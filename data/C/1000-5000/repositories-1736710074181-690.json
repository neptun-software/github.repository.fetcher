{
  "metadata": {
    "timestamp": 1736710074181,
    "page": 690,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cesanta/mjs",
      "stars": 1931,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "build/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.6767578125,
          "content": "Copyright (c) 2013-2018 Cesanta Software Limited\nAll rights reserved\n\nThis software is dual-licensed: you can redistribute it and/or modify\nit under the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation. For the terms of this\nlicense, see <http://www.gnu.org/licenses>.\n\nYou are free to use this software under the terms of the GNU General\nPublic License, but WITHOUT ANY WARRANTY; without even the implied\nwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nSee the GNU General Public License for more details.\n\nAlternatively, you can license this software under a commercial\nlicense, as set out in <https://www.cesanta.com/license>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 7.88671875,
          "content": "MAKEFLAGS += --warn-undefined-variables\nSRCPATH = src\nBUILD_DIR = build\n\nRD ?= docker run -v $(CURDIR):$(CURDIR) --user=$(shell id -u):$(shell id -g) -w $(CURDIR)\nDOCKER_GCC ?= $(RD) mgos/gcc\nDOCKER_CLANG ?= $(RD) mgos/clang\n\ninclude $(SRCPATH)/mjs_sources.mk\n\nTOP_HEADERS = $(addprefix $(SRCPATH)/, $(HEADERS))\nTOP_MJS_PUBLIC_HEADERS = $(addprefix $(SRCPATH)/, $(MJS_PUBLIC_HEADERS))\nTOP_MJS_SOURCES = $(addprefix $(SRCPATH)/, $(MJS_SOURCES))\nTOP_COMMON_SOURCES = $(addprefix $(SRCPATH)/, $(COMMON_SOURCES))\n\nCFLAGS_EXTRA ?=\nMFLAGS += -I. -Isrc -Isrc/frozen\nMFLAGS += -DMJS_MAIN -DMJS_EXPOSE_PRIVATE -DCS_ENABLE_STDIO -DMJS_ENABLE_DEBUG -I../frozen\nMFLAGS += $(CFLAGS_EXTRA)\nCFLAGS += -lm -std=c99 -Wall -Wextra -pedantic -g $(MFLAGS)\nCOMMON_CFLAGS = -DCS_MMAP -DMJS_MODULE_LINES\nASAN_CFLAGS = -fsanitize=address\n\n.PHONY: all test test_full difftest ci-test\n\nVERBOSE ?=\nifeq ($(VERBOSE),1)\nQ :=\nelse\nQ := @\nendif\n\nifeq ($(OS),Windows_NT)\n  UNAME_S := Windows\nelse\n  UNAME_S := $(shell uname -s)\nendif\n\nifeq ($(UNAME_S),Linux)\n  COMMON_CFLAGS += -Wl,--no-as-needed -ldl\n  ASAN_CFLAGS += -fsanitize=leak\nendif\n\nifeq ($(UNAME_S),Darwin)\n  MFLAGS += -D_DARWIN_C_SOURCE\nendif\n\nPROG = $(BUILD_DIR)/mjs\n\nall: mjs.c mjs_no_common.c $(PROG)\n\nTESTUTIL_FILES = $(SRCPATH)/common/cs_dirent.c \\\n                 $(SRCPATH)/common/cs_time.c   \\\n                 $(SRCPATH)/common/test_main.c \\\n                 $(SRCPATH)/common/test_util.c\n\nmjs.h: $(TOP_MJS_PUBLIC_HEADERS) Makefile tools/amalgam.py\n\t@printf \"AMALGAMATING $@\\n\"\n\t$(Q) (tools/amalgam.py \\\n    --autoinc -I src --prefix MJS --strict --license src/mjs_license.h \\\n    --first common/platform.h $(TOP_MJS_PUBLIC_HEADERS)) > $@\n\nmjs.c: $(TOP_COMMON_SOURCES) $(TOP_MJS_SOURCES) mjs.h Makefile\n\t@printf \"AMALGAMATING $@\\n\"\n\t$(Q) (tools/amalgam.py \\\n    --autoinc -I src -I src/frozen --prefix MJS --license src/mjs_license.h \\\n    --license src/mjs_license.h --public-header mjs.h --autoinc-ignore mjs_*_public.h \\\n    --first mjs_common_guard_begin.h,common/platform.h,common/platforms/platform_windows.h,common/platforms/platform_unix.h,common/platforms/platform_esp_lwip.h \\\n    $(TOP_COMMON_SOURCES) $(TOP_MJS_SOURCES)) > $@\n\nmjs_no_common.c: $(TOP_MJS_SOURCES) mjs.h Makefile\n\t@printf \"AMALGAMATING $@\\n\"\n\t$(Q) (tools/amalgam.py \\\n    --autoinc -I src -I src/frozen --prefix MJS --license src/mjs_license.h \\\n    --public-header mjs.h --ignore mjs.h,*common/*,*frozen.[ch] \\\n    --first mjs_common_guard_begin.h,common/platform.h,common/platforms/platform_windows.h,common/platforms/platform_unix.h,common/platforms/platform_esp_lwip.h \\\n    $(TOP_MJS_SOURCES)) > $@\n\nCFLAGS += $(COMMON_CFLAGS)\n\n# NOTE: we compile straight from sources, not from the single amalgamated file,\n# in order to make sure that all sources include the right headers\n$(PROG): $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) $(TOP_HEADERS) $(BUILD_DIR)\n\t$(DOCKER_CLANG) clang $(CFLAGS) $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) -o $(PROG)\n\n$(BUILD_DIR):\n\tmkdir -p $@\n\n$(BUILD_DIR)/%.o: %.c $(TOP_HEADERS) mjs.h\n\t$(CLANG) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<\n\nCOMMON_TEST_FLAGS = -W -Wall -I. -Isrc -g3 -O0 $(COMMON_CFLAGS) $< $(TESTUTIL_FILES) -DMJS_MEMORY_STATS\n\n#include $(REPO_ROOT)/common.mk\n\n# ==== Test Variants ====\n#\n# We want to build tests with various combinations of different compilers and\n# different options. In order to do that, there is some simple makefile magic:\n#\n# There is a function compile_test_with_compiler which takes compiler name, any\n# compile flags, name for the binary, and declares a rule for building that\n# binary.\n#\n# Now, there is a higher level function: compile_test_with_opt, which takes the\n# optimization flag to use, binary name component, and it declares a rule for\n# both clang and for gcc with given optimization flags (by means of the\n# aforementioned compile_test_with_compiler). And there are more higher level\n# function which add more flags, etc etc.\n#\n# ========================================\n# Suppose you want to add more build variants, say with flags -DFOO=1 and\n# -DFOO=2. Here's what you need to do:\n#\n# - Rename compile_test_all to compile_test_with_foo\n# - Inside of your new fancy compile_test_with_foo function, adjust a bit each\n#   invocation of the lower-level function, whatever it is:\n#   to the arg 2, add \"_$2\", and replace empty arg 3 with this: \"$1 $3\".\n# - Write new compile_test_all, which should call your new\n#   compile_test_with_foo, like this:\n#\n#       define compile_test_all\n#       $(eval $(call compile_test_with_foo,-DFOO=1,foo_1,))\n#       $(eval $(call compile_test_with_foo,-DFOO=2,foo_2,))\n#       endef\n#\n# - Done!\n#\n# ========================================\n\n# test variants, will be populated by compile_test, called by\n# compile_test_with_compiler, called by compile_test_with_opt, .... etc\nTEST_VARIANTS =\n\n# params:\n#\n# 1: binary name component, e.g. \"clang_O1_offset_4_whatever_else\"\n# 2: docker image to run compiler and binary in\n# 3: full path to compiler, like \"/usr/bin/clang-3.6\" or \"/usr/bin/gcc\"\n# 4: compiler flags\ndefine compile_test\n$(BUILD_DIR)/unit_test_$1: tests/unit_test.c mjs.c $(TESTUTIL_FILES) $(BUILD_DIR)\n\t@echo BUILDING $$@ with $2[$3], flags: \"'$4'\"\n\t$(RD) --entrypoint $3 $2 $$(COMMON_TEST_FLAGS) $4 -ldl -lm -o $$@\n\t$(RD) --entrypoint ./$$@ $2\n\nTEST_VARIANTS += $(BUILD_DIR)/unit_test_$1\nendef\n\n# params:\n# 1: compiler to use, like \"clang\" or \"gcc\"\n# 2: binary name component, typically the same as compiler: \"clang\" or \"gcc\"\n# 3: additional compiler flags\ndefine compile_test_with_compiler\n$(eval $(call compile_test,$3,$1,$2,$4))\nendef\n\n# params:\n# 1: optimization flag to use, like \"-O0\"\n# 2: binary name component, like \"O0\" or whatever\n# 3: additional compiler flags\ndefine compile_test_with_opt\n$(eval $(call compile_test_with_compiler,mgos/clang,/usr/bin/clang-3.6,clang_$2,$(ASAN_CFLAGS) $1 $3))\n$(eval $(call compile_test_with_compiler,mgos/clang,/usr/bin/clang-3.6,clang_32bit_$2,-m32 $1 $3))\n$(eval $(call compile_test_with_compiler,mgos/gcc,/usr/bin/gcc,gcc_$2,$1 $3))\nendef\n\n# params:\n# 1: flag to use, like \"-DMJS_INIT_OFFSET_SIZE=0\", or just an empty string\n# 2: binary name component, like \"offset_something\"\n# 3: additional compiler flags\ndefine compile_test_with_offset\n$(eval $(call compile_test_with_opt,-O0,O0_$2,$1 $3))\n$(eval $(call compile_test_with_opt,-O1,O1_$2,$1 $3))\n$(eval $(call compile_test_with_opt,-O3,O3_$2,$1 $3))\nendef\n\n\n# params:\n# 1: flag to use, like \"-DMJS_AGGRESSIVE_GC\", or just an empty string\n# 2: binary name component, like \"offset_something\"\n# 3: additional compiler flags\ndefine compile_test_with_aggressive_gc\n$(eval $(call compile_test_with_offset,,offset_def_$2,$1 $3))\n$(eval $(call compile_test_with_offset,-DMJS_INIT_OFFSET_SIZE=0,offset_0_$2,$1 $3))\n$(eval $(call compile_test_with_offset,-DMJS_INIT_OFFSET_SIZE=4,offset_4_$2,$1 $3))\nendef\n\n# compile ALL tests\ndefine compile_test_all\n$(eval $(call compile_test_with_aggressive_gc,-DMJS_AGGRESSIVE_GC,aggressive_gc_$2,$1 $3))\n$(eval $(call compile_test_with_aggressive_gc,,nonaggressive_gc_$2,$1 $3))\nendef\n\n$(eval $(call compile_test_all))\n\n# Run all tests from $(TEST_VARIANTS)\ntest_full: $(TEST_VARIANTS) $(PROG)\n#\tfor f in $(TEST_VARIANTS); do \\\n#    echo ; echo running $$f; \\\n#    $$f; \\\n#  done\n\n# Run just a single test (a first one from $(TEST_VARIANTS))\ntest: $(firstword $(TEST_VARIANTS))\n#\t$<\n\nclean:\n\trm -rf $(BUILD_DIR) *.obj mjs.c mjs.h _CL_*\n\ndifftest:\n\t@TMP=`mktemp -t checkout-diff.XXXXXX`; \\\n\tgit diff  >$$TMP ; \\\n\tif [ -s \"$$TMP\" ]; then echo found diffs in checkout:; git status -s; head -n 50 \"$$TMP\"; exit 1; fi; \\\n\trm $$TMP\n\n###################################  Windows targets for wine, with MSVC6\n\nci-test: $(BUILD_DIR) vc98 vc2017 test_full\n\n$(PROG).exe: $(BUILD_DIR) $(TOP_HEADERS) mjs.c\n\t$(RD) mgos/vc98 wine cl mjs.c $(CLFLAGS) $(MFLAGS) /Fe$@\n\nTEST_SOURCES = tests/unit_test.c $(TESTUTIL_FILES)\nCLFLAGS = /DWIN32_LEAN_AND_MEAN /MD /O1 /TC /W2 /WX /I.. /I. /DNDEBUG /DMJS_MEMORY_STATS\nvc98 vc2017: mjs.c mjs.h\n\t$(RD) mgos/$@ wine cl $(TEST_SOURCES) $(CLFLAGS) /Fe$@.exe\n\t$(RD) mgos/$@ wine ./$@.exe\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.2060546875,
          "content": "mJS: Restricted JavaScript engine\n====================================\n\n[![License](https://img.shields.io/badge/license-GPL_2-green.svg)](https://github.com/cesanta/mjs/blob/master/LICENSE)\n\n# Overview\n\nmJS is designed for microcontrollers with limited resources. Main design\ngoals are: small footprint and simple C/C++ interoperability. mJS\nimplements a strict subset of ES6 (JavaScript version 6):\n\n- Any valid mJS code is a valid ES6 code.\n- Any valid ES6 code is not necessarily a valid mJS code.\n\nOn 32-bit ARM mJS engine takes about 50k of flash memory, and less than 1k\nof RAM (see [intro article](https://mongoose-os.com/blog/mjs-a-new-approach-to-embedded-scripting/)).\nmJS is part of [MongooseOS](https://mongoose-os.com), \nwhere it enables scripting for IoT devices.\n\n# Restrictions\n\n- No standard library. No String, Number, RegExp, Date, Function, etc.\n- **`JSON.parse()`** and **`JSON.stringify()`** are available.\n- No closures, only lexical scoping (i.e. nested functions are allowed).\n- No exceptions.\n- No `new`. In order to create an object with a custom prototype, use\n  **`Object.create()`**, which is available.\n- Strict mode only.\n- No `var`, only `let`.\n- No `for..of`, `=>`, destructors, generators, proxies, promises.\n- No getters, setters, `valueOf`, prototypes, classes, template strings.\n- No `==` or `!=`, only `===` and `!==`.\n- mJS strings are byte strings, not Unicode strings: `'ы'.length === 2`,\n  `'ы'[0] === '\\xd1'`, `'ы'[1] === '\\x8b'`.\n  mJS string can represent any binary data chunk.\n\n# Built-in API\n\n\n<dl>\n  <dt><tt>print(arg1, arg2, ...);</tt></dt>\n  <dd>Print arguments to stdout, separated by space.</dd>\n\n  <dt><tt>load('file.js', obj);</tt></dt>\n  <dd>Execute file <tt>file.js</tt>. <tt>obj</tt> paramenter is\n  optional. <tt>obj</tt> is a global namespace object.\n  If not specified, a current global namespace is passed to the script,\n  which allows <tt>file.js</tt> to modify the current namespace.</dd>\n\n  <dt><tt>die(message);</tt></dt>\n  <dd>Exit interpreter with the given error message</dd>\n\n  <dt><tt>let value = JSON.parse(str);</tt></dt>\n  <dd>Parse JSON string and return parsed value.</dd>\n\n  <dt><tt>let str = JSON.stringify(value);</tt></dt>\n  <dd>Get string representation of the mJS value.</dd>\n\n  <dt><tt>let proto = {foo: 1}; let o = Object.create(proto);</tt></dt>\n  <dd>Create an object with the provided prototype.</dd>\n\n  <dt><tt>'some_string'.slice(start, end);</tt></dt>\n  <dd>Return a substring between two indices. Example:\n      <tt>'abcdef'.slice(1,3) === 'bc';</tt></dd>\n\n  <dt><tt>'abc'.at(0);</tt></dt>\n  <dd>Return numeric byte value at given string index. Example:\n      <tt>'abc'.at(0) === 0x61;</tt></dd>\n\n  <dt><tt>'abc'.indexOf(substr[, fromIndex]);</tt></dt>\n  <dd>Return index of first occurence of substr within the string or `-1`\n  if not found.\n      <tt>'abc'.indexOf('bc') === 1;</tt></dd>\n\n  <dt><tt>chr(n);</tt></dt>\n  <dd>Return 1-byte string whose ASCII code is the integer `n`. If `n` is\n    not numeric or outside of `0-255` range, `null` is returned. Example:\n      <tt>chr(0x61) === 'a';</tt></dd>\n\n  <dt><tt>let a = [1,2,3,4,5]; a.splice(start, deleteCount, ...);</tt></dt>\n  <dd>Change the contents of an array by removing existing elements and/or\n    adding new elements. Example:\n  <tt>let a = [1,2,3,4,5]; a.splice(1, 2, 100, 101, 102); a === [1,100,101,102,4,5];</tt></dd>\n\n  <dt><tt>let s = mkstr(ptrVar, length);</tt></dt>\n  <dd>Create a string backed by a C memory chunk. A string <tt>s</tt> starts\n  at memory location <tt>ptrVar</tt>, and is <tt>length</tt> bytes long.</dd>\n\n  <dt><tt>let s = mkstr(ptrVar, offset, length, copy = false);</tt></dt>\n  <dd>Like `mkstr(ptrVar, length)`, but string <tt>s</tt> starts\n  at memory location <tt>ptrVar + offset</tt>, and the caller can specify\n  whether the string needs to be copied to the internal mjs buffer. By default\n  it's not copied.</dd>\n\n  <dt><tt>let f = ffi('int foo(int)');</tt></dt>\n  <dd>Import C function into mJS. See next section.</dd>\n\n  <dt><tt>gc(full);</tt></dt>\n  <dd>Perform garbage collection. If `full` is `true`, reclaim RAM to OS.</dd>\n</dl>\n\n# C/C++ interoperability\n\nmJS requires no glue code. The mJS's Foreign Function Interface (FFI)\nallows the user to call an existing C function with an arbitrary signature.\nCurrently mJS provides a simple implementation of the FFI trampoline\nthat supports up to 6 32-bit arguments, or up to 2 64-bit arguments:\n\n```javascript\nlet floor = ffi('double floor(double)');\nprint(floor(1.23456));\n```\n\nFunction arguments should be simple: only `int`, `double`, `char *`, `void *`\nare supported. Use `char *` for NUL-terminated C strings, `void *` for any\nother pointers. In order to import more complex functions\n(e.g. the ones that use structures as arguments), write wrappers.\n\n## Callbacks\n\nCallbacks are implemented similarly. Consider that you have a C function\nthat takes a callback and user data `void *` pointer, which should be marked\nas `userdata` in the signature:\n\n```C\nvoid timer(int seconds, void (*callback)(int, void *), void *user_data);\n```\n\nThis is how to make an mJS callback - note the usage of `userdata`:\n\n```javascript\nlet Timer = {\n  set: ffi('void timer(int, void (*)(int, userdata), userdata)')\n};\n\nTimer.set(200, function(t) {\n  print('Time now: ', t);\n}, null);\n```\n\n## Symbol resolver\n\nIn order to make FFI work, mJS must be able to get the address of a C\nfunction by its name. On POSIX systems, `dlsym()` API can do that. On\nWindows, `GetProcAddress()`. On embedded systems, a system resolver should\nbe either manually written, or be implemented with some aid from a firmware\nlinker script. mJS resolver uses `dlsym`-compatible signature.\n\n## Converting structs to objects\n\nmJS provides a helper to facilitate coversion of C structs to JS objects.\nThe functions is called `s2o` and takes two parameters: foreign pointer to\nthe struct and foreign pointer to the struct's descriptor which specifies\nnames and offsets of the struct's members. Here's an simple example:\n\nC/C++ side code:\n```c\n#include \"mjs.h\"\n\nstruct my_struct {\n  int a;\n  const char *b;\n  double c;\n  struct mg_str d;\n  struct mg_str *e;\n  float f;\n  bool g;\n};\n\nstatic const struct mjs_c_struct_member my_struct_descr[] = {\n  {\"a\", offsetof(struct my_struct, a), MJS_STRUCT_FIELD_TYPE_INT, NULL},\n  {\"b\", offsetof(struct my_struct, b), MJS_STRUCT_FIELD_TYPE_CHAR_PTR, NULL},\n  {\"c\", offsetof(struct my_struct, c), MJS_STRUCT_FIELD_TYPE_DOUBLE, NULL},\n  {\"d\", offsetof(struct my_struct, d), MJS_STRUCT_FIELD_TYPE_MG_STR, NULL},\n  {\"e\", offsetof(struct my_struct, e), MJS_STRUCT_FIELD_TYPE_MG_STR_PTR, NULL},\n  {\"f\", offsetof(struct my_struct, f), MJS_STRUCT_FIELD_TYPE_FLOAT, NULL},\n  {\"g\", offsetof(struct my_struct, g), MJS_STRUCT_FIELD_TYPE_BOOL, NULL},\n  {NULL, 0, MJS_STRUCT_FIELD_TYPE_INVALID, NULL},\n};\n\nconst struct mjs_c_struct_member *get_my_struct_descr(void) {\n  return my_struct_descr;\n};\n```\n\nJS side code:\n```js\n// Assuming `s` is a foreign pointer to an instance of `my_struct`, obtained elsewhere.\nlet sd = ffi('void *get_my_struct_descr(void)')();\nlet o = s2o(s, sd);\nprint(o.a, o.b);\n```\n\nNested structs are also supported - use `MJS_STRUCT_FIELD_TYPE_STRUCT` field type\nand provide pointer to the definition:\n\n```c\nstruct my_struct2 {\n  int8_t i8;\n  int16_t i16;\n  uint8_t u8;\n  uint16_t u16;\n};\n\nstatic const struct mjs_c_struct_member my_struct2_descr[] = {\n  {\"i8\", offsetof(struct my_struct2, i8), MJS_STRUCT_FIELD_TYPE_INT8, NULL},\n  {\"i16\", offsetof(struct my_struct2, i16), MJS_STRUCT_FIELD_TYPE_INT16, NULL},\n  {\"u8\", offsetof(struct my_struct2, u8), MJS_STRUCT_FIELD_TYPE_UINT8, NULL},\n  {\"u16\", offsetof(struct my_struct2, u16), MJS_STRUCT_FIELD_TYPE_UINT16, NULL},\n  {NULL, 0, MJS_STRUCT_FIELD_TYPE_INVALID, NULL},\n};\n\nstruct my_struct {\n  struct my_struct2 s;\n  struct my_struct2 *sp;\n};\n\nstatic const struct mjs_c_struct_member my_struct_descr[] = {\n  {\"s\", offsetof(struct my_struct, s), MJS_STRUCT_FIELD_TYPE_STRUCT, my_struct2_descr},\n  {\"sp\", offsetof(struct my_struct, sp), MJS_STRUCT_FIELD_TYPE_STRUCT_PTR, my_struct2_descr},\n  {NULL, 0, MJS_STRUCT_FIELD_TYPE_INVALID, NULL},\n};\n```\n\nFor complicated cases, a custom conversion function can be invoked that returns value:\n```c\nmjs_val_t custom_value_func(struct mjs *mjs, void *ap) {\n  /* Do something with ap, construct and return mjs_val_t */\n}\n\nstatic const struct mjs_c_struct_member my_struct_descr[] = {\n  ...\n  {\"x\", offsetof(struct my_struct, x), MJS_STRUCT_FIELD_TYPE_CUSTOM, custom_value_func},\n  ...\n};\n```\n\n\n# Complete embedding example\n\nWe export C function `foo` to the JS environment and call it from the JS.\n\n```c\n#include \"strings.h\"\n#include \"mjs.h\"\n\nvoid foo(int x) {\n  printf(\"Hello %d!\\n\", x);\n}\n\nvoid *my_dlsym(void *handle, const char *name) {\n  if (strcmp(name, \"foo\") == 0) return foo;\n  return NULL;\n}\n\nint main(void) {\n  struct mjs *mjs = mjs_create();\n  mjs_set_ffi_resolver(mjs, my_dlsym);\n  mjs_exec(mjs, \"let f = ffi('void foo(int)'); f(1234)\", NULL);\n  return 0;\n}\n```\n\nCompile & run:\n\n```\n$ cc main.c mjs.c -o /tmp/x && /tmp/x\nHello 1234!\n```\n\n# Build stand-alone mJS binary\n\nBuild:\n```\n$ make\n```\n\nUse as a simple calculator:\n```\n$ ./build/mjs -e '1 + 2 * 3'\n7\n```\n\nFFI standard C functions:\n```\n$ ./build/mjs -e 'ffi(\"double sin(double)\")(1.23)'\n0.942489\n```\n\nView generated bytecode:\n```\n$ ./build/mjs -l 3 -e '2 + 2'\n------- MJS VM DUMP BEGIN\n    DATA_STACK (0 elems):\n    CALL_STACK (0 elems):\n        SCOPES (1 elems):  [<object>]\n  LOOP_OFFSETS (0 elems):\n  CODE:\n  0   BCODE_HDR [<stdin>] size:28\n  21  PUSH_INT  2\n  23  PUSH_INT  2\n  25  EXPR      +\n  27  EXIT\n  28  NOP\n------- MJS VM DUMP END\n4\n```\n\nThe stand-alone binary uses `dlsym()` symbol resolver, that's why\n`ffi(\"double sin(double)\")(1.23)` works.\n\n# Licensing\n\nmJS is released under commercial and\n[GNU GPL v.2](http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\nopen source licenses.\n\nCommercial Projects: once your project becomes commercialised, GPLv2 licensing\ndictates that you need to either open your source fully or purchase a\ncommercial license. Cesanta offer full, royalty-free commercial licenses\nwithout any GPL restrictions. If your needs require a custom license, we’d be\nhappy to work on a solution with you.\n[Contact us for pricing](https://mongoose-os.com/contact.html)\n\nPrototyping: While your project is still in prototyping stage and not for sale,\nyou can use MJS’s open source code without license restrictions.\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "mjs.c",
          "type": "blob",
          "size": 399.916015625,
          "content": "/*\n * Copyright (c) 2017 Cesanta Software Limited\n * All rights reserved\n *\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n#include \"mjs.h\"\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platform.h\"\n#endif\n#ifndef CS_COMMON_PLATFORM_H_\n#define CS_COMMON_PLATFORM_H_\n\n/*\n * For the \"custom\" platform, includes and dependencies can be\n * provided through mg_locals.h.\n */\n#define CS_P_CUSTOM 0\n#define CS_P_UNIX 1\n#define CS_P_WINDOWS 2\n#define CS_P_ESP32 15\n#define CS_P_ESP8266 3\n#define CS_P_CC3100 6\n#define CS_P_CC3200 4\n#define CS_P_CC3220 17\n#define CS_P_MSP432 5\n#define CS_P_TM4C129 14\n#define CS_P_MBED 7\n#define CS_P_WINCE 8\n#define CS_P_NXP_LPC 13\n#define CS_P_NXP_KINETIS 9\n#define CS_P_NRF51 12\n#define CS_P_NRF52 10\n#define CS_P_PIC32 11\n#define CS_P_RS14100 18\n#define CS_P_STM32 16\n/* Next id: 19 */\n\n/* If not specified explicitly, we guess platform by defines. */\n#ifndef CS_PLATFORM\n\n#if defined(TARGET_IS_MSP432P4XX) || defined(__MSP432P401R__)\n#define CS_PLATFORM CS_P_MSP432\n#elif defined(cc3200) || defined(TARGET_IS_CC3200)\n#define CS_PLATFORM CS_P_CC3200\n#elif defined(cc3220) || defined(TARGET_IS_CC3220)\n#define CS_PLATFORM CS_P_CC3220\n#elif defined(__unix__) || defined(__APPLE__)\n#define CS_PLATFORM CS_P_UNIX\n#elif defined(WINCE)\n#define CS_PLATFORM CS_P_WINCE\n#elif defined(_WIN32)\n#define CS_PLATFORM CS_P_WINDOWS\n#elif defined(__MBED__)\n#define CS_PLATFORM CS_P_MBED\n#elif defined(__USE_LPCOPEN)\n#define CS_PLATFORM CS_P_NXP_LPC\n#elif defined(FRDM_K64F) || defined(FREEDOM)\n#define CS_PLATFORM CS_P_NXP_KINETIS\n#elif defined(PIC32)\n#define CS_PLATFORM CS_P_PIC32\n#elif defined(ESP_PLATFORM)\n#define CS_PLATFORM CS_P_ESP32\n#elif defined(ICACHE_FLASH)\n#define CS_PLATFORM CS_P_ESP8266\n#elif defined(TARGET_IS_TM4C129_RA0) || defined(TARGET_IS_TM4C129_RA1) || \\\n    defined(TARGET_IS_TM4C129_RA2)\n#define CS_PLATFORM CS_P_TM4C129\n#elif defined(RS14100)\n#define CS_PLATFORM CS_P_RS14100\n#elif defined(STM32)\n#define CS_PLATFORM CS_P_STM32\n#endif\n\n#ifndef CS_PLATFORM\n#error \"CS_PLATFORM is not specified and we couldn't guess it.\"\n#endif\n\n#endif /* !defined(CS_PLATFORM) */\n\n#define MG_NET_IF_SOCKET 1\n#define MG_NET_IF_SIMPLELINK 2\n#define MG_NET_IF_LWIP_LOW_LEVEL 3\n#define MG_NET_IF_PIC32 4\n#define MG_NET_IF_NULL 5\n\n#define MG_SSL_IF_OPENSSL 1\n#define MG_SSL_IF_MBEDTLS 2\n#define MG_SSL_IF_SIMPLELINK 3\n\n/* Amalgamated: #include \"common/platforms/platform_unix.h\" */\n/* Amalgamated: #include \"common/platforms/platform_windows.h\" */\n/* Amalgamated: #include \"common/platforms/platform_esp32.h\" */\n/* Amalgamated: #include \"common/platforms/platform_esp8266.h\" */\n/* Amalgamated: #include \"common/platforms/platform_cc3100.h\" */\n/* Amalgamated: #include \"common/platforms/platform_cc3200.h\" */\n/* Amalgamated: #include \"common/platforms/platform_cc3220.h\" */\n/* Amalgamated: #include \"common/platforms/platform_mbed.h\" */\n/* Amalgamated: #include \"common/platforms/platform_nrf51.h\" */\n/* Amalgamated: #include \"common/platforms/platform_nrf52.h\" */\n/* Amalgamated: #include \"common/platforms/platform_wince.h\" */\n/* Amalgamated: #include \"common/platforms/platform_nxp_lpc.h\" */\n/* Amalgamated: #include \"common/platforms/platform_nxp_kinetis.h\" */\n/* Amalgamated: #include \"common/platforms/platform_pic32.h\" */\n/* Amalgamated: #include \"common/platforms/platform_rs14100.h\" */\n/* Amalgamated: #include \"common/platforms/platform_stm32.h\" */\n#if CS_PLATFORM == CS_P_CUSTOM\n#include <platform_custom.h>\n#endif\n\n/* Common stuff */\n\n#if !defined(PRINTF_LIKE)\n#if defined(__GNUC__) || defined(__clang__) || defined(__TI_COMPILER_VERSION__)\n#define PRINTF_LIKE(f, a) __attribute__((format(printf, f, a)))\n#else\n#define PRINTF_LIKE(f, a)\n#endif\n#endif\n\n#if !defined(WEAK)\n#if (defined(__GNUC__) || defined(__clang__) || \\\n     defined(__TI_COMPILER_VERSION__)) &&       \\\n    !defined(_WIN32)\n#define WEAK __attribute__((weak))\n#else\n#define WEAK\n#endif\n#endif\n\n#ifdef __GNUC__\n#define NORETURN __attribute__((noreturn))\n#define NOINLINE __attribute__((noinline))\n#define WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#define NOINSTR __attribute__((no_instrument_function))\n#define DO_NOT_WARN_UNUSED __attribute__((unused))\n#else\n#define NORETURN\n#define NOINLINE\n#define WARN_UNUSED_RESULT\n#define NOINSTR\n#define DO_NOT_WARN_UNUSED\n#endif /* __GNUC__ */\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n#endif\n\n#endif /* CS_COMMON_PLATFORM_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_windows.h\"\n#endif\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_WINDOWS_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_WINDOWS_H_\n#if CS_PLATFORM == CS_P_WINDOWS\n\n/*\n * MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)\n * MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)\n * MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)\n * MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)\n * MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)\n * MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)\n * MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)\n * MSVC++ 7.0  _MSC_VER == 1300\n * MSVC++ 6.0  _MSC_VER == 1200\n * MSVC++ 5.0  _MSC_VER == 1100\n */\n#ifdef _MSC_VER\n#pragma warning(disable : 4127) /* FD_SET() emits warning, disable it */\n#pragma warning(disable : 4204) /* missing c99 support */\n#endif\n\n#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\n#define _WINSOCK_DEPRECATED_NO_WARNINGS 1\n#endif\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <assert.h>\n#include <direct.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <io.h>\n#include <limits.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <ctype.h>\n\n#ifdef _MSC_VER\n#pragma comment(lib, \"ws2_32.lib\") /* Linking with winsock library */\n#endif\n\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n#include <process.h>\n\n#if defined(_MSC_VER) && (_MSC_VER < 1700)\ntypedef int bool;\n#else\n#include <stdbool.h>\n#endif\n\n#if defined(_MSC_VER) && _MSC_VER >= 1800\n#define strdup _strdup\n#endif\n\n#ifndef EINPROGRESS\n#define EINPROGRESS WSAEINPROGRESS\n#endif\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif\n#ifndef __func__\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#endif\n#define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#define to64(x) _atoi64(x)\n#if !defined(__MINGW32__) && !defined(__MINGW64__)\n#define popen(x, y) _popen((x), (y))\n#define pclose(x) _pclose(x)\n#define fileno _fileno\n#endif\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n#define fseeko(x, y, z) _fseeki64((x), (y), (z))\n#else\n#define fseeko(x, y, z) fseek((x), (y), (z))\n#endif\n#if defined(_MSC_VER) && _MSC_VER <= 1200\ntypedef unsigned long uintptr_t;\ntypedef long intptr_t;\n#endif\ntypedef int socklen_t;\n#if _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#endif\ntypedef SOCKET sock_t;\ntypedef uint32_t in_addr_t;\n#ifndef UINT16_MAX\n#define UINT16_MAX 65535\n#endif\n#ifndef UINT32_MAX\n#define UINT32_MAX 4294967295\n#endif\n#ifndef pid_t\n#define pid_t HANDLE\n#endif\n#define INT64_FMT \"I64d\"\n#define INT64_X_FMT \"I64x\"\n#define SIZE_T_FMT \"Iu\"\ntypedef struct _stati64 cs_stat_t;\n#ifndef S_ISDIR\n#define S_ISDIR(x) (((x) &_S_IFMT) == _S_IFDIR)\n#endif\n#ifndef S_ISREG\n#define S_ISREG(x) (((x) &_S_IFMT) == _S_IFREG)\n#endif\n#define DIRSEP '\\\\'\n#define CS_DEFINE_DIRENT\n\n#ifndef va_copy\n#ifdef __va_copy\n#define va_copy __va_copy\n#else\n#define va_copy(x, y) (x) = (y)\n#endif\n#endif\n\n#ifndef MG_MAX_HTTP_REQUEST_SIZE\n#define MG_MAX_HTTP_REQUEST_SIZE 8192\n#endif\n\n#ifndef MG_MAX_HTTP_SEND_MBUF\n#define MG_MAX_HTTP_SEND_MBUF 4096\n#endif\n\n#ifndef MG_MAX_HTTP_HEADERS\n#define MG_MAX_HTTP_HEADERS 40\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifndef MG_ENABLE_BROADCAST\n#define MG_ENABLE_BROADCAST 1\n#endif\n\n#ifndef MG_ENABLE_DIRECTORY_LISTING\n#define MG_ENABLE_DIRECTORY_LISTING 1\n#endif\n\n#ifndef MG_ENABLE_FILESYSTEM\n#define MG_ENABLE_FILESYSTEM 1\n#endif\n\n#ifndef MG_ENABLE_HTTP_CGI\n#define MG_ENABLE_HTTP_CGI MG_ENABLE_FILESYSTEM\n#endif\n\n#ifndef MG_NET_IF\n#define MG_NET_IF MG_NET_IF_SOCKET\n#endif\n\nunsigned int sleep(unsigned int seconds);\n\n/* https://stackoverflow.com/questions/16647819/timegm-cross-platform */\n#define timegm _mkgmtime\n\n#define gmtime_r(a, b) \\\n  do {                 \\\n    *(b) = *gmtime(a); \\\n  } while (0)\n\n#endif /* CS_PLATFORM == CS_P_WINDOWS */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_WINDOWS_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_unix.h\"\n#endif\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_UNIX_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_UNIX_H_\n#if CS_PLATFORM == CS_P_UNIX\n\n#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 600\n#endif\n\n/* <inttypes.h> wants this for C++ */\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n\n/* C++ wants that for INT64_MAX */\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n\n/* Enable fseeko() and ftello() functions */\n#ifndef _LARGEFILE_SOURCE\n#define _LARGEFILE_SOURCE\n#endif\n\n/* Enable 64-bit file offsets */\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n\n#include <arpa/inet.h>\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <limits.h>\n#include <math.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifdef __APPLE__\n#include <machine/endian.h>\n#ifndef BYTE_ORDER\n#define LITTLE_ENDIAN __DARWIN_LITTLE_ENDIAN\n#define BIG_ENDIAN __DARWIN_BIG_ENDIAN\n#define PDP_ENDIAN __DARWIN_PDP_ENDIAN\n#define BYTE_ORDER __DARWIN_BYTE_ORDER\n#endif\n#endif\n\n/*\n * osx correctly avoids defining strtoll when compiling in strict ansi mode.\n * c++ 11 standard defines strtoll as well.\n * We require strtoll, and if your embedded pre-c99 compiler lacks one, please\n * implement a shim.\n */\n#if !(defined(__cplusplus) && __cplusplus >= 201103L) && \\\n    !(defined(__DARWIN_C_LEVEL) && __DARWIN_C_LEVEL >= 200809L)\nlong long strtoll(const char *, char **, int);\n#endif\n\ntypedef int sock_t;\n#define INVALID_SOCKET (-1)\n#define SIZE_T_FMT \"zu\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n\n#ifndef __cdecl\n#define __cdecl\n#endif\n\n#ifndef va_copy\n#ifdef __va_copy\n#define va_copy __va_copy\n#else\n#define va_copy(x, y) (x) = (y)\n#endif\n#endif\n\n#define closesocket(x) close(x)\n\n#ifndef MG_MAX_HTTP_REQUEST_SIZE\n#define MG_MAX_HTTP_REQUEST_SIZE 8192\n#endif\n\n#ifndef MG_MAX_HTTP_SEND_MBUF\n#define MG_MAX_HTTP_SEND_MBUF 4096\n#endif\n\n#ifndef MG_MAX_HTTP_HEADERS\n#define MG_MAX_HTTP_HEADERS 40\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifndef MG_ENABLE_BROADCAST\n#define MG_ENABLE_BROADCAST 1\n#endif\n\n#ifndef MG_ENABLE_DIRECTORY_LISTING\n#define MG_ENABLE_DIRECTORY_LISTING 1\n#endif\n\n#ifndef MG_ENABLE_FILESYSTEM\n#define MG_ENABLE_FILESYSTEM 1\n#endif\n\n#ifndef MG_ENABLE_HTTP_CGI\n#define MG_ENABLE_HTTP_CGI MG_ENABLE_FILESYSTEM\n#endif\n\n#ifndef MG_NET_IF\n#define MG_NET_IF MG_NET_IF_SOCKET\n#endif\n\n#ifndef MG_HOSTS_FILE_NAME\n#define MG_HOSTS_FILE_NAME \"/etc/hosts\"\n#endif\n\n#ifndef MG_RESOLV_CONF_FILE_NAME\n#define MG_RESOLV_CONF_FILE_NAME \"/etc/resolv.conf\"\n#endif\n\n#endif /* CS_PLATFORM == CS_P_UNIX */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_UNIX_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_esp32.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_ESP32_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_ESP32_H_\n#if CS_PLATFORM == CS_P_ESP32\n\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <machine/endian.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define __cdecl\n#define _FILE_OFFSET_BITS 32\n\n#define MG_LWIP 1\n\n#ifndef MG_NET_IF\n#define MG_NET_IF MG_NET_IF_SOCKET\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#endif /* CS_PLATFORM == CS_P_ESP32 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_ESP32_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_esp8266.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_ESP8266_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_ESP8266_H_\n#if CS_PLATFORM == CS_P_ESP8266\n\n#include <assert.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <machine/endian.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n#if !defined(MGOS_VFS_DEFINE_DIRENT)\n#define CS_DEFINE_DIRENT\n#endif\n\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define __cdecl\n#define _FILE_OFFSET_BITS 32\n\n#define MG_LWIP 1\n\n/* struct timeval is defined in sys/time.h. */\n#define LWIP_TIMEVAL_PRIVATE 0\n\n#ifndef MG_NET_IF\n#include <lwip/opt.h>\n#if LWIP_SOCKET /* RTOS SDK has LWIP sockets */\n#define MG_NET_IF MG_NET_IF_SOCKET\n#else\n#define MG_NET_IF MG_NET_IF_LWIP_LOW_LEVEL\n#endif\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#define inet_ntop(af, src, dst, size)                                          \\\n  (((af) == AF_INET) ? ipaddr_ntoa_r((const ip_addr_t *) (src), (dst), (size)) \\\n                     : NULL)\n#define inet_pton(af, src, dst) \\\n  (((af) == AF_INET) ? ipaddr_aton((src), (ip_addr_t *) (dst)) : 0)\n\n#endif /* CS_PLATFORM == CS_P_ESP8266 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_ESP8266_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_cc3100.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_CC3100_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_CC3100_H_\n#if CS_PLATFORM == CS_P_CC3100\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\n#define MG_NET_IF MG_NET_IF_SIMPLELINK\n#define MG_SSL_IF MG_SSL_IF_SIMPLELINK\n\n/*\n * CC3100 SDK and STM32 SDK include headers w/out path, just like\n * #include \"simplelink.h\". As result, we have to add all required directories\n * into Makefile IPATH and do the same thing (include w/out path)\n */\n\n#include <simplelink.h>\n#include <netapp.h>\n#undef timeval\n\ntypedef int sock_t;\n#define INVALID_SOCKET (-1)\n\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define SIZE_T_FMT \"u\"\n\n#define SOMAXCONN 8\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\nchar *inet_ntoa(struct in_addr in);\nint inet_pton(int af, const char *src, void *dst);\n\n#endif /* CS_PLATFORM == CS_P_CC3100 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_CC3100_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/simplelink/cs_simplelink.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_SIMPLELINK_CS_SIMPLELINK_H_\n#define CS_COMMON_PLATFORMS_SIMPLELINK_CS_SIMPLELINK_H_\n\n#if defined(MG_NET_IF) && MG_NET_IF == MG_NET_IF_SIMPLELINK\n\n/* If simplelink.h is already included, all bets are off. */\n#if !defined(__SIMPLELINK_H__)\n\n#include <stdbool.h>\n\n#ifndef __TI_COMPILER_VERSION__\n#undef __CONCAT\n#undef FD_CLR\n#undef FD_ISSET\n#undef FD_SET\n#undef FD_SETSIZE\n#undef FD_ZERO\n#undef fd_set\n#endif\n\n#if CS_PLATFORM == CS_P_CC3220\n#include <ti/drivers/net/wifi/porting/user.h>\n#include <ti/drivers/net/wifi/simplelink.h>\n#include <ti/drivers/net/wifi/sl_socket.h>\n#include <ti/drivers/net/wifi/netapp.h>\n#else\n/* We want to disable SL_INC_STD_BSD_API_NAMING, so we include user.h ourselves\n * and undef it. */\n#define PROVISIONING_API_H_\n#include <simplelink/user.h>\n#undef PROVISIONING_API_H_\n#undef SL_INC_STD_BSD_API_NAMING\n\n#include <simplelink/include/simplelink.h>\n#include <simplelink/include/netapp.h>\n#endif /* CS_PLATFORM == CS_P_CC3220 */\n\n/* Now define only the subset of the BSD API that we use.\n * Notably, close(), read() and write() are not defined. */\n#define AF_INET SL_AF_INET\n\n#define socklen_t SlSocklen_t\n#define sockaddr SlSockAddr_t\n#define sockaddr_in SlSockAddrIn_t\n#define in_addr SlInAddr_t\n\n#define SOCK_STREAM SL_SOCK_STREAM\n#define SOCK_DGRAM SL_SOCK_DGRAM\n\n#define htonl sl_Htonl\n#define ntohl sl_Ntohl\n#define htons sl_Htons\n#define ntohs sl_Ntohs\n\n#ifndef EACCES\n#define EACCES SL_EACCES\n#endif\n#ifndef EAFNOSUPPORT\n#define EAFNOSUPPORT SL_EAFNOSUPPORT\n#endif\n#ifndef EAGAIN\n#define EAGAIN SL_EAGAIN\n#endif\n#ifndef EBADF\n#define EBADF SL_EBADF\n#endif\n#ifndef EINVAL\n#define EINVAL SL_EINVAL\n#endif\n#ifndef ENOMEM\n#define ENOMEM SL_ENOMEM\n#endif\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK SL_EWOULDBLOCK\n#endif\n\n#define SOMAXCONN 8\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\nchar *inet_ntoa(struct in_addr in);\nint inet_pton(int af, const char *src, void *dst);\n\nstruct mg_mgr;\nstruct mg_connection;\n\ntypedef void (*mg_init_cb)(struct mg_mgr *mgr);\nbool mg_start_task(int priority, int stack_size, mg_init_cb mg_init);\n\nvoid mg_run_in_task(void (*cb)(struct mg_mgr *mgr, void *arg), void *cb_arg);\n\nint sl_fs_init(void);\n\nvoid sl_restart_cb(struct mg_mgr *mgr);\n\nint sl_set_ssl_opts(int sock, struct mg_connection *nc);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !defined(__SIMPLELINK_H__) */\n\n/* Compatibility with older versions of SimpleLink */\n#if SL_MAJOR_VERSION_NUM < 2\n\n#define SL_ERROR_BSD_EAGAIN SL_EAGAIN\n#define SL_ERROR_BSD_EALREADY SL_EALREADY\n#define SL_ERROR_BSD_ENOPROTOOPT SL_ENOPROTOOPT\n#define SL_ERROR_BSD_ESECDATEERROR SL_ESECDATEERROR\n#define SL_ERROR_BSD_ESECSNOVERIFY SL_ESECSNOVERIFY\n#define SL_ERROR_FS_FAILED_TO_ALLOCATE_MEM SL_FS_ERR_FAILED_TO_ALLOCATE_MEM\n#define SL_ERROR_FS_FILE_HAS_NOT_BEEN_CLOSE_CORRECTLY \\\n  SL_FS_FILE_HAS_NOT_BEEN_CLOSE_CORRECTLY\n#define SL_ERROR_FS_FILE_NAME_EXIST SL_FS_FILE_NAME_EXIST\n#define SL_ERROR_FS_FILE_NOT_EXISTS SL_FS_ERR_FILE_NOT_EXISTS\n#define SL_ERROR_FS_NO_AVAILABLE_NV_INDEX SL_FS_ERR_NO_AVAILABLE_NV_INDEX\n#define SL_ERROR_FS_NOT_ENOUGH_STORAGE_SPACE SL_FS_ERR_NO_AVAILABLE_BLOCKS\n#define SL_ERROR_FS_NOT_SUPPORTED SL_FS_ERR_NOT_SUPPORTED\n#define SL_ERROR_FS_WRONG_FILE_NAME SL_FS_WRONG_FILE_NAME\n#define SL_ERROR_FS_INVALID_HANDLE SL_FS_ERR_INVALID_HANDLE\n#define SL_NETCFG_MAC_ADDRESS_GET SL_MAC_ADDRESS_GET\n#define SL_SOCKET_FD_ZERO SL_FD_ZERO\n#define SL_SOCKET_FD_SET SL_FD_SET\n#define SL_SOCKET_FD_ISSET SL_FD_ISSET\n#define SL_SO_SECURE_DOMAIN_NAME_VERIFICATION SO_SECURE_DOMAIN_NAME_VERIFICATION\n\n#define SL_FS_READ FS_MODE_OPEN_READ\n#define SL_FS_WRITE FS_MODE_OPEN_WRITE\n\n#define SL_FI_FILE_SIZE(fi) ((fi).FileLen)\n#define SL_FI_FILE_MAX_SIZE(fi) ((fi).AllocatedLen)\n\n#define SlDeviceVersion_t SlVersionFull\n#define sl_DeviceGet sl_DevGet\n#define SL_DEVICE_GENERAL SL_DEVICE_GENERAL_CONFIGURATION\n#define SL_LEN_TYPE _u8\n#define SL_OPT_TYPE _u8\n\n#else /* SL_MAJOR_VERSION_NUM >= 2 */\n\n#define FS_MODE_OPEN_CREATE(max_size, flag) \\\n  (SL_FS_CREATE | SL_FS_CREATE_MAX_SIZE(max_size))\n#define SL_FI_FILE_SIZE(fi) ((fi).Len)\n#define SL_FI_FILE_MAX_SIZE(fi) ((fi).MaxSize)\n\n#define SL_LEN_TYPE _u16\n#define SL_OPT_TYPE _u16\n\n#endif /* SL_MAJOR_VERSION_NUM < 2 */\n\nint slfs_open(const unsigned char *fname, uint32_t flags, uint32_t *token);\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK */\n\n#endif /* CS_COMMON_PLATFORMS_SIMPLELINK_CS_SIMPLELINK_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_cc3200.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_\n#if CS_PLATFORM == CS_P_CC3200\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\n#ifndef __TI_COMPILER_VERSION__\n#include <fcntl.h>\n#include <sys/time.h>\n#endif\n\n#define MG_NET_IF MG_NET_IF_SIMPLELINK\n#define MG_SSL_IF MG_SSL_IF_SIMPLELINK\n\n/* Only SPIFFS supports directories, SLFS does not. */\n#if defined(CC3200_FS_SPIFFS) && !defined(MG_ENABLE_DIRECTORY_LISTING)\n#define MG_ENABLE_DIRECTORY_LISTING 1\n#endif\n\n/* Amalgamated: #include \"common/platforms/simplelink/cs_simplelink.h\" */\n\ntypedef int sock_t;\n#define INVALID_SOCKET (-1)\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define __cdecl\n\n#define fileno(x) -1\n\n/* Some functions we implement for Mongoose. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __TI_COMPILER_VERSION__\nstruct SlTimeval_t;\n#define timeval SlTimeval_t\nint gettimeofday(struct timeval *t, void *tz);\nint settimeofday(const struct timeval *tv, const void *tz);\n\nint asprintf(char **strp, const char *fmt, ...);\n\n#endif\n\n/* TI's libc does not have stat & friends, add them. */\n#ifdef __TI_COMPILER_VERSION__\n\n#include <file.h>\n\ntypedef unsigned int mode_t;\ntypedef size_t _off_t;\ntypedef long ssize_t;\n\nstruct stat {\n  int st_ino;\n  mode_t st_mode;\n  int st_nlink;\n  time_t st_mtime;\n  off_t st_size;\n};\n\nint _stat(const char *pathname, struct stat *st);\nint stat(const char *pathname, struct stat *st);\n\n#define __S_IFMT 0170000\n\n#define __S_IFDIR 0040000\n#define __S_IFCHR 0020000\n#define __S_IFREG 0100000\n\n#define __S_ISTYPE(mode, mask) (((mode) &__S_IFMT) == (mask))\n\n#define S_IFDIR __S_IFDIR\n#define S_IFCHR __S_IFCHR\n#define S_IFREG __S_IFREG\n#define S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)\n#define S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)\n\n/* 5.x series compilers don't have va_copy, 16.x do. */\n#if __TI_COMPILER_VERSION__ < 16000000\n#define va_copy(apc, ap) ((apc) = (ap))\n#endif\n\n#endif /* __TI_COMPILER_VERSION__ */\n\n#ifdef CC3200_FS_SLFS\n#define MG_FS_SLFS\n#endif\n\n#if (defined(CC3200_FS_SPIFFS) || defined(CC3200_FS_SLFS)) && \\\n    !defined(MG_ENABLE_FILESYSTEM)\n#define MG_ENABLE_FILESYSTEM 1\n#define CS_DEFINE_DIRENT\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_PLATFORM == CS_P_CC3200 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_cc3220.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_CC3220_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_CC3220_H_\n#if CS_PLATFORM == CS_P_CC3220\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\n#ifndef __TI_COMPILER_VERSION__\n#include <fcntl.h>\n#include <sys/time.h>\n#endif\n\n#define MG_NET_IF MG_NET_IF_SIMPLELINK\n#ifndef MG_SSL_IF\n#define MG_SSL_IF MG_SSL_IF_SIMPLELINK\n#endif\n\n/* Only SPIFFS supports directories, SLFS does not. */\n#if defined(CC3220_FS_SPIFFS) && !defined(MG_ENABLE_DIRECTORY_LISTING)\n#define MG_ENABLE_DIRECTORY_LISTING 1\n#endif\n\n/* Amalgamated: #include \"common/platforms/simplelink/cs_simplelink.h\" */\n\ntypedef int sock_t;\n#define INVALID_SOCKET (-1)\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define __cdecl\n\n#define fileno(x) -1\n\n/* Some functions we implement for Mongoose. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __TI_COMPILER_VERSION__\nstruct SlTimeval_t;\n#define timeval SlTimeval_t\nint gettimeofday(struct timeval *t, void *tz);\nint settimeofday(const struct timeval *tv, const void *tz);\n\nint asprintf(char **strp, const char *fmt, ...);\n\n#endif\n\n/* TI's libc does not have stat & friends, add them. */\n#ifdef __TI_COMPILER_VERSION__\n\n#include <file.h>\n\ntypedef unsigned int mode_t;\ntypedef size_t _off_t;\ntypedef long ssize_t;\n\nstruct stat {\n  int st_ino;\n  mode_t st_mode;\n  int st_nlink;\n  time_t st_mtime;\n  off_t st_size;\n};\n\nint _stat(const char *pathname, struct stat *st);\nint stat(const char *pathname, struct stat *st);\n\n#define __S_IFMT 0170000\n\n#define __S_IFDIR 0040000\n#define __S_IFCHR 0020000\n#define __S_IFREG 0100000\n\n#define __S_ISTYPE(mode, mask) (((mode) &__S_IFMT) == (mask))\n\n#define S_IFDIR __S_IFDIR\n#define S_IFCHR __S_IFCHR\n#define S_IFREG __S_IFREG\n#define S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)\n#define S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)\n\n#endif /* __TI_COMPILER_VERSION__ */\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_PLATFORM == CS_P_CC3220 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_mbed.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_MBED_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_MBED_H_\n#if CS_PLATFORM == CS_P_MBED\n\n/*\n * mbed.h contains C++ code (e.g. templates), thus, it should be processed\n * only if included directly to startup file (ex: main.cpp)\n */\n#ifdef __cplusplus\n/* Amalgamated: #include \"mbed.h\" */\n#endif /* __cplusplus */\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdio.h>\n\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n/*\n * mbed can be compiled with the ARM compiler which\n * just doesn't come with a gettimeofday shim\n * because it's a BSD API and ARM targets embedded\n * non-unix platforms.\n */\n#if defined(__ARMCC_VERSION) || defined(__ICCARM__)\n#define _TIMEVAL_DEFINED\n#define gettimeofday _gettimeofday\n\n/* copied from GCC on ARM; for some reason useconds are signed */\ntypedef long suseconds_t; /* microseconds (signed) */\nstruct timeval {\n  time_t tv_sec;       /* seconds */\n  suseconds_t tv_usec; /* and microseconds */\n};\n\n#endif\n\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK\n\n#define MG_SIMPLELINK_NO_OSI 1\n\n#include <simplelink.h>\n\ntypedef int sock_t;\n#define INVALID_SOCKET (-1)\n\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT PRId64\n#define INT64_X_FMT PRIx64\n#define SIZE_T_FMT \"u\"\n\n#define SOMAXCONN 8\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\nchar *inet_ntoa(struct in_addr in);\nint inet_pton(int af, const char *src, void *dst);\nint inet_aton(const char *cp, struct in_addr *inp);\nin_addr_t inet_addr(const char *cp);\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK */\n\n#endif /* CS_PLATFORM == CS_P_MBED */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_MBED_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_nrf51.h\"\n#endif\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_NRF51_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_NRF51_H_\n#if CS_PLATFORM == CS_P_NRF51\n\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\n#define to64(x) strtoll(x, NULL, 10)\n\n#define MG_NET_IF MG_NET_IF_LWIP_LOW_LEVEL\n#define MG_LWIP 1\n#define MG_ENABLE_IPV6 1\n\n/*\n * For ARM C Compiler, make lwip to export `struct timeval`; for other\n * compilers, suppress it.\n */\n#if !defined(__ARMCC_VERSION)\n#define LWIP_TIMEVAL_PRIVATE 0\n#else\nstruct timeval;\nint gettimeofday(struct timeval *tp, void *tzp);\n#endif\n\n#define INT64_FMT PRId64\n#define SIZE_T_FMT \"u\"\n\n/*\n * ARM C Compiler doesn't have strdup, so we provide it\n */\n#define CS_ENABLE_STRDUP defined(__ARMCC_VERSION)\n\n#endif /* CS_PLATFORM == CS_P_NRF51 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_NRF51_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_nrf52.h\"\n#endif\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_NRF52_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_NRF52_H_\n#if CS_PLATFORM == CS_P_NRF52\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\n#define to64(x) strtoll(x, NULL, 10)\n\n#define MG_NET_IF MG_NET_IF_LWIP_LOW_LEVEL\n#define MG_LWIP 1\n#define MG_ENABLE_IPV6 1\n\n#if !defined(ENOSPC)\n#define ENOSPC 28 /* No space left on device */\n#endif\n\n/*\n * For ARM C Compiler, make lwip to export `struct timeval`; for other\n * compilers, suppress it.\n */\n#if !defined(__ARMCC_VERSION)\n#define LWIP_TIMEVAL_PRIVATE 0\n#endif\n\n#define INT64_FMT PRId64\n#define SIZE_T_FMT \"u\"\n\n/*\n * ARM C Compiler doesn't have strdup, so we provide it\n */\n#define CS_ENABLE_STRDUP defined(__ARMCC_VERSION)\n\n#endif /* CS_PLATFORM == CS_P_NRF52 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_NRF52_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_wince.h\"\n#endif\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_WINCE_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_WINCE_H_\n\n#if CS_PLATFORM == CS_P_WINCE\n\n/*\n * MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)\n * MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)\n * MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)\n * MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)\n * MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)\n * MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)\n * MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)\n * MSVC++ 7.0  _MSC_VER == 1300\n * MSVC++ 6.0  _MSC_VER == 1200\n * MSVC++ 5.0  _MSC_VER == 1100\n */\n#pragma warning(disable : 4127) /* FD_SET() emits warning, disable it */\n#pragma warning(disable : 4204) /* missing c99 support */\n\n#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\n#define _WINSOCK_DEPRECATED_NO_WARNINGS 1\n#endif\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <assert.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#pragma comment(lib, \"ws2.lib\") /* Linking with WinCE winsock library */\n\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n\n#define strdup _strdup\n\n#ifndef EINPROGRESS\n#define EINPROGRESS WSAEINPROGRESS\n#endif\n\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif\n\n#ifndef EAGAIN\n#define EAGAIN EWOULDBLOCK\n#endif\n\n#ifndef __func__\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#endif\n\n#define snprintf _snprintf\n#define fileno _fileno\n#define vsnprintf _vsnprintf\n#define sleep(x) Sleep((x) *1000)\n#define to64(x) _atoi64(x)\n#define rmdir _rmdir\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n#define fseeko(x, y, z) _fseeki64((x), (y), (z))\n#else\n#define fseeko(x, y, z) fseek((x), (y), (z))\n#endif\n\ntypedef int socklen_t;\n\n#if _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#endif\n\ntypedef SOCKET sock_t;\ntypedef uint32_t in_addr_t;\n\n#ifndef UINT16_MAX\n#define UINT16_MAX 65535\n#endif\n\n#ifndef UINT32_MAX\n#define UINT32_MAX 4294967295\n#endif\n\n#ifndef pid_t\n#define pid_t HANDLE\n#endif\n\n#define INT64_FMT \"I64d\"\n#define INT64_X_FMT \"I64x\"\n/* TODO(alashkin): check if this is correct */\n#define SIZE_T_FMT \"u\"\n\n#define DIRSEP '\\\\'\n#define CS_DEFINE_DIRENT\n\n#ifndef va_copy\n#ifdef __va_copy\n#define va_copy __va_copy\n#else\n#define va_copy(x, y) (x) = (y)\n#endif\n#endif\n\n#ifndef MG_MAX_HTTP_REQUEST_SIZE\n#define MG_MAX_HTTP_REQUEST_SIZE 8192\n#endif\n\n#ifndef MG_MAX_HTTP_SEND_MBUF\n#define MG_MAX_HTTP_SEND_MBUF 4096\n#endif\n\n#ifndef MG_MAX_HTTP_HEADERS\n#define MG_MAX_HTTP_HEADERS 40\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#define abort() DebugBreak();\n\n#ifndef BUFSIZ\n#define BUFSIZ 4096\n#endif\n/*\n * Explicitly disabling MG_ENABLE_THREADS for WinCE\n * because they are enabled for _WIN32 by default\n */\n#ifndef MG_ENABLE_THREADS\n#define MG_ENABLE_THREADS 0\n#endif\n\n#ifndef MG_ENABLE_FILESYSTEM\n#define MG_ENABLE_FILESYSTEM 1\n#endif\n\n#ifndef MG_NET_IF\n#define MG_NET_IF MG_NET_IF_SOCKET\n#endif\n\ntypedef struct _stati64 {\n  uint32_t st_mtime;\n  uint32_t st_size;\n  uint32_t st_mode;\n} cs_stat_t;\n\n/*\n * WinCE 6.0 has a lot of useful definitions in ATL (not windows.h) headers\n * use #ifdefs to avoid conflicts\n */\n\n#ifndef ENOENT\n#define ENOENT ERROR_PATH_NOT_FOUND\n#endif\n\n#ifndef EACCES\n#define EACCES ERROR_ACCESS_DENIED\n#endif\n\n#ifndef ENOMEM\n#define ENOMEM ERROR_NOT_ENOUGH_MEMORY\n#endif\n\n#ifndef _UINTPTR_T_DEFINED\ntypedef unsigned int *uintptr_t;\n#endif\n\n#define _S_IFREG 2\n#define _S_IFDIR 4\n\n#ifndef S_ISDIR\n#define S_ISDIR(x) (((x) &_S_IFDIR) != 0)\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(x) (((x) &_S_IFREG) != 0)\n#endif\n\nint open(const char *filename, int oflag, int pmode);\nint _wstati64(const wchar_t *path, cs_stat_t *st);\nconst char *strerror();\n\n#endif /* CS_PLATFORM == CS_P_WINCE */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_WINCE_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_nxp_lpc.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_NXP_LPC_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_NXP_LPC_H_\n\n#if CS_PLATFORM == CS_P_NXP_LPC\n\n#include <ctype.h>\n#include <stdint.h>\n#include <string.h>\n\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define INT64_FMT \"lld\"\n#define INT64_X_FMT \"llx\"\n#define __cdecl\n\n#define MG_LWIP 1\n\n#define MG_NET_IF MG_NET_IF_LWIP_LOW_LEVEL\n\n/*\n * LPCXpress comes with 3 C library implementations: Newlib, NewlibNano and\n *Redlib.\n * See https://community.nxp.com/message/630860 for more details.\n *\n * Redlib is the default and lacks certain things, so we provide them.\n */\n#ifdef __REDLIB_INTERFACE_VERSION__\n\n/* Let LWIP define timeval for us. */\n#define LWIP_TIMEVAL_PRIVATE 1\n\n#define va_copy(d, s) __builtin_va_copy(d, s)\n\n#define CS_ENABLE_TO64 1\n#define to64(x) cs_to64(x)\n\n#define CS_ENABLE_STRDUP 1\n\n#else\n\n#include <sys/time.h>\n#define LWIP_TIMEVAL_PRIVATE 0\n#define to64(x) strtoll(x, NULL, 10)\n\n#endif\n\n#endif /* CS_PLATFORM == CS_P_NXP_LPC */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_NXP_LPC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_nxp_kinetis.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_NXP_KINETIS_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_NXP_KINETIS_H_\n\n#if CS_PLATFORM == CS_P_NXP_KINETIS\n\n#include <ctype.h>\n#include <inttypes.h>\n#include <string.h>\n#include <sys/time.h>\n\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT \"lld\"\n#define INT64_X_FMT \"llx\"\n#define __cdecl\n\n#define MG_LWIP 1\n\n#define MG_NET_IF MG_NET_IF_LWIP_LOW_LEVEL\n\n/* struct timeval is defined in sys/time.h. */\n#define LWIP_TIMEVAL_PRIVATE 0\n\n#endif /* CS_PLATFORM == CS_P_NXP_KINETIS */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_NXP_KINETIS_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_pic32.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_PIC32_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_PIC32_H_\n\n#if CS_PLATFORM == CS_P_PIC32\n\n#define MG_NET_IF MG_NET_IF_PIC32\n\n#include <stdint.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include <system_config.h>\n#include <system_definitions.h>\n\n#include <sys/types.h>\n\ntypedef TCP_SOCKET sock_t;\n#define to64(x) strtoll(x, NULL, 10)\n\n#define SIZE_T_FMT \"lu\"\n#define INT64_FMT \"lld\"\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\nchar *inet_ntoa(struct in_addr in);\n\n#endif /* CS_PLATFORM == CS_P_PIC32 */\n\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_PIC32_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_rs14100.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_RS14100_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_RS14100_H_\n#if CS_PLATFORM == CS_P_RS14100\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifdef MGOS_HAVE_VFS_COMMON\n#include <mgos_vfs.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT \"lld\"\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifndef MG_ENABLE_FILESYSTEM\n#define MG_ENABLE_FILESYSTEM 1\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_PLATFORM == CS_P_RS14100 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_RS14100_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/platforms/platform_stm32.h\"\n#endif\n\n#ifndef CS_COMMON_PLATFORMS_PLATFORM_STM32_H_\n#define CS_COMMON_PLATFORMS_PLATFORM_STM32_H_\n#if CS_PLATFORM == CS_P_STM32\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <dirent.h>\n\n#include <stm32_sdk_hal.h>\n\n#define to64(x) strtoll(x, NULL, 10)\n#define INT64_FMT \"lld\"\n#define SIZE_T_FMT \"u\"\ntypedef struct stat cs_stat_t;\n#define DIRSEP '/'\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#ifndef MG_ENABLE_FILESYSTEM\n#define MG_ENABLE_FILESYSTEM 1\n#endif\n\n#endif /* CS_PLATFORM == CS_P_STM32 */\n#endif /* CS_COMMON_PLATFORMS_PLATFORM_STM32_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_dbg.h\"\n#endif\n\n#ifndef CS_COMMON_CS_DBG_H_\n#define CS_COMMON_CS_DBG_H_\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#if CS_ENABLE_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef CS_ENABLE_DEBUG\n#define CS_ENABLE_DEBUG 0\n#endif\n\n#ifndef CS_LOG_PREFIX_LEN\n#define CS_LOG_PREFIX_LEN 24\n#endif\n\n#ifndef CS_LOG_ENABLE_TS_DIFF\n#define CS_LOG_ENABLE_TS_DIFF 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Log level; `LL_INFO` is the default. Use `cs_log_set_level()` to change it.\n */\nenum cs_log_level {\n  LL_NONE = -1,\n  LL_ERROR = 0,\n  LL_WARN = 1,\n  LL_INFO = 2,\n  LL_DEBUG = 3,\n  LL_VERBOSE_DEBUG = 4,\n\n  _LL_MIN = -2,\n  _LL_MAX = 5,\n};\n\n/*\n * Set max log level to print; messages with the level above the given one will\n * not be printed.\n */\nvoid cs_log_set_level(enum cs_log_level level);\n\n/*\n * A comma-separated set of prefix=level.\n * prefix is matched against the log prefix exactly as printed, including line\n * number, but partial match is ok. Check stops on first matching entry.\n * If nothing matches, default level is used.\n *\n * Examples:\n *   main.c:=4 - everything from main C at verbose debug level.\n *   mongoose.c=1,mjs.c=1,=4 - everything at verbose debug except mg_* and mjs_*\n *\n */\nvoid cs_log_set_file_level(const char *file_level);\n\n/*\n * Helper function which prints message prefix with the given `level`.\n * If message should be printed (according to the current log level\n * and filter), prints the prefix and returns 1, otherwise returns 0.\n *\n * Clients should typically just use `LOG()` macro.\n */\nint cs_log_print_prefix(enum cs_log_level level, const char *fname, int line);\n\nextern enum cs_log_level cs_log_level;\n\n#if CS_ENABLE_STDIO\n\n/*\n * Set file to write logs into. If `NULL`, logs go to `stderr`.\n */\nvoid cs_log_set_file(FILE *file);\n\n/*\n * Prints log to the current log file, appends \"\\n\" in the end and flushes the\n * stream.\n */\nvoid cs_log_printf(const char *fmt, ...) PRINTF_LIKE(1, 2);\n\n#if CS_ENABLE_STDIO\n\n/*\n * Format and print message `x` with the given level `l`. Example:\n *\n * ```c\n * LOG(LL_INFO, (\"my info message: %d\", 123));\n * LOG(LL_DEBUG, (\"my debug message: %d\", 123));\n * ```\n */\n#define LOG(l, x)                                     \\\n  do {                                                \\\n    if (cs_log_print_prefix(l, __FILE__, __LINE__)) { \\\n      cs_log_printf x;                                \\\n    }                                                 \\\n  } while (0)\n\n#else\n\n#define LOG(l, x) ((void) l)\n\n#endif\n\n#ifndef CS_NDEBUG\n\n/*\n * Shortcut for `LOG(LL_VERBOSE_DEBUG, (...))`\n */\n#define DBG(x) LOG(LL_VERBOSE_DEBUG, x)\n\n#else /* NDEBUG */\n\n#define DBG(x)\n\n#endif\n\n#else /* CS_ENABLE_STDIO */\n\n#define LOG(l, x)\n#define DBG(x)\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_DBG_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_time.h\"\n#endif\n\n#ifndef CS_COMMON_CS_TIME_H_\n#define CS_COMMON_CS_TIME_H_\n\n#include <time.h>\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* Sub-second granularity time(). */\ndouble cs_time(void);\n\n/*\n * Similar to (non-standard) timegm, converts broken-down time into the number\n * of seconds since Unix Epoch.\n */\ndouble cs_timegm(const struct tm *tm);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_TIME_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/mg_str.h\"\n#endif\n\n#ifndef CS_COMMON_MG_STR_H_\n#define CS_COMMON_MG_STR_H_\n\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Describes chunk of memory */\nstruct mg_str {\n  const char *p; /* Memory chunk pointer */\n  size_t len;    /* Memory chunk length */\n};\n\n/*\n * Helper function for creating mg_str struct from plain C string.\n * `NULL` is allowed and becomes `{NULL, 0}`.\n */\nstruct mg_str mg_mk_str(const char *s);\n\n/*\n * Like `mg_mk_str`, but takes string length explicitly.\n */\nstruct mg_str mg_mk_str_n(const char *s, size_t len);\n\n/* Macro for initializing mg_str. */\n#define MG_MK_STR(str_literal) \\\n  { str_literal, sizeof(str_literal) - 1 }\n#define MG_MK_STR_N(str_literal, len) \\\n  { str_literal, len }\n#define MG_NULL_STR \\\n  { NULL, 0 }\n\n/*\n * Cross-platform version of `strcmp()` where where first string is\n * specified by `struct mg_str`.\n */\nint mg_vcmp(const struct mg_str *str2, const char *str1);\n\n/*\n * Cross-platform version of `strncasecmp()` where first string is\n * specified by `struct mg_str`.\n */\nint mg_vcasecmp(const struct mg_str *str2, const char *str1);\n\n/* Creates a copy of s (heap-allocated). */\nstruct mg_str mg_strdup(const struct mg_str s);\n\n/*\n * Creates a copy of s (heap-allocated).\n * Resulting string is NUL-terminated (but NUL is not included in len).\n */\nstruct mg_str mg_strdup_nul(const struct mg_str s);\n\n/*\n * Locates character in a string.\n */\nconst char *mg_strchr(const struct mg_str s, int c);\n\n/*\n * Compare two `mg_str`s; return value is the same as `strcmp`.\n */\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2);\n\n/*\n * Like `mg_strcmp`, but compares at most `n` characters.\n */\nint mg_strncmp(const struct mg_str str1, const struct mg_str str2, size_t n);\n\n/*\n * Compare two `mg_str`s ignoreing case; return value is the same as `strcmp`.\n */\nint mg_strcasecmp(const struct mg_str str1, const struct mg_str str2);\n\n/*\n * Free the string (assuming it was heap allocated).\n */\nvoid mg_strfree(struct mg_str *s);\n\n/*\n * Finds the first occurrence of a substring `needle` in the `haystack`.\n */\nconst char *mg_strstr(const struct mg_str haystack, const struct mg_str needle);\n\n/* Strip whitespace at the start and the end of s */\nstruct mg_str mg_strstrip(struct mg_str s);\n\n/* Returns 1 if s starts with the given prefix. */\nint mg_str_starts_with(struct mg_str s, struct mg_str prefix);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_COMMON_MG_STR_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/str_util.h\"\n#endif\n\n#ifndef CS_COMMON_STR_UTIL_H_\n#define CS_COMMON_STR_UTIL_H_\n\n#include <stdarg.h>\n#include <stdlib.h>\n\n/* Amalgamated: #include \"common/mg_str.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifndef CS_ENABLE_STRDUP\n#define CS_ENABLE_STRDUP 0\n#endif\n\n#ifndef CS_ENABLE_TO64\n#define CS_ENABLE_TO64 0\n#endif\n\n/*\n * Expands to a string representation of its argument: e.g.\n * `CS_STRINGIFY_LIT(5) expands to \"5\"`\n */\n#if !defined(_MSC_VER) || _MSC_VER >= 1900\n#define CS_STRINGIFY_LIT(...) #__VA_ARGS__\n#else\n#define CS_STRINGIFY_LIT(x) #x\n#endif\n\n/*\n * Expands to a string representation of its argument, which is allowed\n * to be a macro: e.g.\n *\n * #define FOO 123\n * CS_STRINGIFY_MACRO(FOO)\n *\n * expands to 123.\n */\n#define CS_STRINGIFY_MACRO(x) CS_STRINGIFY_LIT(x)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Equivalent of standard `strnlen()`.\n */\nsize_t c_strnlen(const char *s, size_t maxlen);\n\n/*\n * Equivalent of standard `snprintf()`.\n */\nint c_snprintf(char *buf, size_t buf_size, const char *format, ...)\n    PRINTF_LIKE(3, 4);\n\n/*\n * Equivalent of standard `vsnprintf()`.\n */\nint c_vsnprintf(char *buf, size_t buf_size, const char *format, va_list ap);\n\n/*\n * Find the first occurrence of find in s, where the search is limited to the\n * first slen characters of s.\n */\nconst char *c_strnstr(const char *s, const char *find, size_t slen);\n\n/*\n * Stringify binary data. Output buffer size must be 2 * size_of_input + 1\n * because each byte of input takes 2 bytes in string representation\n * plus 1 byte for the terminating \\0 character.\n */\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len);\n\n/*\n * Convert stringified binary data back to binary.\n * Does the reverse of `cs_to_hex()`.\n */\nvoid cs_from_hex(char *to, const char *p, size_t len);\n\n#if CS_ENABLE_STRDUP\n/*\n * Equivalent of standard `strdup()`, defined if only `CS_ENABLE_STRDUP` is 1.\n */\nchar *strdup(const char *src);\n#endif\n\n#if CS_ENABLE_TO64\n#include <stdint.h>\n/*\n * Simple string -> int64 conversion routine.\n */\nint64_t cs_to64(const char *s);\n#endif\n\n/*\n * Cross-platform version of `strncasecmp()`.\n */\nint mg_ncasecmp(const char *s1, const char *s2, size_t len);\n\n/*\n * Cross-platform version of `strcasecmp()`.\n */\nint mg_casecmp(const char *s1, const char *s2);\n\n/*\n * Prints message to the buffer. If the buffer is large enough to hold the\n * message, it returns buffer. If buffer is to small, it allocates a large\n * enough buffer on heap and returns allocated buffer.\n * This is a supposed use case:\n *\n * ```c\n *    char buf[5], *p = buf;\n *    mg_avprintf(&p, sizeof(buf), \"%s\", \"hi there\");\n *    use_p_somehow(p);\n *    if (p != buf) {\n *      free(p);\n *    }\n * ```\n *\n * The purpose of this is to avoid malloc-ing if generated strings are small.\n */\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...)\n    PRINTF_LIKE(3, 4);\n\n/* Same as mg_asprintf, but takes varargs list. */\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap);\n\n/*\n * A helper function for traversing a comma separated list of values.\n * It returns a list pointer shifted to the next value or NULL if the end\n * of the list found.\n * The value is stored in a val vector. If the value has a form \"x=y\", then\n * eq_val vector is initialised to point to the \"y\" part, and val vector length\n * is adjusted to point only to \"x\".\n * If the list is just a comma separated list of entries, like \"aa,bb,cc\" then\n * `eq_val` will contain zero-length string.\n *\n * The purpose of this function is to parse comma separated string without\n * any copying/memory allocation.\n */\nconst char *mg_next_comma_list_entry(const char *list, struct mg_str *val,\n                                     struct mg_str *eq_val);\n\n/*\n * Like `mg_next_comma_list_entry()`, but takes `list` as `struct mg_str`.\n * NB: Test return value's .p, not .len. On last itreation that yields result\n * .len will be 0 but .p will not. When finished, .p will be NULL.\n */\nstruct mg_str mg_next_comma_list_entry_n(struct mg_str list, struct mg_str *val,\n                                         struct mg_str *eq_val);\n\n/*\n * Matches 0-terminated string (mg_match_prefix) or string with given length\n * mg_match_prefix_n against a glob pattern. Glob syntax:\n * ```\n * - * matches zero or more characters until a slash character /\n * - ** matches zero or more characters\n * - ? Matches exactly one character which is not a slash /\n * - | or ,  divides alternative patterns\n * - any other character matches itself\n * ```\n * Match is case-insensitive. Return number of bytes matched.\n * Examples:\n * ```\n * mg_match_prefix(\"a*f\", len, \"abcdefgh\") == 6\n * mg_match_prefix(\"a*f\", len, \"abcdexgh\") == 0\n * mg_match_prefix(\"a*f|de*,xy\", len, \"defgh\") == 5\n * mg_match_prefix(\"?*\", len, \"abc\") == 3\n * mg_match_prefix(\"?*\", len, \"\") == 0\n * ```\n */\nsize_t mg_match_prefix(const char *pattern, int pattern_len, const char *str);\n\n/*\n * Like `mg_match_prefix()`, but takes `pattern` and `str` as `struct mg_str`.\n */\nsize_t mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_COMMON_STR_UTIL_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_file.h\"\n#endif\n\n#ifndef CS_COMMON_CS_FILE_H_\n#define CS_COMMON_CS_FILE_H_\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Read whole file `path` in memory. It is responsibility of the caller\n * to `free()` allocated memory. File content is guaranteed to be\n * '\\0'-terminated. File size is returned in `size` variable, which does not\n * count terminating `\\0`.\n * Return: allocated memory, or NULL on error.\n */\nchar *cs_read_file(const char *path, size_t *size);\n\n#ifdef CS_MMAP\n/*\n * Only on platforms which support mmapping: mmap file `path` to the returned\n * address. File size is written to `*size`.\n */\nchar *cs_mmap_file(const char *path, size_t *size);\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_FILE_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/mbuf.h\"\n#endif\n\n/*\n * Mbufs are mutable/growing memory buffers, like C++ strings.\n * Mbuf can append data to the end of a buffer or insert data into arbitrary\n * position in the middle of a buffer. The buffer grows automatically when\n * needed.\n */\n\n#ifndef CS_COMMON_MBUF_H_\n#define CS_COMMON_MBUF_H_\n\n#include <stdlib.h>\n/* Amalgamated: #include \"common/platform.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#ifndef MBUF_SIZE_MULTIPLIER\n#define MBUF_SIZE_MULTIPLIER 1.5\n#endif\n\n#ifndef MBUF_SIZE_MAX_HEADROOM\n#ifdef BUFSIZ\n#define MBUF_SIZE_MAX_HEADROOM BUFSIZ\n#else\n#define MBUF_SIZE_MAX_HEADROOM 1024\n#endif\n#endif\n\n/* Memory buffer descriptor */\nstruct mbuf {\n  char *buf;   /* Buffer pointer */\n  size_t len;  /* Data length. Data is located between offset 0 and len. */\n  size_t size; /* Buffer size allocated by realloc(1). Must be >= len */\n};\n\n/*\n * Initialises an Mbuf.\n * `initial_capacity` specifies the initial capacity of the mbuf.\n */\nvoid mbuf_init(struct mbuf *, size_t initial_capacity);\n\n/* Frees the space allocated for the mbuffer and resets the mbuf structure. */\nvoid mbuf_free(struct mbuf *);\n\n/*\n * Appends data to the Mbuf.\n *\n * Returns the number of bytes appended or 0 if out of memory.\n */\nsize_t mbuf_append(struct mbuf *, const void *data, size_t data_size);\n\n/*\n * Appends data to the Mbuf and frees it (data must be heap-allocated).\n *\n * Returns the number of bytes appended or 0 if out of memory.\n * data is freed irrespective of return value.\n */\nsize_t mbuf_append_and_free(struct mbuf *, void *data, size_t data_size);\n\n/*\n * Inserts data at a specified offset in the Mbuf.\n *\n * Existing data will be shifted forwards and the buffer will\n * be grown if necessary.\n * Returns the number of bytes inserted.\n */\nsize_t mbuf_insert(struct mbuf *, size_t, const void *, size_t);\n\n/* Removes `data_size` bytes from the beginning of the buffer. */\nvoid mbuf_remove(struct mbuf *, size_t data_size);\n\n/*\n * Resizes an Mbuf.\n *\n * If `new_size` is smaller than buffer's `len`, the\n * resize is not performed.\n */\nvoid mbuf_resize(struct mbuf *, size_t new_size);\n\n/* Moves the state from one mbuf to the other. */\nvoid mbuf_move(struct mbuf *from, struct mbuf *to);\n\n/* Removes all the data from mbuf (if any). */\nvoid mbuf_clear(struct mbuf *);\n\n/* Shrinks an Mbuf by resizing its `size` to `len`. */\nvoid mbuf_trim(struct mbuf *);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_MBUF_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/mg_mem.h\"\n#endif\n\n#ifndef CS_COMMON_MG_MEM_H_\n#define CS_COMMON_MG_MEM_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef MG_MALLOC\n#define MG_MALLOC malloc\n#endif\n\n#ifndef MG_CALLOC\n#define MG_CALLOC calloc\n#endif\n\n#ifndef MG_REALLOC\n#define MG_REALLOC realloc\n#endif\n\n#ifndef MG_FREE\n#define MG_FREE free\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_COMMON_MG_MEM_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/frozen/frozen.h\"\n#endif\n\n#ifndef CS_FROZEN_FROZEN_H_\n#define CS_FROZEN_FROZEN_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_WIN32) && _MSC_VER < 1700\ntypedef int bool;\nenum { false = 0, true = 1 };\n#else\n#include <stdbool.h>\n#endif\n\n/* JSON token type */\nenum json_token_type {\n  JSON_TYPE_INVALID = 0, /* memsetting to 0 should create INVALID value */\n  JSON_TYPE_STRING,\n  JSON_TYPE_NUMBER,\n  JSON_TYPE_TRUE,\n  JSON_TYPE_FALSE,\n  JSON_TYPE_NULL,\n  JSON_TYPE_OBJECT_START,\n  JSON_TYPE_OBJECT_END,\n  JSON_TYPE_ARRAY_START,\n  JSON_TYPE_ARRAY_END,\n\n  JSON_TYPES_CNT\n};\n\n/*\n * Structure containing token type and value. Used in `json_walk()` and\n * `json_scanf()` with the format specifier `%T`.\n */\nstruct json_token {\n  const char *ptr;           /* Points to the beginning of the value */\n  int len;                   /* Value length */\n  enum json_token_type type; /* Type of the token, possible values are above */\n};\n\n#define JSON_INVALID_TOKEN \\\n  { 0, 0, JSON_TYPE_INVALID }\n\n/* Error codes */\n#define JSON_STRING_INVALID -1\n#define JSON_STRING_INCOMPLETE -2\n\n/*\n * Callback-based SAX-like API.\n *\n * Property name and length is given only if it's available: i.e. if current\n * event is an object's property. In other cases, `name` is `NULL`. For\n * example, name is never given:\n *   - For the first value in the JSON string;\n *   - For events JSON_TYPE_OBJECT_END and JSON_TYPE_ARRAY_END\n *\n * E.g. for the input `{ \"foo\": 123, \"bar\": [ 1, 2, { \"baz\": true } ] }`,\n * the sequence of callback invocations will be as follows:\n *\n * - type: JSON_TYPE_OBJECT_START, name: NULL, path: \"\", value: NULL\n * - type: JSON_TYPE_NUMBER, name: \"foo\", path: \".foo\", value: \"123\"\n * - type: JSON_TYPE_ARRAY_START,  name: \"bar\", path: \".bar\", value: NULL\n * - type: JSON_TYPE_NUMBER, name: \"0\", path: \".bar[0]\", value: \"1\"\n * - type: JSON_TYPE_NUMBER, name: \"1\", path: \".bar[1]\", value: \"2\"\n * - type: JSON_TYPE_OBJECT_START, name: \"2\", path: \".bar[2]\", value: NULL\n * - type: JSON_TYPE_TRUE, name: \"baz\", path: \".bar[2].baz\", value: \"true\"\n * - type: JSON_TYPE_OBJECT_END, name: NULL, path: \".bar[2]\", value: \"{ \\\"baz\\\":\n *true }\"\n * - type: JSON_TYPE_ARRAY_END, name: NULL, path: \".bar\", value: \"[ 1, 2, {\n *\\\"baz\\\": true } ]\"\n * - type: JSON_TYPE_OBJECT_END, name: NULL, path: \"\", value: \"{ \\\"foo\\\": 123,\n *\\\"bar\\\": [ 1, 2, { \\\"baz\\\": true } ] }\"\n */\ntypedef void (*json_walk_callback_t)(void *callback_data, const char *name,\n                                     size_t name_len, const char *path,\n                                     const struct json_token *token);\n\n/*\n * Parse `json_string`, invoking `callback` in a way similar to SAX parsers;\n * see `json_walk_callback_t`.\n * Return number of processed bytes, or a negative error code.\n */\nint json_walk(const char *json_string, int json_string_length,\n              json_walk_callback_t callback, void *callback_data);\n\n/*\n * JSON generation API.\n * struct json_out abstracts output, allowing alternative printing plugins.\n */\nstruct json_out {\n  int (*printer)(struct json_out *, const char *str, size_t len);\n  union {\n    struct {\n      char *buf;\n      size_t size;\n      size_t len;\n    } buf;\n    void *data;\n    FILE *fp;\n  } u;\n};\n\nextern int json_printer_buf(struct json_out *, const char *, size_t);\nextern int json_printer_file(struct json_out *, const char *, size_t);\n\n#define JSON_OUT_BUF(buf, len) \\\n  {                            \\\n    json_printer_buf, {        \\\n      { buf, len, 0 }          \\\n    }                          \\\n  }\n#define JSON_OUT_FILE(fp)   \\\n  {                         \\\n    json_printer_file, {    \\\n      { (char *) fp, 0, 0 } \\\n    }                       \\\n  }\n\ntypedef int (*json_printf_callback_t)(struct json_out *, va_list *ap);\n\n/*\n * Generate formatted output into a given sting buffer.\n * This is a superset of printf() function, with extra format specifiers:\n *  - `%B` print json boolean, `true` or `false`. Accepts an `int`.\n *  - `%Q` print quoted escaped string or `null`. Accepts a `const char *`.\n *  - `%.*Q` same as `%Q`, but with length. Accepts `int`, `const char *`\n *  - `%V` print quoted base64-encoded string. Accepts a `const char *`, `int`.\n *  - `%H` print quoted hex-encoded string. Accepts a `int`, `const char *`.\n *  - `%M` invokes a json_printf_callback_t function. That callback function\n *  can consume more parameters.\n *\n * Return number of bytes printed. If the return value is bigger than the\n * supplied buffer, that is an indicator of overflow. In the overflow case,\n * overflown bytes are not printed.\n */\nint json_printf(struct json_out *, const char *fmt, ...);\nint json_vprintf(struct json_out *, const char *fmt, va_list ap);\n\n/*\n * Same as json_printf, but prints to a file.\n * File is created if does not exist. File is truncated if already exists.\n */\nint json_fprintf(const char *file_name, const char *fmt, ...);\nint json_vfprintf(const char *file_name, const char *fmt, va_list ap);\n\n/*\n * Print JSON into an allocated 0-terminated string.\n * Return allocated string, or NULL on error.\n * Example:\n *\n * ```c\n *   char *str = json_asprintf(\"{a:%H}\", 3, \"abc\");\n *   printf(\"%s\\n\", str);  // Prints \"616263\"\n *   free(str);\n * ```\n */\nchar *json_asprintf(const char *fmt, ...);\nchar *json_vasprintf(const char *fmt, va_list ap);\n\n/*\n * Helper %M callback that prints contiguous C arrays.\n * Consumes void *array_ptr, size_t array_size, size_t elem_size, char *fmt\n * Return number of bytes printed.\n */\nint json_printf_array(struct json_out *, va_list *ap);\n\n/*\n * Scan JSON string `str`, performing scanf-like conversions according to `fmt`.\n * This is a `scanf()` - like function, with following differences:\n *\n * 1. Object keys in the format string may be not quoted, e.g. \"{key: %d}\"\n * 2. Order of keys in an object is irrelevant.\n * 3. Several extra format specifiers are supported:\n *    - %B: consumes `int *` (or `char *`, if `sizeof(bool) == sizeof(char)`),\n *       expects boolean `true` or `false`.\n *    - %Q: consumes `char **`, expects quoted, JSON-encoded string. Scanned\n *       string is malloc-ed, caller must free() the string.\n *    - %V: consumes `char **`, `int *`. Expects base64-encoded string.\n *       Result string is base64-decoded, malloced and NUL-terminated.\n *       The length of result string is stored in `int *` placeholder.\n *       Caller must free() the result.\n *    - %H: consumes `int *`, `char **`.\n *       Expects a hex-encoded string, e.g. \"fa014f\".\n *       Result string is hex-decoded, malloced and NUL-terminated.\n *       The length of the result string is stored in `int *` placeholder.\n *       Caller must free() the result.\n *    - %M: consumes custom scanning function pointer and\n *       `void *user_data` parameter - see json_scanner_t definition.\n *    - %T: consumes `struct json_token *`, fills it out with matched token.\n *\n * Return number of elements successfully scanned & converted.\n * Negative number means scan error.\n */\nint json_scanf(const char *str, int str_len, const char *fmt, ...);\nint json_vscanf(const char *str, int str_len, const char *fmt, va_list ap);\n\n/* json_scanf's %M handler  */\ntypedef void (*json_scanner_t)(const char *str, int len, void *user_data);\n\n/*\n * Helper function to scan array item with given path and index.\n * Fills `token` with the matched JSON token.\n * Return -1 if no array element found, otherwise non-negative token length.\n */\nint json_scanf_array_elem(const char *s, int len, const char *path, int index,\n                          struct json_token *token);\n\n/*\n * Unescape JSON-encoded string src,slen into dst, dlen.\n * src and dst may overlap.\n * If destination buffer is too small (or zero-length), result string is not\n * written but the length is counted nevertheless (similar to snprintf).\n * Return the length of unescaped string in bytes.\n */\nint json_unescape(const char *src, int slen, char *dst, int dlen);\n\n/*\n * Escape a string `str`, `str_len` into the printer `out`.\n * Return the number of bytes printed.\n */\nint json_escape(struct json_out *out, const char *str, size_t str_len);\n\n/*\n * Read the whole file in memory.\n * Return malloc-ed file content, or NULL on error. The caller must free().\n */\nchar *json_fread(const char *file_name);\n\n/*\n * Update given JSON string `s,len` by changing the value at given `json_path`.\n * The result is saved to `out`. If `json_fmt` == NULL, that deletes the key.\n * If path is not present, missing keys are added. Array path without an\n * index pushes a value to the end of an array.\n * Return 1 if the string was changed, 0 otherwise.\n *\n * Example:  s is a JSON string { \"a\": 1, \"b\": [ 2 ] }\n *   json_setf(s, len, out, \".a\", \"7\");     // { \"a\": 7, \"b\": [ 2 ] }\n *   json_setf(s, len, out, \".b\", \"7\");     // { \"a\": 1, \"b\": 7 }\n *   json_setf(s, len, out, \".b[]\", \"7\");   // { \"a\": 1, \"b\": [ 2,7 ] }\n *   json_setf(s, len, out, \".b\", NULL);    // { \"a\": 1 }\n */\nint json_setf(const char *s, int len, struct json_out *out,\n              const char *json_path, const char *json_fmt, ...);\n\nint json_vsetf(const char *s, int len, struct json_out *out,\n               const char *json_path, const char *json_fmt, va_list ap);\n\n/*\n * Pretty-print JSON string `s,len` into `out`.\n * Return number of processed bytes in `s`.\n */\nint json_prettify(const char *s, int len, struct json_out *out);\n\n/*\n * Prettify JSON file `file_name`.\n * Return number of processed bytes, or negative number of error.\n * On error, file content is not modified.\n */\nint json_prettify_file(const char *file_name);\n\n/*\n * Iterate over an object at given JSON `path`.\n * On each iteration, fill the `key` and `val` tokens. It is OK to pass NULL\n * for `key`, or `val`, in which case they won't be populated.\n * Return an opaque value suitable for the next iteration, or NULL when done.\n *\n * Example:\n *\n * ```c\n * void *h = NULL;\n * struct json_token key, val;\n * while ((h = json_next_key(s, len, h, \".foo\", &key, &val)) != NULL) {\n *   printf(\"[%.*s] -> [%.*s]\\n\", key.len, key.ptr, val.len, val.ptr);\n * }\n * ```\n */\nvoid *json_next_key(const char *s, int len, void *handle, const char *path,\n                    struct json_token *key, struct json_token *val);\n\n/*\n * Iterate over an array at given JSON `path`.\n * Similar to `json_next_key`, but fills array index `idx` instead of `key`.\n */\nvoid *json_next_elem(const char *s, int len, void *handle, const char *path,\n                     int *idx, struct json_token *val);\n\n#ifndef JSON_MAX_PATH_LEN\n#define JSON_MAX_PATH_LEN 256\n#endif\n\n#ifndef JSON_MINIMAL\n#define JSON_MINIMAL 0\n#endif\n\n#ifndef JSON_ENABLE_BASE64\n#define JSON_ENABLE_BASE64 !JSON_MINIMAL\n#endif\n\n#ifndef JSON_ENABLE_HEX\n#define JSON_ENABLE_HEX !JSON_MINIMAL\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_FROZEN_FROZEN_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/ffi/ffi.h\"\n#endif\n\n#ifndef MJS_FFI_FFI_H_\n#define MJS_FFI_FFI_H_\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Maximum number of word-sized args to ffi-ed function. If at least one\n * of the args is double, only 2 args are allowed.\n */\n#define FFI_MAX_ARGS_CNT 6\n\ntypedef void(ffi_fn_t)(void);\n\ntypedef intptr_t ffi_word_t;\n\nenum ffi_ctype {\n  FFI_CTYPE_WORD,\n  FFI_CTYPE_BOOL,\n  FFI_CTYPE_FLOAT,\n  FFI_CTYPE_DOUBLE,\n};\n\nstruct ffi_arg {\n  enum ffi_ctype ctype;\n  union {\n    uint64_t i;\n    double d;\n    float f;\n  } v;\n};\n\nint ffi_call(ffi_fn_t *func, int nargs, struct ffi_arg *res,\n             struct ffi_arg *args);\n\nvoid ffi_set_word(struct ffi_arg *arg, ffi_word_t v);\nvoid ffi_set_bool(struct ffi_arg *arg, bool v);\nvoid ffi_set_ptr(struct ffi_arg *arg, void *v);\nvoid ffi_set_double(struct ffi_arg *arg, double v);\nvoid ffi_set_float(struct ffi_arg *arg, float v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_FFI_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_internal.h\"\n#endif\n\n#ifndef MJS_INTERNAL_H_\n#define MJS_INTERNAL_H_\n\n#include <assert.h>\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifndef FAST\n#define FAST\n#endif\n\n#ifndef STATIC\n#define STATIC\n#endif\n\n#ifndef ENDL\n#define ENDL \"\\n\"\n#endif\n\n#ifdef MJS_EXPOSE_PRIVATE\n#define MJS_PRIVATE\n#define MJS_EXTERN extern\n#else\n#define MJS_PRIVATE static\n#define MJS_EXTERN static\n#endif\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\n#if !defined(WEAK)\n#if (defined(__GNUC__) || defined(__TI_COMPILER_VERSION__)) && !defined(_WIN32)\n#define WEAK __attribute__((weak))\n#else\n#define WEAK\n#endif\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/cs_file.h\" */\n/* Amalgamated: #include \"common/mbuf.h\" */\n\n#if defined(_WIN32) && _MSC_VER < 1700\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef __int64 int64_t;\ntypedef unsigned long uintptr_t;\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n// #define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#define isnan(x) _isnan(x)\n#define va_copy(x, y) (x) = (y)\n#define CS_DEFINE_DIRENT\n#include <windows.h>\n#else\n#if defined(__unix__) || defined(__APPLE__)\n#include <dlfcn.h>\n#endif\n#endif\n\n/*\n * Number of bytes reserved for the jump offset initially. The most practical\n * value is 1, but for testing it's useful to set it to 0 and to some large\n * value as well (like, 4), to make sure that the code behaves correctly under\n * all circumstances.\n */\n#ifndef MJS_INIT_OFFSET_SIZE\n#define MJS_INIT_OFFSET_SIZE 1\n#endif\n\n#endif /* MJS_INTERNAL_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array.h\"\n#endif\n\n#ifndef MJS_ARRAY_H_\n#define MJS_ARRAY_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_array_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_val_t\nmjs_array_get2(struct mjs *mjs, mjs_val_t arr, unsigned long index, int *has);\n\nMJS_PRIVATE void mjs_array_splice(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_array_push_internal(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_ARRAY_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi.h\"\n#endif\n\n#ifndef MJS_FFI_H_\n#define MJS_FFI_H_\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n/* Amalgamated: #include \"mjs_ffi_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nmjs_ffi_resolver_t dlsym;\n\n#define MJS_CB_ARGS_MAX_CNT 6\n#define MJS_CB_SIGNATURE_MAX_SIZE (MJS_CB_ARGS_MAX_CNT + 1 /* return type */)\n\ntypedef uint8_t mjs_ffi_ctype_t;\n\nenum ffi_sig_type {\n  FFI_SIG_FUNC,\n  FFI_SIG_CALLBACK,\n};\n\n/*\n * Parsed FFI signature\n */\nstruct mjs_ffi_sig {\n  /*\n   * Callback signature, corresponds to the arg of type MJS_FFI_CTYPE_CALLBACK\n   * TODO(dfrank): probably we'll need to support multiple callback/userdata\n   * pairs\n   *\n   * NOTE(dfrank): instances of this structure are grouped into GC arenas and\n   * managed by GC, and for the GC mark to work, the first element should be\n   * a pointer (so that the two LSBs are not used).\n   */\n  struct mjs_ffi_sig *cb_sig;\n\n  /*\n   * The first item is the return value type (for `void`, `MJS_FFI_CTYPE_NONE`\n   * is used); the rest are arguments. If some argument is\n   * `MJS_FFI_CTYPE_NONE`, it means that there are no more arguments.\n   */\n  mjs_ffi_ctype_t val_types[MJS_CB_SIGNATURE_MAX_SIZE];\n\n  /*\n   * Function to call. If `is_callback` is not set, then it's the function\n   * obtained by dlsym; otherwise it's a pointer to the appropriate callback\n   * implementation.\n   */\n  ffi_fn_t *fn;\n\n  /* Number of arguments in the signature */\n  int8_t args_cnt;\n\n  /*\n   * If set, then the signature represents the callback (as opposed to a normal\n   * function), and `fn` points to the suitable callback implementation.\n   */\n  unsigned is_callback : 1;\n  unsigned is_valid : 1;\n};\ntypedef struct mjs_ffi_sig mjs_ffi_sig_t;\n\n/* Initialize new FFI signature */\nMJS_PRIVATE void mjs_ffi_sig_init(mjs_ffi_sig_t *sig);\n/* Copy existing FFI signature */\nMJS_PRIVATE void mjs_ffi_sig_copy(mjs_ffi_sig_t *to, const mjs_ffi_sig_t *from);\n/* Free FFI signature. NOTE: the pointer `sig` itself is not freed */\nMJS_PRIVATE void mjs_ffi_sig_free(mjs_ffi_sig_t *sig);\n\n/*\n * Creates a new FFI signature from the GC arena, and return mjs_val_t which\n * wraps it.\n */\nMJS_PRIVATE mjs_val_t mjs_mk_ffi_sig(struct mjs *mjs);\n\n/*\n * Checks whether the given value is a FFI signature.\n */\nMJS_PRIVATE int mjs_is_ffi_sig(mjs_val_t v);\n\n/*\n * Wraps FFI signature structure into mjs_val_t value.\n */\nMJS_PRIVATE mjs_val_t mjs_ffi_sig_to_value(struct mjs_ffi_sig *psig);\n\n/*\n * Extracts a pointer to the FFI signature struct from the mjs_val_t value.\n */\nMJS_PRIVATE struct mjs_ffi_sig *mjs_get_ffi_sig_struct(mjs_val_t v);\n\n/*\n * A wrapper for mjs_ffi_sig_free() suitable to use as a GC cell destructor.\n */\nMJS_PRIVATE void mjs_ffi_sig_destructor(struct mjs *mjs, void *psig);\n\nMJS_PRIVATE int mjs_ffi_sig_set_val_type(mjs_ffi_sig_t *sig, int idx,\n                                         mjs_ffi_ctype_t type);\nMJS_PRIVATE int mjs_ffi_sig_validate(struct mjs *mjs, mjs_ffi_sig_t *sig,\n                                     enum ffi_sig_type sig_type);\nMJS_PRIVATE int mjs_ffi_is_regular_word(mjs_ffi_ctype_t type);\nMJS_PRIVATE int mjs_ffi_is_regular_word_or_void(mjs_ffi_ctype_t type);\n\nstruct mjs_ffi_cb_args {\n  struct mjs_ffi_cb_args *next;\n  struct mjs *mjs;\n  mjs_ffi_sig_t sig;\n  mjs_val_t func;\n  mjs_val_t userdata;\n};\ntypedef struct mjs_ffi_cb_args ffi_cb_args_t;\n\n/*\n * cfunction:\n * Parses the FFI signature string and returns a value wrapping mjs_ffi_sig_t.\n */\nMJS_PRIVATE mjs_err_t mjs_ffi_call(struct mjs *mjs);\n\n/*\n * cfunction:\n * Performs the FFI signature call.\n */\nMJS_PRIVATE mjs_err_t mjs_ffi_call2(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_ffi_cb_free(struct mjs *);\nMJS_PRIVATE void mjs_ffi_args_free_list(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_mm.h\"\n#endif\n\n#ifndef MJS_MM_H_\n#define MJS_MM_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs;\n\ntypedef void (*gc_cell_destructor_t)(struct mjs *mjs, void *);\n\nstruct gc_block {\n  struct gc_block *next;\n  struct gc_cell *base;\n  size_t size;\n};\n\nstruct gc_arena {\n  struct gc_block *blocks;\n  size_t size_increment;\n  struct gc_cell *free; /* head of free list */\n  size_t cell_size;\n\n#if MJS_MEMORY_STATS\n  unsigned long allocations; /* cumulative counter of allocations */\n  unsigned long garbage;     /* cumulative counter of garbage */\n  unsigned long alive;       /* number of living cells */\n#endif\n\n  gc_cell_destructor_t destructor;\n};\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_MM_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc.h\"\n#endif\n\n#ifndef MJS_GC_H_\n#define MJS_GC_H_\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_mm.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_gc_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * performs arithmetics on gc_cell pointers as if they were arena->cell_size\n * bytes wide\n */\n#define GC_CELL_OP(arena, cell, op, arg) \\\n  ((struct gc_cell *) (((char *) (cell)) op((arg) * (arena)->cell_size)))\n\nstruct gc_cell {\n  union {\n    struct gc_cell *link;\n    uintptr_t word;\n  } head;\n};\n\nMJS_PRIVATE int gc_strings_is_gc_needed(struct mjs *mjs);\n\n/* perform gc if not inhibited */\nMJS_PRIVATE int maybe_gc(struct mjs *mjs);\n\nMJS_PRIVATE struct mjs_object *new_object(struct mjs *);\nMJS_PRIVATE struct mjs_property *new_property(struct mjs *);\nMJS_PRIVATE struct mjs_ffi_sig *new_ffi_sig(struct mjs *mjs);\n\nMJS_PRIVATE void gc_mark(struct mjs *mjs, mjs_val_t *val);\n\nMJS_PRIVATE void gc_arena_init(struct gc_arena *, size_t, size_t, size_t);\nMJS_PRIVATE void gc_arena_destroy(struct mjs *, struct gc_arena *a);\nMJS_PRIVATE void gc_sweep(struct mjs *, struct gc_arena *, size_t);\nMJS_PRIVATE void *gc_alloc_cell(struct mjs *, struct gc_arena *);\n\nMJS_PRIVATE uint64_t gc_string_mjs_val_to_offset(mjs_val_t v);\n\n/* return 0 if v is an object/function with a bad pointer */\nMJS_PRIVATE int gc_check_val(struct mjs *mjs, mjs_val_t v);\n\n/* checks whether a pointer is within the ranges of an arena */\nMJS_PRIVATE int gc_check_ptr(const struct gc_arena *a, const void *p);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_GC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core.h\"\n#endif\n\n#ifndef MJS_CORE_H\n#define MJS_CORE_H\n\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n#define JUMP_INSTRUCTION_SIZE 2\n\nenum mjs_type {\n  /* Primitive types */\n  MJS_TYPE_UNDEFINED,\n  MJS_TYPE_NULL,\n  MJS_TYPE_BOOLEAN,\n  MJS_TYPE_NUMBER,\n  MJS_TYPE_STRING,\n  MJS_TYPE_FOREIGN,\n\n  /* Different classes of Object type */\n  MJS_TYPE_OBJECT_GENERIC,\n  MJS_TYPE_OBJECT_ARRAY,\n  MJS_TYPE_OBJECT_FUNCTION,\n  /*\n   * TODO(dfrank): if we support prototypes, need to add items for them here\n   */\n\n  MJS_TYPES_CNT\n};\n\nenum mjs_call_stack_frame_item {\n  CALL_STACK_FRAME_ITEM_RETVAL_STACK_IDX, /* TOS */\n  CALL_STACK_FRAME_ITEM_LOOP_ADDR_IDX,\n  CALL_STACK_FRAME_ITEM_SCOPE_IDX,\n  CALL_STACK_FRAME_ITEM_RETURN_ADDR,\n  CALL_STACK_FRAME_ITEM_THIS,\n\n  CALL_STACK_FRAME_ITEMS_CNT\n};\n\n/*\n * A tag is made of the sign bit and the 4 lower order bits of byte 6.\n * So in total we have 32 possible tags.\n *\n * Tag (1,0) however cannot hold a zero payload otherwise it's interpreted as an\n * INFINITY; for simplicity we're just not going to use that combination.\n */\n#define MAKE_TAG(s, t) \\\n  ((uint64_t)(s) << 63 | (uint64_t) 0x7ff0 << 48 | (uint64_t)(t) << 48)\n\n#define MJS_TAG_OBJECT MAKE_TAG(1, 1)\n#define MJS_TAG_FOREIGN MAKE_TAG(1, 2)\n#define MJS_TAG_UNDEFINED MAKE_TAG(1, 3)\n#define MJS_TAG_BOOLEAN MAKE_TAG(1, 4)\n#define MJS_TAG_NAN MAKE_TAG(1, 5)\n#define MJS_TAG_STRING_I MAKE_TAG(1, 6)  /* Inlined string len < 5 */\n#define MJS_TAG_STRING_5 MAKE_TAG(1, 7)  /* Inlined string len 5 */\n#define MJS_TAG_STRING_O MAKE_TAG(1, 8)  /* Owned string */\n#define MJS_TAG_STRING_F MAKE_TAG(1, 9)  /* Foreign string */\n#define MJS_TAG_STRING_C MAKE_TAG(1, 10) /* String chunk */\n#define MJS_TAG_STRING_D MAKE_TAG(1, 11) /* Dictionary string  */\n#define MJS_TAG_ARRAY MAKE_TAG(1, 12)\n#define MJS_TAG_FUNCTION MAKE_TAG(1, 13)\n#define MJS_TAG_FUNCTION_FFI MAKE_TAG(1, 14)\n#define MJS_TAG_NULL MAKE_TAG(1, 15)\n\n#define MJS_TAG_MASK MAKE_TAG(1, 15)\n\nstruct mjs_vals {\n  /* Current `this` value  */\n  mjs_val_t this_obj;\n  mjs_val_t dataview_proto;\n\n  /*\n   * The object against which the last `OP_GET` was invoked. Needed for\n   * \"method invocation pattern\".\n   */\n  mjs_val_t last_getprop_obj;\n};\n\nstruct mjs_bcode_part {\n  /* Global index of the bcode part */\n  size_t start_idx;\n\n  /* Actual bcode data */\n  struct {\n    const char *p; /* Memory chunk pointer */\n    size_t len;    /* Memory chunk length */\n  } data;\n\n  /*\n   * Result of evaluation (not parsing: if there is an error during parsing,\n   * the bcode is not even committed). It is used to determine whether we\n   * need to evaluate the file: if file was already evaluated, and the result\n   * was MJS_OK, then we won't evaluate it again. Otherwise, we will.\n   */\n  mjs_err_t exec_res : 4;\n\n  /* If set, bcode data does not need to be freed */\n  unsigned in_rom : 1;\n};\n\nstruct mjs {\n  struct mbuf bcode_gen;\n  struct mbuf bcode_parts;\n  size_t bcode_len;\n  struct mbuf stack;\n  struct mbuf call_stack;\n  struct mbuf arg_stack;\n  struct mbuf scopes;          /* Scope objects */\n  struct mbuf loop_addresses;  /* Addresses for breaks & continues */\n  struct mbuf owned_strings;   /* Sequence of (varint len, char data[]) */\n  struct mbuf foreign_strings; /* Sequence of (varint len, char *data) */\n  struct mbuf owned_values;\n  struct mbuf json_visited_stack;\n  struct mjs_vals vals;\n  char *error_msg;\n  char *stack_trace;\n  enum mjs_err error;\n  mjs_ffi_resolver_t *dlsym;  /* Symbol resolver function for FFI */\n  ffi_cb_args_t *ffi_cb_args; /* List of FFI args descriptors */\n  size_t cur_bcode_offset;\n\n  struct gc_arena object_arena;\n  struct gc_arena property_arena;\n  struct gc_arena ffi_sig_arena;\n\n  unsigned inhibit_gc : 1;\n  unsigned need_gc : 1;\n  unsigned generate_jsc : 1;\n};\n\n/*\n * Bcode header: type of the items, and item numbers.\n */\ntypedef uint32_t mjs_header_item_t;\nenum mjs_header_items {\n  MJS_HDR_ITEM_TOTAL_SIZE,   /* Total size of the bcode (not counting the\n                                OP_BCODE_HEADER byte) */\n  MJS_HDR_ITEM_BCODE_OFFSET, /* Offset to the start of the actual bcode (not\n                                counting the OP_BCODE_HEADER byte) */\n  MJS_HDR_ITEM_MAP_OFFSET,   /* Offset to the start of offset-to-line_no mapping\n                                k*/\n\n  MJS_HDR_ITEMS_CNT\n};\n\nMJS_PRIVATE size_t mjs_get_func_addr(mjs_val_t v);\n\nMJS_PRIVATE int mjs_getretvalpos(struct mjs *mjs);\n\nMJS_PRIVATE enum mjs_type mjs_get_type(mjs_val_t v);\n\n/*\n * Prints stack trace starting from the given bcode offset; other offsets\n * (if any) will be fetched from the call_stack.\n */\nMJS_PRIVATE void mjs_gen_stack_trace(struct mjs *mjs, size_t offset);\n\nMJS_PRIVATE mjs_val_t vtop(struct mbuf *m);\nMJS_PRIVATE size_t mjs_stack_size(const struct mbuf *m);\nMJS_PRIVATE mjs_val_t *vptr(struct mbuf *m, int idx);\nMJS_PRIVATE void push_mjs_val(struct mbuf *m, mjs_val_t v);\nMJS_PRIVATE mjs_val_t mjs_pop_val(struct mbuf *m);\nMJS_PRIVATE mjs_val_t mjs_pop(struct mjs *mjs);\nMJS_PRIVATE void mjs_push(struct mjs *mjs, mjs_val_t v);\nMJS_PRIVATE void mjs_die(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CORE_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_conversion.h\"\n#endif\n\n#ifndef MJS_CONVERSION_H_\n#define MJS_CONVERSION_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Tries to convert `mjs_val_t` to a string, returns MJS_OK if successful.\n * String is returned as a pair of pointers: `char **p, size_t *sizep`.\n *\n * Caller must also provide a non-null `need_free`, and if it is non-zero,\n * then the string `*p` should be freed by the caller.\n *\n * MJS does not support `toString()` and `valueOf()`, so, passing an object\n * always results in `MJS_TYPE_ERROR`.\n */\nMJS_PRIVATE mjs_err_t mjs_to_string(struct mjs *mjs, mjs_val_t *v, char **p,\n                                    size_t *sizep, int *need_free);\n\n/*\n * Converts value to boolean as in the expression `if (v)`.\n */\nMJS_PRIVATE mjs_val_t mjs_to_boolean_v(struct mjs *mjs, mjs_val_t v);\n\nMJS_PRIVATE int mjs_is_truthy(struct mjs *mjs, mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CONVERSION_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object.h\"\n#endif\n\n#ifndef MJS_OBJECT_H_\n#define MJS_OBJECT_H_\n\n/* Amalgamated: #include \"mjs_object_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs;\n\nstruct mjs_property {\n  struct mjs_property *next; /* Linkage in struct mjs_object::properties */\n  mjs_val_t name;            /* Property name (a string) */\n  mjs_val_t value;           /* Property value */\n};\n\nstruct mjs_object {\n  struct mjs_property *properties;\n};\n\nMJS_PRIVATE struct mjs_object *get_object_struct(mjs_val_t v);\nMJS_PRIVATE struct mjs_property *mjs_get_own_property(struct mjs *mjs,\n                                                      mjs_val_t obj,\n                                                      const char *name,\n                                                      size_t len);\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property_v(struct mjs *mjs,\n                                                        mjs_val_t obj,\n                                                        mjs_val_t key);\n\n/*\n * A worker function for `mjs_set()` and `mjs_set_v()`: it takes name as both\n * ptr+len and mjs_val_t. If `name` pointer is not NULL, it takes precedence\n * over `name_v`.\n */\nMJS_PRIVATE mjs_err_t mjs_set_internal(struct mjs *mjs, mjs_val_t obj,\n                                       mjs_val_t name_v, char *name,\n                                       size_t name_len, mjs_val_t val);\n\n/*\n * Implementation of `Object.create(proto)`\n */\nMJS_PRIVATE void mjs_op_create_object(struct mjs *mjs);\n\n#define MJS_PROTO_PROP_NAME \"__p\" /* Make it < 5 chars */\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_OBJECT_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive.h\"\n#endif\n\n#ifndef MJS_PRIMITIVE_H\n#define MJS_PRIMITIVE_H\n\n/* Amalgamated: #include \"mjs_primitive_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Convert a pointer to mjs_val_t. If pointer is not valid, mjs crashes.\n */\nMJS_PRIVATE mjs_val_t mjs_legit_pointer_to_value(void *p);\n\n/*\n * Convert a pointer to mjs_val_t. If pointer is not valid, error is set\n * in the mjs context.\n */\nMJS_PRIVATE mjs_val_t mjs_pointer_to_value(struct mjs *mjs, void *p);\n\n/*\n * Extracts a pointer from the mjs_val_t value.\n */\nMJS_PRIVATE void *get_ptr(mjs_val_t v);\n\n/*\n * Implementation for JS isNaN()\n */\nMJS_PRIVATE void mjs_op_isnan(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PRIMITIVE_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string.h\"\n#endif\n\n#ifndef MJS_STRING_H_\n#define MJS_STRING_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_string_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Size of the extra space for strings mbuf that is needed to avoid frequent\n * reallocations\n */\n#define _MJS_STRING_BUF_RESERVE 100\n\nMJS_PRIVATE unsigned long cstr_to_ulong(const char *s, size_t len, int *ok);\nMJS_PRIVATE mjs_err_t\nstr_to_ulong(struct mjs *mjs, mjs_val_t v, int *ok, unsigned long *res);\nMJS_PRIVATE int s_cmp(struct mjs *mjs, mjs_val_t a, mjs_val_t b);\nMJS_PRIVATE mjs_val_t s_concat(struct mjs *mjs, mjs_val_t a, mjs_val_t b);\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags);\n\nMJS_PRIVATE void mjs_mkstr(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_string_slice(struct mjs *mjs);\nMJS_PRIVATE void mjs_string_index_of(struct mjs *mjs);\nMJS_PRIVATE void mjs_string_char_code_at(struct mjs *mjs);\n\n#define EMBSTR_ZERO_TERM 1\n#define EMBSTR_UNESCAPE 2\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_STRING_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util.h\"\n#endif\n\n#ifndef MJS_UTIL_H_\n#define MJS_UTIL_H_\n\n/* Amalgamated: #include \"frozen.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_util_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs_bcode_part;\n\n#if MJS_ENABLE_DEBUG\nMJS_PRIVATE const char *opcodetostr(uint8_t opcode);\nMJS_PRIVATE size_t mjs_disasm_single(const uint8_t *code, size_t i);\n#endif\n\nMJS_PRIVATE const char *mjs_stringify_type(enum mjs_type t);\n\n/*\n * Checks that the given argument is provided, and checks its type. If check\n * fails, sets error in the mjs context, and returns 0; otherwise returns 1.\n *\n * If `arg_num` >= 0, checks argument; otherwise (`arg_num` is negative) checks\n * `this`. `arg_name` is used for the error message only. If `parg` is not\n * NULL, writes resulting value at this location in case of success.\n */\nMJS_PRIVATE int mjs_check_arg(struct mjs *mjs, int arg_num,\n                              const char *arg_name, enum mjs_type expected_type,\n                              mjs_val_t *parg);\n\n/*\n * mjs_normalize_idx takes and index in the string and the string size, and\n * returns the index which is >= 0 and <= size. Negative index is interpreted\n * as size + index.\n */\nMJS_PRIVATE int mjs_normalize_idx(int idx, int size);\n\nMJS_PRIVATE const char *mjs_get_bcode_filename(struct mjs *mjs,\n                                               struct mjs_bcode_part *bp);\n\n/* Print JS value `v` to the JSON stream `out`. */\nvoid mjs_jprintf(mjs_val_t v, struct mjs *mjs, struct json_out *out);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_UTIL_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_varint.h\"\n#endif\n\n#ifndef CS_COMMON_CS_VARINT_H_\n#define CS_COMMON_CS_VARINT_H_\n\n#if defined(_WIN32) && _MSC_VER < 1700\ntypedef unsigned char uint8_t;\ntypedef unsigned __int64 uint64_t;\n#else\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Returns number of bytes required to encode `num`. */\nsize_t cs_varint_llen(uint64_t num);\n\n/*\n * Encodes `num` into `buf`.\n * Returns number of bytes required to encode `num`.\n * Note: return value may be greater than `buf_size` but the function will only\n * write `buf_size` bytes.\n */\nsize_t cs_varint_encode(uint64_t num, uint8_t *buf, size_t buf_size);\n\n/*\n * Decodes varint stored in `buf`.\n * Stores the number of bytes consumed into `llen`.\n * If there aren't enough bytes in `buf` to decode a number, returns false.\n */\nbool cs_varint_decode(const uint8_t *buf, size_t buf_size, uint64_t *num,\n                      size_t *llen);\n\nuint64_t cs_varint_decode_unsafe(const uint8_t *buf, int *llen);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CS_COMMON_CS_VARINT_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_bcode.h\"\n#endif\n\n#ifndef MJS_BCODE_H_\n#define MJS_BCODE_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n/* Amalgamated: #include \"mjs_core.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum mjs_opcode {\n  OP_NOP,               /* ( -- ) */\n  OP_DROP,              /* ( a -- ) */\n  OP_DUP,               /* ( a -- a a ) */\n  OP_SWAP,              /* ( a b -- b a ) */\n  OP_JMP,               /* ( -- ) */\n  OP_JMP_TRUE,          /* ( -- ) */\n  OP_JMP_NEUTRAL_TRUE,  /* ( -- ) */\n  OP_JMP_FALSE,         /* ( -- ) */\n  OP_JMP_NEUTRAL_FALSE, /* ( -- ) */\n  OP_FIND_SCOPE,        /* ( a -- a b ) */\n  OP_PUSH_SCOPE,        /* ( -- a ) */\n  OP_PUSH_STR,          /* ( -- a ) */\n  OP_PUSH_TRUE,         /* ( -- a ) */\n  OP_PUSH_FALSE,        /* ( -- a ) */\n  OP_PUSH_INT,          /* ( -- a ) */\n  OP_PUSH_DBL,          /* ( -- a ) */\n  OP_PUSH_NULL,         /* ( -- a ) */\n  OP_PUSH_UNDEF,        /* ( -- a ) */\n  OP_PUSH_OBJ,          /* ( -- a ) */\n  OP_PUSH_ARRAY,        /* ( -- a ) */\n  OP_PUSH_FUNC,         /* ( -- a ) */\n  OP_PUSH_THIS,         /* ( -- a ) */\n  OP_GET,               /* ( key obj  -- obj[key] ) */\n  OP_CREATE,            /* ( key obj -- ) */\n  OP_EXPR,              /* ( ... -- a ) */\n  OP_APPEND,            /* ( a b -- ) */\n  OP_SET_ARG,           /* ( a -- a ) */\n  OP_NEW_SCOPE,         /* ( -- ) */\n  OP_DEL_SCOPE,         /* ( -- ) */\n  OP_CALL,              /* ( func param1 param2 ... num_params -- result ) */\n  OP_RETURN,            /* ( -- ) */\n  OP_LOOP,         /* ( -- ) Push break & continue addresses to loop_labels */\n  OP_BREAK,        /* ( -- ) */\n  OP_CONTINUE,     /* ( -- ) */\n  OP_SETRETVAL,    /* ( a -- ) */\n  OP_EXIT,         /* ( -- ) */\n  OP_BCODE_HEADER, /* ( -- ) */\n  OP_ARGS,         /* ( -- ) Mark the beginning of function call arguments */\n  OP_FOR_IN_NEXT,  /* ( name obj iter_ptr -- name obj iter_ptr_next ) */\n  OP_MAX\n};\n\nstruct pstate;\nstruct mjs;\n\nMJS_PRIVATE void emit_byte(struct pstate *pstate, uint8_t byte);\nMJS_PRIVATE void emit_int(struct pstate *pstate, int64_t n);\nMJS_PRIVATE void emit_str(struct pstate *pstate, const char *ptr, size_t len);\n\n/*\n * Inserts provided offset `v` at the offset `offset`.\n *\n * Returns delta at which the code was moved; the delta can be any: 0 or\n * positive or negative.\n */\nMJS_PRIVATE int mjs_bcode_insert_offset(struct pstate *p, struct mjs *mjs,\n                                        size_t offset, size_t v);\n\n/*\n * Adds a new bcode part; does not retain `bp`.\n */\nMJS_PRIVATE void mjs_bcode_part_add(struct mjs *mjs,\n                                    const struct mjs_bcode_part *bp);\n\n/*\n * Returns bcode part by the bcode number\n */\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get(struct mjs *mjs, int num);\n\n/*\n * Returns bcode part by the global bcode offset\n */\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get_by_offset(struct mjs *mjs,\n                                                                size_t offset);\n\n/*\n * Returns a number of bcode parts\n */\nMJS_PRIVATE int mjs_bcode_parts_cnt(struct mjs *mjs);\n\n/*\n * Adds the bcode being generated (mjs->bcode_gen) as a next bcode part\n */\nMJS_PRIVATE void mjs_bcode_commit(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_BCODE_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_tok.h\"\n#endif\n\n#ifndef MJS_TOK_H_\n#define MJS_TOK_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct tok {\n  int tok;\n  int len;\n  const char *ptr;\n};\n\nstruct pstate {\n  const char *file_name; /* Source code file name */\n  const char *buf;       /* Nul-terminated source code buffer */\n  const char *pos;       /* Current position */\n  int line_no;           /* Line number */\n  int last_emitted_line_no;\n  struct mbuf offset_lineno_map;\n  int prev_tok;   /* Previous token, for prefix increment / decrement */\n  struct tok tok; /* Parsed token */\n  struct mjs *mjs;\n  int start_bcode_idx; /* Index in mjs->bcode at which parsing was started */\n  int cur_idx; /* Index in mjs->bcode at which newly generated code is inserted\n                  */\n  int depth;\n};\n\nenum {\n  TOK_EOF,\n  TOK_INVALID,\n\n  TOK_COLON,\n  TOK_SEMICOLON,\n  TOK_COMMA,\n  TOK_ASSIGN,\n  TOK_OPEN_CURLY,\n  TOK_CLOSE_CURLY,\n  TOK_OPEN_PAREN,\n  TOK_CLOSE_PAREN,\n  TOK_OPEN_BRACKET,\n  TOK_CLOSE_BRACKET,\n  TOK_MUL,\n  TOK_PLUS,\n  TOK_MINUS,\n  TOK_DIV,\n  TOK_REM,\n  TOK_AND,\n  TOK_OR,\n  TOK_XOR,\n  TOK_DOT,\n  TOK_QUESTION,\n  TOK_NOT,\n  TOK_TILDA,\n  TOK_LT,\n  TOK_GT,\n  TOK_LSHIFT,\n  TOK_RSHIFT,\n  TOK_MINUS_MINUS,\n  TOK_PLUS_PLUS,\n  TOK_PLUS_ASSIGN,\n  TOK_MINUS_ASSIGN,\n  TOK_MUL_ASSIGN,\n  TOK_DIV_ASSIGN,\n  TOK_AND_ASSIGN,\n  TOK_OR_ASSIGN,\n  TOK_REM_ASSIGN,\n  TOK_XOR_ASSIGN,\n  TOK_EQ,\n  TOK_NE,\n  TOK_LE,\n  TOK_GE,\n  TOK_LOGICAL_AND,\n  TOK_LOGICAL_OR,\n  TOK_EQ_EQ,\n  TOK_NE_NE,\n  TOK_LSHIFT_ASSIGN,\n  TOK_RSHIFT_ASSIGN,\n  TOK_URSHIFT,\n  TOK_URSHIFT_ASSIGN,\n\n  TOK_UNARY_PLUS,\n  TOK_UNARY_MINUS,\n  TOK_POSTFIX_PLUS,\n  TOK_POSTFIX_MINUS,\n\n  TOK_NUM = 200, /* Make sure they don't clash with ascii '+', '{', etc */\n  TOK_STR,\n  TOK_IDENT,\n  TOK_KEYWORD_BREAK,\n  TOK_KEYWORD_CASE,\n  TOK_KEYWORD_CATCH,\n  TOK_KEYWORD_CONTINUE,\n  TOK_KEYWORD_DEBUGGER,\n  TOK_KEYWORD_DEFAULT,\n  TOK_KEYWORD_DELETE,\n  TOK_KEYWORD_DO,\n  TOK_KEYWORD_ELSE,\n  TOK_KEYWORD_FALSE,\n  TOK_KEYWORD_FINALLY,\n  TOK_KEYWORD_FOR,\n  TOK_KEYWORD_FUNCTION,\n  TOK_KEYWORD_IF,\n  TOK_KEYWORD_IN,\n  TOK_KEYWORD_INSTANCEOF,\n  TOK_KEYWORD_NEW,\n  TOK_KEYWORD_NULL,\n  TOK_KEYWORD_RETURN,\n  TOK_KEYWORD_SWITCH,\n  TOK_KEYWORD_THIS,\n  TOK_KEYWORD_THROW,\n  TOK_KEYWORD_TRUE,\n  TOK_KEYWORD_TRY,\n  TOK_KEYWORD_TYPEOF,\n  TOK_KEYWORD_VAR,\n  TOK_KEYWORD_VOID,\n  TOK_KEYWORD_WHILE,\n  TOK_KEYWORD_WITH,\n  TOK_KEYWORD_LET,\n  TOK_KEYWORD_UNDEFINED,\n  TOK_MAX\n};\n\nMJS_PRIVATE void pinit(const char *file_name, const char *buf, struct pstate *);\nMJS_PRIVATE int pnext(struct pstate *);\nMJS_PRIVATE int mjs_is_ident(int c);\nMJS_PRIVATE int mjs_is_digit(int c);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_TOK_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_dataview.h\"\n#endif\n\n#ifndef MJS_DATAVIEW_H_\n#define MJS_DATAVIEW_H_\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Functions for memory introspection.\n * These are supposed to be FFI-ed and used from the JS environment.\n */\n\nvoid *mjs_mem_to_ptr(unsigned int val);\nvoid *mjs_mem_get_ptr(void *base, int offset);\nvoid mjs_mem_set_ptr(void *ptr, void *val);\ndouble mjs_mem_get_dbl(void *ptr);\nvoid mjs_mem_set_dbl(void *ptr, double val);\ndouble mjs_mem_get_uint(void *ptr, int size, int bigendian);\ndouble mjs_mem_get_int(void *ptr, int size, int bigendian);\nvoid mjs_mem_set_uint(void *ptr, unsigned int val, int size, int bigendian);\nvoid mjs_mem_set_int(void *ptr, int val, int size, int bigendian);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_DATAVIEW_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec.h\"\n#endif\n\n#ifndef MJS_EXEC_H_\n#define MJS_EXEC_H_\n\n/* Amalgamated: #include \"mjs_exec_public.h\" */\n\n/*\n * A special bcode offset value which causes mjs_execute() to exit immediately;\n * used in mjs_apply().\n */\n#define MJS_BCODE_OFFSET_EXIT ((size_t) 0x7fffffff)\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_EXEC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_json.h\"\n#endif\n\n#ifndef MJS_JSON_H_\n#define MJS_JSON_H_\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t to_json_or_debug(struct mjs *mjs, mjs_val_t v, char *buf,\n                                       size_t size, size_t *res_len,\n                                       uint8_t is_debug);\n\nMJS_PRIVATE mjs_err_t mjs_json_stringify(struct mjs *mjs, mjs_val_t v,\n                                         char *buf, size_t size, char **res);\nMJS_PRIVATE void mjs_op_json_stringify(struct mjs *mjs);\nMJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs);\n\nMJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_JSON_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_builtin.h\"\n#endif\n\n#ifndef MJS_BUILTIN_H_\n#define MJS_BUILTIN_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nvoid mjs_init_builtin(struct mjs *mjs, mjs_val_t obj);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_BUILTIN_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_parser.h\"\n#endif\n\n#ifndef MJS_PARSER_H\n#define MJS_PARSER_H\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t\nmjs_parse(const char *path, const char *buf, struct mjs *);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PARSER_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_dbg.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\nenum cs_log_level cs_log_level WEAK =\n#if CS_ENABLE_DEBUG\n    LL_VERBOSE_DEBUG;\n#else\n    LL_ERROR;\n#endif\n\n#if CS_ENABLE_STDIO\nstatic char *s_file_level = NULL;\n\nvoid cs_log_set_file_level(const char *file_level) WEAK;\n\nFILE *cs_log_file WEAK = NULL;\n\n#if CS_LOG_ENABLE_TS_DIFF\ndouble cs_log_ts WEAK;\n#endif\n\nenum cs_log_level cs_log_cur_msg_level WEAK = LL_NONE;\n\nvoid cs_log_set_file_level(const char *file_level) {\n  char *fl = s_file_level;\n  if (file_level != NULL) {\n    s_file_level = strdup(file_level);\n  } else {\n    s_file_level = NULL;\n  }\n  free(fl);\n}\n\nint cs_log_print_prefix(enum cs_log_level level, const char *file, int ln) WEAK;\nint cs_log_print_prefix(enum cs_log_level level, const char *file, int ln) {\n  char prefix[CS_LOG_PREFIX_LEN], *q;\n  const char *p;\n  size_t fl = 0, ll = 0, pl = 0;\n\n  if (level > cs_log_level && s_file_level == NULL) return 0;\n\n  p = file + strlen(file);\n\n  while (p != file) {\n    const char c = *(p - 1);\n    if (c == '/' || c == '\\\\') break;\n    p--;\n    fl++;\n  }\n\n  ll = (ln < 10000 ? (ln < 1000 ? (ln < 100 ? (ln < 10 ? 1 : 2) : 3) : 4) : 5);\n  if (fl > (sizeof(prefix) - ll - 2)) fl = (sizeof(prefix) - ll - 2);\n\n  pl = fl + 1 + ll;\n  memcpy(prefix, p, fl);\n  q = prefix + pl;\n  memset(q, ' ', sizeof(prefix) - pl);\n  do {\n    *(--q) = '0' + (ln % 10);\n    ln /= 10;\n  } while (ln > 0);\n  *(--q) = ':';\n\n  if (s_file_level != NULL) {\n    enum cs_log_level pll = cs_log_level;\n    struct mg_str fl = mg_mk_str(s_file_level), ps = MG_MK_STR_N(prefix, pl);\n    struct mg_str k, v;\n    while ((fl = mg_next_comma_list_entry_n(fl, &k, &v)).p != NULL) {\n      bool yes = !(!mg_str_starts_with(ps, k) || v.len == 0);\n      if (!yes) continue;\n      pll = (enum cs_log_level)(*v.p - '0');\n      break;\n    }\n    if (level > pll) return 0;\n  }\n\n  if (cs_log_file == NULL) cs_log_file = stderr;\n  cs_log_cur_msg_level = level;\n  fwrite(prefix, 1, sizeof(prefix), cs_log_file);\n#if CS_LOG_ENABLE_TS_DIFF\n  {\n    double now = cs_time();\n    fprintf(cs_log_file, \"%7u \", (unsigned int) ((now - cs_log_ts) * 1000000));\n    cs_log_ts = now;\n  }\n#endif\n  return 1;\n}\n\nvoid cs_log_printf(const char *fmt, ...) WEAK;\nvoid cs_log_printf(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(cs_log_file, fmt, ap);\n  va_end(ap);\n  fputc('\\n', cs_log_file);\n  fflush(cs_log_file);\n  cs_log_cur_msg_level = LL_NONE;\n}\n\nvoid cs_log_set_file(FILE *file) WEAK;\nvoid cs_log_set_file(FILE *file) {\n  cs_log_file = file;\n}\n\n#else\n\nvoid cs_log_set_file_level(const char *file_level) {\n  (void) file_level;\n}\n\n#endif /* CS_ENABLE_STDIO */\n\nvoid cs_log_set_level(enum cs_log_level level) WEAK;\nvoid cs_log_set_level(enum cs_log_level level) {\n  cs_log_level = level;\n#if CS_LOG_ENABLE_TS_DIFF && CS_ENABLE_STDIO\n  cs_log_ts = cs_time();\n#endif\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_file.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_file.h\" */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef CS_MMAP\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#endif\n\n#ifndef EXCLUDE_COMMON\nchar *cs_read_file(const char *path, size_t *size) WEAK;\nchar *cs_read_file(const char *path, size_t *size) {\n  FILE *fp;\n  char *data = NULL;\n  if ((fp = fopen(path, \"rb\")) == NULL) {\n  } else if (fseek(fp, 0, SEEK_END) != 0) {\n    fclose(fp);\n  } else {\n    *size = ftell(fp);\n    data = (char *) malloc(*size + 1);\n    if (data != NULL) {\n      fseek(fp, 0, SEEK_SET); /* Some platforms might not have rewind(), Oo */\n      if (fread(data, 1, *size, fp) != *size) {\n        free(data);\n        return NULL;\n      }\n      data[*size] = '\\0';\n    }\n    fclose(fp);\n  }\n  return data;\n}\n#endif /* EXCLUDE_COMMON */\n\n#ifdef CS_MMAP\nchar *cs_mmap_file(const char *path, size_t *size) WEAK;\nchar *cs_mmap_file(const char *path, size_t *size) {\n  char *r;\n  int fd = open(path, O_RDONLY, 0);\n  struct stat st;\n  if (fd < 0) return NULL;\n  fstat(fd, &st);\n  *size = (size_t) st.st_size;\n  r = (char *) mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n  if (r == MAP_FAILED) return NULL;\n  return r;\n}\n#endif\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/cs_varint.c\"\n#endif\n\n/* Amalgamated: #include \"cs_varint.h\" */\n\nsize_t cs_varint_llen(uint64_t num) {\n  size_t llen = 0;\n\n  do {\n    llen++;\n  } while (num >>= 7);\n\n  return llen;\n}\n\nsize_t cs_varint_encode(uint64_t num, uint8_t *buf, size_t buf_size) {\n  size_t llen = 0;\n\n  do {\n    uint8_t byte = num & 0x7f;\n    num >>= 7;\n    if (num != 0) byte |= 0x80;\n    if (llen < buf_size) *buf++ = byte;\n    llen++;\n  } while (num != 0);\n\n  return llen;\n}\n\nbool cs_varint_decode(const uint8_t *buf, size_t buf_size, uint64_t *num,\n                      size_t *llen) {\n  size_t i = 0, shift = 0;\n  uint64_t n = 0;\n\n  do {\n    if (i == buf_size || i == (8 * sizeof(*num) / 7 + 1)) return false;\n    /*\n     * Each byte of varint contains 7 bits, in little endian order.\n     * MSB is a continuation bit: it tells whether next byte is used.\n     */\n    n |= ((uint64_t)(buf[i] & 0x7f)) << shift;\n    /*\n     * First we increment i, then check whether it is within boundary and\n     * whether decoded byte had continuation bit set.\n     */\n    i++;\n    shift += 7;\n  } while (shift < sizeof(uint64_t) * 8 && (buf[i - 1] & 0x80));\n\n  *num = n;\n  *llen = i;\n\n  return true;\n}\n\nuint64_t cs_varint_decode_unsafe(const uint8_t *buf, int *llen) {\n  uint64_t v;\n  size_t l;\n  cs_varint_decode(buf, ~0, &v, &l);\n  *llen = l;\n  return v;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/mbuf.c\"\n#endif\n\n#ifndef EXCLUDE_COMMON\n\n#include <assert.h>\n#include <string.h>\n/* Amalgamated: #include \"common/mbuf.h\" */\n\n#ifndef MBUF_REALLOC\n#define MBUF_REALLOC realloc\n#endif\n\n#ifndef MBUF_FREE\n#define MBUF_FREE free\n#endif\n\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) WEAK;\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) {\n  mbuf->len = mbuf->size = 0;\n  mbuf->buf = NULL;\n  mbuf_resize(mbuf, initial_size);\n}\n\nvoid mbuf_free(struct mbuf *mbuf) WEAK;\nvoid mbuf_free(struct mbuf *mbuf) {\n  if (mbuf->buf != NULL) {\n    MBUF_FREE(mbuf->buf);\n    mbuf_init(mbuf, 0);\n  }\n}\n\nvoid mbuf_resize(struct mbuf *a, size_t new_size) WEAK;\nvoid mbuf_resize(struct mbuf *a, size_t new_size) {\n  if (new_size > a->size || (new_size < a->size && new_size >= a->len)) {\n    char *buf = (char *) MBUF_REALLOC(a->buf, new_size);\n    /*\n     * In case realloc fails, there's not much we can do, except keep things as\n     * they are. Note that NULL is a valid return value from realloc when\n     * size == 0, but that is covered too.\n     */\n    if (buf == NULL && new_size != 0) return;\n    a->buf = buf;\n    a->size = new_size;\n  }\n}\n\nvoid mbuf_trim(struct mbuf *mbuf) WEAK;\nvoid mbuf_trim(struct mbuf *mbuf) {\n  mbuf_resize(mbuf, mbuf->len);\n}\n\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t) WEAK;\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t len) {\n  char *p = NULL;\n\n  assert(a != NULL);\n  assert(a->len <= a->size);\n  assert(off <= a->len);\n\n  /* check overflow */\n  if (~(size_t) 0 - (size_t) a->buf < len) return 0;\n\n  if (a->len + len <= a->size) {\n    memmove(a->buf + off + len, a->buf + off, a->len - off);\n    if (buf != NULL) {\n      memcpy(a->buf + off, buf, len);\n    }\n    a->len += len;\n  } else {\n    size_t min_size = (a->len + len);\n    size_t new_size = (size_t)(min_size * MBUF_SIZE_MULTIPLIER);\n    if (new_size - min_size > MBUF_SIZE_MAX_HEADROOM) {\n      new_size = min_size + MBUF_SIZE_MAX_HEADROOM;\n    }\n    p = (char *) MBUF_REALLOC(a->buf, new_size);\n    if (p == NULL && new_size != min_size) {\n      new_size = min_size;\n      p = (char *) MBUF_REALLOC(a->buf, new_size);\n    }\n    if (p != NULL) {\n      a->buf = p;\n      if (off != a->len) {\n        memmove(a->buf + off + len, a->buf + off, a->len - off);\n      }\n      if (buf != NULL) memcpy(a->buf + off, buf, len);\n      a->len += len;\n      a->size = new_size;\n    } else {\n      len = 0;\n    }\n  }\n\n  return len;\n}\n\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) WEAK;\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) {\n  return mbuf_insert(a, a->len, buf, len);\n}\n\nsize_t mbuf_append_and_free(struct mbuf *a, void *buf, size_t len) WEAK;\nsize_t mbuf_append_and_free(struct mbuf *a, void *data, size_t len) {\n  size_t ret;\n  /* Optimization: if the buffer is currently empty,\n   * take over the user-provided buffer. */\n  if (a->len == 0) {\n    if (a->buf != NULL) free(a->buf);\n    a->buf = (char *) data;\n    a->len = a->size = len;\n    return len;\n  }\n  ret = mbuf_insert(a, a->len, data, len);\n  free(data);\n  return ret;\n}\n\nvoid mbuf_remove(struct mbuf *mb, size_t n) WEAK;\nvoid mbuf_remove(struct mbuf *mb, size_t n) {\n  if (n > 0 && n <= mb->len) {\n    memmove(mb->buf, mb->buf + n, mb->len - n);\n    mb->len -= n;\n  }\n}\n\nvoid mbuf_clear(struct mbuf *mb) WEAK;\nvoid mbuf_clear(struct mbuf *mb) {\n  mb->len = 0;\n}\n\nvoid mbuf_move(struct mbuf *from, struct mbuf *to) WEAK;\nvoid mbuf_move(struct mbuf *from, struct mbuf *to) {\n  memcpy(to, from, sizeof(*to));\n  memset(from, 0, sizeof(*from));\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/mg_str.c\"\n#endif\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\n\nstruct mg_str mg_mk_str(const char *s) WEAK;\nstruct mg_str mg_mk_str(const char *s) {\n  struct mg_str ret = {s, 0};\n  if (s != NULL) ret.len = strlen(s);\n  return ret;\n}\n\nstruct mg_str mg_mk_str_n(const char *s, size_t len) WEAK;\nstruct mg_str mg_mk_str_n(const char *s, size_t len) {\n  struct mg_str ret = {s, len};\n  return ret;\n}\n\nint mg_vcmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = strncmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nstatic struct mg_str mg_strdup_common(const struct mg_str s,\n                                      int nul_terminate) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.p != NULL) {\n    char *sc = (char *) MG_MALLOC(s.len + (nul_terminate ? 1 : 0));\n    if (sc != NULL) {\n      memcpy(sc, s.p, s.len);\n      if (nul_terminate) sc[s.len] = '\\0';\n      r.p = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) WEAK;\nstruct mg_str mg_strdup(const struct mg_str s) {\n  return mg_strdup_common(s, 0 /* NUL-terminate */);\n}\n\nstruct mg_str mg_strdup_nul(const struct mg_str s) WEAK;\nstruct mg_str mg_strdup_nul(const struct mg_str s) {\n  return mg_strdup_common(s, 1 /* NUL-terminate */);\n}\n\nconst char *mg_strchr(const struct mg_str s, int c) WEAK;\nconst char *mg_strchr(const struct mg_str s, int c) {\n  size_t i;\n  for (i = 0; i < s.len; i++) {\n    if (s.p[i] == c) return &s.p[i];\n  }\n  return NULL;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) WEAK;\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.p[i];\n    int c2 = str2.p[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nint mg_strncmp(const struct mg_str, const struct mg_str, size_t n) WEAK;\nint mg_strncmp(const struct mg_str str1, const struct mg_str str2, size_t n) {\n  struct mg_str s1 = str1;\n  struct mg_str s2 = str2;\n\n  if (s1.len > n) {\n    s1.len = n;\n  }\n  if (s2.len > n) {\n    s2.len = n;\n  }\n  return mg_strcmp(s1, s2);\n}\n\nint mg_strcasecmp(const struct mg_str str1, const struct mg_str str2) WEAK;\nint mg_strcasecmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = tolower((int) str1.p[i]);\n    int c2 = tolower((int) str2.p[i]);\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nvoid mg_strfree(struct mg_str *s) WEAK;\nvoid mg_strfree(struct mg_str *s) {\n  char *sp = (char *) s->p;\n  s->p = NULL;\n  s->len = 0;\n  if (sp != NULL) free(sp);\n}\n\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) WEAK;\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) {\n  size_t i;\n  if (needle.len > haystack.len) return NULL;\n  for (i = 0; i <= haystack.len - needle.len; i++) {\n    if (memcmp(haystack.p + i, needle.p, needle.len) == 0) {\n      return haystack.p + i;\n    }\n  }\n  return NULL;\n}\n\nstruct mg_str mg_strstrip(struct mg_str s) WEAK;\nstruct mg_str mg_strstrip(struct mg_str s) {\n  while (s.len > 0 && isspace((int) *s.p)) {\n    s.p++;\n    s.len--;\n  }\n  while (s.len > 0 && isspace((int) *(s.p + s.len - 1))) {\n    s.len--;\n  }\n  return s;\n}\n\nint mg_str_starts_with(struct mg_str s, struct mg_str prefix) WEAK;\nint mg_str_starts_with(struct mg_str s, struct mg_str prefix) {\n  const struct mg_str sp = MG_MK_STR_N(s.p, prefix.len);\n  if (s.len < prefix.len) return 0;\n  return (mg_strcmp(sp, prefix) == 0);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/common/str_util.c\"\n#endif\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/str_util.h\" */\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifndef C_DISABLE_BUILTIN_SNPRINTF\n#define C_DISABLE_BUILTIN_SNPRINTF 0\n#endif\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\nsize_t c_strnlen(const char *s, size_t maxlen) WEAK;\nsize_t c_strnlen(const char *s, size_t maxlen) {\n  size_t l = 0;\n  for (; l < maxlen && s[l] != '\\0'; l++) {\n  }\n  return l;\n}\n\n#define C_SNPRINTF_APPEND_CHAR(ch)       \\\n  do {                                   \\\n    if (i < (int) buf_size) buf[i] = ch; \\\n    i++;                                 \\\n  } while (0)\n\n#define C_SNPRINTF_FLAG_ZERO 1\n\n#if C_DISABLE_BUILTIN_SNPRINTF\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  return vsnprintf(buf, buf_size, fmt, ap);\n}\n#else\nstatic int c_itoa(char *buf, size_t buf_size, int64_t num, int base, int flags,\n                  int field_width) {\n  char tmp[40];\n  int i = 0, k = 0, neg = 0;\n\n  if (num < 0) {\n    neg++;\n    num = -num;\n  }\n\n  /* Print into temporary buffer - in reverse order */\n  do {\n    int rem = num % base;\n    if (rem < 10) {\n      tmp[k++] = '0' + rem;\n    } else {\n      tmp[k++] = 'a' + (rem - 10);\n    }\n    num /= base;\n  } while (num > 0);\n\n  /* Zero padding */\n  if (flags && C_SNPRINTF_FLAG_ZERO) {\n    while (k < field_width && k < (int) sizeof(tmp) - 1) {\n      tmp[k++] = '0';\n    }\n  }\n\n  /* And sign */\n  if (neg) {\n    tmp[k++] = '-';\n  }\n\n  /* Now output */\n  while (--k >= 0) {\n    C_SNPRINTF_APPEND_CHAR(tmp[k]);\n  }\n\n  return i;\n}\n\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  int ch, i = 0, len_mod, flags, precision, field_width;\n\n  while ((ch = *fmt++) != '\\0') {\n    if (ch != '%') {\n      C_SNPRINTF_APPEND_CHAR(ch);\n    } else {\n      /*\n       * Conversion specification:\n       *   zero or more flags (one of: # 0 - <space> + ')\n       *   an optional minimum  field  width (digits)\n       *   an  optional precision (. followed by digits, or *)\n       *   an optional length modifier (one of: hh h l ll L q j z t)\n       *   conversion specifier (one of: d i o u x X e E f F g G a A c s p n)\n       */\n      flags = field_width = precision = len_mod = 0;\n\n      /* Flags. only zero-pad flag is supported. */\n      if (*fmt == '0') {\n        flags |= C_SNPRINTF_FLAG_ZERO;\n      }\n\n      /* Field width */\n      while (*fmt >= '0' && *fmt <= '9') {\n        field_width *= 10;\n        field_width += *fmt++ - '0';\n      }\n      /* Dynamic field width */\n      if (*fmt == '*') {\n        field_width = va_arg(ap, int);\n        fmt++;\n      }\n\n      /* Precision */\n      if (*fmt == '.') {\n        fmt++;\n        if (*fmt == '*') {\n          precision = va_arg(ap, int);\n          fmt++;\n        } else {\n          while (*fmt >= '0' && *fmt <= '9') {\n            precision *= 10;\n            precision += *fmt++ - '0';\n          }\n        }\n      }\n\n      /* Length modifier */\n      switch (*fmt) {\n        case 'h':\n        case 'l':\n        case 'L':\n        case 'I':\n        case 'q':\n        case 'j':\n        case 'z':\n        case 't':\n          len_mod = *fmt++;\n          if (*fmt == 'h') {\n            len_mod = 'H';\n            fmt++;\n          }\n          if (*fmt == 'l') {\n            len_mod = 'q';\n            fmt++;\n          }\n          break;\n      }\n\n      ch = *fmt++;\n      if (ch == 's') {\n        const char *s = va_arg(ap, const char *); /* Always fetch parameter */\n        int j;\n        int pad = field_width - (precision >= 0 ? c_strnlen(s, precision) : 0);\n        for (j = 0; j < pad; j++) {\n          C_SNPRINTF_APPEND_CHAR(' ');\n        }\n\n        /* `s` may be NULL in case of %.*s */\n        if (s != NULL) {\n          /* Ignore negative and 0 precisions */\n          for (j = 0; (precision <= 0 || j < precision) && s[j] != '\\0'; j++) {\n            C_SNPRINTF_APPEND_CHAR(s[j]);\n          }\n        }\n      } else if (ch == 'c') {\n        ch = va_arg(ap, int); /* Always fetch parameter */\n        C_SNPRINTF_APPEND_CHAR(ch);\n      } else if (ch == 'd' && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int), 10, flags,\n                    field_width);\n      } else if (ch == 'd' && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, long), 10, flags,\n                    field_width);\n#ifdef SSIZE_MAX\n      } else if (ch == 'd' && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, ssize_t), 10, flags,\n                    field_width);\n#endif\n      } else if (ch == 'd' && len_mod == 'q') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int64_t), 10, flags,\n                    field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned long),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, size_t),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if (ch == 'p') {\n        unsigned long num = (unsigned long) (uintptr_t) va_arg(ap, void *);\n        C_SNPRINTF_APPEND_CHAR('0');\n        C_SNPRINTF_APPEND_CHAR('x');\n        i += c_itoa(buf + i, buf_size - i, num, 16, flags, 0);\n      } else {\n#ifndef NO_LIBC\n        /*\n         * TODO(lsm): abort is not nice in a library, remove it\n         * Also, ESP8266 SDK doesn't have it\n         */\n        abort();\n#endif\n      }\n    }\n  }\n\n  /* Zero-terminate the result */\n  if (buf_size > 0) {\n    buf[i < (int) buf_size ? i : (int) buf_size - 1] = '\\0';\n  }\n\n  return i;\n}\n#endif\n\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) WEAK;\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, fmt);\n  result = c_vsnprintf(buf, buf_size, fmt, ap);\n  va_end(ap);\n  return result;\n}\n\n#ifdef _WIN32\nint to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n\n  /* Trim trailing slashes. Leave backslash for paths like \"X:\\\" */\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n\n  /*\n   * Convert back to Unicode. If doubly-converted string does not match the\n   * original, something is fishy, reject.\n   */\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n\n  return ret;\n}\n#endif /* _WIN32 */\n\n/* The simplest O(mn) algorithm. Better implementation are GPLed */\nconst char *c_strnstr(const char *s, const char *find, size_t slen) WEAK;\nconst char *c_strnstr(const char *s, const char *find, size_t slen) {\n  size_t find_length = strlen(find);\n  size_t i;\n\n  for (i = 0; i < slen; i++) {\n    if (i + find_length > slen) {\n      return NULL;\n    }\n\n    if (strncmp(&s[i], find, find_length) == 0) {\n      return &s[i];\n    }\n  }\n\n  return NULL;\n}\n\n#if CS_ENABLE_STRDUP\nchar *strdup(const char *src) WEAK;\nchar *strdup(const char *src) {\n  size_t len = strlen(src) + 1;\n  char *ret = MG_MALLOC(len);\n  if (ret != NULL) {\n    strcpy(ret, src);\n  }\n  return ret;\n}\n#endif\n\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) WEAK;\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) {\n  static const char *hex = \"0123456789abcdef\";\n\n  for (; len--; p++) {\n    *to++ = hex[p[0] >> 4];\n    *to++ = hex[p[0] & 0x0f];\n  }\n  *to = '\\0';\n}\n\nstatic int fourbit(int ch) {\n  if (ch >= '0' && ch <= '9') {\n    return ch - '0';\n  } else if (ch >= 'a' && ch <= 'f') {\n    return ch - 'a' + 10;\n  } else if (ch >= 'A' && ch <= 'F') {\n    return ch - 'A' + 10;\n  }\n  return 0;\n}\n\nvoid cs_from_hex(char *to, const char *p, size_t len) WEAK;\nvoid cs_from_hex(char *to, const char *p, size_t len) {\n  size_t i;\n\n  for (i = 0; i < len; i += 2) {\n    *to++ = (fourbit(p[i]) << 4) + fourbit(p[i + 1]);\n  }\n  *to = '\\0';\n}\n\n#if CS_ENABLE_TO64\nint64_t cs_to64(const char *s) WEAK;\nint64_t cs_to64(const char *s) {\n  int64_t result = 0;\n  int64_t neg = 1;\n  while (*s && isspace((unsigned char) *s)) s++;\n  if (*s == '-') {\n    neg = -1;\n    s++;\n  }\n  while (isdigit((unsigned char) *s)) {\n    result *= 10;\n    result += (*s - '0');\n    s++;\n  }\n  return result * neg;\n}\n#endif\n\nstatic int str_util_lowercase(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n\n  if (len > 0) do {\n      diff = str_util_lowercase(s1++) - str_util_lowercase(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) WEAK;\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) WEAK;\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) {\n  int ret;\n  va_list ap;\n  va_start(ap, fmt);\n  ret = mg_avprintf(buf, size, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) WEAK;\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  va_copy(ap_copy, ap);\n  len = vsnprintf(*buf, size, fmt, ap_copy);\n  va_end(ap_copy);\n\n  if (len < 0) {\n    /* eCos and Windows are not standard-compliant and return -1 when\n     * the buffer is too small. Keep allocating larger buffers until we\n     * succeed or out of memory. */\n    *buf = NULL; /* LCOV_EXCL_START */\n    while (len < 0) {\n      MG_FREE(*buf);\n      if (size == 0) {\n        size = 5;\n      }\n      size *= 2;\n      if ((*buf = (char *) MG_MALLOC(size)) == NULL) {\n        len = -1;\n        break;\n      }\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, size - 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n\n    /*\n     * Microsoft version of vsnprintf() is not always null-terminated, so put\n     * the terminator manually\n     */\n    (*buf)[len] = 0;\n    /* LCOV_EXCL_STOP */\n  } else if (len >= (int) size) {\n    /* Standard-compliant code path. Allocate a buffer that is large enough. */\n    if ((*buf = (char *) MG_MALLOC(len + 1)) == NULL) {\n      len = -1; /* LCOV_EXCL_LINE */\n    } else {    /* LCOV_EXCL_LINE */\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, len + 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n  }\n\n  return len;\n}\n\nconst char *mg_next_comma_list_entry(const char *, struct mg_str *,\n                                     struct mg_str *) WEAK;\nconst char *mg_next_comma_list_entry(const char *list, struct mg_str *val,\n                                     struct mg_str *eq_val) {\n  struct mg_str ret = mg_next_comma_list_entry_n(mg_mk_str(list), val, eq_val);\n  return ret.p;\n}\n\nstruct mg_str mg_next_comma_list_entry_n(struct mg_str list, struct mg_str *val,\n                                         struct mg_str *eq_val) WEAK;\nstruct mg_str mg_next_comma_list_entry_n(struct mg_str list, struct mg_str *val,\n                                         struct mg_str *eq_val) {\n  if (list.len == 0) {\n    /* End of the list */\n    list = mg_mk_str(NULL);\n  } else {\n    const char *chr = NULL;\n    *val = list;\n\n    if ((chr = mg_strchr(*val, ',')) != NULL) {\n      /* Comma found. Store length and shift the list ptr */\n      val->len = chr - val->p;\n      chr++;\n      list.len -= (chr - list.p);\n      list.p = chr;\n    } else {\n      /* This value is the last one */\n      list = mg_mk_str_n(list.p + list.len, 0);\n    }\n\n    if (eq_val != NULL) {\n      /* Value has form \"x=y\", adjust pointers and lengths */\n      /* so that val points to \"x\", and eq_val points to \"y\". */\n      eq_val->len = 0;\n      eq_val->p = (const char *) memchr(val->p, '=', val->len);\n      if (eq_val->p != NULL) {\n        eq_val->p++; /* Skip over '=' character */\n        eq_val->len = val->p + val->len - eq_val->p;\n        val->len = (eq_val->p - val->p) - 1;\n      }\n    }\n  }\n\n  return list;\n}\n\nsize_t mg_match_prefix_n(const struct mg_str, const struct mg_str) WEAK;\nsize_t mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str) {\n  const char *or_str;\n  size_t res = 0, len = 0, i = 0, j = 0;\n\n  if ((or_str = (const char *) memchr(pattern.p, '|', pattern.len)) != NULL ||\n      (or_str = (const char *) memchr(pattern.p, ',', pattern.len)) != NULL) {\n    struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};\n    res = mg_match_prefix_n(pstr, str);\n    if (res > 0) return res;\n    pstr.p = or_str + 1;\n    pstr.len = (pattern.p + pattern.len) - (or_str + 1);\n    return mg_match_prefix_n(pstr, str);\n  }\n\n  for (; i < pattern.len && j < str.len; i++, j++) {\n    if (pattern.p[i] == '?') {\n      continue;\n    } else if (pattern.p[i] == '*') {\n      i++;\n      if (i < pattern.len && pattern.p[i] == '*') {\n        i++;\n        len = str.len - j;\n      } else {\n        len = 0;\n        while (j + len < str.len && str.p[j + len] != '/') len++;\n      }\n      if (i == pattern.len || (pattern.p[i] == '$' && i == pattern.len - 1))\n        return j + len;\n      do {\n        const struct mg_str pstr = {pattern.p + i, pattern.len - i};\n        const struct mg_str sstr = {str.p + j + len, str.len - j - len};\n        res = mg_match_prefix_n(pstr, sstr);\n      } while (res == 0 && len != 0 && len-- > 0);\n      return res == 0 ? 0 : j + res + len;\n    } else if (str_util_lowercase(&pattern.p[i]) !=\n               str_util_lowercase(&str.p[j])) {\n      break;\n    }\n  }\n  if (i < pattern.len && pattern.p[i] == '$') {\n    return j == str.len ? str.len : 0;\n  }\n  return i == pattern.len ? j : 0;\n}\n\nsize_t mg_match_prefix(const char *, int, const char *) WEAK;\nsize_t mg_match_prefix(const char *pattern, int pattern_len, const char *str) {\n  const struct mg_str pstr = {pattern, (size_t) pattern_len};\n  struct mg_str s = {str, 0};\n  if (str != NULL) s.len = strlen(str);\n  return mg_match_prefix_n(pstr, s);\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/frozen/frozen.c\"\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005+ */\n\n/* Amalgamated: #include \"frozen.h\" */\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if !defined(WEAK)\n#if (defined(__GNUC__) || defined(__TI_COMPILER_VERSION__)) && !defined(_WIN32)\n#define WEAK __attribute__((weak))\n#else\n#define WEAK\n#endif\n#endif\n\n#ifdef _WIN32\n#undef snprintf\n#undef vsnprintf\n#define snprintf cs_win_snprintf\n#define vsnprintf cs_win_vsnprintf\nint cs_win_snprintf(char *str, size_t size, const char *format, ...);\nint cs_win_vsnprintf(char *str, size_t size, const char *format, va_list ap);\n#if _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef _int64 int64_t;\ntypedef unsigned _int64 uint64_t;\n#endif\n#define PRId64 \"I64d\"\n#define PRIu64 \"I64u\"\n#else /* _WIN32 */\n/* <inttypes.h> wants this for C++ */\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n#include <inttypes.h>\n#endif /* _WIN32 */\n\n#ifndef INT64_FMT\n#define INT64_FMT PRId64\n#endif\n#ifndef UINT64_FMT\n#define UINT64_FMT PRIu64\n#endif\n\n#ifndef va_copy\n#define va_copy(x, y) x = y\n#endif\n\n#ifndef JSON_ENABLE_ARRAY\n#define JSON_ENABLE_ARRAY 1\n#endif\n\nstruct frozen {\n  const char *end;\n  const char *cur;\n\n  const char *cur_name;\n  size_t cur_name_len;\n\n  /* For callback API */\n  char path[JSON_MAX_PATH_LEN];\n  size_t path_len;\n  void *callback_data;\n  json_walk_callback_t callback;\n};\n\nstruct fstate {\n  const char *ptr;\n  size_t path_len;\n};\n\n#define SET_STATE(fr, ptr, str, len)              \\\n  struct fstate fstate = {(ptr), (fr)->path_len}; \\\n  json_append_to_path((fr), (str), (len));\n\n#define CALL_BACK(fr, tok, value, len)                                        \\\n  do {                                                                        \\\n    if ((fr)->callback &&                                                     \\\n        ((fr)->path_len == 0 || (fr)->path[(fr)->path_len - 1] != '.')) {     \\\n      struct json_token t = {(value), (int) (len), (tok)};                    \\\n                                                                              \\\n      /* Call the callback with the given value and current name */           \\\n      (fr)->callback((fr)->callback_data, (fr)->cur_name, (fr)->cur_name_len, \\\n                     (fr)->path, &t);                                         \\\n                                                                              \\\n      /* Reset the name */                                                    \\\n      (fr)->cur_name = NULL;                                                  \\\n      (fr)->cur_name_len = 0;                                                 \\\n    }                                                                         \\\n  } while (0)\n\nstatic int json_append_to_path(struct frozen *f, const char *str, int size) {\n  int n = f->path_len;\n  int left = sizeof(f->path) - n - 1;\n  if (size > left) size = left;\n  memcpy(f->path + n, str, size);\n  f->path[n + size] = '\\0';\n  f->path_len += size;\n  return n;\n}\n\nstatic void json_truncate_path(struct frozen *f, size_t len) {\n  f->path_len = len;\n  f->path[len] = '\\0';\n}\n\nstatic int json_parse_object(struct frozen *f);\nstatic int json_parse_value(struct frozen *f);\n\n#define EXPECT(cond, err_code)      \\\n  do {                              \\\n    if (!(cond)) return (err_code); \\\n  } while (0)\n\n#define TRY(expr)          \\\n  do {                     \\\n    int _n = expr;         \\\n    if (_n < 0) return _n; \\\n  } while (0)\n\n#define END_OF_STRING (-1)\n\nstatic int json_left(const struct frozen *f) {\n  return f->end - f->cur;\n}\n\nstatic int json_isspace(int ch) {\n  return ch == ' ' || ch == '\\t' || ch == '\\r' || ch == '\\n';\n}\n\nstatic void json_skip_whitespaces(struct frozen *f) {\n  while (f->cur < f->end && json_isspace(*f->cur)) f->cur++;\n}\n\nstatic int json_cur(struct frozen *f) {\n  json_skip_whitespaces(f);\n  return f->cur >= f->end ? END_OF_STRING : *(unsigned char *) f->cur;\n}\n\nstatic int json_test_and_skip(struct frozen *f, int expected) {\n  int ch = json_cur(f);\n  if (ch == expected) {\n    f->cur++;\n    return 0;\n  }\n  return ch == END_OF_STRING ? JSON_STRING_INCOMPLETE : JSON_STRING_INVALID;\n}\n\nstatic int json_isalpha(int ch) {\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}\n\nstatic int json_isdigit(int ch) {\n  return ch >= '0' && ch <= '9';\n}\n\nstatic int json_isxdigit(int ch) {\n  return json_isdigit(ch) || (ch >= 'a' && ch <= 'f') ||\n         (ch >= 'A' && ch <= 'F');\n}\n\nstatic int json_get_escape_len(const char *s, int len) {\n  switch (*s) {\n    case 'u':\n      return len < 6 ? JSON_STRING_INCOMPLETE\n                     : json_isxdigit(s[1]) && json_isxdigit(s[2]) &&\n                               json_isxdigit(s[3]) && json_isxdigit(s[4])\n                           ? 5\n                           : JSON_STRING_INVALID;\n    case '\"':\n    case '\\\\':\n    case '/':\n    case 'b':\n    case 'f':\n    case 'n':\n    case 'r':\n    case 't':\n      return len < 2 ? JSON_STRING_INCOMPLETE : 1;\n    default:\n      return JSON_STRING_INVALID;\n  }\n}\n\n/* identifier = letter { letter | digit | '_' } */\nstatic int json_parse_identifier(struct frozen *f) {\n  EXPECT(json_isalpha(json_cur(f)), JSON_STRING_INVALID);\n  {\n    SET_STATE(f, f->cur, \"\", 0);\n    while (f->cur < f->end &&\n           (*f->cur == '_' || json_isalpha(*f->cur) || json_isdigit(*f->cur))) {\n      f->cur++;\n    }\n    json_truncate_path(f, fstate.path_len);\n    CALL_BACK(f, JSON_TYPE_STRING, fstate.ptr, f->cur - fstate.ptr);\n  }\n  return 0;\n}\n\nstatic int json_get_utf8_char_len(unsigned char ch) {\n  if ((ch & 0x80) == 0) return 1;\n  switch (ch & 0xf0) {\n    case 0xf0:\n      return 4;\n    case 0xe0:\n      return 3;\n    default:\n      return 2;\n  }\n}\n\n/* string = '\"' { quoted_printable_chars } '\"' */\nstatic int json_parse_string(struct frozen *f) {\n  int n, ch = 0, len = 0;\n  TRY(json_test_and_skip(f, '\"'));\n  {\n    SET_STATE(f, f->cur, \"\", 0);\n    for (; f->cur < f->end; f->cur += len) {\n      ch = *(unsigned char *) f->cur;\n      len = json_get_utf8_char_len((unsigned char) ch);\n      EXPECT(ch >= 32 && len > 0, JSON_STRING_INVALID); /* No control chars */\n      EXPECT(len <= json_left(f), JSON_STRING_INCOMPLETE);\n      if (ch == '\\\\') {\n        EXPECT((n = json_get_escape_len(f->cur + 1, json_left(f))) > 0, n);\n        len += n;\n      } else if (ch == '\"') {\n        json_truncate_path(f, fstate.path_len);\n        CALL_BACK(f, JSON_TYPE_STRING, fstate.ptr, f->cur - fstate.ptr);\n        f->cur++;\n        break;\n      };\n    }\n  }\n  return ch == '\"' ? 0 : JSON_STRING_INCOMPLETE;\n}\n\n/* number = [ '-' ] digit+ [ '.' digit+ ] [ ['e'|'E'] ['+'|'-'] digit+ ] */\nstatic int json_parse_number(struct frozen *f) {\n  int ch = json_cur(f);\n  SET_STATE(f, f->cur, \"\", 0);\n  if (ch == '-') f->cur++;\n  EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n  if (f->cur + 1 < f->end && f->cur[0] == '0' && f->cur[1] == 'x') {\n    f->cur += 2;\n    EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n    EXPECT(json_isxdigit(f->cur[0]), JSON_STRING_INVALID);\n    while (f->cur < f->end && json_isxdigit(f->cur[0])) f->cur++;\n  } else {\n    EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n    while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    if (f->cur < f->end && f->cur[0] == '.') {\n      f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n      while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    }\n    if (f->cur < f->end && (f->cur[0] == 'e' || f->cur[0] == 'E')) {\n      f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      if ((f->cur[0] == '+' || f->cur[0] == '-')) f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n      while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    }\n  }\n  json_truncate_path(f, fstate.path_len);\n  CALL_BACK(f, JSON_TYPE_NUMBER, fstate.ptr, f->cur - fstate.ptr);\n  return 0;\n}\n\n#if JSON_ENABLE_ARRAY\n/* array = '[' [ value { ',' value } ] ']' */\nstatic int json_parse_array(struct frozen *f) {\n  int i = 0, current_path_len;\n  char buf[20];\n  CALL_BACK(f, JSON_TYPE_ARRAY_START, NULL, 0);\n  TRY(json_test_and_skip(f, '['));\n  {\n    {\n      SET_STATE(f, f->cur - 1, \"\", 0);\n      while (json_cur(f) != ']') {\n        snprintf(buf, sizeof(buf), \"[%d]\", i);\n        i++;\n        current_path_len = json_append_to_path(f, buf, strlen(buf));\n        f->cur_name =\n            f->path + strlen(f->path) - strlen(buf) + 1 /*opening brace*/;\n        f->cur_name_len = strlen(buf) - 2 /*braces*/;\n        TRY(json_parse_value(f));\n        json_truncate_path(f, current_path_len);\n        if (json_cur(f) == ',') f->cur++;\n      }\n      TRY(json_test_and_skip(f, ']'));\n      json_truncate_path(f, fstate.path_len);\n      CALL_BACK(f, JSON_TYPE_ARRAY_END, fstate.ptr, f->cur - fstate.ptr);\n    }\n  }\n  return 0;\n}\n#endif /* JSON_ENABLE_ARRAY */\n\nstatic int json_expect(struct frozen *f, const char *s, int len,\n                       enum json_token_type tok_type) {\n  int i, n = json_left(f);\n  SET_STATE(f, f->cur, \"\", 0);\n  for (i = 0; i < len; i++) {\n    if (i >= n) return JSON_STRING_INCOMPLETE;\n    if (f->cur[i] != s[i]) return JSON_STRING_INVALID;\n  }\n  f->cur += len;\n  json_truncate_path(f, fstate.path_len);\n\n  CALL_BACK(f, tok_type, fstate.ptr, f->cur - fstate.ptr);\n\n  return 0;\n}\n\n/* value = 'null' | 'true' | 'false' | number | string | array | object */\nstatic int json_parse_value(struct frozen *f) {\n  int ch = json_cur(f);\n\n  switch (ch) {\n    case '\"':\n      TRY(json_parse_string(f));\n      break;\n    case '{':\n      TRY(json_parse_object(f));\n      break;\n#if JSON_ENABLE_ARRAY\n    case '[':\n      TRY(json_parse_array(f));\n      break;\n#endif\n    case 'n':\n      TRY(json_expect(f, \"null\", 4, JSON_TYPE_NULL));\n      break;\n    case 't':\n      TRY(json_expect(f, \"true\", 4, JSON_TYPE_TRUE));\n      break;\n    case 'f':\n      TRY(json_expect(f, \"false\", 5, JSON_TYPE_FALSE));\n      break;\n    case '-':\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      TRY(json_parse_number(f));\n      break;\n    default:\n      return ch == END_OF_STRING ? JSON_STRING_INCOMPLETE : JSON_STRING_INVALID;\n  }\n\n  return 0;\n}\n\n/* key = identifier | string */\nstatic int json_parse_key(struct frozen *f) {\n  int ch = json_cur(f);\n  if (json_isalpha(ch)) {\n    TRY(json_parse_identifier(f));\n  } else if (ch == '\"') {\n    TRY(json_parse_string(f));\n  } else {\n    return ch == END_OF_STRING ? JSON_STRING_INCOMPLETE : JSON_STRING_INVALID;\n  }\n  return 0;\n}\n\n/* pair = key ':' value */\nstatic int json_parse_pair(struct frozen *f) {\n  int current_path_len;\n  const char *tok;\n  json_skip_whitespaces(f);\n  tok = f->cur;\n  TRY(json_parse_key(f));\n  {\n    f->cur_name = *tok == '\"' ? tok + 1 : tok;\n    f->cur_name_len = *tok == '\"' ? f->cur - tok - 2 : f->cur - tok;\n    current_path_len = json_append_to_path(f, f->cur_name, f->cur_name_len);\n  }\n  TRY(json_test_and_skip(f, ':'));\n  TRY(json_parse_value(f));\n  json_truncate_path(f, current_path_len);\n  return 0;\n}\n\n/* object = '{' pair { ',' pair } '}' */\nstatic int json_parse_object(struct frozen *f) {\n  CALL_BACK(f, JSON_TYPE_OBJECT_START, NULL, 0);\n  TRY(json_test_and_skip(f, '{'));\n  {\n    SET_STATE(f, f->cur - 1, \".\", 1);\n    while (json_cur(f) != '}') {\n      TRY(json_parse_pair(f));\n      if (json_cur(f) == ',') f->cur++;\n    }\n    TRY(json_test_and_skip(f, '}'));\n    json_truncate_path(f, fstate.path_len);\n    CALL_BACK(f, JSON_TYPE_OBJECT_END, fstate.ptr, f->cur - fstate.ptr);\n  }\n  return 0;\n}\n\nstatic int json_doit(struct frozen *f) {\n  if (f->cur == 0 || f->end < f->cur) return JSON_STRING_INVALID;\n  if (f->end == f->cur) return JSON_STRING_INCOMPLETE;\n  return json_parse_value(f);\n}\n\nint json_escape(struct json_out *out, const char *p, size_t len) WEAK;\nint json_escape(struct json_out *out, const char *p, size_t len) {\n  size_t i, cl, n = 0;\n  const char *hex_digits = \"0123456789abcdef\";\n  const char *specials = \"btnvfr\";\n\n  for (i = 0; i < len; i++) {\n    unsigned char ch = ((unsigned char *) p)[i];\n    if (ch == '\"' || ch == '\\\\') {\n      n += out->printer(out, \"\\\\\", 1);\n      n += out->printer(out, p + i, 1);\n    } else if (ch >= '\\b' && ch <= '\\r') {\n      n += out->printer(out, \"\\\\\", 1);\n      n += out->printer(out, &specials[ch - '\\b'], 1);\n    } else if (isprint(ch)) {\n      n += out->printer(out, p + i, 1);\n    } else if ((cl = json_get_utf8_char_len(ch)) == 1) {\n      n += out->printer(out, \"\\\\u00\", 4);\n      n += out->printer(out, &hex_digits[(ch >> 4) % 0xf], 1);\n      n += out->printer(out, &hex_digits[ch % 0xf], 1);\n    } else {\n      n += out->printer(out, p + i, cl);\n      i += cl - 1;\n    }\n  }\n\n  return n;\n}\n\nint json_printer_buf(struct json_out *out, const char *buf, size_t len) WEAK;\nint json_printer_buf(struct json_out *out, const char *buf, size_t len) {\n  size_t avail = out->u.buf.size - out->u.buf.len;\n  size_t n = len < avail ? len : avail;\n  memcpy(out->u.buf.buf + out->u.buf.len, buf, n);\n  out->u.buf.len += n;\n  if (out->u.buf.size > 0) {\n    size_t idx = out->u.buf.len;\n    if (idx >= out->u.buf.size) idx = out->u.buf.size - 1;\n    out->u.buf.buf[idx] = '\\0';\n  }\n  return len;\n}\n\nint json_printer_file(struct json_out *out, const char *buf, size_t len) WEAK;\nint json_printer_file(struct json_out *out, const char *buf, size_t len) {\n  return fwrite(buf, 1, len, out->u.fp);\n}\n\n#if JSON_ENABLE_BASE64\nstatic int b64idx(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int b64rev(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else {\n    return 64;\n  }\n}\n\nstatic int b64enc(struct json_out *out, const unsigned char *p, int n) {\n  char buf[4];\n  int i, len = 0;\n  for (i = 0; i < n; i += 3) {\n    int a = p[i], b = i + 1 < n ? p[i + 1] : 0, c = i + 2 < n ? p[i + 2] : 0;\n    buf[0] = b64idx(a >> 2);\n    buf[1] = b64idx((a & 3) << 4 | (b >> 4));\n    buf[2] = b64idx((b & 15) << 2 | (c >> 6));\n    buf[3] = b64idx(c & 63);\n    if (i + 1 >= n) buf[2] = '=';\n    if (i + 2 >= n) buf[3] = '=';\n    len += out->printer(out, buf, sizeof(buf));\n  }\n  return len;\n}\n\nstatic int b64dec(const char *src, int n, char *dst) {\n  const char *end = src + n;\n  int len = 0;\n  while (src + 3 < end) {\n    int a = b64rev(src[0]), b = b64rev(src[1]), c = b64rev(src[2]),\n        d = b64rev(src[3]);\n    dst[len++] = (a << 2) | (b >> 4);\n    if (src[2] != '=') {\n      dst[len++] = (b << 4) | (c >> 2);\n      if (src[3] != '=') {\n        dst[len++] = (c << 6) | d;\n      }\n    }\n    src += 4;\n  }\n  return len;\n}\n#endif /* JSON_ENABLE_BASE64 */\n\nstatic unsigned char hexdec(const char *s) {\n#define HEXTOI(x) (x >= '0' && x <= '9' ? x - '0' : x - 'W')\n  int a = tolower(*(const unsigned char *) s);\n  int b = tolower(*(const unsigned char *) (s + 1));\n  return (HEXTOI(a) << 4) | HEXTOI(b);\n}\n\nint json_vprintf(struct json_out *out, const char *fmt, va_list xap) WEAK;\nint json_vprintf(struct json_out *out, const char *fmt, va_list xap) {\n  int len = 0;\n  const char *quote = \"\\\"\", *null = \"null\";\n  va_list ap;\n  va_copy(ap, xap);\n\n  while (*fmt != '\\0') {\n    if (strchr(\":, \\r\\n\\t[]{}\\\"\", *fmt) != NULL) {\n      len += out->printer(out, fmt, 1);\n      fmt++;\n    } else if (fmt[0] == '%') {\n      char buf[21];\n      size_t skip = 2;\n\n      if (fmt[1] == 'l' && fmt[2] == 'l' && (fmt[3] == 'd' || fmt[3] == 'u')) {\n        int64_t val = va_arg(ap, int64_t);\n        const char *fmt2 = fmt[3] == 'u' ? \"%\" UINT64_FMT : \"%\" INT64_FMT;\n        snprintf(buf, sizeof(buf), fmt2, val);\n        len += out->printer(out, buf, strlen(buf));\n        skip += 2;\n      } else if (fmt[1] == 'z' && fmt[2] == 'u') {\n        size_t val = va_arg(ap, size_t);\n        snprintf(buf, sizeof(buf), \"%lu\", (unsigned long) val);\n        len += out->printer(out, buf, strlen(buf));\n        skip += 1;\n      } else if (fmt[1] == 'M') {\n        json_printf_callback_t f = va_arg(ap, json_printf_callback_t);\n        len += f(out, &ap);\n      } else if (fmt[1] == 'B') {\n        int val = va_arg(ap, int);\n        const char *str = val ? \"true\" : \"false\";\n        len += out->printer(out, str, strlen(str));\n      } else if (fmt[1] == 'H') {\n#if JSON_ENABLE_HEX\n        const char *hex = \"0123456789abcdef\";\n        int i, n = va_arg(ap, int);\n        const unsigned char *p = va_arg(ap, const unsigned char *);\n        len += out->printer(out, quote, 1);\n        for (i = 0; i < n; i++) {\n          len += out->printer(out, &hex[(p[i] >> 4) & 0xf], 1);\n          len += out->printer(out, &hex[p[i] & 0xf], 1);\n        }\n        len += out->printer(out, quote, 1);\n#endif /* JSON_ENABLE_HEX */\n      } else if (fmt[1] == 'V') {\n#if JSON_ENABLE_BASE64\n        const unsigned char *p = va_arg(ap, const unsigned char *);\n        int n = va_arg(ap, int);\n        len += out->printer(out, quote, 1);\n        len += b64enc(out, p, n);\n        len += out->printer(out, quote, 1);\n#endif /* JSON_ENABLE_BASE64 */\n      } else if (fmt[1] == 'Q' ||\n                 (fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 'Q')) {\n        size_t l = 0;\n        const char *p;\n\n        if (fmt[1] == '.') {\n          l = (size_t) va_arg(ap, int);\n          skip += 2;\n        }\n        p = va_arg(ap, char *);\n\n        if (p == NULL) {\n          len += out->printer(out, null, 4);\n        } else {\n          if (fmt[1] == 'Q') {\n            l = strlen(p);\n          }\n          len += out->printer(out, quote, 1);\n          len += json_escape(out, p, l);\n          len += out->printer(out, quote, 1);\n        }\n      } else {\n        /*\n         * we delegate printing to the system printf.\n         * The goal here is to delegate all modifiers parsing to the system\n         * printf, as you can see below we still have to parse the format\n         * types.\n         *\n         * Currently, %s with strings longer than 20 chars will require\n         * double-buffering (an auxiliary buffer will be allocated from heap).\n         * TODO(dfrank): reimplement %s and %.*s in order to avoid that.\n         */\n\n        const char *end_of_format_specifier = \"sdfFeEgGlhuIcx.*-0123456789\";\n        int n = strspn(fmt + 1, end_of_format_specifier);\n        char *pbuf = buf;\n        int need_len, size = sizeof(buf);\n        char fmt2[20];\n        va_list ap_copy;\n        strncpy(fmt2, fmt,\n                n + 1 > (int) sizeof(fmt2) ? sizeof(fmt2) : (size_t) n + 1);\n        fmt2[n + 1] = '\\0';\n\n        va_copy(ap_copy, ap);\n        need_len = vsnprintf(pbuf, size, fmt2, ap_copy);\n        va_end(ap_copy);\n\n        if (need_len < 0) {\n          /*\n           * Windows & eCos vsnprintf implementation return -1 on overflow\n           * instead of needed size.\n           */\n          pbuf = NULL;\n          while (need_len < 0) {\n            free(pbuf);\n            size *= 2;\n            if ((pbuf = (char *) malloc(size)) == NULL) break;\n            va_copy(ap_copy, ap);\n            need_len = vsnprintf(pbuf, size, fmt2, ap_copy);\n            va_end(ap_copy);\n          }\n        } else if (need_len >= (int) sizeof(buf)) {\n          /*\n           * resulting string doesn't fit into a stack-allocated buffer `buf`,\n           * so we need to allocate a new buffer from heap and use it\n           */\n          if ((pbuf = (char *) malloc(need_len + 1)) != NULL) {\n            va_copy(ap_copy, ap);\n            vsnprintf(pbuf, need_len + 1, fmt2, ap_copy);\n            va_end(ap_copy);\n          }\n        }\n        if (pbuf == NULL) {\n          buf[0] = '\\0';\n          pbuf = buf;\n        }\n\n        /*\n         * however we need to parse the type ourselves in order to advance\n         * the va_list by the correct amount; there is no portable way to\n         * inherit the advancement made by vprintf.\n         * 32-bit (linux or windows) passes va_list by value.\n         */\n        if ((n + 1 == strlen(\"%\" PRId64) && strcmp(fmt2, \"%\" PRId64) == 0) ||\n            (n + 1 == strlen(\"%\" PRIu64) && strcmp(fmt2, \"%\" PRIu64) == 0)) {\n          (void) va_arg(ap, int64_t);\n        } else if (strcmp(fmt2, \"%.*s\") == 0) {\n          (void) va_arg(ap, int);\n          (void) va_arg(ap, char *);\n        } else {\n          switch (fmt2[n]) {\n            case 'u':\n            case 'd':\n              (void) va_arg(ap, int);\n              break;\n            case 'g':\n            case 'f':\n              (void) va_arg(ap, double);\n              break;\n            case 'p':\n              (void) va_arg(ap, void *);\n              break;\n            default:\n              /* many types are promoted to int */\n              (void) va_arg(ap, int);\n          }\n        }\n\n        len += out->printer(out, pbuf, strlen(pbuf));\n        skip = n + 1;\n\n        /* If buffer was allocated from heap, free it */\n        if (pbuf != buf) {\n          free(pbuf);\n          pbuf = NULL;\n        }\n      }\n      fmt += skip;\n    } else if (*fmt == '_' || json_isalpha(*fmt)) {\n      len += out->printer(out, quote, 1);\n      while (*fmt == '_' || json_isalpha(*fmt) || json_isdigit(*fmt)) {\n        len += out->printer(out, fmt, 1);\n        fmt++;\n      }\n      len += out->printer(out, quote, 1);\n    } else {\n      len += out->printer(out, fmt, 1);\n      fmt++;\n    }\n  }\n  va_end(ap);\n\n  return len;\n}\n\nint json_printf(struct json_out *out, const char *fmt, ...) WEAK;\nint json_printf(struct json_out *out, const char *fmt, ...) {\n  int n;\n  va_list ap;\n  va_start(ap, fmt);\n  n = json_vprintf(out, fmt, ap);\n  va_end(ap);\n  return n;\n}\n\nint json_printf_array(struct json_out *out, va_list *ap) WEAK;\nint json_printf_array(struct json_out *out, va_list *ap) {\n  int len = 0;\n  char *arr = va_arg(*ap, char *);\n  size_t i, arr_size = va_arg(*ap, size_t);\n  size_t elem_size = va_arg(*ap, size_t);\n  const char *fmt = va_arg(*ap, char *);\n  len += json_printf(out, \"[\", 1);\n  for (i = 0; arr != NULL && i < arr_size / elem_size; i++) {\n    union {\n      int64_t i;\n      double d;\n    } val;\n    memcpy(&val, arr + i * elem_size,\n           elem_size > sizeof(val) ? sizeof(val) : elem_size);\n    if (i > 0) len += json_printf(out, \", \");\n    if (strpbrk(fmt, \"efg\") != NULL) {\n      len += json_printf(out, fmt, val.d);\n    } else {\n      len += json_printf(out, fmt, val.i);\n    }\n  }\n  len += json_printf(out, \"]\", 1);\n  return len;\n}\n\n#ifdef _WIN32\nint cs_win_vsnprintf(char *str, size_t size, const char *format,\n                     va_list ap) WEAK;\nint cs_win_vsnprintf(char *str, size_t size, const char *format, va_list ap) {\n  int res = _vsnprintf(str, size, format, ap);\n  va_end(ap);\n  if (res >= size) {\n    str[size - 1] = '\\0';\n  }\n  return res;\n}\n\nint cs_win_snprintf(char *str, size_t size, const char *format, ...) WEAK;\nint cs_win_snprintf(char *str, size_t size, const char *format, ...) {\n  int res;\n  va_list ap;\n  va_start(ap, format);\n  res = vsnprintf(str, size, format, ap);\n  va_end(ap);\n  return res;\n}\n#endif /* _WIN32 */\n\nint json_walk(const char *json_string, int json_string_length,\n              json_walk_callback_t callback, void *callback_data) WEAK;\nint json_walk(const char *json_string, int json_string_length,\n              json_walk_callback_t callback, void *callback_data) {\n  struct frozen frozen;\n\n  memset(&frozen, 0, sizeof(frozen));\n  frozen.end = json_string + json_string_length;\n  frozen.cur = json_string;\n  frozen.callback_data = callback_data;\n  frozen.callback = callback;\n\n  TRY(json_doit(&frozen));\n\n  return frozen.cur - json_string;\n}\n\nstruct scan_array_info {\n  int found;\n  char path[JSON_MAX_PATH_LEN];\n  struct json_token *token;\n};\n\nstatic void json_scanf_array_elem_cb(void *callback_data, const char *name,\n                                     size_t name_len, const char *path,\n                                     const struct json_token *token) {\n  struct scan_array_info *info = (struct scan_array_info *) callback_data;\n\n  (void) name;\n  (void) name_len;\n\n  if (strcmp(path, info->path) == 0) {\n    *info->token = *token;\n    info->found = 1;\n  }\n}\n\nint json_scanf_array_elem(const char *s, int len, const char *path, int idx,\n                          struct json_token *token) WEAK;\nint json_scanf_array_elem(const char *s, int len, const char *path, int idx,\n                          struct json_token *token) {\n  struct scan_array_info info;\n  info.token = token;\n  info.found = 0;\n  memset(token, 0, sizeof(*token));\n  snprintf(info.path, sizeof(info.path), \"%s[%d]\", path, idx);\n  json_walk(s, len, json_scanf_array_elem_cb, &info);\n  return info.found ? token->len : -1;\n}\n\nstruct json_scanf_info {\n  int num_conversions;\n  char *path;\n  const char *fmt;\n  void *target;\n  void *user_data;\n  int type;\n};\n\nint json_unescape(const char *src, int slen, char *dst, int dlen) WEAK;\nint json_unescape(const char *src, int slen, char *dst, int dlen) {\n  char *send = (char *) src + slen, *dend = dst + dlen, *orig_dst = dst, *p;\n  const char *esc1 = \"\\\"\\\\/bfnrt\", *esc2 = \"\\\"\\\\/\\b\\f\\n\\r\\t\";\n\n  while (src < send) {\n    if (*src == '\\\\') {\n      if (++src >= send) return JSON_STRING_INCOMPLETE;\n      if (*src == 'u') {\n        if (send - src < 5) return JSON_STRING_INCOMPLETE;\n        /* Here we go: this is a \\u.... escape. Process simple one-byte chars */\n        if (src[1] == '0' && src[2] == '0') {\n          /* This is \\u00xx character from the ASCII range */\n          if (dst < dend) *dst = hexdec(src + 3);\n          src += 4;\n        } else {\n          /* Complex \\uXXXX escapes drag utf8 lib... Do it at some stage */\n          return JSON_STRING_INVALID;\n        }\n      } else if ((p = (char *) strchr(esc1, *src)) != NULL) {\n        if (dst < dend) *dst = esc2[p - esc1];\n      } else {\n        return JSON_STRING_INVALID;\n      }\n    } else {\n      if (dst < dend) *dst = *src;\n    }\n    dst++;\n    src++;\n  }\n\n  return dst - orig_dst;\n}\n\nstatic void json_scanf_cb(void *callback_data, const char *name,\n                          size_t name_len, const char *path,\n                          const struct json_token *token) {\n  struct json_scanf_info *info = (struct json_scanf_info *) callback_data;\n  char buf[32]; /* Must be enough to hold numbers */\n\n  (void) name;\n  (void) name_len;\n\n  if (token->ptr == NULL) {\n    /*\n     * We're not interested here in the events for which we have no value;\n     * namely, JSON_TYPE_OBJECT_START and JSON_TYPE_ARRAY_START\n     */\n    return;\n  }\n\n  if (strcmp(path, info->path) != 0) {\n    /* It's not the path we're looking for, so, just ignore this callback */\n    return;\n  }\n\n  switch (info->type) {\n    case 'B':\n      info->num_conversions++;\n      switch (sizeof(bool)) {\n        case sizeof(char):\n          *(char *) info->target = (token->type == JSON_TYPE_TRUE ? 1 : 0);\n          break;\n        case sizeof(int):\n          *(int *) info->target = (token->type == JSON_TYPE_TRUE ? 1 : 0);\n          break;\n        default:\n          /* should never be here */\n          abort();\n      }\n      break;\n    case 'M': {\n      union {\n        void *p;\n        json_scanner_t f;\n      } u = {info->target};\n      info->num_conversions++;\n      u.f(token->ptr, token->len, info->user_data);\n      break;\n    }\n    case 'Q': {\n      char **dst = (char **) info->target;\n      if (token->type == JSON_TYPE_NULL) {\n        *dst = NULL;\n      } else {\n        int unescaped_len = json_unescape(token->ptr, token->len, NULL, 0);\n        if (unescaped_len >= 0 &&\n            (*dst = (char *) malloc(unescaped_len + 1)) != NULL) {\n          info->num_conversions++;\n          if (json_unescape(token->ptr, token->len, *dst, unescaped_len) ==\n              unescaped_len) {\n            (*dst)[unescaped_len] = '\\0';\n          } else {\n            free(*dst);\n            *dst = NULL;\n          }\n        }\n      }\n      break;\n    }\n    case 'H': {\n#if JSON_ENABLE_HEX\n      char **dst = (char **) info->user_data;\n      int i, len = token->len / 2;\n      *(int *) info->target = len;\n      if ((*dst = (char *) malloc(len + 1)) != NULL) {\n        for (i = 0; i < len; i++) {\n          (*dst)[i] = hexdec(token->ptr + 2 * i);\n        }\n        (*dst)[len] = '\\0';\n        info->num_conversions++;\n      }\n#endif /* JSON_ENABLE_HEX */\n      break;\n    }\n    case 'V': {\n#if JSON_ENABLE_BASE64\n      char **dst = (char **) info->target;\n      int len = token->len * 4 / 3 + 2;\n      if ((*dst = (char *) malloc(len + 1)) != NULL) {\n        int n = b64dec(token->ptr, token->len, *dst);\n        (*dst)[n] = '\\0';\n        *(int *) info->user_data = n;\n        info->num_conversions++;\n      }\n#endif /* JSON_ENABLE_BASE64 */\n      break;\n    }\n    case 'T':\n      info->num_conversions++;\n      *(struct json_token *) info->target = *token;\n      break;\n    default:\n      if (token->len >= (int) sizeof(buf)) break;\n      /* Before converting, copy into tmp buffer in order to 0-terminate it */\n      memcpy(buf, token->ptr, token->len);\n      buf[token->len] = '\\0';\n      /* NB: Use of base 0 for %d, %ld, %u and %lu is intentional. */\n      if (info->fmt[1] == 'd' || (info->fmt[1] == 'l' && info->fmt[2] == 'd') ||\n          info->fmt[1] == 'i') {\n        char *endptr = NULL;\n        long r = strtol(buf, &endptr, 0 /* base */);\n        if (*endptr == '\\0') {\n          if (info->fmt[1] == 'l') {\n            *((long *) info->target) = r;\n          } else {\n            *((int *) info->target) = (int) r;\n          }\n          info->num_conversions++;\n        }\n      } else if (info->fmt[1] == 'u' ||\n                 (info->fmt[1] == 'l' && info->fmt[2] == 'u')) {\n        char *endptr = NULL;\n        unsigned long r = strtoul(buf, &endptr, 0 /* base */);\n        if (*endptr == '\\0') {\n          if (info->fmt[1] == 'l') {\n            *((unsigned long *) info->target) = r;\n          } else {\n            *((unsigned int *) info->target) = (unsigned int) r;\n          }\n          info->num_conversions++;\n        }\n      } else {\n#if !JSON_MINIMAL\n        info->num_conversions += sscanf(buf, info->fmt, info->target);\n#endif\n      }\n      break;\n  }\n}\n\nint json_vscanf(const char *s, int len, const char *fmt, va_list ap) WEAK;\nint json_vscanf(const char *s, int len, const char *fmt, va_list ap) {\n  char path[JSON_MAX_PATH_LEN] = \"\", fmtbuf[20];\n  int i = 0;\n  char *p = NULL;\n  struct json_scanf_info info = {0, path, fmtbuf, NULL, NULL, 0};\n\n  while (fmt[i] != '\\0') {\n    if (fmt[i] == '{') {\n      strcat(path, \".\");\n      i++;\n    } else if (fmt[i] == '}') {\n      if ((p = strrchr(path, '.')) != NULL) *p = '\\0';\n      i++;\n    } else if (fmt[i] == '%') {\n      info.target = va_arg(ap, void *);\n      info.type = fmt[i + 1];\n      switch (fmt[i + 1]) {\n        case 'M':\n        case 'V':\n        case 'H':\n          info.user_data = va_arg(ap, void *);\n        /* FALLTHROUGH */\n        case 'B':\n        case 'Q':\n        case 'T':\n          i += 2;\n          break;\n        default: {\n          const char *delims = \", \\t\\r\\n]}\";\n          int conv_len = strcspn(fmt + i + 1, delims) + 1;\n          memcpy(fmtbuf, fmt + i, conv_len);\n          fmtbuf[conv_len] = '\\0';\n          i += conv_len;\n          i += strspn(fmt + i, delims);\n          break;\n        }\n      }\n      json_walk(s, len, json_scanf_cb, &info);\n    } else if (json_isalpha(fmt[i]) || json_get_utf8_char_len(fmt[i]) > 1) {\n      char *pe;\n      const char *delims = \": \\r\\n\\t\";\n      int key_len = strcspn(&fmt[i], delims);\n      if ((p = strrchr(path, '.')) != NULL) p[1] = '\\0';\n      pe = path + strlen(path);\n      memcpy(pe, fmt + i, key_len);\n      pe[key_len] = '\\0';\n      i += key_len + strspn(fmt + i + key_len, delims);\n    } else {\n      i++;\n    }\n  }\n  return info.num_conversions;\n}\n\nint json_scanf(const char *str, int len, const char *fmt, ...) WEAK;\nint json_scanf(const char *str, int len, const char *fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, fmt);\n  result = json_vscanf(str, len, fmt, ap);\n  va_end(ap);\n  return result;\n}\n\nint json_vfprintf(const char *file_name, const char *fmt, va_list ap) WEAK;\nint json_vfprintf(const char *file_name, const char *fmt, va_list ap) {\n  int res = -1;\n  FILE *fp = fopen(file_name, \"wb\");\n  if (fp != NULL) {\n    struct json_out out = JSON_OUT_FILE(fp);\n    res = json_vprintf(&out, fmt, ap);\n    fputc('\\n', fp);\n    fclose(fp);\n  }\n  return res;\n}\n\nint json_fprintf(const char *file_name, const char *fmt, ...) WEAK;\nint json_fprintf(const char *file_name, const char *fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, fmt);\n  result = json_vfprintf(file_name, fmt, ap);\n  va_end(ap);\n  return result;\n}\n\nchar *json_fread(const char *path) WEAK;\nchar *json_fread(const char *path) {\n  FILE *fp;\n  char *data = NULL;\n  if ((fp = fopen(path, \"rb\")) == NULL) {\n  } else if (fseek(fp, 0, SEEK_END) != 0) {\n    fclose(fp);\n  } else {\n    long size = ftell(fp);\n    if (size > 0 && (data = (char *) malloc(size + 1)) != NULL) {\n      fseek(fp, 0, SEEK_SET); /* Some platforms might not have rewind(), Oo */\n      if (fread(data, 1, size, fp) != (size_t) size) {\n        free(data);\n        data = NULL;\n      } else {\n        data[size] = '\\0';\n      }\n    }\n    fclose(fp);\n  }\n  return data;\n}\n\nstruct json_setf_data {\n  const char *json_path;\n  const char *base; /* Pointer to the source JSON string */\n  int matched;      /* Matched part of json_path */\n  int pos;          /* Offset of the mutated value begin */\n  int end;          /* Offset of the mutated value end */\n  int prev;         /* Offset of the previous token end */\n};\n\nstatic int get_matched_prefix_len(const char *s1, const char *s2) {\n  int i = 0;\n  while (s1[i] && s2[i] && s1[i] == s2[i]) i++;\n  return i;\n}\n\nstatic void json_vsetf_cb(void *userdata, const char *name, size_t name_len,\n                          const char *path, const struct json_token *t) {\n  struct json_setf_data *data = (struct json_setf_data *) userdata;\n  int off, len = get_matched_prefix_len(path, data->json_path);\n  if (t->ptr == NULL) return;\n  off = t->ptr - data->base;\n  if (len > data->matched) data->matched = len;\n\n  /*\n   * If there is no exact path match, set the mutation position to tbe end\n   * of the object or array\n   */\n  if (len < data->matched && data->pos == 0 &&\n      (t->type == JSON_TYPE_OBJECT_END || t->type == JSON_TYPE_ARRAY_END)) {\n    data->pos = data->end = data->prev;\n  }\n\n  /* Exact path match. Set mutation position to the value of this token */\n  if (strcmp(path, data->json_path) == 0 && t->type != JSON_TYPE_OBJECT_START &&\n      t->type != JSON_TYPE_ARRAY_START) {\n    data->pos = off;\n    data->end = off + t->len;\n  }\n\n  /*\n   * For deletion, we need to know where the previous value ends, because\n   * we don't know where matched value key starts.\n   * When the mutation position is not yet set, remember each value end.\n   * When the mutation position is already set, but it is at the beginning\n   * of the object/array, we catch the end of the object/array and see\n   * whether the object/array start is closer then previously stored prev.\n   */\n  if (data->pos == 0) {\n    data->prev = off + t->len; /* pos is not yet set */\n  } else if ((t->ptr[0] == '[' || t->ptr[0] == '{') && off + 1 < data->pos &&\n             off + 1 > data->prev) {\n    data->prev = off + 1;\n  }\n  (void) name;\n  (void) name_len;\n}\n\nint json_vsetf(const char *s, int len, struct json_out *out,\n               const char *json_path, const char *json_fmt, va_list ap) WEAK;\nint json_vsetf(const char *s, int len, struct json_out *out,\n               const char *json_path, const char *json_fmt, va_list ap) {\n  struct json_setf_data data;\n  memset(&data, 0, sizeof(data));\n  data.json_path = json_path;\n  data.base = s;\n  data.end = len;\n  json_walk(s, len, json_vsetf_cb, &data);\n  if (json_fmt == NULL) {\n    /* Deletion codepath */\n    json_printf(out, \"%.*s\", data.prev, s);\n    /* Trim comma after the value that begins at object/array start */\n    if (s[data.prev - 1] == '{' || s[data.prev - 1] == '[') {\n      int i = data.end;\n      while (i < len && json_isspace(s[i])) i++;\n      if (s[i] == ',') data.end = i + 1; /* Point after comma */\n    }\n    json_printf(out, \"%.*s\", len - data.end, s + data.end);\n  } else {\n    /* Modification codepath */\n    int n, off = data.matched, depth = 0;\n\n    /* Print the unchanged beginning */\n    json_printf(out, \"%.*s\", data.pos, s);\n\n    /* Add missing keys */\n    while ((n = strcspn(&json_path[off], \".[\")) > 0) {\n      if (s[data.prev - 1] != '{' && s[data.prev - 1] != '[' && depth == 0) {\n        json_printf(out, \",\");\n      }\n      if (off > 0 && json_path[off - 1] != '.') break;\n      json_printf(out, \"%.*Q:\", n, json_path + off);\n      off += n;\n      if (json_path[off] != '\\0') {\n        json_printf(out, \"%c\", json_path[off] == '.' ? '{' : '[');\n        depth++;\n        off++;\n      }\n    }\n    /* Print the new value */\n    json_vprintf(out, json_fmt, ap);\n\n    /* Close brackets/braces of the added missing keys */\n    for (; off > data.matched; off--) {\n      int ch = json_path[off];\n      const char *p = ch == '.' ? \"}\" : ch == '[' ? \"]\" : \"\";\n      json_printf(out, \"%s\", p);\n    }\n\n    /* Print the rest of the unchanged string */\n    json_printf(out, \"%.*s\", len - data.end, s + data.end);\n  }\n  return data.end > data.pos ? 1 : 0;\n}\n\nint json_setf(const char *s, int len, struct json_out *out,\n              const char *json_path, const char *json_fmt, ...) WEAK;\nint json_setf(const char *s, int len, struct json_out *out,\n              const char *json_path, const char *json_fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, json_fmt);\n  result = json_vsetf(s, len, out, json_path, json_fmt, ap);\n  va_end(ap);\n  return result;\n}\n\nstruct prettify_data {\n  struct json_out *out;\n  int level;\n  int last_token;\n};\n\nstatic void indent(struct json_out *out, int level) {\n  while (level-- > 0) out->printer(out, \"  \", 2);\n}\n\nstatic void print_key(struct prettify_data *pd, const char *path,\n                      const char *name, int name_len) {\n  if (pd->last_token != JSON_TYPE_INVALID &&\n      pd->last_token != JSON_TYPE_ARRAY_START &&\n      pd->last_token != JSON_TYPE_OBJECT_START) {\n    pd->out->printer(pd->out, \",\", 1);\n  }\n  if (path[0] != '\\0') pd->out->printer(pd->out, \"\\n\", 1);\n  indent(pd->out, pd->level);\n  if (path[0] != '\\0' && path[strlen(path) - 1] != ']') {\n    pd->out->printer(pd->out, \"\\\"\", 1);\n    pd->out->printer(pd->out, name, (int) name_len);\n    pd->out->printer(pd->out, \"\\\"\", 1);\n    pd->out->printer(pd->out, \": \", 2);\n  }\n}\n\nstatic void prettify_cb(void *userdata, const char *name, size_t name_len,\n                        const char *path, const struct json_token *t) {\n  struct prettify_data *pd = (struct prettify_data *) userdata;\n  switch (t->type) {\n    case JSON_TYPE_OBJECT_START:\n    case JSON_TYPE_ARRAY_START:\n      print_key(pd, path, name, name_len);\n      pd->out->printer(pd->out, t->type == JSON_TYPE_ARRAY_START ? \"[\" : \"{\",\n                       1);\n      pd->level++;\n      break;\n    case JSON_TYPE_OBJECT_END:\n    case JSON_TYPE_ARRAY_END:\n      pd->level--;\n      if (pd->last_token != JSON_TYPE_INVALID &&\n          pd->last_token != JSON_TYPE_ARRAY_START &&\n          pd->last_token != JSON_TYPE_OBJECT_START) {\n        pd->out->printer(pd->out, \"\\n\", 1);\n        indent(pd->out, pd->level);\n      }\n      pd->out->printer(pd->out, t->type == JSON_TYPE_ARRAY_END ? \"]\" : \"}\", 1);\n      break;\n    case JSON_TYPE_NUMBER:\n    case JSON_TYPE_NULL:\n    case JSON_TYPE_TRUE:\n    case JSON_TYPE_FALSE:\n    case JSON_TYPE_STRING:\n      print_key(pd, path, name, name_len);\n      if (t->type == JSON_TYPE_STRING) pd->out->printer(pd->out, \"\\\"\", 1);\n      pd->out->printer(pd->out, t->ptr, t->len);\n      if (t->type == JSON_TYPE_STRING) pd->out->printer(pd->out, \"\\\"\", 1);\n      break;\n    default:\n      break;\n  }\n  pd->last_token = t->type;\n}\n\nint json_prettify(const char *s, int len, struct json_out *out) WEAK;\nint json_prettify(const char *s, int len, struct json_out *out) {\n  struct prettify_data pd = {out, 0, JSON_TYPE_INVALID};\n  return json_walk(s, len, prettify_cb, &pd);\n}\n\nint json_prettify_file(const char *file_name) WEAK;\nint json_prettify_file(const char *file_name) {\n  int res = -1;\n  char *s = json_fread(file_name);\n  FILE *fp;\n  if (s != NULL && (fp = fopen(file_name, \"wb\")) != NULL) {\n    struct json_out out = JSON_OUT_FILE(fp);\n    res = json_prettify(s, strlen(s), &out);\n    if (res < 0) {\n      /* On error, restore the old content */\n      fclose(fp);\n      fp = fopen(file_name, \"wb\");\n      fseek(fp, 0, SEEK_SET);\n      fwrite(s, 1, strlen(s), fp);\n    } else {\n      fputc('\\n', fp);\n    }\n    fclose(fp);\n  }\n  free(s);\n  return res;\n}\n\nstruct next_data {\n  void *handle;            // Passed handle. Changed if a next entry is found\n  const char *path;        // Path to the iterated object/array\n  int path_len;            // Path length - optimisation\n  int found;               // Non-0 if found the next entry\n  struct json_token *key;  // Object's key\n  struct json_token *val;  // Object's value\n  int *idx;                // Array index\n};\n\nstatic void next_set_key(struct next_data *d, const char *name, int name_len,\n                         int is_array) {\n  if (is_array) {\n    /* Array. Set index and reset key  */\n    if (d->key != NULL) {\n      d->key->len = 0;\n      d->key->ptr = NULL;\n    }\n    if (d->idx != NULL) *d->idx = atoi(name);\n  } else {\n    /* Object. Set key and make index -1 */\n    if (d->key != NULL) {\n      d->key->ptr = name;\n      d->key->len = name_len;\n    }\n    if (d->idx != NULL) *d->idx = -1;\n  }\n}\n\nstatic void json_next_cb(void *userdata, const char *name, size_t name_len,\n                         const char *path, const struct json_token *t) {\n  struct next_data *d = (struct next_data *) userdata;\n  const char *p = path + d->path_len;\n  if (d->found) return;\n  if (d->path_len >= (int) strlen(path)) return;\n  if (strncmp(d->path, path, d->path_len) != 0) return;\n  if (strchr(p + 1, '.') != NULL) return; /* More nested objects - skip */\n  if (strchr(p + 1, '[') != NULL) return; /* Ditto for arrays */\n  // {OBJECT,ARRAY}_END types do not pass name, _START does. Save key.\n  if (t->type == JSON_TYPE_OBJECT_START || t->type == JSON_TYPE_ARRAY_START) {\n    next_set_key(d, name, name_len, p[0] == '[');\n  } else if (d->handle == NULL || d->handle < (void *) t->ptr) {\n    if (t->type != JSON_TYPE_OBJECT_END && t->type != JSON_TYPE_ARRAY_END) {\n      next_set_key(d, name, name_len, p[0] == '[');\n    }\n    if (d->val != NULL) *d->val = *t;\n    d->handle = (void *) t->ptr;\n    d->found = 1;\n  }\n}\n\nstatic void *json_next(const char *s, int len, void *handle, const char *path,\n                       struct json_token *key, struct json_token *val, int *i) {\n  struct json_token tmpval, *v = val == NULL ? &tmpval : val;\n  struct json_token tmpkey, *k = key == NULL ? &tmpkey : key;\n  int tmpidx, *pidx = i == NULL ? &tmpidx : i;\n  struct next_data data = {handle, path, (int) strlen(path), 0, k, v, pidx};\n  json_walk(s, len, json_next_cb, &data);\n  return data.found ? data.handle : NULL;\n}\n\nvoid *json_next_key(const char *s, int len, void *handle, const char *path,\n                    struct json_token *key, struct json_token *val) WEAK;\nvoid *json_next_key(const char *s, int len, void *handle, const char *path,\n                    struct json_token *key, struct json_token *val) {\n  return json_next(s, len, handle, path, key, val, NULL);\n}\n\nvoid *json_next_elem(const char *s, int len, void *handle, const char *path,\n                     int *idx, struct json_token *val) WEAK;\nvoid *json_next_elem(const char *s, int len, void *handle, const char *path,\n                     int *idx, struct json_token *val) {\n  return json_next(s, len, handle, path, NULL, val, idx);\n}\n\nstatic int json_sprinter(struct json_out *out, const char *str, size_t len) {\n  size_t old_len = out->u.buf.buf == NULL ? 0 : strlen(out->u.buf.buf);\n  size_t new_len = len + old_len;\n  char *p = (char *) realloc(out->u.buf.buf, new_len + 1);\n  if (p != NULL) {\n    memcpy(p + old_len, str, len);\n    p[new_len] = '\\0';\n    out->u.buf.buf = p;\n  }\n  return len;\n}\n\nchar *json_vasprintf(const char *fmt, va_list ap) WEAK;\nchar *json_vasprintf(const char *fmt, va_list ap) {\n  struct json_out out;\n  memset(&out, 0, sizeof(out));\n  out.printer = json_sprinter;\n  json_vprintf(&out, fmt, ap);\n  return out.u.buf.buf;\n}\n\nchar *json_asprintf(const char *fmt, ...) WEAK;\nchar *json_asprintf(const char *fmt, ...) {\n  char *result = NULL;\n  va_list ap;\n  va_start(ap, fmt);\n  result = json_vasprintf(fmt, ap);\n  va_end(ap);\n  return result;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/ffi/ffi.c\"\n#endif\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n\n#define IS_W(arg) ((arg).ctype == FFI_CTYPE_WORD)\n#define IS_D(arg) ((arg).ctype == FFI_CTYPE_DOUBLE)\n#define IS_F(arg) ((arg).ctype == FFI_CTYPE_FLOAT)\n\n#define W(arg) ((ffi_word_t)(arg).v.i)\n#define D(arg) ((arg).v.d)\n#define F(arg) ((arg).v.f)\n\nvoid ffi_set_word(struct ffi_arg *arg, ffi_word_t v) {\n  arg->ctype = FFI_CTYPE_WORD;\n  arg->v.i = v;\n}\n\nvoid ffi_set_bool(struct ffi_arg *arg, bool v) {\n  arg->ctype = FFI_CTYPE_BOOL;\n  arg->v.i = v;\n}\n\nvoid ffi_set_ptr(struct ffi_arg *arg, void *v) {\n  ffi_set_word(arg, (ffi_word_t) v);\n}\n\nvoid ffi_set_double(struct ffi_arg *arg, double v) {\n  arg->ctype = FFI_CTYPE_DOUBLE;\n  arg->v.d = v;\n}\n\nvoid ffi_set_float(struct ffi_arg *arg, float v) {\n  arg->ctype = FFI_CTYPE_FLOAT;\n  arg->v.f = v;\n}\n\n/*\n * The ARM ABI uses only 4 32-bit registers for paramter passing.\n * Xtensa call0 calling-convention (as used by Espressif) has 6.\n *\n * Focusing only on implementing FFI with registers means we can simplify a lot.\n *\n * ARM has some quasi-alignment rules when mixing double and integers as\n * arguments. Only:\n *   a) double, int32_t, int32_t\n *   b) int32_t, double\n * would fit in 4 registers. (the same goes for uint64_t).\n *\n * In order to simplify further, when a double-width argument is present, we\n * allow only two arguments.\n */\n\n/*\n * We need to support x86_64 in order to support local tests.\n * x86_64 has more and wider registers, but unlike the two main\n * embedded platforms we target it has a separate register file for\n * integer values and for floating point values (both for passing args and\n * return values). E.g. if a double value is passed as a second argument\n * it gets passed in the first available floating point register.\n *\n * I.e, the compiler generates exactly the same code for:\n *\n * void foo(int a, double b) {...}\n *\n * and\n *\n * void foo(double b, int a) {...}\n *\n *\n */\n\ntypedef ffi_word_t (*w4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*w5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                            ffi_word_t);\ntypedef ffi_word_t (*w6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                            ffi_word_t, ffi_word_t);\n\ntypedef ffi_word_t (*wdw_t)(double, ffi_word_t);\ntypedef ffi_word_t (*wwd_t)(ffi_word_t, double);\ntypedef ffi_word_t (*wdd_t)(double, double);\n\ntypedef ffi_word_t (*wwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef ffi_word_t (*wwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef ffi_word_t (*wwdd_t)(ffi_word_t, double, double);\ntypedef ffi_word_t (*wdww_t)(double, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*wdwd_t)(double, ffi_word_t, double);\ntypedef ffi_word_t (*wddw_t)(double, double, ffi_word_t);\ntypedef ffi_word_t (*wddd_t)(double, double, double);\n\ntypedef ffi_word_t (*wfw_t)(float, ffi_word_t);\ntypedef ffi_word_t (*wwf_t)(ffi_word_t, float);\ntypedef ffi_word_t (*wff_t)(float, float);\n\ntypedef ffi_word_t (*wwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef ffi_word_t (*wwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef ffi_word_t (*wwff_t)(ffi_word_t, float, float);\ntypedef ffi_word_t (*wfww_t)(float, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*wfwf_t)(float, ffi_word_t, float);\ntypedef ffi_word_t (*wffw_t)(float, float, ffi_word_t);\ntypedef ffi_word_t (*wfff_t)(float, float, float);\n\ntypedef bool (*b4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef bool (*b5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                      ffi_word_t);\ntypedef bool (*b6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                      ffi_word_t, ffi_word_t);\ntypedef bool (*bdw_t)(double, ffi_word_t);\ntypedef bool (*bwd_t)(ffi_word_t, double);\ntypedef bool (*bdd_t)(double, double);\n\ntypedef bool (*bwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef bool (*bwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef bool (*bwdd_t)(ffi_word_t, double, double);\ntypedef bool (*bdww_t)(double, ffi_word_t, ffi_word_t);\ntypedef bool (*bdwd_t)(double, ffi_word_t, double);\ntypedef bool (*bddw_t)(double, double, ffi_word_t);\ntypedef bool (*bddd_t)(double, double, double);\n\ntypedef bool (*bfw_t)(float, ffi_word_t);\ntypedef bool (*bwf_t)(ffi_word_t, float);\ntypedef bool (*bff_t)(float, float);\n\ntypedef bool (*bwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef bool (*bwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef bool (*bwff_t)(ffi_word_t, float, float);\ntypedef bool (*bfww_t)(float, ffi_word_t, ffi_word_t);\ntypedef bool (*bfwf_t)(float, ffi_word_t, float);\ntypedef bool (*bffw_t)(float, float, ffi_word_t);\ntypedef bool (*bfff_t)(float, float, float);\n\ntypedef double (*d4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef double (*d5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                        ffi_word_t);\ntypedef double (*d6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                        ffi_word_t, ffi_word_t);\ntypedef double (*ddw_t)(double, ffi_word_t);\ntypedef double (*dwd_t)(ffi_word_t, double);\ntypedef double (*ddd_t)(double, double);\n\ntypedef double (*dwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef double (*dwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef double (*dwdd_t)(ffi_word_t, double, double);\ntypedef double (*ddww_t)(double, ffi_word_t, ffi_word_t);\ntypedef double (*ddwd_t)(double, ffi_word_t, double);\ntypedef double (*dddw_t)(double, double, ffi_word_t);\ntypedef double (*dddd_t)(double, double, double);\n\ntypedef float (*f4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef float (*f5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                       ffi_word_t);\ntypedef float (*f6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                       ffi_word_t, ffi_word_t);\ntypedef float (*ffw_t)(float, ffi_word_t);\ntypedef float (*fwf_t)(ffi_word_t, float);\ntypedef float (*fff_t)(float, float);\n\ntypedef float (*fwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef float (*fwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef float (*fwff_t)(ffi_word_t, float, float);\ntypedef float (*ffww_t)(float, ffi_word_t, ffi_word_t);\ntypedef float (*ffwf_t)(float, ffi_word_t, float);\ntypedef float (*fffw_t)(float, float, ffi_word_t);\ntypedef float (*ffff_t)(float, float, float);\n\nint ffi_call(ffi_fn_t *func, int nargs, struct ffi_arg *res,\n             struct ffi_arg *args) {\n  int i, doubles = 0, floats = 0;\n\n  if (nargs > 6) return -1;\n  for (i = 0; i < nargs; i++) {\n    doubles += (IS_D(args[i]));\n    floats += (IS_F(args[i]));\n  }\n\n  /* Doubles and floats are not supported together atm */\n  if (doubles > 0 && floats > 0) {\n    return -1;\n  }\n\n  switch (res->ctype) {\n    case FFI_CTYPE_WORD: { /* {{{ */\n      ffi_word_t r;\n      if (doubles == 0) {\n        if (floats == 0) {\n          /*\n           * No double and no float args: we currently support up to 6\n           * word-sized arguments\n           */\n          if (nargs <= 4) {\n            w4w_t f = (w4w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n          } else if (nargs == 5) {\n            w5w_t f = (w5w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n          } else if (nargs == 6) {\n            w6w_t f = (w6w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                  W(args[5]));\n          } else {\n            abort();\n          }\n        } else {\n          /* There are some floats */\n          switch (nargs) {\n            case 0:\n            case 1:\n            case 2:\n              if (IS_F(args[0]) && IS_F(args[1])) {\n                wff_t f = (wff_t) func;\n                r = f(F(args[0]), F(args[1]));\n              } else if (IS_F(args[0])) {\n                wfw_t f = (wfw_t) func;\n                r = f(F(args[0]), W(args[1]));\n              } else {\n                wwf_t f = (wwf_t) func;\n                r = f(W(args[0]), F(args[1]));\n              }\n              break;\n\n            case 3:\n              if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                wwwf_t f = (wwwf_t) func;\n                r = f(W(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                wwfw_t f = (wwfw_t) func;\n                r = f(W(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                wwff_t f = (wwff_t) func;\n                r = f(W(args[0]), F(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n                wfww_t f = (wfww_t) func;\n                r = f(F(args[0]), W(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                wfwf_t f = (wfwf_t) func;\n                r = f(F(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                wffw_t f = (wffw_t) func;\n                r = f(F(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                wfff_t f = (wfff_t) func;\n                r = f(F(args[0]), F(args[1]), F(args[2]));\n              } else {\n                // The above checks should be exhaustive\n                abort();\n              }\n              break;\n            default:\n              return -1;\n          }\n        }\n      } else {\n        /* There are some doubles */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              wdd_t f = (wdd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              wdw_t f = (wdw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              wwd_t f = (wwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              wwwd_t f = (wwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              wwdw_t f = (wwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              wwdd_t f = (wwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              wdww_t f = (wdww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              wdwd_t f = (wdwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              wddw_t f = (wddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              wddd_t f = (wddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.i = (uint64_t) r;\n    } break;               /* }}} */\n    case FFI_CTYPE_BOOL: { /* {{{ */\n      ffi_word_t r;\n      if (doubles == 0) {\n        if (floats == 0) {\n          /*\n           * No double and no float args: we currently support up to 6\n           * word-sized arguments\n           */\n          if (nargs <= 4) {\n            b4w_t f = (b4w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n          } else if (nargs == 5) {\n            b5w_t f = (b5w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n          } else if (nargs == 6) {\n            b6w_t f = (b6w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                  W(args[5]));\n          } else {\n            abort();\n          }\n        } else {\n          /* There are some floats */\n          switch (nargs) {\n            case 0:\n            case 1:\n            case 2:\n              if (IS_F(args[0]) && IS_F(args[1])) {\n                bff_t f = (bff_t) func;\n                r = f(F(args[0]), F(args[1]));\n              } else if (IS_F(args[0])) {\n                bfw_t f = (bfw_t) func;\n                r = f(F(args[0]), W(args[1]));\n              } else {\n                bwf_t f = (bwf_t) func;\n                r = f(W(args[0]), F(args[1]));\n              }\n              break;\n\n            case 3:\n              if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                bwwf_t f = (bwwf_t) func;\n                r = f(W(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                bwfw_t f = (bwfw_t) func;\n                r = f(W(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                bwff_t f = (bwff_t) func;\n                r = f(W(args[0]), F(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n                bfww_t f = (bfww_t) func;\n                r = f(F(args[0]), W(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                bfwf_t f = (bfwf_t) func;\n                r = f(F(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                bffw_t f = (bffw_t) func;\n                r = f(F(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                bfff_t f = (bfff_t) func;\n                r = f(F(args[0]), F(args[1]), F(args[2]));\n              } else {\n                // The above checks should be exhaustive\n                abort();\n              }\n              break;\n            default:\n              return -1;\n          }\n        }\n      } else {\n        /* There are some doubles */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              bdd_t f = (bdd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              bdw_t f = (bdw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              bwd_t f = (bwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              bwwd_t f = (bwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              bwdw_t f = (bwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              bwdd_t f = (bwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              bdww_t f = (bdww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              bdwd_t f = (bdwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              bddw_t f = (bddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              bddd_t f = (bddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.i = (uint64_t) r;\n    } break;                 /* }}} */\n    case FFI_CTYPE_DOUBLE: { /* {{{ */\n      double r;\n      if (doubles == 0) {\n        /* No double args: we currently support up to 6 word-sized arguments\n         */\n        if (nargs <= 4) {\n          d4w_t f = (d4w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n        } else if (nargs == 5) {\n          d5w_t f = (d5w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n        } else if (nargs == 6) {\n          d6w_t f = (d6w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                W(args[5]));\n        } else {\n          abort();\n        }\n      } else {\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              ddd_t f = (ddd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              ddw_t f = (ddw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              dwd_t f = (dwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              dwwd_t f = (dwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              dwdw_t f = (dwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              dwdd_t f = (dwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              ddww_t f = (ddww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              ddwd_t f = (ddwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              dddw_t f = (dddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              dddd_t f = (dddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.d = r;\n    } break;                /* }}} */\n    case FFI_CTYPE_FLOAT: { /* {{{ */\n      double r;\n      if (floats == 0) {\n        /* No float args: we currently support up to 6 word-sized arguments\n         */\n        if (nargs <= 4) {\n          f4w_t f = (f4w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n        } else if (nargs == 5) {\n          f5w_t f = (f5w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n        } else if (nargs == 6) {\n          f6w_t f = (f6w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                W(args[5]));\n        } else {\n          abort();\n        }\n      } else {\n        /* There are some float args */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_F(args[0]) && IS_F(args[1])) {\n              fff_t f = (fff_t) func;\n              r = f(F(args[0]), F(args[1]));\n            } else if (IS_F(args[0])) {\n              ffw_t f = (ffw_t) func;\n              r = f(F(args[0]), W(args[1]));\n            } else {\n              fwf_t f = (fwf_t) func;\n              r = f(W(args[0]), F(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n              fwwf_t f = (fwwf_t) func;\n              r = f(W(args[0]), W(args[1]), F(args[2]));\n            } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n              fwfw_t f = (fwfw_t) func;\n              r = f(W(args[0]), F(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n              fwff_t f = (fwff_t) func;\n              r = f(W(args[0]), F(args[1]), F(args[2]));\n            } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              ffww_t f = (ffww_t) func;\n              r = f(F(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n              ffwf_t f = (ffwf_t) func;\n              r = f(F(args[0]), W(args[1]), F(args[2]));\n            } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n              fffw_t f = (fffw_t) func;\n              r = f(F(args[0]), F(args[1]), W(args[2]));\n            } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n              ffff_t f = (ffff_t) func;\n              r = f(F(args[0]), F(args[1]), F(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.f = r;\n    } break; /* }}} */\n  }\n\n  return 0;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array.c\"\n#endif\n\n#include <stdio.h>\n/* Amalgamated: #include \"common/str_util.h\" */\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#define SPLICE_NEW_ITEM_IDX 2\n\n/* like c_snprintf but returns `size` if write is truncated */\nstatic int v_sprintf_s(char *buf, size_t size, const char *fmt, ...) {\n  size_t n;\n  va_list ap;\n  va_start(ap, fmt);\n  n = c_vsnprintf(buf, size, fmt, ap);\n  if (n > size) {\n    return size;\n  }\n  return n;\n}\n\nmjs_val_t mjs_mk_array(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_object(mjs);\n  /* change the tag to MJS_TAG_ARRAY */\n  ret &= ~MJS_TAG_MASK;\n  ret |= MJS_TAG_ARRAY;\n  return ret;\n}\n\nint mjs_is_array(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_ARRAY;\n}\n\nmjs_val_t mjs_array_get(struct mjs *mjs, mjs_val_t arr, unsigned long index) {\n  return mjs_array_get2(mjs, arr, index, NULL);\n}\n\nmjs_val_t mjs_array_get2(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                         int *has) {\n  mjs_val_t res = MJS_UNDEFINED;\n\n  if (has != NULL) {\n    *has = 0;\n  }\n\n  if (mjs_is_object(arr)) {\n    struct mjs_property *p;\n    char buf[20];\n    int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n    p = mjs_get_own_property(mjs, arr, buf, n);\n    if (p != NULL) {\n      if (has != NULL) {\n        *has = 1;\n      }\n      res = p->value;\n    }\n  }\n\n  return res;\n}\n\nunsigned long mjs_array_length(struct mjs *mjs, mjs_val_t v) {\n  struct mjs_property *p;\n  unsigned long len = 0;\n\n  if (!mjs_is_object(v)) {\n    len = 0;\n    goto clean;\n  }\n\n  for (p = get_object_struct(v)->properties; p != NULL; p = p->next) {\n    int ok = 0;\n    unsigned long n = 0;\n    str_to_ulong(mjs, p->name, &ok, &n);\n    if (ok && n >= len && n < 0xffffffff) {\n      len = n + 1;\n    }\n  }\n\nclean:\n  return len;\n}\n\nmjs_err_t mjs_array_set(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                        mjs_val_t v) {\n  mjs_err_t ret = MJS_OK;\n\n  if (mjs_is_object(arr)) {\n    char buf[20];\n    int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n    ret = mjs_set(mjs, arr, buf, n, v);\n  } else {\n    ret = MJS_TYPE_ERROR;\n  }\n\n  return ret;\n}\n\nvoid mjs_array_del(struct mjs *mjs, mjs_val_t arr, unsigned long index) {\n  char buf[20];\n  int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n  mjs_del(mjs, arr, buf, n);\n}\n\nmjs_err_t mjs_array_push(struct mjs *mjs, mjs_val_t arr, mjs_val_t v) {\n  return mjs_array_set(mjs, arr, mjs_array_length(mjs, arr), v);\n}\n\nMJS_PRIVATE void mjs_array_push_internal(struct mjs *mjs) {\n  mjs_err_t rcode = MJS_OK;\n  mjs_val_t ret = MJS_UNDEFINED;\n  int nargs = mjs_nargs(mjs);\n  int i;\n\n  /* Make sure that `this` is an array */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_OBJECT_ARRAY, NULL)) {\n    goto clean;\n  }\n\n  /* Push all args */\n  for (i = 0; i < nargs; i++) {\n    rcode = mjs_array_push(mjs, mjs->vals.this_obj, mjs_arg(mjs, i));\n    if (rcode != MJS_OK) {\n      mjs_prepend_errorf(mjs, rcode, \"\");\n      goto clean;\n    }\n  }\n\n  /* Return the new array length */\n  ret = mjs_mk_number(mjs, mjs_array_length(mjs, mjs->vals.this_obj));\n\nclean:\n  mjs_return(mjs, ret);\n  return;\n}\n\nstatic void move_item(struct mjs *mjs, mjs_val_t arr, unsigned long from,\n                      unsigned long to) {\n  mjs_val_t cur = mjs_array_get(mjs, arr, from);\n  mjs_array_set(mjs, arr, to, cur);\n  mjs_array_del(mjs, arr, from);\n}\n\nMJS_PRIVATE void mjs_array_splice(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_err_t rcode = MJS_OK;\n  mjs_val_t ret = mjs_mk_array(mjs);\n  mjs_val_t start_v = MJS_UNDEFINED;\n  mjs_val_t deleteCount_v = MJS_UNDEFINED;\n  int start = 0;\n  int arr_len;\n  int delete_cnt = 0;\n  int new_items_cnt = 0;\n  int delta = 0;\n  int i;\n\n  /* Make sure that `this` is an array */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_OBJECT_ARRAY, NULL)) {\n    goto clean;\n  }\n\n  /* Get array length */\n  arr_len = mjs_array_length(mjs, mjs->vals.this_obj);\n\n  /* get start from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"start\", MJS_TYPE_NUMBER, &start_v)) {\n    goto clean;\n  }\n  start = mjs_normalize_idx(mjs_get_int(mjs, start_v), arr_len);\n\n  /* Handle deleteCount */\n  if (nargs >= SPLICE_NEW_ITEM_IDX) {\n    /* deleteCount is given; use it */\n    if (!mjs_check_arg(mjs, 1, \"deleteCount\", MJS_TYPE_NUMBER,\n                       &deleteCount_v)) {\n      goto clean;\n    }\n    delete_cnt = mjs_get_int(mjs, deleteCount_v);\n    new_items_cnt = nargs - SPLICE_NEW_ITEM_IDX;\n  } else {\n    /* deleteCount is not given; assume the end of the array */\n    delete_cnt = arr_len - start;\n  }\n  if (delete_cnt > arr_len - start) {\n    delete_cnt = arr_len - start;\n  } else if (delete_cnt < 0) {\n    delete_cnt = 0;\n  }\n\n  /* delta at which subsequent array items should be moved */\n  delta = new_items_cnt - delete_cnt;\n\n  /*\n   * copy items which are going to be deleted to the separate array (will be\n   * returned)\n   */\n  for (i = 0; i < delete_cnt; i++) {\n    mjs_val_t cur = mjs_array_get(mjs, mjs->vals.this_obj, start + i);\n    rcode = mjs_array_push(mjs, ret, cur);\n    if (rcode != MJS_OK) {\n      mjs_prepend_errorf(mjs, rcode, \"\");\n      goto clean;\n    }\n  }\n\n  /* If needed, move subsequent items */\n  if (delta < 0) {\n    for (i = start; i < arr_len; i++) {\n      if (i >= start - delta) {\n        move_item(mjs, mjs->vals.this_obj, i, i + delta);\n      } else {\n        mjs_array_del(mjs, mjs->vals.this_obj, i);\n      }\n    }\n  } else if (delta > 0) {\n    for (i = arr_len - 1; i >= start; i--) {\n      move_item(mjs, mjs->vals.this_obj, i, i + delta);\n    }\n  }\n\n  /* Set new items to the array */\n  for (i = 0; i < nargs - SPLICE_NEW_ITEM_IDX; i++) {\n    mjs_array_set(mjs, mjs->vals.this_obj, start + i,\n                  mjs_arg(mjs, SPLICE_NEW_ITEM_IDX + i));\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_bcode.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_varint.h\" */\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nstatic void add_lineno_map_item(struct pstate *pstate) {\n  if (pstate->last_emitted_line_no < pstate->line_no) {\n    int offset = pstate->cur_idx - pstate->start_bcode_idx;\n    size_t offset_llen = cs_varint_llen(offset);\n    size_t lineno_llen = cs_varint_llen(pstate->line_no);\n    mbuf_resize(&pstate->offset_lineno_map,\n                pstate->offset_lineno_map.size + offset_llen + lineno_llen);\n\n    /* put offset */\n    cs_varint_encode(offset, (uint8_t *) pstate->offset_lineno_map.buf +\n                                 pstate->offset_lineno_map.len,\n                     offset_llen);\n    pstate->offset_lineno_map.len += offset_llen;\n\n    /* put line_no */\n    cs_varint_encode(pstate->line_no,\n                     (uint8_t *) pstate->offset_lineno_map.buf +\n                         pstate->offset_lineno_map.len,\n                     lineno_llen);\n    pstate->offset_lineno_map.len += lineno_llen;\n\n    pstate->last_emitted_line_no = pstate->line_no;\n  }\n}\n\nMJS_PRIVATE void emit_byte(struct pstate *pstate, uint8_t byte) {\n  add_lineno_map_item(pstate);\n  mbuf_insert(&pstate->mjs->bcode_gen, pstate->cur_idx, &byte, sizeof(byte));\n  pstate->cur_idx += sizeof(byte);\n}\n\nMJS_PRIVATE void emit_int(struct pstate *pstate, int64_t n) {\n  struct mbuf *b = &pstate->mjs->bcode_gen;\n  size_t llen = cs_varint_llen(n);\n  add_lineno_map_item(pstate);\n  mbuf_insert(b, pstate->cur_idx, NULL, llen);\n  cs_varint_encode(n, (uint8_t *) b->buf + pstate->cur_idx, llen);\n  pstate->cur_idx += llen;\n}\n\nMJS_PRIVATE void emit_str(struct pstate *pstate, const char *ptr, size_t len) {\n  struct mbuf *b = &pstate->mjs->bcode_gen;\n  size_t llen = cs_varint_llen(len);\n  add_lineno_map_item(pstate);\n  mbuf_insert(b, pstate->cur_idx, NULL, llen + len);\n  cs_varint_encode(len, (uint8_t *) b->buf + pstate->cur_idx, llen);\n  memcpy(b->buf + pstate->cur_idx + llen, ptr, len);\n  pstate->cur_idx += llen + len;\n}\n\nMJS_PRIVATE int mjs_bcode_insert_offset(struct pstate *p, struct mjs *mjs,\n                                        size_t offset, size_t v) {\n  int llen = (int) cs_varint_llen(v);\n  int diff = llen - MJS_INIT_OFFSET_SIZE;\n  assert(offset < mjs->bcode_gen.len);\n  if (diff > 0) {\n    mbuf_resize(&mjs->bcode_gen, mjs->bcode_gen.size + diff);\n  }\n  /*\n   * Offset is going to take more than one was reserved, so, move the data\n   * forward\n   */\n  memmove(mjs->bcode_gen.buf + offset + llen,\n          mjs->bcode_gen.buf + offset + MJS_INIT_OFFSET_SIZE,\n          mjs->bcode_gen.len - offset - MJS_INIT_OFFSET_SIZE);\n  mjs->bcode_gen.len += diff;\n  cs_varint_encode(v, (uint8_t *) mjs->bcode_gen.buf + offset, llen);\n\n  /*\n   * If current parsing index is after the offset at which we've inserted new\n   * varint, the index might need to be adjusted\n   */\n  if (p->cur_idx >= (int) offset) {\n    p->cur_idx += diff;\n  }\n  return diff;\n}\n\nMJS_PRIVATE void mjs_bcode_part_add(struct mjs *mjs,\n                                    const struct mjs_bcode_part *bp) {\n  mbuf_append(&mjs->bcode_parts, bp, sizeof(*bp));\n}\n\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get(struct mjs *mjs,\n                                                      int num) {\n  assert(num < mjs_bcode_parts_cnt(mjs));\n  return (struct mjs_bcode_part *) (mjs->bcode_parts.buf +\n                                    num * sizeof(struct mjs_bcode_part));\n}\n\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get_by_offset(struct mjs *mjs,\n                                                                size_t offset) {\n  int i;\n  int parts_cnt = mjs_bcode_parts_cnt(mjs);\n  struct mjs_bcode_part *bp = NULL;\n\n  if (offset >= mjs->bcode_len) {\n    return NULL;\n  }\n\n  for (i = 0; i < parts_cnt; i++) {\n    bp = mjs_bcode_part_get(mjs, i);\n    if (offset < bp->start_idx + bp->data.len) {\n      break;\n    }\n  }\n\n  /* given the non-corrupted data, the needed part must be found */\n  assert(i < parts_cnt);\n\n  return bp;\n}\n\nMJS_PRIVATE int mjs_bcode_parts_cnt(struct mjs *mjs) {\n  return mjs->bcode_parts.len / sizeof(struct mjs_bcode_part);\n}\n\nMJS_PRIVATE void mjs_bcode_commit(struct mjs *mjs) {\n  struct mjs_bcode_part bp;\n  memset(&bp, 0, sizeof(bp));\n\n  /* Make sure the bcode doesn't occupy any extra space */\n  mbuf_trim(&mjs->bcode_gen);\n\n  /* Transfer the ownership of the bcode data */\n  bp.data.p = mjs->bcode_gen.buf;\n  bp.data.len = mjs->bcode_gen.len;\n  mbuf_init(&mjs->bcode_gen, 0);\n\n  bp.start_idx = mjs->bcode_len;\n  bp.exec_res = MJS_ERRS_CNT;\n\n  mjs_bcode_part_add(mjs, &bp);\n\n  mjs->bcode_len += bp.data.len;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_builtin.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_dataview.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_json.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nstatic void mjs_print(struct mjs *mjs) {\n  size_t i, num_args = mjs_nargs(mjs);\n  for (i = 0; i < num_args; i++) {\n    mjs_fprintf(mjs_arg(mjs, i), mjs, stdout);\n    putchar(' ');\n  }\n  putchar('\\n');\n  mjs_return(mjs, MJS_UNDEFINED);\n}\n\n/*\n * If the file with the given filename was already loaded, returns the\n * corresponding bcode part; otherwise returns NULL.\n */\nstatic struct mjs_bcode_part *mjs_get_loaded_file_bcode(struct mjs *mjs,\n                                                        const char *filename) {\n  int parts_cnt = mjs_bcode_parts_cnt(mjs);\n  int i;\n\n  if (filename == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < parts_cnt; i++) {\n    struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n    const char *cur_fn = mjs_get_bcode_filename(mjs, bp);\n    if (strcmp(filename, cur_fn) == 0) {\n      return bp;\n    }\n  }\n  return NULL;\n}\n\nstatic void mjs_load(struct mjs *mjs) {\n  mjs_val_t res = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n  mjs_val_t arg1 = mjs_arg(mjs, 1);\n  int custom_global = 0; /* whether the custom global object was provided */\n\n  if (mjs_is_string(arg0)) {\n    const char *path = mjs_get_cstring(mjs, &arg0);\n    struct mjs_bcode_part *bp = NULL;\n    mjs_err_t ret;\n\n    if (mjs_is_object(arg1)) {\n      custom_global = 1;\n      push_mjs_val(&mjs->scopes, arg1);\n    }\n    bp = mjs_get_loaded_file_bcode(mjs, path);\n    if (bp == NULL) {\n      /* File was not loaded before, so, load */\n      ret = mjs_exec_file(mjs, path, &res);\n    } else {\n      /*\n       * File was already loaded before, so if it was evaluated successfully,\n       * then skip the evaluation at all (and assume MJS_OK); otherwise\n       * re-evaluate it again.\n       *\n       * However, if the custom global object was provided, then reevaluate\n       * the file in any case.\n       */\n      if (bp->exec_res != MJS_OK || custom_global) {\n        ret = mjs_execute(mjs, bp->start_idx, &res);\n      } else {\n        ret = MJS_OK;\n      }\n    }\n    if (ret != MJS_OK) {\n      /*\n       * arg0 and path might be invalidated by executing a file, so refresh\n       * them\n       */\n      arg0 = mjs_arg(mjs, 0);\n      path = mjs_get_cstring(mjs, &arg0);\n      mjs_prepend_errorf(mjs, ret, \"failed to exec file \\\"%s\\\"\", path);\n      goto clean;\n    }\n\n  clean:\n    if (custom_global) {\n      mjs_pop_val(&mjs->scopes);\n    }\n  }\n  mjs_return(mjs, res);\n}\n\nstatic void mjs_get_mjs(struct mjs *mjs) {\n  mjs_return(mjs, mjs_mk_foreign(mjs, mjs));\n}\n\nstatic void mjs_chr(struct mjs *mjs) {\n  mjs_val_t arg0 = mjs_arg(mjs, 0), res = MJS_NULL;\n  int n = mjs_get_int(mjs, arg0);\n  if (mjs_is_number(arg0) && n >= 0 && n <= 255) {\n    uint8_t s = n;\n    res = mjs_mk_string(mjs, (const char *) &s, sizeof(s), 1);\n  }\n  mjs_return(mjs, res);\n}\n\nstatic void mjs_do_gc(struct mjs *mjs) {\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n  mjs_gc(mjs, mjs_is_boolean(arg0) ? mjs_get_bool(mjs, arg0) : 0);\n  mjs_return(mjs, arg0);\n}\n\nstatic void mjs_s2o(struct mjs *mjs) {\n  mjs_return(mjs,\n             mjs_struct_to_obj(mjs, mjs_get_ptr(mjs, mjs_arg(mjs, 0)),\n                               (const struct mjs_c_struct_member *) mjs_get_ptr(\n                                   mjs, mjs_arg(mjs, 1))));\n}\n\nvoid mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) {\n  mjs_val_t v;\n\n  mjs_set(mjs, obj, \"global\", ~0, obj);\n\n  mjs_set(mjs, obj, \"load\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_load));\n  mjs_set(mjs, obj, \"print\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_print));\n  mjs_set(mjs, obj, \"ffi\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call));\n  mjs_set(mjs, obj, \"ffi_cb_free\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free));\n  mjs_set(mjs, obj, \"mkstr\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr));\n  mjs_set(mjs, obj, \"getMJS\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_get_mjs));\n  mjs_set(mjs, obj, \"die\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_die));\n  mjs_set(mjs, obj, \"gc\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_do_gc));\n  mjs_set(mjs, obj, \"chr\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_chr));\n  mjs_set(mjs, obj, \"s2o\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o));\n\n  /*\n   * Populate JSON.parse() and JSON.stringify()\n   */\n  v = mjs_mk_object(mjs);\n  mjs_set(mjs, v, \"stringify\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_stringify));\n  mjs_set(mjs, v, \"parse\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_parse));\n  mjs_set(mjs, obj, \"JSON\", ~0, v);\n\n  /*\n   * Populate Object.create()\n   */\n  v = mjs_mk_object(mjs);\n  mjs_set(mjs, v, \"create\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_create_object));\n  mjs_set(mjs, obj, \"Object\", ~0, v);\n\n  /*\n   * Populate numeric stuff\n   */\n  mjs_set(mjs, obj, \"NaN\", ~0, MJS_TAG_NAN);\n  mjs_set(mjs, obj, \"isNaN\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_isnan));\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_conversion.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nMJS_PRIVATE mjs_err_t mjs_to_string(struct mjs *mjs, mjs_val_t *v, char **p,\n                                    size_t *sizep, int *need_free) {\n  mjs_err_t ret = MJS_OK;\n\n  *p = NULL;\n  *sizep = 0;\n  *need_free = 0;\n\n  if (mjs_is_string(*v)) {\n    *p = (char *) mjs_get_string(mjs, v, sizep);\n  } else if (mjs_is_number(*v)) {\n    char buf[50] = \"\";\n    struct json_out out = JSON_OUT_BUF(buf, sizeof(buf));\n    mjs_jprintf(*v, mjs, &out);\n    *sizep = strlen(buf);\n    *p = malloc(*sizep + 1);\n    if (*p == NULL) {\n      ret = MJS_OUT_OF_MEMORY;\n      goto clean;\n    }\n    memmove(*p, buf, *sizep + 1);\n    *need_free = 1;\n  } else if (mjs_is_boolean(*v)) {\n    if (mjs_get_bool(mjs, *v)) {\n      *p = \"true\";\n      *sizep = 4;\n    } else {\n      *p = \"false\";\n      *sizep = 5;\n    }\n  } else if (mjs_is_undefined(*v)) {\n    *p = \"undefined\";\n    *sizep = 9;\n  } else if (mjs_is_null(*v)) {\n    *p = \"null\";\n    *sizep = 4;\n  } else if (mjs_is_object(*v)) {\n    ret = MJS_TYPE_ERROR;\n    mjs_set_errorf(mjs, ret,\n                   \"conversion from object to string is not supported\");\n  } else if (mjs_is_foreign(*v)) {\n    *p = \"TODO_foreign\";\n    *sizep = 12;\n  } else {\n    ret = MJS_TYPE_ERROR;\n    mjs_set_errorf(mjs, ret, \"unknown type to convert to string\");\n  }\n\nclean:\n  return ret;\n}\n\nMJS_PRIVATE mjs_val_t mjs_to_boolean_v(struct mjs *mjs, mjs_val_t v) {\n  size_t len;\n  int is_truthy;\n\n  is_truthy =\n      ((mjs_is_boolean(v) && mjs_get_bool(mjs, v)) ||\n       (mjs_is_number(v) && mjs_get_double(mjs, v) != 0.0) ||\n       (mjs_is_string(v) && mjs_get_string(mjs, &v, &len) && len > 0) ||\n       (mjs_is_function(v)) || (mjs_is_foreign(v)) || (mjs_is_object(v))) &&\n      v != MJS_TAG_NAN;\n\n  return mjs_mk_boolean(mjs, is_truthy);\n}\n\nMJS_PRIVATE int mjs_is_truthy(struct mjs *mjs, mjs_val_t v) {\n  return mjs_get_bool(mjs, mjs_to_boolean_v(mjs, v));\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_varint.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_builtin.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#ifndef MJS_OBJECT_ARENA_SIZE\n#define MJS_OBJECT_ARENA_SIZE 20\n#endif\n#ifndef MJS_PROPERTY_ARENA_SIZE\n#define MJS_PROPERTY_ARENA_SIZE 20\n#endif\n#ifndef MJS_FUNC_FFI_ARENA_SIZE\n#define MJS_FUNC_FFI_ARENA_SIZE 20\n#endif\n\n#ifndef MJS_OBJECT_ARENA_INC_SIZE\n#define MJS_OBJECT_ARENA_INC_SIZE 10\n#endif\n#ifndef MJS_PROPERTY_ARENA_INC_SIZE\n#define MJS_PROPERTY_ARENA_INC_SIZE 10\n#endif\n#ifndef MJS_FUNC_FFI_ARENA_INC_SIZE\n#define MJS_FUNC_FFI_ARENA_INC_SIZE 10\n#endif\n\nvoid mjs_destroy(struct mjs *mjs) {\n  {\n    int parts_cnt = mjs_bcode_parts_cnt(mjs);\n    int i;\n    for (i = 0; i < parts_cnt; i++) {\n      struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n      if (!bp->in_rom) {\n        free((void *) bp->data.p);\n      }\n    }\n  }\n\n  mbuf_free(&mjs->bcode_gen);\n  mbuf_free(&mjs->bcode_parts);\n  mbuf_free(&mjs->stack);\n  mbuf_free(&mjs->call_stack);\n  mbuf_free(&mjs->arg_stack);\n  mbuf_free(&mjs->owned_strings);\n  mbuf_free(&mjs->foreign_strings);\n  mbuf_free(&mjs->owned_values);\n  mbuf_free(&mjs->scopes);\n  mbuf_free(&mjs->loop_addresses);\n  mbuf_free(&mjs->json_visited_stack);\n  free(mjs->error_msg);\n  free(mjs->stack_trace);\n  mjs_ffi_args_free_list(mjs);\n  gc_arena_destroy(mjs, &mjs->object_arena);\n  gc_arena_destroy(mjs, &mjs->property_arena);\n  gc_arena_destroy(mjs, &mjs->ffi_sig_arena);\n  free(mjs);\n}\n\nstruct mjs *mjs_create(void) {\n  mjs_val_t global_object;\n  struct mjs *mjs = calloc(1, sizeof(*mjs));\n  mbuf_init(&mjs->stack, 0);\n  mbuf_init(&mjs->call_stack, 0);\n  mbuf_init(&mjs->arg_stack, 0);\n  mbuf_init(&mjs->owned_strings, 0);\n  mbuf_init(&mjs->foreign_strings, 0);\n  mbuf_init(&mjs->bcode_gen, 0);\n  mbuf_init(&mjs->bcode_parts, 0);\n  mbuf_init(&mjs->owned_values, 0);\n  mbuf_init(&mjs->scopes, 0);\n  mbuf_init(&mjs->loop_addresses, 0);\n  mbuf_init(&mjs->json_visited_stack, 0);\n\n  mjs->bcode_len = 0;\n\n  /*\n   * The compacting GC exploits the null terminator of the previous string as a\n   * marker.\n   */\n  {\n    char z = 0;\n    mbuf_append(&mjs->owned_strings, &z, 1);\n  }\n\n  gc_arena_init(&mjs->object_arena, sizeof(struct mjs_object),\n                MJS_OBJECT_ARENA_SIZE, MJS_OBJECT_ARENA_INC_SIZE);\n  gc_arena_init(&mjs->property_arena, sizeof(struct mjs_property),\n                MJS_PROPERTY_ARENA_SIZE, MJS_PROPERTY_ARENA_INC_SIZE);\n  gc_arena_init(&mjs->ffi_sig_arena, sizeof(struct mjs_ffi_sig),\n                MJS_FUNC_FFI_ARENA_SIZE, MJS_FUNC_FFI_ARENA_INC_SIZE);\n  mjs->ffi_sig_arena.destructor = mjs_ffi_sig_destructor;\n\n  global_object = mjs_mk_object(mjs);\n  mjs_init_builtin(mjs, global_object);\n  mjs_set_ffi_resolver(mjs, dlsym);\n  push_mjs_val(&mjs->scopes, global_object);\n  mjs->vals.this_obj = MJS_UNDEFINED;\n  mjs->vals.dataview_proto = MJS_UNDEFINED;\n\n  return mjs;\n}\n\nmjs_err_t mjs_set_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  free(mjs->error_msg);\n  mjs->error_msg = NULL;\n  mjs->error = err;\n  if (fmt != NULL) {\n    mg_avprintf(&mjs->error_msg, 0, fmt, ap);\n  }\n  va_end(ap);\n  return err;\n}\n\nmjs_err_t mjs_prepend_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt,\n                             ...) {\n  char *old_error_msg = mjs->error_msg;\n  char *new_error_msg = NULL;\n  va_list ap;\n  va_start(ap, fmt);\n\n  /* err should never be MJS_OK here */\n  assert(err != MJS_OK);\n\n  mjs->error_msg = NULL;\n  /* set error if only it wasn't already set to some error */\n  if (mjs->error == MJS_OK) {\n    mjs->error = err;\n  }\n  mg_avprintf(&new_error_msg, 0, fmt, ap);\n  va_end(ap);\n\n  if (old_error_msg != NULL) {\n    mg_asprintf(&mjs->error_msg, 0, \"%s: %s\", new_error_msg, old_error_msg);\n    free(new_error_msg);\n    free(old_error_msg);\n  } else {\n    mjs->error_msg = new_error_msg;\n  }\n  return err;\n}\n\nvoid mjs_print_error(struct mjs *mjs, FILE *fp, const char *msg,\n                     int print_stack_trace) {\n  if (print_stack_trace && mjs->stack_trace != NULL) {\n    fprintf(fp, \"%s\", mjs->stack_trace);\n  }\n\n  if (msg == NULL) {\n    msg = \"MJS error\";\n  }\n\n  fprintf(fp, \"%s: %s\\n\", msg, mjs_strerror(mjs, mjs->error));\n}\n\nMJS_PRIVATE void mjs_die(struct mjs *mjs) {\n  mjs_val_t msg_v = MJS_UNDEFINED;\n  const char *msg = NULL;\n  size_t msg_len = 0;\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"msg\", MJS_TYPE_STRING, &msg_v)) {\n    goto clean;\n  }\n\n  msg = mjs_get_string(mjs, &msg_v, &msg_len);\n\n  /* TODO(dfrank): take error type as an argument */\n  mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"%.*s\", (int) msg_len, msg);\n\nclean:\n  mjs_return(mjs, MJS_UNDEFINED);\n}\n\nconst char *mjs_strerror(struct mjs *mjs, enum mjs_err err) {\n  const char *err_names[] = {\n      \"NO_ERROR\",        \"SYNTAX_ERROR\",    \"REFERENCE_ERROR\",\n      \"TYPE_ERROR\",      \"OUT_OF_MEMORY\",   \"INTERNAL_ERROR\",\n      \"NOT_IMPLEMENTED\", \"FILE_OPEN_ERROR\", \"BAD_ARGUMENTS\"};\n  return mjs->error_msg == NULL || mjs->error_msg[0] == '\\0' ? err_names[err]\n                                                             : mjs->error_msg;\n}\n\nMJS_PRIVATE size_t mjs_get_func_addr(mjs_val_t v) {\n  return v & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE enum mjs_type mjs_get_type(mjs_val_t v) {\n  int tag;\n  if (mjs_is_number(v)) {\n    return MJS_TYPE_NUMBER;\n  }\n  tag = (v & MJS_TAG_MASK) >> 48;\n  switch (tag) {\n    case MJS_TAG_FOREIGN >> 48:\n      return MJS_TYPE_FOREIGN;\n    case MJS_TAG_UNDEFINED >> 48:\n      return MJS_TYPE_UNDEFINED;\n    case MJS_TAG_OBJECT >> 48:\n      return MJS_TYPE_OBJECT_GENERIC;\n    case MJS_TAG_ARRAY >> 48:\n      return MJS_TYPE_OBJECT_ARRAY;\n    case MJS_TAG_FUNCTION >> 48:\n      return MJS_TYPE_OBJECT_FUNCTION;\n    case MJS_TAG_STRING_I >> 48:\n    case MJS_TAG_STRING_O >> 48:\n    case MJS_TAG_STRING_F >> 48:\n    case MJS_TAG_STRING_D >> 48:\n    case MJS_TAG_STRING_5 >> 48:\n      return MJS_TYPE_STRING;\n    case MJS_TAG_BOOLEAN >> 48:\n      return MJS_TYPE_BOOLEAN;\n    case MJS_TAG_NULL >> 48:\n      return MJS_TYPE_NULL;\n    default:\n      abort();\n      return MJS_TYPE_UNDEFINED;\n  }\n}\n\nmjs_val_t mjs_get_global(struct mjs *mjs) {\n  return *vptr(&mjs->scopes, 0);\n}\n\nstatic void mjs_append_stack_trace_line(struct mjs *mjs, size_t offset) {\n  if (offset != MJS_BCODE_OFFSET_EXIT) {\n    const char *filename = mjs_get_bcode_filename_by_offset(mjs, offset);\n    int line_no = mjs_get_lineno_by_offset(mjs, offset);\n    char *new_line = NULL;\n    const char *fmt = \"  at %s:%d\\n\";\n    if (filename == NULL) {\n      fprintf(stderr,\n              \"ERROR during stack trace generation: wrong bcode offset %d\\n\",\n              (int) offset);\n      filename = \"<unknown-filename>\";\n    }\n    mg_asprintf(&new_line, 0, fmt, filename, line_no);\n\n    if (mjs->stack_trace != NULL) {\n      char *old = mjs->stack_trace;\n      mg_asprintf(&mjs->stack_trace, 0, \"%s%s\", mjs->stack_trace, new_line);\n      free(old);\n      free(new_line);\n    } else {\n      mjs->stack_trace = new_line;\n    }\n  }\n}\n\nMJS_PRIVATE void mjs_gen_stack_trace(struct mjs *mjs, size_t offset) {\n  mjs_append_stack_trace_line(mjs, offset);\n  while (mjs->call_stack.len >=\n         sizeof(mjs_val_t) * CALL_STACK_FRAME_ITEMS_CNT) {\n    int i;\n\n    /* set current offset to it to the offset stored in the frame */\n    offset = mjs_get_int(\n        mjs, *vptr(&mjs->call_stack, -1 - CALL_STACK_FRAME_ITEM_RETURN_ADDR));\n\n    /* pop frame from the call stack */\n    for (i = 0; i < CALL_STACK_FRAME_ITEMS_CNT; i++) {\n      mjs_pop_val(&mjs->call_stack);\n    }\n\n    mjs_append_stack_trace_line(mjs, offset);\n  }\n}\n\nvoid mjs_own(struct mjs *mjs, mjs_val_t *v) {\n  mbuf_append(&mjs->owned_values, &v, sizeof(v));\n}\n\nint mjs_disown(struct mjs *mjs, mjs_val_t *v) {\n  mjs_val_t **vp = (mjs_val_t **) (mjs->owned_values.buf +\n                                   mjs->owned_values.len - sizeof(v));\n\n  for (; (char *) vp >= mjs->owned_values.buf; vp--) {\n    if (*vp == v) {\n      *vp = *(mjs_val_t **) (mjs->owned_values.buf + mjs->owned_values.len -\n                             sizeof(v));\n      mjs->owned_values.len -= sizeof(v);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/*\n * Returns position in the data stack at which the called function is located,\n * and which should be later replaced with the returned value.\n */\nMJS_PRIVATE int mjs_getretvalpos(struct mjs *mjs) {\n  int pos;\n  mjs_val_t *ppos = vptr(&mjs->call_stack, -1);\n  // LOG(LL_INFO, (\"ppos: %p %d\", ppos, mjs_stack_size(&mjs->call_stack)));\n  assert(ppos != NULL && mjs_is_number(*ppos));\n  pos = mjs_get_int(mjs, *ppos) - 1;\n  assert(pos < (int) mjs_stack_size(&mjs->stack));\n  return pos;\n}\n\nint mjs_nargs(struct mjs *mjs) {\n  int top = mjs_stack_size(&mjs->stack);\n  int pos = mjs_getretvalpos(mjs) + 1;\n  // LOG(LL_INFO, (\"top: %d pos: %d\", top, pos));\n  return pos > 0 && pos < top ? top - pos : 0;\n}\n\nmjs_val_t mjs_arg(struct mjs *mjs, int arg_index) {\n  mjs_val_t res = MJS_UNDEFINED;\n  int top = mjs_stack_size(&mjs->stack);\n  int pos = mjs_getretvalpos(mjs) + 1;\n  // LOG(LL_INFO, (\"idx %d pos: %d\", arg_index, pos));\n  if (pos > 0 && pos + arg_index < top) {\n    res = *vptr(&mjs->stack, pos + arg_index);\n  }\n  return res;\n}\n\nvoid mjs_return(struct mjs *mjs, mjs_val_t v) {\n  int pos = mjs_getretvalpos(mjs);\n  // LOG(LL_INFO, (\"pos: %d\", pos));\n  mjs->stack.len = sizeof(mjs_val_t) * pos;\n  mjs_push(mjs, v);\n}\n\nMJS_PRIVATE mjs_val_t vtop(struct mbuf *m) {\n  size_t size = mjs_stack_size(m);\n  return size > 0 ? *vptr(m, size - 1) : MJS_UNDEFINED;\n}\n\nMJS_PRIVATE size_t mjs_stack_size(const struct mbuf *m) {\n  return m->len / sizeof(mjs_val_t);\n}\n\nMJS_PRIVATE mjs_val_t *vptr(struct mbuf *m, int idx) {\n  int size = mjs_stack_size(m);\n  if (idx < 0) idx = size + idx;\n  return idx >= 0 && idx < size ? &((mjs_val_t *) m->buf)[idx] : NULL;\n}\n\nMJS_PRIVATE mjs_val_t mjs_pop(struct mjs *mjs) {\n  if (mjs->stack.len == 0) {\n    mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"stack underflow\");\n    return MJS_UNDEFINED;\n  } else {\n    return mjs_pop_val(&mjs->stack);\n  }\n}\n\nMJS_PRIVATE void push_mjs_val(struct mbuf *m, mjs_val_t v) {\n  mbuf_append(m, &v, sizeof(v));\n}\n\nMJS_PRIVATE mjs_val_t mjs_pop_val(struct mbuf *m) {\n  mjs_val_t v = MJS_UNDEFINED;\n  assert(m->len >= sizeof(v));\n  if (m->len >= sizeof(v)) {\n    memcpy(&v, m->buf + m->len - sizeof(v), sizeof(v));\n    m->len -= sizeof(v);\n  }\n  return v;\n}\n\nMJS_PRIVATE void mjs_push(struct mjs *mjs, mjs_val_t v) {\n  push_mjs_val(&mjs->stack, v);\n}\n\nvoid mjs_set_generate_jsc(struct mjs *mjs, int generate_jsc) {\n  mjs->generate_jsc = generate_jsc;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_dataview.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_exec_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nvoid *mjs_mem_to_ptr(unsigned val) {\n  return (void *) (uintptr_t) val;\n}\n\nvoid *mjs_mem_get_ptr(void *base, int offset) {\n  return (char *) base + offset;\n}\n\nvoid mjs_mem_set_ptr(void *ptr, void *val) {\n  *(void **) ptr = val;\n}\n\ndouble mjs_mem_get_dbl(void *ptr) {\n  double v;\n  memcpy(&v, ptr, sizeof(v));\n  return v;\n}\n\nvoid mjs_mem_set_dbl(void *ptr, double val) {\n  memcpy(ptr, &val, sizeof(val));\n}\n\n/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\ndouble mjs_mem_get_uint(void *ptr, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  unsigned int res = 0;\n  p += bigendian ? 0 : size - 1;\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n  return res;\n}\n\n/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\ndouble mjs_mem_get_int(void *ptr, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  int res = 0;\n  p += bigendian ? 0 : size - 1;\n\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n\n  /* sign-extend */\n  {\n    int extra = sizeof(res) - size;\n    for (i = 0; i < extra; i++) res <<= 8;\n    for (i = 0; i < extra; i++) res >>= 8;\n  }\n\n  return res;\n}\n\nvoid mjs_mem_set_uint(void *ptr, unsigned int val, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr + (bigendian ? size - 1 : 0);\n  int i, inc = bigendian ? -1 : 1;\n  for (i = 0; i < size; i++, p += inc) {\n    *p = val & 0xff;\n    val >>= 8;\n  }\n}\n\nvoid mjs_mem_set_int(void *ptr, int val, int size, int bigendian) {\n  mjs_mem_set_uint(ptr, val, size, bigendian);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_file.h\" */\n/* Amalgamated: #include \"common/cs_varint.h\" */\n\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_parser.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#if MJS_GENERATE_JSC && defined(CS_MMAP)\n#include <sys/mman.h>\n#endif\n\n/*\n * Pushes call stack frame. Offset is a global bcode offset. Retval_stack_idx\n * is an index in mjs->stack at which return value should be written later.\n */\nstatic void call_stack_push_frame(struct mjs *mjs, size_t offset,\n                                  mjs_val_t retval_stack_idx) {\n  /* Pop `this` value, and apply it */\n  mjs_val_t this_obj = mjs_pop_val(&mjs->arg_stack);\n\n  /*\n   * NOTE: the layout is described by enum mjs_call_stack_frame_item\n   */\n  push_mjs_val(&mjs->call_stack, mjs->vals.this_obj);\n  mjs->vals.this_obj = this_obj;\n\n  push_mjs_val(&mjs->call_stack, mjs_mk_number(mjs, (double) offset));\n  push_mjs_val(&mjs->call_stack,\n               mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->scopes)));\n  push_mjs_val(\n      &mjs->call_stack,\n      mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->loop_addresses)));\n  push_mjs_val(&mjs->call_stack, retval_stack_idx);\n}\n\n/*\n * Restores call stack frame. Returns the return address.\n */\nstatic size_t call_stack_restore_frame(struct mjs *mjs) {\n  size_t retval_stack_idx, return_address, scope_index, loop_addr_index;\n  assert(mjs_stack_size(&mjs->call_stack) >= CALL_STACK_FRAME_ITEMS_CNT);\n\n  /*\n   * NOTE: the layout is described by enum mjs_call_stack_frame_item\n   */\n  retval_stack_idx = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  loop_addr_index = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  scope_index = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  return_address = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  mjs->vals.this_obj = mjs_pop_val(&mjs->call_stack);\n\n  /* Remove created scopes */\n  while (mjs_stack_size(&mjs->scopes) > scope_index) {\n    mjs_pop_val(&mjs->scopes);\n  }\n\n  /* Remove loop addresses */\n  while (mjs_stack_size(&mjs->loop_addresses) > loop_addr_index) {\n    mjs_pop_val(&mjs->loop_addresses);\n  }\n\n  /* Shrink stack, leave return value on top */\n  mjs->stack.len = retval_stack_idx * sizeof(mjs_val_t);\n\n  /* Jump to the return address */\n  return return_address;\n}\n\nstatic mjs_val_t mjs_find_scope(struct mjs *mjs, mjs_val_t key) {\n  size_t num_scopes = mjs_stack_size(&mjs->scopes);\n  while (num_scopes > 0) {\n    mjs_val_t scope = *vptr(&mjs->scopes, num_scopes - 1);\n    num_scopes--;\n    if (mjs_get_own_property_v(mjs, scope, key) != NULL) return scope;\n  }\n  mjs_set_errorf(mjs, MJS_REFERENCE_ERROR, \"[%s] is not defined\",\n                 mjs_get_cstring(mjs, &key));\n  return MJS_UNDEFINED;\n}\n\nmjs_val_t mjs_get_this(struct mjs *mjs) {\n  return mjs->vals.this_obj;\n}\n\nstatic double do_arith_op(double da, double db, int op, bool *resnan) {\n  *resnan = false;\n\n  if (isnan(da) || isnan(db)) {\n    *resnan = true;\n    return 0;\n  }\n  /* clang-format off */\n  switch (op) {\n    case TOK_MINUS:   return da - db;\n    case TOK_PLUS:    return da + db;\n    case TOK_MUL:     return da * db;\n    case TOK_DIV:\n      if (db != 0) {\n        return da / db;\n      } else {\n        /* TODO(dfrank): add support for Infinity and return it here */\n        *resnan = true;\n        return 0;\n      }\n    case TOK_REM:\n      /*\n       * TODO(dfrank): probably support remainder operation as it is in JS\n       * (which works with non-integer divisor).\n       */\n      db = (int) db;\n      if (db != 0) {\n        bool neg = false;\n        if (da < 0) {\n          neg = true;\n          da = -da;\n        }\n        if (db < 0) {\n          db = -db;\n        }\n        da = (double) ((int64_t) da % (int64_t) db);\n        if (neg) {\n          da = -da;\n        }\n        return da;\n      } else {\n        *resnan = true;\n        return 0;\n      }\n    case TOK_AND:     return (double) ((int64_t) da & (int64_t) db);\n    case TOK_OR:      return (double) ((int64_t) da | (int64_t) db);\n    case TOK_XOR:     return (double) ((int64_t) da ^ (int64_t) db);\n    case TOK_LSHIFT:  return (double) ((int64_t) da << (int64_t) db);\n    case TOK_RSHIFT:  return (double) ((int64_t) da >> (int64_t) db);\n    case TOK_URSHIFT: return (double) ((uint32_t) da >> (uint32_t) db);\n  }\n  /* clang-format on */\n  *resnan = true;\n  return 0;\n}\n\nstatic void set_no_autoconversion_error(struct mjs *mjs) {\n  mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                     \"implicit type conversion is prohibited\");\n}\n\nstatic mjs_val_t do_op(struct mjs *mjs, mjs_val_t a, mjs_val_t b, int op) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  bool resnan = false;\n  if ((mjs_is_foreign(a) || mjs_is_number(a)) &&\n      (mjs_is_foreign(b) || mjs_is_number(b))) {\n    int is_result_ptr = 0;\n    double da, db, result;\n\n    if (mjs_is_foreign(a) && mjs_is_foreign(b)) {\n      /* When two operands are pointers, only subtraction is supported */\n      if (op != TOK_MINUS) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid operands\");\n      }\n    } else if (mjs_is_foreign(a) || mjs_is_foreign(b)) {\n      /*\n       * When one of the operands is a pointer, only + and - are supported,\n       * and the result is a pointer.\n       */\n      if (op != TOK_MINUS && op != TOK_PLUS) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid operands\");\n      }\n      is_result_ptr = 1;\n    }\n    da = mjs_is_number(a) ? mjs_get_double(mjs, a)\n                          : (double) (uintptr_t) mjs_get_ptr(mjs, a);\n    db = mjs_is_number(b) ? mjs_get_double(mjs, b)\n                          : (double) (uintptr_t) mjs_get_ptr(mjs, b);\n    result = do_arith_op(da, db, op, &resnan);\n    if (resnan) {\n      ret = MJS_TAG_NAN;\n    } else {\n      /*\n       * If at least one of the operands was a pointer, result should also be\n       * a pointer\n       */\n      ret = is_result_ptr ? mjs_mk_foreign(mjs, (void *) (uintptr_t) result)\n                          : mjs_mk_number(mjs, result);\n    }\n  } else if (mjs_is_string(a) && mjs_is_string(b) && (op == TOK_PLUS)) {\n    ret = s_concat(mjs, a, b);\n  } else {\n    set_no_autoconversion_error(mjs);\n  }\n  return ret;\n}\n\nstatic void op_assign(struct mjs *mjs, int op) {\n  mjs_val_t val = mjs_pop(mjs);\n  mjs_val_t obj = mjs_pop(mjs);\n  mjs_val_t key = mjs_pop(mjs);\n  if (mjs_is_object(obj) && mjs_is_string(key)) {\n    mjs_val_t v = mjs_get_v(mjs, obj, key);\n    mjs_set_v(mjs, obj, key, do_op(mjs, v, val, op));\n    mjs_push(mjs, v);\n  } else {\n    mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand\");\n  }\n}\n\nstatic int check_equal(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  int ret = 0;\n  if (a == MJS_TAG_NAN && b == MJS_TAG_NAN) {\n    ret = 0;\n  } else if (a == b) {\n    ret = 1;\n  } else if (mjs_is_number(a) && mjs_is_number(b)) {\n    /*\n     * The case of equal numbers is handled above, so here the result is always\n     * false\n     */\n    ret = 0;\n  } else if (mjs_is_string(a) && mjs_is_string(b)) {\n    ret = s_cmp(mjs, a, b) == 0;\n  } else if (mjs_is_foreign(a) && b == MJS_NULL) {\n    ret = mjs_get_ptr(mjs, a) == NULL;\n  } else if (a == MJS_NULL && mjs_is_foreign(b)) {\n    ret = mjs_get_ptr(mjs, b) == NULL;\n  } else {\n    ret = 0;\n  }\n  return ret;\n}\n\nstatic void exec_expr(struct mjs *mjs, int op) {\n  switch (op) {\n    case TOK_DOT:\n      break;\n    case TOK_MINUS:\n    case TOK_PLUS:\n    case TOK_MUL:\n    case TOK_DIV:\n    case TOK_REM:\n    case TOK_XOR:\n    case TOK_AND:\n    case TOK_OR:\n    case TOK_LSHIFT:\n    case TOK_RSHIFT:\n    case TOK_URSHIFT: {\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_push(mjs, do_op(mjs, a, b, op));\n      break;\n    }\n    case TOK_UNARY_MINUS: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, -a));\n      break;\n    }\n    case TOK_NOT: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !mjs_is_truthy(mjs, val)));\n      break;\n    }\n    case TOK_TILDA: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, (double) (~(int64_t) a)));\n      break;\n    }\n    case TOK_UNARY_PLUS:\n      break;\n    case TOK_EQ:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use ===, not ==\");\n      break;\n    case TOK_NE:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use !==, not !=\");\n      break;\n    case TOK_EQ_EQ: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_NE_NE: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_LT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a < b));\n      break;\n    }\n    case TOK_GT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a > b));\n      break;\n    }\n    case TOK_LE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a <= b));\n      break;\n    }\n    case TOK_GE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a >= b));\n      break;\n    }\n    case TOK_ASSIGN: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj)) {\n        mjs_set_v(mjs, obj, key, val);\n      } else if (mjs_is_foreign(obj)) {\n        /*\n         * We don't have setters, so in order to support properties which behave\n         * like setters, we have to parse key right here, instead of having real\n         * built-in prototype objects\n         */\n\n        int ikey = mjs_get_int(mjs, key);\n        int ival = mjs_get_int(mjs, val);\n\n        if (!mjs_is_number(key)) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n          val = MJS_UNDEFINED;\n        } else if (!mjs_is_number(val) || ival < 0 || ival > 0xff) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"only number 0 .. 255 can be assigned\");\n          val = MJS_UNDEFINED;\n        } else {\n          uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, obj);\n          *(ptr + ikey) = (uint8_t) ival;\n        }\n      } else {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"unsupported object type\");\n      }\n      mjs_push(mjs, val);\n      break;\n    }\n    case TOK_POSTFIX_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    case TOK_POSTFIX_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_MINUS_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_PLUS_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    /*\n     * NOTE: TOK_LOGICAL_AND and TOK_LOGICAL_OR don't need to be here, because\n     * they are just naturally handled by the short-circuit evaluation.\n     * See PARSE_LTR_BINOP() macro in mjs_parser.c.\n     */\n\n    /* clang-format off */\n    case TOK_MINUS_ASSIGN:    op_assign(mjs, TOK_MINUS);    break;\n    case TOK_PLUS_ASSIGN:     op_assign(mjs, TOK_PLUS);     break;\n    case TOK_MUL_ASSIGN:      op_assign(mjs, TOK_MUL);      break;\n    case TOK_DIV_ASSIGN:      op_assign(mjs, TOK_DIV);      break;\n    case TOK_REM_ASSIGN:      op_assign(mjs, TOK_REM);      break;\n    case TOK_AND_ASSIGN:      op_assign(mjs, TOK_AND);      break;\n    case TOK_OR_ASSIGN:       op_assign(mjs, TOK_OR);       break;\n    case TOK_XOR_ASSIGN:      op_assign(mjs, TOK_XOR);      break;\n    case TOK_LSHIFT_ASSIGN:   op_assign(mjs, TOK_LSHIFT);   break;\n    case TOK_RSHIFT_ASSIGN:   op_assign(mjs, TOK_RSHIFT);   break;\n    case TOK_URSHIFT_ASSIGN:  op_assign(mjs, TOK_URSHIFT);  break;\n    case TOK_COMMA: break;\n    /* clang-format on */\n    case TOK_KEYWORD_TYPEOF:\n      mjs_push(mjs, mjs_mk_string(mjs, mjs_typeof(mjs_pop(mjs)), ~0, 1));\n      break;\n    default:\n      LOG(LL_ERROR, (\"Unknown expr: %d\", op));\n      break;\n  }\n}\n\nstatic int getprop_builtin_string(struct mjs *mjs, mjs_val_t val,\n                                  const char *name, size_t name_len,\n                                  mjs_val_t *res) {\n  int isnum = 0;\n  int idx = cstr_to_ulong(name, name_len, &isnum);\n\n  if (strcmp(name, \"length\") == 0) {\n    size_t val_len;\n    mjs_get_string(mjs, &val, &val_len);\n    *res = mjs_mk_number(mjs, (double) val_len);\n    return 1;\n  } else if (strcmp(name, \"at\") == 0 || strcmp(name, \"charCodeAt\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_char_code_at);\n    return 1;\n  } else if (strcmp(name, \"indexOf\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_index_of);\n    return 1;\n  } else if (strcmp(name, \"slice\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_slice);\n    return 1;\n  } else if (isnum) {\n    /*\n     * string subscript: return a new one-byte string if the index\n     * is not out of bounds\n     */\n    size_t val_len;\n    const char *str = mjs_get_string(mjs, &val, &val_len);\n    if (idx >= 0 && idx < (int) val_len) {\n      *res = mjs_mk_string(mjs, str + idx, 1, 1);\n    } else {\n      *res = MJS_UNDEFINED;\n    }\n    return 1;\n  }\n  return 0;\n}\n\nstatic int getprop_builtin_array(struct mjs *mjs, mjs_val_t val,\n                                 const char *name, size_t name_len,\n                                 mjs_val_t *res) {\n  if (strcmp(name, \"splice\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_array_splice);\n    return 1;\n  } else if (strcmp(name, \"push\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_array_push_internal);\n    return 1;\n  } else if (strcmp(name, \"length\") == 0) {\n    *res = mjs_mk_number(mjs, mjs_array_length(mjs, val));\n    return 1;\n  }\n\n  (void) name_len;\n  return 0;\n}\n\nstatic int getprop_builtin_foreign(struct mjs *mjs, mjs_val_t val,\n                                   const char *name, size_t name_len,\n                                   mjs_val_t *res) {\n  int isnum = 0;\n  int idx = cstr_to_ulong(name, name_len, &isnum);\n\n  if (!isnum) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n  } else {\n    uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, val);\n    *res = mjs_mk_number(mjs, *(ptr + idx));\n  }\n  return 1;\n}\n\nstatic void mjs_apply_(struct mjs *mjs) {\n  mjs_val_t res = MJS_UNDEFINED, *args = NULL;\n  mjs_val_t func = mjs->vals.this_obj, v = mjs_arg(mjs, 1);\n  int i, nargs = 0;\n  if (mjs_is_array(v)) {\n    nargs = mjs_array_length(mjs, v);\n    args = calloc(nargs, sizeof(args[0]));\n    for (i = 0; i < nargs; i++) args[i] = mjs_array_get(mjs, v, i);\n  }\n  mjs_apply(mjs, &res, func, mjs_arg(mjs, 0), nargs, args);\n  free(args);\n  mjs_return(mjs, res);\n}\n\nstatic int getprop_builtin(struct mjs *mjs, mjs_val_t val, mjs_val_t name,\n                           mjs_val_t *res) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  int handled = 0;\n\n  mjs_err_t err = mjs_to_string(mjs, &name, &s, &n, &need_free);\n\n  if (err == MJS_OK) {\n    if (mjs_is_string(val)) {\n      handled = getprop_builtin_string(mjs, val, s, n, res);\n    } else if (s != NULL && n == 5 && strncmp(s, \"apply\", n) == 0) {\n      *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_apply_);\n      handled = 1;\n    } else if (mjs_is_array(val)) {\n      handled = getprop_builtin_array(mjs, val, s, n, res);\n    } else if (mjs_is_foreign(val)) {\n      handled = getprop_builtin_foreign(mjs, val, s, n, res);\n    }\n  }\n\n  if (need_free) {\n    free(s);\n    s = NULL;\n  }\n\n  return handled;\n}\n\nMJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res) {\n  size_t i;\n  uint8_t prev_opcode = OP_MAX;\n  uint8_t opcode = OP_MAX;\n\n  /*\n   * remember lengths of all stacks, they will be restored in case of an error\n   */\n  int stack_len = mjs->stack.len;\n  int call_stack_len = mjs->call_stack.len;\n  int arg_stack_len = mjs->arg_stack.len;\n  int scopes_len = mjs->scopes.len;\n  int loop_addresses_len = mjs->loop_addresses.len;\n  size_t start_off = off;\n  const uint8_t *code;\n\n  struct mjs_bcode_part bp = *mjs_bcode_part_get_by_offset(mjs, off);\n\n  mjs_set_errorf(mjs, MJS_OK, NULL);\n  free(mjs->stack_trace);\n  mjs->stack_trace = NULL;\n\n  off -= bp.start_idx;\n\n  for (i = off; i < bp.data.len; i++) {\n    mjs->cur_bcode_offset = i;\n\n    if (mjs->need_gc) {\n      if (maybe_gc(mjs)) {\n        mjs->need_gc = 0;\n      }\n    }\n#if MJS_AGGRESSIVE_GC\n    maybe_gc(mjs);\n#endif\n\n    code = (const uint8_t *) bp.data.p;\n#if MJS_ENABLE_DEBUG\n    mjs_disasm_single(code, i);\n#endif\n    prev_opcode = opcode;\n    opcode = code[i];\n    switch (opcode) {\n      case OP_BCODE_HEADER: {\n        mjs_header_item_t bcode_offset;\n        memcpy(&bcode_offset,\n               code + i + 1 +\n                   sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n               sizeof(bcode_offset));\n        i += bcode_offset;\n      } break;\n      case OP_PUSH_NULL:\n        mjs_push(mjs, mjs_mk_null());\n        break;\n      case OP_PUSH_UNDEF:\n        mjs_push(mjs, mjs_mk_undefined());\n        break;\n      case OP_PUSH_FALSE:\n        mjs_push(mjs, mjs_mk_boolean(mjs, 0));\n        break;\n      case OP_PUSH_TRUE:\n        mjs_push(mjs, mjs_mk_boolean(mjs, 1));\n        break;\n      case OP_PUSH_OBJ:\n        mjs_push(mjs, mjs_mk_object(mjs));\n        break;\n      case OP_PUSH_ARRAY:\n        mjs_push(mjs, mjs_mk_array(mjs));\n        break;\n      case OP_PUSH_FUNC: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_function(mjs, bp.start_idx + i - n));\n        i += llen;\n        break;\n      }\n      case OP_PUSH_THIS:\n        mjs_push(mjs, mjs->vals.this_obj);\n        break;\n      case OP_JMP: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += n + llen;\n        break;\n      }\n      case OP_JMP_FALSE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (!mjs_is_truthy(mjs, mjs_pop(mjs))) {\n          mjs_push(mjs, MJS_UNDEFINED);\n          i += n;\n        }\n        break;\n      }\n      /*\n       * OP_JMP_NEUTRAL_... ops are like as OP_JMP_..., but they are completely\n       * stack-neutral: they just check the TOS, and increment instruction\n       * pointer if the TOS is truthy/falsy.\n       */\n      case OP_JMP_NEUTRAL_TRUE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (mjs_is_truthy(mjs, vtop(&mjs->stack))) {\n          i += n;\n        }\n        break;\n      }\n      case OP_JMP_NEUTRAL_FALSE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (!mjs_is_truthy(mjs, vtop(&mjs->stack))) {\n          i += n;\n        }\n        break;\n      }\n      case OP_FIND_SCOPE: {\n        mjs_val_t key = vtop(&mjs->stack);\n        mjs_push(mjs, mjs_find_scope(mjs, key));\n        break;\n      }\n      case OP_CREATE: {\n        mjs_val_t obj = mjs_pop(mjs);\n        mjs_val_t key = mjs_pop(mjs);\n        if (mjs_get_own_property_v(mjs, obj, key) == NULL) {\n          mjs_set_v(mjs, obj, key, MJS_UNDEFINED);\n        }\n        break;\n      }\n      case OP_APPEND: {\n        mjs_val_t val = mjs_pop(mjs);\n        mjs_val_t arr = mjs_pop(mjs);\n        mjs_err_t err = mjs_array_push(mjs, arr, val);\n        if (err != MJS_OK) {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"append to non-array\");\n        }\n        break;\n      }\n      case OP_GET: {\n        mjs_val_t obj = mjs_pop(mjs);\n        mjs_val_t key = mjs_pop(mjs);\n        mjs_val_t val = MJS_UNDEFINED;\n\n        if (!getprop_builtin(mjs, obj, key, &val)) {\n          if (mjs_is_object(obj)) {\n            val = mjs_get_v_proto(mjs, obj, key);\n          } else {\n            mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"type error\");\n          }\n        }\n\n        mjs_push(mjs, val);\n        if (prev_opcode != OP_FIND_SCOPE) {\n          /*\n           * Previous opcode was not OP_FIND_SCOPE, so it's some \"custom\"\n           * object which might be used as `this`, so, save it\n           */\n          mjs->vals.last_getprop_obj = obj;\n        } else {\n          /*\n           * Previous opcode was OP_FIND_SCOPE, so we're getting value from\n           * the scope, and it should *not* be used as `this`\n           */\n          mjs->vals.last_getprop_obj = MJS_UNDEFINED;\n        }\n        break;\n      }\n      case OP_DEL_SCOPE:\n        if (mjs->scopes.len <= 1) {\n          mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"scopes underflow\");\n        } else {\n          mjs_pop_val(&mjs->scopes);\n        }\n        break;\n      case OP_NEW_SCOPE:\n        push_mjs_val(&mjs->scopes, mjs_mk_object(mjs));\n        break;\n      case OP_PUSH_SCOPE:\n        assert(mjs_stack_size(&mjs->scopes) > 0);\n        mjs_push(mjs, vtop(&mjs->scopes));\n        break;\n      case OP_PUSH_STR: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_string(mjs, (char *) code + i + 1 + llen, n, 1));\n        i += llen + n;\n        break;\n      }\n      case OP_PUSH_INT: {\n        int llen;\n        int64_t n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_number(mjs, (double) n));\n        i += llen;\n        break;\n      }\n      case OP_PUSH_DBL: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_number(\n                          mjs, strtod((char *) code + i + 1 + llen, NULL)));\n        i += llen + n;\n        break;\n      }\n      case OP_FOR_IN_NEXT: {\n        /*\n         * Data stack layout:\n         * ...                                    <-- Bottom of the data stack\n         * <iterator_variable_name>   (string)\n         * <object_that_is_iterated>  (object)\n         * <iterator_foreign_ptr>                 <-- Top of the data stack\n         */\n        mjs_val_t *iterator = vptr(&mjs->stack, -1);\n        mjs_val_t obj = *vptr(&mjs->stack, -2);\n        if (mjs_is_object(obj)) {\n          mjs_val_t var_name = *vptr(&mjs->stack, -3);\n          mjs_val_t key = mjs_next(mjs, obj, iterator);\n          if (key != MJS_UNDEFINED) {\n            mjs_val_t scope = mjs_find_scope(mjs, var_name);\n            mjs_set_v(mjs, scope, var_name, key);\n          }\n        } else {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR,\n                         \"can't iterate over non-object value\");\n        }\n        break;\n      }\n      case OP_RETURN: {\n        /*\n         * Return address is saved as a global bcode offset, so we need to\n         * convert it to the local offset\n         */\n        size_t off_ret = call_stack_restore_frame(mjs);\n        if (off_ret != MJS_BCODE_OFFSET_EXIT) {\n          bp = *mjs_bcode_part_get_by_offset(mjs, off_ret);\n          code = (const uint8_t *) bp.data.p;\n          i = off_ret - bp.start_idx;\n          LOG(LL_VERBOSE_DEBUG, (\"RETURNING TO %d\", (int) off_ret + 1));\n        } else {\n          goto clean;\n        }\n        // mjs_dump(mjs, 0, stdout);\n        break;\n      }\n      case OP_ARGS: {\n        /*\n         * If OP_ARGS follows OP_GET, then last_getprop_obj is set to `this`\n         * value; otherwise, last_getprop_obj is irrelevant and we have to\n         * reset it to `undefined`\n         */\n        if (prev_opcode != OP_GET) {\n          mjs->vals.last_getprop_obj = MJS_UNDEFINED;\n        }\n\n        /*\n         * Push last_getprop_obj, which is going to be used as `this`, see\n         * OP_CALL\n         */\n        push_mjs_val(&mjs->arg_stack, mjs->vals.last_getprop_obj);\n        /*\n         * Push current size of data stack, it's needed to place arguments\n         * properly\n         */\n        push_mjs_val(&mjs->arg_stack,\n                     mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->stack)));\n        break;\n      }\n      case OP_CALL: {\n        // LOG(LL_INFO, (\"BEFORE CALL\"));\n        // mjs_dump(mjs, 0, stdout);\n        int func_pos;\n        mjs_val_t *func;\n        mjs_val_t retval_stack_idx = vtop(&mjs->arg_stack);\n        func_pos = mjs_get_int(mjs, retval_stack_idx) - 1;\n        func = vptr(&mjs->stack, func_pos);\n\n        /* Drop data stack size (pushed by OP_ARGS) */\n        mjs_pop_val(&mjs->arg_stack);\n\n        if (mjs_is_function(*func)) {\n          size_t off_call;\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /*\n           * Function offset is a global bcode offset, so we need to convert it\n           * to the local offset\n           */\n          off_call = mjs_get_func_addr(*func) - 1;\n          bp = *mjs_bcode_part_get_by_offset(mjs, off_call);\n          code = (const uint8_t *) bp.data.p;\n          i = off_call - bp.start_idx;\n\n          *func = MJS_UNDEFINED;  // Return value\n          // LOG(LL_VERBOSE_DEBUG, (\"CALLING  %d\", i + 1));\n        } else if (mjs_is_string(*func) || mjs_is_ffi_sig(*func)) {\n          /* Call ffi-ed function */\n\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /* Perform the ffi-ed function call */\n          mjs_ffi_call2(mjs);\n\n          call_stack_restore_frame(mjs);\n        } else if (mjs_is_foreign(*func)) {\n          /* Call cfunction */\n\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /* Perform the cfunction call */\n          ((void (*) (struct mjs *)) mjs_get_ptr(mjs, *func))(mjs);\n\n          call_stack_restore_frame(mjs);\n        } else {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"calling non-callable\");\n        }\n        break;\n      }\n      case OP_SET_ARG: {\n        int llen1, llen2, n,\n            arg_no = cs_varint_decode_unsafe(&code[i + 1], &llen1);\n        mjs_val_t obj, key, v;\n        n = cs_varint_decode_unsafe(&code[i + llen1 + 1], &llen2);\n        key = mjs_mk_string(mjs, (char *) code + i + 1 + llen1 + llen2, n, 1);\n        obj = vtop(&mjs->scopes);\n        v = mjs_arg(mjs, arg_no);\n        mjs_set_v(mjs, obj, key, v);\n        i += llen1 + llen2 + n;\n        break;\n      }\n      case OP_SETRETVAL: {\n        if (mjs_stack_size(&mjs->call_stack) < CALL_STACK_FRAME_ITEMS_CNT) {\n          mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"cannot return\");\n        } else {\n          size_t retval_pos = mjs_get_int(\n              mjs, *vptr(&mjs->call_stack,\n                         -1 - CALL_STACK_FRAME_ITEM_RETVAL_STACK_IDX));\n          *vptr(&mjs->stack, retval_pos - 1) = mjs_pop(mjs);\n        }\n        // LOG(LL_INFO, (\"AFTER SETRETVAL\"));\n        // mjs_dump(mjs, 0, stdout);\n        break;\n      }\n      case OP_EXPR: {\n        int op = code[i + 1];\n        exec_expr(mjs, op);\n        i++;\n        break;\n      }\n      case OP_DROP: {\n        mjs_pop(mjs);\n        break;\n      }\n      case OP_DUP: {\n        mjs_push(mjs, vtop(&mjs->stack));\n        break;\n      }\n      case OP_SWAP: {\n        mjs_val_t a = mjs_pop(mjs);\n        mjs_val_t b = mjs_pop(mjs);\n        mjs_push(mjs, a);\n        mjs_push(mjs, b);\n        break;\n      }\n      case OP_LOOP: {\n        int l1, l2, off = cs_varint_decode_unsafe(&code[i + 1], &l1);\n        /* push scope index */\n        push_mjs_val(&mjs->loop_addresses,\n                     mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->scopes)));\n\n        /* push break offset */\n        push_mjs_val(\n            &mjs->loop_addresses,\n            mjs_mk_number(mjs, (double) (i + 1 /* OP_LOOP */ + l1 + off)));\n        off = cs_varint_decode_unsafe(&code[i + 1 + l1], &l2);\n\n        /* push continue offset */\n        push_mjs_val(\n            &mjs->loop_addresses,\n            mjs_mk_number(mjs, (double) (i + 1 /* OP_LOOP*/ + l1 + l2 + off)));\n        i += l1 + l2;\n        break;\n      }\n      case OP_CONTINUE: {\n        if (mjs_stack_size(&mjs->loop_addresses) >= 3) {\n          size_t scopes_len = mjs_get_int(mjs, *vptr(&mjs->loop_addresses, -3));\n          assert(mjs_stack_size(&mjs->scopes) >= scopes_len);\n          mjs->scopes.len = scopes_len * sizeof(mjs_val_t);\n\n          /* jump to \"continue\" address */\n          i = mjs_get_int(mjs, vtop(&mjs->loop_addresses)) - 1;\n        } else {\n          mjs_set_errorf(mjs, MJS_SYNTAX_ERROR, \"misplaced 'continue'\");\n        }\n      } break;\n      case OP_BREAK: {\n        if (mjs_stack_size(&mjs->loop_addresses) >= 3) {\n          size_t scopes_len;\n          /* drop \"continue\" address */\n          mjs_pop_val(&mjs->loop_addresses);\n\n          /* pop \"break\" address and jump to it */\n          i = mjs_get_int(mjs, mjs_pop_val(&mjs->loop_addresses)) - 1;\n\n          /* restore scope index */\n          scopes_len = mjs_get_int(mjs, mjs_pop_val(&mjs->loop_addresses));\n          assert(mjs_stack_size(&mjs->scopes) >= scopes_len);\n          mjs->scopes.len = scopes_len * sizeof(mjs_val_t);\n\n          LOG(LL_VERBOSE_DEBUG, (\"BREAKING TO %d\", (int) i + 1));\n        } else {\n          mjs_set_errorf(mjs, MJS_SYNTAX_ERROR, \"misplaced 'break'\");\n        }\n      } break;\n      case OP_NOP:\n        break;\n      case OP_EXIT:\n        i = bp.data.len;\n        break;\n      default:\n#if MJS_ENABLE_DEBUG\n        mjs_dump(mjs, 1);\n#endif\n        mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"Unknown opcode: %d, off %d+%d\",\n                       (int) opcode, (int) bp.start_idx, (int) i);\n        i = bp.data.len;\n        break;\n    }\n    if (mjs->error != MJS_OK) {\n      mjs_gen_stack_trace(mjs, bp.start_idx + i - 1 /* undo the i++ */);\n\n      /* restore stack lenghts */\n      mjs->stack.len = stack_len;\n      mjs->call_stack.len = call_stack_len;\n      mjs->arg_stack.len = arg_stack_len;\n      mjs->scopes.len = scopes_len;\n      mjs->loop_addresses.len = loop_addresses_len;\n\n      /* script will evaluate to `undefined` */\n      mjs_push(mjs, MJS_UNDEFINED);\n      break;\n    }\n  }\n\nclean:\n  /* Remember result of the evaluation of this bcode part */\n  mjs_bcode_part_get_by_offset(mjs, start_off)->exec_res = mjs->error;\n\n  *res = mjs_pop(mjs);\n  return mjs->error;\n}\n\nMJS_PRIVATE mjs_err_t mjs_exec_internal(struct mjs *mjs, const char *path,\n                                        const char *src, int generate_jsc,\n                                        mjs_val_t *res) {\n  size_t off = mjs->bcode_len;\n  mjs_val_t r = MJS_UNDEFINED;\n  mjs->error = mjs_parse(path, src, mjs);\n#if MJS_ENABLE_DEBUG\n  if (cs_log_level >= LL_VERBOSE_DEBUG) mjs_dump(mjs, 1);\n#endif\n  if (generate_jsc == -1) generate_jsc = mjs->generate_jsc;\n  if (mjs->error == MJS_OK) {\n#if MJS_GENERATE_JSC && defined(CS_MMAP)\n    if (generate_jsc && path != NULL) {\n      const char *jsext = \".js\";\n      int basename_len = (int) strlen(path) - strlen(jsext);\n      if (basename_len > 0 && strcmp(path + basename_len, jsext) == 0) {\n        /* source file has a .js extension: create a .jsc counterpart */\n        int rewrite = 1;\n        int read_mmapped = 1;\n\n        /* construct .jsc filename */\n        const char *jscext = \".jsc\";\n        char filename_jsc[basename_len + strlen(jscext) + 1 /* nul-term */];\n        memcpy(filename_jsc, path, basename_len);\n        strcpy(filename_jsc + basename_len, jscext);\n\n        /* get last bcode part */\n        struct mjs_bcode_part *bp =\n            mjs_bcode_part_get(mjs, mjs_bcode_parts_cnt(mjs) - 1);\n\n        /*\n         * before writing .jsc file, check if it already exists and has the\n         * same contents\n         *\n         * TODO(dfrank): probably store crc32 before the bcode data, and only\n         * compare it.\n         */\n        {\n          size_t size;\n          char *data = cs_mmap_file(filename_jsc, &size);\n          if (data != NULL) {\n            if (size == bp->data.len) {\n              if (memcmp(data, bp->data.p, size) == 0) {\n                /* .jsc file is up to date, so don't rewrite it */\n                rewrite = 0;\n              }\n            }\n            munmap(data, size);\n          }\n        }\n\n        /* try to open .jsc file for writing */\n        if (rewrite) {\n          FILE *fp = fopen(filename_jsc, \"wb\");\n          if (fp != NULL) {\n            /* write last bcode part to .jsc */\n            fwrite(bp->data.p, bp->data.len, 1, fp);\n            fclose(fp);\n          } else {\n            LOG(LL_WARN, (\"Failed to open %s for writing\", filename_jsc));\n            read_mmapped = 0;\n          }\n        }\n\n        if (read_mmapped) {\n          /* free RAM buffer with last bcode part */\n          free((void *) bp->data.p);\n\n          /* mmap .jsc file and set last bcode part buffer to it */\n          bp->data.p = cs_mmap_file(filename_jsc, &bp->data.len);\n          bp->in_rom = 1;\n        }\n      }\n    }\n#else\n    (void) generate_jsc;\n#endif\n\n    mjs_execute(mjs, off, &r);\n  }\n  if (res != NULL) *res = r;\n  return mjs->error;\n}\n\nmjs_err_t mjs_exec(struct mjs *mjs, const char *src, mjs_val_t *res) {\n  return mjs_exec_internal(mjs, \"<stdin>\", src, 0 /* generate_jsc */, res);\n}\n\nmjs_err_t mjs_exec_file(struct mjs *mjs, const char *path, mjs_val_t *res) {\n  mjs_err_t error = MJS_FILE_READ_ERROR;\n  mjs_val_t r = MJS_UNDEFINED;\n  size_t size;\n  char *source_code = cs_read_file(path, &size);\n\n  if (source_code == NULL) {\n    error = MJS_FILE_READ_ERROR;\n    mjs_prepend_errorf(mjs, error, \"failed to read file \\\"%s\\\"\", path);\n    goto clean;\n  }\n\n  r = MJS_UNDEFINED;\n  error = mjs_exec_internal(mjs, path, source_code, -1, &r);\n  free(source_code);\n\nclean:\n  if (res != NULL) *res = r;\n  return error;\n}\n\nmjs_err_t mjs_call(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                   mjs_val_t this_val, int nargs, ...) {\n  va_list ap;\n  int i;\n  mjs_err_t ret;\n  mjs_val_t *args = calloc(nargs, sizeof(mjs_val_t));\n  va_start(ap, nargs);\n  for (i = 0; i < nargs; i++) {\n    args[i] = va_arg(ap, mjs_val_t);\n  }\n  va_end(ap);\n\n  ret = mjs_apply(mjs, res, func, this_val, nargs, args);\n\n  free(args);\n  return ret;\n}\n\nmjs_err_t mjs_apply(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                    mjs_val_t this_val, int nargs, mjs_val_t *args) {\n  mjs_val_t r, prev_this_val, retval_stack_idx, *resp;\n  int i;\n\n  if (!mjs_is_function(func) && !mjs_is_foreign(func) &&\n      !mjs_is_ffi_sig(func)) {\n    return mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"calling non-callable\");\n  }\n\n  LOG(LL_VERBOSE_DEBUG, (\"applying func %d\", (int) mjs_get_func_addr(func)));\n\n  prev_this_val = mjs->vals.this_obj;\n\n  /* Push callable which will be later replaced with the return value */\n  mjs_push(mjs, func);\n  resp = vptr(&mjs->stack, -1);\n\n  /* Remember index by which return value should be written */\n  retval_stack_idx = mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->stack));\n\n  // Push all arguments\n  for (i = 0; i < nargs; i++) {\n    mjs_push(mjs, args[i]);\n  }\n\n  /* Push this value to arg_stack, call_stack_push_frame() expects that */\n  push_mjs_val(&mjs->arg_stack, this_val);\n\n  /* Push call stack frame, just like OP_CALL does that */\n  call_stack_push_frame(mjs, MJS_BCODE_OFFSET_EXIT, retval_stack_idx);\n\n  if (mjs_is_foreign(func)) {\n    ((void (*) (struct mjs *)) mjs_get_ptr(mjs, func))(mjs);\n    if (res != NULL) *res = *resp;\n  } else if (mjs_is_ffi_sig(func)) {\n    mjs_ffi_call2(mjs);\n    if (res != NULL) *res = *resp;\n  } else {\n    size_t addr = mjs_get_func_addr(func);\n    mjs_execute(mjs, addr, &r);\n    if (res != NULL) *res = r;\n  }\n\n  /*\n   * If there was an error, we need to restore frame and do the cleanup\n   * which is otherwise done by OP_RETURN\n   */\n  if (mjs->error != MJS_OK) {\n    call_stack_restore_frame(mjs);\n\n    // Pop cell at which the returned value should've been written\n    mjs_pop(mjs);\n  }\n  mjs->vals.this_obj = prev_this_val;\n\n  return mjs->error;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi.c\"\n#endif\n\n/* Amalgamated: #include \"common/mg_str.h\" */\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n/*\n * on linux this is enabled only if __USE_GNU is defined, but we cannot set it\n * because dlfcn could have been included already.\n */\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT NULL\n#endif\n\nstatic ffi_fn_t *get_cb_impl_by_signature(const mjs_ffi_sig_t *sig);\n\n/*\n * Data of the two related arguments: callback function pointer and the\n * userdata for it\n */\nstruct cbdata {\n  /* JS callback function */\n  mjs_val_t func;\n  /* JS userdata */\n  mjs_val_t userdata;\n\n  /* index of the function pointer param */\n  int8_t func_idx;\n  /* index of the userdata param */\n  int8_t userdata_idx;\n};\n\nvoid mjs_set_ffi_resolver(struct mjs *mjs, mjs_ffi_resolver_t *dlsym) {\n  mjs->dlsym = dlsym;\n}\n\nstatic mjs_ffi_ctype_t parse_cval_type(struct mjs *mjs, const char *s,\n                                       const char *e) {\n  struct mg_str ms = MG_NULL_STR;\n  /* Trim leading and trailing whitespace */\n  while (s < e && isspace((int) *s)) s++;\n  while (e > s && isspace((int) e[-1])) e--;\n  ms.p = s;\n  ms.len = e - s;\n  if (mg_vcmp(&ms, \"void\") == 0) {\n    return MJS_FFI_CTYPE_NONE;\n  } else if (mg_vcmp(&ms, \"userdata\") == 0) {\n    return MJS_FFI_CTYPE_USERDATA;\n  } else if (mg_vcmp(&ms, \"int\") == 0) {\n    return MJS_FFI_CTYPE_INT;\n  } else if (mg_vcmp(&ms, \"bool\") == 0) {\n    return MJS_FFI_CTYPE_BOOL;\n  } else if (mg_vcmp(&ms, \"double\") == 0) {\n    return MJS_FFI_CTYPE_DOUBLE;\n  } else if (mg_vcmp(&ms, \"float\") == 0) {\n    return MJS_FFI_CTYPE_FLOAT;\n  } else if (mg_vcmp(&ms, \"char*\") == 0 || mg_vcmp(&ms, \"char *\") == 0) {\n    return MJS_FFI_CTYPE_CHAR_PTR;\n  } else if (mg_vcmp(&ms, \"void*\") == 0 || mg_vcmp(&ms, \"void *\") == 0) {\n    return MJS_FFI_CTYPE_VOID_PTR;\n  } else if (mg_vcmp(&ms, \"struct mg_str\") == 0) {\n    return MJS_FFI_CTYPE_STRUCT_MG_STR;\n  } else if (mg_vcmp(&ms, \"struct mg_str *\") == 0 ||\n             mg_vcmp(&ms, \"struct mg_str*\") == 0) {\n    return MJS_FFI_CTYPE_STRUCT_MG_STR_PTR;\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"failed to parse val type \\\"%.*s\\\"\",\n                       (int) ms.len, ms.p);\n    return MJS_FFI_CTYPE_INVALID;\n  }\n}\n\nstatic const char *find_paren(const char *s, const char *e) {\n  for (; s < e; s++) {\n    if (*s == '(') return s;\n  }\n  return NULL;\n}\n\nstatic const char *find_closing_paren(const char *s, const char *e) {\n  int nesting = 1;\n  while (s < e) {\n    if (*s == '(') {\n      nesting++;\n    } else if (*s == ')') {\n      if (--nesting == 0) break;\n    }\n    s++;\n  }\n  return (s < e ? s : NULL);\n}\n\nMJS_PRIVATE mjs_err_t mjs_parse_ffi_signature(struct mjs *mjs, const char *s,\n                                              int sig_len, mjs_ffi_sig_t *sig,\n                                              enum ffi_sig_type sig_type) {\n  mjs_err_t ret = MJS_OK;\n  int vtidx = 0;\n  const char *cur, *e, *tmp_e, *tmp;\n  struct mg_str rt = MG_NULL_STR, fn = MG_NULL_STR, args = MG_NULL_STR;\n  mjs_ffi_ctype_t val_type = MJS_FFI_CTYPE_INVALID;\n  if (sig_len == ~0) {\n    sig_len = strlen(s);\n  }\n  e = s + sig_len;\n\n  mjs_ffi_sig_init(sig);\n\n  /* Skip leading spaces */\n  for (cur = s; cur < e && isspace((int) *cur); cur++)\n    ;\n\n  /* FInd the first set of parens */\n  tmp_e = find_paren(cur, e);\n  if (tmp_e == NULL || tmp_e - s < 2) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"1\");\n    goto clean;\n  }\n  tmp = find_closing_paren(tmp_e + 1, e);\n  if (tmp == NULL) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"2\");\n    goto clean;\n  }\n\n  /* Now see if we have a second set of parens */\n  args.p = find_paren(tmp + 1, e);\n  if (args.p == NULL) {\n    /* We don't - it's a regular function signature */\n    fn.p = tmp_e - 1;\n    while (fn.p > cur && isspace((int) *fn.p)) fn.p--;\n    while (fn.p > cur && (isalnum((int) *fn.p) || *fn.p == '_')) {\n      fn.p--;\n      fn.len++;\n    }\n    fn.p++;\n    rt.p = cur;\n    rt.len = fn.p - rt.p;\n    /* Stuff inside parens is args */\n    args.p = tmp_e + 1;\n    args.len = tmp - args.p;\n  } else {\n    /* We do - it's a function pointer, like void (*foo)(...).\n     * Stuff inside the first pair of parens is the function name */\n    fn.p = tmp + 1;\n    fn.len = args.p - tmp;\n    rt.p = cur;\n    rt.len = tmp_e - rt.p;\n    args.p++;\n    tmp = find_closing_paren(args.p, e);\n    if (tmp == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"3\");\n      goto clean;\n    }\n    args.len = tmp - args.p;\n    /*\n     * We ignore the name and leave sig->fn NULL here, but it will later be\n     * set to the appropriate callback implementation.\n     */\n    sig->is_callback = 1;\n  }\n\n  val_type = parse_cval_type(mjs, rt.p, rt.p + rt.len);\n  if (val_type == MJS_FFI_CTYPE_INVALID) {\n    ret = mjs->error;\n    goto clean;\n  }\n  mjs_ffi_sig_set_val_type(sig, vtidx++, val_type);\n\n  /* Parse function name {{{ */\n  if (!sig->is_callback) {\n    char buf[100];\n    if (mjs->dlsym == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret,\n                         \"resolver is not set, call mjs_set_ffi_resolver\");\n      goto clean;\n    }\n\n    snprintf(buf, sizeof(buf), \"%.*s\", (int) fn.len, fn.p);\n    sig->fn = (ffi_fn_t *) mjs->dlsym(RTLD_DEFAULT, buf);\n    if (sig->fn == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"dlsym('%s') failed\", buf);\n      goto clean;\n    }\n  } else {\n    tmp_e = strchr(tmp_e, ')');\n    if (tmp_e == NULL) {\n      ret = MJS_TYPE_ERROR;\n      goto clean;\n    }\n  }\n\n  /* Advance cur to the beginning of the arg list */\n  cur = tmp_e = args.p;\n\n  /* Parse all args {{{ */\n  while (tmp_e - args.p < (ptrdiff_t) args.len) {\n    int level = 0; /* nested parens level */\n    int is_fp = 0; /* set to 1 is current arg is a callback function ptr */\n    tmp_e = cur;\n\n    /* Advance tmp_e until the next arg separator */\n    while (*tmp_e && (level > 0 || (*tmp_e != ',' && *tmp_e != ')'))) {\n      switch (*tmp_e) {\n        case '(':\n          level++;\n          /*\n           * only function pointer params can have parens, so, set the flag\n           * that it's going to be a function pointer\n           */\n          is_fp = 1;\n          break;\n        case ')':\n          level--;\n          break;\n      }\n      tmp_e++;\n    }\n\n    if (tmp_e == cur) break;\n\n    /* Parse current arg */\n    if (is_fp) {\n      /* Current argument is a callback function pointer */\n      if (sig->cb_sig != NULL) {\n        /*\n         * We already have parsed some callback argument. Currently we don't\n         * support more than one callback argument, so, return error\n         * TODO(dfrank): probably improve\n         */\n        ret = MJS_TYPE_ERROR;\n        mjs_prepend_errorf(mjs, ret, \"only one callback is allowed\");\n        goto clean;\n      }\n\n      sig->cb_sig = calloc(sizeof(*sig->cb_sig), 1);\n      ret = mjs_parse_ffi_signature(mjs, cur, tmp_e - cur, sig->cb_sig,\n                                    FFI_SIG_CALLBACK);\n      if (ret != MJS_OK) {\n        mjs_ffi_sig_free(sig->cb_sig);\n        free(sig->cb_sig);\n        sig->cb_sig = NULL;\n        goto clean;\n      }\n      val_type = MJS_FFI_CTYPE_CALLBACK;\n    } else {\n      /* Some non-function argument */\n      val_type = parse_cval_type(mjs, cur, tmp_e);\n      if (val_type == MJS_FFI_CTYPE_INVALID) {\n        /* parse_cval_type() has already set error message */\n        ret = MJS_TYPE_ERROR;\n        goto clean;\n      }\n    }\n\n    if (!mjs_ffi_sig_set_val_type(sig, vtidx++, val_type)) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"too many callback args\");\n      goto clean;\n    }\n\n    if (*tmp_e == ',') {\n      /* Advance cur to the next argument */\n      cur = tmp_e + 1;\n      while (*cur == ' ') cur++;\n    } else {\n      /* No more arguments */\n      break;\n    }\n  }\n  /* }}} */\n\n  /* Analyze the results and see if they are obviously wrong */\n  mjs_ffi_sig_validate(mjs, sig, sig_type);\n  if (!sig->is_valid) {\n    ret = MJS_TYPE_ERROR;\n    goto clean;\n  }\n\n  /* If the signature represents a callback, find the suitable implementation */\n  if (sig->is_callback) {\n    sig->fn = get_cb_impl_by_signature(sig);\n    if (sig->fn == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret,\n                         \"the callback signature is valid, but there's \"\n                         \"no existing callback implementation for it\");\n      goto clean;\n    }\n  }\n\nclean:\n  if (ret != MJS_OK) {\n    mjs_prepend_errorf(mjs, ret, \"bad ffi signature: \\\"%.*s\\\"\", sig_len, s);\n    sig->is_valid = 0;\n  }\n  return ret;\n}\n\n/* C callbacks implementation {{{ */\n\n/* An argument or a return value for C callback impl */\nunion ffi_cb_data_val {\n  void *p;\n  uintptr_t w;\n  double d;\n  float f;\n};\n\nstruct ffi_cb_data {\n  union ffi_cb_data_val args[MJS_CB_ARGS_MAX_CNT];\n};\n\nstatic union ffi_cb_data_val ffi_cb_impl_generic(void *param,\n                                                 struct ffi_cb_data *data) {\n  struct mjs_ffi_cb_args *cbargs = (struct mjs_ffi_cb_args *) param;\n  mjs_val_t *args, res = MJS_UNDEFINED;\n  union ffi_cb_data_val ret;\n  int i;\n  struct mjs *mjs = cbargs->mjs;\n  mjs_ffi_ctype_t return_ctype = MJS_FFI_CTYPE_NONE;\n  mjs_err_t err;\n\n  memset(&ret, 0, sizeof(ret));\n  mjs_own(mjs, &res);\n\n  /* There must be at least one argument: a userdata */\n  assert(cbargs->sig.args_cnt > 0);\n\n  /* Create JS arguments */\n  args = calloc(1, sizeof(mjs_val_t) * cbargs->sig.args_cnt);\n  for (i = 0; i < cbargs->sig.args_cnt; i++) {\n    mjs_ffi_ctype_t val_type =\n        cbargs->sig.val_types[i + 1 /* first val_type is return value type */];\n    switch (val_type) {\n      case MJS_FFI_CTYPE_USERDATA:\n        args[i] = cbargs->userdata;\n        break;\n      case MJS_FFI_CTYPE_INT:\n        args[i] = mjs_mk_number(mjs, (double) data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_BOOL:\n        args[i] = mjs_mk_boolean(mjs, !!data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_CHAR_PTR: {\n        const char *s = (char *) data->args[i].w;\n        if (s == NULL) s = \"\";\n        args[i] = mjs_mk_string(mjs, s, ~0, 1);\n        break;\n      }\n      case MJS_FFI_CTYPE_VOID_PTR:\n        args[i] = mjs_mk_foreign(mjs, (void *) data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_DOUBLE:\n        args[i] = mjs_mk_number(mjs, data->args[i].d);\n        break;\n      case MJS_FFI_CTYPE_FLOAT:\n        args[i] = mjs_mk_number(mjs, data->args[i].f);\n        break;\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR: {\n        struct mg_str *s = (struct mg_str *) (void *) data->args[i].w;\n        args[i] = mjs_mk_string(mjs, s->p, s->len, 1);\n        break;\n      }\n      default:\n        /* should never be here */\n        LOG(LL_ERROR, (\"unexpected val type for arg #%d: %d\\n\", i, val_type));\n        abort();\n    }\n  }\n\n  /*\n   * save return ctype outside of `cbargs` before calling the callback, because\n   * callback might call `ffi_cb_free()`, which will effectively invalidate\n   * `cbargs`\n   */\n  return_ctype = cbargs->sig.val_types[0];\n\n  /* Call JS function */\n  LOG(LL_VERBOSE_DEBUG, (\"calling JS callback void-void %d from C\",\n                         mjs_get_int(mjs, cbargs->func)));\n  err = mjs_apply(mjs, &res, cbargs->func, MJS_UNDEFINED, cbargs->sig.args_cnt,\n                  args);\n  /*\n   * cbargs might be invalidated by the callback (if it called ffi_cb_free), so\n   * null it out\n   */\n  cbargs = NULL;\n  if (err != MJS_OK) {\n    /*\n     * There's not much we can do about the error here; let's at least print it\n     */\n    mjs_print_error(mjs, stderr, \"MJS callback error\",\n                    1 /* print_stack_trace */);\n\n    goto clean;\n  }\n\n  /* Get return value, if needed */\n  switch (return_ctype) {\n    case MJS_FFI_CTYPE_NONE:\n      /* do nothing */\n      break;\n    case MJS_FFI_CTYPE_INT:\n      ret.w = mjs_get_int(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      ret.w = mjs_get_bool(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_VOID_PTR:\n      ret.p = mjs_get_ptr(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_DOUBLE:\n      ret.d = mjs_get_double(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      ret.f = (float) mjs_get_double(mjs, res);\n      break;\n    default:\n      /* should never be here */\n      LOG(LL_ERROR, (\"unexpected return val type %d\\n\", return_ctype));\n      abort();\n  }\n\nclean:\n  free(args);\n  mjs_disown(mjs, &res);\n  return ret;\n}\n\nstatic void ffi_init_cb_data_wwww(struct ffi_cb_data *data, uintptr_t w0,\n                                  uintptr_t w1, uintptr_t w2, uintptr_t w3,\n                                  uintptr_t w4, uintptr_t w5) {\n  memset(data, 0, sizeof(*data));\n  data->args[0].w = w0;\n  data->args[1].w = w1;\n  data->args[2].w = w2;\n  data->args[3].w = w3;\n  data->args[4].w = w4;\n  data->args[5].w = w5;\n}\n\nstatic uintptr_t ffi_cb_impl_wpwwwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w0, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwpwwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w1, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwpwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w2, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwpww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w3, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwwpw(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w4, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwwwp(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w5, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wpd(uintptr_t w0, double d1) {\n  struct ffi_cb_data data;\n\n  memset(&data, 0, sizeof(data));\n  data.args[0].w = w0;\n  data.args[1].d = d1;\n\n  return ffi_cb_impl_generic((void *) w0, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wdp(double d0, uintptr_t w1) {\n  struct ffi_cb_data data;\n\n  memset(&data, 0, sizeof(data));\n  data.args[0].d = d0;\n  data.args[1].w = w1;\n\n  return ffi_cb_impl_generic((void *) w1, &data).w;\n}\n/* }}} */\n\nstatic struct mjs_ffi_cb_args **ffi_get_matching(struct mjs_ffi_cb_args **plist,\n                                                 mjs_val_t func,\n                                                 mjs_val_t userdata) {\n  for (; *plist != NULL; plist = &((*plist)->next)) {\n    if ((*plist)->func == func && (*plist)->userdata == userdata) {\n      break;\n    }\n  }\n  return plist;\n}\n\nstatic ffi_fn_t *get_cb_impl_by_signature(const mjs_ffi_sig_t *sig) {\n  if (sig->is_valid) {\n    int i;\n    int double_cnt = 0;\n    int float_cnt = 0;\n    int userdata_idx = 0 /* not a valid value: index 0 means return value */;\n\n    for (i = 1 /*0th item is a return value*/; i < MJS_CB_SIGNATURE_MAX_SIZE;\n         i++) {\n      mjs_ffi_ctype_t type = sig->val_types[i];\n      switch (type) {\n        case MJS_FFI_CTYPE_DOUBLE:\n          double_cnt++;\n          break;\n        case MJS_FFI_CTYPE_FLOAT:\n          float_cnt++;\n          break;\n        case MJS_FFI_CTYPE_USERDATA:\n          assert(userdata_idx == 0); /* Otherwise is_valid should be 0 */\n          userdata_idx = i;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (float_cnt > 0) {\n      /* TODO(dfrank): add support for floats in callbacks */\n      return NULL;\n    }\n\n    assert(userdata_idx > 0); /* Otherwise is_valid should be 0 */\n\n    if (sig->args_cnt <= MJS_CB_ARGS_MAX_CNT) {\n      if (mjs_ffi_is_regular_word_or_void(sig->val_types[0])) {\n        /* Return type is a word or void */\n        switch (double_cnt) {\n          case 0:\n            /* No double arguments */\n            switch (userdata_idx) {\n              case 1:\n                return (ffi_fn_t *) ffi_cb_impl_wpwwwww;\n              case 2:\n                return (ffi_fn_t *) ffi_cb_impl_wwpwwww;\n              case 3:\n                return (ffi_fn_t *) ffi_cb_impl_wwwpwww;\n              case 4:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwpww;\n              case 5:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwwpw;\n              case 6:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwwwp;\n              default:\n                /* should never be here */\n                abort();\n            }\n            break;\n          case 1:\n            /* 1 double argument */\n            switch (userdata_idx) {\n              case 1:\n                return (ffi_fn_t *) ffi_cb_impl_wpd;\n              case 2:\n                return (ffi_fn_t *) ffi_cb_impl_wdp;\n            }\n            break;\n        }\n      }\n    } else {\n      /* Too many arguments for the built-in callback impls */\n      /* TODO(dfrank): add support for custom app-dependent resolver */\n    }\n  }\n\n  return NULL;\n}\n\nMJS_PRIVATE mjs_val_t mjs_ffi_sig_to_value(struct mjs_ffi_sig *psig) {\n  if (psig == NULL) {\n    return MJS_NULL;\n  } else {\n    return mjs_legit_pointer_to_value(psig) | MJS_TAG_FUNCTION_FFI;\n  }\n}\n\nMJS_PRIVATE int mjs_is_ffi_sig(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FUNCTION_FFI;\n}\n\nMJS_PRIVATE struct mjs_ffi_sig *mjs_get_ffi_sig_struct(mjs_val_t v) {\n  struct mjs_ffi_sig *ret = NULL;\n  assert(mjs_is_ffi_sig(v));\n  ret = (struct mjs_ffi_sig *) get_ptr(v);\n  return ret;\n}\n\nMJS_PRIVATE mjs_val_t mjs_mk_ffi_sig(struct mjs *mjs) {\n  struct mjs_ffi_sig *psig = new_ffi_sig(mjs);\n  mjs_ffi_sig_init(psig);\n  return mjs_ffi_sig_to_value(psig);\n}\n\nMJS_PRIVATE void mjs_ffi_sig_destructor(struct mjs *mjs, void *psig) {\n  mjs_ffi_sig_free((mjs_ffi_sig_t *) psig);\n  (void) mjs;\n}\n\nMJS_PRIVATE mjs_err_t mjs_ffi_call(struct mjs *mjs) {\n  mjs_err_t e = MJS_OK;\n  const char *sig_str = NULL;\n  mjs_val_t sig_str_v = mjs_arg(mjs, 0);\n  mjs_val_t ret_v = MJS_UNDEFINED;\n  struct mjs_ffi_sig *psig = mjs_get_ffi_sig_struct(mjs_mk_ffi_sig(mjs));\n  size_t sig_str_len;\n\n  sig_str = mjs_get_string(mjs, &sig_str_v, &sig_str_len);\n  e = mjs_parse_ffi_signature(mjs, sig_str, sig_str_len, psig, FFI_SIG_FUNC);\n  if (e != MJS_OK) goto clean;\n  ret_v = mjs_ffi_sig_to_value(psig);\n\nclean:\n  mjs_return(mjs, ret_v);\n  return e;\n}\n\nMJS_PRIVATE mjs_err_t mjs_ffi_call2(struct mjs *mjs) {\n  mjs_err_t ret = MJS_OK;\n  mjs_ffi_sig_t *psig = NULL;\n  mjs_ffi_ctype_t rtype;\n  mjs_val_t sig_v = *vptr(&mjs->stack, mjs_getretvalpos(mjs));\n\n  int i, nargs;\n  struct ffi_arg res;\n  struct ffi_arg args[FFI_MAX_ARGS_CNT];\n  struct cbdata cbdata;\n\n  /* TODO(dfrank): support multiple callbacks */\n  mjs_val_t resv = mjs_mk_undefined();\n\n  /*\n   * String arguments, needed to support short strings which are packed into\n   * mjs_val_t itself\n   */\n  mjs_val_t argvs[FFI_MAX_ARGS_CNT];\n  struct mg_str argvmgstr[FFI_MAX_ARGS_CNT];\n\n  if (mjs_is_ffi_sig(sig_v)) {\n    psig = mjs_get_ffi_sig_struct(sig_v);\n  } else {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"non-ffi-callable value\");\n    goto clean;\n  }\n\n  memset(&cbdata, 0, sizeof(cbdata));\n  cbdata.func_idx = -1;\n  cbdata.userdata_idx = -1;\n\n  rtype = psig->val_types[0];\n\n  switch (rtype) {\n    case MJS_FFI_CTYPE_DOUBLE:\n      res.ctype = FFI_CTYPE_DOUBLE;\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      res.ctype = FFI_CTYPE_FLOAT;\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      res.ctype = FFI_CTYPE_BOOL;\n      break;\n    case MJS_FFI_CTYPE_USERDATA:\n    case MJS_FFI_CTYPE_INT:\n    case MJS_FFI_CTYPE_CHAR_PTR:\n    case MJS_FFI_CTYPE_VOID_PTR:\n    case MJS_FFI_CTYPE_NONE:\n      res.ctype = FFI_CTYPE_WORD;\n      break;\n\n    case MJS_FFI_CTYPE_INVALID:\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"wrong ffi return type\");\n      goto clean;\n  }\n  res.v.i = 0;\n\n  nargs =\n      mjs_stack_size(&mjs->stack) - mjs_get_int(mjs, vtop(&mjs->call_stack));\n\n  if (nargs != psig->args_cnt) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"got %d actuals, but function takes %d args\",\n                       nargs, psig->args_cnt);\n    goto clean;\n  }\n\n  for (i = 0; i < nargs; i++) {\n    mjs_val_t arg = mjs_arg(mjs, i);\n\n    switch (psig->val_types[1 /* retval type */ + i]) {\n      case MJS_FFI_CTYPE_NONE:\n        /*\n         * Void argument: in any case, it's an error, because if C function\n         * takes no arguments, then the FFI-ed JS function should be called\n         * without any arguments, and thus we'll not face \"void\" here.\n         */\n        ret = MJS_TYPE_ERROR;\n        if (i == 0) {\n          /* FFI signature is correct, but invocation is wrong */\n          mjs_prepend_errorf(mjs, ret, \"ffi-ed function takes no arguments\");\n        } else {\n          /*\n           * FFI signature is wrong: we can't have \"void\" as a non-first\n           * \"argument\"\n           */\n          mjs_prepend_errorf(mjs, ret, \"bad ffi arg #%d type: \\\"void\\\"\", i);\n        }\n\n        goto clean;\n      case MJS_FFI_CTYPE_USERDATA:\n        /* Userdata for the callback */\n        if (cbdata.userdata_idx != -1) {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret, \"two or more userdata args: #%d and %d\",\n                             cbdata.userdata_idx, i);\n\n          goto clean;\n        }\n        cbdata.userdata = arg;\n        cbdata.userdata_idx = i;\n        break;\n      case MJS_FFI_CTYPE_INT: {\n        int intval = 0;\n        if (mjs_is_number(arg)) {\n          intval = mjs_get_int(mjs, arg);\n        } else if (mjs_is_boolean(arg)) {\n          intval = mjs_get_bool(mjs, arg);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not an int (the type idx is: %s)\", i,\n              mjs_typeof(arg));\n        }\n        ffi_set_word(&args[i], intval);\n      } break;\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR: {\n        if (!mjs_is_string(arg)) {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a string (the type idx is: %s)\",\n              i, mjs_typeof(arg));\n          goto clean;\n        }\n        argvs[i] = arg;\n        argvmgstr[i].p = mjs_get_string(mjs, &argvs[i], &argvmgstr[i].len);\n        /*\n         * String argument should be saved separately in order to support\n         * short strings (which are packed into mjs_val_t itself)\n         */\n        ffi_set_ptr(&args[i], (void *) &argvmgstr[i]);\n        break;\n      }\n      case MJS_FFI_CTYPE_BOOL: {\n        int intval = 0;\n        if (mjs_is_number(arg)) {\n          intval = !!mjs_get_int(mjs, arg);\n        } else if (mjs_is_boolean(arg)) {\n          intval = mjs_get_bool(mjs, arg);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a bool (the type idx is: %s)\", i,\n              mjs_typeof(arg));\n        }\n        ffi_set_word(&args[i], intval);\n      } break;\n      case MJS_FFI_CTYPE_DOUBLE:\n        ffi_set_double(&args[i], mjs_get_double(mjs, arg));\n        break;\n      case MJS_FFI_CTYPE_FLOAT:\n        ffi_set_float(&args[i], (float) mjs_get_double(mjs, arg));\n        break;\n      case MJS_FFI_CTYPE_CHAR_PTR: {\n        size_t s;\n        if (mjs_is_string(arg)) {\n          /*\n           * String argument should be saved separately in order to support\n           * short strings (which are packed into mjs_val_t itself)\n           */\n          argvs[i] = arg;\n          ffi_set_ptr(&args[i], (void *) mjs_get_string(mjs, &argvs[i], &s));\n        } else if (mjs_is_null(arg)) {\n          ffi_set_ptr(&args[i], NULL);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a string (the type idx is: %s)\",\n              i, mjs_typeof(arg));\n          goto clean;\n        }\n      } break;\n      case MJS_FFI_CTYPE_VOID_PTR:\n        if (mjs_is_string(arg)) {\n          size_t n;\n          /*\n           * String argument should be saved separately in order to support\n           * short strings (which are packed into mjs_val_t itself)\n           */\n          argvs[i] = arg;\n          ffi_set_ptr(&args[i], (void *) mjs_get_string(mjs, &argvs[i], &n));\n        } else if (mjs_is_foreign(arg)) {\n          ffi_set_ptr(&args[i], (void *) mjs_get_ptr(mjs, arg));\n        } else if (mjs_is_null(arg)) {\n          ffi_set_ptr(&args[i], NULL);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret, \"actual arg #%d is not a ptr\", i);\n          goto clean;\n        }\n        break;\n      case MJS_FFI_CTYPE_CALLBACK:\n        if (mjs_is_function(arg) || mjs_is_foreign(arg) ||\n            mjs_is_ffi_sig(arg)) {\n          /*\n           * Current argument is a callback function pointer: remember the given\n           * JS function and the argument index\n           */\n          cbdata.func = arg;\n          cbdata.func_idx = i;\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret,\n                             \"actual arg #%d is not a function, but %s\", i,\n                             mjs_stringify_type((enum mjs_type) arg));\n          goto clean;\n        }\n        break;\n      case MJS_FFI_CTYPE_INVALID:\n        /* parse_cval_type() has already set a more detailed error */\n        ret = MJS_TYPE_ERROR;\n        mjs_prepend_errorf(mjs, ret, \"wrong arg type\");\n        goto clean;\n      default:\n        abort();\n        break;\n    }\n  }\n\n  if (cbdata.userdata_idx >= 0 && cbdata.func_idx >= 0) {\n    struct mjs_ffi_cb_args *cbargs = NULL;\n    struct mjs_ffi_cb_args **pitem = NULL;\n\n    /* the function takes a callback */\n\n    /*\n     * Get cbargs: either reuse the existing one (if the matching item exists),\n     * or create a new one.\n     */\n    pitem = ffi_get_matching(&mjs->ffi_cb_args, cbdata.func, cbdata.userdata);\n    if (*pitem == NULL) {\n      /* No matching cbargs item; we need to add a new one */\n      cbargs = calloc(1, sizeof(*cbargs));\n      cbargs->mjs = mjs;\n      cbargs->func = cbdata.func;\n      cbargs->userdata = cbdata.userdata;\n      mjs_ffi_sig_copy(&cbargs->sig, psig->cb_sig);\n\n      /* Establish a link to the newly allocated item */\n      *pitem = cbargs;\n    } else {\n      /* Found matching item: reuse it */\n      cbargs = *pitem;\n    }\n\n    {\n      union {\n        ffi_fn_t *fn;\n        void *p;\n      } u;\n      u.fn = psig->cb_sig->fn;\n      ffi_set_ptr(&args[cbdata.func_idx], u.p);\n      ffi_set_ptr(&args[cbdata.userdata_idx], cbargs);\n    }\n  } else if (!(cbdata.userdata_idx == -1 && cbdata.func_idx == -1)) {\n    /*\n     * incomplete signature: it contains either the function pointer or\n     * userdata. It should contain both or none.\n     *\n     * It should be handled in mjs_parse_ffi_signature().\n     */\n    abort();\n  }\n\n  ffi_call(psig->fn, nargs, &res, args);\n\n  switch (rtype) {\n    case MJS_FFI_CTYPE_CHAR_PTR: {\n      const char *s = (const char *) (uintptr_t) res.v.i;\n      if (s != NULL) {\n        resv = mjs_mk_string(mjs, s, ~0, 1);\n      } else {\n        resv = MJS_NULL;\n      }\n      break;\n    }\n    case MJS_FFI_CTYPE_VOID_PTR:\n      resv = mjs_mk_foreign(mjs, (void *) (uintptr_t) res.v.i);\n      break;\n    case MJS_FFI_CTYPE_INT:\n      resv = mjs_mk_number(mjs, (int) res.v.i);\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      resv = mjs_mk_boolean(mjs, !!res.v.i);\n      break;\n    case MJS_FFI_CTYPE_DOUBLE:\n      resv = mjs_mk_number(mjs, res.v.d);\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      resv = mjs_mk_number(mjs, res.v.f);\n      break;\n    default:\n      resv = mjs_mk_undefined();\n      break;\n  }\n\nclean:\n  /*\n   * If there was some error, prepend an error message with the subject\n   * signature\n   */\n  if (ret != MJS_OK) {\n    mjs_prepend_errorf(mjs, ret, \"failed to call FFIed function\");\n    /* TODO(dfrank) stringify mjs_ffi_sig_t in some human-readable format */\n  }\n  mjs_return(mjs, resv);\n\n  return ret;\n}\n\n/*\n * TODO(dfrank): make it return boolean (when booleans are supported), instead\n * of a number\n */\nMJS_PRIVATE void mjs_ffi_cb_free(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_number(mjs, 0);\n  mjs_val_t func = mjs_arg(mjs, 0);\n  mjs_val_t userdata = mjs_arg(mjs, 1);\n\n  if (mjs_is_function(func)) {\n    struct mjs_ffi_cb_args **pitem =\n        ffi_get_matching(&mjs->ffi_cb_args, func, userdata);\n    if (*pitem != NULL) {\n      /* Found matching item: remove it from the linked list, and free */\n      struct mjs_ffi_cb_args *cbargs = *pitem;\n      *pitem = cbargs->next;\n      mjs_ffi_sig_free(&cbargs->sig);\n      free(cbargs);\n      ret = mjs_mk_number(mjs, 1);\n    }\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing argument 'func'\");\n  }\n\n  mjs_return(mjs, ret);\n}\n\nvoid mjs_ffi_args_free_list(struct mjs *mjs) {\n  ffi_cb_args_t *next = mjs->ffi_cb_args;\n\n  while (next != NULL) {\n    ffi_cb_args_t *cur = next;\n    next = next->next;\n    free(cur);\n  }\n}\n\nMJS_PRIVATE void mjs_ffi_sig_init(mjs_ffi_sig_t *sig) {\n  memset(sig, 0, sizeof(*sig));\n}\n\nMJS_PRIVATE void mjs_ffi_sig_copy(mjs_ffi_sig_t *to,\n                                  const mjs_ffi_sig_t *from) {\n  memcpy(to, from, sizeof(*to));\n  if (from->cb_sig != NULL) {\n    to->cb_sig = calloc(sizeof(*to->cb_sig), 1);\n    mjs_ffi_sig_copy(to->cb_sig, from->cb_sig);\n  }\n}\n\nMJS_PRIVATE void mjs_ffi_sig_free(mjs_ffi_sig_t *sig) {\n  if (sig->cb_sig != NULL) {\n    free(sig->cb_sig);\n    sig->cb_sig = NULL;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_sig_set_val_type(mjs_ffi_sig_t *sig, int idx,\n                                         mjs_ffi_ctype_t type) {\n  if (idx < MJS_CB_SIGNATURE_MAX_SIZE) {\n    sig->val_types[idx] = type;\n    return 1;\n  } else {\n    /* Index is too large */\n    return 0;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_sig_validate(struct mjs *mjs, mjs_ffi_sig_t *sig,\n                                     enum ffi_sig_type sig_type) {\n  int ret = 0;\n  int i;\n  int callback_idx = 0;\n  int userdata_idx = 0;\n\n  sig->is_valid = 0;\n\n  switch (sig_type) {\n    case FFI_SIG_FUNC:\n      /* Make sure return type is fine */\n      if (sig->val_types[0] != MJS_FFI_CTYPE_NONE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_INT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_BOOL &&\n          sig->val_types[0] != MJS_FFI_CTYPE_DOUBLE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_FLOAT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_VOID_PTR &&\n          sig->val_types[0] != MJS_FFI_CTYPE_CHAR_PTR) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid return value type\");\n        goto clean;\n      }\n      break;\n    case FFI_SIG_CALLBACK:\n      /* Make sure return type is fine */\n      if (sig->val_types[0] != MJS_FFI_CTYPE_NONE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_INT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_BOOL &&\n          sig->val_types[0] != MJS_FFI_CTYPE_DOUBLE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_FLOAT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_VOID_PTR) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid return value type\");\n        goto clean;\n      }\n  }\n\n  /* Handle argument types */\n  for (i = 1; i < MJS_CB_SIGNATURE_MAX_SIZE; i++) {\n    mjs_ffi_ctype_t type = sig->val_types[i];\n    switch (type) {\n      case MJS_FFI_CTYPE_USERDATA:\n        if (userdata_idx != 0) {\n          /* There must be at most one userdata arg, but we have more */\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"more than one userdata arg: #%d and #%d\",\n                             (userdata_idx - 1), (i - 1));\n          goto clean;\n        }\n        userdata_idx = i;\n        break;\n      case MJS_FFI_CTYPE_CALLBACK:\n        switch (sig_type) {\n          case FFI_SIG_FUNC:\n            break;\n          case FFI_SIG_CALLBACK:\n            mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                               \"callback can't take another callback\");\n            goto clean;\n        }\n        callback_idx = i;\n        break;\n      case MJS_FFI_CTYPE_INT:\n      case MJS_FFI_CTYPE_BOOL:\n      case MJS_FFI_CTYPE_VOID_PTR:\n      case MJS_FFI_CTYPE_CHAR_PTR:\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR:\n      case MJS_FFI_CTYPE_DOUBLE:\n      case MJS_FFI_CTYPE_FLOAT:\n        /* Do nothing */\n        break;\n      case MJS_FFI_CTYPE_NONE:\n        /* No more arguments */\n        goto args_over;\n      default:\n        mjs_prepend_errorf(mjs, MJS_INTERNAL_ERROR, \"invalid ffi_ctype: %d\",\n                           type);\n        goto clean;\n    }\n\n    sig->args_cnt++;\n  }\nargs_over:\n\n  switch (sig_type) {\n    case FFI_SIG_FUNC:\n      if (!((callback_idx > 0 && userdata_idx > 0) ||\n            (callback_idx == 0 && userdata_idx == 0))) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                           \"callback and userdata should be either both \"\n                           \"present or both absent\");\n        goto clean;\n      }\n      break;\n    case FFI_SIG_CALLBACK:\n      if (userdata_idx == 0) {\n        /* No userdata arg */\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"no userdata arg\");\n        goto clean;\n      }\n      break;\n  }\n\n  ret = 1;\n\nclean:\n  if (ret) {\n    sig->is_valid = 1;\n  }\n  return ret;\n}\n\nMJS_PRIVATE int mjs_ffi_is_regular_word(mjs_ffi_ctype_t type) {\n  switch (type) {\n    case MJS_FFI_CTYPE_INT:\n    case MJS_FFI_CTYPE_BOOL:\n      return 1;\n    default:\n      return 0;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_is_regular_word_or_void(mjs_ffi_ctype_t type) {\n  return (type == MJS_FFI_CTYPE_NONE || mjs_ffi_is_regular_word(type));\n}\n\n#ifdef _WIN32\nvoid *dlsym(void *handle, const char *name) {\n  static HANDLE msvcrt_dll;\n  void *sym = NULL;\n  if (msvcrt_dll == NULL) msvcrt_dll = GetModuleHandle(\"msvcrt.dll\");\n  if ((sym = GetProcAddress(GetModuleHandle(NULL), name)) == NULL) {\n    sym = GetProcAddress(msvcrt_dll, name);\n  }\n  return sym;\n}\n#elif !defined(__unix__) && !defined(__APPLE__)\nvoid *dlsym(void *handle, const char *name) {\n  (void) handle;\n  (void) name;\n  return NULL;\n}\n#endif\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc.c\"\n#endif\n\n#include <stdio.h>\n\n/* Amalgamated: #include \"common/cs_varint.h\" */\n/* Amalgamated: #include \"common/mbuf.h\" */\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n\n/*\n * Macros for marking reachable things: use bit 0.\n */\n#define MARK(p) (((struct gc_cell *) (p))->head.word |= 1)\n#define UNMARK(p) (((struct gc_cell *) (p))->head.word &= ~1)\n#define MARKED(p) (((struct gc_cell *) (p))->head.word & 1)\n\n/*\n * Similar to `MARK()` / `UNMARK()` / `MARKED()`, but `.._FREE` counterparts\n * are intended to mark free cells (as opposed to used ones), so they use\n * bit 1.\n */\n#define MARK_FREE(p) (((struct gc_cell *) (p))->head.word |= 2)\n#define UNMARK_FREE(p) (((struct gc_cell *) (p))->head.word &= ~2)\n#define MARKED_FREE(p) (((struct gc_cell *) (p))->head.word & 2)\n\n/*\n * When each arena has that or less free cells, GC will be scheduled\n */\n#define GC_ARENA_CELLS_RESERVE 2\n\nstatic struct gc_block *gc_new_block(struct gc_arena *a, size_t size);\nstatic void gc_free_block(struct gc_block *b);\nstatic void gc_mark_mbuf_pt(struct mjs *mjs, const struct mbuf *mbuf);\n\nMJS_PRIVATE struct mjs_object *new_object(struct mjs *mjs) {\n  return (struct mjs_object *) gc_alloc_cell(mjs, &mjs->object_arena);\n}\n\nMJS_PRIVATE struct mjs_property *new_property(struct mjs *mjs) {\n  return (struct mjs_property *) gc_alloc_cell(mjs, &mjs->property_arena);\n}\n\nMJS_PRIVATE struct mjs_ffi_sig *new_ffi_sig(struct mjs *mjs) {\n  return (struct mjs_ffi_sig *) gc_alloc_cell(mjs, &mjs->ffi_sig_arena);\n}\n\n/* Initializes a new arena. */\nMJS_PRIVATE void gc_arena_init(struct gc_arena *a, size_t cell_size,\n                               size_t initial_size, size_t size_increment) {\n  assert(cell_size >= sizeof(uintptr_t));\n\n  memset(a, 0, sizeof(*a));\n  a->cell_size = cell_size;\n  a->size_increment = size_increment;\n  a->blocks = gc_new_block(a, initial_size);\n}\n\nMJS_PRIVATE void gc_arena_destroy(struct mjs *mjs, struct gc_arena *a) {\n  struct gc_block *b;\n\n  if (a->blocks != NULL) {\n    gc_sweep(mjs, a, 0);\n    for (b = a->blocks; b != NULL;) {\n      struct gc_block *tmp;\n      tmp = b;\n      b = b->next;\n      gc_free_block(tmp);\n    }\n  }\n}\n\nstatic void gc_free_block(struct gc_block *b) {\n  free(b->base);\n  free(b);\n}\n\nstatic struct gc_block *gc_new_block(struct gc_arena *a, size_t size) {\n  struct gc_cell *cur;\n  struct gc_block *b;\n\n  b = (struct gc_block *) calloc(1, sizeof(*b));\n  if (b == NULL) abort();\n\n  b->size = size;\n  b->base = (struct gc_cell *) calloc(a->cell_size, b->size);\n  if (b->base == NULL) abort();\n\n  for (cur = GC_CELL_OP(a, b->base, +, 0);\n       cur < GC_CELL_OP(a, b->base, +, b->size);\n       cur = GC_CELL_OP(a, cur, +, 1)) {\n    cur->head.link = a->free;\n    a->free = cur;\n  }\n\n  return b;\n}\n\n/*\n * Returns whether the given arena has GC_ARENA_CELLS_RESERVE or less free\n * cells\n */\nstatic int gc_arena_is_gc_needed(struct gc_arena *a) {\n  struct gc_cell *r = a->free;\n  int i;\n\n  for (i = 0; i <= GC_ARENA_CELLS_RESERVE; i++, r = r->head.link) {\n    if (r == NULL) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nMJS_PRIVATE int gc_strings_is_gc_needed(struct mjs *mjs) {\n  struct mbuf *m = &mjs->owned_strings;\n  return (double) m->len / (double) m->size > 0.9;\n}\n\nMJS_PRIVATE void *gc_alloc_cell(struct mjs *mjs, struct gc_arena *a) {\n  struct gc_cell *r;\n\n  if (a->free == NULL) {\n    struct gc_block *b = gc_new_block(a, a->size_increment);\n    b->next = a->blocks;\n    a->blocks = b;\n  }\n  r = a->free;\n\n  UNMARK(r);\n\n  a->free = r->head.link;\n\n#if MJS_MEMORY_STATS\n  a->allocations++;\n  a->alive++;\n#endif\n\n  /* Schedule GC if needed */\n  if (gc_arena_is_gc_needed(a)) {\n    mjs->need_gc = 1;\n  }\n\n  /*\n   * TODO(mkm): minor opt possible since most of the fields\n   * are overwritten downstream, but not worth the yak shave time\n   * when fields are added to GC-able structures */\n  memset(r, 0, a->cell_size);\n  return (void *) r;\n}\n\n/*\n * Scans the arena and add all unmarked cells to the free list.\n *\n * Empty blocks get deallocated. The head of the free list will contais cells\n * from the last (oldest) block. Cells will thus be allocated in block order.\n */\nvoid gc_sweep(struct mjs *mjs, struct gc_arena *a, size_t start) {\n  struct gc_block *b;\n  struct gc_cell *cur;\n  struct gc_block **prevp = &a->blocks;\n#if MJS_MEMORY_STATS\n  a->alive = 0;\n#endif\n\n  /*\n   * Before we sweep, we should mark all free cells in a way that is\n   * distinguishable from marked used cells.\n   */\n  {\n    struct gc_cell *next;\n    for (cur = a->free; cur != NULL; cur = next) {\n      next = cur->head.link;\n      MARK_FREE(cur);\n    }\n  }\n\n  /*\n   * We'll rebuild the whole `free` list, so initially we just reset it\n   */\n  a->free = NULL;\n\n  for (b = a->blocks; b != NULL;) {\n    size_t freed_in_block = 0;\n    /*\n     * if it turns out that this block is 100% garbage\n     * we can release the whole block, but the addition\n     * of it's cells to the free list has to be undone.\n     */\n    struct gc_cell *prev_free = a->free;\n\n    for (cur = GC_CELL_OP(a, b->base, +, start);\n         cur < GC_CELL_OP(a, b->base, +, b->size);\n         cur = GC_CELL_OP(a, cur, +, 1)) {\n      if (MARKED(cur)) {\n        /* The cell is used and marked  */\n        UNMARK(cur);\n#if MJS_MEMORY_STATS\n        a->alive++;\n#endif\n      } else {\n        /*\n         * The cell is either:\n         * - free\n         * - garbage that's about to be freed\n         */\n\n        if (MARKED_FREE(cur)) {\n          /* The cell is free, so, just unmark it */\n          UNMARK_FREE(cur);\n        } else {\n          /*\n           * The cell is used and should be freed: call the destructor and\n           * reset the memory\n           */\n          if (a->destructor != NULL) {\n            a->destructor(mjs, cur);\n          }\n          memset(cur, 0, a->cell_size);\n        }\n\n        /* Add this cell to the `free` list */\n        cur->head.link = a->free;\n        a->free = cur;\n        freed_in_block++;\n#if MJS_MEMORY_STATS\n        a->garbage++;\n#endif\n      }\n    }\n\n    /*\n     * don't free the initial block, which is at the tail\n     * because it has a special size aimed at reducing waste\n     * and simplifying initial startup. TODO(mkm): improve\n     * */\n    if (b->next != NULL && freed_in_block == b->size) {\n      *prevp = b->next;\n      gc_free_block(b);\n      b = *prevp;\n      a->free = prev_free;\n    } else {\n      prevp = &b->next;\n      b = b->next;\n    }\n  }\n}\n\n/* Mark an FFI signature */\nstatic void gc_mark_ffi_sig(struct mjs *mjs, mjs_val_t *v) {\n  struct mjs_ffi_sig *psig;\n\n  assert(mjs_is_ffi_sig(*v));\n\n  psig = mjs_get_ffi_sig_struct(*v);\n\n  /*\n   * we treat all object like things like objects but they might be functions,\n   * gc_check_val checks the appropriate arena per actual value type.\n   */\n  if (!gc_check_val(mjs, *v)) {\n    abort();\n  }\n\n  if (MARKED(psig)) return;\n\n  MARK(psig);\n}\n\n/* Mark an object */\nstatic void gc_mark_object(struct mjs *mjs, mjs_val_t *v) {\n  struct mjs_object *obj_base;\n  struct mjs_property *prop;\n  struct mjs_property *next;\n\n  assert(mjs_is_object(*v));\n\n  obj_base = get_object_struct(*v);\n\n  /*\n   * we treat all object like things like objects but they might be functions,\n   * gc_check_val checks the appropriate arena per actual value type.\n   */\n  if (!gc_check_val(mjs, *v)) {\n    abort();\n  }\n\n  if (MARKED(obj_base)) return;\n\n  /* mark object itself, and its properties */\n  for ((prop = obj_base->properties), MARK(obj_base); prop != NULL;\n       prop = next) {\n    if (!gc_check_ptr(&mjs->property_arena, prop)) {\n      abort();\n    }\n\n    gc_mark(mjs, &prop->name);\n    gc_mark(mjs, &prop->value);\n\n    next = prop->next;\n    MARK(prop);\n  }\n\n  /* mark object's prototype */\n  /*\n   * We dropped support for object prototypes in MJS.\n   * If we ever bring it back, don't forget to mark it\n   */\n  /* gc_mark(mjs, mjs_get_proto(mjs, v)); */\n}\n\n/* Mark a string value */\nstatic void gc_mark_string(struct mjs *mjs, mjs_val_t *v) {\n  mjs_val_t h, tmp = 0;\n  char *s;\n\n  /* clang-format off */\n\n  /*\n   * If a value points to an unmarked string we shall:\n   *  1. save the first 6 bytes of the string\n   *     since we need to be able to distinguish real values from\n   *     the saved first 6 bytes of the string, we need to tag the chunk\n   *     as MJS_TAG_STRING_C\n   *  2. encode value's address (v) into the first 6 bytes of the string.\n   *  3. put the saved 8 bytes (tag + chunk) back into the value.\n   *  4. mark the string by putting '\\1' in the NUL terminator of the previous\n   *     string chunk.\n   *\n   * If a value points to an already marked string we shall:\n   *     (0, <6 bytes of a pointer to a mjs_val_t>), hence we have to skip\n   *     the first byte. We tag the value pointer as a MJS_TAG_FOREIGN\n   *     so that it won't be followed during recursive mark.\n   *\n   *  ... the rest is the same\n   *\n   *  Note: 64-bit pointers can be represented with 48-bits\n   */\n\n  /* clang-format on */\n\n  assert((*v & MJS_TAG_MASK) == MJS_TAG_STRING_O);\n\n  s = mjs->owned_strings.buf + gc_string_mjs_val_to_offset(*v);\n  assert(s < mjs->owned_strings.buf + mjs->owned_strings.len);\n  if (s[-1] == '\\0') {\n    memcpy(&tmp, s, sizeof(tmp) - 2);\n    tmp |= MJS_TAG_STRING_C;\n  } else {\n    memcpy(&tmp, s, sizeof(tmp) - 2);\n    tmp |= MJS_TAG_FOREIGN;\n  }\n\n  h = (mjs_val_t)(uintptr_t) v;\n  s[-1] = 1;\n  memcpy(s, &h, sizeof(h) - 2);\n  memcpy(v, &tmp, sizeof(tmp));\n}\n\nMJS_PRIVATE void gc_mark(struct mjs *mjs, mjs_val_t *v) {\n  if (mjs_is_object(*v)) {\n    gc_mark_object(mjs, v);\n  }\n  if (mjs_is_ffi_sig(*v)) {\n    gc_mark_ffi_sig(mjs, v);\n  }\n  if ((*v & MJS_TAG_MASK) == MJS_TAG_STRING_O) {\n    gc_mark_string(mjs, v);\n  }\n}\n\nMJS_PRIVATE uint64_t gc_string_mjs_val_to_offset(mjs_val_t v) {\n  return (((uint64_t)(uintptr_t) get_ptr(v)) & ~MJS_TAG_MASK);\n}\n\nMJS_PRIVATE mjs_val_t gc_string_val_from_offset(uint64_t s) {\n  return s | MJS_TAG_STRING_O;\n}\n\nvoid gc_compact_strings(struct mjs *mjs) {\n  char *p = mjs->owned_strings.buf + 1;\n  uint64_t h, next, head = 1;\n  int len, llen;\n\n  while (p < mjs->owned_strings.buf + mjs->owned_strings.len) {\n    if (p[-1] == '\\1') {\n      /* relocate and update ptrs */\n      h = 0;\n      memcpy(&h, p, sizeof(h) - 2);\n\n      /*\n       * relocate pointers until we find the tail.\n       * The tail is marked with MJS_TAG_STRING_C,\n       * while mjs_val_t link pointers are tagged with MJS_TAG_FOREIGN\n       */\n      for (; (h & MJS_TAG_MASK) != MJS_TAG_STRING_C; h = next) {\n        h &= ~MJS_TAG_MASK;\n        memcpy(&next, (char *) (uintptr_t) h, sizeof(h));\n\n        *(mjs_val_t *) (uintptr_t) h = gc_string_val_from_offset(head);\n      }\n      h &= ~MJS_TAG_MASK;\n\n      /*\n       * the tail contains the first 6 bytes we stole from\n       * the actual string.\n       */\n      len = cs_varint_decode_unsafe((unsigned char *) &h, &llen);\n      len += llen + 1;\n\n      /*\n       * restore the saved 6 bytes\n       * TODO(mkm): think about endianness\n       */\n      memcpy(p, &h, sizeof(h) - 2);\n\n      /*\n       * and relocate the string data by packing it to the left.\n       */\n      memmove(mjs->owned_strings.buf + head, p, len);\n      mjs->owned_strings.buf[head - 1] = 0x0;\n      p += len;\n      head += len;\n    } else {\n      len = cs_varint_decode_unsafe((unsigned char *) p, &llen);\n      len += llen + 1;\n\n      p += len;\n    }\n  }\n\n  mjs->owned_strings.len = head;\n}\n\nMJS_PRIVATE int maybe_gc(struct mjs *mjs) {\n  if (!mjs->inhibit_gc) {\n    mjs_gc(mjs, 0);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n * mark an array of `mjs_val_t` values (*not pointers* to them)\n */\nstatic void gc_mark_val_array(struct mjs *mjs, mjs_val_t *vals, size_t len) {\n  mjs_val_t *vp;\n  for (vp = vals; vp < vals + len; vp++) {\n    gc_mark(mjs, vp);\n  }\n}\n\n/*\n * mark an mbuf containing *pointers* to `mjs_val_t` values\n */\nstatic void gc_mark_mbuf_pt(struct mjs *mjs, const struct mbuf *mbuf) {\n  mjs_val_t **vp;\n  for (vp = (mjs_val_t **) mbuf->buf; (char *) vp < mbuf->buf + mbuf->len;\n       vp++) {\n    gc_mark(mjs, *vp);\n  }\n}\n\n/*\n * mark an mbuf containing `mjs_val_t` values (*not pointers* to them)\n */\nstatic void gc_mark_mbuf_val(struct mjs *mjs, const struct mbuf *mbuf) {\n  gc_mark_val_array(mjs, (mjs_val_t *) mbuf->buf,\n                    mbuf->len / sizeof(mjs_val_t));\n}\n\nstatic void gc_mark_ffi_cbargs_list(struct mjs *mjs, ffi_cb_args_t *cbargs) {\n  for (; cbargs != NULL; cbargs = cbargs->next) {\n    gc_mark(mjs, &cbargs->func);\n    gc_mark(mjs, &cbargs->userdata);\n  }\n}\n\n/* Perform garbage collection */\nvoid mjs_gc(struct mjs *mjs, int full) {\n  gc_mark_val_array(mjs, (mjs_val_t *) &mjs->vals,\n                    sizeof(mjs->vals) / sizeof(mjs_val_t));\n\n  gc_mark_mbuf_pt(mjs, &mjs->owned_values);\n  gc_mark_mbuf_val(mjs, &mjs->scopes);\n  gc_mark_mbuf_val(mjs, &mjs->stack);\n  gc_mark_mbuf_val(mjs, &mjs->call_stack);\n\n  gc_mark_ffi_cbargs_list(mjs, mjs->ffi_cb_args);\n\n  gc_compact_strings(mjs);\n\n  gc_sweep(mjs, &mjs->object_arena, 0);\n  gc_sweep(mjs, &mjs->property_arena, 0);\n  gc_sweep(mjs, &mjs->ffi_sig_arena, 0);\n\n  if (full) {\n    /*\n     * In case of full GC, we also resize strings buffer, but we still leave\n     * some extra space (at most, `_MJS_STRING_BUF_RESERVE`) in order to avoid\n     * frequent reallocations\n     */\n    size_t trimmed_size = mjs->owned_strings.len + _MJS_STRING_BUF_RESERVE;\n    if (trimmed_size < mjs->owned_strings.size) {\n      mbuf_resize(&mjs->owned_strings, trimmed_size);\n    }\n  }\n}\n\nMJS_PRIVATE int gc_check_val(struct mjs *mjs, mjs_val_t v) {\n  if (mjs_is_object(v)) {\n    return gc_check_ptr(&mjs->object_arena, get_object_struct(v));\n  }\n  if (mjs_is_ffi_sig(v)) {\n    return gc_check_ptr(&mjs->ffi_sig_arena, mjs_get_ffi_sig_struct(v));\n  }\n  return 1;\n}\n\nMJS_PRIVATE int gc_check_ptr(const struct gc_arena *a, const void *ptr) {\n  const struct gc_cell *p = (const struct gc_cell *) ptr;\n  struct gc_block *b;\n  for (b = a->blocks; b != NULL; b = b->next) {\n    if (p >= b->base && p < GC_CELL_OP(a, b->base, +, b->size)) {\n      return 1;\n    }\n  }\n  return 0;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_json.c\"\n#endif\n\n/* Amalgamated: #include \"common/str_util.h\" */\n/* Amalgamated: #include \"frozen.h\" */\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n\n#define BUF_LEFT(size, used) (((size_t)(used) < (size)) ? ((size) - (used)) : 0)\n\n/*\n * Returns whether the value of given type should be skipped when generating\n * JSON output\n *\n * So far it always returns 0, but we might add some logic later, if we\n * implement some non-jsonnable objects\n */\nstatic int should_skip_for_json(enum mjs_type type) {\n  int ret;\n  switch (type) {\n    /* All permitted values */\n    case MJS_TYPE_NULL:\n    case MJS_TYPE_BOOLEAN:\n    case MJS_TYPE_NUMBER:\n    case MJS_TYPE_STRING:\n    case MJS_TYPE_OBJECT_GENERIC:\n    case MJS_TYPE_OBJECT_ARRAY:\n      ret = 0;\n      break;\n    default:\n      ret = 1;\n      break;\n  }\n  return ret;\n}\n\nstatic const char *hex_digits = \"0123456789abcdef\";\nstatic char *append_hex(char *buf, char *limit, uint8_t c) {\n  if (buf < limit) *buf++ = 'u';\n  if (buf < limit) *buf++ = '0';\n  if (buf < limit) *buf++ = '0';\n  if (buf < limit) *buf++ = hex_digits[(int) ((c >> 4) % 0xf)];\n  if (buf < limit) *buf++ = hex_digits[(int) (c & 0xf)];\n  return buf;\n}\n\n/*\n * Appends quoted s to buf. Any double quote contained in s will be escaped.\n * Returns the number of characters that would have been added,\n * like snprintf.\n * If size is zero it doesn't output anything but keeps counting.\n */\nstatic int snquote(char *buf, size_t size, const char *s, size_t len) {\n  char *limit = buf + size;\n  const char *end;\n  /*\n   * String single character escape sequence:\n   * http://www.ecma-international.org/ecma-262/6.0/index.html#table-34\n   *\n   * 0x8 -> \\b\n   * 0x9 -> \\t\n   * 0xa -> \\n\n   * 0xb -> \\v\n   * 0xc -> \\f\n   * 0xd -> \\r\n   */\n  const char *specials = \"btnvfr\";\n  size_t i = 0;\n\n  i++;\n  if (buf < limit) *buf++ = '\"';\n\n  for (end = s + len; s < end; s++) {\n    if (*s == '\"' || *s == '\\\\') {\n      i++;\n      if (buf < limit) *buf++ = '\\\\';\n    } else if (*s >= '\\b' && *s <= '\\r') {\n      i += 2;\n      if (buf < limit) *buf++ = '\\\\';\n      if (buf < limit) *buf++ = specials[*s - '\\b'];\n      continue;\n    } else if ((unsigned char) *s < '\\b' || (*s > '\\r' && *s < ' ')) {\n      i += 6 /* \\uXXXX */;\n      if (buf < limit) *buf++ = '\\\\';\n      buf = append_hex(buf, limit, (uint8_t) *s);\n      continue;\n    }\n    i++;\n    if (buf < limit) *buf++ = *s;\n  }\n\n  i++;\n  if (buf < limit) *buf++ = '\"';\n\n  if (buf < limit) {\n    *buf = '\\0';\n  } else if (size != 0) {\n    /*\n     * There is no room for the NULL char, but the size wasn't zero, so we can\n     * safely put NULL in the previous byte\n     */\n    *(buf - 1) = '\\0';\n  }\n  return i;\n}\n\nMJS_PRIVATE mjs_err_t to_json_or_debug(struct mjs *mjs, mjs_val_t v, char *buf,\n                                       size_t size, size_t *res_len,\n                                       uint8_t is_debug) {\n  mjs_val_t el;\n  char *vp;\n  mjs_err_t rcode = MJS_OK;\n  size_t len = 0;\n  /*\n   * TODO(dfrank) : also push all `mjs_val_t`s that are declared below\n   */\n\n  if (size > 0) *buf = '\\0';\n\n  if (!is_debug && should_skip_for_json(mjs_get_type(v))) {\n    goto clean;\n  }\n\n  for (vp = mjs->json_visited_stack.buf;\n       vp < mjs->json_visited_stack.buf + mjs->json_visited_stack.len;\n       vp += sizeof(mjs_val_t)) {\n    if (*(mjs_val_t *) vp == v) {\n      strncpy(buf, \"[Circular]\", size);\n      len = 10;\n      goto clean;\n    }\n  }\n\n  switch (mjs_get_type(v)) {\n    case MJS_TYPE_NULL:\n    case MJS_TYPE_BOOLEAN:\n    case MJS_TYPE_NUMBER:\n    case MJS_TYPE_UNDEFINED:\n    case MJS_TYPE_FOREIGN:\n      /* For those types, regular `mjs_to_string()` works */\n      {\n        /* TODO: refactor: mjs_to_string allocates memory every time */\n        char *p = NULL;\n        int need_free = 0;\n        rcode = mjs_to_string(mjs, &v, &p, &len, &need_free);\n        c_snprintf(buf, size, \"%.*s\", (int) len, p);\n        if (need_free) {\n          free(p);\n        }\n      }\n      goto clean;\n\n    case MJS_TYPE_STRING: {\n      /*\n       * For strings we can't just use `primitive_to_str()`, because we need\n       * quoted value\n       */\n      size_t n;\n      const char *str = mjs_get_string(mjs, &v, &n);\n      len = snquote(buf, size, str, n);\n      goto clean;\n    }\n\n    case MJS_TYPE_OBJECT_FUNCTION:\n    case MJS_TYPE_OBJECT_GENERIC: {\n      char *b = buf;\n      struct mjs_property *prop = NULL;\n      struct mjs_object *o = NULL;\n\n      mbuf_append(&mjs->json_visited_stack, (char *) &v, sizeof(v));\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"{\");\n      o = get_object_struct(v);\n      for (prop = o->properties; prop != NULL; prop = prop->next) {\n        size_t n;\n        const char *s;\n        if (!is_debug && should_skip_for_json(mjs_get_type(prop->value))) {\n          continue;\n        }\n        if (b - buf != 1) { /* Not the first property to be printed */\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \",\");\n        }\n        s = mjs_get_string(mjs, &prop->name, &n);\n        b += c_snprintf(b, BUF_LEFT(size, b - buf), \"\\\"%.*s\\\":\", (int) n, s);\n        {\n          size_t tmp = 0;\n          rcode = to_json_or_debug(mjs, prop->value, b, BUF_LEFT(size, b - buf),\n                                   &tmp, is_debug);\n          if (rcode != MJS_OK) {\n            goto clean_iter;\n          }\n          b += tmp;\n        }\n      }\n\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"}\");\n      mjs->json_visited_stack.len -= sizeof(v);\n\n    clean_iter:\n      len = b - buf;\n      goto clean;\n    }\n    case MJS_TYPE_OBJECT_ARRAY: {\n      int has;\n      char *b = buf;\n      size_t i, alen = mjs_array_length(mjs, v);\n      mbuf_append(&mjs->json_visited_stack, (char *) &v, sizeof(v));\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"[\");\n      for (i = 0; i < alen; i++) {\n        el = mjs_array_get2(mjs, v, i, &has);\n        if (has) {\n          size_t tmp = 0;\n          if (!is_debug && should_skip_for_json(mjs_get_type(el))) {\n            b += c_snprintf(b, BUF_LEFT(size, b - buf), \"null\");\n          } else {\n            rcode = to_json_or_debug(mjs, el, b, BUF_LEFT(size, b - buf), &tmp,\n                                     is_debug);\n            if (rcode != MJS_OK) {\n              goto clean;\n            }\n          }\n          b += tmp;\n        } else {\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \"null\");\n        }\n        if (i != alen - 1) {\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \",\");\n        }\n      }\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"]\");\n      mjs->json_visited_stack.len -= sizeof(v);\n      len = b - buf;\n      goto clean;\n    }\n\n    case MJS_TYPES_CNT:\n      abort();\n  }\n\n  abort();\n\n  len = 0; /* for compilers that don't know about abort() */\n  goto clean;\n\nclean:\n  if (rcode != MJS_OK) {\n    len = 0;\n  }\n  if (res_len != NULL) {\n    *res_len = len;\n  }\n  return rcode;\n}\n\nMJS_PRIVATE mjs_err_t mjs_json_stringify(struct mjs *mjs, mjs_val_t v,\n                                         char *buf, size_t size, char **res) {\n  mjs_err_t rcode = MJS_OK;\n  char *p = buf;\n  size_t len;\n\n  to_json_or_debug(mjs, v, buf, size, &len, 0);\n\n  if (len >= size) {\n    /* Buffer is not large enough. Allocate a bigger one */\n    p = (char *) malloc(len + 1);\n    rcode = mjs_json_stringify(mjs, v, p, len + 1, res);\n    assert(*res == p);\n    goto clean;\n  } else {\n    *res = p;\n    goto clean;\n  }\n\nclean:\n  /*\n   * If we're going to return an error, and we allocated a buffer, then free\n   * it. Otherwise, caller should free it.\n   */\n  if (rcode != MJS_OK && p != buf) {\n    free(p);\n  }\n  return rcode;\n}\n\n/*\n * JSON parsing frame: a separate frame is allocated for each nested\n * object/array during parsing\n */\nstruct json_parse_frame {\n  mjs_val_t val;\n  struct json_parse_frame *up;\n};\n\n/*\n * Context for JSON parsing by means of json_walk()\n */\nstruct json_parse_ctx {\n  struct mjs *mjs;\n  mjs_val_t result;\n  struct json_parse_frame *frame;\n  enum mjs_err rcode;\n};\n\n/* Allocate JSON parse frame */\nstatic struct json_parse_frame *alloc_json_frame(struct json_parse_ctx *ctx,\n                                                 mjs_val_t v) {\n  struct json_parse_frame *frame =\n      (struct json_parse_frame *) calloc(sizeof(struct json_parse_frame), 1);\n  frame->val = v;\n  mjs_own(ctx->mjs, &frame->val);\n  return frame;\n}\n\n/* Free JSON parse frame, return the previous one (which may be NULL) */\nstatic struct json_parse_frame *free_json_frame(\n    struct json_parse_ctx *ctx, struct json_parse_frame *frame) {\n  struct json_parse_frame *up = frame->up;\n  mjs_disown(ctx->mjs, &frame->val);\n  free(frame);\n  return up;\n}\n\n/* Callback for json_walk() */\nstatic void frozen_cb(void *data, const char *name, size_t name_len,\n                      const char *path, const struct json_token *token) {\n  struct json_parse_ctx *ctx = (struct json_parse_ctx *) data;\n  mjs_val_t v = MJS_UNDEFINED;\n\n  (void) path;\n\n  mjs_own(ctx->mjs, &v);\n\n  switch (token->type) {\n    case JSON_TYPE_STRING: {\n      char *dst;\n      if (token->len > 0 && (dst = malloc(token->len)) != NULL) {\n        int len = json_unescape(token->ptr, token->len, dst, token->len);\n        if (len < 0) {\n          mjs_prepend_errorf(ctx->mjs, MJS_TYPE_ERROR, \"invalid JSON string\");\n          break;\n        }\n        v = mjs_mk_string(ctx->mjs, dst, len, 1 /* copy */);\n        free(dst);\n      } else {\n        /*\n         * This branch is for 0-len strings, and for malloc errors\n         * TODO(lsm): on malloc error, propagate the error upstream\n         */\n        v = mjs_mk_string(ctx->mjs, \"\", 0, 1 /* copy */);\n      }\n      break;\n    }\n    case JSON_TYPE_NUMBER:\n      v = mjs_mk_number(ctx->mjs, strtod(token->ptr, NULL));\n      break;\n    case JSON_TYPE_TRUE:\n      v = mjs_mk_boolean(ctx->mjs, 1);\n      break;\n    case JSON_TYPE_FALSE:\n      v = mjs_mk_boolean(ctx->mjs, 0);\n      break;\n    case JSON_TYPE_NULL:\n      v = MJS_NULL;\n      break;\n    case JSON_TYPE_OBJECT_START:\n      v = mjs_mk_object(ctx->mjs);\n      break;\n    case JSON_TYPE_ARRAY_START:\n      v = mjs_mk_array(ctx->mjs);\n      break;\n\n    case JSON_TYPE_OBJECT_END:\n    case JSON_TYPE_ARRAY_END: {\n      /* Object or array has finished: deallocate its frame */\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    } break;\n\n    default:\n      LOG(LL_ERROR, (\"Wrong token type %d\\n\", token->type));\n      break;\n  }\n\n  if (!mjs_is_undefined(v)) {\n    if (name != NULL && name_len != 0) {\n      /* Need to define a property on the current object/array */\n      if (mjs_is_object(ctx->frame->val)) {\n        mjs_set(ctx->mjs, ctx->frame->val, name, name_len, v);\n      } else if (mjs_is_array(ctx->frame->val)) {\n        /*\n         * TODO(dfrank): consult name_len. Currently it's not a problem due to\n         * the implementation details of frozen, but it might change\n         */\n        int idx = (int) strtod(name, NULL);\n        mjs_array_set(ctx->mjs, ctx->frame->val, idx, v);\n      } else {\n        LOG(LL_ERROR, (\"Current value is neither object nor array\\n\"));\n      }\n    } else {\n      /* This is a root value */\n      assert(ctx->frame == NULL);\n\n      /*\n       * This value will also be the overall result of JSON parsing\n       * (it's already owned by the `mjs_alt_json_parse()`)\n       */\n      ctx->result = v;\n    }\n\n    if (token->type == JSON_TYPE_OBJECT_START ||\n        token->type == JSON_TYPE_ARRAY_START) {\n      /* New object or array has just started, so we need to allocate a frame\n       * for it */\n      struct json_parse_frame *new_frame = alloc_json_frame(ctx, v);\n      new_frame->up = ctx->frame;\n      ctx->frame = new_frame;\n    }\n  }\n\n  mjs_disown(ctx->mjs, &v);\n}\n\nMJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len);\n    memcpy(stmp, str, len);\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}\n\nMJS_PRIVATE void mjs_op_json_stringify(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t val = mjs_arg(mjs, 0);\n\n  if (mjs_nargs(mjs) < 1) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing a value to stringify\");\n  } else {\n    char *p = NULL;\n    if (mjs_json_stringify(mjs, val, NULL, 0, &p) == MJS_OK) {\n      ret = mjs_mk_string(mjs, p, ~0, 1 /* copy */);\n      free(p);\n    }\n  }\n\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n\n  if (mjs_is_string(arg0)) {\n    size_t len;\n    const char *str = mjs_get_string(mjs, &arg0, &len);\n    mjs_json_parse(mjs, str, len, &ret);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"string argument required\");\n  }\n\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_main.c\"\n#endif\n\n#ifdef MJS_MAIN\n\n// #include <dlfcn.h>\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nint main(int argc, char *argv[]) {\n  struct mjs *mjs = mjs_create();\n  mjs_val_t res = MJS_UNDEFINED;\n  mjs_err_t err = MJS_OK;\n  int i;\n\n  for (i = 1; i < argc && argv[i][0] == '-' && err == MJS_OK; i++) {\n    if (strcmp(argv[i], \"-l\") == 0 && i + 1 < argc) {\n      cs_log_set_level(atoi(argv[++i]));\n    } else if (strcmp(argv[i], \"-j\") == 0) {\n      mjs_set_generate_jsc(mjs, 1);\n    } else if (strcmp(argv[i], \"-e\") == 0 && i + 1 < argc) {\n      err = mjs_exec(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-f\") == 0 && i + 1 < argc) {\n      err = mjs_exec_file(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n      printf(\"mJS (c) Cesanta, built: \" __DATE__ \"\\n\");\n      printf(\"Usage:\\n\");\n      printf(\"%s [OPTIONS] [js_file ...]\\n\", argv[0]);\n      printf(\"OPTIONS:\\n\");\n      printf(\"  -e string    - Execute JavaScript expression\\n\");\n      printf(\"  -j           - Enable code precompiling to .jsc files\\n\");\n      printf(\"  -f js_file   - Execute code from .js JavaScript file\\n\");\n      printf(\"  -l level     - Set debug level, from 0 to 5\\n\");\n      return EXIT_SUCCESS;\n    } else {\n      fprintf(stderr, \"Unknown flag: [%s]\\n\", argv[i]);\n      return EXIT_FAILURE;\n    }\n  }\n  for (; i < argc && err == MJS_OK; i++) {\n    err = mjs_exec_file(mjs, argv[i], &res);\n  }\n\n  if (err == MJS_OK) {\n    mjs_fprintf(res, mjs, stdout);\n    putchar('\\n');\n  } else {\n    mjs_print_error(mjs, stdout, NULL, 1 /* print_stack_trace */);\n  }\n  mjs_destroy(mjs);\n\n  return EXIT_SUCCESS;\n}\n#endif\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n/* Amalgamated: #include \"common/mg_str.h\" */\n\nMJS_PRIVATE mjs_val_t mjs_object_to_value(struct mjs_object *o) {\n  if (o == NULL) {\n    return MJS_NULL;\n  } else {\n    return mjs_legit_pointer_to_value(o) | MJS_TAG_OBJECT;\n  }\n}\n\nMJS_PRIVATE struct mjs_object *get_object_struct(mjs_val_t v) {\n  struct mjs_object *ret = NULL;\n  if (mjs_is_null(v)) {\n    ret = NULL;\n  } else {\n    assert(mjs_is_object(v));\n    ret = (struct mjs_object *) get_ptr(v);\n  }\n  return ret;\n}\n\nmjs_val_t mjs_mk_object(struct mjs *mjs) {\n  struct mjs_object *o = new_object(mjs);\n  if (o == NULL) {\n    return MJS_NULL;\n  }\n  (void) mjs;\n  o->properties = NULL;\n  return mjs_object_to_value(o);\n}\n\nint mjs_is_object(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_OBJECT ||\n         (v & MJS_TAG_MASK) == MJS_TAG_ARRAY;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property(struct mjs *mjs,\n                                                      mjs_val_t obj,\n                                                      const char *name,\n                                                      size_t len) {\n  struct mjs_property *p;\n  struct mjs_object *o;\n\n  if (!mjs_is_object(obj)) {\n    return NULL;\n  }\n\n  o = get_object_struct(obj);\n\n  if (len <= 5) {\n    mjs_val_t ss = mjs_mk_string(mjs, name, len, 1);\n    for (p = o->properties; p != NULL; p = p->next) {\n      if (p->name == ss) return p;\n    }\n  } else {\n    for (p = o->properties; p != NULL; p = p->next) {\n      if (mjs_strcmp(mjs, &p->name, name, len) == 0) return p;\n    }\n    return p;\n  }\n\n  return NULL;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property_v(struct mjs *mjs,\n                                                        mjs_val_t obj,\n                                                        mjs_val_t key) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  struct mjs_property *p = NULL;\n  mjs_err_t err = mjs_to_string(mjs, &key, &s, &n, &need_free);\n  if (err == MJS_OK) {\n    p = mjs_get_own_property(mjs, obj, s, n);\n  }\n  if (need_free) free(s);\n  return p;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_mk_property(struct mjs *mjs,\n                                                 mjs_val_t name,\n                                                 mjs_val_t value) {\n  struct mjs_property *p = new_property(mjs);\n  p->next = NULL;\n  p->name = name;\n  p->value = value;\n  return p;\n}\n\nmjs_val_t mjs_get(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len) {\n  struct mjs_property *p;\n\n  if (name_len == (size_t) ~0) {\n    name_len = strlen(name);\n  }\n\n  p = mjs_get_own_property(mjs, obj, name, name_len);\n  if (p == NULL) {\n    return MJS_UNDEFINED;\n  } else {\n    return p->value;\n  }\n}\n\nmjs_val_t mjs_get_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  mjs_val_t ret = MJS_UNDEFINED;\n\n  mjs_err_t err = mjs_to_string(mjs, &name, &s, &n, &need_free);\n\n  if (err == MJS_OK) {\n    /* Successfully converted name value to string: get the property */\n    ret = mjs_get(mjs, obj, s, n);\n  }\n\n  if (need_free) {\n    free(s);\n    s = NULL;\n  }\n  return ret;\n}\n\nmjs_val_t mjs_get_v_proto(struct mjs *mjs, mjs_val_t obj, mjs_val_t key) {\n  struct mjs_property *p;\n  mjs_val_t pn = mjs_mk_string(mjs, MJS_PROTO_PROP_NAME, ~0, 1);\n  if ((p = mjs_get_own_property_v(mjs, obj, key)) != NULL) return p->value;\n  if ((p = mjs_get_own_property_v(mjs, obj, pn)) == NULL) return MJS_UNDEFINED;\n  return mjs_get_v_proto(mjs, p->value, key);\n}\n\nmjs_err_t mjs_set(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len, mjs_val_t val) {\n  return mjs_set_internal(mjs, obj, MJS_UNDEFINED, (char *) name, name_len,\n                          val);\n}\n\nmjs_err_t mjs_set_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name,\n                    mjs_val_t val) {\n  return mjs_set_internal(mjs, obj, name, NULL, 0, val);\n}\n\nMJS_PRIVATE mjs_err_t mjs_set_internal(struct mjs *mjs, mjs_val_t obj,\n                                       mjs_val_t name_v, char *name,\n                                       size_t name_len, mjs_val_t val) {\n  mjs_err_t rcode = MJS_OK;\n\n  struct mjs_property *p;\n\n  int need_free = 0;\n\n  if (name == NULL) {\n    /* Pointer was not provided, so obtain one from the name_v. */\n    rcode = mjs_to_string(mjs, &name_v, &name, &name_len, &need_free);\n    if (rcode != MJS_OK) {\n      goto clean;\n    }\n  } else {\n    /*\n     * Pointer was provided, so we ignore name_v. Here we set it to undefined,\n     * and the actual value will be calculated later if needed.\n     */\n    name_v = MJS_UNDEFINED;\n  }\n\n  p = mjs_get_own_property(mjs, obj, name, name_len);\n\n  if (p == NULL) {\n    struct mjs_object *o;\n    if (!mjs_is_object(obj)) {\n      return MJS_REFERENCE_ERROR;\n    }\n\n    /*\n     * name_v might be not a string here. In this case, we need to create a new\n     * `name_v`, which will be a string.\n     */\n    if (!mjs_is_string(name_v)) {\n      name_v = mjs_mk_string(mjs, name, name_len, 1);\n    }\n\n    p = mjs_mk_property(mjs, name_v, val);\n\n    o = get_object_struct(obj);\n    p->next = o->properties;\n    o->properties = p;\n  }\n\n  p->value = val;\n\nclean:\n  if (need_free) {\n    free(name);\n    name = NULL;\n  }\n  return rcode;\n}\n\nMJS_PRIVATE void mjs_destroy_property(struct mjs_property **p) {\n  *p = NULL;\n}\n\n/*\n * See comments in `object_public.h`\n */\nint mjs_del(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len) {\n  struct mjs_property *prop, *prev;\n\n  if (!mjs_is_object(obj)) {\n    return -1;\n  }\n  if (len == (size_t) ~0) {\n    len = strlen(name);\n  }\n  for (prev = NULL, prop = get_object_struct(obj)->properties; prop != NULL;\n       prev = prop, prop = prop->next) {\n    size_t n;\n    const char *s = mjs_get_string(mjs, &prop->name, &n);\n    if (n == len && strncmp(s, name, len) == 0) {\n      if (prev) {\n        prev->next = prop->next;\n      } else {\n        get_object_struct(obj)->properties = prop->next;\n      }\n      mjs_destroy_property(&prop);\n      return 0;\n    }\n  }\n  return -1;\n}\n\nmjs_val_t mjs_next(struct mjs *mjs, mjs_val_t obj, mjs_val_t *iterator) {\n  struct mjs_property *p = NULL;\n  mjs_val_t key = MJS_UNDEFINED;\n\n  if (*iterator == MJS_UNDEFINED) {\n    struct mjs_object *o = get_object_struct(obj);\n    p = o->properties;\n  } else {\n    p = ((struct mjs_property *) get_ptr(*iterator))->next;\n  }\n\n  if (p == NULL) {\n    *iterator = MJS_UNDEFINED;\n  } else {\n    key = p->name;\n    *iterator = mjs_mk_foreign(mjs, p);\n  }\n\n  return key;\n}\n\nMJS_PRIVATE void mjs_op_create_object(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t proto_v = mjs_arg(mjs, 0);\n\n  if (!mjs_check_arg(mjs, 0, \"proto\", MJS_TYPE_OBJECT_GENERIC, &proto_v)) {\n    goto clean;\n  }\n\n  ret = mjs_mk_object(mjs);\n  mjs_set(mjs, ret, MJS_PROTO_PROP_NAME, ~0, proto_v);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nmjs_val_t mjs_struct_to_obj(struct mjs *mjs, const void *base,\n                            const struct mjs_c_struct_member *defs) {\n  mjs_val_t obj;\n  const struct mjs_c_struct_member *def = defs;\n  if (base == NULL || def == NULL) return MJS_UNDEFINED;\n  obj = mjs_mk_object(mjs);\n  /* Pin the object while it is being built */\n  mjs_own(mjs, &obj);\n  /*\n   * Because mjs inserts new properties at the head of the list,\n   * start from the end so the constructed object more closely resembles\n   * the definition.\n   */\n  while (def->name != NULL) def++;\n  for (def--; def >= defs; def--) {\n    mjs_val_t v = MJS_UNDEFINED;\n    const char *ptr = (const char *) base + def->offset;\n    switch (def->type) {\n      case MJS_STRUCT_FIELD_TYPE_STRUCT: {\n        const void *sub_base = (const void *) ptr;\n        const struct mjs_c_struct_member *sub_def =\n            (const struct mjs_c_struct_member *) def->arg;\n        v = mjs_struct_to_obj(mjs, sub_base, sub_def);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_STRUCT_PTR: {\n        const void **sub_base = (const void **) ptr;\n        const struct mjs_c_struct_member *sub_def =\n            (const struct mjs_c_struct_member *) def->arg;\n        if (*sub_base != NULL) {\n          v = mjs_struct_to_obj(mjs, *sub_base, sub_def);\n        } else {\n          v = MJS_NULL;\n        }\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT: {\n        double value = (double) (*(int *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_BOOL: {\n        v = mjs_mk_boolean(mjs, *(bool *) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_DOUBLE: {\n        v = mjs_mk_number(mjs, *(double *) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_FLOAT: {\n        float value = *(float *) ptr;\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_CHAR_PTR: {\n        const char *value = *(const char **) ptr;\n        v = mjs_mk_string(mjs, value, ~0, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_VOID_PTR: {\n        v = mjs_mk_foreign(mjs, *(void **) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_MG_STR_PTR: {\n        const struct mg_str *s = *(const struct mg_str **) ptr;\n        if (s != NULL) {\n          v = mjs_mk_string(mjs, s->p, s->len, 1);\n        } else {\n          v = MJS_NULL;\n        }\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_MG_STR: {\n        const struct mg_str *s = (const struct mg_str *) ptr;\n        v = mjs_mk_string(mjs, s->p, s->len, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_DATA: {\n        const char *dptr = (const char *) ptr;\n        const intptr_t dlen = (intptr_t) def->arg;\n        v = mjs_mk_string(mjs, dptr, dlen, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT8: {\n        double value = (double) (*(int8_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT16: {\n        double value = (double) (*(int16_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_UINT8: {\n        double value = (double) (*(uint8_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_UINT16: {\n        double value = (double) (*(uint16_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_CUSTOM: {\n        mjs_val_t (*fptr)(struct mjs *, const void *) =\n            (mjs_val_t (*) (struct mjs *, const void *)) def->arg;\n        v = fptr(mjs, ptr);\n      }\n      default: { break; }\n    }\n    mjs_set(mjs, obj, def->name, ~0, v);\n  }\n  mjs_disown(mjs, &obj);\n  return obj;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_parser.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_varint.h\" */\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_parser.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\n#ifndef MAX_TOKS_IN_EXPR\n#define MAX_TOKS_IN_EXPR 40\n#endif\n\n#define FAIL_ERR(p, code)                                                      \\\n  do {                                                                         \\\n    mjs_set_errorf(p->mjs, code, \"parse error at line %d: [%.*s]\", p->line_no, \\\n                   10, p->tok.ptr);                                            \\\n    return code;                                                               \\\n  } while (0)\n\n#define pnext1(p)                                    \\\n  do {                                               \\\n    LOG(LL_VERBOSE_DEBUG, (\"  PNEXT %d\", __LINE__)); \\\n    pnext(p);                                        \\\n  } while (0)\n\n#define SYNTAX_ERROR(p) FAIL_ERR(p, MJS_SYNTAX_ERROR)\n#undef EXPECT\n#define EXPECT(p, t)       \\\n  if ((p)->tok.tok != (t)) \\\n    SYNTAX_ERROR(p);       \\\n  else                     \\\n    pnext1(p);\n\nstatic mjs_err_t parse_statement(struct pstate *p);\nstatic mjs_err_t parse_expr(struct pstate *p);\n\nstatic int ptest(struct pstate *p) {\n  struct pstate saved = *p;\n  int tok = pnext(p);\n  *p = saved;\n  return tok;\n}\n\nstatic int s_unary_ops[] = {TOK_NOT, TOK_TILDA, TOK_PLUS_PLUS, TOK_MINUS_MINUS,\n                            TOK_KEYWORD_TYPEOF, TOK_MINUS, TOK_PLUS, TOK_EOF};\nstatic int s_comparison_ops[] = {TOK_LT, TOK_LE, TOK_GT, TOK_GE, TOK_EOF};\nstatic int s_postfix_ops[] = {TOK_PLUS_PLUS, TOK_MINUS_MINUS, TOK_EOF};\nstatic int s_equality_ops[] = {TOK_EQ, TOK_NE, TOK_EQ_EQ, TOK_NE_NE, TOK_EOF};\nstatic int s_assign_ops[] = {\n    TOK_ASSIGN,         TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN,  TOK_MUL_ASSIGN,\n    TOK_DIV_ASSIGN,     TOK_REM_ASSIGN,  TOK_LSHIFT_ASSIGN, TOK_RSHIFT_ASSIGN,\n    TOK_URSHIFT_ASSIGN, TOK_AND_ASSIGN,  TOK_XOR_ASSIGN,    TOK_OR_ASSIGN,\n    TOK_EOF};\n\nstatic int findtok(int *toks, int tok) {\n  int i = 0;\n  while (tok != toks[i] && toks[i] != TOK_EOF) i++;\n  return toks[i];\n}\n\nstatic void emit_op(struct pstate *pstate, int tok) {\n  assert(tok >= 0 && tok <= 255);\n  emit_byte(pstate, OP_EXPR);\n  emit_byte(pstate, (uint8_t) tok);\n}\n\n#define BINOP_STACK_FRAME_SIZE 16\n#define STACK_LIMIT 8192\n\n// Intentionally left as macro rather than a function, to let the\n// compiler to inline calls and mimimize runtime stack usage.\n#define PARSE_LTR_BINOP(p, f1, f2, ops, prev_op)                               \\\n  do {                                                                         \\\n    mjs_err_t res = MJS_OK;                                                    \\\n    p->depth++;                                                                \\\n    if (p->depth > (STACK_LIMIT / BINOP_STACK_FRAME_SIZE)) {                   \\\n      mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"parser stack overflow\");       \\\n      res = MJS_SYNTAX_ERROR;                                                  \\\n      goto binop_clean;                                                        \\\n    }                                                                          \\\n    if ((res = f1(p, TOK_EOF)) != MJS_OK) goto binop_clean;                    \\\n    if (prev_op != TOK_EOF) emit_op(p, prev_op);                               \\\n    if (findtok(ops, p->tok.tok) != TOK_EOF) {                                 \\\n      int op = p->tok.tok;                                                     \\\n      size_t off_if = 0;                                                       \\\n      /* For AND/OR, implement short-circuit evaluation */                     \\\n      if (ops[0] == TOK_LOGICAL_AND || ops[0] == TOK_LOGICAL_OR) {             \\\n        emit_byte(p,                                                           \\\n                  (uint8_t)(ops[0] == TOK_LOGICAL_AND ? OP_JMP_NEUTRAL_FALSE   \\\n                                                      : OP_JMP_NEUTRAL_TRUE)); \\\n        off_if = p->cur_idx;                                                   \\\n        emit_init_offset(p);                                                   \\\n        /* No need to emit TOK_LOGICAL_AND and TOK_LOGICAL_OR: */              \\\n        /* Just drop the first value, and evaluate the second one. */          \\\n        emit_byte(p, (uint8_t) OP_DROP);                                       \\\n        op = TOK_EOF;                                                          \\\n      }                                                                        \\\n      pnext1(p);                                                               \\\n      if ((res = f2(p, op)) != MJS_OK) goto binop_clean;                       \\\n                                                                               \\\n      if (off_if != 0) {                                                       \\\n        mjs_bcode_insert_offset(p, p->mjs, off_if,                             \\\n                                p->cur_idx - off_if - MJS_INIT_OFFSET_SIZE);   \\\n      }                                                                        \\\n    }                                                                          \\\n  binop_clean:                                                                 \\\n    p->depth--;                                                                \\\n    return res;                                                                \\\n  } while (0)\n\n#define PARSE_RTL_BINOP(p, f1, f2, ops, prev_op)        \\\n  do {                                                  \\\n    mjs_err_t res = MJS_OK;                             \\\n    (void) prev_op;                                     \\\n    if ((res = f1(p, TOK_EOF)) != MJS_OK) return res;   \\\n    if (findtok(ops, p->tok.tok) != TOK_EOF) {          \\\n      int op = p->tok.tok;                              \\\n      pnext1(p);                                        \\\n      if ((res = f2(p, TOK_EOF)) != MJS_OK) return res; \\\n      emit_op(p, op);                                   \\\n    }                                                   \\\n    return res;                                         \\\n  } while (0)\n\n#if MJS_INIT_OFFSET_SIZE > 0\nstatic void emit_init_offset(struct pstate *p) {\n  size_t i;\n  for (i = 0; i < MJS_INIT_OFFSET_SIZE; i++) {\n    emit_byte(p, 0);\n  }\n}\n#else\nstatic void emit_init_offset(struct pstate *p) {\n  (void) p;\n}\n#endif\n\nstatic mjs_err_t parse_statement_list(struct pstate *p, int et) {\n  mjs_err_t res = MJS_OK;\n  int drop = 0;\n  pnext1(p);\n  while (res == MJS_OK && p->tok.tok != TOK_EOF && p->tok.tok != et) {\n    if (drop) emit_byte(p, OP_DROP);\n    res = parse_statement(p);\n    drop = 1;\n    while (p->tok.tok == TOK_SEMICOLON) pnext1(p);\n  }\n\n  /*\n   * Client code expects statement list to contain a value, so if the statement\n   * list was empty, push `undefined`.\n   */\n  if (!drop) {\n    emit_byte(p, OP_PUSH_UNDEF);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_block(struct pstate *p, int mkscope) {\n  mjs_err_t res = MJS_OK;\n  p->depth++;\n  if (p->depth > (STACK_LIMIT / BINOP_STACK_FRAME_SIZE)) {\n    mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"parser stack overflow\");\n    res = MJS_SYNTAX_ERROR;\n    return res;\n  }\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  if (mkscope) emit_byte(p, OP_NEW_SCOPE);\n  res = parse_statement_list(p, TOK_CLOSE_CURLY);\n  EXPECT(p, TOK_CLOSE_CURLY);\n  if (mkscope) emit_byte(p, OP_DEL_SCOPE);\n  return res;\n}\n\nstatic mjs_err_t parse_function(struct pstate *p) {\n  size_t prologue, off;\n  int arg_no = 0;\n  int name_provided = 0;\n  mjs_err_t res = MJS_OK;\n\n  EXPECT(p, TOK_KEYWORD_FUNCTION);\n\n  if (p->tok.tok == TOK_IDENT) {\n    /* Function name was provided */\n    struct tok tmp = p->tok;\n    name_provided = 1;\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_FIND_SCOPE);\n    pnext1(p);\n  }\n\n  emit_byte(p, OP_JMP);\n  off = p->cur_idx;\n  emit_init_offset(p);\n\n  prologue = p->cur_idx;\n\n  EXPECT(p, TOK_OPEN_PAREN);\n  emit_byte(p, OP_NEW_SCOPE);\n  // Emit names of function arguments\n  while (p->tok.tok != TOK_CLOSE_PAREN) {\n    if (p->tok.tok != TOK_IDENT) SYNTAX_ERROR(p);\n    emit_byte(p, OP_SET_ARG);\n    emit_int(p, arg_no);\n    arg_no++;\n    emit_str(p, p->tok.ptr, p->tok.len);\n    if (ptest(p) == TOK_COMMA) pnext1(p);\n    pnext1(p);\n  }\n  EXPECT(p, TOK_CLOSE_PAREN);\n  if ((res = parse_block(p, 0)) != MJS_OK) return res;\n  emit_byte(p, OP_RETURN);\n  prologue += mjs_bcode_insert_offset(p, p->mjs, off,\n                                      p->cur_idx - off - MJS_INIT_OFFSET_SIZE);\n  emit_byte(p, OP_PUSH_FUNC);\n  emit_int(p, p->cur_idx - 1 /* OP_PUSH_FUNC */ - prologue);\n  if (name_provided) {\n    emit_op(p, TOK_ASSIGN);\n  }\n\n  return res;\n}\n\nstatic mjs_err_t parse_object_literal(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  EXPECT(p, TOK_OPEN_CURLY);\n  emit_byte(p, OP_PUSH_OBJ);\n  while (p->tok.tok != TOK_CLOSE_CURLY) {\n    if (p->tok.tok != TOK_IDENT && p->tok.tok != TOK_STR) SYNTAX_ERROR(p);\n    emit_byte(p, OP_DUP);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, p->tok.ptr, p->tok.len);\n    emit_byte(p, OP_SWAP);\n    pnext1(p);\n    EXPECT(p, TOK_COLON);\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n    emit_op(p, TOK_ASSIGN);\n    emit_byte(p, OP_DROP);\n    if (p->tok.tok == TOK_COMMA) {\n      pnext1(p);\n    } else if (p->tok.tok != TOK_CLOSE_CURLY) {\n      SYNTAX_ERROR(p);\n    }\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_array_literal(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  EXPECT(p, TOK_OPEN_BRACKET);\n  emit_byte(p, OP_PUSH_ARRAY);\n  while (p->tok.tok != TOK_CLOSE_BRACKET) {\n    emit_byte(p, OP_DUP);\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n    emit_byte(p, OP_APPEND);\n    if (p->tok.tok == TOK_COMMA) pnext1(p);\n  }\n  return res;\n}\n\nstatic enum mjs_err parse_literal(struct pstate *p, const struct tok *t) {\n  struct mbuf *bcode_gen = &p->mjs->bcode_gen;\n  enum mjs_err res = MJS_OK;\n  int tok = t->tok;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s] %p\", p->tok.len, p->tok.ptr, (void *) &t));\n  switch (t->tok) {\n    case TOK_KEYWORD_FALSE:\n      emit_byte(p, OP_PUSH_FALSE);\n      break;\n    case TOK_KEYWORD_TRUE:\n      emit_byte(p, OP_PUSH_TRUE);\n      break;\n    case TOK_KEYWORD_UNDEFINED:\n      emit_byte(p, OP_PUSH_UNDEF);\n      break;\n    case TOK_KEYWORD_NULL:\n      emit_byte(p, OP_PUSH_NULL);\n      break;\n    case TOK_IDENT: {\n      int prev_tok = p->prev_tok;\n      int next_tok = ptest(p);\n      emit_byte(p, OP_PUSH_STR);\n      emit_str(p, t->ptr, t->len);\n      emit_byte(p, (uint8_t)(prev_tok == TOK_DOT ? OP_SWAP : OP_FIND_SCOPE));\n      if (!findtok(s_assign_ops, next_tok) &&\n          !findtok(s_postfix_ops, next_tok) &&\n          /* TODO(dfrank): fix: it doesn't work for prefix ops */\n          !findtok(s_postfix_ops, prev_tok)) {\n        emit_byte(p, OP_GET);\n      }\n      break;\n    }\n    case TOK_NUM: {\n      double iv, d = strtod(t->ptr, NULL);\n      unsigned long uv = strtoul(t->ptr + 2, NULL, 16);\n      if (t->ptr[0] == '0' && t->ptr[1] == 'x') d = uv;\n      if (modf(d, &iv) == 0) {\n        emit_byte(p, OP_PUSH_INT);\n        emit_int(p, (int64_t) d);\n      } else {\n        emit_byte(p, OP_PUSH_DBL);\n        emit_str(p, t->ptr, t->len);\n      }\n      break;\n    }\n    case TOK_STR: {\n      size_t oldlen;\n      emit_byte(p, OP_PUSH_STR);\n      oldlen = bcode_gen->len;\n      embed_string(bcode_gen, p->cur_idx, t->ptr, t->len, EMBSTR_UNESCAPE);\n      p->cur_idx += bcode_gen->len - oldlen;\n    } break;\n    case TOK_OPEN_BRACKET:\n      res = parse_array_literal(p);\n      break;\n    case TOK_OPEN_CURLY:\n      res = parse_object_literal(p);\n      break;\n    case TOK_OPEN_PAREN:\n      pnext1(p);\n      res = parse_expr(p);\n      if (p->tok.tok != TOK_CLOSE_PAREN) SYNTAX_ERROR(p);\n      break;\n    case TOK_KEYWORD_FUNCTION:\n      res = parse_function(p);\n      break;\n    case TOK_KEYWORD_THIS:\n      emit_byte(p, OP_PUSH_THIS);\n      break;\n    default:\n      SYNTAX_ERROR(p);\n  }\n  if (tok != TOK_KEYWORD_FUNCTION) pnext1(p);\n  return res;\n}\n\nstatic mjs_err_t parse_call_dot_mem(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_DOT, TOK_OPEN_PAREN, TOK_OPEN_BRACKET, TOK_EOF};\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_literal(p, &p->tok)) != MJS_OK) return res;\n  while (findtok(ops, p->tok.tok) != TOK_EOF) {\n    if (p->tok.tok == TOK_OPEN_BRACKET) {\n      int prev_tok = p->prev_tok;\n      EXPECT(p, TOK_OPEN_BRACKET);\n      if ((res = parse_expr(p)) != MJS_OK) return res;\n      emit_byte(p, OP_SWAP);\n      EXPECT(p, TOK_CLOSE_BRACKET);\n      if (!findtok(s_assign_ops, p->tok.tok) &&\n          !findtok(s_postfix_ops, p->tok.tok) &&\n          /* TODO(dfrank): fix: it doesn't work for prefix ops */\n          !findtok(s_postfix_ops, prev_tok)) {\n        emit_byte(p, OP_GET);\n      }\n    } else if (p->tok.tok == TOK_OPEN_PAREN) {\n      EXPECT(p, TOK_OPEN_PAREN);\n      emit_byte(p, OP_ARGS);\n      while (p->tok.tok != TOK_CLOSE_PAREN) {\n        if ((res = parse_expr(p)) != MJS_OK) return res;\n        if (p->tok.tok == TOK_COMMA) pnext1(p);\n      }\n      emit_byte(p, OP_CALL);\n      EXPECT(p, TOK_CLOSE_PAREN);\n    } else if (p->tok.tok == TOK_DOT) {\n      EXPECT(p, TOK_DOT);\n      if ((res = parse_call_dot_mem(p, TOK_DOT)) != MJS_OK) return res;\n    }\n  }\n  (void) prev_op;\n  return res;\n}\n\nstatic mjs_err_t parse_postfix(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_call_dot_mem(p, prev_op)) != MJS_OK) return res;\n  if (p->tok.tok == TOK_PLUS_PLUS || p->tok.tok == TOK_MINUS_MINUS) {\n    int op = p->tok.tok == TOK_PLUS_PLUS ? TOK_POSTFIX_PLUS : TOK_POSTFIX_MINUS;\n    emit_op(p, op);\n    pnext1(p);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_unary(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  int op = TOK_EOF;\n  if (findtok(s_unary_ops, p->tok.tok) != TOK_EOF) {\n    op = p->tok.tok;\n    pnext1(p);\n  }\n  if (findtok(s_unary_ops, p->tok.tok) != TOK_EOF) {\n    res = parse_unary(p, prev_op);\n  } else {\n    res = parse_postfix(p, prev_op);\n  }\n  if (res != MJS_OK) return res;\n  if (op != TOK_EOF) {\n    if (op == TOK_MINUS) op = TOK_UNARY_MINUS;\n    if (op == TOK_PLUS) op = TOK_UNARY_PLUS;\n    emit_op(p, op);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_mul_div_rem(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_MUL, TOK_DIV, TOK_REM, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_unary, parse_mul_div_rem, ops, prev_op);\n}\n\nstatic mjs_err_t parse_plus_minus(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_PLUS, TOK_MINUS, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_mul_div_rem, parse_plus_minus, ops, prev_op);\n}\n\nstatic mjs_err_t parse_shifts(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LSHIFT, TOK_RSHIFT, TOK_URSHIFT, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_plus_minus, parse_shifts, ops, prev_op);\n}\n\nstatic mjs_err_t parse_comparison(struct pstate *p, int prev_op) {\n  PARSE_LTR_BINOP(p, parse_shifts, parse_comparison, s_comparison_ops, prev_op);\n}\n\nstatic mjs_err_t parse_equality(struct pstate *p, int prev_op) {\n  PARSE_LTR_BINOP(p, parse_comparison, parse_equality, s_equality_ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_and(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_AND, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_equality, parse_bitwise_and, ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_xor(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_XOR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_and, parse_bitwise_xor, ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_or(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_OR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_xor, parse_bitwise_or, ops, prev_op);\n}\n\nstatic mjs_err_t parse_logical_and(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LOGICAL_AND, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_or, parse_logical_and, ops, prev_op);\n}\n\nstatic mjs_err_t parse_logical_or(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LOGICAL_OR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_logical_and, parse_logical_or, ops, prev_op);\n}\n\nstatic mjs_err_t parse_ternary(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_logical_or(p, TOK_EOF)) != MJS_OK) return res;\n  if (prev_op != TOK_EOF) emit_op(p, prev_op);\n\n  if (p->tok.tok == TOK_QUESTION) {\n    size_t off_if, off_endif, off_else;\n    EXPECT(p, TOK_QUESTION);\n\n    emit_byte(p, OP_JMP_FALSE);\n    off_if = p->cur_idx;\n    emit_init_offset(p);\n\n    if ((res = parse_ternary(p, TOK_EOF)) != MJS_OK) return res;\n\n    emit_byte(p, OP_JMP);\n    off_else = p->cur_idx;\n    emit_init_offset(p);\n    off_endif = p->cur_idx;\n\n    emit_byte(p, OP_DROP);\n\n    EXPECT(p, TOK_COLON);\n    if ((res = parse_ternary(p, TOK_EOF)) != MJS_OK) return res;\n\n    /*\n     * NOTE: if inserting offset causes the code to move, off_endif needs to be\n     * adjusted\n     */\n    off_endif += mjs_bcode_insert_offset(\n        p, p->mjs, off_else, p->cur_idx - off_else - MJS_INIT_OFFSET_SIZE);\n\n    mjs_bcode_insert_offset(p, p->mjs, off_if,\n                            off_endif - off_if - MJS_INIT_OFFSET_SIZE);\n  }\n\n  return res;\n}\n\nstatic mjs_err_t parse_assignment(struct pstate *p, int prev_op) {\n  PARSE_RTL_BINOP(p, parse_ternary, parse_assignment, s_assign_ops, prev_op);\n}\n\nstatic mjs_err_t parse_expr(struct pstate *p) {\n  return parse_assignment(p, TOK_EOF);\n}\n\nstatic mjs_err_t parse_let(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_LET);\n  for (;;) {\n    struct tok tmp = p->tok;\n    EXPECT(p, TOK_IDENT);\n\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n\n    if (p->tok.tok == TOK_ASSIGN) {\n      pnext1(p);\n      emit_byte(p, OP_PUSH_STR);\n      emit_str(p, tmp.ptr, tmp.len);\n      emit_byte(p, OP_FIND_SCOPE);\n      if ((res = parse_expr(p)) != MJS_OK) return res;\n      emit_op(p, TOK_ASSIGN);\n    } else {\n      emit_byte(p, OP_PUSH_UNDEF);\n    }\n    if (p->tok.tok == TOK_COMMA) {\n      emit_byte(p, OP_DROP);\n      pnext1(p);\n    }\n    if (p->tok.tok == TOK_SEMICOLON || p->tok.tok == TOK_EOF) break;\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_block_or_stmt(struct pstate *p, int cs) {\n  if (ptest(p) == TOK_OPEN_CURLY) {\n    return parse_block(p, cs);\n  } else {\n    return parse_statement(p);\n  }\n}\n\nstatic mjs_err_t parse_for_in(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  size_t off_b, off_check_end;\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /* Put iterator variable name to the stack */\n  if (p->tok.tok == TOK_KEYWORD_LET) {\n    EXPECT(p, TOK_KEYWORD_LET);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, p->tok.ptr, p->tok.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n  }\n  emit_byte(p, OP_PUSH_STR);\n  emit_str(p, p->tok.ptr, p->tok.len);\n\n  /* Put object to the stack */\n  EXPECT(p, TOK_IDENT);\n  EXPECT(p, TOK_KEYWORD_IN);\n  parse_expr(p);\n  EXPECT(p, TOK_CLOSE_PAREN);\n\n  emit_byte(p, OP_PUSH_UNDEF); /* Push iterator */\n\n  /* Before parsing condition statement, push break/continue offsets  */\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  emit_byte(p, 0); /* Point OP_CONTINUE to the next instruction */\n\n  emit_byte(p, OP_FOR_IN_NEXT);\n  emit_byte(p, OP_DUP);\n  emit_byte(p, OP_JMP_FALSE);\n  off_check_end = p->cur_idx;\n  emit_init_offset(p);\n\n  // Parse loop body\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_check_end,\n                          p->cur_idx - off_check_end - MJS_INIT_OFFSET_SIZE);\n\n  /* NOTE: jump C -> cond link is already established, it's constant: zero */\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> cond */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DEL_SCOPE);\n\n  return res;\n}\n\nstatic int check_for_in(struct pstate *p) {\n  struct pstate saved = *p;\n  int forin = 0;\n  if (p->tok.tok == TOK_KEYWORD_LET) pnext1(p);\n  if (p->tok.tok == TOK_IDENT) {\n    pnext1(p);\n    if (p->tok.tok == TOK_KEYWORD_IN) forin = 1;\n  }\n  *p = saved;\n  return forin;\n}\n\nstatic mjs_err_t parse_for(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  size_t off_b, off_c, off_init_end;\n  size_t off_incr_begin, off_cond_begin, off_cond_end;\n  int buf_cur_idx;\n\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_FOR);\n  EXPECT(p, TOK_OPEN_PAREN);\n\n  /* Look forward - is it for..in ? */\n  if (check_for_in(p)) return parse_for_in(p);\n\n  /*\n   * BC is a break+continue offsets (a part of OP_LOOP opcode)\n   *\n   *  BC init  incr  cond  body  break  del_scope\n   *  ||    |  ^     ^  |        ^      ^\n   *  ||    +--|-----+  |        |      |\n   *  |+-------+        +--------+      |\n   *  +---------------------------------+\n   *\n   * The order to setup links:\n   *\n   *   cond -> break\n   *   init -> cond\n   *   C -> incr\n   *   B -> del_scope\n   */\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /* Before parsing condition statement, push break/continue offsets  */\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  off_c = p->cur_idx;\n  emit_init_offset(p);\n\n  /* Parse init statement */\n  if (p->tok.tok == TOK_KEYWORD_LET) {\n    if ((res = parse_let(p)) != MJS_OK) return res;\n  } else {\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n  }\n  EXPECT(p, TOK_SEMICOLON);\n  emit_byte(p, OP_DROP);\n\n  emit_byte(p, OP_JMP);\n  off_init_end = p->cur_idx;\n  emit_init_offset(p);\n\n  off_incr_begin = p->cur_idx;\n  off_cond_begin = p->cur_idx;\n\n  /* Parse cond statement */\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_SEMICOLON);\n\n  /* Parse incr statement */\n  /* Incr statement should be placed before cond, so, adjust cur_idx */\n  buf_cur_idx = p->cur_idx;\n  p->cur_idx = off_incr_begin;\n\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_CLOSE_PAREN);\n  emit_byte(p, OP_DROP);\n\n  /*\n   * Now incr is inserted before cond, so we adjust cur_idx back, and set\n   * off_cond_begin to the correct value\n   */\n  {\n    int incr_size = p->cur_idx - off_incr_begin;\n    off_cond_begin += incr_size;\n    p->cur_idx = buf_cur_idx + incr_size;\n  }\n\n  /* p->cur_idx is now at the end of \"cond\" */\n  /* Exit the loop if false */\n  emit_byte(p, OP_JMP_FALSE);\n  off_cond_end = p->cur_idx;\n  emit_init_offset(p);\n\n  /* Parse loop body */\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* p->cur_idx is at the \"break\" item now */\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_cond_end,\n                          p->cur_idx - off_cond_end - MJS_INIT_OFFSET_SIZE);\n\n  /* jump init -> cond (and adjust off_incr_begin which may move) */\n  off_incr_begin += mjs_bcode_insert_offset(\n      p, p->mjs, off_init_end,\n      off_cond_begin - off_init_end - MJS_INIT_OFFSET_SIZE);\n\n  /* jump C -> incr */\n  mjs_bcode_insert_offset(p, p->mjs, off_c,\n                          off_incr_begin - off_c - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> del_scope */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DEL_SCOPE);\n\n  return res;\n}\n\nstatic mjs_err_t parse_while(struct pstate *p) {\n  size_t off_cond_end, off_b;\n  mjs_err_t res = MJS_OK;\n\n  EXPECT(p, TOK_KEYWORD_WHILE);\n  EXPECT(p, TOK_OPEN_PAREN);\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /*\n   * BC is a break+continue offsets (a part of OP_LOOP opcode)\n   *\n   *   BC cond body break del_scope\n   *   || ^  |      ^     ^\n   *   || |  |      |     |\n   *   |+-+  +------+     |\n   *   +------------------+\n   *\n   * The order to setup links:\n   *\n   *    cond -> break\n   *    C -> cond\n   *    B -> del_scope\n   */\n\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  emit_byte(p, 0); /* Point OP_CONTINUE to the next instruction */\n\n  // parse condition statement\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_CLOSE_PAREN);\n\n  // Exit the loop if false\n  emit_byte(p, OP_JMP_FALSE);\n  off_cond_end = p->cur_idx;\n  emit_init_offset(p);\n\n  // Parse loop body\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_cond_end,\n                          p->cur_idx - off_cond_end - MJS_INIT_OFFSET_SIZE);\n\n  /* NOTE: jump C -> cond link is already established, it's constant: zero */\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> cond */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DEL_SCOPE);\n  return res;\n}\n\nstatic mjs_err_t parse_if(struct pstate *p) {\n  size_t off_if, off_endif;\n  mjs_err_t res = MJS_OK;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_IF);\n  EXPECT(p, TOK_OPEN_PAREN);\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n\n  emit_byte(p, OP_JMP_FALSE);\n  off_if = p->cur_idx;\n  emit_init_offset(p);\n\n  EXPECT(p, TOK_CLOSE_PAREN);\n  if ((res = parse_block_or_stmt(p, 1)) != MJS_OK) return res;\n\n  if (p->tok.tok == TOK_KEYWORD_ELSE) {\n    /*\n     * Else clause is present, so, if the condition is not true, the jump\n     * target (off_endif) should be not the current offset, but the offset\n     * after jump-over-else opcode\n     */\n    size_t off_else, off_endelse;\n    pnext1(p);\n    emit_byte(p, OP_JMP);\n    off_else = p->cur_idx;\n    emit_init_offset(p);\n    off_endif = p->cur_idx;\n\n    emit_byte(p, OP_DROP);\n    if ((res = parse_block_or_stmt(p, 1)) != MJS_OK) return res;\n    off_endelse = p->cur_idx;\n\n    /*\n     * NOTE: if inserting offset causes the code to move, off_endif needs to be\n     * adjusted\n     */\n    off_endif += mjs_bcode_insert_offset(\n        p, p->mjs, off_else, off_endelse - off_else - MJS_INIT_OFFSET_SIZE);\n  } else {\n    /* Else clause is not present, so, current offset is a jump target\n     * (off_endif) */\n    off_endif = p->cur_idx;\n  }\n\n  mjs_bcode_insert_offset(p, p->mjs, off_if,\n                          off_endif - off_if - MJS_INIT_OFFSET_SIZE);\n\n  return res;\n}\n\nstatic void pstate_revert(struct pstate *p, struct pstate *old,\n                          int old_bcode_gen_len) {\n  p->pos = old->pos;\n  p->line_no = old->line_no;\n  p->last_emitted_line_no = old->last_emitted_line_no;\n  p->offset_lineno_map.len = old->offset_lineno_map.len;\n  p->prev_tok = old->prev_tok;\n  p->tok = old->tok;\n  p->mjs->bcode_gen.len = old_bcode_gen_len;\n  p->cur_idx = old->cur_idx;\n  p->depth = old->depth;\n}\n\nstatic mjs_err_t parse_return(struct pstate *p) {\n  int old_bcode_gen_len;\n  struct pstate p_saved;\n  EXPECT(p, TOK_KEYWORD_RETURN);\n  p_saved = *p;\n  old_bcode_gen_len = p->mjs->bcode_gen.len;\n  if (parse_expr(p) != MJS_OK) {\n    /*\n     * Failed to parse an expression to return, so return the parser to the\n     * prior state and push undefined.\n     */\n    pstate_revert(p, &p_saved, old_bcode_gen_len);\n    emit_byte(p, OP_PUSH_UNDEF);\n  }\n  emit_byte(p, OP_SETRETVAL);\n  emit_byte(p, OP_RETURN);\n  return MJS_OK;\n}\n\nstatic mjs_err_t parse_statement(struct pstate *p) {\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  switch (p->tok.tok) {\n    case TOK_SEMICOLON:\n      emit_byte(p, OP_PUSH_UNDEF);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_LET:\n      return parse_let(p);\n    case TOK_OPEN_CURLY:\n      return parse_block(p, 1);\n    case TOK_KEYWORD_RETURN:\n      return parse_return(p);\n    case TOK_KEYWORD_FOR:\n      return parse_for(p);\n    case TOK_KEYWORD_WHILE:\n      return parse_while(p);\n    case TOK_KEYWORD_BREAK:\n      emit_byte(p, OP_PUSH_UNDEF);\n      emit_byte(p, OP_BREAK);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_CONTINUE:\n      emit_byte(p, OP_CONTINUE);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_IF:\n      return parse_if(p);\n    case TOK_KEYWORD_CASE:\n    case TOK_KEYWORD_CATCH:\n    case TOK_KEYWORD_DELETE:\n    case TOK_KEYWORD_DO:\n    case TOK_KEYWORD_INSTANCEOF:\n    case TOK_KEYWORD_NEW:\n    case TOK_KEYWORD_SWITCH:\n    case TOK_KEYWORD_THROW:\n    case TOK_KEYWORD_TRY:\n    case TOK_KEYWORD_VAR:\n    case TOK_KEYWORD_VOID:\n    case TOK_KEYWORD_WITH:\n      mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"[%.*s] is not implemented\",\n                     p->tok.len, p->tok.ptr);\n      return MJS_SYNTAX_ERROR;\n    default: {\n      mjs_err_t res = MJS_OK;\n      for (;;) {\n        if ((res = parse_expr(p)) != MJS_OK) return res;\n        if (p->tok.tok != TOK_COMMA) break;\n        emit_byte(p, OP_DROP);\n        pnext1(p);\n      }\n      return res;\n    }\n  }\n}\n\nMJS_PRIVATE mjs_err_t\nmjs_parse(const char *path, const char *buf, struct mjs *mjs) {\n  mjs_err_t res = MJS_OK;\n  struct pstate p;\n  size_t start_idx, llen;\n  int map_len;\n  mjs_header_item_t bcode_offset, map_offset, total_size;\n\n  pinit(path, buf, &p);\n  p.mjs = mjs;\n  p.cur_idx = p.mjs->bcode_gen.len;\n  emit_byte(&p, OP_BCODE_HEADER);\n\n  /*\n   * TODO(dfrank): don't access mjs->bcode_gen directly, use emit_... API which\n   * takes care of p->cur_idx\n   */\n\n  /* Remember starting bcode position, and reserve the room for bcode header */\n  start_idx = p.mjs->bcode_gen.len;\n  mbuf_append(&p.mjs->bcode_gen, NULL,\n              sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT);\n\n  /* Append NULL-terminated filename */\n  mbuf_append(&p.mjs->bcode_gen, path, strlen(path) + 1 /* null-terminate */);\n\n  bcode_offset = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n         &bcode_offset, sizeof(mjs_header_item_t));\n\n  p.start_bcode_idx = p.mjs->bcode_gen.len;\n  p.cur_idx = p.mjs->bcode_gen.len;\n\n  res = parse_statement_list(&p, TOK_EOF);\n  emit_byte(&p, OP_EXIT);\n\n  /* remember map offset */\n  map_offset = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_MAP_OFFSET,\n         &map_offset, sizeof(mjs_header_item_t));\n\n  /* put map length varint */\n  map_len = p.offset_lineno_map.len;\n  llen = cs_varint_llen(map_len);\n  mbuf_resize(&p.mjs->bcode_gen, p.mjs->bcode_gen.size + llen);\n  cs_varint_encode(\n      map_len, (uint8_t *) p.mjs->bcode_gen.buf + p.mjs->bcode_gen.len, llen);\n  p.mjs->bcode_gen.len += llen;\n\n  /* put the map itself */\n  mbuf_append(&p.mjs->bcode_gen, p.offset_lineno_map.buf,\n              p.offset_lineno_map.len);\n\n  total_size = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_TOTAL_SIZE,\n         &total_size, sizeof(mjs_header_item_t));\n\n  mbuf_free(&p.offset_lineno_map);\n\n  /*\n   * If parsing was successful, commit the bcode; otherwise drop generated\n   * bcode\n   */\n  if (res == MJS_OK) {\n    mjs_bcode_commit(mjs);\n  } else {\n    mbuf_free(&mjs->bcode_gen);\n  }\n\n  return res;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n\nmjs_val_t mjs_mk_null(void) {\n  return MJS_NULL;\n}\n\nint mjs_is_null(mjs_val_t v) {\n  return v == MJS_NULL;\n}\n\nmjs_val_t mjs_mk_undefined(void) {\n  return MJS_UNDEFINED;\n}\n\nint mjs_is_undefined(mjs_val_t v) {\n  return v == MJS_UNDEFINED;\n}\n\nmjs_val_t mjs_mk_number(struct mjs *mjs, double v) {\n  mjs_val_t res;\n  (void) mjs;\n  /* not every NaN is a JS NaN */\n  if (isnan(v)) {\n    res = MJS_TAG_NAN;\n  } else {\n    union {\n      double d;\n      mjs_val_t r;\n    } u;\n    u.d = v;\n    res = u.r;\n  }\n  return res;\n}\n\nstatic double get_double(mjs_val_t v) {\n  union {\n    double d;\n    mjs_val_t v;\n  } u;\n  u.v = v;\n  /* Due to NaN packing, any non-numeric value is already a valid NaN value */\n  return u.d;\n}\n\ndouble mjs_get_double(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  return get_double(v);\n}\n\nint mjs_get_int(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  /*\n   * NOTE(dfrank): without double cast, all numbers >= 0x80000000 are always\n   * converted to exactly 0x80000000.\n   */\n  return (int) (unsigned int) get_double(v);\n}\n\nint32_t mjs_get_int32(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  return (int32_t) get_double(v);\n}\n\nint mjs_is_number(mjs_val_t v) {\n  return v == MJS_TAG_NAN || !isnan(get_double(v));\n}\n\nmjs_val_t mjs_mk_boolean(struct mjs *mjs, int v) {\n  (void) mjs;\n  return (v ? 1 : 0) | MJS_TAG_BOOLEAN;\n}\n\nint mjs_get_bool(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  if (mjs_is_boolean(v)) {\n    return v & 1;\n  } else {\n    return 0;\n  }\n}\n\nint mjs_is_boolean(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_BOOLEAN;\n}\n\n#define MJS_IS_POINTER_LEGIT(n) \\\n  (((n) &MJS_TAG_MASK) == 0 || ((n) &MJS_TAG_MASK) == (~0 & MJS_TAG_MASK))\n\nMJS_PRIVATE mjs_val_t mjs_pointer_to_value(struct mjs *mjs, void *p) {\n  uint64_t n = ((uint64_t)(uintptr_t) p);\n\n  if (!MJS_IS_POINTER_LEGIT(n)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid pointer value: %p\", p);\n  }\n  return n & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE mjs_val_t mjs_legit_pointer_to_value(void *p) {\n  uint64_t n = ((uint64_t)(uintptr_t) p);\n\n  assert(MJS_IS_POINTER_LEGIT(n));\n  return n & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE void *get_ptr(mjs_val_t v) {\n  return (void *) (uintptr_t)(v & 0xFFFFFFFFFFFFUL);\n}\n\nvoid *mjs_get_ptr(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  if (!mjs_is_foreign(v)) {\n    return NULL;\n  }\n  return get_ptr(v);\n}\n\nmjs_val_t mjs_mk_foreign(struct mjs *mjs, void *p) {\n  (void) mjs;\n  return mjs_pointer_to_value(mjs, p) | MJS_TAG_FOREIGN;\n}\n\nmjs_val_t mjs_mk_foreign_func(struct mjs *mjs, mjs_func_ptr_t fn) {\n  union {\n    mjs_func_ptr_t fn;\n    void *p;\n  } u;\n  u.fn = fn;\n  (void) mjs;\n  return mjs_pointer_to_value(mjs, u.p) | MJS_TAG_FOREIGN;\n}\n\nint mjs_is_foreign(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FOREIGN;\n}\n\nmjs_val_t mjs_mk_function(struct mjs *mjs, size_t off) {\n  (void) mjs;\n  return (mjs_val_t) off | MJS_TAG_FUNCTION;\n}\n\nint mjs_is_function(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FUNCTION;\n}\n\nMJS_PRIVATE void mjs_op_isnan(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t val = mjs_arg(mjs, 0);\n\n  ret = mjs_mk_boolean(mjs, val == MJS_TAG_NAN);\n\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"common/cs_varint.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n// No UTF\ntypedef unsigned short Rune;\nstatic int chartorune(Rune *rune, const char *str) {\n  *rune = *(unsigned char *) str;\n  return 1;\n}\nstatic int runetochar(char *str, Rune *rune) {\n  str[0] = (char) *rune;\n  return 1;\n}\n\n#ifndef MJS_STRING_BUF_RESERVE\n#define MJS_STRING_BUF_RESERVE 100\n#endif\n\nMJS_PRIVATE size_t unescape(const char *s, size_t len, char *to);\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags);\n\n/* TODO(lsm): NaN payload location depends on endianness, make crossplatform */\n#define GET_VAL_NAN_PAYLOAD(v) ((char *) &(v))\n\nint mjs_is_string(mjs_val_t v) {\n  uint64_t t = v & MJS_TAG_MASK;\n  return t == MJS_TAG_STRING_I || t == MJS_TAG_STRING_F ||\n         t == MJS_TAG_STRING_O || t == MJS_TAG_STRING_5 ||\n         t == MJS_TAG_STRING_D;\n}\n\nmjs_val_t mjs_mk_string(struct mjs *mjs, const char *p, size_t len, int copy) {\n  struct mbuf *m;\n  mjs_val_t offset, tag = MJS_TAG_STRING_F;\n  if (len == 0) {\n    /*\n     * Zero length for foreign string has a special meaning (that the foreign\n     * string is not inlined into mjs_val_t), so when creating a zero-length\n     * string, we always assume it'll be owned. Since the length is zero, it\n     * doesn't matter anyway.\n     */\n    copy = 1;\n  }\n  m = copy ? &mjs->owned_strings : &mjs->foreign_strings;\n  offset = m->len;\n\n  if (len == ~((size_t) 0)) len = strlen(p);\n\n  if (copy) {\n    /* owned string */\n    if (len <= 4) {\n      char *s = GET_VAL_NAN_PAYLOAD(offset) + 1;\n      offset = 0;\n      if (p != 0) {\n        memcpy(s, p, len);\n      }\n      s[-1] = len;\n      tag = MJS_TAG_STRING_I;\n    } else if (len == 5) {\n      char *s = GET_VAL_NAN_PAYLOAD(offset);\n      offset = 0;\n      if (p != 0) {\n        memcpy(s, p, len);\n      }\n      tag = MJS_TAG_STRING_5;\n      // } else if ((dict_index = v_find_string_in_dictionary(p, len)) >= 0) {\n      //   offset = 0;\n      //   GET_VAL_NAN_PAYLOAD(offset)[0] = dict_index;\n      //   tag = MJS_TAG_STRING_D;\n    } else {\n      if (gc_strings_is_gc_needed(mjs)) {\n        mjs->need_gc = 1;\n      }\n\n      /*\n       * Before embedding new string, check if the reallocation is needed.  If\n       * so, perform the reallocation by calling `mbuf_resize` manually, since\n       * we need to preallocate some extra space (`MJS_STRING_BUF_RESERVE`)\n       */\n      if ((m->len + len) > m->size) {\n        char *prev_buf = m->buf;\n        mbuf_resize(m, m->len + len + MJS_STRING_BUF_RESERVE);\n\n        /*\n         * There is a corner case: when the source pointer is located within\n         * the mbuf. In this case, we should adjust the pointer, because it\n         * might have just been reallocated.\n         */\n        if (p >= prev_buf && p < (prev_buf + m->len)) {\n          p += (m->buf - prev_buf);\n        }\n      }\n\n      embed_string(m, m->len, p, len, EMBSTR_ZERO_TERM);\n      tag = MJS_TAG_STRING_O;\n    }\n  } else {\n    /* foreign string */\n    if (sizeof(void *) <= 4 && len <= (1 << 15)) {\n      /* small foreign strings can fit length and ptr in the mjs_val_t */\n      offset = (uint64_t) len << 32 | (uint64_t)(uintptr_t) p;\n    } else {\n      /* bigger strings need indirection that uses ram */\n      size_t pos = m->len;\n      size_t llen = cs_varint_llen(len);\n\n      /* allocate space for len and ptr */\n      mbuf_insert(m, pos, NULL, llen + sizeof(p));\n\n      cs_varint_encode(len, (uint8_t *) (m->buf + pos), llen);\n      memcpy(m->buf + pos + llen, &p, sizeof(p));\n    }\n    tag = MJS_TAG_STRING_F;\n  }\n\n  /* NOTE(lsm): don't use pointer_to_value, 32-bit ptrs will truncate */\n  return (offset & ~MJS_TAG_MASK) | tag;\n}\n\n/* Get a pointer to string and string length. */\nconst char *mjs_get_string(struct mjs *mjs, mjs_val_t *v, size_t *sizep) {\n  uint64_t tag = v[0] & MJS_TAG_MASK;\n  const char *p = NULL;\n  size_t size = 0, llen;\n\n  if (!mjs_is_string(*v)) {\n    goto clean;\n  }\n\n  if (tag == MJS_TAG_STRING_I) {\n    p = GET_VAL_NAN_PAYLOAD(*v) + 1;\n    size = p[-1];\n  } else if (tag == MJS_TAG_STRING_5) {\n    p = GET_VAL_NAN_PAYLOAD(*v);\n    size = 5;\n    // } else if (tag == MJS_TAG_STRING_D) {\n    //   int index = ((unsigned char *) GET_VAL_NAN_PAYLOAD(*v))[0];\n    //   size = v_dictionary_strings[index].len;\n    //   p = v_dictionary_strings[index].p;\n  } else if (tag == MJS_TAG_STRING_O) {\n    size_t offset = (size_t) gc_string_mjs_val_to_offset(*v);\n    char *s = mjs->owned_strings.buf + offset;\n    uint64_t v = 0;\n    if (offset < mjs->owned_strings.len &&\n        cs_varint_decode((uint8_t *) s, mjs->owned_strings.len - offset, &v,\n                         &llen)) {\n      size = v;\n      p = s + llen;\n    } else {\n      goto clean;\n    }\n  } else if (tag == MJS_TAG_STRING_F) {\n    /*\n     * short foreign strings on <=32-bit machines can be encoded in a compact\n     * form:\n     *\n     *     7         6        5        4        3        2        1        0\n     *  11111111|1111tttt|llllllll|llllllll|ssssssss|ssssssss|ssssssss|ssssssss\n     *\n     * Strings longer than 2^26 will be indireceted through the foreign_strings\n     * mbuf.\n     *\n     * We don't use a different tag to represent those two cases. Instead, all\n     * foreign strings represented with the help of the foreign_strings mbuf\n     * will have the upper 16-bits of the payload set to zero. This allows us to\n     * represent up to 477 million foreign strings longer than 64k.\n     */\n    uint16_t len = (*v >> 32) & 0xFFFF;\n    if (sizeof(void *) <= 4 && len != 0) {\n      size = (size_t) len;\n      p = (const char *) (uintptr_t) *v;\n    } else {\n      size_t offset = (size_t) gc_string_mjs_val_to_offset(*v);\n      char *s = mjs->foreign_strings.buf + offset;\n      uint64_t v = 0;\n      if (offset < mjs->foreign_strings.len &&\n          cs_varint_decode((uint8_t *) s, mjs->foreign_strings.len - offset, &v,\n                           &llen)) {\n        size = v;\n        memcpy((char **) &p, s + llen, sizeof(p));\n      } else {\n        goto clean;\n      }\n    }\n  } else {\n    assert(0);\n  }\n\nclean:\n  if (sizep != NULL) {\n    *sizep = size;\n  }\n  return p;\n}\n\nconst char *mjs_get_cstring(struct mjs *mjs, mjs_val_t *value) {\n  size_t size;\n  const char *s = mjs_get_string(mjs, value, &size);\n  if (s == NULL) return NULL;\n  if (s[size] != 0 || strlen(s) != size) {\n    return NULL;\n  }\n  return s;\n}\n\nint mjs_strcmp(struct mjs *mjs, mjs_val_t *a, const char *b, size_t len) {\n  size_t n;\n  const char *s;\n  if (len == (size_t) ~0) len = strlen(b);\n  s = mjs_get_string(mjs, a, &n);\n  if (n != len) {\n    return n - len;\n  }\n  return strncmp(s, b, len);\n}\n\nMJS_PRIVATE unsigned long cstr_to_ulong(const char *s, size_t len, int *ok) {\n  char *e;\n  unsigned long res = strtoul(s, &e, 10);\n  *ok = (e == s + len) && len != 0;\n  return res;\n}\n\nMJS_PRIVATE mjs_err_t\nstr_to_ulong(struct mjs *mjs, mjs_val_t v, int *ok, unsigned long *res) {\n  enum mjs_err ret = MJS_OK;\n  size_t len = 0;\n  const char *p = mjs_get_string(mjs, &v, &len);\n  *res = cstr_to_ulong(p, len, ok);\n\n  return ret;\n}\n\nMJS_PRIVATE int s_cmp(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  size_t a_len, b_len;\n  const char *a_ptr, *b_ptr;\n\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  if (a_len == b_len) {\n    return memcmp(a_ptr, b_ptr, a_len);\n  }\n  if (a_len > b_len) {\n    return 1;\n  } else if (a_len < b_len) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nMJS_PRIVATE mjs_val_t s_concat(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  size_t a_len, b_len, res_len;\n  const char *a_ptr, *b_ptr, *res_ptr;\n  mjs_val_t res;\n\n  /* Find out lengths of both srtings */\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  /* Create a placeholder string */\n  res = mjs_mk_string(mjs, NULL, a_len + b_len, 1);\n\n  /* mjs_mk_string() may have reallocated mbuf - revalidate pointers */\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  /* Copy strings into the placeholder */\n  res_ptr = mjs_get_string(mjs, &res, &res_len);\n  memcpy((char *) res_ptr, a_ptr, a_len);\n  memcpy((char *) res_ptr + a_len, b_ptr, b_len);\n\n  return res;\n}\n\nMJS_PRIVATE void mjs_string_slice(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_val_t ret = mjs_mk_number(mjs, 0);\n  mjs_val_t beginSlice_v = MJS_UNDEFINED;\n  mjs_val_t endSlice_v = MJS_UNDEFINED;\n  int beginSlice = 0;\n  int endSlice = 0;\n  size_t size;\n  const char *s = NULL;\n\n  /* get string from `this` */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  s = mjs_get_string(mjs, &mjs->vals.this_obj, &size);\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"beginSlice\", MJS_TYPE_NUMBER, &beginSlice_v)) {\n    goto clean;\n  }\n  beginSlice = mjs_normalize_idx(mjs_get_int(mjs, beginSlice_v), size);\n\n  if (nargs >= 2) {\n    /* endSlice is given; use it */\n    /* get idx from arg 0 */\n    if (!mjs_check_arg(mjs, 1, \"endSlice\", MJS_TYPE_NUMBER, &endSlice_v)) {\n      goto clean;\n    }\n    endSlice = mjs_normalize_idx(mjs_get_int(mjs, endSlice_v), size);\n  } else {\n    /* endSlice is not given; assume the end of the string */\n    endSlice = size;\n  }\n\n  if (endSlice < beginSlice) {\n    endSlice = beginSlice;\n  }\n\n  ret = mjs_mk_string(mjs, s + beginSlice, endSlice - beginSlice, 1);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_string_index_of(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_number(mjs, -1);\n  mjs_val_t substr_v = MJS_UNDEFINED;\n  mjs_val_t idx_v = MJS_UNDEFINED;\n  int idx = 0;\n  const char *str = NULL, *substr = NULL;\n  size_t str_len = 0, substr_len = 0;\n\n  if (!mjs_check_arg(mjs, -1 /* this */, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  str = mjs_get_string(mjs, &mjs->vals.this_obj, &str_len);\n\n  if (!mjs_check_arg(mjs, 0, \"searchValue\", MJS_TYPE_STRING, &substr_v)) {\n    goto clean;\n  }\n  substr = mjs_get_string(mjs, &substr_v, &substr_len);\n  if (mjs_nargs(mjs) > 1) {\n    if (!mjs_check_arg(mjs, 1, \"fromIndex\", MJS_TYPE_NUMBER, &idx_v)) {\n      goto clean;\n    }\n    idx = mjs_get_int(mjs, idx_v);\n    if (idx < 0) idx = 0;\n    if ((size_t) idx > str_len) idx = str_len;\n  }\n  {\n    const char *substr_p;\n    struct mg_str mgstr, mgsubstr;\n    mgstr.p = str + idx;\n    mgstr.len = str_len - idx;\n    mgsubstr.p = substr;\n    mgsubstr.len = substr_len;\n    substr_p = mg_strstr(mgstr, mgsubstr);\n    if (substr_p != NULL) {\n      ret = mjs_mk_number(mjs, (int) (substr_p - str));\n    }\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_string_char_code_at(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t idx_v = MJS_UNDEFINED;\n  int idx = 0;\n  size_t size;\n  const char *s = NULL;\n\n  /* get string from `this` */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  s = mjs_get_string(mjs, &mjs->vals.this_obj, &size);\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"index\", MJS_TYPE_NUMBER, &idx_v)) {\n    goto clean;\n  }\n  idx = mjs_normalize_idx(mjs_get_int(mjs, idx_v), size);\n  if (idx >= 0 && idx < (int) size) {\n    ret = mjs_mk_number(mjs, ((unsigned char *) s)[idx]);\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_mkstr(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_val_t ret = MJS_UNDEFINED;\n\n  char *ptr = NULL;\n  int offset = 0;\n  int len = 0;\n  int copy = 0;\n\n  mjs_val_t ptr_v = MJS_UNDEFINED;\n  mjs_val_t offset_v = MJS_UNDEFINED;\n  mjs_val_t len_v = MJS_UNDEFINED;\n  mjs_val_t copy_v = MJS_UNDEFINED;\n\n  if (nargs == 2) {\n    ptr_v = mjs_arg(mjs, 0);\n    len_v = mjs_arg(mjs, 1);\n  } else if (nargs == 3) {\n    ptr_v = mjs_arg(mjs, 0);\n    offset_v = mjs_arg(mjs, 1);\n    len_v = mjs_arg(mjs, 2);\n  } else if (nargs == 4) {\n    ptr_v = mjs_arg(mjs, 0);\n    offset_v = mjs_arg(mjs, 1);\n    len_v = mjs_arg(mjs, 2);\n    copy_v = mjs_arg(mjs, 3);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                       \"mkstr takes 2, 3 or 4 arguments: (ptr, len), (ptr, \"\n                       \"offset, len) or (ptr, offset, len, copy)\");\n    goto clean;\n  }\n\n  if (!mjs_is_foreign(ptr_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"ptr should be a foreign pointer\");\n    goto clean;\n  }\n\n  if (offset_v != MJS_UNDEFINED && !mjs_is_number(offset_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"offset should be a number\");\n    goto clean;\n  }\n\n  if (!mjs_is_number(len_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"len should be a number\");\n    goto clean;\n  }\n\n  copy = mjs_is_truthy(mjs, copy_v);\n\n  /* all arguments are fine */\n\n  ptr = (char *) mjs_get_ptr(mjs, ptr_v);\n  if (offset_v != MJS_UNDEFINED) {\n    offset = mjs_get_int(mjs, offset_v);\n  }\n  len = mjs_get_int(mjs, len_v);\n\n  ret = mjs_mk_string(mjs, ptr + offset, len, copy);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nenum unescape_error {\n  SLRE_INVALID_HEX_DIGIT,\n  SLRE_INVALID_ESC_CHAR,\n  SLRE_UNTERM_ESC_SEQ,\n};\n\nstatic int hex(int c) {\n  if (c >= '0' && c <= '9') return c - '0';\n  if (c >= 'a' && c <= 'f') return c - 'a' + 10;\n  if (c >= 'A' && c <= 'F') return c - 'A' + 10;\n  return -SLRE_INVALID_HEX_DIGIT;\n}\n\nstatic int nextesc(const char **p) {\n  const unsigned char *s = (unsigned char *) (*p)++;\n  switch (*s) {\n    case 0:\n      return -SLRE_UNTERM_ESC_SEQ;\n    case 'c':\n      ++*p;\n      return *s & 31;\n    case 'b':\n      return '\\b';\n    case 't':\n      return '\\t';\n    case 'n':\n      return '\\n';\n    case 'v':\n      return '\\v';\n    case 'f':\n      return '\\f';\n    case 'r':\n      return '\\r';\n    case '\\\\':\n      return '\\\\';\n    case 'u':\n      if (isxdigit(s[1]) && isxdigit(s[2]) && isxdigit(s[3]) &&\n          isxdigit(s[4])) {\n        (*p) += 4;\n        return hex(s[1]) << 12 | hex(s[2]) << 8 | hex(s[3]) << 4 | hex(s[4]);\n      }\n      return -SLRE_INVALID_HEX_DIGIT;\n    case 'x':\n      if (isxdigit(s[1]) && isxdigit(s[2])) {\n        (*p) += 2;\n        return (hex(s[1]) << 4) | hex(s[2]);\n      }\n      return -SLRE_INVALID_HEX_DIGIT;\n    default:\n      return -SLRE_INVALID_ESC_CHAR;\n  }\n}\n\nMJS_PRIVATE size_t unescape(const char *s, size_t len, char *to) {\n  const char *end = s + len;\n  size_t n = 0;\n  char tmp[4];\n  Rune r;\n\n  while (s < end) {\n    s += chartorune(&r, s);\n    if (r == '\\\\' && s < end) {\n      switch (*s) {\n        case '\"':\n          s++, r = '\"';\n          break;\n        case '\\'':\n          s++, r = '\\'';\n          break;\n        case '\\n':\n          s++, r = '\\n';\n          break;\n        default: {\n          const char *tmp_s = s;\n          int i = nextesc(&s);\n          switch (i) {\n            case -SLRE_INVALID_ESC_CHAR:\n              r = '\\\\';\n              s = tmp_s;\n              n += runetochar(to == NULL ? tmp : to + n, &r);\n              s += chartorune(&r, s);\n              break;\n            case -SLRE_INVALID_HEX_DIGIT:\n            default:\n              r = i;\n          }\n        }\n      }\n    }\n    n += runetochar(to == NULL ? tmp : to + n, &r);\n  }\n\n  return n;\n}\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags) {\n  char *old_base = m->buf;\n  uint8_t p_backed_by_mbuf = p >= old_base && p < old_base + m->len;\n  size_t n = (flags & EMBSTR_UNESCAPE) ? unescape(p, len, NULL) : len;\n\n  /* Calculate how many bytes length takes */\n  size_t k = cs_varint_llen(n);\n\n  /* total length: varing length + string len + zero-term */\n  size_t tot_len = k + n + !!(flags & EMBSTR_ZERO_TERM);\n\n  /* Allocate buffer */\n  mbuf_insert(m, offset, NULL, tot_len);\n\n  /* Fixup p if it was relocated by mbuf_insert() above */\n  if (p_backed_by_mbuf) {\n    p += m->buf - old_base;\n  }\n\n  /* Write length */\n  cs_varint_encode(n, (unsigned char *) m->buf + offset, k);\n\n  /* Write string */\n  if (p != 0) {\n    if (flags & EMBSTR_UNESCAPE) {\n      unescape(p, len, m->buf + offset + k);\n    } else {\n      memcpy(m->buf + offset + k, p, len);\n    }\n  }\n\n  /* add NULL-terminator if needed */\n  if (flags & EMBSTR_ZERO_TERM) {\n    m->buf[offset + tot_len - 1] = '\\0';\n  }\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_tok.c\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nMJS_PRIVATE void pinit(const char *file_name, const char *buf,\n                       struct pstate *p) {\n  memset(p, 0, sizeof(*p));\n  p->line_no = 1;\n  p->last_emitted_line_no = 1;\n  p->file_name = file_name;\n  p->buf = p->pos = buf;\n  mbuf_init(&p->offset_lineno_map, 0);\n}\n\n// We're not relying on the target libc ctype, as it may incorrectly\n// handle negative arguments, e.g. isspace(-1).\nstatic int mjs_is_space(int c) {\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t' || c == '\\f' ||\n         c == '\\v';\n}\n\nMJS_PRIVATE int mjs_is_digit(int c) {\n  return c >= '0' && c <= '9';\n}\n\nstatic int mjs_is_alpha(int c) {\n  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nMJS_PRIVATE int mjs_is_ident(int c) {\n  return c == '_' || c == '$' || mjs_is_alpha(c);\n}\n\n// Try to parse a token that can take one or two chars.\nstatic int longtok(struct pstate *p, const char *first_chars,\n                   const char *second_chars) {\n  if (strchr(first_chars, p->pos[0]) == NULL) return TOK_EOF;\n  if (p->pos[1] != '\\0' && strchr(second_chars, p->pos[1]) != NULL) {\n    p->tok.len++;\n    p->pos++;\n    return p->pos[-1] << 8 | p->pos[0];\n  }\n  return p->pos[0];\n}\n\n// Try to parse a token that takes exactly 3 chars.\nstatic int longtok3(struct pstate *p, char a, char b, char c) {\n  if (p->pos[0] == a && p->pos[1] == b && p->pos[2] == c) {\n    p->tok.len += 2;\n    p->pos += 2;\n    return p->pos[-2] << 16 | p->pos[-1] << 8 | p->pos[0];\n  }\n  return TOK_EOF;\n}\n\n// Try to parse a token that takes exactly 4 chars.\nstatic int longtok4(struct pstate *p, char a, char b, char c, char d) {\n  if (p->pos[0] == a && p->pos[1] == b && p->pos[2] == c && p->pos[3] == d) {\n    p->tok.len += 3;\n    p->pos += 3;\n    return p->pos[-3] << 24 | p->pos[-2] << 16 | p->pos[-1] << 8 | p->pos[0];\n  }\n  return TOK_EOF;\n}\n\nstatic int getnum(struct pstate *p) {\n  if (p->pos[0] == '0' && p->pos[1] == 'x') {\n    // MSVC6 strtod cannot parse 0x... numbers, thus this ugly workaround.\n    strtoul(p->pos + 2, (char **) &p->pos, 16);\n  } else {\n    strtod(p->pos, (char **) &p->pos);\n  }\n  p->tok.len = p->pos - p->tok.ptr;\n  p->pos--;\n  return TOK_NUM;\n}\n\nstatic int is_reserved_word_token(const char *s, int len) {\n  const char *reserved[] = {\n      \"break\",     \"case\",   \"catch\", \"continue\",   \"debugger\", \"default\",\n      \"delete\",    \"do\",     \"else\",  \"false\",      \"finally\",  \"for\",\n      \"function\",  \"if\",     \"in\",    \"instanceof\", \"new\",      \"null\",\n      \"return\",    \"switch\", \"this\",  \"throw\",      \"true\",     \"try\",\n      \"typeof\",    \"var\",    \"void\",  \"while\",      \"with\",     \"let\",\n      \"undefined\", NULL};\n  int i;\n  if (!mjs_is_alpha(s[0])) return 0;\n  for (i = 0; reserved[i] != NULL; i++) {\n    if (len == (int) strlen(reserved[i]) && strncmp(s, reserved[i], len) == 0)\n      return i + 1;\n  }\n  return 0;\n}\n\nstatic int getident(struct pstate *p) {\n  while (mjs_is_ident(p->pos[0]) || mjs_is_digit(p->pos[0])) p->pos++;\n  p->tok.len = p->pos - p->tok.ptr;\n  p->pos--;\n  return TOK_IDENT;\n}\n\nstatic int getstr(struct pstate *p) {\n  int quote = *p->pos++;\n  p->tok.ptr++;\n  while (p->pos[0] != '\\0' && p->pos[0] != quote) {\n    if (p->pos[0] == '\\\\' && p->pos[1] != '\\0' &&\n        (p->pos[1] == quote || strchr(\"bfnrtv\\\\\", p->pos[1]) != NULL)) {\n      p->pos += 2;\n    } else {\n      p->pos++;\n    }\n  }\n  p->tok.len = p->pos - p->tok.ptr;\n  return TOK_STR;\n}\n\nstatic void skip_spaces_and_comments(struct pstate *p) {\n  const char *pos;\n  do {\n    pos = p->pos;\n    while (mjs_is_space(p->pos[0])) {\n      if (p->pos[0] == '\\n') p->line_no++;\n      p->pos++;\n    }\n    if (p->pos[0] == '/' && p->pos[1] == '/') {\n      while (p->pos[0] != '\\0' && p->pos[0] != '\\n') p->pos++;\n    }\n    if (p->pos[0] == '/' && p->pos[1] == '*') {\n      p->pos += 2;\n      while (p->pos[0] != '\\0') {\n        if (p->pos[0] == '\\n') p->line_no++;\n        if (p->pos[0] == '*' && p->pos[1] == '/') {\n          p->pos += 2;\n          break;\n        }\n        p->pos++;\n      }\n    }\n  } while (pos < p->pos);\n}\n\nstatic int ptranslate(int tok) {\n#define DT(a, b) ((a) << 8 | (b))\n#define TT(a, b, c) ((a) << 16 | (b) << 8 | (c))\n#define QT(a, b, c, d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))\n  /* Map token ID produced by mjs_tok.c to token ID produced by lemon */\n  /* clang-format off */\n  switch (tok) {\n    case ':': return TOK_COLON;\n    case ';': return TOK_SEMICOLON;\n    case ',': return TOK_COMMA;\n    case '=': return TOK_ASSIGN;\n    case '{': return TOK_OPEN_CURLY;\n    case '}': return TOK_CLOSE_CURLY;\n    case '(': return TOK_OPEN_PAREN;\n    case ')': return TOK_CLOSE_PAREN;\n    case '[': return TOK_OPEN_BRACKET;\n    case ']': return TOK_CLOSE_BRACKET;\n    case '*': return TOK_MUL;\n    case '+': return TOK_PLUS;\n    case '-': return TOK_MINUS;\n    case '/': return TOK_DIV;\n    case '%': return TOK_REM;\n    case '&': return TOK_AND;\n    case '|': return TOK_OR;\n    case '^': return TOK_XOR;\n    case '.': return TOK_DOT;\n    case '?': return TOK_QUESTION;\n    case '!': return TOK_NOT;\n    case '~': return TOK_TILDA;\n    case '<': return TOK_LT;\n    case '>': return TOK_GT;\n    case DT('<','<'): return TOK_LSHIFT;\n    case DT('>','>'): return TOK_RSHIFT;\n    case DT('-','-'): return TOK_MINUS_MINUS;\n    case DT('+','+'): return TOK_PLUS_PLUS;\n    case DT('+','='): return TOK_PLUS_ASSIGN;\n    case DT('-','='): return TOK_MINUS_ASSIGN;\n    case DT('*','='): return TOK_MUL_ASSIGN;\n    case DT('/','='): return TOK_DIV_ASSIGN;\n    case DT('&','='): return TOK_AND_ASSIGN;\n    case DT('|','='): return TOK_OR_ASSIGN;\n    case DT('%','='): return TOK_REM_ASSIGN;\n    case DT('^','='): return TOK_XOR_ASSIGN;\n    case DT('=','='): return TOK_EQ;\n    case DT('!','='): return TOK_NE;\n    case DT('<','='): return TOK_LE;\n    case DT('>','='): return TOK_GE;\n    case DT('&','&'): return TOK_LOGICAL_AND;\n    case DT('|','|'): return TOK_LOGICAL_OR;\n    case TT('=','=','='): return TOK_EQ_EQ;\n    case TT('!','=','='): return TOK_NE_NE;\n    case TT('<','<','='): return TOK_LSHIFT_ASSIGN;\n    case TT('>','>','='): return TOK_RSHIFT_ASSIGN;\n    case TT('>','>','>'): return TOK_URSHIFT;\n    case QT('>','>','>','='): return TOK_URSHIFT_ASSIGN;\n  }\n  /* clang-format on */\n  return tok;\n}\n\nMJS_PRIVATE int pnext(struct pstate *p) {\n  int tmp, tok = TOK_INVALID;\n\n  skip_spaces_and_comments(p);\n  p->tok.ptr = p->pos;\n  p->tok.len = 1;\n\n  if (p->pos[0] == '\\0') {\n    tok = TOK_EOF;\n  } else if (mjs_is_digit(p->pos[0])) {\n    tok = getnum(p);\n  } else if (p->pos[0] == '\\'' || p->pos[0] == '\"') {\n    tok = getstr(p);\n  } else if (mjs_is_ident(p->pos[0])) {\n    tok = getident(p);\n    /*\n     * NOTE: getident() has side effects on `p`, and `is_reserved_word_token()`\n     * relies on them. Since in C the order of evaluation of the operands is\n     * undefined, `is_reserved_word_token()` should be called in a separate\n     * statement.\n     */\n    tok += is_reserved_word_token(p->tok.ptr, p->tok.len);\n  } else if (strchr(\",.:;{}[]()?\", p->pos[0]) != NULL) {\n    tok = p->pos[0];\n  } else if ((tmp = longtok3(p, '<', '<', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '>', '>', '=')) != TOK_EOF ||\n             (tmp = longtok4(p, '>', '>', '>', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '>', '>', '>')) != TOK_EOF ||\n             (tmp = longtok3(p, '=', '=', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '!', '=', '=')) != TOK_EOF ||\n             (tmp = longtok(p, \"&\", \"&=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"|\", \"|=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"<\", \"<=\")) != TOK_EOF ||\n             (tmp = longtok(p, \">\", \">=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"-\", \"-=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"+\", \"+=\")) != TOK_EOF) {\n    tok = tmp;\n  } else if ((tmp = longtok(p, \"^~+-%/*<>=!|&\", \"=\")) != TOK_EOF) {\n    tok = tmp;\n  }\n  if (p->pos[0] != '\\0') p->pos++;\n  LOG(LL_VERBOSE_DEBUG, (\"  --> %d [%.*s]\", tok, p->tok.len, p->tok.ptr));\n  p->prev_tok = p->tok.tok;\n  p->tok.tok = ptranslate(tok);\n  return p->tok.tok;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util.c\"\n#endif\n\n/* Amalgamated: #include \"common/cs_varint.h\" */\n/* Amalgamated: #include \"frozen.h\" */\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nconst char *mjs_typeof(mjs_val_t v) {\n  return mjs_stringify_type(mjs_get_type(v));\n}\n\nMJS_PRIVATE const char *mjs_stringify_type(enum mjs_type t) {\n  switch (t) {\n    case MJS_TYPE_NUMBER:\n      return \"number\";\n    case MJS_TYPE_BOOLEAN:\n      return \"boolean\";\n    case MJS_TYPE_STRING:\n      return \"string\";\n    case MJS_TYPE_OBJECT_ARRAY:\n      return \"array\";\n    case MJS_TYPE_OBJECT_GENERIC:\n      return \"object\";\n    case MJS_TYPE_FOREIGN:\n      return \"foreign_ptr\";\n    case MJS_TYPE_OBJECT_FUNCTION:\n      return \"function\";\n    case MJS_TYPE_NULL:\n      return \"null\";\n    case MJS_TYPE_UNDEFINED:\n      return \"undefined\";\n    default:\n      return \"???\";\n  }\n}\n\nvoid mjs_jprintf(mjs_val_t v, struct mjs *mjs, struct json_out *out) {\n  if (mjs_is_number(v)) {\n    double iv, d = mjs_get_double(mjs, v);\n    if (modf(d, &iv) == 0) {\n      json_printf(out, \"%\" INT64_FMT, (int64_t) d);\n    } else {\n      json_printf(out, \"%f\", mjs_get_double(mjs, v));\n    }\n  } else if (mjs_is_boolean(v)) {\n    json_printf(out, \"%s\", mjs_get_bool(mjs, v) ? \"true\" : \"false\");\n  } else if (mjs_is_string(v)) {\n    size_t i, size;\n    const char *s = mjs_get_string(mjs, &v, &size);\n    for (i = 0; i < size; i++) {\n      int ch = ((unsigned char *) s)[i];\n      if (isprint(ch)) {\n        json_printf(out, \"%c\", ch);\n      } else {\n        json_printf(out, \"%s%02x\", \"\\\\x\", ch);\n      }\n    }\n  } else if (mjs_is_array(v)) {\n    json_printf(out, \"%s\", \"<array>\");\n  } else if (mjs_is_object(v)) {\n    json_printf(out, \"%s\", \"<object>\");\n  } else if (mjs_is_foreign(v)) {\n    json_printf(out, \"%s%lx%s\", \"<foreign_ptr@\",\n                (unsigned long) (uintptr_t) mjs_get_ptr(mjs, v), \">\");\n  } else if (mjs_is_function(v)) {\n    json_printf(out, \"%s%d%s\", \"<function@\", (int) mjs_get_func_addr(v), \">\");\n  } else if (mjs_is_null(v)) {\n    json_printf(out, \"%s\", \"null\");\n  } else if (mjs_is_undefined(v)) {\n    json_printf(out, \"%s\", \"undefined\");\n  } else {\n    json_printf(out, \"%s%\" INT64_FMT \"%s\", \"<???\", (int64_t) v, \">\");\n  }\n}\n\nvoid mjs_sprintf(mjs_val_t v, struct mjs *mjs, char *buf, size_t n) {\n  struct json_out out = JSON_OUT_BUF(buf, n);\n  mjs_jprintf(v, mjs, &out);\n}\n\nvoid mjs_fprintf(mjs_val_t v, struct mjs *mjs, FILE *fp) {\n  struct json_out out = JSON_OUT_FILE(fp);\n  mjs_jprintf(v, mjs, &out);\n}\n\n#if MJS_ENABLE_DEBUG\n\nMJS_PRIVATE const char *opcodetostr(uint8_t opcode) {\n  static const char *names[] = {\n      \"NOP\", \"DROP\", \"DUP\", \"SWAP\", \"JMP\", \"JMP_TRUE\", \"JMP_NEUTRAL_TRUE\",\n      \"JMP_FALSE\", \"JMP_NEUTRAL_FALSE\", \"FIND_SCOPE\", \"PUSH_SCOPE\", \"PUSH_STR\",\n      \"PUSH_TRUE\", \"PUSH_FALSE\", \"PUSH_INT\", \"PUSH_DBL\", \"PUSH_NULL\",\n      \"PUSH_UNDEF\", \"PUSH_OBJ\", \"PUSH_ARRAY\", \"PUSH_FUNC\", \"PUSH_THIS\", \"GET\",\n      \"CREATE\", \"EXPR\", \"APPEND\", \"SET_ARG\", \"NEW_SCOPE\", \"DEL_SCOPE\", \"CALL\",\n      \"RETURN\", \"LOOP\", \"BREAK\", \"CONTINUE\", \"SETRETVAL\", \"EXIT\", \"BCODE_HDR\",\n      \"ARGS\", \"FOR_IN_NEXT\",\n  };\n  const char *name = \"???\";\n  assert(ARRAY_SIZE(names) == OP_MAX);\n  if (opcode < ARRAY_SIZE(names)) name = names[opcode];\n  return name;\n}\n\nMJS_PRIVATE size_t mjs_disasm_single(const uint8_t *code, size_t i) {\n  char buf[40];\n  size_t start_i = i;\n  size_t llen;\n  uint64_t n;\n\n  snprintf(buf, sizeof(buf), \"\\t%-3u %-8s\", (unsigned) i, opcodetostr(code[i]));\n\n  switch (code[i]) {\n    case OP_PUSH_FUNC: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s %04u\", buf, (unsigned) (i - n)));\n      i += llen;\n      break;\n    }\n    case OP_PUSH_INT: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t%lu\", buf, (unsigned long) n));\n      i += llen;\n      break;\n    }\n    case OP_SET_ARG: {\n      size_t llen2;\n      uint64_t arg_no;\n      cs_varint_decode(&code[i + 1], ~0, &arg_no, &llen);\n      cs_varint_decode(&code[i + llen + 1], ~0, &n, &llen2);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%.*s] %u\", buf, (int) n,\n                             code + i + 1 + llen + llen2, (unsigned) arg_no));\n      i += llen + llen2 + n;\n      break;\n    }\n    case OP_PUSH_STR:\n    case OP_PUSH_DBL: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%.*s]\", buf, (int) n, code + i + 1 + llen));\n      i += llen + n;\n      break;\n    }\n    case OP_JMP:\n    case OP_JMP_TRUE:\n    case OP_JMP_NEUTRAL_TRUE:\n    case OP_JMP_FALSE:\n    case OP_JMP_NEUTRAL_FALSE: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG,\n          (\"%s\\t%u\", buf,\n           (unsigned) (i + n + llen +\n                       1 /* becaue i will be incremented on the usual terms */)));\n      i += llen;\n      break;\n    }\n    case OP_LOOP: {\n      size_t l1, l2;\n      uint64_t n1, n2;\n      cs_varint_decode(&code[i + 1], ~0, &n1, &l1);\n      cs_varint_decode(&code[i + l1 + 1], ~0, &n2, &l2);\n      LOG(LL_VERBOSE_DEBUG,\n          (\"%s\\tB:%lu C:%lu (%d)\", buf,\n           (unsigned long) (i + 1 /* OP_LOOP */ + l1 + n1),\n           (unsigned long) (i + 1 /* OP_LOOP */ + l1 + l2 + n2), (int) i));\n      i += l1 + l2;\n      break;\n    }\n    case OP_EXPR: {\n      int op = code[i + 1];\n      const char *name = \"???\";\n      /* clang-format off */\n      switch (op) {\n        case TOK_DOT:       name = \".\"; break;\n        case TOK_MINUS:     name = \"-\"; break;\n        case TOK_PLUS:      name = \"+\"; break;\n        case TOK_MUL:       name = \"*\"; break;\n        case TOK_DIV:       name = \"/\"; break;\n        case TOK_REM:       name = \"%\"; break;\n        case TOK_XOR:       name = \"^\"; break;\n        case TOK_AND:       name = \"&\"; break;\n        case TOK_OR:        name = \"|\"; break;\n        case TOK_LSHIFT:    name = \"<<\"; break;\n        case TOK_RSHIFT:    name = \">>\"; break;\n        case TOK_URSHIFT:   name = \">>>\"; break;\n        case TOK_UNARY_MINUS:   name = \"- (unary)\"; break;\n        case TOK_UNARY_PLUS:    name = \"+ (unary)\"; break;\n        case TOK_NOT:       name = \"!\"; break;\n        case TOK_TILDA:     name = \"~\"; break;\n        case TOK_EQ:        name = \"==\"; break;\n        case TOK_NE:        name = \"!=\"; break;\n        case TOK_EQ_EQ:     name = \"===\"; break;\n        case TOK_NE_NE:     name = \"!==\"; break;\n        case TOK_LT:        name = \"<\"; break;\n        case TOK_GT:        name = \">\"; break;\n        case TOK_LE:        name = \"<=\"; break;\n        case TOK_GE:        name = \">=\"; break;\n        case TOK_ASSIGN:    name = \"=\"; break;\n        case TOK_POSTFIX_PLUS:  name = \"++ (postfix)\"; break;\n        case TOK_POSTFIX_MINUS: name = \"-- (postfix)\"; break;\n        case TOK_MINUS_MINUS:   name = \"--\"; break;\n        case TOK_PLUS_PLUS:     name = \"++\"; break;\n        case TOK_LOGICAL_AND:   name = \"&&\"; break;\n        case TOK_LOGICAL_OR:    name = \"||\"; break;\n        case TOK_KEYWORD_TYPEOF:  name = \"typeof\"; break;\n        case TOK_PLUS_ASSIGN:     name = \"+=\"; break;\n        case TOK_MINUS_ASSIGN:    name = \"-=\"; break;\n        case TOK_MUL_ASSIGN:      name = \"*=\"; break;\n        case TOK_DIV_ASSIGN:      name = \"/=\"; break;\n        case TOK_REM_ASSIGN:      name = \"%=\"; break;\n        case TOK_XOR_ASSIGN:      name = \"^=\"; break;\n        case TOK_AND_ASSIGN:      name = \"&=\"; break;\n        case TOK_OR_ASSIGN:       name = \"|=\"; break;\n        case TOK_LSHIFT_ASSIGN:   name = \"<<=\"; break;\n        case TOK_RSHIFT_ASSIGN:   name = \">>=\"; break;\n        case TOK_URSHIFT_ASSIGN:  name = \">>>=\"; break;\n      }\n      /* clang-format on */\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t%s\", buf, name));\n      i++;\n      break;\n    }\n    case OP_BCODE_HEADER: {\n      size_t start = 0;\n      mjs_header_item_t map_offset = 0, total_size = 0;\n      start = i;\n      memcpy(&total_size, &code[i + 1], sizeof(total_size));\n      memcpy(&map_offset,\n             &code[i + 1 + MJS_HDR_ITEM_MAP_OFFSET * sizeof(total_size)],\n             sizeof(map_offset));\n      i += sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT;\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%s] end:%lu map_offset: %lu\", buf,\n                             &code[i + 1], (unsigned long) start + total_size,\n                             (unsigned long) start + map_offset));\n      i += strlen((char *) (code + i + 1)) + 1;\n      break;\n    }\n    default:\n      LOG(LL_VERBOSE_DEBUG, (\"%s\", buf));\n      break;\n  }\n  return i - start_i;\n}\n\nvoid mjs_disasm(const uint8_t *code, size_t len) {\n  size_t i, start = 0;\n  mjs_header_item_t map_offset = 0, total_size = 0;\n\n  for (i = 0; i < len; i++) {\n    size_t delta = mjs_disasm_single(code, i);\n    if (code[i] == OP_BCODE_HEADER) {\n      start = i;\n      memcpy(&total_size, &code[i + 1], sizeof(total_size));\n      memcpy(&map_offset,\n             &code[i + 1 + MJS_HDR_ITEM_MAP_OFFSET * sizeof(total_size)],\n             sizeof(map_offset));\n    }\n\n    i += delta;\n\n    if (map_offset > 0 && i == start + map_offset) {\n      i = start + total_size - 1;\n      continue;\n    }\n  }\n}\n\nstatic void mjs_dump_obj_stack(const char *name, const struct mbuf *m,\n                               struct mjs *mjs) {\n  char buf[50];\n  size_t i, n;\n  n = mjs_stack_size(m);\n  LOG(LL_VERBOSE_DEBUG, (\"%12s (%d elems): \", name, (int) n));\n  for (i = 0; i < n; i++) {\n    mjs_sprintf(((mjs_val_t *) m->buf)[i], mjs, buf, sizeof(buf));\n    LOG(LL_VERBOSE_DEBUG, (\"%34s\", buf));\n  }\n}\n\nvoid mjs_dump(struct mjs *mjs, int do_disasm) {\n  LOG(LL_VERBOSE_DEBUG, (\"------- MJS VM DUMP BEGIN\"));\n  mjs_dump_obj_stack(\"DATA_STACK\", &mjs->stack, mjs);\n  mjs_dump_obj_stack(\"CALL_STACK\", &mjs->call_stack, mjs);\n  mjs_dump_obj_stack(\"SCOPES\", &mjs->scopes, mjs);\n  mjs_dump_obj_stack(\"LOOP_OFFSETS\", &mjs->loop_addresses, mjs);\n  mjs_dump_obj_stack(\"ARG_STACK\", &mjs->arg_stack, mjs);\n  if (do_disasm) {\n    int parts_cnt = mjs_bcode_parts_cnt(mjs);\n    int i;\n    LOG(LL_VERBOSE_DEBUG, (\"%23s\", \"CODE:\"));\n    for (i = 0; i < parts_cnt; i++) {\n      struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n      mjs_disasm((uint8_t *) bp->data.p, bp->data.len);\n    }\n  }\n  LOG(LL_VERBOSE_DEBUG, (\"------- MJS VM DUMP END\"));\n}\n\n#endif\n\nMJS_PRIVATE int mjs_check_arg(struct mjs *mjs, int arg_num,\n                              const char *arg_name, enum mjs_type expected_type,\n                              mjs_val_t *parg) {\n  mjs_val_t arg = MJS_UNDEFINED;\n  enum mjs_type actual_type;\n\n  if (arg_num >= 0) {\n    int nargs = mjs_nargs(mjs);\n    if (nargs < arg_num + 1) {\n      mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing argument %s\", arg_name);\n      return 0;\n    }\n\n    arg = mjs_arg(mjs, arg_num);\n  } else {\n    /* use `this` */\n    arg = mjs->vals.this_obj;\n  }\n\n  actual_type = mjs_get_type(arg);\n  if (actual_type != expected_type) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"%s should be a %s, %s given\",\n                       arg_name, mjs_stringify_type(expected_type),\n                       mjs_stringify_type(actual_type));\n    return 0;\n  }\n\n  if (parg != NULL) {\n    *parg = arg;\n  }\n\n  return 1;\n}\n\nMJS_PRIVATE int mjs_normalize_idx(int idx, int size) {\n  if (idx < 0) {\n    idx = size + idx;\n    if (idx < 0) {\n      idx = 0;\n    }\n  }\n  if (idx > size) {\n    idx = size;\n  }\n  return idx;\n}\n\nMJS_PRIVATE const char *mjs_get_bcode_filename(struct mjs *mjs,\n                                               struct mjs_bcode_part *bp) {\n  (void) mjs;\n  return bp->data.p + 1 /* OP_BCODE_HEADER */ +\n         sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT;\n}\n\nconst char *mjs_get_bcode_filename_by_offset(struct mjs *mjs, int offset) {\n  const char *ret = NULL;\n  struct mjs_bcode_part *bp = mjs_bcode_part_get_by_offset(mjs, offset);\n  if (bp != NULL) {\n    ret = mjs_get_bcode_filename(mjs, bp);\n  }\n  return ret;\n}\n\nint mjs_get_lineno_by_offset(struct mjs *mjs, int offset) {\n  size_t llen;\n  uint64_t map_len;\n  int prev_line_no, ret = 1;\n  struct mjs_bcode_part *bp = mjs_bcode_part_get_by_offset(mjs, offset);\n  uint8_t *p, *pe;\n  if (bp != NULL) {\n    mjs_header_item_t map_offset, bcode_offset;\n    memcpy(&map_offset, bp->data.p + 1 /* OP_BCODE_HEADER */ +\n                            sizeof(mjs_header_item_t) * MJS_HDR_ITEM_MAP_OFFSET,\n           sizeof(map_offset));\n\n    memcpy(&bcode_offset,\n           bp->data.p + 1 /* OP_BCODE_HEADER */ +\n               sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n           sizeof(bcode_offset));\n\n    offset -= (1 /* OP_BCODE_HEADER */ + bcode_offset) + bp->start_idx;\n\n    /* get pointer to the length of the map followed by the map itself */\n    p = (uint8_t *) bp->data.p + 1 /* OP_BCODE_HEADER */ + map_offset;\n\n    cs_varint_decode(p, ~0, &map_len, &llen);\n    p += llen;\n    pe = p + map_len;\n\n    prev_line_no = 1;\n    while (p < pe) {\n      uint64_t cur_offset, line_no;\n      cs_varint_decode(p, ~0, &cur_offset, &llen);\n      p += llen;\n      cs_varint_decode(p, ~0, &line_no, &llen);\n      p += llen;\n\n      if (cur_offset >= (uint64_t) offset) {\n        ret = prev_line_no;\n        break;\n      }\n      prev_line_no = line_no;\n    }\n  }\n  return ret;\n}\n\nint mjs_get_offset_by_call_frame_num(struct mjs *mjs, int cf_num) {\n  int ret = -1;\n  if (cf_num == 0) {\n    /* Return current bcode offset */\n    ret = mjs->cur_bcode_offset;\n  } else if (cf_num > 0 &&\n             mjs->call_stack.len >=\n                 sizeof(mjs_val_t) * CALL_STACK_FRAME_ITEMS_CNT * cf_num) {\n    /* Get offset from the call_stack */\n    int pos = CALL_STACK_FRAME_ITEM_RETURN_ADDR +\n              CALL_STACK_FRAME_ITEMS_CNT * (cf_num - 1);\n    mjs_val_t val = *vptr(&mjs->call_stack, -1 - pos);\n    ret = mjs_get_int(mjs, val);\n  }\n  return ret;\n}\n"
        },
        {
          "name": "mjs.h",
          "type": "blob",
          "size": 28.7451171875,
          "content": "/*\n * Copyright (c) 2017 Cesanta Software Limited\n * All rights reserved\n *\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_features.h\"\n#endif\n\n#ifndef MJS_FEATURES_H_\n#define MJS_FEATURES_H_\n\n#if !defined(MJS_AGGRESSIVE_GC)\n#define MJS_AGGRESSIVE_GC 0\n#endif\n\n#if !defined(MJS_MEMORY_STATS)\n#define MJS_MEMORY_STATS 0\n#endif\n\n/*\n * MJS_GENERATE_JSC: if enabled, and if mmapping is also enabled (CS_MMAP),\n * then execution of any .js file will result in creation of a .jsc file with\n * precompiled bcode, and this .jsc file will be mmapped, instead of keeping\n * bcode in RAM.\n *\n * By default it's enabled (provided that CS_MMAP is defined)\n */\n#if !defined(MJS_GENERATE_JSC)\n#if defined(CS_MMAP)\n#define MJS_GENERATE_JSC 1\n#else\n#define MJS_GENERATE_JSC 0\n#endif\n#endif\n\n#endif /* MJS_FEATURES_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core_public.h\"\n#endif\n\n#ifndef MJS_CORE_PUBLIC_H_\n#define MJS_CORE_PUBLIC_H_\n\n#if !defined(_MSC_VER) || _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef unsigned __int64 uint64_t;\ntypedef int int32_t;\ntypedef unsigned char uint8_t;\n#endif\n#include <stdio.h>\n#include <stddef.h>\n/* Amalgamated: #include \"mjs_features.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MJS_ENABLE_DEBUG\n#define MJS_ENABLE_DEBUG 0\n#endif\n\n/*\n *  Double-precision floating-point number, IEEE 754\n *\n *  64 bit (8 bytes) in total\n *  1  bit sign\n *  11 bits exponent\n *  52 bits mantissa\n *      7         6        5        4        3        2        1        0\n *  seeeeeee|eeeemmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm\n *\n * If an exponent is all-1 and mantissa is all-0, then it is an INFINITY:\n *  11111111|11110000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n * If an exponent is all-1 and mantissa's MSB is 1, it is a quiet NaN:\n *  11111111|11111000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n *  MJS NaN-packing:\n *    sign and exponent is 0xfff\n *    4 bits specify type (tag), must be non-zero\n *    48 bits specify value\n *\n *  11111111|1111tttt|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv\n *   NaN marker |type|  48-bit placeholder for values: pointers, strings\n *\n * On 64-bit platforms, pointers are really 48 bit only, so they can fit,\n * provided they are sign extended\n */\n\ntypedef uint64_t mjs_val_t;\n\n/* This if-0 is a dirty workaround to force etags to pick `struct mjs` */\n#if 0\n/* Opaque structure. MJS engine context. */\nstruct mjs {\n  /* ... */\n};\n#endif\n\nstruct mjs;\n\ntypedef enum mjs_err {\n  MJS_OK,\n  MJS_SYNTAX_ERROR,\n  MJS_REFERENCE_ERROR,\n  MJS_TYPE_ERROR,\n  MJS_OUT_OF_MEMORY,\n  MJS_INTERNAL_ERROR,\n  MJS_NOT_IMPLEMENTED_ERROR,\n  MJS_FILE_READ_ERROR,\n  MJS_BAD_ARGS_ERROR,\n\n  MJS_ERRS_CNT\n} mjs_err_t;\nstruct mjs;\n\n/* Create MJS instance */\nstruct mjs *mjs_create();\n\nstruct mjs_create_opts {\n  /* use non-default bytecode definition file, testing-only */\n  const struct bf_code *code;\n};\n\n/*\n * Like `msj_create()`, but allows to customize initial MJS state, see `struct\n * mjs_create_opts`.\n */\nstruct mjs *mjs_create_opt(struct mjs_create_opts opts);\n\n/* Destroy MJS instance */\nvoid mjs_destroy(struct mjs *mjs);\n\nmjs_val_t mjs_get_global(struct mjs *mjs);\n\n/*\n * Tells the GC about an MJS value variable/field owned by C code.\n *\n * The user's C code should own mjs_val_t variables if the value's lifetime\n * crosses any invocation of `mjs_exec()` and friends, including `mjs_call()`.\n *\n * The registration of the variable prevents the GC from mistakenly treat the\n * object as garbage.\n *\n * User code should also explicitly disown the variables with `mjs_disown()`\n * once it goes out of scope or the structure containing the mjs_val_t field is\n * freed.\n *\n * Consider the following examples:\n *\n * Correct (owning is not necessary):\n * ```c\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script\", &res);\n * // ... use res somehow\n *\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script2\", &res);\n * // ... use new res somehow\n * ```\n *\n * WRONG:\n * ```c\n * mjs_val_t res1;\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 (WRONG!) and res2\n * ```\n *\n * The code above is wrong, because after the second invocation of\n * `mjs_exec()`, the value of `res1` is invalidated.\n *\n * Correct (res1 is owned)\n * ```c\n * mjs_val_t res1 = MJS_UNDEFINED;\n * mjs_own(mjs, &res1);\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2 = MJS_UNDEFINED;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 and res2\n * mjs_disown(mjs, &res1);\n * ```\n *\n * NOTE that we explicly initialized `res1` to a valid value before owning it\n * (in this case, the value is `MJS_UNDEFINED`). Owning an uninitialized\n * variable is an undefined behaviour.\n *\n * Of course, it's not an error to own a variable even if it's not mandatory:\n * e.g. in the last example we could own both `res1` and `res2`. Probably it\n * would help us in the future, when we refactor the code so that `res2` has to\n * be owned, and we could forget to do that.\n *\n * Also, if the user code has some C function called from MJS, and in this C\n * function some MJS value (`mjs_val_t`) needs to be stored somewhere and to\n * stay alive after the C function has returned, it also needs to be properly\n * owned.\n */\nvoid mjs_own(struct mjs *mjs, mjs_val_t *v);\n\n/*\n * Disowns the value previously owned by `mjs_own()`.\n *\n * Returns 1 if value is found, 0 otherwise.\n */\nint mjs_disown(struct mjs *mjs, mjs_val_t *v);\n\nmjs_err_t mjs_set_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt, ...);\n\n/*\n * If there is no error message already set, then it's equal to\n * `mjs_set_errorf()`.\n *\n * Otherwise, an old message gets prepended with the new one, followed by a\n * colon. (the previously set error code is kept)\n */\nmjs_err_t mjs_prepend_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt,\n                             ...);\n\n/*\n * Print the last error details. If print_stack_trace is non-zero, also\n * print stack trace. `msg` is the message which gets prepended to the actual\n * error message, if it's NULL, then \"MJS error\" is used.\n */\nvoid mjs_print_error(struct mjs *mjs, FILE *fp, const char *msg,\n                     int print_stack_trace);\n\n/*\n * return a string representation of an error.\n * the error string might be overwritten by calls to `mjs_set_errorf`.\n */\nconst char *mjs_strerror(struct mjs *mjs, enum mjs_err err);\n\n/*\n * Sets whether *.jsc files are generated when *.js file is executed. By\n * default it's 0.\n *\n * If either `MJS_GENERATE_JSC` or `CS_MMAP` is off, then this function has no\n * effect.\n */\nvoid mjs_set_generate_jsc(struct mjs *mjs, int generate_jsc);\n\n/*\n * When invoked from a cfunction, returns number of arguments passed to the\n * current JS function call.\n */\nint mjs_nargs(struct mjs *mjs);\n\n/*\n * When invoked from a cfunction, returns n-th argument to the current JS\n * function call.\n */\nmjs_val_t mjs_arg(struct mjs *mjs, int n);\n\n/*\n * Sets return value for the current JS function call.\n */\nvoid mjs_return(struct mjs *mjs, mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CORE_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi_public.h\"\n#endif\n\n#ifndef MJS_FFI_PUBLIC_H_\n#define MJS_FFI_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum mjs_ffi_ctype {\n  MJS_FFI_CTYPE_NONE,\n  MJS_FFI_CTYPE_USERDATA,\n  MJS_FFI_CTYPE_CALLBACK,\n  MJS_FFI_CTYPE_INT,\n  MJS_FFI_CTYPE_BOOL,\n  MJS_FFI_CTYPE_DOUBLE,\n  MJS_FFI_CTYPE_FLOAT,\n  MJS_FFI_CTYPE_CHAR_PTR,\n  MJS_FFI_CTYPE_VOID_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR,\n  MJS_FFI_CTYPE_INVALID,\n};\n\ntypedef void *(mjs_ffi_resolver_t)(void *handle, const char *symbol);\n\nvoid mjs_set_ffi_resolver(struct mjs *mjs, mjs_ffi_resolver_t *dlsym);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array_public.h\"\n#endif\n\n/*\n * === Arrays\n */\n\n#ifndef MJS_ARRAY_PUBLIC_H_\n#define MJS_ARRAY_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* Make an empty array object */\nmjs_val_t mjs_mk_array(struct mjs *mjs);\n\n/* Returns length on an array. If `arr` is not an array, 0 is returned. */\nunsigned long mjs_array_length(struct mjs *mjs, mjs_val_t arr);\n\n/* Insert value `v` in array `arr` at the end of the array. */\nmjs_err_t mjs_array_push(struct mjs *mjs, mjs_val_t arr, mjs_val_t v);\n\n/*\n * Return array member at index `index`. If `index` is out of bounds, undefined\n * is returned.\n */\nmjs_val_t mjs_array_get(struct mjs *, mjs_val_t arr, unsigned long index);\n\n/* Insert value `v` into `arr` at index `index`. */\nmjs_err_t mjs_array_set(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                        mjs_val_t v);\n\n/* Returns true if the given value is an array */\nint mjs_is_array(mjs_val_t v);\n\n/* Delete value in array `arr` at index `index`, if it exists. */\nvoid mjs_array_del(struct mjs *mjs, mjs_val_t arr, unsigned long index);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_ARRAY_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core_public.h\"\n#endif\n\n#ifndef MJS_CORE_PUBLIC_H_\n#define MJS_CORE_PUBLIC_H_\n\n#if !defined(_MSC_VER) || _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef unsigned __int64 uint64_t;\ntypedef int int32_t;\ntypedef unsigned char uint8_t;\n#endif\n#include <stdio.h>\n#include <stddef.h>\n/* Amalgamated: #include \"mjs_features.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MJS_ENABLE_DEBUG\n#define MJS_ENABLE_DEBUG 0\n#endif\n\n/*\n *  Double-precision floating-point number, IEEE 754\n *\n *  64 bit (8 bytes) in total\n *  1  bit sign\n *  11 bits exponent\n *  52 bits mantissa\n *      7         6        5        4        3        2        1        0\n *  seeeeeee|eeeemmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm\n *\n * If an exponent is all-1 and mantissa is all-0, then it is an INFINITY:\n *  11111111|11110000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n * If an exponent is all-1 and mantissa's MSB is 1, it is a quiet NaN:\n *  11111111|11111000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n *  MJS NaN-packing:\n *    sign and exponent is 0xfff\n *    4 bits specify type (tag), must be non-zero\n *    48 bits specify value\n *\n *  11111111|1111tttt|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv\n *   NaN marker |type|  48-bit placeholder for values: pointers, strings\n *\n * On 64-bit platforms, pointers are really 48 bit only, so they can fit,\n * provided they are sign extended\n */\n\ntypedef uint64_t mjs_val_t;\n\n/* This if-0 is a dirty workaround to force etags to pick `struct mjs` */\n#if 0\n/* Opaque structure. MJS engine context. */\nstruct mjs {\n  /* ... */\n};\n#endif\n\nstruct mjs;\n\ntypedef enum mjs_err {\n  MJS_OK,\n  MJS_SYNTAX_ERROR,\n  MJS_REFERENCE_ERROR,\n  MJS_TYPE_ERROR,\n  MJS_OUT_OF_MEMORY,\n  MJS_INTERNAL_ERROR,\n  MJS_NOT_IMPLEMENTED_ERROR,\n  MJS_FILE_READ_ERROR,\n  MJS_BAD_ARGS_ERROR,\n\n  MJS_ERRS_CNT\n} mjs_err_t;\nstruct mjs;\n\n/* Create MJS instance */\nstruct mjs *mjs_create();\n\nstruct mjs_create_opts {\n  /* use non-default bytecode definition file, testing-only */\n  const struct bf_code *code;\n};\n\n/*\n * Like `msj_create()`, but allows to customize initial MJS state, see `struct\n * mjs_create_opts`.\n */\nstruct mjs *mjs_create_opt(struct mjs_create_opts opts);\n\n/* Destroy MJS instance */\nvoid mjs_destroy(struct mjs *mjs);\n\nmjs_val_t mjs_get_global(struct mjs *mjs);\n\n/*\n * Tells the GC about an MJS value variable/field owned by C code.\n *\n * The user's C code should own mjs_val_t variables if the value's lifetime\n * crosses any invocation of `mjs_exec()` and friends, including `mjs_call()`.\n *\n * The registration of the variable prevents the GC from mistakenly treat the\n * object as garbage.\n *\n * User code should also explicitly disown the variables with `mjs_disown()`\n * once it goes out of scope or the structure containing the mjs_val_t field is\n * freed.\n *\n * Consider the following examples:\n *\n * Correct (owning is not necessary):\n * ```c\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script\", &res);\n * // ... use res somehow\n *\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script2\", &res);\n * // ... use new res somehow\n * ```\n *\n * WRONG:\n * ```c\n * mjs_val_t res1;\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 (WRONG!) and res2\n * ```\n *\n * The code above is wrong, because after the second invocation of\n * `mjs_exec()`, the value of `res1` is invalidated.\n *\n * Correct (res1 is owned)\n * ```c\n * mjs_val_t res1 = MJS_UNDEFINED;\n * mjs_own(mjs, &res1);\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2 = MJS_UNDEFINED;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 and res2\n * mjs_disown(mjs, &res1);\n * ```\n *\n * NOTE that we explicly initialized `res1` to a valid value before owning it\n * (in this case, the value is `MJS_UNDEFINED`). Owning an uninitialized\n * variable is an undefined behaviour.\n *\n * Of course, it's not an error to own a variable even if it's not mandatory:\n * e.g. in the last example we could own both `res1` and `res2`. Probably it\n * would help us in the future, when we refactor the code so that `res2` has to\n * be owned, and we could forget to do that.\n *\n * Also, if the user code has some C function called from MJS, and in this C\n * function some MJS value (`mjs_val_t`) needs to be stored somewhere and to\n * stay alive after the C function has returned, it also needs to be properly\n * owned.\n */\nvoid mjs_own(struct mjs *mjs, mjs_val_t *v);\n\n/*\n * Disowns the value previously owned by `mjs_own()`.\n *\n * Returns 1 if value is found, 0 otherwise.\n */\nint mjs_disown(struct mjs *mjs, mjs_val_t *v);\n\nmjs_err_t mjs_set_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt, ...);\n\n/*\n * If there is no error message already set, then it's equal to\n * `mjs_set_errorf()`.\n *\n * Otherwise, an old message gets prepended with the new one, followed by a\n * colon. (the previously set error code is kept)\n */\nmjs_err_t mjs_prepend_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt,\n                             ...);\n\n/*\n * Print the last error details. If print_stack_trace is non-zero, also\n * print stack trace. `msg` is the message which gets prepended to the actual\n * error message, if it's NULL, then \"MJS error\" is used.\n */\nvoid mjs_print_error(struct mjs *mjs, FILE *fp, const char *msg,\n                     int print_stack_trace);\n\n/*\n * return a string representation of an error.\n * the error string might be overwritten by calls to `mjs_set_errorf`.\n */\nconst char *mjs_strerror(struct mjs *mjs, enum mjs_err err);\n\n/*\n * Sets whether *.jsc files are generated when *.js file is executed. By\n * default it's 0.\n *\n * If either `MJS_GENERATE_JSC` or `CS_MMAP` is off, then this function has no\n * effect.\n */\nvoid mjs_set_generate_jsc(struct mjs *mjs, int generate_jsc);\n\n/*\n * When invoked from a cfunction, returns number of arguments passed to the\n * current JS function call.\n */\nint mjs_nargs(struct mjs *mjs);\n\n/*\n * When invoked from a cfunction, returns n-th argument to the current JS\n * function call.\n */\nmjs_val_t mjs_arg(struct mjs *mjs, int n);\n\n/*\n * Sets return value for the current JS function call.\n */\nvoid mjs_return(struct mjs *mjs, mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CORE_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec_public.h\"\n#endif\n\n#ifndef MJS_EXEC_PUBLIC_H_\n#define MJS_EXEC_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n#include <stdio.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nmjs_err_t mjs_exec(struct mjs *, const char *src, mjs_val_t *res);\nmjs_err_t mjs_exec_buf(struct mjs *, const char *src, size_t, mjs_val_t *res);\n\nmjs_err_t mjs_exec_file(struct mjs *mjs, const char *path, mjs_val_t *res);\nmjs_err_t mjs_apply(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                    mjs_val_t this_val, int nargs, mjs_val_t *args);\nmjs_err_t mjs_call(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                   mjs_val_t this_val, int nargs, ...);\nmjs_val_t mjs_get_this(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_EXEC_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi_public.h\"\n#endif\n\n#ifndef MJS_FFI_PUBLIC_H_\n#define MJS_FFI_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum mjs_ffi_ctype {\n  MJS_FFI_CTYPE_NONE,\n  MJS_FFI_CTYPE_USERDATA,\n  MJS_FFI_CTYPE_CALLBACK,\n  MJS_FFI_CTYPE_INT,\n  MJS_FFI_CTYPE_BOOL,\n  MJS_FFI_CTYPE_DOUBLE,\n  MJS_FFI_CTYPE_FLOAT,\n  MJS_FFI_CTYPE_CHAR_PTR,\n  MJS_FFI_CTYPE_VOID_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR,\n  MJS_FFI_CTYPE_INVALID,\n};\n\ntypedef void *(mjs_ffi_resolver_t)(void *handle, const char *symbol);\n\nvoid mjs_set_ffi_resolver(struct mjs *mjs, mjs_ffi_resolver_t *dlsym);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc_public.h\"\n#endif\n\n#ifndef MJS_GC_PUBLIC_H_\n#define MJS_GC_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Perform garbage collection.\n * Pass true to full in order to reclaim unused heap back to the OS.\n */\nvoid mjs_gc(struct mjs *mjs, int full);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_GC_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object_public.h\"\n#endif\n\n#ifndef MJS_OBJECT_PUBLIC_H_\n#define MJS_OBJECT_PUBLIC_H_\n\n#include <stddef.h>\n/* Amalgamated: #include \"mjs_core_public.h\" */\n/* Amalgamated: #include \"mjs_ffi_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Returns true if the given value is an object or array.\n */\nint mjs_is_object(mjs_val_t v);\n\n/* Make an empty object */\nmjs_val_t mjs_mk_object(struct mjs *mjs);\n\n/* Field types for struct-object conversion. */\nenum mjs_struct_field_type {\n  MJS_STRUCT_FIELD_TYPE_INVALID,\n  MJS_STRUCT_FIELD_TYPE_STRUCT,     /* Struct, arg points to def. */\n  MJS_STRUCT_FIELD_TYPE_STRUCT_PTR, /* Ptr to struct, arg points to def. */\n  MJS_STRUCT_FIELD_TYPE_INT,\n  MJS_STRUCT_FIELD_TYPE_BOOL,\n  MJS_STRUCT_FIELD_TYPE_DOUBLE,\n  MJS_STRUCT_FIELD_TYPE_FLOAT,\n  MJS_STRUCT_FIELD_TYPE_CHAR_PTR,   /* NUL-terminated string. */\n  MJS_STRUCT_FIELD_TYPE_VOID_PTR,   /* Converted to foreign ptr. */\n  MJS_STRUCT_FIELD_TYPE_MG_STR_PTR, /* Converted to string. */\n  MJS_STRUCT_FIELD_TYPE_MG_STR,     /* Converted to string. */\n  MJS_STRUCT_FIELD_TYPE_DATA,       /* Data, arg is length, becomes string. */\n  MJS_STRUCT_FIELD_TYPE_INT8,\n  MJS_STRUCT_FIELD_TYPE_INT16,\n  MJS_STRUCT_FIELD_TYPE_UINT8,\n  MJS_STRUCT_FIELD_TYPE_UINT16,\n  /*\n   * User-provided function. Arg is a pointer to function that takes void *\n   * (pointer to field within the struct) and returns mjs_val_t:\n   * mjs_val_t field_value(struct mjs *mjs, const void *field_ptr) { ... }\n   */\n  MJS_STRUCT_FIELD_TYPE_CUSTOM,\n};\n\n/* C structure layout descriptor - needed by mjs_struct_to_obj */\nstruct mjs_c_struct_member {\n  const char *name;\n  int offset;\n  enum mjs_struct_field_type type;\n  const void *arg; /* Additional argument, used for some types. */\n};\n\n/* Create flat JS object from a C memory descriptor */\nmjs_val_t mjs_struct_to_obj(struct mjs *mjs, const void *base,\n                            const struct mjs_c_struct_member *members);\n\n/*\n * Lookup property `name` in object `obj`. If `obj` holds no such property,\n * an `undefined` value is returned.\n *\n * If `name_len` is ~0, `name` is assumed to be NUL-terminated and\n * `strlen(name)` is used.\n */\nmjs_val_t mjs_get(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len);\n\n/*\n * Like mjs_get but with a JS string.\n */\nmjs_val_t mjs_get_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name);\n\n/*\n * Like mjs_get_v but lookup the prototype chain.\n */\nmjs_val_t mjs_get_v_proto(struct mjs *mjs, mjs_val_t obj, mjs_val_t key);\n\n/*\n * Set object property. Behaves just like JavaScript assignment.\n */\nmjs_err_t mjs_set(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len,\n                  mjs_val_t val);\n\n/*\n * Like mjs_set but the name is already a JS string.\n */\nmjs_err_t mjs_set_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name,\n                    mjs_val_t val);\n\n/*\n * Delete own property `name` of the object `obj`. Does not follow the\n * prototype chain.\n *\n * If `name_len` is ~0, `name` is assumed to be NUL-terminated and\n * `strlen(name)` is used.\n *\n * Returns 0 on success, -1 on error.\n */\nint mjs_del(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len);\n\n/*\n * Iterate over `obj` properties.\n * First call should set `iterator` to MJS_UNDEFINED.\n * Return object's key (a string), or MJS_UNDEFINED when no more keys left.\n * Do not mutate the object during iteration.\n *\n * Example:\n *   mjs_val_t key, iter = MJS_UNDEFINED;\n *   while ((key = mjs_next(mjs, obj, &iter)) != MJS_UNDEFINED) {\n *     // Do something with the obj/key ...\n *   }\n */\nmjs_val_t mjs_next(struct mjs *mjs, mjs_val_t obj, mjs_val_t *iterator);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_OBJECT_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive_public.h\"\n#endif\n\n#ifndef MJS_PRIMITIVE_PUBLIC_H_\n#define MJS_PRIMITIVE_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* JavaScript `null` value */\n#define MJS_NULL MJS_TAG_NULL\n\n/* JavaScript `undefined` value */\n#define MJS_UNDEFINED MJS_TAG_UNDEFINED\n\n/* Function pointer type used in `mjs_mk_foreign_func`. */\ntypedef void (*mjs_func_ptr_t)(void);\n\n/*\n * Make `null` primitive value.\n *\n * NOTE: this function is deprecated and will be removed in future releases.\n * Use `MJS_NULL` instead.\n */\nmjs_val_t mjs_mk_null(void);\n\n/* Returns true if given value is a primitive `null` value */\nint mjs_is_null(mjs_val_t v);\n\n/*\n * Make `undefined` primitive value.\n *\n * NOTE: this function is deprecated and will be removed in future releases.\n * Use `MJS_UNDEFINED` instead.\n */\nmjs_val_t mjs_mk_undefined(void);\n\n/* Returns true if given value is a primitive `undefined` value */\nint mjs_is_undefined(mjs_val_t v);\n\n/* Make numeric primitive value */\nmjs_val_t mjs_mk_number(struct mjs *mjs, double num);\n\n/*\n * Returns number value stored in `mjs_val_t` as `double`.\n *\n * Returns NaN for non-numbers.\n */\ndouble mjs_get_double(struct mjs *mjs, mjs_val_t v);\n\n/*\n * Returns number value stored in `mjs_val_t` as `int`. If the number value is\n * not an integer, the fraction part will be discarded.\n *\n * If the given value is a non-number, or NaN, the result is undefined.\n */\nint mjs_get_int(struct mjs *mjs, mjs_val_t v);\n\n/*\n * Like mjs_get_int but ensures that the returned type\n * is a 32-bit signed integer.\n */\nint32_t mjs_get_int32(struct mjs *mjs, mjs_val_t v);\n\n/* Returns true if given value is a primitive number value */\nint mjs_is_number(mjs_val_t v);\n\n/*\n * Make JavaScript value that holds C/C++ `void *` pointer.\n *\n * A foreign value is completely opaque and JS code cannot do anything useful\n * with it except holding it in properties and passing it around.\n * It behaves like a sealed object with no properties.\n *\n * NOTE:\n * Only valid pointers (as defined by each supported architecture) will fully\n * preserved. In particular, all supported 64-bit architectures (x86_64, ARM-64)\n * actually define a 48-bit virtual address space.\n * Foreign values will be sign-extended as required, i.e creating a foreign\n * value of something like `(void *) -1` will work as expected. This is\n * important because in some 64-bit OSs (e.g. Solaris) the user stack grows\n * downwards from the end of the address space.\n *\n * If you need to store exactly sizeof(void*) bytes of raw data where\n * `sizeof(void*)` >= 8, please use byte arrays instead.\n */\nmjs_val_t mjs_mk_foreign(struct mjs *mjs, void *ptr);\n\n/*\n * Make JavaScript value that holds C/C++ function pointer, similarly to\n * `mjs_mk_foreign`.\n */\nmjs_val_t mjs_mk_foreign_func(struct mjs *mjs, mjs_func_ptr_t fn);\n\n/*\n * Returns `void *` pointer stored in `mjs_val_t`.\n *\n * Returns NULL if the value is not a foreign pointer.\n */\nvoid *mjs_get_ptr(struct mjs *mjs, mjs_val_t v);\n\n/* Returns true if given value holds `void *` pointer */\nint mjs_is_foreign(mjs_val_t v);\n\nmjs_val_t mjs_mk_boolean(struct mjs *mjs, int v);\nint mjs_get_bool(struct mjs *mjs, mjs_val_t v);\nint mjs_is_boolean(mjs_val_t v);\n\nmjs_val_t mjs_mk_function(struct mjs *mjs, size_t off);\nint mjs_is_function(mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PRIMITIVE_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string_public.h\"\n#endif\n\n#ifndef MJS_STRING_PUBLIC_H_\n#define MJS_STRING_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#define MJS_STRING_LITERAL_MAX_LEN 128\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Creates a string primitive value.\n * `str` must point to the utf8 string of length `len`.\n * If `len` is ~0, `str` is assumed to be NUL-terminated and `strlen(str)` is\n * used.\n *\n * If `copy` is non-zero, the string data is copied and owned by the GC. The\n * caller can free the string data afterwards. Otherwise (`copy` is zero), the\n * caller owns the string data, and is responsible for not freeing it while it\n * is used.\n */\nmjs_val_t mjs_mk_string(struct mjs *mjs, const char *str, size_t len, int copy);\n\n/* Returns true if given value is a primitive string value */\nint mjs_is_string(mjs_val_t v);\n\n/*\n * Returns a pointer to the string stored in `mjs_val_t`.\n *\n * String length returned in `len`, which is allowed to be NULL. Returns NULL\n * if the value is not a string.\n *\n * JS strings can contain embedded NUL chars and may or may not be NUL\n * terminated.\n *\n * CAUTION: creating new JavaScript object, array, or string may kick in a\n * garbage collector, which in turn may relocate string data and invalidate\n * pointer returned by `mjs_get_string()`.\n *\n * Short JS strings are embedded inside the `mjs_val_t` value itself. This\n * is why a pointer to a `mjs_val_t` is required. It also means that the string\n * data will become invalid once that `mjs_val_t` value goes out of scope.\n */\nconst char *mjs_get_string(struct mjs *mjs, mjs_val_t *v, size_t *len);\n\n/*\n * Returns a pointer to the string stored in `mjs_val_t`.\n *\n * Returns NULL if the value is not a string or if the string is not compatible\n * with a C string.\n *\n * C compatible strings contain exactly one NUL char, in terminal position.\n *\n * All strings owned by the MJS engine (see `mjs_mk_string()`) are guaranteed to\n * be NUL terminated. Out of these, those that don't include embedded NUL chars\n * are guaranteed to be C compatible.\n */\nconst char *mjs_get_cstring(struct mjs *mjs, mjs_val_t *v);\n\n/*\n * Returns the standard strcmp comparison code after comparing a JS string a\n * with a possibly non null-terminated string b. NOTE: the strings are equal\n * only if their length is equal, i.e. the len field doesn't imply strncmp\n * behaviour.\n */\nint mjs_strcmp(struct mjs *mjs, mjs_val_t *a, const char *b, size_t len);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_STRING_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util_public.h\"\n#endif\n\n#ifndef MJS_UTIL_PUBLIC_H_\n#define MJS_UTIL_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n#include <stdio.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nconst char *mjs_typeof(mjs_val_t v);\n\nvoid mjs_fprintf(mjs_val_t v, struct mjs *mjs, FILE *fp);\nvoid mjs_sprintf(mjs_val_t v, struct mjs *mjs, char *buf, size_t buflen);\n\n#if MJS_ENABLE_DEBUG\n\nvoid mjs_disasm(const uint8_t *code, size_t len);\nvoid mjs_dump(struct mjs *mjs, int do_disasm);\n\n#endif\n\n/*\n * Returns the filename corresponding to the given bcode offset.\n */\nconst char *mjs_get_bcode_filename_by_offset(struct mjs *mjs, int offset);\n\n/*\n * Returns the line number corresponding to the given bcode offset.\n */\nint mjs_get_lineno_by_offset(struct mjs *mjs, int offset);\n\n/*\n * Returns bcode offset of the corresponding call frame cf_num, where 0 means\n * the currently executing function, 1 means the first return address, etc.\n *\n * If given cf_num is too large, -1 is returned.\n */\nint mjs_get_offset_by_call_frame_num(struct mjs *mjs, int cf_num);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_UTIL_PUBLIC_H_ */\n"
        },
        {
          "name": "mjs_no_common.c",
          "type": "blob",
          "size": 286.51953125,
          "content": "/*\n * Copyright (c) 2017 Cesanta Software Limited\n * All rights reserved\n *\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n#include \"mjs.h\"\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/ffi/ffi.h\"\n#endif\n\n#ifndef MJS_FFI_FFI_H_\n#define MJS_FFI_FFI_H_\n\n#include \"common/platform.h\"\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Maximum number of word-sized args to ffi-ed function. If at least one\n * of the args is double, only 2 args are allowed.\n */\n#define FFI_MAX_ARGS_CNT 6\n\ntypedef void(ffi_fn_t)(void);\n\ntypedef intptr_t ffi_word_t;\n\nenum ffi_ctype {\n  FFI_CTYPE_WORD,\n  FFI_CTYPE_BOOL,\n  FFI_CTYPE_FLOAT,\n  FFI_CTYPE_DOUBLE,\n};\n\nstruct ffi_arg {\n  enum ffi_ctype ctype;\n  union {\n    uint64_t i;\n    double d;\n    float f;\n  } v;\n};\n\nint ffi_call(ffi_fn_t *func, int nargs, struct ffi_arg *res,\n             struct ffi_arg *args);\n\nvoid ffi_set_word(struct ffi_arg *arg, ffi_word_t v);\nvoid ffi_set_bool(struct ffi_arg *arg, bool v);\nvoid ffi_set_ptr(struct ffi_arg *arg, void *v);\nvoid ffi_set_double(struct ffi_arg *arg, double v);\nvoid ffi_set_float(struct ffi_arg *arg, float v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_FFI_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_internal.h\"\n#endif\n\n#ifndef MJS_INTERNAL_H_\n#define MJS_INTERNAL_H_\n\n#include <assert.h>\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifndef FAST\n#define FAST\n#endif\n\n#ifndef STATIC\n#define STATIC\n#endif\n\n#ifndef ENDL\n#define ENDL \"\\n\"\n#endif\n\n#ifdef MJS_EXPOSE_PRIVATE\n#define MJS_PRIVATE\n#define MJS_EXTERN extern\n#else\n#define MJS_PRIVATE static\n#define MJS_EXTERN static\n#endif\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\n#if !defined(WEAK)\n#if (defined(__GNUC__) || defined(__TI_COMPILER_VERSION__)) && !defined(_WIN32)\n#define WEAK __attribute__((weak))\n#else\n#define WEAK\n#endif\n#endif\n\n#ifndef CS_ENABLE_STDIO\n#define CS_ENABLE_STDIO 1\n#endif\n\n#include \"common/cs_dbg.h\"\n#include \"common/cs_file.h\"\n#include \"common/mbuf.h\"\n\n#if defined(_WIN32) && _MSC_VER < 1700\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef __int64 int64_t;\ntypedef unsigned long uintptr_t;\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n// #define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#define isnan(x) _isnan(x)\n#define va_copy(x, y) (x) = (y)\n#define CS_DEFINE_DIRENT\n#include <windows.h>\n#else\n#if defined(__unix__) || defined(__APPLE__)\n#include <dlfcn.h>\n#endif\n#endif\n\n/*\n * Number of bytes reserved for the jump offset initially. The most practical\n * value is 1, but for testing it's useful to set it to 0 and to some large\n * value as well (like, 4), to make sure that the code behaves correctly under\n * all circumstances.\n */\n#ifndef MJS_INIT_OFFSET_SIZE\n#define MJS_INIT_OFFSET_SIZE 1\n#endif\n\n#endif /* MJS_INTERNAL_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_features.h\"\n#endif\n\n#ifndef MJS_FEATURES_H_\n#define MJS_FEATURES_H_\n\n#if !defined(MJS_AGGRESSIVE_GC)\n#define MJS_AGGRESSIVE_GC 0\n#endif\n\n#if !defined(MJS_MEMORY_STATS)\n#define MJS_MEMORY_STATS 0\n#endif\n\n/*\n * MJS_GENERATE_JSC: if enabled, and if mmapping is also enabled (CS_MMAP),\n * then execution of any .js file will result in creation of a .jsc file with\n * precompiled bcode, and this .jsc file will be mmapped, instead of keeping\n * bcode in RAM.\n *\n * By default it's enabled (provided that CS_MMAP is defined)\n */\n#if !defined(MJS_GENERATE_JSC)\n#if defined(CS_MMAP)\n#define MJS_GENERATE_JSC 1\n#else\n#define MJS_GENERATE_JSC 0\n#endif\n#endif\n\n#endif /* MJS_FEATURES_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core_public.h\"\n#endif\n\n#ifndef MJS_CORE_PUBLIC_H_\n#define MJS_CORE_PUBLIC_H_\n\n#if !defined(_MSC_VER) || _MSC_VER >= 1700\n#include <stdint.h>\n#else\ntypedef unsigned __int64 uint64_t;\ntypedef int int32_t;\ntypedef unsigned char uint8_t;\n#endif\n#include <stdio.h>\n#include <stddef.h>\n/* Amalgamated: #include \"mjs_features.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MJS_ENABLE_DEBUG\n#define MJS_ENABLE_DEBUG 0\n#endif\n\n/*\n *  Double-precision floating-point number, IEEE 754\n *\n *  64 bit (8 bytes) in total\n *  1  bit sign\n *  11 bits exponent\n *  52 bits mantissa\n *      7         6        5        4        3        2        1        0\n *  seeeeeee|eeeemmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm\n *\n * If an exponent is all-1 and mantissa is all-0, then it is an INFINITY:\n *  11111111|11110000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n * If an exponent is all-1 and mantissa's MSB is 1, it is a quiet NaN:\n *  11111111|11111000|00000000|00000000|00000000|00000000|00000000|00000000\n *\n *  MJS NaN-packing:\n *    sign and exponent is 0xfff\n *    4 bits specify type (tag), must be non-zero\n *    48 bits specify value\n *\n *  11111111|1111tttt|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv\n *   NaN marker |type|  48-bit placeholder for values: pointers, strings\n *\n * On 64-bit platforms, pointers are really 48 bit only, so they can fit,\n * provided they are sign extended\n */\n\ntypedef uint64_t mjs_val_t;\n\n/* This if-0 is a dirty workaround to force etags to pick `struct mjs` */\n#if 0\n/* Opaque structure. MJS engine context. */\nstruct mjs {\n  /* ... */\n};\n#endif\n\nstruct mjs;\n\ntypedef enum mjs_err {\n  MJS_OK,\n  MJS_SYNTAX_ERROR,\n  MJS_REFERENCE_ERROR,\n  MJS_TYPE_ERROR,\n  MJS_OUT_OF_MEMORY,\n  MJS_INTERNAL_ERROR,\n  MJS_NOT_IMPLEMENTED_ERROR,\n  MJS_FILE_READ_ERROR,\n  MJS_BAD_ARGS_ERROR,\n\n  MJS_ERRS_CNT\n} mjs_err_t;\nstruct mjs;\n\n/* Create MJS instance */\nstruct mjs *mjs_create();\n\nstruct mjs_create_opts {\n  /* use non-default bytecode definition file, testing-only */\n  const struct bf_code *code;\n};\n\n/*\n * Like `msj_create()`, but allows to customize initial MJS state, see `struct\n * mjs_create_opts`.\n */\nstruct mjs *mjs_create_opt(struct mjs_create_opts opts);\n\n/* Destroy MJS instance */\nvoid mjs_destroy(struct mjs *mjs);\n\nmjs_val_t mjs_get_global(struct mjs *mjs);\n\n/*\n * Tells the GC about an MJS value variable/field owned by C code.\n *\n * The user's C code should own mjs_val_t variables if the value's lifetime\n * crosses any invocation of `mjs_exec()` and friends, including `mjs_call()`.\n *\n * The registration of the variable prevents the GC from mistakenly treat the\n * object as garbage.\n *\n * User code should also explicitly disown the variables with `mjs_disown()`\n * once it goes out of scope or the structure containing the mjs_val_t field is\n * freed.\n *\n * Consider the following examples:\n *\n * Correct (owning is not necessary):\n * ```c\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script\", &res);\n * // ... use res somehow\n *\n * mjs_val_t res;\n * mjs_exec(mjs, \"....some script2\", &res);\n * // ... use new res somehow\n * ```\n *\n * WRONG:\n * ```c\n * mjs_val_t res1;\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 (WRONG!) and res2\n * ```\n *\n * The code above is wrong, because after the second invocation of\n * `mjs_exec()`, the value of `res1` is invalidated.\n *\n * Correct (res1 is owned)\n * ```c\n * mjs_val_t res1 = MJS_UNDEFINED;\n * mjs_own(mjs, &res1);\n * mjs_exec(mjs, \"....some script\", &res1);\n *\n * mjs_val_t res2 = MJS_UNDEFINED;\n * mjs_exec(mjs, \"....some script2\", &res2);\n *\n * // ... use res1 and res2\n * mjs_disown(mjs, &res1);\n * ```\n *\n * NOTE that we explicly initialized `res1` to a valid value before owning it\n * (in this case, the value is `MJS_UNDEFINED`). Owning an uninitialized\n * variable is an undefined behaviour.\n *\n * Of course, it's not an error to own a variable even if it's not mandatory:\n * e.g. in the last example we could own both `res1` and `res2`. Probably it\n * would help us in the future, when we refactor the code so that `res2` has to\n * be owned, and we could forget to do that.\n *\n * Also, if the user code has some C function called from MJS, and in this C\n * function some MJS value (`mjs_val_t`) needs to be stored somewhere and to\n * stay alive after the C function has returned, it also needs to be properly\n * owned.\n */\nvoid mjs_own(struct mjs *mjs, mjs_val_t *v);\n\n/*\n * Disowns the value previously owned by `mjs_own()`.\n *\n * Returns 1 if value is found, 0 otherwise.\n */\nint mjs_disown(struct mjs *mjs, mjs_val_t *v);\n\nmjs_err_t mjs_set_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt, ...);\n\n/*\n * If there is no error message already set, then it's equal to\n * `mjs_set_errorf()`.\n *\n * Otherwise, an old message gets prepended with the new one, followed by a\n * colon. (the previously set error code is kept)\n */\nmjs_err_t mjs_prepend_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt,\n                             ...);\n\n/*\n * Print the last error details. If print_stack_trace is non-zero, also\n * print stack trace. `msg` is the message which gets prepended to the actual\n * error message, if it's NULL, then \"MJS error\" is used.\n */\nvoid mjs_print_error(struct mjs *mjs, FILE *fp, const char *msg,\n                     int print_stack_trace);\n\n/*\n * return a string representation of an error.\n * the error string might be overwritten by calls to `mjs_set_errorf`.\n */\nconst char *mjs_strerror(struct mjs *mjs, enum mjs_err err);\n\n/*\n * Sets whether *.jsc files are generated when *.js file is executed. By\n * default it's 0.\n *\n * If either `MJS_GENERATE_JSC` or `CS_MMAP` is off, then this function has no\n * effect.\n */\nvoid mjs_set_generate_jsc(struct mjs *mjs, int generate_jsc);\n\n/*\n * When invoked from a cfunction, returns number of arguments passed to the\n * current JS function call.\n */\nint mjs_nargs(struct mjs *mjs);\n\n/*\n * When invoked from a cfunction, returns n-th argument to the current JS\n * function call.\n */\nmjs_val_t mjs_arg(struct mjs *mjs, int n);\n\n/*\n * Sets return value for the current JS function call.\n */\nvoid mjs_return(struct mjs *mjs, mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CORE_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array_public.h\"\n#endif\n\n/*\n * === Arrays\n */\n\n#ifndef MJS_ARRAY_PUBLIC_H_\n#define MJS_ARRAY_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* Make an empty array object */\nmjs_val_t mjs_mk_array(struct mjs *mjs);\n\n/* Returns length on an array. If `arr` is not an array, 0 is returned. */\nunsigned long mjs_array_length(struct mjs *mjs, mjs_val_t arr);\n\n/* Insert value `v` in array `arr` at the end of the array. */\nmjs_err_t mjs_array_push(struct mjs *mjs, mjs_val_t arr, mjs_val_t v);\n\n/*\n * Return array member at index `index`. If `index` is out of bounds, undefined\n * is returned.\n */\nmjs_val_t mjs_array_get(struct mjs *, mjs_val_t arr, unsigned long index);\n\n/* Insert value `v` into `arr` at index `index`. */\nmjs_err_t mjs_array_set(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                        mjs_val_t v);\n\n/* Returns true if the given value is an array */\nint mjs_is_array(mjs_val_t v);\n\n/* Delete value in array `arr` at index `index`, if it exists. */\nvoid mjs_array_del(struct mjs *mjs, mjs_val_t arr, unsigned long index);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_ARRAY_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array.h\"\n#endif\n\n#ifndef MJS_ARRAY_H_\n#define MJS_ARRAY_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_array_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_val_t\nmjs_array_get2(struct mjs *mjs, mjs_val_t arr, unsigned long index, int *has);\n\nMJS_PRIVATE void mjs_array_splice(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_array_push_internal(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_ARRAY_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi_public.h\"\n#endif\n\n#ifndef MJS_FFI_PUBLIC_H_\n#define MJS_FFI_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum mjs_ffi_ctype {\n  MJS_FFI_CTYPE_NONE,\n  MJS_FFI_CTYPE_USERDATA,\n  MJS_FFI_CTYPE_CALLBACK,\n  MJS_FFI_CTYPE_INT,\n  MJS_FFI_CTYPE_BOOL,\n  MJS_FFI_CTYPE_DOUBLE,\n  MJS_FFI_CTYPE_FLOAT,\n  MJS_FFI_CTYPE_CHAR_PTR,\n  MJS_FFI_CTYPE_VOID_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR_PTR,\n  MJS_FFI_CTYPE_STRUCT_MG_STR,\n  MJS_FFI_CTYPE_INVALID,\n};\n\ntypedef void *(mjs_ffi_resolver_t)(void *handle, const char *symbol);\n\nvoid mjs_set_ffi_resolver(struct mjs *mjs, mjs_ffi_resolver_t *dlsym);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi.h\"\n#endif\n\n#ifndef MJS_FFI_H_\n#define MJS_FFI_H_\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n/* Amalgamated: #include \"mjs_ffi_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nmjs_ffi_resolver_t dlsym;\n\n#define MJS_CB_ARGS_MAX_CNT 6\n#define MJS_CB_SIGNATURE_MAX_SIZE (MJS_CB_ARGS_MAX_CNT + 1 /* return type */)\n\ntypedef uint8_t mjs_ffi_ctype_t;\n\nenum ffi_sig_type {\n  FFI_SIG_FUNC,\n  FFI_SIG_CALLBACK,\n};\n\n/*\n * Parsed FFI signature\n */\nstruct mjs_ffi_sig {\n  /*\n   * Callback signature, corresponds to the arg of type MJS_FFI_CTYPE_CALLBACK\n   * TODO(dfrank): probably we'll need to support multiple callback/userdata\n   * pairs\n   *\n   * NOTE(dfrank): instances of this structure are grouped into GC arenas and\n   * managed by GC, and for the GC mark to work, the first element should be\n   * a pointer (so that the two LSBs are not used).\n   */\n  struct mjs_ffi_sig *cb_sig;\n\n  /*\n   * The first item is the return value type (for `void`, `MJS_FFI_CTYPE_NONE`\n   * is used); the rest are arguments. If some argument is\n   * `MJS_FFI_CTYPE_NONE`, it means that there are no more arguments.\n   */\n  mjs_ffi_ctype_t val_types[MJS_CB_SIGNATURE_MAX_SIZE];\n\n  /*\n   * Function to call. If `is_callback` is not set, then it's the function\n   * obtained by dlsym; otherwise it's a pointer to the appropriate callback\n   * implementation.\n   */\n  ffi_fn_t *fn;\n\n  /* Number of arguments in the signature */\n  int8_t args_cnt;\n\n  /*\n   * If set, then the signature represents the callback (as opposed to a normal\n   * function), and `fn` points to the suitable callback implementation.\n   */\n  unsigned is_callback : 1;\n  unsigned is_valid : 1;\n};\ntypedef struct mjs_ffi_sig mjs_ffi_sig_t;\n\n/* Initialize new FFI signature */\nMJS_PRIVATE void mjs_ffi_sig_init(mjs_ffi_sig_t *sig);\n/* Copy existing FFI signature */\nMJS_PRIVATE void mjs_ffi_sig_copy(mjs_ffi_sig_t *to, const mjs_ffi_sig_t *from);\n/* Free FFI signature. NOTE: the pointer `sig` itself is not freed */\nMJS_PRIVATE void mjs_ffi_sig_free(mjs_ffi_sig_t *sig);\n\n/*\n * Creates a new FFI signature from the GC arena, and return mjs_val_t which\n * wraps it.\n */\nMJS_PRIVATE mjs_val_t mjs_mk_ffi_sig(struct mjs *mjs);\n\n/*\n * Checks whether the given value is a FFI signature.\n */\nMJS_PRIVATE int mjs_is_ffi_sig(mjs_val_t v);\n\n/*\n * Wraps FFI signature structure into mjs_val_t value.\n */\nMJS_PRIVATE mjs_val_t mjs_ffi_sig_to_value(struct mjs_ffi_sig *psig);\n\n/*\n * Extracts a pointer to the FFI signature struct from the mjs_val_t value.\n */\nMJS_PRIVATE struct mjs_ffi_sig *mjs_get_ffi_sig_struct(mjs_val_t v);\n\n/*\n * A wrapper for mjs_ffi_sig_free() suitable to use as a GC cell destructor.\n */\nMJS_PRIVATE void mjs_ffi_sig_destructor(struct mjs *mjs, void *psig);\n\nMJS_PRIVATE int mjs_ffi_sig_set_val_type(mjs_ffi_sig_t *sig, int idx,\n                                         mjs_ffi_ctype_t type);\nMJS_PRIVATE int mjs_ffi_sig_validate(struct mjs *mjs, mjs_ffi_sig_t *sig,\n                                     enum ffi_sig_type sig_type);\nMJS_PRIVATE int mjs_ffi_is_regular_word(mjs_ffi_ctype_t type);\nMJS_PRIVATE int mjs_ffi_is_regular_word_or_void(mjs_ffi_ctype_t type);\n\nstruct mjs_ffi_cb_args {\n  struct mjs_ffi_cb_args *next;\n  struct mjs *mjs;\n  mjs_ffi_sig_t sig;\n  mjs_val_t func;\n  mjs_val_t userdata;\n};\ntypedef struct mjs_ffi_cb_args ffi_cb_args_t;\n\n/*\n * cfunction:\n * Parses the FFI signature string and returns a value wrapping mjs_ffi_sig_t.\n */\nMJS_PRIVATE mjs_err_t mjs_ffi_call(struct mjs *mjs);\n\n/*\n * cfunction:\n * Performs the FFI signature call.\n */\nMJS_PRIVATE mjs_err_t mjs_ffi_call2(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_ffi_cb_free(struct mjs *);\nMJS_PRIVATE void mjs_ffi_args_free_list(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_FFI_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_mm.h\"\n#endif\n\n#ifndef MJS_MM_H_\n#define MJS_MM_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs;\n\ntypedef void (*gc_cell_destructor_t)(struct mjs *mjs, void *);\n\nstruct gc_block {\n  struct gc_block *next;\n  struct gc_cell *base;\n  size_t size;\n};\n\nstruct gc_arena {\n  struct gc_block *blocks;\n  size_t size_increment;\n  struct gc_cell *free; /* head of free list */\n  size_t cell_size;\n\n#if MJS_MEMORY_STATS\n  unsigned long allocations; /* cumulative counter of allocations */\n  unsigned long garbage;     /* cumulative counter of garbage */\n  unsigned long alive;       /* number of living cells */\n#endif\n\n  gc_cell_destructor_t destructor;\n};\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_MM_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc_public.h\"\n#endif\n\n#ifndef MJS_GC_PUBLIC_H_\n#define MJS_GC_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Perform garbage collection.\n * Pass true to full in order to reclaim unused heap back to the OS.\n */\nvoid mjs_gc(struct mjs *mjs, int full);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_GC_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc.h\"\n#endif\n\n#ifndef MJS_GC_H_\n#define MJS_GC_H_\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_mm.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_gc_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * performs arithmetics on gc_cell pointers as if they were arena->cell_size\n * bytes wide\n */\n#define GC_CELL_OP(arena, cell, op, arg) \\\n  ((struct gc_cell *) (((char *) (cell)) op((arg) * (arena)->cell_size)))\n\nstruct gc_cell {\n  union {\n    struct gc_cell *link;\n    uintptr_t word;\n  } head;\n};\n\nMJS_PRIVATE int gc_strings_is_gc_needed(struct mjs *mjs);\n\n/* perform gc if not inhibited */\nMJS_PRIVATE int maybe_gc(struct mjs *mjs);\n\nMJS_PRIVATE struct mjs_object *new_object(struct mjs *);\nMJS_PRIVATE struct mjs_property *new_property(struct mjs *);\nMJS_PRIVATE struct mjs_ffi_sig *new_ffi_sig(struct mjs *mjs);\n\nMJS_PRIVATE void gc_mark(struct mjs *mjs, mjs_val_t *val);\n\nMJS_PRIVATE void gc_arena_init(struct gc_arena *, size_t, size_t, size_t);\nMJS_PRIVATE void gc_arena_destroy(struct mjs *, struct gc_arena *a);\nMJS_PRIVATE void gc_sweep(struct mjs *, struct gc_arena *, size_t);\nMJS_PRIVATE void *gc_alloc_cell(struct mjs *, struct gc_arena *);\n\nMJS_PRIVATE uint64_t gc_string_mjs_val_to_offset(mjs_val_t v);\n\n/* return 0 if v is an object/function with a bad pointer */\nMJS_PRIVATE int gc_check_val(struct mjs *mjs, mjs_val_t v);\n\n/* checks whether a pointer is within the ranges of an arena */\nMJS_PRIVATE int gc_check_ptr(const struct gc_arena *a, const void *p);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_GC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core.h\"\n#endif\n\n#ifndef MJS_CORE_H\n#define MJS_CORE_H\n\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n#define JUMP_INSTRUCTION_SIZE 2\n\nenum mjs_type {\n  /* Primitive types */\n  MJS_TYPE_UNDEFINED,\n  MJS_TYPE_NULL,\n  MJS_TYPE_BOOLEAN,\n  MJS_TYPE_NUMBER,\n  MJS_TYPE_STRING,\n  MJS_TYPE_FOREIGN,\n\n  /* Different classes of Object type */\n  MJS_TYPE_OBJECT_GENERIC,\n  MJS_TYPE_OBJECT_ARRAY,\n  MJS_TYPE_OBJECT_FUNCTION,\n  /*\n   * TODO(dfrank): if we support prototypes, need to add items for them here\n   */\n\n  MJS_TYPES_CNT\n};\n\nenum mjs_call_stack_frame_item {\n  CALL_STACK_FRAME_ITEM_RETVAL_STACK_IDX, /* TOS */\n  CALL_STACK_FRAME_ITEM_LOOP_ADDR_IDX,\n  CALL_STACK_FRAME_ITEM_SCOPE_IDX,\n  CALL_STACK_FRAME_ITEM_RETURN_ADDR,\n  CALL_STACK_FRAME_ITEM_THIS,\n\n  CALL_STACK_FRAME_ITEMS_CNT\n};\n\n/*\n * A tag is made of the sign bit and the 4 lower order bits of byte 6.\n * So in total we have 32 possible tags.\n *\n * Tag (1,0) however cannot hold a zero payload otherwise it's interpreted as an\n * INFINITY; for simplicity we're just not going to use that combination.\n */\n#define MAKE_TAG(s, t) \\\n  ((uint64_t)(s) << 63 | (uint64_t) 0x7ff0 << 48 | (uint64_t)(t) << 48)\n\n#define MJS_TAG_OBJECT MAKE_TAG(1, 1)\n#define MJS_TAG_FOREIGN MAKE_TAG(1, 2)\n#define MJS_TAG_UNDEFINED MAKE_TAG(1, 3)\n#define MJS_TAG_BOOLEAN MAKE_TAG(1, 4)\n#define MJS_TAG_NAN MAKE_TAG(1, 5)\n#define MJS_TAG_STRING_I MAKE_TAG(1, 6)  /* Inlined string len < 5 */\n#define MJS_TAG_STRING_5 MAKE_TAG(1, 7)  /* Inlined string len 5 */\n#define MJS_TAG_STRING_O MAKE_TAG(1, 8)  /* Owned string */\n#define MJS_TAG_STRING_F MAKE_TAG(1, 9)  /* Foreign string */\n#define MJS_TAG_STRING_C MAKE_TAG(1, 10) /* String chunk */\n#define MJS_TAG_STRING_D MAKE_TAG(1, 11) /* Dictionary string  */\n#define MJS_TAG_ARRAY MAKE_TAG(1, 12)\n#define MJS_TAG_FUNCTION MAKE_TAG(1, 13)\n#define MJS_TAG_FUNCTION_FFI MAKE_TAG(1, 14)\n#define MJS_TAG_NULL MAKE_TAG(1, 15)\n\n#define MJS_TAG_MASK MAKE_TAG(1, 15)\n\nstruct mjs_vals {\n  /* Current `this` value  */\n  mjs_val_t this_obj;\n  mjs_val_t dataview_proto;\n\n  /*\n   * The object against which the last `OP_GET` was invoked. Needed for\n   * \"method invocation pattern\".\n   */\n  mjs_val_t last_getprop_obj;\n};\n\nstruct mjs_bcode_part {\n  /* Global index of the bcode part */\n  size_t start_idx;\n\n  /* Actual bcode data */\n  struct {\n    const char *p; /* Memory chunk pointer */\n    size_t len;    /* Memory chunk length */\n  } data;\n\n  /*\n   * Result of evaluation (not parsing: if there is an error during parsing,\n   * the bcode is not even committed). It is used to determine whether we\n   * need to evaluate the file: if file was already evaluated, and the result\n   * was MJS_OK, then we won't evaluate it again. Otherwise, we will.\n   */\n  mjs_err_t exec_res : 4;\n\n  /* If set, bcode data does not need to be freed */\n  unsigned in_rom : 1;\n};\n\nstruct mjs {\n  struct mbuf bcode_gen;\n  struct mbuf bcode_parts;\n  size_t bcode_len;\n  struct mbuf stack;\n  struct mbuf call_stack;\n  struct mbuf arg_stack;\n  struct mbuf scopes;          /* Scope objects */\n  struct mbuf loop_addresses;  /* Addresses for breaks & continues */\n  struct mbuf owned_strings;   /* Sequence of (varint len, char data[]) */\n  struct mbuf foreign_strings; /* Sequence of (varint len, char *data) */\n  struct mbuf owned_values;\n  struct mbuf json_visited_stack;\n  struct mjs_vals vals;\n  char *error_msg;\n  char *stack_trace;\n  enum mjs_err error;\n  mjs_ffi_resolver_t *dlsym;  /* Symbol resolver function for FFI */\n  ffi_cb_args_t *ffi_cb_args; /* List of FFI args descriptors */\n  size_t cur_bcode_offset;\n\n  struct gc_arena object_arena;\n  struct gc_arena property_arena;\n  struct gc_arena ffi_sig_arena;\n\n  unsigned inhibit_gc : 1;\n  unsigned need_gc : 1;\n  unsigned generate_jsc : 1;\n};\n\n/*\n * Bcode header: type of the items, and item numbers.\n */\ntypedef uint32_t mjs_header_item_t;\nenum mjs_header_items {\n  MJS_HDR_ITEM_TOTAL_SIZE,   /* Total size of the bcode (not counting the\n                                OP_BCODE_HEADER byte) */\n  MJS_HDR_ITEM_BCODE_OFFSET, /* Offset to the start of the actual bcode (not\n                                counting the OP_BCODE_HEADER byte) */\n  MJS_HDR_ITEM_MAP_OFFSET,   /* Offset to the start of offset-to-line_no mapping\n                                k*/\n\n  MJS_HDR_ITEMS_CNT\n};\n\nMJS_PRIVATE size_t mjs_get_func_addr(mjs_val_t v);\n\nMJS_PRIVATE int mjs_getretvalpos(struct mjs *mjs);\n\nMJS_PRIVATE enum mjs_type mjs_get_type(mjs_val_t v);\n\n/*\n * Prints stack trace starting from the given bcode offset; other offsets\n * (if any) will be fetched from the call_stack.\n */\nMJS_PRIVATE void mjs_gen_stack_trace(struct mjs *mjs, size_t offset);\n\nMJS_PRIVATE mjs_val_t vtop(struct mbuf *m);\nMJS_PRIVATE size_t mjs_stack_size(const struct mbuf *m);\nMJS_PRIVATE mjs_val_t *vptr(struct mbuf *m, int idx);\nMJS_PRIVATE void push_mjs_val(struct mbuf *m, mjs_val_t v);\nMJS_PRIVATE mjs_val_t mjs_pop_val(struct mbuf *m);\nMJS_PRIVATE mjs_val_t mjs_pop(struct mjs *mjs);\nMJS_PRIVATE void mjs_push(struct mjs *mjs, mjs_val_t v);\nMJS_PRIVATE void mjs_die(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CORE_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_conversion.h\"\n#endif\n\n#ifndef MJS_CONVERSION_H_\n#define MJS_CONVERSION_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Tries to convert `mjs_val_t` to a string, returns MJS_OK if successful.\n * String is returned as a pair of pointers: `char **p, size_t *sizep`.\n *\n * Caller must also provide a non-null `need_free`, and if it is non-zero,\n * then the string `*p` should be freed by the caller.\n *\n * MJS does not support `toString()` and `valueOf()`, so, passing an object\n * always results in `MJS_TYPE_ERROR`.\n */\nMJS_PRIVATE mjs_err_t mjs_to_string(struct mjs *mjs, mjs_val_t *v, char **p,\n                                    size_t *sizep, int *need_free);\n\n/*\n * Converts value to boolean as in the expression `if (v)`.\n */\nMJS_PRIVATE mjs_val_t mjs_to_boolean_v(struct mjs *mjs, mjs_val_t v);\n\nMJS_PRIVATE int mjs_is_truthy(struct mjs *mjs, mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_CONVERSION_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object_public.h\"\n#endif\n\n#ifndef MJS_OBJECT_PUBLIC_H_\n#define MJS_OBJECT_PUBLIC_H_\n\n#include <stddef.h>\n/* Amalgamated: #include \"mjs_core_public.h\" */\n/* Amalgamated: #include \"mjs_ffi_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Returns true if the given value is an object or array.\n */\nint mjs_is_object(mjs_val_t v);\n\n/* Make an empty object */\nmjs_val_t mjs_mk_object(struct mjs *mjs);\n\n/* Field types for struct-object conversion. */\nenum mjs_struct_field_type {\n  MJS_STRUCT_FIELD_TYPE_INVALID,\n  MJS_STRUCT_FIELD_TYPE_STRUCT,     /* Struct, arg points to def. */\n  MJS_STRUCT_FIELD_TYPE_STRUCT_PTR, /* Ptr to struct, arg points to def. */\n  MJS_STRUCT_FIELD_TYPE_INT,\n  MJS_STRUCT_FIELD_TYPE_BOOL,\n  MJS_STRUCT_FIELD_TYPE_DOUBLE,\n  MJS_STRUCT_FIELD_TYPE_FLOAT,\n  MJS_STRUCT_FIELD_TYPE_CHAR_PTR,   /* NUL-terminated string. */\n  MJS_STRUCT_FIELD_TYPE_VOID_PTR,   /* Converted to foreign ptr. */\n  MJS_STRUCT_FIELD_TYPE_MG_STR_PTR, /* Converted to string. */\n  MJS_STRUCT_FIELD_TYPE_MG_STR,     /* Converted to string. */\n  MJS_STRUCT_FIELD_TYPE_DATA,       /* Data, arg is length, becomes string. */\n  MJS_STRUCT_FIELD_TYPE_INT8,\n  MJS_STRUCT_FIELD_TYPE_INT16,\n  MJS_STRUCT_FIELD_TYPE_UINT8,\n  MJS_STRUCT_FIELD_TYPE_UINT16,\n  /*\n   * User-provided function. Arg is a pointer to function that takes void *\n   * (pointer to field within the struct) and returns mjs_val_t:\n   * mjs_val_t field_value(struct mjs *mjs, const void *field_ptr) { ... }\n   */\n  MJS_STRUCT_FIELD_TYPE_CUSTOM,\n};\n\n/* C structure layout descriptor - needed by mjs_struct_to_obj */\nstruct mjs_c_struct_member {\n  const char *name;\n  int offset;\n  enum mjs_struct_field_type type;\n  const void *arg; /* Additional argument, used for some types. */\n};\n\n/* Create flat JS object from a C memory descriptor */\nmjs_val_t mjs_struct_to_obj(struct mjs *mjs, const void *base,\n                            const struct mjs_c_struct_member *members);\n\n/*\n * Lookup property `name` in object `obj`. If `obj` holds no such property,\n * an `undefined` value is returned.\n *\n * If `name_len` is ~0, `name` is assumed to be NUL-terminated and\n * `strlen(name)` is used.\n */\nmjs_val_t mjs_get(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len);\n\n/*\n * Like mjs_get but with a JS string.\n */\nmjs_val_t mjs_get_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name);\n\n/*\n * Like mjs_get_v but lookup the prototype chain.\n */\nmjs_val_t mjs_get_v_proto(struct mjs *mjs, mjs_val_t obj, mjs_val_t key);\n\n/*\n * Set object property. Behaves just like JavaScript assignment.\n */\nmjs_err_t mjs_set(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len,\n                  mjs_val_t val);\n\n/*\n * Like mjs_set but the name is already a JS string.\n */\nmjs_err_t mjs_set_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name,\n                    mjs_val_t val);\n\n/*\n * Delete own property `name` of the object `obj`. Does not follow the\n * prototype chain.\n *\n * If `name_len` is ~0, `name` is assumed to be NUL-terminated and\n * `strlen(name)` is used.\n *\n * Returns 0 on success, -1 on error.\n */\nint mjs_del(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len);\n\n/*\n * Iterate over `obj` properties.\n * First call should set `iterator` to MJS_UNDEFINED.\n * Return object's key (a string), or MJS_UNDEFINED when no more keys left.\n * Do not mutate the object during iteration.\n *\n * Example:\n *   mjs_val_t key, iter = MJS_UNDEFINED;\n *   while ((key = mjs_next(mjs, obj, &iter)) != MJS_UNDEFINED) {\n *     // Do something with the obj/key ...\n *   }\n */\nmjs_val_t mjs_next(struct mjs *mjs, mjs_val_t obj, mjs_val_t *iterator);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_OBJECT_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object.h\"\n#endif\n\n#ifndef MJS_OBJECT_H_\n#define MJS_OBJECT_H_\n\n/* Amalgamated: #include \"mjs_object_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs;\n\nstruct mjs_property {\n  struct mjs_property *next; /* Linkage in struct mjs_object::properties */\n  mjs_val_t name;            /* Property name (a string) */\n  mjs_val_t value;           /* Property value */\n};\n\nstruct mjs_object {\n  struct mjs_property *properties;\n};\n\nMJS_PRIVATE struct mjs_object *get_object_struct(mjs_val_t v);\nMJS_PRIVATE struct mjs_property *mjs_get_own_property(struct mjs *mjs,\n                                                      mjs_val_t obj,\n                                                      const char *name,\n                                                      size_t len);\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property_v(struct mjs *mjs,\n                                                        mjs_val_t obj,\n                                                        mjs_val_t key);\n\n/*\n * A worker function for `mjs_set()` and `mjs_set_v()`: it takes name as both\n * ptr+len and mjs_val_t. If `name` pointer is not NULL, it takes precedence\n * over `name_v`.\n */\nMJS_PRIVATE mjs_err_t mjs_set_internal(struct mjs *mjs, mjs_val_t obj,\n                                       mjs_val_t name_v, char *name,\n                                       size_t name_len, mjs_val_t val);\n\n/*\n * Implementation of `Object.create(proto)`\n */\nMJS_PRIVATE void mjs_op_create_object(struct mjs *mjs);\n\n#define MJS_PROTO_PROP_NAME \"__p\" /* Make it < 5 chars */\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_OBJECT_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive_public.h\"\n#endif\n\n#ifndef MJS_PRIMITIVE_PUBLIC_H_\n#define MJS_PRIMITIVE_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* JavaScript `null` value */\n#define MJS_NULL MJS_TAG_NULL\n\n/* JavaScript `undefined` value */\n#define MJS_UNDEFINED MJS_TAG_UNDEFINED\n\n/* Function pointer type used in `mjs_mk_foreign_func`. */\ntypedef void (*mjs_func_ptr_t)(void);\n\n/*\n * Make `null` primitive value.\n *\n * NOTE: this function is deprecated and will be removed in future releases.\n * Use `MJS_NULL` instead.\n */\nmjs_val_t mjs_mk_null(void);\n\n/* Returns true if given value is a primitive `null` value */\nint mjs_is_null(mjs_val_t v);\n\n/*\n * Make `undefined` primitive value.\n *\n * NOTE: this function is deprecated and will be removed in future releases.\n * Use `MJS_UNDEFINED` instead.\n */\nmjs_val_t mjs_mk_undefined(void);\n\n/* Returns true if given value is a primitive `undefined` value */\nint mjs_is_undefined(mjs_val_t v);\n\n/* Make numeric primitive value */\nmjs_val_t mjs_mk_number(struct mjs *mjs, double num);\n\n/*\n * Returns number value stored in `mjs_val_t` as `double`.\n *\n * Returns NaN for non-numbers.\n */\ndouble mjs_get_double(struct mjs *mjs, mjs_val_t v);\n\n/*\n * Returns number value stored in `mjs_val_t` as `int`. If the number value is\n * not an integer, the fraction part will be discarded.\n *\n * If the given value is a non-number, or NaN, the result is undefined.\n */\nint mjs_get_int(struct mjs *mjs, mjs_val_t v);\n\n/*\n * Like mjs_get_int but ensures that the returned type\n * is a 32-bit signed integer.\n */\nint32_t mjs_get_int32(struct mjs *mjs, mjs_val_t v);\n\n/* Returns true if given value is a primitive number value */\nint mjs_is_number(mjs_val_t v);\n\n/*\n * Make JavaScript value that holds C/C++ `void *` pointer.\n *\n * A foreign value is completely opaque and JS code cannot do anything useful\n * with it except holding it in properties and passing it around.\n * It behaves like a sealed object with no properties.\n *\n * NOTE:\n * Only valid pointers (as defined by each supported architecture) will fully\n * preserved. In particular, all supported 64-bit architectures (x86_64, ARM-64)\n * actually define a 48-bit virtual address space.\n * Foreign values will be sign-extended as required, i.e creating a foreign\n * value of something like `(void *) -1` will work as expected. This is\n * important because in some 64-bit OSs (e.g. Solaris) the user stack grows\n * downwards from the end of the address space.\n *\n * If you need to store exactly sizeof(void*) bytes of raw data where\n * `sizeof(void*)` >= 8, please use byte arrays instead.\n */\nmjs_val_t mjs_mk_foreign(struct mjs *mjs, void *ptr);\n\n/*\n * Make JavaScript value that holds C/C++ function pointer, similarly to\n * `mjs_mk_foreign`.\n */\nmjs_val_t mjs_mk_foreign_func(struct mjs *mjs, mjs_func_ptr_t fn);\n\n/*\n * Returns `void *` pointer stored in `mjs_val_t`.\n *\n * Returns NULL if the value is not a foreign pointer.\n */\nvoid *mjs_get_ptr(struct mjs *mjs, mjs_val_t v);\n\n/* Returns true if given value holds `void *` pointer */\nint mjs_is_foreign(mjs_val_t v);\n\nmjs_val_t mjs_mk_boolean(struct mjs *mjs, int v);\nint mjs_get_bool(struct mjs *mjs, mjs_val_t v);\nint mjs_is_boolean(mjs_val_t v);\n\nmjs_val_t mjs_mk_function(struct mjs *mjs, size_t off);\nint mjs_is_function(mjs_val_t v);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PRIMITIVE_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive.h\"\n#endif\n\n#ifndef MJS_PRIMITIVE_H\n#define MJS_PRIMITIVE_H\n\n/* Amalgamated: #include \"mjs_primitive_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Convert a pointer to mjs_val_t. If pointer is not valid, mjs crashes.\n */\nMJS_PRIVATE mjs_val_t mjs_legit_pointer_to_value(void *p);\n\n/*\n * Convert a pointer to mjs_val_t. If pointer is not valid, error is set\n * in the mjs context.\n */\nMJS_PRIVATE mjs_val_t mjs_pointer_to_value(struct mjs *mjs, void *p);\n\n/*\n * Extracts a pointer from the mjs_val_t value.\n */\nMJS_PRIVATE void *get_ptr(mjs_val_t v);\n\n/*\n * Implementation for JS isNaN()\n */\nMJS_PRIVATE void mjs_op_isnan(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PRIMITIVE_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string_public.h\"\n#endif\n\n#ifndef MJS_STRING_PUBLIC_H_\n#define MJS_STRING_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n\n#define MJS_STRING_LITERAL_MAX_LEN 128\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Creates a string primitive value.\n * `str` must point to the utf8 string of length `len`.\n * If `len` is ~0, `str` is assumed to be NUL-terminated and `strlen(str)` is\n * used.\n *\n * If `copy` is non-zero, the string data is copied and owned by the GC. The\n * caller can free the string data afterwards. Otherwise (`copy` is zero), the\n * caller owns the string data, and is responsible for not freeing it while it\n * is used.\n */\nmjs_val_t mjs_mk_string(struct mjs *mjs, const char *str, size_t len, int copy);\n\n/* Returns true if given value is a primitive string value */\nint mjs_is_string(mjs_val_t v);\n\n/*\n * Returns a pointer to the string stored in `mjs_val_t`.\n *\n * String length returned in `len`, which is allowed to be NULL. Returns NULL\n * if the value is not a string.\n *\n * JS strings can contain embedded NUL chars and may or may not be NUL\n * terminated.\n *\n * CAUTION: creating new JavaScript object, array, or string may kick in a\n * garbage collector, which in turn may relocate string data and invalidate\n * pointer returned by `mjs_get_string()`.\n *\n * Short JS strings are embedded inside the `mjs_val_t` value itself. This\n * is why a pointer to a `mjs_val_t` is required. It also means that the string\n * data will become invalid once that `mjs_val_t` value goes out of scope.\n */\nconst char *mjs_get_string(struct mjs *mjs, mjs_val_t *v, size_t *len);\n\n/*\n * Returns a pointer to the string stored in `mjs_val_t`.\n *\n * Returns NULL if the value is not a string or if the string is not compatible\n * with a C string.\n *\n * C compatible strings contain exactly one NUL char, in terminal position.\n *\n * All strings owned by the MJS engine (see `mjs_mk_string()`) are guaranteed to\n * be NUL terminated. Out of these, those that don't include embedded NUL chars\n * are guaranteed to be C compatible.\n */\nconst char *mjs_get_cstring(struct mjs *mjs, mjs_val_t *v);\n\n/*\n * Returns the standard strcmp comparison code after comparing a JS string a\n * with a possibly non null-terminated string b. NOTE: the strings are equal\n * only if their length is equal, i.e. the len field doesn't imply strncmp\n * behaviour.\n */\nint mjs_strcmp(struct mjs *mjs, mjs_val_t *a, const char *b, size_t len);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_STRING_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string.h\"\n#endif\n\n#ifndef MJS_STRING_H_\n#define MJS_STRING_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_string_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Size of the extra space for strings mbuf that is needed to avoid frequent\n * reallocations\n */\n#define _MJS_STRING_BUF_RESERVE 100\n\nMJS_PRIVATE unsigned long cstr_to_ulong(const char *s, size_t len, int *ok);\nMJS_PRIVATE mjs_err_t\nstr_to_ulong(struct mjs *mjs, mjs_val_t v, int *ok, unsigned long *res);\nMJS_PRIVATE int s_cmp(struct mjs *mjs, mjs_val_t a, mjs_val_t b);\nMJS_PRIVATE mjs_val_t s_concat(struct mjs *mjs, mjs_val_t a, mjs_val_t b);\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags);\n\nMJS_PRIVATE void mjs_mkstr(struct mjs *mjs);\n\nMJS_PRIVATE void mjs_string_slice(struct mjs *mjs);\nMJS_PRIVATE void mjs_string_index_of(struct mjs *mjs);\nMJS_PRIVATE void mjs_string_char_code_at(struct mjs *mjs);\n\n#define EMBSTR_ZERO_TERM 1\n#define EMBSTR_UNESCAPE 2\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_STRING_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util_public.h\"\n#endif\n\n#ifndef MJS_UTIL_PUBLIC_H_\n#define MJS_UTIL_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n#include <stdio.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nconst char *mjs_typeof(mjs_val_t v);\n\nvoid mjs_fprintf(mjs_val_t v, struct mjs *mjs, FILE *fp);\nvoid mjs_sprintf(mjs_val_t v, struct mjs *mjs, char *buf, size_t buflen);\n\n#if MJS_ENABLE_DEBUG\n\nvoid mjs_disasm(const uint8_t *code, size_t len);\nvoid mjs_dump(struct mjs *mjs, int do_disasm);\n\n#endif\n\n/*\n * Returns the filename corresponding to the given bcode offset.\n */\nconst char *mjs_get_bcode_filename_by_offset(struct mjs *mjs, int offset);\n\n/*\n * Returns the line number corresponding to the given bcode offset.\n */\nint mjs_get_lineno_by_offset(struct mjs *mjs, int offset);\n\n/*\n * Returns bcode offset of the corresponding call frame cf_num, where 0 means\n * the currently executing function, 1 means the first return address, etc.\n *\n * If given cf_num is too large, -1 is returned.\n */\nint mjs_get_offset_by_call_frame_num(struct mjs *mjs, int cf_num);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_UTIL_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util.h\"\n#endif\n\n#ifndef MJS_UTIL_H_\n#define MJS_UTIL_H_\n\n#include \"frozen.h\"\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_util_public.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mjs_bcode_part;\n\nMJS_PRIVATE const char *opcodetostr(uint8_t opcode);\nMJS_PRIVATE size_t mjs_disasm_single(const uint8_t *code, size_t i);\nMJS_PRIVATE const char *mjs_stringify_type(enum mjs_type t);\n\n/*\n * Checks that the given argument is provided, and checks its type. If check\n * fails, sets error in the mjs context, and returns 0; otherwise returns 1.\n *\n * If `arg_num` >= 0, checks argument; otherwise (`arg_num` is negative) checks\n * `this`. `arg_name` is used for the error message only. If `parg` is not\n * NULL, writes resulting value at this location in case of success.\n */\nMJS_PRIVATE int mjs_check_arg(struct mjs *mjs, int arg_num,\n                              const char *arg_name, enum mjs_type expected_type,\n                              mjs_val_t *parg);\n\n/*\n * mjs_normalize_idx takes and index in the string and the string size, and\n * returns the index which is >= 0 and <= size. Negative index is interpreted\n * as size + index.\n */\nMJS_PRIVATE int mjs_normalize_idx(int idx, int size);\n\nMJS_PRIVATE const char *mjs_get_bcode_filename(struct mjs *mjs,\n                                               struct mjs_bcode_part *bp);\n\n/* Print JS value `v` to the JSON stream `out`. */\nvoid mjs_jprintf(mjs_val_t v, struct mjs *mjs, struct json_out *out);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_UTIL_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_bcode.h\"\n#endif\n\n#ifndef MJS_BCODE_H_\n#define MJS_BCODE_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n/* Amalgamated: #include \"mjs_core.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum mjs_opcode {\n  OP_NOP,               /* ( -- ) */\n  OP_DROP,              /* ( a -- ) */\n  OP_DUP,               /* ( a -- a a ) */\n  OP_SWAP,              /* ( a b -- b a ) */\n  OP_JMP,               /* ( -- ) */\n  OP_JMP_TRUE,          /* ( -- ) */\n  OP_JMP_NEUTRAL_TRUE,  /* ( -- ) */\n  OP_JMP_FALSE,         /* ( -- ) */\n  OP_JMP_NEUTRAL_FALSE, /* ( -- ) */\n  OP_FIND_SCOPE,        /* ( a -- a b ) */\n  OP_PUSH_SCOPE,        /* ( -- a ) */\n  OP_PUSH_STR,          /* ( -- a ) */\n  OP_PUSH_TRUE,         /* ( -- a ) */\n  OP_PUSH_FALSE,        /* ( -- a ) */\n  OP_PUSH_INT,          /* ( -- a ) */\n  OP_PUSH_DBL,          /* ( -- a ) */\n  OP_PUSH_NULL,         /* ( -- a ) */\n  OP_PUSH_UNDEF,        /* ( -- a ) */\n  OP_PUSH_OBJ,          /* ( -- a ) */\n  OP_PUSH_ARRAY,        /* ( -- a ) */\n  OP_PUSH_FUNC,         /* ( -- a ) */\n  OP_PUSH_THIS,         /* ( -- a ) */\n  OP_GET,               /* ( key obj  -- obj[key] ) */\n  OP_CREATE,            /* ( key obj -- ) */\n  OP_EXPR,              /* ( ... -- a ) */\n  OP_APPEND,            /* ( a b -- ) */\n  OP_SET_ARG,           /* ( a -- a ) */\n  OP_NEW_SCOPE,         /* ( -- ) */\n  OP_DEL_SCOPE,         /* ( -- ) */\n  OP_CALL,              /* ( func param1 param2 ... num_params -- result ) */\n  OP_RETURN,            /* ( -- ) */\n  OP_LOOP,         /* ( -- ) Push break & continue addresses to loop_labels */\n  OP_BREAK,        /* ( -- ) */\n  OP_CONTINUE,     /* ( -- ) */\n  OP_SETRETVAL,    /* ( a -- ) */\n  OP_EXIT,         /* ( -- ) */\n  OP_BCODE_HEADER, /* ( -- ) */\n  OP_ARGS,         /* ( -- ) Mark the beginning of function call arguments */\n  OP_FOR_IN_NEXT,  /* ( name obj iter_ptr -- name obj iter_ptr_next ) */\n  OP_MAX\n};\n\nstruct pstate;\nstruct mjs;\n\nMJS_PRIVATE void emit_byte(struct pstate *pstate, uint8_t byte);\nMJS_PRIVATE void emit_int(struct pstate *pstate, int64_t n);\nMJS_PRIVATE void emit_str(struct pstate *pstate, const char *ptr, size_t len);\n\n/*\n * Inserts provided offset `v` at the offset `offset`.\n *\n * Returns delta at which the code was moved; the delta can be any: 0 or\n * positive or negative.\n */\nMJS_PRIVATE int mjs_bcode_insert_offset(struct pstate *p, struct mjs *mjs,\n                                        size_t offset, size_t v);\n\n/*\n * Adds a new bcode part; does not retain `bp`.\n */\nMJS_PRIVATE void mjs_bcode_part_add(struct mjs *mjs,\n                                    const struct mjs_bcode_part *bp);\n\n/*\n * Returns bcode part by the bcode number\n */\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get(struct mjs *mjs, int num);\n\n/*\n * Returns bcode part by the global bcode offset\n */\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get_by_offset(struct mjs *mjs,\n                                                                size_t offset);\n\n/*\n * Returns a number of bcode parts\n */\nMJS_PRIVATE int mjs_bcode_parts_cnt(struct mjs *mjs);\n\n/*\n * Adds the bcode being generated (mjs->bcode_gen) as a next bcode part\n */\nMJS_PRIVATE void mjs_bcode_commit(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_BCODE_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_tok.h\"\n#endif\n\n#ifndef MJS_TOK_H_\n#define MJS_TOK_H_\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct tok {\n  int tok;\n  int len;\n  const char *ptr;\n};\n\nstruct pstate {\n  const char *file_name; /* Source code file name */\n  const char *buf;       /* Nul-terminated source code buffer */\n  const char *pos;       /* Current position */\n  int line_no;           /* Line number */\n  int last_emitted_line_no;\n  struct mbuf offset_lineno_map;\n  int prev_tok;   /* Previous token, for prefix increment / decrement */\n  struct tok tok; /* Parsed token */\n  struct mjs *mjs;\n  int start_bcode_idx; /* Index in mjs->bcode at which parsing was started */\n  int cur_idx; /* Index in mjs->bcode at which newly generated code is inserted\n                  */\n  int depth;\n};\n\nenum {\n  TOK_EOF,\n  TOK_INVALID,\n\n  TOK_COLON,\n  TOK_SEMICOLON,\n  TOK_COMMA,\n  TOK_ASSIGN,\n  TOK_OPEN_CURLY,\n  TOK_CLOSE_CURLY,\n  TOK_OPEN_PAREN,\n  TOK_CLOSE_PAREN,\n  TOK_OPEN_BRACKET,\n  TOK_CLOSE_BRACKET,\n  TOK_MUL,\n  TOK_PLUS,\n  TOK_MINUS,\n  TOK_DIV,\n  TOK_REM,\n  TOK_AND,\n  TOK_OR,\n  TOK_XOR,\n  TOK_DOT,\n  TOK_QUESTION,\n  TOK_NOT,\n  TOK_TILDA,\n  TOK_LT,\n  TOK_GT,\n  TOK_LSHIFT,\n  TOK_RSHIFT,\n  TOK_MINUS_MINUS,\n  TOK_PLUS_PLUS,\n  TOK_PLUS_ASSIGN,\n  TOK_MINUS_ASSIGN,\n  TOK_MUL_ASSIGN,\n  TOK_DIV_ASSIGN,\n  TOK_AND_ASSIGN,\n  TOK_OR_ASSIGN,\n  TOK_REM_ASSIGN,\n  TOK_XOR_ASSIGN,\n  TOK_EQ,\n  TOK_NE,\n  TOK_LE,\n  TOK_GE,\n  TOK_LOGICAL_AND,\n  TOK_LOGICAL_OR,\n  TOK_EQ_EQ,\n  TOK_NE_NE,\n  TOK_LSHIFT_ASSIGN,\n  TOK_RSHIFT_ASSIGN,\n  TOK_URSHIFT,\n  TOK_URSHIFT_ASSIGN,\n\n  TOK_UNARY_PLUS,\n  TOK_UNARY_MINUS,\n  TOK_POSTFIX_PLUS,\n  TOK_POSTFIX_MINUS,\n\n  TOK_NUM = 200, /* Make sure they don't clash with ascii '+', '{', etc */\n  TOK_STR,\n  TOK_IDENT,\n  TOK_KEYWORD_BREAK,\n  TOK_KEYWORD_CASE,\n  TOK_KEYWORD_CATCH,\n  TOK_KEYWORD_CONTINUE,\n  TOK_KEYWORD_DEBUGGER,\n  TOK_KEYWORD_DEFAULT,\n  TOK_KEYWORD_DELETE,\n  TOK_KEYWORD_DO,\n  TOK_KEYWORD_ELSE,\n  TOK_KEYWORD_FALSE,\n  TOK_KEYWORD_FINALLY,\n  TOK_KEYWORD_FOR,\n  TOK_KEYWORD_FUNCTION,\n  TOK_KEYWORD_IF,\n  TOK_KEYWORD_IN,\n  TOK_KEYWORD_INSTANCEOF,\n  TOK_KEYWORD_NEW,\n  TOK_KEYWORD_NULL,\n  TOK_KEYWORD_RETURN,\n  TOK_KEYWORD_SWITCH,\n  TOK_KEYWORD_THIS,\n  TOK_KEYWORD_THROW,\n  TOK_KEYWORD_TRUE,\n  TOK_KEYWORD_TRY,\n  TOK_KEYWORD_TYPEOF,\n  TOK_KEYWORD_VAR,\n  TOK_KEYWORD_VOID,\n  TOK_KEYWORD_WHILE,\n  TOK_KEYWORD_WITH,\n  TOK_KEYWORD_LET,\n  TOK_KEYWORD_UNDEFINED,\n  TOK_MAX\n};\n\nMJS_PRIVATE void pinit(const char *file_name, const char *buf, struct pstate *);\nMJS_PRIVATE int pnext(struct pstate *);\nMJS_PRIVATE int mjs_is_ident(int c);\nMJS_PRIVATE int mjs_is_digit(int c);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_TOK_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_dataview.h\"\n#endif\n\n#ifndef MJS_DATAVIEW_H_\n#define MJS_DATAVIEW_H_\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\n/*\n * Functions for memory introspection.\n * These are supposed to be FFI-ed and used from the JS environment.\n */\n\nvoid *mjs_mem_to_ptr(unsigned int val);\nvoid *mjs_mem_get_ptr(void *base, int offset);\nvoid mjs_mem_set_ptr(void *ptr, void *val);\ndouble mjs_mem_get_dbl(void *ptr);\nvoid mjs_mem_set_dbl(void *ptr, double val);\ndouble mjs_mem_get_uint(void *ptr, int size, int bigendian);\ndouble mjs_mem_get_int(void *ptr, int size, int bigendian);\nvoid mjs_mem_set_uint(void *ptr, unsigned int val, int size, int bigendian);\nvoid mjs_mem_set_int(void *ptr, int val, int size, int bigendian);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_DATAVIEW_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec_public.h\"\n#endif\n\n#ifndef MJS_EXEC_PUBLIC_H_\n#define MJS_EXEC_PUBLIC_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n#include <stdio.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nmjs_err_t mjs_exec(struct mjs *, const char *src, mjs_val_t *res);\nmjs_err_t mjs_exec_buf(struct mjs *, const char *src, size_t, mjs_val_t *res);\n\nmjs_err_t mjs_exec_file(struct mjs *mjs, const char *path, mjs_val_t *res);\nmjs_err_t mjs_apply(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                    mjs_val_t this_val, int nargs, mjs_val_t *args);\nmjs_err_t mjs_call(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                   mjs_val_t this_val, int nargs, ...);\nmjs_val_t mjs_get_this(struct mjs *mjs);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_EXEC_PUBLIC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec.h\"\n#endif\n\n#ifndef MJS_EXEC_H_\n#define MJS_EXEC_H_\n\n/* Amalgamated: #include \"mjs_exec_public.h\" */\n\n/*\n * A special bcode offset value which causes mjs_execute() to exit immediately;\n * used in mjs_apply().\n */\n#define MJS_BCODE_OFFSET_EXIT ((size_t) 0x7fffffff)\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_EXEC_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_json.h\"\n#endif\n\n#ifndef MJS_JSON_H_\n#define MJS_JSON_H_\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t to_json_or_debug(struct mjs *mjs, mjs_val_t v, char *buf,\n                                       size_t size, size_t *res_len,\n                                       uint8_t is_debug);\n\nMJS_PRIVATE mjs_err_t mjs_json_stringify(struct mjs *mjs, mjs_val_t v,\n                                         char *buf, size_t size, char **res);\nMJS_PRIVATE void mjs_op_json_stringify(struct mjs *mjs);\nMJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs);\n\nMJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_JSON_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_builtin.h\"\n#endif\n\n#ifndef MJS_BUILTIN_H_\n#define MJS_BUILTIN_H_\n\n/* Amalgamated: #include \"mjs_core_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nvoid mjs_init_builtin(struct mjs *mjs, mjs_val_t obj);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_BUILTIN_H_ */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_parser.h\"\n#endif\n\n#ifndef MJS_PARSER_H\n#define MJS_PARSER_H\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif /* __cplusplus */\n\nMJS_PRIVATE mjs_err_t\nmjs_parse(const char *path, const char *buf, struct mjs *);\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* MJS_PARSER_H */\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/ffi/ffi.c\"\n#endif\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n\n#define IS_W(arg) ((arg).ctype == FFI_CTYPE_WORD)\n#define IS_D(arg) ((arg).ctype == FFI_CTYPE_DOUBLE)\n#define IS_F(arg) ((arg).ctype == FFI_CTYPE_FLOAT)\n\n#define W(arg) ((ffi_word_t)(arg).v.i)\n#define D(arg) ((arg).v.d)\n#define F(arg) ((arg).v.f)\n\nvoid ffi_set_word(struct ffi_arg *arg, ffi_word_t v) {\n  arg->ctype = FFI_CTYPE_WORD;\n  arg->v.i = v;\n}\n\nvoid ffi_set_bool(struct ffi_arg *arg, bool v) {\n  arg->ctype = FFI_CTYPE_BOOL;\n  arg->v.i = v;\n}\n\nvoid ffi_set_ptr(struct ffi_arg *arg, void *v) {\n  ffi_set_word(arg, (ffi_word_t) v);\n}\n\nvoid ffi_set_double(struct ffi_arg *arg, double v) {\n  arg->ctype = FFI_CTYPE_DOUBLE;\n  arg->v.d = v;\n}\n\nvoid ffi_set_float(struct ffi_arg *arg, float v) {\n  arg->ctype = FFI_CTYPE_FLOAT;\n  arg->v.f = v;\n}\n\n/*\n * The ARM ABI uses only 4 32-bit registers for paramter passing.\n * Xtensa call0 calling-convention (as used by Espressif) has 6.\n *\n * Focusing only on implementing FFI with registers means we can simplify a lot.\n *\n * ARM has some quasi-alignment rules when mixing double and integers as\n * arguments. Only:\n *   a) double, int32_t, int32_t\n *   b) int32_t, double\n * would fit in 4 registers. (the same goes for uint64_t).\n *\n * In order to simplify further, when a double-width argument is present, we\n * allow only two arguments.\n */\n\n/*\n * We need to support x86_64 in order to support local tests.\n * x86_64 has more and wider registers, but unlike the two main\n * embedded platforms we target it has a separate register file for\n * integer values and for floating point values (both for passing args and\n * return values). E.g. if a double value is passed as a second argument\n * it gets passed in the first available floating point register.\n *\n * I.e, the compiler generates exactly the same code for:\n *\n * void foo(int a, double b) {...}\n *\n * and\n *\n * void foo(double b, int a) {...}\n *\n *\n */\n\ntypedef ffi_word_t (*w4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*w5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                            ffi_word_t);\ntypedef ffi_word_t (*w6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                            ffi_word_t, ffi_word_t);\n\ntypedef ffi_word_t (*wdw_t)(double, ffi_word_t);\ntypedef ffi_word_t (*wwd_t)(ffi_word_t, double);\ntypedef ffi_word_t (*wdd_t)(double, double);\n\ntypedef ffi_word_t (*wwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef ffi_word_t (*wwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef ffi_word_t (*wwdd_t)(ffi_word_t, double, double);\ntypedef ffi_word_t (*wdww_t)(double, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*wdwd_t)(double, ffi_word_t, double);\ntypedef ffi_word_t (*wddw_t)(double, double, ffi_word_t);\ntypedef ffi_word_t (*wddd_t)(double, double, double);\n\ntypedef ffi_word_t (*wfw_t)(float, ffi_word_t);\ntypedef ffi_word_t (*wwf_t)(ffi_word_t, float);\ntypedef ffi_word_t (*wff_t)(float, float);\n\ntypedef ffi_word_t (*wwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef ffi_word_t (*wwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef ffi_word_t (*wwff_t)(ffi_word_t, float, float);\ntypedef ffi_word_t (*wfww_t)(float, ffi_word_t, ffi_word_t);\ntypedef ffi_word_t (*wfwf_t)(float, ffi_word_t, float);\ntypedef ffi_word_t (*wffw_t)(float, float, ffi_word_t);\ntypedef ffi_word_t (*wfff_t)(float, float, float);\n\ntypedef bool (*b4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef bool (*b5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                      ffi_word_t);\ntypedef bool (*b6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                      ffi_word_t, ffi_word_t);\ntypedef bool (*bdw_t)(double, ffi_word_t);\ntypedef bool (*bwd_t)(ffi_word_t, double);\ntypedef bool (*bdd_t)(double, double);\n\ntypedef bool (*bwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef bool (*bwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef bool (*bwdd_t)(ffi_word_t, double, double);\ntypedef bool (*bdww_t)(double, ffi_word_t, ffi_word_t);\ntypedef bool (*bdwd_t)(double, ffi_word_t, double);\ntypedef bool (*bddw_t)(double, double, ffi_word_t);\ntypedef bool (*bddd_t)(double, double, double);\n\ntypedef bool (*bfw_t)(float, ffi_word_t);\ntypedef bool (*bwf_t)(ffi_word_t, float);\ntypedef bool (*bff_t)(float, float);\n\ntypedef bool (*bwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef bool (*bwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef bool (*bwff_t)(ffi_word_t, float, float);\ntypedef bool (*bfww_t)(float, ffi_word_t, ffi_word_t);\ntypedef bool (*bfwf_t)(float, ffi_word_t, float);\ntypedef bool (*bffw_t)(float, float, ffi_word_t);\ntypedef bool (*bfff_t)(float, float, float);\n\ntypedef double (*d4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef double (*d5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                        ffi_word_t);\ntypedef double (*d6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                        ffi_word_t, ffi_word_t);\ntypedef double (*ddw_t)(double, ffi_word_t);\ntypedef double (*dwd_t)(ffi_word_t, double);\ntypedef double (*ddd_t)(double, double);\n\ntypedef double (*dwwd_t)(ffi_word_t, ffi_word_t, double);\ntypedef double (*dwdw_t)(ffi_word_t, double, ffi_word_t);\ntypedef double (*dwdd_t)(ffi_word_t, double, double);\ntypedef double (*ddww_t)(double, ffi_word_t, ffi_word_t);\ntypedef double (*ddwd_t)(double, ffi_word_t, double);\ntypedef double (*dddw_t)(double, double, ffi_word_t);\ntypedef double (*dddd_t)(double, double, double);\n\ntypedef float (*f4w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t);\ntypedef float (*f5w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                       ffi_word_t);\ntypedef float (*f6w_t)(ffi_word_t, ffi_word_t, ffi_word_t, ffi_word_t,\n                       ffi_word_t, ffi_word_t);\ntypedef float (*ffw_t)(float, ffi_word_t);\ntypedef float (*fwf_t)(ffi_word_t, float);\ntypedef float (*fff_t)(float, float);\n\ntypedef float (*fwwf_t)(ffi_word_t, ffi_word_t, float);\ntypedef float (*fwfw_t)(ffi_word_t, float, ffi_word_t);\ntypedef float (*fwff_t)(ffi_word_t, float, float);\ntypedef float (*ffww_t)(float, ffi_word_t, ffi_word_t);\ntypedef float (*ffwf_t)(float, ffi_word_t, float);\ntypedef float (*fffw_t)(float, float, ffi_word_t);\ntypedef float (*ffff_t)(float, float, float);\n\nint ffi_call(ffi_fn_t *func, int nargs, struct ffi_arg *res,\n             struct ffi_arg *args) {\n  int i, doubles = 0, floats = 0;\n\n  if (nargs > 6) return -1;\n  for (i = 0; i < nargs; i++) {\n    doubles += (IS_D(args[i]));\n    floats += (IS_F(args[i]));\n  }\n\n  /* Doubles and floats are not supported together atm */\n  if (doubles > 0 && floats > 0) {\n    return -1;\n  }\n\n  switch (res->ctype) {\n    case FFI_CTYPE_WORD: { /* {{{ */\n      ffi_word_t r;\n      if (doubles == 0) {\n        if (floats == 0) {\n          /*\n           * No double and no float args: we currently support up to 6\n           * word-sized arguments\n           */\n          if (nargs <= 4) {\n            w4w_t f = (w4w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n          } else if (nargs == 5) {\n            w5w_t f = (w5w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n          } else if (nargs == 6) {\n            w6w_t f = (w6w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                  W(args[5]));\n          } else {\n            abort();\n          }\n        } else {\n          /* There are some floats */\n          switch (nargs) {\n            case 0:\n            case 1:\n            case 2:\n              if (IS_F(args[0]) && IS_F(args[1])) {\n                wff_t f = (wff_t) func;\n                r = f(F(args[0]), F(args[1]));\n              } else if (IS_F(args[0])) {\n                wfw_t f = (wfw_t) func;\n                r = f(F(args[0]), W(args[1]));\n              } else {\n                wwf_t f = (wwf_t) func;\n                r = f(W(args[0]), F(args[1]));\n              }\n              break;\n\n            case 3:\n              if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                wwwf_t f = (wwwf_t) func;\n                r = f(W(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                wwfw_t f = (wwfw_t) func;\n                r = f(W(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                wwff_t f = (wwff_t) func;\n                r = f(W(args[0]), F(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n                wfww_t f = (wfww_t) func;\n                r = f(F(args[0]), W(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                wfwf_t f = (wfwf_t) func;\n                r = f(F(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                wffw_t f = (wffw_t) func;\n                r = f(F(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                wfff_t f = (wfff_t) func;\n                r = f(F(args[0]), F(args[1]), F(args[2]));\n              } else {\n                // The above checks should be exhaustive\n                abort();\n              }\n              break;\n            default:\n              return -1;\n          }\n        }\n      } else {\n        /* There are some doubles */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              wdd_t f = (wdd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              wdw_t f = (wdw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              wwd_t f = (wwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              wwwd_t f = (wwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              wwdw_t f = (wwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              wwdd_t f = (wwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              wdww_t f = (wdww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              wdwd_t f = (wdwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              wddw_t f = (wddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              wddd_t f = (wddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.i = (uint64_t) r;\n    } break;               /* }}} */\n    case FFI_CTYPE_BOOL: { /* {{{ */\n      ffi_word_t r;\n      if (doubles == 0) {\n        if (floats == 0) {\n          /*\n           * No double and no float args: we currently support up to 6\n           * word-sized arguments\n           */\n          if (nargs <= 4) {\n            b4w_t f = (b4w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n          } else if (nargs == 5) {\n            b5w_t f = (b5w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n          } else if (nargs == 6) {\n            b6w_t f = (b6w_t) func;\n            r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                  W(args[5]));\n          } else {\n            abort();\n          }\n        } else {\n          /* There are some floats */\n          switch (nargs) {\n            case 0:\n            case 1:\n            case 2:\n              if (IS_F(args[0]) && IS_F(args[1])) {\n                bff_t f = (bff_t) func;\n                r = f(F(args[0]), F(args[1]));\n              } else if (IS_F(args[0])) {\n                bfw_t f = (bfw_t) func;\n                r = f(F(args[0]), W(args[1]));\n              } else {\n                bwf_t f = (bwf_t) func;\n                r = f(W(args[0]), F(args[1]));\n              }\n              break;\n\n            case 3:\n              if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                bwwf_t f = (bwwf_t) func;\n                r = f(W(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                bwfw_t f = (bwfw_t) func;\n                r = f(W(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                bwff_t f = (bwff_t) func;\n                r = f(W(args[0]), F(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n                bfww_t f = (bfww_t) func;\n                r = f(F(args[0]), W(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n                bfwf_t f = (bfwf_t) func;\n                r = f(F(args[0]), W(args[1]), F(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n                bffw_t f = (bffw_t) func;\n                r = f(F(args[0]), F(args[1]), W(args[2]));\n              } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n                bfff_t f = (bfff_t) func;\n                r = f(F(args[0]), F(args[1]), F(args[2]));\n              } else {\n                // The above checks should be exhaustive\n                abort();\n              }\n              break;\n            default:\n              return -1;\n          }\n        }\n      } else {\n        /* There are some doubles */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              bdd_t f = (bdd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              bdw_t f = (bdw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              bwd_t f = (bwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              bwwd_t f = (bwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              bwdw_t f = (bwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              bwdd_t f = (bwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              bdww_t f = (bdww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              bdwd_t f = (bdwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              bddw_t f = (bddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              bddd_t f = (bddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.i = (uint64_t) r;\n    } break;                 /* }}} */\n    case FFI_CTYPE_DOUBLE: { /* {{{ */\n      double r;\n      if (doubles == 0) {\n        /* No double args: we currently support up to 6 word-sized arguments\n         */\n        if (nargs <= 4) {\n          d4w_t f = (d4w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n        } else if (nargs == 5) {\n          d5w_t f = (d5w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n        } else if (nargs == 6) {\n          d6w_t f = (d6w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                W(args[5]));\n        } else {\n          abort();\n        }\n      } else {\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_D(args[0]) && IS_D(args[1])) {\n              ddd_t f = (ddd_t) func;\n              r = f(D(args[0]), D(args[1]));\n            } else if (IS_D(args[0])) {\n              ddw_t f = (ddw_t) func;\n              r = f(D(args[0]), W(args[1]));\n            } else {\n              dwd_t f = (dwd_t) func;\n              r = f(W(args[0]), D(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              dwwd_t f = (dwwd_t) func;\n              r = f(W(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              dwdw_t f = (dwdw_t) func;\n              r = f(W(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              dwdd_t f = (dwdd_t) func;\n              r = f(W(args[0]), D(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              ddww_t f = (ddww_t) func;\n              r = f(D(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_W(args[1]) && IS_D(args[2])) {\n              ddwd_t f = (ddwd_t) func;\n              r = f(D(args[0]), W(args[1]), D(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_W(args[2])) {\n              dddw_t f = (dddw_t) func;\n              r = f(D(args[0]), D(args[1]), W(args[2]));\n            } else if (IS_D(args[0]) && IS_D(args[1]) && IS_D(args[2])) {\n              dddd_t f = (dddd_t) func;\n              r = f(D(args[0]), D(args[1]), D(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.d = r;\n    } break;                /* }}} */\n    case FFI_CTYPE_FLOAT: { /* {{{ */\n      double r;\n      if (floats == 0) {\n        /* No float args: we currently support up to 6 word-sized arguments\n         */\n        if (nargs <= 4) {\n          f4w_t f = (f4w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]));\n        } else if (nargs == 5) {\n          f5w_t f = (f5w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]));\n        } else if (nargs == 6) {\n          f6w_t f = (f6w_t) func;\n          r = f(W(args[0]), W(args[1]), W(args[2]), W(args[3]), W(args[4]),\n                W(args[5]));\n        } else {\n          abort();\n        }\n      } else {\n        /* There are some float args */\n        switch (nargs) {\n          case 0:\n          case 1:\n          case 2:\n            if (IS_F(args[0]) && IS_F(args[1])) {\n              fff_t f = (fff_t) func;\n              r = f(F(args[0]), F(args[1]));\n            } else if (IS_F(args[0])) {\n              ffw_t f = (ffw_t) func;\n              r = f(F(args[0]), W(args[1]));\n            } else {\n              fwf_t f = (fwf_t) func;\n              r = f(W(args[0]), F(args[1]));\n            }\n            break;\n\n          case 3:\n            if (IS_W(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n              fwwf_t f = (fwwf_t) func;\n              r = f(W(args[0]), W(args[1]), F(args[2]));\n            } else if (IS_W(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n              fwfw_t f = (fwfw_t) func;\n              r = f(W(args[0]), F(args[1]), W(args[2]));\n            } else if (IS_W(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n              fwff_t f = (fwff_t) func;\n              r = f(W(args[0]), F(args[1]), F(args[2]));\n            } else if (IS_F(args[0]) && IS_W(args[1]) && IS_W(args[2])) {\n              ffww_t f = (ffww_t) func;\n              r = f(F(args[0]), W(args[1]), W(args[2]));\n            } else if (IS_F(args[0]) && IS_W(args[1]) && IS_F(args[2])) {\n              ffwf_t f = (ffwf_t) func;\n              r = f(F(args[0]), W(args[1]), F(args[2]));\n            } else if (IS_F(args[0]) && IS_F(args[1]) && IS_W(args[2])) {\n              fffw_t f = (fffw_t) func;\n              r = f(F(args[0]), F(args[1]), W(args[2]));\n            } else if (IS_F(args[0]) && IS_F(args[1]) && IS_F(args[2])) {\n              ffff_t f = (ffff_t) func;\n              r = f(F(args[0]), F(args[1]), F(args[2]));\n            } else {\n              // The above checks should be exhaustive\n              abort();\n            }\n            break;\n          default:\n            return -1;\n        }\n      }\n      res->v.f = r;\n    } break; /* }}} */\n  }\n\n  return 0;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_array.c\"\n#endif\n\n#include <stdio.h>\n#include \"common/str_util.h\"\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#define SPLICE_NEW_ITEM_IDX 2\n\n/* like c_snprintf but returns `size` if write is truncated */\nstatic int v_sprintf_s(char *buf, size_t size, const char *fmt, ...) {\n  size_t n;\n  va_list ap;\n  va_start(ap, fmt);\n  n = c_vsnprintf(buf, size, fmt, ap);\n  if (n > size) {\n    return size;\n  }\n  return n;\n}\n\nmjs_val_t mjs_mk_array(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_object(mjs);\n  /* change the tag to MJS_TAG_ARRAY */\n  ret &= ~MJS_TAG_MASK;\n  ret |= MJS_TAG_ARRAY;\n  return ret;\n}\n\nint mjs_is_array(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_ARRAY;\n}\n\nmjs_val_t mjs_array_get(struct mjs *mjs, mjs_val_t arr, unsigned long index) {\n  return mjs_array_get2(mjs, arr, index, NULL);\n}\n\nmjs_val_t mjs_array_get2(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                         int *has) {\n  mjs_val_t res = MJS_UNDEFINED;\n\n  if (has != NULL) {\n    *has = 0;\n  }\n\n  if (mjs_is_object(arr)) {\n    struct mjs_property *p;\n    char buf[20];\n    int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n    p = mjs_get_own_property(mjs, arr, buf, n);\n    if (p != NULL) {\n      if (has != NULL) {\n        *has = 1;\n      }\n      res = p->value;\n    }\n  }\n\n  return res;\n}\n\nunsigned long mjs_array_length(struct mjs *mjs, mjs_val_t v) {\n  struct mjs_property *p;\n  unsigned long len = 0;\n\n  if (!mjs_is_object(v)) {\n    len = 0;\n    goto clean;\n  }\n\n  for (p = get_object_struct(v)->properties; p != NULL; p = p->next) {\n    int ok = 0;\n    unsigned long n = 0;\n    str_to_ulong(mjs, p->name, &ok, &n);\n    if (ok && n >= len && n < 0xffffffff) {\n      len = n + 1;\n    }\n  }\n\nclean:\n  return len;\n}\n\nmjs_err_t mjs_array_set(struct mjs *mjs, mjs_val_t arr, unsigned long index,\n                        mjs_val_t v) {\n  mjs_err_t ret = MJS_OK;\n\n  if (mjs_is_object(arr)) {\n    char buf[20];\n    int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n    ret = mjs_set(mjs, arr, buf, n, v);\n  } else {\n    ret = MJS_TYPE_ERROR;\n  }\n\n  return ret;\n}\n\nvoid mjs_array_del(struct mjs *mjs, mjs_val_t arr, unsigned long index) {\n  char buf[20];\n  int n = v_sprintf_s(buf, sizeof(buf), \"%lu\", index);\n  mjs_del(mjs, arr, buf, n);\n}\n\nmjs_err_t mjs_array_push(struct mjs *mjs, mjs_val_t arr, mjs_val_t v) {\n  return mjs_array_set(mjs, arr, mjs_array_length(mjs, arr), v);\n}\n\nMJS_PRIVATE void mjs_array_push_internal(struct mjs *mjs) {\n  mjs_err_t rcode = MJS_OK;\n  mjs_val_t ret = MJS_UNDEFINED;\n  int nargs = mjs_nargs(mjs);\n  int i;\n\n  /* Make sure that `this` is an array */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_OBJECT_ARRAY, NULL)) {\n    goto clean;\n  }\n\n  /* Push all args */\n  for (i = 0; i < nargs; i++) {\n    rcode = mjs_array_push(mjs, mjs->vals.this_obj, mjs_arg(mjs, i));\n    if (rcode != MJS_OK) {\n      mjs_prepend_errorf(mjs, rcode, \"\");\n      goto clean;\n    }\n  }\n\n  /* Return the new array length */\n  ret = mjs_mk_number(mjs, mjs_array_length(mjs, mjs->vals.this_obj));\n\nclean:\n  mjs_return(mjs, ret);\n  return;\n}\n\nstatic void move_item(struct mjs *mjs, mjs_val_t arr, unsigned long from,\n                      unsigned long to) {\n  mjs_val_t cur = mjs_array_get(mjs, arr, from);\n  mjs_array_set(mjs, arr, to, cur);\n  mjs_array_del(mjs, arr, from);\n}\n\nMJS_PRIVATE void mjs_array_splice(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_err_t rcode = MJS_OK;\n  mjs_val_t ret = mjs_mk_array(mjs);\n  mjs_val_t start_v = MJS_UNDEFINED;\n  mjs_val_t deleteCount_v = MJS_UNDEFINED;\n  int start = 0;\n  int arr_len;\n  int delete_cnt = 0;\n  int new_items_cnt = 0;\n  int delta = 0;\n  int i;\n\n  /* Make sure that `this` is an array */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_OBJECT_ARRAY, NULL)) {\n    goto clean;\n  }\n\n  /* Get array length */\n  arr_len = mjs_array_length(mjs, mjs->vals.this_obj);\n\n  /* get start from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"start\", MJS_TYPE_NUMBER, &start_v)) {\n    goto clean;\n  }\n  start = mjs_normalize_idx(mjs_get_int(mjs, start_v), arr_len);\n\n  /* Handle deleteCount */\n  if (nargs >= SPLICE_NEW_ITEM_IDX) {\n    /* deleteCount is given; use it */\n    if (!mjs_check_arg(mjs, 1, \"deleteCount\", MJS_TYPE_NUMBER,\n                       &deleteCount_v)) {\n      goto clean;\n    }\n    delete_cnt = mjs_get_int(mjs, deleteCount_v);\n    new_items_cnt = nargs - SPLICE_NEW_ITEM_IDX;\n  } else {\n    /* deleteCount is not given; assume the end of the array */\n    delete_cnt = arr_len - start;\n  }\n  if (delete_cnt > arr_len - start) {\n    delete_cnt = arr_len - start;\n  } else if (delete_cnt < 0) {\n    delete_cnt = 0;\n  }\n\n  /* delta at which subsequent array items should be moved */\n  delta = new_items_cnt - delete_cnt;\n\n  /*\n   * copy items which are going to be deleted to the separate array (will be\n   * returned)\n   */\n  for (i = 0; i < delete_cnt; i++) {\n    mjs_val_t cur = mjs_array_get(mjs, mjs->vals.this_obj, start + i);\n    rcode = mjs_array_push(mjs, ret, cur);\n    if (rcode != MJS_OK) {\n      mjs_prepend_errorf(mjs, rcode, \"\");\n      goto clean;\n    }\n  }\n\n  /* If needed, move subsequent items */\n  if (delta < 0) {\n    for (i = start; i < arr_len; i++) {\n      if (i >= start - delta) {\n        move_item(mjs, mjs->vals.this_obj, i, i + delta);\n      } else {\n        mjs_array_del(mjs, mjs->vals.this_obj, i);\n      }\n    }\n  } else if (delta > 0) {\n    for (i = arr_len - 1; i >= start; i--) {\n      move_item(mjs, mjs->vals.this_obj, i, i + delta);\n    }\n  }\n\n  /* Set new items to the array */\n  for (i = 0; i < nargs - SPLICE_NEW_ITEM_IDX; i++) {\n    mjs_array_set(mjs, mjs->vals.this_obj, start + i,\n                  mjs_arg(mjs, SPLICE_NEW_ITEM_IDX + i));\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_bcode.c\"\n#endif\n\n#include \"common/cs_varint.h\"\n\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nstatic void add_lineno_map_item(struct pstate *pstate) {\n  if (pstate->last_emitted_line_no < pstate->line_no) {\n    int offset = pstate->cur_idx - pstate->start_bcode_idx;\n    size_t offset_llen = cs_varint_llen(offset);\n    size_t lineno_llen = cs_varint_llen(pstate->line_no);\n    mbuf_resize(&pstate->offset_lineno_map,\n                pstate->offset_lineno_map.size + offset_llen + lineno_llen);\n\n    /* put offset */\n    cs_varint_encode(offset, (uint8_t *) pstate->offset_lineno_map.buf +\n                                 pstate->offset_lineno_map.len,\n                     offset_llen);\n    pstate->offset_lineno_map.len += offset_llen;\n\n    /* put line_no */\n    cs_varint_encode(pstate->line_no,\n                     (uint8_t *) pstate->offset_lineno_map.buf +\n                         pstate->offset_lineno_map.len,\n                     lineno_llen);\n    pstate->offset_lineno_map.len += lineno_llen;\n\n    pstate->last_emitted_line_no = pstate->line_no;\n  }\n}\n\nMJS_PRIVATE void emit_byte(struct pstate *pstate, uint8_t byte) {\n  add_lineno_map_item(pstate);\n  mbuf_insert(&pstate->mjs->bcode_gen, pstate->cur_idx, &byte, sizeof(byte));\n  pstate->cur_idx += sizeof(byte);\n}\n\nMJS_PRIVATE void emit_int(struct pstate *pstate, int64_t n) {\n  struct mbuf *b = &pstate->mjs->bcode_gen;\n  size_t llen = cs_varint_llen(n);\n  add_lineno_map_item(pstate);\n  mbuf_insert(b, pstate->cur_idx, NULL, llen);\n  cs_varint_encode(n, (uint8_t *) b->buf + pstate->cur_idx, llen);\n  pstate->cur_idx += llen;\n}\n\nMJS_PRIVATE void emit_str(struct pstate *pstate, const char *ptr, size_t len) {\n  struct mbuf *b = &pstate->mjs->bcode_gen;\n  size_t llen = cs_varint_llen(len);\n  add_lineno_map_item(pstate);\n  mbuf_insert(b, pstate->cur_idx, NULL, llen + len);\n  cs_varint_encode(len, (uint8_t *) b->buf + pstate->cur_idx, llen);\n  memcpy(b->buf + pstate->cur_idx + llen, ptr, len);\n  pstate->cur_idx += llen + len;\n}\n\nMJS_PRIVATE int mjs_bcode_insert_offset(struct pstate *p, struct mjs *mjs,\n                                        size_t offset, size_t v) {\n  int llen = (int) cs_varint_llen(v);\n  int diff = llen - MJS_INIT_OFFSET_SIZE;\n  assert(offset < mjs->bcode_gen.len);\n  if (diff > 0) {\n    mbuf_resize(&mjs->bcode_gen, mjs->bcode_gen.size + diff);\n  }\n  /*\n   * Offset is going to take more than one was reserved, so, move the data\n   * forward\n   */\n  memmove(mjs->bcode_gen.buf + offset + llen,\n          mjs->bcode_gen.buf + offset + MJS_INIT_OFFSET_SIZE,\n          mjs->bcode_gen.len - offset - MJS_INIT_OFFSET_SIZE);\n  mjs->bcode_gen.len += diff;\n  cs_varint_encode(v, (uint8_t *) mjs->bcode_gen.buf + offset, llen);\n\n  /*\n   * If current parsing index is after the offset at which we've inserted new\n   * varint, the index might need to be adjusted\n   */\n  if (p->cur_idx >= (int) offset) {\n    p->cur_idx += diff;\n  }\n  return diff;\n}\n\nMJS_PRIVATE void mjs_bcode_part_add(struct mjs *mjs,\n                                    const struct mjs_bcode_part *bp) {\n  mbuf_append(&mjs->bcode_parts, bp, sizeof(*bp));\n}\n\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get(struct mjs *mjs,\n                                                      int num) {\n  assert(num < mjs_bcode_parts_cnt(mjs));\n  return (struct mjs_bcode_part *) (mjs->bcode_parts.buf +\n                                    num * sizeof(struct mjs_bcode_part));\n}\n\nMJS_PRIVATE struct mjs_bcode_part *mjs_bcode_part_get_by_offset(struct mjs *mjs,\n                                                                size_t offset) {\n  int i;\n  int parts_cnt = mjs_bcode_parts_cnt(mjs);\n  struct mjs_bcode_part *bp = NULL;\n\n  if (offset >= mjs->bcode_len) {\n    return NULL;\n  }\n\n  for (i = 0; i < parts_cnt; i++) {\n    bp = mjs_bcode_part_get(mjs, i);\n    if (offset < bp->start_idx + bp->data.len) {\n      break;\n    }\n  }\n\n  /* given the non-corrupted data, the needed part must be found */\n  assert(i < parts_cnt);\n\n  return bp;\n}\n\nMJS_PRIVATE int mjs_bcode_parts_cnt(struct mjs *mjs) {\n  return mjs->bcode_parts.len / sizeof(struct mjs_bcode_part);\n}\n\nMJS_PRIVATE void mjs_bcode_commit(struct mjs *mjs) {\n  struct mjs_bcode_part bp;\n  memset(&bp, 0, sizeof(bp));\n\n  /* Make sure the bcode doesn't occupy any extra space */\n  mbuf_trim(&mjs->bcode_gen);\n\n  /* Transfer the ownership of the bcode data */\n  bp.data.p = mjs->bcode_gen.buf;\n  bp.data.len = mjs->bcode_gen.len;\n  mbuf_init(&mjs->bcode_gen, 0);\n\n  bp.start_idx = mjs->bcode_len;\n  bp.exec_res = MJS_ERRS_CNT;\n\n  mjs_bcode_part_add(mjs, &bp);\n\n  mjs->bcode_len += bp.data.len;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_builtin.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_dataview.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_json.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nstatic void mjs_print(struct mjs *mjs) {\n  size_t i, num_args = mjs_nargs(mjs);\n  for (i = 0; i < num_args; i++) {\n    mjs_fprintf(mjs_arg(mjs, i), mjs, stdout);\n    putchar(' ');\n  }\n  putchar('\\n');\n  mjs_return(mjs, MJS_UNDEFINED);\n}\n\n/*\n * If the file with the given filename was already loaded, returns the\n * corresponding bcode part; otherwise returns NULL.\n */\nstatic struct mjs_bcode_part *mjs_get_loaded_file_bcode(struct mjs *mjs,\n                                                        const char *filename) {\n  int parts_cnt = mjs_bcode_parts_cnt(mjs);\n  int i;\n\n  if (filename == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < parts_cnt; i++) {\n    struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n    const char *cur_fn = mjs_get_bcode_filename(mjs, bp);\n    if (strcmp(filename, cur_fn) == 0) {\n      return bp;\n    }\n  }\n  return NULL;\n}\n\nstatic void mjs_load(struct mjs *mjs) {\n  mjs_val_t res = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n  mjs_val_t arg1 = mjs_arg(mjs, 1);\n  int custom_global = 0; /* whether the custom global object was provided */\n\n  if (mjs_is_string(arg0)) {\n    const char *path = mjs_get_cstring(mjs, &arg0);\n    struct mjs_bcode_part *bp = NULL;\n    mjs_err_t ret;\n\n    if (mjs_is_object(arg1)) {\n      custom_global = 1;\n      push_mjs_val(&mjs->scopes, arg1);\n    }\n    bp = mjs_get_loaded_file_bcode(mjs, path);\n    if (bp == NULL) {\n      /* File was not loaded before, so, load */\n      ret = mjs_exec_file(mjs, path, &res);\n    } else {\n      /*\n       * File was already loaded before, so if it was evaluated successfully,\n       * then skip the evaluation at all (and assume MJS_OK); otherwise\n       * re-evaluate it again.\n       *\n       * However, if the custom global object was provided, then reevaluate\n       * the file in any case.\n       */\n      if (bp->exec_res != MJS_OK || custom_global) {\n        ret = mjs_execute(mjs, bp->start_idx, &res);\n      } else {\n        ret = MJS_OK;\n      }\n    }\n    if (ret != MJS_OK) {\n      /*\n       * arg0 and path might be invalidated by executing a file, so refresh\n       * them\n       */\n      arg0 = mjs_arg(mjs, 0);\n      path = mjs_get_cstring(mjs, &arg0);\n      mjs_prepend_errorf(mjs, ret, \"failed to exec file \\\"%s\\\"\", path);\n      goto clean;\n    }\n\n  clean:\n    if (custom_global) {\n      mjs_pop_val(&mjs->scopes);\n    }\n  }\n  mjs_return(mjs, res);\n}\n\nstatic void mjs_get_mjs(struct mjs *mjs) {\n  mjs_return(mjs, mjs_mk_foreign(mjs, mjs));\n}\n\nstatic void mjs_chr(struct mjs *mjs) {\n  mjs_val_t arg0 = mjs_arg(mjs, 0), res = MJS_NULL;\n  int n = mjs_get_int(mjs, arg0);\n  if (mjs_is_number(arg0) && n >= 0 && n <= 255) {\n    uint8_t s = n;\n    res = mjs_mk_string(mjs, (const char *) &s, sizeof(s), 1);\n  }\n  mjs_return(mjs, res);\n}\n\nstatic void mjs_do_gc(struct mjs *mjs) {\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n  mjs_gc(mjs, mjs_is_boolean(arg0) ? mjs_get_bool(mjs, arg0) : 0);\n  mjs_return(mjs, arg0);\n}\n\nstatic void mjs_s2o(struct mjs *mjs) {\n  mjs_return(mjs,\n             mjs_struct_to_obj(mjs, mjs_get_ptr(mjs, mjs_arg(mjs, 0)),\n                               (const struct mjs_c_struct_member *) mjs_get_ptr(\n                                   mjs, mjs_arg(mjs, 1))));\n}\n\nvoid mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) {\n  mjs_val_t v;\n\n  mjs_set(mjs, obj, \"global\", ~0, obj);\n\n  mjs_set(mjs, obj, \"load\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_load));\n  mjs_set(mjs, obj, \"print\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_print));\n  mjs_set(mjs, obj, \"ffi\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call));\n  mjs_set(mjs, obj, \"ffi_cb_free\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free));\n  mjs_set(mjs, obj, \"mkstr\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr));\n  mjs_set(mjs, obj, \"getMJS\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_get_mjs));\n  mjs_set(mjs, obj, \"die\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_die));\n  mjs_set(mjs, obj, \"gc\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_do_gc));\n  mjs_set(mjs, obj, \"chr\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_chr));\n  mjs_set(mjs, obj, \"s2o\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o));\n\n  /*\n   * Populate JSON.parse() and JSON.stringify()\n   */\n  v = mjs_mk_object(mjs);\n  mjs_set(mjs, v, \"stringify\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_stringify));\n  mjs_set(mjs, v, \"parse\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_parse));\n  mjs_set(mjs, obj, \"JSON\", ~0, v);\n\n  /*\n   * Populate Object.create()\n   */\n  v = mjs_mk_object(mjs);\n  mjs_set(mjs, v, \"create\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_create_object));\n  mjs_set(mjs, obj, \"Object\", ~0, v);\n\n  /*\n   * Populate numeric stuff\n   */\n  mjs_set(mjs, obj, \"NaN\", ~0, MJS_TAG_NAN);\n  mjs_set(mjs, obj, \"isNaN\", ~0,\n          mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_isnan));\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_conversion.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nMJS_PRIVATE mjs_err_t mjs_to_string(struct mjs *mjs, mjs_val_t *v, char **p,\n                                    size_t *sizep, int *need_free) {\n  mjs_err_t ret = MJS_OK;\n\n  *p = NULL;\n  *sizep = 0;\n  *need_free = 0;\n\n  if (mjs_is_string(*v)) {\n    *p = (char *) mjs_get_string(mjs, v, sizep);\n  } else if (mjs_is_number(*v)) {\n    char buf[50] = \"\";\n    struct json_out out = JSON_OUT_BUF(buf, sizeof(buf));\n    mjs_jprintf(*v, mjs, &out);\n    *sizep = strlen(buf);\n    *p = malloc(*sizep + 1);\n    if (*p == NULL) {\n      ret = MJS_OUT_OF_MEMORY;\n      goto clean;\n    }\n    memmove(*p, buf, *sizep + 1);\n    *need_free = 1;\n  } else if (mjs_is_boolean(*v)) {\n    if (mjs_get_bool(mjs, *v)) {\n      *p = \"true\";\n      *sizep = 4;\n    } else {\n      *p = \"false\";\n      *sizep = 5;\n    }\n  } else if (mjs_is_undefined(*v)) {\n    *p = \"undefined\";\n    *sizep = 9;\n  } else if (mjs_is_null(*v)) {\n    *p = \"null\";\n    *sizep = 4;\n  } else if (mjs_is_object(*v)) {\n    ret = MJS_TYPE_ERROR;\n    mjs_set_errorf(mjs, ret,\n                   \"conversion from object to string is not supported\");\n  } else if (mjs_is_foreign(*v)) {\n    *p = \"TODO_foreign\";\n    *sizep = 12;\n  } else {\n    ret = MJS_TYPE_ERROR;\n    mjs_set_errorf(mjs, ret, \"unknown type to convert to string\");\n  }\n\nclean:\n  return ret;\n}\n\nMJS_PRIVATE mjs_val_t mjs_to_boolean_v(struct mjs *mjs, mjs_val_t v) {\n  size_t len;\n  int is_truthy;\n\n  is_truthy =\n      ((mjs_is_boolean(v) && mjs_get_bool(mjs, v)) ||\n       (mjs_is_number(v) && mjs_get_double(mjs, v) != 0.0) ||\n       (mjs_is_string(v) && mjs_get_string(mjs, &v, &len) && len > 0) ||\n       (mjs_is_function(v)) || (mjs_is_foreign(v)) || (mjs_is_object(v))) &&\n      v != MJS_TAG_NAN;\n\n  return mjs_mk_boolean(mjs, is_truthy);\n}\n\nMJS_PRIVATE int mjs_is_truthy(struct mjs *mjs, mjs_val_t v) {\n  return mjs_get_bool(mjs, mjs_to_boolean_v(mjs, v));\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_core.c\"\n#endif\n\n#include \"common/cs_varint.h\"\n#include \"common/str_util.h\"\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_builtin.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#ifndef MJS_OBJECT_ARENA_SIZE\n#define MJS_OBJECT_ARENA_SIZE 20\n#endif\n#ifndef MJS_PROPERTY_ARENA_SIZE\n#define MJS_PROPERTY_ARENA_SIZE 20\n#endif\n#ifndef MJS_FUNC_FFI_ARENA_SIZE\n#define MJS_FUNC_FFI_ARENA_SIZE 20\n#endif\n\n#ifndef MJS_OBJECT_ARENA_INC_SIZE\n#define MJS_OBJECT_ARENA_INC_SIZE 10\n#endif\n#ifndef MJS_PROPERTY_ARENA_INC_SIZE\n#define MJS_PROPERTY_ARENA_INC_SIZE 10\n#endif\n#ifndef MJS_FUNC_FFI_ARENA_INC_SIZE\n#define MJS_FUNC_FFI_ARENA_INC_SIZE 10\n#endif\n\nvoid mjs_destroy(struct mjs *mjs) {\n  {\n    int parts_cnt = mjs_bcode_parts_cnt(mjs);\n    int i;\n    for (i = 0; i < parts_cnt; i++) {\n      struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n      if (!bp->in_rom) {\n        free((void *) bp->data.p);\n      }\n    }\n  }\n\n  mbuf_free(&mjs->bcode_gen);\n  mbuf_free(&mjs->bcode_parts);\n  mbuf_free(&mjs->stack);\n  mbuf_free(&mjs->call_stack);\n  mbuf_free(&mjs->arg_stack);\n  mbuf_free(&mjs->owned_strings);\n  mbuf_free(&mjs->foreign_strings);\n  mbuf_free(&mjs->owned_values);\n  mbuf_free(&mjs->scopes);\n  mbuf_free(&mjs->loop_addresses);\n  mbuf_free(&mjs->json_visited_stack);\n  free(mjs->error_msg);\n  free(mjs->stack_trace);\n  mjs_ffi_args_free_list(mjs);\n  gc_arena_destroy(mjs, &mjs->object_arena);\n  gc_arena_destroy(mjs, &mjs->property_arena);\n  gc_arena_destroy(mjs, &mjs->ffi_sig_arena);\n  free(mjs);\n}\n\nstruct mjs *mjs_create(void) {\n  mjs_val_t global_object;\n  struct mjs *mjs = calloc(1, sizeof(*mjs));\n  mbuf_init(&mjs->stack, 0);\n  mbuf_init(&mjs->call_stack, 0);\n  mbuf_init(&mjs->arg_stack, 0);\n  mbuf_init(&mjs->owned_strings, 0);\n  mbuf_init(&mjs->foreign_strings, 0);\n  mbuf_init(&mjs->bcode_gen, 0);\n  mbuf_init(&mjs->bcode_parts, 0);\n  mbuf_init(&mjs->owned_values, 0);\n  mbuf_init(&mjs->scopes, 0);\n  mbuf_init(&mjs->loop_addresses, 0);\n  mbuf_init(&mjs->json_visited_stack, 0);\n\n  mjs->bcode_len = 0;\n\n  /*\n   * The compacting GC exploits the null terminator of the previous string as a\n   * marker.\n   */\n  {\n    char z = 0;\n    mbuf_append(&mjs->owned_strings, &z, 1);\n  }\n\n  gc_arena_init(&mjs->object_arena, sizeof(struct mjs_object),\n                MJS_OBJECT_ARENA_SIZE, MJS_OBJECT_ARENA_INC_SIZE);\n  gc_arena_init(&mjs->property_arena, sizeof(struct mjs_property),\n                MJS_PROPERTY_ARENA_SIZE, MJS_PROPERTY_ARENA_INC_SIZE);\n  gc_arena_init(&mjs->ffi_sig_arena, sizeof(struct mjs_ffi_sig),\n                MJS_FUNC_FFI_ARENA_SIZE, MJS_FUNC_FFI_ARENA_INC_SIZE);\n  mjs->ffi_sig_arena.destructor = mjs_ffi_sig_destructor;\n\n  global_object = mjs_mk_object(mjs);\n  mjs_init_builtin(mjs, global_object);\n  mjs_set_ffi_resolver(mjs, dlsym);\n  push_mjs_val(&mjs->scopes, global_object);\n  mjs->vals.this_obj = MJS_UNDEFINED;\n  mjs->vals.dataview_proto = MJS_UNDEFINED;\n\n  return mjs;\n}\n\nmjs_err_t mjs_set_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  free(mjs->error_msg);\n  mjs->error_msg = NULL;\n  mjs->error = err;\n  if (fmt != NULL) {\n    mg_avprintf(&mjs->error_msg, 0, fmt, ap);\n  }\n  va_end(ap);\n  return err;\n}\n\nmjs_err_t mjs_prepend_errorf(struct mjs *mjs, mjs_err_t err, const char *fmt,\n                             ...) {\n  char *old_error_msg = mjs->error_msg;\n  char *new_error_msg = NULL;\n  va_list ap;\n  va_start(ap, fmt);\n\n  /* err should never be MJS_OK here */\n  assert(err != MJS_OK);\n\n  mjs->error_msg = NULL;\n  /* set error if only it wasn't already set to some error */\n  if (mjs->error == MJS_OK) {\n    mjs->error = err;\n  }\n  mg_avprintf(&new_error_msg, 0, fmt, ap);\n  va_end(ap);\n\n  if (old_error_msg != NULL) {\n    mg_asprintf(&mjs->error_msg, 0, \"%s: %s\", new_error_msg, old_error_msg);\n    free(new_error_msg);\n    free(old_error_msg);\n  } else {\n    mjs->error_msg = new_error_msg;\n  }\n  return err;\n}\n\nvoid mjs_print_error(struct mjs *mjs, FILE *fp, const char *msg,\n                     int print_stack_trace) {\n  if (print_stack_trace && mjs->stack_trace != NULL) {\n    fprintf(fp, \"%s\", mjs->stack_trace);\n  }\n\n  if (msg == NULL) {\n    msg = \"MJS error\";\n  }\n\n  fprintf(fp, \"%s: %s\\n\", msg, mjs_strerror(mjs, mjs->error));\n}\n\nMJS_PRIVATE void mjs_die(struct mjs *mjs) {\n  mjs_val_t msg_v = MJS_UNDEFINED;\n  const char *msg = NULL;\n  size_t msg_len = 0;\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"msg\", MJS_TYPE_STRING, &msg_v)) {\n    goto clean;\n  }\n\n  msg = mjs_get_string(mjs, &msg_v, &msg_len);\n\n  /* TODO(dfrank): take error type as an argument */\n  mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"%.*s\", (int) msg_len, msg);\n\nclean:\n  mjs_return(mjs, MJS_UNDEFINED);\n}\n\nconst char *mjs_strerror(struct mjs *mjs, enum mjs_err err) {\n  const char *err_names[] = {\n      \"NO_ERROR\",        \"SYNTAX_ERROR\",    \"REFERENCE_ERROR\",\n      \"TYPE_ERROR\",      \"OUT_OF_MEMORY\",   \"INTERNAL_ERROR\",\n      \"NOT_IMPLEMENTED\", \"FILE_OPEN_ERROR\", \"BAD_ARGUMENTS\"};\n  return mjs->error_msg == NULL || mjs->error_msg[0] == '\\0' ? err_names[err]\n                                                             : mjs->error_msg;\n}\n\nMJS_PRIVATE size_t mjs_get_func_addr(mjs_val_t v) {\n  return v & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE enum mjs_type mjs_get_type(mjs_val_t v) {\n  int tag;\n  if (mjs_is_number(v)) {\n    return MJS_TYPE_NUMBER;\n  }\n  tag = (v & MJS_TAG_MASK) >> 48;\n  switch (tag) {\n    case MJS_TAG_FOREIGN >> 48:\n      return MJS_TYPE_FOREIGN;\n    case MJS_TAG_UNDEFINED >> 48:\n      return MJS_TYPE_UNDEFINED;\n    case MJS_TAG_OBJECT >> 48:\n      return MJS_TYPE_OBJECT_GENERIC;\n    case MJS_TAG_ARRAY >> 48:\n      return MJS_TYPE_OBJECT_ARRAY;\n    case MJS_TAG_FUNCTION >> 48:\n      return MJS_TYPE_OBJECT_FUNCTION;\n    case MJS_TAG_STRING_I >> 48:\n    case MJS_TAG_STRING_O >> 48:\n    case MJS_TAG_STRING_F >> 48:\n    case MJS_TAG_STRING_D >> 48:\n    case MJS_TAG_STRING_5 >> 48:\n      return MJS_TYPE_STRING;\n    case MJS_TAG_BOOLEAN >> 48:\n      return MJS_TYPE_BOOLEAN;\n    case MJS_TAG_NULL >> 48:\n      return MJS_TYPE_NULL;\n    default:\n      abort();\n      return MJS_TYPE_UNDEFINED;\n  }\n}\n\nmjs_val_t mjs_get_global(struct mjs *mjs) {\n  return *vptr(&mjs->scopes, 0);\n}\n\nstatic void mjs_append_stack_trace_line(struct mjs *mjs, size_t offset) {\n  if (offset != MJS_BCODE_OFFSET_EXIT) {\n    const char *filename = mjs_get_bcode_filename_by_offset(mjs, offset);\n    int line_no = mjs_get_lineno_by_offset(mjs, offset);\n    char *new_line = NULL;\n    const char *fmt = \"  at %s:%d\\n\";\n    if (filename == NULL) {\n      fprintf(stderr,\n              \"ERROR during stack trace generation: wrong bcode offset %d\\n\",\n              (int) offset);\n      filename = \"<unknown-filename>\";\n    }\n    mg_asprintf(&new_line, 0, fmt, filename, line_no);\n\n    if (mjs->stack_trace != NULL) {\n      char *old = mjs->stack_trace;\n      mg_asprintf(&mjs->stack_trace, 0, \"%s%s\", mjs->stack_trace, new_line);\n      free(old);\n      free(new_line);\n    } else {\n      mjs->stack_trace = new_line;\n    }\n  }\n}\n\nMJS_PRIVATE void mjs_gen_stack_trace(struct mjs *mjs, size_t offset) {\n  mjs_append_stack_trace_line(mjs, offset);\n  while (mjs->call_stack.len >=\n         sizeof(mjs_val_t) * CALL_STACK_FRAME_ITEMS_CNT) {\n    int i;\n\n    /* set current offset to it to the offset stored in the frame */\n    offset = mjs_get_int(\n        mjs, *vptr(&mjs->call_stack, -1 - CALL_STACK_FRAME_ITEM_RETURN_ADDR));\n\n    /* pop frame from the call stack */\n    for (i = 0; i < CALL_STACK_FRAME_ITEMS_CNT; i++) {\n      mjs_pop_val(&mjs->call_stack);\n    }\n\n    mjs_append_stack_trace_line(mjs, offset);\n  }\n}\n\nvoid mjs_own(struct mjs *mjs, mjs_val_t *v) {\n  mbuf_append(&mjs->owned_values, &v, sizeof(v));\n}\n\nint mjs_disown(struct mjs *mjs, mjs_val_t *v) {\n  mjs_val_t **vp = (mjs_val_t **) (mjs->owned_values.buf +\n                                   mjs->owned_values.len - sizeof(v));\n\n  for (; (char *) vp >= mjs->owned_values.buf; vp--) {\n    if (*vp == v) {\n      *vp = *(mjs_val_t **) (mjs->owned_values.buf + mjs->owned_values.len -\n                             sizeof(v));\n      mjs->owned_values.len -= sizeof(v);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/*\n * Returns position in the data stack at which the called function is located,\n * and which should be later replaced with the returned value.\n */\nMJS_PRIVATE int mjs_getretvalpos(struct mjs *mjs) {\n  int pos;\n  mjs_val_t *ppos = vptr(&mjs->call_stack, -1);\n  // LOG(LL_INFO, (\"ppos: %p %d\", ppos, mjs_stack_size(&mjs->call_stack)));\n  assert(ppos != NULL && mjs_is_number(*ppos));\n  pos = mjs_get_int(mjs, *ppos) - 1;\n  assert(pos < (int) mjs_stack_size(&mjs->stack));\n  return pos;\n}\n\nint mjs_nargs(struct mjs *mjs) {\n  int top = mjs_stack_size(&mjs->stack);\n  int pos = mjs_getretvalpos(mjs) + 1;\n  // LOG(LL_INFO, (\"top: %d pos: %d\", top, pos));\n  return pos > 0 && pos < top ? top - pos : 0;\n}\n\nmjs_val_t mjs_arg(struct mjs *mjs, int arg_index) {\n  mjs_val_t res = MJS_UNDEFINED;\n  int top = mjs_stack_size(&mjs->stack);\n  int pos = mjs_getretvalpos(mjs) + 1;\n  // LOG(LL_INFO, (\"idx %d pos: %d\", arg_index, pos));\n  if (pos > 0 && pos + arg_index < top) {\n    res = *vptr(&mjs->stack, pos + arg_index);\n  }\n  return res;\n}\n\nvoid mjs_return(struct mjs *mjs, mjs_val_t v) {\n  int pos = mjs_getretvalpos(mjs);\n  // LOG(LL_INFO, (\"pos: %d\", pos));\n  mjs->stack.len = sizeof(mjs_val_t) * pos;\n  mjs_push(mjs, v);\n}\n\nMJS_PRIVATE mjs_val_t vtop(struct mbuf *m) {\n  size_t size = mjs_stack_size(m);\n  return size > 0 ? *vptr(m, size - 1) : MJS_UNDEFINED;\n}\n\nMJS_PRIVATE size_t mjs_stack_size(const struct mbuf *m) {\n  return m->len / sizeof(mjs_val_t);\n}\n\nMJS_PRIVATE mjs_val_t *vptr(struct mbuf *m, int idx) {\n  int size = mjs_stack_size(m);\n  if (idx < 0) idx = size + idx;\n  return idx >= 0 && idx < size ? &((mjs_val_t *) m->buf)[idx] : NULL;\n}\n\nMJS_PRIVATE mjs_val_t mjs_pop(struct mjs *mjs) {\n  if (mjs->stack.len == 0) {\n    mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"stack underflow\");\n    return MJS_UNDEFINED;\n  } else {\n    return mjs_pop_val(&mjs->stack);\n  }\n}\n\nMJS_PRIVATE void push_mjs_val(struct mbuf *m, mjs_val_t v) {\n  mbuf_append(m, &v, sizeof(v));\n}\n\nMJS_PRIVATE mjs_val_t mjs_pop_val(struct mbuf *m) {\n  mjs_val_t v = MJS_UNDEFINED;\n  assert(m->len >= sizeof(v));\n  if (m->len >= sizeof(v)) {\n    memcpy(&v, m->buf + m->len - sizeof(v), sizeof(v));\n    m->len -= sizeof(v);\n  }\n  return v;\n}\n\nMJS_PRIVATE void mjs_push(struct mjs *mjs, mjs_val_t v) {\n  push_mjs_val(&mjs->stack, v);\n}\n\nvoid mjs_set_generate_jsc(struct mjs *mjs, int generate_jsc) {\n  mjs->generate_jsc = generate_jsc;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_dataview.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_exec_public.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nvoid *mjs_mem_to_ptr(unsigned val) {\n  return (void *) (uintptr_t) val;\n}\n\nvoid *mjs_mem_get_ptr(void *base, int offset) {\n  return (char *) base + offset;\n}\n\nvoid mjs_mem_set_ptr(void *ptr, void *val) {\n  *(void **) ptr = val;\n}\n\ndouble mjs_mem_get_dbl(void *ptr) {\n  double v;\n  memcpy(&v, ptr, sizeof(v));\n  return v;\n}\n\nvoid mjs_mem_set_dbl(void *ptr, double val) {\n  memcpy(ptr, &val, sizeof(val));\n}\n\n/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\ndouble mjs_mem_get_uint(void *ptr, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  unsigned int res = 0;\n  p += bigendian ? 0 : size - 1;\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n  return res;\n}\n\n/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\ndouble mjs_mem_get_int(void *ptr, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  int res = 0;\n  p += bigendian ? 0 : size - 1;\n\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n\n  /* sign-extend */\n  {\n    int extra = sizeof(res) - size;\n    for (i = 0; i < extra; i++) res <<= 8;\n    for (i = 0; i < extra; i++) res >>= 8;\n  }\n\n  return res;\n}\n\nvoid mjs_mem_set_uint(void *ptr, unsigned int val, int size, int bigendian) {\n  uint8_t *p = (uint8_t *) ptr + (bigendian ? size - 1 : 0);\n  int i, inc = bigendian ? -1 : 1;\n  for (i = 0; i < size; i++, p += inc) {\n    *p = val & 0xff;\n    val >>= 8;\n  }\n}\n\nvoid mjs_mem_set_int(void *ptr, int val, int size, int bigendian) {\n  mjs_mem_set_uint(ptr, val, size, bigendian);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_exec.c\"\n#endif\n\n#include \"common/cs_file.h\"\n#include \"common/cs_varint.h\"\n\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_parser.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#if MJS_GENERATE_JSC && defined(CS_MMAP)\n#include <sys/mman.h>\n#endif\n\n/*\n * Pushes call stack frame. Offset is a global bcode offset. Retval_stack_idx\n * is an index in mjs->stack at which return value should be written later.\n */\nstatic void call_stack_push_frame(struct mjs *mjs, size_t offset,\n                                  mjs_val_t retval_stack_idx) {\n  /* Pop `this` value, and apply it */\n  mjs_val_t this_obj = mjs_pop_val(&mjs->arg_stack);\n\n  /*\n   * NOTE: the layout is described by enum mjs_call_stack_frame_item\n   */\n  push_mjs_val(&mjs->call_stack, mjs->vals.this_obj);\n  mjs->vals.this_obj = this_obj;\n\n  push_mjs_val(&mjs->call_stack, mjs_mk_number(mjs, (double) offset));\n  push_mjs_val(&mjs->call_stack,\n               mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->scopes)));\n  push_mjs_val(\n      &mjs->call_stack,\n      mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->loop_addresses)));\n  push_mjs_val(&mjs->call_stack, retval_stack_idx);\n}\n\n/*\n * Restores call stack frame. Returns the return address.\n */\nstatic size_t call_stack_restore_frame(struct mjs *mjs) {\n  size_t retval_stack_idx, return_address, scope_index, loop_addr_index;\n  assert(mjs_stack_size(&mjs->call_stack) >= CALL_STACK_FRAME_ITEMS_CNT);\n\n  /*\n   * NOTE: the layout is described by enum mjs_call_stack_frame_item\n   */\n  retval_stack_idx = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  loop_addr_index = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  scope_index = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  return_address = mjs_get_int(mjs, mjs_pop_val(&mjs->call_stack));\n  mjs->vals.this_obj = mjs_pop_val(&mjs->call_stack);\n\n  /* Remove created scopes */\n  while (mjs_stack_size(&mjs->scopes) > scope_index) {\n    mjs_pop_val(&mjs->scopes);\n  }\n\n  /* Remove loop addresses */\n  while (mjs_stack_size(&mjs->loop_addresses) > loop_addr_index) {\n    mjs_pop_val(&mjs->loop_addresses);\n  }\n\n  /* Shrink stack, leave return value on top */\n  mjs->stack.len = retval_stack_idx * sizeof(mjs_val_t);\n\n  /* Jump to the return address */\n  return return_address;\n}\n\nstatic mjs_val_t mjs_find_scope(struct mjs *mjs, mjs_val_t key) {\n  size_t num_scopes = mjs_stack_size(&mjs->scopes);\n  while (num_scopes > 0) {\n    mjs_val_t scope = *vptr(&mjs->scopes, num_scopes - 1);\n    num_scopes--;\n    if (mjs_get_own_property_v(mjs, scope, key) != NULL) return scope;\n  }\n  mjs_set_errorf(mjs, MJS_REFERENCE_ERROR, \"[%s] is not defined\",\n                 mjs_get_cstring(mjs, &key));\n  return MJS_UNDEFINED;\n}\n\nmjs_val_t mjs_get_this(struct mjs *mjs) {\n  return mjs->vals.this_obj;\n}\n\nstatic double do_arith_op(double da, double db, int op, bool *resnan) {\n  *resnan = false;\n\n  if (isnan(da) || isnan(db)) {\n    *resnan = true;\n    return 0;\n  }\n  /* clang-format off */\n  switch (op) {\n    case TOK_MINUS:   return da - db;\n    case TOK_PLUS:    return da + db;\n    case TOK_MUL:     return da * db;\n    case TOK_DIV:\n      if (db != 0) {\n        return da / db;\n      } else {\n        /* TODO(dfrank): add support for Infinity and return it here */\n        *resnan = true;\n        return 0;\n      }\n    case TOK_REM:\n      /*\n       * TODO(dfrank): probably support remainder operation as it is in JS\n       * (which works with non-integer divisor).\n       */\n      db = (int) db;\n      if (db != 0) {\n        bool neg = false;\n        if (da < 0) {\n          neg = true;\n          da = -da;\n        }\n        if (db < 0) {\n          db = -db;\n        }\n        da = (double) ((int64_t) da % (int64_t) db);\n        if (neg) {\n          da = -da;\n        }\n        return da;\n      } else {\n        *resnan = true;\n        return 0;\n      }\n    case TOK_AND:     return (double) ((int64_t) da & (int64_t) db);\n    case TOK_OR:      return (double) ((int64_t) da | (int64_t) db);\n    case TOK_XOR:     return (double) ((int64_t) da ^ (int64_t) db);\n    case TOK_LSHIFT:  return (double) ((int64_t) da << (int64_t) db);\n    case TOK_RSHIFT:  return (double) ((int64_t) da >> (int64_t) db);\n    case TOK_URSHIFT: return (double) ((uint32_t) da >> (uint32_t) db);\n  }\n  /* clang-format on */\n  *resnan = true;\n  return 0;\n}\n\nstatic void set_no_autoconversion_error(struct mjs *mjs) {\n  mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                     \"implicit type conversion is prohibited\");\n}\n\nstatic mjs_val_t do_op(struct mjs *mjs, mjs_val_t a, mjs_val_t b, int op) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  bool resnan = false;\n  if ((mjs_is_foreign(a) || mjs_is_number(a)) &&\n      (mjs_is_foreign(b) || mjs_is_number(b))) {\n    int is_result_ptr = 0;\n    double da, db, result;\n\n    if (mjs_is_foreign(a) && mjs_is_foreign(b)) {\n      /* When two operands are pointers, only subtraction is supported */\n      if (op != TOK_MINUS) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid operands\");\n      }\n    } else if (mjs_is_foreign(a) || mjs_is_foreign(b)) {\n      /*\n       * When one of the operands is a pointer, only + and - are supported,\n       * and the result is a pointer.\n       */\n      if (op != TOK_MINUS && op != TOK_PLUS) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid operands\");\n      }\n      is_result_ptr = 1;\n    }\n    da = mjs_is_number(a) ? mjs_get_double(mjs, a)\n                          : (double) (uintptr_t) mjs_get_ptr(mjs, a);\n    db = mjs_is_number(b) ? mjs_get_double(mjs, b)\n                          : (double) (uintptr_t) mjs_get_ptr(mjs, b);\n    result = do_arith_op(da, db, op, &resnan);\n    if (resnan) {\n      ret = MJS_TAG_NAN;\n    } else {\n      /*\n       * If at least one of the operands was a pointer, result should also be\n       * a pointer\n       */\n      ret = is_result_ptr ? mjs_mk_foreign(mjs, (void *) (uintptr_t) result)\n                          : mjs_mk_number(mjs, result);\n    }\n  } else if (mjs_is_string(a) && mjs_is_string(b) && (op == TOK_PLUS)) {\n    ret = s_concat(mjs, a, b);\n  } else {\n    set_no_autoconversion_error(mjs);\n  }\n  return ret;\n}\n\nstatic void op_assign(struct mjs *mjs, int op) {\n  mjs_val_t val = mjs_pop(mjs);\n  mjs_val_t obj = mjs_pop(mjs);\n  mjs_val_t key = mjs_pop(mjs);\n  if (mjs_is_object(obj) && mjs_is_string(key)) {\n    mjs_val_t v = mjs_get_v(mjs, obj, key);\n    mjs_set_v(mjs, obj, key, do_op(mjs, v, val, op));\n    mjs_push(mjs, v);\n  } else {\n    mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand\");\n  }\n}\n\nstatic int check_equal(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  int ret = 0;\n  if (a == MJS_TAG_NAN && b == MJS_TAG_NAN) {\n    ret = 0;\n  } else if (a == b) {\n    ret = 1;\n  } else if (mjs_is_number(a) && mjs_is_number(b)) {\n    /*\n     * The case of equal numbers is handled above, so here the result is always\n     * false\n     */\n    ret = 0;\n  } else if (mjs_is_string(a) && mjs_is_string(b)) {\n    ret = s_cmp(mjs, a, b) == 0;\n  } else if (mjs_is_foreign(a) && b == MJS_NULL) {\n    ret = mjs_get_ptr(mjs, a) == NULL;\n  } else if (a == MJS_NULL && mjs_is_foreign(b)) {\n    ret = mjs_get_ptr(mjs, b) == NULL;\n  } else {\n    ret = 0;\n  }\n  return ret;\n}\n\nstatic void exec_expr(struct mjs *mjs, int op) {\n  switch (op) {\n    case TOK_DOT:\n      break;\n    case TOK_MINUS:\n    case TOK_PLUS:\n    case TOK_MUL:\n    case TOK_DIV:\n    case TOK_REM:\n    case TOK_XOR:\n    case TOK_AND:\n    case TOK_OR:\n    case TOK_LSHIFT:\n    case TOK_RSHIFT:\n    case TOK_URSHIFT: {\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_push(mjs, do_op(mjs, a, b, op));\n      break;\n    }\n    case TOK_UNARY_MINUS: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, -a));\n      break;\n    }\n    case TOK_NOT: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !mjs_is_truthy(mjs, val)));\n      break;\n    }\n    case TOK_TILDA: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, (double) (~(int64_t) a)));\n      break;\n    }\n    case TOK_UNARY_PLUS:\n      break;\n    case TOK_EQ:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use ===, not ==\");\n      break;\n    case TOK_NE:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use !==, not !=\");\n      break;\n    case TOK_EQ_EQ: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_NE_NE: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_LT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a < b));\n      break;\n    }\n    case TOK_GT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a > b));\n      break;\n    }\n    case TOK_LE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a <= b));\n      break;\n    }\n    case TOK_GE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a >= b));\n      break;\n    }\n    case TOK_ASSIGN: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj)) {\n        mjs_set_v(mjs, obj, key, val);\n      } else if (mjs_is_foreign(obj)) {\n        /*\n         * We don't have setters, so in order to support properties which behave\n         * like setters, we have to parse key right here, instead of having real\n         * built-in prototype objects\n         */\n\n        int ikey = mjs_get_int(mjs, key);\n        int ival = mjs_get_int(mjs, val);\n\n        if (!mjs_is_number(key)) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n          val = MJS_UNDEFINED;\n        } else if (!mjs_is_number(val) || ival < 0 || ival > 0xff) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"only number 0 .. 255 can be assigned\");\n          val = MJS_UNDEFINED;\n        } else {\n          uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, obj);\n          *(ptr + ikey) = (uint8_t) ival;\n        }\n      } else {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"unsupported object type\");\n      }\n      mjs_push(mjs, val);\n      break;\n    }\n    case TOK_POSTFIX_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    case TOK_POSTFIX_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_MINUS_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_PLUS_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    /*\n     * NOTE: TOK_LOGICAL_AND and TOK_LOGICAL_OR don't need to be here, because\n     * they are just naturally handled by the short-circuit evaluation.\n     * See PARSE_LTR_BINOP() macro in mjs_parser.c.\n     */\n\n    /* clang-format off */\n    case TOK_MINUS_ASSIGN:    op_assign(mjs, TOK_MINUS);    break;\n    case TOK_PLUS_ASSIGN:     op_assign(mjs, TOK_PLUS);     break;\n    case TOK_MUL_ASSIGN:      op_assign(mjs, TOK_MUL);      break;\n    case TOK_DIV_ASSIGN:      op_assign(mjs, TOK_DIV);      break;\n    case TOK_REM_ASSIGN:      op_assign(mjs, TOK_REM);      break;\n    case TOK_AND_ASSIGN:      op_assign(mjs, TOK_AND);      break;\n    case TOK_OR_ASSIGN:       op_assign(mjs, TOK_OR);       break;\n    case TOK_XOR_ASSIGN:      op_assign(mjs, TOK_XOR);      break;\n    case TOK_LSHIFT_ASSIGN:   op_assign(mjs, TOK_LSHIFT);   break;\n    case TOK_RSHIFT_ASSIGN:   op_assign(mjs, TOK_RSHIFT);   break;\n    case TOK_URSHIFT_ASSIGN:  op_assign(mjs, TOK_URSHIFT);  break;\n    case TOK_COMMA: break;\n    /* clang-format on */\n    case TOK_KEYWORD_TYPEOF:\n      mjs_push(mjs, mjs_mk_string(mjs, mjs_typeof(mjs_pop(mjs)), ~0, 1));\n      break;\n    default:\n      LOG(LL_ERROR, (\"Unknown expr: %d\", op));\n      break;\n  }\n}\n\nstatic int getprop_builtin_string(struct mjs *mjs, mjs_val_t val,\n                                  const char *name, size_t name_len,\n                                  mjs_val_t *res) {\n  int isnum = 0;\n  int idx = cstr_to_ulong(name, name_len, &isnum);\n\n  if (strcmp(name, \"length\") == 0) {\n    size_t val_len;\n    mjs_get_string(mjs, &val, &val_len);\n    *res = mjs_mk_number(mjs, (double) val_len);\n    return 1;\n  } else if (strcmp(name, \"at\") == 0 || strcmp(name, \"charCodeAt\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_char_code_at);\n    return 1;\n  } else if (strcmp(name, \"indexOf\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_index_of);\n    return 1;\n  } else if (strcmp(name, \"slice\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_string_slice);\n    return 1;\n  } else if (isnum) {\n    /*\n     * string subscript: return a new one-byte string if the index\n     * is not out of bounds\n     */\n    size_t val_len;\n    const char *str = mjs_get_string(mjs, &val, &val_len);\n    if (idx >= 0 && idx < (int) val_len) {\n      *res = mjs_mk_string(mjs, str + idx, 1, 1);\n    } else {\n      *res = MJS_UNDEFINED;\n    }\n    return 1;\n  }\n  return 0;\n}\n\nstatic int getprop_builtin_array(struct mjs *mjs, mjs_val_t val,\n                                 const char *name, size_t name_len,\n                                 mjs_val_t *res) {\n  if (strcmp(name, \"splice\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_array_splice);\n    return 1;\n  } else if (strcmp(name, \"push\") == 0) {\n    *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_array_push_internal);\n    return 1;\n  } else if (strcmp(name, \"length\") == 0) {\n    *res = mjs_mk_number(mjs, mjs_array_length(mjs, val));\n    return 1;\n  }\n\n  (void) name_len;\n  return 0;\n}\n\nstatic int getprop_builtin_foreign(struct mjs *mjs, mjs_val_t val,\n                                   const char *name, size_t name_len,\n                                   mjs_val_t *res) {\n  int isnum = 0;\n  int idx = cstr_to_ulong(name, name_len, &isnum);\n\n  if (!isnum) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n  } else {\n    uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, val);\n    *res = mjs_mk_number(mjs, *(ptr + idx));\n  }\n  return 1;\n}\n\nstatic void mjs_apply_(struct mjs *mjs) {\n  mjs_val_t res = MJS_UNDEFINED, *args = NULL;\n  mjs_val_t func = mjs->vals.this_obj, v = mjs_arg(mjs, 1);\n  int i, nargs = 0;\n  if (mjs_is_array(v)) {\n    nargs = mjs_array_length(mjs, v);\n    args = calloc(nargs, sizeof(args[0]));\n    for (i = 0; i < nargs; i++) args[i] = mjs_array_get(mjs, v, i);\n  }\n  mjs_apply(mjs, &res, func, mjs_arg(mjs, 0), nargs, args);\n  free(args);\n  mjs_return(mjs, res);\n}\n\nstatic int getprop_builtin(struct mjs *mjs, mjs_val_t val, mjs_val_t name,\n                           mjs_val_t *res) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  int handled = 0;\n\n  mjs_err_t err = mjs_to_string(mjs, &name, &s, &n, &need_free);\n\n  if (err == MJS_OK) {\n    if (mjs_is_string(val)) {\n      handled = getprop_builtin_string(mjs, val, s, n, res);\n    } else if (s != NULL && n == 5 && strncmp(s, \"apply\", n) == 0) {\n      *res = mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_apply_);\n      handled = 1;\n    } else if (mjs_is_array(val)) {\n      handled = getprop_builtin_array(mjs, val, s, n, res);\n    } else if (mjs_is_foreign(val)) {\n      handled = getprop_builtin_foreign(mjs, val, s, n, res);\n    }\n  }\n\n  if (need_free) {\n    free(s);\n    s = NULL;\n  }\n\n  return handled;\n}\n\nMJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res) {\n  size_t i;\n  uint8_t prev_opcode = OP_MAX;\n  uint8_t opcode = OP_MAX;\n\n  /*\n   * remember lengths of all stacks, they will be restored in case of an error\n   */\n  int stack_len = mjs->stack.len;\n  int call_stack_len = mjs->call_stack.len;\n  int arg_stack_len = mjs->arg_stack.len;\n  int scopes_len = mjs->scopes.len;\n  int loop_addresses_len = mjs->loop_addresses.len;\n  size_t start_off = off;\n  const uint8_t *code;\n\n  struct mjs_bcode_part bp = *mjs_bcode_part_get_by_offset(mjs, off);\n\n  mjs_set_errorf(mjs, MJS_OK, NULL);\n  free(mjs->stack_trace);\n  mjs->stack_trace = NULL;\n\n  off -= bp.start_idx;\n\n  for (i = off; i < bp.data.len; i++) {\n    mjs->cur_bcode_offset = i;\n\n    if (mjs->need_gc) {\n      if (maybe_gc(mjs)) {\n        mjs->need_gc = 0;\n      }\n    }\n#if MJS_AGGRESSIVE_GC\n    maybe_gc(mjs);\n#endif\n\n    code = (const uint8_t *) bp.data.p;\n    mjs_disasm_single(code, i);\n    prev_opcode = opcode;\n    opcode = code[i];\n    switch (opcode) {\n      case OP_BCODE_HEADER: {\n        mjs_header_item_t bcode_offset;\n        memcpy(&bcode_offset,\n               code + i + 1 +\n                   sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n               sizeof(bcode_offset));\n        i += bcode_offset;\n      } break;\n      case OP_PUSH_NULL:\n        mjs_push(mjs, mjs_mk_null());\n        break;\n      case OP_PUSH_UNDEF:\n        mjs_push(mjs, mjs_mk_undefined());\n        break;\n      case OP_PUSH_FALSE:\n        mjs_push(mjs, mjs_mk_boolean(mjs, 0));\n        break;\n      case OP_PUSH_TRUE:\n        mjs_push(mjs, mjs_mk_boolean(mjs, 1));\n        break;\n      case OP_PUSH_OBJ:\n        mjs_push(mjs, mjs_mk_object(mjs));\n        break;\n      case OP_PUSH_ARRAY:\n        mjs_push(mjs, mjs_mk_array(mjs));\n        break;\n      case OP_PUSH_FUNC: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_function(mjs, bp.start_idx + i - n));\n        i += llen;\n        break;\n      }\n      case OP_PUSH_THIS:\n        mjs_push(mjs, mjs->vals.this_obj);\n        break;\n      case OP_JMP: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += n + llen;\n        break;\n      }\n      case OP_JMP_FALSE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (!mjs_is_truthy(mjs, mjs_pop(mjs))) {\n          mjs_push(mjs, MJS_UNDEFINED);\n          i += n;\n        }\n        break;\n      }\n      /*\n       * OP_JMP_NEUTRAL_... ops are like as OP_JMP_..., but they are completely\n       * stack-neutral: they just check the TOS, and increment instruction\n       * pointer if the TOS is truthy/falsy.\n       */\n      case OP_JMP_NEUTRAL_TRUE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (mjs_is_truthy(mjs, vtop(&mjs->stack))) {\n          i += n;\n        }\n        break;\n      }\n      case OP_JMP_NEUTRAL_FALSE: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        i += llen;\n        if (!mjs_is_truthy(mjs, vtop(&mjs->stack))) {\n          i += n;\n        }\n        break;\n      }\n      case OP_FIND_SCOPE: {\n        mjs_val_t key = vtop(&mjs->stack);\n        mjs_push(mjs, mjs_find_scope(mjs, key));\n        break;\n      }\n      case OP_CREATE: {\n        mjs_val_t obj = mjs_pop(mjs);\n        mjs_val_t key = mjs_pop(mjs);\n        if (mjs_get_own_property_v(mjs, obj, key) == NULL) {\n          mjs_set_v(mjs, obj, key, MJS_UNDEFINED);\n        }\n        break;\n      }\n      case OP_APPEND: {\n        mjs_val_t val = mjs_pop(mjs);\n        mjs_val_t arr = mjs_pop(mjs);\n        mjs_err_t err = mjs_array_push(mjs, arr, val);\n        if (err != MJS_OK) {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"append to non-array\");\n        }\n        break;\n      }\n      case OP_GET: {\n        mjs_val_t obj = mjs_pop(mjs);\n        mjs_val_t key = mjs_pop(mjs);\n        mjs_val_t val = MJS_UNDEFINED;\n\n        if (!getprop_builtin(mjs, obj, key, &val)) {\n          if (mjs_is_object(obj)) {\n            val = mjs_get_v_proto(mjs, obj, key);\n          } else {\n            mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"type error\");\n          }\n        }\n\n        mjs_push(mjs, val);\n        if (prev_opcode != OP_FIND_SCOPE) {\n          /*\n           * Previous opcode was not OP_FIND_SCOPE, so it's some \"custom\"\n           * object which might be used as `this`, so, save it\n           */\n          mjs->vals.last_getprop_obj = obj;\n        } else {\n          /*\n           * Previous opcode was OP_FIND_SCOPE, so we're getting value from\n           * the scope, and it should *not* be used as `this`\n           */\n          mjs->vals.last_getprop_obj = MJS_UNDEFINED;\n        }\n        break;\n      }\n      case OP_DEL_SCOPE:\n        if (mjs->scopes.len <= 1) {\n          mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"scopes underflow\");\n        } else {\n          mjs_pop_val(&mjs->scopes);\n        }\n        break;\n      case OP_NEW_SCOPE:\n        push_mjs_val(&mjs->scopes, mjs_mk_object(mjs));\n        break;\n      case OP_PUSH_SCOPE:\n        assert(mjs_stack_size(&mjs->scopes) > 0);\n        mjs_push(mjs, vtop(&mjs->scopes));\n        break;\n      case OP_PUSH_STR: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_string(mjs, (char *) code + i + 1 + llen, n, 1));\n        i += llen + n;\n        break;\n      }\n      case OP_PUSH_INT: {\n        int llen;\n        int64_t n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_number(mjs, (double) n));\n        i += llen;\n        break;\n      }\n      case OP_PUSH_DBL: {\n        int llen, n = cs_varint_decode_unsafe(&code[i + 1], &llen);\n        mjs_push(mjs, mjs_mk_number(\n                          mjs, strtod((char *) code + i + 1 + llen, NULL)));\n        i += llen + n;\n        break;\n      }\n      case OP_FOR_IN_NEXT: {\n        /*\n         * Data stack layout:\n         * ...                                    <-- Bottom of the data stack\n         * <iterator_variable_name>   (string)\n         * <object_that_is_iterated>  (object)\n         * <iterator_foreign_ptr>                 <-- Top of the data stack\n         */\n        mjs_val_t *iterator = vptr(&mjs->stack, -1);\n        mjs_val_t obj = *vptr(&mjs->stack, -2);\n        if (mjs_is_object(obj)) {\n          mjs_val_t var_name = *vptr(&mjs->stack, -3);\n          mjs_val_t key = mjs_next(mjs, obj, iterator);\n          if (key != MJS_UNDEFINED) {\n            mjs_val_t scope = mjs_find_scope(mjs, var_name);\n            mjs_set_v(mjs, scope, var_name, key);\n          }\n        } else {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR,\n                         \"can't iterate over non-object value\");\n        }\n        break;\n      }\n      case OP_RETURN: {\n        /*\n         * Return address is saved as a global bcode offset, so we need to\n         * convert it to the local offset\n         */\n        size_t off_ret = call_stack_restore_frame(mjs);\n        if (off_ret != MJS_BCODE_OFFSET_EXIT) {\n          bp = *mjs_bcode_part_get_by_offset(mjs, off_ret);\n          code = (const uint8_t *) bp.data.p;\n          i = off_ret - bp.start_idx;\n          LOG(LL_VERBOSE_DEBUG, (\"RETURNING TO %d\", (int) off_ret + 1));\n        } else {\n          goto clean;\n        }\n        // mjs_dump(mjs, 0, stdout);\n        break;\n      }\n      case OP_ARGS: {\n        /*\n         * If OP_ARGS follows OP_GET, then last_getprop_obj is set to `this`\n         * value; otherwise, last_getprop_obj is irrelevant and we have to\n         * reset it to `undefined`\n         */\n        if (prev_opcode != OP_GET) {\n          mjs->vals.last_getprop_obj = MJS_UNDEFINED;\n        }\n\n        /*\n         * Push last_getprop_obj, which is going to be used as `this`, see\n         * OP_CALL\n         */\n        push_mjs_val(&mjs->arg_stack, mjs->vals.last_getprop_obj);\n        /*\n         * Push current size of data stack, it's needed to place arguments\n         * properly\n         */\n        push_mjs_val(&mjs->arg_stack,\n                     mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->stack)));\n        break;\n      }\n      case OP_CALL: {\n        // LOG(LL_INFO, (\"BEFORE CALL\"));\n        // mjs_dump(mjs, 0, stdout);\n        int func_pos;\n        mjs_val_t *func;\n        mjs_val_t retval_stack_idx = vtop(&mjs->arg_stack);\n        func_pos = mjs_get_int(mjs, retval_stack_idx) - 1;\n        func = vptr(&mjs->stack, func_pos);\n\n        /* Drop data stack size (pushed by OP_ARGS) */\n        mjs_pop_val(&mjs->arg_stack);\n\n        if (mjs_is_function(*func)) {\n          size_t off_call;\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /*\n           * Function offset is a global bcode offset, so we need to convert it\n           * to the local offset\n           */\n          off_call = mjs_get_func_addr(*func) - 1;\n          bp = *mjs_bcode_part_get_by_offset(mjs, off_call);\n          code = (const uint8_t *) bp.data.p;\n          i = off_call - bp.start_idx;\n\n          *func = MJS_UNDEFINED;  // Return value\n          // LOG(LL_VERBOSE_DEBUG, (\"CALLING  %d\", i + 1));\n        } else if (mjs_is_string(*func) || mjs_is_ffi_sig(*func)) {\n          /* Call ffi-ed function */\n\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /* Perform the ffi-ed function call */\n          mjs_ffi_call2(mjs);\n\n          call_stack_restore_frame(mjs);\n        } else if (mjs_is_foreign(*func)) {\n          /* Call cfunction */\n\n          call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx);\n\n          /* Perform the cfunction call */\n          ((void (*) (struct mjs *)) mjs_get_ptr(mjs, *func))(mjs);\n\n          call_stack_restore_frame(mjs);\n        } else {\n          mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"calling non-callable\");\n        }\n        break;\n      }\n      case OP_SET_ARG: {\n        int llen1, llen2, n,\n            arg_no = cs_varint_decode_unsafe(&code[i + 1], &llen1);\n        mjs_val_t obj, key, v;\n        n = cs_varint_decode_unsafe(&code[i + llen1 + 1], &llen2);\n        key = mjs_mk_string(mjs, (char *) code + i + 1 + llen1 + llen2, n, 1);\n        obj = vtop(&mjs->scopes);\n        v = mjs_arg(mjs, arg_no);\n        mjs_set_v(mjs, obj, key, v);\n        i += llen1 + llen2 + n;\n        break;\n      }\n      case OP_SETRETVAL: {\n        if (mjs_stack_size(&mjs->call_stack) < CALL_STACK_FRAME_ITEMS_CNT) {\n          mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"cannot return\");\n        } else {\n          size_t retval_pos = mjs_get_int(\n              mjs, *vptr(&mjs->call_stack,\n                         -1 - CALL_STACK_FRAME_ITEM_RETVAL_STACK_IDX));\n          *vptr(&mjs->stack, retval_pos - 1) = mjs_pop(mjs);\n        }\n        // LOG(LL_INFO, (\"AFTER SETRETVAL\"));\n        // mjs_dump(mjs, 0, stdout);\n        break;\n      }\n      case OP_EXPR: {\n        int op = code[i + 1];\n        exec_expr(mjs, op);\n        i++;\n        break;\n      }\n      case OP_DROP: {\n        mjs_pop(mjs);\n        break;\n      }\n      case OP_DUP: {\n        mjs_push(mjs, vtop(&mjs->stack));\n        break;\n      }\n      case OP_SWAP: {\n        mjs_val_t a = mjs_pop(mjs);\n        mjs_val_t b = mjs_pop(mjs);\n        mjs_push(mjs, a);\n        mjs_push(mjs, b);\n        break;\n      }\n      case OP_LOOP: {\n        int l1, l2, off = cs_varint_decode_unsafe(&code[i + 1], &l1);\n        /* push scope index */\n        push_mjs_val(&mjs->loop_addresses,\n                     mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->scopes)));\n\n        /* push break offset */\n        push_mjs_val(\n            &mjs->loop_addresses,\n            mjs_mk_number(mjs, (double) (i + 1 /* OP_LOOP */ + l1 + off)));\n        off = cs_varint_decode_unsafe(&code[i + 1 + l1], &l2);\n\n        /* push continue offset */\n        push_mjs_val(\n            &mjs->loop_addresses,\n            mjs_mk_number(mjs, (double) (i + 1 /* OP_LOOP*/ + l1 + l2 + off)));\n        i += l1 + l2;\n        break;\n      }\n      case OP_CONTINUE: {\n        if (mjs_stack_size(&mjs->loop_addresses) >= 3) {\n          size_t scopes_len = mjs_get_int(mjs, *vptr(&mjs->loop_addresses, -3));\n          assert(mjs_stack_size(&mjs->scopes) >= scopes_len);\n          mjs->scopes.len = scopes_len * sizeof(mjs_val_t);\n\n          /* jump to \"continue\" address */\n          i = mjs_get_int(mjs, vtop(&mjs->loop_addresses)) - 1;\n        } else {\n          mjs_set_errorf(mjs, MJS_SYNTAX_ERROR, \"misplaced 'continue'\");\n        }\n      } break;\n      case OP_BREAK: {\n        if (mjs_stack_size(&mjs->loop_addresses) >= 3) {\n          size_t scopes_len;\n          /* drop \"continue\" address */\n          mjs_pop_val(&mjs->loop_addresses);\n\n          /* pop \"break\" address and jump to it */\n          i = mjs_get_int(mjs, mjs_pop_val(&mjs->loop_addresses)) - 1;\n\n          /* restore scope index */\n          scopes_len = mjs_get_int(mjs, mjs_pop_val(&mjs->loop_addresses));\n          assert(mjs_stack_size(&mjs->scopes) >= scopes_len);\n          mjs->scopes.len = scopes_len * sizeof(mjs_val_t);\n\n          LOG(LL_VERBOSE_DEBUG, (\"BREAKING TO %d\", (int) i + 1));\n        } else {\n          mjs_set_errorf(mjs, MJS_SYNTAX_ERROR, \"misplaced 'break'\");\n        }\n      } break;\n      case OP_NOP:\n        break;\n      case OP_EXIT:\n        i = bp.data.len;\n        break;\n      default:\n#if MJS_ENABLE_DEBUG\n        mjs_dump(mjs, 1);\n#endif\n        mjs_set_errorf(mjs, MJS_INTERNAL_ERROR, \"Unknown opcode: %d, off %d+%d\",\n                       (int) opcode, (int) bp.start_idx, (int) i);\n        i = bp.data.len;\n        break;\n    }\n    if (mjs->error != MJS_OK) {\n      mjs_gen_stack_trace(mjs, bp.start_idx + i - 1 /* undo the i++ */);\n\n      /* restore stack lenghts */\n      mjs->stack.len = stack_len;\n      mjs->call_stack.len = call_stack_len;\n      mjs->arg_stack.len = arg_stack_len;\n      mjs->scopes.len = scopes_len;\n      mjs->loop_addresses.len = loop_addresses_len;\n\n      /* script will evaluate to `undefined` */\n      mjs_push(mjs, MJS_UNDEFINED);\n      break;\n    }\n  }\n\nclean:\n  /* Remember result of the evaluation of this bcode part */\n  mjs_bcode_part_get_by_offset(mjs, start_off)->exec_res = mjs->error;\n\n  *res = mjs_pop(mjs);\n  return mjs->error;\n}\n\nMJS_PRIVATE mjs_err_t mjs_exec_internal(struct mjs *mjs, const char *path,\n                                        const char *src, int generate_jsc,\n                                        mjs_val_t *res) {\n  size_t off = mjs->bcode_len;\n  mjs_val_t r = MJS_UNDEFINED;\n  mjs->error = mjs_parse(path, src, mjs);\n#if MJS_ENABLE_DEBUG\n  if (cs_log_level >= LL_VERBOSE_DEBUG) mjs_dump(mjs, 1);\n#endif\n  if (generate_jsc == -1) generate_jsc = mjs->generate_jsc;\n  if (mjs->error == MJS_OK) {\n#if MJS_GENERATE_JSC && defined(CS_MMAP)\n    if (generate_jsc && path != NULL) {\n      const char *jsext = \".js\";\n      int basename_len = (int) strlen(path) - strlen(jsext);\n      if (basename_len > 0 && strcmp(path + basename_len, jsext) == 0) {\n        /* source file has a .js extension: create a .jsc counterpart */\n        int rewrite = 1;\n        int read_mmapped = 1;\n\n        /* construct .jsc filename */\n        const char *jscext = \".jsc\";\n        char filename_jsc[basename_len + strlen(jscext) + 1 /* nul-term */];\n        memcpy(filename_jsc, path, basename_len);\n        strcpy(filename_jsc + basename_len, jscext);\n\n        /* get last bcode part */\n        struct mjs_bcode_part *bp =\n            mjs_bcode_part_get(mjs, mjs_bcode_parts_cnt(mjs) - 1);\n\n        /*\n         * before writing .jsc file, check if it already exists and has the\n         * same contents\n         *\n         * TODO(dfrank): probably store crc32 before the bcode data, and only\n         * compare it.\n         */\n        {\n          size_t size;\n          char *data = cs_mmap_file(filename_jsc, &size);\n          if (data != NULL) {\n            if (size == bp->data.len) {\n              if (memcmp(data, bp->data.p, size) == 0) {\n                /* .jsc file is up to date, so don't rewrite it */\n                rewrite = 0;\n              }\n            }\n            munmap(data, size);\n          }\n        }\n\n        /* try to open .jsc file for writing */\n        if (rewrite) {\n          FILE *fp = fopen(filename_jsc, \"wb\");\n          if (fp != NULL) {\n            /* write last bcode part to .jsc */\n            fwrite(bp->data.p, bp->data.len, 1, fp);\n            fclose(fp);\n          } else {\n            LOG(LL_WARN, (\"Failed to open %s for writing\", filename_jsc));\n            read_mmapped = 0;\n          }\n        }\n\n        if (read_mmapped) {\n          /* free RAM buffer with last bcode part */\n          free((void *) bp->data.p);\n\n          /* mmap .jsc file and set last bcode part buffer to it */\n          bp->data.p = cs_mmap_file(filename_jsc, &bp->data.len);\n          bp->in_rom = 1;\n        }\n      }\n    }\n#else\n    (void) generate_jsc;\n#endif\n\n    mjs_execute(mjs, off, &r);\n  }\n  if (res != NULL) *res = r;\n  return mjs->error;\n}\n\nmjs_err_t mjs_exec(struct mjs *mjs, const char *src, mjs_val_t *res) {\n  return mjs_exec_internal(mjs, \"<stdin>\", src, 0 /* generate_jsc */, res);\n}\n\nmjs_err_t mjs_exec_file(struct mjs *mjs, const char *path, mjs_val_t *res) {\n  mjs_err_t error = MJS_FILE_READ_ERROR;\n  mjs_val_t r = MJS_UNDEFINED;\n  size_t size;\n  char *source_code = cs_read_file(path, &size);\n\n  if (source_code == NULL) {\n    error = MJS_FILE_READ_ERROR;\n    mjs_prepend_errorf(mjs, error, \"failed to read file \\\"%s\\\"\", path);\n    goto clean;\n  }\n\n  r = MJS_UNDEFINED;\n  error = mjs_exec_internal(mjs, path, source_code, -1, &r);\n  free(source_code);\n\nclean:\n  if (res != NULL) *res = r;\n  return error;\n}\n\nmjs_err_t mjs_call(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                   mjs_val_t this_val, int nargs, ...) {\n  va_list ap;\n  int i;\n  mjs_err_t ret;\n  mjs_val_t *args = calloc(nargs, sizeof(mjs_val_t));\n  va_start(ap, nargs);\n  for (i = 0; i < nargs; i++) {\n    args[i] = va_arg(ap, mjs_val_t);\n  }\n  va_end(ap);\n\n  ret = mjs_apply(mjs, res, func, this_val, nargs, args);\n\n  free(args);\n  return ret;\n}\n\nmjs_err_t mjs_apply(struct mjs *mjs, mjs_val_t *res, mjs_val_t func,\n                    mjs_val_t this_val, int nargs, mjs_val_t *args) {\n  mjs_val_t r, prev_this_val, retval_stack_idx, *resp;\n  int i;\n\n  if (!mjs_is_function(func) && !mjs_is_foreign(func) &&\n      !mjs_is_ffi_sig(func)) {\n    return mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"calling non-callable\");\n  }\n\n  LOG(LL_VERBOSE_DEBUG, (\"applying func %d\", (int) mjs_get_func_addr(func)));\n\n  prev_this_val = mjs->vals.this_obj;\n\n  /* Push callable which will be later replaced with the return value */\n  mjs_push(mjs, func);\n  resp = vptr(&mjs->stack, -1);\n\n  /* Remember index by which return value should be written */\n  retval_stack_idx = mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->stack));\n\n  // Push all arguments\n  for (i = 0; i < nargs; i++) {\n    mjs_push(mjs, args[i]);\n  }\n\n  /* Push this value to arg_stack, call_stack_push_frame() expects that */\n  push_mjs_val(&mjs->arg_stack, this_val);\n\n  /* Push call stack frame, just like OP_CALL does that */\n  call_stack_push_frame(mjs, MJS_BCODE_OFFSET_EXIT, retval_stack_idx);\n\n  if (mjs_is_foreign(func)) {\n    ((void (*) (struct mjs *)) mjs_get_ptr(mjs, func))(mjs);\n    if (res != NULL) *res = *resp;\n  } else if (mjs_is_ffi_sig(func)) {\n    mjs_ffi_call2(mjs);\n    if (res != NULL) *res = *resp;\n  } else {\n    size_t addr = mjs_get_func_addr(func);\n    mjs_execute(mjs, addr, &r);\n    if (res != NULL) *res = r;\n  }\n\n  /*\n   * If there was an error, we need to restore frame and do the cleanup\n   * which is otherwise done by OP_RETURN\n   */\n  if (mjs->error != MJS_OK) {\n    call_stack_restore_frame(mjs);\n\n    // Pop cell at which the returned value should've been written\n    mjs_pop(mjs);\n  }\n  mjs->vals.this_obj = prev_this_val;\n\n  return mjs->error;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_ffi.c\"\n#endif\n\n#include \"common/mg_str.h\"\n\n/* Amalgamated: #include \"ffi/ffi.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n/*\n * on linux this is enabled only if __USE_GNU is defined, but we cannot set it\n * because dlfcn could have been included already.\n */\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT NULL\n#endif\n\nstatic ffi_fn_t *get_cb_impl_by_signature(const mjs_ffi_sig_t *sig);\n\n/*\n * Data of the two related arguments: callback function pointer and the\n * userdata for it\n */\nstruct cbdata {\n  /* JS callback function */\n  mjs_val_t func;\n  /* JS userdata */\n  mjs_val_t userdata;\n\n  /* index of the function pointer param */\n  int8_t func_idx;\n  /* index of the userdata param */\n  int8_t userdata_idx;\n};\n\nvoid mjs_set_ffi_resolver(struct mjs *mjs, mjs_ffi_resolver_t *dlsym) {\n  mjs->dlsym = dlsym;\n}\n\nstatic mjs_ffi_ctype_t parse_cval_type(struct mjs *mjs, const char *s,\n                                       const char *e) {\n  struct mg_str ms = MG_NULL_STR;\n  /* Trim leading and trailing whitespace */\n  while (s < e && isspace((int) *s)) s++;\n  while (e > s && isspace((int) e[-1])) e--;\n  ms.p = s;\n  ms.len = e - s;\n  if (mg_vcmp(&ms, \"void\") == 0) {\n    return MJS_FFI_CTYPE_NONE;\n  } else if (mg_vcmp(&ms, \"userdata\") == 0) {\n    return MJS_FFI_CTYPE_USERDATA;\n  } else if (mg_vcmp(&ms, \"int\") == 0) {\n    return MJS_FFI_CTYPE_INT;\n  } else if (mg_vcmp(&ms, \"bool\") == 0) {\n    return MJS_FFI_CTYPE_BOOL;\n  } else if (mg_vcmp(&ms, \"double\") == 0) {\n    return MJS_FFI_CTYPE_DOUBLE;\n  } else if (mg_vcmp(&ms, \"float\") == 0) {\n    return MJS_FFI_CTYPE_FLOAT;\n  } else if (mg_vcmp(&ms, \"char*\") == 0 || mg_vcmp(&ms, \"char *\") == 0) {\n    return MJS_FFI_CTYPE_CHAR_PTR;\n  } else if (mg_vcmp(&ms, \"void*\") == 0 || mg_vcmp(&ms, \"void *\") == 0) {\n    return MJS_FFI_CTYPE_VOID_PTR;\n  } else if (mg_vcmp(&ms, \"struct mg_str\") == 0) {\n    return MJS_FFI_CTYPE_STRUCT_MG_STR;\n  } else if (mg_vcmp(&ms, \"struct mg_str *\") == 0 ||\n             mg_vcmp(&ms, \"struct mg_str*\") == 0) {\n    return MJS_FFI_CTYPE_STRUCT_MG_STR_PTR;\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"failed to parse val type \\\"%.*s\\\"\",\n                       (int) ms.len, ms.p);\n    return MJS_FFI_CTYPE_INVALID;\n  }\n}\n\nstatic const char *find_paren(const char *s, const char *e) {\n  for (; s < e; s++) {\n    if (*s == '(') return s;\n  }\n  return NULL;\n}\n\nstatic const char *find_closing_paren(const char *s, const char *e) {\n  int nesting = 1;\n  while (s < e) {\n    if (*s == '(') {\n      nesting++;\n    } else if (*s == ')') {\n      if (--nesting == 0) break;\n    }\n    s++;\n  }\n  return (s < e ? s : NULL);\n}\n\nMJS_PRIVATE mjs_err_t mjs_parse_ffi_signature(struct mjs *mjs, const char *s,\n                                              int sig_len, mjs_ffi_sig_t *sig,\n                                              enum ffi_sig_type sig_type) {\n  mjs_err_t ret = MJS_OK;\n  int vtidx = 0;\n  const char *cur, *e, *tmp_e, *tmp;\n  struct mg_str rt = MG_NULL_STR, fn = MG_NULL_STR, args = MG_NULL_STR;\n  mjs_ffi_ctype_t val_type = MJS_FFI_CTYPE_INVALID;\n  if (sig_len == ~0) {\n    sig_len = strlen(s);\n  }\n  e = s + sig_len;\n\n  mjs_ffi_sig_init(sig);\n\n  /* Skip leading spaces */\n  for (cur = s; cur < e && isspace((int) *cur); cur++)\n    ;\n\n  /* FInd the first set of parens */\n  tmp_e = find_paren(cur, e);\n  if (tmp_e == NULL || tmp_e - s < 2) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"1\");\n    goto clean;\n  }\n  tmp = find_closing_paren(tmp_e + 1, e);\n  if (tmp == NULL) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"2\");\n    goto clean;\n  }\n\n  /* Now see if we have a second set of parens */\n  args.p = find_paren(tmp + 1, e);\n  if (args.p == NULL) {\n    /* We don't - it's a regular function signature */\n    fn.p = tmp_e - 1;\n    while (fn.p > cur && isspace((int) *fn.p)) fn.p--;\n    while (fn.p > cur && (isalnum((int) *fn.p) || *fn.p == '_')) {\n      fn.p--;\n      fn.len++;\n    }\n    fn.p++;\n    rt.p = cur;\n    rt.len = fn.p - rt.p;\n    /* Stuff inside parens is args */\n    args.p = tmp_e + 1;\n    args.len = tmp - args.p;\n  } else {\n    /* We do - it's a function pointer, like void (*foo)(...).\n     * Stuff inside the first pair of parens is the function name */\n    fn.p = tmp + 1;\n    fn.len = args.p - tmp;\n    rt.p = cur;\n    rt.len = tmp_e - rt.p;\n    args.p++;\n    tmp = find_closing_paren(args.p, e);\n    if (tmp == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"3\");\n      goto clean;\n    }\n    args.len = tmp - args.p;\n    /*\n     * We ignore the name and leave sig->fn NULL here, but it will later be\n     * set to the appropriate callback implementation.\n     */\n    sig->is_callback = 1;\n  }\n\n  val_type = parse_cval_type(mjs, rt.p, rt.p + rt.len);\n  if (val_type == MJS_FFI_CTYPE_INVALID) {\n    ret = mjs->error;\n    goto clean;\n  }\n  mjs_ffi_sig_set_val_type(sig, vtidx++, val_type);\n\n  /* Parse function name {{{ */\n  if (!sig->is_callback) {\n    char buf[100];\n    if (mjs->dlsym == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret,\n                         \"resolver is not set, call mjs_set_ffi_resolver\");\n      goto clean;\n    }\n\n    snprintf(buf, sizeof(buf), \"%.*s\", (int) fn.len, fn.p);\n    sig->fn = (ffi_fn_t *) mjs->dlsym(RTLD_DEFAULT, buf);\n    if (sig->fn == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"dlsym('%s') failed\", buf);\n      goto clean;\n    }\n  } else {\n    tmp_e = strchr(tmp_e, ')');\n    if (tmp_e == NULL) {\n      ret = MJS_TYPE_ERROR;\n      goto clean;\n    }\n  }\n\n  /* Advance cur to the beginning of the arg list */\n  cur = tmp_e = args.p;\n\n  /* Parse all args {{{ */\n  while (tmp_e - args.p < (ptrdiff_t) args.len) {\n    int level = 0; /* nested parens level */\n    int is_fp = 0; /* set to 1 is current arg is a callback function ptr */\n    tmp_e = cur;\n\n    /* Advance tmp_e until the next arg separator */\n    while (*tmp_e && (level > 0 || (*tmp_e != ',' && *tmp_e != ')'))) {\n      switch (*tmp_e) {\n        case '(':\n          level++;\n          /*\n           * only function pointer params can have parens, so, set the flag\n           * that it's going to be a function pointer\n           */\n          is_fp = 1;\n          break;\n        case ')':\n          level--;\n          break;\n      }\n      tmp_e++;\n    }\n\n    if (tmp_e == cur) break;\n\n    /* Parse current arg */\n    if (is_fp) {\n      /* Current argument is a callback function pointer */\n      if (sig->cb_sig != NULL) {\n        /*\n         * We already have parsed some callback argument. Currently we don't\n         * support more than one callback argument, so, return error\n         * TODO(dfrank): probably improve\n         */\n        ret = MJS_TYPE_ERROR;\n        mjs_prepend_errorf(mjs, ret, \"only one callback is allowed\");\n        goto clean;\n      }\n\n      sig->cb_sig = calloc(sizeof(*sig->cb_sig), 1);\n      ret = mjs_parse_ffi_signature(mjs, cur, tmp_e - cur, sig->cb_sig,\n                                    FFI_SIG_CALLBACK);\n      if (ret != MJS_OK) {\n        mjs_ffi_sig_free(sig->cb_sig);\n        free(sig->cb_sig);\n        sig->cb_sig = NULL;\n        goto clean;\n      }\n      val_type = MJS_FFI_CTYPE_CALLBACK;\n    } else {\n      /* Some non-function argument */\n      val_type = parse_cval_type(mjs, cur, tmp_e);\n      if (val_type == MJS_FFI_CTYPE_INVALID) {\n        /* parse_cval_type() has already set error message */\n        ret = MJS_TYPE_ERROR;\n        goto clean;\n      }\n    }\n\n    if (!mjs_ffi_sig_set_val_type(sig, vtidx++, val_type)) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"too many callback args\");\n      goto clean;\n    }\n\n    if (*tmp_e == ',') {\n      /* Advance cur to the next argument */\n      cur = tmp_e + 1;\n      while (*cur == ' ') cur++;\n    } else {\n      /* No more arguments */\n      break;\n    }\n  }\n  /* }}} */\n\n  /* Analyze the results and see if they are obviously wrong */\n  mjs_ffi_sig_validate(mjs, sig, sig_type);\n  if (!sig->is_valid) {\n    ret = MJS_TYPE_ERROR;\n    goto clean;\n  }\n\n  /* If the signature represents a callback, find the suitable implementation */\n  if (sig->is_callback) {\n    sig->fn = get_cb_impl_by_signature(sig);\n    if (sig->fn == NULL) {\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret,\n                         \"the callback signature is valid, but there's \"\n                         \"no existing callback implementation for it\");\n      goto clean;\n    }\n  }\n\nclean:\n  if (ret != MJS_OK) {\n    mjs_prepend_errorf(mjs, ret, \"bad ffi signature: \\\"%.*s\\\"\", sig_len, s);\n    sig->is_valid = 0;\n  }\n  return ret;\n}\n\n/* C callbacks implementation {{{ */\n\n/* An argument or a return value for C callback impl */\nunion ffi_cb_data_val {\n  void *p;\n  uintptr_t w;\n  double d;\n  float f;\n};\n\nstruct ffi_cb_data {\n  union ffi_cb_data_val args[MJS_CB_ARGS_MAX_CNT];\n};\n\nstatic union ffi_cb_data_val ffi_cb_impl_generic(void *param,\n                                                 struct ffi_cb_data *data) {\n  struct mjs_ffi_cb_args *cbargs = (struct mjs_ffi_cb_args *) param;\n  mjs_val_t *args, res = MJS_UNDEFINED;\n  union ffi_cb_data_val ret;\n  int i;\n  struct mjs *mjs = cbargs->mjs;\n  mjs_ffi_ctype_t return_ctype = MJS_FFI_CTYPE_NONE;\n  mjs_err_t err;\n\n  memset(&ret, 0, sizeof(ret));\n  mjs_own(mjs, &res);\n\n  /* There must be at least one argument: a userdata */\n  assert(cbargs->sig.args_cnt > 0);\n\n  /* Create JS arguments */\n  args = calloc(1, sizeof(mjs_val_t) * cbargs->sig.args_cnt);\n  for (i = 0; i < cbargs->sig.args_cnt; i++) {\n    mjs_ffi_ctype_t val_type =\n        cbargs->sig.val_types[i + 1 /* first val_type is return value type */];\n    switch (val_type) {\n      case MJS_FFI_CTYPE_USERDATA:\n        args[i] = cbargs->userdata;\n        break;\n      case MJS_FFI_CTYPE_INT:\n        args[i] = mjs_mk_number(mjs, (double) data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_BOOL:\n        args[i] = mjs_mk_boolean(mjs, !!data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_CHAR_PTR: {\n        const char *s = (char *) data->args[i].w;\n        if (s == NULL) s = \"\";\n        args[i] = mjs_mk_string(mjs, s, ~0, 1);\n        break;\n      }\n      case MJS_FFI_CTYPE_VOID_PTR:\n        args[i] = mjs_mk_foreign(mjs, (void *) data->args[i].w);\n        break;\n      case MJS_FFI_CTYPE_DOUBLE:\n        args[i] = mjs_mk_number(mjs, data->args[i].d);\n        break;\n      case MJS_FFI_CTYPE_FLOAT:\n        args[i] = mjs_mk_number(mjs, data->args[i].f);\n        break;\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR: {\n        struct mg_str *s = (struct mg_str *) (void *) data->args[i].w;\n        args[i] = mjs_mk_string(mjs, s->p, s->len, 1);\n        break;\n      }\n      default:\n        /* should never be here */\n        LOG(LL_ERROR, (\"unexpected val type for arg #%d: %d\\n\", i, val_type));\n        abort();\n    }\n  }\n\n  /*\n   * save return ctype outside of `cbargs` before calling the callback, because\n   * callback might call `ffi_cb_free()`, which will effectively invalidate\n   * `cbargs`\n   */\n  return_ctype = cbargs->sig.val_types[0];\n\n  /* Call JS function */\n  LOG(LL_VERBOSE_DEBUG, (\"calling JS callback void-void %d from C\",\n                         mjs_get_int(mjs, cbargs->func)));\n  err = mjs_apply(mjs, &res, cbargs->func, MJS_UNDEFINED, cbargs->sig.args_cnt,\n                  args);\n  /*\n   * cbargs might be invalidated by the callback (if it called ffi_cb_free), so\n   * null it out\n   */\n  cbargs = NULL;\n  if (err != MJS_OK) {\n    /*\n     * There's not much we can do about the error here; let's at least print it\n     */\n    mjs_print_error(mjs, stderr, \"MJS callback error\",\n                    1 /* print_stack_trace */);\n\n    goto clean;\n  }\n\n  /* Get return value, if needed */\n  switch (return_ctype) {\n    case MJS_FFI_CTYPE_NONE:\n      /* do nothing */\n      break;\n    case MJS_FFI_CTYPE_INT:\n      ret.w = mjs_get_int(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      ret.w = mjs_get_bool(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_VOID_PTR:\n      ret.p = mjs_get_ptr(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_DOUBLE:\n      ret.d = mjs_get_double(mjs, res);\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      ret.f = (float) mjs_get_double(mjs, res);\n      break;\n    default:\n      /* should never be here */\n      LOG(LL_ERROR, (\"unexpected return val type %d\\n\", return_ctype));\n      abort();\n  }\n\nclean:\n  free(args);\n  mjs_disown(mjs, &res);\n  return ret;\n}\n\nstatic void ffi_init_cb_data_wwww(struct ffi_cb_data *data, uintptr_t w0,\n                                  uintptr_t w1, uintptr_t w2, uintptr_t w3,\n                                  uintptr_t w4, uintptr_t w5) {\n  memset(data, 0, sizeof(*data));\n  data->args[0].w = w0;\n  data->args[1].w = w1;\n  data->args[2].w = w2;\n  data->args[3].w = w3;\n  data->args[4].w = w4;\n  data->args[5].w = w5;\n}\n\nstatic uintptr_t ffi_cb_impl_wpwwwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w0, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwpwwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w1, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwpwww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w2, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwpww(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w3, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwwpw(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w4, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wwwwwwp(uintptr_t w0, uintptr_t w1, uintptr_t w2,\n                                     uintptr_t w3, uintptr_t w4, uintptr_t w5) {\n  struct ffi_cb_data data;\n  ffi_init_cb_data_wwww(&data, w0, w1, w2, w3, w4, w5);\n  return ffi_cb_impl_generic((void *) w5, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wpd(uintptr_t w0, double d1) {\n  struct ffi_cb_data data;\n\n  memset(&data, 0, sizeof(data));\n  data.args[0].w = w0;\n  data.args[1].d = d1;\n\n  return ffi_cb_impl_generic((void *) w0, &data).w;\n}\n\nstatic uintptr_t ffi_cb_impl_wdp(double d0, uintptr_t w1) {\n  struct ffi_cb_data data;\n\n  memset(&data, 0, sizeof(data));\n  data.args[0].d = d0;\n  data.args[1].w = w1;\n\n  return ffi_cb_impl_generic((void *) w1, &data).w;\n}\n/* }}} */\n\nstatic struct mjs_ffi_cb_args **ffi_get_matching(struct mjs_ffi_cb_args **plist,\n                                                 mjs_val_t func,\n                                                 mjs_val_t userdata) {\n  for (; *plist != NULL; plist = &((*plist)->next)) {\n    if ((*plist)->func == func && (*plist)->userdata == userdata) {\n      break;\n    }\n  }\n  return plist;\n}\n\nstatic ffi_fn_t *get_cb_impl_by_signature(const mjs_ffi_sig_t *sig) {\n  if (sig->is_valid) {\n    int i;\n    int double_cnt = 0;\n    int float_cnt = 0;\n    int userdata_idx = 0 /* not a valid value: index 0 means return value */;\n\n    for (i = 1 /*0th item is a return value*/; i < MJS_CB_SIGNATURE_MAX_SIZE;\n         i++) {\n      mjs_ffi_ctype_t type = sig->val_types[i];\n      switch (type) {\n        case MJS_FFI_CTYPE_DOUBLE:\n          double_cnt++;\n          break;\n        case MJS_FFI_CTYPE_FLOAT:\n          float_cnt++;\n          break;\n        case MJS_FFI_CTYPE_USERDATA:\n          assert(userdata_idx == 0); /* Otherwise is_valid should be 0 */\n          userdata_idx = i;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (float_cnt > 0) {\n      /* TODO(dfrank): add support for floats in callbacks */\n      return NULL;\n    }\n\n    assert(userdata_idx > 0); /* Otherwise is_valid should be 0 */\n\n    if (sig->args_cnt <= MJS_CB_ARGS_MAX_CNT) {\n      if (mjs_ffi_is_regular_word_or_void(sig->val_types[0])) {\n        /* Return type is a word or void */\n        switch (double_cnt) {\n          case 0:\n            /* No double arguments */\n            switch (userdata_idx) {\n              case 1:\n                return (ffi_fn_t *) ffi_cb_impl_wpwwwww;\n              case 2:\n                return (ffi_fn_t *) ffi_cb_impl_wwpwwww;\n              case 3:\n                return (ffi_fn_t *) ffi_cb_impl_wwwpwww;\n              case 4:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwpww;\n              case 5:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwwpw;\n              case 6:\n                return (ffi_fn_t *) ffi_cb_impl_wwwwwwp;\n              default:\n                /* should never be here */\n                abort();\n            }\n            break;\n          case 1:\n            /* 1 double argument */\n            switch (userdata_idx) {\n              case 1:\n                return (ffi_fn_t *) ffi_cb_impl_wpd;\n              case 2:\n                return (ffi_fn_t *) ffi_cb_impl_wdp;\n            }\n            break;\n        }\n      }\n    } else {\n      /* Too many arguments for the built-in callback impls */\n      /* TODO(dfrank): add support for custom app-dependent resolver */\n    }\n  }\n\n  return NULL;\n}\n\nMJS_PRIVATE mjs_val_t mjs_ffi_sig_to_value(struct mjs_ffi_sig *psig) {\n  if (psig == NULL) {\n    return MJS_NULL;\n  } else {\n    return mjs_legit_pointer_to_value(psig) | MJS_TAG_FUNCTION_FFI;\n  }\n}\n\nMJS_PRIVATE int mjs_is_ffi_sig(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FUNCTION_FFI;\n}\n\nMJS_PRIVATE struct mjs_ffi_sig *mjs_get_ffi_sig_struct(mjs_val_t v) {\n  struct mjs_ffi_sig *ret = NULL;\n  assert(mjs_is_ffi_sig(v));\n  ret = (struct mjs_ffi_sig *) get_ptr(v);\n  return ret;\n}\n\nMJS_PRIVATE mjs_val_t mjs_mk_ffi_sig(struct mjs *mjs) {\n  struct mjs_ffi_sig *psig = new_ffi_sig(mjs);\n  mjs_ffi_sig_init(psig);\n  return mjs_ffi_sig_to_value(psig);\n}\n\nMJS_PRIVATE void mjs_ffi_sig_destructor(struct mjs *mjs, void *psig) {\n  mjs_ffi_sig_free((mjs_ffi_sig_t *) psig);\n  (void) mjs;\n}\n\nMJS_PRIVATE mjs_err_t mjs_ffi_call(struct mjs *mjs) {\n  mjs_err_t e = MJS_OK;\n  const char *sig_str = NULL;\n  mjs_val_t sig_str_v = mjs_arg(mjs, 0);\n  mjs_val_t ret_v = MJS_UNDEFINED;\n  struct mjs_ffi_sig *psig = mjs_get_ffi_sig_struct(mjs_mk_ffi_sig(mjs));\n  size_t sig_str_len;\n\n  sig_str = mjs_get_string(mjs, &sig_str_v, &sig_str_len);\n  e = mjs_parse_ffi_signature(mjs, sig_str, sig_str_len, psig, FFI_SIG_FUNC);\n  if (e != MJS_OK) goto clean;\n  ret_v = mjs_ffi_sig_to_value(psig);\n\nclean:\n  mjs_return(mjs, ret_v);\n  return e;\n}\n\nMJS_PRIVATE mjs_err_t mjs_ffi_call2(struct mjs *mjs) {\n  mjs_err_t ret = MJS_OK;\n  mjs_ffi_sig_t *psig = NULL;\n  mjs_ffi_ctype_t rtype;\n  mjs_val_t sig_v = *vptr(&mjs->stack, mjs_getretvalpos(mjs));\n\n  int i, nargs;\n  struct ffi_arg res;\n  struct ffi_arg args[FFI_MAX_ARGS_CNT];\n  struct cbdata cbdata;\n\n  /* TODO(dfrank): support multiple callbacks */\n  mjs_val_t resv = mjs_mk_undefined();\n\n  /*\n   * String arguments, needed to support short strings which are packed into\n   * mjs_val_t itself\n   */\n  mjs_val_t argvs[FFI_MAX_ARGS_CNT];\n  struct mg_str argvmgstr[FFI_MAX_ARGS_CNT];\n\n  if (mjs_is_ffi_sig(sig_v)) {\n    psig = mjs_get_ffi_sig_struct(sig_v);\n  } else {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"non-ffi-callable value\");\n    goto clean;\n  }\n\n  memset(&cbdata, 0, sizeof(cbdata));\n  cbdata.func_idx = -1;\n  cbdata.userdata_idx = -1;\n\n  rtype = psig->val_types[0];\n\n  switch (rtype) {\n    case MJS_FFI_CTYPE_DOUBLE:\n      res.ctype = FFI_CTYPE_DOUBLE;\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      res.ctype = FFI_CTYPE_FLOAT;\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      res.ctype = FFI_CTYPE_BOOL;\n      break;\n    case MJS_FFI_CTYPE_USERDATA:\n    case MJS_FFI_CTYPE_INT:\n    case MJS_FFI_CTYPE_CHAR_PTR:\n    case MJS_FFI_CTYPE_VOID_PTR:\n    case MJS_FFI_CTYPE_NONE:\n      res.ctype = FFI_CTYPE_WORD;\n      break;\n\n    case MJS_FFI_CTYPE_INVALID:\n      ret = MJS_TYPE_ERROR;\n      mjs_prepend_errorf(mjs, ret, \"wrong ffi return type\");\n      goto clean;\n  }\n  res.v.i = 0;\n\n  nargs =\n      mjs_stack_size(&mjs->stack) - mjs_get_int(mjs, vtop(&mjs->call_stack));\n\n  if (nargs != psig->args_cnt) {\n    ret = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, ret, \"got %d actuals, but function takes %d args\",\n                       nargs, psig->args_cnt);\n    goto clean;\n  }\n\n  for (i = 0; i < nargs; i++) {\n    mjs_val_t arg = mjs_arg(mjs, i);\n\n    switch (psig->val_types[1 /* retval type */ + i]) {\n      case MJS_FFI_CTYPE_NONE:\n        /*\n         * Void argument: in any case, it's an error, because if C function\n         * takes no arguments, then the FFI-ed JS function should be called\n         * without any arguments, and thus we'll not face \"void\" here.\n         */\n        ret = MJS_TYPE_ERROR;\n        if (i == 0) {\n          /* FFI signature is correct, but invocation is wrong */\n          mjs_prepend_errorf(mjs, ret, \"ffi-ed function takes no arguments\");\n        } else {\n          /*\n           * FFI signature is wrong: we can't have \"void\" as a non-first\n           * \"argument\"\n           */\n          mjs_prepend_errorf(mjs, ret, \"bad ffi arg #%d type: \\\"void\\\"\", i);\n        }\n\n        goto clean;\n      case MJS_FFI_CTYPE_USERDATA:\n        /* Userdata for the callback */\n        if (cbdata.userdata_idx != -1) {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret, \"two or more userdata args: #%d and %d\",\n                             cbdata.userdata_idx, i);\n\n          goto clean;\n        }\n        cbdata.userdata = arg;\n        cbdata.userdata_idx = i;\n        break;\n      case MJS_FFI_CTYPE_INT: {\n        int intval = 0;\n        if (mjs_is_number(arg)) {\n          intval = mjs_get_int(mjs, arg);\n        } else if (mjs_is_boolean(arg)) {\n          intval = mjs_get_bool(mjs, arg);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not an int (the type idx is: %s)\", i,\n              mjs_typeof(arg));\n        }\n        ffi_set_word(&args[i], intval);\n      } break;\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR: {\n        if (!mjs_is_string(arg)) {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a string (the type idx is: %s)\",\n              i, mjs_typeof(arg));\n          goto clean;\n        }\n        argvs[i] = arg;\n        argvmgstr[i].p = mjs_get_string(mjs, &argvs[i], &argvmgstr[i].len);\n        /*\n         * String argument should be saved separately in order to support\n         * short strings (which are packed into mjs_val_t itself)\n         */\n        ffi_set_ptr(&args[i], (void *) &argvmgstr[i]);\n        break;\n      }\n      case MJS_FFI_CTYPE_BOOL: {\n        int intval = 0;\n        if (mjs_is_number(arg)) {\n          intval = !!mjs_get_int(mjs, arg);\n        } else if (mjs_is_boolean(arg)) {\n          intval = mjs_get_bool(mjs, arg);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a bool (the type idx is: %s)\", i,\n              mjs_typeof(arg));\n        }\n        ffi_set_word(&args[i], intval);\n      } break;\n      case MJS_FFI_CTYPE_DOUBLE:\n        ffi_set_double(&args[i], mjs_get_double(mjs, arg));\n        break;\n      case MJS_FFI_CTYPE_FLOAT:\n        ffi_set_float(&args[i], (float) mjs_get_double(mjs, arg));\n        break;\n      case MJS_FFI_CTYPE_CHAR_PTR: {\n        size_t s;\n        if (mjs_is_string(arg)) {\n          /*\n           * String argument should be saved separately in order to support\n           * short strings (which are packed into mjs_val_t itself)\n           */\n          argvs[i] = arg;\n          ffi_set_ptr(&args[i], (void *) mjs_get_string(mjs, &argvs[i], &s));\n        } else if (mjs_is_null(arg)) {\n          ffi_set_ptr(&args[i], NULL);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(\n              mjs, ret, \"actual arg #%d is not a string (the type idx is: %s)\",\n              i, mjs_typeof(arg));\n          goto clean;\n        }\n      } break;\n      case MJS_FFI_CTYPE_VOID_PTR:\n        if (mjs_is_string(arg)) {\n          size_t n;\n          /*\n           * String argument should be saved separately in order to support\n           * short strings (which are packed into mjs_val_t itself)\n           */\n          argvs[i] = arg;\n          ffi_set_ptr(&args[i], (void *) mjs_get_string(mjs, &argvs[i], &n));\n        } else if (mjs_is_foreign(arg)) {\n          ffi_set_ptr(&args[i], (void *) mjs_get_ptr(mjs, arg));\n        } else if (mjs_is_null(arg)) {\n          ffi_set_ptr(&args[i], NULL);\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret, \"actual arg #%d is not a ptr\", i);\n          goto clean;\n        }\n        break;\n      case MJS_FFI_CTYPE_CALLBACK:\n        if (mjs_is_function(arg) || mjs_is_foreign(arg) ||\n            mjs_is_ffi_sig(arg)) {\n          /*\n           * Current argument is a callback function pointer: remember the given\n           * JS function and the argument index\n           */\n          cbdata.func = arg;\n          cbdata.func_idx = i;\n        } else {\n          ret = MJS_TYPE_ERROR;\n          mjs_prepend_errorf(mjs, ret,\n                             \"actual arg #%d is not a function, but %s\", i,\n                             mjs_stringify_type((enum mjs_type) arg));\n          goto clean;\n        }\n        break;\n      case MJS_FFI_CTYPE_INVALID:\n        /* parse_cval_type() has already set a more detailed error */\n        ret = MJS_TYPE_ERROR;\n        mjs_prepend_errorf(mjs, ret, \"wrong arg type\");\n        goto clean;\n      default:\n        abort();\n        break;\n    }\n  }\n\n  if (cbdata.userdata_idx >= 0 && cbdata.func_idx >= 0) {\n    struct mjs_ffi_cb_args *cbargs = NULL;\n    struct mjs_ffi_cb_args **pitem = NULL;\n\n    /* the function takes a callback */\n\n    /*\n     * Get cbargs: either reuse the existing one (if the matching item exists),\n     * or create a new one.\n     */\n    pitem = ffi_get_matching(&mjs->ffi_cb_args, cbdata.func, cbdata.userdata);\n    if (*pitem == NULL) {\n      /* No matching cbargs item; we need to add a new one */\n      cbargs = calloc(1, sizeof(*cbargs));\n      cbargs->mjs = mjs;\n      cbargs->func = cbdata.func;\n      cbargs->userdata = cbdata.userdata;\n      mjs_ffi_sig_copy(&cbargs->sig, psig->cb_sig);\n\n      /* Establish a link to the newly allocated item */\n      *pitem = cbargs;\n    } else {\n      /* Found matching item: reuse it */\n      cbargs = *pitem;\n    }\n\n    {\n      union {\n        ffi_fn_t *fn;\n        void *p;\n      } u;\n      u.fn = psig->cb_sig->fn;\n      ffi_set_ptr(&args[cbdata.func_idx], u.p);\n      ffi_set_ptr(&args[cbdata.userdata_idx], cbargs);\n    }\n  } else if (!(cbdata.userdata_idx == -1 && cbdata.func_idx == -1)) {\n    /*\n     * incomplete signature: it contains either the function pointer or\n     * userdata. It should contain both or none.\n     *\n     * It should be handled in mjs_parse_ffi_signature().\n     */\n    abort();\n  }\n\n  ffi_call(psig->fn, nargs, &res, args);\n\n  switch (rtype) {\n    case MJS_FFI_CTYPE_CHAR_PTR: {\n      const char *s = (const char *) (uintptr_t) res.v.i;\n      if (s != NULL) {\n        resv = mjs_mk_string(mjs, s, ~0, 1);\n      } else {\n        resv = MJS_NULL;\n      }\n      break;\n    }\n    case MJS_FFI_CTYPE_VOID_PTR:\n      resv = mjs_mk_foreign(mjs, (void *) (uintptr_t) res.v.i);\n      break;\n    case MJS_FFI_CTYPE_INT:\n      resv = mjs_mk_number(mjs, (int) res.v.i);\n      break;\n    case MJS_FFI_CTYPE_BOOL:\n      resv = mjs_mk_boolean(mjs, !!res.v.i);\n      break;\n    case MJS_FFI_CTYPE_DOUBLE:\n      resv = mjs_mk_number(mjs, res.v.d);\n      break;\n    case MJS_FFI_CTYPE_FLOAT:\n      resv = mjs_mk_number(mjs, res.v.f);\n      break;\n    default:\n      resv = mjs_mk_undefined();\n      break;\n  }\n\nclean:\n  /*\n   * If there was some error, prepend an error message with the subject\n   * signature\n   */\n  if (ret != MJS_OK) {\n    mjs_prepend_errorf(mjs, ret, \"failed to call FFIed function\");\n    /* TODO(dfrank) stringify mjs_ffi_sig_t in some human-readable format */\n  }\n  mjs_return(mjs, resv);\n\n  return ret;\n}\n\n/*\n * TODO(dfrank): make it return boolean (when booleans are supported), instead\n * of a number\n */\nMJS_PRIVATE void mjs_ffi_cb_free(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_number(mjs, 0);\n  mjs_val_t func = mjs_arg(mjs, 0);\n  mjs_val_t userdata = mjs_arg(mjs, 1);\n\n  if (mjs_is_function(func)) {\n    struct mjs_ffi_cb_args **pitem =\n        ffi_get_matching(&mjs->ffi_cb_args, func, userdata);\n    if (*pitem != NULL) {\n      /* Found matching item: remove it from the linked list, and free */\n      struct mjs_ffi_cb_args *cbargs = *pitem;\n      *pitem = cbargs->next;\n      mjs_ffi_sig_free(&cbargs->sig);\n      free(cbargs);\n      ret = mjs_mk_number(mjs, 1);\n    }\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing argument 'func'\");\n  }\n\n  mjs_return(mjs, ret);\n}\n\nvoid mjs_ffi_args_free_list(struct mjs *mjs) {\n  ffi_cb_args_t *next = mjs->ffi_cb_args;\n\n  while (next != NULL) {\n    ffi_cb_args_t *cur = next;\n    next = next->next;\n    free(cur);\n  }\n}\n\nMJS_PRIVATE void mjs_ffi_sig_init(mjs_ffi_sig_t *sig) {\n  memset(sig, 0, sizeof(*sig));\n}\n\nMJS_PRIVATE void mjs_ffi_sig_copy(mjs_ffi_sig_t *to,\n                                  const mjs_ffi_sig_t *from) {\n  memcpy(to, from, sizeof(*to));\n  if (from->cb_sig != NULL) {\n    to->cb_sig = calloc(sizeof(*to->cb_sig), 1);\n    mjs_ffi_sig_copy(to->cb_sig, from->cb_sig);\n  }\n}\n\nMJS_PRIVATE void mjs_ffi_sig_free(mjs_ffi_sig_t *sig) {\n  if (sig->cb_sig != NULL) {\n    free(sig->cb_sig);\n    sig->cb_sig = NULL;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_sig_set_val_type(mjs_ffi_sig_t *sig, int idx,\n                                         mjs_ffi_ctype_t type) {\n  if (idx < MJS_CB_SIGNATURE_MAX_SIZE) {\n    sig->val_types[idx] = type;\n    return 1;\n  } else {\n    /* Index is too large */\n    return 0;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_sig_validate(struct mjs *mjs, mjs_ffi_sig_t *sig,\n                                     enum ffi_sig_type sig_type) {\n  int ret = 0;\n  int i;\n  int callback_idx = 0;\n  int userdata_idx = 0;\n\n  sig->is_valid = 0;\n\n  switch (sig_type) {\n    case FFI_SIG_FUNC:\n      /* Make sure return type is fine */\n      if (sig->val_types[0] != MJS_FFI_CTYPE_NONE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_INT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_BOOL &&\n          sig->val_types[0] != MJS_FFI_CTYPE_DOUBLE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_FLOAT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_VOID_PTR &&\n          sig->val_types[0] != MJS_FFI_CTYPE_CHAR_PTR) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid return value type\");\n        goto clean;\n      }\n      break;\n    case FFI_SIG_CALLBACK:\n      /* Make sure return type is fine */\n      if (sig->val_types[0] != MJS_FFI_CTYPE_NONE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_INT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_BOOL &&\n          sig->val_types[0] != MJS_FFI_CTYPE_DOUBLE &&\n          sig->val_types[0] != MJS_FFI_CTYPE_FLOAT &&\n          sig->val_types[0] != MJS_FFI_CTYPE_VOID_PTR) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid return value type\");\n        goto clean;\n      }\n  }\n\n  /* Handle argument types */\n  for (i = 1; i < MJS_CB_SIGNATURE_MAX_SIZE; i++) {\n    mjs_ffi_ctype_t type = sig->val_types[i];\n    switch (type) {\n      case MJS_FFI_CTYPE_USERDATA:\n        if (userdata_idx != 0) {\n          /* There must be at most one userdata arg, but we have more */\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"more than one userdata arg: #%d and #%d\",\n                             (userdata_idx - 1), (i - 1));\n          goto clean;\n        }\n        userdata_idx = i;\n        break;\n      case MJS_FFI_CTYPE_CALLBACK:\n        switch (sig_type) {\n          case FFI_SIG_FUNC:\n            break;\n          case FFI_SIG_CALLBACK:\n            mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                               \"callback can't take another callback\");\n            goto clean;\n        }\n        callback_idx = i;\n        break;\n      case MJS_FFI_CTYPE_INT:\n      case MJS_FFI_CTYPE_BOOL:\n      case MJS_FFI_CTYPE_VOID_PTR:\n      case MJS_FFI_CTYPE_CHAR_PTR:\n      case MJS_FFI_CTYPE_STRUCT_MG_STR_PTR:\n      case MJS_FFI_CTYPE_DOUBLE:\n      case MJS_FFI_CTYPE_FLOAT:\n        /* Do nothing */\n        break;\n      case MJS_FFI_CTYPE_NONE:\n        /* No more arguments */\n        goto args_over;\n      default:\n        mjs_prepend_errorf(mjs, MJS_INTERNAL_ERROR, \"invalid ffi_ctype: %d\",\n                           type);\n        goto clean;\n    }\n\n    sig->args_cnt++;\n  }\nargs_over:\n\n  switch (sig_type) {\n    case FFI_SIG_FUNC:\n      if (!((callback_idx > 0 && userdata_idx > 0) ||\n            (callback_idx == 0 && userdata_idx == 0))) {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                           \"callback and userdata should be either both \"\n                           \"present or both absent\");\n        goto clean;\n      }\n      break;\n    case FFI_SIG_CALLBACK:\n      if (userdata_idx == 0) {\n        /* No userdata arg */\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"no userdata arg\");\n        goto clean;\n      }\n      break;\n  }\n\n  ret = 1;\n\nclean:\n  if (ret) {\n    sig->is_valid = 1;\n  }\n  return ret;\n}\n\nMJS_PRIVATE int mjs_ffi_is_regular_word(mjs_ffi_ctype_t type) {\n  switch (type) {\n    case MJS_FFI_CTYPE_INT:\n    case MJS_FFI_CTYPE_BOOL:\n      return 1;\n    default:\n      return 0;\n  }\n}\n\nMJS_PRIVATE int mjs_ffi_is_regular_word_or_void(mjs_ffi_ctype_t type) {\n  return (type == MJS_FFI_CTYPE_NONE || mjs_ffi_is_regular_word(type));\n}\n\n#ifdef _WIN32\nvoid *dlsym(void *handle, const char *name) {\n  static HANDLE msvcrt_dll;\n  void *sym = NULL;\n  if (msvcrt_dll == NULL) msvcrt_dll = GetModuleHandle(\"msvcrt.dll\");\n  if ((sym = GetProcAddress(GetModuleHandle(NULL), name)) == NULL) {\n    sym = GetProcAddress(msvcrt_dll, name);\n  }\n  return sym;\n}\n#elif !defined(__unix__) && !defined(__APPLE__)\nvoid *dlsym(void *handle, const char *name) {\n  (void) handle;\n  (void) name;\n  return NULL;\n}\n#endif\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_gc.c\"\n#endif\n\n#include <stdio.h>\n\n#include \"common/cs_varint.h\"\n#include \"common/mbuf.h\"\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_ffi.h\" */\n/* Amalgamated: #include \"mjs_gc.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n\n/*\n * Macros for marking reachable things: use bit 0.\n */\n#define MARK(p) (((struct gc_cell *) (p))->head.word |= 1)\n#define UNMARK(p) (((struct gc_cell *) (p))->head.word &= ~1)\n#define MARKED(p) (((struct gc_cell *) (p))->head.word & 1)\n\n/*\n * Similar to `MARK()` / `UNMARK()` / `MARKED()`, but `.._FREE` counterparts\n * are intended to mark free cells (as opposed to used ones), so they use\n * bit 1.\n */\n#define MARK_FREE(p) (((struct gc_cell *) (p))->head.word |= 2)\n#define UNMARK_FREE(p) (((struct gc_cell *) (p))->head.word &= ~2)\n#define MARKED_FREE(p) (((struct gc_cell *) (p))->head.word & 2)\n\n/*\n * When each arena has that or less free cells, GC will be scheduled\n */\n#define GC_ARENA_CELLS_RESERVE 2\n\nstatic struct gc_block *gc_new_block(struct gc_arena *a, size_t size);\nstatic void gc_free_block(struct gc_block *b);\nstatic void gc_mark_mbuf_pt(struct mjs *mjs, const struct mbuf *mbuf);\n\nMJS_PRIVATE struct mjs_object *new_object(struct mjs *mjs) {\n  return (struct mjs_object *) gc_alloc_cell(mjs, &mjs->object_arena);\n}\n\nMJS_PRIVATE struct mjs_property *new_property(struct mjs *mjs) {\n  return (struct mjs_property *) gc_alloc_cell(mjs, &mjs->property_arena);\n}\n\nMJS_PRIVATE struct mjs_ffi_sig *new_ffi_sig(struct mjs *mjs) {\n  return (struct mjs_ffi_sig *) gc_alloc_cell(mjs, &mjs->ffi_sig_arena);\n}\n\n/* Initializes a new arena. */\nMJS_PRIVATE void gc_arena_init(struct gc_arena *a, size_t cell_size,\n                               size_t initial_size, size_t size_increment) {\n  assert(cell_size >= sizeof(uintptr_t));\n\n  memset(a, 0, sizeof(*a));\n  a->cell_size = cell_size;\n  a->size_increment = size_increment;\n  a->blocks = gc_new_block(a, initial_size);\n}\n\nMJS_PRIVATE void gc_arena_destroy(struct mjs *mjs, struct gc_arena *a) {\n  struct gc_block *b;\n\n  if (a->blocks != NULL) {\n    gc_sweep(mjs, a, 0);\n    for (b = a->blocks; b != NULL;) {\n      struct gc_block *tmp;\n      tmp = b;\n      b = b->next;\n      gc_free_block(tmp);\n    }\n  }\n}\n\nstatic void gc_free_block(struct gc_block *b) {\n  free(b->base);\n  free(b);\n}\n\nstatic struct gc_block *gc_new_block(struct gc_arena *a, size_t size) {\n  struct gc_cell *cur;\n  struct gc_block *b;\n\n  b = (struct gc_block *) calloc(1, sizeof(*b));\n  if (b == NULL) abort();\n\n  b->size = size;\n  b->base = (struct gc_cell *) calloc(a->cell_size, b->size);\n  if (b->base == NULL) abort();\n\n  for (cur = GC_CELL_OP(a, b->base, +, 0);\n       cur < GC_CELL_OP(a, b->base, +, b->size);\n       cur = GC_CELL_OP(a, cur, +, 1)) {\n    cur->head.link = a->free;\n    a->free = cur;\n  }\n\n  return b;\n}\n\n/*\n * Returns whether the given arena has GC_ARENA_CELLS_RESERVE or less free\n * cells\n */\nstatic int gc_arena_is_gc_needed(struct gc_arena *a) {\n  struct gc_cell *r = a->free;\n  int i;\n\n  for (i = 0; i <= GC_ARENA_CELLS_RESERVE; i++, r = r->head.link) {\n    if (r == NULL) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nMJS_PRIVATE int gc_strings_is_gc_needed(struct mjs *mjs) {\n  struct mbuf *m = &mjs->owned_strings;\n  return (double) m->len / (double) m->size > 0.9;\n}\n\nMJS_PRIVATE void *gc_alloc_cell(struct mjs *mjs, struct gc_arena *a) {\n  struct gc_cell *r;\n\n  if (a->free == NULL) {\n    struct gc_block *b = gc_new_block(a, a->size_increment);\n    b->next = a->blocks;\n    a->blocks = b;\n  }\n  r = a->free;\n\n  UNMARK(r);\n\n  a->free = r->head.link;\n\n#if MJS_MEMORY_STATS\n  a->allocations++;\n  a->alive++;\n#endif\n\n  /* Schedule GC if needed */\n  if (gc_arena_is_gc_needed(a)) {\n    mjs->need_gc = 1;\n  }\n\n  /*\n   * TODO(mkm): minor opt possible since most of the fields\n   * are overwritten downstream, but not worth the yak shave time\n   * when fields are added to GC-able structures */\n  memset(r, 0, a->cell_size);\n  return (void *) r;\n}\n\n/*\n * Scans the arena and add all unmarked cells to the free list.\n *\n * Empty blocks get deallocated. The head of the free list will contais cells\n * from the last (oldest) block. Cells will thus be allocated in block order.\n */\nvoid gc_sweep(struct mjs *mjs, struct gc_arena *a, size_t start) {\n  struct gc_block *b;\n  struct gc_cell *cur;\n  struct gc_block **prevp = &a->blocks;\n#if MJS_MEMORY_STATS\n  a->alive = 0;\n#endif\n\n  /*\n   * Before we sweep, we should mark all free cells in a way that is\n   * distinguishable from marked used cells.\n   */\n  {\n    struct gc_cell *next;\n    for (cur = a->free; cur != NULL; cur = next) {\n      next = cur->head.link;\n      MARK_FREE(cur);\n    }\n  }\n\n  /*\n   * We'll rebuild the whole `free` list, so initially we just reset it\n   */\n  a->free = NULL;\n\n  for (b = a->blocks; b != NULL;) {\n    size_t freed_in_block = 0;\n    /*\n     * if it turns out that this block is 100% garbage\n     * we can release the whole block, but the addition\n     * of it's cells to the free list has to be undone.\n     */\n    struct gc_cell *prev_free = a->free;\n\n    for (cur = GC_CELL_OP(a, b->base, +, start);\n         cur < GC_CELL_OP(a, b->base, +, b->size);\n         cur = GC_CELL_OP(a, cur, +, 1)) {\n      if (MARKED(cur)) {\n        /* The cell is used and marked  */\n        UNMARK(cur);\n#if MJS_MEMORY_STATS\n        a->alive++;\n#endif\n      } else {\n        /*\n         * The cell is either:\n         * - free\n         * - garbage that's about to be freed\n         */\n\n        if (MARKED_FREE(cur)) {\n          /* The cell is free, so, just unmark it */\n          UNMARK_FREE(cur);\n        } else {\n          /*\n           * The cell is used and should be freed: call the destructor and\n           * reset the memory\n           */\n          if (a->destructor != NULL) {\n            a->destructor(mjs, cur);\n          }\n          memset(cur, 0, a->cell_size);\n        }\n\n        /* Add this cell to the `free` list */\n        cur->head.link = a->free;\n        a->free = cur;\n        freed_in_block++;\n#if MJS_MEMORY_STATS\n        a->garbage++;\n#endif\n      }\n    }\n\n    /*\n     * don't free the initial block, which is at the tail\n     * because it has a special size aimed at reducing waste\n     * and simplifying initial startup. TODO(mkm): improve\n     * */\n    if (b->next != NULL && freed_in_block == b->size) {\n      *prevp = b->next;\n      gc_free_block(b);\n      b = *prevp;\n      a->free = prev_free;\n    } else {\n      prevp = &b->next;\n      b = b->next;\n    }\n  }\n}\n\n/* Mark an FFI signature */\nstatic void gc_mark_ffi_sig(struct mjs *mjs, mjs_val_t *v) {\n  struct mjs_ffi_sig *psig;\n\n  assert(mjs_is_ffi_sig(*v));\n\n  psig = mjs_get_ffi_sig_struct(*v);\n\n  /*\n   * we treat all object like things like objects but they might be functions,\n   * gc_check_val checks the appropriate arena per actual value type.\n   */\n  if (!gc_check_val(mjs, *v)) {\n    abort();\n  }\n\n  if (MARKED(psig)) return;\n\n  MARK(psig);\n}\n\n/* Mark an object */\nstatic void gc_mark_object(struct mjs *mjs, mjs_val_t *v) {\n  struct mjs_object *obj_base;\n  struct mjs_property *prop;\n  struct mjs_property *next;\n\n  assert(mjs_is_object(*v));\n\n  obj_base = get_object_struct(*v);\n\n  /*\n   * we treat all object like things like objects but they might be functions,\n   * gc_check_val checks the appropriate arena per actual value type.\n   */\n  if (!gc_check_val(mjs, *v)) {\n    abort();\n  }\n\n  if (MARKED(obj_base)) return;\n\n  /* mark object itself, and its properties */\n  for ((prop = obj_base->properties), MARK(obj_base); prop != NULL;\n       prop = next) {\n    if (!gc_check_ptr(&mjs->property_arena, prop)) {\n      abort();\n    }\n\n    gc_mark(mjs, &prop->name);\n    gc_mark(mjs, &prop->value);\n\n    next = prop->next;\n    MARK(prop);\n  }\n\n  /* mark object's prototype */\n  /*\n   * We dropped support for object prototypes in MJS.\n   * If we ever bring it back, don't forget to mark it\n   */\n  /* gc_mark(mjs, mjs_get_proto(mjs, v)); */\n}\n\n/* Mark a string value */\nstatic void gc_mark_string(struct mjs *mjs, mjs_val_t *v) {\n  mjs_val_t h, tmp = 0;\n  char *s;\n\n  /* clang-format off */\n\n  /*\n   * If a value points to an unmarked string we shall:\n   *  1. save the first 6 bytes of the string\n   *     since we need to be able to distinguish real values from\n   *     the saved first 6 bytes of the string, we need to tag the chunk\n   *     as MJS_TAG_STRING_C\n   *  2. encode value's address (v) into the first 6 bytes of the string.\n   *  3. put the saved 8 bytes (tag + chunk) back into the value.\n   *  4. mark the string by putting '\\1' in the NUL terminator of the previous\n   *     string chunk.\n   *\n   * If a value points to an already marked string we shall:\n   *     (0, <6 bytes of a pointer to a mjs_val_t>), hence we have to skip\n   *     the first byte. We tag the value pointer as a MJS_TAG_FOREIGN\n   *     so that it won't be followed during recursive mark.\n   *\n   *  ... the rest is the same\n   *\n   *  Note: 64-bit pointers can be represented with 48-bits\n   */\n\n  /* clang-format on */\n\n  assert((*v & MJS_TAG_MASK) == MJS_TAG_STRING_O);\n\n  s = mjs->owned_strings.buf + gc_string_mjs_val_to_offset(*v);\n  assert(s < mjs->owned_strings.buf + mjs->owned_strings.len);\n  if (s[-1] == '\\0') {\n    memcpy(&tmp, s, sizeof(tmp) - 2);\n    tmp |= MJS_TAG_STRING_C;\n  } else {\n    memcpy(&tmp, s, sizeof(tmp) - 2);\n    tmp |= MJS_TAG_FOREIGN;\n  }\n\n  h = (mjs_val_t)(uintptr_t) v;\n  s[-1] = 1;\n  memcpy(s, &h, sizeof(h) - 2);\n  memcpy(v, &tmp, sizeof(tmp));\n}\n\nMJS_PRIVATE void gc_mark(struct mjs *mjs, mjs_val_t *v) {\n  if (mjs_is_object(*v)) {\n    gc_mark_object(mjs, v);\n  }\n  if (mjs_is_ffi_sig(*v)) {\n    gc_mark_ffi_sig(mjs, v);\n  }\n  if ((*v & MJS_TAG_MASK) == MJS_TAG_STRING_O) {\n    gc_mark_string(mjs, v);\n  }\n}\n\nMJS_PRIVATE uint64_t gc_string_mjs_val_to_offset(mjs_val_t v) {\n  return (((uint64_t)(uintptr_t) get_ptr(v)) & ~MJS_TAG_MASK);\n}\n\nMJS_PRIVATE mjs_val_t gc_string_val_from_offset(uint64_t s) {\n  return s | MJS_TAG_STRING_O;\n}\n\nvoid gc_compact_strings(struct mjs *mjs) {\n  char *p = mjs->owned_strings.buf + 1;\n  uint64_t h, next, head = 1;\n  int len, llen;\n\n  while (p < mjs->owned_strings.buf + mjs->owned_strings.len) {\n    if (p[-1] == '\\1') {\n      /* relocate and update ptrs */\n      h = 0;\n      memcpy(&h, p, sizeof(h) - 2);\n\n      /*\n       * relocate pointers until we find the tail.\n       * The tail is marked with MJS_TAG_STRING_C,\n       * while mjs_val_t link pointers are tagged with MJS_TAG_FOREIGN\n       */\n      for (; (h & MJS_TAG_MASK) != MJS_TAG_STRING_C; h = next) {\n        h &= ~MJS_TAG_MASK;\n        memcpy(&next, (char *) (uintptr_t) h, sizeof(h));\n\n        *(mjs_val_t *) (uintptr_t) h = gc_string_val_from_offset(head);\n      }\n      h &= ~MJS_TAG_MASK;\n\n      /*\n       * the tail contains the first 6 bytes we stole from\n       * the actual string.\n       */\n      len = cs_varint_decode_unsafe((unsigned char *) &h, &llen);\n      len += llen + 1;\n\n      /*\n       * restore the saved 6 bytes\n       * TODO(mkm): think about endianness\n       */\n      memcpy(p, &h, sizeof(h) - 2);\n\n      /*\n       * and relocate the string data by packing it to the left.\n       */\n      memmove(mjs->owned_strings.buf + head, p, len);\n      mjs->owned_strings.buf[head - 1] = 0x0;\n      p += len;\n      head += len;\n    } else {\n      len = cs_varint_decode_unsafe((unsigned char *) p, &llen);\n      len += llen + 1;\n\n      p += len;\n    }\n  }\n\n  mjs->owned_strings.len = head;\n}\n\nMJS_PRIVATE int maybe_gc(struct mjs *mjs) {\n  if (!mjs->inhibit_gc) {\n    mjs_gc(mjs, 0);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n * mark an array of `mjs_val_t` values (*not pointers* to them)\n */\nstatic void gc_mark_val_array(struct mjs *mjs, mjs_val_t *vals, size_t len) {\n  mjs_val_t *vp;\n  for (vp = vals; vp < vals + len; vp++) {\n    gc_mark(mjs, vp);\n  }\n}\n\n/*\n * mark an mbuf containing *pointers* to `mjs_val_t` values\n */\nstatic void gc_mark_mbuf_pt(struct mjs *mjs, const struct mbuf *mbuf) {\n  mjs_val_t **vp;\n  for (vp = (mjs_val_t **) mbuf->buf; (char *) vp < mbuf->buf + mbuf->len;\n       vp++) {\n    gc_mark(mjs, *vp);\n  }\n}\n\n/*\n * mark an mbuf containing `mjs_val_t` values (*not pointers* to them)\n */\nstatic void gc_mark_mbuf_val(struct mjs *mjs, const struct mbuf *mbuf) {\n  gc_mark_val_array(mjs, (mjs_val_t *) mbuf->buf,\n                    mbuf->len / sizeof(mjs_val_t));\n}\n\nstatic void gc_mark_ffi_cbargs_list(struct mjs *mjs, ffi_cb_args_t *cbargs) {\n  for (; cbargs != NULL; cbargs = cbargs->next) {\n    gc_mark(mjs, &cbargs->func);\n    gc_mark(mjs, &cbargs->userdata);\n  }\n}\n\n/* Perform garbage collection */\nvoid mjs_gc(struct mjs *mjs, int full) {\n  gc_mark_val_array(mjs, (mjs_val_t *) &mjs->vals,\n                    sizeof(mjs->vals) / sizeof(mjs_val_t));\n\n  gc_mark_mbuf_pt(mjs, &mjs->owned_values);\n  gc_mark_mbuf_val(mjs, &mjs->scopes);\n  gc_mark_mbuf_val(mjs, &mjs->stack);\n  gc_mark_mbuf_val(mjs, &mjs->call_stack);\n\n  gc_mark_ffi_cbargs_list(mjs, mjs->ffi_cb_args);\n\n  gc_compact_strings(mjs);\n\n  gc_sweep(mjs, &mjs->object_arena, 0);\n  gc_sweep(mjs, &mjs->property_arena, 0);\n  gc_sweep(mjs, &mjs->ffi_sig_arena, 0);\n\n  if (full) {\n    /*\n     * In case of full GC, we also resize strings buffer, but we still leave\n     * some extra space (at most, `_MJS_STRING_BUF_RESERVE`) in order to avoid\n     * frequent reallocations\n     */\n    size_t trimmed_size = mjs->owned_strings.len + _MJS_STRING_BUF_RESERVE;\n    if (trimmed_size < mjs->owned_strings.size) {\n      mbuf_resize(&mjs->owned_strings, trimmed_size);\n    }\n  }\n}\n\nMJS_PRIVATE int gc_check_val(struct mjs *mjs, mjs_val_t v) {\n  if (mjs_is_object(v)) {\n    return gc_check_ptr(&mjs->object_arena, get_object_struct(v));\n  }\n  if (mjs_is_ffi_sig(v)) {\n    return gc_check_ptr(&mjs->ffi_sig_arena, mjs_get_ffi_sig_struct(v));\n  }\n  return 1;\n}\n\nMJS_PRIVATE int gc_check_ptr(const struct gc_arena *a, const void *ptr) {\n  const struct gc_cell *p = (const struct gc_cell *) ptr;\n  struct gc_block *b;\n  for (b = a->blocks; b != NULL; b = b->next) {\n    if (p >= b->base && p < GC_CELL_OP(a, b->base, +, b->size)) {\n      return 1;\n    }\n  }\n  return 0;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_json.c\"\n#endif\n\n#include \"common/str_util.h\"\n#include \"frozen.h\"\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n\n#define BUF_LEFT(size, used) (((size_t)(used) < (size)) ? ((size) - (used)) : 0)\n\n/*\n * Returns whether the value of given type should be skipped when generating\n * JSON output\n *\n * So far it always returns 0, but we might add some logic later, if we\n * implement some non-jsonnable objects\n */\nstatic int should_skip_for_json(enum mjs_type type) {\n  int ret;\n  switch (type) {\n    /* All permitted values */\n    case MJS_TYPE_NULL:\n    case MJS_TYPE_BOOLEAN:\n    case MJS_TYPE_NUMBER:\n    case MJS_TYPE_STRING:\n    case MJS_TYPE_OBJECT_GENERIC:\n    case MJS_TYPE_OBJECT_ARRAY:\n      ret = 0;\n      break;\n    default:\n      ret = 1;\n      break;\n  }\n  return ret;\n}\n\nstatic const char *hex_digits = \"0123456789abcdef\";\nstatic char *append_hex(char *buf, char *limit, uint8_t c) {\n  if (buf < limit) *buf++ = 'u';\n  if (buf < limit) *buf++ = '0';\n  if (buf < limit) *buf++ = '0';\n  if (buf < limit) *buf++ = hex_digits[(int) ((c >> 4) % 0xf)];\n  if (buf < limit) *buf++ = hex_digits[(int) (c & 0xf)];\n  return buf;\n}\n\n/*\n * Appends quoted s to buf. Any double quote contained in s will be escaped.\n * Returns the number of characters that would have been added,\n * like snprintf.\n * If size is zero it doesn't output anything but keeps counting.\n */\nstatic int snquote(char *buf, size_t size, const char *s, size_t len) {\n  char *limit = buf + size;\n  const char *end;\n  /*\n   * String single character escape sequence:\n   * http://www.ecma-international.org/ecma-262/6.0/index.html#table-34\n   *\n   * 0x8 -> \\b\n   * 0x9 -> \\t\n   * 0xa -> \\n\n   * 0xb -> \\v\n   * 0xc -> \\f\n   * 0xd -> \\r\n   */\n  const char *specials = \"btnvfr\";\n  size_t i = 0;\n\n  i++;\n  if (buf < limit) *buf++ = '\"';\n\n  for (end = s + len; s < end; s++) {\n    if (*s == '\"' || *s == '\\\\') {\n      i++;\n      if (buf < limit) *buf++ = '\\\\';\n    } else if (*s >= '\\b' && *s <= '\\r') {\n      i += 2;\n      if (buf < limit) *buf++ = '\\\\';\n      if (buf < limit) *buf++ = specials[*s - '\\b'];\n      continue;\n    } else if ((unsigned char) *s < '\\b' || (*s > '\\r' && *s < ' ')) {\n      i += 6 /* \\uXXXX */;\n      if (buf < limit) *buf++ = '\\\\';\n      buf = append_hex(buf, limit, (uint8_t) *s);\n      continue;\n    }\n    i++;\n    if (buf < limit) *buf++ = *s;\n  }\n\n  i++;\n  if (buf < limit) *buf++ = '\"';\n\n  if (buf < limit) {\n    *buf = '\\0';\n  } else if (size != 0) {\n    /*\n     * There is no room for the NULL char, but the size wasn't zero, so we can\n     * safely put NULL in the previous byte\n     */\n    *(buf - 1) = '\\0';\n  }\n  return i;\n}\n\nMJS_PRIVATE mjs_err_t to_json_or_debug(struct mjs *mjs, mjs_val_t v, char *buf,\n                                       size_t size, size_t *res_len,\n                                       uint8_t is_debug) {\n  mjs_val_t el;\n  char *vp;\n  mjs_err_t rcode = MJS_OK;\n  size_t len = 0;\n  /*\n   * TODO(dfrank) : also push all `mjs_val_t`s that are declared below\n   */\n\n  if (size > 0) *buf = '\\0';\n\n  if (!is_debug && should_skip_for_json(mjs_get_type(v))) {\n    goto clean;\n  }\n\n  for (vp = mjs->json_visited_stack.buf;\n       vp < mjs->json_visited_stack.buf + mjs->json_visited_stack.len;\n       vp += sizeof(mjs_val_t)) {\n    if (*(mjs_val_t *) vp == v) {\n      strncpy(buf, \"[Circular]\", size);\n      len = 10;\n      goto clean;\n    }\n  }\n\n  switch (mjs_get_type(v)) {\n    case MJS_TYPE_NULL:\n    case MJS_TYPE_BOOLEAN:\n    case MJS_TYPE_NUMBER:\n    case MJS_TYPE_UNDEFINED:\n    case MJS_TYPE_FOREIGN:\n      /* For those types, regular `mjs_to_string()` works */\n      {\n        /* TODO: refactor: mjs_to_string allocates memory every time */\n        char *p = NULL;\n        int need_free = 0;\n        rcode = mjs_to_string(mjs, &v, &p, &len, &need_free);\n        c_snprintf(buf, size, \"%.*s\", (int) len, p);\n        if (need_free) {\n          free(p);\n        }\n      }\n      goto clean;\n\n    case MJS_TYPE_STRING: {\n      /*\n       * For strings we can't just use `primitive_to_str()`, because we need\n       * quoted value\n       */\n      size_t n;\n      const char *str = mjs_get_string(mjs, &v, &n);\n      len = snquote(buf, size, str, n);\n      goto clean;\n    }\n\n    case MJS_TYPE_OBJECT_FUNCTION:\n    case MJS_TYPE_OBJECT_GENERIC: {\n      char *b = buf;\n      struct mjs_property *prop = NULL;\n      struct mjs_object *o = NULL;\n\n      mbuf_append(&mjs->json_visited_stack, (char *) &v, sizeof(v));\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"{\");\n      o = get_object_struct(v);\n      for (prop = o->properties; prop != NULL; prop = prop->next) {\n        size_t n;\n        const char *s;\n        if (!is_debug && should_skip_for_json(mjs_get_type(prop->value))) {\n          continue;\n        }\n        if (b - buf != 1) { /* Not the first property to be printed */\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \",\");\n        }\n        s = mjs_get_string(mjs, &prop->name, &n);\n        b += c_snprintf(b, BUF_LEFT(size, b - buf), \"\\\"%.*s\\\":\", (int) n, s);\n        {\n          size_t tmp = 0;\n          rcode = to_json_or_debug(mjs, prop->value, b, BUF_LEFT(size, b - buf),\n                                   &tmp, is_debug);\n          if (rcode != MJS_OK) {\n            goto clean_iter;\n          }\n          b += tmp;\n        }\n      }\n\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"}\");\n      mjs->json_visited_stack.len -= sizeof(v);\n\n    clean_iter:\n      len = b - buf;\n      goto clean;\n    }\n    case MJS_TYPE_OBJECT_ARRAY: {\n      int has;\n      char *b = buf;\n      size_t i, alen = mjs_array_length(mjs, v);\n      mbuf_append(&mjs->json_visited_stack, (char *) &v, sizeof(v));\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"[\");\n      for (i = 0; i < alen; i++) {\n        el = mjs_array_get2(mjs, v, i, &has);\n        if (has) {\n          size_t tmp = 0;\n          if (!is_debug && should_skip_for_json(mjs_get_type(el))) {\n            b += c_snprintf(b, BUF_LEFT(size, b - buf), \"null\");\n          } else {\n            rcode = to_json_or_debug(mjs, el, b, BUF_LEFT(size, b - buf), &tmp,\n                                     is_debug);\n            if (rcode != MJS_OK) {\n              goto clean;\n            }\n          }\n          b += tmp;\n        } else {\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \"null\");\n        }\n        if (i != alen - 1) {\n          b += c_snprintf(b, BUF_LEFT(size, b - buf), \",\");\n        }\n      }\n      b += c_snprintf(b, BUF_LEFT(size, b - buf), \"]\");\n      mjs->json_visited_stack.len -= sizeof(v);\n      len = b - buf;\n      goto clean;\n    }\n\n    case MJS_TYPES_CNT:\n      abort();\n  }\n\n  abort();\n\n  len = 0; /* for compilers that don't know about abort() */\n  goto clean;\n\nclean:\n  if (rcode != MJS_OK) {\n    len = 0;\n  }\n  if (res_len != NULL) {\n    *res_len = len;\n  }\n  return rcode;\n}\n\nMJS_PRIVATE mjs_err_t mjs_json_stringify(struct mjs *mjs, mjs_val_t v,\n                                         char *buf, size_t size, char **res) {\n  mjs_err_t rcode = MJS_OK;\n  char *p = buf;\n  size_t len;\n\n  to_json_or_debug(mjs, v, buf, size, &len, 0);\n\n  if (len >= size) {\n    /* Buffer is not large enough. Allocate a bigger one */\n    p = (char *) malloc(len + 1);\n    rcode = mjs_json_stringify(mjs, v, p, len + 1, res);\n    assert(*res == p);\n    goto clean;\n  } else {\n    *res = p;\n    goto clean;\n  }\n\nclean:\n  /*\n   * If we're going to return an error, and we allocated a buffer, then free\n   * it. Otherwise, caller should free it.\n   */\n  if (rcode != MJS_OK && p != buf) {\n    free(p);\n  }\n  return rcode;\n}\n\n/*\n * JSON parsing frame: a separate frame is allocated for each nested\n * object/array during parsing\n */\nstruct json_parse_frame {\n  mjs_val_t val;\n  struct json_parse_frame *up;\n};\n\n/*\n * Context for JSON parsing by means of json_walk()\n */\nstruct json_parse_ctx {\n  struct mjs *mjs;\n  mjs_val_t result;\n  struct json_parse_frame *frame;\n  enum mjs_err rcode;\n};\n\n/* Allocate JSON parse frame */\nstatic struct json_parse_frame *alloc_json_frame(struct json_parse_ctx *ctx,\n                                                 mjs_val_t v) {\n  struct json_parse_frame *frame =\n      (struct json_parse_frame *) calloc(sizeof(struct json_parse_frame), 1);\n  frame->val = v;\n  mjs_own(ctx->mjs, &frame->val);\n  return frame;\n}\n\n/* Free JSON parse frame, return the previous one (which may be NULL) */\nstatic struct json_parse_frame *free_json_frame(\n    struct json_parse_ctx *ctx, struct json_parse_frame *frame) {\n  struct json_parse_frame *up = frame->up;\n  mjs_disown(ctx->mjs, &frame->val);\n  free(frame);\n  return up;\n}\n\n/* Callback for json_walk() */\nstatic void frozen_cb(void *data, const char *name, size_t name_len,\n                      const char *path, const struct json_token *token) {\n  struct json_parse_ctx *ctx = (struct json_parse_ctx *) data;\n  mjs_val_t v = MJS_UNDEFINED;\n\n  (void) path;\n\n  mjs_own(ctx->mjs, &v);\n\n  switch (token->type) {\n    case JSON_TYPE_STRING: {\n      char *dst;\n      if (token->len > 0 && (dst = malloc(token->len)) != NULL) {\n        int len = json_unescape(token->ptr, token->len, dst, token->len);\n        if (len < 0) {\n          mjs_prepend_errorf(ctx->mjs, MJS_TYPE_ERROR, \"invalid JSON string\");\n          break;\n        }\n        v = mjs_mk_string(ctx->mjs, dst, len, 1 /* copy */);\n        free(dst);\n      } else {\n        /*\n         * This branch is for 0-len strings, and for malloc errors\n         * TODO(lsm): on malloc error, propagate the error upstream\n         */\n        v = mjs_mk_string(ctx->mjs, \"\", 0, 1 /* copy */);\n      }\n      break;\n    }\n    case JSON_TYPE_NUMBER:\n      v = mjs_mk_number(ctx->mjs, strtod(token->ptr, NULL));\n      break;\n    case JSON_TYPE_TRUE:\n      v = mjs_mk_boolean(ctx->mjs, 1);\n      break;\n    case JSON_TYPE_FALSE:\n      v = mjs_mk_boolean(ctx->mjs, 0);\n      break;\n    case JSON_TYPE_NULL:\n      v = MJS_NULL;\n      break;\n    case JSON_TYPE_OBJECT_START:\n      v = mjs_mk_object(ctx->mjs);\n      break;\n    case JSON_TYPE_ARRAY_START:\n      v = mjs_mk_array(ctx->mjs);\n      break;\n\n    case JSON_TYPE_OBJECT_END:\n    case JSON_TYPE_ARRAY_END: {\n      /* Object or array has finished: deallocate its frame */\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    } break;\n\n    default:\n      LOG(LL_ERROR, (\"Wrong token type %d\\n\", token->type));\n      break;\n  }\n\n  if (!mjs_is_undefined(v)) {\n    if (name != NULL && name_len != 0) {\n      /* Need to define a property on the current object/array */\n      if (mjs_is_object(ctx->frame->val)) {\n        mjs_set(ctx->mjs, ctx->frame->val, name, name_len, v);\n      } else if (mjs_is_array(ctx->frame->val)) {\n        /*\n         * TODO(dfrank): consult name_len. Currently it's not a problem due to\n         * the implementation details of frozen, but it might change\n         */\n        int idx = (int) strtod(name, NULL);\n        mjs_array_set(ctx->mjs, ctx->frame->val, idx, v);\n      } else {\n        LOG(LL_ERROR, (\"Current value is neither object nor array\\n\"));\n      }\n    } else {\n      /* This is a root value */\n      assert(ctx->frame == NULL);\n\n      /*\n       * This value will also be the overall result of JSON parsing\n       * (it's already owned by the `mjs_alt_json_parse()`)\n       */\n      ctx->result = v;\n    }\n\n    if (token->type == JSON_TYPE_OBJECT_START ||\n        token->type == JSON_TYPE_ARRAY_START) {\n      /* New object or array has just started, so we need to allocate a frame\n       * for it */\n      struct json_parse_frame *new_frame = alloc_json_frame(ctx, v);\n      new_frame->up = ctx->frame;\n      ctx->frame = new_frame;\n    }\n  }\n\n  mjs_disown(ctx->mjs, &v);\n}\n\nMJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len);\n    memcpy(stmp, str, len);\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}\n\nMJS_PRIVATE void mjs_op_json_stringify(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t val = mjs_arg(mjs, 0);\n\n  if (mjs_nargs(mjs) < 1) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing a value to stringify\");\n  } else {\n    char *p = NULL;\n    if (mjs_json_stringify(mjs, val, NULL, 0, &p) == MJS_OK) {\n      ret = mjs_mk_string(mjs, p, ~0, 1 /* copy */);\n      free(p);\n    }\n  }\n\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n\n  if (mjs_is_string(arg0)) {\n    size_t len;\n    const char *str = mjs_get_string(mjs, &arg0, &len);\n    mjs_json_parse(mjs, str, len, &ret);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"string argument required\");\n  }\n\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_main.c\"\n#endif\n\n#ifdef MJS_MAIN\n\n// #include <dlfcn.h>\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_exec.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\nint main(int argc, char *argv[]) {\n  struct mjs *mjs = mjs_create();\n  mjs_val_t res = MJS_UNDEFINED;\n  mjs_err_t err = MJS_OK;\n  int i;\n\n  for (i = 1; i < argc && argv[i][0] == '-' && err == MJS_OK; i++) {\n    if (strcmp(argv[i], \"-l\") == 0 && i + 1 < argc) {\n      cs_log_set_level(atoi(argv[++i]));\n    } else if (strcmp(argv[i], \"-j\") == 0) {\n      mjs_set_generate_jsc(mjs, 1);\n    } else if (strcmp(argv[i], \"-e\") == 0 && i + 1 < argc) {\n      err = mjs_exec(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-f\") == 0 && i + 1 < argc) {\n      err = mjs_exec_file(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n      printf(\"mJS (c) Cesanta, built: \" __DATE__ \"\\n\");\n      printf(\"Usage:\\n\");\n      printf(\"%s [OPTIONS] [js_file ...]\\n\", argv[0]);\n      printf(\"OPTIONS:\\n\");\n      printf(\"  -e string    - Execute JavaScript expression\\n\");\n      printf(\"  -j           - Enable code precompiling to .jsc files\\n\");\n      printf(\"  -f js_file   - Execute code from .js JavaScript file\\n\");\n      printf(\"  -l level     - Set debug level, from 0 to 5\\n\");\n      return EXIT_SUCCESS;\n    } else {\n      fprintf(stderr, \"Unknown flag: [%s]\\n\", argv[i]);\n      return EXIT_FAILURE;\n    }\n  }\n  for (; i < argc && err == MJS_OK; i++) {\n    err = mjs_exec_file(mjs, argv[i], &res);\n  }\n\n  if (err == MJS_OK) {\n    mjs_fprintf(res, mjs, stdout);\n    putchar('\\n');\n  } else {\n    mjs_print_error(mjs, stdout, NULL, 1 /* print_stack_trace */);\n  }\n  mjs_destroy(mjs);\n\n  return EXIT_SUCCESS;\n}\n#endif\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_object.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n#include \"common/mg_str.h\"\n\nMJS_PRIVATE mjs_val_t mjs_object_to_value(struct mjs_object *o) {\n  if (o == NULL) {\n    return MJS_NULL;\n  } else {\n    return mjs_legit_pointer_to_value(o) | MJS_TAG_OBJECT;\n  }\n}\n\nMJS_PRIVATE struct mjs_object *get_object_struct(mjs_val_t v) {\n  struct mjs_object *ret = NULL;\n  if (mjs_is_null(v)) {\n    ret = NULL;\n  } else {\n    assert(mjs_is_object(v));\n    ret = (struct mjs_object *) get_ptr(v);\n  }\n  return ret;\n}\n\nmjs_val_t mjs_mk_object(struct mjs *mjs) {\n  struct mjs_object *o = new_object(mjs);\n  if (o == NULL) {\n    return MJS_NULL;\n  }\n  (void) mjs;\n  o->properties = NULL;\n  return mjs_object_to_value(o);\n}\n\nint mjs_is_object(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_OBJECT ||\n         (v & MJS_TAG_MASK) == MJS_TAG_ARRAY;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property(struct mjs *mjs,\n                                                      mjs_val_t obj,\n                                                      const char *name,\n                                                      size_t len) {\n  struct mjs_property *p;\n  struct mjs_object *o;\n\n  if (!mjs_is_object(obj)) {\n    return NULL;\n  }\n\n  o = get_object_struct(obj);\n\n  if (len <= 5) {\n    mjs_val_t ss = mjs_mk_string(mjs, name, len, 1);\n    for (p = o->properties; p != NULL; p = p->next) {\n      if (p->name == ss) return p;\n    }\n  } else {\n    for (p = o->properties; p != NULL; p = p->next) {\n      if (mjs_strcmp(mjs, &p->name, name, len) == 0) return p;\n    }\n    return p;\n  }\n\n  return NULL;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_get_own_property_v(struct mjs *mjs,\n                                                        mjs_val_t obj,\n                                                        mjs_val_t key) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  struct mjs_property *p = NULL;\n  mjs_err_t err = mjs_to_string(mjs, &key, &s, &n, &need_free);\n  if (err == MJS_OK) {\n    p = mjs_get_own_property(mjs, obj, s, n);\n  }\n  if (need_free) free(s);\n  return p;\n}\n\nMJS_PRIVATE struct mjs_property *mjs_mk_property(struct mjs *mjs,\n                                                 mjs_val_t name,\n                                                 mjs_val_t value) {\n  struct mjs_property *p = new_property(mjs);\n  p->next = NULL;\n  p->name = name;\n  p->value = value;\n  return p;\n}\n\nmjs_val_t mjs_get(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len) {\n  struct mjs_property *p;\n\n  if (name_len == (size_t) ~0) {\n    name_len = strlen(name);\n  }\n\n  p = mjs_get_own_property(mjs, obj, name, name_len);\n  if (p == NULL) {\n    return MJS_UNDEFINED;\n  } else {\n    return p->value;\n  }\n}\n\nmjs_val_t mjs_get_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name) {\n  size_t n;\n  char *s = NULL;\n  int need_free = 0;\n  mjs_val_t ret = MJS_UNDEFINED;\n\n  mjs_err_t err = mjs_to_string(mjs, &name, &s, &n, &need_free);\n\n  if (err == MJS_OK) {\n    /* Successfully converted name value to string: get the property */\n    ret = mjs_get(mjs, obj, s, n);\n  }\n\n  if (need_free) {\n    free(s);\n    s = NULL;\n  }\n  return ret;\n}\n\nmjs_val_t mjs_get_v_proto(struct mjs *mjs, mjs_val_t obj, mjs_val_t key) {\n  struct mjs_property *p;\n  mjs_val_t pn = mjs_mk_string(mjs, MJS_PROTO_PROP_NAME, ~0, 1);\n  if ((p = mjs_get_own_property_v(mjs, obj, key)) != NULL) return p->value;\n  if ((p = mjs_get_own_property_v(mjs, obj, pn)) == NULL) return MJS_UNDEFINED;\n  return mjs_get_v_proto(mjs, p->value, key);\n}\n\nmjs_err_t mjs_set(struct mjs *mjs, mjs_val_t obj, const char *name,\n                  size_t name_len, mjs_val_t val) {\n  return mjs_set_internal(mjs, obj, MJS_UNDEFINED, (char *) name, name_len,\n                          val);\n}\n\nmjs_err_t mjs_set_v(struct mjs *mjs, mjs_val_t obj, mjs_val_t name,\n                    mjs_val_t val) {\n  return mjs_set_internal(mjs, obj, name, NULL, 0, val);\n}\n\nMJS_PRIVATE mjs_err_t mjs_set_internal(struct mjs *mjs, mjs_val_t obj,\n                                       mjs_val_t name_v, char *name,\n                                       size_t name_len, mjs_val_t val) {\n  mjs_err_t rcode = MJS_OK;\n\n  struct mjs_property *p;\n\n  int need_free = 0;\n\n  if (name == NULL) {\n    /* Pointer was not provided, so obtain one from the name_v. */\n    rcode = mjs_to_string(mjs, &name_v, &name, &name_len, &need_free);\n    if (rcode != MJS_OK) {\n      goto clean;\n    }\n  } else {\n    /*\n     * Pointer was provided, so we ignore name_v. Here we set it to undefined,\n     * and the actual value will be calculated later if needed.\n     */\n    name_v = MJS_UNDEFINED;\n  }\n\n  p = mjs_get_own_property(mjs, obj, name, name_len);\n\n  if (p == NULL) {\n    struct mjs_object *o;\n    if (!mjs_is_object(obj)) {\n      return MJS_REFERENCE_ERROR;\n    }\n\n    /*\n     * name_v might be not a string here. In this case, we need to create a new\n     * `name_v`, which will be a string.\n     */\n    if (!mjs_is_string(name_v)) {\n      name_v = mjs_mk_string(mjs, name, name_len, 1);\n    }\n\n    p = mjs_mk_property(mjs, name_v, val);\n\n    o = get_object_struct(obj);\n    p->next = o->properties;\n    o->properties = p;\n  }\n\n  p->value = val;\n\nclean:\n  if (need_free) {\n    free(name);\n    name = NULL;\n  }\n  return rcode;\n}\n\nMJS_PRIVATE void mjs_destroy_property(struct mjs_property **p) {\n  *p = NULL;\n}\n\n/*\n * See comments in `object_public.h`\n */\nint mjs_del(struct mjs *mjs, mjs_val_t obj, const char *name, size_t len) {\n  struct mjs_property *prop, *prev;\n\n  if (!mjs_is_object(obj)) {\n    return -1;\n  }\n  if (len == (size_t) ~0) {\n    len = strlen(name);\n  }\n  for (prev = NULL, prop = get_object_struct(obj)->properties; prop != NULL;\n       prev = prop, prop = prop->next) {\n    size_t n;\n    const char *s = mjs_get_string(mjs, &prop->name, &n);\n    if (n == len && strncmp(s, name, len) == 0) {\n      if (prev) {\n        prev->next = prop->next;\n      } else {\n        get_object_struct(obj)->properties = prop->next;\n      }\n      mjs_destroy_property(&prop);\n      return 0;\n    }\n  }\n  return -1;\n}\n\nmjs_val_t mjs_next(struct mjs *mjs, mjs_val_t obj, mjs_val_t *iterator) {\n  struct mjs_property *p = NULL;\n  mjs_val_t key = MJS_UNDEFINED;\n\n  if (*iterator == MJS_UNDEFINED) {\n    struct mjs_object *o = get_object_struct(obj);\n    p = o->properties;\n  } else {\n    p = ((struct mjs_property *) get_ptr(*iterator))->next;\n  }\n\n  if (p == NULL) {\n    *iterator = MJS_UNDEFINED;\n  } else {\n    key = p->name;\n    *iterator = mjs_mk_foreign(mjs, p);\n  }\n\n  return key;\n}\n\nMJS_PRIVATE void mjs_op_create_object(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t proto_v = mjs_arg(mjs, 0);\n\n  if (!mjs_check_arg(mjs, 0, \"proto\", MJS_TYPE_OBJECT_GENERIC, &proto_v)) {\n    goto clean;\n  }\n\n  ret = mjs_mk_object(mjs);\n  mjs_set(mjs, ret, MJS_PROTO_PROP_NAME, ~0, proto_v);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nmjs_val_t mjs_struct_to_obj(struct mjs *mjs, const void *base,\n                            const struct mjs_c_struct_member *defs) {\n  mjs_val_t obj;\n  const struct mjs_c_struct_member *def = defs;\n  if (base == NULL || def == NULL) return MJS_UNDEFINED;\n  obj = mjs_mk_object(mjs);\n  /* Pin the object while it is being built */\n  mjs_own(mjs, &obj);\n  /*\n   * Because mjs inserts new properties at the head of the list,\n   * start from the end so the constructed object more closely resembles\n   * the definition.\n   */\n  while (def->name != NULL) def++;\n  for (def--; def >= defs; def--) {\n    mjs_val_t v = MJS_UNDEFINED;\n    const char *ptr = (const char *) base + def->offset;\n    switch (def->type) {\n      case MJS_STRUCT_FIELD_TYPE_STRUCT: {\n        const void *sub_base = (const void *) ptr;\n        const struct mjs_c_struct_member *sub_def =\n            (const struct mjs_c_struct_member *) def->arg;\n        v = mjs_struct_to_obj(mjs, sub_base, sub_def);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_STRUCT_PTR: {\n        const void **sub_base = (const void **) ptr;\n        const struct mjs_c_struct_member *sub_def =\n            (const struct mjs_c_struct_member *) def->arg;\n        if (*sub_base != NULL) {\n          v = mjs_struct_to_obj(mjs, *sub_base, sub_def);\n        } else {\n          v = MJS_NULL;\n        }\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT: {\n        double value = (double) (*(int *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_BOOL: {\n        v = mjs_mk_boolean(mjs, *(bool *) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_DOUBLE: {\n        v = mjs_mk_number(mjs, *(double *) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_FLOAT: {\n        float value = *(float *) ptr;\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_CHAR_PTR: {\n        const char *value = *(const char **) ptr;\n        v = mjs_mk_string(mjs, value, ~0, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_VOID_PTR: {\n        v = mjs_mk_foreign(mjs, *(void **) ptr);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_MG_STR_PTR: {\n        const struct mg_str *s = *(const struct mg_str **) ptr;\n        if (s != NULL) {\n          v = mjs_mk_string(mjs, s->p, s->len, 1);\n        } else {\n          v = MJS_NULL;\n        }\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_MG_STR: {\n        const struct mg_str *s = (const struct mg_str *) ptr;\n        v = mjs_mk_string(mjs, s->p, s->len, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_DATA: {\n        const char *dptr = (const char *) ptr;\n        const intptr_t dlen = (intptr_t) def->arg;\n        v = mjs_mk_string(mjs, dptr, dlen, 1);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT8: {\n        double value = (double) (*(int8_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_INT16: {\n        double value = (double) (*(int16_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_UINT8: {\n        double value = (double) (*(uint8_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_UINT16: {\n        double value = (double) (*(uint16_t *) ptr);\n        v = mjs_mk_number(mjs, value);\n        break;\n      }\n      case MJS_STRUCT_FIELD_TYPE_CUSTOM: {\n        mjs_val_t (*fptr)(struct mjs *, const void *) =\n            (mjs_val_t (*) (struct mjs *, const void *)) def->arg;\n        v = fptr(mjs, ptr);\n      }\n      default: { break; }\n    }\n    mjs_set(mjs, obj, def->name, ~0, v);\n  }\n  mjs_disown(mjs, &obj);\n  return obj;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_parser.c\"\n#endif\n\n#include \"common/cs_varint.h\"\n\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_parser.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\n#ifndef MAX_TOKS_IN_EXPR\n#define MAX_TOKS_IN_EXPR 40\n#endif\n\n#define FAIL_ERR(p, code)                                                      \\\n  do {                                                                         \\\n    mjs_set_errorf(p->mjs, code, \"parse error at line %d: [%.*s]\", p->line_no, \\\n                   10, p->tok.ptr);                                            \\\n    return code;                                                               \\\n  } while (0)\n\n#define pnext1(p)                                    \\\n  do {                                               \\\n    LOG(LL_VERBOSE_DEBUG, (\"  PNEXT %d\", __LINE__)); \\\n    pnext(p);                                        \\\n  } while (0)\n\n#define SYNTAX_ERROR(p) FAIL_ERR(p, MJS_SYNTAX_ERROR)\n#undef EXPECT\n#define EXPECT(p, t)       \\\n  if ((p)->tok.tok != (t)) \\\n    SYNTAX_ERROR(p);       \\\n  else                     \\\n    pnext1(p);\n\nstatic mjs_err_t parse_statement(struct pstate *p);\nstatic mjs_err_t parse_expr(struct pstate *p);\n\nstatic int ptest(struct pstate *p) {\n  struct pstate saved = *p;\n  int tok = pnext(p);\n  *p = saved;\n  return tok;\n}\n\nstatic int s_unary_ops[] = {TOK_NOT, TOK_TILDA, TOK_PLUS_PLUS, TOK_MINUS_MINUS,\n                            TOK_KEYWORD_TYPEOF, TOK_MINUS, TOK_PLUS, TOK_EOF};\nstatic int s_comparison_ops[] = {TOK_LT, TOK_LE, TOK_GT, TOK_GE, TOK_EOF};\nstatic int s_postfix_ops[] = {TOK_PLUS_PLUS, TOK_MINUS_MINUS, TOK_EOF};\nstatic int s_equality_ops[] = {TOK_EQ, TOK_NE, TOK_EQ_EQ, TOK_NE_NE, TOK_EOF};\nstatic int s_assign_ops[] = {\n    TOK_ASSIGN,         TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN,  TOK_MUL_ASSIGN,\n    TOK_DIV_ASSIGN,     TOK_REM_ASSIGN,  TOK_LSHIFT_ASSIGN, TOK_RSHIFT_ASSIGN,\n    TOK_URSHIFT_ASSIGN, TOK_AND_ASSIGN,  TOK_XOR_ASSIGN,    TOK_OR_ASSIGN,\n    TOK_EOF};\n\nstatic int findtok(int *toks, int tok) {\n  int i = 0;\n  while (tok != toks[i] && toks[i] != TOK_EOF) i++;\n  return toks[i];\n}\n\nstatic void emit_op(struct pstate *pstate, int tok) {\n  assert(tok >= 0 && tok <= 255);\n  emit_byte(pstate, OP_EXPR);\n  emit_byte(pstate, (uint8_t) tok);\n}\n\n#define BINOP_STACK_FRAME_SIZE 16\n#define STACK_LIMIT 8192\n\n// Intentionally left as macro rather than a function, to let the\n// compiler to inline calls and mimimize runtime stack usage.\n#define PARSE_LTR_BINOP(p, f1, f2, ops, prev_op)                               \\\n  do {                                                                         \\\n    mjs_err_t res = MJS_OK;                                                    \\\n    p->depth++;                                                                \\\n    if (p->depth > (STACK_LIMIT / BINOP_STACK_FRAME_SIZE)) {                   \\\n      mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"parser stack overflow\");       \\\n      res = MJS_SYNTAX_ERROR;                                                  \\\n      goto binop_clean;                                                        \\\n    }                                                                          \\\n    if ((res = f1(p, TOK_EOF)) != MJS_OK) goto binop_clean;                    \\\n    if (prev_op != TOK_EOF) emit_op(p, prev_op);                               \\\n    if (findtok(ops, p->tok.tok) != TOK_EOF) {                                 \\\n      int op = p->tok.tok;                                                     \\\n      size_t off_if = 0;                                                       \\\n      /* For AND/OR, implement short-circuit evaluation */                     \\\n      if (ops[0] == TOK_LOGICAL_AND || ops[0] == TOK_LOGICAL_OR) {             \\\n        emit_byte(p,                                                           \\\n                  (uint8_t)(ops[0] == TOK_LOGICAL_AND ? OP_JMP_NEUTRAL_FALSE   \\\n                                                      : OP_JMP_NEUTRAL_TRUE)); \\\n        off_if = p->cur_idx;                                                   \\\n        emit_init_offset(p);                                                   \\\n        /* No need to emit TOK_LOGICAL_AND and TOK_LOGICAL_OR: */              \\\n        /* Just drop the first value, and evaluate the second one. */          \\\n        emit_byte(p, (uint8_t) OP_DROP);                                       \\\n        op = TOK_EOF;                                                          \\\n      }                                                                        \\\n      pnext1(p);                                                               \\\n      if ((res = f2(p, op)) != MJS_OK) goto binop_clean;                       \\\n                                                                               \\\n      if (off_if != 0) {                                                       \\\n        mjs_bcode_insert_offset(p, p->mjs, off_if,                             \\\n                                p->cur_idx - off_if - MJS_INIT_OFFSET_SIZE);   \\\n      }                                                                        \\\n    }                                                                          \\\n  binop_clean:                                                                 \\\n    p->depth--;                                                                \\\n    return res;                                                                \\\n  } while (0)\n\n#define PARSE_RTL_BINOP(p, f1, f2, ops, prev_op)        \\\n  do {                                                  \\\n    mjs_err_t res = MJS_OK;                             \\\n    (void) prev_op;                                     \\\n    if ((res = f1(p, TOK_EOF)) != MJS_OK) return res;   \\\n    if (findtok(ops, p->tok.tok) != TOK_EOF) {          \\\n      int op = p->tok.tok;                              \\\n      pnext1(p);                                        \\\n      if ((res = f2(p, TOK_EOF)) != MJS_OK) return res; \\\n      emit_op(p, op);                                   \\\n    }                                                   \\\n    return res;                                         \\\n  } while (0)\n\n#if MJS_INIT_OFFSET_SIZE > 0\nstatic void emit_init_offset(struct pstate *p) {\n  size_t i;\n  for (i = 0; i < MJS_INIT_OFFSET_SIZE; i++) {\n    emit_byte(p, 0);\n  }\n}\n#else\nstatic void emit_init_offset(struct pstate *p) {\n  (void) p;\n}\n#endif\n\nstatic mjs_err_t parse_statement_list(struct pstate *p, int et) {\n  mjs_err_t res = MJS_OK;\n  int drop = 0;\n  pnext1(p);\n  while (res == MJS_OK && p->tok.tok != TOK_EOF && p->tok.tok != et) {\n    if (drop) emit_byte(p, OP_DROP);\n    res = parse_statement(p);\n    drop = 1;\n    while (p->tok.tok == TOK_SEMICOLON) pnext1(p);\n  }\n\n  /*\n   * Client code expects statement list to contain a value, so if the statement\n   * list was empty, push `undefined`.\n   */\n  if (!drop) {\n    emit_byte(p, OP_PUSH_UNDEF);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_block(struct pstate *p, int mkscope) {\n  mjs_err_t res = MJS_OK;\n  p->depth++;\n  if (p->depth > (STACK_LIMIT / BINOP_STACK_FRAME_SIZE)) {\n    mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"parser stack overflow\");\n    res = MJS_SYNTAX_ERROR;\n    return res;\n  }\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  if (mkscope) emit_byte(p, OP_NEW_SCOPE);\n  res = parse_statement_list(p, TOK_CLOSE_CURLY);\n  EXPECT(p, TOK_CLOSE_CURLY);\n  if (mkscope) emit_byte(p, OP_DEL_SCOPE);\n  return res;\n}\n\nstatic mjs_err_t parse_function(struct pstate *p) {\n  size_t prologue, off;\n  int arg_no = 0;\n  int name_provided = 0;\n  mjs_err_t res = MJS_OK;\n\n  EXPECT(p, TOK_KEYWORD_FUNCTION);\n\n  if (p->tok.tok == TOK_IDENT) {\n    /* Function name was provided */\n    struct tok tmp = p->tok;\n    name_provided = 1;\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_FIND_SCOPE);\n    pnext1(p);\n  }\n\n  emit_byte(p, OP_JMP);\n  off = p->cur_idx;\n  emit_init_offset(p);\n\n  prologue = p->cur_idx;\n\n  EXPECT(p, TOK_OPEN_PAREN);\n  emit_byte(p, OP_NEW_SCOPE);\n  // Emit names of function arguments\n  while (p->tok.tok != TOK_CLOSE_PAREN) {\n    if (p->tok.tok != TOK_IDENT) SYNTAX_ERROR(p);\n    emit_byte(p, OP_SET_ARG);\n    emit_int(p, arg_no);\n    arg_no++;\n    emit_str(p, p->tok.ptr, p->tok.len);\n    if (ptest(p) == TOK_COMMA) pnext1(p);\n    pnext1(p);\n  }\n  EXPECT(p, TOK_CLOSE_PAREN);\n  if ((res = parse_block(p, 0)) != MJS_OK) return res;\n  emit_byte(p, OP_RETURN);\n  prologue += mjs_bcode_insert_offset(p, p->mjs, off,\n                                      p->cur_idx - off - MJS_INIT_OFFSET_SIZE);\n  emit_byte(p, OP_PUSH_FUNC);\n  emit_int(p, p->cur_idx - 1 /* OP_PUSH_FUNC */ - prologue);\n  if (name_provided) {\n    emit_op(p, TOK_ASSIGN);\n  }\n\n  return res;\n}\n\nstatic mjs_err_t parse_object_literal(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  EXPECT(p, TOK_OPEN_CURLY);\n  emit_byte(p, OP_PUSH_OBJ);\n  while (p->tok.tok != TOK_CLOSE_CURLY) {\n    if (p->tok.tok != TOK_IDENT && p->tok.tok != TOK_STR) SYNTAX_ERROR(p);\n    emit_byte(p, OP_DUP);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, p->tok.ptr, p->tok.len);\n    emit_byte(p, OP_SWAP);\n    pnext1(p);\n    EXPECT(p, TOK_COLON);\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n    emit_op(p, TOK_ASSIGN);\n    emit_byte(p, OP_DROP);\n    if (p->tok.tok == TOK_COMMA) {\n      pnext1(p);\n    } else if (p->tok.tok != TOK_CLOSE_CURLY) {\n      SYNTAX_ERROR(p);\n    }\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_array_literal(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  EXPECT(p, TOK_OPEN_BRACKET);\n  emit_byte(p, OP_PUSH_ARRAY);\n  while (p->tok.tok != TOK_CLOSE_BRACKET) {\n    emit_byte(p, OP_DUP);\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n    emit_byte(p, OP_APPEND);\n    if (p->tok.tok == TOK_COMMA) pnext1(p);\n  }\n  return res;\n}\n\nstatic enum mjs_err parse_literal(struct pstate *p, const struct tok *t) {\n  struct mbuf *bcode_gen = &p->mjs->bcode_gen;\n  enum mjs_err res = MJS_OK;\n  int tok = t->tok;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s] %p\", p->tok.len, p->tok.ptr, (void *) &t));\n  switch (t->tok) {\n    case TOK_KEYWORD_FALSE:\n      emit_byte(p, OP_PUSH_FALSE);\n      break;\n    case TOK_KEYWORD_TRUE:\n      emit_byte(p, OP_PUSH_TRUE);\n      break;\n    case TOK_KEYWORD_UNDEFINED:\n      emit_byte(p, OP_PUSH_UNDEF);\n      break;\n    case TOK_KEYWORD_NULL:\n      emit_byte(p, OP_PUSH_NULL);\n      break;\n    case TOK_IDENT: {\n      int prev_tok = p->prev_tok;\n      int next_tok = ptest(p);\n      emit_byte(p, OP_PUSH_STR);\n      emit_str(p, t->ptr, t->len);\n      emit_byte(p, (uint8_t)(prev_tok == TOK_DOT ? OP_SWAP : OP_FIND_SCOPE));\n      if (!findtok(s_assign_ops, next_tok) &&\n          !findtok(s_postfix_ops, next_tok) &&\n          /* TODO(dfrank): fix: it doesn't work for prefix ops */\n          !findtok(s_postfix_ops, prev_tok)) {\n        emit_byte(p, OP_GET);\n      }\n      break;\n    }\n    case TOK_NUM: {\n      double iv, d = strtod(t->ptr, NULL);\n      unsigned long uv = strtoul(t->ptr + 2, NULL, 16);\n      if (t->ptr[0] == '0' && t->ptr[1] == 'x') d = uv;\n      if (modf(d, &iv) == 0) {\n        emit_byte(p, OP_PUSH_INT);\n        emit_int(p, (int64_t) d);\n      } else {\n        emit_byte(p, OP_PUSH_DBL);\n        emit_str(p, t->ptr, t->len);\n      }\n      break;\n    }\n    case TOK_STR: {\n      size_t oldlen;\n      emit_byte(p, OP_PUSH_STR);\n      oldlen = bcode_gen->len;\n      embed_string(bcode_gen, p->cur_idx, t->ptr, t->len, EMBSTR_UNESCAPE);\n      p->cur_idx += bcode_gen->len - oldlen;\n    } break;\n    case TOK_OPEN_BRACKET:\n      res = parse_array_literal(p);\n      break;\n    case TOK_OPEN_CURLY:\n      res = parse_object_literal(p);\n      break;\n    case TOK_OPEN_PAREN:\n      pnext1(p);\n      res = parse_expr(p);\n      if (p->tok.tok != TOK_CLOSE_PAREN) SYNTAX_ERROR(p);\n      break;\n    case TOK_KEYWORD_FUNCTION:\n      res = parse_function(p);\n      break;\n    case TOK_KEYWORD_THIS:\n      emit_byte(p, OP_PUSH_THIS);\n      break;\n    default:\n      SYNTAX_ERROR(p);\n  }\n  if (tok != TOK_KEYWORD_FUNCTION) pnext1(p);\n  return res;\n}\n\nstatic mjs_err_t parse_call_dot_mem(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_DOT, TOK_OPEN_PAREN, TOK_OPEN_BRACKET, TOK_EOF};\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_literal(p, &p->tok)) != MJS_OK) return res;\n  while (findtok(ops, p->tok.tok) != TOK_EOF) {\n    if (p->tok.tok == TOK_OPEN_BRACKET) {\n      int prev_tok = p->prev_tok;\n      EXPECT(p, TOK_OPEN_BRACKET);\n      if ((res = parse_expr(p)) != MJS_OK) return res;\n      emit_byte(p, OP_SWAP);\n      EXPECT(p, TOK_CLOSE_BRACKET);\n      if (!findtok(s_assign_ops, p->tok.tok) &&\n          !findtok(s_postfix_ops, p->tok.tok) &&\n          /* TODO(dfrank): fix: it doesn't work for prefix ops */\n          !findtok(s_postfix_ops, prev_tok)) {\n        emit_byte(p, OP_GET);\n      }\n    } else if (p->tok.tok == TOK_OPEN_PAREN) {\n      EXPECT(p, TOK_OPEN_PAREN);\n      emit_byte(p, OP_ARGS);\n      while (p->tok.tok != TOK_CLOSE_PAREN) {\n        if ((res = parse_expr(p)) != MJS_OK) return res;\n        if (p->tok.tok == TOK_COMMA) pnext1(p);\n      }\n      emit_byte(p, OP_CALL);\n      EXPECT(p, TOK_CLOSE_PAREN);\n    } else if (p->tok.tok == TOK_DOT) {\n      EXPECT(p, TOK_DOT);\n      if ((res = parse_call_dot_mem(p, TOK_DOT)) != MJS_OK) return res;\n    }\n  }\n  (void) prev_op;\n  return res;\n}\n\nstatic mjs_err_t parse_postfix(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_call_dot_mem(p, prev_op)) != MJS_OK) return res;\n  if (p->tok.tok == TOK_PLUS_PLUS || p->tok.tok == TOK_MINUS_MINUS) {\n    int op = p->tok.tok == TOK_PLUS_PLUS ? TOK_POSTFIX_PLUS : TOK_POSTFIX_MINUS;\n    emit_op(p, op);\n    pnext1(p);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_unary(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  int op = TOK_EOF;\n  if (findtok(s_unary_ops, p->tok.tok) != TOK_EOF) {\n    op = p->tok.tok;\n    pnext1(p);\n  }\n  if (findtok(s_unary_ops, p->tok.tok) != TOK_EOF) {\n    res = parse_unary(p, prev_op);\n  } else {\n    res = parse_postfix(p, prev_op);\n  }\n  if (res != MJS_OK) return res;\n  if (op != TOK_EOF) {\n    if (op == TOK_MINUS) op = TOK_UNARY_MINUS;\n    if (op == TOK_PLUS) op = TOK_UNARY_PLUS;\n    emit_op(p, op);\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_mul_div_rem(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_MUL, TOK_DIV, TOK_REM, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_unary, parse_mul_div_rem, ops, prev_op);\n}\n\nstatic mjs_err_t parse_plus_minus(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_PLUS, TOK_MINUS, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_mul_div_rem, parse_plus_minus, ops, prev_op);\n}\n\nstatic mjs_err_t parse_shifts(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LSHIFT, TOK_RSHIFT, TOK_URSHIFT, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_plus_minus, parse_shifts, ops, prev_op);\n}\n\nstatic mjs_err_t parse_comparison(struct pstate *p, int prev_op) {\n  PARSE_LTR_BINOP(p, parse_shifts, parse_comparison, s_comparison_ops, prev_op);\n}\n\nstatic mjs_err_t parse_equality(struct pstate *p, int prev_op) {\n  PARSE_LTR_BINOP(p, parse_comparison, parse_equality, s_equality_ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_and(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_AND, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_equality, parse_bitwise_and, ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_xor(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_XOR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_and, parse_bitwise_xor, ops, prev_op);\n}\n\nstatic mjs_err_t parse_bitwise_or(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_OR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_xor, parse_bitwise_or, ops, prev_op);\n}\n\nstatic mjs_err_t parse_logical_and(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LOGICAL_AND, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_bitwise_or, parse_logical_and, ops, prev_op);\n}\n\nstatic mjs_err_t parse_logical_or(struct pstate *p, int prev_op) {\n  int ops[] = {TOK_LOGICAL_OR, TOK_EOF};\n  PARSE_LTR_BINOP(p, parse_logical_and, parse_logical_or, ops, prev_op);\n}\n\nstatic mjs_err_t parse_ternary(struct pstate *p, int prev_op) {\n  mjs_err_t res = MJS_OK;\n  if ((res = parse_logical_or(p, TOK_EOF)) != MJS_OK) return res;\n  if (prev_op != TOK_EOF) emit_op(p, prev_op);\n\n  if (p->tok.tok == TOK_QUESTION) {\n    size_t off_if, off_endif, off_else;\n    EXPECT(p, TOK_QUESTION);\n\n    emit_byte(p, OP_JMP_FALSE);\n    off_if = p->cur_idx;\n    emit_init_offset(p);\n\n    if ((res = parse_ternary(p, TOK_EOF)) != MJS_OK) return res;\n\n    emit_byte(p, OP_JMP);\n    off_else = p->cur_idx;\n    emit_init_offset(p);\n    off_endif = p->cur_idx;\n\n    emit_byte(p, OP_DROP);\n\n    EXPECT(p, TOK_COLON);\n    if ((res = parse_ternary(p, TOK_EOF)) != MJS_OK) return res;\n\n    /*\n     * NOTE: if inserting offset causes the code to move, off_endif needs to be\n     * adjusted\n     */\n    off_endif += mjs_bcode_insert_offset(\n        p, p->mjs, off_else, p->cur_idx - off_else - MJS_INIT_OFFSET_SIZE);\n\n    mjs_bcode_insert_offset(p, p->mjs, off_if,\n                            off_endif - off_if - MJS_INIT_OFFSET_SIZE);\n  }\n\n  return res;\n}\n\nstatic mjs_err_t parse_assignment(struct pstate *p, int prev_op) {\n  PARSE_RTL_BINOP(p, parse_ternary, parse_assignment, s_assign_ops, prev_op);\n}\n\nstatic mjs_err_t parse_expr(struct pstate *p) {\n  return parse_assignment(p, TOK_EOF);\n}\n\nstatic mjs_err_t parse_let(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_LET);\n  for (;;) {\n    struct tok tmp = p->tok;\n    EXPECT(p, TOK_IDENT);\n\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, tmp.ptr, tmp.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n\n    if (p->tok.tok == TOK_ASSIGN) {\n      pnext1(p);\n      emit_byte(p, OP_PUSH_STR);\n      emit_str(p, tmp.ptr, tmp.len);\n      emit_byte(p, OP_FIND_SCOPE);\n      if ((res = parse_expr(p)) != MJS_OK) return res;\n      emit_op(p, TOK_ASSIGN);\n    } else {\n      emit_byte(p, OP_PUSH_UNDEF);\n    }\n    if (p->tok.tok == TOK_COMMA) {\n      emit_byte(p, OP_DROP);\n      pnext1(p);\n    }\n    if (p->tok.tok == TOK_SEMICOLON || p->tok.tok == TOK_EOF) break;\n  }\n  return res;\n}\n\nstatic mjs_err_t parse_block_or_stmt(struct pstate *p, int cs) {\n  if (ptest(p) == TOK_OPEN_CURLY) {\n    return parse_block(p, cs);\n  } else {\n    return parse_statement(p);\n  }\n}\n\nstatic mjs_err_t parse_for_in(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  size_t off_b, off_check_end;\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /* Put iterator variable name to the stack */\n  if (p->tok.tok == TOK_KEYWORD_LET) {\n    EXPECT(p, TOK_KEYWORD_LET);\n    emit_byte(p, OP_PUSH_STR);\n    emit_str(p, p->tok.ptr, p->tok.len);\n    emit_byte(p, OP_PUSH_SCOPE);\n    emit_byte(p, OP_CREATE);\n  }\n  emit_byte(p, OP_PUSH_STR);\n  emit_str(p, p->tok.ptr, p->tok.len);\n\n  /* Put object to the stack */\n  EXPECT(p, TOK_IDENT);\n  EXPECT(p, TOK_KEYWORD_IN);\n  parse_expr(p);\n  EXPECT(p, TOK_CLOSE_PAREN);\n\n  emit_byte(p, OP_PUSH_UNDEF); /* Push iterator */\n\n  /* Before parsing condition statement, push break/continue offsets  */\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  emit_byte(p, 0); /* Point OP_CONTINUE to the next instruction */\n\n  emit_byte(p, OP_FOR_IN_NEXT);\n  emit_byte(p, OP_DUP);\n  emit_byte(p, OP_JMP_FALSE);\n  off_check_end = p->cur_idx;\n  emit_init_offset(p);\n\n  // Parse loop body\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_check_end,\n                          p->cur_idx - off_check_end - MJS_INIT_OFFSET_SIZE);\n\n  /* NOTE: jump C -> cond link is already established, it's constant: zero */\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> cond */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_DEL_SCOPE);\n\n  return res;\n}\n\nstatic int check_for_in(struct pstate *p) {\n  struct pstate saved = *p;\n  int forin = 0;\n  if (p->tok.tok == TOK_KEYWORD_LET) pnext1(p);\n  if (p->tok.tok == TOK_IDENT) {\n    pnext1(p);\n    if (p->tok.tok == TOK_KEYWORD_IN) forin = 1;\n  }\n  *p = saved;\n  return forin;\n}\n\nstatic mjs_err_t parse_for(struct pstate *p) {\n  mjs_err_t res = MJS_OK;\n  size_t off_b, off_c, off_init_end;\n  size_t off_incr_begin, off_cond_begin, off_cond_end;\n  int buf_cur_idx;\n\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_FOR);\n  EXPECT(p, TOK_OPEN_PAREN);\n\n  /* Look forward - is it for..in ? */\n  if (check_for_in(p)) return parse_for_in(p);\n\n  /*\n   * BC is a break+continue offsets (a part of OP_LOOP opcode)\n   *\n   *  BC init  incr  cond  body  break  del_scope\n   *  ||    |  ^     ^  |        ^      ^\n   *  ||    +--|-----+  |        |      |\n   *  |+-------+        +--------+      |\n   *  +---------------------------------+\n   *\n   * The order to setup links:\n   *\n   *   cond -> break\n   *   init -> cond\n   *   C -> incr\n   *   B -> del_scope\n   */\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /* Before parsing condition statement, push break/continue offsets  */\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  off_c = p->cur_idx;\n  emit_init_offset(p);\n\n  /* Parse init statement */\n  if (p->tok.tok == TOK_KEYWORD_LET) {\n    if ((res = parse_let(p)) != MJS_OK) return res;\n  } else {\n    if ((res = parse_expr(p)) != MJS_OK) return res;\n  }\n  EXPECT(p, TOK_SEMICOLON);\n  emit_byte(p, OP_DROP);\n\n  emit_byte(p, OP_JMP);\n  off_init_end = p->cur_idx;\n  emit_init_offset(p);\n\n  off_incr_begin = p->cur_idx;\n  off_cond_begin = p->cur_idx;\n\n  /* Parse cond statement */\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_SEMICOLON);\n\n  /* Parse incr statement */\n  /* Incr statement should be placed before cond, so, adjust cur_idx */\n  buf_cur_idx = p->cur_idx;\n  p->cur_idx = off_incr_begin;\n\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_CLOSE_PAREN);\n  emit_byte(p, OP_DROP);\n\n  /*\n   * Now incr is inserted before cond, so we adjust cur_idx back, and set\n   * off_cond_begin to the correct value\n   */\n  {\n    int incr_size = p->cur_idx - off_incr_begin;\n    off_cond_begin += incr_size;\n    p->cur_idx = buf_cur_idx + incr_size;\n  }\n\n  /* p->cur_idx is now at the end of \"cond\" */\n  /* Exit the loop if false */\n  emit_byte(p, OP_JMP_FALSE);\n  off_cond_end = p->cur_idx;\n  emit_init_offset(p);\n\n  /* Parse loop body */\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* p->cur_idx is at the \"break\" item now */\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_cond_end,\n                          p->cur_idx - off_cond_end - MJS_INIT_OFFSET_SIZE);\n\n  /* jump init -> cond (and adjust off_incr_begin which may move) */\n  off_incr_begin += mjs_bcode_insert_offset(\n      p, p->mjs, off_init_end,\n      off_cond_begin - off_init_end - MJS_INIT_OFFSET_SIZE);\n\n  /* jump C -> incr */\n  mjs_bcode_insert_offset(p, p->mjs, off_c,\n                          off_incr_begin - off_c - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> del_scope */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DEL_SCOPE);\n\n  return res;\n}\n\nstatic mjs_err_t parse_while(struct pstate *p) {\n  size_t off_cond_end, off_b;\n  mjs_err_t res = MJS_OK;\n\n  EXPECT(p, TOK_KEYWORD_WHILE);\n  EXPECT(p, TOK_OPEN_PAREN);\n\n  /* new scope should be pushed before OP_LOOP instruction */\n  emit_byte(p, OP_NEW_SCOPE);\n\n  /*\n   * BC is a break+continue offsets (a part of OP_LOOP opcode)\n   *\n   *   BC cond body break del_scope\n   *   || ^  |      ^     ^\n   *   || |  |      |     |\n   *   |+-+  +------+     |\n   *   +------------------+\n   *\n   * The order to setup links:\n   *\n   *    cond -> break\n   *    C -> cond\n   *    B -> del_scope\n   */\n\n  emit_byte(p, OP_LOOP);\n  off_b = p->cur_idx;\n  emit_init_offset(p);\n  emit_byte(p, 0); /* Point OP_CONTINUE to the next instruction */\n\n  // parse condition statement\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n  EXPECT(p, TOK_CLOSE_PAREN);\n\n  // Exit the loop if false\n  emit_byte(p, OP_JMP_FALSE);\n  off_cond_end = p->cur_idx;\n  emit_init_offset(p);\n\n  // Parse loop body\n  if (p->tok.tok == TOK_OPEN_CURLY) {\n    if ((res = parse_statement_list(p, TOK_CLOSE_CURLY)) != MJS_OK) return res;\n    pnext1(p);\n  } else {\n    if ((res = parse_statement(p)) != MJS_OK) return res;\n  }\n  emit_byte(p, OP_DROP);\n  emit_byte(p, OP_CONTINUE);\n\n  /* jump cond -> break */\n  mjs_bcode_insert_offset(p, p->mjs, off_cond_end,\n                          p->cur_idx - off_cond_end - MJS_INIT_OFFSET_SIZE);\n\n  /* NOTE: jump C -> cond link is already established, it's constant: zero */\n\n  emit_byte(p, OP_BREAK);\n\n  /* jump B -> cond */\n  mjs_bcode_insert_offset(p, p->mjs, off_b,\n                          p->cur_idx - off_b - MJS_INIT_OFFSET_SIZE);\n\n  emit_byte(p, OP_DEL_SCOPE);\n  return res;\n}\n\nstatic mjs_err_t parse_if(struct pstate *p) {\n  size_t off_if, off_endif;\n  mjs_err_t res = MJS_OK;\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  EXPECT(p, TOK_KEYWORD_IF);\n  EXPECT(p, TOK_OPEN_PAREN);\n  if ((res = parse_expr(p)) != MJS_OK) return res;\n\n  emit_byte(p, OP_JMP_FALSE);\n  off_if = p->cur_idx;\n  emit_init_offset(p);\n\n  EXPECT(p, TOK_CLOSE_PAREN);\n  if ((res = parse_block_or_stmt(p, 1)) != MJS_OK) return res;\n\n  if (p->tok.tok == TOK_KEYWORD_ELSE) {\n    /*\n     * Else clause is present, so, if the condition is not true, the jump\n     * target (off_endif) should be not the current offset, but the offset\n     * after jump-over-else opcode\n     */\n    size_t off_else, off_endelse;\n    pnext1(p);\n    emit_byte(p, OP_JMP);\n    off_else = p->cur_idx;\n    emit_init_offset(p);\n    off_endif = p->cur_idx;\n\n    emit_byte(p, OP_DROP);\n    if ((res = parse_block_or_stmt(p, 1)) != MJS_OK) return res;\n    off_endelse = p->cur_idx;\n\n    /*\n     * NOTE: if inserting offset causes the code to move, off_endif needs to be\n     * adjusted\n     */\n    off_endif += mjs_bcode_insert_offset(\n        p, p->mjs, off_else, off_endelse - off_else - MJS_INIT_OFFSET_SIZE);\n  } else {\n    /* Else clause is not present, so, current offset is a jump target\n     * (off_endif) */\n    off_endif = p->cur_idx;\n  }\n\n  mjs_bcode_insert_offset(p, p->mjs, off_if,\n                          off_endif - off_if - MJS_INIT_OFFSET_SIZE);\n\n  return res;\n}\n\nstatic void pstate_revert(struct pstate *p, struct pstate *old,\n                          int old_bcode_gen_len) {\n  p->pos = old->pos;\n  p->line_no = old->line_no;\n  p->last_emitted_line_no = old->last_emitted_line_no;\n  p->offset_lineno_map.len = old->offset_lineno_map.len;\n  p->prev_tok = old->prev_tok;\n  p->tok = old->tok;\n  p->mjs->bcode_gen.len = old_bcode_gen_len;\n  p->cur_idx = old->cur_idx;\n  p->depth = old->depth;\n}\n\nstatic mjs_err_t parse_return(struct pstate *p) {\n  int old_bcode_gen_len;\n  struct pstate p_saved;\n  EXPECT(p, TOK_KEYWORD_RETURN);\n  p_saved = *p;\n  old_bcode_gen_len = p->mjs->bcode_gen.len;\n  if (parse_expr(p) != MJS_OK) {\n    /*\n     * Failed to parse an expression to return, so return the parser to the\n     * prior state and push undefined.\n     */\n    pstate_revert(p, &p_saved, old_bcode_gen_len);\n    emit_byte(p, OP_PUSH_UNDEF);\n  }\n  emit_byte(p, OP_SETRETVAL);\n  emit_byte(p, OP_RETURN);\n  return MJS_OK;\n}\n\nstatic mjs_err_t parse_statement(struct pstate *p) {\n  LOG(LL_VERBOSE_DEBUG, (\"[%.*s]\", 10, p->tok.ptr));\n  switch (p->tok.tok) {\n    case TOK_SEMICOLON:\n      emit_byte(p, OP_PUSH_UNDEF);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_LET:\n      return parse_let(p);\n    case TOK_OPEN_CURLY:\n      return parse_block(p, 1);\n    case TOK_KEYWORD_RETURN:\n      return parse_return(p);\n    case TOK_KEYWORD_FOR:\n      return parse_for(p);\n    case TOK_KEYWORD_WHILE:\n      return parse_while(p);\n    case TOK_KEYWORD_BREAK:\n      emit_byte(p, OP_PUSH_UNDEF);\n      emit_byte(p, OP_BREAK);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_CONTINUE:\n      emit_byte(p, OP_CONTINUE);\n      pnext1(p);\n      return MJS_OK;\n    case TOK_KEYWORD_IF:\n      return parse_if(p);\n    case TOK_KEYWORD_CASE:\n    case TOK_KEYWORD_CATCH:\n    case TOK_KEYWORD_DELETE:\n    case TOK_KEYWORD_DO:\n    case TOK_KEYWORD_INSTANCEOF:\n    case TOK_KEYWORD_NEW:\n    case TOK_KEYWORD_SWITCH:\n    case TOK_KEYWORD_THROW:\n    case TOK_KEYWORD_TRY:\n    case TOK_KEYWORD_VAR:\n    case TOK_KEYWORD_VOID:\n    case TOK_KEYWORD_WITH:\n      mjs_set_errorf(p->mjs, MJS_SYNTAX_ERROR, \"[%.*s] is not implemented\",\n                     p->tok.len, p->tok.ptr);\n      return MJS_SYNTAX_ERROR;\n    default: {\n      mjs_err_t res = MJS_OK;\n      for (;;) {\n        if ((res = parse_expr(p)) != MJS_OK) return res;\n        if (p->tok.tok != TOK_COMMA) break;\n        emit_byte(p, OP_DROP);\n        pnext1(p);\n      }\n      return res;\n    }\n  }\n}\n\nMJS_PRIVATE mjs_err_t\nmjs_parse(const char *path, const char *buf, struct mjs *mjs) {\n  mjs_err_t res = MJS_OK;\n  struct pstate p;\n  size_t start_idx, llen;\n  int map_len;\n  mjs_header_item_t bcode_offset, map_offset, total_size;\n\n  pinit(path, buf, &p);\n  p.mjs = mjs;\n  p.cur_idx = p.mjs->bcode_gen.len;\n  emit_byte(&p, OP_BCODE_HEADER);\n\n  /*\n   * TODO(dfrank): don't access mjs->bcode_gen directly, use emit_... API which\n   * takes care of p->cur_idx\n   */\n\n  /* Remember starting bcode position, and reserve the room for bcode header */\n  start_idx = p.mjs->bcode_gen.len;\n  mbuf_append(&p.mjs->bcode_gen, NULL,\n              sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT);\n\n  /* Append NULL-terminated filename */\n  mbuf_append(&p.mjs->bcode_gen, path, strlen(path) + 1 /* null-terminate */);\n\n  bcode_offset = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n         &bcode_offset, sizeof(mjs_header_item_t));\n\n  p.start_bcode_idx = p.mjs->bcode_gen.len;\n  p.cur_idx = p.mjs->bcode_gen.len;\n\n  res = parse_statement_list(&p, TOK_EOF);\n  emit_byte(&p, OP_EXIT);\n\n  /* remember map offset */\n  map_offset = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_MAP_OFFSET,\n         &map_offset, sizeof(mjs_header_item_t));\n\n  /* put map length varint */\n  map_len = p.offset_lineno_map.len;\n  llen = cs_varint_llen(map_len);\n  mbuf_resize(&p.mjs->bcode_gen, p.mjs->bcode_gen.size + llen);\n  cs_varint_encode(\n      map_len, (uint8_t *) p.mjs->bcode_gen.buf + p.mjs->bcode_gen.len, llen);\n  p.mjs->bcode_gen.len += llen;\n\n  /* put the map itself */\n  mbuf_append(&p.mjs->bcode_gen, p.offset_lineno_map.buf,\n              p.offset_lineno_map.len);\n\n  total_size = p.mjs->bcode_gen.len - start_idx;\n  memcpy(p.mjs->bcode_gen.buf + start_idx +\n             sizeof(mjs_header_item_t) * MJS_HDR_ITEM_TOTAL_SIZE,\n         &total_size, sizeof(mjs_header_item_t));\n\n  mbuf_free(&p.offset_lineno_map);\n\n  /*\n   * If parsing was successful, commit the bcode; otherwise drop generated\n   * bcode\n   */\n  if (res == MJS_OK) {\n    mjs_bcode_commit(mjs);\n  } else {\n    mbuf_free(&mjs->bcode_gen);\n  }\n\n  return res;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_primitive.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n\nmjs_val_t mjs_mk_null(void) {\n  return MJS_NULL;\n}\n\nint mjs_is_null(mjs_val_t v) {\n  return v == MJS_NULL;\n}\n\nmjs_val_t mjs_mk_undefined(void) {\n  return MJS_UNDEFINED;\n}\n\nint mjs_is_undefined(mjs_val_t v) {\n  return v == MJS_UNDEFINED;\n}\n\nmjs_val_t mjs_mk_number(struct mjs *mjs, double v) {\n  mjs_val_t res;\n  (void) mjs;\n  /* not every NaN is a JS NaN */\n  if (isnan(v)) {\n    res = MJS_TAG_NAN;\n  } else {\n    union {\n      double d;\n      mjs_val_t r;\n    } u;\n    u.d = v;\n    res = u.r;\n  }\n  return res;\n}\n\nstatic double get_double(mjs_val_t v) {\n  union {\n    double d;\n    mjs_val_t v;\n  } u;\n  u.v = v;\n  /* Due to NaN packing, any non-numeric value is already a valid NaN value */\n  return u.d;\n}\n\ndouble mjs_get_double(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  return get_double(v);\n}\n\nint mjs_get_int(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  /*\n   * NOTE(dfrank): without double cast, all numbers >= 0x80000000 are always\n   * converted to exactly 0x80000000.\n   */\n  return (int) (unsigned int) get_double(v);\n}\n\nint32_t mjs_get_int32(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  return (int32_t) get_double(v);\n}\n\nint mjs_is_number(mjs_val_t v) {\n  return v == MJS_TAG_NAN || !isnan(get_double(v));\n}\n\nmjs_val_t mjs_mk_boolean(struct mjs *mjs, int v) {\n  (void) mjs;\n  return (v ? 1 : 0) | MJS_TAG_BOOLEAN;\n}\n\nint mjs_get_bool(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  if (mjs_is_boolean(v)) {\n    return v & 1;\n  } else {\n    return 0;\n  }\n}\n\nint mjs_is_boolean(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_BOOLEAN;\n}\n\n#define MJS_IS_POINTER_LEGIT(n) \\\n  (((n) &MJS_TAG_MASK) == 0 || ((n) &MJS_TAG_MASK) == (~0 & MJS_TAG_MASK))\n\nMJS_PRIVATE mjs_val_t mjs_pointer_to_value(struct mjs *mjs, void *p) {\n  uint64_t n = ((uint64_t)(uintptr_t) p);\n\n  if (!MJS_IS_POINTER_LEGIT(n)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"invalid pointer value: %p\", p);\n  }\n  return n & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE mjs_val_t mjs_legit_pointer_to_value(void *p) {\n  uint64_t n = ((uint64_t)(uintptr_t) p);\n\n  assert(MJS_IS_POINTER_LEGIT(n));\n  return n & ~MJS_TAG_MASK;\n}\n\nMJS_PRIVATE void *get_ptr(mjs_val_t v) {\n  return (void *) (uintptr_t)(v & 0xFFFFFFFFFFFFUL);\n}\n\nvoid *mjs_get_ptr(struct mjs *mjs, mjs_val_t v) {\n  (void) mjs;\n  if (!mjs_is_foreign(v)) {\n    return NULL;\n  }\n  return get_ptr(v);\n}\n\nmjs_val_t mjs_mk_foreign(struct mjs *mjs, void *p) {\n  (void) mjs;\n  return mjs_pointer_to_value(mjs, p) | MJS_TAG_FOREIGN;\n}\n\nmjs_val_t mjs_mk_foreign_func(struct mjs *mjs, mjs_func_ptr_t fn) {\n  union {\n    mjs_func_ptr_t fn;\n    void *p;\n  } u;\n  u.fn = fn;\n  (void) mjs;\n  return mjs_pointer_to_value(mjs, u.p) | MJS_TAG_FOREIGN;\n}\n\nint mjs_is_foreign(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FOREIGN;\n}\n\nmjs_val_t mjs_mk_function(struct mjs *mjs, size_t off) {\n  (void) mjs;\n  return (mjs_val_t) off | MJS_TAG_FUNCTION;\n}\n\nint mjs_is_function(mjs_val_t v) {\n  return (v & MJS_TAG_MASK) == MJS_TAG_FUNCTION;\n}\n\nMJS_PRIVATE void mjs_op_isnan(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t val = mjs_arg(mjs, 0);\n\n  ret = mjs_mk_boolean(mjs, val == MJS_TAG_NAN);\n\n  mjs_return(mjs, ret);\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_string.c\"\n#endif\n\n/* Amalgamated: #include \"mjs_string.h\" */\n#include \"common/cs_varint.h\"\n#include \"common/mg_str.h\"\n/* Amalgamated: #include \"mjs_conversion.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n\n// No UTF\ntypedef unsigned short Rune;\nstatic int chartorune(Rune *rune, const char *str) {\n  *rune = *(unsigned char *) str;\n  return 1;\n}\nstatic int runetochar(char *str, Rune *rune) {\n  str[0] = (char) *rune;\n  return 1;\n}\n\n#ifndef MJS_STRING_BUF_RESERVE\n#define MJS_STRING_BUF_RESERVE 100\n#endif\n\nMJS_PRIVATE size_t unescape(const char *s, size_t len, char *to);\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags);\n\n/* TODO(lsm): NaN payload location depends on endianness, make crossplatform */\n#define GET_VAL_NAN_PAYLOAD(v) ((char *) &(v))\n\nint mjs_is_string(mjs_val_t v) {\n  uint64_t t = v & MJS_TAG_MASK;\n  return t == MJS_TAG_STRING_I || t == MJS_TAG_STRING_F ||\n         t == MJS_TAG_STRING_O || t == MJS_TAG_STRING_5 ||\n         t == MJS_TAG_STRING_D;\n}\n\nmjs_val_t mjs_mk_string(struct mjs *mjs, const char *p, size_t len, int copy) {\n  struct mbuf *m;\n  mjs_val_t offset, tag = MJS_TAG_STRING_F;\n  if (len == 0) {\n    /*\n     * Zero length for foreign string has a special meaning (that the foreign\n     * string is not inlined into mjs_val_t), so when creating a zero-length\n     * string, we always assume it'll be owned. Since the length is zero, it\n     * doesn't matter anyway.\n     */\n    copy = 1;\n  }\n  m = copy ? &mjs->owned_strings : &mjs->foreign_strings;\n  offset = m->len;\n\n  if (len == ~((size_t) 0)) len = strlen(p);\n\n  if (copy) {\n    /* owned string */\n    if (len <= 4) {\n      char *s = GET_VAL_NAN_PAYLOAD(offset) + 1;\n      offset = 0;\n      if (p != 0) {\n        memcpy(s, p, len);\n      }\n      s[-1] = len;\n      tag = MJS_TAG_STRING_I;\n    } else if (len == 5) {\n      char *s = GET_VAL_NAN_PAYLOAD(offset);\n      offset = 0;\n      if (p != 0) {\n        memcpy(s, p, len);\n      }\n      tag = MJS_TAG_STRING_5;\n      // } else if ((dict_index = v_find_string_in_dictionary(p, len)) >= 0) {\n      //   offset = 0;\n      //   GET_VAL_NAN_PAYLOAD(offset)[0] = dict_index;\n      //   tag = MJS_TAG_STRING_D;\n    } else {\n      if (gc_strings_is_gc_needed(mjs)) {\n        mjs->need_gc = 1;\n      }\n\n      /*\n       * Before embedding new string, check if the reallocation is needed.  If\n       * so, perform the reallocation by calling `mbuf_resize` manually, since\n       * we need to preallocate some extra space (`MJS_STRING_BUF_RESERVE`)\n       */\n      if ((m->len + len) > m->size) {\n        char *prev_buf = m->buf;\n        mbuf_resize(m, m->len + len + MJS_STRING_BUF_RESERVE);\n\n        /*\n         * There is a corner case: when the source pointer is located within\n         * the mbuf. In this case, we should adjust the pointer, because it\n         * might have just been reallocated.\n         */\n        if (p >= prev_buf && p < (prev_buf + m->len)) {\n          p += (m->buf - prev_buf);\n        }\n      }\n\n      embed_string(m, m->len, p, len, EMBSTR_ZERO_TERM);\n      tag = MJS_TAG_STRING_O;\n    }\n  } else {\n    /* foreign string */\n    if (sizeof(void *) <= 4 && len <= (1 << 15)) {\n      /* small foreign strings can fit length and ptr in the mjs_val_t */\n      offset = (uint64_t) len << 32 | (uint64_t)(uintptr_t) p;\n    } else {\n      /* bigger strings need indirection that uses ram */\n      size_t pos = m->len;\n      size_t llen = cs_varint_llen(len);\n\n      /* allocate space for len and ptr */\n      mbuf_insert(m, pos, NULL, llen + sizeof(p));\n\n      cs_varint_encode(len, (uint8_t *) (m->buf + pos), llen);\n      memcpy(m->buf + pos + llen, &p, sizeof(p));\n    }\n    tag = MJS_TAG_STRING_F;\n  }\n\n  /* NOTE(lsm): don't use pointer_to_value, 32-bit ptrs will truncate */\n  return (offset & ~MJS_TAG_MASK) | tag;\n}\n\n/* Get a pointer to string and string length. */\nconst char *mjs_get_string(struct mjs *mjs, mjs_val_t *v, size_t *sizep) {\n  uint64_t tag = v[0] & MJS_TAG_MASK;\n  const char *p = NULL;\n  size_t size = 0, llen;\n\n  if (!mjs_is_string(*v)) {\n    goto clean;\n  }\n\n  if (tag == MJS_TAG_STRING_I) {\n    p = GET_VAL_NAN_PAYLOAD(*v) + 1;\n    size = p[-1];\n  } else if (tag == MJS_TAG_STRING_5) {\n    p = GET_VAL_NAN_PAYLOAD(*v);\n    size = 5;\n    // } else if (tag == MJS_TAG_STRING_D) {\n    //   int index = ((unsigned char *) GET_VAL_NAN_PAYLOAD(*v))[0];\n    //   size = v_dictionary_strings[index].len;\n    //   p = v_dictionary_strings[index].p;\n  } else if (tag == MJS_TAG_STRING_O) {\n    size_t offset = (size_t) gc_string_mjs_val_to_offset(*v);\n    char *s = mjs->owned_strings.buf + offset;\n    uint64_t v = 0;\n    if (offset < mjs->owned_strings.len &&\n        cs_varint_decode((uint8_t *) s, mjs->owned_strings.len - offset, &v,\n                         &llen)) {\n      size = v;\n      p = s + llen;\n    } else {\n      goto clean;\n    }\n  } else if (tag == MJS_TAG_STRING_F) {\n    /*\n     * short foreign strings on <=32-bit machines can be encoded in a compact\n     * form:\n     *\n     *     7         6        5        4        3        2        1        0\n     *  11111111|1111tttt|llllllll|llllllll|ssssssss|ssssssss|ssssssss|ssssssss\n     *\n     * Strings longer than 2^26 will be indireceted through the foreign_strings\n     * mbuf.\n     *\n     * We don't use a different tag to represent those two cases. Instead, all\n     * foreign strings represented with the help of the foreign_strings mbuf\n     * will have the upper 16-bits of the payload set to zero. This allows us to\n     * represent up to 477 million foreign strings longer than 64k.\n     */\n    uint16_t len = (*v >> 32) & 0xFFFF;\n    if (sizeof(void *) <= 4 && len != 0) {\n      size = (size_t) len;\n      p = (const char *) (uintptr_t) *v;\n    } else {\n      size_t offset = (size_t) gc_string_mjs_val_to_offset(*v);\n      char *s = mjs->foreign_strings.buf + offset;\n      uint64_t v = 0;\n      if (offset < mjs->foreign_strings.len &&\n          cs_varint_decode((uint8_t *) s, mjs->foreign_strings.len - offset, &v,\n                           &llen)) {\n        size = v;\n        memcpy((char **) &p, s + llen, sizeof(p));\n      } else {\n        goto clean;\n      }\n    }\n  } else {\n    assert(0);\n  }\n\nclean:\n  if (sizep != NULL) {\n    *sizep = size;\n  }\n  return p;\n}\n\nconst char *mjs_get_cstring(struct mjs *mjs, mjs_val_t *value) {\n  size_t size;\n  const char *s = mjs_get_string(mjs, value, &size);\n  if (s == NULL) return NULL;\n  if (s[size] != 0 || strlen(s) != size) {\n    return NULL;\n  }\n  return s;\n}\n\nint mjs_strcmp(struct mjs *mjs, mjs_val_t *a, const char *b, size_t len) {\n  size_t n;\n  const char *s;\n  if (len == (size_t) ~0) len = strlen(b);\n  s = mjs_get_string(mjs, a, &n);\n  if (n != len) {\n    return n - len;\n  }\n  return strncmp(s, b, len);\n}\n\nMJS_PRIVATE unsigned long cstr_to_ulong(const char *s, size_t len, int *ok) {\n  char *e;\n  unsigned long res = strtoul(s, &e, 10);\n  *ok = (e == s + len) && len != 0;\n  return res;\n}\n\nMJS_PRIVATE mjs_err_t\nstr_to_ulong(struct mjs *mjs, mjs_val_t v, int *ok, unsigned long *res) {\n  enum mjs_err ret = MJS_OK;\n  size_t len = 0;\n  const char *p = mjs_get_string(mjs, &v, &len);\n  *res = cstr_to_ulong(p, len, ok);\n\n  return ret;\n}\n\nMJS_PRIVATE int s_cmp(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  size_t a_len, b_len;\n  const char *a_ptr, *b_ptr;\n\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  if (a_len == b_len) {\n    return memcmp(a_ptr, b_ptr, a_len);\n  }\n  if (a_len > b_len) {\n    return 1;\n  } else if (a_len < b_len) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nMJS_PRIVATE mjs_val_t s_concat(struct mjs *mjs, mjs_val_t a, mjs_val_t b) {\n  size_t a_len, b_len, res_len;\n  const char *a_ptr, *b_ptr, *res_ptr;\n  mjs_val_t res;\n\n  /* Find out lengths of both srtings */\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  /* Create a placeholder string */\n  res = mjs_mk_string(mjs, NULL, a_len + b_len, 1);\n\n  /* mjs_mk_string() may have reallocated mbuf - revalidate pointers */\n  a_ptr = mjs_get_string(mjs, &a, &a_len);\n  b_ptr = mjs_get_string(mjs, &b, &b_len);\n\n  /* Copy strings into the placeholder */\n  res_ptr = mjs_get_string(mjs, &res, &res_len);\n  memcpy((char *) res_ptr, a_ptr, a_len);\n  memcpy((char *) res_ptr + a_len, b_ptr, b_len);\n\n  return res;\n}\n\nMJS_PRIVATE void mjs_string_slice(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_val_t ret = mjs_mk_number(mjs, 0);\n  mjs_val_t beginSlice_v = MJS_UNDEFINED;\n  mjs_val_t endSlice_v = MJS_UNDEFINED;\n  int beginSlice = 0;\n  int endSlice = 0;\n  size_t size;\n  const char *s = NULL;\n\n  /* get string from `this` */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  s = mjs_get_string(mjs, &mjs->vals.this_obj, &size);\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"beginSlice\", MJS_TYPE_NUMBER, &beginSlice_v)) {\n    goto clean;\n  }\n  beginSlice = mjs_normalize_idx(mjs_get_int(mjs, beginSlice_v), size);\n\n  if (nargs >= 2) {\n    /* endSlice is given; use it */\n    /* get idx from arg 0 */\n    if (!mjs_check_arg(mjs, 1, \"endSlice\", MJS_TYPE_NUMBER, &endSlice_v)) {\n      goto clean;\n    }\n    endSlice = mjs_normalize_idx(mjs_get_int(mjs, endSlice_v), size);\n  } else {\n    /* endSlice is not given; assume the end of the string */\n    endSlice = size;\n  }\n\n  if (endSlice < beginSlice) {\n    endSlice = beginSlice;\n  }\n\n  ret = mjs_mk_string(mjs, s + beginSlice, endSlice - beginSlice, 1);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_string_index_of(struct mjs *mjs) {\n  mjs_val_t ret = mjs_mk_number(mjs, -1);\n  mjs_val_t substr_v = MJS_UNDEFINED;\n  mjs_val_t idx_v = MJS_UNDEFINED;\n  int idx = 0;\n  const char *str = NULL, *substr = NULL;\n  size_t str_len = 0, substr_len = 0;\n\n  if (!mjs_check_arg(mjs, -1 /* this */, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  str = mjs_get_string(mjs, &mjs->vals.this_obj, &str_len);\n\n  if (!mjs_check_arg(mjs, 0, \"searchValue\", MJS_TYPE_STRING, &substr_v)) {\n    goto clean;\n  }\n  substr = mjs_get_string(mjs, &substr_v, &substr_len);\n  if (mjs_nargs(mjs) > 1) {\n    if (!mjs_check_arg(mjs, 1, \"fromIndex\", MJS_TYPE_NUMBER, &idx_v)) {\n      goto clean;\n    }\n    idx = mjs_get_int(mjs, idx_v);\n    if (idx < 0) idx = 0;\n    if ((size_t) idx > str_len) idx = str_len;\n  }\n  {\n    const char *substr_p;\n    struct mg_str mgstr, mgsubstr;\n    mgstr.p = str + idx;\n    mgstr.len = str_len - idx;\n    mgsubstr.p = substr;\n    mgsubstr.len = substr_len;\n    substr_p = mg_strstr(mgstr, mgsubstr);\n    if (substr_p != NULL) {\n      ret = mjs_mk_number(mjs, (int) (substr_p - str));\n    }\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_string_char_code_at(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t idx_v = MJS_UNDEFINED;\n  int idx = 0;\n  size_t size;\n  const char *s = NULL;\n\n  /* get string from `this` */\n  if (!mjs_check_arg(mjs, -1 /*this*/, \"this\", MJS_TYPE_STRING, NULL)) {\n    goto clean;\n  }\n  s = mjs_get_string(mjs, &mjs->vals.this_obj, &size);\n\n  /* get idx from arg 0 */\n  if (!mjs_check_arg(mjs, 0, \"index\", MJS_TYPE_NUMBER, &idx_v)) {\n    goto clean;\n  }\n  idx = mjs_normalize_idx(mjs_get_int(mjs, idx_v), size);\n  if (idx >= 0 && idx < (int) size) {\n    ret = mjs_mk_number(mjs, ((unsigned char *) s)[idx]);\n  }\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nMJS_PRIVATE void mjs_mkstr(struct mjs *mjs) {\n  int nargs = mjs_nargs(mjs);\n  mjs_val_t ret = MJS_UNDEFINED;\n\n  char *ptr = NULL;\n  int offset = 0;\n  int len = 0;\n  int copy = 0;\n\n  mjs_val_t ptr_v = MJS_UNDEFINED;\n  mjs_val_t offset_v = MJS_UNDEFINED;\n  mjs_val_t len_v = MJS_UNDEFINED;\n  mjs_val_t copy_v = MJS_UNDEFINED;\n\n  if (nargs == 2) {\n    ptr_v = mjs_arg(mjs, 0);\n    len_v = mjs_arg(mjs, 1);\n  } else if (nargs == 3) {\n    ptr_v = mjs_arg(mjs, 0);\n    offset_v = mjs_arg(mjs, 1);\n    len_v = mjs_arg(mjs, 2);\n  } else if (nargs == 4) {\n    ptr_v = mjs_arg(mjs, 0);\n    offset_v = mjs_arg(mjs, 1);\n    len_v = mjs_arg(mjs, 2);\n    copy_v = mjs_arg(mjs, 3);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                       \"mkstr takes 2, 3 or 4 arguments: (ptr, len), (ptr, \"\n                       \"offset, len) or (ptr, offset, len, copy)\");\n    goto clean;\n  }\n\n  if (!mjs_is_foreign(ptr_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"ptr should be a foreign pointer\");\n    goto clean;\n  }\n\n  if (offset_v != MJS_UNDEFINED && !mjs_is_number(offset_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"offset should be a number\");\n    goto clean;\n  }\n\n  if (!mjs_is_number(len_v)) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"len should be a number\");\n    goto clean;\n  }\n\n  copy = mjs_is_truthy(mjs, copy_v);\n\n  /* all arguments are fine */\n\n  ptr = (char *) mjs_get_ptr(mjs, ptr_v);\n  if (offset_v != MJS_UNDEFINED) {\n    offset = mjs_get_int(mjs, offset_v);\n  }\n  len = mjs_get_int(mjs, len_v);\n\n  ret = mjs_mk_string(mjs, ptr + offset, len, copy);\n\nclean:\n  mjs_return(mjs, ret);\n}\n\nenum unescape_error {\n  SLRE_INVALID_HEX_DIGIT,\n  SLRE_INVALID_ESC_CHAR,\n  SLRE_UNTERM_ESC_SEQ,\n};\n\nstatic int hex(int c) {\n  if (c >= '0' && c <= '9') return c - '0';\n  if (c >= 'a' && c <= 'f') return c - 'a' + 10;\n  if (c >= 'A' && c <= 'F') return c - 'A' + 10;\n  return -SLRE_INVALID_HEX_DIGIT;\n}\n\nstatic int nextesc(const char **p) {\n  const unsigned char *s = (unsigned char *) (*p)++;\n  switch (*s) {\n    case 0:\n      return -SLRE_UNTERM_ESC_SEQ;\n    case 'c':\n      ++*p;\n      return *s & 31;\n    case 'b':\n      return '\\b';\n    case 't':\n      return '\\t';\n    case 'n':\n      return '\\n';\n    case 'v':\n      return '\\v';\n    case 'f':\n      return '\\f';\n    case 'r':\n      return '\\r';\n    case '\\\\':\n      return '\\\\';\n    case 'u':\n      if (isxdigit(s[1]) && isxdigit(s[2]) && isxdigit(s[3]) &&\n          isxdigit(s[4])) {\n        (*p) += 4;\n        return hex(s[1]) << 12 | hex(s[2]) << 8 | hex(s[3]) << 4 | hex(s[4]);\n      }\n      return -SLRE_INVALID_HEX_DIGIT;\n    case 'x':\n      if (isxdigit(s[1]) && isxdigit(s[2])) {\n        (*p) += 2;\n        return (hex(s[1]) << 4) | hex(s[2]);\n      }\n      return -SLRE_INVALID_HEX_DIGIT;\n    default:\n      return -SLRE_INVALID_ESC_CHAR;\n  }\n}\n\nMJS_PRIVATE size_t unescape(const char *s, size_t len, char *to) {\n  const char *end = s + len;\n  size_t n = 0;\n  char tmp[4];\n  Rune r;\n\n  while (s < end) {\n    s += chartorune(&r, s);\n    if (r == '\\\\' && s < end) {\n      switch (*s) {\n        case '\"':\n          s++, r = '\"';\n          break;\n        case '\\'':\n          s++, r = '\\'';\n          break;\n        case '\\n':\n          s++, r = '\\n';\n          break;\n        default: {\n          const char *tmp_s = s;\n          int i = nextesc(&s);\n          switch (i) {\n            case -SLRE_INVALID_ESC_CHAR:\n              r = '\\\\';\n              s = tmp_s;\n              n += runetochar(to == NULL ? tmp : to + n, &r);\n              s += chartorune(&r, s);\n              break;\n            case -SLRE_INVALID_HEX_DIGIT:\n            default:\n              r = i;\n          }\n        }\n      }\n    }\n    n += runetochar(to == NULL ? tmp : to + n, &r);\n  }\n\n  return n;\n}\n\nMJS_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,\n                              size_t len, uint8_t /*enum embstr_flags*/ flags) {\n  char *old_base = m->buf;\n  uint8_t p_backed_by_mbuf = p >= old_base && p < old_base + m->len;\n  size_t n = (flags & EMBSTR_UNESCAPE) ? unescape(p, len, NULL) : len;\n\n  /* Calculate how many bytes length takes */\n  size_t k = cs_varint_llen(n);\n\n  /* total length: varing length + string len + zero-term */\n  size_t tot_len = k + n + !!(flags & EMBSTR_ZERO_TERM);\n\n  /* Allocate buffer */\n  mbuf_insert(m, offset, NULL, tot_len);\n\n  /* Fixup p if it was relocated by mbuf_insert() above */\n  if (p_backed_by_mbuf) {\n    p += m->buf - old_base;\n  }\n\n  /* Write length */\n  cs_varint_encode(n, (unsigned char *) m->buf + offset, k);\n\n  /* Write string */\n  if (p != 0) {\n    if (flags & EMBSTR_UNESCAPE) {\n      unescape(p, len, m->buf + offset + k);\n    } else {\n      memcpy(m->buf + offset + k, p, len);\n    }\n  }\n\n  /* add NULL-terminator if needed */\n  if (flags & EMBSTR_ZERO_TERM) {\n    m->buf[offset + tot_len - 1] = '\\0';\n  }\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_tok.c\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"common/cs_dbg.h\"\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nMJS_PRIVATE void pinit(const char *file_name, const char *buf,\n                       struct pstate *p) {\n  memset(p, 0, sizeof(*p));\n  p->line_no = 1;\n  p->last_emitted_line_no = 1;\n  p->file_name = file_name;\n  p->buf = p->pos = buf;\n  mbuf_init(&p->offset_lineno_map, 0);\n}\n\n// We're not relying on the target libc ctype, as it may incorrectly\n// handle negative arguments, e.g. isspace(-1).\nstatic int mjs_is_space(int c) {\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t' || c == '\\f' ||\n         c == '\\v';\n}\n\nMJS_PRIVATE int mjs_is_digit(int c) {\n  return c >= '0' && c <= '9';\n}\n\nstatic int mjs_is_alpha(int c) {\n  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nMJS_PRIVATE int mjs_is_ident(int c) {\n  return c == '_' || c == '$' || mjs_is_alpha(c);\n}\n\n// Try to parse a token that can take one or two chars.\nstatic int longtok(struct pstate *p, const char *first_chars,\n                   const char *second_chars) {\n  if (strchr(first_chars, p->pos[0]) == NULL) return TOK_EOF;\n  if (p->pos[1] != '\\0' && strchr(second_chars, p->pos[1]) != NULL) {\n    p->tok.len++;\n    p->pos++;\n    return p->pos[-1] << 8 | p->pos[0];\n  }\n  return p->pos[0];\n}\n\n// Try to parse a token that takes exactly 3 chars.\nstatic int longtok3(struct pstate *p, char a, char b, char c) {\n  if (p->pos[0] == a && p->pos[1] == b && p->pos[2] == c) {\n    p->tok.len += 2;\n    p->pos += 2;\n    return p->pos[-2] << 16 | p->pos[-1] << 8 | p->pos[0];\n  }\n  return TOK_EOF;\n}\n\n// Try to parse a token that takes exactly 4 chars.\nstatic int longtok4(struct pstate *p, char a, char b, char c, char d) {\n  if (p->pos[0] == a && p->pos[1] == b && p->pos[2] == c && p->pos[3] == d) {\n    p->tok.len += 3;\n    p->pos += 3;\n    return p->pos[-3] << 24 | p->pos[-2] << 16 | p->pos[-1] << 8 | p->pos[0];\n  }\n  return TOK_EOF;\n}\n\nstatic int getnum(struct pstate *p) {\n  if (p->pos[0] == '0' && p->pos[1] == 'x') {\n    // MSVC6 strtod cannot parse 0x... numbers, thus this ugly workaround.\n    strtoul(p->pos + 2, (char **) &p->pos, 16);\n  } else {\n    strtod(p->pos, (char **) &p->pos);\n  }\n  p->tok.len = p->pos - p->tok.ptr;\n  p->pos--;\n  return TOK_NUM;\n}\n\nstatic int is_reserved_word_token(const char *s, int len) {\n  const char *reserved[] = {\n      \"break\",     \"case\",   \"catch\", \"continue\",   \"debugger\", \"default\",\n      \"delete\",    \"do\",     \"else\",  \"false\",      \"finally\",  \"for\",\n      \"function\",  \"if\",     \"in\",    \"instanceof\", \"new\",      \"null\",\n      \"return\",    \"switch\", \"this\",  \"throw\",      \"true\",     \"try\",\n      \"typeof\",    \"var\",    \"void\",  \"while\",      \"with\",     \"let\",\n      \"undefined\", NULL};\n  int i;\n  if (!mjs_is_alpha(s[0])) return 0;\n  for (i = 0; reserved[i] != NULL; i++) {\n    if (len == (int) strlen(reserved[i]) && strncmp(s, reserved[i], len) == 0)\n      return i + 1;\n  }\n  return 0;\n}\n\nstatic int getident(struct pstate *p) {\n  while (mjs_is_ident(p->pos[0]) || mjs_is_digit(p->pos[0])) p->pos++;\n  p->tok.len = p->pos - p->tok.ptr;\n  p->pos--;\n  return TOK_IDENT;\n}\n\nstatic int getstr(struct pstate *p) {\n  int quote = *p->pos++;\n  p->tok.ptr++;\n  while (p->pos[0] != '\\0' && p->pos[0] != quote) {\n    if (p->pos[0] == '\\\\' && p->pos[1] != '\\0' &&\n        (p->pos[1] == quote || strchr(\"bfnrtv\\\\\", p->pos[1]) != NULL)) {\n      p->pos += 2;\n    } else {\n      p->pos++;\n    }\n  }\n  p->tok.len = p->pos - p->tok.ptr;\n  return TOK_STR;\n}\n\nstatic void skip_spaces_and_comments(struct pstate *p) {\n  const char *pos;\n  do {\n    pos = p->pos;\n    while (mjs_is_space(p->pos[0])) {\n      if (p->pos[0] == '\\n') p->line_no++;\n      p->pos++;\n    }\n    if (p->pos[0] == '/' && p->pos[1] == '/') {\n      while (p->pos[0] != '\\0' && p->pos[0] != '\\n') p->pos++;\n    }\n    if (p->pos[0] == '/' && p->pos[1] == '*') {\n      p->pos += 2;\n      while (p->pos[0] != '\\0') {\n        if (p->pos[0] == '\\n') p->line_no++;\n        if (p->pos[0] == '*' && p->pos[1] == '/') {\n          p->pos += 2;\n          break;\n        }\n        p->pos++;\n      }\n    }\n  } while (pos < p->pos);\n}\n\nstatic int ptranslate(int tok) {\n#define DT(a, b) ((a) << 8 | (b))\n#define TT(a, b, c) ((a) << 16 | (b) << 8 | (c))\n#define QT(a, b, c, d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))\n  /* Map token ID produced by mjs_tok.c to token ID produced by lemon */\n  /* clang-format off */\n  switch (tok) {\n    case ':': return TOK_COLON;\n    case ';': return TOK_SEMICOLON;\n    case ',': return TOK_COMMA;\n    case '=': return TOK_ASSIGN;\n    case '{': return TOK_OPEN_CURLY;\n    case '}': return TOK_CLOSE_CURLY;\n    case '(': return TOK_OPEN_PAREN;\n    case ')': return TOK_CLOSE_PAREN;\n    case '[': return TOK_OPEN_BRACKET;\n    case ']': return TOK_CLOSE_BRACKET;\n    case '*': return TOK_MUL;\n    case '+': return TOK_PLUS;\n    case '-': return TOK_MINUS;\n    case '/': return TOK_DIV;\n    case '%': return TOK_REM;\n    case '&': return TOK_AND;\n    case '|': return TOK_OR;\n    case '^': return TOK_XOR;\n    case '.': return TOK_DOT;\n    case '?': return TOK_QUESTION;\n    case '!': return TOK_NOT;\n    case '~': return TOK_TILDA;\n    case '<': return TOK_LT;\n    case '>': return TOK_GT;\n    case DT('<','<'): return TOK_LSHIFT;\n    case DT('>','>'): return TOK_RSHIFT;\n    case DT('-','-'): return TOK_MINUS_MINUS;\n    case DT('+','+'): return TOK_PLUS_PLUS;\n    case DT('+','='): return TOK_PLUS_ASSIGN;\n    case DT('-','='): return TOK_MINUS_ASSIGN;\n    case DT('*','='): return TOK_MUL_ASSIGN;\n    case DT('/','='): return TOK_DIV_ASSIGN;\n    case DT('&','='): return TOK_AND_ASSIGN;\n    case DT('|','='): return TOK_OR_ASSIGN;\n    case DT('%','='): return TOK_REM_ASSIGN;\n    case DT('^','='): return TOK_XOR_ASSIGN;\n    case DT('=','='): return TOK_EQ;\n    case DT('!','='): return TOK_NE;\n    case DT('<','='): return TOK_LE;\n    case DT('>','='): return TOK_GE;\n    case DT('&','&'): return TOK_LOGICAL_AND;\n    case DT('|','|'): return TOK_LOGICAL_OR;\n    case TT('=','=','='): return TOK_EQ_EQ;\n    case TT('!','=','='): return TOK_NE_NE;\n    case TT('<','<','='): return TOK_LSHIFT_ASSIGN;\n    case TT('>','>','='): return TOK_RSHIFT_ASSIGN;\n    case TT('>','>','>'): return TOK_URSHIFT;\n    case QT('>','>','>','='): return TOK_URSHIFT_ASSIGN;\n  }\n  /* clang-format on */\n  return tok;\n}\n\nMJS_PRIVATE int pnext(struct pstate *p) {\n  int tmp, tok = TOK_INVALID;\n\n  skip_spaces_and_comments(p);\n  p->tok.ptr = p->pos;\n  p->tok.len = 1;\n\n  if (p->pos[0] == '\\0') {\n    tok = TOK_EOF;\n  } else if (mjs_is_digit(p->pos[0])) {\n    tok = getnum(p);\n  } else if (p->pos[0] == '\\'' || p->pos[0] == '\"') {\n    tok = getstr(p);\n  } else if (mjs_is_ident(p->pos[0])) {\n    tok = getident(p);\n    /*\n     * NOTE: getident() has side effects on `p`, and `is_reserved_word_token()`\n     * relies on them. Since in C the order of evaluation of the operands is\n     * undefined, `is_reserved_word_token()` should be called in a separate\n     * statement.\n     */\n    tok += is_reserved_word_token(p->tok.ptr, p->tok.len);\n  } else if (strchr(\",.:;{}[]()?\", p->pos[0]) != NULL) {\n    tok = p->pos[0];\n  } else if ((tmp = longtok3(p, '<', '<', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '>', '>', '=')) != TOK_EOF ||\n             (tmp = longtok4(p, '>', '>', '>', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '>', '>', '>')) != TOK_EOF ||\n             (tmp = longtok3(p, '=', '=', '=')) != TOK_EOF ||\n             (tmp = longtok3(p, '!', '=', '=')) != TOK_EOF ||\n             (tmp = longtok(p, \"&\", \"&=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"|\", \"|=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"<\", \"<=\")) != TOK_EOF ||\n             (tmp = longtok(p, \">\", \">=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"-\", \"-=\")) != TOK_EOF ||\n             (tmp = longtok(p, \"+\", \"+=\")) != TOK_EOF) {\n    tok = tmp;\n  } else if ((tmp = longtok(p, \"^~+-%/*<>=!|&\", \"=\")) != TOK_EOF) {\n    tok = tmp;\n  }\n  if (p->pos[0] != '\\0') p->pos++;\n  LOG(LL_VERBOSE_DEBUG, (\"  --> %d [%.*s]\", tok, p->tok.len, p->tok.ptr));\n  p->prev_tok = p->tok.tok;\n  p->tok.tok = ptranslate(tok);\n  return p->tok.tok;\n}\n#ifdef MJS_MODULE_LINES\n#line 1 \"src/mjs_util.c\"\n#endif\n\n#include \"common/cs_varint.h\"\n#include \"frozen.h\"\n/* Amalgamated: #include \"mjs_array.h\" */\n/* Amalgamated: #include \"mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs_core.h\" */\n/* Amalgamated: #include \"mjs_internal.h\" */\n/* Amalgamated: #include \"mjs_object.h\" */\n/* Amalgamated: #include \"mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs_string.h\" */\n/* Amalgamated: #include \"mjs_util.h\" */\n/* Amalgamated: #include \"mjs_tok.h\" */\n\nconst char *mjs_typeof(mjs_val_t v) {\n  return mjs_stringify_type(mjs_get_type(v));\n}\n\nMJS_PRIVATE const char *mjs_stringify_type(enum mjs_type t) {\n  switch (t) {\n    case MJS_TYPE_NUMBER:\n      return \"number\";\n    case MJS_TYPE_BOOLEAN:\n      return \"boolean\";\n    case MJS_TYPE_STRING:\n      return \"string\";\n    case MJS_TYPE_OBJECT_ARRAY:\n      return \"array\";\n    case MJS_TYPE_OBJECT_GENERIC:\n      return \"object\";\n    case MJS_TYPE_FOREIGN:\n      return \"foreign_ptr\";\n    case MJS_TYPE_OBJECT_FUNCTION:\n      return \"function\";\n    case MJS_TYPE_NULL:\n      return \"null\";\n    case MJS_TYPE_UNDEFINED:\n      return \"undefined\";\n    default:\n      return \"???\";\n  }\n}\n\nvoid mjs_jprintf(mjs_val_t v, struct mjs *mjs, struct json_out *out) {\n  if (mjs_is_number(v)) {\n    double iv, d = mjs_get_double(mjs, v);\n    if (modf(d, &iv) == 0) {\n      json_printf(out, \"%\" INT64_FMT, (int64_t) d);\n    } else {\n      json_printf(out, \"%f\", mjs_get_double(mjs, v));\n    }\n  } else if (mjs_is_boolean(v)) {\n    json_printf(out, \"%s\", mjs_get_bool(mjs, v) ? \"true\" : \"false\");\n  } else if (mjs_is_string(v)) {\n    size_t i, size;\n    const char *s = mjs_get_string(mjs, &v, &size);\n    for (i = 0; i < size; i++) {\n      int ch = ((unsigned char *) s)[i];\n      if (isprint(ch)) {\n        json_printf(out, \"%c\", ch);\n      } else {\n        json_printf(out, \"%s%02x\", \"\\\\x\", ch);\n      }\n    }\n  } else if (mjs_is_array(v)) {\n    json_printf(out, \"%s\", \"<array>\");\n  } else if (mjs_is_object(v)) {\n    json_printf(out, \"%s\", \"<object>\");\n  } else if (mjs_is_foreign(v)) {\n    json_printf(out, \"%s%lx%s\", \"<foreign_ptr@\",\n                (unsigned long) (uintptr_t) mjs_get_ptr(mjs, v), \">\");\n  } else if (mjs_is_function(v)) {\n    json_printf(out, \"%s%d%s\", \"<function@\", (int) mjs_get_func_addr(v), \">\");\n  } else if (mjs_is_null(v)) {\n    json_printf(out, \"%s\", \"null\");\n  } else if (mjs_is_undefined(v)) {\n    json_printf(out, \"%s\", \"undefined\");\n  } else {\n    json_printf(out, \"%s%\" INT64_FMT \"%s\", \"<???\", (int64_t) v, \">\");\n  }\n}\n\nvoid mjs_sprintf(mjs_val_t v, struct mjs *mjs, char *buf, size_t n) {\n  struct json_out out = JSON_OUT_BUF(buf, n);\n  mjs_jprintf(v, mjs, &out);\n}\n\nvoid mjs_fprintf(mjs_val_t v, struct mjs *mjs, FILE *fp) {\n  struct json_out out = JSON_OUT_FILE(fp);\n  mjs_jprintf(v, mjs, &out);\n}\n\nMJS_PRIVATE const char *opcodetostr(uint8_t opcode) {\n  static const char *names[] = {\n      \"NOP\", \"DROP\", \"DUP\", \"SWAP\", \"JMP\", \"JMP_TRUE\", \"JMP_NEUTRAL_TRUE\",\n      \"JMP_FALSE\", \"JMP_NEUTRAL_FALSE\", \"FIND_SCOPE\", \"PUSH_SCOPE\", \"PUSH_STR\",\n      \"PUSH_TRUE\", \"PUSH_FALSE\", \"PUSH_INT\", \"PUSH_DBL\", \"PUSH_NULL\",\n      \"PUSH_UNDEF\", \"PUSH_OBJ\", \"PUSH_ARRAY\", \"PUSH_FUNC\", \"PUSH_THIS\", \"GET\",\n      \"CREATE\", \"EXPR\", \"APPEND\", \"SET_ARG\", \"NEW_SCOPE\", \"DEL_SCOPE\", \"CALL\",\n      \"RETURN\", \"LOOP\", \"BREAK\", \"CONTINUE\", \"SETRETVAL\", \"EXIT\", \"BCODE_HDR\",\n      \"ARGS\", \"FOR_IN_NEXT\",\n  };\n  const char *name = \"???\";\n  assert(ARRAY_SIZE(names) == OP_MAX);\n  if (opcode < ARRAY_SIZE(names)) name = names[opcode];\n  return name;\n}\n\nMJS_PRIVATE size_t mjs_disasm_single(const uint8_t *code, size_t i) {\n  char buf[40];\n  size_t start_i = i;\n  size_t llen;\n  uint64_t n;\n\n  snprintf(buf, sizeof(buf), \"\\t%-3u %-8s\", (unsigned) i, opcodetostr(code[i]));\n\n  switch (code[i]) {\n    case OP_PUSH_FUNC: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s %04u\", buf, (unsigned) (i - n)));\n      i += llen;\n      break;\n    }\n    case OP_PUSH_INT: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t%lu\", buf, (unsigned long) n));\n      i += llen;\n      break;\n    }\n    case OP_SET_ARG: {\n      size_t llen2;\n      uint64_t arg_no;\n      cs_varint_decode(&code[i + 1], ~0, &arg_no, &llen);\n      cs_varint_decode(&code[i + llen + 1], ~0, &n, &llen2);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%.*s] %u\", buf, (int) n,\n                             code + i + 1 + llen + llen2, (unsigned) arg_no));\n      i += llen + llen2 + n;\n      break;\n    }\n    case OP_PUSH_STR:\n    case OP_PUSH_DBL: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%.*s]\", buf, (int) n, code + i + 1 + llen));\n      i += llen + n;\n      break;\n    }\n    case OP_JMP:\n    case OP_JMP_TRUE:\n    case OP_JMP_NEUTRAL_TRUE:\n    case OP_JMP_FALSE:\n    case OP_JMP_NEUTRAL_FALSE: {\n      cs_varint_decode(&code[i + 1], ~0, &n, &llen);\n      LOG(LL_VERBOSE_DEBUG,\n          (\"%s\\t%u\", buf,\n           (unsigned) (i + n + llen +\n                       1 /* becaue i will be incremented on the usual terms */)));\n      i += llen;\n      break;\n    }\n    case OP_LOOP: {\n      size_t l1, l2;\n      uint64_t n1, n2;\n      cs_varint_decode(&code[i + 1], ~0, &n1, &l1);\n      cs_varint_decode(&code[i + l1 + 1], ~0, &n2, &l2);\n      LOG(LL_VERBOSE_DEBUG,\n          (\"%s\\tB:%lu C:%lu (%d)\", buf,\n           (unsigned long) (i + 1 /* OP_LOOP */ + l1 + n1),\n           (unsigned long) (i + 1 /* OP_LOOP */ + l1 + l2 + n2), (int) i));\n      i += l1 + l2;\n      break;\n    }\n    case OP_EXPR: {\n      int op = code[i + 1];\n      const char *name = \"???\";\n      /* clang-format off */\n      switch (op) {\n        case TOK_DOT:       name = \".\"; break;\n        case TOK_MINUS:     name = \"-\"; break;\n        case TOK_PLUS:      name = \"+\"; break;\n        case TOK_MUL:       name = \"*\"; break;\n        case TOK_DIV:       name = \"/\"; break;\n        case TOK_REM:       name = \"%\"; break;\n        case TOK_XOR:       name = \"^\"; break;\n        case TOK_AND:       name = \"&\"; break;\n        case TOK_OR:        name = \"|\"; break;\n        case TOK_LSHIFT:    name = \"<<\"; break;\n        case TOK_RSHIFT:    name = \">>\"; break;\n        case TOK_URSHIFT:   name = \">>>\"; break;\n        case TOK_UNARY_MINUS:   name = \"- (unary)\"; break;\n        case TOK_UNARY_PLUS:    name = \"+ (unary)\"; break;\n        case TOK_NOT:       name = \"!\"; break;\n        case TOK_TILDA:     name = \"~\"; break;\n        case TOK_EQ:        name = \"==\"; break;\n        case TOK_NE:        name = \"!=\"; break;\n        case TOK_EQ_EQ:     name = \"===\"; break;\n        case TOK_NE_NE:     name = \"!==\"; break;\n        case TOK_LT:        name = \"<\"; break;\n        case TOK_GT:        name = \">\"; break;\n        case TOK_LE:        name = \"<=\"; break;\n        case TOK_GE:        name = \">=\"; break;\n        case TOK_ASSIGN:    name = \"=\"; break;\n        case TOK_POSTFIX_PLUS:  name = \"++ (postfix)\"; break;\n        case TOK_POSTFIX_MINUS: name = \"-- (postfix)\"; break;\n        case TOK_MINUS_MINUS:   name = \"--\"; break;\n        case TOK_PLUS_PLUS:     name = \"++\"; break;\n        case TOK_LOGICAL_AND:   name = \"&&\"; break;\n        case TOK_LOGICAL_OR:    name = \"||\"; break;\n        case TOK_KEYWORD_TYPEOF:  name = \"typeof\"; break;\n        case TOK_PLUS_ASSIGN:     name = \"+=\"; break;\n        case TOK_MINUS_ASSIGN:    name = \"-=\"; break;\n        case TOK_MUL_ASSIGN:      name = \"*=\"; break;\n        case TOK_DIV_ASSIGN:      name = \"/=\"; break;\n        case TOK_REM_ASSIGN:      name = \"%=\"; break;\n        case TOK_XOR_ASSIGN:      name = \"^=\"; break;\n        case TOK_AND_ASSIGN:      name = \"&=\"; break;\n        case TOK_OR_ASSIGN:       name = \"|=\"; break;\n        case TOK_LSHIFT_ASSIGN:   name = \"<<=\"; break;\n        case TOK_RSHIFT_ASSIGN:   name = \">>=\"; break;\n        case TOK_URSHIFT_ASSIGN:  name = \">>>=\"; break;\n      }\n      /* clang-format on */\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t%s\", buf, name));\n      i++;\n      break;\n    }\n    case OP_BCODE_HEADER: {\n      size_t start = 0;\n      mjs_header_item_t map_offset = 0, total_size = 0;\n      start = i;\n      memcpy(&total_size, &code[i + 1], sizeof(total_size));\n      memcpy(&map_offset,\n             &code[i + 1 + MJS_HDR_ITEM_MAP_OFFSET * sizeof(total_size)],\n             sizeof(map_offset));\n      i += sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT;\n      LOG(LL_VERBOSE_DEBUG, (\"%s\\t[%s] end:%lu map_offset: %lu\", buf,\n                             &code[i + 1], (unsigned long) start + total_size,\n                             (unsigned long) start + map_offset));\n      i += strlen((char *) (code + i + 1)) + 1;\n      break;\n    }\n    default:\n      LOG(LL_VERBOSE_DEBUG, (\"%s\", buf));\n      break;\n  }\n  return i - start_i;\n}\n\nvoid mjs_disasm(const uint8_t *code, size_t len) {\n  size_t i, start = 0;\n  mjs_header_item_t map_offset = 0, total_size = 0;\n\n  for (i = 0; i < len; i++) {\n    size_t delta = mjs_disasm_single(code, i);\n    if (code[i] == OP_BCODE_HEADER) {\n      start = i;\n      memcpy(&total_size, &code[i + 1], sizeof(total_size));\n      memcpy(&map_offset,\n             &code[i + 1 + MJS_HDR_ITEM_MAP_OFFSET * sizeof(total_size)],\n             sizeof(map_offset));\n    }\n\n    i += delta;\n\n    if (map_offset > 0 && i == start + map_offset) {\n      i = start + total_size - 1;\n      continue;\n    }\n  }\n}\n\n#if MJS_ENABLE_DEBUG\n\nstatic void mjs_dump_obj_stack(const char *name, const struct mbuf *m,\n                               struct mjs *mjs) {\n  char buf[50];\n  size_t i, n;\n  n = mjs_stack_size(m);\n  LOG(LL_VERBOSE_DEBUG, (\"%12s (%d elems): \", name, (int) n));\n  for (i = 0; i < n; i++) {\n    mjs_sprintf(((mjs_val_t *) m->buf)[i], mjs, buf, sizeof(buf));\n    LOG(LL_VERBOSE_DEBUG, (\"%34s\", buf));\n  }\n}\n\nvoid mjs_dump(struct mjs *mjs, int do_disasm) {\n  LOG(LL_VERBOSE_DEBUG, (\"------- MJS VM DUMP BEGIN\"));\n  mjs_dump_obj_stack(\"DATA_STACK\", &mjs->stack, mjs);\n  mjs_dump_obj_stack(\"CALL_STACK\", &mjs->call_stack, mjs);\n  mjs_dump_obj_stack(\"SCOPES\", &mjs->scopes, mjs);\n  mjs_dump_obj_stack(\"LOOP_OFFSETS\", &mjs->loop_addresses, mjs);\n  mjs_dump_obj_stack(\"ARG_STACK\", &mjs->arg_stack, mjs);\n  if (do_disasm) {\n    int parts_cnt = mjs_bcode_parts_cnt(mjs);\n    int i;\n    LOG(LL_VERBOSE_DEBUG, (\"%23s\", \"CODE:\"));\n    for (i = 0; i < parts_cnt; i++) {\n      struct mjs_bcode_part *bp = mjs_bcode_part_get(mjs, i);\n      mjs_disasm((uint8_t *) bp->data.p, bp->data.len);\n    }\n  }\n  LOG(LL_VERBOSE_DEBUG, (\"------- MJS VM DUMP END\"));\n}\n\n#endif\n\nMJS_PRIVATE int mjs_check_arg(struct mjs *mjs, int arg_num,\n                              const char *arg_name, enum mjs_type expected_type,\n                              mjs_val_t *parg) {\n  mjs_val_t arg = MJS_UNDEFINED;\n  enum mjs_type actual_type;\n\n  if (arg_num >= 0) {\n    int nargs = mjs_nargs(mjs);\n    if (nargs < arg_num + 1) {\n      mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"missing argument %s\", arg_name);\n      return 0;\n    }\n\n    arg = mjs_arg(mjs, arg_num);\n  } else {\n    /* use `this` */\n    arg = mjs->vals.this_obj;\n  }\n\n  actual_type = mjs_get_type(arg);\n  if (actual_type != expected_type) {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"%s should be a %s, %s given\",\n                       arg_name, mjs_stringify_type(expected_type),\n                       mjs_stringify_type(actual_type));\n    return 0;\n  }\n\n  if (parg != NULL) {\n    *parg = arg;\n  }\n\n  return 1;\n}\n\nMJS_PRIVATE int mjs_normalize_idx(int idx, int size) {\n  if (idx < 0) {\n    idx = size + idx;\n    if (idx < 0) {\n      idx = 0;\n    }\n  }\n  if (idx > size) {\n    idx = size;\n  }\n  return idx;\n}\n\nMJS_PRIVATE const char *mjs_get_bcode_filename(struct mjs *mjs,\n                                               struct mjs_bcode_part *bp) {\n  (void) mjs;\n  return bp->data.p + 1 /* OP_BCODE_HEADER */ +\n         sizeof(mjs_header_item_t) * MJS_HDR_ITEMS_CNT;\n}\n\nconst char *mjs_get_bcode_filename_by_offset(struct mjs *mjs, int offset) {\n  const char *ret = NULL;\n  struct mjs_bcode_part *bp = mjs_bcode_part_get_by_offset(mjs, offset);\n  if (bp != NULL) {\n    ret = mjs_get_bcode_filename(mjs, bp);\n  }\n  return ret;\n}\n\nint mjs_get_lineno_by_offset(struct mjs *mjs, int offset) {\n  size_t llen;\n  uint64_t map_len;\n  int prev_line_no, ret = 1;\n  struct mjs_bcode_part *bp = mjs_bcode_part_get_by_offset(mjs, offset);\n  uint8_t *p, *pe;\n  if (bp != NULL) {\n    mjs_header_item_t map_offset, bcode_offset;\n    memcpy(&map_offset, bp->data.p + 1 /* OP_BCODE_HEADER */ +\n                            sizeof(mjs_header_item_t) * MJS_HDR_ITEM_MAP_OFFSET,\n           sizeof(map_offset));\n\n    memcpy(&bcode_offset,\n           bp->data.p + 1 /* OP_BCODE_HEADER */ +\n               sizeof(mjs_header_item_t) * MJS_HDR_ITEM_BCODE_OFFSET,\n           sizeof(bcode_offset));\n\n    offset -= (1 /* OP_BCODE_HEADER */ + bcode_offset) + bp->start_idx;\n\n    /* get pointer to the length of the map followed by the map itself */\n    p = (uint8_t *) bp->data.p + 1 /* OP_BCODE_HEADER */ + map_offset;\n\n    cs_varint_decode(p, ~0, &map_len, &llen);\n    p += llen;\n    pe = p + map_len;\n\n    prev_line_no = 1;\n    while (p < pe) {\n      uint64_t cur_offset, line_no;\n      cs_varint_decode(p, ~0, &cur_offset, &llen);\n      p += llen;\n      cs_varint_decode(p, ~0, &line_no, &llen);\n      p += llen;\n\n      if (cur_offset >= (uint64_t) offset) {\n        ret = prev_line_no;\n        break;\n      }\n      prev_line_no = line_no;\n    }\n  }\n  return ret;\n}\n\nint mjs_get_offset_by_call_frame_num(struct mjs *mjs, int cf_num) {\n  int ret = -1;\n  if (cf_num == 0) {\n    /* Return current bcode offset */\n    ret = mjs->cur_bcode_offset;\n  } else if (cf_num > 0 &&\n             mjs->call_stack.len >=\n                 sizeof(mjs_val_t) * CALL_STACK_FRAME_ITEMS_CNT * cf_num) {\n    /* Get offset from the call_stack */\n    int pos = CALL_STACK_FRAME_ITEM_RETURN_ADDR +\n              CALL_STACK_FRAME_ITEMS_CNT * (cf_num - 1);\n    mjs_val_t val = *vptr(&mjs->call_stack, -1 - pos);\n    ret = mjs_get_int(mjs, val);\n  }\n  return ret;\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}