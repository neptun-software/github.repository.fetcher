{
  "metadata": {
    "timestamp": 1736710082998,
    "page": 703,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hufrea/byedpi",
      "stars": 1908,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1123046875,
          "content": "\n\nroot = true\n\n# 4 space indentation\n[*.{c,h}]\nindent_style = space\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": ".vscode\nciadpi.exe\nciadpi\n*.o\ncompile_flags.txt\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2024 hufrea\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7841796875,
          "content": "TARGET = ciadpi\n\nCPPFLAGS = -D_DEFAULT_SOURCE\nCFLAGS += -I. -std=c99 -O2 -Wall -Wno-unused -Wextra -pedantic\nWIN_LDFLAGS = -lws2_32 -lmswsock\n\nHEADERS = conev.h desync.h error.h extend.h kavl.h mpool.h packets.h params.h proxy.h win_service.h\nSRC = packets.c main.c conev.c proxy.c desync.c mpool.c extend.c\nWIN_SRC = win_service.c\n\nOBJ = $(SRC:.c=.o)\nWIN_OBJ = $(WIN_SRC:.c=.o)\n\nPREFIX := /usr/local\nINSTALL_DIR := $(DESTDIR)$(PREFIX)/bin/\n\nall: $(TARGET)\n\n$(TARGET): $(OBJ)\n\t$(CC) -o $(TARGET) $(OBJ) $(LDFLAGS)\n\nwindows: $(OBJ) $(WIN_OBJ)\n\t$(CC) -o $(TARGET).exe $(OBJ) $(WIN_OBJ) $(WIN_LDFLAGS)\n\n$(OBJ): $(HEADERS)\n.c.o:\n\t$(CC) $(CPPFLAGS) $(CFLAGS) -c $<\n\nclean:\n\trm -f $(TARGET) $(TARGET).exe $(OBJ) $(WIN_OBJ)\n\ninstall: $(TARGET)\n\tmkdir -p $(INSTALL_DIR)\n\tinstall -m 755 $(TARGET) $(INSTALL_DIR)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.80859375,
          "content": "Implementation of some DPI bypass methods.\nThe program is a local SOCKS proxy server.\n\nUsage example:\n```\nciadpi --disorder 1 --auto=torst --tlsrec 1+s\nciadpi --fake -1 --ttl 8\n```\n\n------\n### Описание аргументов\n```\n-i, --ip <ip>\n    Прослушиваемый IP, по умолчанию 0.0.0.0\n\n-p, --port <num>\n    Прослушиваемый порт, по умолчанию 1080\n\n-D, --daemon\n    Запуск в режиме демона\n    Поддерживается только в Linux и BSD системах\n\n-w, --pidfile <filename>\n    Расположение PID-файла\n\n-E, --transparent\n    Запуск в режиме прозрачного прокси, SOCKS работать не будет\n    \n-c, --max-conn <count>\n    Максимальное количество клиентских подключений, по умолчанию 512\n\n-I,  --conn-ip <ip>\n    Адрес, к которому будут привязаны исходящие соединения, по умолчанию ::\n    При указании IPv4 адреса запросы на IPv6 будут отклоняться\n\n-b, --buf-size <size>\n    Максимальный размер данных, получаемых и отправляемых за один вызов recv/send\n    Размер указывается в байтах, по умолчанию равен 16384\n\n-g, --def-ttl <num>\n    Значение TTL для всех исходящий соединений\n    Может быть полезен для обхода обнаружения нестандартного/уменьшенного TTL\n\n-N, --no-domain\n    Отбрасывать запросы, если в качестве адреса указан домен\n    Т.к. резолвинг выполняется синхронно, то он может замедлить или даже заморозить работу\n\n-U, --no-udp\n    Не проксировать UDP\n    \n-F, --tfo\n    Включает TCP Fast Open\n    Если сервер его поддерживает, то первый пакет будет отправлен сразу вместе с SYN\n    Поддерживается только в Linux (4.11+)\n    \n-A, --auto <t,r,s,n>\n    Автоматический режим\n    Если произошло событие, похожее на блокировку или поломку,\n    то будут применены параметры обхода, следующие за данной опцией\n    Возможные события:\n        torst   : Вышло время ожидания или сервер сбросил подключение после первого запроса\n        redirect: HTTP Redirect с Location, домен которого не совпадает с исходящим\n        ssl_err : В ответ на ClientHello не пришел ServerHello или SH содержит некорректный session_id\n        none    : Предыдущая группа пропущена, например из-за ограничения по доменам или протоколам\n    \n-L, --auto-mode <0|1>\n    0: кешировать IP только если имеется возможность переподключиться\n    1: кешировать IP также в том случае, если:\n        torst - таймаут/соединение сброшено во время обмена пакетами (т.е. уже после первых данных от сервера)\n        ssl_err - совершился лишь один круг обмена данными (запрос-ответ/запрос-ответ-запрос)\n    \n-u, --cache-ttl <sec>\n    Время жизни значения в кеше, по умолчанию 100800 (28 часов)\n    \n-T, --timeout <sec>\n    Таймаут ожидания первого ответа от сервера в секундах\n    В Linux переводится в миллисекунды, поэтому можно указать дробное число\n    \n-K, --proto <t,h,u,i>\n    Белый список протоколов: tls,http,udp,ipv4\n    \n-H, --hosts <file|:string>\n    Ограничить область действия параметров списком доменов\n    Домены должны быть разделены новой строкой или пробелом\n    \n-j, --ipset <file|:str>\n    Ограничитель по определенным IP/подсетям\n    \n-V, --pf <port[-portr]>\n    Ограничитель по портам\n    \n-R, --round <num[-numr]>\n    К каким/какому запросу применять запутывание\n    По умолчанию 1, т.е. к первому запросу\n    \n-s, --split <pos_t>\n    Разбить запрос по указанной позиции\n    Позиция имеет вид offset[:repeats:skip][+flag1[flag2]]\n    Флаги:\n        +s: добавить смещение SNI\n        +h: добавить смещение Host\n        +n: нулевое смещение\n    Дополнительные флаги:\n        +e: конец; +m: середина\n    Примеры: \n        0+sm - разбить запрос в середине SNI\n        1:3:5 - разбить по позициям 1, 6 и 11\n    Ключ можно указывать несколько раз, чтобы разбить запрос по нескольким позициям\n    Если offset отрицательный и не имеет флагов, то к нему прибавляется размер пакета\n    \n-d, --disorder <pos_t>\n    Подобен --split, но части отправляются в обратном порядке\n    \n-o, --oob <pos_t>\n    Подобен --split, но часть отсылается как OOB данные\n    \n-q, --disoob <pos_t>\n    Подобен --disorder, но часть отсылается как OOB данные\n    \n-f, --fake <pos_t>\n    Подобен --disorder, только перед отправкой первого куска отправляется часть поддельного\n    Количество байт отправляемого из фейка равно рамеру разбиваемой части\n \n-t, --ttl <num>\n    TTL для поддельного пакета, по умолчанию 8\n    Необходимо подобрать такое значение, чтобы пакет не дошел до сервера, но был обработан DPI\n\n-k, --ip-opt[=file|:str]\n    Установить опции для фейкового IP пакета\n    Существенно снизит вероятность, что пакет дойдет до сервера\n    Стоит учесть, что до DPI он также может не дойти\n    В Windows не поддерживается\n    \n-S, --md5sig\n    Установить опцию TCP MD5 Signature для фейкового пакета\n    Большинство серверов (в основном на Linux) отбрасывают пакеты с данной опцией\n    Поддерживается только в Linux, может быть выключен в некоторых сборках ядра (< 3.9, Android)\n\n-O, --fake-offset <n>\n    Сместить начало фейковых данных на n байт\n       \n-l, --fake-data <file|:str>\n    Указать свои поддельные пакеты\n    Строка может содержать escape символы (\\n,\\0,\\0x10)\n\n-e, --oob-data <char>\n    Байт, отсылаемый вне основного потока, по умолчанию 'a'\n    Можно указать ASCII или escape символ\n    \n-n, --tls-sni <str>\n    Изменить SNI в дефолтном fake пакете на указанный\n\n-M, --mod-http <h[,d,r]>\n    Всякие манипуляции с HTTP пакетом, можно комбинировать\n    hcsmix:\n        \"Host: name\" -> \"hOsT: name\"\n    dcsmix:\n        \"Host: name\" -> \"Host: NaMe\"\n    rmspace:\n        \"Host: name\" -> \"Host:name\\t\"\n\n-r, --tlsrec <pos_t>\n    Разделить ClientHello на отдельные записи по указанному смещению\n    Можно указывать несколько раз  \n\n-a, --udp-fake <count>\n    Количество фейковых UDP пакетов\n\n-Y, --drop-sack\n    Игнорировать SACK, вынуждая ядро переотправить уже доставленные пакеты\n    Поддерживается только в Linux\n```\n\n------\n### Подробнее\n`--split`\n\nРазбивает запрос на части. Пример на запросе в 30 байт:\n- Параметры: `--split 3 --split 7`\n- Порядок отправки: 1-3, 3-7, 7-30  \n\nПозиции следует указывать в порядке возрастания.  \n\n------\n`--disorder`\n\nЧасть, попадающая под disorder, будет отправлена с TTL=1, т.е. фактически не будет никуда доставлена.\nОС узнает об этом лишь после отсылки последующей части, когда сервер сообщит о потере с помощью SACK.\nСистеме придется отослать предыдущий пакет заново, тем самым нарушив обычный порядок.\n- Параметры: `--disorder 7`\n- Порядок отправки: 7-30, 1-7  \n\nВышесказанное распространяется только на Linux.\nВ Windows ретрансмиссия начинается с позиции, с которой начались потери (максимальный ACK, полученный от сервера):\n- Параметры: `--disorder 7`\n- Порядок отправки: 7-30, 1-30\n\nПоэтому желательно использовать ещё и `split`:  \n- Параметры: `--split 7 --disorder 23`\n- Порядок отправки: 1-7, 23-30, 7-30\n\nНа практике оптимально использовать:  \n* Linux: `--disorder 1`\n* Windows: `--split 1+s --disorder 3+s`\n\n------\n`--fake`\n\n- Параметры: `--fake 7`\n- Порядок отправки: 1-7 фейк, 7-30 оригинал, 1-7 оригинал\n\nДанные в первой части запроса заменяются на поддельные.  \nЭта часть должна пройти через DPI, но не дойти до сервера.\nА раз часть не дойдет, то ОС отправит ее снова, тем самым изменив порядок подобно `disorder`.\nДля того, чтобы фейк не дошел до сервера, есть опции `ttl`, `ip-opt` и `md5sig`.  \n\nTTL необходимо подбирать такой, чтобы пакет прошел через все DPI, но не дошел до сервера.  \nДля Linux есть md5sig. Он устанавливает опцию TCP MD5 Signature, что не дает пакету быть принятым многими серверами.\nК сожалению, md5sig работает не во всех сборках.  \n\nДля Windows есть еще один способ избежать обработки фейка сервером.\nЭто комбинирование `fake` с `disorder`:\n- Параметры: `--disorder 1 --fake 7`\n- Порядок отправки: 2-7 фейк, 7-30 оригинал, 1-30 оригинал  \n\nЕсли поддельный пакет и дойдет до сервера, то он будет перезаписан из-за полной ретрансмисси.  \n\nНа практике оптимально использовать:  \n* Linux: `--fake -1 --md5sig`\n* Windows: `--disorder 1 --fake -1`\n\n------\n`--oob`\n\nTCP может отсылать данные вне основного потока, используя флаг URG, однако лишь 1 байт в пакете.  \nВсе данные в таком пакете будут доставлены приложению, кроме последнего байта, который и является внеканальным:\n- Параметры: `--oob 3`\n- Отправка: 1-4 с флагом URG (1-3 данные запроса + 4-й байт, который будет усечен), 3-30\n\nЭтот байт желательно помещать в SNI: `--oob 3+s` \n\n------\n`--disoob`\n\nСхож с `--disorder`, но часть отправляется с OOB байтом:\n- Параметры: `--disoob 3`\n- Отправка: 3-30, 1-4 с флагом URG (1-3 данные запроса + 4-й байт, который будет усечен)\n\nПри использовании с `--fake` или `--disorder` можно получить пакет, где OOB байт будет находиться на месте разбиения:\n- Параметры: `--disoob 3 --disorder 7`\n- Отправка: 3-30, 1-8 с флагом URG (1-3 + байт который будет усечен + 4-8)\n\n------\n`--tlsrec`\n\nОдну TLS запись можно разбить на несколько, немного переделав заголовок.  \nНа месте разбиения вставляется новый заголовок, увеличивая размер запроса на 5 байт.  \n\nЭтот заголовок можно поместить в середину SNI, не давая возможность DPI правильно его прочитать: \n`--tlsrec 3+s`\n\nХоть `tlsrec` и `oob` запутывают DPI, они также могут запутать всякие мидлбоксы, которые не поддерживают полноценный стек TCP/TLS.  \nИз-за этого их следует использовать вместе с `--auto`:  \n`--auto=torst --timeout 3 --tlsrec 3+s`  \nВ примере `tlsrec` будет применяться лишь в случаях, когда сброшено подключение или вышел таймаут, т.е. когда, скорее всего, произошла блокировка.  \nМожно наоборот - отменять tlsrec, если сервер сбрасывает подключение или откидывает пакет:  \n`--tlsrec 3+s --auto=torst --timeout 3`  \n\n------\n`-Y, --drop-sack`\n\nЗаставляет ядро игнорировать пакеты с расширением TCP SACK.\nЭто расширение позволяет подтверждать получение отдельных сегментов данных.\nЕсли первая часть запроса будет потеряна, а до сервера дойдет лишь вторая, то сервер с помощью этого расширения может уведомить клиента об этом. Тогда клиент, зная, что вторая часть дошла, отправит лишь первую.  \nЗачем игнорировать это расширение? Второй сегмент может быть фейковым. Если он дойдет до сервера, но клиент об этом не узнает, то он попытается переотправить его. Однако этот сегмент будет содержать уже оригинальные данные, которые перезапишут фейковые, тем самым предотвратив поломку протокола.  \nТак как быстрое подтверждение работать не будет, то это сломает `disorder`, а также добавит задержку перед ретрансмиссией (около 200ms).\n\n------\n`--auto`, `--hosts`\n\nПараметр `auto` делит опции на группы.\nДля каждого запроса они обходятся слева на право.\nСначала проверяется триггер, указанный в `auto`, затем `pf`, `proto` и `hosts`.\n\nМожно указывать несколько групп опций, раделяя их данным параметром.  \nПараметры, которые идут ниже `--timeout` в help-тексте (кроме `tls-sni`), можно вынести в отдельную группу.  \n\n#### Примеры:\n```\n--fake -1 --ttl 10 --auto=ssl_err --fake -1 --ttl 5\n```\nПо умолчанию использовать `fake` с ttl=10, в случае ошибки использовать `fake` с ttl=5\n\n```\n--hosts list.txt --disorder 3 --auto=none\n```\nПрименять запутывание только для доменов из list.txt\n\n```\n--hosts list.txt --auto=none --disorder 3\n```\nНе применять запутывание для доменов из list.txt\n\n```\n--auto=torst --hosts list.txt --disorder 3\n```\nПо умолчанию ничего не делать, использовать disorder при условии, что произошла блокировка и домен входит в list.txt.\n\n```\n--proto=http,tls --disorder 3 --auto=none\n```\nЗапутывать только HTTP и TLS\n\n```\n--proto=http --fake -1 --fake-data=':GET /...' --auto=none --fake -1\n```\nПереопределить фейковый пакет для HTTP\n\n------\n### Сборка\nДля сборки понадобится: \n`make`, `gcc/clang` для Linux, `mingw` для Windows  \n\n* Linux: `make`\n* Windows: `make windows CC=x86_64-w64-mingw32-gcc`\n\n------\n### Дополнительная информация о DPI, источники идей  \n* https://github.com/bol-van/zapret/blob/master/docs/readme.md  \n* https://geneva.cs.umd.edu/papers/geneva_ccs19.pdf  \n* https://habr.com/ru/post/335436  \n"
        },
        {
          "name": "conev.c",
          "type": "blob",
          "size": 5.029296875,
          "content": "#include \"conev.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n#include \"error.h\"\n\n\nstruct poolhd *init_pool(int count)\n{\n    struct poolhd *pool = calloc(1, sizeof(struct poolhd));\n    if (!pool) {\n        uniperror(\"init pool\");\n        return 0;\n    }\n    pool->max = count;\n    pool->count = 0;\n    pool->iters = 0;\n\n    #ifndef NOEPOLL\n    int efd = epoll_create(count);\n    if (efd < 0) {\n        free(pool);\n        return 0;\n    }\n    pool->efd = efd;\n    #endif\n    pool->pevents = malloc(sizeof(*pool->pevents) * count);\n    pool->links = malloc(sizeof(*pool->links) * count);\n    pool->items = malloc(sizeof(*pool->items) * count);\n\n    if (!pool->pevents || !pool->links || !pool->items) {\n        uniperror(\"init pool\");\n        destroy_pool(pool);\n        return 0;\n    }\n    for (int i = 0; i < count; i++) {\n        pool->links[i] = &(pool->items[i]);\n    }\n    memset(pool->items, 0, sizeof(*pool->items));\n    return pool;\n}\n\n\nstruct eval *add_event(struct poolhd *pool, enum eid type,\n        int fd, int e)\n{\n    assert(fd > 0);\n    if (pool->count >= pool->max) {\n        LOG(LOG_E, \"add_event: pool is full\\n\");\n        return 0;\n    }\n    struct eval *val = pool->links[pool->count];\n    memset(val, 0, sizeof(*val));\n\n    val->mod_iter = pool->iters;\n    val->fd = fd;\n    val->index = pool->count;\n    val->type = type;\n\n    #ifndef NOEPOLL\n    struct epoll_event ev = { .events = EPOLLRDHUP | e, .data = {val} };\n    if (epoll_ctl(pool->efd, EPOLL_CTL_ADD, fd, &ev)) {\n        uniperror(\"add event\");\n        return 0;\n    }\n    #else\n    struct pollfd *pfd = &(pool->pevents[pool->count]);\n    \n    pfd->fd = fd;\n    pfd->events = POLLRDHUP | e;\n    pfd->revents = 0;\n    #endif\n\n    pool->count++;\n    return val;\n}\n\n\nvoid del_event(struct poolhd *pool, struct eval *val) \n{\n    assert(val->fd >= -1 && val->mod_iter <= pool->iters);\n    if (val->fd == -1) {\n        return;\n    }\n    #ifdef NOEPOLL\n    assert(val->fd == pool->pevents[val->index].fd);\n    #else\n    epoll_ctl(pool->efd, EPOLL_CTL_DEL, val->fd, 0);\n    #endif\n    if (val->buff.data) {\n        assert(val->buff.size);\n        free(val->buff.data);\n        val->buff.data = 0;\n    }\n    close(val->fd);\n    val->fd = -1;\n    val->mod_iter = pool->iters;\n    pool->count--;\n    \n    struct eval *ev = pool->links[pool->count];\n    if (ev != val) \n    {\n        int index = val->index;\n        pool->links[index] = ev;\n        pool->links[pool->count] = val;\n        #ifdef NOEPOLL\n        pool->pevents[index] = pool->pevents[pool->count];\n        #endif\n        ev->index = index;\n    }\n    if (val->pair) {\n        if (val->pair->pair == val) {\n            val->pair->pair = 0;\n        }\n        struct eval *e = val->pair;\n        val->pair = 0;\n        del_event(pool, e);\n    }\n    assert(pool->count > 0);\n}\n\n\nvoid destroy_pool(struct poolhd *pool)\n{\n    for (int x = 0; x < pool->count; x++) {\n        struct eval *val = pool->links[x];\n        if (val->fd) {\n            close(val->fd);\n            val->fd = 0;\n        }\n        if (val->buff.data) {\n            free(val->buff.data);\n            val->buff.data = 0;\n        }\n    }\n    free(pool->items);\n    free(pool->links);\n    free(pool->pevents);\n    #ifndef NOEPOLL\n    if (pool->efd)\n        close(pool->efd);\n    #endif\n    memset(pool, 0, sizeof(*pool));\n    free(pool);\n}\n\n\n#ifndef NOEPOLL\nstruct eval *next_event(struct poolhd *pool, int *offs, int *type)\n{\n    while (1) {\n        int i = *offs;\n        assert(i >= -1 && i < pool->max);\n        if (i < 0) {\n            i = (epoll_wait(pool->efd, pool->pevents, pool->max, -1) - 1);\n            if (i < 0) {\n                return 0;\n            }\n            pool->iters++;\n        }\n        struct eval *val = pool->pevents[i].data.ptr;\n        *offs = i - 1;\n        if (val->mod_iter == pool->iters) {\n            continue;\n        }\n        *type = pool->pevents[i].events;\n        return val;\n    }\n}\n\n\nint mod_etype(struct poolhd *pool, struct eval *val, int type)\n{\n    assert(val->fd > 0);\n    struct epoll_event ev = {\n        .events = EPOLLRDHUP | type, .data = {val}\n    };\n    return epoll_ctl(pool->efd, EPOLL_CTL_MOD, val->fd, &ev);\n}\n\n#else\nstruct eval *next_event(struct poolhd *pool, int *offs, int *typel)\n{\n    for (int i = *offs; ; i--) {\n        assert(i >= -1 && i < pool->max);\n        if (i < 0) {\n            if (poll(pool->pevents, pool->count, -1) <= 0) {\n                return 0;\n            }\n            i = pool->count - 1;\n            pool->iters++;\n        }\n        short type = pool->pevents[i].revents;\n        if (!type) {\n            continue;\n        }\n        struct eval *val = pool->links[i];\n        assert((i < pool->count) || (val->mod_iter == pool->iters));\n        if (val->mod_iter == pool->iters) {\n            continue;\n        }\n        pool->pevents[i].revents = 0;\n        *offs = i - 1;\n        *typel = type;\n        return val;\n    }\n}\n\n\nint mod_etype(struct poolhd *pool, struct eval *val, int type)\n{\n   assert(val->index >= 0 && val->index < pool->count);\n   pool->pevents[val->index].events = POLLRDHUP | type;\n   return 0;\n}\n#endif\n"
        },
        {
          "name": "conev.h",
          "type": "blob",
          "size": 2.1162109375,
          "content": "#ifndef CONEV_H\n#define CONEV_H\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#ifndef __linux__\n    #define NOEPOLL\n#endif\n\n#ifdef _WIN32\n    #include <ws2tcpip.h>\n    #define poll(fds, cnt, to) WSAPoll(fds, cnt, to)\n    #define close(fd) closesocket(fd)\n#else\n    #include <netinet/in.h>\n    #include <unistd.h>\n    \n    #ifndef NOEPOLL\n        #include <sys/epoll.h>\n        #define POLLIN EPOLLIN\n        #define POLLOUT EPOLLOUT\n        #define POLLERR EPOLLERR\n        #define POLLHUP EPOLLHUP\n        #define POLLRDHUP EPOLLRDHUP\n    #else\n        #include <sys/poll.h>\n    #endif\n#endif\n\n#ifndef POLLRDHUP\n    #define POLLRDHUP 0\n#endif\n\nunion sockaddr_u {\n    struct sockaddr sa;\n    struct sockaddr_in in;\n    struct sockaddr_in6 in6;\n};\n\nenum eid {\n    EV_ACCEPT,\n    EV_REQUEST,\n    EV_CONNECT,\n    EV_IGNORE,\n    EV_TUNNEL,\n    EV_UDP_TUNNEL,\n    EV_FIRST_TUNNEL\n};\n\n#define FLAG_S4 1\n#define FLAG_S5 2\n#define FLAG_CONN 4\n\n#ifdef EID_STR\nchar *eid_name[] = {\n    \"EV_ACCEPT\",\n    \"EV_REQUEST\",\n    \"EV_CONNECT\",\n    \"EV_IGNORE\",\n    \"EV_TUNNEL\",\n    \"EV_UDP_TUNNEL\",\n    \"EV_FIRST_TUNNEL\"\n};\n#endif\n\nstruct buffer {\n    size_t size;\n    unsigned int offset;\n    char *data;\n};\n\nstruct eval {\n    int fd;    \n    int index;\n    unsigned long long mod_iter;\n    enum eid type;\n    struct eval *pair;\n    struct buffer buff;\n    int flag;\n    union sockaddr_u addr;\n    ssize_t recv_count;\n    ssize_t round_sent;\n    unsigned int round_count;\n    int attempt;\n    bool cache;\n    bool mark; //\n};\n\nstruct poolhd {\n    int max;\n    int count;\n    int efd;\n    struct eval **links;\n    struct eval *items;\n#ifndef NOEPOLL\n    struct epoll_event *pevents;\n#else\n    struct pollfd *pevents;\n#endif\n    unsigned long long iters;\n};\n\nstruct poolhd *init_pool(int count);\n\nstruct eval *add_event(struct poolhd *pool, enum eid type, int fd, int e);\n\nstruct eval *add_pair(struct poolhd *pool, struct eval *val, int sfd, int e);\n\nvoid del_event(struct poolhd *pool, struct eval *val);\n\nvoid destroy_pool(struct poolhd *pool);\n\nstruct eval *next_event(struct poolhd *pool, int *offs, int *type);\n\nint mod_etype(struct poolhd *pool, struct eval *val, int type);\n\n#endif\n"
        },
        {
          "name": "desync.c",
          "type": "blob",
          "size": 17.203125,
          "content": "#define _GNU_SOURCE\n\n#include \"desync.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#ifndef _WIN32\n    #include <unistd.h>\n    #include <time.h>\n    #include <sys/time.h>\n    #include <sys/socket.h>\n    #include <sys/mman.h>\n    #include <arpa/inet.h>\n    #include <fcntl.h>\n    \n    #ifndef __linux__\n    #include <netinet/tcp.h>\n    #else\n    #include <linux/tcp.h>\n    #include <linux/filter.h>\n    #endif\n#else\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    #include <mswsock.h>\n#endif\n#define STR_MODE\n\n#include \"params.h\"\n#include \"packets.h\"\n#include \"error.h\"\n\n#define WAIT_LIMIT_MS 500\n#define DEFAULT_TTL 8\n\n\nint setttl(int fd, int ttl)\n{\n    int ret6 = setsockopt(fd, IPPROTO_IPV6,\n        IPV6_UNICAST_HOPS, (char *)&ttl, sizeof(ttl));\n    int ret4 = setsockopt(fd, IPPROTO_IP, \n        IP_TTL, (char *)&ttl, sizeof(ttl));\n    \n    if (ret4 && ret6) {\n        uniperror(\"setttl\");\n        return -1;\n    }\n    return 0;\n}\n\n\n#ifdef __linux__\nstatic int get_family(const struct sockaddr_in6 *dst)\n{\n    static const char map[12] = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\xff\\xff\";\n    if (dst->sin6_family == AF_INET6 \n            && !memcmp(&dst->sin6_addr, map, sizeof(map))) {\n        return AF_INET;\n    }\n    return dst->sin6_family;\n}\n\n\nstatic int drop_sack(int fd)\n{\n    struct sock_filter code[] = {\n        { 0x30, 0, 0, 0x0000000c },\n        { 0x74, 0, 0, 0x00000004 },\n        { 0x35, 0, 3, 0x0000000b },\n        { 0x30, 0, 0, 0x00000022 },\n        { 0x15, 0, 1, 0x00000005 },\n        { 0x6,  0, 0, 0x00000000 },\n        { 0x6,  0, 0, 0x00040000 },\n    };\n    struct sock_fprog bpf = {\n        .len = sizeof(code)/sizeof(*code),\n        .filter = code\n    };\n    if (setsockopt(fd, SOL_SOCKET, \n            SO_ATTACH_FILTER, (char *)&bpf, sizeof(bpf)) == -1) {\n        uniperror(\"setsockopt SO_ATTACH_FILTER\");\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic inline void delay(long ms)\n{\n    struct timespec time = { \n         .tv_nsec = ms * 1e6\n    };\n    nanosleep(&time, 0);\n}\n\n\nstatic void wait_send_if_support(int sfd)\n{\n    int i = 0;\n    for (; params.wait_send && i < WAIT_LIMIT_MS; i++) {\n        struct tcp_info tcpi;\n        socklen_t ts = sizeof(tcpi);\n        \n        if (getsockopt(sfd, IPPROTO_TCP,\n                TCP_INFO, (char *)&tcpi, &ts) < 0) {\n            perror(\"getsockopt TCP_INFO\");\n            break;\n        }\n        if (tcpi.tcpi_state != 1) {\n            LOG(LOG_E, \"state: %d\\n\", tcpi.tcpi_state);\n            break;\n        }\n        if (ts <= offsetof(struct tcp_info, tcpi_notsent_bytes)) {\n            LOG(LOG_E, \"tcpi_notsent_bytes not provided\\n\");\n            params.wait_send = 0;\n            break;\n        }\n        if (tcpi.tcpi_notsent_bytes == 0) {\n            break;\n        }\n        delay(1);\n    }\n    if (i) LOG(LOG_S, \"waiting for send: %d ms\\n\", i);\n}\n#else\n#define wait_send_if_support(sfd) {}\n#endif\n\n\nstatic struct packet get_tcp_fake(const char *buffer, size_t n,\n        struct proto_info *info, const struct desync_params *opt)\n{\n    struct packet pkt;\n    if (opt->fake_data.data) {\n        pkt = opt->fake_data;\n    }\n    else {\n        if (!info->type) {\n            if (is_tls_chello(buffer, n)) info->type = IS_HTTPS;\n            else if (is_http(buffer, n)) info->type = IS_HTTP;\n        }\n        pkt = info->type == IS_HTTP ? fake_http : fake_tls;\n    }\n    if (opt->fake_offset) {\n        if (pkt.size > opt->fake_offset) { \n            pkt.size -= opt->fake_offset;\n            pkt.data += opt->fake_offset;\n        }\n        else pkt.size = 0;\n    }\n    return pkt;\n}\n\n\n#ifdef __linux__\nstatic ssize_t send_fake(int sfd, const char *buffer,\n        long pos, const struct desync_params *opt, struct packet pkt)\n{\n    struct sockaddr_in6 addr;\n    socklen_t addr_size = sizeof(addr);\n    \n    if (opt->md5sig || opt->ip_options) {\n        if (getpeername(sfd, \n                (struct sockaddr *)&addr, &addr_size) < 0) {\n            uniperror(\"getpeername\");\n            return -1;\n        }\n    }\n    int fds[2];\n    if (pipe(fds) < 0) {\n        uniperror(\"pipe\");\n        return -1;\n    }\n    char *p = 0;\n    ssize_t len = -1;\n    \n    while (1) {\n        p = mmap(0, pos, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n        if (p == MAP_FAILED) {\n            uniperror(\"mmap\");\n            p = 0;\n            break;\n        }\n        memcpy(p, pkt.data, pkt.size < pos ? pkt.size : pos);\n        \n        if (setttl(sfd, opt->ttl ? opt->ttl : DEFAULT_TTL) < 0) {\n            break;\n        }\n        if (opt->md5sig) {\n            struct tcp_md5sig md5 = {\n                .tcpm_keylen = 5\n            };\n            memcpy(&md5.tcpm_addr, &addr, addr_size);\n            \n            if (setsockopt(sfd, IPPROTO_TCP,\n                    TCP_MD5SIG, (char *)&md5, sizeof(md5)) < 0) {\n                uniperror(\"setsockopt TCP_MD5SIG\");\n                break;\n            }\n        }\n        if (opt->ip_options && get_family(&addr) == AF_INET \n            && setsockopt(sfd, IPPROTO_IP, IP_OPTIONS,\n                opt->ip_options, opt->ip_options_len) < 0) {\n            uniperror(\"setsockopt IP_OPTIONS\");\n            break;\n        }\n        struct iovec vec = { .iov_base = p, .iov_len = pos };\n        \n        len = vmsplice(fds[1], &vec, 1, SPLICE_F_GIFT);\n        if (len < 0) {\n            uniperror(\"vmsplice\");\n            break;\n        }\n        len = splice(fds[0], 0, sfd, 0, len, 0);\n        if (len < 0) {\n            uniperror(\"splice\");\n            break;\n        }\n        wait_send_if_support(sfd);\n        memcpy(p, buffer, pos);\n        \n        if (setttl(sfd, params.def_ttl) < 0) {\n            break;\n        }\n        if (opt->ip_options && get_family(&addr) == AF_INET \n            && setsockopt(sfd, IPPROTO_IP,\n                IP_OPTIONS, opt->ip_options, 0) < 0) {\n            uniperror(\"setsockopt IP_OPTIONS\");\n            break;\n        }\n        if (opt->md5sig) {\n            struct tcp_md5sig md5 = {\n                .tcpm_keylen = 0\n            };\n            memcpy(&md5.tcpm_addr, &addr, addr_size);\n            \n            if (setsockopt(sfd, IPPROTO_TCP,\n                    TCP_MD5SIG, (char *)&md5, sizeof(md5)) < 0) {\n                uniperror(\"setsockopt TCP_MD5SIG\");\n                break;\n            }\n        }\n        break;\n    }\n    if (p) munmap(p, pos);\n    close(fds[0]);\n    close(fds[1]);\n    return len;\n}\n#endif\n\n#ifdef _WIN32\nOVERLAPPED ov = { 0 };\n\nstatic ssize_t send_fake(int sfd, const char *buffer,\n        long pos, const struct desync_params *opt, struct packet pkt)\n{\n    char path[MAX_PATH], temp[MAX_PATH + 1];\n    int ps = GetTempPath(sizeof(temp), temp);\n    if (!ps) {\n        uniperror(\"GetTempPath\");\n        return -1;\n    }\n    if (!GetTempFileName(temp, \"t\", 0, path)) {\n        uniperror(\"GetTempFileName\");\n        return -1;\n    }\n    LOG(LOG_L, \"temp file: %s\\n\", path);\n    \n    HANDLE hfile = CreateFileA(path, GENERIC_READ | GENERIC_WRITE, \n        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, \n        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);\n    if (hfile == INVALID_HANDLE_VALUE) {\n        uniperror(\"CreateFileA\");\n        return -1;\n    }\n    ssize_t len = -1;\n    \n    while (1) {\n        ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n        if (!ov.hEvent) {\n            uniperror(\"CreateEvent\");\n             break;\n        }\n        DWORD wrtcnt = 0;\n        if (!WriteFile(hfile, pkt.data, pkt.size < pos ? pkt.size : pos, &wrtcnt, 0)) {\n            uniperror(\"WriteFile\");\n            break;\n        }\n        if (pkt.size < pos) {\n            if (SetFilePointer(hfile, pos, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {\n                uniperror(\"SetFilePointer\");\n                break;\n            }\n            if (!SetEndOfFile(hfile)) {\n                uniperror(\"SetFileEnd\");\n                break;\n            }\n        }\n        if (SetFilePointer(hfile, 0, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {\n            uniperror(\"SetFilePointer\");\n            break;\n        }\n        if (setttl(sfd, opt->ttl ? opt->ttl : DEFAULT_TTL) < 0) {\n            break;\n        }\n        if (!TransmitFile(sfd, hfile, pos, pos, &ov, \n                NULL, TF_USE_KERNEL_APC | TF_WRITE_BEHIND)) {\n            if ((GetLastError() != ERROR_IO_PENDING) \n                        && (WSAGetLastError() != WSA_IO_PENDING)) {\n                uniperror(\"TransmitFile\");\n                break;\n            }\n        }\n        //Sleep(3);\n        \n        if (SetFilePointer(hfile, 0, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {\n            uniperror(\"SetFilePointer\");\n            break;\n        }\n        if (!WriteFile(hfile, buffer, pos, &wrtcnt, 0)) {\n            uniperror(\"WriteFile\");\n            break;\n        }\n        if (setttl(sfd, params.def_ttl) < 0) {\n            break;\n        }\n        len = pos;\n        break;\n    }\n    if (!CloseHandle(hfile)\n            || (ov.hEvent && !CloseHandle(ov.hEvent))) {\n        uniperror(\"CloseHandle\");\n        return -1;\n    }\n    return len;\n}\n#endif\n\nstatic ssize_t send_oob(int sfd, char *buffer,\n        ssize_t n, long pos, const char *c)\n{\n    if (n <= pos) {\n        return -1;\n    }\n    char rchar = buffer[pos];\n    buffer[pos] = c[1] ? c[0] : 'a';\n    \n    ssize_t len = send(sfd, buffer, pos + 1, MSG_OOB);\n    buffer[pos] = rchar;\n    \n    if (len < 0) {\n        uniperror(\"send\");\n        return -1;\n    }\n    wait_send_if_support(sfd);\n    \n    len--;\n    if (len != pos) {\n        return len;\n    }\n    return len;\n}\n\n\nstatic ssize_t send_disorder(int sfd, \n        const char *buffer, long pos)\n{\n    int bttl = 1;\n    \n    if (setttl(sfd, bttl) < 0) {\n        return -1;\n    }\n    ssize_t len = send(sfd, buffer, pos, 0);\n    if (len < 0) {\n        uniperror(\"send\");\n    }\n    else wait_send_if_support(sfd);\n    \n    if (setttl(sfd, params.def_ttl) < 0) {\n        return -1;\n    }\n    return len;\n}\n\n\nstatic ssize_t send_late_oob(int sfd, char *buffer,\n        ssize_t n, long pos, const char *c)\n{\n    int bttl = 1;\n    \n    if (setttl(sfd, bttl) < 0) {\n        return -1;\n    }\n    ssize_t len = send_oob(sfd, buffer, n, pos, c);\n    if (len < 0) {\n        uniperror(\"send\");\n    }\n    if (setttl(sfd, params.def_ttl) < 0) {\n        return -1;\n    }\n    return len;\n}\n\n\nstatic void init_proto_info(\n        const char *buffer, size_t n, struct proto_info *info)\n{\n    if (!info->init) {\n        char *host = 0;\n        \n        if ((info->host_len = parse_tls(buffer, n, &host))) {\n            info->type = IS_HTTPS;\n        }\n        else if ((info->host_len = parse_http(buffer, n, &host, 0))) {\n            info->type = IS_HTTP;\n        }\n        info->host_pos = host ? host - buffer : 0;\n        info->init = 1;\n    }\n}\n\n\nstatic long gen_offset(long pos, int flag,\n        const char *buffer, size_t n, long lp, struct proto_info *info)\n{\n    if (flag & (OFFSET_SNI | OFFSET_HOST)) {\n        init_proto_info(buffer, n, info);\n        \n        if (!info->host_pos \n                || ((flag & OFFSET_SNI) && info->type != IS_HTTPS)) {\n            return -1;\n        }\n        pos += info->host_pos;\n        \n        if (flag & OFFSET_END)\n            pos += info->host_len;\n        else if (flag & OFFSET_MID)\n            pos += (info->host_len / 2);\n        else if (flag & OFFSET_RAND)\n            pos += (rand() % info->host_len);\n    }\n    else if (flag & OFFSET_RAND) {\n        pos += lp + (rand() % (n - lp));\n    }\n    else if (flag & OFFSET_MID) {\n        pos += (n / 2);\n    }\n    else if (pos < 0 || (flag & OFFSET_END)) {\n        pos += n;\n    }\n    return pos;\n}\n\n\nstatic ssize_t tamp(char *buffer, size_t bfsize, ssize_t n, \n        const struct desync_params *dp, struct proto_info *info)\n{\n    if (dp->mod_http && is_http(buffer, n)) {\n        LOG(LOG_S, \"modify HTTP: n=%zd\\n\", n);\n        if (mod_http(buffer, n, dp->mod_http)) {\n            LOG(LOG_E, \"mod http error\\n\");\n        }\n    }\n    else if (dp->tlsrec_n && is_tls_chello(buffer, n)) {\n        long lp = 0;\n        struct part part;\n        int i = 0, r = 0, rc = 0;\n        \n        for (; r > 0 || i < dp->tlsrec_n; rc++, r--) {\n            if (r <= 0) {\n                part = dp->tlsrec[i];\n                r = part.r; i++;\n            }\n            long pos = rc * 5;\n            pos += gen_offset(part.pos, \n                part.flag, buffer, n - pos, lp, info);\n                \n            if (part.pos < 0 || part.flag) {\n                pos -= 5;\n            }\n            pos += (long )part.s * (part.r - r);\n            if (pos < lp) {\n                LOG(LOG_E, \"tlsrec cancel: %ld < %ld\\n\", pos, lp);\n                break;\n            }\n            if (!part_tls(buffer + lp, \n                    bfsize - lp, n - lp, pos - lp)) {\n                LOG(LOG_E, \"tlsrec error: pos=%ld, n=%zd\\n\", pos, n);\n                break;\n            }\n            LOG(LOG_S, \"tlsrec: pos=%ld, n=%zd\\n\", pos, n);\n            n += 5;\n            lp = pos + 5;\n        }\n    }\n    return n;\n}\n\n\nssize_t desync(int sfd, char *buffer, size_t bfsize,\n        ssize_t n, ssize_t offset, int dp_c)\n{\n    struct desync_params dp = params.dp[dp_c];\n    struct proto_info info = { 0 };\n    \n    if (offset == 0 && params.debug) {\n        init_proto_info(buffer, n, &info);\n        \n        if (info.host_pos) {\n            LOG(LOG_S, \"host: %.*s (%d)\\n\",\n                info.host_len, buffer + info.host_pos, info.host_pos);\n        } else {\n            INIT_HEX_STR(buffer, (n > 16 ? 16 : n));\n            LOG(LOG_S, \"bytes: %s (%zd)\\n\", HEX_STR, n);\n        }\n    }\n    n = tamp(buffer, bfsize, n, &dp, &info);\n    #ifdef __linux__\n    if (!offset && dp.drop_sack && drop_sack(sfd)) {\n        return -1;\n    }\n    #endif\n    long lp = 0;\n    struct part part;\n    int i = 0, r = 0;\n    \n    for (; r > 0 || i < dp.parts_n; r--) {\n        if (r <= 0) {\n            part = dp.parts[i];\n            r = part.r; i++;\n        }\n        long pos = gen_offset(part.pos, part.flag, buffer, n, lp, &info);\n        pos += (long )part.s * (part.r - r);\n        \n        if (!(part.flag & OFFSET_START) && offset && pos <= offset) {\n            LOG(LOG_S, \"offset: %zd, skip\\n\", offset);\n            continue;\n        }\n        if (pos < 0 || pos > n || pos < lp) {\n            LOG(LOG_E, \"split cancel: pos=%ld-%ld, n=%zd\\n\", lp, pos, n);\n            break;\n        }\n        \n        ssize_t s = 0;\n        switch (part.m) {\n            #ifdef FAKE_SUPPORT\n            case DESYNC_FAKE:\n                if (pos != lp) s = send_fake(sfd, \n                    buffer + lp, pos - lp, &dp, get_tcp_fake(buffer, n, &info, &dp));\n                break;\n            #endif\n            case DESYNC_DISORDER:\n                s = send_disorder(sfd, \n                    buffer + lp, pos - lp);\n                break;\n            \n            case DESYNC_OOB:\n                s = send_oob(sfd, \n                    buffer + lp, bfsize - lp, pos - lp, dp.oob_char);\n                break;\n                \n            case DESYNC_DISOOB:\n                s = send_late_oob(sfd, \n                    buffer + lp, bfsize - lp, pos - lp, dp.oob_char);\n                break;\n                \n            case DESYNC_SPLIT:\n            case DESYNC_NONE:\n                s = send(sfd, buffer + lp, pos - lp, 0);\n                wait_send_if_support(sfd);\n                break;\n                \n            default:\n                return -1;\n        }\n        LOG(LOG_S, \"split: pos=%ld-%ld (%zd), m: %s\\n\", lp, pos, s, demode_str[part.m]);\n        \n        if (s < 0) {\n            if (get_e() == EAGAIN) {\n                return lp;\n            }\n            return -1;\n        } \n        else if (s != (pos - lp)) {\n            LOG(LOG_E, \"%zd != %ld\\n\", s, pos - lp);\n            return lp + s;\n        }\n        lp = pos;\n    }\n    // send all/rest\n    if (lp < n) {\n        LOG((lp ? LOG_S : LOG_L), \"send: pos=%ld-%zd\\n\", lp, n);\n        if (send(sfd, buffer + lp, n - lp, 0) < 0) {\n            if (get_e() == EAGAIN) {\n                return lp;\n            }\n            uniperror(\"send\");\n            return -1;\n        }\n    }\n    return n;\n}\n\n\nint post_desync(int sfd, int dp_c)\n{\n    struct desync_params *dp = &params.dp[dp_c];\n    \n    #ifdef __linux__\n    if (dp->drop_sack) {\n        if (setsockopt(sfd, SOL_SOCKET, \n                SO_DETACH_FILTER, &dp_c, sizeof(dp_c)) == -1) {\n            uniperror(\"setsockopt SO_DETACH_FILTER\");\n            return -1;\n        }\n    }\n    #endif\n    return 0;\n}\n\n\nssize_t desync_udp(int sfd, char *buffer, \n        ssize_t n, const struct sockaddr *dst, int dp_c)\n{\n    struct desync_params *dp = &params.dp[dp_c];\n    \n    if (dp->udp_fake_count != 0) {\n        struct packet pkt;\n        if (dp->fake_data.data) {\n            pkt = dp->fake_data;\n        }\n        else {\n            pkt = fake_udp;\n        }\n        if (dp->fake_offset) {\n            if (pkt.size > dp->fake_offset) { \n                pkt.size -= dp->fake_offset;\n                pkt.data += dp->fake_offset;\n            }\n            else pkt.size = 0;\n        }\n        int bttl = dp->ttl ? dp->ttl : DEFAULT_TTL;\n        if (setttl(sfd, bttl) < 0) {\n            return -1;\n        }\n        for (int i = 0; i < dp->udp_fake_count; i++) {\n            ssize_t len = sendto(sfd, pkt.data, \n                pkt.size, 0, dst, sizeof(struct sockaddr_in6));\n            if (len < 0) {\n                uniperror(\"send\");\n                return -1;\n            }\n        }\n        if (setttl(sfd, params.def_ttl) < 0) {\n            return -1;\n        }\n    }\n    return sendto(sfd, buffer, n, 0, \n        dst, sizeof(struct sockaddr_in6));\n}\n"
        },
        {
          "name": "desync.h",
          "type": "blob",
          "size": 0.4775390625,
          "content": "#ifndef DESYNC_H\n#define DESYNC_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n#ifdef _WIN32\n    #include <winsock2.h>\n#else\n    #include <sys/socket.h>\n#endif\n\nssize_t desync(int sfd, char *buffer, size_t bfsize, ssize_t n, ssize_t offset, int dp_c);\n\nssize_t desync_udp(int sfd, char *buffer, ssize_t n, const struct sockaddr *dst, int dp_c);\n\nint setttl(int fd, int ttl);\n\nint post_desync(int sfd, int dp_c);\n\nstruct proto_info {\n    char init, type;\n    int host_len, host_pos;\n};\n#endif\n"
        },
        {
          "name": "dist",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.h",
          "type": "blob",
          "size": 2.3408203125,
          "content": "#ifndef CIADPI_ERROR_H\n#define CIADPI_ERROR_H\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#ifdef _WIN32\n    #include <winsock2.h>\n#endif\n#ifdef ANDROID_APP\n    #include <android/log.h>\n#endif\n\n#include \"params.h\"\n\n#ifdef _WIN32\n#define get_e() \\\n    unie(WSAGetLastError())\n#else\n#define get_e() \\\n    errno\n#endif\n\n#ifdef _WIN32\n    #define uniperror(str) \\\n        fprintf(stderr, \"%s: %ld\\n\", str, GetLastError())\n#else\n    #ifdef ANDROID_APP\n    #define uniperror(str) \\\n        __android_log_print(ANDROID_LOG_ERROR, \"proxy\", \\\n            \"%s: %s\\n\", str, strerror(errno))\n    #else\n    #define uniperror(str) \\\n        perror(str)\n    #endif\n#endif\n\nstatic int unie(int e)\n{\n    #ifdef _WIN32\n    switch (e) {\n        case WSAEWOULDBLOCK:\n            return EAGAIN;\n        case WSAETIMEDOUT:\n            return ETIMEDOUT;\n        case WSAENETUNREACH:\n            return ENETUNREACH;\n        case WSAEHOSTUNREACH:\n            return EHOSTUNREACH;\n        case WSAECONNREFUSED:\n            return ECONNREFUSED;\n        case WSAECONNRESET:\n            return ECONNRESET;\n    }\n    #endif\n    return e;\n}\n\n#ifdef ANDROID_APP\n    #define LOG_E ANDROID_LOG_ERROR\n    #define LOG_S ANDROID_LOG_DEBUG\n    #define LOG_L ANDROID_LOG_VERBOSE\n    #define LOG(s, str, ...) \\\n        __android_log_print(s, \"proxy\", str, ##__VA_ARGS__)\n#else\n    #define LOG_E -1\n    #define LOG_S 1\n    #define LOG_L 2\n    static void LOG(int s, char *str, ...) {\n        if (params.debug >= s) {\n            va_list args;\n            va_start(args, str);\n            vfprintf(stderr, str, args);\n        }\n    }\n#endif\n\n#define INIT_ADDR_STR(dst) \\\n    char ADDR_STR[INET6_ADDRSTRLEN]; \\\n    const char *p = 0; \\\n    if (dst.sa.sa_family == AF_INET) \\\n        p = inet_ntop(AF_INET, &dst.in.sin_addr, ADDR_STR, sizeof(ADDR_STR)); \\\n    else \\\n        p = inet_ntop(AF_INET6, &dst.in6.sin6_addr, ADDR_STR, sizeof(ADDR_STR)); \\\n    if (!p) uniperror(\"inet_ntop\");\n\n#endif\n\n#define INIT_HEX_STR(b, s) \\\n    char HEX_STR[s * 2 + 1]; \\\n    HEX_STR[sizeof(HEX_STR) - 1] = 0; \\\n    do { \\\n        ssize_t i; \\\n        for (i = 0; i + 4 <= s; i += 4) \\\n            snprintf(HEX_STR + i * 2, sizeof(HEX_STR) - i * 2, \\\n                \"%02x%02x%02x%02x\", b[i],b[i+1],b[i+2],b[i+3]); \\\n        for (; i < s; i++) \\\n            snprintf(HEX_STR + i * 2, sizeof(HEX_STR) - i * 2, \"%02x\", b[i]); \\\n    } while (0);\n"
        },
        {
          "name": "extend.c",
          "type": "blob",
          "size": 15.208984375,
          "content": "#include \"extend.h\"\n\n#ifdef _WIN32\n    #include <ws2tcpip.h>\n    \n    #ifndef TCP_MAXRT\n    #define TCP_MAXRT 5\n    #endif\n#else\n    #include <arpa/inet.h>\n    #include <netinet/tcp.h>\n    #include <sys/un.h>\n    #include <sys/time.h>\n#endif\n\n#include <string.h>\n#include <assert.h>\n\n#include \"proxy.h\"\n#include \"error.h\"\n#include \"params.h\"\n\n#include \"desync.h\"\n#include \"packets.h\"\n\n#define KEY_SIZE sizeof(union sockaddr_u)\n\n\nstatic int set_timeout(int fd, unsigned int s)\n{\n    #ifdef __linux__\n    if (setsockopt(fd, IPPROTO_TCP,\n            TCP_USER_TIMEOUT, (char *)&s, sizeof(s))) {\n        uniperror(\"setsockopt TCP_USER_TIMEOUT\");\n        return -1;\n    }\n    #else\n    #ifdef _WIN32\n    if (setsockopt(fd, IPPROTO_TCP,\n            TCP_MAXRT, (char *)&s, sizeof(s))) {\n        uniperror(\"setsockopt TCP_MAXRT\");\n        return -1;\n    }\n    #endif\n    #endif\n    return 0;\n}\n\n\nstatic ssize_t serialize_addr(const union sockaddr_u *dst,\n        uint8_t *const out, const size_t out_len)\n{\n    #define serialize(raw, field, len, counter){ \\\n        const size_t size = sizeof(field); \\\n        if ((counter + size) <= len) { \\\n            memcpy(raw + counter, &(field), size); \\\n            counter += size; \\\n        } else return 0; \\\n    }\n    size_t c = 0;\n    serialize(out, dst->in.sin_port, out_len, c);\n    serialize(out, dst->sa.sa_family, out_len, c);\n    \n    if (dst->sa.sa_family == AF_INET) {\n        serialize(out, dst->in.sin_addr, out_len, c);\n    } else {\n        serialize(out, dst->in6.sin6_addr, out_len, c);\n    }\n    #undef serialize\n\n    return c;\n}\n\n\nstatic int cache_get(const union sockaddr_u *dst)\n{\n    uint8_t key[KEY_SIZE] = { 0 };\n    int len = serialize_addr(dst, key, sizeof(key));\n    \n    struct elem_i *val = (struct elem_i *)mem_get(params.mempool, (char *)key, len);\n    if (!val) {\n        return -1;\n    }\n    time_t t = time(0);\n    if (t > val->time + params.cache_ttl) {\n        LOG(LOG_S, \"time=%jd, now=%jd, ignore\\n\", (intmax_t)val->time, (intmax_t)t);\n        return 0;\n    }\n    return val->m;\n}\n\n\nstatic int cache_add(const union sockaddr_u *dst, int m)\n{\n    assert(m >= 0 && m < params.dp_count);\n    \n    uint8_t key[KEY_SIZE] = { 0 };\n    int len = serialize_addr(dst, key, sizeof(key));\n    \n    INIT_ADDR_STR((*dst));\n    if (m == 0) {\n        LOG(LOG_S, \"delete ip: %s\\n\", ADDR_STR);\n        mem_delete(params.mempool, (char *)key, len);\n        return 0;\n    }\n    LOG(LOG_S, \"save ip: %s, m=%d\\n\", ADDR_STR, m);\n    time_t t = time(0);\n    \n    char *key_d = malloc(len);\n    if (!key_d) {\n        return -1;\n    }\n    memcpy(key_d, key, len);\n    \n    struct elem_i *val = (struct elem_i *)mem_add(params.mempool, key_d, len, sizeof(struct elem_i));\n    if (!val) {\n        uniperror(\"mem_add\");\n        free(key_d);\n        return -1;\n    }\n    val->m = m;\n    val->time = t;\n    return 0;\n}\n\n\nint connect_hook(struct poolhd *pool, struct eval *val, \n        const union sockaddr_u *dst, int next)\n{\n    int m = cache_get(dst);\n    val->cache = (m == 0);\n    val->attempt = m < 0 ? 0 : m;\n    \n    return create_conn(pool, val, dst, next);\n}\n\n\nint socket_mod(int fd)\n{\n    if (params.custom_ttl) {\n        if (setttl(fd, params.def_ttl) < 0) {\n            return -1;\n        }\n    }\n    if (params.protect_path) {\n        return protect(fd, params.protect_path);\n    }\n    return 0;\n}\n\n\nstatic int reconnect(struct poolhd *pool, struct eval *val, int m)\n{\n    assert(val->flag == FLAG_CONN);\n    \n    struct eval *client = val->pair;\n    \n    if (create_conn(pool, client, &val->addr, EV_FIRST_TUNNEL)) {\n        return -1;\n    }\n    val->pair = 0;\n    del_event(pool, val);\n    \n    //client->type = EV_IGNORE;\n    client->attempt = m;\n    client->cache = 1;\n    client->buff.offset = 0;\n    client->round_sent = 0;\n    return 0;\n}\n\n\nstatic bool check_host(\n        struct mphdr *hosts, const char *buffer, ssize_t n)\n{\n    char *host = 0;\n    int len;\n    if (!(len = parse_tls(buffer, n, &host))) {\n        len = parse_http(buffer, n, &host, 0);\n    }\n    assert(len == 0 || host != 0);\n    if (len <= 0) {\n        return 0;\n    }\n    struct elem *v = mem_get(hosts, host, len);\n    return v && v->len <= len;\n}\n\n\nstatic bool check_ip(\n        struct mphdr *ipset, const union sockaddr_u *dst)\n{\n    int len = sizeof(dst->in.sin_addr);\n    char *data = (char *)&dst->in.sin_addr;\n    \n    if (dst->sa.sa_family == AF_INET6) {\n        len = sizeof(dst->in6.sin6_addr);\n        data = (char *)&dst->in6.sin6_addr;\n    }\n    if (mem_get(ipset, data, len * 8)) {\n        return 1;\n    }\n    return 0;\n}\n\n\nstatic bool check_proto_tcp(int proto, const char *buffer, ssize_t n)\n{\n    if (!(proto & ~IS_IPV4)) {\n        return 1;\n    }\n    else if ((proto & IS_HTTP) && \n            is_http(buffer, n)) {\n        return 1;\n    }\n    else if ((proto & IS_HTTPS) && \n            is_tls_chello(buffer, n)) {\n        return 1;\n    }\n    return 0;\n}\n\n\nstatic bool check_l34(struct desync_params *dp, int st, const union sockaddr_u *dst)\n{\n    if ((dp->proto & IS_UDP) && (st != SOCK_DGRAM)) {\n        return 0;\n    }\n    if (dp->proto & IS_IPV4) {\n        static const char *pat = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\xff\\xff\";\n        \n        if (dst->sa.sa_family != AF_INET \n                && memcmp(&dst->in6.sin6_addr, pat, 12)) {\n            return 0;\n        }\n    }\n    if (dp->pf[0] && \n            (dst->in.sin_port < dp->pf[0] || dst->in.sin_port > dp->pf[1])) {\n        return 0;\n    }\n    if (dp->ipset && !check_ip(dp->ipset, dst)) {\n        return 0;\n    }\n    return 1;\n}\n\n\nstatic bool check_round(const int *nr, int r)\n{\n    return (!nr[1] && r <= 1) || (r >= nr[0] && r <= nr[1]);\n}\n\n\nstatic int on_trigger(int type, struct poolhd *pool, struct eval *val)\n{\n    int m = val->pair->attempt + 1;\n    \n    bool can_reconn = (\n        val->pair->buff.data && !val->recv_count\n        && params.auto_level > AUTO_NOBUFF\n    );\n    if (!can_reconn && params.auto_level <= AUTO_NOSAVE) {\n        return -1;\n    }\n    for (; m < params.dp_count; m++) {\n        struct desync_params *dp = &params.dp[m];\n        if (!dp->detect) {\n            break;\n        }\n        if (!(dp->detect & type)) {\n            continue;\n        }\n        if (can_reconn) {\n            return reconnect(pool, val, m);\n        }\n        cache_add(&val->addr, m);\n        break;\n    }\n    if (m >= params.dp_count && m > 1) {\n        cache_add(&val->addr, 0);\n    }\n    return -1;\n}\n\n\nstatic int on_torst(struct poolhd *pool, struct eval *val)\n{\n    if (on_trigger(DETECT_TORST, pool, val) == 0) {\n        return 0;\n    }\n    struct linger l = { .l_onoff = 1 };\n    if (setsockopt(val->pair->fd, SOL_SOCKET,\n            SO_LINGER, (char *)&l, sizeof(l)) < 0) {\n        uniperror(\"setsockopt SO_LINGER\");\n    }\n    return -1;\n}\n\n\nstatic int on_fin(struct poolhd *pool, struct eval *val)\n{\n    if (!(val->pair->mark && val->round_count <= 1)) {\n        return -1;\n    }\n    if (on_trigger(DETECT_TLS_ERR, pool, val) == 0) {\n        return 0;\n    }\n    return -1;\n}\n\n\nstatic int on_response(struct poolhd *pool, struct eval *val, \n        const char *resp, ssize_t sn)\n{\n    int m = val->pair->attempt + 1;\n    \n    char *req = val->pair->buff.data;\n    ssize_t qn = val->pair->buff.size;\n    \n    for (; m < params.dp_count; m++) {\n        struct desync_params *dp = &params.dp[m];\n        if (!dp->detect) {\n            return -1;\n        }\n        if ((dp->detect & DETECT_HTTP_LOCAT)\n                && is_http_redirect(req, qn, resp, sn)) {\n            break;\n        }\n        else if ((dp->detect & DETECT_TLS_ERR)\n                && ((is_tls_chello(req, qn) && !is_tls_shello(resp, sn))\n                    || neq_tls_sid(req, qn, resp, sn))) {\n            break;\n        }\n    }\n    if (m < params.dp_count) {\n        return reconnect(pool, val, m);\n    }\n    return -1;\n}\n\n\nstatic inline void free_first_req(struct eval *client)\n{\n    client->type = EV_TUNNEL;\n    client->pair->type = EV_TUNNEL;\n    \n    free(client->buff.data);\n    memset(&client->buff, 0, sizeof(client->buff));\n}\n\n\nstatic int setup_conn(struct eval *client, const char *buffer, ssize_t n)\n{\n    int m = client->attempt;\n    \n    if (!m) for (; m < params.dp_count; m++) {\n        struct desync_params *dp = &params.dp[m];\n        if (!dp->detect \n                && check_l34(dp, SOCK_STREAM, &client->pair->addr)\n                && check_proto_tcp(dp->proto, buffer, n) \n                && (!dp->hosts || check_host(dp->hosts, buffer, n))) {\n            break;\n        }\n    }\n    if (m >= params.dp_count) {\n        LOG(LOG_E, \"drop connection (m=%d)\\n\", m);\n        return -1;\n    }\n    if (params.auto_level > AUTO_NOBUFF && params.dp_count > 1) {\n        client->mark = is_tls_chello(buffer, n);\n    }\n    client->attempt = m;\n    \n    if (params.timeout \n            && set_timeout(client->pair->fd, params.timeout)) {\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic int cancel_setup(struct eval *remote)\n{\n    if (params.timeout && params.auto_level <= AUTO_NOSAVE &&\n            set_timeout(remote->fd, 0)) {\n        return -1;\n    }\n    if (post_desync(remote->fd, remote->pair->attempt)) {\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic int send_saved_req(struct poolhd *pool,\n        struct eval *client, char *buffer, ssize_t bfsize)\n{\n    ssize_t offset = client->buff.offset;\n    ssize_t n = client->buff.size - offset;\n    assert(bfsize >= n);\n    memcpy(buffer, client->buff.data + offset, n);\n    \n    ssize_t sn = tcp_send_hook(client->pair, buffer, bfsize, n);\n    if (sn < 0) {\n        return -1;\n    }\n    client->buff.offset += sn;\n    if (sn < n) {\n        if (mod_etype(pool, client->pair, POLLOUT) ||\n                mod_etype(pool, client, 0)) {\n            uniperror(\"mod_etype\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\nint on_first_tunnel(struct poolhd *pool,\n        struct eval *val, char *buffer, size_t bfsize, int etype)\n{\n    if ((etype & POLLOUT) && val->flag == FLAG_CONN) {\n        if (mod_etype(pool, val, POLLIN) ||\n                mod_etype(pool, val->pair, POLLIN)) {\n            uniperror(\"mod_etype\");\n            return -1;\n        }\n        val->pair->type = EV_FIRST_TUNNEL;\n        return send_saved_req(pool, val->pair, buffer, bfsize);\n    }\n    ssize_t n = tcp_recv_hook(pool, val, buffer, bfsize);\n    if (n < 1) {\n        return n;\n    }\n    if (val->flag != FLAG_CONN) {\n        val->buff.size += n;\n        \n        if (val->buff.size >= bfsize) {\n            free_first_req(val);\n        } \n        else {\n            val->buff.data = realloc(val->buff.data, val->buff.size);\n            \n            if (val->buff.data == 0) {\n                uniperror(\"realloc\");\n                return -1;\n            }\n            memcpy(val->buff.data + val->buff.size - n, buffer, n);\n            return send_saved_req(pool, val, buffer, bfsize);\n        }\n    }\n    else {\n        if (on_response(pool, val, buffer, n) == 0) {\n            return 0;\n        }\n        free_first_req(val->pair);\n        int m = val->pair->attempt;\n        \n        if (val->pair->cache && cache_add(&val->addr, m) < 0) {\n            return -1;\n        }\n    }\n    if (tcp_send_hook(val->pair, buffer, bfsize, n) < n) {\n        return -1;\n    }\n    return 0;\n}\n\n\nssize_t tcp_send_hook(struct eval *remote,\n        char *buffer, size_t bfsize, ssize_t n)\n{\n    ssize_t sn = -1;\n    int skip = remote->flag != FLAG_CONN; \n    \n    if (!skip) {\n        struct eval *client = remote->pair;\n    \n        if (client->recv_count == n \n                && setup_conn(client, buffer, n) < 0) {\n            return -1;\n        }\n        int m = client->attempt, r = client->round_count;\n        if (!check_round(params.dp[m].rounds, r)) {\n            skip = 1;\n        }\n        else {\n            LOG(LOG_S, \"desync TCP: group=%d, round=%d, fd=%d\\n\", m, r, remote->fd);\n            \n            ssize_t offset = remote->pair->round_sent;\n            if (!offset && remote->round_count) offset = -1;\n            \n            sn = desync(remote->fd, \n                buffer, bfsize, n, offset, m);\n        }\n    }\n    if (skip) {\n        sn = send(remote->fd, buffer, n, 0);\n        if (sn < 0 && get_e() == EAGAIN) {\n            return 0;\n        }\n    }\n    remote->pair->round_sent += sn;\n    return sn;\n}\n\n\nssize_t tcp_recv_hook(struct poolhd *pool, \n        struct eval *val, char *buffer, size_t bfsize)\n{\n    ssize_t n = recv(val->fd, buffer, bfsize, 0);\n    if (n < 1) {\n        if (!n) {\n            if (val->flag != FLAG_CONN) {\n                val = val->pair;\n            }\n            return on_fin(pool, val);\n        }\n        if (get_e() == EAGAIN) {\n            return 0;\n        }\n        uniperror(\"recv\");\n        switch (get_e()) {\n            case ECONNRESET:\n            case ECONNREFUSED:\n            case ETIMEDOUT: \n                if (val->flag == FLAG_CONN)\n                    return on_torst(pool, val);\n                else\n                    return on_fin(pool, val->pair);\n        }\n        return -1;\n    }\n    val->recv_count += n;\n    if (val->round_sent == 0) {\n        val->round_count++;\n        val->pair->round_sent = 0;\n    }\n    if (val->flag == FLAG_CONN && !val->round_sent) {\n        int *nr = params.dp[val->pair->attempt].rounds;\n        \n        if (check_round(nr, val->round_count)\n                && !check_round(nr, val->round_count + 1)\n                && cancel_setup(val)) {\n            return -1;\n        }\n    }\n    return n;\n}\n\n\nssize_t udp_hook(struct eval *val, \n        char *buffer, ssize_t n, const union sockaddr_u *dst)\n{\n    struct eval *pair = val->pair->pair;\n    \n    int m = pair->attempt, r = pair->round_count;\n    if (!m) {\n        for (; m < params.dp_count; m++) {\n            struct desync_params *dp = &params.dp[m];\n            if (!dp->detect \n                    && check_l34(dp, SOCK_DGRAM, dst)) {\n                break;\n            }\n        }\n        if (m >= params.dp_count) {\n            return -1;\n        }\n        pair->attempt = m;\n    }\n    if (!check_round(params.dp[m].rounds, r)) {\n        return send(val->fd, buffer, n, 0);\n    }\n    LOG(LOG_S, \"desync UDP: group=%d, round=%d, fd=%d\\n\", m, r, val->fd);\n    return desync_udp(val->fd, buffer, n, &dst->sa, m);\n}\n\n\n#ifdef __linux__\nstatic int protect(int conn_fd, const char *path)\n{\n    struct sockaddr_un sa;\n    sa.sun_family = AF_UNIX;\n    strcpy(sa.sun_path, path);\n    \n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n        uniperror(\"socket\");  \n        return -1;\n    }\n    struct timeval tv = { .tv_sec = 1 };\n    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n    setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n    \n    int err = connect(fd, (struct sockaddr *)&sa, sizeof(sa));\n    if (err) {\n        uniperror(\"connect\");\n        close(fd);\n        return -1;\n    }\n    char buf[CMSG_SPACE(sizeof(fd))] = { 0 };\n    struct iovec io = { .iov_base = \"1\", .iov_len = 1 };\n    struct msghdr msg = { .msg_iov = &io };\n    \n    msg.msg_iovlen = 1;\n    msg.msg_control = buf;\n    msg.msg_controllen = sizeof(buf);\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(conn_fd));\n\n    *((int *)CMSG_DATA(cmsg)) = conn_fd;\n    msg.msg_controllen = CMSG_SPACE(sizeof(conn_fd));\n\n    if (sendmsg(fd, &msg, 0) < 0) {\n        uniperror(\"sendmsg\");\n        close(fd);\n        return -1;\n    }\n    if (recv(fd, buf, 1, 0) < 1) {\n        uniperror(\"recv\");\n        close(fd);\n        return -1;\n    }\n    close(fd);\n    return 0;\n}\n#endif\n"
        },
        {
          "name": "extend.h",
          "type": "blob",
          "size": 0.7373046875,
          "content": "#ifndef EXTEND_H\n#define EXTEND_H\n\n#include <stddef.h>\n\n#include \"proxy.h\"\n\nint socket_mod(int fd);\n\nint connect_hook(struct poolhd *pool, struct eval *val, \n        const union sockaddr_u *dst, int next);\n        \nssize_t tcp_send_hook(struct eval *val,\n        char *buffer, size_t bfsize, ssize_t n);\n        \nssize_t tcp_recv_hook(struct poolhd *pool, struct eval *val,\n        char *buffer, size_t bfsize);\n        \nssize_t udp_hook(struct eval *val, \n        char *buffer, ssize_t n, const union sockaddr_u *dst);\n\nint on_first_tunnel(struct poolhd *pool,\n        struct eval *val, char *buffer, size_t bfsize, int etype);\n        \n#ifdef __linux__\nstatic int protect(int conn_fd, const char *path);\n#else\n#define protect(fd, path) 0\n#endif\n\n#endif\n"
        },
        {
          "name": "kavl.h",
          "type": "blob",
          "size": 12.9189453125,
          "content": "/* The MIT License\n\n   Copyright (c) 2018 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* An example:\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"kavl.h\"\n\nstruct my_node {\n  char key;\n  KAVL_HEAD(struct my_node) head;\n};\n#define my_cmp(p, q) (((q)->key < (p)->key) - ((p)->key < (q)->key))\nKAVL_INIT(my, struct my_node, head, my_cmp)\n\nint main(void) {\n  const char *str = \"MNOLKQOPHIA\"; // from wiki, except a duplicate\n  struct my_node *root = 0;\n  int i, l = strlen(str);\n  for (i = 0; i < l; ++i) {        // insert in the input order\n    struct my_node *q, *p = malloc(sizeof(*p));\n    p->key = str[i];\n    q = kavl_insert(my, &root, p, 0);\n    if (p != q) free(p);           // if already present, free\n  }\n  kavl_itr_t(my) itr;\n  kavl_itr_first(my, root, &itr);  // place at first\n  do {                             // traverse\n    const struct my_node *p = kavl_at(&itr);\n    putchar(p->key);\n    free((void*)p);                // free node\n  } while (kavl_itr_next(my, &itr));\n  putchar('\\n');\n  return 0;\n}\n*/\n\n#ifndef KAVL_H\n#define KAVL_H\n\n#ifdef __STRICT_ANSI__\n#define inline __inline__\n#endif\n\n#define KAVL_MAX_DEPTH 64\n\n#define kavl_size(head, p) ((p)? (p)->head.size : 0)\n#define kavl_size_child(head, q, i) ((q)->head.p[(i)]? (q)->head.p[(i)]->head.size : 0)\n\n#define KAVL_HEAD(__type) \\\n\tstruct { \\\n\t\t__type *p[2]; \\\n\t\tsigned char balance; /* balance factor */ \\\n\t\tunsigned size; /* #elements in subtree */ \\\n\t}\n\n#define __KAVL_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__scope __type *kavl_find_##suf(const __type *root, const __type *x, unsigned *cnt_) { \\\n\t\tconst __type *p = root; \\\n\t\tunsigned cnt = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\treturn (__type*)p; \\\n\t}\n\n#define __KAVL_ROTATE(suf, __type, __head) \\\n\t/* one rotation: (a,(b,c)q)p => ((a,b)p,c)q */ \\\n\tstatic inline __type *kavl_rotate1_##suf(__type *p, int dir) { /* dir=0 to left; dir=1 to right */ \\\n\t\tint opp = 1 - dir; /* opposite direction */ \\\n\t\t__type *q = p->__head.p[opp]; \\\n\t\tunsigned size_p = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - kavl_size_child(__head, q, dir); \\\n\t\tq->__head.size = size_p; \\\n\t\tp->__head.p[opp] = q->__head.p[dir]; \\\n\t\tq->__head.p[dir] = p; \\\n\t\treturn q; \\\n\t} \\\n\t/* two consecutive rotations: (a,((b,c)r,d)q)p => ((a,b)p,(c,d)q)r */ \\\n\tstatic inline __type *kavl_rotate2_##suf(__type *p, int dir) { \\\n\t\tint b1, opp = 1 - dir; \\\n\t\t__type *q = p->__head.p[opp], *r = q->__head.p[dir]; \\\n\t\tunsigned size_x_dir = kavl_size_child(__head, r, dir); \\\n\t\tr->__head.size = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - size_x_dir; \\\n\t\tq->__head.size -= size_x_dir + 1; \\\n\t\tp->__head.p[opp] = r->__head.p[dir]; \\\n\t\tr->__head.p[dir] = p; \\\n\t\tq->__head.p[dir] = r->__head.p[opp]; \\\n\t\tr->__head.p[opp] = q; \\\n\t\tb1 = dir == 0? +1 : -1; \\\n\t\tif (r->__head.balance == b1) q->__head.balance = 0, p->__head.balance = -b1; \\\n\t\telse if (r->__head.balance == 0) q->__head.balance = p->__head.balance = 0; \\\n\t\telse q->__head.balance = b1, p->__head.balance = 0; \\\n\t\tr->__head.balance = 0; \\\n\t\treturn r; \\\n\t}\n\n#define __KAVL_INSERT(suf, __scope, __type, __head, __cmp) \\\n\t__scope __type *kavl_insert_##suf(__type **root_, __type *x, unsigned *cnt_) { \\\n\t\tunsigned char stack[KAVL_MAX_DEPTH]; \\\n\t\t__type *path[KAVL_MAX_DEPTH]; \\\n\t\t__type *bp, *bq; \\\n\t\t__type *p, *q, *r = 0; /* _r_ is potentially the new root */ \\\n\t\tint i, which = 0, top, b1, path_len; \\\n\t\tunsigned cnt = 0; \\\n\t\tbp = *root_, bq = 0; \\\n\t\t/* find the insertion location */ \\\n\t\tfor (p = bp, q = bq, top = path_len = 0; p; q = p, p = p->__head.p[which]) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp == 0) { \\\n\t\t\t\tif (cnt_) *cnt_ = cnt; \\\n\t\t\t\treturn p; \\\n\t\t\t} \\\n\t\t\tif (p->__head.balance != 0) \\\n\t\t\t\tbq = q, bp = p, top = 0; \\\n\t\t\tstack[top++] = which = (cmp > 0); \\\n\t\t\tpath[path_len++] = p; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tx->__head.balance = 0, x->__head.size = 1, x->__head.p[0] = x->__head.p[1] = 0; \\\n\t\tif (q == 0) *root_ = x; \\\n\t\telse q->__head.p[which] = x; \\\n\t\tif (bp == 0) return x; \\\n\t\tfor (i = 0; i < path_len; ++i) ++path[i]->__head.size; \\\n\t\tfor (p = bp, top = 0; p != x; p = p->__head.p[stack[top]], ++top) /* update balance factors */ \\\n\t\t\tif (stack[top] == 0) --p->__head.balance; \\\n\t\t\telse ++p->__head.balance; \\\n\t\tif (bp->__head.balance > -2 && bp->__head.balance < 2) return x; /* no re-balance needed */ \\\n\t\t/* re-balance */ \\\n\t\twhich = (bp->__head.balance < 0); \\\n\t\tb1 = which == 0? +1 : -1; \\\n\t\tq = bp->__head.p[1 - which]; \\\n\t\tif (q->__head.balance == b1) { \\\n\t\t\tr = kavl_rotate1_##suf(bp, which); \\\n\t\t\tq->__head.balance = bp->__head.balance = 0; \\\n\t\t} else r = kavl_rotate2_##suf(bp, which); \\\n\t\tif (bq == 0) *root_ = r; \\\n\t\telse bq->__head.p[bp != bq->__head.p[0]] = r; \\\n\t\treturn x; \\\n\t}\n\n#define __KAVL_ERASE(suf, __scope, __type, __head, __cmp) \\\n\t__scope __type *kavl_erase_##suf(__type **root_, const __type *x, unsigned *cnt_) { \\\n\t\t__type *p, *path[KAVL_MAX_DEPTH], fake; \\\n\t\tunsigned char dir[KAVL_MAX_DEPTH]; \\\n\t\tint i, d = 0, cmp; \\\n\t\tunsigned cnt = 0; \\\n\t\tfake.__head.p[0] = *root_, fake.__head.p[1] = 0; \\\n\t\tif (cnt_) *cnt_ = 0; \\\n\t\tif (x) { \\\n\t\t\tfor (cmp = -1, p = &fake; cmp; cmp = __cmp(x, p)) { \\\n\t\t\t\tint which = (cmp > 0); \\\n\t\t\t\tif (cmp > 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\t\tdir[d] = which; \\\n\t\t\t\tpath[d++] = p; \\\n\t\t\t\tp = p->__head.p[which]; \\\n\t\t\t\tif (p == 0) { \\\n\t\t\t\t\tif (cnt_) *cnt_ = 0; \\\n\t\t\t\t\treturn 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\tcnt += kavl_size_child(__head, p, 0) + 1; /* because p==x is not counted */ \\\n\t\t} else { \\\n\t\t\tfor (p = &fake, cnt = 1; p; p = p->__head.p[0]) \\\n\t\t\t\tdir[d] = 0, path[d++] = p; \\\n\t\t\tp = path[--d]; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tfor (i = 1; i < d; ++i) --path[i]->__head.size; \\\n\t\tif (p->__head.p[1] == 0) { /* ((1,.)2,3)4 => (1,3)4; p=2 */ \\\n\t\t\tpath[d-1]->__head.p[dir[d-1]] = p->__head.p[0]; \\\n\t\t} else { \\\n\t\t\t__type *q = p->__head.p[1]; \\\n\t\t\tif (q->__head.p[0] == 0) { /* ((1,2)3,4)5 => ((1)2,4)5; p=3 */ \\\n\t\t\t\tq->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = q; \\\n\t\t\t\tpath[d] = q, dir[d++] = 1; \\\n\t\t\t\tq->__head.size = p->__head.size - 1; \\\n\t\t\t} else { /* ((1,((.,2)3,4)5)6,7)8 => ((1,(2,4)5)3,7)8; p=6 */ \\\n\t\t\t\t__type *r; \\\n\t\t\t\tint e = d++; /* backup _d_ */\\\n\t\t\t\tfor (;;) { \\\n\t\t\t\t\tdir[d] = 0; \\\n\t\t\t\t\tpath[d++] = q; \\\n\t\t\t\t\tr = q->__head.p[0]; \\\n\t\t\t\t\tif (r->__head.p[0] == 0) break; \\\n\t\t\t\t\tq = r; \\\n\t\t\t\t} \\\n\t\t\t\tr->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.p[0] = r->__head.p[1]; \\\n\t\t\t\tr->__head.p[1] = p->__head.p[1]; \\\n\t\t\t\tr->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[e-1]->__head.p[dir[e-1]] = r; \\\n\t\t\t\tpath[e] = r, dir[e] = 1; \\\n\t\t\t\tfor (i = e + 1; i < d; ++i) --path[i]->__head.size; \\\n\t\t\t\tr->__head.size = p->__head.size - 1; \\\n\t\t\t} \\\n\t\t} \\\n\t\twhile (--d > 0) { \\\n\t\t\t__type *q = path[d]; \\\n\t\t\tint which, other, b1 = 1, b2 = 2; \\\n\t\t\twhich = dir[d], other = 1 - which; \\\n\t\t\tif (which) b1 = -b1, b2 = -b2; \\\n\t\t\tq->__head.balance += b1; \\\n\t\t\tif (q->__head.balance == b1) break; \\\n\t\t\telse if (q->__head.balance == b2) { \\\n\t\t\t\t__type *r = q->__head.p[other]; \\\n\t\t\t\tif (r->__head.balance == -b1) { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = kavl_rotate2_##suf(q, which); \\\n\t\t\t\t} else { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = kavl_rotate1_##suf(q, which); \\\n\t\t\t\t\tif (r->__head.balance == 0) { \\\n\t\t\t\t\t\tr->__head.balance = -b1; \\\n\t\t\t\t\t\tq->__head.balance = b1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t} else r->__head.balance = q->__head.balance = 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\t*root_ = fake.__head.p[0]; \\\n\t\treturn p; \\\n\t}\n\n#define kavl_free(__type, __head, __root, __free) do { \\\n\t\t__type *_p, *_q; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t__free(_p); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define __KAVL_ITR(suf, __scope, __type, __head, __cmp) \\\n\tstruct kavl_itr_##suf { \\\n\t\tconst __type *stack[KAVL_MAX_DEPTH], **top, *right; /* _right_ points to the right child of *top */ \\\n\t}; \\\n\t__scope void kavl_itr_first_##suf(const __type *root, struct kavl_itr_##suf *itr) { \\\n\t\tconst __type *p; \\\n\t\tfor (itr->top = itr->stack - 1, p = root; p; p = p->__head.p[0]) \\\n\t\t\t*++itr->top = p; \\\n\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t} \\\n\t__scope int kavl_itr_find_##suf(const __type *root, const __type *x, struct kavl_itr_##suf *itr) { \\\n\t\tconst __type *p = root; \\\n\t\titr->top = itr->stack - 1; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) *++itr->top = p, p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (p) { \\\n\t\t\t*++itr->top = p; \\\n\t\t\titr->right = p->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} else if (itr->top >= itr->stack) { \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 0; \\\n\t\t} else return 0; \\\n\t} \\\n\t__scope int kavl_itr_next_##suf(struct kavl_itr_##suf *itr) { \\\n\t\tfor (;;) { \\\n\t\t\tconst __type *p; \\\n\t\t\tfor (p = itr->right, --itr->top; p; p = p->__head.p[0]) \\\n\t\t\t\t*++itr->top = p; \\\n\t\t\tif (itr->top < itr->stack) return 0; \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} \\\n\t}\n\n/**\n * Insert a node to the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node to insert (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return _x_ if not present in the tree, or the node equal to x.\n */\n#define kavl_insert(suf, proot, x, cnt) kavl_insert_##suf(proot, x, cnt)\n\n/**\n * Find a node in the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param x       node value to find (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return node equal to _x_ if present, or NULL if absent\n */\n#define kavl_find(suf, root, x, cnt) kavl_find_##suf(root, x, cnt)\n\n/**\n * Delete a node from the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node value to delete; if NULL, delete the first node (in)\n *\n * @return node removed from the tree if present, or NULL if absent\n */\n#define kavl_erase(suf, proot, x, cnt) kavl_erase_##suf(proot, x, cnt)\n#define kavl_erase_first(suf, proot) kavl_erase_##suf(proot, 0, 0)\n\n#define kavl_itr_t(suf) struct kavl_itr_##suf\n\n/**\n * Place the iterator at the smallest object\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param itr     iterator\n */\n#define kavl_itr_first(suf, root, itr) kavl_itr_first_##suf(root, itr)\n\n/**\n * Place the iterator at the object equal to or greater than the query\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param x       query (in)\n * @param itr     iterator (out)\n *\n * @return 1 if find; 0 otherwise. kavl_at(itr) is NULL if and only if query is\n *         larger than all objects in the tree\n */\n#define kavl_itr_find(suf, root, x, itr) kavl_itr_find_##suf(root, x, itr)\n\n/**\n * Move to the next object in order\n *\n * @param itr     iterator (modified)\n *\n * @return 1 if there is a next object; 0 otherwise\n */\n#define kavl_itr_next(suf, itr) kavl_itr_next_##suf(itr)\n\n/**\n * Return the pointer at the iterator\n *\n * @param itr     iterator\n *\n * @return pointer if present; NULL otherwise\n */\n#define kavl_at(itr) ((itr)->top < (itr)->stack? 0 : *(itr)->top)\n\n#define KAVL_INIT2(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__KAVL_ROTATE(suf, __type, __head) \\\n\t__KAVL_INSERT(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_ERASE(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_ITR(suf, __scope, __type, __head, __cmp)\n\n#define KAVL_INIT(suf, __type, __head, __cmp) \\\n\tKAVL_INIT2(suf,, __type, __head, __cmp)\n\n#endif\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 28.8125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <limits.h>\n\n#include \"params.h\"\n#include \"proxy.h\"\n#include \"packets.h\"\n#include \"error.h\"\n\n#ifndef _WIN32\n    #include <arpa/inet.h>\n    #include <unistd.h>\n    #include <netdb.h>\n    #include <fcntl.h>\n    #include <netinet/in.h>\n    #include <netinet/tcp.h>\n    #include <sys/socket.h>\n    \n    #define DAEMON\n#else\n    #include <ws2tcpip.h>\n    #include \"win_service.h\"\n    #define close(fd) closesocket(fd)\n#endif\n\n#define VERSION \"16\"\n\nASSERT(sizeof(struct in_addr) == 4)\nASSERT(sizeof(struct in6_addr) == 16)\n\n\nchar ip_option[1] = \"\\0\";\n\nstruct packet fake_tls = { \n    sizeof(tls_data), tls_data \n},\nfake_http = { \n    sizeof(http_data), http_data\n},\nfake_udp = { \n    sizeof(udp_data), udp_data\n};\n\n\nstruct params params = {\n    .wait_send = 1,\n    \n    .cache_ttl = 100800,\n    .ipv6 = 1,\n    .resolve = 1,\n    .udp = 1,\n    .max_open = 512,\n    .bfsize = 16384,\n    .baddr = {\n        .in6 = { .sin6_family = AF_INET6 }\n    },\n    .laddr = {\n        .in = { .sin_family = AF_INET }\n    },\n    .debug = 0,\n    .auto_level = AUTO_NOBUFF\n};\n\n\nstatic const char help_text[] = {\n    \"    -i, --ip, <ip>            Listening IP, default 0.0.0.0\\n\"\n    \"    -p, --port <num>          Listening port, default 1080\\n\"\n    #ifdef DAEMON\n    \"    -D, --daemon              Daemonize\\n\"\n    \"    -w, --pidfile <filename>  Write PID to file\\n\"\n    #endif\n    #ifdef __linux__\n    \"    -E, --transparent         Transparent proxy mode\\n\"\n    #endif\n    \"    -c, --max-conn <count>    Connection count limit, default 512\\n\"\n    \"    -N, --no-domain           Deny domain resolving\\n\"\n    \"    -U, --no-udp              Deny UDP association\\n\"\n    \"    -I  --conn-ip <ip>        Connection binded IP, default ::\\n\"\n    \"    -b, --buf-size <size>     Buffer size, default 16384\\n\"\n    \"    -x, --debug <level>       Print logs, 0, 1 or 2\\n\"\n    \"    -g, --def-ttl <num>       TTL for all outgoing connections\\n\"\n    // desync options\n    #ifdef TCP_FASTOPEN_CONNECT\n    \"    -F, --tfo                 Enable TCP Fast Open\\n\"\n    #endif\n    \"    -A, --auto <t,r,s,n>      Try desync params after this option\\n\"\n    \"                              Detect: torst,redirect,ssl_err,none\\n\"\n    \"    -L, --auto-mode <0|1>     1 - handle trigger after several packets\\n\"\n    \"    -u, --cache-ttl <sec>     Lifetime of cached desync params for IP\\n\"\n    #ifdef TIMEOUT_SUPPORT\n    \"    -T, --timeout <sec>       Timeout waiting for response, after which trigger auto\\n\"\n    #endif\n    \"    -K, --proto <t,h,u,i>     Protocol whitelist: tls,http,udp,ipv4\\n\"\n    \"    -H, --hosts <file|:str>   Hosts whitelist, filename or :string\\n\"\n    \"    -j, --ipset <file|:str>   IP whitelist\\n\"\n    \"    -V, --pf <port[-portr]>   Ports range whitelist\\n\"\n    \"    -R, --round <num[-numr]>  Number of request to which desync will be applied\\n\"\n    \"    -s, --split <pos_t>       Position format: offset[:repeats:skip][+flag1[flag2]]\\n\"\n    \"                              Flags: +s - SNI offset, +h - HTTP host offset, +n - null\\n\"\n    \"                              Additional flags: +e - end, +m - middle\\n\"\n    \"    -d, --disorder <pos_t>    Split and send reverse order\\n\"\n    \"    -o, --oob <pos_t>         Split and send as OOB data\\n\"\n    \"    -q, --disoob <pos_t>      Split and send reverse order as OOB data\\n\"\n    #ifdef FAKE_SUPPORT\n    \"    -f, --fake <pos_t>        Split and send fake packet\\n\"\n    \"    -t, --ttl <num>           TTL of fake packets, default 8\\n\"\n    #ifdef __linux__\n    \"    -k, --ip-opt[=f|:str]     IP options of fake packets\\n\"\n    \"    -S, --md5sig              Add MD5 Signature option for fake packets\\n\"\n    #endif\n    \"    -O, --fake-offset <n>     Fake data start offset\\n\"\n    \"    -l, --fake-data <f|:str>  Set custom fake packet\\n\"\n    \"    -n, --tls-sni <str>       Change SNI in fake ClientHello\\n\"\n    #endif\n    \"    -e, --oob-data <char>     Set custom OOB data\\n\"\n    \"    -M, --mod-http <h,d,r>    Modify HTTP: hcsmix,dcsmix,rmspace\\n\"\n    \"    -r, --tlsrec <pos_t>      Make TLS record at position\\n\"\n    \"    -a, --udp-fake <count>    UDP fakes count, default 0\\n\"\n    #ifdef __linux__\n    \"    -Y, --drop-sack           Drop packets with SACK extension\\n\"\n    #endif\n};\n\n\nconst struct option options[] = {\n    #ifdef DAEMON\n    {\"daemon\",        0, 0, 'D'},\n    {\"pidfile\",       1, 0, 'w'},\n    #endif\n    {\"no-domain\",     0, 0, 'N'},\n    {\"no-ipv6\",       0, 0, 'X'},\n    {\"no-udp\",        0, 0, 'U'},\n    {\"help\",          0, 0, 'h'},\n    {\"version\",       0, 0, 'v'},\n    {\"ip\",            1, 0, 'i'},\n    {\"port\",          1, 0, 'p'},\n    #ifdef __linux__\n    {\"transparent\",   0, 0, 'E'},\n    #endif\n    {\"conn-ip\",       1, 0, 'I'},\n    {\"buf-size\",      1, 0, 'b'},\n    {\"max-conn\",      1, 0, 'c'},\n    {\"debug\",         1, 0, 'x'},\n    \n    #ifdef TCP_FASTOPEN_CONNECT\n    {\"tfo \",          0, 0, 'F'},\n    #endif\n    {\"auto\",          1, 0, 'A'},\n    {\"auto-mode\",     1, 0, 'L'},\n    {\"cache-ttl\",     1, 0, 'u'},\n    #ifdef TIMEOUT_SUPPORT\n    {\"timeout\",       1, 0, 'T'},\n    #endif\n    {\"proto\",         1, 0, 'K'},\n    {\"hosts\",         1, 0, 'H'},\n    {\"pf\",            1, 0, 'V'},\n    {\"round\",         1, 0, 'R'},\n    {\"split\",         1, 0, 's'},\n    {\"disorder\",      1, 0, 'd'},\n    {\"oob\",           1, 0, 'o'},\n    {\"disoob\",        1, 0, 'q'},\n    #ifdef FAKE_SUPPORT\n    {\"fake\",          1, 0, 'f'},\n    {\"ttl\",           1, 0, 't'},\n    #ifdef __linux__\n    {\"ip-opt\",        2, 0, 'k'},\n    {\"md5sig\",        0, 0, 'S'},\n    #endif\n    {\"fake-data\",     1, 0, 'l'},\n    {\"tls-sni\",       1, 0, 'n'},\n    {\"fake-offset\",   1, 0, 'O'},\n    #endif\n    {\"oob-data\",      1, 0, 'e'},\n    {\"mod-http\",      1, 0, 'M'},\n    {\"tlsrec\",        1, 0, 'r'},\n    {\"udp-fake\",      1, 0, 'a'},\n    {\"def-ttl\",       1, 0, 'g'},\n    {\"not-wait-send\", 0, 0, 'W'}, //\n    #ifdef __linux__\n    {\"drop-sack\",     0, 0, 'Y'},\n    {\"protect-path\",  1, 0, 'P'}, //\n    #endif\n    {\"ipset\",         1, 0, 'j'},\n    {0}\n};\n    \n\nssize_t parse_cform(char *buffer, size_t blen, \n        const char *str, size_t slen)\n{\n    static char esca[] = {\n        'r','\\r','n','\\n','t','\\t','\\\\','\\\\',\n        'f','\\f','b','\\b','v','\\v','a','\\a', 0\n    };\n    size_t i = 0, p = 0;\n    for (; p < slen && i < blen; ++p, ++i) {\n        if (str[p] != '\\\\') {\n            buffer[i] = str[p];\n            continue;\n        }\n        p++;\n        char *e = esca;\n        for (; *e; e += 2) {\n            if (*e == str[p]) {\n                buffer[i] = *(e + 1);\n                break;\n            }\n        }\n        if (*e) {\n            continue;\n        }\n        int n = 0;\n        if (sscanf(&str[p], \"x%2hhx%n\", (uint8_t *)&buffer[i], &n) == 1\n              || sscanf(&str[p], \"%3hho%n\", (uint8_t *)&buffer[i], &n) == 1) {\n            p += (n - 1);\n            continue;\n        }\n        i--; p--;\n    }\n    return i;\n}\n\n\nchar *data_from_str(const char *str, ssize_t *size)\n{\n    ssize_t len = strlen(str);\n    if (len == 0) {\n        return 0;\n    }\n    char *d = malloc(len);\n    if (!d) {\n        return 0;\n    }\n    ssize_t i = parse_cform(d, len, str, len);\n    \n    char *m = len != i ? realloc(d, i) : 0;\n    if (i == 0) {\n        return 0;\n    }\n    *size = i;\n    return m ? m : d;\n}\n\n\nchar *ftob(const char *str, ssize_t *sl)\n{\n    if (*str == ':') {\n        return data_from_str(str + 1, sl);\n    }\n    char *buffer = 0;\n    long size;\n    \n    FILE *file = fopen(str, \"rb\");\n    if (!file) {\n        return 0;\n    }\n    do {\n        if (fseek(file, 0, SEEK_END)) {\n            break;\n        }\n        size = ftell(file);\n        if (size <= 0) {\n            break;\n        }\n        if (fseek(file, 0, SEEK_SET)) {\n            break;\n        }\n        if (!(buffer = malloc(size))) {\n            break;\n        }\n        size_t rs = fread(buffer, 1, size, file);\n        if (rs != (size_t )size) {\n            free(buffer);\n            buffer = 0;\n        }\n    } while (0);\n    if (buffer) {\n        *sl = size;\n    }\n    fclose(file);\n    return buffer;\n}\n\n\nstatic inline int lower_char(char *cl)\n{\n    char c = *cl;\n    if (c < 'A') {\n        if (c > '9' || c < '-')\n            return -1;\n    }\n    else if (c < 'a') {\n        if (c > 'Z') \n            return -1;\n        *cl = c + 32;\n    }\n    else if (c > 'z') \n        return -1;\n    return 0;\n}\n\n\nstruct mphdr *parse_hosts(char *buffer, size_t size)\n{\n    struct mphdr *hdr = mem_pool(1, CMP_HOST);\n    if (!hdr) {\n        return 0;\n    }\n    size_t num = 0;\n    bool drop = 0;\n    char *end = buffer + size;\n    char *e = buffer, *s = buffer;\n    \n    for (; e <= end; e++) {\n        if (e != end && *e != ' ' && *e != '\\n' && *e != '\\r') {\n            if (lower_char(e)) {\n                drop = 1;\n            }\n            continue;\n        }\n        if (s == e) {\n            s++;\n            continue;\n        }\n        if (!drop) {\n            if (!mem_add(hdr, s, e - s, sizeof(struct elem))) {\n                mem_destroy(hdr);\n                return 0;\n            }\n        } \n        else {\n            LOG(LOG_E, \"invalid host: num: %zd \\\"%.*s\\\"\\n\", num + 1, ((int )(e - s)), s);\n            drop = 0;\n        }\n        num++;\n        s = e + 1;\n    }\n    LOG(LOG_S, \"hosts count: %zd\\n\", hdr->count);\n    return hdr;\n}\n\n\nstatic int parse_ip(char *out, char *str, size_t size)\n{\n    long bits = 0;\n    char *sep = memchr(str, '/', size);\n    if (sep) {\n        bits = strtol(sep + 1, 0, 10);\n        if (bits <= 0) {\n            return 0;\n        }\n        *sep = 0;\n    }\n    int len = sizeof(struct in_addr);\n    \n    if (inet_pton(AF_INET, str, out) <= 0) {\n        if (inet_pton(AF_INET6, str, out) <= 0) {\n            return 0;\n        }\n        else len = sizeof(struct in6_addr);\n    }\n    if (!bits || bits > len * 8) bits = len * 8;\n    return (int )bits;\n}\n\n\nstruct mphdr *parse_ipset(char *buffer, size_t size)\n{\n    struct mphdr *hdr = mem_pool(0, CMP_BITS);\n    if (!hdr) {\n        return 0;\n    }\n    size_t num = 0;\n    char *end = buffer + size;\n    char *e = buffer, *s = buffer;\n    \n    for (; e <= end; e++) {\n        if (e != end && *e != ' ' && *e != '\\n' && *e != '\\r') {\n            continue;\n        }\n        if (s == e) {\n            s++;\n            continue;\n        }\n        char ip[e - s + 1];\n        ip[e - s] = 0;\n        memcpy(ip, s, e - s);\n        \n        num++;\n        s = e + 1;\n        \n        char ip_stack[sizeof(struct in6_addr)];\n        int bits = parse_ip(ip_stack, ip, sizeof(ip));\n        if (bits <= 0) {\n            LOG(LOG_E, \"invalid ip: num: %zd\\n\", num);\n            continue;\n        }\n        int len = bits / 8 + (bits % 8 ? 1 : 0);\n        char *ip_raw = malloc(len);\n        memcpy(ip_raw, ip_stack, len);\n        \n        struct elem *elem = mem_add(hdr, ip_raw, bits, sizeof(struct elem));\n        if (!elem) {\n            free(ip_raw);\n            mem_destroy(hdr);\n            return 0;\n        }\n    }\n    LOG(LOG_S, \"ip count: %zd\\n\", hdr->count);\n    return hdr;\n}\n\n\nint get_addr(const char *str, union sockaddr_u *addr)\n{\n    struct addrinfo hints = {0}, *res = 0;\n    \n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_flags = AI_NUMERICHOST;\n    \n    if (getaddrinfo(str, 0, &hints, &res) || !res) {\n        return -1;\n    }\n    \n    if (res->ai_addr->sa_family == AF_INET6)\n        addr->in6.sin6_addr = (\n            (struct sockaddr_in6 *)res->ai_addr)->sin6_addr;\n    else\n        addr->in.sin_addr = (\n            (struct sockaddr_in *)res->ai_addr)->sin_addr;\n    addr->sa.sa_family = res->ai_addr->sa_family;\n    \n    freeaddrinfo(res);\n    \n    return 0;\n}\n\n\nint get_default_ttl(void)\n{\n    int orig_ttl = -1, fd;\n    socklen_t tsize = sizeof(orig_ttl);\n    \n    if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        uniperror(\"socket\");\n        return -1;\n    }\n    if (getsockopt(fd, IPPROTO_IP, IP_TTL,\n             (char *)&orig_ttl, &tsize) < 0) {\n        uniperror(\"getsockopt IP_TTL\");\n    }\n    close(fd);\n    return orig_ttl;\n}\n\n\nbool ipv6_support(void)\n{\n    int fd = socket(AF_INET6, SOCK_STREAM, 0);\n    if (fd < 0) {\n        return 0;\n    }\n    close(fd);\n    return 1;\n}\n\n\nint parse_offset(struct part *part, const char *str)\n{\n    char *end = 0;\n    long val = strtol(str, &end, 0);\n    \n    while (*end == ':') {\n        long rs = strtol(end + 1, &end, 0);\n        if (rs < 0 || rs > INT_MAX) {\n            return -1;\n        }\n        if (!part->r) {\n            if (!rs) \n                return -1;\n            part->r = rs;\n        }\n        else {\n            part->s = rs;\n            break;\n        }\n    }\n    if (*end == '+') {\n        switch (*(end + 1)) {\n            case 's':\n                part->flag = OFFSET_SNI;\n                break;\n            case 'h': \n                part->flag = OFFSET_HOST;\n                break;\n            case 'n':\n                break;\n            default:\n                return -1;\n        }\n        switch (*(end + 2)) {\n            case 'e':\n                part->flag |= OFFSET_END;\n                break;\n            case 'm':\n                part->flag |= OFFSET_MID;\n                break;\n            case 'r': //\n                part->flag |= OFFSET_RAND;\n                break;\n            case 's': //\n                part->flag |= OFFSET_START;\n        }\n    }\n    part->pos = val;\n    return 0;\n}\n\n\nvoid *add(void **root, int *n, size_t ss)\n{\n    char *p = realloc(*root, ss * (*n + 1));\n    if (!p) {\n        uniperror(\"realloc\");\n        return 0;\n    }\n    *root = p;\n    p = (p + ((*n) * ss));\n    memset(p, 0, ss);\n    *n = *n + 1;\n    return p;\n}\n\n\n#ifdef DAEMON\nint init_pid_file(const char *fname)\n{\n    params.pid_fd = open(fname, O_RDWR | O_CREAT, 0640);\n    if (params.pid_fd < 0) {\n        return -1;\n    }\n    if (lockf(params.pid_fd, F_TLOCK, 0) < 0) {\n        return -1;\n    }\n    params.pid_file = fname;\n    char pid_str[21];\n    snprintf(pid_str, sizeof(pid_str), \"%d\", getpid());\n    \n    write(params.pid_fd, pid_str, strlen(pid_str));\n    return 0;\n}\n#endif\n\n\nvoid clear_params(void)\n{\n    #ifdef _WIN32\n    WSACleanup();\n    #endif\n    #ifdef DAEMON\n    if (params.pid_fd > 0) {\n        lockf(params.pid_fd, F_ULOCK, 0);\n        close(params.pid_fd);\n    }\n    if (params.pid_file) {\n        unlink(params.pid_file);\n    }\n    #endif\n    if (params.mempool) {\n        mem_destroy(params.mempool);\n        params.mempool = 0;\n    }\n    if (params.dp) {\n        for (int i = 0; i < params.dp_count; i++) {\n            struct desync_params s = params.dp[i];\n            if (s.ip_options != ip_option) {\n                free(s.ip_options);\n                s.ip_options = ip_option;\n            }\n            if (s.parts != 0) {\n                free(s.parts);\n                s.parts = 0;\n            }\n            if (s.tlsrec != 0) {\n                free(s.tlsrec);\n                s.tlsrec = 0;\n            }\n            if (s.fake_data.data != 0) {\n                free(s.fake_data.data);\n                s.fake_data.data = 0;\n            }\n            if (s.file_ptr != 0) {\n                free(s.file_ptr);\n                s.file_ptr = 0;\n            }\n            if (s.hosts != 0) {\n                mem_destroy(s.hosts);\n                s.hosts = 0;\n            }\n            if (s.ipset != 0) {\n                mem_destroy(s.ipset);\n                s.hosts = 0;\n            }\n        }\n        free(params.dp);\n        params.dp = 0;\n    }\n}\n\n\nint main(int argc, char **argv) \n{\n    #ifdef _WIN32\n    WSADATA wsa;\n    \n    if (WSAStartup(MAKEWORD(2, 2), &wsa)) {\n        uniperror(\"WSAStartup\");\n        return -1;\n    }\n    if (register_winsvc(argc, argv)) {\n        return 0;\n    }\n    #endif\n    int optc = sizeof(options)/sizeof(*options);\n    for (int i = 0, e = optc; i < e; i++)\n        optc += options[i].has_arg;\n        \n    char opt[optc + 1];\n    opt[optc] = 0;\n    \n    for (int i = 0, o = 0; o < optc; i++, o++) {\n        opt[o] = options[i].val;\n        for (int c = options[i].has_arg; c; c--) {\n            o++;\n            opt[o] = ':';\n        }\n    }\n    //\n    params.laddr.in.sin_port = htons(1080);\n    if (!ipv6_support()) {\n        params.baddr.sa.sa_family = AF_INET;\n    }\n    \n    char *pid_file = 0;\n    bool daemonize = 0;\n    \n    int rez;\n    int invalid = 0;\n    \n    long val = 0;\n    char *end = 0;\n    bool all_limited = 1;\n    \n    struct desync_params *dp = add((void *)&params.dp,\n        &params.dp_count, sizeof(struct desync_params));\n    if (!dp) {\n        clear_params();\n        return -1;\n    }\n    \n    while (!invalid && (rez = getopt_long(\n             argc, argv, opt, options, 0)) != -1) {\n\n        switch (rez) {\n        \n        case 'N':\n            params.resolve = 0;\n            break;\n        case 'X':\n            params.ipv6 = 0;\n            break;\n        case 'U':\n            params.udp = 0;\n            break;\n        #ifdef __linux__\n        case 'E':\n            params.transparent = 1;\n            break;\n        #endif\n        \n        #ifdef DAEMON\n        case 'D':\n            daemonize = 1;\n            break;\n            \n        case 'w':\n            pid_file = optarg;\n            break;\n        #endif\n        case 'h':\n            printf(help_text);\n            clear_params();\n            return 0;\n        case 'v':\n            printf(\"%s\\n\", VERSION);\n            clear_params();\n            return 0;\n        \n        case 'i':\n            if (get_addr(optarg, &params.laddr) < 0)\n                invalid = 1;\n            break;\n            \n        case 'p':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > 0xffff || *end)\n                invalid = 1;\n            else\n                params.laddr.in.sin_port = htons(val);\n            break;\n            \n        case 'I':\n            if (get_addr(optarg, &params.baddr) < 0)\n                invalid = 1;\n            break;\n            \n        case 'b':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > INT_MAX/4 || *end)\n                invalid = 1;\n            else\n                params.bfsize = val;\n            break;\n            \n        case 'c':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val >= (0xffff/2) || *end) \n                invalid = 1;\n            else\n                params.max_open = val;\n            break;\n           \n        case 'x': //\n            params.debug = strtol(optarg, 0, 0);\n            if (params.debug < 0)\n                invalid = 1;\n            break;\n            \n        // desync options\n        \n        case 'F':\n            params.tfo = 1;\n            break;\n            \n        case 'L':\n            val = strtol(optarg, &end, 0);\n            if (val < 0 || val > 1 || *end)\n                invalid = 1;\n            else\n                params.auto_level = val;\n            break;\n            \n        case 'A':\n            if (!(dp->hosts || dp->proto || dp->pf[0] || dp->detect || dp->ipset)) {\n                all_limited = 0;\n            }\n            dp = add((void *)&params.dp, &params.dp_count,\n                sizeof(struct desync_params));\n            if (!dp) {\n                clear_params();\n                return -1;\n            }\n            end = optarg;\n            while (end && !invalid) {\n                switch (*end) {\n                    case 't': \n                        dp->detect |= DETECT_TORST;\n                        break;\n                    case 'r': \n                        dp->detect |= DETECT_HTTP_LOCAT;\n                        break;\n                    case 'a':\n                    case 's': \n                        dp->detect |= DETECT_TLS_ERR;\n                        break;\n                    case 'n': \n                        break;\n                    default:\n                        invalid = 1;\n                        continue;\n                }\n                end = strchr(end, ',');\n                if (end) end++;\n            }\n            if (dp->detect && params.auto_level == AUTO_NOBUFF) {\n                params.auto_level = AUTO_NOSAVE;\n            }\n            break;\n            \n        case 'u':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || *end) \n                invalid = 1;\n            else\n                params.cache_ttl = val;\n            break;\n        \n        case 'T':;\n            #ifdef __linux__\n            float f = strtof(optarg, &end);\n            val = (long)(f * 1000);\n            #else\n            val = strtol(optarg, &end, 0);\n            #endif\n            if (val <= 0 || val > UINT_MAX || *end)\n                invalid = 1;\n            else\n                params.timeout = val;\n            break;\n            \n        case 'K':\n            end = optarg;\n            while (end && !invalid) {\n                switch (*end) {\n                    case 't': \n                        dp->proto |= IS_HTTPS;\n                        break;\n                    case 'h': \n                        dp->proto |= IS_HTTP;\n                        break;\n                    case 'u': \n                        dp->proto |= IS_UDP;\n                        break;\n                    case 'i': \n                        dp->proto |= IS_IPV4;\n                        break;\n                    default:\n                        invalid = 1;\n                        continue;\n                }\n                end = strchr(end, ',');\n                if (end) end++;\n            }\n            break;\n            \n        case 'H':;\n            if (dp->file_ptr) {\n                continue;\n            }\n            dp->file_ptr = ftob(optarg, &dp->file_size);\n            if (!dp->file_ptr) {\n                uniperror(\"read/parse\");\n                invalid = 1;\n                continue;\n            }\n            dp->hosts = parse_hosts(dp->file_ptr, dp->file_size);\n            if (!dp->hosts) {\n                uniperror(\"parse_hosts\");\n                clear_params();\n                return -1;\n            }\n            break;\n            \n        case 'j':;\n            if (dp->ipset) {\n                continue;\n            }\n            ssize_t size;\n            char *data = ftob(optarg, &size);\n            if (!data) {\n                uniperror(\"read/parse\");\n                invalid = 1;\n                continue;\n            }\n            dp->ipset = parse_ipset(data, size);\n            if (!dp->ipset) {\n                uniperror(\"parse_ipset\");\n                invalid = 1;\n            }\n            free(data);\n            break;\n            \n        case 's':\n        case 'd':\n        case 'o':\n        case 'q':\n        case 'f':\n            ;\n            struct part *part = add((void *)&dp->parts,\n                &dp->parts_n, sizeof(struct part));\n            if (!part) {\n                clear_params();\n                return -1;\n            }\n            if (parse_offset(part, optarg)) {\n                invalid = 1;\n                break;\n            }\n            switch (rez) {\n                case 's': part->m = DESYNC_SPLIT;\n                    break;\n                case 'd': part->m = DESYNC_DISORDER;\n                    break;\n                case 'o': part->m = DESYNC_OOB;\n                    break;\n                case 'q': part->m = DESYNC_DISOOB;\n                    break;\n                case 'f': part->m = DESYNC_FAKE;\n            }\n            break;\n            \n        case 't':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > 255 || *end) \n                invalid = 1;\n            else\n                dp->ttl = val;\n            break;\n            \n        case 'k':\n            if (dp->ip_options) {\n                continue;\n            }\n            if (optarg)\n                dp->ip_options = ftob(optarg, &dp->ip_options_len);\n            else {\n                dp->ip_options = ip_option;\n                dp->ip_options_len = sizeof(ip_option);\n            }\n            if (!dp->ip_options) {\n                uniperror(\"read/parse\");\n                invalid = 1;\n            }\n            break;\n            \n        case 'S':\n            dp->md5sig = 1;\n            break;\n            \n        case 'O':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || *end) \n                invalid = 1;\n            else\n                dp->fake_offset = val;\n            break;\n            \n        case 'n':\n            if (change_tls_sni(optarg, fake_tls.data, fake_tls.size)) {\n                fprintf(stderr, \"error chsni\\n\");\n                clear_params();\n                return -1;\n            }\n            printf(\"sni: %s\\n\", optarg);\n            break;\n            \n        case 'l':\n            if (dp->fake_data.data) {\n                continue;\n            }\n            dp->fake_data.data = ftob(optarg, &dp->fake_data.size);\n            if (!dp->fake_data.data) {\n                uniperror(\"read/parse\");\n                invalid = 1;\n            }\n            break;\n            \n        case 'e':\n            val = parse_cform(dp->oob_char, 1, optarg, strlen(optarg));\n            if (val != 1) {\n                invalid = 1;\n            }\n            else dp->oob_char[1] = 1;\n            break;\n            \n        case 'M':\n            end = optarg;\n            while (end && !invalid) {\n                switch (*end) {\n                    case 'r': \n                        dp->mod_http |= MH_SPACE;\n                        break;\n                    case 'h': \n                        dp->mod_http |= MH_HMIX;\n                        break;\n                    case 'd': \n                        dp->mod_http |= MH_DMIX;\n                        break;\n                    default:\n                        invalid = 1;\n                        continue;\n                }\n                end = strchr(end, ',');\n                if (end) end++;\n            }\n            break;\n            \n        case 'r':\n            part = add((void *)&dp->tlsrec,\n                &dp->tlsrec_n, sizeof(struct part));\n            if (!part) {\n                clear_params();\n                return -1;\n            }\n            if (parse_offset(part, optarg)\n                   || part->pos > 0xffff) {\n                invalid = 1;\n                break;\n            }\n            break;\n            \n        case 'a':\n            val = strtol(optarg, &end, 0);\n            if (val < 0 || val > INT_MAX || *end)\n                invalid = 1;\n            else\n                dp->udp_fake_count = val;\n            break;\n            \n        case 'V':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > USHRT_MAX)\n                invalid = 1;\n            else {\n                dp->pf[0] = htons(val);\n                if (*end == '-') {\n                    val = strtol(end + 1, &end, 0);\n                    if (val <= 0 || val > USHRT_MAX)\n                        invalid = 1;\n                }\n                if (*end)\n                    invalid = 1;\n                else\n                    dp->pf[1] = htons(val);\n            }\n            break;\n            \n        case 'R':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > INT_MAX)\n                invalid = 1;\n            else {\n                dp->rounds[0] = val;\n                if (*end == '-') {\n                    val = strtol(end + 1, &end, 0);\n                    if (val <= 0 || val > INT_MAX)\n                        invalid = 1;\n                }\n                if (*end)\n                    invalid = 1;\n                else\n                    dp->rounds[1] = val;\n            }\n            break;\n            \n        case 'g':\n            val = strtol(optarg, &end, 0);\n            if (val <= 0 || val > 255 || *end)\n                invalid = 1;\n            else {\n                params.def_ttl = val;\n                params.custom_ttl = 1;\n            }\n            break;\n            \n        case 'Y':\n            dp->drop_sack = 1;\n            break;\n        \n        case 'W':\n            params.wait_send = 0;\n            break;\n        #ifdef __linux__\n        case 'P':\n            params.protect_path = optarg;\n            break;\n        #endif\n        case 0:\n            break;\n            \n        case '?':\n            clear_params();\n            return -1;\n            \n        default: \n            printf(\"?: %c\\n\", rez);\n            clear_params();\n            return -1;\n        }\n    }\n    if (invalid) {\n        fprintf(stderr, \"invalid value: -%c %s\\n\", rez, optarg);\n        clear_params();\n        return -1;\n    }\n    if (all_limited) {\n        dp = add((void *)&params.dp,\n            &params.dp_count, sizeof(struct desync_params));\n        if (!dp) {\n            clear_params();\n            return -1;\n        }\n    }\n    \n    if (params.baddr.sa.sa_family != AF_INET6) {\n        params.ipv6 = 0;\n    }\n    if (!params.def_ttl) {\n        if ((params.def_ttl = get_default_ttl()) < 1) {\n            clear_params();\n            return -1;\n        }\n    }\n    params.mempool = mem_pool(0, CMP_BYTES);\n    if (!params.mempool) {\n        uniperror(\"mem_pool\");\n        clear_params();\n        return -1;\n    }\n    srand((unsigned int)time(0));\n    \n    #ifdef DAEMON\n    if (daemonize && daemon(0, 0) < 0) {\n        clear_params();\n        return -1;\n    }\n    if (pid_file && init_pid_file(pid_file) < 0) {\n        clear_params();\n        return -1;\n    }\n    #endif\n    int status = run(&params.laddr);\n    clear_params();\n    return status;\n}\n"
        },
        {
          "name": "mpool.c",
          "type": "blob",
          "size": 3.087890625,
          "content": "#include \"mpool.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n\nstatic int bit_cmp(const struct elem *p, const struct elem *q)\n{\n    int len = q->len < p->len ? q->len : p->len;\n    int df = len % 8, bytes = len / 8;\n    int cmp = memcmp(p->data, q->data, bytes);\n    \n    if (cmp || !df) {\n        return cmp;\n    }\n    uint8_t c1 = p->data[bytes] >> (8 - df);\n    uint8_t c2 = q->data[bytes] >> (8 - df);\n    if (c1 != c2) {\n        if (c1 < c2) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\n\nstatic int byte_cmp(const struct elem *p, const struct elem *q)\n{\n    if (p->len != q->len) {\n        return p->len < q->len ? -1 : 1;\n    }\n    return memcmp(p->data, q->data, p->len);\n}\n\n\nstatic int host_cmp(const struct elem *p, const struct elem *q)\n{\n    int len = q->len < p->len ? q->len : p->len;\n    char *pd = p->data + p->len, *qd = q->data + q->len;\n    \n    while (len-- > 0) {\n        if (*--pd != *--qd) {\n            return *pd < *qd ? -1 : 1;\n        }\n    }\n    if (p->len == q->len \n            || (p->len > q->len ? pd[-1] : qd[-1]) == '.')\n        return 0;\n    \n    return p->len > q->len ? 1 : -1;\n}\n\n\nstatic int scmp(const struct elem *p, const struct elem *q)\n{\n    switch (p->cmp_type) {\n    case CMP_BITS:\n        return bit_cmp(p, q);\n    case CMP_HOST:\n        return host_cmp(p, q);\n    default:\n        return byte_cmp(p, q);\n    }\n}\n\nKAVL_INIT(my, struct elem, head, scmp)\n\n\nstruct mphdr *mem_pool(bool is_static, unsigned char cmp_type)\n{\n    struct mphdr *hdr = calloc(1, sizeof(struct mphdr));\n    if (hdr) {\n        hdr->static_data = is_static;\n        hdr->cmp_type = cmp_type;\n    }\n    return hdr;\n}\n\n\nstruct elem *mem_get(const struct mphdr *hdr, const char *str, int len)\n{\n    struct elem temp = { \n        .cmp_type = hdr->cmp_type,\n        .len = len, .data = (char *)str \n    };\n    return kavl_find(my, hdr->root, &temp, 0);\n}\n\n\nstruct elem *mem_add(struct mphdr *hdr, char *str, int len, size_t struct_size)\n{\n    struct elem *v, *e = calloc(1, struct_size);\n    if (!e) {\n        return 0;\n    }\n    e->len = len;\n    e->cmp_type = hdr->cmp_type;\n    e->data = str;\n    \n    v = kavl_insert(my, &hdr->root, e, 0);\n    while (e != v && e->len < v->len) {\n        mem_delete(hdr, v->data, v->len);\n        v = kavl_insert(my, &hdr->root, e, 0);\n    }\n    if (e != v) {\n        if (!hdr->static_data)\n            free(e->data);\n        free(e);\n    }\n    else hdr->count++;\n    return v;\n}\n\n\nvoid mem_delete(struct mphdr *hdr, const char *str, int len)\n{\n    struct elem temp = { \n        .cmp_type = hdr->cmp_type,\n        .len = len, .data = (char *)str \n    };\n    struct elem *e = kavl_erase(my, &hdr->root, &temp, 0);\n    if (!e) {\n        return;\n    }\n    if (!hdr->static_data) {\n        free(e->data);\n        e->data = 0;\n    }\n    free(e);\n    hdr->count--;\n}\n\n\nvoid mem_destroy(struct mphdr *hdr)\n{\n    while (hdr->root) {\n        struct elem *e = kavl_erase_first(my, &hdr->root);\n        if (!e) {\n            break;\n        }\n        if (!hdr->static_data) {\n            free(e->data);\n        }\n        e->data = 0;\n        free(e);\n    }\n    free(hdr);\n}\n"
        },
        {
          "name": "mpool.h",
          "type": "blob",
          "size": 0.740234375,
          "content": "#ifndef MPOOL_H\n#define MPOOL_H\n\n#include <stdbool.h>\n#include <time.h>\n#include \"kavl.h\"\n\n#define CMP_BYTES 0\n#define CMP_BITS 1\n#define CMP_HOST 2\n\nstruct elem {\n    int len;\n    char *data;\n    unsigned char cmp_type;\n    KAVL_HEAD(struct elem) head;\n};\n\nstruct elem_i {\n    struct elem i;\n    int m;\n    time_t time;\n};\n\nstruct mphdr {\n    bool static_data;\n    unsigned char cmp_type;\n    size_t count;\n    struct elem *root;\n};\n\nstruct mphdr *mem_pool(bool is_static, unsigned char cmp_type);\n\nstruct elem *mem_get(const struct mphdr *hdr, const char *str, int len);\n\nstruct elem *mem_add(struct mphdr *hdr, char *str, int len, size_t ssize);\n\nvoid mem_delete(struct mphdr *hdr, const char *str, int len);\n\nvoid mem_destroy(struct mphdr *hdr);\n\n#endif\n"
        },
        {
          "name": "packets.c",
          "type": "blob",
          "size": 9.919921875,
          "content": "#include \"packets.h\"\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <strings.h>\n\n#ifdef _WIN32\n    #include <winsock2.h>\n#else\n    #include <arpa/inet.h>\n#endif\n\n#define ANTOHS(data, i) \\\n    (((uint16_t)data[i] << 8) + (uint8_t)data[i + 1])\n    \n#define SHTONA(data, i, x) \\\n    data[i] = (uint8_t)((x) >> 8); \\\n    data[i + 1] = ((x) & 0xff)\n\n\nchar tls_data[517] = {\n    \"\\x16\\x03\\x01\\x02\\x00\\x01\\x00\\x01\\xfc\\x03\\x03\\x03\\x5f\"\n    \"\\x6f\\x2c\\xed\\x13\\x22\\xf8\\xdc\\xb2\\xf2\\x60\\x48\\x2d\\x72\"\n    \"\\x66\\x6f\\x57\\xdd\\x13\\x9d\\x1b\\x37\\xdc\\xfa\\x36\\x2e\\xba\"\n    \"\\xf9\\x92\\x99\\x3a\\x20\\xf9\\xdf\\x0c\\x2e\\x8a\\x55\\x89\\x82\"\n    \"\\x31\\x63\\x1a\\xef\\xa8\\xbe\\x08\\x58\\xa7\\xa3\\x5a\\x18\\xd3\"\n    \"\\x96\\x5f\\x04\\x5c\\xb4\\x62\\xaf\\x89\\xd7\\x0f\\x8b\\x00\\x3e\"\n    \"\\x13\\x02\\x13\\x03\\x13\\x01\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\"\n    \"\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\"\n    \"\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\"\n    \"\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\"\n    \"\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x01\"\n    \"\\x75\\x00\\x00\\x00\\x16\\x00\\x14\\x00\\x00\\x11\\x77\\x77\\x77\"\n    \"\\x2e\\x77\\x69\\x6b\\x69\\x70\\x65\\x64\\x69\\x61\\x2e\\x6f\\x72\"\n    \"\\x67\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x16\"\n    \"\\x00\\x14\\x00\\x1d\\x00\\x17\\x00\\x1e\\x00\\x19\\x00\\x18\\x01\"\n    \"\\x00\\x01\\x01\\x01\\x02\\x01\\x03\\x01\\x04\\x00\\x10\\x00\\x0e\"\n    \"\\x00\\x0c\\x02\\x68\\x32\\x08\\x68\\x74\\x74\\x70\\x2f\\x31\\x2e\"\n    \"\\x31\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x31\\x00\\x00\"\n    \"\\x00\\x0d\\x00\\x2a\\x00\\x28\\x04\\x03\\x05\\x03\\x06\\x03\\x08\"\n    \"\\x07\\x08\\x08\\x08\\x09\\x08\\x0a\\x08\\x0b\\x08\\x04\\x08\\x05\"\n    \"\\x08\\x06\\x04\\x01\\x05\\x01\\x06\\x01\\x03\\x03\\x03\\x01\\x03\"\n    \"\\x02\\x04\\x02\\x05\\x02\\x06\\x02\\x00\\x2b\\x00\\x09\\x08\\x03\"\n    \"\\x04\\x03\\x03\\x03\\x02\\x03\\x01\\x00\\x2d\\x00\\x02\\x01\\x01\"\n    \"\\x00\\x33\\x00\\x26\\x00\\x24\\x00\\x1d\\x00\\x20\\x11\\x8c\\xb8\"\n    \"\\x8c\\xe8\\x8a\\x08\\x90\\x1e\\xee\\x19\\xd9\\xdd\\xe8\\xd4\\x06\"\n    \"\\xb1\\xd1\\xe2\\xab\\xe0\\x16\\x63\\xd6\\xdc\\xda\\x84\\xa4\\xb8\"\n    \"\\x4b\\xfb\\x0e\\x00\\x15\\x00\\xac\\x00\\x00\\x00\\x00\\x00\\x00\"\n};\n\nchar http_data[43] = {\n    \"GET / HTTP/1.1\\r\\n\"\n    \"Host: www.wikipedia.org\\r\\n\\r\\n\"\n};\n\nchar udp_data[64] = { 0 };\n\n\nstatic char *strncasestr(const char *a, size_t as, const char *b, size_t bs)\n{\n    for (const char *p = a; ; p++) {\n        p = memchr(p, *b, as - (p - a));\n        if (!p) {\n            return 0;\n        }\n        if ((p + bs) > (a + as)) {\n            return 0;\n        }\n        if (!strncasecmp(p, b, bs)) {\n            return (char *)p;\n        }\n    }\n    return 0;\n}\n\n\nstatic size_t find_tls_ext_offset(uint16_t type, \n        const char *data, size_t size, size_t skip) \n{\n    if (size <= (skip + 2)) {\n        return 0;\n    }\n    uint16_t ext_len = ANTOHS(data, skip);\n    skip += 2;\n    \n    if (ext_len < (size - skip)) {\n        size = ext_len + skip;\n    }\n    while ((skip + 4) < size) {\n        uint16_t epyt = ANTOHS(data, skip);\n        if (type == epyt) {\n            return skip;\n        }\n        uint16_t len = ANTOHS(data, skip + 2);\n        skip += (len + 4);\n    }\n    return 0;\n}\n\n\nstatic size_t chello_ext_offset(uint16_t type, const char *data, size_t size)\n{\n    if (size < 44) {\n        return 0;\n    }\n    uint8_t sid_len = data[43];\n    if (size < (44lu + sid_len + 2)) {\n        return 0;\n    }\n    uint16_t cip_len = ANTOHS(data, 44 + sid_len);\n\n    size_t skip = 44 + sid_len + 2 + cip_len + 2;\n    return find_tls_ext_offset(type, data, size, skip);\n}\n\n\nint change_tls_sni(const char *host, char *buffer, size_t bsize)\n{\n    size_t sni_offs, pad_offs;\n    \n    if (!(sni_offs = chello_ext_offset(0x00, buffer, bsize))) {\n        return -1;\n    }\n    if (!(pad_offs = chello_ext_offset(0x15, buffer, bsize))) {\n        return -1;\n    }\n    char *sni = &buffer[sni_offs];\n    char *pad = &buffer[pad_offs];\n    \n    uint16_t old_sz = ANTOHS(buffer, sni_offs + 2) - 5;\n    uint16_t free_sz = ANTOHS(buffer, pad_offs + 2);\n    uint16_t new_sz = strlen(host);\n    \n    ssize_t diff = new_sz - old_sz;\n  \n    if ((free_sz != (bsize - pad_offs - 4)) \n            || free_sz < diff) {\n        return -1;\n    }\n    SHTONA(sni, 2, old_sz + diff + 5);\n    SHTONA(sni, 4, old_sz + diff + 3);\n    SHTONA(sni, 7, old_sz + diff);\n    SHTONA(pad, 2, free_sz - diff);\n    \n    char *host_end = sni + 9 + old_sz;\n    int oth_sz = bsize - (sni_offs + 9 + old_sz);\n    \n    memmove(host_end + diff, host_end, oth_sz);\n    memcpy(sni + 9, host, new_sz);\n    return 0;\n}\n\n\nbool is_tls_chello(const char *buffer, size_t bsize)\n{\n    return (bsize > 5 &&\n        ANTOHS(buffer, 0) == 0x1603 &&\n        buffer[5] == 0x01);\n}\n\n\nint parse_tls(const char *buffer, size_t bsize, char **hs)\n{\n    if (!is_tls_chello(buffer, bsize)) {\n        return 0;\n    }\n    size_t sni_offs = chello_ext_offset(0x00, buffer, bsize);\n    \n    if (!sni_offs || (sni_offs + 12) >= bsize) {\n        return 0;\n    }\n    uint16_t len = ANTOHS(buffer, sni_offs + 7);\n    \n    if ((sni_offs + 9 + len) > bsize) {\n        return 0;\n    }\n    *hs = (char *)&buffer[sni_offs + 9];\n    return len;\n}\n\n\nbool is_http(const char *buffer, size_t bsize)\n{\n    if (bsize < 16 || *buffer > 'T' || *buffer < 'C') {\n        return 0;\n    }\n    const char *methods[] = {\n        \"HEAD\", \"GET\", \"POST\", \"PUT\", \"DELETE\",\n        \"OPTIONS\", \"CONNECT\", \"TRACE\", \"PATCH\", 0\n    };\n    for (const char **m = methods; *m; m++) {\n        if (strncmp(buffer, *m, strlen(*m)) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n    \nint parse_http(const char *buffer, size_t bsize, char **hs, uint16_t *port)\n{\n    const char *host = buffer, *l_end;\n    const char *buff_end = buffer + bsize;\n    \n    if (!is_http(buffer, bsize)) {\n        return 0;\n    }\n    if (!(host = strncasestr(buffer, bsize, \"\\nHost:\", 6))) {\n        return 0;\n    }\n    host += 6;\n    for (; host < buff_end && *host == ' '; host++);\n    \n    if (!(l_end = memchr(host, '\\n', buff_end - host))) {\n        return 0;\n    }\n    for (; isspace((unsigned char) *(l_end - 1)); l_end--);\n    \n    const char *h_end = l_end - 1;\n    while (isdigit((unsigned char) *--h_end));\n    \n    if (*h_end != ':') {\n        if (port) *port = 80;\n        h_end = l_end;\n    }\n    else if (port) {\n        char *end;\n        long i = strtol(h_end + 1, &end, 10);\n        if (i <= 0 || end != l_end || i > 0xffff)\n            return 0;\n        *port = i;\n    }\n    if (*host == '[') {\n        if (*--h_end != ']')\n            return 0;\n        host++; \n    }\n    *hs = (char *)host;\n    return h_end - host;\n}\n\n\nstatic int get_http_code(const char *b, size_t n)\n{\n    if (n < 13 || strncmp(b, \"HTTP/1.\", 7)) {\n        return 0;\n    }\n    if (!memchr(b + 12, '\\n', n - 12)) {\n        return 0;\n    }\n    char *e;\n    long num = strtol(b + 9, &e, 10);\n    if (num < 100 || num > 511 || !isspace((unsigned char) *e)) {\n        return 0;\n    }\n    return (int )num;\n}\n\n\nbool is_http_redirect(\n        const char *req, size_t qn, const char *resp, size_t sn)\n{\n    char *host = 0, *location;\n    int len = parse_http(req, qn, &host, 0);\n    \n    if (len <= 0 || sn < 29) {\n        return 0;\n    }\n    int code = get_http_code(resp, sn);\n    if (code > 308 || code < 300) {\n        return 0;\n    }\n    if (!(location = strncasestr(resp, sn, \"\\nLocation:\", 10))\n            || ((location += 11) + 8) >= (resp + sn)) {\n        return 0;\n    }\n    char *l_end = memchr(location, '\\n', sn - (location - resp));\n    if (!l_end) {\n        return 0;\n    }\n    for (; isspace((unsigned char) *(l_end - 1)); l_end--);\n    \n    if ((l_end - location) > 7) {\n        if (!strncmp(location, \"http://\", 7)) {\n            location += 7;\n        }\n        else if (!strncmp(location, \"https://\", 8)) {\n            location += 8;\n        }\n    }\n    char *le = memchr(location, '/', l_end - location);\n    if (!le) le = l_end;\n    char *he = host + len, *h = he;\n    \n    while (h != host && *(--h - 1) != '.');\n    while (h != host && *(--h - 1) != '.');\n    \n    return ((le - location) < (he - h)) \n        || memcmp(le - (he - h), h, he - h) != 0;\n}\n\n\nbool neq_tls_sid(const char *req, size_t qn, const char *resp, size_t sn)\n{\n    if (qn < 75 || sn < 75) {\n        return 0;\n    }\n    if (!is_tls_chello(req, qn)\n            || ANTOHS(resp, 0) != 0x1603) {\n        return 0;\n    }\n    uint8_t sid_len = req[43];\n    size_t skip = 44 + sid_len + 3;\n    \n    if (!find_tls_ext_offset(0x2b, resp, sn, skip)) {\n        return 0;\n    }\n    if (req[43] != resp[43]) {\n        return 1;\n    }\n    return memcmp(req + 44, resp + 44, sid_len);\n}\n\n\nbool is_tls_shello(const char *buffer, size_t bsize)\n{\n    return (bsize > 5 &&\n        ANTOHS(buffer, 0) == 0x1603 &&\n        buffer[5] == 0x02);\n}\n\n/*\nbool is_dns_req(char *buffer, size_t n)\n{\n    if (n < 12) {\n        return 0;\n    }\n    return !memcmp(buffer + 2, \"\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\", 10);\n}\n\n\nbool is_quic_initial(char *buffer, size_t bsize)\n{\n    return (bsize > 64 && (buffer[0] & 0xc0) == 0xc0);\n}\n*/\n\nint mod_http(char *buffer, size_t bsize, int m)\n{\n    char *host = 0, *par;\n    int hlen = parse_http(buffer, bsize, &host, 0);\n    if (!hlen)\n        return -1;\n    for (par = host - 1; *par != ':'; par--) {}\n    par -= 4;\n    if (m & MH_HMIX) {\n        par[0] = tolower((unsigned char) par[0]);\n        par[1] = toupper((unsigned char) par[1]);\n        par[3] = toupper((unsigned char) par[3]);\n    }\n    if (m & MH_DMIX) {\n        for (int i = 0; i < hlen; i += 2) {\n            host[i] = toupper((unsigned char)host[i]);\n        }\n    }\n    if (m & MH_SPACE) {\n        for (; !isspace((unsigned char) *(host + hlen)); hlen++) {}\n        int sc = host - (par + 5);\n        memmove(par + 5, host, hlen);\n        memset(par + 5 + hlen, '\\t', sc);\n    }\n    return 0;\n}\n\n\nint part_tls(char *buffer, size_t bsize, ssize_t n, long pos)\n{\n    if ((n < 3) || (bsize - n < 5) || \n            (pos < 0) || (pos + 5 > n)) {\n        return 0;\n    }\n    uint16_t r_sz = ANTOHS(buffer, 3);\n    if (r_sz < pos) {\n        return n;\n    }\n    memmove(buffer + 5 + pos + 5, buffer + 5 + pos, n - (5 + pos));\n    memcpy(buffer + 5 + pos, buffer, 3);\n    \n    SHTONA(buffer, 3, pos);\n    SHTONA(buffer, 5 + pos + 3, r_sz - pos);\n    return 5;\n}\n"
        },
        {
          "name": "packets.h",
          "type": "blob",
          "size": 1.1064453125,
          "content": "#ifndef PACKETS_H\n#define PACKETS_H\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/types.h>\n\n#define IS_TCP 1\n#define IS_UDP 2\n#define IS_HTTP 4\n#define IS_HTTPS 8\n#define IS_IPV4 16\n//#define IS_QUIC 64\n//#define IS_DNS 128\n\n#define MH_HMIX 1\n#define MH_SPACE 2\n#define MH_DMIX 4\n\nextern char tls_data[517];\nextern char http_data[43];\nextern char udp_data[64];\n\nint change_tls_sni(const char *host, char *buffer, size_t bsize);\n\nbool is_tls_chello(const char *buffer, size_t bsize);\n\nint parse_tls(const char *buffer, size_t bsize, char **hs);\n\nbool is_http(const char *buffer, size_t bsize);\n\nint parse_http(const char *buffer, size_t bsize, char **hs, uint16_t *port);\n\nint mod_http(char *buffer, size_t bsize, int m);\n\nbool is_http_redirect(const char *req, size_t qn, const char *resp, size_t sn);\n\nbool neq_tls_sid(const char *req, size_t qn, const char *resp, size_t sn);\n\nbool is_tls_shello(const char *buffer, size_t bsize);\n\nint part_tls(char *buffer, size_t bsize, ssize_t n, long pos);\n\n//bool is_dns_req(char *buffer, size_t n);\n\n//bool is_quic_initial(char *buffer, size_t bsize);\n\n\n#endif\n"
        },
        {
          "name": "params.h",
          "type": "blob",
          "size": 2.248046875,
          "content": "#ifndef PARAMS_H\n#define PARAMS_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"mpool.h\"\n#include \"conev.h\"\n\n#ifdef _WIN32\n    #include <ws2tcpip.h>\n#else\n    #include <arpa/inet.h>\n    #include <netinet/in.h>\n    #include <unistd.h>\n    #include <sys/socket.h>\n#endif\n\n#if defined(__linux__) || defined(_WIN32)\n#define FAKE_SUPPORT 1\n#define TIMEOUT_SUPPORT 1\n#endif\n\n#define OFFSET_END 1\n#define OFFSET_MID 2\n#define OFFSET_RAND 4\n#define OFFSET_SNI 8\n#define OFFSET_HOST 16\n#define OFFSET_START 32\n\n#define DETECT_HTTP_LOCAT 1\n#define DETECT_TLS_ERR 2\n#define DETECT_TORST 8\n\n#define AUTO_NOBUFF -1\n#define AUTO_NOSAVE 0\n\nenum demode {\n    DESYNC_NONE,\n    DESYNC_SPLIT,\n    DESYNC_DISORDER,\n    DESYNC_OOB,\n    DESYNC_DISOOB,\n    DESYNC_FAKE\n};\n\n#ifdef STR_MODE\nchar *demode_str[] = {\n    \"DESYNC_NONE\",\n    \"DESYNC_SPLIT\",\n    \"DESYNC_DISORDER\",\n    \"DESYNC_OOB\",\n    \"DESYNC_DISOOB\",\n    \"DESYNC_FAKE\"\n};\n#endif\n\nstruct part {\n    int m;\n    int flag;\n    long pos;\n    int r, s;\n};\n\nstruct packet {\n     ssize_t size;\n     char  *data;\n};\n\nstruct desync_params {\n    int ttl;\n    char *ip_options;\n    ssize_t ip_options_len;\n    bool md5sig;\n    struct packet fake_data;\n    int udp_fake_count;\n    int fake_offset;\n    bool drop_sack;\n    char oob_char[2];\n    \n    int parts_n;\n    struct part *parts;\n    \n    int mod_http;\n    int tlsrec_n;\n    struct part *tlsrec;\n    \n    int proto;\n    int detect;\n    struct mphdr *hosts;\n    struct mphdr *ipset;\n    uint16_t pf[2];\n    int rounds[2];\n    \n    char *file_ptr;\n    ssize_t file_size;\n};\n\nstruct params {\n    int dp_count;\n    struct desync_params *dp;\n    bool wait_send;\n    int def_ttl;\n    bool custom_ttl;\n    \n    bool tfo;\n    unsigned int timeout;\n    int auto_level;\n    long cache_ttl;\n    bool ipv6;\n    bool resolve;\n    bool udp;\n    int max_open;\n    int debug;\n    size_t bfsize;\n    union sockaddr_u baddr;\n    union sockaddr_u laddr;\n    bool transparent;\n    struct mphdr *mempool;\n    \n    const char *protect_path;\n    const char *pid_file;\n    int pid_fd;\n};\n\nextern struct params params;\n\nextern struct packet fake_tls;\nextern struct packet fake_http;\nextern struct packet fake_udp;\n\nextern char ip_option[1];\n\n#define ASSERT(exp) \\\n    char t[(exp) ? 1 : -1];\n#endif\n"
        },
        {
          "name": "proxy.c",
          "type": "blob",
          "size": 26.37109375,
          "content": "#define EID_STR\n\n#include \"proxy.h\"\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <assert.h>\n\n#include \"params.h\"\n#include \"conev.h\"\n#include \"extend.h\"\n#include \"error.h\"\n\n#ifdef _WIN32\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    \n    #define close(fd) closesocket(fd)\n#else\n    #include <errno.h>\n    #include <unistd.h>\n    #include <fcntl.h>\n    \n    #include <sys/socket.h>\n    #include <arpa/inet.h>\n    #include <netinet/tcp.h>\n    #include <netdb.h>\n\n    #if defined(__linux__) && defined(__GLIBC__)\n        extern int accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);\n    #endif\n    #ifdef __linux__\n        /* For SO_ORIGINAL_DST only (which is 0x50) */\n        #include \"linux/netfilter_ipv4.h\"\n        #ifndef IP6T_SO_ORIGINAL_DST\n        #define IP6T_SO_ORIGINAL_DST SO_ORIGINAL_DST\n        #endif\n    #endif\n#endif\n\n\nint NOT_EXIT = 1;\n\nstatic void on_cancel(int sig) {\n    if (sig) NOT_EXIT = 0;\n}\n\n\nvoid map_fix(union sockaddr_u *addr, char f6)\n{\n    struct {\n        uint64_t o64;\n        uint16_t o16;\n        uint16_t t16;\n        uint32_t o32;\n    } *ipv6m = (void *)&addr->in6.sin6_addr;\n    \n    if (addr->sa.sa_family == AF_INET && f6) {\n        addr->sa.sa_family = AF_INET6;\n        ipv6m->o32 = *(uint32_t *)(&addr->in.sin_addr);\n        ipv6m->o64 = 0;\n        ipv6m->o16 = 0;\n        ipv6m->t16 = 0xffff;\n    } \n    else if (!ipv6m->o64 && !ipv6m->o16 &&\n            ipv6m->t16 == 0xffff && !f6) {\n        addr->sa.sa_family = AF_INET;\n        const struct in_addr *sin_addr_ptr = (struct in_addr *) &ipv6m->o32;\n        addr->in.sin_addr = *sin_addr_ptr;\n    }\n}\n\n\nstatic inline char addr_equ(\n        const union sockaddr_u *a, const union sockaddr_u *b)\n{\n    if (a->sa.sa_family == AF_INET) {\n        return \n            *((uint32_t *)(&a->in.sin_addr)) ==\n            *((uint32_t *)(&b->in.sin_addr));\n    }\n    return memcmp(&a->in6.sin6_addr, \n        &b->in6.sin6_addr, sizeof(b->in6.sin6_addr)) == 0;\n}\n\n\nstatic inline int nb_socket(int domain, int type)\n{\n    #ifdef __linux__\n    int fd = socket(domain, type | SOCK_NONBLOCK, 0);\n    #else\n    int fd = socket(domain, type, 0);\n    #endif\n    if (fd < 0) {\n        uniperror(\"socket\");  \n        return -1;\n    }\n    #ifdef _WIN32\n    unsigned long mode = 1;\n    if (ioctlsocket(fd, FIONBIO, &mode) < 0) {\n        uniperror(\"ioctlsocket\");\n        close(fd);\n        return -1;\n    }\n    #else\n    #ifndef __linux__\n    if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {\n        uniperror(\"fcntl\");\n        close(fd);\n        return -1;\n    }\n    #endif\n    #endif\n    return fd;\n}\n\n\nstatic int resolve(char *host, int len, \n        union sockaddr_u *addr, int type) \n{\n    struct addrinfo hints = {0}, *res = 0;\n    \n    hints.ai_socktype = type;\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = params.ipv6 ? AF_UNSPEC : AF_INET;\n    \n    char rchar = host[len];\n    host[len] = '\\0';\n    LOG(LOG_S, \"resolve: %s\\n\", host);\n    \n    if (getaddrinfo(host, 0, &hints, &res) || !res) {\n        host[len] = rchar;\n        return -1;\n    }\n    if (res->ai_addr->sa_family == AF_INET6)\n        addr->in6 = *(struct sockaddr_in6 *)res->ai_addr;\n    else\n        addr->in = *(struct sockaddr_in *)res->ai_addr;\n    freeaddrinfo(res);\n    \n    host[len] = rchar;\n    return 0;\n}\n\n\nstatic int auth_socks5(int fd, const char *buffer, ssize_t n)\n{\n    if (n <= 2 || (uint8_t)buffer[1] != (n - 2)) {\n        return -1;\n    }\n    uint8_t c = S_AUTH_BAD;\n    for (long i = 2; i < n; i++)\n        if (buffer[i] == S_AUTH_NONE) {\n            c = S_AUTH_NONE;\n            break;\n        }\n    uint8_t a[2] = { S_VER5, c };\n    if (send(fd, (char *)a, sizeof(a), 0) < 0) {\n        uniperror(\"send\");\n        return -1;\n    }\n    return c != S_AUTH_BAD ? 0 : -1;\n}\n\n\nstatic int resp_s5_error(int fd, int e)\n{\n    struct s5_rep s5r = { \n        .ver = 0x05, .code = (uint8_t )e, \n        .atp = S_ATP_I4\n    };\n    return send(fd, (char *)&s5r, sizeof(s5r), 0);\n}\n\n\nstatic int resp_error(int fd, int e, int flag)\n{\n    if (flag == FLAG_S4) {\n        struct s4_req s4r = { \n            .cmd = e ? S4_ER : S4_OK\n        };\n        return send(fd, (char *)&s4r, sizeof(s4r), 0);\n    }\n    else if (flag == FLAG_S5) {\n        switch (unie(e)) {\n            case 0: e = S_ER_OK;\n                break;\n            case ECONNREFUSED: \n                e = S_ER_CONN;\n                break;\n            case EHOSTUNREACH:\n            case ETIMEDOUT: \n                e = S_ER_HOST;\n                break;\n            case ENETUNREACH: \n                e = S_ER_NET;\n                break;\n            default: e = S_ER_GEN;\n        }\n        return resp_s5_error(fd, e);\n    }\n    #ifdef __linux__\n    if (params.transparent &&\n            (e == ECONNREFUSED || e == ETIMEDOUT)) {\n        struct linger l = { .l_onoff = 1 };\n        if (setsockopt(fd, \n                SOL_SOCKET, SO_LINGER, &l, sizeof(l)) < 0) {\n            uniperror(\"setsockopt SO_LINGER\");\n            return -1;\n        }\n    }\n    #endif\n    return 0;\n}\n\n\nstatic int s4_get_addr(const char *buff, \n        size_t n, union sockaddr_u *dst)\n{\n    if (n < sizeof(struct s4_req) + 1) {\n        return -1;\n    }\n    struct s4_req *r = (struct s4_req *)buff;\n    \n    if (r->cmd != S_CMD_CONN) {\n        return -1;\n    }\n    if (ntohl(r->i4.s_addr) <= 255) {\n        if (!params.resolve || buff[n - 1] != 0) {\n            return -1;\n        }\n        char *id_end = strchr(buff + sizeof(*r), 0);\n        if (!id_end) {\n            return -1;\n        }\n        int len = (buff + n - id_end) - 2;\n        if (len < 3 || len > 255) {\n            return -1;\n        }\n        if (resolve(id_end + 1, len, dst, SOCK_STREAM)) {\n            LOG(LOG_E, \"not resolved: %.*s\\n\", len, id_end + 1);\n            return -1;\n        }\n    }\n    else {\n        dst->in.sin_family = AF_INET;\n        dst->in.sin_addr = r->i4;\n    }\n    dst->in.sin_port = r->port;\n    return 0;\n}\n\n\nstatic int s5_get_addr(const char *buffer, \n        size_t n, union sockaddr_u *addr, int type) \n{\n    if (n < S_SIZE_MIN) {\n        LOG(LOG_E, \"ss: request too small\\n\");\n        return -S_ER_GEN;\n    }\n    struct s5_req *r = (struct s5_req *)buffer;\n    \n    size_t o = (r->atp == S_ATP_I4 ? S_SIZE_I4 : \n            (r->atp == S_ATP_ID ? r->dst.id.len + S_SIZE_ID : \n            (r->atp == S_ATP_I6 ? S_SIZE_I6 : 0)));\n    if (n < o)  {\n        LOG(LOG_E, \"ss: bad request\\n\");\n        return -S_ER_GEN;\n    }\n    switch (r->atp) {\n        case S_ATP_I4:\n            addr->in.sin_family = AF_INET;\n            addr->in.sin_addr = r->dst.i4.ip;\n            break;\n        \n        case S_ATP_ID:\n            if (!params.resolve) {\n                return -S_ER_ATP;\n            }\n            if (r->dst.id.len < 3 || \n                    resolve(r->dst.id.domain, r->dst.id.len, addr, type)) {\n                LOG(LOG_E, \"not resolved: %.*s\\n\", r->dst.id.len, r->dst.id.domain);\n                return -S_ER_HOST;\n            }\n            break;\n        \n        case S_ATP_I6:\n            if (!params.ipv6)\n                return -S_ER_ATP;\n            else {\n                addr->in6.sin6_family = AF_INET6;\n                addr->in6.sin6_addr = r->dst.i6.ip;\n            }\n    }\n    memcpy(&addr->in.sin_port, &buffer[o - 2], sizeof(uint16_t));\n    return o;\n}\n\n\nstatic int s5_set_addr(char *buffer, size_t n,\n        const union sockaddr_u *addr, char end)\n{\n    struct s5_req *r = (struct s5_req *)buffer;\n    if (n < S_SIZE_I4) {\n        return -1;\n    }\n    if (addr->sa.sa_family == AF_INET) {\n        if (end) {\n            r = (struct s5_req *)(buffer - S_SIZE_I4);\n        }\n        r->atp = S_ATP_I4;\n        r->dst.i4.ip = addr->in.sin_addr;\n        r->dst.i4.port = addr->in.sin_port;\n        return S_SIZE_I4;\n    } else {\n        if (n < S_SIZE_I6) {\n            return -1;\n        }\n        if (end) {\n            r = (struct s5_req *)(buffer - S_SIZE_I6);\n        }\n        r->atp = S_ATP_I6;\n        r->dst.i6.ip = addr->in6.sin6_addr;\n        r->dst.i6.port = addr->in6.sin6_port;\n        return S_SIZE_I6;\n    }\n    return 0;\n}\n\n\nstatic int remote_sock(union sockaddr_u *dst, int type)\n{\n    if (params.baddr.sa.sa_family == AF_INET6) {\n        map_fix(dst, 6);\n    } else {\n        map_fix(dst, 0);\n    }\n    if (dst->sa.sa_family != params.baddr.sa.sa_family) {\n        LOG(LOG_E, \"different addresses family\\n\");\n        return -1;\n    }\n    int sfd = nb_socket(dst->sa.sa_family, type);\n    if (sfd < 0) {\n        uniperror(\"socket\");  \n        return -1;\n    }\n    if (socket_mod(sfd) < 0) {\n        close(sfd);\n        return -1;\n    }\n    if (dst->sa.sa_family == AF_INET6) {\n        int no = 0;\n        if (setsockopt(sfd, IPPROTO_IPV6,\n                IPV6_V6ONLY, (char *)&no, sizeof(no))) {\n            uniperror(\"setsockopt IPV6_V6ONLY\");\n            close(sfd);\n            return -1;\n        }\n    }\n    if (bind(sfd, (struct sockaddr *)&params.baddr, \n            SA_SIZE(&params.baddr)) < 0) {\n        uniperror(\"bind\");  \n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\n\nint create_conn(struct poolhd *pool,\n        struct eval *val, const union sockaddr_u *dst, int next)\n{\n    union sockaddr_u addr = *dst;\n    \n    int sfd = remote_sock(&addr, SOCK_STREAM);\n    if (sfd < 0) {\n        return -1;\n    }\n    #ifdef __linux__\n    int syn_count = 1;\n    if (setsockopt(sfd, IPPROTO_TCP,\n            TCP_SYNCNT, (char *)&syn_count, sizeof(syn_count))) {\n        uniperror(\"setsockopt TCP_SYNCNT\");\n        close(sfd);\n        return -1;\n    }\n    #ifdef TCP_FASTOPEN_CONNECT\n    int yes = 1;\n    if (params.tfo && setsockopt(sfd, IPPROTO_TCP,\n            TCP_FASTOPEN_CONNECT, (char *)&yes, sizeof(yes))) {\n        uniperror(\"setsockopt TCP_FASTOPEN_CONNECT\");\n        close(sfd);\n        return -1;\n    }\n    #endif\n    #endif\n    int one = 1;\n    if (setsockopt(sfd, IPPROTO_TCP,\n            TCP_NODELAY, (char *)&one, sizeof(one))) {\n        uniperror(\"setsockopt TCP_NODELAY\");\n        close(sfd);\n        return -1;\n    }\n    if (params.debug) {\n        INIT_ADDR_STR((*dst));\n        LOG(LOG_S, \"new conn: fd=%d, pair=%d, addr=%s:%d\\n\", \n            sfd, val->fd, ADDR_STR, ntohs(dst->in.sin_port));\n    }\n    int status = connect(sfd, &addr.sa, SA_SIZE(&addr));\n    if (status == 0 && params.tfo) {\n        LOG(LOG_S, \"TFO supported!\\n\");\n    }\n    if (status < 0 && \n            get_e() != EINPROGRESS && get_e() != EAGAIN) {\n        uniperror(\"connect\");\n        close(sfd);\n        return -1;\n    }\n    struct eval *pair = add_event(pool, next, sfd, POLLOUT);\n    if (!pair) {\n        close(sfd);\n        return -1;\n    }\n    if (mod_etype(pool, val, 0) < 0) {\n        uniperror(\"mod_etype\");\n        return -1;\n    }\n    val->pair = pair;\n    pair->pair = val;\n    #ifdef __NetBSD__\n    pair->addr = addr;\n    #else\n    pair->addr = *dst;\n    #endif\n    pair->flag = FLAG_CONN;\n    val->type = EV_IGNORE;\n    return 0;\n}\n\n\nstatic int udp_associate(struct poolhd *pool, \n        struct eval *val, const union sockaddr_u *dst)\n{\n    union sockaddr_u addr = *dst;\n    \n    int ufd = remote_sock(&addr, SOCK_DGRAM);\n    if (ufd < 0) {\n        return -1;\n    }\n    struct eval *pair = add_event(pool, EV_UDP_TUNNEL, ufd, POLLIN);\n    if (!pair) {\n        close(ufd);\n        return -1;\n    }\n    if (dst->in6.sin6_port != 0) {\n        if (connect(ufd, &addr.sa, SA_SIZE(&addr)) < 0) {\n            uniperror(\"connect\");\n            del_event(pool, pair);\n            return -1;\n        }\n        pair->addr = addr;\n    }\n    //\n    socklen_t sz = sizeof(addr);\n    \n    if (getsockname(val->fd, &addr.sa, &sz)) {\n        uniperror(\"getsockname\");\n        return -1;\n    }\n    addr.in.sin_port = 0;\n    \n    int cfd = nb_socket(addr.sa.sa_family, SOCK_DGRAM);\n    if (cfd < 0) {\n        uniperror(\"socket\");\n        del_event(pool, pair);\n        return -1;\n    }\n    if (bind(cfd, &addr.sa, SA_SIZE(&addr)) < 0) {\n        uniperror(\"bind\");\n        del_event(pool, pair);\n        close(cfd);\n        return -1;\n    }\n    struct eval *client = add_event(pool, EV_UDP_TUNNEL, cfd, POLLIN);\n    if (!client) {\n        del_event(pool, pair);\n        close(cfd);\n        return -1;\n    }\n    if (params.debug) {\n        INIT_ADDR_STR((*dst));\n        LOG(LOG_S, \"udp associate: fds=%d,%d,%d addr=%s:%d\\n\", \n            ufd, cfd, val->fd, ADDR_STR, ntohs(dst->in.sin_port));\n    }\n    val->type = EV_IGNORE;\n    val->pair = client;\n    client->pair = pair;\n    pair->pair = val;\n    \n    client->flag = FLAG_CONN;\n    client->addr = val->addr;\n    client->addr.in.sin_port = 0;\n    \n    sz = sizeof(addr);\n    if (getsockname(cfd, &addr.sa, &sz)) {\n        uniperror(\"getsockname\");\n        return -1;\n    }\n    struct s5_req s5r = { \n        .ver = 0x05 \n    };\n    int len = s5_set_addr((char *)&s5r, sizeof(s5r), &addr, 0);\n    if (len < 0) {\n        return -1;\n    }\n    if (send(val->fd, (char *)&s5r, len, 0) < 0) {\n        uniperror(\"send\");\n        return -1;\n    }\n    if (mod_etype(pool, val, 0)) {\n        uniperror(\"mod_etype\");\n        return -1;\n    }\n    return 0;\n}\n\n#ifdef __linux__\nstatic inline int transp_conn(struct poolhd *pool, struct eval *val)\n{\n    union sockaddr_u remote, self;\n    socklen_t rlen = sizeof(remote), slen = sizeof(self);\n    if (getsockopt(val->fd, IPPROTO_IP,\n            SO_ORIGINAL_DST, &remote, &rlen) != 0)\n    {\n        if (getsockopt(val->fd, IPPROTO_IPV6,\n                IP6T_SO_ORIGINAL_DST, &remote, &rlen) != 0) {\n            uniperror(\"getsockopt SO_ORIGINAL_DST\");\n            return -1;\n        }\n    }\n    if (getsockname(val->fd, &self.sa, &slen) < 0) {\n        uniperror(\"getsockname\");\n        return -1;\n    }\n    if (self.sa.sa_family == remote.sa.sa_family && \n            self.in.sin_port == remote.in.sin_port && \n                addr_equ(&self, &remote)) {\n        LOG(LOG_E, \"connect to self, ignore\\n\");\n        return -1;\n    }\n    int error = connect_hook(pool, val, &remote, EV_CONNECT);\n    if (error) {\n        uniperror(\"connect_hook\");\n        return -1;\n    }\n    return 0;\n}\n#endif\n\nstatic int on_accept(struct poolhd *pool, const struct eval *val)\n{\n    union sockaddr_u client;\n    struct eval *rval;\n    \n    while (1) {\n        socklen_t len = sizeof(client);\n        #ifdef __linux__\n        int c = accept4(val->fd, &client.sa, &len, SOCK_NONBLOCK);\n        #else\n        int c = accept(val->fd, &client.sa, &len);\n        #endif\n        if (c < 0) {\n            if (get_e() == EAGAIN ||\n                    get_e() == EINPROGRESS)\n                break;\n            uniperror(\"accept\");\n            return -1;\n        }\n        LOG(LOG_S, \"accept: fd=%d\\n\", c);\n        #ifndef __linux__\n        #ifdef _WIN32\n        unsigned long mode = 1;\n        if (ioctlsocket(c, FIONBIO, &mode) < 0) {\n            uniperror(\"ioctlsocket\");\n        #else\n        if (fcntl(c, F_SETFL, O_NONBLOCK) < 0) {\n            uniperror(\"fcntl\");\n        #endif\n            close(c);\n            continue;\n        }\n        #endif\n        int one = 1;\n        if (setsockopt(c, IPPROTO_TCP, TCP_NODELAY,\n                (char *)&one, sizeof(one))) {\n            uniperror(\"setsockopt TCP_NODELAY\");\n            close(c);\n            continue;\n        }\n        if (!(rval = add_event(pool, EV_REQUEST, c, POLLIN))) {\n            close(c);\n            continue;\n        }\n        rval->addr = client;\n        #ifdef __linux__\n        if (params.transparent && transp_conn(pool, rval) < 0) {\n            del_event(pool, rval);\n            continue;\n        }\n        #endif\n    }\n    return 0;\n}\n\n\nstatic int on_tunnel(struct poolhd *pool, struct eval *val, \n        char *buffer, size_t bfsize, int etype)\n{\n    ssize_t n = 0;\n    struct eval *pair = val->pair;\n    \n    if (etype & POLLOUT) {\n        LOG(LOG_S, \"pollout (fd=%d)\\n\", val->fd);\n        val = pair;\n        pair = val->pair;\n    }\n    if (val->buff.data) {\n        if (etype & POLLHUP) {\n            return -1;\n        }\n        n = val->buff.size - val->buff.offset;\n        \n        ssize_t sn = tcp_send_hook(pair, \n            val->buff.data + val->buff.offset, n, n);\n        if (sn < 0) {\n            uniperror(\"send\");\n            return -1;\n        }\n        if (sn < n) {\n            val->buff.offset += sn;\n            return 0;\n        }\n        free(val->buff.data);\n        val->buff.data = 0;\n        val->buff.size = 0;\n        val->buff.offset = 0;\n        \n        if (mod_etype(pool, val, POLLIN) ||\n                mod_etype(pool, pair, POLLIN)) {\n            uniperror(\"mod_etype\");\n            return -1;\n        }\n    }\n    do {\n        n = tcp_recv_hook(pool, val, buffer, bfsize);\n        //if (n < 0 && get_e() == EAGAIN) {\n        if (n == 0) {\n            break;\n        }\n        if (n < 0) {\n            return -1;\n        }\n        ssize_t sn = tcp_send_hook(pair, buffer, bfsize, n);\n        if (sn < 0) {\n            uniperror(\"send\");\n            return -1;\n        }\n        if (sn < n) {\n            LOG(LOG_S, \"send: %zd != %zd (fd=%d)\\n\", sn, n, pair->fd);\n            assert(!(val->buff.size || val->buff.offset));\n            \n            val->buff.size = n - sn;\n            if (!(val->buff.data = malloc(n - sn))) {\n                uniperror(\"malloc\");\n                return -1;\n            }\n            memcpy(val->buff.data, buffer + sn, n - sn);\n            \n            if (mod_etype(pool, val, 0) ||\n                    mod_etype(pool, pair, POLLOUT)) {\n                uniperror(\"mod_etype\");\n                return -1;\n            }\n            break;\n        }\n    } while (n == (ssize_t )bfsize);\n    return 0;\n}\n\n\nstatic int on_udp_tunnel(struct eval *val, char *buffer, size_t bfsize)\n{\n    char *data = buffer;\n    size_t data_len = bfsize;\n    \n    if (val->flag != FLAG_CONN) {\n        data += S_SIZE_I6;\n        data_len -= S_SIZE_I6;\n    }\n    union sockaddr_u addr = {0};\n    struct eval *pair = val->flag == FLAG_CONN ?\n        val->pair : val->pair->pair;\n    \n    do {\n        socklen_t asz = sizeof(addr);\n        \n        ssize_t n = recvfrom(val->fd, data, data_len, 0, &addr.sa, &asz);\n        if (n < 1) {\n            if (n && get_e() == EAGAIN)\n                break;\n            uniperror(\"recv udp\");\n            return -1;\n        }\n        val->recv_count += n;\n        if (val->round_sent == 0) {\n            val->round_count++;\n            val->round_sent += n;\n            pair->round_sent = 0;\n        }\n        ssize_t ns;\n        \n        if (val->flag == FLAG_CONN) {\n            if (!val->addr.in.sin_port) {\n                if (!addr_equ(&addr, &val->addr)) {\n                    return 0;\n                }\n                if (connect(val->fd, &addr.sa, SA_SIZE(&addr)) < 0) {\n                    uniperror(\"connect\");\n                    return -1;\n                }\n                val->addr = addr;\n            }\n            if (*(data + 2) != 0) { // frag\n                continue;\n            }\n            int offs = s5_get_addr(data, n, &addr, SOCK_DGRAM);\n            if (offs < 0) {\n                LOG(LOG_E, \"udp parse error\\n\");\n                return -1;\n            }\n            if (!pair->addr.in.sin_port) {\n                if (params.baddr.sa.sa_family == AF_INET6) {\n                    map_fix(&addr, 6);\n                }\n                if (params.baddr.sa.sa_family != addr.sa.sa_family) {\n                    return -1;\n                }\n                if (connect(pair->fd, &addr.sa, SA_SIZE(&addr)) < 0) {\n                    uniperror(\"connect\");\n                    return -1;\n                }\n                pair->addr = addr;\n            }\n            ns = udp_hook(pair, data + offs, n - offs, &pair->addr);\n        }\n        else {\n            map_fix(&addr, 0);\n            memset(buffer, 0, S_SIZE_I6);\n            \n            int offs = s5_set_addr(data, S_SIZE_I6, &addr, 1);\n            if (offs < 0 || offs > S_SIZE_I6) {\n                return -1;\n            }\n            ns = send(pair->fd, data - offs, offs + n, 0);\n        }\n        if (ns < 0) {\n            uniperror(\"sendto\");\n            return -1;\n        }\n    } while(1);\n    return 0;\n}\n\n\nstatic inline int on_request(struct poolhd *pool, struct eval *val,\n        char *buffer, size_t bfsize)\n{\n    union sockaddr_u dst = {0};\n    \n    ssize_t n = recv(val->fd, buffer, bfsize, 0);\n    if (n < 1) {\n        if (n) uniperror(\"ss recv\");\n        return -1;\n    }\n    int error = 0;\n    \n    if (*buffer == S_VER5) {\n        if (val->flag != FLAG_S5) {\n            if (auth_socks5(val->fd, buffer, n)) {\n                return -1;\n            }\n            val->flag = FLAG_S5;\n            return 0;\n        }\n        if (n < S_SIZE_MIN) {\n            LOG(LOG_E, \"ss: request too small (%zd)\\n\", n);\n            return -1;\n        }\n        struct s5_req *r = (struct s5_req *)buffer;\n        int s5e = 0;\n        switch (r->cmd) {\n            case S_CMD_CONN:\n                s5e = s5_get_addr(buffer, n, &dst, SOCK_STREAM);\n                if (s5e >= 0) {\n                    error = connect_hook(pool, val, &dst, EV_CONNECT);\n                }\n                break;\n            case S_CMD_AUDP:\n                if (params.udp) {\n                    s5e = s5_get_addr(buffer, n, &dst, SOCK_DGRAM);\n                    if (s5e >= 0) {\n                        error = udp_associate(pool, val, &dst);\n                    }\n                    break;\n                }\n                __attribute__((fallthrough));\n            default:\n                LOG(LOG_E, \"ss: unsupported cmd: 0x%x\\n\", r->cmd);\n                s5e = -S_ER_CMD;\n        }\n        if (s5e < 0) {\n            if (resp_s5_error(val->fd, -s5e) < 0)\n                uniperror(\"send\");\n            return -1;\n        }\n    }\n    else if (*buffer == S_VER4) {\n        val->flag = FLAG_S4;\n        \n        error = s4_get_addr(buffer, n, &dst);\n        if (error) {\n            if (resp_error(val->fd, error, FLAG_S4) < 0)\n                uniperror(\"send\");\n            return -1;\n        }\n        error = connect_hook(pool, val, &dst, EV_CONNECT);\n    }\n    else {\n        LOG(LOG_E, \"ss: invalid version: 0x%x (%zd)\\n\", *buffer, n);\n        return -1;\n    }\n    if (error) {\n        int en = get_e();\n        if (resp_error(val->fd, en ? en : error, val->flag) < 0)\n            uniperror(\"send\");\n        LOG(LOG_S, \"ss error: %d\\n\", en);\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic inline int on_connect(struct poolhd *pool, struct eval *val, int e)\n{\n    int error = 0;\n    socklen_t len = sizeof(error);\n    if (e) {\n        if (getsockopt(val->fd, SOL_SOCKET, \n                SO_ERROR, (char *)&error, &len)) {\n            uniperror(\"getsockopt SO_ERROR\");\n            return -1;\n        }\n    }\n    else {\n        if (mod_etype(pool, val, POLLIN) ||\n                mod_etype(pool, val->pair, POLLIN)) {\n            uniperror(\"mod_etype\");\n            return -1;\n        }\n        int t = params.auto_level <= AUTO_NOBUFF \n            ? EV_TUNNEL : EV_FIRST_TUNNEL;\n        val->type = t;\n        val->pair->type = t;\n    }\n    if (resp_error(val->pair->fd,\n            error, val->pair->flag) < 0) {\n        uniperror(\"send\");\n        return -1;\n    }\n    return e ? -1 : 0;\n}\n\n\nstatic void close_conn(struct poolhd *pool, struct eval *val)\n{\n    struct eval *cval = val;\n    do {\n        LOG(LOG_S, \"close: fd=%d (pair=%d), recv: %zd, rounds: %d\\n\", \n            cval->fd, cval->pair ? cval->pair->fd : -1, \n            cval->recv_count, cval->round_count);\n        cval = cval->pair;\n    } while (cval && cval != val);\n    del_event(pool, val);\n}\n\n\nint event_loop(int srvfd)\n{\n    size_t bfsize = params.bfsize;\n    \n    struct poolhd *pool = init_pool(params.max_open * 2 + 1);\n    if (!pool) {\n        close(srvfd);\n        return -1;\n    }\n    if (!add_event(pool, EV_ACCEPT, srvfd, POLLIN)) {\n        destroy_pool(pool);\n        close(srvfd);\n        return -1;\n    }\n    char *buffer = malloc(params.bfsize);\n    if (!buffer) {\n        uniperror(\"malloc\");\n        destroy_pool(pool);\n        return -1;\n    }\n    \n    struct eval *val;\n    int i = -1, etype;\n    \n    while (NOT_EXIT) {\n        val = next_event(pool, &i, &etype);\n        if (!val) {\n            if (get_e() == EINTR) \n                continue;\n            uniperror(\"(e)poll\");\n            break;\n        }\n        assert(val->type >= 0\n            && val->type < sizeof(eid_name)/sizeof(*eid_name));\n        LOG(LOG_L, \"new event: fd: %d, evt: %s, mod_iter: %llu\\n\", val->fd, eid_name[val->type], val->mod_iter);\n        \n        switch (val->type) {\n            case EV_ACCEPT:\n                if ((etype & POLLHUP) ||\n                        on_accept(pool, val))\n                    NOT_EXIT = 0;\n                continue;\n            \n            case EV_REQUEST:\n                if ((etype & POLLHUP) || \n                        on_request(pool, val, buffer, bfsize))\n                    close_conn(pool, val);\n                continue;\n        \n            case EV_FIRST_TUNNEL:\n                if (on_first_tunnel(pool, val, buffer, bfsize, etype))\n                    close_conn(pool, val);\n                continue;\n                \n            case EV_TUNNEL:\n                if (on_tunnel(pool, val, buffer, bfsize, etype))\n                    close_conn(pool, val);\n                continue;\n        \n            case EV_UDP_TUNNEL:\n                if (on_udp_tunnel(val, buffer, bfsize))\n                    close_conn(pool, val);\n                continue;\n                \n            case EV_CONNECT:\n                if (on_connect(pool, val, etype & POLLERR))\n                    close_conn(pool, val);\n                continue;\n                \n            case EV_IGNORE:\n                if (etype & (POLLHUP | POLLERR | POLLRDHUP))\n                    close_conn(pool, val);\n                continue;\n            \n            default:\n                LOG(LOG_E, \"???\\n\");\n                NOT_EXIT = 0;\n        }\n    }\n    LOG(LOG_S, \"exit\\n\");\n    free(buffer);\n    destroy_pool(pool);\n    return 0;\n}\n\n\nint listen_socket(const union sockaddr_u *srv)\n{\n    int srvfd = nb_socket(srv->sa.sa_family, SOCK_STREAM);\n    if (srvfd < 0) {\n        uniperror(\"socket\");  \n        return -1;  \n    }\n    int opt = 1;\n    if (setsockopt(srvfd, SOL_SOCKET, \n            SO_REUSEADDR, (char *)&opt, sizeof(opt)) == -1) {\n        uniperror(\"setsockopt\");\n        close(srvfd);\n        return -1;\n    }\n    if (bind(srvfd, &srv->sa, SA_SIZE(srv)) < 0) {\n        uniperror(\"bind\");  \n        close(srvfd);\n        return -1;\n    }\n    if (listen(srvfd, 10)) {\n        uniperror(\"listen\");\n        close(srvfd);\n        return -1;\n    }\n    return srvfd;\n}\n\n\nint run(const union sockaddr_u *srv)\n{\n    #ifdef SIGPIPE\n    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n        uniperror(\"signal SIGPIPE!\");\n    #endif\n    signal(SIGINT, on_cancel);\n    signal(SIGTERM, on_cancel);\n    \n    int fd = listen_socket(srv);\n    if (fd < 0) {\n        return -1;\n    }\n    return event_loop(fd);\n}\n"
        },
        {
          "name": "proxy.h",
          "type": "blob",
          "size": 1.7119140625,
          "content": "#ifndef PROXY_H\n#define PROXY_H\n\n#include <stdint.h>\n\n#ifdef _WIN32\n    #include <ws2tcpip.h>\n#else\n    #include <arpa/inet.h>\n    #include <sys/socket.h>\n#endif\n\n#include \"conev.h\"\n\n#define SA_SIZE(s) \\\n    (((struct sockaddr *)s)->sa_family == AF_INET6) ? \\\n        sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)\n\n#pragma pack(push, 1)\n\nstruct s4_req {\n    uint8_t ver, cmd;\n    uint16_t port;\n    struct in_addr i4;\n};\n\nstruct s5_req {\n    uint8_t ver, cmd, zero, atp;\n    union {\n        struct {\n            struct in_addr ip;\n            uint16_t port;\n        } i4;\n        struct {\n            struct in6_addr ip;\n            uint16_t port;\n        } i6;\n        struct {\n            uint8_t len;\n            char domain[257];\n        } id;\n    } dst;\n};\n\nstruct s5_rep {\n    uint8_t ver, code, zero, atp;\n    struct {\n        struct in_addr i4;\n        uint16_t port;\n    } addr;\n};\n\n#pragma pack(pop)\n\n#define S_AUTH_NONE 0x00\n#define S_AUTH_BAD 0xff\n\n#define S_ATP_I4 0x01\n#define S_ATP_ID 0x03\n#define S_ATP_I6 0x04\n\n#define S_CMD_CONN 0x01\n#define S_CMD_BIND 0x02\n#define S_CMD_AUDP 0x03\n\n#define S_ER_OK 0x00\n#define S_ER_GEN 0x01\n#define S_ER_DENY 0x02\n#define S_ER_NET 0x03\n#define S_ER_HOST 0x04\n#define S_ER_CONN 0x05\n#define S_ER_TTL 0x06\n#define S_ER_CMD 0x07\n#define S_ER_ATP 0x08\n\n#define S4_OK 0x5a\n#define S4_ER 0x5b\n\n#define S_VER5 0x05\n#define S_VER4 0x04\n\n#define S_SIZE_MIN 8\n#define S_SIZE_I4 10\n#define S_SIZE_I6 22\n#define S_SIZE_ID 7\n\nvoid map_fix(union sockaddr_u *addr, char f6);\n\nint create_conn(struct poolhd *pool,\n        struct eval *val, const union sockaddr_u *dst, int next);\n \nint listen_socket(const union sockaddr_u *srv);\n\nint event_loop(int srvfd);\n\nint run(const union sockaddr_u *srv);\n\n#endif\n"
        },
        {
          "name": "win_service.c",
          "type": "blob",
          "size": 2.3837890625,
          "content": "#include \"win_service.h\"\n\n#include <windows.h>\n\n#define SERVICE_NAME \"ByeDPI\"\n\nstatic SERVICE_STATUS ServiceStatus;\nstatic SERVICE_STATUS_HANDLE hStatus;\n\nstatic int svc_argc = 0;\nstatic char **svc_argv = NULL;\n\nint main(int argc, char *argv[]);\n\nvoid service_ctrl_handler(DWORD request)\n{\n    switch(request)\n    {\n        case SERVICE_CONTROL_STOP:\n        case SERVICE_CONTROL_SHUTDOWN:\n            ServiceStatus.dwWin32ExitCode = 0;\n            ServiceStatus.dwCurrentState  = SERVICE_STOPPED;\n        default:\n            break;\n    }\n    SetServiceStatus(hStatus, &ServiceStatus);\n    return;\n}\n\nvoid service_main(int argc __attribute__((unused)), char *argv[] __attribute__((unused)))\n{\n    // Current working directory for services is %WinDir%\\System32, this breaks \n    // relative paths. Set working directory to the directory of the executable file.\n    char file_name[_MAX_PATH];\n    GetModuleFileNameA(NULL, file_name, sizeof(file_name));\n    char working_dir[_MAX_PATH], _tmp[_MAX_DIR];\n    _splitpath_s(file_name, working_dir, _MAX_DRIVE, _tmp, _MAX_DIR, NULL, 0, NULL, 0);\n    strcat_s(working_dir, sizeof(working_dir), _tmp);\n    SetCurrentDirectoryA(working_dir);\n\n    ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; \n    ServiceStatus.dwCurrentState = SERVICE_RUNNING;\n    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;\n    ServiceStatus.dwWin32ExitCode = 0;\n    ServiceStatus.dwServiceSpecificExitCode = 0;\n    ServiceStatus.dwCheckPoint = 1;\n    ServiceStatus.dwWaitHint = 0;\n\n    hStatus = RegisterServiceCtrlHandler(SERVICE_NAME, (LPHANDLER_FUNCTION)service_ctrl_handler);\n    if (hStatus == (SERVICE_STATUS_HANDLE)0)\n    {\n        // Registering Control Handler failed\n        return;\n    }\n\n    SetServiceStatus(hStatus, &ServiceStatus);\n\n    // Calling main with saved argc & argv\n    ServiceStatus.dwWin32ExitCode = (DWORD)main(svc_argc, svc_argv);\n    ServiceStatus.dwCurrentState  = SERVICE_STOPPED;\n    SetServiceStatus(hStatus, &ServiceStatus);\n    return;\n}\n\nint register_winsvc(int argc, char *argv[])\n{\n    SERVICE_TABLE_ENTRY ServiceTable[] = {\n        {SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)service_main},\n        {NULL, NULL}\n    };\n\n    // Save args passed to the program to use instead of the service args.\n    if (svc_argv) {\n        return 0;\n    }\n    svc_argc = argc;\n    svc_argv = argv;\n        \n    return StartServiceCtrlDispatcher(ServiceTable);\n}\n"
        },
        {
          "name": "win_service.h",
          "type": "blob",
          "size": 0.0439453125,
          "content": "int register_winsvc(int argc, char *argv[]);\n"
        }
      ]
    }
  ]
}