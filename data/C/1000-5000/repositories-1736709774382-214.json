{
  "metadata": {
    "timestamp": 1736709774382,
    "page": 214,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "neomutt/neomutt",
      "stars": 3311,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 2.0078125,
          "content": "freebsd_instance:\n  image_family: freebsd-14-1\n\ntask:\n  only_if: $CIRRUS_BRANCH == \"main\" || $CIRRUS_PR != \"\"\n  skip: $CIRRUS_PR_DRAFT == \"true\"\n  env:\n    CIRRUS_CLONE_DEPTH: 3\n    PKG_UPDATE: pkg update -f\n    PKG_INSTALL: pkg install -y\n    PKG_COMMON:\n      cyrus-sasl db5 docbook-xsl gdbm gettext-tools git gpgme iconv jimtcl\n      kyotocabinet libgpg-error libidn2 liblz4 libxslt lmdb lua53 lynx notmuch\n      pcre2 pkgconf qdbm tdb tokyocabinet urlview zstd\n    CONFIGURE_COMMON:\n      --autocrypt --bdb --disable-idn --disable-inotify --fmemopen --full-doc\n      --gdbm --gpgme --gss --homespool --idn2 --kyotocabinet --lmdb --locales-fix\n      --lua --lz4 --notmuch --pcre2 --qdbm --sasl --tdb\n      --tokyocabinet --with-domain=example.com --with-lock=flock --zlib --zstd\n  matrix:\n    - name: FreeBSD / Test\n      env:\n        NEOMUTT_TEST_DIR: ${CIRRUS_WORKING_DIR}/test-files\n      install_script:\n        - ${PKG_UPDATE}\n        - ${PKG_INSTALL} ${PKG_COMMON}\n        - git clone --depth 1 https://github.com/neomutt/neomutt-test-files.git ${NEOMUTT_TEST_DIR}\n        - (cd ${NEOMUTT_TEST_DIR} && ./setup.sh)\n      configure_script: ./configure --autocrypt --disable-doc --disable-idn --idn2 --notmuch --testing\n      build_script: make\n      version_script: ./neomutt -v\n      test_script: make test\n\n    - name: FreeBSD / OpenSSL\n      install_script:\n        - ${PKG_UPDATE}\n        - ${PKG_INSTALL} ${PKG_COMMON} openssl\n      configure_script: ./configure ${CONFIGURE_COMMON} --ssl\n      build_script: make\n      version_script: ./neomutt -v\n\n    - name: FreeBSD / LibreSSL\n      install_script:\n        - ${PKG_UPDATE}\n        - ${PKG_INSTALL} ${PKG_COMMON} libressl\n      configure_script: ./configure ${CONFIGURE_COMMON} --ssl\n      build_script: make\n      version_script: ./neomutt -v\n\n    - name: FreeBSD / GnuTLS\n      install_script:\n        - ${PKG_UPDATE}\n        - ${PKG_INSTALL} ${PKG_COMMON} gnutls\n      configure_script: ./configure ${CONFIGURE_COMMON} --gnutls\n      build_script: make\n      version_script: ./neomutt -v\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 2.583984375,
          "content": "Language: Cpp\n# BasedOnStyle\n\nTabWidth:          8\nUseTab:            Never\nIndentWidth:       2\nColumnLimit:       80\nBreakBeforeBraces: Allman\n\nIncludeCategories:\n  # Standard library headers\n  - Regex:      '\"config\\.h\"'\n    Priority:   -130\n  - Regex:      '\"acutest\\.h\"'\n    Priority:   -120\n  - Regex:      '<.*>'\n    Priority:   -100\n\n  # Backend private header\n  - Regex:      '\"private\\.h\"'\n    Priority:   -90\n\n  # NeoMutt library headers\n  - Regex:      '\"mutt/.*\\.h\"'\n    Priority:   -80\n  - Regex:      '\"address/.*\\.h\"'\n    Priority:   -70\n  - Regex:      '\"config/.*\\.h\"'\n    Priority:   -60\n  - Regex:      '\"email/.*\\.h\"'\n    Priority:   -50\n  - Regex:      '\"core/.*\\.h\"'\n    Priority:   -40\n  - Regex:      '\"alias/.*\\.h\"'\n    Priority:   -35\n  - Regex:      '\"conn/.*\\.h\"'\n    Priority:   -30\n  - Regex:      '\"gui/.*\\.h\"'\n    Priority:   -20\n\n  # NeoMutt general purpose headers\n  - Regex:      '\"mutt\\.h\"'\n    Priority:   -10\n  - Regex:      '\"debug/.*\\.h\"'\n    Priority:   -5\n\n  # Main Header 0\n\n  # Backend using its own library header\n  - Regex:      '\"lib\\.h\"'\n    Priority:   2\n\n  # All backend library headers\n  - Regex:      '\".*/lib\\.h\"'\n    Priority:   5\n\n  # All other NeoMutt headers\n  - Regex:      '\".*\"'\n    Priority:   10\n\nAlignAfterOpenBracket:            true\nAlignEscapedNewlinesLeft:         false\nAlignOperands:                    true\nAlignTrailingComments:            true\nAlwaysBreakAfterReturnType:       None\nBinPackArguments:                 true\nBinPackParameters:                true\nBreakBeforeBinaryOperators:       false\nBreakBeforeTernaryOperators:      false\nCpp11BracedListStyle:             false\nDerivePointerAlignment:           false\nIndentCaseLabels:                 true\nIndentWrappedFunctionNames:       false\nKeepEmptyLinesAtTheStartOfBlocks: false\nMaxEmptyLinesToKeep:              1\nPointerAlignment:                 Right\nReflowComments:                   false\nSortIncludes:                     true\nSpaceAfterCStyleCast:             true\nSpaceBeforeAssignmentOperators:   true\nSpaceBeforeParens:                ControlStatements\nSpaceInEmptyParentheses:          false\nSpacesInCStyleCastParentheses:    false\nSpacesInParentheses:              false\nSpacesInSquareBrackets:           false\n\nPenaltyBreakAssignment: 100\nPenaltyBreakBeforeFirstCallParameter: 100\nBreakStringLiterals: false\n\n# Allow some slightly over-long lines\nPenaltyExcessCharacter: 1\n\n# NEVER\nAllowShortFunctionsOnASingleLine:    false\nAllowShortBlocksOnASingleLine:       false\nAllowShortCaseLabelsOnASingleLine:   false\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine:        false\n\n"
        },
        {
          "name": ".clang_complete.in",
          "type": "blob",
          "size": 0.021484375,
          "content": "@cflags-one-per-line@\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2802734375,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\ntrim_trailing_whitespace = false\n\n# those two settings may be overwritten below.\nindent_size = 2\nindent_style = space\n\n[ChangeLog.md]\nindent_size = 2\n\n[{[mM]akefile*,*.am}]\nindent_size = 4\nindent_style = tab\n\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0234375,
          "content": "*.h linguist-language=C\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6064453125,
          "content": "# Autosetup\n.clang_complete\nautosetup/jimsh0\nconfig.log\nconftest__\nconftest__.c\nMakefile\njimsh0\n\n# Binaries\ndocs/makedoc\nneomutt\npgpewrap\ntest/neomutt-test\nfuzz/address-fuzz\nfuzz/date-fuzz\n\n# Build products\n*.o\n*.o.json\n*.gc??\n*.Po\n*.Tpo\ncoverage\ncoverage.info\nhtml\nlib*.a\npo/*.mo\npo/neomutt.pot\npo/POTFILES\n\n# Docs\ndocs/*.html\ndocs/manual.txt\ndocs/manual.xml\ndocs/neomutt.1\ndocs/neomuttrc\ndocs/neomuttrc.5\n\n# Generated source\nconfig.h\nconststrings.c\ngit_ver.c\nhcache/hcversion.h\n\n# Misc\n*.tmp\n*~\ntags\n!tags/\nasan.*\n.env\n\n# Clangd\n.cache/clangd\ncompile_commands.*\n\n# Intellij IDEs\n.idea\n\n# gcc -fdump-rtl-expand\n*.expand\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 60.3671875,
          "content": "## NeoMutt Contributors - auto-generated: https://github.com/neomutt/authors/tree/main/git\nСтрахиња Радић (@strahinja) <sr@strahinja.org>\tСтрахиња Радић <contact@strahinja.org>\nСтрахиња Радић (@strahinja) <sr@strahinja.org>\tСтрахиња Радић <sr@strahinja.org>\n李经纬 (@ljw20180420) <ljw2017@sjtu.edu.cn>\t李经纬 <ljw2017@sjtu.edu.cn>\nнаб (@nabijaczleweli) <nabijaczleweli@nabijaczleweli.xyz>\tнаб <nabijaczleweli@gmail.com>\nнаб (@nabijaczleweli) <nabijaczleweli@nabijaczleweli.xyz>\tнаб <nabijaczleweli@nabijaczleweli.xyz>\nAdam Borowski (@kilobyte) <kilobyte@angband.pl>\tAdam Borowski <kilobyte@angband.pl>\nAdam Dinwoodie (@me-and) <adam@dinwoodie.org>\tAdam Dinwoodie <adam@dinwoodie.org>\nAdam Korcz (@adamkorcz) <44787359+AdamKorcz@users.noreply.github.com>\tAdam Korcz <44787359+AdamKorcz@users.noreply.github.com>\nAdam Korcz (@adamkorcz) <44787359+AdamKorcz@users.noreply.github.com>\tAdamKorcz <44787359+AdamKorcz@users.noreply.github.com>\nAditya De Saha (@adityadesaha) <adityadesaha@gmail.com>\tAditya De Saha <adityadesaha@gmail.com>\nAdán Somoza (@darkadin) <adansomoza@outlook.com>\tAdán Somoza <adansomoza@outlook.com>\nAdán Somoza (@darkadin) <adansomoza@outlook.com>\tDarkAdin <adansomoza@outlook.com>\nAhmed El Gabri (@ahmedelgabri) <ahmed@gabri.me>\tAhmed El Gabri <ahmed@gabri.me>\nAhmed El Gabri (@ahmedelgabri) <ahmed@gabri.me>\tAhmed El Gabri <ahmed+github@gabri.me>\nAlad Wenter (@aladw) <AladW@users.noreply.github.com>\tAlad Wenter <AladW@users.noreply.github.com>\nAlbert Kim (@alkim0) <alkim@alkim.org>\tAlbert Kim <alkim@alkim.org>\nAlejandro Colomar (@alejandro-colomar) <alx@kernel.org>\tAlejandro Colomar <alx@kernel.org>\nAleksa Sarai (@cyphar) <cyphar@cyphar.com>\tAleksa Sarai <cyphar@cyphar.com>\nAlex Pearce (@alexpearce) <alex@alexpearce.me>\tAlex Pearce <alex@alexpearce.me>\nAlexander Kuleshov (@onlyshk) <kuleshovmail@gmail.com>\tAlexander Kuleshov <kuleshovmail@gmail.com>\nAlexandre Simon (@igit) <as@as-home.fr>\tAlexandre SIMON <as@as-home.fr>\nAlexandre Simon (@igit) <as@as-home.fr>\tAlexandre Simon <as@as-home.fr>\nAlexey Vishnyakov (@sweetvishnya) <vishnya@ispras.ru>\tAlexey Vishnyakov <vishnya@ispras.ru>\nAllan Nordhøy (@comradekingu) <epost@anotheragency.no>\tAllan Nordhøy <epost@anotheragency.no>\nAlvaro Herrera (@alvherre) <alvherre@alvh.no-ip.org>\tAlvaro Herrera <alvherre@alvh.no-ip.org>\nAlyssa Ross (@alyssais) <hi@alyssa.is>\tAlyssa Ross <hi@alyssa.is>\nAndré Berger (@hvkls) <ab@andreberger.eu>\tab <Andre Berger andre.berger@web.de>\nAndré Berger (@hvkls) <ab@andreberger.eu>\tAndré Berger <ab@andreberger.eu>\nAndré Berger (@hvkls) <ab@andreberger.eu>\tAndré Berger <andre.berger@web.de>\nAndré L C Moreira (@carvalhudo) <andrelcmoreira@disroot.org>\tAndré L C Moreira <andrelcmoreira@disroot.org>\nAndré L C Moreira (@carvalhudo) <andrelcmoreira@disroot.org>\tAndré L. C. Moreira <andrelcmoreira@disroot.org>\nAndreas Rammhold (@andir) <andreas@rammhold.de>\tAndreas Rammhold <andreas@rammhold.de>\nAndres Freund (@anarazel) <andres@anarazel.de>\tAndres Freund <andres@anarazel.de>\nAndrij Mizyk (@andmzk) <andmizyk@gmail.com>\tAndrij Mizyk <andmizyk@gmail.com>\nAnna (navi) Figueiredo Gomes (@navi-desu) <navi@vlhl.dev>\tAnna (navi) Figueiredo Gomes <navi@vlhl.dev>\nAntoine Amarilli (@a3nm) <a3nm@a3nm.net>\tAntoine Amarilli <a3nm@a3nm.net>\nAntoine Beaupré (@anarcat) <anarcat@debian.org>\tanarcat <anarcat@users.noreply.github.com>\nAntoine Beaupré (@anarcat) <anarcat@debian.org>\tAntoine Beaupré <anarcat@debian.org>\nAnton Rieger (@inrin) <seishinryohosha@jikken.de>\tAnton Rieger <seishinryohosha@jikken.de>\nAnton Rieger (@inrin) <seishinryohosha@jikken.de>\tseishinryohosha <seishinryohosha@users.noreply.github.com>\nAntonio Radici (@aradici) <antonio@dyne.org>\tAntonio Radici <antonio@dyne.org>\nAntonio Radici (@aradici) <antonio@dyne.org>\tUnknown <antonio@dyne.org>\nashamedbit (@ashamedbit) <muralianiruddhan@gmail.com>\tashamedbit <muralianiruddhan@gmail.com>\nAshish Panigrahi (@paniash) <ashish.panigrahi@protonmail.com>\tAshish Panigrahi <ashish.panigrahi@protonmail.com>\nauouymous (@auouymous) <au@qzx.com>\tauouymous <au@qzx.com>\nAurelien Francillon (@aurelf) <aurelien.francillon@eurecom.fr>\tAurelien Francillon <aurelien.francillon@eurecom.fr>\nAustin Lund (@aplund) <austin.lund@gmail.com>\tAustin Lund <austin.lund@gmail.com>\nAustin Ray (@austin-ray) <austin@austinray.io>\tAustin Ray <austin@austinray.io>\nAustin Ray (@austin-ray) <austin@austinray.io>\tAustin Ray <austin.duke.ray@gmail.com>\nBaudouin Van Humbeck (@scriptor-pro) <bvh@scriptor.pro>\tBaudouin Van Humbeck <bvh@scriptor.pro>\nBenjamin Mako Hill (@makoshark) <mako@atdot.cc>\tBenjamin Mako Hill <mako@atdot.cc>\nBernard Pratz (@guyzmo) <guyzmo+github+pub@m0g.net>\tBernard 'Guyzmo' Pratz <guyzmo+github+pub@m0g.net>\nBernard Pratz (@guyzmo) <guyzmo+github+pub@m0g.net>\tBernard Pratz <guyzmo+github+pub@m0g.net>\nBernard Pratz (@guyzmo) <guyzmo+github+pub@m0g.net>\tGuyzmo <guyzmo+github+pub@m0g.net>\nBernard Pratz (@guyzmo) <guyzmo+github+pub@m0g.net>\tguyzmo <guyzmo+github+pub@m0g.net>\nBertram Scharpf (@bertramscharpf) <software@bertram-scharpf.de>\tBertram Scharpf <software@bertram-scharpf.de>\nBjörn Ketelaars (@bket) <bjorn.ketelaars@hydroxide.nl>\tBjörn Ketelaars <bjorn.ketelaars@hydroxide.nl>\nBletchley Park <18015852+libBletchley@users.noreply.github.com>\tBletchley Park <18015852+libBletchley@users.noreply.github.com>\nBo Yu (@yuzibo) <tsu.yubo@gmail.com>\tBo <tsu.yubo@gmail.com>\nBo Yu (@yuzibo) <tsu.yubo@gmail.com>\tBo Yu <tsu.yubo@gmail.com>\nBo Yu (@yuzibo) <tsu.yubo@gmail.com>\tBo YU <yuzibode@126.com>\nBrendan McLean (@bmclean2) <brendan.mclean@gmail.com>\tbmclean2 <brendan.mclean@posteo.net>\nBrendan McLean (@bmclean2) <brendan.mclean@gmail.com>\tBrendan McLean <brendan.mclean@gmail.com>\nBrett Holman (@holmanb) <bholman.devel@gmail.com>\tBrett Holman <bholman.devel@gmail.com>\nBryan Bennett (@bbenne10) <bbenne10@gmail.com>\tBryan Bennett <bbenne10@gmail.com>\nCarlo Cabrera (@carlocab) <30379873+carlocab@users.noreply.github.com>\tCarlo Cabrera <30379873+carlocab@users.noreply.github.com>\nCarlos Henrique Lima Melara (@charles2910) <charlesmelara@riseup.net>\tCarlos Henrique Lima Melara <34252251+charles2910@users.noreply.github.com>\nCarlos Henrique Lima Melara (@charles2910) <charlesmelara@riseup.net>\tCarlos Henrique Lima Melara <charlesmelara@outlook.com>\nCarlos Henrique Lima Melara (@charles2910) <charlesmelara@riseup.net>\tCarlos Henrique Lima Melara <charlesmelara@riseup.net>\nCasper Ti Vector (@caspervector) <CasperVector@gmail.com>\tCasper Ti Vector <CasperVector@gmail.com>\nCasper Ti Vector (@caspervector) <CasperVector@gmail.com>\tCasper Ti. Vector <CasperVector@gmail.com>\nChao-Kuei Hung (@ckhung) <ckhung@cyut.edu.tw>\tChao-Kuei Hung <ckhung@cyut.edu.tw>\nCharalampos Kardaris (@ckardaris) <ckardaris@outlook.com>\tCharalampos Kardaris <ckardaris@outlook.com>\nCharlie Drage (@cdrage) <charlie@charliedrage.com>\tCharlie Drage <charlie@charliedrage.com>\nChris Czettel (@christopher-john-czettel) <chris@christopher-czettel.net>\tChris Czettel <chris@christopher-czettel.net>\nChris Czettel (@christopher-john-czettel) <chris@christopher-czettel.net>\tchrissl <chris@christopher-czettel.net>\nChris Czettel (@christopher-john-czettel) <chris@christopher-czettel.net>\tChristopher John CZETTEL <chris@christopher-czettel.net>\nChris Salzberg (@shioyama) <chris@dejimata.com>\tChris Salzberg <chris@dejimata.com>\nChris Salzberg (@shioyama) <chris@dejimata.com>\tChris Salzberg <csalzberg@degica.com>\nChris X Weichenberger (@the-x-at) <cweich@cosy.sbg.ac.at>\tChris X Weichenberger <cweich@cosy.sbg.ac.at>\nChris X Weichenberger (@the-x-at) <cweich@cosy.sbg.ac.at>\tChris X. Weichenberger (@the-x-at) <cweich@cosy.sbg.ac.at>\nChristian Dröge (@cdroege) <mail@cdroege.de>\tChristian Dröge <mail@cdroege.de>\nChristian Lütke-Stetzkamp (@clkamp) <clkamp@lkamp.de>\tChristian Lütke-Stetzkamp <clkamp@lkamp.de>\nChristian Lütke-Stetzkamp (@clkamp) <clkamp@lkamp.de>\tChristian Luetke Stetzkamp <clkamp@lkamp.de>\nChristian Ludwig (@luchr) <ludwig@ma.tum.de>\tChristian Ludwig <ludwig@ma.tum.de>\nChristian Storm (@stormc) <storm@mailbox.org>\tChristian Storm <storm@mailbox.org>\nChristoph Berg (@df7cb) <cb@df7cb.de>\tChristoph Berg <cb@df7cb.de>\nChristos Margiolis (@christosmarg) <christos@margiolis.net>\tChristos Margiolis <christos@christosmarg.xyz>\nChristos Margiolis (@christosmarg) <christos@margiolis.net>\tChristos Margiolis <christos@margiolis.net>\ncinder88 (@cinder88) <aerlanger@owlcti.com>\tate <aerlanger@owlcti.com>\ncinder88 (@cinder88) <aerlanger@owlcti.com>\tcinder88 <aerlanger@owlcti.com>\nClaes Nästén (@pekdon) <pekdon@gmail.com>\tClaes Nästén <pekdon@gmail.com>\nClemens Lang (@neverpanic) <neverpanic@gmail.com>\tClemens Lang <neverpanic@gmail.com>\nCody Brownstein (@cbrownstein) <cbrownstein@liquidityllc.com>\tCody Brownstein <cbrownstein@liquidityllc.com>\nColin Wee (@googlebleh) <2gbleh@gmail.com>\tColin Wee <2gbleh@gmail.com>\nDai Mochinaga (@mochidai) <mochidai@gmail.com>\tDai Mochinaga <mochidai@gmail.com>\nDai Mochinaga (@mochidai) <mochidai@gmail.com>\tmochidai <mochidai@gmail.com>\nDamien Riegel (@d-k-c) <damien.riegel@gmail.com>\tDamien R <d-k-c@users.noreply.github.com>\nDamien Riegel (@d-k-c) <damien.riegel@gmail.com>\tDamien Riegel <damien.riegel@gmail.com>\nDamien Riegel (@d-k-c) <damien.riegel@gmail.com>\tDamien Riegel <damien@riegel.io>\nDamien Riegel (@d-k-c) <damien.riegel@gmail.com>\tDamien Riegel <damien.riegel@savoirfairelinux.com>\nDaniel Gray (@dngray) <dng@disroot.org>\tDaniel Gray <dng@disroot.org>\nDaniel Gröber (@danielg) <dxld@darkboxed.org>\tDaniel Gröber <dxld@darkboxed.org>\nDaniel Klose <info@daklose.de>\tDaniel Klose <info@daklose.de>\nDaniel Maslowski (@orangecms) <info@orangecms.org>\tDaniel Maslowski <info@orangecms.org>\nDapeng Gao (@dpgao) <peter@dpgao.cc>\tDapeng Gao <31944689+dpgao@users.noreply.github.com>\nDapeng Gao (@dpgao) <peter@dpgao.cc>\tDapeng Gao <peter@dpgao.cc>\nDarrel Glud (@darrel-glud) <65591041+darrel-glud@users.noreply.github.com>\tDarrel Glud <65591041+darrel-glud@users.noreply.github.com>\nDarrel Glud (@darrel-glud) <65591041+darrel-glud@users.noreply.github.com>\tdarrel-glud <65591041+darrel-glud@users.noreply.github.com>\nDarren Kenny (@darrenkenny) <darren.kenny@oracle.com>\tDarren Kenny <darren.kenny@oracle.com>\nDarshit Shah (@darnir) <git@darnir.net>\tDarshit Shah <darnir@gmail.com>\nDarshit Shah (@darnir) <git@darnir.net>\tDarshit Shah <darnir@users.noreply.github.com>\nDarshit Shah (@darnir) <git@darnir.net>\tDarshit Shah <git@darnir.net>\nDavid Harrigan (@dharrigan) <dharrigan@gmail.com>\tDavid Harrigan <dharrigan@gmail.com>\nDavid Purton (@dcpurton) <dcpurton@marshwiggle.net>\tDavid Purton <dcpurton@marshwiggle.net>\nDavid Sterba (@kdave) <dsterba@suse.cz>\tDavid Sterba <dsterba@suse.com>\nDavid Sterba (@kdave) <dsterba@suse.cz>\tDavid Sterba <dsterba@suse.cz>\nDeng Xiyue (@manphiz) <manphiz@gmail.com>\tDeng Xiyue <manphiz@gmail.com>\nDennis Schön (@roccoblues) <mail@dennis-schoen.de>\tDennis Schön <mail@dennis-schoen.de>\nDimitrios Semitsoglou-Tsiapos (@dset0x) <kmhzsem@gmx.com>\tDimitrios Semitsoglou-Tsiapos <kmhzsem@gmx.com>\nDmitry Polunin (@frei-0xff) <frei-0xff@users.noreply.github.com>\tDmitry Polunin <frei-0xff@users.noreply.github.com>\nDmitry Polunin (@frei-0xff) <frei-0xff@users.noreply.github.com>\tfrei-0xff <frei-0xff@users.noreply.github.com>\nDoron Behar (@doronbehar) <doron.behar@gmail.com>\tDoron Behar <doron.behar@gmail.com>\nDoug Stone-Weaver (@doweaver) <doug@stone-weaver.com>\tDoug Stone-Weaver <doug@stone-weaver.com>\nEduardo Habkost (@ehabkost) <ehabkost@redhat.com>\tEduardo Habkost <ehabkost@redhat.com>\nEdward Betts (@edwardbetts) <edward@4angle.com>\tEdward Betts <edward@4angle.com>\nEl Acheche ANIS (@elacheche) <elacheche@ubuntu.com>\tEl Acheche ANIS <elacheche@ubuntu.com>\nEli Winderickx (@winderickxeli) <eli.winderickx@ap.be>\tEli Winderickx <eli.winderickx@ap.be>\nEli Winderickx (@winderickxeli) <eli.winderickx@ap.be>\tWinderickx Eli (p087068) <eli.winderickx@ap.be>\nElimar Riesebieter (@riesebie) <riesebie@lxtec.de>\tElimar Riesebieter <riesebie@lxtec.de>\nEmir Sari (@bitigchi) <emir_sari@icloud.com>\tEmir Sari <emir_sari@icloud.com>\nEnno Nagel (@konfekt) <Konfekt@users.noreply.github.com>\tEnno <Konfekt@users.noreply.github.com>\nEnno Nagel (@konfekt) <Konfekt@users.noreply.github.com>\tEnno Nagel <Konfekt@users.noreply.github.com>\nEric Blake (@ebblake) <eblake@redhat.com>\tEric Blake <eblake@redhat.com>\nFabian Groffen (@grobian) <grobian@gentoo.org>\tFabian Groffen <grobian@gentoo.org>\nFabian Groffen (@grobian) <grobian@gentoo.org>\tFabian Groffen <grobian@orakel.ods.org>\nFabrice Bellet (@fbellet) <fabrice@bellet.info>\tFabrice Bellet <fabrice@bellet.info>\nFederico Kircheis (@fekir) <federico.kircheis@gmail.com>\tFederico Kircheis <federico.kircheis@gmail.com>\nFederico Kircheis (@fekir) <federico.kircheis@gmail.com>\tfekir <federico.kircheis@gmail.com>\nFlorian Klink (@flokli) <flokli@flokli.de>\tFlorian Klink <flokli@flokli.de>\nFlorian Wehner (@whnr) <florian@whnr.de>\tFlorian Wehner <florian@whnr.de>\nFloyd Anderson (@floand) <f.a@31c0.net>\tFloyd Anderson <f.a@31c0.net>\nFrank Grüllich (@FrankGruellich) <frank.gruellich@gmail.com>\tFrank Grüllich <frank.gruellich@gmail.com>\nFrantišek Hájik (@ferkohajik) <ferko.hajik@gmail.com>\tFrantišek Hájik <ferko.hajik@gmail.com>\nFrederick Eaton (@archenemies) <frederik@ofb.net>\tFrederick Eaton <frederik@ofb.net>\nFreed-Wu (@wzy) <wuzy01@qq.com>\tFreed-Wu <wuzy01@qq.com>\nFreed-Wu (@wzy) <wuzy01@qq.com>\twzy <32936898+Freed-Wu@users.noreply.github.com>\nftilde (@ftilde) <ftilde@tamepointer.de>\tftilde <ftilde@protonmail.com>\nftilde (@ftilde) <ftilde@tamepointer.de>\tftilde <ftilde@tamepointer.de>\nGaël Dubois (@gaael) <chti.gdb@gmail.com>\tGaël Dubois <chti.gdb@gmail.com>\nGerrit Rüsing (@kbcb) <gerrit@macclub-os.de>\tGerrit <gerrit@macclub-os.de>\nGerrit Rüsing (@kbcb) <gerrit@macclub-os.de>\tGerrit Rüsing <gerrit@macclub-os.de>\nGerrit Rüsing (@kbcb) <gerrit@macclub-os.de>\tGerrit <ruesing@posteo.de>\nGerrit Rüsing (@kbcb) <gerrit@macclub-os.de>\tkbcb <gerrit@macclub-os.de>\nGuillaume Brogi (@guiniol) <gui-gui@netcourrier.com>\tGuillaume Brogi <gui-gui@netcourrier.com>\nGuillaume Brogi (@guiniol) <gui-gui@netcourrier.com>\tguiniol <gui-gui@netcourrier.com>\nH N Caldwell <unknown>\tH N Caldwell <unknown>\nH N Caldwell <unknown>\thncaldwell <unknown>\nHaoyu Qiu (@timothyqiu) <timothyqiu32@gmail.com>\tHaoyu Qiu <timothyqiu32@gmail.com>\nHelge Deller (@hdeller) <deller@gmx.de>\tHelge Deller <deller@gmx.de>\nHerbert J Skuhra <herbert@gojira.at>\tHerbert J Skuhra <herbert@gojira.at>\nHugo Barrera (@whynothugo) <hugo@barrera.io>\tHugo Barrera <hugo@barrera.io>\nHugo Barrera (@whynothugo) <hugo@barrera.io>\tHugo Osvaldo Barrera <hugo@barrera.io>\nIan Zimmerman (@nobrowser) <itz@no-use.mooo.com>\tIan Zimmerman <itz@no-use.mooo.com>\nIan Zimmerman (@nobrowser) <itz@no-use.mooo.com>\tIan Zimmerman <itz@primate.net>\nIan Zimmerman (@nobrowser) <itz@no-use.mooo.com>\tIan Zimmerman <itz@very.loosely.org>\nIan Zimmerman (@nobrowser) <itz@no-use.mooo.com>\tIan Zimmerman <nobrowser@users.noreply.github.com>\nIgor Serebryany (@igor47) <igor47@moomers.org>\tIgor Serebryany <igor47@moomers.org>\nIhor Antonov (@ngortheone) <ihor@antonovs.family>\tIhor Antonov <ihor@antonovs.family>\nIlya Kurdyukov (@ilyakurdyukov) <59548320+ilyakurdyukov@users.noreply.github.com>\tIlya Kurdyukov <59548320+ilyakurdyukov@users.noreply.github.com>\nIsmaël Bouya (@immae) <ismael.bouya@normalesup.org>\tIsmaël Bouya <ismael.bouya@normalesup.org>\nIvan Jelincic (@parazyd) <parazyd@dyne.org>\tIvan J <parazyd@dyne.org>\nIvan Jelincic (@parazyd) <parazyd@dyne.org>\tIvan J <parazyd@users.noreply.github.com>\nIvan Jelincic (@parazyd) <parazyd@dyne.org>\tIvan Jelincic <parazyd@dyne.org>\nIvan Jelincic (@parazyd) <parazyd@dyne.org>\tparazyd <parazyd@dyne.org>\nIvan Shmakov <ivan@siamics.net>\tIvan Shmakov <ivan@siamics.net>\nIvan Tham (@pickfire) <pickfire@riseup.net>\tIvan Tham <pickfire@riseup.net>\nJ Lewis Muir (@jlmuir) <jlmuir@imca-cat.org>\tJ Lewis Muir <jlmuir@imca-cat.org>\nJ Lewis Muir (@jlmuir) <jlmuir@imca-cat.org>\tJ. Lewis Muir <jlmuir@imca-cat.org>\nJack Stratton (@phroa) <jack@phroa.net>\tJack Stratton <jack@phroa.net>\nJakub Jindra (@jindraj) <jakub.jindra@socialbakers.com>\tJakub Jindra <jakub.jindra@socialbakers.com>\nJakub Jindra (@jindraj) <jakub.jindra@socialbakers.com>\tJakub Jindra <jindraj@users.noreply.github.com>\nJakub Jindra (@jindraj) <jakub.jindra@socialbakers.com>\tJakub Jindra <skomonster@gmail.com>\nJakub Jindra (@jindraj) <jakub.jindra@socialbakers.com>\tJakub Jindra <jakub.jindra@socialbakers.com>\nJakub Jindra (@jindraj) <jakub.jindra@socialbakers.com>\tJakub Jindra <skomonster@gmail.com>\nJakub Kaczor (@jakubkaczor) <jakubk0.kaczor@gmail.com>\tJakub Kaczor <jakubk0.kaczor@gmail.com>\nJakub Wilk (@jwilk) <jwilk@jwilk.net>\tJakub Wilk <jwilk@jwilk.net>\nJames Cook (@falsifian) <falsifian@falsifian.org>\tJames Cook <falsifian@falsifian.org>\nJames Vaughan (@jamesbvaughan) <james@jamesbvaughan.com>\tJames Vaughan <james@jamesbvaughan.com>\nJan Krieg (@jan-krieg) <jan.krieg.github796@magnonic.net>\tJan Krieg <jan.krieg.github796@magnonic.net>\nJan Palus (@jpalus) <jpalus@fastmail.com>\tJan Palus <jpalus@fastmail.com>\nJangho Seo (@seojangho) <jangho@jangho.io>\tJangho Seo <jangho@jangho.io>\nJasper Adriaanse (@jasperla) <jasper@humppa.nl>\tJasper Adriaanse <jasper@humppa.nl>\nJasper Adriaanse (@jasperla) <jasper@humppa.nl>\tJasper Lievisse Adriaanse <jasper@humppa.nl>\nJelle van der Waa (@jelly) <jelle@vdwaa.nl>\tJelle van der Waa <jelle@vdwaa.nl>\nJenya Sovetkin (@esovetkin) <e.sovetkin@gmail.com>\tJenya Sovetkin <e.sovetkin@gmail.com>\nJerikoOne (@jeriko-one) <jeriko.one@gmx.us>\tJerikoOne <jeriko.one@gmx.us>\nJoey Pabalinas (@alyptik) <joeypabalinas@gmail.com>\tJoey Pabalinas <joeypabalinas@gmail.com>\nJohannes Frankenau <johannes@frankenau.net>\tJohannes Frankenau <johannes@frankenau.net>\nJohannes Weißl (@weisslj) <jargon@molb.org>\tJohannes Weißl <jargon@molb.org>\nJohn Wood (@john-at-charpa) <john@charpa.org>\tJohn Wood <john@charpa.org>\nJonas Witschel (@diabonas) <git@diabonas.de>\tJonas Witschel <diabonas@gmx.de>\nJonas Witschel (@diabonas) <git@diabonas.de>\tJonas Witschel <git@diabonas.de>\nJonathan Perkin (@jperkin) <jperkin@netbsd.org>\tJonathan Perkin <jperkin@netbsd.org>\nJoseph Bisch (@josephbisch) <joseph.bisch@gmail.com>\tJoseph Bisch <joseph.bisch@gmail.com>\nJosh Poimboeuf (@jpoimboe) <jpoimboe@redhat.com>\tJosh Poimboeuf <jpoimboe@redhat.com>\nJoshua Jordi (@jakkinstewart) <dracogoyle@gmail.com>\tJakkin <dracogoyle@gmail.com>\nJoshua Jordi (@jakkinstewart) <dracogoyle@gmail.com>\tJoshua Jordi <dracogoyle@gmail.com>\nJoshua Jordi (@jakkinstewart) <dracogoyle@gmail.com>\tJoshua Jordi <JakkinStewart@users.noreply.github.com>\nJulian Andres Klode (@julian-klode) <jak@jak-linux.org>\tJulian Andres Klode <jak@jak-linux.org>\nJustin Vasel (@justinvasel) <justin.vasel@gmail.com>\tJustin Vasel <justin.vasel@gmail.com>\nKarel Zak (@karelzak) <kzak@redhat.com>\tKarel Zak <kzak@redhat.com>\nKevin Decherf (@kdecherf) <kevin@kdecherf.com>\tKevin Decherf <kevin@kdecherf.com>\nKevin Velghe (@paretje) <kevin@paretje.be>\tKevin Velghe <kevin@paretje.be>\nLarry Rosenman (@lrosenman) <larryrtx@gmail.com>\tLarry Rosenman <larryrtx@gmail.com>\nLars Haalck (@larshaalck) <lars.haalck@uni-muenster.de>\tLars Haalck <lars.haalck@uni-muenster.de>\nLars Haalck (@larshaalck) <lars.haalck@uni-muenster.de>\tLars Haalck <l_haal02@uni-muenster.de>\nLars Kellogg-Stedman (@larsks) <lars@oddbit.com>\tLars Kellogg-Stedman <lars@oddbit.com>\nLeo Lundgren (@rawtaz) <leo@finalresort.org>\tLeo Lundgren <leo@finalresort.org>\nLeo Lundgren (@rawtaz) <leo@finalresort.org>\tLeo R. Lundgren <leo@finalresort.org>\nLeo Lundgren (@rawtaz) <leo@finalresort.org>\trawtaz <rawtaz@users.noreply.github.com>\nLeon Philman (@leonphilman) <125726770+leonphilman@users.noreply.github.com>\tLeon Philman <125726770+leonphilman@users.noreply.github.com>\nLeon Philman (@leonphilman) <125726770+leonphilman@users.noreply.github.com>\tleonphilman <125726770+leonphilman@users.noreply.github.com>\nLeonardo Schenkel (@lbschenkel) <leonardo@schenkel.net>\tLeonardo Brondani Schenkel <leonardo@schenkel.net>\nLeonardo Schenkel (@lbschenkel) <leonardo@schenkel.net>\tLeonardo Schenkel <leonardo@schenkel.net>\nLeonidas Spyropoulos (@inglor) <artafinde@gmail.com>\tLeonidas Spyropoulos <artafinde@gmail.com>\nLouis Brauer (@louis77) <louis@openbooking.ch>\tLouis Brauer <louis@openbooking.ch>\nLucas Bourneuf (@aluriak) <lucas.bourneuf@laposte.net>\tAluriak <lucas.bourneuf@laposte.net>\nLucas Bourneuf (@aluriak) <lucas.bourneuf@laposte.net>\tLucas Bourneuf <lucas.bourneuf@laposte.net>\nLucian Langa (@lucilanga) <lucilanga@7pot.org>\tLucian Langa <lucilanga@7pot.org>\nMaarten van Gompel (@proycon) <proycon@anaproy.nl>\tMaarten van Gompel <proycon@anaproy.nl>\nManos Pitsidianakis (@epilys) <el13635@mail.ntua.gr>\tManos Pitsidianakis <el13635@mail.ntua.gr>\nMarcelo Ricardo Leitner (@marceloleitner) <mleitner@redhat.com>\tMarcelo Ricardo Leitner <mleitner@redhat.com>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner lenovo <mrajner@gik.pw.edu.pl>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner <mrajner@chalmers>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner <mrajner@gik.pw.edu.pl>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner <mrajner@lenovo>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner <mrajner@lenovoarch>\nMarcin Rajner (@mrajner) <mrajner@gik.pw.edu.pl>\tMarcin Rajner <mrajner@pwarch>\nMarco Hinz (@mhinz) <mh.codebro@gmail.com>\tMarco Hinz <mh.codebro@gmail.com>\nMarco Sirabella (@mjsir911) <marco@sirabella.org>\tMarco Sirabella <marco@sirabella.org>\nMarius Gedminas (@mgedmin) <marius@gedmin.as>\tMarius Gedminas <marius@gedmin.as>\nMark Stenglein (@ocelotsloth) <mark@stengle.in>\tMark Stenglein <mark@stengle.in>\nMateus Etto (@yutsuten) <mateus.etto@proton.me>\tMateus Etto <mateus.etto@proton.me>\nMateusz Okulus (@mokulus) <mmokulus@gmail.com>\tMateusz Okulus <mmokulus@gmail.com>\nMateusz Piotrowski (@0mp) <mpp302@gmail.com>\tMateusz Piotrowski <mpp302@gmail.com>\nMatteo Riondato (@rionda) <rionda@acm.org>\tMatteo Riondato <rionda@acm.org>\nMatthew Hughes (@matthewhughes934) <matthewhughes934@gmail.com>\tMatthew Hughes <matthewhughes934@gmail.com>\nMatthias Gerstner (@mgerstner) <matthias.gerstner@suse.de>\tMatthias Gerstner <matthias.gerstner@suse.de>\nMehdi Abaakouk (@sileht) <sileht@sileht.net>\tMehdi ABAAKOUK <sileht@sileht.net>\nMehdi Abaakouk (@sileht) <sileht@sileht.net>\tMehdi Abaakouk <sileht@sileht.net>\nMeindert Kempe (@MeindertKempe) <mail@mkempe.com>\tMeindert Kempe <mail@mkempe.com>\nMichael Bazzinotti <mbazzinotti@gmail.com>\tMichael Bazzinotti <mbazzinotti@gmail.com>\nMichael Bazzinotti <mbazzinotti@gmail.com>\tMichael J. Bazzinotti <mbazzinotti@gmail.com>\nMichael Constantine Dimopoulos (@michaeldim02) <mk@mcdim.xyz>\tMichael Constantine Dimopoulos <31562759+MichaelDim02@users.noreply.github.com>\nMichael Constantine Dimopoulos (@michaeldim02) <mk@mcdim.xyz>\tMichael Constantine Dimopoulos <mk@mcdim.xyz>\nMichal Siedlaczek (@elshize) <michal@siedlaczek.me>\tMichal Siedlaczek <michal@siedlaczek.me>\nMingcong Bai (@MingcongBai) <jeffbai@aosc.xyz>\tMingcong Bai <jeffbai@aosc.xyz>\nMohammad AlSaleh (@MoSal) <CE.Mohammad.Alsaleh@gmail.com>\tMohammad AlSaleh <CE.Mohammad.Alsaleh@gmail.com>\nNagefire (@nagefire) <nagefire.dev@gmail.com>\tNagefire <nagefire.dev@gmail.com>\nNaveen Nathan (@nnathan) <naveen@lastninja.net>\tNaveen Nathan <naveen@lastninja.net>\nng0 <nikita@n0.is>\tng0 <ng0@infotropique.org>\nng0 <nikita@n0.is>\tng0 <ng0@n0.is>\nNicholas Steeves (@sten0) <nsteeves@gmail.com>\tNicholas D Steeves <nsteeves@gmail.com>\nNicholas Steeves (@sten0) <nsteeves@gmail.com>\tNicholas Steeves <nsteeves@gmail.com>\nNicholas Wieland (@ngw) <ngw@nofeed.org>\tNicholas Wieland <ngw@nofeed.org>\nNicolas Bock (@nicolasbock) <nicolasbock@gmail.com>\tNicolas Bock <nicolasbock@gmail.com>\nOliver Bandel (@klartext) <oliver@first.in-berlin.de>\tOliver Bandel <oliver@first.in-berlin.de>\nPablo Ovelleiro Corral (@pinpox) <pablo1@mailbox.org>\tPablo Ovelleiro Corral <pablo1@mailbox.org>\nPaul Dino Jones (@spacefreak18) <paul@spacefreak18.xyz>\tPaul Dino Jones <paul@spacefreak18.xyz>\nPaulo Matos (@pmatos) <p@ocmatos.com>\tPaulo Matos <p@ocmatos.com>\nPerry Thompson (@rypervenche) <contact@ryper.org>\tPerry Thompson <contact@ryper.org>\nPeter Hogg (@pigmonkey) <pm@pig-monkey.com>\tPeter Hogg <pm@pig-monkey.com>\nPeter Hogg (@pigmonkey) <pm@pig-monkey.com>\tPig Monkey <pm@pig-monkey.com>\nPeter Lewis (@petelewis) <pete@muddygoat.org>\tPeter Lewis <pete@muddygoat.org>\nPhil Pennock (@philpennock) <phil@pennock-tech.com>\tPhil Pennock <phil@pennock-tech.com>\nPierre Colin (@Pierre-Colin) <48397990+Pierre-Colin@users.noreply.github.com>\tPierre Colin <48397990+Pierre-Colin@users.noreply.github.com>\nPierre-Elliott Bécue (@p-eb) <becue@crans.org>\tPierre-Elliott Bécue <becue@crans.org>\nPierre-Elliott Bécue (@p-eb) <becue@crans.org>\tPierre-Elliott Bécue <P-EB@users.noreply.github.com>\nPietro Cerutti (@gahr) <gahr@gahr.ch>\tPietro Ceruti <gahr@gahr.ch>\nPietro Cerutti (@gahr) <gahr@gahr.ch>\tPietro Cerutti (@gahr) <gahr@gahr.ch>\nPietro Cerutti (@gahr) <gahr@gahr.ch>\tPietro Cerutti <gahr@gahr.ch>\nR Primus (@rprimus) <rprimus@gmail.com>\tR Primus <rprimus@gmail.com>\nr3lgar (@r3lgar) <r3lgar@openmailbox.org>\tr3lgar <r3lgar@openmailbox.org>\nr3lgar (@r3lgar) <r3lgar@openmailbox.org>\tr3lgar <r3lgar@users.noreply.github.com>\nraf (@raforg) <raf@raf.org>\traf <raf@raf.org>\nRahul Gopinath (@vrthra) <rahul@gopinath.org>\tRahul Gopinath <rahul@gopinath.org>\nRamkumar Ramachandra (@artagnon) <r@artagnon.com>\tRamkumar Ramachandra <r@artagnon.com>\nRayford Shireman (@rayfordshire) <123055883+rayfordshire@users.noreply.github.com>\tRayford Shireman <123055883+rayfordshire@users.noreply.github.com>\nRayford Shireman (@rayfordshire) <123055883+rayfordshire@users.noreply.github.com>\trayfordshire <123055883+rayfordshire@users.noreply.github.com>\nRóbert Horváth (@r001) <rob@nyar.eu>\tRóbert Horváth <rob@nyar.eu>\nRóbert Horváth (@r001) <rob@nyar.eu>\tRobert Horvath <rob@nyar.eu>\nRegid Ichira <regid23@nt1.in>\tRegid Ichira <regid23@nt1.in>\nReis Radomil <reisradomil@fake-box.com>\tReis Radomil <reisradomil@fake-box.com>\nReto Brunner (@brunnre8) <reto@slightlybroken.com>\tReto Brunner <reto@labrat.space>\nReto Brunner (@brunnre8) <reto@slightlybroken.com>\tReto Brunner <reto@slightlybroken.com>\nReto Brunner (@brunnre8) <reto@slightlybroken.com>\tReto <reto@labrat.space>\nRiad Wahby (@kwantam) <kwantam@gmail.com>\tRiad S. Wahby <kwantam@gmail.com>\nRiad Wahby (@kwantam) <kwantam@gmail.com>\tRiad Wahby <kwantam@gmail.com>\nRichard Hartmann (@richih) <RichiH@users.noreply.github.com>\tRichard Hartmann <RichiH@users.noreply.github.com>\nRichard Russon (@flatcap) <rich@flatcap.org>\tLGTM Migrator <lgtm-migrator@users.noreply.github.com>\nRichard Russon (@flatcap) <rich@flatcap.org>\tRichard Russon (DEPLOY) <rich@flatcap.org>\nRichard Russon (@flatcap) <rich@flatcap.org>\tRichard Russon <<rich@flatcap.org>>\nRichard Russon (@flatcap) <rich@flatcap.org>\tRichard Russon <rich@flatcap.org>\nRoberto Alvarado (@robdres) <robdres123@gmail.com>\tRobdres <robdres123@gmail.com>\nRoberto Alvarado (@robdres) <robdres123@gmail.com>\tRoberto Alvarado <robdres123@gmail.com>\nRoberto Alvarado (@robdres) <robdres123@gmail.com>\tRoberto Andrés <robdres@MacBook-Pro-de-Roberto.local>\nRoger Pau Monne (@royger) <roger.pau@citrix.com>\tRoger Pau Monne <roger.pau@citrix.com>\nRomeu Vieira (@romeug) <romeu.bizz@gmail.com>\tRomeu Vieira <romeu.bizz@gmail.com>\nRonan Arraes Jardim Chagas (@ronisbr) <ronisbr@gmail.com>\tRonan Arraes Jardim Chagas <ronisbr@gmail.com>\nRubén Llorente <rubenllorente@startmail.com>\tRubén Llorente <rubenllorente@startmail.com>\nRyan d'Huart (@homoelectromagneticus) <homoelectromagneticus@protonmail.com>\tRyan d'Huart <homoelectromagneticus@protonmail.com>\nRyan Kavanagh (@ryanakca) <rak@rak.ac>\tRyan Kavanagh <rak@rak.ac>\nryt (@0x747972) <0x747972@gmail.com>\tryt <0x747972@gmail.com>\nSantiago Torres (@santiagotorres) <torresariass@gmail.com>\tSantiago Torres <torresariass@gmail.com>\nScott Kostyshak (@scottkosty) <scott.kostyshak@gmail.com>\tScott Kostyshak <scott.kostyshak@gmail.com>\nSebastian Crane (@seabass-labrax) <seabass-labrax@gmx.com>\tSebastian Crane <seabass-labrax@gmx.com>\nSebastian Stark (@sstark) <sstark@mailbox.org>\tSebastian Stark <sstark@mailbox.org>\nSerge Gebhardt (@sgeb) <serge.gebhardt@gmail.com>\tSerge Gebhardt <serge.gebhardt@gmail.com>\nSergey Alirzaev (@l29ah) <zl29ah@gmail.com>\tSergey Alirzaev <zl29ah@gmail.com>\nShane Donohoe <donohoe.shane@gmail.com>\tShane Donohoe <donohoe.shane@gmail.com>\nShane Donohoe <donohoe.shane@gmail.com>\tsharktamer <sharktamer@users.noreply.github.com>\nSheoak (@sheoak) <sheoak@users.noreply.github.com>\tSheoak <sheoak@users.noreply.github.com>\nShi Lee <rtlanceroad@gmail.com>\trtlanceroad <rtlanceroad@gmail.com>\nShi Lee <rtlanceroad@gmail.com>\tShi Lee <rtlanceroad@gmail.com>\nSimon Reichel (@amudtogal) <simonreichel@giese-optik.de>\tSimon Reichel <simms1@web.de>\nSimon Reichel (@amudtogal) <simonreichel@giese-optik.de>\tSimon Reichel <simonreichel@giese-optik.de>\nSimon Symeonidis (@psyomn) <lethaljellybean@gmail.com>\tSimon Symeonidis <lethaljellybean@gmail.com>\nsomini (@somini) <dev@somini.xyz>\tsomini <dev@somini.xyz>\nsomini (@somini) <dev@somini.xyz>\tsomini <somini29@yandex.com>\nsomini (@somini) <dev@somini.xyz>\tsomini <somini@users.noreply.github.com>\nStefan Assmann (@sassmann) <sassmann@kpanic.de>\tsassmann <sassmann@users.noreply.github.com>\nStefan Assmann (@sassmann) <sassmann@kpanic.de>\tStefan Assmann <sassmann@kpanic.de>\nStefan Assmann (@sassmann) <sassmann@kpanic.de>\tStefan Assmann <sassmann@redhat.com>\nStefan Bühler (@stbuehler) <stbuehler@web.de>\tStefan Bühler <stbuehler@web.de>\nStefan Kropp (@debxwoody) <stefan@debxwoody.de>\tDebXWoody <stefan@debxwoody.de>\nStefan Kropp (@debxwoody) <stefan@debxwoody.de>\tStefan <32964719+DebXWoody@users.noreply.github.com>\nStefan Kropp (@debxwoody) <stefan@debxwoody.de>\tStefan Kropp <stefan@debxwoody.de>\nStefano Zacchiroli (@zacchiro) <zack@upsilon.cc>\tStefano Zacchiroli <zack@upsilon.cc>\nSteinar H Gunderson (@sesse) <steinar+neomutt@gunderson.no>\tSteinar H. Gunderson <sgunderson@bigfoot.com>\nSteinar H Gunderson (@sesse) <steinar+neomutt@gunderson.no>\tSteinar H Gunderson <steinar+neomutt@gunderson.no>\nSteinar H Gunderson (@sesse) <steinar+neomutt@gunderson.no>\tSteinar H. Gunderson <steinar+neomutt@gunderson.no>\nStephen Gilles <sgilles@math.umd.edu>\tS. Gilles <sgilles@math.umd.edu>\nStephen Gilles <sgilles@math.umd.edu>\tStephen Gilles <sgilles@math.umd.edu>\nSteven Ragnarök (@nuclearsandwich) <steven@nuclearsandwich.com>\tSteven Ragnarök <steven@nuclearsandwich.com>\nSteven Ragnarök (@nuclearsandwich) <steven@nuclearsandwich.com>\tSteven! Ragnarök <steven@nuclearsandwich.com>\nStig Palmquist (@stigtsp) <stig@stig.io>\tStig Palmquist <stig@stig.io>\nStéphane Lesimple (@speed47) <speed47_github@speed47.net>\tStéphane Lesimple <speed47_github@speed47.net>\nStuart Henderson (@sthen) <stu-github@spacehopper.org>\tStuart Henderson <sthen@users.noreply.github.com>\nStuart Henderson (@sthen) <stu-github@spacehopper.org>\tStuart Henderson <stu-github@spacehopper.org>\ntelshock (@telshock) <telshock@users.noreply.github.com>\ttelshock <telshock@users.noreply.github.com>\nTheo Jepsen (@theojepsen) <theojepsen@gmail.com>\tTheo Jepsen <theojepsen@gmail.com>\nTheo Jepsen (@theojepsen) <theojepsen@gmail.com>\tTheo <theojepsen@g-m-a-i-l-dotcom>\nThiago Costa de Paiva (@tecepe) <tecepe@tecepe.eng.br>\ttecepe <tecepe@tecepe.eng.br>\nThiago Costa de Paiva (@tecepe) <tecepe@tecepe.eng.br>\ttecepe <tecepe@users.noreply.github.com>\nThiago Costa de Paiva (@tecepe) <tecepe@tecepe.eng.br>\tThiago Costa de Paiva <tcpaiva@cern.ch>\nThiago Costa de Paiva (@tecepe) <tecepe@tecepe.eng.br>\tThiago Costa de Paiva <tcpaiva@users.noreply.github.com>\nThiago Costa de Paiva (@tecepe) <tecepe@tecepe.eng.br>\tThiago Costa de Paiva <tecepe@tecepe.eng.br>\nThomas Adam (@thomasadam) <thomas@xteddy.org>\tThomas Adam <thomas@xteddy.org>\nThomas Bracht Laumann Jespersen (@laumann) <t@laumann.xyz>\tThomas Bracht Laumann Jespersen <t@laumann.xyz>\nThomas Jarosch (@thomasjfox) <thomas.jarosch@intra2net.com>\tThomas Jarosch <thomas.jarosch@intra2net.com>\nThomas Klausner (@0-wiz-0) <wiz@netbsd.org>\tThomas Klausner <wiz@netbsd.org>\nThomas Sanchez (@daedric) <thomas.sanchz@gmail.com>\tThomas Sanchez <thomas.sanchz@gmail.com>\nThomas Schneider (@qsuscs) <qsx@qsx.re>\tThomas Schneider <qsx@qsx.re>\nTim Biermann (@timb87) <tbier@posteo.de>\tTim Biermann <tbier@posteo.de>\nTim Clifford (@tim-clifford) <git@clifford.lol>\tTim Clifford <git@clifford.lol>\nTimmy Xiao <timmyxiao1@gmail.com>\tTimmy Xiao <timmyxiao1@gmail.com>\nTino Reichardt (@mcmilk) <github@mcmilk.de>\tTino Reichardt <github@mcmilk.de>\nTino Reichardt (@mcmilk) <github@mcmilk.de>\tTino Reichardt <milky-neomutt@mcmilk.de>\nTobias Angele (@toogley) <toogley@mailbox.org>\tTobias Angele <toogley@mailbox.org>\nTobias Angele (@toogley) <toogley@mailbox.org>\ttoogley <9417950+toogley@users.noreply.github.com>\nTobias Angele (@toogley) <toogley@mailbox.org>\ttoogley <toogley@mailbox.org>\nTobias Stoeckmann (@stoeckmann) <tobias@stoeckmann.org>\tTobias Stoeckmann <tobias@stoeckmann.org>\nTomáš Karela Procházka (@prochac) <tomas.prochazka5d@gmail.com>\tTomáš Karela Procházka <tomas.prochazka5d@gmail.com>\ntoonn (@toonn) <toonn@toonn.io>\ttoonn <toonn@toonn.io>\nTóth János (@g0mb4) <gomba007@gmail.com>\tTóth János <gomba007@gmail.com>\nUdo Schweigert <mutt@cert.siemens.de>\tUdo Schweigert <mutt@cert.siemens.de>\nValeri Sergeev (@vpub) <valsy@mail.ru>\tValeri Sergeev <valsy@mail.ru>\nValeri Sergeev (@vpub) <valsy@mail.ru>\tValeri Y.Sergeev <valsy@mail.ru>\nVictor Fernandes (@ghikio) <criw@pm.me>\tVictor Fernandes <criw@pm.me>\nViktor Cheburkin (@vcheburkin) <victor.cheburkin@gmail.com>\tViktor Cheburkin <victor.cheburkin@gmail.com>\nVladimir Zakharov (@z2v) <zakharov.vv@gmail.com>\tVladimir Zakharov <zakharov.vv@gmail.com>\nvuori (@vuori) <vuori@notcom.org>\tvuori <vuori@notcom.org>\nWerner Fink (@bitstreamout) <werner@suse.de>\tWerner Fink <werner@suse.de>\nWhitney Cumber (@whitney-cumber) <109030400+whitney-cumber@users.noreply.github.com>\tWhitney Cumber <109030400+whitney-cumber@users.noreply.github.com>\nWhitney Cumber (@whitney-cumber) <109030400+whitney-cumber@users.noreply.github.com>\twhitney-cumber <109030400+whitney-cumber@users.noreply.github.com>\nWieland Hoffmann (@mineo) <themineo@gmail.com>\tWieland Hoffmann <mineo@users.noreply.github.com>\nWieland Hoffmann (@mineo) <themineo@gmail.com>\tWieland Hoffmann <themineo@gmail.com>\nWill Curry (@wcurry) <will@robotican.org>\tWill Curry <will@robotican.org>\nWilliam Pettersson (@wpettersson) <william.pettersson@gmail.com>\tWilliam Pettersson <william.pettersson+github@gmail.com>\nWilliam Pettersson (@wpettersson) <william.pettersson@gmail.com>\tWilliam Pettersson <william.pettersson@gmail.com>\nx3nb63 (@x3nb63) <25959223+x3nb63@users.noreply.github.com>\tx3nb63 <25959223+x3nb63@users.noreply.github.com>\nYoshiki Vázquez Baeza (@eldeveloper) <yoshiki89@gmail.com>\tYoshiki Vázquez Baeza <yoshiki89@gmail.com>\nYousef Akbar (@yousefakbar) <yousef@yhakbar.com>\tYousef Akbar <yousef@yhakbar.com>\nYubin Ruan (@walkerlala) <ablacktshirt@gmail.com>\tYubin Ruan <ablacktshirt@gmail.com>\nZak D (@zakarouf) <60977989+zakarouf@users.noreply.github.com>\tZak D <60977989+zakarouf@users.noreply.github.com>\nZero King (@l2dy) <l2dy@icloud.com>\tZero King <l2dy@icloud.com>\nzsugabubus (@zsugabubus) <zsugabubus@users.noreply.github.com>\tzsugabubus <zsugabubus@users.noreply.github.com>\n## Mutt Contributors - auto-generated: https://github.com/neomutt/authors/tree/main/git\nUPSTREAM Aaron Lehmann <aaronl@vitelus.com>\tAaron Lehmann <aaronl@vitelus.com>\nUPSTREAM Aaron Schrab <aaron@schrab.com>\tAaron Schrab <aaron+mutt@schrab.com>\nUPSTREAM Aaron Schrab <aaron@schrab.com>\tAaron Schrab <aaron@schrab.com>\nUPSTREAM Adeodato Simó <asp16@alu.ua.es>\tAdeodato Simó <asp16@alu.ua.es>\nUPSTREAM Adeodato Simó <asp16@alu.ua.es>\tAdeodato Simó <dato@net.com.org.es>\nUPSTREAM Aitor Soroa <a.soroa@gmail.com>\tAitor Soroa <a.soroa@gmail.com>\nUPSTREAM Alain Bench <veronatif@free.fr>\tAlain Bench <messtic@oreka.com>\nUPSTREAM Alain Bench <veronatif@free.fr>\tAlain Bench <veronatif@free.fr>\nUPSTREAM Alain Penders <alain@finale-dev.com>\tAlain Penders <alain@finale-dev.com>\nUPSTREAM Alexey Froloff <raorn@altlinux.org>\tAlexey Froloff <raorn@altlinux.org>\nUPSTREAM Alexey Froloff <raorn@altlinux.org>\tAlexey I. Froloff <raorn@altlinux.org>\nUPSTREAM Alexey Tourbin <at@altlinux.org>\tAlexey Tourbin <at@altlinux.org>\nUPSTREAM Ambrose Li <a.c.li@ieee.org>\tAmbrose Li <a.c.li@ieee.org>\nUPSTREAM Ammon Riley <ammon.riley@gmail.com>\tAmmon Riley <ammon.riley@gmail.com>\nUPSTREAM Anatoly Vorobey <mellon@pobox.com>\tAnatoly Vorobey <mellon@pobox.com>\nUPSTREAM Anders Helmersson <anders.helmersson.utsikt@wasadata.net>\tAnders Helmersson <anders.helmersson@telia.com>\nUPSTREAM Anders Helmersson <anders.helmersson.utsikt@wasadata.net>\tAnders Helmersson <anders.helmersson.utsikt@wasadata.net>\nUPSTREAM Andre Beck <beck@ibh.de>\tAndre Beck <beck@ibh.de>\nUPSTREAM Andre Beck <beck@ibh.de>\tBeck, Andre <beck@ibh.de>\nUPSTREAM Andreas Amann <andreas.amann@tyndall.ie>\tAndreas Amann <andreas.amann@tyndall.ie>\nUPSTREAM Andreas Amann <andreas.amann@tyndall.ie>\tUnknown <andreas.amann@tyndall.ie>\nUPSTREAM Andreas Jaggi <unknown>\tAndreas Jaggi <unknown>\nUPSTREAM Andreas Jobs <unknown>\tAndreas Jobs <unknown>\nUPSTREAM Andrew Gaul <andrew@gaul.org>\tAndrew Gaul <andrew@gaul.org>\nUPSTREAM Andrew Marks <amarks@red.ridge.amrx.net>\tAndrew Marks <amarks@red.ridge.amrx.net>\nUPSTREAM Andrew Nosenko <awn@bcs.zp.ua>\tAndrew Nosenko <awn@bcs.zp.ua>\nUPSTREAM Andrew Nosenko <awn@bcs.zp.ua>\tAndrew W. Nosenko <awn@bcs.zp.ua>\nUPSTREAM Andrey Skvortsov <andrej.skvortzov@gmail.com>\tAndrey Skvortsov <andrej.skvortzov@gmail.com>\nUPSTREAM Antoine Reilles <tonio@netbsd.org>\tAntoine Reilles <tonio@netbsd.org>\nUPSTREAM Anton Lindqvist <anton@basename.se>\tAnton Lindqvist <anton@basename.se>\nUPSTREAM Anton Lindqvist <anton@basename.se>\tAnton Lindqvist <anton.lindqvist@gmail.com>\nUPSTREAM Aram Hamo <contact@aramhamo.me>\tAram Hamo <contact@aramhamo.me>\nUPSTREAM Armin Wolfermann <aw@osn.de>\tArmin Wolfermann <aw@osn.de>\nUPSTREAM Aron Griffis <agriffis@n01se.net>\tAron Griffis <agriffis@n01se.net>\nUPSTREAM Athanasios Douitsis <aduitsis@gmail.com>\tAthanasios Douitsis <aduitsis@gmail.com>\nUPSTREAM Benno Schulenberg <i18n@benno.vertaalt.nl>\tBenno Schulenberg <i18n@benno.vertaalt.nl>\nUPSTREAM Bernd Ahlers <bernd@ba-net.org>\tBernd Ahlers <bernd@ba-net.org>\nUPSTREAM Bertram Felgenhauer <int-e@gmx.de>\tBertram Felgenhauer <int-e@gmx.de>\nUPSTREAM Bertrand Janin <tamentis@neopulsar.org>\tBertrand Janin <tamentis@neopulsar.org>\nUPSTREAM Bill Nottingham <notting@redhat.com>\tBill Nottingham <notting@redhat.com>\nUPSTREAM Bjoern Jacke <bjoern@j3e.de>\tBjoern Jacke <bjoern@j3e.de>\nUPSTREAM Bjoern Jacke <bjoern@j3e.de>\tBjoern Jacke <muttbug@j3e.de>\nUPSTREAM Brandon Long <blong@fiction.net>\tBrandon Long <blong@fiction.net>\nUPSTREAM Brendan Cully <brendan@cully.org>\tBrendan Cully <brendan@cully.org>\nUPSTREAM Brendan Cully <brendan@cully.org>\tBrendan Cully <brendan@kublai.com>\nUPSTREAM Brent Nordquist <brent@nordist.net>\tBrent J. Nordquist <brent@nordist.net>\nUPSTREAM Brent Nordquist <brent@nordist.net>\tBrent Nordquist <brent@nordist.net>\nUPSTREAM Bruno Postle <bruno@postle.net>\tBruno Postle <bruno@postle.net>\nUPSTREAM Byrial Jensen <byrial@image.dk>\tByrial Jensen <byrial@image.dk>\nUPSTREAM Cameron Patrick <cameron@patrick.wattle.id.au>\tCameron Patrick <cameron@patrick.wattle.id.au>\nUPSTREAM Cameron Simpson <cs@cskk.id.au>\tCameron Simpson <cs@cskk.id.au>\nUPSTREAM Cedric Duval <cedricduval@free.fr>\tCedric Duval <cedricduval@free.fr>\nUPSTREAM Cedric Duval <cedricduval@free.fr>\tCedric Duval <cedricduval+web@free.fr>\nUPSTREAM Christian Aichinger <greek0@gmx.net>\tChristian Aichinger <greek0@gmx.net>\nUPSTREAM Christian Ebert <blacktrash@gmx.net>\tChristian Ebert <blacktrash@gmx.net>\nUPSTREAM Christian Vogel <vogelchr@vogel.cx>\tChristian Vogel <vogelchr@vogel.cx>\nUPSTREAM Christoph Ludwig <cludwig@cdc.informatik.tu-darmstadt.de>\tChristoph Ludwig <cludwig@cdc.informatik.tu-darmstadt.de>\nUPSTREAM Consus <consus@gmx.com>\tConsus <consus@gmx.com>\nUPSTREAM convert-repo <unknown>\tconvert-repo <unknown>\nUPSTREAM Corey Minyard <cminyard@mvista.com>\tCorey Minyard <cminyard@mvista.com>\nUPSTREAM Craig Gallek <cgallek@gmail.com>\tCraig Gallek <cgallek@gmail.com>\nUPSTREAM Cyril Roelandt <tipecaml@gmail.com>\tCyril Roelandt <tipecaml@gmail.com>\nUPSTREAM Dale Woolridge <dale-list-mutt-dev-2@woolridge.org>\tDale Woolridge <dale-flea-mutt-bug@woolridge.org>\nUPSTREAM Dale Woolridge <dale-list-mutt-dev-2@woolridge.org>\tDale Woolridge <dale-list-mutt-dev-2@woolridge.org>\nUPSTREAM Dan Born <dan@danborn.net>\tDan Born <dan@danborn.net>\nUPSTREAM Dan Fandrich <dan@coneharvesters.com>\tDan Fandrich <dan@coneharvesters.com>\nUPSTREAM Dan Hopper <ku4nf@austin.rr.com>\tDan Hopper <ku4nf@austin.rr.com>\nUPSTREAM Dan Loewenherz <daniel.loewenherz@yale.edu>\tDan Loewenherz <daniel.loewenherz@yale.edu>\nUPSTREAM Dan Nelson <dnelson@allantgroup.com>\tDan Nelson <dnelson@allantgroup.com>\nUPSTREAM Dan Ohnesorg <dan@ohnesorg.cz>\tDan Ohnesorg <dan@ohnesorg.cz>\nUPSTREAM Daniel Burrows <dburrows@debian.org>\tDaniel Burrows <dburrows@debian.org>\nUPSTREAM Daniel Jacobowitz <dan@debian.org>\tDaniel Jacobowitz <dan@debian.org>\nUPSTREAM Daniel Kahn Gillmor <dkg@fifthhorseman.net>\tDaniel Kahn Gillmor <dkg@fifthhorseman.net>\nUPSTREAM Daniel Schmitz <dr1s@users.noreply.github.com>\tDaniel Schmitz <dr1s@users.noreply.github.com>\nUPSTREAM Daniel Tameling <tamelingdaniel@gmail.com>\tDaniel Tameling <tamelingdaniel@gmail.com>\nUPSTREAM David Champion <dgc@c13.us>\tDavid Champion <dgc@bikeshed.us>\nUPSTREAM David Champion <dgc@c13.us>\tDavid Champion <dgc@c13.us>\nUPSTREAM David Champion <dgc@c13.us>\tDavid Champion <dgc.github@c13.us>\nUPSTREAM David Champion <dgc@c13.us>\tDavid Champion <dgc@uchicago.edu>\nUPSTREAM David Jardine <david@jardine.de>\tDavid Jardine <david@jardine.de>\nUPSTREAM David Shaw <dshaw@jabberwocky.com>\tDavid Shaw <dshaw@jabberwocky.com>\nUPSTREAM David Wilson <dw@botanicus.net>\tDavid Wilson <dw@botanicus.net>\nUPSTREAM David Yitzchak Cohen <lists+mutt_devs@bigfatdave.com>\tDavid Yitzchak Cohen <lists+mutt_bugs@bigfatdave.com>\nUPSTREAM David Yitzchak Cohen <lists+mutt_devs@bigfatdave.com>\tDavid Yitzchak Cohen <lists+mutt_devs@bigfatdave.com>\nUPSTREAM Derek Martin <code@pizzashack.org>\tDerek Martin <code@pizzashack.org>\nUPSTREAM Derek Martin <code@pizzashack.org>\tDerek Martin <invalid@pizzashack.org>\nUPSTREAM Derek Schrock <dereks@lifeofadishwasher.com>\tDerek Schrock <dereks@lifeofadishwasher.com>\nUPSTREAM Dmitri Vereshchagin <dmitri.vereshchagin@gmail.com>\tDmitri Vereshchagin <dmitri.vereshchagin@gmail.com>\nUPSTREAM Ed Neville <ed@s5h.net>\tEd Neville <ed@s5h.net>\nUPSTREAM Ed Neville <ed@s5h.net>\ted@s5h.net <ed@s5h.net>\nUPSTREAM Edmund Grimley Evans <edmundo@rano.org>\tEdmund GRIMLEY EVANS <edmund820@rano.org>\nUPSTREAM Edmund Grimley Evans <edmundo@rano.org>\tEdmund GRIMLEY EVANS <edmundo@rano.org>\nUPSTREAM Edmund Grimley Evans <edmundo@rano.org>\tEdmund Grimley Evans <edmundo@rano.org>\nUPSTREAM Eike Rathke <erack@erack.de>\tEike Rathke <erack@erack.de>\nUPSTREAM Elmar Hoffmann <mutt-dev-ml@elho.net>\tElmar Hoffmann <mutt-dev-ml@elho.net>\nUPSTREAM Emanuele Giaquinta <e.giaquinta@glauco.it>\tEmanuele Giaquinta <e.giaquinta@glauco.it>\nUPSTREAM Emanuele Giaquinta <e.giaquinta@glauco.it>\tEmanuele Giaquinta <unknown>\nUPSTREAM Eric Raymond <esr@thyrsus.com>\tEric Raymond <esr@thyrsus.com>\nUPSTREAM Eric Raymond <esr@thyrsus.com>\tUnknown <esr@thyrsus.com>\nUPSTREAM Erik Hovland <erik@hovland.org>\tErik Hovland <erik@hovland.org>\nUPSTREAM Fahri Cihan Demirci <fcdemirci@fastmail.fm>\tFahri Cihan Demirci <fcdemirci@fastmail.fm>\nUPSTREAM Flammie Pirinen <flammie@iki.fi>\tFlammie Pirinen <flammie@iki.fi>\nUPSTREAM Florian Weimer <fw@deneb.enyo.de>\tFlorian Weimer <fw@deneb.enyo.de>\nUPSTREAM Gary Johnson <garyjohn@spk.agilent.com>\tGary Johnson <garyjohn@spk.agilent.com>\nUPSTREAM Gary Johnson <garyjohn@spk.agilent.com>\tGary Johnson <unknown>\nUPSTREAM Gero Treuner <gerotick@faveve.uni-stuttgart.de>\tGero Treuner <gero@70t.de>\nUPSTREAM Gero Treuner <gerotick@faveve.uni-stuttgart.de>\tGero Treuner <gerotick@faveve.uni-stuttgart.de>\nUPSTREAM Gero Treuner <gerotick@faveve.uni-stuttgart.de>\tgt_16_gitlab.com@innocircle.com <gt_16_gitlab.com@innocircle.com>\nUPSTREAM Gregory Shapiro <dev.mutt.org@g.gshapiro.net>\tGregory Shapiro <dev.mutt.org@g.gshapiro.net>\nUPSTREAM Grzegorz Szymaszek <gszymaszek@short.pl>\tGrzegorz Szymaszek <gszymaszek@short.pl>\nUPSTREAM Guilhem Moulin <guilhem@guilhem.org>\tGuilhem Moulin <guilhem@guilhem.org>\nUPSTREAM guns <self@sungpae.com>\tguns <self@sungpae.com>\nUPSTREAM Holger Weiss <lists@jhweiss.de>\tHolger Weiss <holger@zedat.fu-berlin.de>\nUPSTREAM Holger Weiss <lists@jhweiss.de>\tHolger Weiss <lists@jhweiss.de>\nUPSTREAM Honza Horak <hhorak@redhat.com>\tHonza Horak <hhorak@redhat.com>\nUPSTREAM Honza Horak <hhorak@redhat.com>\tUnknown <hhorak@redhat.com>\nUPSTREAM Horst Schirmeier <horst@schirmeier.com>\tHorst Schirmeier <horst@schirmeier.com>\nUPSTREAM Horvath Szabolcs <horvaths@fi.inf.elte.hu>\tHorvath Szabolcs <horvaths@fi.inf.elte.hu>\nUPSTREAM Hugo Haas <hugo@larve.net>\tHugo Haas <hugo@larve.net>\nUPSTREAM Im Eunjea <eunjea@koru.org>\tIm Eunjea <eunjea@koru.org>\nUPSTREAM Ivan Vilata i Balaguer <ivan@selidor.net>\tIvan Vilata i Balaguer <ivan@selidor.net>\nUPSTREAM James McCoy <jamessan@jamessan.com>\tJames McCoy <jamessan@jamessan.com>\nUPSTREAM Jeff Ito <jeffi@rcn.com>\tJeff Ito <jeffi@rcn.com>\nUPSTREAM Jeremy Sowden <jeremy@azazel.net>\tJeremy Sowden <jeremy@azazel.net>\nUPSTREAM Jesus Climent <jesus.climent@hispalinux.es>\tJesus Climent <jesus.climent@hispalinux.es>\nUPSTREAM Jesus Climent <jesus.climent@hispalinux.es>\tUnknown <jesus.climent@hispalinux.es>\nUPSTREAM Jim Mock <mij@soupnazi.org>\tJim Mock <mij@soupnazi.org>\nUPSTREAM Joel Dahl <joel@freebsd.org>\tJoel Dahl <joel@freebsd.org>\nUPSTREAM Johan D <djo33@free.fr>\tJohan D <djo33@free.fr>\nUPSTREAM Johan Svedberg <johan@svedberg.com>\tJohan Svedberg <johan@svedberg.com>\nUPSTREAM Johan Svedberg <johan@svedberg.com>\tJohan Svedberg <johan@svedberg.pp.se>\nUPSTREAM John Beck <john.beck@oracle.com>\tJohn Beck <john.beck@oracle.com>\nUPSTREAM John Beck <john.beck@oracle.com>\tUnknown <john.beck@oracle.com>\nUPSTREAM John Hawkinson <jhawk@mit.edu>\tJohn Hawkinson <jhawk@mit.edu>\nUPSTREAM John Swinbank <john@swinbank.org>\tJohn Swinbank <john@swinbank.org>\nUPSTREAM Joël Riou <joel.riou@normalesup.org>\tJoël Riou <joel.riou@normalesup.org>\nUPSTREAM Jon Miles <jon@zetnet.net>\tJon Miles <jon@zetnet.net>\nUPSTREAM Jonathan Wakely <bugs@kayari.org>\tJonathan Wakely <bugs@kayari.org>\nUPSTREAM Jörgen Tegnér <jorgen.tegner@telia.com>\tJörgen Tegnér <jorgen.tegner@telia.com>\nUPSTREAM Juan Altmayer Pizzorno <juan@altmayer.com>\tJuan Altmayer Pizzorno <juan@altmayer.com>\nUPSTREAM Jukka Salmi <jukka@salmi.ch>\tJukka Salmi <j+mutt@2007.salmi.ch>\nUPSTREAM Jukka Salmi <jukka@salmi.ch>\tJukka Salmi <jukka@salmi.ch>\nUPSTREAM Julian Gilbey <julian-git@d-and-j.net>\tJulian Gilbey <julian-git@d-and-j.net>\nUPSTREAM Julien Cristau <unknown>\tJulien Cristau <unknown>\nUPSTREAM Julius Plenz <plenz@cis.fu-berlin.de>\tJulius Plenz <plenz@cis.fu-berlin.de>\nUPSTREAM Karel Balej <balejk@matfyz.cz>\tKarel Balej <balejk@matfyz.cz>\nUPSTREAM Kees Cook <kees@outflux.net>\tKees Cook <kees@outflux.net>\nUPSTREAM Kees Cook <kees@outflux.net>\tUnknown <kees@outflux.net>\nUPSTREAM Kevin McCarthy <kevin@8t8.us>\tKevin McCarthy <kevin@8t8.us>\nUPSTREAM Kevin Scannell <kscanne@gmail.com>\tKevin Scannell <kscanne@gmail.com>\nUPSTREAM Kevin Scannell <kscanne@gmail.com>\tKevin Scannell <scannell@slu.edu>\nUPSTREAM Kimihiro Nonaka <nonakap@gmail.com>\tKimihiro Nonaka <nonakap@gmail.com>\nUPSTREAM Kimihiro Nonaka <nonakap@gmail.com>\tNONAKA Kimihiro <nonakap@gmail.com>\nUPSTREAM Konstantin Stephan <pigleich3@gmx.net>\tKonstantin Stephan <pigleich3@gmx.net>\nUPSTREAM Kyle Wheeler <kyle@memoryhole.net>\tKyle Wheeler <kyle@memoryhole.net>\nUPSTREAM Kyle Wheeler <kyle@memoryhole.net>\tKyle Wheeler <kyle-mutt-dev@memoryhole.net>\nUPSTREAM Kyle Wheeler <kyle@memoryhole.net>\tKyle Wheeler <unknown>\nUPSTREAM Lars Hecking <lhecking@nmrc.ucc.ie>\tLars Hecking <lhecking@nmrc.ie>\nUPSTREAM Lars Hecking <lhecking@nmrc.ucc.ie>\tLars Hecking <lhecking@nmrc.ucc.ie>\nUPSTREAM Lars Hecking <lhecking@nmrc.ucc.ie>\tLars Hecking <lhecking@users.sourceforge.net>\nUPSTREAM lilydjwg <lilydjwg@gmail.com>\tlilydjwg <lilydjwg@gmail.com>\nUPSTREAM Luke Mewburn <luke@mewburn.net>\tLuke Mewburn <luke@mewburn.net>\nUPSTREAM Mads Martin Joergensen <mmj@suse.de>\tMads Martin Joergensen <mmj@suse.de>\nUPSTREAM Malcolm Parsons <malcolm.parsons@gmail.com>\tMalcolm Parsons <malcolm.parsons@gmail.com>\nUPSTREAM Mantas Mikulėnas <grawity@gmail.com>\tMantas Mikulėnas <grawity@gmail.com>\nUPSTREAM Marcel Telka <marcel@telka.sk>\tMarcel Telka <marcel@telka.sk>\nUPSTREAM Marcel Telka <marcel@telka.sk>\tUnknown <marcel@telka.sk>\nUPSTREAM Marco d'Itri <md@linux.it>\tMarco d'Itri <md@linux.it>\nUPSTREAM Marco Paolone <marcopaolone@gmail.com>\tMarco Paolone <marcopaolone@gmail.com>\nUPSTREAM Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>\tMarek Marczykowski-Górecki <marmarek@invisiblethingslab.com>\nUPSTREAM Martin F Kraft <madduck@madduck.net>\tMartin F Kraft <madduck@madduck.net>\nUPSTREAM Martin Michlmayr <tbm@cyrius.com>\tMartin Michlmayr <tbm@cyrius.com>\nUPSTREAM Martin Sandsmark <martin@sandsmark.ninja>\tMartin Sandsmark <martin@sandsmark.ninja>\nUPSTREAM Martin Siegert <siegert@sfu.ca>\tMartin Siegert <siegert@sfu.ca>\nUPSTREAM Masayuki Moriyama <unknown>\tMasayuki Moriyama <unknown>\nUPSTREAM Matt Kraai <kraai@ftbfs.org>\tMatt Kraai <kraai@ftbfs.org>\nUPSTREAM Matthias Andree <matthias.andree@gmx.de>\tMatthias Andree <matthias.andree@gmx.de>\nUPSTREAM Michał Kępień <mutt@kempniu.pl>\tMichał Kępień <mutt@kempniu.pl>\nUPSTREAM Michael Elkins <me@mutt.org>\tMichael Elkins <me@mutt.org>\nUPSTREAM Michael Elkins <me@mutt.org>\tMichael Elkins <me@sigpipe.org>\nUPSTREAM Michael Elkins <me@mutt.org>\tUnknown <me@sigpipe.org>\nUPSTREAM Michael Tatge <michael.tatge@web.de>\tMichael Tatge <michael.tatge@web.de>\nUPSTREAM Michael Vrable <mvrable@cs.ucsd.edu>\tMichael Vrable <mvrable@cs.ucsd.edu>\nUPSTREAM Mike Frysinger <vapier@gentoo.org>\tMike Frysinger <vapier@gentoo.org>\nUPSTREAM Mike Hallock <mhallock@scs.uiuc.edu>\tMike Hallock <mhallock@scs.uiuc.edu>\nUPSTREAM Mike Schiraldi <1074468571@schiraldi.org>\tMike Schiraldi <1074468571@schiraldi.org>\nUPSTREAM Miroslav Lichvar <mlichvar@redhat.com>\tMiroslav Lichvar <mlichvar@redhat.com>\nUPSTREAM Moritz Schulte <moritz@g10code.com>\tMoritz Schulte <moritz@g10code.com>\nUPSTREAM Moritz Schulte <moritz@g10code.com>\tMoritz Schulte <Moritz.Schulte@ruhr-uni-bochum.de>\nUPSTREAM Moritz Schulte <moritz@g10code.com>\tUnknown <Moritz.Schulte@ruhr-uni-bochum.de>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <listmail@mbjnet.dk>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <mbj@mbjnet.dk>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <mbj@spamcop.net>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <mjb@spamcop.net>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <mojo@mbjnet.dk>\nUPSTREAM Morten Bo Johansen <mbj@spamcop.net>\tMorten Bo Johansen <morten.bo.johansen@gmail.com>\nUPSTREAM Muh Muhten <muh.muhten@gmail.com>\tMuh Muhten <muh.muhten@gmail.com>\nUPSTREAM N J  Mann <njm@njm.f2s.com>\tN J  Mann <njm@njm.f2s.com>\nUPSTREAM N J  Mann <njm@njm.f2s.com>\tN.J. Mann <njm@njm.f2s.com>\nUPSTREAM Nathan Dushman <nhd+mutt@andrew.cmu.edu>\tNathan Dushman <nhd+mutt@andrew.cmu.edu>\nUPSTREAM Neil Brown <neilb@cse.unsw.edu.au>\tNeil Brown <neilb@cse.unsw.edu.au>\nUPSTREAM Nicolas Rachinsky <nr@rachinsky.de>\tNicolas Rachinsky <nicolas@dauerreden.de>\nUPSTREAM Nicolas Rachinsky <nr@rachinsky.de>\tNicolas Rachinsky <nr@rachinsky.de>\nUPSTREAM Nik Melchior <nam1@cec.wustl.edu>\tNik A. Melchior <nam1@cec.wustl.edu>\nUPSTREAM Nik Melchior <nam1@cec.wustl.edu>\tNik Melchior <nam1@cec.wustl.edu>\nUPSTREAM Nikolaos Kakouros <nkak@kth.se>\tNikolaos Kakouros <nkak@kth.se>\nUPSTREAM Norman Wood <normw013@fastmail.fm>\tNorman Wood <normw013@fastmail.fm>\nUPSTREAM Olaf Hering <olaf@aepfle.de>\tOlaf Hering <olaf@aepfle.de>\nUPSTREAM Ondřej Bílka <neleai@seznam.cz>\tOndřej Bílka <neleai@seznam.cz>\nUPSTREAM Oneric <Nyff@protonmail.ch>\tOneric <Nyff@protonmail.ch>\nUPSTREAM Oota Toshiya <oota@mspd.mt.nec.co.jp>\tOota Toshiya <oota@mspd.mt.nec.co.jp>\nUPSTREAM Oota Toshiya <oota@mspd.mt.nec.co.jp>\toota toshiya <oota@mspd.mt.nec.co.jp>\nUPSTREAM Oswald Buddenhagen <ossi@kde.org>\tOswald Buddenhagen <ossi@kde.org>\nUPSTREAM Patrick Welche <prlw1@cam.ac.uk>\tPatrick Welche <prlw1@cam.ac.uk>\nUPSTREAM Patrick Welche <prlw1@cam.ac.uk>\tPatrick Welche <prlw1@newn.cam.ac.uk>\nUPSTREAM Paul Eggert <eggert@cs.ucla.edu>\tPaul Eggert <eggert@cs.ucla.edu>\nUPSTREAM Paul Walker <paul@black-sun.demon.co.uk>\tPaul Walker <paul@black-sun.demon.co.uk>\nUPSTREAM Paul Walker <paul@black-sun.demon.co.uk>\tPaul WALKER <paul.walker@st.com>\nUPSTREAM Pawel Dziekonski <dzieko@pwr.wroc.pl>\tPawel Dziekonski <dzieko@pwr.wroc.pl>\nUPSTREAM Pawel Dziekonski <dzieko@pwr.wroc.pl>\tPawel Dziekonski <pawel.dziekonski@pwr.wroc.pl>\nUPSTREAM Peter Collingbourne <peter@pcc.me.uk>\tPeter Collingbourne <peter@pcc.me.uk>\nUPSTREAM Peter Rosin <peda@lysator.liu.se>\tPeter Rosin <peda@lysator.liu.se>\nUPSTREAM Peter Wu <peter@lekensteyn.nl>\tPeter Wu <peter@lekensteyn.nl>\nUPSTREAM Petr Písař <petr.pisar@atlas.cz>\tPetr Pisar <petr.pisar@atlas.cz>\nUPSTREAM Petr Písař <petr.pisar@atlas.cz>\tPetr Písař <petr.pisar@atlas.cz>\nUPSTREAM Petr Písař <petr.pisar@atlas.cz>\tPetr P√≠sa≈ô <petr.pisar@atlas.cz>\nUPSTREAM Phil Pennock <mutt-dev@spodhuis.demon.nl>\tPhil Pennock <mutt-dev@spodhuis.demon.nl>\nUPSTREAM Philipp Gesang <philipp.gesang@intra2net.com>\tPhilipp Gesang <philipp.gesang@intra2net.com>\nUPSTREAM Piarres Beobide Egaña <pi@beobide.net>\tpi <pi@beobide.net>\nUPSTREAM Piarres Beobide Egaña <pi@beobide.net>\tPiarres Beobide Egaña <pi@beobide.net>\nUPSTREAM Pieter-Tjerk de Boer <p.t.deboer@utwente.nl>\tPieter-Tjerk de Boer <p.t.deboer@utwente.nl>\nUPSTREAM Rado Smiljanic <regrado@web.de>\tRado S <regrado@web.de>\nUPSTREAM Rado Smiljanic <regrado@web.de>\tRado Smiljanic <regrado@web.de>\nUPSTREAM Ralf Wildenhues <wildenhues@ins.uni-bonn.de>\tRalf Wildenhues <wildenhues@ins.uni-bonn.de>\nUPSTREAM Recai Oktas <roktas@omu.edu.tr>\tRecai Oktas <roktas@omu.edu.tr>\nUPSTREAM Remco Rijnders <remco@webconquest.com>\tRemco Rijnders <remco@webconquest.com>\nUPSTREAM Remco Rijnders <remco@webconquest.com>\tRemco Rĳnders <remco@webconquest.com>\nUPSTREAM René Clerc <rene@clerc.nl>\tRené Clerc <rene@clerc.nl>\nUPSTREAM René Clerc <rene@clerc.nl>\tRen√© Clerc <rene@clerc.nl>\nUPSTREAM Rich Burridge <rich.burridge@oracle.com>\tRich Burridge <rich.burridge@oracle.com>\nUPSTREAM Rich Burridge <rich.burridge@oracle.com>\tUnknown <rich.burridge@oracle.com>\nUPSTREAM Robert Bartel <r.bartel@gmx.net>\tRobert Bartel <r.bartel@gmx.net>\nUPSTREAM Robert Schiele <robert.schiele@t-online.de>\tRobert Schiele <robert.schiele@t-online.de>\nUPSTREAM Rocco Rutte <pdmef@gmx.net>\tRocco Rutte <pdmef@gmx.net>\nUPSTREAM Rocco Rutte <pdmef@gmx.net>\tRocco Rutte <s1118644@mail.inf.tu-dresden.de>\nUPSTREAM Roger Cornelius <rac@tenzing.org>\tRoger Cornelius <rac@tenzing.org>\nUPSTREAM Roland Rosenfeld <roland@spinnaker.de>\tRoland Rosenfeld <roland@spinnaker.de>\nUPSTREAM Roman Kagan <rkagan@mail.ru>\tRoman Kagan <rkagan@mail.ru>\nUPSTREAM Roman Kraevskiy <rkraevskiy@gmail.com>\tRoman Kraevskiy <rkraevskiy@gmail.com>\nUPSTREAM Ronny Haryanto <ronny@haryan.to>\tRonny Haryanto <ronny@haryan.to>\nUPSTREAM Ronny Haryanto <ronny@haryan.to>\tRonny Haryanto <ronnylist@haryan.to>\nUPSTREAM Rosen Penev <rosenp@gmail.com>\tRosen Penev <rosenp@gmail.com>\nUPSTREAM Rudi Chiarito <nutello@sweetness.com>\tRudi Chiarito <nutello@sweetness.com>\nUPSTREAM Rudy Taraschi <rudy@cae.com>\tRudy Taraschi <rudy@cae.com>\nUPSTREAM Rupert Levene <rupert@levene.dyndns.org>\tRupert Levene <rupert@levene.dyndns.org>\nUPSTREAM Sahil Tandon <sahil@brandeis.edu>\tSahil Tandon <sahil@brandeis.edu>\nUPSTREAM Sam Pablo Kuper <sampablokuper@riseup.net>\tSam Pablo Kuper <sampablokuper@riseup.net>\nUPSTREAM Sami Farin <hvtaifwkbgefbaei@gmail.com>\tSami Farin <hvtaifwkbgefbaei@gmail.com>\nUPSTREAM Sami Farin <hvtaifwkbgefbaei@gmail.com>\tSami Farin <safari-mutt@safari.iki.fi>\nUPSTREAM Samuel Tardieu <sam@rfc1149.net>\tSamuel Tardieu <sam@rfc1149.net>\nUPSTREAM Sébastien Hinderer <Sebastien.Hinderer@libertysurf.fr>\tSébastien Hinderer <Sebastien.Hinderer@ens-lyon.org>\nUPSTREAM Sébastien Hinderer <Sebastien.Hinderer@libertysurf.fr>\tSébastien Hinderer <Sebastien.Hinderer@libertysurf.fr>\nUPSTREAM Scott Koranda <skoranda@gravity.phys.uwm.edu>\tScott Koranda <skoranda@gravity.phys.uwm.edu>\nUPSTREAM Sertaç Ö Yıldız <unknown>\tSertaç Ö Yıldız <unknown>\nUPSTREAM Sertaç Ö Yıldız <unknown>\tSertaç Ö. Yıldız <unknown>\nUPSTREAM Seth Arnold <seth.arnold@suse.de>\tSeth Arnold <seth.arnold@suse.de>\nUPSTREAM Seth Forshee <seth@forshee.me>\tSeth Forshee <seth@forshee.me>\nUPSTREAM Simon Ruderich <simon@ruderich.org>\tSimon Ruderich <simon@ruderich.org>\nUPSTREAM Stefan Kuhn <wuodan@hispeed.ch>\tStefan Kuhn <wuodan@hispeed.ch>\nUPSTREAM Stefan Strogin <stefan.strogin@gmail.com>\tStefan Strogin <stefan.strogin@gmail.com>\nUPSTREAM Steve Kemp <skx@debian.org>\tSteve Kemp <skx@debian.org>\nUPSTREAM Steve Kennedy <steve-md@gbnet.net>\tSteve Kennedy <steve-md@gbnet.net>\nUPSTREAM Takashi Takizawa <taki@luna.email.ne.jp>\tTakashi TAKIZAWA <taki@cyber.email.ne.jp>\nUPSTREAM Takashi Takizawa <taki@luna.email.ne.jp>\tTakashi Takizawa <taki@luna.email.ne.jp>\nUPSTREAM Takashi Takizawa <taki@luna.email.ne.jp>\tTAKIZAWA Takashi <taki@luna.email.ne.jp>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTAKAHASHI Tamotsu <arms405@jade.dti.ne.jp>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTAKAHASHI Tamotsu <tamo@momonga-linux.org>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTAKAHASHI Tamotsu <ttakah@lapis.plala.or.jp>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTakahashi Tamotsu <ttakah@lapis.plala.or.jp>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTamotsu TAKAHASHI <ttakah@gmail.com>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTamotsu TAKAHASHI <ttakah@lapis.plala.or.jp>\nUPSTREAM Tamotsu Takahashi <ttakah@lapis.plala.or.jp>\tTamotsu Takahashi <ttakah@lapis.plala.or.jp>\nUPSTREAM ta_panta_rei <7vvtch802@sneakemail.com>\tta_panta_rei <7vvtch802@sneakemail.com>\nUPSTREAM Thomas Glanzmann <sithglan@stud.uni-erlangen.de>\tThomas Glanzmann <sithglan@stud.uni-erlangen.de>\nUPSTREAM Thomas Roessler <roessler@does-not-exist.org>\tThomas Roessler <roessler@does-not-exist.org>\nUPSTREAM Thomas Wiegner <wiegner@gmx.de>\tThomas Wiegner <wiegner@gmx.de>\nUPSTREAM Tim Stoakes <tim@stoakes.net>\tTim Stoakes <tim@stoakes.net>\nUPSTREAM Todd Zullinger <tmz@pobox.com>\tTodd Zullinger <tmz@pobox.com>\nUPSTREAM Tomas Hoger <thoger@redhat.com>\tTomas Hoger <thoger@redhat.com>\nUPSTREAM Tommi Komulainen <tommi.komulainen@iki.fi>\tTommi Komulainen <tommi.komulainen@iki.fi>\nUPSTREAM Tomokazu Yonetani <qhwt+mutt@les.ath.cx>\tTomokazu Yonetani <qhwt+mutt@les.ath.cx>\nUPSTREAM Tomokazu Yonetani <qhwt+mutt@les.ath.cx>\tYONETANI Tomokazu <qhwt+mutt@les.ath.cx>\nUPSTREAM Tony Leneis <tony@cvr.ds.adp.com>\tTony Leneis <tony@cvr.ds.adp.com>\nUPSTREAM Toomas Soome <Toomas.Soome@microlink.ee>\tToomas Soome <Toomas.Soome@microlink.ee>\nUPSTREAM Toomas Soome <Toomas.Soome@microlink.ee>\tToomas Soome <tsoome@muhv.pri.ee>\nUPSTREAM Unknown <bat.guano@don.blech.e4ward.com>\tUnknown <bat.guano@don.blech.e4ward.com>\nUPSTREAM Unknown <ckillian@cs.ucsd.edu>\tUnknown <ckillian@cs.ucsd.edu>\nUPSTREAM Unknown <cypher@conuropsis.org>\tUnknown <cypher@conuropsis.org>\nUPSTREAM Unknown <duvall@emufarm.org>\tUnknown <duvall@emufarm.org>\nUPSTREAM Unknown <exg@gentoo.org>\tUnknown <exg@gentoo.org>\nUPSTREAM Unknown <g1pi@libero.it>\tUnknown <g1pi@libero.it>\nUPSTREAM Unknown <is@netbsd.org>\tUnknown <is@netbsd.org>\nUPSTREAM Unknown <ludwig@fh-worms.de>\tUnknown <ludwig@fh-worms.de>\nUPSTREAM Unknown <nihilhill@gmail.com>\tUnknown <nihilhill@gmail.com>\nUPSTREAM Unknown <peb@mppmu.mpg.de>\tUnknown <peb@mppmu.mpg.de>\nUPSTREAM Unknown <ph04169@cc.uoi.gr>\tUnknown <ph04169@cc.uoi.gr>\nUPSTREAM Unknown <pywatson@gmail.com>\tUnknown <pywatson@gmail.com>\nUPSTREAM Unknown <rea-mutt@codelabs.ru>\tUnknown <rea-mutt@codelabs.ru>\nUPSTREAM Unknown <rtc@gmx.de>\tUnknown <rtc@gmx.de>\nUPSTREAM Unknown <Zardoz@users.sourceforge.net>\tUnknown <Zardoz@users.sourceforge.net>\nUPSTREAM Urs Janßen <urs@tin.org>\tUrs Janßen <urs@tin.org>\nUPSTREAM Velko Hristov <hristov@informatik.hu-berlin.de>\tVelko Hristov <hristov@informatik.hu-berlin.de>\nUPSTREAM Vincent Lefevre <vincent@vinc17.org>\tVincent Lefevre <vincent@vinc17.net>\nUPSTREAM Vincent Lefevre <vincent@vinc17.org>\tVincent Lefevre <vincent@vinc17.org>\nUPSTREAM Vladimir Marek <vladimir.marek@sun.com>\tVladimir Marek <vladimir.marek@sun.com>\nUPSTREAM Vsevolod Volkov <vvv@mutt.org.ua>\tVsevolod Volkov <vvv@mutt.org.ua>\nUPSTREAM Werner Koch <wk@gnupg.org>\tWerner Koch <wk@gnupg.org>\nUPSTREAM Wilfried Goesgens <dothebart@uncensored.citadel.org>\tWilfried Goesgens <dothebart@uncensored.citadel.org>\nUPSTREAM Will Fiveash <will.fiveash@oracle.com>\tWill Fiveash <will.fiveash@oracle.com>\nUPSTREAM Will Fiveash <will.fiveash@oracle.com>\tWill Fiveash <Will.Fiveash@Sun.COM>\nUPSTREAM Will Fiveash <will.fiveash@oracle.com>\tWill Fiveash <william.fiveash@sun.com>\nUPSTREAM Wouter Verheijen <wv@xs2mail.com>\tWouter Verheijen <wv@xs2mail.com>\nUPSTREAM xEgoist <101279047+xEgoist@users.noreply.github.com>\txEgoist <101279047+xEgoist@users.noreply.github.com>\nUPSTREAM Yasuhiro Matsumoto <mattn_jp@hotmail.com>\tYasuhiro Matsumoto <mattn_jp@hotmail.com>\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 16.5986328125,
          "content": "## Contributors\n\nHere's a list of everyone who's helped NeoMutt:\n\n[Adam Borowski](https://github.com/kilobyte \"kilobyte\"),\n[Adam Dinwoodie](https://github.com/me-and \"me-and\"),\n[Adam Korcz](https://github.com/adamkorcz \"adamkorcz\"),\n[Aditya De Saha](https://github.com/adityadesaha \"adityadesaha\"),\n[Adán Somoza](https://github.com/darkadin \"darkadin\"),\n[Ahmed El Gabri](https://github.com/ahmedelgabri \"ahmedelgabri\"),\n[Alad Wenter](https://github.com/aladw \"aladw\"),\n[Albert Kim](https://github.com/alkim0 \"alkim0\"),\n[Alejandro Colomar](https://github.com/alejandro-colomar \"alejandro-colomar\"),\n[Aleksa Sarai](https://github.com/cyphar \"cyphar\"),\n[Alexander Kuleshov](https://github.com/onlyshk \"onlyshk\"),\n[Alexandre Simon](https://github.com/igit \"igit\"),\n[Alexey Vishnyakov](https://github.com/sweetvishnya \"sweetvishnya\"),\n[Alex Pearce](https://github.com/alexpearce \"alexpearce\"),\n[Allan Nordhøy](https://github.com/comradekingu \"comradekingu\"),\n[Alok Singh](https://github.com/alok \"alok\"),\n[Alvaro Herrera](https://github.com/alvherre \"alvherre\"),\n[Alyssa Ross](https://github.com/alyssais \"alyssais\"),\n[Ander Punnar](https://github.com/4nd3r \"4nd3r\"),\n[André Berger](https://github.com/hvkls \"hvkls\"),\n[Andreas Rammhold](https://github.com/andir \"andir\"),\n[Andres Freund](https://github.com/anarazel \"anarazel\"),\n[Andrij Mizyk](https://github.com/andmzk \"andmzk\"),\n[André L C Moreira](https://github.com/carvalhudo \"carvalhudo\"),\n[Anna (navi) Figueiredo Gomes](https://github.com/navi-desu \"navi-desu\"),\n[Antoine Amarilli](https://github.com/a3nm \"a3nm\"),\n[Antoine Beaupré](https://github.com/anarcat \"anarcat\"),\n[Antonio Radici](https://github.com/aradici \"aradici\"),\n[Anton Rieger](https://github.com/inrin \"inrin\"),\n[ashamedbit](https://github.com/ashamedbit \"ashamedbit\"),\n[Ashish Panigrahi](https://github.com/paniash \"paniash\"),\n[auouymous](https://github.com/auouymous \"auouymous\"),\n[Aurelien Francillon](https://github.com/aurelf \"aurelf\"),\n[Austin Lund](https://github.com/aplund \"aplund\"),\n[Austin Ray](https://github.com/austin-ray \"austin-ray\"),\n[Baptiste Daroussin](https://github.com/bapt \"bapt\"),\n[Baudouin Van Humbeck](https://github.com/scriptor-pro \"scriptor-pro\"),\n[Benjamin Mako Hill](https://github.com/makoshark \"makoshark\"),\n[Bernard Pratz](https://github.com/guyzmo \"guyzmo\"),\n[Bertram Scharpf](https://github.com/bertramscharpf \"bertramscharpf\"),\n[Björn Ketelaars](https://github.com/bket \"bket\"),\nBletchley Park,\n[Bo Yu](https://github.com/yuzibo \"yuzibo\"),\n[Brendan McLean](https://github.com/bmclean2 \"bmclean2\"),\n[Brett Holman](https://github.com/holmanb \"holmanb\"),\n[Bryan Bennett](https://github.com/bbenne10 \"bbenne10\"),\n[Carlo Cabrera](https://github.com/carlocab \"carlocab\"),\n[Carlos Henrique Lima Melara](https://github.com/charles2910 \"charles2910\"),\n[Casper Ti Vector](https://github.com/caspervector \"caspervector\"),\n[Chao-Kuei Hung](https://github.com/ckhung \"ckhung\"),\n[Charalampos Kardaris](https://github.com/ckardaris \"ckardaris\"),\n[Charlie Drage](https://github.com/cdrage \"cdrage\"),\n[Chris Czettel](https://github.com/christopher-john-czettel \"christopher-john-czettel\"),\n[Chris Salzberg](https://github.com/shioyama \"shioyama\"),\n[Christian Dröge](https://github.com/cdroege \"cdroege\"),\n[Christian Lütke-Stetzkamp](https://github.com/clkamp \"clkamp\"),\n[Christian Ludwig](https://github.com/luchr \"luchr\"),\n[Christian Storm](https://github.com/stormc \"stormc\"),\n[Christoph Berg](https://github.com/df7cb \"df7cb\"),\n[Christos Margiolis](https://github.com/christosmarg \"christosmarg\"),\n[Chris X Weichenberger](https://github.com/the-x-at \"the-x-at\"),\n[cinder88](https://github.com/cinder88 \"cinder88\"),\n[Claes Nästén](https://github.com/pekdon \"pekdon\"),\n[Clemens Lang](https://github.com/neverpanic \"neverpanic\"),\n[Cody Brownstein](https://github.com/cbrownstein \"cbrownstein\"),\n[Colin Wee](https://github.com/googlebleh \"googlebleh\"),\n[Dai Mochinaga](https://github.com/mochidai \"mochidai\"),\n[Damien Riegel](https://github.com/d-k-c \"d-k-c\"),\n[Daniel Gray](https://github.com/dngray \"dngray\"),\n[Daniel Gröber](https://github.com/danielg \"danielg\"),\nDaniel Klose,\n[Daniel Maslowski](https://github.com/orangecms \"orangecms\"),\n[Dapeng Gao](https://github.com/dpgao \"dpgao\"),\n[Darrel Glud](https://github.com/darrel-glud \"darrel-glud\"),\n[Darren Kenny](https://github.com/darrenkenny \"darrenkenny\"),\n[Darshit Shah](https://github.com/darnir \"darnir\"),\n[David Harrigan](https://github.com/dharrigan \"dharrigan\"),\n[David Purton](https://github.com/dcpurton \"dcpurton\"),\n[David Sterba](https://github.com/kdave \"kdave\"),\n[Deng Xiyue](https://github.com/manphiz \"manphiz\"),\n[Dennis Schön](https://github.com/roccoblues \"roccoblues\"),\n[Dimitrios Semitsoglou-Tsiapos](https://github.com/dset0x \"dset0x\"),\n[Dmitry Polunin](https://github.com/frei-0xff \"frei-0xff\"),\n[Doron Behar](https://github.com/doronbehar \"doronbehar\"),\n[Doug Stone-Weaver](https://github.com/doweaver \"doweaver\"),\n[Eduardo Habkost](https://github.com/ehabkost \"ehabkost\"),\n[Edward Betts](https://github.com/edwardbetts \"edwardbetts\"),\n[El Acheche ANIS](https://github.com/elacheche \"elacheche\"),\n[Elimar Riesebieter](https://github.com/riesebie \"riesebie\"),\n[Eli Winderickx](https://github.com/winderickxeli \"winderickxeli\"),\n[Emir Sari](https://github.com/bitigchi \"bitigchi\"),\n[Enno Nagel](https://github.com/konfekt \"konfekt\"),\n[Eric Blake](https://github.com/ebblake \"ebblake\"),\n[Evgeni Golov](https://github.com/evgeni \"evgeni\"),\n[Fabian Groffen](https://github.com/grobian \"grobian\"),\n[Fabio Locati](https://github.com/Fale \"Fale\"),\n[Fabrice Bellet](https://github.com/fbellet \"fbellet\"),\n[Faidon Liambotis](https://github.com/paravoid \"paravoid\"),\n[Federico Kircheis](https://github.com/fekir \"fekir\"),\n[Florian Klink](https://github.com/flokli \"flokli\"),\n[Florian Wehner](https://github.com/whnr \"whnr\"),\n[Floyd Anderson](https://github.com/floand \"floand\"),\n[Frank Grüllich](https://github.com/FrankGruellich \"FrankGruellich\"),\n[František Hájik](https://github.com/ferkohajik \"ferkohajik\"),\n[Frederick Eaton](https://github.com/archenemies \"archenemies\"),\n[Freed-Wu](https://github.com/wzy \"wzy\"),\n[ftilde](https://github.com/ftilde \"ftilde\"),\n[Gaël Dubois](https://github.com/gaael \"gaael\"),\n[Gerrit Rüsing](https://github.com/kbcb \"kbcb\"),\n[Guillaume Brogi](https://github.com/guiniol \"guiniol\"),\n[Haoyu Qiu](https://github.com/timothyqiu \"timothyqiu\"),\n[Helge Deller](https://github.com/hdeller \"hdeller\"),\nHerbert J Skuhra,\nH N Caldwell,\n[李经纬](https://github.com/ljw20180420 \"ljw20180420\"),\n[наб](https://github.com/nabijaczleweli \"nabijaczleweli\"),\n[Страхиња Радић](https://github.com/strahinja \"strahinja\"),\n[Hugo Barrera](https://github.com/whynothugo \"whynothugo\"),\n[Ian Zimmerman](https://github.com/nobrowser \"nobrowser\"),\n[Igor Serebryany](https://github.com/igor47 \"igor47\"),\n[Ihor Antonov](https://github.com/ngortheone \"ngortheone\"),\n[Ilya Kurdyukov](https://github.com/ilyakurdyukov \"ilyakurdyukov\"),\n[Ismaël Bouya](https://github.com/immae \"immae\"),\n[Ivan Jelincic](https://github.com/parazyd \"parazyd\"),\nIvan Shmakov,\n[Ivan Tham](https://github.com/pickfire \"pickfire\"),\n[Jack Stratton](https://github.com/phroa \"phroa\"),\n[Jakub Jindra](https://github.com/jindraj \"jindraj\"),\n[Jakub Kaczor](https://github.com/jakubkaczor \"jakubkaczor\"),\n[Jakub Wilk](https://github.com/jwilk \"jwilk\"),\n[James Cook](https://github.com/falsifian \"falsifian\"),\n[James Vaughan](https://github.com/jamesbvaughan \"jamesbvaughan\"),\n[Jangho Seo](https://github.com/seojangho \"seojangho\"),\n[Jan Krieg](https://github.com/jan-krieg \"jan-krieg\"),\n[Jan Palus](https://github.com/jpalus \"jpalus\"),\n[Jasper Adriaanse](https://github.com/jasperla \"jasperla\"),\n[Jelle van der Waa](https://github.com/jelly \"jelly\"),\n[Jenya Sovetkin](https://github.com/esovetkin \"esovetkin\"),\n[JerikoOne](https://github.com/jeriko-one \"jeriko-one\"),\n[J Lewis Muir](https://github.com/jlmuir \"jlmuir\"),\n[Joey Pabalinas](https://github.com/alyptik \"alyptik\"),\nJohannes Frankenau,\n[Johannes Weißl](https://github.com/weisslj \"weisslj\"),\n[John Wood](https://github.com/john-at-charpa \"john-at-charpa\"),\n[Jonas Witschel](https://github.com/diabonas \"diabonas\"),\n[Jonathan Perkin](https://github.com/jperkin \"jperkin\"),\n[Joseph Bisch](https://github.com/josephbisch \"josephbisch\"),\n[Josh Poimboeuf](https://github.com/jpoimboe \"jpoimboe\"),\n[Joshua Jordi](https://github.com/jakkinstewart \"jakkinstewart\"),\n[Julian Andres Klode](https://github.com/julian-klode \"julian-klode\"),\n[Justin Vasel](https://github.com/justinvasel \"justinvasel\"),\n[Karel Zak](https://github.com/karelzak \"karelzak\"),\n[Kevin Decherf](https://github.com/kdecherf \"kdecherf\"),\n[Kevin Velghe](https://github.com/paretje \"paretje\"),\n[Kurt Jaeger](https://github.com/opsec \"opsec\"),\n[Larry Rosenman](https://github.com/lrosenman \"lrosenman\"),\n[Lars Haalck](https://github.com/larshaalck \"larshaalck\"),\n[Lars Kellogg-Stedman](https://github.com/larsks \"larsks\"),\n[Leo Lundgren](https://github.com/rawtaz \"rawtaz\"),\n[Leonardo Schenkel](https://github.com/lbschenkel \"lbschenkel\"),\n[Leonidas Spyropoulos](https://github.com/inglor \"inglor\"),\n[Leon Philman](https://github.com/leonphilman \"leonphilman\"),\n[Louis Brauer](https://github.com/louis77 \"louis77\"),\n[Lucas Bourneuf](https://github.com/aluriak \"aluriak\"),\n[Lucian Langa](https://github.com/lucilanga \"lucilanga\"),\n[Maarten van Gompel](https://github.com/proycon \"proycon\"),\n[Manos Pitsidianakis](https://github.com/epilys \"epilys\"),\n[Marcelo Ricardo Leitner](https://github.com/marceloleitner \"marceloleitner\"),\n[Marcin Rajner](https://github.com/mrajner \"mrajner\"),\n[Marco Hinz](https://github.com/mhinz \"mhinz\"),\n[Marco Sirabella](https://github.com/mjsir911 \"mjsir911\"),\n[Marius Gedminas](https://github.com/mgedmin \"mgedmin\"),\n[Mark Stenglein](https://github.com/ocelotsloth \"ocelotsloth\"),\n[Mateus Etto](https://github.com/yutsuten \"yutsuten\"),\n[Mateusz Okulus](https://github.com/mokulus \"mokulus\"),\n[Mateusz Piotrowski](https://github.com/0mp \"0mp\"),\n[Matteo Riondato](https://github.com/rionda \"rionda\"),\n[Matteo Vescovi](https://github.com/mfvescovi \"mfvescovi\"),\n[Matthew Hughes](https://github.com/matthewhughes934 \"matthewhughes934\"),\n[Matthias Gerstner](https://github.com/mgerstner \"mgerstner\"),\n[Mehdi Abaakouk](https://github.com/sileht \"sileht\"),\n[Meindert Kempe](https://github.com/MeindertKempe \"MeindertKempe\"),\nMichael Bazzinotti,\n[Michael Constantine Dimopoulos](https://github.com/michaeldim02 \"michaeldim02\"),\n[Michal Siedlaczek](https://github.com/elshize \"elshize\"),\n[Mingcong Bai](https://github.com/MingcongBai \"MingcongBai\"),\n[Mohammad AlSaleh](https://github.com/MoSal \"MoSal\"),\n[Nagefire](https://github.com/nagefire \"nagefire\"),\n[Naveen Nathan](https://github.com/nnathan \"nnathan\"),\nng0,\n[Nicholas Steeves](https://github.com/sten0 \"sten0\"),\n[Nicholas Wieland](https://github.com/ngw \"ngw\"),\n[Nicolas Bock](https://github.com/nicolasbock \"nicolasbock\"),\n[Olaf Lessenich](https://github.com/xai \"xai\"),\n[Oliver Bandel](https://github.com/klartext \"klartext\"),\n[Pablo Ovelleiro Corral](https://github.com/pinpox \"pinpox\"),\n[Paul Dino Jones](https://github.com/spacefreak18 \"spacefreak18\"),\n[Paulo Matos](https://github.com/pmatos \"pmatos\"),\n[Perry Thompson](https://github.com/rypervenche \"rypervenche\"),\n[Peter Hogg](https://github.com/pigmonkey \"pigmonkey\"),\n[Peter Lewis](https://github.com/petelewis \"petelewis\"),\n[Philipp Marek](https://github.com/phmarek \"phmarek\"),\n[Phil Pennock](https://github.com/philpennock \"philpennock\"),\n[Pierre Colin](https://github.com/Pierre-Colin \"Pierre-Colin\"),\n[Pierre-Elliott Bécue](https://github.com/p-eb \"p-eb\"),\n[Pietro Cerutti](https://github.com/gahr \"gahr\"),\n[r3lgar](https://github.com/r3lgar \"r3lgar\"),\n[raf](https://github.com/raforg \"raforg\"),\n[Rahul Gopinath](https://github.com/vrthra \"vrthra\"),\n[Ramkumar Ramachandra](https://github.com/artagnon \"artagnon\"),\n[Rayford Shireman](https://github.com/rayfordshire \"rayfordshire\"),\n[Róbert Horváth](https://github.com/r001 \"r001\"),\nRegid Ichira,\nReis Radomil,\n[Reto Brunner](https://github.com/brunnre8 \"brunnre8\"),\n[Riad Wahby](https://github.com/kwantam \"kwantam\"),\n[Richard Hartmann](https://github.com/richih \"richih\"),\n[Richard Russon](https://github.com/flatcap \"flatcap\"),\n[Roberto Alvarado](https://github.com/robdres \"robdres\"),\n[Roger Pau Monne](https://github.com/royger \"royger\"),\n[Romeu Vieira](https://github.com/romeug \"romeug\"),\n[Ronan Arraes Jardim Chagas](https://github.com/ronisbr \"ronisbr\"),\n[R Primus](https://github.com/rprimus \"rprimus\"),\nRubén Llorente,\n[Ryan d'Huart](https://github.com/homoelectromagneticus \"homoelectromagneticus\"),\n[Ryan Kavanagh](https://github.com/ryanakca \"ryanakca\"),\n[ryt](https://github.com/0x747972 \"0x747972\"),\n[Santiago Torres](https://github.com/santiagotorres \"santiagotorres\"),\n[Scott Kostyshak](https://github.com/scottkosty \"scottkosty\"),\n[Sebastian Crane](https://github.com/seabass-labrax \"seabass-labrax\"),\n[Sebastian Stark](https://github.com/sstark \"sstark\"),\n[Serge Gebhardt](https://github.com/sgeb \"sgeb\"),\n[Sergey Alirzaev](https://github.com/l29ah \"l29ah\"),\nShane Donohoe,\n[Sheoak](https://github.com/sheoak \"sheoak\"),\nShi Lee,\n[Simon Reichel](https://github.com/amudtogal \"amudtogal\"),\n[Simon Symeonidis](https://github.com/psyomn \"psyomn\"),\n[somini](https://github.com/somini \"somini\"),\n[Stefan Assmann](https://github.com/sassmann \"sassmann\"),\n[Stefan Bühler](https://github.com/stbuehler \"stbuehler\"),\n[Stefan Kropp](https://github.com/debxwoody \"debxwoody\"),\n[Stefano Zacchiroli](https://github.com/zacchiro \"zacchiro\"),\n[Steinar H Gunderson](https://github.com/sesse \"sesse\"),\nStephen Gilles,\n[Steve Bennett](https://github.com/msteveb \"msteveb\"),\n[Steven Ragnarök](https://github.com/nuclearsandwich \"nuclearsandwich\"),\n[Stig Palmquist](https://github.com/stigtsp \"stigtsp\"),\n[Stéphane Lesimple](https://github.com/speed47 \"speed47\"),\n[Stuart Henderson](https://github.com/sthen \"sthen\"),\n[Sven Guckes](https://github.com/guckes \"guckes\"),\n[telshock](https://github.com/telshock \"telshock\"),\n[Theo Jepsen](https://github.com/theojepsen \"theojepsen\"),\n[Thiago Costa de Paiva](https://github.com/tecepe \"tecepe\"),\n[Thomas Adam](https://github.com/thomasadam \"thomasadam\"),\n[Thomas Bracht Laumann Jespersen](https://github.com/laumann \"laumann\"),\n[Thomas Jarosch](https://github.com/thomasjfox \"thomasjfox\"),\n[Thomas Klausner](https://github.com/0-wiz-0 \"0-wiz-0\"),\n[Thomas Sanchez](https://github.com/daedric \"daedric\"),\n[Thomas Schneider](https://github.com/qsuscs \"qsuscs\"),\n[Tim Biermann](https://github.com/timb87 \"timb87\"),\n[Tim Clifford](https://github.com/tim-clifford \"tim-clifford\"),\nTimmy Xiao,\n[Tino Reichardt](https://github.com/mcmilk \"mcmilk\"),\n[Tobias Angele](https://github.com/toogley \"toogley\"),\n[Tobias Stoeckmann](https://github.com/stoeckmann \"stoeckmann\"),\n[Tomáš Karela Procházka](https://github.com/prochac \"prochac\"),\n[toonn](https://github.com/toonn \"toonn\"),\n[Tóth János](https://github.com/g0mb4 \"g0mb4\"),\nUdo Schweigert,\n[Valeri Sergeev](https://github.com/vpub \"vpub\"),\n[Victor Fernandes](https://github.com/ghikio \"ghikio\"),\n[Viktor Cheburkin](https://github.com/vcheburkin \"vcheburkin\"),\n[Vladimir Zakharov](https://github.com/z2v \"z2v\"),\n[vuori](https://github.com/vuori \"vuori\"),\n[Werner Fink](https://github.com/bitstreamout \"bitstreamout\"),\n[Whitney Cumber](https://github.com/whitney-cumber \"whitney-cumber\"),\n[Wieland Hoffmann](https://github.com/mineo \"mineo\"),\n[Will Curry](https://github.com/wcurry \"wcurry\"),\n[William Pettersson](https://github.com/wpettersson \"wpettersson\"),\n[x3nb63](https://github.com/x3nb63 \"x3nb63\"),\n[Yoshiki Vázquez Baeza](https://github.com/eldeveloper \"eldeveloper\"),\n[Yousef Akbar](https://github.com/yousefakbar \"yousefakbar\"),\n[Yubin Ruan](https://github.com/walkerlala \"walkerlala\"),\n[Zak D](https://github.com/zakarouf \"zakarouf\"),\n[Zero King](https://github.com/l2dy \"l2dy\"),\n[zsugabubus](https://github.com/zsugabubus \"zsugabubus\"),\n\n### Patch Authors\n\nWithout the original patch authors, there would be nothing.\nSo, a Big Thank You to:\n\nAaron Schrab, Alain Penders, Benjamin Kuperman, Cedric Duval, Chris Mason,\nChristian Aichinger, Christoph Rissner, David Champion, David Riebenbauer, David\nWilson, Don Zickus, Eric Davis, Felix von Leitner, Jan Synacek, Jason DeTiberus,\nJeremiah Foster, Jeremy Katz, Julius Plenz, Justin Hibbits, Kirill Shutemov,\nLuke Macken, Mantas Mikulenas, Patrick Brisbin, Paul Miller, Philippe Le\nBrouster, Rocco Rutte, Roland Rosenfeld, Sami Farin, Stefan Kuhn, Steve Kemp,\nTerry Chan, Thomas Glanzmann, Thomer Gil, Tim Stoakes, Tyler Earnest, Victor\nManuel Jaquez Leal, Vincent Lefevre, Vladimir Marek, Vsevolod Volkov.\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 110.2197265625,
          "content": "2025-01-09  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - #4477 fix crash in folder-hook\n  - #4480 fix memory leak in compose message preview (fixes #4478)\n  - #4483 query: fix comma-separated names\n  - #4485 lua: fix `lua_mutt_call()`\n  - #4490 notmuch: refresh the Email if the filename changes\n  - fix: no new mail message\n  - fix display of certificate fingerprints\n  - fix prompt colour\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Slovakian\n  - 100% Turkish\n  - 91% French\n  - 41% Chinese (Traditional)\n* Build\n  - #4479 Fix DT_NUMBER entries on 32-bit endian platforms\n* Code\n  - #4481 Simplify `mutt_file_fopen()`\n  - colour refactoring\n  - standardise variable names for temporary files\n\n2024-12-12  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #4437 show message preview in compose view\n  - #4439 add trailing commas when editing addresses\n* Bug Fixes\n  - #4444 expando: fix overflow\n  - #4461 Spaces can be wide\n  - #4464 Remove BOM from UTF-8 text\n  - #4467 Bug with wrong fingerprints in certificate_file\n  - #4470 fix postponed sorting assertion failure\n  - #4472 fix: `save_attachment_open()` when overwriting\n  - #4473 add text-wrapping to compose message preview pager\n  - #4475 edit_headers: cleanup temporary file on error\n  - expando: fix crash on empty `%[]` date\n  - expando: fix container formatting\n  - browser: fix 'tag-' display\n  - query: fix memory leak\n  - fix more arrow_cursor + search\n* Changed Config\n  - Config Renames:\n    - `$pgp_sort_keys`       -> `$pgp_key_sort`\n    - `$sidebar_sort_method` -> `$sidebar_sort`\n    - `$sort_alias`          -> `$alias_sort`\n    - `$sort_browser`        -> `$browser_sort`\n  - Changed Defaults:\n    - `set alias_format = \"%3i %f%t %-15a %-56A | %C%> %Y\"`\n    - `set query_format = \"%3i %t %-25N %-25E | %C%> %Y\"`\n* Translations\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Turkish\n  - 89% French\n  - 39% Chinese (Traditional)\n* Coverity Defects\n  - Explicit null dereferenced\n  - Overflowed constant\n  - Overflowed return value\n  - Resource leak\n* Docs\n  - alias tags\n* Build\n  - #4452 only use `struct tm.tm_gmtoff` if available\n* Code\n  - #4294 refactor memory allocation\n  - #4442 remove unused fields from ComposeSharedData\n  - #4447 refactor 'sort' constants\n  - #4449 add `mutt_window_swap()`\n  - unify Menu data\n  - move config to libraries\n  - unify Alias/Query\n  - expando factor out callbacks\n  - refactor `simple_dialog_new()`\n  - test: add `TEST_CHECK_NUM_EQ()`\n  - fopen: tidy read-only\n* Upstream\n  - #4448 Update queue.h\n\n2024-11-14  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - Fixed: CVE-2024-49393\n  - Fixed: CVE-2024-49394\n  - #4300 Read the protected Message-ID\n* Features\n  - #4336 Allow toggling numeric configs, e.g. `:toggle pager_index_lines`\n  - #4427 alias: tag/untag pattern\n  - query: tag with `<space>`\n* Contrib\n  - #4400 `mutt_oauth2.py`: Fix reference to `client_secret`\n* Bug Fixes\n  - #4399 fix duplicate save-hook\n  - #4403 expando: fix escaping\n  - #4404 browser: fix enter-quit-enter\n  - #4405 pager: fix repaint\n  - #4407 config: warn about deprecated variables\n  - #4425 Refresh alias/query dialog on alias/query format change\n  - #4433 compose: fix redraw on attachment\n  - #4436 compose: fix search with `arrow_cursor`\n  - #4438 autocrypt: fix `copy_normalize_addr()`\n  - alias: fix cli crash\n  - expando: fix relative dates\n  - expando: padding default to space\n* Translations\n  - 100% German\n  - 100% Turkish\n  - 99% Czech\n  - 99% Slovak\n  - 82% French\n* Docs\n  - drop refs to always-enabled features\n  - fix typo in unmacro\n  - fix broken link\n  - ncrypt: fix typo in `config.c`\n\n2024-10-02  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - #4243 - security: kill unnecessary blank lines\n  - #4251 - more security improvements\n  - #4282 - improve NeoMutt bailout handling\n* Features\n  - #4329 - remove mixmaster\n  - #4149 - honour umask in attach save\n* Bug Fixes\n  - #3945 - do not force username in addition to client certificate\n  - #4341 - Fix '%z' and '%Z in '%{...}' expando\n  - #4356 - Allow longer maildir filename suffixes\n  - #4357 - Don't force mbox stats calculations on startup\n  - #4365 - Fix sorting INBOX and its subfolders\n  - #4367 - Let `~Y` match each tag individually\n  - #4371 - ignore macro events during autocrypt initialization\n  - #4383 - Generate the Message-ID earlier\n  - compose: fix `$compose_confirm_detach_first`\n* Changed Config\n  - `set crypt_encryption_info = yes`\n    Add an informative block with details about the encryption\n  - `set crypt_protected_headers_weed = no`\n    Controls whether NeoMutt will weed protected header fields\n  - `set devel_security = no`\n    Devel feature: Security -- https://github.com/neomutt/neomutt/discussions/4251\n  - `$mixmaster` is deprecated\n  - `$mix_entry_format` is deprecated\n* Translations\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Spanish\n  - 81% French\n* Docs\n  - #4350 - Fix configure script name in INSTALL.md\n  - fix para ordering\n* Build\n  - #4280 - Update autosetup\n  - #4281 - Update acutest to the latest upstream commit\n  - #4289 - don't treat stddef.h specially\n  - #4306 - Add -std to CFLAGS too\n  - #4307 - require C11\n  - #4347 - Support BerkeleyDB 18.1\n  - #4362 - Assume 'struct timespec' exists\n  - fix idn2 typo\n* Code\n  - #4113 - Close the hcache handle on failure to open the store\n  - #4214 - upgrade `assert()`\n  - #4283 - mutt/list.c: Use `STAILQ_FOREACH_SAFE()` in stailq deallocators\n  - #4296 - Use `wmem*()` functions with wide-character strings\n  - #4297 - ncrypt/crypt.c: Fix allocation size calculation\n  - #4305 - remove `mutt_expand_path()`\n  - #4308 - fix `-Wdouble-promotion` warnings\n  - #4310 - scanf: initialise out-vars\n  - #4312 - Allow opening the header cache in non-`O_CREAT` mode\n  - #4337 - Fix function pointer types\n  - #4348 - Check `mutt_date_parse_date()`s return value\n  - #4366 - Fix up slashes in `imap_fix_path()`\n  - #4378 - Fix padding with an empty string\n  - tidy expando library\n\n2024-04-25  Richard Russon  \\<rich@flatcap.org\\>\n- Bug Fixes\n  - #4263 fix: cache naming\n  - #4261 expando: fix conditional padding\n  - #4261 expando: fix container\n  - #4261 expando: add lower-case operator\n  - #4261 expando: add external filter\n  - imap: add mailboxes more directly\n- Translations\n  - trans: tidy messages\n- Docs\n  - doxy: add missing params\n- Build\n  - #4268 Filter out CFLAGS with paths from the output of '-v'\n  - #4273 guard truecolor functions in tests\n  - #4275 use homebrew in macOS build\n- Code\n  - use Buffer rather than strcat()\n  - ncrypt: use gpgme types consistently\n\n2024-04-16  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #4216 Compose: Hide MixMaster chain if chain is empty\n  - Expando upgrade\n  - version: bold labels\n* Contrib\n  - mutt_oauth2.py: Detect recipient for oauth automatically\n  - mutt_oauth2.py: imap_oauth_refresh_command does not need options\n* Bug Fixes\n  - #4210 mbox: fix sorting for `mbox_resync()`\n  - #4241 only wrap after first address in header lines\n  - status: reset Buffer before reuse\n  - history: truncate file before writing over it\n  - notmuch: strip leading / from short path\n  - Fix smtp client `$envelope_from_address` possible dangling pointer\n  - Fix non-printable keyname printing to use `<octal>` syntax\n  - Filter Arabic Letter Mark due to display corruption\n  - Loosen `imap_open_mailbox()` SELECT response data parsing\n  - Change `mailto_allow` to be exact match only\n  - Fix `mutt_read_rfc822_line()` to use `is_email_wsp()`\n  - Improve pattern compiler whitespace skipping\n  - Fix gpgme crash when listing keys in a public key block\n  - Add SigInt handler for pattern functions\n  - Fix some mailbox prompts to use mailbox history ring\n  - Improve GPGME inline processing\n  - Reset SIGPIPE signal handler in child process before `exec()`\n  - Filter headers passed via the command line\n  - Remove trailing slashes when opening maildir/mh mailboxes\n  - Fix `mutt_paddstr()` to properly filter unprintable chars\n  - Minor fixes to `match_body_patterns()`\n  - Fix `mutt_ts_capability()` fallback list loop\n  - Ensure SIGALRM interrupts connect() in batch mode\n  - Tighten `$query_command` parsing to allow empty name field\n* Changed Config\n  - #4224 config: add L10N support\n  - New: `set compose_confirm_detach_first = yes`\n    Prevent the accidental deletion of the composed message\n  - Changed: `set reply_regex = \"^((re)(\\\\[[0-9]+\\\\])*:[ \\t]*)*\"`\n    Regex to match message reply subjects like 're: '\n  - Changed: `set pager = \"\"`\n    External command for viewing messages, or empty to use NeoMutt's\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Slovak\n  - 99% Turkish\n  - l10n: document functions\n  - config: add L10N support\n* Docs\n  - Clarify the manual section on POP3 support\n  - Document the `<1234>` key syntax for bind\n  - Document `$sendmail` invocation behavior\n  - Clarify -H usage in batch mode is not a \"pass through\" option\n\n2024-03-29  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - #4185 c441f5957 Fix memory leak in trash_append()\n  - #4189 Fix off-by-one error in %b with notmuch\n  - #4190 Zero-out mailbox counters on delete\n  - #4204 colour: honour the normal colour\n  - #4205 match folder-hook also against mailbox name (fixes #4201)\n  - wrap colour in <show-log-messages>\n  - history: fix saving file\n  - history: improve error message format\n* Docs\n  - #4182 docs: -C: Fix some accidents\n  - #4188 Update oauth2 README\n  - #4193 Update oauth2 README\n  - fix typos, lots of tidying\n  - tidy license info\n* Build\n  - #4196 use FreeBSD 14.0 in Cirrus CI\n  - actions: update cpu count\n  - actions: use codeql v3\n* Code\n  - #4186 Buffer refactoring: make_entry()\n  - address: tidy config handling\n  - coverage: buf, slist\n  - graphviz: link labels\n  - tidy buf_strcpy() calls\n  - tidy char buffers\n  - test: default timezone to UTC\n\n2024-03-23  Richard Russon  \\<rich@flatcap.org\\>\n* Do NOT use this release\n\n2024-02-01  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #4134 Command-line Crypto (neomutt -C)\n* Bug Fixes\n  - #4065 track new-mail check time per mailbox\n  - #4141 fix(change-folder): don't exclude notmuch\n  - #4147 envelope: manage subject/real_subj together\n  - #4155 fix parsing of $REPLYTO\n  - #4158 status: fix refresh after sync-mailbox\n  - #4166 Fix two memory leaks in notmuch support\n  - progress: fix percentages\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Slovak\n  - 100% Turkish\n* Docs\n  - #4172 Several fixes for the manual pages\n* Build\n  - build: openbsd workarounds\n* Code\n  - #4142 add mutt_time_now()\n  - #4146 config: factor out R_ flags\n  - #4154 file: upgrade mutt_file_fopen/fclose()\n  - #4159 upgrade mutt_str_append_item() to use struct Buffer\n  - #4161 maildir: encapsulate the header cache\n  - #4162 remove mutt_str_dequote_comment()\n  - #4165 bufferize mutt_str_inline_replace() as buf_inline_replace()\n  - #4167 bufferize mutt_strn_rfind() as buf_rfind()\n  - #4168 replace buf_len() checks with buf_is_empty()\n  - config: drop unused flags\n  - use message_new()/message_free()\n  - Reconsider the config type bitmap entirely\n\n2023-12-21  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #4126 - add alias 'tags:'\n* Bug Fixes\n  - #4115 - create HelpBar after colours\n  - #4116 - Fix Batch Sending of Emails\n  - #4119 - Fix Header Cache Key Handling\n  - #4121 - mutt_oauth2.py: error out if ENCRYPTION_PIPE was not supplied\n  - #4124 - config: fix flag overlaps\n  - #4125 - compose: restore view-text/pager/mailcap\n  - color: fix attr_color_copy()\n  - fix :color dump\n  - fix leak in completion\n  - force mail check on current mailbox after `<imap-fetch-mail>`\n  - Allow sending an empty mail\n  - mutt_oauth2.py: Use readline to overcome macOS input() restrictions\n* Changed Config\n  - add $history_format: '%s'\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Slovak\n  - 100% Turkish\n  - 99% Spanish\n  - 99% Hungarian\n* Coverity defects\n  - #4111 Educate Coverity about ARRAYs\n  - fix defects\n* Build\n  - #4098 - build: use fallthrough attribute\n  - #4100 - build: split maildir and mh types\n  - #4101 - version: drop default features\n  - #4108 - strip non-conditionals\n  - #4122 - add github action to check for unused functions (xunused)\n  - update fedora action\n  - coverage: fix build for lcov v2\n  - tests: fix error cases\n* Code\n  - #4097 - config: add DT_ON_STARTUP\n  - #4104 - Change mutt_default_save() and addr_hook() to take a buffer\n  - #4105 - Use buffer pool in tests\n  - #4106 - Switch some buffers to use the buffer pool\n  - #4109 - Improve the Progress Bar\n  - #4117 - remove MxOps::path_parent() and mutt_path_parent()\n  - #4120 - remove unused functions\n  - #4131 - move editor test code\n  - #4133 - move log_disp_null() into test folder\n  - #4137 - move config string name functions into tests\n  - add: hook_new()/hook_free()\n  - fix more printf-style params\n  - rename compare to equal\n  - hcache: renaming for clarity\n\n2023-11-03  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #4080 - info screen: enable \\<save-message\\>\n  - #4075 - add color command\n  - color: add ANSI RGB support\n  - color: Support ANSI 2x clear sequences\n* Bug Fixes\n  - #4074 - color: fix palette conversion\n  - #4081 - fix logging on error\n  - #4081 - log: vim-style\n  - #4082 - fix file auto-completion\n  - #4090 - improve logic for growing mailbox memory\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Slovak\n  - 100% Turkish\n* Build\n  - #4085 - fix CFLAGS/LDFLAGS for ncurses\n  - #4085 - configure --with-iconv\n* Code\n  - #4067 - remove unused count of new mails from index private data\n  - #4086 - smtp: Simplify the API of `smtp_code()`\n  - #4091 - simplify CLAMP by expressing it with MIN/MAX\n  - color: introduce ColorElement\n  - color: log gui info on startup\n  - color: move business logic out of parsers\n  - color: tidy OptNoCurses cases\n  - log: add `log_multiline()`\n  - test: increase coverage\n\n2023-10-23  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - #4060 - fix crash on exit\n  - #4061 - fix header colour\n  - #4064 - fix 32-bit date overflow\n  - #4078 - fix new mail in limited view\n  - nntp: fix use-after-free\n  - color: fix ansi colours\n  - color: add +truecolor to version string\n\n2023-10-06  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #3870 - color: allow 'alert', 'bright', 'light' prefix for colorNNN\n  - #3871 - color: refactor parsing code\n  - #3895 - imap: truncate large UIDVALIDITYs to support non-conforming IMAP servers\n  - #3898 - hcache: shrink Email and Body caches\n  - #3900 - prompt: treat complete-query as complete where it makes sense\n  - #3925 - help: add message flags to help screen\n  - #3932 - help: add alternating colors\n  - #3982 - mailboxes: add `-label`, `-notify` and `-poll` options\n  - #4046 - color_directcolor: Also set the default/initial value on startup\n* Bug Fixes\n  - #3897 - maildir: fix sync when a deleted file disappears\n  - #3878 - gnutls: fix \"certificate saved\" message\n  - #3895 - imap: truncate large UIDVALIDITYs to support non-conforming servers\n  - #3897 - maildir: fix fix error with `<sync-mailbox>` on mbsync\n  - #3901 - address: parse comments after address\n  - #3915 - bind: fix truncated binding strings\n  - #3956 - fix 'from' address when real name isn't set\n  - #3962 - Fix crash on `<next-thread>` when the `<limit>`ed view is empty\n  - #3985 - browser: fix autocompletion\n  - #3988 - pager: fix search crash\n  - #3999 - help: fix search highlight\n  - #4049 - force mail check on current mailbox after `<shell-escape>`\n  - #4051 - openssl: continue if a signal interrupts an SSL read/write\n* Config\n  - #3881 - Rename `$imap_keepalive` to `$imap_keep_alive`\n  - #3889 - Change defaults to use `%<...>` conditional syntax\n    `$attach_format`, `$index_format`, `$mailbox_folder_format`,\n    `$status_format`, `$ts_icon_format`, `$ts_status_format`\n  - #3949 - Add `browser_sort_dirs_first` to always list directories first\n* Code\n  - #3877 - imap: factor out tagged emails\n  - #3799 - address: use struct Buffer instead of plain char pointers\n  - #3868 - drop notifications relay\n  - #3869 - move `$delete_untag` out of the backend\n  - #3873 - respect `--[disable-]fmemopen` in tests\n  - hcache: optimize storage requirements, reduce config\n  - logging: catch format string errors\n  - colour:  refactor colour parsing\n  - refactoring, cleanup\n  - fixed coverity defects\n  - convert many functions to use a `Buffer`\n* Translations\n  - 100% :tr: Turkish\n  - 100% :serbia: Serbian\n  - 100% :lithuania: Lithuanian\n  - 100% :de: German\n  - 99% :czech_republic: Czech\n  - 99% :poland: Polish\n  - 98% :slovakia: Slovak\n\n2023-05-17  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #3699 - Support 24bit colors, aka truecolor\n  - #3738 - Show complete MIME structure in attachments\n  - #3842 - Allow percentages to be localized\n* Bug Fixes\n  - #3813 - Fix crash in `op_browser_subscribe()`\n  - #3844 - Select the first email when coming from an empty limit\n  - #3848 - Fix counting new mails in maildir\n  - #3864 - Fix handling of bright colours\n  - #3759 - bind: fix incorrect conflict report\n  - #3781 - index: only refresh the menu on non-focus window changes\n  - #3856 - tunnel: fix reconnection with `ssl_force=true`\n  - #3860 - maildir: stop parsing headers at the end of the headers section\n  - Fix sorting of labels\n* Translations\n  - 100% :serbia: Serbian\n  - 100% :tr: Turkish\n  - 100% :lithuania: Lithuanian\n  - 100% :hungary: Hungarian\n  - 100% :de: German\n  - 99% :norway: Norwegian (Bokmål)\n  - 99% :slovakia: Slovak\n  - 99% :brazil: Portuguese (Brazil)\n  - 99% :czech_republic: Czech\n  - 99% :poland: Polish\n  - 95% :fr: French\n* Build\n - #3798 - Build with libidn2 by default, remove support for libidn1\n* Code\n  - config: dynamically create/delete variables\n  - config: unify handling of NeoMutt and user (my_) variables\n  - config: cache config variables used often\n  - speed: various speedups in parsing emails\n  - cleanups: lots of code cleanups\n  - Huge refactoring towards a separation of Mailbox/MailboxView\n\n2023-05-12  Richard Russon  \\<rich@flatcap.org\\>\n* BROKEN - Please use 2023-05-17 instead\n\n2023-04-07  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #3769 - imap : support IMAP4 ID extension (RFC2971)\n  - #3753 - parse: query all changed (`set`) / all (`set all`) config variables\n* Bug Fixes\n  - #3785 - lua: fix command registration\n  - #3793 - postpone: use colours from the right mailbox\n  - #3794 - smtp: ignore oauth if it isn't configured and not requested\n* Config\n  - #3779 - New: `$imap_send_id` - Send IMAP ID command when logging in\n* Translations\n  - 100% :czech_republic: Czech\n  - 100% :de: German\n  - 100% :hungary: Hungarian\n  - 100% :lithuania: Lithuanian\n  - 100% :brazil: Portuguese (Brazil)\n  - 100% :serbia: Serbian\n  - 100% :slovakia: Slovak\n  - 99% :poland: Polish\n* Docs\n  - Recommend GPGME\n* Code\n  - #3767 - libmutt: eliminate use of config variables\n  - #3774 - fix ubsan warning\n  - #3802 - mutt: optimize and inline `mutt_str_is_email_wsp()`\n  - #3803 - progress: update ncurses only when there is actual progress\n  - #3801 - email: Read `$assumed_charset` outside loops\n  - #3805 - hcache: do less work when not in use\n  - #3777 - pager: add helper for getting `$pager`\n  - #3797 - hcache: remove spurious +1 from Buffer serialization.\n* Build\n  - #3787 - fix race condition in `make install`\n  - #3780 - fallback to detect SASL manually if pkg-config fails, e.g., homebrew\n\n2023-03-22  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - #3372 - use DT_SLIST for charset variables\n  - #3383 - support viewing html with embedded images\n  - #3408 - account command, see the [feature page](https://neomutt.org/feature/account-cmd)\n  - #3411 - check that `$sendmail` and `$inews` don't contain shell meta characters\n  - #3412 - browser: add `$mailbox_folder_format` config variable\n  - #3421 - enter: add function `<kill-whole-line>`\n  - #3414 - account command: add macOS keychain sample provider\n  - #3430 - account command: add GPG+JSON sample provider\n  - #3474 - expose italics attribute for colour scheme\n  - #3471 - allow `source` in hooks to point to relative paths\n  - #3506 - resolve alternates when subscribing/unsubscribing\n  - #3492 - notmuch: allow specifying configuration file\n  - #3547 - notmuch: allow usage of notmuch profiles\n  - #3524 - add GNU SASL support for authentication (`--gsasl` configure option)\n  - #3548 - extend colour objects to support patterns\n  - #3586 - detect and fixup maildirs with missing \"new\" and \"tmp\" directories\n  - #3634 - generate standard MIME types as application/pkcs7-* instead of legacy application/x-pkcs7-*\n  - #3639 - compose: add Smime: pseudo header\n  - #3641 - handle more X-Mutt pseudo-headers with `$edit_headers`\n  - #3702 - use `$socket_timeout` to time out read/write operations\n  - #3717 - allow `%[fmt]` in `$folder_format`\n  - #3719 - respect `$attribution_locale` in `$indent_string` and `$post_indent_string`\n  - #3720 - pattern: add `~K` to search Bcc, include Bcc in `~C`, `%C`, `~L`, and `~p`\n  - #3726 - colour postponed emails list\n  - #3734 - allow querying user-defined variables (`$my_var`) with `-Q`\n  - #3737 - dump user-defined variables (`$my_var`) with `-D`\n  - #3655 - generate purely random `Message-ID` headers\n  - #3752 - allow an empty `$sidebar_divider_char`\n  - #3745 - fix handling and display of group addresses\n* Bug Fixes\n  - #3386 - fix `$status_on_top` to work on complex windows, e.g., attach\n  - #3397 - imap: fix off-by-one error causing bogus \"Progress message 10/9\" message\n  - #3423 - attach: fix segfault when viewing HTML attachment in compose mode\n  - #3434 - allow for longer expansions in e.g., `$index_format`\n  - #3450 - accept unpadded base64-encoded data, as some mailers produce\n  - #3465 - fix hangup when trying to add email address from help screens\n  - #3468 - handle corrupted header caches\n  - #3518 - fix slowdown when changing folders\n  - #3828 - improve error detection for invalid `color` regexes\n  - #3533 - distinguish between old/new with `$mark_old` unset\n  - #3539 - parse mboxes with unconventional `From` lines\n  - #3572 - fix hostname detection for hostname ending with a \".\"\n  - #3596 - fix truncated SMTP lines in case of very long lines\n  - #3600 - use `$smime_sign_as` instead of `$pgp_sign_as` when signing S/MIME messages\n  - #3697 - set `$smime_sign_as` instead of `$smime_default_key` when signing\n  - #3609 - fix wrong message being marked as read with `$pager_read_delay = 1`\n  - #3653 - fix negative new-mail count on maildir\n  - #3656 - skip zero width non-joiner character in the pager\n  - #3664 - handle text/vcard as not being an attachment, same as for text/x-vcard\n  - #3666 - fix `hdr_order` not sorting last header correctly\n  - #3673 - make exiting via SIGINT more graceful\n  - #3700 - fix `unhook index-format-hook`\n  - #3709 - send: delete signature when sending fails #3709\n  - #3727 - SMTP: try all available methods even if SASL is not compiled in\n  - #3730 - fix decryption issue when postponing S/MIME encrypted mails\n  - avoid unnecessary refreshes\n  - fixed a number of memory leaks and crashes\n* Config\n  - #3604 - rename `$ask_follow_up` to `$ask_followup_to`\n  - #3659 - rename `sidebar_whitelist`/`unsidebar_whitelist` to `sidebar_pin`/`sidebar_unpin`\n  - #3629 - skip line rest of line after a warning\n  - #3670 - `$vfolder_format` is now deprecated, use `$folder_format`\n  - #3702 - rename `$connect_timeout` to `$socket_timeout`\n  - #3697 - `pgp_entry_format`: add %i expand for the key fingerprint\n  - #3724 - rename `$attribution` to `$attribution_intro` and\n    `$post_indent_string` to `$attribution_trailer`\n  - config variables are now properly spelled with underscores between names,\n    e.g., `$implicit_autoview` -> `$implicit_auto_view`, `$message_cachedir` ->\n    `$message_cache_dir`; the old names were kept as synonyms\n* Translations\n  - 100% Czech\n  - 100% German\n  - 100% Hungarian\n  - 100% Lithuanian\n  - 100% Portuguese (Brazil)\n  - 100% Serbian\n  - 100% Slovak\n  - 100% Turkish\n  - 99% Spanish\n  - 99% Ukrainian\n  - 94% Polish\n  - 72% Catalan\n* Docs\n  - lots of documentation cleanups and updates\n* Code\n  - a lot of refactor to make the code more organizes, especially in these\n    areas: windowing, menu, browser, enter, function dispatching, key handling,\n    auto-completion\n  - fewer global variables\n  - removal of some unmaintained contrib code\n  - new maintained sample config and examples are in the `data` directory\n  - the contrib script mutt_oauth2.py received a lot of love\n* Build\n  - #3548 - support building with Undefined Behaviour Sanitizer (`--ubsan` configure option)\n  - #3722 - generate compile_commands.json (`--compile-commands` configure option)\n  - use pkg-config to locate most of the 3rd party dependencies\n  - fix curses for netbsd\n  - improve our CI stack\n  - create libparse - parsing functions that can be easily tested\n  - refactor commands / icommands\n\n2022-04-29  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Do not crash on an invalid use_threads/sort combination\n  - Fix: stuck browser cursor\n  - Resolve (move) the cursor after `<edit-label>`\n  - Index: fix menu size on new mail\n  - Don't overlimit LMDB mmap size\n  - OpenBSD y/n translation fix\n  - Generic: split out OP_EXIT binding\n  - Fix parsing of sendmail cmd\n  - Fix: crash with `$menu_move_off=no`\n  - Newsrc: bugfix; `$nntp_user` and `$nntp_pass` ignored\n  - Menu: ensure config changes cause a repaint\n  - Mbox: fix sync duplicates\n  - Make sure the index redraws all that's needed\n* Translations\n  - 100% Chinese (Simplified)\n  - 100% Czech\n  - 100% German\n  - 100% Hungarian\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Turkish\n* Docs\n  - add missing pattern modifier ~I for `$external_search_command`\n* Code\n  - menu: eliminate custom_redraw()\n  - modernise mixmaster\n  - Kill global and Propagate display attach status through State\n\n2022-04-15  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - Fix uudecode buffer overflow (CVE-2022-1328)\n* Features\n  - Colours, colours, colours\n* Bug Fixes\n  - Pager: fix `$pager_stop`\n  - Merge colours with normal\n  - Color: disable mono command\n  - Fix forwarding text attachments when `$honor_disposition` is set\n  - Pager: drop the nntp change-group bindings\n  - Use `mailbox_check()` flags coherently, add IMMEDIATE flag\n  - Fix: tagging in attachment list\n  - Fix: misalignment of mini-index\n  - Make sure to update the menu size after a resort\n* Translations\n  - 100% Hungarian\n* Build\n  - Update acutest\n* Code\n  - Unify pipe functions\n  - Index: notify if navigation fails\n  - Gui: set colour to be merged with normal\n  - Fix: leak in `tls_check_one_certificate()`\n* Upstream\n  - Flush `iconv()` in `mutt_convert_string()`\n  - Fix integer overflow in `mutt_convert_string()`\n  - Fix uudecode cleanup on unexpected eof\n\n2022-04-08  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Compose multipart emails\n* Bug Fixes\n  - Fix screen mode after attempting decryption\n  - imap: increase max size of oauth2 token\n  - Fix autocrypt\n  - Unify Alias/Query workflow\n  - Fix colours\n  - Say which file exists when saving attachments\n  - Force SMTP authentication if `$smtp_user` is set\n  - Fix selecting the right email after limiting\n  - Make sure we have enough memory for a new email\n  - Don't overwrite with zeroes after unlinking the file\n  - Fix crash when forwarding attachments\n  - Fix help reformatting on window resize\n  - Fix poll to use PollFdsCount and not PollFdsLen\n  - regex: range check arrays strictly\n  - Fix Coverity defects\n  - Fix out of bounds write with long log lines\n  - Apply `$fast_reply` to 'to', 'cc', or 'bcc'\n  - Prevent warning on empty emails\n* Changed Config\n  - New default: `set rfc2047_parameters = yes`\n* Translations\n  - 100% German\n  - 100% Lithuanian\n  - 100% Serbian\n  - 100% Czech\n  - 100% Turkish\n  - 72% Hungarian\n* Docs\n  - Improve header cache explanation\n  - Improve description of some notmuch variables\n  - Explain how timezones and `!`s work inside `%{}`, `%[]` and `%()`\n  - Document config synonyms and deprecations\n* Build\n  - Create lots of GitHub Actions\n  - Drop TravisCI\n  - Add automated Fuzzing tests\n  - Add automated ASAN tests\n  - Create Dockers for building Centos/Fedora\n  - Build fixes for Solaris 10\n  - New libraries: browser, enter, envelope\n  - New configure options: `--fuzzing` `--debug-color` `--debug-queue`\n* Code\n  - Split Index/Pager GUIs/functions\n  - Add lots of function dispatchers\n  - Eliminate `menu_loop()`\n  - Refactor function opcodes\n  - Refactor cursor setting\n  - Unify Alias/Query functions\n  - Refactor Compose/Envelope functions\n  - Modernise the Colour handling\n  - Refactor the Attachment View\n  - Eliminate the global `Context`\n  - Upgrade `mutt_get_field()`\n  - Refactor the `color quoted` code\n  - Fix lots of memory leaks\n  - Refactor Index resolve code\n  - Refactor PatternList parsing\n  - Refactor Mailbox freeing\n  - Improve key mapping\n  - Factor out charset hooks\n  - Expose mutt_file_seek API\n  - Improve API of `strto*` wrappers\n* Upstream\n  - imap QRESYNC fixes\n  - Allow an empty To: address prompt\n  - Fix argc==0 handling\n  - Don't queue IMAP close commands\n  - Fix IMAP UTF-7 for code points >= U+10000\n  - Don't include inactive messages in msgset generation\n\n2021-10-29  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Notmuch: support separate database and mail roots without .notmuch\n* Bug Fixes\n  - fix notmuch crash on open failure\n  - fix crypto crash handling pgp keys\n  - fix ncrypt/pgp file_get_size return check\n  - fix restore case-insensitive header sort\n  - fix pager redrawing of long lines\n  - fix notmuch: check database dir for xapian dir\n  - fix notmuch: update index count after `<entire-thread>`\n  - fix protect hash table against empty keys\n  - fix prevent real_subj being set but empty\n  - fix leak when saving fcc\n  - fix leak after `<edit-or-view-raw-message>`\n  - fix leak after trash to hidden mailbox\n  - fix leak restoring postponed emails\n\n2021-10-22  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - fix new mail notifications\n  - fix pattern compilation error for ~( !~>(~P) )\n  - fix menu display on window resize\n  - Stop batch mode emails with no argument or recipients\n  - Add sanitize call in print mailcap function\n  - fix `hdr_order` to use the longest match\n  - fix (un)setenv to not return an error with unset env vars\n  - fix Imap sync when closing a mailbox\n  - fix segfault on OpenBSD current\n  - sidebar: restore `sidebar_spoolfile` colour\n  - fix assert when displaying a file from the browser\n  - fix exec command in compose\n  - fix `check_stats` for Notmuch mailboxes\n  - Fallback: Open Notmuch database without config\n  - fix gui hook commands on startup\n* Changed Config\n  - Re-enable `$ssl_force_tls`\n* Translations\n  - 100% Serbian\n  - 100% Lithuanian\n  - 100% German\n* Build\n  - Warn about deprecated configure options\n\n2021-10-15  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - Fix CVE-2021-32055\n* Features\n  - threads: implement the `$use_threads` feature\n    https://neomutt.org/feature/use-threads\n  - hooks: allow a -noregex param to folder and mbox hooks\n  - mailing lists: implement list-(un)subscribe using RFC2369 headers\n  - mailcap: implement x-neomutt-nowrap flag\n  - pager: add `$local_date_header` option\n  - imap, smtp: add support for authenticating using XOAUTH2\n  - Allow `<sync-mailbox`> to fail quietly\n  - imap: speed up server-side searches\n  - pager: improve `<skip-quoted>` and `<skip-headers>`\n  - notmuch: open database with user's configuration\n  - notmuch: implement `<vfolder-window-reset>`\n  - config: allow `+=` modification of my_ variables\n  - notmuch: tolerate file renames behind neomutt's back\n  - pager: implement `$pager_read_delay`\n  - notmuch: validate `$nm_query_window_timebase`\n  - notmuch: make `$nm_record` work in non-notmuch mailboxes\n  - compose: add `$greeting` - a welcome message on top of emails\n  - notmuch: show additional mail in query windows\n* Changed Config\n- Renamed lots of config, e.g.  `$askbcc` to `$ask_bcc`.\n* Bug Fixes\n  - imap: fix crash on external IMAP events\n  - notmuch: handle missing libnotmuch version bumps\n  - imap: add sanity check for qresync\n  - notmuch: allow windows with 0 duration\n  - index: fix index selection on `<collapse-all>`\n  - imap: fix crash when sync'ing labels\n  - search: fix searching by Message-Id in `<mark-message>`\n  - threads: fix double sorting of threads\n  - stats: don't check mailbox stats unless told\n  - alias: fix crash on empty query\n  - pager: honor mid-message config changes\n  - mailbox: don't propagate read-only state across reopens\n  - hcache: fix caching new labels in the header cache\n  - crypto: set invalidity flags for gpgme/smime keys\n  - notmuch: fix parsing of multiple `type=`\n  - notmuch: validate `$nm_default_url`\n  - messages: avoid unnecessary opening of messages\n  - imap: fix seqset iterator when it ends in a comma\n  - build: refuse to build without pcre2 when pcre2 is linked in ncurses\n* Translations\n  - 100% Serbian\n  - 100% Lithuanian\n  - 100% German\n  - 100% Czech\n  - 96% Spanish\n  - 92% Polish\n  - 85% Norwegian\n  - 80% French\n  - 78% Russian\n  - 74% Esperanto\n  - 66% Greek\n\n2021-02-05  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add `<skip-headers>` to skip past message headers in pager\n  - Add `<view-pager>` function to attachment menu\n* Bug Fixes\n  - Fix detection of mbox files with new mail\n  - Fix crash on collapsed thread\n  - Fix `<group-chat-reply>`\n  - Clear the message window on resize\n  - Do not crash on return from shell-exec if there's no open mailbox\n  - Abort IMAP open if condstore/qresync updates fetch fails\n  - Fix smtp crash on invalid `$smtp_authenticators` list\n  - Fix pager dropped input on screen resize\n  - Fix mime forwarding\n  - Check config after hooks\n  - Always recreate a mailbox after `folder-hook`\n* Translations\n  - 88% Slovakian\n* Docs\n  - Adjust doc to explicitly mention `$count_alternatives`\n  - Restore correct `$sort_re` documentation\n  - Clarify pattern completion\n  - Man pages: Clear up \"-H\" and \"-O\"\n* Build\n  - Update to latest acutest\n  - Update to latest autosetup\n  - Make the location of /tmp configurable\n\n2020-11-20  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Fix crash when saving an alias\n* Translations\n  - 70% Russian\n* Code\n  - Remove redundant function call\n\n2020-11-20  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - imap: close connection on all failures\n* Features\n  - alias: add `<limit>` function to Alias/Query dialogs\n  - config: add validators for `{imap,smtp,pop}_authenticators`\n  - config: warn when signature file is missing or not readable\n  - smtp: support for native SMTP LOGIN auth mech\n  - notmuch: show originating folder in index\n* Bug Fixes\n  - sidebar: prevent the divider colour bleeding out\n  - sidebar: fix `<sidebar-{next,prev}-new>`\n  - notmuch: fix `<entire-thread>` query for current email\n  - restore shutdown-hook functionality\n  - crash in reply-to\n  - user-after-free in `folder-hook`\n  - fix some leaks\n  - fix application of limits to modified mailboxes\n  - write Date header when postponing\n* Translations\n  - 100% Lithuanian\n  - 100% Czech\n  - 70% Turkish\n* Docs\n  - Document that `$alias_sort` affects the query menu\n* Build\n  - improve ASAN flags\n  - add SASL and S/MIME to `--everything`\n  - fix contrib (un)install\n* Code\n  - `my_hdr` compose screen notifications\n  - add contracts to the MXAPI\n  - maildir refactoring\n  - further reduce the use of global variables\n* Upstream\n  - Add `$count_alternatives` to count attachments inside alternatives\n\n2020-09-25  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Compose: display user-defined headers\n  - Address Book / Query: live sorting\n  - Address Book / Query: patterns for searching\n  - Config: Add `+=` and `-=` operators for String Lists\n  - Config: Add `+=` operator for Strings\n  - Allow postfix query `:setenv NAME?` for env vars\n* Bug Fixes\n  - Fix crash when searching with invalid regexes\n  - Compose: Prevent infinite loop of `send2-hook`s\n  - Fix sidebar on new/removed mailboxes\n  - Restore indentation for named mailboxes\n  - Prevent half-parsing an alias\n  - Remove folder creation prompt for POP path\n  - Show error if `$message_cachedir` doesn't point to a valid directory\n  - Fix tracking LastDir in case of IMAP paths with Unicode characters\n  - Make sure all mail gets applied the index limit\n  - Add warnings to -Q query CLI option\n  - Fix index tracking functionality\n* Changed Config\n  - Add `$compose_show_user_headers` (yes)\n* Translations\n  - 100% Czech\n  - 100% Lithuanian\n  - Split up usage strings\n* Build\n  - Run shellcheck on `hcachever.sh`\n  - Add the Address Sanitizer\n  - Move compose files to lib under compose/\n  - Move address config into libaddress\n  - Update to latest acutest - fixes a memory leak in the unit tests\n* Code\n  - Implement ARRAY API\n  - Deglobalised the Config Sort functions\n  - Refactor the Sidebar to be Event-Driven\n  - Refactor the Color Event\n  - Refactor the Commands list\n  - Make `ctx_update_tables()` private\n  - Reduce the scope/deps of some Validator functions\n  - Use the Email's IMAP UID instead of an increasing number as index\n  - debug: log window focus\n\n2020-08-21  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - fix maildir flag generation\n  - fix query notmuch if file is missing\n  - notmuch: don't abort sync on error\n  - fix type checking for send config variables\n* Changed Config\n  - `$sidebar_format` - Use `%D` rather than `%B` for named mailboxes\n* Translations\n  - 96% Lithuanian\n  - 90% Polish\n\n2020-08-14  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - Add mitigation against DoS from thousands of parts\n* Features\n  - Allow index-style searching in postpone menu\n  - Open NeoMutt using a mailbox name\n  - Add `cd` command to change the current working directory\n  - Add tab-completion menu for patterns\n  - Allow renaming existing mailboxes\n  - Check for missing attachments in alternative parts\n  - Add one-liner docs to config items\n* Bug Fixes\n  - Fix logic in checking an empty From address\n  - Fix Imap crash in `cmd_parse_expunge()`\n  - Fix setting attributes with S-Lang\n  - Fix: redrawing of `$pager_index_lines`\n  - Fix progress percentage for syncing large mboxes\n  - Fix sidebar drawing in presence of indentation + named mailboxes\n  - Fix retrieval of drafts when `$postponed` is not in the mailboxes list\n  - Do not add comments to address group terminators\n  - Fix alias sorting for degenerate addresses\n  - Fix attaching emails\n  - Create directories for nonexistent file hcache case\n  - Avoid creating mailboxes for failed subscribes\n  - Fix crash if rejecting cert\n* Changed Config\n  - Add `$copy_decode_weed`, `$pipe_decode_weed`, `$print_decode_weed`\n  - Change default of `$crypt_protected_headers_subject` to \"...\"\n  - Add default keybindings to history-up/down\n* Translations\n  - 100% Czech\n  - 100% Spanish\n* Build\n  - Allow building against Lua 5.4\n  - Fix when `sqlite3.h` is missing\n* Docs\n  - Add a brief section on stty to the manual\n  - Update section \"Terminal Keybindings\" in the manual\n  - Clarify PGP Pseudo-header `S<id>` duration\n* Code\n  - Clean up String API\n  - Make the Sidebar more independent\n  - De-centralise the Config Variables\n  - Refactor dialogs\n  - Refactor: Help Bar generation\n  - Make more APIs Context-free\n  - Adjust the edata use in Maildir and Notmuch\n  - Window refactoring\n  - Convert libsend to use Config functions\n  - Refactor notifications to reduce noise\n  - Convert Keymaps to use STAILQ\n  - Track currently selected email by msgid\n  - Config: no backing global variable\n  - Add events for key binding\n* Upstream\n  - Fix imap postponed mailbox use-after-free error\n  - Speed up thread sort when many long threads exist\n  - Fix ~v tagging when switching to non-threaded sorting\n  - Add message/global to the list of known \"message\" types\n  - Print progress meter when copying/saving tagged messages\n  - Remove ansi formatting from autoview generated quoted replies\n  - Change postpone mode to write Date header too\n  - Unstuff `format=flowed`\n\n2020-08-07  Richard Russon  \\<rich@flatcap.org\\>\n* Devel Release - see 2020-08-14\n\n2020-06-26  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Avoid opening the same hcache file twice\n  - Re-open Mailbox after `folder-hook`\n  - Fix the matching of the `$spool_file` Mailbox\n  - Fix link-thread to link all tagged emails\n* Changed Config\n  - Add `$tunnel_is_secure` config, defaulting to true\n* Upstream\n  - Don't check IMAP PREAUTH encryption if `$tunnel` is in use\n  - Add recommendation to use `$ssl_force_tls`\n\n2020-06-19  Richard Russon  \\<rich@flatcap.org\\>\n* Security\n  - Abort GnuTLS certificate check if a cert in the chain is rejected\n  - TLS: clear data after a starttls acknowledgement\n  - Prevent possible IMAP MITM via PREAUTH response\n* Features\n  - add config operations `+=`/`-=` for number,long\n  - Address book has a comment field\n  - Query menu has a comment field\n* Contrib\n  - sample.neomuttrc-starter: Do not echo prompted password\n* Bug Fixes\n  - make \"news://\" and \"nntp://\" schemes interchangeable\n  - Fix CRLF to LF conversion in base64 decoding\n  - Double comma in query\n  - compose: fix redraw after history\n  - Crash inside empty query menu\n  - mmdf: fix creating new mailbox\n  - mh: fix creating new mailbox\n  - mbox: error out when an mbox/mmdf is a pipe\n  - Fix `<list-reply>` by correct parsing of List-Post headers\n  - Decode references according to RFC2047\n  - fix tagged message count\n  - hcache: fix keylen not being considered when building the full key\n  - sidebar: fix path comparison\n  - Don't mess with the original pattern when running IMAP searches\n  - Handle IMAP \"NO\" resps by issuing a msg instead of failing badly\n  - imap: use the connection delimiter if provided\n  - Memory leaks\n* Changed Config\n  - `$alias_format` default changed to include `%c` comment\n  - `$query_format` default changed to include `%e` extra info\n* Translations\n  - 100% Lithuanian\n  - 84% French\n  - Log the translation in use\n* Docs\n  - Add missing commands unbind, unmacro to man pages\n* Build\n  - Check size of long using `LONG_MAX` instead of `__WORDSIZE`\n  - Allow ./configure to not record cflags\n  - fix out-of-tree build\n  - Avoid locating gdbm symbols in qdbm library\n* Code\n  - Refactor unsafe TAILQ returns\n  - add window notifications\n  - flip negative ifs\n  - Update to latest `acutest.h`\n  - test: add store tests\n  - test: add compression tests\n  - graphviz: email\n  - make more opcode info available\n  - refactor: `main_change_folder()`\n  - refactor: `mutt_mailbox_next()`\n  - refactor: `generate_body()`\n  - compress: add `{min,max}_level` to ComprOps\n  - emphasise empty loops: \"// do nothing\"\n  - prex: convert `is_from()` to use regex\n  - Refactor IMAP's search routines\n\n2020-05-01  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Make sure buffers are initialized on error\n  - fix(sidebar): use abbreviated path if possible\n* Translations\n  - 100% Lithuanian\n* Docs\n  - make header cache config more explicit\n\n2020-04-24  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Fix history corruption\n  - Handle pretty much anything in a URL query part\n  - Correctly parse escaped characters in header phrases\n  - Fix crash reading received header\n  - Fix sidebar indentation\n  - Avoid crashing on failure to parse an IMAP mailbox\n  - Maildir: handle deleted emails correctly\n  - Ensure OP_NULL is always first\n* Translations\n  - 100% Czech\n* Build\n  - cirrus: enable pcre2, make pkgconf a special case\n  - Fix finding pcre2 w/o pkgconf\n  - build: `tdb.h` needs size_t, bring it in with `stddef.h`\n\n2020-04-17  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Fluid layout for Compose Screen, see: https://vimeo.com/407231157\n  - Trivial Database (TDB) header cache backend\n  - RocksDB header cache backend\n  - Add `<sidebar-first>` and `<sidebar-last>` functions\n* Bug Fixes\n  - add error for CLI empty emails\n  - Allow spaces and square brackets in paths\n  - browser: fix hidden mailboxes\n  - fix initial email display\n  - notmuch: fix time window search.\n  - fix resize bugs\n  - notmuch: fix `<entire-thread>`: update current email pointer\n  - sidebar: support indenting and shortening of names\n  - Handle variables inside backticks in `sidebar_pin`\n  - browser: fix mask regex error reporting\n* Translations\n  - 100% Lithuanian\n  - 99% Chinese (simplified)\n* Build\n  - Use regexes for common parsing tasks: urls, dates\n  - Add configure option `--pcre2` -- Enable PCRE2 regular expressions\n  - Add configure option `--tdb` -- Use TDB for the header cache\n  - Add configure option `--rocksdb` -- Use RocksDB for the header cache\n  - Create libstore (key/value backends)\n  - Update to latest autosetup\n  - Update to latest `acutest.h`\n  - Rename `doc/` directory to `docs/`\n  - make: fix location of .Po dependency files\n  - Change libcompress to be more universal\n  - Fix test fails on х32\n  - fix uidvalidity to unsigned 32-bit int\n* Code\n  - Increase test coverage\n  - Fix memory leaks\n  - Fix null checks\n* Upstream\n  - Buffer refactoring\n  - Fix use-after-free in `mutt_str_replace()`\n  - Clarify PGP Pseudo-header `S<id>` duration\n  - Try to respect MUTT_QUIET for IMAP contexts too\n  - Limit recurse depth when parsing mime messages\n\n2020-03-20  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Fix COLUMNS env var\n  - Fix sync after delete\n  - Fix crash in notmuch\n  - Fix sidebar indent\n  - Fix emptying trash\n  - Fix command line sending\n  - Fix reading large address lists\n  - Resolve symlinks only when necessary\n* Translations\n  - 100% Lithuanian\n  - 96% Spanish\n* Docs\n  - Include OpenSSL/LibreSSL/GnuTLS version in neomutt -v output\n  - Fix case of GPGME and SQLite\n* Build\n  - Create libcompress (lz4, zlib, zstd)\n  - Create libhistory\n  - Create libbcache\n  - Move zstrm to libconn\n* Code\n  - Add more test coverage\n  - Rename magic to type\n  - Use `mutt_file_fopen()` on config variables\n  - Change commands to use intptr_t for data\n\n2020-03-13  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - UI: add number of old messages to `$sidebar_format`\n  - UI: support ISO 8601 calendar date\n  - UI: fix commands that don’t need to have a non-empty mailbox to be valid\n  - PGP: inform about successful decryption of inline PGP messages\n  - PGP: try to infer the signing key from the From address\n  - PGP: enable GPGME by default\n  - Notmuch: use query as name for `<vfolder-from-query>`\n  - IMAP: add network traffic compression (COMPRESS=DEFLATE, RFC4978)\n  - Header cache: add support for generic header cache compression\n* Bug Fixes\n  - Fix `$uncollapse_jump`\n  - Only try to perform `<entire-thread>` on maildir/mh mailboxes\n  - Fix crash in pager\n  - Avoid logging single new lines at the end of header fields\n  - Fix listing mailboxes\n  - Do not recurse a non-threaded message\n  - Fix initial window order\n  - Fix leaks on IMAP error paths\n  - Notmuch: compose(attach-message): support notmuch backend\n  - Fix IMAP flag comparison code\n  - Fix `$move` for IMAP mailboxes\n  - Maildir: `maildir_mbox_check_stats()` should only update mailbox stats if requested\n  - Fix unmailboxes for virtual mailboxes\n  - Maildir: sanitize filename before hashing\n  - OAuth: if 'login' name isn't available use 'user'\n  - Add error message on failed encryption\n  - Fix a bunch of crashes\n  - Force C locale for email date\n  - Abort if run without a terminal\n* Changed Config\n  - `$crypt_use_gpgme`                         - Now defaults to 'yes' (enabled)\n  - `$abort_backspace`                         - Hitting backspace against an empty prompt aborts the prompt\n  - `$abort_key`                               - String representation of key to abort prompts\n  - `$arrow_string`                            - Use a custom string for `$arrow_cursor`\n  - `$crypt_opportunistic_encrypt_strong_keys` - Enable encryption only when strong a key is available\n  - `$header_cache_compress_dictionary`        - Filepath to dictionary for zstd compression\n  - `$header_cache_compress_level`             - Level of compression for method\n  - `$header_cache_compress_method`            - Enable generic hcache database compression\n  - `$imap_deflate`                            - Compress network traffic\n  - `$smtp_user`                               - Username for the SMTP server\n* Translations\n  - 100% Lithuanian\n  - 81% Spanish\n  - 78% Russian\n* Build\n  - Add libdebug\n  - Rename public headers to `lib.h`\n  - Create libcompress for compressed folders code\n  - Enable Cirrus CI for FreeBSD\n* Code\n  - Refactor Windows and Dialogs\n  - Lots of code tidying\n  - Refactor: `mutt_addrlist_{search,write}()`\n  - Lots of improvements to the Config code\n  - Use Buffers more pervasively\n  - Unify API function naming\n  - Rename library shared headers\n  - Refactor libconn gui dependencies\n  - Refactor: init.[ch]\n  - Refactor config to use subsets\n  - Config: add path type\n  - Remove backend deps from the connection code\n* Upstream\n  - Allow ~b ~B ~h patterns in send2-hook\n  - Rename smime oppenc mode parameter to `get_keys_by_addr()`\n  - Add `$crypt_opportunistic_encrypt_strong_keys` config var\n  - Fix crash when polling a closed ssl connection\n  - Turn off auto-clear outside of autocrypt initialization\n  - Add protected-headers=\"v1\" to Content-Type when protecting headers\n  - Fix segv in IMAP postponed menu caused by reopen_allow\n  - Adding ISO 8601 calendar date\n  - Fix `$fcc_attach` to not prompt in batch mode\n  - Convert remaining `mutt_encode_path()` call to use struct Buffer\n  - Fix rendering of replacement_char when Charset_is_utf8\n  - Update to latest `acutest.h`\n\n2019-12-07  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - compose: draw status bar with highlights\n* Bug Fixes\n  - crash opening notmuch mailbox\n  - crash in `mutt_autocrypt_ui_recommendation()`\n  - Avoid negative allocation\n  - Mbox new mail\n  - Setting of DT_MAILBOX type variables from Lua\n  - imap: empty cmdbuf before connecting\n  - imap: select the mailbox on reconnect\n  - compose: fix attach message\n* Build\n  - make files conditional\n  - add gpgme check for RHEL6\n* Code\n  - enum-ify log levels\n  - fix function prototypes\n  - refactor virtual email lookups\n  - factor out global Context\n\n2019-11-29  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add raw mailsize expando (%cr)\n* Bug Fixes\n  - Avoid double question marks in bounce confirmation msg\n  - Fix bounce confirmation\n  - fix new-mail flags and behaviour\n  - fix: browser `<descend-directory>`\n  - fix ssl crash\n  - fix move to trash\n  - fix flickering\n  - Do not check hidden mailboxes for new mail\n  - Fix `$new_mail_command` notifications\n  - fix crash in `examine_mailboxes()`\n  - fix crash in `mutt_sort_threads()`\n  - fix: crash after sending\n  - Fix crash in tunnel's `conn_close()`\n  - fix fcc for deep dirs\n  - imap: fix crash when new mail arrives\n  - fix colour 'quoted9'\n  - quieten messages on exit\n  - fix: crash after failed `mbox_check()`\n  - browser: default to a file/dir view when attaching a file\n* Changed Config\n  - Change `$write_bcc` to default off\n* Translations\n  - 100% Portuguese (Brazil)\n  -  92% Polish\n* Docs\n  - Add a bit more documentation about sending\n  - Clarify `$write_bcc` documentation.\n  - Update documentation for raw size expando\n  - docbook: set generate.consistent.ids to make generated html reproducible\n* Build\n  - fix build/tests for 32-bit arches\n  - tests: fix test that would fail soon\n  - tests: fix context for failing idna tests\n\n2019-11-11  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - browser: fix directory view\n  - fix crash in `parse_extract_token()`\n  - force a screen refresh\n  - fix crash sending message from command line\n  - notmuch: use `$nm_default_url` if no mailbox data\n  - fix forward attachments\n  - fix: vfprintf undefined behaviour in `body_handler()`\n  - Fix relative symlink resolution\n  - fix: trash to non-existent file/dir\n  - fix re-opening of mbox Mailboxes\n  - close logging as late as possible\n  - log unknown mailboxes\n  - fix crash in command line postpone\n  - fix memory leaks\n  - fix icommand parsing\n  - fix new mail interaction with `$mail_check_recent`\n\n2019-11-02  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Mailboxes command with empty backticks\n  - Mbox save-to-trash\n  - Mkdir for new maildir folders\n  - Maildir: new mail detection\n  - Truncation of \"set\" command on a path variable\n  - Update crash (when changing folder)\n  - Resolve symbolic links when saving a message\n  - Folder-hook calling `unmailboxes *`\n  - Failed ssl negotiation\n  - Crash when using \"alias -group\"\n  - LibIDN error when `$charset` wasn't set\n  - Notmuch abort `<entire-thread>` if database lacks message\n\n2019-10-25  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add `$fcc_before_send`, defaulting unset\n  - Deprecate TLS 1.0 and 1.1 by default\n  - Turn on `$ssl_force_tls` by default\n  - Command line -z and -Z options to work with IMAP\n  - Add size display configuration variables\n  - Summary pages: version, set, set all, bind, macro\n  - CONDSTORE and QRESYNC support\n  - OAUTHBEARER support\n  - inotify support\n  - add index-format-hook\n  - Add `$auto_subscribe` variable\n  - Allow relative date hour/min/sec offsets\n  - Add attributes support on color declarations\n  - Style Menu Options\n  - Add new pattern type ~I for external searches\n  - Add `<named-mailboxes>` command\n* Changed Config\n  - `$folder_format`\n  - `$pgp_use_gpg_agent`\n  - `$shell`\n  - `$ssl_force_tls`\n  - `$ssl_use_tlsv1`\n  - `$ssl_use_tlsv1_1`\n  - `$status_format`\n  - `$to_chars`\n  - `$user_agent`\n* New Config\n  - `$attach_save_dir`\n  - `$attach_save_without_prompting`\n  - `$autocrypt`\n  - `$autocrypt_acct_format`\n  - `$autocrypt_dir`\n  - `$autocrypt_reply`\n  - `$auto_subscribe`\n  - `$crypt_chars`\n  - `$crypt_protected_headers_read`\n  - `$crypt_protected_headers_save`\n  - `$crypt_protected_headers_subject`\n  - `$crypt_protected_headers_write`\n  - `$external_search_command`\n  - `$fcc_before_send`\n  - `$forward_attachments`\n  - `$imap_condstore`\n  - `$imap_fetch_chunk_size`\n  - `$imap_oauth_refresh_command`\n  - `$imap_qresync`\n  - `$imap_rfc5161`\n  - `$include_encrypted`\n  - `$nm_flagged_tag`\n  - `$nm_replied_tag`\n  - `$pop_oauth_refresh_command`\n  - `$sidebar_non_empty_mailbox_only`\n  - `$size_show_bytes`\n  - `$size_show_fractions`\n  - `$size_show_mb`\n  - `$size_units_on_left`\n  - `$smtp_oauth_refresh_command`\n  - `$ssl_use_tlsv1_3`\n* New Commands\n  - `:index-format-hook`\n  - `:named-mailboxes`\n  - `:unbind`\n  - `:unmacro`\n* New Functions\n  - `<autocrypt-acct-menu>`\n  - `<autocrypt-menu>`\n  - `<compose-to-sender>`\n  - `<create-account>`\n  - `<delete-account>`\n  - `<descend-directory>`\n  - `<group-chat-reply>`\n  - `<mailbox-cycle>`\n  - `<mailbox-list>`\n  - `<toggle-active>`\n  - `<toggle-prefer-encrypt>`\n  - `<toggle-write>`\n  - `<vfolder-from-query-readonly>`\n* Bug Fixes\n  - Fix crashes\n  - Fix memory leaks\n  - Fix undefined behaviour\n  - Fix coverity defects\n* Translations\n  - 100% Lithuanian\n  - 100% Chinese (Simplified)\n  - 100% Portuguese (Brazil)\n  - 95% German\n  - 95% Finnish\n  - 95% Czech\n  - 91% Polish\n  - 78% Japanese\n  - 73% Dutch\n  - 72% Spanish\n  - 62% Swedish\n  - 55% Slovak\n* Docs\n  - OpenPGP and S/MIME configuration\n  - Quick-starter config section\n  - Autocrypt feature\n  - \"Message Composition Flow\" section to manual\n  - OAUTH support\n\n2018-07-16  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - `<check-stats>` function\n* Bug Fixes\n  - Lots\n\n2018-06-22  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Expand variables inside backticks\n  - Honour SASL-IR IMAP capability in SASL PLAIN\n* Bug Fixes\n  - Fix `<toggle-read>`\n  - Do not truncate shell commands on ; or #\n  - pager: index must be rebuilt on MUTT_REOPENED\n  - Handle a BAD response in AUTH PLAIN w/o initial response\n  - fcc_attach: Don't ask every time\n  - Enlarge path buffers PATH_MAX (4096)\n  - Move LSUB call from connection establishment to mailbox SELECTion\n* Translations\n  - Update Chinese (Simplified): 100%\n  - Update Czech: 100%\n  - Update German: 100%\n  - Update Lithuanian: 100%\n  - Update Portuguese (Brazil): 100%\n  - Update Slovak: 59%\n  - Reduce duplication of messages\n* Code\n  - Tidy up the mailbox API\n  - Tidy up the header cache API\n  - Tidy up the encryption API\n  - Add doxygen docs for more functions\n  - Refactor more structs to use STAILQ\n\n2018-05-12  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - echo command\n  - Add `$browser_abbreviate_mailboxes`\n  - Add ~M pattern to match mime Content-Types\n  - Add support for multipart/multilingual emails\n  - Jump to a collapsed email\n  - Add support for idn2 (IDNA2008)\n* Bug Fixes\n  - Let `mutt_ch_choose()` report conversion failure\n  - minor IMAP string handling fixes\n* Translations\n  - Chinese (Simplified) (100%)\n  - Czech (100%)\n  - German (100%)\n  - Lithuanian (62%)\n  - Portuguese (Brazil) (100%)\n* Coverity defects\n  - match prototypes to their functions\n  - make logic clearer\n  - reduce scope of variables\n  - fix coverity defects\n* Docs\n  - development: analysis\n  - development: easy tasks\n  - development: roadmap\n* Code\n  - start refactoring libconn\n  - split out progress functions\n  - split out window functions\n  - split out terminal setting\n  - convert MyVars to use TAILQ\n  - split `mutt_file_{lock,unlock}()`\n  - Move IDN version string to `mutt/idna.c`\n  - refactor: `init_locale()`\n  - Eliminate static variable in `mutt_file_dirname()`\n* Tidy\n  - test int functions against 0\n  - rename lots of constants\n  - rename lots of functions\n  - sort lots of fields/definitions\n* Upstream\n  - Increase account.user/login size to 128\n  - Fix comparison of flags with multiple bits set\n  - Change `mutt_error()` call in `mutt_gpgme_set_sender()` to dprint\n  - Improve the error message when a signature is missing\n  - pager specific \"show incoming mailboxes list\" macro\n  - Improve gss debug printing of status_string\n  - Remove trailing null count from gss_buffer_desc.length field\n  - Add a comment in auth_gss about RFCs and null-termination\n  - Change prompt string for `$crypt_verify_sig`\n\n2018-03-23  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - unify logging/messaging\n  - add alert (blink) colors\n* Contrib\n  - Vim syntax for NeoMutt log files\n* Bug Fixes\n  - Fix progress bar range\n  - notmuch: stop if db open fails\n  - Improve index color cache flushing behavior\n  - lua: fix crash when setting a string\n* Translations\n  - Update Czech translation (100%)\n  - Update German translation (100%)\n  - Update Polish translation (94%)\n  - Update Portuguese (BR) translation (100%)\n  - Update Spanish translation (64%)\n  - Update Turkish translation (75%)\n  - Merge similar messages\n* Docs\n  - Clarify precedence of settings in config files\n  - Fix subjectrx example in the manual\n* Website\n  - Update Gentoo distro page\n  - Devel: Static analysis\n* Build\n  - Support —with-sysroot configure arg\n  - Expose EXTRA_CFLAGS_FOR_BUILD and EXTRA_LDFLAGS_FOR_BUIlD\n  - Update to latest autosetup\n  - Make sure `git_ver.h` doesn't eat random 'g's out of tag names\n* Code\n  - Refactor to reduce complexity\n  - Refactor to reduce variables' scope\n  - Sort functions/config to make docs more legible\n\n2018-02-23  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - browser: `<goto-parent>` function bound to \"p\"\n  - editor: `<history-search>` function bound to \"Ctrl-r\"\n  - Cygwin support: https://neomutt.org/distro/cygwin\n  - openSUSE support: https://neomutt.org/distro/suse\n  - Upstream Homebrew support: Very soon - https://neomutt.org/distro/homebrew\n* Bug Fixes\n  - gmail server-size search\n  - nested-if: correctly handle \"\\<\" and \"\\>\" with %?\n  - display of special chars\n  - lua: enable myvars\n  - for pgpewrap in default gpg.rc\n  - `$reply_regexp` which wasn't formatted correctly.\n  - parsing of urls containing '?'\n  - out-of-bounds read in `mutt_str_lws_len()`\n* Translations\n  - Review fuzzy lt translations\n  - Updated French translation\n* Website\n  - Installation guide for Cygwin\n  - Installation guide for openSUSE\n  - Installation guide for CRUX\n* Build\n  - check that DTDs are installed\n  - autosetup improvements\n  - option for which version of bdb to use\n  - drop test for resizeterm -- it's always present\n* Code\n  - split if's containing assignments\n  - doxygen: add/improve comments\n  - rename functions / parameters for consistency\n  - add missing {}s for clarity\n  - move functions to library\n  - reduce scope of variables\n  - boolify more variables\n  - iwyu: remove unnecessary headers\n  - name unicode chars\n  - tailq: migrate parameter api\n  - md5: refactor and tidy\n  - rfc2047: refactor and tidy\n  - buffer: improvements\n  - create unit test framework\n  - fix several coverity defects\n* Upstream\n  - Fix s/mime certificate deletion bug\n  - Disable message security if the backend is not available\n  - Fix improper signed int conversion of IMAP uid and msn values\n  - Change imap literal counts to parse and store unsigned ints\n  - Fix imap status count range check\n  - `cmd_handle_fatal()`: make error message a bit more descriptive\n  - Create pgp and s/mime default and sign_as key vars\n  - Add missing setup calls when resuming encrypted drafts\n  - `mutt_pretty_size()`: show real number for small files\n  - `examine_directory()`: set directory/symlink size to zero\n  - Add `<history-search>` function, bound to ctrl-r\n  - Avoid a potential integer overflow if a Content-Length value is huge\n\n2017-12-15  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Fix some regressions in the previous release\n\n2017-12-08  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Enhance ifdef feature to support my_ vars\n  - Add `<edit-or-view-raw-message>`\n  - Remove vim syntax file from the main repo\n  - Support reading FQDN from mailname files\n* Bug Fixes\n  - Do not turn CRLF into LF when dealing with transfer-encoding=base64\n  - Cleanup \"SSL is unavailable\" error in mutt_conn_find\n  - Don't clear the macro buffer during startup\n  - Fixup smart `<modify-labels-then-hide>` for !tag case\n  - Add sleep after SMTP error\n  - Restore folder settings after `folder-hook`\n  - Fix segfault when pipe'ing a deleted message\n* Docs\n  - Display_filter escape sequence\n  - Correct spelling mistakes\n  - Add a sentence to `<quasi-delete>` docs\n  - Modify gpg.rc to accommodate GPG 2.1 changes\n* Build\n  - Fix build for RHEL6\n  - Define NCURSES_WIDECHAR to require wide-char support from ncurses\n  - Autosetup: fix check for missing sendmail\n  - Respect `--with-ssl` path\n  - Check that OpenSSL md5 supports -r before using it\n  - Autosetup: expand `--everything` in `neomutt -v`\n  - Make sure objects are not compiled before `git_ver.h` is generated\n  - Build: fix update-po target\n  - Fix out-of-tree builds\n  - Fix stdout + stderr redirection in `hcachever.sh`\n  - Build: moved the check for idn before the check for notmuch\n  - Define prefix in Makefile.autosetup\n  - Install stuff to $(PACKAGE) in $(libexecdir), not $(libdir)\n  - Update autosetup to latest master\n* Code\n  - Rename files\n  - Rename functions\n  - Rename variables\n  - Rename constants\n  - Remove unused parameters\n  - Document functions\n  - Rearrange functions\n  - Move functions to libraries\n  - Add new library functions\n  - Rearrange switch statements\n  - Boolification\n  - Drop #ifdef DEBUG\n  - Fix Coverity defects\n  - Insert braces\n  - Split ifs\n  - Fallthrough\n  - Fix shadow variable\n  - Replace mutt_debug with a macro\n  - Return early where possible\n* Upstream\n  - Note which ssl config vars are GnuTLS or OpenSSL only\n  - Add message count to `$move` quadoption prompt\n  - Add %R (number of read messages) for `$status_format`\n  - Add `$change_folder_next` option to control mailbox suggestion order\n  - Fix `$smart_wrap` to not be disabled by whitespace-prefixed lines\n  - Remove useless else branch in the `$smart_wrap` code\n  - Fix ansi escape sequences with both reset and color parameters\n\n2017-10-27  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - variable type when using fread\n  - prevent timezone overflow\n  - tags: Show fake header for all backends\n  - notmuch: virtual-mailboxes should accept a limit\n  - Issue 888: Fix imap mailbox flag logging\n  - fix actions on tagged messages\n  - call the `folder-hook` before saving to `$record`\n  - Fix smart wrap in pager without breaking header\n  - Add polling for the IDLE command\n* Docs\n  - imap/notmuch tags: Add some documentation\n  - English and other cleanups\n  - compressed and nntp features are now always built\n* Website\n  - Update Arch instructions\n* Build\n  - Fix update-po\n  - Fix neomutt.pot location, remove from git\n  - Allow to specify `--docdir` at configure time\n  - Generate neomuttrc even if configured with `--disable-doc`\n  - Let autosetup define PWD, do not unnecessarily try to create hcache dir\n  - Use bundled wcscasecmp if an implementation is not found in libc\n  - Use host compiler to build the documentation\n  - Update autosetup to latest master branch\n  - autosetup: delete makedoc on 'make clean'\n  - Fixes for endianness detection\n  - Update autosetup to latest master branch\n  - Do not use CPPFLAGS / CFLAGS together with CC_FOR_BUILD\n  - `--enable-everything` includes lua\n  - autosetup: check for sys_siglist[]\n* Code\n  - move functions to library\n  - lib: move MIN/MAX macros\n  - simplify null checks\n  - kill preproc expansion laziness\n  - reduce scope of variables\n  - merge: minor code cleanups\n  - split up 'if' statements that assign and test\n  - Refactor: Remove unused return type\n  - Bool: change functions in `mx.h`\n  - bool: convert function parameters in `nntp.h`\n  - add extra checks to `mutt_pattern_exec()`\n  - Use safe_calloc to initialize memory, simplify size_t overflow check\n  - Move `mutt_rename_file()` to lib/file.[hc]\n  - doxygen: fix a few warnings\n  - minor code fixes\n  - use `mutt_array_size()`\n  - refactor out O_NOFOLLOW\n  - initialise variables\n  - lib: move List and Queue into library\n  - url: make notmuch query string parser generic\n  - Wrap dirname(3) inside a `mutt_dirname()` function\n\n2017-10-13  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - crash using uncolor\n  - Sort the folders list when browsing an IMAP server\n  - Prefer a helpful error message over a BEEP\n* Build\n  - Do not fail if deflate is not in libz\n  - Support EXTRA_CFLAGS and EXTRA_LDFLAGS, kill unused variable\n\n2017-10-06  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add IMAP keywords support\n* Bug Fixes\n  - set mbox_type\n  - %{fmt} date format\n  - Fix off-by-one buffer overflow in add_index_color\n  - crash in `mbox_to_udomain()`\n  - crash in `mutt_substrdup()`\n  - crash looking up mime body type\n  - `$digest_collapse` was broken\n  - crash using notmuch expando with imap\n  - imap: Fix mx.mbox leak in `imap_get_parent_path()`\n  - overflow in `mutt_mktime()`\n  - add more range-checking on dates/times\n  - Remove spurious error message\n  - Unsubscribe after deleting an imap folder\n  - Do not pop from MuttrcStack what wasn't pushed\n* Docs\n  - replace mutt refs with neomutt\n  - drop old vim syntax file\n* Code\n  - convert functions to use 'bool'\n  - convert structs to use STAILQ\n* Build\n  - Autosetup-based configuration\n  - drop upstream mutt references\n  - rename everything 'mutt' to 'neomutt'\n  - move helper programs to lib dir\n  - rename regexp to regex\n  - expand buffers to avoid gcc7 warnings\n* Upstream\n  - Remove \\Seen flag setting for imap trash\n  - Change imap copy/save and trash to sync flags, excluding deleted\n  - Improve imap fetch handler to accept an initial UID\n  - Display an error message when delete mailbox fails\n  - Updated French translation\n  - Fix imap sync segfault due to inactive headers during an expunge\n  - Close the imap socket for the selected mailbox on error\n  - Add missing IMAP_CMD_POLL flag in imap mailbox check\n  - Change maildir and mh check_mailbox to use dynamic sized hash\n  - Fix uses of `context->changed` as a counter\n  - Make `cmd_parse_fetch()` more precise about setting reopen/check flags\n  - Enable `$reply_self` for `<group-reply,>` even with $me_too unset\n\n2017-09-12  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - broken check on resend message\n  - crash in `<vfolder-from-query>`\n* Build\n  - Be more formal about quoting in m4 macros\n  - fix warnings raised by gcc7\n  - notmuch: add support for the v5 API\n\n2017-09-07  Richard Russon  \\<rich@flatcap.org\\>\n* Contrib\n  - Add guix build support\n* Bug Fixes\n  - Only match real mailboxes when looking for new mail\n  - Fix the printing of ncurses version in -v output\n  - Bind editor `<delete>` to `<delete-char>`\n  - Fix overflowing colours\n  - Fix empty In-Reply-To generation\n  - Trim trailing slash from completed dirs\n  - Add guix-neomutt.scm\n  - Fix setting custom query_type in notmuch query\n* Website\n  - New technical documentation LINK\n  - Improve Gentoo distro page\n* Build\n  - Better curses identification\n  - Use the system's wchar_t support\n  - Use the system's md5 tool (or equivalent)\n  - Clean up configure.ac\n  - Teach gen-map-doc about the new opcode header\n* Source\n  - Rename functions (snake_case)\n  - Rename constants/defines (UPPER_CASE)\n  - Create library of shared functions\n  - Much tidying\n  - Rename globals to match user config\n  - Drop unnecessary functions/macros\n  - Use a standard list implementation\n  - Coverity fixes\n  - Use explicit NUL for string terminators\n  - Drop OPS\\* in favour of `opcodes.h`\n* Upstream\n  - Fix menu color calls to occur before positioning the cursor\n  - When guessing an attachment type, don't allow text/plain if there is a null character\n  - Add `$imap_poll_timeout` to allow mailbox polling to time out\n  - Handle error if REGCOMP in pager fails when resizing\n  - Change recvattach to allow nested encryption\n  - Fix attachment check_traditional and extract_keys operations\n  - Add edit-content-type helper and warning for decrypted attachments\n  - Add option to run command to query attachment mime type\n  - Add warning about using inline pgp with format=flowed\n\n2017-07-14  Richard Russon  \\<rich@flatcap.org\\>\n* Translations\n  - Update German translation\n* Docs\n  - compile-time output: use two lists\n  - doxygen: add config file\n  - doxygen: tidy existing comments\n* Build\n  - fix `hcachever.sh` script\n* Upstream\n  - Fix crash when `$postponed` is on another server.\n\n2017-07-07  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Support Gmail's X-GM-RAW server-side search\n  - Include pattern for broken threads\n  - Allow sourcing of multiple files\n* Contrib\n  - vombatidae colorscheme\n  - zenburn colorscheme\n  - black 256 solarized colorscheme\n  - neonwolf colorscheme\n  - Mutt logos\n* Bug Fixes\n  - flags: update the hdr message last\n  - gpgme S/MIME non-detached signature handling\n  - menu: the thread tree color\n  - Uses CurrentFolder to populate LastDir with IMAP\n  - stabilise sidebar sort order\n  - colour emails with a '+' in them\n  - the padding expando `%>`\n  - Do not set old flag if `$mark_old` is false\n  - maildir creation\n  - Decode CRLF line endings to LF when copying headers\n  - score address pattern do not match personal name\n  - open attachments in read-only mode\n  - Add Cc, In-Reply-To, and References to default mailto_allow\n  - Improve search for mime.types\n* Translations\n  - Update Chinese (Simplified) translation\n* Coverity defects\n  - dodgy buffers\n  - leaks in lua get/set options\n  - some resource leaks\n* Docs\n  - update credits\n  - limitations of new-mail %f expando\n  - escape \\<\\>'s in nested conditions\n  - add code of conduct\n  - fix ifdef examples\n  - update mailmap\n  - Update `<modify-labels-then-hide>`\n  - fix mailmap\n  - drop UPDATING files\n* Website\n  - Changes pages (diff)\n  - Update Arch distro page\n  - Update NixOS distro page\n  - Add new Exherbo distro page\n  - Update translation hi-score table\n  - Update code of conduct\n  - Update Newbies page\n  - Add page about Rebuilding the Documentation\n  - Add page of hard problems\n* Build\n  - remove unnecessary steps\n  - drop instdoc script\n  - move smime_keys into contrib\n  - fixes for Solaris\n  - don't delete non-existent files\n  - remove another reference to devel-notes.txt\n  - Handle native Solaris GSSAPI.\n  - drop configure options `--enable-exact-address`\n  - drop configure option `--with-exec-shell`\n  - drop configure option `--enable-nfs-fix`\n  - drop configure option `--disable-warnings`\n  - Completely remove dotlock\n  - More sophisticated check for BDB version + support for DB6 (non default)\n* Tidy\n  - drop VirtIncoming\n  - split `parse_mailboxes()` into `parse_unmailboxes()`\n  - tidy some mailbox code\n  - tidy the version strings\n* Upstream\n  - Add ~\\<() and ~\\>() immediate parent/children patterns\n  - Add L10N comments to the GNUTLS certificate prompt\n  - Add more description for the %S and %Z `$index_format` characters\n  - Add config vars for forwarded message attribution intro/trailer\n  - Block SIGWINCH during connect()\n  - Improve the L10N comment about Sign as\n  - Auto-pad translation for the GPGME key selection \"verify key\" headers\n  - Enable all header fields in the compose menu to be translated\n  - Force hard redraw after `$sendmail` instead of calling `mutt_endwin()`\n  - Make GPGME key selection behavior the same as classic-PGP\n  - Rename 'sign as' to 'Sign as'; makes compose menu more consistent\n  - Change the compose menu fields to be dynamically padded\n\n2017-06-09  Richard Russon  \\<rich@flatcap.org\\>\n* Contrib\n  - unbind mappings before overwriting in vim-keys\n* Bug Fixes\n  - latest coverity issues (#624)\n  - don't pass colour-codes to filters\n  - Don't set a colour unless it's been defined.\n  - crash if no from is set or founds\n  - ifdef command\n* Translations\n  - fix translations\n  - fix some remaining translation problems\n* Docs\n  - explain binding warnings\n  - don't document unsupported arches\n* Build\n  - fix make `git_ver.h`\n  - allow xsltproc and w3m calls to fail\n  - fix make dist\n* Upstream\n  - Add a `mutt_endwin()` before invoking `$sendmail`\n  - Restore setenv function\n  - Fix `<tag-prefix>` to not abort on `$timeout`\n  - Change `km_dokey()` to return -2 on a timeout/sigwinch\n  - Enable TEXTDOMAINDIR override to make translation testing easier\n  - Fix \"format string is not a string literal\" warnings\n\n2017-06-02  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Warn on bindkey aliasing\n  - Drop PATCHES, tidy 'mutt -v' output\n  - Add %z format strings to `$index_format`\n  - Add `$debug_level`/`$debug_file` options\n* Bug Fixes\n  - Fix nntp group selection\n  - Fix status color\n  - Tidy up S/MIME contrib\n  - Do not try to create Maildir if it is an NNTP URL\n  - Fix missing NONULL for `mutt.set()` in Lua\n* Translations\n  - Fix German PGP shortkeys\n* Docs\n  - Remove feature muttrc files\n  - Merge README.notmuch into manual\n  - Remove unneeded scripts\n  - Remove README.SECURITY\n  - Remove BEWARE and devel-notes.txt\n  - Update Makefiles\n  - Delete TODO files\n  - Remove legacy files\n  - Don't generate vim-neomutt syntax file\n  - Remove LaTeX/pdf manual generation\n  - Add missing docs for expandos\n  - Fix sidebar howto examples\n  - Remove some upstream references\n  - Drop refs to patches\n  - Improve PR template and CONTRIBUTING.md\n* Website\n  - Fix list items in newbie-tutorial's Mailing List Guidelines\n  - Remove configure options that no longer exist\n  - fix newbie tutorial\n  - document signing tags / releases\n  - config: drop unused paginate command\n  - script: split tests up into several\n  - convert credits page to markdown\n  - simplify 404 page\n  - improve newbie tutorial\n  - remove help.html and integrate its content elsewhere\n  - make: \"graphviz\" program is needed for generating diagram\n  - improve getting started guide // include legacy files\n  - dev: add list of architectures/operating systems\n  - numerous small fixes\n* Build\n  - Remove typedefs and rename ~130 structs\n  - Add separate hcache dir\n  - Move crypto files to ncrypt dir\n  - Split up `mutt.h`, `protos.h`\n  - Always build: sidebar, imap, pop, smtp, compressed, nntp\n  - Remove `--enable-mailtool` configure option\n  - Make dotlock optional\n  - Change gpgme requirement back to 1.1.0\n  - Remove `check_sec.sh`\n  - Fix safe_calloc args\n  - Remove unused macros\n  - Remove unused option: SmimeSignOpaqueCommand\n  - Move configure-generated files\n  - Update distcheck build flags\n  - Drop obsolete iconv check\n  - Unused prototypes - unsupported systems\n  - Drop many configure tests for things defined in POSIX:2001\n  - Kill useless `crypthash.h` file\n  - Run clang-format on the code\n  - Fail early if ncursesw cannot be found\n  - Add names prototype arguments\n  - Abbreviate pointer tests against NULL\n  - Initialise pointers to NULL\n  - Reduce the scope of for loop variables\n  - Coverity: fix defects\n* Upstream\n  - Convert all exec calls to use `mutt_envlist()`, remove setenv function\n  - Note that mbox-hooks are dependent on `$move`\n  - Refresh header color when updating label\n  - Remove glibc-specific `execvpe()` call in `sendlib.c`\n  - Add color commands for the compose menu headers and security status\n  - Fix sidebar count updates when closing mailbox\n  - Don't modify LastFolder/CurrentFolder upon aborting a change folder operation\n  - Change message modifying operations to additively set redraw flags\n  - Improve maildir and mh to report flag changes in `mx_check_mailbox()`\n  - Add `$header_color_partial` to allow partial coloring of headers\n  - Rename REDRAW_SIGWINCH to REDRAW_FLOW\n  - Create R_PAGER_FLOW config variable flag\n  - Turn IMAP_EXPUNGE_EXPECTED back off when syncing\n  - Add `$history_remove_dups` option to remove dups from history ring\n  - Also remove duplicates from the history file\n  - Don't filter new entries when compacting history save file\n  - Move the IMAP msn field to IMAP_HEADER_DATA\n  - Fix imap expunge to match msn and fix index\n  - Fix `cmd_parse_fetch()` to match against MSN\n  - Start fixing `imap_read_headers()` to account for MSN gaps\n  - Add msn_index and max_msn to find and check boundaries by MSN\n  - Properly adjust fetch ranges when handling new mail\n  - Small imap fetch fixes\n  - Don't abort header cache evaluation when there is a hole\n  - Fix mfc overflow check and uninitialized variable\n  - Fix potential segv if mx_open_mailbox is passed an empty string\n  - Don't clean up idata when closing an open-append mailbox\n  - Don't clean up msn idata when closing an open-append mailbox\n  - Fix memory leak when closing mailbox and using the sidebar\n  - Change imap body cache cleanup to use the uid_hash\n  - Convert classic s/mime to space delimit findKeys output\n  - Add self-encrypt options for PGP and S/MIME\n  - Change `$postpone_encrypt` to use self-encrypt variables first\n  - Automatic post-release commit for mutt-1.8.3\n  - Add note about message scoring and thread patterns\n\n2017-04-28  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Fix and simplify handling of GPGME in configure.ac (@gahr)\n* Docs\n  - Fix typo in README.neomutt (@l2dy)\n* Upstream\n  - Fix `km_error_key()` infinite loop and unget buffer pollution\n  - Fix error message when opening a mailbox with no read permission\n\n2017-04-21  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - add lua scripting\n  - add command-line batch mode\n  - index_format: add support of %K\n* Bug Fixes\n  - attachment/pager: Use mailcap for test/* except plain\n  - Fix `$uncollapse_new` in pager\n  - fix garbage in chdir prompt due to unescaped string\n  - Fix inbox-first functionality when using `mutt_pretty_mailbox()`\n  - add full neomutt version to log startup\n  - fix bug in uncolor for notmuch tag\n  - fix broken `$from_chars` behaviour\n* Coverity defects\n  - strfcpy\n  - add variable - function arg could be NULL/invalid\n  - add variable - failed function leads to invalid variable\n  - add variable - Context could become NULL\n  - add variable - alloc/strdup could return NULL\n  - add variable - route through code leads to invalid variable\n  - remove variable test\n  - test functions\n  - tidy switches\n  - unused variables\n  - refactor only\n  - check for buffer underruns\n  - fix leaks\n  - minor fixes\n  - bug: add missing break\n  - bug: don't pass large object by value\n  - fix: use correct buffer size\n  - shadow variables\n  - 0 -\\> NULL\n* Docs\n  - many minor updates\n  - sync translations\n  - delete trailing whitespace\n  - indent the docbook manual\n  - use w3m as default for generating UTF8 manual.txt\n* Website\n  - many minor updates\n  - fix broken links\n  - add to list of useful programs\n  - test automatic html checker\n  - remove trailing whitespace\n  - add irc description\n  - update issue labels (dev)\n  - new page: closed discussions\n  - new page: making neomutt (dev)\n* Build\n  - drop obsolete m4 scripts\n  - don't look for lua libs unless asked for\n  - lower the gettext requirement 0.18 -\\> 0.17\n  - add `keymap_alldefs.h` to BUILT_SOURCES\n  - fix make dist distcheck\n  - Remove -Iimap from CFLAGS and include `imap/imap.h` explicitly\n  - mx: fix conditional builds\n  - Make iconv mandatory (no more `--disable-iconv`)\n  - refactor: Split out BUFFER-handling functions\n* Tidy\n  - drop control characters from the source\n  - drop vim modelines\n  - delete trailing whitespace\n  - mark all local functions as static\n  - delete unused functions\n  - replace FOREVER with while (true)\n  - drop #if HAVE_CONFIG_H\n  - use #ifdef for potentially missing symbols\n  - remove #if 0 code blocks\n  - drop commented out source\n  - IMAP auth functions are stored by pointer cannot be static\n  - force OPS to be rebuilt after a reconfigure\n  - be specific about void functions\n  - expand a few more alloc macros\n  - add argument names to function prototypes\n  - drop local copy of regex code\n  - rearrange code to avoid forward declarations\n  - limit the scope of some functions\n  - give the compress functions a unique name\n  - use snake_case for function names\n  - add missing newlines to mutt_debug\n  - remove generated files from repo\n  - look for translations in all files\n  - fix arguments to printf-style functions\n  - license text\n  - unify include-guards\n  - tidy makefiles\n  - initialise pointers\n  - make strcmp-like functions clearer\n  - unify sizeof usage\n  - remove forward declarations\n  - remove ()s from return\n  - rename files hyphen to underscore\n  - remove unused macros\n  - use SEEK_SET, SEEK_CUR, SEEK_END\n  - remove constant code\n  - fix typos and grammar in the comments\n  - Switch to using an external gettext runtime\n  - apply clang-format to the source code\n  - boolify returns of 84 functions\n  - boolify lots of struct members\n  - boolify some function parameters\n* Upstream\n  - Add `$ssl_verify_partial_chains` option for OpenSSL\n  - Move the OpenSSL partial chain support check inside configure.ac\n  - Don't allow storing duplicate certs for OpenSSL interactive prompt\n  - Prevent skipped certs from showing a second time\n  - OpenSSL: Don't offer (a)ccept always choice for hostname mismatches\n  - Add SNI support for OpenSSL\n  - Add SNI support for GnuTLS\n  - Add shortcuts for IMAP and POP mailboxes in the file browser\n  - Change OpenSSL to use SHA-256 for cert comparison\n  - Fix conststrings type mismatches\n  - Pass envlist to filter children too\n  - Fix `envlist_set()` for the case that envlist is null\n  - Fix setenv overwriting to not truncate the envlist\n  - Fix `(un)sidebar_pin` to expand paths\n  - Fix `mutt_refresh()` pausing during macro events\n  - Add a menu stack to track current and past menus\n  - Change CurrentMenu to be controlled by the menu stack\n  - Set refresh when popping the menu stack\n  - Remove redraw parameter from crypt send_menus\n  - Don't full redraw the index when handling a command from the pager\n  - Filter other directional markers that corrupt the screen\n  - Remove the OPTFORCEREDRAW options\n  - Remove SidebarNeedsRedraw\n  - Change `reflow_windows()` to set full redraw\n  - Create R_MENU redraw option\n  - Remove refresh parameter from `mutt_enter_fname()`\n  - Remove redraw flag setting after `mutt_endwin()`\n  - Change `km_dokey()` to pass SigWinch on for the MENU_EDITOR\n  - Separate out the compose menu redrawing\n  - Separate out the index menu redrawing\n  - Prepare for pager redraw separation\n  - Separate out the pager menu redrawing\n  - Don't create query menu until after initial prompt\n  - Silence imap progress messages for `<pipe-message>`\n  - Ensure mutt stays in endwin during calls to `pipe_msg()`\n  - Fix memleak when attaching files\n  - Add `$ssl_verify_partial_chains` option for OpenSSL\n  - Move the OpenSSL partial chain support check inside configureac\n  - Don't allow storing duplicate certs for OpenSSL interactive prompt\n  - Prevent skipped certs from showing a second time\n  - OpenSSL: Don't offer (a)ccept always choice for hostname mismatches\n  - Add SNI support for OpenSSL\n  - Add SNI support for GnuTLS\n  - Add shortcuts for IMAP and POP mailboxes in the file browser\n  - Updated French translation\n  - Change OpenSSL to use SHA-256 for cert comparison\n  - Fix conststrings type mismatches\n  - Pass envlist to filter children too\n  - Fix `envlist_set()` for the case that envlist is null\n  - Fix setenv overwriting to not truncate the envlist\n  - Fix `mutt_refresh()` pausing during macro events\n  - Add a menu stack to track current and past menus\n  - Change CurrentMenu to be controlled by the menu stack\n  - Set refresh when popping the menu stack\n  - Remove redraw parameter from crypt send_menus\n  - Don't full redraw the index when handling a command from the pager\n  - Fix `(un)sidebar_pin` to expand paths\n  - Filter other directional markers that corrupt the screen\n  - Remove the OPTFORCEREDRAW options\n  - Remove SidebarNeedsRedraw\n  - Change `reflow_windows()` to set full redraw\n  - Create R_MENU redraw option\n  - Remove refresh parameter from `mutt_enter_fname()`\n  - Remove redraw flag setting after `mutt_endwin()`\n  - Change `km_dokey()` to pass SigWinch on for the MENU_EDITOR\n  - Separate out the compose menu redrawing\n  - Separate out the index menu redrawing\n  - Prepare for pager redraw separation\n  - Separate out the pager menu redrawing\n  - Don't create query menu until after initial prompt\n  - Silence imap progress messages for `<pipe-message>`\n  - Ensure mutt stays in endwin during calls to `pipe_msg()`\n  - Fix memleak when attaching files\n  - automatic post-release commit for mutt-181\n  - Added tag mutt-1-8-1-rel for changeset f44974c10990\n  - mutt-181 signed\n  - Add ifdefs around new mutt_resize_screen calls\n  - Add multiline and sigwinch handling to `mutt_multi_choice()`\n  - Set pager's REDRAW_SIGWINCH when reflowing windows\n  - Add multiline and sigwinch handling to mutt_yesorno\n  - Change the sort prompt to use (s)ort style prompts\n  - Handle the pager sort prompt inside the pager\n  - Fix GPG_TTY to be added to envlist\n  - automatic post-release commit for mutt-182\n\n2017-03-06  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Get the correct buffer size under fmemopen/torify (#441)\n  - Use static inlines to make gcc 4.2.1 happy\n  - getdnsdomainname: cancel getaddrinfo_a if needed\n  - imap: remove useless code (#434) (origin/master)\n  - Fixes missing semi-colon compilation issue (#433)\n* Docs\n  - github: added template for Pull Requests, issues and a CONTRIBUTION.md (#339)\n  - editorconfig: support for new files, fix whitespace (#439)\n  - add blocking fmemopen bug on debian to manual (#422)\n* Upstream\n  - Increase ACCOUNT.pass field size. (closes #3921)\n  - SSL: Fix memory leak in subject alternative name code. (closes #3920)\n  - Prevent segv if open-appending to an mbox fails. (closes #3918)\n  - Clear out extraneous errors before `SSL_connect()` (see #3916)\n\n2017-02-25  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add option `$show_multipart_alternative`\n  - notmuch: Allow to use untransformed tag for color\n  - Use getaddrinfo_a if possible (#420)\n* Bug Fixes\n  - handle sigint within socket operations (#411)\n  - Avoid browsing the remote `$spool_file` by setting MUTT_SELECT_MULTI attach\n  - notmuch: fix crash when completing tags (#395)\n  - Fixes missing failure return of notmuch msg open (#401)\n  - Fix latest Coverity issues (#387)\n  - Advance by the correct number of position even for unknown characters (#368)\n  - Release KyotoCabinet data with `kcfree()` (#384)\n  - 22 resource leaks\n* Translations\n  - Update translations\n  - Update the German translation (#397)\n* Docs\n  - fix typo in notmuch example\n  - remove duplicate \"default\" in the sidebar intro\n  - fix confusing description of notmuch operators (#371)\n  - correct spelling mistakes (#412)\n* Website\n  - link to clang-format config in main repo (#28)\n  - updated list of useful programs\n  - update/improve list of useful programs\n  - `$sidebar_format` has a single default value\n  - fix name of GNU Guix\n  - added guix distro\n  - added link to new afew maintainers\n  - add code of conduct\n  - add mutt-addressbook to useful\n  - remove unnecessary unicode non-breaking spaces\n  - github merging\n* Build\n  - Enable and run unit-tests on the feature/unit-test branch\n  - add notmuch to default, feature\n  - new dbs for mutt\n  - master is now the main branch\n  - streamline builds\n  - fix doc generator\n  - add a few includes (prelude to clang-format)\n  - `slcurses.h` defines its own bool type\n  - travis: use container build\n  - add clang-format file\n  - Remove ugly macros and casts from `crypt_gpgme.c`\n  - fix minor reflow issues in some comments\n  - editorconfig: use spaces to indent in *.[ch] files\n  - added comment-blocks for clang-format to ignore\n  - fix 80 column limit, align statements\n  - Remove `snprintf.c` from EXTRA_DIST (#406)\n  - Kill homebrew (v)snprintf implementations, as they are C99 (#402)\n  - Display charset + small refactoring\n  - Do not cast or check returns from safe_calloc (#396)\n  - refactor: create a generic base64 encode/decode\n  - debug: remove dprint in favor of mutt_debug (#375)\n  - Fix dubious use macro for `_()` / `gettext()` (#376)\n  - Use buf_init instead of memset\n  - Make the heap method and datatype a plain list\n  - Reverts making AliasFile into a list_t (#379)\n  - Turn mutt_new_* macros into inline functions\n  - Do not cast return values from malloc (or similar)\n* Upstream\n  - Simplify `mutt_label_complete()`\n  - Permit tab completion of pattern expressions with ~y (labels)\n  - Fix the `mutt_label_complete()` pos parameter\n  - Fix the x-label update code check location\n  - Improve the label completion hash table usage\n  - Adds label completion\n  - Add `hash_find_elem()` to get the hash element\n  - Minor fixes to the x-label patch from David\n  - Adds capability to edit x-labels inside mutt, and to sort by label\n  - Allow \"unsubjectrc *\" to remove all patterns\n  - Add subjectrx command to replace matching subjects with something else\n  - Abstract the SPAM_LIST as a generic REPLACE_LIST\n  - Improve Reply-to vs From comparison when replying\n  - Fix sidebar references to the \"new count\" to be \"unread\"\n  - Fix several alias hashtable issues\n  - Add casecmp and strdup_key flags to hash_create()\n  - Improve error handling in mbox magic detection\n  - Allow initial blank lines in local mailboxes\n  - Fix minor documentation issues\n  - Convert cmd_parse_search to use the uid hash\n  - Create a uid hash for imap\n  - Convert HASH to be indexable by unsigned int\n  - Fix imap server-side search to call `uid2msgno()` only once\n  - Add a pattern_cache_t to speed up a few repeated matches\n  - Canonicalize line endings for GPGME S/MIME encryption\n  - Fix build for bdb\n  - Create function to free header cache data\n  - Add Kyoto Cabinet support to the header cache\n  - Prevent null pointer exception for `h->ai_canonname`\n  - Show SHA1 fp in interactive cert check menu\n  - Fix potential cert memory leak in `check_certificate_by_digest()`\n  - Plug memory leak in weed-expired-certs code\n  - Filter expired local certs for OpenSSL verification\n  - Change \"allow_dups\" into a flag at hash creation\n\n2017-02-06  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Unicode 0x202F is a non-break space too (#358)\n  - improve readability of `find_subject()`\n  - Import hcache-lmdb fixes from upstream (#363)\n  - Rework the \"inbox-first\" implementation to make code self-explanatory (#356)\n  - If possible, only redraw after gpgme has invoked pinentry (#352)\n  - Remove two use-after free in global hooks (#353)\n  - Handle BAD as IMAP_AUTH_UNAVAIL (#351)\n  - Do not crash when closing a non-opened mailbox\n  - Import hcache benchmark\n  - fix: bug introduced by mkdir changes (#350)\n  - change pager to allow timehook-hook to fire\n* Docs\n  - Update documentation about `<modify-labels-then-hide>`\n\n2017-01-28  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Add option for missing subject replacement\n  - notmuch: Allow `<modify-labels>` to toggle labels\n  - Support for aborting mailbox loading\n  - Do a mailbox check after shell escape\n  - Support of relative paths sourcing and cyclic source detection\n  - Support of multiple config files as CLI arguments\n  - Extend the ~m pattern to allow relative ranges\n  - Implement SASL's PLAIN mechanism as a standalone authenticator\n  - Add support for sensitive config options\n  - Searching with a window over notmuch vfolders\n* Contrib\n  - fix vim syntax file for index-color commands\n  - add .editorconfig\n* Bug Fixes\n  - fix global hooks to not take a pattern\n  - Avoid breaking relative paths when avoiding cyclic checks on\n  - Fix sorting when using '/' as a namespace separator\n* Docs\n  - Added waffle badges to readme\n  - Describe the new message ranges\n  - add documentation for -DS command line switch\n  - fix typos in section on config locations\n  - remove reference to missing keybinding\n  - fix docbook validation\n* Build\n  - Start migrating to stdbool logic\n  - add recursive `mkdir()`\n  - reformat the source to mutt standards\n  - appease `check_sec.sh`\n\n2017-01-13  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Allow custom status flags in `$index_format`\n  - `$from_chars` highlights differences in authorship\n  - notmuch: make 'Folder' and 'Tags' respect (un)ignore\n  - notmuch: add \"virtual-unmailboxes\" command\n* Bug Fixes\n  - pick smarter default for `$sidebar_divider_char`\n  - status color breaks \"mutt -D\"\n  - Enable `<reconstruct-thread>` in the pager\n  - manually touch 'atime' when reading a mbox file\n  - allow `$to_chars` to contain Unicode characters\n  - increase the max lmdb database size\n  - restore limit current thread\n  - don't reset the alarm unless we set it\n  - some more places that may get NULL pointers\n  - rework initials to allow unicode characters\n* Translations\n  - Spanish translation\n  - German translation\n* Docs\n  - Improve whitespace and grammar on the NNTP feature page\n  - make `$to_chars` docs more legible\n  - de-tab the DocBook\n  - fix 301 redirects\n* Build\n  - New configure option `--enable-everything`\n  - add a constant for an aborted question\n  - enhance `mutt_to_base64()` (and callers)\n  - Fix configure.ac to require md5 if hcache is enabled\n  - Bail if a selected hcache backend cannot be found\n  - refactor mutt_matches_ignore\n  - fix hcache + make dist\n  - add unicode string helper function\n  - Re-indent configure.ac\n  - generate devel version suffix\n  - fix `check_sec.sh` warnings\n  - remove unnecessary #ifdef's\n  - add missing #ifdef for nntp\n  - ignore some configure temp files\n  - fix \"make dist\" target\n  - fix function prototypes\n  - fix coverity warnings\n  - notmuch: drop strndup, replace with mutt_substrdup\n* Upstream\n  - Fix failure with GPGME 1.8: do not steal the gpgme_ prefix.\n  - search muttrc file according to XDG Base Specification (closes #3207)\n  - Improve openssl interactive_check_cert. (closes #3899)\n  - Add mutt_array_size macro, change `interactive_check_cert()` to use it. (see #3899)\n  - Return to pager upon aborting a jump operation. (closes #3901)\n  - Change sidebar_spool_file coloring to be lower precedence.\n  - Move '@' pattern modifier documentation to the right section.\n  - Add setenv/unsetenv commands.\n  - Rework OpenSSL certificate verification to support alternative chains. (closes #3903)\n  - Add option to control whether threads uncollapse when new mail arrives.\n  - In the manual, replaced 2 para by example (similar to the first example).\n  - Create MbTable type for multibyte character arrays. (see #3024)\n  - Make `$to_chars` and `$status_chars` accept mulitibyte characters. (closes #3024)\n\n2016-11-26  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Upstream adoption of compress\n  - Multiple hcache backends and run-time selection\n  - `$forward_references` includes References: header on forwards\n  - Hooks: define hooks for startup and shutdown\n  - Add `$collapse_all` to close threads automatically\n* Bug Fixes\n  - Index in pager crash\n  - Tag with multiple labels\n  - Make sure gdbm's symbols are not resolved in QDBM's compatibility layer\n  - Fix crash when doing collapse_all on an empty folder\n  - Fix: crash when browsing empty dir\n  - Initialize imap_authenticate's return value to something meaningful\n* Translations\n  - Update German translation\n  - Update Slovak translation\n  - Update French translation\n  - Add English (British) translation\n  - Convert files to utf-8\n  - Mass tidy up of the translation messages\n* Docs\n  - new-mail bug is fixed\n  - add since date for features\n  - expand example command options for compress\n  - fix entries for `$beep` and `new-mail-command`\n  - add a version number to the generated vimrc\n  - fix links in README\n  - don't use smart quotes in manual examples\n  - `<escape>` and `\\e` means refers to both alt and escape key\n* Build\n  - Travis: test messages\n  - Add option to disable translation messages\n  - Split hcache code into per-backend files\n  - Doc/Makefile clean neomutt-syntax.vim\n  - Improve discovery for the Berkeley Database\n  - Fix nntp/notmuch conditionals\n  - Implement `mutt_strchrnul()`\n  - Rename vim-keybindings to vim-keys\n* Upstream\n  - `$attach_format`: add new %F placeholder\n  - Compose: add operation to rename an attachment\n  - Chain `%d->%F->%f` in the attachment menu\n  - Move mbox close-append logic inside `mbox_close_mailbox()`\n  - When `$flag_safe` is set, flagged messages cannot be deleted\n  - Adds the '@' pattern modifier to limit matches to known aliases\n  - Adds `<mark-message>` binding to create \"hotkeys\" for messages\n  - Updated requirement on the C compiler\n  - Fix `<mark-message>` translation and keybind menu\n  - More openssl1.1 fixes: remove uses of `X509->name` in debugging. (closes #3870)\n  - Don't close stderr when opening a tunnel. (closes #3726)\n  - Minor resource and error logic cleanup in tunnel_socket_open()\n  - Make sure that the output of X509_NAME_oneline is null-terminated\n\n2016-11-04  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - don't crash when the imap connection dies\n* Upstream\n  - Add `<root-message>` function to jump to root message in thread.\n  - Updated French translation.\n  - Prevent an integer overflow in `mutt_mktime()` (closes #3880)\n  - Fix pager segfault when lineInfo.chunks overflows. (closes #3888)\n  - Perform charset conversion on text attachments when piping. (closes #3773) (see #3886)\n  - Add a `--disable-doc` configuration option.\n  - Make ncurses and ncursesw header checking the same.\n  - Attempt to silence a clang range warning. (closes #3891)\n  - Fixed issue from changeset 4da647a80c55. (closes #3892)\n  - Define PATH_MAX, it's missing on the GNU Hurd. (closes #3815)\n\n2016-10-28  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - nntp: use safe_{fopen,fclose}\n  - nntp: fix resource leak\n  - forgotten-attachment: Ignore lines matching `$quote_regex`\n  - forgotten-attachment: Fix checking logic.\n  - forgotten-attachment: Update docs regarding `$quote_regex`\n  - notmuch: Add a fake \"Folder\" header to viewed emails\n  - sidebar: consider description when using pinning\n  - skip-quoted: skip to body\n* Bug Fixes\n  - sensible-browser/notmuch changing mailbox\n  - \"inbox\" sorting function\n  - overhaul the index/pager updates\n  - crash in hdrline\n  - remove stray line introduced by pager fix\n  - Possible fix for random pager crashes.\n* Docs\n  - use a more expressive coverity scan badge\n  - light tidying\n* Build\n  - replace the ugly `strfcpy()` macro with a function\n  - build: Look for tgetent in ncurses, fallback to tinfo only if not found\n  - build: fix a couple of build warnings\n  - travis: install doc dependencies\n  - build: fix install/dist/distcheck targets\n* Upstream\n  - Fix POP3 SASL authentication mechanism DIGEST-MD5. (closes #3862)\n  - Add a few explanatory comments to `pop_auth_sasl()`  (see #3862)\n  - Fix GPGME signature zero timestamp and locale awareness issues. (closes #3882)\n  - Handle presence of '--' delimiter in `$sendmail` (closes #3168)\n  - Allow IPv6 literal addresses in URLs. (closes #3681)\n  - Fix gpgme segfault in `create_recipient_set()`\n  - Use `mutt_strlen()` and `mutt_strncmp()` in `sidebar.c`\n  - Change sidebar to only match `$folder` prefix on a `$sidebar_divider_char.` (closes #3887)\n  - Actually fix gpgme segfault in `create_recipient_set()`\n\n2016-10-14  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - sidebar: Make sure INBOX appears first in the list.\n  - notmuch: Synchronise tags to flags\n* Bug Fixes\n  - updates when pager is open\n  - crash when neither `$spool_file`, `$folder` are set\n  - forgotten-attachment: fix empty regex expression\n  - status-color when `$pager_index_lines > 0`\n  - buffer underrun when no menu item is selected\n  - crash handling keywords/labels\n* Docs\n  - update notmuch references\n* Build\n  - update references to 1.7.1\n  - `strfcpy()` improvement\n* Upstream\n  - automatic post-release commit for mutt-1.7.1\n  - Mark IMAP fast-trash'ed messages as read before copying. (see #3860)\n  - Updated Czech translation.\n  - Preserve forwarded attachment names in d_filename.\n\n2016-10-03  Richard Russon  \\<rich@flatcap.org\\>\n* Build\n  - Fix install and dist targets\n\n2016-10-02  Richard Russon  \\<rich@flatcap.org\\>\n* Features\n  - Kyoto Cabinet header cache\n  - Compose to Sender\n  - Forgotten Attachment uses a regex\n  - Optimize LMDB's hcache backend\n  - Sensible-browser behaviour fixes\n* Bug Fixes\n  - Fixes repaint problem with `$pager_index_lines` #159\n  - Quasi-Delete: check there's a selection\n  - Bulletproof the pager\n  - Typo in the version string\n* Docs\n  - Add badges to README.neomutt\n  - Document the Kyoto cabinet hcache backend\n  - Fix the layout of the syntax file\n  - Make the license clear to github\n  - Fix the alignment in a 'nested-if' example\n  - Fix notmuch vim syntax file\n  - Added Mailinglist mailto links to \"Where is NeoMutt\" section\n  - Fix build of neomutt-syntax.vim\n  - Fixed typo of devel mailinglist name\n* Build\n  - Travis: install the kyoto-cabinet dev files\n  - Build source before docs\n  - Build fix for strndup / malloc\n  - Change gcc build options to prevent crashes\n* Upstream\n  - Ensure signatures exist when verifying multipart/signed emails (closes #3881)\n  - RFC2047-decode mailto url headers after RFC2822 parsing (closes #3879)\n  - RFC2047-decode mailto header values (closes #3879)\n  - Reset invalid parsed received dates to 0  (closes #3878)\n  - Clear pager position when toggling headers\n  - Don't abort the menu editor on sigwinch (closes #3875)\n  - Mark some gpgme pgp menu keybinding translations as fuzzy (closes #3874)\n  - Check for NULL mx_ops in mxc\n  - Use body color for gpgme output (closes #3872)\n  - Fix gpgme segfault when querying candidates with a '+' in the address (closes #3873)\n\n2016-09-16  Richard Russon  \\<rich@flatcap.org\\>\n* Bug Fixes\n  - Avoid segfault when listing mailboxes on startup\n    John Swinbank\n  - Fix buffer overrun in search for attach keyword\n    James McCoy\n  - Fix off-by-one in error message\n    Antonio Radici\n  - fix AC_INIT tarname parameter\n  - fix crash when exiting the pager\n  - fix another crash in the pager\n  - nntp: close message handles\n  - fix: make the pager more robust\n  - fix sidebar sort order\n  - fix notmuch tag completion\n* Docs\n  - doc: Removes bug entry in new-mail docs\n    Santiago Torres\n  - fix some translations in `crypt_gpgme.c`\n    Antonio Radici\n  - docs: mass tidy up\n* Upstream\n  - Fix sidebar documentation a bit\n  - Add sidebar_pin command\n  - Remove the $locale configuration variable\n  - Add `$attribution_locale` configuration variable\n  - Add missing include `<locale.h>` to `send.c` and `edit.c`\n  - Filter out zero width no-break space (U+FEFF)\n  - Update a confusing and obsolete comment\n  - Moves `mutt_copy_list()` to `muttlib.c`, where it belongs\n  - Redraw screen after an SSL cert prompt\n  - Preserve message-id and mft headers for recalled messages\n  - Fix openssl 1.1 compilation issues\n\n2016-09-10  Richard Russon  \\<rich@flatcap.org\\>\n* New Features\n  - Colouring Attachments with Regex\n    Guillaume Brogi\n  - PGP Encrypt to Self\n    Guillaume Brogi\n  - Sensible Browser\n    Pierre-Elliott Bécue\n  - Reply using X-Original-To: header\n    Pierre-Elliott Bécue\n  - Purge Thread\n    Darshit Shah\n  - Forgotten attachment\n    Darshit Shah\n  - Add `sidebar_ordinary` color\n* Bug Fixes\n  - align the nntp code with mutt\n    Fabian Groffen\n  - check for new mail while in pager when idle\n    Stefan Assmann\n  - Allow the user to interrupt slow IO operations\n    Antonio Radici\n  - keywords: check there are emails to tag\n  - fix duplicate saved messages\n  - flatten contrib/keybase dir to fix install\n  - restore the pager keymapping 'i' to exit\n  - proposed fix for clearing labels\n  - notmuch: sync `$vfolder_format` to `$folder_format`\n* Docs\n  - Update List of Features and Authors\n* Build\n  - fix configure check for fmemopen\n  - use fixed version strings\n* Upstream\n  - Increase date buffer size for `$folder_format`\n  - Disable ~X when message scoring\n  - Fix pgpring reporting of DSA and Elgamal key lengths\n  - Stub out `getdnsdomainname()` unless HAVE_GETADDRINFO\n  - Autoconf: always check for `getaddrinfo()`\n  - Add missing sidebar contrib sample files to dist tarball\n\n2016-08-27  Richard Russon  \\<rich@flatcap.org\\>\n* NeoMutt for Mutt 1.7.0\n* Build\n  - Disable fmemopen until bug is fixed\n* Contrib\n  - Keybase portability improvements\n    Joshua Jordi (JakkinStewart)\n\n2016-08-21  Richard Russon  \\<rich@flatcap.org\\>\n* Contrib\n  - Updates to Keybase Support\n    Joshua Jordi (JakkinStewart)\n* Bug Fixes\n  - Fix data-loss when appending a compressed file\n  - Don't paint invisible progress bars\n  - Revert to Mutt keybindings\n  - Don't de-tag emails after labelling them\n  - Don't whine if `getrandom()` fails\n    Adam Borowski (kilobyte)\n  - Fix display when 'from' field is invalid\n* Config\n  - Support for $XDG_CONFIG_HOME and $XDG_CONFIG_DIRS\n    Marco Hinz (mhinz)\n* Docs\n  - Fix DocBook validation\n  - Document Notmuch queries\n* Build\n  - More Autoconf improvements\n    Darshit Shah (darnir)\n  - Create Distribution Tarballs with autogen sources\n    Darshit Shah (darnir)\n\n2016-08-08  Richard Russon  \\<rich@flatcap.org\\>\n* New Features\n  - Timeout Hook - Run a command periodically\n  - Multiple fcc - Save multiple copies of outgoing mail\n* Contrib\n  - Keybase Integration\n    Joshua Jordi (JakkinStewart)\n* Devel\n  - Attached - Prevent missing attachments\n    Darshit Shah (darnir)\n  - Virtual Unmailboxes - Remove unwanted virtual mailboxes\n    Richard Russon (flatcap)\n* Bug Fixes\n  - Sidebar's inbox occasionally shows zero/wrong value\n  - Fix crash opening a second compressed mailbox\n* Config\n  - Look for /etc/neomuttrc and ~/.neomuttrc\n* Docs\n  - Fix broken links, typos\n  - Update project link\n  - Fix version string in the manual\n* Build\n  - Add option to disable fmemopen\n  - Install all the READMEs and contribs\n  - Big overhaul of the build\n    Darshit Shah (darnir)\n\n2016-07-23  Richard Russon  \\<rich@flatcap.org\\>\n* New Motto: \"Teaching an Old Dog New Tricks\"\n  - Thanks to Alok Singh\n* New Features\n  - New Mail Command - Execute a command on receipt of new mail\n  - vim-keys - Mutt config for vim users\n  - LMDB: In-memory header caching database\n  - SMIME Encrypt to Self - Secure storage of sensitive email\n* Bug Fixes\n  - rework `mutt_draw_statusline()`\n  - fix cursor position after sidebar redraw\n  - Add `$sidebar_format` flag '%n' to display 'N' on new mail.\n  - fix `$index_format` truncation problem\n  - Fix compiler warnings due to always true condition\n  - Change sidebar next/prev-new to look at `mailbox->new` too.\n  - Change the default for `$sidebar_format` to use %n.\n  - sidebar \"unsorted\" order to match Mailbox list order.\n  - Include ncurses tinfo library if found.\n  - Sidebar width problem\n  - sidebar crash for non-existent mailbox\n  - Temporary compatibility workaround\n  - Reset `mailbox->new` for the current mailbox in IMAP.\n  - `version.sh` regression\n  - crash when notmuch tries to read a message\n  - status line wrapping\n* Docs\n  - Mass tidy up of the docs\n  - Fix xml validation\n  - Add missing docs for new features\n* Travis\n  - New build system:\n    https://github.com/neomutt/travis-build\n    Now we have central control over what gets built\n\n2016-07-09  Richard Russon  \\<rich@flatcap.org\\>\n* Bug-fixes\n  - This release was a temporary measure\n\n2016-06-11  Richard Russon  \\<rich@flatcap.org\\>\n* Change in behaviour\n  - Temporarily disable `$sidebar_refresh_time`\n    Unfortunately, this was causing too many problems.\n    It will be fixed and re-enabled as soon as possible.\n* Bug Fixes\n  - Fix several crashes, on startup, in Keywords\n  - Reflow text now works as it should\n  - Lots of typos fixed\n  - Compress config bug prevented it working\n  - Some minor bug-fixes from mutt/default\n  - Single quote at line beginning misinterpreted by groff\n  - Setting `$sidebar_width` to more than 128 would cause bad things to happen.\n  - Fix alignment in the compose menu.\n  - Fix sidebar mailbox stats updating on mailbox close.\n* Build Changes\n  - Sync whitespace to mutt/default\n  - Alter ChangeLog date format to simplify Makefiles\n  - Use the new notmuch functions that return a status\n  - Rename sidebar functions `sb_*` -\\> `mutt_sb_*`\n\n2016-05-23  Richard Russon  \\<rich@flatcap.org\\>\n* New Features:\n  - Keywords: Email Label/Keywords/Tagging\n  - Compress: Compressed mailboxes support\n  - NNTP: Talk to a usenet news server\n  - Separate mappings for `<enter>` and `<return>`\n  - New configure option: `--enable-quick-build`\n  - Various build fixes\n\n2016-05-02  Richard Russon  \\<rich@flatcap.org\\>\n* Update for Mutt-1.6.0\n* Bug Fixes:\n  - Build for Notmuch works if Sidebar is disabled\n  - Sidebar functions work even if the Sidebar is hidden\n  - `<sidebar-next-new>`, etc, only find *new* mail, as documented\n  - Notmuch supports *very* long queries\n\n2016-04-16  Richard Russon  \\<rich@flatcap.org\\>\n* Big Bugfix Release\n* Bug Fixes:\n  - Fix crash caused by `$sidebar_folder_indent`\n  - Allow the user to change mailboxes again\n  - Correct sidebar's messages counts\n  - Only sort the sidebar if we're asked to\n  - Fix refresh of pager when toggling the sidebar\n  - Compose mode: make messages respect the TITLE_FMT\n  - Conditional include if `sys/syscall.h`\n  - Build fix for old compilers\n  - Try harder to keep track of the open mailbox\n* Changes to Features\n  - Allow `$sidebar_divider_char` to be longer\n    (it was limited to one character)\n  - Ignore case when sorting the sidebar alphabetically\n* Other Changes\n  - Numerous small tweaks to the docs\n  - Lots of minor code tidy-ups\n  - Enabling Notmuch now forcibly enables Sidebar\n    (it is dependent on it, for now)\n  - A couple of bug fixes from mutt/stable\n\n2016-04-04  Richard Russon  \\<rich@flatcap.org\\>\n* Update for Mutt-1.6.0\n* No other changes in this release\n\n2016-03-28  Richard Russon  \\<rich@flatcap.org\\>\n* New Features\n  - `<skip-quoted>`          - skip quoted text\n  - `<limit-current-thread>` - limit index view to current thread\n* Sidebar Intro - A Gentle Introduction to the Sidebar (with pictures).\n\n2016-03-20  Richard Russon  \\<rich@flatcap.org\\>\n* Numerous small bugfixes\n* TravisCI integration\n\n2016-03-17  Richard Russon  \\<rich@flatcap.org\\>\n* New Features\n  - notmuch - email search support\n  - ifdef   - improvements\n\n2016-03-07  Richard Russon  \\<rich@flatcap.org\\>\n* First NeoMutt release\n* List of Features:\n  - bug-fixes    - various bug fixes\n  - cond-date    - use rules to choose date format\n  - fmemopen     - use memory buffers instead of files\n  - ifdef        - conditional config options\n  - index-color  - theme the email index\n  - initials     - expando for author's initials\n  - nested-if    - allow deeply nested conditions\n  - progress     - show a visual progress bar\n  - quasi-delete - mark emails to be hidden\n  - sidebar      - overview of mailboxes\n  - status-color - theming the status bar\n  - tls-sni      - negotiate for a certificate\n  - trash        - move 'deleted' emails to a trash bin\n\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 6.4853515625,
          "content": "# Installing NeoMutt\n\nNeoMutt is a command line email client (Mail User Agent).\nIt's fast, powerful and flexible.\n\nThe simplest way to obtain NeoMutt is to use your OS's package.\nSee the [distro page](https://neomutt.org/distro.html) to see if there's one for you.\n\n## Obtaining the Source\n\nThe source can be downloaded from our project site on GitHub.\nIt's available as a git repository or a 'tar.gz' archive.\n\n### Git\n\nClone the NeoMutt repository:\n\n```\ngit clone https://github.com/neomutt/neomutt\n```\n\nIt's recommended to use the latest tagged version.\nThe 'main' branch is used for development and may not be as stable.\n\n### Source Archive\n\nThe latest release of NeoMutt can be found, here:\n\n- https://github.com/neomutt/neomutt/releases/latest\n\nAll source releases are signed for security.\nSee [Signing Releases](https://neomutt.org/dev/signing#source-example) for details.\n\n## Building NeoMutt\n\nTo build NeoMutt, you will need, at the very minimum:\n\n- A C11 compiler such as gcc or clang\n- SysV-compatible curses library: ncurses\n- Some common libraries, such as iconv and regex\n- DocBook XSL stylesheets and DTDs (for building the docs)\n\nNeoMutt's build system uses [Autosetup](https://msteveb.github.io/autosetup/).\nIt depends on [Tcl](https://tcl.tk) and [Jim](http://jim.tcl.tk) to run its test scripts.\nIf they aren't available, Autosetup will use a version bundled with NeoMutt.\n\n### Configure\n\nThe Autosetup `configure` script performs two tasks.  It allows the user to\nenable/disable certain features of NeoMutt and it checks that all the build\ndependencies are present.\n\nFor a list of the currently supported options and a brief help text, run:\n`./configure --help`\n\n| Configure option        | Path | Notes                                        |\n| :---------------------- | :--- | :------------------------------------------- |\n| `--with-ncurses=path`   |      | Location of ncurses                          |\n|                         |      |                                              |\n| `--gpgme`               | Path | GPG Made Easy                                |\n| `--gnutls`              | Path | Gnu TLS (SSL)                                |\n| `--gss`                 | Path | Generic Security Services                    |\n| `--sasl`                | Path | Simple Authentication and Security Layer     |\n| `--ssl`                 | Path | OpenSSL                                      |\n|                         |      |                                              |\n| `--fmemopen`            |      | Optional Feature (Dangerous)                 |\n| `--lua`                 | Path | Optional Feature                             |\n| `--notmuch`             | Path | Optional Feature                             |\n|                         |      |                                              |\n| `--bdb`                 | Path | Header cache backend                         |\n| `--gdbm`                | Path | Header cache backend                         |\n| `--kyotocabinet`        | Path | Header cache backend                         |\n| `--lmdb`                | Path | Header cache backend                         |\n| `--qdbm`                | Path | Header cache backend                         |\n| `--tokyocabinet`        | Path | Header cache backend                         |\n|                         |      |                                              |\n| `--with-lock=CHOICE`    |      | Select 'fcntl' or 'flock'                    |\n| `--locales-fix`         |      | Workaround for broken locales                |\n| `--disable-nls`         | Path | National Language Support (translations)     |\n| `--disable-pgp`         | Path | Pretty Good Privacy                          |\n| `--disable-smime`       | Path | Secure/Multipurpose Internet Mail Extensions |\n| `--disable-idn`         | Path | Internationalised domain names               |\n|                         |      |                                              |\n| `--with-domain=DOMAIN`  |      | Default email domain                         |\n| `--with-mailpath`       | Path | Location of spooled mail                     |\n| `--homespool`           | Path | Spooled mail is in user's home dir           |\n|                         |      |                                              |\n| `--prefix`              | Path | Target directory for build (default: `/usr`) |\n| `--disable-doc`         |      | Don't build the docs                         |\n| `--full-doc`            |      | Document disabled features                   |\n| `--quiet`               |      | Only show the summary                        |\n\nThe options marked \"Path\" have either take a path, or have an extra option for\nspecifying the library path.\ne.g.  `./configure --notmuch --with-notmuch=/usr/local/lib/notmuch`\n\nThe parameter `--prefix` is used to specify both the default search path for\nheaders and libraries and the final directory structure of the installed files.\nThese are often the same: if you have your dependencies installed in\n`/usr/include` and `/usr/lib`, you also probably want the NeoMutt executable to\nend up in `/usr/bin` and its documentation in `/usr/share/doc`. This behavior\ncan be tweaked by specifying where 3rd party dependencies are to be found. This\nis done on a per-dependency basis using the `--with-<dep>=path` family of\noptions. As an example, a GPGME installation in `/opt` can be looked up using\nthe arguments `--gpgme --with-gpgme=/opt`.\n\nThe build can be adjusted by setting any of six environment variables:\n\n- `CC`            - set the compiler\n- `CFLAGS`        - replace **all** the compiler flags\n- `EXTRA_CFLAGS`  - append flags to the default compiler flags\n- `LD`            - set the linker\n- `LDFLAGS`       - replace **all** the linker flags\n- `EXTRA_LDFLAGS` - append flags to the default linker flags\n\ne.g.  `make EXTRA_CFLAGS=-g`\n\nHere are the sample commands to configure and build NeoMutt:\n\n```\n./configure --gnutls --gpgme --gss --sasl --tokyocabinet\nmake\n```\n\n### Install / Uninstall\n\nNeoMutt will be installed into the directory configured with `--prefix`.\nThis can be modified using the `DESTDIR` make variable, for example when doing\nstaged builds.  `DESTDIR` is prepended to the install path.\n\nTo install NeoMutt to the configured location, run:\n\n```\nmake install\n```\n\nTo override the root directory, use the `DESTDIR` make variable, e.g.\n\n```\nmake DESTDIR=$HOME/install install'\n```\n\nTo uninstall NeoMutt from the configured location, run:\n\n```\nmake uninstall\n```\n\nTo override the root directory, use the `DESTDIR` make variable, e.g.\n\n```\nmake DESTDIR=$HOME/install uninstall'\n```\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 17.466796875,
          "content": "# GNU GENERAL PUBLIC LICENSE\n\nVersion 2, June 1991\n\n    Copyright (C) 1989, 1991 Free Software Foundation, Inc.  \n    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n\n    Everyone is permitted to copy and distribute verbatim copies\n    of this license document, but changing it is not allowed.\n\n## Preamble\n\nThe licenses for most software are designed to take away your freedom\nto share and change it. By contrast, the GNU General Public License is\nintended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users. This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it. (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.) You can apply it to\nyour programs, too.\n\nWhen we speak of free software, we are referring to freedom, not\nprice. Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\nTo protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if\nyou distribute copies of the software, or if you modify it.\n\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have. You must make sure that they, too, receive or can get the\nsource code. And you must show them these terms so they know their\nrights.\n\nWe protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\nAlso, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware. If the software is modified by someone else and passed on,\nwe want its recipients to know that what they have is not the\noriginal, so that any problems introduced by others will not reflect\non the original authors' reputations.\n\nFinally, any free program is threatened constantly by software\npatents. We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary. To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at\nall.\n\nThe precise terms and conditions for copying, distribution and\nmodification follow.\n\n## TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n**0.** This License applies to any program or other work which\ncontains a notice placed by the copyright holder saying it may be\ndistributed under the terms of this General Public License. The\n\"Program\", below, refers to any such program or work, and a \"work\nbased on the Program\" means either the Program or any derivative work\nunder copyright law: that is to say, a work containing the Program or\na portion of it, either verbatim or with modifications and/or\ntranslated into another language. (Hereinafter, translation is\nincluded without limitation in the term \"modification\".) Each licensee\nis addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope. The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the Program\n(independent of having been made by running the Program). Whether that\nis true depends on what the Program does.\n\n**1.** You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a\nfee.\n\n**2.** You may modify your copy or copies of the Program or any\nportion of it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n  \n**a)** You must cause the modified files to carry prominent notices\nstating that you changed the files and the date of any change.\n\n  \n**b)** You must cause any work that you distribute or publish, that in\nwhole or in part contains or is derived from the Program or any part\nthereof, to be licensed as a whole at no charge to all third parties\nunder the terms of this License.\n\n  \n**c)** If the modified program normally reads commands interactively\nwhen run, you must cause it, when started running for such interactive\nuse in the most ordinary way, to print or display an announcement\nincluding an appropriate copyright notice and a notice that there is\nno warranty (or else, saying that you provide a warranty) and that\nusers may redistribute the program under these conditions, and telling\nthe user how to view a copy of this License. (Exception: if the\nProgram itself is interactive but does not normally print such an\nannouncement, your work based on the Program is not required to print\nan announcement.)\n\nThese requirements apply to the modified work as a whole. If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works. But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n**3.** You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n  \n**a)** Accompany it with the complete corresponding machine-readable\nsource code, which must be distributed under the terms of Sections 1\nand 2 above on a medium customarily used for software interchange; or,\n\n  \n**b)** Accompany it with a written offer, valid for at least three\nyears, to give any third party, for a charge no more than your cost of\nphysically performing source distribution, a complete machine-readable\ncopy of the corresponding source code, to be distributed under the\nterms of Sections 1 and 2 above on a medium customarily used for\nsoftware interchange; or,\n\n  \n**c)** Accompany it with the information you received as to the offer\nto distribute corresponding source code. (This alternative is allowed\nonly for noncommercial distribution and only if you received the\nprogram in object code or executable form with such an offer, in\naccord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it. For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable. However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n**4.** You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License. Any attempt otherwise\nto copy, modify, sublicense or distribute the Program is void, and\nwill automatically terminate your rights under this License. However,\nparties who have received copies, or rights, from you under this\nLicense will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n**5.** You are not required to accept this License, since you have not\nsigned it. However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works. These actions are\nprohibited by law if you do not accept this License. Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n**6.** Each time you redistribute the Program (or any work based on\nthe Program), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions. You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n**7.** If, as a consequence of a court judgment or allegation of\npatent infringement or for any other reason (not limited to patent\nissues), conditions are imposed on you (whether by court order,\nagreement or otherwise) that contradict the conditions of this\nLicense, they do not excuse you from the conditions of this License.\nIf you cannot distribute so as to satisfy simultaneously your\nobligations under this License and any other pertinent obligations,\nthen as a consequence you may not distribute the Program at all. For\nexample, if a patent license would not permit royalty-free\nredistribution of the Program by all those who receive copies directly\nor indirectly through you, then the only way you could satisfy both it\nand this License would be to refrain entirely from distribution of the\nProgram.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices. Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n**8.** If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded. In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n**9.** The Free Software Foundation may publish revised and/or new\nversions of the General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number. If the Program\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation. If the Program does not specify a\nversion number of this License, you may choose any version ever\npublished by the Free Software Foundation.\n\n**10.** If you wish to incorporate parts of the Program into other\nfree programs whose distribution conditions are different, write to\nthe author to ask for permission. For software which is copyrighted by\nthe Free Software Foundation, write to the Free Software Foundation;\nwe sometimes make exceptions for this. Our decision will be guided by\nthe two goals of preserving the free status of all derivatives of our\nfree software and of promoting the sharing and reuse of software\ngenerally.\n\n**NO WARRANTY**\n\n**11.** BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nPROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n**12.** IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nPROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\nEND OF TERMS AND CONDITIONS\n\n## How to Apply These Terms to Your New Programs\n\nIf you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these\nterms.\n\nTo do so, attach the following notices to the program. It is safest to\nattach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    one line to give the program's name and an idea of what it does.\n    Copyright (C) yyyy  name of author\n\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License\n    as published by the Free Software Foundation; either version 2\n    of the License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nAlso add information on how to contact you by electronic and paper\nmail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details\n    type `show w'.  This is free software, and you are welcome\n    to redistribute it under certain conditions; type `show c' \n    for details.\n\nThe hypothetical commands \\`show w' and \\`show c' should show the\nappropriate parts of the General Public License. Of course, the\ncommands you use may be called something other than \\`show w' and\n\\`show c'; they could even be mouse-clicks or menu items--whatever\nsuits your program.\n\nYou should also get your employer (if you work as a programmer) or\nyour school, if any, to sign a \"copyright disclaimer\" for the program,\nif necessary. Here is a sample; alter the names:\n\n    Yoyodyne, Inc., hereby disclaims all copyright\n    interest in the program `Gnomovision'\n    (which makes passes at compilers) written \n    by James Hacker.\n\n    signature of Ty Coon, 1 April 1989\n    Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program\ninto proprietary programs. If your program is a subroutine library,\nyou may consider it more useful to permit linking proprietary\napplications with the library. If this is what you want to do, use the\n[GNU Lesser General Public\nLicense](https://www.gnu.org/licenses/lgpl.html) instead of this\nLicense.\n"
        },
        {
          "name": "Makefile.autosetup",
          "type": "blob",
          "size": 30.4228515625,
          "content": "###############################################################################\n# substitutions by autosetup\n\nPACKAGE=\t@PACKAGE@\nPACKAGE_VERSION=@PACKAGE_VERSION@\nPACKAGE_DATE=\t@PACKAGE_DATE@\n\n# Build-time compiler and flags. These are used for building executables that\n# are only used at build-time, e.g., docs/makedoc. These are different from CC /\n# CFLAGS / LDFLAGS because the host and target systems might be different.\nCC_FOR_BUILD=\t\t@CC_FOR_BUILD@\nCFLAGS_FOR_BUILD=\t@CFLAGS_FOR_BUILD@ $(EXTRA_CFLAGS_FOR_BUILD)\nLDFLAGS_FOR_BUILD=\t@LDFLAGS_FOR_BUILD@ $(EXTRA_LDFLAGS_FOR_BUILD)\n\nPWD=\t\t@PWD@\nSH?=\t\tsh\nAR=\t\t@AR@\nCC=\t\t@CC@\nCPP=\t\t@CPP@\nCFLAGS=\t\t@CPPFLAGS@ @CFLAGS@ -I. -I@srcdir@ -Wall $(EXTRA_CFLAGS)\nLDFLAGS=\t@LDFLAGS@ $(EXTRA_LDFLAGS)\nEXEEXT=\t\t@EXEEXT@\nLIBS=\t\t@LIBS@\n@if ENABLE_NLS\nINTLLIBS=\t@INTLLIBS@\n@endif\nRANLIB=\t\t@RANLIB@\nSRCDIR=\t\t@srcdir@\nINSTALL=\t@INSTALL@ -c\nINSTALL_DATA=\t@INSTALL@ -m 644\nINSTALL_DIR=\t@INSTALL@ -d -m 755\nMKDIR_P=\tmkdir -p\nRM=\t\trm -fr\nDEPFILES=\t$(ALLOBJS:.o=.Po)\nBINFILES=\t$(NEOMUTT)\n@if HAVE_PGP\nLIBBINFILES+=\t$(PGPEWRAP)\n@endif\n@if HAVE_SMIME\nLIBBINFILES+=\t$(SRCDIR)/contrib/smime_keys\n@endif\n\n# paths\nbindir=\t\t@BINDIR@\ndatadir=\t@PKGDATADIR@\ndocdir=\t\t@PKGDOCDIR@\nmandir=\t\t@mandir@\nlibexecdir=\t@libexecdir@\nsysconfdir=\t@SYSCONFDIR@\ntextdomaindir=\t@MUTTLOCALEDIR@\n\n# targets for specific subdirectories\nALL_TARGETS=\t\t@ALL_TARGETS@\nCLEAN_TARGETS=\t\t@CLEAN_TARGETS@\nINSTALL_TARGETS=\t@INSTALL_TARGETS@\nUNINSTALL_TARGETS=\t@UNINSTALL_TARGETS@\n\nVPATH=\t\t@VPATH@\n\nALL_FILES!=\t(cd $(SRCDIR) && git ls-files 2>/dev/null) || true\n\ndefault:\tall\n\n###############################################################################\n# neomutt\nNEOMUTT=\tneomutt$(EXEEXT)\nNEOMUTTOBJS=\talternates.o commands.o conststrings.o copy.o editmsg.o \\\n\t\tenriched.o external.o flags.o git_ver.o globals.o \\\n\t\thandler.o help.o hook.o init.o mailcap.o maillist.o main.o \\\n\t\tmuttlib.o mutt_body.o mutt_config.o mutt_header.o \\\n\t\tmutt_logging.o mutt_mailbox.o mutt_signal.o mutt_socket.o \\\n\t\tmutt_thread.o mview.o mx.o recvcmd.o rfc3676.o score.o \\\n\t\tsubjectrx.o system.o version.o\n\n@if USE_INOTIFY\nNEOMUTTOBJS+=\tmonitor.o\n@endif\n@if USE_LUA\nNEOMUTTOBJS+=\tmutt_lua.o\n@endif\n@if !HAVE_TIMEGM\nNEOMUTTOBJS+=\ttimegm.o\n@endif\n@if !HAVE_WCSCASECMP\nNEOMUTTOBJS+=\twcscasecmp.o\n@endif\n\nCLEANFILES+=\t$(NEOMUTT) $(NEOMUTTOBJS)\nALLOBJS+=\t$(NEOMUTTOBJS)\n\n###############################################################################\n# libaddress\nLIBADDRESS=\tlibaddress.a\nLIBADDRESSOBJS=\taddress/address.o address/config_type.o address/group.o \\\n\t\taddress/idna.o\nCLEANFILES+=\t$(LIBADDRESS) $(LIBADDRESSOBJS)\nALLOBJS+=\t$(LIBADDRESSOBJS)\n\n$(LIBADDRESS): $(PWD)/address $(LIBADDRESSOBJS)\n\t$(AR) cr $@ $(LIBADDRESSOBJS)\n\t$(RANLIB) $@\n$(PWD)/address:\n\t$(MKDIR_P) $(PWD)/address\n\n###############################################################################\n# libalias\nLIBALIAS=\tlibalias.a\nLIBALIASOBJS=\talias/alias.o alias/array.o alias/commands.o alias/complete.o \\\n\t\talias/config.o alias/dlg_alias.o alias/dlg_query.o \\\n\t\talias/expando.o alias/functions.o alias/gui.o alias/reverse.o \\\n\t\talias/sort.o\nCLEANFILES+=\t$(LIBALIAS) $(LIBALIASOBJS)\nALLOBJS+=\t$(LIBALIASOBJS)\n\n$(LIBALIAS): $(PWD)/alias $(LIBALIASOBJS)\n\t$(AR) cr $@ $(LIBALIASOBJS)\n\t$(RANLIB) $@\n$(PWD)/alias:\n\t$(MKDIR_P) $(PWD)/alias\n\n###############################################################################\n# libattach\nLIBATTACH=\tlibattach.a\nLIBATTACHOBJS=\tattach/attach.o attach/attachments.o attach/cid.o \\\n\t\tattach/dlg_attach.o attach/expando.o attach/functions.o \\\n\t\tattach/lib.o attach/mutt_attach.o attach/private_data.o \\\n\t\tattach/recvattach.o\nCLEANFILES+=\t$(LIBATTACH) $(LIBATTACHOBJS)\nALLOBJS+=\t$(LIBATTACHOBJS)\n\n$(LIBATTACH): $(PWD)/attach $(LIBATTACHOBJS)\n\t$(AR) cr $@ $(LIBATTACHOBJS)\n\t$(RANLIB) $@\n$(PWD)/attach:\n\t$(MKDIR_P) $(PWD)/attach\n\n###############################################################################\n# libautocrypt\n@if USE_AUTOCRYPT\nLIBAUTOCRYPT=\tlibautocrypt.a\nLIBAUTOCRYPTOBJS=autocrypt/autocrypt.o autocrypt/autocrypt_data.o \\\n\t\t autocrypt/config.o autocrypt/db.o autocrypt/dlg_autocrypt.o \\\n\t\t autocrypt/expando.o autocrypt/functions.o autocrypt/gpgme.o \\\n\t\t autocrypt/schema.o\nCLEANFILES+=\t$(LIBAUTOCRYPT) $(LIBAUTOCRYPTOBJS)\nALLOBJS+=\t$(LIBAUTOCRYPTOBJS)\n\n$(LIBAUTOCRYPT): $(PWD)/autocrypt $(LIBAUTOCRYPTOBJS)\n\t$(AR) cr $@ $(LIBAUTOCRYPTOBJS)\n\t$(RANLIB) $@\n$(PWD)/autocrypt:\n\t$(MKDIR_P) $(PWD)/autocrypt\n@endif\n\n###############################################################################\n# libbcache\nLIBBCACHE=\tlibbcache.a\nLIBBCACHEOBJS=\tbcache/bcache.o\nCLEANFILES+=\t$(LIBBCACHE) $(LIBBCACHEOBJS)\nALLOBJS+=\t$(LIBBCACHEOBJS)\n\n$(LIBBCACHE): $(PWD)/bcache $(LIBBCACHEOBJS)\n\t$(AR) cr $@ $(LIBBCACHEOBJS)\n\t$(RANLIB) $@\n$(PWD)/bcache:\n\t$(MKDIR_P) $(PWD)/bcache\n\n###############################################################################\n# libbrowser\nLIBBROWSER=\tlibbrowser.a\nLIBBROWSEROBJS=\tbrowser/complete.o browser/config.o browser/dlg_browser.o \\\n\t\tbrowser/expando.o browser/functions.o browser/private_data.o \\\n\t\tbrowser/sort.o\nCLEANFILES+=\t$(LIBBROWSER) $(LIBBROWSEROBJS)\nALLOBJS+=\t$(LIBBROWSEROBJS)\n\n$(LIBBROWSER): $(PWD)/browser $(LIBBROWSEROBJS)\n\t$(AR) cr $@ $(LIBBROWSEROBJS)\n\t$(RANLIB) $@\n$(PWD)/browser:\n\t$(MKDIR_P) $(PWD)/browser\n\n###############################################################################\n# libcolor\nLIBCOLOR=\tlibcolor.a\nLIBCOLOROBJS=\tcolor/ansi.o color/attr.o color/color.o color/command.o \\\n\t\tcolor/curses.o color/dump.o color/merged.o color/notify.o \\\n\t\tcolor/parse_ansi.o color/parse_color.o color/qstyle.o \\\n\t\tcolor/quoted.o color/regex.o color/simple.o\n@if USE_DEBUG_COLOR\nLIBCOLOROBJS+=\tcolor/debug.o\n@endif\nCLEANFILES+=\t$(LIBCOLOR) $(LIBCOLOROBJS)\nALLOBJS+=\t$(LIBCOLOROBJS)\n\n$(LIBCOLOR):\t$(PWD)/color $(LIBCOLOROBJS)\n\t$(AR) cr $@ $(LIBCOLOROBJS)\n\t$(RANLIB) $@\n$(PWD)/color:\n\t$(MKDIR_P) $(PWD)/color\n\n###############################################################################\n# libcomplete\nLIBCOMPLETE=\tlibcomplete.a\nLIBCOMPLETEOBJS=complete/complete.o complete/data.o complete/helpers.o\nCLEANFILES+=\t$(LIBCOMPLETE) $(LIBCOMPLETEOBJS)\nALLOBJS+=\t$(LIBCOMPLETEOBJS)\n\n$(LIBCOMPLETE): $(PWD)/complete $(LIBCOMPLETEOBJS)\n\t$(AR) cr $@ $(LIBCOMPLETEOBJS)\n\t$(RANLIB) $@\n$(PWD)/complete:\n\t$(MKDIR_P) $(PWD)/complete\n\n###############################################################################\n# libcompmbox\nLIBCOMPMBOX=\tlibcompmbox.a\nLIBCOMPMBOXOBJS=compmbox/compress.o compmbox/expando.o\nCLEANFILES+=\t$(LIBCOMPMBOX) $(LIBCOMPMBOXOBJS)\nALLOBJS+=\t$(LIBCOMPMBOXOBJS)\n\n$(LIBCOMPMBOX): $(PWD)/compmbox $(LIBCOMPMBOXOBJS)\n\t$(AR) cr $@ $(LIBCOMPMBOXOBJS)\n\t$(RANLIB) $@\n$(PWD)/compmbox:\n\t$(MKDIR_P) $(PWD)/compmbox\n\n###############################################################################\n# libcompose\nLIBCOMPOSE=\tlibcompose.a\nLIBCOMPOSEOBJS=\tcompose/attach.o compose/attach_data.o compose/cbar.o \\\n\t\tcompose/cbar_data.o compose/config.o compose/dlg_compose.o \\\n\t\tcompose/expando.o compose/functions.o compose/preview.o \\\n\t\tcompose/shared_data.o\n\nCLEANFILES+=\t$(LIBCOMPOSE) $(LIBCOMPOSEOBJS)\nALLOBJS+=\t$(LIBCOMPOSEOBJS)\n\n$(LIBCOMPOSE): $(PWD)/compose $(LIBCOMPOSEOBJS)\n\t$(AR) cr $@ $(LIBCOMPOSEOBJS)\n\t$(RANLIB) $@\n$(PWD)/compose:\n\t$(MKDIR_P) $(PWD)/compose\n\n###############################################################################\n# libcompress\n@if USE_LZ4\nLIBCOMPRESSOBJS+=compress/lz4.o\n@endif\n@if USE_ZLIB\nLIBCOMPRESSOBJS+=compress/zlib.o\n@endif\n@if USE_ZSTD\nLIBCOMPRESSOBJS+=compress/zstd.o\n@endif\n@if USE_LZ4 || USE_ZLIB || USE_ZSTD\nLIBCOMPRESSOBJS+=compress/compress.o\nLIBCOMPRESS=\tlibcompress.a\nCLEANFILES+=\t$(LIBCOMPRESS) $(LIBCOMPRESSOBJS)\nALLOBJS+=\t$(LIBCOMPRESSOBJS)\n\n$(LIBCOMPRESS): $(PWD)/compress $(LIBCOMPRESSOBJS)\n\t$(AR) cr $@ $(LIBCOMPRESSOBJS)\n\t$(RANLIB) $@\n$(PWD)/compress:\n\t$(MKDIR_P) $(PWD)/compress\n@endif\n\n###############################################################################\n# libconfig\nLIBCONFIG=\tlibconfig.a\nLIBCONFIGOBJS=\tconfig/bool.o config/charset.o config/dump.o config/enum.o \\\n\t\tconfig/helpers.o config/long.o config/mbtable.o config/myvar.o \\\n\t\tconfig/number.o config/path.o config/quad.o config/regex.o \\\n\t\tconfig/set.o config/slist.o config/sort.o config/string.o \\\n\t\tconfig/subset.o\nCLEANFILES+=\t$(LIBCONFIG) $(LIBCONFIGOBJS)\nALLOBJS+=\t$(LIBCONFIGOBJS)\n\n$(LIBCONFIG): $(PWD)/config $(LIBCONFIGOBJS)\n\t$(AR) cr $@ $(LIBCONFIGOBJS)\n\t$(RANLIB) $@\n$(PWD)/config:\n\t$(MKDIR_P) $(PWD)/config\n\n###############################################################################\n# libconn\nLIBCONN=\tlibconn.a\nLIBCONNOBJS=\tconn/accountcmd.o conn/config.o conn/connaccount.o \\\n\t\tconn/mutt_account.o conn/raw.o conn/sasl_plain.o \\\n\t\tconn/socket.o conn/tunnel.o\n@if !DOMAIN\nLIBCONNOBJS+=\tconn/getdomain.o\n@endif\n@if USE_SASL_GNU\nLIBCONNOBJS+=\tconn/gsasl.o\n@endif\n@if USE_SASL_CYRUS\nLIBCONNOBJS+=\tconn/sasl.o\n@endif\n@if USE_SSL\nLIBCONNOBJS+=\tconn/dlg_verifycert.o\n@endif\n@if USE_SSL_GNUTLS\nLIBCONNOBJS+=\tconn/gnutls.o\n@endif\n@if USE_SSL_OPENSSL\nLIBCONNOBJS+=\tconn/openssl.o\n@endif\n@if USE_ZLIB\nLIBCONNOBJS+=\tconn/zstrm.o\n@endif\nCLEANFILES+=\t$(LIBCONN) $(LIBCONNOBJS)\nALLOBJS+=\t$(LIBCONNOBJS)\n\n$(LIBCONN): $(PWD)/conn $(LIBCONNOBJS)\n\t$(AR) cr $@ $(LIBCONNOBJS)\n\t$(RANLIB) $@\n$(PWD)/conn:\n\t$(MKDIR_P) $(PWD)/conn\n\n###############################################################################\n# libconvert\nLIBCONVERT=\tlibconvert.a\nLIBCONVERTOBJS=\tconvert/content_info.o convert/convert.o\nCLEANFILES+=\t$(LIBCONVERT) $(LIBCONVERTOBJS)\nALLOBJS+=\t$(LIBCONVERTOBJS)\n\n$(LIBCONVERT): $(PWD)/convert $(LIBCONVERTOBJS)\n\t$(AR) cr $@ $(LIBCONVERTOBJS)\n\t$(RANLIB) $@\n$(PWD)/convert:\n\t$(MKDIR_P) $(PWD)/convert\n\n###############################################################################\n# libcore\nLIBCORE=\tlibcore.a\nLIBCOREOBJS=\tcore/account.o core/command.o core/config_cache.o \\\n\t\tcore/dispatcher.o core/mailbox.o core/message.o core/neomutt.o \\\n\t\tcore/tmp.o\nCLEANFILES+=\t$(LIBCORE) $(LIBCOREOBJS)\nALLOBJS+=\t$(LIBCOREOBJS)\n\n$(LIBCORE): $(PWD)/core $(LIBCOREOBJS)\n\t$(AR) cr $@ $(LIBCOREOBJS)\n\t$(RANLIB) $@\n$(PWD)/core:\n\t$(MKDIR_P) $(PWD)/core\n\n###############################################################################\n# libdebug\n@if USE_DEBUG_BACKTRACE\nLIBDEBUGOBJS+=\tdebug/backtrace.o\n@endif\n@if USE_DEBUG_COLOR\nLIBDEBUGOBJS+=\tdebug/pager.o\n@endif\n@if USE_DEBUG_EMAIL\nLIBDEBUGOBJS+=\tdebug/email.o\n@endif\n@if USE_DEBUG_GRAPHVIZ\nLIBDEBUGOBJS+=\tdebug/graphviz.o\n@endif\n@if USE_DEBUG_KEYMAP\nLIBDEBUGOBJS+=\tdebug/keymap.o\n@endif\n@if USE_DEBUG_LOGGING\nLIBDEBUGOBJS+=\tdebug/logging.o\n@endif\n@if USE_DEBUG_NOTIFY\nLIBDEBUGOBJS+=\tdebug/notify.o\n@endif\n@if USE_DEBUG_WINDOW\nLIBDEBUGOBJS+=\tdebug/window.o\n@endif\n@if USE_DEBUG_BACKTRACE || USE_DEBUG_COLOR || USE_DEBUG_EMAIL || USE_DEBUG_GRAPHVIZ || USE_DEBUG_KEYMAP || USE_DEBUG_LOGGING || USE_DEBUG_NAMES || USE_DEBUG_NOTIFY || USE_DEBUG_WINDOW\nLIBDEBUGOBJS+=\tdebug/names.o\n@endif\n@if USE_DEBUG_EMAIL || USE_DEBUG_GRAPHVIZ\nLIBDEBUGOBJS+=\tdebug/common.o\n@endif\nLIBDEBUGOBJS+=\tdebug/names_expando.o\nLIBDEBUG=\tlibdebug.a\nCLEANFILES+=\t$(LIBDEBUG) $(LIBDEBUGOBJS)\nALLOBJS+=\t$(LIBDEBUGOBJS)\n\n$(LIBDEBUG): $(PWD)/debug $(LIBDEBUGOBJS)\n\t$(AR) cr $@ $(LIBDEBUGOBJS)\n\t$(RANLIB) $@\n$(PWD)/debug:\n\t$(MKDIR_P) $(PWD)/debug\n\n###############################################################################\n# libeditor\nLIBEDITOR=\tlibeditor.a\nLIBEDITOROBJS=\teditor/enter.o editor/functions.o editor/state.o editor/window.o\nCLEANFILES+=\t$(LIBEDITOR) $(LIBEDITOROBJS)\nALLOBJS+=\t$(LIBEDITOROBJS)\n\n$(LIBEDITOR): $(PWD)/editor $(LIBEDITOROBJS)\n\t$(AR) cr $@ $(LIBEDITOROBJS)\n\t$(RANLIB) $@\n$(PWD)/editor:\n\t$(MKDIR_P) $(PWD)/editor\n\n###############################################################################\n# libemail\nLIBEMAIL=\tlibemail.a\nLIBEMAILOBJS=\temail/body.o email/config.o email/email.o email/envelope.o \\\n\t\temail/from.o email/globals.o email/mime.o email/parameter.o \\\n\t\temail/parse.o email/rfc2047.o email/rfc2231.o email/sort.o \\\n\t\temail/tags.o email/thread.o email/url.o\nCLEANFILES+=\t$(LIBEMAIL) $(LIBEMAILOBJS)\nALLOBJS+=\t$(LIBEMAILOBJS)\n\n$(LIBEMAIL): $(PWD)/email $(LIBEMAILOBJS)\n\t$(AR) cr $@ $(LIBEMAILOBJS)\n\t$(RANLIB) $@\n$(PWD)/email:\n\t$(MKDIR_P) $(PWD)/email\n\n###############################################################################\n# libenvelope\nLIBENVELOPE=\tlibenvelope.a\nLIBENVELOPEOBJS=envelope/functions.o envelope/wdata.o envelope/window.o\nCLEANFILES+=\t$(LIBENVELOPE) $(LIBENVELOPEOBJS)\nALLOBJS+=\t$(LIBENVELOPEOBJS)\n\n$(LIBENVELOPE): $(PWD)/envelope $(LIBENVELOPEOBJS)\n\t$(AR) cr $@ $(LIBENVELOPEOBJS)\n\t$(RANLIB) $@\n$(PWD)/envelope:\n\t$(MKDIR_P) $(PWD)/envelope\n\n###############################################################################\n# libexpando\nLIBEXPANDO=\tlibexpando.a\nLIBEXPANDOOBJS=\texpando/config_type.o expando/expando.o expando/filter.o \\\n\t\texpando/format.o expando/helpers.o expando/node.o \\\n\t\texpando/node_condbool.o expando/node_conddate.o \\\n\t\texpando/node_condition.o expando/node_container.o \\\n\t\texpando/node_expando.o expando/node_padding.o \\\n\t\texpando/node_text.o expando/parse.o expando/render.o\nCLEANFILES+=\t$(LIBEXPANDO) $(LIBEXPANDOOBJS)\nALLOBJS+=\t$(LIBEXPANDOOBJS)\n\n$(LIBEXPANDO): $(PWD)/expando $(LIBEXPANDOOBJS)\n\t$(AR) cr $@ $(LIBEXPANDOOBJS)\n\t$(RANLIB) $@\n$(PWD)/expando:\n\t$(MKDIR_P) $(PWD)/expando\n\n###############################################################################\n# libgui\nLIBGUI=\t\tlibgui.a\nLIBGUIOBJS=\tgui/curs_lib.o gui/dialog.o gui/functions.o gui/global.o \\\n\t\tgui/msgcont.o gui/msgwin.o gui/msgwin_wdata.o \\\n\t\tgui/mutt_curses.o gui/mutt_window.o gui/opcodes.o gui/reflow.o \\\n\t\tgui/resize.o gui/rootwin.o gui/sbar.o gui/simple.o \\\n\t\tgui/terminal.o\nCLEANFILES+=\t$(LIBGUI) $(LIBGUIOBJS)\nALLOBJS+=\t$(LIBGUIOBJS)\n\n$(LIBGUI): $(PWD)/gui $(LIBGUIOBJS)\n\t$(AR) cr $@ $(LIBGUIOBJS)\n\t$(RANLIB) $@\n$(PWD)/gui:\n\t$(MKDIR_P) $(PWD)/gui\n\n###############################################################################\n# libhcache\n@if USE_HCACHE\nLIBHCACHE=\tlibhcache.a\nLIBHCACHEOBJS=\thcache/config.o hcache/hcache.o hcache/serialize.o\nCLEANFILES+=\t$(LIBHCACHE) $(LIBHCACHEOBJS)\nALLOBJS+=\t$(LIBHCACHEOBJS)\n\nhcache/hcache.o:\thcache/hcversion.h\n$(LIBHCACHE): $(PWD)/hcache $(LIBHCACHEOBJS)\n\t$(AR) cr $@ $(LIBHCACHEOBJS)\n\t$(RANLIB) $@\n$(PWD)/hcache:\n\t$(MKDIR_P) $(PWD)/hcache\n@endif\n\n###############################################################################\n# libhelpbar\nLIBHELPBAR=\tlibhelpbar.a\nLIBHELPBAROBJS=\thelpbar/config.o helpbar/helpbar.o helpbar/wdata.o\nCLEANFILES+=\t$(LIBHELPBAR) $(LIBHELPBAROBJS)\nALLOBJS+=\t$(LIBHELPBAROBJS)\n\n$(LIBHELPBAR): $(PWD)/helpbar $(LIBHELPBAROBJS)\n\t$(AR) cr $@ $(LIBHELPBAROBJS)\n\t$(RANLIB) $@\n$(PWD)/helpbar:\n\t$(MKDIR_P) $(PWD)/helpbar\n\n###############################################################################\n# libhistory\nLIBHISTORY=\tlibhistory.a\nLIBHISTORYOBJS=\thistory/config.o history/dlg_history.o history/expando.o \\\n\t\thistory/functions.o history/history.o\nCLEANFILES+=\t$(LIBHISTORY) $(LIBHISTORYOBJS)\nALLOBJS+=\t$(LIBHISTORYOBJS)\n\n$(LIBHISTORY): $(PWD)/history $(LIBHISTORYOBJS)\n\t$(AR) cr $@ $(LIBHISTORYOBJS)\n\t$(RANLIB) $@\n$(PWD)/history:\n\t$(MKDIR_P) $(PWD)/history\n\n###############################################################################\n# libimap\nLIBIMAP=\tlibimap.a\nLIBIMAPOBJS=\timap/adata.o imap/auth.o imap/auth_login.o imap/auth_oauth.o \\\n\t\timap/auth_plain.o imap/browse.o imap/command.o imap/config.o \\\n\t\timap/edata.o imap/imap.o imap/mdata.o imap/message.o \\\n\t\timap/msg_set.o imap/msn.o imap/search.o imap/utf7.o imap/util.o\n@if USE_GSS\nLIBIMAPOBJS+=\timap/auth_gss.o\n@endif\n@if USE_SASL_CYRUS\nLIBIMAPOBJS+=\timap/auth_sasl.o\n@endif\n@if USE_SASL_GNU\nLIBIMAPOBJS+=\timap/auth_gsasl.o\n@endif\n@if !HAVE_SASL\nLIBIMAPOBJS+=\timap/auth_anon.o imap/auth_cram.o\n@endif\nCLEANFILES+=\t$(LIBIMAP) $(LIBIMAPOBJS)\nALLOBJS+=\t$(LIBIMAPOBJS)\n\n$(LIBIMAP): $(PWD)/imap $(LIBIMAPOBJS)\n\t$(AR) cr $@ $(LIBIMAPOBJS)\n\t$(RANLIB) $@\n$(PWD)/imap:\n\t$(MKDIR_P) $(PWD)/imap\n\n###############################################################################\n# libindex\nLIBINDEX=\tlibindex.a\nLIBINDEXOBJS=\tindex/config.o index/dlg_index.o index/expando_index.o \\\n\t\tindex/expando_status.o index/functions.o index/ibar.o \\\n\t\tindex/index.o index/ipanel.o index/private_data.o \\\n\t\tindex/shared_data.o index/status.o\nCLEANFILES+=\t$(LIBINDEX) $(LIBINDEXOBJS)\nALLOBJS+=\t$(LIBINDEXOBJS)\n\n$(LIBINDEX): $(PWD)/index $(LIBINDEXOBJS)\n\t$(AR) cr $@ $(LIBINDEXOBJS)\n\t$(RANLIB) $@\n$(PWD)/index:\n\t$(MKDIR_P) $(PWD)/index\n\n###############################################################################\n# libkey\nLIBKEY=\t\tlibkey.a\nLIBKEYOBJS=\tkey/dump.o key/get.o key/init.o key/lib.o key/parse.o\nCLEANFILES+=\t$(LIBKEY) $(LIBKEYOBJS)\nALLOBJS+=\t$(LIBKEYOBJS)\n\n$(LIBKEY): $(PWD)/key $(LIBKEYOBJS)\n\t$(AR) cr $@ $(LIBKEYOBJS)\n\t$(RANLIB) $@\n$(PWD)/key:\n\t$(MKDIR_P) $(PWD)/key\n\n###############################################################################\n# libmaildir\nLIBMAILDIR=\tlibmaildir.a\nLIBMAILDIROBJS= maildir/account.o maildir/config.o maildir/edata.o \\\n\t\tmaildir/mailbox.o maildir/maildir.o maildir/mdata.o \\\n\t\tmaildir/mdemail.o maildir/message.o maildir/path.o \\\n\t\tmaildir/shared.o\n@if USE_HCACHE\nLIBMAILDIROBJS+=maildir/hcache.o\n@endif\nCLEANFILES+=\t$(LIBMAILDIR) $(LIBMAILDIROBJS)\nALLOBJS+=\t$(LIBMAILDIROBJS)\n\n$(LIBMAILDIR): $(PWD)/maildir $(LIBMAILDIROBJS)\n\t$(AR) cr $@ $(LIBMAILDIROBJS)\n\t$(RANLIB) $@\n$(PWD)/maildir:\n\t$(MKDIR_P) $(PWD)/maildir\n\n###############################################################################\n# libmbox\nLIBMBOX=\tlibmbox.a\nLIBMBOXOBJS=\tmbox/config.o mbox/mbox.o\nCLEANFILES+=\t$(LIBMBOX) $(LIBMBOXOBJS)\nALLOBJS+=\t$(LIBMBOXOBJS)\n\n$(LIBMBOX): $(PWD)/mbox $(LIBMBOXOBJS)\n\t$(AR) cr $@ $(LIBMBOXOBJS)\n\t$(RANLIB) $@\n$(PWD)/mbox:\n\t$(MKDIR_P) $(PWD)/mbox\n\n###############################################################################\n# libmenu\nLIBMENU=\tlibmenu.a\nLIBMENUOBJS=\tmenu/config.o menu/draw.o menu/functions.o menu/menu.o \\\n\t\tmenu/move.o menu/observer.o menu/tagging.o menu/type.o \\\n\t\tmenu/window.o\nCLEANFILES+=\t$(LIBMENU) $(LIBMENUOBJS)\nALLOBJS+=\t$(LIBMENUOBJS)\n\n$(LIBMENU): $(PWD)/menu $(LIBMENUOBJS)\n\t$(AR) cr $@ $(LIBMENUOBJS)\n\t$(RANLIB) $@\n$(PWD)/menu:\n\t$(MKDIR_P) $(PWD)/menu\n\n###############################################################################\n# libmh\nLIBMH=\t\tlibmh.a\nLIBMHOBJS=\tmh/config.o mh/mh.o mh/mdata.o mh/mhemail.o mh/mh.o \\\n\t\tmh/sequence.o mh/shared.o\nCLEANFILES+=\t$(LIBMH) $(LIBMHOBJS)\nALLOBJS+=\t$(LIBMHOBJS)\n\n$(LIBMH): $(PWD)/mh $(LIBMHOBJS)\n\t$(AR) cr $@ $(LIBMHOBJS)\n\t$(RANLIB) $@\n$(PWD)/mh:\n\t$(MKDIR_P) $(PWD)/mh\n\n###############################################################################\n# libmutt\nLIBMUTT=\tlibmutt.a\nLIBMUTTOBJS=\tmutt/atoi.o mutt/base64.o mutt/buffer.o mutt/charset.o \\\n\t\tmutt/date.o mutt/envlist.o mutt/exit.o mutt/file.o \\\n\t\tmutt/filter.o mutt/hash.o mutt/list.o mutt/logging.o \\\n\t\tmutt/mapping.o mutt/mbyte.o mutt/md5.o mutt/memory.o \\\n\t\tmutt/notify.o mutt/path.o mutt/pool.o mutt/prex.o \\\n\t\tmutt/qsort_r.o mutt/random.o mutt/regex.o mutt/signal.o \\\n\t\tmutt/slist.o mutt/state.o mutt/string.o\n\nCLEANFILES+=\t$(LIBMUTT) $(LIBMUTTOBJS)\nALLOBJS+=\t$(LIBMUTTOBJS)\n\n$(LIBMUTT): $(PWD)/mutt $(LIBMUTTOBJS)\n\t$(AR) cr $@ $(LIBMUTTOBJS)\n\t$(RANLIB) $@\n$(PWD)/mutt:\n\t$(MKDIR_P) $(PWD)/mutt\n\n###############################################################################\n# libncrypt\nLIBNCRYPT=\tlibncrypt.a\nLIBNCRYPTOBJS=\tncrypt/config.o ncrypt/crypt.o ncrypt/crypt_mod.o \\\n\t\tncrypt/cryptglue.o ncrypt/functions.o\n@if HAVE_PKG_GPGME\nLIBNCRYPTOBJS+=\tncrypt/crypt_gpgme.o ncrypt/dlg_gpgme.o ncrypt/expando_gpgme.o \\\n\t\tncrypt/gpgme_functions.o ncrypt/crypt_mod_pgp_gpgme.o \\\n\t\tncrypt/crypt_mod_smime_gpgme.o ncrypt/sort_gpgme.o\n@endif\n@if HAVE_PGP\nLIBNCRYPTOBJS+=\tncrypt/crypt_mod_pgp_classic.o ncrypt/dlg_pgp.o \\\n\t\tncrypt/expando_command.o ncrypt/expando_pgp.o \\\n\t\tncrypt/gnupgparse.o ncrypt/pgp_functions.o ncrypt/pgp.o \\\n\t\tncrypt/pgpinvoke.o ncrypt/pgpkey.o ncrypt/pgplib.o \\\n\t\tncrypt/pgpmicalg.o ncrypt/pgppacket.o ncrypt/sort_pgp.o\n@endif\n@if HAVE_SMIME\nLIBNCRYPTOBJS+=\tncrypt/crypt_mod_smime_classic.o ncrypt/dlg_smime.o \\\n\t\tncrypt/expando_smime.o ncrypt/smime_functions.o ncrypt/smime.o\n@endif\nCLEANFILES+=\t$(LIBNCRYPT) $(LIBNCRYPTOBJS)\nALLOBJS+=\t$(LIBNCRYPTOBJS)\n\n$(LIBNCRYPT): $(PWD)/ncrypt $(LIBNCRYPTOBJS)\n\t$(AR) cr $@ $(LIBNCRYPTOBJS)\n\t$(RANLIB) $@\n$(PWD)/ncrypt:\n\t$(MKDIR_P) $(PWD)/ncrypt\n\n###############################################################################\n# libnntp\nLIBNNTP=\tlibnntp.a\nLIBNNTPOBJS=\tnntp/adata.o nntp/complete.o nntp/config.o nntp/edata.o \\\n\t\tnntp/expando_browser.o nntp/expando_newsrc.o nntp/mdata.o \\\n\t\tnntp/newsrc.o nntp/nntp.o\nCLEANFILES+=\t$(LIBNNTP) $(LIBNNTPOBJS)\nALLOBJS+=\t$(LIBNNTPOBJS)\n\n$(LIBNNTP): $(PWD)/nntp $(LIBNNTPOBJS)\n\t$(AR) cr $@ $(LIBNNTPOBJS)\n\t$(RANLIB) $@\n$(PWD)/nntp:\n\t$(MKDIR_P) $(PWD)/nntp\n\n###############################################################################\n# libnotmuch\n@if USE_NOTMUCH\nLIBNOTMUCH=\tlibnotmuch.a\nLIBNOTMUCHOBJS=\tnotmuch/adata.o notmuch/complete.o notmuch/config.o \\\n\t\tnotmuch/db.o notmuch/edata.o notmuch/mdata.o notmuch/notmuch.o \\\n\t\tnotmuch/query.o notmuch/tag.o\nCLEANFILES+=\t$(LIBNOTMUCH) $(LIBNOTMUCHOBJS)\nALLOBJS+=\t$(LIBNOTMUCHOBJS)\n\n$(LIBNOTMUCH): $(PWD)/notmuch $(LIBNOTMUCHOBJS)\n\t$(AR) cr $@ $(LIBNOTMUCHOBJS)\n\t$(RANLIB) $@\n$(PWD)/notmuch:\n\t$(MKDIR_P) $(PWD)/notmuch\n@endif\n\n###############################################################################\n# libpager\nLIBPAGER=\tlibpager.a\nLIBPAGEROBJS=\tpager/config.o pager/display.o pager/dlg_pager.o \\\n\t\tpager/do_pager.o pager/functions.o pager/message.o \\\n\t\tpager/pager.o pager/pbar.o pager/ppanel.o pager/private_data.o\nCLEANFILES+=\t$(LIBPAGER) $(LIBPAGEROBJS)\nALLOBJS+=\t$(LIBPAGEROBJS)\n\n$(LIBPAGER): $(PWD)/pager $(LIBPAGEROBJS)\n\t$(AR) cr $@ $(LIBPAGEROBJS)\n\t$(RANLIB) $@\n$(PWD)/pager:\n\t$(MKDIR_P) $(PWD)/pager\n\n###############################################################################\n# libparse\nLIBPARSE=\tlibparse.a\nLIBPARSEOBJS=\tparse/extract.o parse/rc.o parse/set.o\nCLEANFILES+=\t$(LIBPARSE) $(LIBPARSEOBJS)\nALLOBJS+=\t$(LIBPARSEOBJS)\n\n$(LIBPARSE): $(PWD)/parse $(LIBPARSEOBJS)\n\t$(AR) cr $@ $(LIBPARSEOBJS)\n\t$(RANLIB) $@\n$(PWD)/parse:\n\t$(MKDIR_P) $(PWD)/parse\n\n###############################################################################\n# libpattern\nLIBPATTERN=\tlibpattern.a\nLIBPATTERNOBJS=\tpattern/compile.o pattern/complete.o pattern/config.o \\\n\t\tpattern/dlg_pattern.o pattern/exec.o pattern/expando.o \\\n\t\tpattern/flags.o pattern/functions.o pattern/message.o \\\n\t\tpattern/pattern.o pattern/pattern_data.o pattern/search_state.o\nCLEANFILES+=\t$(LIBPATTERN) $(LIBPATTERNOBJS)\nALLOBJS+=\t$(LIBPATTERNOBJS)\n\n$(LIBPATTERN): $(PWD)/pattern $(LIBPATTERNOBJS)\n\t$(AR) cr $@ $(LIBPATTERNOBJS)\n\t$(RANLIB) $@\n$(PWD)/pattern:\n\t$(MKDIR_P) $(PWD)/pattern\n\n###############################################################################\n# libpop\nLIBPOP=\t\tlibpop.a\nLIBPOPOBJS=\tpop/adata.o pop/auth.o pop/config.o pop/edata.o pop/lib.o \\\n\t\tpop/pop.o\nCLEANFILES+=\t$(LIBPOP) $(LIBPOPOBJS)\nALLOBJS+=\t$(LIBPOPOBJS)\n\n$(LIBPOP): $(PWD)/pop $(LIBPOPOBJS)\n\t$(AR) cr $@ $(LIBPOPOBJS)\n\t$(RANLIB) $@\n$(PWD)/pop:\n\t$(MKDIR_P) $(PWD)/pop\n\n###############################################################################\n# libpostpone\nLIBPOSTPONE=\t\tlibpostpone.a\nLIBPOSTPONEOBJS=postpone/dlg_postpone.o postpone/functions.o postpone/postpone.o\nCLEANFILES+=\t$(LIBPOSTPONE) $(LIBPOSTPONEOBJS)\nALLOBJS+=\t$(LIBPOSTPONEOBJS)\n\n$(LIBPOSTPONE): $(PWD)/postpone $(LIBPOSTPONEOBJS)\n\t$(AR) cr $@ $(LIBPOSTPONEOBJS)\n\t$(RANLIB) $@\n$(PWD)/postpone:\n\t$(MKDIR_P) $(PWD)/postpone\n\n###############################################################################\n# libprogress\nLIBPROGRESS=\tlibprogress.a\nLIBPROGRESSOBJS=progress/config.o progress/progress.o progress/wdata.o \\\n\t\tprogress/window.o\nCLEANFILES+=\t$(LIBPROGRESS) $(LIBPROGRESSOBJS)\nALLOBJS+=\t$(LIBPROGRESSOBJS)\n\n$(LIBPROGRESS): $(PWD)/progress $(LIBPROGRESSOBJS)\n\t$(AR) cr $@ $(LIBPROGRESSOBJS)\n\t$(RANLIB) $@\n$(PWD)/progress:\n\t$(MKDIR_P) $(PWD)/progress\n\n###############################################################################\n# libquestion\nLIBQUESTION=\tlibquestion.a\nLIBQUESTIONOBJS=question/question.o\nCLEANFILES+=\t$(LIBQUESTION) $(LIBQUESTIONOBJS)\nALLOBJS+=\t$(LIBQUESTIONOBJS)\n\n$(LIBQUESTION): $(PWD)/question $(LIBQUESTIONOBJS)\n\t$(AR) cr $@ $(LIBQUESTIONOBJS)\n\t$(RANLIB) $@\n$(PWD)/question:\n\t$(MKDIR_P) $(PWD)/question\n\n###############################################################################\n# libsend\nLIBSEND=\tlibsend.a\nLIBSENDOBJS=\tsend/body.o send/config.o send/expando.o send/header.o \\\n\t\tsend/multipart.o send/send.o send/sendlib.o send/sendmail.o \\\n\t\tsend/smtp.o\nCLEANFILES+=\t$(LIBSEND) $(LIBSENDOBJS)\nALLOBJS+=\t$(LIBSENDOBJS)\n\n$(LIBSEND): $(PWD)/send $(LIBSENDOBJS)\n\t$(AR) cr $@ $(LIBSENDOBJS)\n\t$(RANLIB) $@\n$(PWD)/send:\n\t$(MKDIR_P) $(PWD)/send\n\n###############################################################################\n# libsidebar\nLIBSIDEBAR=\tlibsidebar.a\nLIBSIDEBAROBJS=\tsidebar/commands.o sidebar/config.o sidebar/expando.o \\\n\t\tsidebar/functions.o sidebar/observer.o sidebar/sidebar.o \\\n\t\tsidebar/sort.o sidebar/wdata.o sidebar/window.o\nCLEANFILES+=\t$(LIBSIDEBAR) $(LIBSIDEBAROBJS)\nALLOBJS+=\t$(LIBSIDEBAROBJS)\n\n$(LIBSIDEBAR): $(PWD)/sidebar $(LIBSIDEBAROBJS)\n\t$(AR) cr $@ $(LIBSIDEBAROBJS)\n\t$(RANLIB) $@\n$(PWD)/sidebar:\n\t$(MKDIR_P) $(PWD)/sidebar\n\n###############################################################################\n# libstore\n@if HAVE_BDB\nLIBSTOREOBJS+=\tstore/bdb.o\n@endif\n@if HAVE_GDBM\nLIBSTOREOBJS+=\tstore/gdbm.o\n@endif\n@if HAVE_KC\nLIBSTOREOBJS+=\tstore/kc.o\n@endif\n@if HAVE_LMDB\nLIBSTOREOBJS+=\tstore/lmdb.o\n@endif\n@if HAVE_QDBM\nLIBSTOREOBJS+=\tstore/qdbm.o\n@endif\n@if HAVE_ROCKSDB\nLIBSTOREOBJS+=\tstore/rocksdb.o\n@endif\n@if HAVE_TDB\nLIBSTOREOBJS+=\tstore/tdb.o\n@endif\n@if HAVE_TC\nLIBSTOREOBJS+=\tstore/tc.o\n@endif\n@if HAVE_BDB || HAVE_GDBM || HAVE_KC || HAVE_LMDB || HAVE_QDBM || HAVE_ROCKSDB || HAVE_TDB || HAVE_TC\nLIBSTORE=\tlibstore.a\nLIBSTOREOBJS+=\tstore/store.o\nCLEANFILES+=\t$(LIBSTORE) $(LIBSTOREOBJS)\nALLOBJS+=\t$(LIBSTOREOBJS)\n\n$(LIBSTORE): $(PWD)/store $(LIBSTOREOBJS)\n\t$(AR) cr $@ $(LIBSTOREOBJS)\n\t$(RANLIB) $@\n$(PWD)/store:\n\t$(MKDIR_P) $(PWD)/store\n@endif\n\n###############################################################################\n# pgpewrap\nPGPEWRAP=\tpgpewrap$(EXEEXT)\nPGPEWRAPOBJS=\tpgpewrap.o\nCLEANFILES+=\t$(PGPEWRAP) $(PGPEWRAPOBJS)\nALLOBJS+=\t$(PGPEWRAPOBJS)\n\n$(PGPEWRAP): $(PGPEWRAPOBJS)\n\t$(CC) $(LDFLAGS) -o $@ $(PGPEWRAPOBJS)\n\n##############################################################################\n# targets\nall: $(BINFILES) $(LIBBINFILES) $(ALL_TARGETS)\n\n# compile + dependencies\n.c.o:\n\t$(CC) $(CFLAGS) -MT $@ -MD -MP -MF $(@:.o=.Tpo) -c -o $@ $<\n\t@mv $(@:.o=.Tpo) $(@:.o=.Po)\n\n$(ALLOBJS):\n\n# The order of these libraries depends on their dependencies.\n# The libraries with the most dependencies will come first.\nMUTTLIBS+=\t$(LIBINDEX) $(LIBPAGER) $(LIBINDEX) $(LIBPAGER) $(LIBAUTOCRYPT) $(LIBPOP) \\\n\t\t$(LIBEDITOR) $(LIBCOMPLETE) $(LIBBROWSER) $(LIBCOMPMBOX) $(LIBSTORE) \\\n\t\t$(LIBPROGRESS) $(LIBQUESTION) $(LIBPOSTPONE) $(LIBALIAS) $(LIBSEND) \\\n\t\t$(LIBCONVERT) $(LIBCOMPOSE) $(LIBATTACH) $(LIBKEY) $(LIBGUI) $(LIBNNTP) \\\n\t\t$(LIBPATTERN) $(LIBMENU) $(LIBCOLOR) $(LIBENVELOPE) \\\n\t\t$(LIBHELPBAR) $(LIBMBOX) $(LIBMH) $(LIBNOTMUCH) $(LIBMAILDIR) $(LIBEDITOR) $(LIBCOMPLETE) $(LIBNNTP) \\\n\t\t$(LIBNCRYPT) $(LIBIMAP) $(LIBCONN) $(LIBHCACHE) \\\n\t\t$(LIBCOMPRESS) $(LIBSIDEBAR) $(LIBBCACHE) $(LIBHISTORY) \\\n\t\t$(LIBCORE) $(LIBPARSE) $(LIBEXPANDO) $(LIBCONFIG) $(LIBEMAIL) $(LIBADDRESS) \\\n\t\t$(LIBDEBUG) $(LIBMUTT)\n\n# neomutt\n$(NEOMUTT): $(GENERATED) $(NEOMUTTOBJS) $(MUTTLIBS)\n\t$(CC) -o $@ $(NEOMUTTOBJS) $(MUTTLIBS) $(LDFLAGS) $(LIBS)\n\n# clean\nclean: $(CLEAN_TARGETS)\n\t$(RM) $(CLEANFILES)\n\n# install\ninstall: all $(INSTALL_TARGETS)\n\t# Install binaries\n\t$(INSTALL_DIR) $(DESTDIR)$(bindir)\n\tfor f in $(BINFILES); do \\\n\t\t$(INSTALL) $$f $(DESTDIR)$(bindir)/`basename $$f` || exit 1; \\\n\tdone\n\t$(INSTALL_DIR) $(DESTDIR)$(libexecdir)/$(PACKAGE)\n\tfor f in $(LIBBINFILES); do \\\n\t\t$(INSTALL) $$f $(DESTDIR)$(libexecdir)/$(PACKAGE)/`basename $$f` || exit 1; \\\n\tdone\n\n# uninstall\nuninstall: $(UNINSTALL_TARGETS)\n\t# Uninstall binaries\n\tfor f in $(BINFILES); do \\\n\t\t$(RM) $(DESTDIR)$(bindir)/`basename $$f`; \\\n\tdone\n\tfor f in $(LIBBINFILES); do \\\n\t\t$(RM) $(DESTDIR)$(libexecdir)/$(PACKAGE)/`basename $$f`; \\\n\tdone\n\n# distclean\ndistclean: clean\n\t$(RM) $(DEPFILES) jimsh0 config.h config.log conststrings.c \\\n\t\tcontrib/Makefile docs/Makefile docs/neomutt.1 html Makefile po/Makefile \\\n\t\ttest/Makefile .clang_complete compile_commands.json\n\t$(RM) *.gc?? */*.gc?? test/*/*.gc??\n\t$(RM) *.expand */*.expand test/*/*.expand\n\t$(RM) coverage.info coverage\n\n###############################################################################\n# generated\nGENERATED=\tgit_ver.c hcache/hcversion.h\nCLEANFILES+=\t$(GENERATED)\n\ngit_ver.c: $(ALL_FILES)\n\tversion=`git describe --dirty --abbrev=6 --match \"20[0-9][0-9][0-9][0-9][0-9][0-9]\" 2> /dev/null | \\\n\t\tsed -e 's/^[0-9]\\{8\\}//; s/-g\\([a-z0-9]\\{6\\}\\)/-\\1/'`; \\\n\techo 'const char *GitVer = \"'$$version'\";' > $@.tmp; \\\n\tcmp -s $@.tmp $@ || mv $@.tmp $@; \\\n\t$(RM) $@.tmp\n\nhcache/hcversion.h:\t$(SRCDIR)/address/address.h $(SRCDIR)/email/body.h \\\n\t\t\t$(SRCDIR)/email/email.h $(SRCDIR)/email/envelope.h \\\n\t\t\t$(SRCDIR)/email/parameter.h $(SRCDIR)/hcache/hcachever.sh \\\n\t\t\t$(SRCDIR)/mutt/buffer.h $(SRCDIR)/mutt/list.h\n\t$(MKDIR_P) $(PWD)/hcache\n\t( echo '#include \"config.h\"'; \\\n\techo '#include \"address/address.h\"'; \\\n\techo '#include \"email/body.h\"'; \\\n\techo '#include \"email/email.h\"'; \\\n\techo '#include \"email/envelope.h\"'; \\\n\techo '#include \"email/parameter.h\"'; \\\n\techo '#include \"mutt/buffer.h\"'; \\\n\techo '#include \"mutt/list.h\"';) | $(CPP) $(CFLAGS) - | \\\n\t$(SH) $(SRCDIR)/hcache/hcachever.sh hcache/hcversion.h\n\n###############################################################################\n# coverage\n@if ENABLE_COVERAGE\ncoverage: all test\n\t$(RM) coverage\n\t$(RM) mutt/exit.gc??\n\tlcov --test-name \"test\" --output-file coverage.info --capture \\\n\t  --directory address \\\n\t  --directory color \\\n\t  --directory compress \\\n\t  --directory config \\\n\t  --directory core \\\n\t  --directory editor \\\n\t  --directory email \\\n\t  --directory expando \\\n\t  --directory imap \\\n\t  --directory mutt \\\n\t  --directory notmuch \\\n\t  --directory parse \\\n\t  --directory pattern \\\n\t  --directory store \\\n\t  --directory test/eqi \\\n\t  --exclude '*/atoi.h'\n\t-genhtml --output-directory coverage --frames coverage.info\n\tlcov --list coverage.info\n@endif\n\n##############################################################################\n# include generated dependency files\n-include $(DEPFILES)\n\n##############################################################################\n# include special-purpose makefiles, each one of which MUST define the\n# dedicated all-, clean-, install-, and uninstall- targets.\n@include @srcdir@/po/Makefile.autosetup\n@include @srcdir@/contrib/Makefile.autosetup\n@include @srcdir@/data/Makefile.autosetup\n@include @srcdir@/docs/Makefile.autosetup\n@include @srcdir@/test/Makefile.autosetup\n@if ENABLE_FUZZ_TESTS\n@include @srcdir@/fuzz/Makefile.autosetup\n@endif\n\n@if COMPILE_COMMANDS\ncompile_commands.json: $(ALLOBJS)\n\techo '[' > compile_commands.json\n\tcat $(ALLOBJS:.o=.o.json) >> compile_commands.json\n\techo ']' >> compile_commands.json\n\nclean-compile_commands.json:\n\t$(RM) $(ALLOBJS:.o=.o.json)\n\t$(RM) compile_commands.json\n@endif\n\n# vim: set ts=8 noexpandtab:\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4306640625,
          "content": "# This is the NeoMutt Project\n\n[![Stars](https://img.shields.io/github/stars/neomutt/neomutt.svg?style=social&label=Stars)](https://github.com/neomutt/neomutt \"Give us a Star\")\n[![Twitter](https://img.shields.io/twitter/follow/NeoMutt_Org.svg?style=social&label=Follow)](https://twitter.com/NeoMutt_Org \"Follow us on Twitter\")\n[![Contributors](https://img.shields.io/badge/Contributors-287-orange.svg)](https://github.com/neomutt/neomutt/blob/main/AUTHORS.md \"All of NeoMutt's Contributors\")\n[![Release](https://img.shields.io/github/release/neomutt/neomutt.svg)](https://github.com/neomutt/neomutt/releases/latest \"Latest Release Notes\")\n[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](https://github.com/neomutt/neomutt/blob/main/LICENSE.md \"Copyright Statement\")\n[![Code build](https://github.com/neomutt/neomutt/actions/workflows/build-and-test.yml/badge.svg?branch=main&event=push)](https://github.com/neomutt/neomutt/actions/workflows/build-and-test.yml \"Latest Automatic Code Build\")\n[![Coverity Scan](https://img.shields.io/coverity/scan/8495.svg)](https://scan.coverity.com/projects/neomutt-neomutt \"Latest Code Static Analysis\")\n[![Website build](https://github.com/neomutt/neomutt.github.io/actions/workflows/pages/pages-build-deployment/badge.svg)](https://neomutt.org/ \"Website Build\")\n\n## What is NeoMutt?\n\n* NeoMutt is a project of projects.\n* A place to gather all the patches against Mutt.\n* A place for all the developers to gather.\n\nHopefully this will build the community and reduce duplicated effort.\n\nNeoMutt was created when Richard Russon (@FlatCap) took all the old Mutt patches,\nsorted through them, fixed them up and documented them.\n\n## What Features does NeoMutt have?\n\n| Name                     | Description\n| ------------------------ | ------------------------------------------------------\n| Account Command          | Populate account credentials via an external command\n| Attach Headers Color     | Color attachment headers using regex, just like mail bodies\n| Command-line Crypto (-C) | Enable message security in modes that by default don't enable it\n| Compose to Sender        | Send new mail to the sender of the current mail\n| Compose Message Preview  | Show a preview of the message in the Compose Dialog\n| Compressed Folders       | Read from/write to compressed mailboxes\n| Conditional Dates        | Use rules to choose date format\n| Custom Mailbox Tags      | Implements Notmuch tags and Imap keywords\n| Encrypt-to-Self          | Save a self-encrypted copy of emails\n| Fmemopen                 | Replace some temporary files with memory buffers\n| Forgotten Attachment     | Alert user when (s)he forgets to attach a file to an outgoing email.\n| Global Hooks             | Define actions to run globally within NeoMutt\n| Header Cache Compression | Options for compressing the header cache files\n| Ifdef                    | Conditional config options\n| Index Color              | Custom rules for theming the email index\n| Initials Expando         | Expando for author's initials\n| Kyoto Cabinet            | Kyoto Cabinet backend for the header cache\n| Limit Current Thread     | Focus on one Email Thread\n| LMDB                     | LMDB backend for the header cache\n| Multiple FCC             | Save multiple copies of outgoing mail\n| Nested If                | Allow complex nested conditions in format strings\n| New Mail                 | Execute a command upon the receipt of new mail.\n| NNTP                     | Talk to a Usenet news server\n| Notmuch                  | Email search engine\n| Pager Read Delay         | Delay when the pager marks a previewed message as read\n| Progress Bar             | Show a visual progress bar on slow operations\n| Quasi-Delete             | Mark emails that should be hidden, but not deleted\n| Reply With X-Original-To | Direct reply to email using X-Original-To header\n| Sensible Browser         | Make the file browser behave\n| Sidebar                  | Panel containing list of Mailboxes\n| Skip Quoted              | Leave some context visible\n| Status Color             | Custom rules for theming the status bar\n| TLS-SNI                  | Negotiate with a server for a TLS/SSL certificate\n| Trash Folder             | Automatically move deleted emails to a trash bin\n| Use Threads              | Improve the experience with viewing threads in the index\n\n## Contributed Scripts and Config\n\n| Name                   | Description\n| ---------------------- | ---------------------------------------------\n| Header Cache Benchmark | Script to test the speed of the header cache\n| Keybase                | Keybase Integration\n| Useful programs        | List of useful programs interacting with NeoMutt\n| Vi Keys                | Easy and clean Vi-keys for NeoMutt\n| Vim Syntax             | Vim Syntax File\n\n## How to Install NeoMutt?\n\nNeoMutt may be packaged for your distribution, and otherwise it can be\n[built from source](https://neomutt.org/dev/build/build). Please refer to the\ninstructions on the [distro page](https://neomutt.org/distro.html).\n\n## Where is NeoMutt?\n\n- Source Code:     https://github.com/neomutt/neomutt\n- Releases:        https://github.com/neomutt/neomutt/releases/latest\n- Questions/Bugs:  https://github.com/neomutt/neomutt/issues\n- Website:         https://neomutt.org\n- IRC:             [irc://irc.libera.chat/neomutt](https://web.libera.chat/#neomutt \"IRC Web Client\") - please be patient.\n  We're a small group, so our answer might take some time.\n- Mailing Lists:   [neomutt-users](mailto:neomutt-users-request@neomutt.org?subject=subscribe)\n  and [neomutt-devel](mailto:neomutt-devel-request@neomutt.org?subject=subscribe)\n- Development:     https://neomutt.org/dev.html\n- Contributors:    [Everyone who has helped NeoMutt](AUTHORS.md)\n\n## Copyright\n\nNeoMutt is released under the GPL v2+ (GNU General Public License).\nSee [LICENSE.md](LICENSE.md).\n\nThe principal authors of NeoMutt are:\n\n- Copyright (C) 2015-2024 Richard Russon `<rich@flatcap.org>`\n- Copyright (C) 2016-2023 Pietro Cerutti `<gahr@gahr.ch>`\n- Copyright (C) 2017-2019 Mehdi Abaakouk `<sileht@sileht.net>`\n- Copyright (C) 2018-2020 Federico Kircheis `<federico.kircheis@gmail.com>`\n- Copyright (C) 2017-2022 Austin Ray `<austin@austinray.io>`\n- Copyright (C) 2023-2024 Dennis Schön `<mail@dennis-schoen.de>`\n- Copyright (C) 2016-2017 Damien Riegel `<damien.riegel@gmail.com>`\n- Copyright (C) 2023      Rayford Shireman\n- Copyright (C) 2021-2023 David Purton `<dcpurton@marshwiggle.net>`\n- Copyright (C) 2020-2023 наб `<nabijaczleweli@nabijaczleweli.xyz>`\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.4189453125,
          "content": "## Security Policy\n\nIf you believe you have found a security vulnerability in NeoMutt,\nplease **don't** open a GitHub Issue.\n\nPlease contact the maintainer by email:\n\n[<img align=\"left\" src=\"https://avatars3.githubusercontent.com/u/76760?s=60\">](https://github.com/flatcap)\n\n- Richard Russon ([@flatcap](https://github.com/flatcap)) \\<rich@flatcap.org\\>  \n  `69AD 1D63 6AC2 92E8 2065 8C16 EBC1 50E4 B5DA 63DF`\n\nThank you :heart:\n"
        },
        {
          "name": "address",
          "type": "tree",
          "content": null
        },
        {
          "name": "alias",
          "type": "tree",
          "content": null
        },
        {
          "name": "alternates.c",
          "type": "blob",
          "size": 4.39453125,
          "content": "/**\n * @file\n * Alternate address handling\n *\n * @authors\n * Copyright (C) 2021-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_alternates Alternate address handling\n *\n * Alternate address handling\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alternates.h\"\n#include \"parse/lib.h\"\n#include \"commands.h\"\n#include \"mview.h\"\n\nstatic struct RegexList Alternates = STAILQ_HEAD_INITIALIZER(Alternates); ///< List of regexes to match the user's alternate email addresses\nstatic struct RegexList UnAlternates = STAILQ_HEAD_INITIALIZER(UnAlternates); ///< List of regexes to exclude false matches in Alternates\nstatic struct Notify *AlternatesNotify = NULL; ///< Notifications: #NotifyAlternates\n\n/**\n * alternates_cleanup - Free the alternates lists\n */\nvoid alternates_cleanup(void)\n{\n  notify_free(&AlternatesNotify);\n\n  mutt_regexlist_free(&Alternates);\n  mutt_regexlist_free(&UnAlternates);\n}\n\n/**\n * alternates_init - Set up the alternates lists\n */\nvoid alternates_init(void)\n{\n  if (AlternatesNotify)\n    return;\n\n  AlternatesNotify = notify_new();\n  notify_set_parent(AlternatesNotify, NeoMutt->notify);\n}\n\n/**\n * mutt_alternates_reset - Clear the recipient valid flag of all emails\n * @param mv Mailbox view\n */\nvoid mutt_alternates_reset(struct MailboxView *mv)\n{\n  if (!mv || !mv->mailbox)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n    e->recip_valid = false;\n  }\n}\n\n/**\n * parse_alternates - Parse the 'alternates' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult parse_alternates(struct Buffer *buf, struct Buffer *s,\n                                    intptr_t data, struct Buffer *err)\n{\n  struct GroupList gl = STAILQ_HEAD_INITIALIZER(gl);\n\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (parse_grouplist(&gl, buf, s, err) == -1)\n      goto bail;\n\n    mutt_regexlist_remove(&UnAlternates, buf->data);\n\n    if (mutt_regexlist_add(&Alternates, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n\n    if (mutt_grouplist_add_regex(&gl, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n  } while (MoreArgs(s));\n\n  mutt_grouplist_destroy(&gl);\n\n  mutt_debug(LL_NOTIFY, \"NT_ALTERN_ADD: %s\\n\", buf->data);\n  notify_send(AlternatesNotify, NT_ALTERN, NT_ALTERN_ADD, NULL);\n\n  return MUTT_CMD_SUCCESS;\n\nbail:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_ERROR;\n}\n\n/**\n * parse_unalternates - Parse the 'unalternates' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult parse_unalternates(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    mutt_regexlist_remove(&Alternates, buf->data);\n\n    if (!mutt_str_equal(buf->data, \"*\") &&\n        (mutt_regexlist_add(&UnAlternates, buf->data, REG_ICASE, err) != 0))\n    {\n      return MUTT_CMD_ERROR;\n    }\n\n  } while (MoreArgs(s));\n\n  mutt_debug(LL_NOTIFY, \"NT_ALTERN_DELETE: %s\\n\", buf->data);\n  notify_send(AlternatesNotify, NT_ALTERN, NT_ALTERN_DELETE, NULL);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * mutt_alternates_match - Compare an Address to the Un/Alternates lists\n * @param addr Address to check\n * @retval true Address matches\n */\nbool mutt_alternates_match(const char *addr)\n{\n  if (!addr)\n    return false;\n\n  if (mutt_regexlist_match(&Alternates, addr))\n  {\n    mutt_debug(LL_DEBUG5, \"yes, %s matched by alternates\\n\", addr);\n    if (mutt_regexlist_match(&UnAlternates, addr))\n      mutt_debug(LL_DEBUG5, \"but, %s matched by unalternates\\n\", addr);\n    else\n      return true;\n  }\n\n  return false;\n}\n"
        },
        {
          "name": "alternates.h",
          "type": "blob",
          "size": 1.732421875,
          "content": "/**\n * @file\n * Alternate address handling\n *\n * @authors\n * Copyright (C) 2021-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_ALTERNATES_H\n#define MUTT_ALTERNATES_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct MailboxView;\n\n/**\n * enum NotifyAlternates - Alternates command notification types\n *\n * Observers of #NT_ALTERN will not be passed any Event data.\n *\n * @note Notifications are sent **after** the event.\n */\nenum NotifyAlternates\n{\n  NT_ALTERN_ADD = 1,    ///< Alternate address has been added\n  NT_ALTERN_DELETE,     ///< Alternate address has been deleted\n  NT_ALTERN_DELETE_ALL, ///< All Alternate addresses have been deleted\n};\n\nvoid alternates_init(void);\nvoid alternates_cleanup(void);\n\nenum CommandResult parse_alternates  (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unalternates(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\n\nbool mutt_alternates_match(const char *addr);\nvoid mutt_alternates_reset(struct MailboxView *mv);\n\n#endif /* MUTT_ALTERNATES_H */\n"
        },
        {
          "name": "attach",
          "type": "tree",
          "content": null
        },
        {
          "name": "auto.def",
          "type": "blob",
          "size": 39.5830078125,
          "content": "# vim: set ft=tcl syntax=tcl ts=2 sw=2 expandtab:\n\n# Make sure we use /usr as a default prefix on Linux; we can't use $host_\n# variables because this needs to go before the inclusion of the system module.\nif {![catch {exec uname} out] && $out eq {Linux}} {\n  options-defaults {\n    prefix /usr\n  }\n}\n\nautosetup-require-version 0.6.9\n\n# Standard autosetup modules and our own modules\nuse system cc cc-lib mutt-gettext mutt-iconv pkg-config\n\n###############################################################################\n# Names and versions\ndefine PACKAGE          \"neomutt\"\ndefine PACKAGE_VERSION  \"20250109\"\ndefine BUGS_ADDRESS     \"neomutt-devel@neomutt.org\"\n\n# Subdirectories that contain additional Makefile.autosetup files\nset subdirs {po data docs contrib test}\n###############################################################################\n\n###############################################################################\n# Add any user options here\nset valid_options {\n# Curses\n  with-ncurses:path         => \"Location of ncurses\"\n# Features w/o 3rd party dependencies\n  doc=1                     => \"Disable building the documentation\"\n  full-doc=0                => \"Build the full documentation set\"\n  docdir:path               => \"Documentation root\"\n  with-lock:=fcntl          => \"Select fcntl() or flock() to lock files\"\n  fmemopen=0                => \"Use fmemopen() for temporary in-memory files\"\n  inotify=1                 => \"Disable file monitoring support (Linux only)\"\n  locales-fix=0             => \"Enable locales fix\"\n  pgp=1                     => \"Disable PGP support\"\n  smime=1                   => \"Disable SMIME support\"\n  homespool=0               => \"Enable new mail spooling in the user's HOME\"\n  with-homespool:mailbox    => \"File in the user's HOME where new mail is spooled\"\n  with-mailpath:/var/mail   => \"Directory where spool mailboxes are located\"\n  with-domain:domain        => \"Specify your DNS domain name\"\n# Crypto\n  # OpenSSL or GnuTLS\n  ssl=0                     => \"Enable TLS support using OpenSSL\"\n  with-ssl:path             => \"Location of OpenSSL\"\n  gnutls=0                  => \"Enable TLS support using GnuTLS\"\n  with-gnutls:path          => \"Location of GnuTLS\"\n  # GPGME\n  gpgme=0                   => \"Enable GPGME support\"\n  # GSS (IMAP auth)\n  gss=0                     => \"Use GSSAPI authentication for IMAP\"\n  with-gss:path             => \"Location of GSSAPI library\"\n  # SASL (IMAP and POP auth)\n  gsasl=0                   => \"Use the GNU SASL network security library\"\n  with-gsasl:path           => \"Location of the GNU SASL network security library\"\n  sasl=0                    => \"Use the SASL network security library\"\n  with-sasl:path            => \"Location of the SASL network security library\"\n  # AutoCrypt\n  autocrypt=0               => \"Enable AutoCrypt support (requires GPGME and SQLite)\"\n# Lua\n  lua=0                     => \"Enable Lua scripting support\"\n  with-lua:path             => \"Location of Lua\"\n# Notmuch\n  notmuch=0                 => \"Enable Notmuch support\"\n  with-notmuch:path         => \"Location of Notmuch\"\n# NLS\n  nls=1                     => \"Disable Native Language Support\"\n  with-nls:path             => \"Location of libintl\"\n# IDN\n  idn2=1                    => \"Disable GNU libidn2 for internationalized domain names\"\n  with-idn2:path            => \"Location of GNU libidn2\"\n# PCRE2\n  pcre2=0                   => \"Enable PCRE2 regular expressions\"\n  with-pcre2:path           => \"Location of PCRE2\"\n# Header cache\n  bdb=0                     => \"Use BerkeleyDB for the header cache\"\n  with-bdb:path             => \"Location of BerkeleyDB\"\n  with-bdb-version:version  => \"Version of BerkeleyDB\"\n  gdbm=0                    => \"Use GNU dbm for the header cache\"\n  with-gdbm:path            => \"Location of GNU dbm\"\n  kyotocabinet=0            => \"Use KyotoCabinet for the header cache\"\n  with-kyotocabinet:path    => \"Location of KyotoCabinet\"\n  lmdb=0                    => \"Use LMDB for the header cache\"\n  with-lmdb:path            => \"Location of LMDB\"\n  qdbm=0                    => \"Use QDBM for the header cache\"\n  with-qdbm:path            => \"Location of QDBM\"\n  rocksdb=0                 => \"Use RocksDB for the header cache\"\n  with-rocksdb:path         => \"Location of RocksDB\"\n  tdb=0                     => \"Use TDB for the header cache\"\n  with-tdb:path             => \"Location of TDB\"\n  tokyocabinet=0            => \"Use TokyoCabinet for the header cache\"\n  with-tokyocabinet:path    => \"Location of TokyoCabinet\"\n# sqlite\n  sqlite=0                  => \"Enable SQLite support\"\n  with-sqlite:path          => \"Location of SQLite\"\n# compression\n  lz4=0                     => \"Enable LZ4 header cache compression support\"\n  zlib=0                    => \"Enable zlib support\"\n  with-zlib:path            => \"Location of zlib\"\n  zstd=0                    => \"Enable Zstandard header cache compression support\"\n# iconv\n  with-iconv:path           => \"Location of IConv\"\n# System\n  with-sysroot:path         => \"Target system root\"\n  with-tmpdir:=/tmp         => \"location of the tmp directory\"\n# Misc\n  paths-in-cflags=1         => \"Remove paths from CFLAGS in the output of neomutt -v\"\n# Testing\n  asan=0                    => \"Enable the Address Sanitizer\"\n  ubsan=0                   => \"Enable the Undefined Behaviour Sanitizer\"\n  coverage=0                => \"Enable Coverage Testing\"\n  fuzzing                   => \"Enable Fuzz Testing\"\n  compile-commands          => \"Generate compile_commands.json (requires clang)\"\n# Enable all options\n  everything=0              => \"Enable all options\"\n# Debug options\n  debug-backtrace=0         => \"DEBUG: Enable backtrace support with libunwind\"\n  with-backtrace:path       => \"Location of libunwind\"\n  debug-color=0             => \"DEBUG: Enable Color dump\"\n  debug-email=0             => \"DEBUG: Enable Email dump\"\n  debug-graphviz=0          => \"DEBUG: Enable Graphviz dump\"\n  debug-keymap=0            => \"DEBUG: Enable Key mappings dump\"\n  debug-logging=0           => \"DEBUG: Enable Debug logging\"\n  debug-names=0             => \"DEBUG: Enable Name lookup tables\"\n  debug-notify=0            => \"DEBUG: Enable Notifications dump\"\n  debug-queue=0             => \"DEBUG: Enable TAILQ debugging\"\n  debug-window=0            => \"DEBUG: Enable Windows dump\"\n}\n\nset deprecated_options  {\n  idn:\n  with-idn:=\n  pkgconf:=\n  testing:=\n  with-slang:\n  with-ui:=\n  with-gpgme:\n  with-lz4:\n  with-zstd:\n  include-path-in-cflags:=\n  mixmaster:=\n  with-mixmaster:=\n}\n\nforeach dep $deprecated_options {\n  append valid_options \"${dep}deprecated => Deprecated\\n\"\n}\n\noptions $valid_options\n###############################################################################\n\n###############################################################################\n# Issue a warning for deprecated options on the command line\nset notices {}\nforeach dep $deprecated_options {\n  lassign [split $dep :] name\n  if {[opt-bool -nodefault $name] != -1} {\n    lappend notices --$name\n  }\n}\nif {[llength $notices]} {\n  user-notice \"\\nThe following options are deprecated: [join $notices {, }]\\n\"\n}\n###############################################################################\n\n###############################################################################\n# All boolean options are converted to want-* definitions here. Further down,\n# their values is checked with [get-define opt].  This facilitates the handling\n# of dependencies among options (see \"everything\").\nif {1} {\n  # Keep sorted, please.\n  foreach opt {\n    asan autocrypt bdb compile-commands coverage debug-backtrace debug-color\n    debug-email debug-graphviz debug-keymap debug-logging debug-names\n    debug-notify debug-queue debug-window doc everything fmemopen full-doc\n    fuzzing gdbm gnutls gpgme gsasl gss homespool idn2 inotify kyotocabinet\n    lmdb locales-fix lua lz4 nls notmuch paths-in-cflags pcre2 pgp\n    qdbm rocksdb sasl smime sqlite ssl tdb\n    tokyocabinet ubsan zlib zstd\n  } {\n    define want-$opt [opt-bool $opt]\n  }\n\n  # These options support a --with-opt parameter. If that is set, force the\n  # relative --enable-opt to true. This allows \"--with-opt=/usr\" to be used as\n  # a shortcut for \"--opt --with-opt=/usr\".\n  foreach opt {\n    bdb gdbm gnutls gpgme gsasl gss homespool idn2 kyotocabinet lmdb lua lz4\n    nls notmuch pcre2 qdbm rocksdb sasl sqlite ssl tdb tokyocabinet\n    zlib zstd\n  } {\n    if {[opt-val with-$opt] ne {}} {\n      define want-$opt 1\n    }\n  }\n\n  # No more usage of [opt-bool] below this point.\n  proc opt-bool {args} {\n    user-error \"opt-bool should not be called here\"\n  }\n}\n###############################################################################\n\n###############################################################################\n# Paths\ndefine BINDIR           [get-define bindir]\ndefine MUTTLOCALEDIR    [get-define datadir]/locale\ndefine PKGDATADIR       [get-define datadir]/neomutt\ndefine PKGDOCDIR        [opt-val docdir [get-define datadir]/doc/neomutt]\ndefine SYSCONFDIR       [get-define sysconfdir]\ndefine TMPDIR           [opt-val with-tmpdir /tmp]\nset libdir_tail         [file tail [get-define libdir]] ;# used only locally\n###############################################################################\n\n###############################################################################\n# Helper functions\nif {1} {\n  # Check for a header file and a function in a library\n  proc check-inc-and-lib {name prefix header fun lib} {\n    cc-with [list -cflags -I$prefix/include -libs -L$prefix/$::libdir_tail] {\n      if {[cc-check-includes $header] && [cc-check-function-in-lib $fun $lib]} {\n        define-append CFLAGS  -I$prefix/include\n        define-append LDFLAGS -L$prefix/$::libdir_tail\n        define-feature $name\n      }\n    }\n    have-feature $name\n  }\n\n  proc check-define {incfile macro} {\n    set code {}\n    if {$incfile ne {}} {\n      append code \"#include \\\"$incfile\\\"\\n\"\n    }\n    append code \"#ifndef $macro\\n#error \\\"$macro not defined\\\"\\n#endif\\n$macro\"\n    if {[catch {exec {*}[get-define CC] {*}[get-define CFLAGS] -xc - -E | tail -1 << $code} out]} {\n      error\n    }\n    set out\n  }\n\n  # Check whether a macro is defined after preprocessing a header file\n  proc has-define {incfile macro} {\n    expr {[catch {check-define $incfile $macro}] == 0}\n  }\n\n  # Get the value of a macro by preprocessing a header file that defines it\n  proc get-define-value {incfile macro} {\n    if {![catch {check-define $incfile $macro} out]} {\n      return $out\n    }\n  }\n\n  # Convert a string into a representation suitable for a C char[]\n  proc text2c {s} {\n    set result \"\\n  \"\n    set i 0\n    foreach c [split $s {}] {\n      append result \"0x[format %02x [scan $c %c]], \"\n      if {[expr {[incr i] % 12 == 0}]} {\n        append result \"\\n  \"\n        set i 0\n      }\n    }\n    append result \"0x00\\n\";\n  }\n\n  # Guess what..\n  proc yesno val {\n    expr {$val ? \"yes\" : \"no\"}\n  }\n\n  # Wrapper around pkg-config, to optionally fail is a pkg is not found, and to\n  # add the compile/link definitions for the module.\n  proc pkgconf {required module args} {\n    if {[pkg-config $module {*}$args]} {\n\n      # Add only non-duplicate CFLAGS and LDFLAGS\n      foreach which {CFLAGS LDFLAGS} {\n        foreach flag [pkg-config-get $module $which] {\n          if {$flag ni [get-define $which]} {\n            define-append $which $flag\n          }\n        }\n      }\n      # Order of libraries matter, so we cannot skip duplicates\n      define-append LIBS [pkg-config-get $module LIBS]\n      return 1\n    } elseif {[string is bool $required] && $required} {\n      user-error \"$module $args\"\n    } else {\n      return 0\n    }\n  }\n\n  # lkill l p is the list of the elements in l that don't match p\n  proc lkill {l p} {\n    set res [list]\n    foreach elem $l {\n      if {![apply $p $elem]} {\n        lappend res $elem\n      }\n    }\n    set res\n  }\n}\n###############################################################################\n\n###############################################################################\n# C compiler definitions and related tools\nif {1} {\n\n  # First off, require c11\n  if {[cc-check-standards c11] eq {}} {\n    user-error \"C11 is required\"\n  }\n  define-append CFLAGS_FOR_BUILD -std=c11\n  define-append CFLAGS -std=c11\n  define LDFLAGS_FOR_BUILD {}\n\n  # Check for tools and programs\n  cc-check-tools ar ranlib strip\n  cc-check-progs install\n  if {![cc-path-progs sendmail]} {\n    define SENDMAIL /usr/sbin/sendmail\n  }\n\n  # Compiler vendor\n  if {[has-define {} __clang__]} {\n    define COMPILER_IS_CLANG\n  } elseif {[has-define {} __GNUC__]} {\n    define COMPILER_IS_GCC\n  } else {\n    define COMPILER_IS_UNKNOWN\n  }\n\n  # GCC-specifc CFLAGS\n  if {[get-define COMPILER_IS_GCC]} {\n    define-append CFLAGS \"-fno-delete-null-pointer-checks\"\n  }\n\n  # Enable extensions (reverse-engineered from AC_SYSTEM_EXTENSIONS)\n  if {1} {\n    if {[cc-check-includes minix/config.h]} {\n      lappend extensions -D_POSIX_SOURCE=1\n      lappend extensions -D_POSIX_1_SOURCE=2\n      lappend extensions -D_MINIX=1\n    }\n    lappend extensions -D_ALL_SOURCE=1\n    lappend extensions -D_GNU_SOURCE=1\n    lappend extensions -D__EXTENSIONS__\n    lappend extensions -D_XOPEN_SOURCE_EXTENDED\n    define-append CFLAGS_FOR_BUILD {*}$extensions\n    define-append CFLAGS {*}$extensions\n  }\n  cc-with [list -cflags [get-define CFLAGS]]\n\n  # Endianness\n  cc-check-endian\n  if {[have-feature BIG_ENDIAN]} {\n    define WORDS_BIGENDIAN\n  }\n\n  # Large file support\n  if {[cc-check-lfs]} {\n    define OFF_T_FMT {\"%\" PRId64}\n  } else {\n    define OFF_T_FMT {\"%\" PRId32}\n  }\n  define LOFF_T off_t\n}\n###############################################################################\n\n###############################################################################\n# signal-related checks\ncc-check-includes signal.h\n\ncc-with {-includes \"signal.h unistd.h\"} {\n  cc-check-decls sys_siglist\n}\n###############################################################################\n\n###############################################################################\n# Check for includes and functions that in the code are surrounded by\n# '#ifdef HAVE_FOO_H' and '#ifdef HAVE_FUNCTION' and for functions that might\n# be in different libraries\nif {1} {\n  cc-check-includes \\\n    ioctl.h \\\n    termios.h \\\n    sys/ioctl.h \\\n    syscall.h \\\n    sys/random.h \\\n    sys/syscall.h \\\n    sysexits.h\n\n  cc-check-functions \\\n    clock_gettime \\\n    fgetc_unlocked \\\n    futimens \\\n    getaddrinfo \\\n    getrandom \\\n    getsid \\\n    iswblank \\\n    mkdtemp \\\n    qsort_s \\\n    reallocarray \\\n    strsep \\\n    strcasestr \\\n    tcgetwinsize \\\n    timegm \\\n    utimesnsat \\\n    vasprintf \\\n    wcscasecmp\n\n  # The following systems have known-bad qsort_r with reversed arguments\n  if {![has-define sys/param.h __FreeBSD_version] &&\n      ![has-define {} __APPLE__]} {\n    cc-check-functions qsort_r\n  }\n\n  cc-check-function-in-lib gethostent nsl\n  cc-check-function-in-lib setsockopt socket\n  cc-check-function-in-lib getaddrinfo_a anl\n  cc-check-function-in-lib nanosleep rt\n\n  cc-with {-includes sys/stat.h} {\n    cc-check-members \"struct stat.st_atim.tv_nsec\"\n  }\n\n  cc-with {-includes time.h} {\n    cc-check-members \"struct tm.tm_gmtoff\"\n  }\n}\n###############################################################################\n\n###############################################################################\n# Various unconditional defines\ndefine TEST_CASE_MAXSIZE 1024\n###############################################################################\n\nset prefix [opt-val with-sysroot][get-define prefix]\n\n###############################################################################\n# Everything\nif {[get-define want-everything]} {\n  foreach opt {bdb gdbm gpgme kyotocabinet lmdb lua lz4 notmuch pgp rocksdb\n               qdbm sasl smime ssl tokyocabinet tdb zlib zstd} {\n    define want-$opt\n    append conf_options \"--$opt \"\n  }\n} else {\n  set conf_options \"$::argv\"\n}\n\n###############################################################################\n# Locking\nswitch [opt-val with-lock fcntl] {\n  fcntl {\n    define USE_FCNTL\n  }\n\n  flock {\n    define USE_FLOCK\n  }\n\n  default {\n    user-error \"Invalid value for --with-lock=[opt-val with-lock], select fcntl\\\n                or flock\"\n  }\n}\n\n###############################################################################\n# Locales fix\nif {[get-define want-locales-fix]} {define LOCALES_HACK}\n\n###############################################################################\n# Documentation\nif {[get-define want-doc]} {\n  if {![cc-check-progs xsltproc]} {\n    user-error \"Unable to find xsltproc\"\n  }\n\n  msg-checking \"Checking for DocBook DTDs...\"\n  set res [exec xmlcatalog --shell << {public \"-//OASIS//DTD DocBook XML V4.2//EN\"}]\n  if {[string match {> No entry*} $res]} {\n    msg-result \"no\"\n    user-error \"Install DocBook DTDs or './configure --disable-doc'\"\n  }\n  msg-result \"yes\"\n\n  define BUILD_DOC\n}\nif {[get-define want-full-doc]} {define MAKEDOC_FULL}\n\n###############################################################################\n# AutoCrypt\nif {[get-define want-autocrypt]} {\n  define USE_AUTOCRYPT\n  define want-sqlite 1\n  define want-gpgme 1\n}\n\n###############################################################################\n# GPGME\nif {[get-define want-gpgme]} {\n  if {[is-defined _FILE_OFFSET_BITS]} {\n    define-append CFLAGS -D_FILE_OFFSET_BITS=[get-define _FILE_OFFSET_BITS]\n  }\n  pkgconf true gpgme\n  pkgconf true gpg-error\n  define CRYPT_BACKEND_GPGME\n}\n\n###############################################################################\n# INOTIFY\nif {[get-define want-inotify]} {\n  if {[cc-check-functions inotify_add_watch inotify_init inotify_rm_watch]} {\n    define USE_INOTIFY\n    cc-check-functions inotify_init1\n    cc-check-includes sys/inotify.h\n  }\n}\n\n###############################################################################\n# PGP\nif {[get-define want-pgp]} {\n  define-feature PGP\n  define CRYPT_BACKEND_CLASSIC_PGP\n}\n\n###############################################################################\n# SMIME\nif {[get-define want-smime]} {\n  define-feature SMIME\n  define CRYPT_BACKEND_CLASSIC_SMIME\n}\n\n###############################################################################\n# GNU SASL\nif {[get-define want-gsasl] && [get-define want-sasl]} {\n  user-error \"Cannot specify both --gsasl and --sasl\"\n}\nif {[get-define want-gsasl]} {\n  pkgconf true libgsasl\n  define USE_SASL_GNU\n  define-feature SASL\n}\n\n###############################################################################\n# SASL\nif {[get-define want-sasl]} {\n  if {[pkgconf false libsasl2]} {\n    define-feature SASL\n  } elseif {![check-inc-and-lib sasl [opt-val with-sasl $prefix] \\\n                                sasl/sasl.h sasl_encode64 sasl2]} {\n    user-error \"Unable to find SASL\"\n  }\n  define USE_SASL_CYRUS\n}\n\n###############################################################################\n# Lua\nif {[get-define want-lua]} {\n\n  if {![pkgconf false lua] && ![pkgconf false lua-5.4] && ![pkgconf false lua-5.3] && ![pkgconf false lua-5.2] \\\n                           && ![pkgconf false lua5.4]  && ![pkgconf false lua5.3]  && ![pkgconf false lua5.2]} {\n    user-error \"Unable to find LUA\"\n  }\n  define USE_LUA\n}\n\n###############################################################################\n# Notmuch\nif {[get-define want-notmuch]} {\n  if {![check-inc-and-lib notmuch [opt-val with-notmuch $prefix] \\\n                          notmuch.h notmuch_database_open notmuch]} {\n    user-error \"Unable to find Notmuch\"\n  }\n  define USE_NOTMUCH\n  msg-checking \"Checking for Notmuch API version 3...\"\n  if {[cctest -includes {notmuch.h} -libs {-lnotmuch} -link 1 \\\n      -code { notmuch_database_open(NULL, 0, NULL); }]} {\n    define NOTMUCH_API_3\n    msg-result \"yes\"\n  } else {\n    msg-result \"no\"\n  }\n  cc-check-function-in-lib notmuch_database_index_file notmuch\n  cc-check-function-in-lib notmuch_database_open_with_config notmuch\n}\n\n###############################################################################\n# Native Language Support (NLS)\nif {[get-define want-nls]} {\n  if {![check-gettext [opt-val with-nls $prefix]]} {\n    user-error \"Unable to find gettext. Consider --disable-nls\"\n  }\n  if {![cc-check-progs msgfmt msgmerge xgettext]} {\n    user-error \"Unable to find gettext tools (msgfmt, msgmerge, xgettext).\\\n                Consider --disable-nls\"\n  }\n}\n\n###############################################################################\n# SQLite Support\nif {[get-define want-sqlite]} {\n  if {![check-inc-and-lib sqlite [opt-val with-sqlite $prefix] \\\n                          sqlite3.h sqlite3_open sqlite3]} {\n    user-error \"Unable to find SQLite\"\n  }\n  define USE_SQLITE\n}\n\n###############################################################################\n# zlib Support\nif {[get-define want-zlib]} {\n  if {![check-inc-and-lib zlib [opt-val with-zlib $prefix] \\\n                          zlib.h deflate z]} {\n    user-error \"Unable to find zlib\"\n  }\n  define USE_ZLIB\n}\n\n###############################################################################\n# fmemopen(3)\nif {[get-define want-fmemopen]} {\n  if {![cc-check-functions fmemopen]} {\n    user-error \"Unable to find fmemopen\"\n  }\n  if {![cc-check-functions open_memstream]} {\n    user-error \"Unable to find open_memstream\"\n  }\n  define USE_FMEMOPEN 1\n} else {\n  define USE_FMEMOPEN 0\n}\n\n###############################################################################\n# Ncurses\ndefine-append CFLAGS -DNCURSES_WIDECHAR\nset ncurses_prefix [opt-val with-ncurses $prefix]\n\ncc-with [list -libs -L$ncurses_prefix/$::libdir_tail] {\n\n  set tinfo_libs   {tinfow tinfo terminfo}\n  set ncurses_libs {ncursesw ncurses curses}\n\n  # Locate the library defining tgetent()\n  # This must be done *before* checking for ncurses functions, see\n  # https://github.com/neomutt/neomutt/issues/1118\n  foreach tinfo_lib [concat $tinfo_libs $ncurses_libs] {\n    if {[cc-check-function-in-lib tgetent $tinfo_lib]} {\n      break\n    }\n  }\n\n  # Locate the library defining waddnwstr()\n  foreach ncurses_lib $ncurses_libs {\n    if {[cc-check-function-in-lib waddnwstr $ncurses_lib]} {\n      break\n    }\n  }\n\n  if {![have-feature waddnwstr] || ![have-feature tgetent]} {\n    user-error \"Unable to find ncursesw library\"\n  }\n\n  foreach f {bkgrndset setcchar use_extended_names} {\n    cc-check-function-in-lib $f $ncurses_lib\n  }\n\n  define-append CFLAGS -I$ncurses_prefix/include\n  define-append LDFLAGS -L$ncurses_prefix/$::libdir_tail\n}\n\n# Locate the directory containing ncurses.h\n# See https://github.com/neomutt/neomutt/pull/679\napply {{ncurses_prefix} {\n  cc-with [list -cflags -I$ncurses_prefix/include] {\n    foreach ncurses_inc {ncursesw/ ncurses/ curses/ {}} {\n      if {[cc-check-includes ${ncurses_inc}ncurses.h] ||\n          [cc-check-includes ${ncurses_inc}curses.h]} {\n        return\n      }\n    }\n    user-error \"Unable to find ncurses headers\"\n  }\n}} $ncurses_prefix\n\n###############################################################################\n# Iconv - try to mimic AM_ICONV by preferring an installed libiconv\nif {![check-iconv [opt-val with-iconv $prefix]]} {\n  user-error \"Unable to find iconv()\"\n}\n\n###############################################################################\n# Mailpath and homespool\nif {[get-define want-homespool]} {\n  define MAILPATH [opt-val with-homespool mailbox]\n  define HOMESPOOL 1\n} else {\n  define MAILPATH [opt-val with-mailpath /var/mail]\n}\n\n###############################################################################\n# Domain\nif {[opt-val with-domain] ne {}} {\n  define DOMAIN [opt-val with-domain]\n}\n\n###############################################################################\n# TLS support\nif {[get-define want-ssl] && ![get-define want-gnutls]} {\n  # OpenSSL\n  if {[pkgconf false openssl]} {\n    # cool - we do not make pkg-config mandatory for OpenSSL because BSDs still\n    # ship OpenSSL in the base system. Those aren't available through\n    # pkg-config.\n  } else {\n    set ssl_prefix [opt-val with-ssl $prefix]\n    set ssl_cflags -I$ssl_prefix/include\n    set ssl_ldflags -L$ssl_prefix/$::libdir_tail\n    cc-with [list -libs $ssl_ldflags -cflags $ssl_cflags] {\n      if {![cc-check-includes openssl/bio.h openssl/err.h openssl/ssl.h] ||\n          ![cc-check-function-in-lib X509_STORE_CTX_new crypto] ||\n          ![cc-check-function-in-lib SSL_new ssl] ||\n          ![cc-with {-includes openssl/ssl.h} {cc-check-decls SSL_set_mode}]} {\n        user-error \"Unable to find OpenSSL\"\n      }\n      define-append CFLAGS $ssl_cflags\n      define-append LDFLAGS $ssl_ldflags\n    }\n  }\n\n  cc-check-functions RAND_egd\n  cc-check-function-in-lib deflate z\n  define USE_SSL\n  define USE_SSL_OPENSSL\n  if {[cc-with {-includes openssl/ssl.h} {\n      cc-check-decls X509_V_FLAG_PARTIAL_CHAIN}]} {\n    define-feature SSL_PARTIAL_CHAIN\n  }\n} elseif {[get-define want-gnutls]} {\n  # GnuTLS\n  pkgconf true gnutls\n  cc-check-function-in-lib gnutls_priority_set_direct gnutls\n  cc-with {-includes {gnutls/x509.h gnutls/gnutls.h}} {\n    cc-check-decls GNUTLS_VERIFY_DISABLE_TIME_CHECKS\n    cc-check-types gnutls_certificate_credentials_t \\\n      gnutls_certificate_status_t \\\n      gnutls_datum_t \\\n      gnutls_digest_algorithm_t \\\n      gnutls_session_t \\\n      gnutls_transport_ptr_t \\\n      gnutls_x509_crt_t\n  }\n  define USE_SSL\n  define USE_SSL_GNUTLS\n}\n\n###############################################################################\n# GNU libidn\nif {[get-define want-idn2]} {\n  proc find-idn2-includes {} {\n    # These are used to figure which header to include\n    if {!([cc-check-includes idn2.h] || [cc-check-includes idn/idn2.h])} {\n      user-error \"Unable to find GNU libidn2\"\n    }\n  }\n  pkgconf true libidn2\n  find-idn2-includes\n  if {![cc-check-function-in-lib idn2_to_ascii_8z     idn2] ||\n      ![cc-check-function-in-lib idn2_to_unicode_8z8z idn2] ||\n      ![cc-check-function-in-lib idn2_check_version   idn2]} {\n    user-error \"Unable to find required functions in GNU libidn2\"\n  }\n  define-feature libidn\n}\n\n###############################################################################\n# PCRE2\nif {[get-define want-pcre2]} {\n  pkgconf true libpcre2-8\n  define-feature pcre2\n} elseif {[cc-check-functions pcre2_regcomp]} {\n  # See https://bugs.exim.org/show_bug.cgi?id=2707 and\n  # https://github.com/neomutt/neomutt/issues/2865\n  user-error \"Found libpcre2-posix: please reconfigure with --pcre2\"\n}\n\n###############################################################################\n# Header cache - bdb\nif {[get-define want-bdb]} {\n  proc find_bdb {bdb_prefix maj min path_tail lib_names} {\n    set ver_inc_dir $bdb_prefix/include/$path_tail\n    set ver_lib_dir $bdb_prefix/$::libdir_tail/$path_tail\n    set ver_inc_file $ver_inc_dir/db.h\n\n    # File exists?\n    msg-checking \"Checking for BerkeleyDB in $ver_inc_dir...\"\n    if {![file exists $ver_inc_file]} {\n      msg-result \"no\"\n      return 0\n    }\n\n    # Version is coherent?\n    set inc_maj [get-define-value $ver_inc_file DB_VERSION_MAJOR]\n    set inc_min [get-define-value $ver_inc_file DB_VERSION_MINOR]\n    if {$inc_maj eq {}   || $inc_min eq {} ||\n        $inc_maj != $maj || $inc_min != $min} {\n      msg-result \"no (expecting $maj.$min, got $inc_maj.$inc_min)\"\n      return 0\n    }\n    msg-result \"yes\"\n\n    # Can link?\n    foreach lib_name $lib_names {\n      cc-with [list -libs -L$ver_lib_dir -cflags -I$ver_inc_dir] {\n        check-inc-and-lib bdb {} db.h db_env_create $lib_name\n      }\n      if {[have-feature bdb]} {\n        define-append CFLAGS  -I$ver_inc_dir\n        define-append LDFLAGS -L$ver_lib_dir\n        define-append LIBS    -l$lib_name\n        define-append HCACHE_BACKENDS \"bdb\"\n        define USE_HCACHE\n        return 1\n      }\n    }\n    return 0\n  }\n\n  set bdb_versions [opt-val with-bdb-version { 18.1 5.3 6.2 4.8 }] ;# Will be checked in order\n  set bdb_prefix [opt-val with-bdb $prefix]\n\n  foreach ver $bdb_versions {\n    lassign [split $ver .] maj min\n    foreach path_tail [list \"\" db-$maj-$min db${maj}${min} db$maj.$min db-$maj db$maj] {\n      set lib_names [list db$maj-$maj.$min db$maj-$maj db-$maj.$min db-$maj]\n      if {[find_bdb $bdb_prefix $maj $min $path_tail $lib_names]} {\n        break\n      }\n    }\n    if {[have-feature bdb]} {\n      break\n    }\n  }\n\n  if {![have-feature bdb]} {\n    user-error \"Unable to find BerkeleyDB\"\n  }\n}\n\n###############################################################################\n# Header cache - QDBM\n# Note: qdbm must come before gdbm because they share library symbols.\nif {[get-define want-qdbm]} {\n  pkgconf true qdbm\n  define-feature qdbm\n  define-append HCACHE_BACKENDS \"qdbm\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header Cache - GNU dbm\nif {[get-define want-gdbm]} {\n  if {![check-inc-and-lib gdbm [opt-val with-gdbm $prefix] \\\n                          gdbm.h gdbm_count gdbm]} {\n    user-error \"Unable to find GNU dbm\"\n  }\n  define-append HCACHE_BACKENDS \"gdbm\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header cache - LMDB\nif {[get-define want-lmdb]} {\n  if {[pkgconf false lmdb]} {\n    define-feature lmdb\n  } elseif {![check-inc-and-lib lmdb [opt-val with-lmdb $prefix] \\\n                                lmdb.h mdb_env_create lmdb]} {\n    user-error \"Unable to find LMDB\"\n  }\n  define-append HCACHE_BACKENDS \"lmdb\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header cache - KyotoCabinet\nif {[get-define want-kyotocabinet]} {\n  pkgconf true kyotocabinet\n  define-feature kc\n  define-append HCACHE_BACKENDS \"kyotocabinet\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header cache - RocksDB\nif {[get-define want-rocksdb]} {\n  if {![check-inc-and-lib rocksdb [opt-val with-rocksdb $prefix] \\\n                          rocksdb/c.h rocksdb_open rocksdb]} {\n    user-error \"Unable to find RocksDB\"\n  }\n  define-append HCACHE_BACKENDS \"rocksdb\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header Cache - TDB\nif {[get-define want-tdb]} {\n  pkgconf true tdb\n  define-feature tdb\n  define-append HCACHE_BACKENDS \"tdb\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header Cache - TokyoCabinet\nif {[get-define want-tokyocabinet]} {\n  pkgconf true tokyocabinet\n  define-feature tc\n  define-append HCACHE_BACKENDS \"tokyocabinet\"\n  define USE_HCACHE\n}\n\n###############################################################################\n# Header Cache Compression with LZ4\nif {[get-define want-lz4]} {\n  pkgconf true liblz4\n  define USE_LZ4\n  define-feature lz4\n  define USE_HCACHE_COMPRESSION\n  define-append COMPRESS_BACKENDS \"lz4\"\n}\n\n###############################################################################\n# Header Cache Compression with zlib\nif {[get-define want-zlib]} {\n  if {![check-inc-and-lib zlib [opt-val with-zlib $prefix] \\\n                          zlib.h deflate z]} {\n    user-error \"Unable to find zlib\"\n  }\n  define-append LIBS -lz\n  define USE_ZLIB\n  define USE_HCACHE_COMPRESSION\n  define-append COMPRESS_BACKENDS \"zlib\"\n}\n\n###############################################################################\n# Header Cache Compression with Zstandard\nif {[get-define want-zstd]} {\n  pkgconf true libzstd\n  define USE_ZSTD\n  define-feature zstd\n  define USE_HCACHE_COMPRESSION\n  define-append COMPRESS_BACKENDS \"zstd\"\n}\n\n###############################################################################\n# GSS\nif {[get-define want-gss]} {\n\n  # TODO - Use krb5-config only, which should be enough in any moderately\n  # modern OS. If people report breakage, I'll implement the manual logic\n  # later.\n  set gss_prefix [opt-val with-gss $prefix]\n  set krb5_config_guess [file join $gss_prefix bin krb5-config]\n  if {[file-isexec $krb5_config_guess]} {\n    define KRB5-CONFIG $krb5_config_guess\n  } else {\n    if {![cc-check-progs krb5-config]} {\n      user-error \"Unable to find krb5-config\"\n    }\n  }\n\n  msg-checking \"Checking for a GSSAPI implementation...\"\n\n  # Cflags\n  set krb5_config [get-define KRB5-CONFIG]\n  if {[catch {exec-with-stderr $krb5_config --cflags gssapi} res err]} {\n    user-error \"Could not derive --cflags from $krb5_config\"\n  }\n  define-append CFLAGS $res\n\n  # Libs\n  if {[catch {exec-with-stderr $krb5_config --libs gssapi} res err]} {\n    user-error \"Could not derive --libs from $krb5_config\"\n  }\n  define-append LDFLAGS $res\n\n  # Implementation\n  if {[catch {exec-with-stderr $krb5_config --version} res err]} {\n    user-error \"Could not derive --version from $krb5_config\"\n  }\n  switch -glob $res {\n    \"Kerberos 5 *\" { set GSSAPI_IMPL \"MIT\" }\n    \"*eimdal*\"     { set GSSAPI_IMPL \"Heimdal\" }\n    \"Solaris*\"     { set GSSAPI_IMPL \"Solaris\" }\n    default        { set GSSAPI_IMPL \"Unknown\" }\n  }\n  msg-result $GSSAPI_IMPL\n\n  if {$GSSAPI_IMPL in {Heimdal Solaris}} {\n    define HAVE_HEIMDAL\n  }\n  define USE_GSS\n}\n\n###############################################################################\n# DEBUG options\n\n# Backtrace support with libunwind\nif {[get-define want-debug-backtrace]} {\n  if {![check-inc-and-lib libunwind [opt-val with-backtrace $prefix] \\\n                          libunwind.h unw_backtrace unwind]} {\n    user-error \"Unable to find libunwind\"\n  }\n  define LIBS \"-lunwind-generic [get-define LIBS]\"\n  define USE_DEBUG_BACKTRACE 1\n  define debug_build 1\n}\n\n# Color dump\nif {[get-define want-debug-color]} {\n  define USE_DEBUG_COLOR 1\n  define debug_build 1\n}\n\n# Email dump\nif {[get-define want-debug-email]} {\n  define USE_DEBUG_EMAIL 1\n  define debug_build 1\n}\n\n# Graphviz dump\nif {[get-define want-debug-graphviz]} {\n  define USE_DEBUG_GRAPHVIZ 1\n  define debug_build 1\n}\n\n# Key mappings dump\nif {[get-define want-debug-keymap]} {\n  define USE_DEBUG_KEYMAP 1\n  define debug_build 1\n}\n\n# Logging\nif {[get-define want-debug-logging]} {\n  define USE_DEBUG_LOGGING 1\n  define debug_build 1\n}\n\n# Name lookup tables\nif {[get-define want-debug-names]} {\n  define USE_DEBUG_NAMES 1\n  define debug_build 1\n}\n\n# Notifications dump\nif {[get-define want-debug-notify]} {\n  define USE_DEBUG_NOTIFY 1\n  define debug_build 1\n}\n\n# TAILQ debugging\nif {[get-define want-debug-queue]} {\n  # Store the last 2 places the queue element or head was altered\n  define QUEUE_MACRO_DEBUG_TRACE\n  # Invalidated pointers will be set to 0xffffffffffffffff\n  define QUEUE_MACRO_DEBUG_TRASH\n  define debug_build 1\n}\n\n# Windows dump\nif {[get-define want-debug-window]} {\n  define USE_DEBUG_WINDOW 1\n  define debug_build 1\n}\n\n###############################################################################\n# Address Sanitizer\nif {[get-define want-asan]} {\n  msg-checking \"Checking for ASAN...\"\n  if {![cctest -link 1 -cflags -fsanitize=address]} {\n    user-error \"Unable to compile with -fsanitize=address\"\n  }\n  msg-result \"yes\"\n  define-append CFLAGS -fsanitize=address -fno-omit-frame-pointer -fno-common\n  define-append LDFLAGS -fsanitize=address\n  define USE_ASAN\n  define debug_build 1\n}\n\n###############################################################################\n# Undefined Behaviour Sanitizer\nif {[get-define want-ubsan]} {\n  msg-checking \"Checking for UBSAN...\"\n  if {![cctest -link 1 -cflags -fsanitize=undefined]} {\n    user-error \"Unable to compile with -fsanitize=undefined\"\n  }\n  msg-result \"yes\"\n  define-append CFLAGS -fsanitize=undefined -fno-omit-frame-pointer -fno-common\n  define-append LDFLAGS -fsanitize=undefined\n  define USE_UBSAN\n  define debug_build 1\n}\n\n###############################################################################\n# Fuzz Testing\nif {[get-define want-fuzzing]} {\n  define ENABLE_FUZZ_TESTS\n  lappend subdirs fuzz\n  define-append CFLAGS -fsanitize=fuzzer\n  define-append LDFLAGS -fsanitize=fuzzer\n}\n\n###############################################################################\n# Generate compile_commands.json\nif {[get-define want-compile-commands]} {\n  if {![get-define COMPILER_IS_CLANG]} {\n    user-error \"The clang compiler is required to generate compile_commands.json\"\n  }\n  define COMPILE_COMMANDS\n  define-append ALL_TARGETS compile_commands.json\n  define-append CLEAN_TARGETS clean-compile_commands.json\n  define-append CFLAGS {-MJ$(@:.o=.o.json)}\n}\n\n###############################################################################\n# Coverage Testing\nif {[get-define want-coverage]} {\n  define ENABLE_COVERAGE\n  define-append CFLAGS -fprofile-arcs -ftest-coverage\n  define-append LDFLAGS -fprofile-arcs -ftest-coverage\n}\n\n###############################################################################\n# Debug or Release build?\nif {[get-define debug_build]} {\n  define-append CFLAGS -g -O0\n} else {\n  define-append CFLAGS -O2\n}\n\n###############################################################################\n# Generate conststrings.c\nproc remove-paths-from-cflags {} {\n  lkill [get-define CFLAGS] {{x} {\n    foreach cflag {{-I} {-ffile-prefix-map=}} {\n      if {[string equal -length [string length $cflag] $x $cflag]} {\n        return 1\n      }\n    }\n    return 0\n  }}\n}\n\nset conststrings \"\\\n  unsigned char cc_cflags\\[\\] = {[text2c [expr {\n    [get-define want-paths-in-cflags]\n    ? [get-define CFLAGS]\n    : [remove-paths-from-cflags]\n  }]]};\\n\\\n  unsigned char configure_options\\[\\] = {[text2c $conf_options]};\\n\"\nif {[catch {set fd [open conststrings.c w]\n            puts $fd $conststrings\n            close $fd} msg]} {\n  user-error \"Cannot write conststrings.c: $msg\"\n}\n\n###############################################################################\n# Definitions that are going to be substituted in config.h\nset auto_rep {\n  _*\n  *_TARGETS\n  BINDIR\n  BUILD_DOC\n  COMPILE*\n  CRYPT_*\n  DOMAIN\n  ENABLE_*\n  HAVE_*\n  HOMESPOOL\n  LOCALES_HACK\n  MAILPATH\n  MAKEDOC_FULL\n  MUTTLOCALEDIR\n  NOTMUCH_API_3\n  PACKAGE\n  PKGDATADIR\n  PKGDOCDIR\n  QUEUE_*\n  SENDMAIL\n  SYSCONFDIR\n  TEST_CASE_MAXSIZE\n  TMPDIR\n  USE_*\n  VPATH\n  WORDS_BIGENDIAN\n}\nset bare_rep {\n  ICONV_CONST\n  LOFF_T\n  OFF_T_FMT\n}\nset str_rep {\n  PACKAGE_VERSION\n}\n\n###############################################################################\n# Use ccache - don't do it earlier than here\nif {[get-define CCACHE] ne {none}} {\n  define CC \"[get-define CCACHE] [get-define CC]\"\n  define CC_FOR_BUILD \"[get-define CCACHE] [get-define CC_FOR_BUILD]\"\n}\n\n###############################################################################\n# Generate targets and Makefile variables for subdirectories\ndefine VPATH \"\\$(SRCDIR)\"\nforeach dir $subdirs {\n  define-append ALL_TARGETS all-$dir\n  define-append CLEAN_TARGETS clean-$dir\n  define-append INSTALL_TARGETS install-$dir\n  define-append UNINSTALL_TARGETS uninstall-$dir\n}\n\n###############################################################################\n# Define package timestamp (UTC) based on PACKAGE_VERSION for:\n# docs/neomuttrc.5, docs/neomutt.1\ndefine PACKAGE_DATE \\\n  [regsub {(....)(..)(..)} [get-define PACKAGE_VERSION] {\\1-\\2-\\3}]\n\n###############################################################################\n# Generate Makefile and config.h\ndefine PWD [pwd]\nmake-template Makefile.autosetup Makefile\nmake-config-header config.h -auto $auto_rep -bare $bare_rep -str $str_rep\n\n###############################################################################\n# Generate .clang_complete\ndefine cflags-one-per-line [string map {\" \" \"\\n\"} \\\n  [lkill [get-define CFLAGS] {{x} {string equal -length 3 $x \"-MJ\"}}]]\nmake-template .clang_complete.in\n\n###############################################################################\n# Print a summary\nuser-notice \"Summary of build options:\n\n  Version:               [get-define PACKAGE_VERSION]\n  Host OS:               [get-define host_os]\n  Install prefix:        [get-define prefix]\n  Compiler:              [get-define CC]\n  CFlags:                [get-define CFLAGS]\n  LDFlags:               [get-define LDFLAGS]\n  Libs:                  [get-define LIBS]\n\n  GPGME:                 [yesno [get-define CRYPT_BACKEND_GPGME]]\n  PGP:                   [yesno [get-define CRYPT_BACKEND_CLASSIC_PGP]]\n  SMIME:                 [yesno [get-define CRYPT_BACKEND_CLASSIC_SMIME]]\n  Notmuch:               [yesno [get-define USE_NOTMUCH]]\n  Header Cache(s):       [get-define HCACHE_BACKENDS {}]\n  Header Compression(s): [get-define COMPRESS_BACKENDS {}]\n  Lua:                   [yesno [get-define USE_LUA]]\n\"\n"
        },
        {
          "name": "autocrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "autosetup",
          "type": "tree",
          "content": null
        },
        {
          "name": "bcache",
          "type": "tree",
          "content": null
        },
        {
          "name": "browser",
          "type": "tree",
          "content": null
        },
        {
          "name": "color",
          "type": "tree",
          "content": null
        },
        {
          "name": "commands.c",
          "type": "blob",
          "size": 46.373046875,
          "content": "/**\n * @file\n * Functions to parse commands in a config file\n *\n * @authors\n * Copyright (C) 1996-2002,2007,2010,2012-2013,2016 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2004 g10 Code GmbH\n * Copyright (C) 2019-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2020 Aditya De Saha <adityadesaha@gmail.com>\n * Copyright (C) 2020 Matthew Hughes <matthewhughes934@gmail.com>\n * Copyright (C) 2020 R Primus <rprimus@gmail.com>\n * Copyright (C) 2020-2022 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2022 Marco Sirabella <marco@sirabella.org>\n * Copyright (C) 2023 Dennis Schön <mail@dennis-schoen.de>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_commands Functions to parse commands in a config file\n *\n * Functions to parse commands in a config file\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"commands.h\"\n#include \"attach/lib.h\"\n#include \"color/lib.h\"\n#include \"imap/lib.h\"\n#include \"key/lib.h\"\n#include \"menu/lib.h\"\n#include \"pager/lib.h\"\n#include \"parse/lib.h\"\n#include \"store/lib.h\"\n#include \"alternates.h\"\n#include \"globals.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"score.h\"\n#include \"version.h\"\n#ifdef USE_INOTIFY\n#include \"monitor.h\"\n#endif\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\n/// LIFO designed to contain the list of config files that have been sourced and\n/// avoid cyclic sourcing.\nstatic struct ListHead MuttrcStack = STAILQ_HEAD_INITIALIZER(MuttrcStack);\n\n#define MAX_ERRS 128\n\n/**\n * enum TriBool - Tri-state boolean\n */\nenum TriBool\n{\n  TB_UNSET = -1, ///< Value hasn't been set\n  TB_FALSE,      ///< Value is false\n  TB_TRUE,       ///< Value is true\n};\n\n/**\n * enum GroupState - Type of email address group\n */\nenum GroupState\n{\n  GS_NONE, ///< Group is missing an argument\n  GS_RX,   ///< Entry is a regular expression\n  GS_ADDR, ///< Entry is an address\n};\n\n/**\n * is_function - Is the argument a neomutt function?\n * @param name  Command name to be searched for\n * @retval true  Function found\n * @retval false Function not found\n */\nstatic bool is_function(const char *name)\n{\n  for (size_t i = 0; MenuNames[i].name; i++)\n  {\n    const struct MenuFuncOp *fns = km_get_table(MenuNames[i].value);\n    if (!fns)\n      continue;\n\n    for (int j = 0; fns[j].name; j++)\n      if (mutt_str_equal(name, fns[j].name))\n        return true;\n  }\n  return false;\n}\n\n/**\n * is_color_object - Is the argument a neomutt colour?\n * @param name  Colour name to be searched for\n * @retval true  Function found\n * @retval false Function not found\n */\nstatic bool is_color_object(const char *name)\n{\n  int cid = mutt_map_get_value(name, ColorFields);\n\n  return (cid > 0);\n}\n\n/**\n * parse_grouplist - Parse a group context\n * @param gl   GroupList to add to\n * @param buf  Temporary Buffer space\n * @param s    Buffer containing string to be parsed\n * @param err  Buffer for error messages\n * @retval  0 Success\n * @retval -1 Error\n */\nint parse_grouplist(struct GroupList *gl, struct Buffer *buf, struct Buffer *s,\n                    struct Buffer *err)\n{\n  while (mutt_istr_equal(buf->data, \"-group\"))\n  {\n    if (!MoreArgs(s))\n    {\n      buf_strcpy(err, _(\"-group: no group name\"));\n      return -1;\n    }\n\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    mutt_grouplist_add(gl, mutt_pattern_group(buf->data));\n\n    if (!MoreArgs(s))\n    {\n      buf_strcpy(err, _(\"out of arguments\"));\n      return -1;\n    }\n\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  }\n\n  return 0;\n}\n\n/**\n * parse_rc_line_cwd - Parse and run a muttrc line in a relative directory\n * @param line   Line to be parsed\n * @param cwd    File relative where to run the line\n * @param err    Where to write error messages\n * @retval #CommandResult Result e.g. #MUTT_CMD_SUCCESS\n */\nenum CommandResult parse_rc_line_cwd(const char *line, char *cwd, struct Buffer *err)\n{\n  mutt_list_insert_head(&MuttrcStack, mutt_str_dup(NONULL(cwd)));\n\n  enum CommandResult ret = parse_rc_line(line, err);\n\n  struct ListNode *np = STAILQ_FIRST(&MuttrcStack);\n  STAILQ_REMOVE_HEAD(&MuttrcStack, entries);\n  FREE(&np->data);\n  FREE(&np);\n\n  return ret;\n}\n\n/**\n * mutt_get_sourced_cwd - Get the current file path that is being parsed\n * @retval ptr File path that is being parsed or cwd at runtime\n *\n * @note Caller is responsible for freeing returned string\n */\nchar *mutt_get_sourced_cwd(void)\n{\n  struct ListNode *np = STAILQ_FIRST(&MuttrcStack);\n  if (np && np->data)\n    return mutt_str_dup(np->data);\n\n  // stack is empty, return our own dummy file relative to cwd\n  struct Buffer *cwd = buf_pool_get();\n  mutt_path_getcwd(cwd);\n  buf_addstr(cwd, \"/dummy.rc\");\n  char *ret = buf_strdup(cwd);\n  buf_pool_release(&cwd);\n  return ret;\n}\n\n/**\n * source_rc - Read an initialization file\n * @param rcfile_path Path to initialization file\n * @param err         Buffer for error messages\n * @retval <0 NeoMutt should pause to let the user know\n */\nint source_rc(const char *rcfile_path, struct Buffer *err)\n{\n  int lineno = 0, rc = 0, warnings = 0;\n  enum CommandResult line_rc;\n  struct Buffer *token = NULL, *linebuf = NULL;\n  char *line = NULL;\n  char *currentline = NULL;\n  char rcfile[PATH_MAX + 1] = { 0 };\n  size_t linelen = 0;\n  pid_t pid;\n\n  mutt_str_copy(rcfile, rcfile_path, sizeof(rcfile));\n\n  size_t rcfilelen = mutt_str_len(rcfile);\n  if (rcfilelen == 0)\n    return -1;\n\n  bool ispipe = rcfile[rcfilelen - 1] == '|';\n\n  if (!ispipe)\n  {\n    struct ListNode *np = STAILQ_FIRST(&MuttrcStack);\n    if (!mutt_path_to_absolute(rcfile, np ? NONULL(np->data) : \"\"))\n    {\n      mutt_error(_(\"Error: Can't build path of '%s'\"), rcfile_path);\n      return -1;\n    }\n\n    STAILQ_FOREACH(np, &MuttrcStack, entries)\n    {\n      if (mutt_str_equal(np->data, rcfile))\n      {\n        break;\n      }\n    }\n    if (np)\n    {\n      mutt_error(_(\"Error: Cyclic sourcing of configuration file '%s'\"), rcfile);\n      return -1;\n    }\n\n    mutt_list_insert_head(&MuttrcStack, mutt_str_dup(rcfile));\n  }\n\n  mutt_debug(LL_DEBUG2, \"Reading configuration file '%s'\\n\", rcfile);\n\n  FILE *fp = mutt_open_read(rcfile, &pid);\n  if (!fp)\n  {\n    buf_printf(err, \"%s: %s\", rcfile, strerror(errno));\n    return -1;\n  }\n\n  token = buf_pool_get();\n  linebuf = buf_pool_get();\n\n  const char *const c_config_charset = cs_subset_string(NeoMutt->sub, \"config_charset\");\n  const char *const c_charset = cc_charset();\n  while ((line = mutt_file_read_line(line, &linelen, fp, &lineno, MUTT_RL_CONT)) != NULL)\n  {\n    const bool conv = c_config_charset && c_charset;\n    if (conv)\n    {\n      currentline = mutt_str_dup(line);\n      if (!currentline)\n        continue;\n      mutt_ch_convert_string(&currentline, c_config_charset, c_charset, MUTT_ICONV_NO_FLAGS);\n    }\n    else\n    {\n      currentline = line;\n    }\n\n    buf_strcpy(linebuf, currentline);\n\n    buf_reset(err);\n    line_rc = parse_rc_buffer(linebuf, token, err);\n    if (line_rc == MUTT_CMD_ERROR)\n    {\n      mutt_error(\"%s:%d: %s\", rcfile, lineno, buf_string(err));\n      if (--rc < -MAX_ERRS)\n      {\n        if (conv)\n          FREE(&currentline);\n        break;\n      }\n    }\n    else if (line_rc == MUTT_CMD_WARNING)\n    {\n      /* Warning */\n      mutt_warning(\"%s:%d: %s\", rcfile, lineno, buf_string(err));\n      warnings++;\n    }\n    else if (line_rc == MUTT_CMD_FINISH)\n    {\n      if (conv)\n        FREE(&currentline);\n      break; /* Found \"finish\" command */\n    }\n    else\n    {\n      if (rc < 0)\n        rc = -1;\n    }\n    if (conv)\n      FREE(&currentline);\n  }\n\n  FREE(&line);\n  mutt_file_fclose(&fp);\n  if (pid != -1)\n    filter_wait(pid);\n\n  if (rc)\n  {\n    /* the neomuttrc source keyword */\n    buf_reset(err);\n    buf_printf(err, (rc >= -MAX_ERRS) ? _(\"source: errors in %s\") : _(\"source: reading aborted due to too many errors in %s\"),\n               rcfile);\n    rc = -1;\n  }\n  else\n  {\n    /* Don't alias errors with warnings */\n    if (warnings > 0)\n    {\n      buf_printf(err, ngettext(\"source: %d warning in %s\", \"source: %d warnings in %s\", warnings),\n                 warnings, rcfile);\n      rc = -2;\n    }\n  }\n\n  if (!ispipe && !STAILQ_EMPTY(&MuttrcStack))\n  {\n    struct ListNode *np = STAILQ_FIRST(&MuttrcStack);\n    STAILQ_REMOVE_HEAD(&MuttrcStack, entries);\n    FREE(&np->data);\n    FREE(&np);\n  }\n\n  buf_pool_release(&token);\n  buf_pool_release(&linebuf);\n  return rc;\n}\n\n/**\n * parse_cd - Parse the 'cd' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_cd(struct Buffer *buf, struct Buffer *s,\n                                   intptr_t data, struct Buffer *err)\n{\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  buf_expand_path(buf);\n  if (buf_is_empty(buf))\n  {\n    if (HomeDir)\n    {\n      buf_strcpy(buf, HomeDir);\n    }\n    else\n    {\n      buf_printf(err, _(\"%s: too few arguments\"), \"cd\");\n      return MUTT_CMD_ERROR;\n    }\n  }\n\n  if (chdir(buf_string(buf)) != 0)\n  {\n    buf_printf(err, \"cd: %s\", strerror(errno));\n    return MUTT_CMD_ERROR;\n  }\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_echo - Parse the 'echo' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_echo(struct Buffer *buf, struct Buffer *s,\n                                     intptr_t data, struct Buffer *err)\n{\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"echo\");\n    return MUTT_CMD_WARNING;\n  }\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  OptForceRefresh = true;\n  mutt_message(\"%s\", buf->data);\n  OptForceRefresh = false;\n  mutt_sleep(0);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_finish - Parse the 'finish' command - Implements Command::parse() - @ingroup command_parse\n * @retval  #MUTT_CMD_FINISH Stop processing the current file\n * @retval  #MUTT_CMD_WARNING Failed\n *\n * If the 'finish' command is found, we should stop reading the current file.\n */\nstatic enum CommandResult parse_finish(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), \"finish\");\n    return MUTT_CMD_WARNING;\n  }\n\n  return MUTT_CMD_FINISH;\n}\n\n/**\n * parse_group - Parse the 'group' and 'ungroup' commands - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_group(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  struct GroupList gl = STAILQ_HEAD_INITIALIZER(gl);\n  enum GroupState gstate = GS_NONE;\n\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    if (parse_grouplist(&gl, buf, s, err) == -1)\n      goto bail;\n\n    if ((data == MUTT_UNGROUP) && mutt_istr_equal(buf->data, \"*\"))\n    {\n      mutt_grouplist_clear(&gl);\n      goto out;\n    }\n\n    if (mutt_istr_equal(buf->data, \"-rx\"))\n    {\n      gstate = GS_RX;\n    }\n    else if (mutt_istr_equal(buf->data, \"-addr\"))\n    {\n      gstate = GS_ADDR;\n    }\n    else\n    {\n      switch (gstate)\n      {\n        case GS_NONE:\n          buf_printf(err, _(\"%sgroup: missing -rx or -addr\"),\n                     (data == MUTT_UNGROUP) ? \"un\" : \"\");\n          goto warn;\n\n        case GS_RX:\n          if ((data == MUTT_GROUP) &&\n              (mutt_grouplist_add_regex(&gl, buf->data, REG_ICASE, err) != 0))\n          {\n            goto bail;\n          }\n          else if ((data == MUTT_UNGROUP) &&\n                   (mutt_grouplist_remove_regex(&gl, buf->data) < 0))\n          {\n            goto bail;\n          }\n          break;\n\n        case GS_ADDR:\n        {\n          char *estr = NULL;\n          struct AddressList al = TAILQ_HEAD_INITIALIZER(al);\n          mutt_addrlist_parse2(&al, buf->data);\n          if (TAILQ_EMPTY(&al))\n            goto bail;\n          if (mutt_addrlist_to_intl(&al, &estr))\n          {\n            buf_printf(err, _(\"%sgroup: warning: bad IDN '%s'\"),\n                       (data == 1) ? \"un\" : \"\", estr);\n            mutt_addrlist_clear(&al);\n            FREE(&estr);\n            goto bail;\n          }\n          if (data == MUTT_GROUP)\n            mutt_grouplist_add_addrlist(&gl, &al);\n          else if (data == MUTT_UNGROUP)\n            mutt_grouplist_remove_addrlist(&gl, &al);\n          mutt_addrlist_clear(&al);\n          break;\n        }\n      }\n    }\n  } while (MoreArgs(s));\n\nout:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_SUCCESS;\n\nbail:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_ERROR;\n\nwarn:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_WARNING;\n}\n\n/**\n * parse_ifdef - Parse the 'ifdef' and 'ifndef' commands - Implements Command::parse() - @ingroup command_parse\n *\n * The 'ifdef' command allows conditional elements in the config file.\n * If a given variable, function, command or compile-time symbol exists, then\n * read the rest of the line of config commands.\n * e.g.\n *      ifdef sidebar source ~/.neomutt/sidebar.rc\n *\n * If (data == 1) then it means use the 'ifndef' (if-not-defined) command.\n * e.g.\n *      ifndef imap finish\n */\nstatic enum CommandResult parse_ifdef(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n  if (buf_is_empty(buf))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), (data ? \"ifndef\" : \"ifdef\"));\n    return MUTT_CMD_WARNING;\n  }\n\n  // is the item defined as:\n  bool res = cs_subset_lookup(NeoMutt->sub, buf->data) // a variable?\n             || feature_enabled(buf->data)             // a compiled-in feature?\n             || is_function(buf->data)                 // a function?\n             || command_get(buf->data)                 // a command?\n             || is_color_object(buf->data)             // a color?\n#ifdef USE_HCACHE\n             || store_is_valid_backend(buf->data) // a store? (database)\n#endif\n             || mutt_str_getenv(buf->data); // an environment variable?\n\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), (data ? \"ifndef\" : \"ifdef\"));\n    return MUTT_CMD_WARNING;\n  }\n  parse_extract_token(buf, s, TOKEN_SPACE);\n\n  /* ifdef KNOWN_SYMBOL or ifndef UNKNOWN_SYMBOL */\n  if ((res && (data == 0)) || (!res && (data == 1)))\n  {\n    enum CommandResult rc = parse_rc_line(buf->data, err);\n    if (rc == MUTT_CMD_ERROR)\n    {\n      mutt_error(_(\"Error: %s\"), buf_string(err));\n      return MUTT_CMD_ERROR;\n    }\n    return rc;\n  }\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_ignore - Parse the 'ignore' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_ignore(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    remove_from_stailq(&UnIgnore, buf->data);\n    add_to_stailq(&Ignore, buf->data);\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_lists - Parse the 'lists' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_lists(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  struct GroupList gl = STAILQ_HEAD_INITIALIZER(gl);\n\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (parse_grouplist(&gl, buf, s, err) == -1)\n      goto bail;\n\n    mutt_regexlist_remove(&UnMailLists, buf->data);\n\n    if (mutt_regexlist_add(&MailLists, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n\n    if (mutt_grouplist_add_regex(&gl, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n  } while (MoreArgs(s));\n\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_SUCCESS;\n\nbail:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_ERROR;\n}\n\n/**\n * mailbox_add - Add a new Mailbox\n * @param folder  Path to use for '+' abbreviations\n * @param mailbox Mailbox to add\n * @param label   Descriptive label\n * @param poll    Enable mailbox polling?\n * @param notify  Enable mailbox notification?\n * @param err     Buffer for error messages\n * @retval #CommandResult Result e.g. #MUTT_CMD_SUCCESS\n */\nstatic enum CommandResult mailbox_add(const char *folder, const char *mailbox,\n                                      const char *label, enum TriBool poll,\n                                      enum TriBool notify, struct Buffer *err)\n{\n  mutt_debug(LL_DEBUG1, \"Adding mailbox: '%s' label '%s', poll %s, notify %s\\n\",\n             mailbox, label ? label : \"[NONE]\",\n             (poll == TB_UNSET) ? \"[UNSPECIFIED]\" :\n             (poll == TB_TRUE)  ? \"true\" :\n                                  \"false\",\n             (notify == TB_UNSET) ? \"[UNSPECIFIED]\" :\n             (notify == TB_TRUE)  ? \"true\" :\n                                    \"false\");\n  struct Mailbox *m = mailbox_new();\n\n  buf_strcpy(&m->pathbuf, mailbox);\n  /* int rc = */ mx_path_canon2(m, folder);\n\n  if (m->type <= MUTT_UNKNOWN)\n  {\n    buf_printf(err, \"Unknown Mailbox: %s\", m->realpath);\n    mailbox_free(&m);\n    return MUTT_CMD_ERROR;\n  }\n\n  bool new_account = false;\n  struct Account *a = mx_ac_find(m);\n  if (!a)\n  {\n    a = account_new(NULL, NeoMutt->sub);\n    a->type = m->type;\n    new_account = true;\n  }\n\n  if (!new_account)\n  {\n    struct Mailbox *m_old = mx_mbox_find(a, m->realpath);\n    if (m_old)\n    {\n      if (!m_old->visible)\n      {\n        m_old->visible = true;\n        m_old->gen = mailbox_gen();\n      }\n\n      if (label)\n        mutt_str_replace(&m_old->name, label);\n\n      if (notify != TB_UNSET)\n        m_old->notify_user = notify;\n\n      if (poll != TB_UNSET)\n        m_old->poll_new_mail = poll;\n\n      struct EventMailbox ev_m = { m_old };\n      notify_send(m_old->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);\n\n      mailbox_free(&m);\n      return MUTT_CMD_SUCCESS;\n    }\n  }\n\n  if (label)\n    m->name = mutt_str_dup(label);\n\n  if (notify != TB_UNSET)\n    m->notify_user = notify;\n\n  if (poll != TB_UNSET)\n    m->poll_new_mail = poll;\n\n  if (!mx_ac_add(a, m))\n  {\n    mailbox_free(&m);\n    if (new_account)\n    {\n      cs_subset_free(&a->sub);\n      FREE(&a->name);\n      notify_free(&a->notify);\n      FREE(&a);\n    }\n    return MUTT_CMD_SUCCESS;\n  }\n\n  if (new_account)\n  {\n    neomutt_account_add(NeoMutt, a);\n  }\n\n  // this is finally a visible mailbox in the sidebar and mailboxes list\n  m->visible = true;\n\n#ifdef USE_INOTIFY\n  mutt_monitor_add(m);\n#endif\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * mailbox_add_simple - Add a new Mailbox\n * @param mailbox Mailbox to add\n * @param err     Buffer for error messages\n * @retval true Success\n */\nbool mailbox_add_simple(const char *mailbox, struct Buffer *err)\n{\n  enum CommandResult rc = mailbox_add(\"\", mailbox, NULL, TB_UNSET, TB_UNSET, err);\n\n  return (rc == MUTT_CMD_SUCCESS);\n}\n\n/**\n * parse_mailboxes - Parse the 'mailboxes' command - Implements Command::parse() - @ingroup command_parse\n *\n * This is also used by 'virtual-mailboxes'.\n */\nenum CommandResult parse_mailboxes(struct Buffer *buf, struct Buffer *s,\n                                   intptr_t data, struct Buffer *err)\n{\n  enum CommandResult rc = MUTT_CMD_WARNING;\n\n  struct Buffer *label = buf_pool_get();\n  struct Buffer *mailbox = buf_pool_get();\n\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  while (MoreArgs(s))\n  {\n    bool label_set = false;\n    enum TriBool notify = TB_UNSET;\n    enum TriBool poll = TB_UNSET;\n\n    do\n    {\n      // Start by handling the options\n      parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n      if (mutt_str_equal(buf_string(buf), \"-label\"))\n      {\n        if (!MoreArgs(s))\n        {\n          buf_printf(err, _(\"%s: too few arguments\"), \"mailboxes -label\");\n          goto done;\n        }\n\n        parse_extract_token(label, s, TOKEN_NO_FLAGS);\n        label_set = true;\n      }\n      else if (mutt_str_equal(buf_string(buf), \"-nolabel\"))\n      {\n        buf_reset(label);\n        label_set = true;\n      }\n      else if (mutt_str_equal(buf_string(buf), \"-notify\"))\n      {\n        notify = TB_TRUE;\n      }\n      else if (mutt_str_equal(buf_string(buf), \"-nonotify\"))\n      {\n        notify = TB_FALSE;\n      }\n      else if (mutt_str_equal(buf_string(buf), \"-poll\"))\n      {\n        poll = TB_TRUE;\n      }\n      else if (mutt_str_equal(buf_string(buf), \"-nopoll\"))\n      {\n        poll = TB_FALSE;\n      }\n      else if ((data & MUTT_NAMED) && !label_set)\n      {\n        if (!MoreArgs(s))\n        {\n          buf_printf(err, _(\"%s: too few arguments\"), \"named-mailboxes\");\n          goto done;\n        }\n\n        buf_copy(label, buf);\n        label_set = true;\n      }\n      else\n      {\n        buf_copy(mailbox, buf);\n        break;\n      }\n    } while (MoreArgs(s));\n\n    if (buf_is_empty(mailbox))\n    {\n      buf_printf(err, _(\"%s: too few arguments\"), \"mailboxes\");\n      goto done;\n    }\n\n    rc = mailbox_add(c_folder, buf_string(mailbox),\n                     label_set ? buf_string(label) : NULL, poll, notify, err);\n    if (rc != MUTT_CMD_SUCCESS)\n      goto done;\n\n    buf_reset(label);\n    buf_reset(mailbox);\n  }\n\n  rc = MUTT_CMD_SUCCESS;\n\ndone:\n  buf_pool_release(&label);\n  buf_pool_release(&mailbox);\n  return rc;\n}\n\n/**\n * parse_my_hdr - Parse the 'my_hdr' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult parse_my_hdr(struct Buffer *buf, struct Buffer *s,\n                                intptr_t data, struct Buffer *err)\n{\n  parse_extract_token(buf, s, TOKEN_SPACE | TOKEN_QUOTE);\n  char *p = strpbrk(buf->data, \": \\t\");\n  if (!p || (*p != ':'))\n  {\n    buf_strcpy(err, _(\"invalid header field\"));\n    return MUTT_CMD_WARNING;\n  }\n\n  struct EventHeader ev_h = { buf->data };\n  struct ListNode *n = header_find(&UserHeader, buf->data);\n\n  if (n)\n  {\n    header_update(n, buf->data);\n    mutt_debug(LL_NOTIFY, \"NT_HEADER_CHANGE: %s\\n\", buf->data);\n    notify_send(NeoMutt->notify, NT_HEADER, NT_HEADER_CHANGE, &ev_h);\n  }\n  else\n  {\n    header_add(&UserHeader, buf->data);\n    mutt_debug(LL_NOTIFY, \"NT_HEADER_ADD: %s\\n\", buf->data);\n    notify_send(NeoMutt->notify, NT_HEADER, NT_HEADER_ADD, &ev_h);\n  }\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * set_dump - Dump list of config variables into a file/pager\n * @param flags what configs to dump: see #ConfigDumpFlags\n * @param err buffer for error message\n * @return num See #CommandResult\n *\n * FIXME: Move me into parse/set.c.  Note: this function currently depends on\n * pager, which is the reason it is not included in the parse library.\n */\nenum CommandResult set_dump(ConfigDumpFlags flags, struct Buffer *err)\n{\n  struct Buffer *tempfile = buf_pool_get();\n  buf_mktemp(tempfile);\n\n  FILE *fp_out = mutt_file_fopen(buf_string(tempfile), \"w\");\n  if (!fp_out)\n  {\n    // L10N: '%s' is the file name of the temporary file\n    buf_printf(err, _(\"Could not create temporary file %s\"), buf_string(tempfile));\n    buf_pool_release(&tempfile);\n    return MUTT_CMD_ERROR;\n  }\n\n  dump_config(NeoMutt->sub->cs, flags, fp_out);\n\n  mutt_file_fclose(&fp_out);\n\n  struct PagerData pdata = { 0 };\n  struct PagerView pview = { &pdata };\n\n  pdata.fname = buf_string(tempfile);\n\n  pview.banner = \"set\";\n  pview.flags = MUTT_PAGER_NO_FLAGS;\n  pview.mode = PAGER_MODE_OTHER;\n\n  mutt_do_pager(&pview, NULL);\n  buf_pool_release(&tempfile);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * envlist_sort - Compare two environment strings - Implements ::sort_t - @ingroup sort_api\n */\nstatic int envlist_sort(const void *a, const void *b, void *sdata)\n{\n  return strcmp(*(const char **) a, *(const char **) b);\n}\n\n/**\n * parse_setenv - Parse the 'setenv' and 'unsetenv' commands - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_setenv(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  char **envp = EnvList;\n\n  bool query = false;\n  bool prefix = false;\n  bool unset = (data == MUTT_SET_UNSET);\n\n  if (!MoreArgs(s))\n  {\n    if (!StartupComplete)\n    {\n      buf_printf(err, _(\"%s: too few arguments\"), \"setenv\");\n      return MUTT_CMD_WARNING;\n    }\n\n    struct Buffer *tempfile = buf_pool_get();\n    buf_mktemp(tempfile);\n\n    FILE *fp_out = mutt_file_fopen(buf_string(tempfile), \"w\");\n    if (!fp_out)\n    {\n      // L10N: '%s' is the file name of the temporary file\n      buf_printf(err, _(\"Could not create temporary file %s\"), buf_string(tempfile));\n      buf_pool_release(&tempfile);\n      return MUTT_CMD_ERROR;\n    }\n\n    int count = 0;\n    for (char **env = EnvList; *env; env++)\n      count++;\n\n    mutt_qsort_r(EnvList, count, sizeof(char *), envlist_sort, NULL);\n\n    for (char **env = EnvList; *env; env++)\n      fprintf(fp_out, \"%s\\n\", *env);\n\n    mutt_file_fclose(&fp_out);\n\n    struct PagerData pdata = { 0 };\n    struct PagerView pview = { &pdata };\n\n    pdata.fname = buf_string(tempfile);\n\n    pview.banner = \"setenv\";\n    pview.flags = MUTT_PAGER_NO_FLAGS;\n    pview.mode = PAGER_MODE_OTHER;\n\n    mutt_do_pager(&pview, NULL);\n    buf_pool_release(&tempfile);\n\n    return MUTT_CMD_SUCCESS;\n  }\n\n  if (*s->dptr == '?')\n  {\n    query = true;\n    prefix = true;\n\n    if (unset)\n    {\n      buf_printf(err, _(\"Can't query option with the '%s' command\"), \"unsetenv\");\n      return MUTT_CMD_WARNING;\n    }\n\n    s->dptr++;\n  }\n\n  /* get variable name */\n  parse_extract_token(buf, s, TOKEN_EQUAL | TOKEN_QUESTION);\n\n  if (*s->dptr == '?')\n  {\n    if (unset)\n    {\n      buf_printf(err, _(\"Can't query option with the '%s' command\"), \"unsetenv\");\n      return MUTT_CMD_WARNING;\n    }\n\n    if (prefix)\n    {\n      buf_printf(err, _(\"Can't use a prefix when querying a variable\"));\n      return MUTT_CMD_WARNING;\n    }\n\n    query = true;\n    s->dptr++;\n  }\n\n  if (query)\n  {\n    bool found = false;\n    while (envp && *envp)\n    {\n      /* This will display all matches for \"^QUERY\" */\n      if (mutt_str_startswith(*envp, buf->data))\n      {\n        if (!found)\n        {\n          mutt_endwin();\n          found = true;\n        }\n        puts(*envp);\n      }\n      envp++;\n    }\n\n    if (found)\n    {\n      mutt_any_key_to_continue(NULL);\n      return MUTT_CMD_SUCCESS;\n    }\n\n    buf_printf(err, _(\"%s is unset\"), buf->data);\n    return MUTT_CMD_WARNING;\n  }\n\n  if (unset)\n  {\n    if (!envlist_unset(&EnvList, buf->data))\n    {\n      buf_printf(err, _(\"%s is unset\"), buf->data);\n      return MUTT_CMD_WARNING;\n    }\n    return MUTT_CMD_SUCCESS;\n  }\n\n  /* set variable */\n\n  if (*s->dptr == '=')\n  {\n    s->dptr++;\n    SKIPWS(s->dptr);\n  }\n\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"setenv\");\n    return MUTT_CMD_WARNING;\n  }\n\n  char *name = mutt_str_dup(buf->data);\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  envlist_set(&EnvList, name, buf->data, true);\n  FREE(&name);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_source - Parse the 'source' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_source(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  struct Buffer *path = buf_pool_get();\n\n  do\n  {\n    if (parse_extract_token(buf, s, TOKEN_NO_FLAGS) != 0)\n    {\n      buf_printf(err, _(\"source: error at %s\"), s->dptr);\n      buf_pool_release(&path);\n      return MUTT_CMD_ERROR;\n    }\n    buf_copy(path, buf);\n    buf_expand_path(path);\n\n    if (source_rc(buf_string(path), err) < 0)\n    {\n      buf_printf(err, _(\"source: file %s could not be sourced\"), buf_string(path));\n      buf_pool_release(&path);\n      return MUTT_CMD_ERROR;\n    }\n\n  } while (MoreArgs(s));\n\n  buf_pool_release(&path);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_nospam - Parse the 'nospam' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_nospam(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"nospam\");\n    return MUTT_CMD_ERROR;\n  }\n\n  // Extract the first token, a regex or \"*\"\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n  if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), \"finish\");\n    return MUTT_CMD_ERROR;\n  }\n\n  // \"*\" is special - clear both spam and nospam lists\n  if (mutt_str_equal(buf_string(buf), \"*\"))\n  {\n    mutt_replacelist_free(&SpamList);\n    mutt_regexlist_free(&NoSpamList);\n    return MUTT_CMD_SUCCESS;\n  }\n\n  // If it's on the spam list, just remove it\n  if (mutt_replacelist_remove(&SpamList, buf_string(buf)) != 0)\n    return MUTT_CMD_SUCCESS;\n\n  // Otherwise, add it to the nospam list\n  if (mutt_regexlist_add(&NoSpamList, buf_string(buf), REG_ICASE, err) != 0)\n    return MUTT_CMD_ERROR;\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_spam - Parse the 'spam' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_spam(struct Buffer *buf, struct Buffer *s,\n                                     intptr_t data, struct Buffer *err)\n{\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"spam\");\n    return MUTT_CMD_ERROR;\n  }\n\n  // Extract the first token, a regex\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n  // If there's a second parameter, it's a template for the spam tag\n  if (MoreArgs(s))\n  {\n    struct Buffer *templ = buf_pool_get();\n    parse_extract_token(templ, s, TOKEN_NO_FLAGS);\n\n    // Add to the spam list\n    int rc = mutt_replacelist_add(&SpamList, buf_string(buf), buf_string(templ), err);\n    buf_pool_release(&templ);\n    if (rc != 0)\n      return MUTT_CMD_ERROR;\n  }\n  else\n  {\n    // If not, try to remove from the nospam list\n    mutt_regexlist_remove(&NoSpamList, buf_string(buf));\n  }\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_stailq - Parse a list command - Implements Command::parse() - @ingroup command_parse\n *\n * This is used by 'alternative_order', 'auto_view' and several others.\n */\nstatic enum CommandResult parse_stailq(struct Buffer *buf, struct Buffer *s,\n                                       intptr_t data, struct Buffer *err)\n{\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    add_to_stailq((struct ListHead *) data, buf->data);\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_subscribe - Parse the 'subscribe' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_subscribe(struct Buffer *buf, struct Buffer *s,\n                                          intptr_t data, struct Buffer *err)\n{\n  struct GroupList gl = STAILQ_HEAD_INITIALIZER(gl);\n\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (parse_grouplist(&gl, buf, s, err) == -1)\n      goto bail;\n\n    mutt_regexlist_remove(&UnMailLists, buf->data);\n    mutt_regexlist_remove(&UnSubscribedLists, buf->data);\n\n    if (mutt_regexlist_add(&MailLists, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n    if (mutt_regexlist_add(&SubscribedLists, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n    if (mutt_grouplist_add_regex(&gl, buf->data, REG_ICASE, err) != 0)\n      goto bail;\n  } while (MoreArgs(s));\n\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_SUCCESS;\n\nbail:\n  mutt_grouplist_destroy(&gl);\n  return MUTT_CMD_ERROR;\n}\n\n/**\n * parse_subscribe_to - Parse the 'subscribe-to' command - Implements Command::parse() - @ingroup command_parse\n *\n * The 'subscribe-to' command allows to subscribe to an IMAP-Mailbox.\n * Patterns are not supported.\n * Use it as follows: subscribe-to =folder\n */\nenum CommandResult parse_subscribe_to(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  if (!buf || !s || !err)\n    return MUTT_CMD_ERROR;\n\n  buf_reset(err);\n\n  if (MoreArgs(s))\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (MoreArgs(s))\n    {\n      buf_printf(err, _(\"%s: too many arguments\"), \"subscribe-to\");\n      return MUTT_CMD_WARNING;\n    }\n\n    if (!buf_is_empty(buf))\n    {\n      /* Expand and subscribe */\n      buf_expand_path(buf);\n      if (imap_subscribe(buf_string(buf), true) == 0)\n      {\n        mutt_message(_(\"Subscribed to %s\"), buf->data);\n        return MUTT_CMD_SUCCESS;\n      }\n\n      buf_printf(err, _(\"Could not subscribe to %s\"), buf->data);\n      return MUTT_CMD_ERROR;\n    }\n\n    mutt_debug(LL_DEBUG1, \"Corrupted buffer\");\n    return MUTT_CMD_ERROR;\n  }\n\n  buf_addstr(err, _(\"No folder specified\"));\n  return MUTT_CMD_WARNING;\n}\n\n/**\n * parse_tag_formats - Parse the 'tag-formats' command - Implements Command::parse() - @ingroup command_parse\n *\n * Parse config like: `tag-formats pgp GP`\n *\n * @note This maps format -> tag\n */\nstatic enum CommandResult parse_tag_formats(struct Buffer *buf, struct Buffer *s,\n                                            intptr_t data, struct Buffer *err)\n{\n  if (!s)\n    return MUTT_CMD_ERROR;\n\n  struct Buffer *tagbuf = buf_pool_get();\n  struct Buffer *fmtbuf = buf_pool_get();\n\n  while (MoreArgs(s))\n  {\n    parse_extract_token(tagbuf, s, TOKEN_NO_FLAGS);\n    const char *tag = buf_string(tagbuf);\n    if (*tag == '\\0')\n      continue;\n\n    parse_extract_token(fmtbuf, s, TOKEN_NO_FLAGS);\n    const char *fmt = buf_string(fmtbuf);\n\n    /* avoid duplicates */\n    const char *tmp = mutt_hash_find(TagFormats, fmt);\n    if (tmp)\n    {\n      mutt_warning(_(\"tag format '%s' already registered as '%s'\"), fmt, tmp);\n      continue;\n    }\n\n    mutt_hash_insert(TagFormats, fmt, mutt_str_dup(tag));\n  }\n\n  buf_pool_release(&tagbuf);\n  buf_pool_release(&fmtbuf);\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_tag_transforms - Parse the 'tag-transforms' command - Implements Command::parse() - @ingroup command_parse\n *\n * Parse config like: `tag-transforms pgp P`\n *\n * @note This maps tag -> transform\n */\nstatic enum CommandResult parse_tag_transforms(struct Buffer *buf, struct Buffer *s,\n                                               intptr_t data, struct Buffer *err)\n{\n  if (!s)\n    return MUTT_CMD_ERROR;\n\n  struct Buffer *tagbuf = buf_pool_get();\n  struct Buffer *trnbuf = buf_pool_get();\n\n  while (MoreArgs(s))\n  {\n    parse_extract_token(tagbuf, s, TOKEN_NO_FLAGS);\n    const char *tag = buf_string(tagbuf);\n    if (*tag == '\\0')\n      continue;\n\n    parse_extract_token(trnbuf, s, TOKEN_NO_FLAGS);\n    const char *trn = buf_string(trnbuf);\n\n    /* avoid duplicates */\n    const char *tmp = mutt_hash_find(TagTransforms, tag);\n    if (tmp)\n    {\n      mutt_warning(_(\"tag transform '%s' already registered as '%s'\"), tag, tmp);\n      continue;\n    }\n\n    mutt_hash_insert(TagTransforms, tag, mutt_str_dup(trn));\n  }\n\n  buf_pool_release(&tagbuf);\n  buf_pool_release(&trnbuf);\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unignore - Parse the 'unignore' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_unignore(struct Buffer *buf, struct Buffer *s,\n                                         intptr_t data, struct Buffer *err)\n{\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    /* don't add \"*\" to the unignore list */\n    if (!mutt_str_equal(buf->data, \"*\"))\n      add_to_stailq(&UnIgnore, buf->data);\n\n    remove_from_stailq(&Ignore, buf->data);\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unlists - Parse the 'unlists' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_unlists(struct Buffer *buf, struct Buffer *s,\n                                        intptr_t data, struct Buffer *err)\n{\n  mutt_hash_free(&AutoSubscribeCache);\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    mutt_regexlist_remove(&SubscribedLists, buf->data);\n    mutt_regexlist_remove(&MailLists, buf->data);\n\n    if (!mutt_str_equal(buf->data, \"*\") &&\n        (mutt_regexlist_add(&UnMailLists, buf->data, REG_ICASE, err) != 0))\n    {\n      return MUTT_CMD_ERROR;\n    }\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * do_unmailboxes - Remove a Mailbox from the Sidebar/notifications\n * @param m Mailbox to `unmailboxes`\n */\nstatic void do_unmailboxes(struct Mailbox *m)\n{\n#ifdef USE_INOTIFY\n  if (m->poll_new_mail)\n    mutt_monitor_remove(m);\n#endif\n  m->visible = false;\n  m->gen = -1;\n  if (m->opened)\n  {\n    struct EventMailbox ev_m = { NULL };\n    mutt_debug(LL_NOTIFY, \"NT_MAILBOX_CHANGE: NULL\\n\");\n    notify_send(NeoMutt->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);\n  }\n  else\n  {\n    account_mailbox_remove(m->account, m);\n    mailbox_free(&m);\n  }\n}\n\n/**\n * do_unmailboxes_star - Remove all Mailboxes from the Sidebar/notifications\n */\nstatic void do_unmailboxes_star(void)\n{\n  struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n  neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n  struct MailboxNode *np = NULL;\n  struct MailboxNode *nptmp = NULL;\n  STAILQ_FOREACH_SAFE(np, &ml, entries, nptmp)\n  {\n    do_unmailboxes(np->mailbox);\n  }\n  neomutt_mailboxlist_clear(&ml);\n}\n\n/**\n * parse_unmailboxes - Parse the 'unmailboxes' command - Implements Command::parse() - @ingroup command_parse\n *\n * This is also used by 'unvirtual-mailboxes'\n */\nenum CommandResult parse_unmailboxes(struct Buffer *buf, struct Buffer *s,\n                                     intptr_t data, struct Buffer *err)\n{\n  while (MoreArgs(s))\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (mutt_str_equal(buf->data, \"*\"))\n    {\n      do_unmailboxes_star();\n      return MUTT_CMD_SUCCESS;\n    }\n\n    buf_expand_path(buf);\n\n    struct Account *a = NULL;\n    TAILQ_FOREACH(a, &NeoMutt->accounts, entries)\n    {\n      struct Mailbox *m = mx_mbox_find(a, buf_string(buf));\n      if (m)\n      {\n        do_unmailboxes(m);\n        break;\n      }\n    }\n  }\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unmy_hdr - Parse the 'unmy_hdr' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_unmy_hdr(struct Buffer *buf, struct Buffer *s,\n                                         intptr_t data, struct Buffer *err)\n{\n  struct ListNode *np = NULL, *tmp = NULL;\n  size_t l;\n\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    if (mutt_str_equal(\"*\", buf->data))\n    {\n      /* Clear all headers, send a notification for each header */\n      STAILQ_FOREACH(np, &UserHeader, entries)\n      {\n        mutt_debug(LL_NOTIFY, \"NT_HEADER_DELETE: %s\\n\", np->data);\n        struct EventHeader ev_h = { np->data };\n        notify_send(NeoMutt->notify, NT_HEADER, NT_HEADER_DELETE, &ev_h);\n      }\n      mutt_list_free(&UserHeader);\n      continue;\n    }\n\n    l = mutt_str_len(buf->data);\n    if (buf->data[l - 1] == ':')\n      l--;\n\n    STAILQ_FOREACH_SAFE(np, &UserHeader, entries, tmp)\n    {\n      if (mutt_istrn_equal(buf->data, np->data, l) && (np->data[l] == ':'))\n      {\n        mutt_debug(LL_NOTIFY, \"NT_HEADER_DELETE: %s\\n\", np->data);\n        struct EventHeader ev_h = { np->data };\n        notify_send(NeoMutt->notify, NT_HEADER, NT_HEADER_DELETE, &ev_h);\n\n        header_free(&UserHeader, np);\n      }\n    }\n  } while (MoreArgs(s));\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unstailq - Parse an unlist command - Implements Command::parse() - @ingroup command_parse\n *\n * This is used by 'unalternative_order', 'unauto_view' and several others.\n */\nstatic enum CommandResult parse_unstailq(struct Buffer *buf, struct Buffer *s,\n                                         intptr_t data, struct Buffer *err)\n{\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    /* Check for deletion of entire list */\n    if (mutt_str_equal(buf->data, \"*\"))\n    {\n      mutt_list_free((struct ListHead *) data);\n      break;\n    }\n    remove_from_stailq((struct ListHead *) data, buf->data);\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unsubscribe - Parse the 'unsubscribe' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_unsubscribe(struct Buffer *buf, struct Buffer *s,\n                                            intptr_t data, struct Buffer *err)\n{\n  mutt_hash_free(&AutoSubscribeCache);\n  do\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    mutt_regexlist_remove(&SubscribedLists, buf->data);\n\n    if (!mutt_str_equal(buf->data, \"*\") &&\n        (mutt_regexlist_add(&UnSubscribedLists, buf->data, REG_ICASE, err) != 0))\n    {\n      return MUTT_CMD_ERROR;\n    }\n  } while (MoreArgs(s));\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_unsubscribe_from - Parse the 'unsubscribe-from' command - Implements Command::parse() - @ingroup command_parse\n *\n * The 'unsubscribe-from' command allows to unsubscribe from an IMAP-Mailbox.\n * Patterns are not supported.\n * Use it as follows: unsubscribe-from =folder\n */\nenum CommandResult parse_unsubscribe_from(struct Buffer *buf, struct Buffer *s,\n                                          intptr_t data, struct Buffer *err)\n{\n  if (!buf || !s || !err)\n    return MUTT_CMD_ERROR;\n\n  if (MoreArgs(s))\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n    if (MoreArgs(s))\n    {\n      buf_printf(err, _(\"%s: too many arguments\"), \"unsubscribe-from\");\n      return MUTT_CMD_WARNING;\n    }\n\n    if (buf->data && (*buf->data != '\\0'))\n    {\n      /* Expand and subscribe */\n      buf_expand_path(buf);\n      if (imap_subscribe(buf_string(buf), false) == 0)\n      {\n        mutt_message(_(\"Unsubscribed from %s\"), buf->data);\n        return MUTT_CMD_SUCCESS;\n      }\n\n      buf_printf(err, _(\"Could not unsubscribe from %s\"), buf->data);\n      return MUTT_CMD_ERROR;\n    }\n\n    mutt_debug(LL_DEBUG1, \"Corrupted buffer\");\n    return MUTT_CMD_ERROR;\n  }\n\n  buf_addstr(err, _(\"No folder specified\"));\n  return MUTT_CMD_WARNING;\n}\n\n/**\n * parse_version - Parse the 'version' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_version(struct Buffer *buf, struct Buffer *s,\n                                        intptr_t data, struct Buffer *err)\n{\n  // silently ignore 'version' if it's in a config file\n  if (!StartupComplete)\n    return MUTT_CMD_SUCCESS;\n\n  struct Buffer *tempfile = buf_pool_get();\n  buf_mktemp(tempfile);\n\n  FILE *fp_out = mutt_file_fopen(buf_string(tempfile), \"w\");\n  if (!fp_out)\n  {\n    // L10N: '%s' is the file name of the temporary file\n    buf_printf(err, _(\"Could not create temporary file %s\"), buf_string(tempfile));\n    buf_pool_release(&tempfile);\n    return MUTT_CMD_ERROR;\n  }\n\n  print_version(fp_out);\n  mutt_file_fclose(&fp_out);\n\n  struct PagerData pdata = { 0 };\n  struct PagerView pview = { &pdata };\n\n  pdata.fname = buf_string(tempfile);\n\n  pview.banner = \"version\";\n  pview.flags = MUTT_PAGER_NO_FLAGS;\n  pview.mode = PAGER_MODE_OTHER;\n\n  mutt_do_pager(&pview, NULL);\n  buf_pool_release(&tempfile);\n\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * source_stack_cleanup - Free memory from the stack used for the source command\n */\nvoid source_stack_cleanup(void)\n{\n  mutt_list_free(&MuttrcStack);\n}\n\n/**\n * MuttCommands - General NeoMutt Commands\n */\nstatic const struct Command MuttCommands[] = {\n  // clang-format off\n  { \"alias\",               parse_alias,            0 },\n  { \"alternates\",          parse_alternates,       0 },\n  { \"alternative_order\",   parse_stailq,           IP &AlternativeOrderList },\n  { \"attachments\",         parse_attachments,      0 },\n  { \"auto_view\",           parse_stailq,           IP &AutoViewList },\n  { \"bind\",                mutt_parse_bind,        0 },\n  { \"cd\",                  parse_cd,               0 },\n  { \"color\",               mutt_parse_color,       0 },\n  { \"echo\",                parse_echo,             0 },\n  { \"exec\",                mutt_parse_exec,        0 },\n  { \"finish\",              parse_finish,           0 },\n  { \"group\",               parse_group,            MUTT_GROUP },\n  { \"hdr_order\",           parse_stailq,           IP &HeaderOrderList },\n  { \"ifdef\",               parse_ifdef,            0 },\n  { \"ifndef\",              parse_ifdef,            1 },\n  { \"ignore\",              parse_ignore,           0 },\n  { \"lists\",               parse_lists,            0 },\n  { \"macro\",               mutt_parse_macro,       1 },\n  { \"mailboxes\",           parse_mailboxes,        0 },\n  { \"mailto_allow\",        parse_stailq,           IP &MailToAllow },\n  { \"mime_lookup\",         parse_stailq,           IP &MimeLookupList },\n  { \"mono\",                mutt_parse_mono,        0 },\n  { \"my_hdr\",              parse_my_hdr,           0 },\n  { \"named-mailboxes\",     parse_mailboxes,        MUTT_NAMED },\n  { \"nospam\",              parse_nospam,           0 },\n  { \"push\",                mutt_parse_push,        0 },\n  { \"reset\",               parse_set,              MUTT_SET_RESET },\n  { \"score\",               mutt_parse_score,       0 },\n  { \"set\",                 parse_set,              MUTT_SET_SET },\n  { \"setenv\",              parse_setenv,           MUTT_SET_SET },\n  { \"source\",              parse_source,           0 },\n  { \"spam\",                parse_spam,             0 },\n  { \"subjectrx\",           parse_subjectrx_list,   0 },\n  { \"subscribe\",           parse_subscribe,        0 },\n  { \"tag-formats\",         parse_tag_formats,      0 },\n  { \"tag-transforms\",      parse_tag_transforms,   0 },\n  { \"toggle\",              parse_set,              MUTT_SET_INV },\n  { \"unalias\",             parse_unalias,          0 },\n  { \"unalternates\",        parse_unalternates,     0 },\n  { \"unalternative_order\", parse_unstailq,         IP &AlternativeOrderList },\n  { \"unattachments\",       parse_unattachments,    0 },\n  { \"unauto_view\",         parse_unstailq,         IP &AutoViewList },\n  { \"unbind\",              mutt_parse_unbind,      MUTT_UNBIND },\n  { \"uncolor\",             mutt_parse_uncolor,     0 },\n  { \"ungroup\",             parse_group,            MUTT_UNGROUP },\n  { \"unhdr_order\",         parse_unstailq,         IP &HeaderOrderList },\n  { \"unignore\",            parse_unignore,         0 },\n  { \"unlists\",             parse_unlists,          0 },\n  { \"unmacro\",             mutt_parse_unbind,      MUTT_UNMACRO },\n  { \"unmailboxes\",         parse_unmailboxes,      0 },\n  { \"unmailto_allow\",      parse_unstailq,         IP &MailToAllow },\n  { \"unmime_lookup\",       parse_unstailq,         IP &MimeLookupList },\n  { \"unmono\",              mutt_parse_unmono,      0 },\n  { \"unmy_hdr\",            parse_unmy_hdr,         0 },\n  { \"unscore\",             mutt_parse_unscore,     0 },\n  { \"unset\",               parse_set,              MUTT_SET_UNSET },\n  { \"unsetenv\",            parse_setenv,           MUTT_SET_UNSET },\n  { \"unsubjectrx\",         parse_unsubjectrx_list, 0 },\n  { \"unsubscribe\",         parse_unsubscribe,      0 },\n  { \"version\",             parse_version,          0 },\n  // clang-format on\n};\n\n/**\n * commands_init - Initialize commands array and register default commands\n */\nvoid commands_init(void)\n{\n  commands_register(MuttCommands, mutt_array_size(MuttCommands));\n}\n"
        },
        {
          "name": "commands.h",
          "type": "blob",
          "size": 2.4130859375,
          "content": "/**\n * @file\n * Functions to parse commands in a config file\n *\n * @authors\n * Copyright (C) 2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_COMMANDS_H\n#define MUTT_COMMANDS_H\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct GroupList;\n\n/* parameter to parse_mailboxes */\n#define MUTT_NAMED   (1 << 0)\n\nenum CommandResult parse_mailboxes       (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_my_hdr          (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_subjectrx_list  (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_subscribe_to    (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unalternates    (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unmailboxes     (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unsubjectrx_list(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unsubscribe_from(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\n\nenum CommandResult parse_rc_line_cwd(const char *line, char *cwd, struct Buffer *err);\nchar *mutt_get_sourced_cwd(void);\nbool mailbox_add_simple(const char *mailbox, struct Buffer *err);\n\nint parse_grouplist(struct GroupList *gl, struct Buffer *buf, struct Buffer *s, struct Buffer *err);\nvoid source_stack_cleanup(void);\nint source_rc(const char *rcfile_path, struct Buffer *err);\n\nenum CommandResult set_dump(ConfigDumpFlags flags, struct Buffer *err);\n\n#endif /* MUTT_COMMANDS_H */\n"
        },
        {
          "name": "complete",
          "type": "tree",
          "content": null
        },
        {
          "name": "compmbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "compose",
          "type": "tree",
          "content": null
        },
        {
          "name": "compress",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.142578125,
          "content": "#!/bin/sh\ndir=\"`dirname \"$0\"`/autosetup\"\n#@@INITCHECK@@#\nWRAPPER=\"$0\"; export WRAPPER; exec \"`\"$dir/autosetup-find-tclsh\"`\" \"$dir/autosetup\" \"$@\"\n"
        },
        {
          "name": "conn",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "convert",
          "type": "tree",
          "content": null
        },
        {
          "name": "copy.c",
          "type": "blob",
          "size": 31.478515625,
          "content": "/**\n * @file\n * Duplicate the structure of an entire email\n *\n * @authors\n * Copyright (C) 1996-2000,2002,2014 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2024 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017-2023 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2024 Dennis Schön <mail@dennis-schoen.de>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_copy Duplicate the structure of an entire email\n *\n * Duplicate the structure of an entire email\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <inttypes.h> // IWYU pragma: keep\n#include <locale.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"copy.h\"\n#include \"expando/lib.h\"\n#include \"index/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"pager/lib.h\"\n#include \"send/lib.h\"\n#include \"globals.h\"\n#include \"handler.h\"\n#include \"mx.h\"\n#ifdef USE_NOTMUCH\n#include \"notmuch/lib.h\"\n#include \"muttlib.h\"\n#endif\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\nstatic int address_header_decode(char **h);\nstatic int copy_delete_attach(struct Body *b, FILE *fp_in, FILE *fp_out,\n                              const char *quoted_date);\n\nARRAY_HEAD(HeaderArray, char *);\n\n/**\n * add_one_header - Add a header to a Headers array\n * @param headers Headers array\n * @param pos     Position to insert new header\n * @param value   Text to insert\n *\n * If a header already exists in that position, the new text will be\n * concatenated on the old.\n */\nstatic void add_one_header(struct HeaderArray *headers, size_t pos, char *value)\n{\n  char **old = ARRAY_GET(headers, pos);\n  if (old && *old)\n  {\n    char *new_value = NULL;\n    mutt_str_asprintf(&new_value, \"%s%s\", *old, value);\n    FREE(old);\n    FREE(&value);\n    value = new_value;\n  }\n  ARRAY_SET(headers, pos, value);\n}\n\n/**\n * mutt_copy_hdr - Copy header from one file to another\n * @param fp_in     FILE pointer to read from\n * @param fp_out    FILE pointer to write to\n * @param off_start Offset to start from\n * @param off_end   Offset to finish at\n * @param chflags   Flags, see #CopyHeaderFlags\n * @param prefix    Prefix for quoting headers\n * @param wraplen   Width to wrap at (when chflags & CH_DISPLAY)\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Ok, the only reason for not merging this with mutt_copy_header() below is to\n * avoid creating a Email structure in message_handler().  Also, this one will\n * wrap headers much more aggressively than the other one.\n */\nint mutt_copy_hdr(FILE *fp_in, FILE *fp_out, LOFF_T off_start, LOFF_T off_end,\n                  CopyHeaderFlags chflags, const char *prefix, int wraplen)\n{\n  bool from = false;\n  bool this_is_from = false;\n  bool ignore = false;\n  char buf[1024] = { 0 }; /* should be long enough to get most fields in one pass */\n  char *nl = NULL;\n  struct HeaderArray headers = ARRAY_HEAD_INITIALIZER;\n  int hdr_count;\n  int x;\n  char *this_one = NULL;\n  size_t this_one_len = 0;\n\n  if (off_start < 0)\n    return -1;\n\n  if (ftello(fp_in) != off_start)\n    if (!mutt_file_seek(fp_in, off_start, SEEK_SET))\n      return -1;\n\n  buf[0] = '\\n';\n  buf[1] = '\\0';\n\n  if ((chflags & (CH_REORDER | CH_WEED | CH_MIME | CH_DECODE | CH_PREFIX | CH_WEED_DELIVERED)) == 0)\n  {\n    /* Without these flags to complicate things\n     * we can do a more efficient line to line copying */\n    while (ftello(fp_in) < off_end)\n    {\n      nl = strchr(buf, '\\n');\n\n      if (!fgets(buf, sizeof(buf), fp_in))\n        break;\n\n      /* Is it the beginning of a header? */\n      if (nl && (buf[0] != ' ') && (buf[0] != '\\t'))\n      {\n        ignore = true;\n        if (!from && mutt_str_startswith(buf, \"From \"))\n        {\n          if ((chflags & CH_FROM) == 0)\n            continue;\n          from = true;\n        }\n        else if ((chflags & CH_NOQFROM) && mutt_istr_startswith(buf, \">From \"))\n        {\n          continue;\n        }\n        else if ((buf[0] == '\\n') || ((buf[0] == '\\r') && (buf[1] == '\\n')))\n        {\n          break; /* end of header */\n        }\n\n        if ((chflags & (CH_UPDATE | CH_XMIT | CH_NOSTATUS)) &&\n            (mutt_istr_startswith(buf, \"Status:\") || mutt_istr_startswith(buf, \"X-Status:\")))\n        {\n          continue;\n        }\n        if ((chflags & (CH_UPDATE_LEN | CH_XMIT | CH_NOLEN)) &&\n            (mutt_istr_startswith(buf, \"Content-Length:\") ||\n             mutt_istr_startswith(buf, \"Lines:\")))\n        {\n          continue;\n        }\n        if ((chflags & CH_UPDATE_REFS) && mutt_istr_startswith(buf, \"References:\"))\n        {\n          continue;\n        }\n        if ((chflags & CH_UPDATE_IRT) && mutt_istr_startswith(buf, \"In-Reply-To:\"))\n        {\n          continue;\n        }\n        if (chflags & CH_UPDATE_LABEL && mutt_istr_startswith(buf, \"X-Label:\"))\n          continue;\n        if ((chflags & CH_UPDATE_SUBJECT) && mutt_istr_startswith(buf, \"Subject:\"))\n        {\n          continue;\n        }\n\n        ignore = false;\n      }\n\n      if (!ignore && (fputs(buf, fp_out) == EOF))\n        return -1;\n    }\n    return 0;\n  }\n\n  hdr_count = 1;\n  x = 0;\n\n  /* We are going to read and collect the headers in an array\n   * so we are able to do re-ordering.\n   * First count the number of entries in the array */\n  if (chflags & CH_REORDER)\n  {\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &HeaderOrderList, entries)\n    {\n      mutt_debug(LL_DEBUG3, \"Reorder list: %s\\n\", np->data);\n      hdr_count++;\n    }\n  }\n\n  mutt_debug(LL_DEBUG1, \"WEED is %sset\\n\", (chflags & CH_WEED) ? \"\" : \"not \");\n\n  ARRAY_RESERVE(&headers, hdr_count);\n\n  /* Read all the headers into the array */\n  while (ftello(fp_in) < off_end)\n  {\n    nl = strchr(buf, '\\n');\n\n    /* Read a line */\n    if (!fgets(buf, sizeof(buf), fp_in))\n      break;\n\n    /* Is it the beginning of a header? */\n    if (nl && (buf[0] != ' ') && (buf[0] != '\\t'))\n    {\n      /* Do we have anything pending? */\n      if (this_one)\n      {\n        if (chflags & CH_DECODE)\n        {\n          if (address_header_decode(&this_one) == 0)\n            rfc2047_decode(&this_one);\n          this_one_len = mutt_str_len(this_one);\n\n          /* Convert CRLF line endings to LF */\n          if ((this_one_len > 2) && (this_one[this_one_len - 2] == '\\r') &&\n              (this_one[this_one_len - 1] == '\\n'))\n          {\n            this_one[this_one_len - 2] = '\\n';\n            this_one[this_one_len - 1] = '\\0';\n          }\n        }\n\n        add_one_header(&headers, x, this_one);\n        this_one = NULL;\n      }\n\n      ignore = true;\n      this_is_from = false;\n      if (!from && mutt_str_startswith(buf, \"From \"))\n      {\n        if ((chflags & CH_FROM) == 0)\n          continue;\n        this_is_from = true;\n        from = true;\n      }\n      else if ((buf[0] == '\\n') || ((buf[0] == '\\r') && (buf[1] == '\\n')))\n      {\n        break; /* end of header */\n      }\n\n      /* note: CH_FROM takes precedence over header weeding. */\n      if (!((chflags & CH_FROM) && (chflags & CH_FORCE_FROM) && this_is_from) &&\n          (chflags & CH_WEED) && mutt_matches_ignore(buf))\n      {\n        continue;\n      }\n      if ((chflags & CH_WEED_DELIVERED) && mutt_istr_startswith(buf, \"Delivered-To:\"))\n      {\n        continue;\n      }\n      if ((chflags & (CH_UPDATE | CH_XMIT | CH_NOSTATUS)) &&\n          (mutt_istr_startswith(buf, \"Status:\") || mutt_istr_startswith(buf, \"X-Status:\")))\n      {\n        continue;\n      }\n      if ((chflags & (CH_UPDATE_LEN | CH_XMIT | CH_NOLEN)) &&\n          (mutt_istr_startswith(buf, \"Content-Length:\") || mutt_istr_startswith(buf, \"Lines:\")))\n      {\n        continue;\n      }\n      if ((chflags & CH_MIME))\n      {\n        if (mutt_istr_startswith(buf, \"mime-version:\"))\n        {\n          continue;\n        }\n        size_t plen = mutt_istr_startswith(buf, \"content-\");\n        if ((plen != 0) && (mutt_istr_startswith(buf + plen, \"transfer-encoding:\") ||\n                            mutt_istr_startswith(buf + plen, \"type:\")))\n        {\n          continue;\n        }\n      }\n      if ((chflags & CH_UPDATE_REFS) && mutt_istr_startswith(buf, \"References:\"))\n      {\n        continue;\n      }\n      if ((chflags & CH_UPDATE_IRT) && mutt_istr_startswith(buf, \"In-Reply-To:\"))\n      {\n        continue;\n      }\n      if ((chflags & CH_UPDATE_LABEL) && mutt_istr_startswith(buf, \"X-Label:\"))\n        continue;\n      if ((chflags & CH_UPDATE_SUBJECT) && mutt_istr_startswith(buf, \"Subject:\"))\n      {\n        continue;\n      }\n\n      /* Find x -- the array entry where this header is to be saved */\n      if (chflags & CH_REORDER)\n      {\n        struct ListNode *np = NULL;\n        x = 0;\n        int match = -1;\n        size_t match_len = 0;\n\n        STAILQ_FOREACH(np, &HeaderOrderList, entries)\n        {\n          size_t hdr_order_len = mutt_str_len(np->data);\n          if (mutt_istrn_equal(buf, np->data, hdr_order_len))\n          {\n            if ((match == -1) || (hdr_order_len > match_len))\n            {\n              match = x;\n              match_len = hdr_order_len;\n            }\n            mutt_debug(LL_DEBUG2, \"Reorder: %s matches %s\", np->data, buf);\n          }\n          x++;\n        }\n        if (match != -1)\n          x = match;\n      }\n\n      ignore = false;\n    } /* If beginning of header */\n\n    if (!ignore)\n    {\n      mutt_debug(LL_DEBUG2, \"Reorder: x = %d; hdr_count = %d\\n\", x, hdr_count);\n      if (this_one)\n      {\n        size_t blen = mutt_str_len(buf);\n\n        MUTT_MEM_REALLOC(&this_one, this_one_len + blen + 1, char);\n        mutt_strn_copy(this_one + this_one_len, buf, blen, blen + 1);\n        this_one_len += blen;\n      }\n      else\n      {\n        this_one = mutt_str_dup(buf);\n        this_one_len = mutt_str_len(this_one);\n      }\n    }\n  } /* while (ftello (fp_in) < off_end) */\n\n  /* Do we have anything pending?  -- XXX, same code as in above in the loop. */\n  if (this_one)\n  {\n    if (chflags & CH_DECODE)\n    {\n      if (address_header_decode(&this_one) == 0)\n        rfc2047_decode(&this_one);\n      this_one_len = mutt_str_len(this_one);\n    }\n\n    add_one_header(&headers, x, this_one);\n    this_one = NULL;\n  }\n\n  /* Now output the headers in order */\n  bool error = false;\n  char **hp = NULL;\n  const short c_wrap = cs_subset_number(NeoMutt->sub, \"wrap\");\n\n  ARRAY_FOREACH(hp, &headers)\n  {\n    if (!error && hp && *hp)\n    {\n      /* We couldn't do the prefixing when reading because RFC2047\n       * decoding may have concatenated lines.  */\n      if (chflags & (CH_DECODE | CH_PREFIX))\n      {\n        const char *pre = (chflags & CH_PREFIX) ? prefix : NULL;\n        wraplen = mutt_window_wrap_cols(wraplen, c_wrap);\n\n        if (mutt_write_one_header(fp_out, 0, *hp, pre, wraplen, chflags, NeoMutt->sub) == -1)\n        {\n          error = true;\n        }\n      }\n      else\n      {\n        if (fputs(*hp, fp_out) == EOF)\n        {\n          error = true;\n        }\n      }\n    }\n\n    FREE(hp);\n  }\n  ARRAY_FREE(&headers);\n\n  if (error)\n    return -1;\n  return 0;\n}\n\n/**\n * mutt_copy_header - Copy Email header\n * @param fp_in    FILE pointer to read from\n * @param e        Email\n * @param fp_out   FILE pointer to write to\n * @param chflags  See #CopyHeaderFlags\n * @param prefix   Prefix for quoting headers (if #CH_PREFIX is set)\n * @param wraplen  Width to wrap at (when chflags & CH_DISPLAY)\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mutt_copy_header(FILE *fp_in, struct Email *e, FILE *fp_out,\n                     CopyHeaderFlags chflags, const char *prefix, int wraplen)\n{\n  char *temp_hdr = NULL;\n\n  if (e->env)\n  {\n    chflags |= ((e->env->changed & MUTT_ENV_CHANGED_IRT) ? CH_UPDATE_IRT : 0) |\n               ((e->env->changed & MUTT_ENV_CHANGED_REFS) ? CH_UPDATE_REFS : 0) |\n               ((e->env->changed & MUTT_ENV_CHANGED_XLABEL) ? CH_UPDATE_LABEL : 0) |\n               ((e->env->changed & MUTT_ENV_CHANGED_SUBJECT) ? CH_UPDATE_SUBJECT : 0);\n  }\n\n  if (mutt_copy_hdr(fp_in, fp_out, e->offset, e->body->offset, chflags, prefix, wraplen) == -1)\n    return -1;\n\n  if (chflags & CH_TXTPLAIN)\n  {\n    char chsbuf[128] = { 0 };\n    char buf[128] = { 0 };\n    fputs(\"MIME-Version: 1.0\\n\", fp_out);\n    fputs(\"Content-Transfer-Encoding: 8bit\\n\", fp_out);\n    fputs(\"Content-Type: text/plain; charset=\", fp_out);\n    const char *const c_charset = cc_charset();\n    mutt_ch_canonical_charset(chsbuf, sizeof(chsbuf), c_charset ? c_charset : \"us-ascii\");\n    mutt_addr_cat(buf, sizeof(buf), chsbuf, MimeSpecials);\n    fputs(buf, fp_out);\n    fputc('\\n', fp_out);\n  }\n\n  if ((chflags & CH_UPDATE_IRT) && !STAILQ_EMPTY(&e->env->in_reply_to))\n  {\n    fputs(\"In-Reply-To:\", fp_out);\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &e->env->in_reply_to, entries)\n    {\n      fputc(' ', fp_out);\n      fputs(np->data, fp_out);\n    }\n    fputc('\\n', fp_out);\n  }\n\n  if ((chflags & CH_UPDATE_REFS) && !STAILQ_EMPTY(&e->env->references))\n  {\n    fputs(\"References:\", fp_out);\n    mutt_write_references(&e->env->references, fp_out, 0);\n    fputc('\\n', fp_out);\n  }\n\n  if ((chflags & CH_UPDATE) && ((chflags & CH_NOSTATUS) == 0))\n  {\n    if (e->old || e->read)\n    {\n      fputs(\"Status: \", fp_out);\n      if (e->read)\n        fputs(\"RO\", fp_out);\n      else if (e->old)\n        fputc('O', fp_out);\n      fputc('\\n', fp_out);\n    }\n\n    if (e->flagged || e->replied)\n    {\n      fputs(\"X-Status: \", fp_out);\n      if (e->replied)\n        fputc('A', fp_out);\n      if (e->flagged)\n        fputc('F', fp_out);\n      fputc('\\n', fp_out);\n    }\n  }\n\n  if (chflags & CH_UPDATE_LEN && ((chflags & CH_NOLEN) == 0))\n  {\n    fprintf(fp_out, \"Content-Length: \" OFF_T_FMT \"\\n\", e->body->length);\n    if ((e->lines != 0) || (e->body->length == 0))\n      fprintf(fp_out, \"Lines: %d\\n\", e->lines);\n  }\n\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n#ifdef USE_NOTMUCH\n  if (chflags & CH_VIRTUAL)\n  {\n    /* Add some fake headers based on notmuch data */\n    char *folder = nm_email_get_folder(e);\n    if (folder && !(c_weed && mutt_matches_ignore(\"folder\")))\n    {\n      char buf[1024] = { 0 };\n      mutt_str_copy(buf, folder, sizeof(buf));\n      mutt_pretty_mailbox(buf, sizeof(buf));\n\n      fputs(\"Folder: \", fp_out);\n      fputs(buf, fp_out);\n      fputc('\\n', fp_out);\n    }\n  }\n#endif\n\n  struct Buffer *tags = buf_pool_get();\n  driver_tags_get(&e->tags, tags);\n  if (!buf_is_empty(tags) && !(c_weed && mutt_matches_ignore(\"tags\")))\n  {\n    fputs(\"Tags: \", fp_out);\n    fputs(buf_string(tags), fp_out);\n    fputc('\\n', fp_out);\n  }\n  buf_pool_release(&tags);\n\n  const struct Slist *const c_send_charset = cs_subset_slist(NeoMutt->sub, \"send_charset\");\n  const short c_wrap = cs_subset_number(NeoMutt->sub, \"wrap\");\n  if ((chflags & CH_UPDATE_LABEL) && e->env->x_label)\n  {\n    temp_hdr = e->env->x_label;\n    /* env->x_label isn't currently stored with direct references elsewhere.\n     * Mailbox->label_hash strdups the keys.  But to be safe, encode a copy */\n    if (!(chflags & CH_DECODE))\n    {\n      temp_hdr = mutt_str_dup(temp_hdr);\n      rfc2047_encode(&temp_hdr, NULL, sizeof(\"X-Label:\"), c_send_charset);\n    }\n    if (mutt_write_one_header(fp_out, \"X-Label\", temp_hdr, (chflags & CH_PREFIX) ? prefix : 0,\n                              mutt_window_wrap_cols(wraplen, c_wrap), chflags,\n                              NeoMutt->sub) == -1)\n    {\n      return -1;\n    }\n    if (!(chflags & CH_DECODE))\n      FREE(&temp_hdr);\n  }\n\n  if ((chflags & CH_UPDATE_SUBJECT) && e->env->subject)\n  {\n    temp_hdr = e->env->subject;\n    /* env->subject is directly referenced in Mailbox->subj_hash, so we\n     * have to be careful not to encode (and thus free) that memory. */\n    if (!(chflags & CH_DECODE))\n    {\n      temp_hdr = mutt_str_dup(temp_hdr);\n      rfc2047_encode(&temp_hdr, NULL, sizeof(\"Subject:\"), c_send_charset);\n    }\n    if (mutt_write_one_header(fp_out, \"Subject\", temp_hdr, (chflags & CH_PREFIX) ? prefix : 0,\n                              mutt_window_wrap_cols(wraplen, c_wrap), chflags,\n                              NeoMutt->sub) == -1)\n    {\n      return -1;\n    }\n    if (!(chflags & CH_DECODE))\n      FREE(&temp_hdr);\n  }\n\n  if ((chflags & CH_NONEWLINE) == 0)\n  {\n    if (chflags & CH_PREFIX)\n      fputs(prefix, fp_out);\n    fputc('\\n', fp_out); /* add header terminator */\n  }\n\n  if (ferror(fp_out) || feof(fp_out))\n    return -1;\n\n  return 0;\n}\n\n/**\n * count_delete_lines - Count lines to be deleted in this email body\n * @param fp      FILE pointer to read from\n * @param b       Email Body\n * @param length  Number of bytes to be deleted\n * @param datelen Length of the date\n * @retval num Number of lines to be deleted\n * @retval -1 on error\n *\n * Count the number of lines and bytes to be deleted in this body\n */\nstatic int count_delete_lines(FILE *fp, struct Body *b, LOFF_T *length, size_t datelen)\n{\n  int dellines = 0;\n\n  if (b->deleted)\n  {\n    if (!mutt_file_seek(fp, b->offset, SEEK_SET))\n    {\n      return -1;\n    }\n    for (long l = b->length; l; l--)\n    {\n      const int ch = getc(fp);\n      if (ch == EOF)\n        break;\n      if (ch == '\\n')\n        dellines++;\n    }\n    /* 3 and 89 come from the added header of three lines in\n     * copy_delete_attach().  89 is the size of the header(including\n     * the newlines, tabs, and a single digit length), not including\n     * the date length. */\n    dellines -= 3;\n    *length -= b->length - (89 + datelen);\n    /* Count the number of digits exceeding the first one to write the size */\n    for (long l = 10; b->length >= l; l *= 10)\n      (*length)++;\n  }\n  else\n  {\n    for (b = b->parts; b; b = b->next)\n    {\n      const int del = count_delete_lines(fp, b, length, datelen);\n      if (del == -1)\n      {\n        return -1;\n      }\n      dellines += del;\n    }\n  }\n  return dellines;\n}\n\n/**\n * mutt_copy_message_fp - Make a copy of a message from a FILE pointer\n * @param fp_out  Where to write output\n * @param fp_in   Where to get input\n * @param e       Email being copied\n * @param cmflags Flags, see #CopyMessageFlags\n * @param chflags Flags, see #CopyHeaderFlags\n * @param wraplen Width to wrap at (when chflags & CH_DISPLAY)\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mutt_copy_message_fp(FILE *fp_out, FILE *fp_in, struct Email *e,\n                         CopyMessageFlags cmflags, CopyHeaderFlags chflags, int wraplen)\n{\n  struct Body *body = e->body;\n  struct Buffer *prefix = buf_pool_get();\n  LOFF_T new_offset = -1;\n  int rc = 0;\n\n  if (cmflags & MUTT_CM_PREFIX)\n  {\n    const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n    if (c_text_flowed)\n    {\n      buf_strcpy(prefix, \">\");\n    }\n    else\n    {\n      const char *const c_attribution_locale = cs_subset_string(NeoMutt->sub, \"attribution_locale\");\n      const struct Expando *c_indent_string = cs_subset_expando(NeoMutt->sub, \"indent_string\");\n      struct Mailbox *m_cur = get_current_mailbox();\n      setlocale(LC_TIME, NONULL(c_attribution_locale));\n      mutt_make_string(prefix, -1, c_indent_string, m_cur, -1, e, MUTT_FORMAT_NO_FLAGS, NULL);\n      setlocale(LC_TIME, \"\");\n    }\n  }\n\n  if ((cmflags & MUTT_CM_NOHEADER) == 0)\n  {\n    if (cmflags & MUTT_CM_PREFIX)\n    {\n      chflags |= CH_PREFIX;\n    }\n    else if (e->attach_del && (chflags & CH_UPDATE_LEN))\n    {\n      int new_lines;\n      int rc_attach_del = -1;\n      LOFF_T new_length = body->length;\n      struct Buffer *quoted_date = NULL;\n\n      quoted_date = buf_pool_get();\n      buf_addch(quoted_date, '\"');\n      mutt_date_make_date(quoted_date, cs_subset_bool(NeoMutt->sub, \"local_date_header\"));\n      buf_addch(quoted_date, '\"');\n\n      /* Count the number of lines and bytes to be deleted */\n      if (!mutt_file_seek(fp_in, body->offset, SEEK_SET))\n      {\n        goto attach_del_cleanup;\n      }\n      const int del = count_delete_lines(fp_in, body, &new_length, buf_len(quoted_date));\n      if (del == -1)\n      {\n        goto attach_del_cleanup;\n      }\n      new_lines = e->lines - del;\n\n      /* Copy the headers */\n      if (mutt_copy_header(fp_in, e, fp_out, chflags | CH_NOLEN | CH_NONEWLINE, NULL, wraplen))\n        goto attach_del_cleanup;\n      fprintf(fp_out, \"Content-Length: \" OFF_T_FMT \"\\n\", new_length);\n      if (new_lines <= 0)\n        new_lines = 0;\n      else\n        fprintf(fp_out, \"Lines: %d\\n\", new_lines);\n\n      putc('\\n', fp_out);\n      if (ferror(fp_out) || feof(fp_out))\n        goto attach_del_cleanup;\n      new_offset = ftello(fp_out);\n\n      /* Copy the body */\n      if (!mutt_file_seek(fp_in, body->offset, SEEK_SET))\n        goto attach_del_cleanup;\n      if (copy_delete_attach(body, fp_in, fp_out, buf_string(quoted_date)))\n        goto attach_del_cleanup;\n\n      buf_pool_release(&quoted_date);\n\n      LOFF_T fail = ((ftello(fp_out) - new_offset) - new_length);\n      if (fail)\n      {\n        mutt_error(ngettext(\"The length calculation was wrong by %ld byte\",\n                            \"The length calculation was wrong by %ld bytes\", fail),\n                   (long) fail);\n        new_length += fail;\n      }\n\n      /* Update original message if we are sync'ing a mailfolder */\n      if (cmflags & MUTT_CM_UPDATE)\n      {\n        e->attach_del = false;\n        e->lines = new_lines;\n        body->offset = new_offset;\n\n        body->length = new_length;\n        mutt_body_free(&body->parts);\n      }\n\n      rc_attach_del = 0;\n\n    attach_del_cleanup:\n      buf_pool_release(&quoted_date);\n      rc = rc_attach_del;\n      goto done;\n    }\n\n    if (mutt_copy_header(fp_in, e, fp_out, chflags,\n                         (chflags & CH_PREFIX) ? buf_string(prefix) : NULL, wraplen) == -1)\n    {\n      rc = -1;\n      goto done;\n    }\n\n    new_offset = ftello(fp_out);\n  }\n\n  if (cmflags & MUTT_CM_DECODE)\n  {\n    /* now make a text/plain version of the message */\n    struct State state = { 0 };\n    state.fp_in = fp_in;\n    state.fp_out = fp_out;\n    if (cmflags & MUTT_CM_PREFIX)\n      state.prefix = buf_string(prefix);\n    if (cmflags & MUTT_CM_DISPLAY)\n    {\n      state.flags |= STATE_DISPLAY;\n      state.wraplen = wraplen;\n      const char *const c_pager = pager_get_pager(NeoMutt->sub);\n      if (!c_pager)\n        state.flags |= STATE_PAGER;\n    }\n    if (cmflags & MUTT_CM_PRINTING)\n      state.flags |= STATE_PRINTING;\n    if (cmflags & MUTT_CM_WEED)\n      state.flags |= STATE_WEED;\n    if (cmflags & MUTT_CM_CHARCONV)\n      state.flags |= STATE_CHARCONV;\n    if (cmflags & MUTT_CM_REPLYING)\n      state.flags |= STATE_REPLYING;\n\n    if ((WithCrypto != 0) && cmflags & MUTT_CM_VERIFY)\n      state.flags |= STATE_VERIFY;\n\n    rc = mutt_body_handler(body, &state);\n  }\n  else if ((WithCrypto != 0) && (cmflags & MUTT_CM_DECODE_CRYPT) && (e->security & SEC_ENCRYPT))\n  {\n    struct Body *cur = NULL;\n    FILE *fp = NULL;\n\n    if (((WithCrypto & APPLICATION_PGP) != 0) && (cmflags & MUTT_CM_DECODE_PGP) &&\n        (e->security & APPLICATION_PGP) && (e->body->type == TYPE_MULTIPART))\n    {\n      if (crypt_pgp_decrypt_mime(fp_in, &fp, e->body, &cur))\n      {\n        rc = 1;\n        goto done;\n      }\n      fputs(\"MIME-Version: 1.0\\n\", fp_out);\n    }\n\n    if (((WithCrypto & APPLICATION_SMIME) != 0) && (cmflags & MUTT_CM_DECODE_SMIME) &&\n        (e->security & APPLICATION_SMIME) && (e->body->type == TYPE_APPLICATION))\n    {\n      if (crypt_smime_decrypt_mime(fp_in, &fp, e->body, &cur))\n      {\n        rc = 1;\n        goto done;\n      }\n    }\n\n    if (!cur)\n    {\n      mutt_error(_(\"No decryption engine available for message\"));\n      rc = 1;\n      goto done;\n    }\n\n    mutt_write_mime_header(cur, fp_out, NeoMutt->sub);\n    fputc('\\n', fp_out);\n\n    if (!mutt_file_seek(fp, cur->offset, SEEK_SET))\n    {\n      rc = 1;\n      goto done;\n    }\n\n    if (mutt_file_copy_bytes(fp, fp_out, cur->length) == -1)\n    {\n      mutt_file_fclose(&fp);\n      mutt_body_free(&cur);\n      rc = 1;\n      goto done;\n    }\n    mutt_body_free(&cur);\n    mutt_file_fclose(&fp);\n  }\n  else\n  {\n    if (!mutt_file_seek(fp_in, body->offset, SEEK_SET))\n    {\n      rc = 1;\n      goto done;\n    }\n    if (cmflags & MUTT_CM_PREFIX)\n    {\n      int c;\n      size_t bytes = body->length;\n\n      fputs(buf_string(prefix), fp_out);\n\n      while (((c = fgetc(fp_in)) != EOF) && bytes--)\n      {\n        fputc(c, fp_out);\n        if (c == '\\n')\n        {\n          fputs(buf_string(prefix), fp_out);\n        }\n      }\n    }\n    else if (mutt_file_copy_bytes(fp_in, fp_out, body->length) == -1)\n    {\n      rc = 1;\n      goto done;\n    }\n  }\n\n  if ((cmflags & MUTT_CM_UPDATE) && ((cmflags & MUTT_CM_NOHEADER) == 0) &&\n      (new_offset != -1))\n  {\n    body->offset = new_offset;\n    mutt_body_free(&body->parts);\n  }\n\ndone:\n  buf_pool_release(&prefix);\n  return rc;\n}\n\n/**\n * mutt_copy_message - Copy a message from a Mailbox\n * @param fp_out  FILE pointer to write to\n * @param e       Email\n * @param msg     Message\n * @param cmflags Flags, see #CopyMessageFlags\n * @param chflags Flags, see #CopyHeaderFlags\n * @param wraplen Width to wrap at (when chflags & CH_DISPLAY)\n * @retval  0 Success\n * @retval -1 Failure\n *\n * should be made to return -1 on fatal errors, and 1 on non-fatal errors\n * like partial decode, where it is worth displaying as much as possible\n */\nint mutt_copy_message(FILE *fp_out, struct Email *e, struct Message *msg,\n                      CopyMessageFlags cmflags, CopyHeaderFlags chflags, int wraplen)\n{\n  if (!msg || !e->body)\n  {\n    return -1;\n  }\n  if (fp_out == msg->fp)\n  {\n    mutt_debug(LL_DEBUG1, \"trying to read/write from/to the same FILE*!\\n\");\n    return -1;\n  }\n\n  int rc = mutt_copy_message_fp(fp_out, msg->fp, e, cmflags, chflags, wraplen);\n  if ((rc == 0) && (ferror(fp_out) || feof(fp_out)))\n  {\n    mutt_debug(LL_DEBUG1, \"failed to detect EOF!\\n\");\n    rc = -1;\n  }\n  return rc;\n}\n\n/**\n * append_message - Appends a copy of the given message to a mailbox\n * @param dest    destination mailbox\n * @param fp_in    where to get input\n * @param src     source mailbox\n * @param e       Email being copied\n * @param cmflags Flags, see #CopyMessageFlags\n * @param chflags Flags, see #CopyHeaderFlags\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int append_message(struct Mailbox *dest, FILE *fp_in, struct Mailbox *src,\n                          struct Email *e, CopyMessageFlags cmflags, CopyHeaderFlags chflags)\n{\n  char buf[256] = { 0 };\n  struct Message *msg = NULL;\n  int rc;\n\n  if (!mutt_file_seek(fp_in, e->offset, SEEK_SET))\n    return -1;\n  if (!fgets(buf, sizeof(buf), fp_in))\n    return -1;\n\n  msg = mx_msg_open_new(dest, e, is_from(buf, NULL, 0, NULL) ? MUTT_MSG_NO_FLAGS : MUTT_ADD_FROM);\n  if (!msg)\n    return -1;\n  if ((dest->type == MUTT_MBOX) || (dest->type == MUTT_MMDF))\n    chflags |= CH_FROM | CH_FORCE_FROM;\n  chflags |= ((dest->type == MUTT_MAILDIR) ? CH_NOSTATUS : CH_UPDATE);\n  rc = mutt_copy_message_fp(msg->fp, fp_in, e, cmflags, chflags, 0);\n  if (mx_msg_commit(dest, msg) != 0)\n    rc = -1;\n\n#ifdef USE_NOTMUCH\n  if (msg->committed_path && (dest->type == MUTT_MAILDIR) && (src->type == MUTT_NOTMUCH))\n    nm_update_filename(src, NULL, msg->committed_path, e);\n#endif\n\n  mx_msg_close(dest, &msg);\n  return rc;\n}\n\n/**\n * mutt_append_message - Append a message\n * @param m_dst   Destination Mailbox\n * @param m_src   Source Mailbox\n * @param e       Email\n * @param msg     Message\n * @param cmflags Flags, see #CopyMessageFlags\n * @param chflags Flags, see #CopyHeaderFlags\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mutt_append_message(struct Mailbox *m_dst, struct Mailbox *m_src,\n                        struct Email *e, struct Message *msg,\n                        CopyMessageFlags cmflags, CopyHeaderFlags chflags)\n{\n  if (!e)\n    return -1;\n\n  const bool own_msg = !msg;\n  if (own_msg && !(msg = mx_msg_open(m_src, e)))\n  {\n    return -1;\n  }\n\n  int rc = append_message(m_dst, msg->fp, m_src, e, cmflags, chflags);\n  if (own_msg)\n  {\n    mx_msg_close(m_src, &msg);\n  }\n  return rc;\n}\n\n/**\n * copy_delete_attach - Copy a message, deleting marked attachments\n * @param b           Email Body\n * @param fp_in       FILE pointer to read from\n * @param fp_out      FILE pointer to write to\n * @param quoted_date Date stamp\n * @retval  0 Success\n * @retval -1 Failure\n *\n * This function copies a message body, while deleting _in_the_copy_\n * any attachments which are marked for deletion.\n * Nothing is changed in the original message -- this is left to the caller.\n */\nstatic int copy_delete_attach(struct Body *b, FILE *fp_in, FILE *fp_out, const char *quoted_date)\n{\n  struct Body *part = NULL;\n\n  for (part = b->parts; part; part = part->next)\n  {\n    if (part->deleted || part->parts)\n    {\n      /* Copy till start of this part */\n      if (mutt_file_copy_bytes(fp_in, fp_out, part->hdr_offset - ftello(fp_in)))\n      {\n        return -1;\n      }\n\n      if (part->deleted)\n      {\n        /* If this is modified, count_delete_lines() needs to be changed too */\n        fprintf(fp_out,\n                \"Content-Type: message/external-body; access-type=x-mutt-deleted;\\n\"\n                \"\\texpiration=%s; length=\" OFF_T_FMT \"\\n\"\n                \"\\n\",\n                quoted_date, part->length);\n        if (ferror(fp_out))\n        {\n          return -1;\n        }\n\n        /* Copy the original mime headers */\n        if (mutt_file_copy_bytes(fp_in, fp_out, part->offset - ftello(fp_in)))\n        {\n          return -1;\n        }\n\n        /* Skip the deleted body */\n        if (!mutt_file_seek(fp_in, part->offset + part->length, SEEK_SET))\n        {\n          return -1;\n        }\n      }\n      else\n      {\n        if (copy_delete_attach(part, fp_in, fp_out, quoted_date))\n        {\n          return -1;\n        }\n      }\n    }\n  }\n\n  /* Copy the last parts */\n  if (mutt_file_copy_bytes(fp_in, fp_out, b->offset + b->length - ftello(fp_in)))\n    return -1;\n\n  return 0;\n}\n\n/**\n * address_header_decode - Parse an email's headers\n * @param[out] h Array of header strings\n * @retval 0 Success\n * @retval 1 Failure\n */\nstatic int address_header_decode(char **h)\n{\n  char *s = *h;\n  size_t l;\n  bool rp = false;\n\n  switch (tolower((unsigned char) *s))\n  {\n    case 'b':\n    {\n      if (!(l = mutt_istr_startswith(s, \"bcc:\")))\n        return 0;\n      break;\n    }\n    case 'c':\n    {\n      if (!(l = mutt_istr_startswith(s, \"cc:\")))\n        return 0;\n      break;\n    }\n    case 'f':\n    {\n      if (!(l = mutt_istr_startswith(s, \"from:\")))\n        return 0;\n      break;\n    }\n    case 'm':\n    {\n      if (!(l = mutt_istr_startswith(s, \"mail-followup-to:\")))\n        return 0;\n      break;\n    }\n    case 'r':\n    {\n      if ((l = mutt_istr_startswith(s, \"return-path:\")))\n      {\n        rp = true;\n        break;\n      }\n      else if ((l = mutt_istr_startswith(s, \"reply-to:\")))\n      {\n        break;\n      }\n      return 0;\n    }\n    case 's':\n    {\n      if (!(l = mutt_istr_startswith(s, \"sender:\")))\n        return 0;\n      break;\n    }\n    case 't':\n    {\n      if (!(l = mutt_istr_startswith(s, \"to:\")))\n        return 0;\n      break;\n    }\n    default:\n      return 0;\n  }\n\n  struct AddressList al = TAILQ_HEAD_INITIALIZER(al);\n  mutt_addrlist_parse(&al, s + l);\n  if (TAILQ_EMPTY(&al))\n    return 0;\n\n  mutt_addrlist_to_local(&al);\n  rfc2047_decode_addrlist(&al);\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, &al, entries)\n  {\n    if (a->personal)\n    {\n      buf_dequote_comment(a->personal);\n    }\n  }\n\n  /* angle brackets for return path are mandated by RFC5322,\n   * so leave Return-Path as-is */\n  if (rp)\n  {\n    *h = mutt_str_dup(s);\n  }\n  else\n  {\n    struct Buffer buf = { 0 };\n    (*h)[l - 1] = '\\0';\n    mutt_addrlist_write_wrap(&al, &buf, *h);\n    buf_addch(&buf, '\\n');\n    *h = buf.data;\n  }\n\n  mutt_addrlist_clear(&al);\n\n  FREE(&s);\n  return 1;\n}\n"
        },
        {
          "name": "copy.h",
          "type": "blob",
          "size": 4.626953125,
          "content": "/**\n * @file\n * Duplicate the structure of an entire email\n *\n * @authors\n * Copyright (C) 1996-2000 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2018-2021 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2021 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_COPY_H\n#define MUTT_COPY_H\n\n#include \"config.h\"\n#include <stdint.h>\n#include <stdio.h>\n\nstruct Email;\nstruct Mailbox;\nstruct Message;\n\ntypedef uint16_t CopyMessageFlags;     ///< Flags for mutt_copy_message(), e.g. #MUTT_CM_NOHEADER\n#define MUTT_CM_NO_FLAGS           0   ///< No flags are set\n#define MUTT_CM_NOHEADER     (1 << 0)  ///< Don't copy the message header\n#define MUTT_CM_PREFIX       (1 << 1)  ///< Quote the header and body\n#define MUTT_CM_DECODE       (1 << 2)  ///< Decode the message body into text/plain\n#define MUTT_CM_DISPLAY      (1 << 3)  ///< Output is displayed to the user\n#define MUTT_CM_UPDATE       (1 << 4)  ///< Update structs on sync\n#define MUTT_CM_WEED         (1 << 5)  ///< Weed message/rfc822 attachment headers\n#define MUTT_CM_CHARCONV     (1 << 6)  ///< Perform character set conversions\n#define MUTT_CM_PRINTING     (1 << 7)  ///< Printing the message - display light\n#define MUTT_CM_REPLYING     (1 << 8)  ///< Replying the message\n#define MUTT_CM_DECODE_PGP   (1 << 9)  ///< Used for decoding PGP messages\n#define MUTT_CM_DECODE_SMIME (1 << 10) ///< Used for decoding S/MIME messages\n#define MUTT_CM_VERIFY       (1 << 11) ///< Do signature verification\n#define MUTT_CM_DECODE_CRYPT (MUTT_CM_DECODE_PGP | MUTT_CM_DECODE_SMIME)\n\ntypedef uint32_t CopyHeaderFlags;   ///< Flags for mutt_copy_header(), e.g. #CH_UPDATE\n#define CH_NO_FLAGS             0   ///< No flags are set\n#define CH_UPDATE         (1 << 0)  ///< Update the status and x-status fields?\n#define CH_WEED           (1 << 1)  ///< Weed the headers?\n#define CH_DECODE         (1 << 2)  ///< Do RFC2047 header decoding\n#define CH_XMIT           (1 << 3)  ///< Transmitting this message? (Ignore Lines: and Content-Length:)\n#define CH_FROM           (1 << 4)  ///< Retain the \"From \" message separator?\n#define CH_PREFIX         (1 << 5)  ///< Quote header using `$indent_string` string?\n#define CH_NOSTATUS       (1 << 6)  ///< Suppress the status and x-status fields\n#define CH_REORDER        (1 << 7)  ///< Re-order output of headers (specified by 'hdr_order')\n#define CH_NONEWLINE      (1 << 8)  ///< Don't output terminating newline after the header\n#define CH_MIME           (1 << 9)  ///< Ignore MIME fields\n#define CH_UPDATE_LEN     (1 << 10) ///< Update Lines: and Content-Length:\n#define CH_TXTPLAIN       (1 << 11) ///< Generate text/plain MIME headers\n#define CH_NOLEN          (1 << 12) ///< Don't write Content-Length: and Lines:\n#define CH_WEED_DELIVERED (1 << 13) ///< Weed eventual Delivered-To headers\n#define CH_FORCE_FROM     (1 << 14) ///< Give CH_FROM precedence over CH_WEED?\n#define CH_NOQFROM        (1 << 15) ///< Ignore \">From \" line\n#define CH_UPDATE_IRT     (1 << 16) ///< Update In-Reply-To:\n#define CH_UPDATE_REFS    (1 << 17) ///< Update References:\n#define CH_DISPLAY        (1 << 18) ///< Display result to user\n#define CH_UPDATE_LABEL   (1 << 19) ///< Update X-Label: from email->env->x_label?\n#define CH_UPDATE_SUBJECT (1 << 20) ///< Update Subject: protected header update\n#define CH_VIRTUAL        (1 << 21) ///< Write virtual header lines too\n\nint mutt_copy_hdr(FILE *fp_in, FILE *fp_out, LOFF_T off_start, LOFF_T off_end, CopyHeaderFlags chflags, const char *prefix, int wraplen);\n\nint mutt_copy_header(FILE *fp_in, struct Email *e, FILE *fp_out, CopyHeaderFlags chflags, const char *prefix, int wraplen);\n\nint mutt_copy_message_fp(FILE *fp_out, FILE *fp_in, struct Email *e, CopyMessageFlags cmflags, CopyHeaderFlags chflags, int wraplen);\nint mutt_copy_message   (FILE *fp_out, struct Email *e, struct Message *msg, CopyMessageFlags cmflags, CopyHeaderFlags chflags, int wraplen);\n\nint mutt_append_message(struct Mailbox *m_dst, struct Mailbox *m_src, struct Email *e, struct Message *msg, CopyMessageFlags cmflags, CopyHeaderFlags chflags);\n\n#endif /* MUTT_COPY_H */\n"
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "editmsg.c",
          "type": "blob",
          "size": 7.7158203125,
          "content": "/**\n * @file\n * Prepare an email to be edited\n *\n * @authors\n * Copyright (C) 1999-2002 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2017 Reis Radomil\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2019-2022 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_editmsg Prepare an email to be edited\n *\n * Prepare an email to be edited\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"copy.h\"\n#include \"mx.h\"\n#include \"protos.h\"\n\n/**\n * ev_message - Edit an email or view it in an external editor\n * @param action Action to perform, e.g. #EVM_EDIT\n * @param m      Mailbox\n * @param e      Email\n * @retval  1 Message not modified\n * @retval  0 Message edited successfully\n * @retval -1 Error\n */\nstatic int ev_message(enum EvMessage action, struct Mailbox *m, struct Email *e)\n{\n  char buf[256] = { 0 };\n  int rc;\n  FILE *fp = NULL;\n  struct stat st = { 0 };\n  bool old_append = m->append;\n\n  struct Buffer *fname = buf_pool_get();\n  buf_mktemp(fname);\n\n  // Temporarily force $mbox_type to be MUTT_MBOX\n  const unsigned char c_mbox_type = cs_subset_enum(NeoMutt->sub, \"mbox_type\");\n  cs_subset_str_native_set(NeoMutt->sub, \"mbox_type\", MUTT_MBOX, NULL);\n\n  struct Mailbox *m_fname = mx_path_resolve(buf_string(fname));\n  if (!mx_mbox_open(m_fname, MUTT_NEWFOLDER))\n  {\n    mutt_error(_(\"could not create temporary folder: %s\"), strerror(errno));\n    buf_pool_release(&fname);\n    mailbox_free(&m_fname);\n    return -1;\n  }\n\n  cs_subset_str_native_set(NeoMutt->sub, \"mbox_type\", c_mbox_type, NULL);\n\n  const CopyHeaderFlags chflags = CH_NOLEN |\n                                  (((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF)) ?\n                                       CH_NO_FLAGS :\n                                       CH_NOSTATUS);\n  rc = mutt_append_message(m_fname, m, e, NULL, MUTT_CM_NO_FLAGS, chflags);\n  int oerrno = errno;\n\n  mx_mbox_close(m_fname);\n  mailbox_free(&m_fname);\n\n  if (rc == -1)\n  {\n    mutt_error(_(\"could not write temporary mail folder: %s\"), strerror(oerrno));\n    goto bail;\n  }\n\n  rc = stat(buf_string(fname), &st);\n  if (rc == -1)\n  {\n    mutt_error(_(\"Can't stat %s: %s\"), buf_string(fname), strerror(errno));\n    goto bail;\n  }\n\n  /* The file the user is going to edit is not a real mbox, so we need to\n   * truncate the last newline in the temp file, which is logically part of\n   * the message separator, and not the body of the message.  If we fail to\n   * remove it, the message will grow by one line each time the user edits\n   * the message.  */\n  if ((st.st_size != 0) && (truncate(buf_string(fname), st.st_size - 1) == -1))\n  {\n    rc = -1;\n    mutt_error(_(\"could not truncate temporary mail folder: %s\"), strerror(errno));\n    goto bail;\n  }\n\n  if (action == EVM_VIEW)\n  {\n    /* remove write permissions */\n    rc = mutt_file_chmod_rm_stat(buf_string(fname), S_IWUSR | S_IWGRP | S_IWOTH, &st);\n    if (rc == -1)\n    {\n      mutt_debug(LL_DEBUG1, \"Could not remove write permissions of %s: %s\",\n                 buf_string(fname), strerror(errno));\n      /* Do not bail out here as we are checking afterwards if we should adopt\n       * changes of the temporary file. */\n    }\n  }\n\n  /* re-stat after the truncate, to avoid false \"modified\" bugs */\n  rc = stat(buf_string(fname), &st);\n  if (rc == -1)\n  {\n    mutt_error(_(\"Can't stat %s: %s\"), buf_string(fname), strerror(errno));\n    goto bail;\n  }\n\n  /* Do not reuse the stat st here as it is outdated. */\n  time_t mtime = mutt_file_decrease_mtime(buf_string(fname), NULL);\n  if (mtime == (time_t) -1)\n  {\n    rc = -1;\n    mutt_perror(\"%s\", buf_string(fname));\n    goto bail;\n  }\n\n  const char *const c_editor = cs_subset_string(NeoMutt->sub, \"editor\");\n  mutt_edit_file(NONULL(c_editor), buf_string(fname));\n\n  rc = stat(buf_string(fname), &st);\n  if (rc == -1)\n  {\n    mutt_error(_(\"Can't stat %s: %s\"), buf_string(fname), strerror(errno));\n    goto bail;\n  }\n\n  if (st.st_size == 0)\n  {\n    mutt_message(_(\"Message file is empty\"));\n    rc = 1;\n    goto bail;\n  }\n\n  if ((action == EVM_EDIT) && (st.st_mtime == mtime))\n  {\n    mutt_message(_(\"Message not modified\"));\n    rc = 1;\n    goto bail;\n  }\n\n  if ((action == EVM_VIEW) && (st.st_mtime != mtime))\n  {\n    mutt_message(_(\"Message of read-only mailbox modified! Ignoring changes.\"));\n    rc = 1;\n    goto bail;\n  }\n\n  if (action == EVM_VIEW)\n  {\n    /* stop processing here and skip right to the end */\n    rc = 1;\n    goto bail;\n  }\n\n  fp = mutt_file_fopen(buf_string(fname), \"r\");\n  if (!fp)\n  {\n    rc = -1;\n    mutt_error(_(\"Can't open message file: %s\"), strerror(errno));\n    goto bail;\n  }\n\n  if (!mx_mbox_open(m, MUTT_APPEND | MUTT_QUIET))\n  {\n    rc = -1;\n    /* L10N: %s is from strerror(errno) */\n    mutt_error(_(\"Can't append to folder: %s\"), strerror(errno));\n    goto bail;\n  }\n  MsgOpenFlags of = MUTT_MSG_NO_FLAGS;\n  CopyHeaderFlags cf = (((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF)) ? CH_NO_FLAGS : CH_NOSTATUS);\n\n  if (fgets(buf, sizeof(buf), fp) && is_from(buf, NULL, 0, NULL))\n  {\n    if ((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF))\n      cf = CH_FROM | CH_FORCE_FROM;\n  }\n  else\n  {\n    of = MUTT_ADD_FROM;\n  }\n\n  /* XXX - we have to play games with the message flags to avoid\n   * problematic behavior with maildir folders.  */\n\n  bool o_read = e->read;\n  bool o_old = e->old;\n  e->read = false;\n  e->old = false;\n  struct Message *msg = mx_msg_open_new(m, e, of);\n  e->read = o_read;\n  e->old = o_old;\n\n  if (!msg)\n  {\n    rc = -1;\n    mutt_error(_(\"Can't append to folder: %s\"), strerror(errno));\n    mx_mbox_close(m);\n    goto bail;\n  }\n\n  rc = mutt_copy_hdr(fp, msg->fp, 0, st.st_size, CH_NOLEN | cf, NULL, 0);\n  if (rc == 0)\n  {\n    fputc('\\n', msg->fp);\n    mutt_file_copy_stream(fp, msg->fp);\n  }\n\n  rc = mx_msg_commit(m, msg);\n  mx_msg_close(m, &msg);\n\n  mx_mbox_close(m);\n  m->last_checked = 0; // force a check on the next mx_mbox_check() call\n\nbail:\n  mutt_file_fclose(&fp);\n\n  if (rc >= 0)\n    unlink(buf_string(fname));\n\n  if (rc == 0)\n  {\n    mutt_set_flag(m, e, MUTT_DELETE, true, true);\n    mutt_set_flag(m, e, MUTT_PURGE, true, true);\n    mutt_set_flag(m, e, MUTT_READ, true, true);\n\n    const bool c_delete_untag = cs_subset_bool(NeoMutt->sub, \"delete_untag\");\n    if (c_delete_untag)\n      mutt_set_flag(m, e, MUTT_TAG, false, true);\n  }\n  else if (rc == -1)\n  {\n    mutt_message(_(\"Error. Preserving temporary file: %s\"), buf_string(fname));\n  }\n\n  m->append = old_append;\n\n  buf_pool_release(&fname);\n  return rc;\n}\n\n/**\n * mutt_ev_message - Edit or view a message\n * @param m      Mailbox\n * @param ea     Array of Emails\n * @param action Action to perform, e.g. #EVM_EDIT\n * @retval 1  Message not modified\n * @retval 0  Message edited successfully\n * @retval -1 Error\n */\nint mutt_ev_message(struct Mailbox *m, struct EmailArray *ea, enum EvMessage action)\n{\n  struct Email **ep = NULL;\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    if (ev_message(action, m, e) == -1)\n      return -1;\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "editor",
          "type": "tree",
          "content": null
        },
        {
          "name": "email",
          "type": "tree",
          "content": null
        },
        {
          "name": "enriched.c",
          "type": "blob",
          "size": 14.9736328125,
          "content": "/**\n * @file\n * Rich text handler\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_enriched Rich text handler\n *\n * Rich text handler\n */\n\n/**\n * A (not so) minimal implementation of RFC1563.\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"enriched.h\"\n\n#define INDENT_SIZE 4\n\n/**\n * enum RichAttribs - Rich text attributes\n */\nenum RichAttribs\n{\n  RICH_PARAM = 0,    ///< Parameter label\n  RICH_BOLD,         ///< Bold text\n  RICH_UNDERLINE,    ///< Underlined text\n  RICH_ITALIC,       ///< Italic text\n  RICH_NOFILL,       ///< Text will not be reformatted\n  RICH_INDENT,       ///< Indented text\n  RICH_INDENT_RIGHT, ///< Right-indented text\n  RICH_EXCERPT,      ///< Excerpt text\n  RICH_CENTER,       ///< Centred text\n  RICH_FLUSHLEFT,    ///< Left-justified text\n  RICH_FLUSHRIGHT,   ///< Right-justified text\n  RICH_COLOR,        ///< Coloured text\n  RICH_MAX,\n};\n\n/**\n * struct Etags - Enriched text tags\n */\nstruct Etags\n{\n  const wchar_t *tag_name; ///< Tag name\n  int index;               ///< Index number\n};\n\n/// EnrichedTags - Lookup table of tags allowed in enriched text\nstatic const struct Etags EnrichedTags[] = {\n  // clang-format off\n  { L\"param\",       RICH_PARAM        },\n  { L\"bold\",        RICH_BOLD         },\n  { L\"italic\",      RICH_ITALIC       },\n  { L\"underline\",   RICH_UNDERLINE    },\n  { L\"nofill\",      RICH_NOFILL       },\n  { L\"excerpt\",     RICH_EXCERPT      },\n  { L\"indent\",      RICH_INDENT       },\n  { L\"indentright\", RICH_INDENT_RIGHT },\n  { L\"center\",      RICH_CENTER       },\n  { L\"flushleft\",   RICH_FLUSHLEFT    },\n  { L\"flushright\",  RICH_FLUSHRIGHT   },\n  { L\"flushboth\",   RICH_FLUSHLEFT    },\n  { L\"color\",       RICH_COLOR        },\n  { L\"x-color\",     RICH_COLOR        },\n  { NULL, -1 },\n  // clang-format on\n};\n\n/**\n * struct EnrichedState - State of enriched-text parser\n */\nstruct EnrichedState\n{\n  wchar_t *buffer;\n  wchar_t *line;\n  wchar_t *param;\n  size_t buf_len;\n  size_t line_len;\n  size_t line_used;\n  size_t line_max;\n  size_t indent_len;\n  size_t word_len;\n  size_t buf_used;\n  size_t param_used;\n  size_t param_len;\n  int tag_level[RICH_MAX];\n  int wrap_margin;\n  struct State *state;\n};\n\n/**\n * enriched_wrap - Wrap enriched text\n * @param enriched State of enriched text\n */\nstatic void enriched_wrap(struct EnrichedState *enriched)\n{\n  if (!enriched)\n    return;\n\n  int x;\n\n  if (enriched->line_len)\n  {\n    if (enriched->tag_level[RICH_CENTER] || enriched->tag_level[RICH_FLUSHRIGHT])\n    {\n      /* Strip trailing white space */\n      size_t y = enriched->line_used - 1;\n\n      while (y && iswspace(enriched->line[y]))\n      {\n        enriched->line[y] = (wchar_t) '\\0';\n        y--;\n        enriched->line_used--;\n        enriched->line_len--;\n      }\n      if (enriched->tag_level[RICH_CENTER])\n      {\n        /* Strip leading whitespace */\n        y = 0;\n\n        while (enriched->line[y] && iswspace(enriched->line[y]))\n          y++;\n        if (y)\n        {\n          for (size_t z = y; z <= enriched->line_used; z++)\n          {\n            enriched->line[z - y] = enriched->line[z];\n          }\n\n          enriched->line_len -= y;\n          enriched->line_used -= y;\n        }\n      }\n    }\n\n    const int extra = enriched->wrap_margin - enriched->line_len - enriched->indent_len -\n                      (enriched->tag_level[RICH_INDENT_RIGHT] * INDENT_SIZE);\n    if (extra > 0)\n    {\n      if (enriched->tag_level[RICH_CENTER])\n      {\n        x = extra / 2;\n        while (x)\n        {\n          state_putc(enriched->state, ' ');\n          x--;\n        }\n      }\n      else if (enriched->tag_level[RICH_FLUSHRIGHT])\n      {\n        x = extra - 1;\n        while (x)\n        {\n          state_putc(enriched->state, ' ');\n          x--;\n        }\n      }\n    }\n    state_putws(enriched->state, (const wchar_t *) enriched->line);\n  }\n\n  state_putc(enriched->state, '\\n');\n  enriched->line[0] = (wchar_t) '\\0';\n  enriched->line_len = 0;\n  enriched->line_used = 0;\n  enriched->indent_len = 0;\n  if (enriched->state->prefix)\n  {\n    state_puts(enriched->state, enriched->state->prefix);\n    enriched->indent_len += mutt_str_len(enriched->state->prefix);\n  }\n\n  if (enriched->tag_level[RICH_EXCERPT])\n  {\n    x = enriched->tag_level[RICH_EXCERPT];\n    while (x)\n    {\n      if (enriched->state->prefix)\n      {\n        state_puts(enriched->state, enriched->state->prefix);\n        enriched->indent_len += mutt_str_len(enriched->state->prefix);\n      }\n      else\n      {\n        state_puts(enriched->state, \"> \");\n        enriched->indent_len += mutt_str_len(\"> \");\n      }\n      x--;\n    }\n  }\n  else\n  {\n    enriched->indent_len = 0;\n  }\n  if (enriched->tag_level[RICH_INDENT])\n  {\n    x = enriched->tag_level[RICH_INDENT] * INDENT_SIZE;\n    enriched->indent_len += x;\n    while (x)\n    {\n      state_putc(enriched->state, ' ');\n      x--;\n    }\n  }\n}\n\n/**\n * enriched_flush - Write enriched text to the State\n * @param enriched State of Enriched text\n * @param wrap     true if the text should be wrapped\n */\nstatic void enriched_flush(struct EnrichedState *enriched, bool wrap)\n{\n  if (!enriched || !enriched->buffer)\n    return;\n\n  if (!enriched->tag_level[RICH_NOFILL] &&\n      ((enriched->line_len + enriched->word_len) >\n       (enriched->wrap_margin - (enriched->tag_level[RICH_INDENT_RIGHT] * INDENT_SIZE) -\n        enriched->indent_len)))\n  {\n    enriched_wrap(enriched);\n  }\n\n  if (enriched->buf_used)\n  {\n    enriched->buffer[enriched->buf_used] = (wchar_t) '\\0';\n    enriched->line_used += enriched->buf_used;\n    if (enriched->line_used > enriched->line_max)\n    {\n      enriched->line_max = enriched->line_used;\n      MUTT_MEM_REALLOC(&enriched->line, enriched->line_max + 1, wchar_t);\n    }\n    wcscat(enriched->line, enriched->buffer);\n    enriched->line_len += enriched->word_len;\n    enriched->word_len = 0;\n    enriched->buf_used = 0;\n  }\n  if (wrap)\n    enriched_wrap(enriched);\n  fflush(enriched->state->fp_out);\n}\n\n/**\n * enriched_putwc - Write one wide character to the state\n * @param c    Character to write\n * @param enriched State of Enriched text\n */\nstatic void enriched_putwc(wchar_t c, struct EnrichedState *enriched)\n{\n  if (!enriched)\n    return;\n\n  if (enriched->tag_level[RICH_PARAM])\n  {\n    if (enriched->tag_level[RICH_COLOR])\n    {\n      if ((enriched->param_used + 1) >= enriched->param_len)\n      {\n        enriched->param_len += 256;\n        MUTT_MEM_REALLOC(&enriched->param, enriched->param_len, wchar_t);\n      }\n\n      enriched->param[enriched->param_used++] = c;\n    }\n    return; /* nothing to do */\n  }\n\n  /* see if more space is needed (plus extra for possible rich characters) */\n  if ((enriched->buf_len < (enriched->buf_used + 3)) || !enriched->buffer)\n  {\n    enriched->buf_len += 1024;\n    MUTT_MEM_REALLOC(&enriched->buffer, enriched->buf_len + 1, wchar_t);\n  }\n\n  if ((!enriched->tag_level[RICH_NOFILL] && iswspace(c)) || (c == (wchar_t) '\\0'))\n  {\n    if (c == (wchar_t) '\\t')\n      enriched->word_len += 8 - (enriched->line_len + enriched->word_len) % 8;\n    else\n      enriched->word_len++;\n\n    enriched->buffer[enriched->buf_used++] = c;\n    enriched_flush(enriched, false);\n  }\n  else\n  {\n    if (enriched->state->flags & STATE_DISPLAY)\n    {\n      if (enriched->tag_level[RICH_BOLD])\n      {\n        enriched->buffer[enriched->buf_used++] = c;\n        enriched->buffer[enriched->buf_used++] = (wchar_t) '\\010'; // Ctrl-H (backspace)\n        enriched->buffer[enriched->buf_used++] = c;\n      }\n      else if (enriched->tag_level[RICH_UNDERLINE])\n      {\n        enriched->buffer[enriched->buf_used++] = '_';\n        enriched->buffer[enriched->buf_used++] = (wchar_t) '\\010'; // Ctrl-H (backspace)\n        enriched->buffer[enriched->buf_used++] = c;\n      }\n      else if (enriched->tag_level[RICH_ITALIC])\n      {\n        enriched->buffer[enriched->buf_used++] = c;\n        enriched->buffer[enriched->buf_used++] = (wchar_t) '\\010'; // Ctrl-H (backspace)\n        enriched->buffer[enriched->buf_used++] = '_';\n      }\n      else\n      {\n        enriched->buffer[enriched->buf_used++] = c;\n      }\n    }\n    else\n    {\n      enriched->buffer[enriched->buf_used++] = c;\n    }\n    enriched->word_len++;\n  }\n}\n\n/**\n * enriched_puts - Write an enriched text string to the State\n * @param s        String to write\n * @param enriched State of Enriched text\n */\nstatic void enriched_puts(const char *s, struct EnrichedState *enriched)\n{\n  if (!enriched)\n    return;\n\n  const char *c = NULL;\n\n  if ((enriched->buf_len < (enriched->buf_used + mutt_str_len(s))) || !enriched->buffer)\n  {\n    enriched->buf_len += 1024;\n    MUTT_MEM_REALLOC(&enriched->buffer, enriched->buf_len + 1, wchar_t);\n  }\n  c = s;\n  while (*c)\n  {\n    enriched->buffer[enriched->buf_used++] = (wchar_t) *c;\n    c++;\n  }\n}\n\n/**\n * enriched_set_flags - Set flags on the enriched text state\n * @param tag      Tag to set\n * @param enriched State of Enriched text\n */\nstatic void enriched_set_flags(const wchar_t *tag, struct EnrichedState *enriched)\n{\n  if (!enriched)\n    return;\n\n  const wchar_t *tagptr = tag;\n  int i, j;\n\n  if (*tagptr == (wchar_t) '/')\n    tagptr++;\n\n  for (i = 0, j = -1; EnrichedTags[i].tag_name; i++)\n  {\n    if (wcscasecmp(EnrichedTags[i].tag_name, tagptr) == 0)\n    {\n      j = EnrichedTags[i].index;\n      break;\n    }\n  }\n\n  if (j != -1)\n  {\n    if ((j == RICH_CENTER) || (j == RICH_FLUSHLEFT) || (j == RICH_FLUSHRIGHT))\n      enriched_flush(enriched, true);\n\n    if (*tag == (wchar_t) '/')\n    {\n      if (enriched->tag_level[j]) /* make sure not to go negative */\n        enriched->tag_level[j]--;\n      if ((enriched->state->flags & STATE_DISPLAY) && (j == RICH_PARAM) &&\n          enriched->tag_level[RICH_COLOR])\n      {\n        enriched->param[enriched->param_used] = (wchar_t) '\\0';\n        if (wcscasecmp(L\"black\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[30m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"red\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[31m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"green\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[32m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"yellow\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[33m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"blue\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[34m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"magenta\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[35m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"cyan\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[36m\", enriched); // Escape\n        }\n        else if (wcscasecmp(L\"white\", enriched->param) == 0)\n        {\n          enriched_puts(\"\\033[37m\", enriched); // Escape\n        }\n      }\n      if ((enriched->state->flags & STATE_DISPLAY) && (j == RICH_COLOR))\n      {\n        enriched_puts(\"\\033[0m\", enriched); // Escape\n      }\n\n      /* flush parameter buffer when closing the tag */\n      if (j == RICH_PARAM)\n      {\n        enriched->param_used = 0;\n        enriched->param[0] = (wchar_t) '\\0';\n      }\n    }\n    else\n    {\n      enriched->tag_level[j]++;\n    }\n\n    if (j == RICH_EXCERPT)\n      enriched_flush(enriched, true);\n  }\n}\n\n/**\n * text_enriched_handler - Handler for enriched text - Implements ::handler_t - @ingroup handler_api\n * @retval 0 Always\n */\nint text_enriched_handler(struct Body *b_email, struct State *state)\n{\n  enum\n  {\n    TEXT,\n    LANGLE,\n    TAG,\n    BOGUS_TAG,\n    NEWLINE,\n    ST_EOF,\n    DONE\n  } text_state = TEXT;\n\n  long bytes = b_email->length;\n  struct EnrichedState enriched = { 0 };\n  wint_t wc = 0;\n  int tag_len = 0;\n  wchar_t tag[1024 + 1];\n\n  enriched.state = state;\n  enriched.wrap_margin = ((state->wraplen > 4) &&\n                          ((state->flags & STATE_DISPLAY) || (state->wraplen < 76))) ?\n                             state->wraplen - 4 :\n                             72;\n  enriched.line_max = enriched.wrap_margin * 4;\n  enriched.line = MUTT_MEM_CALLOC(enriched.line_max + 1, wchar_t);\n  enriched.param = MUTT_MEM_CALLOC(256, wchar_t);\n\n  enriched.param_len = 256;\n  enriched.param_used = 0;\n\n  if (state->prefix)\n  {\n    state_puts(state, state->prefix);\n    enriched.indent_len += mutt_str_len(state->prefix);\n  }\n\n  while (text_state != DONE)\n  {\n    if (text_state != ST_EOF)\n    {\n      if (!bytes || ((wc = fgetwc(state->fp_in)) == WEOF))\n        text_state = ST_EOF;\n      else\n        bytes--;\n    }\n\n    switch (text_state)\n    {\n      case TEXT:\n        switch (wc)\n        {\n          case '<':\n            text_state = LANGLE;\n            break;\n\n          case '\\n':\n            if (enriched.tag_level[RICH_NOFILL])\n            {\n              enriched_flush(&enriched, true);\n            }\n            else\n            {\n              enriched_putwc((wchar_t) ' ', &enriched);\n              text_state = NEWLINE;\n            }\n            break;\n\n          default:\n            enriched_putwc(wc, &enriched);\n        }\n        break;\n\n      case LANGLE:\n        if (wc == (wchar_t) '<')\n        {\n          enriched_putwc(wc, &enriched);\n          text_state = TEXT;\n          break;\n        }\n        else\n        {\n          tag_len = 0;\n          text_state = TAG;\n        }\n        /* Yes, (it wasn't a <<, so this char is first in TAG) */\n        FALLTHROUGH;\n\n      case TAG:\n        if (wc == (wchar_t) '>')\n        {\n          tag[tag_len] = (wchar_t) '\\0';\n          enriched_set_flags(tag, &enriched);\n          text_state = TEXT;\n        }\n        else if (tag_len < 1024) /* ignore overly long tags */\n        {\n          tag[tag_len++] = wc;\n        }\n        else\n        {\n          text_state = BOGUS_TAG;\n        }\n        break;\n\n      case BOGUS_TAG:\n        if (wc == (wchar_t) '>')\n          text_state = TEXT;\n        break;\n\n      case NEWLINE:\n        if (wc == (wchar_t) '\\n')\n        {\n          enriched_flush(&enriched, true);\n        }\n        else\n        {\n          ungetwc(wc, state->fp_in);\n          bytes++;\n          text_state = TEXT;\n        }\n        break;\n\n      case ST_EOF:\n        enriched_putwc((wchar_t) '\\0', &enriched);\n        enriched_flush(&enriched, true);\n        text_state = DONE;\n        break;\n\n      default:\n        /* not reached */\n        break;\n    }\n  }\n\n  state_putc(state, '\\n'); /* add a final newline */\n\n  FREE(&(enriched.buffer));\n  FREE(&(enriched.line));\n  FREE(&(enriched.param));\n\n  return 0;\n}\n"
        },
        {
          "name": "enriched.h",
          "type": "blob",
          "size": 0.9326171875,
          "content": "/**\n * @file\n * Rich text handler\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_ENRICHED_H\n#define MUTT_ENRICHED_H\n\nstruct Body;\nstruct State;\n\nint text_enriched_handler(struct Body *b_email, struct State *state);\n\n#endif /* MUTT_ENRICHED_H */\n"
        },
        {
          "name": "envelope",
          "type": "tree",
          "content": null
        },
        {
          "name": "expando",
          "type": "tree",
          "content": null
        },
        {
          "name": "external.c",
          "type": "blob",
          "size": 32.6083984375,
          "content": "/**\n * @file\n * Manage where the email is piped to external commands\n *\n * @authors\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018-2023 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2021 Eric Blake <eblake@redhat.com>\n * Copyright (C) 2021 Ihor Antonov <ihor@antonovs.family>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_external Manage where the email is piped to external commands\n *\n * Manage where the email is piped to external commands\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"external.h\"\n#include \"attach/lib.h\"\n#include \"browser/lib.h\"\n#include \"complete/lib.h\"\n#include \"editor/lib.h\"\n#include \"history/lib.h\"\n#include \"imap/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"parse/lib.h\"\n#include \"progress/lib.h\"\n#include \"question/lib.h\"\n#include \"send/lib.h\"\n#include \"copy.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_mailbox.h\"\n#include \"mutt_thread.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"protos.h\"\n#ifdef USE_NOTMUCH\n#include \"notmuch/lib.h\"\n#endif\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\n/// The folder the user last saved to.  Used by ci_save_message()\nstatic struct Buffer LastSaveFolder = { 0 };\n\n/**\n * external_cleanup - Clean up commands globals\n */\nvoid external_cleanup(void)\n{\n  buf_dealloc(&LastSaveFolder);\n}\n\n/**\n * index_bounce_message - Bounce an email\n * @param m  Mailbox\n * @param ea Array of Emails to bounce\n */\nvoid index_bounce_message(struct Mailbox *m, struct EmailArray *ea)\n{\n  if (!m || !ea || ARRAY_EMPTY(ea))\n    return;\n\n  struct Buffer *buf = buf_pool_get();\n  struct Buffer *prompt = buf_pool_get();\n  struct AddressList al = TAILQ_HEAD_INITIALIZER(al);\n  char *err = NULL;\n  int rc;\n  int msg_count = 0;\n\n  struct Email **ep = NULL;\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    /* RFC5322 mandates a From: header,\n     * so warn before bouncing messages without one */\n    if (TAILQ_EMPTY(&e->env->from))\n      mutt_error(_(\"Warning: message contains no From: header\"));\n\n    msg_count++;\n  }\n\n  if (msg_count == 1)\n    buf_strcpy(prompt, _(\"Bounce message to: \"));\n  else\n    buf_strcpy(prompt, _(\"Bounce tagged messages to: \"));\n\n  rc = mw_get_field(buf_string(prompt), buf, MUTT_COMP_NO_FLAGS, HC_ALIAS,\n                    &CompleteAliasOps, NULL);\n  if ((rc != 0) || buf_is_empty(buf))\n    goto done;\n\n  mutt_addrlist_parse2(&al, buf_string(buf));\n  if (TAILQ_EMPTY(&al))\n  {\n    mutt_error(_(\"Error parsing address\"));\n    goto done;\n  }\n\n  mutt_expand_aliases(&al);\n\n  if (mutt_addrlist_to_intl(&al, &err) < 0)\n  {\n    mutt_error(_(\"Bad IDN: '%s'\"), err);\n    FREE(&err);\n    goto done;\n  }\n\n  buf_reset(buf);\n  mutt_addrlist_write(&al, buf, true);\n\n  buf_printf(prompt, ngettext(\"Bounce message to %s?\", \"Bounce messages to %s?\", msg_count),\n             buf_string(buf));\n\n  if (query_quadoption(buf_string(prompt), NeoMutt->sub, \"bounce\") != MUTT_YES)\n  {\n    msgwin_clear_text(NULL);\n    mutt_message(ngettext(\"Message not bounced\", \"Messages not bounced\", msg_count));\n    goto done;\n  }\n\n  msgwin_clear_text(NULL);\n\n  struct Message *msg = NULL;\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    msg = mx_msg_open(m, e);\n    if (!msg)\n    {\n      rc = -1;\n      break;\n    }\n\n    rc = mutt_bounce_message(msg->fp, m, e, &al, NeoMutt->sub);\n    mx_msg_close(m, &msg);\n\n    if (rc < 0)\n      break;\n  }\n\n  /* If no error, or background, display message. */\n  if ((rc == 0) || (rc == S_BKG))\n    mutt_message(ngettext(\"Message bounced\", \"Messages bounced\", msg_count));\n\ndone:\n  mutt_addrlist_clear(&al);\n  buf_pool_release(&buf);\n  buf_pool_release(&prompt);\n}\n\n/**\n * pipe_set_flags - Generate flags for copy header/message\n * @param[in]  decode  If true decode the message\n * @param[in]  print   If true, mark the message for printing\n * @param[out] cmflags Flags, see #CopyMessageFlags\n * @param[out] chflags Flags, see #CopyHeaderFlags\n */\nstatic void pipe_set_flags(bool decode, bool print, CopyMessageFlags *cmflags,\n                           CopyHeaderFlags *chflags)\n{\n  if (decode)\n  {\n    *chflags |= CH_DECODE | CH_REORDER;\n    *cmflags |= MUTT_CM_DECODE | MUTT_CM_CHARCONV;\n\n    const bool c_print_decode_weed = cs_subset_bool(NeoMutt->sub, \"print_decode_weed\");\n    const bool c_pipe_decode_weed = cs_subset_bool(NeoMutt->sub, \"pipe_decode_weed\");\n    if (print ? c_print_decode_weed : c_pipe_decode_weed)\n    {\n      *chflags |= CH_WEED;\n      *cmflags |= MUTT_CM_WEED;\n    }\n\n    /* Just as with copy-decode, we need to update the mime fields to avoid\n     * confusing programs that may process the email.  However, we don't want\n     * to force those fields to appear in printouts. */\n    if (!print)\n      *chflags |= CH_MIME | CH_TXTPLAIN;\n  }\n\n  if (print)\n    *cmflags |= MUTT_CM_PRINTING;\n}\n\n/**\n * pipe_msg - Pipe a message\n * @param m      Mailbox\n * @param e      Email to pipe\n * @param msg    Message\n * @param fp     File to write to\n * @param decode If true, decode the message\n * @param print  If true, message is for printing\n */\nstatic void pipe_msg(struct Mailbox *m, struct Email *e, struct Message *msg,\n                     FILE *fp, bool decode, bool print)\n{\n  CopyMessageFlags cmflags = MUTT_CM_NO_FLAGS;\n  CopyHeaderFlags chflags = CH_FROM;\n\n  pipe_set_flags(decode, print, &cmflags, &chflags);\n\n  if ((WithCrypto != 0) && decode && e->security & SEC_ENCRYPT)\n  {\n    if (!crypt_valid_passphrase(e->security))\n      return;\n    mutt_endwin();\n  }\n\n  const bool own_msg = !msg;\n  if (own_msg)\n  {\n    msg = mx_msg_open(m, e);\n    if (!msg)\n    {\n      return;\n    }\n  }\n\n  if (decode)\n  {\n    mutt_parse_mime_message(e, msg->fp);\n  }\n\n  mutt_copy_message(fp, e, msg, cmflags, chflags, 0);\n\n  if (own_msg)\n  {\n    mx_msg_close(m, &msg);\n  }\n}\n\n/**\n * pipe_message - Pipe message to a command\n * @param m      Mailbox\n * @param ea     Array of Emails to pipe\n * @param cmd    Command to pipe to\n * @param decode Should the message be decrypted\n * @param print  True if this is a print job\n * @param split  Should a separator be sent between messages?\n * @param sep    Separator string\n * @retval  0 Success\n * @retval  1 Error\n *\n * The following code is shared between printing and piping.\n */\nstatic int pipe_message(struct Mailbox *m, struct EmailArray *ea, const char *cmd,\n                        bool decode, bool print, bool split, const char *sep)\n{\n  if (!m || !ea || ARRAY_EMPTY(ea))\n    return 1;\n\n  int rc = 0;\n  pid_t pid;\n  FILE *fp_out = NULL;\n\n  if (ARRAY_SIZE(ea) == 1)\n  {\n    struct Email *e = *ARRAY_GET(ea, 0);\n    /* handle a single message */\n    mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);\n\n    struct Message *msg = mx_msg_open(m, e);\n    if (msg && (WithCrypto != 0) && decode)\n    {\n      mutt_parse_mime_message(e, msg->fp);\n      if ((e->security & SEC_ENCRYPT) && !crypt_valid_passphrase(e->security))\n      {\n        mx_msg_close(m, &msg);\n        return 1;\n      }\n    }\n    mutt_endwin();\n\n    pid = filter_create(cmd, &fp_out, NULL, NULL, EnvList);\n    if (pid < 0)\n    {\n      mutt_perror(_(\"Can't create filter process\"));\n      mx_msg_close(m, &msg);\n      return 1;\n    }\n\n    OptKeepQuiet = true;\n    pipe_msg(m, e, msg, fp_out, decode, print);\n    mx_msg_close(m, &msg);\n    mutt_file_fclose(&fp_out);\n    rc = filter_wait(pid);\n    OptKeepQuiet = false;\n  }\n  else\n  {\n    /* handle tagged messages */\n    if ((WithCrypto != 0) && decode)\n    {\n      struct Email **ep = NULL;\n      ARRAY_FOREACH(ep, ea)\n      {\n        struct Email *e = *ep;\n        struct Message *msg = mx_msg_open(m, e);\n        if (msg)\n        {\n          mutt_parse_mime_message(e, msg->fp);\n          mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);\n          mx_msg_close(m, &msg);\n        }\n        if ((e->security & SEC_ENCRYPT) && !crypt_valid_passphrase(e->security))\n        {\n          return 1;\n        }\n      }\n    }\n\n    if (split)\n    {\n      struct Email **ep = NULL;\n      ARRAY_FOREACH(ep, ea)\n      {\n        struct Email *e = *ep;\n        mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);\n        mutt_endwin();\n        pid = filter_create(cmd, &fp_out, NULL, NULL, EnvList);\n        if (pid < 0)\n        {\n          mutt_perror(_(\"Can't create filter process\"));\n          return 1;\n        }\n        OptKeepQuiet = true;\n        pipe_msg(m, e, NULL, fp_out, decode, print);\n        /* add the message separator */\n        if (sep)\n          fputs(sep, fp_out);\n        mutt_file_fclose(&fp_out);\n        if (filter_wait(pid) != 0)\n          rc = 1;\n        OptKeepQuiet = false;\n      }\n    }\n    else\n    {\n      mutt_endwin();\n      pid = filter_create(cmd, &fp_out, NULL, NULL, EnvList);\n      if (pid < 0)\n      {\n        mutt_perror(_(\"Can't create filter process\"));\n        return 1;\n      }\n      OptKeepQuiet = true;\n      struct Email **ep = NULL;\n      ARRAY_FOREACH(ep, ea)\n      {\n        struct Email *e = *ep;\n        mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);\n        pipe_msg(m, e, NULL, fp_out, decode, print);\n        /* add the message separator */\n        if (sep)\n          fputs(sep, fp_out);\n      }\n      mutt_file_fclose(&fp_out);\n      if (filter_wait(pid) != 0)\n        rc = 1;\n      OptKeepQuiet = false;\n    }\n  }\n\n  const bool c_wait_key = cs_subset_bool(NeoMutt->sub, \"wait_key\");\n  if ((rc != 0) || c_wait_key)\n    mutt_any_key_to_continue(NULL);\n  return rc;\n}\n\n/**\n * mutt_pipe_message - Pipe a message\n * @param m  Mailbox\n * @param ea Array of Emails to pipe\n */\nvoid mutt_pipe_message(struct Mailbox *m, struct EmailArray *ea)\n{\n  if (!m || !ea)\n    return;\n\n  struct Buffer *buf = buf_pool_get();\n\n  if (mw_get_field(_(\"Pipe to command: \"), buf, MUTT_COMP_NO_FLAGS,\n                   HC_EXT_COMMAND, &CompleteFileOps, NULL) != 0)\n  {\n    goto cleanup;\n  }\n\n  if (buf_is_empty(buf))\n    goto cleanup;\n\n  buf_expand_path(buf);\n  const bool c_pipe_decode = cs_subset_bool(NeoMutt->sub, \"pipe_decode\");\n  const bool c_pipe_split = cs_subset_bool(NeoMutt->sub, \"pipe_split\");\n  const char *const c_pipe_sep = cs_subset_string(NeoMutt->sub, \"pipe_sep\");\n  pipe_message(m, ea, buf_string(buf), c_pipe_decode, false, c_pipe_split, c_pipe_sep);\n\ncleanup:\n  buf_pool_release(&buf);\n}\n\n/**\n * mutt_print_message - Print a message\n * @param m  Mailbox\n * @param ea Array of Emails to print\n */\nvoid mutt_print_message(struct Mailbox *m, struct EmailArray *ea)\n{\n  if (!m || !ea)\n    return;\n\n  const enum QuadOption c_print = cs_subset_quad(NeoMutt->sub, \"print\");\n  const char *const c_print_command = cs_subset_string(NeoMutt->sub, \"print_command\");\n  if (c_print && !c_print_command)\n  {\n    mutt_message(_(\"No printing command has been defined\"));\n    return;\n  }\n\n  int msg_count = ARRAY_SIZE(ea);\n  const char *msg = ngettext(\"Print message?\", \"Print tagged messages?\", msg_count);\n  if (query_quadoption(msg, NeoMutt->sub, \"print\") != MUTT_YES)\n  {\n    return;\n  }\n\n  const bool c_print_decode = cs_subset_bool(NeoMutt->sub, \"print_decode\");\n  const bool c_print_split = cs_subset_bool(NeoMutt->sub, \"print_split\");\n  if (pipe_message(m, ea, c_print_command, c_print_decode, true, c_print_split, \"\\f\") == 0)\n  {\n    mutt_message(ngettext(\"Message printed\", \"Messages printed\", msg_count));\n  }\n  else\n  {\n    mutt_message(ngettext(\"Message could not be printed\",\n                          \"Messages could not be printed\", msg_count));\n  }\n}\n\n/**\n * mutt_select_sort - Ask the user for a sort method\n * @param reverse If true make it a reverse sort\n * @retval true The sort type changed\n */\nbool mutt_select_sort(bool reverse)\n{\n  enum EmailSortType sort = EMAIL_SORT_DATE;\n\n  switch (mw_multi_choice(reverse ?\n                              /* L10N: The highlighted letters must match the \"Sort\" options */\n                              _(\"Rev-Sort (d)ate,(f)rm,(r)ecv,(s)ubj,t(o),(t)hread,(u)nsort,si(z)e,s(c)ore,s(p)am,(l)abel?\") :\n                              /* L10N: The highlighted letters must match the \"Rev-Sort\" options */\n                              _(\"Sort (d)ate,(f)rm,(r)ecv,(s)ubj,t(o),(t)hread,(u)nsort,si(z)e,s(c)ore,s(p)am,(l)abel?\"),\n                          /* L10N: These must match the highlighted letters from \"Sort\" and \"Rev-Sort\" */\n                          _(\"dfrsotuzcpl\")))\n  {\n    case -1: /* abort - don't resort */\n      return false;\n\n    case 1: /* (d)ate */\n      sort = EMAIL_SORT_DATE;\n      break;\n\n    case 2: /* (f)rm */\n      sort = EMAIL_SORT_FROM;\n      break;\n\n    case 3: /* (r)ecv */\n      sort = EMAIL_SORT_DATE_RECEIVED;\n      break;\n\n    case 4: /* (s)ubj */\n      sort = EMAIL_SORT_SUBJECT;\n      break;\n\n    case 5: /* t(o) */\n      sort = EMAIL_SORT_TO;\n      break;\n\n    case 6: /* (t)hread */\n      sort = EMAIL_SORT_THREADS;\n      break;\n\n    case 7: /* (u)nsort */\n      sort = EMAIL_SORT_UNSORTED;\n      break;\n\n    case 8: /* si(z)e */\n      sort = EMAIL_SORT_SIZE;\n      break;\n\n    case 9: /* s(c)ore */\n      sort = EMAIL_SORT_SCORE;\n      break;\n\n    case 10: /* s(p)am */\n      sort = EMAIL_SORT_SPAM;\n      break;\n\n    case 11: /* (l)abel */\n      sort = EMAIL_SORT_LABEL;\n      break;\n  }\n\n  const unsigned char c_use_threads = cs_subset_enum(NeoMutt->sub, \"use_threads\");\n  const enum EmailSortType c_sort = cs_subset_sort(NeoMutt->sub, \"sort\");\n  int rc = CSR_ERR_CODE;\n  if ((sort != EMAIL_SORT_THREADS) || (c_use_threads == UT_UNSET))\n  {\n    if ((sort != EMAIL_SORT_THREADS) && (c_sort & SORT_LAST))\n      sort |= SORT_LAST;\n    if (reverse)\n      sort |= SORT_REVERSE;\n\n    rc = cs_subset_str_native_set(NeoMutt->sub, \"sort\", sort, NULL);\n  }\n  else\n  {\n    ASSERT((c_sort & SORT_MASK) != EMAIL_SORT_THREADS); /* See index_config_observer() */\n    /* Preserve the value of $sort, and toggle whether we are threaded. */\n    switch (c_use_threads)\n    {\n      case UT_FLAT:\n        rc = cs_subset_str_native_set(NeoMutt->sub, \"use_threads\",\n                                      reverse ? UT_REVERSE : UT_THREADS, NULL);\n        break;\n      case UT_THREADS:\n        rc = cs_subset_str_native_set(NeoMutt->sub, \"use_threads\",\n                                      reverse ? UT_REVERSE : UT_FLAT, NULL);\n        break;\n      case UT_REVERSE:\n        rc = cs_subset_str_native_set(NeoMutt->sub, \"use_threads\",\n                                      reverse ? UT_FLAT : UT_THREADS, NULL);\n        break;\n      default:\n        ASSERT(false);\n    }\n  }\n\n  return ((CSR_RESULT(rc) == CSR_SUCCESS) && !(rc & CSR_SUC_NO_CHANGE));\n}\n\n/**\n * mutt_shell_escape - Invoke a command in a subshell\n * @retval true A command was invoked (no matter what its result)\n * @retval false No command was invoked\n */\nbool mutt_shell_escape(void)\n{\n  bool rc = false;\n  struct Buffer *buf = buf_pool_get();\n\n  if (mw_get_field(_(\"Shell command: \"), buf, MUTT_COMP_NO_FLAGS,\n                   HC_EXT_COMMAND, &CompleteFileOps, NULL) != 0)\n  {\n    goto done;\n  }\n\n  if (buf_is_empty(buf))\n  {\n    const char *const c_shell = cs_subset_string(NeoMutt->sub, \"shell\");\n    buf_strcpy(buf, c_shell);\n  }\n\n  if (buf_is_empty(buf))\n  {\n    goto done;\n  }\n\n  msgwin_clear_text(NULL);\n  mutt_endwin();\n  fflush(stdout);\n  int rc2 = mutt_system(buf_string(buf));\n  if (rc2 == -1)\n    mutt_debug(LL_DEBUG1, \"Error running \\\"%s\\\"\\n\", buf_string(buf));\n\n  const bool c_wait_key = cs_subset_bool(NeoMutt->sub, \"wait_key\");\n  if ((rc2 != 0) || c_wait_key)\n    mutt_any_key_to_continue(NULL);\n\n  rc = true;\ndone:\n  buf_pool_release(&buf);\n  return rc;\n}\n\n/**\n * mutt_enter_command - Enter a neomutt command\n */\nvoid mutt_enter_command(void)\n{\n  struct Buffer *buf = buf_pool_get();\n  struct Buffer *err = buf_pool_get();\n\n  window_redraw(NULL);\n  /* if enter is pressed after : with no command, just return */\n  if ((mw_get_field(\":\", buf, MUTT_COMP_NO_FLAGS, HC_NEO_COMMAND,\n                    &CompleteCommandOps, NULL) != 0) ||\n      buf_is_empty(buf))\n  {\n    goto done;\n  }\n\n  enum CommandResult rc = parse_rc_line(buf_string(buf), err);\n  if (!buf_is_empty(err))\n  {\n    if (rc == MUTT_CMD_SUCCESS) /* command succeeded with message */\n      mutt_message(\"%s\", buf_string(err));\n    else if (rc == MUTT_CMD_ERROR)\n      mutt_error(\"%s\", buf_string(err));\n    else if (rc == MUTT_CMD_WARNING)\n      mutt_warning(\"%s\", buf_string(err));\n  }\n\n  if (NeoMutt)\n  {\n    // Running commands could cause anything to change, so let others know\n    notify_send(NeoMutt->notify, NT_GLOBAL, NT_GLOBAL_COMMAND, NULL);\n  }\n\ndone:\n  buf_pool_release(&buf);\n  buf_pool_release(&err);\n}\n\n/**\n * mutt_display_address - Display the address of a message\n * @param env Envelope containing address\n */\nvoid mutt_display_address(struct Envelope *env)\n{\n  const char *pfx = NULL;\n\n  struct AddressList *al = mutt_get_address(env, &pfx);\n  if (!al)\n    return;\n\n  /* Note: We don't convert IDNA to local representation this time.\n   * That is intentional, so the user has an opportunity to copy &\n   * paste the on-the-wire form of the address to other, IDN-unable\n   * software.  */\n  struct Buffer *buf = buf_pool_get();\n  mutt_addrlist_write(al, buf, false);\n  mutt_message(\"%s: %s\", pfx, buf_string(buf));\n  buf_pool_release(&buf);\n}\n\n/**\n * set_copy_flags - Set the flags for a message copy\n * @param[in]  e               Email\n * @param[in]  transform_opt   Transformation, e.g. #TRANSFORM_DECRYPT\n * @param[out] cmflags         Flags, see #CopyMessageFlags\n * @param[out] chflags         Flags, see #CopyHeaderFlags\n */\nstatic void set_copy_flags(struct Email *e, enum MessageTransformOpt transform_opt,\n                           CopyMessageFlags *cmflags, CopyHeaderFlags *chflags)\n{\n  *cmflags = MUTT_CM_NO_FLAGS;\n  *chflags = CH_UPDATE_LEN;\n\n  const bool need_decrypt = (transform_opt == TRANSFORM_DECRYPT) &&\n                            (e->security & SEC_ENCRYPT);\n  const bool want_pgp = (WithCrypto & APPLICATION_PGP);\n  const bool want_smime = (WithCrypto & APPLICATION_SMIME);\n  const bool is_pgp = mutt_is_application_pgp(e->body) & SEC_ENCRYPT;\n  const bool is_smime = mutt_is_application_smime(e->body) & SEC_ENCRYPT;\n\n  if (need_decrypt && want_pgp && mutt_is_multipart_encrypted(e->body))\n  {\n    *chflags = CH_NONEWLINE | CH_XMIT | CH_MIME;\n    *cmflags = MUTT_CM_DECODE_PGP;\n  }\n  else if (need_decrypt && want_pgp && is_pgp)\n  {\n    *chflags = CH_XMIT | CH_MIME | CH_TXTPLAIN;\n    *cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;\n  }\n  else if (need_decrypt && want_smime && is_smime)\n  {\n    *chflags = CH_NONEWLINE | CH_XMIT | CH_MIME;\n    *cmflags = MUTT_CM_DECODE_SMIME;\n  }\n  else if (transform_opt == TRANSFORM_DECODE)\n  {\n    *chflags = CH_XMIT | CH_MIME | CH_TXTPLAIN | CH_DECODE; // then decode RFC2047\n    *cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;\n    const bool c_copy_decode_weed = cs_subset_bool(NeoMutt->sub, \"copy_decode_weed\");\n    if (c_copy_decode_weed)\n    {\n      *chflags |= CH_WEED; // and respect $weed\n      *cmflags |= MUTT_CM_WEED;\n    }\n  }\n}\n\n/**\n * mutt_save_message_mbox - Save a message to a given mailbox\n * @param m_src            Mailbox to copy from\n * @param e                Email\n * @param save_opt         Copy or move, e.g. #SAVE_MOVE\n * @param transform_opt    Transformation, e.g. #TRANSFORM_DECRYPT\n * @param m_dst            Mailbox to save to\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_save_message_mbox(struct Mailbox *m_src, struct Email *e, enum MessageSaveOpt save_opt,\n                           enum MessageTransformOpt transform_opt, struct Mailbox *m_dst)\n{\n  CopyMessageFlags cmflags = MUTT_CM_NO_FLAGS;\n  CopyHeaderFlags chflags = CH_NO_FLAGS;\n  int rc;\n\n  set_copy_flags(e, transform_opt, &cmflags, &chflags);\n\n  struct Message *msg = mx_msg_open(m_src, e);\n  if (msg && transform_opt != TRANSFORM_NONE)\n  {\n    mutt_parse_mime_message(e, msg->fp);\n  }\n\n  rc = mutt_append_message(m_dst, m_src, e, msg, cmflags, chflags);\n  mx_msg_close(m_src, &msg);\n  if (rc != 0)\n    return rc;\n\n  if (save_opt == SAVE_MOVE)\n  {\n    mutt_set_flag(m_src, e, MUTT_DELETE, true, true);\n    mutt_set_flag(m_src, e, MUTT_PURGE, true, true);\n    const bool c_delete_untag = cs_subset_bool(NeoMutt->sub, \"delete_untag\");\n    if (c_delete_untag)\n      mutt_set_flag(m_src, e, MUTT_TAG, false, true);\n  }\n\n  return 0;\n}\n\n/**\n * mutt_save_message - Save an email\n * @param m                Mailbox\n * @param ea               Array of Emails to save\n * @param save_opt         Copy or move, e.g. #SAVE_MOVE\n * @param transform_opt    Transformation, e.g. #TRANSFORM_DECRYPT\n * @retval  0 Copy/save was successful\n * @retval -1 Error/abort\n */\nint mutt_save_message(struct Mailbox *m, struct EmailArray *ea,\n                      enum MessageSaveOpt save_opt, enum MessageTransformOpt transform_opt)\n{\n  if (!ea || ARRAY_EMPTY(ea))\n    return -1;\n\n  int rc = -1;\n  int tagged_progress_count = 0;\n  unsigned int msg_count = ARRAY_SIZE(ea);\n  struct Mailbox *m_save = NULL;\n\n  struct Buffer *buf = buf_pool_get();\n  struct stat st = { 0 };\n  struct Email *e_cur = *ARRAY_GET(ea, 0);\n\n  const SecurityFlags security_flags = WithCrypto ? e_cur->security : SEC_NO_FLAGS;\n  const bool is_passphrase_needed = security_flags & SEC_ENCRYPT;\n\n  const char *prompt = NULL;\n  const char *progress_msg = NULL;\n\n  // Set prompt and progress_msg\n  switch (save_opt)\n  {\n    case SAVE_COPY:\n      // L10N: Progress meter message when copying tagged messages\n      progress_msg = (msg_count > 1) ? _(\"Copying tagged messages...\") : NULL;\n      switch (transform_opt)\n      {\n        case TRANSFORM_NONE:\n          prompt = (msg_count > 1) ? _(\"Copy tagged to mailbox\") : _(\"Copy to mailbox\");\n          break;\n        case TRANSFORM_DECRYPT:\n          prompt = (msg_count > 1) ? _(\"Decrypt-copy tagged to mailbox\") :\n                                     _(\"Decrypt-copy to mailbox\");\n          break;\n        case TRANSFORM_DECODE:\n          prompt = (msg_count > 1) ? _(\"Decode-copy tagged to mailbox\") :\n                                     _(\"Decode-copy to mailbox\");\n          break;\n      }\n      break;\n\n    case SAVE_MOVE:\n      // L10N: Progress meter message when saving tagged messages\n      progress_msg = (msg_count > 1) ? _(\"Saving tagged messages...\") : NULL;\n      switch (transform_opt)\n      {\n        case TRANSFORM_NONE:\n          prompt = (msg_count > 1) ? _(\"Save tagged to mailbox\") : _(\"Save to mailbox\");\n          break;\n        case TRANSFORM_DECRYPT:\n          prompt = (msg_count > 1) ? _(\"Decrypt-save tagged to mailbox\") :\n                                     _(\"Decrypt-save to mailbox\");\n          break;\n        case TRANSFORM_DECODE:\n          prompt = (msg_count > 1) ? _(\"Decode-save tagged to mailbox\") :\n                                     _(\"Decode-save to mailbox\");\n          break;\n      }\n      break;\n  }\n\n  mutt_message_hook(m, e_cur, MUTT_MESSAGE_HOOK);\n  mutt_default_save(buf, e_cur);\n  buf_pretty_mailbox(buf);\n\n  if (mw_enter_fname(prompt, buf, false, NULL, false, NULL, NULL, MUTT_SEL_NO_FLAGS) == -1)\n  {\n    goto cleanup;\n  }\n\n  size_t pathlen = buf_len(buf);\n  if (pathlen == 0)\n    goto cleanup;\n\n  mutt_path_tidy(buf, true);\n\n  /* This is an undocumented feature of ELM pointed out to me by Felix von\n   * Leitner <leitner@prz.fu-berlin.de> */\n  if (buf_is_empty(&LastSaveFolder))\n    buf_alloc(&LastSaveFolder, PATH_MAX);\n  if (mutt_str_equal(buf_string(buf), \".\"))\n    buf_copy(buf, &LastSaveFolder);\n  else\n    buf_strcpy(&LastSaveFolder, buf_string(buf));\n\n  buf_expand_path(buf);\n\n  /* check to make sure that this file is really the one the user wants */\n  if (mutt_save_confirm(buf_string(buf), &st) != 0)\n    goto cleanup;\n\n  if (is_passphrase_needed && (transform_opt != TRANSFORM_NONE) &&\n      !crypt_valid_passphrase(security_flags))\n  {\n    rc = -1;\n    goto errcleanup;\n  }\n\n  mutt_message(_(\"Copying to %s...\"), buf_string(buf));\n\n  enum MailboxType mailbox_type = imap_path_probe(buf_string(buf), NULL);\n  if ((m->type == MUTT_IMAP) && (transform_opt == TRANSFORM_NONE) && (mailbox_type == MUTT_IMAP))\n  {\n    rc = imap_copy_messages(m, ea, buf_string(buf), save_opt);\n    switch (rc)\n    {\n      /* success */\n      case 0:\n        mutt_clear_error();\n        rc = 0;\n        if (save_opt == SAVE_MOVE)\n        {\n          const bool c_delete_untag = cs_subset_bool(NeoMutt->sub, \"delete_untag\");\n          if (c_delete_untag)\n          {\n            struct Email **ep = NULL;\n            ARRAY_FOREACH(ep, ea)\n            {\n              mutt_set_flag(m, *ep, MUTT_TAG, false, true);\n            }\n          }\n        }\n        goto cleanup;\n      /* non-fatal error: continue to fetch/append */\n      case 1:\n        break;\n      /* fatal error, abort */\n      case -1:\n        goto errcleanup;\n    }\n  }\n\n  mutt_file_resolve_symlink(buf);\n  m_save = mx_path_resolve(buf_string(buf));\n  bool old_append = m_save->append;\n  OpenMailboxFlags mbox_flags = MUTT_NEWFOLDER;\n  /* Display a tagged message progress counter, rather than (for\n   * IMAP) a per-message progress counter */\n  if (msg_count > 1)\n    mbox_flags |= MUTT_QUIET;\n  if (!mx_mbox_open(m_save, mbox_flags))\n  {\n    rc = -1;\n    mailbox_free(&m_save);\n    goto errcleanup;\n  }\n  m_save->append = true;\n\n  /* If we're saving to a compressed mailbox, the stats won't be updated\n   * until the next open.  Until then, improvise. */\n  struct Mailbox *m_comp = NULL;\n  if (m_save->compress_info)\n  {\n    m_comp = mailbox_find(m_save->realpath);\n  }\n  /* We probably haven't been opened yet */\n  if (m_comp && (m_comp->msg_count == 0))\n    m_comp = NULL;\n\n  if (msg_count == 1)\n  {\n    rc = mutt_save_message_mbox(m, e_cur, save_opt, transform_opt, m_save);\n    if (rc != 0)\n    {\n      mx_mbox_close(m_save);\n      m_save->append = old_append;\n      goto errcleanup;\n    }\n\n    if (m_comp)\n    {\n      m_comp->msg_count++;\n      if (!e_cur->read)\n      {\n        m_comp->msg_unread++;\n        if (!e_cur->old)\n          m_comp->msg_new++;\n      }\n      if (e_cur->flagged)\n        m_comp->msg_flagged++;\n    }\n  }\n  else\n  {\n    rc = 0;\n\n#ifdef USE_NOTMUCH\n    if (m->type == MUTT_NOTMUCH)\n      nm_db_longrun_init(m, true);\n#endif\n    struct Progress *progress = progress_new(MUTT_PROGRESS_WRITE, msg_count);\n    progress_set_message(progress, \"%s\", progress_msg);\n    struct Email **ep = NULL;\n    ARRAY_FOREACH(ep, ea)\n    {\n      struct Email *e = *ep;\n      progress_update(progress, ++tagged_progress_count, -1);\n      mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);\n      rc = mutt_save_message_mbox(m, e, save_opt, transform_opt, m_save);\n      if (rc != 0)\n        break;\n\n      if (m_comp)\n      {\n        struct Email *e2 = e;\n        m_comp->msg_count++;\n        if (!e2->read)\n        {\n          m_comp->msg_unread++;\n          if (!e2->old)\n            m_comp->msg_new++;\n        }\n        if (e2->flagged)\n          m_comp->msg_flagged++;\n      }\n    }\n    progress_free(&progress);\n\n#ifdef USE_NOTMUCH\n    if (m->type == MUTT_NOTMUCH)\n      nm_db_longrun_done(m);\n#endif\n    if (rc != 0)\n    {\n      mx_mbox_close(m_save);\n      m_save->append = old_append;\n      goto errcleanup;\n    }\n  }\n\n  const bool need_mailbox_cleanup = ((m_save->type == MUTT_MBOX) ||\n                                     (m_save->type == MUTT_MMDF));\n\n  mx_mbox_close(m_save);\n  m_save->append = old_append;\n\n  if (need_mailbox_cleanup)\n    mailbox_restore_timestamp(buf_string(buf), &st);\n\n  mutt_clear_error();\n  rc = 0;\n\nerrcleanup:\n  if (rc != 0)\n  {\n    switch (save_opt)\n    {\n      case SAVE_MOVE:\n        if (msg_count > 1)\n        {\n          // L10N: Message when an index tagged save operation fails for some reason\n          mutt_error(_(\"Error saving tagged messages\"));\n        }\n        else\n        {\n          // L10N: Message when an index/pager save operation fails for some reason\n          mutt_error(_(\"Error saving message\"));\n        }\n        break;\n      case SAVE_COPY:\n        if (msg_count > 1)\n        {\n          // L10N: Message when an index tagged copy operation fails for some reason\n          mutt_error(_(\"Error copying tagged messages\"));\n        }\n        else\n        {\n          // L10N: Message when an index/pager copy operation fails for some reason\n          mutt_error(_(\"Error copying message\"));\n        }\n        break;\n    }\n  }\n\n  mailbox_free(&m_save);\n\ncleanup:\n  buf_pool_release(&buf);\n  return rc;\n}\n\n/**\n * mutt_edit_content_type - Edit the content type of an attachment\n * @param e  Email\n * @param b  Attachment\n * @param fp File handle to the attachment\n * @retval true A Any change is made\n *\n * recvattach requires the return code to know when to regenerate the actx.\n */\nbool mutt_edit_content_type(struct Email *e, struct Body *b, FILE *fp)\n{\n  struct Buffer *buf = buf_pool_get();\n  struct Buffer *charset = buf_pool_get();\n  struct Buffer *obuf = buf_pool_get();\n  struct Buffer *tmp = buf_pool_get();\n\n  bool rc = false;\n  bool charset_changed = false;\n  bool type_changed = false;\n  bool structure_changed = false;\n\n  char *cp = mutt_param_get(&b->parameter, \"charset\");\n  buf_strcpy(charset, cp);\n\n  buf_printf(buf, \"%s/%s\", TYPE(b), b->subtype);\n  buf_copy(obuf, buf);\n  if (!TAILQ_EMPTY(&b->parameter))\n  {\n    struct Parameter *np = NULL;\n    TAILQ_FOREACH(np, &b->parameter, entries)\n    {\n      mutt_addr_cat(tmp->data, tmp->dsize, np->value, MimeSpecials);\n      buf_add_printf(buf, \"; %s=%s\", np->attribute, buf_string(tmp));\n    }\n  }\n\n  if ((mw_get_field(\"Content-Type: \", buf, MUTT_COMP_NO_FLAGS, HC_OTHER, NULL, NULL) != 0) ||\n      buf_is_empty(buf))\n  {\n    goto done;\n  }\n\n  /* clean up previous junk */\n  mutt_param_free(&b->parameter);\n  FREE(&b->subtype);\n\n  mutt_parse_content_type(buf_string(buf), b);\n\n  buf_printf(tmp, \"%s/%s\", TYPE(b), NONULL(b->subtype));\n  type_changed = !mutt_istr_equal(buf_string(tmp), buf_string(obuf));\n  charset_changed = !mutt_istr_equal(buf_string(charset),\n                                     mutt_param_get(&b->parameter, \"charset\"));\n\n  /* if in send mode, check for conversion - current setting is default. */\n\n  if (!e && (b->type == TYPE_TEXT) && charset_changed)\n  {\n    buf_printf(tmp, _(\"Convert to %s upon sending?\"),\n               mutt_param_get(&b->parameter, \"charset\"));\n    enum QuadOption ans = query_yesorno(buf_string(tmp), b->noconv ? MUTT_NO : MUTT_YES);\n    if (ans != MUTT_ABORT)\n      b->noconv = (ans == MUTT_NO);\n  }\n\n  /* inform the user */\n\n  buf_printf(tmp, \"%s/%s\", TYPE(b), NONULL(b->subtype));\n  if (type_changed)\n    mutt_message(_(\"Content-Type changed to %s\"), buf_string(tmp));\n  if ((b->type == TYPE_TEXT) && charset_changed)\n  {\n    if (type_changed)\n      mutt_sleep(1);\n    mutt_message(b->noconv ? _(\"Character set changed to %s; not converting\") :\n                             _(\"Character set changed to %s; converting\"),\n                 mutt_param_get(&b->parameter, \"charset\"));\n  }\n\n  b->force_charset |= charset_changed;\n\n  if (!is_multipart(b) && b->parts)\n  {\n    structure_changed = true;\n    mutt_body_free(&b->parts);\n  }\n  if (!mutt_is_message_type(b->type, b->subtype) && b->email)\n  {\n    structure_changed = true;\n    b->email->body = NULL;\n    email_free(&b->email);\n  }\n\n  if (fp && !b->parts && (is_multipart(b) || mutt_is_message_type(b->type, b->subtype)))\n  {\n    structure_changed = true;\n    mutt_parse_part(fp, b);\n  }\n\n  if ((WithCrypto != 0) && e)\n  {\n    if (e->body == b)\n      e->security = SEC_NO_FLAGS;\n\n    e->security |= crypt_query(b);\n  }\n\n  rc = structure_changed | type_changed;\n\ndone:\n  buf_pool_release(&buf);\n  buf_pool_release(&charset);\n  buf_pool_release(&obuf);\n  buf_pool_release(&tmp);\n  return rc;\n}\n\n/**\n * check_traditional_pgp - Check for an inline PGP content\n * @param m Mailbox\n * @param e Email to check\n * @retval true Message contains inline PGP content\n */\nstatic bool check_traditional_pgp(struct Mailbox *m, struct Email *e)\n{\n  bool rc = false;\n\n  e->security |= PGP_TRADITIONAL_CHECKED;\n\n  struct Message *msg = mx_msg_open(m, e);\n  if (msg)\n  {\n    mutt_parse_mime_message(e, msg->fp);\n    if (crypt_pgp_check_traditional(msg->fp, e->body, false))\n    {\n      e->security = crypt_query(e->body);\n      rc = true;\n    }\n\n    e->security |= PGP_TRADITIONAL_CHECKED;\n    mx_msg_close(m, &msg);\n  }\n  return rc;\n}\n\n/**\n * mutt_check_traditional_pgp - Check if a message has inline PGP content\n * @param m  Mailbox\n * @param ea Array of Emails to check\n * @retval true Message contains inline PGP content\n */\nbool mutt_check_traditional_pgp(struct Mailbox *m, struct EmailArray *ea)\n{\n  bool rc = false;\n\n  struct Email **ep = NULL;\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    if (!(e->security & PGP_TRADITIONAL_CHECKED))\n      rc = check_traditional_pgp(m, e) || rc;\n  }\n\n  return rc;\n}\n"
        },
        {
          "name": "external.h",
          "type": "blob",
          "size": 2.3583984375,
          "content": "/**\n * @file\n * Manage where the email is piped to external commands\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2021 Ihor Antonov <ihor@antonovs.family>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_EXTERNAL_H\n#define MUTT_EXTERNAL_H\n\n#include <stdbool.h>\n#include <stdio.h>\n\nstruct Body;\nstruct Email;\nstruct EmailArray;\nstruct Envelope;\nstruct Mailbox;\n\n/**\n * enum MessageTransformOpt - Message transformation option\n */\nenum MessageTransformOpt\n{\n  TRANSFORM_NONE = 0,   ///< No transformation\n  TRANSFORM_DECRYPT,    ///< Decrypt message\n  TRANSFORM_DECODE,     ///< Decode message\n};\n\n/**\n * enum MessageSaveOpt - Message save option\n */\nenum MessageSaveOpt\n{\n  SAVE_COPY = 0,   ///< Copy message, making a duplicate in another mailbox\n  SAVE_MOVE,       ///< Move message to another mailbox, removing the original\n};\n\nvoid index_bounce_message(struct Mailbox *m, struct EmailArray *ea);\nbool mutt_check_traditional_pgp(struct Mailbox *m, struct EmailArray *ea);\nvoid external_cleanup(void);\nvoid mutt_display_address(struct Envelope *env);\nbool mutt_edit_content_type(struct Email *e, struct Body *b, FILE *fp);\nvoid mutt_enter_command(void);\nvoid mutt_pipe_message(struct Mailbox *m, struct EmailArray *ea);\nvoid mutt_print_message(struct Mailbox *m, struct EmailArray *ea);\nint  mutt_save_message(struct Mailbox *m, struct EmailArray *ea, enum MessageSaveOpt save_opt, enum MessageTransformOpt transform_opt);\nint  mutt_save_message_mbox(struct Mailbox *m_src, struct Email *e, enum MessageSaveOpt save_opt, enum MessageTransformOpt transform_opt, struct Mailbox *m_dst);\nbool mutt_select_sort(bool reverse);\nbool mutt_shell_escape(void);\n\n#endif /* MUTT_EXTERNAL_H */\n"
        },
        {
          "name": "flags.c",
          "type": "blob",
          "size": 11.787109375,
          "content": "/**\n * @file\n * Manipulate the flags in an email header\n *\n * @authors\n * Copyright (C) 1996-2000 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017 Fabrice Bellet <fabrice@bellet.info>\n * Copyright (C) 2018 Mehdi Abaakouk <sileht@sileht.net>\n * Copyright (C) 2022 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_flags Manipulate the flags in an email header\n *\n * Manipulate the flags in an email header\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"color/lib.h\"\n#include \"index/lib.h\"\n#include \"key/lib.h\"\n#include \"mutt_thread.h\"\n#include \"protos.h\"\n\n/**\n * mutt_set_flag - Set a flag on an email\n * @param m        Mailbox\n * @param e        Email\n * @param flag     Flag to set, e.g. #MUTT_DELETE\n * @param bf       true: set the flag; false: clear the flag\n * @param upd_mbox true: update the Mailbox\n */\nvoid mutt_set_flag(struct Mailbox *m, struct Email *e, enum MessageType flag,\n                   bool bf, bool upd_mbox)\n{\n  if (!m || !e)\n    return;\n\n  bool changed = e->changed;\n  int deleted = m->msg_deleted;\n  int tagged = m->msg_tagged;\n  int flagged = m->msg_flagged;\n  int update = false;\n\n  if (m->readonly && (flag != MUTT_TAG))\n    return; /* don't modify anything if we are read-only */\n\n  switch (flag)\n  {\n    case MUTT_DELETE:\n    {\n      if (!(m->rights & MUTT_ACL_DELETE))\n        return;\n\n      if (bf)\n      {\n        const bool c_flag_safe = cs_subset_bool(NeoMutt->sub, \"flag_safe\");\n        if (!e->deleted && !m->readonly && (!e->flagged || !c_flag_safe))\n        {\n          e->deleted = true;\n          update = true;\n          if (upd_mbox)\n            m->msg_deleted++;\n          /* deleted messages aren't treated as changed elsewhere so that the\n           * purge-on-sync option works correctly. This isn't applicable here */\n          if (m->type == MUTT_IMAP)\n          {\n            e->changed = true;\n            if (upd_mbox)\n              m->changed = true;\n          }\n        }\n      }\n      else if (e->deleted)\n      {\n        e->deleted = false;\n        update = true;\n        if (upd_mbox)\n          m->msg_deleted--;\n        /* see my comment above */\n        if (m->type == MUTT_IMAP)\n        {\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n        /* If the user undeletes a message which is marked as\n         * \"trash\" in the maildir folder on disk, the folder has\n         * been changed, and is marked accordingly.  However, we do\n         * _not_ mark the message itself changed, because trashing\n         * is checked in specific code in the maildir folder\n         * driver.  */\n        if ((m->type == MUTT_MAILDIR) && upd_mbox && e->trash)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_PURGE:\n    {\n      if (!(m->rights & MUTT_ACL_DELETE))\n        return;\n\n      if (bf)\n      {\n        if (!e->purge && !m->readonly)\n          e->purge = true;\n      }\n      else if (e->purge)\n      {\n        e->purge = false;\n      }\n      break;\n    }\n    case MUTT_NEW:\n    {\n      if (!(m->rights & MUTT_ACL_SEEN))\n        return;\n\n      if (bf)\n      {\n        if (e->read || e->old)\n        {\n          update = true;\n          e->old = false;\n          if (upd_mbox)\n            m->msg_new++;\n          if (e->read)\n          {\n            e->read = false;\n            if (upd_mbox)\n              m->msg_unread++;\n          }\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n      }\n      else if (!e->read)\n      {\n        update = true;\n        if (!e->old)\n          if (upd_mbox)\n            m->msg_new--;\n        e->read = true;\n        if (upd_mbox)\n          m->msg_unread--;\n        e->changed = true;\n        if (upd_mbox)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_OLD:\n    {\n      if (!(m->rights & MUTT_ACL_SEEN))\n        return;\n\n      if (bf)\n      {\n        if (!e->old)\n        {\n          update = true;\n          e->old = true;\n          if (!e->read)\n            if (upd_mbox)\n              m->msg_new--;\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n      }\n      else if (e->old)\n      {\n        update = true;\n        e->old = false;\n        if (!e->read)\n          if (upd_mbox)\n            m->msg_new++;\n        e->changed = true;\n        if (upd_mbox)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_READ:\n    {\n      if (!(m->rights & MUTT_ACL_SEEN))\n        return;\n\n      if (bf)\n      {\n        if (!e->read)\n        {\n          update = true;\n          e->read = true;\n          if (upd_mbox)\n            m->msg_unread--;\n          if (!e->old)\n            if (upd_mbox)\n              m->msg_new--;\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n      }\n      else if (e->read)\n      {\n        update = true;\n        e->read = false;\n        if (upd_mbox)\n          m->msg_unread++;\n        if (!e->old)\n          if (upd_mbox)\n            m->msg_new++;\n        e->changed = true;\n        if (upd_mbox)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_REPLIED:\n    {\n      if (!(m->rights & MUTT_ACL_WRITE))\n        return;\n\n      if (bf)\n      {\n        if (!e->replied)\n        {\n          update = true;\n          e->replied = true;\n          if (!e->read)\n          {\n            e->read = true;\n            if (upd_mbox)\n              m->msg_unread--;\n            if (!e->old)\n              if (upd_mbox)\n                m->msg_new--;\n          }\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n      }\n      else if (e->replied)\n      {\n        update = true;\n        e->replied = false;\n        e->changed = true;\n        if (upd_mbox)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_FLAG:\n    {\n      if (!(m->rights & MUTT_ACL_WRITE))\n        return;\n\n      if (bf)\n      {\n        if (!e->flagged)\n        {\n          update = true;\n          e->flagged = bf;\n          if (upd_mbox)\n            m->msg_flagged++;\n          e->changed = true;\n          if (upd_mbox)\n            m->changed = true;\n        }\n      }\n      else if (e->flagged)\n      {\n        update = true;\n        e->flagged = false;\n        if (upd_mbox)\n          m->msg_flagged--;\n        e->changed = true;\n        if (upd_mbox)\n          m->changed = true;\n      }\n      break;\n    }\n    case MUTT_TAG:\n    {\n      if (bf)\n      {\n        if (!e->tagged)\n        {\n          update = true;\n          e->tagged = true;\n          if (upd_mbox)\n            m->msg_tagged++;\n        }\n      }\n      else if (e->tagged)\n      {\n        update = true;\n        e->tagged = false;\n        if (upd_mbox)\n          m->msg_tagged--;\n      }\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  if (update)\n  {\n    email_set_color(m, e);\n    struct EventMailbox ev_m = { m };\n    notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);\n  }\n\n  /* if the message status has changed, we need to invalidate the cached\n   * search results so that any future search will match the current status\n   * of this message and not what it was at the time it was last searched.  */\n  if (e->searched && ((changed != e->changed) || (deleted != m->msg_deleted) ||\n                      (tagged != m->msg_tagged) || (flagged != m->msg_flagged)))\n  {\n    e->searched = false;\n  }\n}\n\n/**\n * mutt_emails_set_flag - Set flag on messages\n * @param m    Mailbox\n * @param ea   Array of Emails to flag\n * @param flag Flag to set, e.g. #MUTT_DELETE\n * @param bf   true: set the flag; false: clear the flag\n */\nvoid mutt_emails_set_flag(struct Mailbox *m, struct EmailArray *ea,\n                          enum MessageType flag, bool bf)\n{\n  if (!m || !ea || ARRAY_EMPTY(ea))\n    return;\n\n  struct Email **ep = NULL;\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    mutt_set_flag(m, e, flag, bf, true);\n  }\n}\n\n/**\n * mutt_thread_set_flag - Set a flag on an entire thread\n * @param m         Mailbox\n * @param e         Email\n * @param flag      Flag to set, e.g. #MUTT_DELETE\n * @param bf        true: set the flag; false: clear the flag\n * @param subthread If true apply to all of the thread\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mutt_thread_set_flag(struct Mailbox *m, struct Email *e,\n                         enum MessageType flag, bool bf, bool subthread)\n{\n  struct MuttThread *start = NULL;\n  struct MuttThread *cur = e->thread;\n\n  if (!mutt_using_threads())\n  {\n    mutt_error(_(\"Threading is not enabled\"));\n    return -1;\n  }\n\n  if (!subthread)\n    while (cur->parent)\n      cur = cur->parent;\n\n  start = cur;\n\n  if (cur->message && (cur != e->thread))\n    mutt_set_flag(m, cur->message, flag, bf, true);\n\n  cur = cur->child;\n  if (!cur)\n    goto done;\n\n  while (true)\n  {\n    if (cur->message && (cur != e->thread))\n      mutt_set_flag(m, cur->message, flag, bf, true);\n\n    if (cur->child)\n    {\n      cur = cur->child;\n    }\n    else if (cur->next)\n    {\n      cur = cur->next;\n    }\n    else\n    {\n      while (!cur->next)\n      {\n        cur = cur->parent;\n        if (cur == start)\n          goto done;\n      }\n      cur = cur->next;\n    }\n  }\ndone:\n  cur = e->thread;\n  if (cur->message)\n    mutt_set_flag(m, cur->message, flag, bf, true);\n  return 0;\n}\n\n/**\n * mw_change_flag - Change the flag on a Message - @ingroup gui_mw\n * @param m  Mailbox\n * @param ea Array of Emails to change\n * @param bf true: set the flag; false: clear the flag\n * @retval  0 Success\n * @retval -1 Failure\n *\n * This function uses the message window.\n *\n * Ask the user which flag they'd like to set/clear, e.g.\n * `Clear flag? (D/N/O/r/!):`\n */\nint mw_change_flag(struct Mailbox *m, struct EmailArray *ea, bool bf)\n{\n  if (!m || !ea || ARRAY_EMPTY(ea))\n    return -1;\n\n  // blank window (0, 0)\n  struct MuttWindow *win = msgwin_new(true);\n  if (!win)\n    return -1;\n\n  char prompt[256] = { 0 };\n  snprintf(prompt, sizeof(prompt),\n           \"%s? (D/N/O/r/*/!): \", bf ? _(\"Set flag\") : _(\"Clear flag\"));\n  msgwin_set_text(win, prompt, MT_COLOR_PROMPT);\n\n  msgcont_push_window(win);\n  struct MuttWindow *old_focus = window_set_focus(win);\n  window_redraw(win);\n\n  struct KeyEvent event = { 0, OP_NULL };\n  do\n  {\n    window_redraw(NULL);\n    event = mutt_getch(GETCH_NO_FLAGS);\n  } while ((event.op == OP_TIMEOUT) || (event.op == OP_REPAINT));\n\n  win = msgcont_pop_window();\n  window_set_focus(old_focus);\n  mutt_window_free(&win);\n\n  if (event.op == OP_ABORT)\n    return -1;\n\n  enum MessageType flag = MUTT_NONE;\n  switch (event.ch)\n  {\n    case 'd':\n    case 'D':\n      if (!bf)\n        mutt_emails_set_flag(m, ea, MUTT_PURGE, bf);\n      flag = MUTT_DELETE;\n      break;\n\n    case 'N':\n    case 'n':\n      flag = MUTT_NEW;\n      break;\n\n    case 'o':\n    case 'O':\n      mutt_emails_set_flag(m, ea, MUTT_READ, !bf);\n      flag = MUTT_OLD;\n      break;\n\n    case 'r':\n    case 'R':\n      flag = MUTT_REPLIED;\n      break;\n\n    case '*':\n      flag = MUTT_TAG;\n      break;\n\n    case '!':\n      flag = MUTT_FLAG;\n      break;\n\n    default:\n      mutt_beep(false);\n      return -1;\n  }\n\n  mutt_emails_set_flag(m, ea, flag, bf);\n  return 0;\n}\n"
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "globals.c",
          "type": "blob",
          "size": 3.4482421875,
          "content": "/**\n * @file\n * Global variables\n *\n * @authors\n * Copyright (C) 2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_globals Global variables\n *\n * Global variables\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stddef.h>\n#include \"mutt/lib.h\"\n\nbool ErrorBufMessage; ///< true if the last message was an error\nchar ErrorBuf[1024];  ///< Copy of the last error message\n\nchar *HomeDir = NULL;       ///< User's home directory\nchar *ShortHostname = NULL; ///< Short version of the hostname\n\nchar *Username = NULL; ///< User's login name\n\nchar *CurrentFolder = NULL; ///< Currently selected mailbox\nchar *LastFolder = NULL;    ///< Previously selected mailbox\n\n/* Lists of strings */\n// clang-format off\nstruct ListHead AlternativeOrderList = STAILQ_HEAD_INITIALIZER(AlternativeOrderList); ///< List of preferred mime types to display\nstruct ListHead AutoViewList         = STAILQ_HEAD_INITIALIZER(AutoViewList);         ///< List of mime types to auto view\nstruct ListHead HeaderOrderList      = STAILQ_HEAD_INITIALIZER(HeaderOrderList);      ///< List of header fields in the order they should be displayed\nstruct ListHead MimeLookupList       = STAILQ_HEAD_INITIALIZER(MimeLookupList);       ///< List of mime types that that shouldn't use the mailcap entry\nstruct ListHead Muttrc               = STAILQ_HEAD_INITIALIZER(Muttrc);               ///< List of config files to read\nstruct ListHead TempAttachmentsList  = STAILQ_HEAD_INITIALIZER(TempAttachmentsList);  ///< List of temporary files for displaying attachments\nstruct ListHead UserHeader           = STAILQ_HEAD_INITIALIZER(UserHeader);           ///< List of custom headers to add to outgoing emails\n// clang-format on\n\n/* pseudo options */\n// clang-format off\n#ifdef USE_AUTOCRYPT\nbool OptAutocryptGpgme;     ///< (pseudo) use Autocrypt context inside ncrypt/crypt_gpgme.c\n#endif\nbool OptDontHandlePgpKeys;  ///< (pseudo) used to extract PGP keys\nbool OptForceRefresh;       ///< (pseudo) refresh even during macros\nbool OptKeepQuiet;          ///< (pseudo) shut up the message and refresh functions while we are executing an external program\nbool OptMsgErr;             ///< (pseudo) used by mutt_error/mutt_message\nbool OptNeedRescore;        ///< (pseudo) set when the 'score' command is used\nbool OptNeedResort;         ///< (pseudo) used to force a re-sort\nbool OptNews;               ///< (pseudo) used to change reader mode\nbool OptNewsSend;           ///< (pseudo) used to change behavior when posting\nbool OptNoCurses;           ///< (pseudo) when sending in batch mode\nbool OptPgpCheckTrust;      ///< (pseudo) used by dlg_pgp()\nbool OptResortInit;         ///< (pseudo) used to force the next resort to be from scratch\nbool OptSortSubthreads;     ///< (pseudo) used when $sort_aux changes\n// clang-format on\n\nchar **EnvList = NULL; ///< Private copy of the environment variables\n"
        },
        {
          "name": "globals.h",
          "type": "blob",
          "size": 3.2216796875,
          "content": "/**\n * @file\n * Global variables\n *\n * @authors\n * Copyright (C) 2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_GLOBALS_H\n#define MUTT_GLOBALS_H\n\n#include \"config.h\"\n#include <stdbool.h>\n\nextern bool ErrorBufMessage; ///< true if the last message was an error\nextern char ErrorBuf[1024];  ///< Copy of the last error message\n\nextern char *HomeDir;        ///< User's home directory\nextern char *ShortHostname;  ///< Short version of the hostname\n\nextern char *Username;       ///< User's login name\n\nextern char *CurrentFolder;  ///< Currently selected mailbox\nextern char *LastFolder;     ///< Previously selected mailbox\n\nextern const char *GitVer;\n\n/* Lists of strings */\nextern struct ListHead AlternativeOrderList; ///< List of preferred mime types to display\nextern struct ListHead AutoViewList;         ///< List of mime types to auto view\nextern struct ListHead HeaderOrderList;      ///< List of header fields in the order they should be displayed\nextern struct ListHead MimeLookupList;       ///< List of mime types that that shouldn't use the mailcap entry\nextern struct ListHead Muttrc;               ///< List of config files to read\nextern struct ListHead TempAttachmentsList;  ///< List of temporary files for displaying attachments\nextern struct ListHead UserHeader;           ///< List of custom headers to add to outgoing emails\n\n/* pseudo options */\n#ifdef USE_AUTOCRYPT\nextern bool OptAutocryptGpgme;      ///< (pseudo) use Autocrypt context inside ncrypt/crypt_gpgme.c\n#endif\nextern bool OptDontHandlePgpKeys;   ///< (pseudo) used to extract PGP keys\nextern bool OptForceRefresh;        ///< (pseudo) refresh even during macros\nextern bool OptKeepQuiet;           ///< (pseudo) shut up the message and refresh functions while we are executing an external program\nextern bool OptMsgErr;              ///< (pseudo) used by mutt_error/mutt_message\nextern bool OptNeedRescore;         ///< (pseudo) set when the 'score' command is used\nextern bool OptNeedResort;          ///< (pseudo) used to force a re-sort\nextern bool OptNews;                ///< (pseudo) used to change reader mode\nextern bool OptNewsSend;            ///< (pseudo) used to change behavior when posting\nextern bool OptNoCurses;            ///< (pseudo) when sending in batch mode\nextern bool OptPgpCheckTrust;       ///< (pseudo) used by dlg_pgp()\nextern bool OptResortInit;          ///< (pseudo) used to force the next resort to be from scratch\nextern bool OptSortSubthreads;      ///< (pseudo) used when $sort_aux changes\n\nextern char **EnvList;              ///< Private copy of the environment variables\n\n#endif /* MUTT_GLOBALS_H */\n"
        },
        {
          "name": "gui",
          "type": "tree",
          "content": null
        },
        {
          "name": "handler.c",
          "type": "blob",
          "size": 53.376953125,
          "content": "/**\n * @file\n * Decide how to display email content\n *\n * @authors\n * Copyright (C) 1996-2000,2002,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2022 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Federico Kircheis <federico.kircheis@gmail.com>\n * Copyright (C) 2018 Reis Radomil\n * Copyright (C) 2019 Ian Zimmerman <itz@no-use.mooo.com>\n * Copyright (C) 2021 David Purton <dcpurton@marshwiggle.net>\n * Copyright (C) 2023 Dennis Schön <mail@dennis-schoen.de>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_handler Decide how to display email content\n *\n * Decide how to display email content\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <iconv.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"handler.h\"\n#include \"attach/lib.h\"\n#include \"key/lib.h\"\n#include \"menu/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"pager/lib.h\"\n#include \"copy.h\"\n#include \"enriched.h\"\n#include \"globals.h\"\n#include \"mailcap.h\"\n#include \"mutt_logging.h\"\n#include \"muttlib.h\"\n#include \"rfc3676.h\"\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\n#define BUFI_SIZE 1000\n#define BUFO_SIZE 2000\n\n#define TXT_HTML 1\n#define TXT_PLAIN 2\n#define TXT_ENRICHED 3\n\n/**\n * @defgroup handler_api Mime Handler API\n *\n * Prototype for a function to handle MIME parts\n *\n * @param b_email Body of the email\n * @param state   State of text being processed\n * @retval 0 Success\n * @retval -1 Error\n */\ntypedef int (*handler_t)(struct Body *b_email, struct State *state);\n\n/**\n * print_part_line - Print a separator for the Mime part\n * @param state State of text being processed\n * @param b_email     Body of the email\n * @param n     Part number for multipart emails (0 otherwise)\n */\nstatic void print_part_line(struct State *state, struct Body *b_email, int n)\n{\n  char length[5] = { 0 };\n  mutt_str_pretty_size(length, sizeof(length), b_email->length);\n  state_mark_attach(state);\n  char *charset = mutt_param_get(&b_email->parameter, \"charset\");\n  if (n == 0)\n  {\n    state_printf(state, _(\"[-- Type: %s/%s%s%s, Encoding: %s, Size: %s --]\\n\"),\n                 TYPE(b_email), b_email->subtype, charset ? \"; charset=\" : \"\",\n                 charset ? charset : \"\", ENCODING(b_email->encoding), length);\n  }\n  else\n  {\n    state_printf(state, _(\"[-- Alternative Type #%d: %s/%s%s%s, Encoding: %s, Size: %s --]\\n\"),\n                 n, TYPE(b_email), b_email->subtype, charset ? \"; charset=\" : \"\",\n                 charset ? charset : \"\", ENCODING(b_email->encoding), length);\n  }\n}\n\n/**\n * convert_to_state - Convert text and write it to a file\n * @param cd     Iconv conversion descriptor\n * @param bufi   Buffer with text to convert\n * @param l      Length of buffer\n * @param state  State to write to\n */\nstatic void convert_to_state(iconv_t cd, char *bufi, size_t *l, struct State *state)\n{\n  char bufo[BUFO_SIZE] = { 0 };\n  const char *ib = NULL;\n  char *ob = NULL;\n  size_t ibl, obl;\n\n  if (!bufi)\n  {\n    if (iconv_t_valid(cd))\n    {\n      ob = bufo;\n      obl = sizeof(bufo);\n      iconv(cd, NULL, NULL, &ob, &obl);\n      if (ob != bufo)\n        state_prefix_put(state, bufo, ob - bufo);\n    }\n    return;\n  }\n\n  if (!iconv_t_valid(cd))\n  {\n    state_prefix_put(state, bufi, *l);\n    *l = 0;\n    return;\n  }\n\n  ib = bufi;\n  ibl = *l;\n  while (true)\n  {\n    ob = bufo;\n    obl = sizeof(bufo);\n    mutt_ch_iconv(cd, &ib, &ibl, &ob, &obl, 0, \"?\", NULL);\n    if (ob == bufo)\n      break;\n    state_prefix_put(state, bufo, ob - bufo);\n  }\n  memmove(bufi, ib, ibl);\n  *l = ibl;\n}\n\n/**\n * decode_xbit - Decode xbit-encoded text\n * @param state  State to work with\n * @param len    Length of text to decode\n * @param istext Mime part is plain text\n * @param cd     Iconv conversion descriptor\n */\nstatic void decode_xbit(struct State *state, long len, bool istext, iconv_t cd)\n{\n  if (!istext)\n  {\n    mutt_file_copy_bytes(state->fp_in, state->fp_out, len);\n    return;\n  }\n\n  state_set_prefix(state);\n\n  int c;\n  char bufi[BUFI_SIZE] = { 0 };\n  size_t l = 0;\n  while (((c = fgetc(state->fp_in)) != EOF) && len--)\n  {\n    if ((c == '\\r') && len)\n    {\n      const int ch = fgetc(state->fp_in);\n      if (ch == '\\n')\n      {\n        c = ch;\n        len--;\n      }\n      else\n      {\n        ungetc(ch, state->fp_in);\n      }\n    }\n\n    bufi[l++] = c;\n    if (l == sizeof(bufi))\n      convert_to_state(cd, bufi, &l, state);\n  }\n\n  convert_to_state(cd, bufi, &l, state);\n  convert_to_state(cd, 0, 0, state);\n\n  state_reset_prefix(state);\n}\n\n/**\n * qp_decode_triple - Decode a quoted-printable triplet\n * @param s State to work with\n * @param d Decoded character\n * @retval 0 Success\n * @retval -1 Error\n */\nstatic int qp_decode_triple(char *s, char *d)\n{\n  /* soft line break */\n  if ((s[0] == '=') && (s[1] == '\\0'))\n    return 1;\n\n  /* quoted-printable triple */\n  if ((s[0] == '=') && isxdigit((unsigned char) s[1]) && isxdigit((unsigned char) s[2]))\n  {\n    *d = (hexval(s[1]) << 4) | hexval(s[2]);\n    return 0;\n  }\n\n  /* something else */\n  return -1;\n}\n\n/**\n * qp_decode_line - Decode a line of quoted-printable text\n * @param dest Buffer for result\n * @param src  Text to decode\n * @param l    Bytes written to buffer\n * @param last Last character of the line\n */\nstatic void qp_decode_line(char *dest, char *src, size_t *l, int last)\n{\n  char *d = NULL, *s = NULL;\n  char c = 0;\n\n  int kind = -1;\n  bool soft = false;\n\n  /* decode the line */\n\n  for (d = dest, s = src; *s;)\n  {\n    switch ((kind = qp_decode_triple(s, &c)))\n    {\n      case 0:\n        *d++ = c;\n        s += 3;\n        break; /* qp triple */\n      case -1:\n        *d++ = *s++;\n        break; /* single character */\n      case 1:\n        soft = true;\n        s++;\n        break; /* soft line break */\n    }\n  }\n\n  if (!soft && (last == '\\n'))\n  {\n    /* neither \\r nor \\n as part of line-terminating CRLF\n     * may be qp-encoded, so remove \\r and \\n-terminate;\n     * see RFC2045, sect. 6.7, (1): General 8bit representation */\n    if ((kind == 0) && (c == '\\r'))\n      *(d - 1) = '\\n';\n    else\n      *d++ = '\\n';\n  }\n\n  *d = '\\0';\n  *l = d - dest;\n}\n\n/**\n * decode_quoted - Decode an attachment encoded with quoted-printable\n * @param state  State to work with\n * @param len    Length of text to decode\n * @param istext Mime part is plain text\n * @param cd     Iconv conversion descriptor\n *\n * Why doesn't this overflow any buffers? First, it's guaranteed that the\n * length of a line grows when you _en_-code it to quoted-printable. That\n * means that we always can store the result in a buffer of at most the _same_\n * size.\n *\n * Now, we don't special-case if the line we read with fgets() isn't\n * terminated. We don't care about this, since 256 > 78, so corrupted input\n * will just be corrupted a bit more. That implies that 256+1 bytes are\n * always sufficient to store the result of qp_decode_line.\n *\n * Finally, at soft line breaks, some part of a multibyte character may have\n * been left over by convert_to_state(). This shouldn't be more than 6\n * characters, so 256+7 should be sufficient memory to store the decoded\n * data.\n *\n * Just to make sure that I didn't make some off-by-one error above, we just\n * use 512 for the target buffer's size.\n */\nstatic void decode_quoted(struct State *state, long len, bool istext, iconv_t cd)\n{\n  char line[256] = { 0 };\n  char decline[512] = { 0 };\n  size_t l = 0;\n  size_t l3;\n\n  if (istext)\n    state_set_prefix(state);\n\n  while (len > 0)\n  {\n    /* It's ok to use a fixed size buffer for input, even if the line turns\n     * out to be longer than this.  Just process the line in chunks.  This\n     * really shouldn't happen according the MIME spec, since Q-P encoded\n     * lines are at most 76 characters, but we should be liberal about what\n     * we accept.  */\n    if (!fgets(line, MIN((ssize_t) sizeof(line), len + 1), state->fp_in))\n      break;\n\n    size_t linelen = strlen(line);\n    len -= linelen;\n\n    /* inspect the last character we read so we can tell if we got the\n     * entire line.  */\n    const int last = (linelen != 0) ? line[linelen - 1] : 0;\n\n    /* chop trailing whitespace if we got the full line */\n    if (last == '\\n')\n    {\n      while ((linelen > 0) && isspace(line[linelen - 1]))\n        linelen--;\n      line[linelen] = '\\0';\n    }\n\n    /* decode and do character set conversion */\n    qp_decode_line(decline + l, line, &l3, last);\n    l += l3;\n    convert_to_state(cd, decline, &l, state);\n  }\n\n  convert_to_state(cd, 0, 0, state);\n  state_reset_prefix(state);\n}\n\n/**\n * decode_byte - Decode a uuencoded byte\n * @param ch Character to decode\n * @retval num Decoded value\n */\nstatic unsigned char decode_byte(char ch)\n{\n  if ((ch < 32) || (ch > 95))\n    return 0;\n  return ch - 32;\n}\n\n/**\n * decode_uuencoded - Decode uuencoded text\n * @param state      State to work with\n * @param len    Length of text to decode\n * @param istext Mime part is plain text\n * @param cd     Iconv conversion descriptor\n */\nstatic void decode_uuencoded(struct State *state, long len, bool istext, iconv_t cd)\n{\n  char tmps[128] = { 0 };\n  char *pt = NULL;\n  char bufi[BUFI_SIZE] = { 0 };\n  size_t k = 0;\n\n  if (istext)\n    state_set_prefix(state);\n\n  while (len > 0)\n  {\n    if (!fgets(tmps, sizeof(tmps), state->fp_in))\n      goto cleanup;\n    len -= mutt_str_len(tmps);\n    if (mutt_str_startswith(tmps, \"begin \"))\n      break;\n  }\n  while (len > 0)\n  {\n    if (!fgets(tmps, sizeof(tmps), state->fp_in))\n      goto cleanup;\n    len -= mutt_str_len(tmps);\n    if (mutt_str_startswith(tmps, \"end\"))\n      break;\n    pt = tmps;\n    const unsigned char linelen = decode_byte(*pt);\n    pt++;\n    for (unsigned char c = 0; (c < linelen) && *pt;)\n    {\n      for (char l = 2; (l <= 6) && pt[0] && pt[1]; l += 2)\n      {\n        char out = decode_byte(*pt) << l;\n        pt++;\n        out |= (decode_byte(*pt) >> (6 - l));\n        bufi[k++] = out;\n        c++;\n        if (c == linelen)\n          break;\n      }\n      convert_to_state(cd, bufi, &k, state);\n      pt++;\n    }\n  }\n\ncleanup:\n  convert_to_state(cd, bufi, &k, state);\n  convert_to_state(cd, 0, 0, state);\n\n  state_reset_prefix(state);\n}\n\n/**\n * is_mmnoask - Metamail compatibility: should the attachment be autoviewed?\n * @param buf Mime type, e.g. 'text/plain'\n * @retval true Metamail \"no ask\" is true\n *\n * Test if the `MM_NOASK` environment variable should allow autoviewing of the\n * attachment.\n *\n * @note If `MM_NOASK=1` then the function will automatically return true.\n */\nstatic bool is_mmnoask(const char *buf)\n{\n  const char *val = mutt_str_getenv(\"MM_NOASK\");\n  if (!val)\n    return false;\n\n  char *p = NULL;\n  char tmp[1024] = { 0 };\n  char *q = NULL;\n\n  if (mutt_str_equal(val, \"1\"))\n    return true;\n\n  mutt_str_copy(tmp, val, sizeof(tmp));\n  p = tmp;\n\n  while ((p = strtok(p, \",\")))\n  {\n    q = strrchr(p, '/');\n    if (q)\n    {\n      if (q[1] == '*')\n      {\n        if (mutt_istrn_equal(buf, p, q - p))\n          return true;\n      }\n      else\n      {\n        if (mutt_istr_equal(buf, p))\n          return true;\n      }\n    }\n    else\n    {\n      const size_t plen = mutt_istr_startswith(buf, p);\n      if ((plen != 0) && (buf[plen] == '/'))\n        return true;\n    }\n\n    p = NULL;\n  }\n\n  return false;\n}\n\n/**\n * is_autoview - Should email body be filtered by mailcap\n * @param b Body of the email\n * @retval 1 body part should be filtered by a mailcap entry prior to viewing inline\n * @retval 0 otherwise\n */\nstatic bool is_autoview(struct Body *b)\n{\n  char type[256] = { 0 };\n  bool is_av = false;\n\n  snprintf(type, sizeof(type), \"%s/%s\", TYPE(b), b->subtype);\n\n  const bool c_implicit_auto_view = cs_subset_bool(NeoMutt->sub, \"implicit_auto_view\");\n  if (c_implicit_auto_view)\n  {\n    /* $implicit_auto_view is essentially the same as \"auto_view *\" */\n    is_av = true;\n  }\n  else\n  {\n    /* determine if this type is on the user's auto_view list */\n    mutt_check_lookup_list(b, type, sizeof(type));\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &AutoViewList, entries)\n    {\n      int i = mutt_str_len(np->data);\n      i--;\n      if (((i > 0) && (np->data[i - 1] == '/') && (np->data[i] == '*') &&\n           mutt_istrn_equal(type, np->data, i)) ||\n          mutt_istr_equal(type, np->data))\n      {\n        is_av = true;\n        break;\n      }\n    }\n\n    if (is_mmnoask(type))\n      is_av = true;\n  }\n\n  /* determine if there is a mailcap entry suitable for auto_view\n   *\n   * @warning type is altered by this call as a result of 'mime_lookup' support */\n  if (is_av)\n    return mailcap_lookup(b, type, sizeof(type), NULL, MUTT_MC_AUTOVIEW);\n\n  return false;\n}\n\n/**\n * autoview_handler - Handler for autoviewable attachments - Implements ::handler_t - @ingroup handler_api\n */\nstatic int autoview_handler(struct Body *b_email, struct State *state)\n{\n  struct MailcapEntry *entry = mailcap_entry_new();\n  char buf[1024] = { 0 };\n  char type[256] = { 0 };\n  struct Buffer *cmd = buf_pool_get();\n  struct Buffer *tempfile = buf_pool_get();\n  char *fname = NULL;\n  FILE *fp_in = NULL;\n  FILE *fp_out = NULL;\n  FILE *fp_err = NULL;\n  pid_t pid;\n  int rc = 0;\n\n  snprintf(type, sizeof(type), \"%s/%s\", TYPE(b_email), b_email->subtype);\n  mailcap_lookup(b_email, type, sizeof(type), entry, MUTT_MC_AUTOVIEW);\n\n  fname = mutt_str_dup(b_email->filename);\n  mutt_file_sanitize_filename(fname, true);\n  mailcap_expand_filename(entry->nametemplate, fname, tempfile);\n  FREE(&fname);\n\n  if (entry->command)\n  {\n    buf_strcpy(cmd, entry->command);\n\n    /* mailcap_expand_command returns 0 if the file is required */\n    bool piped = mailcap_expand_command(b_email, buf_string(tempfile), type, cmd);\n\n    if (state->flags & STATE_DISPLAY)\n    {\n      state_mark_attach(state);\n      state_printf(state, _(\"[-- Autoview using %s --]\\n\"), buf_string(cmd));\n      mutt_message(_(\"Invoking autoview command: %s\"), buf_string(cmd));\n    }\n\n    fp_in = mutt_file_fopen(buf_string(tempfile), \"w+\");\n    if (!fp_in)\n    {\n      mutt_perror(\"fopen\");\n      mailcap_entry_free(&entry);\n      rc = -1;\n      goto cleanup;\n    }\n\n    mutt_file_copy_bytes(state->fp_in, fp_in, b_email->length);\n\n    if (piped)\n    {\n      unlink(buf_string(tempfile));\n      fflush(fp_in);\n      rewind(fp_in);\n      pid = filter_create_fd(buf_string(cmd), NULL, &fp_out, &fp_err,\n                             fileno(fp_in), -1, -1, EnvList);\n    }\n    else\n    {\n      mutt_file_fclose(&fp_in);\n      pid = filter_create(buf_string(cmd), NULL, &fp_out, &fp_err, EnvList);\n    }\n\n    if (pid < 0)\n    {\n      mutt_perror(_(\"Can't create filter\"));\n      if (state->flags & STATE_DISPLAY)\n      {\n        state_mark_attach(state);\n        state_printf(state, _(\"[-- Can't run %s --]\\n\"), buf_string(cmd));\n      }\n      rc = -1;\n      goto bail;\n    }\n\n    if (state->prefix)\n    {\n      /* Remove ansi and formatting from autoview output in replies only.  The\n       * user may want to see the formatting in the pager, but it shouldn't be\n       * in their quoted reply text too.  */\n      struct Buffer *stripped = buf_pool_get();\n      while (fgets(buf, sizeof(buf), fp_out))\n      {\n        buf_strip_formatting(stripped, buf, false);\n        state_puts(state, state->prefix);\n        state_puts(state, buf_string(stripped));\n      }\n      buf_pool_release(&stripped);\n\n      /* check for data on stderr */\n      if (fgets(buf, sizeof(buf), fp_err))\n      {\n        if (state->flags & STATE_DISPLAY)\n        {\n          state_mark_attach(state);\n          state_printf(state, _(\"[-- Autoview stderr of %s --]\\n\"), buf_string(cmd));\n        }\n\n        state_puts(state, state->prefix);\n        state_puts(state, buf);\n        while (fgets(buf, sizeof(buf), fp_err))\n        {\n          state_puts(state, state->prefix);\n          state_puts(state, buf);\n        }\n      }\n    }\n    else\n    {\n      mutt_file_copy_stream(fp_out, state->fp_out);\n      /* Check for stderr messages */\n      if (fgets(buf, sizeof(buf), fp_err))\n      {\n        if (state->flags & STATE_DISPLAY)\n        {\n          state_mark_attach(state);\n          state_printf(state, _(\"[-- Autoview stderr of %s --]\\n\"), buf_string(cmd));\n        }\n\n        state_puts(state, buf);\n        mutt_file_copy_stream(fp_err, state->fp_out);\n      }\n    }\n\n  bail:\n    mutt_file_fclose(&fp_out);\n    mutt_file_fclose(&fp_err);\n\n    filter_wait(pid);\n    if (piped)\n      mutt_file_fclose(&fp_in);\n    else\n      mutt_file_unlink(buf_string(tempfile));\n\n    if (state->flags & STATE_DISPLAY)\n      mutt_clear_error();\n  }\n\ncleanup:\n  mailcap_entry_free(&entry);\n\n  buf_pool_release(&cmd);\n  buf_pool_release(&tempfile);\n\n  return rc;\n}\n\n/**\n * text_plain_handler - Handler for plain text - Implements ::handler_t - @ingroup handler_api\n * @retval 0 Always\n *\n * When generating format=flowed ($text_flowed is set) from format=fixed, strip\n * all trailing spaces to improve interoperability; if $text_flowed is unset,\n * simply verbatim copy input.\n */\nstatic int text_plain_handler(struct Body *b_email, struct State *state)\n{\n  char *buf = NULL;\n  size_t sz = 0;\n\n  const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n  while ((buf = mutt_file_read_line(buf, &sz, state->fp_in, NULL, MUTT_RL_NO_FLAGS)))\n  {\n    if (!mutt_str_equal(buf, \"-- \") && c_text_flowed)\n    {\n      size_t len = mutt_str_len(buf);\n      while ((len > 0) && (buf[len - 1] == ' '))\n        buf[--len] = '\\0';\n    }\n    if (state->prefix)\n      state_puts(state, state->prefix);\n    state_puts(state, buf);\n    state_putc(state, '\\n');\n  }\n\n  FREE(&buf);\n  return 0;\n}\n\n/**\n * message_handler - Handler for message/rfc822 body parts - Implements ::handler_t - @ingroup handler_api\n */\nstatic int message_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *b = NULL;\n  LOFF_T off_start;\n  int rc = 0;\n\n  off_start = ftello(state->fp_in);\n  if (off_start < 0)\n    return -1;\n\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    b = mutt_body_new();\n    b->length = mutt_file_get_size_fp(state->fp_in);\n    b->parts = mutt_rfc822_parse_message(state->fp_in, b);\n  }\n  else\n  {\n    b = b_email;\n  }\n\n  if (b->parts)\n  {\n    CopyHeaderFlags chflags = CH_DECODE | CH_FROM;\n    const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n    if ((state->flags & STATE_WEED) ||\n        ((state->flags & (STATE_DISPLAY | STATE_PRINTING)) && c_weed))\n    {\n      chflags |= CH_WEED | CH_REORDER;\n    }\n    if (state->prefix)\n      chflags |= CH_PREFIX;\n    if (state->flags & STATE_DISPLAY)\n      chflags |= CH_DISPLAY;\n\n    mutt_copy_hdr(state->fp_in, state->fp_out, off_start, b->parts->offset,\n                  chflags, state->prefix, 0);\n\n    if (state->prefix)\n      state_puts(state, state->prefix);\n    state_putc(state, '\\n');\n\n    rc = mutt_body_handler(b->parts, state);\n  }\n\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    mutt_body_free(&b);\n  }\n\n  return rc;\n}\n\n/**\n * external_body_handler - Handler for external-body emails - Implements ::handler_t - @ingroup handler_api\n */\nstatic int external_body_handler(struct Body *b_email, struct State *state)\n{\n  const char *str = NULL;\n  char strbuf[1024] = { 0 };\n\n  const char *access_type = mutt_param_get(&b_email->parameter, \"access-type\");\n  if (!access_type)\n  {\n    if (state->flags & STATE_DISPLAY)\n    {\n      state_mark_attach(state);\n      state_puts(state, _(\"[-- Error: message/external-body has no access-type parameter --]\\n\"));\n      return 0;\n    }\n    else\n    {\n      return -1;\n    }\n  }\n\n  const char *expiration = mutt_param_get(&b_email->parameter, \"expiration\");\n  time_t expire;\n  if (expiration)\n    expire = mutt_date_parse_date(expiration, NULL);\n  else\n    expire = -1;\n\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n  if (mutt_istr_equal(access_type, \"x-mutt-deleted\"))\n  {\n    if (state->flags & (STATE_DISPLAY | STATE_PRINTING))\n    {\n      char pretty_size[10] = { 0 };\n      char *length = mutt_param_get(&b_email->parameter, \"length\");\n      if (length)\n      {\n        long size = strtol(length, NULL, 10);\n        mutt_str_pretty_size(pretty_size, sizeof(pretty_size), size);\n        if (expire != -1)\n        {\n          str = ngettext(\n              /* L10N: If the translation of this string is a multi line string, then\n                 each line should start with \"[-- \" and end with \" --]\".\n                 The first \"%s/%s\" is a MIME type, e.g. \"text/plain\". The last %s\n                 expands to a date as returned by `mutt_date_parse_date()`.\n\n                 Note: The size argument printed is not the actual number as passed\n                 to gettext but the prettified version, e.g. size = 2048 will be\n                 printed as 2K.  Your language might be sensitive to that: For\n                 example although '1K' and '1024' represent the same number your\n                 language might inflect the noun 'byte' differently.\n\n                 Sadly, we can't do anything about that at the moment besides\n                 passing the precise size in bytes. If you are interested the\n                 function responsible for the prettification is\n                 mutt_str_pretty_size() in muttlib.c */\n              \"[-- This %s/%s attachment (size %s byte) has been deleted --]\\n\"\n              \"[-- on %s --]\\n\",\n              \"[-- This %s/%s attachment (size %s bytes) has been deleted --]\\n\"\n              \"[-- on %s --]\\n\",\n              size);\n        }\n        else\n        {\n          str = ngettext(\n              /* L10N: If the translation of this string is a multi line string, then\n                 each line should start with \"[-- \" and end with \" --]\".\n                 The first \"%s/%s\" is a MIME type, e.g. \"text/plain\".\n\n                 Note: The size argument printed is not the actual number as passed\n                 to gettext but the prettified version, e.g. size = 2048 will be\n                 printed as 2K.  Your language might be sensitive to that: For\n                 example although '1K' and '1024' represent the same number your\n                 language might inflect the noun 'byte' differently.\n\n                 Sadly, we can't do anything about that at the moment besides\n                 passing the precise size in bytes. If you are interested the\n                 function responsible for the prettification is\n                 mutt_str_pretty_size() in muttlib.c  */\n              \"[-- This %s/%s attachment (size %s byte) has been deleted --]\\n\",\n              \"[-- This %s/%s attachment (size %s bytes) has been deleted --]\\n\", size);\n        }\n      }\n      else\n      {\n        pretty_size[0] = '\\0';\n        if (expire != -1)\n        {\n          /* L10N: If the translation of this string is a multi line string, then\n             each line should start with \"[-- \" and end with \" --]\".\n             The first \"%s/%s\" is a MIME type, e.g. \"text/plain\". The last %s\n             expands to a date as returned by `mutt_date_parse_date()`.\n\n             Caution: Argument three %3$ is also defined but should not be used\n             in this translation!  */\n          str = _(\"[-- This %s/%s attachment has been deleted --]\\n[-- on %4$s --]\\n\");\n        }\n        else\n        {\n          /* L10N: If the translation of this string is a multi line string, then\n             each line should start with \"[-- \" and end with \" --]\".\n             The first \"%s/%s\" is a MIME type, e.g. \"text/plain\". */\n          str = _(\"[-- This %s/%s attachment has been deleted --]\\n\");\n        }\n      }\n\n      snprintf(strbuf, sizeof(strbuf), str, TYPE(b_email->parts),\n               b_email->parts->subtype, pretty_size, expiration);\n      state_attach_puts(state, strbuf);\n      if (b_email->parts->filename)\n      {\n        state_mark_attach(state);\n        state_printf(state, _(\"[-- name: %s --]\\n\"), b_email->parts->filename);\n      }\n\n      CopyHeaderFlags chflags = CH_DECODE;\n      if (c_weed)\n        chflags |= CH_WEED | CH_REORDER;\n\n      mutt_copy_hdr(state->fp_in, state->fp_out, ftello(state->fp_in),\n                    b_email->parts->offset, chflags, NULL, 0);\n    }\n  }\n  else if (expiration && (expire < mutt_date_now()))\n  {\n    if (state->flags & STATE_DISPLAY)\n    {\n      /* L10N: If the translation of this string is a multi line string, then\n         each line should start with \"[-- \" and end with \" --]\".\n         The \"%s/%s\" is a MIME type, e.g. \"text/plain\". */\n      snprintf(strbuf, sizeof(strbuf),\n               _(\"[-- This %s/%s attachment is not included, --]\\n[-- and the indicated external source has expired --]\\n\"),\n               TYPE(b_email->parts), b_email->parts->subtype);\n      state_attach_puts(state, strbuf);\n\n      CopyHeaderFlags chflags = CH_DECODE | CH_DISPLAY;\n      if (c_weed)\n        chflags |= CH_WEED | CH_REORDER;\n\n      mutt_copy_hdr(state->fp_in, state->fp_out, ftello(state->fp_in),\n                    b_email->parts->offset, chflags, NULL, 0);\n    }\n  }\n  else\n  {\n    if (state->flags & STATE_DISPLAY)\n    {\n      /* L10N: If the translation of this string is a multi line string, then\n         each line should start with \"[-- \" and end with \" --]\".\n         The \"%s/%s\" is a MIME type, e.g. \"text/plain\".  The %s after\n         access-type is an access-type as defined by the MIME RFCs, e.g. \"FTP\",\n         \"LOCAL-FILE\", \"MAIL-SERVER\". */\n      snprintf(strbuf, sizeof(strbuf),\n               _(\"[-- This %s/%s attachment is not included, --]\\n[-- and the indicated access-type %s is unsupported --]\\n\"),\n               TYPE(b_email->parts), b_email->parts->subtype, access_type);\n      state_attach_puts(state, strbuf);\n\n      CopyHeaderFlags chflags = CH_DECODE | CH_DISPLAY;\n      if (c_weed)\n        chflags |= CH_WEED | CH_REORDER;\n\n      mutt_copy_hdr(state->fp_in, state->fp_out, ftello(state->fp_in),\n                    b_email->parts->offset, chflags, NULL, 0);\n    }\n  }\n\n  return 0;\n}\n\n/**\n * alternative_handler - Handler for multipart alternative emails - Implements ::handler_t - @ingroup handler_api\n */\nstatic int alternative_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *const head = b_email;\n  struct Body *choice = NULL;\n  struct Body *b = NULL;\n  bool mustfree = false;\n  int rc = 0;\n\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    mustfree = true;\n    b = mutt_body_new();\n    b->length = mutt_file_get_size_fp(state->fp_in);\n    b->parts = mutt_parse_multipart(state->fp_in,\n                                    mutt_param_get(&b_email->parameter, \"boundary\"),\n                                    b->length,\n                                    mutt_istr_equal(\"digest\", b_email->subtype));\n  }\n  else\n  {\n    b = b_email;\n  }\n\n  b_email = b;\n\n  /* First, search list of preferred types */\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, &AlternativeOrderList, entries)\n  {\n    int btlen; /* length of basetype */\n    bool wild; /* do we have a wildcard to match all subtypes? */\n\n    char *c = strchr(np->data, '/');\n    if (c)\n    {\n      wild = ((c[1] == '*') && (c[2] == '\\0'));\n      btlen = c - np->data;\n    }\n    else\n    {\n      wild = true;\n      btlen = mutt_str_len(np->data);\n    }\n\n    if (b_email->parts)\n      b = b_email->parts;\n    else\n      b = b_email;\n    while (b)\n    {\n      const char *bt = TYPE(b);\n      if (mutt_istrn_equal(bt, np->data, btlen) && (bt[btlen] == 0))\n      {\n        /* the basetype matches */\n        if (wild || mutt_istr_equal(np->data + btlen + 1, b->subtype))\n        {\n          choice = b;\n        }\n      }\n      b = b->next;\n    }\n\n    if (choice)\n      break;\n  }\n\n  /* Next, look for an autoviewable type */\n  if (!choice)\n  {\n    if (b_email->parts)\n      b = b_email->parts;\n    else\n      b = b_email;\n    while (b)\n    {\n      if (is_autoview(b))\n        choice = b;\n      b = b->next;\n    }\n  }\n\n  /* Then, look for a text entry */\n  if (!choice)\n  {\n    if (b_email->parts)\n      b = b_email->parts;\n    else\n      b = b_email;\n    int type = 0;\n    while (b)\n    {\n      if (b->type == TYPE_TEXT)\n      {\n        if (mutt_istr_equal(\"plain\", b->subtype) && (type <= TXT_PLAIN))\n        {\n          choice = b;\n          type = TXT_PLAIN;\n        }\n        else if (mutt_istr_equal(\"enriched\", b->subtype) && (type <= TXT_ENRICHED))\n        {\n          choice = b;\n          type = TXT_ENRICHED;\n        }\n        else if (mutt_istr_equal(\"html\", b->subtype) && (type <= TXT_HTML))\n        {\n          choice = b;\n          type = TXT_HTML;\n        }\n      }\n      b = b->next;\n    }\n  }\n\n  /* Finally, look for other possibilities */\n  if (!choice)\n  {\n    if (b_email->parts)\n      b = b_email->parts;\n    else\n      b = b_email;\n    while (b)\n    {\n      if (mutt_can_decode(b))\n        choice = b;\n      b = b->next;\n    }\n  }\n\n  if (choice)\n  {\n    const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n    if (state->flags & STATE_DISPLAY && !c_weed &&\n        mutt_file_seek(state->fp_in, choice->hdr_offset, SEEK_SET))\n    {\n      mutt_file_copy_bytes(state->fp_in, state->fp_out, choice->offset - choice->hdr_offset);\n    }\n\n    const char *const c_show_multipart_alternative = cs_subset_string(NeoMutt->sub, \"show_multipart_alternative\");\n    if (mutt_str_equal(\"info\", c_show_multipart_alternative))\n    {\n      print_part_line(state, choice, 0);\n    }\n    mutt_body_handler(choice, state);\n\n    /* Let it flow back to the main part */\n    head->nowrap = choice->nowrap;\n    choice->nowrap = false;\n\n    if (mutt_str_equal(\"info\", c_show_multipart_alternative))\n    {\n      if (b_email->parts)\n        b = b_email->parts;\n      else\n        b = b_email;\n      int count = 0;\n      while (b)\n      {\n        if (choice != b)\n        {\n          count += 1;\n          if (count == 1)\n            state_putc(state, '\\n');\n\n          print_part_line(state, b, count);\n        }\n        b = b->next;\n      }\n    }\n  }\n  else if (state->flags & STATE_DISPLAY)\n  {\n    /* didn't find anything that we could display! */\n    state_mark_attach(state);\n    state_puts(state, _(\"[-- Error: Could not display any parts of Multipart/Alternative --]\\n\"));\n    rc = -1;\n  }\n\n  if (mustfree)\n    mutt_body_free(&b_email);\n\n  return rc;\n}\n\n/**\n * multilingual_handler - Handler for multi-lingual emails - Implements ::handler_t - @ingroup handler_api\n * @retval 0 Always\n */\nstatic int multilingual_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *b = NULL;\n  bool mustfree = false;\n  int rc = 0;\n\n  mutt_debug(LL_DEBUG2, \"RFC8255 >> entering in handler multilingual handler\\n\");\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    mustfree = true;\n    b = mutt_body_new();\n    b->length = mutt_file_get_size_fp(state->fp_in);\n    b->parts = mutt_parse_multipart(state->fp_in,\n                                    mutt_param_get(&b_email->parameter, \"boundary\"),\n                                    b->length,\n                                    mutt_istr_equal(\"digest\", b_email->subtype));\n  }\n  else\n  {\n    b = b_email;\n  }\n\n  b_email = b;\n\n  if (b_email->parts)\n    b = b_email->parts;\n  else\n    b = b_email;\n\n  struct Body *choice = NULL;\n  struct Body *first_part = NULL;\n  struct Body *zxx_part = NULL;\n  struct ListNode *np = NULL;\n\n  while (b)\n  {\n    if (mutt_can_decode(b))\n    {\n      first_part = b;\n      break;\n    }\n    b = b->next;\n  }\n\n  const struct Slist *c_preferred_languages = cs_subset_slist(NeoMutt->sub, \"preferred_languages\");\n  if (c_preferred_languages)\n  {\n    struct Buffer *langs = buf_pool_get();\n    cs_subset_str_string_get(NeoMutt->sub, \"preferred_languages\", langs);\n    mutt_debug(LL_DEBUG2, \"RFC8255 >> preferred_languages set in config to '%s'\\n\",\n               buf_string(langs));\n    buf_pool_release(&langs);\n\n    STAILQ_FOREACH(np, &c_preferred_languages->head, entries)\n    {\n      while (b)\n      {\n        if (mutt_can_decode(b))\n        {\n          if (b->language && mutt_str_equal(\"zxx\", b->language))\n            zxx_part = b;\n\n          mutt_debug(LL_DEBUG2, \"RFC8255 >> comparing configuration preferred_language='%s' to mail part content-language='%s'\\n\",\n                     np->data, b->language);\n          if (b->language && mutt_str_equal(np->data, b->language))\n          {\n            mutt_debug(LL_DEBUG2, \"RFC8255 >> preferred_language='%s' matches content-language='%s' >> part selected to be displayed\\n\",\n                       np->data, b->language);\n            choice = b;\n            break;\n          }\n        }\n\n        b = b->next;\n      }\n\n      if (choice)\n        break;\n\n      if (b_email->parts)\n        b = b_email->parts;\n      else\n        b = b_email;\n    }\n  }\n\n  if (choice)\n  {\n    mutt_body_handler(choice, state);\n  }\n  else\n  {\n    if (zxx_part)\n      mutt_body_handler(zxx_part, state);\n    else\n      mutt_body_handler(first_part, state);\n  }\n\n  if (mustfree)\n    mutt_body_free(&b_email);\n\n  return rc;\n}\n\n/**\n * multipart_handler - Handler for multipart emails - Implements ::handler_t - @ingroup handler_api\n */\nstatic int multipart_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *b = NULL, *p = NULL;\n  int count;\n  int rc = 0;\n\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    b = mutt_body_new();\n    b->length = mutt_file_get_size_fp(state->fp_in);\n    b->parts = mutt_parse_multipart(state->fp_in,\n                                    mutt_param_get(&b_email->parameter, \"boundary\"),\n                                    b->length,\n                                    mutt_istr_equal(\"digest\", b_email->subtype));\n  }\n  else\n  {\n    b = b_email;\n  }\n\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n  const bool c_include_only_first = cs_subset_bool(NeoMutt->sub, \"include_only_first\");\n\n  for (p = b->parts, count = 1; p; p = p->next, count++)\n  {\n    if (state->flags & STATE_DISPLAY)\n    {\n      state_mark_attach(state);\n      if (p->description || p->filename || p->form_name)\n      {\n        /* L10N: %s is the attachment description, filename or form_name. */\n        state_printf(state, _(\"[-- Attachment #%d: %s --]\\n\"), count,\n                     p->description ? p->description :\n                     p->filename    ? p->filename :\n                                      p->form_name);\n      }\n      else\n      {\n        state_printf(state, _(\"[-- Attachment #%d --]\\n\"), count);\n      }\n      print_part_line(state, p, 0);\n      if (c_weed)\n      {\n        state_putc(state, '\\n');\n      }\n      else if (mutt_file_seek(state->fp_in, p->hdr_offset, SEEK_SET))\n      {\n        mutt_file_copy_bytes(state->fp_in, state->fp_out, p->offset - p->hdr_offset);\n      }\n    }\n\n    rc = mutt_body_handler(p, state);\n    state_putc(state, '\\n');\n\n    if (rc != 0)\n    {\n      mutt_error(_(\"One or more parts of this message could not be displayed\"));\n      mutt_debug(LL_DEBUG1, \"Failed on attachment #%d, type %s/%s\\n\", count,\n                 TYPE(p), NONULL(p->subtype));\n    }\n\n    if ((state->flags & STATE_REPLYING) && c_include_only_first && (state->flags & STATE_FIRSTDONE))\n    {\n      break;\n    }\n  }\n\n  if ((b_email->encoding == ENC_BASE64) || (b_email->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b_email->encoding == ENC_UUENCODED))\n  {\n    mutt_body_free(&b);\n  }\n\n  /* make failure of a single part non-fatal */\n  if (rc < 0)\n    rc = 1;\n  return rc;\n}\n\n/**\n * run_decode_and_handler - Run an appropriate decoder for an email\n * @param b         Body of the email\n * @param state         State to work with\n * @param handler   Callback function to process the content - Implements ::handler_t\n * @param plaintext Is the content in plain text\n * @retval 0 Success\n * @retval -1 Error\n */\nstatic int run_decode_and_handler(struct Body *b, struct State *state,\n                                  handler_t handler, bool plaintext)\n{\n  const char *save_prefix = NULL;\n  FILE *fp = NULL;\n  size_t tmplength = 0;\n  LOFF_T tmpoffset = 0;\n  int decode = 0;\n  int rc = 0;\n#ifndef USE_FMEMOPEN\n  struct Buffer *tempfile = NULL;\n#endif\n\n  if (!mutt_file_seek(state->fp_in, b->offset, SEEK_SET))\n  {\n    return -1;\n  }\n\n#ifdef USE_FMEMOPEN\n  char *temp = NULL;\n  size_t tempsize = 0;\n#endif\n\n  /* see if we need to decode this part before processing it */\n  if ((b->encoding == ENC_BASE64) || (b->encoding == ENC_QUOTED_PRINTABLE) ||\n      (b->encoding == ENC_UUENCODED) || (plaintext || mutt_is_text_part(b)))\n  /* text subtypes may require character set conversion even with 8bit encoding */\n  {\n    const int orig_type = b->type;\n    if (plaintext)\n    {\n      b->type = TYPE_TEXT;\n    }\n    else\n    {\n      /* decode to a tempfile, saving the original destination */\n      fp = state->fp_out;\n#ifdef USE_FMEMOPEN\n      state->fp_out = open_memstream(&temp, &tempsize);\n      if (!state->fp_out)\n      {\n        mutt_error(_(\"Unable to open 'memory stream'\"));\n        mutt_debug(LL_DEBUG1, \"Can't open 'memory stream'\\n\");\n        return -1;\n      }\n#else\n      tempfile = buf_pool_get();\n      buf_mktemp(tempfile);\n      state->fp_out = mutt_file_fopen(buf_string(tempfile), \"w\");\n      if (!state->fp_out)\n      {\n        mutt_error(_(\"Unable to open temporary file\"));\n        mutt_debug(LL_DEBUG1, \"Can't open %s\\n\", buf_string(tempfile));\n        buf_pool_release(&tempfile);\n        return -1;\n      }\n#endif\n      /* decoding the attachment changes the size and offset, so save a copy\n       * of the \"real\" values now, and restore them after processing */\n      tmplength = b->length;\n      tmpoffset = b->offset;\n\n      /* if we are decoding binary bodies, we don't want to prefix each\n       * line with the prefix or else the data will get corrupted.  */\n      save_prefix = state->prefix;\n      state->prefix = NULL;\n\n      decode = 1;\n    }\n\n    mutt_decode_attachment(b, state);\n\n    if (decode)\n    {\n      b->length = ftello(state->fp_out);\n      b->offset = 0;\n#ifdef USE_FMEMOPEN\n      /* When running under torify, mutt_file_fclose(&state->fp_out) does not seem to\n       * update tempsize. On the other hand, fflush does.  See\n       * https://github.com/neomutt/neomutt/issues/440 */\n      fflush(state->fp_out);\n#endif\n      mutt_file_fclose(&state->fp_out);\n\n      /* restore final destination and substitute the tempfile for input */\n      state->fp_out = fp;\n      fp = state->fp_in;\n#ifdef USE_FMEMOPEN\n      if (tempsize)\n      {\n        state->fp_in = fmemopen(temp, tempsize, \"r\");\n      }\n      else\n      { /* fmemopen can't handle zero-length buffers */\n        state->fp_in = mutt_file_fopen(\"/dev/null\", \"r\");\n      }\n      if (!state->fp_in)\n      {\n        mutt_perror(_(\"failed to re-open 'memory stream'\"));\n        FREE(&temp);\n        return -1;\n      }\n#else\n      state->fp_in = mutt_file_fopen(buf_string(tempfile), \"r\");\n      unlink(buf_string(tempfile));\n      buf_pool_release(&tempfile);\n#endif\n      /* restore the prefix */\n      state->prefix = save_prefix;\n    }\n\n    b->type = orig_type;\n  }\n\n  /* process the (decoded) body part */\n  if (handler)\n  {\n    rc = handler(b, state);\n    if (rc != 0)\n    {\n      mutt_debug(LL_DEBUG1, \"Failed on attachment of type %s/%s\\n\", TYPE(b),\n                 NONULL(b->subtype));\n    }\n\n    if (decode)\n    {\n      b->length = tmplength;\n      b->offset = tmpoffset;\n\n      /* restore the original source stream */\n      mutt_file_fclose(&state->fp_in);\n      state->fp_in = fp;\n    }\n  }\n  state->flags |= STATE_FIRSTDONE;\n#ifdef USE_FMEMOPEN\n  FREE(&temp);\n#endif\n\n  return rc;\n}\n\n/**\n * valid_pgp_encrypted_handler - Handler for valid pgp-encrypted emails - Implements ::handler_t - @ingroup handler_api\n */\nstatic int valid_pgp_encrypted_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *octetstream = b_email->parts->next;\n\n  /* clear out any mime headers before the handler, so they can't be spoofed. */\n  mutt_env_free(&b_email->mime_headers);\n  mutt_env_free(&octetstream->mime_headers);\n\n  int rc;\n  /* Some clients improperly encode the octetstream part. */\n  if (octetstream->encoding != ENC_7BIT)\n    rc = run_decode_and_handler(octetstream, state, crypt_pgp_encrypted_handler, 0);\n  else\n    rc = crypt_pgp_encrypted_handler(octetstream, state);\n  b_email->goodsig |= octetstream->goodsig;\n\n  /* Relocate protected headers onto the multipart/encrypted part */\n  if (!rc && octetstream->mime_headers)\n  {\n    b_email->mime_headers = octetstream->mime_headers;\n    octetstream->mime_headers = NULL;\n  }\n\n  return rc;\n}\n\n/**\n * malformed_pgp_encrypted_handler - Handler for invalid pgp-encrypted emails - Implements ::handler_t - @ingroup handler_api\n */\nstatic int malformed_pgp_encrypted_handler(struct Body *b_email, struct State *state)\n{\n  struct Body *octetstream = b_email->parts->next->next;\n\n  /* clear out any mime headers before the handler, so they can't be spoofed. */\n  mutt_env_free(&b_email->mime_headers);\n  mutt_env_free(&octetstream->mime_headers);\n\n  /* exchange encodes the octet-stream, so re-run it through the decoder */\n  int rc = run_decode_and_handler(octetstream, state, crypt_pgp_encrypted_handler, false);\n  b_email->goodsig |= octetstream->goodsig;\n#ifdef USE_AUTOCRYPT\n  b_email->is_autocrypt |= octetstream->is_autocrypt;\n#endif\n\n  /* Relocate protected headers onto the multipart/encrypted part */\n  if (!rc && octetstream->mime_headers)\n  {\n    b_email->mime_headers = octetstream->mime_headers;\n    octetstream->mime_headers = NULL;\n  }\n\n  return rc;\n}\n\n/**\n * mutt_decode_base64 - Decode base64-encoded text\n * @param state      State to work with\n * @param len    Length of text to decode\n * @param istext Mime part is plain text\n * @param cd     Iconv conversion descriptor\n */\nvoid mutt_decode_base64(struct State *state, size_t len, bool istext, iconv_t cd)\n{\n  char buf[5] = { 0 };\n  int ch, i;\n  bool cr = false;\n  char bufi[BUFI_SIZE] = { 0 };\n  size_t l = 0;\n\n  buf[4] = '\\0';\n\n  if (istext)\n    state_set_prefix(state);\n\n  while (len > 0)\n  {\n    for (i = 0; (i < 4) && (len > 0); len--)\n    {\n      ch = fgetc(state->fp_in);\n      if (ch == EOF)\n        break;\n      if ((ch >= 0) && (ch < 128) && ((base64val(ch) != -1) || (ch == '=')))\n        buf[i++] = ch;\n    }\n    if (i != 4)\n    {\n      /* \"i\" may be zero if there is trailing whitespace, which is not an error */\n      if (i != 0)\n        mutt_debug(LL_DEBUG2, \"didn't get a multiple of 4 chars\\n\");\n      break;\n    }\n\n    const int c1 = base64val(buf[0]);\n    const int c2 = base64val(buf[1]);\n\n    /* first char */\n    ch = (c1 << 2) | (c2 >> 4);\n\n    if (cr && (ch != '\\n'))\n      bufi[l++] = '\\r';\n\n    cr = false;\n\n    if (istext && (ch == '\\r'))\n      cr = true;\n    else\n      bufi[l++] = ch;\n\n    /* second char */\n    if (buf[2] == '=')\n      break;\n    const int c3 = base64val(buf[2]);\n    ch = ((c2 & 0xf) << 4) | (c3 >> 2);\n\n    if (cr && (ch != '\\n'))\n      bufi[l++] = '\\r';\n\n    cr = false;\n\n    if (istext && (ch == '\\r'))\n      cr = true;\n    else\n      bufi[l++] = ch;\n\n    /* third char */\n    if (buf[3] == '=')\n      break;\n    const int c4 = base64val(buf[3]);\n    ch = ((c3 & 0x3) << 6) | c4;\n\n    if (cr && (ch != '\\n'))\n      bufi[l++] = '\\r';\n\n    cr = false;\n\n    if (istext && (ch == '\\r'))\n      cr = true;\n    else\n      bufi[l++] = ch;\n\n    if ((l + 8) >= sizeof(bufi))\n      convert_to_state(cd, bufi, &l, state);\n  }\n\n  if (cr)\n    bufi[l++] = '\\r';\n\n  convert_to_state(cd, bufi, &l, state);\n  convert_to_state(cd, 0, 0, state);\n\n  state_reset_prefix(state);\n}\n\n/**\n * mutt_body_handler - Handler for the Body of an email\n * @param b     Body of the email\n * @param state State to work with\n * @retval 0 Success\n * @retval -1 Error\n */\nint mutt_body_handler(struct Body *b, struct State *state)\n{\n  if (!b || !state)\n    return -1;\n\n  bool plaintext = false;\n  handler_t handler = NULL;\n  handler_t encrypted_handler = NULL;\n  int rc = 0;\n  static unsigned short recurse_level = 0;\n\n  const int oflags = state->flags;\n  const bool is_attachment_display = (oflags & STATE_DISPLAY_ATTACH);\n\n  if (recurse_level >= MUTT_MIME_MAX_DEPTH)\n  {\n    mutt_debug(LL_DEBUG1, \"recurse level too deep. giving up\\n\");\n    return 1;\n  }\n  recurse_level++;\n\n  /* first determine which handler to use to process this part */\n\n  if (is_autoview(b))\n  {\n    handler = autoview_handler;\n    state->flags &= ~STATE_CHARCONV;\n  }\n  else if (b->type == TYPE_TEXT)\n  {\n    if (mutt_istr_equal(\"plain\", b->subtype))\n    {\n      const bool c_reflow_text = cs_subset_bool(NeoMutt->sub, \"reflow_text\");\n      /* avoid copying this part twice since removing the transfer-encoding is\n       * the only operation needed.  */\n      if (((WithCrypto & APPLICATION_PGP) != 0) && mutt_is_application_pgp(b))\n      {\n        encrypted_handler = crypt_pgp_application_handler;\n        handler = encrypted_handler;\n      }\n      else if (c_reflow_text &&\n               mutt_istr_equal(\"flowed\", mutt_param_get(&b->parameter, \"format\")))\n      {\n        handler = rfc3676_handler;\n      }\n      else\n      {\n        handler = text_plain_handler;\n      }\n    }\n    else if (mutt_istr_equal(\"enriched\", b->subtype))\n    {\n      handler = text_enriched_handler;\n    }\n    else /* text body type without a handler */\n    {\n      plaintext = false;\n    }\n  }\n  else if (b->type == TYPE_MESSAGE)\n  {\n    if (mutt_is_message_type(b->type, b->subtype))\n      handler = message_handler;\n    else if (mutt_istr_equal(\"delivery-status\", b->subtype))\n      plaintext = true;\n    else if (mutt_istr_equal(\"external-body\", b->subtype))\n      handler = external_body_handler;\n  }\n  else if (b->type == TYPE_MULTIPART)\n  {\n    const char *const c_show_multipart_alternative = cs_subset_string(NeoMutt->sub, \"show_multipart_alternative\");\n    if (!mutt_str_equal(\"inline\", c_show_multipart_alternative) &&\n        mutt_istr_equal(\"alternative\", b->subtype))\n    {\n      handler = alternative_handler;\n    }\n    else if (!mutt_str_equal(\"inline\", c_show_multipart_alternative) &&\n             mutt_istr_equal(\"multilingual\", b->subtype))\n    {\n      handler = multilingual_handler;\n    }\n    else if ((WithCrypto != 0) && mutt_istr_equal(\"signed\", b->subtype))\n    {\n      if (!mutt_param_get(&b->parameter, \"protocol\"))\n        mutt_error(_(\"Error: multipart/signed has no protocol\"));\n      else if (state->flags & STATE_VERIFY)\n        handler = mutt_signed_handler;\n    }\n    else if (mutt_is_valid_multipart_pgp_encrypted(b))\n    {\n      encrypted_handler = valid_pgp_encrypted_handler;\n      handler = encrypted_handler;\n    }\n    else if (mutt_is_malformed_multipart_pgp_encrypted(b))\n    {\n      encrypted_handler = malformed_pgp_encrypted_handler;\n      handler = encrypted_handler;\n    }\n\n    if (!handler)\n      handler = multipart_handler;\n\n    if ((b->encoding != ENC_7BIT) && (b->encoding != ENC_8BIT) && (b->encoding != ENC_BINARY))\n    {\n      mutt_debug(LL_DEBUG1, \"Bad encoding type %d for multipart entity, assuming 7 bit\\n\",\n                 b->encoding);\n      b->encoding = ENC_7BIT;\n    }\n  }\n  else if ((WithCrypto != 0) && (b->type == TYPE_APPLICATION))\n  {\n    if (OptDontHandlePgpKeys && mutt_istr_equal(\"pgp-keys\", b->subtype))\n    {\n      /* pass raw part through for key extraction */\n      plaintext = true;\n    }\n    else if (((WithCrypto & APPLICATION_PGP) != 0) && mutt_is_application_pgp(b))\n    {\n      encrypted_handler = crypt_pgp_application_handler;\n      handler = encrypted_handler;\n    }\n    else if (((WithCrypto & APPLICATION_SMIME) != 0) && mutt_is_application_smime(b))\n    {\n      encrypted_handler = crypt_smime_application_handler;\n      handler = encrypted_handler;\n    }\n  }\n\n  if ((plaintext || handler) && (is_attachment_display || !mutt_prefer_as_attachment(b)))\n  {\n    /* only respect disposition == attachment if we're not\n     * displaying from the attachment menu (i.e. pager) */\n    /* Prevent encrypted attachments from being included in replies\n     * unless $include_encrypted is set. */\n    const bool c_include_encrypted = cs_subset_bool(NeoMutt->sub, \"include_encrypted\");\n    if ((state->flags & STATE_REPLYING) && (state->flags & STATE_FIRSTDONE) &&\n        encrypted_handler && !c_include_encrypted)\n    {\n      goto cleanup;\n    }\n\n    rc = run_decode_and_handler(b, state, handler, plaintext);\n  }\n  else if (state->flags & STATE_DISPLAY)\n  {\n    /* print hint to use attachment menu for disposition == attachment\n     * if we're not already being called from there */\n    const bool c_honor_disposition = cs_subset_bool(NeoMutt->sub, \"honor_disposition\");\n    struct Buffer *msg = buf_pool_get();\n\n    if (is_attachment_display)\n    {\n      if (c_honor_disposition && (b->disposition == DISP_ATTACH))\n      {\n        buf_strcpy(msg, _(\"[-- This is an attachment --]\\n\"));\n      }\n      else\n      {\n        /* L10N: %s/%s is a MIME type, e.g. \"text/plain\". */\n        buf_printf(msg, _(\"[-- %s/%s is unsupported --]\\n\"), TYPE(b), b->subtype);\n      }\n    }\n    else\n    {\n      struct Buffer *keystroke = buf_pool_get();\n      if (km_expand_key(km_find_func(MENU_PAGER, OP_VIEW_ATTACHMENTS), keystroke))\n      {\n        if (c_honor_disposition && (b->disposition == DISP_ATTACH))\n        {\n          /* L10N: %s expands to a keystroke/key binding, e.g. 'v'.  */\n          buf_printf(msg, _(\"[-- This is an attachment (use '%s' to view this part) --]\\n\"),\n                     buf_string(keystroke));\n        }\n        else\n        {\n          /* L10N: %s/%s is a MIME type, e.g. \"text/plain\".\n             The last %s expands to a keystroke/key binding, e.g. 'v'. */\n          buf_printf(msg, _(\"[-- %s/%s is unsupported (use '%s' to view this part) --]\\n\"),\n                     TYPE(b), b->subtype, buf_string(keystroke));\n        }\n      }\n      else\n      {\n        if (c_honor_disposition && (b->disposition == DISP_ATTACH))\n        {\n          buf_strcpy(msg, _(\"[-- This is an attachment (need 'view-attachments' bound to key) --]\\n\"));\n        }\n        else\n        {\n          /* L10N: %s/%s is a MIME type, e.g. \"text/plain\". */\n          buf_printf(msg, _(\"[-- %s/%s is unsupported (need 'view-attachments' bound to key) --]\\n\"),\n                     TYPE(b), b->subtype);\n        }\n      }\n      buf_pool_release(&keystroke);\n    }\n    state_mark_attach(state);\n    state_printf(state, \"%s\", buf_string(msg));\n    buf_pool_release(&msg);\n  }\n\ncleanup:\n  recurse_level--;\n  state->flags = oflags | (state->flags & STATE_FIRSTDONE);\n  if (rc != 0)\n  {\n    mutt_debug(LL_DEBUG1, \"Bailing on attachment of type %s/%s\\n\", TYPE(b),\n               NONULL(b->subtype));\n  }\n\n  return rc;\n}\n\n/**\n * mutt_prefer_as_attachment - Do we want this part as an attachment?\n * @param b Body of email to test\n * @retval true We want this part as an attachment\n */\nbool mutt_prefer_as_attachment(struct Body *b)\n{\n  if (!mutt_can_decode(b))\n    return true;\n\n  if (b->disposition != DISP_ATTACH)\n    return false;\n\n  return cs_subset_bool(NeoMutt->sub, \"honor_disposition\");\n}\n\n/**\n * mutt_can_decode - Will decoding the attachment produce any output\n * @param b Body of email to test\n * @retval true Decoding the attachment will produce output\n */\nbool mutt_can_decode(struct Body *b)\n{\n  if (is_autoview(b))\n    return true;\n  if (b->type == TYPE_TEXT)\n    return true;\n  if (b->type == TYPE_MESSAGE)\n    return true;\n  if (b->type == TYPE_MULTIPART)\n  {\n    if (WithCrypto)\n    {\n      if (mutt_istr_equal(b->subtype, \"signed\") || mutt_istr_equal(b->subtype, \"encrypted\"))\n      {\n        return true;\n      }\n    }\n\n    for (struct Body *part = b->parts; part; part = part->next)\n    {\n      if (mutt_can_decode(part))\n        return true;\n    }\n  }\n  else if ((WithCrypto != 0) && (b->type == TYPE_APPLICATION))\n  {\n    if (((WithCrypto & APPLICATION_PGP) != 0) && mutt_is_application_pgp(b))\n      return true;\n    if (((WithCrypto & APPLICATION_SMIME) != 0) && mutt_is_application_smime(b))\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * mutt_decode_attachment - Decode an email's attachment\n * @param b Body of the email\n * @param state State of text being processed\n */\nvoid mutt_decode_attachment(const struct Body *b, struct State *state)\n{\n  int istext = mutt_is_text_part(b) && (b->disposition == DISP_INLINE);\n  iconv_t cd = ICONV_T_INVALID;\n\n  if (!mutt_file_seek(state->fp_in, b->offset, SEEK_SET))\n  {\n    return;\n  }\n\n  if (istext && (b->charset || (state->flags & STATE_CHARCONV)))\n  {\n    const char *charset = b->charset;\n    if (!charset)\n    {\n      charset = mutt_param_get(&b->parameter, \"charset\");\n      if (!charset && !slist_is_empty(cc_assumed_charset()))\n        charset = mutt_ch_get_default_charset(cc_assumed_charset());\n    }\n    if (charset && cc_charset())\n      cd = mutt_ch_iconv_open(cc_charset(), charset, MUTT_ICONV_HOOK_FROM);\n  }\n\n  switch (b->encoding)\n  {\n    case ENC_QUOTED_PRINTABLE:\n      decode_quoted(state, b->length,\n                    istext || (((WithCrypto & APPLICATION_PGP) != 0) &&\n                               mutt_is_application_pgp(b)),\n                    cd);\n      break;\n    case ENC_BASE64:\n      mutt_decode_base64(state, b->length,\n                         istext || (((WithCrypto & APPLICATION_PGP) != 0) &&\n                                    mutt_is_application_pgp(b)),\n                         cd);\n      break;\n    case ENC_UUENCODED:\n      decode_uuencoded(state, b->length,\n                       istext || (((WithCrypto & APPLICATION_PGP) != 0) &&\n                                  mutt_is_application_pgp(b)),\n                       cd);\n      break;\n    default:\n      decode_xbit(state, b->length,\n                  istext || (((WithCrypto & APPLICATION_PGP) != 0) &&\n                             mutt_is_application_pgp(b)),\n                  cd);\n      break;\n  }\n}\n"
        },
        {
          "name": "handler.h",
          "type": "blob",
          "size": 1.3115234375,
          "content": "/**\n * @file\n * Decide how to display email content\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2022 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_HANDLER_H\n#define MUTT_HANDLER_H\n\n#include <iconv.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct Body;\nstruct State;\n\nint  mutt_body_handler        (struct Body *b, struct State *state);\nbool mutt_can_decode          (struct Body *b);\nvoid mutt_decode_attachment   (const struct Body *b, struct State *state);\nvoid mutt_decode_base64       (struct State *state, size_t len, bool istext, iconv_t cd);\nbool mutt_prefer_as_attachment(struct Body *b);\n\n#endif /* MUTT_HANDLER_H */\n"
        },
        {
          "name": "hcache",
          "type": "tree",
          "content": null
        },
        {
          "name": "help.c",
          "type": "blob",
          "size": 14.2802734375,
          "content": "/**\n * @file\n * Generate the help-page and GUI display it\n *\n * @authors\n * Copyright (C) 1996-2000,2009 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018-2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2020 Yousef Akbar <yousef@yhakbar.com>\n * Copyright (C) 2021 Ihor Antonov <ihor@antonovs.family>\n * Copyright (C) 2023 Tóth János <gomba007@gmail.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_help Generate the help-page and GUI display it\n *\n * Generate and help-page and GUI display it\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"index/lib.h\"\n#include \"key/lib.h\"\n#include \"menu/lib.h\"\n#include \"pager/lib.h\"\n#include \"protos.h\"\n\n/**\n * struct HelpLine - One line of Help text\n */\nstruct HelpLine\n{\n  const char *first;  ///< First  column\n  const char *second; ///< Second column\n  const char *third;  ///< Third  column\n};\nARRAY_HEAD(HelpLineArray, struct HelpLine);\n\n/**\n * help_lookup_function - Find a keybinding for an operation\n * @param op   Operation, e.g. OP_DELETE\n * @param menu Current Menu, e.g. #MENU_PAGER\n * @retval ptr  Key binding\n * @retval NULL No key binding found\n */\nstatic const struct MenuFuncOp *help_lookup_function(int op, enum MenuType menu)\n{\n  if ((menu != MENU_PAGER) && (menu != MENU_GENERIC))\n  {\n    /* first look in the generic map for the function */\n    for (int i = 0; OpGeneric[i].name; i++)\n      if (OpGeneric[i].op == op)\n        return &OpGeneric[i];\n  }\n\n  const struct MenuFuncOp *funcs = km_get_table(menu);\n  if (funcs)\n  {\n    for (int i = 0; funcs[i].name; i++)\n      if (funcs[i].op == op)\n        return &funcs[i];\n  }\n\n  return NULL;\n}\n\n/**\n * help_sort_alpha - Compare two Help Lines by their first entry - Implements ::sort_t - @ingroup sort_api\n */\nstatic int help_sort_alpha(const void *a, const void *b, void *sdata)\n{\n  const struct HelpLine *x = (const struct HelpLine *) a;\n  const struct HelpLine *y = (const struct HelpLine *) b;\n\n  return mutt_str_cmp(x->first, y->first);\n}\n\n/**\n * escape_macro - Escape any special characters in a macro\n * @param[in]  macro Macro string\n * @param[out] buf   Buffer for the result\n *\n * Replace characters, such as `<Enter>` with the literal \"\\n\"\n */\nstatic void escape_macro(const char *macro, struct Buffer *buf)\n{\n  wchar_t wc = 0;\n  size_t k;\n  size_t len = mutt_str_len(macro);\n  mbstate_t mbstate1 = { 0 };\n  mbstate_t mbstate2 = { 0 };\n\n  for (; (len > 0) && (k = mbrtowc(&wc, macro, MB_LEN_MAX, &mbstate1)); macro += k, len -= k)\n  {\n    if ((k == ICONV_ILLEGAL_SEQ) || (k == ICONV_BUF_TOO_SMALL))\n    {\n      if (k == ICONV_ILLEGAL_SEQ)\n        memset(&mbstate1, 0, sizeof(mbstate1));\n      k = (k == ICONV_ILLEGAL_SEQ) ? 1 : len;\n      wc = ReplacementChar;\n    }\n\n    const int w = wcwidth(wc);\n    if (IsWPrint(wc) && (w >= 0))\n    {\n      char tmp[MB_LEN_MAX * 2] = { 0 };\n      if (wcrtomb(tmp, wc, &mbstate2) != ICONV_ILLEGAL_SEQ)\n      {\n        buf_addstr(buf, tmp);\n      }\n    }\n    else if ((wc < 0x20) || (wc == 0x7f))\n    {\n      if (wc == '\\033') // Escape\n        buf_addstr(buf, \"\\\\e\");\n      else if (wc == '\\n')\n        buf_addstr(buf, \"\\\\n\");\n      else if (wc == '\\r')\n        buf_addstr(buf, \"\\\\r\");\n      else if (wc == '\\t')\n        buf_addstr(buf, \"\\\\t\");\n      else\n        buf_add_printf(buf, \"^%c\", (char) ((wc + '@') & 0x7f));\n    }\n    else\n    {\n      buf_addch(buf, '?');\n    }\n  }\n}\n\n/**\n * dump_menu - Write all the key bindings to a HelpLine Array\n * @param menu      Menu type\n * @param hla_menu  HelpLine Array of key bindings\n * @param hla_macro HelpLine Array of macros\n *\n * For bind:  { key-string, function-name, description }\n * For macro: { key-string, macro-text,    optional-description }\n */\nstatic void dump_menu(enum MenuType menu, struct HelpLineArray *hla_menu,\n                      struct HelpLineArray *hla_macro)\n{\n  struct Keymap *map = NULL;\n  struct Buffer *buf = buf_pool_get();\n\n  STAILQ_FOREACH(map, &Keymaps[menu], entries)\n  {\n    if (map->op == OP_NULL)\n      continue;\n\n    buf_reset(buf);\n    km_expand_key(map, buf);\n\n    struct HelpLine hl = { 0 };\n\n    hl.first = buf_strdup(buf);\n\n    if (map->op == OP_MACRO)\n    {\n      hl.second = map->macro;\n      hl.third = map->desc;\n      ARRAY_ADD(hla_macro, hl);\n    }\n    else\n    {\n      const struct MenuFuncOp *funcs = help_lookup_function(map->op, menu);\n      ASSERT(funcs);\n      hl.second = funcs->name;\n      hl.third = _(opcodes_get_description(funcs->op));\n      ARRAY_ADD(hla_menu, hl);\n    }\n  }\n\n  buf_pool_release(&buf);\n}\n\n/**\n * dump_bound - Dump the bound keys to a file\n * @param menu Menu type\n * @param fp   File to write to\n *\n * Collect all the function bindings and write them to a file.\n *\n * The output will be in three columns: binding, function, description.\n */\nstatic void dump_bound(enum MenuType menu, FILE *fp)\n{\n  struct HelpLineArray hla_gen = ARRAY_HEAD_INITIALIZER;\n  struct HelpLineArray hla_macro = ARRAY_HEAD_INITIALIZER;\n  struct HelpLineArray hla_menu = ARRAY_HEAD_INITIALIZER;\n\n  dump_menu(menu, &hla_menu, &hla_macro);\n  if ((menu != MENU_EDITOR) && (menu != MENU_PAGER) && (menu != MENU_GENERIC))\n  {\n    dump_menu(MENU_GENERIC, &hla_gen, &hla_macro);\n  }\n\n  struct HelpLine *hl = NULL;\n  int w1 = 0;\n  int w2 = 0;\n  ARRAY_FOREACH(hl, &hla_menu)\n  {\n    w1 = MAX(w1, mutt_str_len(hl->first));\n    w2 = MAX(w2, mutt_str_len(hl->second));\n  }\n\n  ARRAY_FOREACH(hl, &hla_gen)\n  {\n    w1 = MAX(w1, mutt_str_len(hl->first));\n    w2 = MAX(w2, mutt_str_len(hl->second));\n  }\n\n  ARRAY_FOREACH(hl, &hla_macro)\n  {\n    w1 = MAX(w1, mutt_str_len(hl->first));\n  }\n\n  const char *desc = mutt_map_get_name(menu, MenuNames);\n  fprintf(fp, _(\"%s bindings:\"), desc);\n  fputs(\"\\n\\n\", fp);\n\n  ARRAY_FOREACH(hl, &hla_menu)\n  {\n    fprintf(fp, \"%*s  \", -w1, hl->first);\n    fprintf(fp, \"%*s  %s\\n\", -w2, hl->second, hl->third);\n  }\n\n  if (!ARRAY_EMPTY(&hla_gen))\n  {\n    fprintf(fp, \"\\n%s\\n\\n\", _(\"Generic bindings:\"));\n    ARRAY_FOREACH(hl, &hla_gen)\n    {\n      fprintf(fp, \"%*s  \", -w1, hl->first);\n      fprintf(fp, \"%*s  %s\\n\", -w2, hl->second, hl->third);\n    }\n  }\n\n  if (!ARRAY_EMPTY(&hla_macro))\n  {\n    fprintf(fp, \"\\n%s\\n\\n\", _(\"macros:\"));\n    struct Buffer *macro = buf_pool_get();\n    ARRAY_FOREACH(hl, &hla_macro)\n    {\n      fprintf(fp, \"%*s  \", -w1, hl->first);\n\n      buf_reset(macro);\n      escape_macro(hl->second, macro);\n\n      if (hl->third) // there's a description\n      {\n        // Two lines, description then macro\n        fprintf(fp, \"%s\\n\", hl->third);\n        fprintf(fp, \"%s\\n\\n\", buf_string(macro));\n      }\n      else\n      {\n        fprintf(fp, \"%s\\n\", buf_string(macro));\n      }\n    }\n    buf_pool_release(&macro);\n  }\n\n  ARRAY_FOREACH(hl, &hla_gen)\n  {\n    FREE(&hl->first);\n  }\n\n  ARRAY_FOREACH(hl, &hla_menu)\n  {\n    FREE(&hl->first);\n  }\n\n  ARRAY_FOREACH(hl, &hla_macro)\n  {\n    FREE(&hl->first);\n  }\n\n  ARRAY_FREE(&hla_gen);\n  ARRAY_FREE(&hla_macro);\n  ARRAY_FREE(&hla_menu);\n}\n\n/**\n * is_bound - Does a function have a keybinding?\n * @param km_list Keymap to examine\n * @param op      Operation, e.g. OP_DELETE\n * @retval true A key is bound to that operation\n */\nstatic bool is_bound(struct KeymapList *km_list, int op)\n{\n  struct Keymap *map = NULL;\n  STAILQ_FOREACH(map, km_list, entries)\n  {\n    if (map->op == op)\n      return true;\n  }\n  return false;\n}\n\n/**\n * dump_unbound_menu - Write the operations with no key bindings to a HelpLine Array\n * @param[in]  funcs   All the bindings for the current menu\n * @param[in]  km_list First key map to consider\n * @param[in]  aux     Second key map to consider\n * @param[out] hla     HelpLine Array\n *\n * The output will be in two columns: { function-name, description }\n */\nstatic void dump_unbound_menu(const struct MenuFuncOp *funcs, struct KeymapList *km_list,\n                              struct KeymapList *aux, struct HelpLineArray *hla)\n{\n  for (int i = 0; funcs[i].name; i++)\n  {\n    if (!is_bound(km_list, funcs[i].op) && (!aux || !is_bound(aux, funcs[i].op)))\n    {\n      struct HelpLine hl = { 0 };\n      hl.first = funcs[i].name;\n      hl.second = _(opcodes_get_description(funcs[i].op));\n      ARRAY_ADD(hla, hl);\n    }\n  }\n}\n\n/**\n * dump_unbound - Dump the unbound keys to a file\n * @param menu Menu type\n * @param fp   File to write to\n *\n * The output will be in two columns: { function-name, description }\n */\nstatic void dump_unbound(enum MenuType menu, FILE *fp)\n{\n  fprintf(fp, \"\\n%s\\n\\n\", _(\"Unbound functions:\"));\n\n  struct HelpLineArray hla = ARRAY_HEAD_INITIALIZER;\n\n  const struct MenuFuncOp *funcs = km_get_table(menu);\n  if (funcs)\n    dump_unbound_menu(funcs, &Keymaps[menu], NULL, &hla);\n\n  if ((menu != MENU_EDITOR) && (menu != MENU_PAGER) && (menu != MENU_GENERIC))\n    dump_unbound_menu(OpGeneric, &Keymaps[MENU_GENERIC], &Keymaps[menu], &hla);\n\n  struct HelpLine *hl = NULL;\n  int w1 = 0;\n  ARRAY_FOREACH(hl, &hla)\n  {\n    w1 = MAX(w1, mutt_str_len(hl->first));\n  }\n\n  ARRAY_SORT(&hla, help_sort_alpha, NULL);\n  ARRAY_FOREACH(hl, &hla)\n  {\n    fprintf(fp, \"%*s  %s\\n\", -w1, hl->first, hl->second);\n  }\n\n  ARRAY_FREE(&hla);\n}\n\n/**\n * show_flag_if_present - Write out a message flag if exists\n * @param fp    File to write to\n * @param table Table containing the flag characters\n * @param index Index of flag character int the table\n * @param desc  Description of flag\n */\nstatic void show_flag_if_present(FILE *fp, const struct MbTable *table, int index, char *desc)\n{\n  const char *flag = mbtable_get_nth_wchar(table, index);\n  if ((strlen(flag) < 1) || (*flag == ' '))\n    return;\n\n  const int cols = mutt_strwidth(flag);\n\n  fprintf(fp, \"    %s%*s  %s\\n\", flag, 4 - cols, \"\", desc);\n}\n\n/**\n * dump_message_flags - Write out all the message flags\n * @param menu Menu type\n * @param fp   File to write to\n *\n * Display a quick reminder of all the flags in the config options:\n * - $crypt_chars\n * - $flag_chars\n * - $to_chars\n */\nstatic void dump_message_flags(enum MenuType menu, FILE *fp)\n{\n  if (menu != MENU_INDEX)\n    return;\n\n  fprintf(fp, \"\\n%s\\n\\n\", _(\"Message flags:\"));\n\n  const struct MbTable *c_flag_chars = cs_subset_mbtable(NeoMutt->sub, \"flag_chars\");\n  const struct MbTable *c_crypt_chars = cs_subset_mbtable(NeoMutt->sub, \"crypt_chars\");\n  const struct MbTable *c_to_chars = cs_subset_mbtable(NeoMutt->sub, \"to_chars\");\n\n  fputs(\"$flag_chars:\\n\", fp);\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_TAGGED, _(\"message is tagged\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_IMPORTANT, _(\"message is flagged\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_DELETED, _(\"message is deleted\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_DELETED_ATTACH, _(\"attachment is deleted\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_REPLIED, _(\"message has been replied to\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_OLD, _(\"message has been read\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_NEW, _(\"message is new\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_OLD_THREAD, _(\"thread has been read\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_NEW_THREAD,\n                       _(\"thread has at least one new message\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_SEMPTY,\n                       _(\"message has been read (%S expando)\"));\n  show_flag_if_present(fp, c_flag_chars, FLAG_CHAR_ZEMPTY,\n                       _(\"message has been read (%Z expando)\"));\n\n  fputs(\"\\n$crypt_chars:\\n\", fp);\n  show_flag_if_present(fp, c_crypt_chars, FLAG_CHAR_CRYPT_GOOD_SIGN,\n                       _(\"message signed with a verified key\"));\n  show_flag_if_present(fp, c_crypt_chars, FLAG_CHAR_CRYPT_ENCRYPTED,\n                       _(\"message is PGP-encrypted\"));\n  show_flag_if_present(fp, c_crypt_chars, FLAG_CHAR_CRYPT_SIGNED, _(\"message is signed\"));\n  show_flag_if_present(fp, c_crypt_chars, FLAG_CHAR_CRYPT_CONTAINS_KEY,\n                       _(\"message contains a PGP key\"));\n  show_flag_if_present(fp, c_crypt_chars, FLAG_CHAR_CRYPT_NO_CRYPTO,\n                       _(\"message has no cryptography information\"));\n\n  fputs(\"\\n$to_chars:\\n\", fp);\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_NOT_IN_THE_LIST,\n                       _(\"message is not To: you\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_UNIQUE,\n                       _(\"message is To: you and only you\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_TO, _(\"message is To: you\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_CC, _(\"message is Cc: to you\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_ORIGINATOR, _(\"message is From: you\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_SUBSCRIBED_LIST,\n                       _(\"message is sent to a subscribed mailing list\"));\n  show_flag_if_present(fp, c_to_chars, FLAG_CHAR_TO_REPLY_TO,\n                       _(\"you are in the Reply-To: list\"));\n  fputs(\"\\n\", fp);\n}\n\n/**\n * mutt_help - Display the help menu\n * @param menu    Current Menu\n */\nvoid mutt_help(enum MenuType menu)\n{\n  char banner[128] = { 0 };\n  FILE *fp = NULL;\n\n  struct Buffer *tempfile = buf_pool_get();\n  buf_mktemp(tempfile);\n\n  struct PagerData pdata = { 0 };\n  struct PagerView pview = { &pdata };\n\n  pview.mode = PAGER_MODE_HELP;\n  pview.flags = MUTT_PAGER_MARKER | MUTT_PAGER_NOWRAP | MUTT_PAGER_STRIPES;\n\n  fp = mutt_file_fopen(buf_string(tempfile), \"w\");\n  if (!fp)\n  {\n    mutt_perror(\"%s\", buf_string(tempfile));\n    goto cleanup;\n  }\n\n  dump_bound(menu, fp);\n  dump_unbound(menu, fp);\n  dump_message_flags(menu, fp);\n\n  mutt_file_fclose(&fp);\n\n  const char *desc = mutt_map_get_name(menu, MenuNames);\n  snprintf(banner, sizeof(banner), _(\"Help for %s\"), desc);\n  pdata.fname = buf_string(tempfile);\n  pview.banner = banner;\n\n  mutt_do_pager(&pview, NULL);\n\ncleanup:\n  buf_pool_release(&tempfile);\n}\n"
        },
        {
          "name": "helpbar",
          "type": "tree",
          "content": null
        },
        {
          "name": "history",
          "type": "tree",
          "content": null
        },
        {
          "name": "hook.c",
          "type": "blob",
          "size": 28.951171875,
          "content": "/**\n * @file\n * Parse and execute user-defined hooks\n *\n * @authors\n * Copyright (C) 1996-2002,2004,2007 Michael R. Elkins <me@mutt.org>, and others\n * Copyright (C) 2016 Thomas Adam <thomas@xteddy.org>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017-2021 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2019 Federico Kircheis <federico.kircheis@gmail.com>\n * Copyright (C) 2019 Naveen Nathan <naveen@lastninja.net>\n * Copyright (C) 2022 Oliver Bandel <oliver@first.in-berlin.de>\n * Copyright (C) 2023 Dennis Schön <mail@dennis-schoen.de>\n * Copyright (C) 2023-2024 Tóth János <gomba007@gmail.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_hook Parse and execute user-defined hooks\n *\n * Parse and execute user-defined hooks\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"hook.h\"\n#include \"attach/lib.h\"\n#include \"compmbox/lib.h\"\n#include \"expando/lib.h\"\n#include \"index/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"parse/lib.h\"\n#include \"pattern/lib.h\"\n#include \"commands.h\"\n#include \"globals.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n\nextern const struct ExpandoDefinition IndexFormatDef[];\n\n/**\n * struct Hook - A list of user hooks\n */\nstruct Hook\n{\n  HookFlags type;              ///< Hook type\n  struct Regex regex;          ///< Regular expression\n  char *command;               ///< Filename, command or pattern to execute\n  char *source_file;           ///< Used for relative-directory source\n  struct PatternList *pattern; ///< Used for fcc,save,send-hook\n  struct Expando *expando;     ///< Used for format hooks\n  TAILQ_ENTRY(Hook) entries;   ///< Linked list\n};\nTAILQ_HEAD(HookList, Hook);\n\n/// All simple hooks, e.g. MUTT_FOLDER_HOOK\nstatic struct HookList Hooks = TAILQ_HEAD_INITIALIZER(Hooks);\n\n/// All Index Format hooks\nstatic struct HashTable *IdxFmtHooks = NULL;\n\n/// The type of the hook currently being executed, e.g. #MUTT_SAVE_HOOK\nstatic HookFlags CurrentHookType = MUTT_HOOK_NO_FLAGS;\n\n/**\n * hook_free - Free a Hook\n * @param ptr Hook to free\n */\nstatic void hook_free(struct Hook **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct Hook *h = *ptr;\n\n  FREE(&h->command);\n  FREE(&h->source_file);\n  FREE(&h->regex.pattern);\n  if (h->regex.regex)\n  {\n    regfree(h->regex.regex);\n    FREE(&h->regex.regex);\n  }\n  mutt_pattern_free(&h->pattern);\n  expando_free(&h->expando);\n  FREE(ptr);\n}\n\n/**\n * hook_new - Create a Hook\n * @retval ptr New Hook\n */\nstatic struct Hook *hook_new(void)\n{\n  return MUTT_MEM_CALLOC(1, struct Hook);\n}\n\n/**\n * mutt_parse_charset_iconv_hook - Parse 'charset-hook' and 'iconv-hook' commands - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult mutt_parse_charset_iconv_hook(struct Buffer *buf, struct Buffer *s,\n                                                 intptr_t data, struct Buffer *err)\n{\n  struct Buffer *alias = buf_pool_get();\n  struct Buffer *charset = buf_pool_get();\n\n  int rc = MUTT_CMD_ERROR;\n\n  if (parse_extract_token(alias, s, TOKEN_NO_FLAGS) < 0)\n    goto done;\n  if (parse_extract_token(charset, s, TOKEN_NO_FLAGS) < 0)\n    goto done;\n\n  const enum LookupType type = (data & MUTT_ICONV_HOOK) ? MUTT_LOOKUP_ICONV : MUTT_LOOKUP_CHARSET;\n\n  if (buf_is_empty(alias) || buf_is_empty(charset))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n    rc = MUTT_CMD_WARNING;\n  }\n  else if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), buf->data);\n    buf_reset(s); // clean up buffer to avoid a mess with further rcfile processing\n    rc = MUTT_CMD_WARNING;\n  }\n  else if (mutt_ch_lookup_add(type, buf_string(alias), buf_string(charset), err))\n  {\n    rc = MUTT_CMD_SUCCESS;\n  }\n\ndone:\n  buf_pool_release(&alias);\n  buf_pool_release(&charset);\n\n  return rc;\n}\n\n/**\n * mutt_parse_hook - Parse the 'hook' family of commands - Implements Command::parse() - @ingroup command_parse\n *\n * This is used by 'account-hook', 'append-hook' and many more.\n */\nenum CommandResult mutt_parse_hook(struct Buffer *buf, struct Buffer *s,\n                                   intptr_t data, struct Buffer *err)\n{\n  struct Hook *hook = NULL;\n  int rc = MUTT_CMD_ERROR;\n  bool pat_not = false;\n  bool use_regex = true;\n  regex_t *rx = NULL;\n  struct PatternList *pat = NULL;\n  const bool folder_or_mbox = (data & (MUTT_FOLDER_HOOK | MUTT_MBOX_HOOK));\n\n  struct Buffer *cmd = buf_pool_get();\n  struct Buffer *pattern = buf_pool_get();\n\n  if (~data & MUTT_GLOBAL_HOOK) /* NOT a global hook */\n  {\n    if (*s->dptr == '!')\n    {\n      s->dptr++;\n      SKIPWS(s->dptr);\n      pat_not = true;\n    }\n\n    parse_extract_token(pattern, s, TOKEN_NO_FLAGS);\n    if (folder_or_mbox && mutt_str_equal(buf_string(pattern), \"-noregex\"))\n    {\n      use_regex = false;\n      if (!MoreArgs(s))\n      {\n        buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n        rc = MUTT_CMD_WARNING;\n        goto cleanup;\n      }\n      parse_extract_token(pattern, s, TOKEN_NO_FLAGS);\n    }\n\n    if (!MoreArgs(s))\n    {\n      buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n      rc = MUTT_CMD_WARNING;\n      goto cleanup;\n    }\n  }\n\n  parse_extract_token(cmd, s,\n                      (data & (MUTT_FOLDER_HOOK | MUTT_SEND_HOOK | MUTT_SEND2_HOOK |\n                               MUTT_ACCOUNT_HOOK | MUTT_REPLY_HOOK)) ?\n                          TOKEN_SPACE :\n                          TOKEN_NO_FLAGS);\n\n  if (buf_is_empty(cmd))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n    rc = MUTT_CMD_WARNING;\n    goto cleanup;\n  }\n\n  if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), buf->data);\n    rc = MUTT_CMD_WARNING;\n    goto cleanup;\n  }\n\n  const char *const c_default_hook = cs_subset_string(NeoMutt->sub, \"default_hook\");\n  if (folder_or_mbox)\n  {\n    /* Accidentally using the ^ mailbox shortcut in the .neomuttrc is a\n     * common mistake */\n    if ((pattern->data[0] == '^') && !CurrentFolder)\n    {\n      buf_strcpy(err, _(\"current mailbox shortcut '^' is unset\"));\n      goto cleanup;\n    }\n\n    struct Buffer *tmp = buf_pool_get();\n    buf_copy(tmp, pattern);\n    buf_expand_path_regex(tmp, use_regex);\n\n    /* Check for other mailbox shortcuts that expand to the empty string.\n     * This is likely a mistake too */\n    if (buf_is_empty(tmp) && !buf_is_empty(pattern))\n    {\n      buf_strcpy(err, _(\"mailbox shortcut expanded to empty regex\"));\n      buf_pool_release(&tmp);\n      goto cleanup;\n    }\n\n    if (use_regex)\n    {\n      buf_copy(pattern, tmp);\n    }\n    else\n    {\n      mutt_file_sanitize_regex(pattern, buf_string(tmp));\n    }\n    buf_pool_release(&tmp);\n  }\n  else if (data & (MUTT_APPEND_HOOK | MUTT_OPEN_HOOK | MUTT_CLOSE_HOOK))\n  {\n    if (mutt_comp_valid_command(buf_string(cmd)) == 0)\n    {\n      buf_strcpy(err, _(\"badly formatted command string\"));\n      goto cleanup;\n    }\n  }\n  else if (c_default_hook && (~data & MUTT_GLOBAL_HOOK) &&\n           !(data & (MUTT_ACCOUNT_HOOK)) && (!WithCrypto || !(data & MUTT_CRYPT_HOOK)))\n  {\n    /* At this stage only these hooks remain:\n     * fcc-, fcc-save-, index-format-, message-, reply-, save-, send- and send2-hook\n     * If given a plain string, or regex, we expand it using $default_hook. */\n    mutt_check_simple(pattern, c_default_hook);\n  }\n\n  if (data & (MUTT_MBOX_HOOK | MUTT_SAVE_HOOK | MUTT_FCC_HOOK))\n  {\n    buf_expand_path(cmd);\n  }\n\n  /* check to make sure that a matching hook doesn't already exist */\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (data & MUTT_GLOBAL_HOOK)\n    {\n      /* Ignore duplicate global hooks */\n      if (mutt_str_equal(hook->command, buf_string(cmd)))\n      {\n        rc = MUTT_CMD_SUCCESS;\n        goto cleanup;\n      }\n    }\n    else if ((hook->type == data) && (hook->regex.pat_not == pat_not) &&\n             mutt_str_equal(buf_string(pattern), hook->regex.pattern))\n    {\n      if (data & (MUTT_FOLDER_HOOK | MUTT_SEND_HOOK | MUTT_SEND2_HOOK | MUTT_MESSAGE_HOOK |\n                  MUTT_ACCOUNT_HOOK | MUTT_REPLY_HOOK | MUTT_CRYPT_HOOK |\n                  MUTT_TIMEOUT_HOOK | MUTT_STARTUP_HOOK | MUTT_SHUTDOWN_HOOK))\n      {\n        /* these hooks allow multiple commands with the same\n         * pattern, so if we've already seen this pattern/command pair, just\n         * ignore it instead of creating a duplicate */\n        if (mutt_str_equal(hook->command, buf_string(cmd)))\n        {\n          rc = MUTT_CMD_SUCCESS;\n          goto cleanup;\n        }\n      }\n      else\n      {\n        /* other hooks only allow one command per pattern, so update the\n         * entry with the new command.  this currently does not change the\n         * order of execution of the hooks, which i think is desirable since\n         * a common action to perform is to change the default (.) entry\n         * based upon some other information. */\n        FREE(&hook->command);\n        hook->command = buf_strdup(cmd);\n        FREE(&hook->source_file);\n        hook->source_file = mutt_get_sourced_cwd();\n\n        if (data & (MUTT_IDXFMTHOOK | MUTT_MBOX_HOOK | MUTT_SAVE_HOOK | MUTT_FCC_HOOK))\n        {\n          expando_free(&hook->expando);\n          hook->expando = expando_parse(buf_string(cmd), IndexFormatDef, err);\n        }\n\n        rc = MUTT_CMD_SUCCESS;\n        goto cleanup;\n      }\n    }\n  }\n\n  if (data & (MUTT_SEND_HOOK | MUTT_SEND2_HOOK | MUTT_SAVE_HOOK |\n              MUTT_FCC_HOOK | MUTT_MESSAGE_HOOK | MUTT_REPLY_HOOK))\n  {\n    PatternCompFlags comp_flags;\n\n    if (data & (MUTT_SEND2_HOOK))\n      comp_flags = MUTT_PC_SEND_MODE_SEARCH;\n    else if (data & (MUTT_SEND_HOOK | MUTT_FCC_HOOK))\n      comp_flags = MUTT_PC_NO_FLAGS;\n    else\n      comp_flags = MUTT_PC_FULL_MSG;\n\n    struct MailboxView *mv_cur = get_current_mailbox_view();\n    struct Menu *menu = get_current_menu();\n    pat = mutt_pattern_comp(mv_cur, menu, buf_string(pattern), comp_flags, err);\n    if (!pat)\n      goto cleanup;\n  }\n  else if (~data & MUTT_GLOBAL_HOOK) /* NOT a global hook */\n  {\n    /* Hooks not allowing full patterns: Check syntax of regex */\n    rx = MUTT_MEM_CALLOC(1, regex_t);\n    int rc2 = REG_COMP(rx, buf_string(pattern), ((data & MUTT_CRYPT_HOOK) ? REG_ICASE : 0));\n    if (rc2 != 0)\n    {\n      regerror(rc2, rx, err->data, err->dsize);\n      FREE(&rx);\n      goto cleanup;\n    }\n  }\n\n  struct Expando *exp = NULL;\n  if (data & (MUTT_IDXFMTHOOK | MUTT_MBOX_HOOK | MUTT_SAVE_HOOK | MUTT_FCC_HOOK))\n    exp = expando_parse(buf_string(cmd), IndexFormatDef, err);\n\n  hook = hook_new();\n  hook->type = data;\n  hook->command = buf_strdup(cmd);\n  hook->source_file = mutt_get_sourced_cwd();\n  hook->pattern = pat;\n  hook->regex.pattern = buf_strdup(pattern);\n  hook->regex.regex = rx;\n  hook->regex.pat_not = pat_not;\n  hook->expando = exp;\n\n  TAILQ_INSERT_TAIL(&Hooks, hook, entries);\n  rc = MUTT_CMD_SUCCESS;\n\ncleanup:\n  buf_pool_release(&cmd);\n  buf_pool_release(&pattern);\n  return rc;\n}\n\n/**\n * mutt_delete_hooks - Delete matching hooks\n * @param type Hook type to delete, see #HookFlags\n *\n * If MUTT_HOOK_NO_FLAGS is passed, all the hooks will be deleted.\n */\nvoid mutt_delete_hooks(HookFlags type)\n{\n  struct Hook *h = NULL;\n  struct Hook *tmp = NULL;\n\n  TAILQ_FOREACH_SAFE(h, &Hooks, entries, tmp)\n  {\n    if ((type == MUTT_HOOK_NO_FLAGS) || (type == h->type))\n    {\n      TAILQ_REMOVE(&Hooks, h, entries);\n      hook_free(&h);\n    }\n  }\n}\n\n/**\n * idxfmt_hashelem_free - Free our hash table data - Implements ::hash_hdata_free_t - @ingroup hash_hdata_free_api\n */\nstatic void idxfmt_hashelem_free(int type, void *obj, intptr_t data)\n{\n  struct HookList *hl = obj;\n  struct Hook *h = NULL;\n  struct Hook *tmp = NULL;\n\n  TAILQ_FOREACH_SAFE(h, hl, entries, tmp)\n  {\n    TAILQ_REMOVE(hl, h, entries);\n    hook_free(&h);\n  }\n\n  FREE(&hl);\n}\n\n/**\n * delete_idxfmt_hooks - Delete all the index-format-hooks\n */\nstatic void delete_idxfmt_hooks(void)\n{\n  mutt_hash_free(&IdxFmtHooks);\n}\n\n/**\n * mutt_parse_idxfmt_hook - Parse the 'index-format-hook' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult mutt_parse_idxfmt_hook(struct Buffer *buf, struct Buffer *s,\n                                                 intptr_t data, struct Buffer *err)\n{\n  enum CommandResult rc = MUTT_CMD_ERROR;\n  bool pat_not = false;\n\n  struct Buffer *name = buf_pool_get();\n  struct Buffer *pattern = buf_pool_get();\n  struct Buffer *fmtstring = buf_pool_get();\n  struct Expando *exp = NULL;\n\n  if (!IdxFmtHooks)\n  {\n    IdxFmtHooks = mutt_hash_new(30, MUTT_HASH_STRDUP_KEYS);\n    mutt_hash_set_destructor(IdxFmtHooks, idxfmt_hashelem_free, 0);\n  }\n\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n    goto out;\n  }\n  parse_extract_token(name, s, TOKEN_NO_FLAGS);\n  struct HookList *hl = mutt_hash_find(IdxFmtHooks, buf_string(name));\n\n  if (*s->dptr == '!')\n  {\n    s->dptr++;\n    SKIPWS(s->dptr);\n    pat_not = true;\n  }\n  parse_extract_token(pattern, s, TOKEN_NO_FLAGS);\n\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), buf->data);\n    goto out;\n  }\n  parse_extract_token(fmtstring, s, TOKEN_NO_FLAGS);\n\n  exp = expando_parse(buf_string(fmtstring), IndexFormatDef, err);\n  if (!exp)\n    goto out;\n\n  if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), buf->data);\n    goto out;\n  }\n\n  const char *const c_default_hook = cs_subset_string(NeoMutt->sub, \"default_hook\");\n  if (c_default_hook)\n    mutt_check_simple(pattern, c_default_hook);\n\n  /* check to make sure that a matching hook doesn't already exist */\n  struct Hook *hook = NULL;\n  if (hl)\n  {\n    TAILQ_FOREACH(hook, hl, entries)\n    {\n      if ((hook->regex.pat_not == pat_not) &&\n          mutt_str_equal(buf_string(pattern), hook->regex.pattern))\n      {\n        expando_free(&hook->expando);\n        hook->expando = exp;\n        exp = NULL;\n        rc = MUTT_CMD_SUCCESS;\n        goto out;\n      }\n    }\n  }\n\n  /* MUTT_PC_PATTERN_DYNAMIC sets so that date ranges are regenerated during\n   * matching.  This of course is slower, but index-format-hook is commonly\n   * used for date ranges, and they need to be evaluated relative to \"now\", not\n   * the hook compilation time.  */\n  struct MailboxView *mv_cur = get_current_mailbox_view();\n  struct Menu *menu = get_current_menu();\n  struct PatternList *pat = mutt_pattern_comp(mv_cur, menu, buf_string(pattern),\n                                              MUTT_PC_FULL_MSG | MUTT_PC_PATTERN_DYNAMIC,\n                                              err);\n  if (!pat)\n    goto out;\n\n  hook = hook_new();\n  hook->type = MUTT_IDXFMTHOOK;\n  hook->command = NULL;\n  hook->source_file = mutt_get_sourced_cwd();\n  hook->pattern = pat;\n  hook->regex.pattern = buf_strdup(pattern);\n  hook->regex.regex = NULL;\n  hook->regex.pat_not = pat_not;\n  hook->expando = exp;\n  exp = NULL;\n\n  if (!hl)\n  {\n    hl = MUTT_MEM_CALLOC(1, struct HookList);\n    TAILQ_INIT(hl);\n    mutt_hash_insert(IdxFmtHooks, buf_string(name), hl);\n  }\n\n  TAILQ_INSERT_TAIL(hl, hook, entries);\n  rc = MUTT_CMD_SUCCESS;\n\nout:\n  buf_pool_release(&name);\n  buf_pool_release(&pattern);\n  buf_pool_release(&fmtstring);\n  expando_free(&exp);\n\n  return rc;\n}\n\n/**\n * mutt_get_hook_type - Find a hook by name\n * @param name Name to find\n * @retval num                 Hook ID, e.g. #MUTT_FOLDER_HOOK\n * @retval #MUTT_HOOK_NO_FLAGS Error, no matching hook\n */\nstatic HookFlags mutt_get_hook_type(const char *name)\n{\n  struct Command *c = NULL;\n  for (size_t i = 0, size = commands_array(&c); i < size; i++)\n  {\n    if (((c[i].parse == mutt_parse_hook) || (c[i].parse == mutt_parse_idxfmt_hook)) &&\n        mutt_istr_equal(c[i].name, name))\n    {\n      return c[i].data;\n    }\n  }\n  return MUTT_HOOK_NO_FLAGS;\n}\n\n/**\n * mutt_parse_unhook - Parse the 'unhook' command - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult mutt_parse_unhook(struct Buffer *buf, struct Buffer *s,\n                                            intptr_t data, struct Buffer *err)\n{\n  while (MoreArgs(s))\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    if (mutt_str_equal(\"*\", buf->data))\n    {\n      if (CurrentHookType != TOKEN_NO_FLAGS)\n      {\n        buf_addstr(err, _(\"unhook: Can't do unhook * from within a hook\"));\n        return MUTT_CMD_WARNING;\n      }\n      mutt_delete_hooks(MUTT_HOOK_NO_FLAGS);\n      delete_idxfmt_hooks();\n      mutt_ch_lookup_remove();\n    }\n    else\n    {\n      HookFlags type = mutt_get_hook_type(buf->data);\n\n      if (type == MUTT_HOOK_NO_FLAGS)\n      {\n        buf_printf(err, _(\"unhook: unknown hook type: %s\"), buf->data);\n        return MUTT_CMD_ERROR;\n      }\n      if (type & (MUTT_CHARSET_HOOK | MUTT_ICONV_HOOK))\n      {\n        mutt_ch_lookup_remove();\n        return MUTT_CMD_SUCCESS;\n      }\n      if (CurrentHookType == type)\n      {\n        buf_printf(err, _(\"unhook: Can't delete a %s from within a %s\"),\n                   buf->data, buf->data);\n        return MUTT_CMD_WARNING;\n      }\n      if (type == MUTT_IDXFMTHOOK)\n        delete_idxfmt_hooks();\n      else\n        mutt_delete_hooks(type);\n    }\n  }\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * mutt_folder_hook - Perform a folder hook\n * @param path Path to potentially match\n * @param desc Description to potentially match\n */\nvoid mutt_folder_hook(const char *path, const char *desc)\n{\n  if (!path && !desc)\n    return;\n\n  struct Hook *hook = NULL;\n  struct Buffer *err = buf_pool_get();\n\n  CurrentHookType = MUTT_FOLDER_HOOK;\n\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!hook->command)\n      continue;\n\n    if (!(hook->type & MUTT_FOLDER_HOOK))\n      continue;\n\n    const char *match = NULL;\n    if (mutt_regex_match(&hook->regex, path))\n      match = path;\n    else if (mutt_regex_match(&hook->regex, desc))\n      match = desc;\n\n    if (match)\n    {\n      mutt_debug(LL_DEBUG1, \"folder-hook '%s' matches '%s'\\n\", hook->regex.pattern, match);\n      mutt_debug(LL_DEBUG5, \"    %s\\n\", hook->command);\n      if (parse_rc_line_cwd(hook->command, hook->source_file, err) == MUTT_CMD_ERROR)\n      {\n        mutt_error(\"%s\", buf_string(err));\n        break;\n      }\n    }\n  }\n  buf_pool_release(&err);\n\n  CurrentHookType = MUTT_HOOK_NO_FLAGS;\n}\n\n/**\n * mutt_find_hook - Find a matching hook\n * @param type Hook type, see #HookFlags\n * @param pat  Pattern to match\n * @retval ptr Command string\n *\n * @note The returned string must not be freed.\n */\nchar *mutt_find_hook(HookFlags type, const char *pat)\n{\n  struct Hook *tmp = NULL;\n\n  TAILQ_FOREACH(tmp, &Hooks, entries)\n  {\n    if (tmp->type & type)\n    {\n      if (mutt_regex_match(&tmp->regex, pat))\n        return tmp->command;\n    }\n  }\n  return NULL;\n}\n\n/**\n * mutt_message_hook - Perform a message hook\n * @param m   Mailbox\n * @param e   Email\n * @param type Hook type, see #HookFlags\n */\nvoid mutt_message_hook(struct Mailbox *m, struct Email *e, HookFlags type)\n{\n  struct Hook *hook = NULL;\n  struct PatternCache cache = { 0 };\n  struct Buffer *err = buf_pool_get();\n\n  CurrentHookType = type;\n\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!hook->command)\n      continue;\n\n    if (hook->type & type)\n    {\n      if ((mutt_pattern_exec(SLIST_FIRST(hook->pattern), 0, m, e, &cache) > 0) ^\n          hook->regex.pat_not)\n      {\n        if (parse_rc_line_cwd(hook->command, hook->source_file, err) == MUTT_CMD_ERROR)\n        {\n          mutt_error(\"%s\", buf_string(err));\n          CurrentHookType = MUTT_HOOK_NO_FLAGS;\n          buf_pool_release(&err);\n\n          return;\n        }\n        /* Executing arbitrary commands could affect the pattern results,\n         * so the cache has to be wiped */\n        memset(&cache, 0, sizeof(cache));\n      }\n    }\n  }\n  buf_pool_release(&err);\n\n  CurrentHookType = MUTT_HOOK_NO_FLAGS;\n}\n\n/**\n * addr_hook - Perform an address hook (get a path)\n * @param path    Buffer for path\n * @param type    Hook type, see #HookFlags\n * @param m       Mailbox\n * @param e       Email\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int addr_hook(struct Buffer *path, HookFlags type, struct Mailbox *m, struct Email *e)\n{\n  struct Hook *hook = NULL;\n  struct PatternCache cache = { 0 };\n\n  /* determine if a matching hook exists */\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!hook->command)\n      continue;\n\n    if (hook->type & type)\n    {\n      if ((mutt_pattern_exec(SLIST_FIRST(hook->pattern), 0, m, e, &cache) > 0) ^\n          hook->regex.pat_not)\n      {\n        buf_alloc(path, PATH_MAX);\n        mutt_make_string(path, -1, hook->expando, m, -1, e, MUTT_FORMAT_PLAIN, NULL);\n        buf_fix_dptr(path);\n        return 0;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * mutt_default_save - Find the default save path for an email\n * @param path  Buffer for the path\n * @param e     Email\n */\nvoid mutt_default_save(struct Buffer *path, struct Email *e)\n{\n  struct Mailbox *m_cur = get_current_mailbox();\n  if (addr_hook(path, MUTT_SAVE_HOOK, m_cur, e) == 0)\n    return;\n\n  struct Envelope *env = e->env;\n  const struct Address *from = TAILQ_FIRST(&env->from);\n  const struct Address *reply_to = TAILQ_FIRST(&env->reply_to);\n  const struct Address *to = TAILQ_FIRST(&env->to);\n  const struct Address *cc = TAILQ_FIRST(&env->cc);\n  const struct Address *addr = NULL;\n  bool from_me = mutt_addr_is_user(from);\n\n  if (!from_me && reply_to && reply_to->mailbox)\n    addr = reply_to;\n  else if (!from_me && from && from->mailbox)\n    addr = from;\n  else if (to && to->mailbox)\n    addr = to;\n  else if (cc && cc->mailbox)\n    addr = cc;\n  else\n    addr = NULL;\n  if (addr)\n  {\n    struct Buffer *tmp = buf_pool_get();\n    mutt_safe_path(tmp, addr);\n    buf_add_printf(path, \"=%s\", buf_string(tmp));\n    buf_pool_release(&tmp);\n  }\n}\n\n/**\n * mutt_select_fcc - Select the FCC path for an email\n * @param path    Buffer for the path\n * @param e       Email\n */\nvoid mutt_select_fcc(struct Buffer *path, struct Email *e)\n{\n  buf_alloc(path, PATH_MAX);\n\n  if (addr_hook(path, MUTT_FCC_HOOK, NULL, e) != 0)\n  {\n    const struct Address *to = TAILQ_FIRST(&e->env->to);\n    const struct Address *cc = TAILQ_FIRST(&e->env->cc);\n    const struct Address *bcc = TAILQ_FIRST(&e->env->bcc);\n    const bool c_save_name = cs_subset_bool(NeoMutt->sub, \"save_name\");\n    const bool c_force_name = cs_subset_bool(NeoMutt->sub, \"force_name\");\n    const char *const c_record = cs_subset_string(NeoMutt->sub, \"record\");\n    if ((c_save_name || c_force_name) && (to || cc || bcc))\n    {\n      const struct Address *addr = to ? to : (cc ? cc : bcc);\n      struct Buffer *buf = buf_pool_get();\n      mutt_safe_path(buf, addr);\n      const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n      buf_concat_path(path, NONULL(c_folder), buf_string(buf));\n      buf_pool_release(&buf);\n      if (!c_force_name && (mx_access(buf_string(path), W_OK) != 0))\n        buf_strcpy(path, c_record);\n    }\n    else\n    {\n      buf_strcpy(path, c_record);\n    }\n  }\n  else\n  {\n    buf_fix_dptr(path);\n  }\n\n  buf_pretty_mailbox(path);\n}\n\n/**\n * list_hook - Find hook strings matching\n * @param[out] matches List of hook strings\n * @param[in]  match   String to match\n * @param[in]  type    Hook type, see #HookFlags\n */\nstatic void list_hook(struct ListHead *matches, const char *match, HookFlags type)\n{\n  struct Hook *tmp = NULL;\n\n  TAILQ_FOREACH(tmp, &Hooks, entries)\n  {\n    if ((tmp->type & type) && mutt_regex_match(&tmp->regex, match))\n    {\n      mutt_list_insert_tail(matches, mutt_str_dup(tmp->command));\n    }\n  }\n}\n\n/**\n * mutt_crypt_hook - Find crypto hooks for an Address\n * @param[out] list List of keys\n * @param[in]  addr Address to match\n *\n * The crypt-hook associates keys with addresses.\n */\nvoid mutt_crypt_hook(struct ListHead *list, struct Address *addr)\n{\n  list_hook(list, buf_string(addr->mailbox), MUTT_CRYPT_HOOK);\n}\n\n/**\n * mutt_account_hook - Perform an account hook\n * @param url Account URL to match\n */\nvoid mutt_account_hook(const char *url)\n{\n  /* parsing commands with URLs in an account hook can cause a recursive\n   * call. We just skip processing if this occurs. Typically such commands\n   * belong in a folder-hook -- perhaps we should warn the user. */\n  static bool inhook = false;\n  if (inhook)\n    return;\n\n  struct Hook *hook = NULL;\n  struct Buffer *err = buf_pool_get();\n\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!(hook->command && (hook->type & MUTT_ACCOUNT_HOOK)))\n      continue;\n\n    if (mutt_regex_match(&hook->regex, url))\n    {\n      inhook = true;\n      mutt_debug(LL_DEBUG1, \"account-hook '%s' matches '%s'\\n\", hook->regex.pattern, url);\n      mutt_debug(LL_DEBUG5, \"    %s\\n\", hook->command);\n\n      if (parse_rc_line_cwd(hook->command, hook->source_file, err) == MUTT_CMD_ERROR)\n      {\n        mutt_error(\"%s\", buf_string(err));\n        buf_pool_release(&err);\n\n        inhook = false;\n        goto done;\n      }\n\n      inhook = false;\n    }\n  }\ndone:\n  buf_pool_release(&err);\n}\n\n/**\n * mutt_timeout_hook - Execute any timeout hooks\n *\n * The user can configure hooks to be run on timeout.\n * This function finds all the matching hooks and executes them.\n */\nvoid mutt_timeout_hook(void)\n{\n  struct Hook *hook = NULL;\n  struct Buffer *err = buf_pool_get();\n\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!(hook->command && (hook->type & MUTT_TIMEOUT_HOOK)))\n      continue;\n\n    if (parse_rc_line_cwd(hook->command, hook->source_file, err) == MUTT_CMD_ERROR)\n    {\n      mutt_error(\"%s\", buf_string(err));\n      buf_reset(err);\n\n      /* The hooks should be independent of each other, so even though this on\n       * failed, we'll carry on with the others. */\n    }\n  }\n  buf_pool_release(&err);\n\n  /* Delete temporary attachment files */\n  mutt_temp_attachments_cleanup();\n}\n\n/**\n * mutt_startup_shutdown_hook - Execute any startup/shutdown hooks\n * @param type Hook type: #MUTT_STARTUP_HOOK or #MUTT_SHUTDOWN_HOOK\n *\n * The user can configure hooks to be run on startup/shutdown.\n * This function finds all the matching hooks and executes them.\n */\nvoid mutt_startup_shutdown_hook(HookFlags type)\n{\n  struct Hook *hook = NULL;\n  struct Buffer *err = buf_pool_get();\n\n  TAILQ_FOREACH(hook, &Hooks, entries)\n  {\n    if (!(hook->command && (hook->type & type)))\n      continue;\n\n    if (parse_rc_line_cwd(hook->command, hook->source_file, err) == MUTT_CMD_ERROR)\n    {\n      mutt_error(\"%s\", buf_string(err));\n      buf_reset(err);\n    }\n  }\n  buf_pool_release(&err);\n}\n\n/**\n * mutt_idxfmt_hook - Get index-format-hook format string\n * @param name Hook name\n * @param m    Mailbox\n * @param e    Email\n * @retval ptr  Expando\n * @retval NULL No matching hook\n */\nconst struct Expando *mutt_idxfmt_hook(const char *name, struct Mailbox *m, struct Email *e)\n{\n  if (!IdxFmtHooks)\n    return NULL;\n\n  struct HookList *hl = mutt_hash_find(IdxFmtHooks, name);\n  if (!hl)\n    return NULL;\n\n  CurrentHookType = MUTT_IDXFMTHOOK;\n\n  struct PatternCache cache = { 0 };\n  const struct Expando *exp = NULL;\n  struct Hook *hook = NULL;\n\n  TAILQ_FOREACH(hook, hl, entries)\n  {\n    struct Pattern *pat = SLIST_FIRST(hook->pattern);\n    if ((mutt_pattern_exec(pat, 0, m, e, &cache) > 0) ^ hook->regex.pat_not)\n    {\n      exp = hook->expando;\n      break;\n    }\n  }\n\n  CurrentHookType = MUTT_HOOK_NO_FLAGS;\n\n  return exp;\n}\n\n/**\n * HookCommands - Hook Commands\n */\nstatic const struct Command HookCommands[] = {\n  // clang-format off\n  { \"account-hook\",      mutt_parse_hook,               MUTT_ACCOUNT_HOOK },\n  { \"charset-hook\",      mutt_parse_charset_iconv_hook, MUTT_CHARSET_HOOK },\n  { \"crypt-hook\",        mutt_parse_hook,               MUTT_CRYPT_HOOK },\n  { \"fcc-hook\",          mutt_parse_hook,               MUTT_FCC_HOOK },\n  { \"fcc-save-hook\",     mutt_parse_hook,               MUTT_FCC_HOOK | MUTT_SAVE_HOOK },\n  { \"folder-hook\",       mutt_parse_hook,               MUTT_FOLDER_HOOK },\n  { \"iconv-hook\",        mutt_parse_charset_iconv_hook, MUTT_ICONV_HOOK },\n  { \"index-format-hook\", mutt_parse_idxfmt_hook,        MUTT_IDXFMTHOOK },\n  { \"mbox-hook\",         mutt_parse_hook,               MUTT_MBOX_HOOK },\n  { \"message-hook\",      mutt_parse_hook,               MUTT_MESSAGE_HOOK },\n  { \"pgp-hook\",          mutt_parse_hook,               MUTT_CRYPT_HOOK },\n  { \"reply-hook\",        mutt_parse_hook,               MUTT_REPLY_HOOK },\n  { \"save-hook\",         mutt_parse_hook,               MUTT_SAVE_HOOK },\n  { \"send-hook\",         mutt_parse_hook,               MUTT_SEND_HOOK },\n  { \"send2-hook\",        mutt_parse_hook,               MUTT_SEND2_HOOK },\n  { \"shutdown-hook\",     mutt_parse_hook,               MUTT_SHUTDOWN_HOOK | MUTT_GLOBAL_HOOK },\n  { \"startup-hook\",      mutt_parse_hook,               MUTT_STARTUP_HOOK | MUTT_GLOBAL_HOOK },\n  { \"timeout-hook\",      mutt_parse_hook,               MUTT_TIMEOUT_HOOK | MUTT_GLOBAL_HOOK },\n  { \"unhook\",            mutt_parse_unhook,             0 },\n  // clang-format on\n};\n\n/**\n * hooks_init - Setup feature commands\n */\nvoid hooks_init(void)\n{\n  commands_register(HookCommands, mutt_array_size(HookCommands));\n}\n"
        },
        {
          "name": "hook.h",
          "type": "blob",
          "size": 3.94921875,
          "content": "/**\n * @file\n * Parse and execute user-defined hooks\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_HOOK_H\n#define MUTT_HOOK_H\n\n#include \"config.h\"\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Address;\nstruct Buffer;\nstruct Email;\nstruct ListHead;\n\ntypedef uint32_t HookFlags;          ///< Flags for mutt_parse_hook(), e.g. #MUTT_FOLDER_HOOK\n#define MUTT_HOOK_NO_FLAGS       0   ///< No flags are set\n#define MUTT_FOLDER_HOOK   (1 << 0)  ///< folder-hook: when entering a mailbox\n#define MUTT_MBOX_HOOK     (1 << 1)  ///< mbox-hook: move messages after reading them\n#define MUTT_SEND_HOOK     (1 << 2)  ///< send-hook: when composing a new email\n#define MUTT_FCC_HOOK      (1 << 3)  ///< fcc-hook: to save outgoing email\n#define MUTT_SAVE_HOOK     (1 << 4)  ///< save-hook: set a default folder when saving an email\n#define MUTT_CHARSET_HOOK  (1 << 5)  ///< charset-hook: create a charset alias for malformed emails\n#define MUTT_ICONV_HOOK    (1 << 6)  ///< iconv-hook: create a system charset alias\n#define MUTT_MESSAGE_HOOK  (1 << 7)  ///< message-hook: run before displaying a message\n#define MUTT_CRYPT_HOOK    (1 << 8)  ///< crypt-hook: automatically select a PGP/SMIME key\n#define MUTT_ACCOUNT_HOOK  (1 << 9)  ///< account-hook: when changing between accounts\n#define MUTT_REPLY_HOOK    (1 << 10) ///< reply-hook: when replying to an email\n#define MUTT_SEND2_HOOK    (1 << 11) ///< send2-hook: when changing fields in the compose menu\n#define MUTT_OPEN_HOOK     (1 << 12) ///< open-hook: to read a compressed mailbox\n#define MUTT_APPEND_HOOK   (1 << 13) ///< append-hook: append to a compressed mailbox\n#define MUTT_CLOSE_HOOK    (1 << 14) ///< close-hook: write to a compressed mailbox\n#define MUTT_IDXFMTHOOK    (1 << 15) ///< index-format-hook: customise the format of the index\n#define MUTT_TIMEOUT_HOOK  (1 << 16) ///< timeout-hook: run a command periodically\n#define MUTT_STARTUP_HOOK  (1 << 17) ///< startup-hook: run when starting NeoMutt\n#define MUTT_SHUTDOWN_HOOK (1 << 18) ///< shutdown-hook: run when leaving NeoMutt\n#define MUTT_GLOBAL_HOOK   (1 << 19) ///< Hooks which don't take a regex\n\nvoid hooks_init(void);\nenum CommandResult mutt_parse_hook(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\n\nvoid                  mutt_account_hook            (const char *url);\nvoid                  mutt_crypt_hook              (struct ListHead *list, struct Address *addr);\nvoid                  mutt_default_save            (struct Buffer *path, struct Email *e);\nvoid                  mutt_delete_hooks            (HookFlags type);\nchar *                mutt_find_hook               (HookFlags type, const char *pat);\nvoid                  mutt_folder_hook             (const char *path, const char *desc);\nconst struct Expando *mutt_idxfmt_hook             (const char *name, struct Mailbox *m, struct Email *e);\nvoid                  mutt_message_hook            (struct Mailbox *m, struct Email *e, HookFlags type);\nenum CommandResult    mutt_parse_charset_iconv_hook(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nvoid                  mutt_select_fcc              (struct Buffer *path, struct Email *e);\nvoid                  mutt_startup_shutdown_hook   (HookFlags type);\nvoid                  mutt_timeout_hook            (void);\n\n#endif /* MUTT_HOOK_H */\n"
        },
        {
          "name": "imap",
          "type": "tree",
          "content": null
        },
        {
          "name": "index",
          "type": "tree",
          "content": null
        },
        {
          "name": "init.c",
          "type": "blob",
          "size": 17.5947265625,
          "content": "/**\n * @file\n * Config/command parsing\n *\n * @authors\n * Copyright (C) 1996-2002,2010,2013,2016 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2018-2022 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2018-2024 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2023 Rayford Shireman\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_init Config/command parsing\n *\n * Config/command parsing\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"init.h\"\n#include \"color/lib.h\"\n#include \"compmbox/lib.h\"\n#include \"history/lib.h\"\n#include \"imap/lib.h\"\n#include \"key/lib.h\"\n#include \"menu/lib.h\"\n#include \"notmuch/lib.h\"\n#include \"parse/lib.h\"\n#include \"sidebar/lib.h\"\n#include \"commands.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"mutt_logging.h\"\n#include \"muttlib.h\"\n#include \"protos.h\"\n#ifndef DOMAIN\n#include \"conn/lib.h\"\n#endif\n#ifdef USE_LUA\n#include \"mutt_lua.h\"\n#endif\n\n/**\n * execute_commands - Execute a set of NeoMutt commands\n * @param p List of command strings\n * @retval  0 Success, all the commands succeeded\n * @retval -1 Error\n */\nstatic int execute_commands(struct ListHead *p)\n{\n  int rc = 0;\n  struct Buffer *err = buf_pool_get();\n\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, p, entries)\n  {\n    enum CommandResult rc2 = parse_rc_line(np->data, err);\n    if (rc2 == MUTT_CMD_ERROR)\n      mutt_error(_(\"Error in command line: %s\"), buf_string(err));\n    else if (rc2 == MUTT_CMD_WARNING)\n      mutt_warning(_(\"Warning in command line: %s\"), buf_string(err));\n\n    if ((rc2 == MUTT_CMD_ERROR) || (rc2 == MUTT_CMD_WARNING))\n    {\n      buf_pool_release(&err);\n      return -1;\n    }\n  }\n  buf_pool_release(&err);\n\n  return rc;\n}\n\n/**\n * find_cfg - Find a config file\n * @param home         User's home directory\n * @param xdg_cfg_home XDG home directory\n * @retval ptr  Success, first matching directory\n * @retval NULL Error, no matching directories\n */\nstatic char *find_cfg(const char *home, const char *xdg_cfg_home)\n{\n  const char *names[] = {\n    \"neomuttrc\",\n    \"muttrc\",\n    NULL,\n  };\n\n  const char *locations[][2] = {\n    { xdg_cfg_home, \"neomutt/\" },\n    { xdg_cfg_home, \"mutt/\" },\n    { home, \".neomutt/\" },\n    { home, \".mutt/\" },\n    { home, \".\" },\n    { NULL, NULL },\n  };\n\n  for (int i = 0; locations[i][0] || locations[i][1]; i++)\n  {\n    if (!locations[i][0])\n      continue;\n\n    for (int j = 0; names[j]; j++)\n    {\n      char buf[256] = { 0 };\n\n      snprintf(buf, sizeof(buf), \"%s/%s%s\", locations[i][0], locations[i][1], names[j]);\n      if (access(buf, F_OK) == 0)\n        return mutt_str_dup(buf);\n    }\n  }\n\n  return NULL;\n}\n\n#ifndef DOMAIN\n/**\n * getmailname - Try to retrieve the FQDN from mailname files\n * @retval ptr Heap allocated string with the FQDN\n * @retval NULL No valid mailname file could be read\n */\nstatic char *getmailname(void)\n{\n  char *mailname = NULL;\n  static const char *mn_files[] = { \"/etc/mailname\", \"/etc/mail/mailname\" };\n\n  for (size_t i = 0; i < mutt_array_size(mn_files); i++)\n  {\n    FILE *fp = mutt_file_fopen(mn_files[i], \"r\");\n    if (!fp)\n      continue;\n\n    size_t len = 0;\n    mailname = mutt_file_read_line(NULL, &len, fp, NULL, MUTT_RL_NO_FLAGS);\n    mutt_file_fclose(&fp);\n    if (mailname && *mailname)\n      break;\n\n    FREE(&mailname);\n  }\n\n  return mailname;\n}\n#endif\n\n/**\n * get_hostname - Find the Fully-Qualified Domain Name\n * @param cs Config Set\n * @retval true  Success\n * @retval false Error, failed to find any name\n *\n * Use several methods to try to find the Fully-Qualified domain name of this host.\n * If the user has already configured a hostname, this function will use it.\n */\nstatic bool get_hostname(struct ConfigSet *cs)\n{\n  const char *short_host = NULL;\n  struct utsname utsname = { 0 };\n\n  const char *const c_hostname = cs_subset_string(NeoMutt->sub, \"hostname\");\n  if (c_hostname)\n  {\n    short_host = c_hostname;\n  }\n  else\n  {\n    /* The call to uname() shouldn't fail, but if it does, the system is horribly\n     * broken, and the system's networking configuration is in an unreliable\n     * state.  We should bail.  */\n    if ((uname(&utsname)) == -1)\n    {\n      mutt_perror(_(\"unable to determine nodename via uname()\"));\n      return false; // TEST09: can't test\n    }\n\n    short_host = utsname.nodename;\n  }\n\n  /* some systems report the FQDN instead of just the hostname */\n  char *dot = strchr(short_host, '.');\n  if (dot)\n    ShortHostname = mutt_strn_dup(short_host, dot - short_host);\n  else\n    ShortHostname = mutt_str_dup(short_host);\n\n  // All the code paths from here alloc memory for the fqdn\n  char *fqdn = mutt_str_dup(c_hostname);\n  if (!fqdn)\n  {\n    mutt_debug(LL_DEBUG1, \"Setting $hostname\\n\");\n    /* now get FQDN.  Use configured domain first, DNS next, then uname */\n#ifdef DOMAIN\n    /* we have a compile-time domain name, use that for `$hostname` */\n    mutt_str_asprintf(&fqdn, \"%s.%s\", NONULL(ShortHostname), DOMAIN);\n#else\n    fqdn = getmailname();\n    if (!fqdn)\n    {\n      struct Buffer *domain = buf_pool_get();\n      if (getdnsdomainname(domain) == 0)\n      {\n        mutt_str_asprintf(&fqdn, \"%s.%s\", NONULL(ShortHostname), buf_string(domain));\n      }\n      else\n      {\n        /* DNS failed, use the nodename.  Whether or not the nodename had a '.'\n         * in it, we can use the nodename as the FQDN.  On hosts where DNS is\n         * not being used, e.g. small network that relies on hosts files, a\n         * short host name is all that is required for SMTP to work correctly.\n         * It could be wrong, but we've done the best we can, at this point the\n         * onus is on the user to provide the correct hostname if the nodename\n         * won't work in their network.  */\n        fqdn = mutt_str_dup(utsname.nodename);\n      }\n      buf_pool_release(&domain);\n      mutt_debug(LL_DEBUG1, \"Hostname: %s\\n\", NONULL(fqdn));\n    }\n#endif\n  }\n\n  if (fqdn)\n  {\n    cs_str_initial_set(cs, \"hostname\", fqdn, NULL);\n    cs_str_reset(cs, \"hostname\", NULL);\n    FREE(&fqdn);\n  }\n\n  return true;\n}\n\n/**\n * mutt_opts_cleanup - Clean up before quitting\n */\nvoid mutt_opts_cleanup(void)\n{\n  source_stack_cleanup();\n\n  alias_cleanup();\n  sb_cleanup();\n\n  mutt_regexlist_free(&MailLists);\n  mutt_regexlist_free(&NoSpamList);\n  mutt_regexlist_free(&SubscribedLists);\n  mutt_regexlist_free(&UnMailLists);\n  mutt_regexlist_free(&UnSubscribedLists);\n\n  mutt_grouplist_cleanup();\n  driver_tags_cleanup();\n\n  /* Lists of strings */\n  mutt_list_free(&AlternativeOrderList);\n  mutt_list_free(&AutoViewList);\n  mutt_list_free(&HeaderOrderList);\n  mutt_list_free(&Ignore);\n  mutt_list_free(&MailToAllow);\n  mutt_list_free(&MimeLookupList);\n  mutt_list_free(&Muttrc);\n  mutt_list_free(&UnIgnore);\n  mutt_list_free(&UserHeader);\n\n  colors_cleanup();\n\n  FREE(&CurrentFolder);\n  FREE(&HomeDir);\n  FREE(&LastFolder);\n  FREE(&ShortHostname);\n  FREE(&Username);\n\n  mutt_replacelist_free(&SpamList);\n\n  mutt_delete_hooks(MUTT_HOOK_NO_FLAGS);\n\n  mutt_hist_cleanup();\n  mutt_keys_cleanup();\n\n  mutt_regexlist_free(&NoSpamList);\n  commands_cleanup();\n}\n\n/**\n * mutt_init - Initialise NeoMutt\n * @param cs          Config Set\n * @param dlevel      Command line debug level\n * @param dfile       Command line debug file\n * @param skip_sys_rc If true, don't read the system config file\n * @param commands    List of config commands to execute\n * @retval 0 Success\n * @retval 1 Error\n */\nint mutt_init(struct ConfigSet *cs, const char *dlevel, const char *dfile,\n              bool skip_sys_rc, struct ListHead *commands)\n{\n  bool need_pause = false;\n  int rc = 1;\n  struct Buffer *err = buf_pool_get();\n  struct Buffer *buf = buf_pool_get();\n\n  mutt_grouplist_init();\n  alias_init();\n  commands_init();\n  hooks_init();\n  mutt_comp_init();\n  imap_init();\n#ifdef USE_LUA\n  mutt_lua_init();\n#endif\n  driver_tags_init();\n\n  menu_init();\n  sb_init();\n#ifdef USE_NOTMUCH\n  nm_init();\n#endif\n\n#ifdef NEOMUTT_DIRECT_COLORS\n  /* Test if we run in a terminal which supports direct colours.\n   *\n   * The user/terminal can indicate their capability independent of the\n   * terminfo file by setting the COLORTERM environment variable to \"truecolor\"\n   * or \"24bit\" (case sensitive).\n   *\n   * Note: This is to test is less about whether the terminal understands\n   * direct color commands but more about whether ncurses believes it can send\n   * them to the terminal, e.g. ncurses ignores COLORTERM.\n   */\n  if (COLORS == 16777216) // 2^24\n  {\n    /* Ncurses believes the Terminal supports it check the environment variable\n     * to respect the user's choice */\n    const char *env_colorterm = mutt_str_getenv(\"COLORTERM\");\n    if (env_colorterm && (mutt_str_equal(env_colorterm, \"truecolor\") ||\n                          mutt_str_equal(env_colorterm, \"24bit\")))\n    {\n      cs_str_initial_set(cs, \"color_directcolor\", \"yes\", NULL);\n      cs_str_reset(cs, \"color_directcolor\", NULL);\n    }\n  }\n#endif\n\n  /* \"$spool_file\" precedence: config file, environment */\n  const char *p = mutt_str_getenv(\"MAIL\");\n  if (!p)\n    p = mutt_str_getenv(\"MAILDIR\");\n  if (!p)\n  {\n#ifdef HOMESPOOL\n    buf_concat_path(buf, NONULL(HomeDir), MAILPATH);\n#else\n    buf_concat_path(buf, MAILPATH, NONULL(Username));\n#endif\n    p = buf_string(buf);\n  }\n  cs_str_initial_set(cs, \"spool_file\", p, NULL);\n  cs_str_reset(cs, \"spool_file\", NULL);\n\n  p = mutt_str_getenv(\"REPLYTO\");\n  if (p)\n  {\n    struct Buffer *token = buf_pool_get();\n\n    buf_printf(buf, \"Reply-To: %s\", p);\n    buf_seek(buf, 0);\n    parse_my_hdr(token, buf, 0, err); /* adds to UserHeader */\n    buf_pool_release(&token);\n  }\n\n  p = mutt_str_getenv(\"EMAIL\");\n  if (p)\n  {\n    cs_str_initial_set(cs, \"from\", p, NULL);\n    cs_str_reset(cs, \"from\", NULL);\n  }\n\n  /* \"$mailcap_path\" precedence: config file, environment, code */\n  const char *env_mc = mutt_str_getenv(\"MAILCAPS\");\n  if (env_mc)\n  {\n    cs_str_initial_set(cs, \"mailcap_path\", env_mc, NULL);\n    cs_str_reset(cs, \"mailcap_path\", NULL);\n  }\n\n  /* \"$tmp_dir\" precedence: config file, environment, code */\n  const char *env_tmp = mutt_str_getenv(\"TMPDIR\");\n  if (env_tmp)\n  {\n    cs_str_initial_set(cs, \"tmp_dir\", env_tmp, NULL);\n    cs_str_reset(cs, \"tmp_dir\", NULL);\n  }\n\n  /* \"$visual\", \"$editor\" precedence: config file, environment, code */\n  const char *env_ed = mutt_str_getenv(\"VISUAL\");\n  if (!env_ed)\n    env_ed = mutt_str_getenv(\"EDITOR\");\n  if (!env_ed)\n    env_ed = \"vi\";\n  cs_str_initial_set(cs, \"editor\", env_ed, NULL);\n\n  const char *const c_editor = cs_subset_string(NeoMutt->sub, \"editor\");\n  if (!c_editor)\n    cs_str_reset(cs, \"editor\", NULL);\n\n  const char *charset = mutt_ch_get_langinfo_charset();\n  cs_str_initial_set(cs, \"charset\", charset, NULL);\n  cs_str_reset(cs, \"charset\", NULL);\n  mutt_ch_set_charset(charset);\n  FREE(&charset);\n\n  char name[256] = { 0 };\n  const char *c_real_name = cs_subset_string(NeoMutt->sub, \"real_name\");\n  if (!c_real_name)\n  {\n    struct passwd *pw = getpwuid(getuid());\n    if (pw)\n    {\n      c_real_name = mutt_gecos_name(name, sizeof(name), pw);\n    }\n  }\n  cs_str_initial_set(cs, \"real_name\", c_real_name, NULL);\n  cs_str_reset(cs, \"real_name\", NULL);\n\n#ifdef HAVE_GETSID\n  /* Unset suspend by default if we're the session leader */\n  if (getsid(0) == getpid())\n  {\n    cs_str_initial_set(cs, \"suspend\", \"no\", NULL);\n    cs_str_reset(cs, \"suspend\", NULL);\n  }\n#endif\n\n  /* RFC2368, \"4. Unsafe headers\"\n   * The creator of a mailto URL can't expect the resolver of a URL to\n   * understand more than the \"subject\" and \"body\" headers. Clients that\n   * resolve mailto URLs into mail messages should be able to correctly\n   * create RFC822-compliant mail messages using the \"subject\" and \"body\"\n   * headers.  */\n  add_to_stailq(&MailToAllow, \"body\");\n  add_to_stailq(&MailToAllow, \"subject\");\n  /* Cc, In-Reply-To, and References help with not breaking threading on\n   * mailing lists, see https://github.com/neomutt/neomutt/issues/115 */\n  add_to_stailq(&MailToAllow, \"cc\");\n  add_to_stailq(&MailToAllow, \"in-reply-to\");\n  add_to_stailq(&MailToAllow, \"references\");\n\n  if (STAILQ_EMPTY(&Muttrc))\n  {\n    const char *xdg_cfg_home = mutt_str_getenv(\"XDG_CONFIG_HOME\");\n\n    if (!xdg_cfg_home && HomeDir)\n    {\n      buf_printf(buf, \"%s/.config\", HomeDir);\n      xdg_cfg_home = buf_string(buf);\n    }\n\n    char *config = find_cfg(HomeDir, xdg_cfg_home);\n    if (config)\n    {\n      mutt_list_insert_tail(&Muttrc, config);\n    }\n  }\n  else\n  {\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &Muttrc, entries)\n    {\n      buf_strcpy(buf, np->data);\n      FREE(&np->data);\n      buf_expand_path(buf);\n      np->data = buf_strdup(buf);\n      if (access(np->data, F_OK))\n      {\n        mutt_perror(\"%s\", np->data);\n        goto done; // TEST10: neomutt -F missing\n      }\n    }\n  }\n\n  if (!STAILQ_EMPTY(&Muttrc))\n  {\n    cs_str_string_set(cs, \"alias_file\", STAILQ_FIRST(&Muttrc)->data, NULL);\n  }\n\n  /* Process the global rc file if it exists and the user hasn't explicitly\n   * requested not to via \"-n\".  */\n  if (!skip_sys_rc)\n  {\n    do\n    {\n      if (mutt_set_xdg_path(XDG_CONFIG_DIRS, buf))\n        break;\n\n      buf_printf(buf, \"%s/neomuttrc\", SYSCONFDIR);\n      if (access(buf_string(buf), F_OK) == 0)\n        break;\n\n      buf_printf(buf, \"%s/Muttrc\", SYSCONFDIR);\n      if (access(buf_string(buf), F_OK) == 0)\n        break;\n\n      buf_printf(buf, \"%s/neomuttrc\", PKGDATADIR);\n      if (access(buf_string(buf), F_OK) == 0)\n        break;\n\n      buf_printf(buf, \"%s/Muttrc\", PKGDATADIR);\n    } while (false);\n\n    if (access(buf_string(buf), F_OK) == 0)\n    {\n      if (source_rc(buf_string(buf), err) != 0)\n      {\n        mutt_error(\"%s\", buf_string(err));\n        need_pause = true; // TEST11: neomutt (error in /etc/neomuttrc)\n      }\n    }\n  }\n\n  /* Read the user's initialization file.  */\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, &Muttrc, entries)\n  {\n    if (np->data)\n    {\n      if (source_rc(np->data, err) != 0)\n      {\n        mutt_error(\"%s\", buf_string(err));\n        need_pause = true; // TEST12: neomutt (error in ~/.neomuttrc)\n      }\n    }\n  }\n\n  if (execute_commands(commands) != 0)\n    need_pause = true; // TEST13: neomutt -e broken\n\n  if (!get_hostname(cs))\n    goto done;\n\n  /* The command line overrides the config */\n  if (dlevel)\n    cs_str_reset(cs, \"debug_level\", NULL);\n  if (dfile)\n    cs_str_reset(cs, \"debug_file\", NULL);\n\n  if (mutt_log_start() < 0)\n  {\n    mutt_perror(\"log file\");\n    goto done;\n  }\n\n  if (need_pause && !OptNoCurses)\n  {\n    log_queue_flush(log_disp_terminal);\n    if (mutt_any_key_to_continue(NULL) == 'q')\n      goto done; // TEST14: neomutt -e broken (press 'q')\n  }\n\n  const char *const c_tmp_dir = cs_subset_path(NeoMutt->sub, \"tmp_dir\");\n  if (mutt_file_mkdir(c_tmp_dir, S_IRWXU) < 0)\n  {\n    mutt_error(_(\"Can't create %s: %s\"), c_tmp_dir, strerror(errno));\n    goto done;\n  }\n\n  mutt_hist_init();\n  mutt_hist_read_file();\n\n#ifdef USE_NOTMUCH\n  const bool c_virtual_spool_file = cs_subset_bool(NeoMutt->sub, \"virtual_spool_file\");\n  if (c_virtual_spool_file)\n  {\n    /* Find the first virtual folder and open it */\n    struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n    neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_NOTMUCH);\n    struct MailboxNode *mp = STAILQ_FIRST(&ml);\n    if (mp)\n      cs_str_string_set(cs, \"spool_file\", mailbox_path(mp->mailbox), NULL);\n    neomutt_mailboxlist_clear(&ml);\n  }\n#endif\n  rc = 0;\n\ndone:\n  buf_pool_release(&err);\n  buf_pool_release(&buf);\n  return rc;\n}\n\n/**\n * mutt_query_variables - Implement the -Q command line flag\n * @param queries   List of query strings\n * @param show_docs If true, show one-liner docs for the config item\n * @retval 0 Success, all queries exist\n * @retval 1 Error\n */\nint mutt_query_variables(struct ListHead *queries, bool show_docs)\n{\n  struct Buffer *value = buf_pool_get();\n  struct Buffer *tmp = buf_pool_get();\n  int rc = 0;\n\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, queries, entries)\n  {\n    buf_reset(value);\n\n    struct HashElem *he = cs_subset_lookup(NeoMutt->sub, np->data);\n    if (he)\n    {\n      if (he->type & D_INTERNAL_DEPRECATED)\n      {\n        mutt_warning(_(\"Option %s is deprecated\"), np->data);\n        rc = 1;\n        continue;\n      }\n\n      int rv = cs_subset_he_string_get(NeoMutt->sub, he, value);\n      if (CSR_RESULT(rv) != CSR_SUCCESS)\n      {\n        rc = 1;\n        continue;\n      }\n\n      int type = DTYPE(he->type);\n      if (type == DT_PATH)\n        mutt_pretty_mailbox(value->data, value->dsize);\n\n      if ((type != DT_BOOL) && (type != DT_NUMBER) && (type != DT_LONG) && (type != DT_QUAD))\n      {\n        buf_reset(tmp);\n        pretty_var(buf_string(value), tmp);\n        buf_copy(value, tmp);\n      }\n\n      const bool tty = isatty(STDOUT_FILENO);\n\n      ConfigDumpFlags cdflags = CS_DUMP_NO_FLAGS;\n      if (tty)\n        cdflags |= CS_DUMP_LINK_DOCS;\n      if (show_docs)\n        cdflags |= CS_DUMP_SHOW_DOCS;\n\n      dump_config_neo(NeoMutt->sub->cs, he, value, NULL, cdflags, stdout);\n      continue;\n    }\n\n    mutt_warning(_(\"Unknown option %s\"), np->data);\n    rc = 1;\n  }\n\n  buf_pool_release(&value);\n  buf_pool_release(&tmp);\n\n  return rc; // TEST16: neomutt -Q charset\n}\n"
        },
        {
          "name": "init.h",
          "type": "blob",
          "size": 1.3291015625,
          "content": "/**\n * @file\n * Config/command parsing\n *\n * @authors\n * Copyright (C) 1996-2002,2007,2010,2012-2013,2016 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2004 g10 Code GmbH\n * Copyright (C) 2019-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_INIT_H\n#define MUTT_INIT_H\n\n#include <stdbool.h>\n#include \"mutt/lib.h\"\n\nstruct ConfigSet;\n\nextern const struct Mapping SortMethods[];\n\nvoid init_config         (struct ConfigSet *cs);\nint  mutt_init           (struct ConfigSet *cs, const char *dlevel, const char *dfile, bool skip_sys_rc, struct ListHead *commands);\nvoid mutt_opts_cleanup   (void);\nint  mutt_query_variables(struct ListHead *queries, bool show_docs);\n\n#endif /* MUTT_INIT_H */\n"
        },
        {
          "name": "key",
          "type": "tree",
          "content": null
        },
        {
          "name": "mailcap.c",
          "type": "blob",
          "size": 18.39453125,
          "content": "/**\n * @file\n * RFC1524 Mailcap routines\n *\n * @authors\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Federico Kircheis <federico.kircheis@gmail.com>\n * Copyright (C) 2018-2021 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mailcap RFC1524 Mailcap routines\n *\n * RFC1524 defines a format for the Multimedia Mail Configuration, which is the\n * standard mailcap file format under Unix which specifies what external\n * programs should be used to view/compose/edit multimedia files based on\n * content type.\n *\n * This file contains various functions for implementing a fair subset of\n * RFC1524.\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"mailcap.h\"\n#include \"attach/lib.h\"\n#include \"muttlib.h\"\n#include \"protos.h\"\n\n/**\n * mailcap_expand_command - Expand expandos in a command\n * @param b        Email Body\n * @param filename File containing the email text\n * @param type     Type, e.g. \"text/plain\"\n * @param command  Buffer containing command\n * @retval 0 Command works on a file\n * @retval 1 Command works on a pipe\n *\n * The command semantics include the following:\n * %s is the filename that contains the mail body data\n * %t is the content type, like text/plain\n * %{parameter} is replaced by the parameter value from the content-type field\n * \\% is %\n * Unsupported rfc1524 parameters: these would probably require some doing\n * by neomutt, and can probably just be done by piping the message to metamail\n * %n is the integer number of sub-parts in the multipart\n * %F is \"content-type filename\" repeated for each sub-part\n */\nint mailcap_expand_command(struct Body *b, const char *filename,\n                           const char *type, struct Buffer *command)\n{\n  int needspipe = true;\n  struct Buffer *buf = buf_pool_get();\n  struct Buffer *quoted = buf_pool_get();\n  struct Buffer *param = NULL;\n  struct Buffer *type2 = NULL;\n\n  const bool c_mailcap_sanitize = cs_subset_bool(NeoMutt->sub, \"mailcap_sanitize\");\n  const char *cptr = buf_string(command);\n  while (*cptr)\n  {\n    if (*cptr == '\\\\')\n    {\n      cptr++;\n      if (*cptr)\n        buf_addch(buf, *cptr++);\n    }\n    else if (*cptr == '%')\n    {\n      cptr++;\n      if (*cptr == '{')\n      {\n        const char *pvalue2 = NULL;\n\n        if (param)\n          buf_reset(param);\n        else\n          param = buf_pool_get();\n\n        /* Copy parameter name into param buffer */\n        cptr++;\n        while (*cptr && (*cptr != '}'))\n          buf_addch(param, *cptr++);\n\n        /* In send mode, use the current charset, since the message hasn't\n         * been converted yet.   If noconv is set, then we assume the\n         * charset parameter has the correct value instead. */\n        if (mutt_istr_equal(buf_string(param), \"charset\") && b->charset && !b->noconv)\n          pvalue2 = b->charset;\n        else\n          pvalue2 = mutt_param_get(&b->parameter, buf_string(param));\n\n        /* Now copy the parameter value into param buffer */\n        if (c_mailcap_sanitize)\n          buf_sanitize_filename(param, NONULL(pvalue2), false);\n        else\n          buf_strcpy(param, pvalue2);\n\n        buf_quote_filename(quoted, buf_string(param), true);\n        buf_addstr(buf, buf_string(quoted));\n      }\n      else if ((*cptr == 's') && filename)\n      {\n        buf_quote_filename(quoted, filename, true);\n        buf_addstr(buf, buf_string(quoted));\n        needspipe = false;\n      }\n      else if (*cptr == 't')\n      {\n        if (!type2)\n        {\n          type2 = buf_pool_get();\n          if (c_mailcap_sanitize)\n            buf_sanitize_filename(type2, type, false);\n          else\n            buf_strcpy(type2, type);\n        }\n        buf_quote_filename(quoted, buf_string(type2), true);\n        buf_addstr(buf, buf_string(quoted));\n      }\n\n      if (*cptr)\n        cptr++;\n    }\n    else\n    {\n      buf_addch(buf, *cptr++);\n    }\n  }\n  buf_copy(command, buf);\n\n  buf_pool_release(&buf);\n  buf_pool_release(&quoted);\n  buf_pool_release(&param);\n  buf_pool_release(&type2);\n\n  return needspipe;\n}\n\n/**\n * get_field - NUL terminate a RFC1524 field\n * @param s String to alter\n * @retval ptr  Start of next field\n * @retval NULL Error\n */\nstatic char *get_field(char *s)\n{\n  if (!s)\n    return NULL;\n\n  char *ch = NULL;\n\n  while ((ch = strpbrk(s, \";\\\\\")))\n  {\n    if (*ch == '\\\\')\n    {\n      s = ch + 1;\n      if (*s)\n        s++;\n    }\n    else\n    {\n      *ch = '\\0';\n      ch = mutt_str_skip_email_wsp(ch + 1);\n      break;\n    }\n  }\n  mutt_str_remove_trailing_ws(s);\n  return ch;\n}\n\n/**\n * get_field_text - Get the matching text from a mailcap\n * @param field    String to parse\n * @param entry    Save the entry here\n * @param type     Type, e.g. \"text/plain\"\n * @param filename Mailcap filename\n * @param line     Mailcap line\n * @retval 1 Success\n * @retval 0 Failure\n */\nstatic int get_field_text(char *field, char **entry, const char *type,\n                          const char *filename, int line)\n{\n  field = mutt_str_skip_whitespace(field);\n  if (*field == '=')\n  {\n    if (entry)\n    {\n      field++;\n      field = mutt_str_skip_whitespace(field);\n      mutt_str_replace(entry, field);\n    }\n    return 1;\n  }\n  else\n  {\n    mutt_error(_(\"Improperly formatted entry for type %s in \\\"%s\\\" line %d\"),\n               type, filename, line);\n    return 0;\n  }\n}\n\n/**\n * rfc1524_mailcap_parse - Parse a mailcap entry\n * @param b        Email Body\n * @param filename Filename\n * @param type     Type, e.g. \"text/plain\"\n * @param entry    Entry, e.g. \"compose\"\n * @param opt      Option, see #MailcapLookup\n * @retval true  Success\n * @retval false Failure\n */\nstatic bool rfc1524_mailcap_parse(struct Body *b, const char *filename, const char *type,\n                                  struct MailcapEntry *entry, enum MailcapLookup opt)\n{\n  char *buf = NULL;\n  bool found = false;\n  int line = 0;\n\n  /* rfc1524 mailcap file is of the format:\n   * base/type; command; extradefs\n   * type can be * for matching all\n   * base with no /type is an implicit wild\n   * command contains a %s for the filename to pass, default to pipe on stdin\n   * extradefs are of the form:\n   *  def1=\"definition\"; def2=\"define \\;\";\n   * line wraps with a \\ at the end of the line\n   * # for comments */\n\n  /* find length of basetype */\n  char *ch = strchr(type, '/');\n  if (!ch)\n    return false;\n  const int btlen = ch - type;\n\n  FILE *fp = mutt_file_fopen(filename, \"r\");\n  if (fp)\n  {\n    size_t buflen;\n    while (!found && (buf = mutt_file_read_line(buf, &buflen, fp, &line, MUTT_RL_CONT)))\n    {\n      /* ignore comments */\n      if (*buf == '#')\n        continue;\n      mutt_debug(LL_DEBUG2, \"mailcap entry: %s\\n\", buf);\n\n      /* check type */\n      ch = get_field(buf);\n      if (!mutt_istr_equal(buf, type) && (!mutt_istrn_equal(buf, type, btlen) ||\n                                          ((buf[btlen] != '\\0') && /* implicit wild */\n                                           !mutt_str_equal(buf + btlen, \"/*\")))) /* wildsubtype */\n      {\n        continue;\n      }\n\n      /* next field is the viewcommand */\n      char *field = ch;\n      ch = get_field(ch);\n      if (entry)\n        entry->command = mutt_str_dup(field);\n\n      /* parse the optional fields */\n      found = true;\n      bool copiousoutput = false;\n      bool composecommand = false;\n      bool editcommand = false;\n      bool printcommand = false;\n\n      while (ch)\n      {\n        field = ch;\n        ch = get_field(ch);\n        mutt_debug(LL_DEBUG2, \"field: %s\\n\", field);\n        size_t plen;\n\n        if (mutt_istr_equal(field, \"needsterminal\"))\n        {\n          if (entry)\n            entry->needsterminal = true;\n        }\n        else if (mutt_istr_equal(field, \"copiousoutput\"))\n        {\n          copiousoutput = true;\n          if (entry)\n            entry->copiousoutput = true;\n        }\n        else if ((plen = mutt_istr_startswith(field, \"composetyped\")))\n        {\n          /* this compare most occur before compose to match correctly */\n          if (get_field_text(field + plen, entry ? &entry->composetypecommand : NULL,\n                             type, filename, line))\n          {\n            composecommand = true;\n          }\n        }\n        else if ((plen = mutt_istr_startswith(field, \"compose\")))\n        {\n          if (get_field_text(field + plen, entry ? &entry->composecommand : NULL,\n                             type, filename, line))\n          {\n            composecommand = true;\n          }\n        }\n        else if ((plen = mutt_istr_startswith(field, \"print\")))\n        {\n          if (get_field_text(field + plen, entry ? &entry->printcommand : NULL,\n                             type, filename, line))\n          {\n            printcommand = true;\n          }\n        }\n        else if ((plen = mutt_istr_startswith(field, \"edit\")))\n        {\n          if (get_field_text(field + plen, entry ? &entry->editcommand : NULL,\n                             type, filename, line))\n          {\n            editcommand = true;\n          }\n        }\n        else if ((plen = mutt_istr_startswith(field, \"nametemplate\")))\n        {\n          get_field_text(field + plen, entry ? &entry->nametemplate : NULL,\n                         type, filename, line);\n        }\n        else if ((plen = mutt_istr_startswith(field, \"x-convert\")))\n        {\n          get_field_text(field + plen, entry ? &entry->convert : NULL, type, filename, line);\n        }\n        else if ((plen = mutt_istr_startswith(field, \"test\")))\n        {\n          /* This routine executes the given test command to determine\n           * if this is the right entry.  */\n          char *test_command = NULL;\n\n          if (get_field_text(field + plen, &test_command, type, filename, line) && test_command)\n          {\n            struct Buffer *command = buf_pool_get();\n            struct Buffer *afilename = buf_pool_get();\n            buf_strcpy(command, test_command);\n            const bool c_mailcap_sanitize = cs_subset_bool(NeoMutt->sub, \"mailcap_sanitize\");\n            if (c_mailcap_sanitize)\n              buf_sanitize_filename(afilename, NONULL(b->filename), true);\n            else\n              buf_strcpy(afilename, b->filename);\n            if (mailcap_expand_command(b, buf_string(afilename), type, command) == 1)\n            {\n              mutt_debug(LL_DEBUG1, \"mailcap command needs a pipe: %s\\n\",\n                         buf_string(command));\n            }\n\n            if (mutt_system(buf_string(command)))\n            {\n              /* a non-zero exit code means test failed */\n              found = false;\n            }\n            FREE(&test_command);\n            buf_pool_release(&command);\n            buf_pool_release(&afilename);\n          }\n        }\n        else if (mutt_istr_startswith(field, \"x-neomutt-keep\"))\n        {\n          if (entry)\n            entry->xneomuttkeep = true;\n        }\n        else if (mutt_istr_startswith(field, \"x-neomutt-nowrap\"))\n        {\n          if (entry)\n            entry->xneomuttnowrap = true;\n          b->nowrap = true;\n        }\n      } /* while (ch) */\n\n      if (opt == MUTT_MC_AUTOVIEW)\n      {\n        if (!copiousoutput)\n          found = false;\n      }\n      else if (opt == MUTT_MC_COMPOSE)\n      {\n        if (!composecommand)\n          found = false;\n      }\n      else if (opt == MUTT_MC_EDIT)\n      {\n        if (!editcommand)\n          found = false;\n      }\n      else if (opt == MUTT_MC_PRINT)\n      {\n        if (!printcommand)\n          found = false;\n      }\n\n      if (!found)\n      {\n        /* reset */\n        if (entry)\n        {\n          FREE(&entry->command);\n          FREE(&entry->composecommand);\n          FREE(&entry->composetypecommand);\n          FREE(&entry->editcommand);\n          FREE(&entry->printcommand);\n          FREE(&entry->nametemplate);\n          FREE(&entry->convert);\n          entry->needsterminal = false;\n          entry->copiousoutput = false;\n          entry->xneomuttkeep = false;\n        }\n      }\n    }\n    mutt_file_fclose(&fp);\n  }\n\n  FREE(&buf);\n  return found;\n}\n\n/**\n * mailcap_entry_new - Allocate memory for a new rfc1524 entry\n * @retval ptr An un-initialized struct MailcapEntry\n */\nstruct MailcapEntry *mailcap_entry_new(void)\n{\n  return MUTT_MEM_CALLOC(1, struct MailcapEntry);\n}\n\n/**\n * mailcap_entry_free - Deallocate an struct MailcapEntry\n * @param[out] ptr MailcapEntry to deallocate\n */\nvoid mailcap_entry_free(struct MailcapEntry **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct MailcapEntry *me = *ptr;\n\n  FREE(&me->command);\n  FREE(&me->testcommand);\n  FREE(&me->composecommand);\n  FREE(&me->composetypecommand);\n  FREE(&me->editcommand);\n  FREE(&me->printcommand);\n  FREE(&me->nametemplate);\n  FREE(ptr);\n}\n\n/**\n * mailcap_lookup - Find given type in the list of mailcap files\n * @param b      Message body\n * @param type   Text type in \"type/subtype\" format\n * @param typelen Length of the type\n * @param entry  struct MailcapEntry to populate with results\n * @param opt    Type of mailcap entry to lookup, see #MailcapLookup\n * @retval true  If *entry is not NULL it populates it with the mailcap entry\n * @retval false No matching entry is found\n *\n * Find the given type in the list of mailcap files.\n */\nbool mailcap_lookup(struct Body *b, char *type, size_t typelen,\n                    struct MailcapEntry *entry, enum MailcapLookup opt)\n{\n  /* rfc1524 specifies that a path of mailcap files should be searched.\n   * joy.  They say\n   * $HOME/.mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap, etc\n   * and overridden by the MAILCAPS environment variable, and, just to be nice,\n   * we'll make it specifiable in .neomuttrc */\n  const struct Slist *c_mailcap_path = cs_subset_slist(NeoMutt->sub, \"mailcap_path\");\n  if (!c_mailcap_path || (c_mailcap_path->count == 0))\n  {\n    /* L10N:\n       Mutt is trying to look up a mailcap value, but $mailcap_path is empty.\n       We added a reference to the MAILCAPS environment variable as a hint too.\n\n       Because the variable is automatically populated by Mutt, this\n       should only occur if the user deliberately runs in their shell:\n         export MAILCAPS=\n\n       or deliberately runs inside Mutt or their .muttrc:\n         set mailcap_path=\"\"\n         -or-\n         unset mailcap_path\n    */\n    mutt_error(_(\"Neither mailcap_path nor MAILCAPS specified\"));\n    return false;\n  }\n\n  mutt_check_lookup_list(b, type, typelen);\n\n  struct Buffer *path = buf_pool_get();\n  bool found = false;\n\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, &c_mailcap_path->head, entries)\n  {\n    buf_strcpy(path, np->data);\n    buf_expand_path(path);\n\n    mutt_debug(LL_DEBUG2, \"Checking mailcap file: %s\\n\", buf_string(path));\n    found = rfc1524_mailcap_parse(b, buf_string(path), type, entry, opt);\n    if (found)\n      break;\n  }\n\n  buf_pool_release(&path);\n\n  if (entry && !found)\n    mutt_error(_(\"mailcap entry for type %s not found\"), type);\n\n  return found;\n}\n\n/**\n * mailcap_expand_filename - Expand a new filename from a template or existing filename\n * @param nametemplate Template\n * @param oldfile      Original filename\n * @param newfile      Buffer for new filename\n *\n * If there is no nametemplate, the stripped oldfile name is used as the\n * template for newfile.\n *\n * If there is no oldfile, the stripped nametemplate name is used as the\n * template for newfile.\n *\n * If both a nametemplate and oldfile are specified, the template is checked\n * for a \"%s\". If none is found, the nametemplate is used as the template for\n * newfile.  The first path component of the nametemplate and oldfile are ignored.\n */\nvoid mailcap_expand_filename(const char *nametemplate, const char *oldfile,\n                             struct Buffer *newfile)\n{\n  int i, j, k;\n  char *s = NULL;\n  bool lmatch = false, rmatch = false;\n\n  buf_reset(newfile);\n\n  /* first, ignore leading path components */\n\n  if (nametemplate && (s = strrchr(nametemplate, '/')))\n    nametemplate = s + 1;\n\n  if (oldfile && (s = strrchr(oldfile, '/')))\n    oldfile = s + 1;\n\n  if (!nametemplate)\n  {\n    if (oldfile)\n      buf_strcpy(newfile, oldfile);\n  }\n  else if (!oldfile)\n  {\n    mutt_file_expand_fmt(newfile, nametemplate, \"neomutt\");\n  }\n  else /* oldfile && nametemplate */\n  {\n    /* first, compare everything left from the \"%s\"\n     * (if there is one).  */\n\n    lmatch = true;\n    bool ps = false;\n    for (i = 0; nametemplate[i]; i++)\n    {\n      if ((nametemplate[i] == '%') && (nametemplate[i + 1] == 's'))\n      {\n        ps = true;\n        break;\n      }\n\n      /* note that the following will _not_ read beyond oldfile's end. */\n\n      if (lmatch && (nametemplate[i] != oldfile[i]))\n        lmatch = false;\n    }\n\n    if (ps)\n    {\n      /* If we had a \"%s\", check the rest. */\n\n      /* now, for the right part: compare everything right from\n       * the \"%s\" to the final part of oldfile.\n       *\n       * The logic here is as follows:\n       *\n       * - We start reading from the end.\n       * - There must be a match _right_ from the \"%s\",\n       *   thus the i + 2.\n       * - If there was a left hand match, this stuff\n       *   must not be counted again.  That's done by the\n       *   condition (j >= (lmatch ? i : 0)).  */\n\n      rmatch = true;\n\n      for (j = mutt_str_len(oldfile) - 1, k = mutt_str_len(nametemplate) - 1;\n           (j >= (lmatch ? i : 0)) && (k >= (i + 2)); j--, k--)\n      {\n        if (nametemplate[k] != oldfile[j])\n        {\n          rmatch = false;\n          break;\n        }\n      }\n\n      /* Now, check if we had a full match. */\n\n      if (k >= i + 2)\n        rmatch = false;\n\n      struct Buffer *left = buf_pool_get();\n      struct Buffer *right = buf_pool_get();\n\n      if (!lmatch)\n        buf_strcpy_n(left, nametemplate, i);\n      if (!rmatch)\n        buf_strcpy(right, nametemplate + i + 2);\n      buf_printf(newfile, \"%s%s%s\", buf_string(left), oldfile, buf_string(right));\n\n      buf_pool_release(&left);\n      buf_pool_release(&right);\n    }\n    else\n    {\n      /* no \"%s\" in the name template. */\n      buf_strcpy(newfile, nametemplate);\n    }\n  }\n\n  mutt_adv_mktemp(newfile);\n}\n"
        },
        {
          "name": "mailcap.h",
          "type": "blob",
          "size": 2.2236328125,
          "content": "/**\n * @file\n * RFC1524 Mailcap routines\n *\n * @authors\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2021 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MAILCAP_H\n#define MUTT_MAILCAP_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct Body;\nstruct Buffer;\n\n/**\n * struct MailcapEntry - A mailcap entry\n */\nstruct MailcapEntry\n{\n  char *command;\n  char *testcommand;\n  char *composecommand;\n  char *composetypecommand;\n  char *editcommand;\n  char *printcommand;\n  char *nametemplate;\n  char *convert;\n  bool needsterminal : 1; ///< endwin() and system\n  bool copiousoutput : 1; ///< needs pager, basically\n  bool xneomuttkeep  : 1; ///< do not remove the file on command exit\n  bool xneomuttnowrap: 1; ///< do not wrap the output in the pager\n};\n\n/**\n * enum MailcapLookup - Mailcap actions\n */\nenum MailcapLookup\n{\n  MUTT_MC_NO_FLAGS = 0, ///< No flags set\n  MUTT_MC_EDIT,         ///< Mailcap edit field\n  MUTT_MC_COMPOSE,      ///< Mailcap compose field\n  MUTT_MC_PRINT,        ///< Mailcap print field\n  MUTT_MC_AUTOVIEW,     ///< Mailcap autoview field\n};\n\nvoid                 mailcap_entry_free(struct MailcapEntry **ptr);\nstruct MailcapEntry *mailcap_entry_new(void);\nint                  mailcap_expand_command(struct Body *b, const char *filename, const char *type, struct Buffer *command);\nvoid                 mailcap_expand_filename(const char *nametemplate, const char *oldfile, struct Buffer *newfile);\nbool                 mailcap_lookup(struct Body *b, char *type, size_t typelen, struct MailcapEntry *entry, enum MailcapLookup opt);\n\n#endif /* MUTT_MAILCAP_H */\n"
        },
        {
          "name": "maildir",
          "type": "tree",
          "content": null
        },
        {
          "name": "maillist.c",
          "type": "blob",
          "size": 3.8330078125,
          "content": "/**\n * @file\n * Handle mailing lists\n *\n * @authors\n * Copyright (C) 2020 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2023 Anna Figueiredo Gomes <navi@vlhl.dev>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_maillist Handle mailing lists\n *\n * Handle mailing lists\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"email/lib.h\"\n#include \"maillist.h\"\n#include \"muttlib.h\"\n\n/**\n * mutt_is_mail_list - Is this the email address of a mailing list? - Implements ::addr_predicate_t - @ingroup addr_predicate_api\n * @param addr Address to test\n * @retval true It's a mailing list\n */\nbool mutt_is_mail_list(const struct Address *addr)\n{\n  if (!mutt_regexlist_match(&UnMailLists, buf_string(addr->mailbox)))\n    return mutt_regexlist_match(&MailLists, buf_string(addr->mailbox));\n  return false;\n}\n\n/**\n * mutt_is_subscribed_list - Is this the email address of a user-subscribed mailing list? - Implements ::addr_predicate_t - @ingroup addr_predicate_api\n * @param addr Address to test\n * @retval true It's a subscribed mailing list\n */\nbool mutt_is_subscribed_list(const struct Address *addr)\n{\n  if (!mutt_regexlist_match(&UnMailLists, buf_string(addr->mailbox)) &&\n      !mutt_regexlist_match(&UnSubscribedLists, buf_string(addr->mailbox)))\n  {\n    return mutt_regexlist_match(&SubscribedLists, buf_string(addr->mailbox));\n  }\n  return false;\n}\n\n/**\n * check_for_mailing_list - Search list of addresses for a mailing list\n * @param al      AddressList to search\n * @param pfx     Prefix string\n * @param buf     Buffer to store results\n * @param buflen  Buffer length\n * @retval 1 Mailing list found\n * @retval 0 No list found\n *\n * Search for a mailing list in the list of addresses pointed to by addr.\n * If one is found, print pfx and the name of the list into buf.\n */\nbool check_for_mailing_list(struct AddressList *al, const char *pfx, char *buf, int buflen)\n{\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    if (mutt_is_subscribed_list(a))\n    {\n      if (pfx && buf && buflen)\n        snprintf(buf, buflen, \"%s%s\", pfx, mutt_get_name(a));\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * check_for_mailing_list_addr - Check an address list for a mailing list\n * @param al     AddressList\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n * @retval true Mailing list found\n *\n * If one is found, print the address of the list into buf.\n */\nbool check_for_mailing_list_addr(struct AddressList *al, char *buf, int buflen)\n{\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    if (mutt_is_subscribed_list(a))\n    {\n      if (buf && buflen)\n        snprintf(buf, buflen, \"%s\", buf_string(a->mailbox));\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * first_mailing_list - Get the first mailing list in the list of addresses\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n * @param al     AddressList\n * @retval true A mailing list was found\n */\nbool first_mailing_list(char *buf, size_t buflen, struct AddressList *al)\n{\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    if (mutt_is_subscribed_list(a))\n    {\n      mutt_save_path(buf, buflen, a);\n      return true;\n    }\n  }\n  return false;\n}\n"
        },
        {
          "name": "maillist.h",
          "type": "blob",
          "size": 1.2900390625,
          "content": "/**\n * @file\n * Handle mailing lists\n *\n * @authors\n * Copyright (C) 2020 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MAILLIST_H\n#define MUTT_MAILLIST_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct Address;\nstruct AddressList;\n\nbool check_for_mailing_list     (struct AddressList *al, const char *pfx, char *buf, int buflen);\nbool check_for_mailing_list_addr(struct AddressList *al, char *buf, int buflen);\nbool first_mailing_list         (char *buf, size_t buflen, struct AddressList *al);\nbool mutt_is_mail_list          (const struct Address *addr);\nbool mutt_is_subscribed_list    (const struct Address *addr);\n\n#endif /* MUTT_MAILLIST_H */\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 45.6640625,
          "content": "/**\n * @file\n * Command line processing\n *\n * @authors\n * Copyright (C) 1996-2007,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2007 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2004 g10 Code GmbH\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017-2023 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2020 R Primus <rprimus@gmail.com>\n * Copyright (C) 2023 Dennis Schön <mail@dennis-schoen.de>\n * Copyright (C) 2024 Alejandro Colomar <alx@kernel.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @mainpage Code Docs\n *\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"structs.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"pages.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"globals.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"functions.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"enums.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"members.svg\">\n * <img style=\"float: left; padding-right: 0.5em;\" src=\"defines.svg\">\n * <br>\n *\n * ## Libraries\n *\n * [Each library](pages.html) helps to untangle the code by grouping similar\n * functions and reducing dependencies.\n *\n * The goal is that each library is:\n * - Self-contained (it may rely on other libraries)\n * - Independently testable (i.e. without using NeoMutt)\n * - Fully documented\n * - Robust\n *\n * Libraries:\n * @ref lib_address, @ref lib_alias, @ref lib_attach, @ref lib_autocrypt,\n * @ref lib_bcache, @ref lib_browser, @ref lib_color, @ref lib_complete,\n * @ref lib_compmbox, @ref lib_compose, @ref lib_compress, @ref lib_config,\n * @ref lib_conn, @ref lib_convert, @ref lib_core, @ref lib_editor,\n * @ref lib_email, @ref lib_envelope, @ref lib_expando, @ref lib_gui,\n * @ref lib_hcache, @ref lib_helpbar, @ref lib_history, @ref lib_imap,\n * @ref lib_index, @ref lib_key, @ref lib_maildir, @ref lib_mh, @ref lib_mbox,\n * @ref lib_menu, @ref lib_mutt, @ref lib_ncrypt,\n * @ref lib_nntp, @ref lib_notmuch, @ref lib_pager, @ref lib_parse,\n * @ref lib_pattern, @ref lib_pop, @ref lib_postpone, @ref lib_progress,\n * @ref lib_question, @ref lib_send, @ref lib_sidebar, @ref lib_store.\n *\n * ## Miscellaneous files\n *\n * These file form the main body of NeoMutt.\n *\n * | File            | Description                |\n * | :-------------- | :------------------------- |\n * | alternates.c    | @subpage neo_alternates    |\n * | commands.c      | @subpage neo_commands      |\n * | copy.c          | @subpage neo_copy          |\n * | editmsg.c       | @subpage neo_editmsg       |\n * | enriched.c      | @subpage neo_enriched      |\n * | external.c      | @subpage neo_external      |\n * | flags.c         | @subpage neo_flags         |\n * | globals.c       | @subpage neo_globals       |\n * | handler.c       | @subpage neo_handler       |\n * | help.c          | @subpage neo_help          |\n * | hook.c          | @subpage neo_hook          |\n * | init.c          | @subpage neo_init          |\n * | mailcap.c       | @subpage neo_mailcap       |\n * | maillist.c      | @subpage neo_maillist      |\n * | main.c          | @subpage neo_main          |\n * | monitor.c       | @subpage neo_monitor       |\n * | muttlib.c       | @subpage neo_muttlib       |\n * | mutt_body.c     | @subpage neo_mutt_body     |\n * | mutt_config.c   | @subpage neo_mutt_config   |\n * | mutt_header.c   | @subpage neo_mutt_header   |\n * | mutt_logging.c  | @subpage neo_mutt_logging  |\n * | mutt_lua.c      | @subpage neo_mutt_lua      |\n * | mutt_mailbox.c  | @subpage neo_mutt_mailbox  |\n * | mutt_signal.c   | @subpage neo_mutt_signal   |\n * | mutt_socket.c   | @subpage neo_mutt_socket   |\n * | mutt_thread.c   | @subpage neo_mutt_thread   |\n * | mview.c         | @subpage neo_mview         |\n * | mx.c            | @subpage neo_mx            |\n * | recvcmd.c       | @subpage neo_recvcmd       |\n * | rfc3676.c       | @subpage neo_rfc3676       |\n * | score.c         | @subpage neo_score         |\n * | subjectrx.c     | @subpage neo_subjrx        |\n * | system.c        | @subpage neo_system        |\n * | timegm.c        | @subpage neo_timegm        |\n * | version.c       | @subpage neo_version       |\n * | wcscasecmp.c    | @subpage neo_wcscasecmp    |\n *\n * ## Building these Docs\n *\n * The config for building the docs is in the main source repo.\n *\n * Everything possible is turned on in the config file, so you'll need to\n * install a few dependencies like `dot` from the graphviz package.\n *\n * ## Installing the Docs\n *\n * These docs aren't in the main website repo -- they weigh in at 100MB.\n * Instead, they're stored in the [code repo](https://github.com/neomutt/code)\n */\n\n/**\n * @page neo_main Command line processing\n *\n * Command line processing\n */\n\n#define GNULIB_defined_setlocale\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <locale.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"attach/lib.h\"\n#include \"browser/lib.h\"\n#include \"color/lib.h\"\n#include \"history/lib.h\"\n#include \"imap/lib.h\"\n#include \"index/lib.h\"\n#include \"key/lib.h\"\n#include \"menu/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"nntp/lib.h\"\n#include \"pop/lib.h\"\n#include \"postpone/lib.h\"\n#include \"question/lib.h\"\n#include \"send/lib.h\"\n#include \"alternates.h\"\n#include \"external.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"init.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_mailbox.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"nntp/adata.h\" // IWYU pragma: keep\n#include \"protos.h\"\n#include \"subjectrx.h\"\n#include \"version.h\"\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n#ifdef USE_AUTOCRYPT\n#include \"autocrypt/lib.h\"\n#endif\n#if defined(USE_DEBUG_NOTIFY) || defined(USE_DEBUG_BACKTRACE)\n#include \"debug/lib.h\"\n#endif\n\nbool StartupComplete = false; ///< When the config has been read\n\n// clang-format off\ntypedef uint8_t CliFlags;         ///< Flags for command line options, e.g. #MUTT_CLI_IGNORE\n#define MUTT_CLI_NO_FLAGS      0  ///< No flags are set\n#define MUTT_CLI_IGNORE  (1 << 0) ///< -z Open first mailbox if it has mail\n#define MUTT_CLI_MAILBOX (1 << 1) ///< -Z Open first mailbox if is has new mail\n#define MUTT_CLI_NOSYSRC (1 << 2) ///< -n Do not read the system-wide config file\n#define MUTT_CLI_RO      (1 << 3) ///< -R Open mailbox in read-only mode\n#define MUTT_CLI_SELECT  (1 << 4) ///< -y Start with a list of all mailboxes\n#define MUTT_CLI_NEWS    (1 << 5) ///< -g/-G Start with a list of all newsgroups\n// clang-format on\n\n/**\n * reset_tilde - Temporary measure\n * @param cs Config Set\n */\nstatic void reset_tilde(struct ConfigSet *cs)\n{\n  static const char *names[] = { \"folder\", \"mbox\", \"postponed\", \"record\" };\n\n  struct Buffer *value = buf_pool_get();\n  for (size_t i = 0; i < mutt_array_size(names); i++)\n  {\n    struct HashElem *he = cs_get_elem(cs, names[i]);\n    if (!he)\n      continue;\n    buf_reset(value);\n    cs_he_initial_get(cs, he, value);\n    buf_expand_path_regex(value, false);\n    cs_he_initial_set(cs, he, value->data, NULL);\n    cs_he_reset(cs, he, NULL);\n  }\n  buf_pool_release(&value);\n}\n\n#ifdef ENABLE_NLS\n/**\n * localise_config - Localise some config\n * @param cs Config Set\n */\nstatic void localise_config(struct ConfigSet *cs)\n{\n  static const char *names[] = {\n    \"attribution_intro\",\n    \"compose_format\",\n    \"forward_attribution_intro\",\n    \"forward_attribution_trailer\",\n    \"reply_regex\",\n    \"status_format\",\n    \"ts_icon_format\",\n    \"ts_status_format\",\n  };\n\n  struct Buffer *value = buf_pool_get();\n  for (size_t i = 0; i < mutt_array_size(names); i++)\n  {\n    struct HashElem *he = cs_get_elem(cs, names[i]);\n    if (!he)\n      continue;\n    buf_reset(value);\n    cs_he_initial_get(cs, he, value);\n\n    // Lookup the translation\n    const char *l10n = gettext(buf_string(value));\n\n    cs_he_initial_set(cs, he, l10n, NULL);\n    cs_he_reset(cs, he, NULL);\n  }\n  buf_pool_release(&value);\n}\n#endif\n\n/**\n * mutt_exit - Leave NeoMutt NOW\n * @param code Value to return to the calling environment\n */\nvoid mutt_exit(int code)\n{\n  mutt_endwin();\n#ifdef USE_DEBUG_BACKTRACE\n  if (code != 0)\n    show_backtrace();\n#endif\n  exit(code);\n}\n\n/**\n * usage - Display NeoMutt command line\n * @retval true Text displayed\n */\nstatic bool usage(void)\n{\n  puts(mutt_make_version());\n\n  // clang-format off\n  /* L10N: Try to limit to 80 columns */\n  puts(_(\"usage:\"));\n  puts(_(\"  neomutt [-CEn] [-e <command>] [-F <config>] [-H <draft>] [-i <include>]\\n\"\n         \"          [-b <address>] [-c <address>] [-s <subject>] [-a <file> [...] --]\\n\"\n         \"          <address> [...]\"));\n  puts(_(\"  neomutt [-Cn] [-e <command>] [-F <config>] [-b <address>] [-c <address>]\\n\"\n         \"          [-s <subject>] [-a <file> [...] --] <address> [...] < message\"));\n  puts(_(\"  neomutt [-nRy] [-e <command>] [-F <config>] [-f <mailbox>] [-m <type>]\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -A <alias>\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -B\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -D [-S] [-O]\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -d <level> -l <file>\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -G\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -g <server>\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -p\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -Q <variable> [-O]\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -Z\"));\n  puts(_(\"  neomutt [-n] [-e <command>] [-F <config>] -z [-f <mailbox>]\"));\n  puts(_(\"  neomutt -v[v]\\n\"));\n\n  /* L10N: Try to limit to 80 columns.  If more space is needed add an indented line */\n  puts(_(\"options:\"));\n  puts(_(\"  --            Special argument forces NeoMutt to stop option parsing and treat\\n\"\n         \"                remaining arguments as addresses even if they start with a dash\"));\n  puts(_(\"  -A <alias>    Print an expanded version of the given alias to stdout and exit\"));\n  puts(_(\"  -a <file>     Attach one or more files to a message (must be the last option)\\n\"\n         \"                Add any addresses after the '--' argument\"));\n  puts(_(\"  -B            Run in batch mode (do not start the ncurses UI)\"));\n  puts(_(\"  -b <address>  Specify a blind carbon copy (Bcc) recipient\"));\n  puts(_(\"  -c <address>  Specify a carbon copy (Cc) recipient\"));\n  puts(_(\"  -C            Enable Command-line Crypto (signing/encryption)\"));\n  puts(_(\"  -D            Dump all config variables as 'name=value' pairs to stdout\"));\n  puts(_(\"  -D -O         Like -D, but show one-liner documentation\"));\n  puts(_(\"  -D -S         Like -D, but hide the value of sensitive variables\"));\n  puts(_(\"  -d <level>    Log debugging output to a file (default is \\\"~/.neomuttdebug0\\\")\\n\"\n         \"                The level can range from 1-5 and affects verbosity\"));\n  puts(_(\"  -E            Edit draft (-H) or include (-i) file during message composition\"));\n  puts(_(\"  -e <command>  Specify a command to be run after reading the config files\"));\n  puts(_(\"  -F <config>   Specify an alternative initialization file to read\"));\n  puts(_(\"  -f <mailbox>  Specify a mailbox (as defined with 'mailboxes' command) to load\"));\n  puts(_(\"  -G            Start NeoMutt with a listing of subscribed newsgroups\"));\n  puts(_(\"  -g <server>   Like -G, but start at specified news server\"));\n  puts(_(\"  -H <draft>    Specify a draft file with header and body for message composing\"));\n  puts(_(\"  -h            Print this help message and exit\"));\n  puts(_(\"  -i <include>  Specify an include file to be embedded in the body of a message\"));\n  puts(_(\"  -l <file>     Specify a file for debugging output (default \\\"~/.neomuttdebug0\\\")\"));\n  puts(_(\"  -m <type>     Specify a default mailbox format type for newly created folders\\n\"\n         \"                The type is either MH, MMDF, Maildir or mbox (case-insensitive)\"));\n  puts(_(\"  -n            Do not read the system-wide configuration file\"));\n  puts(_(\"  -p            Resume a prior postponed message, if any\"));\n  puts(_(\"  -Q <variable> Query a configuration variable and print its value to stdout\\n\"\n         \"                (after the config has been read and any commands executed)\\n\"\n         \"                Add -O for one-liner documentation\"));\n  puts(_(\"  -R            Open mailbox in read-only mode\"));\n  puts(_(\"  -s <subject>  Specify a subject (must be enclosed in quotes if it has spaces)\"));\n  puts(_(\"  -v            Print the NeoMutt version and compile-time definitions and exit\"));\n  puts(_(\"  -vv           Print the NeoMutt license and copyright information and exit\"));\n  puts(_(\"  -y            Start NeoMutt with a listing of all defined mailboxes\"));\n  puts(_(\"  -Z            Open the first mailbox with new message or exit immediately with\\n\"\n         \"                exit code 1 if none is found in all defined mailboxes\"));\n  puts(_(\"  -z            Open the first or specified (-f) mailbox if it holds any message\\n\"\n         \"                or exit immediately with exit code 1 otherwise\"));\n  // clang-format on\n\n  fflush(stdout);\n  return !ferror(stdout);\n}\n\n/**\n * start_curses - Start the Curses UI\n * @retval 0 Success\n * @retval 1 Failure\n */\nstatic int start_curses(void)\n{\n  km_init(); /* must come before mutt_init */\n\n  /* should come before initscr() so that ncurses 4.2 doesn't try to install\n   * its own SIGWINCH handler */\n  mutt_signal_init();\n\n  if (!initscr())\n  {\n    mutt_error(_(\"Error initializing terminal\"));\n    return 1;\n  }\n\n  colors_init();\n  keypad(stdscr, true);\n  cbreak();\n  noecho();\n  nonl();\n  typeahead(-1); /* simulate smooth scrolling */\n  meta(stdscr, true);\n  init_extended_keys();\n  /* Now that curses is set up, we drop back to normal screen mode.\n   * This simplifies displaying error messages to the user.\n   * The first call to refresh() will swap us back to curses screen mode. */\n  endwin();\n  return 0;\n}\n\n/**\n * init_locale - Initialise the Locale/NLS settings\n */\nstatic void init_locale(void)\n{\n  setlocale(LC_ALL, \"\");\n\n#ifdef ENABLE_NLS\n  const char *domdir = mutt_str_getenv(\"TEXTDOMAINDIR\");\n  if (domdir)\n    bindtextdomain(PACKAGE, domdir);\n  else\n    bindtextdomain(PACKAGE, MUTTLOCALEDIR);\n  textdomain(PACKAGE);\n#endif\n#ifndef LOCALES_HACK\n  /* Do we have a locale definition? */\n  if (mutt_str_getenv(\"LC_ALL\") || mutt_str_getenv(\"LANG\") || mutt_str_getenv(\"LC_CTYPE\"))\n  {\n    OptLocales = true;\n  }\n#endif\n}\n\n/**\n * get_user_info - Find the user's name, home and shell\n * @param cs Config Set\n * @retval true Success\n *\n * Find the login name, real name, home directory and shell.\n */\nstatic bool get_user_info(struct ConfigSet *cs)\n{\n  const char *shell = mutt_str_getenv(\"SHELL\");\n  if (shell)\n    cs_str_initial_set(cs, \"shell\", shell, NULL);\n\n  /* Get some information about the user */\n  struct passwd *pw = getpwuid(getuid());\n  if (pw)\n  {\n    if (!Username)\n      Username = mutt_str_dup(pw->pw_name);\n    if (!HomeDir)\n      HomeDir = mutt_str_dup(pw->pw_dir);\n    if (!shell)\n      cs_str_initial_set(cs, \"shell\", pw->pw_shell, NULL);\n  }\n\n  if (!Username)\n  {\n    mutt_error(_(\"unable to determine username\"));\n    return false; // TEST05: neomutt (unset $USER, delete user from /etc/passwd)\n  }\n\n  if (!HomeDir)\n  {\n    mutt_error(_(\"unable to determine home directory\"));\n    return false; // TEST06: neomutt (unset $HOME, delete user from /etc/passwd)\n  }\n\n  cs_str_reset(cs, \"shell\", NULL);\n  return true;\n}\n\n/**\n * log_translation - Log the translation being used\n *\n * Read the header info from the translation file.\n *\n * @note Call bindtextdomain() first\n */\nstatic void log_translation(void)\n{\n  const char *header = \"\"; // Do not merge these two lines\n  header = _(header);      // otherwise the .po files will end up badly ordered\n  const char *label = \"Language:\"; // the start of the lookup/needle\n  const char *lang = mutt_istr_find(header, label);\n  int len = 64;\n  if (lang)\n  {\n    lang += strlen(label); // skip label\n    SKIPWS(lang);\n    char *nl = strchr(lang, '\\n');\n    if (nl)\n      len = (nl - lang);\n  }\n  else\n  {\n    lang = \"NONE\";\n  }\n\n  mutt_debug(LL_DEBUG1, \"Translation: %.*s\\n\", len, lang);\n}\n\n/**\n * log_gui - Log info about the GUI\n */\nstatic void log_gui(void)\n{\n  const char *term = mutt_str_getenv(\"TERM\");\n  const char *color_term = mutt_str_getenv(\"COLORTERM\");\n  bool true_color = false;\n#ifdef NEOMUTT_DIRECT_COLORS\n  true_color = true;\n#endif\n\n  mutt_debug(LL_DEBUG1, \"GUI:\\n\");\n  mutt_debug(LL_DEBUG1, \"    Curses: %s\\n\", curses_version());\n  mutt_debug(LL_DEBUG1, \"    COLORS=%d\\n\", COLORS);\n  mutt_debug(LL_DEBUG1, \"    COLOR_PAIRS=%d\\n\", COLOR_PAIRS);\n  mutt_debug(LL_DEBUG1, \"    TERM=%s\\n\", NONULL(term));\n  mutt_debug(LL_DEBUG1, \"    COLORTERM=%s\\n\", NONULL(color_term));\n  mutt_debug(LL_DEBUG1, \"    True color support: %s\\n\", true_color ? \"YES\" : \"NO\");\n  mutt_debug(LL_DEBUG1, \"    Screen: %dx%d\\n\", RootWindow->state.cols,\n             RootWindow->state.rows);\n}\n\n/**\n * main_timeout_observer - Notification that a timeout has occurred - Implements ::observer_t - @ingroup observer_api\n */\nint main_timeout_observer(struct NotifyCallback *nc)\n{\n  static time_t last_run = 0;\n\n  if (nc->event_type != NT_TIMEOUT)\n    return 0;\n\n  const short c_timeout = cs_subset_number(NeoMutt->sub, \"timeout\");\n  if (c_timeout <= 0)\n    goto done;\n\n  time_t now = mutt_date_now();\n  if (now < (last_run + c_timeout))\n    goto done;\n\n  // Limit hook to running under the Index or Pager\n  struct MuttWindow *focus = window_get_focus();\n  struct MuttWindow *dlg = dialog_find(focus);\n  if (!dlg || (dlg->type != WT_DLG_INDEX))\n    goto done;\n\n  last_run = now;\n  mutt_timeout_hook();\n\ndone:\n  mutt_debug(LL_DEBUG5, \"timeout done\\n\");\n  return 0;\n}\n\n/**\n * main - Start NeoMutt\n * @param argc Number of command line arguments\n * @param argv List of command line arguments\n * @param envp Copy of the environment\n * @retval 0 Success\n * @retval 1 Error\n */\nint\n#ifdef ENABLE_FUZZ_TESTS\ndisabled_main\n#else\nmain\n#endif\n(int argc, char *argv[], char *envp[])\n{\n  char *subject = NULL;\n  char *include_file = NULL;\n  char *draft_file = NULL;\n  char *new_type = NULL;\n  char *dlevel = NULL;\n  char *dfile = NULL;\n  const char *cli_nntp = NULL;\n  struct Email *e = NULL;\n  struct ListHead attach = STAILQ_HEAD_INITIALIZER(attach);\n  struct ListHead commands = STAILQ_HEAD_INITIALIZER(commands);\n  struct ListHead queries = STAILQ_HEAD_INITIALIZER(queries);\n  struct ListHead alias_queries = STAILQ_HEAD_INITIALIZER(alias_queries);\n  struct ListHead cc_list = STAILQ_HEAD_INITIALIZER(cc_list);\n  struct ListHead bcc_list = STAILQ_HEAD_INITIALIZER(bcc_list);\n  SendFlags sendflags = SEND_NO_FLAGS;\n  CliFlags flags = MUTT_CLI_NO_FLAGS;\n  int version = 0;\n  int i;\n  bool explicit_folder = false;\n  bool dump_variables = false;\n  bool one_liner = false;\n  bool hide_sensitive = false;\n  bool batch_mode = false;\n  bool edit_infile = false;\n  int double_dash = argc, nargc = 1;\n  int rc = 1;\n  bool repeat_error = false;\n  struct Buffer *folder = buf_pool_get();\n  struct Buffer *expanded_infile = buf_pool_get();\n  struct Buffer *tempfile = buf_pool_get();\n  struct ConfigSet *cs = NULL;\n\n  MuttLogger = log_disp_terminal;\n\n  /* sanity check against stupid administrators */\n  if (getegid() != getgid())\n  {\n    mutt_error(\"%s: I don't want to run with privileges!\", (argc != 0) ? argv[0] : \"neomutt\");\n    goto main_exit; // TEST01: neomutt (as root, chgrp mail neomutt; chmod +s neomutt)\n  }\n\n  init_locale();\n\n  EnvList = envlist_init(envp);\n  for (optind = 1; optind < double_dash;)\n  {\n    /* We're getopt'ing POSIXLY, so we'll be here every time getopt()\n     * encounters a non-option.  That could be a file to attach\n     * (all non-options between -a and --) or it could be an address\n     * (which gets collapsed to the front of argv).  */\n    for (; optind < argc; optind++)\n    {\n      if ((argv[optind][0] == '-') && (argv[optind][1] != '\\0'))\n      {\n        if ((argv[optind][1] == '-') && (argv[optind][2] == '\\0'))\n          double_dash = optind; /* quit outer loop after getopt */\n        break;                  /* drop through to getopt */\n      }\n\n      /* non-option, either an attachment or address */\n      if (!STAILQ_EMPTY(&attach))\n        mutt_list_insert_tail(&attach, mutt_str_dup(argv[optind]));\n      else\n        argv[nargc++] = argv[optind];\n    }\n\n    i = getopt(argc, argv, \"+A:a:Bb:F:f:Cc:Dd:l:Ee:g:GH:i:hm:nOpQ:RSs:TvyzZ\");\n    if (i != EOF)\n    {\n      switch (i)\n      {\n        case 'A':\n          mutt_list_insert_tail(&alias_queries, mutt_str_dup(optarg));\n          break;\n        case 'a':\n          mutt_list_insert_tail(&attach, mutt_str_dup(optarg));\n          break;\n        case 'B':\n          batch_mode = true;\n          break;\n        case 'b':\n          mutt_list_insert_tail(&bcc_list, mutt_str_dup(optarg));\n          break;\n        case 'C':\n          sendflags |= SEND_CLI_CRYPTO;\n          break;\n        case 'c':\n          mutt_list_insert_tail(&cc_list, mutt_str_dup(optarg));\n          break;\n        case 'D':\n          dump_variables = true;\n          break;\n        case 'd':\n          dlevel = optarg;\n          break;\n        case 'E':\n          edit_infile = true;\n          break;\n        case 'e':\n          mutt_list_insert_tail(&commands, mutt_str_dup(optarg));\n          break;\n        case 'F':\n          mutt_list_insert_tail(&Muttrc, mutt_str_dup(optarg));\n          break;\n        case 'f':\n          buf_strcpy(folder, optarg);\n          explicit_folder = true;\n          break;\n        case 'g': /* Specify a news server */\n          cli_nntp = optarg;\n          FALLTHROUGH;\n\n        case 'G': /* List of newsgroups */\n          flags |= MUTT_CLI_SELECT | MUTT_CLI_NEWS;\n          break;\n        case 'H':\n          draft_file = optarg;\n          break;\n        case 'i':\n          include_file = optarg;\n          break;\n        case 'l':\n          dfile = optarg;\n          break;\n        case 'm':\n          new_type = optarg;\n          break;\n        case 'n':\n          flags |= MUTT_CLI_NOSYSRC;\n          break;\n        case 'O':\n          one_liner = true;\n          break;\n        case 'p':\n          sendflags |= SEND_POSTPONED;\n          break;\n        case 'Q':\n          mutt_list_insert_tail(&queries, mutt_str_dup(optarg));\n          break;\n        case 'R':\n          flags |= MUTT_CLI_RO; /* read-only mode */\n          break;\n        case 'S':\n          hide_sensitive = true;\n          break;\n        case 's':\n          subject = optarg;\n          break;\n        case 'v':\n          version++;\n          break;\n        case 'y': /* My special hack mode */\n          flags |= MUTT_CLI_SELECT;\n          break;\n        case 'Z':\n          flags |= MUTT_CLI_MAILBOX | MUTT_CLI_IGNORE;\n          break;\n        case 'z':\n          flags |= MUTT_CLI_IGNORE;\n          break;\n        default:\n          OptNoCurses = true;\n          if (usage())\n            goto main_ok; // TEST03: neomutt -9\n          else\n            goto main_curses;\n      }\n    }\n  }\n\n  /* collapse remaining argv */\n  while (optind < argc)\n    argv[nargc++] = argv[optind++];\n  optind = 1;\n  argc = nargc;\n\n  if (version > 0)\n  {\n    log_queue_flush(log_disp_terminal);\n    bool done;\n    if (version == 1)\n      done = print_version(stdout);\n    else\n      done = print_copyright();\n    OptNoCurses = true;\n    if (done)\n      goto main_ok; // TEST04: neomutt -v\n    else\n      goto main_curses;\n  }\n\n  mutt_str_replace(&Username, mutt_str_getenv(\"USER\"));\n  mutt_str_replace(&HomeDir, mutt_str_getenv(\"HOME\"));\n\n  cs = cs_new(500);\n  if (!cs)\n    goto main_curses;\n\n  NeoMutt = neomutt_new(cs);\n  init_config(cs);\n\n  // Change the current umask, and save the original one\n  NeoMutt->user_default_umask = umask(077);\n  subjrx_init();\n  attach_init();\n  alternates_init();\n\n#ifdef USE_DEBUG_NOTIFY\n  notify_observer_add(NeoMutt->notify, NT_ALL, debug_all_observer, NULL);\n#endif\n\n  if (!get_user_info(cs))\n    goto main_exit;\n\n  reset_tilde(cs);\n#ifdef ENABLE_NLS\n  localise_config(cs);\n#endif\n\n  if (dfile)\n  {\n    cs_str_initial_set(cs, \"debug_file\", dfile, NULL);\n    cs_str_reset(cs, \"debug_file\", NULL);\n  }\n\n  if (dlevel)\n  {\n    short num = 0;\n    if (!mutt_str_atos_full(dlevel, &num) || (num < LL_MESSAGE) || (num >= LL_MAX))\n    {\n      mutt_error(_(\"Error: value '%s' is invalid for -d\"), dlevel);\n      goto main_exit; // TEST07: neomutt -d xyz\n    }\n    cs_str_initial_set(cs, \"debug_level\", dlevel, NULL);\n    cs_str_reset(cs, \"debug_level\", NULL);\n  }\n\n  mutt_log_prep();\n  MuttLogger = log_disp_queue;\n  log_translation();\n  mutt_debug(LL_DEBUG1, \"user's umask %03o\\n\", NeoMutt->user_default_umask);\n  mutt_debug(LL_DEBUG3, \"umask set to 077\\n\");\n\n  if (!STAILQ_EMPTY(&cc_list) || !STAILQ_EMPTY(&bcc_list))\n  {\n    e = email_new();\n    e->env = mutt_env_new();\n\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &bcc_list, entries)\n    {\n      mutt_addrlist_parse(&e->env->bcc, np->data);\n    }\n\n    STAILQ_FOREACH(np, &cc_list, entries)\n    {\n      mutt_addrlist_parse(&e->env->cc, np->data);\n    }\n\n    mutt_list_free(&bcc_list);\n    mutt_list_free(&cc_list);\n  }\n\n  /* Check for a batch send. */\n  if (!isatty(0) || !STAILQ_EMPTY(&queries) || !STAILQ_EMPTY(&alias_queries) ||\n      dump_variables || batch_mode)\n  {\n    OptNoCurses = true;\n    sendflags |= SEND_BATCH;\n    MuttLogger = log_disp_terminal;\n    log_queue_flush(log_disp_terminal);\n  }\n\n  /* Check to make sure stdout is available in curses mode. */\n  if (!OptNoCurses && !isatty(1))\n    goto main_curses;\n\n  /* This must come before mutt_init() because curses needs to be started\n   * before calling the init_pair() function to set the color scheme.  */\n  if (!OptNoCurses)\n  {\n    int crc = start_curses();\n    if (crc != 0)\n      goto main_curses; // TEST08: can't test -- fake term?\n  }\n\n  /* Always create the mutt_windows because batch mode has some shared code\n   * paths that end up referencing them. */\n  rootwin_new();\n\n  if (!OptNoCurses)\n  {\n    /* check whether terminal status is supported (must follow curses init) */\n    TsSupported = mutt_ts_capability();\n    mutt_resize_screen();\n    log_gui();\n  }\n\n  /* set defaults and read init files */\n  int rc2 = mutt_init(cs, dlevel, dfile, flags & MUTT_CLI_NOSYSRC, &commands);\n  if (rc2 != 0)\n    goto main_curses;\n\n  mutt_init_abort_key();\n\n  /* \"$news_server\" precedence: command line, config file, environment, system file */\n  if (!cli_nntp)\n    cli_nntp = cs_subset_string(NeoMutt->sub, \"news_server\");\n\n  if (!cli_nntp)\n    cli_nntp = mutt_str_getenv(\"NNTPSERVER\");\n\n  if (!cli_nntp)\n  {\n    char buf[1024] = { 0 };\n    cli_nntp = mutt_file_read_keyword(SYSCONFDIR \"/nntpserver\", buf, sizeof(buf));\n  }\n\n  if (cli_nntp)\n  {\n    cs_str_initial_set(cs, \"news_server\", cli_nntp, NULL);\n    cs_str_reset(cs, \"news_server\", NULL);\n  }\n\n  /* Initialize crypto backends.  */\n  crypt_init();\n\n  if (new_type)\n  {\n    struct Buffer *err = buf_pool_get();\n    int r = cs_str_initial_set(cs, \"mbox_type\", new_type, err);\n    if (CSR_RESULT(r) != CSR_SUCCESS)\n    {\n      mutt_error(\"%s\", buf_string(err));\n      buf_pool_release(&err);\n      goto main_curses;\n    }\n    cs_str_reset(cs, \"mbox_type\", NULL);\n  }\n\n  if (!STAILQ_EMPTY(&queries))\n  {\n    rc = mutt_query_variables(&queries, one_liner);\n    goto main_curses;\n  }\n\n  if (dump_variables)\n  {\n    const bool tty = isatty(STDOUT_FILENO);\n\n    ConfigDumpFlags cdflags = CS_DUMP_NO_FLAGS;\n    if (tty)\n      cdflags |= CS_DUMP_LINK_DOCS;\n    if (hide_sensitive)\n      cdflags |= CS_DUMP_HIDE_SENSITIVE;\n    if (one_liner)\n      cdflags |= CS_DUMP_SHOW_DOCS;\n    dump_config(cs, cdflags, stdout);\n    goto main_ok; // TEST18: neomutt -D\n  }\n\n  if (!STAILQ_EMPTY(&alias_queries))\n  {\n    rc = 0;\n    for (; optind < argc; optind++)\n      mutt_list_insert_tail(&alias_queries, mutt_str_dup(argv[optind]));\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &alias_queries, entries)\n    {\n      struct AddressList *al = alias_lookup(np->data);\n      if (al)\n      {\n        /* output in machine-readable form */\n        mutt_addrlist_to_intl(al, NULL);\n        struct Buffer *buf = buf_pool_get();\n        mutt_addrlist_write(al, buf, false);\n        printf(\"%s\\n\", buf_string(buf));\n        buf_pool_release(&buf);\n      }\n      else\n      {\n        rc = 1;\n        printf(\"%s\\n\", NONULL(np->data)); // TEST19: neomutt -A unknown\n      }\n    }\n    mutt_list_free(&alias_queries);\n    goto main_curses; // TEST20: neomutt -A alias\n  }\n\n  if (!OptNoCurses)\n  {\n    mutt_curses_set_color_by_id(MT_COLOR_NORMAL);\n    clear();\n    MuttLogger = log_disp_curses;\n    log_queue_flush(log_disp_curses);\n    log_queue_set_max_size(100);\n  }\n\n#ifdef USE_AUTOCRYPT\n  /* Initialize autocrypt after curses messages are working,\n   * because of the initial account setup screens. */\n  const bool c_autocrypt = cs_subset_bool(NeoMutt->sub, \"autocrypt\");\n  if (c_autocrypt)\n    mutt_autocrypt_init(!(sendflags & SEND_BATCH));\n#endif\n\n  /* Create the `$folder` directory if it doesn't exist. */\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  if (!OptNoCurses && c_folder)\n  {\n    struct stat st = { 0 };\n    struct Buffer *fpath = buf_pool_get();\n\n    buf_strcpy(fpath, c_folder);\n    buf_expand_path(fpath);\n    bool skip = false;\n    /* we're not connected yet - skip mail folder creation */\n    skip |= (imap_path_probe(buf_string(fpath), NULL) == MUTT_IMAP);\n    skip |= (pop_path_probe(buf_string(fpath), NULL) == MUTT_POP);\n    skip |= (nntp_path_probe(buf_string(fpath), NULL) == MUTT_NNTP);\n    if (!skip && (stat(buf_string(fpath), &st) == -1) && (errno == ENOENT))\n    {\n      char msg2[256] = { 0 };\n      snprintf(msg2, sizeof(msg2), _(\"%s does not exist. Create it?\"), c_folder);\n      if (query_yesorno(msg2, MUTT_YES) == MUTT_YES)\n      {\n        if ((mkdir(buf_string(fpath), 0700) == -1) && (errno != EEXIST))\n          mutt_error(_(\"Can't create %s: %s\"), c_folder, strerror(errno)); // TEST21: neomutt -n -F /dev/null (and ~/Mail doesn't exist)\n      }\n    }\n    buf_pool_release(&fpath);\n  }\n\n  if (batch_mode)\n  {\n    goto main_ok; // TEST22: neomutt -B\n  }\n  StartupComplete = true;\n\n  notify_observer_add(NeoMutt->sub->notify, NT_CONFIG, main_hist_observer, NULL);\n  notify_observer_add(NeoMutt->sub->notify, NT_CONFIG, main_log_observer, NULL);\n  notify_observer_add(NeoMutt->sub->notify, NT_CONFIG, main_config_observer, NULL);\n  notify_observer_add(NeoMutt->notify, NT_TIMEOUT, main_timeout_observer, NULL);\n\n  if (sendflags & SEND_POSTPONED)\n  {\n    if (!OptNoCurses)\n      mutt_flushinp();\n    if (mutt_send_message(SEND_POSTPONED, NULL, NULL, NULL, NULL, NeoMutt->sub) == 0)\n      rc = 0;\n    // TEST23: neomutt -p (postponed message, cancel)\n    // TEST24: neomutt -p (no postponed message)\n    log_queue_empty();\n    repeat_error = true;\n    goto main_curses;\n  }\n  else if (subject || e || draft_file || include_file ||\n           !STAILQ_EMPTY(&attach) || (optind < argc))\n  {\n    FILE *fp_in = NULL;\n    FILE *fp_out = NULL;\n    char *infile = NULL;\n    char *bodytext = NULL;\n    const char *bodyfile = NULL;\n    int rv = 0;\n\n    if (!OptNoCurses)\n      mutt_flushinp();\n\n    if (!e)\n      e = email_new();\n    if (!e->env)\n      e->env = mutt_env_new();\n\n    for (i = optind; i < argc; i++)\n    {\n      if (url_check_scheme(argv[i]) == U_MAILTO)\n      {\n        if (!mutt_parse_mailto(e->env, &bodytext, argv[i]))\n        {\n          mutt_error(_(\"Failed to parse mailto: link\"));\n          email_free(&e);\n          goto main_curses; // TEST25: neomutt mailto:?\n        }\n      }\n      else\n      {\n        mutt_addrlist_parse(&e->env->to, argv[i]);\n      }\n    }\n\n    const bool c_auto_edit = cs_subset_bool(NeoMutt->sub, \"auto_edit\");\n    if (!draft_file && c_auto_edit && TAILQ_EMPTY(&e->env->to) &&\n        TAILQ_EMPTY(&e->env->cc))\n    {\n      mutt_error(_(\"No recipients specified\"));\n      email_free(&e);\n      goto main_curses; // TEST26: neomutt -s test (with auto_edit=yes)\n    }\n\n    if (subject)\n    {\n      /* prevent header injection */\n      mutt_filter_commandline_header_value(subject);\n      mutt_env_set_subject(e->env, subject);\n    }\n\n    if (draft_file)\n    {\n      infile = draft_file;\n      include_file = NULL;\n    }\n    else if (include_file)\n    {\n      infile = include_file;\n    }\n    else\n    {\n      edit_infile = false;\n    }\n\n    if (infile || bodytext)\n    {\n      /* Prepare fp_in and expanded_infile. */\n      if (infile)\n      {\n        if (mutt_str_equal(\"-\", infile))\n        {\n          if (edit_infile)\n          {\n            mutt_error(_(\"Can't use -E flag with stdin\"));\n            email_free(&e);\n            goto main_curses; // TEST27: neomutt -E -H -\n          }\n          fp_in = stdin;\n        }\n        else\n        {\n          buf_strcpy(expanded_infile, infile);\n          buf_expand_path(expanded_infile);\n          fp_in = mutt_file_fopen(buf_string(expanded_infile), \"r\");\n          if (!fp_in)\n          {\n            mutt_perror(\"%s\", buf_string(expanded_infile));\n            email_free(&e);\n            goto main_curses; // TEST28: neomutt -E -H missing\n          }\n        }\n      }\n\n      if (edit_infile)\n      {\n        /* If editing the infile, keep it around afterwards so\n         * it doesn't get unlinked, and we can rebuild the draft_file */\n        sendflags |= SEND_NO_FREE_HEADER;\n      }\n      else\n      {\n        /* Copy input to a tempfile, and re-point fp_in to the tempfile.\n         * Note: stdin is always copied to a tempfile, ensuring draft_file\n         * can stat and get the correct st_size below.  */\n        buf_mktemp(tempfile);\n\n        fp_out = mutt_file_fopen(buf_string(tempfile), \"w\");\n        if (!fp_out)\n        {\n          mutt_file_fclose(&fp_in);\n          mutt_perror(\"%s\", buf_string(tempfile));\n          email_free(&e);\n          goto main_curses; // TEST29: neomutt -H existing-file (where tmpdir=/path/to/FILE blocking tmpdir)\n        }\n        if (fp_in)\n        {\n          mutt_file_copy_stream(fp_in, fp_out);\n          if (fp_in == stdin)\n            sendflags |= SEND_CONSUMED_STDIN;\n          else\n            mutt_file_fclose(&fp_in);\n        }\n        else if (bodytext)\n        {\n          fputs(bodytext, fp_out);\n        }\n        mutt_file_fclose(&fp_out);\n\n        fp_in = mutt_file_fopen(buf_string(tempfile), \"r\");\n        if (!fp_in)\n        {\n          mutt_perror(\"%s\", buf_string(tempfile));\n          email_free(&e);\n          goto main_curses; // TEST30: can't test\n        }\n      }\n\n      /* Parse the draft_file into the full Email/Body structure.\n       * Set SEND_DRAFT_FILE so mutt_send_message doesn't overwrite\n       * our e->body.  */\n      if (draft_file)\n      {\n        struct Envelope *opts_env = e->env;\n        struct stat st = { 0 };\n\n        sendflags |= SEND_DRAFT_FILE;\n\n        /* Set up a tmp Email with just enough information so that\n         * mutt_prepare_template() can parse the message in fp_in.  */\n        struct Email *e_tmp = email_new();\n        e_tmp->offset = 0;\n        e_tmp->body = mutt_body_new();\n        if (fstat(fileno(fp_in), &st) != 0)\n        {\n          mutt_perror(\"%s\", draft_file);\n          email_free(&e);\n          email_free(&e_tmp);\n          goto main_curses; // TEST31: can't test\n        }\n        e_tmp->body->length = st.st_size;\n\n        if (mutt_prepare_template(fp_in, NULL, e, e_tmp, false) < 0)\n        {\n          mutt_error(_(\"Can't parse message template: %s\"), draft_file);\n          email_free(&e);\n          email_free(&e_tmp);\n          goto main_curses;\n        }\n\n        /* Scan for neomutt header to set `$resume_draft_files` */\n        struct ListNode *np = NULL, *tmp = NULL;\n        const bool c_resume_edited_draft_files = cs_subset_bool(NeoMutt->sub, \"resume_edited_draft_files\");\n        STAILQ_FOREACH_SAFE(np, &e->env->userhdrs, entries, tmp)\n        {\n          if (mutt_istr_startswith(np->data, \"X-Mutt-Resume-Draft:\"))\n          {\n            if (c_resume_edited_draft_files)\n              cs_str_native_set(cs, \"resume_draft_files\", true, NULL);\n\n            STAILQ_REMOVE(&e->env->userhdrs, np, ListNode, entries);\n            FREE(&np->data);\n            FREE(&np);\n          }\n        }\n\n        mutt_addrlist_copy(&e->env->to, &opts_env->to, false);\n        mutt_addrlist_copy(&e->env->cc, &opts_env->cc, false);\n        mutt_addrlist_copy(&e->env->bcc, &opts_env->bcc, false);\n        if (opts_env->subject)\n          mutt_env_set_subject(e->env, opts_env->subject);\n\n        mutt_env_free(&opts_env);\n        email_free(&e_tmp);\n      }\n      /* Editing the include_file: pass it directly in.\n       * Note that SEND_NO_FREE_HEADER is set above so it isn't unlinked.  */\n      else if (edit_infile)\n        bodyfile = buf_string(expanded_infile);\n      // For bodytext and unedited include_file: use the tempfile.\n      else\n        bodyfile = buf_string(tempfile);\n\n      mutt_file_fclose(&fp_in);\n    }\n\n    FREE(&bodytext);\n\n    if (!STAILQ_EMPTY(&attach))\n    {\n      struct Body *b = e->body;\n\n      while (b && b->next)\n        b = b->next;\n\n      struct ListNode *np = NULL;\n      STAILQ_FOREACH(np, &attach, entries)\n      {\n        if (b)\n        {\n          b->next = mutt_make_file_attach(np->data, NeoMutt->sub);\n          b = b->next;\n        }\n        else\n        {\n          b = mutt_make_file_attach(np->data, NeoMutt->sub);\n          e->body = b;\n        }\n        if (!b)\n        {\n          mutt_error(_(\"%s: unable to attach file\"), np->data);\n          mutt_list_free(&attach);\n          email_free(&e);\n          goto main_curses; // TEST32: neomutt john@example.com -a missing\n        }\n      }\n      mutt_list_free(&attach);\n    }\n\n    rv = mutt_send_message(sendflags, e, bodyfile, NULL, NULL, NeoMutt->sub);\n    /* We WANT the \"Mail sent.\" and any possible, later error */\n    log_queue_empty();\n    if (ErrorBufMessage)\n      mutt_message(\"%s\", ErrorBuf);\n\n    if (edit_infile)\n    {\n      if (draft_file)\n      {\n        if (truncate(buf_string(expanded_infile), 0) == -1)\n        {\n          mutt_perror(\"%s\", buf_string(expanded_infile));\n          email_free(&e);\n          goto main_curses; // TEST33: neomutt -H read-only -s test john@example.com -E\n        }\n        fp_out = mutt_file_fopen(buf_string(expanded_infile), \"a\");\n        if (!fp_out)\n        {\n          mutt_perror(\"%s\", buf_string(expanded_infile));\n          email_free(&e);\n          goto main_curses; // TEST34: can't test\n        }\n\n        /* If the message was sent or postponed, these will already\n         * have been done.  */\n        if (rv < 0)\n        {\n          if (e->body->next)\n            e->body = mutt_make_multipart(e->body);\n          mutt_encode_descriptions(e->body, true, NeoMutt->sub);\n          mutt_prepare_envelope(e->env, false, NeoMutt->sub);\n          mutt_env_to_intl(e->env, NULL, NULL);\n        }\n\n        const bool c_crypt_protected_headers_read = cs_subset_bool(NeoMutt->sub, \"crypt_protected_headers_read\");\n        mutt_rfc822_write_header(fp_out, e->env, e->body, MUTT_WRITE_HEADER_POSTPONE, false,\n                                 c_crypt_protected_headers_read &&\n                                     mutt_should_hide_protected_subject(e),\n                                 NeoMutt->sub);\n        const bool c_resume_edited_draft_files = cs_subset_bool(NeoMutt->sub, \"resume_edited_draft_files\");\n        if (c_resume_edited_draft_files)\n          fprintf(fp_out, \"X-Mutt-Resume-Draft: 1\\n\");\n        fputc('\\n', fp_out);\n        if ((mutt_write_mime_body(e->body, fp_out, NeoMutt->sub) == -1))\n        {\n          mutt_file_fclose(&fp_out);\n          email_free(&e);\n          goto main_curses; // TEST35: can't test\n        }\n        mutt_file_fclose(&fp_out);\n      }\n\n      email_free(&e);\n    }\n\n    /* !edit_infile && draft_file will leave the tempfile around */\n    if (!buf_is_empty(tempfile))\n      unlink(buf_string(tempfile));\n\n    rootwin_cleanup();\n\n    if (rv != 0)\n      goto main_curses; // TEST36: neomutt -H existing -s test john@example.com -E (cancel sending)\n  }\n  else if (sendflags & SEND_BATCH)\n  {\n    /* This guards against invoking `neomutt < /dev/null` and accidentally\n     * sending an email due to a my_hdr or other setting.  */\n    mutt_error(_(\"No recipients specified\"));\n    goto main_curses;\n  }\n  else\n  {\n    if (flags & MUTT_CLI_MAILBOX)\n    {\n      const bool c_imap_passive = cs_subset_bool(NeoMutt->sub, \"imap_passive\");\n      cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", false, NULL);\n      const CheckStatsFlags csflags = MUTT_MAILBOX_CHECK_IMMEDIATE;\n      if (mutt_mailbox_check(NULL, csflags) == 0)\n      {\n        mutt_message(_(\"No mailbox with new mail\"));\n        repeat_error = true;\n        goto main_curses; // TEST37: neomutt -Z (no new mail)\n      }\n      buf_reset(folder);\n      mutt_mailbox_next(NULL, folder);\n      cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", c_imap_passive, NULL);\n    }\n    else if (flags & MUTT_CLI_SELECT)\n    {\n      if (flags & MUTT_CLI_NEWS)\n      {\n        const char *const c_news_server = cs_subset_string(NeoMutt->sub, \"news_server\");\n        OptNews = true;\n        CurrentNewsSrv = nntp_select_server(NULL, c_news_server, false);\n        if (!CurrentNewsSrv)\n          goto main_curses; // TEST38: neomutt -G (unset news_server)\n      }\n      else if (TAILQ_EMPTY(&NeoMutt->accounts))\n      {\n        mutt_error(_(\"No incoming mailboxes defined\"));\n        goto main_curses; // TEST39: neomutt -n -F /dev/null -y\n      }\n      buf_reset(folder);\n      dlg_browser(folder, MUTT_SEL_FOLDER | MUTT_SEL_MAILBOX, NULL, NULL, NULL);\n      if (buf_is_empty(folder))\n      {\n        goto main_ok; // TEST40: neomutt -y (quit selection)\n      }\n    }\n\n    if (buf_is_empty(folder))\n    {\n      const char *const c_spool_file = cs_subset_string(NeoMutt->sub, \"spool_file\");\n      if (c_spool_file)\n      {\n        // Check if `$spool_file` corresponds a mailboxes' description.\n        struct Mailbox *m_desc = mailbox_find_name(c_spool_file);\n        if (m_desc)\n          buf_strcpy(folder, m_desc->realpath);\n        else\n          buf_strcpy(folder, c_spool_file);\n      }\n      else if (c_folder)\n      {\n        buf_strcpy(folder, c_folder);\n      }\n      /* else no folder */\n    }\n\n    if (OptNews)\n    {\n      OptNews = false;\n      buf_alloc(folder, PATH_MAX);\n      nntp_expand_path(folder->data, folder->dsize, &CurrentNewsSrv->conn->account);\n    }\n    else\n    {\n      buf_expand_path(folder);\n    }\n\n    mutt_str_replace(&CurrentFolder, buf_string(folder));\n    mutt_str_replace(&LastFolder, buf_string(folder));\n\n    if (flags & MUTT_CLI_IGNORE)\n    {\n      /* check to see if there are any messages in the folder */\n      switch (mx_path_is_empty(folder))\n      {\n        case -1:\n          mutt_perror(\"%s\", buf_string(folder));\n          goto main_curses; // TEST41: neomutt -z -f missing\n        case 1:\n          mutt_error(_(\"Mailbox is empty\"));\n          goto main_curses; // TEST42: neomutt -z -f /dev/null\n      }\n    }\n\n    struct Mailbox *m_cur = mailbox_find(buf_string(folder));\n    // Take a copy of the name just in case the hook alters m_cur\n    const char *name = m_cur ? mutt_str_dup(m_cur->name) : NULL;\n    mutt_folder_hook(buf_string(folder), name);\n    FREE(&name);\n    mutt_startup_shutdown_hook(MUTT_STARTUP_HOOK);\n    mutt_debug(LL_NOTIFY, \"NT_GLOBAL_STARTUP\\n\");\n    notify_send(NeoMutt->notify, NT_GLOBAL, NT_GLOBAL_STARTUP, NULL);\n\n    notify_send(NeoMutt->notify_resize, NT_RESIZE, 0, NULL);\n    window_redraw(NULL);\n\n    repeat_error = true;\n    struct Mailbox *m = mx_resolve(buf_string(folder));\n    const bool c_read_only = cs_subset_bool(NeoMutt->sub, \"read_only\");\n    if (!mx_mbox_open(m, ((flags & MUTT_CLI_RO) || c_read_only) ? MUTT_READONLY : MUTT_OPEN_NO_FLAGS))\n    {\n      if (m->account)\n        account_mailbox_remove(m->account, m);\n\n      mailbox_free(&m);\n      mutt_error(_(\"Unable to open mailbox %s\"), buf_string(folder));\n      repeat_error = false;\n    }\n    if (m || !explicit_folder)\n    {\n      struct MuttWindow *dlg = index_pager_init();\n      dialog_push(dlg);\n\n      mutt_curses_set_cursor(MUTT_CURSOR_INVISIBLE);\n      m = dlg_index(dlg, m);\n      mutt_curses_set_cursor(MUTT_CURSOR_VISIBLE);\n      mailbox_free(&m);\n\n      dialog_pop();\n      mutt_window_free(&dlg);\n      log_queue_empty();\n      repeat_error = false;\n    }\n    imap_logout_all();\n#ifdef USE_SASL_CYRUS\n    mutt_sasl_cleanup();\n#endif\n#ifdef USE_SASL_GNU\n    mutt_gsasl_cleanup();\n#endif\n#ifdef USE_AUTOCRYPT\n    mutt_autocrypt_cleanup();\n#endif\n    // TEST43: neomutt (no change to mailbox)\n    // TEST44: neomutt (change mailbox)\n  }\n\nmain_ok:\n  rc = 0;\nmain_curses:\n  mutt_endwin();\n  mutt_temp_attachments_cleanup();\n  /* Repeat the last message to the user */\n  if (repeat_error && ErrorBufMessage)\n    puts(ErrorBuf);\nmain_exit:\n  if (NeoMutt && NeoMutt->sub)\n  {\n    notify_observer_remove(NeoMutt->sub->notify, main_hist_observer, NULL);\n    notify_observer_remove(NeoMutt->sub->notify, main_log_observer, NULL);\n    notify_observer_remove(NeoMutt->sub->notify, main_config_observer, NULL);\n    notify_observer_remove(NeoMutt->notify, main_timeout_observer, NULL);\n  }\n  mutt_list_free(&commands);\n  MuttLogger = log_disp_queue;\n  buf_pool_release(&folder);\n  buf_pool_release(&expanded_infile);\n  buf_pool_release(&tempfile);\n  mutt_list_free(&queries);\n  crypto_module_cleanup();\n  rootwin_cleanup();\n  buf_pool_cleanup();\n  envlist_free(&EnvList);\n  mutt_browser_cleanup();\n  external_cleanup();\n  menu_cleanup();\n  crypt_cleanup();\n  mutt_ch_cache_cleanup();\n  mutt_opts_cleanup();\n  subjrx_cleanup();\n  attach_cleanup();\n  alternates_cleanup();\n  mutt_keys_cleanup();\n  mutt_prex_cleanup();\n  config_cache_cleanup();\n  neomutt_free(&NeoMutt);\n  cs_free(&cs);\n  log_queue_flush(log_disp_terminal);\n  mutt_log_stop();\n  return rc;\n}\n"
        },
        {
          "name": "mbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "menu",
          "type": "tree",
          "content": null
        },
        {
          "name": "mh",
          "type": "tree",
          "content": null
        },
        {
          "name": "monitor.c",
          "type": "blob",
          "size": 14.1591796875,
          "content": "/**\n * @file\n * Monitor files for changes\n *\n * @authors\n * Copyright (C) 2018 Gero Treuer <gero@70t.de>\n * Copyright (C) 2018-2024 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2019 Ian Zimmerman <itz@no-use.mooo.com>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2020 R Primus <rprimus@gmail.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_monitor Monitor files for changes\n *\n * Monitor files for changes\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"core/lib.h\"\n#include \"monitor.h\"\n#include \"index/lib.h\"\n#ifndef HAVE_INOTIFY_INIT1\n#include <fcntl.h>\n#endif\n\n/// Set to true when a monitored file has changed\nbool MonitorFilesChanged = false;\n/// Set to true when the current mailbox has changed\nbool MonitorCurMboxChanged = false;\n\n/// Inotify file descriptor\nstatic int INotifyFd = -1;\n/// Linked list of monitored Mailboxes\nstatic struct Monitor *Monitor = NULL;\n/// Number of used entries in the #PollFds array\nstatic size_t PollFdsCount = 0;\n/// Size of #PollFds array\nstatic size_t PollFdsLen = 0;\n/// Array of monitored file descriptors\nstatic struct pollfd *PollFds = NULL;\n/// Monitor file descriptor of the current mailbox\nstatic int MonitorCurMboxDescriptor = -1;\n\n#define INOTIFY_MASK_DIR (IN_MOVED_TO | IN_ATTRIB | IN_CLOSE_WRITE | IN_ISDIR)\n#define INOTIFY_MASK_FILE IN_CLOSE_WRITE\n\n#define EVENT_BUFLEN MAX(4096, sizeof(struct inotify_event) + NAME_MAX + 1)\n\n/**\n * enum ResolveResult - Results for the Monitor functions\n */\nenum ResolveResult\n{\n  RESOLVE_RES_FAIL_NOMAILBOX = -3, ///< No Mailbox to work on\n  RESOLVE_RES_FAIL_NOTYPE = -2,    ///< Can't identify Mailbox type\n  RESOLVE_RES_FAIL_STAT = -1,      ///< Can't stat() the Mailbox file\n  RESOLVE_RES_OK_NOTEXISTING = 0,  ///< File exists, no monitor is attached\n  RESOLVE_RES_OK_EXISTING = 1,     ///< File exists, monitor is already attached\n};\n\n/**\n * struct Monitor - A watch on a file\n */\nstruct Monitor\n{\n  struct Monitor *next; ///< Linked list\n  char *mh_backup_path;\n  dev_t st_dev;\n  ino_t st_ino;\n  enum MailboxType type;\n  int desc;\n};\n\n/**\n * struct MonitorInfo - Information about a monitored file\n */\nstruct MonitorInfo\n{\n  enum MailboxType type;\n  bool is_dir;\n  const char *path;\n  dev_t st_dev;\n  ino_t st_ino;\n  struct Monitor *monitor;\n  struct Buffer path_buf; ///< access via path only (maybe not initialized)\n};\n\n/**\n * mutt_poll_fd_add - Add a file to the watch list\n * @param fd     File to watch\n * @param events Events to listen for, e.g. POLLIN\n */\nstatic void mutt_poll_fd_add(int fd, short events)\n{\n  int i = 0;\n  for (; (i < PollFdsCount) && (PollFds[i].fd != fd); i++)\n    ; // do nothing\n\n  if (i == PollFdsCount)\n  {\n    if (PollFdsCount == PollFdsLen)\n    {\n      PollFdsLen += 2;\n      MUTT_MEM_REALLOC(&PollFds, PollFdsLen, struct pollfd);\n    }\n    PollFdsCount++;\n    PollFds[i].fd = fd;\n    PollFds[i].events = events;\n  }\n  else\n  {\n    PollFds[i].events |= events;\n  }\n}\n\n/**\n * mutt_poll_fd_remove - Remove a file from the watch list\n * @param fd File to remove\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int mutt_poll_fd_remove(int fd)\n{\n  int i = 0;\n  for (; (i < PollFdsCount) && (PollFds[i].fd != fd); i++)\n    ; // do nothing\n\n  if (i == PollFdsCount)\n    return -1;\n  int d = PollFdsCount - i - 1;\n  if (d != 0)\n    memmove(&PollFds[i], &PollFds[i + 1], d * sizeof(struct pollfd));\n  PollFdsCount--;\n  return 0;\n}\n\n/**\n * monitor_init - Set up file monitoring\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int monitor_init(void)\n{\n  if (INotifyFd != -1)\n    return 0;\n\n#ifdef HAVE_INOTIFY_INIT1\n  INotifyFd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);\n  if (INotifyFd == -1)\n  {\n    mutt_debug(LL_DEBUG2, \"inotify_init1 failed, errno=%d %s\\n\", errno, strerror(errno));\n    return -1;\n  }\n#else\n  INotifyFd = inotify_init();\n  if (INotifyFd == -1)\n  {\n    mutt_debug(LL_DEBUG2, \"monitor: inotify_init failed, errno=%d %s\\n\", errno,\n               strerror(errno));\n    return -1;\n  }\n  fcntl(INotifyFd, F_SETFL, O_NONBLOCK);\n  fcntl(INotifyFd, F_SETFD, FD_CLOEXEC);\n#endif\n  mutt_poll_fd_add(0, POLLIN);\n  mutt_poll_fd_add(INotifyFd, POLLIN);\n\n  return 0;\n}\n\n/**\n * monitor_check_cleanup - Close down file monitoring\n */\nstatic void monitor_check_cleanup(void)\n{\n  if (!Monitor && (INotifyFd != -1))\n  {\n    mutt_poll_fd_remove(INotifyFd);\n    close(INotifyFd);\n    INotifyFd = -1;\n    MonitorFilesChanged = false;\n  }\n}\n\n/**\n * monitor_new - Create a new file monitor\n * @param info       Details of file to monitor\n * @param descriptor Watch descriptor\n * @retval ptr Newly allocated Monitor\n */\nstatic struct Monitor *monitor_new(struct MonitorInfo *info, int descriptor)\n{\n  struct Monitor *monitor = MUTT_MEM_CALLOC(1, struct Monitor);\n  monitor->type = info->type;\n  monitor->st_dev = info->st_dev;\n  monitor->st_ino = info->st_ino;\n  monitor->desc = descriptor;\n  monitor->next = Monitor;\n  if (info->type == MUTT_MH)\n    monitor->mh_backup_path = mutt_str_dup(info->path);\n\n  Monitor = monitor;\n\n  return monitor;\n}\n\n/**\n * monitor_info_free - Shutdown a file monitor\n * @param info Monitor to shut down\n */\nstatic void monitor_info_free(struct MonitorInfo *info)\n{\n  buf_dealloc(&info->path_buf);\n}\n\n/**\n * monitor_delete - Free a file monitor\n * @param monitor Monitor to free\n */\nstatic void monitor_delete(struct Monitor *monitor)\n{\n  if (!monitor)\n    return;\n\n  struct Monitor **ptr = &Monitor;\n\n  while (true)\n  {\n    if (!*ptr)\n      return;\n    if (*ptr == monitor)\n      break;\n    ptr = &(*ptr)->next;\n  }\n\n  FREE(&monitor->mh_backup_path);\n  monitor = monitor->next;\n  FREE(ptr);\n  *ptr = monitor;\n}\n\n/**\n * monitor_handle_ignore - Listen for when a backup file is closed\n * @param desc Watch descriptor\n * @retval >=0 New descriptor\n * @retval  -1 Error\n */\nstatic int monitor_handle_ignore(int desc)\n{\n  int new_desc = -1;\n  struct Monitor *iter = Monitor;\n  struct stat st = { 0 };\n\n  while (iter && (iter->desc != desc))\n    iter = iter->next;\n\n  if (iter)\n  {\n    if ((iter->type == MUTT_MH) && (stat(iter->mh_backup_path, &st) == 0))\n    {\n      new_desc = inotify_add_watch(INotifyFd, iter->mh_backup_path, INOTIFY_MASK_FILE);\n      if (new_desc == -1)\n      {\n        mutt_debug(LL_DEBUG2, \"inotify_add_watch failed for '%s', errno=%d %s\\n\",\n                   iter->mh_backup_path, errno, strerror(errno));\n      }\n      else\n      {\n        mutt_debug(LL_DEBUG3, \"inotify_add_watch descriptor=%d for '%s'\\n\",\n                   desc, iter->mh_backup_path);\n        iter->st_dev = st.st_dev;\n        iter->st_ino = st.st_ino;\n        iter->desc = new_desc;\n      }\n    }\n    else\n    {\n      mutt_debug(LL_DEBUG3, \"cleanup watch (implicitly removed) - descriptor=%d\\n\", desc);\n    }\n\n    if (MonitorCurMboxDescriptor == desc)\n      MonitorCurMboxDescriptor = new_desc;\n\n    if (new_desc == -1)\n    {\n      monitor_delete(iter);\n      monitor_check_cleanup();\n    }\n  }\n\n  return new_desc;\n}\n\n/**\n * monitor_resolve - Get the monitor for a mailbox\n * @param[out] info Details of the mailbox's monitor\n * @param[in]  m    Mailbox\n * @retval >=0 mailbox is valid and locally accessible:\n *               0: no monitor / 1: preexisting monitor\n * @retval  -3 no mailbox (MonitorInfo: no fields set)\n * @retval  -2 type not set\n * @retval  -1 stat() failed (see errno; MonitorInfo fields: type, is_dir, path)\n *\n * If m is NULL, try to get the current mailbox from the Index.\n */\nstatic enum ResolveResult monitor_resolve(struct MonitorInfo *info, struct Mailbox *m)\n{\n  char *fmt = NULL;\n  struct stat st = { 0 };\n\n  struct Mailbox *m_cur = get_current_mailbox();\n  if (m)\n  {\n    info->type = m->type;\n    info->path = m->realpath;\n  }\n  else if (m_cur)\n  {\n    info->type = m_cur->type;\n    info->path = m_cur->realpath;\n  }\n  else\n  {\n    return RESOLVE_RES_FAIL_NOMAILBOX;\n  }\n\n  if (info->type == MUTT_UNKNOWN)\n  {\n    return RESOLVE_RES_FAIL_NOTYPE;\n  }\n  else if (info->type == MUTT_MAILDIR)\n  {\n    info->is_dir = true;\n    fmt = \"%s/new\";\n  }\n  else\n  {\n    info->is_dir = false;\n    if (info->type == MUTT_MH)\n      fmt = \"%s/.mh_sequences\";\n  }\n  if (fmt)\n  {\n    buf_printf(&info->path_buf, fmt, info->path);\n    info->path = buf_string(&info->path_buf);\n  }\n  if (stat(info->path, &st) != 0)\n    return RESOLVE_RES_FAIL_STAT;\n\n  struct Monitor *iter = Monitor;\n  while (iter && ((iter->st_ino != st.st_ino) || (iter->st_dev != st.st_dev)))\n    iter = iter->next;\n\n  info->st_dev = st.st_dev;\n  info->st_ino = st.st_ino;\n  info->monitor = iter;\n\n  return iter ? RESOLVE_RES_OK_EXISTING : RESOLVE_RES_OK_NOTEXISTING;\n}\n\n/**\n * mutt_monitor_poll - Check for filesystem changes\n * @retval -3 unknown/unexpected events: poll timeout / fds not handled by us\n * @retval -2 monitor detected changes, no STDIN input\n * @retval -1 error (see errno)\n * @retval  0 (1) input ready from STDIN, or (2) monitoring inactive -> no poll()\n *\n * Wait for I/O ready file descriptors or signals.\n *\n * MonitorFilesChanged also reflects changes to monitored files.\n *\n * Only STDIN and INotify file handles currently expected/supported.\n * More would ask for common infrastructure (sockets?).\n */\nint mutt_monitor_poll(void)\n{\n  int rc = 0;\n  char buf[EVENT_BUFLEN]\n      __attribute__((aligned(__alignof__(struct inotify_event)))) = { 0 };\n\n  MonitorFilesChanged = false;\n\n  if (INotifyFd != -1)\n  {\n    int fds = poll(PollFds, PollFdsCount, 1000); // 1 Second\n\n    if (fds == -1)\n    {\n      rc = -1;\n      if (errno != EINTR)\n      {\n        mutt_debug(LL_DEBUG2, \"poll() failed, errno=%d %s\\n\", errno, strerror(errno));\n      }\n    }\n    else\n    {\n      bool input_ready = false;\n      for (int i = 0; fds && (i < PollFdsCount); i++)\n      {\n        if (PollFds[i].revents)\n        {\n          fds--;\n          if (PollFds[i].fd == 0)\n          {\n            input_ready = true;\n          }\n          else if (PollFds[i].fd == INotifyFd)\n          {\n            MonitorFilesChanged = true;\n            mutt_debug(LL_DEBUG3, \"file change(s) detected\\n\");\n            char *ptr = buf;\n            const struct inotify_event *event = NULL;\n\n            while (true)\n            {\n              int len = read(INotifyFd, buf, sizeof(buf));\n              if (len == -1)\n              {\n                if (errno != EAGAIN)\n                {\n                  mutt_debug(LL_DEBUG2, \"read inotify events failed, errno=%d %s\\n\",\n                             errno, strerror(errno));\n                }\n                break;\n              }\n\n              while (ptr < (buf + len))\n              {\n                event = (const struct inotify_event *) ptr;\n                mutt_debug(LL_DEBUG3, \"+ detail: descriptor=%d mask=0x%x\\n\",\n                           event->wd, event->mask);\n                if (event->mask & IN_IGNORED)\n                  monitor_handle_ignore(event->wd);\n                else if (event->wd == MonitorCurMboxDescriptor)\n                  MonitorCurMboxChanged = true;\n                ptr += sizeof(struct inotify_event) + event->len;\n              }\n            }\n          }\n        }\n      }\n      if (!input_ready)\n        rc = MonitorFilesChanged ? -2 : -3;\n    }\n  }\n\n  return rc;\n}\n\n/**\n * mutt_monitor_add - Add a watch for a mailbox\n * @param m Mailbox to watch\n * @retval  0 success: new or already existing monitor\n * @retval -1 failed:  no mailbox, inaccessible file, create monitor/watcher failed\n *\n * If m is NULL, try to get the current mailbox from the Index.\n */\nint mutt_monitor_add(struct Mailbox *m)\n{\n  struct MonitorInfo info = { 0 };\n\n  int rc = 0;\n  enum ResolveResult desc = monitor_resolve(&info, m);\n  if (desc != RESOLVE_RES_OK_NOTEXISTING)\n  {\n    if (!m && (desc == RESOLVE_RES_OK_EXISTING))\n      MonitorCurMboxDescriptor = info.monitor->desc;\n    rc = (desc == RESOLVE_RES_OK_EXISTING) ? 0 : -1;\n    goto cleanup;\n  }\n\n  uint32_t mask = info.is_dir ? INOTIFY_MASK_DIR : INOTIFY_MASK_FILE;\n  if (((INotifyFd == -1) && (monitor_init() == -1)) ||\n      ((desc = inotify_add_watch(INotifyFd, info.path, mask)) == -1))\n  {\n    mutt_debug(LL_DEBUG2, \"inotify_add_watch failed for '%s', errno=%d %s\\n\",\n               info.path, errno, strerror(errno));\n    rc = -1;\n    goto cleanup;\n  }\n\n  mutt_debug(LL_DEBUG3, \"inotify_add_watch descriptor=%d for '%s'\\n\", desc, info.path);\n  if (!m)\n    MonitorCurMboxDescriptor = desc;\n\n  monitor_new(&info, desc);\n\ncleanup:\n  monitor_info_free(&info);\n  return rc;\n}\n\n/**\n * mutt_monitor_remove - Remove a watch for a mailbox\n * @param m Mailbox\n * @retval 0 monitor removed (not shared)\n * @retval 1 monitor not removed (shared)\n * @retval 2 no monitor\n *\n * If m is NULL, try to get the current mailbox from the Index.\n */\nint mutt_monitor_remove(struct Mailbox *m)\n{\n  struct MonitorInfo info = { 0 };\n  struct MonitorInfo info2 = { 0 };\n  int rc = 0;\n\n  if (!m)\n  {\n    MonitorCurMboxDescriptor = -1;\n    MonitorCurMboxChanged = false;\n  }\n\n  if (monitor_resolve(&info, m) != RESOLVE_RES_OK_EXISTING)\n  {\n    rc = 2;\n    goto cleanup;\n  }\n\n  struct Mailbox *m_cur = get_current_mailbox();\n  if (m_cur)\n  {\n    if (m)\n    {\n      if ((monitor_resolve(&info2, NULL) == RESOLVE_RES_OK_EXISTING) &&\n          (info.st_ino == info2.st_ino) && (info.st_dev == info2.st_dev))\n      {\n        rc = 1;\n        goto cleanup;\n      }\n    }\n    else\n    {\n      if (mailbox_find(m_cur->realpath))\n      {\n        rc = 1;\n        goto cleanup;\n      }\n    }\n  }\n\n  inotify_rm_watch(info.monitor->desc, INotifyFd);\n  mutt_debug(LL_DEBUG3, \"inotify_rm_watch for '%s' descriptor=%d\\n\", info.path,\n             info.monitor->desc);\n\n  monitor_delete(info.monitor);\n  monitor_check_cleanup();\n\ncleanup:\n  monitor_info_free(&info);\n  monitor_info_free(&info2);\n  return rc;\n}\n"
        },
        {
          "name": "monitor.h",
          "type": "blob",
          "size": 1.19921875,
          "content": "/**\n * @file\n * Monitor files for changes\n *\n * @authors\n * Copyright (C) 2018 Gero Treuner <gero@70t.de>\n * Copyright (C) 2018-2024 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MONITOR_H\n#define MUTT_MONITOR_H\n\n#include <stdbool.h>\n\nstruct Mailbox;\n\nextern bool MonitorFilesChanged;   ///< true after a monitored file has changed\nextern bool MonitorCurMboxChanged; ///< true after the current mailbox has changed\n\nint mutt_monitor_add(struct Mailbox *m);\nint mutt_monitor_remove(struct Mailbox *m);\nint mutt_monitor_poll(void);\n\n#endif /* MUTT_MONITOR_H */\n"
        },
        {
          "name": "mutt.h",
          "type": "blob",
          "size": 2.8427734375,
          "content": "/**\n * @file\n * Many unsorted constants and some structs\n *\n * @authors\n * Copyright (C) 1996-2002,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2004 g10 Code GmbH\n * Copyright (C) 2018-2024 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_H\n#define MUTT_MUTT_H\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n/* On OS X 10.5.x, wide char functions are inlined by default breaking\n * --without-wc-funcs compilation\n */\n#ifdef __APPLE_CC__\n#define _DONT_USE_CTYPE_INLINE_\n#endif\n\n/* PATH_MAX is undefined on the hurd */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifdef HAVE_FGETS_UNLOCKED\n#define fgets fgets_unlocked\n#endif\n\n#ifdef HAVE_FGETC_UNLOCKED\n#define fgetc fgetc_unlocked\n#endif\n\nextern bool StartupComplete;\n\ntypedef uint8_t CompletionFlags;       ///< Flags for mw_get_field(), e.g. #MUTT_COMP_NO_FLAGS\n#define MUTT_COMP_NO_FLAGS          0  ///< No flags are set\n#define MUTT_COMP_CLEAR       (1 << 0) ///< Clear input if printable character is pressed\n#define MUTT_COMP_PASS        (1 << 1) ///< Password mode (no echo)\n#define MUTT_COMP_UNBUFFERED  (1 << 2) ///< Ignore macro buffer\n\n/**\n * enum MessageType - To set flags or match patterns\n *\n * @sa mutt_set_flag(), mutt_pattern_func()\n */\nenum MessageType\n{\n  MUTT_ALL = 1,    ///< All messages\n  MUTT_NONE,       ///< No messages\n  MUTT_NEW,        ///< New messages\n  MUTT_OLD,        ///< Old messages\n  MUTT_REPLIED,    ///< Messages that have been replied to\n  MUTT_READ,       ///< Messages that have been read\n  MUTT_UNREAD,     ///< Unread messages\n  MUTT_DELETE,     ///< Messages to be deleted\n  MUTT_UNDELETE,   ///< Messages to be un-deleted\n  MUTT_PURGE,      ///< Messages to be purged (bypass trash)\n  MUTT_DELETED,    ///< Deleted messages\n  MUTT_FLAG,       ///< Flagged messages\n  MUTT_TAG,        ///< Tagged messages\n  MUTT_UNTAG,      ///< Messages to be un-tagged\n  MUTT_LIMIT,      ///< Messages in limited view\n  MUTT_EXPIRED,    ///< Expired messages\n  MUTT_SUPERSEDED, ///< Superseded messages\n  MUTT_TRASH,      ///< Trashed messages\n\n  MUTT_MT_MAX,\n};\n\n/* flags for parse_spam_list */\n#define MUTT_SPAM   1\n#define MUTT_NOSPAM 2\n\nvoid reset_value(const char *name);\n\n#endif /* MUTT_MUTT_H */\n"
        },
        {
          "name": "mutt",
          "type": "tree",
          "content": null
        },
        {
          "name": "mutt_body.c",
          "type": "blob",
          "size": 3.25390625,
          "content": "/**\n * @file\n * Representation of the body of an email\n *\n * @authors\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018-2020 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_body Representation of the body of an email\n *\n * Representation of the body of an email\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"mutt_body.h\"\n#include \"attach/lib.h\"\n#include \"send/lib.h\"\n#include \"muttlib.h\"\n\n/**\n * mutt_body_copy - Create a send-mode duplicate from a receive-mode body\n * @param[in]  fp    FILE pointer to attachments\n * @param[out] b_dst New Body will be saved here\n * @param[in]  b_src Source Body to copy\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mutt_body_copy(FILE *fp, struct Body **b_dst, struct Body *b_src)\n{\n  if (!b_dst || !b_src)\n    return -1;\n\n  struct Body *b = NULL;\n  bool use_disp;\n  struct Buffer *tmp = buf_pool_get();\n\n  if (b_src->filename)\n  {\n    use_disp = true;\n    buf_strcpy(tmp, b_src->filename);\n  }\n  else\n  {\n    use_disp = false;\n  }\n\n  mutt_adv_mktemp(tmp);\n  if (mutt_save_attachment(fp, b_src, buf_string(tmp), MUTT_SAVE_NO_FLAGS, NULL) == -1)\n  {\n    buf_pool_release(&tmp);\n    return -1;\n  }\n\n  *b_dst = mutt_body_new();\n  b = *b_dst;\n\n  memcpy(b, b_src, sizeof(struct Body));\n  TAILQ_INIT(&b->parameter);\n  b->parts = NULL;\n  b->next = NULL;\n\n  b->content_id = mutt_str_dup(b->content_id);\n  b->filename = buf_strdup(tmp);\n  b->use_disp = use_disp;\n  b->unlink = true;\n\n  if (mutt_is_text_part(b))\n    b->noconv = true;\n\n  b->xtype = mutt_str_dup(b->xtype);\n  b->subtype = mutt_str_dup(b->subtype);\n  b->form_name = mutt_str_dup(b->form_name);\n  b->d_filename = mutt_str_dup(b->d_filename);\n  /* mutt_adv_mktemp() will mangle the filename in tmp,\n   * so preserve it in d_filename */\n  if (!b->d_filename && use_disp)\n    b->d_filename = mutt_str_dup(b_src->filename);\n  b->description = mutt_str_dup(b->description);\n\n  b->language = mutt_str_dup(b->language);\n  b->charset = mutt_str_dup(b->charset);\n\n  b->content = NULL;\n  b->aptr = NULL;\n  b->mime_headers = NULL;\n\n  /* we don't seem to need the Email structure currently.\n   * XXX this may change in the future */\n  b->email = NULL;\n\n  /* copy parameters */\n  struct Parameter *np = NULL, *new_param = NULL;\n  TAILQ_FOREACH(np, &b_src->parameter, entries)\n  {\n    new_param = mutt_param_new();\n    new_param->attribute = mutt_str_dup(np->attribute);\n    new_param->value = mutt_str_dup(np->value);\n    TAILQ_INSERT_HEAD(&b->parameter, new_param, entries);\n  }\n\n  mutt_stamp_attachment(b);\n  buf_pool_release(&tmp);\n  return 0;\n}\n"
        },
        {
          "name": "mutt_body.h",
          "type": "blob",
          "size": 0.962890625,
          "content": "/**\n * @file\n * Representation of the body of an email\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_BODY_H\n#define MUTT_MUTT_BODY_H\n\n#include <stdio.h>\n\nstruct Body;\n\nint mutt_body_copy(FILE *fp, struct Body **b_dst, struct Body *b_src);\n\n#endif /* MUTT_MUTT_BODY_H */\n"
        },
        {
          "name": "mutt_config.c",
          "type": "blob",
          "size": 36.5693359375,
          "content": "/**\n * @file\n * Definitions of config variables\n *\n * @authors\n * Copyright (C) 2020 Aditya De Saha <adityadesaha@gmail.com>\n * Copyright (C) 2020 Louis Brauer <louis@openbooking.ch>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2020-2024 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2021 Ashish Panigrahi <ashish.panigrahi@protonmail.com>\n * Copyright (C) 2023 наб <nabijaczleweli@nabijaczleweli.xyz>\n * Copyright (C) 2023-2024 Tóth János <gomba007@gmail.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_config Definitions of config variables\n *\n * Definitions of config variables\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"attach/lib.h\"\n#include \"expando/lib.h\"\n#include \"index/lib.h\"\n#include \"init.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_thread.h\"\n#include \"mx.h\"\n\nextern const struct ExpandoDefinition IndexFormatDef[];\n\n#define CONFIG_INIT_TYPE(CS, NAME)                                             \\\n  extern const struct ConfigSetType Cst##NAME;                                 \\\n  cs_register_type(CS, &Cst##NAME)\n\n#define CONFIG_INIT_VARS(CS, NAME)                                             \\\n  bool config_init_##NAME(struct ConfigSet *cs);                               \\\n  config_init_##NAME(CS)\n\n/**\n * SortAuxMethods - Sort methods for '$sort_aux' for the index\n */\nstatic const struct Mapping SortAuxMethods[] = {\n  // clang-format off\n  { \"date\",          EMAIL_SORT_DATE },\n  { \"date-received\", EMAIL_SORT_DATE_RECEIVED },\n  { \"from\",          EMAIL_SORT_FROM },\n  { \"label\",         EMAIL_SORT_LABEL },\n  { \"score\",         EMAIL_SORT_SCORE },\n  { \"size\",          EMAIL_SORT_SIZE },\n  { \"spam\",          EMAIL_SORT_SPAM },\n  { \"subject\",       EMAIL_SORT_SUBJECT },\n  { \"to\",            EMAIL_SORT_TO },\n  { \"unsorted\",      EMAIL_SORT_UNSORTED },\n  // Compatibility\n  { \"date-sent\",     EMAIL_SORT_DATE },\n  { \"mailbox-order\", EMAIL_SORT_UNSORTED },\n  { \"threads\",       EMAIL_SORT_DATE },\n  { NULL, 0 },\n  // clang-format on\n};\n\n/**\n * SortMethods - Sort methods for '$sort' for the index\n */\nconst struct Mapping SortMethods[] = {\n  // clang-format off\n  { \"date\",          EMAIL_SORT_DATE },\n  { \"date-received\", EMAIL_SORT_DATE_RECEIVED },\n  { \"from\",          EMAIL_SORT_FROM },\n  { \"label\",         EMAIL_SORT_LABEL },\n  { \"score\",         EMAIL_SORT_SCORE },\n  { \"size\",          EMAIL_SORT_SIZE },\n  { \"spam\",          EMAIL_SORT_SPAM },\n  { \"subject\",       EMAIL_SORT_SUBJECT },\n  { \"threads\",       EMAIL_SORT_THREADS },\n  { \"to\",            EMAIL_SORT_TO },\n  { \"unsorted\",      EMAIL_SORT_UNSORTED },\n  // Compatibility\n  { \"date-sent\",     EMAIL_SORT_DATE },\n  { \"mailbox-order\", EMAIL_SORT_UNSORTED },\n  { NULL, 0 },\n  // clang-format on\n};\n\n/**\n * multipart_validator - Validate the \"show_multipart_alternative\" config variable - Implements ConfigDef::validator() - @ingroup cfg_def_validator\n */\nstatic int multipart_validator(const struct ConfigSet *cs, const struct ConfigDef *cdef,\n                               intptr_t value, struct Buffer *err)\n{\n  if (value == 0)\n    return CSR_SUCCESS;\n\n  const char *str = (const char *) value;\n\n  if (mutt_str_equal(str, \"inline\") || mutt_str_equal(str, \"info\"))\n    return CSR_SUCCESS;\n\n  buf_printf(err, _(\"Invalid value for option %s: %s\"), cdef->name, str);\n  return CSR_ERR_INVALID;\n}\n\n/**\n * AttachFormatDef - Expando definitions\n *\n * Config:\n * - $attach_format\n */\nstatic const struct ExpandoDefinition AttachFormatDef[] = {\n  // clang-format off\n  { \"*\", \"padding-soft\",     ED_GLOBAL, ED_GLO_PADDING_SOFT,     node_padding_parse },\n  { \">\", \"padding-hard\",     ED_GLOBAL, ED_GLO_PADDING_HARD,     node_padding_parse },\n  { \"|\", \"padding-eol\",      ED_GLOBAL, ED_GLO_PADDING_EOL,      node_padding_parse },\n  { \"c\", \"charset-convert\",  ED_BODY,   ED_BOD_CHARSET_CONVERT,  NULL },\n  { \"C\", \"charset\",          ED_ATTACH, ED_ATT_CHARSET,          NULL },\n  { \"d\", \"description\",      ED_BODY,   ED_BOD_DESCRIPTION,      NULL },\n  { \"D\", \"deleted\",          ED_BODY,   ED_BOD_DELETED,          NULL },\n  { \"e\", \"mime-encoding\",    ED_BODY,   ED_BOD_MIME_ENCODING,    NULL },\n  { \"f\", \"file\",             ED_BODY,   ED_BOD_FILE,             NULL },\n  { \"F\", \"file-disposition\", ED_BODY,   ED_BOD_FILE_DISPOSITION, NULL },\n  { \"I\", \"disposition\",      ED_BODY,   ED_BOD_DISPOSITION,      NULL },\n  { \"m\", \"mime-major\",       ED_BODY,   ED_BOD_MIME_MAJOR,       NULL },\n  { \"M\", \"mime-minor\",       ED_BODY,   ED_BOD_MIME_MINOR,       NULL },\n  { \"n\", \"number\",           ED_ATTACH, ED_ATT_NUMBER,           NULL },\n  { \"Q\", \"attach-qualifies\", ED_BODY,   ED_BOD_ATTACH_QUALIFIES, NULL },\n  { \"s\", \"file-size\",        ED_BODY,   ED_BOD_FILE_SIZE,        NULL },\n  { \"t\", \"tagged\",           ED_BODY,   ED_BOD_TAGGED,           NULL },\n  { \"T\", \"tree\",             ED_ATTACH, ED_ATT_TREE,             NULL },\n  { \"u\", \"unlink\",           ED_BODY,   ED_BOD_UNLINK,           NULL },\n  { \"X\", \"attach-count\",     ED_BODY,   ED_BOD_ATTACH_COUNT,     NULL },\n  { NULL, NULL, 0, -1, NULL }\n  // clang-format on\n};\n\n/**\n * parse_index_date_recv_local - Parse a Date Expando - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a custom Expando of the form, \"%(string)\".\n * The \"string\" will be passed to strftime().\n */\nstruct ExpandoNode *parse_index_date_recv_local(const char *str,\n                                                struct ExpandoFormat *fmt, int did,\n                                                int uid, ExpandoParserFlags flags,\n                                                const char **parsed_until,\n                                                struct ExpandoParseError *err)\n{\n  if (flags & EP_CONDITIONAL)\n  {\n    return node_conddate_parse(str, did, uid, parsed_until, err);\n  }\n\n  return node_expando_parse_enclosure(str, did, uid, ')', fmt, parsed_until, err);\n}\n\n/**\n * parse_index_date_local - Parse a Date Expando - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a custom expando of the form, \"%[string]\".\n * The \"string\" will be passed to strftime().\n */\nstruct ExpandoNode *parse_index_date_local(const char *str, struct ExpandoFormat *fmt,\n                                           int did, int uid, ExpandoParserFlags flags,\n                                           const char **parsed_until,\n                                           struct ExpandoParseError *err)\n{\n  if (flags & EP_CONDITIONAL)\n  {\n    return node_conddate_parse(str, did, uid, parsed_until, err);\n  }\n\n  return node_expando_parse_enclosure(str, did, uid, ']', fmt, parsed_until, err);\n}\n\n/**\n * parse_index_date - Parse a Date Expando - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a custom Expando of the form, \"%{string}\".\n * The \"string\" will be passed to strftime().\n */\nstruct ExpandoNode *parse_index_date(const char *str, struct ExpandoFormat *fmt,\n                                     int did, int uid, ExpandoParserFlags flags,\n                                     const char **parsed_until,\n                                     struct ExpandoParseError *err)\n{\n  if (flags & EP_CONDITIONAL)\n  {\n    return node_conddate_parse(str, did, uid, parsed_until, err);\n  }\n\n  return node_expando_parse_enclosure(str, did, uid, '}', fmt, parsed_until, err);\n}\n\n/**\n * parse_index_hook - Parse an index-hook - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a custom Expando of the form, \"%@name@\".\n * The \"name\" will be looked up as an index-hook, then the result parsed as an\n * Expando.\n */\nstruct ExpandoNode *parse_index_hook(const char *str, struct ExpandoFormat *fmt,\n                                     int did, int uid, ExpandoParserFlags flags,\n                                     const char **parsed_until,\n                                     struct ExpandoParseError *err)\n{\n  if (flags & EP_CONDITIONAL)\n  {\n    snprintf(err->message, sizeof(err->message),\n             _(\"index-hook cannot be used as a condition\"));\n    err->position = str;\n    return NULL;\n  }\n\n  return node_expando_parse_enclosure(str, did, uid, '@', fmt, parsed_until, err);\n}\n\n/**\n * parse_tags_transformed - Parse a Tags-Transformed Expando - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a custom expando of the form, \"%G?\" where '?' is an alpha-numeric character.\n */\nstruct ExpandoNode *parse_tags_transformed(const char *str, struct ExpandoFormat *fmt,\n                                           int did, int uid, ExpandoParserFlags flags,\n                                           const char **parsed_until,\n                                           struct ExpandoParseError *err)\n{\n  // Tag expando %G must use an suffix from [A-Za-z0-9], e.g. %Ga, %GL\n  if (!isalnum(str[1]))\n    return NULL;\n\n  // Let the basic expando parser do the work\n  flags |= EP_NO_CUSTOM_PARSE;\n  struct ExpandoNode *node = parse_short_name(str, IndexFormatDef, flags, fmt,\n                                              parsed_until, err);\n\n  // but adjust the node to take one more character\n  node->text = mutt_strn_dup((*parsed_until) - 1, 2);\n  (*parsed_until)++;\n\n  if (flags & EP_CONDITIONAL)\n  {\n    node->type = ENT_CONDBOOL;\n    node->render = node_condbool_render;\n  }\n\n  return node;\n}\n\n/**\n * parse_subject - Parse a Subject Expando - Implements ExpandoDefinition::parse() - @ingroup expando_parse_api\n *\n * Parse a Subject Expando, \"%s\", into two separate Nodes.\n * One for the tree, one for the subject.\n */\nstruct ExpandoNode *parse_subject(const char *str, struct ExpandoFormat *fmt,\n                                  int did, int uid, ExpandoParserFlags flags,\n                                  const char **parsed_until, struct ExpandoParseError *err)\n{\n  // Let the basic expando parser do the work\n  flags |= EP_NO_CUSTOM_PARSE;\n  struct ExpandoNode *node_subj = parse_short_name(str, IndexFormatDef, flags,\n                                                   NULL, parsed_until, err);\n\n  struct ExpandoNode *node_tree = node_expando_new(NULL, ED_ENVELOPE, ED_ENV_THREAD_TREE);\n  struct ExpandoNode *node_cont = node_container_new();\n\n  // Apply the formatting info to the container\n  node_cont->format = fmt;\n\n  node_add_child(node_cont, node_tree);\n  node_add_child(node_cont, node_subj);\n\n  return node_cont;\n}\n\n/**\n * IndexFormatDef - Expando definitions\n *\n * Config:\n * - $attribution_intro\n * - $attribution_trailer\n * - $forward_attribution_intro\n * - $forward_attribution_trailer\n * - $forward_format\n * - $index_format\n * - $message_format\n * - $pager_format\n *\n * @note Longer Expandos must precede any similar, but shorter Expandos\n */\nconst struct ExpandoDefinition IndexFormatDef[] = {\n  // clang-format off\n  { \"*\",  \"padding-soft\",        ED_GLOBAL,   ED_GLO_PADDING_SOFT,        node_padding_parse },\n  { \">\",  \"padding-hard\",        ED_GLOBAL,   ED_GLO_PADDING_HARD,        node_padding_parse },\n  { \"|\",  \"padding-eol\",         ED_GLOBAL,   ED_GLO_PADDING_EOL,         node_padding_parse },\n  { \"(\",  NULL,                  ED_EMAIL,    ED_EMA_STRF_RECV_LOCAL,     parse_index_date_recv_local },\n  { \"@\",  NULL,                  ED_EMAIL,    ED_EMA_INDEX_HOOK,          parse_index_hook },\n  { \"a\",  \"from\",                ED_ENVELOPE, ED_ENV_FROM,                NULL },\n  { \"A\",  \"reply-to\",            ED_ENVELOPE, ED_ENV_REPLY_TO,            NULL },\n  { \"b\",  \"mailbox-name\",        ED_MAILBOX,  ED_MBX_MAILBOX_NAME,        NULL },\n  { \"B\",  \"list-address\",        ED_ENVELOPE, ED_ENV_LIST_ADDRESS,        NULL },\n  { \"cr\", \"body-characters\",     ED_EMAIL,    ED_EMA_BODY_CHARACTERS,     NULL },\n  { \"c\",  \"size\",                ED_EMAIL,    ED_EMA_SIZE,                NULL },\n  { \"C\",  \"number\",              ED_EMAIL,    ED_EMA_NUMBER,              NULL },\n  { \"d\",  \"date-format\",         ED_EMAIL,    ED_EMA_DATE_FORMAT,         NULL },\n  { \"D\",  \"date-format-local\",   ED_EMAIL,    ED_EMA_DATE_FORMAT_LOCAL,   NULL },\n  { \"e\",  \"thread-number\",       ED_EMAIL,    ED_EMA_THREAD_NUMBER,       NULL },\n  { \"E\",  \"thread-count\",        ED_EMAIL,    ED_EMA_THREAD_COUNT,        NULL },\n  { \"f\",  \"from-full\",           ED_ENVELOPE, ED_ENV_FROM_FULL,           NULL },\n  { \"Fp\", \"sender-plain\",        ED_ENVELOPE, ED_ENV_SENDER_PLAIN,        NULL },\n  { \"F\",  \"sender\",              ED_ENVELOPE, ED_ENV_SENDER,              NULL },\n  { \"g\",  \"tags\",                ED_EMAIL,    ED_EMA_TAGS,                NULL },\n  { \"G\",  \"tags-transformed\",    ED_EMAIL,    ED_EMA_TAGS_TRANSFORMED,    parse_tags_transformed },\n  { \"H\",  \"spam\",                ED_ENVELOPE, ED_ENV_SPAM,                NULL },\n  { \"i\",  \"message-id\",          ED_ENVELOPE, ED_ENV_MESSAGE_ID,          NULL },\n  { \"I\",  \"initials\",            ED_ENVELOPE, ED_ENV_INITIALS,            NULL },\n  { \"J\",  \"thread-tags\",         ED_EMAIL,    ED_EMA_THREAD_TAGS,         NULL },\n  { \"K\",  \"list-empty\",          ED_ENVELOPE, ED_ENV_LIST_EMPTY,          NULL },\n  { \"l\",  \"lines\",               ED_EMAIL,    ED_EMA_LINES,               NULL },\n  { \"L\",  \"from-list\",           ED_EMAIL,    ED_EMA_FROM_LIST,           NULL },\n  { \"m\",  \"message-count\",       ED_MAILBOX,  ED_MBX_MESSAGE_COUNT,       NULL },\n  { \"M\",  \"thread-hidden-count\", ED_EMAIL,    ED_EMA_THREAD_HIDDEN_COUNT, NULL },\n  { \"n\",  \"name\",                ED_ENVELOPE, ED_ENV_NAME,                NULL },\n  { \"N\",  \"score\",               ED_EMAIL,    ED_EMA_SCORE,               NULL },\n  { \"O\",  \"save-folder\",         ED_EMAIL,    ED_EMA_LIST_OR_SAVE_FOLDER, NULL },\n  { \"P\",  \"percentage\",          ED_MAILBOX,  ED_MBX_PERCENTAGE,          NULL },\n  { \"q\",  \"newsgroup\",           ED_ENVELOPE, ED_ENV_NEWSGROUP,           NULL },\n  { \"r\",  \"to-all\",              ED_ENVELOPE, ED_ENV_TO_ALL,              NULL },\n  { \"R\",  \"cc-all\",              ED_ENVELOPE, ED_ENV_CC_ALL,              NULL },\n  { \"s\",  \"subject\",             ED_ENVELOPE, ED_ENV_SUBJECT,             parse_subject },\n  { \"S\",  \"flag-chars\",          ED_EMAIL,    ED_EMA_FLAG_CHARS,          NULL },\n  { \"t\",  \"to\",                  ED_ENVELOPE, ED_ENV_TO,                  NULL },\n  { \"T\",  \"to-chars\",            ED_EMAIL,    ED_EMA_TO_CHARS,            NULL },\n  { \"u\",  \"username\",            ED_ENVELOPE, ED_ENV_USERNAME,            NULL },\n  { \"v\",  \"first-name\",          ED_ENVELOPE, ED_ENV_FIRST_NAME,          NULL },\n  { \"W\",  \"organization\",        ED_ENVELOPE, ED_ENV_ORGANIZATION,        NULL },\n  { \"x\",  \"x-comment-to\",        ED_ENVELOPE, ED_ENV_X_COMMENT_TO,        NULL },\n  { \"X\",  \"attachment-count\",    ED_EMAIL,    ED_EMA_ATTACHMENT_COUNT,    NULL },\n  { \"y\",  \"x-label\",             ED_ENVELOPE, ED_ENV_X_LABEL,             NULL },\n  { \"Y\",  \"thread-x-label\",      ED_ENVELOPE, ED_ENV_THREAD_X_LABEL,      NULL },\n  { \"Z\",  \"combined-flags\",      ED_EMAIL,    ED_EMA_COMBINED_FLAGS,      NULL },\n  { \"zc\", \"crypto-flags\",        ED_EMAIL,    ED_EMA_CRYPTO_FLAGS,        NULL },\n  { \"zs\", \"status-flags\",        ED_EMAIL,    ED_EMA_STATUS_FLAGS,        NULL },\n  { \"zt\", \"message-flags\",       ED_EMAIL,    ED_EMA_MESSAGE_FLAGS,       NULL },\n  { \"[\",  NULL,                  ED_EMAIL,    ED_EMA_DATE_STRF_LOCAL,     parse_index_date_local },\n  { \"{\",  NULL,                  ED_EMAIL,    ED_EMA_DATE_STRF,           parse_index_date },\n  { NULL, NULL, 0, -1, NULL }\n  // clang-format on\n};\n\n/// IndexFormatDefNoPadding - Index format definitions, without padding\nstatic const struct ExpandoDefinition *const IndexFormatDefNoPadding = &(IndexFormatDef[3]);\n\n/// StatusFormatDefNoPadding - Status format definitions, without padding\nconst struct ExpandoDefinition *const StatusFormatDefNoPadding = &(StatusFormatDef[3]);\n\n/**\n * MainVars - General Config definitions for NeoMutt\n */\nstatic struct ConfigDef MainVars[] = {\n  // clang-format off\n  { \"abort_backspace\", DT_BOOL, true, 0, NULL,\n    \"Hitting backspace against an empty prompt aborts the prompt\"\n  },\n  { \"abort_key\", DT_STRING|D_NOT_EMPTY|D_ON_STARTUP, IP \"\\007\", 0, NULL,\n    \"String representation of key to abort prompts\"\n  },\n  { \"ascii_chars\", DT_BOOL, false, 0, NULL,\n    \"Use plain ASCII characters, when drawing email threads\"\n  },\n  { \"assumed_charset\", DT_SLIST|D_SLIST_SEP_COLON|D_SLIST_ALLOW_EMPTY, 0, 0, charset_slist_validator,\n    \"If a message is missing a character set, assume this character set\"\n  },\n  { \"attach_format\", DT_EXPANDO|D_NOT_EMPTY, IP \"%u%D%I %t%4n %T%d %> [%.7m/%.10M, %.6e%<C?, %C>, %s] \", IP &AttachFormatDef, NULL,\n    \"printf-like format string for the attachment menu\"\n  },\n  { \"attach_save_dir\", DT_PATH|D_PATH_DIR, IP \"./\", 0, NULL,\n    \"Default directory where attachments are saved\"\n  },\n  { \"attach_save_without_prompting\", DT_BOOL, false, 0, NULL,\n    \"If true, then don't prompt to save\"\n  },\n  { \"attach_sep\", DT_STRING, IP \"\\n\", 0, NULL,\n    \"Separator to add between saved/printed/piped attachments\"\n  },\n  { \"attach_split\", DT_BOOL, true, 0, NULL,\n    \"Save/print/pipe tagged messages individually\"\n  },\n  { \"auto_edit\", DT_BOOL, false, 0, NULL,\n    \"Skip the initial compose menu and edit the email\"\n  },\n  { \"auto_tag\", DT_BOOL, false, 0, NULL,\n    \"Automatically apply actions to all tagged messages\"\n  },\n  { \"beep\", DT_BOOL, true, 0, NULL,\n    \"Make a noise when an error occurs\"\n  },\n  { \"beep_new\", DT_BOOL, false, 0, NULL,\n    \"Make a noise when new mail arrives\"\n  },\n  { \"bounce\", DT_QUAD, MUTT_ASKYES, 0, NULL,\n    \"Confirm before bouncing a message\"\n  },\n  { \"braille_friendly\", DT_BOOL, false, 0, NULL,\n    \"Move the cursor to the beginning of the line\"\n  },\n  { \"charset\", DT_STRING|D_NOT_EMPTY|D_CHARSET_SINGLE, 0, 0, charset_validator,\n    \"Default character set for displaying text on screen\"\n  },\n  { \"collapse_flagged\", DT_BOOL, true, 0, NULL,\n    \"Prevent the collapse of threads with flagged emails\"\n  },\n  { \"collapse_unread\", DT_BOOL, true, 0, NULL,\n    \"Prevent the collapse of threads with unread emails\"\n  },\n  { \"color_directcolor\", DT_BOOL|D_ON_STARTUP, false, 0, NULL,\n    \"Use 24bit colors (aka truecolor aka directcolor)\"\n  },\n  { \"config_charset\", DT_STRING, 0, 0, charset_validator,\n    \"Character set that the config files are in\"\n  },\n  { \"confirm_append\", DT_BOOL, true, 0, NULL,\n    \"Confirm before appending emails to a mailbox\"\n  },\n  { \"confirm_create\", DT_BOOL, true, 0, NULL,\n    \"Confirm before creating a new mailbox\"\n  },\n  { \"copy_decode_weed\", DT_BOOL, false, 0, NULL,\n    \"Controls whether to weed headers when copying or saving emails\"\n  },\n  { \"count_alternatives\", DT_BOOL, false, 0, NULL,\n    \"Recurse inside multipart/alternatives while counting attachments\"\n  },\n  { \"crypt_chars\", DT_MBTABLE, IP \"SPsK \", 0, NULL,\n    \"User-configurable crypto flags: signed, encrypted etc.\"\n  },\n  { \"date_format\", DT_STRING|D_NOT_EMPTY, IP \"!%a, %b %d, %Y at %I:%M:%S%p %Z\", 0, NULL,\n    \"strftime format string for the `%d` expando\"\n  },\n  { \"debug_file\", DT_PATH|D_PATH_FILE, IP \"~/.neomuttdebug\", 0, NULL,\n    \"File to save debug logs\"\n  },\n  { \"debug_level\", DT_NUMBER, 0, 0, level_validator,\n    \"Logging level for debug logs\"\n  },\n  { \"default_hook\", DT_STRING, IP \"~f %s !~P | (~P ~C %s)\", 0, NULL,\n    \"Pattern to use for hooks that only have a simple regex\"\n  },\n  { \"delete\", DT_QUAD, MUTT_ASKYES, 0, NULL,\n    \"Really delete messages, when the mailbox is closed\"\n  },\n  { \"delete_untag\", DT_BOOL, true, 0, NULL,\n    \"Untag messages when they are marked for deletion\"\n  },\n  { \"digest_collapse\", DT_BOOL, true, 0, NULL,\n    \"Hide the subparts of a multipart/digest\"\n  },\n  { \"duplicate_threads\", DT_BOOL, true, 0, NULL,\n    \"Highlight messages with duplicated message IDs\"\n  },\n  { \"editor\", DT_STRING|D_NOT_EMPTY|D_STRING_COMMAND, 0, 0, NULL,\n    \"External command to use as an email editor\"\n  },\n  { \"flag_chars\", DT_MBTABLE, IP \"*!DdrONon- \", 0, NULL,\n    \"User-configurable index flags: tagged, new, etc\"\n  },\n  { \"flag_safe\", DT_BOOL, false, 0, NULL,\n    \"Protect flagged messages from deletion\"\n  },\n  { \"folder\", DT_STRING|D_STRING_MAILBOX, IP \"~/Mail\", 0, NULL,\n    \"Base folder for a set of mailboxes\"\n  },\n  { \"force_name\", DT_BOOL, false, 0, NULL,\n    \"Save outgoing mail in a folder of their name\"\n  },\n  { \"forward_decode\", DT_BOOL, true, 0, NULL,\n    \"Decode the message when forwarding it\"\n  },\n  { \"forward_quote\", DT_BOOL, false, 0, NULL,\n    \"Automatically quote a forwarded message using `$indent_string`\"\n  },\n  { \"from\", DT_ADDRESS, 0, 0, NULL,\n    \"Default 'From' address to use, if isn't otherwise set\"\n  },\n  { \"from_chars\", DT_MBTABLE, 0, 0, NULL,\n    \"User-configurable index flags: to address, cc address, etc\"\n  },\n  { \"gecos_mask\", DT_REGEX, IP \"^[^,]*\", 0, NULL,\n    \"Regex for parsing GECOS field of /etc/passwd\"\n  },\n  { \"header\", DT_BOOL, false, 0, NULL,\n    \"Include the message headers in the reply email (Weed applies)\"\n  },\n  { \"hide_limited\", DT_BOOL, false, 0, NULL,\n    \"Don't indicate hidden messages, in the thread tree\"\n  },\n  { \"hide_missing\", DT_BOOL, true, 0, NULL,\n    \"Don't indicate missing messages, in the thread tree\"\n  },\n  { \"hide_thread_subject\", DT_BOOL, true, 0, NULL,\n    \"Hide subjects that are similar to that of the parent message\"\n  },\n  { \"hide_top_limited\", DT_BOOL, false, 0, NULL,\n    \"Don't indicate hidden top message, in the thread tree\"\n  },\n  { \"hide_top_missing\", DT_BOOL, true, 0, NULL,\n    \"Don't indicate missing top message, in the thread tree\"\n  },\n  { \"honor_disposition\", DT_BOOL, false, 0, NULL,\n    \"Don't display MIME parts inline if they have a disposition of 'attachment'\"\n  },\n  { \"hostname\", DT_STRING, 0, 0, NULL,\n    \"Fully-qualified domain name of this machine\"\n  },\n  { \"implicit_auto_view\", DT_BOOL, false, 0, NULL,\n    \"Display MIME attachments inline if a 'copiousoutput' mailcap entry exists\"\n  },\n  { \"include_encrypted\", DT_BOOL, false, 0, NULL,\n    \"Whether to include encrypted content when replying\"\n  },\n  { \"include_only_first\", DT_BOOL, false, 0, NULL,\n    \"Only include the first attachment when replying\"\n  },\n  { \"indent_string\", DT_EXPANDO, IP \"> \", IP IndexFormatDefNoPadding, NULL,\n    \"String used to indent 'reply' text\"\n  },\n  { \"index_format\", DT_EXPANDO|D_NOT_EMPTY, IP \"%4C %Z %{%b %d} %-15.15L (%<l?%4l&%4c>) %s\", IP &IndexFormatDef, NULL,\n    \"printf-like format string for the index menu (emails)\"\n  },\n  { \"keep_flagged\", DT_BOOL, false, 0, NULL,\n    \"Don't move flagged messages from `$spool_file` to `$mbox`\"\n  },\n  { \"local_date_header\", DT_BOOL, true, 0, NULL,\n    \"Convert the date in the Date header of sent emails into local timezone, UTC otherwise\"\n  },\n  { \"mail_check\", DT_NUMBER|D_INTEGER_NOT_NEGATIVE, 5, 0, NULL,\n    \"Number of seconds before NeoMutt checks for new mail\"\n  },\n  { \"mail_check_recent\", DT_BOOL, true, 0, NULL,\n    \"Notify the user about new mail since the last time the mailbox was opened\"\n  },\n  { \"mail_check_stats\", DT_BOOL, false, 0, NULL,\n    \"Periodically check for new mail\"\n  },\n  { \"mail_check_stats_interval\", DT_NUMBER|D_INTEGER_NOT_NEGATIVE, 60, 0, NULL,\n    \"How often to check for new mail\"\n  },\n  { \"mailcap_path\", DT_SLIST|D_SLIST_SEP_COLON, IP \"~/.mailcap:\" PKGDATADIR \"/mailcap:\" SYSCONFDIR \"/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap\", 0, NULL,\n    \"List of mailcap files (colon-separated)\"\n  },\n  { \"mailcap_sanitize\", DT_BOOL, true, 0, NULL,\n    \"Restrict the possible characters in mailcap expandos\"\n  },\n  { \"mark_old\", DT_BOOL, true, 0, NULL,\n    \"Mark new emails as old when leaving the mailbox\"\n  },\n  { \"mbox\", DT_STRING|D_STRING_MAILBOX, IP \"~/mbox\", 0, NULL,\n    \"Folder that receives read emails (see Move)\"\n  },\n  { \"mbox_type\", DT_ENUM, MUTT_MBOX, IP &MboxTypeDef, NULL,\n    \"Default type for creating new mailboxes\"\n  },\n  { \"message_cache_clean\", DT_BOOL, false, 0, NULL,\n    \"(imap/pop) Clean out obsolete entries from the message cache\"\n  },\n  { \"message_cache_dir\", DT_PATH|D_PATH_DIR, 0, 0, NULL,\n    \"(imap/pop) Directory for the message cache\"\n  },\n  { \"message_format\", DT_EXPANDO|D_NOT_EMPTY, IP \"%s\", IP &IndexFormatDef, NULL,\n    \"printf-like format string for listing attached messages\"\n  },\n  { \"meta_key\", DT_BOOL, false, 0, NULL,\n    \"Interpret 'ALT-x' as 'ESC-x'\"\n  },\n  { \"mime_forward\", DT_QUAD, MUTT_NO, 0, NULL,\n    \"Forward a message as a 'message/RFC822' MIME part\"\n  },\n  { \"mime_forward_rest\", DT_QUAD, MUTT_YES, 0, NULL,\n    \"Forward all attachments, even if they can't be decoded\"\n  },\n  { \"move\", DT_QUAD, MUTT_NO, 0, NULL,\n    \"Move emails from `$spool_file` to `$mbox` when read\"\n  },\n  { \"narrow_tree\", DT_BOOL, false, 0, NULL,\n    \"Draw a narrower thread tree in the index\"\n  },\n  { \"new_mail_command\", DT_EXPANDO|D_STRING_COMMAND, 0, IP StatusFormatDefNoPadding, NULL,\n    \"External command to run when new mail arrives\"\n  },\n  { \"pipe_decode\", DT_BOOL, false, 0, NULL,\n    \"Decode the message when piping it\"\n  },\n  { \"pipe_decode_weed\", DT_BOOL, true, 0, NULL,\n    \"Control whether to weed headers when piping an email\"\n  },\n  { \"pipe_sep\", DT_STRING, IP \"\\n\", 0, NULL,\n    \"Separator to add between multiple piped messages\"\n  },\n  { \"pipe_split\", DT_BOOL, false, 0, NULL,\n    \"Run the pipe command on each message separately\"\n  },\n  { \"postponed\", DT_STRING|D_STRING_MAILBOX, IP \"~/postponed\", 0, NULL,\n    \"Folder to store postponed messages\"\n  },\n  { \"preferred_languages\", DT_SLIST|D_SLIST_SEP_COMMA, 0, 0, NULL,\n    \"List of Preferred Languages for multilingual MIME (comma-separated)\"\n  },\n  { \"print\", DT_QUAD, MUTT_ASKNO, 0, NULL,\n    \"Confirm before printing a message\"\n  },\n  { \"print_command\", DT_STRING|D_STRING_COMMAND, IP \"lpr\", 0, NULL,\n    \"External command to print a message\"\n  },\n  { \"print_decode\", DT_BOOL, true, 0, NULL,\n    \"Decode message before printing it\"\n  },\n  { \"print_decode_weed\", DT_BOOL, true, 0, NULL,\n    \"Control whether to weed headers when printing an email\"\n  },\n  { \"print_split\", DT_BOOL, false, 0, NULL,\n    \"Print multiple messages separately\"\n  },\n  { \"quit\", DT_QUAD, MUTT_YES, 0, NULL,\n    \"Prompt before exiting NeoMutt\"\n  },\n  { \"quote_regex\", DT_REGEX, IP \"^([ \\t]*[|>:}#])+\", 0, NULL,\n    \"Regex to match quoted text in a reply\"\n  },\n  { \"read_only\", DT_BOOL, false, 0, NULL,\n    \"Open folders in read-only mode\"\n  },\n  { \"real_name\", DT_STRING, 0, 0, NULL,\n    \"Real name of the user\"\n  },\n  { \"record\", DT_STRING|D_STRING_MAILBOX, IP \"~/sent\", 0, NULL,\n    \"Folder to save 'sent' messages\"\n  },\n  { \"reflow_space_quotes\", DT_BOOL, true, 0, NULL,\n    \"Insert spaces into reply quotes for 'format=flowed' messages\"\n  },\n  { \"reflow_text\", DT_BOOL, true, 0, NULL,\n    \"Reformat paragraphs of 'format=flowed' text\"\n  },\n  { \"reflow_wrap\", DT_NUMBER, 78, 0, NULL,\n    \"Maximum paragraph width for reformatting 'format=flowed' text\"\n  },\n  { \"resolve\", DT_BOOL, true, 0, NULL,\n    \"Move to the next email whenever a command modifies an email\"\n  },\n  { \"resume_edited_draft_files\", DT_BOOL, true, 0, NULL,\n    \"Resume editing previously saved draft files\"\n  },\n  { \"save_address\", DT_BOOL, false, 0, NULL,\n    \"Use sender's full address as a default save folder\"\n  },\n  { \"save_empty\", DT_BOOL, true, 0, NULL,\n    \"(mbox,mmdf) Preserve empty mailboxes\"\n  },\n  { \"save_name\", DT_BOOL, false, 0, NULL,\n    \"Save outgoing message to mailbox of recipient's name if it exists\"\n  },\n  { \"score\", DT_BOOL, true, 0, NULL,\n    \"Use message scoring\"\n  },\n  { \"score_threshold_delete\", DT_NUMBER, -1, 0, NULL,\n    \"Messages with a lower score will be automatically deleted\"\n  },\n  { \"score_threshold_flag\", DT_NUMBER, 9999, 0, NULL,\n    \"Messages with a greater score will be automatically flagged\"\n  },\n  { \"score_threshold_read\", DT_NUMBER, -1, 0, NULL,\n    \"Messages with a lower score will be automatically marked read\"\n  },\n  { \"send_charset\", DT_SLIST|D_SLIST_SEP_COLON|D_SLIST_ALLOW_EMPTY|D_CHARSET_STRICT, IP \"us-ascii:iso-8859-1:utf-8\", 0, charset_slist_validator,\n    \"Character sets for outgoing mail\"\n  },\n  { \"shell\", DT_STRING|D_STRING_COMMAND, IP \"/bin/sh\", 0, NULL,\n    \"External command to run subshells in\"\n  },\n  { \"show_multipart_alternative\", DT_STRING, 0, 0, multipart_validator,\n    \"How to display 'multipart/alternative' MIME parts\"\n  },\n  { \"simple_search\", DT_STRING, IP \"~f %s | ~s %s\", 0, NULL,\n    \"Pattern to search for when search doesn't contain ~'s\"\n  },\n  { \"size_show_bytes\", DT_BOOL, false, 0, NULL,\n    \"Show smaller sizes in bytes\"\n  },\n  { \"size_show_fractions\", DT_BOOL, true, 0, NULL,\n    \"Show size fractions with a single decimal place\"\n  },\n  { \"size_show_mb\", DT_BOOL, true, 0, NULL,\n    \"Show sizes in megabytes for sizes greater than 1 megabyte\"\n  },\n  { \"size_units_on_left\", DT_BOOL, false, 0, NULL,\n    \"Show the units as a prefix to the size\"\n  },\n  { \"sleep_time\", DT_NUMBER|D_INTEGER_NOT_NEGATIVE, 1, 0, NULL,\n    \"Time to pause after certain info messages\"\n  },\n  { \"sort\", DT_SORT|D_SORT_REVERSE|D_SORT_LAST, EMAIL_SORT_DATE, IP SortMethods, sort_validator,\n    \"Sort method for the index\"\n  },\n  { \"sort_aux\", DT_SORT|D_SORT_REVERSE|D_SORT_LAST, EMAIL_SORT_DATE, IP SortAuxMethods, NULL,\n    \"Secondary sort method for the index\"\n  },\n  { \"sort_re\", DT_BOOL, true, 0, NULL,\n    \"Whether $reply_regex must be matched when not $strict_threads\"\n  },\n  { \"spool_file\", DT_STRING|D_STRING_MAILBOX, 0, 0, NULL,\n    \"Inbox\"\n  },\n  { \"status_chars\", DT_MBTABLE, IP \"-*%A\", 0, NULL,\n    \"Indicator characters for the status bar\"\n  },\n  { \"status_on_top\", DT_BOOL, false, 0, NULL,\n    \"Display the status bar at the top\"\n  },\n  { \"strict_threads\", DT_BOOL, false, 0, NULL,\n    \"Thread messages using 'In-Reply-To' and 'References' headers\"\n  },\n  { \"suspend\", DT_BOOL, true, 0, NULL,\n    \"Allow the user to suspend NeoMutt using '^Z'\"\n  },\n  { \"text_flowed\", DT_BOOL, false, 0, NULL,\n    \"Generate 'format=flowed' messages\"\n  },\n  { \"thread_received\", DT_BOOL, false, 0, NULL,\n    \"Sort threaded messages by their received date\"\n  },\n  { \"timeout\", DT_NUMBER|D_INTEGER_NOT_NEGATIVE, 600, 0, NULL,\n    \"Time to wait for user input in menus\"\n  },\n  { \"tmp_dir\", DT_PATH|D_PATH_DIR|D_NOT_EMPTY, IP TMPDIR, 0, NULL,\n    \"Directory for temporary files\"\n  },\n  { \"to_chars\", DT_MBTABLE, IP \" +TCFLR\", 0, NULL,\n    \"Indicator characters for the 'To' field in the index\"\n  },\n  { \"trash\", DT_STRING|D_STRING_MAILBOX, 0, 0, NULL,\n    \"Folder to put deleted emails\"\n  },\n  { \"ts_enabled\", DT_BOOL, false, 0, NULL,\n    \"Allow NeoMutt to set the terminal status line and icon\"\n  },\n  // L10N: $ts_icon_format default format\n  { \"ts_icon_format\", DT_EXPANDO|D_L10N_STRING, IP N_(\"M%<n?AIL&ail>\"), IP StatusFormatDefNoPadding, NULL,\n    \"printf-like format string for the terminal's icon title\"\n  },\n  // L10N: $ts_status_format default format\n  { \"ts_status_format\", DT_EXPANDO|D_L10N_STRING, IP N_(\"NeoMutt with %<m?%m messages&no messages>%<n? [%n NEW]>\"), IP StatusFormatDefNoPadding, NULL,\n    \"printf-like format string for the terminal's status (window title)\"\n  },\n  { \"use_domain\", DT_BOOL, true, 0, NULL,\n    \"Qualify local addresses using this domain\"\n  },\n  { \"use_threads\", DT_ENUM, UT_UNSET, IP &UseThreadsTypeDef, NULL,\n    \"Whether to use threads for the index\"\n  },\n  { \"wait_key\", DT_BOOL, true, 0, NULL,\n    \"Prompt to press a key after running external commands\"\n  },\n  { \"weed\", DT_BOOL, true, 0, NULL,\n    \"Filter headers when displaying/forwarding/printing/replying\"\n  },\n  { \"wrap\", DT_NUMBER, 0, 0, NULL,\n    \"Width to wrap text in the pager\"\n  },\n  { \"wrap_search\", DT_BOOL, true, 0, NULL,\n    \"Wrap around when the search hits the end\"\n  },\n\n  { \"cursor_overlay\",            D_INTERNAL_DEPRECATED|DT_BOOL,   0, IP \"2020-07-20\" },\n  { \"escape\",                    D_INTERNAL_DEPRECATED|DT_STRING, 0, IP \"2021-03-18\" },\n  { \"ignore_linear_white_space\", D_INTERNAL_DEPRECATED|DT_BOOL,   0, IP \"2021-03-18\" },\n  { \"mixmaster\",                 D_INTERNAL_DEPRECATED|DT_STRING, 0, IP \"2024-05-30\" },\n  { \"mix_entry_format\",          D_INTERNAL_DEPRECATED|DT_EXPANDO,0, IP \"2024-05-30\" },\n  { \"visual\",                    D_INTERNAL_DEPRECATED|DT_STRING, 0, IP \"2021-03-18\" },\n\n  { \"autoedit\",                  DT_SYNONYM, IP \"auto_edit\",                  IP \"2021-03-21\" },\n  { \"confirmappend\",             DT_SYNONYM, IP \"confirm_append\",             IP \"2021-03-21\" },\n  { \"confirmcreate\",             DT_SYNONYM, IP \"confirm_create\",             IP \"2021-03-21\" },\n  { \"edit_hdrs\",                 DT_SYNONYM, IP \"edit_headers\",               IP \"2021-03-21\" },\n  { \"forw_decode\",               DT_SYNONYM, IP \"forward_decode\",             IP \"2021-03-21\" },\n  { \"forw_quote\",                DT_SYNONYM, IP \"forward_quote\",              IP \"2021-03-21\" },\n  { \"hdr_format\",                DT_SYNONYM, IP \"index_format\",               IP \"2021-03-21\" },\n  { \"implicit_autoview\",         DT_SYNONYM, IP \"implicit_auto_view\",         IP \"2023-01-25\" },\n  { \"include_onlyfirst\",         DT_SYNONYM, IP \"include_only_first\",         IP \"2021-03-21\" },\n  { \"indent_str\",                DT_SYNONYM, IP \"indent_string\",              IP \"2021-03-21\" },\n  { \"message_cachedir\",          DT_SYNONYM, IP \"message_cache_dir\",          IP \"2023-01-25\" },\n  { \"mime_fwd\",                  DT_SYNONYM, IP \"mime_forward\",               IP \"2021-03-21\" },\n  { \"msg_format\",                DT_SYNONYM, IP \"message_format\",             IP \"2021-03-21\" },\n  { \"print_cmd\",                 DT_SYNONYM, IP \"print_command\",              IP \"2021-03-21\" },\n  { \"quote_regexp\",              DT_SYNONYM, IP \"quote_regex\",                IP \"2021-03-21\" },\n  { \"realname\",                  DT_SYNONYM, IP \"real_name\",                  IP \"2021-03-21\" },\n  { \"spoolfile\",                 DT_SYNONYM, IP \"spool_file\",                 IP \"2021-03-21\" },\n  { \"tmpdir\",                    DT_SYNONYM, IP \"tmp_dir\",                    IP \"2023-01-25\" },\n  { \"xterm_icon\",                DT_SYNONYM, IP \"ts_icon_format\",             IP \"2021-03-21\" },\n  { \"xterm_set_titles\",          DT_SYNONYM, IP \"ts_enabled\",                 IP \"2021-03-21\" },\n  { \"xterm_title\",               DT_SYNONYM, IP \"ts_status_format\",           IP \"2021-03-21\" },\n\n  { \"devel_security\", DT_BOOL, false, 0, NULL,\n    \"Devel feature: Security -- https://github.com/neomutt/neomutt/discussions/4251\"\n  },\n\n  { NULL },\n  // clang-format on\n};\n\n#if defined(HAVE_LIBIDN)\n/**\n * MainVarsIdn - IDN Config definitions\n */\nstatic struct ConfigDef MainVarsIdn[] = {\n  // clang-format off\n  { \"idn_decode\", DT_BOOL, true, 0, NULL,\n    \"(idn) Decode international domain names\"\n  },\n  { \"idn_encode\", DT_BOOL, true, 0, NULL,\n    \"(idn) Encode international domain names\"\n  },\n  { NULL },\n  // clang-format on\n};\n#endif\n\n/**\n * config_init_main - Register main config variables - Implements ::module_init_config_t - @ingroup cfg_module_api\n */\nstatic bool config_init_main(struct ConfigSet *cs)\n{\n  bool rc = cs_register_variables(cs, MainVars);\n\n#if defined(HAVE_LIBIDN)\n  rc |= cs_register_variables(cs, MainVarsIdn);\n#endif\n\n  return rc;\n}\n\n/**\n * init_types - Create the config types\n * @param cs Config items\n *\n * Define the config types, e.g. #DT_STRING.\n */\nstatic void init_types(struct ConfigSet *cs)\n{\n  CONFIG_INIT_TYPE(cs, Address);\n  CONFIG_INIT_TYPE(cs, Bool);\n  CONFIG_INIT_TYPE(cs, Enum);\n  CONFIG_INIT_TYPE(cs, Expando);\n  CONFIG_INIT_TYPE(cs, Long);\n  CONFIG_INIT_TYPE(cs, Mbtable);\n  CONFIG_INIT_TYPE(cs, MyVar);\n  CONFIG_INIT_TYPE(cs, Number);\n  CONFIG_INIT_TYPE(cs, Path);\n  CONFIG_INIT_TYPE(cs, Quad);\n  CONFIG_INIT_TYPE(cs, Regex);\n  CONFIG_INIT_TYPE(cs, Slist);\n  CONFIG_INIT_TYPE(cs, Sort);\n  CONFIG_INIT_TYPE(cs, String);\n}\n\n/**\n * init_variables - Define the config variables\n * @param cs Config items\n */\nstatic void init_variables(struct ConfigSet *cs)\n{\n  // Define the config variables\n  config_init_main(cs);\n  CONFIG_INIT_VARS(cs, alias);\n#if defined(USE_AUTOCRYPT)\n  CONFIG_INIT_VARS(cs, autocrypt);\n#endif\n  CONFIG_INIT_VARS(cs, browser);\n  CONFIG_INIT_VARS(cs, compose);\n  CONFIG_INIT_VARS(cs, conn);\n  CONFIG_INIT_VARS(cs, email);\n#if defined(USE_HCACHE)\n  CONFIG_INIT_VARS(cs, hcache);\n#endif\n  CONFIG_INIT_VARS(cs, helpbar);\n  CONFIG_INIT_VARS(cs, history);\n  CONFIG_INIT_VARS(cs, imap);\n  CONFIG_INIT_VARS(cs, index);\n  CONFIG_INIT_VARS(cs, maildir);\n  CONFIG_INIT_VARS(cs, mbox);\n  CONFIG_INIT_VARS(cs, menu);\n  CONFIG_INIT_VARS(cs, mh);\n  CONFIG_INIT_VARS(cs, ncrypt);\n  CONFIG_INIT_VARS(cs, nntp);\n#if defined(USE_NOTMUCH)\n  CONFIG_INIT_VARS(cs, notmuch);\n#endif\n  CONFIG_INIT_VARS(cs, pager);\n  CONFIG_INIT_VARS(cs, pattern);\n  CONFIG_INIT_VARS(cs, pop);\n  CONFIG_INIT_VARS(cs, progress);\n  CONFIG_INIT_VARS(cs, send);\n  CONFIG_INIT_VARS(cs, sidebar);\n}\n\n/**\n * init_config - Initialise the config system\n * @param cs Config items\n */\nvoid init_config(struct ConfigSet *cs)\n{\n  init_types(cs);\n  init_variables(cs);\n}\n"
        },
        {
          "name": "mutt_header.c",
          "type": "blob",
          "size": 11.296875,
          "content": "/**\n * @file\n * Manipulate an email's header\n *\n * @authors\n * Copyright (C) 2017-2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2023 Rayford Shireman\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_header Manipulate an email's header\n *\n * Manipulate an email's header\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <time.h>\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"mutt_header.h\"\n#include \"complete/lib.h\"\n#include \"editor/lib.h\"\n#include \"history/lib.h\"\n#include \"index/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"postpone/lib.h\"\n#include \"send/lib.h\"\n#include \"globals.h\"\n#include \"muttlib.h\"\n#include \"mview.h\"\n\n/**\n * label_ref_dec - Decrease the refcount of a label\n * @param m     Mailbox\n * @param label Label\n */\nstatic void label_ref_dec(struct Mailbox *m, char *label)\n{\n  struct HashElem *he = mutt_hash_find_elem(m->label_hash, label);\n  if (!he)\n    return;\n\n  uintptr_t count = (uintptr_t) he->data;\n  if (count <= 1)\n  {\n    mutt_hash_delete(m->label_hash, label, NULL);\n    return;\n  }\n\n  count--;\n  he->data = (void *) count;\n}\n\n/**\n * label_ref_inc - Increase the refcount of a label\n * @param m     Mailbox\n * @param label Label\n */\nstatic void label_ref_inc(struct Mailbox *m, char *label)\n{\n  uintptr_t count;\n\n  struct HashElem *he = mutt_hash_find_elem(m->label_hash, label);\n  if (!he)\n  {\n    count = 1;\n    mutt_hash_insert(m->label_hash, label, (void *) count);\n    return;\n  }\n\n  count = (uintptr_t) he->data;\n  count++;\n  he->data = (void *) count;\n}\n\n/**\n * label_message - Add an X-Label: field\n * @param[in]  m         Mailbox\n * @param[in]  e         Email\n * @param[out] new_label Set to true if this is a new label\n * @retval true The label was added\n */\nstatic bool label_message(struct Mailbox *m, struct Email *e, char *new_label)\n{\n  if (!e)\n    return false;\n  if (mutt_str_equal(e->env->x_label, new_label))\n    return false;\n\n  if (e->env->x_label)\n    label_ref_dec(m, e->env->x_label);\n  if (mutt_str_replace(&e->env->x_label, new_label))\n    label_ref_inc(m, e->env->x_label);\n\n  e->changed = true;\n  e->env->changed |= MUTT_ENV_CHANGED_XLABEL;\n  return true;\n}\n\n/**\n * mutt_label_message - Let the user label a message\n * @param mv Mailbox\n * @param ea Array of Emails to label\n * @retval num Number of messages changed\n */\nint mutt_label_message(struct MailboxView *mv, struct EmailArray *ea)\n{\n  if (!mv || !mv->mailbox || !ea)\n    return 0;\n\n  struct Mailbox *m = mv->mailbox;\n\n  int changed = 0;\n  struct Buffer *buf = buf_pool_get();\n\n  struct Email **ep = ARRAY_GET(ea, 0);\n  if (ARRAY_SIZE(ea) == 1)\n  {\n    // If there's only one email, use its label as a template\n    struct Email *e = *ep;\n    if (e->env->x_label)\n      buf_strcpy(buf, e->env->x_label);\n  }\n\n  if (mw_get_field(\"Label: \", buf, MUTT_COMP_NO_FLAGS, HC_OTHER, &CompleteLabelOps, NULL) != 0)\n  {\n    goto done;\n  }\n\n  char *new_label = buf->data;\n  SKIPWS(new_label);\n  if (*new_label == '\\0')\n    new_label = NULL;\n\n  ARRAY_FOREACH(ep, ea)\n  {\n    struct Email *e = *ep;\n    if (label_message(m, e, new_label))\n    {\n      changed++;\n      email_set_color(m, e);\n    }\n  }\n\ndone:\n  buf_pool_release(&buf);\n  return changed;\n}\n\n/**\n * mutt_edit_headers - Let the user edit the message header and body\n * @param editor Editor command\n * @param body   File containing message body\n * @param e      Email\n * @param fcc    Buffer for the fcc field\n */\nvoid mutt_edit_headers(const char *editor, const char *body, struct Email *e,\n                       struct Buffer *fcc)\n{\n  struct Buffer *path = buf_pool_get();\n  buf_mktemp(path);\n  FILE *fp_out = mutt_file_fopen(buf_string(path), \"w\");\n  if (!fp_out)\n  {\n    mutt_perror(\"%s\", buf_string(path));\n    goto cleanup;\n  }\n\n  mutt_env_to_local(e->env);\n  mutt_rfc822_write_header(fp_out, e->env, NULL, MUTT_WRITE_HEADER_EDITHDRS,\n                           false, false, NeoMutt->sub);\n  fputc('\\n', fp_out); /* tie off the header. */\n\n  /* now copy the body of the message. */\n  FILE *fp_in = mutt_file_fopen(body, \"r\");\n  if (!fp_in)\n  {\n    mutt_perror(\"%s\", body);\n    mutt_file_fclose(&fp_out);\n    mutt_file_unlink(buf_string(path));\n    goto cleanup;\n  }\n\n  mutt_file_copy_stream(fp_in, fp_out);\n\n  mutt_file_fclose(&fp_in);\n  mutt_file_fclose(&fp_out);\n\n  struct stat st = { 0 };\n  if (stat(buf_string(path), &st) == -1)\n  {\n    mutt_perror(\"%s\", buf_string(path));\n    goto cleanup;\n  }\n\n  time_t mtime = mutt_file_decrease_mtime(buf_string(path), &st);\n  if (mtime == (time_t) -1)\n  {\n    mutt_perror(\"%s\", buf_string(path));\n    goto cleanup;\n  }\n\n  mutt_edit_file(editor, buf_string(path));\n  if ((stat(buf_string(path), &st) != 0) || (mtime == st.st_mtime))\n  {\n    mutt_debug(LL_DEBUG1, \"temp file was not modified\\n\");\n    /* the file has not changed! */\n    mutt_file_unlink(buf_string(path));\n    goto cleanup;\n  }\n\n  mutt_file_unlink(body);\n  mutt_list_free(&e->env->userhdrs);\n\n  /* Read the temp file back in */\n  fp_in = mutt_file_fopen(buf_string(path), \"r\");\n  if (!fp_in)\n  {\n    mutt_perror(\"%s\", buf_string(path));\n    mutt_file_unlink(buf_string(path));\n    goto cleanup;\n  }\n\n  fp_out = mutt_file_fopen(body, \"w\");\n  if (!fp_out)\n  {\n    mutt_file_fclose(&fp_in);\n    mutt_file_unlink(buf_string(path));\n    mutt_perror(\"%s\", body);\n    goto cleanup;\n  }\n\n  struct Envelope *env_new = NULL;\n  char buf[1024] = { 0 };\n  env_new = mutt_rfc822_read_header(fp_in, NULL, true, false);\n  int bytes_read;\n  while ((bytes_read = fread(buf, 1, sizeof(buf), fp_in)) > 0)\n    fwrite(buf, 1, bytes_read, fp_out);\n  mutt_file_fclose(&fp_out);\n  mutt_file_fclose(&fp_in);\n  mutt_file_unlink(buf_string(path));\n\n  /* in case the user modifies/removes the In-Reply-To header with\n   * $edit_headers set, we remove References: as they're likely invalid;\n   * we can simply compare strings as we don't generate References for\n   * multiple Message-Ids in IRT anyways */\n  if (!OptNewsSend)\n  {\n    if (!STAILQ_EMPTY(&e->env->in_reply_to) &&\n        (STAILQ_EMPTY(&env_new->in_reply_to) ||\n         !mutt_str_equal(STAILQ_FIRST(&env_new->in_reply_to)->data,\n                         STAILQ_FIRST(&e->env->in_reply_to)->data)))\n    {\n      mutt_list_free(&e->env->references);\n    }\n  }\n\n  /* restore old info. */\n  mutt_list_free(&env_new->references);\n  STAILQ_SWAP(&env_new->references, &e->env->references, ListNode);\n\n  mutt_env_free(&e->env);\n  e->env = env_new;\n  env_new = NULL;\n\n  mutt_expand_aliases_env(e->env);\n\n  /* search through the user defined headers added to see if\n   * fcc: or attach: or pgp: or smime: was specified */\n\n  struct ListNode *np = NULL, *tmp = NULL;\n  STAILQ_FOREACH_SAFE(np, &e->env->userhdrs, entries, tmp)\n  {\n    bool keep = true;\n    size_t plen = 0;\n\n    // Check for header names: most specific first\n    if (fcc && ((plen = mutt_istr_startswith(np->data, \"X-Mutt-Fcc:\")) ||\n                (plen = mutt_istr_startswith(np->data, \"Mutt-Fcc:\")) ||\n                (plen = mutt_istr_startswith(np->data, \"fcc:\"))))\n    {\n      const char *p = mutt_str_skip_email_wsp(np->data + plen);\n      if (*p)\n      {\n        buf_strcpy(fcc, p);\n        buf_pretty_mailbox(fcc);\n      }\n      keep = false;\n    }\n    // Check for header names: most specific first\n    else if ((plen = mutt_istr_startswith(np->data, \"X-Mutt-Attach:\")) ||\n             (plen = mutt_istr_startswith(np->data, \"Mutt-Attach:\")) ||\n             (plen = mutt_istr_startswith(np->data, \"attach:\")))\n    {\n      struct Body *body2 = NULL;\n      struct Body *parts = NULL;\n\n      const char *p = mutt_str_skip_email_wsp(np->data + plen);\n      if (*p)\n      {\n        buf_reset(path);\n        for (; (p[0] != '\\0') && (p[0] != ' ') && (p[0] != '\\t'); p++)\n        {\n          if (p[0] == '\\\\')\n          {\n            if (p[1] == '\\0')\n              break;\n            p++;\n          }\n          buf_addch(path, *p);\n        }\n        p = mutt_str_skip_email_wsp(p);\n\n        buf_expand_path(path);\n        body2 = mutt_make_file_attach(buf_string(path), NeoMutt->sub);\n        if (body2)\n        {\n          body2->description = mutt_str_dup(p);\n          for (parts = e->body; parts->next; parts = parts->next)\n            ; // do nothing\n\n          parts->next = body2;\n        }\n        else\n        {\n          buf_pretty_mailbox(path);\n          mutt_error(_(\"%s: unable to attach file\"), buf_string(path));\n        }\n      }\n      keep = false;\n    }\n    // Check for header names: most specific first\n    else if (((WithCrypto & APPLICATION_PGP) != 0) &&\n             ((plen = mutt_istr_startswith(np->data, \"X-Mutt-PGP:\")) ||\n              (plen = mutt_istr_startswith(np->data, \"Mutt-PGP:\")) ||\n              (plen = mutt_istr_startswith(np->data, \"pgp:\"))))\n    {\n      SecurityFlags sec = mutt_parse_crypt_hdr(np->data + plen, false, APPLICATION_PGP);\n      if (sec != SEC_NO_FLAGS)\n        sec |= APPLICATION_PGP;\n      if (sec != e->security)\n      {\n        e->security = sec;\n        notify_send(e->notify, NT_EMAIL, NT_EMAIL_CHANGE, NULL);\n      }\n      keep = false;\n    }\n    // Check for header names: most specific first\n    else if (((WithCrypto & APPLICATION_SMIME) != 0) &&\n             ((plen = mutt_istr_startswith(np->data, \"X-Mutt-SMIME:\")) ||\n              (plen = mutt_istr_startswith(np->data, \"Mutt-SMIME:\")) ||\n              (plen = mutt_istr_startswith(np->data, \"smime:\"))))\n    {\n      SecurityFlags sec = mutt_parse_crypt_hdr(np->data + plen, false, APPLICATION_SMIME);\n      if (sec != SEC_NO_FLAGS)\n        sec |= APPLICATION_SMIME;\n      if (sec != e->security)\n      {\n        e->security = sec;\n        notify_send(e->notify, NT_EMAIL, NT_EMAIL_CHANGE, NULL);\n      }\n      keep = false;\n    }\n\n    if (!keep)\n    {\n      STAILQ_REMOVE(&e->env->userhdrs, np, ListNode, entries);\n      FREE(&np->data);\n      FREE(&np);\n    }\n  }\n\ncleanup:\n  buf_pool_release(&path);\n}\n\n/**\n * mutt_make_label_hash - Create a Hash Table to store the labels\n * @param m Mailbox\n */\nvoid mutt_make_label_hash(struct Mailbox *m)\n{\n  /* 131 is just a rough prime estimate of how many distinct\n   * labels someone might have in a mailbox.  */\n  m->label_hash = mutt_hash_new(131, MUTT_HASH_STRDUP_KEYS);\n}\n\n/**\n * mutt_label_hash_add - Add a message's labels to the Hash Table\n * @param m Mailbox\n * @param e Email\n */\nvoid mutt_label_hash_add(struct Mailbox *m, struct Email *e)\n{\n  if (!m || !m->label_hash)\n    return;\n  if (e->env->x_label)\n    label_ref_inc(m, e->env->x_label);\n}\n\n/**\n * mutt_label_hash_remove - Remove a message's labels from the Hash Table\n * @param m Mailbox\n * @param e Email\n */\nvoid mutt_label_hash_remove(struct Mailbox *m, struct Email *e)\n{\n  if (!m || !m->label_hash)\n    return;\n  if (e->env->x_label)\n    label_ref_dec(m, e->env->x_label);\n}\n"
        },
        {
          "name": "mutt_header.h",
          "type": "blob",
          "size": 1.2822265625,
          "content": "/**\n * @file\n * Representation of the email's header\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_HEADER_H\n#define MUTT_MUTT_HEADER_H\n\nstruct Buffer;\nstruct Email;\nstruct EmailArray;\nstruct Mailbox;\nstruct MailboxView;\n\nvoid mutt_edit_headers(const char *editor, const char *body, struct Email *e, struct Buffer *fcc);\nvoid mutt_label_hash_add(struct Mailbox *m, struct Email *e);\nvoid mutt_label_hash_remove(struct Mailbox *m, struct Email *e);\nint mutt_label_message(struct MailboxView *mv, struct EmailArray *ea);\nvoid mutt_make_label_hash(struct Mailbox *m);\n\n#endif /* MUTT_MUTT_HEADER_H */\n"
        },
        {
          "name": "mutt_logging.c",
          "type": "blob",
          "size": 7.5400390625,
          "content": "/**\n * @file\n * NeoMutt Logging\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2019 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_logging NeoMutt Logging\n *\n * NeoMutt Logging\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt_logging.h\"\n#include \"color/lib.h\"\n#include \"globals.h\"\n#include \"muttlib.h\"\n\nstatic uint64_t LastError = 0; ///< Time of the last error message (in milliseconds since the Unix epoch)\n\nstatic char *CurrentFile = NULL; ///< The previous log file name\nstatic const int NumOfLogs = 5;  ///< How many log files to rotate\n\n#define S_TO_MS 1000L\n\n/**\n * error_pause - Wait for an error message to be read\n *\n * If '$sleep_time' seconds hasn't elapsed since LastError, then wait\n */\nstatic void error_pause(void)\n{\n  const short c_sleep_time = cs_subset_number(NeoMutt->sub, \"sleep_time\");\n  const uint64_t elapsed = mutt_date_now_ms() - LastError;\n  const uint64_t sleep = c_sleep_time * S_TO_MS;\n  if ((LastError == 0) || (elapsed >= sleep))\n    return;\n\n  mutt_refresh();\n  mutt_date_sleep_ms(sleep - elapsed);\n}\n\n/**\n * mutt_clear_error - Clear the message line (bottom line of screen)\n */\nvoid mutt_clear_error(void)\n{\n  /* Make sure the error message has had time to be read */\n  if (OptMsgErr)\n    error_pause();\n\n  ErrorBufMessage = false;\n  if (!OptNoCurses)\n    msgwin_clear_text(NULL);\n}\n\n/**\n * log_disp_curses - Display a log line in the message line - Implements ::log_dispatcher_t - @ingroup logging_api\n */\nint log_disp_curses(time_t stamp, const char *file, int line, const char *function,\n                    enum LogLevel level, const char *format, ...)\n{\n  const short c_debug_level = cs_subset_number(NeoMutt->sub, \"debug_level\");\n  if (level > c_debug_level)\n    return 0;\n\n  char buf[LOG_LINE_MAX_LEN] = { 0 };\n\n  va_list ap;\n  va_start(ap, format);\n  int rc = vsnprintf(buf, sizeof(buf), format, ap);\n  va_end(ap);\n\n  if ((level == LL_PERROR) && (rc >= 0) && (rc < sizeof(buf)))\n  {\n    char *buf2 = buf + rc;\n    int len = sizeof(buf) - rc;\n    const char *p = strerror(errno);\n    if (!p)\n      p = _(\"unknown error\");\n\n    rc += snprintf(buf2, len, \": %s (errno = %d)\", p, errno);\n  }\n\n  const bool dupe = (mutt_str_equal(buf, ErrorBuf));\n  if (!dupe)\n  {\n    /* Only log unique messages */\n    log_disp_file(stamp, file, line, function, level, \"%s\", buf);\n    if (stamp == 0)\n      log_disp_queue(stamp, file, line, function, level, \"%s\", buf);\n  }\n\n  /* Don't display debugging message on screen */\n  if (level > LL_MESSAGE)\n    return 0;\n\n  /* Only pause if this is a message following an error */\n  if ((level > LL_ERROR) && OptMsgErr && !dupe)\n    error_pause();\n\n  mutt_str_copy(ErrorBuf, buf, sizeof(ErrorBuf));\n  ErrorBufMessage = true;\n\n  if (!OptKeepQuiet)\n  {\n    enum ColorId cid = MT_COLOR_NORMAL;\n    switch (level)\n    {\n      case LL_ERROR:\n        mutt_beep(false);\n        cid = MT_COLOR_ERROR;\n        break;\n      case LL_WARNING:\n        cid = MT_COLOR_WARNING;\n        break;\n      default:\n        cid = MT_COLOR_MESSAGE;\n        break;\n    }\n\n    msgwin_set_text(NULL, ErrorBuf, cid);\n  }\n\n  if ((level <= LL_ERROR) && !dupe)\n  {\n    OptMsgErr = true;\n    LastError = mutt_date_now_ms();\n  }\n  else\n  {\n    OptMsgErr = false;\n    LastError = 0;\n  }\n\n  window_redraw(msgwin_get_window());\n  return rc;\n}\n\n/**\n * mutt_log_prep - Prepare to log\n */\nvoid mutt_log_prep(void)\n{\n  char ver[64] = { 0 };\n  snprintf(ver, sizeof(ver), \"-%s%s\", PACKAGE_VERSION, GitVer);\n  log_file_set_version(ver);\n}\n\n/**\n * mutt_log_stop - Close the log file\n */\nvoid mutt_log_stop(void)\n{\n  log_file_close(false);\n  FREE(&CurrentFile);\n}\n\n/**\n * mutt_log_set_file - Change the logging file\n * @param file Name to use\n * @retval  0 Success, file opened\n * @retval -1 Error, see errno\n *\n * Close the old log, rotate the new logs and open the new log.\n */\nint mutt_log_set_file(const char *file)\n{\n  const char *const c_debug_file = cs_subset_path(NeoMutt->sub, \"debug_file\");\n  if (!mutt_str_equal(CurrentFile, c_debug_file))\n  {\n    struct Buffer *expanded = buf_pool_get();\n    buf_addstr(expanded, c_debug_file);\n    buf_expand_path(expanded);\n\n    const char *name = mutt_file_rotate(buf_string(expanded), NumOfLogs);\n    buf_pool_release(&expanded);\n    if (!name)\n      return -1;\n\n    log_file_set_filename(name, false);\n    FREE(&name);\n    mutt_str_replace(&CurrentFile, c_debug_file);\n  }\n\n  cs_subset_str_string_set(NeoMutt->sub, \"debug_file\", file, NULL);\n\n  return 0;\n}\n\n/**\n * mutt_log_set_level - Change the logging level\n * @param level Logging level\n * @param verbose If true, then log the event\n * @retval  0 Success\n * @retval -1 Error, level is out of range\n */\nint mutt_log_set_level(enum LogLevel level, bool verbose)\n{\n  if (!CurrentFile)\n  {\n    const char *const c_debug_file = cs_subset_path(NeoMutt->sub, \"debug_file\");\n    mutt_log_set_file(c_debug_file);\n  }\n\n  if (log_file_set_level(level, verbose) != 0)\n    return -1;\n\n  cs_subset_str_native_set(NeoMutt->sub, \"debug_level\", level, NULL);\n  return 0;\n}\n\n/**\n * mutt_log_start - Enable file logging\n * @retval  0 Success, or already running\n * @retval -1 Failed to start\n *\n * This also handles file rotation.\n */\nint mutt_log_start(void)\n{\n  const short c_debug_level = cs_subset_number(NeoMutt->sub, \"debug_level\");\n  if (c_debug_level < 1)\n    return 0;\n\n  if (log_file_running())\n    return 0;\n\n  const char *const c_debug_file = cs_subset_path(NeoMutt->sub, \"debug_file\");\n  mutt_log_set_file(c_debug_file);\n\n  /* This will trigger the file creation */\n  if (log_file_set_level(c_debug_level, true) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * level_validator - Validate the \"debug_level\" config variable - Implements ConfigDef::validator() - @ingroup cfg_def_validator\n */\nint level_validator(const struct ConfigSet *cs, const struct ConfigDef *cdef,\n                    intptr_t value, struct Buffer *err)\n{\n  if ((value < 0) || (value >= LL_MAX))\n  {\n    buf_printf(err, _(\"Invalid value for option %s: %ld\"), cdef->name, (long) value);\n    return CSR_ERR_INVALID;\n  }\n\n  return CSR_SUCCESS;\n}\n\n/**\n * main_log_observer - Notification that a Config Variable has changed - Implements ::observer_t - @ingroup observer_api\n */\nint main_log_observer(struct NotifyCallback *nc)\n{\n  if (nc->event_type != NT_CONFIG)\n    return 0;\n  if (!nc->event_data)\n    return -1;\n\n  struct EventConfig *ev_c = nc->event_data;\n\n  if (mutt_str_equal(ev_c->name, \"debug_file\"))\n  {\n    const char *const c_debug_file = cs_subset_path(NeoMutt->sub, \"debug_file\");\n    mutt_log_set_file(c_debug_file);\n  }\n  else if (mutt_str_equal(ev_c->name, \"debug_level\"))\n  {\n    const short c_debug_level = cs_subset_number(NeoMutt->sub, \"debug_level\");\n    mutt_log_set_level(c_debug_level, true);\n  }\n  else\n  {\n    return 0;\n  }\n\n  mutt_debug(LL_DEBUG5, \"log done\\n\");\n  return 0;\n}\n"
        },
        {
          "name": "mutt_logging.h",
          "type": "blob",
          "size": 1.5263671875,
          "content": "/**\n * @file\n * NeoMutt Logging\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_LOGGING_H\n#define MUTT_MUTT_LOGGING_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <time.h>\n#include \"mutt/lib.h\"\n\nstruct ConfigDef;\nstruct ConfigSet;\n\nint log_disp_curses(time_t stamp, const char *file, int line, const char *function, enum LogLevel level, const char *format, ...)\n                    __attribute__((__format__(__printf__, 6, 7)));\n\nvoid mutt_log_prep(void);\nint  mutt_log_start(void);\nvoid mutt_log_stop(void);\nint  mutt_log_set_level(enum LogLevel level, bool verbose);\nint  mutt_log_set_file(const char *file);\n\nint  main_log_observer(struct NotifyCallback *nc);\nint  level_validator(const struct ConfigSet *cs, const struct ConfigDef *cdef, intptr_t value, struct Buffer *err);\n\nvoid mutt_clear_error(void);\n\n#endif /* MUTT_MUTT_LOGGING_H */\n"
        },
        {
          "name": "mutt_lua.c",
          "type": "blob",
          "size": 12.5546875,
          "content": "/**\n * @file\n * Integrated Lua scripting\n *\n * @authors\n * Copyright (C) 2016-2017 Bernard Pratz <z+mutt+pub@m0g.net>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Victor Fernandes <criw@pm.me>\n * Copyright (C) 2019 Ian Zimmerman <itz@no-use.mooo.com>\n * Copyright (C) 2019-2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2023 Rayford Shireman\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_lua Integrated Lua scripting\n *\n * Integrated Lua scripting\n */\n\n#ifndef LUA_COMPAT_ALL\n#define LUA_COMPAT_ALL\n#endif\n#ifndef LUA_COMPAT_5_1\n#define LUA_COMPAT_5_1\n#endif\n\n#include \"config.h\"\n#include <lauxlib.h>\n#include <lua.h>\n#include <lualib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n#include \"mutt_lua.h\"\n#include \"parse/lib.h\"\n#include \"muttlib.h\"\n\n/// Global Lua State\nstatic lua_State *LuaState = NULL;\n\n/**\n * LuaCommands - List of NeoMutt commands to register\n */\nstatic const struct Command LuaCommands[] = {\n  // clang-format off\n  { \"lua\",        mutt_lua_parse,       0 },\n  { \"lua-source\", mutt_lua_source_file, 0 },\n  // clang-format on\n};\n\n/**\n * handle_panic - Handle a panic in the Lua interpreter\n * @param l Lua State\n * @retval -1 Always\n */\nstatic int handle_panic(lua_State *l)\n{\n  mutt_debug(LL_DEBUG1, \"lua runtime panic: %s\\n\", lua_tostring(l, -1));\n  mutt_error(\"Lua runtime panic: %s\", lua_tostring(l, -1));\n  lua_pop(l, 1);\n  return -1;\n}\n\n/**\n * handle_error - Handle an error in the Lua interpreter\n * @param l Lua State\n * @retval -1 Always\n */\nstatic int handle_error(lua_State *l)\n{\n  mutt_debug(LL_DEBUG1, \"lua runtime error: %s\\n\", lua_tostring(l, -1));\n  mutt_error(\"Lua runtime error: %s\", lua_tostring(l, -1));\n  lua_pop(l, 1);\n  return -1;\n}\n\n/**\n * lua_mutt_call - Call a NeoMutt command by name\n * @param l Lua State\n * @retval >=0 Success\n * @retval -1 Error\n */\nstatic int lua_mutt_call(lua_State *l)\n{\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_call()\\n\");\n  struct Buffer *err = buf_pool_get();\n  struct Buffer *token = buf_pool_get();\n  struct Buffer *buf = buf_pool_get();\n  const struct Command *cmd = NULL;\n  int rc = 0;\n\n  if (lua_gettop(l) == 0)\n  {\n    luaL_error(l, \"Error command argument required.\");\n    return -1;\n  }\n\n  cmd = command_get(lua_tostring(l, 1));\n  if (!cmd)\n  {\n    luaL_error(l, \"Error command %s not found.\", lua_tostring(l, 1));\n    return -1;\n  }\n\n  for (int i = 2; i <= lua_gettop(l); i++)\n  {\n    buf_addstr(buf, lua_tostring(l, i));\n    buf_addch(buf, ' ');\n  }\n  buf_seek(buf, 0);\n\n  if (cmd->parse(token, buf, cmd->data, err))\n  {\n    luaL_error(l, \"NeoMutt error: %s\", buf_string(err));\n    rc = -1;\n  }\n  else\n  {\n    if (!lua_pushstring(l, buf_string(err)))\n      handle_error(l);\n    else\n      rc++;\n  }\n\n  buf_pool_release(&buf);\n  buf_pool_release(&token);\n  buf_pool_release(&err);\n  return rc;\n}\n\n/**\n * lua_mutt_set - Set a NeoMutt variable\n * @param l Lua State\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int lua_mutt_set(lua_State *l)\n{\n  const char *param = lua_tostring(l, -2);\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_set(%s)\\n\", param);\n\n  struct Buffer *err = buf_pool_get();\n  struct HashElem *he = cs_subset_lookup(NeoMutt->sub, param);\n  if (!he)\n  {\n    // In case it is a my_var, we have to create it\n    if (mutt_str_startswith(param, \"my_\"))\n    {\n      struct ConfigDef my_cdef = { 0 };\n      my_cdef.name = param;\n      my_cdef.type = DT_MYVAR;\n      he = cs_create_variable(NeoMutt->sub->cs, &my_cdef, err);\n      if (!he)\n        return -1;\n    }\n    else\n    {\n      luaL_error(l, \"NeoMutt parameter not found %s\", param);\n      return -1;\n    }\n  }\n\n  struct ConfigDef *cdef = he->data;\n\n  int rc = 0;\n\n  switch (DTYPE(cdef->type))\n  {\n    case DT_ADDRESS:\n    case DT_ENUM:\n    case DT_MBTABLE:\n    case DT_MYVAR:\n    case DT_PATH:\n    case DT_REGEX:\n    case DT_SLIST:\n    case DT_SORT:\n    case DT_STRING:\n    {\n      const char *value = lua_tostring(l, -1);\n      size_t val_size = lua_rawlen(l, -1);\n      struct Buffer *value_buf = buf_pool_get();\n      buf_strcpy_n(value_buf, value, val_size);\n      if (DTYPE(he->type) == DT_PATH)\n        buf_expand_path(value_buf);\n\n      int rv = cs_subset_he_string_set(NeoMutt->sub, he, buf_string(value_buf), err);\n      buf_pool_release(&value_buf);\n      if (CSR_RESULT(rv) != CSR_SUCCESS)\n        rc = -1;\n      break;\n    }\n    case DT_NUMBER:\n    case DT_QUAD:\n    {\n      const intptr_t value = lua_tointeger(l, -1);\n      int rv = cs_subset_he_native_set(NeoMutt->sub, he, value, err);\n      if (CSR_RESULT(rv) != CSR_SUCCESS)\n        rc = -1;\n      break;\n    }\n    case DT_BOOL:\n    {\n      const intptr_t value = lua_toboolean(l, -1);\n      int rv = cs_subset_he_native_set(NeoMutt->sub, he, value, err);\n      if (CSR_RESULT(rv) != CSR_SUCCESS)\n        rc = -1;\n      break;\n    }\n    default:\n      luaL_error(l, \"Unsupported NeoMutt parameter type %d for %s\", DTYPE(cdef->type), param);\n      rc = -1;\n      break;\n  }\n\n  buf_pool_release(&err);\n  return rc;\n}\n\n/**\n * lua_mutt_get - Get a NeoMutt variable\n * @param l Lua State\n * @retval  1 Success\n * @retval -1 Error\n */\nstatic int lua_mutt_get(lua_State *l)\n{\n  const char *param = lua_tostring(l, -1);\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_get(%s)\\n\", param);\n\n  struct HashElem *he = cs_subset_lookup(NeoMutt->sub, param);\n  if (!he)\n  {\n    mutt_debug(LL_DEBUG2, \" * error\\n\");\n    luaL_error(l, \"NeoMutt parameter not found %s\", param);\n    return -1;\n  }\n\n  struct ConfigDef *cdef = he->data;\n\n  switch (DTYPE(cdef->type))\n  {\n    case DT_ADDRESS:\n    case DT_ENUM:\n    case DT_MBTABLE:\n    case DT_MYVAR:\n    case DT_REGEX:\n    case DT_SLIST:\n    case DT_SORT:\n    case DT_STRING:\n    {\n      struct Buffer *value = buf_pool_get();\n      int rc = cs_subset_he_string_get(NeoMutt->sub, he, value);\n      if (CSR_RESULT(rc) != CSR_SUCCESS)\n      {\n        buf_pool_release(&value);\n        return -1;\n      }\n\n      struct Buffer *escaped = buf_pool_get();\n      escape_string(escaped, buf_string(value));\n      lua_pushstring(l, buf_string(escaped));\n      buf_pool_release(&value);\n      buf_pool_release(&escaped);\n      return 1;\n    }\n    case DT_QUAD:\n      lua_pushinteger(l, (unsigned char) cdef->var);\n      return 1;\n    case DT_NUMBER:\n      lua_pushinteger(l, (signed short) cdef->var);\n      return 1;\n    case DT_BOOL:\n      lua_pushboolean(l, (bool) cdef->var);\n      return 1;\n    default:\n      luaL_error(l, \"NeoMutt parameter type %d unknown for %s\", cdef->type, param);\n      return -1;\n  }\n}\n\n/**\n * lua_mutt_enter - Execute NeoMutt config from Lua\n * @param l Lua State\n * @retval >=0 Success\n * @retval -1  Error\n */\nstatic int lua_mutt_enter(lua_State *l)\n{\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_enter()\\n\");\n  struct Buffer *err = buf_pool_get();\n  char *buf = mutt_str_dup(lua_tostring(l, -1));\n  int rc = 0;\n\n  if (parse_rc_line(buf, err))\n  {\n    luaL_error(l, \"NeoMutt error: %s\", buf_string(err));\n    rc = -1;\n  }\n  else\n  {\n    if (!lua_pushstring(l, buf_string(err)))\n      handle_error(l);\n    else\n      rc++;\n  }\n\n  FREE(&buf);\n  buf_pool_release(&err);\n\n  return rc;\n}\n\n/**\n * lua_mutt_message - Display a message in Neomutt\n * @param l Lua State\n * @retval 0 Always\n */\nstatic int lua_mutt_message(lua_State *l)\n{\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_message()\\n\");\n  const char *msg = lua_tostring(l, -1);\n  if (msg)\n    mutt_message(\"%s\", msg);\n  return 0;\n}\n\n/**\n * lua_mutt_error - Display an error in Neomutt\n * @param l Lua State\n * @retval 0 Always\n */\nstatic int lua_mutt_error(lua_State *l)\n{\n  mutt_debug(LL_DEBUG2, \" * lua_mutt_error()\\n\");\n  const char *msg = lua_tostring(l, -1);\n  if (msg)\n    mutt_error(\"%s\", msg);\n  return 0;\n}\n\n/**\n * lua_expose_command - Expose a NeoMutt command to the Lua interpreter\n * @param l   Lua state\n * @param cmd NeoMutt Command\n */\nstatic void lua_expose_command(lua_State *l, const struct Command *cmd)\n{\n  char buf[1024] = { 0 };\n  snprintf(buf, sizeof(buf), \"mutt.command.%s = function (...); mutt.call('%s', ...); end\",\n           cmd->name, cmd->name);\n  (void) luaL_dostring(l, buf);\n}\n\n/**\n * LuaMuttCommands - List of Lua commands to register\n *\n * In NeoMutt, run:\n *\n * `:lua mutt.message('hello')`\n *\n * and it will call lua_mutt_message()\n */\nstatic const luaL_Reg LuaMuttCommands[] = {\n  // clang-format off\n  { \"set\",     lua_mutt_set },\n  { \"get\",     lua_mutt_get },\n  { \"call\",    lua_mutt_call },\n  { \"enter\",   lua_mutt_enter },\n  { \"print\",   lua_mutt_message },\n  { \"message\", lua_mutt_message },\n  { \"error\",   lua_mutt_error },\n  { NULL, NULL },\n  // clang-format on\n};\n\n/**\n * luaopen_mutt_decl - Declare some NeoMutt types to the Lua interpreter\n * @param l Lua State\n * @retval 1 Always\n */\nstatic int luaopen_mutt_decl(lua_State *l)\n{\n  mutt_debug(LL_DEBUG2, \" * luaopen_mutt()\\n\");\n  luaL_newlib(l, LuaMuttCommands);\n  int lib_idx = lua_gettop(l);\n\n  // clang-format off\n  lua_pushstring(l, \"VERSION\");     lua_pushstring(l, mutt_make_version()); lua_settable(l, lib_idx);;\n  lua_pushstring(l, \"QUAD_YES\");    lua_pushinteger(l, MUTT_YES);           lua_settable(l, lib_idx);;\n  lua_pushstring(l, \"QUAD_NO\");     lua_pushinteger(l, MUTT_NO);            lua_settable(l, lib_idx);;\n  lua_pushstring(l, \"QUAD_ASKYES\"); lua_pushinteger(l, MUTT_ASKYES);        lua_settable(l, lib_idx);;\n  lua_pushstring(l, \"QUAD_ASKNO\");  lua_pushinteger(l, MUTT_ASKNO);         lua_settable(l, lib_idx);;\n  // clang-format on\n\n  return 1;\n}\n\n/**\n * luaopen_mutt - Expose a 'Mutt' object to the Lua interpreter\n * @param l Lua State\n */\nstatic void luaopen_mutt(lua_State *l)\n{\n  luaL_requiref(l, \"mutt\", luaopen_mutt_decl, 1);\n  (void) luaL_dostring(l, \"mutt.command = {}\");\n\n  struct Command *c = NULL;\n  for (size_t i = 0, size = commands_array(&c); i < size; i++)\n  {\n    lua_expose_command(l, &c[i]);\n  }\n}\n\n/**\n * lua_init - Initialise a Lua State\n * @param[out] l Lua State\n * @retval true Successful\n */\nstatic bool lua_init(lua_State **l)\n{\n  if (!l)\n    return false;\n  if (*l)\n    return true;\n\n  mutt_debug(LL_DEBUG2, \" * lua_init()\\n\");\n  *l = luaL_newstate();\n\n  if (!*l)\n  {\n    mutt_error(_(\"Error: Couldn't load the lua interpreter\"));\n    return false;\n  }\n\n  lua_atpanic(*l, handle_panic);\n\n  /* load various Lua libraries */\n  luaL_openlibs(*l);\n  luaopen_mutt(*l);\n\n  return true;\n}\n\n/**\n * mutt_lua_init - Setup feature commands\n */\nvoid mutt_lua_init(void)\n{\n  commands_register(LuaCommands, mutt_array_size(LuaCommands));\n}\n\n/**\n * mutt_lua_parse - Parse the 'lua' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult mutt_lua_parse(struct Buffer *buf, struct Buffer *s,\n                                  intptr_t data, struct Buffer *err)\n{\n  lua_init(&LuaState);\n  mutt_debug(LL_DEBUG2, \" * mutt_lua_parse(%s)\\n\", buf->data);\n\n  if (luaL_dostring(LuaState, s->dptr))\n  {\n    mutt_debug(LL_DEBUG2, \" * %s -> failure\\n\", s->dptr);\n    buf_printf(err, \"%s: %s\", s->dptr, lua_tostring(LuaState, -1));\n    /* pop error message from the stack */\n    lua_pop(LuaState, 1);\n    return MUTT_CMD_ERROR;\n  }\n  mutt_debug(LL_DEBUG2, \" * %s -> success\\n\", s->dptr);\n  buf_reset(s); // Clear the rest of the line\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * mutt_lua_source_file - Parse the 'lua-source' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult mutt_lua_source_file(struct Buffer *buf, struct Buffer *s,\n                                        intptr_t data, struct Buffer *err)\n{\n  mutt_debug(LL_DEBUG2, \" * mutt_lua_source()\\n\");\n\n  lua_init(&LuaState);\n\n  if (parse_extract_token(buf, s, TOKEN_NO_FLAGS) != 0)\n  {\n    buf_printf(err, _(\"source: error at %s\"), s->dptr);\n    return MUTT_CMD_ERROR;\n  }\n  if (MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too many arguments\"), \"source\");\n    return MUTT_CMD_WARNING;\n  }\n\n  struct Buffer *path = buf_pool_get();\n  buf_copy(path, buf);\n  buf_expand_path(path);\n\n  if (luaL_dofile(LuaState, buf_string(path)))\n  {\n    mutt_error(_(\"Couldn't source lua source: %s\"), lua_tostring(LuaState, -1));\n    lua_pop(LuaState, 1);\n    buf_pool_release(&path);\n    return MUTT_CMD_ERROR;\n  }\n\n  buf_pool_release(&path);\n  return MUTT_CMD_SUCCESS;\n}\n"
        },
        {
          "name": "mutt_lua.h",
          "type": "blob",
          "size": 1.150390625,
          "content": "/**\n * @file\n * Integrated Lua scripting\n *\n * @authors\n * Copyright (C) 2017-2020 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_LUA_H\n#define MUTT_MUTT_LUA_H\n\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\n\nenum CommandResult mutt_lua_parse      (struct Buffer *tmp, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult mutt_lua_source_file(struct Buffer *tmp, struct Buffer *s, intptr_t data, struct Buffer *err);\n\nvoid mutt_lua_init(void);\n\n#endif /* MUTT_MUTT_LUA_H */\n"
        },
        {
          "name": "mutt_mailbox.c",
          "type": "blob",
          "size": 12.6279296875,
          "content": "/**\n * @file\n * Mailbox helper functions\n *\n * @authors\n * Copyright (C) 2019-2022 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2019-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2021 Austin Ray <austin@austinray.io>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_mailbox Mailbox helper functions\n *\n * Mailbox helper functions\n */\n\n#include \"config.h\"\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <utime.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n#include \"mutt_mailbox.h\"\n#include \"postpone/lib.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n\nstatic time_t MailboxTime = 0; ///< last time we started checking for mail\nstatic time_t MailboxStatsTime = 0; ///< last time we check performed mail_check_stats\nstatic short MailboxCount = 0;  ///< how many boxes with new mail\nstatic short MailboxNotify = 0; ///< # of unnotified new boxes\n\n/**\n * is_same_mailbox - Compare two Mailboxes to see if they're equal\n * @param m1  First mailbox\n * @param m2  Second mailbox\n * @param st1 stat() info for first mailbox\n * @param st2 stat() info for second mailbox\n * @retval true  Mailboxes are the same\n * @retval false Mailboxes are different\n */\nstatic bool is_same_mailbox(struct Mailbox *m1, struct Mailbox *m2,\n                            struct stat *st1, struct stat *st2)\n{\n  if (!m1 || buf_is_empty(&m1->pathbuf) || !m2 || buf_is_empty(&m2->pathbuf) ||\n      (m1->type != m2->type))\n  {\n    return false;\n  }\n\n  const bool uses_protocol = (m2->type == MUTT_IMAP) || (m2->type == MUTT_NNTP) ||\n                             (m2->type == MUTT_NOTMUCH) || (m2->type == MUTT_POP);\n\n  if (uses_protocol)\n    return mutt_str_equal(mailbox_path(m1), mailbox_path(m2));\n  else\n    return ((st1->st_dev == st2->st_dev) && (st1->st_ino == st2->st_ino));\n}\n\n/**\n * mailbox_check - Check a mailbox for new mail\n * @param m_cur   Current Mailbox\n * @param m_check Mailbox to check\n * @param st_cur  stat() info for the current Mailbox\n * @param flags   Flags, e.g. #MUTT_MAILBOX_CHECK_POSTPONED\n */\nstatic void mailbox_check(struct Mailbox *m_cur, struct Mailbox *m_check,\n                          struct stat *st_cur, CheckStatsFlags flags)\n{\n  struct stat st = { 0 };\n\n  enum MailboxType mb_type = mx_path_probe(mailbox_path(m_check));\n\n  const bool c_mail_check_recent = cs_subset_bool(NeoMutt->sub, \"mail_check_recent\");\n  if ((m_cur == m_check) && c_mail_check_recent)\n    m_check->has_new = false;\n\n  switch (mb_type)\n  {\n    case MUTT_POP:\n    case MUTT_NNTP:\n    case MUTT_NOTMUCH:\n    case MUTT_IMAP:\n      m_check->type = mb_type;\n      break;\n    default:\n      if ((stat(mailbox_path(m_check), &st) != 0) ||\n          ((m_check->type == MUTT_UNKNOWN) && S_ISREG(st.st_mode) && (st.st_size == 0)) ||\n          ((m_check->type == MUTT_UNKNOWN) &&\n           ((m_check->type = mx_path_probe(mailbox_path(m_check))) <= 0)))\n      {\n        /* if the mailbox still doesn't exist, set the newly created flag to be\n         * ready for when it does. */\n        m_check->newly_created = true;\n        m_check->type = MUTT_UNKNOWN;\n        m_check->size = 0;\n        return;\n      }\n      break; // kept for consistency.\n  }\n\n  const bool c_check_mbox_size = cs_subset_bool(NeoMutt->sub, \"check_mbox_size\");\n\n  /* check to see if the folder is the currently selected folder before polling */\n  if (!is_same_mailbox(m_cur, m_check, st_cur, &st))\n  {\n    switch (m_check->type)\n    {\n      case MUTT_NOTMUCH:\n        // Remove this when non-notmuch backends only check unread, flagged,\n        // and total counts per 'mbox_check_stats' docs.\n        if ((flags & MUTT_MAILBOX_CHECK_STATS) == 0)\n          break;\n        FALLTHROUGH;\n\n      case MUTT_IMAP:\n      case MUTT_MBOX:\n      case MUTT_MMDF:\n      case MUTT_MAILDIR:\n      case MUTT_MH:\n        mx_mbox_check_stats(m_check, flags);\n        break;\n      default:; /* do nothing */\n    }\n  }\n  else if (c_check_mbox_size && m_cur && buf_is_empty(&m_cur->pathbuf))\n  {\n    m_check->size = (off_t) st.st_size; /* update the size of current folder */\n  }\n\n  if (!m_check->has_new)\n  {\n    m_check->notified = false;\n  }\n  else\n  {\n    // pretend that we've already notified for the mailbox\n    if (!m_check->notify_user)\n      m_check->notified = true;\n    else if (!m_check->notified)\n      MailboxNotify++;\n  }\n}\n\n/**\n * mutt_mailbox_check - Check all all Mailboxes for new mail\n * @param m_cur Current Mailbox\n * @param flags Flags, e.g. #MUTT_MAILBOX_CHECK_STATS\n * @retval num Number of mailboxes with new mail\n *\n * Check all all Mailboxes for new mail and total/new/flagged messages\n */\nint mutt_mailbox_check(struct Mailbox *m_cur, CheckStatsFlags flags)\n{\n  if (TAILQ_EMPTY(&NeoMutt->accounts)) // fast return if there are no mailboxes\n    return 0;\n\n  if (flags & MUTT_MAILBOX_CHECK_POSTPONED)\n    mutt_update_num_postponed();\n\n  const short c_mail_check = cs_subset_number(NeoMutt->sub, \"mail_check\");\n  const bool c_mail_check_stats = cs_subset_bool(NeoMutt->sub, \"mail_check_stats\");\n  const short c_mail_check_stats_interval = cs_subset_number(NeoMutt->sub, \"mail_check_stats_interval\");\n\n  time_t t = mutt_date_now();\n  if ((flags == MUTT_MAILBOX_CHECK_NO_FLAGS) && ((t - MailboxTime) < c_mail_check))\n    return MailboxCount;\n\n  if ((flags & MUTT_MAILBOX_CHECK_STATS) ||\n      (c_mail_check_stats && ((t - MailboxStatsTime) >= c_mail_check_stats_interval)))\n  {\n    flags |= MUTT_MAILBOX_CHECK_STATS;\n    MailboxStatsTime = t;\n  }\n\n  MailboxTime = t;\n  MailboxCount = 0;\n  MailboxNotify = 0;\n\n  /* check device ID and serial number instead of comparing paths */\n  struct stat st_cur = { 0 };\n  if (!m_cur || (m_cur->type == MUTT_IMAP) || (m_cur->type == MUTT_POP) ||\n      (m_cur->type == MUTT_NNTP) || stat(mailbox_path(m_cur), &st_cur) != 0)\n  {\n    st_cur.st_dev = 0;\n    st_cur.st_ino = 0;\n  }\n\n  struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n  neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n  struct MailboxNode *np = NULL;\n  STAILQ_FOREACH(np, &ml, entries)\n  {\n    struct Mailbox *m = np->mailbox;\n\n    if (!m->visible || !m->poll_new_mail)\n      continue;\n\n    CheckStatsFlags m_flags = flags;\n    if (!m->first_check_stats_done && c_mail_check_stats)\n    {\n      m_flags |= MUTT_MAILBOX_CHECK_STATS;\n    }\n    mailbox_check(m_cur, m, &st_cur, m_flags);\n    if (m->has_new)\n      MailboxCount++;\n    m->first_check_stats_done = true;\n  }\n  neomutt_mailboxlist_clear(&ml);\n\n  return MailboxCount;\n}\n\n/**\n * mutt_mailbox_notify - Notify the user if there's new mail\n * @param m_cur Current Mailbox\n * @retval true There is new mail\n */\nbool mutt_mailbox_notify(struct Mailbox *m_cur)\n{\n  if ((mutt_mailbox_check(m_cur, MUTT_MAILBOX_CHECK_NO_FLAGS) > 0) && (MailboxNotify != 0))\n  {\n    return mutt_mailbox_list();\n  }\n  return false;\n}\n\n/**\n * mutt_mailbox_list - Show a message with the list of mailboxes with new mail\n * @retval true There is new mail\n */\nbool mutt_mailbox_list(void)\n{\n  int have_unnotified = MailboxNotify;\n\n  struct Buffer *path = buf_pool_get();\n  struct Buffer *mailboxlist = buf_pool_get();\n\n  buf_addstr(mailboxlist, _(\"New mail in \"));\n  struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n  neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n  struct MailboxNode *np = NULL;\n  bool any_new = false;\n  STAILQ_FOREACH(np, &ml, entries)\n  {\n    /* Is there new mail in this mailbox? */\n    if (!np->mailbox->has_new || (have_unnotified && np->mailbox->notified))\n      continue;\n\n    buf_strcpy(path, mailbox_path(np->mailbox));\n    buf_pretty_mailbox(path);\n\n    if (any_new)\n    {\n      buf_addstr(mailboxlist, \", \");\n    }\n\n    if (!np->mailbox->notified)\n    {\n      np->mailbox->notified = true;\n      MailboxNotify--;\n    }\n    buf_addstr(mailboxlist, buf_string(path));\n    any_new = true;\n  }\n  neomutt_mailboxlist_clear(&ml);\n\n  buf_pool_release(&path);\n\n  if (any_new)\n  {\n    mutt_message(\"%s\", buf_string(mailboxlist));\n    buf_pool_release(&mailboxlist);\n    return true;\n  }\n\n  /* there were no mailboxes needing to be notified, so clean up since\n    * MailboxNotify has somehow gotten out of sync */\n  MailboxNotify = 0;\n  buf_pool_release(&mailboxlist);\n  return false;\n}\n\n/**\n * mutt_mailbox_set_notified - Note when the user was last notified of new mail\n * @param m Mailbox\n */\nvoid mutt_mailbox_set_notified(struct Mailbox *m)\n{\n  if (!m)\n    return;\n\n  m->notified = true;\n  mutt_time_now(&m->last_visited);\n}\n\n/**\n * find_next_mailbox - Find the next mailbox with new or unread mail\n * @param s         Buffer containing name of current mailbox\n * @param find_new  Boolean controlling new or unread check\n * @retval ptr Mailbox\n *\n * Given a folder name, find the next incoming folder with new or unread mail.\n * The Mailbox will be returned and a pretty version of the path put into s.\n */\nstatic struct Mailbox *find_next_mailbox(struct Buffer *s, bool find_new)\n{\n  bool found = false;\n  for (int pass = 0; pass < 2; pass++)\n  {\n    struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n    neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n    struct MailboxNode *np = NULL;\n    STAILQ_FOREACH(np, &ml, entries)\n    {\n      buf_expand_path(&np->mailbox->pathbuf);\n      struct Mailbox *m_cur = np->mailbox;\n\n      if ((found || (pass > 0)) && (find_new ? m_cur->has_new : m_cur->msg_unread > 0))\n      {\n        buf_strcpy(s, mailbox_path(np->mailbox));\n        buf_pretty_mailbox(s);\n        struct Mailbox *m_result = np->mailbox;\n        neomutt_mailboxlist_clear(&ml);\n        return m_result;\n      }\n      if (mutt_str_equal(buf_string(s), mailbox_path(np->mailbox)))\n        found = true;\n    }\n    neomutt_mailboxlist_clear(&ml);\n  }\n\n  return NULL;\n}\n\n/**\n * mutt_mailbox_next - Incoming folders completion routine\n * @param m_cur Current Mailbox\n * @param s     Buffer containing name of current mailbox\n * @retval ptr Mailbox\n *\n * Given a folder name, find the next incoming folder with new mail.\n * The Mailbox will be returned and a pretty version of the path put into s.\n */\nstruct Mailbox *mutt_mailbox_next(struct Mailbox *m_cur, struct Buffer *s)\n{\n  buf_expand_path(s);\n\n  if (mutt_mailbox_check(m_cur, MUTT_MAILBOX_CHECK_NO_FLAGS) > 0)\n  {\n    struct Mailbox *m_res = find_next_mailbox(s, true);\n    if (m_res)\n      return m_res;\n\n    mutt_mailbox_check(m_cur, MUTT_MAILBOX_CHECK_POSTPONED);\n  }\n\n  buf_reset(s); // no folders with new mail\n  return NULL;\n}\n\n/**\n * mutt_mailbox_next_unread - Find next mailbox with unread mail\n * @param m_cur Current Mailbox\n * @param s     Buffer containing name of current mailbox\n * @retval ptr Mailbox\n *\n * Given a folder name, find the next mailbox with unread mail.\n * The Mailbox will be returned and a pretty version of the path put into s.\n */\nstruct Mailbox *mutt_mailbox_next_unread(struct Mailbox *m_cur, struct Buffer *s)\n{\n  buf_expand_path(s);\n\n  struct Mailbox *m_res = find_next_mailbox(s, false);\n  if (m_res)\n    return m_res;\n\n  buf_reset(s); // no folders with new mail\n  return NULL;\n}\n\n/**\n * mailbox_restore_timestamp - Restore the timestamp of a mailbox\n * @param path Path to the mailbox\n * @param st   Timestamp info from stat()\n *\n * Fix up the atime and mtime after mbox/mmdf mailbox was modified according to\n * stat() info taken before a modification.\n */\nvoid mailbox_restore_timestamp(const char *path, struct stat *st)\n{\n#ifdef HAVE_UTIMENSAT\n  struct timespec ts[2] = { { 0 }, { 0 } };\n#else\n  struct utimbuf ut = { 0 };\n#endif\n\n  const bool c_check_mbox_size = cs_subset_bool(NeoMutt->sub, \"check_mbox_size\");\n  if (c_check_mbox_size)\n  {\n    struct Mailbox *m = mailbox_find(path);\n    if (m && !m->has_new)\n      mailbox_update(m);\n  }\n  else\n  {\n    /* fix up the times so mailbox won't get confused */\n    if (st->st_mtime > st->st_atime)\n    {\n#ifdef HAVE_UTIMENSAT\n      ts[0].tv_sec = 0;\n      ts[0].tv_nsec = UTIME_OMIT;\n      ts[1].tv_sec = 0;\n      ts[1].tv_nsec = UTIME_NOW;\n      utimensat(AT_FDCWD, buf, ts, 0);\n#else\n      ut.actime = st->st_atime;\n      ut.modtime = mutt_date_now();\n      utime(path, &ut);\n#endif\n    }\n    else\n    {\n#ifdef HAVE_UTIMENSAT\n      ts[0].tv_sec = 0;\n      ts[0].tv_nsec = UTIME_NOW;\n      ts[1].tv_sec = 0;\n      ts[1].tv_nsec = UTIME_NOW;\n      utimensat(AT_FDCWD, buf, ts, 0);\n#else\n      utime(path, NULL);\n#endif\n    }\n  }\n}\n"
        },
        {
          "name": "mutt_mailbox.h",
          "type": "blob",
          "size": 1.4150390625,
          "content": "/**\n * @file\n * Mailbox helper functions\n *\n * @authors\n * Copyright (C) 2019-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2022 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_MAILBOX_H\n#define MUTT_MUTT_MAILBOX_H\n\n#include <stdbool.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct stat;\n\nint  mutt_mailbox_check       (struct Mailbox *m_cur, CheckStatsFlags flags);\nvoid mailbox_restore_timestamp(const char *path, struct stat *st);\nbool mutt_mailbox_list        (void);\nstruct Mailbox *mutt_mailbox_next(struct Mailbox *m_cur, struct Buffer *s);\nstruct Mailbox *mutt_mailbox_next_unread(struct Mailbox *m_cur, struct Buffer *s);\nbool mutt_mailbox_notify      (struct Mailbox *m_cur);\nvoid mutt_mailbox_set_notified(struct Mailbox *m);\n\n#endif /* MUTT_MUTT_MAILBOX_H */\n"
        },
        {
          "name": "mutt_signal.c",
          "type": "blob",
          "size": 3.482421875,
          "content": "/**\n * @file\n * Signal handling\n *\n * @authors\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_signal Signal handling\n *\n * Signal handling\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"attach/lib.h\"\n#include \"protos.h\"\n#if defined(USE_DEBUG_GRAPHVIZ) || defined(USE_DEBUG_BACKTRACE)\n#include \"debug/lib.h\"\n#endif\n\n/// Ncurses function isendwin() has been called\nstatic int IsEndwin = 0;\n\n/**\n * curses_signal_handler - Catch signals and relay the info to the main program - Implements ::sig_handler_t - @ingroup sig_handler_api\n * @param sig Signal number, e.g. SIGINT\n */\nstatic void curses_signal_handler(int sig)\n{\n  int save_errno = errno;\n  enum MuttCursorState old_cursor = MUTT_CURSOR_VISIBLE;\n\n  switch (sig)\n  {\n    case SIGTSTP: /* user requested a suspend */\n    {\n      const bool c_suspend = cs_subset_bool(NeoMutt->sub, \"suspend\");\n      if (!c_suspend)\n        break;\n      IsEndwin = isendwin();\n      old_cursor = mutt_curses_set_cursor(MUTT_CURSOR_VISIBLE);\n      if (!IsEndwin)\n        endwin();\n      kill(0, SIGSTOP);\n    }\n      FALLTHROUGH;\n\n    case SIGCONT:\n      if (!IsEndwin)\n        refresh();\n      mutt_curses_set_cursor(old_cursor);\n      /* We don't receive SIGWINCH when suspended; however, no harm is done by\n       * just assuming we received one, and triggering the 'resize' anyway. */\n      SigWinch = true;\n      break;\n\n    case SIGWINCH:\n      SigWinch = true;\n      break;\n\n    case SIGINT:\n      SigInt = true;\n      break;\n  }\n  errno = save_errno;\n}\n\n/**\n * curses_exit_handler - Notify the user and shutdown gracefully - Implements ::sig_handler_t - @ingroup sig_handler_api\n * @param sig Signal number, e.g. SIGTERM\n */\nstatic void curses_exit_handler(int sig)\n{\n  mutt_curses_set_cursor(MUTT_CURSOR_VISIBLE);\n  endwin(); /* just to be safe */\n  mutt_temp_attachments_cleanup();\n  mutt_sig_exit_handler(sig); /* DOES NOT RETURN */\n}\n\n/**\n * curses_segv_handler - Catch a segfault and print a backtrace - Implements ::sig_handler_t - @ingroup sig_handler_api\n * @param sig Signal number, e.g. SIGSEGV\n */\nstatic void curses_segv_handler(int sig)\n{\n  mutt_curses_set_cursor(MUTT_CURSOR_VISIBLE);\n  endwin(); /* just to be safe */\n#ifdef USE_DEBUG_BACKTRACE\n  show_backtrace();\n#endif\n#ifdef USE_DEBUG_GRAPHVIZ\n  dump_graphviz(\"segfault\", NULL);\n#endif\n\n  struct sigaction act = { 0 };\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = 0;\n  act.sa_handler = SIG_DFL;\n  sigaction(sig, &act, NULL);\n  // Re-raise the signal to give outside handlers a chance to deal with it\n  raise(sig);\n}\n\n/**\n * mutt_signal_init - Initialise the signal handling\n */\nvoid mutt_signal_init(void)\n{\n  mutt_sig_init(curses_signal_handler, curses_exit_handler, curses_segv_handler);\n}\n"
        },
        {
          "name": "mutt_socket.c",
          "type": "blob",
          "size": 2.7568359375,
          "content": "/**\n * @file\n * NeoMutt connections\n *\n * @authors\n * Copyright (C) 2000-2007 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2017-2022 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_socket NeoMutt connections\n *\n * NeoMutt connections\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <string.h>\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"mutt_socket.h\"\n#include \"hook.h\"\n#ifndef USE_SSL\n#include \"mutt/lib.h\"\n#endif\n\n/**\n * mutt_conn_new - Create a new Connection\n * @param cac Credentials to use\n * @retval ptr New Connection\n */\nstruct Connection *mutt_conn_new(const struct ConnAccount *cac)\n{\n  enum ConnectionType conn_type;\n\n  const char *const c_tunnel = cs_subset_string(NeoMutt->sub, \"tunnel\");\n  if (c_tunnel)\n    conn_type = MUTT_CONNECTION_TUNNEL;\n  else if (cac->flags & MUTT_ACCT_SSL)\n    conn_type = MUTT_CONNECTION_SSL;\n  else\n    conn_type = MUTT_CONNECTION_SIMPLE;\n\n  struct Connection *conn = mutt_socket_new(conn_type);\n  if (conn)\n  {\n    memcpy(&conn->account, cac, sizeof(struct ConnAccount));\n  }\n  else\n  {\n    if (conn_type == MUTT_CONNECTION_SSL)\n    {\n#ifndef USE_SSL\n      /* that's probably why it failed */\n      mutt_error(_(\"SSL is unavailable, can't connect to %s\"), cac->host);\n#endif\n    }\n  }\n  return conn;\n}\n\n/**\n * mutt_conn_find - Find a connection from a list\n * @param cac   ConnAccount to match\n * @retval ptr Matching Connection\n *\n * find a connection off the list of connections whose account matches cac.\n * If start is not null, only search for connections after the given connection\n * (allows higher level socket code to make more fine-grained searches than\n * account info. Eg in IMAP we may wish to find a connection which is not in\n * IMAP_SELECTED state)\n */\nstruct Connection *mutt_conn_find(const struct ConnAccount *cac)\n{\n  struct Url url = { 0 };\n  char hook[1024] = { 0 };\n\n  /* cac isn't actually modified, since url isn't either */\n  account_to_url((struct ConnAccount *) cac, &url);\n  url.path = NULL;\n  url_tostring(&url, hook, sizeof(hook), U_NO_FLAGS);\n  mutt_account_hook(hook);\n\n  return mutt_conn_new(cac);\n}\n"
        },
        {
          "name": "mutt_socket.h",
          "type": "blob",
          "size": 1.0654296875,
          "content": "/**\n * @file\n * NeoMutt connections\n *\n * @authors\n * Copyright (C) 2000-2007 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018-2022 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_SOCKET_H\n#define MUTT_MUTT_SOCKET_H\n\nstruct ConnAccount;\n\nstruct Connection *mutt_conn_find(const struct ConnAccount *account);\nstruct Connection *mutt_conn_new (const struct ConnAccount *account);\n\n#endif /* MUTT_MUTT_SOCKET_H */\n"
        },
        {
          "name": "mutt_thread.c",
          "type": "blob",
          "size": 47.5361328125,
          "content": "/**\n * @file\n * Create/manipulate threading in emails\n *\n * @authors\n * Copyright (C) 2017 Peter Lewis <pete@muddygoat.org>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017-2023 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2019 Federico Kircheis <federico.kircheis@gmail.com>\n * Copyright (C) 2021 Eric Blake <eblake@redhat.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mutt_thread Create/manipulate threading in emails\n *\n * Create/manipulate threading in emails\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"mutt.h\"\n#include \"mutt_thread.h\"\n#include \"globals.h\"\n#include \"mview.h\"\n#include \"mx.h\"\n#include \"protos.h\"\n\n/**\n * UseThreadsMethods - Choices for '$use_threads' for the index\n */\nstatic const struct Mapping UseThreadsMethods[] = {\n  // clang-format off\n  { \"unset\",         UT_UNSET },\n  { \"flat\",          UT_FLAT },\n  { \"threads\",       UT_THREADS },\n  { \"reverse\",       UT_REVERSE },\n  // aliases\n  { \"no\",            UT_FLAT },\n  { \"yes\",           UT_THREADS },\n  { NULL, 0 },\n  // clang-format on\n};\n\n/// Data for the $use_threads enumeration\nconst struct EnumDef UseThreadsTypeDef = {\n  \"use_threads_type\",\n  4,\n  (struct Mapping *) &UseThreadsMethods,\n};\n\n/**\n * mutt_thread_style - Which threading style is active?\n * @retval #UT_FLAT    No threading in use\n * @retval #UT_THREADS Normal threads (root above subthread)\n * @retval #UT_REVERSE Reverse threads (subthread above root)\n *\n * @note UT_UNSET is never returned; rather, this function considers the\n *       interaction between $use_threads and $sort.\n */\nenum UseThreads mutt_thread_style(void)\n{\n  const unsigned char c_use_threads = cs_subset_enum(NeoMutt->sub, \"use_threads\");\n  const enum EmailSortType c_sort = cs_subset_sort(NeoMutt->sub, \"sort\");\n  if (c_use_threads > UT_FLAT)\n    return c_use_threads;\n  if ((c_sort & SORT_MASK) != EMAIL_SORT_THREADS)\n    return UT_FLAT;\n  if (c_sort & SORT_REVERSE)\n    return UT_REVERSE;\n  return UT_THREADS;\n}\n\n/**\n * get_use_threads_str - Convert UseThreads enum to string\n * @param value Value to convert\n * @retval ptr String form of value\n */\nconst char *get_use_threads_str(enum UseThreads value)\n{\n  return mutt_map_get_name(value, UseThreadsMethods);\n}\n\n/**\n * sort_validator - Validate the \"sort\" config variable - Implements ConfigDef::validator() - @ingroup cfg_def_validator\n */\nint sort_validator(const struct ConfigSet *cs, const struct ConfigDef *cdef,\n                   intptr_t value, struct Buffer *err)\n{\n  if (((value & SORT_MASK) == EMAIL_SORT_THREADS) && (value & SORT_LAST))\n  {\n    buf_printf(err, _(\"Cannot use 'last-' prefix with 'threads' for %s\"), cdef->name);\n    return CSR_ERR_INVALID;\n  }\n  return CSR_SUCCESS;\n}\n\n/**\n * is_visible - Is the message visible?\n * @param e   Email\n * @retval true The message is not hidden in some way\n */\nstatic bool is_visible(struct Email *e)\n{\n  return e->vnum >= 0 || (e->collapsed && e->visible);\n}\n\n/**\n * need_display_subject - Determines whether to display a message's subject\n * @param e Email\n * @retval true The subject should be displayed\n */\nstatic bool need_display_subject(struct Email *e)\n{\n  struct MuttThread *tmp = NULL;\n  struct MuttThread *tree = e->thread;\n\n  /* if the user disabled subject hiding, display it */\n  const bool c_hide_thread_subject = cs_subset_bool(NeoMutt->sub, \"hide_thread_subject\");\n  if (!c_hide_thread_subject)\n    return true;\n\n  /* if our subject is different from our parent's, display it */\n  if (e->subject_changed)\n    return true;\n\n  /* if our subject is different from that of our closest previously displayed\n   * sibling, display the subject */\n  for (tmp = tree->prev; tmp; tmp = tmp->prev)\n  {\n    e = tmp->message;\n    if (e && is_visible(e))\n    {\n      if (e->subject_changed)\n        return true;\n      break;\n    }\n  }\n\n  /* if there is a parent-to-child subject change anywhere between us and our\n   * closest displayed ancestor, display the subject */\n  for (tmp = tree->parent; tmp; tmp = tmp->parent)\n  {\n    e = tmp->message;\n    if (e)\n    {\n      if (is_visible(e))\n        return false;\n      if (e->subject_changed)\n        return true;\n    }\n  }\n\n  /* if we have no visible parent or previous sibling, display the subject */\n  return true;\n}\n\n/**\n * linearize_tree - Flatten an email thread\n * @param tctx Threading context\n */\nstatic void linearize_tree(struct ThreadsContext *tctx)\n{\n  if (!tctx || !tctx->mailbox_view)\n    return;\n\n  struct Mailbox *m = tctx->mailbox_view->mailbox;\n\n  const bool reverse = (mutt_thread_style() == UT_REVERSE);\n  struct MuttThread *tree = tctx->tree;\n  struct Email **array = m->emails + (reverse ? m->msg_count - 1 : 0);\n\n  while (tree)\n  {\n    while (!tree->message)\n      tree = tree->child;\n\n    *array = tree->message;\n    array += reverse ? -1 : 1;\n\n    if (tree->child)\n    {\n      tree = tree->child;\n    }\n    else\n    {\n      while (tree)\n      {\n        if (tree->next)\n        {\n          tree = tree->next;\n          break;\n        }\n        else\n        {\n          tree = tree->parent;\n        }\n      }\n    }\n  }\n}\n\n/**\n * calculate_visibility - Are tree nodes visible\n * @param tree      Threads tree\n * @param max_depth Maximum depth to check\n *\n * this calculates whether a node is the root of a subtree that has visible\n * nodes, whether a node itself is visible, whether, if invisible, it has\n * depth anyway, and whether any of its later siblings are roots of visible\n * subtrees.  while it's at it, it frees the old thread display, so we can\n * skip parts of the tree in mutt_draw_tree() if we've decided here that we\n * don't care about them any more.\n */\nstatic void calculate_visibility(struct MuttThread *tree, int *max_depth)\n{\n  if (!tree)\n    return;\n\n  struct MuttThread *tmp = NULL;\n  struct MuttThread *orig_tree = tree;\n  const bool c_hide_top_missing = cs_subset_bool(NeoMutt->sub, \"hide_top_missing\");\n  const bool c_hide_missing = cs_subset_bool(NeoMutt->sub, \"hide_missing\");\n  int hide_top_missing = c_hide_top_missing && !c_hide_missing;\n  const bool c_hide_top_limited = cs_subset_bool(NeoMutt->sub, \"hide_top_limited\");\n  const bool c_hide_limited = cs_subset_bool(NeoMutt->sub, \"hide_limited\");\n  int hide_top_limited = c_hide_top_limited && !c_hide_limited;\n  int depth = 0;\n\n  /* we walk each level backwards to make it easier to compute next_subtree_visible */\n  while (tree->next)\n    tree = tree->next;\n  *max_depth = 0;\n\n  while (true)\n  {\n    if (depth > *max_depth)\n      *max_depth = depth;\n\n    tree->subtree_visible = 0;\n    if (tree->message)\n    {\n      FREE(&tree->message->tree);\n      if (is_visible(tree->message))\n      {\n        tree->deep = true;\n        tree->visible = true;\n        tree->message->display_subject = need_display_subject(tree->message);\n        for (tmp = tree; tmp; tmp = tmp->parent)\n        {\n          if (tmp->subtree_visible)\n          {\n            tmp->deep = true;\n            tmp->subtree_visible = 2;\n            break;\n          }\n          else\n          {\n            tmp->subtree_visible = 1;\n          }\n        }\n      }\n      else\n      {\n        tree->visible = false;\n        tree->deep = !c_hide_limited;\n      }\n    }\n    else\n    {\n      tree->visible = false;\n      tree->deep = !c_hide_missing;\n    }\n    tree->next_subtree_visible = tree->next && (tree->next->next_subtree_visible ||\n                                                tree->next->subtree_visible);\n    if (tree->child)\n    {\n      depth++;\n      tree = tree->child;\n      while (tree->next)\n        tree = tree->next;\n    }\n    else if (tree->prev)\n    {\n      tree = tree->prev;\n    }\n    else\n    {\n      while (tree && !tree->prev)\n      {\n        depth--;\n        tree = tree->parent;\n      }\n      if (!tree)\n        break;\n      tree = tree->prev;\n    }\n  }\n\n  /* now fix up for the OPTHIDETOP* options if necessary */\n  if (hide_top_limited || hide_top_missing)\n  {\n    tree = orig_tree;\n    while (true)\n    {\n      if (!tree->visible && tree->deep && (tree->subtree_visible < 2) &&\n          ((tree->message && hide_top_limited) || (!tree->message && hide_top_missing)))\n      {\n        tree->deep = false;\n      }\n      if (!tree->deep && tree->child && tree->subtree_visible)\n      {\n        tree = tree->child;\n      }\n      else if (tree->next)\n      {\n        tree = tree->next;\n      }\n      else\n      {\n        while (tree && !tree->next)\n          tree = tree->parent;\n        if (!tree)\n          break;\n        tree = tree->next;\n      }\n    }\n  }\n}\n\n/**\n * mutt_thread_ctx_init - Initialize a threading context\n * @param mv Mailbox view\n * @retval ptr Threading context\n */\nstruct ThreadsContext *mutt_thread_ctx_init(struct MailboxView *mv)\n{\n  struct ThreadsContext *tctx = MUTT_MEM_CALLOC(1, struct ThreadsContext);\n  tctx->mailbox_view = mv;\n  return tctx;\n}\n\n/**\n * mutt_thread_ctx_free - Finalize a threading context\n * @param ptr Threading context to free\n */\nvoid mutt_thread_ctx_free(struct ThreadsContext **ptr)\n{\n  if (!ptr || !*ptr)\n  {\n    return;\n  }\n\n  struct ThreadsContext *tctx = *ptr;\n\n  mutt_hash_free(&tctx->hash);\n\n  FREE(ptr);\n}\n\n/**\n * mutt_draw_tree - Draw a tree of threaded emails\n * @param tctx Threading context\n *\n * Since the graphics characters have a value >255, I have to resort to using\n * escape sequences to pass the information to print_enriched_string().  These\n * are the macros MUTT_TREE_* defined in mutt.h.\n *\n * ncurses should automatically use the default ASCII characters instead of\n * graphics chars on terminals which don't support them (see the man page for\n * curs_addch).\n */\nvoid mutt_draw_tree(struct ThreadsContext *tctx)\n{\n  char *pfx = NULL, *mypfx = NULL, *arrow = NULL, *myarrow = NULL, *new_tree = NULL;\n  const bool reverse = (mutt_thread_style() == UT_REVERSE);\n  enum TreeChar corner = reverse ? MUTT_TREE_ULCORNER : MUTT_TREE_LLCORNER;\n  enum TreeChar vtee = reverse ? MUTT_TREE_BTEE : MUTT_TREE_TTEE;\n  const bool c_narrow_tree = cs_subset_bool(NeoMutt->sub, \"narrow_tree\");\n  int depth = 0, start_depth = 0, max_depth = 0, width = c_narrow_tree ? 1 : 2;\n  struct MuttThread *nextdisp = NULL, *pseudo = NULL, *parent = NULL;\n\n  struct MuttThread *tree = tctx->tree;\n\n  /* Do the visibility calculations and free the old thread chars.\n   * From now on we can simply ignore invisible subtrees */\n  calculate_visibility(tree, &max_depth);\n  pfx = MUTT_MEM_MALLOC((width * max_depth) + 2, char);\n  arrow = MUTT_MEM_MALLOC((width * max_depth) + 2, char);\n  const bool c_hide_limited = cs_subset_bool(NeoMutt->sub, \"hide_limited\");\n  const bool c_hide_missing = cs_subset_bool(NeoMutt->sub, \"hide_missing\");\n  while (tree)\n  {\n    if (depth != 0)\n    {\n      myarrow = arrow + (depth - start_depth - ((start_depth != 0) ? 0 : 1)) * width;\n      if (start_depth == depth)\n        myarrow[0] = nextdisp ? MUTT_TREE_LTEE : corner;\n      else if (parent->message && !c_hide_limited)\n        myarrow[0] = MUTT_TREE_HIDDEN;\n      else if (!parent->message && !c_hide_missing)\n        myarrow[0] = MUTT_TREE_MISSING;\n      else\n        myarrow[0] = vtee;\n      if (width == 2)\n      {\n        myarrow[1] = pseudo ? MUTT_TREE_STAR :\n                              (tree->duplicate_thread ? MUTT_TREE_EQUALS : MUTT_TREE_HLINE);\n      }\n      if (tree->visible)\n      {\n        myarrow[width] = MUTT_TREE_RARROW;\n        myarrow[width + 1] = 0;\n        new_tree = MUTT_MEM_MALLOC(((size_t) depth * width) + 2, char);\n        if (start_depth > 1)\n        {\n          strncpy(new_tree, pfx, (size_t) width * (start_depth - 1));\n          mutt_str_copy(new_tree + (start_depth - 1) * width, arrow,\n                        (1 + depth - start_depth) * width + 2);\n        }\n        else\n        {\n          mutt_str_copy(new_tree, arrow, ((size_t) depth * width) + 2);\n        }\n        tree->message->tree = new_tree;\n      }\n    }\n    if (tree->child && (depth != 0))\n    {\n      mypfx = pfx + (depth - 1) * width;\n      mypfx[0] = nextdisp ? MUTT_TREE_VLINE : MUTT_TREE_SPACE;\n      if (width == 2)\n        mypfx[1] = MUTT_TREE_SPACE;\n    }\n    parent = tree;\n    nextdisp = NULL;\n    pseudo = NULL;\n    do\n    {\n      if (tree->child && tree->subtree_visible)\n      {\n        if (tree->deep)\n          depth++;\n        if (tree->visible)\n          start_depth = depth;\n        tree = tree->child;\n\n        /* we do this here because we need to make sure that the first child thread\n         * of the old tree that we deal with is actually displayed if any are,\n         * or we might set the parent variable wrong while going through it. */\n        while (!tree->subtree_visible && tree->next)\n          tree = tree->next;\n      }\n      else\n      {\n        while (!tree->next && tree->parent)\n        {\n          if (tree == pseudo)\n            pseudo = NULL;\n          if (tree == nextdisp)\n            nextdisp = NULL;\n          if (tree->visible)\n            start_depth = depth;\n          tree = tree->parent;\n          if (tree->deep)\n          {\n            if (start_depth == depth)\n              start_depth--;\n            depth--;\n          }\n        }\n        if (tree == pseudo)\n          pseudo = NULL;\n        if (tree == nextdisp)\n          nextdisp = NULL;\n        if (tree->visible)\n          start_depth = depth;\n        tree = tree->next;\n        if (!tree)\n          break;\n      }\n      if (!pseudo && tree->fake_thread)\n        pseudo = tree;\n      if (!nextdisp && tree->next_subtree_visible)\n        nextdisp = tree;\n    } while (!tree->deep);\n  }\n\n  FREE(&pfx);\n  FREE(&arrow);\n}\n\n/**\n * make_subject_list - Create a sorted list of all subjects in a thread\n * @param[out] subjects String List of subjects\n * @param[in]  cur      Email Thread\n * @param[out] dateptr  Earliest date found in thread\n *\n * Since we may be trying to attach as a pseudo-thread a MuttThread that has no\n * message, we have to make a list of all the subjects of its most immediate\n * existing descendants.\n */\nstatic void make_subject_list(struct ListHead *subjects, struct MuttThread *cur, time_t *dateptr)\n{\n  struct MuttThread *start = cur;\n  struct Envelope *env = NULL;\n  time_t thisdate;\n  int rc = 0;\n\n  const bool c_thread_received = cs_subset_bool(NeoMutt->sub, \"thread_received\");\n  const bool c_sort_re = cs_subset_bool(NeoMutt->sub, \"sort_re\");\n  while (true)\n  {\n    while (!cur->message)\n      cur = cur->child;\n\n    if (dateptr)\n    {\n      thisdate = c_thread_received ? cur->message->received : cur->message->date_sent;\n      if ((*dateptr == 0) || (thisdate < *dateptr))\n        *dateptr = thisdate;\n    }\n\n    env = cur->message->env;\n    if (env->real_subj && ((env->real_subj != env->subject) || !c_sort_re))\n    {\n      struct ListNode *np = NULL;\n      STAILQ_FOREACH(np, subjects, entries)\n      {\n        rc = mutt_str_cmp(env->real_subj, np->data);\n        if (rc >= 0)\n          break;\n      }\n      if (!np)\n        mutt_list_insert_head(subjects, env->real_subj);\n      else if (rc > 0)\n        mutt_list_insert_after(subjects, np, env->real_subj);\n    }\n\n    while (!cur->next && (cur != start))\n    {\n      cur = cur->parent;\n    }\n    if (cur == start)\n      break;\n    cur = cur->next;\n  }\n}\n\n/**\n * find_subject - Find the best possible match for a parent based on subject\n * @param m   Mailbox\n * @param cur Email to match\n * @retval ptr Best match for a parent\n *\n * If there are multiple matches, the one which was sent the latest, but before\n * the current message, is used.\n */\nstatic struct MuttThread *find_subject(struct Mailbox *m, struct MuttThread *cur)\n{\n  if (!m)\n    return NULL;\n\n  struct HashElem *he = NULL;\n  struct MuttThread *tmp = NULL, *last = NULL;\n  struct ListHead subjects = STAILQ_HEAD_INITIALIZER(subjects);\n  time_t date = 0;\n\n  make_subject_list(&subjects, cur, &date);\n\n  struct ListNode *np = NULL;\n  const bool c_thread_received = cs_subset_bool(NeoMutt->sub, \"thread_received\");\n  STAILQ_FOREACH(np, &subjects, entries)\n  {\n    for (he = mutt_hash_find_bucket(m->subj_hash, np->data); he; he = he->next)\n    {\n      tmp = ((struct Email *) he->data)->thread;\n      if ((tmp != cur) &&                  /* don't match the same message */\n          !tmp->fake_thread &&             /* don't match pseudo threads */\n          tmp->message->subject_changed && /* only match interesting replies */\n          !is_descendant(tmp, cur) &&      /* don't match in the same thread */\n          (date >= (c_thread_received ? tmp->message->received : tmp->message->date_sent)) &&\n          (!last || (c_thread_received ?\n                         (last->message->received < tmp->message->received) :\n                         (last->message->date_sent < tmp->message->date_sent))) &&\n          tmp->message->env->real_subj &&\n          mutt_str_equal(np->data, tmp->message->env->real_subj))\n      {\n        last = tmp; /* best match so far */\n      }\n    }\n  }\n\n  mutt_list_clear(&subjects);\n  return last;\n}\n\n/**\n * make_subj_hash - Create a Hash Table for the email subjects\n * @param m Mailbox\n * @retval ptr Newly allocated Hash Table\n */\nstatic struct HashTable *make_subj_hash(struct Mailbox *m)\n{\n  if (!m)\n    return NULL;\n\n  struct HashTable *hash = mutt_hash_new(m->msg_count * 2, MUTT_HASH_ALLOW_DUPS);\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e || !e->env)\n      continue;\n    if (e->env->real_subj)\n      mutt_hash_insert(hash, e->env->real_subj, e);\n  }\n\n  return hash;\n}\n\n/**\n * pseudo_threads - Thread messages by subject\n * @param tctx Threading context\n *\n * Thread by subject things that didn't get threaded by message-id\n */\nstatic void pseudo_threads(struct ThreadsContext *tctx)\n{\n  if (!tctx || !tctx->mailbox_view)\n    return;\n\n  struct Mailbox *m = tctx->mailbox_view->mailbox;\n\n  struct MuttThread *tree = tctx->tree;\n  struct MuttThread *top = tree;\n  struct MuttThread *tmp = NULL, *cur = NULL, *parent = NULL, *curchild = NULL,\n                    *nextchild = NULL;\n\n  if (!m->subj_hash)\n    m->subj_hash = make_subj_hash(m);\n\n  while (tree)\n  {\n    cur = tree;\n    tree = tree->next;\n    parent = find_subject(m, cur);\n    if (parent)\n    {\n      cur->fake_thread = true;\n      unlink_message(&top, cur);\n      insert_message(&parent->child, parent, cur);\n      parent->sort_children = true;\n      tmp = cur;\n      while (true)\n      {\n        while (!tmp->message)\n          tmp = tmp->child;\n\n        /* if the message we're attaching has pseudo-children, they\n         * need to be attached to its parent, so move them up a level.\n         * but only do this if they have the same real subject as the\n         * parent, since otherwise they rightly belong to the message\n         * we're attaching. */\n        if ((tmp == cur) || mutt_str_equal(tmp->message->env->real_subj,\n                                           parent->message->env->real_subj))\n        {\n          tmp->message->subject_changed = false;\n\n          for (curchild = tmp->child; curchild;)\n          {\n            nextchild = curchild->next;\n            if (curchild->fake_thread)\n            {\n              unlink_message(&tmp->child, curchild);\n              insert_message(&parent->child, parent, curchild);\n            }\n            curchild = nextchild;\n          }\n        }\n\n        while (!tmp->next && (tmp != cur))\n        {\n          tmp = tmp->parent;\n        }\n        if (tmp == cur)\n          break;\n        tmp = tmp->next;\n      }\n    }\n  }\n  tctx->tree = top;\n}\n\n/**\n * mutt_clear_threads - Clear the threading of message in a mailbox\n * @param tctx Threading context\n */\nvoid mutt_clear_threads(struct ThreadsContext *tctx)\n{\n  if (!tctx || !tctx->tree)\n    return;\n\n  struct MailboxView *mv = tctx->mailbox_view;\n  if (!mv)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n  if (!m || !m->emails)\n    return;\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    /* mailbox may have been only partially read */\n    e->thread = NULL;\n    e->threaded = false;\n  }\n  tctx->tree = NULL;\n  mutt_hash_free(&tctx->hash);\n}\n\n/**\n * compare_threads - Helper to sort email threads - Implements ::sort_t - @ingroup sort_api\n */\nstatic int compare_threads(const void *a, const void *b, void *sdata)\n{\n  const struct MuttThread *ta = *(struct MuttThread const *const *) a;\n  const struct MuttThread *tb = *(struct MuttThread const *const *) b;\n  const struct ThreadsContext *tctx = sdata;\n  ASSERT(ta->parent == tb->parent);\n\n  /* If c_sort ties, remember we are building the thread array in\n   * reverse from the index the mails had in the mailbox.  */\n  struct Mailbox *m = tctx->mailbox_view->mailbox;\n  const enum MailboxType mtype = mx_type(m);\n  if (ta->parent)\n  {\n    return mutt_compare_emails(ta->sort_aux_key, tb->sort_aux_key, mtype,\n                               tctx->c_sort_aux, SORT_REVERSE | EMAIL_SORT_UNSORTED);\n  }\n  else\n  {\n    return mutt_compare_emails(ta->sort_thread_key, tb->sort_thread_key, mtype,\n                               tctx->c_sort, SORT_REVERSE | EMAIL_SORT_UNSORTED);\n  }\n}\n\n/**\n * mutt_sort_subthreads - Sort the children of a thread\n * @param tctx Threading context\n * @param init If true, rebuild the thread\n */\nstatic void mutt_sort_subthreads(struct ThreadsContext *tctx, bool init)\n{\n  struct MuttThread *thread = tctx->tree;\n  if (!thread)\n    return;\n\n  struct MuttThread **array = NULL, *top = NULL, *tmp = NULL;\n  struct Email *sort_aux_key = NULL, *oldsort_aux_key = NULL;\n  struct Email *oldsort_thread_key = NULL;\n  int i, array_size;\n  bool sort_top = false;\n\n  /* we put things into the array backwards to save some cycles,\n   * but we want to have to move less stuff around if we're\n   * resorting, so we sort backwards and then put them back\n   * in reverse order so they're forwards */\n  const bool reverse = (mutt_thread_style() == UT_REVERSE);\n  enum EmailSortType c_sort = cs_subset_sort(NeoMutt->sub, \"sort\");\n  enum EmailSortType c_sort_aux = cs_subset_sort(NeoMutt->sub, \"sort_aux\");\n  if ((c_sort & SORT_MASK) == EMAIL_SORT_THREADS)\n  {\n    ASSERT(!(c_sort & SORT_REVERSE) != reverse);\n    c_sort = c_sort_aux;\n  }\n  c_sort ^= SORT_REVERSE;\n  c_sort_aux ^= SORT_REVERSE;\n  if (init || (tctx->c_sort != c_sort) || (tctx->c_sort_aux != c_sort_aux))\n  {\n    tctx->c_sort = c_sort;\n    tctx->c_sort_aux = c_sort_aux;\n    init = true;\n  }\n\n  top = thread;\n\n  array_size = 256;\n  array = MUTT_MEM_CALLOC(array_size, struct MuttThread *);\n  while (true)\n  {\n    if (init || !thread->sort_thread_key || !thread->sort_aux_key)\n    {\n      thread->sort_thread_key = NULL;\n      thread->sort_aux_key = NULL;\n\n      if (thread->parent)\n        thread->parent->sort_children = true;\n      else\n        sort_top = true;\n    }\n\n    if (thread->child)\n    {\n      thread = thread->child;\n      continue;\n    }\n    else\n    {\n      /* if it has no children, it must be real. sort it on its own merits */\n      thread->sort_thread_key = thread->message;\n      thread->sort_aux_key = thread->message;\n\n      if (thread->next)\n      {\n        thread = thread->next;\n        continue;\n      }\n    }\n\n    struct Mailbox *m = tctx->mailbox_view->mailbox;\n    const enum MailboxType mtype = mx_type(m);\n    while (!thread->next)\n    {\n      /* if it has siblings and needs to be sorted, sort it... */\n      if (thread->prev && (thread->parent ? thread->parent->sort_children : sort_top))\n      {\n        /* put them into the array */\n        for (i = 0; thread; i++, thread = thread->prev)\n        {\n          if (i >= array_size)\n          {\n            array_size *= 2;\n            MUTT_MEM_REALLOC(&array, array_size, struct MuttThread *);\n          }\n\n          array[i] = thread;\n        }\n\n        mutt_qsort_r((void *) array, i, sizeof(struct MuttThread *), compare_threads, tctx);\n\n        /* attach them back together.  make thread the last sibling. */\n        thread = array[0];\n        thread->next = NULL;\n        array[i - 1]->prev = NULL;\n\n        if (thread->parent)\n          thread->parent->child = array[i - 1];\n        else\n          top = array[i - 1];\n\n        while (--i)\n        {\n          array[i - 1]->prev = array[i];\n          array[i]->next = array[i - 1];\n        }\n      }\n\n      if (thread->parent)\n      {\n        tmp = thread;\n        thread = thread->parent;\n\n        if (!thread->sort_thread_key || !thread->sort_aux_key || thread->sort_children)\n        {\n          /* we just sorted its children */\n          thread->sort_children = false;\n\n          oldsort_aux_key = thread->sort_aux_key;\n          oldsort_thread_key = thread->sort_thread_key;\n\n          /* update sort keys. sort_aux_key will be the first or last\n           * sibling, as appropriate... */\n          thread->sort_aux_key = thread->message;\n          sort_aux_key = ((!(c_sort_aux & SORT_LAST)) ^ (!(c_sort_aux & SORT_REVERSE))) ?\n                             thread->child->sort_aux_key :\n                             tmp->sort_aux_key;\n\n          if (c_sort_aux & SORT_LAST)\n          {\n            if (!thread->sort_aux_key ||\n                (mutt_compare_emails(thread->sort_aux_key, sort_aux_key, mtype,\n                                     c_sort_aux | SORT_REVERSE, EMAIL_SORT_UNSORTED) > 0))\n            {\n              thread->sort_aux_key = sort_aux_key;\n            }\n          }\n          else if (!thread->sort_aux_key)\n          {\n            thread->sort_aux_key = sort_aux_key;\n          }\n\n          /* ...but sort_thread_key may require searching the entire\n           * list of siblings */\n          if ((c_sort_aux & ~SORT_REVERSE) == (c_sort & ~SORT_REVERSE))\n          {\n            thread->sort_thread_key = thread->sort_aux_key;\n          }\n          else\n          {\n            if (thread->message)\n            {\n              thread->sort_thread_key = thread->message;\n            }\n            else if (reverse != (!(c_sort_aux & SORT_REVERSE)))\n            {\n              thread->sort_thread_key = tmp->sort_thread_key;\n            }\n            else\n            {\n              thread->sort_thread_key = thread->child->sort_thread_key;\n            }\n            if (c_sort & SORT_LAST)\n            {\n              for (tmp = thread->child; tmp; tmp = tmp->next)\n              {\n                if (tmp->sort_thread_key == thread->sort_thread_key)\n                  continue;\n                if ((mutt_compare_emails(thread->sort_thread_key, tmp->sort_thread_key, mtype,\n                                         c_sort | SORT_REVERSE, EMAIL_SORT_UNSORTED) > 0))\n                {\n                  thread->sort_thread_key = tmp->sort_thread_key;\n                }\n              }\n            }\n          }\n\n          /* if a sort_key has changed, we need to resort it and siblings */\n          if ((oldsort_aux_key != thread->sort_aux_key) ||\n              (oldsort_thread_key != thread->sort_thread_key))\n          {\n            if (thread->parent)\n              thread->parent->sort_children = true;\n            else\n              sort_top = true;\n          }\n        }\n      }\n      else\n      {\n        FREE(&array);\n        tctx->tree = top;\n        return;\n      }\n    }\n\n    thread = thread->next;\n  }\n}\n\n/**\n * check_subjects - Find out which emails' subjects differ from their parent's\n * @param mv   Mailbox View\n * @param init If true, rebuild the thread\n */\nstatic void check_subjects(struct MailboxView *mv, bool init)\n{\n  if (!mv)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e || !e->thread)\n      continue;\n\n    if (e->thread->check_subject)\n      e->thread->check_subject = false;\n    else if (!init)\n      continue;\n\n    /* figure out which messages have subjects different than their parents' */\n    struct MuttThread *tmp = e->thread->parent;\n    while (tmp && !tmp->message)\n    {\n      tmp = tmp->parent;\n    }\n\n    if (!tmp)\n    {\n      e->subject_changed = true;\n    }\n    else if (e->env->real_subj && tmp->message->env->real_subj)\n    {\n      e->subject_changed = !mutt_str_equal(e->env->real_subj, tmp->message->env->real_subj);\n    }\n    else\n    {\n      e->subject_changed = (e->env->real_subj || tmp->message->env->real_subj);\n    }\n  }\n}\n\n/**\n * thread_hash_destructor - Free our hash table data - Implements ::hash_hdata_free_t - @ingroup hash_hdata_free_api\n */\nstatic void thread_hash_destructor(int type, void *obj, intptr_t data)\n{\n  FREE(&obj);\n}\n\n/**\n * mutt_sort_threads - Sort email threads\n * @param tctx Threading context\n * @param init If true, rebuild the thread\n */\nvoid mutt_sort_threads(struct ThreadsContext *tctx, bool init)\n{\n  if (!tctx || !tctx->mailbox_view)\n    return;\n\n  struct MailboxView *mv = tctx->mailbox_view;\n  struct Mailbox *m = mv->mailbox;\n\n  struct Email *e = NULL;\n  int i, using_refs = 0;\n  struct MuttThread *thread = NULL, *tnew = NULL, *tmp = NULL;\n  struct MuttThread top = { 0 };\n  struct ListNode *ref = NULL;\n\n  ASSERT(m->msg_count > 0);\n  if (!tctx->hash)\n    init = true;\n\n  if (init)\n  {\n    tctx->hash = mutt_hash_new(m->msg_count * 2, MUTT_HASH_ALLOW_DUPS);\n    mutt_hash_set_destructor(tctx->hash, thread_hash_destructor, 0);\n  }\n\n  /* we want a quick way to see if things are actually attached to the top of the\n   * thread tree or if they're just dangling, so we attach everything to a top\n   * node temporarily */\n  top.parent = NULL;\n  top.next = NULL;\n  top.prev = NULL;\n\n  top.child = tctx->tree;\n  for (thread = tctx->tree; thread; thread = thread->next)\n    thread->parent = &top;\n\n  /* put each new message together with the matching messageless MuttThread if it\n   * exists.  otherwise, if there is a MuttThread that already has a message, thread\n   * new message as an identical child.  if we didn't attach the message to a\n   * MuttThread, make a new one for it. */\n  const bool c_duplicate_threads = cs_subset_bool(NeoMutt->sub, \"duplicate_threads\");\n  for (i = 0; i < m->msg_count; i++)\n  {\n    e = m->emails[i];\n    if (!e)\n      continue;\n\n    if (e->thread)\n    {\n      /* unlink pseudo-threads because they might be children of newly\n       * arrived messages */\n      thread = e->thread;\n      for (tnew = thread->child; tnew;)\n      {\n        tmp = tnew->next;\n        if (tnew->fake_thread)\n        {\n          unlink_message(&thread->child, tnew);\n          insert_message(&top.child, &top, tnew);\n          tnew->fake_thread = false;\n        }\n        tnew = tmp;\n      }\n    }\n    else\n    {\n      if ((!init || c_duplicate_threads) && e->env->message_id)\n        thread = mutt_hash_find(tctx->hash, e->env->message_id);\n      else\n        thread = NULL;\n\n      if (thread && !thread->message)\n      {\n        /* this is a message which was missing before */\n        thread->message = e;\n        e->thread = thread;\n        thread->check_subject = true;\n\n        /* mark descendants as needing subject_changed checked */\n        for (tmp = (thread->child ? thread->child : thread); tmp != thread;)\n        {\n          while (!tmp->message)\n            tmp = tmp->child;\n          tmp->check_subject = true;\n          while (!tmp->next && (tmp != thread))\n            tmp = tmp->parent;\n          if (tmp != thread)\n            tmp = tmp->next;\n        }\n\n        if (thread->parent)\n        {\n          /* remove threading info above it based on its children, which we'll\n           * recalculate based on its headers.  make sure not to leave\n           * dangling missing messages.  note that we haven't kept track\n           * of what info came from its children and what from its siblings'\n           * children, so we just remove the stuff that's definitely from it */\n          do\n          {\n            tmp = thread->parent;\n            unlink_message(&tmp->child, thread);\n            thread->parent = NULL;\n            thread->sort_thread_key = NULL;\n            thread->sort_aux_key = NULL;\n            thread->fake_thread = false;\n            thread = tmp;\n          } while (thread != &top && !thread->child && !thread->message);\n        }\n      }\n      else\n      {\n        tnew = (c_duplicate_threads ? thread : NULL);\n\n        thread = MUTT_MEM_CALLOC(1, struct MuttThread);\n        thread->message = e;\n        thread->check_subject = true;\n        e->thread = thread;\n        mutt_hash_insert(tctx->hash, e->env->message_id ? e->env->message_id : \"\", thread);\n\n        if (tnew)\n        {\n          if (tnew->duplicate_thread)\n            tnew = tnew->parent;\n\n          thread = e->thread;\n\n          insert_message(&tnew->child, tnew, thread);\n          thread->duplicate_thread = true;\n          thread->message->threaded = true;\n        }\n      }\n    }\n  }\n\n  /* thread by references */\n  for (i = 0; i < m->msg_count; i++)\n  {\n    e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->threaded)\n      continue;\n    e->threaded = true;\n\n    thread = e->thread;\n    if (!thread)\n      continue;\n    using_refs = 0;\n\n    while (true)\n    {\n      if (using_refs == 0)\n      {\n        /* look at the beginning of in-reply-to: */\n        ref = STAILQ_FIRST(&e->env->in_reply_to);\n        if (ref)\n        {\n          using_refs = 1;\n        }\n        else\n        {\n          ref = STAILQ_FIRST(&e->env->references);\n          using_refs = 2;\n        }\n      }\n      else if (using_refs == 1)\n      {\n        /* if there's no references header, use all the in-reply-to:\n         * data that we have.  otherwise, use the first reference\n         * if it's different than the first in-reply-to, otherwise use\n         * the second reference (since at least eudora puts the most\n         * recent reference in in-reply-to and the rest in references) */\n        if (STAILQ_EMPTY(&e->env->references))\n        {\n          ref = STAILQ_NEXT(ref, entries);\n        }\n        else\n        {\n          if (!mutt_str_equal(ref->data, STAILQ_FIRST(&e->env->references)->data))\n            ref = STAILQ_FIRST(&e->env->references);\n          else\n            ref = STAILQ_NEXT(STAILQ_FIRST(&e->env->references), entries);\n\n          using_refs = 2;\n        }\n      }\n      else\n      {\n        ref = STAILQ_NEXT(ref, entries); /* go on with references */\n      }\n\n      if (!ref)\n        break;\n\n      tnew = mutt_hash_find(tctx->hash, ref->data);\n      if (tnew)\n      {\n        if (tnew->duplicate_thread)\n          tnew = tnew->parent;\n        if (is_descendant(tnew, thread)) /* no loops! */\n          continue;\n      }\n      else\n      {\n        tnew = MUTT_MEM_CALLOC(1, struct MuttThread);\n        mutt_hash_insert(tctx->hash, ref->data, tnew);\n      }\n\n      if (thread->parent)\n        unlink_message(&top.child, thread);\n      insert_message(&tnew->child, tnew, thread);\n      thread = tnew;\n      if (thread->message || (thread->parent && (thread->parent != &top)))\n        break;\n    }\n\n    if (!thread->parent)\n      insert_message(&top.child, &top, thread);\n  }\n\n  /* detach everything from the temporary top node */\n  for (thread = top.child; thread; thread = thread->next)\n  {\n    thread->parent = NULL;\n  }\n  tctx->tree = top.child;\n\n  check_subjects(mv, init);\n\n  const bool c_strict_threads = cs_subset_bool(NeoMutt->sub, \"strict_threads\");\n  if (!c_strict_threads)\n    pseudo_threads(tctx);\n\n  /* if $sort_aux or similar changed after the mailbox is sorted, then\n   * all the subthreads need to be resorted */\n  if (tctx->tree)\n  {\n    mutt_sort_subthreads(tctx, init || OptSortSubthreads);\n    OptSortSubthreads = false;\n\n    /* Put the list into an array. */\n    linearize_tree(tctx);\n\n    /* Draw the thread tree. */\n    mutt_draw_tree(tctx);\n  }\n}\n\n/**\n * mutt_aside_thread - Find the next/previous (sub)thread\n * @param e          Search from this Email\n * @param forwards   Direction to search: 'true' forwards, 'false' backwards\n * @param subthreads Search subthreads: 'true' subthread, 'false' not\n * @retval num Index into the virtual email table\n * @retval  -1 Error\n */\nint mutt_aside_thread(struct Email *e, bool forwards, bool subthreads)\n{\n  if (!e)\n    return -1;\n\n  struct MuttThread *cur = NULL;\n  struct Email *e_tmp = NULL;\n\n  const enum UseThreads threaded = mutt_thread_style();\n  if (threaded == UT_FLAT)\n  {\n    mutt_error(_(\"Threading is not enabled\"));\n    return e->vnum;\n  }\n\n  cur = e->thread;\n\n  if (subthreads)\n  {\n    if (forwards ^ (threaded == UT_REVERSE))\n    {\n      while (!cur->next && cur->parent)\n        cur = cur->parent;\n    }\n    else\n    {\n      while (!cur->prev && cur->parent)\n        cur = cur->parent;\n    }\n  }\n  else\n  {\n    while (cur->parent)\n      cur = cur->parent;\n  }\n\n  if (forwards ^ (threaded == UT_REVERSE))\n  {\n    do\n    {\n      cur = cur->next;\n      if (!cur)\n        return -1;\n      e_tmp = find_virtual(cur, false);\n    } while (!e_tmp);\n  }\n  else\n  {\n    do\n    {\n      cur = cur->prev;\n      if (!cur)\n        return -1;\n      e_tmp = find_virtual(cur, true);\n    } while (!e_tmp);\n  }\n\n  return e_tmp->vnum;\n}\n\n/**\n * mutt_parent_message - Find the parent of a message\n * @param e         Current Email\n * @param find_root If true, find the root message\n * @retval >=0 Virtual index number of parent/root message\n * @retval -1 Error\n */\nint mutt_parent_message(struct Email *e, bool find_root)\n{\n  if (!e)\n    return -1;\n\n  struct MuttThread *thread = NULL;\n  struct Email *e_parent = NULL;\n\n  if (!mutt_using_threads())\n  {\n    mutt_error(_(\"Threading is not enabled\"));\n    return e->vnum;\n  }\n\n  /* Root may be the current message */\n  if (find_root)\n    e_parent = e;\n\n  for (thread = e->thread->parent; thread; thread = thread->parent)\n  {\n    e = thread->message;\n    if (e)\n    {\n      e_parent = e;\n      if (!find_root)\n        break;\n    }\n  }\n\n  if (!e_parent)\n  {\n    mutt_error(_(\"Parent message is not available\"));\n    return -1;\n  }\n  if (!is_visible(e_parent))\n  {\n    if (find_root)\n      mutt_error(_(\"Root message is not visible in this limited view\"));\n    else\n      mutt_error(_(\"Parent message is not visible in this limited view\"));\n    return -1;\n  }\n  return e_parent->vnum;\n}\n\n/**\n * mutt_set_vnum - Set the virtual index number of all the messages in a mailbox\n * @param m       Mailbox\n * @retval num Size in bytes of all messages shown\n */\noff_t mutt_set_vnum(struct Mailbox *m)\n{\n  if (!m)\n    return 0;\n\n  off_t vsize = 0;\n  const int padding = mx_msg_padding_size(m);\n\n  m->vcount = 0;\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->vnum >= 0)\n    {\n      e->vnum = m->vcount;\n      m->v2r[m->vcount] = i;\n      m->vcount++;\n      vsize += e->body->length + e->body->offset - e->body->hdr_offset + padding;\n    }\n  }\n\n  return vsize;\n}\n\n/**\n * mutt_traverse_thread - Recurse through an email thread, matching messages\n * @param e_cur Current Email\n * @param flag  Flag to set, see #MuttThreadFlags\n * @retval num Number of matches\n */\nint mutt_traverse_thread(struct Email *e_cur, MuttThreadFlags flag)\n{\n  struct MuttThread *thread = NULL, *top = NULL;\n  struct Email *e_root = NULL;\n  const enum UseThreads threaded = mutt_thread_style();\n  int final, reverse = (threaded == UT_REVERSE), minmsgno;\n  int num_hidden = 0, new_mail = 0, old_mail = 0;\n  bool flagged = false;\n  int min_unread_msgno = INT_MAX, min_unread = e_cur->vnum;\n\n  if (threaded == UT_FLAT)\n  {\n    mutt_error(_(\"Threading is not enabled\"));\n    return e_cur->vnum;\n  }\n\n  if (!e_cur->thread)\n  {\n    return e_cur->vnum;\n  }\n\n  final = e_cur->vnum;\n  thread = e_cur->thread;\n  while (thread->parent)\n    thread = thread->parent;\n  top = thread;\n  while (!thread->message)\n    thread = thread->child;\n  e_cur = thread->message;\n  minmsgno = e_cur->msgno;\n\n  if (!e_cur->read && e_cur->visible)\n  {\n    if (e_cur->old)\n      old_mail = 2;\n    else\n      new_mail = 1;\n    if (e_cur->msgno < min_unread_msgno)\n    {\n      min_unread = e_cur->vnum;\n      min_unread_msgno = e_cur->msgno;\n    }\n  }\n\n  if (e_cur->flagged && e_cur->visible)\n    flagged = true;\n\n  if ((e_cur->vnum == -1) && e_cur->visible)\n    num_hidden++;\n\n  if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))\n  {\n    e_cur->attr_color = NULL; /* force index entry's color to be re-evaluated */\n    e_cur->collapsed = flag & MUTT_THREAD_COLLAPSE;\n    if (e_cur->vnum != -1)\n    {\n      e_root = e_cur;\n      if (flag & MUTT_THREAD_COLLAPSE)\n        final = e_root->vnum;\n    }\n  }\n\n  if ((thread == top) && !(thread = thread->child))\n  {\n    /* return value depends on action requested */\n    if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))\n    {\n      e_cur->num_hidden = num_hidden;\n      return final;\n    }\n    if (flag & MUTT_THREAD_UNREAD)\n      return (old_mail && new_mail) ? new_mail : (old_mail ? old_mail : new_mail);\n    if (flag & MUTT_THREAD_NEXT_UNREAD)\n      return min_unread;\n    if (flag & MUTT_THREAD_FLAGGED)\n      return flagged;\n  }\n\n  while (true)\n  {\n    e_cur = thread->message;\n\n    if (e_cur)\n    {\n      if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))\n      {\n        e_cur->attr_color = NULL; /* force index entry's color to be re-evaluated */\n        e_cur->collapsed = flag & MUTT_THREAD_COLLAPSE;\n        if (!e_root && e_cur->visible)\n        {\n          e_root = e_cur;\n          if (flag & MUTT_THREAD_COLLAPSE)\n            final = e_root->vnum;\n        }\n\n        if (reverse && (flag & MUTT_THREAD_COLLAPSE) &&\n            (e_cur->msgno < minmsgno) && e_cur->visible)\n        {\n          minmsgno = e_cur->msgno;\n          final = e_cur->vnum;\n        }\n\n        if (flag & MUTT_THREAD_COLLAPSE)\n        {\n          if (e_cur != e_root)\n            e_cur->vnum = -1;\n        }\n        else\n        {\n          if (e_cur->visible)\n            e_cur->vnum = e_cur->msgno;\n        }\n      }\n\n      if (!e_cur->read && e_cur->visible)\n      {\n        if (e_cur->old)\n          old_mail = 2;\n        else\n          new_mail = 1;\n        if (e_cur->msgno < min_unread_msgno)\n        {\n          min_unread = e_cur->vnum;\n          min_unread_msgno = e_cur->msgno;\n        }\n      }\n\n      if (e_cur->flagged && e_cur->visible)\n        flagged = true;\n\n      if ((e_cur->vnum == -1) && e_cur->visible)\n        num_hidden++;\n    }\n\n    if (thread->child)\n    {\n      thread = thread->child;\n    }\n    else if (thread->next)\n    {\n      thread = thread->next;\n    }\n    else\n    {\n      bool done = false;\n      while (!thread->next)\n      {\n        thread = thread->parent;\n        if (thread == top)\n        {\n          done = true;\n          break;\n        }\n      }\n      if (done)\n        break;\n      thread = thread->next;\n    }\n  }\n\n  /* re-traverse the thread and store num_hidden in all headers, with or\n   * without a virtual index.  this will allow ~v to match all collapsed\n   * messages when switching sort order to non-threaded.  */\n  if (flag & MUTT_THREAD_COLLAPSE)\n  {\n    thread = top;\n    while (true)\n    {\n      e_cur = thread->message;\n      if (e_cur)\n        e_cur->num_hidden = num_hidden + 1;\n\n      if (thread->child)\n      {\n        thread = thread->child;\n      }\n      else if (thread->next)\n      {\n        thread = thread->next;\n      }\n      else\n      {\n        bool done = false;\n        while (!thread->next)\n        {\n          thread = thread->parent;\n          if (thread == top)\n          {\n            done = true;\n            break;\n          }\n        }\n        if (done)\n          break;\n        thread = thread->next;\n      }\n    }\n  }\n\n  /* return value depends on action requested */\n  if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))\n    return final;\n  if (flag & MUTT_THREAD_UNREAD)\n    return (old_mail && new_mail) ? new_mail : (old_mail ? old_mail : new_mail);\n  if (flag & MUTT_THREAD_NEXT_UNREAD)\n    return min_unread;\n  if (flag & MUTT_THREAD_FLAGGED)\n    return flagged;\n\n  return 0;\n}\n\n/**\n * mutt_messages_in_thread - Count the messages in a thread\n * @param m    Mailbox\n * @param e    Email\n * @param mit  Flag, e.g. #MIT_NUM_MESSAGES\n * @retval num Number of message / Our position\n */\nint mutt_messages_in_thread(struct Mailbox *m, struct Email *e, enum MessageInThread mit)\n{\n  if (!m || !e)\n    return 1;\n\n  struct MuttThread *threads[2];\n  int rc;\n\n  const enum UseThreads threaded = mutt_thread_style();\n  if ((threaded == UT_FLAT) || !e->thread)\n    return 1;\n\n  threads[0] = e->thread;\n  while (threads[0]->parent)\n    threads[0] = threads[0]->parent;\n\n  threads[1] = (mit == MIT_POSITION) ? e->thread : threads[0]->next;\n\n  for (int i = 0; i < (((mit == MIT_POSITION) || !threads[1]) ? 1 : 2); i++)\n  {\n    while (!threads[i]->message)\n      threads[i] = threads[i]->child;\n  }\n\n  if (threaded == UT_REVERSE)\n  {\n    rc = threads[0]->message->msgno - (threads[1] ? threads[1]->message->msgno : -1);\n  }\n  else\n  {\n    rc = (threads[1] ? threads[1]->message->msgno : m->msg_count) -\n         threads[0]->message->msgno;\n  }\n\n  if (mit == MIT_POSITION)\n    rc += 1;\n\n  return rc;\n}\n\n/**\n * mutt_make_id_hash - Create a Hash Table for message-ids\n * @param m Mailbox\n * @retval ptr Newly allocated Hash Table\n */\nstruct HashTable *mutt_make_id_hash(struct Mailbox *m)\n{\n  struct HashTable *hash = mutt_hash_new(m->msg_count * 2, MUTT_HASH_NO_FLAGS);\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e || !e->env)\n      continue;\n\n    if (e->env->message_id)\n      mutt_hash_insert(hash, e->env->message_id, e);\n  }\n\n  return hash;\n}\n\n/**\n * link_threads - Forcibly link messages together\n * @param parent Parent Email\n * @param child  Child Email\n * @param m      Mailbox\n * @retval true On success\n */\nstatic bool link_threads(struct Email *parent, struct Email *child, struct Mailbox *m)\n{\n  if (child == parent)\n    return false;\n\n  mutt_break_thread(child);\n  mutt_list_insert_head(&child->env->in_reply_to, mutt_str_dup(parent->env->message_id));\n  mutt_set_flag(m, child, MUTT_TAG, false, true);\n\n  child->changed = true;\n  child->env->changed |= MUTT_ENV_CHANGED_IRT;\n  return true;\n}\n\n/**\n * mutt_link_threads - Forcibly link threads together\n * @param parent   Parent Email\n * @param children Array of children Emails\n * @param m        Mailbox\n * @retval true On success\n */\nbool mutt_link_threads(struct Email *parent, struct EmailArray *children, struct Mailbox *m)\n{\n  if (!parent || !children || !m)\n    return false;\n\n  bool changed = false;\n\n  struct Email **ep = NULL;\n  ARRAY_FOREACH(ep, children)\n  {\n    struct Email *e = *ep;\n    changed |= link_threads(parent, e, m);\n  }\n\n  return changed;\n}\n\n/**\n * mutt_thread_collapse_collapsed - Re-collapse threads marked as collapsed\n * @param tctx Threading context\n */\nvoid mutt_thread_collapse_collapsed(struct ThreadsContext *tctx)\n{\n  struct MuttThread *thread = NULL;\n  struct MuttThread *top = tctx->tree;\n  while ((thread = top))\n  {\n    while (!thread->message)\n      thread = thread->child;\n\n    struct Email *e = thread->message;\n    if (e->collapsed)\n      mutt_collapse_thread(e);\n    top = top->next;\n  }\n}\n\n/**\n * mutt_thread_collapse - Toggle collapse\n * @param tctx Threading context\n * @param collapse Collapse / uncollapse\n */\nvoid mutt_thread_collapse(struct ThreadsContext *tctx, bool collapse)\n{\n  struct MuttThread *thread = NULL;\n  struct MuttThread *top = tctx->tree;\n  while ((thread = top))\n  {\n    while (!thread->message)\n      thread = thread->child;\n\n    struct Email *e = thread->message;\n\n    if (e->collapsed != collapse)\n    {\n      if (e->collapsed)\n        mutt_uncollapse_thread(e);\n      else if (mutt_thread_can_collapse(e))\n        mutt_collapse_thread(e);\n    }\n    top = top->next;\n  }\n}\n\n/**\n * mutt_thread_can_collapse - Check whether a thread can be collapsed\n * @param e Head of the thread\n * @retval true Can be collapsed\n * @retval false Cannot be collapsed\n */\nbool mutt_thread_can_collapse(struct Email *e)\n{\n  const bool c_collapse_flagged = cs_subset_bool(NeoMutt->sub, \"collapse_flagged\");\n  const bool c_collapse_unread = cs_subset_bool(NeoMutt->sub, \"collapse_unread\");\n  return (c_collapse_unread || !mutt_thread_contains_unread(e)) &&\n         (c_collapse_flagged || !mutt_thread_contains_flagged(e));\n}\n"
        },
        {
          "name": "mutt_thread.h",
          "type": "blob",
          "size": 5.619140625,
          "content": "/**\n * @file\n * Create/manipulate threading in emails\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2021 Eric Blake <eblake@redhat.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTT_THREAD_H\n#define MUTT_MUTT_THREAD_H\n\n#include \"email/lib.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/types.h>\n\nstruct Buffer;\nstruct ConfigDef;\nstruct ConfigSet;\nstruct Mailbox;\nstruct MailboxView;\n\n/**\n * struct ThreadsContext - The \"current\" threading state\n */\nstruct ThreadsContext\n{\n  struct MailboxView *mailbox_view; ///< Current mailbox\n  struct MuttThread  *tree;         ///< Top of thread tree\n  struct HashTable   *hash;         ///< Hash Table: \"message-id\" -> MuttThread\n  enum EmailSortType  c_sort;       ///< Last sort method\n  enum EmailSortType  c_sort_aux;   ///< Last sort_aux method\n};\n\n/**\n * enum TreeChar - Tree characters for menus\n *\n * @sa linearize_tree(), print_enriched_string()\n */\nenum TreeChar\n{\n  MUTT_TREE_LLCORNER = 1, ///< Lower left corner\n  MUTT_TREE_ULCORNER,     ///< Upper left corner\n  MUTT_TREE_LTEE,         ///< Left T-piece\n  MUTT_TREE_HLINE,        ///< Horizontal line\n  MUTT_TREE_VLINE,        ///< Vertical line\n  MUTT_TREE_SPACE,        ///< Blank space\n  MUTT_TREE_RARROW,       ///< Right arrow\n  MUTT_TREE_STAR,         ///< Star character (for threads)\n  MUTT_TREE_HIDDEN,       ///< Ampersand character (for threads)\n  MUTT_TREE_EQUALS,       ///< Equals (for threads)\n  MUTT_TREE_TTEE,         ///< Top T-piece\n  MUTT_TREE_BTEE,         ///< Bottom T-piece\n  MUTT_TREE_MISSING,      ///< Question mark\n  MUTT_TREE_MAX,\n\n  MUTT_SPECIAL_INDEX = MUTT_TREE_MAX, ///< Colour indicator\n};\n\ntypedef uint8_t MuttThreadFlags;         ///< Flags, e.g. #MUTT_THREAD_COLLAPSE\n#define MUTT_THREAD_NO_FLAGS          0  ///< No flags are set\n#define MUTT_THREAD_COLLAPSE    (1 << 0) ///< Collapse an email thread\n#define MUTT_THREAD_UNCOLLAPSE  (1 << 1) ///< Uncollapse an email thread\n#define MUTT_THREAD_UNREAD      (1 << 2) ///< Count unread emails in a thread\n#define MUTT_THREAD_NEXT_UNREAD (1 << 3) ///< Find the next unread email\n#define MUTT_THREAD_FLAGGED     (1 << 4) ///< Count flagged emails in a thread\n\n/**\n * enum MessageInThread - Flags for mutt_messages_in_thread()\n */\nenum MessageInThread\n{\n  MIT_NUM_MESSAGES, ///< How many messages are in the thread\n  MIT_POSITION,     ///< Our position in the thread\n};\n\n/**\n * enum UseThreads - Which threading style is active, $use_threads\n */\nenum UseThreads\n{\n  UT_UNSET,     ///< Not yet set by user, stick to legacy semantics\n  UT_FLAT,      ///< Unthreaded\n  UT_THREADS,   ///< Normal threading (root above subthreads)\n  UT_REVERSE,   ///< Reverse threading (subthreads above root)\n};\n\nextern const struct EnumDef UseThreadsTypeDef;\n\nint mutt_traverse_thread(struct Email *e, MuttThreadFlags flag);\n#define mutt_collapse_thread(e)         mutt_traverse_thread(e, MUTT_THREAD_COLLAPSE)\n#define mutt_uncollapse_thread(e)       mutt_traverse_thread(e, MUTT_THREAD_UNCOLLAPSE)\n#define mutt_thread_contains_unread(e)  mutt_traverse_thread(e, MUTT_THREAD_UNREAD)\n#define mutt_thread_contains_flagged(e) mutt_traverse_thread(e, MUTT_THREAD_FLAGGED)\n#define mutt_thread_next_unread(e)      mutt_traverse_thread(e, MUTT_THREAD_NEXT_UNREAD)\n\nenum UseThreads mutt_thread_style(void);\n#define mutt_using_threads() (mutt_thread_style() > UT_FLAT)\nconst char *get_use_threads_str(enum UseThreads value);\nint sort_validator(const struct ConfigSet *cs, const struct ConfigDef *cdef,\n                   intptr_t value, struct Buffer *err);\n\nint mutt_aside_thread(struct Email *e, bool forwards, bool subthreads);\n#define mutt_next_thread(e)        mutt_aside_thread(e, true,  false)\n#define mutt_previous_thread(e)    mutt_aside_thread(e, false, false)\n#define mutt_next_subthread(e)     mutt_aside_thread(e, true,  true)\n#define mutt_previous_subthread(e) mutt_aside_thread(e, false, true)\n\nstruct ThreadsContext *mutt_thread_ctx_init          (struct MailboxView *mv);\nvoid                   mutt_thread_ctx_free          (struct ThreadsContext **ptr);\nvoid                   mutt_thread_collapse_collapsed(struct ThreadsContext *tctx);\nvoid                   mutt_thread_collapse          (struct ThreadsContext *tctx, bool collapse);\nbool                   mutt_thread_can_collapse      (struct Email *e);\n\nvoid                   mutt_clear_threads     (struct ThreadsContext *tctx);\nvoid                   mutt_draw_tree         (struct ThreadsContext *tctx);\nbool                   mutt_link_threads      (struct Email *parent, struct EmailArray *children, struct Mailbox *m);\nstruct HashTable *     mutt_make_id_hash      (struct Mailbox *m);\nint                    mutt_messages_in_thread(struct Mailbox *m, struct Email *e, enum MessageInThread mit);\nint                    mutt_parent_message    (struct Email *e, bool find_root);\noff_t                  mutt_set_vnum          (struct Mailbox *m);\nvoid                   mutt_sort_threads      (struct ThreadsContext *tctx, bool init);\n\n#endif /* MUTT_MUTT_THREAD_H */\n"
        },
        {
          "name": "muttlib.c",
          "type": "blob",
          "size": 26.9013671875,
          "content": "/**\n * @file\n * Some miscellaneous functions\n *\n * @authors\n * Copyright (C) 1996-2000,2007,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2008 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2017 Aleksa Sarai <cyphar@cyphar.com>\n * Copyright (C) 2017-2022 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_muttlib Some miscellaneous functions\n *\n * Some miscellaneous functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"muttlib.h\"\n#include \"browser/lib.h\"\n#include \"editor/lib.h\"\n#include \"history/lib.h\"\n#include \"imap/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"question/lib.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"mx.h\"\n#include \"protos.h\"\n\n/// Accepted XDG environment variables\nstatic const char *XdgEnvVars[] = {\n  [XDG_CONFIG_HOME] = \"XDG_CONFIG_HOME\",\n  [XDG_CONFIG_DIRS] = \"XDG_CONFIG_DIRS\",\n};\n\n/// XDG default locations\nstatic const char *XdgDefaults[] = {\n  [XDG_CONFIG_HOME] = \"~/.config\",\n  [XDG_CONFIG_DIRS] = \"/etc/xdg\",\n};\n\n/**\n * mutt_adv_mktemp - Create a temporary file\n * @param buf Buffer for the name\n *\n * Accept a \"suggestion\" for file name.  If that file exists, then\n * construct one with unique name but keep any extension.\n * This might fail, I guess.\n */\nvoid mutt_adv_mktemp(struct Buffer *buf)\n{\n  if (!(buf->data && (buf->data[0] != '\\0')))\n  {\n    buf_mktemp(buf);\n  }\n  else\n  {\n    struct Buffer *prefix = buf_pool_get();\n    buf_strcpy(prefix, buf->data);\n    mutt_file_sanitize_filename(prefix->data, true);\n    const char *const c_tmp_dir = cs_subset_path(NeoMutt->sub, \"tmp_dir\");\n    buf_printf(buf, \"%s/%s\", NONULL(c_tmp_dir), buf_string(prefix));\n\n    struct stat st = { 0 };\n    if ((lstat(buf_string(buf), &st) == -1) && (errno == ENOENT))\n      goto out;\n\n    char *suffix = strchr(prefix->data, '.');\n    if (suffix)\n    {\n      *suffix = '\\0';\n      suffix++;\n    }\n    buf_mktemp_pfx_sfx(buf, prefix->data, suffix);\n\n  out:\n    buf_pool_release(&prefix);\n  }\n}\n\n/**\n * buf_expand_path_regex - Create the canonical path (with regex char escaping)\n * @param buf     Buffer with path\n * @param regex If true, escape any regex characters\n *\n * @note The path is expanded in-place\n */\nvoid buf_expand_path_regex(struct Buffer *buf, bool regex)\n{\n  const char *s = NULL;\n  const char *tail = \"\";\n\n  bool recurse = false;\n\n  struct Buffer *p = buf_pool_get();\n  struct Buffer *q = buf_pool_get();\n  struct Buffer *tmp = buf_pool_get();\n\n  do\n  {\n    recurse = false;\n    s = buf_string(buf);\n\n    switch (*s)\n    {\n      case '~':\n      {\n        if ((s[1] == '/') || (s[1] == '\\0'))\n        {\n          buf_strcpy(p, HomeDir);\n          tail = s + 1;\n        }\n        else\n        {\n          char *t = strchr(s + 1, '/');\n          if (t)\n            *t = '\\0';\n\n          struct passwd *pw = getpwnam(s + 1);\n          if (pw)\n          {\n            buf_strcpy(p, pw->pw_dir);\n            if (t)\n            {\n              *t = '/';\n              tail = t;\n            }\n            else\n            {\n              tail = \"\";\n            }\n          }\n          else\n          {\n            /* user not found! */\n            if (t)\n              *t = '/';\n            buf_reset(p);\n            tail = s;\n          }\n        }\n        break;\n      }\n\n      case '=':\n      case '+':\n      {\n        const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n        enum MailboxType mb_type = mx_path_probe(c_folder);\n\n        /* if folder = {host} or imap[s]://host/: don't append slash */\n        if ((mb_type == MUTT_IMAP) && ((c_folder[strlen(c_folder) - 1] == '}') ||\n                                       (c_folder[strlen(c_folder) - 1] == '/')))\n        {\n          buf_strcpy(p, c_folder);\n        }\n        else if (mb_type == MUTT_NOTMUCH)\n        {\n          buf_strcpy(p, c_folder);\n        }\n        else if (c_folder && (c_folder[strlen(c_folder) - 1] == '/'))\n        {\n          buf_strcpy(p, c_folder);\n        }\n        else\n        {\n          buf_printf(p, \"%s/\", NONULL(c_folder));\n        }\n\n        tail = s + 1;\n        break;\n      }\n\n        /* elm compatibility, @ expands alias to user name */\n\n      case '@':\n      {\n        struct AddressList *al = alias_lookup(s + 1);\n        if (al && !TAILQ_EMPTY(al))\n        {\n          struct Email *e = email_new();\n          e->env = mutt_env_new();\n          mutt_addrlist_copy(&e->env->from, al, false);\n          mutt_addrlist_copy(&e->env->to, al, false);\n\n          buf_alloc(p, PATH_MAX);\n          mutt_default_save(p, e);\n\n          email_free(&e);\n          /* Avoid infinite recursion if the resulting folder starts with '@' */\n          if (*p->data != '@')\n            recurse = true;\n\n          tail = \"\";\n        }\n        break;\n      }\n\n      case '>':\n      {\n        const char *const c_mbox = cs_subset_string(NeoMutt->sub, \"mbox\");\n        buf_strcpy(p, c_mbox);\n        tail = s + 1;\n        break;\n      }\n\n      case '<':\n      {\n        const char *const c_record = cs_subset_string(NeoMutt->sub, \"record\");\n        buf_strcpy(p, c_record);\n        tail = s + 1;\n        break;\n      }\n\n      case '!':\n      {\n        if (s[1] == '!')\n        {\n          buf_strcpy(p, LastFolder);\n          tail = s + 2;\n        }\n        else\n        {\n          const char *const c_spool_file = cs_subset_string(NeoMutt->sub, \"spool_file\");\n          buf_strcpy(p, c_spool_file);\n          tail = s + 1;\n        }\n        break;\n      }\n\n      case '-':\n      {\n        buf_strcpy(p, LastFolder);\n        tail = s + 1;\n        break;\n      }\n\n      case '^':\n      {\n        buf_strcpy(p, CurrentFolder);\n        tail = s + 1;\n        break;\n      }\n\n      default:\n      {\n        buf_reset(p);\n        tail = s;\n      }\n    }\n\n    if (regex && *(buf_string(p)) && !recurse)\n    {\n      mutt_file_sanitize_regex(q, buf_string(p));\n      buf_printf(tmp, \"%s%s\", buf_string(q), tail);\n    }\n    else\n    {\n      buf_printf(tmp, \"%s%s\", buf_string(p), tail);\n    }\n\n    buf_copy(buf, tmp);\n  } while (recurse);\n\n  buf_pool_release(&p);\n  buf_pool_release(&q);\n  buf_pool_release(&tmp);\n\n  /* Rewrite IMAP path in canonical form - aids in string comparisons of\n   * folders. May possibly fail, in which case buf should be the same. */\n  if (imap_path_probe(buf_string(buf), NULL) == MUTT_IMAP)\n    imap_path_canon(buf);\n}\n\n/**\n * buf_expand_path - Create the canonical path\n * @param buf     Buffer with path\n *\n * @note The path is expanded in-place\n */\nvoid buf_expand_path(struct Buffer *buf)\n{\n  buf_expand_path_regex(buf, false);\n}\n\n/**\n * mutt_gecos_name - Lookup a user's real name in /etc/passwd\n * @param dest    Buffer for the result\n * @param destlen Length of buffer\n * @param pw      Passwd entry\n * @retval ptr Result buffer on success\n *\n * Extract the real name from /etc/passwd's GECOS field.  When set, honor the\n * regular expression in `$gecos_mask`, otherwise assume that the GECOS field is a\n * comma-separated list.\n * Replace \"&\" by a capitalized version of the user's login name.\n */\nchar *mutt_gecos_name(char *dest, size_t destlen, struct passwd *pw)\n{\n  regmatch_t pat_match[1] = { 0 };\n  char *p = NULL;\n\n  if (!pw || !pw->pw_gecos)\n    return NULL;\n\n  memset(dest, 0, destlen);\n\n  const struct Regex *c_gecos_mask = cs_subset_regex(NeoMutt->sub, \"gecos_mask\");\n  if (mutt_regex_capture(c_gecos_mask, pw->pw_gecos, 1, pat_match))\n  {\n    mutt_str_copy(dest, pw->pw_gecos + pat_match[0].rm_so,\n                  MIN(pat_match[0].rm_eo - pat_match[0].rm_so + 1, destlen));\n  }\n  else if ((p = strchr(pw->pw_gecos, ',')))\n  {\n    mutt_str_copy(dest, pw->pw_gecos, MIN(destlen, p - pw->pw_gecos + 1));\n  }\n  else\n  {\n    mutt_str_copy(dest, pw->pw_gecos, destlen);\n  }\n\n  size_t pwnl = strlen(pw->pw_name);\n\n  for (int idx = 0; dest[idx]; idx++)\n  {\n    if (dest[idx] == '&')\n    {\n      memmove(&dest[idx + pwnl], &dest[idx + 1],\n              MAX((ssize_t) (destlen - idx - pwnl - 1), 0));\n      memcpy(&dest[idx], pw->pw_name, MIN(destlen - idx - 1, pwnl));\n      dest[idx] = toupper((unsigned char) dest[idx]);\n    }\n  }\n\n  return dest;\n}\n\n/**\n * mutt_needs_mailcap - Does this type need a mailcap entry do display\n * @param b Attachment body to be displayed\n * @retval true  NeoMutt requires a mailcap entry to display\n * @retval false otherwise\n */\nbool mutt_needs_mailcap(struct Body *b)\n{\n  switch (b->type)\n  {\n    case TYPE_TEXT:\n      if (mutt_istr_equal(\"plain\", b->subtype))\n        return false;\n      break;\n    case TYPE_APPLICATION:\n      if (((WithCrypto & APPLICATION_PGP) != 0) && mutt_is_application_pgp(b))\n        return false;\n      if (((WithCrypto & APPLICATION_SMIME) != 0) && mutt_is_application_smime(b))\n        return false;\n      break;\n\n    case TYPE_MULTIPART:\n    case TYPE_MESSAGE:\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * mutt_is_text_part - Is this part of an email in plain text?\n * @param b Part of an email\n * @retval true Part is in plain text\n */\nbool mutt_is_text_part(const struct Body *b)\n{\n  int t = b->type;\n  char *s = b->subtype;\n\n  if (((WithCrypto & APPLICATION_PGP) != 0) && mutt_is_application_pgp(b))\n    return false;\n\n  if (t == TYPE_TEXT)\n    return true;\n\n  if (t == TYPE_MESSAGE)\n  {\n    if (mutt_istr_equal(\"delivery-status\", s))\n      return true;\n  }\n\n  if (((WithCrypto & APPLICATION_PGP) != 0) && (t == TYPE_APPLICATION))\n  {\n    if (mutt_istr_equal(\"pgp-keys\", s))\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * mutt_pretty_mailbox - Shorten a mailbox path using '~' or '='\n * @param buf    Buffer containing string to shorten\n * @param buflen Length of buffer\n *\n * Collapse the pathname using ~ or = when possible\n */\nvoid mutt_pretty_mailbox(char *buf, size_t buflen)\n{\n  if (!buf)\n    return;\n\n  char *p = buf, *q = buf;\n  size_t len;\n  enum UrlScheme scheme;\n  char tmp[PATH_MAX] = { 0 };\n\n  scheme = url_check_scheme(buf);\n\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  if ((scheme == U_IMAP) || (scheme == U_IMAPS))\n  {\n    imap_pretty_mailbox(buf, buflen, c_folder);\n    return;\n  }\n\n  if (scheme == U_NOTMUCH)\n    return;\n\n  /* if buf is an url, only collapse path component */\n  if (scheme != U_UNKNOWN)\n  {\n    p = strchr(buf, ':') + 1;\n    if (mutt_strn_equal(p, \"//\", 2))\n      q = strchr(p + 2, '/');\n    if (!q)\n      q = strchr(p, '\\0');\n    p = q;\n  }\n\n  /* cleanup path */\n  if (strstr(p, \"//\") || strstr(p, \"/./\"))\n  {\n    /* first attempt to collapse the pathname, this is more\n     * lightweight than realpath() and doesn't resolve links */\n    while (*p)\n    {\n      if ((p[0] == '/') && (p[1] == '/'))\n      {\n        *q++ = '/';\n        p += 2;\n      }\n      else if ((p[0] == '/') && (p[1] == '.') && (p[2] == '/'))\n      {\n        *q++ = '/';\n        p += 3;\n      }\n      else\n      {\n        *q++ = *p++;\n      }\n    }\n    *q = '\\0';\n  }\n  else if (strstr(p, \"..\") && ((scheme == U_UNKNOWN) || (scheme == U_FILE)) &&\n           realpath(p, tmp))\n  {\n    mutt_str_copy(p, tmp, buflen - (p - buf));\n  }\n\n  if ((len = mutt_str_startswith(buf, c_folder)) && (buf[len] == '/'))\n  {\n    *buf++ = '=';\n    memmove(buf, buf + len, mutt_str_len(buf + len) + 1);\n  }\n  else if ((len = mutt_str_startswith(buf, HomeDir)) && (buf[len] == '/'))\n  {\n    *buf++ = '~';\n    memmove(buf, buf + len - 1, mutt_str_len(buf + len - 1) + 1);\n  }\n}\n\n/**\n * buf_pretty_mailbox - Shorten a mailbox path using '~' or '='\n * @param buf Buffer containing Mailbox name\n */\nvoid buf_pretty_mailbox(struct Buffer *buf)\n{\n  if (!buf || !buf->data)\n    return;\n  /* This reduces the size of the Buffer, so we can pass it through.\n   * We adjust the size just to make sure buf->data is not NULL though */\n  buf_alloc(buf, PATH_MAX);\n  mutt_pretty_mailbox(buf->data, buf->dsize);\n  buf_fix_dptr(buf);\n}\n\n/**\n * mutt_check_overwrite - Ask the user if overwriting is necessary\n * @param[in]  attname   Attachment name\n * @param[in]  path      Path to save the file\n * @param[out] fname     Buffer for filename\n * @param[out] opt       Save option, see #SaveAttach\n * @param[out] directory Directory to save under (OPTIONAL)\n * @retval  0 Success\n * @retval -1 Abort\n * @retval  1 Error\n */\nint mutt_check_overwrite(const char *attname, const char *path, struct Buffer *fname,\n                         enum SaveAttach *opt, char **directory)\n{\n  struct stat st = { 0 };\n\n  buf_strcpy(fname, path);\n  if (access(buf_string(fname), F_OK) != 0)\n    return 0;\n  if (stat(buf_string(fname), &st) != 0)\n    return -1;\n  if (S_ISDIR(st.st_mode))\n  {\n    enum QuadOption ans = MUTT_NO;\n    if (directory)\n    {\n      switch (mw_multi_choice\n              /* L10N: Means \"The path you specified as the destination file is a directory.\"\n                 See the msgid \"Save to file: \" (alias.c, recvattach.c)\n                 These three letters correspond to the choices in the string.  */\n              (_(\"File is a directory, save under it: (y)es, (n)o, (a)ll?\"), _(\"yna\")))\n      {\n        case 3: /* all */\n          mutt_str_replace(directory, buf_string(fname));\n          break;\n        case 1: /* yes */\n          FREE(directory);\n          break;\n        case -1: /* abort */\n          FREE(directory);\n          return -1;\n        case 2: /* no */\n          FREE(directory);\n          return 1;\n      }\n    }\n    /* L10N: Means \"The path you specified as the destination file is a directory.\"\n       See the msgid \"Save to file: \" (alias.c, recvattach.c) */\n    else if ((ans = query_yesorno(_(\"File is a directory, save under it?\"), MUTT_YES)) != MUTT_YES)\n      return (ans == MUTT_NO) ? 1 : -1;\n\n    struct Buffer *tmp = buf_pool_get();\n    buf_strcpy(tmp, mutt_path_basename(NONULL(attname)));\n    struct FileCompletionData cdata = { false, NULL, NULL, NULL };\n    if ((mw_get_field(_(\"File under directory: \"), tmp, MUTT_COMP_CLEAR,\n                      HC_FILE, &CompleteFileOps, &cdata) != 0) ||\n        buf_is_empty(tmp))\n    {\n      buf_pool_release(&tmp);\n      return (-1);\n    }\n    buf_concat_path(fname, path, buf_string(tmp));\n    buf_pool_release(&tmp);\n  }\n\n  if ((*opt == MUTT_SAVE_NO_FLAGS) && (access(buf_string(fname), F_OK) == 0))\n  {\n    char buf[4096] = { 0 };\n    snprintf(buf, sizeof(buf), \"%s - %s\", buf_string(fname),\n             // L10N: Options for: File %s exists, (o)verwrite, (a)ppend, or (c)ancel?\n             _(\"File exists, (o)verwrite, (a)ppend, or (c)ancel?\"));\n    switch (mw_multi_choice(buf, _(\"oac\")))\n    {\n      case -1: /* abort */\n        return -1;\n      case 3: /* cancel */\n        return 1;\n\n      case 2: /* append */\n        *opt = MUTT_SAVE_APPEND;\n        break;\n      case 1: /* overwrite */\n        break;\n    }\n  }\n  return 0;\n}\n\n/**\n * mutt_save_path - Turn an email address into a filename (for saving)\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n * @param addr   Email address to use\n *\n * If the user hasn't set `$save_address` the name will be truncated to the '@'\n * character.\n */\nvoid mutt_save_path(char *buf, size_t buflen, const struct Address *addr)\n{\n  if (addr && addr->mailbox)\n  {\n    mutt_str_copy(buf, buf_string(addr->mailbox), buflen);\n    const bool c_save_address = cs_subset_bool(NeoMutt->sub, \"save_address\");\n    if (!c_save_address)\n    {\n      char *p = strpbrk(buf, \"%@\");\n      if (p)\n        *p = '\\0';\n    }\n    mutt_str_lower(buf);\n  }\n  else\n  {\n    *buf = '\\0';\n  }\n}\n\n/**\n * buf_save_path - Make a safe filename from an email address\n * @param dest Buffer for the result\n * @param a    Address to use\n */\nvoid buf_save_path(struct Buffer *dest, const struct Address *a)\n{\n  if (a && a->mailbox)\n  {\n    buf_copy(dest, a->mailbox);\n    const bool c_save_address = cs_subset_bool(NeoMutt->sub, \"save_address\");\n    if (!c_save_address)\n    {\n      char *p = strpbrk(dest->data, \"%@\");\n      if (p)\n      {\n        *p = '\\0';\n        buf_fix_dptr(dest);\n      }\n    }\n    mutt_str_lower(dest->data);\n  }\n  else\n  {\n    buf_reset(dest);\n  }\n}\n\n/**\n * mutt_safe_path - Make a safe filename from an email address\n * @param dest Buffer for the result\n * @param a    Address to use\n *\n * The filename will be stripped of '/', space, etc to make it safe.\n */\nvoid mutt_safe_path(struct Buffer *dest, const struct Address *a)\n{\n  buf_save_path(dest, a);\n  for (char *p = dest->data; *p; p++)\n    if ((*p == '/') || isspace(*p) || !IsPrint((unsigned char) *p))\n      *p = '_';\n}\n\n/**\n * mutt_open_read - Run a command to read from\n * @param[in]  path   Path to command\n * @param[out] thepid PID of the command\n * @retval ptr File containing output of command\n *\n * This function allows the user to specify a command to read stdout from in\n * place of a normal file.  If the last character in the string is a pipe (|),\n * then we assume it is a command to run instead of a normal file.\n */\nFILE *mutt_open_read(const char *path, pid_t *thepid)\n{\n  FILE *fp = NULL;\n  struct stat st = { 0 };\n\n  size_t len = mutt_str_len(path);\n  if (len == 0)\n  {\n    return NULL;\n  }\n\n  if (path[len - 1] == '|')\n  {\n    /* read from a pipe */\n\n    char *p = mutt_str_dup(path);\n\n    p[len - 1] = 0;\n    mutt_endwin();\n    *thepid = filter_create(p, NULL, &fp, NULL, EnvList);\n    FREE(&p);\n  }\n  else\n  {\n    if (stat(path, &st) < 0)\n      return NULL;\n    if (S_ISDIR(st.st_mode))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n    fp = mutt_file_fopen(path, \"r\");\n    *thepid = -1;\n  }\n  return fp;\n}\n\n/**\n * mutt_save_confirm - Ask the user to save\n * @param s  Save location\n * @param st Timestamp\n * @retval  0 OK to proceed\n * @retval -1 to abort\n * @retval  1 to retry\n */\nint mutt_save_confirm(const char *s, struct stat *st)\n{\n  int rc = 0;\n\n  enum MailboxType type = mx_path_probe(s);\n\n  if (type == MUTT_POP)\n  {\n    mutt_error(_(\"Can't save message to POP mailbox\"));\n    return 1;\n  }\n\n  if ((type != MUTT_MAILBOX_ERROR) && (type != MUTT_UNKNOWN) && (mx_access(s, W_OK) == 0))\n  {\n    const bool c_confirm_append = cs_subset_bool(NeoMutt->sub, \"confirm_append\");\n    if (c_confirm_append)\n    {\n      struct Buffer *tmp = buf_pool_get();\n      buf_printf(tmp, _(\"Append messages to %s?\"), s);\n      enum QuadOption ans = query_yesorno_help(buf_string(tmp), MUTT_YES,\n                                               NeoMutt->sub, \"confirm_append\");\n      if (ans == MUTT_NO)\n        rc = 1;\n      else if (ans == MUTT_ABORT)\n        rc = -1;\n      buf_pool_release(&tmp);\n    }\n  }\n\n  if (type == MUTT_NNTP)\n  {\n    mutt_error(_(\"Can't save message to news server\"));\n    return 0;\n  }\n\n  if (stat(s, st) != -1)\n  {\n    if (type == MUTT_MAILBOX_ERROR)\n    {\n      mutt_error(_(\"%s is not a mailbox\"), s);\n      return 1;\n    }\n  }\n  else if (type != MUTT_IMAP)\n  {\n    st->st_mtime = 0;\n    st->st_atime = 0;\n\n    /* pathname does not exist */\n    if (errno == ENOENT)\n    {\n      const bool c_confirm_create = cs_subset_bool(NeoMutt->sub, \"confirm_create\");\n      if (c_confirm_create)\n      {\n        struct Buffer *tmp = buf_pool_get();\n        buf_printf(tmp, _(\"Create %s?\"), s);\n        enum QuadOption ans = query_yesorno_help(buf_string(tmp), MUTT_YES,\n                                                 NeoMutt->sub, \"confirm_create\");\n        if (ans == MUTT_NO)\n          rc = 1;\n        else if (ans == MUTT_ABORT)\n          rc = -1;\n        buf_pool_release(&tmp);\n      }\n\n      /* user confirmed with MUTT_YES or set `$confirm_create` */\n      if (rc == 0)\n      {\n        /* create dir recursively */\n        char *tmp_path = mutt_path_dirname(s);\n        if (mutt_file_mkdir(tmp_path, S_IRWXU) == -1)\n        {\n          /* report failure & abort */\n          mutt_perror(\"%s\", s);\n          FREE(&tmp_path);\n          return 1;\n        }\n        FREE(&tmp_path);\n      }\n    }\n    else\n    {\n      mutt_perror(\"%s\", s);\n      return 1;\n    }\n  }\n\n  msgwin_clear_text(NULL);\n  return rc;\n}\n\n/**\n * mutt_sleep - Sleep for a while\n * @param s Number of seconds to sleep\n *\n * If the user config '$sleep_time' is larger, sleep that long instead.\n */\nvoid mutt_sleep(short s)\n{\n  const short c_sleep_time = cs_subset_number(NeoMutt->sub, \"sleep_time\");\n  if (c_sleep_time > s)\n    sleep(c_sleep_time);\n  else if (s)\n    sleep(s);\n}\n\n/**\n * mutt_make_version - Generate the NeoMutt version string\n * @retval ptr Version string\n *\n * @note This returns a pointer to a static buffer\n */\nconst char *mutt_make_version(void)\n{\n  static char vstring[256];\n  snprintf(vstring, sizeof(vstring), \"NeoMutt %s%s\", PACKAGE_VERSION, GitVer);\n  return vstring;\n}\n\n/**\n * mutt_encode_path - Convert a path to 'us-ascii'\n * @param buf Buffer for the result\n * @param src Path to convert (OPTIONAL)\n *\n * If `src` is NULL, the path in `buf` will be converted in-place.\n */\nvoid mutt_encode_path(struct Buffer *buf, const char *src)\n{\n  char *p = mutt_str_dup(src);\n  int rc = mutt_ch_convert_string(&p, cc_charset(), \"us-ascii\", MUTT_ICONV_NO_FLAGS);\n  size_t len = buf_strcpy(buf, (rc == 0) ? NONULL(p) : NONULL(src));\n\n  /* convert the path to POSIX \"Portable Filename Character Set\" */\n  for (size_t i = 0; i < len; i++)\n  {\n    if (!isalnum(buf->data[i]) && !strchr(\"/.-_\", buf->data[i]))\n    {\n      buf->data[i] = '_';\n    }\n  }\n  FREE(&p);\n}\n\n/**\n * mutt_set_xdg_path - Find an XDG path or its fallback\n * @param type    Type of XDG variable, e.g. #XDG_CONFIG_HOME\n * @param buf     Buffer to save path\n * @retval 1 An entry was found that actually exists on disk and 0 otherwise\n *\n * Process an XDG environment variable or its fallback.\n */\nint mutt_set_xdg_path(enum XdgType type, struct Buffer *buf)\n{\n  const char *xdg_env = mutt_str_getenv(XdgEnvVars[type]);\n  char *xdg = xdg_env ? mutt_str_dup(xdg_env) : mutt_str_dup(XdgDefaults[type]);\n  char *x = xdg; /* mutt_str_sep() changes xdg, so free x instead later */\n  char *token = NULL;\n  int rc = 0;\n\n  while ((token = mutt_str_sep(&xdg, \":\")))\n  {\n    if (buf_printf(buf, \"%s/%s/neomuttrc\", token, PACKAGE) < 0)\n      continue;\n    buf_expand_path(buf);\n    if (access(buf_string(buf), F_OK) == 0)\n    {\n      rc = 1;\n      break;\n    }\n\n    if (buf_printf(buf, \"%s/%s/Muttrc\", token, PACKAGE) < 0)\n      continue;\n    buf_expand_path(buf);\n    if (access(buf_string(buf), F_OK) == 0)\n    {\n      rc = 1;\n      break;\n    }\n  }\n\n  FREE(&x);\n  return rc;\n}\n\n/**\n * mutt_get_parent_path - Find the parent of a path (or mailbox)\n * @param path   Path to use\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n */\nvoid mutt_get_parent_path(const char *path, char *buf, size_t buflen)\n{\n  enum MailboxType mb_type = mx_path_probe(path);\n\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  if (mb_type == MUTT_IMAP)\n  {\n    imap_get_parent_path(path, buf, buflen);\n  }\n  else if (mb_type == MUTT_NOTMUCH)\n  {\n    mutt_str_copy(buf, c_folder, buflen);\n  }\n  else\n  {\n    mutt_str_copy(buf, path, buflen);\n    int n = mutt_str_len(buf);\n    if (n == 0)\n      return;\n\n    /* remove any final trailing '/' */\n    if (buf[n - 1] == '/')\n      buf[n - 1] = '\\0';\n\n    /* Remove everything until the next slash */\n    for (n--; ((n >= 0) && (buf[n] != '/')); n--)\n      ; // do nothing\n\n    if (n > 0)\n    {\n      buf[n] = '\\0';\n    }\n    else\n    {\n      buf[0] = '/';\n      buf[1] = '\\0';\n    }\n  }\n}\n\n/**\n * buf_sanitize_filename - Replace unsafe characters in a filename\n * @param buf   Buffer for the result\n * @param path  Filename to make safe\n * @param slash Replace '/' characters too\n */\nvoid buf_sanitize_filename(struct Buffer *buf, const char *path, short slash)\n{\n  if (!buf || !path)\n    return;\n\n  buf_reset(buf);\n\n  for (; *path; path++)\n  {\n    if ((slash && (*path == '/')) || !strchr(FilenameSafeChars, *path))\n      buf_addch(buf, '_');\n    else\n      buf_addch(buf, *path);\n  }\n}\n\n/**\n * mutt_str_pretty_size - Display an abbreviated size, like 3.4K\n * @param buf    Buffer for the result\n * @param buflen Length of the buffer\n * @param num    Number to abbreviate\n */\nvoid mutt_str_pretty_size(char *buf, size_t buflen, size_t num)\n{\n  if (!buf || (buflen == 0))\n    return;\n\n  const bool c_size_show_bytes = cs_subset_bool(NeoMutt->sub, \"size_show_bytes\");\n  const bool c_size_show_fractions = cs_subset_bool(NeoMutt->sub, \"size_show_fractions\");\n  const bool c_size_show_mb = cs_subset_bool(NeoMutt->sub, \"size_show_mb\");\n  const bool c_size_units_on_left = cs_subset_bool(NeoMutt->sub, \"size_units_on_left\");\n\n  if (c_size_show_bytes && (num < 1024))\n  {\n    snprintf(buf, buflen, \"%d\", (int) num);\n  }\n  else if (num == 0)\n  {\n    mutt_str_copy(buf, c_size_units_on_left ? \"K0\" : \"0K\", buflen);\n  }\n  else if (c_size_show_fractions && (num < 10189)) /* 0.1K - 9.9K */\n  {\n    snprintf(buf, buflen, c_size_units_on_left ? \"K%3.1f\" : \"%3.1fK\",\n             (num < 103) ? 0.1 : (num / 1024.0));\n  }\n  else if (!c_size_show_mb || (num < 1023949)) /* 10K - 999K */\n  {\n    /* 51 is magic which causes 10189/10240 to be rounded up to 10 */\n    snprintf(buf, buflen, c_size_units_on_left ? (\"K%zu\") : (\"%zuK\"), (num + 51) / 1024);\n  }\n  else if (c_size_show_fractions && (num < 10433332)) /* 1.0M - 9.9M */\n  {\n    snprintf(buf, buflen, c_size_units_on_left ? \"M%3.1f\" : \"%3.1fM\", num / 1048576.0);\n  }\n  else /* 10M+ */\n  {\n    /* (10433332 + 52428) / 1048576 = 10 */\n    snprintf(buf, buflen, c_size_units_on_left ? (\"M%zu\") : (\"%zuM\"), (num + 52428) / 1048576);\n  }\n}\n\n/**\n * add_to_stailq - Add a string to a list\n * @param head String list\n * @param str  String to add\n *\n * @note Duplicate or empty strings will not be added\n */\nvoid add_to_stailq(struct ListHead *head, const char *str)\n{\n  /* don't add a NULL or empty string to the list */\n  if (!str || (*str == '\\0'))\n    return;\n\n  /* check to make sure the item is not already on this list */\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, head, entries)\n  {\n    if (mutt_istr_equal(str, np->data))\n    {\n      return;\n    }\n  }\n  mutt_list_insert_tail(head, mutt_str_dup(str));\n}\n\n/**\n * remove_from_stailq - Remove an item, matching a string, from a List\n * @param head Head of the List\n * @param str  String to match\n *\n * @note The string comparison is case-insensitive\n */\nvoid remove_from_stailq(struct ListHead *head, const char *str)\n{\n  if (mutt_str_equal(\"*\", str))\n  {\n    mutt_list_free(head); /* \"unCMD *\" means delete all current entries */\n  }\n  else\n  {\n    struct ListNode *np = NULL, *tmp = NULL;\n    STAILQ_FOREACH_SAFE(np, head, entries, tmp)\n    {\n      if (mutt_istr_equal(str, np->data))\n      {\n        STAILQ_REMOVE(head, np, ListNode, entries);\n        FREE(&np->data);\n        FREE(&np);\n        break;\n      }\n    }\n  }\n}\n"
        },
        {
          "name": "muttlib.h",
          "type": "blob",
          "size": 2.4931640625,
          "content": "/**\n * @file\n * Some miscellaneous functions\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2019 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MUTTLIB_H\n#define MUTT_MUTTLIB_H\n\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"attach/lib.h\"\n\nstruct Address;\nstruct Body;\nstruct Buffer;\nstruct ListHead;\nstruct passwd;\nstruct stat;\n\nvoid        mutt_adv_mktemp(struct Buffer *buf);\nvoid        buf_expand_path(struct Buffer *buf);\nvoid        buf_expand_path_regex(struct Buffer *buf, bool regex);\nvoid        buf_pretty_mailbox(struct Buffer *s);\nvoid        buf_sanitize_filename (struct Buffer *buf, const char *path, short slash);\nvoid        buf_save_path(struct Buffer *dest, const struct Address *a);\nint         mutt_check_overwrite(const char *attname, const char *path, struct Buffer *fname, enum SaveAttach *opt, char **directory);\nvoid        mutt_encode_path(struct Buffer *buf, const char *src);\nchar *      mutt_gecos_name(char *dest, size_t destlen, struct passwd *pw);\nvoid        mutt_get_parent_path(const char *path, char *buf, size_t buflen);\nbool        mutt_is_text_part(const struct Body *b);\nconst char *mutt_make_version(void);\nbool        mutt_needs_mailcap(struct Body *b);\nFILE *      mutt_open_read(const char *path, pid_t *thepid);\nvoid        mutt_pretty_mailbox(char *buf, size_t buflen);\nvoid        mutt_safe_path(struct Buffer *dest, const struct Address *a);\nint         mutt_save_confirm(const char *s, struct stat *st);\nvoid        mutt_save_path(char *d, size_t dsize, const struct Address *a);\nvoid        mutt_sleep(short s);\nvoid        mutt_str_pretty_size(char *buf, size_t buflen, size_t num);\n\nvoid add_to_stailq     (struct ListHead *head, const char *str);\nvoid remove_from_stailq(struct ListHead *head, const char *str);\n\n#endif /* MUTT_MUTTLIB_H */\n"
        },
        {
          "name": "mview.c",
          "type": "blob",
          "size": 11.822265625,
          "content": "/**\n * @file\n * View of a Mailbox\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2020-2021 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mview View of a Mailbox\n *\n * View of a Mailbox\n */\n\n#include \"config.h\"\n#include <string.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"mview.h\"\n#include \"imap/lib.h\"\n#include \"ncrypt/lib.h\"\n#include \"pattern/lib.h\"\n#include \"mutt_header.h\"\n#include \"mutt_thread.h\"\n#include \"mx.h\"\n#include \"score.h\"\n\n/**\n * mview_free - Free a MailboxView\n * @param[out] ptr MailboxView to free\n */\nvoid mview_free(struct MailboxView **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct MailboxView *mv = *ptr;\n\n  struct EventMview ev_m = { mv };\n  mutt_debug(LL_NOTIFY, \"NT_MVIEW_DELETE: %p\\n\", (void *) mv);\n  notify_send(mv->notify, NT_MVIEW, NT_MVIEW_DELETE, &ev_m);\n\n  if (mv->mailbox)\n  {\n    notify_observer_remove(mv->mailbox->notify, mview_mailbox_observer, mv);\n\n    // Disconnect the Emails before freeing the Threads\n    for (int i = 0; i < mv->mailbox->msg_count; i++)\n    {\n      struct Email *e = mv->mailbox->emails[i];\n      if (!e)\n        continue;\n      e->thread = NULL;\n      e->threaded = false;\n    }\n  }\n\n  mutt_thread_ctx_free(&mv->threads);\n  notify_free(&mv->notify);\n  FREE(&mv->pattern);\n  mutt_pattern_free(&mv->limit_pattern);\n\n  *ptr = NULL;\n  FREE(&mv);\n}\n\n/**\n * mview_new - Create a new MailboxView\n * @param m      Mailbox\n * @param parent Notification parent\n * @retval ptr New MailboxView\n */\nstruct MailboxView *mview_new(struct Mailbox *m, struct Notify *parent)\n{\n  if (!m)\n    return NULL;\n\n  struct MailboxView *mv = MUTT_MEM_CALLOC(1, struct MailboxView);\n\n  mv->notify = notify_new();\n  notify_set_parent(mv->notify, parent);\n  struct EventMview ev_m = { mv };\n  mutt_debug(LL_NOTIFY, \"NT_MVIEW_ADD: %p\\n\", (void *) mv);\n  notify_send(mv->notify, NT_MVIEW, NT_MVIEW_ADD, &ev_m);\n  // If the Mailbox is closed, mv->mailbox must be set to NULL\n  notify_observer_add(m->notify, NT_MAILBOX, mview_mailbox_observer, mv);\n\n  mv->mailbox = m;\n  mv->threads = mutt_thread_ctx_init(mv);\n  mv->msg_in_pager = -1;\n  mv->collapsed = false;\n  mview_update(mv);\n\n  return mv;\n}\n\n/**\n * mview_clean - Release memory and initialize a MailboxView\n * @param mv MailboxView to cleanup\n */\nstatic void mview_clean(struct MailboxView *mv)\n{\n  FREE(&mv->pattern);\n  mutt_pattern_free(&mv->limit_pattern);\n  if (mv->mailbox)\n    notify_observer_remove(mv->mailbox->notify, mview_mailbox_observer, mv);\n\n  struct Notify *notify = mv->notify;\n  struct Mailbox *m = mv->mailbox;\n  memset(mv, 0, sizeof(struct MailboxView));\n  mv->notify = notify;\n  mv->mailbox = m;\n}\n\n/**\n * mview_update - Update the MailboxView's message counts\n * @param mv Mailbox View\n *\n * this routine is called to update the counts in the MailboxView structure\n */\nvoid mview_update(struct MailboxView *mv)\n{\n  if (!mv || !mv->mailbox)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n\n  mutt_hash_free(&m->subj_hash);\n  mutt_hash_free(&m->id_hash);\n\n  /* reset counters */\n  m->msg_unread = 0;\n  m->msg_flagged = 0;\n  m->msg_new = 0;\n  m->msg_deleted = 0;\n  m->msg_tagged = 0;\n  m->vcount = 0;\n  m->changed = false;\n\n  mutt_clear_threads(mv->threads);\n\n  const bool c_score = cs_subset_bool(NeoMutt->sub, \"score\");\n  struct Email *e = NULL;\n  for (int msgno = 0; msgno < m->msg_count; msgno++)\n  {\n    e = m->emails[msgno];\n    if (!e)\n      continue;\n\n    if (WithCrypto)\n    {\n      /* NOTE: this _must_ be done before the check for mailcap! */\n      e->security = crypt_query(e->body);\n    }\n\n    if (mview_has_limit(mv))\n    {\n      e->vnum = -1;\n    }\n    else\n    {\n      m->v2r[m->vcount] = msgno;\n      e->vnum = m->vcount++;\n    }\n    e->msgno = msgno;\n\n    if (e->env->supersedes)\n    {\n      struct Email *e2 = NULL;\n\n      if (!m->id_hash)\n        m->id_hash = mutt_make_id_hash(m);\n\n      e2 = mutt_hash_find(m->id_hash, e->env->supersedes);\n      if (e2)\n      {\n        e2->superseded = true;\n        if (c_score)\n          mutt_score_message(mv->mailbox, e2, true);\n      }\n    }\n\n    /* add this message to the hash tables */\n    if (m->id_hash && e->env->message_id)\n      mutt_hash_insert(m->id_hash, e->env->message_id, e);\n    if (m->subj_hash && e->env->real_subj)\n      mutt_hash_insert(m->subj_hash, e->env->real_subj, e);\n    mutt_label_hash_add(m, e);\n\n    if (c_score)\n      mutt_score_message(mv->mailbox, e, false);\n\n    if (e->changed)\n      m->changed = true;\n    if (e->flagged)\n      m->msg_flagged++;\n    if (e->deleted)\n      m->msg_deleted++;\n    if (e->tagged)\n      m->msg_tagged++;\n    if (!e->read)\n    {\n      m->msg_unread++;\n      if (!e->old)\n        m->msg_new++;\n    }\n  }\n\n  /* rethread from scratch */\n  mutt_sort_headers(mv, true);\n}\n\n/**\n * update_tables - Update a MailboxView's internal tables\n * @param mv Mailbox\n */\nstatic void update_tables(struct MailboxView *mv)\n{\n  if (!mv || !mv->mailbox)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n\n  int i, j, padding;\n\n  /* update memory to reflect the new state of the mailbox */\n  m->vcount = 0;\n  mv->vsize = 0;\n  m->msg_tagged = 0;\n  m->msg_deleted = 0;\n  m->msg_new = 0;\n  m->msg_unread = 0;\n  m->changed = false;\n  m->msg_flagged = 0;\n  padding = mx_msg_padding_size(m);\n  const bool c_maildir_trash = cs_subset_bool(NeoMutt->sub, \"maildir_trash\");\n  for (i = 0, j = 0; i < m->msg_count; i++)\n  {\n    if (!m->emails[i])\n      break;\n    if (!m->emails[i]->quasi_deleted &&\n        (!m->emails[i]->deleted || ((m->type == MUTT_MAILDIR) && c_maildir_trash)))\n    {\n      if (i != j)\n      {\n        m->emails[j] = m->emails[i];\n        m->emails[i] = NULL;\n      }\n      m->emails[j]->msgno = j;\n      if (m->emails[j]->vnum != -1)\n      {\n        m->v2r[m->vcount] = j;\n        m->emails[j]->vnum = m->vcount++;\n        struct Body *b = m->emails[j]->body;\n        mv->vsize += b->length + b->offset - b->hdr_offset + padding;\n      }\n\n      m->emails[j]->changed = false;\n      m->emails[j]->env->changed = false;\n\n      if ((m->type == MUTT_MAILDIR) && c_maildir_trash)\n      {\n        if (m->emails[j]->deleted)\n          m->msg_deleted++;\n      }\n\n      if (m->emails[j]->tagged)\n        m->msg_tagged++;\n      if (m->emails[j]->flagged)\n        m->msg_flagged++;\n      if (!m->emails[j]->read)\n      {\n        m->msg_unread++;\n        if (!m->emails[j]->old)\n          m->msg_new++;\n      }\n\n      j++;\n    }\n    else\n    {\n      if ((m->type == MUTT_NOTMUCH) || (m->type == MUTT_MH) ||\n          (m->type == MUTT_MAILDIR) || (m->type == MUTT_IMAP))\n      {\n        mailbox_size_sub(m, m->emails[i]);\n      }\n      /* remove message from the hash tables */\n      if (m->subj_hash && m->emails[i]->env->real_subj)\n        mutt_hash_delete(m->subj_hash, m->emails[i]->env->real_subj, m->emails[i]);\n      if (m->id_hash && m->emails[i]->env->message_id)\n        mutt_hash_delete(m->id_hash, m->emails[i]->env->message_id, m->emails[i]);\n      mutt_label_hash_remove(m, m->emails[i]);\n\n      if (m->type == MUTT_IMAP)\n        imap_notify_delete_email(m, m->emails[i]);\n\n      mailbox_gc_add(m->emails[i]);\n      m->emails[i] = NULL;\n    }\n  }\n  m->msg_count = j;\n}\n\n/**\n * mview_mailbox_observer - Notification that a Mailbox has changed - Implements ::observer_t - @ingroup observer_api\n */\nint mview_mailbox_observer(struct NotifyCallback *nc)\n{\n  if (nc->event_type != NT_MAILBOX)\n    return 0;\n  if (!nc->global_data)\n    return -1;\n\n  struct MailboxView *mv = nc->global_data;\n\n  switch (nc->event_subtype)\n  {\n    case NT_MAILBOX_DELETE:\n      mutt_clear_threads(mv->threads);\n      mview_clean(mv);\n      break;\n    case NT_MAILBOX_INVALID:\n      mview_update(mv);\n      break;\n    case NT_MAILBOX_UPDATE:\n      update_tables(mv);\n      break;\n    case NT_MAILBOX_RESORT:\n      mutt_sort_headers(mv, true);\n      break;\n    default:\n      return 0;\n  }\n\n  mutt_debug(LL_DEBUG5, \"mailbox done\\n\");\n  return 0;\n}\n\n/**\n * message_is_tagged - Is a message in the index tagged (and within limit)\n * @param e   Email\n * @retval true The message is both tagged and within limit\n *\n * If a limit is in effect, the message must be visible within it.\n */\nbool message_is_tagged(struct Email *e)\n{\n  return e->visible && e->tagged;\n}\n\n/**\n * ea_add_tagged - Get an array of the tagged Emails\n * @param ea         Empty EmailArray to populate\n * @param mv         Current Mailbox\n * @param e          Current Email\n * @param use_tagged Use tagged Emails\n * @retval num Number of selected emails\n * @retval -1  Error\n */\nint ea_add_tagged(struct EmailArray *ea, struct MailboxView *mv, struct Email *e, bool use_tagged)\n{\n  if (use_tagged)\n  {\n    if (!mv || !mv->mailbox || !mv->mailbox->emails)\n      return -1;\n\n    struct Mailbox *m = mv->mailbox;\n    for (int i = 0; i < m->msg_count; i++)\n    {\n      e = m->emails[i];\n      if (!e)\n        break;\n      if (!message_is_tagged(e))\n        continue;\n\n      ARRAY_ADD(ea, e);\n    }\n  }\n  else\n  {\n    if (!e)\n      return -1;\n\n    ARRAY_ADD(ea, e);\n  }\n\n  return ARRAY_SIZE(ea);\n}\n\n/**\n * mutt_get_virt_email - Get a virtual Email\n * @param m    Mailbox\n * @param vnum Virtual index number\n * @retval ptr  Email\n * @retval NULL No Email selected, or bad index values\n *\n * This safely gets the result of the following:\n * - `mailbox->emails[mailbox->v2r[vnum]]`\n */\nstruct Email *mutt_get_virt_email(struct Mailbox *m, int vnum)\n{\n  if (!m || !m->emails || !m->v2r)\n    return NULL;\n\n  if ((vnum < 0) || (vnum >= m->vcount))\n    return NULL;\n\n  int inum = m->v2r[vnum];\n  if ((inum < 0) || (inum >= m->msg_count))\n    return NULL;\n\n  return m->emails[inum];\n}\n\n/**\n * mview_has_limit - Is a limit active?\n * @param mv MailboxView\n * @retval true A limit is active\n * @retval false No limit is active\n */\nbool mview_has_limit(const struct MailboxView *mv)\n{\n  return mv && mv->pattern;\n}\n\n/**\n * mview_mailbox - Wrapper to get the mailbox in a MailboxView, or NULL\n * @param mv MailboxView\n * @retval ptr The mailbox in the MailboxView\n * @retval NULL MailboxView is NULL or doesn't have a mailbox\n */\nstruct Mailbox *mview_mailbox(struct MailboxView *mv)\n{\n  return mv ? mv->mailbox : NULL;\n}\n\n/**\n * top_of_thread - Find the first email in the current thread\n * @param e Current Email\n * @retval ptr  Success, email found\n * @retval NULL Error\n */\nstatic struct MuttThread *top_of_thread(struct Email *e)\n{\n  if (!e)\n    return NULL;\n\n  struct MuttThread *t = e->thread;\n\n  while (t && t->parent)\n    t = t->parent;\n\n  return t;\n}\n\n/**\n * mutt_limit_current_thread - Limit the email view to the current thread\n * @param mv Mailbox View\n * @param e  Email\n * @retval true Success\n * @retval false Failure\n */\nbool mutt_limit_current_thread(struct MailboxView *mv, struct Email *e)\n{\n  if (!mv || !mv->mailbox || !e)\n    return false;\n\n  struct Mailbox *m = mv->mailbox;\n\n  struct MuttThread *me = top_of_thread(e);\n  if (!me)\n    return false;\n\n  m->vcount = 0;\n  mv->vsize = 0;\n  mv->collapsed = false;\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    e = m->emails[i];\n    if (!e)\n      break;\n\n    e->vnum = -1;\n    e->visible = false;\n    e->collapsed = false;\n    e->num_hidden = 0;\n\n    if (top_of_thread(e) == me)\n    {\n      struct Body *body = e->body;\n\n      e->vnum = m->vcount;\n      e->visible = true;\n      m->v2r[m->vcount] = i;\n      m->vcount++;\n      mv->vsize += (body->length + body->offset - body->hdr_offset);\n    }\n  }\n  return true;\n}\n"
        },
        {
          "name": "mview.h",
          "type": "blob",
          "size": 2.8515625,
          "content": "/**\n * @file\n * View of a Mailbox\n *\n * @authors\n * Copyright (C) 2019-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MVIEW_H\n#define MUTT_MVIEW_H\n\n#include <stdbool.h>\n#include <sys/types.h>\n\nstruct Email;\nstruct EmailArray;\nstruct Mailbox;\nstruct Notify;\nstruct NotifyCallback;\n\n/**\n * struct MailboxView - View of a Mailbox\n */\nstruct MailboxView\n{\n  off_t vsize;                       ///< Size (in bytes) of the messages shown\n  char *pattern;                     ///< Limit pattern string\n  struct PatternList *limit_pattern; ///< Compiled limit pattern\n  struct ThreadsContext *threads;    ///< Threads context\n  int msg_in_pager;                  ///< Message currently shown in the pager\n\n  struct Menu *menu;                 ///< Needed for pattern compilation\n\n  bool collapsed : 1;                ///< Are all threads collapsed?\n\n  struct Mailbox *mailbox;           ///< Current Mailbox\n  struct Notify *notify;             ///< Notifications: #NotifyMview, #EventMview\n};\n\n/**\n * enum NotifyMview - Types of MailboxView Event\n *\n * Observers of #NT_MVIEW will be passed an #EventMview.\n */\nenum NotifyMview\n{\n  NT_MVIEW_ADD = 1, ///< The Mview has been opened\n  NT_MVIEW_DELETE,  ///< The Mview is about to be destroyed\n  NT_MVIEW_CHANGE,  ///< The Mview has changed\n};\n\n/**\n * struct EventMview - An Event that happened to an MailboxView\n */\nstruct EventMview\n{\n  struct MailboxView *mv; ///< The MailboxView this Event relates to\n};\n\nvoid                mview_free            (struct MailboxView **ptr);\nint                 mview_mailbox_observer(struct NotifyCallback *nc);\nstruct MailboxView *mview_new             (struct Mailbox *m, struct Notify *parent);\nvoid                mview_update          (struct MailboxView *mv);\nbool                mview_has_limit       (const struct MailboxView *mv);\nstruct Mailbox *    mview_mailbox         (struct MailboxView *mv);\n\nbool message_is_tagged(struct Email *e);\nstruct Email *mutt_get_virt_email(struct Mailbox *m, int vnum);\n\nint ea_add_tagged(struct EmailArray *ea, struct MailboxView *mv, struct Email *e, bool use_tagged);\n\nbool mutt_limit_current_thread(struct MailboxView *mv, struct Email *e);\n\n#endif /* MUTT_MVIEW_H */\n"
        },
        {
          "name": "mx.c",
          "type": "blob",
          "size": 43.1318359375,
          "content": "/**\n * @file\n * Mailbox multiplexor\n *\n * @authors\n * Copyright (C) 1996-2002,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2003 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Mehdi Abaakouk <sileht@sileht.net>\n * Copyright (C) 2018-2022 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2020 Austin Ray <austin@austinray.io>\n * Copyright (C) 2020 Reto Brunner <reto@slightlybroken.com>\n * Copyright (C) 2023-2024 Dennis Schön <mail@dennis-schoen.de>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_mx Mailbox multiplexor\n *\n * Mailbox multiplexor\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"mx.h\"\n#include \"compmbox/lib.h\"\n#include \"imap/lib.h\"\n#include \"key/lib.h\"\n#include \"maildir/lib.h\"\n#include \"mbox/lib.h\"\n#include \"menu/lib.h\"\n#include \"mh/lib.h\"\n#include \"nntp/lib.h\"\n#include \"pop/lib.h\"\n#include \"question/lib.h\"\n#include \"copy.h\"\n#include \"external.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"mutt_header.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_mailbox.h\"\n#include \"muttlib.h\"\n#include \"nntp/mdata.h\" // IWYU pragma: keep\n#include \"protos.h\"\n#ifdef USE_NOTMUCH\n#include \"notmuch/lib.h\"\n#endif\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\n/// Lookup table of mailbox types\nstatic const struct Mapping MboxTypeMap[] = {\n  // clang-format off\n  { \"mbox\",    MUTT_MBOX,    },\n  { \"MMDF\",    MUTT_MMDF,    },\n  { \"MH\",      MUTT_MH,      },\n  { \"Maildir\", MUTT_MAILDIR, },\n  { NULL, 0, },\n  // clang-format on\n};\n\n/// Data for the $mbox_type enumeration\nconst struct EnumDef MboxTypeDef = {\n  \"mbox_type\",\n  4,\n  (struct Mapping *) &MboxTypeMap,\n};\n\n/**\n * MxOps - All the Mailbox backends\n */\nstatic const struct MxOps *MxOps[] = {\n  /* These mailboxes can be recognised by their Url scheme */\n  &MxImapOps,\n#ifdef USE_NOTMUCH\n  &MxNotmuchOps,\n#endif\n  &MxPopOps,\n  &MxNntpOps,\n\n  /* Local mailboxes */\n  &MxMaildirOps,\n  &MxMboxOps,\n  &MxMhOps,\n  &MxMmdfOps,\n\n  /* If everything else fails... */\n  &MxCompOps,\n  NULL,\n};\n\n/**\n * mx_get_ops - Get mailbox operations\n * @param type Mailbox type\n * @retval ptr  Mailbox function\n * @retval NULL Error\n */\nconst struct MxOps *mx_get_ops(enum MailboxType type)\n{\n  for (const struct MxOps **ops = MxOps; *ops; ops++)\n    if ((*ops)->type == type)\n      return *ops;\n\n  return NULL;\n}\n\n/**\n * mutt_is_spool - Is this the spool_file?\n * @param str Name to check\n * @retval true It is the spool_file\n */\nstatic bool mutt_is_spool(const char *str)\n{\n  const char *const c_spool_file = cs_subset_string(NeoMutt->sub, \"spool_file\");\n  if (mutt_str_equal(str, c_spool_file))\n    return true;\n\n  struct Url *ua = url_parse(str);\n  struct Url *ub = url_parse(c_spool_file);\n\n  const bool is_spool = ua && ub && (ua->scheme == ub->scheme) &&\n                        mutt_istr_equal(ua->host, ub->host) &&\n                        mutt_istr_equal(ua->path, ub->path) &&\n                        (!ua->user || !ub->user || mutt_str_equal(ua->user, ub->user));\n\n  url_free(&ua);\n  url_free(&ub);\n  return is_spool;\n}\n\n/**\n * mx_access - Wrapper for access, checks permissions on a given mailbox\n * @param path  Path of mailbox\n * @param flags Flags, e.g. W_OK\n * @retval  0 Success, allowed\n * @retval <0 Failure, not allowed\n *\n * We may be interested in using ACL-style flags at some point, currently we\n * use the normal access() flags.\n */\nint mx_access(const char *path, int flags)\n{\n  if (imap_path_probe(path, NULL) == MUTT_IMAP)\n    return imap_access(path);\n\n  return access(path, flags);\n}\n\n/**\n * mx_open_mailbox_append - Open a mailbox for appending\n * @param m     Mailbox\n * @param flags Flags, see #OpenMailboxFlags\n * @retval true Success\n * @retval false Failure\n */\nstatic bool mx_open_mailbox_append(struct Mailbox *m, OpenMailboxFlags flags)\n{\n  if (!m)\n    return false;\n\n  struct stat st = { 0 };\n\n  m->append = true;\n  if ((m->type == MUTT_UNKNOWN) || (m->type == MUTT_MAILBOX_ERROR))\n  {\n    m->type = mx_path_probe(mailbox_path(m));\n\n    if (m->type == MUTT_UNKNOWN)\n    {\n      if (flags & (MUTT_APPEND | MUTT_NEWFOLDER))\n      {\n        m->type = MUTT_MAILBOX_ERROR;\n      }\n      else\n      {\n        mutt_error(_(\"%s is not a mailbox\"), mailbox_path(m));\n        return false;\n      }\n    }\n\n    if (m->type == MUTT_MAILBOX_ERROR)\n    {\n      if (stat(mailbox_path(m), &st) == -1)\n      {\n        if (errno == ENOENT)\n        {\n          if (mutt_comp_can_append(m))\n            m->type = MUTT_COMPRESSED;\n          else\n            m->type = cs_subset_enum(NeoMutt->sub, \"mbox_type\");\n          flags |= MUTT_APPENDNEW;\n        }\n        else\n        {\n          mutt_perror(\"%s\", mailbox_path(m));\n          return false;\n        }\n      }\n      else\n      {\n        return false;\n      }\n    }\n\n    m->mx_ops = mx_get_ops(m->type);\n  }\n\n  if (!m->mx_ops || !m->mx_ops->mbox_open_append)\n    return false;\n\n  const bool rc = m->mx_ops->mbox_open_append(m, flags);\n  m->opened++;\n  return rc;\n}\n\n/**\n * mx_mbox_ac_link - Link a Mailbox to an existing or new Account\n * @param m Mailbox to link\n * @retval true Success\n * @retval false Failure\n */\nbool mx_mbox_ac_link(struct Mailbox *m)\n{\n  if (!m)\n    return false;\n\n  if (m->account)\n    return true;\n\n  struct Account *a = mx_ac_find(m);\n  const bool new_account = !a;\n  if (new_account)\n  {\n    a = account_new(NULL, NeoMutt->sub);\n    a->type = m->type;\n  }\n  if (!mx_ac_add(a, m))\n  {\n    if (new_account)\n    {\n      account_free(&a);\n    }\n    return false;\n  }\n  if (new_account)\n  {\n    neomutt_account_add(NeoMutt, a);\n  }\n  return true;\n}\n\n/**\n * mx_mbox_open - Open a mailbox and parse it\n * @param m     Mailbox to open\n * @param flags Flags, see #OpenMailboxFlags\n * @retval true Success\n * @retval false Error\n */\nbool mx_mbox_open(struct Mailbox *m, OpenMailboxFlags flags)\n{\n  if (!m)\n    return false;\n\n  if ((m->type == MUTT_UNKNOWN) && (flags & (MUTT_NEWFOLDER | MUTT_APPEND)))\n  {\n    m->type = cs_subset_enum(NeoMutt->sub, \"mbox_type\");\n    m->mx_ops = mx_get_ops(m->type);\n  }\n\n  const bool newly_linked_account = !m->account;\n  if (newly_linked_account)\n  {\n    if (!mx_mbox_ac_link(m))\n    {\n      return false;\n    }\n  }\n\n  m->verbose = !(flags & MUTT_QUIET);\n  m->readonly = (flags & MUTT_READONLY);\n  m->peekonly = (flags & MUTT_PEEK);\n\n  if (flags & (MUTT_APPEND | MUTT_NEWFOLDER))\n  {\n    if (!mx_open_mailbox_append(m, flags))\n    {\n      goto error;\n    }\n    return true;\n  }\n\n  if (m->opened > 0)\n  {\n    m->opened++;\n    return true;\n  }\n\n  m->size = 0;\n  m->msg_unread = 0;\n  m->msg_flagged = 0;\n  m->rights = MUTT_ACL_ALL;\n\n  if (m->type == MUTT_UNKNOWN)\n  {\n    m->type = mx_path_probe(mailbox_path(m));\n    m->mx_ops = mx_get_ops(m->type);\n  }\n\n  if ((m->type == MUTT_UNKNOWN) || (m->type == MUTT_MAILBOX_ERROR) || !m->mx_ops)\n  {\n    if (m->type == MUTT_MAILBOX_ERROR)\n      mutt_perror(\"%s\", mailbox_path(m));\n    else if ((m->type == MUTT_UNKNOWN) || !m->mx_ops)\n      mutt_error(_(\"%s is not a mailbox\"), mailbox_path(m));\n    goto error;\n  }\n\n  mutt_make_label_hash(m);\n\n  /* if the user has a 'push' command in their .neomuttrc, or in a folder-hook,\n   * it will cause the progress messages not to be displayed because\n   * mutt_refresh() will think we are in the middle of a macro.  so set a\n   * flag to indicate that we should really refresh the screen.  */\n  OptForceRefresh = true;\n\n  if (m->verbose)\n    mutt_message(_(\"Reading %s...\"), mailbox_path(m));\n\n  // Clear out any existing emails\n  for (int i = 0; i < m->email_max; i++)\n  {\n    email_free(&m->emails[i]);\n  }\n\n  m->msg_count = 0;\n  m->msg_unread = 0;\n  m->msg_flagged = 0;\n  m->msg_new = 0;\n  m->msg_deleted = 0;\n  m->msg_tagged = 0;\n  m->vcount = 0;\n\n  enum MxOpenReturns rc = m->mx_ops->mbox_open(m);\n  m->opened++;\n\n  if ((rc == MX_OPEN_OK) || (rc == MX_OPEN_ABORT))\n  {\n    if ((flags & MUTT_NOSORT) == 0)\n    {\n      /* avoid unnecessary work since the mailbox is completely unthreaded\n       * to begin with */\n      OptSortSubthreads = false;\n      OptNeedRescore = false;\n    }\n    if (m->verbose)\n      mutt_clear_error();\n    if (rc == MX_OPEN_ABORT)\n    {\n      mutt_error(_(\"Reading from %s interrupted...\"), mailbox_path(m));\n    }\n  }\n  else\n  {\n    goto error;\n  }\n\n  if (!m->peekonly)\n    m->has_new = false;\n  OptForceRefresh = false;\n\n  return true;\n\nerror:\n  mx_fastclose_mailbox(m, newly_linked_account);\n  if (newly_linked_account)\n    account_mailbox_remove(m->account, m);\n  return false;\n}\n\n/**\n * mx_fastclose_mailbox - Free up memory associated with the Mailbox\n * @param m Mailbox\n * @param keep_account Make sure not to remove the mailbox's account\n */\nvoid mx_fastclose_mailbox(struct Mailbox *m, bool keep_account)\n{\n  if (!m)\n    return;\n\n  m->opened--;\n  if (m->opened != 0)\n    return;\n\n  /* never announce that a mailbox we've just left has new mail.\n   * TODO: really belongs in mx_mbox_close, but this is a nice hook point */\n  if (!m->peekonly)\n    mutt_mailbox_set_notified(m);\n\n  if (m->mx_ops)\n    m->mx_ops->mbox_close(m);\n\n  mutt_hash_free(&m->subj_hash);\n  mutt_hash_free(&m->id_hash);\n  mutt_hash_free(&m->label_hash);\n\n  if (m->emails)\n  {\n    for (int i = 0; i < m->msg_count; i++)\n    {\n      if (!m->emails[i])\n        break;\n      email_free(&m->emails[i]);\n    }\n  }\n\n  if (!m->visible)\n  {\n    mx_ac_remove(m, keep_account);\n  }\n}\n\n/**\n * sync_mailbox - Save changes to disk\n * @param m Mailbox\n * @retval enum #MxStatus\n */\nstatic enum MxStatus sync_mailbox(struct Mailbox *m)\n{\n  if (!m || !m->mx_ops || !m->mx_ops->mbox_sync)\n    return MX_STATUS_ERROR;\n\n  if (m->verbose)\n  {\n    /* L10N: Displayed before/as a mailbox is being synced */\n    mutt_message(_(\"Writing %s...\"), mailbox_path(m));\n  }\n\n  enum MxStatus rc = m->mx_ops->mbox_sync(m);\n  if (rc != MX_STATUS_OK)\n  {\n    mutt_debug(LL_DEBUG2, \"mbox_sync returned: %d\\n\", rc);\n    if ((rc == MX_STATUS_ERROR) && m->verbose)\n    {\n      /* L10N: Displayed if a mailbox sync fails */\n      mutt_error(_(\"Unable to write %s\"), mailbox_path(m));\n    }\n  }\n\n  return rc;\n}\n\n/**\n * trash_append - Move deleted mails to the trash folder\n * @param m Mailbox\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int trash_append(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct stat st = { 0 };\n  struct stat stc = { 0 };\n  int rc;\n\n  const bool c_maildir_trash = cs_subset_bool(NeoMutt->sub, \"maildir_trash\");\n  const char *const c_trash = cs_subset_string(NeoMutt->sub, \"trash\");\n  if (!c_trash || (m->msg_deleted == 0) || ((m->type == MUTT_MAILDIR) && c_maildir_trash))\n  {\n    return 0;\n  }\n\n  int delmsgcount = 0;\n  int first_del = -1;\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->deleted && !e->purge)\n    {\n      if (first_del < 0)\n        first_del = i;\n      delmsgcount++;\n    }\n  }\n\n  if (delmsgcount == 0)\n    return 0; /* nothing to be done */\n\n  /* avoid the \"append messages\" prompt */\n  const bool c_confirm_append = cs_subset_bool(NeoMutt->sub, \"confirm_append\");\n  cs_subset_str_native_set(NeoMutt->sub, \"confirm_append\", false, NULL);\n  rc = mutt_save_confirm(c_trash, &st);\n  cs_subset_str_native_set(NeoMutt->sub, \"confirm_append\", c_confirm_append, NULL);\n  if (rc != 0)\n  {\n    /* L10N: Although we know the precise number of messages, we do not show it to the user.\n       So feel free to use a \"generic plural\" as plural translation if your language has one. */\n    mutt_error(ngettext(\"message not deleted\", \"messages not deleted\", delmsgcount));\n    return -1;\n  }\n\n  if ((lstat(mailbox_path(m), &stc) == 0) && (stc.st_ino == st.st_ino) &&\n      (stc.st_dev == st.st_dev) && (stc.st_rdev == st.st_rdev))\n  {\n    return 0; /* we are in the trash folder: simple sync */\n  }\n\n  if ((m->type == MUTT_IMAP) && (imap_path_probe(c_trash, NULL) == MUTT_IMAP))\n  {\n    if (imap_fast_trash(m, c_trash) == 0)\n      return 0;\n  }\n\n  struct Mailbox *m_trash = mx_path_resolve(c_trash);\n  const bool old_append = m_trash->append;\n  if (!mx_mbox_open(m_trash, MUTT_APPEND))\n  {\n    mutt_error(_(\"Can't open trash folder\"));\n    mailbox_free(&m_trash);\n    return -1;\n  }\n\n  /* continue from initial scan above */\n  for (int i = first_del; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->deleted && !e->purge)\n    {\n      if (mutt_append_message(m_trash, m, e, NULL, MUTT_CM_NO_FLAGS, CH_NO_FLAGS) == -1)\n      {\n        mx_mbox_close(m_trash);\n        // L10N: Displayed if appending to $trash fails when syncing or closing a mailbox\n        mutt_error(_(\"Unable to append to trash folder\"));\n        m_trash->append = old_append;\n        mailbox_free(&m_trash);\n        return -1;\n      }\n    }\n  }\n\n  mx_mbox_close(m_trash);\n  m_trash->append = old_append;\n  mailbox_free(&m_trash);\n\n  return 0;\n}\n\n/**\n * mx_mbox_close - Save changes and close mailbox\n * @param m Mailbox\n * @retval enum #MxStatus\n *\n * @note The flag retvals come from a call to a backend sync function\n *\n * @note It's very important to ensure the mailbox is properly closed before\n *       free'ing the context.  For selected mailboxes, IMAP will cache the\n *       context inside connection->adata until imap_close_mailbox() removes\n *       it.  Readonly, dontwrite, and append mailboxes are guaranteed to call\n *       mx_fastclose_mailbox(), so for most of NeoMutt's code you won't see\n *       return value checks for temporary contexts.\n */\nenum MxStatus mx_mbox_close(struct Mailbox *m)\n{\n  if (!m)\n    return MX_STATUS_ERROR;\n\n  const bool c_mail_check_recent = cs_subset_bool(NeoMutt->sub, \"mail_check_recent\");\n  if (c_mail_check_recent && !m->peekonly)\n    m->has_new = false;\n\n  if (m->readonly || m->dontwrite || m->append || m->peekonly)\n  {\n    mx_fastclose_mailbox(m, false);\n    return 0;\n  }\n\n  int i, read_msgs = 0;\n  enum MxStatus rc = MX_STATUS_ERROR;\n  enum QuadOption move_messages = MUTT_NO;\n  enum QuadOption purge = MUTT_YES;\n  struct Buffer *mbox = NULL;\n  struct Buffer *buf = buf_pool_get();\n\n  if ((m->msg_unread != 0) && (m->type == MUTT_NNTP))\n  {\n    struct NntpMboxData *mdata = m->mdata;\n\n    if (mdata && mdata->adata && mdata->group)\n    {\n      enum QuadOption ans = query_quadoption(_(\"Mark all articles read?\"),\n                                             NeoMutt->sub, \"catchup_newsgroup\");\n      if (ans == MUTT_ABORT)\n        goto cleanup;\n      if (ans == MUTT_YES)\n        mutt_newsgroup_catchup(m, mdata->adata, mdata->group);\n    }\n  }\n\n  const bool c_keep_flagged = cs_subset_bool(NeoMutt->sub, \"keep_flagged\");\n  for (i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (!e->deleted && e->read && !(e->flagged && c_keep_flagged))\n      read_msgs++;\n  }\n\n  /* don't need to move articles from newsgroup */\n  if (m->type == MUTT_NNTP)\n    read_msgs = 0;\n\n  const enum QuadOption c_move = cs_subset_quad(NeoMutt->sub, \"move\");\n  if ((read_msgs != 0) && (c_move != MUTT_NO))\n  {\n    bool is_spool;\n    mbox = buf_pool_get();\n\n    char *p = mutt_find_hook(MUTT_MBOX_HOOK, mailbox_path(m));\n    if (p)\n    {\n      is_spool = true;\n      buf_strcpy(mbox, p);\n    }\n    else\n    {\n      const char *const c_mbox = cs_subset_string(NeoMutt->sub, \"mbox\");\n      buf_strcpy(mbox, c_mbox);\n      is_spool = mutt_is_spool(mailbox_path(m)) && !mutt_is_spool(buf_string(mbox));\n    }\n\n    if (is_spool && !buf_is_empty(mbox))\n    {\n      buf_expand_path(mbox);\n      buf_printf(buf,\n                 /* L10N: The first argument is the number of read messages to be\n                            moved, the second argument is the target mailbox. */\n                 ngettext(\"Move %d read message to %s?\", \"Move %d read messages to %s?\", read_msgs),\n                 read_msgs, buf_string(mbox));\n      move_messages = query_quadoption(buf_string(buf), NeoMutt->sub, \"move\");\n      if (move_messages == MUTT_ABORT)\n        goto cleanup;\n    }\n  }\n\n  /* There is no point in asking whether or not to purge if we are\n   * just marking messages as \"trash\".  */\n  const bool c_maildir_trash = cs_subset_bool(NeoMutt->sub, \"maildir_trash\");\n  if ((m->msg_deleted != 0) && !((m->type == MUTT_MAILDIR) && c_maildir_trash))\n  {\n    buf_printf(buf, ngettext(\"Purge %d deleted message?\", \"Purge %d deleted messages?\", m->msg_deleted),\n               m->msg_deleted);\n    purge = query_quadoption(buf_string(buf), NeoMutt->sub, \"delete\");\n    if (purge == MUTT_ABORT)\n      goto cleanup;\n  }\n\n  const bool c_mark_old = cs_subset_bool(NeoMutt->sub, \"mark_old\");\n  if (c_mark_old && !m->peekonly)\n  {\n    for (i = 0; i < m->msg_count; i++)\n    {\n      struct Email *e = m->emails[i];\n      if (!e)\n        break;\n      if (!e->deleted && !e->old && !e->read)\n        mutt_set_flag(m, e, MUTT_OLD, true, true);\n    }\n  }\n\n  if (move_messages)\n  {\n    if (m->verbose)\n      mutt_message(_(\"Moving read messages to %s...\"), buf_string(mbox));\n\n    /* try to use server-side copy first */\n    i = 1;\n\n    if ((m->type == MUTT_IMAP) && (imap_path_probe(buf_string(mbox), NULL) == MUTT_IMAP))\n    {\n      /* add messages for moving, and clear old tags, if any */\n      struct EmailArray ea = ARRAY_HEAD_INITIALIZER;\n      for (i = 0; i < m->msg_count; i++)\n      {\n        struct Email *e = m->emails[i];\n        if (!e)\n          break;\n\n        if (e->read && !e->deleted && !(e->flagged && c_keep_flagged))\n        {\n          e->tagged = true;\n          ARRAY_ADD(&ea, e);\n        }\n        else\n        {\n          e->tagged = false;\n        }\n      }\n\n      i = imap_copy_messages(m, &ea, buf_string(mbox), SAVE_MOVE);\n      if (i == 0)\n      {\n        const bool c_delete_untag = cs_subset_bool(NeoMutt->sub, \"delete_untag\");\n        if (c_delete_untag)\n        {\n          struct Email **ep = NULL;\n          ARRAY_FOREACH(ep, &ea)\n          {\n            mutt_set_flag(m, *ep, MUTT_TAG, false, true);\n          }\n        }\n      }\n      ARRAY_FREE(&ea);\n    }\n\n    if (i == 0) /* success */\n    {\n      mutt_clear_error();\n    }\n    else if (i == -1) /* horrible error, bail */\n    {\n      goto cleanup;\n    }\n    else /* use regular append-copy mode */\n    {\n      struct Mailbox *m_read = mx_path_resolve(buf_string(mbox));\n      if (!mx_mbox_open(m_read, MUTT_APPEND))\n      {\n        mailbox_free(&m_read);\n        goto cleanup;\n      }\n\n      for (i = 0; i < m->msg_count; i++)\n      {\n        struct Email *e = m->emails[i];\n        if (!e)\n          break;\n        if (e->read && !e->deleted && !(e->flagged && c_keep_flagged))\n        {\n          if (mutt_append_message(m_read, m, e, NULL, MUTT_CM_NO_FLAGS, CH_UPDATE_LEN) == 0)\n          {\n            mutt_set_flag(m, e, MUTT_DELETE, true, true);\n            mutt_set_flag(m, e, MUTT_PURGE, true, true);\n          }\n          else\n          {\n            mx_mbox_close(m_read);\n            goto cleanup;\n          }\n        }\n      }\n\n      mx_mbox_close(m_read);\n    }\n  }\n  else if (!m->changed && (m->msg_deleted == 0))\n  {\n    if (m->verbose)\n      mutt_message(_(\"Mailbox is unchanged\"));\n    if ((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF))\n      mbox_reset_atime(m, NULL);\n    mx_fastclose_mailbox(m, false);\n    rc = MX_STATUS_OK;\n    goto cleanup;\n  }\n\n  /* copy mails to the trash before expunging */\n  const char *const c_trash = cs_subset_string(NeoMutt->sub, \"trash\");\n  const struct Mailbox *m_trash = mx_mbox_find(m->account, c_trash);\n  if (purge && (m->msg_deleted != 0) && (m != m_trash))\n  {\n    if (trash_append(m) != 0)\n      goto cleanup;\n  }\n\n  /* allow IMAP to preserve the deleted flag across sessions */\n  if (m->type == MUTT_IMAP)\n  {\n    const enum MxStatus check = imap_sync_mailbox(m, (purge != MUTT_NO), true);\n    if (check == MX_STATUS_ERROR)\n    {\n      rc = check;\n      goto cleanup;\n    }\n  }\n  else\n  {\n    if (purge == MUTT_NO)\n    {\n      for (i = 0; i < m->msg_count; i++)\n      {\n        struct Email *e = m->emails[i];\n        if (!e)\n          break;\n\n        e->deleted = false;\n        e->purge = false;\n      }\n      m->msg_deleted = 0;\n    }\n\n    if (m->changed || (m->msg_deleted != 0))\n    {\n      enum MxStatus check = sync_mailbox(m);\n      if (check != MX_STATUS_OK)\n      {\n        rc = check;\n        goto cleanup;\n      }\n    }\n  }\n\n  if (m->verbose)\n  {\n    if (move_messages)\n    {\n      mutt_message(_(\"%d kept, %d moved, %d deleted\"),\n                   m->msg_count - m->msg_deleted, read_msgs, m->msg_deleted);\n    }\n    else\n    {\n      mutt_message(_(\"%d kept, %d deleted\"), m->msg_count - m->msg_deleted, m->msg_deleted);\n    }\n  }\n\n  const bool c_save_empty = cs_subset_bool(NeoMutt->sub, \"save_empty\");\n  if ((m->msg_count == m->msg_deleted) &&\n      ((m->type == MUTT_MMDF) || (m->type == MUTT_MBOX)) &&\n      !mutt_is_spool(mailbox_path(m)) && !c_save_empty)\n  {\n    mutt_file_unlink_empty(mailbox_path(m));\n  }\n\n  if ((purge == MUTT_YES) && (m->msg_deleted != 0))\n  {\n    for (i = 0; i < m->msg_count; i++)\n    {\n      struct Email *e = m->emails[i];\n      if (!e)\n        break;\n      if (e->deleted && !e->read)\n      {\n        m->msg_unread--;\n        if (!e->old)\n          m->msg_new--;\n      }\n      if (e->deleted && e->flagged)\n        m->msg_flagged--;\n    }\n  }\n\n  mx_fastclose_mailbox(m, false);\n\n  rc = MX_STATUS_OK;\n\ncleanup:\n  buf_pool_release(&mbox);\n  buf_pool_release(&buf);\n  return rc;\n}\n\n/**\n * mx_mbox_sync - Save changes to mailbox\n * @param[in]  m          Mailbox\n * @retval enum #MxStatus\n *\n * @note The flag retvals come from a call to a backend sync function\n */\nenum MxStatus mx_mbox_sync(struct Mailbox *m)\n{\n  if (!m)\n    return MX_STATUS_ERROR;\n\n  enum MxStatus rc = MX_STATUS_OK;\n  int purge = 1;\n  int msgcount, deleted;\n\n  if (m->dontwrite)\n  {\n    struct Buffer *buf = buf_pool_get();\n    struct Buffer *tmp = buf_pool_get();\n\n    if (km_expand_key(km_find_func(MENU_INDEX, OP_TOGGLE_WRITE), buf))\n      buf_printf(tmp, _(\" Press '%s' to toggle write\"), buf_string(buf));\n    else\n      buf_addstr(tmp, _(\"Use 'toggle-write' to re-enable write\"));\n\n    mutt_error(_(\"Mailbox is marked unwritable. %s\"), buf_string(tmp));\n\n    buf_pool_release(&buf);\n    buf_pool_release(&tmp);\n    return MX_STATUS_ERROR;\n  }\n  else if (m->readonly)\n  {\n    mutt_error(_(\"Mailbox is read-only\"));\n    return MX_STATUS_ERROR;\n  }\n\n  if (!m->changed && (m->msg_deleted == 0))\n  {\n    if (m->verbose)\n      mutt_message(_(\"Mailbox is unchanged\"));\n    return MX_STATUS_OK;\n  }\n\n  if (m->msg_deleted != 0)\n  {\n    char buf[128] = { 0 };\n\n    snprintf(buf, sizeof(buf),\n             ngettext(\"Purge %d deleted message?\", \"Purge %d deleted messages?\", m->msg_deleted),\n             m->msg_deleted);\n    purge = query_quadoption(buf, NeoMutt->sub, \"delete\");\n    if (purge == MUTT_ABORT)\n      return MX_STATUS_ERROR;\n    if (purge == MUTT_NO)\n    {\n      if (!m->changed)\n        return MX_STATUS_OK; /* nothing to do! */\n      /* let IMAP servers hold on to D flags */\n      if (m->type != MUTT_IMAP)\n      {\n        for (int i = 0; i < m->msg_count; i++)\n        {\n          struct Email *e = m->emails[i];\n          if (!e)\n            break;\n          e->deleted = false;\n          e->purge = false;\n        }\n        m->msg_deleted = 0;\n      }\n    }\n    mailbox_changed(m, NT_MAILBOX_UNTAG);\n  }\n\n  /* really only for IMAP - imap_sync_mailbox results in a call to\n   * ctx_update_tables, so m->msg_deleted is 0 when it comes back */\n  msgcount = m->msg_count;\n  deleted = m->msg_deleted;\n\n  const char *const c_trash = cs_subset_string(NeoMutt->sub, \"trash\");\n  const struct Mailbox *m_trash = mx_mbox_find(m->account, c_trash);\n  if (purge && (m->msg_deleted != 0) && (m != m_trash))\n  {\n    if (trash_append(m) != 0)\n      return MX_STATUS_OK;\n  }\n\n  if (m->type == MUTT_IMAP)\n    rc = imap_sync_mailbox(m, purge, false);\n  else\n    rc = sync_mailbox(m);\n  if (rc != MX_STATUS_ERROR)\n  {\n    if ((m->type == MUTT_IMAP) && !purge)\n    {\n      if (m->verbose)\n        mutt_message(_(\"Mailbox checkpointed\"));\n    }\n    else\n    {\n      if (m->verbose)\n        mutt_message(_(\"%d kept, %d deleted\"), msgcount - deleted, deleted);\n    }\n\n    mutt_sleep(0);\n\n    const bool c_save_empty = cs_subset_bool(NeoMutt->sub, \"save_empty\");\n    if ((m->msg_count == m->msg_deleted) &&\n        ((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF)) &&\n        !mutt_is_spool(mailbox_path(m)) && !c_save_empty)\n    {\n      unlink(mailbox_path(m));\n      mx_fastclose_mailbox(m, false);\n      return MX_STATUS_OK;\n    }\n\n    /* if we haven't deleted any messages, we don't need to resort\n     * ... except for certain folder formats which need \"unsorted\"\n     * sort order in order to synchronize folders.\n     *\n     * MH and maildir are safe.  mbox-style seems to need re-sorting,\n     * at least with the new threading code.  */\n    if (purge || ((m->type != MUTT_MAILDIR) && (m->type != MUTT_MH)))\n    {\n      /* IMAP does this automatically after handling EXPUNGE */\n      if (m->type != MUTT_IMAP)\n      {\n        mailbox_changed(m, NT_MAILBOX_UPDATE);\n        mailbox_changed(m, NT_MAILBOX_RESORT);\n      }\n    }\n  }\n\n  return rc;\n}\n\n/**\n * mx_msg_open_new - Open a new message\n * @param m     Destination mailbox\n * @param e     Message being copied (required for maildir support, because the filename depends on the message flags)\n * @param flags Flags, see #MsgOpenFlags\n * @retval ptr New Message\n */\nstruct Message *mx_msg_open_new(struct Mailbox *m, const struct Email *e, MsgOpenFlags flags)\n{\n  if (!m)\n    return NULL;\n\n  struct Address *p = NULL;\n  struct Message *msg = NULL;\n\n  if (!m->mx_ops || !m->mx_ops->msg_open_new)\n  {\n    mutt_debug(LL_DEBUG1, \"function unimplemented for mailbox type %d\\n\", m->type);\n    return NULL;\n  }\n\n  msg = message_new();\n  msg->write = true;\n\n  if (e)\n  {\n    msg->flags.flagged = e->flagged;\n    msg->flags.replied = e->replied;\n    msg->flags.read = e->read;\n    msg->flags.draft = (flags & MUTT_SET_DRAFT);\n    msg->received = e->received;\n  }\n\n  if (msg->received == 0)\n    msg->received = mutt_date_now();\n\n  if (m->mx_ops->msg_open_new(m, msg, e))\n  {\n    if (m->type == MUTT_MMDF)\n      fputs(MMDF_SEP, msg->fp);\n\n    if (((m->type == MUTT_MBOX) || (m->type == MUTT_MMDF)) && (flags & MUTT_ADD_FROM))\n    {\n      if (e)\n      {\n        p = TAILQ_FIRST(&e->env->return_path);\n        if (!p)\n          p = TAILQ_FIRST(&e->env->sender);\n        if (!p)\n          p = TAILQ_FIRST(&e->env->from);\n      }\n\n      // Use C locale for the date, so that day/month names are in English\n      char buf[64] = { 0 };\n      mutt_date_localtime_format_locale(buf, sizeof(buf), \"%a %b %e %H:%M:%S %Y\",\n                                        msg->received, NeoMutt->time_c_locale);\n      fprintf(msg->fp, \"From %s %s\\n\", p ? buf_string(p->mailbox) : NONULL(Username), buf);\n    }\n  }\n  else\n  {\n    message_free(&msg);\n  }\n\n  return msg;\n}\n\n/**\n * mx_mbox_check - Check for new mail - Wrapper for MxOps::mbox_check()\n * @param m          Mailbox\n * @retval enum #MxStatus\n */\nenum MxStatus mx_mbox_check(struct Mailbox *m)\n{\n  if (!m || !m->mx_ops)\n    return MX_STATUS_ERROR;\n\n  const short c_mail_check = cs_subset_number(NeoMutt->sub, \"mail_check\");\n\n  time_t t = mutt_date_now();\n  if ((t - m->last_checked) < c_mail_check)\n    return MX_STATUS_OK;\n\n  m->last_checked = t;\n\n  enum MxStatus rc = m->mx_ops->mbox_check(m);\n  if ((rc == MX_STATUS_NEW_MAIL) || (rc == MX_STATUS_REOPENED))\n  {\n    mailbox_changed(m, NT_MAILBOX_INVALID);\n  }\n\n  return rc;\n}\n\n/**\n * mx_msg_open - Return a stream pointer for a message\n * @param m Mailbox\n * @param e Email\n * @retval ptr  Message\n * @retval NULL Error\n */\nstruct Message *mx_msg_open(struct Mailbox *m, struct Email *e)\n{\n  if (!m || !e)\n    return NULL;\n\n  if (!m->mx_ops || !m->mx_ops->msg_open)\n  {\n    mutt_debug(LL_DEBUG1, \"function not implemented for mailbox type %d\\n\", m->type);\n    return NULL;\n  }\n\n  struct Message *msg = message_new();\n  if (!m->mx_ops->msg_open(m, msg, e))\n    message_free(&msg);\n\n  return msg;\n}\n\n/**\n * mx_msg_commit - Commit a message to a folder - Wrapper for MxOps::msg_commit()\n * @param m   Mailbox\n * @param msg Message to commit\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mx_msg_commit(struct Mailbox *m, struct Message *msg)\n{\n  if (!m || !m->mx_ops || !m->mx_ops->msg_commit || !msg)\n    return -1;\n\n  if (!(msg->write && m->append))\n  {\n    mutt_debug(LL_DEBUG1, \"msg->write = %d, m->append = %d\\n\", msg->write, m->append);\n    return -1;\n  }\n\n  return m->mx_ops->msg_commit(m, msg);\n}\n\n/**\n * mx_msg_close - Close a message\n * @param[in]  m   Mailbox\n * @param[out] ptr Message to close\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mx_msg_close(struct Mailbox *m, struct Message **ptr)\n{\n  if (!m || !ptr || !*ptr)\n    return 0;\n\n  int rc = 0;\n  struct Message *msg = *ptr;\n\n  if (m->mx_ops && m->mx_ops->msg_close)\n    rc = m->mx_ops->msg_close(m, msg);\n\n  if (msg->path)\n  {\n    mutt_debug(LL_DEBUG1, \"unlinking %s\\n\", msg->path);\n    unlink(msg->path);\n  }\n\n  message_free(ptr);\n  return rc;\n}\n\n/**\n * mx_alloc_memory - Create storage for the emails\n * @param m        Mailbox\n * @param req_size Space required\n */\nvoid mx_alloc_memory(struct Mailbox *m, int req_size)\n{\n  if ((req_size + 1) <= m->email_max)\n    return;\n\n  // Step size to increase by\n  // Larger mailboxes get a larger step (limited to 1000)\n  const int grow = CLAMP(m->email_max, 25, 1000);\n\n  // Sanity checks\n  req_size = ROUND_UP(req_size + 1, grow);\n\n  const size_t s = MAX(sizeof(struct Email *), sizeof(int));\n  if ((req_size * s) < (m->email_max * s))\n  {\n    mutt_error(\"%s\", strerror(ENOMEM));\n    mutt_exit(1);\n  }\n\n  if (m->emails)\n  {\n    MUTT_MEM_REALLOC(&m->emails, req_size, struct Email *);\n    MUTT_MEM_REALLOC(&m->v2r, req_size, int);\n  }\n  else\n  {\n    m->emails = MUTT_MEM_CALLOC(req_size, struct Email *);\n    m->v2r = MUTT_MEM_CALLOC(req_size, int);\n  }\n\n  for (int i = m->email_max; i < req_size; i++)\n  {\n    m->emails[i] = NULL;\n    m->v2r[i] = -1;\n  }\n\n  m->email_max = req_size;\n}\n\n/**\n * mx_path_is_empty - Is the mailbox empty\n * @param path Mailbox to check\n * @retval 1 Mailbox is empty\n * @retval 0 Mailbox contains mail\n * @retval -1 Error\n */\nint mx_path_is_empty(struct Buffer *path)\n{\n  if (buf_is_empty(path))\n    return -1;\n\n  enum MailboxType type = mx_path_probe(buf_string(path));\n  const struct MxOps *ops = mx_get_ops(type);\n  if (!ops || !ops->path_is_empty)\n    return -1;\n\n  return ops->path_is_empty(path);\n}\n\n/**\n * mx_tags_edit - Start the tag editor of the mailbox\n * @param m      Mailbox\n * @param tags   Existing tags\n * @param buf    Buffer for the results\n * @retval -1 Error\n * @retval 0  No valid user input\n * @retval 1  Buffer set\n */\nint mx_tags_edit(struct Mailbox *m, const char *tags, struct Buffer *buf)\n{\n  if (!m || !buf)\n    return -1;\n\n  if (m->mx_ops->tags_edit)\n    return m->mx_ops->tags_edit(m, tags, buf);\n\n  mutt_message(_(\"Folder doesn't support tagging, aborting\"));\n  return -1;\n}\n\n/**\n * mx_tags_commit - Save tags to the Mailbox - Wrapper for MxOps::tags_commit()\n * @param m    Mailbox\n * @param e    Email\n * @param tags Tags to save\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mx_tags_commit(struct Mailbox *m, struct Email *e, const char *tags)\n{\n  if (!m || !e || !tags)\n    return -1;\n\n  if (m->mx_ops->tags_commit)\n    return m->mx_ops->tags_commit(m, e, tags);\n\n  mutt_message(_(\"Folder doesn't support tagging, aborting\"));\n  return -1;\n}\n\n/**\n * mx_tags_is_supported - Return true if mailbox support tagging\n * @param m Mailbox\n * @retval true Tagging is supported\n */\nbool mx_tags_is_supported(struct Mailbox *m)\n{\n  return m && m->mx_ops->tags_commit && m->mx_ops->tags_edit;\n}\n\n/**\n * mx_path_probe - Find a mailbox that understands a path\n * @param path Path to examine\n * @retval enum MailboxType, e.g. #MUTT_IMAP\n */\nenum MailboxType mx_path_probe(const char *path)\n{\n  if (!path)\n    return MUTT_UNKNOWN;\n\n  enum MailboxType rc = MUTT_UNKNOWN;\n\n  // First, search the non-local Mailbox types (is_local == false)\n  for (const struct MxOps **ops = MxOps; *ops; ops++)\n  {\n    if ((*ops)->is_local)\n      continue;\n    rc = (*ops)->path_probe(path, NULL);\n    if (rc != MUTT_UNKNOWN)\n      return rc;\n  }\n\n  struct stat st = { 0 };\n  if (stat(path, &st) != 0)\n  {\n    mutt_debug(LL_DEBUG1, \"unable to stat %s: %s (errno %d)\\n\", path, strerror(errno), errno);\n    return MUTT_UNKNOWN;\n  }\n\n  if (S_ISFIFO(st.st_mode))\n  {\n    mutt_error(_(\"Can't open %s: it is a pipe\"), path);\n    return MUTT_UNKNOWN;\n  }\n\n  // Next, search the local Mailbox types (is_local == true)\n  for (const struct MxOps **ops = MxOps; *ops; ops++)\n  {\n    if (!(*ops)->is_local)\n      continue;\n    rc = (*ops)->path_probe(path, &st);\n    if (rc != MUTT_UNKNOWN)\n      return rc;\n  }\n\n  return rc;\n}\n\n/**\n * mx_path_canon - Canonicalise a mailbox path - Wrapper for MxOps::path_canon()\n */\nint mx_path_canon(struct Buffer *path, const char *folder, enum MailboxType *type)\n{\n  if (buf_is_empty(path))\n    return -1;\n\n  for (size_t i = 0; i < 3; i++)\n  {\n    /* Look for !! ! - < > or ^ followed by / or NUL */\n    if ((buf_at(path, 0) == '!') && (buf_at(path, 1) == '!'))\n    {\n      if (((buf_at(path, 2) == '/') || (buf_at(path, 2) == '\\0')))\n      {\n        buf_inline_replace(path, 0, 2, LastFolder);\n      }\n    }\n    else if ((buf_at(path, 0) == '+') || (buf_at(path, 0) == '='))\n    {\n      size_t folder_len = mutt_str_len(folder);\n      if ((folder_len > 0) && (folder[folder_len - 1] != '/'))\n      {\n        path->data[0] = '/';\n        buf_inline_replace(path, 0, 0, folder);\n      }\n      else\n      {\n        buf_inline_replace(path, 0, 1, folder);\n      }\n    }\n    else if ((buf_at(path, 1) == '/') || (buf_at(path, 1) == '\\0'))\n    {\n      if (buf_at(path, 0) == '!')\n      {\n        const char *const c_spool_file = cs_subset_string(NeoMutt->sub, \"spool_file\");\n        buf_inline_replace(path, 0, 1, c_spool_file);\n      }\n      else if (buf_at(path, 0) == '-')\n      {\n        buf_inline_replace(path, 0, 1, LastFolder);\n      }\n      else if (buf_at(path, 0) == '<')\n      {\n        const char *const c_record = cs_subset_string(NeoMutt->sub, \"record\");\n        buf_inline_replace(path, 0, 1, c_record);\n      }\n      else if (buf_at(path, 0) == '>')\n      {\n        const char *const c_mbox = cs_subset_string(NeoMutt->sub, \"mbox\");\n        buf_inline_replace(path, 0, 1, c_mbox);\n      }\n      else if (buf_at(path, 0) == '^')\n      {\n        buf_inline_replace(path, 0, 1, CurrentFolder);\n      }\n      else if (buf_at(path, 0) == '~')\n      {\n        buf_inline_replace(path, 0, 1, HomeDir);\n      }\n    }\n    else if (buf_at(path, 0) == '@')\n    {\n      /* elm compatibility, @ expands alias to user name */\n      struct AddressList *al = alias_lookup(buf_string(path));\n      if (!al || TAILQ_EMPTY(al))\n        break;\n\n      struct Email *e = email_new();\n      e->env = mutt_env_new();\n      mutt_addrlist_copy(&e->env->from, al, false);\n      mutt_addrlist_copy(&e->env->to, al, false);\n      mutt_default_save(path, e);\n      email_free(&e);\n      break;\n    }\n    else\n    {\n      break;\n    }\n  }\n\n  // if (!folder) //XXX - use inherited version, or pass NULL to backend?\n  //   return -1;\n\n  enum MailboxType type2 = mx_path_probe(buf_string(path));\n  if (type)\n    *type = type2;\n  const struct MxOps *ops = mx_get_ops(type2);\n  if (!ops || !ops->path_canon)\n    return -1;\n\n  if (ops->path_canon(path) < 0)\n  {\n    mutt_path_canon(path, HomeDir, true);\n  }\n\n  return 0;\n}\n\n/**\n * mx_path_canon2 - Canonicalise the path to realpath\n * @param m      Mailbox\n * @param folder Path to canonicalise\n * @retval  0 Success\n * @retval -1 Failure\n */\nint mx_path_canon2(struct Mailbox *m, const char *folder)\n{\n  if (!m)\n    return -1;\n\n  struct Buffer *path = buf_pool_get();\n\n  if (m->realpath)\n    buf_strcpy(path, m->realpath);\n  else\n    buf_strcpy(path, mailbox_path(m));\n\n  int rc = mx_path_canon(path, folder, &m->type);\n\n  mutt_str_replace(&m->realpath, buf_string(path));\n  buf_pool_release(&path);\n\n  if (rc >= 0)\n  {\n    m->mx_ops = mx_get_ops(m->type);\n    buf_strcpy(&m->pathbuf, m->realpath);\n  }\n\n  return rc;\n}\n\n/**\n * mx_msg_padding_size - Bytes of padding between messages - Wrapper for MxOps::msg_padding_size()\n * @param m Mailbox\n * @retval num Number of bytes of padding\n *\n * mmdf and mbox add separators, which leads a small discrepancy when computing\n * vsize for a limited view.\n */\nint mx_msg_padding_size(struct Mailbox *m)\n{\n  if (!m || !m->mx_ops || !m->mx_ops->msg_padding_size)\n    return 0;\n\n  return m->mx_ops->msg_padding_size(m);\n}\n\n/**\n * mx_ac_find - Find the Account owning a Mailbox\n * @param m Mailbox\n * @retval ptr  Account\n * @retval NULL None found\n */\nstruct Account *mx_ac_find(struct Mailbox *m)\n{\n  if (!m || !m->mx_ops || !m->realpath)\n    return NULL;\n\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != m->type)\n      continue;\n\n    if (m->mx_ops->ac_owns_path(np, m->realpath))\n      return np;\n  }\n\n  return NULL;\n}\n\n/**\n * mx_mbox_find - Find a Mailbox on an Account\n * @param a    Account to search\n * @param path Path to find\n * @retval ptr Mailbox\n */\nstruct Mailbox *mx_mbox_find(struct Account *a, const char *path)\n{\n  if (!a || !path)\n    return NULL;\n\n  struct MailboxNode *np = NULL;\n  struct Url *url_p = NULL;\n  struct Url *url_a = NULL;\n\n  const bool use_url = (a->type == MUTT_IMAP);\n  if (use_url)\n  {\n    url_p = url_parse(path);\n    if (!url_p)\n      goto done;\n  }\n\n  STAILQ_FOREACH(np, &a->mailboxes, entries)\n  {\n    if (!use_url)\n    {\n      if (mutt_str_equal(np->mailbox->realpath, path))\n        return np->mailbox;\n      continue;\n    }\n\n    url_free(&url_a);\n    url_a = url_parse(np->mailbox->realpath);\n    if (!url_a)\n      continue;\n\n    if (!mutt_istr_equal(url_a->host, url_p->host))\n      continue;\n    if (url_p->user && !mutt_istr_equal(url_a->user, url_p->user))\n      continue;\n    if (a->type == MUTT_IMAP)\n    {\n      if (imap_mxcmp(url_a->path, url_p->path) == 0)\n        break;\n    }\n    else\n    {\n      if (mutt_str_equal(url_a->path, url_p->path))\n        break;\n    }\n  }\n\ndone:\n  url_free(&url_p);\n  url_free(&url_a);\n\n  if (!np)\n    return NULL;\n  return np->mailbox;\n}\n\n/**\n * mx_mbox_find2 - Find a Mailbox on an Account\n * @param path Path to find\n * @retval ptr  Mailbox\n * @retval NULL No match\n */\nstruct Mailbox *mx_mbox_find2(const char *path)\n{\n  if (!path)\n    return NULL;\n\n  struct Buffer *buf = buf_new(path);\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  mx_path_canon(buf, c_folder, NULL);\n\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    struct Mailbox *m = mx_mbox_find(np, buf_string(buf));\n    if (m)\n    {\n      buf_free(&buf);\n      return m;\n    }\n  }\n\n  buf_free(&buf);\n  return NULL;\n}\n\n/**\n * mx_path_resolve - Get a Mailbox for a path\n * @param path Mailbox path\n * @retval ptr Mailbox\n *\n * If there isn't a Mailbox for the path, one will be created.\n */\nstruct Mailbox *mx_path_resolve(const char *path)\n{\n  if (!path)\n    return NULL;\n\n  struct Mailbox *m = mx_mbox_find2(path);\n  if (m)\n    return m;\n\n  m = mailbox_new();\n  buf_strcpy(&m->pathbuf, path);\n  const char *const c_folder = cs_subset_string(NeoMutt->sub, \"folder\");\n  mx_path_canon2(m, c_folder);\n\n  return m;\n}\n\n/**\n * mx_mbox_find_by_name_ac - Find a Mailbox with given name under an Account\n * @param a    Account to search\n * @param name Name to find\n * @retval ptr Mailbox\n */\nstatic struct Mailbox *mx_mbox_find_by_name_ac(struct Account *a, const char *name)\n{\n  if (!a || !name)\n    return NULL;\n\n  struct MailboxNode *np = NULL;\n\n  STAILQ_FOREACH(np, &a->mailboxes, entries)\n  {\n    if (mutt_str_equal(np->mailbox->name, name))\n      return np->mailbox;\n  }\n\n  return NULL;\n}\n\n/**\n * mx_mbox_find_by_name - Find a Mailbox with given name\n * @param name Name to search\n * @retval ptr Mailbox\n */\nstatic struct Mailbox *mx_mbox_find_by_name(const char *name)\n{\n  if (!name)\n    return NULL;\n\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    struct Mailbox *m = mx_mbox_find_by_name_ac(np, name);\n    if (m)\n      return m;\n  }\n\n  return NULL;\n}\n\n/**\n * mx_resolve - Get a Mailbox from either a path or name\n * @param path_or_name Mailbox path or name\n * @retval ptr         Mailbox\n *\n * Order of resolving:\n *  1. Name\n *  2. Path\n */\nstruct Mailbox *mx_resolve(const char *path_or_name)\n{\n  if (!path_or_name)\n    return NULL;\n\n  // Order is name first because you can create a Mailbox from\n  // a path, but can't from a name. So fallback behavior creates\n  // a new Mailbox for us.\n  struct Mailbox *m = mx_mbox_find_by_name(path_or_name);\n  if (!m)\n    m = mx_path_resolve(path_or_name);\n\n  return m;\n}\n\n/**\n * mx_ac_add - Add a Mailbox to an Account - Wrapper for MxOps::ac_add()\n */\nbool mx_ac_add(struct Account *a, struct Mailbox *m)\n{\n  if (!a || !m || !m->mx_ops || !m->mx_ops->ac_add)\n    return false;\n\n  return m->mx_ops->ac_add(a, m) && account_mailbox_add(a, m);\n}\n\n/**\n * mx_ac_remove - Remove a Mailbox from an Account and delete Account if empty\n * @param m Mailbox to remove\n * @param keep_account Make sure not to remove the mailbox's account\n * @retval  0 Success\n * @retval -1 Error\n *\n * @note The mailbox is NOT free'd\n */\nint mx_ac_remove(struct Mailbox *m, bool keep_account)\n{\n  if (!m || !m->account)\n    return -1;\n\n  struct Account *a = m->account;\n  account_mailbox_remove(m->account, m);\n  if (!keep_account && STAILQ_EMPTY(&a->mailboxes))\n  {\n    neomutt_account_remove(NeoMutt, a);\n  }\n  return 0;\n}\n\n/**\n * mx_mbox_check_stats - Check the statistics for a mailbox - Wrapper for MxOps::mbox_check_stats()\n *\n * @note Emits: #NT_MAILBOX_CHANGE\n */\nenum MxStatus mx_mbox_check_stats(struct Mailbox *m, uint8_t flags)\n{\n  if (!m)\n    return MX_STATUS_ERROR;\n\n  enum MxStatus rc = m->mx_ops->mbox_check_stats(m, flags);\n  if (rc != MX_STATUS_ERROR)\n  {\n    struct EventMailbox ev_m = { m };\n    notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);\n  }\n\n  return rc;\n}\n\n/**\n * mx_save_hcache - Save message to the header cache - Wrapper for MxOps::msg_save_hcache()\n * @param m Mailbox\n * @param e Email\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Write a single header out to the header cache.\n */\nint mx_save_hcache(struct Mailbox *m, struct Email *e)\n{\n  if (!m || !m->mx_ops || !m->mx_ops->msg_save_hcache || !e)\n    return 0;\n\n  return m->mx_ops->msg_save_hcache(m, e);\n}\n\n/**\n * mx_type - Return the type of the Mailbox\n * @param m Mailbox\n * @retval enum #MailboxType\n */\nenum MailboxType mx_type(struct Mailbox *m)\n{\n  return m ? m->type : MUTT_MAILBOX_ERROR;\n}\n\n/**\n * mx_toggle_write - Toggle the mailbox's readonly flag\n * @param m Mailbox\n * @retval  0 Success\n * @retval -1 Error\n */\nint mx_toggle_write(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  if (m->readonly)\n  {\n    mutt_error(_(\"Can't toggle write on a readonly mailbox\"));\n    return -1;\n  }\n\n  if (m->dontwrite)\n  {\n    m->dontwrite = false;\n    mutt_message(_(\"Changes to folder will be written on folder exit\"));\n  }\n  else\n  {\n    m->dontwrite = true;\n    mutt_message(_(\"Changes to folder will not be written\"));\n  }\n\n  struct EventMailbox ev_m = { m };\n  notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);\n  return 0;\n}\n"
        },
        {
          "name": "mx.h",
          "type": "blob",
          "size": 3.763671875,
          "content": "/**\n * @file\n * API for mailboxes\n *\n * @authors\n * Copyright (C) 1996-2002,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2002 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_MX_H\n#define MUTT_MX_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct Email;\n\nextern const struct EnumDef MboxTypeDef;\n\ntypedef uint8_t MsgOpenFlags;      ///< Flags for mx_msg_open_new(), e.g. #MUTT_ADD_FROM\n#define MUTT_MSG_NO_FLAGS       0  ///< No flags are set\n#define MUTT_ADD_FROM     (1 << 0) ///< add a From_ line\n#define MUTT_SET_DRAFT    (1 << 1) ///< set the message draft flag\n\n/* Wrappers for the Mailbox API, see MxOps */\nenum MxStatus        mx_mbox_check        (struct Mailbox *m);\nenum MxStatus        mx_mbox_check_stats  (struct Mailbox *m, uint8_t flags);\nenum MxStatus        mx_mbox_close        (struct Mailbox *m);\nbool                 mx_mbox_open         (struct Mailbox *m, OpenMailboxFlags flags);\nenum MxStatus        mx_mbox_sync         (struct Mailbox *m);\nint                  mx_msg_close         (struct Mailbox *m, struct Message **ptr);\nint                  mx_msg_commit        (struct Mailbox *m, struct Message *msg);\nstruct Message *     mx_msg_open_new      (struct Mailbox *m, const struct Email *e, MsgOpenFlags flags);\nstruct Message *     mx_msg_open          (struct Mailbox *m, struct Email *e);\nint                  mx_msg_padding_size  (struct Mailbox *m);\nint                  mx_save_hcache       (struct Mailbox *m, struct Email *e);\nint                  mx_path_canon        (struct Buffer *path, const char *folder, enum MailboxType *type);\nint                  mx_path_canon2       (struct Mailbox *m, const char *folder);\nenum MailboxType     mx_path_probe        (const char *path);\nstruct Mailbox *     mx_path_resolve      (const char *path);\nstruct Mailbox *     mx_resolve           (const char *path_or_name);\nint                  mx_tags_commit       (struct Mailbox *m, struct Email *e, const char *tags);\nint                  mx_tags_edit         (struct Mailbox *m, const char *tags, struct Buffer *buf);\nenum MailboxType     mx_type              (struct Mailbox *m);\n\nstruct Account *     mx_ac_find           (struct Mailbox *m);\nstruct Mailbox *     mx_mbox_find         (struct Account *a, const char *path);\nstruct Mailbox *     mx_mbox_find2        (const char *path);\nbool                 mx_mbox_ac_link      (struct Mailbox *m);\nbool                 mx_ac_add            (struct Account *a, struct Mailbox *m);\nint                  mx_ac_remove         (struct Mailbox *m, bool keep_account);\n\nint                  mx_access            (const char *path, int flags);\nvoid                 mx_alloc_memory      (struct Mailbox *m, int req_size);\nint                  mx_path_is_empty     (struct Buffer *path);\nvoid                 mx_fastclose_mailbox (struct Mailbox *m, bool keep_account);\nconst struct MxOps * mx_get_ops           (enum MailboxType type);\nbool                 mx_tags_is_supported (struct Mailbox *m);\nint                  mx_toggle_write      (struct Mailbox *m);\n\n#endif /* MUTT_MX_H */\n"
        },
        {
          "name": "ncrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "nntp",
          "type": "tree",
          "content": null
        },
        {
          "name": "notmuch",
          "type": "tree",
          "content": null
        },
        {
          "name": "pager",
          "type": "tree",
          "content": null
        },
        {
          "name": "parse",
          "type": "tree",
          "content": null
        },
        {
          "name": "pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "pgpewrap.c",
          "type": "blob",
          "size": 1.072265625,
          "content": "/**\n * @file\n * Standalone tool to manipulate a program's command line\n *\n * C version by Wessel Dankers <wsl@fruit.eu.org>\n *\n * This code is in the public domain.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nstatic void print_usage(const char *progname)\n{\n  fprintf(stderr, \"Command line usage: %s [flags] -- prefix [recipients]\\n\", progname);\n  exit(1);\n}\n\nint main(int argc, char **argv)\n{\n  char **opts = NULL, **opt = NULL;\n  char *pfx = NULL;\n\n  if (argc < 2)\n  {\n    print_usage((argc != 0) ? argv[0] : \"pgpewrap\");\n  }\n\n  opts = malloc((2 * argc + 1) * sizeof(*opts));\n  if (!opts)\n  {\n    perror(argv[0]);\n    exit(2);\n  }\n\n  opt = opts;\n  *opt++ = argv[1];\n  pfx = NULL;\n\n  for (int i = 2; i < argc;)\n  {\n    if (strcmp(argv[i], \"--\") == 0)\n    {\n      i += 2;\n      if (i > argc)\n      {\n        free(opts);\n        print_usage(argv[0]);\n      }\n      pfx = argv[i - 1];\n    }\n    if (pfx)\n      *opt++ = pfx;\n    *opt++ = argv[i++];\n  }\n  *opt = NULL;\n\n  execvp(opts[0], opts);\n  perror(argv[0]);\n  free(opts);\n  return 2;\n}\n"
        },
        {
          "name": "po",
          "type": "tree",
          "content": null
        },
        {
          "name": "pop",
          "type": "tree",
          "content": null
        },
        {
          "name": "postpone",
          "type": "tree",
          "content": null
        },
        {
          "name": "progress",
          "type": "tree",
          "content": null
        },
        {
          "name": "protos.h",
          "type": "blob",
          "size": 2.201171875,
          "content": "/**\n * @file\n * Prototypes for many functions\n *\n * @authors\n * Copyright (C) 1996-2000,2007,2010,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2013 Karel Zak <kzak@redhat.com>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_PROTOS_H\n#define MUTT_PROTOS_H\n\n#include \"config.h\"\n#include <stdbool.h>\n#include \"mutt.h\"\n#include \"menu/lib.h\"\n\nstruct Buffer;\nstruct Email;\nstruct EmailArray;\nstruct Mailbox;\nstruct NotifyCallback;\n\n/**\n * enum XdgType - XDG variable types\n */\nenum XdgType\n{\n  XDG_CONFIG_HOME, ///< XDG home dir: ~/.config\n  XDG_CONFIG_DIRS, ///< XDG system dir: /etc/xdg\n};\n\n/**\n * enum EvMessage - Edit or View a message\n */\nenum EvMessage\n{\n  EVM_VIEW, ///< View the message\n  EVM_EDIT, ///< Edit the message\n};\n\nint mutt_ev_message(struct Mailbox *m, struct EmailArray *ea, enum EvMessage action);\n\nint mutt_system(const char *cmd);\n\nint mutt_set_xdg_path(enum XdgType type, struct Buffer *buf);\nvoid mutt_help(enum MenuType menu);\nvoid mutt_set_flag(struct Mailbox *m, struct Email *e, enum MessageType flag, bool bf, bool upd_mbox);\nvoid mutt_signal_init(void);\nvoid mutt_emails_set_flag(struct Mailbox *m, struct EmailArray *ea, enum MessageType flag, bool bf);\nint mw_change_flag(struct Mailbox *m, struct EmailArray *ea, bool bf);\n\nint mutt_thread_set_flag(struct Mailbox *m, struct Email *e, enum MessageType flag, bool bf, bool subthread);\nextern short PostCount;\n\n#ifndef HAVE_WCSCASECMP\nint wcscasecmp(const wchar_t *a, const wchar_t *b);\n#endif\n\nint mutt_reply_observer(struct NotifyCallback *nc);\n\n#endif /* MUTT_PROTOS_H */\n"
        },
        {
          "name": "question",
          "type": "tree",
          "content": null
        },
        {
          "name": "recvcmd.c",
          "type": "blob",
          "size": 29.556640625,
          "content": "/**\n * @file\n * Send/reply with an attachment\n *\n * @authors\n * Copyright (C) 1999-2004 Thomas Roessler <roessler@does-not-exist.org>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2019-2023 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2023 Leon Philman\n * Copyright (C) 2023-2024 Tóth János <gomba007@gmail.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_recvcmd Send/reply with an attachment\n *\n * Send/reply with an attachment\n */\n\n#include \"config.h\"\n#include <locale.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"alias/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"recvcmd.h\"\n#include \"attach/lib.h\"\n#include \"editor/lib.h\"\n#include \"expando/lib.h\"\n#include \"history/lib.h\"\n#include \"index/lib.h\"\n#include \"question/lib.h\"\n#include \"send/lib.h\"\n#include \"copy.h\"\n#include \"globals.h\"\n#include \"handler.h\"\n#include \"mutt_body.h\"\n#include \"mutt_logging.h\"\n#include \"protos.h\"\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\n/**\n * check_msg - Are we working with an RFC822 message\n * @param b   Body of email\n * @param err If true, display a message if this isn't an RFC822 message\n * @retval true This is an RFC822 message\n *\n * some helper functions to verify that we are exclusively operating on\n * message/rfc822 attachments\n */\nstatic bool check_msg(struct Body *b, bool err)\n{\n  if (!mutt_is_message_type(b->type, b->subtype))\n  {\n    if (err)\n      mutt_error(_(\"You may only bounce message/rfc822 parts\"));\n    return false;\n  }\n  return true;\n}\n\n/**\n * check_all_msg - Are all the Attachments RFC822 messages?\n * @param actx Attachment context\n * @param b    Current message\n * @param err  If true, report errors\n * @retval true All parts are RFC822 messages\n */\nstatic bool check_all_msg(struct AttachCtx *actx, struct Body *b, bool err)\n{\n  if (b && !check_msg(b, err))\n    return false;\n  if (!b)\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        if (!check_msg(actx->idx[i]->body, err))\n          return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * check_can_decode - Can we decode all tagged attachments?\n * @param actx Attachment context\n * @param b    Body of email\n * @retval true All tagged attachments are decodable\n */\nstatic bool check_can_decode(struct AttachCtx *actx, struct Body *b)\n{\n  if (b)\n    return mutt_can_decode(b);\n\n  for (short i = 0; i < actx->idxlen; i++)\n    if (actx->idx[i]->body->tagged && !mutt_can_decode(actx->idx[i]->body))\n      return false;\n\n  return true;\n}\n\n/**\n * count_tagged - Count the number of tagged attachments\n * @param actx Attachment context\n * @retval num Number of tagged attachments\n */\nstatic short count_tagged(struct AttachCtx *actx)\n{\n  short count = 0;\n  for (short i = 0; i < actx->idxlen; i++)\n    if (actx->idx[i]->body->tagged)\n      count++;\n\n  return count;\n}\n\n/**\n * count_tagged_children - Tagged children below a multipart/message attachment\n * @param actx Attachment context\n * @param i    Index of first attachment\n * @retval num Number of tagged attachments\n */\nstatic short count_tagged_children(struct AttachCtx *actx, short i)\n{\n  short level = actx->idx[i]->level;\n  short count = 0;\n\n  while ((++i < actx->idxlen) && (level < actx->idx[i]->level))\n    if (actx->idx[i]->body->tagged)\n      count++;\n\n  return count;\n}\n\n/**\n * attach_bounce_message - Bounce function, from the attachment menu\n * @param m    Mailbox\n * @param fp   Handle of message\n * @param actx Attachment context\n * @param b    Body of email\n */\nvoid attach_bounce_message(struct Mailbox *m, FILE *fp, struct AttachCtx *actx,\n                           struct Body *b)\n{\n  if (!m || !fp || !actx)\n    return;\n\n  if (!check_all_msg(actx, b, true))\n    return;\n\n  struct AddressList al = TAILQ_HEAD_INITIALIZER(al);\n  struct Buffer *prompt = buf_pool_get();\n  struct Buffer *buf = buf_pool_get();\n\n  /* RFC5322 mandates a From: header, so warn before bouncing\n   * messages without one */\n  if (b)\n  {\n    if (TAILQ_EMPTY(&b->email->env->from))\n    {\n      mutt_error(_(\"Warning: message contains no From: header\"));\n      mutt_clear_error();\n    }\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        if (TAILQ_EMPTY(&actx->idx[i]->body->email->env->from))\n        {\n          mutt_error(_(\"Warning: message contains no From: header\"));\n          mutt_clear_error();\n          break;\n        }\n      }\n    }\n  }\n\n  /* one or more messages? */\n  int num_msg = b ? 1 : count_tagged(actx);\n  if (num_msg == 1)\n    buf_strcpy(prompt, _(\"Bounce message to: \"));\n  else\n    buf_strcpy(prompt, _(\"Bounce tagged messages to: \"));\n\n  if ((mw_get_field(buf_string(prompt), buf, MUTT_COMP_NO_FLAGS, HC_ALIAS,\n                    &CompleteAliasOps, NULL) != 0) ||\n      buf_is_empty(buf))\n  {\n    goto done;\n  }\n\n  mutt_addrlist_parse(&al, buf_string(buf));\n  if (TAILQ_EMPTY(&al))\n  {\n    mutt_error(_(\"Error parsing address\"));\n    goto done;\n  }\n\n  mutt_expand_aliases(&al);\n\n  char *err = NULL;\n  if (mutt_addrlist_to_intl(&al, &err) < 0)\n  {\n    mutt_error(_(\"Bad IDN: '%s'\"), err);\n    FREE(&err);\n    goto done;\n  }\n\n  buf_reset(buf);\n  buf_alloc(buf, 8192);\n  mutt_addrlist_write(&al, buf, true);\n\n  buf_printf(prompt, ngettext(\"Bounce message to %s?\", \"Bounce messages to %s?\", num_msg),\n             buf_string(buf));\n\n  if (query_quadoption(buf_string(prompt), NeoMutt->sub, \"bounce\") != MUTT_YES)\n  {\n    msgwin_clear_text(NULL);\n    mutt_message(ngettext(\"Message not bounced\", \"Messages not bounced\", num_msg));\n    goto done;\n  }\n\n  msgwin_clear_text(NULL);\n\n  int rc = 0;\n  if (b)\n  {\n    rc = mutt_bounce_message(fp, m, b->email, &al, NeoMutt->sub);\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        if (mutt_bounce_message(actx->idx[i]->fp, m, actx->idx[i]->body->email,\n                                &al, NeoMutt->sub))\n        {\n          rc = 1;\n        }\n      }\n    }\n  }\n\n  if (rc == 0)\n    mutt_message(ngettext(\"Message bounced\", \"Messages bounced\", num_msg));\n  else\n    mutt_error(ngettext(\"Error bouncing message\", \"Error bouncing messages\", num_msg));\n\ndone:\n  mutt_addrlist_clear(&al);\n  buf_pool_release(&buf);\n  buf_pool_release(&prompt);\n}\n\n/**\n * mutt_attach_resend - Resend-message, from the attachment menu\n * @param fp   File containing email\n * @param m    Current mailbox\n * @param actx Attachment context\n * @param b    Attachment\n */\nvoid mutt_attach_resend(FILE *fp, struct Mailbox *m, struct AttachCtx *actx, struct Body *b)\n{\n  if (!check_all_msg(actx, b, true))\n    return;\n\n  if (b)\n  {\n    mutt_resend_message(fp, m, b->email, NeoMutt->sub);\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        mutt_resend_message(actx->idx[i]->fp, m, actx->idx[i]->body->email,\n                            NeoMutt->sub);\n      }\n    }\n  }\n}\n\n/**\n * find_common_parent - Find a common parent message for the tagged attachments\n * @param actx    Attachment context\n * @param nattach Number of tagged attachments\n * @retval ptr Parent attachment\n * @retval NULL Failure, no common parent\n */\nstatic struct AttachPtr *find_common_parent(struct AttachCtx *actx, short nattach)\n{\n  short i;\n  short nchildren;\n\n  for (i = 0; i < actx->idxlen; i++)\n    if (actx->idx[i]->body->tagged)\n      break;\n\n  while (--i >= 0)\n  {\n    if (mutt_is_message_type(actx->idx[i]->body->type, actx->idx[i]->body->subtype))\n    {\n      nchildren = count_tagged_children(actx, i);\n      if (nchildren == nattach)\n        return actx->idx[i];\n    }\n  }\n\n  return NULL;\n}\n\n/**\n * is_parent - Check whether one attachment is the parent of another\n * @param i    Index of parent Attachment\n * @param actx Attachment context\n * @param b    Potential child Attachment\n * @retval true Attachment\n *\n * check whether attachment i is a parent of the attachment pointed to by b\n *\n * @note This and the calling procedure could be optimized quite a bit.\n *       For now, it's not worth the effort.\n */\nstatic int is_parent(short i, struct AttachCtx *actx, const struct Body *b)\n{\n  short level = actx->idx[i]->level;\n\n  while ((++i < actx->idxlen) && (actx->idx[i]->level > level))\n  {\n    if (actx->idx[i]->body == b)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * find_parent - Find the parent of an Attachment\n * @param actx    Attachment context\n * @param b       Attachment (OPTIONAL)\n * @param nattach Use the nth attachment\n * @retval ptr  Parent attachment\n * @retval NULL No parent exists\n */\nstatic struct AttachPtr *find_parent(struct AttachCtx *actx, struct Body *b, short nattach)\n{\n  struct AttachPtr *parent = NULL;\n\n  if (b)\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (mutt_is_message_type(actx->idx[i]->body->type, actx->idx[i]->body->subtype) &&\n          is_parent(i, actx, b))\n      {\n        parent = actx->idx[i];\n      }\n      if (actx->idx[i]->body == b)\n        break;\n    }\n  }\n  else if (nattach)\n  {\n    parent = find_common_parent(actx, nattach);\n  }\n\n  return parent;\n}\n\n/**\n * include_header - Write an email header to a file, optionally quoting it\n * @param quote  If true, prefix the lines\n * @param fp_in  File to read from\n * @param e      Email\n * @param fp_out File to write to\n * @param prefix Prefix for each line (OPTIONAL)\n */\nstatic void include_header(bool quote, FILE *fp_in, struct Email *e,\n                           FILE *fp_out, const char *prefix)\n{\n  CopyHeaderFlags chflags = CH_DECODE;\n  struct Buffer *prefix2 = buf_pool_get();\n\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n  if (c_weed)\n    chflags |= CH_WEED | CH_REORDER;\n\n  if (quote)\n  {\n    const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n    if (prefix)\n    {\n      buf_strcpy(prefix2, prefix);\n    }\n    else if (!c_text_flowed)\n    {\n      const char *const c_attribution_locale = cs_subset_string(NeoMutt->sub, \"attribution_locale\");\n      const struct Expando *c_indent_string = cs_subset_expando(NeoMutt->sub, \"indent_string\");\n      setlocale(LC_TIME, NONULL(c_attribution_locale));\n      mutt_make_string(prefix2, -1, c_indent_string, NULL, -1, e, MUTT_FORMAT_NO_FLAGS, NULL);\n      setlocale(LC_TIME, \"\");\n    }\n    else\n    {\n      buf_strcpy(prefix2, \">\");\n    }\n\n    chflags |= CH_PREFIX;\n  }\n\n  mutt_copy_header(fp_in, e, fp_out, chflags, quote ? buf_string(prefix2) : NULL, 0);\n  buf_pool_release(&prefix2);\n}\n\n/**\n * copy_problematic_attachments - Attach the body parts which can't be decoded\n * @param[out] last  Body pointer to update\n * @param[in]  actx  Attachment context\n * @param[in]  force If true, attach parts that can't be decoded\n * @retval ptr Pointer to last Body part\n *\n * This code is shared by forwarding and replying.\n */\nstatic struct Body **copy_problematic_attachments(struct Body **last,\n                                                  struct AttachCtx *actx, bool force)\n{\n  for (short i = 0; i < actx->idxlen; i++)\n  {\n    if (actx->idx[i]->body->tagged && (force || !mutt_can_decode(actx->idx[i]->body)))\n    {\n      if (mutt_body_copy(actx->idx[i]->fp, last, actx->idx[i]->body) == -1)\n        return NULL; /* XXXXX - may lead to crashes */\n      last = &((*last)->next);\n    }\n  }\n  return last;\n}\n\n/**\n * attach_forward_bodies - Forward one or several MIME bodies\n * @param fp      File to read from\n * @param e       Email\n * @param actx    Attachment Context\n * @param b       Body of email\n * @param nattach Number of tagged attachments\n *\n * (non-message types)\n */\nstatic void attach_forward_bodies(FILE *fp, struct Email *e, struct AttachCtx *actx,\n                                  struct Body *b, short nattach)\n{\n  bool mime_fwd_all = false;\n  bool mime_fwd_any = true;\n  struct Email *e_parent = NULL;\n  FILE *fp_parent = NULL;\n  enum QuadOption ans = MUTT_NO;\n  struct Buffer *tempfile = NULL;\n  struct Buffer *prefix = buf_pool_get();\n\n  /* First, find the parent message.\n   * Note: This could be made an option by just\n   * putting the following lines into an if block.  */\n  struct AttachPtr *parent = find_parent(actx, b, nattach);\n  if (parent)\n  {\n    e_parent = parent->body->email;\n    fp_parent = parent->fp;\n  }\n  else\n  {\n    e_parent = e;\n    fp_parent = actx->fp_root;\n  }\n\n  struct Email *e_tmp = email_new();\n  e_tmp->env = mutt_env_new();\n  mutt_make_forward_subject(e_tmp->env, e_parent, NeoMutt->sub);\n\n  tempfile = buf_pool_get();\n  buf_mktemp(tempfile);\n  FILE *fp_tmp = mutt_file_fopen(buf_string(tempfile), \"w\");\n  if (!fp_tmp)\n  {\n    mutt_error(_(\"Can't open temporary file %s\"), buf_string(tempfile));\n    email_free(&e_tmp);\n    goto bail;\n  }\n\n  mutt_forward_intro(e_parent, fp_tmp, NeoMutt->sub);\n\n  /* prepare the prefix here since we'll need it later. */\n\n  const bool c_forward_quote = cs_subset_bool(NeoMutt->sub, \"forward_quote\");\n  if (c_forward_quote)\n  {\n    const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n    if (c_text_flowed)\n    {\n      buf_strcpy(prefix, \">\");\n    }\n    else\n    {\n      const char *const c_attribution_locale = cs_subset_string(NeoMutt->sub, \"attribution_locale\");\n      const struct Expando *c_indent_string = cs_subset_expando(NeoMutt->sub, \"indent_string\");\n      setlocale(LC_TIME, NONULL(c_attribution_locale));\n      mutt_make_string(prefix, -1, c_indent_string, NULL, -1, e_parent,\n                       MUTT_FORMAT_NO_FLAGS, NULL);\n      setlocale(LC_TIME, \"\");\n    }\n  }\n\n  include_header(c_forward_quote, fp_parent, e_parent, fp_tmp, buf_string(prefix));\n\n  /* Now, we have prepared the first part of the message body: The\n   * original message's header.\n   *\n   * The next part is more interesting: either include the message bodies,\n   * or attach them.  */\n  if ((!b || mutt_can_decode(b)) &&\n      ((ans = query_quadoption(_(\"Forward as attachments?\"), NeoMutt->sub, \"mime_forward\")) == MUTT_YES))\n  {\n    mime_fwd_all = true;\n  }\n  else if (ans == MUTT_ABORT)\n  {\n    goto bail;\n  }\n\n  /* shortcut MIMEFWDREST when there is only one attachment.\n   * Is this intuitive?  */\n  if (!mime_fwd_all && !b && (nattach > 1) && !check_can_decode(actx, b))\n  {\n    ans = query_quadoption(_(\"Can't decode all tagged attachments.  MIME-forward the others?\"),\n                           NeoMutt->sub, \"mime_forward_rest\");\n    if (ans == MUTT_ABORT)\n      goto bail;\n    else if (ans == MUTT_NO)\n      mime_fwd_any = false;\n  }\n\n  /* initialize a state structure */\n\n  struct State state = { 0 };\n  if (c_forward_quote)\n    state.prefix = buf_string(prefix);\n  state.flags = STATE_CHARCONV;\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n  if (c_weed)\n    state.flags |= STATE_WEED;\n  state.fp_out = fp_tmp;\n\n  /* where do we append new MIME parts? */\n  struct Body **last = &e_tmp->body;\n\n  if (b)\n  {\n    /* single body case */\n\n    if (!mime_fwd_all && mutt_can_decode(b))\n    {\n      state.fp_in = fp;\n      mutt_body_handler(b, &state);\n      state_putc(&state, '\\n');\n    }\n    else\n    {\n      if (mutt_body_copy(fp, last, b) == -1)\n        goto bail;\n    }\n  }\n  else\n  {\n    /* multiple body case */\n\n    if (!mime_fwd_all)\n    {\n      for (int i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged && mutt_can_decode(actx->idx[i]->body))\n        {\n          state.fp_in = actx->idx[i]->fp;\n          mutt_body_handler(actx->idx[i]->body, &state);\n          state_putc(&state, '\\n');\n        }\n      }\n    }\n\n    if (mime_fwd_any && !copy_problematic_attachments(last, actx, mime_fwd_all))\n      goto bail;\n  }\n\n  mutt_forward_trailer(e_parent, fp_tmp, NeoMutt->sub);\n\n  mutt_file_fclose(&fp_tmp);\n  fp_tmp = NULL;\n\n  /* now that we have the template, send it. */\n  struct EmailArray ea = ARRAY_HEAD_INITIALIZER;\n  ARRAY_ADD(&ea, e_parent);\n  mutt_send_message(SEND_NO_FLAGS, e_tmp, buf_string(tempfile), NULL, &ea,\n                    NeoMutt->sub);\n  ARRAY_FREE(&ea);\n  buf_pool_release(&tempfile);\n  buf_pool_release(&prefix);\n  return;\n\nbail:\n  if (fp_tmp)\n  {\n    mutt_file_fclose(&fp_tmp);\n    mutt_file_unlink(buf_string(tempfile));\n  }\n  buf_pool_release(&tempfile);\n  buf_pool_release(&prefix);\n\n  email_free(&e_tmp);\n}\n\n/**\n * attach_forward_msgs - Forward one or several message-type attachments\n * @param fp    File handle to attachment\n * @param actx  Attachment Context\n * @param b     Attachment to forward (OPTIONAL)\n * @param flags Send mode, see #SendFlags\n *\n * This is different from the previous function since we want to mimic the\n * index menu's behavior.\n *\n * Code reuse from mutt_send_message() is not possible here. It relies on a\n * context structure to find messages, while, on the attachment menu, messages\n * are referenced through the attachment index.\n */\nstatic void attach_forward_msgs(FILE *fp, struct AttachCtx *actx, struct Body *b, SendFlags flags)\n{\n  struct Email *e_cur = NULL;\n  struct Email *e_tmp = NULL;\n  enum QuadOption ans;\n  struct Body **last = NULL;\n  struct Buffer *tempfile = NULL;\n  FILE *fp_tmp = NULL;\n\n  CopyHeaderFlags chflags = CH_DECODE;\n\n  if (b)\n  {\n    e_cur = b->email;\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        e_cur = actx->idx[i]->body->email;\n        break;\n      }\n    }\n  }\n\n  e_tmp = email_new();\n  e_tmp->env = mutt_env_new();\n  mutt_make_forward_subject(e_tmp->env, e_cur, NeoMutt->sub);\n\n  tempfile = buf_pool_get();\n\n  ans = query_quadoption(_(\"Forward MIME encapsulated?\"), NeoMutt->sub, \"mime_forward\");\n  if (ans == MUTT_NO)\n  {\n    /* no MIME encapsulation */\n\n    buf_mktemp(tempfile);\n    fp_tmp = mutt_file_fopen(buf_string(tempfile), \"w\");\n    if (!fp_tmp)\n    {\n      mutt_error(_(\"Can't create %s\"), buf_string(tempfile));\n      goto cleanup;\n    }\n\n    CopyMessageFlags cmflags = MUTT_CM_NO_FLAGS;\n    const bool c_forward_quote = cs_subset_bool(NeoMutt->sub, \"forward_quote\");\n    if (c_forward_quote)\n    {\n      chflags |= CH_PREFIX;\n      cmflags |= MUTT_CM_PREFIX;\n    }\n\n    const bool c_forward_decode = cs_subset_bool(NeoMutt->sub, \"forward_decode\");\n    if (c_forward_decode)\n    {\n      cmflags |= MUTT_CM_DECODE | MUTT_CM_CHARCONV;\n      const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n      if (c_weed)\n      {\n        chflags |= CH_WEED | CH_REORDER;\n        cmflags |= MUTT_CM_WEED;\n      }\n    }\n\n    if (b)\n    {\n      mutt_forward_intro(b->email, fp_tmp, NeoMutt->sub);\n      mutt_copy_message_fp(fp_tmp, fp, b->email, cmflags, chflags, 0);\n      mutt_forward_trailer(b->email, fp_tmp, NeoMutt->sub);\n    }\n    else\n    {\n      for (short i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged)\n        {\n          mutt_forward_intro(actx->idx[i]->body->email, fp_tmp, NeoMutt->sub);\n          mutt_copy_message_fp(fp_tmp, actx->idx[i]->fp,\n                               actx->idx[i]->body->email, cmflags, chflags, 0);\n          mutt_forward_trailer(actx->idx[i]->body->email, fp_tmp, NeoMutt->sub);\n        }\n      }\n    }\n    mutt_file_fclose(&fp_tmp);\n  }\n  else if (ans == MUTT_YES) /* do MIME encapsulation - we don't need to do much here */\n  {\n    last = &e_tmp->body;\n    if (b)\n    {\n      mutt_body_copy(fp, last, b);\n    }\n    else\n    {\n      for (short i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged)\n        {\n          mutt_body_copy(actx->idx[i]->fp, last, actx->idx[i]->body);\n          last = &((*last)->next);\n        }\n      }\n    }\n  }\n  else\n  {\n    email_free(&e_tmp);\n  }\n\n  struct EmailArray ea = ARRAY_HEAD_INITIALIZER;\n  ARRAY_ADD(&ea, e_cur);\n  mutt_send_message(flags, e_tmp, buf_is_empty(tempfile) ? NULL : buf_string(tempfile),\n                    NULL, &ea, NeoMutt->sub);\n  ARRAY_FREE(&ea);\n  e_tmp = NULL; /* mutt_send_message frees this */\n\ncleanup:\n  email_free(&e_tmp);\n  buf_pool_release(&tempfile);\n}\n\n/**\n * mutt_attach_forward - Forward an Attachment\n * @param fp    Handle to the attachment\n * @param e     Email\n * @param actx  Attachment Context\n * @param b     Current message\n * @param flags Send mode, see #SendFlags\n */\nvoid mutt_attach_forward(FILE *fp, struct Email *e, struct AttachCtx *actx,\n                         struct Body *b, SendFlags flags)\n{\n  if (check_all_msg(actx, b, false))\n  {\n    attach_forward_msgs(fp, actx, b, flags);\n  }\n  else\n  {\n    const short nattach = count_tagged(actx);\n    attach_forward_bodies(fp, e, actx, b, nattach);\n  }\n}\n\n/**\n * attach_reply_envelope_defaults - Create the envelope defaults for a reply\n * @param env    Envelope to fill in\n * @param actx   Attachment Context\n * @param parent Parent Email\n * @param flags  Flags, see #SendFlags\n * @retval  0 Success\n * @retval -1 Error\n *\n * This function can be invoked in two ways.\n *\n * Either, parent is NULL.  In this case, all tagged bodies are of a message type,\n * and the header information is fetched from them.\n *\n * Or, parent is non-NULL.  In this case, cur is the common parent of all the\n * tagged attachments.\n *\n * Note that this code is horribly similar to envelope_defaults() from send.c.\n */\nstatic int attach_reply_envelope_defaults(struct Envelope *env, struct AttachCtx *actx,\n                                          struct Email *parent, SendFlags flags)\n{\n  struct Envelope *curenv = NULL;\n  struct Email *e = NULL;\n\n  if (parent)\n  {\n    curenv = parent->env;\n    e = parent;\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        e = actx->idx[i]->body->email;\n        curenv = e->env;\n        break;\n      }\n    }\n  }\n\n  if (!curenv || !e)\n  {\n    mutt_error(_(\"Can't find any tagged messages\"));\n    return -1;\n  }\n\n  if ((flags & SEND_NEWS))\n  {\n    /* in case followup set Newsgroups: with Followup-To: if it present */\n    if (!env->newsgroups && curenv && !mutt_istr_equal(curenv->followup_to, \"poster\"))\n    {\n      env->newsgroups = mutt_str_dup(curenv->followup_to);\n    }\n  }\n  else\n  {\n    if (parent)\n    {\n      if (mutt_fetch_recips(env, curenv, flags, NeoMutt->sub) == -1)\n        return -1;\n    }\n    else\n    {\n      for (short i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged &&\n            (mutt_fetch_recips(env, actx->idx[i]->body->email->env, flags,\n                               NeoMutt->sub) == -1))\n        {\n          return -1;\n        }\n      }\n    }\n\n    if ((flags & SEND_LIST_REPLY) && TAILQ_EMPTY(&env->to))\n    {\n      mutt_error(_(\"No mailing lists found\"));\n      return -1;\n    }\n\n    mutt_fix_reply_recipients(env, NeoMutt->sub);\n  }\n  mutt_make_misc_reply_headers(env, curenv, NeoMutt->sub);\n\n  if (parent)\n  {\n    mutt_add_to_reference_headers(env, curenv, NeoMutt->sub);\n  }\n  else\n  {\n    for (short i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged)\n      {\n        mutt_add_to_reference_headers(env, actx->idx[i]->body->email->env,\n                                      NeoMutt->sub);\n      }\n    }\n  }\n\n  return 0;\n}\n\n/**\n * attach_include_reply - This is _very_ similar to send.c's include_reply()\n * @param fp     File handle to attachment\n * @param fp_tmp File handle to temporary file\n * @param e      Email\n */\nstatic void attach_include_reply(FILE *fp, FILE *fp_tmp, struct Email *e)\n{\n  CopyMessageFlags cmflags = MUTT_CM_PREFIX | MUTT_CM_DECODE | MUTT_CM_CHARCONV;\n  CopyHeaderFlags chflags = CH_DECODE;\n\n  mutt_make_attribution_intro(e, fp_tmp, NeoMutt->sub);\n\n  const bool c_header = cs_subset_bool(NeoMutt->sub, \"header\");\n  if (!c_header)\n    cmflags |= MUTT_CM_NOHEADER;\n  const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n  if (c_weed)\n  {\n    chflags |= CH_WEED;\n    cmflags |= MUTT_CM_WEED;\n  }\n\n  mutt_copy_message_fp(fp_tmp, fp, e, cmflags, chflags, 0);\n  mutt_make_attribution_trailer(e, fp_tmp, NeoMutt->sub);\n}\n\n/**\n * mutt_attach_reply - Attach a reply\n * @param fp    File handle to reply\n * @param m     Mailbox\n * @param e     Email\n * @param actx  Attachment Context\n * @param b     Current message\n * @param flags Send mode, see #SendFlags\n */\nvoid mutt_attach_reply(FILE *fp, struct Mailbox *m, struct Email *e,\n                       struct AttachCtx *actx, struct Body *b, SendFlags flags)\n{\n  bool mime_reply_any = false;\n\n  short nattach = 0;\n  struct AttachPtr *parent = NULL;\n  struct Email *e_parent = NULL;\n  FILE *fp_parent = NULL;\n  struct Email *e_tmp = NULL;\n  FILE *fp_tmp = NULL;\n  struct Buffer *tempfile = NULL;\n  struct EmailArray ea = ARRAY_HEAD_INITIALIZER;\n\n  struct Buffer *prefix = buf_pool_get();\n\n  if (flags & SEND_NEWS)\n    OptNewsSend = true;\n  else\n    OptNewsSend = false;\n\n  if (!check_all_msg(actx, b, false))\n  {\n    nattach = count_tagged(actx);\n    parent = find_parent(actx, b, nattach);\n    if (parent)\n    {\n      e_parent = parent->body->email;\n      fp_parent = parent->fp;\n    }\n    else\n    {\n      e_parent = e;\n      fp_parent = actx->fp_root;\n    }\n  }\n\n  if ((nattach > 1) && !check_can_decode(actx, b))\n  {\n    const enum QuadOption ans = query_quadoption(_(\"Can't decode all tagged attachments.  MIME-encapsulate the others?\"),\n                                                 NeoMutt->sub, \"mime_forward_rest\");\n    if (ans == MUTT_ABORT)\n      goto cleanup;\n    if (ans == MUTT_YES)\n      mime_reply_any = true;\n  }\n  else if (nattach == 1)\n  {\n    mime_reply_any = true;\n  }\n\n  e_tmp = email_new();\n  e_tmp->env = mutt_env_new();\n\n  if (attach_reply_envelope_defaults(e_tmp->env, actx,\n                                     e_parent ? e_parent : (b ? b->email : NULL),\n                                     flags) == -1)\n  {\n    goto cleanup;\n  }\n\n  tempfile = buf_pool_get();\n  buf_mktemp(tempfile);\n  fp_tmp = mutt_file_fopen(buf_string(tempfile), \"w\");\n  if (!fp_tmp)\n  {\n    mutt_error(_(\"Can't create %s\"), buf_string(tempfile));\n    goto cleanup;\n  }\n\n  if (e_parent)\n  {\n    mutt_make_attribution_intro(e_parent, fp_tmp, NeoMutt->sub);\n\n    struct State state = { 0 };\n    state.fp_out = fp_tmp;\n\n    const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n    if (c_text_flowed)\n    {\n      buf_strcpy(prefix, \">\");\n    }\n    else\n    {\n      const char *const c_attribution_locale = cs_subset_string(NeoMutt->sub, \"attribution_locale\");\n      const struct Expando *c_indent_string = cs_subset_expando(NeoMutt->sub, \"indent_string\");\n      setlocale(LC_TIME, NONULL(c_attribution_locale));\n      mutt_make_string(prefix, -1, c_indent_string, m, -1, e_parent,\n                       MUTT_FORMAT_NO_FLAGS, NULL);\n      setlocale(LC_TIME, \"\");\n    }\n\n    state.prefix = buf_string(prefix);\n    state.flags = STATE_CHARCONV;\n\n    const bool c_weed = cs_subset_bool(NeoMutt->sub, \"weed\");\n    if (c_weed)\n      state.flags |= STATE_WEED;\n\n    const bool c_header = cs_subset_bool(NeoMutt->sub, \"header\");\n    if (c_header)\n      include_header(true, fp_parent, e_parent, fp_tmp, buf_string(prefix));\n\n    if (b)\n    {\n      if (mutt_can_decode(b))\n      {\n        state.fp_in = fp;\n        mutt_body_handler(b, &state);\n        state_putc(&state, '\\n');\n      }\n      else\n      {\n        mutt_body_copy(fp, &e_tmp->body, b);\n      }\n    }\n    else\n    {\n      for (short i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged && mutt_can_decode(actx->idx[i]->body))\n        {\n          state.fp_in = actx->idx[i]->fp;\n          mutt_body_handler(actx->idx[i]->body, &state);\n          state_putc(&state, '\\n');\n        }\n      }\n    }\n\n    mutt_make_attribution_trailer(e_parent, fp_tmp, NeoMutt->sub);\n\n    if (mime_reply_any && !b && !copy_problematic_attachments(&e_tmp->body, actx, false))\n    {\n      goto cleanup;\n    }\n  }\n  else\n  {\n    if (b)\n    {\n      attach_include_reply(fp, fp_tmp, b->email);\n    }\n    else\n    {\n      for (short i = 0; i < actx->idxlen; i++)\n      {\n        if (actx->idx[i]->body->tagged)\n          attach_include_reply(actx->idx[i]->fp, fp_tmp, actx->idx[i]->body->email);\n      }\n    }\n  }\n\n  mutt_file_fclose(&fp_tmp);\n\n  ARRAY_ADD(&ea, e_parent ? e_parent : (b ? b->email : NULL));\n  if (mutt_send_message(flags, e_tmp, buf_string(tempfile), NULL, &ea, NeoMutt->sub) == 0)\n  {\n    mutt_set_flag(m, e, MUTT_REPLIED, true, true);\n  }\n  e_tmp = NULL; /* mutt_send_message frees this */\n\ncleanup:\n  if (fp_tmp)\n  {\n    mutt_file_fclose(&fp_tmp);\n    mutt_file_unlink(buf_string(tempfile));\n  }\n  buf_pool_release(&tempfile);\n  buf_pool_release(&prefix);\n  email_free(&e_tmp);\n  ARRAY_FREE(&ea);\n}\n\n/**\n * mutt_attach_mail_sender - Compose an email to the sender in the email attachment\n * @param actx Attachment Context\n * @param b    Current attachment\n */\nvoid mutt_attach_mail_sender(struct AttachCtx *actx, struct Body *b)\n{\n  if (!check_all_msg(actx, b, 0))\n  {\n    /* L10N: You will see this error message if you invoke <compose-to-sender>\n       when you are on a normal attachment.  */\n    mutt_error(_(\"You may only compose to sender with message/rfc822 parts\"));\n    return;\n  }\n\n  struct Email *e_tmp = email_new();\n  e_tmp->env = mutt_env_new();\n\n  if (b)\n  {\n    if (mutt_fetch_recips(e_tmp->env, b->email->env, SEND_TO_SENDER, NeoMutt->sub) == -1)\n    {\n      email_free(&e_tmp);\n      return;\n    }\n  }\n  else\n  {\n    for (int i = 0; i < actx->idxlen; i++)\n    {\n      if (actx->idx[i]->body->tagged &&\n          (mutt_fetch_recips(e_tmp->env, actx->idx[i]->body->email->env,\n                             SEND_TO_SENDER, NeoMutt->sub) == -1))\n      {\n        email_free(&e_tmp);\n        return;\n      }\n    }\n  }\n\n  // This call will free e_tmp for us\n  mutt_send_message(SEND_NO_FLAGS, e_tmp, NULL, NULL, NULL, NeoMutt->sub);\n}\n"
        },
        {
          "name": "recvcmd.h",
          "type": "blob",
          "size": 1.4501953125,
          "content": "/**\n * @file\n * Send/reply with an attachment\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_RECVCMD_H\n#define MUTT_RECVCMD_H\n\n#include <stdio.h>\n#include \"send/lib.h\"\n\nstruct AttachCtx;\nstruct Body;\nstruct Email;\nstruct Mailbox;\n\nvoid attach_bounce_message  (struct Mailbox *m, FILE *fp, struct AttachCtx *actx, struct Body *b);\nvoid mutt_attach_resend     (FILE *fp, struct Mailbox *m, struct AttachCtx *actx, struct Body *b);\nvoid mutt_attach_forward    (FILE *fp, struct Email *e, struct AttachCtx *actx, struct Body *b, SendFlags flags);\nvoid mutt_attach_reply      (FILE *fp, struct Mailbox *m, struct Email *e, struct AttachCtx *actx, struct Body *b, SendFlags flags);\nvoid mutt_attach_mail_sender(struct AttachCtx *actx, struct Body *b);\n\n#endif /* MUTT_RECVCMD_H */\n"
        },
        {
          "name": "rfc3676.c",
          "type": "blob",
          "size": 14.6240234375,
          "content": "/**\n * @file\n * RFC3676 Format Flowed routines\n *\n * @authors\n * Copyright (C) 2005 Andreas Krennmair <ak@synflood.at>\n * Copyright (C) 2005 Peter J. Holzer <hjp@hjp.net>\n * Copyright (C) 2005-2009 Rocco Rutte <pdmef@gmx.net>\n * Copyright (C) 2010 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Federico Kircheis <federico.kircheis@gmail.com>\n * Copyright (C) 2020 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_rfc3676 RFC3676 Format Flowed routines\n *\n * RFC3676 Format Flowed routines\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"gui/lib.h\"\n#include \"rfc3676.h\"\n\n#define FLOWED_MAX 72\n\n/**\n * struct FlowedState - State of a Format-Flowed line of text\n */\nstruct FlowedState\n{\n  size_t width;\n  size_t spaces;\n  bool delsp;\n};\n\n/**\n * get_quote_level - Get the quote level of a line\n * @param line Text to examine\n * @retval num Quote level\n */\nstatic int get_quote_level(const char *line)\n{\n  int quoted = 0;\n  const char *p = line;\n\n  while (p && (*p == '>'))\n  {\n    quoted++;\n    p++;\n  }\n\n  return quoted;\n}\n\n/**\n * space_quotes - Should we add spaces between quote levels\n * @param state State to use\n * @retval true Spaces should be added\n *\n * Determines whether to add spacing between/after each quote level:\n * `   >>>foo`\n * becomes\n * `   > > > foo`\n */\nstatic int space_quotes(struct State *state)\n{\n  /* Allow quote spacing in the pager even for `$text_flowed`,\n   * but obviously not when replying.  */\n  const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n  if (c_text_flowed && (state->flags & STATE_REPLYING))\n    return 0;\n\n  const bool c_reflow_space_quotes = cs_subset_bool(NeoMutt->sub, \"reflow_space_quotes\");\n  return c_reflow_space_quotes;\n}\n\n/**\n * add_quote_suffix - Should we add a trailing space to quotes\n * @param state State to use\n * @param ql    Quote level\n * @retval true Spaces should be added\n *\n * Determines whether to add a trailing space to quotes:\n * `   >>> foo`\n * as opposed to\n * `   >>>foo`\n */\nstatic bool add_quote_suffix(struct State *state, int ql)\n{\n  if (state->flags & STATE_REPLYING)\n    return false;\n\n  if (space_quotes(state))\n    return false;\n\n  if (!ql && !state->prefix)\n    return false;\n\n  /* The prefix will add its own space */\n  const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n  if (!c_text_flowed && !ql && state->prefix)\n    return false;\n\n  return true;\n}\n\n/**\n * print_indent - Print indented text\n * @param ql         Quote level\n * @param state      State to work with\n * @param add_suffix If true, write a trailing space character\n * @retval num Number of characters written\n */\nstatic size_t print_indent(int ql, struct State *state, int add_suffix)\n{\n  size_t wid = 0;\n\n  if (state->prefix)\n  {\n    /* use given prefix only for format=fixed replies to format=flowed,\n     * for format=flowed replies to format=flowed, use '>' indentation */\n    const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n    if (c_text_flowed)\n    {\n      ql++;\n    }\n    else\n    {\n      state_puts(state, state->prefix);\n      wid = mutt_strwidth(state->prefix);\n    }\n  }\n  for (int i = 0; i < ql; i++)\n  {\n    state_putc(state, '>');\n    if (space_quotes(state))\n      state_putc(state, ' ');\n  }\n  if (add_suffix)\n    state_putc(state, ' ');\n\n  if (space_quotes(state))\n    ql *= 2;\n\n  return ql + add_suffix + wid;\n}\n\n/**\n * flush_par - Write out the paragraph\n * @param state State to work with\n * @param fst   State of the flowed text\n */\nstatic void flush_par(struct State *state, struct FlowedState *fst)\n{\n  if (fst->width > 0)\n  {\n    state_putc(state, '\\n');\n    fst->width = 0;\n  }\n  fst->spaces = 0;\n}\n\n/**\n * quote_width - Calculate the paragraph width based upon the quote level\n * @param state State to use\n * @param ql    Quote level\n * @retval num Paragraph width\n *\n * The start of a quoted line will be \">>> \", so we need to subtract the space\n * required for the prefix from the terminal width.\n */\nstatic int quote_width(struct State *state, int ql)\n{\n  const int screen_width = (state->flags & STATE_DISPLAY) ? state->wraplen : 80;\n  const short c_reflow_wrap = cs_subset_number(NeoMutt->sub, \"reflow_wrap\");\n  int width = mutt_window_wrap_cols(screen_width, c_reflow_wrap);\n  const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n  if (c_text_flowed && (state->flags & STATE_REPLYING))\n  {\n    /* When replying, force a wrap at FLOWED_MAX to comply with RFC3676\n     * guidelines */\n    if (width > FLOWED_MAX)\n      width = FLOWED_MAX;\n    ql++; /* When replying, we will add an additional quote level */\n  }\n  /* adjust the paragraph width subtracting the number of prefix chars */\n  width -= space_quotes(state) ? ql * 2 : ql;\n  /* When displaying (not replying), there may be a space between the prefix\n   * string and the paragraph */\n  if (add_quote_suffix(state, ql))\n    width--;\n  /* failsafe for really long quotes */\n  if (width <= 0)\n    width = FLOWED_MAX; /* arbitrary, since the line will wrap */\n  return width;\n}\n\n/**\n * print_flowed_line - Print a format-flowed line\n * @param line  Text to print\n * @param state State to work with\n * @param ql    Quote level\n * @param fst   State of the flowed text\n * @param term  If true, terminate with a new line\n */\nstatic void print_flowed_line(char *line, struct State *state, int ql,\n                              struct FlowedState *fst, bool term)\n{\n  size_t width, w, words = 0;\n  char *p = NULL;\n  char last;\n\n  if (!line || (*line == '\\0'))\n  {\n    /* flush current paragraph (if any) first */\n    flush_par(state, fst);\n    print_indent(ql, state, 0);\n    state_putc(state, '\\n');\n    return;\n  }\n\n  width = quote_width(state, ql);\n  last = line[mutt_str_len(line) - 1];\n\n  mutt_debug(LL_DEBUG5, \"f=f: line [%s], width = %ld, spaces = %zu\\n\", line,\n             (long) width, fst->spaces);\n\n  for (words = 0; (p = mutt_str_sep(&line, \" \"));)\n  {\n    mutt_debug(LL_DEBUG5, \"f=f: word [%s], width: %zu, remaining = [%s]\\n\", p,\n               fst->width, line);\n\n    /* remember number of spaces */\n    if (*p == '\\0')\n    {\n      mutt_debug(LL_DEBUG3, \"f=f: additional space\\n\");\n      fst->spaces++;\n      continue;\n    }\n    /* there's exactly one space prior to every but the first word */\n    if (words)\n      fst->spaces++;\n\n    w = mutt_strwidth(p);\n    /* see if we need to break the line but make sure the first word is put on\n     * the line regardless; if for DelSp=yes only one trailing space is used,\n     * we probably have a long word that we should break within (we leave that\n     * up to the pager or user) */\n    if (!(!fst->spaces && fst->delsp && (last != ' ')) && (w < width) &&\n        (w + fst->width + fst->spaces > width))\n    {\n      mutt_debug(LL_DEBUG3, \"f=f: break line at %zu, %zu spaces left\\n\",\n                 fst->width, fst->spaces);\n      /* only honor trailing spaces for format=flowed replies */\n      const bool c_text_flowed = cs_subset_bool(NeoMutt->sub, \"text_flowed\");\n      if (c_text_flowed)\n        for (; fst->spaces; fst->spaces--)\n          state_putc(state, ' ');\n      state_putc(state, '\\n');\n      fst->width = 0;\n      fst->spaces = 0;\n      words = 0;\n    }\n\n    if (!words && !fst->width)\n      fst->width = print_indent(ql, state, add_quote_suffix(state, ql));\n    fst->width += w + fst->spaces;\n    for (; fst->spaces; fst->spaces--)\n      state_putc(state, ' ');\n    state_puts(state, p);\n    words++;\n  }\n\n  if (term)\n    flush_par(state, fst);\n}\n\n/**\n * print_fixed_line - Print a fixed format line\n * @param line  Text to print\n * @param state State to work with\n * @param ql    Quote level\n * @param fst   State of the flowed text\n */\nstatic void print_fixed_line(const char *line, struct State *state, int ql,\n                             struct FlowedState *fst)\n{\n  print_indent(ql, state, add_quote_suffix(state, ql));\n  if (line && *line)\n    state_puts(state, line);\n  state_putc(state, '\\n');\n\n  fst->width = 0;\n  fst->spaces = 0;\n}\n\n/**\n * rfc3676_handler - Handler for format=flowed - Implements ::handler_t - @ingroup handler_api\n * @retval 0 Always\n */\nint rfc3676_handler(struct Body *b_email, struct State *state)\n{\n  char *buf = NULL;\n  unsigned int quotelevel = 0;\n  bool delsp = false;\n  size_t sz = 0;\n  struct FlowedState fst = { 0 };\n\n  /* respect DelSp of RFC3676 only with f=f parts */\n  char *t = mutt_param_get(&b_email->parameter, \"delsp\");\n  if (t)\n  {\n    delsp = mutt_istr_equal(t, \"yes\");\n    t = NULL;\n    fst.delsp = true;\n  }\n\n  mutt_debug(LL_DEBUG3, \"f=f: DelSp: %s\\n\", delsp ? \"yes\" : \"no\");\n\n  while ((buf = mutt_file_read_line(buf, &sz, state->fp_in, NULL, MUTT_RL_NO_FLAGS)))\n  {\n    const size_t buflen = mutt_str_len(buf);\n    const unsigned int newql = get_quote_level(buf);\n\n    /* end flowed paragraph (if we're within one) if quoting level\n     * changes (should not but can happen, see RFC3676, sec. 4.5.) */\n    if (newql != quotelevel)\n      flush_par(state, &fst);\n\n    quotelevel = newql;\n    int buf_off = newql;\n\n    /* respect sender's space-stuffing by removing one leading space */\n    if (buf[buf_off] == ' ')\n      buf_off++;\n\n    /* test for signature separator */\n    const unsigned int sigsep = mutt_str_equal(buf + buf_off, \"-- \");\n\n    /* a fixed line either has no trailing space or is the\n     * signature separator */\n    const bool fixed = (buflen == buf_off) || (buf[buflen - 1] != ' ') || sigsep;\n\n    /* print fixed-and-standalone, fixed-and-empty and sigsep lines as\n     * fixed lines */\n    if ((fixed && ((fst.width == 0) || (buflen == 0))) || sigsep)\n    {\n      /* if we're within a flowed paragraph, terminate it */\n      flush_par(state, &fst);\n      print_fixed_line(buf + buf_off, state, quotelevel, &fst);\n      continue;\n    }\n\n    /* for DelSp=yes, we need to strip one SP prior to CRLF on flowed lines */\n    if (delsp && !fixed)\n      buf[buflen - 1] = '\\0';\n\n    print_flowed_line(buf + buf_off, state, quotelevel, &fst, fixed);\n  }\n\n  flush_par(state, &fst);\n\n  FREE(&buf);\n  return 0;\n}\n\n/**\n * mutt_rfc3676_is_format_flowed - Is the Email \"format-flowed\"?\n * @param b Email Body to examine\n * @retval true Email is \"format-flowed\"\n */\nbool mutt_rfc3676_is_format_flowed(struct Body *b)\n{\n  if (b && (b->type == TYPE_TEXT) && mutt_istr_equal(\"plain\", b->subtype))\n  {\n    const char *format = mutt_param_get(&b->parameter, \"format\");\n    if (mutt_istr_equal(\"flowed\", format))\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * rfc3676_space_stuff - Perform required RFC3676 space stuffing\n * @param filename Attachment file\n * @param unstuff  If true, remove space stuffing\n *\n * Space stuffing means that we have to add leading spaces to\n * certain lines:\n *   - lines starting with a space\n *   - lines starting with 'From '\n *\n * Care is taken to preserve the e->body->filename, as\n * mutt -i -E can directly edit a passed in filename.\n */\nstatic void rfc3676_space_stuff(const char *filename, bool unstuff)\n{\n  FILE *fp_out = NULL;\n  char *buf = NULL;\n  size_t blen = 0;\n\n  struct Buffer *tempfile = buf_pool_get();\n\n  FILE *fp_in = mutt_file_fopen(filename, \"r\");\n  if (!fp_in)\n    goto bail;\n\n  buf_mktemp(tempfile);\n  fp_out = mutt_file_fopen(buf_string(tempfile), \"w+\");\n  if (!fp_out)\n    goto bail;\n\n  while ((buf = mutt_file_read_line(buf, &blen, fp_in, NULL, MUTT_RL_NO_FLAGS)) != NULL)\n  {\n    if (unstuff)\n    {\n      if (buf[0] == ' ')\n        fputs(buf + 1, fp_out);\n      else\n        fputs(buf, fp_out);\n    }\n    else\n    {\n      if ((buf[0] == ' ') || mutt_str_startswith(buf, \"From \"))\n        fputc(' ', fp_out);\n      fputs(buf, fp_out);\n    }\n    fputc('\\n', fp_out);\n  }\n  FREE(&buf);\n  mutt_file_fclose(&fp_in);\n  mutt_file_fclose(&fp_out);\n  mutt_file_set_mtime(filename, buf_string(tempfile));\n\n  fp_in = mutt_file_fopen(buf_string(tempfile), \"r\");\n  if (!fp_in)\n    goto bail;\n\n  if ((truncate(filename, 0) == -1) || ((fp_out = mutt_file_fopen(filename, \"a\")) == NULL))\n  {\n    mutt_perror(\"%s\", filename);\n    goto bail;\n  }\n\n  mutt_file_copy_stream(fp_in, fp_out);\n  mutt_file_set_mtime(buf_string(tempfile), filename);\n  unlink(buf_string(tempfile));\n\nbail:\n  mutt_file_fclose(&fp_in);\n  mutt_file_fclose(&fp_out);\n  buf_pool_release(&tempfile);\n}\n\n/**\n * mutt_rfc3676_space_stuff - Perform RFC3676 space stuffing on an Email\n * @param e Email\n *\n * @note We don't check the option `$text_flowed` because we want to stuff based\n *       the actual content type.  The option only decides whether to *set*\n *       format=flowed on new messages.\n */\nvoid mutt_rfc3676_space_stuff(struct Email *e)\n{\n  if (!e || !e->body || !e->body->filename)\n    return;\n\n  if (mutt_rfc3676_is_format_flowed(e->body))\n    rfc3676_space_stuff(e->body->filename, false);\n}\n\n/**\n * mutt_rfc3676_space_unstuff - Remove RFC3676 space stuffing\n * @param e Email\n */\nvoid mutt_rfc3676_space_unstuff(struct Email *e)\n{\n  if (!e || !e->body || !e->body->filename)\n    return;\n\n  if (mutt_rfc3676_is_format_flowed(e->body))\n    rfc3676_space_stuff(e->body->filename, true);\n}\n\n/**\n * mutt_rfc3676_space_unstuff_attachment - Unstuff attachments\n * @param b        Email Body (OPTIONAL)\n * @param filename Attachment file\n *\n * This routine is used when saving/piping/viewing rfc3676 attachments.\n *\n * If b is provided, the function will verify that the Email is format-flowed.\n * The filename will be unstuffed, not b->filename or b->fp.\n */\nvoid mutt_rfc3676_space_unstuff_attachment(struct Body *b, const char *filename)\n{\n  if (!filename)\n    return;\n\n  if (b && !mutt_rfc3676_is_format_flowed(b))\n    return;\n\n  rfc3676_space_stuff(filename, true);\n}\n\n/**\n * mutt_rfc3676_space_stuff_attachment - Stuff attachments\n * @param b        Email Body (OPTIONAL)\n * @param filename Attachment file\n *\n * This routine is used when filtering rfc3676 attachments.\n *\n * If b is provided, the function will verify that the Email is format-flowed.\n * The filename will be unstuffed, not b->filename or b->fp.\n */\nvoid mutt_rfc3676_space_stuff_attachment(struct Body *b, const char *filename)\n{\n  if (!filename)\n    return;\n\n  if (b && !mutt_rfc3676_is_format_flowed(b))\n    return;\n\n  rfc3676_space_stuff(filename, false);\n}\n"
        },
        {
          "name": "rfc3676.h",
          "type": "blob",
          "size": 1.4921875,
          "content": "/**\n * @file\n * RFC3676 Format Flowed routines\n *\n * @authors\n * Copyright (C) 2005 Andreas Krennmair <ak@synflood.at>\n * Copyright (C) 2005 Peter J. Holzer <hjp@hjp.net>\n * Copyright (C) 2005,2007 Rocco Rutte <pdmef@gmx.net>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_RFC3676_H\n#define MUTT_RFC3676_H\n\n#include <stdbool.h>\n\nstruct Body;\nstruct Email;\nstruct State;\n\nint  rfc3676_handler                      (struct Body *b_email, struct State *state);\nbool mutt_rfc3676_is_format_flowed        (struct Body *b);\nvoid mutt_rfc3676_space_stuff             (struct Email *e);\nvoid mutt_rfc3676_space_unstuff           (struct Email *e);\nvoid mutt_rfc3676_space_unstuff_attachment(struct Body *b, const char *filename);\nvoid mutt_rfc3676_space_stuff_attachment  (struct Body *b, const char *filename);\n\n#endif /* MUTT_RFC3676_H */\n"
        },
        {
          "name": "score.c",
          "type": "blob",
          "size": 6.6376953125,
          "content": "/**\n * @file\n * Routines for adding user scores to emails\n *\n * @authors\n * Copyright (C) 1996-2000 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n * Copyright (C) 2018 Victor Fernandes <criw@pm.me>\n * Copyright (C) 2020-2021 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_score Routines for adding user scores to emails\n *\n * Routines for adding user scores to emails\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"mutt.h\"\n#include \"score.h\"\n#include \"index/lib.h\"\n#include \"parse/lib.h\"\n#include \"pattern/lib.h\"\n#include \"globals.h\"\n#include \"mutt_thread.h\"\n#include \"protos.h\"\n\n/**\n * struct Score - Scoring rule for email\n */\nstruct Score\n{\n  char *str;\n  struct PatternList *pat;\n  int val;\n  bool exact;         ///< If this rule matches, don't evaluate any more\n  struct Score *next; ///< Linked list\n};\n\n/// Linked list of email scoring rules\nstatic struct Score *ScoreList = NULL;\n\n/**\n * mutt_check_rescore - Do the emails need to have their scores recalculated?\n * @param m Mailbox\n */\nvoid mutt_check_rescore(struct Mailbox *m)\n{\n  const bool c_score = cs_subset_bool(NeoMutt->sub, \"score\");\n  if (OptNeedRescore && c_score)\n  {\n    const enum EmailSortType c_sort = cs_subset_sort(NeoMutt->sub, \"sort\");\n    const enum EmailSortType c_sort_aux = cs_subset_sort(NeoMutt->sub, \"sort_aux\");\n    if (((c_sort & SORT_MASK) == EMAIL_SORT_SCORE) ||\n        ((c_sort_aux & SORT_MASK) == EMAIL_SORT_SCORE))\n    {\n      OptNeedResort = true;\n      if (mutt_using_threads())\n        OptSortSubthreads = true;\n    }\n\n    mutt_debug(LL_NOTIFY, \"NT_SCORE: %p\\n\", (void *) m);\n    notify_send(m->notify, NT_SCORE, 0, NULL);\n  }\n  OptNeedRescore = false;\n}\n\n/**\n * mutt_parse_score - Parse the 'score' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult mutt_parse_score(struct Buffer *buf, struct Buffer *s,\n                                    intptr_t data, struct Buffer *err)\n{\n  struct Score *ptr = NULL, *last = NULL;\n  char *pattern = NULL, *pc = NULL;\n\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"score\");\n    return MUTT_CMD_WARNING;\n  }\n  pattern = buf_strdup(buf);\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n  if (MoreArgs(s))\n  {\n    FREE(&pattern);\n    buf_printf(err, _(\"%s: too many arguments\"), \"score\");\n    return MUTT_CMD_WARNING;\n  }\n\n  /* look for an existing entry and update the value, else add it to the end\n   * of the list */\n  for (ptr = ScoreList, last = NULL; ptr; last = ptr, ptr = ptr->next)\n    if (mutt_str_equal(pattern, ptr->str))\n      break;\n\n  if (ptr)\n  {\n    /* 'buf' arg was cleared and 'pattern' holds the only reference;\n     * as here 'ptr' != NULL -> update the value only in which case\n     * ptr->str already has the string, so pattern should be freed.  */\n    FREE(&pattern);\n  }\n  else\n  {\n    struct MailboxView *mv_cur = get_current_mailbox_view();\n    struct Menu *menu = get_current_menu();\n    struct PatternList *pat = mutt_pattern_comp(mv_cur, menu, pattern, MUTT_PC_NO_FLAGS, err);\n    if (!pat)\n    {\n      FREE(&pattern);\n      return MUTT_CMD_ERROR;\n    }\n    ptr = MUTT_MEM_CALLOC(1, struct Score);\n    if (last)\n      last->next = ptr;\n    else\n      ScoreList = ptr;\n    ptr->pat = pat;\n    ptr->str = pattern;\n  }\n  pc = buf->data;\n  if (*pc == '=')\n  {\n    ptr->exact = true;\n    pc++;\n  }\n  if (!mutt_str_atoi_full(pc, &ptr->val))\n  {\n    FREE(&pattern);\n    buf_strcpy(err, _(\"Error: score: invalid number\"));\n    return MUTT_CMD_ERROR;\n  }\n  OptNeedRescore = true;\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * mutt_score_message - Apply scoring to an email\n * @param m        Mailbox\n * @param e        Email\n * @param upd_mbox If true, update the Mailbox too\n */\nvoid mutt_score_message(struct Mailbox *m, struct Email *e, bool upd_mbox)\n{\n  struct Score *tmp = NULL;\n  struct PatternCache cache = { 0 };\n\n  e->score = 0; /* in case of re-scoring */\n  for (tmp = ScoreList; tmp; tmp = tmp->next)\n  {\n    if (mutt_pattern_exec(SLIST_FIRST(tmp->pat), MUTT_MATCH_FULL_ADDRESS, NULL, e, &cache) > 0)\n    {\n      if (tmp->exact || (tmp->val == 9999) || (tmp->val == -9999))\n      {\n        e->score = tmp->val;\n        break;\n      }\n      e->score += tmp->val;\n    }\n  }\n  if (e->score < 0)\n    e->score = 0;\n\n  const short c_score_threshold_delete = cs_subset_number(NeoMutt->sub, \"score_threshold_delete\");\n  const short c_score_threshold_flag = cs_subset_number(NeoMutt->sub, \"score_threshold_flag\");\n  const short c_score_threshold_read = cs_subset_number(NeoMutt->sub, \"score_threshold_read\");\n\n  if (e->score <= c_score_threshold_delete)\n    mutt_set_flag(m, e, MUTT_DELETE, true, upd_mbox);\n  if (e->score <= c_score_threshold_read)\n    mutt_set_flag(m, e, MUTT_READ, true, upd_mbox);\n  if (e->score >= c_score_threshold_flag)\n    mutt_set_flag(m, e, MUTT_FLAG, true, upd_mbox);\n}\n\n/**\n * mutt_parse_unscore - Parse the 'unscore' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult mutt_parse_unscore(struct Buffer *buf, struct Buffer *s,\n                                      intptr_t data, struct Buffer *err)\n{\n  struct Score *tmp = NULL, *last = NULL;\n\n  while (MoreArgs(s))\n  {\n    parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n    if (mutt_str_equal(\"*\", buf->data))\n    {\n      for (tmp = ScoreList; tmp;)\n      {\n        last = tmp;\n        tmp = tmp->next;\n        mutt_pattern_free(&last->pat);\n        FREE(&last);\n      }\n      ScoreList = NULL;\n    }\n    else\n    {\n      for (tmp = ScoreList; tmp; last = tmp, tmp = tmp->next)\n      {\n        if (mutt_str_equal(buf->data, tmp->str))\n        {\n          if (last)\n            last->next = tmp->next;\n          else\n            ScoreList = tmp->next;\n          mutt_pattern_free(&tmp->pat);\n          FREE(&tmp);\n          /* there should only be one score per pattern, so we can stop here */\n          break;\n        }\n      }\n    }\n  }\n  OptNeedRescore = true;\n  return MUTT_CMD_SUCCESS;\n}\n"
        },
        {
          "name": "score.h",
          "type": "blob",
          "size": 1.27734375,
          "content": "/**\n * @file\n * Routines for adding user scores to emails\n *\n * @authors\n * Copyright (C) 2018-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_SCORE_H\n#define MUTT_SCORE_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct Email;\n\nvoid mutt_check_rescore(struct Mailbox *m);\nenum CommandResult mutt_parse_score(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult mutt_parse_unscore(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nvoid mutt_score_message(struct Mailbox *m, struct Email *e, bool upd_mbox);\n\n#endif /* MUTT_SCORE_H */\n"
        },
        {
          "name": "send",
          "type": "tree",
          "content": null
        },
        {
          "name": "sidebar",
          "type": "tree",
          "content": null
        },
        {
          "name": "store",
          "type": "tree",
          "content": null
        },
        {
          "name": "subjectrx.c",
          "type": "blob",
          "size": 5.1025390625,
          "content": "/**\n * @file\n * Subject Regex handling\n *\n * @authors\n * Copyright (C) 2021-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_subjrx Subject Regex handling\n *\n * Subject Regex handling\n */\n\n#include \"config.h\"\n#include <stddef.h>\n#include <stdint.h>\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"subjectrx.h\"\n#include \"parse/lib.h\"\n#include \"mview.h\"\n\n/// List of subjectrx rules for modifying the Subject:\nstatic struct ReplaceList SubjectRegexList = STAILQ_HEAD_INITIALIZER(SubjectRegexList);\nstatic struct Notify *SubjRxNotify = NULL; ///< Notifications: #NotifySubjRx\n\n/**\n * subjrx_cleanup - Free the Subject Regex List\n */\nvoid subjrx_cleanup(void)\n{\n  notify_free(&SubjRxNotify);\n  mutt_replacelist_free(&SubjectRegexList);\n}\n\n/**\n * subjrx_init - Create new Subject Regex List\n */\nvoid subjrx_init(void)\n{\n  if (SubjRxNotify)\n    return;\n\n  SubjRxNotify = notify_new();\n  notify_set_parent(SubjRxNotify, NeoMutt->notify);\n}\n\n/**\n * parse_unreplace_list - Remove a string replacement rule - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_unreplace_list(struct Buffer *buf, struct Buffer *s,\n                                               struct ReplaceList *list, struct Buffer *err)\n{\n  /* First token is a regex. */\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"unsubjectrx\");\n    return MUTT_CMD_WARNING;\n  }\n\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n  /* \"*\" is a special case. */\n  if (mutt_str_equal(buf->data, \"*\"))\n  {\n    mutt_replacelist_free(list);\n    return MUTT_CMD_SUCCESS;\n  }\n\n  mutt_replacelist_remove(list, buf->data);\n  return MUTT_CMD_SUCCESS;\n}\n\n/**\n * parse_replace_list - Parse a string replacement rule - Implements Command::parse() - @ingroup command_parse\n */\nstatic enum CommandResult parse_replace_list(struct Buffer *buf, struct Buffer *s,\n                                             struct ReplaceList *list, struct Buffer *err)\n{\n  struct Buffer *templ = buf_pool_get();\n  int rc = MUTT_CMD_WARNING;\n\n  /* First token is a regex. */\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"subjectrx\");\n    goto done;\n  }\n  parse_extract_token(buf, s, TOKEN_NO_FLAGS);\n\n  /* Second token is a replacement template */\n  if (!MoreArgs(s))\n  {\n    buf_printf(err, _(\"%s: too few arguments\"), \"subjectrx\");\n    goto done;\n  }\n  parse_extract_token(templ, s, TOKEN_NO_FLAGS);\n\n  if (mutt_replacelist_add(list, buf->data, buf_string(templ), err) != 0)\n  {\n    rc = MUTT_CMD_ERROR;\n    goto done;\n  }\n\n  rc = MUTT_CMD_SUCCESS;\n\ndone:\n  buf_pool_release(&templ);\n  return rc;\n}\n\n/**\n * subjrx_apply_mods - Apply regex modifications to the subject\n * @param env Envelope of Email\n * @retval true Subject modified\n */\nbool subjrx_apply_mods(struct Envelope *env)\n{\n  if (!env || !env->subject || (*env->subject == '\\0'))\n    return false;\n\n  if (env->disp_subj)\n    return true;\n\n  if (STAILQ_EMPTY(&SubjectRegexList))\n    return false;\n\n  env->disp_subj = mutt_replacelist_apply(&SubjectRegexList, env->subject);\n  return true;\n}\n\n/**\n * subjrx_clear_mods - Clear out all modified email subjects\n * @param mv Mailbox view\n */\nvoid subjrx_clear_mods(struct MailboxView *mv)\n{\n  if (!mv || !mv->mailbox)\n    return;\n\n  struct Mailbox *m = mv->mailbox;\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e || !e->env)\n      continue;\n    FREE(&e->env->disp_subj);\n  }\n}\n\n/**\n * parse_subjectrx_list - Parse the 'subjectrx' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult parse_subjectrx_list(struct Buffer *buf, struct Buffer *s,\n                                        intptr_t data, struct Buffer *err)\n{\n  enum CommandResult rc;\n\n  rc = parse_replace_list(buf, s, &SubjectRegexList, err);\n  if (rc == MUTT_CMD_SUCCESS)\n  {\n    mutt_debug(LL_NOTIFY, \"NT_SUBJRX_ADD: %s\\n\", buf->data);\n    notify_send(SubjRxNotify, NT_SUBJRX, NT_SUBJRX_ADD, NULL);\n  }\n  return rc;\n}\n\n/**\n * parse_unsubjectrx_list - Parse the 'unsubjectrx' command - Implements Command::parse() - @ingroup command_parse\n */\nenum CommandResult parse_unsubjectrx_list(struct Buffer *buf, struct Buffer *s,\n                                          intptr_t data, struct Buffer *err)\n{\n  enum CommandResult rc;\n\n  rc = parse_unreplace_list(buf, s, &SubjectRegexList, err);\n  if (rc == MUTT_CMD_SUCCESS)\n  {\n    mutt_debug(LL_NOTIFY, \"NT_SUBJRX_DELETE: %s\\n\", buf->data);\n    notify_send(SubjRxNotify, NT_SUBJRX, NT_SUBJRX_DELETE, NULL);\n  }\n  return rc;\n}\n"
        },
        {
          "name": "subjectrx.h",
          "type": "blob",
          "size": 1.7138671875,
          "content": "/**\n * @file\n * Subject Regex handling\n *\n * @authors\n * Copyright (C) 2021-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_SUBJECTRX_H\n#define MUTT_SUBJECTRX_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include \"core/lib.h\"\n\nstruct Buffer;\nstruct Envelope;\nstruct MailboxView;\n\n/**\n * enum NotifySubjRx - Subject Regex notification types\n *\n * Observers of #NT_SUBJRX will not be passed any Event data.\n *\n * @note Notifications are sent **after** the event.\n */\nenum NotifySubjRx\n{\n  NT_SUBJRX_ADD = 1,    ///< Subject Regex has been added\n  NT_SUBJRX_DELETE,     ///< Subject Regex has been deleted\n  NT_SUBJRX_DELETE_ALL, ///< All Subject Regexes have been deleted\n};\n\nvoid subjrx_init(void);\nvoid subjrx_cleanup(void);\n\nenum CommandResult parse_subjectrx_list  (struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\nenum CommandResult parse_unsubjectrx_list(struct Buffer *buf, struct Buffer *s, intptr_t data, struct Buffer *err);\n\nbool subjrx_apply_mods(struct Envelope *env);\nvoid subjrx_clear_mods(struct MailboxView *mv);\n\n#endif /* MUTT_SUBJECTRX_H */\n"
        },
        {
          "name": "system.c",
          "type": "blob",
          "size": 2.4482421875,
          "content": "/**\n * @file\n * Execute external programs\n *\n * @authors\n * Copyright (C) 1996-2000,2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2017-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_system Execute external programs\n *\n * Execute external programs\n */\n\n#include \"config.h\"\n#include <signal.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h> // IWYU pragma: keep\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"imap/lib.h\"\n#include \"globals.h\"\n#include \"protos.h\"\n\n/**\n * mutt_system - Run an external command\n * @param cmd Command and arguments\n * @retval -1  Error\n * @retval >=0 Success (command's return code)\n *\n * Fork and run an external command with arguments.\n *\n * @note This function won't return until the command finishes.\n */\nint mutt_system(const char *cmd)\n{\n  int rc = -1;\n  struct sigaction act = { 0 };\n  struct sigaction oldtstp = { 0 };\n  struct sigaction oldcont = { 0 };\n  pid_t pid;\n\n  if (!cmd || (*cmd == '\\0'))\n    return 0;\n\n  /* must ignore SIGINT and SIGQUIT */\n\n  mutt_sig_block_system();\n\n  act.sa_handler = SIG_DFL;\n/* we want to restart the waitpid() below */\n#ifdef SA_RESTART\n  act.sa_flags = SA_RESTART;\n#endif\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGTSTP, &act, &oldtstp);\n  sigaction(SIGCONT, &act, &oldcont);\n\n  pid = fork();\n  if (pid == 0)\n  {\n    act.sa_flags = 0;\n\n    mutt_sig_unblock_system(false);\n    mutt_sig_reset_child_signals();\n\n    execle(EXEC_SHELL, \"sh\", \"-c\", cmd, NULL, EnvList);\n    _exit(127); /* execl error */\n  }\n  else if (pid != -1)\n  {\n    rc = imap_wait_keep_alive(pid);\n  }\n\n  sigaction(SIGCONT, &oldcont, NULL);\n  sigaction(SIGTSTP, &oldtstp, NULL);\n\n  /* reset SIGINT, SIGQUIT and SIGCHLD */\n  mutt_sig_unblock_system(true);\n\n  rc = (pid != -1) ? (WIFEXITED(rc) ? WEXITSTATUS(rc) : -1) : -1;\n\n  return rc;\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "timegm.c",
          "type": "blob",
          "size": 1.849609375,
          "content": "/**\n * @file\n * For systems lacking timegm()\n *\n * @authors\n * Copyright (C) 2022 Claes Nästén <pekdon@gmail.com>\n * Copyright (C) 2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_timegm For systems lacking timegm()\n *\n * For systems lacking timegm()\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <time.h>\n\n/**\n * is_leap_year - Is this a Leap Year?\n * @param year Year\n * @retval true It's a leap year\n */\nstatic bool is_leap_year(int year)\n{\n  return ((year % 400) == 0) || (((year % 4) == 0) && ((year % 100) != 0));\n}\n\n/**\n * tm_to_sec - Convert a time structure to number of seconds since the epoch\n * @param tm Time structure\n * @retval num Seconds since the epoch\n */\nstatic time_t tm_to_sec(struct tm *tm)\n{\n  time_t val = tm->tm_sec + (tm->tm_min * 60) + (tm->tm_hour * 3600) + (tm->tm_yday * 86400);\n\n  int year = 1900 + tm->tm_year;\n  for (int i = 1970; i < year; i++)\n  {\n    if (is_leap_year(i))\n      val += (366 * 86400);\n    else\n      val += (365 * 86400);\n  }\n\n  return val;\n}\n\n/**\n * timegm - Convert struct tm to time_t seconds since epoch\n * @param tm Time to convert to seconds since epoch\n * @retval num Seconds since epoch\n */\ntime_t timegm(struct tm *tm)\n{\n  return tm_to_sec(tm);\n}\n"
        },
        {
          "name": "version.c",
          "type": "blob",
          "size": 13.47265625,
          "content": "/**\n * @file\n * Display version and copyright about NeoMutt\n *\n * @authors\n * Copyright (C) 2016-2020 Pietro Cerutti <gahr@gahr.ch>\n * Copyright (C) 2016-2023 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_version Display version and copyright about NeoMutt\n *\n * Display version and copyright about NeoMutt\n */\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"gui/lib.h\"\n#include \"version.h\"\n#include \"compress/lib.h\"\n#ifdef HAVE_LIBIDN\n#include \"address/lib.h\"\n#endif\n#ifdef CRYPT_BACKEND_GPGME\n#include \"ncrypt/lib.h\"\n#endif\n#ifdef HAVE_NOTMUCH\n#include <notmuch.h>\n#endif\n#ifdef USE_SSL_OPENSSL\n#include <openssl/opensslv.h>\n#endif\n#ifdef USE_SSL_GNUTLS\n#include <gnutls/gnutls.h>\n#endif\n#ifdef HAVE_PCRE2\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#endif\n\nconst char *mutt_make_version(void);\nconst char *store_backend_list(void);\nconst char *store_compress_list(void);\n\n/// CLI: Width to wrap version info\nstatic const int SCREEN_WIDTH = 80;\n\nextern unsigned char cc_cflags[];\nextern unsigned char configure_options[];\n\n/// CLI Version: Authors' copyrights\nstatic const char *Copyright =\n    \"Copyright (C) 2015-2025 Richard Russon <rich@flatcap.org>\\n\"\n    \"Copyright (C) 2016-2025 Pietro Cerutti <gahr@gahr.ch>\\n\"\n    \"Copyright (C) 2017-2019 Mehdi Abaakouk <sileht@sileht.net>\\n\"\n    \"Copyright (C) 2018-2020 Federico Kircheis <federico.kircheis@gmail.com>\\n\"\n    \"Copyright (C) 2017-2022 Austin Ray <austin@austinray.io>\\n\"\n    \"Copyright (C) 2023-2025 Dennis Schön <mail@dennis-schoen.de>\\n\"\n    \"Copyright (C) 2016-2017 Damien Riegel <damien.riegel@gmail.com>\\n\"\n    \"Copyright (C) 2023      Rayford Shireman\\n\"\n    \"Copyright (C) 2021-2023 David Purton <dcpurton@marshwiggle.net>\\n\"\n    \"Copyright (C) 2020-2023 наб <nabijaczleweli@nabijaczleweli.xyz>\\n\";\n\n/// CLI Version: Thanks\nstatic const char *Thanks = N_(\n    \"Many others not mentioned here contributed code, fixes and suggestions.\\n\");\n\n/// CLI Version: License\nstatic const char *License = N_(\n    \"This program is free software; you can redistribute it and/or modify\\n\"\n    \"it under the terms of the GNU General Public License as published by\\n\"\n    \"the Free Software Foundation; either version 2 of the License, or\\n\"\n    \"(at your option) any later version.\\n\"\n    \"\\n\"\n    \"This program is distributed in the hope that it will be useful,\\n\"\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n    \"GNU General Public License for more details.\\n\"\n    \"\\n\"\n    \"You should have received a copy of the GNU General Public License\\n\"\n    \"along with this program; if not, write to the Free Software\\n\"\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\\n\");\n\n/// CLI Version: How to reach the NeoMutt Team\nstatic const char *ReachingUs = N_(\"To learn more about NeoMutt, visit: https://neomutt.org\\n\"\n                                   \"If you find a bug in NeoMutt, please raise an issue at:\\n\"\n                                   \"    https://github.com/neomutt/neomutt/issues\\n\"\n                                   \"or send an email to: <neomutt-devel@neomutt.org>\\n\");\n\n// clang-format off\n/// CLI Version: Warranty notice\nstatic const char *Notice =\n    N_(\"Copyright (C) 2015-2025 Richard Russon and friends\\n\"\n       \"NeoMutt comes with ABSOLUTELY NO WARRANTY; for details type 'neomutt -vv'.\\n\"\n       \"NeoMutt is free software, and you are welcome to redistribute it\\n\"\n       \"under certain conditions; type 'neomutt -vv' for details.\\n\");\n// clang-format on\n\n/**\n * struct CompileOptions - List of built-in capabilities\n */\nstruct CompileOptions\n{\n  const char *name; ///< Option name\n  int enabled;      ///< 0 Disabled, 1 Enabled, 2 Devel only\n};\n\n/* These are sorted by the display string */\n\n/// Compile options strings for `neomutt -v` output\nstatic const struct CompileOptions CompOpts[] = {\n#ifdef USE_AUTOCRYPT\n  { \"autocrypt\", 1 },\n#else\n  { \"autocrypt\", 0 },\n#endif\n#ifdef USE_FCNTL\n  { \"fcntl\", 1 },\n#else\n  { \"fcntl\", 0 },\n#endif\n#ifdef USE_FLOCK\n  { \"flock\", 1 },\n#else\n  { \"flock\", 0 },\n#endif\n#ifdef USE_FMEMOPEN\n  { \"fmemopen\", 1 },\n#else\n  { \"fmemopen\", 0 },\n#endif\n#ifdef HAVE_FUTIMENS\n  { \"futimens\", 1 },\n#else\n  { \"futimens\", 0 },\n#endif\n#ifdef HAVE_GETADDRINFO\n  { \"getaddrinfo\", 1 },\n#else\n  { \"getaddrinfo\", 0 },\n#endif\n#ifdef USE_SSL_GNUTLS\n  { \"gnutls\", 1 },\n#else\n  { \"gnutls\", 0 },\n#endif\n#ifdef CRYPT_BACKEND_GPGME\n  { \"gpgme\", 1 },\n#else\n  { \"gpgme\", 0 },\n#endif\n#ifdef USE_SASL_GNU\n  { \"gsasl\", 1 },\n#else\n  { \"gsasl\", 0 },\n#endif\n#ifdef USE_GSS\n  { \"gss\", 1 },\n#else\n  { \"gss\", 0 },\n#endif\n#ifdef USE_HCACHE\n  { \"hcache\", 1 },\n#else\n  { \"hcache\", 0 },\n#endif\n#ifdef HOMESPOOL\n  { \"homespool\", 1 },\n#else\n  { \"homespool\", 0 },\n#endif\n#ifdef HAVE_LIBIDN\n  { \"idn\", 1 },\n#else\n  { \"idn\", 0 },\n#endif\n#ifdef USE_INOTIFY\n  { \"inotify\", 1 },\n#else\n  { \"inotify\", 0 },\n#endif\n#ifdef LOCALES_HACK\n  { \"locales_hack\", 1 },\n#else\n  { \"locales_hack\", 0 },\n#endif\n#ifdef USE_LUA\n  { \"lua\", 1 },\n#else\n  { \"lua\", 0 },\n#endif\n#ifdef ENABLE_NLS\n  { \"nls\", 1 },\n#else\n  { \"nls\", 0 },\n#endif\n#ifdef USE_NOTMUCH\n  { \"notmuch\", 1 },\n#else\n  { \"notmuch\", 0 },\n#endif\n#ifdef USE_SSL_OPENSSL\n  { \"openssl\", 1 },\n#else\n  { \"openssl\", 0 },\n#endif\n#ifdef HAVE_PCRE2\n  { \"pcre2\", 1 },\n#endif\n#ifdef CRYPT_BACKEND_CLASSIC_PGP\n  { \"pgp\", 1 },\n#else\n  { \"pgp\", 0 },\n#endif\n#ifndef HAVE_PCRE2\n  { \"regex\", 1 },\n#endif\n#ifdef USE_SASL_CYRUS\n  { \"sasl\", 1 },\n#else\n  { \"sasl\", 0 },\n#endif\n#ifdef CRYPT_BACKEND_CLASSIC_SMIME\n  { \"smime\", 1 },\n#else\n  { \"smime\", 0 },\n#endif\n#ifdef USE_SQLITE\n  { \"sqlite\", 1 },\n#else\n  { \"sqlite\", 0 },\n#endif\n#ifdef NEOMUTT_DIRECT_COLORS\n  { \"truecolor\", 1 },\n#else\n  { \"truecolor\", 0 },\n#endif\n  { NULL, 0 },\n};\n\n/// Debug options strings for `neomutt -v` output\nstatic const struct CompileOptions DebugOpts[] = {\n#ifdef USE_ASAN\n  { \"asan\", 2 },\n#endif\n#ifdef USE_DEBUG_BACKTRACE\n  { \"backtrace\", 2 },\n#endif\n#ifdef USE_DEBUG_COLOR\n  { \"color\", 2 },\n#endif\n#ifdef USE_DEBUG_EMAIL\n  { \"email\", 2 },\n#endif\n#ifdef USE_DEBUG_GRAPHVIZ\n  { \"graphviz\", 2 },\n#endif\n#ifdef USE_DEBUG_KEYMAP\n  { \"keymap\", 2 },\n#endif\n#ifdef USE_DEBUG_LOGGING\n  { \"logging\", 2 },\n#endif\n#ifdef USE_DEBUG_NAMES\n  { \"names\", 2 },\n#endif\n#ifdef USE_DEBUG_NOTIFY\n  { \"notify\", 2 },\n#endif\n#ifdef QUEUE_MACRO_DEBUG_TRACE\n  { \"queue\", 2 },\n#endif\n#ifdef USE_UBSAN\n  { \"ubsan\", 2 },\n#endif\n#ifdef USE_DEBUG_WINDOW\n  { \"window\", 2 },\n#endif\n  { NULL, 0 },\n};\n\n/**\n * print_compile_options - Print a list of enabled/disabled features\n * @param co Array of compile options\n * @param fp file to write to\n *\n * Two lists are generated and passed to this function:\n *\n * One list which just uses the configure state of each feature.\n * One list which just uses feature which are set to on directly in NeoMutt.\n *\n * The output is of the form: \"+enabled_feature -disabled_feature\" and is\n * wrapped to SCREEN_WIDTH characters.\n */\nstatic void print_compile_options(const struct CompileOptions *co, FILE *fp)\n{\n  if (!co || !fp)\n    return;\n\n  size_t used = 2;\n  bool tty = isatty(fileno(fp));\n\n  fprintf(fp, \"  \");\n  for (int i = 0; co[i].name; i++)\n  {\n    const size_t len = strlen(co[i].name) + 2; /* +/- and a space */\n    if ((used + len) > SCREEN_WIDTH)\n    {\n      used = 2;\n      fprintf(fp, \"\\n  \");\n    }\n    used += len;\n    const char *fmt = \"?%s \";\n    switch (co[i].enabled)\n    {\n      case 0: // Disabled\n        if (tty)\n          fmt = \"\\033[1;31m-%s\\033[0m \"; // Escape, red\n        else\n          fmt = \"-%s \";\n        break;\n      case 1: // Enabled\n        if (tty)\n          fmt = \"\\033[1;32m+%s\\033[0m \"; // Escape, green\n        else\n          fmt = \"+%s \";\n        break;\n      case 2: // Devel only\n        if (tty)\n          fmt = \"\\033[1;36m%s\\033[0m \"; // Escape, cyan\n        else\n          fmt = \"%s \";\n        break;\n    }\n    fprintf(fp, fmt, co[i].name);\n  }\n  fprintf(fp, \"\\n\");\n}\n\n/**\n * rstrip_in_place - Strip a trailing carriage return\n * @param s  String to be modified\n * @retval ptr The modified string\n *\n * The string has its last carriage return set to NUL.\n */\nstatic char *rstrip_in_place(char *s)\n{\n  if (!s)\n    return NULL;\n\n  char *p = &s[strlen(s)];\n  if (p == s)\n    return s;\n  p--;\n  while ((p >= s) && ((*p == '\\n') || (*p == '\\r')))\n    *p-- = '\\0';\n  return s;\n}\n\n/**\n * print_version - Print system and compile info to a file\n * @param fp File to print to\n * @retval true Text displayed\n *\n * Print information about the current system NeoMutt is running on.\n * Also print a list of all the compile-time information.\n */\nbool print_version(FILE *fp)\n{\n  if (!fp)\n    return false;\n\n  struct utsname uts = { 0 };\n  bool tty = isatty(fileno(fp));\n\n  const char *col_cyan = \"\";\n  const char *col_bold = \"\";\n  const char *col_end = \"\";\n\n  if (tty)\n  {\n    col_cyan = \"\\033[1;36m\"; // Escape, cyan\n    col_bold = \"\\033[1m\";    // Escape, bold\n    col_end = \"\\033[0m\";     // Escape, end\n  }\n\n  fprintf(fp, \"%s%s%s\\n\", col_cyan, mutt_make_version(), col_end);\n  fprintf(fp, \"%s\\n\", _(Notice));\n\n  uname(&uts);\n\n  fprintf(fp, \"%sSystem:%s \", col_bold, col_end);\n#ifdef SCO\n  fprintf(fp, \"SCO %s\", uts.release);\n#else\n  fprintf(fp, \"%s %s\", uts.sysname, uts.release);\n#endif\n\n  fprintf(fp, \" (%s)\", uts.machine);\n\n  fprintf(fp, \"\\n%sncurses:%s %s\", col_bold, col_end, curses_version());\n#ifdef NCURSES_VERSION\n  fprintf(fp, \" (compiled with %s.%d)\", NCURSES_VERSION, NCURSES_VERSION_PATCH);\n#endif\n\n#ifdef _LIBICONV_VERSION\n  fprintf(fp, \"\\n%slibiconv:%s %d.%d\", col_bold, col_end,\n          _LIBICONV_VERSION >> 8, _LIBICONV_VERSION & 0xff);\n#endif\n\n#ifdef HAVE_LIBIDN\n  fprintf(fp, \"\\n%slibidn2:%s %s\", col_bold, col_end, mutt_idna_print_version());\n#endif\n\n#ifdef CRYPT_BACKEND_GPGME\n  fprintf(fp, \"\\n%sGPGME:%s %s\", col_bold, col_end, mutt_gpgme_print_version());\n#endif\n\n#ifdef USE_SSL_OPENSSL\n#ifdef LIBRESSL_VERSION_TEXT\n  fprintf(fp, \"\\n%sLibreSSL:%s %s\", col_bold, col_end, LIBRESSL_VERSION_TEXT);\n#endif\n#ifdef OPENSSL_VERSION_TEXT\n  fprintf(fp, \"\\n%sOpenSSL:%s %s\", col_bold, col_end, OPENSSL_VERSION_TEXT);\n#endif\n#endif\n\n#ifdef USE_SSL_GNUTLS\n  fprintf(fp, \"\\n%sGnuTLS:%s %s\", col_bold, col_end, GNUTLS_VERSION);\n#endif\n\n#ifdef HAVE_NOTMUCH\n  fprintf(fp, \"\\n%slibnotmuch:%s %d.%d.%d\", col_bold, col_end, LIBNOTMUCH_MAJOR_VERSION,\n          LIBNOTMUCH_MINOR_VERSION, LIBNOTMUCH_MICRO_VERSION);\n#endif\n\n#ifdef HAVE_PCRE2\n  {\n    char version[24] = { 0 };\n    pcre2_config(PCRE2_CONFIG_VERSION, version);\n    fprintf(fp, \"\\n%sPCRE2:%s %s\", col_bold, col_end, version);\n  }\n#endif\n\n#ifdef USE_HCACHE\n  const char *backends = store_backend_list();\n  fprintf(fp, \"\\n%sstorage:%s %s\", col_bold, col_end, backends);\n  FREE(&backends);\n#ifdef USE_HCACHE_COMPRESSION\n  backends = compress_list();\n  fprintf(fp, \"\\n%scompression:%s %s\", col_bold, col_end, backends);\n  FREE(&backends);\n#endif\n#endif\n\n  rstrip_in_place((char *) configure_options);\n  fprintf(fp, \"\\n\\n%sConfigure options:%s %s\\n\", col_bold, col_end, (char *) configure_options);\n\n  rstrip_in_place((char *) cc_cflags);\n  fprintf(fp, \"\\n%sCompilation CFLAGS:%s %s\\n\", col_bold, col_end, (char *) cc_cflags);\n\n  fprintf(fp, \"\\n%s%s%s\\n\", col_bold, _(\"Compile options:\"), col_end);\n  print_compile_options(CompOpts, fp);\n\n  if (DebugOpts[0].name)\n  {\n    fprintf(fp, \"\\n%s%s%s\\n\", col_bold, _(\"Devel options:\"), col_end);\n    print_compile_options(DebugOpts, fp);\n  }\n\n  fprintf(fp, \"\\n\");\n#ifdef DOMAIN\n  fprintf(fp, \"DOMAIN=\\\"%s\\\"\\n\", DOMAIN);\n#endif\n#ifdef ISPELL\n  fprintf(fp, \"ISPELL=\\\"%s\\\"\\n\", ISPELL);\n#endif\n  fprintf(fp, \"MAILPATH=\\\"%s\\\"\\n\", MAILPATH);\n  fprintf(fp, \"PKGDATADIR=\\\"%s\\\"\\n\", PKGDATADIR);\n  fprintf(fp, \"SENDMAIL=\\\"%s\\\"\\n\", SENDMAIL);\n  fprintf(fp, \"SYSCONFDIR=\\\"%s\\\"\\n\", SYSCONFDIR);\n\n  fprintf(fp, \"\\n\");\n  fputs(_(ReachingUs), fp);\n\n  fflush(fp);\n  return !ferror(fp);\n}\n\n/**\n * print_copyright - Print copyright message\n * @retval true Text displayed\n *\n * Print the authors' copyright messages, the GPL license and some contact\n * information for the NeoMutt project.\n */\nbool print_copyright(void)\n{\n  puts(mutt_make_version());\n  puts(Copyright);\n  puts(_(Thanks));\n  puts(_(License));\n  puts(_(ReachingUs));\n\n  fflush(stdout);\n  return !ferror(stdout);\n}\n\n/**\n * feature_enabled - Test if a compile-time feature is enabled\n * @param name  Compile-time symbol of the feature\n * @retval true  Feature enabled\n * @retval false Feature not enabled, or not compiled in\n *\n * Many of the larger features of neomutt can be disabled at compile time.\n * They define a symbol and use ifdef's around their code.\n * The symbols are mirrored in \"CompileOptions CompOpts[]\" in this\n * file.\n *\n * This function checks if one of these symbols is present in the code.\n *\n * These symbols are also seen in the output of \"neomutt -v\".\n */\nbool feature_enabled(const char *name)\n{\n  if (!name)\n    return false;\n  for (int i = 0; CompOpts[i].name; i++)\n  {\n    if (mutt_str_equal(name, CompOpts[i].name))\n    {\n      return CompOpts[i].enabled;\n    }\n  }\n  return false;\n}\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.9951171875,
          "content": "/**\n * @file\n * Display version and copyright about NeoMutt\n *\n * @authors\n * Copyright (C) 2017-2021 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_VERSION_H\n#define MUTT_VERSION_H\n\n#include <stdbool.h>\n#include <stdio.h>\n\nbool print_version(FILE *fp);\nbool print_copyright(void);\nbool feature_enabled(const char *name);\n\n#endif /* MUTT_VERSION_H */\n"
        },
        {
          "name": "wcscasecmp.c",
          "type": "blob",
          "size": 1.3974609375,
          "content": "/**\n * @file\n * For systems lacking wcscasecmp()\n *\n * @authors\n * Copyright (C) 2009 Rocco Rutte <pdmef@gmx.net>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page neo_wcscasecmp For systems lacking wcscasecmp()\n *\n * For systems lacking wcscasecmp()\n */\n\n#include \"config.h\"\n#include <wchar.h>\n#include <wctype.h>\n\n/**\n * wcscasecmp - Compare two wide-character strings, ignoring case\n * @param a First string\n * @param b Second string\n * @retval -1 a precedes b\n * @retval  0 a and b are identical\n * @retval  1 b precedes a\n */\nint wcscasecmp(const wchar_t *a, const wchar_t *b)\n{\n  if (!a && !b)\n    return 0;\n  if (!a && b)\n    return -1;\n  if (a && !b)\n    return 1;\n\n  for (; *a || *b; a++, b++)\n  {\n    int i = towlower(*a);\n    if ((i - towlower(*b)) != 0)\n      return i;\n  }\n  return 0;\n}\n"
        }
      ]
    }
  ]
}