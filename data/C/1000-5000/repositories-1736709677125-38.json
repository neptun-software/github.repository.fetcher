{
  "metadata": {
    "timestamp": 1736709677125,
    "page": 38,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "asg017/sqlite-vec",
      "stars": 4619,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2724609375,
          "content": "/target\n.vscode\nsift/\n*.tar.gz\n*.db\n*.npy\n*.bin\n*.out\nvenv/\n\nvendor/\ndist/\n\n*.pyc\n*.db-journal\n\nalexandria/\nopenai/\nexamples/supabase-dbpedia\nexamples/ann-filtering\nexamples/dbpedia-openai\nexamples/imdb\nexamples/sotu\n\nsqlite-vec.h\ntmp/\n\npoetry.lock\n\n*.jsonl\n\nmemstat.c\nmemstat.*\n"
        },
        {
          "name": "ARCHITECTURE.md",
          "type": "blob",
          "size": 3.923828125,
          "content": "# `sqlite-vec` Architecture\n\nInternal documentation for how `sqlite-vec` works under-the-hood. Not meant for\nusers of the `sqlite-vec` project, consult\n[the official `sqlite-vec` documentation](https://alexgarcia.xyz/sqlite-vec) for\nhow-to-guides. Rather, this is for people interested in how `sqlite-vec` works\nand some guidelines to any future contributors.\n\nVery much a WIP.\n\n## `vec0`\n\n### Shadow Tables\n\n#### `xyz_chunks`\n\n- `chunk_id INTEGER`\n- `size INTEGER`\n- `validity BLOB`\n- `rowids BLOB`\n\n#### `xyz_rowids`\n\n- `rowid INTEGER`\n- `id`\n- `chunk_id INTEGER`\n- `chunk_offset INTEGER`\n\n#### `xyz_vector_chunksNN`\n\n- `rowid INTEGER`\n- `vector BLOB`\n\n#### `xyz_auxiliary`\n\n- `rowid INTEGER`\n- `valueNN [type]`\n\n#### `xyz_metadatachunksNN`\n\n- `rowid INTEGER`\n- `data BLOB`\n\n#### `xyz_metadatatextNN`\n\n- `rowid INTEGER`\n- `data TEXT`\n\n### idxStr\n\nThe `vec0` idxStr is a string composed of single \"header\" character and 0 or\nmore \"blocks\" of 4 characters each.\n\nThe \"header\" charcter denotes the type of query plan, as determined by the\n`enum vec0_query_plan` values. The current possible values are:\n\n| Name                       | Value | Description                                                            |\n| -------------------------- | ----- | ---------------------------------------------------------------------- |\n| `VEC0_QUERY_PLAN_FULLSCAN` | `'1'` | Perform a full-scan on all rows                                        |\n| `VEC0_QUERY_PLAN_POINT`    | `'2'` | Perform a single-lookup point query for the provided rowid             |\n| `VEC0_QUERY_PLAN_KNN`      | `'3'` | Perform a KNN-style query on the provided query vector and parameters. |\n\nEach 4-character \"block\" is associated with a corresponding value in `argv[]`.\nFor example, the 1st block at byte offset `1-4` (inclusive) is the 1st block and\nis associated with `argv[1]`. The 2nd block at byte offset `5-8` (inclusive) is\nassociated with `argv[2]` and so on. Each block describes what kind of value or\nfilter the given `argv[i]` value is.\n\n#### `VEC0_IDXSTR_KIND_KNN_MATCH` (`'{'`)\n\n`argv[i]` is the query vector of the KNN query.\n\nThe remaining 3 characters of the block are `_` fillers.\n\n#### `VEC0_IDXSTR_KIND_KNN_K` (`'}'`)\n\n`argv[i]` is the limit/k value of the KNN query.\n\nThe remaining 3 characters of the block are `_` fillers.\n\n#### `VEC0_IDXSTR_KIND_KNN_ROWID_IN` (`'['`)\n\n`argv[i]` is the optional `rowid in (...)` value, and must be handled with\n[`sqlite3_vtab_in_first()` / `sqlite3_vtab_in_next()`](https://www.sqlite.org/c3ref/vtab_in_first.html).\n\nThe remaining 3 characters of the block are `_` fillers.\n\n#### `VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT` (`']'`)\n\n`argv[i]` is a \"constraint\" on a specific partition key.\n\nThe second character of the block denotes which partition key to filter on,\nusing `A` to denote the first partition key column, `B` for the second, etc. It\nis encoded with `'A' + partition_idx` and can be decoded with `c - 'A'`.\n\nThe third character of the block denotes which operator is used in the\nconstraint. It will be one of the values of `enum vec0_partition_operator`, as\nonly a subset of operations are supported on partition keys.\n\nThe fourth character of the block is a `_` filler.\n\n#### `VEC0_IDXSTR_KIND_POINT_ID` (`'!'`)\n\n`argv[i]` is the value of the rowid or id to match against for the point query.\n\nThe remaining 3 characters of the block are `_` fillers.\n\n#### `VEC0_IDXSTR_KIND_METADATA_CONSTRAINT` (`'&'`)\n\n`argv[i]` is the value of the `WHERE` constraint for a metdata column in a KNN\nquery.\n\nThe second character of the block denotes which metadata column the constraint\nbelongs to, using `A` to denote the first metadata column column, `B` for the\nsecond, etc. It is encoded with `'A' + metadata_idx` and can be decoded with\n`c - 'A'`.\n\nThe third character of the block is the constraint operator. It will be one of\n`enum vec0_metadata_operator`, as only a subset of operators are supported on\nmetadata column KNN filters.\n\nThe foruth character of the block is a `_` filler.\n"
        },
        {
          "name": "LICENSE-APACHE",
          "type": "blob",
          "size": 10.6748046875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1.  Definitions.\n\n    \"License\" shall mean the terms and conditions for use, reproduction,\n    and distribution as defined by Sections 1 through 9 of this document.\n\n    \"Licensor\" shall mean the copyright owner or entity authorized by\n    the copyright owner that is granting the License.\n\n    \"Legal Entity\" shall mean the union of the acting entity and all\n    other entities that control, are controlled by, or are under common\n    control with that entity. For the purposes of this definition,\n    \"control\" means (i) the power, direct or indirect, to cause the\n    direction or management of such entity, whether by contract or\n    otherwise, or (ii) ownership of fifty percent (50%) or more of the\n    outstanding shares, or (iii) beneficial ownership of such entity.\n\n    \"You\" (or \"Your\") shall mean an individual or Legal Entity\n    exercising permissions granted by this License.\n\n    \"Source\" form shall mean the preferred form for making modifications,\n    including but not limited to software source code, documentation\n    source, and configuration files.\n\n    \"Object\" form shall mean any form resulting from mechanical\n    transformation or translation of a Source form, including but\n    not limited to compiled object code, generated documentation,\n    and conversions to other media types.\n\n    \"Work\" shall mean the work of authorship, whether in Source or\n    Object form, made available under the License, as indicated by a\n    copyright notice that is included in or attached to the work\n    (an example is provided in the Appendix below).\n\n    \"Derivative Works\" shall mean any work, whether in Source or Object\n    form, that is based on (or derived from) the Work and for which the\n    editorial revisions, annotations, elaborations, or other modifications\n    represent, as a whole, an original work of authorship. For the purposes\n    of this License, Derivative Works shall not include works that remain\n    separable from, or merely link (or bind by name) to the interfaces of,\n    the Work and Derivative Works thereof.\n\n    \"Contribution\" shall mean any work of authorship, including\n    the original version of the Work and any modifications or additions\n    to that Work or Derivative Works thereof, that is intentionally\n    submitted to Licensor for inclusion in the Work by the copyright owner\n    or by an individual or Legal Entity authorized to submit on behalf of\n    the copyright owner. For the purposes of this definition, \"submitted\"\n    means any form of electronic, verbal, or written communication sent\n    to the Licensor or its representatives, including but not limited to\n    communication on electronic mailing lists, source code control systems,\n    and issue tracking systems that are managed by, or on behalf of, the\n    Licensor for the purpose of discussing and improving the Work, but\n    excluding communication that is conspicuously marked or otherwise\n    designated in writing by the copyright owner as \"Not a Contribution.\"\n\n    \"Contributor\" shall mean Licensor and any individual or Legal Entity\n    on behalf of whom a Contribution has been received by Licensor and\n    subsequently incorporated within the Work.\n\n2.  Grant of Copyright License. Subject to the terms and conditions of\n    this License, each Contributor hereby grants to You a perpetual,\n    worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n    copyright license to reproduce, prepare Derivative Works of,\n    publicly display, publicly perform, sublicense, and distribute the\n    Work and such Derivative Works in Source or Object form.\n\n3.  Grant of Patent License. Subject to the terms and conditions of\n    this License, each Contributor hereby grants to You a perpetual,\n    worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n    (except as stated in this section) patent license to make, have made,\n    use, offer to sell, sell, import, and otherwise transfer the Work,\n    where such license applies only to those patent claims licensable\n    by such Contributor that are necessarily infringed by their\n    Contribution(s) alone or by combination of their Contribution(s)\n    with the Work to which such Contribution(s) was submitted. If You\n    institute patent litigation against any entity (including a\n    cross-claim or counterclaim in a lawsuit) alleging that the Work\n    or a Contribution incorporated within the Work constitutes direct\n    or contributory patent infringement, then any patent licenses\n    granted to You under this License for that Work shall terminate\n    as of the date such litigation is filed.\n\n4.  Redistribution. You may reproduce and distribute copies of the\n    Work or Derivative Works thereof in any medium, with or without\n    modifications, and in Source or Object form, provided that You\n    meet the following conditions:\n\n    (a) You must give any other recipients of the Work or\n    Derivative Works a copy of this License; and\n\n    (b) You must cause any modified files to carry prominent notices\n    stating that You changed the files; and\n\n    (c) You must retain, in the Source form of any Derivative Works\n    that You distribute, all copyright, patent, trademark, and\n    attribution notices from the Source form of the Work,\n    excluding those notices that do not pertain to any part of\n    the Derivative Works; and\n\n    (d) If the Work includes a \"NOTICE\" text file as part of its\n    distribution, then any Derivative Works that You distribute must\n    include a readable copy of the attribution notices contained\n    within such NOTICE file, excluding those notices that do not\n    pertain to any part of the Derivative Works, in at least one\n    of the following places: within a NOTICE text file distributed\n    as part of the Derivative Works; within the Source form or\n    documentation, if provided along with the Derivative Works; or,\n    within a display generated by the Derivative Works, if and\n    wherever such third-party notices normally appear. The contents\n    of the NOTICE file are for informational purposes only and\n    do not modify the License. You may add Your own attribution\n    notices within Derivative Works that You distribute, alongside\n    or as an addendum to the NOTICE text from the Work, provided\n    that such additional attribution notices cannot be construed\n    as modifying the License.\n\n    You may add Your own copyright statement to Your modifications and\n    may provide additional or different license terms and conditions\n    for use, reproduction, or distribution of Your modifications, or\n    for any such Derivative Works as a whole, provided Your use,\n    reproduction, and distribution of the Work otherwise complies with\n    the conditions stated in this License.\n\n5.  Submission of Contributions. Unless You explicitly state otherwise,\n    any Contribution intentionally submitted for inclusion in the Work\n    by You to the Licensor shall be under the terms and conditions of\n    this License, without any additional terms or conditions.\n    Notwithstanding the above, nothing herein shall supersede or modify\n    the terms of any separate license agreement you may have executed\n    with Licensor regarding such Contributions.\n\n6.  Trademarks. This License does not grant permission to use the trade\n    names, trademarks, service marks, or product names of the Licensor,\n    except as required for reasonable and customary use in describing the\n    origin of the Work and reproducing the content of the NOTICE file.\n\n7.  Disclaimer of Warranty. Unless required by applicable law or\n    agreed to in writing, Licensor provides the Work (and each\n    Contributor provides its Contributions) on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n    implied, including, without limitation, any warranties or conditions\n    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n    PARTICULAR PURPOSE. You are solely responsible for determining the\n    appropriateness of using or redistributing the Work and assume any\n    risks associated with Your exercise of permissions under this License.\n\n8.  Limitation of Liability. In no event and under no legal theory,\n    whether in tort (including negligence), contract, or otherwise,\n    unless required by applicable law (such as deliberate and grossly\n    negligent acts) or agreed to in writing, shall any Contributor be\n    liable to You for damages, including any direct, indirect, special,\n    incidental, or consequential damages of any character arising as a\n    result of this License or out of the use or inability to use the\n    Work (including but not limited to damages for loss of goodwill,\n    work stoppage, computer failure or malfunction, or any and all\n    other commercial damages or losses), even if such Contributor\n    has been advised of the possibility of such damages.\n\n9.  Accepting Warranty or Additional Liability. While redistributing\n    the Work or Derivative Works thereof, You may choose to offer,\n    and charge a fee for, acceptance of support, warranty, indemnity,\n    or other liability obligations and/or rights consistent with this\n    License. However, in accepting such obligations, You may act only\n    on Your own behalf and on Your sole responsibility, not on behalf\n    of any other Contributor, and only if You agree to indemnify,\n    defend, and hold each Contributor harmless for any liability\n    incurred by, or claims asserted against, such Contributor by reason\n    of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\nCopyright 2024 Alex Garcia\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2024 Alex Garcia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 7.5625,
          "content": "\nCOMMIT=$(shell git rev-parse HEAD)\nVERSION=$(shell cat VERSION)\nDATE=$(shell date +'%FT%TZ%z')\n\nINSTALL_LIB_DIR = /usr/local/lib\nINSTALL_INCLUDE_DIR = /usr/local/include\nINSTALL_BIN_DIR = /usr/local/bin\n\nifndef CC\nCC=gcc\nendif\nifndef AR\nAR=ar\nendif\n\nifeq ($(shell uname -s),Darwin)\nCONFIG_DARWIN=y\nelse ifeq ($(OS),Windows_NT)\nCONFIG_WINDOWS=y\nelse\nCONFIG_LINUX=y\nendif\n\nifdef CONFIG_DARWIN\nLOADABLE_EXTENSION=dylib\nendif\n\nifdef CONFIG_LINUX\nLOADABLE_EXTENSION=so\nCFLAGS += -lm\nendif\n\nifdef CONFIG_WINDOWS\nLOADABLE_EXTENSION=dll\nendif\n\n\nifdef python\nPYTHON=$(python)\nelse\nPYTHON=python3\nendif\n\nifndef OMIT_SIMD\n\tifeq ($(shell uname -sm),Darwin x86_64)\n\tCFLAGS += -mavx -DSQLITE_VEC_ENABLE_AVX\n\tendif\n\tifeq ($(shell uname -sm),Darwin arm64)\n\tCFLAGS += -mcpu=apple-m1 -DSQLITE_VEC_ENABLE_NEON\n\tendif\nendif\n\nifdef USE_BREW_SQLITE\n\tSQLITE_INCLUDE_PATH=-I/opt/homebrew/opt/sqlite/include\n\tSQLITE_LIB_PATH=-L/opt/homebrew/opt/sqlite/lib\n\tCFLAGS += $(SQLITE_INCLUDE_PATH) $(SQLITE_LIB_PATH)\nendif\n\nifdef IS_MACOS_ARM\nRENAME_WHEELS_ARGS=--is-macos-arm\nelse\nRENAME_WHEELS_ARGS=\nendif\n\nprefix=dist\n$(prefix):\n\tmkdir -p $(prefix)\n\nTARGET_LOADABLE=$(prefix)/vec0.$(LOADABLE_EXTENSION)\nTARGET_STATIC=$(prefix)/libsqlite_vec0.a\nTARGET_STATIC_H=$(prefix)/sqlite-vec.h\nTARGET_CLI=$(prefix)/sqlite3\n\nloadable: $(TARGET_LOADABLE)\nstatic: $(TARGET_STATIC)\ncli: $(TARGET_CLI)\n\nall: loadable static cli\n\nOBJS_DIR=$(prefix)/.objs\nLIBS_DIR=$(prefix)/.libs\nBUILD_DIR=$(prefix)/.build\n\n$(OBJS_DIR): $(prefix)\n\tmkdir -p $@\n\n$(LIBS_DIR): $(prefix)\n\tmkdir -p $@\n\n$(BUILD_DIR): $(prefix)\n\tmkdir -p $@\n\n\n$(TARGET_LOADABLE): sqlite-vec.c sqlite-vec.h $(prefix)\n\t$(CC) \\\n\t\t-fPIC -shared \\\n\t\t-Wall -Wextra \\\n\t\t-Ivendor/ \\\n\t\t-O3 \\\n\t\t$(CFLAGS) \\\n\t\t$< -o $@\n\n$(TARGET_STATIC): sqlite-vec.c sqlite-vec.h $(prefix) $(OBJS_DIR)\n\t$(CC) -Ivendor/ $(CFLAGS) -DSQLITE_CORE -DSQLITE_VEC_STATIC \\\n\t-O3 -c  $< -o $(OBJS_DIR)/vec.o\n\t$(AR) rcs $@ $(OBJS_DIR)/vec.o\n\n$(TARGET_STATIC_H): sqlite-vec.h $(prefix)\n\tcp $< $@\n\n\n$(OBJS_DIR)/sqlite3.o: vendor/sqlite3.c $(OBJS_DIR)\n\t$(CC) -c -g3 -O3 -DSQLITE_EXTRA_INIT=core_init -DSQLITE_CORE -DSQLITE_ENABLE_STMT_SCANSTATUS -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_EXPLAIN_COMMENTS -I./vendor $< -o $@\n\n$(LIBS_DIR)/sqlite3.a: $(OBJS_DIR)/sqlite3.o $(LIBS_DIR)\n\t$(AR) rcs $@ $<\n\n$(BUILD_DIR)/shell-new.c: vendor/shell.c $(BUILD_DIR)\n\tsed 's/\\/\\*extra-version-info\\*\\//EXTRA_TODO/g' $< > $@\n\n$(OBJS_DIR)/shell.o: $(BUILD_DIR)/shell-new.c $(OBJS_DIR)\n\t$(CC) -c -g3 -O3 \\\n\t\t-I./vendor \\\n\t\t-DSQLITE_ENABLE_STMT_SCANSTATUS -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_EXPLAIN_COMMENTS \\\n\t\t-DEXTRA_TODO=\"\\\"CUSTOMBUILD:sqlite-vec\\n\\\"\" \\\n\t\t$< -o $@\n\n$(LIBS_DIR)/shell.a: $(OBJS_DIR)/shell.o $(LIBS_DIR)\n\t$(AR) rcs $@ $<\n\n$(OBJS_DIR)/sqlite-vec.o: sqlite-vec.c $(OBJS_DIR)\n\t$(CC) -c -g3 -Ivendor/ -I./ $(CFLAGS) $< -o $@\n\n$(LIBS_DIR)/sqlite-vec.a: $(OBJS_DIR)/sqlite-vec.o $(LIBS_DIR)\n\t$(AR) rcs $@ $<\n\n\n$(TARGET_CLI): sqlite-vec.h $(LIBS_DIR)/sqlite-vec.a $(LIBS_DIR)/shell.a $(LIBS_DIR)/sqlite3.a examples/sqlite3-cli/core_init.c $(prefix)\n\t$(CC) -g3  \\\n\t-Ivendor/ -I./ \\\n\t-DSQLITE_CORE \\\n\t-DSQLITE_VEC_STATIC \\\n\t-DSQLITE_THREADSAFE=0 -DSQLITE_ENABLE_FTS4 \\\n\t-DSQLITE_ENABLE_STMT_SCANSTATUS -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_EXPLAIN_COMMENTS \\\n\t-DSQLITE_EXTRA_INIT=core_init \\\n\t$(CFLAGS) \\\n\t-ldl -lm \\\n\texamples/sqlite3-cli/core_init.c $(LIBS_DIR)/shell.a $(LIBS_DIR)/sqlite3.a $(LIBS_DIR)/sqlite-vec.a -o $@\n\n\nsqlite-vec.h: sqlite-vec.h.tmpl VERSION\n\tVERSION=$(shell cat VERSION) \\\n\tDATE=$(shell date -r VERSION +'%FT%TZ%z') \\\n\tSOURCE=$(shell git log -n 1 --pretty=format:%H -- VERSION) \\\n\tVERSION_MAJOR=$$(echo $$VERSION | cut -d. -f1) \\\n\tVERSION_MINOR=$$(echo $$VERSION | cut -d. -f2) \\\n\tVERSION_PATCH=$$(echo $$VERSION | cut -d. -f3 | cut -d- -f1) \\\n\tenvsubst < $< > $@\n\nclean:\n\trm -rf dist\n\n\nFORMAT_FILES=sqlite-vec.h sqlite-vec.c\nformat: $(FORMAT_FILES)\n\tclang-format -i $(FORMAT_FILES)\n\tblack tests/test-loadable.py\n\nlint: SHELL:=/bin/bash\nlint:\n\tdiff -u <(cat $(FORMAT_FILES)) <(clang-format $(FORMAT_FILES))\n\nprogress:\n\tdeno run --allow-read=sqlite-vec.c scripts/progress.ts\n\n\nevidence-of:\n\t@echo \"EVIDENCE-OF: V$(shell printf \"%05d\" $$((RANDOM % 100000)))_$(shell printf \"%05d\" $$((RANDOM % 100000)))\"\n\ntest:\n\tsqlite3 :memory: '.read test.sql'\n\n.PHONY: version loadable static test clean gh-release evidence-of install uninstall\n\npublish-release:\n\t./scripts/publish-release.sh\n\n# -k test_vec0_update\ntest-loadable: loadable\n\t$(PYTHON) -m pytest -vv -s -x tests/test-*.py\n\ntest-loadable-snapshot-update: loadable\n\t$(PYTHON) -m pytest -vv tests/test-loadable.py --snapshot-update\n\ntest-loadable-watch:\n\twatchexec --exts c,py,Makefile --clear -- make test-loadable\n\ntest-unit:\n\t$(CC) tests/test-unit.c sqlite-vec.c -I./ -Ivendor -o $(prefix)/test-unit && $(prefix)/test-unit\n\nsite-dev:\n\tnpm --prefix site run dev\n\nsite-build:\n\tnpm --prefix site run build\n\ninstall:\n\tinstall -d $(INSTALL_LIB_DIR)\n\tinstall -d $(INSTALL_INCLUDE_DIR)\n\tinstall -m 644 sqlite-vec.h $(INSTALL_INCLUDE_DIR)\n\t@if [ -f $(TARGET_LOADABLE) ]; then \\\n\t\tinstall -m 644 $(TARGET_LOADABLE) $(INSTALL_LIB_DIR); \\\n\tfi\n\t@if [ -f $(TARGET_STATIC) ]; then \\\n\t\tinstall -m 644 $(TARGET_STATIC) $(INSTALL_LIB_DIR); \\\n\tfi\n\t@if [ -f $(TARGET_CLI) ]; then \\\n\t\tsudo install -m 755 $(TARGET_CLI) $(INSTALL_BIN_DIR); \\\n\tfi\n\tldconfig\n\nuninstall:\n\trm -f $(INSTALL_LIB_DIR)/$(notdir $(TARGET_LOADABLE))\n\trm -f $(INSTALL_LIB_DIR)/$(notdir $(TARGET_STATIC))\n\trm -f $(INSTALL_LIB_DIR)/$(notdir $(TARGET_CLI))\n\trm -f $(INSTALL_INCLUDE_DIR)/sqlite-vec.h\n\tldconfig\n\n# ███████████████████████████████ WASM SECTION ███████████████████████████████\n\nWASM_DIR=$(prefix)/.wasm\n\n$(WASM_DIR): $(prefix)\n\tmkdir -p $@\n\nSQLITE_WASM_VERSION=3450300\nSQLITE_WASM_YEAR=2024\nSQLITE_WASM_SRCZIP=$(BUILD_DIR)/sqlite-src.zip\nSQLITE_WASM_COMPILED_SQLITE3C=$(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/sqlite3.c\nSQLITE_WASM_COMPILED_MJS=$(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/ext/wasm/jswasm/sqlite3.mjs\nSQLITE_WASM_COMPILED_WASM=$(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/ext/wasm/jswasm/sqlite3.wasm\n\nTARGET_WASM_LIB=$(WASM_DIR)/libsqlite_vec.wasm.a\nTARGET_WASM_MJS=$(WASM_DIR)/sqlite3.mjs\nTARGET_WASM_WASM=$(WASM_DIR)/sqlite3.wasm\nTARGET_WASM=$(TARGET_WASM_MJS) $(TARGET_WASM_WASM)\n\n$(SQLITE_WASM_SRCZIP): $(BUILD_DIR)\n\tcurl -o $@ https://www.sqlite.org/$(SQLITE_WASM_YEAR)/sqlite-src-$(SQLITE_WASM_VERSION).zip\n\ttouch $@\n\n$(SQLITE_WASM_COMPILED_SQLITE3C): $(SQLITE_WASM_SRCZIP) $(BUILD_DIR)\n\trm -rf $(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/ || true\n\tunzip -q -o $< -d $(BUILD_DIR)\n\t(cd $(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/ && ./configure --enable-all && make sqlite3.c)\n\ttouch $@\n\n$(TARGET_WASM_LIB): examples/wasm/wasm.c sqlite-vec.c $(BUILD_DIR) $(WASM_DIR)\n\temcc -O3  -I./ -Ivendor -DSQLITE_CORE -c examples/wasm/wasm.c -o $(BUILD_DIR)/wasm.wasm.o\n\temcc -O3  -I./ -Ivendor -DSQLITE_CORE -c sqlite-vec.c -o $(BUILD_DIR)/sqlite-vec.wasm.o\n\temar rcs $@ $(BUILD_DIR)/wasm.wasm.o $(BUILD_DIR)/sqlite-vec.wasm.o\n\n$(SQLITE_WASM_COMPILED_MJS) $(SQLITE_WASM_COMPILED_WASM): $(SQLITE_WASM_COMPILED_SQLITE3C) $(TARGET_WASM_LIB)\n\t(cd $(BUILD_DIR)/sqlite-src-$(SQLITE_WASM_VERSION)/ext/wasm && \\\n\t\tmake sqlite3_wasm_extra_init.c=../../../../.wasm/libsqlite_vec.wasm.a jswasm/sqlite3.mjs jswasm/sqlite3.wasm \\\n\t)\n\n$(TARGET_WASM_MJS): $(SQLITE_WASM_COMPILED_MJS)\n\tcp $< $@\n\n$(TARGET_WASM_WASM): $(SQLITE_WASM_COMPILED_WASM)\n\tcp $< $@\n\nwasm: $(TARGET_WASM)\n\n# ███████████████████████████████   END WASM   ███████████████████████████████\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.751953125,
          "content": "# `sqlite-vec`\n\n[![](https://dcbadge.vercel.app/api/server/VCtQ8cGhUs)](https://discord.gg/Ve7WeCJFXk)\n\nAn extremely small, \"fast enough\" vector search SQLite extension that runs\nanywhere! A successor to [`sqlite-vss`](https://github.com/asg017/sqlite-vss)\n\n<!-- deno-fmt-ignore-start -->\n\n> [!IMPORTANT]\n> _`sqlite-vec` is a pre-v1, so expect breaking changes!_\n\n<!-- deno-fmt-ignore-end -->\n\n- Store and query float, int8, and binary vectors in `vec0` virtual tables\n- Written in pure C, no dependencies, runs anywhere SQLite runs\n  (Linux/MacOS/Windows, in the browser with WASM, Raspberry Pis, etc.)\n- Pre-filter vectors with `rowid IN (...)` subqueries\n\n<p align=\"center\">\n  <a href=\"https://hacks.mozilla.org/2024/06/sponsoring-sqlite-vec-to-enable-more-powerful-local-ai-applications/\">\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"./.github/logos/mozilla.dark.svg\">\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"./.github/logos/mozilla.svg\">\n    <img alt=\"Mozilla Builders logo\" width=400>\n  </picture>\n  </a>\n</p>\n\n<p align=\"center\">\n<i>\n<code>sqlite-vec</code> is a\n<a href=\"https://hacks.mozilla.org/2024/06/sponsoring-sqlite-vec-to-enable-more-powerful-local-ai-applications/\">Mozilla Builders project</a>,\nwith additional sponsorship from\n<a href=\"https://fly.io/\"><img width=14px src=\"./.github/logos/flyio.small.ico\"/> Fly.io </a>,\n<a href=\"https://tur.so/sqlite-vec\"><img width=14px src=\"./.github/logos/turso.small.ico\"/> Turso</a>, and\n<a href=\"https://sqlitecloud.io/\"><img width=14px src=\"./.github/logos/sqlitecloud.small.svg\"/> SQLite Cloud</a>.\nSee <a href=\"#sponsors\">the Sponsors section</a> for more details.\n</i>\n</p>\n\n## Installing\n\nSee [Installing `sqlite-vec`](https://alexgarcia.xyz/sqlite-vec/installation.html)\nfor more details.\n\n| Language       | Install                                              | More Info                                                                             |                                                                                                                                                                                                    |\n| -------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Python         | `pip install sqlite-vec`                             | [`sqlite-vec` with Python](https://alexgarcia.xyz/sqlite-vec/python.html)             | [![PyPI](https://img.shields.io/pypi/v/sqlite-vec.svg?color=blue&logo=python&logoColor=white)](https://pypi.org/project/sqlite-vec/)                                                               |\n| Node.js        | `npm install sqlite-vec`                             | [`sqlite-vec` with Node.js](https://alexgarcia.xyz/sqlite-vec/js.html)            | [![npm](https://img.shields.io/npm/v/sqlite-vec.svg?color=green&logo=nodedotjs&logoColor=white)](https://www.npmjs.com/package/sqlite-vec)                                                         |\n| Ruby           | `gem install sqlite-vec`                             | [`sqlite-vec` with Ruby](https://alexgarcia.xyz/sqlite-vec/ruby.html)                 | ![Gem](https://img.shields.io/gem/v/sqlite-vec?color=red&logo=rubygems&logoColor=white)                                                                       |\n| Go             | `go get -u github.com/asg017/sqlite-vec/bindings/go` | [`sqlite-vec` with Go](https://alexgarcia.xyz/sqlite-vec/go.html)                     | [![Go Reference](https://pkg.go.dev/badge/github.com/asg017/sqlite-vec-go-bindings/cgo.svg)](https://pkg.go.dev/github.com/asg017/asg017/sqlite-vec-go-bindings/cgo)                                              |\n| Rust           | `cargo add sqlite-vec`                               | [`sqlite-vec` with Rust](https://alexgarcia.xyz/sqlite-vec/rust.html)                 | [![Crates.io](https://img.shields.io/crates/v/sqlite-vec?logo=rust)](https://crates.io/crates/sqlite-vec)                                                                                          |\n| Datasette      | `datasette install datasette-sqlite-vec`             | [`sqlite-vec` with Datasette](https://alexgarcia.xyz/sqlite-vec/datasette.html)       | [![Datasette](https://img.shields.io/pypi/v/datasette-sqlite-vec.svg?color=B6B6D9&label=Datasette+plugin&logoColor=white&logo=python)](https://datasette.io/plugins/datasette-sqlite-vec)          |\n| rqlite         | `rqlited -extensions-path=sqlite-vec.tar.gz`         | [`sqlite-vec` with rqlite](https://alexgarcia.xyz/sqlite-vec/rqlite.html)                        | [![rqlite](https://img.shields.io/badge/rqlite-sqlite_extensions-blue)](https://rqlite.io/docs/guides/extensions/)           |\n| `sqlite-utils` | `sqlite-utils install sqlite-utils-sqlite-vec`       | [`sqlite-vec` with sqlite-utils](https://alexgarcia.xyz/sqlite-vec/sqlite-utils.html) | [![sqlite-utils](https://img.shields.io/pypi/v/sqlite-utils-sqlite-vec.svg?color=B6B6D9&label=sqlite-utils+plugin&logoColor=white&logo=python)](https://datasette.io/plugins/datasette-sqlite-vec) |\n| Github Release |                                                      |                                                                                       | ![GitHub tag (latest SemVer pre-release)](https://img.shields.io/github/v/tag/asg017/sqlite-vec?color=lightgrey&include_prereleases&label=Github+release&logo=github)                              |\n\n\n## Sample usage\n\n```sql\n.load ./vec0\n\ncreate virtual table vec_examples using vec0(\n  sample_embedding float[8]\n);\n\n-- vectors can be provided as JSON or in a compact binary format\ninsert into vec_examples(rowid, sample_embedding)\n  values\n    (1, '[-0.200, 0.250, 0.341, -0.211, 0.645, 0.935, -0.316, -0.924]'),\n    (2, '[0.443, -0.501, 0.355, -0.771, 0.707, -0.708, -0.185, 0.362]'),\n    (3, '[0.716, -0.927, 0.134, 0.052, -0.669, 0.793, -0.634, -0.162]'),\n    (4, '[-0.710, 0.330, 0.656, 0.041, -0.990, 0.726, 0.385, -0.958]');\n\n\n-- KNN style query\nselect\n  rowid,\n  distance\nfrom vec_examples\nwhere sample_embedding match '[0.890, 0.544, 0.825, 0.961, 0.358, 0.0196, 0.521, 0.175]'\norder by distance\nlimit 2;\n/*\n┌───────┬──────────────────┐\n│ rowid │     distance     │\n├───────┼──────────────────┤\n│ 2     │ 2.38687372207642 │\n│ 1     │ 2.38978505134583 │\n└───────┴──────────────────┘\n*/\n```\n\n## Sponsors\n\nDevelopment of `sqlite-vec` is supported by multiple generous sponsors! Mozilla\nis the main sponsor through the new Builders project.\n\n<p align=\"center\">\n  <a href=\"https://hacks.mozilla.org/2024/06/sponsoring-sqlite-vec-to-enable-more-powerful-local-ai-applications/\">\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"./.github/logos/mozilla.dark.svg\">\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"./.github/logos/mozilla.svg\">\n    <img alt=\"Mozilla Builders logo\" width=400>\n  </picture>\n  </a>\n</p>\n\n`sqlite-vec` is also sponsored by the following companies:\n\n<a href=\"https://fly.io/\">\n<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"./.github/logos/flyio.dark.svg\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"./.github/logos/flyio.svg\">\n  <img alt=\"Fly.io logo\" src=\"./.github/logos/flyio.svg\" width=\"32%\">\n</picture>\n</a>\n\n<a href=\"https://tur.so/sqlite-vec\">\n<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"./.github/logos/turso.svg\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"./.github/logos/turso.svg\">\n  <img alt=\"Turso logo\" src=\"./.github/logos/turso.svg\" width=\"32%\">\n</picture>\n</a>\n\n<a href=\"https://sqlitecloud.io/\">\n<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"./.github/logos/sqlitecloud.dark.svg\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"./.github/logos/sqlitecloud.svg\">\n  <img alt=\"SQLite Cloud logo\" src=\"./.github/logos/flyio.svg\" width=\"32%\">\n</picture>\n</a>\n\nAs well as multiple individual supporters on\n[Github sponsors](https://github.com/sponsors/asg017/)!\n\nIf your company interested in sponsoring `sqlite-vec` development, send me an\nemail to get more info: https://alexgarcia.xyz\n\n## See Also\n\n- [**`sqlite-ecosystem`**](https://github.com/asg017/sqlite-ecosystem), Maybe\n  more 3rd party SQLite extensions I've developed\n- [**`sqlite-rembed`**](https://github.com/asg017/sqlite-rembed), Generate text\n  embeddings from remote APIs like OpenAI/Nomic/Ollama, meant for testing and\n  SQL scripts\n- [**`sqlite-lembed`**](https://github.com/asg017/sqlite-lembed), Generate text\n  embeddings locally from embedding models in the `.gguf` format\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1748046875,
          "content": "Please report any security vulnerabilities to alexsebastian.garcia@gmail.com . Avould using public Github issues whenever possible. I will get back to you as quickly as possible.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.6015625,
          "content": "- [ ] add `xyz_info` shadow table with version etc.\n\n- later\n  - [ ] partition: UPDATE support\n  - [ ] skip invalid validity entries in knn filter?\n  - [ ] nulls in metadata\n  - [ ] partition `x in (...)` handling\n  - [ ] blobs/date/datetime\n  - [ ] uuid/ulid perf\n  - [ ] Aux columns: `NOT NULL` constraint\n  - [ ] Metadata columns: `NOT NULL` constraint\n   - [ ] Partiion key: `NOT NULL` constraint\n  - [ ] dictionary encoding?\n  - [ ] properly sqlite3_vtab_nochange / sqlite3_value_nochange handling\n  - [ ] perf\n    - [ ] aux: cache INSERT\n    - [ ] aux: LEFT JOIN on `_rowids` queries to avoid N lookup queries\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0126953125,
          "content": "0.1.7-alpha.2"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "bindings",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "reference.yaml",
          "type": "blob",
          "size": 11.95703125,
          "content": "sections:\n  constructors:\n    title: Constructors\n    desc: |\n      SQL functions that \"construct\" vectors with different element types.\n\n      Currently, only `float32`, `int8`, and `bit` vectors are supported.\n\n  op:\n    title: Operations\n    desc: |\n      Different operations and utilities for working with vectors.\n  distance:\n    title: Distance functions\n    desc: Various algorithms to calculate distance between two vectors.\n  quantization:\n    title: Quantization\n    desc: Various techniques to \"compress\" a vector by reducing precision and accuracy.\n  numpy:\n    title: \"NumPy Utilities\"\n    desc: Functions to read data from or work with [NumPy arrays](https://numpy.org/doc/stable/reference/generated/numpy.array.html).\n  meta:\n    title: Meta\n    desc: Helper functions to debug `sqlite-vec` installations.\n  entrypoints:\n    title: Entrypoints\n    desc: All the named entrypoints that load in different `sqlite-vec` functions and options.\n#  vec0:\n#    title: \"vec0 Virtual Table\"\n#    desc: TODO\nmeta:\n  vec_version:\n    params: []\n    desc: Returns a version string of the current `sqlite-vec` installation.\n    example: select vec_version();\n  vec_debug:\n    params: []\n    desc: Returns debugging information of the current `sqlite-vec` installation.\n    example: select vec_debug();\nconstructors:\n  vec_f32:\n    params: [vector]\n    desc: |\n      Creates a float vector from a BLOB or JSON text. If a BLOB is provided,\n      the length must be divisible by 4, as a float takes up 4 bytes of space each.\n\n      The returned value is a BLOB with 4 bytes per element, with a special [subtype](https://www.sqlite.org/c3ref/result_subtype.html)\n      of `223`.\n    example:\n      - select vec_f32('[.1, .2, .3, 4]');\n      - select subtype(vec_f32('[.1, .2, .3, 4]'));\n      - select vec_f32(X'AABBCCDD');\n      - select vec_to_json(vec_f32(X'AABBCCDD'));\n      - select vec_f32(X'AA');\n  vec_int8:\n    params: [vector]\n    desc: |\n      Creates a 8-bit integer vector from a BLOB or JSON text. If a BLOB is provided,\n      the length must be divisible by 4, as a float takes up 4 bytes of space each.\n      If JSON text is provided, each element must be an integer between -128 and 127 inclusive.\n\n      The returned value is a BLOB with 1 byte per element, with a special [subtype](https://www.sqlite.org/c3ref/result_subtype.html)\n      of `225`.\n\n    example:\n      - select vec_int8('[1, 2, 3, 4]');\n      - select subtype(vec_int8('[1, 2, 3, 4]'));\n      - select vec_int8(X'AABBCCDD');\n      - select vec_to_json(vec_int8(X'AABBCCDD'));\n      - select vec_int8('[999]');\n\n  vec_bit:\n    params: [vector]\n    desc: |\n      Creates a binary vector from a BLOB.\n\n      The returned value is a BLOB with 1 byte per 8 elements, with a special [subtype](https://www.sqlite.org/c3ref/result_subtype.html)\n      of `224`.\n    example:\n      - select vec_bit(X'F0');\n      - select subtype(vec_bit(X'F0'));\n      - select vec_to_json(vec_bit(X'F0'));\nop:\n  vec_length:\n    params: [vector]\n    desc: |\n      Returns the number of elements in the given vector.\n      The vector can be `JSON`, `BLOB`, or the result of a [constructor function](#constructors).\n\n      This function will return an error if `vector` is invalid.\n    example:\n      - select vec_length('[.1, .2]');\n      - select vec_length(X'AABBCCDD');\n      - select vec_length(vec_int8(X'AABBCCDD'));\n      - select vec_length(vec_bit(X'AABBCCDD'));\n      - select vec_length(X'CCDD');\n  vec_type:\n    params: [vector]\n    desc: |\n      Returns the name of the type of `vector` as text. One of `'float32'`, `'int8'`, or `'bit'`.\n\n      This function will return an error if `vector` is invalid.\n    example:\n      - select vec_type('[.1, .2]');\n      - select vec_type(X'AABBCCDD');\n      - select vec_type(vec_int8(X'AABBCCDD'));\n      - select vec_type(vec_bit(X'AABBCCDD'));\n      - select vec_type(X'CCDD');\n  vec_add:\n    params: [a, b]\n    desc: |\n      Adds every element in vector `a` with vector `b`, returning a new vector `c`. Both vectors\n      must be of the same type and same length. Only `float32` and `int8` vectors are supported.\n\n      An error is raised if either `a` or `b` are invalid, or if they are not the same type or same length.\n\n      See also [`vec_sub()`](#vec_sub).\n\n    example:\n      - |\n        select vec_add(\n          '[.1, .2, .3]',\n          '[.4, .5, .6]'\n        );\n      - |\n        select vec_to_json(\n          vec_add(\n            '[.1, .2, .3]',\n            '[.4, .5, .6]'\n          )\n        );\n      - |\n        select vec_to_json(\n          vec_add(\n            vec_int8('[1, 2, 3]'),\n            vec_int8('[4, 5, 6]')\n          )\n        );\n      - select vec_add('[.1]', vec_int8('[1]'));\n      - select vec_add(vec_bit(X'AA'), vec_bit(X'BB'));\n  vec_sub:\n    params: [a, b]\n    desc: |\n      Subtracts every element in vector `a` with vector `b`, returning a new vector `c`. Both vectors\n      must be of the same type and same length. Only `float32` and `int8` vectors are supported.\n\n      An error is raised if either `a` or `b` are invalid, or if they are not the same type or same length.\n\n      See also [`vec_add()`](#vec_add).\n\n    example:\n      - |\n        select vec_sub(\n          '[.1, .2, .3]',\n          '[.4, .5, .6]'\n        );\n      - |\n        select vec_to_json(\n          vec_sub(\n            '[.1, .2, .3]',\n            '[.4, .5, .6]'\n          )\n        );\n      - |\n        select vec_to_json(\n          vec_sub(\n            vec_int8('[1, 2, 3]'),\n            vec_int8('[4, 5, 6]')\n          )\n        );\n      - select vec_sub('[.1]', vec_int8('[1]'));\n      - select vec_sub(vec_bit(X'AA'), vec_bit(X'BB'));\n  vec_normalize:\n    params: [vector]\n    desc: |\n      Performs L2 normalization on the given vector. Only float32 vectors are currently supported.\n\n      Returns an error if the input is an invalid vector or not a float32 vector.\n    example:\n      - select vec_normalize('[2, 3, 1, -4]');\n      - |\n        select vec_to_json(\n          vec_normalize('[2, 3, 1, -4]')\n        );\n      - |\n        -- for matryoshka embeddings - slice then normalize\n        select vec_to_json(\n          vec_normalize(\n            vec_slice('[2, 3, 1, -4]', 0, 2)\n          )\n        );\n  vec_slice:\n    params: [vector, start, end]\n    desc: |\n      Extract a subset of `vector` from the `start` element (inclusive) to the `end` element (exclusive). TODO check\n\n      This is especially useful for [Matryoshka embeddings](#TODO), also known as \"adaptive length\" embeddings.\n      Use with [`vec_normalize()`](#vec_normalize) to get proper results.\n\n      Returns an error in the following conditions:\n        - If `vector` is not a valid vector\n        - If `start` is less than zero or greater than or equal to `end`\n        - If `end` is greater than the length of `vector`, or less than or equal to `start`.\n        - If `vector` is a bitvector, `start` and `end` must be divisible by 8.\n    example:\n      - select vec_slice('[1, 2,3, 4]', 0, 2);\n      - |\n        select vec_to_json(\n          vec_slice('[1, 2,3, 4]', 0, 2)\n        );\n      - |\n        select vec_to_json(\n          vec_slice('[1, 2,3, 4]', 2, 4)\n        );\n      - |\n        select vec_to_json(\n          vec_slice('[1, 2,3, 4]', -1, 4)\n        );\n      - |\n        select vec_to_json(\n          vec_slice('[1, 2,3, 4]', 0, 5)\n        );\n      - |\n        select vec_to_json(\n          vec_slice('[1, 2,3, 4]', 0, 0)\n        );\n  vec_to_json:\n    params: [vector]\n    desc: |\n      Represents a vector as JSON text. The input vector can be a vector BLOB or JSON text.\n\n      Returns an error if `vector` is an invalid vector, or when memory cannot be allocated.\n    example:\n      - select vec_to_json(X'AABBCCDD');\n      - select vec_to_json(vec_int8(X'AABBCCDD'));\n      - select vec_to_json(vec_bit(X'AABBCCDD'));\n      - select vec_to_json('[1,2,3,4]');\n      - select vec_to_json('invalid');\n  vec_each:\n    params: [vector]\n    desc: |\n      A table function to iterate through every element in a vector. One row id returned per element in a vector.\n\n      ```sql\n      CREATE TABLE vec_each(\n        rowid int,    -- The\n        vector HIDDEN -- input parameter: A well-formed vector value\n      )\n      ```\n\n      Returns an error if `vector` is not a valid vector.\n    example:\n      - select rowid, value from vec_each('[1,2,3,4]');\n      - select rowid, value from vec_each(X'AABBCCDD00112233');\n      - select rowid, value from vec_each(vec_int8(X'AABBCCDD'));\n      - select rowid, value from vec_each(vec_bit(X'F0'));\n\ndistance:\n  vec_distance_L2:\n    params: [a, b]\n    desc: |\n      Calculates the L2 euclidian distance between vectors `a` and `b`. Only valid for float32 or int8 vectors.\n\n      Returns an error under the following conditions:\n      - `a` or `b` are invalid vectors\n      - `a` or `b` do not share the same vector element types (ex float32 or int8)\n      - `a` or `b` are bit vectors. Use [`vec_distance_hamming()`](#vec_distance_hamming) for distance calculations between two bitvectors.\n      - `a` or `b` do not have the same length.\n    example:\n      - select vec_distance_L2('[1, 1]', '[2, 2]');\n      - select vec_distance_L2('[1, 1]', '[-2, -2]');\n      - select vec_distance_L2('[1.1, 2.2, 3.3]', '[4.4, 5.5, 6.6]');\n      - select vec_distance_L2(X'AABBCCDD', X'00112233');\n      - select vec_distance_L2('[1, 1]', vec_int8('[2, 2]'));\n      - select vec_distance_L2(vec_bit(X'AA'), vec_bit(X'BB'));\n  vec_distance_cosine:\n    params: [a, b]\n    desc: |\n      Calculates the cosine distance between vectors `a` and `b`. Only valid for float32 or int8 vectors.\n\n      Returns an error under the following conditions:\n        - `a` or `b` are invalid vectors\n        - `a` or `b` do not share the same vector element types (ex float32 or int8)\n        - `a` or `b` are bit vectors. Use [`vec_distance_hamming()`](#vec_distance_hamming) for distance calculations between two bitvectors.\n        - `a` or `b` do not have the same length.\n    example:\n      - select vec_distance_cosine('[1, 1]', '[2, 2]');\n      - select vec_distance_cosine('[1, 1]', '[-2, -2]');\n      - select vec_distance_cosine('[1.1, 2.2, 3.3]', '[4.4, 5.5, 6.6]');\n      - select vec_distance_cosine(X'AABBCCDD', X'00112233');\n      - select vec_distance_cosine('[1, 1]', vec_int8('[2, 2]'));\n      - select vec_distance_cosine(vec_bit(X'AA'), vec_bit(X'BB'));\n  vec_distance_hamming:\n    params: [a, b]\n    desc: |\n      Calculates the hamming distance between two bitvectors `a` and `b`. Only valid for bitvectors.\n\n      Returns an error under the following conditions:\n      - `a` or `b` are not bitvectors\n      - `a` and `b` do not share the same length\n      - Memory cannot be allocated\n    example:\n      - select vec_distance_hamming(vec_bit(X'00'), vec_bit(X'FF'));\n      - select vec_distance_hamming(vec_bit(X'FF'), vec_bit(X'FF'));\n      - select vec_distance_hamming(vec_bit(X'F0'), vec_bit(X'44'));\n      - select vec_distance_hamming('[1, 1]', '[0, 0]');\n\nquantization:\n  vec_quantize_binary:\n    params: [vector]\n    desc: |\n      Quantize a float32 or int8 vector into a bitvector.\n      For every element in the vector, a `1` is assigned to positive numbers and a `0` is assigned to negative numbers.\n      These values are then packed into a bit vector.\n\n      Returns an error if `vector` is invalid, or if `vector` is not a float32 or int8 vector.\n    example:\n      - select vec_quantize_binary('[1, 2, 3, 4, 5, 6, 7, 8]');\n      - select vec_quantize_binary('[1, 2, 3, 4, -5, -6, -7, -8]');\n      - select vec_quantize_binary('[-1, -2, -3, -4, -5, -6, -7, -8]');\n      - select vec_quantize_binary('[-1, -2, -3, -4, -5, -6, -7, -8]');\n      - select vec_quantize_binary(vec_int8(X'11223344'));\n      - select vec_quantize_binary(vec_bit(X'FF'));\n  vec_quantize_i8:\n    params: [vector, \"[start]\", \"[end]\"]\n    desc: x\n    example: select 'todo';\nvec0:\n  vec0:\n    params: []\n    desc: TODO\n    example:\n      - |\n        create virtual table vec_items using vec0(\n          contents_embedding float[4]\n        );\n      - |\n        insert into vec_items(rowid, contents_embedding)\n        values (1, '[1, 1, 1, 1]'),\n          (2, '[2, 2, 2, 2]'),\n          (3, '[3, 3, 3, 3]');\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "site",
          "type": "tree",
          "content": null
        },
        {
          "name": "sqlite-dist.toml",
          "type": "blob",
          "size": 0.4921875,
          "content": "[package]\nname = \"sqlite-vec\"\nlicense = \"MIT OR Apache\"\nhomepage = \"https://alexgarcia.xyz/sqlite-vec\"\nrepo = \"https://github.com/asg017/sqlite-vec\"\ndescription = \"A vector search SQLite extension.\"\nauthors = [\"Alex Garcia\"]\ngit_tag_format = \"v$VERSION\"\n\n[targets]\ngithub_releases = {}\nsqlpkg = {}\nspm = {}\namalgamation = {include=[\"sqlite-vec.c\", \"sqlite-vec.h\"]}\n\npip = { extra_init_py = \"bindings/python/extra_init.py\" }\ndatasette = {}\nsqlite_utils = {}\n\nnpm = {}\n\ngem = { module_name = \"SqliteVec\" }\n"
        },
        {
          "name": "sqlite-vec.c",
          "type": "blob",
          "size": 298.0654296875,
          "content": "#include \"sqlite-vec.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <float.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef SQLITE_VEC_OMIT_FS\n#include <stdio.h>\n#endif\n\n#ifndef SQLITE_CORE\n#include \"sqlite3ext.h\"\nSQLITE_EXTENSION_INIT1\n#else\n#include \"sqlite3.h\"\n#endif\n\n#ifndef UINT32_TYPE\n#ifdef HAVE_UINT32_T\n#define UINT32_TYPE uint32_t\n#else\n#define UINT32_TYPE unsigned int\n#endif\n#endif\n#ifndef UINT16_TYPE\n#ifdef HAVE_UINT16_T\n#define UINT16_TYPE uint16_t\n#else\n#define UINT16_TYPE unsigned short int\n#endif\n#endif\n#ifndef INT16_TYPE\n#ifdef HAVE_INT16_T\n#define INT16_TYPE int16_t\n#else\n#define INT16_TYPE short int\n#endif\n#endif\n#ifndef UINT8_TYPE\n#ifdef HAVE_UINT8_T\n#define UINT8_TYPE uint8_t\n#else\n#define UINT8_TYPE unsigned char\n#endif\n#endif\n#ifndef INT8_TYPE\n#ifdef HAVE_INT8_T\n#define INT8_TYPE int8_t\n#else\n#define INT8_TYPE signed char\n#endif\n#endif\n#ifndef LONGDOUBLE_TYPE\n#define LONGDOUBLE_TYPE long double\n#endif\n\n#ifndef _WIN32\n#ifndef __EMSCRIPTEN__\n#ifndef __COSMOPOLITAN__\n#ifndef __wasi__\ntypedef u_int8_t uint8_t;\ntypedef u_int16_t uint16_t;\ntypedef u_int64_t uint64_t;\n#endif\n#endif\n#endif\n#endif\n\ntypedef int8_t i8;\ntypedef uint8_t u8;\ntypedef int16_t i16;\ntypedef int32_t i32;\ntypedef sqlite3_int64 i64;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef float f32;\ntypedef size_t usize;\n\n#ifndef UNUSED_PARAMETER\n#define UNUSED_PARAMETER(X) (void)(X)\n#endif\n\n// sqlite3_vtab_in() was added in SQLite version 3.38 (2022-02-22)\n// https://www.sqlite.org/changes.html#version_3_38_0\n#if SQLITE_VERSION_NUMBER >= 3038000\n#define COMPILER_SUPPORTS_VTAB_IN 1\n#endif\n\n#ifndef SQLITE_SUBTYPE\n#define SQLITE_SUBTYPE 0x000100000\n#endif\n\n#ifndef SQLITE_RESULT_SUBTYPE\n#define SQLITE_RESULT_SUBTYPE 0x001000000\n#endif\n\n#ifndef SQLITE_INDEX_CONSTRAINT_LIMIT\n#define SQLITE_INDEX_CONSTRAINT_LIMIT 73\n#endif\n\n#ifndef SQLITE_INDEX_CONSTRAINT_OFFSET\n#define SQLITE_INDEX_CONSTRAINT_OFFSET 74\n#endif\n\n#define countof(x) (sizeof(x) / sizeof((x)[0]))\n#define min(a, b) (((a) <= (b)) ? (a) : (b))\n\nenum VectorElementType {\n  // clang-format off\n  SQLITE_VEC_ELEMENT_TYPE_FLOAT32 = 223 + 0,\n  SQLITE_VEC_ELEMENT_TYPE_BIT     = 223 + 1,\n  SQLITE_VEC_ELEMENT_TYPE_INT8    = 223 + 2,\n  // clang-format on\n};\n\n#ifdef SQLITE_VEC_ENABLE_AVX\n#include <immintrin.h>\n#define PORTABLE_ALIGN32 __attribute__((aligned(32)))\n#define PORTABLE_ALIGN64 __attribute__((aligned(64)))\n\nstatic f32 l2_sqr_float_avx(const void *pVect1v, const void *pVect2v,\n                            const void *qty_ptr) {\n  f32 *pVect1 = (f32 *)pVect1v;\n  f32 *pVect2 = (f32 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n  f32 PORTABLE_ALIGN32 TmpRes[8];\n  size_t qty16 = qty >> 4;\n\n  const f32 *pEnd1 = pVect1 + (qty16 << 4);\n\n  __m256 diff, v1, v2;\n  __m256 sum = _mm256_set1_ps(0);\n\n  while (pVect1 < pEnd1) {\n    v1 = _mm256_loadu_ps(pVect1);\n    pVect1 += 8;\n    v2 = _mm256_loadu_ps(pVect2);\n    pVect2 += 8;\n    diff = _mm256_sub_ps(v1, v2);\n    sum = _mm256_add_ps(sum, _mm256_mul_ps(diff, diff));\n\n    v1 = _mm256_loadu_ps(pVect1);\n    pVect1 += 8;\n    v2 = _mm256_loadu_ps(pVect2);\n    pVect2 += 8;\n    diff = _mm256_sub_ps(v1, v2);\n    sum = _mm256_add_ps(sum, _mm256_mul_ps(diff, diff));\n  }\n\n  _mm256_store_ps(TmpRes, sum);\n  return sqrt(TmpRes[0] + TmpRes[1] + TmpRes[2] + TmpRes[3] + TmpRes[4] +\n              TmpRes[5] + TmpRes[6] + TmpRes[7]);\n}\n#endif\n\n#ifdef SQLITE_VEC_ENABLE_NEON\n#include <arm_neon.h>\n\n#define PORTABLE_ALIGN32 __attribute__((aligned(32)))\n\n// thx https://github.com/nmslib/hnswlib/pull/299/files\nstatic f32 l2_sqr_float_neon(const void *pVect1v, const void *pVect2v,\n                             const void *qty_ptr) {\n  f32 *pVect1 = (f32 *)pVect1v;\n  f32 *pVect2 = (f32 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n  size_t qty16 = qty >> 4;\n\n  const f32 *pEnd1 = pVect1 + (qty16 << 4);\n\n  float32x4_t diff, v1, v2;\n  float32x4_t sum0 = vdupq_n_f32(0);\n  float32x4_t sum1 = vdupq_n_f32(0);\n  float32x4_t sum2 = vdupq_n_f32(0);\n  float32x4_t sum3 = vdupq_n_f32(0);\n\n  while (pVect1 < pEnd1) {\n    v1 = vld1q_f32(pVect1);\n    pVect1 += 4;\n    v2 = vld1q_f32(pVect2);\n    pVect2 += 4;\n    diff = vsubq_f32(v1, v2);\n    sum0 = vfmaq_f32(sum0, diff, diff);\n\n    v1 = vld1q_f32(pVect1);\n    pVect1 += 4;\n    v2 = vld1q_f32(pVect2);\n    pVect2 += 4;\n    diff = vsubq_f32(v1, v2);\n    sum1 = vfmaq_f32(sum1, diff, diff);\n\n    v1 = vld1q_f32(pVect1);\n    pVect1 += 4;\n    v2 = vld1q_f32(pVect2);\n    pVect2 += 4;\n    diff = vsubq_f32(v1, v2);\n    sum2 = vfmaq_f32(sum2, diff, diff);\n\n    v1 = vld1q_f32(pVect1);\n    pVect1 += 4;\n    v2 = vld1q_f32(pVect2);\n    pVect2 += 4;\n    diff = vsubq_f32(v1, v2);\n    sum3 = vfmaq_f32(sum3, diff, diff);\n  }\n\n  f32 sum_scalar =\n      vaddvq_f32(vaddq_f32(vaddq_f32(sum0, sum1), vaddq_f32(sum2, sum3)));\n  const f32 *pEnd2 = pVect1 + (qty - (qty16 << 4));\n  while (pVect1 < pEnd2) {\n    f32 diff = *pVect1 - *pVect2;\n    sum_scalar += diff * diff;\n    pVect1++;\n    pVect2++;\n  }\n\n  return sqrt(sum_scalar);\n}\n\nstatic f32 l2_sqr_int8_neon(const void *pVect1v, const void *pVect2v,\n                            const void *qty_ptr) {\n  i8 *pVect1 = (i8 *)pVect1v;\n  i8 *pVect2 = (i8 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n\n  const i8 *pEnd1 = pVect1 + qty;\n  i32 sum_scalar = 0;\n\n  while (pVect1 < pEnd1 - 7) {\n    // loading 8 at a time\n    int8x8_t v1 = vld1_s8(pVect1);\n    int8x8_t v2 = vld1_s8(pVect2);\n    pVect1 += 8;\n    pVect2 += 8;\n\n    // widen to protect against overflow\n    int16x8_t v1_wide = vmovl_s8(v1);\n    int16x8_t v2_wide = vmovl_s8(v2);\n\n    int16x8_t diff = vsubq_s16(v1_wide, v2_wide);\n    int16x8_t squared_diff = vmulq_s16(diff, diff);\n    int32x4_t sum = vpaddlq_s16(squared_diff);\n\n    sum_scalar += vgetq_lane_s32(sum, 0) + vgetq_lane_s32(sum, 1) +\n                  vgetq_lane_s32(sum, 2) + vgetq_lane_s32(sum, 3);\n  }\n\n  // handle leftovers\n  while (pVect1 < pEnd1) {\n    i16 diff = (i16)*pVect1 - (i16)*pVect2;\n    sum_scalar += diff * diff;\n    pVect1++;\n    pVect2++;\n  }\n\n  return sqrtf(sum_scalar);\n}\n\nstatic i32 l1_int8_neon(const void *pVect1v, const void *pVect2v,\n                        const void *qty_ptr) {\n  i8 *pVect1 = (i8 *)pVect1v;\n  i8 *pVect2 = (i8 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n\n  const int8_t *pEnd1 = pVect1 + qty;\n\n  int32x4_t acc1 = vdupq_n_s32(0);\n  int32x4_t acc2 = vdupq_n_s32(0);\n  int32x4_t acc3 = vdupq_n_s32(0);\n  int32x4_t acc4 = vdupq_n_s32(0);\n\n  while (pVect1 < pEnd1 - 63) {\n    int8x16_t v1 = vld1q_s8(pVect1);\n    int8x16_t v2 = vld1q_s8(pVect2);\n    int8x16_t diff1 = vabdq_s8(v1, v2);\n    acc1 = vaddq_s32(acc1, vpaddlq_u16(vpaddlq_u8(diff1)));\n\n    v1 = vld1q_s8(pVect1 + 16);\n    v2 = vld1q_s8(pVect2 + 16);\n    int8x16_t diff2 = vabdq_s8(v1, v2);\n    acc2 = vaddq_s32(acc2, vpaddlq_u16(vpaddlq_u8(diff2)));\n\n    v1 = vld1q_s8(pVect1 + 32);\n    v2 = vld1q_s8(pVect2 + 32);\n    int8x16_t diff3 = vabdq_s8(v1, v2);\n    acc3 = vaddq_s32(acc3, vpaddlq_u16(vpaddlq_u8(diff3)));\n\n    v1 = vld1q_s8(pVect1 + 48);\n    v2 = vld1q_s8(pVect2 + 48);\n    int8x16_t diff4 = vabdq_s8(v1, v2);\n    acc4 = vaddq_s32(acc4, vpaddlq_u16(vpaddlq_u8(diff4)));\n\n    pVect1 += 64;\n    pVect2 += 64;\n  }\n\n  while (pVect1 < pEnd1 - 15) {\n    int8x16_t v1 = vld1q_s8(pVect1);\n    int8x16_t v2 = vld1q_s8(pVect2);\n    int8x16_t diff = vabdq_s8(v1, v2);\n    acc1 = vaddq_s32(acc1, vpaddlq_u16(vpaddlq_u8(diff)));\n    pVect1 += 16;\n    pVect2 += 16;\n  }\n\n  int32x4_t acc = vaddq_s32(vaddq_s32(acc1, acc2), vaddq_s32(acc3, acc4));\n\n  int32_t sum = 0;\n  while (pVect1 < pEnd1) {\n    int32_t diff = abs((int32_t)*pVect1 - (int32_t)*pVect2);\n    sum += diff;\n    pVect1++;\n    pVect2++;\n  }\n\n  return vaddvq_s32(acc) + sum;\n}\n\nstatic double l1_f32_neon(const void *pVect1v, const void *pVect2v,\n                          const void *qty_ptr) {\n  f32 *pVect1 = (f32 *)pVect1v;\n  f32 *pVect2 = (f32 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n\n  const f32 *pEnd1 = pVect1 + qty;\n  float64x2_t acc = vdupq_n_f64(0);\n\n  while (pVect1 < pEnd1 - 3) {\n    float32x4_t v1 = vld1q_f32(pVect1);\n    float32x4_t v2 = vld1q_f32(pVect2);\n    pVect1 += 4;\n    pVect2 += 4;\n\n    // f32x4 -> f64x2 pad for overflow\n    float64x2_t low_diff = vabdq_f64(vcvt_f64_f32(vget_low_f32(v1)),\n                                     vcvt_f64_f32(vget_low_f32(v2)));\n    float64x2_t high_diff =\n        vabdq_f64(vcvt_high_f64_f32(v1), vcvt_high_f64_f32(v2));\n\n    acc = vaddq_f64(acc, vaddq_f64(low_diff, high_diff));\n  }\n\n  double sum = 0;\n  while (pVect1 < pEnd1) {\n    sum += fabs((double)*pVect1 - (double)*pVect2);\n    pVect1++;\n    pVect2++;\n  }\n\n  return vaddvq_f64(acc) + sum;\n}\n#endif\n\nstatic f32 l2_sqr_float(const void *pVect1v, const void *pVect2v,\n                        const void *qty_ptr) {\n  f32 *pVect1 = (f32 *)pVect1v;\n  f32 *pVect2 = (f32 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n\n  f32 res = 0;\n  for (size_t i = 0; i < qty; i++) {\n    f32 t = *pVect1 - *pVect2;\n    pVect1++;\n    pVect2++;\n    res += t * t;\n  }\n  return sqrt(res);\n}\n\nstatic f32 l2_sqr_int8(const void *pA, const void *pB, const void *pD) {\n  i8 *a = (i8 *)pA;\n  i8 *b = (i8 *)pB;\n  size_t d = *((size_t *)pD);\n\n  f32 res = 0;\n  for (size_t i = 0; i < d; i++) {\n    f32 t = *a - *b;\n    a++;\n    b++;\n    res += t * t;\n  }\n  return sqrt(res);\n}\n\nstatic f32 distance_l2_sqr_float(const void *a, const void *b, const void *d) {\n#ifdef SQLITE_VEC_ENABLE_NEON\n  if ((*(const size_t *)d) > 16) {\n    return l2_sqr_float_neon(a, b, d);\n  }\n#endif\n#ifdef SQLITE_VEC_ENABLE_AVX\n  if (((*(const size_t *)d) % 16 == 0)) {\n    return l2_sqr_float_avx(a, b, d);\n  }\n#endif\n  return l2_sqr_float(a, b, d);\n}\n\nstatic f32 distance_l2_sqr_int8(const void *a, const void *b, const void *d) {\n#ifdef SQLITE_VEC_ENABLE_NEON\n  if ((*(const size_t *)d) > 7) {\n    return l2_sqr_int8_neon(a, b, d);\n  }\n#endif\n  return l2_sqr_int8(a, b, d);\n}\n\nstatic i32 l1_int8(const void *pA, const void *pB, const void *pD) {\n  i8 *a = (i8 *)pA;\n  i8 *b = (i8 *)pB;\n  size_t d = *((size_t *)pD);\n\n  i32 res = 0;\n  for (size_t i = 0; i < d; i++) {\n    res += abs(*a - *b);\n    a++;\n    b++;\n  }\n\n  return res;\n}\n\nstatic i32 distance_l1_int8(const void *a, const void *b, const void *d) {\n#ifdef SQLITE_VEC_ENABLE_NEON\n  if ((*(const size_t *)d) > 15) {\n    return l1_int8_neon(a, b, d);\n  }\n#endif\n  return l1_int8(a, b, d);\n}\n\nstatic double l1_f32(const void *pA, const void *pB, const void *pD) {\n  f32 *a = (f32 *)pA;\n  f32 *b = (f32 *)pB;\n  size_t d = *((size_t *)pD);\n\n  double res = 0;\n  for (size_t i = 0; i < d; i++) {\n    res += fabs((double)*a - (double)*b);\n    a++;\n    b++;\n  }\n\n  return res;\n}\n\nstatic double distance_l1_f32(const void *a, const void *b, const void *d) {\n#ifdef SQLITE_VEC_ENABLE_NEON\n  if ((*(const size_t *)d) > 3) {\n    return l1_f32_neon(a, b, d);\n  }\n#endif\n  return l1_f32(a, b, d);\n}\n\nstatic f32 distance_cosine_float(const void *pVect1v, const void *pVect2v,\n                                 const void *qty_ptr) {\n  f32 *pVect1 = (f32 *)pVect1v;\n  f32 *pVect2 = (f32 *)pVect2v;\n  size_t qty = *((size_t *)qty_ptr);\n\n  f32 dot = 0;\n  f32 aMag = 0;\n  f32 bMag = 0;\n  for (size_t i = 0; i < qty; i++) {\n    dot += *pVect1 * *pVect2;\n    aMag += *pVect1 * *pVect1;\n    bMag += *pVect2 * *pVect2;\n    pVect1++;\n    pVect2++;\n  }\n  return 1 - (dot / (sqrt(aMag) * sqrt(bMag)));\n}\nstatic f32 distance_cosine_int8(const void *pA, const void *pB,\n                                const void *pD) {\n  i8 *a = (i8 *)pA;\n  i8 *b = (i8 *)pB;\n  size_t d = *((size_t *)pD);\n\n  f32 dot = 0;\n  f32 aMag = 0;\n  f32 bMag = 0;\n  for (size_t i = 0; i < d; i++) {\n    dot += *a * *b;\n    aMag += *a * *a;\n    bMag += *b * *b;\n    a++;\n    b++;\n  }\n  return 1 - (dot / (sqrt(aMag) * sqrt(bMag)));\n}\n\n// https://github.com/facebookresearch/faiss/blob/77e2e79cd0a680adc343b9840dd865da724c579e/faiss/utils/hamming_distance/common.h#L34\nstatic u8 hamdist_table[256] = {\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4,\n    2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4,\n    2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,\n    4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,\n    3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,\n    4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};\n\nstatic f32 distance_hamming_u8(u8 *a, u8 *b, size_t n) {\n  int same = 0;\n  for (unsigned long i = 0; i < n; i++) {\n    same += hamdist_table[a[i] ^ b[i]];\n  }\n  return (f32)same;\n}\n\n#ifdef _MSC_VER\n#if !defined(__clang__) && (defined(_M_ARM) || defined(_M_ARM64))\n// From\n// https://github.com/ngtcp2/ngtcp2/blob/b64f1e77b5e0d880b93d31f474147fae4a1d17cc/lib/ngtcp2_ringbuf.c,\n// line 34-43\nstatic unsigned int __builtin_popcountl(unsigned int x) {\n  unsigned int c = 0;\n  for (; x; ++c) {\n    x &= x - 1;\n  }\n  return c;\n}\n#else\n#include <intrin.h>\n#define __builtin_popcountl __popcnt64\n#endif\n#endif\n\nstatic f32 distance_hamming_u64(u64 *a, u64 *b, size_t n) {\n  int same = 0;\n  for (unsigned long i = 0; i < n; i++) {\n    same += __builtin_popcountl(a[i] ^ b[i]);\n  }\n  return (f32)same;\n}\n\n/**\n * @brief Calculate the hamming distance between two bitvectors.\n *\n * @param a - first bitvector, MUST have d dimensions\n * @param b - second bitvector, MUST have d dimensions\n * @param d - pointer to size_t, MUST be divisible by CHAR_BIT\n * @return f32\n */\nstatic f32 distance_hamming(const void *a, const void *b, const void *d) {\n  size_t dimensions = *((size_t *)d);\n\n  if ((dimensions % 64) == 0) {\n    return distance_hamming_u64((u64 *)a, (u64 *)b, dimensions / 8 / CHAR_BIT);\n  }\n  return distance_hamming_u8((u8 *)a, (u8 *)b, dimensions / CHAR_BIT);\n}\n\n// from SQLite source:\n// https://github.com/sqlite/sqlite/blob/a509a90958ddb234d1785ed7801880ccb18b497e/src/json.c#L153\nstatic const char vecJsonIsSpaceX[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n#define vecJsonIsspace(x) (vecJsonIsSpaceX[(unsigned char)x])\n\ntypedef void (*vector_cleanup)(void *p);\n\nvoid vector_cleanup_noop(void *_) { UNUSED_PARAMETER(_); }\n\n#define JSON_SUBTYPE 74\n\nvoid vtab_set_error(sqlite3_vtab *pVTab, const char *zFormat, ...) {\n  va_list args;\n  sqlite3_free(pVTab->zErrMsg);\n  va_start(args, zFormat);\n  pVTab->zErrMsg = sqlite3_vmprintf(zFormat, args);\n  va_end(args);\n}\nstruct Array {\n  size_t element_size;\n  size_t length;\n  size_t capacity;\n  void *z;\n};\n\n/**\n * @brief Initial an array with the given element size and capacity.\n *\n * @param array\n * @param element_size\n * @param init_capacity\n * @return SQLITE_OK on success, error code on failure. Only error is\n * SQLITE_NOMEM\n */\nint array_init(struct Array *array, size_t element_size, size_t init_capacity) {\n  int sz = element_size * init_capacity;\n  void *z = sqlite3_malloc(sz);\n  if (!z) {\n    return SQLITE_NOMEM;\n  }\n  memset(z, 0, sz);\n\n  array->element_size = element_size;\n  array->length = 0;\n  array->capacity = init_capacity;\n  array->z = z;\n  return SQLITE_OK;\n}\n\nint array_append(struct Array *array, const void *element) {\n  if (array->length == array->capacity) {\n    size_t new_capacity = array->capacity * 2 + 100;\n    void *z = sqlite3_realloc64(array->z, array->element_size * new_capacity);\n    if (z) {\n      array->capacity = new_capacity;\n      array->z = z;\n    } else {\n      return SQLITE_NOMEM;\n    }\n  }\n  memcpy(&((unsigned char *)array->z)[array->length * array->element_size],\n         element, array->element_size);\n  array->length++;\n  return SQLITE_OK;\n}\n\nvoid array_cleanup(struct Array *array) {\n  if (!array)\n    return;\n  array->element_size = 0;\n  array->length = 0;\n  array->capacity = 0;\n  sqlite3_free(array->z);\n  array->z = NULL;\n}\n\nchar *vector_subtype_name(int subtype) {\n  switch (subtype) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32:\n    return \"float32\";\n  case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    return \"int8\";\n  case SQLITE_VEC_ELEMENT_TYPE_BIT:\n    return \"bit\";\n  }\n  return \"\";\n}\nchar *type_name(int type) {\n  switch (type) {\n  case SQLITE_INTEGER:\n    return \"INTEGER\";\n  case SQLITE_BLOB:\n    return \"BLOB\";\n  case SQLITE_TEXT:\n    return \"TEXT\";\n  case SQLITE_FLOAT:\n    return \"FLOAT\";\n  case SQLITE_NULL:\n    return \"NULL\";\n  }\n  return \"\";\n}\n\ntypedef void (*fvec_cleanup)(f32 *vector);\n\nvoid fvec_cleanup_noop(f32 *_) { UNUSED_PARAMETER(_); }\n\nstatic int fvec_from_value(sqlite3_value *value, f32 **vector,\n                           size_t *dimensions, fvec_cleanup *cleanup,\n                           char **pzErr) {\n  int value_type = sqlite3_value_type(value);\n\n  if (value_type == SQLITE_BLOB) {\n    const void *blob = sqlite3_value_blob(value);\n    int bytes = sqlite3_value_bytes(value);\n    if (bytes == 0) {\n      *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n      return SQLITE_ERROR;\n    }\n    if ((bytes % sizeof(f32)) != 0) {\n      *pzErr = sqlite3_mprintf(\"invalid float32 vector BLOB length. Must be \"\n                               \"divisible by %d, found %d\",\n                               sizeof(f32), bytes);\n      return SQLITE_ERROR;\n    }\n    *vector = (f32 *)blob;\n    *dimensions = bytes / sizeof(f32);\n    *cleanup = fvec_cleanup_noop;\n    return SQLITE_OK;\n  }\n\n  if (value_type == SQLITE_TEXT) {\n    const char *source = (const char *)sqlite3_value_text(value);\n    int source_len = sqlite3_value_bytes(value);\n    if (source_len == 0) {\n      *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n      return SQLITE_ERROR;\n    }\n    int i = 0;\n\n    struct Array x;\n    int rc = array_init(&x, sizeof(f32), ceil(source_len / 2.0));\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n\n    // advance leading whitespace to first '['\n    while (i < source_len) {\n      if (vecJsonIsspace(source[i])) {\n        i++;\n        continue;\n      }\n      if (source[i] == '[') {\n        break;\n      }\n\n      *pzErr = sqlite3_mprintf(\n          \"JSON array parsing error: Input does not start with '['\");\n      array_cleanup(&x);\n      return SQLITE_ERROR;\n    }\n    if (source[i] != '[') {\n      *pzErr = sqlite3_mprintf(\n          \"JSON array parsing error: Input does not start with '['\");\n      array_cleanup(&x);\n      return SQLITE_ERROR;\n    }\n    int offset = i + 1;\n\n    while (offset < source_len) {\n      char *ptr = (char *)&source[offset];\n      char *endptr;\n\n      errno = 0;\n      double result = strtod(ptr, &endptr);\n      if ((errno != 0 && result == 0) // some interval error?\n          || (errno == ERANGE &&\n              (result == HUGE_VAL || result == -HUGE_VAL)) // too big / smalls\n      ) {\n        sqlite3_free(x.z);\n        *pzErr = sqlite3_mprintf(\"JSON parsing error\");\n        return SQLITE_ERROR;\n      }\n\n      if (endptr == ptr) {\n        if (*ptr != ']') {\n          sqlite3_free(x.z);\n          *pzErr = sqlite3_mprintf(\"JSON parsing error\");\n          return SQLITE_ERROR;\n        }\n        goto done;\n      }\n\n      f32 res = (f32)result;\n      array_append(&x, (const void *)&res);\n\n      offset += (endptr - ptr);\n      while (offset < source_len) {\n        if (vecJsonIsspace(source[offset])) {\n          offset++;\n          continue;\n        }\n        if (source[offset] == ',') {\n          offset++;\n          continue;\n        }\n        if (source[offset] == ']')\n          goto done;\n        break;\n      }\n    }\n\n  done:\n\n    if (x.length > 0) {\n      *vector = (f32 *)x.z;\n      *dimensions = x.length;\n      *cleanup = (fvec_cleanup)sqlite3_free;\n      return SQLITE_OK;\n    }\n    sqlite3_free(x.z);\n    *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n    return SQLITE_ERROR;\n  }\n\n  *pzErr = sqlite3_mprintf(\n      \"Input must have type BLOB (compact format) or TEXT (JSON), found %s\",\n      type_name(value_type));\n  return SQLITE_ERROR;\n}\n\nstatic int bitvec_from_value(sqlite3_value *value, u8 **vector,\n                             size_t *dimensions, vector_cleanup *cleanup,\n                             char **pzErr) {\n  int value_type = sqlite3_value_type(value);\n  if (value_type == SQLITE_BLOB) {\n    const void *blob = sqlite3_value_blob(value);\n    int bytes = sqlite3_value_bytes(value);\n    if (bytes == 0) {\n      *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n      return SQLITE_ERROR;\n    }\n    *vector = (u8 *)blob;\n    *dimensions = bytes * CHAR_BIT;\n    *cleanup = vector_cleanup_noop;\n    return SQLITE_OK;\n  }\n  *pzErr = sqlite3_mprintf(\"Unknown type for bitvector.\");\n  return SQLITE_ERROR;\n}\n\nstatic int int8_vec_from_value(sqlite3_value *value, i8 **vector,\n                               size_t *dimensions, vector_cleanup *cleanup,\n                               char **pzErr) {\n  int value_type = sqlite3_value_type(value);\n  if (value_type == SQLITE_BLOB) {\n    const void *blob = sqlite3_value_blob(value);\n    int bytes = sqlite3_value_bytes(value);\n    if (bytes == 0) {\n      *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n      return SQLITE_ERROR;\n    }\n    *vector = (i8 *)blob;\n    *dimensions = bytes;\n    *cleanup = vector_cleanup_noop;\n    return SQLITE_OK;\n  }\n\n  if (value_type == SQLITE_TEXT) {\n    const char *source = (const char *)sqlite3_value_text(value);\n    int source_len = sqlite3_value_bytes(value);\n    int i = 0;\n\n    if (source_len == 0) {\n      *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n      return SQLITE_ERROR;\n    }\n\n    struct Array x;\n    int rc = array_init(&x, sizeof(i8), ceil(source_len / 2.0));\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n\n    // advance leading whitespace to first '['\n    while (i < source_len) {\n      if (vecJsonIsspace(source[i])) {\n        i++;\n        continue;\n      }\n      if (source[i] == '[') {\n        break;\n      }\n\n      *pzErr = sqlite3_mprintf(\n          \"JSON array parsing error: Input does not start with '['\");\n      array_cleanup(&x);\n      return SQLITE_ERROR;\n    }\n    if (source[i] != '[') {\n      *pzErr = sqlite3_mprintf(\n          \"JSON array parsing error: Input does not start with '['\");\n      array_cleanup(&x);\n      return SQLITE_ERROR;\n    }\n    int offset = i + 1;\n\n    while (offset < source_len) {\n      char *ptr = (char *)&source[offset];\n      char *endptr;\n\n      errno = 0;\n      long result = strtol(ptr, &endptr, 10);\n      if ((errno != 0 && result == 0) ||\n          (errno == ERANGE && (result == LONG_MAX || result == LONG_MIN))) {\n        sqlite3_free(x.z);\n        *pzErr = sqlite3_mprintf(\"JSON parsing error\");\n        return SQLITE_ERROR;\n      }\n\n      if (endptr == ptr) {\n        if (*ptr != ']') {\n          sqlite3_free(x.z);\n          *pzErr = sqlite3_mprintf(\"JSON parsing error\");\n          return SQLITE_ERROR;\n        }\n        goto done;\n      }\n\n      if (result < INT8_MIN || result > INT8_MAX) {\n        sqlite3_free(x.z);\n        *pzErr =\n            sqlite3_mprintf(\"JSON parsing error: value out of range for int8\");\n        return SQLITE_ERROR;\n      }\n\n      i8 res = (i8)result;\n      array_append(&x, (const void *)&res);\n\n      offset += (endptr - ptr);\n      while (offset < source_len) {\n        if (vecJsonIsspace(source[offset])) {\n          offset++;\n          continue;\n        }\n        if (source[offset] == ',') {\n          offset++;\n          continue;\n        }\n        if (source[offset] == ']')\n          goto done;\n        break;\n      }\n    }\n\n  done:\n\n    if (x.length > 0) {\n      *vector = (i8 *)x.z;\n      *dimensions = x.length;\n      *cleanup = (vector_cleanup)sqlite3_free;\n      return SQLITE_OK;\n    }\n    sqlite3_free(x.z);\n    *pzErr = sqlite3_mprintf(\"zero-length vectors are not supported.\");\n    return SQLITE_ERROR;\n  }\n\n  *pzErr = sqlite3_mprintf(\"Unknown type for int8 vector.\");\n  return SQLITE_ERROR;\n}\n\n/**\n * @brief Extract a vector from a sqlite3_value. Can be a float32, int8, or bit\n * vector.\n *\n * @param value: the sqlite3_value to read from.\n * @param vector: Output pointer to vector data.\n * @param dimensions: Output number of dimensions\n * @param dimensions: Output vector element type\n * @param cleanup\n * @param pzErrorMessage\n * @return int SQLITE_OK on success, error code otherwise\n */\nint vector_from_value(sqlite3_value *value, void **vector, size_t *dimensions,\n                      enum VectorElementType *element_type,\n                      vector_cleanup *cleanup, char **pzErrorMessage) {\n  int subtype = sqlite3_value_subtype(value);\n  if (!subtype || (subtype == SQLITE_VEC_ELEMENT_TYPE_FLOAT32) ||\n      (subtype == JSON_SUBTYPE)) {\n    int rc = fvec_from_value(value, (f32 **)vector, dimensions,\n                             (fvec_cleanup *)cleanup, pzErrorMessage);\n    if (rc == SQLITE_OK) {\n      *element_type = SQLITE_VEC_ELEMENT_TYPE_FLOAT32;\n    }\n    return rc;\n  }\n\n  if (subtype == SQLITE_VEC_ELEMENT_TYPE_BIT) {\n    int rc = bitvec_from_value(value, (u8 **)vector, dimensions, cleanup,\n                               pzErrorMessage);\n    if (rc == SQLITE_OK) {\n      *element_type = SQLITE_VEC_ELEMENT_TYPE_BIT;\n    }\n    return rc;\n  }\n  if (subtype == SQLITE_VEC_ELEMENT_TYPE_INT8) {\n    int rc = int8_vec_from_value(value, (i8 **)vector, dimensions, cleanup,\n                                 pzErrorMessage);\n    if (rc == SQLITE_OK) {\n      *element_type = SQLITE_VEC_ELEMENT_TYPE_INT8;\n    }\n    return rc;\n  }\n  *pzErrorMessage = sqlite3_mprintf(\"Unknown subtype: %d\", subtype);\n  return SQLITE_ERROR;\n}\n\nint ensure_vector_match(sqlite3_value *aValue, sqlite3_value *bValue, void **a,\n                        void **b, enum VectorElementType *element_type,\n                        size_t *dimensions, vector_cleanup *outACleanup,\n                        vector_cleanup *outBCleanup, char **outError) {\n  int rc;\n  enum VectorElementType aType, bType;\n  size_t aDims, bDims;\n  char *error = NULL;\n  vector_cleanup aCleanup, bCleanup;\n\n  rc = vector_from_value(aValue, a, &aDims, &aType, &aCleanup, &error);\n  if (rc != SQLITE_OK) {\n    *outError = sqlite3_mprintf(\"Error reading 1st vector: %s\", error);\n    sqlite3_free(error);\n    return SQLITE_ERROR;\n  }\n\n  rc = vector_from_value(bValue, b, &bDims, &bType, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    *outError = sqlite3_mprintf(\"Error reading 2nd vector: %s\", error);\n    sqlite3_free(error);\n    aCleanup(a);\n    return SQLITE_ERROR;\n  }\n\n  if (aType != bType) {\n    *outError =\n        sqlite3_mprintf(\"Vector type mistmatch. First vector has type %s, \"\n                        \"while the second has type %s.\",\n                        vector_subtype_name(aType), vector_subtype_name(bType));\n    aCleanup(*a);\n    bCleanup(*b);\n    return SQLITE_ERROR;\n  }\n  if (aDims != bDims) {\n    *outError = sqlite3_mprintf(\n        \"Vector dimension mistmatch. First vector has %ld dimensions, \"\n        \"while the second has %ld dimensions.\",\n        aDims, bDims);\n    aCleanup(*a);\n    bCleanup(*b);\n    return SQLITE_ERROR;\n  }\n  *element_type = aType;\n  *dimensions = aDims;\n  *outACleanup = aCleanup;\n  *outBCleanup = bCleanup;\n  return SQLITE_OK;\n}\n\nint _cmp(const void *a, const void *b) { return (*(i64 *)a - *(i64 *)b); }\n\nstruct VecNpyFile {\n  char *path;\n  size_t pathLength;\n};\n#define SQLITE_VEC_NPY_FILE_NAME \"vec0-npy-file\"\n\n#ifndef SQLITE_VEC_OMIT_FS\nstatic void vec_npy_file(sqlite3_context *context, int argc,\n                         sqlite3_value **argv) {\n  assert(argc == 1);\n  char *path = (char *)sqlite3_value_text(argv[0]);\n  size_t pathLength = sqlite3_value_bytes(argv[0]);\n  struct VecNpyFile *f;\n\n  f = sqlite3_malloc(sizeof(*f));\n  if (!f) {\n    sqlite3_result_error_nomem(context);\n    return;\n  }\n  memset(f, 0, sizeof(*f));\n\n  f->path = path;\n  f->pathLength = pathLength;\n  sqlite3_result_pointer(context, f, SQLITE_VEC_NPY_FILE_NAME, sqlite3_free);\n}\n#endif\n\n#pragma region scalar functions\nstatic void vec_f32(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 1);\n  int rc;\n  f32 *vector = NULL;\n  size_t dimensions;\n  fvec_cleanup cleanup;\n  char *errmsg;\n  rc = fvec_from_value(argv[0], &vector, &dimensions, &cleanup, &errmsg);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, errmsg, -1);\n    sqlite3_free(errmsg);\n    return;\n  }\n  sqlite3_result_blob(context, vector, dimensions * sizeof(f32),\n                      (void (*)(void *))cleanup);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_FLOAT32);\n}\n\nstatic void vec_bit(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 1);\n  int rc;\n  u8 *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *errmsg;\n  rc = bitvec_from_value(argv[0], &vector, &dimensions, &cleanup, &errmsg);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, errmsg, -1);\n    sqlite3_free(errmsg);\n    return;\n  }\n  sqlite3_result_blob(context, vector, dimensions / CHAR_BIT, SQLITE_TRANSIENT);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_BIT);\n  cleanup(vector);\n}\nstatic void vec_int8(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 1);\n  int rc;\n  i8 *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *errmsg;\n  rc = int8_vec_from_value(argv[0], &vector, &dimensions, &cleanup, &errmsg);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, errmsg, -1);\n    sqlite3_free(errmsg);\n    return;\n  }\n  sqlite3_result_blob(context, vector, dimensions, SQLITE_TRANSIENT);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_INT8);\n  cleanup(vector);\n}\n\nstatic void vec_length(sqlite3_context *context, int argc,\n                       sqlite3_value **argv) {\n  assert(argc == 1);\n  int rc;\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *errmsg;\n  enum VectorElementType elementType;\n  rc = vector_from_value(argv[0], &vector, &dimensions, &elementType, &cleanup,\n                         &errmsg);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, errmsg, -1);\n    sqlite3_free(errmsg);\n    return;\n  }\n  sqlite3_result_int64(context, dimensions);\n  cleanup(vector);\n}\n\nstatic void vec_distance_cosine(sqlite3_context *context, int argc,\n                                sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a = NULL, *b = NULL;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(\n        context, \"Cannot calculate cosine distance between two bitvectors.\",\n        -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    f32 result = distance_cosine_float(a, b, &dimensions);\n    sqlite3_result_double(context, result);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    f32 result = distance_cosine_int8(a, b, &dimensions);\n    sqlite3_result_double(context, result);\n    goto finish;\n  }\n  }\n\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\n\nstatic void vec_distance_l2(sqlite3_context *context, int argc,\n                            sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a = NULL, *b = NULL;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(\n        context, \"Cannot calculate L2 distance between two bitvectors.\", -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    f32 result = distance_l2_sqr_float(a, b, &dimensions);\n    sqlite3_result_double(context, result);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    f32 result = distance_l2_sqr_int8(a, b, &dimensions);\n    sqlite3_result_double(context, result);\n    goto finish;\n  }\n  }\n\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\n\nstatic void vec_distance_l1(sqlite3_context *context, int argc,\n                            sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a, *b;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(\n        context, \"Cannot calculate L1 distance between two bitvectors.\", -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    double result = distance_l1_f32(a, b, &dimensions);\n    sqlite3_result_double(context, result);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    i64 result = distance_l1_int8(a, b, &dimensions);\n    sqlite3_result_int(context, result);\n    goto finish;\n  }\n  }\n\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\n\nstatic void vec_distance_hamming(sqlite3_context *context, int argc,\n                                 sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a = NULL, *b = NULL;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_double(context, distance_hamming(a, b, &dimensions));\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    sqlite3_result_error(\n        context,\n        \"Cannot calculate hamming distance between two float32 vectors.\", -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    sqlite3_result_error(\n        context, \"Cannot calculate hamming distance between two int8 vectors.\",\n        -1);\n    goto finish;\n  }\n  }\n\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\n\nchar *vec_type_name(enum VectorElementType elementType) {\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32:\n    return \"float32\";\n  case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    return \"int8\";\n  case SQLITE_VEC_ELEMENT_TYPE_BIT:\n    return \"bit\";\n  }\n  return \"\";\n}\n\nstatic void vec_type(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 1);\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *pzError;\n  enum VectorElementType elementType;\n  int rc = vector_from_value(argv[0], &vector, &dimensions, &elementType,\n                             &cleanup, &pzError);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, pzError, -1);\n    sqlite3_free(pzError);\n    return;\n  }\n  sqlite3_result_text(context, vec_type_name(elementType), -1, SQLITE_STATIC);\n  cleanup(vector);\n}\nstatic void vec_quantize_binary(sqlite3_context *context, int argc,\n                                sqlite3_value **argv) {\n  assert(argc == 1);\n  void *vector;\n  size_t dimensions;\n  vector_cleanup vectorCleanup;\n  char *pzError;\n  enum VectorElementType elementType;\n  int rc = vector_from_value(argv[0], &vector, &dimensions, &elementType,\n                             &vectorCleanup, &pzError);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, pzError, -1);\n    sqlite3_free(pzError);\n    return;\n  }\n\n  if (dimensions <= 0) {\n    sqlite3_result_error(context, \"Zero length vectors are not supported.\", -1);\n    goto cleanup;\n    return;\n  }\n  if ((dimensions % CHAR_BIT) != 0) {\n    sqlite3_result_error(\n        context,\n        \"Binary quantization requires vectors with a length divisible by 8\",\n        -1);\n    goto cleanup;\n    return;\n  }\n\n  int sz = dimensions / CHAR_BIT;\n  u8 *out = sqlite3_malloc(sz);\n  if (!out) {\n    sqlite3_result_error_code(context, SQLITE_NOMEM);\n    goto cleanup;\n    return;\n  }\n  memset(out, 0, sz);\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n\n    for (size_t i = 0; i < dimensions; i++) {\n      int res = ((f32 *)vector)[i] > 0.0;\n      out[i / 8] |= (res << (i % 8));\n    }\n    break;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    for (size_t i = 0; i < dimensions; i++) {\n      int res = ((i8 *)vector)[i] > 0;\n      out[i / 8] |= (res << (i % 8));\n    }\n    break;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(context,\n                         \"Can only binary quantize float or int8 vectors\", -1);\n    sqlite3_free(out);\n    return;\n  }\n  }\n  sqlite3_result_blob(context, out, sz, sqlite3_free);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_BIT);\n\ncleanup:\n  vectorCleanup(vector);\n}\n\nstatic void vec_quantize_int8(sqlite3_context *context, int argc,\n                              sqlite3_value **argv) {\n  assert(argc == 2);\n  f32 *srcVector;\n  size_t dimensions;\n  fvec_cleanup srcCleanup;\n  char *err;\n  i8 *out = NULL;\n  int rc = fvec_from_value(argv[0], &srcVector, &dimensions, &srcCleanup, &err);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, err, -1);\n    sqlite3_free(err);\n    return;\n  }\n\n  int sz = dimensions * sizeof(i8);\n  out = sqlite3_malloc(sz);\n  if (!out) {\n    sqlite3_result_error_nomem(context);\n    goto cleanup;\n  }\n  memset(out, 0, sz);\n\n  if ((sqlite3_value_type(argv[1]) != SQLITE_TEXT) ||\n      (sqlite3_value_bytes(argv[1]) != strlen(\"unit\")) ||\n      (sqlite3_stricmp((const char *)sqlite3_value_text(argv[1]), \"unit\") !=\n       0)) {\n    sqlite3_result_error(\n        context, \"2nd argument to vec_quantize_int8() must be 'unit'.\", -1);\n    sqlite3_free(out);\n    goto cleanup;\n  }\n  f32 step = (1.0 - (-1.0)) / 255;\n  for (size_t i = 0; i < dimensions; i++) {\n    out[i] = ((srcVector[i] - (-1.0)) / step) - 128;\n  }\n\n  sqlite3_result_blob(context, out, dimensions * sizeof(i8), sqlite3_free);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_INT8);\n\ncleanup:\n  srcCleanup(srcVector);\n}\n\nstatic void vec_add(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a = NULL, *b = NULL;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(context, \"Cannot add two bitvectors together.\", -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    size_t outSize = dimensions * sizeof(f32);\n    f32 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      goto finish;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < dimensions; i++) {\n      out[i] = ((f32 *)a)[i] + ((f32 *)b)[i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_FLOAT32);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    size_t outSize = dimensions * sizeof(i8);\n    i8 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      goto finish;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < dimensions; i++) {\n      out[i] = ((i8 *)a)[i] + ((i8 *)b)[i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_INT8);\n    goto finish;\n  }\n  }\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\nstatic void vec_sub(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  assert(argc == 2);\n  int rc;\n  void *a = NULL, *b = NULL;\n  size_t dimensions;\n  vector_cleanup aCleanup, bCleanup;\n  char *error;\n  enum VectorElementType elementType;\n  rc = ensure_vector_match(argv[0], argv[1], &a, &b, &elementType, &dimensions,\n                           &aCleanup, &bCleanup, &error);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, error, -1);\n    sqlite3_free(error);\n    return;\n  }\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    sqlite3_result_error(context, \"Cannot subtract two bitvectors together.\",\n                         -1);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    size_t outSize = dimensions * sizeof(f32);\n    f32 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      goto finish;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < dimensions; i++) {\n      out[i] = ((f32 *)a)[i] - ((f32 *)b)[i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_FLOAT32);\n    goto finish;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    size_t outSize = dimensions * sizeof(i8);\n    i8 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      goto finish;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < dimensions; i++) {\n      out[i] = ((i8 *)a)[i] - ((i8 *)b)[i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_INT8);\n    goto finish;\n  }\n  }\nfinish:\n  aCleanup(a);\n  bCleanup(b);\n  return;\n}\nstatic void vec_slice(sqlite3_context *context, int argc,\n                      sqlite3_value **argv) {\n  assert(argc == 3);\n\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *err;\n  enum VectorElementType elementType;\n\n  int rc = vector_from_value(argv[0], &vector, &dimensions, &elementType,\n                             &cleanup, &err);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, err, -1);\n    sqlite3_free(err);\n    return;\n  }\n\n  int start = sqlite3_value_int(argv[1]);\n  int end = sqlite3_value_int(argv[2]);\n\n  if (start < 0) {\n    sqlite3_result_error(context,\n                         \"slice 'start' index must be a postive number.\", -1);\n    goto done;\n  }\n  if (end < 0) {\n    sqlite3_result_error(context, \"slice 'end' index must be a postive number.\",\n                         -1);\n    goto done;\n  }\n  if (((size_t)start) > dimensions) {\n    sqlite3_result_error(\n        context, \"slice 'start' index is greater than the number of dimensions\",\n        -1);\n    goto done;\n  }\n  if (((size_t)end) > dimensions) {\n    sqlite3_result_error(\n        context, \"slice 'end' index is greater than the number of dimensions\",\n        -1);\n    goto done;\n  }\n  if (start > end) {\n    sqlite3_result_error(context,\n                         \"slice 'start' index is greater than 'end' index\", -1);\n    goto done;\n  }\n  if (start == end) {\n    sqlite3_result_error(context,\n                         \"slice 'start' index is equal to the 'end' index, \"\n                         \"vectors must have non-zero length\",\n                         -1);\n    goto done;\n  }\n  size_t n = end - start;\n\n  switch (elementType) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n    int outSize = n * sizeof(f32);\n    f32 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      goto done;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < n; i++) {\n      out[i] = ((f32 *)vector)[start + i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_FLOAT32);\n    goto done;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n    int outSize = n * sizeof(i8);\n    i8 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      return;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < n; i++) {\n      out[i] = ((i8 *)vector)[start + i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_INT8);\n    goto done;\n  }\n  case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n    if ((start % CHAR_BIT) != 0) {\n      sqlite3_result_error(context, \"start index must be divisible by 8.\", -1);\n      goto done;\n    }\n    if ((end % CHAR_BIT) != 0) {\n      sqlite3_result_error(context, \"end index must be divisible by 8.\", -1);\n      goto done;\n    }\n    int outSize = n / CHAR_BIT;\n    u8 *out = sqlite3_malloc(outSize);\n    if (!out) {\n      sqlite3_result_error_nomem(context);\n      return;\n    }\n    memset(out, 0, outSize);\n    for (size_t i = 0; i < n / CHAR_BIT; i++) {\n      out[i] = ((u8 *)vector)[(start / CHAR_BIT) + i];\n    }\n    sqlite3_result_blob(context, out, outSize, sqlite3_free);\n    sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_BIT);\n    goto done;\n  }\n  }\ndone:\n  cleanup(vector);\n}\n\nstatic void vec_to_json(sqlite3_context *context, int argc,\n                        sqlite3_value **argv) {\n  assert(argc == 1);\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *err;\n  enum VectorElementType elementType;\n\n  int rc = vector_from_value(argv[0], &vector, &dimensions, &elementType,\n                             &cleanup, &err);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, err, -1);\n    sqlite3_free(err);\n    return;\n  }\n\n  sqlite3_str *str = sqlite3_str_new(sqlite3_context_db_handle(context));\n  sqlite3_str_appendall(str, \"[\");\n  for (size_t i = 0; i < dimensions; i++) {\n    if (i != 0) {\n      sqlite3_str_appendall(str, \",\");\n    }\n    if (elementType == SQLITE_VEC_ELEMENT_TYPE_FLOAT32) {\n      f32 value = ((f32 *)vector)[i];\n      if (isnan(value)) {\n        sqlite3_str_appendall(str, \"null\");\n      } else {\n        sqlite3_str_appendf(str, \"%f\", value);\n      }\n\n    } else if (elementType == SQLITE_VEC_ELEMENT_TYPE_INT8) {\n      sqlite3_str_appendf(str, \"%d\", ((i8 *)vector)[i]);\n    } else if (elementType == SQLITE_VEC_ELEMENT_TYPE_BIT) {\n      u8 b = (((u8 *)vector)[i / 8] >> (i % CHAR_BIT)) & 1;\n      sqlite3_str_appendf(str, \"%d\", b);\n    }\n  }\n  sqlite3_str_appendall(str, \"]\");\n  int len = sqlite3_str_length(str);\n  char *s = sqlite3_str_finish(str);\n  if (s) {\n    sqlite3_result_text(context, s, len, sqlite3_free);\n    sqlite3_result_subtype(context, JSON_SUBTYPE);\n  } else {\n    sqlite3_result_error_nomem(context);\n  }\n  cleanup(vector);\n}\n\nstatic void vec_normalize(sqlite3_context *context, int argc,\n                          sqlite3_value **argv) {\n  assert(argc == 1);\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n  char *err;\n  enum VectorElementType elementType;\n\n  int rc = vector_from_value(argv[0], &vector, &dimensions, &elementType,\n                             &cleanup, &err);\n  if (rc != SQLITE_OK) {\n    sqlite3_result_error(context, err, -1);\n    sqlite3_free(err);\n    return;\n  }\n\n  if (elementType != SQLITE_VEC_ELEMENT_TYPE_FLOAT32) {\n    sqlite3_result_error(\n        context, \"only float32 vectors are supported when normalizing\", -1);\n    cleanup(vector);\n    return;\n  }\n\n  int outSize = dimensions * sizeof(f32);\n  f32 *out = sqlite3_malloc(outSize);\n  if (!out) {\n    cleanup(vector);\n    sqlite3_result_error_code(context, SQLITE_NOMEM);\n    return;\n  }\n  memset(out, 0, outSize);\n\n  f32 *v = (f32 *)vector;\n\n  f32 norm = 0;\n  for (size_t i = 0; i < dimensions; i++) {\n    norm += v[i] * v[i];\n  }\n  norm = sqrt(norm);\n  for (size_t i = 0; i < dimensions; i++) {\n    out[i] = v[i] / norm;\n  }\n\n  sqlite3_result_blob(context, out, dimensions * sizeof(f32), sqlite3_free);\n  sqlite3_result_subtype(context, SQLITE_VEC_ELEMENT_TYPE_FLOAT32);\n  cleanup(vector);\n}\n\nstatic void _static_text_func(sqlite3_context *context, int argc,\n                              sqlite3_value **argv) {\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  sqlite3_result_text(context, sqlite3_user_data(context), -1, SQLITE_STATIC);\n}\n\n#pragma endregion\n\nenum Vec0TokenType {\n  TOKEN_TYPE_IDENTIFIER,\n  TOKEN_TYPE_DIGIT,\n  TOKEN_TYPE_LBRACKET,\n  TOKEN_TYPE_RBRACKET,\n  TOKEN_TYPE_PLUS,\n  TOKEN_TYPE_EQ,\n};\nstruct Vec0Token {\n  enum Vec0TokenType token_type;\n  char *start;\n  char *end;\n};\n\nint is_alpha(char x) {\n  return (x >= 'a' && x <= 'z') || (x >= 'A' && x <= 'Z');\n}\nint is_digit(char x) { return (x >= '0' && x <= '9'); }\nint is_whitespace(char x) {\n  return x == ' ' || x == '\\t' || x == '\\n' || x == '\\r';\n}\n\n#define VEC0_TOKEN_RESULT_EOF 1\n#define VEC0_TOKEN_RESULT_SOME 2\n#define VEC0_TOKEN_RESULT_ERROR 3\n\nint vec0_token_next(char *start, char *end, struct Vec0Token *out) {\n  char *ptr = start;\n  while (ptr < end) {\n    char curr = *ptr;\n    if (is_whitespace(curr)) {\n      ptr++;\n      continue;\n    } else if (curr == '+') {\n      ptr++;\n      out->start = ptr;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_PLUS;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == '[') {\n      ptr++;\n      out->start = ptr;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_LBRACKET;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == ']') {\n      ptr++;\n      out->start = ptr;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_RBRACKET;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == '=') {\n      ptr++;\n      out->start = ptr;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_EQ;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (is_alpha(curr)) {\n      char *start = ptr;\n      while (ptr < end && (is_alpha(*ptr) || is_digit(*ptr) || *ptr == '_')) {\n        ptr++;\n      }\n      out->start = start;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_IDENTIFIER;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (is_digit(curr)) {\n      char *start = ptr;\n      while (ptr < end && (is_digit(*ptr))) {\n        ptr++;\n      }\n      out->start = start;\n      out->end = ptr;\n      out->token_type = TOKEN_TYPE_DIGIT;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else {\n      return VEC0_TOKEN_RESULT_ERROR;\n    }\n  }\n  return VEC0_TOKEN_RESULT_EOF;\n}\n\nstruct Vec0Scanner {\n  char *start;\n  char *end;\n  char *ptr;\n};\n\nvoid vec0_scanner_init(struct Vec0Scanner *scanner, const char *source,\n                       int source_length) {\n  scanner->start = (char *)source;\n  scanner->end = (char *)source + source_length;\n  scanner->ptr = (char *)source;\n}\nint vec0_scanner_next(struct Vec0Scanner *scanner, struct Vec0Token *out) {\n  int rc = vec0_token_next(scanner->start, scanner->end, out);\n  if (rc == VEC0_TOKEN_RESULT_SOME) {\n    scanner->start = out->end;\n  }\n  return rc;\n}\n\nint vec0_parse_table_option(const char *source, int source_length,\n                            char **out_key, int *out_key_length,\n                            char **out_value, int *out_value_length) {\n  int rc;\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n  char *key;\n  char *value;\n  int keyLength, valueLength;\n\n  vec0_scanner_init(&scanner, source, source_length);\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  key = token.start;\n  keyLength = token.end - token.start;\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME && token.token_type != TOKEN_TYPE_EQ) {\n    return SQLITE_EMPTY;\n  }\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      !((token.token_type == TOKEN_TYPE_IDENTIFIER) ||\n        (token.token_type == TOKEN_TYPE_DIGIT))) {\n    return SQLITE_ERROR;\n  }\n  value = token.start;\n  valueLength = token.end - token.start;\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc == VEC0_TOKEN_RESULT_EOF) {\n    *out_key = key;\n    *out_key_length = keyLength;\n    *out_value = value;\n    *out_value_length = valueLength;\n    return SQLITE_OK;\n  }\n  return SQLITE_ERROR;\n}\n/**\n * @brief Parse an argv[i] entry of a vec0 virtual table definition, and see if\n * it's a PARTITION KEY definition.\n *\n * @param source: argv[i] source string\n * @param source_length: length of the source string\n * @param out_column_name: If it is a partition key, the output column name. Same lifetime\n * as source, points to specific char *\n * @param out_column_name_length: Length of out_column_name in bytes\n * @param out_column_type: SQLITE_TEXT or SQLITE_INTEGER.\n * @return int: SQLITE_EMPTY if not a PK, SQLITE_OK if it is.\n */\nint vec0_parse_partition_key_definition(const char *source, int source_length,\n                                 char **out_column_name,\n                                 int *out_column_name_length,\n                                 int *out_column_type) {\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n  char *column_name;\n  int column_name_length;\n  int column_type;\n  vec0_scanner_init(&scanner, source, source_length);\n\n  // Check first token is identifier, will be the column name\n  int rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n\n  column_name = token.start;\n  column_name_length = token.end - token.start;\n\n  // Check the next token matches \"text\" or \"integer\", as column type\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"text\", token.end - token.start) == 0) {\n    column_type = SQLITE_TEXT;\n  } else if (sqlite3_strnicmp(token.start, \"int\", token.end - token.start) ==\n                 0 ||\n             sqlite3_strnicmp(token.start, \"integer\",\n                              token.end - token.start) == 0) {\n    column_type = SQLITE_INTEGER;\n  } else {\n    return SQLITE_EMPTY;\n  }\n\n  // Check the next token is identifier and matches \"partition\"\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"partition\", token.end - token.start) != 0) {\n    return SQLITE_EMPTY;\n  }\n\n  // Check the next token is identifier and matches \"key\"\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"key\", token.end - token.start) != 0) {\n    return SQLITE_EMPTY;\n  }\n\n  *out_column_name = column_name;\n  *out_column_name_length = column_name_length;\n  *out_column_type = column_type;\n\n  return SQLITE_OK;\n}\n\n/**\n * @brief Parse an argv[i] entry of a vec0 virtual table definition, and see if\n * it's an auxiliar column definition, ie `+[name] [type]` like `+contents text`\n *\n * @param source: argv[i] source string\n * @param source_length: length of the source string\n * @param out_column_name: If it is a partition key, the output column name. Same lifetime\n * as source, points to specific char *\n * @param out_column_name_length: Length of out_column_name in bytes\n * @param out_column_type: SQLITE_TEXT, SQLITE_INTEGER, SQLITE_FLOAT, or SQLITE_BLOB.\n * @return int: SQLITE_EMPTY if not an aux column, SQLITE_OK if it is.\n */\nint vec0_parse_auxiliary_column_definition(const char *source, int source_length,\n                                 char **out_column_name,\n                                 int *out_column_name_length,\n                                 int *out_column_type) {\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n  char *column_name;\n  int column_name_length;\n  int column_type;\n  vec0_scanner_init(&scanner, source, source_length);\n\n  // Check first token is '+', which denotes aux columns\n  int rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME ||\n      token.token_type != TOKEN_TYPE_PLUS) {\n    return SQLITE_EMPTY;\n  }\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n\n  column_name = token.start;\n  column_name_length = token.end - token.start;\n\n  // Check the next token matches \"text\" or \"integer\", as column type\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"text\", token.end - token.start) == 0) {\n    column_type = SQLITE_TEXT;\n  } else if (sqlite3_strnicmp(token.start, \"int\", token.end - token.start) ==\n                 0 ||\n             sqlite3_strnicmp(token.start, \"integer\",\n                              token.end - token.start) == 0) {\n    column_type = SQLITE_INTEGER;\n  } else if (sqlite3_strnicmp(token.start, \"float\", token.end - token.start) ==\n                 0 ||\n             sqlite3_strnicmp(token.start, \"double\",\n                              token.end - token.start) == 0) {\n    column_type = SQLITE_FLOAT;\n  } else if (sqlite3_strnicmp(token.start, \"blob\", token.end - token.start) ==0) {\n    column_type = SQLITE_BLOB;\n  } else {\n    return SQLITE_EMPTY;\n  }\n\n  *out_column_name = column_name;\n  *out_column_name_length = column_name_length;\n  *out_column_type = column_type;\n\n  return SQLITE_OK;\n}\n\ntypedef enum {\n  VEC0_METADATA_COLUMN_KIND_BOOLEAN,\n  VEC0_METADATA_COLUMN_KIND_INTEGER,\n  VEC0_METADATA_COLUMN_KIND_FLOAT,\n  VEC0_METADATA_COLUMN_KIND_TEXT,\n  // future: blob, date, datetime\n} vec0_metadata_column_kind;\n\n/**\n * @brief Parse an argv[i] entry of a vec0 virtual table definition, and see if\n * it's an metadata column definition, ie `[name] [type]` like `is_released boolean`\n *\n * @param source: argv[i] source string\n * @param source_length: length of the source string\n * @param out_column_name: If it is a metadata column, the output column name. Same lifetime\n * as source, points to specific char *\n * @param out_column_name_length: Length of out_column_name in bytes\n * @param out_column_type: one of vec0_metadata_column_kind\n * @return int: SQLITE_EMPTY if not an metadata column, SQLITE_OK if it is.\n */\nint vec0_parse_metadata_column_definition(const char *source, int source_length,\n                                 char **out_column_name,\n                                 int *out_column_name_length,\n                                 vec0_metadata_column_kind *out_column_type) {\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n  char *column_name;\n  int column_name_length;\n  vec0_metadata_column_kind column_type;\n  int rc;\n  vec0_scanner_init(&scanner, source, source_length);\n\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME ||\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n\n  column_name = token.start;\n  column_name_length = token.end - token.start;\n\n  // Check the next token matches a valid metadata type\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME ||\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  char * t = token.start;\n  int n = token.end - token.start;\n  if (sqlite3_strnicmp(t, \"boolean\", n) == 0 || sqlite3_strnicmp(t, \"bool\", n) == 0) {\n    column_type = VEC0_METADATA_COLUMN_KIND_BOOLEAN;\n  }else if (sqlite3_strnicmp(t, \"int64\", n) == 0 || sqlite3_strnicmp(t, \"integer64\", n) == 0 || sqlite3_strnicmp(t, \"integer\", n) == 0 || sqlite3_strnicmp(t, \"int\", n) == 0) {\n    column_type = VEC0_METADATA_COLUMN_KIND_INTEGER;\n  }else if (sqlite3_strnicmp(t, \"float\", n) == 0 || sqlite3_strnicmp(t, \"double\", n) == 0 || sqlite3_strnicmp(t, \"float64\", n) == 0 || sqlite3_strnicmp(t, \"f64\", n) == 0) {\n    column_type = VEC0_METADATA_COLUMN_KIND_FLOAT;\n  } else if (sqlite3_strnicmp(t, \"text\", n) == 0) {\n    column_type = VEC0_METADATA_COLUMN_KIND_TEXT;\n  } else {\n    return SQLITE_EMPTY;\n  }\n\n  *out_column_name = column_name;\n  *out_column_name_length = column_name_length;\n  *out_column_type = column_type;\n\n  return SQLITE_OK;\n}\n\n/**\n * @brief Parse an argv[i] entry of a vec0 virtual table definition, and see if\n * it's a PRIMARY KEY definition.\n *\n * @param source: argv[i] source string\n * @param source_length: length of the source string\n * @param out_column_name: If it is a PK, the output column name. Same lifetime\n * as source, points to specific char *\n * @param out_column_name_length: Length of out_column_name in bytes\n * @param out_column_type: SQLITE_TEXT or SQLITE_INTEGER.\n * @return int: SQLITE_EMPTY if not a PK, SQLITE_OK if it is.\n */\nint vec0_parse_primary_key_definition(const char *source, int source_length,\n                                 char **out_column_name,\n                                 int *out_column_name_length,\n                                 int *out_column_type) {\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n  char *column_name;\n  int column_name_length;\n  int column_type;\n  vec0_scanner_init(&scanner, source, source_length);\n\n  // Check first token is identifier, will be the column name\n  int rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n\n  column_name = token.start;\n  column_name_length = token.end - token.start;\n\n  // Check the next token matches \"text\" or \"integer\", as column type\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"text\", token.end - token.start) == 0) {\n    column_type = SQLITE_TEXT;\n  } else if (sqlite3_strnicmp(token.start, \"int\", token.end - token.start) ==\n                 0 ||\n             sqlite3_strnicmp(token.start, \"integer\",\n                              token.end - token.start) == 0) {\n    column_type = SQLITE_INTEGER;\n  } else {\n    return SQLITE_EMPTY;\n  }\n\n  // Check the next token is identifier and matches \"primary\"\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"primary\", token.end - token.start) != 0) {\n    return SQLITE_EMPTY;\n  }\n\n  // Check the next token is identifier and matches \"key\"\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"key\", token.end - token.start) != 0) {\n    return SQLITE_EMPTY;\n  }\n\n  *out_column_name = column_name;\n  *out_column_name_length = column_name_length;\n  *out_column_type = column_type;\n\n  return SQLITE_OK;\n}\n\nenum Vec0DistanceMetrics {\n  VEC0_DISTANCE_METRIC_L2 = 1,\n  VEC0_DISTANCE_METRIC_COSINE = 2,\n  VEC0_DISTANCE_METRIC_L1 = 3,\n};\n\nstruct VectorColumnDefinition {\n  char *name;\n  int name_length;\n  size_t dimensions;\n  enum VectorElementType element_type;\n  enum Vec0DistanceMetrics distance_metric;\n};\n\nstruct Vec0PartitionColumnDefinition {\n  int type;\n  char * name;\n  int name_length;\n};\n\nstruct Vec0AuxiliaryColumnDefinition {\n  int type;\n  char * name;\n  int name_length;\n};\nstruct Vec0MetadataColumnDefinition {\n  vec0_metadata_column_kind kind;\n  char * name;\n  int name_length;\n};\n\nsize_t vector_byte_size(enum VectorElementType element_type,\n                        size_t dimensions) {\n  switch (element_type) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32:\n    return dimensions * sizeof(f32);\n  case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    return dimensions * sizeof(i8);\n  case SQLITE_VEC_ELEMENT_TYPE_BIT:\n    return dimensions / CHAR_BIT;\n  }\n  return 0;\n}\n\nsize_t vector_column_byte_size(struct VectorColumnDefinition column) {\n  return vector_byte_size(column.element_type, column.dimensions);\n}\n\n/**\n * @brief Parse an vec0 vtab argv[i] column definition and see if\n * it's a vector column defintion, ex `contents_embedding float[768]`.\n *\n * @param source vec0 argv[i] item\n * @param source_length length of source in bytes\n * @param outColumn Output the parse vector column to this struct, if success\n * @return int SQLITE_OK on success, SQLITE_EMPTY is it's not a vector column\n * definition, SQLITE_ERROR on error.\n */\nint vec0_parse_vector_column(const char *source, int source_length,\n                        struct VectorColumnDefinition *outColumn) {\n  // parses a vector column definition like so:\n  // \"abc float[123]\", \"abc_123 bit[1234]\", eetc.\n  // https://github.com/asg017/sqlite-vec/issues/46\n  int rc;\n  struct Vec0Scanner scanner;\n  struct Vec0Token token;\n\n  char *name;\n  int nameLength;\n  enum VectorElementType elementType;\n  enum Vec0DistanceMetrics distanceMetric = VEC0_DISTANCE_METRIC_L2;\n  int dimensions;\n\n  vec0_scanner_init(&scanner, source, source_length);\n\n  // starts with an identifier\n  rc = vec0_scanner_next(&scanner, &token);\n\n  if (rc != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n\n  name = token.start;\n  nameLength = token.end - token.start;\n\n  // vector column type comes next: float, int, or bit\n  rc = vec0_scanner_next(&scanner, &token);\n\n  if (rc != VEC0_TOKEN_RESULT_SOME ||\n      token.token_type != TOKEN_TYPE_IDENTIFIER) {\n    return SQLITE_EMPTY;\n  }\n  if (sqlite3_strnicmp(token.start, \"float\", 5) == 0 ||\n      sqlite3_strnicmp(token.start, \"f32\", 3) == 0) {\n    elementType = SQLITE_VEC_ELEMENT_TYPE_FLOAT32;\n  } else if (sqlite3_strnicmp(token.start, \"int8\", 4) == 0 ||\n             sqlite3_strnicmp(token.start, \"i8\", 2) == 0) {\n    elementType = SQLITE_VEC_ELEMENT_TYPE_INT8;\n  } else if (sqlite3_strnicmp(token.start, \"bit\", 3) == 0) {\n    elementType = SQLITE_VEC_ELEMENT_TYPE_BIT;\n  } else {\n    return SQLITE_EMPTY;\n  }\n\n  // left '[' bracket\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME && token.token_type != TOKEN_TYPE_LBRACKET) {\n    return SQLITE_EMPTY;\n  }\n\n  // digit, for vector dimension length\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME && token.token_type != TOKEN_TYPE_DIGIT) {\n    return SQLITE_ERROR;\n  }\n  dimensions = atoi(token.start);\n  if (dimensions <= 0) {\n    return SQLITE_ERROR;\n  }\n\n  // // right ']' bracket\n  rc = vec0_scanner_next(&scanner, &token);\n  if (rc != VEC0_TOKEN_RESULT_SOME && token.token_type != TOKEN_TYPE_RBRACKET) {\n    return SQLITE_ERROR;\n  }\n\n  // any other tokens left should be column-level options , ex `key=value`\n  // ex `distance_metric=L2 distance_metric=cosine` should error\n  while (1) {\n    // should be EOF or identifier (option key)\n    rc = vec0_scanner_next(&scanner, &token);\n    if (rc == VEC0_TOKEN_RESULT_EOF) {\n      break;\n    }\n\n    if (rc != VEC0_TOKEN_RESULT_SOME &&\n        token.token_type != TOKEN_TYPE_IDENTIFIER) {\n      return SQLITE_ERROR;\n    }\n\n    char *key = token.start;\n    int keyLength = token.end - token.start;\n\n    if (sqlite3_strnicmp(key, \"distance_metric\", keyLength) == 0) {\n\n      if (elementType == SQLITE_VEC_ELEMENT_TYPE_BIT) {\n        return SQLITE_ERROR;\n      }\n      // ensure equal sign after distance_metric\n      rc = vec0_scanner_next(&scanner, &token);\n      if (rc != VEC0_TOKEN_RESULT_SOME && token.token_type != TOKEN_TYPE_EQ) {\n        return SQLITE_ERROR;\n      }\n\n      // distance_metric value, an identifier (L2, cosine, etc)\n      rc = vec0_scanner_next(&scanner, &token);\n      if (rc != VEC0_TOKEN_RESULT_SOME &&\n          token.token_type != TOKEN_TYPE_IDENTIFIER) {\n        return SQLITE_ERROR;\n      }\n\n      char *value = token.start;\n      int valueLength = token.end - token.start;\n      if (sqlite3_strnicmp(value, \"l2\", valueLength) == 0) {\n        distanceMetric = VEC0_DISTANCE_METRIC_L2;\n      } else if (sqlite3_strnicmp(value, \"l1\", valueLength) == 0) {\n        distanceMetric = VEC0_DISTANCE_METRIC_L1;\n      } else if (sqlite3_strnicmp(value, \"cosine\", valueLength) == 0) {\n        distanceMetric = VEC0_DISTANCE_METRIC_COSINE;\n      } else {\n        return SQLITE_ERROR;\n      }\n    }\n    // unknown key\n    else {\n      return SQLITE_ERROR;\n    }\n  }\n\n  outColumn->name = sqlite3_mprintf(\"%.*s\", nameLength, name);\n  if (!outColumn->name) {\n    return SQLITE_ERROR;\n  }\n  outColumn->name_length = nameLength;\n  outColumn->distance_metric = distanceMetric;\n  outColumn->element_type = elementType;\n  outColumn->dimensions = dimensions;\n  return SQLITE_OK;\n}\n\n#pragma region vec_each table function\n\ntypedef struct vec_each_vtab vec_each_vtab;\nstruct vec_each_vtab {\n  sqlite3_vtab base;\n};\n\ntypedef struct vec_each_cursor vec_each_cursor;\nstruct vec_each_cursor {\n  sqlite3_vtab_cursor base;\n  i64 iRowid;\n  enum VectorElementType vector_type;\n  void *vector;\n  size_t dimensions;\n  vector_cleanup cleanup;\n};\n\nstatic int vec_eachConnect(sqlite3 *db, void *pAux, int argc,\n                           const char *const *argv, sqlite3_vtab **ppVtab,\n                           char **pzErr) {\n  UNUSED_PARAMETER(pAux);\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  UNUSED_PARAMETER(pzErr);\n  vec_each_vtab *pNew;\n  int rc;\n\n  rc = sqlite3_declare_vtab(db, \"CREATE TABLE x(value, vector hidden)\");\n#define VEC_EACH_COLUMN_VALUE 0\n#define VEC_EACH_COLUMN_VECTOR 1\n  if (rc == SQLITE_OK) {\n    pNew = sqlite3_malloc(sizeof(*pNew));\n    *ppVtab = (sqlite3_vtab *)pNew;\n    if (pNew == 0)\n      return SQLITE_NOMEM;\n    memset(pNew, 0, sizeof(*pNew));\n  }\n  return rc;\n}\n\nstatic int vec_eachDisconnect(sqlite3_vtab *pVtab) {\n  vec_each_vtab *p = (vec_each_vtab *)pVtab;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\nstatic int vec_eachOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor) {\n  UNUSED_PARAMETER(p);\n  vec_each_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(*pCur));\n  if (pCur == 0)\n    return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\nstatic int vec_eachClose(sqlite3_vtab_cursor *cur) {\n  vec_each_cursor *pCur = (vec_each_cursor *)cur;\n  if(pCur->vector) {\n    pCur->cleanup(pCur->vector);\n  }\n  sqlite3_free(pCur);\n  return SQLITE_OK;\n}\n\nstatic int vec_eachBestIndex(sqlite3_vtab *pVTab,\n                             sqlite3_index_info *pIdxInfo) {\n  UNUSED_PARAMETER(pVTab);\n  int hasVector = 0;\n  for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n    const struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];\n    // printf(\"i=%d iColumn=%d, op=%d, usable=%d\\n\", i, pCons->iColumn,\n    // pCons->op, pCons->usable);\n    switch (pCons->iColumn) {\n    case VEC_EACH_COLUMN_VECTOR: {\n      if (pCons->op == SQLITE_INDEX_CONSTRAINT_EQ && pCons->usable) {\n        hasVector = 1;\n        pIdxInfo->aConstraintUsage[i].argvIndex = 1;\n        pIdxInfo->aConstraintUsage[i].omit = 1;\n      }\n      break;\n    }\n    }\n  }\n  if (!hasVector) {\n    return SQLITE_CONSTRAINT;\n  }\n\n  pIdxInfo->estimatedCost = (double)100000;\n  pIdxInfo->estimatedRows = 100000;\n\n  return SQLITE_OK;\n}\n\nstatic int vec_eachFilter(sqlite3_vtab_cursor *pVtabCursor, int idxNum,\n                          const char *idxStr, int argc, sqlite3_value **argv) {\n  UNUSED_PARAMETER(idxNum);\n  UNUSED_PARAMETER(idxStr);\n  assert(argc == 1);\n  vec_each_cursor *pCur = (vec_each_cursor *)pVtabCursor;\n\n  if (pCur->vector) {\n    pCur->cleanup(pCur->vector);\n    pCur->vector = NULL;\n  }\n\n  char *pzErrMsg;\n  int rc = vector_from_value(argv[0], &pCur->vector, &pCur->dimensions,\n                             &pCur->vector_type, &pCur->cleanup, &pzErrMsg);\n  if (rc != SQLITE_OK) {\n    return SQLITE_ERROR;\n  }\n  pCur->iRowid = 0;\n  return SQLITE_OK;\n}\n\nstatic int vec_eachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid) {\n  vec_each_cursor *pCur = (vec_each_cursor *)cur;\n  *pRowid = pCur->iRowid;\n  return SQLITE_OK;\n}\n\nstatic int vec_eachEof(sqlite3_vtab_cursor *cur) {\n  vec_each_cursor *pCur = (vec_each_cursor *)cur;\n  return pCur->iRowid >= (i64)pCur->dimensions;\n}\n\nstatic int vec_eachNext(sqlite3_vtab_cursor *cur) {\n  vec_each_cursor *pCur = (vec_each_cursor *)cur;\n  pCur->iRowid++;\n  return SQLITE_OK;\n}\n\nstatic int vec_eachColumn(sqlite3_vtab_cursor *cur, sqlite3_context *context,\n                          int i) {\n  vec_each_cursor *pCur = (vec_each_cursor *)cur;\n  switch (i) {\n  case VEC_EACH_COLUMN_VALUE:\n    switch (pCur->vector_type) {\n    case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n      sqlite3_result_double(context, ((f32 *)pCur->vector)[pCur->iRowid]);\n      break;\n    }\n    case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n      u8 x = ((u8 *)pCur->vector)[pCur->iRowid / CHAR_BIT];\n      sqlite3_result_int(context,\n                         (x & (0b10000000 >> ((pCur->iRowid % CHAR_BIT)))) > 0);\n      break;\n    }\n    case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n      sqlite3_result_int(context, ((i8 *)pCur->vector)[pCur->iRowid]);\n      break;\n    }\n    }\n\n    break;\n  }\n  return SQLITE_OK;\n}\n\nstatic sqlite3_module vec_eachModule = {\n    /* iVersion    */ 0,\n    /* xCreate     */ 0,\n    /* xConnect    */ vec_eachConnect,\n    /* xBestIndex  */ vec_eachBestIndex,\n    /* xDisconnect */ vec_eachDisconnect,\n    /* xDestroy    */ 0,\n    /* xOpen       */ vec_eachOpen,\n    /* xClose      */ vec_eachClose,\n    /* xFilter     */ vec_eachFilter,\n    /* xNext       */ vec_eachNext,\n    /* xEof        */ vec_eachEof,\n    /* xColumn     */ vec_eachColumn,\n    /* xRowid      */ vec_eachRowid,\n    /* xUpdate     */ 0,\n    /* xBegin      */ 0,\n    /* xSync       */ 0,\n    /* xCommit     */ 0,\n    /* xRollback   */ 0,\n    /* xFindMethod */ 0,\n    /* xRename     */ 0,\n    /* xSavepoint  */ 0,\n    /* xRelease    */ 0,\n    /* xRollbackTo */ 0,\n    /* xShadowName */ 0,\n#if SQLITE_VERSION_NUMBER >= 3044000\n    /* xIntegrity  */ 0\n#endif\n};\n\n#pragma endregion\n\n#pragma region vec_npy_each table function\n\nenum NpyTokenType {\n  NPY_TOKEN_TYPE_IDENTIFIER,\n  NPY_TOKEN_TYPE_NUMBER,\n  NPY_TOKEN_TYPE_LPAREN,\n  NPY_TOKEN_TYPE_RPAREN,\n  NPY_TOKEN_TYPE_LBRACE,\n  NPY_TOKEN_TYPE_RBRACE,\n  NPY_TOKEN_TYPE_COLON,\n  NPY_TOKEN_TYPE_COMMA,\n  NPY_TOKEN_TYPE_STRING,\n  NPY_TOKEN_TYPE_FALSE,\n};\n\nstruct NpyToken {\n  enum NpyTokenType token_type;\n  unsigned char *start;\n  unsigned char *end;\n};\n\nint npy_token_next(unsigned char *start, unsigned char *end,\n                   struct NpyToken *out) {\n  unsigned char *ptr = start;\n  while (ptr < end) {\n    unsigned char curr = *ptr;\n    if (is_whitespace(curr)) {\n      ptr++;\n      continue;\n    } else if (curr == '(') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_LPAREN;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == ')') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_RPAREN;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == '{') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_LBRACE;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == '}') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_RBRACE;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == ':') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_COLON;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == ',') {\n      out->start = ptr++;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_COMMA;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == '\\'') {\n      unsigned char *start = ptr;\n      ptr++;\n      while (ptr < end) {\n        if ((*ptr) == '\\'') {\n          break;\n        }\n        ptr++;\n      }\n      if ((*ptr) != '\\'') {\n        return VEC0_TOKEN_RESULT_ERROR;\n      }\n      out->start = start;\n      out->end = ++ptr;\n      out->token_type = NPY_TOKEN_TYPE_STRING;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (curr == 'F' &&\n               strncmp((char *)ptr, \"False\", strlen(\"False\")) == 0) {\n      out->start = ptr;\n      out->end = (ptr + (int)strlen(\"False\"));\n      ptr = out->end;\n      out->token_type = NPY_TOKEN_TYPE_FALSE;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else if (is_digit(curr)) {\n      unsigned char *start = ptr;\n      while (ptr < end && (is_digit(*ptr))) {\n        ptr++;\n      }\n      out->start = start;\n      out->end = ptr;\n      out->token_type = NPY_TOKEN_TYPE_NUMBER;\n      return VEC0_TOKEN_RESULT_SOME;\n    } else {\n      return VEC0_TOKEN_RESULT_ERROR;\n    }\n  }\n  return VEC0_TOKEN_RESULT_ERROR;\n}\n\nstruct NpyScanner {\n  unsigned char *start;\n  unsigned char *end;\n  unsigned char *ptr;\n};\n\nvoid npy_scanner_init(struct NpyScanner *scanner, const unsigned char *source,\n                      int source_length) {\n  scanner->start = (unsigned char *)source;\n  scanner->end = (unsigned char *)source + source_length;\n  scanner->ptr = (unsigned char *)source;\n}\n\nint npy_scanner_next(struct NpyScanner *scanner, struct NpyToken *out) {\n  int rc = npy_token_next(scanner->start, scanner->end, out);\n  if (rc == VEC0_TOKEN_RESULT_SOME) {\n    scanner->start = out->end;\n  }\n  return rc;\n}\n\n#define NPY_PARSE_ERROR \"Error parsing numpy array: \"\nint parse_npy_header(sqlite3_vtab *pVTab, const unsigned char *header,\n                     size_t headerLength,\n                     enum VectorElementType *out_element_type,\n                     int *fortran_order, size_t *numElements,\n                     size_t *numDimensions) {\n\n  struct NpyScanner scanner;\n  struct NpyToken token;\n  int rc;\n  npy_scanner_init(&scanner, header, headerLength);\n\n  if (npy_scanner_next(&scanner, &token) != VEC0_TOKEN_RESULT_SOME &&\n      token.token_type != NPY_TOKEN_TYPE_LBRACE) {\n    vtab_set_error(pVTab,\n                   NPY_PARSE_ERROR \"numpy header did not start with '{'\");\n    return SQLITE_ERROR;\n  }\n  while (1) {\n    rc = npy_scanner_next(&scanner, &token);\n    if (rc != VEC0_TOKEN_RESULT_SOME) {\n      vtab_set_error(pVTab, NPY_PARSE_ERROR \"expected key in numpy header\");\n      return SQLITE_ERROR;\n    }\n\n    if (token.token_type == NPY_TOKEN_TYPE_RBRACE) {\n      break;\n    }\n    if (token.token_type != NPY_TOKEN_TYPE_STRING) {\n      vtab_set_error(pVTab, NPY_PARSE_ERROR\n                     \"expected a string as key in numpy header\");\n      return SQLITE_ERROR;\n    }\n    unsigned char *key = token.start;\n\n    rc = npy_scanner_next(&scanner, &token);\n    if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n        (token.token_type != NPY_TOKEN_TYPE_COLON)) {\n      vtab_set_error(pVTab, NPY_PARSE_ERROR\n                     \"expected a ':' after key in numpy header\");\n      return SQLITE_ERROR;\n    }\n\n    if (strncmp((char *)key, \"'descr'\", strlen(\"'descr'\")) == 0) {\n      rc = npy_scanner_next(&scanner, &token);\n      if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n          (token.token_type != NPY_TOKEN_TYPE_STRING)) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"expected a string value after 'descr' key\");\n        return SQLITE_ERROR;\n      }\n      if (strncmp((char *)token.start, \"'<f4'\", strlen(\"'<f4'\")) != 0) {\n        vtab_set_error(\n            pVTab, NPY_PARSE_ERROR\n            \"Only '<f4' values are supported in sqlite-vec numpy functions\");\n        return SQLITE_ERROR;\n      }\n      *out_element_type = SQLITE_VEC_ELEMENT_TYPE_FLOAT32;\n    } else if (strncmp((char *)key, \"'fortran_order'\",\n                       strlen(\"'fortran_order'\")) == 0) {\n      rc = npy_scanner_next(&scanner, &token);\n      if (rc != VEC0_TOKEN_RESULT_SOME ||\n          token.token_type != NPY_TOKEN_TYPE_FALSE) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"Only fortran_order = False is supported in sqlite-vec \"\n                       \"numpy functions\");\n        return SQLITE_ERROR;\n      }\n      *fortran_order = 0;\n    } else if (strncmp((char *)key, \"'shape'\", strlen(\"'shape'\")) == 0) {\n      // \"(xxx, xxx)\" OR (xxx,)\n      size_t first;\n      rc = npy_scanner_next(&scanner, &token);\n      if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n          (token.token_type != NPY_TOKEN_TYPE_LPAREN)) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"Expected left parenthesis '(' after shape key\");\n        return SQLITE_ERROR;\n      }\n\n      rc = npy_scanner_next(&scanner, &token);\n      if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n          (token.token_type != NPY_TOKEN_TYPE_NUMBER)) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"Expected an initial number in shape value\");\n        return SQLITE_ERROR;\n      }\n      first = strtol((char *)token.start, NULL, 10);\n\n      rc = npy_scanner_next(&scanner, &token);\n      if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n          (token.token_type != NPY_TOKEN_TYPE_COMMA)) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"Expected comma after first shape value\");\n        return SQLITE_ERROR;\n      }\n\n      rc = npy_scanner_next(&scanner, &token);\n      if (rc != VEC0_TOKEN_RESULT_SOME) {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR\n                       \"unexpected header EOF while parsing shape\");\n        return SQLITE_ERROR;\n      }\n      if (token.token_type == NPY_TOKEN_TYPE_NUMBER) {\n        *numElements = first;\n        *numDimensions = strtol((char *)token.start, NULL, 10);\n        rc = npy_scanner_next(&scanner, &token);\n        if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n            (token.token_type != NPY_TOKEN_TYPE_RPAREN)) {\n          vtab_set_error(pVTab, NPY_PARSE_ERROR\n                         \"expected right parenthesis after shape value\");\n          return SQLITE_ERROR;\n        }\n      } else if (token.token_type == NPY_TOKEN_TYPE_RPAREN) {\n        // '(0,)' means an empty array!\n        *numElements = first ? 1 : 0;\n        *numDimensions = first;\n      } else {\n        vtab_set_error(pVTab, NPY_PARSE_ERROR \"unknown type in shape value\");\n        return SQLITE_ERROR;\n      }\n    } else {\n      vtab_set_error(pVTab, NPY_PARSE_ERROR \"unknown key in numpy header\");\n      return SQLITE_ERROR;\n    }\n\n    rc = npy_scanner_next(&scanner, &token);\n    if ((rc != VEC0_TOKEN_RESULT_SOME) ||\n        (token.token_type != NPY_TOKEN_TYPE_COMMA)) {\n      vtab_set_error(pVTab, NPY_PARSE_ERROR \"unknown extra token after value\");\n      return SQLITE_ERROR;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\ntypedef struct vec_npy_each_vtab vec_npy_each_vtab;\nstruct vec_npy_each_vtab {\n  sqlite3_vtab base;\n};\n\ntypedef enum {\n  VEC_NPY_EACH_INPUT_BUFFER,\n  VEC_NPY_EACH_INPUT_FILE,\n} vec_npy_each_input_type;\n\ntypedef struct vec_npy_each_cursor vec_npy_each_cursor;\nstruct vec_npy_each_cursor {\n  sqlite3_vtab_cursor base;\n  i64 iRowid;\n  // sqlite-vec compatible type of vector\n  enum VectorElementType elementType;\n  // number of vectors in the npy array\n  size_t nElements;\n  // number of dimensions each vector has\n  size_t nDimensions;\n\n  vec_npy_each_input_type input_type;\n\n  // when input_type == VEC_NPY_EACH_INPUT_BUFFER\n\n  // Buffer containing the vector data, when reading from an in-memory buffer.\n  // Size: nElements * nDimensions * element_size\n  // Clean up with sqlite3_free() once complete\n  void *vector;\n\n  // when input_type == VEC_NPY_EACH_INPUT_FILE\n\n  // Opened npy file, when reading from a file.\n  // fclose() when complete.\n#ifndef SQLITE_VEC_OMIT_FS\n  FILE *file;\n#endif\n\n  // an in-memory buffer containing a portion of the npy array.\n  // Used for faster reading, instead of calling fread a lot.\n  // Will have a byte-size of fileBufferSize\n  void *chunksBuffer;\n  // size of allocated fileBuffer in bytes\n  size_t chunksBufferSize;\n  //// Maximum length of the buffer, in terms of number of vectors.\n  size_t maxChunks;\n\n  // Counter index of the current vector into of fileBuffer to yield.\n  // Starts at 0 once fileBuffer is read, and iterates to bufferLength.\n  // Resets to 0 once that \"buffer\" is yielded and a new one is read.\n  size_t currentChunkIndex;\n  size_t currentChunkSize;\n\n  // 0 when there are still more elements to read/yield, 1 when complete.\n  int eof;\n};\n\nstatic unsigned char NPY_MAGIC[6] = \"\\x93NUMPY\";\n\n#ifndef SQLITE_VEC_OMIT_FS\nint parse_npy_file(sqlite3_vtab *pVTab, FILE *file, vec_npy_each_cursor *pCur) {\n  int n;\n  fseek(file, 0, SEEK_END);\n  long fileSize = ftell(file);\n\n  fseek(file, 0L, SEEK_SET);\n\n  unsigned char header[10];\n  n = fread(&header, sizeof(unsigned char), 10, file);\n  if (n != 10) {\n    vtab_set_error(pVTab, \"numpy array file too short\");\n    return SQLITE_ERROR;\n  }\n\n  if (memcmp(NPY_MAGIC, header, sizeof(NPY_MAGIC)) != 0) {\n    vtab_set_error(pVTab,\n                   \"numpy array file does not contain the 'magic' header\");\n    return SQLITE_ERROR;\n  }\n\n  u8 major = header[6];\n  u8 minor = header[7];\n  uint16_t headerLength = 0;\n  memcpy(&headerLength, &header[8], sizeof(uint16_t));\n\n  size_t totalHeaderLength = sizeof(NPY_MAGIC) + sizeof(major) + sizeof(minor) +\n                             sizeof(headerLength) + headerLength;\n  i32 dataSize = fileSize - totalHeaderLength;\n  if (dataSize < 0) {\n    vtab_set_error(pVTab, \"numpy array file header length is invalid\");\n    return SQLITE_ERROR;\n  }\n\n  unsigned char *headerX = sqlite3_malloc(headerLength);\n  if (headerLength && !headerX) {\n    return SQLITE_NOMEM;\n  }\n\n  n = fread(headerX, sizeof(char), headerLength, file);\n  if (n != headerLength) {\n    sqlite3_free(headerX);\n    vtab_set_error(pVTab, \"numpy array file header length is invalid\");\n    return SQLITE_ERROR;\n  }\n\n  int fortran_order;\n  enum VectorElementType element_type;\n  size_t numElements;\n  size_t numDimensions;\n  int rc = parse_npy_header(pVTab, headerX, headerLength, &element_type,\n                            &fortran_order, &numElements, &numDimensions);\n  sqlite3_free(headerX);\n  if (rc != SQLITE_OK) {\n    // parse_npy_header already attackes an error emssage\n    return rc;\n  }\n\n  i32 expectedDataSize =\n      numElements * vector_byte_size(element_type, numDimensions);\n  if (expectedDataSize != dataSize) {\n    vtab_set_error(\n        pVTab, \"numpy array file error: Expected a data size of %d, found %d\",\n        expectedDataSize, dataSize);\n    return SQLITE_ERROR;\n  }\n\n  pCur->maxChunks = 1024;\n  pCur->chunksBufferSize =\n      (vector_byte_size(element_type, numDimensions)) * pCur->maxChunks;\n  pCur->chunksBuffer = sqlite3_malloc(pCur->chunksBufferSize);\n  if (pCur->chunksBufferSize && !pCur->chunksBuffer) {\n    return SQLITE_NOMEM;\n  }\n\n  pCur->currentChunkSize =\n      fread(pCur->chunksBuffer, vector_byte_size(element_type, numDimensions),\n            pCur->maxChunks, file);\n\n  pCur->currentChunkIndex = 0;\n  pCur->elementType = element_type;\n  pCur->nElements = numElements;\n  pCur->nDimensions = numDimensions;\n  pCur->input_type = VEC_NPY_EACH_INPUT_FILE;\n\n  pCur->eof = pCur->currentChunkSize == 0;\n  pCur->file = file;\n  return SQLITE_OK;\n}\n#endif\n\nint parse_npy_buffer(sqlite3_vtab *pVTab, const unsigned char *buffer,\n                     int bufferLength, void **data, size_t *numElements,\n                     size_t *numDimensions,\n                     enum VectorElementType *element_type) {\n\n  if (bufferLength < 10) {\n    // IMP: V03312_20150\n    vtab_set_error(pVTab, \"numpy array too short\");\n    return SQLITE_ERROR;\n  }\n  if (memcmp(NPY_MAGIC, buffer, sizeof(NPY_MAGIC)) != 0) {\n    // V11954_28792\n    vtab_set_error(pVTab, \"numpy array does not contain the 'magic' header\");\n    return SQLITE_ERROR;\n  }\n\n  u8 major = buffer[6];\n  u8 minor = buffer[7];\n  uint16_t headerLength = 0;\n  memcpy(&headerLength, &buffer[8], sizeof(uint16_t));\n\n  i32 totalHeaderLength = sizeof(NPY_MAGIC) + sizeof(major) + sizeof(minor) +\n                          sizeof(headerLength) + headerLength;\n  i32 dataSize = bufferLength - totalHeaderLength;\n\n  if (dataSize < 0) {\n    vtab_set_error(pVTab, \"numpy array header length is invalid\");\n    return SQLITE_ERROR;\n  }\n\n  const unsigned char *header = &buffer[10];\n  int fortran_order;\n\n  int rc = parse_npy_header(pVTab, header, headerLength, element_type,\n                            &fortran_order, numElements, numDimensions);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n\n  i32 expectedDataSize =\n      (*numElements * vector_byte_size(*element_type, *numDimensions));\n  if (expectedDataSize != dataSize) {\n    vtab_set_error(pVTab,\n                   \"numpy array error: Expected a data size of %d, found %d\",\n                   expectedDataSize, dataSize);\n    return SQLITE_ERROR;\n  }\n\n  *data = (void *)&buffer[totalHeaderLength];\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachConnect(sqlite3 *db, void *pAux, int argc,\n                               const char *const *argv, sqlite3_vtab **ppVtab,\n                               char **pzErr) {\n  UNUSED_PARAMETER(pAux);\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  UNUSED_PARAMETER(pzErr);\n  vec_npy_each_vtab *pNew;\n  int rc;\n\n  rc = sqlite3_declare_vtab(db, \"CREATE TABLE x(vector, input hidden)\");\n#define VEC_NPY_EACH_COLUMN_VECTOR 0\n#define VEC_NPY_EACH_COLUMN_INPUT 1\n  if (rc == SQLITE_OK) {\n    pNew = sqlite3_malloc(sizeof(*pNew));\n    *ppVtab = (sqlite3_vtab *)pNew;\n    if (pNew == 0)\n      return SQLITE_NOMEM;\n    memset(pNew, 0, sizeof(*pNew));\n  }\n  return rc;\n}\n\nstatic int vec_npy_eachDisconnect(sqlite3_vtab *pVtab) {\n  vec_npy_each_vtab *p = (vec_npy_each_vtab *)pVtab;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor) {\n  UNUSED_PARAMETER(p);\n  vec_npy_each_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(*pCur));\n  if (pCur == 0)\n    return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachClose(sqlite3_vtab_cursor *cur) {\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)cur;\n#ifndef SQLITE_VEC_OMIT_FS\n  if (pCur->file) {\n    fclose(pCur->file);\n    pCur->file = NULL;\n  }\n#endif\n  if (pCur->chunksBuffer) {\n    sqlite3_free(pCur->chunksBuffer);\n    pCur->chunksBuffer = NULL;\n  }\n  if (pCur->vector) {\n    pCur->vector = NULL;\n  }\n  sqlite3_free(pCur);\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachBestIndex(sqlite3_vtab *pVTab,\n                                 sqlite3_index_info *pIdxInfo) {\n  int hasInput;\n  for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n    const struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];\n    // printf(\"i=%d iColumn=%d, op=%d, usable=%d\\n\", i, pCons->iColumn,\n    // pCons->op, pCons->usable);\n    switch (pCons->iColumn) {\n    case VEC_NPY_EACH_COLUMN_INPUT: {\n      if (pCons->op == SQLITE_INDEX_CONSTRAINT_EQ && pCons->usable) {\n        hasInput = 1;\n        pIdxInfo->aConstraintUsage[i].argvIndex = 1;\n        pIdxInfo->aConstraintUsage[i].omit = 1;\n      }\n      break;\n    }\n    }\n  }\n  if (!hasInput) {\n    pVTab->zErrMsg = sqlite3_mprintf(\"input argument is required\");\n    return SQLITE_ERROR;\n  }\n\n  pIdxInfo->estimatedCost = (double)100000;\n  pIdxInfo->estimatedRows = 100000;\n\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachFilter(sqlite3_vtab_cursor *pVtabCursor, int idxNum,\n                              const char *idxStr, int argc,\n                              sqlite3_value **argv) {\n  UNUSED_PARAMETER(idxNum);\n  UNUSED_PARAMETER(idxStr);\n  assert(argc == 1);\n  int rc;\n\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)pVtabCursor;\n\n#ifndef SQLITE_VEC_OMIT_FS\n  if (pCur->file) {\n    fclose(pCur->file);\n    pCur->file = NULL;\n  }\n#endif\n  if (pCur->chunksBuffer) {\n    sqlite3_free(pCur->chunksBuffer);\n    pCur->chunksBuffer = NULL;\n  }\n  if (pCur->vector) {\n    pCur->vector = NULL;\n  }\n\n#ifndef SQLITE_VEC_OMIT_FS\n  struct VecNpyFile *f = NULL;\n  if ((f = sqlite3_value_pointer(argv[0], SQLITE_VEC_NPY_FILE_NAME))) {\n    FILE *file = fopen(f->path, \"r\");\n    if (!file) {\n      vtab_set_error(pVtabCursor->pVtab, \"Could not open numpy file\");\n      return SQLITE_ERROR;\n    }\n\n    rc = parse_npy_file(pVtabCursor->pVtab, file, pCur);\n    if (rc != SQLITE_OK) {\n#ifndef SQLITE_VEC_OMIT_FS\n      fclose(file);\n#endif\n      return rc;\n    }\n\n  } else\n#endif\n  {\n\n    const unsigned char *input = sqlite3_value_blob(argv[0]);\n    int inputLength = sqlite3_value_bytes(argv[0]);\n    void *data;\n    size_t numElements;\n    size_t numDimensions;\n    enum VectorElementType element_type;\n\n    rc = parse_npy_buffer(pVtabCursor->pVtab, input, inputLength, &data,\n                          &numElements, &numDimensions, &element_type);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n\n    pCur->vector = data;\n    pCur->elementType = element_type;\n    pCur->nElements = numElements;\n    pCur->nDimensions = numDimensions;\n    pCur->input_type = VEC_NPY_EACH_INPUT_BUFFER;\n  }\n\n  pCur->iRowid = 0;\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid) {\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)cur;\n  *pRowid = pCur->iRowid;\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachEof(sqlite3_vtab_cursor *cur) {\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)cur;\n  if (pCur->input_type == VEC_NPY_EACH_INPUT_BUFFER) {\n    return (!pCur->nElements) || (size_t)pCur->iRowid >= pCur->nElements;\n  }\n  return pCur->eof;\n}\n\nstatic int vec_npy_eachNext(sqlite3_vtab_cursor *cur) {\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)cur;\n  pCur->iRowid++;\n  if (pCur->input_type == VEC_NPY_EACH_INPUT_BUFFER) {\n    return SQLITE_OK;\n  }\n\n#ifndef SQLITE_VEC_OMIT_FS\n  // else: input is a file\n  pCur->currentChunkIndex++;\n  if (pCur->currentChunkIndex >= pCur->currentChunkSize) {\n    pCur->currentChunkSize =\n        fread(pCur->chunksBuffer,\n              vector_byte_size(pCur->elementType, pCur->nDimensions),\n              pCur->maxChunks, pCur->file);\n    if (!pCur->currentChunkSize) {\n      pCur->eof = 1;\n    }\n    pCur->currentChunkIndex = 0;\n  }\n#endif\n  return SQLITE_OK;\n}\n\nstatic int vec_npy_eachColumnBuffer(vec_npy_each_cursor *pCur,\n                                    sqlite3_context *context, int i) {\n  switch (i) {\n  case VEC_NPY_EACH_COLUMN_VECTOR: {\n    sqlite3_result_subtype(context, pCur->elementType);\n    switch (pCur->elementType) {\n    case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n      sqlite3_result_blob(\n          context,\n          &((unsigned char *)\n                pCur->vector)[pCur->iRowid * pCur->nDimensions * sizeof(f32)],\n          pCur->nDimensions * sizeof(f32), SQLITE_TRANSIENT);\n\n      break;\n    }\n    case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n      // https://github.com/asg017/sqlite-vec/issues/42\n      sqlite3_result_error(context,\n                           \"vec_npy_each only supports float32 vectors\", -1);\n      break;\n    }\n    }\n\n    break;\n  }\n  }\n  return SQLITE_OK;\n}\nstatic int vec_npy_eachColumnFile(vec_npy_each_cursor *pCur,\n                                  sqlite3_context *context, int i) {\n  switch (i) {\n  case VEC_NPY_EACH_COLUMN_VECTOR: {\n    switch (pCur->elementType) {\n    case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n      sqlite3_result_blob(\n          context,\n          &((unsigned char *)\n                pCur->chunksBuffer)[pCur->currentChunkIndex *\n                                    pCur->nDimensions * sizeof(f32)],\n          pCur->nDimensions * sizeof(f32), SQLITE_TRANSIENT);\n      break;\n    }\n    case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n      // https://github.com/asg017/sqlite-vec/issues/42\n      sqlite3_result_error(context,\n                           \"vec_npy_each only supports float32 vectors\", -1);\n      break;\n    }\n    }\n    break;\n  }\n  }\n  return SQLITE_OK;\n}\nstatic int vec_npy_eachColumn(sqlite3_vtab_cursor *cur,\n                              sqlite3_context *context, int i) {\n  vec_npy_each_cursor *pCur = (vec_npy_each_cursor *)cur;\n  switch (pCur->input_type) {\n  case VEC_NPY_EACH_INPUT_BUFFER:\n    return vec_npy_eachColumnBuffer(pCur, context, i);\n  case VEC_NPY_EACH_INPUT_FILE:\n    return vec_npy_eachColumnFile(pCur, context, i);\n  }\n  return SQLITE_ERROR;\n}\n\nstatic sqlite3_module vec_npy_eachModule = {\n    /* iVersion    */ 0,\n    /* xCreate     */ 0,\n    /* xConnect    */ vec_npy_eachConnect,\n    /* xBestIndex  */ vec_npy_eachBestIndex,\n    /* xDisconnect */ vec_npy_eachDisconnect,\n    /* xDestroy    */ 0,\n    /* xOpen       */ vec_npy_eachOpen,\n    /* xClose      */ vec_npy_eachClose,\n    /* xFilter     */ vec_npy_eachFilter,\n    /* xNext       */ vec_npy_eachNext,\n    /* xEof        */ vec_npy_eachEof,\n    /* xColumn     */ vec_npy_eachColumn,\n    /* xRowid      */ vec_npy_eachRowid,\n    /* xUpdate     */ 0,\n    /* xBegin      */ 0,\n    /* xSync       */ 0,\n    /* xCommit     */ 0,\n    /* xRollback   */ 0,\n    /* xFindMethod */ 0,\n    /* xRename     */ 0,\n    /* xSavepoint  */ 0,\n    /* xRelease    */ 0,\n    /* xRollbackTo */ 0,\n    /* xShadowName */ 0,\n#if SQLITE_VERSION_NUMBER >= 3044000\n    /* xIntegrity  */ 0,\n#endif\n};\n\n#pragma endregion\n\n#pragma region vec0 virtual table\n\n#define VEC0_COLUMN_ID 0\n#define VEC0_COLUMN_USERN_START 1\n#define VEC0_COLUMN_OFFSET_DISTANCE 1\n#define VEC0_COLUMN_OFFSET_K 2\n\n#define VEC0_SHADOW_INFO_NAME \"\\\"%w\\\".\\\"%w_info\\\"\"\n\n#define VEC0_SHADOW_CHUNKS_NAME \"\\\"%w\\\".\\\"%w_chunks\\\"\"\n/// 1) schema, 2) original vtab table name\n#define VEC0_SHADOW_CHUNKS_CREATE                                              \\\n  \"CREATE TABLE \" VEC0_SHADOW_CHUNKS_NAME \"(\"                                  \\\n  \"chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,\"                                \\\n  \"size INTEGER NOT NULL,\"                                                     \\\n  \"validity BLOB NOT NULL,\"                                                    \\\n  \"rowids BLOB NOT NULL\"                                                       \\\n  \");\"\n\n#define VEC0_SHADOW_ROWIDS_NAME \"\\\"%w\\\".\\\"%w_rowids\\\"\"\n/// 1) schema, 2) original vtab table name\n#define VEC0_SHADOW_ROWIDS_CREATE_BASIC                                        \\\n  \"CREATE TABLE \" VEC0_SHADOW_ROWIDS_NAME \"(\"                                  \\\n  \"rowid INTEGER PRIMARY KEY AUTOINCREMENT,\"                                   \\\n  \"id,\"                                                                        \\\n  \"chunk_id INTEGER,\"                                                          \\\n  \"chunk_offset INTEGER\"                                                       \\\n  \");\"\n\n// vec0 tables with a text primary keys are still backed by int64 primary keys,\n// since a fixed-length rowid is required for vec0 chunks. But we add a new 'id\n// text unique' column to emulate a text primary key interface.\n#define VEC0_SHADOW_ROWIDS_CREATE_PK_TEXT                                      \\\n  \"CREATE TABLE \" VEC0_SHADOW_ROWIDS_NAME \"(\"                                  \\\n  \"rowid INTEGER PRIMARY KEY AUTOINCREMENT,\"                                   \\\n  \"id TEXT UNIQUE NOT NULL,\"                                                   \\\n  \"chunk_id INTEGER,\"                                                          \\\n  \"chunk_offset INTEGER\"                                                       \\\n  \");\"\n\n/// 1) schema, 2) original vtab table name\n#define VEC0_SHADOW_VECTOR_N_NAME \"\\\"%w\\\".\\\"%w_vector_chunks%02d\\\"\"\n\n/// 1) schema, 2) original vtab table name\n#define VEC0_SHADOW_VECTOR_N_CREATE                                            \\\n  \"CREATE TABLE \" VEC0_SHADOW_VECTOR_N_NAME \"(\"                                \\\n  \"rowid PRIMARY KEY,\"                                                         \\\n  \"vectors BLOB NOT NULL\"                                                      \\\n  \");\"\n\n#define VEC0_SHADOW_AUXILIARY_NAME \"\\\"%w\\\".\\\"%w_auxiliary\\\"\"\n\n#define VEC0_SHADOW_METADATA_N_NAME \"\\\"%w\\\".\\\"%w_metadatachunks%02d\\\"\"\n#define VEC0_SHADOW_METADATA_TEXT_DATA_NAME \"\\\"%w\\\".\\\"%w_metadatatext%02d\\\"\"\n\n#define VEC_INTERAL_ERROR \"Internal sqlite-vec error: \"\n#define REPORT_URL \"https://github.com/asg017/sqlite-vec/issues/new\"\n\ntypedef struct vec0_vtab vec0_vtab;\n\n#define VEC0_MAX_VECTOR_COLUMNS   16\n#define VEC0_MAX_PARTITION_COLUMNS 4\n#define VEC0_MAX_AUXILIARY_COLUMNS 16\n#define VEC0_MAX_METADATA_COLUMNS 16\n\n#define SQLITE_VEC_VEC0_MAX_DIMENSIONS 8192\n#define VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH 16\n#define VEC0_METADATA_TEXT_VIEW_DATA_LENGTH 12\n\ntypedef enum {\n  // vector column, ie \"contents_embedding float[1024]\"\n  SQLITE_VEC0_USER_COLUMN_KIND_VECTOR = 1,\n\n  // partition key column, ie \"user_id integer partition key\"\n  SQLITE_VEC0_USER_COLUMN_KIND_PARTITION = 2,\n\n  //\n  SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY = 3,\n\n  // metadata column that can be filtered, ie \"genre text\"\n  SQLITE_VEC0_USER_COLUMN_KIND_METADATA = 4,\n} vec0_user_column_kind;\n\nstruct vec0_vtab {\n  sqlite3_vtab base;\n\n  // the SQLite connection of the host database\n  sqlite3 *db;\n\n  // True if the primary key of the vec0 table has a column type TEXT.\n  // Will change the schema of the _rowids table, and insert/query logic.\n  int pkIsText;\n\n  // number of defined vector columns.\n  int numVectorColumns;\n\n  // number of defined PARTITION KEY columns.\n  int numPartitionColumns;\n\n  // number of defined auxiliary columns\n  int numAuxiliaryColumns;\n\n  // number of defined metadata columns\n  int numMetadataColumns;\n\n\n  // Name of the schema the table exists on.\n  // Must be freed with sqlite3_free()\n  char *schemaName;\n\n  // Name of the table the table exists on.\n  // Must be freed with sqlite3_free()\n  char *tableName;\n\n  // Name of the _rowids shadow table.\n  // Must be freed with sqlite3_free()\n  char *shadowRowidsName;\n\n  // Name of the _chunks shadow table.\n  // Must be freed with sqlite3_free()\n  char *shadowChunksName;\n\n  // contains enum vec0_user_column_kind values for up to\n  // numVectorColumns + numPartitionColumns entries\n  vec0_user_column_kind user_column_kinds[VEC0_MAX_VECTOR_COLUMNS + VEC0_MAX_PARTITION_COLUMNS + VEC0_MAX_AUXILIARY_COLUMNS + VEC0_MAX_METADATA_COLUMNS];\n\n  uint8_t user_column_idxs[VEC0_MAX_VECTOR_COLUMNS + VEC0_MAX_PARTITION_COLUMNS + VEC0_MAX_AUXILIARY_COLUMNS + VEC0_MAX_METADATA_COLUMNS];\n\n\n  // Name of all the vector chunk shadow tables.\n  // Ex '_vector_chunks00'\n  // Only the first numVectorColumns entries will be available.\n  // The first numVectorColumns entries must be freed with sqlite3_free()\n  char *shadowVectorChunksNames[VEC0_MAX_VECTOR_COLUMNS];\n\n  // Name of all metadata chunk shadow tables, ie `_metadatachunks00`\n  // Only the first numMetadataColumns entries will be available.\n  // The first numMetadataColumns entries must be freed with sqlite3_free()\n  char *shadowMetadataChunksNames[VEC0_MAX_METADATA_COLUMNS];\n\n  struct VectorColumnDefinition vector_columns[VEC0_MAX_VECTOR_COLUMNS];\n  struct Vec0PartitionColumnDefinition paritition_columns[VEC0_MAX_PARTITION_COLUMNS];\n  struct Vec0AuxiliaryColumnDefinition auxiliary_columns[VEC0_MAX_AUXILIARY_COLUMNS];\n  struct Vec0MetadataColumnDefinition metadata_columns[VEC0_MAX_METADATA_COLUMNS];\n\n  int chunk_size;\n\n  // select latest chunk from _chunks, getting chunk_id\n  sqlite3_stmt *stmtLatestChunk;\n\n  /**\n   * Statement to insert a row into the _rowids table, with a rowid.\n   * Parameters:\n   *    1: int64, rowid to insert\n   * Result columns: none\n   * SQL: \"INSERT INTO _rowids(rowid) VALUES (?)\"\n   *\n   * Must be cleaned up with sqlite3_finalize().\n   */\n  sqlite3_stmt *stmtRowidsInsertRowid;\n\n  /**\n   * Statement to insert a row into the _rowids table, with an id.\n   * The id column isn't a tradition primary key, but instead a unique\n   * column to handle \"text primary key\" vec0 tables. The true int64 rowid\n   * can be retrieved after inserting with sqlite3_last_rowid().\n   *\n   * Parameters:\n   *    1: text or null, id to insert\n   * Result columns: none\n   *\n   * Must be cleaned up with sqlite3_finalize().\n   */\n  sqlite3_stmt *stmtRowidsInsertId;\n\n  /**\n   * Statement to update the \"position\" columns chunk_id and chunk_offset for\n   * a given _rowids row. Used when the \"next available\" chunk position is found\n   * for a vector.\n   *\n   * Parameters:\n   *    1: int64, chunk_id value\n   *    2: int64, chunk_offset value\n   *    3: int64, rowid value\n   * Result columns: none\n   *\n   * Must be cleaned up with sqlite3_finalize().\n   */\n  sqlite3_stmt *stmtRowidsUpdatePosition;\n\n  /**\n   * Statement to quickly find the chunk_id + chunk_offset of a given row.\n   * Parameters:\n   *  1: rowid of the row/vector to lookup\n   * Result columns:\n   *  0: chunk_id (i64)\n   *  1: chunk_offset (i64)\n   * SQL: \"SELECT id, chunk_id, chunk_offset FROM _rowids WHERE rowid = ?\"\"\n   *\n   * Must be cleaned up with sqlite3_finalize().\n   */\n  sqlite3_stmt *stmtRowidsGetChunkPosition;\n};\n\n/**\n * @brief Finalize all the sqlite3_stmt members in a vec0_vtab.\n *\n * @param p vec0_vtab pointer\n */\nvoid vec0_free_resources(vec0_vtab *p) {\n  sqlite3_finalize(p->stmtLatestChunk);\n  p->stmtLatestChunk = NULL;\n  sqlite3_finalize(p->stmtRowidsInsertRowid);\n  p->stmtRowidsInsertRowid = NULL;\n  sqlite3_finalize(p->stmtRowidsInsertId);\n  p->stmtRowidsInsertId = NULL;\n  sqlite3_finalize(p->stmtRowidsUpdatePosition);\n  p->stmtRowidsUpdatePosition = NULL;\n  sqlite3_finalize(p->stmtRowidsGetChunkPosition);\n  p->stmtRowidsGetChunkPosition = NULL;\n}\n\n/**\n * @brief Free all memory and sqlite3_stmt members of a vec0_vtab\n *\n * @param p vec0_vtab pointer\n */\nvoid vec0_free(vec0_vtab *p) {\n  vec0_free_resources(p);\n\n  sqlite3_free(p->schemaName);\n  p->schemaName = NULL;\n  sqlite3_free(p->tableName);\n  p->tableName = NULL;\n  sqlite3_free(p->shadowChunksName);\n  p->shadowChunksName = NULL;\n  sqlite3_free(p->shadowRowidsName);\n  p->shadowRowidsName = NULL;\n\n  for (int i = 0; i < p->numVectorColumns; i++) {\n    sqlite3_free(p->shadowVectorChunksNames[i]);\n    p->shadowVectorChunksNames[i] = NULL;\n\n    sqlite3_free(p->vector_columns[i].name);\n    p->vector_columns[i].name = NULL;\n  }\n}\n\nint vec0_num_defined_user_columns(vec0_vtab *p) {\n  return p->numVectorColumns + p->numPartitionColumns + p->numAuxiliaryColumns + p->numMetadataColumns;\n}\n\n/**\n * @brief Returns the index of the distance hidden column for the given vec0\n * table.\n *\n * @param p vec0 table\n * @return int\n */\nint vec0_column_distance_idx(vec0_vtab *p) {\n  return VEC0_COLUMN_USERN_START + (vec0_num_defined_user_columns(p) - 1) +\n         VEC0_COLUMN_OFFSET_DISTANCE;\n}\n\n/**\n * @brief Returns the index of the k hidden column for the given vec0 table.\n *\n * @param p vec0 table\n * @return int k column index\n */\nint vec0_column_k_idx(vec0_vtab *p) {\n  return VEC0_COLUMN_USERN_START + (vec0_num_defined_user_columns(p) - 1) +\n         VEC0_COLUMN_OFFSET_K;\n}\n\n/**\n * Returns 1 if the given column-based index is a valid vector column,\n * 0 otherwise.\n */\nint vec0_column_idx_is_vector(vec0_vtab *pVtab, int column_idx) {\n  return column_idx >= VEC0_COLUMN_USERN_START &&\n         column_idx <= (VEC0_COLUMN_USERN_START + vec0_num_defined_user_columns(pVtab) - 1) &&\n         pVtab->user_column_kinds[column_idx - VEC0_COLUMN_USERN_START] == SQLITE_VEC0_USER_COLUMN_KIND_VECTOR;\n}\n\n/**\n * Returns the vector index of the given user column index.\n * ONLY call if validated with vec0_column_idx_is_vector before\n */\nint vec0_column_idx_to_vector_idx(vec0_vtab *pVtab, int column_idx) {\n  UNUSED_PARAMETER(pVtab);\n  return pVtab->user_column_idxs[column_idx - VEC0_COLUMN_USERN_START];\n}\n/**\n * Returns 1 if the given column-based index is a \"partition key\" column,\n * 0 otherwise.\n */\nint vec0_column_idx_is_partition(vec0_vtab *pVtab, int column_idx) {\n  return column_idx >= VEC0_COLUMN_USERN_START &&\n         column_idx <= (VEC0_COLUMN_USERN_START + vec0_num_defined_user_columns(pVtab) - 1) &&\n         pVtab->user_column_kinds[column_idx - VEC0_COLUMN_USERN_START] == SQLITE_VEC0_USER_COLUMN_KIND_PARTITION;\n}\n\n/**\n * Returns the partition column index of the given user column index.\n * ONLY call if validated with vec0_column_idx_is_vector before\n */\nint vec0_column_idx_to_partition_idx(vec0_vtab *pVtab, int column_idx) {\n  UNUSED_PARAMETER(pVtab);\n  return pVtab->user_column_idxs[column_idx - VEC0_COLUMN_USERN_START];\n}\n\n/**\n * Returns 1 if the given column-based index is a auxiliary column,\n * 0 otherwise.\n */\nint vec0_column_idx_is_auxiliary(vec0_vtab *pVtab, int column_idx) {\n  return column_idx >= VEC0_COLUMN_USERN_START &&\n         column_idx <= (VEC0_COLUMN_USERN_START + vec0_num_defined_user_columns(pVtab) - 1) &&\n         pVtab->user_column_kinds[column_idx - VEC0_COLUMN_USERN_START] == SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY;\n}\n\n/**\n * Returns the auxiliary column index of the given user column index.\n * ONLY call if validated with vec0_column_idx_to_partition_idx before\n */\nint vec0_column_idx_to_auxiliary_idx(vec0_vtab *pVtab, int column_idx) {\n  UNUSED_PARAMETER(pVtab);\n  return pVtab->user_column_idxs[column_idx - VEC0_COLUMN_USERN_START];\n}\n\n/**\n * Returns 1 if the given column-based index is a metadata column,\n * 0 otherwise.\n */\nint vec0_column_idx_is_metadata(vec0_vtab *pVtab, int column_idx) {\n  return column_idx >= VEC0_COLUMN_USERN_START &&\n         column_idx <= (VEC0_COLUMN_USERN_START + vec0_num_defined_user_columns(pVtab) - 1) &&\n         pVtab->user_column_kinds[column_idx - VEC0_COLUMN_USERN_START] == SQLITE_VEC0_USER_COLUMN_KIND_METADATA;\n}\n\n/**\n * Returns the metadata column index of the given user column index.\n * ONLY call if validated with vec0_column_idx_is_metadata before\n */\nint vec0_column_idx_to_metadata_idx(vec0_vtab *pVtab, int column_idx) {\n  UNUSED_PARAMETER(pVtab);\n  return pVtab->user_column_idxs[column_idx - VEC0_COLUMN_USERN_START];\n}\n\n/**\n * @brief Retrieve the chunk_id, chunk_offset, and possible \"id\" value\n * of a vec0_vtab row with the provided rowid\n *\n * @param p vec0_vtab\n * @param rowid the rowid of the row to query\n * @param id output, optional sqlite3_value to provide the id.\n *            Useful for text PK rows. Must be freed with sqlite3_value_free()\n * @param chunk_id output, the chunk_id the row belongs to\n * @param chunk_offset  output, the offset within the chunk the row belongs to\n * @return SQLITE_ROW on success, error code otherwise. SQLITE_EMPTY if row DNE\n */\nint vec0_get_chunk_position(vec0_vtab *p, i64 rowid, sqlite3_value **id,\n                            i64 *chunk_id, i64 *chunk_offset) {\n  int rc;\n\n  if (!p->stmtRowidsGetChunkPosition) {\n    const char *zSql =\n        sqlite3_mprintf(\"SELECT id, chunk_id, chunk_offset \"\n                        \"FROM \" VEC0_SHADOW_ROWIDS_NAME \" WHERE rowid = ?\",\n                        p->schemaName, p->tableName);\n    if (!zSql) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &p->stmtRowidsGetChunkPosition, 0);\n    sqlite3_free((void *)zSql);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(\n          &p->base, VEC_INTERAL_ERROR\n          \"could not initialize 'rowids get chunk position' statement\");\n      goto cleanup;\n    }\n  }\n\n  sqlite3_bind_int64(p->stmtRowidsGetChunkPosition, 1, rowid);\n  rc = sqlite3_step(p->stmtRowidsGetChunkPosition);\n  // special case: when no results, return SQLITE_EMPTY to convey \"that chunk\n  // position doesnt exist\"\n  if (rc == SQLITE_DONE) {\n    rc = SQLITE_EMPTY;\n    goto cleanup;\n  }\n  if (rc != SQLITE_ROW) {\n    goto cleanup;\n  }\n\n  if (id) {\n    sqlite3_value *value =\n        sqlite3_column_value(p->stmtRowidsGetChunkPosition, 0);\n    *id = sqlite3_value_dup(value);\n    if (!*id) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n  }\n\n  if (chunk_id) {\n    *chunk_id = sqlite3_column_int64(p->stmtRowidsGetChunkPosition, 1);\n  }\n  if (chunk_offset) {\n    *chunk_offset = sqlite3_column_int64(p->stmtRowidsGetChunkPosition, 2);\n  }\n\n  rc = SQLITE_OK;\n\ncleanup:\n  sqlite3_reset(p->stmtRowidsGetChunkPosition);\n  sqlite3_clear_bindings(p->stmtRowidsGetChunkPosition);\n  return rc;\n}\n\n/**\n * @brief Return the id value from the _rowids table where _rowids.rowid =\n * rowid.\n *\n * @param pVtab: vec0 table to query\n * @param rowid: rowid of the row to query.\n * @param out: A dup'ed sqlite3_value of the id column. Might be null.\n *                         Must be cleaned up with sqlite3_value_free().\n * @returns SQLITE_OK on success, error code on failure\n */\nint vec0_get_id_value_from_rowid(vec0_vtab *pVtab, i64 rowid,\n                                 sqlite3_value **out) {\n  // PERF: different strategy than get_chunk_position?\n  return vec0_get_chunk_position((vec0_vtab *)pVtab, rowid, out, NULL, NULL);\n}\n\nint vec0_rowid_from_id(vec0_vtab *p, sqlite3_value *valueId, i64 *rowid) {\n  sqlite3_stmt *stmt = NULL;\n  int rc;\n  char *zSql;\n  zSql = sqlite3_mprintf(\"SELECT rowid\"\n                         \" FROM \" VEC0_SHADOW_ROWIDS_NAME \" WHERE id = ?\",\n                         p->schemaName, p->tableName);\n  if (!zSql) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n  sqlite3_bind_value(stmt, 1, valueId);\n  rc = sqlite3_step(stmt);\n  if (rc == SQLITE_DONE) {\n    rc = SQLITE_EMPTY;\n    goto cleanup;\n  }\n  if (rc != SQLITE_ROW) {\n    goto cleanup;\n  }\n  *rowid = sqlite3_column_int64(stmt, 0);\n  rc = sqlite3_step(stmt);\n  if (rc != SQLITE_DONE) {\n    goto cleanup;\n  }\n\n  rc = SQLITE_OK;\n\ncleanup:\n  sqlite3_finalize(stmt);\n  return rc;\n}\n\nint vec0_result_id(vec0_vtab *p, sqlite3_context *context, i64 rowid) {\n  if (!p->pkIsText) {\n    sqlite3_result_int64(context, rowid);\n    return SQLITE_OK;\n  }\n  sqlite3_value *valueId;\n  int rc = vec0_get_id_value_from_rowid(p, rowid, &valueId);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n  if (!valueId) {\n    sqlite3_result_error_nomem(context);\n  } else {\n    sqlite3_result_value(context, valueId);\n    sqlite3_value_free(valueId);\n  }\n  return SQLITE_OK;\n}\n\n/**\n * @brief\n *\n * @param pVtab: virtual table to query\n * @param rowid: row to lookup\n * @param vector_column_idx: which vector column to query\n * @param outVector: Output pointer to the vector buffer.\n *                    Must be sqlite3_free()'ed.\n * @param outVectorSize: Pointer to a int where the size of outVector\n *                       will be stored.\n * @return int SQLITE_OK on success.\n */\nint vec0_get_vector_data(vec0_vtab *pVtab, i64 rowid, int vector_column_idx,\n                         void **outVector, int *outVectorSize) {\n  vec0_vtab *p = pVtab;\n  int rc, brc;\n  i64 chunk_id;\n  i64 chunk_offset;\n  size_t size;\n  void *buf = NULL;\n  int blobOffset;\n  sqlite3_blob *vectorBlob = NULL;\n  assert((vector_column_idx >= 0) &&\n         (vector_column_idx < pVtab->numVectorColumns));\n\n  rc = vec0_get_chunk_position(pVtab, rowid, NULL, &chunk_id, &chunk_offset);\n  if (rc == SQLITE_EMPTY) {\n    vtab_set_error(&pVtab->base, \"Could not find a row with rowid %lld\", rowid);\n    goto cleanup;\n  }\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  rc = sqlite3_blob_open(p->db, p->schemaName,\n                         p->shadowVectorChunksNames[vector_column_idx],\n                         \"vectors\", chunk_id, 0, &vectorBlob);\n\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&pVtab->base,\n                   \"Could not fetch vector data for %lld, opening blob failed\",\n                   rowid);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  size = vector_column_byte_size(pVtab->vector_columns[vector_column_idx]);\n  blobOffset = chunk_offset * size;\n\n  buf = sqlite3_malloc(size);\n  if (!buf) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  rc = sqlite3_blob_read(vectorBlob, buf, size, blobOffset);\n  if (rc != SQLITE_OK) {\n    sqlite3_free(buf);\n    buf = NULL;\n    vtab_set_error(\n        &pVtab->base,\n        \"Could not fetch vector data for %lld, reading from blob failed\",\n        rowid);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  *outVector = buf;\n  if (outVectorSize) {\n    *outVectorSize = size;\n  }\n  rc = SQLITE_OK;\n\ncleanup:\n  brc = sqlite3_blob_close(vectorBlob);\n  if ((rc == SQLITE_OK) && (brc != SQLITE_OK)) {\n    vtab_set_error(\n        &p->base, VEC_INTERAL_ERROR\n        \"unknown error, could not close vector blob, please file an issue\");\n    return brc;\n  }\n\n  return rc;\n}\n\n/**\n * @brief Retrieve the sqlite3_value of the i'th partition value for the given row.\n *\n * @param pVtab - the vec0_vtab in questions\n * @param rowid - rowid of target row\n * @param partition_idx - which partition column to retrieve\n * @param outValue - output sqlite3_value\n * @return int - SQLITE_OK on success, otherwise error code\n */\nint vec0_get_partition_value_for_rowid(vec0_vtab *pVtab, i64 rowid, int partition_idx, sqlite3_value ** outValue) {\n  int rc;\n  i64 chunk_id;\n  i64 chunk_offset;\n  rc = vec0_get_chunk_position(pVtab, rowid, NULL, &chunk_id, &chunk_offset);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  sqlite3_stmt * stmt = NULL;\n  char * zSql = sqlite3_mprintf(\"SELECT partition%02d FROM \" VEC0_SHADOW_CHUNKS_NAME \" WHERE chunk_id = ?\", partition_idx, pVtab->schemaName, pVtab->tableName);\n  if(!zSql) {\n    return SQLITE_NOMEM;\n  }\n  rc = sqlite3_prepare_v2(pVtab->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  sqlite3_bind_int64(stmt, 1, chunk_id);\n  rc = sqlite3_step(stmt);\n  if(rc != SQLITE_ROW) {\n    rc = SQLITE_ERROR;\n    goto done;\n  }\n  *outValue = sqlite3_value_dup(sqlite3_column_value(stmt, 0));\n  if(!*outValue) {\n    rc = SQLITE_NOMEM;\n    goto done;\n  }\n  rc = SQLITE_OK;\n\n  done:\n    sqlite3_finalize(stmt);\n    return rc;\n\n}\n\n/**\n * @brief Get the value of an auxiliary column for the given rowid\n *\n * @param pVtab vec0_vtab\n * @param rowid the rowid of the row to lookup\n * @param auxiliary_idx aux index of the column we care about\n * @param outValue Output sqlite3_value to store\n * @return int SQLITE_OK on success, error code otherwise\n */\nint vec0_get_auxiliary_value_for_rowid(vec0_vtab *pVtab, i64 rowid, int auxiliary_idx, sqlite3_value ** outValue) {\n  int rc;\n  sqlite3_stmt * stmt = NULL;\n  char * zSql = sqlite3_mprintf(\"SELECT value%02d FROM \" VEC0_SHADOW_AUXILIARY_NAME \" WHERE rowid = ?\", auxiliary_idx, pVtab->schemaName, pVtab->tableName);\n  if(!zSql) {\n    return SQLITE_NOMEM;\n  }\n  rc = sqlite3_prepare_v2(pVtab->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  sqlite3_bind_int64(stmt, 1, rowid);\n  rc = sqlite3_step(stmt);\n  if(rc != SQLITE_ROW) {\n    rc = SQLITE_ERROR;\n    goto done;\n  }\n  *outValue = sqlite3_value_dup(sqlite3_column_value(stmt, 0));\n  if(!*outValue) {\n    rc = SQLITE_NOMEM;\n    goto done;\n  }\n  rc = SQLITE_OK;\n\n  done:\n    sqlite3_finalize(stmt);\n    return rc;\n}\n\n/**\n * @brief Result the given metadata value for the given row and metadata column index.\n * Will traverse the metadatachunksNN table with BLOB I/0 for the given rowid.\n *\n * @param p\n * @param rowid\n * @param metadata_idx\n * @param context\n * @return int\n */\nint vec0_result_metadata_value_for_rowid(vec0_vtab *p, i64 rowid, int metadata_idx, sqlite3_context * context) {\n  int rc;\n  i64 chunk_id;\n  i64 chunk_offset;\n  rc = vec0_get_chunk_position(p, rowid, NULL, &chunk_id, &chunk_offset);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  sqlite3_blob * blobValue;\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowMetadataChunksNames[metadata_idx], \"data\", chunk_id, 0, &blobValue);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n\n  switch(p->metadata_columns[metadata_idx].kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      u8 block;\n      rc = sqlite3_blob_read(blobValue, &block, sizeof(block), chunk_offset / CHAR_BIT);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n      int value = block >> ((chunk_offset % CHAR_BIT)) & 1;\n      sqlite3_result_int(context, value);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      i64 value;\n      rc = sqlite3_blob_read(blobValue, &value, sizeof(value), chunk_offset * sizeof(i64));\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n      sqlite3_result_int64(context, value);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      double value;\n      rc = sqlite3_blob_read(blobValue, &value, sizeof(value), chunk_offset * sizeof(double));\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n      sqlite3_result_double(context, value);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      u8 view[VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n      rc = sqlite3_blob_read(blobValue, &view, VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH, chunk_offset * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n      int length = ((int *)view)[0];\n      if(length <= VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n        sqlite3_result_text(context, (const char*) (view + 4), length, SQLITE_TRANSIENT);\n      }\n      else {\n        sqlite3_stmt * stmt;\n        const char * zSql = sqlite3_mprintf(\"SELECT data FROM \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" WHERE rowid = ?\", p->schemaName, p->tableName, metadata_idx);\n        if(!zSql) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n        sqlite3_free((void *) zSql);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        sqlite3_bind_int64(stmt, 1, rowid);\n        rc = sqlite3_step(stmt);\n        if(rc != SQLITE_ROW) {\n          sqlite3_finalize(stmt);\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        sqlite3_result_value(context, sqlite3_column_value(stmt, 0));\n        sqlite3_finalize(stmt);\n        rc = SQLITE_OK;\n      }\n      break;\n    }\n  }\n  done:\n    // blobValue is read-only, will not fail on close\n    sqlite3_blob_close(blobValue);\n    return rc;\n\n}\n\nint vec0_get_latest_chunk_rowid(vec0_vtab *p, i64 *chunk_rowid, sqlite3_value ** partitionKeyValues) {\n  int rc;\n  const char *zSql;\n  // lazy initialize stmtLatestChunk when needed. May be cleared during xSync()\n  if (!p->stmtLatestChunk) {\n    if(p->numPartitionColumns > 0) {\n      sqlite3_str * s = sqlite3_str_new(NULL);\n      sqlite3_str_appendf(s, \"SELECT max(rowid) FROM \" VEC0_SHADOW_CHUNKS_NAME \" WHERE \",\n                           p->schemaName, p->tableName);\n\n      for(int i = 0; i < p->numPartitionColumns; i++) {\n        if(i != 0) {\n          sqlite3_str_appendall(s, \" AND \");\n        }\n        sqlite3_str_appendf(s, \" partition%02d = ? \", i);\n      }\n      zSql = sqlite3_str_finish(s);\n    }else {\n      zSql = sqlite3_mprintf(\"SELECT max(rowid) FROM \" VEC0_SHADOW_CHUNKS_NAME,\n                           p->schemaName, p->tableName);\n    }\n\n    if (!zSql) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &p->stmtLatestChunk, 0);\n    sqlite3_free((void *)zSql);\n    if (rc != SQLITE_OK) {\n      // IMP: V21406_05476\n      vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                     \"could not initialize 'latest chunk' statement\");\n      goto cleanup;\n    }\n  }\n\n  for(int i = 0; i < p->numPartitionColumns; i++) {\n    sqlite3_bind_value(p->stmtLatestChunk, i+1, (partitionKeyValues[i]));\n  }\n\n  rc = sqlite3_step(p->stmtLatestChunk);\n  if (rc != SQLITE_ROW) {\n    // IMP: V31559_15629\n    vtab_set_error(&p->base, VEC_INTERAL_ERROR \"Could not find latest chunk\");\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  if(sqlite3_column_type(p->stmtLatestChunk, 0) == SQLITE_NULL){\n    rc = SQLITE_EMPTY;\n    goto cleanup;\n  }\n  *chunk_rowid = sqlite3_column_int64(p->stmtLatestChunk, 0);\n  rc = sqlite3_step(p->stmtLatestChunk);\n  if (rc != SQLITE_DONE) {\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR\n                   \"unknown result code when closing out stmtLatestChunk. \"\n                   \"Please file an issue: \" REPORT_URL,\n                   p->schemaName, p->shadowChunksName);\n    goto cleanup;\n  }\n  rc = SQLITE_OK;\n\ncleanup:\n  if (p->stmtLatestChunk) {\n    sqlite3_reset(p->stmtLatestChunk);\n    sqlite3_clear_bindings(p->stmtLatestChunk);\n  }\n  return rc;\n}\n\nint vec0_rowids_insert_rowid(vec0_vtab *p, i64 rowid) {\n  int rc = SQLITE_OK;\n  int entered = 0;\n  UNUSED_PARAMETER(entered); // temporary\n  if (!p->stmtRowidsInsertRowid) {\n    const char *zSql =\n        sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_ROWIDS_NAME \"(rowid)\"\n                        \"VALUES (?);\",\n                        p->schemaName, p->tableName);\n    if (!zSql) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &p->stmtRowidsInsertRowid, 0);\n    sqlite3_free((void *)zSql);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                     \"could not initialize 'insert rowids' statement\");\n      goto cleanup;\n    }\n  }\n\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_enter) {\n    sqlite3_mutex_enter(sqlite3_db_mutex(p->db));\n    entered = 1;\n  }\n#endif\n  sqlite3_bind_int64(p->stmtRowidsInsertRowid, 1, rowid);\n  rc = sqlite3_step(p->stmtRowidsInsertRowid);\n\n  if (rc != SQLITE_DONE) {\n    if (sqlite3_extended_errcode(p->db) == SQLITE_CONSTRAINT_PRIMARYKEY) {\n      // IMP: V17090_01160\n      vtab_set_error(&p->base, \"UNIQUE constraint failed on %s primary key\",\n                     p->tableName);\n    } else {\n      // IMP: V04679_21517\n      vtab_set_error(&p->base,\n                     \"Error inserting rowid into rowids shadow table: %s\",\n                     sqlite3_errmsg(sqlite3_db_handle(p->stmtRowidsInsertId)));\n    }\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  rc = SQLITE_OK;\n\ncleanup:\n  if (p->stmtRowidsInsertRowid) {\n    sqlite3_reset(p->stmtRowidsInsertRowid);\n    sqlite3_clear_bindings(p->stmtRowidsInsertRowid);\n  }\n\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_leave && entered) {\n    sqlite3_mutex_leave(sqlite3_db_mutex(p->db));\n  }\n#endif\n  return rc;\n}\n\nint vec0_rowids_insert_id(vec0_vtab *p, sqlite3_value *idValue, i64 *rowid) {\n  int rc = SQLITE_OK;\n  int entered = 0;\n  UNUSED_PARAMETER(entered); // temporary\n  if (!p->stmtRowidsInsertId) {\n    const char *zSql =\n        sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_ROWIDS_NAME \"(id)\"\n                        \"VALUES (?);\",\n                        p->schemaName, p->tableName);\n    if (!zSql) {\n      rc = SQLITE_NOMEM;\n      goto complete;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &p->stmtRowidsInsertId, 0);\n    sqlite3_free((void *)zSql);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                     \"could not initialize 'insert rowids id' statement\");\n      goto complete;\n    }\n  }\n\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_enter) {\n    sqlite3_mutex_enter(sqlite3_db_mutex(p->db));\n    entered = 1;\n  }\n#endif\n\n  if (idValue) {\n    sqlite3_bind_value(p->stmtRowidsInsertId, 1, idValue);\n  }\n  rc = sqlite3_step(p->stmtRowidsInsertId);\n\n  if (rc != SQLITE_DONE) {\n    if (sqlite3_extended_errcode(p->db) == SQLITE_CONSTRAINT_UNIQUE) {\n      // IMP: V20497_04568\n      vtab_set_error(&p->base, \"UNIQUE constraint failed on %s primary key\",\n                     p->tableName);\n    } else {\n      // IMP: V24016_08086\n      // IMP: V15177_32015\n      vtab_set_error(&p->base,\n                     \"Error inserting id into rowids shadow table: %s\",\n                     sqlite3_errmsg(sqlite3_db_handle(p->stmtRowidsInsertId)));\n    }\n    rc = SQLITE_ERROR;\n    goto complete;\n  }\n\n  *rowid = sqlite3_last_insert_rowid(p->db);\n  rc = SQLITE_OK;\n\ncomplete:\n  if (p->stmtRowidsInsertId) {\n    sqlite3_reset(p->stmtRowidsInsertId);\n    sqlite3_clear_bindings(p->stmtRowidsInsertId);\n  }\n\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_leave && entered) {\n    sqlite3_mutex_leave(sqlite3_db_mutex(p->db));\n  }\n#endif\n  return rc;\n}\n\nint vec0_metadata_chunk_size(vec0_metadata_column_kind kind, int chunk_size) {\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN:\n      return chunk_size / 8;\n    case VEC0_METADATA_COLUMN_KIND_INTEGER:\n      return chunk_size * sizeof(i64);\n    case VEC0_METADATA_COLUMN_KIND_FLOAT:\n      return chunk_size * sizeof(double);\n    case VEC0_METADATA_COLUMN_KIND_TEXT:\n      return chunk_size * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH;\n  }\n  return 0;\n}\n\nint vec0_rowids_update_position(vec0_vtab *p, i64 rowid, i64 chunk_rowid,\n                                i64 chunk_offset) {\n  int rc = SQLITE_OK;\n\n  if (!p->stmtRowidsUpdatePosition) {\n    const char *zSql = sqlite3_mprintf(\" UPDATE \" VEC0_SHADOW_ROWIDS_NAME\n                                       \" SET chunk_id = ?, chunk_offset = ?\"\n                                       \" WHERE rowid = ?\",\n                                       p->schemaName, p->tableName);\n    if (!zSql) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &p->stmtRowidsUpdatePosition, 0);\n    sqlite3_free((void *)zSql);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                     \"could not initialize 'update rowids position' statement\");\n      goto cleanup;\n    }\n  }\n\n  sqlite3_bind_int64(p->stmtRowidsUpdatePosition, 1, chunk_rowid);\n  sqlite3_bind_int64(p->stmtRowidsUpdatePosition, 2, chunk_offset);\n  sqlite3_bind_int64(p->stmtRowidsUpdatePosition, 3, rowid);\n\n  rc = sqlite3_step(p->stmtRowidsUpdatePosition);\n  if (rc != SQLITE_DONE) {\n    // IMP: V21925_05995\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR\n                   \"could not update rowids position for rowid=%lld, \"\n                   \"chunk_rowid=%lld, chunk_offset=%lld\",\n                   rowid, chunk_rowid, chunk_offset);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  rc = SQLITE_OK;\n\ncleanup:\n  if (p->stmtRowidsUpdatePosition) {\n    sqlite3_reset(p->stmtRowidsUpdatePosition);\n    sqlite3_clear_bindings(p->stmtRowidsUpdatePosition);\n  }\n\n  return rc;\n}\n\n/**\n * @brief Adds a new chunk for the vec0 table, and the corresponding vector\n * chunks.\n *\n * Inserts a new row into the _chunks table, with blank data, and uses that new\n * rowid to insert new blank rows into _vector_chunksXX tables.\n *\n * @param p: vec0 table to add new chunk\n * @param paritionKeyValues: Array of partition key valeus for the new chunk, if available\n * @param chunk_rowid: Output pointer, if not NULL, then will be filled with the\n * new chunk rowid.\n * @return int SQLITE_OK on success, error code otherwise.\n */\nint vec0_new_chunk(vec0_vtab *p, sqlite3_value ** partitionKeyValues, i64 *chunk_rowid) {\n  int rc;\n  char *zSql;\n  sqlite3_stmt *stmt;\n  i64 rowid;\n\n  // Step 1: Insert a new row in _chunks, capture that new rowid\n  if(p->numPartitionColumns > 0) {\n    sqlite3_str * s = sqlite3_str_new(NULL);\n    sqlite3_str_appendf(s, \"INSERT INTO \" VEC0_SHADOW_CHUNKS_NAME, p->schemaName, p->tableName);\n    sqlite3_str_appendall(s, \"(size, validity, rowids\");\n    for(int i = 0; i < p->numPartitionColumns; i++) {\n      sqlite3_str_appendf(s, \", partition%02d\", i);\n    }\n    sqlite3_str_appendall(s, \") VALUES (?, ?, ?\");\n    for(int i = 0; i < p->numPartitionColumns; i++) {\n      sqlite3_str_appendall(s, \", ?\");\n    }\n    sqlite3_str_appendall(s, \")\");\n\n    zSql = sqlite3_str_finish(s);\n  }else {\n    zSql = sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_CHUNKS_NAME\n                         \"(size, validity, rowids) \"\n                         \"VALUES (?, ?, ?);\",\n                         p->schemaName, p->tableName);\n  }\n\n  if (!zSql) {\n    return SQLITE_NOMEM;\n  }\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if (rc != SQLITE_OK) {\n    sqlite3_finalize(stmt);\n    return rc;\n  }\n\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_enter) {\n    sqlite3_mutex_enter(sqlite3_db_mutex(p->db));\n  }\n#endif\n\n  sqlite3_bind_int64(stmt, 1, p->chunk_size);               // size\n  sqlite3_bind_zeroblob(stmt, 2, p->chunk_size / CHAR_BIT); // validity bitmap\n  sqlite3_bind_zeroblob(stmt, 3, p->chunk_size * sizeof(i64)); // rowids\n\n  for(int i = 0; i < p->numPartitionColumns; i++) {\n    sqlite3_bind_value(stmt, 4 + i, partitionKeyValues[i]);\n  }\n\n  rc = sqlite3_step(stmt);\n  int failed = rc != SQLITE_DONE;\n  rowid = sqlite3_last_insert_rowid(p->db);\n#if SQLITE_THREADSAFE\n  if (sqlite3_mutex_leave) {\n    sqlite3_mutex_leave(sqlite3_db_mutex(p->db));\n  }\n#endif\n  sqlite3_finalize(stmt);\n  if (failed) {\n    return SQLITE_ERROR;\n  }\n\n  // Step 2: Create new vector chunks for each vector column, with\n  //          that new chunk_rowid.\n\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_VECTOR) {\n      continue;\n    }\n    int vector_column_idx = p->user_column_idxs[i];\n    i64 vectorsSize =\n        p->chunk_size * vector_column_byte_size(p->vector_columns[vector_column_idx]);\n\n    zSql = sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_VECTOR_N_NAME\n                           \"(rowid, vectors)\"\n                           \"VALUES (?, ?)\",\n                           p->schemaName, p->tableName, vector_column_idx);\n    if (!zSql) {\n      return SQLITE_NOMEM;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n    sqlite3_free(zSql);\n\n    if (rc != SQLITE_OK) {\n      sqlite3_finalize(stmt);\n      return rc;\n    }\n\n    sqlite3_bind_int64(stmt, 1, rowid);\n    sqlite3_bind_zeroblob64(stmt, 2, vectorsSize);\n\n    rc = sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n    if (rc != SQLITE_DONE) {\n      return rc;\n    }\n  }\n\n  // Step 3: Create new metadata chunks for each metadata column\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_METADATA) {\n      continue;\n    }\n    int metadata_column_idx = p->user_column_idxs[i];\n    zSql = sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_METADATA_N_NAME\n                           \"(rowid, data)\"\n                           \"VALUES (?, ?)\",\n                           p->schemaName, p->tableName, metadata_column_idx);\n    if (!zSql) {\n      return SQLITE_NOMEM;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n    sqlite3_free(zSql);\n\n    if (rc != SQLITE_OK) {\n      sqlite3_finalize(stmt);\n      return rc;\n    }\n\n    sqlite3_bind_int64(stmt, 1, rowid);\n    sqlite3_bind_zeroblob64(stmt, 2, vec0_metadata_chunk_size(p->metadata_columns[metadata_column_idx].kind, p->chunk_size));\n\n    rc = sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n    if (rc != SQLITE_DONE) {\n      return rc;\n    }\n  }\n\n\n  if (chunk_rowid) {\n    *chunk_rowid = rowid;\n  }\n\n  return SQLITE_OK;\n}\n\nstruct vec0_query_fullscan_data {\n  sqlite3_stmt *rowids_stmt;\n  i8 done;\n};\nvoid vec0_query_fullscan_data_clear(\n    struct vec0_query_fullscan_data *fullscan_data) {\n  if (!fullscan_data)\n    return;\n\n  if (fullscan_data->rowids_stmt) {\n    sqlite3_finalize(fullscan_data->rowids_stmt);\n    fullscan_data->rowids_stmt = NULL;\n  }\n}\n\nstruct vec0_query_knn_data {\n  i64 k;\n  i64 k_used;\n  // Array of rowids of size k. Must be freed with sqlite3_free().\n  i64 *rowids;\n  // Array of distances of size k. Must be freed with sqlite3_free().\n  f32 *distances;\n  i64 current_idx;\n};\nvoid vec0_query_knn_data_clear(struct vec0_query_knn_data *knn_data) {\n  if (!knn_data)\n    return;\n\n  if (knn_data->rowids) {\n    sqlite3_free(knn_data->rowids);\n    knn_data->rowids = NULL;\n  }\n  if (knn_data->distances) {\n    sqlite3_free(knn_data->distances);\n    knn_data->distances = NULL;\n  }\n}\n\nstruct vec0_query_point_data {\n  i64 rowid;\n  void *vectors[VEC0_MAX_VECTOR_COLUMNS];\n  int done;\n};\nvoid vec0_query_point_data_clear(struct vec0_query_point_data *point_data) {\n  if (!point_data)\n    return;\n  for (int i = 0; i < VEC0_MAX_VECTOR_COLUMNS; i++) {\n    sqlite3_free(point_data->vectors[i]);\n    point_data->vectors[i] = NULL;\n  }\n}\n\ntypedef enum {\n  // If any values are updated, please update the ARCHITECTURE.md docs accordingly!\n\n VEC0_QUERY_PLAN_FULLSCAN = '1',\n VEC0_QUERY_PLAN_POINT = '2',\n VEC0_QUERY_PLAN_KNN = '3',\n} vec0_query_plan;\n\ntypedef struct vec0_cursor vec0_cursor;\nstruct vec0_cursor {\n  sqlite3_vtab_cursor base;\n\n  vec0_query_plan query_plan;\n  struct vec0_query_fullscan_data *fullscan_data;\n  struct vec0_query_knn_data *knn_data;\n  struct vec0_query_point_data *point_data;\n};\n\nvoid vec0_cursor_clear(vec0_cursor *pCur) {\n  if (pCur->fullscan_data) {\n    vec0_query_fullscan_data_clear(pCur->fullscan_data);\n    sqlite3_free(pCur->fullscan_data);\n    pCur->fullscan_data = NULL;\n  }\n  if (pCur->knn_data) {\n    vec0_query_knn_data_clear(pCur->knn_data);\n    sqlite3_free(pCur->knn_data);\n    pCur->knn_data = NULL;\n  }\n  if (pCur->point_data) {\n    vec0_query_point_data_clear(pCur->point_data);\n    sqlite3_free(pCur->point_data);\n    pCur->point_data = NULL;\n  }\n}\n\n#define VEC_CONSTRUCTOR_ERROR \"vec0 constructor error: \"\nstatic int vec0_init(sqlite3 *db, void *pAux, int argc, const char *const *argv,\n                     sqlite3_vtab **ppVtab, char **pzErr, bool isCreate) {\n  UNUSED_PARAMETER(pAux);\n  vec0_vtab *pNew;\n  int rc;\n  const char *zSql;\n\n  pNew = sqlite3_malloc(sizeof(*pNew));\n  if (pNew == 0)\n    return SQLITE_NOMEM;\n  memset(pNew, 0, sizeof(*pNew));\n\n  // Declared chunk_size=N for entire table.\n  // -1 to use the defualt, otherwise will get re-assigned on `chunk_size=N`\n  // option\n  int chunk_size = -1;\n  int numVectorColumns = 0;\n  int numPartitionColumns = 0;\n  int numAuxiliaryColumns = 0;\n  int numMetadataColumns = 0;\n  int user_column_idx = 0;\n\n  // track if a \"primary key\" column is defined\n  char *pkColumnName = NULL;\n  int pkColumnNameLength;\n  int pkColumnType = SQLITE_INTEGER;\n\n  for (int i = 3; i < argc; i++) {\n    struct VectorColumnDefinition vecColumn;\n    struct Vec0PartitionColumnDefinition partitionColumn;\n    struct Vec0AuxiliaryColumnDefinition auxColumn;\n    struct Vec0MetadataColumnDefinition metadataColumn;\n    char *cName = NULL;\n    int cNameLength;\n    int cType;\n\n    // Scenario #1: Constructor argument is a vector column definition, ie `foo float[1024]`\n    rc = vec0_parse_vector_column(argv[i], strlen(argv[i]), &vecColumn);\n    if (rc == SQLITE_ERROR) {\n      *pzErr = sqlite3_mprintf(\n          VEC_CONSTRUCTOR_ERROR \"could not parse vector column '%s'\", argv[i]);\n      goto error;\n    }\n    if (rc == SQLITE_OK) {\n      if (numVectorColumns >= VEC0_MAX_VECTOR_COLUMNS) {\n        sqlite3_free(vecColumn.name);\n        *pzErr = sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR\n                                 \"Too many provided vector columns, maximum %d\",\n                                 VEC0_MAX_VECTOR_COLUMNS);\n        goto error;\n      }\n\n      if (vecColumn.dimensions > SQLITE_VEC_VEC0_MAX_DIMENSIONS) {\n        sqlite3_free(vecColumn.name);\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR\n            \"Dimension on vector column too large, provided %lld, maximum %lld\",\n            (i64)vecColumn.dimensions, SQLITE_VEC_VEC0_MAX_DIMENSIONS);\n        goto error;\n      }\n      pNew->user_column_kinds[user_column_idx] = SQLITE_VEC0_USER_COLUMN_KIND_VECTOR;\n      pNew->user_column_idxs[user_column_idx] = numVectorColumns;\n      memcpy(&pNew->vector_columns[numVectorColumns], &vecColumn, sizeof(vecColumn));\n      numVectorColumns++;\n      user_column_idx++;\n\n      continue;\n    }\n\n    // Scenario #2: Constructor argument is a partition key column definition, ie `user_id text partition key`\n    rc = vec0_parse_partition_key_definition(argv[i], strlen(argv[i]), &cName,\n                                      &cNameLength, &cType);\n    if (rc == SQLITE_OK) {\n      if (numPartitionColumns >= VEC0_MAX_PARTITION_COLUMNS) {\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR\n            \"More than %d partition key columns were provided\",\n            VEC0_MAX_PARTITION_COLUMNS);\n        goto error;\n      }\n      partitionColumn.type = cType;\n      partitionColumn.name_length = cNameLength;\n      partitionColumn.name = sqlite3_mprintf(\"%.*s\", cNameLength, cName);\n      if(!partitionColumn.name) {\n        rc = SQLITE_NOMEM;\n        goto error;\n      }\n\n      pNew->user_column_kinds[user_column_idx] = SQLITE_VEC0_USER_COLUMN_KIND_PARTITION;\n      pNew->user_column_idxs[user_column_idx] = numPartitionColumns;\n      memcpy(&pNew->paritition_columns[numPartitionColumns], &partitionColumn, sizeof(partitionColumn));\n      numPartitionColumns++;\n      user_column_idx++;\n      continue;\n    }\n\n    // Scenario #3: Constructor argument is a primary key column definition, ie `article_id text primary key`\n    rc = vec0_parse_primary_key_definition(argv[i], strlen(argv[i]), &cName,\n                                      &cNameLength, &cType);\n    if (rc == SQLITE_OK) {\n      if (pkColumnName) {\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR\n            \"More than one primary key definition was provided, vec0 only \"\n            \"suports a single primary key column\",\n            argv[i]);\n        goto error;\n      }\n      pkColumnName = cName;\n      pkColumnNameLength = cNameLength;\n      pkColumnType = cType;\n      continue;\n    }\n\n    // Scenario #4: Constructor argument is a auxiliary column definition, ie `+contents text`\n    rc = vec0_parse_auxiliary_column_definition(argv[i], strlen(argv[i]), &cName,\n                                      &cNameLength, &cType);\n    if(rc == SQLITE_OK) {\n      if (numAuxiliaryColumns >= VEC0_MAX_AUXILIARY_COLUMNS) {\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR\n            \"More than %d auxiliary columns were provided\",\n            VEC0_MAX_AUXILIARY_COLUMNS);\n        goto error;\n      }\n      auxColumn.type = cType;\n      auxColumn.name_length = cNameLength;\n      auxColumn.name = sqlite3_mprintf(\"%.*s\", cNameLength, cName);\n      if(!auxColumn.name) {\n        rc = SQLITE_NOMEM;\n        goto error;\n      }\n\n      pNew->user_column_kinds[user_column_idx] = SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY;\n      pNew->user_column_idxs[user_column_idx] = numAuxiliaryColumns;\n      memcpy(&pNew->auxiliary_columns[numAuxiliaryColumns], &auxColumn, sizeof(auxColumn));\n      numAuxiliaryColumns++;\n      user_column_idx++;\n      continue;\n    }\n\n    vec0_metadata_column_kind kind;\n    rc = vec0_parse_metadata_column_definition(argv[i], strlen(argv[i]), &cName,\n                                      &cNameLength, &kind);\n    if(rc == SQLITE_OK) {\n      if (numMetadataColumns >= VEC0_MAX_METADATA_COLUMNS) {\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR\n            \"More than %d metadata columns were provided\",\n            VEC0_MAX_METADATA_COLUMNS);\n        goto error;\n      }\n      metadataColumn.kind = kind;\n      metadataColumn.name_length = cNameLength;\n      metadataColumn.name = sqlite3_mprintf(\"%.*s\", cNameLength, cName);\n      if(!metadataColumn.name) {\n        rc = SQLITE_NOMEM;\n        goto error;\n      }\n\n      pNew->user_column_kinds[user_column_idx] = SQLITE_VEC0_USER_COLUMN_KIND_METADATA;\n      pNew->user_column_idxs[user_column_idx] = numMetadataColumns;\n      memcpy(&pNew->metadata_columns[numMetadataColumns], &metadataColumn, sizeof(metadataColumn));\n      numMetadataColumns++;\n      user_column_idx++;\n      continue;\n    }\n\n    // Scenario #4: Constructor argument is a table-level option, ie `chunk_size`\n\n    char *key;\n    char *value;\n    int keyLength, valueLength;\n    rc = vec0_parse_table_option(argv[i], strlen(argv[i]), &key, &keyLength,\n                                 &value, &valueLength);\n    if (rc == SQLITE_ERROR) {\n      *pzErr = sqlite3_mprintf(\n          VEC_CONSTRUCTOR_ERROR \"could not parse table option '%s'\", argv[i]);\n      goto error;\n    }\n    if (rc == SQLITE_OK) {\n      if (sqlite3_strnicmp(key, \"chunk_size\", keyLength) == 0) {\n        chunk_size = atoi(value);\n        if (chunk_size <= 0) {\n          // IMP: V01931_18769\n          *pzErr =\n              sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR\n                              \"chunk_size must be a non-zero positive integer\");\n          goto error;\n        }\n        if ((chunk_size % 8) != 0) {\n          // IMP: V14110_30948\n          *pzErr = sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR\n                                   \"chunk_size must be divisible by 8\");\n          goto error;\n        }\n#define SQLITE_VEC_CHUNK_SIZE_MAX 4096\n        if (chunk_size > SQLITE_VEC_CHUNK_SIZE_MAX) {\n          *pzErr =\n              sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR \"chunk_size too large\");\n          goto error;\n        }\n      } else {\n        // IMP: V27642_11712\n        *pzErr = sqlite3_mprintf(\n            VEC_CONSTRUCTOR_ERROR \"Unknown table option: %.*s\", keyLength, key);\n        goto error;\n      }\n      continue;\n    }\n\n    // Scenario #5: Unknown constructor argument\n    *pzErr =\n        sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR \"Could not parse '%s'\", argv[i]);\n    goto error;\n  }\n\n  if (chunk_size < 0) {\n    chunk_size = 1024;\n  }\n\n  if (numVectorColumns <= 0) {\n    *pzErr = sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR\n                             \"At least one vector column is required\");\n    goto error;\n  }\n\n  sqlite3_str *createStr = sqlite3_str_new(NULL);\n  sqlite3_str_appendall(createStr, \"CREATE TABLE x(\");\n  if (pkColumnName) {\n    sqlite3_str_appendf(createStr, \"\\\"%.*w\\\" primary key, \", pkColumnNameLength,\n                        pkColumnName);\n  } else {\n    sqlite3_str_appendall(createStr, \"rowid, \");\n  }\n  for (int i = 0; i < numVectorColumns + numPartitionColumns + numAuxiliaryColumns + numMetadataColumns; i++) {\n    switch(pNew->user_column_kinds[i]) {\n      case SQLITE_VEC0_USER_COLUMN_KIND_VECTOR: {\n        int vector_idx = pNew->user_column_idxs[i];\n        sqlite3_str_appendf(createStr, \"\\\"%.*w\\\", \",\n                        pNew->vector_columns[vector_idx].name_length,\n                        pNew->vector_columns[vector_idx].name);\n        break;\n      }\n      case SQLITE_VEC0_USER_COLUMN_KIND_PARTITION: {\n        int partition_idx = pNew->user_column_idxs[i];\n        sqlite3_str_appendf(createStr, \"\\\"%.*w\\\", \",\n                        pNew->paritition_columns[partition_idx].name_length,\n                        pNew->paritition_columns[partition_idx].name);\n        break;\n      }\n      case SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY: {\n        int auxiliary_idx = pNew->user_column_idxs[i];\n        sqlite3_str_appendf(createStr, \"\\\"%.*w\\\", \",\n                        pNew->auxiliary_columns[auxiliary_idx].name_length,\n                        pNew->auxiliary_columns[auxiliary_idx].name);\n        break;\n      }\n      case SQLITE_VEC0_USER_COLUMN_KIND_METADATA: {\n        int metadata_idx = pNew->user_column_idxs[i];\n        sqlite3_str_appendf(createStr, \"\\\"%.*w\\\", \",\n                        pNew->metadata_columns[metadata_idx].name_length,\n                        pNew->metadata_columns[metadata_idx].name);\n        break;\n      }\n    }\n\n  }\n  sqlite3_str_appendall(createStr, \" distance hidden, k hidden) \");\n  if (pkColumnName) {\n    sqlite3_str_appendall(createStr, \"without rowid \");\n  }\n  zSql = sqlite3_str_finish(createStr);\n  if (!zSql) {\n    goto error;\n  }\n  rc = sqlite3_declare_vtab(db, zSql);\n  sqlite3_free((void *)zSql);\n  if (rc != SQLITE_OK) {\n    *pzErr = sqlite3_mprintf(VEC_CONSTRUCTOR_ERROR\n                             \"could not declare virtual table, '%s'\",\n                             sqlite3_errmsg(db));\n    goto error;\n  }\n\n  const char *schemaName = argv[1];\n  const char *tableName = argv[2];\n\n  pNew->db = db;\n  pNew->pkIsText = pkColumnType == SQLITE_TEXT;\n  pNew->schemaName = sqlite3_mprintf(\"%s\", schemaName);\n  if (!pNew->schemaName) {\n    goto error;\n  }\n  pNew->tableName = sqlite3_mprintf(\"%s\", tableName);\n  if (!pNew->tableName) {\n    goto error;\n  }\n  pNew->shadowRowidsName = sqlite3_mprintf(\"%s_rowids\", tableName);\n  if (!pNew->shadowRowidsName) {\n    goto error;\n  }\n  pNew->shadowChunksName = sqlite3_mprintf(\"%s_chunks\", tableName);\n  if (!pNew->shadowChunksName) {\n    goto error;\n  }\n  pNew->numVectorColumns = numVectorColumns;\n  pNew->numPartitionColumns = numPartitionColumns;\n  pNew->numAuxiliaryColumns = numAuxiliaryColumns;\n  pNew->numMetadataColumns = numMetadataColumns;\n\n  for (int i = 0; i < pNew->numVectorColumns; i++) {\n    pNew->shadowVectorChunksNames[i] =\n        sqlite3_mprintf(\"%s_vector_chunks%02d\", tableName, i);\n    if (!pNew->shadowVectorChunksNames[i]) {\n      goto error;\n    }\n  }\n  for (int i = 0; i < pNew->numMetadataColumns; i++) {\n    pNew->shadowMetadataChunksNames[i] =\n        sqlite3_mprintf(\"%s_metadatachunks%02d\", tableName, i);\n    if (!pNew->shadowMetadataChunksNames[i]) {\n      goto error;\n    }\n  }\n  pNew->chunk_size = chunk_size;\n\n  // if xCreate, then create the necessary shadow tables\n  if (isCreate) {\n    sqlite3_stmt *stmt;\n    int rc;\n\n    char * zCreateInfo = sqlite3_mprintf(\"CREATE TABLE \"VEC0_SHADOW_INFO_NAME \" (key text primary key, value any)\", pNew->schemaName, pNew->tableName);\n    if(!zCreateInfo) {\n      goto error;\n    }\n    rc = sqlite3_prepare_v2(db, zCreateInfo, -1, &stmt, NULL);\n\n    sqlite3_free((void *) zCreateInfo);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      // TODO(IMP)\n      sqlite3_finalize(stmt);\n      *pzErr = sqlite3_mprintf(\"Could not create '_info' shadow table: %s\",\n                               sqlite3_errmsg(db));\n      goto error;\n    }\n    sqlite3_finalize(stmt);\n\n    char * zSeedInfo = sqlite3_mprintf(\n      \"INSERT INTO \"VEC0_SHADOW_INFO_NAME \"(key, value) VALUES \"\n      \"(?1, ?2), (?3, ?4), (?5, ?6), (?7, ?8) \",\n      pNew->schemaName, pNew->tableName\n    );\n    if(!zSeedInfo) {\n      goto error;\n    }\n    rc = sqlite3_prepare_v2(db, zSeedInfo, -1, &stmt, NULL);\n    sqlite3_free((void *) zSeedInfo);\n    if (rc != SQLITE_OK) {\n      // TODO(IMP)\n      sqlite3_finalize(stmt);\n      *pzErr = sqlite3_mprintf(\"Could not seed '_info' shadow table: %s\",\n                               sqlite3_errmsg(db));\n      goto error;\n    }\n    sqlite3_bind_text(stmt, 1, \"CREATE_VERSION\", -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 2, SQLITE_VEC_VERSION, -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 3, \"CREATE_VERSION_MAJOR\", -1, SQLITE_STATIC);\n    sqlite3_bind_int(stmt, 4, SQLITE_VEC_VERSION_MAJOR);\n    sqlite3_bind_text(stmt, 5, \"CREATE_VERSION_MINOR\", -1, SQLITE_STATIC);\n    sqlite3_bind_int(stmt, 6, SQLITE_VEC_VERSION_MINOR);\n    sqlite3_bind_text(stmt, 7, \"CREATE_VERSION_PATCH\", -1, SQLITE_STATIC);\n    sqlite3_bind_int(stmt, 8, SQLITE_VEC_VERSION_PATCH);\n\n    if(sqlite3_step(stmt) != SQLITE_DONE) {\n      // TODO(IMP)\n      sqlite3_finalize(stmt);\n      *pzErr = sqlite3_mprintf(\"Could not seed '_info' shadow table: %s\",\n                               sqlite3_errmsg(db));\n      goto error;\n    }\n    sqlite3_finalize(stmt);\n\n\n\n    // create the _chunks shadow table\n    char *zCreateShadowChunks = NULL;\n    if(pNew->numPartitionColumns) {\n      sqlite3_str * s = sqlite3_str_new(NULL);\n      sqlite3_str_appendf(s, \"CREATE TABLE \" VEC0_SHADOW_CHUNKS_NAME \"(\", pNew->schemaName, pNew->tableName);\n      sqlite3_str_appendall(s, \"chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,\" \"size INTEGER NOT NULL,\");\n      sqlite3_str_appendall(s, \"sequence_id integer,\");\n      for(int i = 0; i < pNew->numPartitionColumns;i++) {\n        sqlite3_str_appendf(s, \"partition%02d,\", i);\n      }\n      sqlite3_str_appendall(s, \"validity BLOB NOT NULL, rowids BLOB NOT NULL);\");\n      zCreateShadowChunks = sqlite3_str_finish(s);\n    }else {\n      zCreateShadowChunks = sqlite3_mprintf(VEC0_SHADOW_CHUNKS_CREATE,\n                                          pNew->schemaName, pNew->tableName);\n    }\n    if (!zCreateShadowChunks) {\n        goto error;\n      }\n    rc = sqlite3_prepare_v2(db, zCreateShadowChunks, -1, &stmt, 0);\n    sqlite3_free((void *)zCreateShadowChunks);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      // IMP: V17740_01811\n      sqlite3_finalize(stmt);\n      *pzErr = sqlite3_mprintf(\"Could not create '_chunks' shadow table: %s\",\n                               sqlite3_errmsg(db));\n      goto error;\n    }\n    sqlite3_finalize(stmt);\n\n    // create the _rowids shadow table\n    char *zCreateShadowRowids;\n    if (pNew->pkIsText) {\n      // adds a \"text unique not null\" constraint to the id column\n      zCreateShadowRowids = sqlite3_mprintf(VEC0_SHADOW_ROWIDS_CREATE_PK_TEXT,\n                                            pNew->schemaName, pNew->tableName);\n    } else {\n      zCreateShadowRowids = sqlite3_mprintf(VEC0_SHADOW_ROWIDS_CREATE_BASIC,\n                                            pNew->schemaName, pNew->tableName);\n    }\n    if (!zCreateShadowRowids) {\n      goto error;\n    }\n    rc = sqlite3_prepare_v2(db, zCreateShadowRowids, -1, &stmt, 0);\n    sqlite3_free((void *)zCreateShadowRowids);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      // IMP: V11631_28470\n      sqlite3_finalize(stmt);\n      *pzErr = sqlite3_mprintf(\"Could not create '_rowids' shadow table: %s\",\n                               sqlite3_errmsg(db));\n      goto error;\n    }\n    sqlite3_finalize(stmt);\n\n    for (int i = 0; i < pNew->numVectorColumns; i++) {\n      char *zSql = sqlite3_mprintf(VEC0_SHADOW_VECTOR_N_CREATE,\n                                   pNew->schemaName, pNew->tableName, i);\n      if (!zSql) {\n        goto error;\n      }\n      rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, 0);\n      sqlite3_free((void *)zSql);\n      if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n        // IMP: V25919_09989\n        sqlite3_finalize(stmt);\n        *pzErr = sqlite3_mprintf(\n            \"Could not create '_vector_chunks%02d' shadow table: %s\", i,\n            sqlite3_errmsg(db));\n        goto error;\n      }\n      sqlite3_finalize(stmt);\n    }\n\n    for (int i = 0; i < pNew->numMetadataColumns; i++) {\n      char *zSql = sqlite3_mprintf(\"CREATE TABLE \" VEC0_SHADOW_METADATA_N_NAME \"(rowid PRIMARY KEY, data BLOB NOT NULL);\",\n                                   pNew->schemaName, pNew->tableName, i);\n      if (!zSql) {\n        goto error;\n      }\n      rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, 0);\n      sqlite3_free((void *)zSql);\n      if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n        sqlite3_finalize(stmt);\n        *pzErr = sqlite3_mprintf(\n            \"Could not create '_metata_chunks%02d' shadow table: %s\", i,\n            sqlite3_errmsg(db));\n        goto error;\n      }\n      sqlite3_finalize(stmt);\n\n      if(pNew->metadata_columns[i].kind == VEC0_METADATA_COLUMN_KIND_TEXT) {\n        char *zSql = sqlite3_mprintf(\"CREATE TABLE \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \"(rowid PRIMARY KEY, data TEXT);\",\n                                   pNew->schemaName, pNew->tableName, i);\n        if (!zSql) {\n          goto error;\n        }\n        rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, 0);\n        sqlite3_free((void *)zSql);\n        if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n          sqlite3_finalize(stmt);\n          *pzErr = sqlite3_mprintf(\n              \"Could not create '_metadatatext%02d' shadow table: %s\", i,\n              sqlite3_errmsg(db));\n          goto error;\n        }\n        sqlite3_finalize(stmt);\n\n      }\n    }\n\n    if(pNew->numAuxiliaryColumns > 0) {\n      sqlite3_stmt * stmt;\n      sqlite3_str * s = sqlite3_str_new(NULL);\n      sqlite3_str_appendf(s, \"CREATE TABLE \" VEC0_SHADOW_AUXILIARY_NAME \"( rowid integer PRIMARY KEY \", pNew->schemaName, pNew->tableName);\n      for(int i = 0; i < pNew->numAuxiliaryColumns; i++) {\n        sqlite3_str_appendf(s, \", value%02d\", i);\n      }\n      sqlite3_str_appendall(s, \")\");\n      char *zSql = sqlite3_str_finish(s);\n      if(!zSql) {\n        goto error;\n      }\n      rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, NULL);\n      if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n        sqlite3_finalize(stmt);\n        *pzErr = sqlite3_mprintf(\n            \"Could not create auxiliary shadow table: %s\",\n            sqlite3_errmsg(db));\n\n        goto error;\n      }\n      sqlite3_finalize(stmt);\n    }\n  }\n\n  *ppVtab = (sqlite3_vtab *)pNew;\n  return SQLITE_OK;\n\nerror:\n  vec0_free(pNew);\n  return SQLITE_ERROR;\n}\n\nstatic int vec0Create(sqlite3 *db, void *pAux, int argc,\n                      const char *const *argv, sqlite3_vtab **ppVtab,\n                      char **pzErr) {\n  return vec0_init(db, pAux, argc, argv, ppVtab, pzErr, true);\n}\nstatic int vec0Connect(sqlite3 *db, void *pAux, int argc,\n                       const char *const *argv, sqlite3_vtab **ppVtab,\n                       char **pzErr) {\n  return vec0_init(db, pAux, argc, argv, ppVtab, pzErr, false);\n}\n\nstatic int vec0Disconnect(sqlite3_vtab *pVtab) {\n  vec0_vtab *p = (vec0_vtab *)pVtab;\n  vec0_free(p);\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\nstatic int vec0Destroy(sqlite3_vtab *pVtab) {\n  vec0_vtab *p = (vec0_vtab *)pVtab;\n  sqlite3_stmt *stmt;\n  int rc;\n  const char *zSql;\n\n  // Free up any sqlite3_stmt, otherwise DROPs on those tables will fail\n  vec0_free_resources(p);\n\n  // TODO(test) later: can't evidence-of here, bc always gives \"SQL logic error\" instead of\n  // provided error\n  zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_CHUNKS_NAME, p->schemaName,\n                         p->tableName);\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n  sqlite3_free((void *)zSql);\n  if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n    rc = SQLITE_ERROR;\n    vtab_set_error(pVtab, \"could not drop chunks shadow table\");\n    goto done;\n  }\n  sqlite3_finalize(stmt);\n\n  zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_INFO_NAME, p->schemaName,\n                         p->tableName);\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n  sqlite3_free((void *)zSql);\n  if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n    rc = SQLITE_ERROR;\n    vtab_set_error(pVtab, \"could not drop info shadow table\");\n    goto done;\n  }\n  sqlite3_finalize(stmt);\n\n  zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_ROWIDS_NAME, p->schemaName,\n                         p->tableName);\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n  sqlite3_free((void *)zSql);\n  if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n    rc = SQLITE_ERROR;\n    goto done;\n  }\n  sqlite3_finalize(stmt);\n\n  for (int i = 0; i < p->numVectorColumns; i++) {\n    zSql = sqlite3_mprintf(\"DROP TABLE \\\"%w\\\".\\\"%w\\\"\", p->schemaName,\n                           p->shadowVectorChunksNames[i]);\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n    sqlite3_free((void *)zSql);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n    sqlite3_finalize(stmt);\n  }\n\n  if(p->numAuxiliaryColumns > 0) {\n    zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_AUXILIARY_NAME, p->schemaName, p->tableName);\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n    sqlite3_free((void *)zSql);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n    sqlite3_finalize(stmt);\n  }\n\n\n  for (int i = 0; i < p->numMetadataColumns; i++) {\n    zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_METADATA_N_NAME, p->schemaName,p->tableName, i);\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n    sqlite3_free((void *)zSql);\n    if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n    sqlite3_finalize(stmt);\n\n    if(p->metadata_columns[i].kind == VEC0_METADATA_COLUMN_KIND_TEXT) {\n      zSql = sqlite3_mprintf(\"DROP TABLE \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME, p->schemaName,p->tableName, i);\n      rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, 0);\n      sqlite3_free((void *)zSql);\n      if ((rc != SQLITE_OK) || (sqlite3_step(stmt) != SQLITE_DONE)) {\n        rc = SQLITE_ERROR;\n        goto done;\n      }\n      sqlite3_finalize(stmt);\n    }\n  }\n\n  stmt = NULL;\n  rc = SQLITE_OK;\n\ndone:\n  sqlite3_finalize(stmt);\n  vec0_free(p);\n  // If there was an error\n  if (rc == SQLITE_OK) {\n    sqlite3_free(p);\n  }\n  return rc;\n}\n\nstatic int vec0Open(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor) {\n  UNUSED_PARAMETER(p);\n  vec0_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(*pCur));\n  if (pCur == 0)\n    return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\nstatic int vec0Close(sqlite3_vtab_cursor *cur) {\n  vec0_cursor *pCur = (vec0_cursor *)cur;\n  vec0_cursor_clear(pCur);\n  sqlite3_free(pCur);\n  return SQLITE_OK;\n}\n\n// All the different type of \"values\" provided to argv/argc in vec0Filter.\n// These enums denote the use and purpose of all of them.\ntypedef enum  {\n  // If any values are updated, please update the ARCHITECTURE.md docs accordingly!\n\n  VEC0_IDXSTR_KIND_KNN_MATCH = '{',\n  VEC0_IDXSTR_KIND_KNN_K = '}',\n  VEC0_IDXSTR_KIND_KNN_ROWID_IN = '[',\n  VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT = ']',\n  VEC0_IDXSTR_KIND_POINT_ID = '!',\n  VEC0_IDXSTR_KIND_METADATA_CONSTRAINT = '&',\n} vec0_idxstr_kind;\n\n// The different SQLITE_INDEX_CONSTRAINT values that vec0 partition key columns\n// support, but as characters that fit nicely in idxstr.\ntypedef enum  {\n  // If any values are updated, please update the ARCHITECTURE.md docs accordingly!\n\n  VEC0_PARTITION_OPERATOR_EQ = 'a',\n  VEC0_PARTITION_OPERATOR_GT = 'b',\n  VEC0_PARTITION_OPERATOR_LE = 'c',\n  VEC0_PARTITION_OPERATOR_LT = 'd',\n  VEC0_PARTITION_OPERATOR_GE = 'e',\n  VEC0_PARTITION_OPERATOR_NE = 'f',\n} vec0_partition_operator;\ntypedef enum  {\n  VEC0_METADATA_OPERATOR_EQ = 'a',\n  VEC0_METADATA_OPERATOR_GT = 'b',\n  VEC0_METADATA_OPERATOR_LE = 'c',\n  VEC0_METADATA_OPERATOR_LT = 'd',\n  VEC0_METADATA_OPERATOR_GE = 'e',\n  VEC0_METADATA_OPERATOR_NE = 'f',\n  VEC0_METADATA_OPERATOR_IN = 'g',\n} vec0_metadata_operator;\n\nstatic int vec0BestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pIdxInfo) {\n  vec0_vtab *p = (vec0_vtab *)pVTab;\n  /**\n   * Possible query plans are:\n   * 1. KNN when:\n   *    a) An `MATCH` op on vector column\n   *    b) ORDER BY on distance column\n   *    c) LIMIT\n   *    d) rowid in (...) OPTIONAL\n   * 2. Point when:\n   *    a) An `EQ` op on rowid column\n   * 3. else: fullscan\n   *\n   */\n  int iMatchTerm = -1;\n  int iMatchVectorTerm = -1;\n  int iLimitTerm = -1;\n  int iRowidTerm = -1;\n  int iKTerm = -1;\n  int iRowidInTerm = -1;\n  int hasAuxConstraint = 0;\n\n#ifdef SQLITE_VEC_DEBUG\n  printf(\"pIdxInfo->nOrderBy=%d, pIdxInfo->nConstraint=%d\\n\", pIdxInfo->nOrderBy, pIdxInfo->nConstraint);\n#endif\n\n  for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n    u8 vtabIn = 0;\n\n#if COMPILER_SUPPORTS_VTAB_IN\n    if (sqlite3_libversion_number() >= 3038000) {\n      vtabIn = sqlite3_vtab_in(pIdxInfo, i, -1);\n    }\n#endif\n\n#ifdef SQLITE_VEC_DEBUG\n    printf(\"xBestIndex [%d] usable=%d iColumn=%d op=%d vtabin=%d\\n\", i,\n           pIdxInfo->aConstraint[i].usable, pIdxInfo->aConstraint[i].iColumn,\n           pIdxInfo->aConstraint[i].op, vtabIn);\n#endif\n    if (!pIdxInfo->aConstraint[i].usable)\n      continue;\n\n    int iColumn = pIdxInfo->aConstraint[i].iColumn;\n    int op = pIdxInfo->aConstraint[i].op;\n\n    if (op == SQLITE_INDEX_CONSTRAINT_LIMIT) {\n      iLimitTerm = i;\n    }\n    if (op == SQLITE_INDEX_CONSTRAINT_MATCH &&\n        vec0_column_idx_is_vector(p, iColumn)) {\n      if (iMatchTerm > -1) {\n        vtab_set_error(\n            pVTab, \"only 1 MATCH operator is allowed in a single vec0 query\");\n        return SQLITE_ERROR;\n      }\n      iMatchTerm = i;\n      iMatchVectorTerm = vec0_column_idx_to_vector_idx(p, iColumn);\n    }\n    if (op == SQLITE_INDEX_CONSTRAINT_EQ && iColumn == VEC0_COLUMN_ID) {\n      if (vtabIn) {\n        if (iRowidInTerm != -1) {\n          vtab_set_error(pVTab, \"only 1 'rowid in (..)' operator is allowed in \"\n                                \"a single vec0 query\");\n          return SQLITE_ERROR;\n        }\n        iRowidInTerm = i;\n\n      } else {\n        iRowidTerm = i;\n      }\n    }\n    if (op == SQLITE_INDEX_CONSTRAINT_EQ && iColumn == vec0_column_k_idx(p)) {\n      iKTerm = i;\n    }\n    if(\n      (op != SQLITE_INDEX_CONSTRAINT_LIMIT && op != SQLITE_INDEX_CONSTRAINT_OFFSET)\n      && vec0_column_idx_is_auxiliary(p, iColumn)) {\n        hasAuxConstraint = 1;\n      }\n  }\n\n  sqlite3_str *idxStr = sqlite3_str_new(NULL);\n  int rc;\n\n  if (iMatchTerm >= 0) {\n    if (iLimitTerm < 0 && iKTerm < 0) {\n      vtab_set_error(\n          pVTab,\n          \"A LIMIT or 'k = ?' constraint is required on vec0 knn queries.\");\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n    if (iLimitTerm >= 0 && iKTerm >= 0) {\n      vtab_set_error(pVTab, \"Only LIMIT or 'k =?' can be provided, not both\");\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n\n    if (pIdxInfo->nOrderBy) {\n      if (pIdxInfo->nOrderBy > 1) {\n        vtab_set_error(pVTab, \"Only a single 'ORDER BY distance' clause is \"\n                              \"allowed on vec0 KNN queries\");\n        rc = SQLITE_ERROR;\n      goto done;\n      }\n      if (pIdxInfo->aOrderBy[0].iColumn != vec0_column_distance_idx(p)) {\n        vtab_set_error(pVTab,\n                       \"Only a single 'ORDER BY distance' clause is allowed on \"\n                       \"vec0 KNN queries, not on other columns\");\n        rc = SQLITE_ERROR;\n      goto done;\n      }\n      if (pIdxInfo->aOrderBy[0].desc) {\n        vtab_set_error(\n            pVTab, \"Only ascending in ORDER BY distance clause is supported, \"\n                   \"DESC is not supported yet.\");\n        rc = SQLITE_ERROR;\n      goto done;\n      }\n    }\n\n    if(hasAuxConstraint) {\n      // IMP: V25623_09693\n      vtab_set_error(pVTab, \"An illegal WHERE constraint was provided on a vec0 auxiliary column in a KNN query.\");\n      rc = SQLITE_ERROR;\n      goto done;\n    }\n\n    sqlite3_str_appendchar(idxStr, 1, VEC0_QUERY_PLAN_KNN);\n\n    int argvIndex = 1;\n    pIdxInfo->aConstraintUsage[iMatchTerm].argvIndex = argvIndex++;\n    pIdxInfo->aConstraintUsage[iMatchTerm].omit = 1;\n    sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_KNN_MATCH);\n    sqlite3_str_appendchar(idxStr, 3, '_');\n\n    if (iLimitTerm >= 0) {\n      pIdxInfo->aConstraintUsage[iLimitTerm].argvIndex = argvIndex++;\n      pIdxInfo->aConstraintUsage[iLimitTerm].omit = 1;\n    } else {\n      pIdxInfo->aConstraintUsage[iKTerm].argvIndex = argvIndex++;\n      pIdxInfo->aConstraintUsage[iKTerm].omit = 1;\n    }\n    sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_KNN_K);\n    sqlite3_str_appendchar(idxStr, 3, '_');\n\n#if COMPILER_SUPPORTS_VTAB_IN\n    if (iRowidInTerm >= 0) {\n      // already validated as  >= SQLite 3.38 bc iRowidInTerm is only >= 0 when\n      // vtabIn == 1\n      sqlite3_vtab_in(pIdxInfo, iRowidInTerm, 1);\n      pIdxInfo->aConstraintUsage[iRowidInTerm].argvIndex = argvIndex++;\n      pIdxInfo->aConstraintUsage[iRowidInTerm].omit = 1;\n      sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_KNN_ROWID_IN);\n      sqlite3_str_appendchar(idxStr, 3, '_');\n    }\n#endif\n\n    for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n      if (!pIdxInfo->aConstraint[i].usable)\n        continue;\n\n      int iColumn = pIdxInfo->aConstraint[i].iColumn;\n      int op = pIdxInfo->aConstraint[i].op;\n      if(op == SQLITE_INDEX_CONSTRAINT_LIMIT || op == SQLITE_INDEX_CONSTRAINT_OFFSET) {\n        continue;\n      }\n      if(!vec0_column_idx_is_partition(p, iColumn)) {\n        continue;\n      }\n\n      int partition_idx = vec0_column_idx_to_partition_idx(p, iColumn);\n      char value = 0;\n\n      switch(op) {\n        case SQLITE_INDEX_CONSTRAINT_EQ: {\n          value = VEC0_PARTITION_OPERATOR_EQ;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_GT: {\n          value = VEC0_PARTITION_OPERATOR_GT;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_LE: {\n          value = VEC0_PARTITION_OPERATOR_LE;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_LT: {\n          value = VEC0_PARTITION_OPERATOR_LT;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_GE: {\n          value = VEC0_PARTITION_OPERATOR_GE;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_NE: {\n          value = VEC0_PARTITION_OPERATOR_NE;\n          break;\n        }\n      }\n\n      if(value) {\n        pIdxInfo->aConstraintUsage[i].argvIndex = argvIndex++;\n        pIdxInfo->aConstraintUsage[i].omit = 1;\n        sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT);\n        sqlite3_str_appendchar(idxStr, 1, 'A' + partition_idx);\n        sqlite3_str_appendchar(idxStr, 1, value);\n        sqlite3_str_appendchar(idxStr, 1, '_');\n      }\n\n    }\n\n    for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n      if (!pIdxInfo->aConstraint[i].usable)\n        continue;\n\n      int iColumn = pIdxInfo->aConstraint[i].iColumn;\n      int op = pIdxInfo->aConstraint[i].op;\n      if(op == SQLITE_INDEX_CONSTRAINT_LIMIT || op == SQLITE_INDEX_CONSTRAINT_OFFSET) {\n        continue;\n      }\n      if(!vec0_column_idx_is_metadata(p, iColumn)) {\n        continue;\n      }\n\n      int metadata_idx = vec0_column_idx_to_metadata_idx(p, iColumn);\n      char value = 0;\n\n      switch(op) {\n        case SQLITE_INDEX_CONSTRAINT_EQ: {\n          int vtabIn = 0;\n          #if COMPILER_SUPPORTS_VTAB_IN\n          if (sqlite3_libversion_number() >= 3038000) {\n            vtabIn = sqlite3_vtab_in(pIdxInfo, i, -1);\n          }\n          if(vtabIn) {\n            switch(p->metadata_columns[metadata_idx].kind) {\n              case VEC0_METADATA_COLUMN_KIND_FLOAT:\n              case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n                // IMP: V15248_32086\n                rc = SQLITE_ERROR;\n                vtab_set_error(pVTab, \"'xxx in (...)' is only available on INTEGER or TEXT metadata columns.\");\n                goto done;\n                break;\n              }\n              case VEC0_METADATA_COLUMN_KIND_INTEGER:\n              case VEC0_METADATA_COLUMN_KIND_TEXT: {\n                break;\n              }\n            }\n            value = VEC0_METADATA_OPERATOR_IN;\n            sqlite3_vtab_in(pIdxInfo, i, 1);\n          }else\n          #endif\n           {\n            value = VEC0_PARTITION_OPERATOR_EQ;\n          }\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_GT: {\n          value = VEC0_METADATA_OPERATOR_GT;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_LE: {\n          value = VEC0_METADATA_OPERATOR_LE;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_LT: {\n          value = VEC0_METADATA_OPERATOR_LT;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_GE: {\n          value = VEC0_METADATA_OPERATOR_GE;\n          break;\n        }\n        case SQLITE_INDEX_CONSTRAINT_NE: {\n          value = VEC0_METADATA_OPERATOR_NE;\n          break;\n        }\n        default: {\n          // IMP: V16511_00582\n          rc = SQLITE_ERROR;\n          vtab_set_error(pVTab,\n          \"An illegal WHERE constraint was provided on a vec0 metadata column in a KNN query. \"\n          \"Only one of EQUALS, GREATER_THAN, LESS_THAN_OR_EQUAL, LESS_THAN, GREATER_THAN_OR_EQUAL, NOT_EQUALS is allowed.\"\n          );\n          goto done;\n        }\n      }\n\n      if(p->metadata_columns[metadata_idx].kind == VEC0_METADATA_COLUMN_KIND_BOOLEAN) {\n        if(!(value == VEC0_METADATA_OPERATOR_EQ || value == VEC0_METADATA_OPERATOR_NE)) {\n          // IMP: V10145_26984\n          rc = SQLITE_ERROR;\n          vtab_set_error(pVTab, \"ONLY EQUALS (=) or NOT_EQUALS (!=) operators are allowed on boolean metadata columns.\");\n          goto done;\n        }\n      }\n\n      pIdxInfo->aConstraintUsage[i].argvIndex = argvIndex++;\n      pIdxInfo->aConstraintUsage[i].omit = 1;\n      sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_METADATA_CONSTRAINT);\n      sqlite3_str_appendchar(idxStr, 1, 'A' + metadata_idx);\n      sqlite3_str_appendchar(idxStr, 1, value);\n      sqlite3_str_appendchar(idxStr, 1, '_');\n\n    }\n\n\n\n    pIdxInfo->idxNum = iMatchVectorTerm;\n    pIdxInfo->estimatedCost = 30.0;\n    pIdxInfo->estimatedRows = 10;\n\n  } else if (iRowidTerm >= 0) {\n    sqlite3_str_appendchar(idxStr, 1, VEC0_QUERY_PLAN_POINT);\n    pIdxInfo->aConstraintUsage[iRowidTerm].argvIndex = 1;\n    pIdxInfo->aConstraintUsage[iRowidTerm].omit = 1;\n    sqlite3_str_appendchar(idxStr, 1, VEC0_IDXSTR_KIND_POINT_ID);\n    sqlite3_str_appendchar(idxStr, 3, '_');\n    pIdxInfo->idxNum = pIdxInfo->colUsed;\n    pIdxInfo->estimatedCost = 10.0;\n    pIdxInfo->estimatedRows = 1;\n  } else {\n    sqlite3_str_appendchar(idxStr, 1, VEC0_QUERY_PLAN_FULLSCAN);\n    pIdxInfo->estimatedCost = 3000000.0;\n    pIdxInfo->estimatedRows = 100000;\n  }\n  pIdxInfo->idxStr = sqlite3_str_finish(idxStr);\n  idxStr = NULL;\n  if (!pIdxInfo->idxStr) {\n    rc = SQLITE_OK;\n    goto done;\n  }\n  pIdxInfo->needToFreeIdxStr = 1;\n\n\n  rc = SQLITE_OK;\n\n  done:\n    if(idxStr) {\n      sqlite3_str_finish(idxStr);\n    }\n    return rc;\n}\n\n// forward delcaration bc vec0Filter uses it\nstatic int vec0Next(sqlite3_vtab_cursor *cur);\n\nvoid merge_sorted_lists(f32 *a, i64 *a_rowids, i64 a_length, f32 *b,\n                        i64 *b_rowids, i32 *b_top_idxs, i64 b_length, f32 *out,\n                        i64 *out_rowids, i64 out_length, i64 *out_used) {\n  // assert((a_length >= out_length) || (b_length >= out_length));\n  i64 ptrA = 0;\n  i64 ptrB = 0;\n  for (int i = 0; i < out_length; i++) {\n    if ((ptrA >= a_length) && (ptrB >= b_length)) {\n      *out_used = i;\n      return;\n    }\n    if (ptrA >= a_length) {\n      out[i] = b[b_top_idxs[ptrB]];\n      out_rowids[i] = b_rowids[b_top_idxs[ptrB]];\n      ptrB++;\n    } else if (ptrB >= b_length) {\n      out[i] = a[ptrA];\n      out_rowids[i] = a_rowids[ptrA];\n      ptrA++;\n    } else {\n      if (a[ptrA] <= b[b_top_idxs[ptrB]]) {\n        out[i] = a[ptrA];\n        out_rowids[i] = a_rowids[ptrA];\n        ptrA++;\n      } else {\n        out[i] = b[b_top_idxs[ptrB]];\n        out_rowids[i] = b_rowids[b_top_idxs[ptrB]];\n        ptrB++;\n      }\n    }\n  }\n\n  *out_used = out_length;\n}\n\nu8 *bitmap_new(i32 n) {\n  assert(n % 8 == 0);\n  u8 *p = sqlite3_malloc(n * sizeof(u8) / CHAR_BIT);\n  if (p) {\n    memset(p, 0, n * sizeof(u8) / CHAR_BIT);\n  }\n  return p;\n}\nu8 *bitmap_new_from(i32 n, u8 *from) {\n  assert(n % 8 == 0);\n  u8 *p = sqlite3_malloc(n * sizeof(u8) / CHAR_BIT);\n  if (p) {\n    memcpy(p, from, n / CHAR_BIT);\n  }\n  return p;\n}\n\nvoid bitmap_copy(u8 *base, u8 *from, i32 n) {\n  assert(n % 8 == 0);\n  memcpy(base, from, n / CHAR_BIT);\n}\n\nvoid bitmap_and_inplace(u8 *base, u8 *other, i32 n) {\n  assert((n % 8) == 0);\n  for (int i = 0; i < n / CHAR_BIT; i++) {\n    base[i] = base[i] & other[i];\n  }\n}\n\nvoid bitmap_set(u8 *bitmap, i32 position, int value) {\n  if (value) {\n    bitmap[position / CHAR_BIT] |= 1 << (position % CHAR_BIT);\n  } else {\n    bitmap[position / CHAR_BIT] &= ~(1 << (position % CHAR_BIT));\n  }\n}\n\nint bitmap_get(u8 *bitmap, i32 position) {\n  return (((bitmap[position / CHAR_BIT]) >> (position % CHAR_BIT)) & 1);\n}\n\nvoid bitmap_clear(u8 *bitmap, i32 n) {\n  assert((n % 8) == 0);\n  memset(bitmap, 0, n / CHAR_BIT);\n}\n\nvoid bitmap_fill(u8 *bitmap, i32 n) {\n  assert((n % 8) == 0);\n  memset(bitmap, 0xFF, n / CHAR_BIT);\n}\n\n/**\n * @brief Finds the minimum k items in distances, and writes the indicies to\n * out.\n *\n * @param distances input f32 array of size n, the items to consider.\n * @param n: size of distances array.\n * @param out: Output array of size k, will contain at most k element indicies\n * @param k: Size of output array\n * @return int\n */\nint min_idx(const f32 *distances, i32 n, u8 *candidates, i32 *out, i32 k,\n            u8 *bTaken, i32 *k_used) {\n  assert(k > 0);\n  assert(k <= n);\n\n  bitmap_clear(bTaken, n);\n\n  for (int ik = 0; ik < k; ik++) {\n    int min_idx = 0;\n    while (min_idx < n &&\n           (bitmap_get(bTaken, min_idx) || !bitmap_get(candidates, min_idx))) {\n      min_idx++;\n    }\n    if (min_idx >= n) {\n      *k_used = ik;\n      return SQLITE_OK;\n    }\n\n    for (int i = 0; i < n; i++) {\n      if (distances[i] <= distances[min_idx] && !bitmap_get(bTaken, i) &&\n          (bitmap_get(candidates, i))) {\n        min_idx = i;\n      }\n    }\n\n    out[ik] = min_idx;\n    bitmap_set(bTaken, min_idx, 1);\n  }\n  *k_used = k;\n  return SQLITE_OK;\n}\n\nint vec0_get_metadata_text_long_value(\n  vec0_vtab * p,\n  sqlite3_stmt ** stmt,\n  int metadata_idx,\n  i64 rowid,\n  int *n,\n  char ** s) {\n  int rc;\n  if(!(*stmt)) {\n    const char * zSql = sqlite3_mprintf(\"select data from \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" where rowid = ?\", p->schemaName, p->tableName, metadata_idx);\n    if(!zSql) {\n      rc = SQLITE_NOMEM;\n      goto done;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, stmt, NULL);\n    sqlite3_free( (void *) zSql);\n    if(rc != SQLITE_OK) {\n      goto done;\n    }\n  }\n\n  sqlite3_reset(*stmt);\n  sqlite3_bind_int64(*stmt, 1, rowid);\n  rc = sqlite3_step(*stmt);\n  if(rc != SQLITE_ROW) {\n    rc = SQLITE_ERROR;\n    goto done;\n  }\n  *s = (char *) sqlite3_column_text(*stmt, 0);\n  *n = sqlite3_column_bytes(*stmt, 0);\n  rc = SQLITE_OK;\n  done:\n    return rc;\n}\n\n/**\n * @brief Crete at \"iterator\" (sqlite3_stmt) of chunks with the given constraints\n *\n * Any VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT values in idxStr/argv will be applied\n * as WHERE constraints in the underlying stmt SQL, and any consumer of the stmt\n * can freely step through the stmt with all constraints satisfied.\n *\n * @param p - vec0_vtab\n * @param idxStr - the xBestIndex/xFilter idxstr containing VEC0_IDXSTR values\n * @param argc - number of argv values from xFilter\n * @param argv - array of sqlite3_value from xFilter\n * @param outStmt - output sqlite3_stmt of chunks with all filters applied\n * @return int SQLITE_OK on success, error code otherwise\n */\nint vec0_chunks_iter(vec0_vtab * p, const char * idxStr, int argc, sqlite3_value ** argv, sqlite3_stmt** outStmt) {\n  // always null terminated, enforced by SQLite\n  int idxStrLength = strlen(idxStr);\n  // \"1\" refers to the initial vec0_query_plan char, 4 is the number of chars per \"element\"\n  int numValueEntries = (idxStrLength-1) / 4;\n  assert(argc == numValueEntries);\n\n  int rc;\n  sqlite3_str * s = sqlite3_str_new(NULL);\n  sqlite3_str_appendf(s, \"select chunk_id, validity, rowids \"\n                         \" from \" VEC0_SHADOW_CHUNKS_NAME,\n                         p->schemaName, p->tableName);\n\n  int appendedWhere = 0;\n  for(int i = 0; i < numValueEntries; i++) {\n    int idx = 1 + (i * 4);\n    char kind = idxStr[idx + 0];\n    if(kind != VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT) {\n      continue;\n    }\n\n    int partition_idx = idxStr[idx + 1] - 'A';\n    int operator = idxStr[idx + 2];\n    // idxStr[idx + 3] is just null, a '_' placeholder\n\n    if(!appendedWhere) {\n      sqlite3_str_appendall(s, \" WHERE \");\n      appendedWhere = 1;\n    }else {\n      sqlite3_str_appendall(s, \" AND \");\n    }\n    switch(operator) {\n     case VEC0_PARTITION_OPERATOR_EQ:\n      sqlite3_str_appendf(s, \" partition%02d = ? \", partition_idx);\n      break;\n     case VEC0_PARTITION_OPERATOR_GT:\n      sqlite3_str_appendf(s, \" partition%02d > ? \", partition_idx);\n      break;\n     case VEC0_PARTITION_OPERATOR_LE:\n      sqlite3_str_appendf(s, \" partition%02d <= ? \", partition_idx);\n      break;\n     case VEC0_PARTITION_OPERATOR_LT:\n      sqlite3_str_appendf(s, \" partition%02d < ? \", partition_idx);\n      break;\n     case VEC0_PARTITION_OPERATOR_GE:\n      sqlite3_str_appendf(s, \" partition%02d >= ? \", partition_idx);\n      break;\n     case VEC0_PARTITION_OPERATOR_NE:\n      sqlite3_str_appendf(s, \" partition%02d != ? \", partition_idx);\n      break;\n     default: {\n      char * zSql = sqlite3_str_finish(s);\n      sqlite3_free(zSql);\n      return SQLITE_ERROR;\n     }\n\n    }\n\n  }\n\n  char *zSql = sqlite3_str_finish(s);\n  if (!zSql) {\n    return SQLITE_NOMEM;\n  }\n\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, outStmt, NULL);\n  sqlite3_free(zSql);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n\n  int n = 1;\n  for(int i = 0; i < numValueEntries; i++) {\n    int idx = 1 + (i * 4);\n    char kind = idxStr[idx + 0];\n    if(kind != VEC0_IDXSTR_KIND_KNN_PARTITON_CONSTRAINT) {\n      continue;\n    }\n    sqlite3_bind_value(*outStmt, n++, argv[i]);\n  }\n\n  return rc;\n}\n\n// a single `xxx in (...)` constraint on a metadata column. TEXT or INTEGER only for now.\nstruct Vec0MetadataIn{\n  // index of argv[i]` the constraint is on\n  int argv_idx;\n  // metadata column index of the constraint, derived from idxStr + argv_idx\n  int metadata_idx;\n  // array of the copied `(...)` values from sqlite3_vtab_in_first()/sqlite3_vtab_in_next()\n  struct Array array;\n};\n\n// Array elements for `xxx in (...)` values for a text column. basically just a string\nstruct Vec0MetadataInTextEntry {\n  int n;\n  char * zString;\n};\n\n\nint vec0_metadata_filter_text(vec0_vtab * p, sqlite3_value * value, const void * buffer, int size, vec0_metadata_operator op, u8* b, int metadata_idx, int chunk_rowid, struct Array * aMetadataIn, int argv_idx) {\n  int rc;\n  sqlite3_stmt * stmt = NULL;\n  i64 * rowids = NULL;\n  sqlite3_blob * rowidsBlob;\n  const char * sTarget = (const char *) sqlite3_value_text(value);\n  int nTarget = sqlite3_value_bytes(value);\n\n\n  // TODO(perf): only text metadata news the rowids BLOB. Make it so that\n  // rowids BLOB is re-used when multiple fitlers on text columns,\n  // ex \"name BETWEEN 'a' and 'b'\"\"\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowChunksName, \"rowids\", chunk_rowid, 0, &rowidsBlob);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  assert(sqlite3_blob_bytes(rowidsBlob) % sizeof(i64) == 0);\n  assert((sqlite3_blob_bytes(rowidsBlob) / sizeof(i64)) == size);\n\n  rowids = sqlite3_malloc(sqlite3_blob_bytes(rowidsBlob));\n  if(!rowids) {\n    sqlite3_blob_close(rowidsBlob);\n    return SQLITE_NOMEM;\n  }\n\n  rc = sqlite3_blob_read(rowidsBlob, rowids, sqlite3_blob_bytes(rowidsBlob), 0);\n  if(rc != SQLITE_OK) {\n    sqlite3_blob_close(rowidsBlob);\n    return rc;\n  }\n  sqlite3_blob_close(rowidsBlob);\n\n  switch(op) {\n    int nPrefix;\n    char * sPrefix;\n    char *sFull;\n    int nFull;\n    u8 * view;\n    case VEC0_METADATA_OPERATOR_EQ: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n\n        // for EQ the text lengths must match\n        if(nPrefix != nTarget) {\n          bitmap_set(b, i, 0);\n          continue;\n        }\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH));\n\n        // for short strings, use the prefix comparison direclty\n        if(nPrefix <= VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          bitmap_set(b, i, cmpPrefix == 0);\n          continue;\n        }\n        // for EQ on longs strings, the prefix must match\n        if(cmpPrefix) {\n          bitmap_set(b, i, 0);\n          continue;\n        }\n        // consult the full string\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) == 0);\n      }\n      break;\n    }\n    case VEC0_METADATA_OPERATOR_NE: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n\n        // for NE if text lengths dont match, it never will\n        if(nPrefix != nTarget) {\n          bitmap_set(b, i, 1);\n          continue;\n        }\n\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH));\n\n        // for short strings, use the prefix comparison direclty\n        if(nPrefix <= VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          bitmap_set(b, i, cmpPrefix != 0);\n          continue;\n        }\n        // for NE on longs strings, if prefixes dont match, then long string wont\n        if(cmpPrefix) {\n          bitmap_set(b, i, 1);\n          continue;\n        }\n        // consult the full string\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) != 0);\n      }\n      break;\n    }\n    case VEC0_METADATA_OPERATOR_GT: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH), nTarget));\n\n        if(nPrefix < VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          // if prefix match, check which is longer\n          if(cmpPrefix == 0) {\n            bitmap_set(b, i, nPrefix > nTarget);\n          }\n          else {\n            bitmap_set(b, i, cmpPrefix > 0);\n          }\n          continue;\n        }\n        // TODO(perf): may not need to compare full text in some cases\n\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) > 0);\n      }\n      break;\n    }\n    case VEC0_METADATA_OPERATOR_GE: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH), nTarget));\n\n        if(nPrefix < VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          // if prefix match, check which is longer\n          if(cmpPrefix == 0) {\n            bitmap_set(b, i, nPrefix >= nTarget);\n          }\n          else {\n            bitmap_set(b, i, cmpPrefix >= 0);\n          }\n          continue;\n        }\n        // TODO(perf): may not need to compare full text in some cases\n\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) >= 0);\n      }\n      break;\n    }\n    case VEC0_METADATA_OPERATOR_LE: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH), nTarget));\n\n        if(nPrefix < VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          // if prefix match, check which is longer\n          if(cmpPrefix == 0) {\n            bitmap_set(b, i, nPrefix <= nTarget);\n          }\n          else {\n            bitmap_set(b, i, cmpPrefix <= 0);\n          }\n          continue;\n        }\n        // TODO(perf): may not need to compare full text in some cases\n\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) <= 0);\n      }\n      break;\n    }\n    case VEC0_METADATA_OPERATOR_LT: {\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n        int cmpPrefix = strncmp(sPrefix, sTarget, min(min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH), nTarget));\n\n        if(nPrefix < VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n          // if prefix match, check which is longer\n          if(cmpPrefix == 0) {\n            bitmap_set(b, i, nPrefix < nTarget);\n          }\n          else {\n            bitmap_set(b, i, cmpPrefix < 0);\n          }\n          continue;\n        }\n        // TODO(perf): may not need to compare full text in some cases\n\n        rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        if(nPrefix != nFull) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        bitmap_set(b, i, strncmp(sFull, sTarget, nFull) < 0);\n      }\n      break;\n    }\n\n    case VEC0_METADATA_OPERATOR_IN: {\n      size_t metadataInIdx = -1;\n      for(size_t i = 0; i < aMetadataIn->length; i++) {\n        struct Vec0MetadataIn * metadataIn = &(((struct Vec0MetadataIn *) aMetadataIn->z)[i]);\n        if(metadataIn->argv_idx == argv_idx) {\n          metadataInIdx = i;\n          break;\n        }\n      }\n      if(metadataInIdx < 0) {\n        rc = SQLITE_ERROR;\n        goto done;\n      }\n\n      struct Vec0MetadataIn * metadataIn = &((struct Vec0MetadataIn *) aMetadataIn->z)[metadataInIdx];\n      struct Array * aTarget = &(metadataIn->array);\n\n\n      int nPrefix;\n      char * sPrefix;\n      char *sFull;\n      int nFull;\n      u8 * view;\n      for(int i = 0; i < size; i++) {\n        view = &((u8*) buffer)[i * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n        nPrefix = ((int*) view)[0];\n        sPrefix = (char *) &view[4];\n        for(size_t target_idx = 0; target_idx < aTarget->length; target_idx++) {\n          struct Vec0MetadataInTextEntry * entry = &(((struct Vec0MetadataInTextEntry*)aTarget->z)[target_idx]);\n          if(entry->n != nPrefix) {\n            continue;\n          }\n          int cmpPrefix = strncmp(sPrefix, entry->zString, min(nPrefix, VEC0_METADATA_TEXT_VIEW_DATA_LENGTH));\n          if(nPrefix <= VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n            if(cmpPrefix == 0) {\n              bitmap_set(b, i, 1);\n              break;\n            }\n            continue;\n          }\n          if(cmpPrefix) {\n            continue;\n          }\n\n          rc = vec0_get_metadata_text_long_value(p, &stmt, metadata_idx, rowids[i], &nFull, &sFull);\n          if(rc != SQLITE_OK) {\n            goto done;\n          }\n          if(nPrefix != nFull) {\n            rc = SQLITE_ERROR;\n            goto done;\n          }\n          if(strncmp(sFull, entry->zString, nFull) == 0) {\n            bitmap_set(b, i, 1);\n            break;\n          }\n        }\n      }\n      break;\n    }\n\n  }\n  rc = SQLITE_OK;\n\n  done:\n    sqlite3_finalize(stmt);\n    sqlite3_free(rowids);\n    return rc;\n\n}\n\n/**\n * @brief Fill in bitmap of chunk values, whether or not the values match a metadata constraint\n *\n * @param p vec0_vtab\n * @param metadata_idx index of the metatadata column to perfrom constraints on\n * @param value sqlite3_value of the constraints value\n * @param blob sqlite3_blob that is already opened on the metdata column's shadow chunk table\n * @param chunk_rowid rowid of the chunk to calculate on\n * @param b pre-allocated and zero'd out bitmap to write results to\n * @param size size of the chunk\n * @return int SQLITE_OK on success, error code otherwise\n */\nint vec0_set_metadata_filter_bitmap(\n  vec0_vtab *p,\n  int metadata_idx,\n  vec0_metadata_operator op,\n  sqlite3_value * value,\n  sqlite3_blob * blob,\n  i64 chunk_rowid,\n  u8* b,\n  int size,\n  struct Array * aMetadataIn, int argv_idx) {\n  // TODO: shouldn't this skip in-valid entries from the chunk's  validity bitmap?\n\n  int rc;\n  rc = sqlite3_blob_reopen(blob, chunk_rowid);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n\n  vec0_metadata_column_kind kind = p->metadata_columns[metadata_idx].kind;\n  int szMatch = 0;\n  int blobSize = sqlite3_blob_bytes(blob);\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      szMatch = blobSize == size / CHAR_BIT;\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      szMatch = blobSize == size * sizeof(i64);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      szMatch = blobSize == size * sizeof(double);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      szMatch = blobSize == size * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH;\n      break;\n    }\n  }\n  if(!szMatch) {\n    return SQLITE_ERROR;\n  }\n  void * buffer = sqlite3_malloc(blobSize);\n  if(!buffer) {\n    return SQLITE_NOMEM;\n  }\n  rc = sqlite3_blob_read(blob, buffer, blobSize, 0);\n  if(rc != SQLITE_OK) {\n    goto done;\n  }\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      int target = sqlite3_value_int(value);\n      if( (target && op == VEC0_METADATA_OPERATOR_EQ) || (!target && op == VEC0_METADATA_OPERATOR_NE)) {\n        for(int i = 0; i < size; i++) { bitmap_set(b, i, bitmap_get((u8*) buffer, i)); }\n      }\n      else {\n        for(int i = 0; i < size; i++) { bitmap_set(b, i, !bitmap_get((u8*) buffer, i)); }\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      i64 * array = (i64*) buffer;\n      i64 target = sqlite3_value_int64(value);\n      switch(op) {\n        case VEC0_METADATA_OPERATOR_EQ: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] == target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_GT: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] > target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_LE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] <= target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_LT: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] < target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_GE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] >= target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_NE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] != target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_IN: {\n          int metadataInIdx = -1;\n          for(size_t i = 0; i < aMetadataIn->length; i++) {\n            struct Vec0MetadataIn * metadataIn = &((struct Vec0MetadataIn *) aMetadataIn->z)[i];\n            if(metadataIn->argv_idx == argv_idx) {\n              metadataInIdx = i;\n              break;\n            }\n          }\n          if(metadataInIdx < 0) {\n            rc = SQLITE_ERROR;\n            goto done;\n          }\n          struct Vec0MetadataIn * metadataIn = &((struct Vec0MetadataIn *) aMetadataIn->z)[metadataInIdx];\n          struct Array * aTarget = &(metadataIn->array);\n\n          for(int i = 0; i < size; i++) {\n            for(size_t target_idx = 0; target_idx < aTarget->length; target_idx++) {\n              if( ((i64*)aTarget->z)[target_idx] == array[i]) {\n                bitmap_set(b, i, 1);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      double * array = (double*) buffer;\n      double target = sqlite3_value_double(value);\n      switch(op) {\n        case VEC0_METADATA_OPERATOR_EQ: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] == target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_GT: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] > target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_LE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] <= target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_LT: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] < target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_GE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] >= target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_NE: {\n          for(int i = 0; i < size; i++) { bitmap_set(b, i, array[i] != target); }\n          break;\n        }\n        case VEC0_METADATA_OPERATOR_IN: {\n          // should never be reached\n          break;\n        }\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      rc = vec0_metadata_filter_text(p, value, buffer, size, op, b, metadata_idx, chunk_rowid, aMetadataIn, argv_idx);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n      break;\n    }\n  }\n  done:\n    sqlite3_free(buffer);\n    return rc;\n}\n\nint vec0Filter_knn_chunks_iter(vec0_vtab *p, sqlite3_stmt *stmtChunks,\n                               struct VectorColumnDefinition *vector_column,\n                               int vectorColumnIdx, struct Array *arrayRowidsIn,\n                               struct Array * aMetadataIn,\n                               const char * idxStr, int argc, sqlite3_value ** argv,\n                               void *queryVector, i64 k, i64 **out_topk_rowids,\n                               f32 **out_topk_distances, i64 *out_used) {\n  // for each chunk, get top min(k, chunk_size) rowid + distances to query vec.\n  // then reconcile all topk_chunks for a true top k.\n  // output only rowids + distances for now\n\n  int rc = SQLITE_OK;\n  sqlite3_blob *blobVectors = NULL;\n\n  void *baseVectors = NULL; // memory: chunk_size * dimensions * element_size\n\n  // OWNED BY CALLER ON SUCCESS\n  i64 *topk_rowids = NULL; // memory: k * 4\n  // OWNED BY CALLER ON SUCCESS\n  f32 *topk_distances = NULL; // memory: k * 4\n\n  i64 *tmp_topk_rowids = NULL;    // memory: k * 4\n  f32 *tmp_topk_distances = NULL; // memory: k * 4\n  f32 *chunk_distances = NULL;    // memory: chunk_size * 4\n  u8 *b = NULL;                   // memory: chunk_size / 8\n  u8 *bTaken = NULL;              // memory: chunk_size / 8\n  i32 *chunk_topk_idxs = NULL;    // memory: k * 4\n  u8 *bmRowids = NULL;            // memory: chunk_size / 8\n  u8 *bmMetadata = NULL;            // memory: chunk_size / 8\n  //                        // total: a lot???\n\n  // 6 * (k * 4) + (k * 2) + (chunk_size / 8) + (chunk_size * dimensions * 4)\n\n  topk_rowids = sqlite3_malloc(k * sizeof(i64));\n  if (!topk_rowids) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n  memset(topk_rowids, 0, k * sizeof(i64));\n\n  topk_distances = sqlite3_malloc(k * sizeof(f32));\n  if (!topk_distances) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n  memset(topk_distances, 0, k * sizeof(f32));\n\n  tmp_topk_rowids = sqlite3_malloc(k * sizeof(i64));\n  if (!tmp_topk_rowids) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n  memset(tmp_topk_rowids, 0, k * sizeof(i64));\n\n  tmp_topk_distances = sqlite3_malloc(k * sizeof(f32));\n  if (!tmp_topk_distances) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n  memset(tmp_topk_distances, 0, k * sizeof(f32));\n\n  i64 k_used = 0;\n  i64 baseVectorsSize = p->chunk_size * vector_column_byte_size(*vector_column);\n  baseVectors = sqlite3_malloc(baseVectorsSize);\n  if (!baseVectors) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  chunk_distances = sqlite3_malloc(p->chunk_size * sizeof(f32));\n  if (!chunk_distances) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  b = bitmap_new(p->chunk_size);\n  if (!b) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  bTaken = bitmap_new(p->chunk_size);\n  if (!bTaken) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  chunk_topk_idxs = sqlite3_malloc(k * sizeof(i32));\n  if (!chunk_topk_idxs) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  bmRowids = arrayRowidsIn ? bitmap_new(p->chunk_size) : NULL;\n  if (arrayRowidsIn && !bmRowids) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  sqlite3_blob * metadataBlobs[VEC0_MAX_METADATA_COLUMNS];\n  memset(metadataBlobs, 0, sizeof(sqlite3_blob*) * VEC0_MAX_METADATA_COLUMNS);\n\n  bmMetadata = bitmap_new(p->chunk_size);\n  if(!bmMetadata) {\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  int idxStrLength = strlen(idxStr);\n  int numValueEntries = (idxStrLength-1) / 4;\n  assert(numValueEntries == argc);\n  int hasMetadataFilters = 0;\n  for(int i = 0; i < argc; i++) {\n    int idx = 1 + (i * 4);\n    char kind = idxStr[idx + 0];\n    if(kind == VEC0_IDXSTR_KIND_METADATA_CONSTRAINT) {\n      hasMetadataFilters = 1;\n      break;\n    }\n  }\n\n  while (true) {\n    rc = sqlite3_step(stmtChunks);\n    if (rc == SQLITE_DONE) {\n      break;\n    }\n    if (rc != SQLITE_ROW) {\n      vtab_set_error(&p->base, \"chunks iter error\");\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n    memset(chunk_distances, 0, p->chunk_size * sizeof(f32));\n    memset(chunk_topk_idxs, 0, k * sizeof(i32));\n    bitmap_clear(b, p->chunk_size);\n\n    i64 chunk_id = sqlite3_column_int64(stmtChunks, 0);\n    unsigned char *chunkValidity =\n        (unsigned char *)sqlite3_column_blob(stmtChunks, 1);\n    i64 validitySize = sqlite3_column_bytes(stmtChunks, 1);\n    if (validitySize != p->chunk_size / CHAR_BIT) {\n      // IMP: V05271_22109\n      vtab_set_error(\n          &p->base,\n          \"chunk validity size doesn't match - expected %lld, found %lld\",\n          p->chunk_size / CHAR_BIT, validitySize);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    i64 *chunkRowids = (i64 *)sqlite3_column_blob(stmtChunks, 2);\n    i64 rowidsSize = sqlite3_column_bytes(stmtChunks, 2);\n    if (rowidsSize != p->chunk_size * sizeof(i64)) {\n      // IMP: V02796_19635\n      vtab_set_error(&p->base, \"rowids size doesn't match\");\n      vtab_set_error(\n          &p->base,\n          \"chunk rowids size doesn't match - expected %lld, found %lld\",\n          p->chunk_size * sizeof(i64), rowidsSize);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    // open the vector chunk blob for the current chunk\n    rc = sqlite3_blob_open(p->db, p->schemaName,\n                           p->shadowVectorChunksNames[vectorColumnIdx],\n                           \"vectors\", chunk_id, 0, &blobVectors);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, \"could not open vectors blob for chunk %lld\",\n                     chunk_id);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    i64 currentBaseVectorsSize = sqlite3_blob_bytes(blobVectors);\n    i64 expectedBaseVectorsSize =\n        p->chunk_size * vector_column_byte_size(*vector_column);\n    if (currentBaseVectorsSize != expectedBaseVectorsSize) {\n      // IMP: V16465_00535\n      vtab_set_error(\n          &p->base,\n          \"vectors blob size doesn't match - expected %lld, found %lld\",\n          expectedBaseVectorsSize, currentBaseVectorsSize);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n    rc = sqlite3_blob_read(blobVectors, baseVectors, currentBaseVectorsSize, 0);\n\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, \"vectors blob read error for %lld\", chunk_id);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    bitmap_copy(b, chunkValidity, p->chunk_size);\n    if (arrayRowidsIn) {\n      bitmap_clear(bmRowids, p->chunk_size);\n\n      for (int i = 0; i < p->chunk_size; i++) {\n        if (!bitmap_get(chunkValidity, i)) {\n          continue;\n        }\n        i64 rowid = chunkRowids[i];\n        void *in = bsearch(&rowid, arrayRowidsIn->z, arrayRowidsIn->length,\n                           sizeof(i64), _cmp);\n        bitmap_set(bmRowids, i, in ? 1 : 0);\n      }\n      bitmap_and_inplace(b, bmRowids, p->chunk_size);\n    }\n\n    if(hasMetadataFilters) {\n      for(int i = 0; i < argc; i++) {\n        int idx = 1 + (i * 4);\n        char kind = idxStr[idx + 0];\n        if(kind != VEC0_IDXSTR_KIND_METADATA_CONSTRAINT) {\n          continue;\n        }\n        int metadata_idx = idxStr[idx + 1] - 'A';\n        int operator = idxStr[idx + 2];\n\n        if(!metadataBlobs[metadata_idx]) {\n          rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowMetadataChunksNames[metadata_idx], \"data\", chunk_id, 0, &metadataBlobs[metadata_idx]);\n          vtab_set_error(&p->base, \"Could not open metadata blob\");\n          if(rc != SQLITE_OK) {\n            goto cleanup;\n          }\n        }\n\n        bitmap_clear(bmMetadata, p->chunk_size);\n        rc = vec0_set_metadata_filter_bitmap(p, metadata_idx, operator, argv[i], metadataBlobs[metadata_idx], chunk_id, bmMetadata, p->chunk_size, aMetadataIn, i);\n        if(rc != SQLITE_OK) {\n          vtab_set_error(&p->base, \"Could not filter metadata fields\");\n          if(rc != SQLITE_OK) {\n            goto cleanup;\n          }\n        }\n        bitmap_and_inplace(b, bmMetadata, p->chunk_size);\n      }\n    }\n\n\n    for (int i = 0; i < p->chunk_size; i++) {\n      if (!bitmap_get(b, i)) {\n        continue;\n      };\n\n      f32 result;\n      switch (vector_column->element_type) {\n      case SQLITE_VEC_ELEMENT_TYPE_FLOAT32: {\n        const f32 *base_i =\n            ((f32 *)baseVectors) + (i * vector_column->dimensions);\n        switch (vector_column->distance_metric) {\n        case VEC0_DISTANCE_METRIC_L2: {\n          result = distance_l2_sqr_float(base_i, (f32 *)queryVector,\n                                         &vector_column->dimensions);\n          break;\n        }\n        case VEC0_DISTANCE_METRIC_L1: {\n          result = distance_l1_f32(base_i, (f32 *)queryVector,\n                                   &vector_column->dimensions);\n          break;\n        }\n        case VEC0_DISTANCE_METRIC_COSINE: {\n          result = distance_cosine_float(base_i, (f32 *)queryVector,\n                                         &vector_column->dimensions);\n          break;\n        }\n        }\n        break;\n      }\n      case SQLITE_VEC_ELEMENT_TYPE_INT8: {\n        const i8 *base_i =\n            ((i8 *)baseVectors) + (i * vector_column->dimensions);\n        switch (vector_column->distance_metric) {\n        case VEC0_DISTANCE_METRIC_L2: {\n          result = distance_l2_sqr_int8(base_i, (i8 *)queryVector,\n                                        &vector_column->dimensions);\n          break;\n        }\n        case VEC0_DISTANCE_METRIC_L1: {\n          result = distance_l1_int8(base_i, (i8 *)queryVector,\n                                    &vector_column->dimensions);\n          break;\n        }\n        case VEC0_DISTANCE_METRIC_COSINE: {\n          result = distance_cosine_int8(base_i, (i8 *)queryVector,\n                                        &vector_column->dimensions);\n          break;\n        }\n        }\n\n        break;\n      }\n      case SQLITE_VEC_ELEMENT_TYPE_BIT: {\n        const u8 *base_i =\n            ((u8 *)baseVectors) + (i * (vector_column->dimensions / CHAR_BIT));\n        result = distance_hamming(base_i, (u8 *)queryVector,\n                                  &vector_column->dimensions);\n        break;\n      }\n      }\n\n      chunk_distances[i] = result;\n    }\n\n    int used1;\n    min_idx(chunk_distances, p->chunk_size, b, chunk_topk_idxs,\n            min(k, p->chunk_size), bTaken, &used1);\n\n    i64 used;\n    merge_sorted_lists(topk_distances, topk_rowids, k_used, chunk_distances,\n                       chunkRowids, chunk_topk_idxs,\n                       min(min(k, p->chunk_size), used1), tmp_topk_distances,\n                       tmp_topk_rowids, k, &used);\n\n    for (int i = 0; i < used; i++) {\n      topk_rowids[i] = tmp_topk_rowids[i];\n      topk_distances[i] = tmp_topk_distances[i];\n    }\n    k_used = used;\n    // blobVectors is always opened with read-only permissions, so this never\n    // fails.\n    sqlite3_blob_close(blobVectors);\n    blobVectors = NULL;\n  }\n\n  *out_topk_rowids = topk_rowids;\n  *out_topk_distances = topk_distances;\n  *out_used = k_used;\n  rc = SQLITE_OK;\n\ncleanup:\n  if (rc != SQLITE_OK) {\n    sqlite3_free(topk_rowids);\n    sqlite3_free(topk_distances);\n  }\n  sqlite3_free(chunk_topk_idxs);\n  sqlite3_free(tmp_topk_rowids);\n  sqlite3_free(tmp_topk_distances);\n  sqlite3_free(b);\n  sqlite3_free(bTaken);\n  sqlite3_free(bmRowids);\n  sqlite3_free(baseVectors);\n  sqlite3_free(chunk_distances);\n  sqlite3_free(bmMetadata);\n  for(int i = 0; i < VEC0_MAX_METADATA_COLUMNS; i++) {\n    sqlite3_blob_close(metadataBlobs[i]);\n  }\n  // blobVectors is always opened with read-only permissions, so this never\n  // fails.\n  sqlite3_blob_close(blobVectors);\n  return rc;\n}\n\nint vec0Filter_knn(vec0_cursor *pCur, vec0_vtab *p, int idxNum,\n                   const char *idxStr, int argc, sqlite3_value **argv) {\n  assert(argc == (strlen(idxStr)-1) / 4);\n  int rc;\n  struct vec0_query_knn_data *knn_data;\n\n  int vectorColumnIdx = idxNum;\n  struct VectorColumnDefinition *vector_column =\n      &p->vector_columns[vectorColumnIdx];\n\n  struct Array *arrayRowidsIn = NULL;\n  sqlite3_stmt *stmtChunks = NULL;\n  void *queryVector;\n  size_t dimensions;\n  enum VectorElementType elementType;\n  vector_cleanup queryVectorCleanup = vector_cleanup_noop;\n  char *pzError;\n  knn_data = sqlite3_malloc(sizeof(*knn_data));\n  if (!knn_data) {\n    return SQLITE_NOMEM;\n  }\n  memset(knn_data, 0, sizeof(*knn_data));\n  // array of `struct Vec0MetadataIn`, IF there are any `xxx in (...)` metadata constraints\n  struct Array * aMetadataIn = NULL;\n\n  int query_idx =-1;\n  int k_idx = -1;\n  int rowid_in_idx = -1;\n  for(int i = 0; i < argc; i++) {\n    if(idxStr[1 + (i*4)] == VEC0_IDXSTR_KIND_KNN_MATCH) {\n      query_idx = i;\n    }\n    if(idxStr[1 + (i*4)] == VEC0_IDXSTR_KIND_KNN_K) {\n      k_idx = i;\n    }\n    if(idxStr[1 + (i*4)] == VEC0_IDXSTR_KIND_KNN_ROWID_IN) {\n      rowid_in_idx = i;\n    }\n  }\n  assert(query_idx >= 0);\n  assert(k_idx >= 0);\n\n  // make sure the query vector matches the vector column (type dimensions etc.)\n  rc = vector_from_value(argv[query_idx], &queryVector, &dimensions, &elementType,\n                         &queryVectorCleanup, &pzError);\n\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&p->base,\n                   \"Query vector on the \\\"%.*s\\\" column is invalid: %z\",\n                   vector_column->name_length, vector_column->name, pzError);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  if (elementType != vector_column->element_type) {\n    vtab_set_error(\n        &p->base,\n        \"Query vector for the \\\"%.*s\\\" column is expected to be of type \"\n        \"%s, but a %s vector was provided.\",\n        vector_column->name_length, vector_column->name,\n        vector_subtype_name(vector_column->element_type),\n        vector_subtype_name(elementType));\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  if (dimensions != vector_column->dimensions) {\n    vtab_set_error(\n        &p->base,\n        \"Dimension mismatch for query vector for the \\\"%.*s\\\" column. \"\n        \"Expected %d dimensions but received %d.\",\n        vector_column->name_length, vector_column->name,\n        vector_column->dimensions, dimensions);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  i64 k = sqlite3_value_int64(argv[k_idx]);\n  if (k < 0) {\n    vtab_set_error(\n        &p->base, \"k value in knn queries must be greater than or equal to 0.\");\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n#define SQLITE_VEC_VEC0_K_MAX 4096\n  if (k > SQLITE_VEC_VEC0_K_MAX) {\n    vtab_set_error(\n        &p->base,\n        \"k value in knn query too large, provided %lld and the limit is %lld\",\n        k, SQLITE_VEC_VEC0_K_MAX);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  if (k == 0) {\n    knn_data->k = 0;\n    pCur->knn_data = knn_data;\n    pCur->query_plan = VEC0_QUERY_PLAN_KNN;\n    rc = SQLITE_OK;\n    goto cleanup;\n  }\n\n// handle when a `rowid in (...)` operation was provided\n// Array of all the rowids that appear in any `rowid in (...)` constraint.\n// NULL if none were provided, which means a \"full\" scan.\n#if COMPILER_SUPPORTS_VTAB_IN\n  if (rowid_in_idx >= 0) {\n    sqlite3_value *item;\n    int rc;\n    arrayRowidsIn = sqlite3_malloc(sizeof(*arrayRowidsIn));\n    if (!arrayRowidsIn) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    memset(arrayRowidsIn, 0, sizeof(*arrayRowidsIn));\n\n    rc = array_init(arrayRowidsIn, sizeof(i64), 32);\n    if (rc != SQLITE_OK) {\n      goto cleanup;\n    }\n    for (rc = sqlite3_vtab_in_first(argv[rowid_in_idx], &item); rc == SQLITE_OK && item;\n         rc = sqlite3_vtab_in_next(argv[rowid_in_idx], &item)) {\n      i64 rowid;\n      if (p->pkIsText) {\n        rc = vec0_rowid_from_id(p, item, &rowid);\n        if (rc != SQLITE_OK) {\n          goto cleanup;\n        }\n      } else {\n        rowid = sqlite3_value_int64(item);\n      }\n      rc = array_append(arrayRowidsIn, &rowid);\n      if (rc != SQLITE_OK) {\n        goto cleanup;\n      }\n    }\n    if (rc != SQLITE_DONE) {\n      vtab_set_error(&p->base, \"error processing rowid in (...) array\");\n      goto cleanup;\n    }\n    qsort(arrayRowidsIn->z, arrayRowidsIn->length, arrayRowidsIn->element_size,\n          _cmp);\n  }\n#endif\n\n  #if COMPILER_SUPPORTS_VTAB_IN\n  for(int i = 0; i < argc; i++) {\n    if(!(idxStr[1 + (i*4)] == VEC0_IDXSTR_KIND_METADATA_CONSTRAINT && idxStr[1 + (i*4) + 2] == VEC0_METADATA_OPERATOR_IN)) {\n      continue;\n    }\n    int metadata_idx = idxStr[1 + (i*4) + 1]  - 'A';\n    if(!aMetadataIn) {\n      aMetadataIn = sqlite3_malloc(sizeof(*aMetadataIn));\n      if(!aMetadataIn) {\n        rc = SQLITE_NOMEM;\n        goto cleanup;\n      }\n      memset(aMetadataIn, 0, sizeof(*aMetadataIn));\n      rc = array_init(aMetadataIn, sizeof(struct Vec0MetadataIn), 8);\n      if(rc != SQLITE_OK) {\n        goto cleanup;\n      }\n    }\n\n    struct Vec0MetadataIn item;\n    memset(&item, 0, sizeof(item));\n    item.metadata_idx=metadata_idx;\n    item.argv_idx = i;\n\n    switch(p->metadata_columns[metadata_idx].kind) {\n      case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n        rc = array_init(&item.array, sizeof(i64), 16);\n        if(rc != SQLITE_OK) {\n          goto cleanup;\n        }\n        sqlite3_value *entry;\n        for (rc = sqlite3_vtab_in_first(argv[i], &entry); rc == SQLITE_OK && entry; rc = sqlite3_vtab_in_next(argv[i], &entry)) {\n          i64 v = sqlite3_value_int64(entry);\n          rc = array_append(&item.array, &v);\n          if (rc != SQLITE_OK) {\n            goto cleanup;\n          }\n        }\n\n        if (rc != SQLITE_DONE) {\n          vtab_set_error(&p->base, \"Error fetching next value in `x in (...)` integer expression\");\n          goto cleanup;\n        }\n\n        break;\n      }\n      case VEC0_METADATA_COLUMN_KIND_TEXT: {\n        rc = array_init(&item.array, sizeof(struct Vec0MetadataInTextEntry), 16);\n        if(rc != SQLITE_OK) {\n          goto cleanup;\n        }\n        sqlite3_value *entry;\n        for (rc = sqlite3_vtab_in_first(argv[i], &entry); rc == SQLITE_OK && entry; rc = sqlite3_vtab_in_next(argv[i], &entry)) {\n          const char * s = (const char *) sqlite3_value_text(entry);\n          int n = sqlite3_value_bytes(entry);\n\n          struct Vec0MetadataInTextEntry entry;\n          entry.zString = sqlite3_mprintf(\"%.*s\", n, s);\n          if(!entry.zString) {\n            rc = SQLITE_NOMEM;\n            goto cleanup;\n          }\n          entry.n = n;\n          rc = array_append(&item.array, &entry);\n          if (rc != SQLITE_OK) {\n            goto cleanup;\n          }\n        }\n\n        if (rc != SQLITE_DONE) {\n          vtab_set_error(&p->base, \"Error fetching next value in `x in (...)` text expression\");\n          goto cleanup;\n        }\n\n        break;\n      }\n      default: {\n        vtab_set_error(&p->base, \"Internal sqlite-vec error\");\n        goto cleanup;\n      }\n    }\n\n    rc = array_append(aMetadataIn, &item);\n    if(rc != SQLITE_OK) {\n      goto cleanup;\n    }\n  }\n  #endif\n\n  rc = vec0_chunks_iter(p, idxStr, argc, argv, &stmtChunks);\n  if (rc != SQLITE_OK) {\n    // IMP: V06942_23781\n    vtab_set_error(&p->base, \"Error preparing stmtChunk: %s\",\n                   sqlite3_errmsg(p->db));\n    goto cleanup;\n  }\n\n  i64 *topk_rowids = NULL;\n  f32 *topk_distances = NULL;\n  i64 k_used = 0;\n  rc = vec0Filter_knn_chunks_iter(p, stmtChunks, vector_column, vectorColumnIdx,\n                                  arrayRowidsIn, aMetadataIn, idxStr, argc, argv, queryVector, k, &topk_rowids,\n                                  &topk_distances, &k_used);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  knn_data->current_idx = 0;\n  knn_data->k = k;\n  knn_data->rowids = topk_rowids;\n  knn_data->distances = topk_distances;\n  knn_data->k_used = k_used;\n\n  pCur->knn_data = knn_data;\n  pCur->query_plan = VEC0_QUERY_PLAN_KNN;\n  rc = SQLITE_OK;\n\ncleanup:\n  sqlite3_finalize(stmtChunks);\n  array_cleanup(arrayRowidsIn);\n  sqlite3_free(arrayRowidsIn);\n  queryVectorCleanup(queryVector);\n  if(aMetadataIn) {\n    for(size_t i = 0; i < aMetadataIn->length; i++) {\n      struct Vec0MetadataIn* item = &((struct Vec0MetadataIn *) aMetadataIn->z)[i];\n      for(size_t j = 0; j < item->array.length; j++) {\n        if(p->metadata_columns[item->metadata_idx].kind == VEC0_METADATA_COLUMN_KIND_TEXT) {\n          struct Vec0MetadataInTextEntry entry = ((struct Vec0MetadataInTextEntry*)item->array.z)[j];\n          sqlite3_free(entry.zString);\n        }\n      }\n      array_cleanup(&item->array);\n    }\n    array_cleanup(aMetadataIn);\n  }\n\n  sqlite3_free(aMetadataIn);\n\n  return rc;\n}\n\nint vec0Filter_fullscan(vec0_vtab *p, vec0_cursor *pCur) {\n  int rc;\n  char *zSql;\n  struct vec0_query_fullscan_data *fullscan_data;\n\n  fullscan_data = sqlite3_malloc(sizeof(*fullscan_data));\n  if (!fullscan_data) {\n    return SQLITE_NOMEM;\n  }\n  memset(fullscan_data, 0, sizeof(*fullscan_data));\n\n  zSql = sqlite3_mprintf(\" SELECT rowid \"\n                         \" FROM \" VEC0_SHADOW_ROWIDS_NAME\n                         \" ORDER by chunk_id, chunk_offset \",\n                         p->schemaName, p->tableName);\n  if (!zSql) {\n    rc = SQLITE_NOMEM;\n    goto error;\n  }\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &fullscan_data->rowids_stmt, NULL);\n  sqlite3_free(zSql);\n  if (rc != SQLITE_OK) {\n    // IMP: V09901_26739\n    vtab_set_error(&p->base, \"Error preparing rowid scan: %s\",\n                   sqlite3_errmsg(p->db));\n    goto error;\n  }\n\n  rc = sqlite3_step(fullscan_data->rowids_stmt);\n\n  // DONE when there's no rowids, ROW when there are, both \"success\"\n  if (!(rc == SQLITE_ROW || rc == SQLITE_DONE)) {\n    goto error;\n  }\n\n  fullscan_data->done = rc == SQLITE_DONE;\n  pCur->query_plan = VEC0_QUERY_PLAN_FULLSCAN;\n  pCur->fullscan_data = fullscan_data;\n  return SQLITE_OK;\n\nerror:\n  vec0_query_fullscan_data_clear(fullscan_data);\n  sqlite3_free(fullscan_data);\n  return rc;\n}\n\nint vec0Filter_point(vec0_cursor *pCur, vec0_vtab *p, int argc,\n                     sqlite3_value **argv) {\n  int rc;\n  assert(argc == 1);\n  i64 rowid;\n  struct vec0_query_point_data *point_data = NULL;\n\n  point_data = sqlite3_malloc(sizeof(*point_data));\n  if (!point_data) {\n    rc = SQLITE_NOMEM;\n    goto error;\n  }\n  memset(point_data, 0, sizeof(*point_data));\n\n  if (p->pkIsText) {\n    rc = vec0_rowid_from_id(p, argv[0], &rowid);\n    if (rc == SQLITE_EMPTY) {\n      goto eof;\n    }\n    if (rc != SQLITE_OK) {\n      goto error;\n    }\n  } else {\n    rowid = sqlite3_value_int64(argv[0]);\n  }\n\n  for (int i = 0; i < p->numVectorColumns; i++) {\n    rc = vec0_get_vector_data(p, rowid, i, &point_data->vectors[i], NULL);\n    if (rc == SQLITE_EMPTY) {\n      goto eof;\n    }\n    if (rc != SQLITE_OK) {\n      goto error;\n    }\n  }\n\n  point_data->rowid = rowid;\n  point_data->done = 0;\n  pCur->point_data = point_data;\n  pCur->query_plan = VEC0_QUERY_PLAN_POINT;\n  return SQLITE_OK;\n\neof:\n  point_data->rowid = rowid;\n  point_data->done = 1;\n  pCur->point_data = point_data;\n  pCur->query_plan = VEC0_QUERY_PLAN_POINT;\n  return SQLITE_OK;\n\nerror:\n  vec0_query_point_data_clear(point_data);\n  sqlite3_free(point_data);\n  return rc;\n}\n\nstatic int vec0Filter(sqlite3_vtab_cursor *pVtabCursor, int idxNum,\n                      const char *idxStr, int argc, sqlite3_value **argv) {\n  vec0_vtab *p = (vec0_vtab *)pVtabCursor->pVtab;\n  vec0_cursor *pCur = (vec0_cursor *)pVtabCursor;\n  vec0_cursor_clear(pCur);\n\n  int idxStrLength = strlen(idxStr);\n  if(idxStrLength <= 0) {\n    return SQLITE_ERROR;\n  }\n  if((idxStrLength-1) % 4 != 0) {\n    return SQLITE_ERROR;\n  }\n  int numValueEntries = (idxStrLength-1) / 4;\n  if(numValueEntries != argc) {\n    return SQLITE_ERROR;\n  }\n\n  char query_plan = idxStr[0];\n  switch(query_plan) {\n    case VEC0_QUERY_PLAN_FULLSCAN:\n      return vec0Filter_fullscan(p, pCur);\n    case VEC0_QUERY_PLAN_KNN:\n      return vec0Filter_knn(pCur, p, idxNum, idxStr, argc, argv);\n    case VEC0_QUERY_PLAN_POINT:\n      return vec0Filter_point(pCur, p, argc, argv);\n    default:\n      vtab_set_error(pVtabCursor->pVtab, \"unknown idxStr '%s'\", idxStr);\n      return SQLITE_ERROR;\n  }\n}\n\nstatic int vec0Rowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid) {\n  vec0_cursor *pCur = (vec0_cursor *)cur;\n  switch (pCur->query_plan) {\n  case VEC0_QUERY_PLAN_FULLSCAN: {\n    *pRowid = sqlite3_column_int64(pCur->fullscan_data->rowids_stmt, 0);\n    return SQLITE_OK;\n  }\n  case VEC0_QUERY_PLAN_POINT: {\n    *pRowid = pCur->point_data->rowid;\n    return SQLITE_OK;\n  }\n  case VEC0_QUERY_PLAN_KNN: {\n    vtab_set_error(cur->pVtab,\n                   \"Internal sqlite-vec error: expected point query plan in \"\n                   \"vec0Rowid, found %d\",\n                   pCur->query_plan);\n    return SQLITE_ERROR;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec0Next(sqlite3_vtab_cursor *cur) {\n  vec0_cursor *pCur = (vec0_cursor *)cur;\n  switch (pCur->query_plan) {\n  case VEC0_QUERY_PLAN_FULLSCAN: {\n    if (!pCur->fullscan_data) {\n      return SQLITE_ERROR;\n    }\n    int rc = sqlite3_step(pCur->fullscan_data->rowids_stmt);\n    if (rc == SQLITE_DONE) {\n      pCur->fullscan_data->done = 1;\n      return SQLITE_OK;\n    }\n    if (rc == SQLITE_ROW) {\n      return SQLITE_OK;\n    }\n    return SQLITE_ERROR;\n  }\n  case VEC0_QUERY_PLAN_KNN: {\n    if (!pCur->knn_data) {\n      return SQLITE_ERROR;\n    }\n\n    pCur->knn_data->current_idx++;\n    return SQLITE_OK;\n  }\n  case VEC0_QUERY_PLAN_POINT: {\n    if (!pCur->point_data) {\n      return SQLITE_ERROR;\n    }\n    pCur->point_data->done = 1;\n    return SQLITE_OK;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec0Eof(sqlite3_vtab_cursor *cur) {\n  vec0_cursor *pCur = (vec0_cursor *)cur;\n  switch (pCur->query_plan) {\n  case VEC0_QUERY_PLAN_FULLSCAN: {\n    if (!pCur->fullscan_data) {\n      return 1;\n    }\n    return pCur->fullscan_data->done;\n  }\n  case VEC0_QUERY_PLAN_KNN: {\n    if (!pCur->knn_data) {\n      return 1;\n    }\n    // return (pCur->knn_data->current_idx >= pCur->knn_data->k) ||\n    // (pCur->knn_data->distances[pCur->knn_data->current_idx] == FLT_MAX);\n    return (pCur->knn_data->current_idx >= pCur->knn_data->k_used);\n  }\n  case VEC0_QUERY_PLAN_POINT: {\n    if (!pCur->point_data) {\n      return 1;\n    }\n    return pCur->point_data->done;\n  }\n  }\n  return 1;\n}\n\nstatic int vec0Column_fullscan(vec0_vtab *pVtab, vec0_cursor *pCur,\n                               sqlite3_context *context, int i) {\n  if (!pCur->fullscan_data) {\n    sqlite3_result_error(\n        context, \"Internal sqlite-vec error: fullscan_data is NULL.\", -1);\n    return SQLITE_ERROR;\n  }\n  i64 rowid = sqlite3_column_int64(pCur->fullscan_data->rowids_stmt, 0);\n  if (i == VEC0_COLUMN_ID) {\n    return vec0_result_id(pVtab, context, rowid);\n  }\n  else if (vec0_column_idx_is_vector(pVtab, i)) {\n    void *v;\n    int sz;\n    int vector_idx = vec0_column_idx_to_vector_idx(pVtab, i);\n    int rc = vec0_get_vector_data(pVtab, rowid, vector_idx, &v, &sz);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n    sqlite3_result_blob(context, v, sz, sqlite3_free);\n    sqlite3_result_subtype(context,\n                           pVtab->vector_columns[vector_idx].element_type);\n\n  }\n  else if (i == vec0_column_distance_idx(pVtab)) {\n    sqlite3_result_null(context);\n  }\n  else if(vec0_column_idx_is_partition(pVtab, i)) {\n    int partition_idx = vec0_column_idx_to_partition_idx(pVtab, i);\n    sqlite3_value * v;\n    int rc = vec0_get_partition_value_for_rowid(pVtab, rowid, partition_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n  else if(vec0_column_idx_is_auxiliary(pVtab, i)) {\n    int auxiliary_idx = vec0_column_idx_to_auxiliary_idx(pVtab, i);\n    sqlite3_value * v;\n    int rc = vec0_get_auxiliary_value_for_rowid(pVtab, rowid, auxiliary_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n\n  else if(vec0_column_idx_is_metadata(pVtab, i)) {\n    if(sqlite3_vtab_nochange(context)) {\n      return SQLITE_OK;\n    }\n    int metadata_idx = vec0_column_idx_to_metadata_idx(pVtab, i);\n    int rc = vec0_result_metadata_value_for_rowid(pVtab, rowid, metadata_idx, context);\n    if(rc != SQLITE_OK) {\n      // IMP: V15466_32305\n      const char * zErr = sqlite3_mprintf(\n        \"Could not extract metadata value for column %.*s at rowid %lld\",\n        pVtab->metadata_columns[metadata_idx].name_length,\n        pVtab->metadata_columns[metadata_idx].name, rowid\n      );\n      if(zErr) {\n        sqlite3_result_error(context, zErr, -1);\n        sqlite3_free((void *) zErr);\n      }else {\n        sqlite3_result_error_nomem(context);\n      }\n    }\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int vec0Column_point(vec0_vtab *pVtab, vec0_cursor *pCur,\n                            sqlite3_context *context, int i) {\n  if (!pCur->point_data) {\n    sqlite3_result_error(context,\n                         \"Internal sqlite-vec error: point_data is NULL.\", -1);\n    return SQLITE_ERROR;\n  }\n  if (i == VEC0_COLUMN_ID) {\n    return vec0_result_id(pVtab, context, pCur->point_data->rowid);\n  }\n  else if (i == vec0_column_distance_idx(pVtab)) {\n    sqlite3_result_null(context);\n    return SQLITE_OK;\n  }\n  else if (vec0_column_idx_is_vector(pVtab, i)) {\n    if (sqlite3_vtab_nochange(context)) {\n      sqlite3_result_null(context);\n      return SQLITE_OK;\n    }\n    int vector_idx = vec0_column_idx_to_vector_idx(pVtab, i);\n    sqlite3_result_blob(\n        context, pCur->point_data->vectors[vector_idx],\n        vector_column_byte_size(pVtab->vector_columns[vector_idx]),\n        SQLITE_TRANSIENT);\n    sqlite3_result_subtype(context,\n                           pVtab->vector_columns[vector_idx].element_type);\n    return SQLITE_OK;\n  }\n  else if(vec0_column_idx_is_partition(pVtab, i)) {\n    if(sqlite3_vtab_nochange(context)) {\n      return SQLITE_OK;\n    }\n    int partition_idx = vec0_column_idx_to_partition_idx(pVtab, i);\n    i64 rowid = pCur->point_data->rowid;\n    sqlite3_value * v;\n    int rc = vec0_get_partition_value_for_rowid(pVtab, rowid, partition_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n  else if(vec0_column_idx_is_auxiliary(pVtab, i)) {\n    if(sqlite3_vtab_nochange(context)) {\n      return SQLITE_OK;\n    }\n    i64 rowid = pCur->point_data->rowid;\n    int auxiliary_idx = vec0_column_idx_to_auxiliary_idx(pVtab, i);\n    sqlite3_value * v;\n    int rc = vec0_get_auxiliary_value_for_rowid(pVtab, rowid, auxiliary_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n\n  else if(vec0_column_idx_is_metadata(pVtab, i)) {\n    if(sqlite3_vtab_nochange(context)) {\n      return SQLITE_OK;\n    }\n    i64 rowid = pCur->point_data->rowid;\n    int metadata_idx = vec0_column_idx_to_metadata_idx(pVtab, i);\n    int rc = vec0_result_metadata_value_for_rowid(pVtab, rowid, metadata_idx, context);\n    if(rc != SQLITE_OK) {\n      const char * zErr = sqlite3_mprintf(\n        \"Could not extract metadata value for column %.*s at rowid %lld\",\n        pVtab->metadata_columns[metadata_idx].name_length,\n        pVtab->metadata_columns[metadata_idx].name, rowid\n      );\n      if(zErr) {\n        sqlite3_result_error(context, zErr, -1);\n        sqlite3_free((void *) zErr);\n      }else {\n        sqlite3_result_error_nomem(context);\n      }\n    }\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int vec0Column_knn(vec0_vtab *pVtab, vec0_cursor *pCur,\n                          sqlite3_context *context, int i) {\n  if (!pCur->knn_data) {\n    sqlite3_result_error(context,\n                         \"Internal sqlite-vec error: knn_data is NULL.\", -1);\n    return SQLITE_ERROR;\n  }\n  if (i == VEC0_COLUMN_ID) {\n    i64 rowid = pCur->knn_data->rowids[pCur->knn_data->current_idx];\n    return vec0_result_id(pVtab, context, rowid);\n  }\n  else if (i == vec0_column_distance_idx(pVtab)) {\n    sqlite3_result_double(\n        context, pCur->knn_data->distances[pCur->knn_data->current_idx]);\n    return SQLITE_OK;\n  }\n  else if (vec0_column_idx_is_vector(pVtab, i)) {\n    void *out;\n    int sz;\n    int vector_idx = vec0_column_idx_to_vector_idx(pVtab, i);\n    int rc = vec0_get_vector_data(\n        pVtab, pCur->knn_data->rowids[pCur->knn_data->current_idx], vector_idx,\n        &out, &sz);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n    sqlite3_result_blob(context, out, sz, sqlite3_free);\n    sqlite3_result_subtype(context,\n                           pVtab->vector_columns[vector_idx].element_type);\n    return SQLITE_OK;\n  }\n  else if(vec0_column_idx_is_partition(pVtab, i)) {\n    int partition_idx = vec0_column_idx_to_partition_idx(pVtab, i);\n    i64 rowid = pCur->knn_data->rowids[pCur->knn_data->current_idx];\n    sqlite3_value * v;\n    int rc = vec0_get_partition_value_for_rowid(pVtab, rowid, partition_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n  else if(vec0_column_idx_is_auxiliary(pVtab, i)) {\n    int auxiliary_idx = vec0_column_idx_to_auxiliary_idx(pVtab, i);\n    i64 rowid = pCur->knn_data->rowids[pCur->knn_data->current_idx];\n    sqlite3_value * v;\n    int rc = vec0_get_auxiliary_value_for_rowid(pVtab, rowid, auxiliary_idx, &v);\n    if(rc == SQLITE_OK) {\n      sqlite3_result_value(context, v);\n      sqlite3_value_free(v);\n    }else {\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n\n  else if(vec0_column_idx_is_metadata(pVtab, i)) {\n    int metadata_idx = vec0_column_idx_to_metadata_idx(pVtab, i);\n    i64 rowid = pCur->knn_data->rowids[pCur->knn_data->current_idx];\n    int rc = vec0_result_metadata_value_for_rowid(pVtab, rowid, metadata_idx, context);\n    if(rc != SQLITE_OK) {\n      const char * zErr = sqlite3_mprintf(\n        \"Could not extract metadata value for column %.*s at rowid %lld\",\n        pVtab->metadata_columns[metadata_idx].name_length,\n        pVtab->metadata_columns[metadata_idx].name, rowid\n      );\n      if(zErr) {\n        sqlite3_result_error(context, zErr, -1);\n        sqlite3_free((void *) zErr);\n      }else {\n        sqlite3_result_error_nomem(context);\n      }\n    }\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int vec0Column(sqlite3_vtab_cursor *cur, sqlite3_context *context,\n                      int i) {\n  vec0_cursor *pCur = (vec0_cursor *)cur;\n  vec0_vtab *pVtab = (vec0_vtab *)cur->pVtab;\n  switch (pCur->query_plan) {\n  case VEC0_QUERY_PLAN_FULLSCAN: {\n    return vec0Column_fullscan(pVtab, pCur, context, i);\n  }\n  case VEC0_QUERY_PLAN_KNN: {\n    return vec0Column_knn(pVtab, pCur, context, i);\n  }\n  case VEC0_QUERY_PLAN_POINT: {\n    return vec0Column_point(pVtab, pCur, context, i);\n  }\n  }\n  return SQLITE_OK;\n}\n\n/**\n * @brief Handles the \"insert rowid\" step of a row insert operation of a vec0\n * table.\n *\n * This function will insert a new row into the _rowids vec0 shadow table.\n *\n * @param p: virtual table\n * @param idValue: Value containing the inserted rowid/id value.\n * @param rowid: Output rowid, will point to the \"real\" i64 rowid\n * value that was inserted\n * @return int SQLITE_OK on success, error code on failure\n */\nint vec0Update_InsertRowidStep(vec0_vtab *p, sqlite3_value *idValue,\n                               i64 *rowid) {\n\n  /**\n   * An insert into a vec0 table can happen a few different ways:\n   *  1) With default INTEGER primary key: With a supplied i64 rowid\n   *  2) With default INTEGER primary key: WITHOUT a supplied rowid\n   *  3) With TEXT primary key: supplied text rowid\n   */\n\n  int rc;\n\n  // Option 3: vtab has a user-defined TEXT primary key, so ensure a text value\n  // is provided.\n  if (p->pkIsText) {\n    if (sqlite3_value_type(idValue) != SQLITE_TEXT) {\n      // IMP: V04200_21039\n      vtab_set_error(&p->base,\n                     \"The %s virtual table was declared with a TEXT primary \"\n                     \"key, but a non-TEXT value was provided in an INSERT.\",\n                     p->tableName);\n      return SQLITE_ERROR;\n    }\n\n    return vec0_rowids_insert_id(p, idValue, rowid);\n  }\n\n  // Option 1: User supplied a i64 rowid\n  if (sqlite3_value_type(idValue) == SQLITE_INTEGER) {\n    i64 suppliedRowid = sqlite3_value_int64(idValue);\n    rc = vec0_rowids_insert_rowid(p, suppliedRowid);\n    if (rc == SQLITE_OK) {\n      *rowid = suppliedRowid;\n    }\n    return rc;\n  }\n\n  // Option 2: User did not suppled a rowid\n\n  if (sqlite3_value_type(idValue) != SQLITE_NULL) {\n    // IMP: V30855_14925\n    vtab_set_error(&p->base,\n                   \"Only integers are allows for primary key values on %s\",\n                   p->tableName);\n    return SQLITE_ERROR;\n  }\n  // NULL to get next auto-incremented value\n  return vec0_rowids_insert_id(p, NULL, rowid);\n}\n\n/**\n * @brief Determines the \"next available\" chunk position for a newly inserted\n * vec0 row.\n *\n * This operation may insert a new \"blank\" chunk the _chunks table, if there is\n * no more space in previous chunks.\n *\n * @param p: virtual table\n * @param partitionKeyValues: array of partition key column values, to constrain\n * against any partition key columns.\n * @param chunk_rowid: Output rowid of the chunk in the _chunks virtual table\n * that has the avialabiity.\n * @param chunk_offset: Output the index of the available space insert the\n * chunk, based on the index of the first available validity bit.\n * @param pBlobValidity: Output blob of the validity column of the available\n * chunk. Will be opened with read/write permissions.\n * @param pValidity: Output buffer of the original chunk's validity column.\n *    Needs to be cleaned up with sqlite3_free().\n * @return int SQLITE_OK on success, error code on failure\n */\nint vec0Update_InsertNextAvailableStep(\n    vec0_vtab *p,\n    sqlite3_value ** partitionKeyValues,\n    i64 *chunk_rowid, i64 *chunk_offset,\n    sqlite3_blob **blobChunksValidity,\n    const unsigned char **bufferChunksValidity) {\n\n  int rc;\n  i64 validitySize;\n  *chunk_offset = -1;\n\n  rc = vec0_get_latest_chunk_rowid(p, chunk_rowid, partitionKeyValues);\n  if(rc == SQLITE_EMPTY) {\n    goto done;\n  }\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowChunksName, \"validity\",\n                         *chunk_rowid, 1, blobChunksValidity);\n  if (rc != SQLITE_OK) {\n    // IMP: V22053_06123\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR\n                   \"could not open validity blob on %s.%s.%lld\",\n                   p->schemaName, p->shadowChunksName, *chunk_rowid);\n    goto cleanup;\n  }\n\n  validitySize = sqlite3_blob_bytes(*blobChunksValidity);\n  if (validitySize != p->chunk_size / CHAR_BIT) {\n    // IMP: V29362_13432\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR\n                   \"validity blob size mismatch on \"\n                   \"%s.%s.%lld, expected %lld but received %lld.\",\n                   p->schemaName, p->shadowChunksName, *chunk_rowid,\n                   (i64)(p->chunk_size / CHAR_BIT), validitySize);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  *bufferChunksValidity = sqlite3_malloc(validitySize);\n  if (!(*bufferChunksValidity)) {\n    vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                   \"Could not allocate memory for validity bitmap\");\n    rc = SQLITE_NOMEM;\n    goto cleanup;\n  }\n\n  rc = sqlite3_blob_read(*blobChunksValidity, (void *)*bufferChunksValidity,\n                         validitySize, 0);\n\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR\n                   \"Could not read validity bitmap for %s.%s.%lld\",\n                   p->schemaName, p->shadowChunksName, *chunk_rowid);\n    goto cleanup;\n  }\n\n  // find the next available offset, ie first `0` in the bitmap.\n  for (int i = 0; i < validitySize; i++) {\n    if ((*bufferChunksValidity)[i] == 0b11111111)\n      continue;\n    for (int j = 0; j < CHAR_BIT; j++) {\n      if (((((*bufferChunksValidity)[i] >> j) & 1) == 0)) {\n        *chunk_offset = (i * CHAR_BIT) + j;\n        goto done;\n      }\n    }\n  }\n\ndone:\n  // latest chunk was full, so need to create a new one\n  if (*chunk_offset == -1) {\n    rc = vec0_new_chunk(p, partitionKeyValues, chunk_rowid);\n    if (rc != SQLITE_OK) {\n      // IMP: V08441_25279\n      vtab_set_error(&p->base,\n                     VEC_INTERAL_ERROR \"Could not insert a new vector chunk\");\n      rc = SQLITE_ERROR; // otherwise raises a DatabaseError and not operational\n                         // error?\n      goto cleanup;\n    }\n    *chunk_offset = 0;\n\n    // blobChunksValidity and pValidity are stale, pointing to the previous\n    // (full) chunk. to re-assign them\n    rc = sqlite3_blob_close(*blobChunksValidity);\n    sqlite3_free((void *)*bufferChunksValidity);\n    *blobChunksValidity = NULL;\n    *bufferChunksValidity = NULL;\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, VEC_INTERAL_ERROR\n                     \"unknown error, blobChunksValidity could not be closed, \"\n                     \"please file an issue.\");\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowChunksName,\n                           \"validity\", *chunk_rowid, 1, blobChunksValidity);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(\n          &p->base,\n          VEC_INTERAL_ERROR\n          \"Could not open validity blob for newly created chunk %s.%s.%lld\",\n          p->schemaName, p->shadowChunksName, *chunk_rowid);\n      goto cleanup;\n    }\n    validitySize = sqlite3_blob_bytes(*blobChunksValidity);\n    if (validitySize != p->chunk_size / CHAR_BIT) {\n      vtab_set_error(&p->base,\n                     VEC_INTERAL_ERROR\n                     \"validity blob size mismatch for newly created chunk \"\n                     \"%s.%s.%lld. Exepcted %lld, got %lld\",\n                     p->schemaName, p->shadowChunksName, *chunk_rowid,\n                     p->chunk_size / CHAR_BIT, validitySize);\n      goto cleanup;\n    }\n    *bufferChunksValidity = sqlite3_malloc(validitySize);\n    rc = sqlite3_blob_read(*blobChunksValidity, (void *)*bufferChunksValidity,\n                           validitySize, 0);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base,\n                     VEC_INTERAL_ERROR\n                     \"could not read validity blob newly created chunk \"\n                     \"%s.%s.%lld\",\n                     p->schemaName, p->shadowChunksName, *chunk_rowid);\n      goto cleanup;\n    }\n  }\n\n  rc = SQLITE_OK;\n\ncleanup:\n  return rc;\n}\n\n/**\n * @brief Write the vector data into the provided vector blob at the given\n * offset\n *\n * @param blobVectors SQLite BLOB to write to\n * @param chunk_offset the \"offset\" (ie validity bitmap position) to write the\n * vector to\n * @param bVector pointer to the vector containing data\n * @param dimensions how many dimensions the vector has\n * @param element_type the vector type\n * @return result of sqlite3_blob_write, SQLITE_OK on success, otherwise failure\n */\nstatic int\nvec0_write_vector_to_vector_blob(sqlite3_blob *blobVectors, i64 chunk_offset,\n                                 const void *bVector, size_t dimensions,\n                                 enum VectorElementType element_type) {\n  int n;\n  int offset;\n\n  switch (element_type) {\n  case SQLITE_VEC_ELEMENT_TYPE_FLOAT32:\n    n = dimensions * sizeof(f32);\n    offset = chunk_offset * dimensions * sizeof(f32);\n    break;\n  case SQLITE_VEC_ELEMENT_TYPE_INT8:\n    n = dimensions * sizeof(i8);\n    offset = chunk_offset * dimensions * sizeof(i8);\n    break;\n  case SQLITE_VEC_ELEMENT_TYPE_BIT:\n    n = dimensions / CHAR_BIT;\n    offset = chunk_offset * dimensions / CHAR_BIT;\n    break;\n  }\n\n  return sqlite3_blob_write(blobVectors, bVector, n, offset);\n}\n\n/**\n * @brief\n *\n * @param p vec0 virtual table\n * @param chunk_rowid: which chunk to write to\n * @param chunk_offset: the offset inside the chunk to write the vector to.\n * @param rowid: the rowid of the inserting row\n * @param vectorDatas: array of the vector data to insert\n * @param blobValidity: writeable validity blob of the row's assigned chunk.\n * @param validity: snapshot buffer of the valdity column from the row's\n * assigned chunk.\n * @return int SQLITE_OK on success, error code on failure\n */\nint vec0Update_InsertWriteFinalStep(vec0_vtab *p, i64 chunk_rowid,\n                                    i64 chunk_offset, i64 rowid,\n                                    void *vectorDatas[],\n                                    sqlite3_blob *blobChunksValidity,\n                                    const unsigned char *bufferChunksValidity) {\n  int rc, brc;\n  sqlite3_blob *blobChunksRowids = NULL;\n\n  // mark the validity bit for this row in the chunk's validity bitmap\n  // Get the byte offset of the bitmap\n  char unsigned bx = bufferChunksValidity[chunk_offset / CHAR_BIT];\n  // set the bit at the chunk_offset position inside that byte\n  bx = bx | (1 << (chunk_offset % CHAR_BIT));\n  // write that 1 byte\n  rc = sqlite3_blob_write(blobChunksValidity, &bx, 1, chunk_offset / CHAR_BIT);\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&p->base, VEC_INTERAL_ERROR \"could not mark validity bit \");\n    return rc;\n  }\n\n  // Go insert the vector data into the vector chunk shadow tables\n  for (int i = 0; i < p->numVectorColumns; i++) {\n    sqlite3_blob *blobVectors;\n    rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowVectorChunksNames[i],\n                           \"vectors\", chunk_rowid, 1, &blobVectors);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base, \"Error opening vector blob at %s.%s.%lld\",\n                     p->schemaName, p->shadowVectorChunksNames[i], chunk_rowid);\n      goto cleanup;\n    }\n\n    i64 expected =\n        p->chunk_size * vector_column_byte_size(p->vector_columns[i]);\n    i64 actual = sqlite3_blob_bytes(blobVectors);\n\n    if (actual != expected) {\n      // IMP: V16386_00456\n      vtab_set_error(\n          &p->base,\n          VEC_INTERAL_ERROR\n          \"vector blob size mismatch on %s.%s.%lld. Expected %lld, actual %lld\",\n          p->schemaName, p->shadowVectorChunksNames[i], chunk_rowid, expected,\n          actual);\n      rc = SQLITE_ERROR;\n      // already error, can ignore result code\n      sqlite3_blob_close(blobVectors);\n      goto cleanup;\n    };\n\n    rc = vec0_write_vector_to_vector_blob(\n        blobVectors, chunk_offset, vectorDatas[i],\n        p->vector_columns[i].dimensions, p->vector_columns[i].element_type);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base,\n                     VEC_INTERAL_ERROR\n                     \"could not write vector blob on %s.%s.%lld\",\n                     p->schemaName, p->shadowVectorChunksNames[i], chunk_rowid);\n      rc = SQLITE_ERROR;\n      // already error, can ignore result code\n      sqlite3_blob_close(blobVectors);\n      goto cleanup;\n    }\n    rc = sqlite3_blob_close(blobVectors);\n    if (rc != SQLITE_OK) {\n      vtab_set_error(&p->base,\n                     VEC_INTERAL_ERROR\n                     \"could not close vector blob on %s.%s.%lld\",\n                     p->schemaName, p->shadowVectorChunksNames[i], chunk_rowid);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n  }\n\n  // write the new rowid to the rowids column of the _chunks table\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowChunksName, \"rowids\",\n                         chunk_rowid, 1, &blobChunksRowids);\n  if (rc != SQLITE_OK) {\n    // IMP: V09221_26060\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR \"could not open rowids blob on %s.%s.%lld\",\n                   p->schemaName, p->shadowChunksName, chunk_rowid);\n    goto cleanup;\n  }\n  i64 expected = p->chunk_size * sizeof(i64);\n  i64 actual = sqlite3_blob_bytes(blobChunksRowids);\n  if (expected != actual) {\n    // IMP: V12779_29618\n    vtab_set_error(\n        &p->base,\n        VEC_INTERAL_ERROR\n        \"rowids blob size mismatch on %s.%s.%lld. Expected %lld, actual %lld\",\n        p->schemaName, p->shadowChunksName, chunk_rowid, expected, actual);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  rc = sqlite3_blob_write(blobChunksRowids, &rowid, sizeof(i64),\n                          chunk_offset * sizeof(i64));\n  if (rc != SQLITE_OK) {\n    vtab_set_error(\n        &p->base, VEC_INTERAL_ERROR \"could not write rowids blob on %s.%s.%lld\",\n        p->schemaName, p->shadowChunksName, chunk_rowid);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  // Now with all the vectors inserted, go back and update the _rowids table\n  // with the new chunk_rowid/chunk_offset values\n  rc = vec0_rowids_update_position(p, rowid, chunk_rowid, chunk_offset);\n\ncleanup:\n  brc = sqlite3_blob_close(blobChunksRowids);\n  if ((rc == SQLITE_OK) && (brc != SQLITE_OK)) {\n    vtab_set_error(\n        &p->base, VEC_INTERAL_ERROR \"could not close rowids blob on %s.%s.%lld\",\n        p->schemaName, p->shadowChunksName, chunk_rowid);\n    return brc;\n  }\n  return rc;\n}\n\nint vec0_write_metadata_value(vec0_vtab *p, int metadata_column_idx, i64 rowid, i64 chunk_id, i64 chunk_offset, sqlite3_value * v, int isupdate) {\n  int rc;\n  struct Vec0MetadataColumnDefinition * metadata_column = &p->metadata_columns[metadata_column_idx];\n  vec0_metadata_column_kind kind = metadata_column->kind;\n\n  // verify input value matches column type\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      if(sqlite3_value_type(v) != SQLITE_INTEGER || ((sqlite3_value_int(v) != 0) && (sqlite3_value_int(v) != 1))) {\n        rc = SQLITE_ERROR;\n        vtab_set_error(&p->base, \"Expected 0 or 1 for BOOLEAN metadata column %.*s\", metadata_column->name_length, metadata_column->name);\n        goto done;\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      if(sqlite3_value_type(v) != SQLITE_INTEGER) {\n        rc = SQLITE_ERROR;\n        vtab_set_error(&p->base, \"Expected integer for INTEGER metadata column %.*s, received %s\", metadata_column->name_length, metadata_column->name, type_name(sqlite3_value_type(v)));\n        goto done;\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      if(sqlite3_value_type(v) != SQLITE_FLOAT) {\n        rc = SQLITE_ERROR;\n        vtab_set_error(&p->base, \"Expected float for FLOAT metadata column %.*s, received %s\", metadata_column->name_length, metadata_column->name, type_name(sqlite3_value_type(v)));\n        goto done;\n      }\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      if(sqlite3_value_type(v) != SQLITE_TEXT) {\n        rc = SQLITE_ERROR;\n        vtab_set_error(&p->base, \"Expected text for TEXT metadata column %.*s, received %s\", metadata_column->name_length, metadata_column->name, type_name(sqlite3_value_type(v)));\n        goto done;\n      }\n      break;\n    }\n  }\n\n  sqlite3_blob * blobValue = NULL;\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowMetadataChunksNames[metadata_column_idx], \"data\", chunk_id, 1, &blobValue);\n  if(rc != SQLITE_OK) {\n    goto done;\n  }\n\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      u8 block;\n      int value = sqlite3_value_int(v);\n      rc = sqlite3_blob_read(blobValue, &block, sizeof(u8), (int) (chunk_offset / CHAR_BIT));\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n\n      if (value) {\n        block |= 1 << (chunk_offset % CHAR_BIT);\n      } else {\n        block &= ~(1 << (chunk_offset % CHAR_BIT));\n      }\n\n      rc = sqlite3_blob_write(blobValue, &block, sizeof(u8), chunk_offset / CHAR_BIT);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      i64 value = sqlite3_value_int64(v);\n      rc = sqlite3_blob_write(blobValue, &value, sizeof(value), chunk_offset * sizeof(i64));\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      double value = sqlite3_value_double(v);\n      rc = sqlite3_blob_write(blobValue, &value, sizeof(value), chunk_offset * sizeof(double));\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      int prev_n;\n      rc = sqlite3_blob_read(blobValue, &prev_n, sizeof(int), chunk_offset * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n\n      const char * s = (const char *) sqlite3_value_text(v);\n      int n = sqlite3_value_bytes(v);\n      u8 view[VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n      memset(view, 0, VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      memcpy(view, &n, sizeof(int));\n      memcpy(view+4, s, min(n, VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH-4));\n\n      rc = sqlite3_blob_write(blobValue, &view, VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH, chunk_offset * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      if(n > VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n        const char * zSql;\n\n        if(isupdate && (prev_n > VEC0_METADATA_TEXT_VIEW_DATA_LENGTH)) {\n          zSql = sqlite3_mprintf(\"UPDATE \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" SET data = ?2 WHERE rowid = ?1\", p->schemaName, p->tableName, metadata_column_idx);\n        }else {\n          zSql = sqlite3_mprintf(\"INSERT INTO \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" (rowid, data) VALUES (?1, ?2)\", p->schemaName, p->tableName, metadata_column_idx);\n        }\n        if(!zSql) {\n          rc = SQLITE_NOMEM;\n          goto done;\n        }\n        sqlite3_stmt * stmt;\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        sqlite3_bind_int64(stmt, 1, rowid);\n        sqlite3_bind_text(stmt, 2, s, n, SQLITE_STATIC);\n        rc = sqlite3_step(stmt);\n        sqlite3_finalize(stmt);\n\n        if(rc != SQLITE_DONE) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n      }\n      else if(prev_n > VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n        const char * zSql = sqlite3_mprintf(\"DELETE FROM \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" WHERE rowid = ?\", p->schemaName, p->tableName, metadata_column_idx);\n        if(!zSql) {\n          rc = SQLITE_NOMEM;\n          goto done;\n        }\n        sqlite3_stmt * stmt;\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        sqlite3_bind_int64(stmt, 1, rowid);\n        rc = sqlite3_step(stmt);\n        sqlite3_finalize(stmt);\n\n        if(rc != SQLITE_DONE) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n      }\n      break;\n    }\n  }\n\n  if(rc != SQLITE_OK) {\n\n  }\n  rc = sqlite3_blob_close(blobValue);\n  if(rc != SQLITE_OK) {\n    goto done;\n  }\n\n  done:\n    return rc;\n}\n\n\n/**\n * @brief Handles INSERT INTO operations on a vec0 table.\n *\n * @return int SQLITE_OK on success, otherwise error code on failure\n */\nint vec0Update_Insert(sqlite3_vtab *pVTab, int argc, sqlite3_value **argv,\n                      sqlite_int64 *pRowid) {\n  UNUSED_PARAMETER(argc);\n  vec0_vtab *p = (vec0_vtab *)pVTab;\n  int rc;\n  // Rowid for the inserted row, deterimined by the inserted ID + _rowids shadow\n  // table\n  i64 rowid;\n\n  // Array to hold the vector data of the inserted row. Individual elements will\n  // have a lifetime bound to the argv[..] values.\n  void *vectorDatas[VEC0_MAX_VECTOR_COLUMNS];\n  // Array to hold cleanup functions for vectorDatas[]\n  vector_cleanup cleanups[VEC0_MAX_VECTOR_COLUMNS];\n\n  sqlite3_value * partitionKeyValues[VEC0_MAX_PARTITION_COLUMNS];\n\n  // Rowid of the chunk in the _chunks shadow table that the row will be a part\n  // of.\n  i64 chunk_rowid;\n  // offset within the chunk where the rowid belongs\n  i64 chunk_offset;\n\n  // a write-able blob of the validity column for the given chunk. Used to mark\n  // validity bit\n  sqlite3_blob *blobChunksValidity = NULL;\n  // buffer for the valididty column for the given chunk. Maybe not needed here?\n  const unsigned char *bufferChunksValidity = NULL;\n  int numReadVectors = 0;\n\n  // Read all provided partition key values into partitionKeyValues\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_PARTITION) {\n      continue;\n    }\n    int partition_key_idx = p->user_column_idxs[i];\n    partitionKeyValues[partition_key_idx] = argv[2+VEC0_COLUMN_USERN_START + i];\n\n    int new_value_type = sqlite3_value_type(partitionKeyValues[partition_key_idx]);\n    if((new_value_type != SQLITE_NULL) && (new_value_type != p->paritition_columns[partition_key_idx].type)) {\n      // IMP: V11454_28292\n      vtab_set_error(\n        pVTab,\n        \"Parition key type mismatch: The partition key column %.*s has type %s, but %s was provided.\",\n        p->paritition_columns[partition_key_idx].name_length,\n        p->paritition_columns[partition_key_idx].name,\n        type_name(p->paritition_columns[partition_key_idx].type),\n        type_name(new_value_type)\n      );\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n  }\n\n  // read all the inserted vectors  into vectorDatas, validate their lengths.\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_VECTOR) {\n      continue;\n    }\n    int vector_column_idx = p->user_column_idxs[i];\n    sqlite3_value *valueVector = argv[2 + VEC0_COLUMN_USERN_START + i];\n    size_t dimensions;\n\n    char *pzError;\n    enum VectorElementType elementType;\n    rc = vector_from_value(valueVector, &vectorDatas[vector_column_idx], &dimensions,\n                           &elementType, &cleanups[vector_column_idx], &pzError);\n    if (rc != SQLITE_OK) {\n      // IMP: V06519_23358\n      vtab_set_error(\n          pVTab, \"Inserted vector for the \\\"%.*s\\\" column is invalid: %z\",\n          p->vector_columns[vector_column_idx].name_length, p->vector_columns[vector_column_idx].name, pzError);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    numReadVectors++;\n    if (elementType != p->vector_columns[vector_column_idx].element_type) {\n      // IMP: V08221_25059\n      vtab_set_error(\n          pVTab,\n          \"Inserted vector for the \\\"%.*s\\\" column is expected to be of type \"\n          \"%s, but a %s vector was provided.\",\n          p->vector_columns[i].name_length, p->vector_columns[i].name,\n          vector_subtype_name(p->vector_columns[i].element_type),\n          vector_subtype_name(elementType));\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n\n    if (dimensions != p->vector_columns[vector_column_idx].dimensions) {\n      // IMP: V01145_17984\n      vtab_set_error(\n          pVTab,\n          \"Dimension mismatch for inserted vector for the \\\"%.*s\\\" column. \"\n          \"Expected %d dimensions but received %d.\",\n          p->vector_columns[vector_column_idx].name_length, p->vector_columns[vector_column_idx].name,\n          p->vector_columns[vector_column_idx].dimensions, dimensions);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n  }\n\n  // Cannot insert a value in the hidden \"distance\" column\n  if (sqlite3_value_type(argv[2 + vec0_column_distance_idx(p)]) !=\n      SQLITE_NULL) {\n    // IMP: V24228_08298\n    vtab_set_error(pVTab,\n                   \"A value was provided for the hidden \\\"distance\\\" column.\");\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  // Cannot insert a value in the hidden \"k\" column\n  if (sqlite3_value_type(argv[2 + vec0_column_k_idx(p)]) != SQLITE_NULL) {\n    // IMP: V11875_28713\n    vtab_set_error(pVTab, \"A value was provided for the hidden \\\"k\\\" column.\");\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  // Step #1: Insert/get a rowid for this row, from the _rowids table.\n  rc = vec0Update_InsertRowidStep(p, argv[2 + VEC0_COLUMN_ID], &rowid);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  // Step #2: Find the next \"available\" position in the _chunks table for this\n  // row.\n  rc = vec0Update_InsertNextAvailableStep(p, partitionKeyValues,\n  &chunk_rowid, &chunk_offset,\n                                          &blobChunksValidity,\n                                          &bufferChunksValidity);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  // Step #3: With the next available chunk position, write out all the vectors\n  //          to their specified location.\n  rc = vec0Update_InsertWriteFinalStep(p, chunk_rowid, chunk_offset, rowid,\n                                       vectorDatas, blobChunksValidity,\n                                       bufferChunksValidity);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n\n  if(p->numAuxiliaryColumns > 0) {\n    sqlite3_stmt *stmt;\n    sqlite3_str * s = sqlite3_str_new(NULL);\n    sqlite3_str_appendf(s, \"INSERT INTO \" VEC0_SHADOW_AUXILIARY_NAME \"(rowid \", p->schemaName, p->tableName);\n    for(int i = 0; i < p->numAuxiliaryColumns; i++) {\n      sqlite3_str_appendf(s, \", value%02d\", i);\n    }\n    sqlite3_str_appendall(s, \") VALUES (? \");\n    for(int i = 0; i < p->numAuxiliaryColumns; i++) {\n      sqlite3_str_appendall(s, \", ?\");\n    }\n    sqlite3_str_appendall(s, \")\");\n    char * zSql = sqlite3_str_finish(s);\n    // TODO double check error handling ehre\n    if(!zSql) {\n      rc = SQLITE_NOMEM;\n      goto cleanup;\n    }\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n    if(rc != SQLITE_OK) {\n      goto cleanup;\n    }\n    sqlite3_bind_int64(stmt, 1, rowid);\n\n    for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n      if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY) {\n        continue;\n      }\n      int auxiliary_key_idx = p->user_column_idxs[i];\n      sqlite3_value * v = argv[2+VEC0_COLUMN_USERN_START + i];\n      int v_type = sqlite3_value_type(v);\n      if(v_type != SQLITE_NULL && (v_type != p->auxiliary_columns[auxiliary_key_idx].type)) {\n        sqlite3_finalize(stmt);\n        rc = SQLITE_CONSTRAINT;\n        vtab_set_error(\n          pVTab,\n          \"Auxiliary column type mismatch: The auxiliary column %.*s has type %s, but %s was provided.\",\n          p->auxiliary_columns[auxiliary_key_idx].name_length,\n          p->auxiliary_columns[auxiliary_key_idx].name,\n          type_name(p->auxiliary_columns[auxiliary_key_idx].type),\n          type_name(v_type)\n        );\n        goto cleanup;\n      }\n      // first 1 is for 1-based indexing on sqlite3_bind_*, second 1 is to account for initial rowid parameter\n      sqlite3_bind_value(stmt, 1 + 1 + auxiliary_key_idx, v);\n    }\n\n    rc = sqlite3_step(stmt);\n    if(rc != SQLITE_DONE) {\n      sqlite3_finalize(stmt);\n      rc = SQLITE_ERROR;\n      goto cleanup;\n    }\n    sqlite3_finalize(stmt);\n  }\n\n\n  for(int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_METADATA) {\n      continue;\n    }\n    int metadata_idx = p->user_column_idxs[i];\n    sqlite3_value *v = argv[2 + VEC0_COLUMN_USERN_START + i];\n    rc = vec0_write_metadata_value(p, metadata_idx, rowid, chunk_rowid, chunk_offset, v, 0);\n    if(rc != SQLITE_OK) {\n      goto cleanup;\n    }\n  }\n\n  *pRowid = rowid;\n  rc = SQLITE_OK;\n\ncleanup:\n  for (int i = 0; i < numReadVectors; i++) {\n    cleanups[i](vectorDatas[i]);\n  }\n  sqlite3_free((void *)bufferChunksValidity);\n  int brc = sqlite3_blob_close(blobChunksValidity);\n  if ((rc == SQLITE_OK) && (brc != SQLITE_OK)) {\n    vtab_set_error(&p->base,\n                   VEC_INTERAL_ERROR \"unknown error, blobChunksValidity could \"\n                                     \"not be closed, please file an issue\");\n    return brc;\n  }\n  return rc;\n}\n\nint vec0Update_Delete_ClearValidity(vec0_vtab *p, i64 chunk_id,\n                                    u64 chunk_offset) {\n  int rc, brc;\n  sqlite3_blob *blobChunksValidity = NULL;\n  char unsigned bx;\n  int validityOffset = chunk_offset / CHAR_BIT;\n\n  // 2. ensure chunks.validity bit is 1, then set to 0\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowChunksName, \"validity\",\n                         chunk_id, 1, &blobChunksValidity);\n  if (rc != SQLITE_OK) {\n    // IMP: V26002_10073\n    vtab_set_error(&p->base, \"could not open validity blob for %s.%s.%lld\",\n                   p->schemaName, p->shadowChunksName, chunk_id);\n    return SQLITE_ERROR;\n  }\n  // will skip the sqlite3_blob_bytes(blobChunksValidity) check for now,\n  // the read below would catch it\n\n  rc = sqlite3_blob_read(blobChunksValidity, &bx, sizeof(bx), validityOffset);\n  if (rc != SQLITE_OK) {\n    // IMP: V21193_05263\n    vtab_set_error(\n        &p->base, \"could not read validity blob for %s.%s.%lld at %d\",\n        p->schemaName, p->shadowChunksName, chunk_id, validityOffset);\n    goto cleanup;\n  }\n  if (!(bx >> (chunk_offset % CHAR_BIT))) {\n    // IMP: V21193_05263\n    rc = SQLITE_ERROR;\n    vtab_set_error(\n        &p->base,\n        \"vec0 deletion error: validity bit is not set for %s.%s.%lld at %d\",\n        p->schemaName, p->shadowChunksName, chunk_id, validityOffset);\n    goto cleanup;\n  }\n  char unsigned mask = ~(1 << (chunk_offset % CHAR_BIT));\n  char result = bx & mask;\n  rc = sqlite3_blob_write(blobChunksValidity, &result, sizeof(bx),\n                          validityOffset);\n  if (rc != SQLITE_OK) {\n    vtab_set_error(\n        &p->base, \"could not write to validity blob for %s.%s.%lld at %d\",\n        p->schemaName, p->shadowChunksName, chunk_id, validityOffset);\n    goto cleanup;\n  }\n\ncleanup:\n\n  brc = sqlite3_blob_close(blobChunksValidity);\n  if (rc != SQLITE_OK)\n    return rc;\n  if (brc != SQLITE_OK) {\n    vtab_set_error(&p->base,\n                   \"vec0 deletion error: Error commiting validity blob \"\n                   \"transaction on %s.%s.%lld at %d\",\n                   p->schemaName, p->shadowChunksName, chunk_id,\n                   validityOffset);\n    return brc;\n  }\n  return SQLITE_OK;\n}\n\nint vec0Update_Delete_DeleteRowids(vec0_vtab *p, i64 rowid) {\n  int rc;\n  sqlite3_stmt *stmt = NULL;\n\n  char *zSql =\n      sqlite3_mprintf(\"DELETE FROM \" VEC0_SHADOW_ROWIDS_NAME \" WHERE rowid = ?\",\n                      p->schemaName, p->tableName);\n  if (!zSql) {\n    return SQLITE_NOMEM;\n  }\n\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n  sqlite3_bind_int64(stmt, 1, rowid);\n  rc = sqlite3_step(stmt);\n  if (rc != SQLITE_DONE) {\n    goto cleanup;\n  }\n  rc = SQLITE_OK;\n\ncleanup:\n  sqlite3_finalize(stmt);\n  return rc;\n}\n\nint vec0Update_Delete_DeleteAux(vec0_vtab *p, i64 rowid) {\n  int rc;\n  sqlite3_stmt *stmt = NULL;\n\n  char *zSql =\n      sqlite3_mprintf(\"DELETE FROM \" VEC0_SHADOW_AUXILIARY_NAME \" WHERE rowid = ?\",\n                      p->schemaName, p->tableName);\n  if (!zSql) {\n    return SQLITE_NOMEM;\n  }\n\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n  sqlite3_free(zSql);\n  if (rc != SQLITE_OK) {\n    goto cleanup;\n  }\n  sqlite3_bind_int64(stmt, 1, rowid);\n  rc = sqlite3_step(stmt);\n  if (rc != SQLITE_DONE) {\n    goto cleanup;\n  }\n  rc = SQLITE_OK;\n\ncleanup:\n  sqlite3_finalize(stmt);\n  return rc;\n}\n\nint vec0Update_Delete_ClearMetadata(vec0_vtab *p, int metadata_idx, i64 rowid, i64 chunk_id,\n                                    u64 chunk_offset) {\n  int rc;\n  sqlite3_blob * blobValue;\n  vec0_metadata_column_kind kind = p->metadata_columns[metadata_idx].kind;\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowMetadataChunksNames[metadata_idx], \"data\", chunk_id, 1, &blobValue);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n\n  switch(kind) {\n    case VEC0_METADATA_COLUMN_KIND_BOOLEAN: {\n      u8 block;\n      rc = sqlite3_blob_read(blobValue, &block, sizeof(u8), (int) (chunk_offset / CHAR_BIT));\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n\n      block &= ~(1 << (chunk_offset % CHAR_BIT));\n      rc = sqlite3_blob_write(blobValue, &block, sizeof(u8), chunk_offset / CHAR_BIT);\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_INTEGER: {\n      i64 v = 0;\n      rc = sqlite3_blob_write(blobValue, &v, sizeof(v), chunk_offset * sizeof(i64));\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_FLOAT: {\n      double v = 0;\n      rc = sqlite3_blob_write(blobValue, &v, sizeof(v), chunk_offset * sizeof(double));\n      break;\n    }\n    case VEC0_METADATA_COLUMN_KIND_TEXT: {\n      int n;\n      rc = sqlite3_blob_read(blobValue, &n, sizeof(int), chunk_offset * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n\n      u8 view[VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH];\n      memset(view, 0, VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      rc = sqlite3_blob_write(blobValue, &view, sizeof(view), chunk_offset * VEC0_METADATA_TEXT_VIEW_BUFFER_LENGTH);\n      if(rc != SQLITE_OK) {\n        goto done;\n      }\n\n      if(n > VEC0_METADATA_TEXT_VIEW_DATA_LENGTH) {\n        const char * zSql = sqlite3_mprintf(\"DELETE FROM \" VEC0_SHADOW_METADATA_TEXT_DATA_NAME \" WHERE rowid = ?\", p->schemaName, p->tableName, metadata_idx);\n        if(!zSql) {\n          rc = SQLITE_NOMEM;\n          goto done;\n        }\n        sqlite3_stmt * stmt;\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n        if(rc != SQLITE_OK) {\n          goto done;\n        }\n        sqlite3_bind_int64(stmt, 1, rowid);\n        rc = sqlite3_step(stmt);\n        if(rc != SQLITE_DONE) {\n          rc = SQLITE_ERROR;\n          goto done;\n        }\n        sqlite3_finalize(stmt);\n      }\n      break;\n    }\n  }\n  int rc2;\n  done:\n  rc2 = sqlite3_blob_close(blobValue);\n  if(rc == SQLITE_OK) {\n    return rc2;\n  }\n  return rc;\n}\n\nint vec0Update_Delete(sqlite3_vtab *pVTab, sqlite3_value *idValue) {\n  vec0_vtab *p = (vec0_vtab *)pVTab;\n  int rc;\n  i64 rowid;\n  i64 chunk_id;\n  i64 chunk_offset;\n\n  if (p->pkIsText) {\n    rc = vec0_rowid_from_id(p, idValue, &rowid);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n  } else {\n    rowid = sqlite3_value_int64(idValue);\n  }\n\n  // 1. Find chunk position for given rowid\n  // 2. Ensure that validity bit for position is 1, then set to 0\n  // 3. Zero out rowid in chunks.rowid\n  // 4. Zero out vector data in all vector column chunks\n  // 5. Delete value in _rowids table\n\n  // 1. get chunk_id and chunk_offset from _rowids\n  rc = vec0_get_chunk_position(p, rowid, NULL, &chunk_id, &chunk_offset);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n\n  rc = vec0Update_Delete_ClearValidity(p, chunk_id, chunk_offset);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n\n  // 3. zero out rowid in chunks.rowids\n  // https://github.com/asg017/sqlite-vec/issues/54\n\n  // 4. zero out any data in vector chunks tables\n  // https://github.com/asg017/sqlite-vec/issues/54\n\n  // 5. delete from _rowids table\n  rc = vec0Update_Delete_DeleteRowids(p, rowid);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n\n  // 6. delete any auxiliary rows\n  if(p->numAuxiliaryColumns > 0) {\n    rc = vec0Update_Delete_DeleteAux(p, rowid);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n  }\n\n  // 6. delete metadata\n  for(int i = 0; i < p->numMetadataColumns; i++) {\n    rc = vec0Update_Delete_ClearMetadata(p, i, rowid, chunk_id, chunk_offset);\n  }\n\n  return SQLITE_OK;\n}\n\nint vec0Update_UpdateAuxColumn(vec0_vtab *p, int auxiliary_column_idx, sqlite3_value * value, i64 rowid) {\n  int rc;\n  sqlite3_stmt *stmt;\n  const char * zSql = sqlite3_mprintf(\"UPDATE \" VEC0_SHADOW_AUXILIARY_NAME \" SET value%02d = ? WHERE rowid = ?\", p->schemaName, p->tableName, auxiliary_column_idx);\n  if(!zSql) {\n    return SQLITE_NOMEM;\n  }\n  rc = sqlite3_prepare_v2(p->db, zSql, -1, &stmt, NULL);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  sqlite3_bind_value(stmt, 1, value);\n  sqlite3_bind_int64(stmt, 2, rowid);\n  rc = sqlite3_step(stmt);\n  if(rc != SQLITE_DONE) {\n    sqlite3_finalize(stmt);\n    return SQLITE_ERROR;\n  }\n  sqlite3_finalize(stmt);\n  return SQLITE_OK;\n}\n\nint vec0Update_UpdateVectorColumn(vec0_vtab *p, i64 chunk_id, i64 chunk_offset,\n                                  int i, sqlite3_value *valueVector) {\n  int rc;\n\n  sqlite3_blob *blobVectors = NULL;\n\n  char *pzError;\n  size_t dimensions;\n  enum VectorElementType elementType;\n  void *vector;\n  vector_cleanup cleanup = vector_cleanup_noop;\n  // https://github.com/asg017/sqlite-vec/issues/53\n  rc = vector_from_value(valueVector, &vector, &dimensions, &elementType,\n                         &cleanup, &pzError);\n  if (rc != SQLITE_OK) {\n    // IMP: V15203_32042\n    vtab_set_error(\n        &p->base, \"Updated vector for the \\\"%.*s\\\" column is invalid: %z\",\n        p->vector_columns[i].name_length, p->vector_columns[i].name, pzError);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  if (elementType != p->vector_columns[i].element_type) {\n    // IMP: V03643_20481\n    vtab_set_error(\n        &p->base,\n        \"Updated vector for the \\\"%.*s\\\" column is expected to be of type \"\n        \"%s, but a %s vector was provided.\",\n        p->vector_columns[i].name_length, p->vector_columns[i].name,\n        vector_subtype_name(p->vector_columns[i].element_type),\n        vector_subtype_name(elementType));\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n  if (dimensions != p->vector_columns[i].dimensions) {\n    // IMP: V25739_09810\n    vtab_set_error(\n        &p->base,\n        \"Dimension mismatch for new updated vector for the \\\"%.*s\\\" column. \"\n        \"Expected %d dimensions but received %d.\",\n        p->vector_columns[i].name_length, p->vector_columns[i].name,\n        p->vector_columns[i].dimensions, dimensions);\n    rc = SQLITE_ERROR;\n    goto cleanup;\n  }\n\n  rc = sqlite3_blob_open(p->db, p->schemaName, p->shadowVectorChunksNames[i],\n                         \"vectors\", chunk_id, 1, &blobVectors);\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&p->base, \"Could not open vectors blob for %s.%s.%lld\",\n                   p->schemaName, p->shadowVectorChunksNames[i], chunk_id);\n    goto cleanup;\n  }\n  rc = vec0_write_vector_to_vector_blob(blobVectors, chunk_offset, vector,\n                                        p->vector_columns[i].dimensions,\n                                        p->vector_columns[i].element_type);\n  if (rc != SQLITE_OK) {\n    vtab_set_error(&p->base, \"Could not write to vectors blob for %s.%s.%lld\",\n                   p->schemaName, p->shadowVectorChunksNames[i], chunk_id);\n    goto cleanup;\n  }\n\ncleanup:\n  cleanup(vector);\n  int brc = sqlite3_blob_close(blobVectors);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n  if (brc != SQLITE_OK) {\n    vtab_set_error(\n        &p->base,\n        \"Could not commit blob transaction for vectors blob for %s.%s.%lld\",\n        p->schemaName, p->shadowVectorChunksNames[i], chunk_id);\n    return brc;\n  }\n  return SQLITE_OK;\n}\n\nint vec0Update_Update(sqlite3_vtab *pVTab, int argc, sqlite3_value **argv) {\n  UNUSED_PARAMETER(argc);\n  vec0_vtab *p = (vec0_vtab *)pVTab;\n  int rc;\n  i64 chunk_id;\n  i64 chunk_offset;\n\n  i64 rowid;\n  if (p->pkIsText) {\n    const char *a = (const char *)sqlite3_value_text(argv[0]);\n    const char *b = (const char *)sqlite3_value_text(argv[1]);\n    // IMP: V08886_25725\n    if ((sqlite3_value_bytes(argv[0]) != sqlite3_value_bytes(argv[1])) ||\n        strncmp(a, b, sqlite3_value_bytes(argv[0])) != 0) {\n      vtab_set_error(pVTab,\n                     \"UPDATEs on vec0 primary key values are not allowed.\");\n      return SQLITE_ERROR;\n    }\n    rc = vec0_rowid_from_id(p, argv[0], &rowid);\n    if (rc != SQLITE_OK) {\n      return rc;\n    }\n  } else {\n    rowid = sqlite3_value_int64(argv[0]);\n  }\n\n  // 1) get chunk_id and chunk_offset from _rowids\n  rc = vec0_get_chunk_position(p, rowid, NULL, &chunk_id, &chunk_offset);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n\n  // 2) update any partition key values\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_PARTITION) {\n      continue;\n    }\n    sqlite3_value * value = argv[2+VEC0_COLUMN_USERN_START + i];\n    if(sqlite3_value_nochange(value)) {\n      continue;\n    }\n    vtab_set_error(pVTab, \"UPDATE on partition key columns are not supported yet. \");\n    return SQLITE_ERROR;\n  }\n\n  // 3) handle auxiliary column updates\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_AUXILIARY) {\n      continue;\n    }\n    int auxiliary_column_idx = p->user_column_idxs[i];\n    sqlite3_value * value = argv[2+VEC0_COLUMN_USERN_START + i];\n    if(sqlite3_value_nochange(value)) {\n      continue;\n    }\n    rc = vec0Update_UpdateAuxColumn(p, auxiliary_column_idx, value, rowid);\n    if(rc != SQLITE_OK) {\n      return SQLITE_ERROR;\n    }\n  }\n\n  // 4) handle metadata column updates\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_METADATA) {\n      continue;\n    }\n    int metadata_column_idx = p->user_column_idxs[i];\n    sqlite3_value * value = argv[2+VEC0_COLUMN_USERN_START + i];\n    if(sqlite3_value_nochange(value)) {\n      continue;\n    }\n    rc = vec0_write_metadata_value(p, metadata_column_idx, rowid, chunk_id, chunk_offset, value, 1);\n    if(rc != SQLITE_OK) {\n      return rc;\n    }\n  }\n\n  // 5) iterate over all new vectors, update the vectors\n  for (int i = 0; i < vec0_num_defined_user_columns(p); i++) {\n    if(p->user_column_kinds[i] != SQLITE_VEC0_USER_COLUMN_KIND_VECTOR) {\n      continue;\n    }\n    int vector_idx = p->user_column_idxs[i];\n    sqlite3_value *valueVector = argv[2 + VEC0_COLUMN_USERN_START + i];\n    // in vec0Column, we check sqlite3_vtab_nochange() on vector columns.\n    // If the vector column isn't being changed, we return NULL;\n    // That's not great, that means vector columns can never be NULLABLE\n    // (bc we cant distinguish if an updated vector is truly NULL or nochange).\n    // Also it means that if someone tries to run `UPDATE v SET X = NULL`,\n    // we can't effectively detect and raise an error.\n    // A better solution would be to use a custom result_type for \"empty\",\n    // but subtypes don't appear to survive xColumn -> xUpdate, it's always 0.\n    // So for now, we'll just use NULL and warn people to not SET X = NULL\n    // in the docs.\n    if (sqlite3_value_type(valueVector) == SQLITE_NULL) {\n      continue;\n    }\n\n    rc = vec0Update_UpdateVectorColumn(p, chunk_id, chunk_offset, vector_idx,\n                                       valueVector);\n    if (rc != SQLITE_OK) {\n      return SQLITE_ERROR;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int vec0Update(sqlite3_vtab *pVTab, int argc, sqlite3_value **argv,\n                      sqlite_int64 *pRowid) {\n  // DELETE operation\n  if (argc == 1 && sqlite3_value_type(argv[0]) != SQLITE_NULL) {\n    return vec0Update_Delete(pVTab, argv[0]);\n  }\n  // INSERT operation\n  else if (argc > 1 && sqlite3_value_type(argv[0]) == SQLITE_NULL) {\n    return vec0Update_Insert(pVTab, argc, argv, pRowid);\n  }\n  // UPDATE operation\n  else if (argc > 1 && sqlite3_value_type(argv[0]) != SQLITE_NULL) {\n    return vec0Update_Update(pVTab, argc, argv);\n  } else {\n    vtab_set_error(pVTab, \"Unrecognized xUpdate operation provided for vec0.\");\n    return SQLITE_ERROR;\n  }\n}\n\nstatic int vec0ShadowName(const char *zName) {\n  static const char *azName[] = {\n    \"rowids\", \"chunks\", \"auxiliary\", \"info\",\n\n  // Up to VEC0_MAX_METADATA_COLUMNS\n  // TODO be smarter about this man\n  \"metadatachunks00\",\n  \"metadatachunks01\",\n  \"metadatachunks02\",\n  \"metadatachunks03\",\n  \"metadatachunks04\",\n  \"metadatachunks05\",\n  \"metadatachunks06\",\n  \"metadatachunks07\",\n  \"metadatachunks08\",\n  \"metadatachunks09\",\n  \"metadatachunks10\",\n  \"metadatachunks11\",\n  \"metadatachunks12\",\n  \"metadatachunks13\",\n  \"metadatachunks14\",\n  \"metadatachunks15\",\n\n  // Up to\n  \"metadatatext00\",\n  \"metadatatext01\",\n  \"metadatatext02\",\n  \"metadatatext03\",\n  \"metadatatext04\",\n  \"metadatatext05\",\n  \"metadatatext06\",\n  \"metadatatext07\",\n  \"metadatatext08\",\n  \"metadatatext09\",\n  \"metadatatext10\",\n  \"metadatatext11\",\n  \"metadatatext12\",\n  \"metadatatext13\",\n  \"metadatatext14\",\n  \"metadatatext15\",\n  };\n\n  for (size_t i = 0; i < sizeof(azName) / sizeof(azName[0]); i++) {\n    if (sqlite3_stricmp(zName, azName[i]) == 0)\n      return 1;\n  }\n  //for(size_t i = 0; i < )\"vector_chunks\", \"metadatachunks\"\n  return 0;\n}\n\nstatic int vec0Begin(sqlite3_vtab *pVTab) {\n  UNUSED_PARAMETER(pVTab);\n  return SQLITE_OK;\n}\nstatic int vec0Sync(sqlite3_vtab *pVTab) {\n  UNUSED_PARAMETER(pVTab);\n  vec0_vtab *p = (vec0_vtab *)pVTab;\n  if (p->stmtLatestChunk) {\n    sqlite3_finalize(p->stmtLatestChunk);\n    p->stmtLatestChunk = NULL;\n  }\n  if (p->stmtRowidsInsertRowid) {\n    sqlite3_finalize(p->stmtRowidsInsertRowid);\n    p->stmtRowidsInsertRowid = NULL;\n  }\n  if (p->stmtRowidsInsertId) {\n    sqlite3_finalize(p->stmtRowidsInsertId);\n    p->stmtRowidsInsertId = NULL;\n  }\n  if (p->stmtRowidsUpdatePosition) {\n    sqlite3_finalize(p->stmtRowidsUpdatePosition);\n    p->stmtRowidsUpdatePosition = NULL;\n  }\n  if (p->stmtRowidsGetChunkPosition) {\n    sqlite3_finalize(p->stmtRowidsGetChunkPosition);\n    p->stmtRowidsGetChunkPosition = NULL;\n  }\n  return SQLITE_OK;\n}\nstatic int vec0Commit(sqlite3_vtab *pVTab) {\n  UNUSED_PARAMETER(pVTab);\n  return SQLITE_OK;\n}\nstatic int vec0Rollback(sqlite3_vtab *pVTab) {\n  UNUSED_PARAMETER(pVTab);\n  return SQLITE_OK;\n}\n\nstatic sqlite3_module vec0Module = {\n    /* iVersion      */ 3,\n    /* xCreate       */ vec0Create,\n    /* xConnect      */ vec0Connect,\n    /* xBestIndex    */ vec0BestIndex,\n    /* xDisconnect   */ vec0Disconnect,\n    /* xDestroy      */ vec0Destroy,\n    /* xOpen         */ vec0Open,\n    /* xClose        */ vec0Close,\n    /* xFilter       */ vec0Filter,\n    /* xNext         */ vec0Next,\n    /* xEof          */ vec0Eof,\n    /* xColumn       */ vec0Column,\n    /* xRowid        */ vec0Rowid,\n    /* xUpdate       */ vec0Update,\n    /* xBegin        */ vec0Begin,\n    /* xSync         */ vec0Sync,\n    /* xCommit       */ vec0Commit,\n    /* xRollback     */ vec0Rollback,\n    /* xFindFunction */ 0,\n    /* xRename       */ 0, // https://github.com/asg017/sqlite-vec/issues/43\n    /* xSavepoint    */ 0,\n    /* xRelease      */ 0,\n    /* xRollbackTo   */ 0,\n    /* xShadowName   */ vec0ShadowName,\n#if SQLITE_VERSION_NUMBER >= 3044000\n    /* xIntegrity    */ 0, // https://github.com/asg017/sqlite-vec/issues/44\n#endif\n};\n#pragma endregion\n\nstatic char *POINTER_NAME_STATIC_BLOB_DEF = \"vec0-static_blob_def\";\nstruct static_blob_definition {\n  void *p;\n  size_t dimensions;\n  size_t nvectors;\n  enum VectorElementType element_type;\n};\nstatic void vec_static_blob_from_raw(sqlite3_context *context, int argc,\n                                     sqlite3_value **argv) {\n\n  assert(argc == 4);\n  struct static_blob_definition *p;\n  p = sqlite3_malloc(sizeof(*p));\n  if (!p) {\n    sqlite3_result_error_nomem(context);\n    return;\n  }\n  memset(p, 0, sizeof(*p));\n  p->p = (void *)sqlite3_value_int64(argv[0]);\n  p->element_type = SQLITE_VEC_ELEMENT_TYPE_FLOAT32;\n  p->dimensions = sqlite3_value_int64(argv[2]);\n  p->nvectors = sqlite3_value_int64(argv[3]);\n  sqlite3_result_pointer(context, p, POINTER_NAME_STATIC_BLOB_DEF,\n                         sqlite3_free);\n}\n#pragma region vec_static_blobs() table function\n\n#define MAX_STATIC_BLOBS 16\n\ntypedef struct static_blob static_blob;\nstruct static_blob {\n  char *name;\n  void *p;\n  size_t dimensions;\n  size_t nvectors;\n  enum VectorElementType element_type;\n};\n\ntypedef struct vec_static_blob_data vec_static_blob_data;\nstruct vec_static_blob_data {\n  static_blob static_blobs[MAX_STATIC_BLOBS];\n};\n\ntypedef struct vec_static_blobs_vtab vec_static_blobs_vtab;\nstruct vec_static_blobs_vtab {\n  sqlite3_vtab base;\n  vec_static_blob_data *data;\n};\n\ntypedef struct vec_static_blobs_cursor vec_static_blobs_cursor;\nstruct vec_static_blobs_cursor {\n  sqlite3_vtab_cursor base;\n  sqlite3_int64 iRowid;\n};\n\nstatic int vec_static_blobsConnect(sqlite3 *db, void *pAux, int argc,\n                                   const char *const *argv,\n                                   sqlite3_vtab **ppVtab, char **pzErr) {\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  UNUSED_PARAMETER(pzErr);\n\n  vec_static_blobs_vtab *pNew;\n#define VEC_STATIC_BLOBS_NAME 0\n#define VEC_STATIC_BLOBS_DATA 1\n#define VEC_STATIC_BLOBS_DIMENSIONS 2\n#define VEC_STATIC_BLOBS_COUNT 3\n  int rc = sqlite3_declare_vtab(\n      db, \"CREATE TABLE x(name, data, dimensions hidden, count hidden)\");\n  if (rc == SQLITE_OK) {\n    pNew = sqlite3_malloc(sizeof(*pNew));\n    *ppVtab = (sqlite3_vtab *)pNew;\n    if (pNew == 0)\n      return SQLITE_NOMEM;\n    memset(pNew, 0, sizeof(*pNew));\n    pNew->data = pAux;\n  }\n  return rc;\n}\n\nstatic int vec_static_blobsDisconnect(sqlite3_vtab *pVtab) {\n  vec_static_blobs_vtab *p = (vec_static_blobs_vtab *)pVtab;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsUpdate(sqlite3_vtab *pVTab, int argc,\n                                  sqlite3_value **argv, sqlite_int64 *pRowid) {\n  UNUSED_PARAMETER(pRowid);\n  vec_static_blobs_vtab *p = (vec_static_blobs_vtab *)pVTab;\n  // DELETE operation\n  if (argc == 1 && sqlite3_value_type(argv[0]) != SQLITE_NULL) {\n    return SQLITE_ERROR;\n  }\n  // INSERT operation\n  else if (argc > 1 && sqlite3_value_type(argv[0]) == SQLITE_NULL) {\n    const char *key =\n        (const char *)sqlite3_value_text(argv[2 + VEC_STATIC_BLOBS_NAME]);\n    int idx = -1;\n    for (int i = 0; i < MAX_STATIC_BLOBS; i++) {\n      if (!p->data->static_blobs[i].name) {\n        p->data->static_blobs[i].name = sqlite3_mprintf(\"%s\", key);\n        idx = i;\n        break;\n      }\n    }\n    if (idx < 0)\n      abort();\n    struct static_blob_definition *def = sqlite3_value_pointer(\n        argv[2 + VEC_STATIC_BLOBS_DATA], POINTER_NAME_STATIC_BLOB_DEF);\n    p->data->static_blobs[idx].p = def->p;\n    p->data->static_blobs[idx].dimensions = def->dimensions;\n    p->data->static_blobs[idx].nvectors = def->nvectors;\n    p->data->static_blobs[idx].element_type = def->element_type;\n\n    return SQLITE_OK;\n  }\n  // UPDATE operation\n  else if (argc > 1 && sqlite3_value_type(argv[0]) != SQLITE_NULL) {\n    return SQLITE_ERROR;\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec_static_blobsOpen(sqlite3_vtab *p,\n                                sqlite3_vtab_cursor **ppCursor) {\n  UNUSED_PARAMETER(p);\n  vec_static_blobs_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(*pCur));\n  if (pCur == 0)\n    return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsClose(sqlite3_vtab_cursor *cur) {\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)cur;\n  sqlite3_free(pCur);\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsBestIndex(sqlite3_vtab *pVTab,\n                                     sqlite3_index_info *pIdxInfo) {\n  UNUSED_PARAMETER(pVTab);\n  pIdxInfo->idxNum = 1;\n  pIdxInfo->estimatedCost = (double)10;\n  pIdxInfo->estimatedRows = 10;\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsNext(sqlite3_vtab_cursor *cur);\nstatic int vec_static_blobsFilter(sqlite3_vtab_cursor *pVtabCursor, int idxNum,\n                                  const char *idxStr, int argc,\n                                  sqlite3_value **argv) {\n  UNUSED_PARAMETER(idxNum);\n  UNUSED_PARAMETER(idxStr);\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)pVtabCursor;\n  pCur->iRowid = -1;\n  vec_static_blobsNext(pVtabCursor);\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsRowid(sqlite3_vtab_cursor *cur,\n                                 sqlite_int64 *pRowid) {\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)cur;\n  *pRowid = pCur->iRowid;\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsNext(sqlite3_vtab_cursor *cur) {\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)cur;\n  vec_static_blobs_vtab *p = (vec_static_blobs_vtab *)pCur->base.pVtab;\n  pCur->iRowid++;\n  while (pCur->iRowid < MAX_STATIC_BLOBS) {\n    if (p->data->static_blobs[pCur->iRowid].name) {\n      return SQLITE_OK;\n    }\n    pCur->iRowid++;\n  }\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blobsEof(sqlite3_vtab_cursor *cur) {\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)cur;\n  return pCur->iRowid >= MAX_STATIC_BLOBS;\n}\n\nstatic int vec_static_blobsColumn(sqlite3_vtab_cursor *cur,\n                                  sqlite3_context *context, int i) {\n  vec_static_blobs_cursor *pCur = (vec_static_blobs_cursor *)cur;\n  vec_static_blobs_vtab *p = (vec_static_blobs_vtab *)cur->pVtab;\n  switch (i) {\n  case VEC_STATIC_BLOBS_NAME:\n    sqlite3_result_text(context, p->data->static_blobs[pCur->iRowid].name, -1,\n                        SQLITE_TRANSIENT);\n    break;\n  case VEC_STATIC_BLOBS_DATA:\n    sqlite3_result_null(context);\n    break;\n  case VEC_STATIC_BLOBS_DIMENSIONS:\n    sqlite3_result_int64(context,\n                         p->data->static_blobs[pCur->iRowid].dimensions);\n    break;\n  case VEC_STATIC_BLOBS_COUNT:\n    sqlite3_result_int64(context, p->data->static_blobs[pCur->iRowid].nvectors);\n    break;\n  }\n  return SQLITE_OK;\n}\n\nstatic sqlite3_module vec_static_blobsModule = {\n    /* iVersion    */ 3,\n    /* xCreate     */ 0,\n    /* xConnect    */ vec_static_blobsConnect,\n    /* xBestIndex  */ vec_static_blobsBestIndex,\n    /* xDisconnect */ vec_static_blobsDisconnect,\n    /* xDestroy    */ 0,\n    /* xOpen       */ vec_static_blobsOpen,\n    /* xClose      */ vec_static_blobsClose,\n    /* xFilter     */ vec_static_blobsFilter,\n    /* xNext       */ vec_static_blobsNext,\n    /* xEof        */ vec_static_blobsEof,\n    /* xColumn     */ vec_static_blobsColumn,\n    /* xRowid      */ vec_static_blobsRowid,\n    /* xUpdate     */ vec_static_blobsUpdate,\n    /* xBegin      */ 0,\n    /* xSync       */ 0,\n    /* xCommit     */ 0,\n    /* xRollback   */ 0,\n    /* xFindMethod */ 0,\n    /* xRename     */ 0,\n    /* xSavepoint  */ 0,\n    /* xRelease    */ 0,\n    /* xRollbackTo */ 0,\n    /* xShadowName */ 0,\n#if SQLITE_VERSION_NUMBER >= 3044000\n    /* xIntegrity  */ 0\n#endif\n};\n#pragma endregion\n\n#pragma region vec_static_blob_entries() table function\n\ntypedef struct vec_static_blob_entries_vtab vec_static_blob_entries_vtab;\nstruct vec_static_blob_entries_vtab {\n  sqlite3_vtab base;\n  static_blob *blob;\n};\ntypedef enum {\n  VEC_SBE__QUERYPLAN_FULLSCAN = 1,\n  VEC_SBE__QUERYPLAN_KNN = 2\n} vec_sbe_query_plan;\n\nstruct sbe_query_knn_data {\n  i64 k;\n  i64 k_used;\n  // Array of rowids of size k. Must be freed with sqlite3_free().\n  i32 *rowids;\n  // Array of distances of size k. Must be freed with sqlite3_free().\n  f32 *distances;\n  i64 current_idx;\n};\nvoid sbe_query_knn_data_clear(struct sbe_query_knn_data *knn_data) {\n  if (!knn_data)\n    return;\n\n  if (knn_data->rowids) {\n    sqlite3_free(knn_data->rowids);\n    knn_data->rowids = NULL;\n  }\n  if (knn_data->distances) {\n    sqlite3_free(knn_data->distances);\n    knn_data->distances = NULL;\n  }\n}\n\ntypedef struct vec_static_blob_entries_cursor vec_static_blob_entries_cursor;\nstruct vec_static_blob_entries_cursor {\n  sqlite3_vtab_cursor base;\n  sqlite3_int64 iRowid;\n  vec_sbe_query_plan query_plan;\n  struct sbe_query_knn_data *knn_data;\n};\n\nstatic int vec_static_blob_entriesConnect(sqlite3 *db, void *pAux, int argc,\n                                          const char *const *argv,\n                                          sqlite3_vtab **ppVtab, char **pzErr) {\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n  UNUSED_PARAMETER(pzErr);\n  vec_static_blob_data *blob_data = pAux;\n  int idx = -1;\n  for (int i = 0; i < MAX_STATIC_BLOBS; i++) {\n    if (!blob_data->static_blobs[i].name)\n      continue;\n    if (strncmp(blob_data->static_blobs[i].name, argv[3],\n                strlen(blob_data->static_blobs[i].name)) == 0) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx < 0)\n    abort();\n  vec_static_blob_entries_vtab *pNew;\n#define VEC_STATIC_BLOB_ENTRIES_VECTOR 0\n#define VEC_STATIC_BLOB_ENTRIES_DISTANCE 1\n#define VEC_STATIC_BLOB_ENTRIES_K 2\n  int rc = sqlite3_declare_vtab(\n      db, \"CREATE TABLE x(vector, distance hidden, k hidden)\");\n  if (rc == SQLITE_OK) {\n    pNew = sqlite3_malloc(sizeof(*pNew));\n    *ppVtab = (sqlite3_vtab *)pNew;\n    if (pNew == 0)\n      return SQLITE_NOMEM;\n    memset(pNew, 0, sizeof(*pNew));\n    pNew->blob = &blob_data->static_blobs[idx];\n  }\n  return rc;\n}\n\nstatic int vec_static_blob_entriesCreate(sqlite3 *db, void *pAux, int argc,\n                                         const char *const *argv,\n                                         sqlite3_vtab **ppVtab, char **pzErr) {\n  return vec_static_blob_entriesConnect(db, pAux, argc, argv, ppVtab, pzErr);\n}\n\nstatic int vec_static_blob_entriesDisconnect(sqlite3_vtab *pVtab) {\n  vec_static_blob_entries_vtab *p = (vec_static_blob_entries_vtab *)pVtab;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blob_entriesOpen(sqlite3_vtab *p,\n                                       sqlite3_vtab_cursor **ppCursor) {\n  UNUSED_PARAMETER(p);\n  vec_static_blob_entries_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(*pCur));\n  if (pCur == 0)\n    return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blob_entriesClose(sqlite3_vtab_cursor *cur) {\n  vec_static_blob_entries_cursor *pCur = (vec_static_blob_entries_cursor *)cur;\n  sqlite3_free(pCur->knn_data);\n  sqlite3_free(pCur);\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blob_entriesBestIndex(sqlite3_vtab *pVTab,\n                                            sqlite3_index_info *pIdxInfo) {\n  vec_static_blob_entries_vtab *p = (vec_static_blob_entries_vtab *)pVTab;\n  int iMatchTerm = -1;\n  int iLimitTerm = -1;\n  // int iRowidTerm = -1; // https://github.com/asg017/sqlite-vec/issues/47\n  int iKTerm = -1;\n\n  for (int i = 0; i < pIdxInfo->nConstraint; i++) {\n    if (!pIdxInfo->aConstraint[i].usable)\n      continue;\n\n    int iColumn = pIdxInfo->aConstraint[i].iColumn;\n    int op = pIdxInfo->aConstraint[i].op;\n    if (op == SQLITE_INDEX_CONSTRAINT_MATCH &&\n        iColumn == VEC_STATIC_BLOB_ENTRIES_VECTOR) {\n      if (iMatchTerm > -1) {\n        // https://github.com/asg017/sqlite-vec/issues/51\n        return SQLITE_ERROR;\n      }\n      iMatchTerm = i;\n    }\n    if (op == SQLITE_INDEX_CONSTRAINT_LIMIT) {\n      iLimitTerm = i;\n    }\n    if (op == SQLITE_INDEX_CONSTRAINT_EQ &&\n        iColumn == VEC_STATIC_BLOB_ENTRIES_K) {\n      iKTerm = i;\n    }\n  }\n  if (iMatchTerm >= 0) {\n    if (iLimitTerm < 0 && iKTerm < 0) {\n      // https://github.com/asg017/sqlite-vec/issues/51\n      return SQLITE_ERROR;\n    }\n    if (iLimitTerm >= 0 && iKTerm >= 0) {\n      return SQLITE_ERROR; // limit or k, not both\n    }\n    if (pIdxInfo->nOrderBy < 1) {\n      vtab_set_error(pVTab, \"ORDER BY distance required\");\n      return SQLITE_CONSTRAINT;\n    }\n    if (pIdxInfo->nOrderBy > 1) {\n      // https://github.com/asg017/sqlite-vec/issues/51\n      vtab_set_error(pVTab, \"more than 1 ORDER BY clause provided\");\n      return SQLITE_CONSTRAINT;\n    }\n    if (pIdxInfo->aOrderBy[0].iColumn != VEC_STATIC_BLOB_ENTRIES_DISTANCE) {\n      vtab_set_error(pVTab, \"ORDER BY must be on the distance column\");\n      return SQLITE_CONSTRAINT;\n    }\n    if (pIdxInfo->aOrderBy[0].desc) {\n      vtab_set_error(pVTab,\n                     \"Only ascending in ORDER BY distance clause is supported, \"\n                     \"DESC is not supported yet.\");\n      return SQLITE_CONSTRAINT;\n    }\n\n    pIdxInfo->idxNum = VEC_SBE__QUERYPLAN_KNN;\n    pIdxInfo->estimatedCost = (double)10;\n    pIdxInfo->estimatedRows = 10;\n\n    pIdxInfo->orderByConsumed = 1;\n    pIdxInfo->aConstraintUsage[iMatchTerm].argvIndex = 1;\n    pIdxInfo->aConstraintUsage[iMatchTerm].omit = 1;\n    if (iLimitTerm >= 0) {\n      pIdxInfo->aConstraintUsage[iLimitTerm].argvIndex = 2;\n      pIdxInfo->aConstraintUsage[iLimitTerm].omit = 1;\n    } else {\n      pIdxInfo->aConstraintUsage[iKTerm].argvIndex = 2;\n      pIdxInfo->aConstraintUsage[iKTerm].omit = 1;\n    }\n\n  } else {\n    pIdxInfo->idxNum = VEC_SBE__QUERYPLAN_FULLSCAN;\n    pIdxInfo->estimatedCost = (double)p->blob->nvectors;\n    pIdxInfo->estimatedRows = p->blob->nvectors;\n  }\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blob_entriesFilter(sqlite3_vtab_cursor *pVtabCursor,\n                                         int idxNum, const char *idxStr,\n                                         int argc, sqlite3_value **argv) {\n  UNUSED_PARAMETER(idxStr);\n  assert(argc >= 0 && argc <= 3);\n  vec_static_blob_entries_cursor *pCur =\n      (vec_static_blob_entries_cursor *)pVtabCursor;\n  vec_static_blob_entries_vtab *p =\n      (vec_static_blob_entries_vtab *)pCur->base.pVtab;\n\n  if (idxNum == VEC_SBE__QUERYPLAN_KNN) {\n    assert(argc == 2);\n    pCur->query_plan = VEC_SBE__QUERYPLAN_KNN;\n    struct sbe_query_knn_data *knn_data;\n    knn_data = sqlite3_malloc(sizeof(*knn_data));\n    if (!knn_data) {\n      return SQLITE_NOMEM;\n    }\n    memset(knn_data, 0, sizeof(*knn_data));\n\n    void *queryVector;\n    size_t dimensions;\n    enum VectorElementType elementType;\n    vector_cleanup cleanup;\n    char *err;\n    int rc = vector_from_value(argv[0], &queryVector, &dimensions, &elementType,\n                               &cleanup, &err);\n    if (rc != SQLITE_OK) {\n      return SQLITE_ERROR;\n    }\n    if (elementType != p->blob->element_type) {\n      return SQLITE_ERROR;\n    }\n    if (dimensions != p->blob->dimensions) {\n      return SQLITE_ERROR;\n    }\n\n    i64 k = min(sqlite3_value_int64(argv[1]), (i64)p->blob->nvectors);\n    if (k < 0) {\n      // HANDLE https://github.com/asg017/sqlite-vec/issues/55\n      return SQLITE_ERROR;\n    }\n    if (k == 0) {\n      knn_data->k = 0;\n      pCur->knn_data = knn_data;\n      return SQLITE_OK;\n    }\n\n    size_t bsize = (p->blob->nvectors + 7) & ~7;\n\n    i32 *topk_rowids = sqlite3_malloc(k * sizeof(i32));\n    if (!topk_rowids) {\n      // HANDLE https://github.com/asg017/sqlite-vec/issues/55\n      return SQLITE_ERROR;\n    }\n    f32 *distances = sqlite3_malloc(bsize * sizeof(f32));\n    if (!distances) {\n      // HANDLE https://github.com/asg017/sqlite-vec/issues/55\n      return SQLITE_ERROR;\n    }\n\n    for (size_t i = 0; i < p->blob->nvectors; i++) {\n      // https://github.com/asg017/sqlite-vec/issues/52\n      float *v = ((float *)p->blob->p) + (i * p->blob->dimensions);\n      distances[i] =\n          distance_l2_sqr_float(v, (float *)queryVector, &p->blob->dimensions);\n    }\n    u8 *candidates = bitmap_new(bsize);\n    assert(candidates);\n\n    u8 *taken = bitmap_new(bsize);\n    assert(taken);\n\n    bitmap_fill(candidates, bsize);\n    for (size_t i = bsize; i >= p->blob->nvectors; i--) {\n      bitmap_set(candidates, i, 0);\n    }\n    i32 k_used = 0;\n    min_idx(distances, bsize, candidates, topk_rowids, k, taken, &k_used);\n    knn_data->current_idx = 0;\n    knn_data->distances = distances;\n    knn_data->k = k;\n    knn_data->rowids = topk_rowids;\n\n    pCur->knn_data = knn_data;\n  } else {\n    pCur->query_plan = VEC_SBE__QUERYPLAN_FULLSCAN;\n    pCur->iRowid = 0;\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int vec_static_blob_entriesRowid(sqlite3_vtab_cursor *cur,\n                                        sqlite_int64 *pRowid) {\n  vec_static_blob_entries_cursor *pCur = (vec_static_blob_entries_cursor *)cur;\n  switch (pCur->query_plan) {\n  case VEC_SBE__QUERYPLAN_FULLSCAN: {\n    *pRowid = pCur->iRowid;\n    return SQLITE_OK;\n  }\n  case VEC_SBE__QUERYPLAN_KNN: {\n    i32 rowid = ((i32 *)pCur->knn_data->rowids)[pCur->knn_data->current_idx];\n    *pRowid = (sqlite3_int64)rowid;\n    return SQLITE_OK;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec_static_blob_entriesNext(sqlite3_vtab_cursor *cur) {\n  vec_static_blob_entries_cursor *pCur = (vec_static_blob_entries_cursor *)cur;\n  switch (pCur->query_plan) {\n  case VEC_SBE__QUERYPLAN_FULLSCAN: {\n    pCur->iRowid++;\n    return SQLITE_OK;\n  }\n  case VEC_SBE__QUERYPLAN_KNN: {\n    pCur->knn_data->current_idx++;\n    return SQLITE_OK;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec_static_blob_entriesEof(sqlite3_vtab_cursor *cur) {\n  vec_static_blob_entries_cursor *pCur = (vec_static_blob_entries_cursor *)cur;\n  vec_static_blob_entries_vtab *p =\n      (vec_static_blob_entries_vtab *)pCur->base.pVtab;\n  switch (pCur->query_plan) {\n  case VEC_SBE__QUERYPLAN_FULLSCAN: {\n    return (size_t)pCur->iRowid >= p->blob->nvectors;\n  }\n  case VEC_SBE__QUERYPLAN_KNN: {\n    return pCur->knn_data->current_idx >= pCur->knn_data->k;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic int vec_static_blob_entriesColumn(sqlite3_vtab_cursor *cur,\n                                         sqlite3_context *context, int i) {\n  vec_static_blob_entries_cursor *pCur = (vec_static_blob_entries_cursor *)cur;\n  vec_static_blob_entries_vtab *p = (vec_static_blob_entries_vtab *)cur->pVtab;\n\n  switch (pCur->query_plan) {\n  case VEC_SBE__QUERYPLAN_FULLSCAN: {\n    switch (i) {\n    case VEC_STATIC_BLOB_ENTRIES_VECTOR:\n\n      sqlite3_result_blob(\n          context,\n          ((unsigned char *)p->blob->p) +\n              (pCur->iRowid * p->blob->dimensions * sizeof(float)),\n          p->blob->dimensions * sizeof(float), SQLITE_TRANSIENT);\n      sqlite3_result_subtype(context, p->blob->element_type);\n      break;\n    }\n    return SQLITE_OK;\n  }\n  case VEC_SBE__QUERYPLAN_KNN: {\n    switch (i) {\n    case VEC_STATIC_BLOB_ENTRIES_VECTOR: {\n      i32 rowid = ((i32 *)pCur->knn_data->rowids)[pCur->knn_data->current_idx];\n      sqlite3_result_blob(context,\n                          ((unsigned char *)p->blob->p) +\n                              (rowid * p->blob->dimensions * sizeof(float)),\n                          p->blob->dimensions * sizeof(float),\n                          SQLITE_TRANSIENT);\n      sqlite3_result_subtype(context, p->blob->element_type);\n      break;\n    }\n    }\n    return SQLITE_OK;\n  }\n  }\n  return SQLITE_ERROR;\n}\n\nstatic sqlite3_module vec_static_blob_entriesModule = {\n    /* iVersion    */ 3,\n    /* xCreate     */\n    vec_static_blob_entriesCreate, // handle rm?\n                                   // https://github.com/asg017/sqlite-vec/issues/55\n    /* xConnect    */ vec_static_blob_entriesConnect,\n    /* xBestIndex  */ vec_static_blob_entriesBestIndex,\n    /* xDisconnect */ vec_static_blob_entriesDisconnect,\n    /* xDestroy    */ vec_static_blob_entriesDisconnect,\n    /* xOpen       */ vec_static_blob_entriesOpen,\n    /* xClose      */ vec_static_blob_entriesClose,\n    /* xFilter     */ vec_static_blob_entriesFilter,\n    /* xNext       */ vec_static_blob_entriesNext,\n    /* xEof        */ vec_static_blob_entriesEof,\n    /* xColumn     */ vec_static_blob_entriesColumn,\n    /* xRowid      */ vec_static_blob_entriesRowid,\n    /* xUpdate     */ 0,\n    /* xBegin      */ 0,\n    /* xSync       */ 0,\n    /* xCommit     */ 0,\n    /* xRollback   */ 0,\n    /* xFindMethod */ 0,\n    /* xRename     */ 0,\n    /* xSavepoint  */ 0,\n    /* xRelease    */ 0,\n    /* xRollbackTo */ 0,\n    /* xShadowName */ 0,\n#if SQLITE_VERSION_NUMBER >= 3044000\n    /* xIntegrity  */ 0\n#endif\n};\n#pragma endregion\n\n#ifdef SQLITE_VEC_ENABLE_AVX\n#define SQLITE_VEC_DEBUG_BUILD_AVX \"avx\"\n#else\n#define SQLITE_VEC_DEBUG_BUILD_AVX \"\"\n#endif\n#ifdef SQLITE_VEC_ENABLE_NEON\n#define SQLITE_VEC_DEBUG_BUILD_NEON \"neon\"\n#else\n#define SQLITE_VEC_DEBUG_BUILD_NEON \"\"\n#endif\n\n#define SQLITE_VEC_DEBUG_BUILD                                                 \\\n  SQLITE_VEC_DEBUG_BUILD_AVX \" \" SQLITE_VEC_DEBUG_BUILD_NEON\n\n#define SQLITE_VEC_DEBUG_STRING                                                \\\n  \"Version: \" SQLITE_VEC_VERSION \"\\n\"                                          \\\n  \"Date: \" SQLITE_VEC_DATE \"\\n\"                                                \\\n  \"Commit: \" SQLITE_VEC_SOURCE \"\\n\"                                            \\\n  \"Build flags: \" SQLITE_VEC_DEBUG_BUILD\n\nSQLITE_VEC_API int sqlite3_vec_init(sqlite3 *db, char **pzErrMsg,\n                                    const sqlite3_api_routines *pApi) {\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT2(pApi);\n#endif\n  int rc = SQLITE_OK;\n\n#define DEFAULT_FLAGS (SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC)\n\n  rc = sqlite3_create_function_v2(db, \"vec_version\", 0, DEFAULT_FLAGS,\n                                  SQLITE_VEC_VERSION, _static_text_func, NULL,\n                                  NULL, NULL);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n  rc = sqlite3_create_function_v2(db, \"vec_debug\", 0, DEFAULT_FLAGS,\n                                  SQLITE_VEC_DEBUG_STRING, _static_text_func,\n                                  NULL, NULL, NULL);\n  if (rc != SQLITE_OK) {\n    return rc;\n  }\n  static struct {\n    const char *zFName;\n    void (*xFunc)(sqlite3_context *, int, sqlite3_value **);\n    int nArg;\n    int flags;\n  } aFunc[] = {\n      // clang-format off\n    //{\"vec_version\",         _static_text_func,    0, DEFAULT_FLAGS,                                          (void *) SQLITE_VEC_VERSION },\n    //{\"vec_debug\",           _static_text_func,    0, DEFAULT_FLAGS,                                          (void *) SQLITE_VEC_DEBUG_STRING },\n    {\"vec_distance_l2\",     vec_distance_l2,      2, DEFAULT_FLAGS | SQLITE_SUBTYPE,                         },\n    {\"vec_distance_l1\",     vec_distance_l1,      2, DEFAULT_FLAGS | SQLITE_SUBTYPE,                         },\n    {\"vec_distance_hamming\",vec_distance_hamming, 2, DEFAULT_FLAGS | SQLITE_SUBTYPE,                         },\n    {\"vec_distance_cosine\", vec_distance_cosine,  2, DEFAULT_FLAGS | SQLITE_SUBTYPE,                         },\n    {\"vec_length\",          vec_length,           1, DEFAULT_FLAGS | SQLITE_SUBTYPE,                         },\n    {\"vec_type\",           vec_type,           1, DEFAULT_FLAGS,                         },\n    {\"vec_to_json\",         vec_to_json,          1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_add\",             vec_add,              2, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_sub\",             vec_sub,              2, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_slice\",           vec_slice,            3, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_normalize\",       vec_normalize,        1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_f32\",             vec_f32,              1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_bit\",             vec_bit,              1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_int8\",            vec_int8,             1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_quantize_int8\",     vec_quantize_int8,      2, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n    {\"vec_quantize_binary\", vec_quantize_binary,  1, DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, },\n      // clang-format on\n  };\n\n  static struct {\n    char *name;\n    const sqlite3_module *module;\n    void *p;\n    void (*xDestroy)(void *);\n  } aMod[] = {\n      // clang-format off\n    {\"vec0\",          &vec0Module,          NULL, NULL},\n    {\"vec_each\",      &vec_eachModule,      NULL, NULL},\n      // clang-format on\n  };\n\n  for (unsigned long i = 0; i < countof(aFunc) && rc == SQLITE_OK; i++) {\n    rc = sqlite3_create_function_v2(db, aFunc[i].zFName, aFunc[i].nArg,\n                                    aFunc[i].flags, NULL, aFunc[i].xFunc, NULL,\n                                    NULL, NULL);\n    if (rc != SQLITE_OK) {\n      *pzErrMsg = sqlite3_mprintf(\"Error creating function %s: %s\",\n                                  aFunc[i].zFName, sqlite3_errmsg(db));\n      return rc;\n    }\n  }\n\n  for (unsigned long i = 0; i < countof(aMod) && rc == SQLITE_OK; i++) {\n    rc = sqlite3_create_module_v2(db, aMod[i].name, aMod[i].module, NULL, NULL);\n    if (rc != SQLITE_OK) {\n      *pzErrMsg = sqlite3_mprintf(\"Error creating module %s: %s\", aMod[i].name,\n                                  sqlite3_errmsg(db));\n      return rc;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_VEC_OMIT_FS\nSQLITE_VEC_API int sqlite3_vec_numpy_init(sqlite3 *db, char **pzErrMsg,\n                                            const sqlite3_api_routines *pApi) {\n  UNUSED_PARAMETER(pzErrMsg);\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT2(pApi);\n#endif\n  int rc = SQLITE_OK;\n  rc = sqlite3_create_function_v2(db, \"vec_npy_file\", 1, SQLITE_RESULT_SUBTYPE,\n                                  NULL, vec_npy_file, NULL, NULL, NULL);\n  if(rc != SQLITE_OK) {\n    return rc;\n  }\n  rc = sqlite3_create_module_v2(db, \"vec_npy_each\", &vec_npy_eachModule, NULL, NULL);\n  return rc;\n}\n#endif\n\nSQLITE_VEC_API int\nsqlite3_vec_static_blobs_init(sqlite3 *db, char **pzErrMsg,\n                              const sqlite3_api_routines *pApi) {\n  UNUSED_PARAMETER(pzErrMsg);\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT2(pApi);\n#endif\n\n  int rc = SQLITE_OK;\n  vec_static_blob_data *static_blob_data;\n  static_blob_data = sqlite3_malloc(sizeof(*static_blob_data));\n  if (!static_blob_data) {\n    return SQLITE_NOMEM;\n  }\n  memset(static_blob_data, 0, sizeof(*static_blob_data));\n\n  rc = sqlite3_create_function_v2(\n      db, \"vec_static_blob_from_raw\", 4,\n      DEFAULT_FLAGS | SQLITE_SUBTYPE | SQLITE_RESULT_SUBTYPE, NULL,\n      vec_static_blob_from_raw, NULL, NULL, NULL);\n  if (rc != SQLITE_OK)\n    return rc;\n\n  rc = sqlite3_create_module_v2(db, \"vec_static_blobs\", &vec_static_blobsModule,\n                                static_blob_data, sqlite3_free);\n  if (rc != SQLITE_OK)\n    return rc;\n  rc = sqlite3_create_module_v2(db, \"vec_static_blob_entries\",\n                                &vec_static_blob_entriesModule,\n                                static_blob_data, NULL);\n  if (rc != SQLITE_OK)\n    return rc;\n  return rc;\n}\n"
        },
        {
          "name": "sqlite-vec.h.tmpl",
          "type": "blob",
          "size": 0.8115234375,
          "content": "#ifndef SQLITE_VEC_H\n#define SQLITE_VEC_H\n\n#ifndef SQLITE_CORE\n#include \"sqlite3ext.h\"\n#else\n#include \"sqlite3.h\"\n#endif\n\n#ifdef SQLITE_VEC_STATIC\n  #define SQLITE_VEC_API\n#else\n  #ifdef _WIN32\n    #define SQLITE_VEC_API __declspec(dllexport)\n  #else\n    #define SQLITE_VEC_API\n  #endif\n#endif\n\n#define SQLITE_VEC_VERSION \"v${VERSION}\"\n// TODO rm\n#define SQLITE_VEC_DATE \"${DATE}\"\n#define SQLITE_VEC_SOURCE \"${SOURCE}\"\n\n\n#define SQLITE_VEC_VERSION_MAJOR ${VERSION_MAJOR}\n#define SQLITE_VEC_VERSION_MINOR ${VERSION_MINOR}\n#define SQLITE_VEC_VERSION_PATCH ${VERSION_PATCH}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nSQLITE_VEC_API int sqlite3_vec_init(sqlite3 *db, char **pzErrMsg,\n                  const sqlite3_api_routines *pApi);\n\n#ifdef __cplusplus\n}  /* end of the 'extern \"C\"' block */\n#endif\n\n#endif /* ifndef SQLITE_VEC_H */\n"
        },
        {
          "name": "test.sql",
          "type": "blob",
          "size": 16.365234375,
          "content": "\n.load dist/vec0main\n.bail on\n\n.mode qbox\n\n\n.load ./memstat\n.echo on\n\nselect name, value from sqlite_memstat where name = 'MEMORY_USED';\n\ncreate virtual table v using vec0(\n  vector float[1],\n  name1 text,\n  name2 text,\n  age int,\n  chunk_size=8\n);\n\nselect name, value from sqlite_memstat where name = 'MEMORY_USED';\n\ninsert into v(vector, name1, name2, age) values\n  ('[1]', 'alex', 'xxxx', 1),\n  ('[2]', 'alex', 'aaaa', 2),\n  ('[3]', 'alex', 'aaaa', 3),\n  ('[4]', 'brian', 'aaaa', 1),\n  ('[5]', 'brian', 'aaaa', 2),\n  ('[6]', 'brian', 'aaaa', 3),\n  ('[7]', 'craig', 'aaaa', 1),\n  ('[8]', 'craig', 'xxxx', 2),\n  ('[9]', 'craig', 'xxxx', 3),\n  ('[10]', '123456789012345', 'xxxx', 3);\n\nselect name, value from sqlite_memstat where name = 'MEMORY_USED';\n\nselect rowid, name1, name2, age, vec_to_json(vector)\nfrom v\nwhere vector match '[0]'\n  and k = 5\n  and name1 in ('alex', 'brian', 'craig')\n  --and name2 in ('aaaa', 'xxxx')\n  and age in (1, 2, 3, 2222,3333,4444);\n\nselect name, value from sqlite_memstat where name = 'MEMORY_USED';\n\nselect rowid, name1, name2, age, vec_to_json(vector)\nfrom v\nwhere vector match '[0]'\n  and k = 5\n  and name1 in ('123456789012345', 'superfluous');\n\n\n.exit\n\ncreate virtual table v using vec0(\n  vector float[1],\n  +description text\n);\ninsert into v(rowid, vector, description) values (1, '[1]', 'aaa');\nselect * from v;\n\n.exit\n\ncreate virtual table vec_articles using vec0(\n  article_id integer primary key,\n  year integer partition key,\n  headline_embedding float[1],\n  +headline text,\n  +url text,\n  word_count integer,\n  print_section text,\n  print_page integer,\n  pub_date text,\n);\n\ninsert into vec_articles values (1111, 2020, '[1]', 'headline', 'https://...', 200, 'A', 1, '2020-01-01');\n\nselect * from vec_articles;\n\n.exit\n\n\ncreate table movies(movie_id integer primary key, synopsis text);\nINSERT INTO movies(movie_id, synopsis)\nVALUES\n  (1, 'A family is haunted by demonic spirits after moving into a new house, requiring the help of paranormal investigators.'),\n  (2, 'Two dim-witted friends embark on a cross-country road trip to return a briefcase full of money to its owner.'),\n  (3, 'A team of explorers travels through a wormhole in space in an attempt to ensure humanity’s survival.'),\n  (4, 'A young hobbit embarks on a journey with a fellowship to destroy a powerful ring and save Middle-earth from darkness.'),\n  (5, 'A documentary about the dangers of global warming, featuring former U.S. Vice President Al Gore.'),\n  (6, 'After the death of her secretive mother, a woman discovers terrifying secrets about her family lineage.'),\n  (7, 'A clueless but charismatic TV anchorman struggles to stay relevant in the world of broadcast journalism.'),\n  (8, 'A young blade runner uncovers a long-buried secret that leads him to track down former blade runner Rick Deckard.'),\n  (9, 'A young boy discovers he is a wizard and attends a magical school, where he learns about his destiny.'),\n  (10, 'A rock climber attempts to scale El Capitan in Yosemite National Park without the use of ropes or safety gear.'),\n  (11, 'A young African-American man uncovers a disturbing secret when he visits his white girlfriend''s family estate.'),\n  (12, 'Three friends wake up from a bachelor party in Las Vegas with no memory of the previous night and must retrace their steps.'),\n  (13, 'A computer hacker learns about the true nature of his reality and his role in the war against its controllers.'),\n  (14, 'In post-Civil War Spain, a young girl escapes into an eerie but captivating fantasy world.'),\n  (15, 'A documentary that explores racial inequality in the United States, focusing on the prison system and mass incarceration.'),\n  (16, 'A young woman is followed by an unknown supernatural force after a sexual encounter.'),\n  (17, 'Two immature but well-meaning stepbrothers become instant rivals when their single parents marry.'),\n  (18, 'A thief with the ability to enter people''s dreams is tasked with planting an idea into a target''s subconscious.'),\n  (19, 'A mute woman forms a unique relationship with a mysterious aquatic creature being held in a secret research facility.'),\n  (20, 'A documentary about the life and legacy of Fred Rogers, the beloved host of the children''s TV show \"Mister Rogers'' Neighborhood.\"');\n\n\ncreate virtual table vec_movies using vec0(\n  movie_id integer primary key,\n  synopsis_embedding float[1],\n  +title text,\n  genre text,\n  num_reviews int,\n  mean_rating float,\n  chunk_size=8\n);\n\n.schema\n/*\ninsert into vec_movies(movie_id, synopsis_embedding, num_reviews, mean_rating) values\n  (1, '[1]', 153, 4.6),\n  (2, '[2]', 382, 2.6),\n  (3, '[3]', 53, 5.0),\n  (4, '[4]', 210, 4.2),\n  (5, '[5]', 93, 3.4),\n  (6, '[6]', 167, 4.7),\n  (7, '[7]', 482, 2.9),\n  (8, '[8]', 301, 5.0),\n  (9, '[9]', 134, 4.1),\n  (10, '[10]', 66, 3.2),\n  (11, '[11]', 88, 4.9),\n  (12, '[12]', 59, 2.8),\n  (13, '[13]', 423, 4.5),\n  (14, '[14]', 275, 3.6),\n  (15, '[15]', 191, 4.4),\n  (16, '[16]', 314, 4.3),\n  (17, '[17]', 74, 3.0),\n  (18, '[18]', 201, 5.0),\n  (19, '[19]', 399, 2.7),\n  (20, '[20]', 186, 4.8);\n*/\n\n/*\n\nINSERT INTO vec_movies(movie_id, synopsis_embedding, genre, num_reviews, mean_rating)\nVALUES\n  (1, '[1]', 'horror', 153, 4.6),\n  (2, '[2]', 'comedy', 382, 2.6),\n  (3, '[3]', 'scifi', 53, 5.0),\n  (4, '[4]', 'fantasy', 210, 4.2),\n  (5, '[5]', 'documentary', 93, 3.4),\n  (6, '[6]', 'horror', 167, 4.7),\n  (7, '[7]', 'comedy', 482, 2.9),\n  (8, '[8]', 'scifi', 301, 5.0),\n  (9, '[9]', 'fantasy', 134, 4.1),\n  (10, '[10]', 'documentary', 66, 3.2),\n  (11, '[11]', 'horror', 88, 4.9),\n  (12, '[12]', 'comedy', 59, 2.8),\n  (13, '[13]', 'scifi', 423, 4.5),\n  (14, '[14]', 'fantasy', 275, 3.6),\n  (15, '[15]', 'documentary', 191, 4.4),\n  (16, '[16]', 'horror', 314, 4.3),\n  (17, '[17]', 'comedy', 74, 3.0),\n  (18, '[18]', 'scifi', 201, 5.0),\n  (19, '[19]', 'fantasy', 399, 2.7),\n  (20, '[20]', 'documentary', 186, 4.8);\n*/\n\nINSERT INTO vec_movies(movie_id, synopsis_embedding, genre, title, num_reviews, mean_rating)\nVALUES\n  (1, '[1]', 'horror', 'The Conjuring', 153, 4.6),\n  (2, '[2]', 'comedy', 'Dumb and Dumber', 382, 2.6),\n  (3, '[3]', 'scifi', 'Interstellar', 53, 5.0),\n  (4, '[4]', 'fantasy', 'The Lord of the Rings: The Fellowship of the Ring', 210, 4.2),\n  (5, '[5]', 'documentary', 'An Inconvenient Truth', 93, 3.4),\n  (6, '[6]', 'horror', 'Hereditary', 167, 4.7),\n  (7, '[7]', 'comedy', 'Anchorman: The Legend of Ron Burgundy', 482, 2.9),\n  (8, '[8]', 'scifi', 'Blade Runner 2049', 301, 5.0),\n  (9, '[9]', 'fantasy', 'Harry Potter and the Sorcerer''s Stone', 134, 4.1),\n  (10, '[10]', 'documentary', 'Free Solo', 66, 3.2),\n  (11, '[11]', 'horror', 'Get Out', 88, 4.9),\n  (12, '[12]', 'comedy', 'The Hangover', 59, 2.8),\n  (13, '[13]', 'scifi', 'The Matrix', 423, 4.5),\n  (14, '[14]', 'fantasy', 'Pan''s Labyrinth', 275, 3.6),\n  (15, '[15]', 'documentary', '13th', 191, 4.4),\n  (16, '[16]', 'horror', 'It Follows', 314, 4.3),\n  (17, '[17]', 'comedy', 'Step Brothers', 74, 3.0),\n  (18, '[18]', 'scifi', 'Inception', 201, 5.0),\n  (19, '[19]', 'fantasy', 'The Shape of Water', 399, 2.7),\n  (20, '[20]', 'documentary', 'Won''t You Be My Neighbor?', 186, 4.8),\n  (21, '[21]', 'scifi', 'Gravity', 342, 4.0),\n  (22, '[22]', 'scifi', 'Dune', 451, 4.4),\n  (23, '[23]', 'scifi', 'The Martian', 522, 4.6),\n  (24, '[24]', 'horror', 'A Quiet Place', 271, 4.3),\n  (25, '[25]', 'fantasy', 'The Chronicles of Narnia: The Lion, the Witch and the Wardrobe', 310, 3.9);\n\n--select * from vec_movies;\n--select * from vec_movies_metadata_chunks00;\n\n\ncreate virtual table vec_chunks using vec0(\n  user_id integer partition key,\n  +contents text,\n  contents_embedding float[1],\n);\n\nINSERT INTO vec_chunks (rowid, user_id, contents, contents_embedding) VALUES\n(1, 123, 'Our PTO policy allows employees to take both vacation and sick leave as needed.', '[1]'),\n(2, 123, 'Employees must provide notice at least two weeks in advance for planned vacations.', '[2]'),\n(3, 123, 'Sick leave can be taken without advance notice, but employees must inform their manager.', '[3]'),\n(4, 123, 'Unused PTO can be carried over to the following year, up to a maximum of 40 hours.', '[4]'),\n(5, 123, 'PTO must be used in increments of at least 4 hours.', '[5]'),\n(6, 456, 'New employees are granted 10 days of PTO during their first year of employment.', '[6]'),\n(7, 456, 'After the first year, employees earn an additional day of PTO for each year of service.', '[7]'),\n(8, 789, 'PTO requests will be reviewed by the HR department and are subject to approval.', '[8]'),\n(9, 789, 'The company reserves the right to deny PTO requests during peak operational periods.', '[9]'),\n(10, 456, 'If PTO is denied, the employee will be given an alternative time to take leave.', '[10]'),\n(11, 789, 'Employees who are out of PTO must request unpaid leave for any additional time off.', '[11]'),\n(12, 789, 'In case of a family emergency, employees can request emergency leave.', '[12]'),\n(13, 456, 'Emergency leave may be granted for personal or family illness, or other critical situations.', '[13]'),\n(14, 789, 'The maximum length of emergency leave is subject to company discretion.', '[14]'),\n(15, 123, 'All PTO balances will be displayed on the employee self-service portal.', '[15]'),\n(16, 456, 'Employees who are terminated will be paid for unused PTO, as per state law.', '[16]'),\n(17, 123, 'Part-time employees are eligible for PTO on a pro-rata basis.', '[17]'),\n(18, 789, 'The company encourages employees to use their PTO to maintain work-life balance.', '[18]'),\n(19, 456, 'Employees should not book travel plans until their PTO request has been approved.', '[19]'),\n(20, 123, 'Managers are responsible for tracking their team members'' PTO usage.', '[20]');\n\nselect rowid, user_id, contents, distance\nfrom vec_chunks\nwhere contents_embedding match '[19]'\n  and user_id = 123\n  and k = 5;\n\n.exit\n\n\n\n\n\n-- PARTITION KEY and auxiliar columns!\ncreate virtual table vec_chunks using vec0(\n  -- internally shard the vector index by user\n  user_id integer partition key,\n  -- store the chunk text pre-embedding as an \"auxiliary column\"\n  +contents text,\n  contents_embeddings float[1024],\n);\n\nselect rowid, user_id, contents, distance\nfrom vec_chunks\nwhere contents_embedding match '[...]'\n  and user_id = 123\n  and k = 5;\n/*\n┌───────┬─────────┬──────────────────────────────────────────────────────────────┬──────────┐\n│ rowid │ user_id │                           contents                           │ distance │\n├───────┼─────────┼──────────────────────────────────────────────────────────────┼──────────┤\n│ 20    │ 123     │ 'Managers are responsible for tracking their team members''  │ 1.0      │\n│       │         │ PTO usage.'                                                  │          │\n├───────┼─────────┼──────────────────────────────────────────────────────────────┼──────────┤\n│ 17    │ 123     │ 'Part-time employees are eligible for PTO on a pro-rata basi │ 2.0      │\n│       │         │ s.'                                                          │          │\n├───────┼─────────┼──────────────────────────────────────────────────────────────┼──────────┤\n│ 15    │ 123     │ 'All PTO balances will be displayed on the employee self-ser │ 4.0      │\n│       │         │ vice portal.'                                                │          │\n├───────┼─────────┼──────────────────────────────────────────────────────────────┼──────────┤\n│ 5     │ 123     │ 'PTO must be used in increments of at least 4 hours.'        │ 14.0     │\n├───────┼─────────┼──────────────────────────────────────────────────────────────┼──────────┤\n│ 4     │ 123     │ 'Unused PTO can be carried over to the following year, up to │ 15.0     │\n│       │         │  a maximum of 40 hours.'                                     │          │\n└───────┴─────────┴──────────────────────────────────────────────────────────────┴──────────┘\n*/\n\n\n\n\n\n-- metadata filters!\ncreate virtual table vec_movies using vec0(\n  movie_id integer primary key,\n  synopsis_embedding float[1024],\n  genre text,\n  num_reviews int,\n  mean_rating float\n);\n\nselect\n  movie_id,\n  title,\n  genre,\n  num_reviews,\n  mean_rating,\n  distance\nfrom vec_movies\nwhere synopsis_embedding match '[15.5]'\n  and genre = 'scifi'\n  and num_reviews between 100 and 500\n  and mean_rating > 3.5\n  and k = 5;\n/*\n┌──────────┬─────────────────────┬─────────┬─────────────┬──────────────────┬──────────┐\n│ movie_id │        title        │  genre  │ num_reviews │   mean_rating    │ distance │\n├──────────┼─────────────────────┼─────────┼─────────────┼──────────────────┼──────────┤\n│ 13       │ 'The Matrix'        │ 'scifi' │ 423         │ 4.5              │ 2.5      │\n│ 18       │ 'Inception'         │ 'scifi' │ 201         │ 5.0              │ 2.5      │\n│ 21       │ 'Gravity'           │ 'scifi' │ 342         │ 4.0              │ 5.5      │\n│ 22       │ 'Dune'              │ 'scifi' │ 451         │ 4.40000009536743 │ 6.5      │\n│ 8        │ 'Blade Runner 2049' │ 'scifi' │ 301         │ 5.0              │ 7.5      │\n└──────────┴─────────────────────┴─────────┴─────────────┴──────────────────┴──────────┘\n*/\n\n\n\n\n.exit\n\ncreate virtual table vec_movies using vec0(\n  movie_id integer primary key,\n  synopsis_embedding float[768],\n  genre text,\n  num_reviews int,\n  mean_rating float,\n);\n\n\n.exit\n\n\ncreate virtual table vec_chunks using vec0(\n  chunk_id integer primary key,\n  contents_embedding float[1],\n  +contents text\n);\ninsert into vec_chunks(chunk_id, contents_embedding, contents) values\n  (1, '[1]', 'alex'),\n  (2, '[2]', 'brian'),\n  (3, '[3]', 'craig'),\n  (4, '[4]', 'dylan');\n\nselect * from vec_chunks;\n\nselect chunk_id, contents, distance\nfrom vec_chunks\nwhere contents_embedding match '[5]'\nand k = 3;\n\n.exit\n\ncreate virtual table v using vec0(a float[1]);\nselect count(*) from v_chunks;\ninsert into v(a) values ('[1.11]');\nselect * from v;\ndrop table v;\n\ncreate virtual table v using vec0(\n\n  v_aaa float[1],\n  partk_xxx int partition key,\n  v_bbb float[2],\n  partk_yyy text partition key,\n  chunk_size=32\n);\n\n\ninsert into v(rowid, v_aaa, partk_xxx, v_bbb, partk_yyy) values\n  (1, '[.1]', 999, '[.11, .11]', 'alex'),\n  (2, '[.2]', 999, '[.22, .22]', 'alex'),\n  (3, '[.3]', 999, '[.33, .33]', 'brian');\n\n\nselect rowid, vec_to_json(v_aaa), partk_xxx, vec_to_json(v_bbb), partk_yyy from v;\n\nselect * from v;\nselect * from v where rowid = 2;\nupdate v\nset v_aaa = '[.222]',\n  v_bbb = '[.222, .222]'\nwhere rowid = 2;\n\nselect rowid, vec_to_json(v_aaa), partk_xxx, vec_to_json(v_bbb), partk_yyy from v;\n\nselect chunk_id, size, sequence_id, partition00, partition01, (validity), length(rowids) from v_chunks;\n\n--explain query plan\nselect *, distance\nfrom v\nwhere v_aaa match '[.5]'\n  and partk_xxx = 999\n  and partk_yyy = 'alex'\n  --and partk_xxx != 20\n  and k = 5;\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmp-static.py",
          "type": "blob",
          "size": 1.62890625,
          "content": "import sqlite3\nimport numpy as np\n\ndb = sqlite3.connect(\":memory:\")\n\ndb.enable_load_extension(True)\ndb.load_extension(\"./dist/vec0\")\ndb.execute(\"select load_extension('./dist/vec0', 'sqlite3_vec_raw_init')\")\ndb.enable_load_extension(False)\n\nx = np.array([[0.1, 0.2, 0.3, 0.4], [0.9, 0.8, 0.7, 0.6]], dtype=np.float32)\ny = np.array([[0.2, 0.3], [0.9, 0.8], [0.6, 0.5]], dtype=np.float32)\nz = np.array(\n    [\n        [0.1, 0.1, 0.1, 0.1],\n        [0.2, 0.2, 0.2, 0.2],\n        [0.3, 0.3, 0.3, 0.3],\n        [0.4, 0.4, 0.4, 0.4],\n        [0.5, 0.5, 0.5, 0.5],\n    ],\n    dtype=np.float32,\n)\n\n\ndef register_np(array, name):\n    ptr = array.__array_interface__[\"data\"][0]\n    nvectors, dimensions = array.__array_interface__[\"shape\"]\n    element_type = array.__array_interface__[\"typestr\"]\n\n    assert element_type == \"<f4\"\n\n    name_escaped = db.execute(\"select printf('%w', ?)\", [name]).fetchone()[0]\n\n    db.execute(\n        \"insert into temp.vec_static_blobs(name, data) select ?, vec_static_blob_from_raw(?, ?, ?, ?)\",\n        [name, ptr, element_type, dimensions, nvectors],\n    )\n\n    db.execute(\n        f'create virtual table \"{name_escaped}\" using vec_static_blob_entries({name_escaped})'\n    )\n\n\nregister_np(x, \"x\")\nregister_np(y, \"y\")\nregister_np(z, \"z\")\nprint(db.execute(\"select *, dimensions, count from temp.vec_static_blobs;\").fetchall())\n\nprint(db.execute(\"select vec_to_json(vector) from x;\").fetchall())\nprint(db.execute(\"select (vector) from y limit 2;\").fetchall())\nprint(\n    db.execute(\n        \"select (vector) from z where vector match ? and k = 2 order by distance;\",\n        [np.array([0.3, 0.3, 0.3, 0.3], dtype=np.float32)],\n    ).fetchall()\n)\n"
        }
      ]
    }
  ]
}