{
  "metadata": {
    "timestamp": 1736709802202,
    "page": 256,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yarrick/pingfs",
      "stars": 3121,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "*.o\npingfs\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7333984375,
          "content": "Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3251953125,
          "content": "all: pingfs\n\nOBJS=icmp.o host.o pingfs.o fs.o net.o chunk.o\nLDFLAGS=-lanl -lrt `pkg-config fuse --libs`\nCFLAGS+=--std=c99 -Wall -Wshadow -pedantic -g `pkg-config fuse --cflags`\nCFLAGS+=-D_GNU_SOURCE -D_POSIX_C_SOURCE=200809 -D_XOPEN_SOURCE\n\npingfs: $(OBJS)\n\t$(CC) $(OBJS) -o $@ $(LDFLAGS)\n\n.PHONY=clean all\nclean:\n\trm -f *.o pingfs\n\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.0732421875,
          "content": "pingfs - \"True cloud storage\"\n\tby Erik Ekman <erik@kryo.se>\n\npingfs is a filesystem where the data is stored only in the Internet itself,\nas ICMP Echo packets (pings) travelling from you to remote servers and\nback again.\n\nIt is implemented using raw sockets and FUSE, so superuser powers are required.\nLinux is the only intended target OS, portability is not a goal.\nBoth IPv4 and IPv6 remote hosts are supported.\n\nCompile by just running 'make'\n\nHow to start it:\n- Create a textfile with hostname and IP addresses to target\n- As root, run ./pingfs <filename> <mountpoint>\n  It will resolve all hostnames, and then test each resolved address\n  if it responds properly to a number of pings.\n  Some statistics will be printed and then the filesystem will be mounted.\n- Pingfs will stay in the foreground and print stats on packets and bytes\n  each second.\n\nHow to stop it:\n- Stop with ^C, and it should unmount itself.\n- Otherwise unmount with fusermount -u <mountpoint>\n\nSupported operations\n- Creating/removing normal files\n- Listing files\n- Renaming files\n- Reading/writing/truncating files\n- Setting/getting file permissions\n\nUnsupported operations\n- Creating/removing directories\n- Creating soft/hard links\n- Timestamps (they are always 0)\n\nNotes:\nThe performance is too low right now to handle LAN hosts, it will\nlose data right away. Use pingfs with care.\n\nLicense:\n\nCopyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "chunk.c",
          "type": "blob",
          "size": 4.5390625,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include \"chunk.h\"\n#include \"host.h\"\n#include \"net.h\"\n\n#include <time.h>\n#include <pthread.h>\n#include <errno.h>\n\nenum io_owner {\n\tOWNER_FS = 1,\n\tOWNER_NET = 2,\n};\n\nstruct io {\n\tpthread_cond_t fs_cond;\n\tpthread_cond_t net_cond;\n\tpthread_mutex_t mutex;\n\tenum io_owner owner;\n\tuint8_t *data;\n\tsize_t len;\n};\n\nstatic uint16_t icmp_id;\nstatic int timeout;\n\nstatic struct chunk *chunk_head;\nstatic pthread_mutex_t chunk_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid chunk_set_timeout(int t)\n{\n\ttimeout = t;\n}\n\nstruct chunk *chunk_create()\n{\n\tstruct chunk *c;\n\n\tc = calloc(1, sizeof(*c));\n\tif (!c)\n\t\treturn NULL;\n\n\t/* TODO can give duplicate ids after some time\n\t * if objects have varying lifetime */\n\tc->id = icmp_id++;\n\n\treturn c;\n}\n\nvoid chunk_free(struct chunk *c)\n{\n\tfree(c);\n}\n\nvoid chunk_add(struct chunk *c)\n{\n\tpthread_mutex_lock(&chunk_mutex);\n\tc->next_active = chunk_head;\n\tchunk_head = c;\n\tpthread_mutex_unlock(&chunk_mutex);\n}\n\nvoid chunk_remove(struct chunk *c)\n{\n\tstruct chunk *prev, *curr;\n\n\tprev = NULL;\n\tpthread_mutex_lock(&chunk_mutex);\n\tcurr = chunk_head;\n\twhile (curr) {\n\t\tif (curr == c) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next_active = curr->next_active;\n\t\t\t} else {\n\t\t\t\tchunk_head = curr->next_active;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = curr->next_active;\n\t}\n\tpthread_mutex_unlock(&chunk_mutex);\n}\n\nstatic void process_chunk(struct chunk *c, uint8_t **data)\n{\n\tc->seqno++;\n\tif (c->io) {\n\t\tstruct io *io = c->io;\n\t\tpthread_mutex_lock(&io->mutex);\n\t\tio->data = *data;\n\t\tio->len = c->len;\n\t\tio->owner = OWNER_FS;\n\t\tpthread_cond_signal(&io->fs_cond);\n\t\t/* Wait while fs thread works, sets owner back and signals */\n\t\twhile (io->owner != OWNER_NET)\n\t\t\tpthread_cond_wait(&io->net_cond, &io->mutex);\n\t\t*data = io->data;\n\t\tpthread_mutex_unlock(&io->mutex);\n\t\tfree(c->io);\n\t\tc->io = NULL;\n\t}\n\tnet_send(c->host, c->id, c->seqno, *data, c->len);\n}\n\nvoid chunk_reply(void *userdata, struct sockaddr_storage *addr,\n\tsize_t addrlen, uint16_t id, uint16_t seqno, uint8_t **data, size_t len)\n{\n\tstruct chunk *c;\n\tpthread_mutex_lock(&chunk_mutex);\n\tc = chunk_head;\n\twhile (c) {\n\t\tif (c->id == id) {\n\t\t\tnet_inc_rx(len);\n\t\t\tif (len == c->len && seqno == c->seqno) {\n\t\t\t\tprocess_chunk(c, data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tc = c->next_active;\n\t}\n\tpthread_mutex_unlock(&chunk_mutex);\n}\n\n/* Call from fs thread to wait until chunk arrives or timeout.\n * When data comes from icmp it is pointed to in data argument,\n * and the function returns the length of it.\n * Must call chunk_done() after when done */\nint chunk_wait_for(struct chunk *c, uint8_t **data)\n{\n\tpthread_mutex_lock(&chunk_mutex);\n\tif (c->io) {\n\t\tpthread_mutex_unlock(&chunk_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tc->io = calloc(1, sizeof(struct io));\n\tif (!c->io) {\n\t\tpthread_mutex_unlock(&chunk_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tpthread_mutex_unlock(&chunk_mutex);\n\tc->io->owner = OWNER_NET;\n\tpthread_cond_init(&c->io->fs_cond, NULL);\n\tpthread_cond_init(&c->io->net_cond, NULL);\n\tif (pthread_mutex_init(&c->io->mutex, NULL)) {\n\t\tpthread_mutex_unlock(&chunk_mutex);\n\t\tfree(c->io);\n\t\treturn -errno;\n\t}\n\n\tpthread_mutex_lock(&c->io->mutex);\n\twhile (c->io->owner != OWNER_FS) {\n\t\tint res;\n\t\tstruct timespec ts;\n\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\t\tts.tv_sec += timeout;\n\t\tres = pthread_cond_timedwait(&c->io->fs_cond,\n\t\t\t&c->io->mutex, &ts);\n\t\tif (res) {\n\t\t\t/* Timeout, data is lost */\n\t\t\tpthread_mutex_unlock(&c->io->mutex);\n\t\t\tpthread_mutex_lock(&chunk_mutex);\n\t\t\tfree(c->io);\n\t\t\tc->io = NULL;\n\t\t\tpthread_mutex_unlock(&chunk_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Still holding io->mutex here */\n\t*data = c->io->data;\n\treturn c->io->len;\n}\n\n/* Put back new data, let net thread continue */\nvoid chunk_done(struct chunk *c, uint8_t *data, size_t len)\n{\n\tc->io->data = data;\n\tc->io->len = len;\n\tc->len = c->io->len;\n\tc->io->owner = OWNER_NET;\n\n\tpthread_cond_signal(&c->io->net_cond);\n\tpthread_mutex_unlock(&c->io->mutex);\n}\n"
        },
        {
          "name": "chunk.h",
          "type": "blob",
          "size": 1.802734375,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#ifndef PINGFS_CHUNK_H_\n#define PINGFS_CHUNK_H_\n\n#include <stdint.h>\n#include <sys/socket.h>\n\n#define CHUNK_SIZE 1024\n\nstruct host;\n\nstruct io;\n\nstruct chunk {\n\t/* Link for list of all active chunks */\n\tstruct chunk *next_active;\n\t/* Link for list of chunks in this same file */\n\tstruct chunk *next_file;\n\tstruct host *host;\n\tstruct io *io;\n\tuint16_t id;\n\tuint16_t seqno;\n\tuint16_t len;\n};\n\n/* Set timeout (seconds) waiting for packets */\nvoid chunk_set_timeout(int t);\n\n/* Allocate chunk and give it id and seqno */\nstruct chunk *chunk_create();\n\nvoid chunk_free(struct chunk *c);\n\n/* Add/remove chunk from active list */\nvoid chunk_add(struct chunk *c);\nvoid chunk_remove(struct chunk *c);\n\n/* Handle icmp reply */\nvoid chunk_reply(void *userdata, struct sockaddr_storage *addr,\n\tsize_t addrlen, uint16_t id, uint16_t seqno, uint8_t **data, size_t len);\n\n/* Ask for chunk from network, put back result */\nint chunk_wait_for(struct chunk *c, uint8_t **data);\nvoid chunk_done(struct chunk *c, uint8_t *data, size_t len);\n\n#endif /* PINGFS_CHUNK_H_ */\n"
        },
        {
          "name": "fs.c",
          "type": "blob",
          "size": 7.4765625,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include \"fs.h\"\n#include \"host.h\"\n#include \"net.h\"\n#include \"chunk.h\"\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <assert.h>\n\nstruct file {\n\tstruct file *next;\n\tconst char *name;\n\tstruct chunk *chunks;\n\tmode_t mode;\n};\n\nstruct file *files;\n\nstatic void fs_free(struct file *f)\n{\n\tstruct chunk *c, *next;\n\n\tc = f->chunks;\n\twhile (c) {\n\t\tnext = c->next_file;\n\t\tchunk_remove(c);\n\t\tchunk_free(c);\n\t\tc = next;\n\t}\n\tfree((void*) f->name);\n\tfree(f);\n}\n\nstatic size_t file_size(struct file *f)\n{\n\tstruct chunk *c;\n\tsize_t size = 0;\n\n\tc = f->chunks;\n\twhile (c) {\n\t\tsize += c->len;\n\t\tc = c->next_file;\n\t}\n\treturn size;\n}\n\nstatic void *fs_init(struct fuse_conn_info *conn)\n{\n\tnet_start();\n\treturn NULL;\n}\n\nstatic void fs_destroy(void *data)\n{\n\tstruct file *f;\n\n\tnet_stop();\n\tf = files;\n\twhile (f) {\n\t\tstruct file *next = f->next;\n\t\tfs_free(f);\n\t\tf = next;\n\t}\n}\n\nstatic struct file *find_file(const char *name)\n{\n\tstruct file *f;\n\n\tf = files;\n\twhile (f) {\n\t\tif (strcmp(name, f->name) == 0)\n\t\t\treturn f;\n\t\tf = f->next;\n\t}\n\treturn NULL;\n}\n\nstatic int fs_mkdir(const char *name, mode_t mode)\n{\n\treturn -ENOTSUP;\n}\n\nstatic int fs_mknod(const char *name, mode_t mode, dev_t device)\n{\n\tstruct file *f;\n\n\t/* Only regular files */\n\tif (!S_ISREG(mode))\n\t\treturn -ENOTSUP;\n\n\tf = find_file(name);\n\tif (f)\n\t\treturn -EEXIST;\n\n\tf = calloc(1, sizeof(struct file));\n\tif (!f)\n\t\treturn -errno;\n\n\tf->name = strdup(name);\n\tf->mode = mode;\n\tf->next = files;\n\tfiles = f;\n\n\treturn 0;\n}\n\nstatic int fs_chmod(const char *name, mode_t mode)\n{\n\tstruct file *f;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\tf->mode = mode;\n\treturn 0;\n}\n\nstatic int fs_utime(const char *name, struct utimbuf *utim)\n{\n\tstruct file *f;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\t/* No-op */\n\treturn 0;\n}\n\nstatic int fs_getattr(const char *name, struct stat *stat)\n{\n\tstruct file *f;\n\n\tstat->st_nlink = 1;\n\tstat->st_uid = getuid();\n\tstat->st_gid = getgid();\n\tstat->st_atime = 0;\n\tstat->st_mtime = 0;\n\tstat->st_ctime = 0;\n\n\tif (strcmp(\"/\", name) == 0) {\n\t\tstat->st_mode = S_IFDIR | 0775;\n\t\tstat->st_size = 0;\n\t\tstat->st_blksize = 0;\n\t\tstat->st_blocks = 0;\n\t\treturn 0;\n\t}\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\tstat->st_mode = f->mode;\n\tstat->st_size = file_size(f);\n\treturn 0;\n}\n\nstatic int fs_unlink(const char *name)\n{\n\tstruct file *f = files;\n\tstruct file *last = NULL;\n\twhile (f) {\n\t\tif (strcmp(name, f->name) == 0) {\n\t\t\tif (last) {\n\t\t\t\tlast->next = f->next;\n\t\t\t} else {\n\t\t\t\tfiles = f->next;\n\t\t\t}\n\t\t\tfs_free(f);\n\t\t\treturn 0;\n\t\t}\n\t\tlast = f;\n\t\tf = f->next;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int fs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,\n\toff_t offset, struct fuse_file_info *fi)\n{\n\tstruct file *f;\n\tif (strcmp(\"/\", path)) {\n\t\treturn -ENOENT;\n\t}\n\tfiller(buf, \".\", NULL, 0);\n\tfiller(buf, \"..\", NULL, 0);\n\n\tf = files;\n\twhile (f) {\n\t\t/* Skip initial '/' in name */\n\t\tfiller(buf, &f->name[1], NULL, 0);\n\t\tf = f->next;\n\t}\n\n\treturn 0;\n}\n\nstatic int fs_open(const char *name, struct fuse_file_info *fileinfo)\n{\n\tstruct file *f;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int fs_inner_write(struct file *f, const char *buf, size_t size,\n\toff_t offset)\n{\n\tstruct chunk *c;\n\tstruct chunk *last = NULL;\n\tuint8_t *chunkdata;\n\tint len;\n\tint clen;\n\n\tc = f->chunks;\n\twhile (c && offset >= c->len) {\n\t\tif (c->len != CHUNK_SIZE) {\n\t\t\t/* Extend this chunk instead\n\t\t\t * of creating new */\n\t\t\tbreak;\n\t\t}\n\t\toffset -= c->len;\n\t\tlast = c;\n\t\tc = c->next_file;\n\t}\n\tif (!c) {\n\t\t/* Write to new chunk */\n\t\tc = chunk_create();\n\t\tc->len = MIN(size, CHUNK_SIZE);\n\t\tchunk_add(c);\n\n\t\tif (last)\n\t\t\tlast->next_file = c;\n\t\telse\n\t\t\tf->chunks = c;\n\t\tc->host = host_get_next();\n\t\tnet_send(c->host, c->id, c->seqno, (const uint8_t *) buf, c->len);\n\n\t\treturn c->len;\n\t}\n\t/* Modify/extend existing chunk */\n\n\tchunkdata = NULL;\n\tclen = chunk_wait_for(c, &chunkdata);\n\tif (clen <= 0)\n\t\treturn clen;\n\n\t/* New chunk length */\n\tclen = MIN(CHUNK_SIZE, size + offset);\n\t/* Number of bytes to write */\n\tlen = MIN(clen - offset, size);\n\n\tchunkdata = realloc(chunkdata, clen);\n\tmemcpy(&chunkdata[offset], buf, len);\n\tchunk_done(c, chunkdata, clen);\n\treturn len;\n}\n\nstatic int fs_write(const char *name, const char *buf, size_t size,\n\toff_t offset, struct fuse_file_info *fileinfo)\n{\n\tstruct file *f;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\treturn fs_inner_write(f, buf, size, offset);\n}\n\nstatic int fs_read(const char *name, char *buf, size_t size,\n\toff_t offset, struct fuse_file_info *fileinfo)\n{\n\tstruct file *f;\n\tstruct chunk *c;\n\tuint8_t *chunkdata;\n\tint len;\n\tint clen;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\tc = f->chunks;\n\twhile (c && offset >= c->len) {\n\t\toffset -= c->len;\n\t\tc = c->next_file;\n\t}\n\tif (!c) {\n\t\t/* Read out of bounds */\n\t\treturn 0;\n\t}\n\n\tlen = MIN(c->len - offset, size);\n\n\tchunkdata = NULL;\n\tclen = chunk_wait_for(c, &chunkdata);\n\tif (!clen)\n\t\treturn -EIO;\n\n\tmemcpy(buf, &chunkdata[offset], len);\n\tchunk_done(c, chunkdata, clen);\n\treturn len;\n}\n\nstatic int shrink_file(struct file *f, off_t length)\n{\n\tstruct chunk *c = f->chunks;\n\tstruct chunk *prev = NULL;\n\twhile (c->len <= length) {\n\t\tlength -= c->len;\n\t\tprev = c;\n\t\tc = c->next_file;\n\t}\n\tif (!length) {\n\t\tif (prev)\n\t\t\tprev->next_file = NULL;\n\t\telse\n\t\t\tf->chunks = NULL;\n\t}\n\twhile (c) {\n\t\tstruct chunk *next = c->next_file;\n\t\tif (length) {\n\t\t\tuint8_t *cdata;\n\t\t\tint clen;\n\n\t\t\tclen = chunk_wait_for(c, &cdata);\n\t\t\tif (!clen)\n\t\t\t\treturn -EIO;\n\n\t\t\tchunk_done(c, cdata, length);\n\t\t\tc->next_file = NULL;\n\t\t\tlength = 0;\n\t\t} else {\n\t\t\tchunk_remove(c);\n\t\t\tchunk_free(c);\n\t\t}\n\t\tc = next;\n\t}\n\treturn 0;\n}\n\nstatic int grow_file(struct file *f, off_t length)\n{\n\tint offset = file_size(f);\n\tint to_grow = length - offset;\n\tchar zerobuf[CHUNK_SIZE];\n\n\tmemset(zerobuf, 0, sizeof(zerobuf));\n\twhile (to_grow) {\n\t\tint res = fs_inner_write(f, zerobuf, MIN(to_grow, CHUNK_SIZE), offset);\n\t\tif (res < 0) {\n\t\t\treturn res;\n\t\t}\n\t\tassert(res);\n\t\toffset += res;\n\t\tto_grow -= res;\n\t}\n\treturn 0;\n}\n\nstatic int fs_truncate(const char *name, off_t length)\n{\n\tstruct file *f;\n\tint cur_size;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\tcur_size = file_size(f);\n\tif (length > cur_size)\n\t\treturn grow_file(f, length);\n\tif (length < cur_size) {\n\t\treturn shrink_file(f, length);\n\t}\n\treturn 0;\n}\n\nstatic int fs_rename(const char *name, const char *newname)\n{\n\tstruct file *f;\n\n\tf = find_file(name);\n\tif (!f)\n\t\treturn -ENOENT;\n\n\tfree((void*) f->name);\n\tf->name = strdup(newname);\n\n\treturn 0;\n}\n\nconst struct fuse_operations fs_ops = {\n\t.getattr = fs_getattr,\n\t.utime = fs_utime,\n\t.chmod = fs_chmod,\n\t.mkdir = fs_mkdir,\n\t.mknod = fs_mknod,\n\t.unlink = fs_unlink,\n\t.readdir = fs_readdir,\n\t.open = fs_open,\n\t.write = fs_write,\n\t.read = fs_read,\n\t.truncate = fs_truncate,\n\t.rename = fs_rename,\n\t.init = fs_init,\n\t.destroy = fs_destroy,\n};\n\n"
        },
        {
          "name": "fs.h",
          "type": "blob",
          "size": 0.9794921875,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef PINGFS_FS_H_\n#define PINGFS_FS_H_\n\n#define FUSE_USE_VERSION 26\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fuse.h>\n\nextern const struct fuse_operations fs_ops;\n\n#endif /* PINGFS_FS_H_ */\n"
        },
        {
          "name": "host.c",
          "type": "blob",
          "size": 6.634765625,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include \"host.h\"\n#include \"net.h\"\n#include \"chunk.h\"\n\n#include <time.h>\n#include <assert.h>\n\n#ifndef CLOCK_MONOTONIC_RAW\n#define CLOCK_MONOTONIC_RAW CLOCK_MONOTONIC\n#endif\n\n#include <sys/param.h>\n\nstruct linked_gaicb {\n\tstruct gaicb gaicb;\n\tstruct linked_gaicb *next;\n};\n\nstruct eval_host {\n\tstruct host *host;\n\tstruct timespec sendtime;\n\tuint16_t cur_seqno;\n\tuint16_t id;\n\tuint8_t *payload;\n\tsize_t payload_len;\n\tint done;\n\tint num_tx;\n\tint num_rx;\n};\n\nstatic const struct addrinfo addr_request = {\n\t.ai_family = AF_UNSPEC,\n\t.ai_socktype = SOCK_RAW,\n};\n\nint host_make_resolvlist(FILE *file, struct gaicb **list[])\n{\n\tint hosts = 0;\n\tint i;\n\n\tstruct gaicb **l;\n\tstruct linked_gaicb *head = NULL;\n\tstruct linked_gaicb *tail = NULL;\n\tstruct linked_gaicb *lg;\n\n\tfor (;;) {\n\t\tchar hostname[300];\n\t\tint res;\n\n\t\tmemset(hostname, 0, sizeof(hostname));\n\t\tres = fscanf(file, \"%256s\", hostname);\n\t\tif (res == EOF) break;\n\n\t\tlg = calloc(1, sizeof(*lg));\n\t\tif (!lg)\n\t\t\treturn 0;\n\n\t\tlg->gaicb.ar_name = strndup(hostname, strlen(hostname));\n\t\tlg->gaicb.ar_request = &addr_request;\n\t\tif (!head) head = lg;\n\t\tif (tail) tail->next = lg;\n\t\ttail = lg;\n\t\thosts++;\n\t}\n\n\tl = calloc(hosts, sizeof(struct gaicb*));\n\tif (!l)\n\t\treturn 0;\n\n\tlg = head;\n\tfor (i = 0; i < hosts; i++) {\n\t\tl[i] = &lg->gaicb;\n\t\tlg = lg->next;\n\t}\n\n\t*list = l;\n\n\treturn hosts;\n}\n\nvoid host_free_resolvlist(struct gaicb *list[], int length)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tfree((char *) list[i]->ar_name);\n\t\tif (list[i]->ar_result) freeaddrinfo(list[i]->ar_result);\n\t\tfree(list[i]);\n\t}\n\tfree(list);\n}\n\nstruct host *host_create(struct gaicb *list[], int listlength)\n{\n\tstruct host *hosts = NULL;\n\tstruct host *last = NULL;\n\tint i;\n\n\tfor (i = 0; i < listlength; i++) {\n\t\tif (gai_error(list[i]) == 0) {\n\t\t\tstruct addrinfo *result = list[i]->ar_result;\n\t\t\twhile (result) {\n\t\t\t\tstruct host *h;\n\n\t\t\t\th = calloc(1, sizeof(struct host));\n\t\t\t\tif (!h)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tmemcpy(&h->sockaddr, result->ai_addr, result->ai_addrlen);\n\t\t\t\th->sockaddr_len = result->ai_addrlen;\n\t\t\t\tif (!hosts)\n\t\t\t\t\thosts = h;\n\t\t\t\tif (last)\n\t\t\t\t\tlast->next = h;\n\t\t\t\tlast = h;\n\n\t\t\t\tresult = result->ai_next;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hosts;\n}\n\nstatic uint64_t latency_sum_us;\nstatic uint32_t latency_count;\n\nstatic void diff_add(struct timespec *start, struct timespec *end)\n{\n\tuint64_t us = (end->tv_sec - start->tv_sec) * 1000000;\n\tus -= start->tv_nsec / 1000;\n\tus += end->tv_nsec / 1000;\n\n\tlatency_sum_us += us;\n\tlatency_count++;\n}\n\nstruct evaldata {\n\tstruct eval_host *hosts;\n\tint count;\n};\n\nstatic void eval_reply(void *userdata, struct sockaddr_storage *addr,\n\tsize_t addrlen, uint16_t id, uint16_t seqno, uint8_t **data, size_t len)\n{\n\tint i;\n\tstruct evaldata *eval = (struct evaldata *) userdata;\n\tstruct timespec recvtime;\n\tclock_gettime(CLOCK_MONOTONIC_RAW, &recvtime);\n\tfor (i = 0; i < eval->count; i++) {\n\t\tstruct eval_host *eh = &eval->hosts[i];\n\t\tif (addrlen == eh->host->sockaddr_len &&\n\t\t\tmemcmp(addr, &eh->host->sockaddr, addrlen) == 0 &&\n\t\t\teh->payload_len == len &&\n\t\t\tmemcmp(*data, eh->payload, eh->payload_len) == 0 &&\n\t\t\teh->id == id &&\n\t\t\teh->cur_seqno == seqno) {\n\n\t\t\t/* Store accepted reply */\n\t\t\teh->num_rx++;\n\t\t\teh->done = 1;\n\t\t\tnet_inc_rx(eh->payload_len);\n\t\t\t/* Use new seqno for next packet */\n\t\t\teh->cur_seqno++;\n\t\t\tdiff_add(&eh->sendtime, &recvtime);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint host_evaluate(struct host **hosts, int length, int timeout)\n{\n\tint i;\n\tint addr;\n\tint good_hosts;\n\tstruct host *host;\n\tstruct host *prev;\n\tstruct evaldata evaldata;\n\tuint8_t eval_payload[CHUNK_SIZE];\n\n\tevaldata.count = length;\n\tevaldata.hosts = calloc(length, sizeof(struct eval_host));\n\tif (!evaldata.hosts)\n\t\treturn 0;\n\n\tfor (i = 0; i < sizeof(eval_payload); i++) {\n\t\teval_payload[i] = i & 0xff;\n\t}\n\n\taddr = 0;\n\thost = *hosts;\n\tfor (i = 0; i < length; i++) {\n\t\tevaldata.hosts[addr].host = host;\n\t\tevaldata.hosts[addr].id = addr;\n\t\tevaldata.hosts[addr].cur_seqno = addr * 2;\n\t\tevaldata.hosts[addr].payload = eval_payload;\n\t\tevaldata.hosts[addr].payload_len = sizeof(eval_payload);\n\t\taddr++;\n\t\thost = host->next;\n\t}\n\n\tprintf(\"Evaluating %d hosts (timeout=%ds).\", length, timeout);\n\tfor (i = 0; i < 5; i++) {\n\t\tint h;\n\t\tstruct timeval tv;\n\n\t\tprintf(\".\");\n\t\tfflush(stdout);\n\t\tfor (h = 0; h < length; h++) {\n\t\t\tstruct eval_host *eh = &evaldata.hosts[h];\n\t\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &eh->sendtime);\n\t\t\teh->done = 0;\n\t\t\teh->num_tx++;\n\t\t\tnet_send(eh->host, eh->id, eh->cur_seqno,\n\t\t\t\teh->payload, eh->payload_len);\n\t\t}\n\n\t\ttv.tv_sec = timeout;\n\t\ttv.tv_usec = 0;\n\t\tfor (;;) {\n\t\t\tint alldone = 1;\n\t\t\tint res;\n\n\t\t\tfor (h = 0; h < length; h++) {\n\t\t\t\talldone &= evaldata.hosts[h].done;\n\t\t\t}\n\t\t\tif (alldone) /* All hosts have replied */\n\t\t\t\tbreak;\n\n\t\t\tres = net_recv(&tv, eval_reply, &evaldata);\n\t\t\tif (!res) /* Timeout, give up */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\" done.\\n\");\n\n\tgood_hosts = 0;\n\tfor (i = 0; i < length; i++) {\n\t\tstruct eval_host *eh = &evaldata.hosts[i];\n\t\t/* Filter out hosts with below 100% result */\n\t\tif (eh->num_tx == 0 ||\n\t\t\teh->num_tx != eh->num_rx) {\n\n\t\t\t/* Mark host for deletion */\n\t\t\teh->host->sockaddr_len = 0;\n\t\t} else {\n\t\t\tgood_hosts++;\n\t\t}\n\t}\n\n\thost = *hosts;\n\tprev = NULL;\n\twhile (host) {\n\t\tstruct host *next = host->next;\n\t\t/* Remove bad hosts from list */\n\t\tif (host->sockaddr_len == 0) {\n\t\t\tif (host == *hosts)\n\t\t\t\t*hosts = next;\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\tfree(host);\n\n\t\t} else {\n\t\t\tprev = host;\n\t\t}\n\t\thost = next;\n\t}\n\n\tfree(evaldata.hosts);\n\tprintf(\"%d of %d hosts responded correctly to all pings\", good_hosts, length);\n\tif (good_hosts) {\n\t\tprintf(\" (average RTT %.02f ms)\",\n\t\t\tlatency_sum_us / ( latency_count * 1000.0f));\n\t}\n\tprintf(\"\\n\");\n\treturn good_hosts;\n}\n\nstatic struct host *hosts_start;\nstatic struct host *hosts_cur;\n\nvoid host_use(struct host* hosts)\n{\n\thosts_start = hosts;\n}\n\n/* Return next host.\n * Emulate a cyclic list of hosts */\nstruct host *host_get_next()\n{\n\tstruct host *h;\n\tassert(hosts_start);\n\tif (!hosts_cur)\n\t\thosts_cur = hosts_start;\n\th = hosts_cur;\n\thosts_cur = hosts_cur->next;\n\treturn h;\n}\n\n"
        },
        {
          "name": "host.h",
          "type": "blob",
          "size": 1.3408203125,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef PINGFS_HOST_H_\n#define PINGFS_HOST_H_\n\n#include <stdio.h>\n#include <string.h>\n#include <netdb.h>\n#include <stdlib.h>\n\nstruct host {\n\tstruct host *next;\n\tstruct sockaddr_storage sockaddr;\n\tsocklen_t sockaddr_len;\n};\n\nint host_make_resolvlist(FILE *hostfile, struct gaicb **list[]);\nvoid host_free_resolvlist(struct gaicb *list[], int length);\n\nstruct host *host_create(struct gaicb *list[], int listlength);\n\nint host_evaluate(struct host **hosts, int length, int timeout);\n\nvoid host_use(struct host* hosts);\n\nstruct host *host_get_next();\n\n#endif /* PINGFS_HOST_H_ */\n"
        },
        {
          "name": "icmp.c",
          "type": "blob",
          "size": 4.1787109375,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <strings.h>\n#include <netinet/ip_icmp.h>\n#include <netinet/icmp6.h>\n#include <arpa/inet.h>\n\n#include \"icmp.h\"\n\nstruct icmp_rule {\n\tint request_type;\n\tint reply_type;\n\tint use_checksum;\n\tint strip_iphdr;\n};\n\nstatic const struct icmp_rule icmpv4 = {\n\t.request_type = ICMP_ECHO,\n\t.reply_type = ICMP_ECHOREPLY,\n\t.use_checksum = 1,\n\t.strip_iphdr = 1,\n};\nstatic const struct icmp_rule icmpv6 = {\n\t.request_type = ICMP6_ECHO_REQUEST,\n\t.reply_type = ICMP6_ECHO_REPLY,\n\t.use_checksum = 0,\n\t.strip_iphdr = 0,\n};\n\n#define GET_RULE(pkt) ((ICMP_ADDRFAMILY(pkt) == AF_INET) ? &icmpv4 : &icmpv6 )\n\nstatic uint16_t checksum(uint8_t *data, uint32_t len)\n{\n\tuint32_t csum = 0;\n\tuint32_t i;\n\tfor (i = 0; i < len; i += 2) {\n\t\tuint16_t c = data[i] << 8;\n\t\tif (i + 1 < len) c |= data[i + 1];\n\t\tcsum += c;\n\t}\n\tcsum = (csum >> 16) + (csum & 0xffff);\n\tcsum += (csum >> 16);\n\treturn (uint16_t)(~csum);\n}\n\nstatic uint16_t read16(uint8_t *data)\n{\n\treturn (data[0] << 8) | data[1];\n}\n\nstatic void write16(uint8_t *data, uint16_t s)\n{\n\tdata[0] = s >> 8;\n\tdata[1] = s & 0xFF;\n}\n\nstatic uint8_t *icmp_encode(struct icmp_packet *pkt, int *len)\n{\n\tstruct icmp_rule const *rule = GET_RULE(pkt);\n\tuint8_t *data;\n\tint pktlen;\n\n\tpktlen = ICMP_HDRLEN + pkt->payload_len;\n\tdata = calloc(1, pktlen);\n\tif (!data)\n\t\treturn NULL;\n\n\tif (pkt->type == ICMP_REQUEST) {\n\t\tdata[0] = rule->request_type;\n\t} else {\n\t\tdata[0] = rule->reply_type;\n\t}\n\n\twrite16(&data[4], pkt->id);\n\twrite16(&data[6], pkt->seqno);\n\tif (pkt->payload_len)\n\t\tmemcpy(&data[8], pkt->payload, pkt->payload_len);\n\n\tif (rule->use_checksum) {\n\t\twrite16(&data[2], checksum(data, pktlen));\n\t}\n\n\t*len = pktlen;\n\treturn data;\n}\n\nint icmp_send(int socket, struct icmp_packet *pkt)\n{\n\tint len;\n\tuint8_t *icmpdata;\n\n\ticmpdata = icmp_encode(pkt, &len);\n\tif (!icmpdata)\n\t\treturn 0;\n\n\tlen = sendto(socket, icmpdata, len, 0, (struct sockaddr *) &pkt->peer, pkt->peer_len);\n\n\tfree(icmpdata);\n\treturn len;\n}\n\nint icmp_parse(struct icmp_packet *pkt, uint8_t *data, int len)\n{\n\tstruct icmp_rule const *rule = GET_RULE(pkt);\n\tif (rule->strip_iphdr) {\n\t\tint hdrlen;\n\t\tif (len == 0) return -3;\n\t\thdrlen = (data[0] & 0x0f) << 2;\n\t\tif (len < hdrlen) return -4;\n\t\tdata += hdrlen;\n\t\tlen -= hdrlen;\n\t}\n\tif (len < ICMP_HDRLEN) return -1;\n\tif (rule->use_checksum) {\n\t\tif (checksum(data, len) != 0) return -2;\n\t}\n\tif (rule->request_type == data[0]) {\n\t\tpkt->type = ICMP_REQUEST;\n\t} else if (rule->reply_type == data[0]) {\n\t\tpkt->type = ICMP_REPLY;\n\t} else {\n\t\treturn -5;\n\t}\n\tpkt->id = read16(&data[4]);\n\tpkt->seqno = read16(&data[6]);\n\tpkt->payload_len = len - ICMP_HDRLEN;\n\tif (pkt->payload_len) {\n\t\tpkt->payload = malloc(pkt->payload_len);\n\t\tmemcpy(pkt->payload, &data[ICMP_HDRLEN], pkt->payload_len);\n\t} else {\n\t\tpkt->payload = NULL;\n\t}\n\treturn 0;\n}\n\nstatic void *get_in_addr(struct sockaddr_storage *ss)\n{\n\tif (ss->ss_family == AF_INET) {\n\t\treturn &(((struct sockaddr_in*)ss)->sin_addr);\n\t} else {\n\t\treturn &(((struct sockaddr_in6*)ss)->sin6_addr);\n\t}\n}\n\nstatic char *icmp_type_str(struct icmp_packet *pkt)\n{\n\tif (pkt->type == ICMP_REPLY) return \"Reply from\";\n\tif (pkt->type == ICMP_REQUEST) return \"Request to\";\n\treturn \"Other\";\n}\n\nvoid icmp_dump(struct icmp_packet *pkt)\n{\n\tchar ipaddr[64];\n\tbzero(ipaddr, sizeof(ipaddr));\n\tinet_ntop(pkt->peer.ss_family, get_in_addr(&pkt->peer), ipaddr, sizeof(ipaddr));\n\n\tprintf(\"%s %s, id %04X, seqno %04X, payload %d bytes\\n\",\n\t\ticmp_type_str(pkt), ipaddr, pkt->id, pkt->seqno, pkt->payload_len);\n}\n\n\n"
        },
        {
          "name": "icmp.h",
          "type": "blob",
          "size": 1.3876953125,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef PINGFS_ICMP_H_\n#define PINGFS_ICMP_H_\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#define ICMP_ADDRFAMILY(pkt) ((pkt)->peer.ss_family)\n\n#define ICMP_HDRLEN 8\n\nenum icmp_type {\n\tICMP_REQUEST,\n\tICMP_REPLY,\n};\n\nstruct icmp_packet {\n\tstruct sockaddr_storage peer;\n\tsocklen_t peer_len;\n\tenum icmp_type type;\n\tuint16_t id;\n\tuint16_t seqno;\n\tuint8_t *payload;\n\tuint32_t payload_len;\n};\n\nextern int icmp_parse(struct icmp_packet *pkt, uint8_t *data, int len);\nextern void icmp_dump(struct icmp_packet *pkt);\nextern int icmp_send(int socket, struct icmp_packet *pkt);\n\n#endif /* PINGFS_ICMP_H_ */\n"
        },
        {
          "name": "net.c",
          "type": "blob",
          "size": 6.482421875,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include \"net.h\"\n#include \"icmp.h\"\n#include \"chunk.h\"\n\n#include <netinet/ip_icmp.h>\n#include <netinet/icmp6.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <pthread.h>\n\nstatic int sockv4;\nstatic int sockv6;\n\nstruct pkt_stats {\n\tlong long unsigned int packets;\n\tlong long unsigned int bytes;\n};\n\nstatic struct net_data {\n\tpthread_t responder;\n\tpthread_t status;\n\tpthread_mutex_t stats_mutex;\n\tstruct pkt_stats tx;\n\tstruct pkt_stats rx;\n} netdata;\n\nstatic void inc_stats(struct pkt_stats *stats, int packetsize)\n{\n\tpthread_mutex_lock(&netdata.stats_mutex);\n\tstats->packets++;\n\tstats->bytes += packetsize + ICMP_HDRLEN;\n\tpthread_mutex_unlock(&netdata.stats_mutex);\n}\n\nstatic void net_inc_tx(int packetsize)\n{\n\tinc_stats(&netdata.tx, packetsize);\n}\n\nvoid net_inc_rx(int packetsize)\n{\n\tinc_stats(&netdata.rx, packetsize);\n}\n\nint net_open_sockets()\n{\n\t/* 1MB receive buffer per socket */\n\tint rcvbuf = 1024*1024;\n\n\t// v4 socket will return full IP header\n\tsockv4 = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);\n\tif (sockv4 < 0) {\n\t\tperror(\"Failed to open IPv4 socket\");\n\t} else {\n\t\tint res = setsockopt(sockv4, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));\n\t\tif (res < 0) {\n\t\t\tperror(\"Failed to set receive buffer size on IPv4 socket\");\n\t\t}\n\t}\n\n\t// v6 socket will just give ICMPv6 data, no IP header\n\tsockv6 = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sockv6 >= 0) {\n\t\tstruct icmp6_filter filter;\n\t\tint res = setsockopt(sockv6, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));\n\t\tif (res < 0) {\n\t\t\tperror(\"Failed to set receive buffer size on IPv6 socket\");\n\t\t}\n\n\t\tICMP6_FILTER_SETBLOCKALL(&filter);\n\t\tICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filter);\n\t\tres = setsockopt(sockv6, IPPROTO_ICMPV6, ICMP6_FILTER, &filter, sizeof(filter));\n\t\tif (res < 0) {\n\t\t\tperror(\"Failed to set ICMP filters on IPv6 socket\");\n\t\t}\n\t} else {\n\t\tperror(\"Failed to open IPv6 socket\");\n\t}\n\n\tif (sockv4 < 0 && sockv6 < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid net_send(struct host *host, uint16_t id, uint16_t seqno, const uint8_t *data, size_t len)\n{\n\tint sock;\n\tstruct icmp_packet pkt;\n\n\tmemcpy(&pkt.peer, &host->sockaddr, host->sockaddr_len);\n\tpkt.peer_len = host->sockaddr_len;\n\tpkt.type = ICMP_REQUEST;\n\tpkt.id = id;\n\tpkt.seqno = seqno;\n\tpkt.payload = (uint8_t *) data;\n\tpkt.payload_len = len;\n\n\tif (ICMP_ADDRFAMILY(&pkt) == AF_INET) {\n\t\tsock = sockv4;\n\t} else {\n\t\tsock = sockv6;\n\t}\n\n\tif (sock >= 0) {\n\t\tnet_inc_tx(pkt.payload_len);\n\t\tif (!icmp_send(sock, &pkt))\n\t\t\tperror(\"Failed sending data packet\");\n\t}\n\n}\n\nstatic void handle_recv(int sock, net_recv_fn_t recv_fn, void *recv_data)\n{\n\tstruct icmp_packet mypkt;\n\tmypkt.peer_len = sizeof(struct sockaddr_storage);\n\tuint8_t buf[BUFSIZ];\n\tint len;\n\n\tlen = recvfrom(sock, buf, sizeof(buf), 0,\n\t\t(struct sockaddr *) &mypkt.peer, &mypkt.peer_len);\n\tif (len > 0 && icmp_parse(&mypkt, buf, len) == 0) {\n\t\tif (mypkt.type == ICMP_REPLY) {\n\t\t\trecv_fn(recv_data, &mypkt.peer, mypkt.peer_len, mypkt.id,\n\t\t\t\tmypkt.seqno, &mypkt.payload, mypkt.payload_len);\n\t\t}\n\t\tfree(mypkt.payload);\n\t}\n}\n\nint net_recv(struct timeval *tv, net_recv_fn_t recv_fn, void *recv_data)\n{\n\tint maxfd;\n\tfd_set fds;\n\tint i;\n\n\tFD_ZERO(&fds);\n\tif (sockv4 >= 0) FD_SET(sockv4, &fds);\n\tif (sockv6 >= 0) FD_SET(sockv6, &fds);\n\tmaxfd = MAX(sockv4, sockv6);\n\n\ti = select(maxfd+1, &fds, NULL, NULL, tv);\n\tif ((sockv4 >= 0) && FD_ISSET(sockv4, &fds))\n\t\thandle_recv(sockv4, recv_fn, recv_data);\n\tif ((sockv6 >= 0) && FD_ISSET(sockv6, &fds))\n\t\thandle_recv(sockv6, recv_fn, recv_data);\n\treturn i;\n}\n\nstatic void *responder_thread(void *arg)\n{\n\tfor (;;) {\n\t\tstruct timeval tv;\n\t\ttv.tv_sec = 1;\n\t\ttv.tv_usec = 0;\n\t\tnet_recv(&tv, chunk_reply, NULL);\n\t}\n\treturn NULL;\n}\n\nstatic void get_stats(struct pkt_stats *rx, struct pkt_stats *tx)\n{\n\tpthread_mutex_lock(&netdata.stats_mutex);\n\tmemcpy(rx, &netdata.rx, sizeof(netdata.rx));\n\tmemcpy(tx, &netdata.tx, sizeof(netdata.tx));\n\tpthread_mutex_unlock(&netdata.stats_mutex);\n}\n\nstatic float format_bytes(unsigned long long bytes, const char **suffix)\n{\n\tconst char *suffixes[] = {\n\t\t\"B\",\n\t\t\"kB\",\n\t\t\"MB\",\n\t\t\"GB\",\n\t\tNULL,\n\t};\n\tint i = 0;\n\tfloat bps = (float) bytes;\n\n\twhile (suffixes[i + 1] && bps > 1300) {\n\t\tbps /= 1000.0f;\n\t\ti++;\n\t}\n\n\t*suffix = suffixes[i];\n\n\treturn bps;\n}\n\nstatic void diff_stats(struct pkt_stats *new, struct pkt_stats *old)\n{\n\tstruct pkt_stats diff;\n\tfloat bytes;\n\tconst char *byte_suffix;\n\tdiff.packets = new->packets - old->packets;\n\tdiff.bytes = new->bytes - old->bytes;\n\tmemcpy(old, new, sizeof(*old));\n\tbytes = format_bytes(diff.bytes, &byte_suffix);\n\tprintf(\"%6llu pkt/s, %7.01f %2s/s\", diff.packets, bytes, byte_suffix);\n}\n\nstatic void *status_thread(void *arg)\n{\n\tconst struct timespec status_sleep = {\n\t\t.tv_sec = 1,\n\t\t.tv_nsec = 0,\n\t};\n\tstatic struct pkt_stats prev_rx, prev_tx;\n\tget_stats(&prev_rx, &prev_tx);\n\tnanosleep(&status_sleep, NULL);\n\tfor (;;) {\n\t\tstruct pkt_stats rx, tx;\n\t\tget_stats(&rx, &tx);\n\t\tprintf(\"\\rICMP in: \");\n\t\tdiff_stats(&rx, &prev_rx);\n\t\tprintf(\"    ICMP out: \");\n\t\tdiff_stats(&tx, &prev_tx);\n\t\tfflush(stdout);\n\t\tnanosleep(&status_sleep, NULL);\n\t}\n\treturn NULL;\n}\n\nvoid net_start()\n{\n\tif (pthread_mutex_init(&netdata.stats_mutex, NULL)) {\n\t\tperror(\"Fatal, failed to create a mutex\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpthread_create(&netdata.responder, NULL, responder_thread, NULL);\n\tpthread_create(&netdata.status, NULL, status_thread, NULL);\n}\n\nvoid net_stop()\n{\n\tpthread_cancel(netdata.responder);\n\tpthread_join(netdata.responder, NULL);\n\tpthread_cancel(netdata.status);\n\tpthread_join(netdata.status, NULL);\n\n\tpthread_mutex_lock(&netdata.stats_mutex);\n\tprintf(\"\\n\\nTotal network resources consumed:\\n\"\n\t\t\"in:  %10llu packets, %10llu bytes\\n\"\n\t\t\"out: %10llu packets, %10llu bytes\\n\"\n\t\t\" (bytes counted above IP level)\\n\",\n\t\tnetdata.rx.packets, netdata.rx.bytes,\n\t\tnetdata.tx.packets, netdata.tx.bytes\n\t);\n\tpthread_mutex_unlock(&netdata.stats_mutex);\n}\n"
        },
        {
          "name": "net.h",
          "type": "blob",
          "size": 1.318359375,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef PINGFS_NET_H_\n#define PINGFS_NET_H_\n\n#include \"host.h\"\n\n#include <stdint.h>\n#include <sys/types.h>\n\nint net_open_sockets();\nvoid net_send(struct host *host, uint16_t id, uint16_t seqno, const uint8_t *data, size_t len);\n\ntypedef void (*net_recv_fn_t)(void *userdata, struct sockaddr_storage *addr,\n\tsize_t addrlen, uint16_t id, uint16_t seqno, uint8_t **data, size_t len);\n\nint net_recv(struct timeval *tv, net_recv_fn_t recv_fn, void *recv_data);\n\nvoid net_inc_rx(int packetsize);\n\nvoid net_start();\nvoid net_stop();\n\n#endif /* PINGFS_NET_H_ */\n"
        },
        {
          "name": "pingfs.c",
          "type": "blob",
          "size": 6.0751953125,
          "content": "/*\n * Copyright (c) 2013-2015 Erik Ekman <yarrick@kryo.se>\n *\n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <netdb.h>\n#include <pwd.h>\n\n#include \"host.h\"\n#include \"fs.h\"\n#include \"net.h\"\n#include \"chunk.h\"\n\n#include <arpa/inet.h>\n\n#define DEFAULT_TIMEOUT_S 1\n\nstruct arginfo {\n\tchar *hostfile;\n\tchar *mountpoint;\n\tint num_args;\n\tint timeout;\n};\n\nenum {\n\tKEY_HELP,\n\tKEY_ASUSER,\n\tKEY_TIMEOUT,\n};\n\nstatic const struct fuse_opt pingfs_opts[] = {\n\tFUSE_OPT_KEY(\"-h\",  KEY_HELP),\n\tFUSE_OPT_KEY(\"-u \", KEY_ASUSER),\n\tFUSE_OPT_KEY(\"-t \", KEY_TIMEOUT),\n\tFUSE_OPT_END,\n};\n\nstatic int read_hostnames(const char *hfile, struct gaicb **list[])\n{\n\tint h = 0;\n\tFILE *file;\n\n\tif (strcmp(\"-\", hfile) == 0) {\n\t\tfile = stdin;\n\t} else {\n\t\tfile = fopen(hfile, \"r\");\n\t\tif (!file) {\n\t\t\tperror(\"Failed to read file\");\n\t\t\treturn h;\n\t\t}\n\t}\n\n\th = host_make_resolvlist(file, list);\n\tfclose(file);\n\n\treturn h;\n}\n\nstatic int resolve_names(struct gaicb **list, int names, struct host **hosts)\n{\n\tint ret;\n\tint hostcount;\n\tint i;\n\n\tfprintf(stderr, \"Resolving %d hostnames... \", names);\n\tfflush(stderr);\n\n\tret = getaddrinfo_a(GAI_WAIT, list, names, NULL);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"Resolving failed: %s\\n\", gai_strerror(ret));\n\t\treturn -1;\n\t}\n\n\tfprintf(stderr, \"done.\\n\");\n\n\thostcount = 0;\n\tfor (i = 0; i < names; i++) {\n\t\tret = gai_error(list[i]);\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"Skipping %s: %s\\n\", list[i]->ar_name, gai_strerror(ret));\n\t\t} else {\n\t\t\tstruct addrinfo *result = list[i]->ar_result;\n\t\t\tdo {\n\t\t\t\thostcount++;\n\t\t\t\tresult = result->ai_next;\n\t\t\t} while (result);\n\t\t}\n\t}\n\tif (!hostcount) {\n\t\tfprintf(stderr, \"No hosts found! Exiting\\n\");\n\t\treturn -1;\n\t}\n\n\t*hosts = host_create(list, names);\n\thost_free_resolvlist(list, names);\n\n\tif (*hosts == NULL) {\n\t\tfprintf(stderr, \"Failed creating list list, exiting\\n\");\n\t\treturn -1;\n\t}\n\n\treturn hostcount;\n}\n\nstatic void print_usage(char *progname)\n{\n\tfprintf(stderr, \"Usage: %s [options] hostfile mountpoint\\n\"\n\t\t\"Options:\\n\"\n\t\t\" -h           : Print this help and exit\\n\"\n\t\t\" -u username  : Mount the filesystem as this user\\n\"\n\t\t\" -t timeout   : Max time to wait for icmp reply \"\n\t\t\t\"(seconds, default 1)\\n\", progname);\n}\n\nstatic int pingfs_opt_proc(void *data, const char *arg, int key, struct fuse_args *outargs)\n{\n\tstruct arginfo *arginfo = (struct arginfo *) data;\n\tstruct passwd *pw;\n\tint res;\n\n\tswitch (key) {\n\tcase FUSE_OPT_KEY_NONOPT:\n\t\targinfo->num_args++;\n\t\tif (!arginfo->hostfile) {\n\t\t\t/* Get first non-option argument as hostfile */\n\t\t\targinfo->hostfile = strdup(arg);\n\t\t\treturn 0;\n\t\t} else if (!arginfo->mountpoint) {\n\t\t\targinfo->mountpoint = strdup(arg);\n\t\t}\n\t\tbreak;\n\tcase KEY_HELP:\n\t\tprint_usage(outargs->argv[0]);\n\t\texit(0);\n\tcase KEY_ASUSER:\n\t\tpw = getpwnam(&arg[2]); /* Offset 2 to skip '-u' from arg */\n\t\tif (pw) {\n\t\t\tchar userarg[64];\n\t\t\tsnprintf(userarg, sizeof(userarg), \"-ouid=%d,gid=%d\", pw->pw_uid, pw->pw_gid);\n\t\t\tfuse_opt_add_arg(outargs, userarg);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Bad username given! Exiting\\n\");\n\t\t\tprint_usage(outargs->argv[0]);\n\t\t\texit(1);\n\t\t}\n\t\tbreak;\n\tcase KEY_TIMEOUT:\n\t\tres = sscanf(arg, \"-t%d\", &arginfo->timeout);\n\t\tif (res == 1 && arginfo->timeout > 0 && arginfo->timeout < 60) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Bad timeout given! Exiting\\n\");\n\t\t\tprint_usage(outargs->argv[0]);\n\t\t\texit(1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct gaicb **list;\n\tstruct host *hosts = NULL;\n\tstruct host *h;\n\tint hostnames;\n\tint host_count;\n\tstruct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n\tstruct arginfo arginfo;\n\tstruct stat mountdir;\n\tint res;\n\n\tmemset(&arginfo, 0, sizeof(arginfo));\n\targinfo.timeout = DEFAULT_TIMEOUT_S;\n\tif (fuse_opt_parse(&args, &arginfo, pingfs_opts, pingfs_opt_proc) == -1) {\n\t\tfprintf(stderr, \"Error parsing options!\\n\");\n\t\tprint_usage(argv[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (arginfo.num_args != 2) {\n\t\tfprintf(stderr, \"Need two arguments!\\n\");\n\t\tprint_usage(argv[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tres = stat(arginfo.mountpoint, &mountdir);\n\tif (res) {\n\t\tperror(\"Failed to check mountpoint\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tif (!S_ISDIR(mountdir.st_mode)) {\n\t\tfprintf(stderr, \"Mountpoint must be a directory! Exiting\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tfree(arginfo.mountpoint);\n\n\thostnames = read_hostnames(arginfo.hostfile, &list);\n\tfree(arginfo.hostfile);\n\tif (!hostnames) {\n\t\tfprintf(stderr, \"No hosts configured! Exiting\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (net_open_sockets()) {\n\t\tfprintf(stderr, \"No raw sockets opened. Got root?\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\thost_count = resolve_names(list, hostnames, &hosts);\n\tif (host_count < 0) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\thost_count = host_evaluate(&hosts, host_count, arginfo.timeout);\n\tif (!host_count) {\n\t\tfprintf(stderr, \"No host passed the test\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tchunk_set_timeout(arginfo.timeout);\n\n\thost_use(hosts);\n\n\t/* Always run FUSE in foreground */\n\tfuse_opt_add_arg(&args, \"-f\");\n\n\t/* Run FUSE single threaded */\n\tfuse_opt_add_arg(&args, \"-s\");\n\n\t/* Default permissions handling, allow all users\n\t * Directory is 775 so only root can use it anyway */\n\tfuse_opt_add_arg(&args, \"-odefault_permissions,allow_other\");\n\n\t/* Enable direct IO so we can do partial read/writes */\n\tfuse_opt_add_arg(&args, \"-odirect_io\");\n\n\tprintf(\"Mounting filesystem\\n\");\n\tfuse_main(args.argc, args.argv, &fs_ops, NULL);\n\n\t/* Clean up */\n\tfuse_opt_free_args(&args);\n\th = hosts;\n\twhile (h) {\n\t\tstruct host *host = h;\n\t\th = h->next;\n\t\tfree(host);\n\t}\n\treturn EXIT_SUCCESS;\n}\n"
        }
      ]
    }
  ]
}