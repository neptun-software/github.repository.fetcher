{
  "metadata": {
    "timestamp": 1736710184917,
    "page": 877,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rougier/freetype-gl",
      "stars": 1662,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.580078125,
          "content": "# Set the default behavior, in case people don't have core.autocrlf set.\n# Normalize all detected text files to LF line endings when checking in.\n* text=auto\n\n# Keep everything within the windows subdirectory as it is.\n/windows/** binary\n\n# Binary files should be detected by default, but just stay save and tell\n# git that they are not text and are not diff-able\n# Portable network graphics format\n*.png binary\n# Windows dynamic link library format\n*.dll binary\n# Windows import library format\n*.lib binary\n# Windows portable executable format\n*.exe binary\n# TrueType file format\n*.ttf binary\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.73828125,
          "content": "demos/data/\ndemos/fonts/\ndemos/shaders/\ndemos/ansi\ndemos/atb-agg\ndemos/benchmark\ndemos/cartoon\ndemos/console\ndemos/cube\ndemos/distance-field\ndemos/distance-field-2\ndemos/distance-field-3\ndemos/embedded-font\ndemos/font\ndemos/gamma\ndemos/glyph\ndemos/lcd\ndemos/makefont\ndemos/markup\ndemos/outline\ndemos/subpixel\ndemos/texture\ndemos/vera-16.h\n\ndoc/html/\ndoc/Doxyfile\n\nfonts/Arial.ttf\nfonts/DroidSansJapanese.ttf\nfonts/DroidSerif-Bold.ttf\nfonts/DroidSerif-Italic.ttf\nfonts/DroidSerif-Regular.ttf\nfonts/Georgia.ttf\nfonts/Tahoma.ttf\nfonts/Times.ttf\nfonts/Verdana.ttf\n\nharfbuzz/fonts/\nharfbuzz/harfbuzz\nharfbuzz/hb-texture\nharfbuzz/libfreetype-gl-hb.a\n\nCMakeFiles\nCMakeCache.txt\ncmake_install.cmake\nMakefile\nlibfreetype-gl.a\nmakefont\n/build\n/.vs\n/out\n/glfw-3.2.1*\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.6787109375,
          "content": "# Freetype GL - A C OpenGL Freetype engine\n#\n# Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n# file `LICENSE` for more details.\nlanguage: c\ndist: trusty\ncompiler:\n  - gcc\nbefore_install:\n# GLFW requires a working X11 display and makefont uses GLFW.\n  - \"export DISPLAY=:99.0\"\n  - \"sh -e /etc/init.d/xvfb start\"\ninstall:\n# Update system\n  - sudo apt-get update -qq || true\n# Install dependencies\n  - sudo apt-get install -qq cmake g++-4.8 gcc-4.8 libglew-dev libfreetype6-dev doxygen libharfbuzz-dev libxmu-dev libxi-dev libxrandr-dev libxinerama-dev libxcursor-dev\n# Prepare manual installation of dependencies\n  - mkdir TRAVIS_TMP/ && cd TRAVIS_TMP\n# GLFW 3.1.1 install\n  - wget -O glfw-3.2.1.zip https://github.com/glfw/glfw/archive/3.2.1.zip\n  - unzip glfw-3.2.1.zip\n  - cd glfw-3.2.1\n  - cmake -DBUILD_SHARED_LIBS=ON -DGLFW_BUILD_EXAMPLES=OFF -DGLFW_BUILD_TESTS=OFF -DGLFW_BUILD_DOCS=OFF -DCMAKE_INSTALL_PREFIX=/usr -DLIB_SUFFIX=/x86_64-linux-gnu\n  - make\n  - sudo make install\n  - cd ..\n# AntTweakBar install\n  - wget -O AntTweakBar_116.zip http://sourceforge.net/projects/anttweakbar/files/latest/download?source=dlp\n  - unzip AntTweakBar_116.zip\n  - cd AntTweakBar/src\n# And as it uses C++ ... we need to link with g++, but this Makefile's version doesn't !\n# So we modify the makefile with sed !\n  - sed -i \"s/LINK     \t= gcc/LINK     \t= g++/\" Makefile\n  - make\n  - sudo mv ../lib/libAntTweakBar.so /usr/lib/\n  - sudo mv ../lib/libAntTweakBar.so.1 /usr/lib/\n  - sudo mv ../include/* /usr/include/\n  - cd ../../\n  - rm -rf AntTweakBar_116.zip\n  - rm -rf AntTweakBar\n#\n  - cd ..\nbefore_script:\n  - cmake -Dfreetype-gl_BUILD_HARFBUZZ=ON . && make\nscript:\n  - ctest --output-on-failure\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.0029296875,
          "content": "# Freetype GL - A C OpenGL Freetype engine\n#\n# Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n# file `LICENSE` for more details.\n\ncmake_minimum_required(VERSION 2.8.12)\n\nproject(freetype-gl LANGUAGES C CXX)\n\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_STANDARD_REQUIRED TRUE)\n\nset(CMAKE_MODULE_PATH\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules\"\n    \"${CMAKE_MODULE_PATH}\"\n)\n# The additional / is important to remove the last character from the path.\n# Note that it does not matter if the OS uses / or \\, because we are only\n# saving the path size.\nstring(LENGTH \"${CMAKE_SOURCE_DIR}/\" SOURCE_PATH_SIZE)\nadd_definitions(\"-DSOURCE_PATH_SIZE=${SOURCE_PATH_SIZE}\")\n\nmessage(STATUS \"Building for ${CMAKE_SYSTEM_NAME} target system\")\nmessage(STATUS \"Building with ${CMAKE_C_COMPILER_ID} compiler\")\n\nset(freetype-gl_WITH_GLEW_DEFAULT ON)\n\nif((${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\") OR\n    (${CMAKE_SYSTEM_NAME} MATCHES \"Android\"))\n    set(freetype-gl_WITH_GLEW_DEFAULT OFF)\nendif()\n\noption(freetype-gl_WITH_GLEW\n    \"Use the GLEW library to fetch OpenGL function pointers\"\n    ${freetype-gl_WITH_GLEW_DEFAULT})\noption(freetype-gl_WITH_GLAD \"Use the GLAD gl loader\" OFF)\noption(freetype-gl_USE_VAO \"Use a VAO to render a vertex_buffer instance (required for forward compatible OpenGL 3.0 contexts)\" OFF)\noption(freetype-gl_BUILD_DEMOS \"Build the freetype-gl example programs\" ON)\noption(freetype-gl_BUILD_APIDOC \"Build the freetype-gl API documentation\" ON)\noption(freetype-gl_BUILD_HARFBUZZ \"Build the freetype-gl harfbuzz support (experimental)\" OFF)\noption(freetype-gl_BUILD_MAKEFONT \"Build the makefont tool\" ON)\noption(freetype-gl_BUILD_TESTS \"Build the tests\" ON)\noption(freetype-gl_BUILD_SHARED \"Build shared library\" OFF)\noption(freetype-gl_OFF_SCREEN \"Build for off-screen render (build libfreetype-gl.so only without GLX, demos must disable because of missing glfw)\" OFF)\n\ninclude(RequireIncludeFile)\ninclude(RequireFunctionExists)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\n\nrequire_include_file(stdbool.h HAVE_STDBOOL_H)\nrequire_include_file(stdint.h HAVE_STDINT_H)\nrequire_include_file(math.h HAVE_MATH_H)\n\ncheck_library_exists(m cos \"\" HAVE_MATH_LIBRARY)\n\nif(HAVE_MATH_LIBRARY)\n    list(APPEND CMAKE_REQUIRED_LIBRARIES m)\n    set(MATH_LIBRARY m)\nendif()\n\nrequire_function_exists(cos HAVE_COS)\nrequire_function_exists(fabs HAVE_FABS)\nrequire_function_exists(floor HAVE_FLOOR)\nrequire_function_exists(fmod HAVE_FMOD)\nrequire_function_exists(pow HAVE_POW)\nrequire_function_exists(roundf HAVE_ROUNDF)\nrequire_function_exists(round HAVE_ROUND)\nrequire_function_exists(sin HAVE_SIN)\nrequire_function_exists(sqrt HAVE_SQRT)\nrequire_function_exists(tan HAVE_TAN)\n\ncheck_symbol_exists(M_PI math.h HAVE_M_PI)\n\nif(NOT HAVE_M_PI)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_USE_MATH_DEFINES)\n    unset(HAVE_M_PI CACHE)\n\n    check_symbol_exists(M_PI math.h HAVE_M_PI)\n\n    if(NOT HAVE_M_PI)\n        message(FATAL_ERROR \"`M_PI` not defined in `math.h`.\")\n    else()\n        add_definitions(-D_USE_MATH_DEFINES)\n    endif()\nendif()\n\n\nif(freetype-gl_OFF_SCREEN)\n    set(freetype-gl_BUILD_DEMOS OFF)\n\n    # Build OFF screen must use FindOpenGL with GLVND\n    # The only one module OpenGL are needed for libOpenGL.so\n    set(OpenGL_GL_PREFERENCE GLVND)\n    find_package(OpenGL REQUIRED OpenGL EGL)\n    set(OPENGL_LIBRARY ${OPENGL_opengl_LIBRARY})\nelse()\n    find_package(OpenGL REQUIRED)\nendif()\nfind_package(Freetype REQUIRED)\n\nif(freetype-gl_WITH_GLEW)\n    set(FREETYPE_GL_USE_GLEW 1)\n    find_package(GLEW REQUIRED)\nendif()\n\nif(freetype-gl_WITH_GLAD)\n    set(GL_WITH_GLAD 1)\nendif()\n\ninclude_directories(\n    ${OPENGL_INCLUDE_DIRS}\n    ${FREETYPE_INCLUDE_DIRS}\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${GLEW_INCLUDE_PATH}\n    ${PROJECT_BINARY_DIR}\n)\n\nif(MSVC)\n    # _CRT_NONSTDC_NO_DEPRECATE -> remove warning C4996\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE)\nendif(MSVC)\n\nif(freetype-gl_USE_VAO)\n    set(FREETYPE_GL_USE_VAO 1)\nendif(freetype-gl_USE_VAO)\n\nconfigure_file (\n        \"${PROJECT_SOURCE_DIR}/cmake/config.h.in\"\n        \"${PROJECT_BINARY_DIR}/config.h\"\n)\n\nset(FREETYPE_GL_HDR\n    distance-field.h\n    edtaa3func.h\n    font-manager.h\n    freetype-gl.h\n    markup.h\n    opengl.h\n    platform.h\n    text-buffer.h\n    texture-atlas.h\n    texture-font.h\n    utf8-utils.h\n    ftgl-utils.h\n    vec234.h\n    vector.h\n    vertex-attribute.h\n    vertex-buffer.h\n    freetype-gl-errdef.h\n    ${PROJECT_BINARY_DIR}/config.h\n)\n\nset(FREETYPE_GL_SRC\n    distance-field.c\n    edtaa3func.c\n    font-manager.c\n    platform.c\n    text-buffer.c\n    texture-atlas.c\n    texture-font.c\n    utf8-utils.c\n    ftgl-utils.c\n    vector.c\n    vertex-attribute.c\n    vertex-buffer.c\n)\n\nif(NOT MSVC)\n\tset(PKG_CONFIG_PREFIX ${CMAKE_INSTALL_PREFIX})\n\tset(PKG_CONFIG_EXEC_PREFIX \"\\${prefix}\")\n\tset(PKG_CONFIG_LIBDIR \"\\${exec_prefix}/lib\")\n\tset(PKG_CONFIG_INCLUDEDIR \"\\${prefix}/include\")\n\tconfigure_file(freetype-gl.pc.in ${CMAKE_CURRENT_BINARY_DIR}/freetype-gl.pc @ONLY)\n\tinstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/freetype-gl.pc DESTINATION ${PKG_CONFIG_PREFIX}/share/pkgconfig)\nendif()\n\nif(freetype-gl_BUILD_SHARED)\n    add_library(freetype-gl SHARED\n        ${FREETYPE_GL_SRC}\n        ${FREETYPE_GL_HDR}\n    )\n    SET_TARGET_PROPERTIES(\n        freetype-gl\n    PROPERTIES\n        VERSION 0.3.2\n        SOVERSION 0)\n    target_link_libraries (freetype-gl\n\t\t\t   ${OPENGL_LIBRARY}\n\t\t\t   ${FREETYPE_LIBRARIES}\n\t\t\t   ${MATH_LIBRARY}\n\t\t\t   ${GLEW_LIBRARY}\n\t\t\t   )\nelse()\n    add_library(freetype-gl STATIC\n        ${FREETYPE_GL_SRC}\n        ${FREETYPE_GL_HDR}\n    )\nendif()\n\nif(freetype-gl_BUILD_MAKEFONT)\n    add_executable(makefont makefont.c)\n\n    target_link_libraries(makefont\n        freetype-gl\n        ${OPENGL_LIBRARY}\n        ${FREETYPE_LIBRARIES}\n        ${MATH_LIBRARY}\n        ${GLEW_LIBRARY}\n    )\n\n    if(MSVC AND NOT (MSVC_VERSION LESS 1900))\n        # prevent error LNK2019: unresolved external symbol _sprintf referenced in function __bdf_parse_properties\n        # see http://stackoverflow.com/a/32418900/469659\n        target_link_libraries(makefont \"legacy_stdio_definitions.lib\")\n    endif()\nendif()\n\ninstall(TARGETS freetype-gl\n  RUNTIME DESTINATION bin\n  LIBRARY DESTINATION lib\n  ARCHIVE DESTINATION lib)\ninstall(FILES ${FREETYPE_GL_HDR}\n  DESTINATION include/freetype-gl\n  PERMISSIONS OWNER_READ GROUP_READ WORLD_READ)\n\nif(freetype-gl_BUILD_APIDOC)\n    add_subdirectory(doc)\nendif()\n\nif(freetype-gl_BUILD_HARFBUZZ)\n    add_subdirectory(harfbuzz)\nendif()\n\nif(freetype-gl_BUILD_DEMOS)\n    add_subdirectory(demos)\nendif()\n\nif(freetype-gl_BUILD_TESTS)\n    enable_testing()\n    add_subdirectory(tests)\nendif(freetype-gl_BUILD_TESTS)\n\nget_property(LIB64 GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS)\n\nif (\"${LIB64}\" STREQUAL \"TRUE\")\n    set(LIBSUFFIX 64)\nelse()\n    set(LIBSUFFIX \"\")\nendif()\n\nset(INSTALL_LIB_DIR     lib${LIBSUFFIX} CACHE PATH \"Installation directory for libraries\")\nmark_as_advanced(INSTALL_LIB_DIR)\n\ninstall(TARGETS freetype-gl\n\tARCHIVE DESTINATION ${INSTALL_LIB_DIR}\n\tLIBRARY DESTINATION ${INSTALL_LIB_DIR}\n\tCOMPONENT library)\ninstall(FILES ${FREETYPE_GL_HDR} DESTINATION include\n\tCOMPONENT headers)\n\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 0.0068359375,
          "content": "LICENSE"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 4.09765625,
          "content": "# Install\n\n## Arch Linux\n\nfreetype-gl is available on the [Arch User Repository](https://aur.archlinux.org/packages/freetype-gl).\n\n## Ubuntu\n\nThe procedure is detailed in the [.travis.yml](.travis.yml).\n\nIf you want to reuse distribution packages as much as possible,\nyou need at the very least to:\n\n-   compile and install AntTweakBar from source: <http://anttweakbar.sourceforge.net/doc/>\n\n    There is no Ubuntu package for it, and that project is marked as unmaintained.\n\n-   Ubuntu 15.10 and earlier required extra fixes to GLFW because of packaging and upstream bugs.\n\n    Those were not present in 16.10 anymore, where you can just use:\n\n        sudo apt-get install libglfw3-dev\n\n    The fixes were:\n\n    -   compile and install GLFW from source because of a Debian packaging bug with CMake:\n        <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=812853>\n\n    -   apply the fix at\n        <https://github.com/rougier/freetype-gl/blob/a4cfb9abac19a0ab62b625a9b6f856e032fe3732/.travis.yml#L23>\n        to the installed GLFW files\n\nThen:\n\n    mkdir build\n    cd build\n    cmake ..\n    make\n\nYou can then run some demos under:\n\n    cd demos\n\n\n## Windows MSYS2 MINGW64 with gcc 64-bit toolchain\n\nA video by OGLDEV on building FreetypeGL using Visual Studio 2022: <https://youtu.be/W_lyfaKpUsE>\n\n<http://msys2.github.io/>\n\nBe sure to check the MSYS2 wiki for install instructions / general information about the different shells etc. <https://sourceforge.net/p/msys2/wiki>\nWe set up only a 64-bit toolchain for the sake of brevity.\n\n### Install required packages\n\nOpen up the MSYS2 shell e.g. with msys2.exe\n\n```\npacman -S mingw-w64-x86_64-gcc\npacman -S mingw-w64-x86_64-cmake\npacman -S mingw-w64-x86_64-make\npacman -S mingw-w64-x86_64-glew\npacman -S mingw-w64-x86_64-glfw\npacman -S mingw-w64-x86_64-fontconfig\npacman -S mingw-w64-x86_64-freetype\npacman -S mingw-w64-x86_64-harfbuzz\npacman -S mingw-w64-x86_64-pkg-config\npacman -S mingw-w64-x86_64-doxygen\n```\n\n### Generate Makefile\n\nOpen the MinGW64 shell e.g. via mingw64.exe\nWe need to explicitly tell CMake to generate MinGW Makefiles and enable harfbuzz examples.\n\n```\nmkdir build\ncd build\ncmake -G \"MinGW Makefiles\"  -Dfreetype-gl_BUILD_HARFBUZZ=ON ..\n```\n\n**Note**: Harfbuzz examples only work with symbolic links enabled. See <https://github.com/git-for-windows/git/wiki/Symbolic-links>\n\n### VCPKG\nAlternatively, you can build and install freetype-gl using [vcpkg](https://github.com/microsoft/vcpkg/) dependency manager:\n\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install freetype-gl\n```\n\nThe freetype-gl port in vcpkg is kept up to date by microsoft team members and community contributors.\nIf the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n### Build demos\n\n```\ncmake --build .\n```\n\n### Run the demos\n\nGo to the `demo/` folder to try some demos.\nThe harfbuzz examples are located in the `harfbuzz/` folder.\n\nTo run the `atb-agg` demo you need to copy the file `AntTweakBar64.dll` into the `demo/` folder.\n\n### Troubleshooting\n**Note**: If you have the installer ending in 20160921.exe then you have to manually create /mingw32 and /mingw64 directories in the msys2 installation directory.\nThis should be fixed with the next version of the installer.\n\n`mkdir -p /mingw{32,64}`\n\nMake sure to add your bin folder e.g. `C:\\msys64\\mingw64\\bin`  to your PATH if you want to run the demos outside of the MINGW64 shell.\n\nIf you get an error when you start your application from the Windows Explorer like \"The procedure entry point inflateReset2 could not be located in the dynamic link library zlib1.dll\":\nThis is likely a PATH related problem. In this case some other zlib1.dll existent in one of the PATH folders was shadowing the needed zlib1.dll one of the mingw64/bin folder.\nThe solution is to change the order of the PATH entries so that the mingw64 folder comes first.\n\n## macOS with homebrew\n\nInstall [homebrew](http://brew.sh/).\n\nThen:\n\n    brew install AntTweakBar ImageMagick cmake doxygen glfw3\n    cmake .\n    make\n\nYou can then run some demos under:\n\n    cd demos\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.525390625,
          "content": "Copyright 2011-2016 Nicolas P. Rougier\nCopyright 2013-2016 Marcel Metz\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are\nthose of the authors and should not be interpreted as representing official\npolicies, either expressed or implied, of the freetype-gl project.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8505859375,
          "content": "# Freetype GL - A C OpenGL Freetype engine\n\n[![Build Status Travis](https://travis-ci.org/rougier/freetype-gl.png?branch=master)](https://travis-ci.org/rougier/freetype-gl)\n[![Build Status Appveyor](https://ci.appveyor.com/api/projects/status/github/rougier/freetype-gl?branch=master)](https://ci.appveyor.com/project/rougier/freetype-gl)\n\nA small library for displaying Unicode in OpenGL using a single texture and\na single vertex buffer.\n\n![Screenshot](http://raw.github.com/rougier/freetype-gl/master/doc/images/markup.png)\n\n\n[Installation instructions](INSTALL.md)\n\n## Code organization\n\n### Mandatory files\n\n* **texture-font**:  The texture-font structure is in charge of creating bitmap\n                     glyphs and to upload them to the texture atlas.\n\n* **texture-atlas**: This structure is responsible for the packing of small\n                     regions into a bigger texture. It is based on the skyline\n                     bottom left algorithm which appear to be [well suited for\n                     storing glyphs](https://raw.githubusercontent.com/rougier/freetype-gl/master/doc/RectangleBinPack.pdf).\n\n* **vector**:        This structure loosely mimics the std::vector class from\n                     c++. It is used by texture-atlas (for storing nodes),\n                     texture-font (for storing glyphs) and font-manager (for\n                     storing fonts). More information at:\n                     http://www.cppreference.com/wiki/container/vector/start\n\n\n### Optional files\n\n* **markup**:        Simple structure that describes text properties (font\n                     family, font size, colors, underline, etc.)\n\n* **font-manager**:  Structure in charge of caching fonts.\n\n* **vertex-buffer**: Generic vertex buffer structure inspired by pyglet\n                     (python). (more information at http://www.pyglet.org)\n\n* **edtaa3func**:    Distance field computation by Stefan Gustavson\n                     (more information at http://contourtextures.wikidot.com/)\n\n* **makefont**:      Allow to generate header file with font information\n                     (texture + glyphs) such that it can be used without\n                     freetype.\n\n\n## Contributors\n\n* Ryan.H.Kawicki (Initial CMake project)\n* Julian Mayer (Several bugfixes and code for demo-opengl-4.cc)\n* Sylvain Duclos (Android port)\n* Wang Yongcong (Improvements on the windows build and code review)\n* Jonas Wielicki (Bug report & fix on the CMakefile)\n* whatmannerofburgeristhis (Bug report in makefont)\n* Andrei Petrovici (Fine analysis of the whole code and report of potential problems)\n* Cristi Caloghera (Report on bad vertex buffer usage)\n* Andrei Petrovici (Code review)\n* Kim Jacobsen (Bug report & fix)\n* bsoddd (Bug report & fix)\n* Greg Douglas (Bug report & fix)\n* Jim Teeuwen (Bug report & fix)\n* quarnster (Bug report & fix)\n* Per Inge Mathisen (Bug report & fix)\n* Wojciech Mamrak (Code review, bug report & fix)\n* Wael Eloraiby (Put code to the C89 norm and fix CMakefile)\n* Christian Forfang (Code review, fix & patch for 3.2 core profile)\n* Lukas Murmann (Code review & fix for 3.2 core profile)\n* Jérémie Roy (Code review, fix and new ideas)\n* dsewtz (Bug report & fix)\n* jcgamestoy (Bug report & fix)\n* Behdad Esfahbod (Bug fix on harfbuzz demo)\n* Marcel Metz (Bug report & fix, CMmake no demo option, makefont parameters)\n* PJ O'Halloran (svn to git migration)\n* William Light (Face creation from memory)\n* Jan Niklas Hasse (Bug report & fix + README.md)\n* Pierre-Emmanuel Lallemant (Bug report & fix + travis setup)\n* Robert Conde (Bug report & fix)\n* Mikołaj Siedlarek (Build system bug fix)\n* Preet Desai (Bug report & fix)\n* Andy Staton (CMake fix and added namespace safeguard (avoiding glm collisions))\n* Daniel Burke (Removed GLEW dependency and fix problems with font licences)\n* Bob Kocisko (Added horizontal text alignment and text bounds calculation)\n* Ciro Santilli (Improve markdown documentation)\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.146484375,
          "content": "TODO\n====\n- Fix memory leaks in demo-atb-agg\n- To implement a generic hash table to speed up glyph and kerning access\n- To add a small markup parser\n\n"
        },
        {
          "name": "VisualC",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 2.6513671875,
          "content": "# Freetype GL - A C OpenGL Freetype engine\n#\n# Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n# file `LICENSE` for more details.\nversion: ci-{build}\ncache: \n  - c:/tools/vcpkg/installed/\nenvironment:\n  matrix:\n\n  # Windows CMake + MSVC\n  - job_name: CMake\n\n  # Windows MSVS + MSVC\n  - job_name: MSVS_Debug_x64\n    job_group: MSVS\n    appveyor_build_worker_image: Visual Studio 2019\n    configuration: Debug\n    platform: x64\n\n  - job_name: MSVS_Debug_x86\n    job_group: MSVS\n    appveyor_build_worker_image: Visual Studio 2019\n    configuration: Debug\n    platform: x86\n\n  - job_name: MSVS_Release_x64\n    job_group: MSVS\n    appveyor_build_worker_image: Visual Studio 2019\n    configuration: Release\n    platform: x64\n\n  - job_name: MSVS_Release_x86\n    job_group: MSVS\n    appveyor_build_worker_image: Visual Studio 2019\n    configuration: Release\n    platform: x86\n\nmatrix:\n  fast_finish: true\n\ninit:\n  - git config --global core.eol native\n  - git config --global core.autocrlf true\n\nfor:\n  - matrix:\n      only:\n        - job_name: Cmake\n    install:\n      - '\"C:\\Program Files (X86)\\Microsoft Visual Studio 12.0\\VC\\vcvarsall.bat\"'\n      # Remove the VS Xamarin targets to reduce AppVeyor specific noise in build\n      # logs.  See also http://help.appveyor.com/discussions/problems/4569\n      - del \"C:\\Program Files (x86)\\MSBuild\\12.0\\Microsoft.Common.targets\\ImportAfter\\Xamarin.Common.targets\"\n      - cd C:\\Tools\\vcpkg\n      - git pull --quiet\n      - .\\bootstrap-vcpkg.bat\n      - vcpkg install glfw3:x86-windows\n      - vcpkg install glfw3:x64-windows\n      - vcpkg install glew:x86-windows\n      - vcpkg install glew:x64-windows\n      - vcpkg install freetype:x86-windows\n      - vcpkg install freetype:x64-windows\n      - cd %APPVEYOR_BUILD_FOLDER%\n    build_script:\n      - cmake -DCMAKE_TOOLCHAIN_FILE=c:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake -G \"Visual Studio 12\" -Dfreetype-gl_BUILD_APIDOC=OFF -Dfreetype-gl_BUILD_TESTS=OFF ..\n      - cmake --build . --config RelWithDebInfo -- /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\" /verbosity:minimal\n    before_build:\n      - if not exist build\\NUL mkdir build\n      - cd build\n \n  - matrix:\n      only:\n        - job_group: MSVS\n    install:\n      - cd C:\\Tools\\vcpkg\n      - git pull --quiet\n      - .\\bootstrap-vcpkg.bat\n      - vcpkg integrate install\n      - vcpkg install glfw3:x86-windows\n      - vcpkg install glfw3:x64-windows\n      - vcpkg install glew:x86-windows\n      - vcpkg install glew:x64-windows\n      - vcpkg install freetype:x86-windows\n      - vcpkg install freetype:x64-windows\n      - cd %APPVEYOR_BUILD_FOLDER%\n    build_script:\n    - msbuild VisualC\\freetype-gl.sln\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "distance-field.c",
          "type": "blob",
          "size": 3.0380859375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <math.h>\n#include <float.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"edtaa3func.h\"\n\n\ndouble *\nmake_distance_mapd( double *data, unsigned int width, unsigned int height )\n{\n    short * xdist = (short *)  malloc( width * height * sizeof(short) );\n    short * ydist = (short *)  malloc( width * height * sizeof(short) );\n    double * gx   = (double *) calloc( width * height, sizeof(double) );\n    double * gy      = (double *) calloc( width * height, sizeof(double) );\n    double * outside = (double *) calloc( width * height, sizeof(double) );\n    double * inside  = (double *) calloc( width * height, sizeof(double) );\n    double vmin = DBL_MAX;\n    unsigned int i;\n\n    // Compute outside = edtaa3(bitmap); % Transform background (0's)\n    computegradient( data, width, height, gx, gy);\n    edtaa3(data, gx, gy, width, height, xdist, ydist, outside);\n    for( i=0; i<width*height; ++i)\n        if( outside[i] < 0.0 )\n            outside[i] = 0.0;\n\n    // Compute inside = edtaa3(1-bitmap); % Transform foreground (1's)\n    memset( gx, 0, sizeof(double)*width*height );\n    memset( gy, 0, sizeof(double)*width*height );\n    for( i=0; i<width*height; ++i)\n        data[i] = 1 - data[i];\n    computegradient( data, width, height, gx, gy );\n    edtaa3( data, gx, gy, width, height, xdist, ydist, inside );\n    for( i=0; i<width*height; ++i )\n        if( inside[i] < 0 )\n            inside[i] = 0.0;\n\n    // distmap = outside - inside; % Bipolar distance field\n    for( i=0; i<width*height; ++i)\n    {\n        outside[i] -= inside[i];\n        if( outside[i] < vmin )\n            vmin = outside[i];\n    }\n\n    vmin = fabs(vmin);\n\n    for( i=0; i<width*height; ++i)\n    {\n        double v = outside[i];\n        if     ( v < -vmin) outside[i] = -vmin;\n        else if( v > +vmin) outside[i] = +vmin;\n        data[i] = (outside[i]+vmin)/(2*vmin);\n    }\n\n    free( xdist );\n    free( ydist );\n    free( gx );\n    free( gy );\n    free( outside );\n    free( inside );\n    return data;\n}\n\nunsigned char *\nmake_distance_mapb( unsigned char *img,\n                    unsigned int width, unsigned int height )\n{\n    double * data    = (double *) calloc( width * height, sizeof(double) );\n    unsigned char *out = (unsigned char *) malloc( width * height * sizeof(unsigned char) );\n    unsigned int i;\n\n    // find minimum and maximum values\n    double img_min = DBL_MAX;\n    double img_max = DBL_MIN;\n\n    for( i=0; i<width*height; ++i)\n    {\n        double v = img[i];\n        data[i] = v;\n        if (v > img_max)\n            img_max = v;\n        if (v < img_min)\n            img_min = v;\n    }\n\n    // Map values from 0 - 255 to 0.0 - 1.0\n    for( i=0; i<width*height; ++i)\n        data[i] = (img[i]-img_min)/img_max;\n\n    data = make_distance_mapd(data, width, height);\n\n    // map values from 0.0 - 1.0 to 0 - 255\n    for( i=0; i<width*height; ++i)\n        out[i] = (unsigned char)(255*(1-data[i]));\n\n    free( data );\n\n    return out;\n}\n"
        },
        {
          "name": "distance-field.h",
          "type": "blob",
          "size": 1.3916015625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __DISTANCE_FIELD_H__\n#define __DISTANCE_FIELD_H__\n\n#ifdef __cplusplus\nextern \"C\" {\nnamespace ftgl {\n#endif\n\n/**\n * @file   shader.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup distance-field Distance Field\n *\n * Functions to calculate signed distance fields for bitmaps.\n *\n * <b>Example Usage</b>:\n * @code\n * #include \"distance-field.h\"\n *\n * int main( int arrgc, char *argv[] )\n * {\n *     int width = 512;\n *     int height = 512;\n *     unsigned char *image = create_greyscale_image(width, height);\n *\n *     image = make_distance_map( image, width, height );\n *\n *     return 0;\n * }\n * @endcode\n *\n * @{\n */\n\n/**\n * Create a distance file from the given image.\n *\n * @param img     A greyscale image.\n * @param width   The width of the given image.\n * @param height  The height of the given image.\n *\n * @return        A newly allocated distance field.  This image must\n *                be freed after usage.\n *\n */\ndouble *\nmake_distance_mapd( double *img,\n                    unsigned int width, unsigned int height );\n\nunsigned char *\nmake_distance_mapb( unsigned char *img,\n                    unsigned int width, unsigned int height );\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __DISTANCE_FIELD_H__ */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "edtaa3func.c",
          "type": "blob",
          "size": 18.603515625,
          "content": "/*\n * edtaa3()\n *\n * Sweep-and-update Euclidean distance transform of an\n * image. Positive pixels are treated as object pixels,\n * zero or negative pixels are treated as background.\n * An attempt is made to treat antialiased edges correctly.\n * The input image must have pixels in the range [0,1],\n * and the antialiased image should be a box-filter\n * sampling of the ideal, crisp edge.\n * If the antialias region is more than 1 pixel wide,\n * the result from this transform will be inaccurate.\n *\n * By Stefan Gustavson (stefan.gustavson@gmail.com).\n *\n * Originally written in 1994, based on a verbal\n * description of the SSED8 algorithm published in the\n * PhD dissertation of Ingemar Ragnemalm. This is his\n * algorithm, I only implemented it in C.\n *\n * Updated in 2004 to treat border pixels correctly,\n * and cleaned up the code to improve readability.\n *\n * Updated in 2009 to handle anti-aliased edges.\n *\n * Updated in 2011 to avoid a corner case infinite loop.\n *\n * Updated 2012 to change license from LGPL to MIT.\n *\n * Updated 2014 to fix a bug with the 'gy' gradient computation.\n *\n */\n\n/*\n Copyright (C) 2009-2012 Stefan Gustavson (stefan.gustavson@gmail.com)\n The code in this file is distributed under the MIT license:\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n\n#include <math.h>\n#include \"edtaa3func.h\"\n\n/*\n * Compute the local gradient at edge pixels using convolution filters.\n * The gradient is computed only at edge pixels. At other places in the\n * image, it is never used, and it's mostly zero anyway.\n */\nvoid computegradient(double *img, int w, int h, double *gx, double *gy)\n{\n    int i,j,k,p,q;\n    double glength, phi, phiscaled, ascaled, errsign, pfrac, qfrac, err0, err1, err;\n#define SQRT2 1.4142136\n    for(i = 1; i < h-1; i++) { // Avoid edges where the kernels would spill over\n        for(j = 1; j < w-1; j++) {\n            k = i*w + j;\n            if((img[k]>0.0) && (img[k]<1.0)) { // Compute gradient for edge pixels only\n                gx[k] = -img[k-w-1] - SQRT2*img[k-1] - img[k+w-1] + img[k-w+1] + SQRT2*img[k+1] + img[k+w+1];\n                gy[k] = -img[k-w-1] - SQRT2*img[k-w] - img[k-w+1] + img[k+w-1] + SQRT2*img[k+w] + img[k+w+1];\n                glength = gx[k]*gx[k] + gy[k]*gy[k];\n                if(glength > 0.0) { // Avoid division by zero\n                    glength = sqrt(glength);\n                    gx[k]=gx[k]/glength;\n                    gy[k]=gy[k]/glength;\n                }\n            }\n        }\n    }\n    // TODO: Compute reasonable values for gx, gy also around the image edges.\n    // (These are zero now, which reduces the accuracy for a 1-pixel wide region\n\t// around the image edge.) 2x2 kernels would be suitable for this.\n}\n\n/*\n * A somewhat tricky function to approximate the distance to an edge in a\n * certain pixel, with consideration to either the local gradient (gx,gy)\n * or the direction to the pixel (dx,dy) and the pixel greyscale value a.\n * The latter alternative, using (dx,dy), is the metric used by edtaa2().\n * Using a local estimate of the edge gradient (gx,gy) yields much better\n * accuracy at and near edges, and reduces the error even at distant pixels\n * provided that the gradient direction is accurately estimated.\n */\ndouble edgedf(double gx, double gy, double a)\n{\n    double df, glength, temp, a1;\n\n    if ((gx == 0) || (gy == 0)) { // Either A) gu or gv are zero, or B) both\n        df = 0.5-a;  // Linear approximation is A) correct or B) a fair guess\n    } else {\n        glength = sqrt(gx*gx + gy*gy);\n        if(glength>0) {\n            gx = gx/glength;\n            gy = gy/glength;\n        }\n        /* Everything is symmetric wrt sign and transposition,\n         * so move to first octant (gx>=0, gy>=0, gx>=gy) to\n         * avoid handling all possible edge directions.\n         */\n        gx = fabs(gx);\n        gy = fabs(gy);\n        if(gx<gy) {\n            temp = gx;\n            gx = gy;\n            gy = temp;\n        }\n        a1 = 0.5*gy/gx;\n        if (a < a1) { // 0 <= a < a1\n            df = 0.5*(gx + gy) - sqrt(2.0*gx*gy*a);\n        } else if (a < (1.0-a1)) { // a1 <= a <= 1-a1\n            df = (0.5-a)*gx;\n        } else { // 1-a1 < a <= 1\n            df = -0.5*(gx + gy) + sqrt(2.0*gx*gy*(1.0-a));\n        }\n    }\n    return df;\n}\n\ndouble distaa3(double *img, double *gximg, double *gyimg, int w, int c, int xc, int yc, int xi, int yi)\n{\n  double di, df, dx, dy, gx, gy, a;\n  int closest;\n\n  closest = c-xc-yc*w; // Index to the edge pixel pointed to from c\n  a = img[closest];    // Grayscale value at the edge pixel\n  gx = gximg[closest]; // X gradient component at the edge pixel\n  gy = gyimg[closest]; // Y gradient component at the edge pixel\n\n  if(a > 1.0) a = 1.0;\n  if(a < 0.0) a = 0.0; // Clip grayscale values outside the range [0,1]\n  if(a == 0.0) return 1000000.0; // Not an object pixel, return \"very far\" (\"don't know yet\")\n\n  dx = (double)xi;\n  dy = (double)yi;\n  di = sqrt(dx*dx + dy*dy); // Length of integer vector, like a traditional EDT\n  if(di==0) { // Use local gradient only at edges\n      // Estimate based on local gradient only\n      df = edgedf(gx, gy, a);\n  } else {\n      // Estimate gradient based on direction to edge (accurate for large di)\n      df = edgedf(dx, dy, a);\n  }\n  return di + df; // Same metric as edtaa2, except at edges (where di=0)\n}\n\n// Shorthand macro: add ubiquitous parameters dist, gx, gy, img and w and call distaa3()\n#define DISTAA(c,xc,yc,xi,yi) (distaa3(img, gx, gy, w, c, xc, yc, xi, yi))\n\nvoid edtaa3(double *img, double *gx, double *gy, int w, int h, short *distx, short *disty, double *dist)\n{\n  int x, y, i, c;\n  int offset_u, offset_ur, offset_r, offset_rd,\n  offset_d, offset_dl, offset_l, offset_lu;\n  double olddist, newdist;\n  int cdistx, cdisty, newdistx, newdisty;\n  int changed;\n  double epsilon = 1e-3;\n\n  /* Initialize index offsets for the current image width */\n  offset_u = -w;\n  offset_ur = -w+1;\n  offset_r = 1;\n  offset_rd = w+1;\n  offset_d = w;\n  offset_dl = w-1;\n  offset_l = -1;\n  offset_lu = -w-1;\n\n  /* Initialize the distance images */\n  for(i=0; i<w*h; i++) {\n    distx[i] = 0; // At first, all pixels point to\n    disty[i] = 0; // themselves as the closest known.\n    if(img[i] <= 0.0)\n      {\n\tdist[i]= 1000000.0; // Big value, means \"not set yet\"\n      }\n    else if (img[i]<1.0) {\n      dist[i] = edgedf(gx[i], gy[i], img[i]); // Gradient-assisted estimate\n    }\n    else {\n      dist[i]= 0.0; // Inside the object\n    }\n  }\n\n  /* Perform the transformation */\n  do\n    {\n      changed = 0;\n\n      /* Scan rows, except first row */\n      for(y=1; y<h; y++)\n        {\n\n          /* move index to leftmost pixel of current row */\n          i = y*w;\n\n          /* scan right, propagate distances from above & left */\n\n          /* Leftmost pixel is special, has no left neighbors */\n          olddist = dist[i];\n          if(olddist > 0) // If non-zero distance or not set yet\n            {\n\t      c = i + offset_u; // Index of candidate for testing\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_ur;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n          i++;\n\n          /* Middle pixels have all neighbors */\n          for(x=1; x<w-1; x++, i++)\n            {\n              olddist = dist[i];\n              if(olddist <= 0) continue; // No need to update further\n\n\t      c = i+offset_l;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_lu;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_u;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_ur;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n\n          /* Rightmost pixel of row is special, has no right neighbors */\n          olddist = dist[i];\n          if(olddist > 0) // If not already zero distance\n            {\n\t      c = i+offset_l;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_lu;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_u;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty+1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n\n          /* Move index to second rightmost pixel of current row. */\n          /* Rightmost pixel is skipped, it has no right neighbor. */\n          i = y*w + w-2;\n\n          /* scan left, propagate distance from right */\n          for(x=w-2; x>=0; x--, i--)\n            {\n              olddist = dist[i];\n              if(olddist <= 0) continue; // Already zero distance\n\n\t      c = i+offset_r;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n        }\n\n      /* Scan rows in reverse order, except last row */\n      for(y=h-2; y>=0; y--)\n        {\n          /* move index to rightmost pixel of current row */\n          i = y*w + w-1;\n\n          /* Scan left, propagate distances from below & right */\n\n          /* Rightmost pixel is special, has no right neighbors */\n          olddist = dist[i];\n          if(olddist > 0) // If not already zero distance\n            {\n\t      c = i+offset_d;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_dl;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n          i--;\n\n          /* Middle pixels have all neighbors */\n          for(x=w-2; x>0; x--, i--)\n            {\n              olddist = dist[i];\n              if(olddist <= 0) continue; // Already zero distance\n\n\t      c = i+offset_r;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_rd;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_d;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n                  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_dl;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n                  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n          /* Leftmost pixel is special, has no left neighbors */\n          olddist = dist[i];\n          if(olddist > 0) // If not already zero distance\n            {\n\t      c = i+offset_r;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n                  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_rd;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx-1;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n\t\t  dist[i]=newdist;\n                  olddist=newdist;\n                  changed = 1;\n                }\n\n\t      c = i+offset_d;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx;\n              newdisty = cdisty-1;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n                  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n\n          /* Move index to second leftmost pixel of current row. */\n          /* Leftmost pixel is skipped, it has no left neighbor. */\n          i = y*w + 1;\n          for(x=1; x<w; x++, i++)\n            {\n              /* scan right, propagate distance from left */\n              olddist = dist[i];\n              if(olddist <= 0) continue; // Already zero distance\n\n\t      c = i+offset_l;\n\t      cdistx = distx[c];\n\t      cdisty = disty[c];\n              newdistx = cdistx+1;\n              newdisty = cdisty;\n              newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);\n              if(newdist < olddist-epsilon)\n                {\n                  distx[i]=newdistx;\n                  disty[i]=newdisty;\n                  dist[i]=newdist;\n                  changed = 1;\n                }\n            }\n        }\n    }\n  while(changed); // Sweep until no more updates are made\n\n  /* The transformation is completed. */\n\n}\n"
        },
        {
          "name": "edtaa3func.h",
          "type": "blob",
          "size": 3.912109375,
          "content": "/*\n * Copyright 2009 Stefan Gustavson (stefan.gustavson@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY STEFAN GUSTAVSON ''AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL STEFAN GUSTAVSON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are\n * those of the authors and should not be interpreted as representing official\n * policies, either expressed or implied, of Stefan Gustavson.\n *\n *\n * edtaa3()\n *\n * Sweep-and-update Euclidean distance transform of an\n * image. Positive pixels are treated as object pixels,\n * zero or negative pixels are treated as background.\n * An attempt is made to treat antialiased edges correctly.\n * The input image must have pixels in the range [0,1],\n * and the antialiased image should be a box-filter\n * sampling of the ideal, crisp edge.\n * If the antialias region is more than 1 pixel wide,\n * the result from this transform will be inaccurate.\n *\n * By Stefan Gustavson (stefan.gustavson@gmail.com).\n *\n * Originally written in 1994, based on a verbal\n * description of the SSED8 algorithm published in the\n * PhD dissertation of Ingemar Ragnemalm. This is his\n * algorithm, I only implemented it in C.\n *\n * Updated in 2004 to treat border pixels correctly,\n * and cleaned up the code to improve readability.\n *\n * Updated in 2009 to handle anti-aliased edges.\n *\n * Updated in 2011 to avoid a corner case infinite loop.\n *\n */\n#ifndef __EDTAA3FUNC_H__\n#define __EDTAA3FUNC_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/*\n * Compute the local gradient at edge pixels using convolution filters.\n * The gradient is computed only at edge pixels. At other places in the\n * image, it is never used, and it's mostly zero anyway.\n */\nvoid computegradient(double *img, int w, int h, double *gx, double *gy);\n\n/*\n * A somewhat tricky function to approximate the distance to an edge in a\n * certain pixel, with consideration to either the local gradient (gx,gy)\n * or the direction to the pixel (dx,dy) and the pixel greyscale value a.\n * The latter alternative, using (dx,dy), is the metric used by edtaa2().\n * Using a local estimate of the edge gradient (gx,gy) yields much better\n * accuracy at and near edges, and reduces the error even at distant pixels\n * provided that the gradient direction is accurately estimated.\n */\ndouble edgedf(double gx, double gy, double a);\n\n\ndouble distaa3(double *img, double *gximg, double *gyimg, int w, int c, int xc, int yc, int xi, int yi);\n\n// Shorthand macro: add ubiquitous parameters dist, gx, gy, img and w and call distaa3()\n#define DISTAA(c,xc,yc,xi,yi) (distaa3(img, gx, gy, w, c, xc, yc, xi, yi))\n\nvoid edtaa3(double *img, double *gx, double *gy, int w, int h, short *distx, short *disty, double *dist);\n\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif // __EDTAA3FUNC_H__\n"
        },
        {
          "name": "font-manager.c",
          "type": "blob",
          "size": 6.4326171875,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#if 0\n#  if !defined(_WIN32) && !defined(_WIN64)\n#    include <fontconfig/fontconfig.h>\n#  endif\n#endif\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"font-manager.h\"\n#include \"ftgl-utils.h\"\n\n// ------------------------------------------------------------ file_exists ---\nstatic int\nfile_exists( const char * filename )\n{\n    FILE * file = fopen( filename, \"r\" );\n    if ( file )\n    {\n        fclose(file);\n        return 1;\n    }\n    return 0;\n}\n\n\n// ------------------------------------------------------- font_manager_new ---\nfont_manager_t *\nfont_manager_new( size_t width, size_t height, size_t depth )\n{\n    font_manager_t *self;\n    texture_atlas_t *atlas = texture_atlas_new( width, height, depth );\n    self = (font_manager_t *) malloc( sizeof(font_manager_t) );\n    if( !self )\n    {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n        /* exit( EXIT_FAILURE ); */ /* Never ever exit from a library */\n    }\n    self->atlas = atlas;\n    self->fonts = vector_new( sizeof(texture_font_t *) );\n    self->cache = strdup( \" \" );\n    return self;\n}\n\n\n// ---------------------------------------------------- font_manager_delete ---\nvoid\nfont_manager_delete( font_manager_t * self )\n{\n    size_t i;\n    texture_font_t *font;\n    assert( self );\n\n    for( i=0; i<vector_size( self->fonts ); ++i)\n    {\n        font = *(texture_font_t **) vector_get( self->fonts, i );\n        texture_font_delete( font );\n    }\n    vector_delete( self->fonts );\n    texture_atlas_delete( self->atlas );\n    if( self->cache )\n    {\n        free( self->cache );\n    }\n    free( self );\n}\n\n\n\n// ----------------------------------------------- font_manager_delete_font ---\nvoid\nfont_manager_delete_font( font_manager_t * self,\n                          texture_font_t * font)\n{\n    size_t i;\n    texture_font_t *other;\n\n    assert( self );\n    assert( font );\n\n    for( i=0; i<self->fonts->size;++i )\n    {\n        other = (texture_font_t *) vector_get( self->fonts, i );\n        if ( (strcmp(font->filename, other->filename) == 0)\n               && ( font->size == other->size) )\n        {\n            vector_erase( self->fonts, i);\n            break;\n        }\n    }\n    texture_font_delete( font );\n}\n\n\n\n// ----------------------------------------- font_manager_get_from_filename ---\ntexture_font_t *\nfont_manager_get_from_filename( font_manager_t *self,\n                                const char * filename,\n                                const float size )\n{\n    size_t i;\n    texture_font_t *font;\n\n    assert( self );\n    for( i=0; i<vector_size(self->fonts); ++i )\n    {\n        font = * (texture_font_t **) vector_get( self->fonts, i );\n        if( (strcmp(font->filename, filename) == 0) && ( font->size == size) )\n        {\n            return font;\n        }\n    }\n    font = texture_font_new_from_file( self->atlas, size, filename );\n    if( font )\n    {\n        vector_push_back( self->fonts, &font );\n        texture_font_load_glyphs( font, self->cache );\n        return font;\n    }\n    freetype_gl_error_str( Cannot_Load_File, filename );\n    return 0;\n}\n\n\n// ----------------------------------------- font_manager_get_from_description ---\ntexture_font_t *\nfont_manager_get_from_description( font_manager_t *self,\n                                   const char * family,\n                                   const float size,\n                                   const int bold,\n                                   const int italic )\n{\n    texture_font_t *font;\n    char *filename = 0;\n\n    assert( self );\n\n    if( file_exists( family ) )\n    {\n        filename = strdup( family );\n    }\n    else\n    {\n#if defined(_WIN32) || defined(_WIN64)\n        freetype_gl_error( Unimplemented_Function );\n        return 0;\n#endif\n        filename = font_manager_match_description( self, family, size, bold, italic );\n        if( !filename )\n        {\n\t    char string[0x101];\n\t    string[0x100] = '\\0';\n            snprintf(string, 0x100,\n                     \"%s (size=%.1f, bold=%d, italic=%d)\",\n                     family, size, bold, italic );\n            freetype_gl_error_str( Font_Unavailable, string );\n            return 0;\n        }\n    }\n    font = font_manager_get_from_filename( self, filename, size );\n\n    free( filename );\n    return font;\n}\n\n// ------------------------------------------- font_manager_get_from_markup ---\ntexture_font_t *\nfont_manager_get_from_markup( font_manager_t *self,\n                              const markup_t *markup )\n{\n    assert( self );\n    assert( markup );\n\n    return font_manager_get_from_description( self, markup->family, markup->size,\n                                              markup->bold,   markup->italic );\n}\n\n// ----------------------------------------- font_manager_match_description ---\nchar *\nfont_manager_match_description( font_manager_t * self,\n                                const char * family,\n                                const float size,\n                                const int bold,\n                                const int italic )\n{\n// Use of fontconfig is disabled by default.\n#if 1\n    return 0;\n#else\n#  if defined _WIN32 || defined _WIN64\n    freetype_gl_error( Unimplemented_Function );\n    return 0;\n#  endif\n    char *filename = 0;\n    int weight = FC_WEIGHT_REGULAR;\n    int slant = FC_SLANT_ROMAN;\n    if ( bold )\n    {\n        weight = FC_WEIGHT_BOLD;\n    }\n    if( italic )\n    {\n        slant = FC_SLANT_ITALIC;\n    }\n    FcInit();\n    FcPattern *pattern = FcPatternCreate();\n    FcPatternAddDouble( pattern, FC_SIZE, size );\n    FcPatternAddInteger( pattern, FC_WEIGHT, weight );\n    FcPatternAddInteger( pattern, FC_SLANT, slant );\n    FcPatternAddString( pattern, FC_FAMILY, (FcChar8*) family );\n    FcConfigSubstitute( 0, pattern, FcMatchPattern );\n    FcDefaultSubstitute( pattern );\n    FcResult result;\n    FcPattern *match = FcFontMatch( 0, pattern, &result );\n    FcPatternDestroy( pattern );\n\n    if ( !match )\n    {\n        freetype_gl_error_str( Cant_Match_Family, family );\n        return 0;\n    }\n    else\n    {\n        FcValue value;\n        FcResult result = FcPatternGet( match, FC_FILE, 0, &value );\n        if ( result )\n        {\n            freetype_gl_error_str( Cant_Match_Family, family );\n        }\n        else\n        {\n            filename = strdup( (char *)(value.u.s) );\n        }\n    }\n    FcPatternDestroy( match );\n    return filename;\n#endif\n}\n"
        },
        {
          "name": "font-manager.h",
          "type": "blob",
          "size": 3.8251953125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __FONT_MANAGER_H__\n#define __FONT_MANAGER_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"vector.h\"\n#include \"markup.h\"\n#include \"texture-font.h\"\n#include \"texture-atlas.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   font-manager.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup font-manager Font manager\n *\n * Structure in charge of caching fonts.\n *\n * <b>Example Usage</b>:\n * @code\n * #include \"font-manager.h\"\n *\n * int main( int arrgc, char *argv[] )\n * {\n *     font_manager_t * manager = manager_new( 512, 512, 1 );\n *     texture_font_t * font = font_manager_get( manager, \"Mono\", 12, 0, 0 );\n *\n *     return 0;\n * }\n * @endcode\n *\n * @{\n */\n\n\n/**\n * Structure in charge of caching fonts.\n */\ntypedef struct font_manager_t {\n    /**\n     * Texture atlas to hold font glyphs.\n     */\n    texture_atlas_t * atlas;\n\n    /**\n     * Cached textures.\n     */\n    vector_t * fonts;\n\n    /**\n     * Default glyphs to be loaded when loading a new font.\n     */\n    char * cache;\n\n} font_manager_t;\n\n\n\n/**\n * Creates a new empty font manager.\n *\n * @param   width   width of the underlying atlas\n * @param   height  height of the underlying atlas\n * @param   depth   bit depth of the underlying atlas\n *\n * @return          a new font manager.\n *\n */\n  font_manager_t *\n  font_manager_new( size_t width,\n                    size_t height,\n                    size_t depth );\n\n\n/**\n *  Deletes a font manager.\n *\n *  @param self a font manager.\n */\n  void\n  font_manager_delete( font_manager_t *self );\n\n\n/**\n *  Deletes a font from the font manager.\n *\n *  Note that font glyphs are not removed from the atlas.\n *\n *  @param self a font manager.\n *  @param font font to be deleted\n *\n */\n  void\n  font_manager_delete_font( font_manager_t * self,\n                            texture_font_t * font );\n\n\n/**\n *  Request for a font based on a filename.\n *\n *  @param self     a font manager.\n *  @param filename font filename\n *  @param size     font size\n *\n *  @return Requested font\n */\n  texture_font_t *\n  font_manager_get_from_filename( font_manager_t * self,\n                                  const char * filename,\n                                  const float size );\n\n\n/**\n *  Request for a font based on a description\n *\n *  @param self     a font manager\n *  @param family   font family\n *  @param size     font size\n *  @param bold     whether font is bold\n *  @param italic   whether font is italic\n *\n *  @return Requested font\n */\n  texture_font_t *\n  font_manager_get_from_description( font_manager_t * self,\n                                     const char * family,\n                                     const float size,\n                                     const int bold,\n                                     const int italic );\n\n\n/**\n *  Request for a font based on a markup\n *\n *  @param self    a font manager\n *  @param markup  Markup describing a font\n *\n *  @return Requested font\n */\n  texture_font_t *\n  font_manager_get_from_markup( font_manager_t *self,\n                                const markup_t *markup );\n\n\n/**\n *  Search for a font filename that match description.\n *\n *  @param self    a font manager\n *  @param family   font family\n *  @param size     font size\n *  @param bold     whether font is bold\n *  @param italic   whether font is italic\n *\n *  @return Requested font filename\n */\n  char *\n  font_manager_match_description( font_manager_t * self,\n                                  const char * family,\n                                  const float size,\n                                  const int bold,\n                                  const int italic );\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif // ifdef __cplusplus\n\n#endif /* __FONT_MANAGER_H__ */\n"
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "freetype-gl-errdef.h",
          "type": "blob",
          "size": 1.458984375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n\n#ifndef __FREETYPE_GL_ERRORS_H__\n#define __FREETYPE_GL_ERRORS_H__\n\nFTGL_ERROR_START_LIST\n\nFTGL_ERRORDEF_( Texture_Atlas_Full,\t\t\t0x00,\n\t\t\"Texture atlas is full\" )\nFTGL_ERRORDEF_( Cannot_Load_File,\t\t\t0x01,\n\t\t\"unable to load file\" )\nFTGL_ERRORDEF_( Font_Unavailable,\t\t\t0x02,\n\t\t\"no font available\" )\nFTGL_ERRORDEF_( No_Font_File_Given,\t\t\t0x03,\n\t\t\"no font file given\" )\nFTGL_ERRORDEF_( Out_Of_Memory,\t\t\t\t0x04,\n\t\t\"out of memory\" )\nFTGL_ERRORDEF_( Unimplemented_Function,\t\t\t0x05,\n\t\t\"unimplemented function\" )\nFTGL_ERRORDEF_( Cant_Match_Family,\t\t\t0x06,\n\t\t\"fontconfig error: could not match family\" )\nFTGL_ERRORDEF_( No_Font_In_Markup,\t\t\t0x07,\n\t\t\"Markup doesn't have a font\" )\nFTGL_ERRORDEF_( No_Size_Specified,\t\t\t0x08,\n\t\t\"No size specified for attribute\" )\nFTGL_ERRORDEF_( No_Format_Specified,\t\t\t0x09,\n\t\t\"No format specified for attribute\" )\nFTGL_ERRORDEF_( Vertex_Attribute_Format_Wrong,\t\t0x0A,\n\t\t\"Vertex attribute format not understood\" )\nFTGL_ERRORDEF_( Load_Color_Not_Available,\t\t0x0B,\n\t\t\"FT_LOAD_COLOR not available\" )\nFTGL_ERRORDEF_( No_Fixed_Size_In_Color_Font,\t\t0x0C,\n\t\t\"No fixed size in color font\" )\nFTGL_ERRORDEF_( Variable_Font_Weight_Not_Available,\t0x0D,\n\t\t\"Variable font weight not available\" )\nFTGL_ERRORDEF_( Variable_Font_Weight_Out_Of_Range, \t0x0E,\n\t\t\"Variable font weight out of range\" )\n\nFTGL_ERROR_END_LIST\n\n#endif\n"
        },
        {
          "name": "freetype-gl.h",
          "type": "blob",
          "size": 0.7744140625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __FREETYPE_GL_H__\n#define __FREETYPE_GL_H__\n\n/* Mandatory */\n#include \"platform.h\"\n#include \"opengl.h\"\n#include \"vec234.h\"\n#include \"vector.h\"\n#include \"texture-atlas.h\"\n#include \"texture-font.h\"\n#include \"ftgl-utils.h\"\n\n#ifdef IMPLEMENT_FREETYPE_GL\n#include \"platform.c\"\n#include \"texture-atlas.c\"\n#include \"texture-font.c\"\n#include \"vector.c\"\n#include \"utf8-utils.c\"\n#include \"distance-field.c\"\n#include \"edtaa3func.c\"\n#include \"ftgl-utils.c\"\n#endif\n\n#ifdef __cplusplus\n#ifndef NOT_USING_FT_GL_NAMESPACE\nusing namespace ftgl;\n#endif /* NOT_USING_FT_GL_NAMESPACE */\n#endif /* __cplusplus */\n\n#endif /* FREETYPE_GL_H */\n"
        },
        {
          "name": "freetype-gl.pc.in",
          "type": "blob",
          "size": 0.26953125,
          "content": "prefix=@PKG_CONFIG_PREFIX@\nexec_prefix=@PKG_CONFIG_EXEC_PREFIX@\nlibdir=@PKG_CONFIG_LIBDIR@\nincludedir=@PKG_CONFIG_INCLUDEDIR@\n\nName: freetype-gl\nDescription: OpenGL text using one vertex buffer, one texture and FreeType\nLibs: -L${libdir} -lfreetype-gl\nCflags: -I${includedir}\n"
        },
        {
          "name": "ftgl-utils.c",
          "type": "blob",
          "size": 1.8486328125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include \"ftgl-utils.h\"\n\nerror_callback_t log_error = error_callback_default;\n\n// ------------------------------------------------- error_callback_default ---\n#ifdef __ANDROID__\n#include <android/log.h>\n#define  LOG_TAG    \"freetype-gl\"\nvoid error_callback_default(const char* fmt, ...)\n{\n  va_list myargs;\n  va_start(myargs, fmt);\n  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG,\n\t\t      \"Freetype GL Error %03x %s:\\n\", freetype_gl_errno, freetype_gl_message);\n  __android_log_vprint(ANDROID_LOG_ERROR, LOG_TAG,\n\t\t       fmt, myargs);\n  va_end(myargs);\n}\n#else\nvoid error_callback_default(const char* fmt, ...)\n{\n  va_list myargs;\n  va_start(myargs, fmt);\n  vfprintf(stderr, fmt, myargs);\n  va_end(myargs);\n}\n#endif\n\n// ----------------------------------------------------- set_error_callback ---\nvoid\nset_error_callback(error_callback_t error_cb)\n{\n    log_error = error_cb;\n}\n\n__THREAD int freetype_gl_errno=0;\n__THREAD int freetype_gl_warnings=0;\n__THREAD const char * freetype_gl_message=NULL;\n\n#undef FTERRORS_H_\n#define FT_NOERRORDEF_( e, v, s )  [v] = s,\n#define FT_ERRORDEF_( e, v, s )  [v] = s,\n#define FTGL_ERRORDEF_( e, v, s )  [v+FTGL_ERR_BASE] = s,\n#define FT_ERROR_START_LIST\n#define FT_ERROR_END_LIST\n#define FTGL_ERROR_START_LIST\n#define FTGL_ERROR_END_LIST\n\nconst char* freetype_gl_errstrs[] = {\n  #include <freetype/fterrdef.h>\n  #include \"freetype-gl-errdef.h\"\n  [FTGL_ERR_MAX+1] = NULL\n};\n\nconst char* FTGL_Error_String( unsigned int error_code )\n{\n    if( error_code > FTGL_ERR_MAX) return NULL;\n    return freetype_gl_errstrs[error_code];\n}\n\n#undef FTGL_ERRORDEF_\n#undef __FREETYPE_GL_ERRORS_H__\n#undef FT_ERROR_START_LIST\n#undef FT_ERROR_END_LIST\n#undef FTGL_ERROR_START_LIST\n#undef FTGL_ERROR_END_LIST\n"
        },
        {
          "name": "ftgl-utils.h",
          "type": "blob",
          "size": 4.0380859375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __FTGL_UTILS_H__\n#define __FTGL_UTILS_H__\n#include <stdio.h>\n#include <stdarg.h>\n\n#ifndef __THREAD\n#if defined(__GNUC__) || defined(__clang__)\n#define __THREAD __thread\n#elif defined(_MSC_VER)\n#define __THREAD __declspec( thread )\n#else\n#define __THREAD\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\nnamespace ftgl {\n#endif\n\n\ntypedef void (*error_callback_t) (const char *fmt, ...);\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\nerror_callback_t log_error;\n\n/**\n * Prints input to stderr\n * This is fallback function for error reporting if ftgl_set_error_callback() wans't called\n *\n * @param fmt       cstring to be printed matching C-style printing syntax\n * @param ...       va_list fmt supplying arguments\n */\n  void\n  error_callback_default(const char *fmt, ...);\n\n/**\n * Set function to call on error handling\n * This is fallback function for error reporting if ftgl_set_error_callback() wans't called\n *\n * @param error_cb  callback function to call on error, see error_callback_default for reference\n */\n  void\n  set_error_callback(error_callback_t error_cb);\n\n/*********** public error API ***********/\n/**\n * freetype_gl_errno    is the error number if a freetype-gl function fails\n *                      Errors < FTGL_ERR_BASE are pass-through from Freetype\n */\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\n__THREAD int freetype_gl_errno;\n/**\n * freetype_gl_warnings is a flag that activates output of warnings.\n *                      Default is warnings off\n */\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\n__THREAD int freetype_gl_warnings;\n/**\n * freetype_gl_message  is the error message if a freetype-gl function fails\n */\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\n__THREAD const char * freetype_gl_message;\n/**\n * FTGL_Error_String  converts an errno to the message (including FT_errors)\n */\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\nconst char* FTGL_Error_String( unsigned int error_code );\n\n#ifndef FTGL_ERR_PREFIX\n# define FTGL_ERR_PREFIX  FTGL_Err_\n#endif\n\n#ifndef FTGL_ERR_CAT\n# define FTGL_ERR_XCAT( x, y )  x ## y\n# define FTGL_ERR_CAT( x, y )   FTGL_ERR_XCAT( x, y )\n#endif\n#define FTGL_ERR_BASE  0xE0 /* Freetype GL errors start at 0xE0 */\n\n#ifndef IMPLEMENT_FREETYPE_GL\nextern\n#endif\nconst char* freetype_gl_errstrs[];\n\n#define freetype_gl_error(errno) {\t\t\t     \\\n\tfreetype_gl_errno = FTGL_ERR_CAT( FTGL_ERR_PREFIX, errno);\t\\\n\tfreetype_gl_message = freetype_gl_errstrs[freetype_gl_errno]; \\\n\tlog_error(\"FTGL Error %s:%d: %s\\n\", __FILE__, __LINE__, freetype_gl_message); \\\n    }\n\n#define freetype_gl_error_str(errno, string) {\t\t\t\t\t\\\n\tfreetype_gl_errno = FTGL_ERR_CAT( FTGL_ERR_PREFIX, errno);\t\\\n\tfreetype_gl_message = freetype_gl_errstrs[freetype_gl_errno]; \\\n\tlog_error(\"FTGL Error %s:%d: %s '%s'\\n\", __FILE__, __LINE__, freetype_gl_message, string); \\\n    }\n\n#define freetype_gl_warning(errno) {\t\t\t     \\\n\tfreetype_gl_errno = FTGL_ERR_CAT( FTGL_ERR_PREFIX, errno);\t\\\n\tfreetype_gl_message = freetype_gl_errstrs[freetype_gl_errno]; \\\n\tif(freetype_gl_warnings) log_error(\"FTGL Warning %s:%d: %s\\n\", __FILE__, __LINE__, freetype_gl_message); \\\n    }\n\n#define freetype_error(errno) {\t\t\t     \\\n\tfreetype_gl_errno = errno;\t\\\n\tfreetype_gl_message = freetype_gl_errstrs[errno]; \\\n\tlog_error(\"Freetype Error %s:%d: %s\\n\", __FILE__, __LINE__, freetype_gl_message); \\\n    }\n\n#define FTGL_ERR_MAX FTGL_ERR_BASE+0x1F\n\n#ifndef FTGL_ERRORDEF_\n# ifndef FTGL_ERRORDEF\n\n#  define FTGL_ERRORDEF( e, v, s )  e = v,\n#  define FTGL_ERROR_START_LIST     enum {\n#  define FTGL_ERROR_END_LIST       FTGL_ERR_CAT( FTGL_ERR_PREFIX, Max ) };\n\n# endif /* !FTGL_ERRORDEF */\n\n    /* this macro is used to define an error */\n# define FTGL_ERRORDEF_( e, v, s )\t\t\t\t\t\t\\\n          FTGL_ERRORDEF( FTGL_ERR_CAT( FTGL_ERR_PREFIX, e ), v + FTGL_ERR_BASE, s )\n# endif /* !FTGL_ERRORDEF_ */\n\n#include \"freetype-gl-errdef.h\"\n\n#undef FTGL_ERRORDEF_\n#undef __FREETYPE_GL_ERRORS_H__\n#undef FTGL_ERROR_START_LIST\n#undef FTGL_ERROR_END_LIST\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "harfbuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "makefont.c",
          "type": "blob",
          "size": 16.4375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include \"opengl.h\"\n#include \"vec234.h\"\n#include \"vector.h\"\n#include \"freetype-gl.h\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n\n#ifndef WIN32\n#   define PRIzu \"zu\"\n#else\n#   define PRIzu \"Iu\"\n#endif\n\n\n// ------------------------------------------------------------- print help ---\nvoid print_help()\n{\n    fprintf( stderr, \"Usage: makefont [--help] --font <font file> \"\n             \"--header <header file> --size <font size> \"\n             \"--variable <variable name> --texture <texture size> \"\n             \"--rendermode <one of 'normal', 'outline_edge', 'outline_positive', 'outline_negative' or 'sdf'>\\n\" );\n}\n\nvoid print_glyph(FILE * file, texture_glyph_t * glyph)\n{\n    // TextureFont\n    fprintf( file, \"  {%u, \", glyph->codepoint );\n    fprintf( file, \"%\" PRIzu \", %\" PRIzu \", \", glyph->width, glyph->height );\n    fprintf( file, \"%d, %d, \", glyph->offset_x, glyph->offset_y );\n    fprintf( file, \"%ff, %ff, \", glyph->advance_x, glyph->advance_y );\n    fprintf( file, \"%ff, %ff, %ff, %ff, \", glyph->s0, glyph->t0, glyph->s1, glyph->t1 );\n    fprintf( file, \"%\" PRIzu \", \", vector_size(glyph->kerning) );\n    if (vector_size(glyph->kerning) == 0) {\n\tfprintf( file, \"{{0}}\" );\n    } else {\n\tint k;\n\tfprintf( file, \"{ \" );\n\tfor( k=0; k < vector_size(glyph->kerning); ++k ) {\n\t    float *kerning = *(float **) vector_get( glyph->kerning, k);\n\t    int l;\n\t    fprintf( file, \"{\" );\n\t    for( l=0; l<0xff; l++ )\n\t\tfprintf( file, \" %ff,\", kerning[l] );\n\t    fprintf( file, \" %ff }\", kerning[0xFF] );\n\n\t    if( k < (vector_size(glyph->kerning)-1))\n\t\tfprintf( file, \",\\n\" );\n\t}\n\tfprintf( file, \" }\" );\n    }\n    fprintf( file, \" };\\n\" );\n}\n// ------------------------------------------------------------------- main ---\nint main( int argc, char **argv )\n{\n    FILE* test;\n    size_t i, j, k;\n    int arg;\n\n    char * font_cache =\n        \" !\\\"#$%&'()*+,-./0123456789:;<=>?\"\n        \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\"\n        \"`abcdefghijklmnopqrstuvwxyz{|}~\";\n\n    float  font_size   = 0.0;\n    const char * font_filename   = NULL;\n    const char * header_filename = NULL;\n    const char * variable_name   = \"font\";\n    int show_help = 0;\n    size_t texture_width = 0;\n    rendermode_t rendermode = RENDER_NORMAL;\n    const char *rendermodes[5];\n    rendermodes[RENDER_NORMAL] = \"normal\";\n    rendermodes[RENDER_OUTLINE_EDGE] = \"outline edge\";\n    rendermodes[RENDER_OUTLINE_POSITIVE] = \"outline added\";\n    rendermodes[RENDER_OUTLINE_NEGATIVE] = \"outline removed\";\n    rendermodes[RENDER_SIGNED_DISTANCE_FIELD] = \"signed distance field\";\n\n    for ( arg = 1; arg < argc; ++arg )\n    {\n        if ( 0 == strcmp( \"--font\", argv[arg] ) || 0 == strcmp( \"-f\", argv[arg] ) )\n        {\n            ++arg;\n\n            if ( font_filename )\n            {\n                fprintf( stderr, \"Multiple --font parameters.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No font file given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            font_filename = argv[arg];\n            continue;\n        }\n\n        if ( 0 == strcmp( \"--header\", argv[arg] ) || 0 == strcmp( \"-o\", argv[arg] )  )\n        {\n            ++arg;\n\n            if ( header_filename )\n            {\n                fprintf( stderr, \"Multiple --header parameters.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No header file given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            header_filename = argv[arg];\n            continue;\n        }\n\n        if ( 0 == strcmp( \"--help\", argv[arg] ) || 0 == strcmp( \"-h\", argv[arg] ) )\n        {\n            show_help = 1;\n            break;\n        }\n\n        if ( 0 == strcmp( \"--size\", argv[arg] ) || 0 == strcmp( \"-s\", argv[arg] ) )\n        {\n            ++arg;\n\n            if ( 0.0 != font_size )\n            {\n                fprintf( stderr, \"Multiple --size parameters.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No font size given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            errno = 0;\n\n            font_size = atof( argv[arg] );\n\n            if ( errno )\n            {\n                fprintf( stderr, \"No valid font size given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            continue;\n        }\n\n        if ( 0 == strcmp( \"--variable\", argv[arg] ) || 0 == strcmp( \"-a\", argv[arg] )  )\n        {\n            ++arg;\n\n            if ( 0 != strcmp( \"font\", variable_name ) )\n            {\n                fprintf( stderr, \"Multiple --variable parameters.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No variable name given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            variable_name = argv[arg];\n            continue;\n        }\n\n        if ( 0 == strcmp( \"--texture\", argv[arg] ) || 0 == strcmp( \"-t\", argv[arg] ) )\n        {\n            ++arg;\n\n            if ( 0 != texture_width )\n            {\n                fprintf( stderr, \"Multiple --texture parameters.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No texture size given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            errno = 0;\n\n            texture_width = atof( argv[arg] );\n\n            if ( errno )\n            {\n                fprintf( stderr, \"No valid texture size given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            continue;\n        }\n\n        if ( 0 == strcmp( \"--rendermode\", argv[arg] ) || 0 == strcmp( \"-r\", argv[arg] ) )\n        {\n            ++arg;\n\n            if ( arg >= argc )\n            {\n                fprintf( stderr, \"No render mode given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            errno = 0;\n\n            if( 0 == strcmp( \"normal\", argv[arg] ) )\n            {\n                rendermode = RENDER_NORMAL;\n            }\n            else if( 0 == strcmp( \"outline_edge\", argv[arg] ) )\n            {\n                rendermode = RENDER_OUTLINE_EDGE;\n            }\n            else if( 0 == strcmp( \"outline_positive\", argv[arg] ) )\n            {\n                rendermode = RENDER_OUTLINE_POSITIVE;\n            }\n            else if( 0 == strcmp( \"outline_negative\", argv[arg] ) )\n            {\n                rendermode = RENDER_OUTLINE_NEGATIVE;\n            }\n            else if( 0 == strcmp( \"sdf\", argv[arg] ) )\n            {\n                rendermode = RENDER_SIGNED_DISTANCE_FIELD;\n            }\n            else\n            {\n                fprintf( stderr, \"No valid render mode given.\\n\" );\n                print_help();\n                exit( 1 );\n            }\n\n            continue;\n        }\n\n        fprintf( stderr, \"Unknown parameter %s\\n\", argv[arg] );\n        print_help();\n        exit( 1 );\n    }\n\n    if ( show_help )\n    {\n        print_help();\n        exit( 1 );\n    }\n\n    if ( !font_filename )\n    {\n        fprintf( stderr, \"No font file given.\\n\" );\n        print_help();\n        exit( 1 );\n    }\n\n    if ( !( test = fopen( font_filename, \"r\" ) ) )\n    {\n        fprintf( stderr, \"Font file \\\"%s\\\" does not exist.\\n\", font_filename );\n    }\n\n    fclose( test );\n\n    if ( 4.0 > font_size )\n    {\n        fprintf( stderr, \"Font size too small, expected at least 4 pt.\\n\" );\n        print_help();\n        exit( 1 );\n    }\n\n    if ( !header_filename )\n    {\n        fprintf( stderr, \"No header file given.\\n\" );\n        print_help();\n        exit( 1 );\n    }\n\n    if ( 0 == texture_width )\n    {\n        texture_width = 128;\n    }\n\n    texture_atlas_t * atlas = texture_atlas_new( texture_width, texture_width, 1 );\n    texture_font_t  * font  = texture_font_new_from_file( atlas, font_size, font_filename );\n    font->rendermode = rendermode;\n\n    size_t missed = texture_font_load_glyphs( font, font_cache );\n\n    printf( \"Font filename           : %s\\n\"\n            \"Font size               : %.1f\\n\"\n            \"Number of glyphs        : %ld\\n\"\n            \"Number of missed glyphs : %ld\\n\"\n            \"Texture size            : %ldx%ldx%ld\\n\"\n            \"Texture occupancy       : %.2f%%\\n\"\n            \"\\n\"\n            \"Header filename         : %s\\n\"\n            \"Variable name           : %s\\n\"\n            \"Render mode             : %s\\n\",\n            font_filename,\n            font_size,\n            strlen(font_cache),\n            missed,\n            atlas->width, atlas->height, atlas->depth,\n            100.0 * atlas->used / (float)(atlas->width * atlas->height),\n            header_filename,\n            variable_name,\n            rendermodes[rendermode] );\n\n    size_t texture_size = atlas->width * atlas->height * atlas->depth;\n    size_t glyph_count = font->glyphs->size;\n    size_t max_kerning_count = 1;\n    for( i=0; i < glyph_count; ++i )\n    {\n        texture_glyph_t **glyph_0x100 = *(texture_glyph_t ***) vector_get( font->glyphs, i );\n\tif(glyph_0x100) {\n\t    for( j=0; j < 0x100; ++j ) {\n\t\ttexture_glyph_t *glyph;\n\t\tif(( glyph = glyph_0x100[j] )) {\n\t\t    size_t new_max = vector_size(glyph->kerning);\n\t\t    if( new_max > max_kerning_count )\n\t\t\tmax_kerning_count = new_max;\n\t\t}\n\t    }\n\t}\n    }\n\n\n    FILE *file = fopen( header_filename, \"w\" );\n\n\n    // -------------\n    // Header\n    // -------------\n    fprintf( file,\n        \"/* ============================================================================\\n\"\n        \" * Freetype GL - A C OpenGL Freetype engine\\n\"\n        \" * Platform:    Any\\n\"\n        \" * WWW:         https://github.com/rougier/freetype-gl\\n\"\n        \" * ----------------------------------------------------------------------------\\n\"\n        \" * Copyright 2011,2012 Nicolas P. Rougier. All rights reserved.\\n\"\n        \" *\\n\"\n        \" * Redistribution and use in source and binary forms, with or without\\n\"\n        \" * modification, are permitted provided that the following conditions are met:\\n\"\n        \" *\\n\"\n        \" *  1. Redistributions of source code must retain the above copyright notice,\\n\"\n        \" *     this list of conditions and the following disclaimer.\\n\"\n        \" *\\n\"\n        \" *  2. Redistributions in binary form must reproduce the above copyright\\n\"\n        \" *     notice, this list of conditions and the following disclaimer in the\\n\"\n        \" *     documentation and/or other materials provided with the distribution.\\n\"\n        \" *\\n\"\n        \" * THIS SOFTWARE IS PROVIDED BY NICOLAS P. ROUGIER ''AS IS'' AND ANY EXPRESS OR\\n\"\n        \" * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\n\"\n        \" * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\\n\"\n        \" * EVENT SHALL NICOLAS P. ROUGIER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\\n\"\n        \" * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\\n\"\n        \" * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\\n\"\n        \" * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\\n\"\n        \" * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n        \" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n        \" * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n        \" *\\n\"\n        \" * The views and conclusions contained in the software and documentation are\\n\"\n        \" * those of the authors and should not be interpreted as representing official\\n\"\n        \" * policies, either expressed or implied, of Nicolas P. Rougier.\\n\"\n        \" * ============================================================================\\n\"\n        \" */\\n\\n\");\n\n    fprintf( file, \n        \"/* ============================================================================\\n\"\n        \" * Parameters\\n\"\n        \" * ----------------------------------------------------------------------------\\n\"\n        \" * Font size: %f\\n\"\n        \" * Texture width: %zu\\n\"\n        \" * Texture height: %zu\\n\"\n        \" * Texture depth: %zu\\n\"\n        \" * ===============================================================================\\n\"\n        \" */\\n\\n\", \n        font_size, atlas->width, atlas->height, atlas->depth);\n\n\n    // ----------------------\n    // Structure declarations\n    // ----------------------\n    fprintf( file,\n\t     \"#include <stddef.h>\\n\"\n\t     \"#include <stdint.h>\\n\"\n\t     \"#ifdef __cplusplus\\n\"\n\t     \"extern \\\"C\\\" {\\n\"\n\t     \"#endif\\n\"\n\t     \"\\n\" );\n\n    fprintf( file,\n        \"typedef struct\\n\"\n        \"{\\n\"\n        \"    uint32_t codepoint;\\n\"\n        \"    int width, height;\\n\"\n        \"    int offset_x, offset_y;\\n\"\n        \"    float advance_x, advance_y;\\n\"\n        \"    float s0, t0, s1, t1;\\n\"\n        \"    size_t kerning_count;\\n\"\n        \"    float kerning[%\" PRIzu \"][0x100];\\n\"\n        \"} texture_glyph_t;\\n\\n\", max_kerning_count );\n\n    fprintf( file,\n        \"typedef struct\\n\"\n        \"{\\n\"\n        \"    size_t tex_width;\\n\"\n        \"    size_t tex_height;\\n\"\n        \"    size_t tex_depth;\\n\"\n        \"    unsigned char tex_data[%\" PRIzu \"];\\n\"\n        \"    float size;\\n\"\n        \"    float height;\\n\"\n        \"    float linegap;\\n\"\n        \"    float ascender;\\n\"\n        \"    float descender;\\n\"\n        \"    size_t glyphs_count;\\n\"\n        \"    texture_glyph_t *glyphs[%\" PRIzu \"][0x100];\\n\"\n        \"} texture_font_t;\\n\\n\", texture_size, glyph_count );\n\n    texture_glyph_t * glyph;\n\n    GLYPHS_ITERATOR(i, glyph, font->glyphs) {\n\tfprintf( file, \"texture_glyph_t %s_glyph_%08x = \", variable_name, glyph->codepoint );\n /*\n        // Debugging information\n        printf( \"glyph : '%lc'\\n\",\n                 glyph->codepoint );\n        printf( \"  size       : %dx%d\\n\",\n                 glyph->width, glyph->height );\n        printf( \"  offset     : %+d%+d\\n\",\n                 glyph->offset_x, glyph->offset_y );\n        printf( \"  advance    : %ff, %ff\\n\",\n                 glyph->advance_x, glyph->advance_y );\n        printf( \"  tex coords.: %ff, %ff, %ff, %ff\\n\",\n                 glyph->u0, glyph->v0, glyph->u1, glyph->v1 );\n\n        printf( \"  kerning    : \" );\n        if( glyph->kerning_count )\n        {\n            for( j=0; j < glyph->kerning_count; ++j )\n            {\n                printf( \"('%lc', %ff)\",\n                         glyph->kerning[j].codepoint, glyph->kerning[j].kerning );\n                if( j < (glyph->kerning_count-1) )\n                {\n                    printf( \", \" );\n                }\n            }\n        }\n        else\n        {\n            printf( \"None\" );\n        }\n        printf( \"\\n\\n\" );\n*/\n\tprint_glyph(file, glyph);\n    }\n    GLYPHS_ITERATOR_END\n\n    fprintf( file, \"texture_font_t %s = {\\n\", variable_name );\n\n\n    // ------------\n    // Texture data\n    // ------------\n    fprintf( file, \" %\" PRIzu \", %\" PRIzu \", %\" PRIzu \",\\n\", atlas->width, atlas->height, atlas->depth );\n    fprintf( file, \" {\" );\n    for( i=0; i < texture_size; i+= 32 )\n    {\n        for( j=0; j < 32 && (j+i) < texture_size ; ++ j)\n        {\n            if( (j+i) < (texture_size-1) )\n            {\n                fprintf( file, \"%d,\", atlas->data[i+j] );\n            }\n            else\n            {\n                fprintf( file, \"%d\", atlas->data[i+j] );\n            }\n        }\n        if( (j+i) < texture_size )\n        {\n            fprintf( file, \"\\n\" );\n        }\n    }\n    fprintf( file, \"}, \\n\" );\n\n\n    // -------------------\n    // Texture information\n    // -------------------\n    fprintf( file, \" %ff, %ff, %ff, %ff, %ff, %\" PRIzu \", \\n\",\n             font->size, font->height,\n             font->linegap,font->ascender, font->descender,\n             glyph_count );\n\n    // --------------\n    // Texture glyphs\n    // --------------\n    fprintf( file, \" {\\n\" );\n    GLYPHS_ITERATOR1(i, glyph, font->glyphs) {\n\tfprintf( file, \" {\\n\" );\n\tGLYPHS_ITERATOR2(i, glyph, font->glyphs) {\n\t    fprintf( file, \"  &%s_glyph_%08x,\\n\", variable_name, glyph->codepoint );\n\t} else {\n\t    fprintf( file, \"  NULL,\\n\" );\n\t}\n\tGLYPHS_ITERATOR_END1;\n\tfprintf( file, \" },\\n\" );\n    } GLYPHS_ITERATOR_END2;\n    fprintf( file, \" }\\n};\\n\" );\n    fprintf( file,\n        \"#ifdef __cplusplus\\n\"\n        \"}\\n\"\n        \"#endif\\n\" );\n\n    return 0;\n}\n"
        },
        {
          "name": "markup.h",
          "type": "blob",
          "size": 2.5634765625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __MARKUP_H__\n#define __MARKUP_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"texture-font.h\"\n#include \"vec234.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   markup.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup markup Markup\n *\n * Simple structure that describes text properties.\n *\n * <b>Example Usage</b>:\n * @code\n * #include \"markup.h\"\n *\n * ...\n *\n * vec4 black  = {{0.0, 0.0, 0.0, 1.0}};\n * vec4 white  = {{1.0, 1.0, 1.0, 1.0}};\n * vec4 none   = {{1.0, 1.0, 1.0, 0.0}};\n *\n * markup_t normal = {\n *     .family  = \"Droid Serif\",\n *     .size = 24.0,\n *     .bold = 0,\n *     .italic = 0,\n *     .spacing = 1.0,\n *     .gamma = 1.0,\n *     .foreground_color = black, .background_color    = none,\n *     .underline        = 0,     .underline_color     = black,\n *     .overline         = 0,     .overline_color      = black,\n *     .strikethrough    = 0,     .strikethrough_color = black,\n *     .font = 0,\n * };\n *\n * ...\n *\n * @endcode\n *\n * @{\n */\n\n\n/**\n * Simple structure that describes text properties.\n */\ntypedef struct markup_t\n{\n    /**\n     * A font family name such as \"normal\", \"sans\", \"serif\" or \"monospace\".\n     */\n    char * family;\n\n    /**\n     * Font size.\n     */\n    float size;\n\n    /**\n     * Whether text is bold.\n     */\n    int bold;\n\n    /**\n     * Whether text is italic.\n     */\n    int italic;\n\n    /**\n     * Spacing between letters.\n     */\n    float spacing;\n\n    /**\n     * Gamma correction.\n     */\n    float gamma;\n\n    /**\n     * Text color.\n     */\n    vec4 foreground_color;\n\n    /**\n     * Background color.\n     */\n    vec4 background_color;\n\n    /**\n     * Whether outline is active.\n     */\n    int outline;\n\n    /**\n     * Outline color.\n     */\n    vec4 outline_color;\n\n    /**\n     * Whether underline is active.\n     */\n    int underline;\n\n    /**\n     * Underline color.\n     */\n    vec4 underline_color;\n\n    /**\n     * Whether overline is active.\n     */\n    int overline;\n\n    /**\n     * Overline color.\n     */\n    vec4 overline_color;\n\n    /**\n     * Whether strikethrough is active.\n     */\n    int strikethrough;\n\n    /**\n     * Strikethrough color.\n     */\n    vec4 strikethrough_color;\n\n    /**\n     * Pointer on the corresponding font (family/size/bold/italic)\n     */\n    texture_font_t * font;\n\n} markup_t;\n\n/**\n  * Default markup\n  */\nextern markup_t default_markup;\n\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __MARKUP_H__ */\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 1.044921875,
          "content": "project('freetype-gl', 'c')\n\nc = meson.get_compiler('c')\nm = c.find_library('m')\nfreetype2 = dependency('freetype2')\ngl = dependency('opengl')\n\nconf_data = configuration_data()\nconfigure_file(output: 'config.h', configuration: conf_data)\n# TODO add config data\n\nfreetype_gl_sources = files('distance-field.c', \n                'edtaa3func.c', \n                'ftgl-utils.c',\n                'font-manager.c', \n                'platform.c', \n                'text-buffer.c', \n                'texture-atlas.c', \n                'texture-font.c', \n                'utf8-utils.c',\n                'vector.c',\n                'vertex-attribute.c',\n                'vertex-buffer.c')\n\ninc = include_directories('.')\ndeps = [freetype2, gl, m]\n\nfreetype_gl_lib = library('freetype-gl', freetype_gl_sources, include_directories: inc, dependencies: deps)\nfreetype_gl_dep = declare_dependency(include_directories: inc, dependencies: deps, link_with: freetype_gl_lib)\n\nmakefont_sources = files('makefont.c')\nexecutable('makefont', makefont_sources, dependencies: freetype_gl_dep)\n"
        },
        {
          "name": "opengl.h",
          "type": "blob",
          "size": 0.966796875,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __OPEN_GL_H__\n#define __OPEN_GL_H__\n#include \"config.h\"\n\n#if defined(GL_WITH_GLAD)\n#   include <glad/glad.h>\n#else\n#if defined(__APPLE__)\n#   include \"TargetConditionals.h\"\n#   if TARGET_OS_SIMULATOR || TARGET_OS_IPHONE\n#     if defined(FREETYPE_GL_ES_VERSION_3_0)\n#       include <OpenGLES/ES3/gl.h>\n#     else\n#       include <OpenGLES/ES2/gl.h>\n#     endif\n#   else\n#     include <OpenGL/gl.h>\n#   endif\n#elif defined(_WIN32) || defined(_WIN64)\n#  include <GL/glew.h>\n#  include <GL/wglew.h>\n#elif defined(__ANDROID_API__)\n#  if defined(FREETYPE_GL_ES_VERSION_3_0)\n#    include <GLES3/gl3.h>\n#  else\n#    include <GLES2/gl2.h>\n#  endif\n#else\n#if defined(FREETYPE_GL_USE_GLEW)\n#  include <GL/glew.h>\n#endif\n#  define GL_GLEXT_PROTOTYPES\n#  include <GL/gl.h>\n#endif\n#endif /* GL_WITH_GLAD */\n\n#endif /* OPEN_GL_H */\n"
        },
        {
          "name": "platform.c",
          "type": "blob",
          "size": 0.65234375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <string.h>\n#include \"platform.h\"\n\n#if defined(_WIN32) || defined(_WIN64)\n\n#include <math.h>\n\n// strndup() is not available on Windows\nchar *strndup( const char *s1, size_t n)\n{\n    char *copy= (char*)malloc( n+1 );\n    memcpy( copy, s1, n );\n    copy[n] = 0;\n    return copy;\n};\n#endif\n\n\n// strndup() was only added in OSX lion\n#if defined(__APPLE__)\nchar *strndup( const char *s1, size_t n)\n{\n    char *copy = calloc( n+1, sizeof(char) );\n    memcpy( copy, s1, n );\n    return copy;\n};\n#endif\n"
        },
        {
          "name": "platform.h",
          "type": "blob",
          "size": 0.6669921875,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __PLATFORM_H__\n#define __PLATFORM_H__\n\n#include <stdlib.h>\n\n#ifdef __cplusplus\nextern \"C\" {\nnamespace ftgl {\n#endif\n\n#ifdef __APPLE__\n    /* strndup() was only added in OSX lion */\n    char * strndup( const char *s1, size_t n);\n#elif defined(_WIN32) || defined(_WIN64)\n    /* does not exist on windows */\n    char * strndup( const char *s1, size_t n);\n#    pragma warning (disable: 4244) // suspend warnings\n#endif // _WIN32 || _WIN64\n\n#ifdef __cplusplus\n}\n}\n#endif // __cplusplus\n\n#endif /* __PLATFORM_H__ */\n"
        },
        {
          "name": "shaders",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "text-buffer.c",
          "type": "blob",
          "size": 16.744140625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <math.h>\n#include \"opengl.h\"\n#include \"text-buffer.h\"\n#include \"utf8-utils.h\"\n#include \"ftgl-utils.h\"\n\n#define SET_GLYPH_VERTEX(value,x0,y0,z0,s0,t0,r,g,b,a,sh,gm) { \\\n    glyph_vertex_t *gv=&value;\t\t\t\t       \\\n    gv->x=x0; gv->y=y0; gv->z=z0;\t\t\t       \\\n    gv->u=s0; gv->v=t0;\t\t\t\t\t       \\\n    gv->r=r; gv->g=g; gv->b=b; gv->a=a;\t\t\t       \\\n    gv->shift=sh; gv->gamma=gm;}\n\n// ----------------------------------------------------------------------------\n\ntext_buffer_t *\ntext_buffer_new( void )\n{\n    text_buffer_t *self = (text_buffer_t *) malloc (sizeof(text_buffer_t));\n    self->buffer = vertex_buffer_new(\n                                     \"vertex:3f,tex_coord:2f,color:4f,ashift:1f,agamma:1f\" );\n    self->line_start = 0;\n    self->line_ascender = 0;\n    self->base_color.r = 0.0;\n    self->base_color.g = 0.0;\n    self->base_color.b = 0.0;\n    self->base_color.a = 1.0;\n    self->line_descender = 0;\n    self->lines = vector_new( sizeof(line_info_t) );\n    self->bounds.left   = 0.0;\n    self->bounds.top    = 0.0;\n    self->bounds.width  = 0.0;\n    self->bounds.height = 0.0;\n    return self;\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_delete( text_buffer_t * self )\n{\n    vector_delete( self->lines );\n    vertex_buffer_delete( self->buffer );\n    free( self );\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_clear( text_buffer_t * self )\n{\n    assert( self );\n\n    vertex_buffer_clear( self->buffer );\n    self->line_start = 0;\n    self->line_ascender = 0;\n    self->line_descender = 0;\n    vector_clear( self->lines );\n    self->bounds.left   = 0.0;\n    self->bounds.top    = 0.0;\n    self->bounds.width  = 0.0;\n    self->bounds.height = 0.0;\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_printf( text_buffer_t * self, vec2 *pen, ... )\n{\n    markup_t *markup;\n    char *text;\n    va_list args;\n\n    if( vertex_buffer_size( self->buffer ) == 0 )\n    {\n        self->origin = *pen;\n    }\n\n    va_start ( args, pen );\n    do {\n        markup = va_arg( args, markup_t * );\n        if( markup == NULL )\n        {\n            return;\n        }\n        text = va_arg( args, char * );\n        text_buffer_add_text( self, pen, markup, text, 0 );\n    } while( markup != 0 );\n    va_end ( args );\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_move_last_line( text_buffer_t * self, float dy )\n{\n    size_t i;\n    int j;\n    for( i=self->line_start; i < vector_size( self->buffer->items ); ++i )\n    {\n        ivec4 *item = (ivec4 *) vector_get( self->buffer->items, i);\n        for( j=item->vstart; j<item->vstart+item->vcount; ++j)\n        {\n            glyph_vertex_t * vertex =\n                (glyph_vertex_t *)  vector_get( self->buffer->vertices, j );\n            vertex->y -= dy;\n        }\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// text_buffer_finish_line (internal use only)\n//\n// Performs calculations needed at the end of each line of text\n// and prepares for the next line if necessary\n//\n// advancePen: if true, advance the pen to the next line\n//\nstatic void\ntext_buffer_finish_line( text_buffer_t * self, vec2 * pen, bool advancePen )\n{\n    float line_left = self->line_left;\n    float line_right = pen->x;\n    float line_width  = line_right - line_left;\n    float line_top = pen->y + self->line_ascender;\n    float line_height = self->line_ascender - self->line_descender;\n    float line_bottom = line_top - line_height;\n\n    line_info_t line_info;\n    line_info.line_start = self->line_start;\n    line_info.bounds.left = line_left;\n    line_info.bounds.top = line_top;\n    line_info.bounds.width = line_width;\n    line_info.bounds.height = line_height;\n\n    vector_push_back( self->lines,  &line_info);\n\n\n    if (line_left < self->bounds.left)\n    {\n        self->bounds.left = line_left;\n    }\n    if (line_top > self->bounds.top)\n    {\n        self->bounds.top = line_top;\n    }\n\n    float self_right = self->bounds.left + self->bounds.width;\n    float self_bottom = self->bounds.top - self->bounds.height;\n\n    if (line_right > self_right)\n    {\n        self->bounds.width = line_right - self->bounds.left;\n    }\n    if (line_bottom < self_bottom)\n    {\n        self->bounds.height = self->bounds.top - line_bottom;\n    }\n\n    if ( advancePen )\n    {\n        pen->x = self->origin.x;\n        pen->y += (int)(self->line_descender);\n    }\n\n    self->line_descender = 0;\n    self->line_ascender = 0;\n    self->line_start = vector_size( self->buffer->items );\n    self->line_left = pen->x;\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_add_text( text_buffer_t * self,\n                      vec2 * pen, markup_t * markup,\n                      const char * text, size_t length )\n{\n    size_t i;\n    const char * prev_character = NULL;\n\n    if( markup == NULL )\n    {\n        return;\n    }\n\n    if( !markup->font )\n    {\n        freetype_gl_error( No_Font_In_Markup );\n        return;\n    }\n\n    if( length == 0 )\n    {\n        length = utf8_strlen(text);\n    }\n    if( vertex_buffer_size( self->buffer ) == 0 )\n    {\n        self->origin = *pen;\n        self->line_left = pen->x;\n        self->bounds.left = pen->x;\n        self->bounds.top = pen->y;\n    }\n    else\n    {\n        if (pen->x < self->origin.x)\n        {\n            self->origin.x = pen->x;\n        }\n        if (pen->y != self->last_pen_y)\n        {\n            text_buffer_finish_line(self, pen, false);\n        }\n    }\n\n    for( i = 0; length; i += utf8_surrogate_len( text + i ) )\n    {\n        text_buffer_add_char( self, pen, markup, text + i, prev_character );\n        prev_character = text + i;\n        length--;\n    }\n\n    self->last_pen_y = pen->y;\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_add_char( text_buffer_t * self,\n                      vec2 * pen, markup_t * markup,\n                      const char * current, const char * previous )\n{\n    size_t vcount = 0;\n    size_t icount = 0;\n    vertex_buffer_t * buffer = self->buffer;\n    texture_font_t * font = markup->font;\n    float gamma = markup->gamma;\n\n    // Maximum number of vertices is 20 (= 5x2 triangles) per glyph:\n    //  - 2 triangles for background\n    //  - 2 triangles for overline\n    //  - 2 triangles for underline\n    //  - 2 triangles for strikethrough\n    //  - 2 triangles for glyph\n    glyph_vertex_t vertices[4*5];\n    GLuint indices[6*5];\n    texture_glyph_t *glyph;\n    texture_glyph_t *black;\n    float kerning = 0.0f;\n\n    if( markup->font->ascender > self->line_ascender )\n    {\n        float y = pen->y;\n        pen->y -= (markup->font->ascender - self->line_ascender);\n        text_buffer_move_last_line( self, (float)(int)(y-pen->y) );\n        self->line_ascender = markup->font->ascender;\n    }\n    if( markup->font->descender < self->line_descender )\n    {\n        self->line_descender = markup->font->descender;\n    }\n\n    if( *current == '\\n' )\n    {\n        text_buffer_finish_line(self, pen, true);\n        return;\n    }\n\n    glyph = texture_font_get_glyph( font, current );\n    black = texture_font_get_glyph( font, NULL );\n\n    if( glyph == NULL )\n    {\n        return;\n    }\n\n    if( previous && markup->font->kerning )\n    {\n        kerning = texture_glyph_get_kerning( glyph, previous );\n    }\n    pen->x += kerning;\n\n    // Background\n    if( markup->background_color.alpha > 0 )\n    {\n        float r = markup->background_color.r;\n        float g = markup->background_color.g;\n        float b = markup->background_color.b;\n        float a = markup->background_color.a;\n        float x0 = ( pen->x -kerning );\n        float y0 = (float)(int)( pen->y + font->descender );\n        float x1 = ( x0 + glyph->advance_x );\n        float y1 = (float)(int)( y0 + font->height + font->linegap );\n        float s0 = black->s0;\n        float t0 = black->t0;\n        float s1 = black->s1;\n        float t1 = black->t1;\n\n        SET_GLYPH_VERTEX(vertices[vcount+0],\n                         (float)(int)x0,y0,0,  s0,t0,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+1],\n                         (float)(int)x0,y1,0,  s0,t1,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+2],\n                         (float)(int)x1,y1,0,  s1,t1,  r,g,b,a,  x1-((int)x1), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+3],\n                         (float)(int)x1,y0,0,  s1,t0,  r,g,b,a,  x1-((int)x1), gamma );\n        indices[icount + 0] = vcount+0;\n        indices[icount + 1] = vcount+1;\n        indices[icount + 2] = vcount+2;\n        indices[icount + 3] = vcount+0;\n        indices[icount + 4] = vcount+2;\n        indices[icount + 5] = vcount+3;\n        vcount += 4;\n        icount += 6;\n    }\n\n    // Underline\n    if( markup->underline )\n    {\n        float r = markup->underline_color.r;\n        float g = markup->underline_color.g;\n        float b = markup->underline_color.b;\n        float a = markup->underline_color.a;\n        float x0 = ( pen->x - kerning );\n        float y0 = (float)(int)( pen->y + font->underline_position );\n        float x1 = ( x0 + glyph->advance_x );\n        float y1 = (float)(int)( y0 + font->underline_thickness );\n        float s0 = black->s0;\n        float t0 = black->t0;\n        float s1 = black->s1;\n        float t1 = black->t1;\n\n        SET_GLYPH_VERTEX(vertices[vcount+0],\n                         (float)(int)x0,y0,0,  s0,t0,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+1],\n                         (float)(int)x0,y1,0,  s0,t1,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+2],\n                         (float)(int)x1,y1,0,  s1,t1,  r,g,b,a,  x1-((int)x1), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+3],\n                         (float)(int)x1,y0,0,  s1,t0,  r,g,b,a,  x1-((int)x1), gamma );\n        indices[icount + 0] = vcount+0;\n        indices[icount + 1] = vcount+1;\n        indices[icount + 2] = vcount+2;\n        indices[icount + 3] = vcount+0;\n        indices[icount + 4] = vcount+2;\n        indices[icount + 5] = vcount+3;\n        vcount += 4;\n        icount += 6;\n    }\n\n    // Overline\n    if( markup->overline )\n    {\n        float r = markup->overline_color.r;\n        float g = markup->overline_color.g;\n        float b = markup->overline_color.b;\n        float a = markup->overline_color.a;\n        float x0 = ( pen->x -kerning );\n        float y0 = (float)(int)( pen->y + (int)font->ascender );\n        float x1 = ( x0 + glyph->advance_x );\n        float y1 = (float)(int)( y0 + (int)font->underline_thickness );\n        float s0 = black->s0;\n        float t0 = black->t0;\n        float s1 = black->s1;\n        float t1 = black->t1;\n        SET_GLYPH_VERTEX(vertices[vcount+0],\n                         (float)(int)x0,y0,0,  s0,t0,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+1],\n                         (float)(int)x0,y1,0,  s0,t1,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+2],\n                         (float)(int)x1,y1,0,  s1,t1,  r,g,b,a,  x1-((int)x1), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+3],\n                         (float)(int)x1,y0,0,  s1,t0,  r,g,b,a,  x1-((int)x1), gamma );\n        indices[icount + 0] = vcount+0;\n        indices[icount + 1] = vcount+1;\n        indices[icount + 2] = vcount+2;\n        indices[icount + 3] = vcount+0;\n        indices[icount + 4] = vcount+2;\n        indices[icount + 5] = vcount+3;\n        vcount += 4;\n        icount += 6;\n    }\n\n    /* Strikethrough */\n    if( markup->strikethrough )\n    {\n        float r = markup->strikethrough_color.r;\n        float g = markup->strikethrough_color.g;\n        float b = markup->strikethrough_color.b;\n        float a = markup->strikethrough_color.a;\n        float x0  = ( pen->x -kerning );\n        float y0  = (float)(int)( pen->y + (int)font->ascender*.33f);\n        float x1  = ( x0 + glyph->advance_x );\n        float y1  = (float)(int)( y0 + (int)font->underline_thickness );\n        float s0 = black->s0;\n        float t0 = black->t0;\n        float s1 = black->s1;\n        float t1 = black->t1;\n        SET_GLYPH_VERTEX(vertices[vcount+0],\n                         (float)(int)x0,y0,0,  s0,t0,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+1],\n                         (float)(int)x0,y1,0,  s0,t1,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+2],\n                         (float)(int)x1,y1,0,  s1,t1,  r,g,b,a,  x1-((int)x1), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+3],\n                         (float)(int)x1,y0,0,  s1,t0,  r,g,b,a,  x1-((int)x1), gamma );\n        indices[icount + 0] = vcount+0;\n        indices[icount + 1] = vcount+1;\n        indices[icount + 2] = vcount+2;\n        indices[icount + 3] = vcount+0;\n        indices[icount + 4] = vcount+2;\n        indices[icount + 5] = vcount+3;\n        vcount += 4;\n        icount += 6;\n    }\n    {\n        // Actual glyph\n        float r = markup->foreground_color.red;\n        float g = markup->foreground_color.green;\n        float b = markup->foreground_color.blue;\n        float a = markup->foreground_color.alpha;\n        float x0 = ( pen->x + glyph->offset_x );\n        float y0 = (float)(int)( pen->y + glyph->offset_y );\n        float x1 = ( x0 + glyph->width );\n        float y1 = (float)(int)( y0 - glyph->height );\n        float s0 = glyph->s0;\n        float t0 = glyph->t0;\n        float s1 = glyph->s1;\n        float t1 = glyph->t1;\n\n        SET_GLYPH_VERTEX(vertices[vcount+0],\n                         (float)(int)x0,y0,0,  s0,t0,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+1],\n                         (float)(int)x0,y1,0,  s0,t1,  r,g,b,a,  x0-((int)x0), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+2],\n                         (float)(int)x1,y1,0,  s1,t1,  r,g,b,a,  x1-((int)x1), gamma );\n        SET_GLYPH_VERTEX(vertices[vcount+3],\n                         (float)(int)x1,y0,0,  s1,t0,  r,g,b,a,  x1-((int)x1), gamma );\n        indices[icount + 0] = vcount+0;\n        indices[icount + 1] = vcount+1;\n        indices[icount + 2] = vcount+2;\n        indices[icount + 3] = vcount+0;\n        indices[icount + 4] = vcount+2;\n        indices[icount + 5] = vcount+3;\n        vcount += 4;\n        icount += 6;\n\n        vertex_buffer_push_back( buffer, vertices, vcount, indices, icount );\n        pen->x += glyph->advance_x * (1.0f + markup->spacing);\n    }\n}\n\n// ----------------------------------------------------------------------------\nvoid\ntext_buffer_align( text_buffer_t * self, vec2 * pen,\n                   enum Align alignment )\n{\n    if (ALIGN_LEFT == alignment)\n    {\n        return;\n    }\n\n    size_t total_items = vector_size( self->buffer->items );\n    if ( self->line_start != total_items )\n    {\n        text_buffer_finish_line( self, pen, false );\n    }\n\n\n    size_t i, j;\n    int k;\n    float self_left, self_right, self_center;\n    float line_left, line_right, line_center;\n    float dx;\n\n    self_left = self->bounds.left;\n    self_right = self->bounds.left + self->bounds.width;\n    self_center = (self_left + self_right) / 2;\n\n    line_info_t* line_info;\n    size_t lines_count, line_end;\n\n    lines_count = vector_size( self->lines );\n    for ( i = 0; i < lines_count; ++i )\n    {\n        line_info = (line_info_t*)vector_get( self->lines, i );\n\n        if ( i + 1 < lines_count )\n        {\n            line_end = ((line_info_t*)vector_get( self->lines, i + 1 ))->line_start;\n        }\n        else\n        {\n            line_end = vector_size( self->buffer->items );\n        }\n\n        line_right = line_info->bounds.left + line_info->bounds.width;\n\n        if ( ALIGN_RIGHT == alignment )\n        {\n            dx = self_right - line_right;\n        }\n        else // ALIGN_CENTER\n        {\n            line_left = line_info->bounds.left;\n            line_center = (line_left + line_right) / 2;\n            dx = self_center - line_center;\n        }\n\n        dx = roundf( dx );\n\n        for( j=line_info->line_start; j < line_end; ++j )\n        {\n            ivec4 *item = (ivec4 *) vector_get( self->buffer->items, j);\n            for( k=item->vstart; k<item->vstart+item->vcount; ++k)\n            {\n                glyph_vertex_t * vertex =\n                                   (glyph_vertex_t *)vector_get( self->buffer->vertices, k );\n                vertex->x += dx;\n            }\n        }\n    }\n}\n\nvec4\ntext_buffer_get_bounds( text_buffer_t * self, vec2 * pen )\n{\n    size_t total_items = vector_size( self->buffer->items );\n    if ( self->line_start != total_items )\n    {\n        text_buffer_finish_line( self, pen, false );\n    }\n\n    return self->bounds;\n}\n"
        },
        {
          "name": "text-buffer.h",
          "type": "blob",
          "size": 4.947265625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __TEXT_BUFFER_H__\n#define __TEXT_BUFFER_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"vertex-buffer.h\"\n#include \"markup.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * Use LCD filtering\n */\n#define LCD_FILTERING_ON    3\n\n/**\n * Do not use LCD filtering\n */\n#define LCD_FILTERING_OFF 1\n\n/**\n * @file   text-buffer.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup text-buffer Text buffer\n *\n *\n * <b>Example Usage</b>:\n * @code\n *\n * int main( int arrgc, char *argv[] )\n * {\n *\n *     return 0;\n * }\n * @endcode\n *\n * @{\n */\n\n/**\n * Text buffer structure\n */\ntypedef struct  text_buffer_t {\n    /**\n     * Vertex buffer\n     */\n    vertex_buffer_t *buffer;\n\n    /**\n     * Base color for text\n     */\n    vec4 base_color;\n\n\n    /**\n     * Pen origin\n     */\n    vec2 origin;\n\n    /**\n     * Last pen y location\n     */\n    float last_pen_y;\n\n    /**\n     * Total bounds\n     */\n    vec4 bounds;\n\n    /**\n     * Index (in the vertex buffer) of the current line start\n     */\n    size_t line_start;\n\n    /**\n     * Location of the start of the line\n     */\n    float line_left;\n\n    /**\n     * Vector of line information\n     */\n    vector_t * lines;\n\n    /**\n     * Current line ascender\n     */\n    float line_ascender;\n\n    /**\n     * Current line decender\n     */\n    float line_descender;\n} text_buffer_t;\n\n\n\n/**\n * Glyph vertex structure\n */\ntypedef struct glyph_vertex_t {\n    /**\n     * Vertex x coordinates\n     */\n    float x;\n\n    /**\n     * Vertex y coordinates\n     */\n    float y;\n\n    /**\n     * Vertex z coordinates\n     */\n    float z;\n\n    /**\n     * Texture first coordinate\n     */\n    float u;\n\n    /**\n     * Texture second coordinate\n     */\n    float v;\n\n    /**\n     * Color red component\n     */\n    float r;\n\n    /**\n     * Color green component\n     */\n    float g;\n\n    /**\n     * Color blue component\n     */\n    float b;\n\n    /**\n     * Color alpha component\n     */\n    float a;\n\n    /**\n     * Shift along x\n     */\n    float shift;\n\n    /**\n     * Color gamma correction\n     */\n    float gamma;\n\n} glyph_vertex_t;\n\n\n/**\n * Line structure\n */\ntypedef struct line_info_t {\n    /**\n     * Index (in the vertex buffer) where this line starts\n     */\n    size_t line_start;\n\n    /**\n     * bounds of this line\n     */\n    vec4 bounds;\n\n} line_info_t;\n\n/**\n * Align enumeration\n */\ntypedef enum Align\n{\n    /**\n     * Align text to the left hand side\n     */\n    ALIGN_LEFT,\n\n    /**\n     * Align text to the center\n     */\n    ALIGN_CENTER,\n\n    /**\n     * Align text to the right hand side\n     */\n    ALIGN_RIGHT\n} Align;\n\n\n/**\n * Creates a new empty text buffer.\n *\n * @return  a new empty text buffer.\n *\n */\n  text_buffer_t *\n  text_buffer_new( void );\n\n/**\n * Deletes texture buffer and its associated vertex buffer.\n *\n * @param  self  texture buffer to delete\n *\n */\n  void\n  text_buffer_delete( text_buffer_t * self );\n\n\n /**\n  * Print some text to the text buffer\n  *\n  * @param self a text buffer\n  * @param pen  position of text start\n  * @param ...  a series of markup_t *, char * ended by NULL\n  *\n  */\n  void\n  text_buffer_printf( text_buffer_t * self, vec2 * pen, ... );\n\n\n /**\n  * Add some text to the text buffer\n  *\n  * @param self   a text buffer\n  * @param pen    position of text start\n  * @param markup Markup to be used to add text\n  * @param text   Text to be added\n  * @param length Length of text to be added\n  */\n  void\n  text_buffer_add_text( text_buffer_t * self,\n                        vec2 * pen, markup_t * markup,\n                        const char * text, size_t length );\n\n /**\n  * Add a char to the text buffer\n  *\n  * @param self     a text buffer\n  * @param pen      position of text start\n  * @param markup   markup to be used to add text\n  * @param current  charactr to be added\n  * @param previous previous character (if any)\n  */\n  void\n  text_buffer_add_char( text_buffer_t * self,\n                        vec2 * pen, markup_t * markup,\n                        const char * current, const char * previous );\n\n /**\n  * Align all the lines of text already added to the buffer\n  * This alignment will be relative to the overall bounds of the\n  * text which can be queried by text_buffer_get_bounds\n  *\n  * @param self      a text buffer\n  * @param pen       pen used in last call (must be unmodified)\n  * @param alignment desired alignment of text\n  */\n  void\n  text_buffer_align( text_buffer_t * self, vec2 * pen,\n                     enum Align alignment );\n\n /**\n  * Get the rectangle surrounding the text\n  *\n  * @param self      a text buffer\n  * @param pen       pen used in last call (must be unmodified)\n  */\n  vec4\n  text_buffer_get_bounds( text_buffer_t * self, vec2 * pen );\n\n/**\n  * Clear text buffer\n  *\n  * @param self a text buffer\n */\n  void\n  text_buffer_clear( text_buffer_t * self );\n\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* #define __TEXT_BUFFER_H__ */\n"
        },
        {
          "name": "texture-atlas.c",
          "type": "blob",
          "size": 9.0859375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include \"texture-atlas.h\"\n#include \"texture-font.h\"\n#include \"ftgl-utils.h\"\n\n// -------------------------------------------------- texture_atlas_special ---\n\nvoid texture_atlas_special ( texture_atlas_t * self )\n{\n    ivec4 region = texture_atlas_get_region( self, 5, 5 );\n    texture_glyph_t * glyph = texture_glyph_new( );\n    static unsigned char data[4*4*3] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n                                        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n                                        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n                                        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\n    if ( region.x < 0 ) {\n        freetype_gl_error( Texture_Atlas_Full );\n    }\n    \n    texture_atlas_set_region( self, region.x, region.y, 4, 4, data, 0 );\n    glyph->codepoint = -1;\n    glyph->s0 = (region.x+2)/(float)self->width;\n    glyph->t0 = (region.y+2)/(float)self->height;\n    glyph->s1 = (region.x+3)/(float)self->width;\n    glyph->t1 = (region.y+3)/(float)self->height;\n\n    self->special = (void*)glyph;\n}\n\n// ------------------------------------------------------ texture_atlas_new ---\ntexture_atlas_t *\ntexture_atlas_new( const size_t width,\n                   const size_t height,\n                   const size_t depth )\n{\n    texture_atlas_t *self = (texture_atlas_t *) malloc( sizeof(texture_atlas_t) );\n\n    // We want a one pixel border around the whole atlas to avoid any artefact when\n    // sampling texture\n    ivec3 node = {{1,1,width-2}};\n\n    assert( (depth == 1) || (depth == 3) || (depth == 4) );\n    if( self == NULL)\n    {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n        /* exit( EXIT_FAILURE ); */ /* Never exit from a library */\n    }\n    self->nodes = vector_new( sizeof(ivec3) );\n    self->used = 0;\n    self->width = width;\n    self->height = height;\n    self->depth = depth;\n    self->id = 0;\n    self->modified = 1;\n\n    vector_push_back( self->nodes, &node );\n    self->data = (unsigned char *)\n        calloc( width*height*depth, sizeof(unsigned char) );\n\n    if( self->data == NULL)\n    {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n\n    texture_atlas_special( self );\n    \n    return self;\n}\n\n\n// --------------------------------------------------- texture_atlas_delete ---\nvoid\ntexture_atlas_delete( texture_atlas_t *self )\n{\n    assert( self );\n    vector_delete( self->nodes );\n    texture_glyph_delete( self->special );\n    if( self->data )\n    {\n        free( self->data );\n    }\n    free( self );\n}\n\n\n// ----------------------------------------------- texture_atlas_set_region ---\nvoid\ntexture_atlas_set_region( texture_atlas_t * self,\n                          const size_t x,\n                          const size_t y,\n                          const size_t width,\n                          const size_t height,\n                          const unsigned char * data,\n                          const size_t stride )\n{\n    size_t i;\n    size_t depth;\n    size_t charsize;\n\n    assert( self );\n    assert( x > 0);\n    assert( y > 0);\n    assert( x < (self->width-1));\n    assert( (x + width) <= (self->width-1));\n    assert( y < (self->height-1));\n    assert( (y + height) <= (self->height-1));\n        \n    // prevent copying data from undefined position\n    // and prevent memcpy's undefined behavior when count is zero\n    assert(height == 0 || (data != NULL && width > 0));\n\n    depth = self->depth;\n    charsize = sizeof(char);\n    for( i=0; i<height; ++i )\n    {\n        memcpy( self->data+((y+i)*self->width + x ) * charsize * depth,\n                data + (i*stride) * charsize, width * charsize * depth  );\n    }\n    self->modified = 1;\n}\n\n\n// ------------------------------------------------------ texture_atlas_fit ---\nint\ntexture_atlas_fit( texture_atlas_t * self,\n                   const size_t index,\n                   const size_t width,\n                   const size_t height )\n{\n    ivec3 *node;\n    int x, y, width_left;\n    size_t i;\n\n    assert( self );\n\n    node = (ivec3 *) (vector_get( self->nodes, index ));\n    x = node->x;\n    y = node->y;\n    width_left = width;\n    i = index;\n\n    if ( (x + width) > (self->width-1) )\n    {\n\treturn -1;\n    }\n    y = node->y;\n    while( width_left > 0 )\n    {\n\tnode = (ivec3 *) (vector_get( self->nodes, i ));\n\tif( node->y > y )\n\t{\n\t    y = node->y;\n\t}\n\tif( (y + height) > (self->height-1) )\n\t{\n\t    return -1;\n\t}\n\twidth_left -= node->z;\n\t++i;\n    }\n    return y;\n}\n\n\n// ---------------------------------------------------- texture_atlas_merge ---\nvoid\ntexture_atlas_merge( texture_atlas_t * self )\n{\n    ivec3 *node, *next;\n    size_t i;\n\n    assert( self );\n\n    for( i=0; i< self->nodes->size-1; ++i )\n    {\n        node = (ivec3 *) (vector_get( self->nodes, i ));\n        next = (ivec3 *) (vector_get( self->nodes, i+1 ));\n        if( node->y == next->y )\n\t{\n            node->z += next->z;\n            vector_erase( self->nodes, i+1 );\n            --i;\n        }\n    }\n}\n\n\n// ----------------------------------------------- texture_atlas_get_region ---\nivec4\ntexture_atlas_get_region( texture_atlas_t * self,\n                          const size_t width,\n                          const size_t height )\n{\n    int y, best_index;\n    size_t best_height, best_width;\n    ivec3 *node, *prev;\n    ivec4 region = {{0,0,width,height}};\n    size_t i;\n\n    assert( self );\n\n    best_height = UINT_MAX;\n    best_index  = -1;\n    best_width = UINT_MAX;\n    for( i=0; i<self->nodes->size; ++i )\n    {\n        y = texture_atlas_fit( self, i, width, height );\n        if( y >= 0 )\n\t{\n            node = (ivec3 *) vector_get( self->nodes, i );\n            if( ( (y + height) < best_height ) ||\n                ( ((y + height) == best_height) && (node->z > 0 && (size_t)node->z < best_width)) ) {\n                best_height = y + height;\n                best_index = i;\n                best_width = node->z;\n                region.x = node->x;\n                region.y = y;\n            }\n        }\n    }\n    \n    if( best_index == -1 )\n    {\n        region.x = -1;\n        region.y = -1;\n        region.width = 0;\n        region.height = 0;\n        return region;\n    }\n\n    node = (ivec3 *) malloc( sizeof(ivec3) );\n    if( node == NULL) {\n        freetype_gl_error( Out_Of_Memory );\n        return (ivec4){{-1,-1,0,0}};\n        /* exit( EXIT_FAILURE ); */ /* Never exit from a library */\n    }\n    node->x = region.x;\n    node->y = region.y + height;\n    node->z = width;\n    vector_insert( self->nodes, best_index, node );\n    free( node );\n\n    for( i = best_index+1; i < self->nodes->size; ++i )\n    {\n        node = (ivec3 *) vector_get( self->nodes, i );\n        prev = (ivec3 *) vector_get( self->nodes, i-1 );\n\n        if (node->x < (prev->x + prev->z) )\n\t{\n            int shrink = prev->x + prev->z - node->x;\n            node->x += shrink;\n            node->z -= shrink;\n            if (node->z <= 0) {\n                vector_erase( self->nodes, i );\n                --i;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    texture_atlas_merge( self );\n    self->used += width * height;\n    self->modified = 1;    \n    return region;\n}\n\n\n// ---------------------------------------------------- texture_atlas_clear ---\nvoid\ntexture_atlas_clear( texture_atlas_t * self )\n{\n    ivec3 node = {{1,1,1}};\n\n    assert( self );\n    assert( self->data );\n\n    vector_clear( self->nodes );\n    self->used = 0;\n    // We want a one pixel border around the whole atlas to avoid any artefact when\n    // sampling texture\n    node.z = self->width-2;\n\n    vector_push_back( self->nodes, &node );\n    memset( self->data, 0, self->width*self->height*self->depth );\n}\n\n// -------------------------------------------- texture_atlas_enlarge_atlas ---\n\nvoid texture_atlas_enlarge_texture ( texture_atlas_t* self, size_t width_new, size_t height_new)\n{\n    assert(self);\n    //ensure size increased\n    assert(width_new >= self->width);\n    assert(height_new >= self->height);\n    assert(width_new + height_new > self->width + self->height);\n\n    size_t width_old = self->width;\n    size_t height_old = self->height;    \n    //allocate new buffer\n    unsigned char* data_old = self->data;\n    self->data = calloc(1,width_new*height_new * sizeof(char)*self->depth);    \n    //update atlas size\n    self->width = width_new;\n    self->height = height_new;\n    //add node reflecting the gained space on the right\n    if( width_new>width_old )\n    {\n        ivec3 node;\n        node.x = width_old - 1;\n        node.y = 1;\n        node.z = width_new - width_old;\n        vector_push_back(self->nodes, &node);    \n    }\n    //copy over data from the old buffer, skipping first row and column because of the margin\n    size_t pixel_size = sizeof(char) * self->depth;\n    size_t old_row_size = width_old * pixel_size;\n    texture_atlas_set_region(self, 1, 1, width_old - 2, height_old - 2, data_old + old_row_size + pixel_size, old_row_size);\n    free(data_old);    \n}\n"
        },
        {
          "name": "texture-atlas.h",
          "type": "blob",
          "size": 4.8515625,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n *  ============================================================================\n *\n *\n * This source is based on the article by Jukka Jylänki :\n * \"A Thousand Ways to Pack the Bin - A Practical Approach to\n * Two-Dimensional Rectangle Bin Packing\", February 27, 2010.\n *\n * More precisely, this is an implementation of the Skyline Bottom-Left\n * algorithm based on C++ sources provided by Jukka Jylänki at:\n * http://clb.demon.fi/files/RectangleBinPack/\n *\n *  ============================================================================\n */\n#ifndef __TEXTURE_ATLAS_H__\n#define __TEXTURE_ATLAS_H__\n\n#include <stdlib.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"vector.h\"\n#include \"vec234.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   texture-atlas.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup texture-atlas Texture atlas\n *\n * A texture atlas is used to pack several small regions into a single texture.\n *\n * The actual implementation is based on the article by Jukka Jylänki : \"A\n * Thousand Ways to Pack the Bin - A Practical Approach to Two-Dimensional\n * Rectangle Bin Packing\", February 27, 2010.\n * More precisely, this is an implementation of the Skyline Bottom-Left\n * algorithm based on C++ sources provided by Jukka Jylänki at:\n * http://clb.demon.fi/files/RectangleBinPack/\n *\n *\n * Example Usage:\n * @code\n * #include \"texture-atlas.h\"\n *\n * ...\n *\n * / Creates a new atlas of 512x512 with a depth of 1\n * texture_atlas_t * atlas = texture_atlas_new( 512, 512, 1 );\n *\n * // Allocates a region of 20x20\n * ivec4 region = texture_atlas_get_region( atlas, 20, 20 );\n *\n * // Fill region with some data\n * texture_atlas_set_region( atlas, region.x, region.y, region.width, region.height, data, stride )\n *\n * ...\n *\n * @endcode\n *\n * @{\n */\n\n\n/**\n * A texture atlas is used to pack several small regions into a single texture.\n */\ntypedef struct texture_atlas_t\n{\n    /**\n     * Allocated nodes\n     */\n    vector_t * nodes;\n\n    /**\n     *  Width (in pixels) of the underlying texture\n     */\n    size_t width;\n\n    /**\n     * Height (in pixels) of the underlying texture\n     */\n    size_t height;\n\n    /**\n     * Depth (in bytes) of the underlying texture\n     */\n    size_t depth;\n\n    /**\n     * Allocated surface size\n     */\n    size_t used;\n\n    /**\n     * Texture identity (OpenGL)\n     */\n    unsigned int id;\n\n    /**\n     * Atlas data\n     */\n    unsigned char * data;\n\n    /**\n     * Atlas has been modified\n     */\n    unsigned char modified;\n\n    /**\n     * Atlas special glyph, this is a void*, and will be typecasted as necessary\n     */\n\n    void * special;\n\n} texture_atlas_t;\n\n\n\n/**\n * Creates a new empty texture atlas.\n *\n * @param   width   width of the atlas\n * @param   height  height of the atlas\n * @param   depth   bit depth of the atlas\n * @return          a new empty texture atlas.\n *\n */\n  texture_atlas_t *\n  texture_atlas_new( const size_t width,\n                     const size_t height,\n                     const size_t depth );\n\n\n/**\n *  Deletes a texture atlas.\n *\n *  @param self a texture atlas structure\n *\n */\n  void\n  texture_atlas_delete( texture_atlas_t * self );\n\n\n/**\n *  Allocate a new region in the atlas.\n *\n *  @param self   a texture atlas structure\n *  @param width  width of the region to allocate\n *  @param height height of the region to allocate\n *  @return       Coordinates of the allocated region\n *\n */\n  ivec4\n  texture_atlas_get_region( texture_atlas_t * self,\n                            const size_t width,\n                            const size_t height );\n\n\n/**\n *  Upload data to the specified atlas region.\n *\n *  @param self   a texture atlas structure\n *  @param x      x coordinate the region\n *  @param y      y coordinate the region\n *  @param width  width of the region\n *  @param height height of the region\n *  @param data   data to be uploaded into the specified region\n *  @param stride stride of the data\n *\n */\n  void\n  texture_atlas_set_region( texture_atlas_t * self,\n                            const size_t x,\n                            const size_t y,\n                            const size_t width,\n                            const size_t height,\n                            const unsigned char *data,\n                            const size_t stride );\n\n/**\n *  Remove all allocated regions from the atlas.\n *\n *  @param self   a texture atlas structure\n */\n  void\n  texture_atlas_clear( texture_atlas_t * self );\n\n/**\n *  Enlarge a texture atlas\n *\n *  @param self       a texture atlas structure\n *  @param width_new  new width\n *  @param height_new new height\n */\n  void\n  texture_atlas_enlarge_texture ( texture_atlas_t* self, size_t width_new, size_t height_new);\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __TEXTURE_ATLAS_H__ */\n"
        },
        {
          "name": "texture-font.c",
          "type": "blob",
          "size": 37.208984375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_SIZES_H\n#include FT_STROKER_H\n// #include FT_ADVANCES_H\n#include FT_LCD_FILTER_H\n#include FT_TRUETYPE_TABLES_H\n#include FT_MULTIPLE_MASTERS_H\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n#ifdef __APPLE__\n# include <machine/endian.h>\n# define __BIG_ENDIAN __ORDER_BIG_ENDIAN__\n# define __LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__\n# define __BYTE_ORDER __BYTE_ORDER__\n#elif defined(_WIN32) || defined(_WIN64)\n# define __LITTLE_ENDIAN 1234\n# define __BIG_ENDIAN 4321\n# define __BYTE_ORDER __LITTLE_ENDIAN\n#else\n# include <endian.h>\n#endif\n#include \"distance-field.h\"\n#include \"texture-font.h\"\n#include \"platform.h\"\n#include \"utf8-utils.h\"\n#include \"ftgl-utils.h\"\n\n#define HRES  64\n#define HRESf 64.f\n#define DPI   72\n\nstatic float convert_F26Dot6_to_float(FT_F26Dot6 value)\n{\n  return ((float)value) / 64.0;\n}\nstatic FT_F26Dot6 convert_float_to_F26Dot6(float value)\n{\n  return (FT_F26Dot6) (value * 64.0);\n}\n\n// per-thread library\n\n__THREAD texture_font_library_t * freetype_gl_library = NULL;\n__THREAD font_mode_t mode_default=MODE_FREE_CLOSE;\n\n// rol8 ror8\n\n#if (defined(_WIN32) || defined(_WIN64)) && !defined(__GNUC__)\n# define inline\nstatic inline __builtin_bswap32(uint32_t in)\n{\n    return ((in >> 24) & 0xFF) | ((in >> 8) & 0xFF00) | ((in & 0xFF00) << 8) | ((in & 0xFF) << 24);\n}\n#endif\n\nstatic inline uint32_t rol(uint32_t in, uint32_t x)\n{\n    return (in >> (32-x)) | (in << x);\n}\n\n// ------------------------------------------------------ texture_glyph_clone ---\ntexture_glyph_t*\ntexture_glyph_clone(texture_glyph_t* self)\n{\n    int i;\n    texture_glyph_t* new_glyph;\n    float* source;\n    float** target;\n    assert(self);\n\n    new_glyph = (texture_glyph_t *) malloc( sizeof(texture_glyph_t) );\n    if(new_glyph == NULL) {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n    memcpy(new_glyph, self, sizeof(texture_glyph_t));\n    new_glyph->kerning = vector_new(sizeof(float**));\n    vector_resize(new_glyph->kerning, self->kerning->size);\n    for (i = 0; i < self->kerning->size; i++) {\n        source = *(float**)vector_get(self->kerning, i);\n        target = (float**)vector_get(new_glyph->kerning, i);\n        *target = calloc(0x100, sizeof(float));\n        memcpy(*target, source, 0x100);\n    }\n    return new_glyph;\n}\n\n// ------------------------------------------------------ texture_glyph_new ---\ntexture_glyph_t *\ntexture_glyph_new(void)\n{\n    texture_glyph_t *self = (texture_glyph_t *) malloc( sizeof(texture_glyph_t) );\n    if(self == NULL) {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n\n    self->codepoint  = -1;\n    self->width     = 0;\n    self->height    = 0;\n    /* Attributes that can have different images for the same codepoint */\n    self->rendermode = RENDER_NORMAL;\n    self->outline_thickness = 0.0;\n    self->glyphmode = GLYPH_END;\n    /* End of attribute part */\n    self->offset_x  = 0;\n    self->offset_y  = 0;\n    self->advance_x = 0.0;\n    self->advance_y = 0.0;\n    self->s0        = 0.0;\n    self->t0        = 0.0;\n    self->s1        = 0.0;\n    self->t1        = 0.0;\n    self->kerning   = vector_new( sizeof(float**) );\n    return self;\n}\n\n// ---------------------------------------------- texture_font_default_mode ---\nvoid\ntexture_font_default_mode(font_mode_t mode)\n{\n    mode_default=mode;\n}\n\n// --------------------------------------------------- texture_glyph_delete ---\nvoid\ntexture_glyph_delete( texture_glyph_t *self )\n{\n    int i;\n    assert( self );\n    for(i=0; i < self->kerning->size; i++)\n        free( *(float **) vector_get( self->kerning, i ) );\n    vector_delete( self->kerning );\n    free( self );\n}\n\n// ---------------------------------------------- texture_glyph_get_kerning ---\nfloat\ntexture_glyph_get_kerning( const texture_glyph_t * self,\n                           const char * codepoint )\n{\n    uint32_t ucodepoint = utf8_to_utf32( codepoint );\n    uint32_t i = ucodepoint >> 8;\n    uint32_t j = ucodepoint & 0xFF;\n    float *kern_index;\n\n    assert( self );\n    if(ucodepoint == -1)\n        return 0;\n    if(self->kerning->size <= i)\n        return 0;\n\n    kern_index = *(float **) vector_get( self->kerning, i );\n\n    if(!kern_index)\n        return 0;\n    else\n        return kern_index[j];\n}\n\n// ---------------------------------------------- texture_font_index_kerning ---\n\nvoid texture_font_index_kerning( texture_glyph_t * self,\n                                 uint32_t codepoint,\n                                 float kerning)\n{\n    uint32_t i = codepoint >> 8;\n    uint32_t j = codepoint & 0xFF;\n    float ** kerning_index;\n\n    if(self->kerning->size <= i) {\n        vector_resize( self->kerning, i+1);\n    }\n\n    kerning_index = (float **) vector_get( self->kerning, i );\n\n    if(!*kerning_index) {\n        *kerning_index = calloc( 0x100, sizeof(float) );\n    }\n\n    (*kerning_index)[j] = kerning;\n}\n\n// ------------------------------------------ texture_font_generate_kerning ---\nvoid\ntexture_font_generate_kerning( texture_font_t *self,\n                               FT_Library *library, FT_Face *face )\n{\n    size_t i, j, k;\n    FT_UInt glyph_index, prev_index;\n    texture_glyph_t *glyph, *prev_glyph;\n    FT_Vector kerning;\n\n    assert( self );\n\n    /* For each glyph couple combination, check if kerning is necessary */\n    /* Starts at index 1 since 0 is for the special background glyph */\n    GLYPHS_ITERATOR(i, glyph, self->glyphs ) {\n        glyph_index = FT_Get_Char_Index( *face, glyph->codepoint );\n//        fprintf(stderr, \"Retrieving glyph %p from index %i\\n\", __glyphs, __i);\n//        fprintf(stderr, \"Glpyh %p: Indexing %d, kerning %p\\n\", glyph, glyph_index, glyph->kerning);\n        for(k=0; k < glyph->kerning->size; k++)\n            free( *(float **) vector_get( glyph->kerning, k ) );\n        vector_clear( glyph->kerning );\n        \n        GLYPHS_ITERATOR(j, prev_glyph, self->glyphs ) {\n            prev_index = FT_Get_Char_Index( *face, prev_glyph->codepoint );\n            // FT_KERNING_UNFITTED returns FT_F26Dot6 values.\n            FT_Get_Kerning( *face, prev_index, glyph_index, FT_KERNING_UNFITTED, &kerning );\n            // printf(\"%c(%d)-%c(%d): %ld\\n\",\n            //       prev_glyph->codepoint, prev_glyph->codepoint,\n            //       glyph_index, glyph_index, kerning.x);\n            if( kerning.x ) {\n                texture_font_index_kerning( glyph,\n                                            prev_glyph->codepoint,\n                                            convert_F26Dot6_to_float(kerning.x) / HRESf );\n            }\n            // also insert kerning with the current added element\n            FT_Get_Kerning( *face, glyph_index, prev_index, FT_KERNING_UNFITTED, &kerning );\n            if( kerning.x ) {\n                texture_font_index_kerning( prev_glyph,\n                                            glyph->codepoint,\n                                            kerning.x / (float)(HRESf*HRESf) );\n            }\n        }\n        GLYPHS_ITERATOR_END\n    }\n    GLYPHS_ITERATOR_END\n}\n\n// -------------------------------------------------- texture_is_color_font ---\n\nint\ntexture_is_color_font( texture_font_t *self) {\n    static const uint32_t tag = FT_MAKE_TAG('C', 'B', 'D', 'T');\n    unsigned long length = 0;\n    FT_Load_Sfnt_Table(self->face, tag, 0, NULL, &length);\n    return length != 0;\n}\n\n// -------------------------------------------------- texture_font_set_size ---\n\nint\ntexture_font_set_size ( texture_font_t *self, float size )\n{\n    FT_Error error=0;\n    FT_Matrix matrix = {\n        (int)((1.0/HRES) * 0x10000L),\n        (int)((0.0)      * 0x10000L),\n        (int)((0.0)      * 0x10000L),\n        (int)((1.0)      * 0x10000L)};\n\n    if( FT_HAS_FIXED_SIZES( self->face ) ) {\n        /* Select best size */\n        if (self->face->num_fixed_sizes == 0) {\n            freetype_gl_error( No_Fixed_Size_In_Color_Font );\n            return 0;\n        }\n        \n        int best_match = 0;\n        float diff = 1e20;\n        int i;\n\n        for (i = 0; i < self->face->num_fixed_sizes; ++i) {\n\t    float new_size = convert_F26Dot6_to_float(self->face->available_sizes[i].size);\n\t    float ndiff = size > new_size ? size / new_size : new_size / size;\n\t    if(freetype_gl_warnings)\n\t\tlog_error(\"candiate: size[%i]=%f %d*%d\\n\", i, new_size,\n\t\t\t  self->face->available_sizes[i].width,\n\t\t\t  self->face->available_sizes[i].height);\n            if (ndiff < diff) {\n                best_match = i;\n                diff = ndiff;\n            }\n        }\n\tif(freetype_gl_warnings)\n\t    log_error(\"selected: size[%i] for %f\\n\", best_match, size);\n        error = FT_Select_Size(self->face, best_match);\n        if(error) {\n            freetype_error( error );\n            return 0;\n        }\n        self->scale = self->size / convert_F26Dot6_to_float(self->face->available_sizes[best_match].size);\n    } else {\n        /* Set char size */\n        error = FT_Set_Char_Size(self->face, convert_float_to_F26Dot6(size), 0, DPI * HRES, DPI);\n        \n        if(error) {\n            freetype_error( error );\n            return 0;\n        }\n    }\n    /* Set transform matrix */\n    FT_Set_Transform(self->face, &matrix, NULL);\n\n    return 1;\n}\n\n// --------------------------------------------------\n\nvoid\ntexture_font_init_size( texture_font_t * self)\n{\n    FT_Size_Metrics metrics;\n    \n    self->underline_position = self->face->underline_position / (float)(HRESf*HRESf) * self->size;\n    self->underline_position = roundf( self->underline_position );\n    if( self->underline_position > -2 )\n    {\n        self->underline_position = -2.0;\n    }\n\n    self->underline_thickness = self->face->underline_thickness / (float)(HRESf*HRESf) * self->size;\n    self->underline_thickness = roundf( self->underline_thickness );\n    if( self->underline_thickness < 1 )\n    {\n        self->underline_thickness = 1.0;\n    }\n\n    metrics = self->face->size->metrics;\n    self->ascender  = metrics.ascender  >> 6;\n    self->descender = metrics.descender >> 6;\n    self->height    = metrics.height    >> 6;\n    self->linegap = self->height - self->ascender + self->descender;\n}\n\n// ------------------------------------------------------ texture_font_init ---\nstatic int\ntexture_font_init(texture_font_t *self)\n{\n    assert(self->atlas);\n    assert(self->size > 0);\n    assert((self->location == TEXTURE_FONT_FILE && self->filename)\n        || (self->location == TEXTURE_FONT_MEMORY\n            && self->memory.base && self->memory.size));\n\n    self->glyphs = vector_new(sizeof(texture_glyph_t *));\n    self->height = 0;\n    self->ascender = 0;\n    self->descender = 0;\n    self->linegap = 0;\n    self->rendermode = RENDER_NORMAL;\n    self->outline_thickness = 0.0;\n    self->hinting = 1;\n    self->kerning = 1;\n    self->filtering = 1;\n    self->scaletex = 1;\n    self->scale = 1.0;\n\n    // FT_LCD_FILTER_LIGHT   is (0x00, 0x55, 0x56, 0x55, 0x00)\n    // FT_LCD_FILTER_DEFAULT is (0x10, 0x40, 0x70, 0x40, 0x10)\n    self->lcd_weights[0] = 0x10;\n    self->lcd_weights[1] = 0x40;\n    self->lcd_weights[2] = 0x70;\n    self->lcd_weights[3] = 0x40;\n    self->lcd_weights[4] = 0x10;\n\n    if (!texture_font_load_face(self, self->size))\n        return -1;\n\n    texture_font_init_size( self );\n\n    if (!texture_font_set_size(self, self->size))\n        return -1;\n    \n    /* NULL is a special glyph */\n    texture_font_get_glyph( self, NULL );\n\n    return 0;\n}\n\n// ---------------------------------------------------- texture_library_new ---\ntexture_font_library_t *\ntexture_library_new(void)\n{\n    texture_font_library_t *self = calloc(1, sizeof(*self));\n    \n    self->mode = MODE_ALWAYS_OPEN;\n    \n    return self;\n}\n\n// --------------------------------------------- texture_font_new_from_file ---\ntexture_font_t *\ntexture_font_new_from_file(texture_atlas_t *atlas, const float pt_size,\n                           const char *filename)\n{\n    texture_font_t *self;\n\n    assert(filename);\n\n    self = calloc(1, sizeof(*self));\n    if (!self) {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n\n    self->atlas = atlas;\n    self->size  = pt_size;\n\n    self->location = TEXTURE_FONT_FILE;\n    self->filename = strdup(filename);\n    self->mode = mode_default;\n    \n    if (texture_font_init(self)) {\n        texture_font_delete(self);\n        return NULL;\n    }\n\n    return self;\n}\n\n// ------------------------------------------- texture_font_new_from_memory ---\ntexture_font_t *\ntexture_font_new_from_memory(texture_atlas_t *atlas, float pt_size,\n                             const void *memory_base, size_t memory_size)\n{\n    texture_font_t *self;\n\n    assert(memory_base);\n    assert(memory_size);\n\n    self = calloc(1, sizeof(*self));\n    if (!self) {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n\n    self->atlas = atlas;\n    self->size  = pt_size;\n\n    self->location = TEXTURE_FONT_MEMORY;\n    self->memory.base = memory_base;\n    self->memory.size = memory_size;\n    self->mode = mode_default;\n    \n    if (texture_font_init(self)) {\n        texture_font_delete(self);\n        return NULL;\n    }\n\n    return self;\n}\n\n// ----------------------------------------------------- texture_font_clone ---\ntexture_font_t *\ntexture_font_clone( texture_font_t *old, float pt_size)\n{\n    texture_font_t *self;\n    FT_Error error = 0;\n    float native_size = old->size / old->scale; // unscale fonts\n    \n    self = calloc(1, sizeof(*self));\n    if (!self) {\n        freetype_gl_error( Out_Of_Memory );\n        return NULL;\n    }\n\n    memcpy(self, old, sizeof(*self));\n    self->size  = pt_size;\n\n    error = FT_New_Size( self->face, &self->ft_size );\n    if(error) {\n        freetype_error( error );\n        return NULL;\n    }\n\n    error = FT_Activate_Size( self->ft_size );\n    if(error) {\n        freetype_error( error );\n        return NULL;\n    }\n    \n    if(!texture_font_set_size ( self, pt_size ))\n        return NULL;\n\n    texture_font_init_size( self );\n    \n    if(self->size / self->scale != native_size)\n        self->glyphs = vector_new(sizeof(texture_glyph_t *));\n    return self;\n}\n// ----------------------------------------------------- texture_font_close ---\n\nvoid\ntexture_font_close( texture_font_t *self, font_mode_t face_mode, font_mode_t library_mode )\n{\n    if( self->face && self->mode <= face_mode ) {\n        FT_Done_Face( self->face );\n        self->face = NULL;\n    } else {\n        return; // never close the library when the face stays open\n    }\n\n    if( self->library && self->library->library && self->library->mode <= library_mode ) {\n        FT_Done_FreeType( self->library->library );\n        self->library->library = NULL;\n    }\n}\n\n// ------------------------------------------------- texture_font_load_face ---\n\nint\ntexture_font_load_face( texture_font_t *self, float size )\n{\n    FT_Error error;\n\n    if ( !self->library ) {\n        if ( !freetype_gl_library ) {\n            freetype_gl_library = texture_library_new();\n        }\n        self->library = freetype_gl_library;\n    }\n    \n    if( !self->library->library ) {\n        error = FT_Init_FreeType( &self->library->library );\n        if(error) {\n            freetype_error( error );\n            goto cleanup;\n        }\n    }\n    \n    if( !self->face ) {\n        switch (self->location) {\n        case TEXTURE_FONT_FILE:\n            error = FT_New_Face(self->library->library, self->filename, 0, &self->face);\n            if(error) {\n                freetype_error( error );\n                goto cleanup_library;\n            }\n            break;\n\n        case TEXTURE_FONT_MEMORY:\n            error = FT_New_Memory_Face(self->library->library,\n                                       self->memory.base, self->memory.size, 0, &self->face);\n            if(error) {\n                freetype_error( error );\n                goto cleanup_library;\n            }\n            break;\n        }\n\n        /* Select charmap */\n        error = FT_Select_Charmap(self->face, FT_ENCODING_UNICODE);\n        if(error) {\n            freetype_error( error );\n            goto cleanup_face;\n        }\n\n        error = FT_New_Size( self->face, &self->ft_size );\n        if(error) {\n            freetype_error( error );\n            goto cleanup_face;\n        }\n\n        error = FT_Activate_Size( self->ft_size );\n        if(error) {\n            freetype_error( error );\n            goto cleanup_face;\n        }\n        \n        if(!texture_font_set_size ( self, size ))\n            goto cleanup_face;\n    }\n    \n    return 1;\n    \n  cleanup_face:\n    texture_font_close( self, MODE_ALWAYS_OPEN, MODE_FREE_CLOSE );\n    return 0;\n  cleanup_library:\n    texture_font_close( self, MODE_ALWAYS_OPEN, MODE_ALWAYS_OPEN );\n  cleanup:\n    return 0;\n}\n\n// ----------------------------------------------- texture_font_is_variable ---\nint\ntexture_font_is_variable( texture_font_t *self )\n{\n    int result = 0;\n\n    if( self && self->face )\n        result = self->face->face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS;\n\n    return result == FT_FACE_FLAG_MULTIPLE_MASTERS;\n}\n\n// ------------------------------------------------ texture_font_get_weight ---\nint\ntexture_font_get_weight( texture_font_t *self, FT_Fixed *def, FT_Fixed *min, FT_Fixed *max )\n{\n    int result = 0;\n\n    if( def && min && max ) {\n        *def = 0; *min = 0; *max = 0;\n\n        if( self && self->library->library && self->face ) {\n            FT_MM_Var *master;\n\n            if( FT_Get_MM_Var( self->face, &master ) == 0 ) {\n                const FT_Tag tag = FT_MAKE_TAG ('w', 'g', 'h', 't');\n                const char* name = \"Weight\";\n\n                for( unsigned int i = 0; i < 16 && i < master->num_axis; i++ ) {\n\n                    if( tag == master->axis[i].tag\n                        || strcmp( name, master->axis[i].name ) == 0 )\n                    {\n                        *def = master->axis[i].def;\n                        *min = master->axis[i].minimum;\n                        *max = master->axis[i].maximum;\n                        result = 1;\n                        break;\n                    }\n                }\n                FT_Done_MM_Var (self->library->library, master);\n            }\n        }\n    }\n\n    return result;\n}\n\n// ------------------------------------------------ texture_font_set_weight ---\nint\ntexture_font_set_weight( texture_font_t *self, FT_Fixed wght )\n{\n    int result = 0;\n\n    if( self && self->library->library && self->face ) {\n        FT_MM_Var *master;\n\n        if( FT_Get_MM_Var( self->face, &master ) == 0 ) {\n            const FT_Tag tag = FT_MAKE_TAG ('w', 'g', 'h', 't');\n            const char* name = \"Weight\";\n\n            for( unsigned int i = 0; i < 16 && i < master->num_axis; i++ ) {\n\n                if( tag == master->axis[i].tag\n                    || strcmp( name, master->axis[i].name ) == 0 )\n                {\n                    const FT_Fixed min = master->axis[i].minimum;\n                    const FT_Fixed max = master->axis[i].maximum;\n\n                    if( wght >= min && wght <= max )\n                    {\n                        const int n = i + 1;\n                        FT_Fixed coords[16];\n\n                        if( FT_Get_Var_Design_Coordinates( self->face, n, coords ) == 0 )\n                        {\n                            coords[i] = wght;\n\n                            if( FT_Set_Var_Design_Coordinates( self->face, n, coords ) == 0 )\n                                result = 1;\n                        }\n                    }\n                    else result = -1;\n\n                    break;\n                }\n            }\n            FT_Done_MM_Var (self->library->library, master);\n        }\n    }\n\n    if( result < 0 ) {\n        freetype_gl_warning( Variable_Font_Weight_Out_Of_Range );\n    } else if ( result == 0 ) {\n        freetype_gl_warning( Variable_Font_Weight_Not_Available );\n    }\n\n    return result == 1;\n}\n\n// ---------------------------------------------------- texture_font_delete ---\nvoid\ntexture_font_delete( texture_font_t *self )\n{\n    size_t i;\n    texture_glyph_t *glyph;\n    FT_Error error=0;\n\n    assert( self );\n\n    error = FT_Done_Size( self->ft_size );\n    if(error) {\n        freetype_error( error );\n    }\n\n    texture_font_close( self, MODE_ALWAYS_OPEN, MODE_FREE_CLOSE );\n\n    if(self->location == TEXTURE_FONT_FILE && self->filename)\n        free( self->filename );\n        \n    GLYPHS_ITERATOR(i, glyph, self->glyphs) {\n        texture_glyph_delete( glyph );\n    } GLYPHS_ITERATOR_END1\n        free( __glyphs );\n    GLYPHS_ITERATOR_END2;\n\n    vector_delete( self->glyphs );\n    free( self );\n}\n\n// ------------------------------------------------ texture_font_find_glyph ---\ntexture_glyph_t *\ntexture_font_find_glyph( texture_font_t * self,\n                         const char * codepoint )\n{\n    if(!codepoint)\n        return (texture_glyph_t *)self->atlas->special;\n    \n    return texture_font_find_glyph_gi(self, utf8_to_utf32( codepoint ));\n}\n\n// ---------------------------------------------- texture_font_find_glyph_gi ---\ntexture_glyph_t *\ntexture_font_find_glyph_gi( texture_font_t * self,\n                            uint32_t codepoint )\n{\n    uint32_t i = codepoint >> 8;\n    uint32_t j = codepoint & 0xFF;\n    texture_glyph_t **glyph_index1, *glyph;\n\n    if(self->glyphs->size <= i)\n        return NULL;\n\n    glyph_index1 = *(texture_glyph_t ***) vector_get( self->glyphs, i );\n\n    if(!glyph_index1)\n        return NULL;\n    else\n        glyph = glyph_index1[j];\n\n    while( glyph && // if no glyph is there, we are done here\n           (glyph->rendermode != self->rendermode ||\n            glyph->outline_thickness != self->outline_thickness) ) {\n        if( glyph->glyphmode != GLYPH_CONT)\n            return NULL;\n        glyph++;\n    }\n    return glyph;\n}\n\nint\ntexture_font_index_glyph( texture_font_t * self,\n                          texture_glyph_t *glyph,\n                          uint32_t codepoint)\n{\n    uint32_t i = codepoint >> 8;\n    uint32_t j = codepoint & 0xFF;\n    texture_glyph_t ***glyph_index1, *glyph_insert;\n\n    if(self->glyphs->size <= i) {\n        vector_resize( self->glyphs, i+1);\n    }\n\n    glyph_index1 = (texture_glyph_t ***) vector_get( self->glyphs, i );\n\n    if(!*glyph_index1) {\n        *glyph_index1 = calloc( 0x100, sizeof(texture_glyph_t*) );\n    }\n\n    if(( glyph_insert = (*glyph_index1)[j] )) {\n        int i = 0;\n        // fprintf(stderr, \"glyph already there\\n\");\n        while (glyph_insert[i].glyphmode != GLYPH_END)\n            i++;\n        // fprintf(stderr, \"Insert a glyph after position %d\\n\", i);\n        glyph_insert[i].glyphmode = GLYPH_CONT;\n        (*glyph_index1)[j] = glyph_insert = realloc( glyph_insert, sizeof(texture_glyph_t)*(i+2) );\n        memcpy( glyph_insert+(i+1), glyph, sizeof(texture_glyph_t) );\n        return 1;\n    } else {\n        (*glyph_index1)[j] = glyph;\n        return 0;\n    }\n}\n\n// ------------------------------------------------ texture_font_load_glyph ---\nint\ntexture_font_load_glyph( texture_font_t * self,\n                         const char * codepoint )\n{\n    /* codepoint NULL is special : it is used for line drawing (overline,\n     * underline, strikethrough) and background.\n     */\n    if( !codepoint ) {\n        return 1;\n    }\n    uint32_t ucodepoint = utf8_to_utf32(codepoint);\n\n    return texture_font_load_glyph_gi( self,\n                                       FT_Get_Char_Index( self->face, ucodepoint),\n                                       ucodepoint);\n}\n\n// ------------------------------------------------ texture_font_load_glyph ---\nint\ntexture_font_load_glyph_gi( texture_font_t * self,\n                            uint32_t glyph_index,\n                            uint32_t ucodepoint )\n{\n    size_t i, x, y;\n\n    FT_Error error;\n    FT_Face face;\n    FT_Glyph ft_glyph = NULL;\n    FT_GlyphSlot slot;\n    FT_Bitmap ft_bitmap;\n\n    texture_glyph_t *glyph;\n    FT_Int32 flags = 0;\n    int ft_glyph_top = 0;\n    int ft_glyph_left = 0;\n\n    ivec4 region;\n    size_t missed = 0;\n\n    /* Check if codepoint has been already loaded */\n    if (texture_font_find_glyph_gi(self, ucodepoint)) {\n        return 1;\n    }\n\n    if (!texture_font_load_face(self, self->size))\n        return 0;\n\n    flags = 0;\n    ft_glyph_top = 0;\n    ft_glyph_left = 0;\n    if(!glyph_index) {\n        texture_glyph_t * glyph;\n        if ((glyph = texture_font_find_glyph(self, \"\\0\"))) {\n            texture_font_index_glyph( self, glyph, ucodepoint );\n            texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n            return 1;\n        }\n    }\n    // WARNING: We use texture-atlas depth to guess if user wants\n    //          LCD subpixel rendering\n\n    if( self->rendermode != RENDER_NORMAL && self->rendermode != RENDER_SIGNED_DISTANCE_FIELD )\n    {\n        flags |= FT_LOAD_NO_BITMAP;\n    }\n    else\n    {\n        flags |= FT_LOAD_RENDER;\n    }\n\n    if( !self->hinting )\n    {\n        flags |= FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT;\n    }\n    else\n    {\n        flags |= FT_LOAD_FORCE_AUTOHINT;\n    }\n\n    if( self->atlas->depth == 3 )\n    {\n        FT_Library_SetLcdFilter( self->library->library, FT_LCD_FILTER_LIGHT );\n        flags |= FT_LOAD_TARGET_LCD;\n\n        if( self->filtering )\n        {\n            FT_Library_SetLcdFilterWeights( self->library->library, self->lcd_weights );\n        }\n    }\n    else if (HRES == 1)\n    {\n        /* “FT_LOAD_TARGET_LIGHT\n         *  A lighter hinting algorithm for gray-level modes. Many generated\n         *  glyphs are fuzzier but better resemble their original shape.\n         *  This is achieved by snapping glyphs to the pixel grid\n         *  only vertically (Y-axis), as is done by FreeType's new CFF engine\n         *  or Microsoft's ClearType font renderer.”\n         * https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#ft_load_target_xxx\n         */\n        flags |= FT_LOAD_TARGET_LIGHT;\n    }\n\n    if( self->atlas->depth == 4 )\n    {\n#ifdef FT_LOAD_COLOR\n        flags |= FT_LOAD_COLOR;\n#else\n        freetype_gl_error( Load_Color_Not_Available );\n#endif\n    }\n\n    error = FT_Activate_Size( self->ft_size );\n    if(error) {\n        freetype_error( error );\n        return 0;\n    }\n\n    error = FT_Load_Glyph( self->face, glyph_index, flags );\n    if( error )\n    {\n        freetype_error( error );\n        texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n        return 0;\n    }\n\n    if( self->rendermode == RENDER_NORMAL || self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )\n    {\n        slot            = self->face->glyph;\n        ft_bitmap       = slot->bitmap;\n        ft_glyph_top    = slot->bitmap_top;\n        ft_glyph_left   = slot->bitmap_left;\n    }\n    else\n    {\n        FT_Stroker stroker;\n        FT_BitmapGlyph ft_bitmap_glyph;\n\n        error = FT_Stroker_New( self->library->library, &stroker );\n\n        if( error )\n        {\n            freetype_error( error );\n            goto cleanup_stroker;\n        }\n\n        FT_Stroker_Set(stroker,\n                        (int)(self->outline_thickness * HRES),\n                        FT_STROKER_LINECAP_ROUND,\n                        FT_STROKER_LINEJOIN_ROUND,\n                        0);\n\n        error = FT_Get_Glyph( self->face->glyph, &ft_glyph);\n\n        if( error )\n        {\n            freetype_error( error );\n            goto cleanup_stroker;\n        }\n\n        if( self->rendermode == RENDER_OUTLINE_EDGE )\n            error = FT_Glyph_Stroke( &ft_glyph, stroker, 1 );\n        else if ( self->rendermode == RENDER_OUTLINE_POSITIVE )\n            error = FT_Glyph_StrokeBorder( &ft_glyph, stroker, 0, 1 );\n        else if ( self->rendermode == RENDER_OUTLINE_NEGATIVE )\n            error = FT_Glyph_StrokeBorder( &ft_glyph, stroker, 1, 1 );\n\n        if( error )\n        {\n            freetype_error( error );\n            goto cleanup_stroker;\n        }\n\n        switch( self->atlas->depth ) {\n        case 1:\n            error = FT_Glyph_To_Bitmap( &ft_glyph, FT_RENDER_MODE_NORMAL, 0, 1);\n            break;\n        case 3:\n            error = FT_Glyph_To_Bitmap( &ft_glyph, FT_RENDER_MODE_LCD, 0, 1);\n            break;\n        case 4:\n            error = FT_Glyph_To_Bitmap( &ft_glyph, FT_RENDER_MODE_NORMAL, 0, 1);\n            break;\n        }\n\n        if( error )\n        {\n            freetype_error( error );\n            goto cleanup_stroker;\n        }\n\n        ft_bitmap_glyph = (FT_BitmapGlyph) ft_glyph;\n        ft_bitmap       = ft_bitmap_glyph->bitmap;\n        ft_glyph_top    = ft_bitmap_glyph->top;\n        ft_glyph_left   = ft_bitmap_glyph->left;\n\ncleanup_stroker:\n        FT_Stroker_Done( stroker );\n\n        if( error )\n        {\n            texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n            return 0;\n        }\n    }\n\n    struct {\n        int left;\n        int top;\n        int right;\n        int bottom;\n    } padding = { 0, 0, 1, 1 };\n\n    if( self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )\n    {\n        padding.top = 1;\n        padding.left = 1;\n    }\n\n    if( self->padding != 0 )\n    {\n        padding.top += self->padding;\n        padding.left += self->padding;\n        padding.right += self->padding;\n        padding.bottom += self->padding;\n    }\n\n    size_t src_w = self->atlas->depth == 3 ? ft_bitmap.width/3 : ft_bitmap.width;\n    size_t src_h = ft_bitmap.rows;\n\n    size_t tgt_w = src_w + padding.left + padding.right;\n    size_t tgt_h = src_h + padding.top + padding.bottom;\n\n    region = texture_atlas_get_region( self->atlas, tgt_w, tgt_h );\n\n    if ( region.x < 0 )\n    {\n        freetype_gl_warning( Texture_Atlas_Full );\n        texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n        return 0;\n    }\n\n    x = region.x;\n    y = region.y;\n\n    // Copy pixel data over\n    unsigned char *buffer = calloc( tgt_w * tgt_h * self->atlas->depth, sizeof(unsigned char) );\n\n    unsigned char *dst_ptr = buffer + (padding.top * tgt_w + padding.left) * self->atlas->depth;\n    unsigned char *src_ptr = ft_bitmap.buffer;\n    if( ft_bitmap.pixel_mode == FT_PIXEL_MODE_BGRA && self->atlas->depth == 4 )\n    {\n        // BGRA in, RGBA out\n        for( i = 0; i < src_h; i++ ) {\n            int j;\n            for( j = 0; j < ft_bitmap.width; j++ ) {\n                uint32_t bgra, rgba;\n                bgra = ((uint32_t*)src_ptr)[j];\n#if __BYTE_ORDER == __BIG_ENDIAN\n                rgba = rol(__builtin_bswap32(bgra), 8);\n#else\n                rgba = rol(__builtin_bswap32(bgra), 24);\n#endif\n                ((uint32_t*)dst_ptr)[j] = rgba;\n            }\n            dst_ptr += tgt_w * self->atlas->depth;\n            src_ptr += ft_bitmap.pitch;\n        }\n    }\n    else if( ft_bitmap.pixel_mode == FT_PIXEL_MODE_BGRA && self->atlas->depth == 1 )\n    {\n        // BGRA in, grey out: Use weighted sum for luminosity, and multiply by alpha\n        struct src_pixel_t { uint8_t b; uint8_t g; uint8_t r; uint8_t a; } * src = (struct src_pixel_t *)ft_bitmap.buffer;\n        for( int row = 0; row < src_h; row++, dst_ptr += tgt_w * self->atlas->depth ) {\n            for( int col = 0; col < src_w; col++, src++ ) {\n                dst_ptr[col] = (0.3*src->r + 0.59*src->g + 0.11*src->b) * (src->a/255.0);\n            }\n        }\n    }\n    else if( ft_bitmap.pixel_mode == FT_PIXEL_MODE_GRAY && self->atlas->depth == 4 ) {\n        // Grey in, RGBA out: Use grey level for alpha channel, with white color\n        struct dst_pixel_t { uint8_t r; uint8_t g; uint8_t b; uint8_t a; } * dst = (struct dst_pixel_t *)dst_ptr;\n        for( int row = 0; row < src_h; row++, dst += tgt_w ) {\n            for( int col = 0; col < src_w; col++, src_ptr++ ) {\n                dst[col] = (struct dst_pixel_t){ 255, 255, 255, *src_ptr };\n            }\n        }\n    }\n    else\n    {\n        // Straight copy, per row\n        for( i = 0; i < src_h; i++ ) {\n            //difference between width and pitch: https://www.freetype.org/freetype2/docs/reference/ft2-basic_types.html#FT_Bitmap\n            memcpy( dst_ptr, src_ptr, ft_bitmap.width);\n            dst_ptr += tgt_w * self->atlas->depth;\n            src_ptr += ft_bitmap.pitch;\n        }\n    }\n\n    if( self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )\n    {\n        unsigned char *sdf = make_distance_mapb( buffer, tgt_w, tgt_h );\n        free( buffer );\n        buffer = sdf;\n    }\n\n    texture_atlas_set_region( self->atlas, x, y, tgt_w, tgt_h, buffer, tgt_w * self->atlas->depth);\n\n    free( buffer );\n\n    glyph = texture_glyph_new( );\n    glyph->codepoint = glyph_index ? ucodepoint : 0;\n;\n    glyph->width    = tgt_w;\n    glyph->height   = tgt_h;\n    glyph->rendermode = self->rendermode;\n    glyph->outline_thickness = self->outline_thickness;\n    glyph->offset_x = ft_glyph_left;\n    glyph->offset_y = ft_glyph_top;\n    if(self->scaletex) {\n        glyph->s0       = x/(float)self->atlas->width;\n        glyph->t0       = y/(float)self->atlas->height;\n        glyph->s1       = (x + glyph->width)/(float)self->atlas->width;\n        glyph->t1       = (y + glyph->height)/(float)self->atlas->height;\n    } else {\n        // fix up unscaled coordinates by subtracting 0.5\n        // this avoids drawing pixels from neighboring characters\n        // note that you also have to paint these glyphs with an offset of\n        // half a pixel each to get crisp rendering\n        glyph->s0       = x - 0.5;\n        glyph->t0       = y - 0.5;\n        glyph->s1       = x + tgt_w - 0.5;\n        glyph->t1       = y + tgt_h - 0.5;\n    }\n    slot = self->face->glyph;\n    if( FT_HAS_FIXED_SIZES( self->face ) ) {\n        // color fonts use actual pixels, not subpixels\n        glyph->advance_x = slot->advance.x;\n        glyph->advance_y = slot->advance.y;\n    } else {\n\tglyph->advance_x = convert_F26Dot6_to_float(slot->advance.x) * self->scale;\n        glyph->advance_y = convert_F26Dot6_to_float(slot->advance.y) * self->scale;\n    }\n\n    int free_glyph = texture_font_index_glyph(self, glyph, ucodepoint);\n    if(!glyph_index) {\n        if(!free_glyph) {\n            glyph = texture_glyph_clone(glyph);\n        }\n        free_glyph = texture_font_index_glyph(self, glyph, 0);\n    }\n    if(free_glyph) {\n        // fprintf(stderr, \"Free glyph\\n\");\n        free(glyph);\n    }\n    \n    if( self->rendermode != RENDER_NORMAL && self->rendermode != RENDER_SIGNED_DISTANCE_FIELD )\n        FT_Done_Glyph( ft_glyph );\n\n    texture_font_generate_kerning( self, &self->library->library, &self->face );\n\n    texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n\n    return 1;\n}\n\n// ----------------------------------------------- texture_font_load_glyphs ---\nsize_t\ntexture_font_load_glyphs( texture_font_t * self,\n                          const char * codepoints )\n{\n    size_t i;\n\n    self->mode++;\n\n    /* Load each glyph */\n    for( i = 0; i < strlen(codepoints); i += utf8_surrogate_len(codepoints + i) ) {\n        if( !texture_font_load_glyph( self, codepoints + i ) ) {\n            self->mode--;\n            texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n\n            return utf8_strlen( codepoints + i );\n        }\n    }\n\n    self->mode--;\n    texture_font_close( self, MODE_AUTO_CLOSE, MODE_AUTO_CLOSE );\n\n    return 0;\n}\n\n\n// ------------------------------------------------- texture_font_get_glyph ---\ntexture_glyph_t *\ntexture_font_get_glyph( texture_font_t * self,\n                        const char * codepoint )\n{\n    texture_glyph_t *glyph;\n\n    assert( self );\n    assert( self->filename );\n    assert( self->atlas );\n\n    /* Check if codepoint has been already loaded */\n    if( !(glyph = texture_font_find_glyph( self, codepoint )) )\n    /* Glyph has not been already loaded */\n        if( texture_font_load_glyph( self, codepoint ) )\n            glyph = texture_font_find_glyph( self, codepoint );\n\n    return glyph;\n}\n\n// ----------------------------------------------- texture_font_get_glyph_gi ---\ntexture_glyph_t *\ntexture_font_get_glyph_gi( texture_font_t * self,\n                           uint32_t glyph_index )\n{\n    texture_glyph_t *glyph;\n\n    assert( self );\n    assert( self->filename );\n    assert( self->atlas );\n\n    /* Check if glyph_index has been already loaded */\n    if( (glyph = texture_font_find_glyph_gi( self, glyph_index )) )\n        return glyph;\n\n    /* Glyph has not been already loaded */\n    if( texture_font_load_glyph_gi( self, glyph_index, glyph_index ) )\n        return texture_font_find_glyph_gi( self, glyph_index );\n\n    return NULL;\n}\n\n// ------------------------------------------  texture_font_enlarge_texture ---\nvoid\ntexture_font_enlarge_texture( texture_font_t * self, size_t width_new,\n                              size_t height_new)\n{\n    assert(self);\n\n    texture_atlas_enlarge_texture ( self->atlas, width_new, height_new);\n}\n// -------------------------------------------- texture_font_enlarge_glyphs ---\nvoid\ntexture_font_enlarge_glyphs( texture_font_t * self, float mulw, float mulh)\n{\n    size_t i;\n    texture_glyph_t* g;\n    GLYPHS_ITERATOR(i, g, self->glyphs) {\n        g->s0 *= mulw;\n        g->s1 *= mulw;\n        g->t0 *= mulh;\n        g->t1 *= mulh;\n    } GLYPHS_ITERATOR_END\n}\n\n// -------------------------------------------  texture_font_enlarge_atlas ---\nvoid\ntexture_font_enlarge_atlas( texture_font_t * self, size_t width_new,\n                            size_t height_new )\n{\n    assert(self);\n    assert(self->atlas);\n    //ensure size increased\n    assert(width_new >= self->atlas->width);\n    assert(height_new >= self->atlas->height);\n    assert(width_new + height_new > self->atlas->width + self->atlas->height);    \n    assert(width_new + height_new > self->atlas->width + self->atlas->height);\n    texture_atlas_t* ta = self->atlas;\n    size_t width_old = ta->width;\n    size_t height_old = ta->height;    \n\n    texture_font_enlarge_texture( self, width_new, height_new);\n    if( self->scaletex ) {\n        float mulw = (float)width_old / width_new;\n        float mulh = (float)height_old / height_new;\n        texture_font_enlarge_glyphs( self, mulw, mulh );\n    }\n}\n"
        },
        {
          "name": "texture-font.h",
          "type": "blob",
          "size": 19.25,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __TEXTURE_FONT_H__\n#define __TEXTURE_FONT_H__\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"vector.h\"\n#include \"texture-atlas.h\"\n\n#ifndef __THREAD\n#if defined(__GNUC__) || defined(__clang__)\n#define __THREAD __thread\n#elif defined(_MSC_VER)\n#define __THREAD __declspec( thread )\n#else\n#define __THREAD\n#endif\n#endif\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   texture-font.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup texture-font Texture font\n *\n * Texture font.\n *\n * Example Usage:\n * @code\n * #include \"texture-font.h\"\n *\n * int main( int arrgc, char *argv[] )\n * {\n *   return 0;\n * }\n * @endcode\n *\n * @{\n */\n\n\n/**\n * A list of possible ways to render a glyph.\n */\ntypedef enum rendermode_t\n{\n    RENDER_NORMAL,\n    RENDER_OUTLINE_EDGE,\n    RENDER_OUTLINE_POSITIVE,\n    RENDER_OUTLINE_NEGATIVE,\n    RENDER_SIGNED_DISTANCE_FIELD\n} rendermode_t;\n\n/**\n * Glyph array end mark type\n */\ntypedef enum glyphmode_t\n{\n    GLYPH_END=0,\n    GLYPH_CONT=1\n} glyphmode_t;\n\n/*\n * Glyph metrics:\n * --------------\n *\n *                       xmin                     xmax\n *                        |                         |\n *                        |<-------- width -------->|\n *                        |                         |\n *              |         +-------------------------+----------------- ymax\n *              |         |    ggggggggg   ggggg    |     ^        ^\n *              |         |   g:::::::::ggg::::g    |     |        |\n *              |         |  g:::::::::::::::::g    |     |        |\n *              |         | g::::::ggggg::::::gg    |     |        |\n *              |         | g:::::g     g:::::g     |     |        |\n *    offset_x -|-------->| g:::::g     g:::::g     |  offset_y    |\n *              |         | g:::::g     g:::::g     |     |        |\n *              |         | g::::::g    g:::::g     |     |        |\n *              |         | g:::::::ggggg:::::g     |     |        |\n *              |         |  g::::::::::::::::g     |     |      height\n *              |         |   gg::::::::::::::g     |     |        |\n *  baseline ---*---------|---- gggggggg::::::g-----*--------      |\n *            / |         |             g:::::g     |              |\n *     origin   |         | gggggg      g:::::g     |              |\n *              |         | g:::::gg   gg:::::g     |              |\n *              |         |  g::::::ggg:::::::g     |              |\n *              |         |   gg:::::::::::::g      |              |\n *              |         |     ggg::::::ggg        |              |\n *              |         |         gggggg          |              v\n *              |         +-------------------------+----------------- ymin\n *              |                                   |\n *              |------------- advance_x ---------->|\n */\n\n/**\n * A structure that describe a glyph.\n */\ntypedef struct texture_glyph_t\n{\n    /**\n     * Unicode codepoint this glyph represents in UTF-32 LE encoding.\n     */\n    uint32_t codepoint;\n\n    /**\n     * Glyph's width in pixels.\n     */\n    size_t width;\n\n    /**\n     * Glyph's height in pixels.\n     */\n    size_t height;\n\n    /**\n     * Glyph's left bearing expressed in integer pixels.\n     */\n    int offset_x;\n\n    /**\n     * Glyphs's top bearing expressed in integer pixels.\n     *\n     * Remember that this is the distance from the baseline to the top-most\n     * glyph scanline, upwards y coordinates being positive.\n     */\n    int offset_y;\n\n    /**\n     * For horizontal text layouts, this is the horizontal distance (in\n     * fractional pixels) used to increment the pen position when the glyph is\n     * drawn as part of a string of text.\n     */\n    float advance_x;\n\n    /**\n     * For vertical text layouts, this is the vertical distance (in fractional\n     * pixels) used to increment the pen position when the glyph is drawn as\n     * part of a string of text.\n     */\n    float advance_y;\n\n    /**\n     * First normalized texture coordinate (x) of top-left corner\n     */\n    float s0;\n\n    /**\n     * Second normalized texture coordinate (y) of top-left corner\n     */\n    float t0;\n\n    /**\n     * First normalized texture coordinate (x) of bottom-right corner\n     */\n    float s1;\n\n    /**\n     * Second normalized texture coordinate (y) of bottom-right corner\n     */\n    float t1;\n\n    /**\n     * A vector of kerning pairs relative to this glyph.\n     */\n    vector_t * kerning;\n\n    /**\n     * Mode this glyph was rendered\n     */\n    rendermode_t rendermode;\n\n    /**\n     * Glyph outline thickness\n     */\n    float outline_thickness;\n\n    /**\n     * Glyph scan end mark\n     */\n    glyphmode_t glyphmode;\n\n} texture_glyph_t;\n\n/**\n * Enum type for texture location\n */\ntypedef enum font_location_t {\n    TEXTURE_FONT_FILE = 0,\n    TEXTURE_FONT_MEMORY\n} font_location_t;\n\n/**\n * Enum type for automatic open/close\n */\ntypedef enum font_mode_t {\n    MODE_AUTO_CLOSE = 0,\n    MODE_GLYPHS_CLOSE,\n    MODE_FREE_CLOSE,\n    MODE_MANUAL_CLOSE,\n    MODE_ALWAYS_OPEN\n} font_mode_t;\n/**\n * default mode for fonts\n */\nextern __THREAD font_mode_t mode_default;\n\n/** set defualt mode for fonts\n *\n * @param  mode  The mode for automatic open/close new fonts get\n */\n\nvoid\ntexture_font_default_mode(font_mode_t mode);\n\n/* If there is no Freetype included, just define that as incomplete pointer */\n#if !defined(FT2BUILD_H_) && !defined(__FT2BUILD_H__) && !defined(FREETYPE_H_)\ntypedef struct FT_FaceRec_* FT_Face;\ntypedef struct FT_LibraryRec_* FT_Library;\ntypedef struct FT_SizeRec_* FT_Size;\ntypedef signed long FT_Fixed;\n#endif\n\n/* same for harfbuzz */\n#ifndef HB_BUFFER_H\ntypedef struct hb_font_t hb_font_t;\n#endif\n\n/**\n *  Texture font library structure.\n */\ntypedef struct texture_font_library_t\n{\n    /**\n     * Flag for mode\n     */\n    font_mode_t mode;\n\n    /**\n     * Freetype library pointer\n     */\n    FT_Library library;\n} texture_font_library_t;\n\n/**\n *  Texture font structure.\n */\ntypedef struct texture_font_t\n{\n    /**\n     * Vector of glyphs contained in this font.\n     * This is actually a two-stage table, indexing into 256 glyphs each\n     */\n    vector_t * glyphs;\n\n    /**\n     * Atlas structure to store glyphs data.\n     */\n    texture_atlas_t * atlas;\n    \n    /**\n     * font location\n     */\n    font_location_t location;\n\n    union {\n        /**\n         * Font filename, for when location == TEXTURE_FONT_FILE\n         */\n        char *filename;\n\n        /**\n         * Font memory address, for when location == TEXTURE_FONT_MEMORY\n         */\n        struct {\n            const void *base;\n            size_t size;\n        } memory;\n    };\n\n    /**\n     * Texture font library\n     */\n\n    texture_font_library_t * library;\n  \n    /**\n     * Font size\n     */\n    float size;\n\n    /**\n     * Mode the font is rendering its next glyph\n     */\n    rendermode_t rendermode;\n\n    /**\n     * Outline thickness\n     */\n    float outline_thickness;\n\n    /**\n     * Whether to use our own lcd filter.\n     */\n    unsigned char filtering;\n    /**\n     * Whether to use kerning if available\n     */\n    unsigned char kerning;\n\n    /**\n     * Whether to use autohint when rendering font\n     */\n    unsigned char hinting;\n\n    /**\n     * Whether to scale texture coordinates\n     */\n    unsigned char scaletex;\n\n    /**\n     * LCD filter weights\n     */\n    unsigned char lcd_weights[5];\n\n    /**\n     * This field is simply used to compute a default line spacing (i.e., the\n     * baseline-to-baseline distance) when writing text with this font. Note\n     * that it usually is larger than the sum of the ascender and descender\n     * taken as absolute values. There is also no guarantee that no glyphs\n     * extend above or below subsequent baselines when using this distance.\n     */\n    float height;\n\n    /**\n     * This field is the distance that must be placed between two lines of\n     * text. The baseline-to-baseline distance should be computed as:\n     * ascender - descender + linegap\n     */\n    float linegap;\n\n    /**\n     * The ascender is the vertical distance from the horizontal baseline to\n     * the highest 'character' coordinate in a font face. Unfortunately, font\n     * formats define the ascender differently. For some, it represents the\n     * ascent of all capital latin characters (without accents), for others it\n     * is the ascent of the highest accented character, and finally, other\n     * formats define it as being equal to bbox.yMax.\n     */\n    float ascender;\n\n    /**\n     * The descender is the vertical distance from the horizontal baseline to\n     * the lowest 'character' coordinate in a font face. Unfortunately, font\n     * formats define the descender differently. For some, it represents the\n     * descent of all capital latin characters (without accents), for others it\n     * is the ascent of the lowest accented character, and finally, other\n     * formats define it as being equal to bbox.yMin. This field is negative\n     * for values below the baseline.\n     */\n    float descender;\n\n    /**\n     * The position of the underline line for this face. It is the center of\n     * the underlining stem. Only relevant for scalable formats.\n     */\n    float underline_position;\n\n    /**\n     * The thickness of the underline for this face. Only relevant for scalable\n     * formats.\n     */\n    float underline_thickness;\n\n    /**\n    * The padding to be add to the glyph's texture that are loaded by this font.\n    * Usefull when adding effects with shaders.\n    */\n    int padding;\n\n    /**\n     * Flag for mode\n     */\n    font_mode_t mode;\n\n    /**\n     * Freetype face pointer\n     */\n    FT_Face face;\n\n    /**\n     * Freetype size pointer\n     */\n    FT_Size ft_size;\n\n    /**\n     * Harfbuzz font pointer\n     */\n    hb_font_t* hb_font;\n\n    /**\n     * factor to scale font coordinates\n     */\n    float scale;\n} texture_font_t;\n\n/**\n * This function creates a new font library\n *\n * @return a new library (no font loaded yet)\n */\n  texture_font_library_t *\n      texture_library_new(void);\n\n/**\n * This variable holds the per-thread library\n */\n\n  extern __THREAD texture_font_library_t * freetype_gl_library;\n  \n/**\n * This function creates a new texture font from given filename and size.  The\n * texture atlas is used to store glyph on demand. Note the depth of the atlas\n * will determine if the font is rendered as alpha channel only (depth = 1) or\n * RGB (depth = 3) that correspond to subpixel rendering (if available on your\n * freetype implementation), or RGBA (depth = 4) for color fonts.\n *\n * @param atlas     A texture atlas\n * @param pt_size   Size of font to be created (in points)\n * @param filename  A font filename\n *\n * @return A new empty font (no glyph inside yet)\n *\n */\n  texture_font_t *\n  texture_font_new_from_file( texture_atlas_t * atlas,\n                              const float pt_size,\n                              const char * filename );\n\n\n/**\n * This function creates a new texture font from a memory location and size.\n * The texture atlas is used to store glyph on demand. Note the depth of the\n * atlas will determine if the font is rendered as alpha channel only\n * (depth = 1) or RGB (depth = 3) that correspond to subpixel rendering (if\n * available on your freetype implementation).\n *\n * @param atlas       A texture atlas\n * @param pt_size     Size of font to be created (in points)\n * @param memory_base Start of the font file in memory\n * @param memory_size Size of the font file memory region, in bytes\n *\n * @return A new empty font (no glyph inside yet)\n *\n */\n  texture_font_t *\n  texture_font_new_from_memory( texture_atlas_t *atlas,\n                                float pt_size,\n                                const void *memory_base,\n                                size_t memory_size );\n\n/**\n * Clone the freetype-gl font and set a different size\n *\n * @param self         a valid texture font\n * @param size         the new size of the font\n */\n  texture_font_t *\n  texture_font_clone( texture_font_t *self,\n\t\t      float size);\n\n/**\n * Close the freetype structures from a font and the associated library\n *\n * @param self         a valid texture font\n * @param face_mode    if the mode of the face is less or equal, be done with it\n * @param library_mode if the mode of the library is less or equal, be done with it\n */\n  void\n  texture_font_close( texture_font_t *self, font_mode_t face_mode, font_mode_t library_mode );\n\n/**\n * Delete a texture font. Note that this does not delete the glyph from the\n * texture atlas.\n *\n * @param self a valid texture font\n */\n  void\n  texture_font_delete( texture_font_t * self );\n\n\n/**\n * Load a texture font.\n *\n * @param self  a valid texture font\n * @param size  the size of the font\n *\n * @return 1 on success, 0 on error\n */\n  int\n  texture_font_load_face( texture_font_t * self, float size );\n\n/**\n * Texture font contains multiple masters and is capable of interpolating between them.\n *\n * @param self  a valid texture font\n *\n * @return 1 if true, 0 if false\n *\n * @see texture_font_get_weight, texture_font_set_weight\n */\n  int\n  texture_font_is_variable( texture_font_t * self );\n\n\n/**\n * Get font weights (variable fonts only)\n *\n * @param self  a valid texture font\n * @param def   default weight\n * @param min   minimum weight\n * @param max   maximum weight\n *\n * @return 1 on success, 0 on error\n */\n  int\n  texture_font_get_weight( texture_font_t * self, FT_Fixed * def,\n                           FT_Fixed * min, FT_Fixed * max );\n\n\n/**\n * Set font weight (variable fonts only)\n *\n * @param self  a valid texture font\n * @param wght  new font weight\n *\n * @return 1 on success, 0 on error\n */\n  int\n  texture_font_set_weight( texture_font_t * self, FT_Fixed wght );\n\n\n/**\n * Request a new glyph from the font. If it has not been created yet, it will\n * be.\n *\n * @param self      A valid texture font\n * @param codepoint Character codepoint to be loaded in UTF-8 encoding.\n *\n * @return A pointer on the new glyph or 0 if the texture atlas is not big\n *         enough\n *\n */\n  texture_glyph_t *\n  texture_font_get_glyph( texture_font_t * self,\n                          const char * codepoint );\n\n/**\n * Request an already loaded glyph from the font.\n *\n * @param self      A valid texture font\n * @param codepoint Character codepoint to be found in UTF-8 encoding.\n *\n * @return A pointer on the glyph or 0 if the glyph is not loaded\n */\n texture_glyph_t *\n texture_font_find_glyph( texture_font_t * self,\n                          const char * codepoint );\n    \n/** \n * Index a glyph in a font\n * \n * @param self      A valid texture font\n * @param glyph     The glyph to index in the font\n * @param codepoint The codepoint to insert into\n *\n * @return          1 if glyph was copied, 0 if it was inserted\n */\nint\ntexture_font_index_glyph( texture_font_t * self,\n\t\t\t  texture_glyph_t * glyph,\n\t\t\t  uint32_t codepoint );\n    \n/**\n * Request the loading of a given glyph.\n *\n * @param self       A valid texture font\n * @param codepoint  Character codepoint to be loaded in UTF-8 encoding.\n *\n * @return One if the glyph could be loaded, zero if not.\n */\nint\ntexture_font_load_glyph( texture_font_t * self,\n\t\t\t const char * codepoint );\n\n/**\n * Request a new glyph from the font. If it has not been created yet, it will\n * be.\n *\n * @param self        A valid texture font\n * @param glyph_index Font's character glyph index to be obtained\n *\n * @return A pointer on the new glyph or 0 if the texture atlas is not big\n *         enough\n *\n */\ntexture_glyph_t *\ntexture_font_get_glyph_gi( texture_font_t * self,\n\t\t\t   uint32_t glyph_index );\n\n/**\n * Request an already loaded glyph from the font. \n *\n * @param self         A valid texture font\n * @param glyph_index  Font's character codepoint to be found\n *\n * @return A pointer on the glyph or 0 if the glyph is not loaded\n */\ntexture_glyph_t *\ntexture_font_find_glyph_gi( texture_font_t * self,\n\t\t\t    uint32_t glyph_index );\n\n/**\n * Request the loading of a given glyph.\n *\n * @param self         A valid texture font\n * @param glyph_index  Character codepoint to be loaded in font's codepoint\n * @param ucodepoint   Character codepoint for inserting into lookup table\n *\n * @return One if the glyph could be loaded, zero if not.\n */\nint\ntexture_font_load_glyph_gi( texture_font_t * self,\n\t\t\t    uint32_t glyph_index,\n\t\t\t    uint32_t ucodepoint);\n\n/**\n * Request the loading of several glyphs at once.\n *\n * @param self       A valid texture font\n * @param codepoints Character codepoints to be loaded in UTF-8 encoding. May\n *                   contain duplicates.\n *\n * @return Number of missed glyph if the texture is not big enough to hold\n *         every glyphs.\n */\n  size_t\n  texture_font_load_glyphs( texture_font_t * self,\n                            const char * codepoints );\n/**\n * Increases the size of a fonts texture atlas\n * Invalidates all pointers to font->atlas->data\n * Changes the UV Coordinates of existing glyphs in the font\n *\n * @param self A valid texture font\n * @param width_new Width of the texture atlas after resizing (must be bigger\n *                  or equal to current width)\n * @param height_new Height of the texture atlas after resizing (must be bigger or\n *                   equal to current height)\n */\n  void\n  texture_font_enlarge_atlas( texture_font_t * self, size_t width_new,\n\t\t\t      size_t height_new );\n\n/**\n * Changes the UV Coordinates of existing glyphs in the font\n *\n * @param self A valid texture font\n * @param mulw scale factor for width\n * @param mulh scale factor for height\n */\n  void\n  texture_font_enlarge_glyphs( texture_font_t * self, float mulw, float mulh );\n  \n/**\n * Increases the size of a fonts texture atlas\n *\n * @param self A valid texture font\n * @param width_new Width of the texture atlas after resizing (must be bigger\n *                  or equal to current width)\n * @param height_new Height of the texture atlas after resizing (must be bigger or\n *                   equal to current height)\n */\n  void\n  texture_font_enlarge_texture( texture_font_t * self, size_t width_new,\n\t\t\t\tsize_t height_new );\n/**\n * Get the kerning between two horizontal glyphs.\n *\n * @param self      A valid texture glyph\n * @param codepoint Character codepoint of the peceding character in UTF-8 encoding.\n *\n * @return x kerning value\n */\nfloat\ntexture_glyph_get_kerning( const texture_glyph_t * self,\n                           const char * codepoint );\n\n\n/**\n * Creates a new empty glyph\n *\n * @return a new empty glyph (not valid)\n */\ntexture_glyph_t *\ntexture_glyph_new( void );\n\n/**\n * Delete a glyph\n *\n * @param  self         A valid texture glyph\n */\nvoid\ntexture_glyph_delete( texture_glyph_t * self );\n\n/**\n * Clone a glyph\n *\n * @param self         A valid texture glyph\n */\ntexture_glyph_t*\ntexture_glyph_clone( texture_glyph_t* self );\n\n/** @} */\n\n#define GLYPHS_ITERATOR1(index, name, glyph) \\\n    for( index = 0; index < vector_size ( glyph ); index++ ) { \\\n\ttexture_glyph_t ** __glyphs;\n#define GLYPHS_ITERATOR2(index, name, glyph) \\\n\tif(( __glyphs = *(texture_glyph_t *** ) vector_get ( glyph, index ) )) { \\\n\t    int __i;\t\t\t\t\t\t\t\\\n\t    for( __i = 0; __i < 0x100; __i++ ) {\t\t\t\\\n\t\tif(( name = __glyphs[__i] ))\n#define GLYPHS_ITERATOR(index, name, glyph) \\\n    GLYPHS_ITERATOR1(index, name, glyph)\t\t\\\n\tGLYPHS_ITERATOR2(index, name, glyph)\n\n#define GLYPHS_ITERATOR_END1 }\n#define GLYPHS_ITERATOR_END2 } }\n#define GLYPHS_ITERATOR_END } } }\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __TEXTURE_FONT_H__ */\n"
        },
        {
          "name": "utf8-utils.c",
          "type": "blob",
          "size": 1.880859375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <string.h>\n#include \"utf8-utils.h\"\n\n// ----------------------------------------------------- utf8_surrogate_len ---\nsize_t\nutf8_surrogate_len( const char* character )\n{\n    size_t result = 0;\n    char test_char;\n\n    if (!character)\n        return 0;\n\n    test_char = character[0];\n\n    if ((test_char & 0x80) == 0)\n        return 1;\n\n    while (test_char & 0x80)\n    {\n        test_char <<= 1;\n        result++;\n    }\n\n    return result;\n}\n\n// ------------------------------------------------------------ utf8_strlen ---\nsize_t\nutf8_strlen( const char* string )\n{\n    const char* ptr = string;\n    size_t result = 0;\n\n    while (*ptr)\n    {\n        ptr += utf8_surrogate_len(ptr);\n        result++;\n    }\n\n    return result;\n}\n\nuint32_t\nutf8_to_utf32( const char * character )\n{\n    if( !character )\n    {\n        return -1;\n    }\n\n    if( ( character[0] & 0x80 ) == 0x0 )\n    {\n        return character[0];\n    }\n\n    if( ( character[0] & 0xE0 ) == 0xC0 )\n    {\n        return ( ( character[0] & 0x3F ) << 6 ) | ( character[1] & 0x3F );\n    }\n\n    if( ( character[0] & 0xF0 ) == 0xE0 )\n    {\n        return ( ( character[0] & 0x1F ) << ( 6 + 6 ) ) | ( ( character[1] & 0x3F ) << 6 ) | ( character[2] & 0x3F );\n    }\n\n    if( ( character[0] & 0xF8 ) == 0xF0 )\n    {\n        return ( ( character[0] & 0x0F ) << ( 6 + 6 + 6 ) ) | ( ( character[1] & 0x3F ) << ( 6 + 6 ) ) | ( ( character[2] & 0x3F ) << 6 ) | ( character[3] & 0x3F );\n    }\n\n    if( ( character[0] & 0xFC ) == 0xF8 )\n    {\n        return ( ( character[0] & 0x07 ) << ( 6 + 6 + 6 + 6 ) ) | ( ( character[1] & 0x3F ) << ( 6 + 6 + 6 ) ) | ( ( character[2] & 0x3F ) << ( 6 + 6 ) ) | ( ( character[3] & 0x3F ) << 6 ) | ( character[4] & 0x3F );\n    }\n\n    return 0xFFFD; // invalid character\n}\n"
        },
        {
          "name": "utf8-utils.h",
          "type": "blob",
          "size": 1.2998046875,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __UTF8_UTILS_H__\n#define __UTF8_UTILS_H__\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n\nnamespace ftgl {\n#endif\n\n/**\n * @file    utf8-utils.h\n * @author  Marcel Metz <mmetz@adrian-broher.net>\n *\n * defgroup utf8-utils UTF-8 Utilities\n *\n * @{\n */\n\n  /**\n   * Returns the size in bytes of a given UTF-8 encoded character surrogate\n   *\n   * @param character  An UTF-8 encoded character\n   *\n   * @return  The length of the surrogate in bytes.\n   */\n  size_t\n  utf8_surrogate_len( const char* character );\n\n  /**\n   * Return the length of the given UTF-8 encoded and\n   * NULL terminated string.\n   *\n   * @param string  An UTF-8 encoded string\n   *\n   * @return  The length of the string in characters.\n   */\n  size_t\n  utf8_strlen( const char* string );\n\n  /**\n   * Converts a given UTF-8 encoded character to its UTF-32 LE equivalent\n   *\n   * @param character  An UTF-8 encoded character\n   *\n   * @return  The equivalent of the given character in UTF-32 LE\n   *          encoding.\n   */\n  uint32_t\n  utf8_to_utf32( const char * character );\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* #define __UTF8_UTILS_H__ */\n"
        },
        {
          "name": "vec234.h",
          "type": "blob",
          "size": 6.2919921875,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __VEC234_H__\n#define __VEC234_H__\n\n#ifdef __cplusplus\nextern \"C\" {\nnamespace ftgl {\n#endif\n\n\n/**\n * Tuple of 4 ints.\n *\n * Each field can be addressed using several aliases:\n *  - First component:  <b>x</b>, <b>r</b>, <b>red</b> or <b>vstart</b>\n *  - Second component: <b>y</b>, <b>g</b>, <b>green</b> or <b>vcount</b>\n *  - Third component:  <b>z</b>, <b>b</b>, <b>blue</b>, <b>width</b> or <b>istart</b>\n *  - Fourth component: <b>w</b>, <b>a</b>, <b>alpha</b>, <b>height</b> or <b>icount</b>\n *\n */\ntypedef union\n{\n     int data[4];    /**< All compoments at once     */\n     struct {\n        int x;      /**< Alias for first component  */\n        int y;      /**< Alias for second component */\n        int z;      /**< Alias for third component  */\n        int w;      /**< Alias for fourht component */\n    };\n    struct {\n        int x_;     /**< Alias for first component  */\n        int y_;     /**< Alias for second component */\n        int width;  /**< Alias for third component  */\n        int height; /**< Alias for fourth component */\n    };\n    struct {\n        int r;      /**< Alias for first component  */\n        int g;      /**< Alias for second component */\n        int b;      /**< Alias for third component  */\n        int a;      /**< Alias for fourth component */\n    };\n    struct {\n        int red;    /**< Alias for first component  */\n        int green;  /**< Alias for second component */\n        int blue;   /**< Alias for third component  */\n        int alpha;  /**< Alias for fourth component */\n    };\n    struct {\n        int vstart; /**< Alias for first component  */\n        int vcount; /**< Alias for second component */\n        int istart; /**< Alias for third component  */\n        int icount; /**< Alias for fourth component */\n    };\n} ivec4;\n\n\n/**\n * Tuple of 3 ints.\n *\n * Each field can be addressed using several aliases:\n *  - First component:  <b>x</b>, <b>r</b> or <b>red</b>\n *  - Second component: <b>y</b>, <b>g</b> or <b>green</b>\n *  - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>\n *\n */\ntypedef union\n{\n    int data[3];    /**< All compoments at once     */\n    struct {\n        int x;      /**< Alias for first component  */\n        int y;      /**< Alias for second component */\n        int z;      /**< Alias for third component  */\n    };\n    struct {\n        int r;      /**< Alias for first component  */\n        int g;      /**< Alias for second component */\n        int b;      /**< Alias for third component  */\n    };\n    struct {\n        int red;    /**< Alias for first component  */\n        int green;  /**< Alias for second component */\n        int blue;   /**< Alias for third component  */\n    };\n} ivec3;\n\n\n/**\n * Tuple of 2 ints.\n *\n * Each field can be addressed using several aliases:\n *  - First component: <b>x</b>, <b>s</b> or <b>start</b>\n *  - Second component: <b>y</b>, <b>t</b> or <b>end</b>\n *\n */\ntypedef union\n{\n    int data[2];    /**< All compoments at once     */\n    struct {\n        int x;      /**< Alias for first component  */\n        int y;      /**< Alias for second component */\n    };\n    struct {\n        int s;      /**< Alias for first component  */\n        int t;      /**< Alias for second component */\n    };\n    struct {\n        int start;  /**< Alias for first component  */\n        int end;    /**< Alias for second component */\n    };\n} ivec2;\n\n\n/**\n * Tuple of 4 floats.\n *\n * Each field can be addressed using several aliases:\n *  - First component:  <b>x</b>, <b>left</b>, <b>r</b> or <b>red</b>\n *  - Second component: <b>y</b>, <b>top</b>, <b>g</b> or <b>green</b>\n *  - Third component:  <b>z</b>, <b>width</b>, <b>b</b> or <b>blue</b>\n *  - Fourth component: <b>w</b>, <b>height</b>, <b>a</b> or <b>alpha</b>\n */\ntypedef union\n{\n    float data[4];    /**< All compoments at once    */\n    struct {\n        float x;      /**< Alias for first component */\n        float y;      /**< Alias for second component */\n        float z;      /**< Alias for third component  */\n        float w;      /**< Alias for fourth component */\n    };\n    struct {\n        float left;   /**< Alias for first component */\n        float top;    /**< Alias for second component */\n        float width;  /**< Alias for third component  */\n        float height; /**< Alias for fourth component */\n    };\n    struct {\n        float r;      /**< Alias for first component */\n        float g;      /**< Alias for second component */\n        float b;      /**< Alias for third component  */\n        float a;      /**< Alias for fourth component */\n    };\n    struct {\n        float red;    /**< Alias for first component */\n        float green;  /**< Alias for second component */\n        float blue;   /**< Alias for third component  */\n        float alpha;  /**< Alias for fourth component */\n    };\n} vec4;\n\n\n/**\n * Tuple of 3 floats\n *\n * Each field can be addressed using several aliases:\n *  - First component:  <b>x</b>, <b>r</b> or <b>red</b>\n *  - Second component: <b>y</b>, <b>g</b> or <b>green</b>\n *  - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>\n */\ntypedef union\n{\n    float data[3];   /**< All compoments at once    */\n    struct {\n        float x;     /**< Alias for first component */\n        float y;     /**< Alias fo second component */\n        float z;     /**< Alias fo third component  */\n    };\n    struct {\n        float r;     /**< Alias for first component */\n        float g;     /**< Alias fo second component */\n        float b;     /**< Alias fo third component  */\n    };\n    struct {\n        float red;   /**< Alias for first component */\n        float green; /**< Alias fo second component */\n        float blue;  /**< Alias fo third component  */\n    };\n} vec3;\n\n\n/**\n * Tuple of 2 floats\n *\n * Each field can be addressed using several aliases:\n *  - First component:  <b>x</b> or <b>s</b>\n *  - Second component: <b>y</b> or <b>t</b>\n */\ntypedef union\n{\n    float data[2]; /**< All components at once     */\n    struct {\n        float x;   /**< Alias for first component  */\n        float y;   /**< Alias for second component */\n    };\n    struct {\n        float s;   /**< Alias for first component  */\n        float t;   /**< Alias for second component */\n    };\n} vec2;\n\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __VEC234_H__ */\n"
        },
        {
          "name": "vector.c",
          "type": "blob",
          "size": 7.5205078125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"vector.h\"\n#include \"ftgl-utils.h\"\n\n\n// ------------------------------------------------------------- vector_new ---\nvector_t *\nvector_new( size_t item_size )\n{\n    vector_t *self = (vector_t *) malloc( sizeof(vector_t) );\n    assert( item_size );\n\n    if( !self )\n    {\n\tfreetype_gl_error( Out_Of_Memory );\n\treturn NULL;\n    }\n    self->item_size = item_size;\n    self->size      = 0;\n    self->capacity  = 1;\n    self->items     = calloc( self->item_size, self->capacity );\n    return self;\n}\n\n\n\n// ---------------------------------------------------------- vector_delete ---\nvoid\nvector_delete( vector_t *self )\n{\n    assert( self );\n\n    free( self->items );\n    free( self );\n}\n\n\n\n// ------------------------------------------------------------- vector_get ---\nconst void *\nvector_get( const vector_t *self,\n            size_t index )\n{\n    assert( self );\n    assert( self->size );\n    assert( index  < self->size );\n\n    return (char*)(self->items) + index * self->item_size;\n}\n\n\n\n// ----------------------------------------------------------- vector_front ---\nconst void *\nvector_front( const vector_t *self )\n{\n    assert( self );\n    assert( self->size );\n\n    return vector_get( self, 0 );\n}\n\n\n// ------------------------------------------------------------ vector_back ---\nconst void *\nvector_back( const vector_t *self )\n{\n    assert( self );\n    assert( self->size );\n\n    return vector_get( self, self->size-1 );\n}\n\n\n// -------------------------------------------------------- vector_contains ---\nint\nvector_contains( const vector_t *self,\n                 const void *item,\n                 int (*cmp)(const void *, const void *) )\n{\n    size_t i;\n    assert( self );\n\n    for( i=0; i<self->size; ++i )\n    {\n        if( (*cmp)(item, vector_get(self,i) ) == 0 )\n        {\n            return 1;\n        }\n    }\n   return 0;\n}\n\n\n// ----------------------------------------------------------- vector_empty ---\nint\nvector_empty( const vector_t *self )\n{\n    assert( self );\n\n    return self->size == 0;\n}\n\n\n// ------------------------------------------------------------ vector_size ---\nsize_t\nvector_size( const vector_t *self )\n{\n    assert( self );\n\n    return self->size;\n}\n\n\n// --------------------------------------------------------- vector_reserve ---\nvoid\nvector_reserve( vector_t *self,\n                const size_t size )\n{\n    assert( self );\n\n    if( self->capacity < size)\n    {\n        self->items = realloc( self->items, size * self->item_size );\n\tmemset( (char *)(self->items) + self->capacity * self->item_size, 0,\n\t\t(size - self->capacity) * self->item_size );\n        self->capacity = size;\n    }\n}\n\n\n// -------------------------------------------------------- vector_capacity ---\nsize_t\nvector_capacity( const vector_t *self )\n{\n    assert( self );\n\n    return self->capacity;\n}\n\n\n// ---------------------------------------------------------- vector_shrink ---\nvoid\nvector_shrink( vector_t *self )\n{\n    assert( self );\n\n    if( self->capacity > self->size )\n    {\n        self->items = realloc( self->items, self->size * self->item_size );\n    }\n    self->capacity = self->size;\n}\n\n\n// ----------------------------------------------------------- vector_clear ---\nvoid\nvector_clear( vector_t *self )\n{\n    assert( self );\n\n    memset( (char *)(self->items), 0, self->size * self->item_size);\n    self->size = 0;\n}\n\n\n// ------------------------------------------------------------- vector_set ---\nvoid\nvector_set( vector_t *self,\n            const size_t index,\n            const void *item )\n{\n    assert( self );\n    assert( self->size );\n    assert( index  < self->size );\n\n    memcpy( (char *)(self->items) + index * self->item_size,\n            item, self->item_size );\n}\n\n\n// ---------------------------------------------------------- vector_insert ---\nvoid\nvector_insert( vector_t *self,\n               const size_t index,\n               const void *item )\n{\n    assert( self );\n    assert( index <= self->size);\n\n    if( self->capacity <= self->size )\n    {\n        vector_reserve(self, 2 * self->capacity );\n    }\n    if( index < self->size )\n    {\n        memmove( (char *)(self->items) + (index + 1) * self->item_size,\n                 (char *)(self->items) + (index + 0) * self->item_size,\n                 (self->size - index)  * self->item_size);\n    }\n    self->size++;\n    vector_set( self, index, item );\n}\n\n\n// ----------------------------------------------------- vector_erase_range ---\nvoid\nvector_erase_range( vector_t *self,\n                    const size_t first,\n                    const size_t last )\n{\n    assert( self );\n    assert( first < self->size );\n    assert( last  < self->size+1 );\n    assert( first < last );\n\n    memmove( (char *)(self->items) + first * self->item_size,\n             (char *)(self->items) + last  * self->item_size,\n             (self->size - last)   * self->item_size);\n    self->size -= (last-first);\n}\n\n\n// ----------------------------------------------------------- vector_erase ---\nvoid\nvector_erase( vector_t *self,\n              const size_t index )\n{\n    assert( self );\n    assert( index < self->size );\n\n    vector_erase_range( self, index, index+1 );\n}\n\n\n// ------------------------------------------------------- vector_push_back ---\nvoid\nvector_push_back( vector_t *self,\n                  const void *item )\n{\n    vector_insert( self, self->size, item );\n}\n\n\n// -------------------------------------------------------- vector_pop_back ---\nvoid\nvector_pop_back( vector_t *self )\n{\n    assert( self );\n    assert( self->size );\n\n    self->size--;\n}\n\n\n// ---------------------------------------------------------- vector_resize ---\nvoid\nvector_resize( vector_t *self,\n               const size_t size )\n{\n    assert( self );\n\n    if( size > self->capacity)\n    {\n        vector_reserve( self, size );\n        self->size = self->capacity;\n    }\n    else\n    {\n        self->size = size;\n    }\n}\n\n\n// -------------------------------------------------- vector_push_back_data ---\nvoid\nvector_push_back_data( vector_t *self,\n                       const void * data,\n                       const size_t count )\n{\n    assert( self );\n    assert( data );\n    assert( count );\n\n    if( self->capacity < (self->size+count) )\n    {\n        vector_reserve(self, self->size+count);\n    }\n    memmove( (char *)(self->items) + self->size * self->item_size, data,\n             count*self->item_size );\n    self->size += count;\n}\n\n\n// ----------------------------------------------------- vector_insert_data ---\nvoid\nvector_insert_data( vector_t *self,\n                    const size_t index,\n                    const void * data,\n                    const size_t count )\n{\n    assert( self );\n    assert( index < self->size );\n    assert( data );\n    assert( count );\n\n    if( self->capacity < (self->size+count) )\n    {\n        vector_reserve(self, self->size+count);\n    }\n    memmove( (char *)(self->items) + (index + count ) * self->item_size,\n             (char *)(self->items) + (index ) * self->item_size,\n             count*self->item_size );\n    memmove( (char *)(self->items) + index * self->item_size, data,\n             count*self->item_size );\n    self->size += count;\n}\n\n\n// ------------------------------------------------------------ vector_sort ---\nvoid\nvector_sort( vector_t *self,\n             int (*cmp)(const void *, const void *) )\n{\n    assert( self );\n    assert( self->size );\n\n    qsort(self->items, self->size, self->item_size, cmp);\n}\n"
        },
        {
          "name": "vector.h",
          "type": "blob",
          "size": 6.6533203125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __VECTOR_H__\n#define __VECTOR_H__\n\n#include <stdlib.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stddef.h>\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   vector.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup vector Vector\n *\n * The vector structure and accompanying functions loosely mimic the STL C++\n * vector class. It is used by @ref texture-atlas (for storing nodes), @ref\n * texture-font (for storing glyphs) and @ref font-manager (for storing fonts).\n * More information at http://www.cppreference.com/wiki/container/vector/start\n *\n * <b>Example Usage</b>:\n * @code\n * #include \"vector.h\"\n *\n * int main( int arrgc, char *argv[] )\n * {\n *   int i,j = 1;\n *   vector_t * vector = vector_new( sizeof(int) );\n *   vector_push_back( &i );\n *\n *   j = * (int *) vector_get( vector, 0 );\n *   vector_delete( vector);\n *\n *   return 0;\n * }\n * @endcode\n *\n * @{\n */\n\n/**\n *  Generic vector structure.\n *\n * @memberof vector\n */\ntypedef struct vector_t\n {\n     /** Pointer to dynamically allocated items. */\n     void * items;\n\n     /** Number of items that can be held in currently allocated storage. */\n     size_t capacity;\n\n     /** Number of items. */\n     size_t size;\n\n     /** Size (in bytes) of a single item. */\n     size_t item_size;\n} vector_t;\n\n\n/**\n * Creates a new empty vector.\n *\n * @param   item_size    item size in bytes\n * @return               a new empty vector\n *\n */\n  vector_t *\n  vector_new( size_t item_size );\n\n\n/**\n *  Deletes a vector.\n *\n *  @param self a vector structure\n *\n */\n  void\n  vector_delete( vector_t *self );\n\n\n/**\n *  Returns a pointer to the item located at specified index.\n *\n *  @param  self  a vector structure\n *  @param  index the index of the item to be returned\n *  @return       pointer on the specified item\n */\n  const void *\n  vector_get( const vector_t *self,\n              size_t index );\n\n\n/**\n *  Returns a pointer to the first item.\n *\n *  @param  self  a vector structure\n *  @return       pointer on the first item\n */\n  const void *\n  vector_front( const vector_t *self );\n\n\n/**\n *  Returns a pointer to the last item\n *\n *  @param  self  a vector structure\n *  @return pointer on the last item\n */\n  const void *\n  vector_back( const vector_t *self );\n\n\n/**\n *  Check if an item is contained within the vector.\n *\n *  @param  self  a vector structure\n *  @param  item  item to be searched in the vector\n *  @param  cmp   a pointer a comparison function\n *  @return       1 if item is contained within the vector, 0 otherwise\n */\n  int\n  vector_contains( const vector_t *self,\n                   const void *item,\n                   int (*cmp)(const void *, const void *) );\n\n\n/**\n *  Checks whether the vector is empty.\n *\n *  @param  self  a vector structure\n *  @return       1 if the vector is empty, 0 otherwise\n */\n  int\n  vector_empty( const vector_t *self );\n\n\n/**\n *  Returns the number of items\n *\n *  @param  self  a vector structure\n *  @return       number of items\n */\n  size_t\n  vector_size( const vector_t *self );\n\n\n/**\n *  Reserve storage such that it can hold at last size items.\n *\n *  @param  self  a vector structure\n *  @param  size  the new storage capacity\n */\n  void\n  vector_reserve( vector_t *self,\n                  const size_t size );\n\n\n/**\n *  Returns current storage capacity\n *\n *  @param  self  a vector structure\n *  @return       storage capacity\n */\n  size_t\n  vector_capacity( const vector_t *self );\n\n\n/**\n *  Decrease capacity to fit actual size.\n *\n *  @param  self  a vector structure\n */\n  void\n  vector_shrink( vector_t *self );\n\n\n/**\n *  Removes all items.\n *\n *  @param  self  a vector structure\n */\n  void\n  vector_clear( vector_t *self );\n\n\n/**\n *  Replace an item.\n *\n *  @param  self  a vector structure\n *  @param  index the index of the item to be replaced\n *  @param  item  the new item\n */\n  void\n  vector_set( vector_t *self,\n              const size_t index,\n              const void *item );\n\n\n/**\n *  Erase an item.\n *\n *  @param  self  a vector structure\n *  @param  index the index of the item to be erased\n */\n  void\n  vector_erase( vector_t *self,\n                const size_t index );\n\n\n/**\n *  Erase a range of items.\n *\n *  @param  self  a vector structure\n *  @param  first the index of the first item to be erased\n *  @param  last  the index of the last item to be erased\n */\n  void\n  vector_erase_range( vector_t *self,\n                      const size_t first,\n                      const size_t last );\n\n\n/**\n *  Appends given item to the end of the vector.\n *\n *  @param  self a vector structure\n *  @param  item the item to be inserted\n */\n  void\n  vector_push_back( vector_t *self,\n                    const void *item );\n\n\n/**\n *  Removes the last item of the vector.\n *\n *  @param  self a vector structure\n */\n  void\n  vector_pop_back( vector_t *self );\n\n\n/**\n *  Resizes the vector to contain size items\n *\n *  If the current size is less than size, additional items are appended and\n *  initialized with value. If the current size is greater than size, the\n *  vector is reduced to its first size elements.\n *\n *  @param  self a vector structure\n *  @param  size the new size\n */\n  void\n  vector_resize( vector_t *self,\n                 const size_t size );\n\n\n/**\n *  Insert a single item at specified index.\n *\n *  @param  self  a vector structure\n *  @param  index location before which to insert item\n *  @param  item  the item to be inserted\n */\n  void\n  vector_insert( vector_t *self,\n                 const size_t index,\n                 const void *item );\n\n\n/**\n *  Insert raw data at specified index.\n *\n *  @param  self  a vector structure\n *  @param  index location before which to insert item\n *  @param  data  a pointer to the items to be inserted\n *  @param  count the number of items to be inserted\n */\n  void\n  vector_insert_data( vector_t *self,\n                      const size_t index,\n                      const void * data,\n                      const size_t count );\n\n\n/**\n *  Append raw data to the end of the vector.\n *\n *  @param  self  a vector structure\n *  @param  data  a pointer to the items to be inserted\n *  @param  count the number of items to be inserted\n */\n  void\n  vector_push_back_data( vector_t *self,\n                         const void * data,\n                         const size_t count );\n\n\n/**\n *  Sort vector items according to cmp function.\n *\n *  @param  self  a vector structure\n *  @param  cmp   a pointer a comparison function\n */\n  void\n  vector_sort( vector_t *self,\n               int (*cmp)(const void *, const void *) );\n\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __VECTOR_H__ */\n"
        },
        {
          "name": "vertex-attribute.c",
          "type": "blob",
          "size": 3.3798828125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"vec234.h\"\n#include \"platform.h\"\n#include \"vertex-attribute.h\"\n#include \"ftgl-utils.h\"\n\n\n// ----------------------------------------------------------------------------\nvertex_attribute_t *\nvertex_attribute_new( GLchar * name,\n                      GLint size,\n                      GLenum type,\n                      GLboolean normalized,\n                      GLsizei stride,\n                      GLvoid *pointer )\n{\n    vertex_attribute_t *attribute =\n        (vertex_attribute_t *) malloc (sizeof(vertex_attribute_t));\n\n    assert( size > 0 );\n\n    attribute->name       = (GLchar *) strdup( name );\n    attribute->index      = -1;\n    attribute->size       = size;\n    attribute->type       = type;\n    attribute->normalized = normalized;\n    attribute->stride     = stride;\n    attribute->pointer    = pointer;\n    return attribute;\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_attribute_delete( vertex_attribute_t * self )\n{\n    assert( self );\n\n    free( self->name );\n    free( self );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvertex_attribute_t *\nvertex_attribute_parse( char *format )\n{\n    GLenum type = 0;\n    int size;\n    int normalized = 0;\n    char ctype;\n    char *name = NULL;\n    vertex_attribute_t *attr;\n    char *p = strchr(format, ':');\n    if( p != NULL)\n    {\n        name = strndup(format, p-format);\n        if( *(++p) == '\\0' )\n        {\n\t    freetype_gl_error_str( No_Size_Specified, name );\n            free( name );\n            return 0;\n        }\n        size = *p - '0';\n\n        if( *(++p) == '\\0' )\n        {\n            freetype_gl_error_str( No_Format_Specified, name );\n            free( name );\n            return 0;\n        }\n        ctype = *p;\n\n        if( *(++p) != '\\0' )\n        {\n            if( *p == 'n' )\n            {\n                normalized = 1;\n            }\n        }\n\n    }\n    else\n    {\n        freetype_gl_error_str(Vertex_Attribute_Format_Wrong, name );\n        return 0;\n    }\n\n    switch( ctype )\n    {\n    case 'b': type = GL_BYTE;           break;\n    case 'B': type = GL_UNSIGNED_BYTE;  break;\n    case 's': type = GL_SHORT;          break;\n    case 'S': type = GL_UNSIGNED_SHORT; break;\n    case 'i': type = GL_INT;            break;\n    case 'I': type = GL_UNSIGNED_INT;   break;\n    case 'f': type = GL_FLOAT;          break;\n    default:  type = 0;                 break;\n    }\n\n\n    attr = vertex_attribute_new( name, size, type, normalized, 0, 0 );\n    free( name );\n    return attr;\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_attribute_enable( vertex_attribute_t *attr )\n{\n    if( attr->index == -1 )\n    {\n        GLint program;\n        glGetIntegerv( GL_CURRENT_PROGRAM, &program );\n        if( program == 0)\n        {\n            return;\n        }\n        attr->index = glGetAttribLocation( program, attr->name );\n        if( attr->index == -1 )\n        {\n            return;\n        }\n    }\n    glEnableVertexAttribArray( attr->index );\n    glVertexAttribPointer( attr->index, attr->size, attr->type,\n                           attr->normalized, attr->stride, attr->pointer );\n}\n"
        },
        {
          "name": "vertex-attribute.h",
          "type": "blob",
          "size": 7.375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __VERTEX_ATTRIBUTE_H__\n#define __VERTEX_ATTRIBUTE_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"opengl.h\"\n#include \"vector.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   vertex-attribute.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n *\n * @defgroup vertex-attribut Vertex attribute\n *\n * Besides the required vertex position, vertices can have several other\n * numeric attributes. Each is specified in the format string with a letter,\n * the number of components and the data type.\n *\n * Each of the attributes is described in the table below with the set of valid\n * format strings written as a regular expression (for example, \"v[234][if]\"\n * means \"v2f\", \"v3i\", \"v4f\", etc. are all valid formats).\n *\n * Some attributes have a \"recommended\" format string, which is the most\n * efficient form for the video driver as it requires less conversion.\n *\n * <table>\n *   <tr>\n *     <th>Attribute</th>\n *     <th>Formats</th>\n *     <th>Recommended</th>\n *   </tr>\n *   <tr>\n *     <td>Vertex position</td>\n *     <td>\"v[234][sifd]\"</td>\n *     <td>\"v[234]f\"</td>\n *   </tr>\n *   <tr>\n *     <td> Color             </td>\n *     <td> \"c[34][bBsSiIfd]\" </td>\n *     <td> \"c[34]B\"          </td>\n *   </tr>\n *   <tr>\n *     <td> Edge flag </td>\n *     <td> \"e1[bB]\"  </td>\n *     <td>           </td>\n *   </tr>\n *   <tr>\n *    <td> Fog coordinate     </td>\n *    <td> \"f[1234][bBsSiIfd]\"</td>\n *    <td>                    </td>\n *   </tr>\n *   <tr>\n *     <td> Normal      </td>\n *     <td> \"n3[bsifd]\" </td>\n *     <td> \"n3f\"       </td>\n *   </tr>\n *   <tr>\n *     <td> Secondary color   </td>\n *     <td> \"s[34][bBsSiIfd]\" </td>\n *     <td> \"s[34]B\"          </td>\n *   </tr>\n *   <tr>\n *     <td> Texture coordinate </td>\n *     <td> \"t[234][sifd]\"     </td>\n *     <td> \"t[234]f\"          </td>\n *   </tr>\n *   <tr>\n *     <td> Generic attribute             </td>\n *     <td> \"[0-15]g(n)?[1234][bBsSiIfd]\" </td>\n *     <td>                               </td>\n *   </tr>\n * </table>\n *\n * The possible data types that can be specified in the format string are described below.\n *\n * <table>\n *   <tr>\n *     <th> Format   </th>\n *     <th> Type     </th>\n *     <th> GL Type  </th>\n *   </tr>\n *   <tr>\n *     <td> \"b\"               </td>\n *     <td> Signed byte       </td>\n *     <td> GL_BYTE           </td>\n *   </tr>\n *   <tr>\n *     <td> \"B\"               </td>\n *     <td> Unsigned byte     </td>\n *     <td> GL_UNSIGNED_BYTE  </td>\n *   </tr>\n *   <tr>\n *     <td> \"s\"               </td>\n *     <td> Signed short      </td>\n *     <td> GL_SHORT          </td>\n *   </tr>\n *   <tr>\n *     <td> \"S\"               </td>\n *     <td> Unsigned short    </td>\n *     <td> GL_UNSIGNED_SHORT </td>\n *   </tr>\n *   <tr>\n *     <td> \"i\"               </td>\n *     <td> Signed int        </td>\n *     <td> GL_INT            </td>\n *   </tr>\n *   <tr>\n *     <td> \"I\"               </td>\n *     <td> Unsigned int      </td>\n *     <td> GL_UNSIGNED_INT   </td>\n *   </tr>\n *   <tr>\n *     <td> \"f\"               </td>\n *     <td> Float             </td>\n *     <td> GL_FLOAT          </td>\n *   </tr>\n *   <tr>\n *     <td> \"d\"               </td>\n *     <td> Double            </td>\n *     <td> GL_DOUBLE     T   </td>\n *   </tr>\n * </table>\n *\n * The following attributes are normalised to the range [0, 1]. The value is\n * used as-is if the data type is floating-point. If the data type is byte,\n * short or int, the value is divided by the maximum value representable by\n * that type. For example, unsigned bytes are divided by 255 to get the\n * normalised value.\n *\n *  - Color\n *  - Secondary color\n *  - Generic attributes with the \"n\" format given.\n *\n * Up to 16 generic attributes can be specified per vertex, and can be used by\n * shader programs for any purpose (they are ignored in the fixed-function\n * pipeline). For the other attributes, consult the OpenGL programming guide\n * for details on their effects.\n *\n * When using the draw and related functions, attribute data is specified\n * alongside the vertex position data. The following example reproduces the two\n * points from the previous page, except that the first point is blue and the\n * second green:\n *\n * It is an error to provide more than one set of data for any attribute, or to\n * mismatch the size of the initial data with the number of vertices specified\n * in the first argument.\n *\n * @{\n */\n\n\n/**\n * Maximum number of attributes per vertex\n *\n * @private\n */\n#define MAX_VERTEX_ATTRIBUTE 16\n\n\n/**\n *  Generic vertex attribute.\n */\ntypedef struct vertex_attribute_t\n{\n    /**\n     *  atribute name\n     */\n    GLchar * name;\n\n    /**\n     * index of the generic vertex attribute to be modified.\n     */\n    GLuint index;\n\n    /**\n     * Number of components per generic vertex attribute.\n     *\n     * Must be 1, 2, 3, or 4. The initial value is 4.\n     */\n    GLint size;\n\n    /**\n     *  data type of each component in the array.\n     *\n     *  Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,\n     *  GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are\n     *  accepted. The initial value is GL_FLOAT.\n     */\n    GLenum type;\n\n    /**\n     *  whether fixed-point data values should be normalized (GL_TRUE) or\n     *  converted directly as fixed-point values (GL_FALSE) when they are\n     *  accessed.\n     */\n    GLboolean normalized;\n\n    /**\n     *  byte offset between consecutive generic vertex attributes.\n     *\n     *  If stride is 0, the generic vertex attributes are understood to be\n     *  tightly packed in the array. The initial value is 0.\n     */\n    GLsizei stride;\n\n    /**\n     *  pointer to the first component of the first attribute element in the\n     *  array.\n     */\n    GLvoid * pointer;\n\n    /**\n     * pointer to the function that enable this attribute.\n     */\n    void ( * enable )(void *);\n\n} vertex_attribute_t;\n\n\n\n/**\n * Create an attribute from the given parameters.\n *\n * @param size       number of component\n * @param type       data type\n * @param normalized Whether fixed-point data values should be normalized\n                     (GL_TRUE) or converted directly as fixed-point values\n                     (GL_FALSE) when they are  accessed.\n * @param stride     byte offset between consecutive attributes.\n * @param pointer    pointer to the first component of the first attribute\n *                   element in the array.\n * @return           a new initialized vertex attribute.\n *\n * @private\n */\nvertex_attribute_t *\nvertex_attribute_new( GLchar * name,\n                      GLint size,\n                      GLenum type,\n                      GLboolean normalized,\n                      GLsizei stride,\n                      GLvoid *pointer );\n\n\n\n/**\n * Delete a vertex attribute.\n *\n * @param  self a vertex attribute\n *\n */\nvoid\nvertex_attribute_delete( vertex_attribute_t * self );\n\n\n/**\n * Create an attribute from the given description.\n *\n * @param  format Format string specifies the format of a vertex attribute.\n * @return        an initialized vertex attribute\n *\n * @private\n */\n  vertex_attribute_t *\n  vertex_attribute_parse( char *format );\n\n/**\n * Enable a vertex attribute.\n *\n * @param attr  a vertex attribute\n *\n * @private\n */\n  void\n  vertex_attribute_enable( vertex_attribute_t *attr );\n\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __VERTEX_ATTRIBUTE_H__ */\n"
        },
        {
          "name": "vertex-buffer.c",
          "type": "blob",
          "size": 16.0537109375,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"vec234.h\"\n#include \"platform.h\"\n#include \"vertex-buffer.h\"\n#include \"ftgl-utils.h\"\n\n/**\n * Buffer status\n */\n#define CLEAN  (0)\n#define DIRTY  (1)\n#define FROZEN (2)\n\n\n// ----------------------------------------------------------------------------\nvertex_buffer_t *\nvertex_buffer_new( const char *format )\n{\n    size_t i, index = 0, stride = 0;\n    const char *start = 0, *end = 0;\n    GLchar *pointer = 0;\n\n    vertex_buffer_t *self = (vertex_buffer_t *) malloc (sizeof(vertex_buffer_t));\n    if( !self )\n    {\n        return NULL;\n    }\n\n    self->format = strdup( format );\n\n    for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )\n    {\n        self->attributes[i] = 0;\n    }\n\n    start = format;\n    do\n    {\n        char *desc = 0;\n        vertex_attribute_t *attribute;\n        GLuint attribute_size = 0;\n        end = (char *) (strchr(start+1, ','));\n\n        if (end == NULL)\n        {\n            desc = strdup( start );\n        }\n        else\n        {\n            desc = strndup( start, end-start );\n        }\n        attribute = vertex_attribute_parse( desc );\n        start = end+1;\n        free(desc);\n        attribute->pointer = pointer;\n\n        switch( attribute->type )\n        {\n        case GL_BOOL:           attribute_size = sizeof(GLboolean); break;\n        case GL_BYTE:           attribute_size = sizeof(GLbyte); break;\n        case GL_UNSIGNED_BYTE:  attribute_size = sizeof(GLubyte); break;\n        case GL_SHORT:          attribute_size = sizeof(GLshort); break;\n        case GL_UNSIGNED_SHORT: attribute_size = sizeof(GLushort); break;\n        case GL_INT:            attribute_size = sizeof(GLint); break;\n        case GL_UNSIGNED_INT:   attribute_size = sizeof(GLuint); break;\n        case GL_FLOAT:          attribute_size = sizeof(GLfloat); break;\n        default:                attribute_size = 0;\n        }\n        stride  += attribute->size*attribute_size;\n        pointer += attribute->size*attribute_size;\n        self->attributes[index] = attribute;\n        index++;\n    } while ( end && (index < MAX_VERTEX_ATTRIBUTE) );\n\n    for( i=0; i<index; ++i )\n    {\n        self->attributes[i]->stride = stride;\n    }\n\n#ifdef FREETYPE_GL_USE_VAO\n    self->VAO_id = 0;\n#endif\n\n    self->vertices = vector_new( stride );\n    self->vertices_id  = 0;\n    self->GPU_vsize = 0;\n\n    self->indices = vector_new( sizeof(GLuint) );\n    self->indices_id  = 0;\n    self->GPU_isize = 0;\n\n    self->items = vector_new( sizeof(ivec4) );\n    self->state = DIRTY;\n    self->mode = GL_TRIANGLES;\n    return self;\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_delete( vertex_buffer_t *self )\n{\n    size_t i;\n\n    assert( self );\n\n    for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )\n    {\n        if( self->attributes[i] )\n        {\n            vertex_attribute_delete( self->attributes[i] );\n        }\n    }\n\n#ifdef FREETYPE_GL_USE_VAO\n    if( self->VAO_id )\n    {\n        glDeleteVertexArrays( 1, &self->VAO_id );\n    }\n    self->VAO_id = 0;\n#endif\n\n    vector_delete( self->vertices );\n    self->vertices = 0;\n    if( self->vertices_id )\n    {\n        glDeleteBuffers( 1, &self->vertices_id );\n    }\n    self->vertices_id = 0;\n\n    vector_delete( self->indices );\n    self->indices = 0;\n    if( self->indices_id )\n    {\n        glDeleteBuffers( 1, &self->indices_id );\n    }\n    self->indices_id = 0;\n\n    vector_delete( self->items );\n\n    if( self->format )\n    {\n        free( self->format );\n    }\n    self->format = 0;\n    self->state = 0;\n    free( self );\n}\n\n\n// ----------------------------------------------------------------------------\nconst char *\nvertex_buffer_format( const vertex_buffer_t *self )\n{\n    assert( self );\n\n    return self->format;\n}\n\n\n// ----------------------------------------------------------------------------\nsize_t\nvertex_buffer_size( const vertex_buffer_t *self )\n{\n    assert( self );\n\n    return vector_size( self->items );\n}\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_print( vertex_buffer_t * self )\n{\n    int i = 0;\n    static char *gltypes[9] = {\n        \"GL_BOOL\",\n        \"GL_BYTE\",\n        \"GL_UNSIGNED_BYTE\",\n        \"GL_SHORT\",\n        \"GL_UNSIGNED_SHORT\",\n        \"GL_INT\",\n        \"GL_UNSIGNED_INT\",\n        \"GL_FLOAT\",\n        \"GL_VOID\"\n    };\n\n    assert(self);\n\n    log_error( \"%ld vertices, %ld indices\\n\",\n             vector_size( self->vertices ), vector_size( self->indices ) );\n    while( self->attributes[i] )\n    {\n        int j = 8;\n        switch( self->attributes[i]->type )\n        {\n        case GL_BOOL:           j=0; break;\n        case GL_BYTE:           j=1; break;\n        case GL_UNSIGNED_BYTE:  j=2; break;\n        case GL_SHORT:          j=3; break;\n        case GL_UNSIGNED_SHORT: j=4; break;\n        case GL_INT:            j=5; break;\n        case GL_UNSIGNED_INT:   j=6; break;\n        case GL_FLOAT:          j=7; break;\n        default:                j=8; break;\n        }\n        log_error( \"%s : %dx%s (+%p)\\n\",\n                self->attributes[i]->name,\n                self->attributes[i]->size,\n                gltypes[j],\n                self->attributes[i]->pointer);\n\n        i += 1;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_upload ( vertex_buffer_t *self )\n{\n    size_t vsize, isize;\n\n    if( self->state == FROZEN )\n    {\n        return;\n    }\n\n    if( !self->vertices_id )\n    {\n        glGenBuffers( 1, &self->vertices_id );\n    }\n    if( !self->indices_id )\n    {\n        glGenBuffers( 1, &self->indices_id );\n    }\n\n    vsize = self->vertices->size*self->vertices->item_size;\n    isize = self->indices->size*self->indices->item_size;\n\n\n    // Always upload vertices first such that indices do not point to non\n    // existing data (if we get interrupted in between for example).\n\n    // Upload vertices\n    glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );\n    if( vsize != self->GPU_vsize )\n    {\n        glBufferData( GL_ARRAY_BUFFER,\n                      vsize, self->vertices->items, GL_DYNAMIC_DRAW );\n        self->GPU_vsize = vsize;\n    }\n    else\n    {\n        glBufferSubData( GL_ARRAY_BUFFER,\n                         0, vsize, self->vertices->items );\n    }\n    glBindBuffer( GL_ARRAY_BUFFER, 0 );\n\n    // Upload indices\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );\n    if( isize != self->GPU_isize )\n    {\n        glBufferData( GL_ELEMENT_ARRAY_BUFFER,\n                      isize, self->indices->items, GL_DYNAMIC_DRAW );\n        self->GPU_isize = isize;\n    }\n    else\n    {\n        glBufferSubData( GL_ELEMENT_ARRAY_BUFFER,\n                         0, isize, self->indices->items );\n    }\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_clear( vertex_buffer_t *self )\n{\n    assert( self );\n\n    self->state = FROZEN;\n    vector_clear( self->indices );\n    vector_clear( self->vertices );\n    vector_clear( self->items );\n    self->state = DIRTY;\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_render_setup ( vertex_buffer_t *self, GLenum mode )\n{\n    size_t i;\n\n#ifdef FREETYPE_GL_USE_VAO\n    // Unbind so no existing VAO-state is overwritten,\n    // (e.g. the GL_ELEMENT_ARRAY_BUFFER-binding).\n    glBindVertexArray( 0 );\n#endif\n\n    if( self->state != CLEAN )\n    {\n        vertex_buffer_upload( self );\n        self->state = CLEAN;\n    }\n\n#ifdef FREETYPE_GL_USE_VAO\n    if( self->VAO_id == 0 )\n    {\n        // Generate and set up VAO\n\n        glGenVertexArrays( 1, &self->VAO_id );\n        glBindVertexArray( self->VAO_id );\n\n        glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );\n\n        for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )\n        {\n            vertex_attribute_t *attribute = self->attributes[i];\n            if( attribute == 0 )\n            {\n                continue;\n            }\n            else\n            {\n                vertex_attribute_enable( attribute );\n            }\n        }\n\n        glBindBuffer( GL_ARRAY_BUFFER, 0 );\n\n        if( self->indices->size )\n        {\n            glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );\n        }\n    }\n\n    // Bind VAO for drawing\n    glBindVertexArray( self->VAO_id );\n#else\n\n    glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );\n\n    for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )\n    {\n        vertex_attribute_t *attribute = self->attributes[i];\n        if ( attribute == 0 )\n        {\n            continue;\n        }\n        else\n        {\n            vertex_attribute_enable( attribute );\n        }\n    }\n\n    if( self->indices->size )\n    {\n        glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );\n    }\n#endif\n\n    self->mode = mode;\n}\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_render_finish ( vertex_buffer_t *self )\n{\n#ifdef FREETYPE_GL_USE_VAO\n    glBindVertexArray( 0 );\n#else\n    int i;\n\n    for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )\n    {\n        vertex_attribute_t *attribute = self->attributes[i];\n        if( attribute == 0 )\n        {\n            continue;\n        }\n        else\n        {\n            glDisableVertexAttribArray( attribute->index );\n        }\n    }\n\n    glBindBuffer( GL_ARRAY_BUFFER, 0 );\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );\n#endif\n}\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_render_item ( vertex_buffer_t *self,\n                            size_t index )\n{\n    ivec4 * item = (ivec4 *) vector_get( self->items, index );\n    assert( self );\n    assert( index < vector_size( self->items ) );\n\n\n    if( self->indices->size )\n    {\n        size_t start = item->istart;\n        size_t count = item->icount;\n        glDrawElements( self->mode, count, GL_UNSIGNED_INT, (void *)(start*sizeof(GLuint)) );\n    }\n    else if( self->vertices->size )\n    {\n        size_t start = item->vstart;\n        size_t count = item->vcount;\n        glDrawArrays( self->mode, start*self->vertices->item_size, count);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_render ( vertex_buffer_t *self, GLenum mode )\n{\n    size_t vcount = self->vertices->size;\n    size_t icount = self->indices->size;\n\n    vertex_buffer_render_setup( self, mode );\n    if( icount )\n    {\n        glDrawElements( mode, icount, GL_UNSIGNED_INT, 0 );\n    }\n    else\n    {\n        glDrawArrays( mode, 0, vcount );\n    }\n    vertex_buffer_render_finish( self );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_push_back_indices ( vertex_buffer_t * self,\n                                  const GLuint * indices,\n                                  const size_t icount )\n{\n    assert( self );\n\n    self->state |= DIRTY;\n    vector_push_back_data( self->indices, indices, icount );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_push_back_vertices ( vertex_buffer_t * self,\n                                   const void * vertices,\n                                   const size_t vcount )\n{\n    assert( self );\n\n    self->state |= DIRTY;\n    vector_push_back_data( self->vertices, vertices, vcount );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_insert_indices ( vertex_buffer_t *self,\n                               const size_t index,\n                               const GLuint *indices,\n                               const size_t count )\n{\n    assert( self );\n    assert( self->indices );\n    assert( index < self->indices->size+1 );\n\n    self->state |= DIRTY;\n    vector_insert_data( self->indices, index, indices, count );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_insert_vertices( vertex_buffer_t *self,\n                               const size_t index,\n                               const void *vertices,\n                               const size_t vcount )\n{\n    size_t i;\n    assert( self );\n    assert( self->vertices );\n    assert( index < self->vertices->size+1 );\n\n    self->state |= DIRTY;\n\n     for( i=0; i<self->indices->size; ++i )\n    {\n        if( *(GLuint *)(vector_get( self->indices, i )) > index )\n        {\n            *(GLuint *)(vector_get( self->indices, i )) += index;\n        }\n    }\n\n    vector_insert_data( self->vertices, index, vertices, vcount );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_erase_indices( vertex_buffer_t *self,\n                             const size_t first,\n                             const size_t last )\n{\n    assert( self );\n    assert( self->indices );\n    assert( first < self->indices->size );\n    assert( (last) <= self->indices->size );\n\n    self->state |= DIRTY;\n    vector_erase_range( self->indices, first, last );\n}\n\n\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_erase_vertices( vertex_buffer_t *self,\n                              const size_t first,\n                              const size_t last )\n{\n    size_t i;\n    assert( self );\n    assert( self->vertices );\n    assert( first < self->vertices->size );\n    assert( last <= self->vertices->size );\n    assert( last > first );\n\n    self->state |= DIRTY;\n    for( i=0; i<self->indices->size; ++i )\n    {\n        if( *(GLuint *)(vector_get( self->indices, i )) > first )\n        {\n            *(GLuint *)(vector_get( self->indices, i )) -= (last-first);\n        }\n    }\n    vector_erase_range( self->vertices, first, last );\n}\n\n\n\n// ----------------------------------------------------------------------------\nsize_t\nvertex_buffer_push_back( vertex_buffer_t * self,\n                         const void * vertices, const size_t vcount,\n                         const GLuint * indices, const size_t icount )\n{\n    return vertex_buffer_insert( self, vector_size( self->items ),\n                                 vertices, vcount, indices, icount );\n}\n\n// ----------------------------------------------------------------------------\nsize_t\nvertex_buffer_insert( vertex_buffer_t * self, const size_t index,\n                      const void * vertices, const size_t vcount,\n                      const GLuint * indices, const size_t icount )\n{\n    size_t vstart, istart, i;\n    ivec4 item;\n    assert( self );\n    assert( vertices );\n    assert( indices );\n\n    self->state = FROZEN;\n\n    // Push back vertices\n    vstart = vector_size( self->vertices );\n    vertex_buffer_push_back_vertices( self, vertices, vcount );\n\n    // Push back indices\n    istart = vector_size( self->indices );\n    vertex_buffer_push_back_indices( self, indices, icount );\n\n    // Update indices within the vertex buffer\n    for( i=0; i<icount; ++i )\n    {\n        *(GLuint *)(vector_get( self->indices, istart+i )) += vstart;\n    }\n\n    // Insert item\n    item.x = vstart;\n    item.y = vcount;\n    item.z = istart;\n    item.w = icount;\n    vector_insert( self->items, index, &item );\n\n    self->state = DIRTY;\n    return index;\n}\n\n// ----------------------------------------------------------------------------\nvoid\nvertex_buffer_erase( vertex_buffer_t * self,\n                     const size_t index )\n{\n    ivec4 * item;\n    int vstart;\n    size_t vcount, istart, icount, i;\n\n    assert( self );\n    assert( index < vector_size( self->items ) );\n\n    item = (ivec4 *) vector_get( self->items, index );\n    vstart = item->vstart;\n    vcount = item->vcount;\n    istart = item->istart;\n    icount = item->icount;\n\n    // Update items\n    for( i=0; i<vector_size(self->items); ++i )\n    {\n        ivec4 * item = (ivec4 *) vector_get( self->items, i );\n        if( item->vstart > vstart)\n        {\n            item->vstart -= vcount;\n            item->istart -= icount;\n        }\n    }\n\n    self->state = FROZEN;\n    vertex_buffer_erase_indices( self, istart, istart+icount );\n    vertex_buffer_erase_vertices( self, vstart, vstart+vcount );\n    vector_erase( self->items, index );\n    self->state = DIRTY;\n}\n"
        },
        {
          "name": "vertex-buffer.h",
          "type": "blob",
          "size": 7.1220703125,
          "content": "/* Freetype GL - A C OpenGL Freetype engine\n *\n * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying\n * file `LICENSE` for more details.\n */\n#ifndef __VERTEX_BUFFER_H__\n#define __VERTEX_BUFFER_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"opengl.h\"\n#include \"vector.h\"\n#include \"vertex-attribute.h\"\n\n#ifdef __cplusplus\nnamespace ftgl {\n#endif\n\n/**\n * @file   vertex-buffer.h\n * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)\n * @date   April, 2012\n *\n * @defgroup vertex-buffer Vertex buffer\n *\n * @{\n */\n\n\n/**\n * Generic vertex buffer.\n */\ntypedef struct vertex_buffer_t\n{\n    /** Format of the vertex buffer. */\n    char * format;\n\n    /** Vector of vertices. */\n    vector_t * vertices;\n\n#ifdef FREETYPE_GL_USE_VAO\n    /** GL identity of the Vertex Array Object */\n    GLuint VAO_id;\n#endif\n\n    /** GL identity of the vertices buffer. */\n    GLuint vertices_id;\n\n    /** Vector of indices. */\n    vector_t * indices;\n\n    /** GL identity of the indices buffer. */\n    GLuint indices_id;\n\n    /** Current size of the vertices buffer in GPU */\n    size_t GPU_vsize;\n\n    /** Current size of the indices buffer in GPU*/\n    size_t GPU_isize;\n\n    /** GL primitives to render. */\n    GLenum mode;\n\n    /** Whether the vertex buffer needs to be uploaded to GPU memory. */\n    char state;\n\n    /** Individual items */\n    vector_t * items;\n\n    /** Array of attributes. */\n    vertex_attribute_t *attributes[MAX_VERTEX_ATTRIBUTE];\n} vertex_buffer_t;\n\n\n/**\n * Creates an empty vertex buffer.\n *\n * @param  format a string describing vertex format.\n * @return        an empty vertex buffer.\n */\n  vertex_buffer_t *\n  vertex_buffer_new( const char *format );\n\n\n/**\n * Deletes vertex buffer and releases GPU memory.\n *\n * @param  self  a vertex buffer\n */\n  void\n  vertex_buffer_delete( vertex_buffer_t * self );\n\n\n/**\n *  Returns the number of items in the vertex buffer\n *\n *  @param  self  a vertex buffer\n *  @return       number of items\n */\n  size_t\n  vertex_buffer_size( const vertex_buffer_t *self );\n\n\n/**\n *  Returns vertex format\n *\n *  @param  self  a vertex buffer\n *  @return       vertex format\n */\n  const char *\n  vertex_buffer_format( const vertex_buffer_t *self );\n\n\n/**\n * Print information about a vertex buffer\n *\n * @param  self  a vertex buffer\n */\n  void\n  vertex_buffer_print( vertex_buffer_t * self );\n\n\n/**\n * Prepare vertex buffer for render.\n *\n * @param  self  a vertex buffer\n * @param  mode  render mode\n */\n  void\n  vertex_buffer_render_setup ( vertex_buffer_t *self,\n                               GLenum mode );\n\n\n/**\n * Finish rendering by setting back modified states\n *\n * @param  self  a vertex buffer\n */\n  void\n  vertex_buffer_render_finish ( vertex_buffer_t *self );\n\n\n/**\n * Render vertex buffer.\n *\n * @param  self  a vertex buffer\n * @param  mode  render mode\n */\n  void\n  vertex_buffer_render ( vertex_buffer_t *self,\n                         GLenum mode );\n\n\n/**\n * Render a specified item from the vertex buffer.\n *\n * @param  self   a vertex buffer\n * @param  index index of the item to be rendered\n */\n  void\n  vertex_buffer_render_item ( vertex_buffer_t *self,\n                              size_t index );\n\n\n/**\n * Upload buffer to GPU memory.\n *\n * @param  self  a vertex buffer\n */\n  void\n  vertex_buffer_upload( vertex_buffer_t *self );\n\n\n/**\n * Clear all items.\n *\n * @param  self  a vertex buffer\n */\n  void\n  vertex_buffer_clear( vertex_buffer_t *self );\n\n\n/**\n * Appends indices at the end of the buffer.\n *\n * @param  self     a vertex buffer\n * @param  indices  indices to be appended\n * @param  icount   number of indices to be appended\n *\n * @private\n */\n  void\n  vertex_buffer_push_back_indices ( vertex_buffer_t *self,\n                                    const GLuint * indices,\n                                    const size_t icount );\n\n\n/**\n * Appends vertices at the end of the buffer.\n *\n * @note Internal use\n *\n * @param  self     a vertex buffer\n * @param  vertices vertices to be appended\n * @param  vcount   number of vertices to be appended\n *\n * @private\n */\n  void\n  vertex_buffer_push_back_vertices ( vertex_buffer_t *self,\n                                     const void * vertices,\n                                     const size_t vcount );\n\n\n/**\n * Insert indices in the buffer.\n *\n * @param  self    a vertex buffer\n * @param  index   location before which to insert indices\n * @param  indices indices to be appended\n * @param  icount  number of indices to be appended\n *\n * @private\n */\n  void\n  vertex_buffer_insert_indices ( vertex_buffer_t *self,\n                                 const size_t index,\n                                 const GLuint *indices,\n                                 const size_t icount );\n\n\n/**\n * Insert vertices in the buffer.\n *\n * @param  self     a vertex buffer\n * @param  index    location before which to insert vertices\n * @param  vertices vertices to be appended\n * @param  vcount   number of vertices to be appended\n *\n * @private\n */\n  void\n  vertex_buffer_insert_vertices ( vertex_buffer_t *self,\n                                  const size_t index,\n                                  const void *vertices,\n                                  const size_t vcount );\n\n/**\n * Erase indices in the buffer.\n *\n * @param  self   a vertex buffer\n * @param  first  the index of the first index to be erased\n * @param  last   the index of the last index to be erased\n *\n * @private\n */\n  void\n  vertex_buffer_erase_indices ( vertex_buffer_t *self,\n                                const size_t first,\n                                const size_t last );\n\n/**\n * Erase vertices in the buffer.\n *\n * @param  self   a vertex buffer\n * @param  first  the index of the first vertex to be erased\n * @param  last   the index of the last vertex to be erased\n *\n * @private\n */\n  void\n  vertex_buffer_erase_vertices ( vertex_buffer_t *self,\n                                 const size_t first,\n                                 const size_t last );\n\n\n/**\n * Append a new item to the collection.\n *\n * @param  self   a vertex buffer\n * @param  vcount   number of vertices\n * @param  vertices raw vertices data\n * @param  icount   number of indices\n * @param  indices  raw indices data\n */\n  size_t\n  vertex_buffer_push_back( vertex_buffer_t * self,\n                           const void * vertices, const size_t vcount,\n                           const GLuint * indices, const size_t icount );\n\n\n/**\n * Insert a new item into the vertex buffer.\n *\n * @param  self      a vertex buffer\n * @param  index     location before which to insert item\n * @param  vertices  raw vertices data\n * @param  vcount    number of vertices\n * @param  indices   raw indices data\n * @param  icount    number of indices\n */\n  size_t\n  vertex_buffer_insert( vertex_buffer_t * self,\n                        const size_t index,\n                        const void * vertices, const size_t vcount,\n                        const GLuint * indices, const size_t icount );\n\n/**\n * Erase an item from the vertex buffer.\n *\n * @param  self     a vertex buffer\n * @param  index    index of the item to be deleted\n */\n  void\n  vertex_buffer_erase( vertex_buffer_t * self,\n                       const size_t index );\n\n/** @} */\n\n#ifdef __cplusplus\n}\n}\n#endif\n\n#endif /* __VERTEX_BUFFER_H__ */\n"
        },
        {
          "name": "windows",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}