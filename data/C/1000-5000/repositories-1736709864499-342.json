{
  "metadata": {
    "timestamp": 1736709864499,
    "page": 342,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lastpass/lastpass-cli",
      "stars": 2861,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "/build/\n/test/.lpass\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.16015625,
          "content": "# EditorConfig is awesome: http://EditorConfig.org\nroot = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\nindent_style = tab\nindent_size = 4\ncharset = utf-8\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1015625,
          "content": "*.o\n*.d\n*.swp\nlpass\nlpass.1\nlpass.exe\ncertificate.h\ntags\nbuild\ntest/.lpass\nversion.h\n\n# IDE\n/.idea\n/.vs\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.51171875,
          "content": "language: cpp\nsudo: required\ndist: trusty\nosx_image: xcode7\n\ncompiler:\n - gcc\n - clang\n\nos:\n- linux\n- osx\n\nbefore_install:\n- if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew update; fi\n- if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew install libxml2 || true ; fi\n- if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew install cmake || true ; fi\n- if [[ \"$TRAVIS_OS_NAME\" == \"linux\" ]]; then sudo apt-get -qq update; fi\n- if [[ \"$TRAVIS_OS_NAME\" == \"linux\" ]]; then sudo apt-get install -y libxml2-dev; fi\n\nscript: make && make test\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 12.009765625,
          "content": "# Version 1.6.1\n* Fixed a bug that prevented groups from being added to shared folders whenever any of the users did not have a public key\n\n# Version 1.6.0\n* Improve sharing key generation\n* Remove SHA-256 support for login hashes\n* Fix password change failure\n* Replace logic of reusing key as IV\n* Fix incorrect pointer-to-pointer argument passing that would yield compilation errors on GCC-14\n\n# Version 1.5.0\n* Add support for URL logging\n* Fix segmentation faults on Mac OS X\n* Fix synchronization issues, which caused empty IDs\n* Fix feature flags file deletion on logout\n\n# Version 1.4.0\n* Add support for writing encrypted URLs\n* Add support for feature flags\n* Fix shared folder username\n\n# Version 1.3.7\n* Add support for reading encrypted URLs (Tibor Komlossy)\n* Fix GCC 10 compatibility issue #532 (Tibor Komlossy)\n\n# Version 1.3.6\n* Fix version (Béla Ormos)\n\n# Version 1.3.5\n* Updating certificate hashes (Béla Ormos)\n\n# Version 1.3.4\n* Updating post parameter (Gergely Der)\n\n# Version 1.3.3\n * Decrease the time for the cli app to do things (Wesley Schwengle)\n * 'blob_load' refactor (Wesley Schwengle)\n * Fixed bug where logout requires login (Wesley Schwengle)\n * Fix non-default PKG_CONFIG_PATH on macOS (Alyssa Ross)\n\n# Version 1.3.2\n * Don't require using make (Eli Schwartz)\n * Disable IPv6 support (Wesley Schwengle)\n * Link against Brew Curl on MacOS (Tom Sullivan)\n * Autogenerate versions from git (Wesley Schwengle/Eli Schwartz)\n * Remove memory leak in `config_path_for_type` (Tom Sullivan)\n * Install bash-completions in PREFIX dir (Wesley Schwengle)\n * Include `libgen.h` for BSD builds (Tom Sullivan)\n * Create subdirectories when determining config path (Tom Sullivan)\n * Only show basename in usage (William Casarin)\n * Fix segmentation fault on BSD while running `make test` (Björn Ketelaars)\n * README.md updates:\n   * Brew formula installation (Thomas Haggett)\n   * Ubuntu Xenial dependencies (Nick Timkovich)\n   * Debian stable/testing and Ubuntu dependencies (Wesley Schwengle)\n\n# Version 1.3.1\n * Revert \"pins: remove GlobalSign R1/R3 pins\" from Robert Copeland\n * Readme update from Wesley Schwengle\n * Add Dockerfile to create a clean build environment from Wesley Schwengle\n * Missing dependencies in readme\n * Added CLion project files to ignore list\n\n# Version 1.3.0\n * `lpass show` now supports `--json` format\n * `lpass show` now supports `--quiet` flag to suppress prompts,\n   from Pau Sanchez\n * `lpass import` has `--keep-dupes` flag which will preserve duplicate\n   accounts on import\n * `LPASS_PINENTRY` environment variable may now be used to set custom\n   path to pinentry, from Martynas Mickevičius\n * Build fix for aarch64 and others from Natanael Copa\n * New fish completions from Israel Chauca Fuentes\n * Zsh completions from Richard Hillmann\n * Brew build instructions updates from Roger D. Winans\n * bugfix: site notes now show up in notes textarea instead of fields\n * spelling fixes from Josh Soref\n\n# Version 1.2.2\n * `lpass ls --format` now supports \"%al\" to show URL, from Yikai Zhao\n * $VISUAL can be used in preference to $EDITOR, from Wesley Schwengle\n * `lpass edit` can now directly edit multiline ssh keys\n * fields are now preserved when edited with `lpass edit`\n * Bugfix: use-after-free in http.c fixed, from Björn Ketelaars\n * Bugfix: command-line completion now works for names with spaces\n * Bugfix: loading attachments from shared folders now works, from Spencer\n   Whyte\n * Debian packing updates from Hannes Hörl\n * Documentation updates from Darragh Grealish and Steven Liekens\n\n# Version 1.2.1\n * Bugfix: fix regression with ```lpass show``` not displaying all fields\n   for secure notes\n * Use sysctl instead of procfs for pid-to-cmd on some versions of BSD,\n   from Thomas Hurst\n * Build: fix build for test binaries on OpenBSD, from Björn Ketelaars\n\n# Version 1.2.0\n * ```lpass show``` now supports new-style multiline ssh keys\n * ```lpass export``` now supports --fields=FIELDLIST argument to\n   control output, with patches from Kyle Burton\n * ```lpass ls``` now always shows empty shared folders\n * ```lpass edit``` can now set the 'master password reprompt' field in sites\n * ```lpass share create``` now shows the created share name\n * Bugfix: crash in `lpass show` fixed by Kyle Burton\n * build fixes for termux and documentation updates, from Christian Rondeau\n * documentation updates for Ubuntu from Craig Menning and Glenn Oppegard\n * Test suite now included covering basic operations\n\n# Version 1.1.2\n * Bugfix: crash with ```lpass logout --color=never``` fixed\n * Bugfix: ```lpass add``` with secure notes works again\n * Bugfix: sort order in ```lpass ls``` is now consistent whether or not\n   colors are used\n * Documentation has been enhanced to describe aliases and more options,\n   with patches by Eric B. Hymowitz.\n * Build: debian package fixed for rebuild issues and missing build\n   dependencies\n\n# Version 1.1.1\n * Bugfix: fix crash in ```lpass show``` for secure notes without attachments\n * Build: fix build on OpenBSD\n * Build: fix build when using LibreSSL\n\n# Version 1.1.0\n * New command ```lpass import``` can import an existing csv file (or output\n   from ```lpass export``` into the vault\n * ```lpass show``` and ```lpass ls``` learned a ```--format``` argument\n   to enable user-specified printf-style formats\n * Bash completions will now complete field names if ```--field``` is\n   specified after the account name\n * Build: cmake now used for building, by Filippo Cucchetto and\n   with fixes by Eli Schwartz\n * Build: lpass has been updated to work with OpenSSL 1.1; please note\n   that libcurl-openssl must also be linked against the same version\n   in order to avoid mysterious segfaults\n * Bugfix: crash in ```lpass ls -l``` with no last_modified_gmt fixed\n * Bugfix: secure notes editing with \"Name\" fields now works properly\n * Bugfix: editing secure note names now works (github #106)\n * Bugfix: lpass-created server secure notes are now compatible with the plugin\n * Bugfix: ```generate``` now uses all defined characters, by Ignat Korchagin\n * Bugfix: ```lpass show``` for ssh-key secure notes no longer corrupts\n   password-protected ssh keys (github #232)\n\n# Version 1.0.0\n * New command ```lpass status``` shows whether or not the user is logged\n   in with agent, from Nick Knudson\n * ```lpass add``` can now be passed ```--note-type=X``` in order to add\n   a secure note using a template.  Specifying an unknown note template will\n   list the available templates.\n * ```lpass ls``` now shows username with ```--long```, from Alli Witheford\n * Bash completions are now installed with make install, from Eli Schwartz\n * Fish shell completions supplied by Joar Wanboarg\n * Initial support for adding (```lpass add --app```) and editing applications\n * Updates to manpage for ```ls```, ```passwd```, ```add```, and basic\n   usage examples\n * lpass now follows XDG base directory specifications for its files on\n   platforms that use it.  Set ```LP_HOME``` to ~/.lpass to keep the previous\n   location\n * Bugfix: resolved syncing problems on some platforms (notably RHEL/CentOS)\n   related to improper multiprocess usage of libcurl (github #166)\n * Bugfix: ```lpass show``` no longer crashes when a searched-for field is\n   not found (github #167)\n * Bugfix: ```lpass``` no longer exits with an error if the blob is empty\n   but otherwise without parsing errors.  This fixes the case where a new\n   user could not use the application without first adding a site elsewhere.\n * ```LPASS_LOG_LEVEL``` learned level=8 with which lpass will also dump\n   libcurl verbose logs showing all traffic for debugging (not recommended\n   for general use due to potentially sensitive headers being logged).\n\n# Version 0.9.0\n * Add support for accounts in the EU datacenter (lastpass.eu)\n * ```lpass ls``` now sorts its output and properly displays group folder\n   account entries\n * ```lpass export``` output has been reworked to match that of the website,\n   from Justen Walker\n * ```lpass share limit``` subcommand was added which allows displaying and\n   modifying user-specific restrictions for shared folders\n * The new ```LPASS_LOG_LEVEL``` environment variable can be set to cause\n   the lpass uploader process to log its actions, useful for debugging syncing\n   issues.  Set it to 7 to get all debug logs; the logfile will be\n   ~/.lpass/lpass.log.\n * Bugfix: syncing is fixed on systems that use XFS or other filesystems which\n   do not support setting d_type in readdir()\n * Bugfix: ```lpass mv``` now works properly with linked accounts\n\n# Version 0.8.1, 0.7.2, 0.6.1, 0.5.1\n * This update to all recent versions switches to the platform certificate\n   store and adds pinning of LastPass public keys, in preparation for\n   certificate changes at lastpass.com. Upgrade will be needed to avoid \"Peer\n   certificate cannot be authenticated with given CA certificates\" errors\n   when the cert changes are made.\n\n# Version 0.8.0\n * New command ```lpass add``` works like ```lpass edit``` for new accounts\n * New command ```lpass mv``` can be used to move an account into a different (possibly shared) folder\n * New command ```lpass passwd``` can be used to change master password\n * Tab-completion for bash is now available; to use, source ```contrib/lpass_bash_completion``` from a bash startup file\n * ```lpass ls``` now interprets backslash properly for subfolder display\n * ```lpass edit``` gained the ability to edit all fields of an account at once by using a specially-formatted edit buffer\n * ```lpass show``` gained the ability to show multiple accounts at once, from Angus Galloway\n * ```lpass show``` now reformats SSH private key fields in secure notes into a usable form\n * ```lpass share useradd``` gained the ability to specify group names\n * ```lpass share``` got better documentation\n * Bugfix: logins with certain multifactors that support out-of-band authentication will now work correctly\n * Blob edits no longer reencrypt the entire database, just the changed accounts\n * Syncing operation is now much more robust in the face of server errors or\n   invalid transactions.\n * OSX builds fixed for Xcode-less installations, with help from Wael Nasreddine\n * Corrections to FSF address from Tom Prince\n\n# Version 0.7.1\n * This bugfix release fixes a build issue on OSX platforms without XCode. It is otherwise identical to 0.7.0.\n\n# Version 0.7.0\n * ```lpass``` now supports aliases in order to set preferred switches or nicknames for commands. ```echo 'show -G' > ~/.lpass/alias.show```, for example, will turn regex matching on for ```lpass show```.\n * In addition to pinentry and in-process prompting, the ```LPASS_ASKPASS``` environment variable/config value is now checked for a binary to ask for passwords.  It uses the same conventions as ssh-askpass.\n * ```lpass show``` will now match account id when using regex or substring matching\n * ```lpass ls``` learned the ```-l [-u]```switches to show mod and use times, from Lloyd Zusman\n * Secure notes are now created by default when empty sites are edited with --notes, from Lloyd Zusman\n * The new ```LPASS_CLIPBOARD_COMMAND``` environment variable/config value can be used to configure the helper application for the system clipboard, from Tom Prince.  Among other things, you can use this to clear the clipboard after a certain number of pastes with ```xclip -l```.\n * Various code cleanups and documentation fixes from Tom Prince.\n * The license has been clarified to GPLv2 or later, plus the OpenSSL exception; please see individual files and the LICENSE.OpenSSL / COPYING files for details.  This was the intended license all along but it was not spelled out consistently.\n\n# Version 0.6.0\n *  New share sub-command allows automating some common tasks with shared folders\n *  PBKDF2 speedups from Thomas Hurst\n *  Ungrouped entries now fall under \"(none)\" heading, from Gordon Celesta\n *  Documentation updates from Eli Young\n *  Cleanups from Björn Ketelaars\n\n# Version 0.5.1\n * Update Thawte CA cert to support lastpass.com's new SHA-256 cert.\n\n# Version 0.5.0\n *  OpenBSD support\n *  Updated build/install instructions for Cygwin, Debian, and RPM-based distributions\n *  Regex and substring searching for cmd-show\n *  Secure note parsing and field display\n *  Fixes for pinentry errors and hangs\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.9921875,
          "content": "if(${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.1)\n  set(CMAKE_LEGACY_CYGWIN_WIN32 0) # Remove when CMake > 2.8.4 is required\n  cmake_minimum_required(VERSION 2.8)\nelse()\n  cmake_minimum_required(VERSION 3.1)\nendif()\n\nproject(lpass)\ninclude(GNUInstallDirs)\nfind_package(PkgConfig REQUIRED)\n\nif(${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.4)\n  # pkg_get_variable is not available until CMake >= 3.4.0\n  # Debian oldstable still packages CMake 3.0.2\n  function(pkg_get_variable _output_name _pkg _name)\n    execute_process(COMMAND ${PKG_CONFIG_EXECUTABLE} --variable=${_name} ${_pkg}\n                    OUTPUT_VARIABLE _pkg_result\n                    OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n    set(\"${_output_name}\" \"${_pkg_result}\" CACHE STRING \"pkg-config variable ${_name} of ${_pkg}\")\n  endfunction()\n\n  pkg_get_variable(BASH_COMPLETION_PREFIX bash-completion prefix)\n  if(BASH_COMPLETION_PREFIX)\n    set(BASH_COMPLETION_FOUND TRUE)\n  endif()\n\nelse()\n\n  include(FindPkgConfig)\n  pkg_search_module(BASH_COMPLETION bash-completion)\n\nendif()\n\nif(APPLE)\n  find_program(BREW_INSTALLED BREW)\n\n  if(BREW_INSTALLED)  \n    function(get_brew_packageconfig_path _package_name _output_variable)\n      execute_process(COMMAND brew --cellar ${_package_name}\n                      RESULT_VARIABLE _result_var_cellar\n                      OUTPUT_VARIABLE _output_variable_cellar\n                      OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n      if(_result_var_cellar AND NOT STATUS EQUAL 0)\n        message(STATUS \"Unable to obtain homebrew cellar location for package ${_package_name}. Error: ${_result_var_cellar}\")\n      else()\n        execute_process(COMMAND find \"${_output_variable_cellar}/\" -type d -name pkgconfig\n                        COMMAND tr -d '\\n'\n                        COMMAND tr -s '/'\n                        RESULT_VARIABLE _brew_pkgconfig_c\n                        OUTPUT_VARIABLE _brew_pkgconfig_cellar\n                        OUTPUT_STRIP_TRAILING_WHITESPACE)\n      endif()\n\n      execute_process(COMMAND brew --prefix ${_package_name}\n                      RESULT_VARIABLE _result_var_prefix\n                      OUTPUT_VARIABLE _output_variable_prefix\n                      OUTPUT_STRIP_TRAILING_WHITESPACE)\n      \n      if(_result_var_prefix AND NOT STATUS EQUAL 0)\n        message(STATUS \"Unable to obtain homebrew prefix location for package ${_package_name}. Error: ${_result_var_cellar}\")\n      else()\n        execute_process(COMMAND find \"${_output_variable_prefix}/\" -type d -name pkgconfig\n                        COMMAND tr -d '\\n'\n                        COMMAND tr -s '/'\n                        RESULT_VARIABLE _brew_pkgconfig_p\n                        OUTPUT_VARIABLE _brew_pkgconfig_prefix\n                        OUTPUT_STRIP_TRAILING_WHITESPACE)\n      endif()\n\n      set(\"${_output_variable}\" \"${_brew_pkgconfig_cellar}:${_brew_pkgconfig_prefix}\" CACHE STRING \"pkg-config homebrew locations for ${_package_name}\")\n\n    endfunction()\n\n    # Get pkg-config paths for curl/openssl installed via homebrew\n    get_brew_packageconfig_path(\"curl\" BREW_CURL)\n    get_brew_packageconfig_path(\"openssl\" BREW_OPENSSL)\n\n    set(ENV{PKG_CONFIG_PATH} \"$ENV{PKG_CONFIG_PATH}/usr/local/opt/curl/lib/pkgconfig:/usr/local/opt/openssl:${BREW_CURL}:${BREW_OPENSSL}\")\n    message(STATUS \"PKG_CONFIG_PATH: $ENV{PKG_CONFIG_PATH}\")\n  else()\n    set(ENV{PKG_CONFIG_PATH} \"$ENV{PKG_CONFIG_PATH}:/usr/local/opt/curl/lib/pkgconfig:/usr/local/opt/openssl\")\n  endif()\n\nendif()\n\nfind_package(LibXml2 REQUIRED)\ninclude_directories(${LIBXML2_INCLUDE_DIR})\n\nfind_package(OpenSSL REQUIRED)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nfind_package(CURL REQUIRED)\ninclude_directories(${CURL_INCLUDE_DIR})\n\nset(PROJECT_NAME lpass)\n\nfile(GLOB PROJECT_HEADERS *.h version.h)\nfile(GLOB PROJECT_SOURCES *.c)\n\nset(PROJECT_DEFINITIONS \"_GNU_SOURCE\")\n\nset(PROJECT_FLAGS \"-std=gnu99 -pedantic -Wall -Wextra -Wno-language-extension-token\")\nif(APPLE)\n  set(PROJECT_FLAGS \"${PROJECT_FLAGS} -Wno-deprecated-declarations\")\nendif()\n\nexecute_process(COMMAND ./LASTPASS-VERSION-GEN\n\tWORKING_DIRECTORY ${CMAKE_SOURCE_DIR})\n\n# Main lpass executable\nadd_executable(${PROJECT_NAME} ${PROJECT_HEADERS} ${PROJECT_SOURCES})\nset_target_properties(${PROJECT_NAME} PROPERTIES\n  C_STANDARD 99\n  COMPILE_FLAGS ${PROJECT_FLAGS}\n  COMPILE_DEFINITIONS ${PROJECT_DEFINITIONS}\n)\n\ntarget_link_libraries(${PROJECT_NAME} ${LIBXML2_LIBRARIES} ${OPENSSL_LIBRARIES} ${CURL_LIBRARIES})\nif (CMAKE_SYSTEM_NAME MATCHES \"OpenBSD\")\n  target_link_libraries(${PROJECT_NAME} \"-lkvm\")\nendif (CMAKE_SYSTEM_NAME MATCHES \"OpenBSD\")\n\nadd_custom_command(OUTPUT lpass.1 DEPENDS ${CMAKE_SOURCE_DIR}/lpass.1.txt\n        COMMAND a2x -D ./ --no-xmllint -f manpage ${CMAKE_SOURCE_DIR}/lpass.1.txt)\nadd_custom_command(OUTPUT lpass.1.html DEPENDS ${CMAKE_SOURCE_DIR}/lpass.1.txt\n        COMMAND asciidoc -b html5 -a data-uri -a icons -a toc2 -o lpass.1.html ${CMAKE_SOURCE_DIR}/lpass.1.txt)\n\ninstall(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION bin)\n\nif(BASH_COMPLETION_FOUND)\n  pkg_get_variable(BASH_COMPLETION_COMPLETIONSDIR bash-completion completionsdir)\n\n  # Fix GH-478\n  if(NOT \"${BASH_COMPLETION_PREFIX}\" STREQUAL \"${CMAKE_INSTALL_PREFIX}\")\n    string(REGEX REPLACE \"^${BASH_COMPLETION_PREFIX}\" \"${CMAKE_INSTALL_PREFIX}\" COMP_DIR ${BASH_COMPLETION_COMPLETIONSDIR})\n    set(BASH_COMPLETION_COMPLETIONSDIR ${COMP_DIR})\n    unset(COMP_DIR)\n  endif()\n\n  install(FILES contrib/lpass_bash_completion DESTINATION ${BASH_COMPLETION_COMPLETIONSDIR} RENAME lpass)\nendif()\n\n# Test lpass executable with mock server, link against test versions first\nfile(GLOB LPTEST_SOURCES test/*.c *.c)\nadd_executable(lpass-test EXCLUDE_FROM_ALL ${PROJECT_HEADERS} ${LPTEST_SOURCES})\nset_target_properties(lpass-test PROPERTIES\n  C_STANDARD 99\n  COMPILE_FLAGS \"${PROJECT_FLAGS} -DTEST_BUILD\"\n  COMPILE_DEFINITIONS ${PROJECT_DEFINITIONS}\n)\ntarget_link_libraries(lpass-test ${LIBXML2_LIBRARIES} ${OPENSSL_LIBRARIES} ${CURL_LIBRARIES})\nif (CMAKE_SYSTEM_NAME MATCHES \"OpenBSD\")\n  target_link_libraries(lpass-test \"-lkvm\")\nendif (CMAKE_SYSTEM_NAME MATCHES \"OpenBSD\")\nenable_testing()\nadd_test(test_login ${CMAKE_SOURCE_DIR}/test/tests test_login)\nadd_test(test_login_wrong_pw_should_fail ${CMAKE_SOURCE_DIR}/test/tests test_login_wrong_pw_should_fail)\nadd_test(test_add_account ${CMAKE_SOURCE_DIR}/test/tests test_add_account)\nadd_test(test_add_note ${CMAKE_SOURCE_DIR}/test/tests test_add_note)\nadd_test(test_add_note_with_field ${CMAKE_SOURCE_DIR}/test/tests test_add_note_with_field)\nadd_test(test_add_site_note ${CMAKE_SOURCE_DIR}/test/tests test_add_site_note)\nadd_test(test_add_ssn_name ${CMAKE_SOURCE_DIR}/test/tests test_add_ssn_name)\nadd_test(test_add_ssh_key ${CMAKE_SOURCE_DIR}/test/tests test_add_ssh_key)\nadd_test(test_edit_ssh_key ${CMAKE_SOURCE_DIR}/test/tests test_edit_ssh_key)\nadd_test(test_edit_username ${CMAKE_SOURCE_DIR}/test/tests test_edit_username)\nadd_test(test_edit_field ${CMAKE_SOURCE_DIR}/test/tests test_edit_field)\nadd_test(test_edit_reprompt ${CMAKE_SOURCE_DIR}/test/tests test_edit_reprompt)\nadd_test(test_duplicate ${CMAKE_SOURCE_DIR}/test/tests test_duplicate)\nadd_test(test_generate ${CMAKE_SOURCE_DIR}/test/tests test_generate)\nadd_test(test_show ${CMAKE_SOURCE_DIR}/test/tests test_show)\nadd_test(test_show_json ${CMAKE_SOURCE_DIR}/test/tests test_show_json)\nadd_test(test_show_note ${CMAKE_SOURCE_DIR}/test/tests test_show_note)\nadd_test(test_show_reprompt ${CMAKE_SOURCE_DIR}/test/tests test_show_reprompt)\nadd_test(test_ls ${CMAKE_SOURCE_DIR}/test/tests test_ls)\nadd_test(test_export ${CMAKE_SOURCE_DIR}/test/tests test_export)\nadd_test(test_export_extended ${CMAKE_SOURCE_DIR}/test/tests test_export_extended)\n\nadd_custom_target(doc-man DEPENDS lpass.1)\nadd_custom_target(doc-html DEPENDS lpass.1.html)\n# See https://cmake.org/pipermail/cmake/2009-January/026520.html\nadd_custom_target(install-doc COMMAND ${CMAKE_COMMAND} -DMANDIR=${CMAKE_INSTALL_FULL_MANDIR} -P ${CMAKE_SOURCE_DIR}/cmake_extras/install_doc.cmake DEPENDS doc-man)\nadd_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -DPROJECT_NAME=${PROJECT_NAME} -DMANDIR=${CMAKE_INSTALL_FULL_MANDIR} -P ${CMAKE_SOURCE_DIR}/cmake_extras/uninstall.cmake)\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 2.2021484375,
          "content": "\nContributions are welcome!  Please open a pull request at github:\n\n    https://github.com/lastpass/lastpass-cli\n\nThe project is licensed under the GPL version 2 or later with an\nexception for linking with OpenSSL (see COPYING and LICENSE.OpenSSL),\nand requires acceptance of the Developer's Certificate of Origin for\ncontributions (see below).\n\nTo indicate your acceptance of Developer's Certificate of Origin 1.1\nterms, please add the following line to the end of the commit message\nfor each contribution you make to the project:\n\nSigned-off-by: Your Name <your@email.example.org>\n\nusing your real name. Pseudonyms or anonymous contributions cannot\nunfortunately be accepted.\n\n---------------------------------------------------------------------------\n\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n\n---------------------------------------------------------------------------\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "LASTPASS-VERSION-GEN",
          "type": "blob",
          "size": 1.005859375,
          "content": "#!/bin/sh\n\n# This file has been adopted from the git project\n# You can find the original at https://github.com/git/git/blob/master/GIT-VERSION-GEN\n\nLPVF=version.h\nDEF_VER=v1.6.1.GIT\n\nLF='\n'\n\n# First see if there is a version file (included in release tarballs),\n# then try git-describe, then default.\nif test -f version\nthen\n\tVN=$(cat version) || VN=\"$DEF_VER\"\nelif test -d ${GIT_DIR:-.git} -o -f .git &&\n\tVN=$(git describe --match \"v[0-9]*\" HEAD 2>/dev/null) &&\n\tcase \"$VN\" in\n\t*$LF*) (exit 1) ;;\n\tv[0-9]*)\n\t\tgit update-index -q --refresh\n\t\ttest -z \"$(git diff-index --name-only HEAD --)\" ||\n\t\tVN=\"$VN-dirty\" ;;\n\tesac\nthen\n\tVN=$(echo \"$VN\" | sed -e 's/-/./g');\nelse\n\tVN=\"$DEF_VER\"\nfi\n\nVN=$(expr \"$VN\" : v*'\\(.*\\)')\n\nif test -r $LPVF\nthen\n\tVC=$(sed -ne 's/^#define LASTPASS_CLI_VERSION \"\\(.*\\)\"/\\1/p' <$LPVF)\nelse\n\tVC=unset\nfi\ntest \"$VN\" = \"$VC\" || {\n\techo >&2 \"LASTPASS_CLI_VERSION  =$VN\"\n\techo \"#define LASTPASS_CLI_VERSION \\\"$VN\\\"\" >$LPVF\n\techo \"#define LASTPASS_CLI_USERAGENT \\\"LastPass-CLI/\\\" LASTPASS_CLI_VERSION\" >>$LPVF\n}\n"
        },
        {
          "name": "LICENSE.OpenSSL",
          "type": "blob",
          "size": 6.806640625,
          "content": "Certain source files in this program permit linking with the OpenSSL\nlibrary (http://www.openssl.org), which otherwise wouldn't be allowed\nunder the GPL.  For purposes of identifying OpenSSL, most source files\ngiving this permission limit it to versions of OpenSSL having a license\nidentical to that listed in this file (LICENSE.OpenSSL).  It is not\nnecessary for the copyright years to match between this file and the\nOpenSSL version in question.  However, note that because this file is\nan extension of the license statements of these source files, this file\nmay not be changed except with permission from all copyright holders\nof source files in this program which reference this file.\n\n\n  LICENSE ISSUES\n  ==============\n\n  The OpenSSL toolkit stays under a dual license, i.e. both the conditions of\n  the OpenSSL License and the original SSLeay license apply to the toolkit.\n  See below for the actual license texts. Actually both licenses are BSD-style\n  Open Source licenses. In case of any license issues related to OpenSSL\n  please contact openssl-core@openssl.org.\n\n  OpenSSL License\n  ---------------\n\n/* ====================================================================\n * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    openssl-core@openssl.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n Original SSLeay License\n -----------------------\n\n/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n * \n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n * \n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the routines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from \n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n * \n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * \n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7734375,
          "content": "PREFIX ?= /usr\nMANDIR ?= $(PREFIX)/share/man\nBUILDDIR=build\nCMAKEMAKE=$(BUILDDIR)/Makefile\nCMAKEOPTS=-DCMAKE_INSTALL_PREFIX:PATH=$(PREFIX) -DCMAKE_INSTALL_MANDIR:PATH=$(MANDIR)\n\nall: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) all\n\nclean: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) clean\n\t$(RM) -r $(BUILDDIR)\n\ndoc-man: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) doc-man\n\ndoc-html: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) doc-html\n\ninstall-doc: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) install-doc\n\ninstall: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) install\n\ntest: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) lpass-test && $(MAKE) -C $(BUILDDIR) test\n\nuninstall: $(CMAKEMAKE)\n\t$(MAKE) -C $(BUILDDIR) uninstall\n\n$(CMAKEMAKE):\n\tmkdir -p $(BUILDDIR) && cd $(BUILDDIR) && cmake $(CMAKEOPTS) ..\n\n.PHONY: all doc-man clean $(CMAKEMAKE)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.205078125,
          "content": "# LastPass CLI\n#### (c) 2014-2019 LastPass.\n\nCommand line interface to [LastPass.com](https://lastpass.com/).\n\n## Operating System Support\n\n`lpass` is designed to run on GNU/Linux, Cygwin and Mac OS X.\n\n## Dependencies\n\n* [LibreSSL](http://www.libressl.org/) or [OpenSSL](https://www.openssl.org/)\n* [libcurl](http://curl.haxx.se/)\n* [libxml2](http://xmlsoft.org/)\n* [pinentry](https://www.gnupg.org/related_software/pinentry/index.en.html) (optional)\n* [AsciiDoc](http://www.methods.co.nz/asciidoc/) (build-time documentation generation only)\n* [xclip](http://sourceforge.net/projects/xclip/), [xsel](http://www.vergenet.net/~conrad/software/xsel/), [pbcopy](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html), or [putclip from cygutils-extra](https://cygwin.com/cgi-bin2/package-grep.cgi?grep=cygutils-extra) for clipboard support (optional)\n\n### Installing on Linux\n#### Arch\n* A binary package is available from the community repository, use pacman to simple install lastpass-cli.\n* Can be build from source with the \"lastpass-cli-git\" *[Arch User Repository (AUR)](https://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=lastpass-cli).\nInformation about installing packages from the AUR [can be found on the Arch wiki](https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_packages).\n\n```\n# from community repository\nsudo pacman -S lastpass-cli\n# from AUR repository\npacker -S lastpass-cli-git\n```\n\n#### Fedora\n\n* Packages are available in Fedora 22 and later.\n\n```\nsudo dnf install lastpass-cli\n```\n\n#### Red Hat/Centos\n\n* Packages are available in [EPEL](https://fedoraproject.org/wiki/EPEL) for RHEL/CentOS 7 and later.\n\n```\nsudo yum install lastpass-cli\n```\n\n* For older versions: Install the needed build dependencies, and then follow instructions in\n  the 'Building' section.\n\n```\nsudo yum install openssl libcurl libxml2 pinentry xclip openssl-devel libxml2-devel libcurl-devel gcc gcc-c++ make cmake\n```\n\n\n#### Debian/Ubuntu\n\n* Install the needed build dependencies, and then follow instructions in\n  the 'Building' section.\n\n* For Ubuntu 16.04 (xenial)\n\n```\napt-get --no-install-recommends -yqq install \\\n  bash-completion \\\n  build-essential \\\n  cmake \\\n  libcurl3  \\\n  libcurl3-openssl-dev  \\\n  libssl1.0.0 \\\n  libssl-dev \\\n  libxml2 \\\n  libxml2-dev  \\\n  pkg-config \\\n  ca-certificates \\\n  xclip\n```\n\n* For Debian (stable/oldstable) and other Ubuntus < 18.04\n\n```\napt-get --no-install-recommends -yqq install \\\n  bash-completion \\\n  build-essential \\\n  cmake \\\n  libcurl3  \\\n  libcurl3-openssl-dev  \\\n  libssl1.0 \\\n  libssl1.0-dev \\\n  libxml2 \\\n  libxml2-dev  \\\n  pkg-config \\\n  ca-certificates \\\n  xclip\n```\n\n* For Debian (testing/experimental) and Ubuntu >= 18.04\n\n```\napt-get --no-install-recommends -yqq install \\\n  bash-completion \\\n  build-essential \\\n  cmake \\\n  libcurl4  \\\n  libcurl4-openssl-dev  \\\n  libssl-dev  \\\n  libxml2 \\\n  libxml2-dev  \\\n  libssl1.1 \\\n  pkg-config \\\n  ca-certificates \\\n  xclip\n```\n\n#### Gentoo\n* Install the package:\n\n```\nsudo emerge lastpass-cli\n```\n\n#### Other Linux Distros\nInstall the packages listed in the Dependencies section of this document,\nand then follow instructions in the 'Building' section.\n\n### Installing on OS X\n\n#### With [Homebrew](http://brew.sh/) (easiest)\n* Install Homebrew, if necessary.\n* Update Homebrew's local formula cache:\n\n```\nbrew update\n```\n\n* Install the lastpass-cli formula:\n\n```\nbrew install lastpass-cli\n```\n\n#### With [MacPorts](https://www.macports.org/)\n* [Install MacPorts](https://www.macports.org/install.php), if necessary.\n* Update MacPorts' local ports tree:\n\n```\nsudo port selfupdate\n```\n\n* Install the lastpass-cli port:\n\n```\nsudo port install lastpass-cli\n```\n\n* Optionally install the documentation:\n\n```\nsudo port install lastpass-cli-doc\n```\n\n#### Manually\nInstall the packages listed in the Dependencies section of this document,\nand then follow instructions in the 'Building' section.\n\n### Installing on FreeBSD\n* Install the binary package:\n\n```\nsudo pkg install security/lastpass-cli\n```\n\n* Or build the port yourself:\n\n```\nsudo make -C /usr/ports/security/lastpass-cli all install clean\n```\n\n### Installing on Cygwin\n* Install [apt-cyg](https://github.com/transcode-open/apt-cyg)\n* Using apt-cyg, install the needed build dependencies, and then follow\n  instructions in the 'Building' section.\n\n```\napt-cyg install wget make cmake gcc-core gcc-g++ openssl-devel libcurl-devel libxml2-devel libiconv-devel cygutils-extra\n```\n\n## Building\n\n    $ make\n\nUnder the covers, make invokes cmake in a build directory; you may also use\ncmake directly if you need more control over the build process.\n\n## Installing\n\n    $ sudo make install\n\nThese environment variables can be passed to make to do the right thing: `PREFIX`, `DESTDIR`, `BINDIR`, `LIBDIR`, `MANDIR`.\n\n## Running\n\nIf you've installed it:\n\n    $ lpass\n\nOtherwise, from the build directory:\n\n    $ ./lpass\n\n## Documentation\n\nInstall `asciidoc` and `xsltproc` if they are not already installed.\n\n    $ sudo apt-get install asciidoc xsltproc\n\nThe `install-doc` target builds and installs the documentation.\n\n    $ sudo make install-doc\n\nOnce installed,\n\n    $ man lpass\n\nYou can view the full documentation in the manpage, `man lpass` or [view it online](https://lastpass.github.io/lastpass-cli/lpass.1.html).\n"
        },
        {
          "name": "agent.c",
          "type": "blob",
          "size": 8.6611328125,
          "content": "/*\n * agent for caching decryption key\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n\n#include \"agent.h\"\n#include \"config.h\"\n#include \"util.h\"\n#include \"password.h\"\n#include \"terminal.h\"\n#include \"process.h\"\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/mman.h>\n#include <errno.h>\n#include <signal.h>\n#if (defined(__unix__) || defined(unix)) && !defined(USG)\n#include <sys/param.h>\n#endif\n\n#if !defined(SUN_LEN)\n#define SUN_LEN(su) \\\n        (sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))\n#endif\n\n#if !defined(__linux__) && !defined(__CYGWIN__)\n#define SOCKET_SEND_PID 1\nstruct ucred {\n\tpid_t pid;\n\tuid_t uid;\n\tgid_t gid;\n};\n#endif\n\n#define AGENT_VERIFICATION_STRING \"`lpass` was written by LastPass.\\n\"\n\nstatic inline char *agent_socket_path(void)\n{\n\treturn config_path(\"agent.sock\");\n}\n\nbool agent_load_key(unsigned char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *iterationbuf = NULL;\n\t_cleanup_free_ char *verify = NULL;\n\t_cleanup_free_ char *username = NULL;\n\t_cleanup_free_ char *password = NULL;\n\tint iterations;\n\n\titerationbuf = config_read_string(\"iterations\");\n\tusername = config_read_string(\"username\");\n\tif (!iterationbuf || !username || !config_exists(\"verify\"))\n\t\treturn false;\n\titerations = strtoul(iterationbuf, NULL, 10);\n\tif (iterations <= 0)\n\t\treturn false;\n\n\tfor (;;) {\n\t\tfree(password);\n\t\tpassword = password_prompt(\"Master Password\", password ? \"Incorrect master password; please try again.\" : NULL, \"Please enter the LastPass master password for <%s>.\", username);\n\t\tif (!password)\n\t\t\treturn false;\n\t\tkdf_decryption_key(username, password, iterations, key);\n\n\t\t/* no longer need password contents, zero it */\n\t\tsecure_clear_str(password);\n\n\t\tverify = config_read_encrypted_string(\"verify\", key);\n\t\tif (verify && !strcmp(verify, AGENT_VERIFICATION_STRING))\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n_noreturn_ static void agent_cleanup(int signal)\n{\n\tUNUSED(signal);\n\tchar *path = agent_socket_path();\n\tunlink(path);\n\tfree(path);\n\t_exit(EXIT_SUCCESS);\n}\n\n#if defined(__linux__) || defined(__CYGWIN__)\nstatic int agent_socket_get_cred(int fd, struct ucred *cred)\n{\n\tsocklen_t credlen = sizeof(struct ucred);\n\treturn getsockopt(fd, SOL_SOCKET, SO_PEERCRED, cred, &credlen);\n}\n#elif defined(__APPLE__) && defined(__MACH__) || defined(BSD)\nstatic int agent_socket_get_cred(int fd, struct ucred *cred)\n{\n\tif (getpeereid(fd, &cred->uid, &cred->gid) < 0)\n\t\treturn -1;\n\n\tif (read(fd, &cred->pid, sizeof(cred->pid)) != sizeof(cred->pid))\n\t\treturn -1;\n\n\treturn 0;\n}\n#endif\n\nvoid _assert_socket_sun_path(struct sockaddr_un *sa, char *path)\n{\n\tif (strlen(path) >= sizeof(sa->sun_path)) {\n\t\tdie(\"Path too large for agent control socket.\");\n\t}\n}\n\nint _setup_agent_socket(struct sockaddr_un *sa, char *path)\n{\n\tint fd;\n\n\t_assert_socket_sun_path(sa, path);\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->sun_family = AF_UNIX;\n\tstrlcpy(sa->sun_path, path, sizeof(sa->sun_path));\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\treturn fd;\n}\n\nstatic void agent_run(unsigned const char key[KDF_HASH_LEN])\n{\n\tchar *agent_timeout_str;\n\tunsigned int agent_timeout;\n\tstruct sockaddr_un sa, listensa;\n\tstruct ucred cred;\n\tint fd, listenfd;\n\tsocklen_t len;\n\n\tsignal(SIGHUP, agent_cleanup);\n\tsignal(SIGINT, agent_cleanup);\n\tsignal(SIGQUIT, agent_cleanup);\n\tsignal(SIGTERM, agent_cleanup);\n\tsignal(SIGALRM, agent_cleanup);\n\n\tagent_timeout_str = getenv(\"LPASS_AGENT_TIMEOUT\");\n\tagent_timeout = 60 * 60; /* One hour by default. */\n\tif (agent_timeout_str && strlen(agent_timeout_str))\n\t\tagent_timeout = strtoul(agent_timeout_str, NULL, 10);\n\tif (agent_timeout)\n\t\talarm(agent_timeout);\n\n\t_cleanup_free_ char *path = agent_socket_path();\n\tfd = _setup_agent_socket(&sa, path);\n\n\tunlink(path);\n\n\tif (bind(fd, (struct sockaddr *)&sa, SUN_LEN(&sa)) < 0 || listen(fd, 16) < 0) {\n\t\tlistenfd = errno;\n\t\tclose(fd);\n\t\tunlink(path);\n\t\terrno = listenfd;\n\t\tdie_errno(\"bind|listen\");\n\t}\n\n\tfor (len = sizeof(listensa); (listenfd = accept(fd, (struct sockaddr *)&listensa, &len)) > 0; len = sizeof(listensa)) {\n\t\tif (agent_socket_get_cred(listenfd, &cred) < 0) {\n\t\t\tclose(listenfd);\n\t\t\tcontinue;\n\t\t}\n\t\tif (cred.uid != getuid() || cred.gid != getgid() || !process_is_same_executable(cred.pid)) {\n\t\t\tclose(listenfd);\n\t\t\tcontinue;\n\t\t}\n\n#if SOCKET_SEND_PID == 1\n\t\tpid_t pid = getpid();\n\t\tIGNORE_RESULT(write(listenfd, &pid, sizeof(pid)));\n#endif\n\t\tIGNORE_RESULT(write(listenfd, key, KDF_HASH_LEN));\n\t\tclose(listenfd);\n\t}\n\n\tlistenfd = errno;\n\tclose(fd);\n\tunlink(path);\n\terrno = listenfd;\n\tdie_errno(\"accept\");\n}\n\nvoid agent_kill(void)\n{\n\tstruct sockaddr_un sa;\n\tstruct ucred cred;\n\tint fd;\n\n\t_cleanup_free_ char *path = agent_socket_path();\n\tfd = _setup_agent_socket(&sa, path);\n\n\tif (connect(fd, (struct sockaddr *)&sa, SUN_LEN(&sa)) < 0)\n\t\tgoto out;\n\n#if SOCKET_SEND_PID == 1\n\tpid_t pid = getpid();\n\tif (write(fd, &pid, sizeof(pid)) != sizeof(pid))\n\t\tgoto out;\n#endif\n\n\tif (agent_socket_get_cred(fd, &cred) < 0)\n\t\tgoto out;\n\n\tkill(cred.pid, SIGTERM);\n\nout:\n\tclose(fd);\n}\n\nbool agent_ask(unsigned char key[KDF_HASH_LEN])\n{\n\tstruct sockaddr_un sa;\n\tint fd;\n\tbool ret = false;\n\n\t_cleanup_free_ char *path = agent_socket_path();\n\tfd = _setup_agent_socket(&sa, path);\n\n\tret = connect(fd, (struct sockaddr *)&sa, SUN_LEN(&sa)) >= 0;\n\tif (!ret)\n\t\tgoto out;\n\n#if SOCKET_SEND_PID == 1\n\tpid_t pid = getpid();\n\tret = write(fd, &pid, sizeof(pid)) == sizeof(pid);\n\tif (!ret)\n\t\tgoto out;\n\tret = read(fd, &pid, sizeof(pid)) == sizeof(pid);\n\tif (!ret)\n\t\tgoto out;\n#endif\n\tret = read(fd, key, KDF_HASH_LEN) == KDF_HASH_LEN;\n\tif (!ret)\n\t\tgoto out;\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void agent_start(unsigned const char key[KDF_HASH_LEN])\n{\n\tpid_t child;\n\n\tagent_kill();\n\n\tif (config_exists(\"plaintext_key\"))\n\t\treturn;\n\n\tchar *disable_str = getenv(\"LPASS_AGENT_DISABLE\");\n\tif (disable_str && !strcmp(disable_str, \"1\")) {\n\t\treturn;\n\t}\n\n\tchild = fork();\n\tif (child < 0)\n\t\tdie_errno(\"fork(agent)\");\n\n\tif (child == 0) {\n\t\tint null = open(\"/dev/null\", 0);\n\t\tif (null < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\t\tdup2(null, 0);\n\t\tdup2(null, 1);\n\t\tdup2(null, 2);\n\t\tclose(null);\n\t\tsetsid();\n\t\tif (chdir(\"/\") < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\t\tprocess_disable_ptrace();\n\t\tprocess_set_name(\"lpass [agent]\");\n\n\t\tagent_run(key);\n\t\t_exit(EXIT_FAILURE);\n\t}\n}\n\nbool agent_get_decryption_key(unsigned char key[KDF_HASH_LEN])\n{\n\tif (config_exists(\"plaintext_key\")) {\n\t\t_cleanup_free_ unsigned char *key_buffer = NULL;\n\t\tif (config_read_buffer(\"plaintext_key\", &key_buffer) == KDF_HASH_LEN) {\n\t\t\t_cleanup_free_ char *verify = config_read_encrypted_string(\"verify\", (unsigned char *)key_buffer);\n\t\t\tif (!verify || strcmp(verify, AGENT_VERIFICATION_STRING))\n\t\t\t\tgoto badkey;\n\t\t\tmemcpy(key, key_buffer, KDF_HASH_LEN);\n\t\t\tsecure_clear(key_buffer, KDF_HASH_LEN);\n\t\t\tmlock(key, KDF_HASH_LEN);\n\t\t\treturn true;\n\t\t}\n\t\tbadkey: config_unlink(\"plaintext_key\");\n\t}\n\tif (!agent_ask(key)) {\n\t\tif (!agent_load_key(key))\n\t\t\treturn false;\n\t\tagent_start(key);\n\t}\n\tmlock(key, KDF_HASH_LEN);\n\treturn true;\n}\n\nvoid agent_save(const char *username, int iterations, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *iterations_str = xultostr(iterations);\n\tconfig_write_string(\"iterations\", iterations_str);\n\tconfig_write_string(\"username\", username);\n\tconfig_write_encrypted_string(\"verify\", AGENT_VERIFICATION_STRING, key);\n\tagent_start(key);\n}\n"
        },
        {
          "name": "agent.h",
          "type": "blob",
          "size": 0.35546875,
          "content": "#ifndef AGENT_H\n#define AGENT_H\n\n#include \"kdf.h\"\n#include <stdbool.h>\n\nbool agent_get_decryption_key(unsigned char key[KDF_HASH_LEN]);\nvoid agent_save(const char *username, int iterations, unsigned const char key[KDF_HASH_LEN]);\nvoid agent_kill(void);\nbool agent_ask(unsigned char key[KDF_HASH_LEN]);\nbool agent_load_key(unsigned char key[KDF_HASH_LEN]);\n\n#endif\n"
        },
        {
          "name": "blob.c",
          "type": "blob",
          "size": 34.8974609375,
          "content": "/*\n * encrypted vault parsing\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"blob.h\"\n#include \"config.h\"\n#include \"endpoints.h\"\n#include \"cipher.h\"\n#include \"util.h\"\n#include \"upload-queue.h\"\n#include \"version.h\"\n#include <time.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#if defined(__APPLE__) && defined(__MACH__)\n#include <libkern/OSByteOrder.h>\n#define htobe32(x) OSSwapHostToBigInt32(x)\n#define be32toh(x) OSSwapBigToHostInt32(x)\n#else\n# if (defined(__unix__) || defined(unix)) && !defined(USG)\n#  include <sys/param.h>\n# endif\n# if defined(BSD)\n#  include <sys/endian.h>\n# else\n#  include <endian.h>\n# endif\n#endif\n\nstruct app *account_to_app(const struct account *account)\n{\n\treturn container_of(account, struct app, account);\n}\n\nvoid share_free(struct share *share)\n{\n\tif (!share)\n\t\treturn;\n\n\tfree(share->name);\n\tfree(share->id);\n\tfree(share->chunk);\n\tfree(share);\n}\n\nvoid field_free(struct field *field)\n{\n\tif (!field)\n\t\treturn;\n\n\tfree(field->name);\n\tfree(field->value);\n\tfree(field->value_encrypted);\n\tfree(field->type);\n\tfree(field);\n}\n\nvoid account_free_contents(struct account *account)\n{\n\tstruct field *field, *tmp;\n\n\tfree(account->id);\n\tfree(account->name);\n\tfree(account->group);\n\tfree(account->fullname);\n\tfree(account->url);\n\tfree(account->username);\n\tfree(account->password);\n\tfree(account->note);\n\tfree(account->name_encrypted);\n\tfree(account->group_encrypted);\n\tfree(account->url_encrypted);\n\tfree(account->username_encrypted);\n\tfree(account->password_encrypted);\n\tfree(account->note_encrypted);\n\tfree(account->attachkey);\n\tfree(account->attachkey_encrypted);\n\n\tlist_for_each_entry_safe(field, tmp, &account->field_head, list) {\n\t\tfield_free(field);\n\t}\n}\n\nvoid app_free(struct app *app)\n{\n\taccount_free_contents(&app->account);\n\tfree(app->appname);\n\tfree(app->extra);\n\tfree(app->extra_encrypted);\n\tfree(app->wintitle);\n\tfree(app->wininfo);\n\tfree(app->exeversion);\n\tfree(app->warnversion);\n\tfree(app->exehash);\n}\n\nbool account_is_group(struct account *account)\n{\n\treturn !strcmp(account->url, \"http://group\");\n}\n\nstatic\nbool account_is_secure_note(const struct account *account)\n{\n\treturn !strcmp(account->url, \"http://sn\");\n}\n\nstruct app *new_app()\n{\n\tstruct app *app = new0(struct app, 1);\n\tstruct account *account = &app->account;\n\n\tapp->appname = xstrdup(\"\");\n\tapp->extra = xstrdup(\"\");\n\tapp->extra_encrypted = xstrdup(\"\");\n\n\tINIT_LIST_HEAD(&account->field_head);\n\tINIT_LIST_HEAD(&account->attach_head);\n\taccount->is_app = true;\n\n\treturn app;\n}\n\nstruct account *new_account()\n{\n\tstruct account *account = new0(struct account, 1);\n\tINIT_LIST_HEAD(&account->field_head);\n\tINIT_LIST_HEAD(&account->attach_head);\n\treturn account;\n}\n\nvoid account_free(struct account *account)\n{\n\tif (!account)\n\t\treturn;\n\n\tif (account->is_app) {\n\t\tapp_free(account_to_app(account));\n\t\treturn;\n\t}\n\n\taccount_free_contents(account);\n\tfree(account);\n}\n\nvoid blob_free(struct blob *blob)\n{\n\tif (!blob)\n\t\treturn;\n\n\tstruct account *account, *tmp;\n\tstruct share *share, *tmp_share;\n\n\tlist_for_each_entry_safe(account, tmp, &blob->account_head, list)\n\t\taccount_free(account);\n\n\tlist_for_each_entry_safe(share, tmp_share, &blob->share_head, list)\n\t\tshare_free(share);\n\n\tfree(blob);\n}\n\nstruct blob_pos {\n\tconst unsigned char *data;\n\tsize_t len;\n};\n\nstruct chunk {\n\tchar name[4 + 1];\n\tconst unsigned char *data;\n\tsize_t len;\n};\n\nstruct item {\n\tconst unsigned char *data;\n\tsize_t len;\n};\n\nstatic bool read_chunk(struct blob_pos *blob, struct chunk *chunk)\n{\n\tif (blob->len < 4)\n\t\treturn false;\n\tchunk->name[0] = blob->data[0];\n\tchunk->name[1] = blob->data[1];\n\tchunk->name[2] = blob->data[2];\n\tchunk->name[3] = blob->data[3];\n\tchunk->name[4] = '\\0';\n\tblob->len -= 4;\n\tblob->data += 4;\n\n\tif (blob->len < sizeof(uint32_t))\n\t\treturn false;\n\tchunk->len = be32toh(*((uint32_t *)blob->data));\n\tblob->len -= sizeof(uint32_t);\n\tblob->data += sizeof(uint32_t);\n\n\tif (chunk->len > blob->len)\n\t\treturn false;\n\tchunk->data = blob->data;\n\tblob->data += chunk->len;\n\tblob->len -= chunk->len;\n\n\treturn true;\n\n}\n\nstatic bool read_item(struct chunk *chunk, struct item *item)\n{\n\tif (chunk->len < sizeof(uint32_t))\n\t\treturn false;\n\titem->len = be32toh(*((uint32_t *)chunk->data));\n\tchunk->len -= sizeof(uint32_t);\n\tchunk->data += sizeof(uint32_t);\n\n\tif (item->len > chunk->len)\n\t\treturn false;\n\titem->data = chunk->data;\n\tchunk->data += item->len;\n\tchunk->len -= item->len;\n\n\treturn true;\n}\n\nstatic char *read_hex_string(struct chunk *chunk)\n{\n\tstruct item item;\n\tint result;\n\tchar *str = NULL;\n\n\tif (!read_item(chunk, &item))\n\t\treturn NULL;\n\tif (item.len == 0)\n\t\treturn xstrdup(\"\");\n\n\tresult = hex_to_bytes((char *) item.data, (unsigned char **) &str);\n\tif (result) {\n\t\tfree(str);\n\t\treturn NULL;\n\t}\n\treturn str;\n}\n\nstatic char *read_plain_string(struct chunk *chunk)\n{\n\tstruct item item;\n\n\tif (!read_item(chunk, &item))\n\t\treturn NULL;\n\n\tif (item.len == 0)\n\t\treturn xstrdup(\"\");\n\n\treturn xstrndup((char *) item.data, item.len);\n}\n\nstatic char *read_crypt_string(struct chunk *chunk, const unsigned char key[KDF_HASH_LEN], char **stored_base64)\n{\n\tstruct item item;\n\tchar *ptext;\n\n\tif (!read_item(chunk, &item))\n\t\treturn NULL;\n\tif (stored_base64)\n\t\t*stored_base64 = cipher_base64(item.data, item.len);\n\n\tif (item.len == 0)\n\t\treturn xstrdup(\"\");\n\n\tptext = cipher_aes_decrypt(item.data, item.len, key);\n\tif (!ptext)\n\t\t/* don't fail whole blob if this item cannot be decrypted */\n\t\treturn xstrdup(\"\");\n\n\treturn ptext;\n}\n\nstatic int read_boolean(struct chunk *chunk)\n{\n\tstruct item item;\n\n\tif (!read_item(chunk, &item))\n\t\treturn -1;\n\tif (item.len != 1)\n\t\treturn 0;\n\n\treturn item.data[0] == '1';\n}\n\nstatic bool check_next_entry_encrypted(struct chunk *chunk) {\n\treturn (chunk->data + sizeof(uint32_t))[0] == '!';\n}\n\n#define entry_plain_at(base, var) do { \\\n\tchar *__entry_val__ = read_plain_string(chunk); \\\n\tif (!__entry_val__) \\\n\t\tgoto error; \\\n\tbase->var = __entry_val__; \\\n\t} while (0)\n#define entry_plain(var) entry_plain_at(parsed, var)\n#define entry_hex_at(base, var) do { \\\n\tchar *__entry_val__ = read_hex_string(chunk); \\\n\tif (!__entry_val__) \\\n\t\tgoto error; \\\n\tbase->var = __entry_val__; \\\n\t} while (0)\n#define entry_hex(var) entry_hex_at(parsed, var)\n#define entry_boolean(var) do { \\\n\tint __entry_val__ = read_boolean(chunk); \\\n\tif (__entry_val__ < 0) \\\n\t\tgoto error; \\\n\tparsed->var = __entry_val__; \\\n\t} while (0)\n#define entry_crypt_at(base, var) do { \\\n\tchar *__entry_val__ = read_crypt_string(chunk, key, &base->var##_encrypted); \\\n\tif (!__entry_val__) \\\n\t\tgoto error; \\\n\tbase->var = __entry_val__; \\\n\t} while (0)\n#define entry_crypt(var) entry_crypt_at(parsed, var)\n#define skip(placeholder) do { \\\n\tstruct item skip_item; \\\n\tif (!read_item(chunk, &skip_item)) \\\n\t\tgoto error; \\\n\t} while (0)\n\nstatic struct account *account_parse(struct chunk *chunk, const unsigned char key[KDF_HASH_LEN])\n{\n\tstruct account *parsed = new_account();\n\n\tentry_plain(id);\n\tentry_crypt(name);\n\tentry_crypt(group);\n \tif (check_next_entry_encrypted(chunk))\n\t\tentry_crypt(url);\n\telse\n\t\tentry_hex(url);\n\tentry_crypt(note);\n\tentry_boolean(fav);\n\tskip(sharedfromaid);\n\tentry_crypt(username);\n\tentry_crypt(password);\n\tentry_boolean(pwprotect);\n\tskip(genpw);\n\tskip(sn);\n\tentry_plain(last_touch);\n\tskip(autologin);\n\tskip(never_autofill);\n\tskip(realm_data);\n\tskip(fiid);\n\tskip(custom_js);\n\tskip(submit_id);\n\tskip(captcha_id);\n\tskip(urid);\n\tskip(basic_auth);\n\tskip(method);\n\tskip(action);\n\tskip(groupid);\n\tskip(deleted);\n\tentry_plain(attachkey_encrypted);\n\tentry_boolean(attachpresent);\n\tskip(individualshare);\n\tskip(notetype);\n\tskip(noalert);\n\tentry_plain(last_modified_gmt);\n\tskip(hasbeenshared);\n\tskip(last_pwchange_gmt);\n\tskip(created_gmt);\n\tskip(vulnerable);\n\n\tif (parsed->name[0] == 16)\n\t\tparsed->name[0] = '\\0';\n\tif (parsed->group[0] == 16)\n\t\tparsed->group[0] = '\\0';\n\n\tif (strlen(parsed->attachkey_encrypted)) {\n\t\tparsed->attachkey = cipher_aes_decrypt_base64(\n\t\t\tparsed->attachkey_encrypted, key);\n\t}\n\tif (!parsed->attachkey)\n\t\tparsed->attachkey = xstrdup(\"\");\n\n\t/* use name as 'fullname' only if there's no assigned group */\n\tif (strlen(parsed->group) &&\n\t    (strlen(parsed->name) || account_is_group(parsed)))\n\t\txasprintf(&parsed->fullname, \"%s/%s\", parsed->group, parsed->name);\n\telse\n\t\tparsed->fullname = xstrdup(parsed->name);\n\n\treturn parsed;\n\nerror:\n\taccount_free(parsed);\n\treturn NULL;\n}\n\nstatic struct field *field_parse(struct chunk *chunk, const unsigned char key[KDF_HASH_LEN])\n{\n\tstruct field *parsed = new0(struct field, 1);\n\n\tentry_plain(name);\n\tentry_plain(type);\n\tif (!strcmp(parsed->type, \"email\") || !strcmp(parsed->type, \"tel\") || !strcmp(parsed->type, \"text\") || !strcmp(parsed->type, \"password\") || !strcmp(parsed->type, \"textarea\"))\n\t\tentry_crypt(value);\n\telse\n\t\tentry_plain(value);\n\tentry_boolean(checked);\n\n\treturn parsed;\n\nerror:\n\tfield_free(parsed);\n\treturn NULL;\n}\n\nstatic struct field *app_field_parse(struct chunk *chunk, const unsigned char key[KDF_HASH_LEN])\n{\n\tstruct field *parsed = new0(struct field, 1);\n\n\tentry_plain(name);\n\tentry_crypt(value);\n\tentry_plain(type);\n\n\treturn parsed;\nerror:\n\tfield_free(parsed);\n\treturn NULL;\n}\n\nstatic struct share *share_parse(struct chunk *chunk, const struct private_key *private_key)\n{\n\tstruct share *parsed = new0(struct share, 1);\n\tstruct item item;\n\t_cleanup_free_ unsigned char *ciphertext = NULL;\n\t_cleanup_free_ char *hex_key = NULL;\n\t_cleanup_free_ unsigned char *key = NULL;\n\t_cleanup_free_ char *base64_name = NULL;\n\tsize_t len;\n\n\tif (!private_key)\n\t\tgoto error;\n\n\tif (chunk->len) {\n\t\tparsed->chunk_len = chunk->len;\n\t\tparsed->chunk = xmalloc(chunk->len);\n\t\tmemcpy(parsed->chunk, chunk->data, chunk->len);\n\t}\n\n\tentry_plain(id);\n\n\tif (!read_item(chunk, &item) || item.len == 0 || item.len % 2 != 0)\n\t\tgoto error;\n\thex_to_bytes((char *) item.data, &ciphertext);\n\thex_key = cipher_rsa_decrypt(ciphertext, item.len / 2, private_key);\n\tif (!hex_key)\n\t\tgoto error;\n\tlen = strlen(hex_key);\n\tif (len % 2 != 0)\n\t\tgoto error;\n\tlen /= 2;\n\tif (len != KDF_HASH_LEN)\n\t\tgoto error;\n\thex_to_bytes(hex_key, &key);\n\tmlock(parsed->key, KDF_HASH_LEN);\n\tmemcpy(parsed->key, key, KDF_HASH_LEN);\n\n\tbase64_name = read_plain_string(chunk);\n\tparsed->name = cipher_aes_decrypt_base64(base64_name, parsed->key);\n\tif (!parsed->name)\n\t\tgoto error;\n\n\tentry_boolean(readonly);\n\n\treturn parsed;\n\nerror:\n\tshare_free(parsed);\n\treturn NULL;\n}\n\nstatic struct app *app_parse(struct chunk *chunk, const unsigned char key[KDF_HASH_LEN])\n{\n\tstruct app *app = new_app();\n\tstruct account *parsed = &app->account;\n\n\tentry_plain(id);\n\tentry_hex_at(app, appname);\n\tentry_crypt_at(app, extra);\n\tentry_crypt(name);\n\tentry_crypt(group);\n\tentry_plain(last_touch);\n\tskip(fiid);\n\tentry_boolean(pwprotect);\n\tentry_boolean(fav);\n\tentry_plain_at(app, wintitle);\n\tentry_plain_at(app, wininfo);\n\tentry_plain_at(app, exeversion);\n\tskip(autologin);\n\tentry_plain_at(app, warnversion);\n\tentry_plain_at(app, exehash);\n\n\tparsed->username = xstrdup(\"\");\n\tparsed->password = xstrdup(\"\");\n\tparsed->note = xstrdup(\"\");\n\tparsed->url = xstrdup(\"\");\n\n\tif (strlen(parsed->group) &&\n\t    (strlen(parsed->name) || account_is_group(parsed)))\n\t\txasprintf(&parsed->fullname, \"%s/%s\", parsed->group, parsed->name);\n\telse\n\t\tparsed->fullname = xstrdup(parsed->name);\n\n\treturn app;\nerror:\n\tapp_free(app);\n\treturn NULL;\n}\n\nstatic void attach_free(struct attach *attach)\n{\n\tif (!attach)\n\t\treturn;\n\n\tfree(attach->id);\n\tfree(attach->parent);\n\tfree(attach->mimetype);\n\tfree(attach->storagekey);\n\tfree(attach->size);\n\tfree(attach->filename);\n\tfree(attach);\n}\n\nstatic struct attach *attach_parse(struct chunk *chunk)\n{\n\tstruct attach *parsed = new0(struct attach, 1);\n\n\tentry_plain(id);\n\tentry_plain(parent);\n\tentry_plain(mimetype);\n\tentry_plain(storagekey);\n\tentry_plain(size);\n\tentry_plain(filename);\n\n\treturn parsed;\n\nerror:\n\tattach_free(parsed);\n\treturn NULL;\n}\n\n#undef entry_plain\n#undef entry_plain_at\n#undef entry_hex\n#undef entry_boolean\n#undef entry_crypt\n#undef entry_crypt_at\n#undef skip\n\nstruct blob *blob_parse(const unsigned char *blob, size_t len, const unsigned char key[KDF_HASH_LEN], const struct private_key *private_key)\n{\n\tstruct blob_pos blob_pos = { .data = blob, .len = len };\n\tstruct chunk chunk;\n\tstruct account *account = NULL;\n\tstruct field *field;\n\tstruct share *share, *last_share = NULL;\n\tstruct app *app = NULL;\n\tstruct attach *attach;\n\tstruct blob *parsed;\n\t_cleanup_free_ char *versionstr = NULL;\n\n\tparsed = new0(struct blob, 1);\n\tparsed->local_version = false;\n\tINIT_LIST_HEAD(&parsed->account_head);\n\tINIT_LIST_HEAD(&parsed->share_head);\n\n\twhile (read_chunk(&blob_pos, &chunk)) {\n\t\tif (!strcmp(chunk.name, \"LPAV\")) {\n\t\t\tversionstr = xstrndup((char *) chunk.data, chunk.len);\n\t\t\tparsed->version = strtoull(versionstr, NULL, 10);\n\t\t} else if (!strcmp(chunk.name, \"ACCT\")) {\n\t\t\taccount = account_parse(&chunk, last_share ? last_share->key : key);\n\t\t\tif (!account)\n\t\t\t\tgoto error;\n\n\t\t\tif (last_share) {\n\t\t\t\taccount->share = last_share;\n\t\t\t\tchar *tmp = account->fullname;\n\t\t\t\txasprintf(&account->fullname, \"%s/%s\",\n\t\t\t\t\t  last_share->name, tmp);\n\t\t\t\tfree(tmp);\n\t\t\t}\n\n\t\t\tlist_add(&account->list, &parsed->account_head);\n\n\t\t} else if (!strcmp(chunk.name, \"ACFL\") || !strcmp(chunk.name, \"ACOF\")) {\n\t\t\tif (!account)\n\t\t\t\tgoto error;\n\n\t\t\tfield = field_parse(&chunk, last_share ? last_share->key : key);\n\t\t\tif (!field)\n\t\t\t\tgoto error;\n\n\t\t\tlist_add_tail(&field->list, &account->field_head);\n\t\t} else if (!strcmp(chunk.name, \"LOCL\")) {\n\t\t\tparsed->local_version = true;\n\t\t} else if (!strcmp(chunk.name, \"SHAR\")) {\n\t\t\tshare = share_parse(&chunk, private_key);\n\t\t\tlast_share = share;\n\t\t\tif (share)\n\t\t\t\tlist_add_tail(&share->list, &parsed->share_head);\n\t\t} else if (!strcmp(chunk.name, \"AACT\")) {\n\t\t\tapp = app_parse(&chunk, last_share ? last_share->key : key);\n\t\t\tif (app)\n\t\t\t\tlist_add_tail(&app->account.list, &parsed->account_head);\n\t\t} else if (!strcmp(chunk.name, \"AACF\")) {\n\t\t\tif (!app)\n\t\t\t\tgoto error;\n\t\t\tfield = app_field_parse(&chunk, last_share ? last_share->key : key);\n\t\t\tif (!field)\n\t\t\t\tgoto error;\n\t\t\tlist_add_tail(&field->list, &app->account.field_head);\n\t\t} else if (!strcmp(chunk.name, \"ATTA\")) {\n\t\t\tstruct account *tmp;\n\t\t\tbool found = false;\n\n\t\t\tattach = attach_parse(&chunk);\n\t\t\tif (!attach)\n\t\t\t\tgoto error;\n\n\t\t\t/* add attachment to the proper account's list */\n\t\t\tlist_for_each_entry(tmp, &parsed->account_head, list) {\n\t\t\t\tif (!strcmp(tmp->id, attach->parent)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tlist_add_tail(&attach->list, &tmp->attach_head);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tattach_free(attach);\n\t\t}\n\t}\n\n\tif (!versionstr)\n\t\tgoto error;\n\treturn parsed;\n\nerror:\n\tblob_free(parsed);\n\treturn NULL;\n}\n\nvoid buffer_init(struct buffer *buf)\n{\n\tbuf->len = 0;\n\tbuf->max = 80;\n\tbuf->bytes = xcalloc(buf->max, 1);\n}\n\nvoid buffer_append(struct buffer *buffer, void *bytes, size_t len)\n{\n\tif (buffer->len + len > buffer->max) {\n\t\tbuffer->max = buffer->len + len + 512;\n\t\tbuffer->bytes = xrealloc(buffer->bytes, buffer->max);\n\t}\n\tmemcpy(buffer->bytes + buffer->len, bytes, len);\n\tbuffer->len += len;\n}\n\nvoid buffer_append_char(struct buffer *buf, char c)\n{\n\tif (buf->len + 1 >= buf->max) {\n\t\tbuf->max += 80;\n\t\tbuf->bytes = xrealloc(buf->bytes, buf->max);\n\t}\n\tbuf->bytes[buf->len++] = c;\n\tbuf->bytes[buf->len] = '\\0';\n}\n\nvoid buffer_append_str(struct buffer *buf, char *str)\n{\n\t/*\n\t * copy null terminator, but don't count in used len\n         * so that append of multiple strings will work\n         */\n\tbuffer_append(buf, str, strlen(str) + 1);\n\tbuf->len--;\n}\n\nstatic void write_item(struct buffer *buffer, char *bytes, size_t len)\n{\n\tuint32_t be32len = htobe32(len);\n\tbuffer_append(buffer, &be32len, sizeof(be32len));\n\tbuffer_append(buffer, bytes, len);\n}\n\nstatic void write_plain_string(struct buffer *buffer, char *bytes)\n{\n\twrite_item(buffer, bytes, strlen(bytes));\n}\nstatic void write_hex_string(struct buffer *buffer, char *bytes)\n{\n\t_cleanup_free_ char *hex = NULL;\n\tbytes_to_hex((unsigned char *) bytes, &hex, strlen(bytes));\n\twrite_plain_string(buffer, hex);\n}\nstatic void write_crypt_string(struct buffer *buffer, char *enc_str)\n{\n\t_cleanup_free_ unsigned char *encrypted = NULL;\n\tsize_t len;\n\n\t/*\n\t * enc_str is base64-encoded, but we write out raw bytes in\n\t * the saved blob, so un-base64.\n\t */\n\tlen = cipher_unbase64(enc_str, &encrypted);\n\twrite_item(buffer, (char *) encrypted, len);\n}\n\nstatic void write_boolean(struct buffer *buffer, bool yes)\n{\n\twrite_plain_string(buffer, yes ? \"1\" : \"0\");\n}\n\nstatic void write_chunk(struct buffer *dstbuffer, struct buffer *srcbuffer, char *tag)\n{\n\tif (strlen(tag) != 4)\n\t\treturn;\n\tbuffer_append(dstbuffer, tag, 4);\n\twrite_item(dstbuffer, srcbuffer->bytes, srcbuffer->len);\n}\n\nstatic void write_app_chunk(struct buffer *buffer, struct account *account)\n{\n\tstruct buffer accbuf, fieldbuf;\n\tstruct field *field;\n\tstruct app *app = account_to_app(account);\n\n\tmemset(&accbuf, 0, sizeof(accbuf));\n\twrite_plain_string(&accbuf, account->id);\n\twrite_hex_string(&accbuf, app->appname);\n\twrite_crypt_string(&accbuf, app->extra_encrypted);\n\twrite_crypt_string(&accbuf, account->name_encrypted);\n\twrite_crypt_string(&accbuf, account->group_encrypted);\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_boolean(&accbuf, account->pwprotect);\n\twrite_boolean(&accbuf, account->fav);\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_chunk(buffer, &accbuf, \"AACT\");\n\tfree(accbuf.bytes);\n\tlist_for_each_entry(field, &account->field_head, list) {\n\t\tmemset(&fieldbuf, 0, sizeof(fieldbuf));\n\t\twrite_plain_string(&fieldbuf, field->name);\n\t\tif (!strcmp(field->type, \"email\") || !strcmp(field->type, \"tel\") || !strcmp(field->type, \"text\") || !strcmp(field->type, \"password\") || !strcmp(field->type, \"textarea\"))\n\t\t\twrite_crypt_string(&fieldbuf, field->value_encrypted);\n\t\telse\n\t\t\twrite_plain_string(&fieldbuf, field->value);\n\t\twrite_plain_string(&fieldbuf, field->type);\n\t\twrite_chunk(buffer, &fieldbuf, \"AACF\");\n\t\tfree(fieldbuf.bytes);\n\t}\n}\n\nstatic void write_account_chunk(struct buffer *buffer, struct account *account, const struct feature_flag *feature_flag)\n{\n\tstruct buffer accbuf, fieldbuf;\n\tstruct field *field;\n\n\tif (account->is_app) {\n\t\twrite_app_chunk(buffer, account);\n\t\treturn;\n\t}\n\n\tmemset(&accbuf, 0, sizeof(accbuf));\n\twrite_plain_string(&accbuf, account->id);\n\twrite_crypt_string(&accbuf, account->name_encrypted);\n\twrite_crypt_string(&accbuf, account->group_encrypted);\n\tif (feature_flag && feature_flag->url_encryption_enabled) {\n\t\tif (account->url_encrypted != NULL)\n\t\t\twrite_crypt_string(&accbuf, account->url_encrypted);\n\t\telse\n\t\t\twrite_hex_string(&accbuf, account->url);\n\t} else {\n\t\twrite_hex_string(&accbuf, account->url);\n\t}\n\twrite_crypt_string(&accbuf, account->note_encrypted);\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_crypt_string(&accbuf, account->username_encrypted);\n\twrite_crypt_string(&accbuf, account->password_encrypted);\n\twrite_boolean(&accbuf, account->pwprotect);\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_plain_string(&accbuf, \"skipped\");\n\twrite_chunk(buffer, &accbuf, \"ACCT\");\n\tfree(accbuf.bytes);\n\tlist_for_each_entry(field, &account->field_head, list) {\n\t\tmemset(&fieldbuf, 0, sizeof(fieldbuf));\n\t\twrite_plain_string(&fieldbuf, field->name);\n\t\twrite_plain_string(&fieldbuf, field->type);\n\t\tif (!strcmp(field->type, \"email\") || !strcmp(field->type, \"tel\") || !strcmp(field->type, \"text\") || !strcmp(field->type, \"password\") || !strcmp(field->type, \"textarea\"))\n\t\t\twrite_crypt_string(&fieldbuf, field->value_encrypted);\n\t\telse\n\t\t\twrite_plain_string(&fieldbuf, field->value);\n\t\twrite_boolean(&fieldbuf, field->checked);\n\t\twrite_chunk(buffer, &fieldbuf, \"ACFL\");\n\t\tfree(fieldbuf.bytes);\n\t}\n}\nstatic void write_share_chunk(struct buffer *buffer, struct share *share)\n{\n\tstruct buffer sharebuf = { .bytes = share->chunk, .len = share->chunk_len, .max = share->chunk_len };\n\twrite_chunk(buffer, &sharebuf, \"SHAR\");\n}\n\nsize_t blob_write(const struct blob *blob, const unsigned char key[KDF_HASH_LEN], char **out, const struct feature_flag *feature_flag)\n{\n\tstruct buffer buffer;\n\tstruct share *last_share = NULL;\n\tstruct account *account;\n\tUNUSED(key);\n\n\tmemset(&buffer, 0, sizeof(buffer));\n\n\t_cleanup_free_ char *version = xultostr(blob->version);\n\tbuffer_append(&buffer, \"LPAV\", 4);\n\twrite_plain_string(&buffer, version);\n\tbuffer_append(&buffer, \"LOCL\", 4);\n\twrite_plain_string(&buffer, LASTPASS_CLI_VERSION);\n\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tif (!account->share)\n\t\t\twrite_account_chunk(&buffer, account, feature_flag);\n\t}\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tif (!account->share)\n\t\t\tcontinue;\n\t\tif (last_share != account->share) {\n\t\t\twrite_share_chunk(&buffer, account->share);\n\t\t\tlast_share = account->share;\n\t\t}\n\t\twrite_account_chunk(&buffer, account, feature_flag);\n\t}\n\n\t*out = buffer.bytes;\n\treturn buffer.len;\n}\n\nstatic struct blob *local_blob(const unsigned char key[KDF_HASH_LEN], const struct private_key *private_key)\n{\n\t_cleanup_free_ unsigned char *blob = NULL;\n\tsize_t len = config_read_encrypted_buffer(\"blob\", &blob, key);\n\tif (!blob)\n\t\treturn NULL;\n\treturn blob_parse(blob, len, key, private_key);\n}\n\nstatic struct blob *blob_get_latest(struct session *session, const unsigned char key[KDF_HASH_LEN])\n{\n\tstruct blob *local;\n\tunsigned long long remote_version;\n\n\tlocal = local_blob(key, &session->private_key);\n\tif (!local)\n\t\treturn lastpass_get_blob(session, key);\n\n\tremote_version = lastpass_get_blob_version(session, key);\n\n\tif (remote_version == 0) {\n\t\tblob_free(local);\n\t\treturn NULL;\n\t}\n\n\tif (remote_version > local->version) {\n\t\tblob_free(local);\n\t\treturn lastpass_get_blob(session, key);\n\t}\n\n\tconfig_touch(\"blob\");\n\treturn local;\n}\n\nstatic time_t auto_sync_time(void)\n{\n\ttime_t time;\n\tchar *env = getenv(\"LPASS_AUTO_SYNC_TIME\");\n\n\tif (!env)\n\t\treturn 5;\n\ttime = strtoul(env, NULL, 10);\n\tif (!time)\n\t\treturn 5;\n\treturn time;\n}\n\nstruct blob *blob_load(enum blobsync sync, struct session *session, const unsigned char key[KDF_HASH_LEN])\n{\n\tif (sync == BLOB_SYNC_YES)\n\t\treturn blob_get_latest(session, key);\n\n\tif (sync == BLOB_SYNC_NO)\n\t\treturn local_blob(key, &session->private_key);\n\n\tif (config_exists(\"blob\") &&\n\t\t\ttime(NULL) - config_mtime(\"blob\") < auto_sync_time()) {\n\t\treturn local_blob(key, &session->private_key);\n\t}\n\n\treturn blob_get_latest(session, key);\n}\n\nvoid blob_save(const struct blob *blob, const unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\t_cleanup_free_ char *bluffer = NULL;\n\tsize_t len;\n\n\tlen = blob_write(blob, key, &bluffer, feature_flag);\n\tif (!len)\n\t\tdie(\"Could not write blob.\");\n\n\tconfig_write_encrypted_buffer(\"blob\", bluffer, len, key);\n}\n\n#define set_field(obj, field) do { \\\n\tfree(obj->field); \\\n\tobj->field = field; \\\n} while (0)\n#define set_encrypted_field(obj, field) do { \\\n\tif (!obj->field || !field || strcmp(obj->field, field)) { \\\n\t\tset_field(obj, field); \\\n\t\tfree(obj->field##_encrypted); \\\n\t\tobj->field##_encrypted = encrypt_and_base64(field, account->share ? account->share->key : key); \\\n\t} \\\n} while (0)\n#define reencrypt_field(obj, field) do { \\\n\tfree(obj->field##_encrypted); \\\n\tobj->field##_encrypted = encrypt_and_base64(obj->field, account->share ? account->share->key : key); \\\n} while (0)\n\nvoid account_set_username(struct account *account, char *username, unsigned const char key[KDF_HASH_LEN])\n{\n\tset_encrypted_field(account, username);\n}\nvoid account_set_password(struct account *account, char *password, unsigned const char key[KDF_HASH_LEN])\n{\n\tset_encrypted_field(account, password);\n}\nvoid account_set_group(struct account *account, char *group, unsigned const char key[KDF_HASH_LEN])\n{\n\tset_encrypted_field(account, group);\n}\nvoid account_set_name(struct account *account, char *name, unsigned const char key[KDF_HASH_LEN])\n{\n\tset_encrypted_field(account, name);\n}\nvoid account_set_note(struct account *account, char *note, unsigned const char key[KDF_HASH_LEN])\n{\n\tset_encrypted_field(account, note);\n}\nvoid account_set_url(struct account *account, char *url, unsigned const char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tif (url != NULL && strstr(url, \"://\") == NULL) {\n\t\tchar *url_with_prefix;\n\t\tif ((url_with_prefix = malloc(strlen(url) + strlen(\"http://\") + 1)) != NULL) {\n\t\t\tstrcpy(url_with_prefix, \"http://\");\n\t\t\tstrcat(url_with_prefix, url);\n\t\t\tfree(url);\n\t\t\turl = url_with_prefix;\n\t\t}\n\t}\n\n\tif (feature_flag && feature_flag->url_encryption_enabled) {\n\t\tset_encrypted_field(account, url);\n\t} else {\n\t\tUNUSED(key);\n\t\tset_field(account, url);\n\t}\n}\nvoid account_set_appname(struct account *account, char *appname, unsigned const char key[KDF_HASH_LEN])\n{\n\tUNUSED(key);\n\tstruct app *app;\n\tif (!account->is_app)\n\t\treturn;\n\n\tapp = account_to_app(account);\n\tset_field(app, appname);\n}\nvoid field_set_value(struct account *account, struct field *field, char *value, unsigned const char key[KDF_HASH_LEN])\n{\n\tif (!strcmp(field->type, \"email\") || !strcmp(field->type, \"tel\") || !strcmp(field->type, \"text\") || !strcmp(field->type, \"password\") || !strcmp(field->type, \"textarea\"))\n\t\tset_encrypted_field(field, value);\n\telse\n\t\tset_field(field, value);\n}\n\nstatic bool is_shared_folder_name(const char *fullname)\n{\n\treturn !strncmp(fullname, \"Shared-\", 7) && strchr(fullname, '/');\n}\n\nvoid account_reencrypt(struct account *account, const unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tstruct field *field;\n\n\treencrypt_field(account, name);\n\treencrypt_field(account, group);\n\tif (feature_flag && feature_flag->url_encryption_enabled) {\n\t\treencrypt_field(account, url);\n\t}\n\treencrypt_field(account, username);\n\treencrypt_field(account, password);\n\treencrypt_field(account, note);\n\n\tlist_for_each_entry(field, &account->field_head, list) {\n\t\treencrypt_field(field, value);\n\t}\n}\n\n/*\n * Set just group and name, assuming we've stripped off any leading\n * shared folder from fullname.\n */\nstatic void account_set_group_name(struct account *account,\n\t\t\t\t   const char *groupname,\n\t\t\t\t   unsigned const char key[KDF_HASH_LEN])\n{\n\tchar *slash = strrchr(groupname, '/');\n\tif (!slash) {\n\t\taccount_set_name(account, xstrdup(groupname), key);\n\t\taccount_set_group(account, xstrdup(\"\"), key);\n\t} else {\n\t\taccount_set_name(account, xstrdup(slash + 1), key);\n\t\taccount_set_group(account, xstrndup(groupname, slash - groupname), key);\n\t}\n}\n\nvoid account_set_fullname(struct account *account, char *fullname, unsigned const char key[KDF_HASH_LEN])\n{\n\tchar *groupname = fullname;\n\n\t/* skip Shared-XXX/ for shared folders */\n\tif (is_shared_folder_name(fullname)) {\n\t\tchar *tmp = strchr(fullname, '/');\n\t\tif (tmp)\n\t\t\tgroupname = tmp + 1;\n\t}\n\taccount_set_group_name(account, groupname, key);\n\tfree(account->fullname);\n\taccount->fullname = fullname;\n}\n\nstruct share *find_unique_share(struct blob *blob, const char *name)\n{\n       struct share *share;\n\n       list_for_each_entry(share, &blob->share_head, list) {\n               if (!strcasecmp(share->name, name)) {\n                       return share;\n               }\n       }\n       return NULL;\n}\n\n/*\n * Assign an account to the proper shared folder, if any.\n *\n * If the share changed from whatever it was previously, the account\n * fields are reencrypted with either the share key or the blob key.\n *\n * This function may exit if the name represents a shared folder but\n * same folder is not available.\n */\nvoid account_assign_share(struct blob *blob, struct account *account,\n\t\t\t  unsigned const char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tstruct share *share, *old_share;\n\t_cleanup_free_ char *shared_name = NULL;\n\tchar *name = account->fullname;\n\n\told_share = account->share;\n\n\t/* strip off shared groupname */\n\tchar *slash = strchr(name, '/');\n\tif (!slash) {\n\t\taccount->share = NULL;\n\t\tgoto reencrypt;\n\t}\n\n\tshared_name = xstrndup(name, slash - name);\n\n\t/* find a share matching group name */\n\tshare = find_unique_share(blob, shared_name);\n\n\tif (!share && is_shared_folder_name(name)) {\n\t\t/* don't allow normal folders named like SFs */\n\t\tdie(\"Unable to find shared folder for %s in blob\\n\", name);\n\t}\n\n\taccount->share = share;\n\n\t/* update group name to not include new share, if needed */\n\tif (share)\n\t\taccount_set_group_name(account, slash + 1, key);\n\nreencrypt:\n\tif (old_share != account->share)\n\t\taccount_reencrypt(account, key, feature_flag);\n}\n\nstruct account *notes_expand(struct account *acc)\n{\n\tstruct account *expand;\n\tstruct field *field = NULL;\n\tchar *start, *lf, *colon, *name, *value;\n\tstruct attach *attach, *tmp;\n\tchar *line = NULL;\n\tsize_t len;\n\n\tif (!account_is_secure_note(acc))\n\t\treturn NULL;\n\n\texpand = new_account();\n\n\texpand->id = xstrdup(acc->id);\n\texpand->pwprotect = acc->pwprotect;\n\texpand->name = xstrdup(acc->name);\n\texpand->group = xstrdup(acc->group);\n\texpand->fullname = xstrdup(acc->fullname);\n\texpand->share = acc->share;\n\n\tif (strncmp(acc->note, \"NoteType:\", 9))\n\t\treturn NULL;\n\n\tenum note_type note_type = NOTE_TYPE_NONE;\n\tlf = strchr(acc->note + 9, '\\n');\n\tif (lf) {\n\t\t_cleanup_free_ char *type = xstrndup(acc->note + 9, lf - (acc->note + 9));\n\t\tnote_type = notes_get_type_by_name(type);\n\t}\n\n\tfor (start = acc->note; ; ) {\n\t\tname = value = NULL;\n\t\tlf = strchrnul(start, '\\n');\n\t\tif (lf == start && !field)\n\t\t\tgoto skip;\n\n\t\tline = xstrndup(start, lf - start);\n\t\tcolon = strchr(line, ':');\n\t\tif (colon) {\n\t\t\tname = xstrndup(line, colon - line);\n\t\t\tvalue = xstrdup(colon + 1);\n\t\t}\n\n\t\t/*\n\t\t * Append non-keyed strings to existing field.\n\t\t * If no field, skip.\n\t\t */\n\t\tif (!name) {\n\t\t\tif (field)\n\t\t\t\txstrappendf(&field->value, \"\\n%s\", line);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/*\n\t\t * If this is a known notetype, append any non-existent\n\t\t * keys to the existing field.  For example, Proc-Type\n\t\t * in the ssh private key field goes into private key,\n\t\t * not a Proc-Type field.\n\t\t */\n\t\tif (note_type != NOTE_TYPE_NONE &&\n\t\t    !note_has_field(note_type, name) && field &&\n\t\t    note_field_is_multiline(note_type, field->name)) {\n\t\t\txstrappendf(&field->value, \"\\n%s\", line);\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (!strcmp(name, \"Username\"))\n\t\t\texpand->username = xstrdup(value);\n\t\telse if (!strcmp(name, \"Password\"))\n\t\t\texpand->password = xstrdup(value);\n\t\telse if (!strcmp(name, \"URL\"))\n\t\t\texpand->url = xstrdup(value);\n\t\telse if (!strcmp(name, \"Notes\")) {\n\t\t\texpand->note = xstrdup(strchr(start, ':') + 1);\n\t\t\tlen = strlen(expand->note);\n\t\t\tif (len && expand->note[len - 1] == '\\n')\n\t\t\t\texpand->note[len - 1] = '\\0';\n\t\t\tlf = NULL;\n\t\t} else {\n\t\t\tfield = new0(struct field, 1);\n\t\t\tfield->type = xstrdup(\"text\");\n\t\t\tfield->name = xstrdup(name);\n\t\t\tfield->value = xstrdup(value);\n\t\t\tlist_add(&field->list, &expand->field_head);\n\t\t}\nskip:\n\t\tfree(value);\n\t\tfree(name);\n\t\tfree(line);\n\t\tline = NULL;\n\t\tif (!lf || !*lf)\n\t\t\tbreak;\n\t\tstart = lf + 1;\n\t\tif (!*start)\n\t\t\tbreak;\n\t}\n\tif (!expand->note && !expand->username && !expand->url && !expand->password && list_empty(&expand->field_head))\n\t\texpand->note = xstrdup(acc->note);\n\telse if (!expand->note)\n\t\texpand->note = xstrdup(\"\");\n\tif (!expand->url)\n\t\texpand->url = xstrdup(\"\");\n\tif (!expand->username)\n\t\texpand->username = xstrdup(\"\");\n\tif (!expand->password)\n\t\texpand->password = xstrdup(\"\");\n\n\t/* move attachments to expanded account */\n\texpand->attachkey = xstrdup(acc->attachkey);\n\texpand->attachkey_encrypted = xstrdup(acc->attachkey_encrypted);\n\texpand->attachpresent = acc->attachpresent;\n\n\tlist_for_each_entry_safe(attach, tmp, &acc->attach_head, list) {\n\t\tlist_del(&attach->list);\n\t\tlist_add_tail(&attach->list, &expand->attach_head);\n\t}\n\n\treturn expand;\n}\nstruct account *notes_collapse(struct account *acc)\n{\n\tstruct account *collapse;\n\tstruct field *field;\n\tstruct attach *attach, *tmp;\n\n\tcollapse = new_account();\n\n\tcollapse->id = xstrdup(acc->id);\n\tcollapse->pwprotect = acc->pwprotect;\n\tcollapse->name = xstrdup(acc->name);\n\tcollapse->group = xstrdup(acc->group);\n\tcollapse->fullname = xstrdup(acc->fullname);\n\tcollapse->url = xstrdup(\"http://sn\");\n\tcollapse->username = xstrdup(\"\");\n\tcollapse->password = xstrdup(\"\");\n\tcollapse->note = xstrdup(\"\");\n\tcollapse->share = acc->share;\n\n\t/* move attachments back from expanded account */\n\tcollapse->attachkey = xstrdup(acc->attachkey);\n\tcollapse->attachkey_encrypted = xstrdup(acc->attachkey_encrypted);\n\tcollapse->attachpresent = acc->attachpresent;\n\n\tlist_for_each_entry_safe(attach, tmp, &acc->attach_head, list) {\n\t\tlist_del(&attach->list);\n\t\tlist_add_tail(&attach->list, &collapse->attach_head);\n\t}\n\n\tlist_for_each_entry(field, &acc->field_head, list) {\n\t\ttrim(field->value);\n\t\ttrim(field->name);\n\t\tif (!strcmp(field->name, \"NoteType\"))\n\t\t\txstrprependf(&collapse->note, \"%s:%s\\n\", field->name, field->value);\n\t\telse\n\t\t\txstrappendf(&collapse->note, \"%s:%s\\n\", field->name, field->value);\n\t}\n\tif (strlen(acc->username))\n\t\txstrappendf(&collapse->note, \"%s:%s\\n\", \"Username\", trim(acc->username));\n\tif (strlen(acc->password))\n\t\txstrappendf(&collapse->note, \"%s:%s\\n\", \"Password\", trim(acc->password));\n\tif (strlen(acc->url))\n\t\txstrappendf(&collapse->note, \"%s:%s\\n\", \"URL\", trim(acc->url));\n\tif (strlen(acc->note))\n\t\txstrappendf(&collapse->note, \"%s:%s\\n\", \"Notes\", trim(acc->note));\n\n\treturn collapse;\n}\n"
        },
        {
          "name": "blob.h",
          "type": "blob",
          "size": 5.1474609375,
          "content": "#ifndef BLOB_H\n#define BLOB_H\n\n#include \"kdf.h\"\n#include \"session.h\"\n#include \"list.h\"\n#include \"notes.h\"\n#include \"feature-flag.h\"\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct share_user {\n\tchar *uid;\n\tchar *username;\n\tchar *realname;\n\tchar *cgid;\n\tbool read_only;\n\tbool is_group;\t\t/* if set uid, username store gid, groupname */\n\tbool hide_passwords;\n\tbool admin;\n\tbool outside_enterprise;\n\tbool accepted;\n\tstruct public_key sharing_key;\n\tstruct list_head list;\n};\n\nstruct share_limit_aid {\n\tchar *aid;\n\tstruct list_head list;\n};\n\nstruct share_limit {\n\tbool whitelist;\n\tstruct list_head aid_list;\n};\n\nstruct share {\n\tchar *id;\n\tchar *name;\n\tunsigned char key[KDF_HASH_LEN];\n\tbool readonly;\n\n\tchar *chunk;\n\tsize_t chunk_len;\n\n\tstruct list_head list;\n};\n\nstruct field {\n\tchar *type;\n\tchar *name;\n\tchar *value, *value_encrypted;\n\tbool checked;\n\n\tstruct list_head list;\n};\n\nstruct account {\n\tchar *id;\n\tchar *name, *name_encrypted;\n\tchar *group, *group_encrypted;\n\tchar *fullname;\n\tchar *url, *url_encrypted;\n\tchar *username, *username_encrypted;\n\tchar *password, *password_encrypted;\n\tchar *note, *note_encrypted;\n\tchar *last_touch, *last_modified_gmt;\n\tbool pwprotect;\n\tbool fav;\n\tbool is_app;\n\tchar *attachkey, *attachkey_encrypted;\n\tbool attachpresent;\n\tsize_t attach_len;\n\tchar *attach_bytes;\n\n\tstruct list_head field_head;\n\tstruct share *share;\n\n\tstruct list_head attach_head;\n\n\tstruct list_head list;\n\tstruct list_head match_list;\n};\n\nstruct app {\n\tstruct account account;\n\n\tchar *appname;\n\tchar *extra, *extra_encrypted;\n\tchar *wintitle;\n\tchar *wininfo;\n\tchar *exeversion;\n\tchar *warnversion;\n\tchar *exehash;\n};\n\nstruct attach {\n\tchar *id;\n\tchar *parent;\n\tchar *mimetype;\n\tchar *storagekey;\n\tchar *size;\n\tchar *filename;\n\n\tstruct list_head list;\n};\n\n/* resizable string buffer */\nstruct buffer {\n\tsize_t len;\n\tsize_t max;\n\tchar *bytes;\n};\n\nstruct blob {\n\tunsigned long long version;\n\tbool local_version;\n\t/* TODO: extract other data eventually... */\n\n\tstruct list_head account_head;\n\tstruct list_head share_head;\n};\n\n/* state used during master password change */\nstruct pwchange_info {\n\tchar *reencrypt_id;\n\tchar *token;\n\tchar *privkey_encrypted;\n\tchar *new_privkey_encrypted;\n\tchar *new_privkey_hash;\n\tchar *new_key_hash;\n\tstruct list_head fields;\n\tstruct list_head su_keys;\n};\n\n/* replacement items for password change blob updates */\nstruct pwchange_field {\n\tchar *old_ctext;\n\tchar *new_ctext;\n\tbool optional;\n\tstruct list_head list;\n};\n\n/* Super-user keys used for enterprise password recovery. */\nstruct pwchange_su_key {\n\tchar *uid;\t\t\t/* uid for super user */\n\tstruct public_key sharing_key;\t/* pubkey for this user */\n\tchar *new_enc_key;\t\t/* user AES key, enc w/ SU's RSA key */\n\tstruct list_head list;\n};\n\nenum blobsync { BLOB_SYNC_AUTO, BLOB_SYNC_YES, BLOB_SYNC_NO };\n\nstruct blob *blob_parse(const unsigned char *blob, size_t len, const unsigned char key[KDF_HASH_LEN], const struct private_key *private_key);\nvoid blob_free(struct blob *blob);\nsize_t blob_write(const struct blob *blob, const unsigned char key[KDF_HASH_LEN], char **out, const struct feature_flag *feature_flag);\nstruct blob *blob_load(enum blobsync sync, struct session *session, const unsigned char key[KDF_HASH_LEN]);\nvoid blob_save(const struct blob *blob, const unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag);\nvoid field_free(struct field *field);\nstruct app *account_to_app(const struct account *account);\nstruct app *new_app();\nstruct account *new_account();\nvoid account_free(struct account *account);\nvoid account_set_username(struct account *account, char *username, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_password(struct account *account, char *password, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_group(struct account *account, char *group, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_name(struct account *account, char *name, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_fullname(struct account *account, char *fullname, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_url(struct account *account, char *url, unsigned const char key[KDF_HASH_LEN], const struct feature_flag *feature_flag);\nvoid account_set_note(struct account *account, char *note, unsigned const char key[KDF_HASH_LEN]);\nvoid account_set_appname(struct account *account, char *appname, unsigned const char key[KDF_HASH_LEN]);\nvoid account_assign_share(struct blob *blob, struct account *account, unsigned const char key[KDF_HASH_LEN], const struct feature_flag *feature_flag);\nvoid account_reencrypt(struct account *account, const unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag);\nbool account_is_group(struct account *account);\nvoid field_set_value(struct account *account, struct field *field, char *value, unsigned const char key[KDF_HASH_LEN]);\nstruct account *notes_expand(struct account *acc);\nstruct account *notes_collapse(struct account *acc);\nvoid share_free(struct share *share);\nstruct share *find_unique_share(struct blob *blob, const char *name);\nvoid buffer_init(struct buffer *buf);\nvoid buffer_append(struct buffer *buffer, void *bytes, size_t len);\nvoid buffer_append_char(struct buffer *buf, char c);\nvoid buffer_append_str(struct buffer *buf, char *str);\n\n#endif\n"
        },
        {
          "name": "cipher.c",
          "type": "blob",
          "size": 13.7373046875,
          "content": "/*\n * encryption and decryption routines\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cipher.h\"\n#include \"util.h\"\n#include <sys/mman.h>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n#include <openssl/x509.h>\n#include <string.h>\n#include <stdarg.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n\n#define LP_PKEY_PREFIX \"LastPassPrivateKey<\"\n#define LP_PKEY_SUFFIX \">LastPassPrivateKey\"\n\nchar *cipher_rsa_decrypt(const unsigned char *ciphertext, size_t len, const struct private_key *private_key)\n{\n\tPKCS8_PRIV_KEY_INFO *p8inf = NULL;\n\tEVP_PKEY *pkey = NULL;\n\tRSA *rsa = NULL;\n\tBIO *memory = NULL;\n\tchar *ret = NULL;\n\n\tif (!len)\n\t\treturn NULL;\n\n\tmemory = BIO_new(BIO_s_mem());\n\tif (BIO_write(memory, private_key->key, private_key->len) < 0)\n\t\tgoto out;\n\n\tp8inf = d2i_PKCS8_PRIV_KEY_INFO_bio(memory, NULL);\n\tif (!p8inf)\n\t\tgoto out;\n\tpkey = EVP_PKCS82PKEY(p8inf);\n\tif (!pkey)\n\t\tgoto out;\n\trsa = EVP_PKEY_get1_RSA(pkey);\n\tif (!rsa)\n\t\tgoto out;\n\n\tret = xcalloc(len + 1, 1);\n\tif (RSA_private_decrypt(len, (unsigned char *)ciphertext, (unsigned char *)ret, rsa, RSA_PKCS1_OAEP_PADDING) < 0) {\n\t\tfree(ret);\n\t\tret = NULL;\n\t\tgoto out;\n\t}\n\nout:\n\tPKCS8_PRIV_KEY_INFO_free(p8inf);\n\tEVP_PKEY_free(pkey);\n\tRSA_free(rsa);\n\tBIO_free_all(memory);\n\treturn ret;\n}\n\nint cipher_rsa_encrypt_bytes(const unsigned char *plaintext,\n\t\t\t     size_t in_len,\n\t\t\t     const struct public_key *public_key,\n\t\t\t     unsigned char *out_crypttext, size_t *out_len)\n{\n\tEVP_PKEY *pubkey = NULL;\n\tRSA *rsa = NULL;\n\tBIO *memory = NULL;\n\tint ret;\n\n\tif (*out_len < public_key->len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemory = BIO_new(BIO_s_mem());\n\tret = BIO_write(memory, public_key->key, public_key->len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = -EIO;\n\tpubkey = d2i_PUBKEY_bio(memory, NULL);\n\tif (!pubkey)\n\t\tgoto out;\n\n\trsa = EVP_PKEY_get1_RSA(pubkey);\n\tif (!rsa)\n\t\tgoto out;\n\n\tret = RSA_public_encrypt(in_len, plaintext,\n\t\t\t         out_crypttext,\n\t\t\t         rsa, RSA_PKCS1_OAEP_PADDING);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*out_len = ret;\n\tret = 0;\n\nout:\n\tEVP_PKEY_free(pubkey);\n\tRSA_free(rsa);\n\tBIO_free_all(memory);\n\treturn ret;\n}\n\nint cipher_rsa_encrypt(const char *plaintext,\n\t\t       const struct public_key *public_key,\n\t\t       unsigned char *out_crypttext, size_t *out_len)\n{\n\treturn cipher_rsa_encrypt_bytes((unsigned char *) plaintext,\n\t\t\t\t\tstrlen(plaintext),\n\t\t\t\t\tpublic_key, out_crypttext, out_len);\n}\n\nchar *cipher_aes_decrypt(const unsigned char *ciphertext, size_t len, const unsigned char key[KDF_HASH_LEN])\n{\n\tEVP_CIPHER_CTX *ctx;\n\tchar *plaintext;\n\tint out_len;\n\n\tif (!len)\n\t\treturn NULL;\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (!ctx)\n\t\treturn NULL;\n\n\tplaintext = xcalloc(len + AES_BLOCK_SIZE + 1, 1);\n\tif (len >= 33 && len % 16 == 1 && ciphertext[0] == '!') {\n\t\tif (!EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, (unsigned char *)(ciphertext + 1)))\n\t\t\tgoto error;\n\t\tciphertext += 17;\n\t\tlen -= 17;\n\t} else {\n\t\tif (!EVP_DecryptInit_ex(ctx, EVP_aes_256_ecb(), NULL, key, NULL))\n\t\t\tgoto error;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, (unsigned char *)plaintext, &out_len, (unsigned char *)ciphertext, len))\n\t\tgoto error;\n\tlen = out_len;\n\tif (!EVP_DecryptFinal_ex(ctx, (unsigned char *)(plaintext + out_len), &out_len))\n\t\tgoto error;\n\tlen += out_len;\n\tplaintext[len] = '\\0';\n\tEVP_CIPHER_CTX_free(ctx);\n\treturn plaintext;\n\nerror:\n\tEVP_CIPHER_CTX_free(ctx);\n\tsecure_clear(plaintext, len + AES_BLOCK_SIZE + 1);\n\tfree(plaintext);\n\treturn NULL;\n}\n\nstatic\nsize_t cipher_aes_encrypt_bytes(const unsigned char *bytes, size_t len,\n\t\t\t\tconst unsigned char key[KDF_HASH_LEN],\n\t\t\t\tconst unsigned char *iv,\n\t\t\t\tunsigned char **out)\n{\n\tEVP_CIPHER_CTX *ctx;\n\tint out_len;\n\tsize_t ret_len = 0;\n\tunsigned char *ctext;\n\n\tctext = *out;\n\tif (!ctext)\n\t\tctext = xcalloc(len + AES_BLOCK_SIZE * 2 + 1, 1);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (!ctx)\n\t\tgoto error;\n\n\tif (!EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))\n\t\tgoto error;\n\n\tif (!EVP_EncryptUpdate(ctx, ctext, &out_len, bytes, len))\n\t\tgoto error;\n\n\tret_len += out_len;\n\tif (!EVP_EncryptFinal_ex(ctx, ctext + ret_len, &out_len))\n\t\tgoto error;\n\tret_len += out_len;\n\n\tEVP_CIPHER_CTX_free(ctx);\n\t*out = ctext;\n\treturn ret_len;\n\nerror:\n\tEVP_CIPHER_CTX_free(ctx);\n\tif (!*out)\n\t\tfree(ctext);\n\tdie(\"Failed to encrypt data.\");\n\n}\n\nsize_t cipher_aes_encrypt(const char *plaintext,\n\t\t\t  const unsigned char key[KDF_HASH_LEN],\n\t\t\t  unsigned char **out)\n{\n\tunsigned char *ciphertext;\n\tunsigned char *tmp;\n\tunsigned char iv[AES_BLOCK_SIZE];\n\tint in_len;\n\tsize_t len;\n\n\tif (!RAND_bytes(iv, AES_BLOCK_SIZE))\n\t\tdie(\"Could not generate random bytes for CBC IV.\");\n\n\tin_len = strlen(plaintext);\n\n\tciphertext = xcalloc(in_len + AES_BLOCK_SIZE * 2 + 1, 1);\n\tciphertext[0] = '!';\n\tlen = 1;\n\n\tmemcpy(ciphertext + len, iv, AES_BLOCK_SIZE);\n\tlen += AES_BLOCK_SIZE;\n\n\ttmp = ciphertext + len;\n\tlen += cipher_aes_encrypt_bytes((unsigned char *)plaintext, in_len,\n\t\t\t\t\tkey, iv, &tmp);\n\n\t*out = ciphertext;\n\treturn len;\n}\n\nstatic char *base64(const unsigned char *bytes, size_t len)\n{\n\tBIO *memory, *b64;\n\tBUF_MEM *buffer;\n\tchar *output;\n\n\tb64 = BIO_new(BIO_f_base64());\n\tBIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n\tmemory = BIO_new(BIO_s_mem());\n\tif (!b64 || !memory)\n\t\tgoto error;\n\tb64 = BIO_push(b64, memory);\n\tif (!b64)\n\t\tgoto error;\n\tif (BIO_write(b64, bytes, len) < 0 || BIO_flush(b64) < 0)\n\t\tgoto error;\n\n\tBIO_get_mem_ptr(b64, &buffer);\n\toutput = xmalloc(buffer->length + 1);\n\tmemcpy(output, buffer->data, buffer->length);\n\toutput[buffer->length] = '\\0';\n\n\tBIO_free_all(b64);\n\treturn output;\n\nerror:\n\tdie(\"Could not base64 the given bytes.\");\n}\n\nchar *cipher_base64(const unsigned char *bytes, size_t len)\n{\n\t_cleanup_free_ char *iv = NULL;\n\t_cleanup_free_ char *data = NULL;\n\tchar *output;\n\n\tif (len >= 33 && bytes[0] == '!' && len % 16 == 1) {\n\t\tiv = base64(bytes + 1, 16);\n\t\tdata = base64(bytes + 17, len - 17);\n\t\txasprintf(&output, \"!%s|%s\", iv, data);\n\t\treturn output;\n\t}\n\treturn base64(bytes, len);\n}\n\nsize_t unbase64(const char *bytes, unsigned char **unbase64)\n{\n\tsize_t len;\n\tBIO *memory, *b64;\n\tunsigned char *buffer;\n\n\tlen = strlen(bytes);\n\tif (!len)\n\t\tgoto error;\n\tb64 = BIO_new(BIO_f_base64());\n\tmemory = BIO_new_mem_buf((char *)bytes, len);\n\tif (!b64 || !memory)\n\t\tgoto error;\n\tb64 = BIO_push(b64, memory);\n\tif (!b64)\n\t\tgoto error;\n\tBIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n\tbuffer = xcalloc(len + 1, 1);\n\tlen = BIO_read(b64, buffer, len);\n\tif ((int)len <= 0)\n\t\tgoto error;\n\tbuffer[len] = '\\0';\n\n\tBIO_free_all(b64);\n\t*unbase64 = buffer;\n\treturn len;\n\nerror:\n\tdie(\"Could not unbase64 the given bytes.\");\n}\n\nsize_t cipher_unbase64(const char *ciphertext, unsigned char **b64data)\n{\n\t_cleanup_free_ char *copy = NULL;\n\t_cleanup_free_ unsigned char *iv = NULL;\n\t_cleanup_free_ unsigned char *data = NULL;\n\tunsigned char *unbase64_ciphertext = NULL;\n\tchar *pipe;\n\tsize_t iv_len, data_len, len;\n\n\tif (!strlen(ciphertext))\n\t\treturn 0;\n\n\tif (ciphertext[0] != '!')\n\t\treturn unbase64(ciphertext, b64data);\n\n\tcopy = xstrdup(&ciphertext[1]);\n\tpipe = strchr(copy, '|');\n\tif (!pipe)\n\t\treturn 0;\n\t*pipe = '\\0';\n\tiv_len = unbase64(copy, &iv);\n\tdata_len = unbase64(pipe + 1, &data);\n\tlen = iv_len + data_len + 1 /* '!' */;\n\tunbase64_ciphertext = xcalloc(len, 1);\n\tunbase64_ciphertext[0] = '!';\n\tmemcpy(&unbase64_ciphertext[1], iv, iv_len);\n\tmemcpy(&unbase64_ciphertext[1 + iv_len], data, data_len);\n\n\t*b64data = unbase64_ciphertext;\n\treturn len;\n}\n\nchar *cipher_aes_decrypt_base64(const char *ciphertext, const unsigned char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ unsigned char *unbase64_ciphertext = NULL;\n\tsize_t len;\n\n\tlen = cipher_unbase64(ciphertext, &unbase64_ciphertext);\n\tif (!len)\n\t\treturn NULL;\n\n\treturn cipher_aes_decrypt(unbase64_ciphertext, len, key);\n}\n\nchar *encrypt_and_base64(const char *str, unsigned const char key[KDF_HASH_LEN])\n{\n\tunsigned char *intermediate = NULL;\n\tchar *base64 = NULL;\n\tsize_t len;\n\n\tbase64 = xstrdup(str);\n\tif (!*base64)\n\t\treturn base64;\n\n\tlen = cipher_aes_encrypt(base64, key, &intermediate);\n\tfree(base64);\n\tbase64 = cipher_base64(intermediate, len);\n\tfree(intermediate);\n\treturn base64;\n}\n\n/*\n * Decrypt the LastPass sharing RSA private key.  The key has start_str\n * and end_str prepended / appended before encryption, and the result\n * is encrypted with the AES key.\n *\n * On success, the resulting key is stored in out_key and mlock()ed.\n * If there is a non-fatal error (or no key), the resulting structure\n * will have len = 0.\n */\nvoid cipher_decrypt_private_key(const char *key_hex,\n\t\t\t\tunsigned const char key[KDF_HASH_LEN],\n\t\t\t\tstruct private_key *out_key)\n{\n\tsize_t len;\n\t_cleanup_free_ unsigned char *encrypted_key = NULL;\n\t_cleanup_free_ char *decrypted_key = NULL;\n\tunsigned char *encrypted_key_start;\n\tchar *start, *end;\n\tunsigned char *dec_key = NULL;\n\tint ret;\n\n\t#define start_str LP_PKEY_PREFIX\n\t#define end_str LP_PKEY_SUFFIX\n\n\tmemset(out_key, 0, sizeof(*out_key));\n\n\tlen = strlen(key_hex);\n\tif (!len)\n\t\treturn;\n\n\tif (key_hex[0] == '!') {\n\t\t/* v2 format */\n\t\tdecrypted_key = cipher_aes_decrypt_base64(\n\t\t\tkey_hex, key);\n\t} else {\n\t\tif (len % 2 != 0)\n\t\t\tdie(\"Key hex in wrong format.\");\n\t\tlen /= 2;\n\n\t\t/* v1 format */\n\t\tlen += 16 /* IV */ + 1 /* bang symbol */;\n\t\tencrypted_key = xcalloc(len + 1, 1);\n\t\tencrypted_key[0] = '!';\n\t\tmemcpy(&encrypted_key[1], key, 16);\n\t\tencrypted_key_start = &encrypted_key[17];\n\t\thex_to_bytes(key_hex, &encrypted_key_start);\n\t\tdecrypted_key = cipher_aes_decrypt(encrypted_key, len, key);\n\t}\n\n\tif (!decrypted_key) {\n\t\twarn(\"Could not decrypt private key.\");\n\t\treturn;\n\t}\n\n\tstart = strstr(decrypted_key, start_str);\n\tend = strstr(decrypted_key, end_str);\n\tif (!start || !end || end <= start) {\n\t\twarn(\"Could not decode decrypted private key.\");\n\t\treturn;\n\t}\n\n\tstart += strlen(start_str);\n\t*end = '\\0';\n\n\tret = hex_to_bytes(start, &dec_key);\n\tif (ret)\n\t\tdie(\"Invalid private key after decryption and decoding.\");\n\n\tout_key->key = dec_key;\n\tout_key->len = strlen(start) / 2;\n\tmlock(out_key->key, out_key->len);\n\n\t#undef start_str\n\t#undef end_str\n}\n\n/*\n * Encrypt RSA sharing key.  Encrypted key is returned as a base64 string.\n */\nchar *cipher_encrypt_private_key(struct private_key *private_key,\n\t\t\t\t unsigned const char key[KDF_HASH_LEN])\n{\n\tunsigned char *key_ptext;\n\tunsigned char *ctext = NULL;\n\tchar *key_hex_dst;\n\tchar *encrypted_base64 = NULL;\n\tsize_t len, ctext_len, hex_len;\n\n\tif (!private_key->len)\n\t\treturn xstrdup(\"\");\n\n\thex_len = private_key->len * 2;\n\tlen = strlen(LP_PKEY_PREFIX) + hex_len + strlen(LP_PKEY_SUFFIX);\n\n\tkey_ptext = xcalloc(len + 1, 1);\n\tmemcpy(key_ptext, LP_PKEY_PREFIX, strlen(LP_PKEY_PREFIX));\n\n\tkey_hex_dst = (char *) key_ptext + strlen(LP_PKEY_PREFIX);\n\tbytes_to_hex(private_key->key, &key_hex_dst, private_key->len);\n\n\tmemcpy(key_ptext + strlen(LP_PKEY_PREFIX) + hex_len,\n\t       LP_PKEY_SUFFIX, strlen(LP_PKEY_SUFFIX));\n\t\n\tctext_len = cipher_aes_encrypt(key_ptext, key, &ctext);\n\n\tencrypted_base64 = cipher_base64(ctext, ctext_len);\n\n\tfree(ctext);\n\tfree(key_ptext);\n\n\treturn encrypted_base64;\n}\n\n/*\n * Get hex-encoded sha256() of a buffer.\n */\nchar *cipher_sha256_hex(unsigned char *bytes, size_t len)\n{\n\tchar *tmp = NULL;\n\tSHA256_CTX sha256;\n\tunsigned char hash[SHA256_DIGEST_LENGTH];\n\n\tif (!SHA256_Init(&sha256))\n\t\tgoto die;\n\tif (!SHA256_Update(&sha256, bytes, len))\n\t\tgoto die;\n\tif (!SHA256_Final(hash, &sha256))\n\t\tgoto die;\n\n\tbytes_to_hex(hash, &tmp, sizeof(hash));\n\treturn tmp;\ndie:\n\tdie(\"SHA-256 hash failed\");\n}\n\nchar *cipher_sha256_b64(unsigned char *bytes, size_t len)\n{\n\t_cleanup_free_ unsigned char *hash_raw = NULL;\n\t_cleanup_free_ char *hash_hex = NULL;\n\n\thash_hex = cipher_sha256_hex(bytes, len);\n\thex_to_bytes(hash_hex, &hash_raw);\n\treturn base64(hash_raw, strlen(hash_hex) / 2);\n}\n\n/*\n * Get hex-encoded sha256() for multiple arguments.\n */\nchar *cipher_multi_sha256_hex(int num_args, ...)\n{\n\tva_list args;\n\tchar *hash_hex = NULL;\n\tunsigned char hash[SHA256_DIGEST_LENGTH];\n\tconst EVP_MD *md_sha256;\n\tEVP_MD_CTX *sha256_ctx;\n\n\tva_start(args, num_args);\n\n\tsha256_ctx = EVP_MD_CTX_create();\n\tmd_sha256 = EVP_sha256();\n\tif (!md_sha256)\n\t\tgoto error;\n\n\tif (!EVP_DigestInit_ex(sha256_ctx, md_sha256, NULL))\n\t\tgoto error;\n\n\tfor (int i = 0; i < num_args; i++) {\n\t\tchar *arg = va_arg(args, char *);\n\t\tif (!EVP_DigestUpdate(sha256_ctx, arg, strlen(arg)))\n\t\t\tgoto error;\n\t}\n\t\n\tif (!EVP_DigestFinal_ex(sha256_ctx, hash, 0))\n\t\tgoto error;\n\n\tbytes_to_hex(hash, &hash_hex, sizeof(hash));\n\tEVP_MD_CTX_free(sha256_ctx);\n\n\treturn hash_hex;\n\nerror:\n\tEVP_MD_CTX_free(sha256_ctx);\n\tdie(\"SHA-256 hash failed\");\n}\n"
        },
        {
          "name": "cipher.h",
          "type": "blob",
          "size": 1.490234375,
          "content": "#ifndef CIPHER_H\n#define CIPHER_H\n\n#include \"kdf.h\"\n#include \"session.h\"\n\nchar *cipher_rsa_decrypt(const unsigned char *ciphertext, size_t len, const struct private_key *private_key);\nint cipher_rsa_encrypt_bytes(const unsigned char *plaintext,\n\t\t\t     size_t in_len,\n\t\t\t     const struct public_key *public_key,\n\t\t\t     unsigned char *out_crypttext, size_t *out_len);\nint cipher_rsa_encrypt(const char *plaintext,\n\t\t       const struct public_key *public_key,\n\t\t       unsigned char *out_crypttext, size_t *out_len);\nchar *cipher_aes_decrypt(const unsigned char *ciphertext, size_t len, const unsigned char key[KDF_HASH_LEN]);\nchar *cipher_aes_decrypt_base64(const char *ciphertext, const unsigned char key[KDF_HASH_LEN]);\nsize_t cipher_aes_encrypt(const char *plaintext, const unsigned char key[KDF_HASH_LEN], unsigned char **ciphertext);\nchar *cipher_base64(const unsigned char *bytes, size_t len);\nsize_t cipher_unbase64(const char *ciphertext, unsigned char **b64data);\nsize_t unbase64(const char *ptext, unsigned char **b64data);\nchar *encrypt_and_base64(const char *str, unsigned const char key[KDF_HASH_LEN]);\nvoid cipher_decrypt_private_key(const char *key_hex, unsigned const char key[KDF_HASH_LEN], struct private_key *out_key);\nchar *cipher_encrypt_private_key(struct private_key *private_key,\n\t\t\t\t unsigned const char key[KDF_HASH_LEN]);\nchar *cipher_sha256_hex(unsigned char *bytes, size_t len);\nchar *cipher_sha256_b64(unsigned char *bytes, size_t len);\nchar *cipher_multi_sha256_hex(int num_args, ...);\n#endif\n"
        },
        {
          "name": "clipboard.c",
          "type": "blob",
          "size": 3.349609375,
          "content": "/*\n * system copy/paste routines\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n\n#include \"clipboard.h\"\n#include \"util.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\nstatic pid_t clipboard_process = 0;\nstatic int saved_stdout = -1; \nstatic bool registered_closer = false;\n\nvoid clipboard_close(void)\n{\n\tif (!clipboard_process || saved_stdout < 0)\n\t\treturn;\n\n\tfflush(stdout);\n\tdup2(saved_stdout, STDOUT_FILENO);\n\tclose(saved_stdout);\n\twaitpid(clipboard_process, NULL, 0);\n\tclipboard_process = 0;\n\tsaved_stdout = -1;\n}\n\nvoid exec_command(char *command) {\n\tchar *shell = getenv(\"SHELL\");\n\n\tif (!shell) {\n\t\tshell = \"/bin/sh\";\n\t}\n\n\texeclp(shell, shell, \"-c\", command, NULL);\n}\n\nvoid clipboard_open(void)\n{\n\tint pipefd[2];\n\n\tif (clipboard_process > 0)\n\t\treturn;\n\n\tif (pipe(pipefd) < 0)\n\t\tdie_errno(\"pipe\");\n\tsaved_stdout = dup(STDOUT_FILENO);\n\tif (saved_stdout < 0)\n\t\tdie_errno(\"dup\");\n\tclipboard_process = fork();\n\tif (clipboard_process == -1)\n\t\tdie_errno(\"fork\");\n\tif (!clipboard_process) {\n\t\tclose(pipefd[1]);\n\t\tdup2(pipefd[0], STDIN_FILENO);\n\t\tclose(pipefd[0]);\n\t\tchar *clipboard_command = getenv(\"LPASS_CLIPBOARD_COMMAND\");\n\t\tif (clipboard_command) {\n\t\t\texec_command(clipboard_command);\n\t\t\tdie(\"Unable to copy contents to clipboard. Please make sure you have `wl-clip`, `xclip`, `xsel`, `pbcopy`, or `putclip` installed.\");\n\t\t} else {\n\t\t\texeclp(\"wl-copy\", \"wl-copy\", NULL);\n\t\t\texeclp(\"xclip\", \"xclip\", \"-selection\", \"clipboard\", \"-in\", NULL);\n\t\t\texeclp(\"xsel\", \"xsel\", \"--clipboard\", \"--input\", NULL);\n\t\t\texeclp(\"pbcopy\", \"pbcopy\", NULL);\n\t\t\texeclp(\"putclip\", \"putclip\", \"--dos\", NULL);\n\t\t\tdie(\"Unable to copy contents to clipboard. Please make sure you have `xclip`, `xsel`, `pbcopy`, or `putclip` installed.\");\n\t\t}\n\t}\n\tclose(pipefd[0]);\n\tdup2(pipefd[1], STDOUT_FILENO);\n\tclose(pipefd[1]);\n\n\tif (!registered_closer) {\n\t\tatexit(clipboard_close);\n\t\tregistered_closer = true;\n\t}\n}\n"
        },
        {
          "name": "clipboard.h",
          "type": "blob",
          "size": 0.1015625,
          "content": "#ifndef CLIPBOARD_H\n#define CLIPBOARD_H\n\nvoid clipboard_open(void);\nvoid clipboard_close(void);\n\n#endif\n"
        },
        {
          "name": "cmake_extras",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd-add.c",
          "type": "blob",
          "size": 3.939453125,
          "content": "/*\n * command for adding vault entries\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"agent.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n\nint cmd_add(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"username\", no_argument, NULL, 'u'},\n\t\t{\"password\", no_argument, NULL, 'p'},\n\t\t{\"url\", no_argument, NULL, 'L'},\n\t\t{\"field\", required_argument, NULL, 'F'},\n\t\t{\"notes\", no_argument, NULL, 'O'},\n\t\t{\"app\", no_argument, NULL, 'a'},\n\t\t{\"non-interactive\", no_argument, NULL, 'X'},\n\t\t{\"note-type\", required_argument, NULL, 'T'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\t_cleanup_free_ char *field = NULL;\n\tchar *name;\n\tbool non_interactive = false;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tenum edit_choice choice = EDIT_ANY;\n\tenum note_type note_type = NOTE_TYPE_NONE;\n\tbool is_app = false;\n\n\t#define ensure_choice() if (choice != EDIT_ANY) goto choice_die;\n\twhile ((option = getopt_long(argc, argv, \"up\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_USERNAME;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_PASSWORD;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_URL;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_FIELD;\n\t\t\t\tfield = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'O':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_NOTES;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tnon_interactive = true;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tis_app = true;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tnote_type = parse_note_type_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_add_usage);\n\t\t}\n\t}\n\t#undef ensure_choice\n\n\tif (argc - optind != 1)\n\t\tdie_usage(cmd_add_usage);\n\tif (choice == EDIT_NONE)\n\t\tchoice_die: die_usage(\"add ... {--username|--password|--url|--notes|--field=FIELD|--note-type=NOTE_TYPE}\");\n\tname = argv[optind];\n\n\tinit_all(sync, key, &session, &blob);\n\n\treturn edit_new_account(session, blob, sync, name, choice, field,\n\t\t\t\tnon_interactive, is_app, note_type, key);\n}\n"
        },
        {
          "name": "cmd-duplicate.c",
          "type": "blob",
          "size": 3.7724609375,
          "content": "/*\n * command for making copies of vault entries\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"blob.h\"\n#include \"endpoints.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n\nint cmd_duplicate(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tchar *name;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tstruct account *found, *new;\n\tstruct field *field, *copy_field;\n\n\twhile ((option = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_duplicate_usage);\n\t\t}\n\t}\n\n\tif (argc - optind != 1)\n\t\tdie_usage(cmd_duplicate_usage);\n\tname = argv[optind];\n\n\tinit_all(sync, key, &session, &blob);\n\n\tfound = find_unique_account(blob, name);\n\tif (!found)\n\t\tdie(\"Could not find specified account '%s'.\", name);\n\n\tnew = new_account();\n\tnew->share = found->share;\n\tnew->id = xstrdup(\"0\");\n\taccount_set_name(new, xstrdup(found->name), key);\n\taccount_set_group(new, xstrdup(found->group), key);\n\taccount_set_username(new, xstrdup(found->username), key);\n\taccount_set_password(new, xstrdup(found->password), key);\n\taccount_set_note(new, xstrdup(found->note), key);\n\tnew->fullname = xstrdup(found->fullname);\n\taccount_set_url(new, xstrdup(found->url), key, &session->feature_flag);\n\tnew->pwprotect = found->pwprotect;\n\n\tlist_for_each_entry(field, &found->field_head, list) {\n\t\tcopy_field = new0(struct field, 1);\n\t\tcopy_field->type = xstrdup(field->type);\n\t\tcopy_field->name = xstrdup(field->name);\n\t\tfield_set_value(found, copy_field, xstrdup(field->value), key);\n\t\tcopy_field->checked = field->checked;\n\t\tlist_add_tail(&copy_field->list, &new->field_head);\n\t}\n\n\tlist_add(&new->list, &blob->account_head);\n\n\tlastpass_update_account(sync, key, session, new, blob);\n\tblob_save(blob, key, &session->feature_flag);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-edit.c",
          "type": "blob",
          "size": 4.1728515625,
          "content": "/*\n * command for editing vault entries\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"agent.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n\nint cmd_edit(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"username\", no_argument, NULL, 'u'},\n\t\t{\"password\", no_argument, NULL, 'p'},\n\t\t{\"url\", no_argument, NULL, 'L'},\n\t\t{\"field\", required_argument, NULL, 'F'},\n\t\t{\"name\", no_argument, NULL, 'N'},\n\t\t{\"notes\", no_argument, NULL, 'O'},\n\t\t{\"non-interactive\", no_argument, NULL, 'X'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\t_cleanup_free_ char *field = NULL;\n\tchar *name;\n\tbool non_interactive = false;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tstruct account *editable;\n\tenum edit_choice choice = EDIT_ANY;\n\tenum note_type note_type = NOTE_TYPE_NONE;\n\n\t#define ensure_choice() if (choice != EDIT_ANY) goto choice_die;\n\twhile ((option = getopt_long(argc, argv, \"up\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_USERNAME;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_PASSWORD;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_URL;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_FIELD;\n\t\t\t\tfield = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_NAME;\n\t\t\t\tbreak;\n\t\t\tcase 'O':\n\t\t\t\tensure_choice();\n\t\t\t\tchoice = EDIT_NOTES;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tnon_interactive = true;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_edit_usage);\n\t\t}\n\t}\n\t#undef ensure_choice\n\n\tif (argc - optind != 1)\n\t\tdie_usage(cmd_edit_usage);\n\tif (choice == EDIT_NONE)\n\t\tchoice_die: die_usage(\"edit ... {--name|--username|--password|--url|--notes|--field=FIELD}\");\n\tname = argv[optind];\n\n\tinit_all(sync, key, &session, &blob);\n\n\teditable = find_unique_account(blob, name);\n\tif (!editable)\n\t\treturn edit_new_account(session, blob, sync, name, choice,\n\t\t\t\t\tfield, non_interactive, false,\n\t\t\t\t\tnote_type, key);\n\n\tif (editable->share && editable->share->readonly)\n\t\tdie(\"%s is a readonly shared entry from %s. It cannot be edited.\",\n\t\t    editable->fullname, editable->share->name);\n\n\treturn edit_account(session, blob, sync, editable, choice, field,\n\t\t\t    non_interactive, key);\n}\n"
        },
        {
          "name": "cmd-export.c",
          "type": "blob",
          "size": 6.42578125,
          "content": "/*\n * command for exporting vault entries into CSV format\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"blob.h\"\n#include \"endpoints.h\"\n#include \"agent.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nstruct field_selection {\n\tconst char *name;\n\tstruct list_head list;\n};\n\nstatic void parse_field_arg(char *arg, struct list_head *head)\n{\n\tchar *token;\n\tfor (token = strtok(arg, \",\"); token; token = strtok(NULL, \",\")) {\n\t\tstruct field_selection *sel = new0(struct field_selection, 1);\n\t\tsel->name = token;\n\t\tlist_add_tail(&sel->list, head);\n\t}\n}\n\nstatic void print_csv_cell(const char *cell, bool is_last)\n{\n\tconst char *ptr;\n\tbool needs_quote = false;\n\n\tcell = cell == NULL ? \"\" : cell;\n\n\t/* decide if we need quoting */\n\tfor (ptr = cell; *ptr; ptr++) {\n\t\tif (*ptr == '\"' || *ptr == ',' || *ptr == '\\n' || *ptr == '\\r') {\n\t\t\tneeds_quote = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (needs_quote)\n\t\tputchar('\"');\n\n\tfor (ptr = cell; *ptr; ptr++) {\n\t\tputchar(*ptr);\n\t\tif (*ptr == '\"')\n\t\t\tputchar('\"');\n\t}\n\n\tif (needs_quote)\n\t\tputchar('\"');\n\n\tif (is_last)\n\t\tprintf(\"\\r\\n\");\n\telse\n\t\tprintf(\",\");\n}\n\nvoid print_csv_field(struct account *account, const char *field_name,\n\t\t     bool is_last)\n{\n\t_cleanup_free_ char *share_group = NULL;\n\tchar *groupname = account->group;\n\n#define OUTPUT_FIELD(name, value, is_last) \\\n\tdo { \\\n\t\tif (!strcmp(field_name, name)) { \\\n\t\t\tprint_csv_cell(value, is_last); \\\n\t\t\treturn; \\\n\t\t} \\\n\t} while(0)\n\n\tOUTPUT_FIELD(\"url\", account->url, is_last);\n\tOUTPUT_FIELD(\"username\", account->username, is_last);\n\tOUTPUT_FIELD(\"password\", account->password, is_last);\n\tOUTPUT_FIELD(\"extra\", account->note, is_last);\n\tOUTPUT_FIELD(\"name\", account->name, is_last);\n\tOUTPUT_FIELD(\"fav\", bool_str(account->fav), is_last);\n\tOUTPUT_FIELD(\"id\", account->id, is_last);\n\tOUTPUT_FIELD(\"group\", account->group, is_last);\n\tOUTPUT_FIELD(\"fullname\", account->fullname, is_last);\n\tOUTPUT_FIELD(\"last_touch\", account->last_touch, is_last);\n\tOUTPUT_FIELD(\"last_modified_gmt\", account->last_modified_gmt, is_last);\n\tOUTPUT_FIELD(\"attachpresent\", bool_str(account->attachpresent), is_last);\n\n\tif (!strcmp(field_name, \"grouping\")) {\n\t\tif (account->share) {\n\t\t\txasprintf(&share_group, \"%s\\\\%s\",\n\t\t\t\t  account->share->name, account->group);\n\n\t\t\t/* trim trailing backslash if no subfolder */\n\t\t\tif (!strlen(account->group))\n\t\t\t\tshare_group[strlen(share_group)-1] = '\\0';\n\n\t\t\tgroupname = share_group;\n\t\t}\n\t\tprint_csv_cell(groupname, is_last);\n\t\treturn;\n\t}\n\n\t/* unknown field, just return empty string */\n\tprint_csv_cell(\"\", is_last);\n}\n\nint cmd_export(int argc, char **argv)\n{\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{\"fields\", required_argument, NULL, 'f'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tstruct account *account;\n\tconst char *default_fields[] = {\n\t\t\"url\", \"username\", \"password\", \"extra\",\n\t\t\"name\", \"grouping\", \"fav\"\n\t};\n\n\tLIST_HEAD(field_list);\n\n\twhile ((option = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tparse_field_arg(optarg, &field_list);\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_export_usage);\n\t\t}\n\t}\n\n\tif (list_empty(&field_list)) {\n\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(default_fields); i++) {\n\t\t\tstruct field_selection *sel = new0(struct field_selection, 1);\n\t\t\tsel->name = default_fields[i];\n\t\t\tlist_add_tail(&sel->list, &field_list);\n\t\t}\n\t}\n\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstruct field_selection *field_sel, *tmp;\n\n\tinit_all(sync, key, &session, &blob);\n\n\t/* reprompt once if any one account is password protected */\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tif (account->pwprotect) {\n\t\t\tunsigned char pwprotect_key[KDF_HASH_LEN];\n\t\t\tif (!agent_load_key(pwprotect_key))\n\t\t\t\tdie(\"Could not authenticate for protected entry.\");\n\t\t\tif (memcmp(pwprotect_key, key, KDF_HASH_LEN))\n\t\t\t\tdie(\"Current key is not on-disk key.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstruct field_selection *last_entry =\n\t\tlist_last_entry_or_null(&field_list, struct field_selection, list);\n\n\t/* header */\n\tlist_for_each_entry(field_sel, &field_list, list) {\n\t\tprint_csv_cell(field_sel->name, field_sel == last_entry);\n\t}\n\n\t/* entries */\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\n\t\t/* skip groups */\n\t\tif (!strcmp(account->url, \"http://group\"))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(field_sel, &field_list, list) {\n\t\t\tprint_csv_field(account, field_sel->name,\n\t\t\t\t\tfield_sel == last_entry);\n\t\t}\n\t\tlastpass_log_access(sync, session, key, account);\n\t}\n\n\tlist_for_each_entry_safe(field_sel, tmp, &field_list, list) {\n\t\tfree(field_sel);\n\t}\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-generate.c",
          "type": "blob",
          "size": 4.9306640625,
          "content": "/*\n * command for generating passwords\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"clipboard.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic char chars[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890`~!@#$%^&*()-_=+[{]}\\\\|;:'\\\",<.>/?\";\n#define ALL_CHARS_LEN (sizeof(chars) - 1)\n#define NICE_CHARS_LEN 62\n\nint cmd_generate(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"username\", required_argument, NULL, 'U'},\n\t\t{\"url\", required_argument, NULL, 'L'},\n\t\t{\"no-symbols\", no_argument, NULL, 'X'},\n\t\t{\"clip\", no_argument, NULL, 'c'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tchar *username = NULL;\n\tchar *url = NULL;\n\tbool no_symbols = false;\n\tunsigned long length;\n\tchar *name;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\t_cleanup_free_ char *password = NULL;\n\tstruct account *new = NULL, *found;\n\tstruct account *notes_expansion, *notes_collapsed = NULL;\n\tbool clip = false;\n\n\twhile ((option = getopt_long(argc, argv, \"c\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tusername = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\turl = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tno_symbols = true;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tclip = true;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_generate_usage);\n\t\t}\n\t}\n\n\tif (argc - optind != 2)\n\t\tdie_usage(cmd_generate_usage);\n\tname = argv[optind];\n\tlength = strtoul(argv[optind + 1], NULL, 10);\n\tif (!length)\n\t\tdie_usage(cmd_generate_usage);\n\n\tinit_all(sync, key, &session, &blob);\n\n\tpassword = xcalloc(length + 1, 1);\n\tfor (size_t i = 0; i < length; ++i)\n\t\tpassword[i] = chars[range_rand(0, no_symbols ? NICE_CHARS_LEN : ALL_CHARS_LEN)];\n\n\tfound = find_unique_account(blob, name);\n\tif (found) {\n\t\tif (found->share && found->share->readonly)\n\t\t\tdie(\"%s is a readonly shared entry from %s. It cannot be edited.\", found->fullname, found->share->name);\n\t\tnotes_expansion = notes_expand(found);\n\t\tif (notes_expansion) {\n\t\t\tnotes_collapsed = found;\n\t\t\tfound = notes_expansion;\n\t\t}\n\t\taccount_set_password(found, xstrdup(password), key);\n\t\tif (username)\n\t\t\taccount_set_username(found, username, key);\n\t\tif (url) {\n\t\t\taccount_set_url(found, xstrdup(url), key, &session->feature_flag);\n\t\t}\n\t\tif (notes_expansion && notes_collapsed) {\n\t\t\tfound = notes_collapsed;\n\t\t\tnotes_collapsed = notes_collapse(notes_expansion);\n\t\t\taccount_free(notes_expansion);\n\t\t\taccount_set_note(found, xstrdup(notes_collapsed->note), key);\n\t\t\taccount_free(notes_collapsed);\n\t\t}\n\t} else {\n\t\tnew = new_account();\n\t\tnew->id = xstrdup(\"0\");\n\t\taccount_set_password(new, xstrdup(password), key);\n\t\taccount_set_fullname(new, xstrdup(name), key);\n\t\taccount_set_username(new, username ? username : xstrdup(\"\"), key);\n\t\taccount_set_note(new, xstrdup(\"\"), key);\n\t\taccount_set_url(new, url ? url : xstrdup(\"\"), key, &session->feature_flag);\n\t\taccount_assign_share(blob, new, key, &session->feature_flag);\n\n\t\tlist_add(&new->list, &blob->account_head);\n\t}\n\n\tlastpass_update_account(sync, key, session, found ? found : new, blob);\n\tblob_save(blob, key, &session->feature_flag);\n\n\tif (clip)\n\t\tclipboard_open();\n\n\tprintf(\"%s\\n\", password);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-import.c",
          "type": "blob",
          "size": 9.7080078125,
          "content": "/*\n * command for importing vault entries from CSV file into the vault\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"blob.h\"\n#include \"endpoints.h\"\n#include \"agent.h\"\n#include \"list.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <search.h>\n\nstruct csv_record {\n\tstruct list_head field_head;\n\tstruct list_head list;\n};\n\nstruct csv_field {\n\tchar *value;\n\tstruct list_head list;\n};\n\nenum csv_token {\n\tCSV_NONE,\n\tCSV_FIELD,\n\tCSV_NL,\n\tCSV_EOF\n};\n\nstatic enum csv_token csv_next_token(FILE *fp, char **retp)\n{\n\tint ch, nextch;\n\tbool readch = false;\n\tbool in_quote = false;\n\tbool done = false;\n\tbool eol = false;\n\tchar *rptr;\n\n\tstruct buffer result = {\n\t\t.len = 0,\n\t\t.max = 80,\n\t\t.bytes = NULL,\n\t};\n\tresult.bytes = xcalloc(result.max, 1);\n\n\t*retp = NULL;\n\twhile (!done) {\n\t\tch = fgetc(fp);\n\t\tif (ch == EOF)\n\t\t\tbreak;\n\n\t\treadch = true;\n\t\tswitch(ch)\n\t\t{\n\t\tcase '\\n':\n\t\tcase ',':\n\t\t\t/* non-quoted newline / comma terminate field */\n\t\t\tif (!in_quote) {\n\t\t\t\tdone = true;\n\t\t\t\teol = (ch == '\\n');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* otherwise append */\n\t\t\tbuffer_append_char(&result, ch);\n\t\t\tbreak;\n\n\t\tcase '\"':\n\t\t\t/*\n\t\t\t * quote immediately after comma starts a\n\t\t\t * double-quoted field\n\t\t\t */\n\t\t\tif (result.len == 0 && !in_quote) {\n\t\t\t\tin_quote = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (in_quote) {\n\t\t\t\t/*\n\t\t\t\t * inside a dqfield, two double quotes adds a\n\t\t\t\t * quote, print one\n\t\t\t\t */\n\t\t\t\tnextch = fgetc(fp);\n\t\t\t\tif (nextch == '\"') {\n\t\t\t\t\tbuffer_append_char(&result, '\"');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* otherwise terminate the quote */\n\t\t\t\tin_quote = false;\n\t\t\t\tungetc(nextch, fp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* quote not after a comma, treat as unescaped */\n\t\t\tbuffer_append_char(&result, ch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuffer_append_char(&result, ch);\n\t\t}\n\t}\n\n\tif (!readch)\n\t\treturn CSV_EOF;\n\n\trptr = result.bytes;\n\t/* trim cr/nl, but not spaces (they may be significant) */\n\twhile (rptr[strlen(rptr)-1] == '\\r' ||\n\t       rptr[strlen(rptr)-1] == '\\n') {\n\t\trptr[strlen(rptr)-1] = '\\0';\n\t}\n\t*retp = rptr;\n\n\tif (eol)\n\t\treturn CSV_NL;\n\n\treturn CSV_FIELD;\n}\n\nstatic struct csv_record *csv_record_new()\n{\n\tstruct csv_record *r;\n\n\tr = new0(struct csv_record, 1);\n\tINIT_LIST_HEAD(&r->field_head);\n\treturn r;\n}\n\n/*\n * Return a list of csv_record items from parsing a CSV file.\n */\nstatic void csv_parse(FILE *fp, struct list_head *list)\n{\n\tchar *p;\n\tenum csv_token token;\n\tstruct csv_record *record;\n\n\trecord = csv_record_new();\n\twhile ((token = csv_next_token(fp, &p))) {\n\t\tif (p) {\n\t\t\tstruct csv_field *field = new0(struct csv_field, 1);\n\t\t\tfield->value = p;\n\t\t\tlist_add_tail(&field->list, &record->field_head);\n\t\t}\n\t\tif (token == CSV_NL || token == CSV_EOF) {\n\t\t\tif (!list_empty(&record->field_head)) {\n\t\t\t\tlist_add_tail(&record->list, list);\n\t\t\t\trecord = csv_record_new();\n\t\t\t}\n\t\t}\n\t\tif (token == CSV_EOF)\n\t\t\tbreak;\n\t}\n\tfree(record);\n}\n\nstatic struct account *new_import_account(unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tstruct account *account = new_account();\n\n\taccount_set_url(account, xstrdup(\"\"), key, feature_flag);\n\taccount_set_username(account, xstrdup(\"\"), key);\n\taccount_set_password(account, xstrdup(\"\"), key);\n\taccount_set_note(account, xstrdup(\"\"), key);\n\taccount_set_name(account, xstrdup(\"\"), key);\n\taccount_set_group(account, xstrdup(\"\"), key);\n\n\treturn account;\n}\n\nstatic int csv_parse_accounts(FILE *fp, struct list_head *account_list,\n\t\t\t      unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tstruct list_head items;\n\tstruct csv_record *record, *tmp_record, *first;\n\tstruct csv_field *field, *tmp_field;\n\tint i = 0;\n\tint num_accounts = 0;\n\n\tint url_index = -1,\n\t    username_index = -1,\n\t    password_index = -1,\n\t    extra_index = -1,\n\t    name_index = -1,\n\t    grouping_index = -1,\n\t    fav_index = -1;\n\n\tINIT_LIST_HEAD(&items);\n\tcsv_parse(fp, &items);\n\n\tif (list_empty(&items))\n\t\treturn 0;\n\n#define set_field_index(x) \\\n\tdo { \\\n\t\tif (!strcmp(field->value, #x)) { \\\n\t\t\tx ## _index = i; \\\n\t\t} \\\n\t} while (0)\n\n#define set_field(x, fieldname) \\\n\tdo { \\\n\t\tif (i == x ## _index) { \\\n\t\t\taccount_set_ ## fieldname (account, field->value, key); \\\n\t\t\tset = true; \\\n\t\t} \\\n\t} while (0)\n\n#define set_field_ff(x, fieldname, feature_flag) \\\n\tdo { \\\n\t\tif (i == x ## _index) { \\\n\t\t\taccount_set_ ## fieldname (account, field->value, key, feature_flag); \\\n\t\t\tset = true; \\\n\t\t} \\\n\t} while (0)\n\n\t/*\n\t * first line should tell us the field matrix; if\n\t * it doesn't reveal anything useful then we won't\n\t * import anything\n\t */\n\trecord = list_first_entry(&items, struct csv_record, list);\n\tlist_for_each_entry(field, &record->field_head, list) {\n\t\tset_field_index(url);\n\t\tset_field_index(username);\n\t\tset_field_index(password);\n\t\tset_field_index(extra);\n\t\tset_field_index(name);\n\t\tset_field_index(grouping);\n\t\tset_field_index(fav);\n\t\ti++;\n\t}\n\n\tif (url_index == -1 && username_index == -1 &&\n\t    password_index == -1 && extra_index == -1 &&\n\t    name_index == -1 && grouping_index == -1 &&\n\t    fav_index == -1) {\n\t\tdie(\"Could not read the CSV header at the first line of the input file\");\n\t\treturn 0;\n\t}\n\n\tfirst = record;\n\tlist_for_each_entry(record, &items, list) {\n\t\tstruct account *account;\n\t\tif (record == first)\n\t\t\tcontinue;\n\n\t\taccount = new_import_account(key, feature_flag);\n\t\ti = 0;\n\t\tlist_for_each_entry(field, &record->field_head, list) {\n\t\t\tbool set = false;\n\t\t\tset_field_ff(url, url, feature_flag);\n\t\t\tset_field(username, username);\n\t\t\tset_field(password, password);\n\t\t\tset_field(name, name);\n\t\t\tset_field(grouping, group);\n\t\t\tset_field(extra, note);\n\t\t\tif (i == fav_index) {\n\t\t\t\taccount->fav = field->value[0] == '1';\n\t\t\t\tset = true;\n\t\t\t}\n\n\t\t\t/* free unknown field */\n\t\t\tif (!set)\n\t\t\t\tfree(field->value);\n\t\t\ti++;\n\t\t}\n\t\tnum_accounts++;\n\t\tlist_add_tail(&account->list, account_list);\n\t}\n\n\tlist_for_each_entry_safe(record, tmp_record, &items, list) {\n\t\tlist_for_each_entry_safe(field, tmp_field,\n\t\t\t\t\t &record->field_head, list) {\n\t\t\tfree(field);\n\t\t}\n\t\tfree(record);\n\t}\n\treturn num_accounts;\n}\n\n/* dedupe based on password / url / name / username sets */\nint csv_dedupe_compare(const void *k1, const void *k2)\n{\n\tconst struct account *a1 = k1, *a2 = k2;\n\tint r;\n\n\tif ((r = strcmp(a1->password, a2->password)))\n\t\treturn r;\n\tif ((r = strcmp(a1->username, a2->username)))\n\t\treturn r;\n\tif ((r = strcmp(a1->url, a2->url)))\n\t\treturn r;\n\treturn strcmp(a1->name, a2->name);\n}\n\nvoid csv_dedupe_accounts(struct list_head *blob_accounts,\n\t\t\t struct list_head *new_accounts)\n{\n\tstruct account *account, *tmp;\n\tvoid *search_tree = NULL;\n\n\tlist_for_each_entry(account, blob_accounts, list) {\n\t\ttsearch(account, &search_tree, csv_dedupe_compare);\n\t}\n\n\tlist_for_each_entry_safe(account, tmp, new_accounts, list) {\n\t\tif (tfind(account, &search_tree, csv_dedupe_compare)) {\n\t\t\tlist_del(&account->list);\n\t\t\taccount_free(account);\n\t\t}\n\t}\n}\n\nint cmd_import(int argc, char **argv)\n{\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"keep-dupes\", no_argument, NULL, 'k'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tunsigned char key[KDF_HASH_LEN];\n\t_cleanup_fclose_ FILE *fp;\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstruct list_head accounts;\n\tstruct account *account;\n\tint count, new_count;\n\tbool keep_dupes = false;\n\tint ret;\n\n\twhile ((option = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\tcase 'S':\n\t\t\tsync = parse_sync_string(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkeep_dupes = true;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tdie_usage(cmd_import_usage);\n\t\t}\n\t}\n\n\tif (argc - optind < 1) {\n\t\tfp = stdin;\n\t} else {\n\t\tchar *filename = argv[optind];\n\t\tfp = fopen(filename, \"rb\");\n\t\tif (!fp)\n\t\t\tdie(\"Unable to open %s\", filename);\n\t}\n\n\tinit_all(sync, key, &session, &blob);\n\n\tINIT_LIST_HEAD(&accounts);\n\tcount = csv_parse_accounts(fp, &accounts, key, &session->feature_flag);\n\n\tprintf(\"Parsed %d accounts\\n\", count);\n\n\tnew_count = 0;\n\tif (!keep_dupes)\n\t\tcsv_dedupe_accounts(&blob->account_head, &accounts);\n\n\tlist_for_each_entry(account, &accounts, list) {\n\t\tnew_count++;\n\t};\n\n\tif (count - new_count)\n\t\tprintf(\"Removed %d duplicate accounts\\n\", count - new_count);\n\n\tret = lastpass_upload(session, &accounts);\n\tif (ret)\n\t\tdie(\"Import failed (%d)\\n\", ret);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-login.c",
          "type": "blob",
          "size": 4.1689453125,
          "content": "/*\n * command for logging into the service\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n\n#include \"cmd.h\"\n#include \"kdf.h\"\n#include \"password.h\"\n#include \"session.h\"\n#include \"util.h\"\n#include \"process.h\"\n#include \"endpoints.h\"\n#include \"config.h\"\n#include \"agent.h\"\n#include \"terminal.h\"\n#include <getopt.h>\n\nint cmd_login(int argc, char **argv)\n{\n\tstatic struct option long_options[] = {\n\t\t{\"trust\", no_argument, NULL, 't'},\n\t\t{\"plaintext-key\", no_argument, NULL, 'P'},\n\t\t{\"force\", no_argument, NULL, 'f'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tbool trust = false;\n\tbool plaintext_key = false;\n\tbool force = false;\n\tchar *username;\n\t_cleanup_free_ char *error = NULL;\n\t_cleanup_free_ char *password = NULL;\n\tint iterations;\n\tstruct session *session;\n\tunsigned char key[KDF_HASH_LEN];\n\tchar hex[KDF_HEX_LEN];\n\n\twhile ((option = getopt_long(argc, argv, \"f\", long_options, &option_index)) != -1) {\n\tswitch (option) {\n\t\tcase 't':\n\t\t\ttrust = true;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tplaintext_key = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tforce = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tterminal_set_color_mode(\n\t\t\t\tparse_color_mode_string(optarg));\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tdie_usage(cmd_login_usage);\n\t\t}\n\t}\n\tif (argc - optind != 1)\n\t\tdie_usage(cmd_login_usage);\n\n\tif (!force && plaintext_key && !ask_yes_no(false, \"You have used the --plaintext-key option. This option will greatly reduce the security of your passwords. You are advised, instead, to use the agent, whose timeout can be disabled by setting LPASS_AGENT_TIMEOUT=0. Are you sure you would like to do this?\"))\n\t\tdie(\"Login aborted. Try again without --plaintext-key.\");\n\n\tusername = argv[optind];\n\titerations = lastpass_iterations(username);\n\tif (!iterations)\n\t\tdie(\"Unable to fetch iteration count. Check your internet connection and be sure your username is valid.\");\n\n\tdo {\n\t\tfree(password);\n\t\tpassword = password_prompt(\"Master Password\", error, \"Please enter the LastPass master password for <%s>.\", username);\n\t\tif (!password)\n\t\t\tdie(\"Failed to enter correct password.\");\n\n\t\tkdf_login_key(username, password, iterations, hex);\n\t\tkdf_decryption_key(username, password, iterations, key);\n\n\t\tfree(error);\n\t\terror = NULL;\n\t\tsession = lastpass_login(username, hex, key, iterations, &error, trust);\n\t} while (!session_is_valid(session));\n\n\tconfig_unlink(\"plaintext_key\");\n\tif (plaintext_key)\n\t\tconfig_write_buffer(\"plaintext_key\", (char *)key, KDF_HASH_LEN);\n\n\tagent_save(username, iterations, key);\n\n\tsession_save(session, key);\n\tsession_free(session);\n\tsession = NULL;\n\n\tterminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD \"Success\" TERMINAL_RESET \": Logged in as \" TERMINAL_UNDERLINE \"%s\" TERMINAL_RESET \".\\n\", username);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-logout.c",
          "type": "blob",
          "size": 2.818359375,
          "content": "/*\n * command for logging out of LastPass\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"agent.h\"\n#include \"upload-queue.h\"\n#include \"endpoints.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint cmd_logout(int argc, char **argv)\n{\n\tstatic struct option long_options[] = {\n\t\t{\"force\", no_argument, NULL, 'f'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tbool force = false;\n\tstruct session *session = NULL;\n\tunsigned char key[KDF_HASH_LEN];\n\n\twhile ((option = getopt_long(argc, argv, \"f\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'f':\n\t\t\t\tforce = true;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_logout_usage);\n\t\t}\n\t}\n\tif (optind < argc)\n\t\tdie_usage(cmd_logout_usage);\n\n\tif (!force && !ask_yes_no(true, \"Are you sure you would like to log out?\")) {\n\t\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD \"Log out\" TERMINAL_RESET \": aborted.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (agent_ask(key)) {\n\t\tinit_all(0, key, &session, NULL);\n\t\tlastpass_logout(session);\n\t}\n\n\tsession_kill();\n\n\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD \"Log out\" TERMINAL_RESET \": complete.\\n\");\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-ls.c",
          "type": "blob",
          "size": 9.53515625,
          "content": "/*\n * command for listing the vault\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"format.h\"\n#include \"kdf.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n\nstatic bool long_listing = false;\nstatic bool show_mtime = true;\n\nstruct node {\n\tchar *name;\n\tstruct account *account;\n\tbool shared;\n\n\tstruct list_head children;\n\tstruct list_head list;\n};\n\nstruct path_component\n{\n\tchar *component;\n\tstruct list_head list;\n};\n\n/*\n * Tokenize path and add each component to the components list.\n * For group names, the path separator is a backslash.  The path\n * string is modified in place and the component list stores\n * pointers to the modified string.\n */\nstatic void parse_path(char *path, struct list_head *components)\n{\n\tchar *token;\n\tstruct path_component *pc;\n\n\tfor (token = strtok(path, \"\\\\\"); token; token = strtok(NULL, \"\\\\\")) {\n\t\tpc = new0(struct path_component, 1);\n\t\tpc->component = token;\n\t\tlist_add_tail(&pc->list, components);\n\t}\n}\n\nstatic void __insert_node(struct node *head,\n\t\t\t  struct list_head *components,\n\t\t\t  struct account *account)\n{\n\tstruct path_component *pc;\n\tstruct node *child, *tmp;\n\n\t/* iteratively build a tree from all the path components */\n\tlist_for_each_entry(pc, components, list) {\n\t\tchild = NULL;\n\t\tlist_for_each_entry(tmp, &head->children, list) {\n\t\t\tif (!strcmp(tmp->name, pc->component)) {\n\t\t\t\tchild = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!child) {\n\t\t\tchild = new0(struct node, 1);\n\t\t\tchild->shared= !!account->share;\n\t\t\tchild->name = xstrdup(pc->component);\n\t\t\tINIT_LIST_HEAD(&child->children);\n\t\t\tlist_add_tail(&child->list, &head->children);\n\t\t}\n\t\thead = child;\n\t}\n\n\t/* skip group display -- we already added the hierarchy for them */\n\tif (account_is_group(account))\n\t\treturn;\n\n\t/* and add the site at the lowest level */\n\tchild = new0(struct node, 1);\n\tchild->account = account;\n\tchild->shared= !!account->share;\n\tchild->name = xstrdup(account->name);\n\tINIT_LIST_HEAD(&child->children);\n\tlist_add_tail(&child->list, &head->children);\n}\n\nstatic void insert_node(struct node *head, const char *path, struct account *account)\n{\n\tstruct list_head components;\n\tstruct path_component *pc, *tmp;\n\t_cleanup_free_ char *dirname = xstrdup(path);\n\tchar *pos;\n\n\t/* remove name portion of fullname; we don't parse that */\n\tif (strlen(dirname) >= strlen(account->name)) {\n\t\tchar *tmp = dirname + strlen(dirname) - strlen(account->name);\n\t\tif (strcmp(tmp, account->name) == 0) {\n\t\t\t*tmp = 0;\n\t\t}\n\t}\n\n\tpos = dirname;\n\t/* trim trailing slash */\n\tif (strlen(pos))\n\t\tpos[strlen(pos)-1] = 0;\n\n\t/*\n\t * We are left with one of:\n\t *\n\t *     (none)/\n\t *     groupname/\n\t *     Shared-folder/\n\t *     Shared-folder/groupname/\n\t *\n\t * If there are embedded backslashes, these are treated as folder\n\t * names by parse_path().\n\t */\n\tINIT_LIST_HEAD(&components);\n\tif (account->share && strlen(pos) >= strlen(account->share->name)) {\n\t\tpos[strlen(account->share->name)] = 0;\n\t\tparse_path(pos, &components);\n\t\tpos += strlen(account->share->name) + 1;\n\t}\n\n\t/* either '(none)/' or group/ or empty string */\n\tparse_path(pos, &components);\n\n\t__insert_node(head, &components, account);\n\n\tlist_for_each_entry_safe(pc, tmp, &components, list) {\n\t\tlist_del(&pc->list);\n\t\tfree(pc);\n\t}\n}\n\nstatic void free_node(struct node *head)\n{\n\tstruct node *node, *tmp;\n\n\tif (!head)\n\t\treturn;\n\n\tlist_for_each_entry_safe(node, tmp, &head->children, list) {\n\t\tfree_node(node);\n\t}\n\tfree(head->name);\n\tfree(head);\n}\n\nstatic void print_node(struct node *head, char *fmt_str, int level)\n{\n\tstruct node *node;\n\n\tlist_for_each_entry(node, &head->children, list) {\n\t\tif (node->name) {\n\t\t\tfor (int i = 0; i < level; ++i)\n\t\t\t\tprintf(\"    \");\n\t\t\tif (node->account) {\n\t\t\t\tstruct buffer buf;\n\n\t\t\t\tbuffer_init(&buf);\n\t\t\t\tformat_account(&buf, fmt_str, node->account);\n\t\t\t\tterminal_printf(\"%s\\n\", buf.bytes);\n\t\t\t\tfree(buf.bytes);\n\t\t\t}\n\t\t\telse if (node->shared)\n\t\t\t\tterminal_printf(TERMINAL_FG_CYAN TERMINAL_BOLD \"%s\" TERMINAL_RESET \"\\n\", node->name);\n\t\t\telse\n\t\t\t\tterminal_printf(TERMINAL_FG_BLUE TERMINAL_BOLD \"%s\" TERMINAL_RESET \"\\n\", node->name);\n\t\t}\n\t\tprint_node(node, fmt_str, level + 1);\n\t}\n}\n\nstatic int compare_account(const void *a, const void *b)\n{\n\tstruct account * const *acct_a = a;\n\tstruct account * const *acct_b = b;\n\t_cleanup_free_ char *str1 = get_display_fullname(*acct_a);\n\t_cleanup_free_ char *str2 = get_display_fullname(*acct_b);\n\n\treturn strcmp(str1, str2);\n}\n\nint cmd_ls(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{\"format\", required_argument, NULL, 'f'},\n\t\t{\"long\", no_argument, NULL, 'l'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tchar *group = NULL;\n\tint group_len;\n\tchar *sub;\n\tstruct node *root;\n\tchar *fullname;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tenum color_mode cmode = COLOR_MODE_AUTO;\n\tbool print_tree;\n\tstruct account *account;\n\t_cleanup_free_ struct account **account_array = NULL;\n\tint i, num_accounts;\n\t_cleanup_free_ char *fmt_str = NULL;\n\n\tstruct share *share;\n\n\twhile ((option = getopt_long(argc, argv, \"lmu\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tcmode = parse_color_mode_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tfmt_str = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tlong_listing = true;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tshow_mtime = true;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tshow_mtime = false;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_ls_usage);\n\t\t}\n\t}\n\n\tswitch (argc - optind) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgroup = argv[optind];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie_usage(cmd_ls_usage);\n\t}\n\n\tterminal_set_color_mode(cmode);\n\tprint_tree = cmode == COLOR_MODE_ALWAYS ||\n\t\t     (cmode == COLOR_MODE_AUTO && isatty(fileno(stdout)));\n\n\n\tinit_all(sync, key, &session, &blob);\n\troot = new0(struct node, 1);\n\tINIT_LIST_HEAD(&root->children);\n\n\t/* '(none)' group -> search for any without group */\n\tif (group && !strcmp(group, \"(none)\"))\n\t\tgroup = \"\";\n\n\tnum_accounts = 0;\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tnum_accounts++;\n\t}\n\tlist_for_each_entry(share, &blob->share_head, list) {\n\t\tnum_accounts++;\n\t}\n\n\ti=0;\n\taccount_array = xcalloc(num_accounts, sizeof(struct account *));\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\taccount_array[i++] = account;\n\t}\n\t/* fake accounts for shares, so that empty shared folders are shown. */\n\tlist_for_each_entry(share, &blob->share_head, list) {\n\t\tstruct account *account = new_account();\n\t\tchar *tmpname = NULL;\n\n\t\txasprintf(&tmpname, \"%s/\", share->name);\n\t\taccount->share = share;\n\t\taccount->id = share->id;\n\t\taccount_set_name(account, xstrdup(\"\"), key);\n\t\taccount_set_fullname(account, tmpname, key);\n\t\taccount_set_url(account, \"http://group\", key, &session->feature_flag);\n\t\taccount_array[i++] = account;\n\t}\n\tqsort(account_array, num_accounts, sizeof(struct account *),\n\t      compare_account);\n\n\tif (!fmt_str) {\n\t\txasprintf(&fmt_str,\n\t\t\t  TERMINAL_FG_CYAN \"%s\"\n\t\t\t  TERMINAL_FG_GREEN TERMINAL_BOLD \"%%a%c\"\n\t\t\t  TERMINAL_NO_BOLD\n\t\t\t  \" [id: %%ai]\"\n\t\t\t  \"%s\" TERMINAL_RESET,\n\t\t\t  (long_listing) ?\n\t\t\t\t((show_mtime) ?  \"%am \" : \"%aU \") : \"\",\n\t\t\t  (print_tree) ? 'n' : 'N',\n\t\t\t  (long_listing) ? \" [username: %au]\" : \"\");\n\t}\n\n\tfor (i=0; i < num_accounts; i++)\n\t{\n\t\tstruct account *account = account_array[i];\n\n\t\tif (group) {\n\t\t\tsub = strstr(account->fullname, group);\n\t\t\tif (!sub || sub != account->fullname)\n\t\t\t\tcontinue;\n\t\t\tgroup_len = strlen(group);\n\t\t\tsub += group_len;\n\t\t\tif (group_len &&\n\t\t\t    group[group_len - 1] != '/' &&\n\t\t\t    sub[0] != '\\0' && sub[0] != '/')\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfullname = get_display_fullname(account);\n\n\t\tif (print_tree)\n\t\t\tinsert_node(root, fullname, account);\n\t\telse {\n\t\t\tstruct buffer buf;\n\n\t\t\tbuffer_init(&buf);\n\t\t\tformat_account(&buf, fmt_str, account);\n\t\t\tterminal_printf(\"%s\\n\", buf.bytes);\n\t\t\tfree(buf.bytes);\n\t\t}\n\t\tfree(fullname);\n\t}\n\tif (print_tree)\n\t\tprint_node(root, fmt_str, 0);\n\n\tfree_node(root);\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-mv.c",
          "type": "blob",
          "size": 3.7041015625,
          "content": "/*\n * command for moving vault entries\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"agent.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n\nint cmd_mv(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tint option;\n\tint option_index;\n\tchar *name;\n\tchar *folder;\n\tchar *new_fullname = NULL;\n\tstruct account *account;\n\tstruct share *old_share;\n\n\twhile ((option = getopt_long(argc, argv, \"SC\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_mv_usage);\n\t\t}\n\t}\n\n\tif (argc - optind != 2)\n\t\tdie_usage(cmd_mv_usage);\n\n\tname = argv[optind++];\n\tfolder = argv[optind++];\n\n\tinit_all(sync, key, &session, &blob);\n\n\taccount = find_unique_account(blob, name);\n\tif (!account) {\n\t\tdie(\"Unable to find account %s\", name);\n\t}\n\n\txasprintf(&new_fullname, \"%s/%s\", folder, account->name);\n\told_share = account->share;\n\n\taccount_set_fullname(account, new_fullname, key);\n\taccount_assign_share(blob, account, key, &session->feature_flag);\n\tif (account->share && account->share->readonly) {\n\t\tdie(\"You do not have access to move %s into %s\",\n\t\t    account->name, account->share->name);\n\t}\n\n\tif (old_share != account->share) {\n\t\t/*\n\t\t * when moving into / out of a shared folder, we need to\n\t\t * reencrypt and make a special api call for that.\n\t\t */\n\t\tint ret = lastpass_share_move(session, account, old_share);\n\t\tif (ret) {\n\t\t\tdie(\"Move to/from shared folder failed (%d)\\n\", ret);\n\t\t}\n\t\tlist_del(&account->list);\n\t} else {\n\t\t/* standard case: account just changing group name */\n\t\tlastpass_update_account(sync, key, session, account, blob);\n\t}\n\tblob_save(blob, key, &session->feature_flag);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-passwd.c",
          "type": "blob",
          "size": 7.357421875,
          "content": "/*\n * command for changing master password\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include <errno.h>\n#include <string.h>\n#include \"blob.h\"\n#include \"kdf.h\"\n#include \"cmd.h\"\n#include \"endpoints.h\"\n#include \"config.h\"\n#include \"password.h\"\n#include \"cipher.h\"\n#include \"session.h\"\n\nstatic void show_status_bar(const char *operation,\n\t\t\t    unsigned int cur, unsigned int max)\n{\n\tchar progress[41] = {0};\n\tsize_t len;\n\n\tif (!max)\n\t\tmax = 1;\n\n\tif (cur > max)\n\t\tcur = max;\n\n\tlen = (cur * (sizeof(progress) - 1)) / max;\n\tif (len)\n\t\tmemset(progress, '=', len);\n\n\tterminal_fprintf(stderr, TERMINAL_FG_CYAN \"%s \" TERMINAL_RESET\n                     TERMINAL_FG_BLUE \"[%-*s] \" TERMINAL_RESET\n                     TERMINAL_FG_CYAN \"%d/%d     \\r\" TERMINAL_RESET,\n                     operation, (int) sizeof(progress)-1, progress, cur, max);\n}\n\nstatic void reencrypt(struct session *session,\n\t\t      struct pwchange_info *info,\n\t\t      unsigned char key[KDF_HASH_LEN],\n\t\t      unsigned char new_key[KDF_HASH_LEN])\n{\n\tstruct pwchange_field *field;\n\tstruct pwchange_su_key *su_key;\n\tstruct private_key tmp;\n\tunsigned int n_fields = 0;\n\tunsigned int i = 0;\n\tunsigned int n_required = 0;\n\tunsigned int errors = 0;\n\n\t/* count how many things we'll encrypt */\n\tlist_for_each_entry(field, &info->fields, list) {\n\t\tn_fields++;\n\t}\n\tlist_for_each_entry(su_key, &info->su_keys, list) {\n\t\tn_fields++;\n\t}\n\t/* plus sharing key */\n\tn_fields++;\n\n\tshow_status_bar(\"Re-encrypting\", i++, n_fields);\n\n\t/* decrypt and re-encrypt RSA sharing key */\n\tcipher_decrypt_private_key(info->privkey_encrypted, key, &tmp);\n\tif (tmp.len != session->private_key.len ||\n\t    memcmp(session->private_key.key, tmp.key, session->private_key.len)) {\n\t\tdie(\"Server and session private key don't match! Try lpass sync first.\");\n\t}\n\n\tinfo->new_privkey_encrypted =\n\t\tcipher_encrypt_private_key(&tmp, new_key);\n\n\tsecure_clear(tmp.key, tmp.len);\n\tfree(tmp.key);\n\n\t/* reencrypt site info */\n\tlist_for_each_entry(field, &info->fields, list) {\n\t\tshow_status_bar(\"Re-encrypting\", i++, n_fields);\n\t\tif (!field->optional)\n\t\t\tn_required++;\n\n\t\tchar *ptext = cipher_aes_decrypt_base64(field->old_ctext, key);\n\t\tif (!ptext) {\n\t\t\tif (!field->optional)\n\t\t\t\terrors++;\n\t\t\tptext = \" \";\n\t\t}\n\t\tfield->new_ctext = encrypt_and_base64(ptext, new_key);\n\t}\n\n\t/*\n\t * Fail if > 10% decryption errors.  This indicates the blob and key\n\t * are out of sync somehow, or that user has reverted a password\n\t * change but some entries are encrypted with the new key.\n\t */\n\tif (errors > n_required / 10)\n\t\tdie(\"Too many decryption failures.\");\n\n\t/* encrypt recovery copy of our key */\n\tlist_for_each_entry(su_key, &info->su_keys, list) {\n\t\tshow_status_bar(\"Re-encrypting\", i++, n_fields);\n\n\t\tsize_t enc_key_len = su_key->sharing_key.len;\n\t\tunsigned char *enc_key = xmalloc(enc_key_len);\n\n\t\tcipher_rsa_encrypt_bytes(new_key, KDF_HASH_LEN,\n\t\t\t\t\t &su_key->sharing_key,\n\t\t\t\t\t enc_key, &enc_key_len);\n\t\tbytes_to_hex(enc_key, &su_key->new_enc_key, enc_key_len);\n\t\tfree(enc_key);\n\t}\n\n\tshow_status_bar(\"Re-encrypting\", n_fields, n_fields);\n\n\tinfo->new_privkey_hash = cipher_sha256_hex((unsigned char *)\n\t\tinfo->new_privkey_encrypted,\n\t\tstrlen(info->new_privkey_encrypted));\n\tinfo->new_key_hash = cipher_sha256_hex(new_key, KDF_HASH_LEN);\n\n\tprintf(\"\\n\");\n}\n\nint cmd_passwd(int argc, char **argv)\n{\n\tUNUSED(argc);\n\tUNUSED(argv);\n\n\tunsigned char key[KDF_HASH_LEN];\n\tunsigned char new_key[KDF_HASH_LEN];\n\tchar hex[KDF_HEX_LEN];\n\tchar new_hex[KDF_HEX_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob;\n\tint ret;\n\t_cleanup_free_ char *password = NULL;\n\t_cleanup_free_ char *new_password = NULL;\n\t_cleanup_free_ char *pw2 = NULL;\n\t_cleanup_free_ char *username = NULL;\n\tint iterations;\n\tbool match;\n\tstruct pwchange_info info;\n\n\t/* load existing session, if present */\n\tinit_all(BLOB_SYNC_YES, key, &session, &blob);\n\n\tusername = config_read_string(\"username\");\n\titerations = lastpass_iterations(username);\n\tif (!iterations)\n\t\tdie(\"Unable to fetch iteration count. Check your internet connection and be sure your username is valid.\");\n\n\t/* reprompt for old mpw */\n\tpassword = password_prompt(\"Current Master Password\", NULL,\n\t\t\"Please enter the current LastPass master password for <%s>.\",\n\t\tusername);\n\n\tif (!password)\n\t\tdie(\"Failed to enter password.\");\n\n\tkdf_login_key(username, password, iterations, hex);\n\tsecure_clear_str(password);\n\n\t/* prompt for new pw */\n\tnew_password = password_prompt(\"New Master Password\", NULL,\n\t\t\"Please enter the new LastPass master password for <%s>.\",\n\t\tusername);\n\n\tpw2 = password_prompt(\"Confirm New Master Password\", NULL,\n\t\t\"Please retype the new LastPass master password for <%s>.\",\n\t\tusername);\n\n\tif (!new_password || !pw2)\n\t\tdie(\"Failed to enter new password.\");\n\n\tmatch = strcmp(new_password, pw2) == 0;\n\tsecure_clear_str(pw2);\n\n\tif (!match)\n\t\tdie(\"Bad password: passwords don't match.\");\n\n\tif (strlen(new_password) < 8)\n\t\tdie(\"Bad password: too short.\");\n\n\tkdf_decryption_key(username, new_password, iterations, new_key);\n\tkdf_login_key(username, new_password, iterations, new_hex);\n\tsecure_clear_str(new_password);\n\n\t/*\n\t * Fetch the data to reencrypt.  We may learn at this point that the\n\t * current password was incorrect, so handle that accordingly.\n\t */\n\tterminal_printf(TERMINAL_FG_CYAN \"Fetching data...\\n\" TERMINAL_RESET);\n\tret = lastpass_pwchange_start(session, username, hex, &info);\n\tif (ret) {\n\t\tif (ret == -EPERM)\n\t\t\tdie(\"Incorrect password.  Password not changed.\");\n\t\telse\n\t\t\tdie(\"Error changing password (error=%d)\", ret);\n\t}\n\n\t/* reencrypt */\n\treencrypt(session, &info, key, new_key);\n\n\tterminal_printf(TERMINAL_FG_CYAN \"Uploading...\\n\" TERMINAL_RESET);\n\n\t_cleanup_free_ char *enc_username = encrypt_and_base64(username, new_key);\n\tret = lastpass_pwchange_complete(session, username, enc_username,\n\t\t\t\t\t hex, new_hex, iterations, &info);\n\n\tif (ret)\n\t\tdie(\"Password change failed.\");\n\n\tsession_kill();\n\tterminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD \"Success\" TERMINAL_RESET \": Password changed and logged out.\\n\");\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-rm.c",
          "type": "blob",
          "size": 3.0322265625,
          "content": "/*\n * command for removing vault entries\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"blob.h\"\n#include \"endpoints.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n\nint cmd_rm(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tchar *name;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tstruct account *found;\n\n\twhile ((option = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_rm_usage);\n\t\t}\n\t}\n\n\tif (argc - optind != 1)\n\t\tdie_usage(cmd_rm_usage);\n\tname = argv[optind];\n\n\tinit_all(sync, key, &session, &blob);\n\tfound = find_unique_account(blob, name);\n\tif (!found)\n\t\tdie(\"Could not find specified account '%s'.\", name);\n\tif (found->share && found->share->readonly)\n\t\tdie(\"%s is a readonly shared entry from %s. It cannot be deleted.\", found->fullname, found->share->name);\n\n\tlist_del(&found->list);\n\n\tlastpass_remove_account(sync, key, session, found, blob);\n\tblob_save(blob, key, &session->feature_flag);\n\taccount_free(found);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-share.c",
          "type": "blob",
          "size": 13.314453125,
          "content": "/*\n * commands to manipulate shared folders\n *\n * Copyright (C) 2015 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders grant you\n * additional permission to link or combine this program with the OpenSSL\n * library and distribute the resulting work.  See the LICENSE.OpenSSL file\n * in this distribution for more details.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"agent.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"clipboard.h\"\n#include \"upload-queue.h\"\n#include \"process.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstruct share_args {\n\tstruct session *session;\n\tstruct blob *blob;\n\tenum blobsync sync;\n\tunsigned char key[KDF_HASH_LEN];\n\tconst char *sharename;\n\tstruct share *share;\n\n\tbool read_only;\n\tbool set_read_only;\n\tbool admin;\n\tbool set_admin;\n\tbool hide_passwords;\n\tbool set_hide_passwords;\n\n\tbool specified_limit_type;\n\tbool whitelist;\n\tbool add;\n\tbool remove;\n\tbool clear;\n};\n\nstruct share_command {\n\tconst char *name;\n\tconst char *usage;\n\tint (*cmd)(struct share_command *cmd, int, char **,\n\t\t   struct share_args *share);\n};\n\n#define share_userls_usage \"userls SHARE\"\n#define share_useradd_usage \"useradd [--read-only=[true|false] --hidden=[true|false] --admin=[true|false] SHARE USERNAME\"\n#define share_usermod_usage \"usermod [--read-only=[true|false] --hidden=[true|false] --admin=[true|false] SHARE USERNAME\"\n#define share_userdel_usage \"userdel SHARE USERNAME\"\n#define share_create_usage \"create SHARE\"\n#define share_limit_usage \"limit [--deny|--allow] [--add|--rm|--clear] SHARE USERNAME [sites]\"\n#define share_rm_usage \"rm SHARE\"\n\nstatic char *checkmark(int x) {\n\treturn (x) ? \"x\" : \"_\";\n}\n\nstatic void die_share_usage(struct share_command *cmd)\n{\n\tdie_usage(cmd->usage);\n}\n\nstatic int share_userls(struct share_command *cmd, int argc, char **argv,\n\t\t\tstruct share_args *args)\n{\n\tUNUSED(argv);\n\tstruct share_user *user;\n\tchar name[40];\n\tLIST_HEAD(users);\n\tbool has_groups = false;\n\n\tif (argc)\n\t\tdie_share_usage(cmd);\n\n\tif (lastpass_share_getinfo(args->session, args->share->id, &users))\n\t\tdie(\"Unable to access user list for share %s\\n\",\n\t\t    args->sharename);\n\n\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD \"%-40s %6s %6s %6s %6s %6s\" TERMINAL_RESET \"\\n\",\n\t       \"User\", \"RO\", \"Admin\", \"Hide\", \"OutEnt\", \"Accept\");\n\n\tlist_for_each_entry(user, &users, list) {\n\t\tif (user->is_group) {\n\t\t\thas_groups = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (user->realname) {\n\t\t\tsnprintf(name, sizeof(name), \"%s <%s>\",\n\t\t\t\t user->realname, user->username);\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"%s\", user->username);\n\t\t}\n\n\t\tterminal_printf(\"%-40s %6s %6s %6s %6s %6s\"\n\t\t\t\t\"\\n\",\n\t\t\t\tname,\n\t\t\t\tcheckmark(user->read_only),\n\t\t\t\tcheckmark(user->admin),\n\t\t\t\tcheckmark(user->hide_passwords),\n\t\t\t\tcheckmark(user->outside_enterprise),\n\t\t\t\tcheckmark(user->accepted));\n\t}\n\n\tif (!has_groups)\n\t\treturn 0;\n\n\n\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD \"%-40s %6s %6s %6s %6s %6s\"\n\t\t\tTERMINAL_RESET \"\\n\",\n\t\t\t\"Group\", \"RO\", \"Admin\", \"Hide\", \"OutEnt\", \"Accept\");\n\n\tlist_for_each_entry(user, &users, list) {\n\t\tif (!user->is_group)\n\t\t\tcontinue;\n\n\t\tterminal_printf(\"%-40s %6s %6s %6s %6s %6s\"\n\t\t\t\t\"\\n\",\n\t\t\t\tuser->username,\n\t\t\t\tcheckmark(user->read_only),\n\t\t\t\tcheckmark(user->admin),\n\t\t\t\tcheckmark(user->hide_passwords),\n\t\t\t\tcheckmark(user->outside_enterprise),\n\t\t\t\tcheckmark(user->accepted));\n\t}\n\treturn 0;\n}\n\nstatic int share_useradd(struct share_command *cmd, int argc, char **argv,\n\t\t\t struct share_args *args)\n{\n\tstruct share_user new_user = {\n\t\t.read_only = args->read_only,\n\t\t.hide_passwords = args->hide_passwords,\n\t\t.admin = args->admin\n\t};\n\n\tif (argc != 1)\n\t\tdie_share_usage(cmd);\n\n\tnew_user.username = argv[0];\n\tlastpass_share_user_add(args->session, args->share, &new_user);\n\treturn 0;\n}\n\nstatic\nstruct share_user *get_user_from_share(struct session *session,\n\t\t\t\t       struct share *share,\n\t\t\t\t       const char *username)\n{\n\tstruct share_user *tmp, *found = NULL;\n\tLIST_HEAD(users);\n\n\tif (lastpass_share_getinfo(session, share->id, &users))\n\t\tdie(\"Unable to access user list for share %s\\n\", share->name);\n\n\tlist_for_each_entry(tmp, &users, list) {\n\t\tif (strcmp(tmp->username, username) == 0) {\n\t\t\tfound = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tdie(\"Unable to find user %s in the user list\\n\",\n\t\t    username);\n\n\treturn found;\n}\n\n\nstatic int share_usermod(struct share_command *cmd, int argc, char **argv,\n\t\t\t struct share_args *args)\n{\n\tstruct share_user *user;\n\n\tif (argc != 1)\n\t\tdie_share_usage(cmd);\n\n\tuser = get_user_from_share(args->session, args->share, argv[0]);\n\n\tif (args->set_read_only)\n\t\tuser->read_only = args->read_only;\n\tif (args->set_hide_passwords)\n\t\tuser->hide_passwords = args->hide_passwords;\n\tif (args->set_admin)\n\t\tuser->admin = args->admin;\n\n\tlastpass_share_user_mod(args->session, args->share, user);\n\treturn 0;\n}\n\nstatic int share_userdel(struct share_command *cmd, int argc, char **argv,\n\t\t\t struct share_args *args)\n{\n\tstruct share_user *found;\n\n\tif (argc != 1)\n\t\tdie_share_usage(cmd);\n\n\tfound = get_user_from_share(args->session, args->share, argv[0]);\n\tlastpass_share_user_del(args->session, args->share->id, found);\n\treturn 0;\n}\n\nstatic void print_share_limits(struct blob *blob, struct share *share,\n\t\t\t       struct share_limit *limit)\n{\n\tstruct account *account;\n\tstruct share_limit_aid *aid;\n\tchar sitename[80];\n\n\t/* display current settings for this user */\n\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD\n\t\t\t\"%-60s %7s %5s\" TERMINAL_RESET \"\\n\",\n\t\t\t\"Site\", \"Unavail\", \"Avail\");\n\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tif (account->share != share)\n\t\t\tcontinue;\n\n\t\tbool in_list = false;\n\t\tlist_for_each_entry(aid, &limit->aid_list, list) {\n\t\t\tif (!strcmp(aid->aid, account->id)) {\n\t\t\t\tin_list = true;\n\t\t\t}\n\t\t}\n\n\t\tbool avail = (in_list && limit->whitelist) ||\n\t\t\t(!in_list && !limit->whitelist);\n\n\t\tsnprintf(sitename, sizeof(sitename),\n\t\t\t\tTERMINAL_BOLD \"%-.30s\" TERMINAL_NO_BOLD \" [id: %s]\",\n\t\t\t\taccount->name, account->id);\n\n\t\tterminal_printf(TERMINAL_FG_GREEN\n\t\t\t\t\"%-66s\" TERMINAL_RESET \" %8s %5s\\n\",\n\t\t\t\tsitename, checkmark(!avail), checkmark(avail));\n\n\t}\n}\n\n\nstatic int share_limit(struct share_command *cmd, int argc, char **argv,\n\t\t       struct share_args *args)\n{\n\tstruct share_user *found;\n\tstruct share_limit limit;\n\tstruct account *account;\n\tstruct share_limit_aid *aid, *tmp;\n\tstruct blob *blob = args->blob;\n\tbool changed_list_type;\n\tint optind;\n\n\tstruct list_head potential_set;\n\tstruct list_head matches;\n\n\tif (argc < 1)\n\t\tdie_share_usage(cmd);\n\n\tfound = get_user_from_share(args->session, args->share, argv[0]);\n\tlastpass_share_get_limits(args->session, args->share, found, &limit);\n\n\tif (!args->specified_limit_type)\n\t\targs->whitelist = limit.whitelist;\n\n\t/*\n\t * prompt if we switch list type and there are entries already, in\n\t * order to avoid accidentally changing a blacklist to a whitelist\n\t */\n\tchanged_list_type = args->whitelist != limit.whitelist &&\n\t\t\t    !list_empty(&limit.aid_list);\n\n\tif (argc == 1 && !changed_list_type) {\n\t\t/* nothing to do, just print current limits */\n\t\tprint_share_limits(blob, args->share, &limit);\n\t\treturn 0;\n\t}\n\n\tif (changed_list_type) {\n\t\tbool isok = ask_yes_no(false,\n\t\t\t\"Supplied limit type (%s) doesn't match existing list (%s).\\nContinue and switch?\",\n\t\t\targs->whitelist ? \"default deny\" : \"default allow\",\n\t\t\tlimit.whitelist ? \"default deny\" : \"default allow\");\n\n\t\tif (!isok)\n\t\t\tdie(\"Aborted.\");\n\t}\n\n\t/* add to, or subtract from current list */\n\tINIT_LIST_HEAD(&potential_set);\n\tINIT_LIST_HEAD(&matches);\n\n\t/* search only accts in this share */\n\tlist_for_each_entry(account, &blob->account_head, list) {\n\t\tif (account->share == args->share)\n\t\t\tlist_add(&account->match_list, &potential_set);\n\t}\n\n\tfor (optind = 1; optind < argc; optind++) {\n\t\tchar *name = argv[optind];\n\t\tfind_matching_accounts(&potential_set, name, &matches);\n\t}\n\n\tif (args->clear) {\n\t\tlist_for_each_entry_safe(aid, tmp, &limit.aid_list, list) {\n\t\t\tlist_del(&aid->list);\n\t\t\tfree(aid->aid);\n\t\t}\n\t}\n\n\tlist_for_each_entry(account, &matches, match_list) {\n\n\t\t/* add account to share_limit */\n\t\tbool in_list = false;\n\t\tlist_for_each_entry(aid, &limit.aid_list, list) {\n\t\t\tif (!strcmp(aid->aid, account->id)) {\n\t\t\t\tin_list = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((!in_list && args->add) || args->clear) {\n\t\t\tstruct share_limit_aid *newaid =\n\t\t\t\tnew0(struct share_limit_aid, 1);\n\t\t\tnewaid->aid = account->id;\n\t\t\tlist_add_tail(&newaid->list, &limit.aid_list);\n\t\t}\n\t\telse if (in_list && args->remove) {\n\t\t\tlist_del(&aid->list);\n\t\t}\n\t}\n\n\tlimit.whitelist = args->whitelist;\n\n\tlastpass_share_set_limits(args->session, args->share, found, &limit);\n\n\tprint_share_limits(blob, args->share, &limit);\n\n\treturn 0;\n}\n\nstatic int share_create(struct share_command *cmd, int argc, char **argv,\n\t\t\tstruct share_args *args)\n{\n\tint ret;\n\tbool prepend_share;\n\n\tif (argc != 0)\n\t\tdie_share_usage(cmd);\n\n\tUNUSED(argv);\n\n\tret = lastpass_share_create(args->session, args->sharename);\n\tif (ret)\n\t\tdie(\"No permission to create share\");\n\n\tprepend_share = strncmp(args->sharename, \"Shared-\", 7);\n\tterminal_printf(\"Folder %s%s created.\\n\",\n\t\t\t(prepend_share) ? \"Shared-\" : \"\",\n\t\t\targs->sharename);\n\treturn 0;\n}\n\nstatic int share_rm(struct share_command *cmd, int argc, char **argv,\n\t\t    struct share_args *args)\n{\n\tif (argc != 0)\n\t\tdie_share_usage(cmd);\n\n\tUNUSED(argv);\n\n\tlastpass_share_delete(args->session, args->share);\n\treturn 0;\n}\n\n#define SHARE_CMD(name) { #name, \"share \" share_##name##_usage, share_##name }\nstatic struct share_command share_commands[] = {\n\tSHARE_CMD(userls),\n\tSHARE_CMD(useradd),\n\tSHARE_CMD(usermod),\n\tSHARE_CMD(userdel),\n\tSHARE_CMD(create),\n\tSHARE_CMD(rm),\n\tSHARE_CMD(limit),\n};\n#undef SHARE_CMD\n\n/* Display more verbose usage if no subcmd is given or matched. */\nstatic void share_help(void)\n{\n\tterminal_fprintf(stderr, \"Usage: %s %s\\n\", ARGV[0], cmd_share_usage);\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(share_commands); ++i)\n\t\tprintf(\"  %s %s\\n\", ARGV[0], share_commands[i].usage);\n\n\texit(1);\n}\n\nint cmd_share(int argc, char **argv)\n{\n\tchar *subcmd;\n\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{\"read-only\", required_argument, NULL, 'r'},\n\t\t{\"hidden\", required_argument, NULL, 'H'},\n\t\t{\"admin\", required_argument, NULL, 'a'},\n\t\t{\"deny\", no_argument, NULL, 'd'},\n\t\t{\"allow\", no_argument, NULL, 'w'},\n\t\t{\"add\", no_argument, NULL, 'A'},\n\t\t{\"rm\", no_argument, NULL, 'R'},\n\t\t{\"clear\", no_argument, NULL, 'c'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tstruct share_args args = {\n\t\t.sync = BLOB_SYNC_AUTO,\n\t\t.read_only = true,\n\t\t.hide_passwords = true,\n\t\t.add = true,\n\t};\n\n\tbool invalid_params = false;\n\tstruct share_command *command;\n\n\t/*\n\t * Parse out all option commands for all subcommands, and store\n\t * them in the share_args struct.\n\t *\n\t * All commands have at least subcmd and sharename non-option args.\n\t * Additional non-option commands are passed as argc/argv to the\n\t * sub-command.\n\t */\n\tint option;\n\tint option_index;\n\twhile ((option = getopt_long(argc, argv, \"S:C:r:H:a:dwARc\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\targs.sync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\targs.read_only = parse_bool_arg_string(optarg);\n\t\t\t\targs.set_read_only = true;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\targs.hide_passwords =\n\t\t\t\t\tparse_bool_arg_string(optarg);\n\t\t\t\targs.set_hide_passwords = true;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\targs.admin = parse_bool_arg_string(optarg);\n\t\t\t\targs.set_admin = true;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\targs.whitelist = true;\n\t\t\t\targs.specified_limit_type = true;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\targs.whitelist = false;\n\t\t\t\targs.specified_limit_type = true;\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\targs.add = true;\n\t\t\t\targs.remove = args.clear = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\targs.remove = true;\n\t\t\t\targs.add = args.clear = false;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\targs.clear = true;\n\t\t\t\targs.add = args.remove = false;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tinvalid_params = true;\n\t\t}\n\t}\n\n\tif (argc - optind < 1)\n\t\tshare_help();\n\n\tsubcmd = argv[optind++];\n\tcommand = NULL;\n\tfor (unsigned int i=0; i < ARRAY_SIZE(share_commands); i++) {\n\t\tif (strcmp(subcmd, share_commands[i].name) == 0) {\n\t\t\tcommand = &share_commands[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!command)\n\t\tshare_help();\n\n\tif (argc - optind < 1 || invalid_params)\n\t\tdie_share_usage(command);\n\n\targs.sharename = argv[optind++];\n\n\tinit_all(args.sync, args.key, &args.session, &args.blob);\n\n\tif (strcmp(subcmd, \"create\") != 0) {\n\t\targs.share = find_unique_share(args.blob, args.sharename);\n\t\tif (!args.share)\n\t\t\tdie(\"Share %s not found.\", args.sharename);\n\t}\n\n\tcommand->cmd(command, argc - optind, &argv[optind], &args);\n\tsession_free(args.session);\n\tblob_free(args.blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-show.c",
          "type": "blob",
          "size": 13.857421875,
          "content": "/*\n * command to show the contents of a vault entry\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"cipher.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"agent.h\"\n#include \"kdf.h\"\n#include \"endpoints.h\"\n#include \"clipboard.h\"\n#include \"format.h\"\n#include \"json-format.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n/*\n * If a secure note field contains ascii armor, its newlines will\n * have been replaced by spaces when saving.  Undo this for\n * display purposes.  The replacement (if applicable) is done\n * in-place.\n */\nstatic char *fix_ascii_armor(char *armor_str)\n{\n\tchar *end_header, *start_trailer, *ptr;\n\n\t/* need at least 4 \"-----\" strings */\n\tif (strlen(armor_str) < 20)\n\t\treturn armor_str;\n\n\t/* look for -----BEGIN [xxx]----- and -----END [xxx]----- strings */\n\tif (strncmp(armor_str, \"-----BEGIN\", 10))\n\t\treturn armor_str;\n\n\tend_header = strstr(armor_str + 10, \"----- \");\n\tif (!end_header)\n\t\treturn armor_str;\n\n\tstart_trailer = strstr(end_header, \"-----END\");\n\tif (!start_trailer)\n\t\treturn armor_str;\n\n\tif (strncmp(armor_str + strlen(armor_str) - 5, \"-----\", 5))\n\t\treturn armor_str;\n\n\t/* ok, probably ascii armor, go ahead and munge it as such */\n\tptr = end_header;\n\twhile ((ptr = strchr(ptr, ' ')) != NULL) {\n\t\tif (ptr >= start_trailer)\n\t\t\tbreak;\n\t\t/* don't modify spaces after headers, e.g. encrypted keys */\n\t\tif (ptr[-1] == ':') {\n\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*ptr = '\\n';\n\t}\n\treturn armor_str;\n}\n\nstatic char *attachment_filename(struct account *account,\n\t\t\t\t struct attach *attach)\n{\n\t_cleanup_free_ unsigned char *key_bin = NULL;\n\n\tif (!attach->filename ||\n\t    !account->attachkey ||\n\t    strlen(account->attachkey) != KDF_HASH_LEN * 2 ||\n\t    hex_to_bytes(account->attachkey, &key_bin)) {\n\t\treturn xstrdup(\"unknown\");\n\t}\n\n\treturn cipher_aes_decrypt_base64(attach->filename, key_bin);\n}\n\nstatic bool attachment_is_binary(unsigned char *data, size_t len)\n{\n\tsize_t i;\n\tfor (i = 0; i < min(len, 100); i++) {\n\t\tif (!isprint(data[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void show_attachment(const struct session *session,\n\t\t\t    struct account *account,\n\t\t\t    struct attach *attach,\n\t\t\t    bool quiet)\n{\n\t_cleanup_free_ unsigned char *key_bin = NULL;\n\t_cleanup_free_ char *result = NULL;\n\t_cleanup_free_ char *filename = NULL;\n\tint ret;\n\tchar opt;\n\tchar *ptext;\n\tsize_t len;\n\tchar *shareid = NULL;\n\tunsigned char *bytes = NULL;\n\tFILE *fp = stdout;\n\n\tif (!account->attachkey || strlen(account->attachkey) != KDF_HASH_LEN * 2)\n\t\tdie(\"Missing attach key for account %s\\n\", account->name);\n\n\tif (hex_to_bytes(account->attachkey, &key_bin))\n\t\tdie(\"Invalid attach key for account %s\\n\", account->name);\n\n\tif (account->share != NULL)\n\t\tshareid = account->share->id;\n\n\tfilename = attachment_filename(account, attach);\n\n\tret = lastpass_load_attachment(session, shareid, attach, &result);\n\tif (ret)\n\t\tdie(\"Could not load attachment %s\\n\", attach->id);\n\n\tptext = cipher_aes_decrypt_base64(result, key_bin);\n\tif (!ptext)\n\t\tdie(\"Unable to decrypt attachment %s\\n\", attach->id);\n\n\tlen = unbase64(ptext, &bytes);\n\n\tif (attachment_is_binary(bytes, len) && !quiet) {\n\t\topt = ask_options(\"yns\", 's',\n\t\t\t    \"\\\"%s\\\" is a binary file, print it anyway (or save)? \",\n\t\t\t    filename);\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\treturn;\n\t\tcase 's':\n\t\t\tfp = fopen(filename, \"wb\");\n\t\t\tif (!fp)\n\t\t\t\tdie(\"Unable to open %s\\n\", filename);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen = fwrite(bytes, 1, len, fp);\n\tif (fp != stdout) {\n\t\tfprintf(stderr, TERMINAL_FG_GREEN \"Wrote %zu bytes to \\\"%s\\\"\\n\" TERMINAL_RESET, len, filename);\n\t\tfclose(fp);\n\t}\n}\n\nstatic char *pretty_field_value(struct field *field)\n{\n\tchar *value;\n\tif (!strcmp(field->type, \"checkbox\"))\n\t\tvalue = xstrdup(field->checked ? \"Checked\" : \"Unchecked\");\n\telse if (!strcmp(field->type, \"radio\"))\n\t\txasprintf(&value, \"%s, %s\", field->value, field->checked ? \"Checked\" : \"Unchecked\");\n\telse\n\t\tvalue = fix_ascii_armor(xstrdup(field->value));\n\treturn value;\n}\n\nstatic void print_header(char *title_format, struct account *found)\n{\n\tstruct buffer buf;\n\n\tbuffer_init(&buf);\n\tformat_account(&buf, title_format, found);\n\tterminal_printf(\"%s\\n\", buf.bytes);\n\tfree(buf.bytes);\n}\n\nstatic void print_field(char *field_format, struct account *account,\n\t\t\tchar *name, char *value)\n{\n\tstruct buffer buf;\n\n\tbuffer_init(&buf);\n\tformat_field(&buf, field_format, account, name, value);\n\tterminal_printf(\"%s\\n\", buf.bytes);\n\tfree(buf.bytes);\n}\n\nstatic void print_attachment(char *field_format,\n\t\t\t     struct account *account,\n\t\t\t     struct attach *attach)\n{\n\t_cleanup_free_ char *attach_id = NULL;\n\t_cleanup_free_ char *filename = NULL;\n\n\txasprintf(&attach_id, \"att-%s\", attach->id);\n\tfilename = attachment_filename(account, attach);\n\n\tprint_field(field_format, account, attach_id, filename);\n}\n\nstatic struct attach *find_attachment(struct account *account,\n\t\t\t\t      const char *attach_id)\n{\n\tstruct attach *attach = NULL;\n\n\t/* trim 'att-' off id if someone passed it */\n\tif (!strncmp(attach_id, \"att-\", 4))\n\t\tattach_id += 4;\n\n\tlist_for_each_entry(attach, &account->attach_head, list) {\n\t\tif (!strcmp(attach->id, attach_id))\n\t\t\treturn attach;\n\t}\n\treturn NULL;\n}\n\n\nint cmd_show(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\t_cleanup_free_ char *value = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"sync\", required_argument, NULL, 'S'},\n\t\t{\"all\", no_argument, NULL, 'A'},\n\t\t{\"username\", no_argument, NULL, 'u'},\n\t\t{\"password\", no_argument, NULL, 'p'},\n\t\t{\"url\", no_argument, NULL, 'L'},\n\t\t{\"field\", required_argument, NULL, 'f'},\n\t\t{\"id\", no_argument, NULL, 'I'},\n\t\t{\"name\", no_argument, NULL, 'N'},\n\t\t{\"notes\", no_argument, NULL, 'O'},\n\t\t{\"attach\", required_argument, NULL, 'a'},\n\t\t{\"clip\", no_argument, NULL, 'c'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{\"basic-regexp\", no_argument, NULL, 'G'},\n\t\t{\"fixed-strings\", no_argument, NULL, 'F'},\n\t\t{\"expand-multi\", no_argument, NULL, 'x'},\n\t\t{\"title-format\", required_argument, NULL, 't'},\n\t\t{\"format\", required_argument, NULL, 'o'},\n\t\t{\"json\", no_argument, NULL, 'j'},\n\t\t{\"quiet\", no_argument, NULL, 'q'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tint option;\n\tint option_index;\n\tenum { ALL, USERNAME, PASSWORD, URL, FIELD, ID, NAME, NOTES, ATTACH } choice = ALL;\n\t_cleanup_free_ char *field = NULL;\n\tstruct account *notes_expansion = NULL;\n\tstruct field *found_field;\n\tchar *name, *pretty_field;\n\tstruct account *found, *last_found, *account;\n\tstruct app *app;\n\tenum blobsync sync = BLOB_SYNC_AUTO;\n\tbool clip = false;\n\tbool json = false;\n\tbool expand_multi = false;\n\tbool quiet = false;\n\tstruct list_head matches, potential_set;\n\tenum search_type search = SEARCH_EXACT_MATCH;\n\tint fields = ACCOUNT_NAME | ACCOUNT_ID | ACCOUNT_FULLNAME;\n\tstruct attach *attach;\n\n\t_cleanup_free_ char *title_format = NULL;\n\t_cleanup_free_ char *field_format = NULL;\n\t_cleanup_free_ char *attach_id = NULL;\n\n\twhile ((option = getopt_long(argc, argv, \"cupFGxtoqj\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'S':\n\t\t\t\tsync = parse_sync_string(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tchoice = ALL;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tchoice = USERNAME;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tchoice = PASSWORD;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tchoice = URL;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tchoice = FIELD;\n\t\t\t\tfield = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tsearch = SEARCH_BASIC_REGEX;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tsearch = SEARCH_FIXED_SUBSTRING;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tchoice = ID;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tchoice = NAME;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tjson = true;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tchoice = ATTACH;\n\t\t\t\tattach_id = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'O':\n\t\t\t\tchoice = NOTES;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tclip = true;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\texpand_multi = true;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tfield_format = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\ttitle_format = xstrdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tquiet = true;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_show_usage);\n\t\t}\n\t}\n\n\tif (argc - optind < 1)\n\t\tdie_usage(cmd_show_usage);\n\n\tif (argc - optind > 1) {\n\t\t/*\n\t\t * if multiple search criteria supplied, go ahead\n\t\t * and expand all matches\n\t\t */\n\t\texpand_multi = true;\n\t}\n\n\tinit_all(sync, key, &session, &blob);\n\n\tINIT_LIST_HEAD(&matches);\n\tINIT_LIST_HEAD(&potential_set);\n\n\tif (!title_format) {\n\t\ttitle_format = xstrdup(\n\t\t\tTERMINAL_FG_CYAN \"%/as\" TERMINAL_RESET\n\t\t\tTERMINAL_FG_BLUE \"%/ag\"\n\t\t\tTERMINAL_BOLD \"%an\" TERMINAL_RESET\n\t\t\tTERMINAL_FG_GREEN \" [id: %ai]\" TERMINAL_RESET);\n\t}\n\tif (!field_format) {\n\t\tfield_format = xstrdup(\n\t\t\tTERMINAL_FG_YELLOW \"%fn\" TERMINAL_RESET \": %fv\");\n\t}\n\n\tlist_for_each_entry(account, &blob->account_head, list)\n\t\tlist_add(&account->match_list, &potential_set);\n\n\tfor (; optind < argc; optind++) {\n\n\t\tname = argv[optind];\n\n\t\tswitch (search) {\n\t\tcase SEARCH_EXACT_MATCH:\n\t\t\tfind_matching_accounts(&potential_set, name, &matches);\n\t\t\tbreak;\n\t\tcase SEARCH_BASIC_REGEX:\n\t\t\tfind_matching_regex(&potential_set, name, fields, &matches);\n\t\t\tbreak;\n\t\tcase SEARCH_FIXED_SUBSTRING:\n\t\t\tfind_matching_substr(&potential_set, name, fields, &matches);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (list_empty(&matches))\n\t\tdie(\"Could not find specified account(s).\");\n\n\tfound = list_first_entry(&matches, struct account, match_list);\n\tlast_found = list_last_entry(&matches, struct account, match_list);\n\tif (found != last_found && !expand_multi) {\n\t\t/* Multiple matches; dump the ids and exit */\n\t\tterminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD \"Multiple matches found.\\n\");\n\t\tlist_for_each_entry(found, &matches, match_list)\n\t\t\tprint_header(title_format, found);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\t/* reprompt if necessary for any matched item */\n\tlist_for_each_entry(found, &matches, match_list) {\n\t\tif (found->pwprotect) {\n\t\t\tunsigned char pwprotect_key[KDF_HASH_LEN];\n\t\t\tif (!agent_load_key(pwprotect_key))\n\t\t\t\tdie(\"Could not authenticate for protected entry.\");\n\t\t\tif (memcmp(pwprotect_key, key, KDF_HASH_LEN))\n\t\t\t\tdie(\"Current key is not on-disk key.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (clip)\n\t\tclipboard_open();\n\n\tif (json) {\n\t\tjson_format_account_list(&matches);\n\t\tgoto done;\n\t}\n\n\tlist_for_each_entry(account, &matches, match_list) {\n\n\t\tfound = account;\n\t\tlastpass_log_access(sync, session, key, found);\n\n\t\tnotes_expansion = notes_expand(found);\n\t\tif (notes_expansion)\n\t\t\tfound = notes_expansion;\n\n\t\tif (choice == FIELD) {\n\t\t\tbool has_field = false;\n\t\t\tlist_for_each_entry(found_field, &found->field_head, list) {\n\t\t\t\tif (!strcmp(found_field->name, field)) {\n\t\t\t\t\thas_field = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!has_field)\n\t\t\t\tdie(\"Could not find specified field '%s'.\", field);\n\t\t\tvalue = pretty_field_value(found_field);\n\t\t} else if (choice == USERNAME)\n\t\t\tvalue = xstrdup(found->username);\n\t\telse if (choice == PASSWORD)\n\t\t\tvalue = xstrdup(found->password);\n\t\telse if (choice == URL)\n\t\t\tvalue = xstrdup(found->url);\n\t\telse if (choice == ID)\n\t\t\tvalue = xstrdup(found->id);\n\t\telse if (choice == NAME)\n\t\t\tvalue = xstrdup(found->name);\n\t\telse if (choice == NOTES)\n\t\t\tvalue = xstrdup(found->note);\n\t\telse if (choice == ATTACH) {\n\t\t\tstruct attach *attach = find_attachment(found, attach_id);\n\t\t\tif (!attach)\n\t\t\t\tdie(\"Could not find specified attachment '%s'.\", attach_id);\n\t\t\tshow_attachment(session, found, attach, quiet);\n\t\t}\n\n\t\tif (choice == ALL) {\n\t\t\tprint_header(title_format, found);\n\n\t\t\tif (strlen(found->username))\n\t\t\t\tprint_field(field_format, found, \"Username\", found->username);\n\t\t\tif (strlen(found->password))\n\t\t\t\tprint_field(field_format, found, \"Password\", found->password);\n\t\t\tif (strlen(found->url) && strcmp(found->url, \"http://\"))\n\t\t\t\tprint_field(field_format, found, \"URL\", found->url);\n\t\t\tif (found->is_app) {\n\t\t\t\tapp = account_to_app(found);\n\t\t\t\tif (strlen(app->appname))\n\t\t\t\t\tprint_field(field_format, found, \"Application\", app->appname);\n\t\t\t}\n\n\t\t\tlist_for_each_entry(found_field, &found->field_head, list) {\n\t\t\t\tpretty_field = pretty_field_value(found_field);\n\t\t\t\tprint_field(field_format, found, found_field->name, pretty_field);\n\t\t\t\tfree(pretty_field);\n\t\t\t}\n\t\t\tlist_for_each_entry(attach, &found->attach_head, list) {\n\t\t\t\tprint_attachment(field_format, found, attach);\n\t\t\t}\n\t\t\tif (found->pwprotect)\n\t\t\t\tprint_field(field_format, found, \"Reprompt\", \"Yes\");\n\t\t\tif (strlen(found->note))\n\t\t\t\tprint_field(field_format, found, \"Notes\", found->note);\n\t\t} else if (choice != ATTACH) {\n\t\t\tif (!value)\n\t\t\t\tdie(\"Programming error.\");\n\t\t\tprintf(\"%s\", value);\n\t\t\tif (!clip)\n\t\t\t\tputchar('\\n');\n\t\t}\n\n\t\taccount_free(notes_expansion);\n\t}\ndone:\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd-status.c",
          "type": "blob",
          "size": 2.7734375,
          "content": "/*\n * command to get the status of the LastPass agent\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"agent.h\"\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"upload-queue.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nint cmd_status(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstatic struct option long_options[] = {\n\t\t{\"quiet\", no_argument, NULL, 'q'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tbool quiet = false;\n\t_cleanup_free_ char *username = NULL;\n\n\twhile ((option = getopt_long(argc, argv, \"q\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'q':\n\t\t\t\tquiet = true;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_status_usage);\n\t\t}\n\t}\n\n\tif (!agent_ask(key)) {\n\t\tif(!quiet) {\n\t\t\tterminal_printf(TERMINAL_FG_RED TERMINAL_BOLD \"Not logged in\" TERMINAL_RESET \".\\n\");\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif(!quiet) {\n\t\t\tusername = config_read_string(\"username\");\n\t\t\tterminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD \"Logged in\" TERMINAL_RESET \" as \" TERMINAL_UNDERLINE \"%s\" TERMINAL_RESET \".\\n\", username);\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
        },
        {
          "name": "cmd-sync.c",
          "type": "blob",
          "size": 2.6298828125,
          "content": "/*\n * command to synchronize with LastPass servers\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include \"upload-queue.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nint cmd_sync(int argc, char **argv)\n{\n\tunsigned char key[KDF_HASH_LEN];\n\tstruct session *session = NULL;\n\tstruct blob *blob = NULL;\n\tstatic struct option long_options[] = {\n\t\t{\"background\", no_argument, NULL, 'b'},\n\t\t{\"color\", required_argument, NULL, 'C'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\tbool background = false;\n\n\twhile ((option = getopt_long(argc, argv, \"b\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'b':\n\t\t\t\tbackground = true;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tterminal_set_color_mode(\n\t\t\t\t\tparse_color_mode_string(optarg));\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tdie_usage(cmd_sync_usage);\n\t\t}\n\t}\n\n\tinit_all(0, key, &session, NULL);\n\n\tupload_queue_ensure_running(key, session);\n\tif (!background) {\n\t\twhile (upload_queue_is_running())\n\t\t\tusleep(1000000 / 3);\n\t}\n\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n"
        },
        {
          "name": "cmd.c",
          "type": "blob",
          "size": 7.287109375,
          "content": "/*\n * general utility functions used by multiple commands\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"agent.h\"\n#include \"blob.h\"\n#include \"session.h\"\n#include \"util.h\"\n#include \"process.h\"\n#include <strings.h>\n#include <string.h>\n#include <regex.h>\n\nenum blobsync parse_sync_string(const char *syncstr)\n{\n\tif (!syncstr || !strcasecmp(syncstr, \"auto\"))\n\t\treturn BLOB_SYNC_AUTO;\n\telse if (!strcasecmp(syncstr, \"now\"))\n\t\treturn BLOB_SYNC_YES;\n\telse if (!strcasecmp(syncstr, \"no\"))\n\t\treturn BLOB_SYNC_NO;\n\telse\n\t\tdie_usage(\"... --sync=auto|now|no\");\n}\n\nenum color_mode parse_color_mode_string(const char *colormode)\n{\n\tif (!colormode || strcmp(colormode, \"auto\") == 0)\n\t\treturn COLOR_MODE_AUTO;\n\telse if (strcmp(colormode, \"never\") == 0)\n\t\treturn COLOR_MODE_NEVER;\n\telse if (strcmp(colormode, \"always\") == 0)\n\t\treturn COLOR_MODE_ALWAYS;\n\telse\n\t\tdie_usage(\"... --color=auto|never|always\");\n}\n\nbool parse_bool_arg_string(const char *extra)\n{\n\treturn !extra || strcmp(extra, \"true\") == 0;\n}\n\nenum note_type parse_note_type_string(const char *extra)\n{\n\tenum note_type result;\n\n\tresult = notes_get_type_by_shortname(extra);\n\tif (result == NOTE_TYPE_NONE) {\n\t\t_cleanup_free_ char *params = NULL;\n\t\t_cleanup_free_ char *usage = NULL;\n\n\t\tparams = note_type_usage();\n\t\txasprintf(&usage, \"... %s\", params);\n\t\tdie_usage(usage);\n\t}\n\n\treturn result;\n}\n\nvoid init_all(enum blobsync sync, unsigned char key[KDF_HASH_LEN], struct session **session, struct blob **blob)\n{\n\tif (!agent_get_decryption_key(key))\n\t\tdie(\"Could not find decryption key. Perhaps you need to login with `%s login`.\", ARGV[0]);\n\n\t*session = session_load(key);\n\tif (!*session)\n\t\tdie(\"Could not find session. Perhaps you need to login with `%s login`.\", ARGV[0]);\n\n\tif (blob) {\n\t\t*blob = blob_load(sync, *session, key);\n\t\tif (!*blob)\n\t\t\tdie(\"Unable to fetch blob. Either your session is invalid and you need to login with `%s login`, you need to synchronize, your blob is empty, or there is something wrong with your internet connection.\", ARGV[0]);\n\t}\n}\n\n/*\n * cmp_regex - do regex comparison with a basic regex\n */\nstatic int cmp_regex(const char *haystack, const char *needle)\n{\n\treturn regexec((void *) needle, haystack, 0, NULL, 0);\n}\n\n/*\n * cmp_substr - do substring comparison with a fixed pattern\n */\nstatic int cmp_substr(const char *haystack, const char *needle)\n{\n\treturn strstr(haystack, needle) == NULL;\n}\n\n/*\n * Search accounts with a given comparator.\n *\n * Any matched account is removed from the accounts list, and added to\n * ret_list.\n *\n * Note, the account list is iterated through match_list, so the caller\n * must first create a list of possible matches (from blob->account_head).\n * This is done instead of searching blob->account_head directly to enable\n * multiple searches of the potential match set.\n */\nstatic void search_accounts(struct list_head *accounts,\n\t\t\t    const void *needle,\n\t\t\t    int (*cmp)(const char *haystack, const char *needle),\n\t\t\t    int fields,\n\t\t\t    struct list_head *ret_list)\n{\n\tstruct account *account, *tmp;\n\tlist_for_each_entry_safe(account, tmp, accounts, match_list) {\n\t\tif (((fields & ACCOUNT_ID) && cmp(account->id, needle) == 0) ||\n\t\t    ((fields & ACCOUNT_NAME) && cmp(account->name, needle) == 0) ||\n\t\t    ((fields & ACCOUNT_FULLNAME) && cmp(account->fullname, needle) == 0) ||\n\t\t    ((fields & ACCOUNT_URL) && cmp(account->url, needle) == 0) ||\n\t\t    ((fields & ACCOUNT_USERNAME) && cmp(account->username, needle) == 0)) {\n\t\t\tlist_del(&account->match_list);\n\t\t\tlist_add_tail(&account->match_list, ret_list);\n\t\t}\n\t}\n}\n\n/*\n * Search accounts on given fields, returning results into ret_list.\n *\n * @pattern - a basic regular expression\n * @fields - which fields to search on\n */\nvoid find_matching_regex(struct list_head *accounts, const char *pattern,\n\t\t\t int fields, struct list_head *ret_list)\n{\n\tregex_t regex;\n\n\tif (regcomp(&regex, pattern, REG_ICASE))\n\t\tdie(\"Invalid regex '%s'\", pattern);\n\tsearch_accounts(accounts, &regex, cmp_regex, fields, ret_list);\n\tregfree(&regex);\n}\n\n/*\n * Search accounts on name, username, and url fields, adding all matches\n * into ret_list.\n *\n * @pattern - a basic regular expression\n * @fields - which fields to search on\n */\nvoid find_matching_substr(struct list_head *accounts, const char *pattern,\n\t\t\t  int fields, struct list_head *ret_list)\n{\n\tsearch_accounts(accounts, pattern, cmp_substr, fields, ret_list);\n}\n\n/*\n * Search list of accounts for any and all accounts matching a given name.\n * Matching accounts are appended to ret_list which should be initialized\n * by the caller.\n *\n * In the case of an id match, we return only the matching id entry.\n */\nvoid find_matching_accounts(struct list_head *accounts, const char *name,\n\t\t\t    struct list_head *ret_list)\n{\n\t/* look for exact id match */\n\tstruct account *account;\n\tlist_for_each_entry(account, accounts, match_list) {\n\t\tif (strcmp(name, \"0\") && !strcasecmp(account->id, name)) {\n\t\t\tlist_del(&account->match_list);\n\t\t\tlist_add_tail(&account->match_list, ret_list);\n\t\t\t/* if id match, stop processing */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* search for fullname or name match */\n\tsearch_accounts(accounts, name, strcmp,\n\t\t\tACCOUNT_NAME | ACCOUNT_FULLNAME,\n\t\t\tret_list);\n}\n\nstruct account *find_unique_account(struct blob *blob, const char *name)\n{\n\tstruct list_head matches;\n\tstruct list_head potential_set;\n\tstruct account *account, *last_account;\n\n\tINIT_LIST_HEAD(&matches);\n\tINIT_LIST_HEAD(&potential_set);\n\n\tlist_for_each_entry(account, &blob->account_head, list)\n\t\tlist_add(&account->match_list, &potential_set);\n\n\tfind_matching_accounts(&potential_set, name, &matches);\n\n\tif (list_empty(&matches))\n\t\treturn NULL;\n\n\taccount = list_first_entry(&matches, struct account, match_list);\n\tlast_account = list_last_entry(&matches, struct account, match_list);\n\n\tif (account != last_account)\n\t\tdie(\"Multiple matches found for '%s'. You must specify an ID instead of a name.\", name);\n\n\treturn account;\n}\n"
        },
        {
          "name": "cmd.h",
          "type": "blob",
          "size": 4.005859375,
          "content": "#ifndef CMD_H\n#define CMD_H\n\n#include \"blob.h\"\n#include \"session.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n\nenum search_type\n{\n\tSEARCH_EXACT_MATCH,\n\tSEARCH_BASIC_REGEX,\n\tSEARCH_FIXED_SUBSTRING,\n};\n\n#define BIT(x) (1ull << (x))\n\nenum account_field\n{\n\tACCOUNT_ID = BIT(0),\n\tACCOUNT_NAME = BIT(1),\n\tACCOUNT_FULLNAME = BIT(2),\n\tACCOUNT_URL = BIT(3),\n\tACCOUNT_USERNAME = BIT(4),\n};\n\nenum edit_choice\n{\n\tEDIT_NONE,\n\tEDIT_USERNAME,\n\tEDIT_PASSWORD,\n\tEDIT_URL,\n\tEDIT_FIELD,\n\tEDIT_NAME,\n\tEDIT_NOTES,\n\tEDIT_ANY\n};\n\nvoid init_all(enum blobsync sync, unsigned char key[KDF_HASH_LEN], struct session **session, struct blob **blob);\nenum blobsync parse_sync_string(const char *str);\nstruct account *find_unique_account(struct blob *blob, const char *name);\nvoid find_matching_accounts(struct list_head *accounts, const char *name,\n\t\t\t    struct list_head *ret_list);\nvoid find_matching_regex(struct list_head *accounts, const char *pattern,\n\t\t\t int fields, struct list_head *ret_list);\nvoid find_matching_substr(struct list_head *accounts, const char *pattern,\n\t\t\t  int fields, struct list_head *ret_list);\nenum color_mode parse_color_mode_string(const char *colormode);\nbool parse_bool_arg_string(const char *extra);\nenum note_type parse_note_type_string(const char *extra);\n\nint edit_account(struct session *session,\n\t\t struct blob *blob,\n\t\t enum blobsync sync,\n\t\t struct account *editable,\n\t\t enum edit_choice choice,\n\t\t const char *field,\n\t\t bool non_interactive,\n\t\t unsigned char key[KDF_HASH_LEN]);\n\nint edit_new_account(struct session *session,\n\t\t     struct blob *blob,\n\t\t     enum blobsync sync,\n\t\t     const char *name,\n\t\t     enum edit_choice choice,\n\t\t     const char *field,\n\t\t     bool non_interactive,\n\t\t     bool is_app,\n\t\t     enum note_type note_type,\n\t\t     unsigned char key[KDF_HASH_LEN]);\n\n#define color_usage \"[--color=auto|never|always]\"\n\nint cmd_login(int argc, char **argv);\n#define cmd_login_usage \"login [--trust] [--plaintext-key [--force, -f]] \" color_usage \" USERNAME\"\n\nint cmd_logout(int argc, char **argv);\n#define cmd_logout_usage \"logout [--force, -f] \" color_usage\n\nint cmd_passwd(int argc, char **argv);\n#define cmd_passwd_usage \"passwd\"\n\nint cmd_show(int argc, char **argv);\n#define cmd_show_usage \"show [--sync=auto|now|no] [--clip, -c] [--quiet, -q] [--expand-multi, -x] [--json, -j] [--all|--username|--password|--url|--notes|--field=FIELD|--id|--name|--attach=ATTACHID] [--basic-regexp, -G|--fixed-strings, -F] \" color_usage \" {UNIQUENAME|UNIQUEID}\"\n\nint cmd_ls(int argc, char **argv);\n#define cmd_ls_usage \"ls [--sync=auto|now|no] [--long, -l] [-m] [-u] \" color_usage \" [GROUP]\"\n\nint cmd_add(int argc, char **argv);\n#define cmd_add_usage \"add [--sync=auto|now|no] [--non-interactive] \" color_usage \" {--username|--password|--url|--notes|--field=FIELD|--note-type=NOTETYPE} NAME\"\n\nint cmd_edit(int argc, char **argv);\n#define cmd_edit_usage \"edit [--sync=auto|now|no] [--non-interactive] \" color_usage \" {--name|--username|--password|--url|--notes|--field=FIELD} {NAME|UNIQUEID}\"\n\nint cmd_generate(int argc, char **argv);\n#define cmd_generate_usage \"generate [--sync=auto|now|no] [--clip, -c] [--username=USERNAME] [--url=URL] [--no-symbols] {NAME|UNIQUEID} LENGTH\"\n\nint cmd_duplicate(int argc, char **argv);\n#define cmd_duplicate_usage \"duplicate [--sync=auto|now|no] \" color_usage \" {UNIQUENAME|UNIQUEID}\"\n\nint cmd_rm(int argc, char **argv);\n#define cmd_rm_usage \"rm [--sync=auto|now|no] \" color_usage \" {UNIQUENAME|UNIQUEID}\"\n\nint cmd_status(int argc, char **argv);\n#define cmd_status_usage \"status [--quiet, -q] \" color_usage\n\nint cmd_sync(int argc, char **argv);\n#define cmd_sync_usage \"sync [--background, -b] \" color_usage\n\nint cmd_export(int argc, char **argv);\n#define cmd_export_usage \"export [--sync=auto|now|no] \" color_usage \" [--fields=FIELDLIST]\"\n\nint cmd_share(int argc, char **argv);\n#define cmd_share_usage \"share subcommand sharename ...\"\n#endif\n\nint cmd_mv(int argc, char **argv);\n#define cmd_mv_usage \"mv \" color_usage \" {UNIQUENAME|UNIQUEID} GROUP\"\n\nint cmd_import(int argc, char **argv);\n#define cmd_import_usage \"import [--keep-dupes] [CSV_FILENAME]\"\n"
        },
        {
          "name": "config.c",
          "type": "blob",
          "size": 11.7177734375,
          "content": "/*\n * configuration file handling\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"config.h\"\n#include \"util.h\"\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <unistd.h>\n#include <utime.h>\n#include <string.h>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/hmac.h>\n\n/*\n * Map well-known pathnames to their configuration type.\n */\nstruct pathname_type_tuple {\n\tchar *name;\n\tenum config_type type;\n};\n\nstruct pathname_type_tuple pathname_type_lookup[] = {\n\t{ \"env\", CONFIG_CONFIG },\n\t{ \"blob\", CONFIG_DATA },\n\t{ \"iterations\", CONFIG_DATA },\n\t{ \"username\", CONFIG_DATA },\n\t{ \"verify\", CONFIG_DATA },\n\t{ \"plaintext_key\", CONFIG_DATA },\n\t{ \"trusted_id\", CONFIG_DATA },\n\t{ \"session_uid\", CONFIG_DATA },\n\t{ \"session_sessionid\", CONFIG_DATA },\n\t{ \"session_token\", CONFIG_DATA },\n\t{ \"session_privatekey\", CONFIG_DATA },\n\t{ \"session_server\", CONFIG_DATA },\n\t{ \"lpass.log\", CONFIG_DATA },\n\t{ \"agent.sock\", CONFIG_RUNTIME },\n\t{ \"uploader.pid\", CONFIG_RUNTIME },\n};\n\nchar *config_type_to_xdg[] = {\n\t[CONFIG_DATA] = \"XDG_DATA_HOME\",\n\t[CONFIG_CONFIG] = \"XDG_CONFIG_HOME\",\n\t[CONFIG_RUNTIME] = \"XDG_RUNTIME_DIR\",\n};\n\nstatic\nchar *get_xdg_dir(const char *xdg_var)\n{\n\tchar *home;\n\tchar *retstr = NULL;\n\n\tif (getenv(xdg_var))\n\t\treturn xstrdup(getenv(xdg_var));\n\n\t/*\n\t * $XDG var not set in environment; decide whether\n\t * to use backups locations based on existence of\n\t * $XDG_RUNTIME_DIR.\n\t */\n\tif (!getenv(\"XDG_RUNTIME_DIR\"))\n\t\treturn NULL;\n\n\thome = getenv(\"HOME\");\n\tif (!home)\n\t\treturn NULL;\n\n\tif (!strcmp(xdg_var, \"XDG_DATA_HOME\"))\n\t\txasprintf(&retstr, \"%s/.local/share\", home);\n\telse if (!strcmp(xdg_var, \"XDG_CONFIG_HOME\"))\n\t\txasprintf(&retstr, \"%s/.config\", home);\n\n\treturn retstr;\n}\n\n/*\n * Get the path to a config file given its name and the type of file.\n *\n * lpass looks for files in the following directories:\n *\n * First, if $LPASS_HOME is set, everything goes there.\n *\n * After that, if it is a persistent, user-specific data file,\n * it goes in $XDG_DATA_HOME/lpass.\n *\n * If a configuration item, it goes in $XDG_CONFIG_HOME.\n *\n * If a purely runtime item (socket, pidfile, etc) it goes in\n * $XDG_RUNTIME_HOME.\n *\n * If none of the $XDG environment variables are set, fall-back\n * to ~/.lpass.\n */\nstatic\nchar *config_path_for_type(enum config_type type, const char *name)\n{\n\tchar *home, *path, *xdg_env;\n\t_cleanup_free_ char *config = NULL;\n\t_cleanup_free_ char *xdg_dir = NULL;\n\tstruct stat sbuf;\n\tint ret;\n\n\txdg_env = config_type_to_xdg[type];\n\n\thome = getenv(\"LPASS_HOME\");\n\tif (home)\n\t\tconfig = xstrdup(home);\n\telse if ((xdg_dir = get_xdg_dir(xdg_env))) {\n\t\txasprintf(&config, \"%s/lpass\", xdg_dir);\n\t} else {\n\t\thome = getenv(\"HOME\");\n\t\tif (!home)\n\t\t\tdie(\"HOME is not set\");\n\n\t\txasprintf(&config, \"%s/.lpass\", home);\n\t}\n\n\tret = stat(config, &sbuf);\n\tif ((ret == -1 && errno == ENOENT) || !S_ISDIR(sbuf.st_mode)) {\n\t\tunlink(config);\n\t\tif (mkdir(config, 0700) < 0)\n\t\t\tdie_errno(\"mkdir(%s)\", config);\n\t} else if (ret == -1)\n\t\tdie_errno(\"stat(%s)\", config);\n\n\t_cleanup_free_ char *buffer = xstrdup(name);\n\t_cleanup_free_ char *dir_path = xstrdup(config);\n\tchar *saveptr = NULL;\n\tfor (char *token = strtok_r(buffer, \"/\", &saveptr); token && saveptr && strlen(saveptr) > 0; token = strtok_r(NULL, \"/\", &saveptr)) {\n\t\txstrappendf(&dir_path, \"/%s\", token);\n\n\t\tret = stat(dir_path, &sbuf);\n\t\tif ((ret == -1 && errno == ENOENT) || !S_ISDIR(sbuf.st_mode)) {\n\t\t\tunlink(dir_path);\n\t\t\tif (mkdir(dir_path, 0700) < 0)\n\t\t\t\tdie_errno(\"mkdir(%s)\", dir_path);\n\t\t} else if (ret == -1)\n\t\t\tdie_errno(\"stat(%s)\", dir_path);\n\t}\n\n\txasprintf(&path, \"%s/%s\", config, name);\n\n\treturn path;\n}\n\n\nenum config_type config_path_type(const char *name)\n{\n\tunsigned int i;\n\n\t/* aliases are config files */\n\tif (!strncmp(name, \"alias\", 5)) {\n\t\treturn CONFIG_CONFIG;\n\t}\n\n\t/* lock files are runtime */\n\tif (strlen(name) >= 5 && !strcmp(name + strlen(name) - 5, \".lock\")) {\n\t\treturn CONFIG_RUNTIME;\n\t}\n\n\t/* categorized this configuration file by name? */\n\tfor (i=0; i < ARRAY_SIZE(pathname_type_lookup); i++) {\n\t\tif (!strcmp(name, pathname_type_lookup[i].name)) {\n\t\t\treturn pathname_type_lookup[i].type;\n\t\t}\n\t}\n\n\t/* everything else is config_data */\n\treturn CONFIG_DATA;\n}\n\nchar *config_path(const char *name)\n{\n\treturn config_path_for_type(config_path_type(name), name);\n}\n\n\nFILE *config_fopen(const char *name, const char *mode)\n{\n\t_cleanup_free_ char *path = config_path(name);\n\treturn fopen(path, mode);\n}\n\nvoid config_touch(const char *name)\n{\n\t_cleanup_free_ char *path = NULL;\n\tpath = config_path(name);\n\tif (utime(path, NULL) < 0)\n\t\tdie_errno(\"utime\");\n}\n\nbool config_exists(const char *name)\n{\n\t_cleanup_free_ char *path = NULL;\n\tstruct stat sbuf;\n\n\tpath = config_path(name);\n\treturn stat(path, &sbuf) != -1;\n}\n\ntime_t config_mtime(const char *name)\n{\n\t_cleanup_free_ char *path = NULL;\n\tstruct stat sbuf;\n\n\tpath = config_path(name);\n\tif (stat(path, &sbuf) < 0)\n\t\treturn 0;\n\n\treturn sbuf.st_mtime;\n}\n\nbool config_unlink(const char *name)\n{\n\t_cleanup_free_ char *path = config_path(name);\n\treturn unlink(path) == 0;\n}\n\nvoid config_write_string(const char *name, const char *string)\n{\n\tconfig_write_buffer(name, string, strlen(string));\n}\n\nvoid config_write_buffer(const char *name, const char *buffer, size_t len)\n{\n\t_cleanup_free_ char *tempname = NULL;\n\t_cleanup_free_ char *finalpath = config_path(name);\n\tint tempfd;\n\tFILE *tempfile = NULL;\n\n\txasprintf(&tempname, \"%s.XXXXXX\", finalpath);\n\ttempfd = mkstemp(tempname);\n\tif (tempfd < 0)\n\t\tdie_errno(\"mkstemp(%s)\", tempname);\n\ttempfile = fdopen(tempfd, \"w\");\n\tif (!tempfile)\n\t\tgoto error;\n\tif (fwrite(buffer, 1, len, tempfile) != len)\n\t\tgoto error;\n\tfclose(tempfile);\n\ttempfile = NULL;\n\tif (rename(tempname, finalpath) < 0)\n\t\tgoto error;\n\treturn;\n\nerror:\n\ttempfd = errno;\n\tif (tempfile)\n\t\tfclose(tempfile);\n\tunlink(tempname);\n\terrno = tempfd;\n\tdie_errno(\"config-%s\", name);\n}\n\nchar *config_read_string(const char *name)\n{\n\t_cleanup_free_ char *buffer = NULL;\n\tsize_t len = config_read_buffer(name, (unsigned char **) &buffer);\n\n\tif (!buffer)\n\t\treturn NULL;\n\n\treturn xstrndup(buffer, len);\n}\n\nsize_t config_read_buffer(const char *name, unsigned char **out)\n{\n\t_cleanup_fclose_ FILE *file = NULL;\n\tunsigned char *buffer;\n\tsize_t len, read;\n\n\tfile = config_fopen(name, \"r\");\n\tif (!file) {\n\t\t*out = NULL;\n\t\treturn 0;\n\t}\n\n\tfor (len = 0, buffer = xmalloc(8192); ; buffer = xrealloc(buffer, len + 8192)) {\n\t\tread = fread(buffer + len, 1, 8192, file);\n\t\tlen += read;\n\t\tif (read != 8192) {\n\t\t\tif (ferror(file))\n\t\t\t\tdie_errno(\"fread(config-%s)\", name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*out = buffer;\n\treturn len;\n}\n\n/*\n * ciphertext = IV | aes-256-cbc(plaintext, key)\n * authenticated-ciphertext = HMAC-SHA256(ciphertext, key) | ciphertext\n *\n * These two functions work with `authenticated-ciphertext`.\n */\n\nstatic size_t encrypt_buffer(const char *buffer, size_t in_len, unsigned const char key[KDF_HASH_LEN], char **out)\n{\n\tEVP_CIPHER_CTX *ctx;\n\tchar *ciphertext;\n\tunsigned char iv[AES_BLOCK_SIZE];\n\tint out_len;\n\tunsigned int hmac_len;\n\tsize_t len;\n\n\tif (!RAND_bytes(iv, AES_BLOCK_SIZE))\n\t\tdie(\"Could not generate random bytes for CBC IV.\");\n\n\tciphertext = xcalloc(in_len + AES_BLOCK_SIZE * 2 + SHA256_DIGEST_LENGTH, 1);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (!ctx)\n\t\tgoto error;\n\n\tlen = SHA256_DIGEST_LENGTH;\n\tmemcpy(ciphertext + len, iv, AES_BLOCK_SIZE);\n\tlen += AES_BLOCK_SIZE;\n\n\tif (!EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))\n\t\tgoto error;\n\tif (!EVP_EncryptUpdate(ctx, (unsigned char *)(ciphertext + len), &out_len, (unsigned char *)buffer, in_len))\n\t\tgoto error;\n\tlen += out_len;\n\tif (!EVP_EncryptFinal_ex(ctx, (unsigned char *)(ciphertext + len), &out_len))\n\t\tgoto error;\n\tlen += out_len;\n\n\tif (!HMAC(EVP_sha256(), key, KDF_HASH_LEN, (unsigned char *)(ciphertext + SHA256_DIGEST_LENGTH), len - SHA256_DIGEST_LENGTH, (unsigned char *)ciphertext, &hmac_len))\n\t\tgoto error;\n\n\tEVP_CIPHER_CTX_free(ctx);\n\t*out = ciphertext;\n\treturn len;\n\nerror:\n\tEVP_CIPHER_CTX_free(ctx);\n\tfree(ciphertext);\n\tdie(\"Failed to encrypt data.\");\n\n}\n\nstatic size_t decrypt_buffer(const unsigned char *buffer, size_t in_len, unsigned const char key[KDF_HASH_LEN], unsigned char **out)\n{\n\tEVP_CIPHER_CTX *ctx;\n\tunsigned char *plaintext = NULL;\n\tint out_len;\n\tunsigned int hmac_len;\n\tsize_t len;\n\tunsigned char hmac[SHA256_DIGEST_LENGTH];\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (!ctx)\n\t\tgoto error;\n\n\tif (in_len < (SHA256_DIGEST_LENGTH + AES_BLOCK_SIZE * 2))\n\t\tgoto error;\n\n\tif (!HMAC(EVP_sha256(), key, KDF_HASH_LEN, (unsigned char *)(buffer + SHA256_DIGEST_LENGTH), in_len - SHA256_DIGEST_LENGTH, hmac, &hmac_len))\n\t\tgoto error;\n\tif (CRYPTO_memcmp(hmac, buffer, SHA256_DIGEST_LENGTH))\n\t\tgoto error;\n\n\tplaintext = xcalloc(in_len + AES_BLOCK_SIZE, 1);\n\tif (!EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, (unsigned char *)(buffer + SHA256_DIGEST_LENGTH)))\n\t\tgoto error;\n\tif (!EVP_DecryptUpdate(ctx, (unsigned char *)plaintext, &out_len, (unsigned char *)(buffer + SHA256_DIGEST_LENGTH + AES_BLOCK_SIZE), in_len - SHA256_DIGEST_LENGTH - AES_BLOCK_SIZE))\n\t\tgoto error;\n\tlen = out_len;\n\tif (!EVP_DecryptFinal_ex(ctx, (unsigned char *)(plaintext + out_len), &out_len))\n\t\tgoto error;\n\tlen += out_len;\n\tEVP_CIPHER_CTX_free(ctx);\n\t*out = plaintext;\n\treturn len;\n\nerror:\n\tEVP_CIPHER_CTX_free(ctx);\n\tfree(plaintext);\n\t*out = NULL;\n\treturn 0;\n}\n\nvoid config_write_encrypted_string(const char *name, const char *string, unsigned const char key[KDF_HASH_LEN])\n{\n\tconfig_write_encrypted_buffer(name, string, strlen(string), key);\n}\n\nvoid config_write_encrypted_buffer(const char *name, const char *buffer, size_t len, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *encrypted_buffer = NULL;\n\n\tlen = encrypt_buffer(buffer, len, key, &encrypted_buffer);\n\tconfig_write_buffer(name, encrypted_buffer, len);\n}\n\nchar *config_read_encrypted_string(const char *name, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *buffer = NULL;\n\tsize_t len = config_read_encrypted_buffer(name, (unsigned char **) &buffer, key);\n\n\tif (!buffer)\n\t\treturn NULL;\n\n\treturn xstrndup(buffer, len);\n}\n\nsize_t config_read_encrypted_buffer(const char *name, unsigned char **buffer, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ unsigned char *encrypted_buffer = NULL;\n\tsize_t len;\n\n\tlen = config_read_buffer(name, &encrypted_buffer);\n\tif (!encrypted_buffer) {\n\t\t*buffer = NULL;\n\t\treturn 0;\n\t}\n\n\treturn decrypt_buffer(encrypted_buffer, len, key, buffer);\n}\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 1.1171875,
          "content": "#ifndef CONFIG_H\n#define CONFIG_H\n\n#include \"kdf.h\"\n#include <stdio.h>\n#include <stdbool.h>\n#include <sys/types.h>\n\nenum config_type {\n\tCONFIG_DATA,\n\tCONFIG_CONFIG,\n\tCONFIG_RUNTIME,\n};\n\nchar *config_path(const char *name);\nFILE *config_fopen(const char *name, const char *mode);\nbool config_exists(const char *name);\nbool config_unlink(const char *name);\ntime_t config_mtime(const char *name);\nvoid config_touch(const char *name);\n\nvoid config_write_string(const char *name, const char *string);\nvoid config_write_buffer(const char *name, const char *buffer, size_t len);\nchar *config_read_string(const char *name);\nsize_t config_read_buffer(const char *name, unsigned char **buffer);\n\nvoid config_write_encrypted_string(const char *name, const char *string, unsigned const char key[KDF_HASH_LEN]);\nvoid config_write_encrypted_buffer(const char *name, const char *buffer, size_t len, unsigned const char key[KDF_HASH_LEN]);\nchar *config_read_encrypted_string(const char *name, unsigned const char key[KDF_HASH_LEN]);\nsize_t config_read_encrypted_buffer(const char *name, unsigned char **buffer, unsigned const char key[KDF_HASH_LEN]);\n\n\n#endif\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "edit.c",
          "type": "blob",
          "size": 17.12109375,
          "content": "/*\n * common routines for editing / adding accounts\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n\n#include \"cmd.h\"\n#include \"endpoints.h\"\n#include \"blob.h\"\n#include \"agent.h\"\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include \"util.h\"\n#include \"feature-flag.h\"\n\n#define MAX_NOTE_LEN (unsigned long) 45000\n\n#if defined(__linux__) || defined(__CYGWIN__)\nstatic char *shared_memory_dir(void)\n{\n\treturn xstrdup(\"/dev/shm\");\n}\n#elif defined(__APPLE__) && defined(__MACH__)\nstatic const char *shared_memory_dir_mount =\n\"dir=\\\"$(mktemp -d \\\"${TMPDIR:-/tmp}/lpass.XXXXXXXXXXXXX\\\")\\\"\\n\"\n\"dev=\\\"$(hdid -drivekey system-image=yes -nomount 'ram://32768' | cut -d ' ' -f 1)\\\"\\n\"\n\"[[ -z $dev ]] && exit 1\\n\"\n\"newfs_hfs -M 700 \\\"$dev\\\" >/dev/null 2>&1 || exit 1\\n\"\n\"mount -t hfs -o noatime -o nobrowse \\\"$dev\\\" \\\"$dir\\\" || exit 1\\n\"\n\"echo \\\"$dev\\\"\\necho \\\"$dir\\\"\\n\";\nstatic const char *shared_memory_dir_unmount =\n\"umount \\\"$SECURE_TMPDIR\\\"\\n\"\n\"diskutil quiet eject \\\"$RAMDISK_DEV\\\"\\n\"\n\"rm -rf \\\"$SECURE_TMPDIR\\\"\\n\";\nstatic void shared_memory_dir_eject(void)\n{\n\tsystem(shared_memory_dir_unmount);\n}\nstatic char *shared_memory_dir(void)\n{\n\tchar *stored = getenv(\"SECURE_TMPDIR\");\n\tif (stored)\n\t\treturn xstrdup(stored);\n\n\t_cleanup_free_ char *dev = NULL;\n\tchar *dir = NULL;\n\tsize_t len;\n\tFILE *script = popen(shared_memory_dir_mount, \"r\");\n\n\tif (!script)\n\t\treturn NULL;\n\n\tlen = 0;\n\tif (getline(&dev, &len, script) <= 0) {\n\t\tpclose(script);\n\t\treturn NULL;\n\t}\n\ttrim(dev);\n\n\tlen = 0;\n\tif (getline(&dir, &len, script) <= 0) {\n\t\tpclose(script);\n\t\treturn NULL;\n\t}\n\ttrim(dir);\n\n\tsetenv(\"SECURE_TMPDIR\", dir, true);\n\tsetenv(\"RAMDISK_DEV\", dev, true);\n\tatexit(shared_memory_dir_eject);\n\n\treturn dir;\n}\n#else\nstatic char *shared_memory_dir(void)\n{\n\tchar *tmpdir = getenv(\"SECURE_TMPDIR\");\n\tif (!tmpdir) {\n\t\tif (!(tmpdir = getenv(\"TMPDIR\")))\n\t\t\ttmpdir = \"/tmp\";\n\n\t\tfprintf(stderr,\n\t\t\t\"Warning: Using %s as secure temporary directory.\\n\"\n\t\t\t\"Recommend using tmpfs and encrypted swap.\\n\"\n\t\t\t\"Set SECURE_TMPDIR environment variable to override.\\n\",\n\t\t\ttmpdir);\n\t\tsleep(5);\n\t}\n\treturn xstrdup(tmpdir);\n}\n#endif\n_noreturn_ static inline void die_unlink_errno(const char *str, const char *file, const char *dir)\n{\n\tint saved = errno;\n\tif (file)\n\t\tunlink(file);\n\tif (dir)\n\t\trmdir(dir);\n\terrno = saved;\n\tdie_errno(\"%s\", str);\n}\n\nstatic void assign_account_value(struct account *account,\n\t\t\t\t const char *label,\n\t\t\t\t char *value,\n\t\t\t\t int lineno,\n\t\t\t\t unsigned char key[KDF_HASH_LEN],\n\t\t\t\t const struct feature_flag *feature_flag)\n{\n\tstruct field *editable_field = NULL;\n\n#define assign_if(title, field) do { \\\n\tif (!strcmp(label, title)) { \\\n\t\taccount_set_##field(account, xstrdup(trim(value)), key); \\\n\t\treturn; \\\n\t} \\\n\t} while (0)\n\n#define assign_if_ff(title, field, feature_flag) do { \\\n\tif (!strcmp(label, title)) { \\\n\t\taccount_set_##field(account, xstrdup(trim(value)), key, feature_flag); \\\n\t\treturn; \\\n\t} \\\n\t} while (0)\n\n\t/*\n\t * \"Name\" may be used in note templates; only assign fullname\n\t * in the first line.\n\t */\n\tif (lineno == 1) {\n\t\tassign_if(\"Name\", fullname);\n\t}\n\tassign_if_ff(\"URL\", url, feature_flag);\n\tassign_if(\"Username\", username);\n\tassign_if(\"Password\", password);\n\tassign_if(\"Application\", appname);\n\tassign_if(\"Notes\", note);\n\n\tif (!strcmp(label, \"Reprompt\")) {\n\t\taccount->pwprotect = !strcmp(trim(value), \"Yes\");\n\t\treturn;\n\t}\n\n\t/* if we got here maybe it's a secure note field */\n\tlist_for_each_entry(editable_field, &account->field_head, list) {\n\t\tif (!strcmp(label, editable_field->name)) {\n\t\t\tfield_set_value(account, editable_field,\n\t\t\t\t\txstrdup(trim(value)), key);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Some other name: value pair -- treat like a new field */\n\teditable_field = new0(struct field, 1);\n\teditable_field->name = xstrdup(label);\n\teditable_field->type = xstrdup(\"password\");\n\tfield_set_value(account, editable_field, xstrdup(trim(value)), key);\n\tlist_add_tail(&editable_field->list, &account->field_head);\n\n#undef assign_if\n}\n\nstatic\nint read_file_buf(FILE *fp, char **value_out, size_t *len_out)\n{\n\tsize_t len;\n\tsize_t read;\n\tchar *value;\n\n\t*len_out = 0;\n\t*value_out = NULL;\n\n\tfor (len = 0, value = xmalloc(8192 + 1); ; value = xrealloc(value, len + 8192 + 1)) {\n\t\tread = fread(value + len, 1, 8192, fp);\n\t\tlen += read;\n\t\tif (read != 8192) {\n\t\t\tif (ferror(fp))\n\t\t\t\treturn -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvalue[len] = '\\0';\n\t*value_out = value;\n\t*len_out = len;\n\treturn 0;\n}\n\nenum note_type get_note_type(struct account *account)\n{\n\tstruct field *editable_field;\n\n\tlist_for_each_entry(editable_field, &account->field_head, list) {\n\t\tif (!strcmp(editable_field->name, \"NoteType\")) {\n\t\t\treturn notes_get_type_by_name(editable_field->value);\n\t\t}\n\t}\n\treturn NOTE_TYPE_NONE;\n}\n\nstruct parsed_name_value\n{\n\tchar *name;\n\tchar *value;\n\tint lineno;\n\tstruct list_head list;\n};\n\n/*\n * Read a file representing all of the data in an account.\n * We generate this file when editing an account, and parse it back\n * after a user has edited it.\n *\n * Multiline values are accepted (though they may not be supported by\n * lastpass in all cases).\n *\n * Once the \"Notes:\" label is encountered, everything else is concatenated\n * into the note.\n *\n * Name: text0\n * URL: text1\n * [...]\n * Notes:\n * notes text here\n */\nstatic void parse_account_file(FILE *input, enum note_type note_type,\n\t\t\t       struct list_head *list_head)\n{\n\t_cleanup_free_ char *line = NULL;\n\tssize_t read;\n\tsize_t len = 0;\n\tchar *name, *delim, *value = NULL;\n\tbool parsing_notes = false;\n\tint ret;\n\tint lineno = 0;\n\n\tstruct parsed_name_value *current = NULL;\n\n\t/* parse label: [value] */\n\twhile ((read = getline(&line, &len, input)) != -1) {\n\t\tlineno++;\n\n\t\tline = trim(line);\n\t\tdelim = strchr(line, ':');\n\t\tif (!delim) {\n\t\t\t/* non keyed strings go to existing field (if any) */\n\t\t\tif (current)\n\t\t\t\txstrappendf(&current->value, \"\\n%s\", line);\n\t\t\tcontinue;\n\t\t}\n\n\t\tname = xstrndup(line, delim - line);\n\t\tvalue = xstrdup(delim + 1);\n\n\t\t/*\n\t\t * If this is a known notetype, append any non-existent\n\t\t * keys to the existing field.  For example, Proc-Type\n\t\t * in the ssh private key field goes into private key,\n\t\t * not a Proc-Type field.\n\t\t */\n\t\tif (note_type != NOTE_TYPE_NONE &&\n\t\t    !note_has_field(note_type, name) && current &&\n\t\t    note_field_is_multiline(note_type, current->name)) {\n\t\t\txstrappendf(&current->value, \"\\n%s\", line);\n\n\t\t\tfree(name);\n\t\t\tfree(value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(name, \"Notes\")) {\n\t\t\tparsing_notes = true;\n\t\t\tfree(name);\n\t\t\tfree(value);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent = new0(struct parsed_name_value, 1);\n\t\tcurrent->name = name;\n\t\tcurrent->value = value;\n\t\tcurrent->lineno = lineno;\n\t\tlist_add_tail(&current->list, list_head);\n\t}\n\n\tif (!parsing_notes)\n\t\treturn;\n\n\t/* everything else goes into notes section */\n\tvalue = NULL;\n\tlen = 0;\n\tret = read_file_buf(input, &value, &len);\n\tif (ret)\n\t\treturn;\n\n\tif (len > MAX_NOTE_LEN) {\n\t\tdie(\"Maximum note length is %lu bytes (was %lu)\",\n\t\t    MAX_NOTE_LEN, len);\n\t}\n\n\tcurrent = new0(struct parsed_name_value, 1);\n\tcurrent->name = xstrdup(\"Notes\");\n\tcurrent->value = value;\n\tcurrent->lineno = lineno;\n\tlist_add_tail(&current->list, list_head);\n}\n\nstatic void read_account_file(FILE *input, struct account *account,\n\t\t\t      unsigned char key[KDF_HASH_LEN], const struct feature_flag *feature_flag)\n{\n\tLIST_HEAD(fields);\n\tstruct parsed_name_value *entry, *tmp;\n\n\tparse_account_file(input, get_note_type(account), &fields);\n\n\tlist_for_each_entry_safe(entry, tmp, &fields, list) {\n\t\tassign_account_value(account, entry->name, entry->value,\n\t\t\t\t     entry->lineno, key, feature_flag);\n\t\tfree(entry->name);\n\t\tfree(entry->value);\n\t\tlist_del(&entry->list);\n\t\tfree(entry);\n\t}\n}\n\nstatic\nstruct field *add_default_field(struct account *account,\n\t\t\t        const char *field_name,\n\t\t\t        unsigned char key[KDF_HASH_LEN])\n{\n\tstruct field *editable_field = NULL;\n\tbool found = false;\n\n\tlist_for_each_entry(editable_field, &account->field_head, list) {\n\t\tif (!strcmp(editable_field->name, field_name)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn editable_field;\n\n\teditable_field = new0(struct field, 1);\n\teditable_field->type = xstrdup(\"text\");\n\teditable_field->name = xstrdup(field_name);\n\tfield_set_value(account, editable_field, xstrdup(\"\"), key);\n\n\tlist_add_tail(&editable_field->list, &account->field_head);\n\treturn editable_field;\n}\n\nstatic void add_default_fields(struct account *account,\n\t\t\t       enum note_type note_type,\n\t\t\t       unsigned char key[KDF_HASH_LEN])\n{\n\tint i;\n\tstruct note_template *tmpl;\n\n\tif (note_type <= NOTE_TYPE_NONE || note_type >= NUM_NOTE_TYPES)\n\t\treturn;\n\n\t/*\n\t * Add a new, empty field for any label in the template which\n\t * does not already exist in the account.\n\t */\n\ttmpl = &note_templates[note_type];\n\tfor (i=0; tmpl->fields[i]; i++) {\n\t\t/*\n\t\t * ... but skip these: they are already handled by the\n\t\t * collapse code.\n\t\t */\n\t\tif (!strcmp(tmpl->fields[i], \"Username\"))\n\t\t\tcontinue;\n\t\tif (!strcmp(tmpl->fields[i], \"Password\"))\n\t\t\tcontinue;\n\n\t\tadd_default_field(account, tmpl->fields[i], key);\n\t}\n}\n\nstatic int write_account_file(FILE *fp, struct account *account,\n\t\t\t      unsigned char key[KDF_HASH_LEN])\n{\n\tstruct field *editable_field = NULL;\n\tenum note_type note_type;\n\n#define write_field(title, field) do { \\\n\tif (fprintf(fp, \"%s: %s\\n\", title, field) < 0) \\\n\t\treturn -errno; \\\n\t} while (0)\n\n\twrite_field(\"Name\", account->fullname);\n\n\tnote_type = get_note_type(account);\n\n\tif (account->is_app) {\n\t\tstruct app *app = account_to_app(account);\n\n\t\twrite_field(\"Application\", app->appname);\n\t} else if (note_type != NOTE_TYPE_NONE) {\n\t\tadd_default_fields(account, note_type, key);\n\t} else {\n\t\twrite_field(\"URL\", account->url);\n\t\twrite_field(\"Username\", account->username);\n\t\twrite_field(\"Password\", account->password);\n\t}\n\n\tlist_for_each_entry(editable_field, &account->field_head, list) {\n\t\twrite_field(editable_field->name, editable_field->value);\n\t}\n\n\tif (account->pwprotect) {\n\t\twrite_field(\"Reprompt\", \"Yes\");\n\t}\n\n\tif (fprintf(fp, \"Notes:    # Add notes below this line.\\n%s\", account->note) < 0)\n\t\treturn -errno;\n\n\treturn 0;\n#undef write_field\n}\n\nint edit_account(struct session *session,\n\t\t struct blob *blob,\n\t\t enum blobsync sync,\n\t\t struct account *editable,\n\t\t enum edit_choice choice,\n\t\t const char *field,\n\t\t bool non_interactive,\n\t\t unsigned char key[KDF_HASH_LEN])\n{\n\tsize_t len;\n\tstruct account *notes_expansion, *notes_collapsed = NULL;\n\tstruct field *editable_field = NULL;\n\t_cleanup_free_ char *tmppath = NULL;\n\t_cleanup_free_ char *tmpdir = NULL;\n\t_cleanup_free_ char *editcmd = NULL;\n\tint tmpfd;\n\tFILE *tmpfile;\n\tchar *value;\n\tint ret;\n\n\tstruct share *old_share = editable->share;\n\n\tnotes_expansion = notes_expand(editable);\n\tif (notes_expansion) {\n\t\tnotes_collapsed = editable;\n\t\teditable = notes_expansion;\n\t} else if (choice == EDIT_FIELD)\n\t\tdie(\"Editing fields of entries that are not secure notes is currently not supported.\");\n\n\tswitch(choice)\n\t{\n\tcase EDIT_USERNAME:\n\t\tvalue = editable->username;\n\t\tbreak;\n\tcase EDIT_PASSWORD:\n\t\tvalue = editable->password;\n\t\tbreak;\n\tcase EDIT_URL:\n\t\tvalue = editable->url;\n\t\tbreak;\n\tcase EDIT_NAME:\n\t\tvalue = editable->fullname;\n\t\tbreak;\n\tcase EDIT_FIELD:\n\t\teditable_field = add_default_field(editable, field, key);\n\t\tvalue = editable_field->value;\n\t\tbreak;\n\tcase EDIT_NOTES:\n\t\tvalue = editable->note;\n\t\tbreak;\n\tdefault:\n\t\tvalue = NULL;\n\t}\n\n\tif (!non_interactive) {\n\t\tif (editable->pwprotect) {\n\t\t\tunsigned char pwprotect_key[KDF_HASH_LEN];\n\t\t\tif (!agent_load_key(pwprotect_key))\n\t\t\t\tdie(\"Could not authenticate for protected entry.\");\n\t\t\tif (memcmp(pwprotect_key, key, KDF_HASH_LEN))\n\t\t\t\tdie(\"Current key is not on-disk key.\");\n\t\t}\n\n\t\tif (strcmp(editable->id, \"0\"))\n\t\t\tlastpass_log_access(sync, session, key, editable);\n\n\t\ttmpdir = shared_memory_dir();\n\t\txstrappend(&tmpdir, \"/lpass.XXXXXX\");\n\t\tif (!mkdtemp(tmpdir))\n\t\t\tdie_errno(\"mkdtemp\");\n\t\txasprintf(&tmppath, \"%s/lpass.XXXXXX\", tmpdir);\n\t\ttmpfd = mkstemp(tmppath);\n\t\tif (tmpfd < 0)\n\t\t\tdie_unlink_errno(\"mkstemp\", tmppath, tmpdir);\n\t\ttmpfile = fdopen(tmpfd, \"w\");\n\t\tif (!tmpfile)\n\t\t\tdie_unlink_errno(\"fdopen\", tmppath, tmpdir);\n\n\t\tif (choice == EDIT_ANY) {\n\t\t\tif (write_account_file(tmpfile, editable, key))\n\t\t\t\tdie_unlink_errno(\"fprintf\", tmppath, tmpdir);\n\t\t} else {\n\t\t\tif (fprintf(tmpfile, \"%s\\n\", value) < 0)\n\t\t\t\tdie_unlink_errno(\"fprintf\", tmppath, tmpdir);\n\t\t}\n\t\tfclose(tmpfile);\n\n\t\txasprintf(&editcmd, \"${VISUAL:-${EDITOR:-vi}} '%s'\", tmppath);\n\t\tif (system(editcmd) < 0)\n\t\t\tdie_unlink_errno(\"system($VISUAL)\", tmppath, tmpdir);\n\n\t\ttmpfile = fopen(tmppath, \"r\");\n\t} else\n\t\ttmpfile = stdin;\n\tif (!tmpfile)\n\t\tdie_unlink_errno(\"fopen\", tmppath, tmpdir);\n\n\tif (choice == EDIT_NOTES) {\n\t\tret = read_file_buf(tmpfile, &value, &len);\n\t\tif (ret)\n\t\t\tdie_unlink_errno(\"fread(tmpfile)\", tmppath, tmpdir);\n\t} else if (choice == EDIT_ANY) {\n\t\tread_account_file(tmpfile, editable, key, &session->feature_flag);\n\t\tvalue = NULL;\n\t} else {\n\t\tret = read_file_buf(tmpfile, &value, &len);\n\t\tif (ret)\n\t\t\tdie_unlink_errno(\"fread(tmpfile)\", tmppath, tmpdir);\n\t}\n\tfclose(tmpfile);\n\n\tif (value) {\n\t\tlen = strlen(value);\n\t\tif (len && value[len - 1] == '\\n')\n\t\t\tvalue[len - 1] = '\\0';\n\t}\n\tif (tmppath) {\n\t\tunlink(tmppath);\n\t\trmdir(tmpdir);\n\t}\n\n\tif (choice == EDIT_USERNAME)\n\t\taccount_set_username(editable, value, key);\n\telse if (choice == EDIT_PASSWORD)\n\t\taccount_set_password(editable, value, key);\n\telse if (choice == EDIT_URL)\n\t\taccount_set_url(editable, value, key, &session->feature_flag);\n\telse if (choice == EDIT_NAME)\n\t\taccount_set_fullname(editable, value, key);\n\telse if (choice == EDIT_NOTES)\n\t\taccount_set_note(editable, value, key);\n\telse if (choice == EDIT_FIELD) {\n\t\tif (!value || !strlen(value)) {\n\t\t\tlist_del(&editable_field->list);\n\t\t\tfield_free(editable_field);\n\t\t} else\n\t\t\tfield_set_value(editable, editable_field, value, key);\n\t}\n\n\tif (notes_expansion && notes_collapsed) {\n\t\teditable = notes_collapsed;\n\t\tnotes_collapsed = notes_collapse(notes_expansion);\n\t\taccount_free(notes_expansion);\n\t\taccount_set_note(editable, xstrdup(notes_collapsed->note), key);\n\t\taccount_set_fullname(editable, xstrdup(notes_collapsed->fullname), key);\n\t\teditable->pwprotect = notes_collapsed->pwprotect;\n\t\taccount_free(notes_collapsed);\n\t}\n\n\taccount_assign_share(blob, editable, key, &session->feature_flag);\n\tif (old_share != editable->share) {\n\t\tdie(\"Use lpass mv to move items to/from shared folders\");\n\t}\n\n\tlastpass_update_account(sync, key, session, editable, blob);\n\tblob_save(blob, key, &session->feature_flag);\n\n\tsession_free(session);\n\tblob_free(blob);\n\treturn 0;\n}\n\nint edit_new_account(struct session *session,\n\t\t     struct blob *blob,\n\t\t     enum blobsync sync,\n\t\t     const char *name,\n\t\t     enum edit_choice choice,\n\t\t     const char *field,\n\t\t     bool non_interactive,\n\t\t     bool is_app,\n\t\t     enum note_type note_type,\n\t\t     unsigned char key[KDF_HASH_LEN])\n{\n\tstruct app *app;\n\tstruct account *account;\n\n\tif (note_type != NOTE_TYPE_NONE &&\n\t    choice != EDIT_NOTES && choice != EDIT_ANY) {\n\t\tdie(\"Note type may only be used with secure notes\");\n\t}\n\n\tif (is_app) {\n\t\tapp = new_app();\n\t\taccount = &app->account;\n\t} else {\n\t\taccount = new_account();\n\t}\n\n\taccount->id = xstrdup(\"0\");\n\taccount->attachkey = xstrdup(\"\");\n\taccount->attachkey_encrypted = xstrdup(\"\");\n\taccount_set_password(account, xstrdup(\"\"), key);\n\taccount_set_fullname(account, xstrdup(name), key);\n\taccount_set_username(account, xstrdup(\"\"), key);\n\taccount_set_note(account, xstrdup(\"\"), key);\n\tif (choice == EDIT_NOTES || note_type != NOTE_TYPE_NONE) {\n\t\taccount_set_url(account, xstrdup(\"http://sn\"), key, &session->feature_flag);\n\t} else {\n\t\taccount_set_url(account, xstrdup(\"\"), key, &session->feature_flag);\n\t}\n\taccount_assign_share(blob, account, key, &session->feature_flag);\n\tlist_add(&account->list, &blob->account_head);\n\n\tif (note_type != NOTE_TYPE_NONE) {\n\t\tchar *note_type_str = NULL;\n\t\txasprintf(&note_type_str, \"NoteType:%s\\n\",\n\t\t\t  notes_get_name(note_type));\n\t\taccount_set_note(account, note_type_str, key);\n\t}\n\n\treturn edit_account(session, blob, sync, account, choice, field,\n\t\t\t    non_interactive, key);\n}\n"
        },
        {
          "name": "endpoints-login.c",
          "type": "blob",
          "size": 10.9453125,
          "content": "/*\n * https endpoints for logging into LastPass\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"endpoints.h\"\n#include \"http.h\"\n#include \"xml.h\"\n#include \"password.h\"\n#include \"config.h\"\n#include \"util.h\"\n#include \"upload-queue.h\"\n#include \"version.h\"\n#include \"terminal.h\"\n#include <sys/utsname.h>\n#include <string.h>\n\nstruct multifactor_type {\n    const char *name;\n    const char *error_str;\n    const char *error_failure_str;\n    const char *post_var;\n};\nstatic struct multifactor_type multifactor_types[] = {\n\t{\n\t\t.name = \"Google Authenticator Code\",\n\t\t.error_str = \"googleauthrequired\",\n\t\t.error_failure_str = \"googleauthfailed\",\n\t\t.post_var = \"otp\"\n\t},\n\t{\n\t\t.name = \"YubiKey OTP\",\n\t\t.error_str = \"otprequired\",\n\t\t.error_failure_str = \"otpfailed\",\n\t\t.post_var = \"otp\"\n\t},\n\t{\n\t\t.name = \"Sesame OTP\",\n\t\t.error_str = \"sesameotprequired\",\n\t\t.error_failure_str = \"sesameotpfailed\",\n\t\t.post_var = \"sesameotp\"\n\t},\n\t{\n\t\t.name = \"Out-of-Band OTP\",\n\t\t.error_str = \"outofbandrequired\",\n\t\t.error_failure_str = \"multifactorresponsefailed\",\n\t\t.post_var = \"otp\"\n\t},\n    {\n        .name = \"Microsoft Authenticator Code\",\n        .error_str = \"microsoftauthrequired\",\n        .error_failure_str = \"microsoftauthfailed\",\n        .post_var = \"otp\"\n    }\n};\n\nstatic void filter_error_message(char *message)\n{\n\tchar *nullit;\n\n\tnullit = strstr(message, \" Upgrade your browser extension so you can enter it.\");\n\tif (nullit)\n\t\t*nullit = '\\0';\n}\n\nstatic inline void append_post(char **args, const char *name, const char *val)\n{\n\tchar **last = args;\n\twhile (*last && strcmp(*last, name))\n\t\t++last;\n\t*last = (char *)name;\n\t*(last + 1) = (char *)val;\n}\n\nstatic char *calculate_trust_id(bool force)\n{\n\tchar *trusted_id;\n\n\ttrusted_id = config_read_string(\"trusted_id\");\n\tif (force && !trusted_id) {\n\t\ttrusted_id = xcalloc(33, 1);\n\t\tfor (size_t i = 0; i < 32; ++i)\n\t\t\ttrusted_id[i] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$\"[range_rand(0, 66)];\n\t\tconfig_write_string(\"trusted_id\", trusted_id);\n\t}\n\n\treturn trusted_id;\n}\n\nstatic char *calculate_trust_label(void)\n{\n\tchar *trusted_label;\n\tstruct utsname utsname;\n\n\tif (uname(&utsname) < 0)\n\t\tdie_errno(\"Failed to determine uname.\");\n\n\txasprintf(&trusted_label, \"%s - %s %s\", utsname.nodename, utsname.sysname, utsname.release);\n\n\treturn trusted_label;\n}\n\nstatic bool error_post(char **message, struct session **session)\n{\n\t*session = NULL;\n\tif (message)\n\t\t*message = xstrdup(\"Unable to post login request.\");\n\treturn true;\n}\n\n\nstatic bool error_other(char **message, struct session **session, const char *txt)\n{\n\t*session = NULL;\n\tif (message)\n\t\t*message = xstrdup(txt);\n\treturn true;\n}\n\nstatic bool error_message(char **message, struct session **session, const char *reply)\n{\n\t*session = NULL;\n\tif (message) {\n\t\t*message = xml_error_cause(reply, \"message\");\n\t\tif (*message)\n\t\t\tfilter_error_message(*message);\n\t\telse\n\t\t\t*message = xstrdup(\"Could not parse error message to login request.\");\n\n\t}\n\treturn true;\n}\n\nstatic bool ordinary_login(const char *login_server, const unsigned char key[KDF_HASH_LEN], char **args, char **cause, char **message, char **reply, struct session **session,\n\t\t\t   char **ret_login_server)\n{\n\tchar *server;\n\n\tfree(*reply);\n\t*reply = http_post_lastpass_v(login_server, \"login.php\", NULL, NULL, args);\n\tif (!*reply)\n\t\treturn error_post(message, session);\n\n\t*session = xml_ok_session(*reply, key);\n\tif (*session) {\n\t\t(*session)->server = xstrdup(login_server);\n\t\treturn true;\n\t}\n\n\t/* handle server redirection if requested for lastpass.eu */\n\tserver = xml_error_cause(*reply, \"server\");\n\tif (server && strcmp(server, \"lastpass.eu\") == 0)\n\t\treturn ordinary_login(server, key, args, cause, message, reply, session, ret_login_server);\n\n\t*cause = xml_error_cause(*reply, \"cause\");\n\tif (!*cause)\n\t\treturn error_other(message, session, \"Unable to determine login failure cause.\");\n\n\t*ret_login_server = xstrdup(login_server);\n\treturn false;\n}\n\nstatic inline bool has_capabilities(const char *capabilities, const char *capability)\n{\n\t_cleanup_free_ char *caps = xstrdup(capabilities);\n\tchar *token;\n\n\tfor (token = strtok(caps, \",\"); token; token = strtok(NULL, \",\")) {\n\t\tif (!strcmp(capability, token))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool oob_login(const char *login_server, const unsigned char key[KDF_HASH_LEN], char **args, char **message, char **reply, char **oob_name, struct session **session)\n{\n\t_cleanup_free_ char *oob_capabilities = NULL;\n\t_cleanup_free_ char *cause = NULL;\n\t_cleanup_free_ char *retryid = NULL;\n\tbool can_do_passcode;\n\tbool ret;\n\n\t*oob_name = xml_error_cause(*reply, \"outofbandname\");\n\toob_capabilities = xml_error_cause(*reply, \"capabilities\");\n\tif (!*oob_name || !oob_capabilities)\n\t\treturn error_other(message, session, \"Could not determine out-of-band type.\");\n\tcan_do_passcode = has_capabilities(oob_capabilities, \"passcode\");\n\tif (can_do_passcode && !has_capabilities(oob_capabilities, \"outofband\")) {\n\t\txstrappend(oob_name, \" OTP\");\n\t\tgoto failure;\n\t}\n\n\tterminal_fprintf(stderr, TERMINAL_FG_YELLOW TERMINAL_BOLD \"Waiting for approval of out-of-band %s login%s\" TERMINAL_NO_BOLD \"...\", *oob_name, can_do_passcode ? \", or press Ctrl+C to enter a passcode\" : \"\");\n\tappend_post(args, \"outofbandrequest\", \"1\");\n\tfor (;;) {\n\t\tfree(*reply);\n\t\t*reply = http_post_lastpass_v(login_server, \"login.php\", NULL, NULL, args);\n\t\tif (!*reply) {\n\t\t\tif (can_do_passcode) {\n\t\t\t\tappend_post(args, \"outofbandrequest\", \"0\");\n\t\t\t\tappend_post(args, \"outofbandretry\", \"0\");\n\t\t\t\tappend_post(args, \"outofbandretryid\", \"\");\n\t\t\t\txstrappend(oob_name, \" OTP\");\n\t\t\t\tgoto failure;\n\t\t\t} else {\n\t\t\t\terror_post(message, session);\n\t\t\t\tgoto success;\n\t\t\t}\n\t\t}\n\t\t*session = xml_ok_session(*reply, key);\n\t\tif (*session) {\n\t\t\t(*session)->server = xstrdup(login_server);\n\t\t\tgoto success;\n\t\t}\n\n\t\tfree(cause);\n\t\tcause = xml_error_cause(*reply, \"cause\");\n\t\tif (cause && !strcmp(cause, \"outofbandrequired\")) {\n\t\t\tfree(retryid);\n\t\t\tretryid = xml_error_cause(*reply, \"retryid\");\n\t\t\tappend_post(args, \"outofbandretry\", \"1\");\n\t\t\tappend_post(args, \"outofbandretryid\", retryid);\n\t\t\tfprintf(stderr, \".\");\n\t\t\tcontinue;\n\t\t}\n\t\terror_message(message, session, *reply);\n\t\tgoto success;\n\t}\n\nsuccess:\n\tret = true;\n\tgoto out;\nfailure:\n\tret = false;\n\tgoto out;\nout:\n\tterminal_fprintf(stderr, TERMINAL_RESET \"\\n\" TERMINAL_UP_CURSOR(1) TERMINAL_CLEAR_DOWN);\n\treturn ret;\n}\n\nstatic bool otp_login(const char *login_server, const unsigned char key[KDF_HASH_LEN], char **args, char **message, char **reply, const char *otp_name, const char *cause, const char *username, struct session **session)\n{\n\tstruct multifactor_type *replied_multifactor = NULL;\n\t_cleanup_free_ char *multifactor = NULL;\n\t_cleanup_free_ char *next_cause = NULL;\n\tchar *multifactor_error = NULL;\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(multifactor_types); ++i) {\n\t\tif (!strcmp(multifactor_types[i].error_str, cause)) {\n\t\t\treplied_multifactor = &multifactor_types[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!replied_multifactor)\n\t\treturn error_message(message, session, *reply);\n\n\tfor (;;) {\n\t\tfree(multifactor);\n\t\tmultifactor = password_prompt(\"Code\", multifactor_error, \"Please enter your %s for <%s>.\", otp_name ? otp_name : replied_multifactor->name, username);\n\t\tif (!multifactor)\n\t\t\treturn error_other(message, session, \"Aborted multifactor authentication.\");\n\t\tappend_post(args, replied_multifactor->post_var, multifactor);\n\n\t\tfree(*reply);\n\t\t*reply = http_post_lastpass_v(login_server, \"login.php\", NULL, NULL, args);\n\t\tif (!*reply)\n\t\t\treturn error_post(message, session);\n\n\t\t*session = xml_ok_session(*reply, key);\n\t\tif (*session) {\n\t\t\t(*session)->server = xstrdup(login_server);\n\t\t\treturn true;\n\t\t}\n\n\t\tfree(next_cause);\n\t\tnext_cause = xml_error_cause(*reply, \"cause\");\n\t\tif (next_cause && !strcmp(next_cause, replied_multifactor->error_failure_str))\n\t\t\tmultifactor_error = \"Invalid multifactor code; please try again.\";\n\t\telse\n\t\t\treturn error_message(message, session, *reply);\n\t}\n}\n\nstruct session *lastpass_login(const char *username, const char hash[KDF_HEX_LEN], const unsigned char key[KDF_HASH_LEN], int iterations, char **error_message, bool trust)\n{\n\tchar *args[33];\n\t_cleanup_free_ char *user_lower = NULL;\n\t_cleanup_free_ char *iters = NULL;\n\t_cleanup_free_ char *trusted_id = NULL;\n\t_cleanup_free_ char *trusted_label = NULL;\n\t_cleanup_free_ char *cause = NULL;\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *otp_name = NULL;\n\t_cleanup_free_ char *login_server = NULL;\n\tstruct session *session = NULL;\n\n\titers = xultostr(iterations);\n\tuser_lower = xstrlower(username);\n\ttrusted_id = calculate_trust_id(trust);\n\n\tmemset(args, 0, sizeof(args));\n\tappend_post(args, \"xml\", \"2\");\n\tappend_post(args, \"username\", user_lower);\n\tappend_post(args, \"hash\", hash);\n\tappend_post(args, \"iterations\", iters);\n\tappend_post(args, \"includeprivatekeyenc\", \"1\");\n\tappend_post(args, \"method\", \"cli\");\n\tappend_post(args, \"outofbandsupported\", \"1\");\n\tif (trusted_id)\n\t\tappend_post(args, \"uuid\", trusted_id);\n\n\tif (ordinary_login(LASTPASS_SERVER, key, args, &cause, error_message, &reply, &session, &login_server))\n\t\treturn session;\n\n\tif (trust) {\n\t\ttrusted_label = calculate_trust_label();\n\t\tappend_post(args, \"trustlabel\", trusted_label);\n\t}\n\n\tif (cause && !strcmp(cause, \"outofbandrequired\") &&\n\t    oob_login(login_server, key, args, error_message, &reply, &otp_name, &session)) {\n\t\tif (trust)\n\t\t\thttp_post_lastpass(\"trust.php\", session, NULL, \"token\", session->token, \"uuid\", trusted_id, \"trustlabel\", trusted_label, NULL);\n\t\treturn session;\n\t}\n\n\tif (otp_login(login_server, key, args, error_message, &reply, otp_name, cause, user_lower, &session))\n\t\treturn session;\n\n\terror_other(error_message, &session, \"An unspecified error occurred.\");\n\treturn NULL;\n}\n"
        },
        {
          "name": "endpoints-share.c",
          "type": "blob",
          "size": 12.5654296875,
          "content": "/*\n * https endpoints for shared folder manipulation\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"endpoints.h\"\n#include \"http.h\"\n#include \"version.h\"\n#include \"xml.h\"\n#include \"config.h\"\n#include \"util.h\"\n#include \"upload-queue.h\"\n#include <string.h>\n#include <errno.h>\n#include <curl/curl.h>\n\nint lastpass_share_getinfo(const struct session *session, const char *shareid,\n\t\t\t   struct list_head *users)\n{\n\t_cleanup_free_ char *reply = NULL;\n\tsize_t len;\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"sharejs\", \"1\", \"getinfo\", \"1\",\n\t\t\t\t   \"id\", shareid, \"xmlr\", \"1\", NULL);\n\tif (!reply)\n\t\treturn -EPERM;\n\n\txml_parse_share_getinfo(reply, users);\n\treturn 0;\n}\n\nstatic\nint lastpass_share_get_user_by_uid(const struct session *session,\n\t\t\t\t   const char *uid,\n\t\t\t\t   struct share_user *user)\n{\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *uid_param;\n\tsize_t len;\n\n\txasprintf(&uid_param, \"{\\\"%s\\\":{}}\", uid);\n\n\t/* get the pubkey for the user/group */\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"getpubkey\", \"1\",\n\t\t\t\t   \"uid\", uid_param,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\treturn xml_parse_share_getpubkey(reply, user);\n}\n\nstatic\nint lastpass_share_get_users_by_username(const struct session *session,\n\t\t\t\t\t const char *username,\n\t\t\t\t\t struct list_head *users)\n{\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *uid_param;\n\tsize_t len;\n\n\txasprintf(&uid_param, \"{\\\"%s\\\":{}}\", username);\n\n\t/* get the pubkey for the user/group */\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"getpubkey\", \"1\",\n\t\t\t\t   \"uid\", uid_param,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\treturn xml_parse_share_getpubkeys(reply, users);\n}\n\nint lastpass_share_user_add(const struct session *session,\n\t\t\t    struct share *share,\n\t\t\t    struct share_user *user)\n{\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *enc_share_name = NULL;\n\t_cleanup_free_ char *hex_share_key = NULL;\n\t_cleanup_free_ unsigned char *enc_share_key = NULL;\n\t_cleanup_free_ char *hex_enc_share_key = NULL;\n\tint ret;\n\tsize_t len;\n\n\tstruct list_head user_list;\n\tstruct share_user *share_user, *tmp;\n\n\tINIT_LIST_HEAD(&user_list);\n\n\tret = lastpass_share_get_users_by_username(session, user->username,\n\t\t\t\t\t\t   &user_list);\n\tif (ret)\n\t\tdie(\"Unable to lookup user %s (%d)\\n\", user->username, ret);\n\n\tlist_for_each_entry_safe(share_user, tmp, &user_list, list) {\n\n\t\t/* encrypt sharename with sharekey */\n\t\tenc_share_name = encrypt_and_base64(share->name, share->key);\n\n\t\t/* encrypt sharekey with user's pubkey */\n\t\tbytes_to_hex(share->key, &hex_share_key, sizeof(share->key));\n\n\t\tsize_t enc_share_key_len = share_user->sharing_key.len;\n\n\t\tif (enc_share_key_len) {\n\t\t\tenc_share_key = xmalloc(enc_share_key_len);\n\n\t\t\tret = cipher_rsa_encrypt(hex_share_key, &share_user->sharing_key,\n\t\t\t\t\t\tenc_share_key, &enc_share_key_len);\n\t\t\tif (ret)\n\t\t\t\tdie(\"Unable to encrypt sharing key with pubkey (%d)\\n\",\n\t\t\t\t\tret);\n\n\t\t\tbytes_to_hex(enc_share_key, &hex_enc_share_key,\n\t\t\t\t\tenc_share_key_len);\n\n\t\t\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t\t\t\"token\", session->token,\n\t\t\t\t\t\t\"id\", share->id,\n\t\t\t\t\t\t\"update\", \"1\",\n\t\t\t\t\t\t\"add\", \"1\",\n\t\t\t\t\t\t\"notify\", \"1\",\n\t\t\t\t\t\t\"username0\", share_user->username,\n\t\t\t\t\t\t\"cgid0\", share_user->cgid ? share_user->cgid : \"\",\n\t\t\t\t\t\t\"sharekey0\", hex_enc_share_key,\n\t\t\t\t\t\t\"sharename\", enc_share_name,\n\t\t\t\t\t\t\"name\", share->name,\n\t\t\t\t\t\t\"readonly\", bool_str(user->read_only),\n\t\t\t\t\t\t\"give\", bool_str(!user->hide_passwords),\n\t\t\t\t\t\t\"canadminister\", bool_str(user->admin),\n\t\t\t\t\t\t\"xmlr\", \"1\", NULL);\n\t\t} else {\n\t\t\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t\t\t\"token\", session->token,\n\t\t\t\t\t\t\"id\", share->id,\n\t\t\t\t\t\t\"update\", \"1\",\n\t\t\t\t\t\t\"add\", \"1\",\n\t\t\t\t\t\t\"notify\", \"1\",\n\t\t\t\t\t\t\"msfusername0\", share_user->username,\n\t\t\t\t\t\t\"msfcgid0\", share_user->cgid ? share_user->cgid : \"\",\n\t\t\t\t\t\t\"msfreadonly0\", bool_str(user->read_only),\n\t\t\t\t\t\t\"msfcanadminister0\", bool_str(user->admin),\n\t\t\t\t\t\t\"msfgive0\", bool_str(!user->hide_passwords),\n\t\t\t\t\t\t\"sharename\", enc_share_name,\n\t\t\t\t\t\t\"name\", share->name,\n\t\t\t\t\t\t\"readonly\", bool_str(user->read_only),\n\t\t\t\t\t\t\"give\", bool_str(!user->hide_passwords),\n\t\t\t\t\t\t\"canadminister\", bool_str(user->admin),\n\t\t\t\t\t\t\"xmlr\", \"1\", NULL);\n\t\t}\n\n\t\tfree(share_user);\n\t}\n\n\tif (!reply)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nint lastpass_share_user_mod(const struct session *session,\n\t\t\t    struct share *share,\n\t\t\t    struct share_user *user)\n{\n\t_cleanup_free_ char *reply = NULL;\n\tsize_t len;\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", share->id,\n\t\t\t\t   \"up\", \"1\",\n\t\t\t\t   \"edituser\", \"1\",\n\t\t\t\t   \"uid\", user->uid,\n\t\t\t\t   \"readonly\", user->read_only ? \"on\" : \"\",\n\t\t\t\t   \"give\", !user->hide_passwords ? \"on\" : \"\",\n\t\t\t\t   \"canadminister\", user->admin ? \"on\" : \"\",\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\tif (!reply)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nint lastpass_share_user_del(const struct session *session, const char *shareid,\n\t\t\t    struct share_user *user)\n{\n\tchar *reply = NULL;\n\tsize_t len;\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", shareid,\n\t\t\t\t   \"update\", \"1\",\n\t\t\t\t   \"delete\", \"1\",\n\t\t\t\t   \"uid\", user->uid,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\tfree(reply);\n\treturn 0;\n}\n\nint lastpass_share_create(const struct session *session, const char *sharename)\n{\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *sf_username;\n\t_cleanup_free_ char *enc_share_name = NULL;\n\t_cleanup_free_ char *hex_share_key = NULL;\n\t_cleanup_free_ unsigned char *enc_share_key = NULL;\n\t_cleanup_free_ char *sf_fullname = NULL;\n\t_cleanup_free_ char *hex_enc_share_key = NULL;\n\t_cleanup_free_ char *hex_hash = NULL;\n\n\tunsigned char key[SHA256_DIGEST_LENGTH];\n\tstruct share_user user;\n\tsize_t len;\n\tunsigned int i;\n\tint ret;\n\n\t/* strip off \"Shared-\" part if included, we add it later */\n\tif (!strncmp(sharename, \"Shared-\", 7))\n\t\tsharename += 7;\n\n\tret = lastpass_share_get_user_by_uid(session, session->uid, &user);\n\tif (ret)\n\t\tdie(\"Unable to get pubkey for your user (%d)\\n\", ret);\n\n\txasprintf(&sf_fullname, \"Shared-%s\", sharename);\n\txasprintf(&sf_username, \"%s-%s\", user.username, sf_fullname);\n\tfor (i=0; i < strlen(sf_username); i++)\n\t\tif (sf_username[i] == ' ')\n\t\t\tsf_username[i] = '_';\n\n\tget_random_bytes(key, sizeof(key));\n\tbytes_to_hex(key, &hex_share_key, sizeof(key));\n\n\thex_hash = cipher_multi_sha256_hex(2, xstrlower(sf_username), hex_share_key);\n\thex_hash = cipher_multi_sha256_hex(2, hex_hash, hex_share_key);\n\n\t/*\n\t * Sharing key is hex-encoded then RSA-encrypted with our pubkey.\n\t * Shared folder name is AES-encrypted with the sharing key.\n\t */\n\tsize_t enc_share_key_len = user.sharing_key.len;\n\tenc_share_key = xmalloc(enc_share_key_len);\n\tret = cipher_rsa_encrypt(hex_share_key, &user.sharing_key,\n\t\t\t\t enc_share_key, &enc_share_key_len);\n\tif (ret)\n\t\tdie(\"Unable to RSA encrypt the sharing key (%d)\", ret);\n\n\tbytes_to_hex(enc_share_key, &hex_enc_share_key, enc_share_key_len);\n\n\tenc_share_name = encrypt_and_base64(sf_fullname, key);\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", \"0\",\n\t\t\t\t   \"update\", \"1\",\n\t\t\t\t   \"newusername\", sf_username,\n\t\t\t\t   \"newhash\", hex_hash,\n\t\t\t\t   \"sharekey\", hex_enc_share_key,\n\t\t\t\t   \"name\", sf_fullname,\n\t\t\t\t   \"sharename\", enc_share_name,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\tif (!reply)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nint lastpass_share_delete(const struct session *session, struct share *share)\n{\n\tchar *reply = NULL;\n\tsize_t len;\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", share->id,\n\t\t\t\t   \"delete\", \"1\",\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\tfree(reply);\n\treturn 0;\n}\n\n/*\n * Move a site into or out of a shared folder.\n *\n * account should already be encrypted with the new share key.\n * orig_folder or account->share may be null, indicating the\n * transition to or from a regular site and a shared folder.\n */\nint lastpass_share_move(const struct session *session,\n\t\t\tstruct account *account,\n\t\t\tstruct share *orig_folder)\n{\n\t_cleanup_free_ char *url = NULL;\n\t_cleanup_free_ char *reply = NULL;\n\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\tif (!account->share && !orig_folder)\n\t\treturn 0;\n\n\tbytes_to_hex((unsigned char *) account->url, &url, strlen(account->url));\n\n\tif (session->feature_flag.url_encryption_enabled) {\n\t\thttp_post_add_params(&params,\n\t\t\t\"token\", session->token,\n\t\t\t\"cmd\", \"uploadaccounts\",\n\t\t\t\"aid0\", account->id,\n\t\t\t\"name0\", account->name_encrypted,\n\t\t\t\"grouping0\", account->group_encrypted,\n\t\t\t\"url0\", account->url_encrypted,\n\t\t\t\"username0\", account->username_encrypted,\n\t\t\t\"password0\", account->password_encrypted,\n\t\t\t\"pwprotect0\", account->pwprotect ? \"on\" : \"off\",\n\t\t\t\"extra0\", account->note_encrypted,\n\t\t\t\"todelete\", account->id, NULL);\n\t} else {\n\t\thttp_post_add_params(&params,\n\t\t\t\"token\", session->token,\n\t\t\t\"cmd\", \"uploadaccounts\",\n\t\t\t\"aid0\", account->id,\n\t\t\t\"name0\", account->name_encrypted,\n\t\t\t\"grouping0\", account->group_encrypted,\n\t\t\t\"url0\", url,\n\t\t\t\"username0\", account->username_encrypted,\n\t\t\t\"password0\", account->password_encrypted,\n\t\t\t\"pwprotect0\", account->pwprotect ? \"on\" : \"off\",\n\t\t\t\"extra0\", account->note_encrypted,\n\t\t\t\"todelete\", account->id, NULL);\n\t}\n\n\tif (account->share) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"sharedfolderid\", account->share->id,\n\t\t\t\t     NULL);\n\t}\n\n\tif (orig_folder) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"origsharedfolderid\", orig_folder->id,\n\t\t\t\t     NULL);\n\t}\n\n\tif (session->feature_flag.url_logging_enabled) {\n\t\thttp_post_add_params(&params, \"recordUrl\", url, NULL);\n\t}\n\n\treply = http_post_lastpass_param_set(\"lastpass/api.php\",\n\t\t\t\t\t     session, NULL,\n\t\t\t\t\t     &params);\n\n\tfree(params.argv);\n\n\tif (!reply)\n\t\treturn -EINVAL;\n\n\treturn xml_api_err(reply);\n}\n\nint lastpass_share_get_limits(const struct session *session,\n\t\t\t      struct share *share,\n\t\t\t      struct share_user *user,\n\t\t\t      struct share_limit *ret_limit)\n{\n\t_cleanup_free_ char *reply = NULL;\n\tsize_t len;\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", share->id,\n\t\t\t\t   \"limit\", \"1\",\n\t\t\t\t   \"uid\", user->uid,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\txml_parse_share_get_limits(reply, ret_limit);\n\treturn 0;\n}\n\nint lastpass_share_set_limits(const struct session *session,\n\t\t\t      struct share *share,\n\t\t\t      struct share_user *user,\n\t\t\t      struct share_limit *limit)\n{\n\tchar *reply = NULL;\n\t_cleanup_free_ char *aid_buf = NULL;\n\tchar numaids_str[30] = {0};\n\tstruct share_limit_aid *aid;\n\tint numaids = 0;\n\tsize_t alloc_len = 0;\n\tsize_t len;\n\n\tlist_for_each_entry(aid, &limit->aid_list, list) {\n\t\talloc_len += strlen(aid->aid) + 1 /* comma or null */;\n\t\tnumaids++;\n\t}\n\n\taid_buf = xcalloc(alloc_len, 1);\n\n\tlist_for_each_entry(aid, &limit->aid_list, list) {\n\t\tstrlcat(aid_buf, aid->aid, alloc_len);\n\t\tstrlcat(aid_buf, \",\", alloc_len);\n\t}\n\taid_buf[alloc_len-1] = '\\0';\n\n\tsnprintf(numaids_str, sizeof(numaids_str), \"%d\", numaids);\n\n\treply = http_post_lastpass(\"share.php\", session, &len,\n\t\t\t\t   \"token\", session->token,\n\t\t\t\t   \"id\", share->id,\n\t\t\t\t   \"limit\", \"1\",\n\t\t\t\t   \"edit\", \"1\",\n\t\t\t\t   \"uid\", user->uid,\n\t\t\t\t   \"numaids\", numaids_str,\n\t\t\t\t   \"hidebydefault\", bool_str(limit->whitelist),\n\t\t\t\t   \"aids\", aid_buf,\n\t\t\t\t   \"xmlr\", \"1\", NULL);\n\n\tfree(reply);\n\treturn 0;\n}\n"
        },
        {
          "name": "endpoints.c",
          "type": "blob",
          "size": 15.5302734375,
          "content": "/*\n * https endpoints for LastPass services\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"endpoints.h\"\n#include \"http.h\"\n#include \"version.h\"\n#include \"xml.h\"\n#include \"config.h\"\n#include \"util.h\"\n#include \"upload-queue.h\"\n#include <string.h>\n#include <errno.h>\n#include <curl/curl.h>\n\nunsigned int lastpass_iterations(const char *username)\n{\n\t_cleanup_free_ char *reply = NULL;\n\t_cleanup_free_ char *user_lower = NULL;\n\n\tuser_lower = xstrlower(username);\n\treply = http_post_lastpass(\"iterations.php\", NULL, NULL, \"email\", user_lower, NULL);\n\n\tif (!reply)\n\t\treturn 0;\n\n\treturn strtoul(reply, NULL, 10);\n}\n\nvoid lastpass_logout(const struct session *session)\n{\n\tfree(http_post_lastpass(\"logout.php\", session, NULL, \"method\", \"cli\", \"noredirect\", \"1\", \"token\", session->token, NULL));\n}\n\nstruct blob *lastpass_get_blob(const struct session *session, const unsigned char key[KDF_HASH_LEN])\n{\n\tsize_t len;\n\n\t_cleanup_free_ char *blob = http_post_lastpass(\"getaccts.php\", session, &len, \"mobile\", \"1\", \"requestsrc\", \"cli\", \"hasplugin\", LASTPASS_CLI_VERSION, NULL);\n\tif (!blob || !len)\n\t\treturn NULL;\n\tconfig_write_encrypted_buffer(\"blob\", blob, len, key);\n\treturn blob_parse((unsigned char *) blob, len, key, &session->private_key);\n}\n\nvoid lastpass_remove_account(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const struct account *account, struct blob *blob)\n{\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\thttp_post_add_params(&params, \"extjs\", \"1\", \"token\", session->token, \"delete\", \"1\", \"aid\", account->id, NULL);\n\n\tif (account->share)\n\t\thttp_post_add_params(&params, \"sharedfolderid\", account->share->id, NULL);\n\n\t_cleanup_free_ char *url = NULL;\n\tif (session->feature_flag.url_logging_enabled) {\n\t\tbytes_to_hex((unsigned char *) account->url, &url, strlen(account->url));\n\t\thttp_post_add_params(&params, \"recordUrl\", url, NULL);\n\t}\n\n\t++blob->version;\n\tupload_queue_enqueue(sync, key, session, \"show_website.php\", &params);\n}\n\nstatic char *stringify_field(const struct field *field)\n{\n\tchar *str, *name, *type, *value, *intermediate;\n\tCURL *curl;\n\n\tcurl = curl_easy_init();\n\tif (!curl)\n\t\treturn xstrdup(\"\");\n\n\tname = curl_easy_escape(curl, field->name, 0);\n\ttype = curl_easy_escape(curl, field->type, 0);\n\tif (field->value_encrypted)\n\t\tvalue = curl_easy_escape(curl, field->value_encrypted, 0);\n\telse if (!strcmp(field->type, \"checkbox\") || !strcmp(field->type, \"radio\")) {\n\t\txasprintf(&intermediate, \"%s-%c\", field->value, field->checked ? '1' : '0');\n\t\tvalue = curl_easy_escape(curl, intermediate, 0);\n\t\tfree(intermediate);\n\t} else\n\t\tvalue = curl_easy_escape(curl, field->value, 0);\n\n\txasprintf(&str, \"0\\t%s\\t%s\\t%s\\n\", name, value, type);\n\n\tcurl_free(name);\n\tcurl_free(type);\n\tcurl_free(value);\n\tcurl_easy_cleanup(curl);\n\n\treturn str;\n}\n\nstatic char *stringify_fields(const struct list_head *field_head)\n{\n\tchar *field_str, *fields = NULL;\n\tstruct field *field;\n\n\tlist_for_each_entry(field, field_head, list) {\n\t\tfield_str = stringify_field(field);\n\t\txstrappend(&fields, field_str);\n\t\tfree(field_str);\n\t}\n\tif (fields)\n\t\txstrappend(&fields, \"0\\taction\\t\\taction\\n0\\tmethod\\t\\tmethod\\n\");\n\telse\n\t\tfields = xstrdup(\"\");\n\n\tfield_str = NULL;\n\tbytes_to_hex((unsigned char *) fields, &field_str, strlen(fields));\n\tfree(fields);\n\n\treturn field_str;\n}\n\nstatic void add_app_fields(const struct account *account,\n\t\t\t   struct http_param_set *params)\n{\n\tint index = 0;\n\tstruct field *field;\n\n\tlist_for_each_entry(field, &account->field_head, list) {\n\t\tchar *id_name, *type_name, *value_name;\n\n\t\txasprintf(&id_name, \"fieldid%d\", index);\n\t\txasprintf(&type_name, \"fieldtype%d\", index);\n\t\txasprintf(&value_name, \"fieldvalue%d\", index);\n\n\t\thttp_post_add_params(params,\n\t\t\t\t     id_name, field->name,\n\t\t\t\t     type_name, field->type,\n\t\t\t\t     value_name, field->value_encrypted,\n\t\t\t\t     NULL);\n\t\tindex++;\n\t}\n}\n\nvoid lastpass_update_account(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const struct account *account, struct blob *blob)\n{\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\t_cleanup_free_ char *url = NULL;\n\t_cleanup_free_ char *fields = NULL;\n\n\tbytes_to_hex((unsigned char *) account->url, &url, strlen(account->url));\n\tfields = stringify_fields(&account->field_head);\n\n\t++blob->version;\n\n\thttp_post_add_params(&params,\n\t\t\t     \"extjs\", \"1\",\n\t\t\t     \"token\", session->token,\n\t\t\t     \"method\", \"cli\",\n\t\t\t     \"name\", account->name_encrypted,\n\t\t\t     \"grouping\", account->group_encrypted,\n\t\t\t     \"pwprotect\", account->pwprotect ? \"on\" : \"off\",\n\t\t\t     NULL);\n\n\tif (account->share) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"sharedfolderid\", account->share->id,\n\t\t\t\t     NULL);\n\t}\n\tif (account->is_app) {\n\t\tstruct app *app = account_to_app(account);\n\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"ajax\", \"1\",\n\t\t\t\t     \"cmd\", \"updatelpaa\",\n\t\t\t\t     \"appname\", app->appname,\n\t\t\t\t     NULL);\n\t\tadd_app_fields(account, &params);\n\t\tif (strcmp(account->id, \"0\"))\n\t\t\thttp_post_add_params(&params, \"appaid\", account->id, NULL);\n\n\t\tupload_queue_enqueue(sync, key, session, \"addapp.php\", &params);\n\t\tgoto out_free_params;\n\t}\n\n\tif (session->feature_flag.url_encryption_enabled) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t\"aid\", account->id,\n\t\t\t\t\"url\", account->url_encrypted,\n\t\t\t\t\"username\", account->username_encrypted,\n\t\t\t\t\"password\", account->password_encrypted,\n\t\t\t\t\"extra\", account->note_encrypted,\n\t\t\t\tNULL);\n\t} else {\n\t\thttp_post_add_params(&params,\n\t\t\t\t\"aid\", account->id,\n\t\t\t\t\"url\", url,\n\t\t\t\t\"username\", account->username_encrypted,\n\t\t\t\t\"password\", account->password_encrypted,\n\t\t\t\t\"extra\", account->note_encrypted,\n\t\t\t\tNULL);\n\t}\n\n\tif (strlen(fields)) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"save_all\", \"1\",\n\t\t\t\t     \"data\", fields,\n\t\t\t\t     NULL);\n\t}\n\n\tif (session->feature_flag.url_logging_enabled) {\n\t\thttp_post_add_params(&params, \"recordUrl\", url, NULL);\n\t}\n\n\tupload_queue_enqueue(sync, key, session, \"show_website.php\", &params);\n\nout_free_params:\n\tfree(params.argv);\n}\n\nunsigned long long lastpass_get_blob_version(struct session *session, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *reply = NULL;\n\tunsigned long long version;\n\n\treply = http_post_lastpass(\"login_check.php\", session, NULL, \"method\", \"cli\", NULL);\n\tif (!reply)\n\t\treturn 0;\n\tversion = xml_login_check(reply, session);\n\tif (version)\n\t\tsession_save(session, key);\n\treturn version;\n}\n\nvoid lastpass_log_access(enum blobsync sync, const struct session *session, unsigned const char key[KDF_HASH_LEN], const struct account *account)\n{\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\tif (!strcmp(account->id, \"0\"))\n\t\treturn;\n\n\thttp_post_add_params(&params, \"id\", account->id, \"method\", \"cli\", NULL);\n\n\tif (account->share)\n\t\thttp_post_add_params(&params, \"sharedfolderid\", account->share->id, NULL);\n\n\t_cleanup_free_ char *url = NULL;\n\tif (session->feature_flag.url_logging_enabled) {\n\t\tbytes_to_hex((unsigned char *) account->url, &url, strlen(account->url));\n\t\thttp_post_add_params(&params, \"recordUrl\", url, NULL);\n\t}\n\n\tupload_queue_enqueue(sync, key, session, \"loglogin.php\", &params);\n\n\tfree(params.argv);\n}\n\n\nint lastpass_pwchange_start(const struct session *session, const char *username, const char hash[KDF_HEX_LEN], struct pwchange_info *info)\n{\n\t_cleanup_free_ char *reply = NULL;\n\n\treply = http_post_lastpass(\"lastpass/api.php\", session, NULL,\n\t\t\t\t   \"cmd\", \"getacctschangepw\",\n\t\t\t\t   \"username\", username,\n\t\t\t\t   \"hash\", hash,\n\t\t\t\t   \"changepw\", \"1\",\n\t\t\t\t   \"changepw2\", \"1\",\n\t\t\t\t   \"includersaprivatekeyenc\", \"1\",\n\t\t\t\t   \"changeun\", \"\",\n\t\t\t\t   \"resetrsakeys\", \"0\",\n\t\t\t\t   \"includeendmarker\", \"1\", NULL);\n\tif (!reply)\n\t\treturn -ENOENT;\n\n\treturn xml_parse_pwchange(reply, info);\n}\n\nint lastpass_pwchange_complete(const struct session *session,\n\t\t\t       const char *username,\n\t\t\t       const char *enc_username,\n\t\t\t\t   const char old_hash[KDF_HEX_LEN],\n\t\t\t       const char new_hash[KDF_HEX_LEN],\n\t\t\t       int new_iterations,\n\t\t\t       struct pwchange_info *info)\n{\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\tstruct pwchange_field *field;\n\tstruct pwchange_su_key *su_key;\n\t_cleanup_free_ char *iterations_str = xultostr(new_iterations);\n\t_cleanup_free_ char *sukeycnt_str = NULL;\n\t_cleanup_free_ char *reencrypt_string = NULL;\n\t_cleanup_free_ char *reply = NULL;\n\tsize_t len;\n\tint su_key_ind;\n\tchar suuid_str[30] = {0};\n\tchar sukey_str[30] = {0};\n\tunsigned int i;\n\n\t/* build reencrypt string from change pw info */\n\tlen = strlen(info->reencrypt_id) + 1;\n\tlist_for_each_entry(field, &info->fields, list) {\n\t\tlen += strlen(field->old_ctext) + strlen(field->new_ctext) +\n\t\t       1 /* ':' */ + 1 /* '\\n' */;\n\t}\n\treencrypt_string = xcalloc(len + 1, 1);\n\tstrlcat(reencrypt_string, info->reencrypt_id, len);\n\tstrlcat(reencrypt_string, \"\\n\", len);\n\n\tlist_for_each_entry(field, &info->fields, list) {\n\t\tstrlcat(reencrypt_string, field->old_ctext, len);\n\t\tstrlcat(reencrypt_string, \":\", len);\n\t\tstrlcat(reencrypt_string, field->new_ctext, len);\n\t\tstrlcat(reencrypt_string, \"\\n\", len);\n\t}\n\n\thttp_post_add_params(&params,\n\t\t\"cmd\", \"updatepassword\",\n\t\t\"pwupdate\", \"1\",\n\t\t\"email\", username,\n\t\t\"token\", info->token,\n\t\t\"reencrypt\", reencrypt_string,\n\t\t\"newprivatekeyenc\", info->new_privkey_encrypted,\n\t\t\"newuserkeyhexhash\", info->new_key_hash,\n\t\t\"newprivatekeyenchexhash\", info->new_privkey_hash,\n\t\t\"newpasswordhash\", new_hash,\n\t\t\"key_iterations\", iterations_str,\n\t\t\"encrypted_username\", enc_username,\n\t\t\"origusername\", username,\n\t\t\"wxhash\", old_hash,\n\t\tNULL);\n\n\tsu_key_ind = 0;\n\tlist_for_each_entry(su_key, &info->su_keys, list) {\n\t\tsnprintf(suuid_str, sizeof(suuid_str), \"suuid%d\", su_key_ind);\n\t\tsnprintf(sukey_str, sizeof(sukey_str), \"sukey%d\", su_key_ind);\n\t\thttp_post_add_params(&params,\n\t\t\t\t     xstrdup(suuid_str), su_key->uid,\n\t\t\t\t     xstrdup(sukey_str), su_key->new_enc_key,\n\t\t\t\t     NULL);\n\t\tsu_key_ind++;\n\t}\n\tsukeycnt_str = xultostr(su_key_ind);\n\thttp_post_add_params(&params, xstrdup(\"sukeycnt\"), sukeycnt_str, NULL);\n\n\treply = http_post_lastpass_param_set(\"lastpass/api.php\",\n\t\t\t\t\t     session, NULL,\n\t\t\t\t\t     &params);\n\n\tfor (i=0; i < params.n_alloced && params.argv[i]; i++) {\n\t\tif (starts_with(params.argv[i], \"sukey\") ||\n\t\t    starts_with(params.argv[i], \"suuid\")) {\n\t\t\tfree(params.argv[i]);\n\t\t}\n\t}\n\n\tif (!reply)\n\t\treturn -EINVAL;\n\n\tif (!strstr(reply, \"pwchangeok\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Upload a set of accounts, used for import.\n */\nint lastpass_upload(const struct session *session,\n\t\t    struct list_head *accounts)\n{\n\t_cleanup_free_ char *reply = NULL;\n\tstruct account *account;\n\tint index;\n\tunsigned int i;\n\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\tif (list_empty(accounts))\n\t\treturn 0;\n\n\thttp_post_add_params(&params,\n\t\t\t     \"token\", session->token,\n\t\t\t     \"cmd\", \"uploadaccounts\",\n\t\t\t     NULL);\n\n\tindex = 0;\n\tlist_for_each_entry(account, accounts, list) {\n\t\tchar *name_param, *grouping_param;\n\t\tchar *url_param, *username_param, *password_param;\n\t\tchar *fav_param, *extra_param, *record_url_param;\n\t\tchar *url = NULL;\n\t\tbytes_to_hex((unsigned char *) account->url, &url,\n\t\t\t     strlen(account->url));\n\n\t\txasprintf(&name_param, \"name%d\", index);\n\t\txasprintf(&grouping_param, \"grouping%d\", index);\n\t\txasprintf(&url_param, \"url%d\", index);\n\t\txasprintf(&username_param, \"username%d\", index);\n\t\txasprintf(&password_param, \"password%d\", index);\n\t\txasprintf(&fav_param, \"fav%d\", index);\n\t\txasprintf(&extra_param, \"extra%d\", index);\n\t\txasprintf(&record_url_param, \"recordUrl%d\", index);\n\n\t\tif (session->feature_flag.url_encryption_enabled) {\n\t\t\thttp_post_add_params(&params,\n\t\t\t\tname_param, account->name_encrypted,\n\t\t\t\tgrouping_param, account->group_encrypted,\n\t\t\t\turl_param, account->url_encrypted,\n\t\t\t\tusername_param, account->username_encrypted,\n\t\t\t\tpassword_param, account->password_encrypted,\n\t\t\t\tfav_param, account->fav ? \"1\" : \"0\",\n\t\t\t\textra_param, account->note_encrypted,\n\t\t\t\tNULL);\n\t\t} else {\n\t\t\thttp_post_add_params(&params,\n\t\t\t\tname_param, account->name_encrypted,\n\t\t\t\tgrouping_param, account->group_encrypted,\n\t\t\t\turl_param, url,\n\t\t\t\tusername_param, account->username_encrypted,\n\t\t\t\tpassword_param, account->password_encrypted,\n\t\t\t\tfav_param, account->fav ? \"1\" : \"0\",\n\t\t\t\textra_param, account->note_encrypted,\n\t\t\t\tNULL);\n\t\t}\n\n\t\tif (session->feature_flag.url_logging_enabled) {\n\t\t\thttp_post_add_params(&params, record_url_param, url, NULL);\n\t\t}\n\n\t\tindex++;\n\t}\n\n\treply = http_post_lastpass_param_set(\"lastpass/api.php\",\n\t\t\t\t\t     session, NULL,\n\t\t\t\t\t     &params);\n\n\tfor (i=0; i < params.n_alloced && params.argv[i]; i++) {\n\t\tif (starts_with(params.argv[i], \"name\") ||\n\t\t    starts_with(params.argv[i], \"grouping\") ||\n\t\t    starts_with(params.argv[i], \"username\") ||\n\t\t    starts_with(params.argv[i], \"password\") ||\n\t\t    starts_with(params.argv[i], \"fav\") ||\n\t\t    starts_with(params.argv[i], \"extra\") ||\n\t\t    starts_with(params.argv[i], \"recordUrl\")) {\n\t\t\tfree(params.argv[i]);\n\t\t}\n\t\telse if (starts_with(params.argv[i], \"url\")) {\n\t\t\tfree(params.argv[i]);\n\t\t\tif (i < params.n_alloced) {\n\t\t\t\tfree(params.argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(params.argv);\n\n\tif (!reply)\n\t\treturn -EINVAL;\n\n\treturn xml_api_err(reply);\n}\n\n/*\n * Get the attachment for a given attachment id.  The crypttext is returned\n * and should be decrypted with account->attachkey.  The pointer returned\n * in *result should be freed by the caller.\n */\nint lastpass_load_attachment(const struct session *session,\n\t\t\t     const char *shareid,\n\t\t\t     struct attach *attach,\n\t\t\t     char **result)\n{\n\tchar *reply = NULL;\n\tchar *p;\n\n\t*result = NULL;\n\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\thttp_post_add_params(&params,\n\t\t\t     \"token\", session->token,\n\t\t\t     \"getattach\", attach->storagekey,\n\t\t\t     NULL);\n\n\tif (shareid) {\n\t\thttp_post_add_params(&params,\n\t\t\t\t     \"sharedfolderid\", shareid,\n\t\t\t\t     NULL);\n\t}\n\n\treply = http_post_lastpass_param_set(\"getattach.php\",\n\t\t\t\t\t     session, NULL,\n\t\t\t\t\t     &params);\n\n\tfree(params.argv);\n\tif (!reply)\n\t\treturn -ENOENT;\n\n\t/* returned string is json-encoded base64 string; unescape it */\n\tif (reply[0] == '\"')\n\t\tmemmove(reply, reply+1, strlen(reply));\n\tif (reply[strlen(reply)-1] == '\"')\n\t\treply[strlen(reply)-1] = 0;\n\n\tp = reply;\n\twhile (*p) {\n\t\tif (*p == '\\\\') {\n\t\t\tmemmove(p, p + 1, strlen(p));\n\t\t} else {\n\t\t\tp++;\n\t\t}\n\t}\n\n\t*result = reply;\n\treturn 0;\n}\n"
        },
        {
          "name": "endpoints.h",
          "type": "blob",
          "size": 2.5947265625,
          "content": "#ifndef ENDPOINTS_H\n#define ENDPOINTS_H\n\n#include \"session.h\"\n#include \"blob.h\"\n#include \"kdf.h\"\n#include <stddef.h>\n\nunsigned int lastpass_iterations(const char *username);\nstruct session *lastpass_login(const char *username, const char hash[KDF_HEX_LEN], const unsigned char key[KDF_HASH_LEN], int iterations, char **error_message, bool trust);\nvoid lastpass_logout(const struct session *session);\nstruct blob *lastpass_get_blob(const struct session *session, const unsigned char key[KDF_HASH_LEN]);\nunsigned long long lastpass_get_blob_version(struct session *session, unsigned const char key[KDF_HASH_LEN]);\nvoid lastpass_remove_account(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const struct account *account, struct blob *blob);\nvoid lastpass_update_account(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const struct account *account, struct blob *blob);\nvoid lastpass_log_access(enum blobsync sync, const struct session *session, unsigned const char key[KDF_HASH_LEN], const struct account *account);\n\nint lastpass_share_getinfo(const struct session *session, const char *shareid, struct list_head *users);\nint lastpass_share_user_add(const struct session *session, struct share *share, struct share_user *user);\nint lastpass_share_user_del(const struct session *session, const char *shareid, struct share_user *user);\nint lastpass_share_user_mod(const struct session *session, struct share *share, struct share_user *user);\nint lastpass_share_move(const struct session *session, struct account *account, struct share *orig_folder);\nint lastpass_share_create(const struct session *session, const char *sharename);\nint lastpass_share_delete(const struct session *session, struct share *share);\nint lastpass_share_get_limits(const struct session *session, struct share *share, struct share_user *user, struct share_limit *ret_limit);\nint lastpass_share_set_limits(const struct session *session, struct share *share, struct share_user *user, struct share_limit *limit);\nint lastpass_pwchange_start(const struct session *session, const char *username, const char hash[KDF_HEX_LEN], struct pwchange_info *pwchange_info);\nint lastpass_pwchange_complete(const struct session *session, const char *username, const char *enc_username, const char old_hash[KDF_HEX_LEN], const char new_hash[KDF_HEX_LEN], int new_iterations, struct pwchange_info *pwchange_info);\nint lastpass_upload(const struct session *session, struct list_head *accounts);\nint lastpass_load_attachment(const struct session *session, const char *shareid, struct attach *attach, char **result);\n#endif\n"
        },
        {
          "name": "feature-flag.c",
          "type": "blob",
          "size": 3.1640625,
          "content": "/*\n * feature flag handling routines\n *\n * Copyright (C) 2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"xml.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include <string.h>\n\n#define SESSION_FF_URL_ENCRYPTION \"session_ff_url_encryption\"\n#define SESSION_FF_URL_LOGGING \"session_ff_url_logging\"\n\nvoid feature_flag_load_xml_attr(struct feature_flag *feature_flag, xmlDoc *doc, xmlAttrPtr attr) {\n    if (!xmlStrcmp(attr->name, BAD_CAST \"url_encryption\")) {\n        feature_flag->url_encryption_enabled = !strcmp((char *)xmlNodeListGetString(doc, attr->children, 1), \"1\");\n    }\n\n    if (!xmlStrcmp(attr->name, BAD_CAST \"url_logging\")) {\n        feature_flag->url_logging_enabled = !strcmp((char *)xmlNodeListGetString(doc, attr->children, 1), \"1\");\n    }\n}\n\nvoid feature_flag_save(const struct feature_flag *feature_flag, unsigned const char key[KDF_HASH_LEN]) {\n    config_write_encrypted_string(SESSION_FF_URL_ENCRYPTION, feature_flag->url_encryption_enabled ? \"1\" : \"0\", key);\n    config_write_encrypted_string(SESSION_FF_URL_LOGGING, feature_flag->url_logging_enabled ? \"1\" : \"0\", key);\n}\n\nvoid feature_flag_load(struct feature_flag *feature_flag, unsigned const char key[KDF_HASH_LEN]) {\n    char *ff_url_encryption = config_read_encrypted_string(SESSION_FF_URL_ENCRYPTION, key);\n    if (ff_url_encryption != NULL) {\n        feature_flag->url_encryption_enabled = !strcmp(ff_url_encryption, \"1\");\n    }\n\n    char *ff_url_logging = config_read_encrypted_string(SESSION_FF_URL_LOGGING, key);\n    if (ff_url_logging != NULL) {\n        feature_flag->url_logging_enabled = !strcmp(ff_url_logging, \"1\");\n    }\n}\n\nvoid feature_flag_cleanup() {\n    config_unlink(SESSION_FF_URL_ENCRYPTION);\n    config_unlink(SESSION_FF_URL_LOGGING);\n}\n"
        },
        {
          "name": "feature-flag.h",
          "type": "blob",
          "size": 0.5,
          "content": "#ifndef FEATUREFLAG_H\n#define FEATUREFLAG_H\n\n#include <libxml/tree.h>\n#include <stdbool.h>\n\nstruct feature_flag {\n\tbool url_encryption_enabled;\n\tbool url_logging_enabled;\n};\n\nvoid feature_flag_load_xml_attr(struct feature_flag *feature_flag, xmlDoc *doc, xmlAttrPtr attr);\nvoid feature_flag_save(const struct feature_flag *feature_flag, unsigned const char key[KDF_HASH_LEN]);\nvoid feature_flag_load(struct feature_flag *feature_flag, unsigned const char key[KDF_HASH_LEN]);\nvoid feature_flag_cleanup();\n\n#endif\n"
        },
        {
          "name": "format.c",
          "type": "blob",
          "size": 5.29296875,
          "content": "/*\n * printf-like formatting routines\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"cmd.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"kdf.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n\nchar *get_display_fullname(struct account *account)\n{\n\tchar *fullname = NULL;\n\n\tif (account->share || strcmp(account->group, \"\"))\n\t\tfullname = xstrdup(account->fullname);\n\telse\n\t\txasprintf(&fullname, \"(none)/%s\", account->fullname);\n\n\treturn fullname;\n}\n\nchar *format_timestamp(char *timestamp, bool utc)\n{\n\tchar temp[60];\n\tstruct tm *ts_tm;\n\n\tif (!timestamp)\n\t\treturn xstrdup(\"\");\n\n\ttime_t ts_time_t = (time_t) strtoul(timestamp, NULL, 10);\n\n\tif (ts_time_t == 0)\n\t\treturn xstrdup(\"\");\n\n\tif (utc)\n\t\tts_tm = gmtime(&ts_time_t);\n\telse\n\t\tts_tm = localtime(&ts_time_t);\n\n\tstrftime(temp, sizeof(temp), \"%Y-%m-%d %H:%M\", ts_tm);\n\n\treturn xstrdup(temp);\n}\n\nstatic\nvoid append_str(struct buffer *buf, char *str, bool add_slash)\n{\n\tif (!str || !strlen(str))\n\t\treturn;\n\n\tbuffer_append_str(buf, str);\n\tif (add_slash)\n\t\tbuffer_append_char(buf, '/');\n}\n\nstatic\nvoid format_account_item(struct buffer *buf, char fmt,\n\t\t\t struct account *account, bool add_slash)\n{\n\t_cleanup_free_ char *name = NULL;\n\t_cleanup_free_ char *ts = NULL;\n\n\tswitch (fmt) {\n\tcase 'i':\n\t\t/* id */\n\t\tappend_str(buf, account->id, add_slash);\n\t\tbreak;\n\tcase 'n':\n\t\t/* shortname */\n\t\tappend_str(buf, account->name, add_slash);\n\t\tbreak;\n\tcase 'N':\n\t\t/* fullname */\n\t\tname = get_display_fullname(account);\n\t\tappend_str(buf, name, add_slash);\n\t\tbreak;\n\tcase 'u':\n\t\t/* username */\n\t\tappend_str(buf, account->username, add_slash);\n\t\tbreak;\n\tcase 'p':\n\t\t/* password */\n\t\tappend_str(buf, account->password, add_slash);\n\t\tbreak;\n\tcase 'm':\n\t\t/* mtime */\n\t\tts = format_timestamp(account->last_modified_gmt, true);\n\t\tappend_str(buf, ts, add_slash);\n\t\tbreak;\n\tcase 'U':\n\t\t/* last touch time */\n\t\tts = format_timestamp(account->last_touch, false);\n\t\tappend_str(buf, ts, add_slash);\n\t\tbreak;\n\tcase 's':\n\t\t/* sharename */\n\t\tif (account->share)\n\t\t\tappend_str(buf, account->share->name, add_slash);\n\t\tbreak;\n\tcase 'g':\n\t\t/* group name */\n\t\tappend_str(buf, account->group, add_slash);\n\t\tbreak;\n\tcase 'l':\n\t\t/* URL */\n\t\tappend_str(buf, account->url, add_slash);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid format_field_item(struct buffer *buf, char fmt,\n\t\t       char *field_name, char *field_value,\n\t\t       bool add_slash)\n{\n\tif (fmt == 'n' && field_name) {\n\t\tappend_str(buf, field_name, add_slash);\n\t} else if (fmt == 'v' && field_value) {\n\t\tappend_str(buf, field_value, add_slash);\n\t}\n}\n\nvoid format_field(struct buffer *buf, const char *format_str,\n\t\t  struct account *account,\n\t\t  char *field_name, char *field_value)\n{\n\tconst char *p = format_str;\n\tbool in_format = false;\n\tbool add_slash = false;\n\n\twhile (*p) {\n\t\tchar ch = *p++;\n\n\t\tif (!in_format) {\n\t\t\tif (ch == '%')\n\t\t\t\tin_format = true;\n\t\t\telse\n\t\t\t\tbuffer_append_char(buf, ch);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* expand format specifiers */\n\t\tswitch (ch)\n\t\t{\n\t\tcase '%':\n\t\t\t/* %% escape */\n\t\t\tbuffer_append_char(buf, ch);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t/* append trailing slash, if nonempty */\n\t\t\tadd_slash = true;\n\t\t\tcontinue;\n\t\tcase 'f':\n\t\t\t/* field name/value */\n\t\t\tif (!*p) {\n\t\t\t\tbuffer_append_char(buf, '%');\n\t\t\t\tbuffer_append_char(buf, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *p++;\n\t\t\tformat_field_item(buf, ch, field_name, field_value, add_slash);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t/* account item */\n\t\t\tif (!*p) {\n\t\t\t\tbuffer_append_char(buf, '%');\n\t\t\t\tbuffer_append_char(buf, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *p++;\n\t\t\tformat_account_item(buf, ch, account, add_slash);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuffer_append_char(buf, '%');\n\t\t\tbuffer_append_char(buf, ch);\n\t\t}\n\t\tadd_slash = false;\n\t\tin_format = false;\n\t}\n}\n\nvoid format_account(struct buffer *buf, const char *fmt_str,\n\t\t    struct account *account)\n{\n\tformat_field(buf, fmt_str, account, NULL, NULL);\n}\n"
        },
        {
          "name": "format.h",
          "type": "blob",
          "size": 0.3544921875,
          "content": "#ifndef FORMAT_H\n#define FORMAT_H\n\nchar *get_display_fullname(struct account *account);\nchar *format_timestamp(char *timestamp, bool utc);\nvoid format_account(struct buffer *buf, char *format_str,\n\t\t    struct account *account);\nvoid format_field(struct buffer *buf, char *format_str,\n\t\t  struct account *account,\n\t\t  char *field_name, char *field_value);\n#endif\n"
        },
        {
          "name": "http.c",
          "type": "blob",
          "size": 9.380859375,
          "content": "/*\n * http posting routines\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"http.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include \"pins.h\"\n#include \"cipher.h\"\n#include <stdarg.h>\n#include <stdint.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <openssl/ssl.h>\n#include <curl/curl.h>\n\nstruct mem_chunk {\n\tchar *ptr;\n\tsize_t len;\n};\n\n#ifndef TEST_BUILD\nstatic bool interrupted = false;\nstatic sig_t previous_handler = SIG_DFL;\nstatic void interruption_detected(int signal)\n{\n\tUNUSED(signal);\n\tinterrupted = true;\n}\nstatic void set_interrupt_detect(void)\n{\n\tinterrupted = false;\n\tprevious_handler = signal(SIGINT, interruption_detected);\n}\nstatic void unset_interrupt_detect(void)\n{\n\tinterrupted = false;\n\tsignal(SIGINT, previous_handler);\n}\nstatic int check_interruption(void *p, double dltotal, double dlnow, double ultotal, double ulnow)\n{\n\tUNUSED(p);\n\tUNUSED(dltotal);\n\tUNUSED(dlnow);\n\tUNUSED(ultotal);\n\tUNUSED(ulnow);\n\treturn interrupted;\n}\n\nstatic size_t write_data(char *ptr, size_t size, size_t nmemb, void *data)\n{\n\tsize_t len, new_len;\n\tstruct mem_chunk *mem = (struct mem_chunk *)data;\n\tif ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) && nmemb > 0 && SIZE_MAX / nmemb < size) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tlen = size * nmemb;\n\tnew_len = len + mem->len + 1;\n\tif (new_len <= mem->len || new_len <= len || new_len < 1) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\n\tmem->ptr = xrealloc(mem->ptr, new_len);\n\tmemcpy(mem->ptr + mem->len, ptr, len);\n\tmem->len += len;\n\tmem->ptr[mem->len] = '\\0';\n\n\treturn len;\n}\n\nstatic char *hash_subject_pubkey_info(X509 *cert)\n{\n\t_cleanup_free_ unsigned char *spki = NULL;\n\tchar *hash = NULL;\n\tEVP_PKEY *pkey;\n\tint len;\n\n\tpkey = X509_get_pubkey(cert);\n\tif (!pkey)\n\t\treturn NULL;\n\n\tlen = i2d_PUBKEY(pkey, &spki);\n\tif (len <= 0)\n\t\tgoto free_pkey;\n\n\thash = cipher_sha256_b64(spki, len);\nfree_pkey:\n\tEVP_PKEY_free(pkey);\n\treturn hash;\n}\n\nstatic int verify_callback(int preverify_ok, X509_STORE_CTX *ctx)\n{\n\tint i, j;\n\n\t/*\n\t * Preverify checks the platform's certificate store; don't\n\t * allow any chain that doesn't already validate according to\n\t * that.\n\t */\n\tif (!preverify_ok)\n\t\treturn 0;\n\n\t/* check each certificate in the chain against our built-in pinlist. */\n\tSTACK_OF(X509) *chain = X509_STORE_CTX_get_chain(ctx);\n\tif (!chain)\n\t\tdie(\"No certificate chain available\");\n\n\tbool found = false;\n\tfor (i=0; i < sk_X509_num(chain); i++) {\n\t\t_cleanup_free_ char *spki_hash = NULL;\n\t\tspki_hash = hash_subject_pubkey_info(sk_X509_value(chain, i));\n\t\tif (!spki_hash)\n\t\t\tcontinue;\n\n\t\tfor (j=0; j < (int) ARRAY_SIZE(PK_PINS); j++) {\n\t\t\tif (strcmp(PK_PINS[j], spki_hash) == 0) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic CURLcode pin_keys(CURL *curl, void *sslctx, void *parm)\n{\n\tUNUSED(curl);\n\tUNUSED(parm);\n\tSSL_CTX_set_verify((SSL_CTX *)sslctx, SSL_VERIFY_PEER,\n\t\t\t   verify_callback);\n\treturn CURLE_OK;\n}\n#endif\n\nstatic\nvoid vhttp_post_add_params(struct http_param_set *param_set, va_list args)\n{\n\tchar **argv_ptr;\n\tchar *arg;\n\tsize_t count = 0;\n\n\tif (!param_set->argv) {\n\t\tparam_set->n_alloced = 2;\n\t\tparam_set->argv = xcalloc(param_set->n_alloced, sizeof(char *));\n\t}\n\targv_ptr = param_set->argv;\n\twhile (*argv_ptr) {\n\t\targv_ptr++;\n\t\tcount++;\n\t}\n\n\twhile ((arg = va_arg(args, char *))) {\n\t\tif (count == param_set->n_alloced - 1) {\n\t\t\tparam_set->n_alloced += 2;\n\t\t\tparam_set->argv = xreallocarray(param_set->argv,\n\t\t\t\tparam_set->n_alloced, sizeof(char *));\n\t\t\targv_ptr = &param_set->argv[count];\n\t\t}\n\t\t*argv_ptr++ = arg;\n\t\tcount++;\n\t}\n\t*argv_ptr = 0;\n}\n\nint http_init()\n{\n\tcurl_global_cleanup();\n\treturn curl_global_init(CURL_GLOBAL_DEFAULT);\n}\n\nvoid http_post_add_params(struct http_param_set *param_set, ...)\n{\n\tva_list args;\n\tva_start(args, param_set);\n\tvhttp_post_add_params(param_set, args);\n\tva_end(args);\n}\n\nchar *http_post_lastpass(const char *page, const struct session *session, size_t *final_len, ...)\n{\n\tva_list args;\n\tstruct http_param_set params = {\n\t\t.argv = NULL,\n\t\t.n_alloced = 0\n\t};\n\n\tva_start(args, final_len);\n\tvhttp_post_add_params(&params, args);\n\tchar *result = http_post_lastpass_param_set(page, session, final_len, &params);\n\tfree(params.argv);\n\treturn result;\n}\n\n#ifndef TEST_BUILD\nchar *http_post_lastpass_v_noexit(const char *server, const char *page, const struct session *session, size_t *final_len, char **argv, int *curl_ret, long *http_code)\n{\n\t_cleanup_free_ char *url = NULL;\n\t_cleanup_free_ char *postdata = NULL;\n\t_cleanup_free_ char *cookie = NULL;\n\t_cleanup_fclose_ FILE *logstream = NULL;\n\tchar *param, *encoded_param;\n\tCURL *curl = NULL;\n\tchar separator;\n\tsize_t len, new_len;\n\tint ret;\n\tstruct mem_chunk result;\n\tconst char *login_server;\n\n\t/* if we have a session, use that server, otherwise use whatever was passed */\n\tlogin_server = session ? session->server : server;\n\n\t/* if nothing passed, use lastpass */\n\tif (!login_server)\n\t\tlogin_server = LASTPASS_SERVER;\n\n\txasprintf(&url, \"https://%s/%s\", login_server, page);\n\n\tlpass_log(LOG_DEBUG, \"Making request to %s\\n\", url);\n\n\tcurl = curl_easy_init();\n\tif (!curl)\n\t\tdie(\"Could not init curl\");\n\n\tlen = 0;\n\tfor (separator = '=', param = *argv;\n\t     param;\n\t     separator = (separator == '=') ? '&' : '=', param = *(++argv)) {\n\t\tencoded_param = curl_easy_escape(curl, param, 0);\n\t\tif (!encoded_param)\n\t\t\tdie(\"Could not escape %s with curl\", param);\n\t\tnew_len = strlen(encoded_param) + 1 /* separator */;\n\t\tpostdata = xrealloc(postdata, len + new_len + 1 /* null */);\n\t\tsnprintf(postdata + len, new_len + 1, \"%s%c\", encoded_param, separator);\n\t\tlen += new_len;\n\t\tcurl_free(encoded_param);\n\t}\n\tif (len && postdata)\n\t\tpostdata[len - 1] = '\\0';\n\n\tmemset(&result, 0, sizeof(result));\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_USERAGENT, LASTPASS_CLI_USERAGENT);\n\n\t/* TODO: Make this optional via either env vars and/or an option for\n\t *       lpass -4 or lpass -6\n\t */\n\tcurl_easy_setopt(curl, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);\n\n\tif (lpass_log_level() >= LOG_VERBOSE) {\n\t\tlogstream = lpass_log_open();\n\t\tif (logstream) {\n\t\t\tcurl_easy_setopt(curl, CURLOPT_STDERR, logstream);\n\t\t\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\t\t}\n\t}\n#if defined(DO_NOT_ENABLE_ME_MITM_PROXY_FOR_DEBUGGING_ONLY)\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n\tcurl_easy_setopt(curl, CURLOPT_PROXY, \"http://localhost:8080\");\n#else\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2);\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1);\n\tcurl_easy_setopt(curl, CURLOPT_SSL_CTX_FUNCTION, pin_keys);\n#endif\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &result);\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\tcurl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, check_interruption);\n\tcurl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);\n\tif (postdata)\n\t\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);\n\tif (session) {\n\t\txasprintf(&cookie, \"PHPSESSID=%s\", session->sessionid);\n\t\tcurl_easy_setopt(curl, CURLOPT_COOKIE, cookie);\n\t}\n\n\tset_interrupt_detect();\n\tret = curl_easy_perform(curl);\n\tunset_interrupt_detect();\n\n\tcurl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, http_code);\n\tcurl_easy_cleanup(curl);\n\t*curl_ret = ret;\n\n\tif (ret != CURLE_OK) {\n\t\tresult.len = 0;\n\t\tfree(result.ptr);\n\t\tresult.ptr = NULL;\n\t} else if (!result.ptr)\n\t\tresult.ptr = xstrdup(\"\");\n\tif (final_len)\n\t\t*final_len = result.len;\n\n\treturn result.ptr;\n}\n#endif\n\nchar *http_post_lastpass_v(const char *server, const char *page, const struct session *session, size_t *final_len, char **argv)\n{\n\tchar *result;\n\tint ret;\n\tlong http_code;\n\n\tresult = http_post_lastpass_v_noexit(server, page, session, final_len,\n\t\t\t\t\t     argv, &ret, &http_code);\n\n\tif (ret != CURLE_OK && ret != CURLE_ABORTED_BY_CALLBACK)\n\t\tdie(\"%s.\", curl_easy_strerror(ret));\n\n\treturn result;\n}\n\n\nchar *http_post_lastpass_param_set(const char *page, const struct session *session, size_t *final_len, struct http_param_set *param_set) {\n\treturn http_post_lastpass_v(NULL, page, session, final_len, param_set->argv);\n}\n"
        },
        {
          "name": "http.h",
          "type": "blob",
          "size": 0.9052734375,
          "content": "#ifndef HTTP_H\n#define HTTP_H\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <curl/curl.h>\n#include \"session.h\"\n\nstruct http_param_set\n{\n\tchar **argv;\n\tsize_t n_alloced;\n};\n\n#define LASTPASS_SERVER\t\"lastpass.com\"\n\n#define HTTP_ERROR_CODE\tCURLE_HTTP_RETURNED_ERROR\n#define HTTP_ERROR_CONNECT\tCURLE_SSL_CONNECT_ERROR\n\nint http_init();\nvoid http_post_add_params(struct http_param_set *params, ...);\nchar *http_post_lastpass(const char *page, const struct session *session, size_t *len, ...);\nchar *http_post_lastpass_v(const char *server, const char *page, const struct session *session, size_t *len, char **argv);\nchar *http_post_lastpass_param_set(const char *page, const struct session *session, size_t *len,\n\t\t\t\t   struct http_param_set *params);\nchar *http_post_lastpass_v_noexit(const char *server, const char *page, const struct session *session, size_t *final_len, char **argv, int *curl_ret, long *http_code);\n\n#endif\n"
        },
        {
          "name": "json-format.c",
          "type": "blob",
          "size": 6.17578125,
          "content": "/*\n * json formatting routines\n *\n * Copyright (C) 2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"blob.h\"\n#include \"util.h\"\n#include \"list.h\"\n#include \"json-format.h\"\n\n#define INDENT_SPACES 2\n\nstatic void json_format(struct json_field *field, int level, bool is_last);\n\nstatic void print_json_quoted_string(const char *str)\n{\n\tconst char *ptr = NULL;\n\n\tputchar ('\"');\n\tfor (ptr = str; *ptr; ptr++) {\n\t\t/* escape some characters according to http://www.ietf.org/rfc/rfc4627.txt */\n\t\tswitch (*ptr) {\n\t\tcase '\\b': putchar('\\\\'); putchar('b'); break;\n\t\tcase '\\f': putchar('\\\\'); putchar('f'); break;\n\t\tcase '\\n': putchar('\\\\'); putchar('n'); break;\n\t\tcase '\\r': putchar('\\\\'); putchar('r'); break;\n\t\tcase '\\t': putchar('\\\\'); putchar('t'); break;\n\t\tcase '\\\\': putchar('\\\\'); putchar('\\\\'); break;\n\t\tcase  '\"': putchar('\\\\'); putchar('\"'); break;\n\t\tdefault:\n\t\t\tif ((*ptr) < ' ') {\n\t\t\t\tprintf(\"\\\\u%04x\", *ptr);\n\t\t\t} else {\n\t\t\t\tputchar(*ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tputchar ('\"');\n}\n\nstatic void indent(int level)\n{\n\tfor (int i = 0; i < level * INDENT_SPACES; i++)\n\t\tputchar(' ');\n}\n\nstatic\nvoid json_format_string(struct json_field *field, int level, bool is_last)\n{\n\tindent(level);\n\tif (field->name) {\n\t\tprint_json_quoted_string(field->name);\n\t\tprintf(\": \");\n\t}\n\tprint_json_quoted_string(field->u.string_value);\n\tprintf(\"%c\\n\", is_last ? ' ' : ',');\n}\n\nstatic\nvoid json_format_array(struct json_field *field, int level, bool is_last)\n{\n\tstruct json_field *child;\n\tstruct json_field *last;\n\n\tif (field->type != JSON_ARRAY)\n\t\treturn;\n\n\tlast = list_last_entry_or_null(&field->children, struct json_field,\n\t\t\t\t       siblings);\n\tindent(level);\n\n\tif (field->name) {\n\t\tprint_json_quoted_string(field->name);\n\t\tprintf(\": \");\n\t}\n\tprintf (\"[\\n\");\n\tlist_for_each_entry(child, &field->children, siblings) {\n\t\tjson_format(child, level + 1, child == last);\n\t}\n\tindent(level);\n\tprintf (\"]%c\\n\", is_last ? ' ' : ',');\n}\n\nstatic\nvoid json_format_object(struct json_field *field, int level, bool is_last)\n{\n\tstruct json_field *child;\n\tstruct json_field *last;\n\n\tif (field->type != JSON_OBJECT)\n\t\treturn;\n\n\tlast = list_last_entry_or_null(&field->children, struct json_field,\n\t\t\t\t       siblings);\n\tindent(level);\n\n\tif (field->name) {\n\t\tprint_json_quoted_string(field->name);\n\t\tprintf(\": \");\n\t}\n\tprintf (\"{\\n\");\n\tlist_for_each_entry(child, &field->children, siblings) {\n\t\tjson_format(child, level + 1, child == last);\n\t}\n\tindent(level);\n\tprintf (\"}%c\\n\", is_last ? ' ' : ',');\n}\n\nstatic\nvoid json_format(struct json_field *field, int level, bool is_last)\n{\n\tswitch (field->type) {\n\tcase JSON_OBJECT:\n\t\tjson_format_object(field, level, is_last);\n\t\tbreak;\n\tcase JSON_STRING:\n\t\tjson_format_string(field, level, is_last);\n\t\tbreak;\n\tcase JSON_ARRAY:\n\t\tjson_format_array(field, level, is_last);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"unhandled type: %d\\n\", field->type);\n\t}\n}\n\nstatic\nvoid json_add_string_field(struct json_field *object,\n\t\t\t   const char *name, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\n\tstruct json_field *field = xmalloc(sizeof(struct json_field));\n\tfield->name = name;\n\tfield->type = JSON_STRING;\n\tfield->u.string_value = value;\n\n\tlist_add_tail(&field->siblings, &object->children);\n}\n\nstatic\nvoid account_to_json_field(struct account *account, struct json_field *obj)\n{\n\tobj->name = NULL;\n\tobj->type = JSON_OBJECT;\n\n\tjson_add_string_field(obj, \"id\", account->id);\n\n\tjson_add_string_field(obj, \"name\", account->name);\n\tjson_add_string_field(obj, \"fullname\", account->fullname);\n\tjson_add_string_field(obj, \"username\", account->username);\n\tjson_add_string_field(obj, \"password\", account->password);\n\tjson_add_string_field(obj, \"last_modified_gmt\", account->last_modified_gmt);\n\tjson_add_string_field(obj, \"last_touch\", account->last_touch);\n\tif (account->share)\n\t\tjson_add_string_field(obj, \"share\", account->share->name);\n\tjson_add_string_field(obj, \"group\", account->group);\n\tjson_add_string_field(obj, \"url\", account->url);\n\tjson_add_string_field(obj, \"note\", account->note);\n}\n\nstatic void json_free_account_fields(struct json_field *obj)\n{\n\tstruct json_field *field, *tmp;\n\n\tlist_for_each_entry_safe(field, tmp, &obj->children, siblings) {\n\t\tfree(field);\n\t}\n}\n\nvoid json_format_account_list(struct list_head *accounts)\n{\n\tstruct account *account;\n\tstruct json_field *child, *tmp;\n\tstruct json_field array = {\n\t\t.type = JSON_ARRAY\n\t};\n\tINIT_LIST_HEAD(&array.children);\n\n\tlist_for_each_entry(account, accounts, match_list) {\n\t\tstruct json_field *object = xmalloc(sizeof(*object));\n\t\tobject->name = NULL;\n\t\tobject->type = JSON_OBJECT;\n\t\tINIT_LIST_HEAD(&object->children);\n\n\t\taccount_to_json_field(account, object);\n\t\tlist_add_tail(&object->siblings, &array.children);\n\t}\n\tjson_format(&array, 0, true);\n\n\tlist_for_each_entry_safe(child, tmp, &array.children, siblings) {\n\t\tjson_free_account_fields(child);\n\t\tfree(child);\n\t}\n}\n"
        },
        {
          "name": "json-format.h",
          "type": "blob",
          "size": 0.7666015625,
          "content": "#ifndef JSON_FORMAT_H\n#define JSON_FORMAT_H\n\nenum json_field_type {\n\tJSON_STRING,\n\tJSON_ARRAY,\n\tJSON_OBJECT\n};\n\n/*\n * Stores a JSON record to be formatted.\n *\n * Type field dictates which union is used for primitive types.\n * For both objects and arrays, children holds the items that are\n * assigned to the container, and those fields are linked via\n * siblings pointer.  The only difference between an array and an\n * object is that the children will not have names in the case of\n * an array.\n */\nstruct json_field\n{\n\tconst char *name;\n\tenum json_field_type type;\n\n\t/* list of properties */\n\tstruct list_head children;\n\tstruct list_head siblings;\n\n\tunion {\n\t\tconst char *string_value;\n\t} u;\n};\n\nvoid json_format_account_list(struct list_head *accounts);\n\n#endif /* JSON_FORMAT_H */\n"
        },
        {
          "name": "kdf.c",
          "type": "blob",
          "size": 3.787109375,
          "content": "/*\n * key derivation routines\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"kdf.h\"\n#include \"util.h\"\n#include <string.h>\n#include <sys/mman.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/opensslv.h>\n\n#if defined(__APPLE__) && defined(__MACH__)\n#include <CommonCrypto/CommonCryptor.h>\n#include <CommonCrypto/CommonKeyDerivation.h>\nstatic void pbkdf2_hash(const char *username, size_t username_len, const char *password, size_t password_len, int iterations, unsigned char hash[KDF_HASH_LEN])\n{\n\tif (CCKeyDerivationPBKDF(kCCPBKDF2, password, password_len, (const uint8_t *)username, username_len, kCCPRFHmacAlgSHA256, iterations, hash, KDF_HASH_LEN) == kCCParamError)\n\t\tdie(\"Failed to compute PBKDF2 for %s\", username);\n}\n#else\n#include \"pbkdf2.h\"\n\nstatic void pbkdf2_hash(const char *username, size_t username_len, const char *password, size_t password_len, int iterations, unsigned char hash[KDF_HASH_LEN])\n{\n\tif (!PKCS5_PBKDF2_HMAC(password, password_len, (const unsigned char *)username, username_len, iterations, EVP_sha256(), KDF_HASH_LEN, hash))\n\t\tdie(\"Failed to compute PBKDF2 for %s\", username);\n}\n#endif\n\nstatic inline void fail_invalid_iteration_count() {\n\tdie(\"Action required: Your current iteration count does not meet the minimum number of %d iterations . Increase the iteration count on another client that supports iteration number setting.\", MINIMUM_ITERATIONS);\n}\n\nvoid kdf_login_key(const char *username, const char *password, int iterations, char hex[KDF_HEX_LEN])\n{\n\tunsigned char hash[KDF_HASH_LEN];\n\tsize_t password_len;\n\t_cleanup_free_ char *user_lower = xstrlower(username);\n\n\tpassword_len = strlen(password);\n\n\tif (iterations < MINIMUM_ITERATIONS)\n\t\tfail_invalid_iteration_count();\n\n\tpbkdf2_hash(user_lower, strlen(user_lower), password, password_len, iterations, hash);\n\tpbkdf2_hash(password, password_len, (char *)hash, KDF_HASH_LEN, 1, hash);\n\n\tbytes_to_hex(hash, &hex, KDF_HASH_LEN);\n\tmlock(hex, KDF_HEX_LEN);\n}\n\nvoid kdf_decryption_key(const char *username, const char *password, int iterations, unsigned char hash[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *user_lower = xstrlower(username);\n\n\tif (iterations < MINIMUM_ITERATIONS)\n\t\tfail_invalid_iteration_count();\n\n\tpbkdf2_hash(user_lower, strlen(user_lower), password, strlen(password), iterations, hash);\n\tmlock(hash, KDF_HASH_LEN);\n}\n"
        },
        {
          "name": "kdf.h",
          "type": "blob",
          "size": 0.4130859375,
          "content": "#ifndef KDF_H\n#define KDF_H\n\n#include <sys/types.h>\n#include <openssl/sha.h>\n\n#define KDF_HASH_LEN SHA256_DIGEST_LENGTH\n#define KDF_HEX_LEN (KDF_HASH_LEN * 2 + 1)\n#define MINIMUM_ITERATIONS 2\n\nvoid kdf_login_key(const char *username, const char *password, int iterations, char hex[KDF_HEX_LEN]);\nvoid kdf_decryption_key(const char *username, const char *password, int iterations, unsigned char hash[KDF_HASH_LEN]);\n\n#endif\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 12.6162109375,
          "content": "#ifndef _LIST_H\n#define _LIST_H\n\n/* Stripped down implementation of linked list taken\n * from the Linux Kernel.\n */\n\n/*\n * Simple doubly linked list implementation.\n *\n * Some of the internal functions (\"__xxx\") are useful when\n * manipulating whole lists rather than single entries, as\n * sometimes we already know the next/prev entries and we can\n * generate better code by using them directly rather than\n * using the generic single-entry routines.\n */\n\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head name = LIST_HEAD_INIT(name)\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\n/*\n * Insert a new entry between two known consecutive entries.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head, head->next);\n}\n\n/**\n * list_add_tail - add a new entry\n * @new: new entry to be added\n * @head: list head to add it before\n *\n * Insert a new entry before the specified head.\n * This is useful for implementing queues.\n */\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n/*\n * Delete a list entry by making the prev/next entries\n * point to each other.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\n#ifndef __clang_analyzer__\n#define LIST_POISON1  ((void *) 0x00100100)\n#define LIST_POISON2  ((void *) 0x00200200)\n#else\n#define LIST_POISON1  NULL\n#define LIST_POISON2  NULL\n#endif\n\n/**\n * list_empty - tests whether a list is empty\n * @head: the list to test.\n */\nstatic inline int list_empty(const struct list_head *head)\n{\n\treturn head->next == head;\n}\n\n/**\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty() on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_del(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n/**\n * list_first_entry - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_first_entry(ptr, type, member) \\\n\tlist_entry((ptr)->next, type, member)\n\n/**\n * list_last_entry - get the last element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_last_entry(ptr, type, member) \\\n\tlist_entry((ptr)->prev, type, member)\n\n/**\n * list_first_entry_or_null - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Note that if the list is empty, it returns NULL.\n */\n#define list_first_entry_or_null(ptr, type, member) \\\n\t(!list_empty(ptr) ? list_first_entry(ptr, type, member) : NULL)\n\n/**\n * list_last_entry_or_null - get the last element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Note that if the list is empty, it returns NULL.\n */\n#define list_last_entry_or_null(ptr, type, member) \\\n\t(!list_empty(ptr) ? list_last_entry(ptr, type, member) : NULL)\n\n/**\n * list_next_entry - get the next element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_next_entry(pos, member) \\\n\tlist_entry((pos)->member.next, typeof(*(pos)), member)\n\n/**\n * list_prev_entry - get the prev element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_prev_entry(pos, member) \\\n\tlist_entry((pos)->member.prev, typeof(*(pos)), member)\n\n/**\n * list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev\t-\titerate over a list backwards\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n\tfor (pos = (head)->prev; pos != (head); pos = pos->prev)\n\n/**\n * list_for_each_safe - iterate over a list safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->next, n = pos->next; pos != (head); \\\n\t\tpos = n, n = pos->next)\n\n/**\n * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev_safe(pos, n, head) \\\n\tfor (pos = (head)->prev, n = pos->prev; \\\n\t     pos != (head); \\\n\t     pos = n, n = pos->prev)\n\n/**\n * list_for_each_entry\t-\titerate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\n\t     &pos->member != (head);\t\t\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_reverse - iterate backwards over list of given type.\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_reverse(pos, head, member)\t\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member);\t\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()\n * @pos:\tthe type * to use as a start point\n * @head:\tthe head of the list\n * @member:\tthe name of the list_struct within the struct.\n *\n * Prepares a pos entry for use as a start point in list_for_each_entry_continue().\n */\n#define list_prepare_entry(pos, head, member) \\\n\t((pos) ? : list_entry(head, typeof(*pos), member))\n\n/**\n * list_for_each_entry_continue - continue iteration over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Continue to iterate over list of given type, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue(pos, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member);\t\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_continue_reverse - iterate backwards from the given point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Start to iterate over list of given type backwards, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue_reverse(pos, head, member)\t\t\\\n\tfor (pos = list_prev_entry(pos, member);\t\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_for_each_entry_from - iterate over list of given type from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from(pos, head, member) \t\t\t\\\n\tfor (; &pos->member != (head);\t\t\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member),\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_continue - continue list iteration safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type, continuing after current point,\n * safe against removal of list entry.\n */\n#define list_for_each_entry_safe_continue(pos, n, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member), \t\t\t\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_from - iterate over list from current point safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type from current point, safe against\n * removal of list entry.\n */\n#define list_for_each_entry_safe_from(pos, n, head, member) \t\t\t\\\n\tfor (n = list_next_entry(pos, member);\t\t\t\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate backwards over list of given type, safe against removal\n * of list entry.\n */\n#define list_for_each_entry_safe_reverse(pos, n, head, member)\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member),\t\t\\\n\t\tn = list_prev_entry(pos, member);\t\t\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = n, n = list_prev_entry(n, member))\n\n/**\n * list_safe_reset_next - reset a stale list_for_each_entry_safe loop\n * @pos:\tthe loop cursor used in the list_for_each_entry_safe loop\n * @n:\t\ttemporary storage used in list_for_each_entry_safe\n * @member:\tthe name of the list_struct within the struct.\n *\n * list_safe_reset_next is not safe to use in general if the list may be\n * modified concurrently (eg. the lock is dropped in the loop body). An\n * exception to this is if the cursor element (pos) is pinned in the list,\n * and list_safe_reset_next is called after re-taking the lock and before\n * completing the current iteration of the loop body.\n */\n#define list_safe_reset_next(pos, n, member)\t\t\t\t\\\n\tn = list_next_entry(pos, member)\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#ifndef __clang_analyzer__\n#define container_of(ptr, type, member) __extension__({\t\t\t\\\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\\\n\t(type *)( (char *)__mptr - offsetof(type,member) );})\n#else\n#define container_of(ptr, type, member) __extension__({\t\t\t\\\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\\\n\t(type *)( (char *)__mptr - (char *)offsetof(type,member) );})\n#endif\n#endif\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 2.58203125,
          "content": "/*\n * logging functions\n *\n * Copyright (C) 2016 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"util.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <fcntl.h>\n#include <sys/time.h>\n\n#define TIME_FMT \"%lld.%06lld\"\n#define TIME_ARGS(tv) ((long long)(tv)->tv_sec), ((long long)(tv)->tv_usec)\n\nint lpass_log_level()\n{\n\tchar *log_level_str;\n\tint level;\n\n\tlog_level_str = getenv(\"LPASS_LOG_LEVEL\");\n\tif (!log_level_str)\n\t\treturn LOG_NONE;\n\n\tlevel = strtoul(log_level_str, NULL, 10);\n\treturn (enum log_level) level;\n}\n\nvoid lpass_log(enum log_level level, char *fmt, ...)\n{\n\tstruct timeval tv;\n\tstruct timezone tz;\n\tva_list ap;\n\t_cleanup_fclose_ FILE *fp = NULL;\n\n\tint req_level = lpass_log_level();\n\n\tif (req_level < level)\n\t\treturn;\n\n\tfp = lpass_log_open();\n\tif (!fp)\n\t\treturn;\n\n\tgettimeofday(&tv, &tz);\n\tfprintf(fp, \"<%d> [\" TIME_FMT \"] \", level, TIME_ARGS(&tv));\n\tva_start(ap, fmt);\n\tvfprintf(fp, fmt, ap);\n\tva_end(ap);\n\tfflush(fp);\n}\n\nFILE *lpass_log_open()\n{\n\t_cleanup_free_ char *upload_log_path = NULL;\n\n\tif (lpass_log_level() < 0)\n\t\treturn NULL;\n\n\tupload_log_path = config_path(\"lpass.log\");\n\treturn fopen(upload_log_path, \"a\");\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 0.6220703125,
          "content": "#ifndef __LOG_H\n#define __LOG_H\n\n/*\n * Loglevels for ~/.lpass/lpass.log.  By default, nothing is logged, but\n * setting LPASS_LOG_LEVEL to a positive value will turn on logging.\n *\n * NOTE: debug and verbose logs can include sensitive information such as\n *       session IDs in the clear.  Do NOT post logs in public without\n *       scrubbing them first!\n */\nenum log_level\n{\n\tLOG_NONE = -1,\n\tLOG_ERROR = 3,\n\tLOG_WARNING = 4,\n\tLOG_INFO = 6,\n\tLOG_DEBUG = 7,\n\tLOG_VERBOSE = 8,\t/* _everything_ including CURL verbose logs */\n};\n\nint lpass_log_level();\nvoid lpass_log(enum log_level level, char *fmt, ...);\nFILE *lpass_log_open();\n\n#endif\n"
        },
        {
          "name": "lpass.1.txt",
          "type": "blob",
          "size": 13.923828125,
          "content": ":man source:   lpass\n:man manual:   lpass\n\nLPASS(1)\n========\n\n\nNAME\n----\nlpass - command line interface for LastPass\n\nSYNOPSIS\n--------\n[verse]\n*lpass* [ --version, -v | --help, -h ]\n*lpass* <subcommand> [<args>]\n\nDESCRIPTION\n-----------\n'lpass' is a simple command line interface to LastPass. It is comprised of\nseveral subcommands:\n\n[verse]\n lpass *login* [--trust] [--plaintext-key [--force, -f]] [--color=auto|never|always] USERNAME\n lpass *logout* [--force, -f] [--color=auto|never|always]\n lpass *passwd*\n lpass *show* [--sync=auto|now|no] [--clip, -c] [--quiet, -q] [--expand-multi, -x] [--json, -j] [--all|--username|--password|--url|--notes|--field=FIELD|--id|--name|--attach=ATTACHID] [--basic-regexp, -G|--fixed-strings, -F] [--color=auto|never|always] {NAME|UNIQUEID}*\n lpass *ls* [--sync=auto|now|no] [--long, -l] [-m] [-u] [--color=auto|never|always] [GROUP]\n lpass *mv* [--sync=auto|now|no] [--color=auto|never|always] {UNIQUENAME|UNIQUEID} GROUP\n lpass *add* [--sync=auto|now|no] [--non-interactive] {--name|--username, -u|--password, -p|--url|--notes|--field=FIELD|--note-type=NOTETYPE} [--color=auto|never|always] {NAME|UNIQUEID}\n lpass *edit* [--sync=auto|now|no] [--non-interactive] {--name|--username, -u|--password, -p|--url|--notes|--field=FIELD} [--color=auto|never|always] {NAME|UNIQUEID}\n lpass *generate* [--sync=auto|now|no] [--clip, -c] [--username=USERNAME] [--url=URL] [--no-symbols] [--color=auto|never|always] {NAME|UNIQUEID} LENGTH\n lpass *duplicate* [--sync=auto|now|no] [--color=auto|never|always] {UNIQUENAME|UNIQUEID}\n lpass *rm* [--sync=auto|now|no] [--color=auto|never|always] {UNIQUENAME|UNIQUEID}\n lpass *status* [--quiet, -q] [--color=auto|never|always]\n lpass *sync* [--background, -b] [--color=auto|never|always]\n lpass *import* [--sync=auto|now|no] [--keep-dupes] [FILENAME]\n lpass *export* [--sync=auto|now|no] [--color=auto|never|always] [--fields=FIELDLIST]\n lpass *share* *userls* SHARE\n lpass *share* *useradd* [--read-only=[true|false]] [--hidden=[true|false]] [--admin=[true|false]] SHARE USERNAME\n lpass *share* *usermod* [--read-only=[true|false]] [--hidden=[true|false]] [--admin=[true|false]] SHARE USERNAME\n lpass *share* *userdel* SHARE USERNAME\n lpass *share* *create* SHARE\n lpass *share* *rm* SHARE\n lpass *share* *limit* [--deny|--allow] [--add|--rm|--clear] SHARE USERNAME [sites]\n\nSynchronization\n~~~~~~~~~~~~~~~\nThe '--sync' options control when the current operation involves a\nsynchronization with the server. If 'now' is set, and the command makes a\nchange, the change is synchronized before the command exits. If 'now' is set,\nand the command displays a value, the local cache is synchronized before the\nvalue is shown. If 'now' is set, and the command is otherwise successful, but\nsynchronization fails, the command will return an error. If 'auto' is set,\nand the command makes a change, the change is synchronized to the server in\nthe background. If 'auto' is set, and the command displays a value, the local\ncache is synchronized before the value is shown only if the local cache is\nmore than 5 seconds (or 'LPASS_AUTO_SYNC_TIME' seconds, if set) old. If 'no'\nis set, the command will not interact with the server, unless there is a\ncurrent upload queue being processed. Any local changes that are not\nsynchronized with the server will exist in a queue of timestamped requests\nwhich will be synchronized on the next occurring synchronization.\n\nThe 'sync' command forces a synchronization of the local cache with the\nLastPass servers, and does not exit until the local cache is synchronized or\nuntil an error occurs. Alternatively, if '--background' is specified, the\nsynchronization occurs in a daemonized process.\n\nAgent\n~~~~~\nAn agent process will be spawned in the background on a first successful\ncommand, and all subsequent commands will use the agent for decryption,\ninstead of asking a user for a password. The agent will quit after one hour,\nunless the 'LPASS_AGENT_TIMEOUT' environment variable is set to an alternative\nnumber of seconds in which to quit, or 0 to never quit. If the environment\nvariable 'LPASS_AGENT_DISABLE' is set to 1, the agent will not be used.\n\nPassword Entry\n~~~~~~~~~~~~~~\nThe *pinentry* program, part of *gpg2*(1), may be used for inputting\npasswords if it is installed. A custom path to the *pinentry* program can be\nprovided by the 'LPASS_PINENTRY' environment variable.\n\nIf *pinentry* program is unavailable, or if the 'LPASS_DISABLE_PINENTRY'\nenvironment variable is set to 1, passwords will be read from standard input and a\nprompt will be displayed on standard error.\n\nThe program used for inputting passwords may also be configured by setting the\n'LPASS_ASKPASS' environment variable. 'LPASS_ASKPASS' is expected to be a\nbinary that produces a prompt using its first command-line argument, and\noutputs the entered password to standard out.  ssh-askpass implements this\nprotocol, as does the following shell script:\n\n[verse]\n #!/bin/bash\n echo -n \"$*: \" >/dev/stderr\n stty -echo\n read answer\n stty echo\n echo $answer\n\nEntry Specification\n~~~~~~~~~~~~~~~~~~~\nCommands that take a 'UNIQUENAME' will fail if the provided name is used\nmultiple times, and return an error. Commands may alternatively take a\n'UNIQUEID', which will be the integer 'ID' provided by LastPass for identifying\nentries uniquely. Commands that take either a 'NAME' or a 'UNIQUEID' will create a\nnew entry if a 'NAME' is specified and otherwise overwrite an existing entry if\n'UNIQUEID' is specified.\n\nLogging In\n~~~~~~~~~~\nThe 'login' subcommand will initialize a local cache and configuration folder,\nthen attempt to authenticate itself with the LastPass servers, using the\nprovided command line credentials or by interactively prompting (in the case of\nmultifactor or an unprovided password). The '--trust' option will cause\nsubsequent logins to not require multifactor authentication. If the\n'--plaintext-key' option is specified, the decryption key will be saved to the\nhard disk in plaintext.  Please note that use of this option is discouraged\nexcept in limited situations, as it greatly decreases the security of data.\n\nThe 'logout' subcommand will remove the local cache and stored encryption\nkeys. It will prompt the user to confirm, unless '--force' is specified.\n\nThe 'passwd' subcommand may be used to change your LastPass password:\nit will prompt for the old and new password and then re-encrypt all records\nwith the newly derived key.\n\nViewing\n~~~~~~~\nThe 'show' subcommand will display a password or selected field.\n\nBy default, the site you specify with the 'show' subcommand must\n*exactly* match the name of the site.  If the '--fixed-strings' or '-F'\noption is set, then the 'show' subcommand will find a site containing\nthat *exact* substring; if the '--basic-regexp' or '-G' option is set,\nthen the 'show' subcommand will find a site matching a case-insensitive\nregular expression.\n\nBy default if your 'show' subcommand matches more than one site, then\nthe 'show' subcommand will generate a warning and display the names of\nmatching sites but no other information.  The '--expand-multi' or '-x'\noption will instead show the requested information from all of the\nmatching sites.\n\nThe 'ls' subcommand will list names in groups in a tree structure. If\nthe '--long' or '-l' option is set, then also list the last modification\ntime.  The '-u' option may be passed to show the last use (last touch) time\ninstead, if available. Both times are in GMT.\n\nPassing '--json' to 'show' will generate json output instead of\nhuman-readable text.\n\nIn addition to using the built-in formats, both 'show' and 'ls' subcommands\nsupport printf-style format strings by using the '--format' option with\nthe following placeholders:\n\n* %ai: account id\n* %an: account name\n* %aN: account name including path\n* %au: account user\n* %ap: account password\n* %am: account modification time\n* %aU: account last touch time\n* %as: account share name\n* %ag: account group name\n* %al: account URL\n* %fn: field name (for 'show')\n* %fv: field value (for 'show')\n\nA slash can be added between the '%' and the placeholder to indicate that a\nslash should be appended, only if the printed value is expanded to a non-empty\nstring.  For example, this command will properly show the full path to\nan account: `lpass ls --format=\"%/as%/ag%an\"`.\n\nModifying\n~~~~~~~~~\nThe 'edit' subcommand will edit the selected field. If '--non-interactive' is not\nset, the selected field will be edited using 'EDITOR'; otherwise the command will\naccept data until EOF or, unless the notes field is being edited, the first new line.\nPlease note that when editing interactively, the contents of the field may be\nsaved on disk in tmp files or in editor swap files, depending on your system\nconfiguration.\n\nThe 'generate' subcommand will create a randomly generated password for the\nchosen key name, and optionally add a url and username while inserting the\ngenerated password.\n\nThe 'rm' command will remove the specified entry, and the 'duplicate' command\nwill create a duplicate entry of the one specified, but with a different 'ID'.\n\nBackup\n~~~~~~\nThe 'export' subcommand will dump all account information including\npasswords to stdout (unencrypted) in CSV format.  The optional\n'--fields=FIELDLIST' argument may contain a comma-separated subset of the\nfollowing fields:\n\n  id, url, username, password, extra, name, fav, id, grouping, group,\n  fullname, last_touch, last_modified_gmt, attachpresent\n\nThe 'import' subcommand does the reverse: accounts from an unencrypted\nCSV file are uploaded to the server.\n\nIt is recommended that such backups be encrypted at rest, for example by\npiping to and from gpg.\n\nShared Folder Commands\n~~~~~~~~~~~~~~~~~~~~~~\nThe 'share' command and its accompanying subcommands can be used to manipulate\nshared folders, if available to the (enterprise or premium) user.  The\n'userls', 'useradd', 'usermod', and 'userdel' subcommands may be used to\nquery and modify membership of the shared folder, while the 'create' and 'rm'\nshare subcommands may be used to add new, or delete existing shared folders.\nThe normal 'generate' and 'edit' commands may be used to edit accounts within\nthe shared folder.\n\nThe 'share limit' command may be used to manipulate account access lists on the\nshare for a specific user.  Running with no arguments will display the\ncurrent access levels for a user.  The '--add', '--rm', and '--clear' options\nmay be used to add to, remove from, or reset the list.  Passing '--allow' or\n'--deny' will make the list a whitelist or blacklist, respectively.\n\nClipboard\n~~~~~~~~~\nCommands that take a '-c' or '--clip' option will copy the output to the\nclipboard, using *xclip*(1) or *xsel*(1) on X11-based systems, *pbcopy*(1)\non OSX, or *putclip* on Cygwin. The command to be used can be overridden by\nspecifying the `LPASS_CLIPBOARD_COMMAND` environment variable.\n\nColor Output\n~~~~~~~~~~~~\nThe '--color' option controls colored output to the terminal.  By default,\ncommands will use '--color=auto', in which color output is used unless the\noutput is not a tty (for example, when passed to a pipe or file).  If 'always'\nis used, colors are produced regardless of the output detection.  If 'never'\nis used, no color escape sequences are emitted.\n\nConfiguration\n~~~~~~~~~~~~~\n'lpass' stores configuration in the following locations, in descending\norder of precedence:\n\n* The directory '$LPASS_HOME', if set\n* '$XDG_CONFIG_HOME/lpass', '$XDG_DATA_HOME/lpass', and\n  '$XDG_RUNTIME_DIR/lpass' (or equivalent defaults), if at least\n  '$XDG_RUNTIME_DIR' is set\n* '$HOME/.lpass'\n\nAll configuration may be specified via environment variables. Alternatively, a\nset of environment variable overrides may be specified in '$LPASS_HOME/env' in\nthe form of:\n\n[verse]\nVARIABLE1=VALUE1\nVARIABLE2=VALUE2\n...\n\nAliases\n~~~~~~~\nDefault options can be specified for any command by creating command aliases.\nCommand aliases are stored in the configuration directory (see previous\nsection) with files named 'alias.*command*'.  For example, to force the\n'ls' subcommand to never use color, make an 'alias.ls' file with the\nappropriate option:\n----\necho 'ls --color=never' > ~/.config/lpass/alias.ls\n----\n\nSimilarly, new subcommands can be created based on built-in subcommands with\noptions.  Thus,\n----\necho 'show --password -c' > ~/.config/lpass/alias.passclip\n----\n\nwould create a 'passclip' subcommand that copies your password onto the\nclipboard.\n\nENVIRONMENT VARIABLES\n---------------------\nThe following environment variables may be used for configuration as described\nin the section above:\n\n* 'LPASS_HOME'\n* 'LPASS_AUTO_SYNC_TIME'\n* 'LPASS_AGENT_TIMEOUT'\n* 'LPASS_AGENT_DISABLE'\n* 'LPASS_PINENTRY'\n* 'LPASS_DISABLE_PINENTRY'\n* 'LPASS_ASKPASS'\n* 'LPASS_CLIPBOARD_COMMAND'\n\nEXAMPLES\n--------\n\nIn the following examples, \"$\" indicates a shell prompt while \"#\"\nindicates a comment.\n\n----\n# login, generate and retrieve a new password\n$ lpass login user@example.com\n$ lpass generate work/email 20\nG</Czo4*c;A+g;KIHkO-\n$ lpass ls work\nwork\n    email [id: 140613939481239829]\n$ lpass show -p email\nG</Czo4*c;A+g;KIHkO-\n\n# Copy password to clipboard\n$ lpass show -cp email\n\n# Add a new secure note\n$ lpass add --note-type=ssn info/my-ssn\n# (editor shows a template file; fill in and save)\nName: info/my-ssn\nNoteType: Social Security\nName: My Name Goes Here\nNumber: 123-45-6789\nNotes:    # Add notes below this line\nAny notes I want to save go here.\n~\n~\n\n$ lpass show my-ssn\ninfo/my-ssn [id: 0]\nNumber: 123-45-6789\nName: My Name Goes Here\nNoteType: Social Security\nNotes:\nAny notes I want to save go here.\n\n# Display a secure note attachment\n$ lpass show my-secure-note\ninfo/my-secure-note [id: 1426405543365295118]\nURL: http://sn\natt-1426405543365295118-94690: travel-flight.pdf\n$ lpass show my-secure-note --attach att-1426405543365295118-94690\n\"travel-flight.pdf\" is a binary file, print it anyway (or save)?  [y/n/S] s\nWrote 122864 bytes to \"travel-flight.pdf\"\n\n# Display secure note attachment to standard output\n$ lpass show my-secure-note --attach att-1426405543365295118-94690 --quiet\n[... binary data on stdout ...]\n\n# Add an account non-interactively by creating the proper template\nprintf \"Username: wizard97\\nPassword: vJwhFfBBtn8hj4\" | \\\n    lpass add Facebook --non-interactive\n----\n\n\n"
        },
        {
          "name": "lpass.c",
          "type": "blob",
          "size": 5.1328125,
          "content": "/*\n * lpass - lastpass command line utility\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"process.h\"\n#include \"cmd.h\"\n#include \"string.h\"\n#include \"util.h\"\n#include \"http.h\"\n#include \"config.h\"\n#include \"terminal.h\"\n#include \"version.h\"\n#include \"log.h\"\n#include <sys/stat.h>\n#include <getopt.h>\n#include <unistd.h>\n\n#if (defined(__APPLE__) && defined(__MACH__)) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)\n#include <libgen.h>\n#endif\n\n#define CMD(name) { #name, cmd_##name##_usage, cmd_##name }\nstatic struct {\n\tconst char *name;\n\tconst char *usage;\n\tint (*cmd)(int, char**);\n} commands[] = {\n\tCMD(login),\n\tCMD(logout),\n\tCMD(passwd),\n\tCMD(show),\n\tCMD(ls),\n\tCMD(mv),\n\tCMD(add),\n\tCMD(edit),\n\tCMD(generate),\n\tCMD(duplicate),\n\tCMD(rm),\n\tCMD(status),\n\tCMD(sync),\n\tCMD(export),\n\tCMD(import),\n\tCMD(share)\n};\n#undef CMD\n\nstatic void version(void)\n{\n\tterminal_printf(\"LastPass CLI v\" LASTPASS_CLI_VERSION \"\\n\");\n}\n\nstatic void help(void)\n{\n\tterminal_printf(\"Usage:\\n\");\n\tprintf(\"  %s {--help|--version}\\n\", ARGV[0]);\n\tfor (size_t i = 0; i < ARRAY_SIZE(commands); ++i)\n\t\tprintf(\"  %s %s\\n\", basename(ARGV[0]), commands[i].usage);\n}\n\nstatic int global_options(int argc, char *argv[])\n{\n\tstatic struct option long_options[] = {\n\t\t{\"version\", no_argument, NULL, 'v'},\n\t\t{\"help\", no_argument, NULL, 'h'},\n\t\t{0, 0, 0, 0}\n\t};\n\tint option;\n\tint option_index;\n\n\twhile ((option = getopt_long(argc, argv, \"vh\", long_options, &option_index)) != -1) {\n\t\tswitch (option) {\n\t\t\tcase 'v':\n\t\t\t\tversion();\n\t\t\t\treturn 0;\n\t\t\tcase 'h':\n\t\t\t\tversion();\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\thelp();\n\t\t\t\treturn 0;\n\t\t\tcase '?':\n\t\t\t\thelp();\n\t\t\t\treturn option == 'h';\n\t\t}\n\t}\n\n\thelp();\n\treturn 1;\n}\n\nstatic void expand_aliases(int *argc, char ***argv)\n{\n\tint i;\n\tconst char *alias = (*argv)[0];\n\tchar **new_argv = NULL;\n\tint argv_alloced;\n\tint new_argc = 0;\n\t_cleanup_free_ char *config_name;\n\n\txasprintf(&config_name, \"alias.%s\", alias);\n\n\t_cleanup_free_ char *alias_val = config_read_string(config_name);\n\tif (!alias_val)\n\t\treturn;\n\n\ttrim(alias_val);\n\n\t/* split commandline and prepend to argv */\n\targv_alloced = 0;\n\tnew_argv = xcalloc(*argc + 1, sizeof(*new_argv));\n\n\tchar *tok = strtok(alias_val, \" \\t\");\n\twhile (tok) {\n\t\tif (new_argc >= argv_alloced) {\n\t\t\targv_alloced += 16;\n\t\t\tnew_argv = xreallocarray(new_argv,\n\t\t\t\targv_alloced + *argc + 1, sizeof(*new_argv));\n\t\t}\n\t\tnew_argv[new_argc++] = xstrdup(tok);\n\t\ttok = strtok(NULL, \" \\t\");\n\t}\n\n\t/* copy in remaining items from argc */\n\tfor (i=1; i < *argc; i++) {\n\t\tnew_argv[new_argc++] = xstrdup((*argv)[i]);\n\t}\n\tnew_argv[new_argc] = 0;\n\t*argv = new_argv;\n\t*argc = new_argc;\n}\n\nstatic int process_command(int argc, char *argv[])\n{\n\texpand_aliases(&argc, &argv);\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(commands); ++i) {\n\t\tif (argc && !strcmp(argv[0], commands[i].name))\n\t\t\treturn commands[i].cmd(argc, argv);\n\t}\n\thelp();\n\treturn 1;\n}\n\nstatic void load_saved_environment(void)\n{\n\t_cleanup_free_ char *env = NULL;\n\n\tenv = config_read_string(\"env\");\n\tif (!env)\n\t\treturn;\n\n\tfor (char *tok = strtok(env, \"\\n\"); tok; tok = strtok(NULL, \"\\n\")) {\n\t\tchar *equals = strchr(tok, '=');\n\t\tif (!equals || !*equals) {\n\t\t\twarn(\"The environment line '%s' is invalid.\", tok);\n\t\t\tcontinue;\n\t\t}\n\t\t*equals = '\\0';\n\t\tif (setenv(tok, equals + 1, true))\n\t\t\twarn_errno(\"The environment line '%s' is invalid.\", tok);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\t/* For process.h to function. */\n\tARGC = argc;\n\tARGV = argv;\n\n\t/* Do not remove this umask. Always keep at top. */\n\tumask(0077);\n\n\tif (http_init())\n\t\tdie(\"Unable to initialize curl\");\n\n\tload_saved_environment();\n\n\tif (argc >= 2 && argv[1][0] != '-')\n\t\treturn process_command(argc - 1, argv + 1);\n\n\treturn global_options(argc, argv);\n}\n"
        },
        {
          "name": "notes.c",
          "type": "blob",
          "size": 6.65625,
          "content": "/*\n * routines for classifying secure notes\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include <string.h>\n#include \"notes.h\"\n#include \"util.h\"\n\n/* Templates for shared note types */\nstruct note_template note_templates[] = {\n\t[ NOTE_TYPE_AMEX ] = {\n\t\t.name = \"American Express\",\n\t\t.shortname = \"amex\",\n\t\t.fields = { NULL }},\n\t[ NOTE_TYPE_BANK ] = {\n\t\t.name = \"Bank Account\",\n\t\t.shortname = \"bank\",\n\t\t.fields = { \"Bank Name\", \"Account Type\", \"Routing Number\", \"Account Number\", \"SWIFT Code\", \"IBAN Number\", \"Pin\", \"Branch Address\", \"Branch Phone\", NULL }},\n\t[ NOTE_TYPE_CREDIT ] = {\n\t\t.name = \"Credit Card\",\n\t\t.shortname = \"credit-card\",\n\t\t.fields = { \"Name on Card\", \"Type\", \"Number\", \"Security Code\", \"Start Date\", \"Expiration Date\", NULL }},\n\t[ NOTE_TYPE_DATABASE ] = {\n\t\t.name = \"Database\",\n\t\t.shortname = \"database\",\n\t\t.fields = { \"Type\", \"Hostname\", \"Port\", \"Database\", \"Username\", \"Password\", \"SID\", \"Alias\", NULL }},\n\t[ NOTE_TYPE_DRIVERS_LICENSE ] = {\n\t\t.name = \"Driver's License\",\n\t\t.shortname = \"drivers-license\",\n\t\t.fields = { \"Number\", \"Expiration Date\", \"License Class\", \"Name\", \"Address\", \"City / Town\", \"State\", \"ZIP / Postal Code\", \"Country\", \"Date of Birth\", \"Sex\", \"Height\", NULL }},\n\t[ NOTE_TYPE_EMAIL ] = {\n\t\t.name = \"Email Account\",\n\t\t.shortname = \"email\",\n\t\t.fields = { \"Username\", \"Password\", \"Server\", \"Port\", \"Type\", \"SMTP Server\", \"SMTP Port\", NULL }},\n\t[ NOTE_TYPE_HEALTH_INSURANCE ] = {\n\t\t.name = \"Health Insurance\",\n\t\t.shortname = \"health-insurance\",\n\t\t.fields = { \"Company\", \"Company Phone\", \"Policy Type\", \"Policy Number\", \"Group ID\", \"Member Name\", \"Member ID\", \"Physician Name\", \"Physician Phone\", \"Physician Address\", \"Co-pay\", NULL }},\n\t[ NOTE_TYPE_IM ] = {\n\t\t.name = \"Instant Messenger\",\n\t\t.shortname = \"im\",\n\t\t.fields = { \"Type\", \"Username\", \"Password\", \"Server\", \"Port\", NULL }},\n\t[ NOTE_TYPE_INSURANCE ] = {\n\t\t.name = \"Insurance\",\n\t\t.shortname = \"insurance\",\n\t\t.fields = { \"Company\", \"Policy Type\", \"Policy Number\", \"Expiration\", \"Agent Name\", \"Agent Phone\", \"URL\", NULL }},\n\t[ NOTE_TYPE_MASTERCARD ] = {\n\t\t.name = \"Mastercard\",\n\t\t.shortname = \"mastercard\",\n\t\t.fields = { NULL }},\n\t[ NOTE_TYPE_MEMBERSHIP ] = {\n\t\t.name = \"Membership\",\n\t\t.shortname = \"membership\",\n\t\t.fields = { \"Organization\", \"Membership Number\", \"Member Name\", \"Start Date\", \"Expiration Date\", \"Website\", \"Telephone\", \"Password\", NULL }},\n\t[ NOTE_TYPE_PASSPORT ] = {\n\t\t.name = \"Passport\",\n\t\t.shortname = \"passport\",\n\t\t.fields = { \"Type\", \"Name\", \"Country\", \"Number\", \"Sex\", \"Nationality\", \"Date of Birth\", \"Issued Date\", \"Expiration Date\", NULL }},\n\t[ NOTE_TYPE_SERVER ] = {\n\t\t.name = \"Server\",\n\t\t.shortname = \"server\",\n\t\t.fields = { \"Hostname\", \"Username\", \"Password\", NULL }},\n\t[ NOTE_TYPE_SSN ] = {\n\t\t.name = \"Social Security\",\n\t\t.shortname = \"ssn\",\n\t\t.fields = { \"Name\", \"Number\", NULL }},\n\t[ NOTE_TYPE_SOFTWARE_LICENSE ] = {\n\t\t.name = \"Software License\",\n\t\t.shortname = \"software-license\",\n\t\t.fields = { \"License Key\", \"Licensee\", \"Version\", \"Publisher\", \"Support Email\", \"Website\", \"Price\", \"Purchase Date\", \"Order Number\", \"Number of Licenses\", \"Order Total\", NULL }},\n\t[ NOTE_TYPE_SSH_KEY ] = {\n\t\t.name = \"SSH Key\",\n\t\t.shortname = \"ssh-key\",\n\t\t.fields = { \"Bit Strength\", \"Format\", \"Passphrase\", \"Private Key\", \"Public Key\", \"Hostname\", \"Date\", NULL }},\n\t[ NOTE_TYPE_VISA ] = {\n\t\t.name = \"VISA\",\n\t\t.shortname = \"visa\",\n\t\t.fields = { NULL }},\n\t[ NOTE_TYPE_WIFI ] = {\n\t\t.name = \"Wi-Fi Password\",\n\t\t.shortname = \"wifi\",\n\t\t.fields = { \"SSID\", \"Password\", \"Connection Type\", \"Connection Mode\", \"Authentication\", \"Encryption\", \"Use 802.1X\", \"FIPS Mode\", \"Key Type\", \"Protected\", \"Key Index\", NULL }},\n};\n\nconst char *notes_get_name(enum note_type note_type)\n{\n\tif (note_type <= NOTE_TYPE_NONE || note_type >= NUM_NOTE_TYPES)\n\t\treturn \"\";\n\n\treturn note_templates[note_type].name;\n}\n\nbool note_field_is_multiline(enum note_type note_type, const char *field)\n{\n\treturn note_type == NOTE_TYPE_SSH_KEY && !strcmp(field, \"Private Key\");\n}\n\nbool note_has_field(enum note_type note_type, const char *field)\n{\n\tconst char **p;\n\tif (note_type <= NOTE_TYPE_NONE || note_type >= NUM_NOTE_TYPES)\n\t\treturn true;\n\n\tp = note_templates[note_type].fields;\n\twhile (*p) {\n\t\tif (!strcmp(field, *p))\n\t\t\treturn true;\n\t\tp++;\n\t}\n\treturn false;\n}\n\nenum note_type notes_get_type_by_shortname(const char *type_str)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(note_templates) != NUM_NOTE_TYPES);\n\n\tsize_t i;\n\tfor (i = 0; i < NUM_NOTE_TYPES; i++) {\n\t\tif (!strcasecmp(type_str, note_templates[i].shortname))\n\t\t\treturn i;\n\t}\n\treturn NOTE_TYPE_NONE;\n}\n\nenum note_type notes_get_type_by_name(const char *type_str)\n{\n\tsize_t i;\n\tfor (i = 0; i < NUM_NOTE_TYPES; i++) {\n\t\tif (!strcasecmp(type_str, note_templates[i].name))\n\t\t\treturn i;\n\t}\n\treturn NOTE_TYPE_NONE;\n}\n\nchar *note_type_usage()\n{\n\tint i;\n\tchar *start = \"--note-type=TYPE\\n\\nValid values for TYPE:\\n\";\n\tsize_t alloc_len = strlen(start) + 1;\n\tchar *usage_str;\n\n\tfor (i = 0; i < NUM_NOTE_TYPES; i++)\n\t\talloc_len += strlen(note_templates[i].shortname) + 2;\n\n\tusage_str = xcalloc(1, alloc_len);\n\tstrlcat(usage_str, start, alloc_len);\n\tfor (i = 0; i < NUM_NOTE_TYPES; i++) {\n\t\tstrlcat(usage_str, \"\\t\", alloc_len);\n\t\tstrlcat(usage_str, note_templates[i].shortname, alloc_len);\n\t\tif (i != NUM_NOTE_TYPES - 1)\n\t\t\tstrlcat(usage_str, \"\\n\", alloc_len);\n\t}\n\treturn usage_str;\n}\n"
        },
        {
          "name": "notes.h",
          "type": "blob",
          "size": 1.037109375,
          "content": "#ifndef NOTE_TYPES\n#define NOTE_TYPES\n\n#include <stdbool.h>\n\nenum note_type {\n\tNOTE_TYPE_NONE = -1,\n\tNOTE_TYPE_AMEX,\n\tNOTE_TYPE_BANK,\n\tNOTE_TYPE_CREDIT,\n\tNOTE_TYPE_DATABASE,\n\tNOTE_TYPE_DRIVERS_LICENSE,\n\tNOTE_TYPE_EMAIL,\n\tNOTE_TYPE_HEALTH_INSURANCE,\n\tNOTE_TYPE_IM,\n\tNOTE_TYPE_INSURANCE,\n\tNOTE_TYPE_MASTERCARD,\n\tNOTE_TYPE_MEMBERSHIP,\n\tNOTE_TYPE_PASSPORT,\n\tNOTE_TYPE_SERVER,\n\tNOTE_TYPE_SOFTWARE_LICENSE,\n\tNOTE_TYPE_SSH_KEY,\n\tNOTE_TYPE_SSN,\n\tNOTE_TYPE_VISA,\n\tNOTE_TYPE_WIFI,\n\tNUM_NOTE_TYPES,\t\t/* keep last */\n};\n\n#define MAX_FIELD_CT 12\nstruct note_template {\n\tconst char *shortname;\n\tconst char *name;\n\tconst char *fields[MAX_FIELD_CT + 1];\n};\n\nextern struct note_template note_templates[];\n\nconst char *notes_get_name(enum note_type note_type);\nbool note_field_is_multiline(enum note_type note_type, const char *field);\nbool note_has_field(enum note_type note_type, const char *field);\nenum note_type notes_get_type_by_shortname(const char *shortname);\nenum note_type notes_get_type_by_name(const char *type_str);\nchar *note_type_usage();\n\n#endif /* NOTE_TYPES */\n"
        },
        {
          "name": "password.c",
          "type": "blob",
          "size": 9.5859375,
          "content": "/*\n * queue for changes uploaded to LastPass\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"password.h\"\n#include \"util.h\"\n#include \"terminal.h\"\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <termios.h>\n\nstatic char *password_prompt_askpass(const char *askpass, const char *prompt, const char *error, const char *descfmt, va_list params)\n{\n\tint status;\n\tint write_fds[2], read_fds[2];\n\tpid_t child;\n\tFILE *output;\n\tchar *password = NULL, *lastlf;\n\tsize_t len;\n\tUNUSED(error);\n\tUNUSED(descfmt);\n\tUNUSED(params);\n\n\tif (pipe(write_fds) < 0 || pipe(read_fds) < 0)\n\t\tdie_errno(\"pipe\");\n\n\tchild = fork();\n\tif (child == -1)\n\t\tdie_errno(\"fork\");\n\n\tif (child == 0) {\n\t\tdup2(read_fds[1], STDOUT_FILENO);\n\n\t\tclose(read_fds[0]);\n\t\tclose(read_fds[1]);\n\t\tclose(write_fds[0]);\n\t\tclose(write_fds[1]);\n\t\texeclp(askpass, \"lpass-askpass\", prompt, NULL);\n\t\t_exit(76);\n\t}\n\tclose(read_fds[1]);\n\tclose(write_fds[0]);\n\tclose(write_fds[1]);\n\n\toutput = fdopen(read_fds[0], \"r\");\n\tif (!output)\n\t\tdie_errno(\"fdopen\");\n\n\tif (getline(&password, &len, output) < 0) {\n\t\tfree(password);\n\t\tdie(\"Unable to retrieve password from askpass (no reply)\");\n\t}\n\tlastlf = strrchr(password, '\\n');\n\tif (lastlf)\n\t\t*lastlf = '\\0';\n\twaitpid(child, &status, 0);\n\n\tif (WEXITSTATUS(status) == 76) {\n\t\tdie(\"Unable to execute askpass %s\", askpass);\n\t} else if (WEXITSTATUS(status)) {\n\t\tdie(\"There was an unspecified problem with askpass (%d)\",\n\t\t    WEXITSTATUS(status));\n\t}\n\treturn password;\n}\n\nstatic char *password_prompt_fallback(const char *prompt, const char *error, const char *descfmt, va_list params)\n{\n\tstruct termios old_termios, mask_echo;\n\tchar *password = NULL, *lastlf;\n\tsize_t len = 0;\n\n\tterminal_fprintf(stderr, TERMINAL_FG_YELLOW TERMINAL_BOLD);\n\tvfprintf(stderr, descfmt, params);\n\tterminal_fprintf(stderr, TERMINAL_RESET \"\\n\\n\");\n\n\tif (error)\n\t\tterminal_fprintf(stderr, TERMINAL_FG_RED TERMINAL_BOLD \"%s\" TERMINAL_RESET \"\\n\", error);\n\n\tterminal_fprintf(stderr, TERMINAL_BOLD \"%s\" TERMINAL_RESET \": \", prompt);\n\n\tif (isatty(STDIN_FILENO)) {\n\t\tif (tcgetattr(STDIN_FILENO, &old_termios) < 0)\n\t\t\tdie_errno(\"tcgetattr\");\n\t\tmask_echo = old_termios;\n\t\tmask_echo.c_lflag &= ~(ICANON | ECHO);\n\t\tif (tcsetattr(STDIN_FILENO, TCSANOW, &mask_echo) < 0)\n\t\t\tdie_errno(\"tcsetattr\");\n\t}\n\n\tif (getline(&password, &len, stdin) < 0) {\n\t\tfree(password);\n\t\tpassword = NULL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"\\n\");\n\tlastlf = strrchr(password, '\\n');\n\tif (lastlf)\n\t\t*lastlf = '\\0';\n\nout:\n\tif (isatty(STDIN_FILENO)) {\n\t\tif (tcsetattr(STDIN_FILENO, TCSANOW, &old_termios) < 0)\n\t\t\tdie_errno(\"tcsetattr\");\n\t}\n\n\tterminal_fprintf(stderr, \"%s\" TERMINAL_CLEAR_DOWN, error ? TERMINAL_UP_CURSOR(4) : TERMINAL_UP_CURSOR(3));\n\treturn password;\n}\n\nchar *pinentry_escape(const char *str)\n{\n\tint len, new_len;\n\tchar *escaped;\n\n\tif (!str)\n\t\treturn NULL;\n\n\tnew_len = len = strlen(str);\n\n\tfor (int i = 0; i < len; ++i) {\n\t\tif (str[i] == '%' || str[i] == '\\r' || str[i] == '\\n')\n\t\t\tnew_len += 2;\n\t}\n\n\tescaped = xcalloc(new_len + 1, 1);\n\n\tfor (int i = 0, j = 0; i < len; ++i, ++j) {\n\t\tif (str[i] == '%') {\n\t\t\tescaped[j] = '%';\n\t\t\tescaped[j + 1] = '2';\n\t\t\tescaped[j + 2] = '5';\n\t\t\tj += 2;\n\t\t} else if (str[i] == '\\r') {\n\t\t\tescaped[j] = '%';\n\t\t\tescaped[j + 1] = '0';\n\t\t\tescaped[j + 2] = 'd';\n\t\t\tj += 2;\n\t\t} else if (str[i] == '\\n') {\n\t\t\tescaped[j] = '%';\n\t\t\tescaped[j + 1] = '0';\n\t\t\tescaped[j + 2] = 'a';\n\t\t\tj += 2;\n\t\t} else\n\t\t\tescaped[j] = str[i];\n\t}\n\n\treturn escaped;\n}\n\nchar *pinentry_unescape(const char *str)\n{\n\tchar *unescaped;\n\tchar hex[3];\n\tint len;\n\n\tif (!str)\n\t\treturn NULL;\n\n\tlen = strlen(str);\n\tunescaped = xcalloc(len + 1, 1);\n\n\tfor (int i = 0, j = 0; i < len; ++i, ++j) {\n\t\tif (str[i] == '%') {\n\t\t\tif (i + 2 >= len)\n\t\t\t\tbreak;\n\t\t\thex[0] = str[i + 1];\n\t\t\thex[1] = str[i + 2];\n\t\t\thex[2] = '\\0';\n\t\t\ti += 2;\n\t\t\tunescaped[j] = strtoul(hex, NULL, 16);\n\t\t} else\n\t\t\tunescaped[j] = str[i];\n\t}\n\n\treturn unescaped;\n}\n\nchar *password_prompt(const char *prompt, const char *error, const char *descfmt, ...)\n{\n\tint status;\n\tint write_fds[2], read_fds[2];\n\tpid_t child;\n\tsize_t len = 0, total_len, new_len;\n\t_cleanup_fclose_ FILE *input = NULL;\n\t_cleanup_fclose_ FILE *output = NULL;\n\t_cleanup_free_ char *line = NULL;\n\t_cleanup_free_ char *desc = NULL;\n\t_cleanup_free_ char *prompt_colon = NULL;\n\t_cleanup_free_ char *password = NULL;\n\tchar *password_fallback;\n\tchar *askpass;\n\tchar *pinentry_fallback = \"pinentry\";\n\tchar *pinentry;\n\tchar *ret;\n\tva_list params;\n\tint devnull;\n\n\taskpass = getenv(\"LPASS_ASKPASS\");\n\tif (askpass) {\n\t\tva_start(params, descfmt);\n\t\taskpass = password_prompt_askpass(askpass, prompt, error, descfmt, params);\n\t\tva_end(params);\n\t\treturn askpass;\n\t}\n\n\tpassword_fallback = getenv(\"LPASS_DISABLE_PINENTRY\");\n\tif (password_fallback && !strcmp(password_fallback, \"1\")) {\n\t\tva_start(params, descfmt);\n\t\tpassword_fallback = password_prompt_fallback(prompt, error, descfmt, params);\n\t\tva_end(params);\n\t\treturn password_fallback;\n\t}\n\n\tpinentry = getenv(\"LPASS_PINENTRY\");\n\tif (!pinentry) {\n\t\tpinentry = pinentry_fallback;\n\t}\n\n\tif (pipe(write_fds) < 0 || pipe(read_fds) < 0)\n\t\tdie_errno(\"pipe\");\n\n\tchild = fork();\n\tif (child == -1)\n\t\tdie_errno(\"fork\");\n\n\tif (child == 0) {\n\t\tdup2(read_fds[1], STDOUT_FILENO);\n\t\tdup2(write_fds[0], STDIN_FILENO);\n\n\t\tdevnull = open(\"/dev/null\", O_WRONLY);\n\t\tdup2(devnull, STDERR_FILENO);\n\n\t\tclose(read_fds[0]);\n\t\tclose(read_fds[1]);\n\t\tclose(write_fds[0]);\n\t\tclose(write_fds[1]);\n\t\texeclp(pinentry, pinentry, NULL);\n\t\t_exit(76);\n\t}\n\tclose(read_fds[1]);\n\tclose(write_fds[0]);\n\n\tinput = fdopen(write_fds[1], \"w\");\n\toutput = fdopen(read_fds[0], \"r\");\n\tif (!input || !output)\n\t\tdie_errno(\"fdopen\");\n\n\n\t#define nextline() do { \\\n\t\tif (len) \\\n\t\t\tsecure_clear(line, len); \\\n\t\tlen = 0; \\\n\t\tfree(line); \\\n\t\tline = NULL; \\\n\t\tif (getline(&line, &len, output) < 0) \\\n\t\t\tgoto dead_pinentry; \\\n\t\tlen = strlen(line); \\\n\t} while (0)\n\n\t#define check() do { \\\n\t\tnextline(); \\\n\t\tif (!starts_with(line, \"OK\")) \\\n\t\t\tgoto dead_pinentry; \\\n\t} while (0)\n\n\t#define send(command, argument) do { \\\n\t\tif (argument == NULL) \\\n\t\t\tfprintf(input, command \"\\n\"); \\\n\t\telse { \\\n\t\t\t_cleanup_free_ char *cleaned = pinentry_escape(argument); \\\n\t\t\tfprintf(input, command \" %s\\n\", cleaned); \\\n\t\t} \\\n\t\tfflush(input); \\\n\t} while (0)\n\n\t#define option(name, val) do { \\\n\t\tchar *var = val, *option, *key = name; \\\n\t\tif (var) { \\\n\t\t\tvar = pinentry_escape(var); \\\n\t\t\txasprintf(&option, \"%s=%s\", key, var); \\\n\t\t\tsend(\"OPTION\", option); \\\n\t\t\tfree(var); \\\n\t\t\tfree(option); \\\n\t\t\tcheck(); \\\n\t\t} \\\n\t} while(0)\n\n\tcheck();\n\n\tsend(\"SETTITLE\", \"LastPass CLI\");\n\tcheck();\n\n\tif (prompt) {\n\t\txasprintf(&prompt_colon, \"%s:\", prompt);\n\t\tprompt = prompt_colon;\n\t}\n\tsend(\"SETPROMPT\", prompt);\n\tcheck();\n\n\tif (error) {\n\t\tsend(\"SETERROR\", error);\n\t\tcheck();\n\t}\n\n\tva_start(params, descfmt);\n\txvasprintf(&desc, descfmt, params);\n\tva_end(params);\n\n\tsend(\"SETDESC\", desc);\n\tcheck();\n\n\toption(\"ttytype\", getenv(\"TERM\"));\n\toption(\"ttyname\", ttyname(0));\n\toption(\"display\", getenv(\"DISPLAY\"));\n\n\tsend(\"GETPIN\", NULL);\n\ttotal_len = 1;\n\tpassword = xcalloc(total_len, 1);\n\tfor (;;) {\n\t\tnextline();\n\t\tif (starts_with(line, \"D\")) {\n\t\t\tif (len >= 3) {\n\t\t\t\tnew_len = total_len + len - 3;\n\t\t\t\tpassword = secure_resize(password, total_len, new_len);\n\t\t\t\ttotal_len = new_len;\n\t\t\t\tstrlcat(password, line + 2, total_len);\n\t\t\t}\n\t\t} else if (starts_with(line, \"OK\"))\n\t\t\tbreak;\n\t\telse {\n\t\t\tfree(password);\n\t\t\tpassword = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsend(\"BYE\", NULL);\n\n\t#undef nextline\n\t#undef check\n\t#undef send\n\t#undef option\n\n\twaitpid(child, NULL, 0);\n\n\tif (len)\n\t\tsecure_clear(line, len);\n\n\tret = pinentry_unescape(password);\n\tsecure_clear_str(password);\n\treturn ret;\n\ndead_pinentry:\n\tif (waitpid(child, &status, WNOHANG) <= 0) {\n\t\tsleep(1);\n\t\tif (waitpid(child, &status, WNOHANG) <= 0) {\n\t\t\tkill(child, SIGTERM);\n\t\t\tsleep(1);\n\t\t\tif (waitpid(child, &status, WNOHANG) <= 0) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\twaitpid(child, &status, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif (WEXITSTATUS(status) == 0)\n\t\treturn NULL;\n\telse if (WEXITSTATUS(status) == 76) {\n\t\tva_start(params, descfmt);\n\t\tpassword_fallback = password_prompt_fallback(prompt, error, descfmt, params);\n\t\tva_end(params);\n\t\treturn password_fallback;\n\t} else\n\t\tdie(\"There was an unspecified problem with pinentry.\");\n}\n"
        },
        {
          "name": "password.h",
          "type": "blob",
          "size": 0.2119140625,
          "content": "#ifndef PASSWORD_H\n#define PASSWORD_H\n\nchar *password_prompt(const char *prompt, const char *error, const char *descfmt, ...);\nchar *pinentry_unescape(const char *str);\nchar *pinentry_escape(const char *str);\n\n#endif\n"
        },
        {
          "name": "pbkdf2.c",
          "type": "blob",
          "size": 3.00390625,
          "content": "/*\n * Copyright (c) 2014-2016 Thomas Hurst.\n * Copyright (c) 2016-2018 LastPass.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"pbkdf2.h\"\n#include <string.h>\n#include <openssl/hmac.h>\n\n#ifndef min\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n#define ERR_IFZERO(x) if (!(x)) goto err\n#define ERR_LABEL err:\n#else\n#define ERR_IFZERO(x) (x)\n#define ERR_LABEL\n#endif\n\nint fallback_pkcs5_pbkdf2_hmac(const char *pass, size_t pass_len,\n\tconst unsigned char *salt, size_t salt_len, unsigned int iterations,\n\tconst EVP_MD *digest, size_t key_len, unsigned char *output)\n{\n\tHMAC_CTX *ctx;\n\tunsigned char *out = output;\n\tunsigned int iter = 1, count = 1;\n\tunsigned int cp_len, i, ret = 0;\n\tunsigned int key_left = key_len;\n\tunsigned int md_len = EVP_MD_size(digest);\n\n\tif (md_len == 0)\n\t\treturn 0;\n\n\tunsigned char tmp_md[md_len];\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)\n\tHMAC_CTX real_ctx;\n\tctx = &real_ctx;\n\tHMAC_CTX_init(ctx);\n#else\n\tctx = HMAC_CTX_new();\n\tif (!ctx)\n\t\treturn 0;\n#endif\n\n\tERR_IFZERO(HMAC_Init_ex(ctx, pass, pass_len, digest, NULL));\n\n\twhile (key_left) {\n\t\tcp_len = min(key_left, md_len);\n\n\t\tunsigned char c[4];\n\t\tc[0] = (count >> 24) & 0xff;\n\t\tc[1] = (count >> 16) & 0xff;\n\t\tc[2] = (count >> 8) & 0xff;\n\t\tc[3] = (count) & 0xff;\n\n\t\tERR_IFZERO(HMAC_Init_ex(ctx, NULL, 0, digest, NULL));\n\t\tERR_IFZERO(HMAC_Update(ctx, salt, salt_len));\n\t\tERR_IFZERO(HMAC_Update(ctx, c, 4));\n\t\tERR_IFZERO(HMAC_Final(ctx, tmp_md, NULL));\n\t\tmemcpy(out, tmp_md, cp_len);\n\n\t\tfor (iter=1; iter < iterations; iter++) {\n\t\t\tERR_IFZERO(HMAC_Init_ex(ctx, NULL, 0, digest, NULL));\n\t\t\tERR_IFZERO(HMAC_Update(ctx, tmp_md, md_len));\n\t\t\tERR_IFZERO(HMAC_Final(ctx, tmp_md, NULL));\n\n\t\t\tfor (i = 0; i < cp_len; i++) {\n\t\t\t\tout[i] ^= tmp_md[i];\n\t\t\t}\n\t\t}\n\n\t\tkey_left -= cp_len;\n\t\tout += cp_len;\n\t\tcount++;\n\t}\n\tret = 1;\n\nERR_LABEL\n#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)\n\tHMAC_CTX_cleanup(ctx);\n#else\n\tHMAC_CTX_free(ctx);\n#endif\n\treturn ret;\n}\n"
        },
        {
          "name": "pbkdf2.h",
          "type": "blob",
          "size": 1.4580078125,
          "content": "/*\n * Copyright (c) 2014-2017 Thomas Hurst.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifndef PBKDF2_H\n#define PBKDF2_H\n\n#include <openssl/evp.h>\n\n#if OPENSSL_VERSION_NUMBER < 0x10000000L\n#define PKCS5_PBKDF2_HMAC fallback_pkcs5_pbkdf2_hmac\n#endif\n\nint fallback_pkcs5_pbkdf2_hmac(const char *pass, size_t pass_len,\n\tconst unsigned char *salt, size_t salt_len, unsigned int iterations,\n\tconst EVP_MD *digest, size_t key_len, unsigned char *output);\n#endif\n"
        },
        {
          "name": "pins.h",
          "type": "blob",
          "size": 0.623046875,
          "content": "#ifndef PINS_H\n#define PINS_H\nconst char *PK_PINS[] = {\n\t/* future lastpass root CA (GlobalSign R1) */\n\t\"K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q=\",\n\t/* future lastpass root CA (GlobalSign R2) */\n\t\"iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0=\",\n\t/* future lastpass root CA (GlobalSign R3) */\n\t\"cGuxAXyFXFkWm61cF4HPWX8S0srS9j0aSqN0k4AP+4A=\",\n\t/* current lastpass.com primary (leaf) */\n\t\"YDjIAXSYj+mh+25FGifAiKN4oNOAj+as6gQv4naQG0M=\",\n\t/* current lastpass.eu primary (leaf) */\n\t\"SjMnNhjAyVM5Yv6O5JaQgNygBTU0wdb8Jz3mfQfTc28=\",\n\t/* GlobalSign ECC OV SSL CA 2018 intermediate CA */\n\t\"OD/WDbD3VsfMwwNzzy9MWd9JXppKB77Vb3ST2wn9meg=\"\n};\n#endif\n"
        },
        {
          "name": "process.c",
          "type": "blob",
          "size": 4.646484375,
          "content": "/*\n * lpass process settings\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"process.h\"\n#include \"util.h\"\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <limits.h>\n\n#if defined(__linux__)\n#include <sys/prctl.h>\n#define USE_PRCTL\n#elif defined(__APPLE__) && defined(__MACH__)\n#include <libproc.h>\n#include <sys/ptrace.h>\n#define USE_PTRACE\n#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)\n#include <sys/param.h>\n#include <sys/sysctl.h>\n#elif defined(__OpenBSD__)\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/sysctl.h>\n#include <kvm.h>\n#endif\n\n#ifndef USE_PRCTL\n#undef PR_SET_DUMPABLE\n#define PR_SET_DUMPABLE 0\n#define PR_SET_NAME 0\nstatic void prctl(__attribute__((unused)) int x,\n\t\t  __attribute__((unused)) unsigned long y) {}\n#endif\n\n#ifndef USE_PTRACE\n#undef PT_DENY_ATTACH\n#define PT_DENY_ATTACH 0\nstatic void ptrace(__attribute__((unused)) int x,\n\t\t   __attribute__((unused)) int y,\n\t\t   __attribute__((unused)) int z,\n\t\t   __attribute__((unused)) int w) {}\n#endif\n\n\n#if defined(__linux__) || defined(__CYGWIN__) || (defined(__NetBSD__) && !defined(KERN_PROC_PATHNAME))\nstatic int pid_to_cmd(pid_t pid, char *cmd, size_t cmd_size)\n{\n\t_cleanup_free_ char *proc;\n\txasprintf(&proc, \"/proc/%lu/exe\", (unsigned long)pid);\n\treturn readlink(proc, cmd, cmd_size - 1);\n}\n#elif defined(__APPLE__) && defined(__MACH__)\nstatic int pid_to_cmd(pid_t pid, char *cmd, size_t cmd_size)\n{\n\tint result;\n\tresult = proc_pidpath(pid, cmd, cmd_size);\n\treturn (result <= 0) ? -1 : 0;\n}\n#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)\nstatic int pid_to_cmd(pid_t pid, char *cmd, size_t cmd_size)\n{\n\tint mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid };\n\n\treturn sysctl(mib, 4, cmd, &cmd_size, NULL, 0);\n}\n#elif defined(__OpenBSD__)\nstatic int pid_to_cmd(pid_t pid, char *cmd, size_t cmd_size)\n{\n\tint cnt, ret;\n\tkvm_t *kd;\n\tstruct kinfo_proc *kp;\n\n\tret = -1;\n\n\tif ((kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL)) == NULL)\n\t\treturn ret;\n\tif ((kp = kvm_getprocs(kd, KERN_PROC_PID, (int)pid, sizeof(*kp), &cnt)) == NULL)\n\t\tgoto out;\n\tif ((kp->p_flag & P_SYSTEM) != 0)\n\t\tgoto out;\n\tif (cnt != 1)\n\t\tgoto out;\n\tif (strlcpy(cmd, kp[0].p_comm, cmd_size) >= cmd_size)\n\t\tgoto out;\n\n\tret = 0;\n\nout:\n\tkvm_close(kd);\n\treturn ret;\n}\n#else\n#error \"Please provide a pid_to_cmd for your platform\"\n#endif\n\nint ARGC;\nchar **ARGV;\n\nvoid process_set_name(const char *name)\n{\n\tsize_t argslen = 0;\n\tprctl(PR_SET_NAME, (unsigned long) name);\n\n\tif (!ARGC || !ARGV)\n\t\treturn;\n\n\tfor (int i = 0; i < ARGC; ++i) {\n\t\targslen += strlen(ARGV[i]) + 1;\n\t\tfor (char *p = ARGV[i]; *p; ++p)\n\t\t\t*p = '\\0';\n\t}\n\n\tstrlcpy(ARGV[0], name, argslen);\n}\n\nbool process_is_same_executable(pid_t pid)\n{\n\tchar resolved_them[PATH_MAX + 1] = { 0 }, resolved_me[PATH_MAX + 1] = { 0 };\n\n\tif (pid_to_cmd(pid, resolved_them, sizeof(resolved_them)) < 0 ||\n\t    pid_to_cmd(getpid(), resolved_me, sizeof(resolved_me)) < 0)\n\t\treturn false;\n\n\treturn strcmp(resolved_them, resolved_me) == 0;\n}\n\nvoid process_disable_ptrace(void)\n{\n\tprctl(PR_SET_DUMPABLE, 0);\n\tptrace(PT_DENY_ATTACH, 0, 0, 0);\n\n\tstruct rlimit limit = { 0, 0 };\n\tsetrlimit(RLIMIT_CORE, &limit);\n}\n"
        },
        {
          "name": "process.h",
          "type": "blob",
          "size": 0.2421875,
          "content": "#ifndef PROCESS_H\n#define PROCESS_H\n\n#include <stdbool.h>\n#include <sys/types.h>\n\nextern int ARGC;\nextern char **ARGV;\n\nvoid process_set_name(const char *name);\nvoid process_disable_ptrace(void);\nbool process_is_same_executable(pid_t pid);\n\n#endif\n"
        },
        {
          "name": "session.c",
          "type": "blob",
          "size": 4.033203125,
          "content": "/*\n * session handling routines\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"xml.h\"\n#include \"config.h\"\n#include \"util.h\"\n#include \"cipher.h\"\n#include \"agent.h\"\n#include \"upload-queue.h\"\n#include <sys/mman.h>\n#include <string.h>\n\nstruct session *session_new(void)\n{\n\treturn new0(struct session, 1);\n}\nvoid session_free(struct session *session)\n{\n\tif (!session)\n\t\treturn;\n\tfree(session->uid);\n\tfree(session->sessionid);\n\tfree(session->token);\n\tfree(session->private_key.key);\n\tfree(session->server);\n\tfree(session);\n}\nbool session_is_valid(struct session *session)\n{\n\treturn session && session->uid && session->sessionid && session->token;\n}\n\nvoid session_set_private_key(struct session *session, unsigned const char key[KDF_HASH_LEN], const char *key_hex)\n{\n\tcipher_decrypt_private_key(key_hex, key, &session->private_key);\n}\n\nvoid session_save(struct session *session, unsigned const char key[KDF_HASH_LEN])\n{\n\tconfig_write_encrypted_string(\"session_uid\", session->uid, key);\n\tconfig_write_encrypted_string(\"session_sessionid\", session->sessionid, key);\n\tconfig_write_encrypted_string(\"session_token\", session->token, key);\n\tconfig_write_encrypted_buffer(\"session_privatekey\", (char *)session->private_key.key, session->private_key.len, key);\n\tfeature_flag_save(&session->feature_flag, key);\n\n\t/*\n\t * existing sessions may not have a server yet; they will fall back\n\t * to lastpass.com.\n\t */\n\tif (session->server)\n\t\tconfig_write_string(\"session_server\", session->server);\n}\nstruct session *session_load(unsigned const char key[KDF_HASH_LEN])\n{\n\tstruct session *session = session_new();\n\tsession->uid = config_read_encrypted_string(\"session_uid\", key);\n\tsession->sessionid = config_read_encrypted_string(\"session_sessionid\", key);\n\tsession->token = config_read_encrypted_string(\"session_token\", key);\n\tsession->server = config_read_string(\"session_server\");\n\tsession->private_key.len = config_read_encrypted_buffer(\"session_privatekey\", &session->private_key.key, key);\n\tmlock(session->private_key.key, session->private_key.len);\n\tfeature_flag_load(&session->feature_flag, key);\n\n\tif (session_is_valid(session))\n\t\treturn session;\n\telse {\n\t\tsession_free(session);\n\t\treturn NULL;\n\t}\n}\n\nvoid session_kill()\n{\n\tconfig_unlink(\"verify\");\n\tconfig_unlink(\"username\");\n\tconfig_unlink(\"session_sessionid\");\n\tconfig_unlink(\"iterations\");\n\n\tconfig_unlink(\"blob\");\n\tconfig_unlink(\"session_token\");\n\tconfig_unlink(\"session_uid\");\n\tconfig_unlink(\"session_privatekey\");\n\tconfig_unlink(\"session_server\");\n\tconfig_unlink(\"plaintext_key\");\n\t\n\tfeature_flag_cleanup();\n\n\tagent_kill();\n\tupload_queue_kill();\n}\n"
        },
        {
          "name": "session.h",
          "type": "blob",
          "size": 0.765625,
          "content": "#ifndef SESSION_H\n#define SESSION_H\n\n#include \"kdf.h\"\n#include \"feature-flag.h\"\n#include <stdbool.h>\n\nstruct public_key {\n\tunsigned char *key;\n\tsize_t len;\n};\nstruct private_key {\n\tunsigned char *key;\n\tsize_t len;\n};\nstruct session {\n\tchar *uid;\n\tchar *sessionid;\n\tchar *token;\n\tchar *server;\n\tstruct private_key private_key;\n\tstruct feature_flag feature_flag;\n};\n\nstruct session *session_new();\nvoid session_free(struct session *session);\nbool session_is_valid(struct session *session);\nstruct session *session_load(unsigned const char key[KDF_HASH_LEN]);\nvoid session_save(struct session *session, unsigned const char key[KDF_HASH_LEN]);\nvoid session_set_private_key(struct session *session, unsigned const char key[KDF_HASH_LEN], const char *key_hex);\nvoid session_kill();\n\n#endif\n"
        },
        {
          "name": "terminal.c",
          "type": "blob",
          "size": 2.7861328125,
          "content": "/*\n * terminal printing routines\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"terminal.h\"\n#include \"util.h\"\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nstatic enum color_mode color_mode = COLOR_MODE_AUTO;\n\nstatic void filter_ansi(FILE *file, const char *fmt, va_list args)\n{\n\t_cleanup_free_ char *str = NULL;\n\tsize_t len, i, j;\n\n\tif (color_mode == COLOR_MODE_ALWAYS ||\n\t    (color_mode == COLOR_MODE_AUTO && isatty(fileno(file)))) {\n\t\tvfprintf(file, fmt, args);\n\t\treturn;\n\t}\n\n\tlen = xvasprintf(&str, fmt, args);\n\n\tfor (i = 0; len >= 2 && i < len - 2; ++i) {\n\t\tif (str[i] == '\\x1b' && str[i + 1] == '[') {\n\t\t\tstr[i] = str[i + 1] = '\\0';\n\t\t\tfor (j = i + 2; j < len; ++j) {\n\t\t\t\tif (isalpha(str[j]))\n\t\t\t\t\tbreak;\n\t\t\t\tstr[j] = '\\0';\n\t\t\t}\n\t\t\tstr[j] = '\\0';\n\t\t}\n\t}\n\tfor (i = 0; i < len; i = j) {\n\t\tfputs(&str[i], file);\n\t\tfor (j = i + strlen(&str[i]); j < len; ++j) {\n\t\t\tif (str[j] != '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid terminal_set_color_mode(enum color_mode mode)\n{\n\tcolor_mode = mode;\n}\n\nvoid terminal_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfilter_ansi(stdout, fmt, args);\n\tva_end(args);\n}\n\nvoid terminal_fprintf(FILE *file, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfilter_ansi(file, fmt, args);\n\tva_end(args);\n}\n"
        },
        {
          "name": "terminal.h",
          "type": "blob",
          "size": 1.6416015625,
          "content": "#ifndef TERMINAL_H\n#define TERMINAL_H\n\n#include \"util.h\"\n\n#define TERMINAL_FG_BLACK\t\"\\x1b[30m\"\n#define TERMINAL_FG_RED\t\t\"\\x1b[31m\"\n#define TERMINAL_FG_GREEN\t\"\\x1b[32m\"\n#define TERMINAL_FG_YELLOW\t\"\\x1b[33m\"\n#define TERMINAL_FG_BLUE\t\"\\x1b[34m\"\n#define TERMINAL_FG_MAGENTA\t\"\\x1b[35m\"\n#define TERMINAL_FG_CYAN\t\"\\x1b[36m\"\n#define TERMINAL_FG_WHITE\t\"\\x1b[37m\"\n#define TERMINAL_FG_DEFAULT\t\"\\x1b[39m\"\n\n#define TERMINAL_BG_BLACK\t\"\\x1b[40m\"\n#define TERMINAL_BG_RED\t\t\"\\x1b[41m\"\n#define TERMINAL_BG_GREEN\t\"\\x1b[42m\"\n#define TERMINAL_BG_YELLOW\t\"\\x1b[43m\"\n#define TERMINAL_BG_BLUE\t\"\\x1b[44m\"\n#define TERMINAL_BG_MAGENTA\t\"\\x1b[45m\"\n#define TERMINAL_BG_CYAN\t\"\\x1b[46m\"\n#define TERMINAL_BG_WHITE\t\"\\x1b[47m\"\n#define TERMINAL_BG_DEFAULT\t\"\\x1b[49m\"\n\n#define TERMINAL_BOLD\t\t\"\\x1b[1m\"\n#define TERMINAL_NO_BOLD\t\"\\x1b[22m\"\n#define TERMINAL_UNDERLINE\t\"\\x1b[4m\"\n#define TERMINAL_NO_UNDERLINE\t\"\\x1b[24m\"\n\n#define TERMINAL_RESET\t\t\"\\x1b[0m\"\n\n#define TERMINAL_SAVE_CURSOR\t\"\\x1b[s\"\n#define TERMINAL_RESTORE_CURSOR\t\"\\x1b[u\"\n#define TERMINAL_UP_CURSOR(l)\t\"\\x1b[\" #l \"A\"\n#define TERMINAL_DOWN_CURSOR(l)\t\"\\x1b[\" #l \"B\"\n#define TERMINAL_RIGHT_CURSOR(c) \"\\x1b[\" #c \"C\"\n#define TERMINAL_LEFT_CURSOR(c)\t\"\\x1b[\" #c \"D\"\n#define TERMINAL_CLEAR_DOWN\t\"\\x1b[0J\"\n#define TERMINAL_CLEAR_UP\t\"\\x1b[1J\"\n#define TERMINAL_CLEAR_RIGHT\t\"\\x1b[0K\"\n#define TERMINAL_CLEAR_LEFT\t\"\\x1b[1K\"\n#define TERMINAL_CLEAR_LINE\t\"\\x1b[2K\"\n#define TERMINAL_CLEAR_ALL\t\"\\x1b[2J\"\n\nenum color_mode {\n\tCOLOR_MODE_AUTO,\n\tCOLOR_MODE_NEVER,\n\tCOLOR_MODE_ALWAYS\n};\n\nvoid terminal_set_color_mode(enum color_mode color_mode);\nvoid terminal_printf(const char *fmt, ...) _printf_(1, 2);\nvoid terminal_fprintf(FILE *file, const char *fmt, ...) _printf_(2, 3);\n\n#endif\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "upload-queue.c",
          "type": "blob",
          "size": 10.5849609375,
          "content": "/*\n * queue for changes uploaded to LastPass\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"upload-queue.h\"\n#include \"session.h\"\n#include \"http.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"kdf.h\"\n#include \"log.h\"\n#include \"process.h\"\n#include \"password.h\"\n#include \"endpoints.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <signal.h>\n\n/* keep around failed updates for a couple of weeks */\n#define FAIL_MAX_AGE\t86400 * 14\n\nstatic void make_upload_dir(const char *path)\n{\n\t_cleanup_free_ char *base_path = NULL;\n\tstruct stat sbuf;\n\tint ret;\n\n\tbase_path = config_path(path);\n\n\tret = stat(base_path, &sbuf);\n\tif ((ret == -1 && errno == ENOENT) || !S_ISDIR(sbuf.st_mode)) {\n\t\tunlink(base_path);\n\t\tif (mkdir(base_path, 0700) < 0)\n\t\t\tdie_errno(\"mkdir(%s)\", base_path);\n\t} else if (ret == -1)\n\t\tdie_errno(\"stat(%s)\", base_path);\n\n}\n\nstatic void upload_queue_write_entry(const char *entry, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *name = NULL;\n\tunsigned long serial;\n\n\tmake_upload_dir(\"upload-queue\");\n\n\tfor (serial = 0; serial < ULONG_MAX; ++serial) {\n\t\tfree(name);\n\t\txasprintf(&name, \"upload-queue/%lu%04lu\", time(NULL), serial);\n\t\tif (!config_exists(name))\n\t\t\tbreak;\n\t}\n\tif (serial == ULONG_MAX)\n\t\tdie(\"No more upload queue entry slots available.\");\n\n\tconfig_write_encrypted_string(name, entry, key);\n}\n\nstatic void upload_queue_cleanup_failures()\n{\n\t_cleanup_free_ char *base_path = config_path(\"upload-fail\");\n\tDIR *dir = opendir(base_path);\n\tstruct dirent *entry;\n\tchar *p;\n\tstruct stat sbuf;\n\tint ret;\n\n\tif (!dir)\n\t\treturn;\n\n\twhile ((entry = readdir(dir))) {\n\t\t_cleanup_free_ char *fn = NULL;\n\n\t\tif (entry->d_type != DT_REG && entry->d_type != DT_UNKNOWN)\n\t\t\tcontinue;\n\n\t\tfor (p = entry->d_name; *p; ++p) {\n\t\t\tif (!isdigit(*p))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*p)\n\t\t\tcontinue;\n\n\t\txasprintf(&fn, \"%s/%s\", base_path, entry->d_name);\n\t\tret = stat(fn, &sbuf);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif ((time(NULL) - sbuf.st_mtime) > FAIL_MAX_AGE) {\n\t\t\tunlink(fn);\n\t\t}\n\t}\n\tclosedir(dir);\n}\n\nstatic void upload_queue_drop(const char *name)\n{\n\t_cleanup_free_ char *newname = NULL;\n\t_cleanup_free_ char *old_full = NULL;\n\t_cleanup_free_ char *new_full = NULL;\n\tchar *basename;\n\tint ret;\n\n\tlpass_log(LOG_DEBUG, \"UQ: dropping %s\\n\", name);\n\n\tmake_upload_dir(\"upload-fail\");\n\n\tbasename = strrchr(name, '/');\n\tif (!basename) {\n\t\tunlink(name);\n\t\treturn;\n\t}\n\tbasename += 1;\n\txasprintf(&newname, \"upload-fail/%s\", basename);\n\n\told_full = config_path(name);\n\tnew_full = config_path(newname);\n\tret = rename(old_full, new_full);\n\n\tlpass_log(LOG_DEBUG, \"UQ: rename returned %d (errno=%d)\\n\", ret, errno);\n\n\tupload_queue_cleanup_failures();\n}\n\nstatic char *upload_queue_next_entry(unsigned const char key[KDF_HASH_LEN], char **name, char **lock)\n{\n\tunsigned long long smallest = ULLONG_MAX, current;\n\t_cleanup_free_ char *smallest_name = NULL;\n\t_cleanup_free_ char *base_path = config_path(\"upload-queue\");\n\t_cleanup_free_ char *pidstr = NULL;\n\tpid_t pid;\n\tchar *result, *p;\n\tDIR *dir = opendir(base_path);\n\tstruct dirent *entry;\n\n\tif (!dir)\n\t\treturn NULL;\n\twhile ((entry = readdir(dir))) {\n\t\tif (entry->d_type != DT_REG && entry->d_type != DT_UNKNOWN)\n\t\t\tcontinue;\n\n\t\tfor (p = entry->d_name; *p; ++p) {\n\t\t\tif (!isdigit(*p))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*p)\n\t\t\tcontinue;\n\t\tcurrent = strtoull(entry->d_name, NULL, 10);\n\t\tif (!current)\n\t\t\tcontinue;\n\t\tif (current < smallest) {\n\t\t\tsmallest = current;\n\t\t\tfree(smallest_name);\n\t\t\tsmallest_name = xstrdup(entry->d_name);\n\t\t}\n\t}\n\tclosedir(dir);\n\tif (smallest == ULLONG_MAX)\n\t\treturn NULL;\n\n\txasprintf(name, \"upload-queue/%s\", smallest_name);\n\txasprintf(lock, \"%s.lock\", *name);\n\twhile (config_exists(*lock)) {\n\t\tfree(pidstr);\n\t\tpidstr = config_read_encrypted_string(*lock, key);\n\t\tif (!pidstr) {\n\t\t\tconfig_unlink(*lock);\n\t\t\tbreak;\n\t\t}\n\t\tpid = strtoul(pidstr, NULL, 10);\n\t\tif (!pid) {\n\t\t\tconfig_unlink(*lock);\n\t\t\tbreak;\n\t\t}\n\t\tif (process_is_same_executable(pid))\n\t\t\tsleep(1);\n\t\telse {\n\t\t\tconfig_unlink(*lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(pidstr);\n\tpidstr = xultostr(getpid());\n\tconfig_write_encrypted_string(*lock, pidstr, key);\n\tresult = config_read_encrypted_string(*name, key);\n\tif (!result) {\n\t\t/* could not decrypt: drop this file */\n\t\tlpass_log(LOG_DEBUG, \"UQ: unable to decrypt job %s\\n\", *name);\n\t\tupload_queue_drop(*name);\n\t\tconfig_unlink(*lock);\n\t\treturn NULL;\n\t}\n\treturn result;\n}\n\nstatic void upload_queue_cleanup(int signal)\n{\n\tUNUSED(signal);\n\tconfig_unlink(\"uploader.pid\");\n\t_exit(EXIT_SUCCESS);\n}\nstatic void upload_queue_upload_all(const struct session *session, unsigned const char key[KDF_HASH_LEN])\n{\n\tchar *entry, *next_entry, *result;\n\tint size;\n\tchar **argv = NULL;\n\tchar **argv_ptr;\n\tchar *name, *lock, *p;\n\tbool do_break;\n\tbool should_fetch_new_blob_after = false;\n\tint curl_ret;\n\tlong http_code;\n\tbool http_failed_all;\n\tint backoff;\n\tint backoff_scale = 8;\n\n\twhile ((entry = upload_queue_next_entry(key, &name, &lock))) {\n\n\t\tlpass_log(LOG_DEBUG, \"UQ: processing job %s\\n\", name);\n\n\t\tsize = 0;\n\t\tfor (p = entry; *p; ++p) {\n\t\t\tif (*p == '\\n')\n\t\t\t\t++size;\n\t\t}\n\t\tif (p > entry && p[-1] != '\\n')\n\t\t\t++size;\n\t\tif (size < 1) {\n\t\t\tconfig_unlink(name);\n\t\t\tconfig_unlink(lock);\n\t\t\tgoto end;\n\t\t}\n\t\targv_ptr = argv = xcalloc(size + 1, sizeof(char **));\n\t\tfor (do_break = false, p = entry, next_entry = entry; ; ++p) {\n\t\t\tif (!*p)\n\t\t\t\tdo_break = true;\n\t\t\tif (*p == '\\n' || !*p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\t*(argv_ptr++) = pinentry_unescape(next_entry);\n\t\t\t\tnext_entry = p + 1;\n\t\t\t\tif (do_break)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\targv[size] = NULL;\n\n\t\thttp_failed_all = true;\n\t\tbackoff = 1;\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tif (i) {\n\t\t\t\tlpass_log(LOG_DEBUG, \"UQ: attempt %d, sleeping %d seconds\\n\", i+1, backoff);\n\t\t\t\tsleep(backoff);\n\t\t\t\tbackoff *= backoff_scale;\n\t\t\t}\n\n\t\t\tlpass_log(LOG_DEBUG, \"UQ: posting to %s\\n\", argv[0]);\n\n\t\t\tresult = http_post_lastpass_v_noexit(session->server, argv[0],\n\t\t\t\tsession, NULL, &argv[1],\n\t\t\t\t&curl_ret, &http_code);\n\n\t\t\thttp_failed_all &=\n\t\t\t\t(curl_ret == HTTP_ERROR_CODE ||\n\t\t\t\t curl_ret == HTTP_ERROR_CONNECT);\n\n\t\t\tlpass_log(LOG_DEBUG, \"UQ: result %d (http_code=%ld)\\n\", curl_ret, http_code);\n\n\t\t\tif (http_code == 500) {\n\t\t\t\t/* not a rate-limit error; try again with less backoff */\n\t\t\t\tbackoff_scale = 2;\n\t\t\t} else {\n\t\t\t\tbackoff_scale = 8;\n\t\t\t}\n\n\t\t\tif (result && strlen(result))\n\t\t\t\tshould_fetch_new_blob_after = true;\n\t\t\tfree(result);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!result) {\n\t\t\tlpass_log(LOG_DEBUG, \"UQ: failed, http_failed_all: %d\\n\", http_failed_all);\n\n\t\t\t/* server failed response 5 times, remove it */\n\t\t\tif (http_failed_all)\n\t\t\t\tupload_queue_drop(name);\n\n\t\t\tconfig_unlink(lock);\n\t\t} else {\n\t\t\tlpass_log(LOG_DEBUG, \"UQ: succeeded\\n\");\n\t\t\tconfig_unlink(name);\n\t\t\tconfig_unlink(lock);\n\t\t}\n\t\tfor (argv_ptr = argv; *argv_ptr; ++argv_ptr)\n\t\t\tfree(*argv_ptr);\n\t\tfree(argv);\nend:\n\t\tfree(name);\n\t\tfree(lock);\n\t\tfree(entry);\n\t}\n\n\tif (should_fetch_new_blob_after)\n\t\tblob_free(lastpass_get_blob(session, key));\n}\n\nstatic void upload_queue_run(const struct session *session, unsigned const char key[KDF_HASH_LEN])\n{\n\t_cleanup_free_ char *pid = NULL;\n\tupload_queue_kill();\n\tpid_t child = fork();\n\tif (child < 0)\n\t\tdie_errno(\"fork(agent)\");\n\n\tif (child == 0) {\n\t\tint null = open(\"/dev/null\", 0);\n\t\tint upload_log = null;\n\n\t\tif (null >= 0) {\n\t\t\tdup2(null, 0);\n\t\t\tdup2(null, 1);\n\t\t\tdup2(null, 2);\n\t\t\tclose(null);\n\t\t\tclose(upload_log);\n\t\t}\n\t\tsetsid();\n\t\tIGNORE_RESULT(chdir(\"/\"));\n\t\tprocess_set_name(\"lpass [upload queue]\");\n\t\tsignal(SIGHUP, upload_queue_cleanup);\n\t\tsignal(SIGINT, upload_queue_cleanup);\n\t\tsignal(SIGQUIT, upload_queue_cleanup);\n\t\tsignal(SIGTERM, upload_queue_cleanup);\n\t\tsignal(SIGALRM, upload_queue_cleanup);\n\t\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\n\t\tlpass_log(LOG_DEBUG, \"UQ: starting queue run\\n\");\n\t\tupload_queue_upload_all(session, key);\n\t\tlpass_log(LOG_DEBUG, \"UQ: queue run complete\\n\");\n\t\tupload_queue_cleanup(0);\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\tpid = xultostr(child);\n\tconfig_write_string(\"uploader.pid\", pid);\n}\n\nvoid upload_queue_kill(void)\n{\n\t_cleanup_free_ char *pidstr = NULL;\n\tpid_t pid;\n\n\tpidstr = config_read_string(\"uploader.pid\");\n\tif (!pidstr)\n\t\treturn;\n\tpid = strtoul(pidstr, NULL, 10);\n\tif (!pid)\n\t\treturn;\n\tkill(pid, SIGTERM);\n}\n\nbool upload_queue_is_running(void)\n{\n\t_cleanup_free_ char *pidstr = NULL;\n\tpid_t pid;\n\n\tpidstr = config_read_string(\"uploader.pid\");\n\tif (!pidstr)\n\t\treturn false;\n\tpid = strtoul(pidstr, NULL, 10);\n\tif (!pid)\n\t\treturn false;\n\treturn process_is_same_executable(pid);\n}\n\nvoid upload_queue_enqueue(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const char *page, struct http_param_set *params)\n{\n\t_cleanup_free_ char *sum = xstrdup(page);\n\tchar *next = NULL;\n\tchar *escaped = NULL;\n\tchar *param;\n\tchar **argv = params->argv;\n\n\twhile ((param = *argv++)) {\n\t\tescaped = pinentry_escape(param);\n\t\txasprintf(&next, \"%s\\n%s\", sum, escaped);\n\t\tfree(escaped);\n\t\tfree(sum);\n\t\tsum = next;\n\t}\n\n\tupload_queue_write_entry(sum, key);\n\n\tif (sync != BLOB_SYNC_NO)\n\t\tupload_queue_ensure_running(key, session);\n}\n\nvoid upload_queue_ensure_running(unsigned const char key[KDF_HASH_LEN], const struct session *session)\n{\n\tif (!upload_queue_is_running())\n\t\tupload_queue_run(session, key);\n}\n"
        },
        {
          "name": "upload-queue.h",
          "type": "blob",
          "size": 0.4736328125,
          "content": "#ifndef UPLOADQUEUE_H\n#define UPLOADQUEUE_H\n\n#include \"kdf.h\"\n#include \"session.h\"\n#include \"blob.h\"\n#include \"http.h\"\n#include <stdbool.h>\n\nvoid upload_queue_enqueue(enum blobsync sync, unsigned const char key[KDF_HASH_LEN], const struct session *session, const char *page, struct http_param_set *params);\nbool upload_queue_is_running(void);\nvoid upload_queue_kill(void);\nvoid upload_queue_ensure_running(unsigned const char key[KDF_HASH_LEN], const struct session *session);\n\n#endif\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 12.1357421875,
          "content": "/*\n * utility functions\n *\n * Copyright (C) 2014-2018 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n *\n * reallocarray is:\n *     Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>.\n * strlcpy and strlcat are:\n *     Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>.\n * For reallocarray, strlcpy, and strlcat:\n *     Permission to use, copy, modify, and distribute this software for any\n *     purpose with or without fee is hereby granted, provided that the above\n *     copyright notice and this permission notice appear in all copies.\n *     THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n *     WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n *     MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n *     ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n *     WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n *     ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n *     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n#include \"util.h\"\n#include \"process.h\"\n#include \"terminal.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <openssl/rand.h>\n\nvoid warn(const char *err, ...)\n{\n\tchar message[4096];\n\tva_list params;\n\n\tva_start(params, err);\n\tvsnprintf(message, sizeof(message), err, params);\n\tva_end(params);\n\n\tterminal_fprintf(stderr, TERMINAL_FG_YELLOW TERMINAL_BOLD \"Warning\" TERMINAL_RESET \": %s\\n\", message);\n}\n\nvoid warn_errno(const char *err, ...)\n{\n\tchar message[4096], *error_message;\n\tva_list params;\n\n\terror_message = strerror(errno);\n\n\tva_start(params, err);\n\tvsnprintf(message, sizeof(message), err, params);\n\tva_end(params);\n\n\tterminal_fprintf(stderr, TERMINAL_FG_YELLOW TERMINAL_BOLD \"WARNING\" TERMINAL_RESET \": \" TERMINAL_FG_YELLOW \"%s\" TERMINAL_RESET \": %s\\n\", error_message, message);\n}\n\n_noreturn_ void die(const char *err, ...)\n{\n\tchar message[4096];\n\tva_list params;\n\n\tva_start(params, err);\n\tvsnprintf(message, sizeof(message), err, params);\n\tva_end(params);\n\n\tterminal_fprintf(stderr, TERMINAL_FG_RED TERMINAL_BOLD \"Error\" TERMINAL_RESET \": %s\\n\", message);\n\texit(1);\n}\n_noreturn_ void die_errno(const char *err, ...)\n{\n\tchar message[4096], *error_message;\n\tva_list params;\n\n\terror_message = strerror(errno);\n\n\tva_start(params, err);\n\tvsnprintf(message, sizeof(message), err, params);\n\tva_end(params);\n\n\tterminal_fprintf(stderr, TERMINAL_FG_RED TERMINAL_BOLD \"Error\" TERMINAL_RESET \": \" TERMINAL_FG_RED \"%s\" TERMINAL_RESET \": %s\\n\", error_message, message);\n\texit(1);\n}\n\nvoid die_usage(const char *usage)\n{\n\tterminal_fprintf(stderr, \"Usage: %s %s\\n\", ARGV[0], usage);\n\texit(1);\n}\n\nchar ask_options(char *options, char def, const char *prompt, ...)\n{\n\tva_list params;\n\t_cleanup_free_ char *response = NULL;\n\tsize_t len = 0;\n\tunsigned int i;\n\n\tfor (;;) {\n\t\tva_start(params, prompt);\n\t\tterminal_fprintf(stderr, TERMINAL_FG_YELLOW);\n\t\tvfprintf(stderr, prompt, params);\n\t\tterminal_fprintf(stderr, TERMINAL_RESET);\n\t\tva_end(params);\n\t\tterminal_fprintf(stderr, \" [\");\n\t        for (i = 0; i < strlen(options); i++) {\n\t\t\tif (options[i] == def) {\n\t\t\t\tterminal_fprintf(stderr,TERMINAL_BOLD \"%c\" TERMINAL_RESET, toupper(options[i]));\n\t\t\t} else {\n\t\t\t\tterminal_fprintf(stderr, \"%c\", options[i]);\n\t\t\t}\n\t\t\tif (i < strlen(options)-1)\n\t\t\t\tterminal_fprintf(stderr, \"/\");\n\t\t\telse\n\t\t\t\tterminal_fprintf(stderr, \"] \");\n\t\t}\n\t\tif (getline(&response, &len, stdin) < 0)\n\t\t\tdie(\"aborted response.\");\n\t\tstrlower(response);\n\n\t\tif (!strcmp(\"\\n\", response))\n\t\t\treturn def;\n\n\t\tif (strlen(response) && strchr(options, response[0]))\n\t\t\treturn response[0];\n\n\t\tterminal_fprintf(stderr, TERMINAL_FG_RED TERMINAL_BOLD \"Error\" TERMINAL_RESET \": Response not understood.\\n\");\n\t\tfree(response);\n\t\tresponse = NULL;\n\t\tlen = 0;\n\t}\n}\n\nbool ask_yes_no(bool default_yes, const char *prompt, ...)\n{\n\tva_list params;\n\tchar message[4096];\n\n\tva_start(params, prompt);\n\tvsnprintf(message, sizeof(message), prompt, params);\n\tva_end(params);\n\n\treturn ask_options(\"yn\", (default_yes) ? 'y' : 'n', message) == 'y';\n}\n\nvoid *xmalloc(size_t size)\n{\n\tvoid *ret = malloc(size);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"malloc(%zu)\", size);\n}\nvoid *xcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ret = calloc(nmemb, size);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"calloc(%zu, %zu)\", nmemb, size);\n}\nvoid *xrealloc(void *ptr, size_t size)\n{\n\tvoid *ret = realloc(ptr, size);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"realloc(%p, %zu)\", ptr, size);\n}\nvoid *reallocarray(void *optr, size_t nmemb, size_t size)\n{\n\tif (!size || !nmemb) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tif ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&\n\t    nmemb > 0 && SIZE_MAX / nmemb < size) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn realloc(optr, size * nmemb);\n}\nvoid *xreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *ret = reallocarray(ptr, nmemb, size);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"reallocarray(%p, %zu, %zu)\", ptr, nmemb, size);\n}\n\nvoid *xstrdup(const char *str)\n{\n\tvoid *ret = strdup(str);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"strdup(%p)\", (void *) str);\n}\nvoid *xstrndup(const char *str, size_t maxlen)\n{\n\tvoid *ret = strndup(str, maxlen);\n\tif (likely(ret))\n\t\treturn ret;\n\tdie_errno(\"strndup(%p, %zu)\", (void *) str, maxlen);\n}\nint xasprintf(char **strp, const char *fmt, ...)\n{\n\tva_list params;\n\tint ret;\n\n\tva_start(params, fmt);\n\tret = xvasprintf(strp, fmt, params);\n\tva_end(params);\n\n\treturn ret;\n}\nint xvasprintf(char **strp, const char *fmt, va_list ap)\n{\n\tint ret;\n\n\tret = vasprintf(strp, fmt, ap);\n\tif (ret == -1)\n\t\tdie_errno(\"asprintf(%p, %s, ...)\", (void *)strp, fmt);\n\n\treturn ret;\n}\n\n#ifdef __GLIBC__\nsize_t strlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn (s - src - 1);\t/* count does not include NUL */\n}\nsize_t strlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn (dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn (dlen + (s - src));\t/* count does not include NUL */\n}\n#else\nchar *strchrnul(const char *s, int c)\n{\n\tchar *p = strchr(s, c);\n\tif (!p)\n\t\tp = (char *)s + strlen(s);\n\treturn p;\n}\n#endif\n\nvoid strlower(char *str)\n{\n\tfor (; *str; ++str)\n\t\t*str = tolower(*str);\n}\nvoid strupper(char *str)\n{\n\tfor (; *str; ++str)\n\t\t*str = toupper(*str);\n}\nchar *xstrlower(const char *str)\n{\n\tchar *copy = xstrdup(str);\n\tstrlower(copy);\n\treturn copy;\n}\nchar *xstrupper(const char *str)\n{\n\tchar *copy = xstrdup(str);\n\tstrupper(copy);\n\treturn copy;\n}\nchar *xultostr(unsigned long num)\n{\n\tchar *str;\n\txasprintf(&str, \"%ld\", num);\n\treturn str;\n}\n\nbool starts_with(const char *str, const char *start)\n{\n\tfor (; ; ++str, ++start) {\n\t\tif (!*start)\n\t\t\treturn true;\n\t\telse if (*str != *start)\n\t\t\treturn false;\n\t}\n}\nbool ends_with(const char *str, const char *end)\n{\n\tint str_len = strlen(str);\n\tint end_len = strlen(end);\n\tif (str_len < end_len)\n\t\treturn false;\n\telse\n\t\treturn !strcmp(str + str_len - end_len, end);\n}\nchar *trim(char *str)\n{\n\tint start, i;\n\n\tfor (start = 0; isspace(str[start]) && str[start]; ++start);\n\n\tfor (i = 0; str[i + start]; ++i)\n\t\tstr[i] = str[i + start];\n\tstr[i] = '\\0';\n\n\tfor (--i; i >= 0 && isspace(str[i]); --i)\n\t\tstr[i] = '\\0';\n\n\treturn str;\n}\n\nvoid xstrappend(char **str, const char *suffix)\n{\n\tif (!*str) {\n\t\t*str = xstrdup(suffix);\n\t\treturn;\n\t}\n\tsize_t len = strlen(*str) + strlen(suffix) + 1;\n\t*str = xrealloc(*str, len);\n\tstrlcat(*str, suffix, len);\n}\nvoid xstrappendf(char **str, const char *suffixfmt, ...)\n{\n\t_cleanup_free_ char *fmt = NULL;\n\tva_list args;\n\n\tva_start(args, suffixfmt);\n\txvasprintf(&fmt, suffixfmt, args);\n\tva_end(args);\n\n\txstrappend(str, fmt);\n}\nvoid xstrprepend(char **str, const char *prefix)\n{\n\tif (!*str) {\n\t\t*str = xstrdup(prefix);\n\t\treturn;\n\t}\n\tsize_t len = strlen(*str) + strlen(prefix) + 1;\n\tchar *new = xmalloc(len);\n\tstrlcpy(new, prefix, len);\n\tstrlcat(new, *str, len);\n\tfree(*str);\n\t*str = new;\n}\nvoid xstrprependf(char **str, const char *suffixfmt, ...)\n{\n\t_cleanup_free_ char *fmt = NULL;\n\tva_list args;\n\n\tva_start(args, suffixfmt);\n\txvasprintf(&fmt, suffixfmt, args);\n\tva_end(args);\n\n\txstrprepend(str, fmt);\n}\n\nvoid secure_clear(void *ptr, size_t len)\n{\n\tif (!ptr)\n\t\treturn;\n\n\tmemset(ptr, 0, len);\n\t/* prevent GCC / LLVM from optimizing out memset */\n\tasm volatile(\"\" : : \"r\"(ptr) : \"memory\");\n}\n\nvoid secure_clear_str(char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tsecure_clear(str, strlen(str));\n}\n\nvoid *secure_resize(void *ptr, size_t oldlen, size_t newlen)\n{\n\t/* open-coded realloc, with a secure memset in the middle */\n\tvoid *newptr = xmalloc(newlen);\n\tif (ptr) {\n\t\tmemcpy(newptr, ptr, min(oldlen, newlen));\n\t\tsecure_clear(ptr, oldlen);\n\t\tfree(ptr);\n\t}\n\treturn newptr;\n}\n\nstatic char hex_digits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n_unroll_ void bytes_to_hex(const unsigned char *bytes, char **hex, size_t len)\n{\n\tif (!*hex)\n\t\t*hex = xmalloc(len * 2 + 1);\n\tfor (size_t i = 0; i < len; ++i) {\n\t\t(*hex)[i * 2] = hex_digits[(bytes[i] >> 4) & 0xF];\n\t\t(*hex)[i * 2 + 1] = hex_digits[bytes[i] & 0xF];\n\t}\n\t(*hex)[len * 2] = '\\0';\n}\n\nint hex_to_bytes(const char *hex, unsigned char **bytes)\n{\n\tsize_t len = strlen(hex);\n\tif (len % 2 != 0) {\n\t\tif (!*bytes)\n\t\t\t*bytes = xcalloc(1, 1);\n\t\t**bytes = '\\0';\n\t\treturn -EINVAL;\n\t}\n\tif (!*bytes)\n\t\t*bytes = xmalloc(len / 2 + 1);\n\tfor (size_t i = 0; i < len / 2; ++i) {\n\t\tif (sscanf(&hex[i * 2], \"%2hhx\", (unsigned char *)(*bytes + i)) != 1) {\n\t\t\tfprintf(stderr, \"%s\\n\", hex);\n\t\t\t**bytes = '\\0';\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t(*bytes)[len / 2] = '\\0';\n\treturn 0;\n}\n\n/* [min, max) */\nunsigned long range_rand(unsigned long min, unsigned long max)\n{\n\tunsigned long base_random, range, remainder, bucket;\n\n\tif (!RAND_bytes((unsigned char *)&base_random, sizeof(base_random)))\n\t\tdie(\"Could not generate random bytes.\");\n\tif (ULONG_MAX == base_random)\n\t\treturn range_rand(min, max);\n\trange = max - min;\n\tremainder = ULONG_MAX % range;\n\tbucket = ULONG_MAX / range;\n\tif (base_random < ULONG_MAX - remainder)\n\t\treturn min + base_random / bucket;\n\treturn range_rand(min, max);\n}\n\nvoid get_random_bytes(unsigned char *buf, size_t len)\n{\n\tif (!RAND_bytes(buf, len))\n\t\tdie(\"Could not generate random bytes.\");\n}\n\nconst char *bool_str(bool val)\n{\n\treturn val ? \"1\" : \"0\";\n}\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 3.5615234375,
          "content": "#ifndef UTIL_H\n#define UTIL_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n#ifndef min\n#define min(x,y) (((x) < (y)) ? (x) : (y))\n#endif\n\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define _noreturn_ __attribute__((noreturn))\n#if !defined(__clang__)\n#define _unroll_ __attribute__((optimize(\"unroll-loops\")))\n#else\n#define _unroll_\n#endif\n#define _printf_(x, y) __attribute__((format(printf, x, y)))\n#define _cleanup_(x) __attribute__((cleanup(x)))\n\n#define DEFINE_TRIVIAL_CLEANUP_FUNC(type, func)                 \\\n\tstatic inline void func##p(type *p) {                   \\\n\t\tif (*p)                                         \\\n\t\t\tfunc(*p);                               \\\n\t}\nDEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, fclose)\nDEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, pclose)\nDEFINE_TRIVIAL_CLEANUP_FUNC(DIR*, closedir)\n#undef DEFINE_TRIVIAL_CLEANUP_FUNC\nstatic inline void umaskp(mode_t *u) {\n\tumask(*u);\n}\nstatic inline void freep(void *p) {\n\tfree(*(void**) p);\n}\n#define _cleanup_free_ _cleanup_(freep)\n#define _cleanup_umask_ _cleanup_(umaskp)\n#define _cleanup_fclose_ _cleanup_(fclosep)\n#define _cleanup_pclose_ _cleanup_(pclosep)\n#define _cleanup_closedir_ _cleanup_(closedirp)\n\n#define new0(t, l) ((t*) xcalloc((l), sizeof(t)))\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))\n#define UNUSED(x) (void)(x)\n#define IGNORE_RESULT(x) do { int z = x; (void)sizeof(z); } while (0)\n\n#define MUL_NO_OVERFLOW (1UL << (sizeof(size_t) * 4))\n#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))\n\nvoid warn(const char *err, ...) _printf_(1, 2);\nvoid warn_errno(const char *err, ...) _printf_(1, 2);\n_noreturn_ void die(const char *err, ...) _printf_(1, 2);\n_noreturn_ void die_errno(const char *err, ...) _printf_(1, 2);\n_noreturn_ void die_usage(const char *usage);\nchar ask_options(char *options, char def, const char *prompt, ...);\nbool ask_yes_no(bool default_yes, const char *prompt, ...);\n\nvoid *xmalloc(size_t size);\nvoid *xcalloc(size_t nmemb, size_t size);\nvoid *xrealloc(void *ptr, size_t size);\nvoid *reallocarray(void *ptr, size_t nmemb, size_t size);\nvoid *xreallocarray(void *ptr, size_t nmemb, size_t size);\n\nvoid *xstrdup(const char *str);\nvoid *xstrndup(const char *str, size_t maxlen);\nint xasprintf(char **strp, const char *fmt, ...) _printf_(2, 3);\nint xvasprintf(char **strp, const char *fmt, va_list ap);\n\n#ifdef __GLIBC__\nsize_t strlcpy(char *dst, const char *src, size_t dstsize);\nsize_t strlcat(char *dst, const char *src, size_t dstsize);\n#else\nchar *strchrnul(const char *s, int c);\n#endif\n\nvoid strlower(char *str);\nvoid strupper(char *str);\nchar *xstrlower(const char *str);\nchar *xstrupper(const char *str);\n\nchar *xultostr(unsigned long num);\n\nvoid xstrappend(char **str, const char *suffix);\nvoid xstrappendf(char **str, const char *suffixfmt, ...) _printf_(2, 3);\nvoid xstrprepend(char **str, const char *suffix);\nvoid xstrprependf(char **str, const char *suffixfmt, ...) _printf_(2, 3);\n\nbool starts_with(const char *str, const char *start);\nbool ends_with(const char *str, const char *end);\n\nchar *trim(char *str);\n\nvoid bytes_to_hex(const unsigned char *bytes, char **hex, size_t len);\nint hex_to_bytes(const char *hex, unsigned char **bytes);\n\nvoid secure_clear(void *ptr, size_t len);\nvoid secure_clear_str(char *str);\nvoid *secure_resize(void *ptr, size_t oldlen, size_t newlen);\n\n/* [min, max) */\nunsigned long range_rand(unsigned long min, unsigned long max);\nvoid get_random_bytes(unsigned char *buf, size_t len);\n\nconst char *bool_str(bool val);\n#endif\n"
        },
        {
          "name": "xml.c",
          "type": "blob",
          "size": 16.283203125,
          "content": "/*\n * xml parsing routines\n *\n * Copyright (C) 2014-2024 LastPass.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to link the code of portions of this program with the\n * OpenSSL library under certain conditions as described in each\n * individual source file, and distribute linked combinations\n * including the two.\n *\n * You must obey the GNU General Public License in all respects\n * for all of the code used other than OpenSSL.  If you modify\n * file(s) with this exception, you may extend this exception to your\n * version of the file(s), but you are not obligated to do so.  If you\n * do not wish to do so, delete this exception statement from your\n * version.  If you delete this exception statement from all source\n * files in the program, then also delete it here.\n *\n * See LICENSE.OpenSSL for more details regarding this exception.\n */\n#include \"xml.h\"\n#include \"util.h\"\n#include \"blob.h\"\n#include \"feature-flag.h\"\n#include <string.h>\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <errno.h>\n\nstruct session *xml_ok_session(const char *buf, unsigned const char key[KDF_HASH_LEN])\n{\n\tstruct session *session = NULL;\n\txmlDoc *doc = NULL;\n\txmlNode *root;\n\tdoc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\tgoto out;\n\n\troot = xmlDocGetRootElement(doc);\n\tif (root && !xmlStrcmp(root->name, BAD_CAST \"response\")) {\n\t\tfor (root = root->children; root; root = root->next) {\n\t\t\tif (!xmlStrcmp(root->name, BAD_CAST \"ok\"))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (root && !xmlStrcmp(root->name, BAD_CAST \"ok\")) {\n\t\tsession = session_new();\n\t\tfor (xmlAttrPtr attr = root->properties; attr; attr = attr->next) {\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"uid\"))\n\t\t\t\tsession->uid = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"sessionid\"))\n\t\t\t\tsession->sessionid = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"token\"))\n\t\t\t\tsession->token = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"privatekeyenc\")) {\n\t\t\t\t_cleanup_free_ char *private_key = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t\tsession_set_private_key(session, key, private_key);\n\t\t\t}\n\n\t\t\tfeature_flag_load_xml_attr(&session->feature_flag, doc, attr);\n\t\t}\n\t}\nout:\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\tif (!session_is_valid(session)) {\n\t\tsession_free(session);\n\t\treturn NULL;\n\t}\n\treturn session;\n}\n\nunsigned long long xml_login_check(const char *buf, struct session *session)\n{\n\t_cleanup_free_ char *versionstr = NULL;\n\tunsigned long long version = 0;\n\txmlDoc *doc = NULL;\n\txmlNode *root, *child = NULL;\n\n\tdoc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\tgoto out;\n\n\troot = xmlDocGetRootElement(doc);\n\tif (root && !xmlStrcmp(root->name, BAD_CAST \"response\")) {\n\t\tfor (child = root->children; child; child = child->next) {\n\t\t\tif (!xmlStrcmp(child->name, BAD_CAST \"ok\"))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (child) {\n\t\tfor (xmlAttrPtr attr = child->properties; attr; attr = attr->next) {\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"uid\")) {\n\t\t\t\tfree(session->uid);\n\t\t\t\tsession->uid = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t} else if (!xmlStrcmp(attr->name, BAD_CAST \"sessionid\")) {\n\t\t\t\tfree(session->sessionid);\n\t\t\t\tsession->sessionid = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t} else if (!xmlStrcmp(attr->name, BAD_CAST \"token\")) {\n\t\t\t\tfree(session->token);\n\t\t\t\tsession->token = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t} else if (!xmlStrcmp(attr->name, BAD_CAST \"accts_version\")) {\n\t\t\t\tversionstr = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t\tversion = strtoull(versionstr, NULL, 10);\n\t\t\t}\n\n\t\t\tfeature_flag_load_xml_attr(&session->feature_flag, doc, attr);\n\t\t}\n\t}\nout:\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\treturn version;\n}\n\nchar *xml_error_cause(const char *buf, const char *what)\n{\n\tchar *result = NULL;\n\txmlDoc *doc = NULL;\n\txmlNode *root;\n\n\tdoc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\tgoto out;\n\n\troot = xmlDocGetRootElement(doc);\n\tif (root && !xmlStrcmp(root->name, BAD_CAST \"response\")) {\n\t\tfor (xmlNode *child = root->children; child; child = child->next) {\n\t\t\tif (!xmlStrcmp(child->name, BAD_CAST \"error\")) {\n\t\t\t\tfor (xmlAttrPtr attr = child->properties; attr; attr = attr->next) {\n\t\t\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST what)) {\n\t\t\t\t\t\tresult = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\tif (!result)\n\t\tresult = xstrdup(\"unknown\");\n\n\treturn result;\n}\n\n/*\n * Check if node has the tag \"name\", and interpret as a string\n * if so.\n *\n * Return true and update the string pointed to by ptr if the node\n * matches name.\n */\nstatic bool\nxml_parse_str(xmlDoc *doc, xmlNode *parent, const char *name, char **ptr)\n{\n\tif (xmlStrcmp(parent->name, BAD_CAST name))\n\t\treturn false;\n\n\t*ptr = (char *) xmlNodeListGetString(doc, parent->xmlChildrenNode, 1);\n\tif (!*ptr)\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Check if node has the tag \"name\", and interpret as an int if so.\n *\n * Return true and update the int pointed to by ptr if the node\n * matches name.\n */\nstatic bool\nxml_parse_int(xmlDoc *doc, xmlNode *parent, const char *name, int *ptr)\n{\n\tif (xmlStrcmp(parent->name, BAD_CAST name))\n\t\treturn false;\n\n\t_cleanup_free_ char *str = (char *)\n\t\txmlNodeListGetString(doc, parent->xmlChildrenNode, 1);\n\n\tif (!str)\n\t\treturn false;\n\n\t*ptr = atoi(str);\n\treturn true;\n}\n\n/*\n * Check if node is for the boolean \"name\", and interpret as a boolean\n * if so.\n *\n * Return true and update the boolean pointed to by ptr if the node\n * matches name.\n */\nstatic bool\nxml_parse_bool(xmlDoc *doc, xmlNode *parent, const char *name, bool *ptr)\n{\n\tint intval;\n\n\tif (!xml_parse_int(doc, parent, name, &intval))\n\t\treturn false;\n\n\t*ptr = intval;\n\treturn true;\n}\n\nstatic void\nxml_parse_share_permissions(xmlDoc *doc, xmlNode *item, struct share_user *user)\n{\n\tbool tmp;\n\n\tfor (xmlNode *child = item->children; child; child = child->next) {\n\t\tif (xml_parse_bool(doc, child, \"canadminister\", &user->admin))\n\t\t\tcontinue;\n\t\tif (xml_parse_bool(doc, child, \"readonly\", &user->read_only))\n\t\t\tcontinue;\n\t\tif (xml_parse_bool(doc, child, \"give\", &tmp)) {\n\t\t\tuser->hide_passwords = !tmp;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic void\nxml_parse_share_user(xmlDoc *doc, xmlNode *item, struct share_user *user)\n{\n\tchar *tmp;\n\n\t/* process a user item */\n\tfor (xmlNode *child = item->children; child; child = child->next) {\n\t\tif (xml_parse_str(doc, child, \"realname\", &user->realname))\n\t\t\tcontinue;\n\t\tif (xml_parse_str(doc, child, \"username\", &user->username))\n\t\t\tcontinue;\n\t\tif (xml_parse_str(doc, child, \"uid\", &user->uid))\n\t\t\tcontinue;\n\t\tif (xml_parse_bool(doc, child, \"group\", &user->is_group))\n\t\t\tcontinue;\n\t\tif (xml_parse_bool(doc, child, \"outsideenterprise\", &user->outside_enterprise))\n\t\t\tcontinue;\n\t\tif (xml_parse_bool(doc, child, \"accepted\", &user->accepted))\n\t\t\tcontinue;\n\t\tif (xml_parse_str(doc, child, \"sharingkey\", &tmp)) {\n\t\t\tint ret = hex_to_bytes(tmp, &user->sharing_key.key);\n\t\t\tif (ret == 0)\n\t\t\t\tuser->sharing_key.len = strlen(tmp) / 2;\n\t\t\tfree(tmp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!xmlStrcmp(child->name, BAD_CAST \"permissions\"))\n\t\t\txml_parse_share_permissions(doc, child, user);\n\t}\n}\n\nstatic int\nxml_parse_share_key_entry(xmlDoc *doc, xmlNode *root,\n\t\t\t  struct share_user *user, int idx)\n{\n\tchar *tmp;\n\n\t_cleanup_free_ char *pubkey = NULL;\n\t_cleanup_free_ char *username = NULL;\n\t_cleanup_free_ char *uid = NULL;\n\t_cleanup_free_ char *cgid = NULL;\n\n\txasprintf(&pubkey, \"pubkey%d\", idx);\n\txasprintf(&username, \"username%d\", idx);\n\txasprintf(&uid, \"uid%d\", idx);\n\txasprintf(&cgid, \"cgid%d\", idx);\n\n\tmemset(user, 0, sizeof(*user));\n\n\tfor (xmlNode *item = root->children; item; item = item->next) {\n\t\tif (xml_parse_str(doc, item, pubkey, &tmp)) {\n\t\t\tint ret = hex_to_bytes(tmp, &user->sharing_key.key);\n\t\t\tif (ret == 0)\n\t\t\t\tuser->sharing_key.len = strlen(tmp) / 2;\n\t\t\tfree(tmp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (xml_parse_str(doc, item, username, &user->username))\n\t\t\tcontinue;\n\t\tif (xml_parse_str(doc, item, uid, &user->uid))\n\t\t\tcontinue;\n\t\tif (xml_parse_str(doc, item, cgid, &user->cgid))\n\t\t\tcontinue;\n\t}\n\n\tif (!user->uid) {\n\t\tfree(user->cgid);\n\t\tfree(user->username);\n\t\tfree(user->sharing_key.key);\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\n\nint xml_parse_share_getinfo(const char *buf, struct list_head *users)\n{\n\tint ret;\n\txmlDoc *doc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * XML fields are as follows:\n\t * xmlresponse\n\t *   users\n\t *     item\n\t *       realname\n\t *       uid\n\t *       group\n\t *       username\n\t *       permissions\n\t *         readonly\n\t *         canadminister\n\t *         give\n\t *       outsideenterprise\n\t *       accepted\n\t *     item...\n\t */\n\txmlNode *root = xmlDocGetRootElement(doc);\n\tif (!root ||\n\t    xmlStrcmp(root->name, BAD_CAST \"xmlresponse\") ||\n\t    !root->children ||\n\t    xmlStrcmp(root->children->name, BAD_CAST \"users\")) {\n\t\tret = -EINVAL;\n\t\tgoto free_doc;\n\t}\n\n\txmlNode *usernode = root->children;\n\tfor (xmlNode *item = usernode->children; item; item = item->next) {\n\t\tif (xmlStrcmp(item->name, BAD_CAST \"item\"))\n\t\t\tcontinue;\n\n\t\tstruct share_user *new_user = xcalloc(1, sizeof(*new_user));\n\t\txml_parse_share_user(doc, item, new_user);\n\t\tlist_add_tail(&new_user->list, users);\n\t}\n\tret = 0;\nfree_doc:\n\txmlFreeDoc(doc);\n\treturn ret;\n}\n\nint xml_parse_share_getpubkeys(const char *buf, struct list_head *user_list)\n{\n\tint ret;\n\txmlDoc *doc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * XML fields are as follows:\n\t * xmlresponse\n\t *   success\n\t *   pubkey0\n\t *   uid0\n\t *   username0\n\t *   cgid0 (if group)\n\t */\n\txmlNode *root = xmlDocGetRootElement(doc);\n\tif (!root || xmlStrcmp(root->name, BAD_CAST \"xmlresponse\") ||\n\t    !root->children) {\n\t\tret = -EINVAL;\n\t\tgoto free_doc;\n\t}\n\n\tfor (int count = 0; ; count++) {\n\t\tstruct share_user *user = new0(struct share_user, 1);\n\t\tret = xml_parse_share_key_entry(doc, root, user, count);\n\t\tif (ret) {\n\t\t\tfree(user);\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&user->list, user_list);\n\t}\n\tif (list_empty(user_list))\n\t\tret = -ENOENT;\n\telse\n\t\tret = 0;\nfree_doc:\n\txmlFreeDoc(doc);\n\treturn ret;\n}\n\nstatic\nint xml_parse_su_key_entry(xmlDoc *doc, xmlNode *parent,\n\t\t\t   struct pwchange_su_key *su_key, int idx)\n{\n\tchar *tmp;\n\t_cleanup_free_ char *pubkey = NULL;\n\t_cleanup_free_ char *uid = NULL;\n\n\txasprintf(&pubkey, \"sukey%d\", idx);\n\txasprintf(&uid, \"suuid%d\", idx);\n\n\tmemset(su_key, 0, sizeof(*su_key));\n\tfor (xmlAttrPtr attr = parent->properties; attr; attr = attr->next) {\n\t\tif (!xmlStrcmp(attr->name, BAD_CAST pubkey)) {\n\t\t\ttmp = (char *) xmlNodeListGetString(doc, attr->children, 1);\n\t\t\tint ret = hex_to_bytes(tmp, &su_key->sharing_key.key);\n\t\t\tif (ret == 0)\n\t\t\t\tsu_key->sharing_key.len = strlen(tmp) / 2;\n\t\t\tfree(tmp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!xmlStrcmp(attr->name, BAD_CAST uid)) {\n\t\t\ttmp = (char *) xmlNodeListGetString(doc, attr->children, 1);\n\t\t\tsu_key->uid = tmp;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (!su_key->sharing_key.len || !su_key->uid) {\n\t\tfree(su_key->uid);\n\t\tfree(su_key->sharing_key.key);\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic\nint xml_parse_pwchange_su_keys(xmlDoc *doc, xmlNode *parent,\n\t\t\t       struct pwchange_info *info)\n{\n\tfor (int count = 0; ; count++) {\n\t\tstruct pwchange_su_key *su_key = new0(struct pwchange_su_key,1);\n\t\tint ret = xml_parse_su_key_entry(doc, parent, su_key, count);\n\t\tif (ret) {\n\t\t\tfree(su_key);\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&su_key->list, &info->su_keys);\n\t}\n\treturn 0;\n}\n\nstatic\nint xml_parse_pwchange_data(char *data, struct pwchange_info *info)\n{\n\tchar *token, *end;\n\tstruct pwchange_field *field;\n\n\t/*\n\t * read the first two lines without strtok: in case there are\n\t * empty lines we don't want to skip them.\n\t */\n#define next_line(x) { \\\n\tend = strchr(data, '\\n'); \\\n\tif (!end) \\\n\t\treturn -ENOENT; \\\n\t*end++ = 0; \\\n\tinfo->x = xstrdup(data); \\\n\tdata = end; \\\n}\n\tnext_line(reencrypt_id);\n\tnext_line(privkey_encrypted);\n\n#undef next_line\n\n\tfor (token = strtok(data, \"\\n\"); token; token = strtok(NULL, \"\\n\")) {\n\n\t\tif (!strncmp(token, \"endmarker\", 9))\n\t\t\tbreak;\n\n\t\tfield = new0(struct pwchange_field, 1);\n\n\t\tchar *delim = strchr(token, '\\t');\n\t\tif (delim) {\n\t\t\t*delim = 0;\n\t\t\tfield->optional = *(delim + 1) == '0';\n\t\t}\n\t\tfield->old_ctext = xstrdup(token);\n\t\tlist_add_tail(&field->list, &info->fields);\n\t}\n\treturn 0;\n}\n\nint xml_api_err(const char *buf)\n{\n\tint ret;\n\txmlDoc *doc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\txmlNode *root = xmlDocGetRootElement(doc);\n\tif (!root || xmlStrcmp(root->name, BAD_CAST \"lastpass\") ||\n\t\t\t       !root->children) {\n\t\tret = -EINVAL;\n\t\tgoto free_doc;\n\t}\n\n\tfor (xmlAttrPtr attr = root->properties; attr; attr = attr->next) {\n\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"rc\")) {\n\t\t\t_cleanup_free_ char *val = (char *)\n\t\t\t\txmlNodeListGetString(doc, attr->children, 1);\n\t\t\tif (strcmp(val, \"OK\") != 0) {\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto free_doc;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nfree_doc:\n\txmlFreeDoc(doc);\n\treturn ret;\n}\n\nint xml_parse_pwchange(const char *buf, struct pwchange_info *info)\n{\n\tint ret;\n\txmlDoc *doc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tINIT_LIST_HEAD(&info->fields);\n\tINIT_LIST_HEAD(&info->su_keys);\n\n\txmlNode *root = xmlDocGetRootElement(doc);\n\tif (!root || xmlStrcmp(root->name, BAD_CAST \"lastpass\") ||\n\t\t\t       !root->children) {\n\t\tret = -EINVAL;\n\t\tgoto free_doc;\n\t}\n\n\tfor (xmlAttrPtr attr = root->properties; attr; attr = attr->next) {\n\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"rc\")) {\n\t\t\t_cleanup_free_ char *val = (char *)\n\t\t\t\txmlNodeListGetString(doc, attr->children, 1);\n\t\t\tif (strcmp(val, \"OK\") != 0) {\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto free_doc;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (xmlNode *item = root->children; item; item = item->next) {\n\t\tif (xmlStrcmp(item->name, BAD_CAST \"data\"))\n\t\t\tcontinue;\n\n\t\tfor (xmlAttrPtr attr = item->properties; attr; attr = attr->next) {\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"xml\")) {\n\t\t\t\t_cleanup_free_ char *data = (char *)\n\t\t\t\t\txmlNodeListGetString(doc, attr->children, 1);\n\n\t\t\t\tret = xml_parse_pwchange_data(data, info);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto free_doc;\n\t\t\t}\n\t\t\tif (!xmlStrcmp(attr->name, BAD_CAST \"token\"))\n\t\t\t\tinfo->token = (char *)xmlNodeListGetString(doc, attr->children, 1);\n\t\t}\n\t\txml_parse_pwchange_su_keys(doc, item, info);\n\t}\n\n\tret = 0;\nfree_doc:\n\txmlFreeDoc(doc);\n\treturn ret;\n}\n\nint xml_parse_share_getpubkey(const char *buf, struct share_user *user)\n{\n\tstruct list_head users;\n\tstruct share_user *share_user, *tmp;\n\tint ret;\n\n\tINIT_LIST_HEAD(&users);\n\tret = xml_parse_share_getpubkeys(buf, &users);\n\tif (ret)\n\t\treturn ret;\n\n\tif (list_empty(&users))\n\t\treturn -ENOENT;\n\n\tshare_user = list_first_entry(&users, struct share_user, list);\n\t*user = *share_user;\n\n\tlist_for_each_entry_safe(share_user, tmp, &users, list)\n\t\tfree(share_user);\n\n\treturn 0;\n}\n\nstatic\nvoid xml_parse_share_limit_aids(xmlDoc *doc, xmlNode *parent,\n\t\t\t\tstruct list_head *list)\n{\n\tfor (xmlNode *item = parent->children; item; item = item->next) {\n\t\tif (xmlStrncmp(item->name, BAD_CAST \"aid\", 3))\n\t\t\tcontinue;\n\n\t\tstruct share_limit_aid *aid = new0(struct share_limit_aid, 1);\n\n\t\taid->aid = (char *) xmlNodeListGetString(doc,\n\t\t\t\titem->xmlChildrenNode, 1);\n\n\t\tlist_add_tail(&aid->list, list);\n\t}\n}\n\nint xml_parse_share_get_limits(const char *buf, struct share_limit *limit)\n{\n\tint ret;\n\n\tmemset(limit, 0, sizeof(*limit));\n\tINIT_LIST_HEAD(&limit->aid_list);\n\n\txmlDoc *doc = xmlReadMemory(buf, strlen(buf), NULL, NULL, 0);\n\n\tif (!doc)\n\t\treturn -EINVAL;\n\n\txmlNode *root = xmlDocGetRootElement(doc);\n\tif (!root || xmlStrcmp(root->name, BAD_CAST \"xmlresponse\") ||\n\t    !root->children) {\n\t\tret = -EINVAL;\n\t\tgoto free_doc;\n\t}\n\n\tfor (xmlNode *item = root->children; item; item = item->next) {\n\t\tif (xml_parse_bool(doc, item, \"hidebydefault\",\n\t\t\t\t   &limit->whitelist))\n\t\t\tcontinue;\n\n\t\tif (!xmlStrcmp(item->name, BAD_CAST \"aids\")) {\n\t\t\txml_parse_share_limit_aids(doc, item, &limit->aid_list);\n\t\t}\n\t}\n\tret = 0;\nfree_doc:\n\txmlFreeDoc(doc);\n\treturn ret;\n}\n"
        },
        {
          "name": "xml.h",
          "type": "blob",
          "size": 0.72265625,
          "content": "#ifndef XML_H\n#define XML_H\n\n#include \"session.h\"\n#include \"cipher.h\"\n#include \"list.h\"\n#include \"blob.h\"\n\nstruct session *xml_ok_session(const char *buf, unsigned const char key[KDF_HASH_LEN]);\nchar *xml_error_cause(const char *buf, const char *what);\nunsigned long long xml_login_check(const char *buf, struct session *session);\nint xml_parse_share_getinfo(const char *buf, struct list_head *users);\nint xml_parse_share_getpubkey(const char *buf, struct share_user *user);\nint xml_parse_pwchange(const char *buf, struct pwchange_info *info);\nint xml_api_err(const char *buf);\nint xml_parse_share_getpubkeys(const char *buf, struct list_head *user_list);\nint xml_parse_share_get_limits(const char *buf, struct share_limit *limit);\n\n#endif\n"
        }
      ]
    }
  ]
}