{
  "metadata": {
    "timestamp": 1736709691579,
    "page": 61,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "RandyGaul/cute_headers",
      "stars": 4364,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0224609375,
          "content": "*.h linguist-language=C"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1142578125,
          "content": "# macOS\n.DS_Store\n\n# Executables\nexample\ntests\nexamples_cute_sound/sdl_demo/sdl_demo\n\n# vim\n*.swp\n*.swo\n*.swn\n*.orig\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0830078125,
          "content": "[submodule \"player2d\"]\n\tpath = player2d\n\turl = https://github.com/RandyGaul/player2d\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.3515625,
          "content": "# cute_headers\n\nVarious single-file cross-platform C/C++ headers implementing self-contained libraries.\n\n| library | description | latest version| language(s)\n|---------|-------------|---------------|-------------\n**[cute_c2](cute_c2.h)** | 2D collision detection routines on primitives, boolean results and/or manifold generation, shape cast/sweep test, raycasts | 1.10 | C/C++\n**[cute_net](cute_net.h)** | Networking library for games requiring an optional reliability layer over UDP with a baked in security scheme | 1.03 | C/C++\n**[cute_tiled](cute_tiled.h)** | Very efficient loader for Tiled maps exported to JSON format | 1.07 | C/C++\n**[cute_aseprite](cute_aseprite.h)** | Parses .ase/.aseprite files into a compact and convenient struct collection | 1.04 | C/C++\n**[cute_sound](cute_sound.h)** | Load/play/loop (with plugin)/pan WAV + OGG (stb_vorbis wrapper for OGG) in mono/stereo, high performance custom mixer, music + crossfade support | 2.08 | C/C++\n**[cute_math](cute_math.h)** | Professional level 3D vector math via SSE intrinsics | 1.02 | C++\n**[cute_png](cute_png.h)** | load/save PNG, texture atlas compiler, DEFLATE compliant decompressor | 1.05 | C/C++\n**[cute_spritebatch](cute_spritebatch.h)** | Run-time 2d sprite batcher. Builds atlases on-the-fly in-memory. Useful to implement a sprite batcher for any purpose (like 2D games) for high-performance rendering, without the need to precompile texture atlases on-disk. | 1.06 | C/C++\n**[cute_sync](cute_sync.h)** | Collection of practical synchronization primitives, including read/write lock and threadpool/task system | 1.01 | C/C++\n**[cute_tls](cute_tls.h)** | Create a TLS connection to a website over TCP, useful for HTTPS requests. | 1.01 | C/C++/Obj-C\n\nHow to Use\n----------\n\nGenerally these headers do not have dependencies and are intended to be included directly into your source (check each header for specific documentation at the top of the file). Each header has a LIBNAME_IMPLEMENTATION symbol; add this to a single translation unit in your code and include the header right after in order to define library symbols. Just include the header as normal otherwise.\n\nExamples and Tests\n------------------\n\nSome headers also have example code or demos. In this repo just look for the corresponding examples or tests folders. The example folders are particularly useful for figuring out how to use a particular header.\n\nContact\n-------\n\nHere's a link to the discord chat for cute_headers. Feel free to pop in and ask questions, make suggestions, or have a discussion. If anyone has used cute_headers it would be great to hear your experience! https://discord.gg/2DFHRmX\n\nAnother easy way to get a hold of me is on twitter [@randypgaul](https://twitter.com/RandyPGaul).\n\nFAQ\n---\n\n> - *What's the point of making a single file? Why is there implementation and static functions in the headers?*\n\nIncluding these headers is like including a normal header. However, to define the implementation each header looks something like this:\n\n```c\n// Do this ONCE in a .c/.cpp file\n#define LIBNAME_IMPLEMENTATION\n#include \"libname.h\"\n\n// Everywhere else, just include like a typical header\n#include \"libname.h\"\n```\n\nThis will turn the file into a header + c file combo, one time. The point of this is: A) handling the header or sending it to people is easy, no zip files or anything just copy and paste a single file; B) build scripts are a pain in the ass, and these single-file libs can be integrated into any project without modifying a single build script.\n\n> - *Doesn't writing all the code in a header ruin compile times?*\n\nThe stigma that header implementations slow compile time come from inline'd code and template spam. In either case every single [translation unit](https://en.wikipedia.org/wiki/Translation_unit_(programming)) must churn through the header and place inline versions of functions, or for templates generate various type-specific functions. It gets worse once the linker kicks in and needs to coalesce translation units together, deleting duplicated symbols. Often linkers are single-threaded tasks and can really bottleneck build times.\n\nA well constructed single-file header will not use any templates and make use of inline sparingly. Additionally well constructed single-file headers use a #define to place implementation (the function definitions and symbols) into a **single** translation unit. In this way a well crafted single-file header is pretty much the best thing a C compiler can come across, as far as build times go. Especially when the header can optionally #define out unneeded features.\n\n> - *Aren't these header only libraries just a new fad?*\n\nI personally don't really know if it's a fad or not, but these files aren't really just headers. They are headers with the .C file part (the implementation) attached to the end. It's two different files stuck together with the C preprocessor, but the implementation part never shows up unless the user does #define LIB_IMPLEMENTATION. This define step is the only integration step required to use these headers.\n\nUnfortunately writing a good header library is pretty hard, so just any random header lib out there in the wild is probably not a good one. The [STB](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwihsabx0qHSAhVX0WMKHVnyAZ0QFggaMAA&url=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb&usg=AFQjCNHkcM-rQ-cn3VbNhQZ3lnwpnSrCWQ&sig2=bg0yIt7IhNkQy6_nMcuYZw&bvm=bv.147448319,d.cGc) and [RJM](https://github.com/rmitton/rjm) are pretty good header libs, and are a good reference to get an idea at what a good header lib looks like. [Mattias Gustavsson](https://github.com/mattiasgustavsson/libs) has my favorite collection of headers.\n\n> - *What is the license?*\n\nEach lib contains license info at the end of the file. There is a choice between public domain, and zlib.\n\n> - *I was looking for a header I've seen before, but it's missing. Where did it go?*\n\nSome of the unpopular or not so useful headers became deprecated, and [live here now](https://github.com/RandyGaul/cute_headers_deprecated).\n\n> - *Do you have any higher level libraries? These seem a bit too low-level.\n\nThe cute headers are indeed rather low-level. They solve specific problems. If you're looking for a higher level game creation framework I suggestion trying out [Cute Framework](https://github.com/RandyGaul/cute_framework), a 2D game creation framework built largely on-top of the various low-level cute headers seen here.\n"
        },
        {
          "name": "cute_aseprite.h",
          "type": "blob",
          "size": 39.501953125,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_aseprite.h - v1.04\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_ASEPRITE_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY\n\n\t\tcute_aseprite.h is a single-file header that implements some functions to\n\t\tparse .ase/.aseprite files. The entire file is parsed all at once and some\n\t\tstructs are filled out then handed back to you.\n\n\n\tLIMITATIONS\n\n\t\tOnly the \"normal\" blend mode for layers is supported. As a workaround try\n\t\tusing the \"merge down\" function in Aseprite to create a normal layer.\n\t\tSupporting all blend modes would take too much code to be worth it.\n\n\t\tDoes not support very old versions of Aseprite (with old palette chunks\n\t\t0x0004 or 0x0011). Also does not support deprecrated mask chunk.\n\n\t\tsRGB and ICC profiles are parsed but completely ignored when blending\n\t\tframes together. If you want these to be used when composing frames you\n\t\thave to do this yourself.\n\n\n\tSPECIAL THANKS\n\n\t\tSpecial thanks to Noel Berry for the blend code in his reference C++\n\t\timplementation (https://github.com/NoelFB/blah).\n\n\t\tSpecial thanks to Richard Mitton for the initial implementation of the\n\t\tzlib inflater.\n\n\n\tRevision history:\n\t\t1.00 (08/25/2020) initial release\n\t\t1.01 (08/31/2020) fixed memleaks, tag parsing bug (crash), blend bugs\n\t\t1.02 (02/05/2022) fixed icc profile parse bug, support transparent pal-\n\t\t                  ette index, can parse 1.3 files (no tileset support)\n\t\t1.03 (11/27/2023) fixed slice pivot parse bug\n  \t\t1.04 (02/20/2024) chunck 0x0004 support\n*/\n\n/*\n\tDOCUMENTATION\n\n\t\tSimply load an .ase or .aseprite file from disk or from memory like so.\n\n\t\t\tase_t* ase = cute_aseprite_load_from_file(\"data/player.aseprite\", NULL);\n\n\n\t\tThen access the fields directly, assuming you have your own `Animation` type.\n\n\t\t\tint w = ase->w;\n\t\t\tint h = ase->h;\n\t\t\tAnimation anim = { 0 }; // Your custom animation data type.\n\n\t\t\tfor (int i = 0; i < ase->frame_count; ++i) {\n\t\t\t\tase_frame_t* frame = ase->frames + i;\n\t\t\t\tanim.add_frame(frame->duration_milliseconds, frame->pixels);\n\t\t\t}\n\n\n\t\tThen free it up when done.\n\n\t\t\tcute_aseprite_free(ase);\n\n\n\tDATA STRUCTURES\n\n\t\tAseprite files have frames, layers, and cels. A single frame is one frame of an\n\t\tanimation, formed by blending all the cels of an animation together. There is\n\t\tone cel per layer per frame. Each cel contains its own pixel data.\n\n\t\tThe frame's pixels are automatically assumed to have been blended by the `normal`\n\t\tblend mode. A warning is emit if any other blend mode is encountered. Feel free\n\t\tto update the pixels of each frame with your own implementation of blending\n\t\tfunctions. The frame's pixels are merely provided like this for convenience.\n\n\n\tBUGS AND CRASHES\n\n\t\tThis header is quite new and it takes time to test all the parse paths. Don't be\n\t\tshy about opening a GitHub issue if there's a crash! It's quite easy to update\n\t\tthe parser as long as you upload your .ase file that shows the bug.\n\n\t\thttps://github.com/RandyGaul/cute_headers/issues\n*/\n\n#ifndef CUTE_ASEPRITE_H\n#define CUTE_ASEPRITE_H\n\ntypedef struct ase_t ase_t;\n\nase_t* cute_aseprite_load_from_file(const char* path, void* mem_ctx);\nase_t* cute_aseprite_load_from_memory(const void* memory, int size, void* mem_ctx);\nvoid cute_aseprite_free(ase_t* aseprite);\n\n#define CUTE_ASEPRITE_MAX_LAYERS (64)\n#define CUTE_ASEPRITE_MAX_SLICES (128)\n#define CUTE_ASEPRITE_MAX_PALETTE_ENTRIES (1024)\n#define CUTE_ASEPRITE_MAX_TAGS (256)\n\n#include <stdint.h>\n\ntypedef struct ase_color_t ase_color_t;\ntypedef struct ase_frame_t ase_frame_t;\ntypedef struct ase_layer_t ase_layer_t;\ntypedef struct ase_cel_t ase_cel_t;\ntypedef struct ase_tag_t ase_tag_t;\ntypedef struct ase_slice_t ase_slice_t;\ntypedef struct ase_palette_entry_t ase_palette_entry_t;\ntypedef struct ase_palette_t ase_palette_t;\ntypedef struct ase_udata_t ase_udata_t;\ntypedef struct ase_cel_extra_chunk_t ase_cel_extra_chunk_t;\ntypedef struct ase_color_profile_t ase_color_profile_t;\ntypedef struct ase_fixed_t ase_fixed_t;\n\nstruct ase_color_t\n{\n\tuint8_t r, g, b, a;\n};\n\nstruct ase_fixed_t\n{\n\tuint16_t a;\n\tuint16_t b;\n};\n\nstruct ase_udata_t\n{\n\tint has_color;\n\tase_color_t color;\n\tint has_text;\n\tconst char* text;\n};\n\ntypedef enum ase_layer_flags_t\n{\n\tASE_LAYER_FLAGS_VISIBLE            = 0x01,\n\tASE_LAYER_FLAGS_EDITABLE           = 0x02,\n\tASE_LAYER_FLAGS_LOCK_MOVEMENT      = 0x04,\n\tASE_LAYER_FLAGS_BACKGROUND         = 0x08,\n\tASE_LAYER_FLAGS_PREFER_LINKED_CELS = 0x10,\n\tASE_LAYER_FLAGS_COLLAPSED          = 0x20,\n\tASE_LAYER_FLAGS_REFERENCE          = 0x40,\n} ase_layer_flags_t;\n\ntypedef enum ase_layer_type_t\n{\n\tASE_LAYER_TYPE_NORMAL,\n\tASE_LAYER_TYPE_GROUP,\n} ase_layer_type_t;\n\nstruct ase_layer_t\n{\n\tase_layer_flags_t flags;\n\tase_layer_type_t type;\n\tconst char* name;\n\tase_layer_t* parent;\n\tfloat opacity;\n\tase_udata_t udata;\n};\n\nstruct ase_cel_extra_chunk_t\n{\n\tint precise_bounds_are_set;\n\tase_fixed_t precise_x;\n\tase_fixed_t precise_y;\n\tase_fixed_t w, h;\n};\n\nstruct ase_cel_t\n{\n\tase_layer_t* layer;\n\tvoid* pixels;\n\tint w, h;\n\tint x, y;\n\tfloat opacity;\n\tint is_linked;\n\tuint16_t linked_frame_index;\n\tint has_extra;\n\tase_cel_extra_chunk_t extra;\n\tase_udata_t udata;\n};\n\nstruct ase_frame_t\n{\n\tase_t* ase;\n\tint duration_milliseconds;\n\tase_color_t* pixels;\n\tint cel_count;\n\tase_cel_t cels[CUTE_ASEPRITE_MAX_LAYERS];\n};\n\ntypedef enum ase_animation_direction_t\n{\n\tASE_ANIMATION_DIRECTION_FORWARDS,\n\tASE_ANIMATION_DIRECTION_BACKWORDS,\n\tASE_ANIMATION_DIRECTION_PINGPONG,\n} ase_animation_direction_t;\n\nstruct ase_tag_t\n{\n\tint from_frame;\n\tint to_frame;\n\tase_animation_direction_t loop_animation_direction;\n\tint repeat;\n\tuint8_t r, g, b;\n\tconst char* name;\n\tase_udata_t udata;\n};\n\nstruct ase_slice_t\n{\n\tconst char* name;\n\tint frame_number;\n\tint origin_x;\n\tint origin_y;\n\tint w, h;\n\n\tint has_center_as_9_slice;\n\tint center_x;\n\tint center_y;\n\tint center_w;\n\tint center_h;\n\n\tint has_pivot;\n\tint pivot_x;\n\tint pivot_y;\n\n\tase_udata_t udata;\n};\n\nstruct ase_palette_entry_t\n{\n\tase_color_t color;\n\tconst char* color_name;\n};\n\nstruct ase_palette_t\n{\n\tint entry_count;\n\tase_palette_entry_t entries[CUTE_ASEPRITE_MAX_PALETTE_ENTRIES];\n};\n\ntypedef enum ase_color_profile_type_t\n{\n\tASE_COLOR_PROFILE_TYPE_NONE,\n\tASE_COLOR_PROFILE_TYPE_SRGB,\n\tASE_COLOR_PROFILE_TYPE_EMBEDDED_ICC,\n} ase_color_profile_type_t;\n\nstruct ase_color_profile_t\n{\n\tase_color_profile_type_t type;\n\tint use_fixed_gamma;\n\tase_fixed_t gamma;\n\tuint32_t icc_profile_data_length;\n\tvoid* icc_profile_data;\n};\n\ntypedef enum ase_mode_t\n{\n\tASE_MODE_RGBA,\n\tASE_MODE_GRAYSCALE,\n\tASE_MODE_INDEXED\n} ase_mode_t;\n\nstruct ase_t\n{\n\tase_mode_t mode;\n\tint w, h;\n\tint transparent_palette_entry_index;\n\tint number_of_colors;\n\tint pixel_w;\n\tint pixel_h;\n\tint grid_x;\n\tint grid_y;\n\tint grid_w;\n\tint grid_h;\n\tint has_color_profile;\n\tase_color_profile_t color_profile;\n\tase_palette_t palette;\n\n\tint layer_count;\n\tase_layer_t layers[CUTE_ASEPRITE_MAX_LAYERS];\n\n\tint frame_count;\n\tase_frame_t* frames;\n\n\tint tag_count;\n\tase_tag_t tags[CUTE_ASEPRITE_MAX_TAGS];\n\n\tint slice_count;\n\tase_slice_t slices[CUTE_ASEPRITE_MAX_SLICES];\n\n\tvoid* mem_ctx;\n};\n\n#endif // CUTE_ASEPRITE_H\n\n#ifdef CUTE_ASEPRITE_IMPLEMENTATION\n#ifndef CUTE_ASEPRITE_IMPLEMENTATION_ONCE\n#define CUTE_ASEPRITE_IMPLEMENTATION_ONCE\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\n\t#define _CRT_NONSTDC_NO_DEPRECATE\n#endif\n\n#if !defined(CUTE_ASEPRITE_ALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_ASEPRITE_ALLOC(size, ctx) malloc(size)\n\t#define CUTE_ASEPRITE_FREE(mem, ctx) free(mem)\n#endif\n\n#if !defined(CUTE_ASEPRITE_UNUSED)\n\t#if defined(_MSC_VER)\n\t\t#define CUTE_ASEPRITE_UNUSED(x) (void)x\n\t#else\n\t\t#define CUTE_ASEPRITE_UNUSED(x) (void)(sizeof(x))\n\t#endif\n#endif\n\n#if !defined(CUTE_ASEPRITE_MEMCPY)\n\t#include <string.h> // memcpy\n\t#define CUTE_ASEPRITE_MEMCPY memcpy\n#endif\n\n#if !defined(CUTE_ASEPRITE_MEMSET)\n\t#include <string.h> // memset\n\t#define CUTE_ASEPRITE_MEMSET memset\n#endif\n\n#if !defined(CUTE_ASEPRITE_ASSERT)\n\t#include <assert.h>\n\t#define CUTE_ASEPRITE_ASSERT assert\n#endif\n\n#if !defined(CUTE_ASEPRITE_SEEK_SET)\n\t#include <stdio.h> // SEEK_SET\n\t#define CUTE_ASEPRITE_SEEK_SET SEEK_SET\n#endif\n\n#if !defined(CUTE_ASEPRITE_SEEK_END)\n\t#include <stdio.h> // SEEK_END\n\t#define CUTE_ASEPRITE_SEEK_END SEEK_END\n#endif\n\n#if !defined(CUTE_ASEPRITE_FILE)\n\t#include <stdio.h> // FILE\n\t#define CUTE_ASEPRITE_FILE FILE\n#endif\n\n#if !defined(CUTE_ASEPRITE_FOPEN)\n\t#include <stdio.h> // fopen\n\t#define CUTE_ASEPRITE_FOPEN fopen\n#endif\n\n#if !defined(CUTE_ASEPRITE_FSEEK)\n\t#include <stdio.h> // fseek\n\t#define CUTE_ASEPRITE_FSEEK fseek\n#endif\n\n#if !defined(CUTE_ASEPRITE_FREAD)\n\t#include <stdio.h> // fread\n\t#define CUTE_ASEPRITE_FREAD fread\n#endif\n\n#if !defined(CUTE_ASEPRITE_FTELL)\n\t#include <stdio.h> // ftell\n\t#define CUTE_ASEPRITE_FTELL ftell\n#endif\n\n#if !defined(CUTE_ASEPRITE_FCLOSE)\n\t#include <stdio.h> // fclose\n\t#define CUTE_ASEPRITE_FCLOSE fclose\n#endif\n\nstatic const char* s_error_file = NULL; // The filepath of the file being parsed. NULL if from memory.\nstatic const char* s_error_reason;      // Used to capture errors during DEFLATE parsing.\n\n#if !defined(CUTE_ASEPRITE_WARNING)\n\t#define CUTE_ASEPRITE_WARNING(msg) cute_aseprite_warning(msg, __LINE__)\n\n    static int s_error_cline;               // The line in cute_aseprite.h where the error was triggered.\n\tvoid cute_aseprite_warning(const char* warning, int line)\n\t{\n\t\ts_error_cline = line;\n\t\tconst char *error_file = s_error_file ? s_error_file : \"MEMORY\";\n\t\tprintf(\"WARNING (cute_aseprite.h:%i): %s (%s)\\n\", s_error_cline, warning, error_file);\n\t}\n#endif\n\n#define CUTE_ASEPRITE_FAIL() do { goto ase_err; } while (0)\n#define CUTE_ASEPRITE_CHECK(X, Y) do { if (!(X)) { s_error_reason = Y; CUTE_ASEPRITE_FAIL(); } } while (0)\n#define CUTE_ASEPRITE_CALL(X) do { if (!(X)) goto ase_err; } while (0)\n#define CUTE_ASEPRITE_DEFLATE_MAX_BITLEN 15\n\n// DEFLATE tables from RFC 1951\nstatic uint8_t s_fixed_table[288 + 32] = {\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n\t9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n}; // 3.2.6\nstatic uint8_t s_permutation_order[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 }; // 3.2.7\nstatic uint8_t s_len_extra_bits[29 + 2] = { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,  0,0 }; // 3.2.5\nstatic uint32_t s_len_base[29 + 2] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,  0,0 }; // 3.2.5\nstatic uint8_t s_dist_extra_bits[30 + 2] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,  0,0 }; // 3.2.5\nstatic uint32_t s_dist_base[30 + 2] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 0,0 }; // 3.2.5\n\ntypedef struct deflate_t\n{\n\tuint64_t bits;\n\tint count;\n\tuint32_t* words;\n\tint word_count;\n\tint word_index;\n\tint bits_left;\n\n\tint final_word_available;\n\tuint32_t final_word;\n\n\tchar* out;\n\tchar* out_end;\n\tchar* begin;\n\n\tuint32_t lit[288];\n\tuint32_t dst[32];\n\tuint32_t len[19];\n\tuint32_t nlit;\n\tuint32_t ndst;\n\tuint32_t nlen;\n} deflate_t;\n\nstatic int s_would_overflow(deflate_t* s, int num_bits)\n{\n\treturn (s->bits_left + s->count) - num_bits < 0;\n}\n\nstatic char* s_ptr(deflate_t* s)\n{\n\tCUTE_ASEPRITE_ASSERT(!(s->bits_left & 7));\n\treturn (char*)(s->words + s->word_index) - (s->count / 8);\n}\n\nstatic uint64_t s_peak_bits(deflate_t* s, int num_bits_to_read)\n{\n\tif (s->count < num_bits_to_read)\n\t{\n\t\tif (s->word_index < s->word_count)\n\t\t{\n\t\t\tuint32_t word = s->words[s->word_index++];\n\t\t\ts->bits |= (uint64_t)word << s->count;\n\t\t\ts->count += 32;\n\t\t\tCUTE_ASEPRITE_ASSERT(s->word_index <= s->word_count);\n\t\t}\n\n\t\telse if (s->final_word_available)\n\t\t{\n\t\t\tuint32_t word = s->final_word;\n\t\t\ts->bits |= (uint64_t)word << s->count;\n\t\t\ts->count += s->bits_left;\n\t\t\ts->final_word_available = 0;\n\t\t}\n\t}\n\n\treturn s->bits;\n}\n\nstatic uint32_t s_consume_bits(deflate_t* s, int num_bits_to_read)\n{\n\tCUTE_ASEPRITE_ASSERT(s->count >= num_bits_to_read);\n\tuint32_t bits = (uint32_t)(s->bits & (((uint64_t)1 << num_bits_to_read) - 1));\n\ts->bits >>= num_bits_to_read;\n\ts->count -= num_bits_to_read;\n\ts->bits_left -= num_bits_to_read;\n\treturn bits;\n}\n\nstatic uint32_t s_read_bits(deflate_t* s, int num_bits_to_read)\n{\n\tCUTE_ASEPRITE_ASSERT(num_bits_to_read <= 32);\n\tCUTE_ASEPRITE_ASSERT(num_bits_to_read >= 0);\n\tCUTE_ASEPRITE_ASSERT(s->bits_left > 0);\n\tCUTE_ASEPRITE_ASSERT(s->count <= 64);\n\tCUTE_ASEPRITE_ASSERT(!s_would_overflow(s, num_bits_to_read));\n\ts_peak_bits(s, num_bits_to_read);\n\tuint32_t bits = s_consume_bits(s, num_bits_to_read);\n\treturn bits;\n}\n\nstatic uint32_t s_rev16(uint32_t a)\n{\n\ta = ((a & 0xAAAA) >>  1) | ((a & 0x5555) << 1);\n\ta = ((a & 0xCCCC) >>  2) | ((a & 0x3333) << 2);\n\ta = ((a & 0xF0F0) >>  4) | ((a & 0x0F0F) << 4);\n\ta = ((a & 0xFF00) >>  8) | ((a & 0x00FF) << 8);\n\treturn a;\n}\n\n// RFC 1951 section 3.2.2\nstatic uint32_t s_build(deflate_t* s, uint32_t* tree, uint8_t* lens, int sym_count)\n{\n\tint n, codes[16], first[16], counts[16] = { 0 };\n    CUTE_ASEPRITE_UNUSED(s);\n\n\t// Frequency count\n\tfor (n = 0; n < sym_count; n++) counts[lens[n]]++;\n\n\t// Distribute codes\n\tcounts[0] = codes[0] = first[0] = 0;\n\tfor (n = 1; n <= 15; ++n)\n\t{\n\t\tcodes[n] = (codes[n - 1] + counts[n - 1]) << 1;\n\t\tfirst[n] = first[n - 1] + counts[n - 1];\n\t}\n\n\tfor (uint32_t i = 0; i < (uint32_t)sym_count; ++i)\n\t{\n\t\tuint8_t len = lens[i];\n\n\t\tif (len != 0)\n\t\t{\n\t\t\tCUTE_ASEPRITE_ASSERT(len < 16);\n\t\t\tuint32_t code = (uint32_t)codes[len]++;\n\t\t\tuint32_t slot = (uint32_t)first[len]++;\n\t\t\ttree[slot] = (code << (32 - (uint32_t)len)) | (i << 4) | len;\n\t\t}\n\t}\n\n\treturn (uint32_t)first[15];\n}\n\nstatic int s_stored(deflate_t* s)\n{\n\tchar* p;\n\n\t// 3.2.3\n\t// skip any remaining bits in current partially processed byte\n\ts_read_bits(s, s->count & 7);\n\n\t// 3.2.4\n\t// read LEN and NLEN, should complement each other\n\tuint16_t LEN = (uint16_t)s_read_bits(s, 16);\n\tuint16_t NLEN = (uint16_t)s_read_bits(s, 16);\n\tuint16_t TILDE_NLEN = ~NLEN;\n\tCUTE_ASEPRITE_CHECK(LEN == TILDE_NLEN, \"Failed to find LEN and NLEN as complements within stored (uncompressed) stream.\");\n\tCUTE_ASEPRITE_CHECK(s->bits_left / 8 <= (int)LEN, \"Stored block extends beyond end of input stream.\");\n\tp = s_ptr(s);\n\tCUTE_ASEPRITE_MEMCPY(s->out, p, LEN);\n\ts->out += LEN;\n\treturn 1;\n\nase_err:\n\treturn 0;\n}\n\n// 3.2.6\nstatic int s_fixed(deflate_t* s)\n{\n\ts->nlit = s_build(s, s->lit, s_fixed_table, 288);\n\ts->ndst = s_build(0, s->dst, s_fixed_table + 288, 32);\n\treturn 1;\n}\n\nstatic int s_decode(deflate_t* s, uint32_t* tree, int hi)\n{\n\tuint64_t bits = s_peak_bits(s, 16);\n\tuint32_t search = (s_rev16((uint32_t)bits) << 16) | 0xFFFF;\n\tint lo = 0;\n\twhile (lo < hi)\n\t{\n\t\tint guess = (lo + hi) >> 1;\n\t\tif (search < tree[guess]) hi = guess;\n\t\telse lo = guess + 1;\n\t}\n\n\tuint32_t key = tree[lo - 1];\n\tuint32_t len = (32 - (key & 0xF));\n\tCUTE_ASEPRITE_ASSERT((search >> len) == (key >> len));\n\n\ts_consume_bits(s, key & 0xF);\n\treturn (key >> 4) & 0xFFF;\n}\n\n// 3.2.7\nstatic int s_dynamic(deflate_t* s)\n{\n\tuint8_t lenlens[19] = { 0 };\n\n\tuint32_t nlit = 257 + s_read_bits(s, 5);\n\tuint32_t ndst = 1 + s_read_bits(s, 5);\n\tuint32_t nlen = 4 + s_read_bits(s, 4);\n\n\tfor (uint32_t i = 0 ; i < nlen; ++i)\n\t\tlenlens[s_permutation_order[i]] = (uint8_t)s_read_bits(s, 3);\n\n\t// Build the tree for decoding code lengths\n\ts->nlen = s_build(0, s->len, lenlens, 19);\n\tuint8_t lens[288 + 32];\n\n\tfor (uint32_t n = 0; n < nlit + ndst;)\n\t{\n\t\tint sym = s_decode(s, s->len, (int)s->nlen);\n\t\tswitch (sym)\n\t\t{\n\t\tcase 16: for (uint32_t i =  3 + s_read_bits(s, 2); i; --i, ++n) lens[n] = lens[n - 1]; break;\n\t\tcase 17: for (uint32_t i =  3 + s_read_bits(s, 3); i; --i, ++n) lens[n] = 0; break;\n\t\tcase 18: for (uint32_t i = 11 + s_read_bits(s, 7); i; --i, ++n) lens[n] = 0; break;\n\t\tdefault: lens[n++] = (uint8_t)sym; break;\n\t\t}\n\t}\n\n\ts->nlit = s_build(s, s->lit, lens, (int)nlit);\n\ts->ndst = s_build(0, s->dst, lens + nlit, (int)ndst);\n\treturn 1;\n}\n\n// 3.2.3\nstatic int s_block(deflate_t* s)\n{\n\twhile (1)\n\t{\n\t\tint symbol = s_decode(s, s->lit, (int)s->nlit);\n\n\t\tif (symbol < 256)\n\t\t{\n\t\t\tCUTE_ASEPRITE_CHECK(s->out + 1 <= s->out_end, \"Attempted to overwrite out buffer while outputting a symbol.\");\n\t\t\t*s->out = (char)symbol;\n\t\t\ts->out += 1;\n\t\t}\n\n\t\telse if (symbol > 256)\n\t\t{\n\t\t\tsymbol -= 257;\n\t\t\tuint32_t length = s_read_bits(s, (int)(s_len_extra_bits[symbol])) + s_len_base[symbol];\n\t\t\tint distance_symbol = s_decode(s, s->dst, (int)s->ndst);\n\t\t\tuint32_t backwards_distance = s_read_bits(s, s_dist_extra_bits[distance_symbol]) + s_dist_base[distance_symbol];\n\t\t\tCUTE_ASEPRITE_CHECK(s->out - backwards_distance >= s->begin, \"Attempted to write before out buffer (invalid backwards distance).\");\n\t\t\tCUTE_ASEPRITE_CHECK(s->out + length <= s->out_end, \"Attempted to overwrite out buffer while outputting a string.\");\n\t\t\tchar* src = s->out - backwards_distance;\n\t\t\tchar* dst = s->out;\n\t\t\ts->out += length;\n\n\t\t\tswitch (backwards_distance)\n\t\t\t{\n\t\t\tcase 1: // very common in images\n\t\t\t\tCUTE_ASEPRITE_MEMSET(dst, *src, (size_t)length);\n\t\t\t\tbreak;\n\t\t\tdefault: while (length--) *dst++ = *src++;\n\t\t\t}\n\t\t}\n\n\t\telse break;\n\t}\n\n\treturn 1;\n\nase_err:\n\treturn 0;\n}\n\n// 3.2.3\nstatic int s_inflate(const void* in, int in_bytes, void* out, int out_bytes, void* mem_ctx)\n{\n\tCUTE_ASEPRITE_UNUSED(mem_ctx);\n\tdeflate_t* s = (deflate_t*)CUTE_ASEPRITE_ALLOC(sizeof(deflate_t), mem_ctx);\n\ts->bits = 0;\n\ts->count = 0;\n\ts->word_index = 0;\n\ts->bits_left = in_bytes * 8;\n\n\t// s->words is the in-pointer rounded up to a multiple of 4\n\tint first_bytes = (int)((((size_t)in + 3) & (size_t)(~3)) - (size_t)in);\n\ts->words = (uint32_t*)((char*)in + first_bytes);\n\ts->word_count = (in_bytes - first_bytes) / 4;\n\tint last_bytes = ((in_bytes - first_bytes) & 3);\n\n\tfor (int i = 0; i < first_bytes; ++i)\n\t\ts->bits |= (uint64_t)(((uint8_t*)in)[i]) << (i * 8);\n\n\ts->final_word_available = last_bytes ? 1 : 0;\n\ts->final_word = 0;\n\tfor(int i = 0; i < last_bytes; i++)\n\t\ts->final_word |= ((uint8_t*)in)[in_bytes - last_bytes + i] << (i * 8);\n\n\ts->count = first_bytes * 8;\n\n\ts->out = (char*)out;\n\ts->out_end = s->out + out_bytes;\n\ts->begin = (char*)out;\n\n\tint count = 0;\n\tuint32_t bfinal;\n\tdo\n\t{\n\t\tbfinal = s_read_bits(s, 1);\n\t\tuint32_t btype = s_read_bits(s, 2);\n\n\t\tswitch (btype)\n\t\t{\n\t\tcase 0: CUTE_ASEPRITE_CALL(s_stored(s)); break;\n\t\tcase 1: s_fixed(s); CUTE_ASEPRITE_CALL(s_block(s)); break;\n\t\tcase 2: s_dynamic(s); CUTE_ASEPRITE_CALL(s_block(s)); break;\n\t\tcase 3: CUTE_ASEPRITE_CHECK(0, \"Detected unknown block type within input stream.\");\n\t\t}\n\n\t\t++count;\n\t}\n\twhile (!bfinal);\n\n\tCUTE_ASEPRITE_FREE(s, mem_ctx);\n\treturn 1;\n\nase_err:\n\tCUTE_ASEPRITE_FREE(s, mem_ctx);\n\treturn 0;\n}\n\ntypedef struct ase_state_t\n{\n\tuint8_t* in;\n\tuint8_t* end;\n\tvoid* mem_ctx;\n} ase_state_t;\n\nstatic uint8_t s_read_uint8(ase_state_t* s)\n{\n\tCUTE_ASEPRITE_ASSERT(s->in <= s->end + sizeof(uint8_t));\n\tuint8_t** p = &s->in;\n\tuint8_t value = **p;\n\t++(*p);\n\treturn value;\n}\n\nstatic uint16_t s_read_uint16(ase_state_t* s)\n{\n\tCUTE_ASEPRITE_ASSERT(s->in <= s->end + sizeof(uint16_t));\n\tuint8_t** p = &s->in;\n\tuint16_t value;\n\tvalue = (*p)[0];\n\tvalue |= (((uint16_t)((*p)[1])) << 8);\n\t*p += 2;\n\treturn value;\n}\n\nstatic ase_fixed_t s_read_fixed(ase_state_t* s)\n{\n\tase_fixed_t value;\n\tvalue.a = s_read_uint16(s);\n\tvalue.b = s_read_uint16(s);\n\treturn value;\n}\n\nstatic uint32_t s_read_uint32(ase_state_t* s)\n{\n\tCUTE_ASEPRITE_ASSERT(s->in <= s->end + sizeof(uint32_t));\n\tuint8_t** p = &s->in;\n\tuint32_t value;\n\tvalue  = (*p)[0];\n\tvalue |= (((uint32_t)((*p)[1])) << 8);\n\tvalue |= (((uint32_t)((*p)[2])) << 16);\n\tvalue |= (((uint32_t)((*p)[3])) << 24);\n\t*p += 4;\n\treturn value;\n}\n\n#ifdef CUTE_ASPRITE_S_READ_UINT64\n// s_read_uint64() is not currently used.\nstatic uint64_t s_read_uint64(ase_state_t* s)\n{\n\tCUTE_ASEPRITE_ASSERT(s->in <= s->end + sizeof(uint64_t));\n\tuint8_t** p = &s->in;\n\tuint64_t value;\n\tvalue  = (*p)[0];\n\tvalue |= (((uint64_t)((*p)[1])) << 8 );\n\tvalue |= (((uint64_t)((*p)[2])) << 16);\n\tvalue |= (((uint64_t)((*p)[3])) << 24);\n\tvalue |= (((uint64_t)((*p)[4])) << 32);\n\tvalue |= (((uint64_t)((*p)[5])) << 40);\n\tvalue |= (((uint64_t)((*p)[6])) << 48);\n\tvalue |= (((uint64_t)((*p)[7])) << 56);\n\t*p += 8;\n\treturn value;\n}\n#endif\n\n#define s_read_int16(s) (int16_t)s_read_uint16(s)\n#define s_read_int32(s) (int32_t)s_read_uint32(s)\n\n#ifdef CUTE_ASPRITE_S_READ_BYTES\n// s_read_bytes() is not currently used.\nstatic void s_read_bytes(ase_state_t* s, uint8_t* bytes, int num_bytes)\n{\n\tfor (int i = 0; i < num_bytes; ++i) {\n\t\tbytes[i] = s_read_uint8(s);\n\t}\n}\n#endif\n\nstatic const char* s_read_string(ase_state_t* s)\n{\n\tint len = (int)s_read_uint16(s);\n\tchar* bytes = (char*)CUTE_ASEPRITE_ALLOC(len + 1, s->mem_ctx);\n\tfor (int i = 0; i < len; ++i) {\n\t\tbytes[i] = (char)s_read_uint8(s);\n\t}\n\tbytes[len] = 0;\n\treturn bytes;\n}\n\nstatic void s_skip(ase_state_t* ase, int num_bytes)\n{\n\tCUTE_ASEPRITE_ASSERT(ase->in <= ase->end + num_bytes);\n\tase->in += num_bytes;\n}\n\nstatic char* s_fopen(const char* path, int* size, void* mem_ctx)\n{\n\tCUTE_ASEPRITE_UNUSED(mem_ctx);\n\tchar* data = 0;\n\tCUTE_ASEPRITE_FILE* fp = CUTE_ASEPRITE_FOPEN(path, \"rb\");\n\tint sz = 0;\n\n\tif (fp) {\n\t\tCUTE_ASEPRITE_FSEEK(fp, 0, CUTE_ASEPRITE_SEEK_END);\n\t\tsz = (int)CUTE_ASEPRITE_FTELL(fp);\n\t\tCUTE_ASEPRITE_FSEEK(fp, 0, CUTE_ASEPRITE_SEEK_SET);\n\t\tdata = (char*)CUTE_ASEPRITE_ALLOC(sz + 1, mem_ctx);\n\t\tCUTE_ASEPRITE_FREAD(data, sz, 1, fp);\n\t\tdata[sz] = 0;\n\t\tCUTE_ASEPRITE_FCLOSE(fp);\n\t}\n\n\tif (size) *size = sz;\n\treturn data;\n}\n\nase_t* cute_aseprite_load_from_file(const char* path, void* mem_ctx)\n{\n\ts_error_file = path;\n\tint sz;\n\tvoid* file = s_fopen(path, &sz, mem_ctx);\n\tif (!file) {\n\t\tCUTE_ASEPRITE_WARNING(\"Unable to find map file.\");\n\t\treturn NULL;\n\t}\n\tase_t* aseprite = cute_aseprite_load_from_memory(file, sz, mem_ctx);\n\tCUTE_ASEPRITE_FREE(file, mem_ctx);\n\ts_error_file = NULL;\n\treturn aseprite;\n}\n\nstatic int s_mul_un8(int a, int b)\n{\n\tint t = (a * b) + 0x80;\n\treturn (((t >> 8) + t) >> 8);\n}\n\nstatic ase_color_t s_blend(ase_color_t src, ase_color_t dst, uint8_t opacity)\n{\n\tsrc.a = (uint8_t)s_mul_un8(src.a, opacity);\n\tint a = src.a + dst.a - s_mul_un8(src.a, dst.a);\n\tint r, g, b;\n\tif (a == 0) {\n\t\tr = g = b = 0;\n\t} else {\n\t\tr = dst.r + (src.r - dst.r) * src.a / a;\n\t\tg = dst.g + (src.g - dst.g) * src.a / a;\n\t\tb = dst.b + (src.b - dst.b) * src.a / a;\n\t}\n\tase_color_t ret = { (uint8_t)r, (uint8_t)g, (uint8_t)b, (uint8_t)a };\n\treturn ret;\n}\n\nstatic int s_min(int a, int b)\n{\n\treturn a < b ? a : b;\n}\n\nstatic int s_max(int a, int b)\n{\n\treturn a < b ? b : a;\n}\n\nstatic ase_color_t s_color(ase_t* ase, void* src, int index)\n{\n\tase_color_t result;\n\tif (ase->mode == ASE_MODE_RGBA) {\n\t\tresult = ((ase_color_t*)src)[index];\n\t} else if (ase->mode == ASE_MODE_GRAYSCALE) {\n\t\tuint8_t saturation = ((uint8_t*)src)[index * 2];\n\t\tuint8_t a = ((uint8_t*)src)[index * 2 + 1];\n\t\tresult.r = result.g = result.b = saturation;\n\t\tresult.a = a;\n\t} else {\n\t\tCUTE_ASEPRITE_ASSERT(ase->mode == ASE_MODE_INDEXED);\n\t\tuint8_t palette_index = ((uint8_t*)src)[index];\n\t\tif (palette_index == ase->transparent_palette_entry_index) {\n\t\t\tresult.r = 0;\n\t\t\tresult.g = 0;\n\t\t\tresult.b = 0;\n\t\t\tresult.a = 0;\n\t\t} else {\n\t\t\tresult = ase->palette.entries[palette_index].color;\n\t\t}\n\t}\n\treturn result;\n}\n\nase_t* cute_aseprite_load_from_memory(const void* memory, int size, void* mem_ctx)\n{\n\tase_t* ase = (ase_t*)CUTE_ASEPRITE_ALLOC(sizeof(ase_t), mem_ctx);\n\tCUTE_ASEPRITE_MEMSET(ase, 0, sizeof(*ase));\n\n\tase_state_t state = { 0, 0, 0 };\n\tase_state_t* s = &state;\n\ts->in = (uint8_t*)memory;\n\ts->end = s->in + size;\n\ts->mem_ctx = mem_ctx;\n\n\ts_skip(s, sizeof(uint32_t)); // File size.\n\tint magic = (int)s_read_uint16(s);\n\tCUTE_ASEPRITE_ASSERT(magic == 0xA5E0);\n\n\tase->frame_count = (int)s_read_uint16(s);\n\tase->w = s_read_uint16(s);\n\tase->h = s_read_uint16(s);\n\tuint16_t bpp = s_read_uint16(s) / 8;\n\tif (bpp == 4) ase->mode = ASE_MODE_RGBA;\n\telse if (bpp == 2) ase->mode = ASE_MODE_GRAYSCALE;\n\telse {\n\t\tCUTE_ASEPRITE_ASSERT(bpp == 1);\n\t\tase->mode = ASE_MODE_INDEXED;\n\t}\n\tuint32_t valid_layer_opacity = s_read_uint32(s) & 1;\n\tint speed = s_read_uint16(s);\n\ts_skip(s, sizeof(uint32_t) * 2); // Spec says skip these bytes, as they're zero'd.\n\tase->transparent_palette_entry_index = s_read_uint8(s);\n\ts_skip(s, 3); // Spec says skip these bytes.\n\tase->number_of_colors = (int)s_read_uint16(s);\n\tase->pixel_w = (int)s_read_uint8(s);\n\tase->pixel_h = (int)s_read_uint8(s);\n\tase->grid_x = (int)s_read_int16(s);\n\tase->grid_y = (int)s_read_int16(s);\n\tase->grid_w = (int)s_read_uint16(s);\n\tase->grid_h = (int)s_read_uint16(s);\n\ts_skip(s, 84); // For future use (set to zero).\n\n\tase->frames = (ase_frame_t*)CUTE_ASEPRITE_ALLOC((int)(sizeof(ase_frame_t)) * ase->frame_count, mem_ctx);\n\tCUTE_ASEPRITE_MEMSET(ase->frames, 0, sizeof(ase_frame_t) * (size_t)ase->frame_count);\n\n\tase_udata_t* last_udata = NULL;\n\tint was_on_tags = 0;\n\tint tag_index = 0;\n\n\tase_layer_t* layer_stack[CUTE_ASEPRITE_MAX_LAYERS];\n\n\t// Parse all chunks in the .aseprite file.\n\tfor (int i = 0; i < ase->frame_count; ++i) {\n\t\tase_frame_t* frame = ase->frames + i;\n\t\tframe->ase = ase;\n\t\ts_skip(s, sizeof(uint32_t)); // Frame size.\n\t\tmagic = (int)s_read_uint16(s);\n\t\tCUTE_ASEPRITE_ASSERT(magic == 0xF1FA);\n\t\tint chunk_count = (int)s_read_uint16(s);\n\t\tframe->duration_milliseconds = s_read_uint16(s);\n\t\tif (frame->duration_milliseconds == 0) frame->duration_milliseconds = speed;\n\t\ts_skip(s, 2); // For future use (set to zero).\n\t\tuint32_t new_chunk_count = s_read_uint32(s);\n\t\tif (new_chunk_count) chunk_count = (int)new_chunk_count;\n\n\t\tfor (int j = 0; j < chunk_count; ++j) {\n\t\t\tuint32_t chunk_size = s_read_uint32(s);\n\t\t\tuint16_t chunk_type = s_read_uint16(s);\n\t\t\tchunk_size -= (uint32_t)(sizeof(uint32_t) + sizeof(uint16_t));\n\t\t\tuint8_t* chunk_start = s->in;\n\n\t\t\tswitch (chunk_type) {\n\t\t\tcase 0x0004: // Old Palette chunk (used when there are no colors with alpha in the palette)\n\t\t\t{\n\t\t\t\tuint16_t nbPackets = s_read_uint16(s);\n\t\t\t\tfor (uint16_t k = 0; k < nbPackets; k++) {\n\t\t\t\t\tuint16_t maxColor = 0;\n\t\t\t\t\tuint16_t skip = (uint16_t)s_read_uint8(s);\n\t\t\t\t\tuint16_t nbColors = (uint16_t)s_read_uint8(s);\n\t\t\t\t\tif (nbColors == 0) nbColors = 256;\n\n\t\t\t\t\tfor (uint16_t l = 0; l < nbColors; l++) {\n\t\t\t\t\t\tase_palette_entry_t entry;\n\t\t\t\t\t\tentry.color.r = s_read_uint8(s);\n\t\t\t\t\t\tentry.color.g = s_read_uint8(s);\n\t\t\t\t\t\tentry.color.b = s_read_uint8(s);\n\t\t\t\t\t\tentry.color.a = 255;\n\t\t\t\t\t\tentry.color_name = NULL;\n\t\t\t\t\t\tase->palette.entries[skip + l] = entry;\n\t\t\t\t\t\tif (skip + l > maxColor) maxColor = skip + l;\n\t\t\t\t\t}\n\n\t\t\t\t\tase->palette.entry_count = maxColor+1;\n\t\t\t\t}\n\n\t\t\t}\tbreak;\n\t\t\tcase 0x2004: // Layer chunk.\n\t\t\t{\n\t\t\t\tCUTE_ASEPRITE_ASSERT(ase->layer_count < CUTE_ASEPRITE_MAX_LAYERS);\n\t\t\t\tase_layer_t* layer = ase->layers + ase->layer_count++;\n\t\t\t\tlayer->flags = (ase_layer_flags_t)s_read_uint16(s);\n\t\t\t\tlayer->type = (ase_layer_type_t)s_read_uint16(s);\n\t\t\t\tlayer->parent = NULL;\n\t\t\t\tint child_level = (int)s_read_uint16(s);\n\t\t\t\tlayer_stack[child_level] = layer;\n\t\t\t\tif (child_level) {\n\t\t\t\t\tlayer->parent = layer_stack[child_level - 1];\n\t\t\t\t}\n\t\t\t\ts_skip(s, sizeof(uint16_t)); // Default layer width in pixels (ignored).\n\t\t\t\ts_skip(s, sizeof(uint16_t)); // Default layer height in pixels (ignored).\n\t\t\t\tint blend_mode = (int)s_read_uint16(s);\n\t\t\t\tif (blend_mode) CUTE_ASEPRITE_WARNING(\"Unknown blend mode encountered.\");\n\t\t\t\tlayer->opacity = s_read_uint8(s) / 255.0f;\n\t\t\t\tif (!valid_layer_opacity) layer->opacity = 1.0f;\n\t\t\t\ts_skip(s, 3); // For future use (set to zero).\n\t\t\t\tlayer->name = s_read_string(s);\n\t\t\t\tlast_udata = &layer->udata;\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2005: // Cel chunk.\n\t\t\t{\n\t\t\t\tCUTE_ASEPRITE_ASSERT(frame->cel_count < CUTE_ASEPRITE_MAX_LAYERS);\n\t\t\t\tase_cel_t* cel = frame->cels + frame->cel_count++;\n\t\t\t\tint layer_index = (int)s_read_uint16(s);\n\t\t\t\tcel->layer = ase->layers + layer_index;\n\t\t\t\tcel->x = s_read_int16(s);\n\t\t\t\tcel->y = s_read_int16(s);\n\t\t\t\tcel->opacity = s_read_uint8(s) / 255.0f;\n\t\t\t\tint cel_type = (int)s_read_uint16(s);\n\t\t\t\ts_skip(s, 7); // For future (set to zero).\n\t\t\t\tswitch (cel_type) {\n\t\t\t\tcase 0: // Raw cel.\n\t\t\t\t\tcel->w = s_read_uint16(s);\n\t\t\t\t\tcel->h = s_read_uint16(s);\n\t\t\t\t\tcel->pixels = CUTE_ASEPRITE_ALLOC(cel->w * cel->h * bpp, mem_ctx);\n\t\t\t\t\tCUTE_ASEPRITE_MEMCPY(cel->pixels, s->in, (size_t)(cel->w * cel->h * bpp));\n\t\t\t\t\ts_skip(s, cel->w * cel->h * bpp);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Linked cel.\n\t\t\t\t\tcel->is_linked = 1;\n\t\t\t\t\tcel->linked_frame_index = s_read_uint16(s);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Compressed image cel.\n\t\t\t\t{\n\t\t\t\t\tcel->w = s_read_uint16(s);\n\t\t\t\t\tcel->h = s_read_uint16(s);\n\t\t\t\t\tint zlib_byte0 = s_read_uint8(s);\n\t\t\t\t\tint zlib_byte1 = s_read_uint8(s);\n\t\t\t\t\tint deflate_bytes = (int)chunk_size - (int)(s->in - chunk_start);\n\t\t\t\t\tvoid* pixels = s->in;\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT((zlib_byte0 & 0x0F) == 0x08); // Only zlib compression method (RFC 1950) is supported.\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT((zlib_byte0 & 0xF0) <= 0x70); // Innapropriate window size detected.\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT(!(zlib_byte1 & 0x20)); // Preset dictionary is present and not supported.\n\t\t\t\t\tint pixels_sz = cel->w * cel->h * bpp;\n\t\t\t\t\tvoid* pixels_decompressed = CUTE_ASEPRITE_ALLOC(pixels_sz, mem_ctx);\n\t\t\t\t\tint ret = s_inflate(pixels, deflate_bytes, pixels_decompressed, pixels_sz, mem_ctx);\n\t\t\t\t\tif (!ret) CUTE_ASEPRITE_WARNING(s_error_reason);\n\t\t\t\t\tcel->pixels = pixels_decompressed;\n\t\t\t\t\ts_skip(s, deflate_bytes);\n\t\t\t\t}\tbreak;\n\t\t\t\t}\n\t\t\t\tlast_udata = &cel->udata;\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2006: // Cel extra chunk.\n\t\t\t{\n\t\t\t\tase_cel_t* cel = frame->cels + frame->cel_count;\n\t\t\t\tcel->has_extra = 1;\n\t\t\t\tcel->extra.precise_bounds_are_set = (int)s_read_uint32(s);\n\t\t\t\tcel->extra.precise_x = s_read_fixed(s);\n\t\t\t\tcel->extra.precise_y = s_read_fixed(s);\n\t\t\t\tcel->extra.w = s_read_fixed(s);\n\t\t\t\tcel->extra.h = s_read_fixed(s);\n\t\t\t\ts_skip(s, 16); // For future use (set to zero).\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2007: // Color profile chunk.\n\t\t\t{\n\t\t\t\tase->has_color_profile = 1;\n\t\t\t\tase->color_profile.type = (ase_color_profile_type_t)s_read_uint16(s);\n\t\t\t\tase->color_profile.use_fixed_gamma = (int)s_read_uint16(s) & 1;\n\t\t\t\tase->color_profile.gamma = s_read_fixed(s);\n\t\t\t\ts_skip(s, 8); // For future use (set to zero).\n\t\t\t\tif (ase->color_profile.type == ASE_COLOR_PROFILE_TYPE_EMBEDDED_ICC) {\n\t\t\t\t\t// Use the embedded ICC profile.\n\t\t\t\t\tase->color_profile.icc_profile_data_length = s_read_uint32(s);\n\t\t\t\t\tase->color_profile.icc_profile_data = CUTE_ASEPRITE_ALLOC(ase->color_profile.icc_profile_data_length, mem_ctx);\n\t\t\t\t\tCUTE_ASEPRITE_MEMCPY(ase->color_profile.icc_profile_data, s->in, ase->color_profile.icc_profile_data_length);\n\t\t\t\t\ts->in += ase->color_profile.icc_profile_data_length;\n\t\t\t\t}\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2018: // Tags chunk.\n\t\t\t{\n\t\t\t\tase->tag_count = (int)s_read_uint16(s);\n\t\t\t\ts_skip(s, 8); // For future (set to zero).\n\t\t\t\tCUTE_ASEPRITE_ASSERT(ase->tag_count < CUTE_ASEPRITE_MAX_TAGS);\n\t\t\t\tfor (int k = 0; k < ase->tag_count; ++k) {\n\t\t\t\t\tase->tags[k].from_frame = (int)s_read_uint16(s);\n\t\t\t\t\tase->tags[k].to_frame = (int)s_read_uint16(s);\n\t\t\t\t\tase->tags[k].loop_animation_direction = (ase_animation_direction_t)s_read_uint8(s);\n\t\t\t\t\tase->tags[k].repeat = s_read_uint16(s);\n\t\t\t\t\ts_skip(s, 6); // For future (set to zero).\n\t\t\t\t\tase->tags[k].r = s_read_uint8(s);\n\t\t\t\t\tase->tags[k].g = s_read_uint8(s);\n\t\t\t\t\tase->tags[k].b = s_read_uint8(s);\n\t\t\t\t\ts_skip(s, 1); // Extra byte (zero).\n\t\t\t\t\tase->tags[k].name = s_read_string(s);\n\t\t\t\t}\n\t\t\t\twas_on_tags = 1;\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2019: // Palette chunk.\n\t\t\t{\n\t\t\t\tase->palette.entry_count = (int)s_read_uint32(s);\n\t\t\t\tCUTE_ASEPRITE_ASSERT(ase->palette.entry_count <= CUTE_ASEPRITE_MAX_PALETTE_ENTRIES);\n\t\t\t\tint first_index = (int)s_read_uint32(s);\n\t\t\t\tint last_index = (int)s_read_uint32(s);\n\t\t\t\ts_skip(s, 8); // For future (set to zero).\n\t\t\t\tfor (int k = first_index; k <= last_index; ++k) {\n\t\t\t\t\tint has_name = s_read_uint16(s);\n\t\t\t\t\tase_palette_entry_t entry;\n\t\t\t\t\tentry.color.r = s_read_uint8(s);\n\t\t\t\t\tentry.color.g = s_read_uint8(s);\n\t\t\t\t\tentry.color.b = s_read_uint8(s);\n\t\t\t\t\tentry.color.a = s_read_uint8(s);\n\t\t\t\t\tif (has_name) {\n\t\t\t\t\t\tentry.color_name = s_read_string(s);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentry.color_name = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT(k < CUTE_ASEPRITE_MAX_PALETTE_ENTRIES);\n\t\t\t\t\tase->palette.entries[k] = entry;\n\t\t\t\t}\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2020: // Udata chunk.\n\t\t\t{\n\t\t\t\tCUTE_ASEPRITE_ASSERT(last_udata || was_on_tags);\n\t\t\t\tif (was_on_tags && !last_udata) {\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT(tag_index < ase->tag_count);\n\t\t\t\t\tlast_udata = &ase->tags[tag_index++].udata;\n\t\t\t\t}\n\t\t\t\tint flags = (int)s_read_uint32(s);\n\t\t\t\tif (flags & 1) {\n\t\t\t\t\tlast_udata->has_text = 1;\n\t\t\t\t\tlast_udata->text = s_read_string(s);\n\t\t\t\t}\n\t\t\t\tif (flags & 2) {\n\t\t\t\t\tlast_udata->color.r = s_read_uint8(s);\n\t\t\t\t\tlast_udata->color.g = s_read_uint8(s);\n\t\t\t\t\tlast_udata->color.b = s_read_uint8(s);\n\t\t\t\t\tlast_udata->color.a = s_read_uint8(s);\n\t\t\t\t}\n\t\t\t\tlast_udata = NULL;\n\t\t\t}\tbreak;\n\n\t\t\tcase 0x2022: // Slice chunk.\n\t\t\t{\n\t\t\t\tint slice_count = (int)s_read_uint32(s);\n\t\t\t\tint flags = (int)s_read_uint32(s);\n\t\t\t\ts_skip(s, sizeof(uint32_t)); // Reserved.\n\t\t\t\tconst char* name = s_read_string(s);\n\t\t\t\tfor (int k = 0; k < (int)slice_count; ++k) {\n\t\t\t\t\tase_slice_t slice;\n\t\t\t\t\tCUTE_ASEPRITE_MEMSET(&slice, 0, sizeof(slice));\n\t\t\t\t\tslice.name = name;\n\t\t\t\t\tslice.frame_number = (int)s_read_uint32(s);\n\t\t\t\t\tslice.origin_x = (int)s_read_int32(s);\n\t\t\t\t\tslice.origin_y = (int)s_read_int32(s);\n\t\t\t\t\tslice.w = (int)s_read_uint32(s);\n\t\t\t\t\tslice.h = (int)s_read_uint32(s);\n\t\t\t\t\tif (flags & 1) {\n\t\t\t\t\t\t// It's a 9-patches slice.\n\t\t\t\t\t\tslice.has_center_as_9_slice = 1;\n\t\t\t\t\t\tslice.center_x = (int)s_read_int32(s);\n\t\t\t\t\t\tslice.center_y = (int)s_read_int32(s);\n\t\t\t\t\t\tslice.center_w = (int)s_read_uint32(s);\n\t\t\t\t\t\tslice.center_h = (int)s_read_uint32(s);\n\t\t\t\t\t}\n\t\t\t\t\tif (flags & 2) {\n\t\t\t\t\t\t// Has pivot information.\n\t\t\t\t\t\tslice.has_pivot = 1;\n\t\t\t\t\t\tslice.pivot_x = (int)s_read_int32(s);\n\t\t\t\t\t\tslice.pivot_y = (int)s_read_int32(s);\n\t\t\t\t\t}\n\t\t\t\t\tCUTE_ASEPRITE_ASSERT(ase->slice_count < CUTE_ASEPRITE_MAX_SLICES);\n\t\t\t\t\tase->slices[ase->slice_count++] = slice;\n\t\t\t\t\tlast_udata = &ase->slices[ase->slice_count - 1].udata;\n\t\t\t\t}\n\t\t\t}\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ts_skip(s, (int)chunk_size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuint32_t size_read = (uint32_t)(s->in - chunk_start);\n\t\t\tCUTE_ASEPRITE_ASSERT(size_read == chunk_size);\n\t\t}\n\t}\n\n\t// Blend all cel pixels into each of their respective frames, for convenience.\n\tfor (int i = 0; i < ase->frame_count; ++i) {\n\t\tase_frame_t* frame = ase->frames + i;\n\t\tframe->pixels = (ase_color_t*)CUTE_ASEPRITE_ALLOC((int)(sizeof(ase_color_t)) * ase->w * ase->h, mem_ctx);\n\t\tCUTE_ASEPRITE_MEMSET(frame->pixels, 0, sizeof(ase_color_t) * (size_t)ase->w * (size_t)ase->h);\n\t\tase_color_t* dst = frame->pixels;\n\t\tfor (int j = 0; j < frame->cel_count; ++j) {\n\t\t\tase_cel_t* cel = frame->cels + j;\n\t\t\tif (!(cel->layer->flags & ASE_LAYER_FLAGS_VISIBLE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cel->layer->parent && !(cel->layer->parent->flags & ASE_LAYER_FLAGS_VISIBLE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (cel->is_linked) {\n\t\t\t\tase_frame_t* frame = ase->frames + cel->linked_frame_index;\n\t\t\t\tint found = 0;\n\t\t\t\tfor (int k = 0; k < frame->cel_count; ++k) {\n\t\t\t\t\tif (frame->cels[k].layer == cel->layer) {\n\t\t\t\t\t\tcel = frame->cels + k;\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCUTE_ASEPRITE_ASSERT(found);\n\t\t\t}\n\t\t\tvoid* src = cel->pixels;\n\t\t\tuint8_t opacity = (uint8_t)(cel->opacity * cel->layer->opacity * 255.0f);\n\t\t\tint cx = cel->x;\n\t\t\tint cy = cel->y;\n\t\t\tint cw = cel->w;\n\t\t\tint ch = cel->h;\n\t\t\tint cl = -s_min(cx, 0);\n\t\t\tint ct = -s_min(cy, 0);\n\t\t\tint dl = s_max(cx, 0);\n\t\t\tint dt = s_max(cy, 0);\n\t\t\tint dr = s_min(ase->w, cw + cx);\n\t\t\tint db = s_min(ase->h, ch + cy);\n\t\t\tint aw = ase->w;\n\t\t\tfor (int dx = dl, sx = cl; dx < dr; dx++, sx++) {\n\t\t\t\tfor (int dy = dt, sy = ct; dy < db; dy++, sy++) {\n\t\t\t\t\tint dst_index = aw * dy + dx;\n\t\t\t\t\tase_color_t src_color = s_color(ase, src, cw * sy + sx);\n\t\t\t\t\tase_color_t dst_color = dst[dst_index];\n\t\t\t\t\tase_color_t result = s_blend(src_color, dst_color, opacity);\n\t\t\t\t\tdst[dst_index] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tase->mem_ctx = mem_ctx;\n\treturn ase;\n}\n\nvoid cute_aseprite_free(ase_t* ase)\n{\n\tfor (int i = 0; i < ase->frame_count; ++i) {\n\t\tase_frame_t* frame = ase->frames + i;\n\t\tCUTE_ASEPRITE_FREE(frame->pixels, ase->mem_ctx);\n\t\tfor (int j = 0; j < frame->cel_count; ++j) {\n\t\t\tase_cel_t* cel = frame->cels + j;\n\t\t\tCUTE_ASEPRITE_FREE(cel->pixels, ase->mem_ctx);\n\t\t\tCUTE_ASEPRITE_FREE((void*)cel->udata.text, ase->mem_ctx);\n\t\t}\n\t}\n\tfor (int i = 0; i < ase->layer_count; ++i) {\n\t\tase_layer_t* layer = ase->layers + i;\n\t\tCUTE_ASEPRITE_FREE((void*)layer->name, ase->mem_ctx);\n\t\tCUTE_ASEPRITE_FREE((void*)layer->udata.text, ase->mem_ctx);\n\t}\n\tfor (int i = 0; i < ase->tag_count; ++i) {\n\t\tase_tag_t* tag = ase->tags + i;\n\t\tCUTE_ASEPRITE_FREE((void*)tag->name, ase->mem_ctx);\n\t}\n\tfor (int i = 0; i < ase->slice_count; ++i) {\n\t\tase_slice_t* slice = ase->slices + i;\n\t\tCUTE_ASEPRITE_FREE((void*)slice->udata.text, ase->mem_ctx);\n\t}\n\tif (ase->slice_count) {\n\t\tCUTE_ASEPRITE_FREE((void*)ase->slices[0].name, ase->mem_ctx);\n\t}\n\tfor (int i = 0; i < ase->palette.entry_count; ++i) {\n\t\tCUTE_ASEPRITE_FREE((void*)ase->palette.entries[i].color_name, ase->mem_ctx);\n\t}\n\tCUTE_ASEPRITE_FREE(ase->color_profile.icc_profile_data, ase->mem_ctx);\n\tCUTE_ASEPRITE_FREE(ase->frames, ase->mem_ctx);\n\tCUTE_ASEPRITE_FREE(ase, ase->mem_ctx);\n}\n\n#endif // CUTE_ASEPRITE_IMPLEMENTATION_ONCE\n#endif // CUTE_ASEPRITE_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2017 Randy Gaul http://www.randygaul.net\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\n\tsoftware, either in source code form or as a compiled binary, for any purpose,\n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this\n\tsoftware dedicate any and all copyright interest in the software to the public\n\tdomain. We make this dedication for the benefit of the public at large and to\n\tthe detriment of our heirs and successors. We intend this dedication to be an\n\tovert act of relinquishment in perpetuity of all present and future rights to\n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_c2.h",
          "type": "blob",
          "size": 64.23046875,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_c2.h - v1.10\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_C2_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY\n\n\t\tcute_c2 is a single-file header that implements 2D collision detection routines\n\t\tthat test for overlap, and optionally can find the collision manifold. The\n\t\tmanifold contains all necessary information to prevent shapes from inter-\n\t\tpenetrating, which is useful for character controllers, general physics\n\t\tsimulation, and user-interface programming.\n\n\t\tThis header implements a group of \"immediate mode\" functions that should be\n\t\tvery easily adapted into pre-existing projects.\n\n\n\tTHE IMPORTANT PARTS\n\n\t\tMost of the math types in this header are for internal use. Users care about\n\t\tthe shape types and the collision functions.\n\n\t\tSHAPE TYPES:\n\t\t* c2Circle\n\t\t* c2Capsule\n\t\t* c2AABB\n\t\t* c2Ray\n\t\t* c2Poly\n\n\t\tCOLLISION FUNCTIONS (*** is a shape name from the above list):\n\t\t* c2***to***         - boolean YES/NO hittest\n\t\t* c2***to***Manifold - construct manifold to describe how shapes hit\n\t\t* c2GJK              - runs GJK algorithm to find closest point pair between two shapes\n\t\t* c2TOI              - computes the time of impact between two shapes, useful for sweeping shapes, or doing shape casts\n\t\t* c2MakePoly         - Runs convex hull algorithm and computes normals on input point-set\n\t\t* c2Collided         - generic version of c2***to*** funcs\n\t\t* c2Collide          - generic version of c2***to***Manifold funcs\n\t\t* c2CastRay          - generic version of c2Rayto*** funcs\n\n\t\tThe rest of the header is more or less for internal use. Here is an example of\n\t\tmaking some shapes and testing for collision:\n\n\t\t\tc2Circle c;\n\t\t\tc.p = position;\n\t\t\tc.r = radius;\n\n\t\t\tc2Capsule cap;\n\t\t\tcap.a = first_endpoint;\n\t\t\tcap.b = second_endpoint;\n\t\t\tcap.r = radius;\n\n\t\t\tint hit = c2CircletoCapsule(c, cap);\n\t\t\tif (hit)\n\t\t\t{\n\t\t\t\thandle collision here...\n\t\t\t}\n\t\n\t\tFor more code examples and tests please see:\n\t\thttps://github.com/RandyGaul/cute_header/tree/master/examples_cute_gl_and_c2\n\n\t\tHere is a past discussion thread on this header:\n\t\thttps://www.reddit.com/r/gamedev/comments/5tqyey/tinyc2_2d_collision_detection_library_in_c/\n\n\t\tHere is a very nice repo containing various tests and examples using SFML for rendering:\n\t\thttps://github.com/sro5h/tinyc2-tests\n\n\n\tFEATURES\n\n\t\t* Circles, capsules, AABBs, rays and convex polygons are supported\n\t\t* Fast boolean only result functions (hit yes/no)\n\t\t* Slghtly slower manifold generation for collision normals + depths +points\n\t\t* GJK implementation (finds closest points for disjoint pairs of shapes)\n\t\t* Shape casts/sweeps with c2TOI function (time of impact)\n\t\t* Robust 2D convex hull generator\n\t\t* Lots of correctly implemented and tested 2D math routines\n\t\t* Implemented in portable C, and is readily portable to other languages\n\t\t* Generic c2Collide, c2Collided and c2CastRay function (can pass in any shape type)\n\t\t* Extensive examples at: https://github.com/RandyGaul/cute_headers/tree/master/examples_cute_gl_and_c2\n\n\n\tRevision History\n\t\n\t\t1.0  (02/13/2017) initial release\n\t\t1.01 (02/13/2017) const crusade, minor optimizations, capsule degen\n\t\t1.02 (03/21/2017) compile fixes for c on more compilers\n\t\t1.03 (09/15/2017) various bugfixes and quality of life changes to manifolds\n\t\t1.04 (03/25/2018) fixed manifold bug in c2CircletoAABBManifold\n\t\t1.05 (11/01/2018) added c2TOI (time of impact) for shape cast/sweep test\n\t\t1.06 (08/23/2019) C2_*** types to C2_TYPE_***, and CUTE_C2_API\n\t\t1.07 (10/19/2019) Optimizations to c2TOI - breaking change to c2GJK API\n\t\t1.08 (12/22/2019) Remove contact point + normal from c2TOI, removed feather\n\t\t                  radius from c2GJK, fixed various bugs in capsule to poly\n\t\t                  manifold, did a pass on all docs\n\t\t1.09 (07/27/2019) Added c2Inflate - to inflate/deflate shapes for c2TOI\n\t\t1.10 (02/05/2022) Implemented GJK-Raycast for c2TOI (from E. Catto's Box2D)\n\n\n\tContributors\n\n\t\tPlastburk         1.01 - const pointers pull request\n\t\tmmozeiko          1.02 - 3 compile bugfixes\n\t\tfelipefs          1.02 - 3 compile bugfixes\n\t\tseemk             1.02 - fix branching bug in c2Collide\n\t\tsro5h             1.02 - bug reports for multiple manifold funcs\n\t\tsro5h             1.03 - work involving quality of life fixes for manifolds\n\t\tWizzard033        1.06 - C2_*** types to C2_TYPE_***, and CUTE_C2_API\n\t\tTyler Glaeil      1.08 - Lots of bug reports and disussion on capsules + TOIs\n\n\n\tDETAILS/ADVICE\n\n\t\tBROAD PHASE\n\n\t\t\tThis header does not implement a broad-phase, and instead concerns itself with\n\t\t\tthe narrow-phase. This means this header just checks to see if two individual\n\t\t\tshapes are touching, and can give information about how they are touching.\n\n\t\t\tVery common 2D broad-phases are tree and grid approaches. Quad trees are good\n\t\t\tfor static geometry that does not move much if at all. Dynamic AABB trees are\n\t\t\tgood for general purpose use, and can handle moving objects very well. Grids\n\t\t\tare great and are similar to quad trees.\n\n\t\t\tIf implementing a grid it can be wise to have each collideable grid cell hold\n\t\t\tan integer. This integer refers to a 2D shape that can be passed into the\n\t\t\tvarious functions in this header. The shape can be transformed from \"model\"\n\t\t\tspace to \"world\" space using c2x -- a transform struct. In this way a grid\n\t\t\tcan be implemented that holds any kind of convex shape (that this header\n\t\t\tsupports) while conserving memory with shape instancing.\n\n\t\tNUMERIC ROBUSTNESS\n\n\t\t\tMany of the functions in cute c2 use `c2GJK`, an implementation of the GJK\n\t\t\talgorithm. Internally GJK computes signed area values, and these values are\n\t\t\tvery numerically sensitive to large shapes. This means the GJK function will\n\t\t\tbreak down if input shapes are too large or too far away from the origin.\n\n\t\t\tIn general it is best to compute collision detection on small shapes very\n\t\t\tclose to the origin. One trick is to keep your collision information numerically\n\t\t\tvery tiny, and simply scale it up when rendering to the appropriate size.\n\n\t\t\tFor reference, if your shapes are all AABBs and contain a width and height\n\t\t\tof somewhere between 1.0f and 10.0f, everything will be fine. However, once\n\t\t\tyour shapes start approaching a width/height of 100.0f to 1000.0f GJK can\n\t\t\tstart breaking down.\n\n\t\t\tThis is a complicated topic, so feel free to ask the author for advice here.\n\n\t\t\tHere is an example demonstrating this problem with two large AABBs:\n\t\t\thttps://github.com/RandyGaul/cute_headers/issues/160\n\n\t\tPlease email at my address with any questions or comments at:\n\t\tauthor's last name followed by 1748 at gmail\n*/\n\n#if !defined(CUTE_C2_H)\n\n// this can be adjusted as necessary, but is highly recommended to be kept at 8.\n// higher numbers will incur quite a bit of memory overhead, and convex shapes\n// over 8 verts start to just look like spheres, which can be implicitly rep-\n// resented as a point + radius. usually tools that generate polygons should be\n// constructed so they do not output polygons with too many verts.\n// Note: polygons in cute_c2 are all *convex*.\n#define C2_MAX_POLYGON_VERTS 8\n\n// 2d vector\ntypedef struct c2v\n{\n\tfloat x;\n\tfloat y;\n} c2v;\n\n// 2d rotation composed of cos/sin pair for a single angle\n// We use two floats as a small optimization to avoid computing sin/cos unnecessarily\ntypedef struct c2r\n{\n\tfloat c;\n\tfloat s;\n} c2r;\n\n// 2d rotation matrix\ntypedef struct c2m\n{\n\tc2v x;\n\tc2v y;\n} c2m;\n\n// 2d transformation \"x\"\n// These are used especially for c2Poly when a c2Poly is passed to a function.\n// Since polygons are prime for \"instancing\" a c2x transform can be used to\n// transform a polygon from local space to world space. In functions that take\n// a c2x pointer (like c2PolytoPoly), these pointers can be NULL, which represents\n// an identity transformation and assumes the verts inside of c2Poly are already\n// in world space.\ntypedef struct c2x\n{\n\tc2v p;\n\tc2r r;\n} c2x;\n\n// 2d halfspace (aka plane, aka line)\ntypedef struct c2h\n{\n\tc2v n;   // normal, normalized\n\tfloat d; // distance to origin from plane, or ax + by = d\n} c2h;\n\ntypedef struct c2Circle\n{\n\tc2v p;\n\tfloat r;\n} c2Circle;\n\ntypedef struct c2AABB\n{\n\tc2v min;\n\tc2v max;\n} c2AABB;\n\n// a capsule is defined as a line segment (from a to b) and radius r\ntypedef struct c2Capsule\n{\n\tc2v a;\n\tc2v b;\n\tfloat r;\n} c2Capsule;\n\ntypedef struct c2Poly\n{\n\tint count;\n\tc2v verts[C2_MAX_POLYGON_VERTS];\n\tc2v norms[C2_MAX_POLYGON_VERTS];\n} c2Poly;\n\n// IMPORTANT:\n// Many algorithms in this file are sensitive to the magnitude of the\n// ray direction (c2Ray::d). It is highly recommended to normalize the\n// ray direction and use t to specify a distance. Please see this link\n// for an in-depth explanation: https://github.com/RandyGaul/cute_headers/issues/30\ntypedef struct c2Ray\n{\n\tc2v p;   // position\n\tc2v d;   // direction (normalized)\n\tfloat t; // distance along d from position p to find endpoint of ray\n} c2Ray;\n\ntypedef struct c2Raycast\n{\n\tfloat t; // time of impact\n\tc2v n;   // normal of surface at impact (unit length)\n} c2Raycast;\n\n// position of impact p = ray.p + ray.d * raycast.t\n#define c2Impact(ray, t) c2Add(ray.p, c2Mulvs(ray.d, t))\n\n// contains all information necessary to resolve a collision, or in other words\n// this is the information needed to separate shapes that are colliding. Doing\n// the resolution step is *not* included in cute_c2.\ntypedef struct c2Manifold\n{\n\tint count;\n\tfloat depths[2];\n\tc2v contact_points[2];\n\n\t// always points from shape A to shape B (first and second shapes passed into\n\t// any of the c2***to***Manifold functions)\n\tc2v n;\n} c2Manifold;\n\n// This define allows exporting/importing of the header to a dynamic library.\n// Here's an example.\n// #define CUTE_C2_API extern \"C\" __declspec(dllexport)\n#if !defined(CUTE_C2_API)\n#\tdefine CUTE_C2_API\n#endif\n\n// boolean collision detection\n// these versions are faster than the manifold versions, but only give a YES/NO result\nCUTE_C2_API int c2CircletoCircle(c2Circle A, c2Circle B);\nCUTE_C2_API int c2CircletoAABB(c2Circle A, c2AABB B);\nCUTE_C2_API int c2CircletoCapsule(c2Circle A, c2Capsule B);\nCUTE_C2_API int c2AABBtoAABB(c2AABB A, c2AABB B);\nCUTE_C2_API int c2AABBtoCapsule(c2AABB A, c2Capsule B);\nCUTE_C2_API int c2CapsuletoCapsule(c2Capsule A, c2Capsule B);\nCUTE_C2_API int c2CircletoPoly(c2Circle A, const c2Poly* B, const c2x* bx);\nCUTE_C2_API int c2AABBtoPoly(c2AABB A, const c2Poly* B, const c2x* bx);\nCUTE_C2_API int c2CapsuletoPoly(c2Capsule A, const c2Poly* B, const c2x* bx);\nCUTE_C2_API int c2PolytoPoly(const c2Poly* A, const c2x* ax, const c2Poly* B, const c2x* bx);\n\n// ray operations\n// output is placed into the c2Raycast struct, which represents the hit location\n// of the ray. the out param contains no meaningful information if these funcs\n// return 0\nCUTE_C2_API int c2RaytoCircle(c2Ray A, c2Circle B, c2Raycast* out);\nCUTE_C2_API int c2RaytoAABB(c2Ray A, c2AABB B, c2Raycast* out);\nCUTE_C2_API int c2RaytoCapsule(c2Ray A, c2Capsule B, c2Raycast* out);\nCUTE_C2_API int c2RaytoPoly(c2Ray A, const c2Poly* B, const c2x* bx_ptr, c2Raycast* out);\n\n// manifold generation\n// These functions are (generally) slower than the boolean versions, but will compute one\n// or two points that represent the plane of contact. This information is usually needed\n// to resolve and prevent shapes from colliding. If no collision occured the count member\n// of the manifold struct is set to 0.\nCUTE_C2_API void c2CircletoCircleManifold(c2Circle A, c2Circle B, c2Manifold* m);\nCUTE_C2_API void c2CircletoAABBManifold(c2Circle A, c2AABB B, c2Manifold* m);\nCUTE_C2_API void c2CircletoCapsuleManifold(c2Circle A, c2Capsule B, c2Manifold* m);\nCUTE_C2_API void c2AABBtoAABBManifold(c2AABB A, c2AABB B, c2Manifold* m);\nCUTE_C2_API void c2AABBtoCapsuleManifold(c2AABB A, c2Capsule B, c2Manifold* m);\nCUTE_C2_API void c2CapsuletoCapsuleManifold(c2Capsule A, c2Capsule B, c2Manifold* m);\nCUTE_C2_API void c2CircletoPolyManifold(c2Circle A, const c2Poly* B, const c2x* bx, c2Manifold* m);\nCUTE_C2_API void c2AABBtoPolyManifold(c2AABB A, const c2Poly* B, const c2x* bx, c2Manifold* m);\nCUTE_C2_API void c2CapsuletoPolyManifold(c2Capsule A, const c2Poly* B, const c2x* bx, c2Manifold* m);\nCUTE_C2_API void c2PolytoPolyManifold(const c2Poly* A, const c2x* ax, const c2Poly* B, const c2x* bx, c2Manifold* m);\n\ntypedef enum\n{\n\tC2_TYPE_NONE,\n\tC2_TYPE_CIRCLE,\n\tC2_TYPE_AABB,\n\tC2_TYPE_CAPSULE,\n\tC2_TYPE_POLY\n} C2_TYPE;\n\n// This struct is only for advanced usage of the c2GJK function. See comments inside of the\n// c2GJK function for more details.\ntypedef struct c2GJKCache\n{\n\tfloat metric;\n\tint count;\n\tint iA[3];\n\tint iB[3];\n\tfloat div;\n} c2GJKCache;\n\n// This is an advanced function, intended to be used by people who know what they're doing.\n//\n// Runs the GJK algorithm to find closest points, returns distance between closest points.\n// outA and outB can be NULL, in this case only distance is returned. ax_ptr and bx_ptr\n// can be NULL, and represent local to world transformations for shapes A and B respectively.\n// use_radius will apply radii for capsules and circles (if set to false, spheres are\n// treated as points and capsules are treated as line segments i.e. rays). The cache parameter\n// should be NULL, as it is only for advanced usage (unless you know what you're doing, then\n// go ahead and use it). iterations is an optional parameter.\n//\n// IMPORTANT NOTE:\n// The GJK function is sensitive to large shapes, since it internally will compute signed area\n// values. `c2GJK` is called throughout cute c2 in many ways, so try to make sure all of your\n// collision shapes are not gigantic. For example, try to keep the volume of all your shapes\n// less than 100.0f. If you need large shapes, you should use tiny collision geometry for all\n// cute c2 function, and simply render the geometry larger on-screen by scaling it up.\nCUTE_C2_API float c2GJK(const void* A, C2_TYPE typeA, const c2x* ax_ptr, const void* B, C2_TYPE typeB, const c2x* bx_ptr, c2v* outA, c2v* outB, int use_radius, int* iterations, c2GJKCache* cache);\n\n// Stores results of a time of impact calculation done by `c2TOI`.\ntypedef struct c2TOIResult\n{\n\tint hit;        // 1 if shapes were touching at the TOI, 0 if they never hit.\n\tfloat toi;      // The time of impact between two shapes.\n\tc2v n;          // Surface normal from shape A to B at the time of impact.\n\tc2v p;          // Point of contact between shapes A and B at time of impact.\n\tint iterations; // Number of iterations the solver underwent.\n} c2TOIResult;\n\n// This is an advanced function, intended to be used by people who know what they're doing.\n//\n// Computes the time of impact from shape A and shape B. The velocity of each shape is provided\n// by vA and vB respectively. The shapes are *not* allowed to rotate over time. The velocity is\n// assumed to represent the change in motion from time 0 to time 1, and so the return value will\n// be a number from 0 to 1. To move each shape to the colliding configuration, multiply vA and vB\n// each by the return value. ax_ptr and bx_ptr are optional parameters to transforms for each shape,\n// and are typically used for polygon shapes to transform from model to world space. Set these to\n// NULL to represent identity transforms. iterations is an optional parameter. use_radius\n// will apply radii for capsules and circles (if set to false, spheres are treated as points and\n// capsules are treated as line segments i.e. rays).\n//\n// IMPORTANT NOTE:\n// The c2TOI function can be used to implement a \"swept character controller\", but it can be\n// difficult to do so. Say we compute a time of impact with `c2TOI` and move the shapes to the\n// time of impact, and adjust the velocity by zeroing out the velocity along the surface normal.\n// If we then call `c2TOI` again, it will fail since the shapes will be considered to start in\n// a colliding configuration. There are many styles of tricks to get around this problem, and\n// all of them involve giving the next call to `c2TOI` some breathing room. It is recommended\n// to use some variation of the following algorithm:\n//\n// 1. Call c2TOI.\n// 2. Move the shapes to the TOI.\n// 3. Slightly inflate the size of one, or both, of the shapes so they will be intersecting.\n//    The purpose is to make the shapes numerically intersecting, but not visually intersecting.\n//    Another option is to call c2TOI with slightly deflated shapes.\n//    See the function `c2Inflate` for some more details.\n// 4. Compute the collision manifold between the inflated shapes (for example, use c2PolytoPolyManifold).\n// 5. Gently push the shapes apart. This will give the next call to c2TOI some breathing room.\nCUTE_C2_API c2TOIResult c2TOI(const void* A, C2_TYPE typeA, const c2x* ax_ptr, c2v vA, const void* B, C2_TYPE typeB, const c2x* bx_ptr, c2v vB, int use_radius);\n\n// Inflating a shape.\n//\n// This is useful to numerically grow or shrink a polytope. For example, when calling\n// a time of impact function it can be good to use a slightly smaller shape. Then, once\n// both shapes are moved to the time of impact a collision manifold can be made from the\n// slightly larger (and now overlapping) shapes.\n//\n// IMPORTANT NOTE\n// Inflating a shape with sharp corners can cause those corners to move dramatically.\n// Deflating a shape can avoid this problem, but deflating a very small shape can invert\n// the planes and result in something that is no longer convex. Make sure to pick an\n// appropriately small skin factor, for example 1.0e-6f.\nCUTE_C2_API void c2Inflate(void* shape, C2_TYPE type, float skin_factor);\n\n// Computes 2D convex hull. Will not do anything if less than two verts supplied. If\n// more than C2_MAX_POLYGON_VERTS are supplied extras are ignored.\nCUTE_C2_API int c2Hull(c2v* verts, int count);\nCUTE_C2_API void c2Norms(c2v* verts, c2v* norms, int count);\n\n// runs c2Hull and c2Norms, assumes p->verts and p->count are both set to valid values\nCUTE_C2_API void c2MakePoly(c2Poly* p);\n\n// Generic collision detection routines, useful for games that want to use some poly-\n// morphism to write more generic-styled code. Internally calls various above functions.\n// For AABBs/Circles/Capsules ax and bx are ignored. For polys ax and bx can define\n// model to world transformations (for polys only), or be NULL for identity transforms.\nCUTE_C2_API int c2Collided(const void* A, const c2x* ax, C2_TYPE typeA, const void* B, const c2x* bx, C2_TYPE typeB);\nCUTE_C2_API void c2Collide(const void* A, const c2x* ax, C2_TYPE typeA, const void* B, const c2x* bx, C2_TYPE typeB, c2Manifold* m);\nCUTE_C2_API int c2CastRay(c2Ray A, const void* B, const c2x* bx, C2_TYPE typeB, c2Raycast* out);\n\n#ifdef _MSC_VER\n\t#define C2_INLINE __forceinline\n#else\n\t#define C2_INLINE inline __attribute__((always_inline))\n#endif\n\n// adjust these primitives as seen fit\n#include <string.h> // memcpy\n#include <math.h>\n#define c2Sin(radians) sinf(radians)\n#define c2Cos(radians) cosf(radians)\n#define c2Sqrt(a) sqrtf(a)\n#define c2Min(a, b) ((a) < (b) ? (a) : (b))\n#define c2Max(a, b) ((a) > (b) ? (a) : (b))\n#define c2Abs(a) ((a) < 0 ? -(a) : (a))\n#define c2Clamp(a, lo, hi) c2Max(lo, c2Min(a, hi))\nC2_INLINE void c2SinCos(float radians, float* s, float* c) { *c = c2Cos(radians); *s = c2Sin(radians); }\n#define c2Sign(a) (a < 0 ? -1.0f : 1.0f)\n\n// The rest of the functions in the header-only portion are all for internal use\n// and use the author's personal naming conventions. It is recommended to use one's\n// own math library instead of the one embedded here in cute_c2, but for those\n// curious or interested in trying it out here's the details:\n\n// The Mul functions are used to perform multiplication. x stands for transform,\n// v stands for vector, s stands for scalar, r stands for rotation, h stands for\n// halfspace and T stands for transpose.For example c2MulxvT stands for \"multiply\n// a transform with a vector, and transpose the transform\".\n\n// vector ops\nC2_INLINE c2v c2V(float x, float y) { c2v a; a.x = x; a.y = y; return a; }\nC2_INLINE c2v c2Add(c2v a, c2v b) { a.x += b.x; a.y += b.y; return a; }\nC2_INLINE c2v c2Sub(c2v a, c2v b) { a.x -= b.x; a.y -= b.y; return a; }\nC2_INLINE float c2Dot(c2v a, c2v b) { return a.x * b.x + a.y * b.y; }\nC2_INLINE c2v c2Mulvs(c2v a, float b) { a.x *= b; a.y *= b; return a; }\nC2_INLINE c2v c2Mulvv(c2v a, c2v b) { a.x *= b.x; a.y *= b.y; return a; }\nC2_INLINE c2v c2Div(c2v a, float b) { return c2Mulvs(a, 1.0f / b); }\nC2_INLINE c2v c2Skew(c2v a) { c2v b; b.x = -a.y; b.y = a.x; return b; }\nC2_INLINE c2v c2CCW90(c2v a) { c2v b; b.x = a.y; b.y = -a.x; return b; }\nC2_INLINE float c2Det2(c2v a, c2v b) { return a.x * b.y - a.y * b.x; }\nC2_INLINE c2v c2Minv(c2v a, c2v b) { return c2V(c2Min(a.x, b.x), c2Min(a.y, b.y)); }\nC2_INLINE c2v c2Maxv(c2v a, c2v b) { return c2V(c2Max(a.x, b.x), c2Max(a.y, b.y)); }\nC2_INLINE c2v c2Clampv(c2v a, c2v lo, c2v hi) { return c2Maxv(lo, c2Minv(a, hi)); }\nC2_INLINE c2v c2Absv(c2v a) { return c2V(c2Abs(a.x), c2Abs(a.y)); }\nC2_INLINE float c2Hmin(c2v a) { return c2Min(a.x, a.y); }\nC2_INLINE float c2Hmax(c2v a) { return c2Max(a.x, a.y); }\nC2_INLINE float c2Len(c2v a) { return c2Sqrt(c2Dot(a, a)); }\nC2_INLINE c2v c2Norm(c2v a) { return c2Div(a, c2Len(a)); }\nC2_INLINE c2v c2SafeNorm(c2v a) { float sq = c2Dot(a, a); return sq ? c2Div(a, c2Len(a)) : c2V(0, 0); }\nC2_INLINE c2v c2Neg(c2v a) { return c2V(-a.x, -a.y); }\nC2_INLINE c2v c2Lerp(c2v a, c2v b, float t) { return c2Add(a, c2Mulvs(c2Sub(b, a), t)); }\nC2_INLINE int c2Parallel(c2v a, c2v b, float kTol)\n{\n\tfloat k = c2Len(a) / c2Len(b);\n\tb = c2Mulvs(b, k);\n\tif (c2Abs(a.x - b.x) < kTol && c2Abs(a.y - b.y) < kTol) return 1;\n\treturn 0;\n}\n\n// rotation ops\nC2_INLINE c2r c2Rot(float radians) { c2r r; c2SinCos(radians, &r.s, &r.c); return r; }\nC2_INLINE c2r c2RotIdentity(void) { c2r r; r.c = 1.0f; r.s = 0; return r; }\nC2_INLINE c2v c2RotX(c2r r) { return c2V(r.c, r.s); }\nC2_INLINE c2v c2RotY(c2r r) { return c2V(-r.s, r.c); }\nC2_INLINE c2v c2Mulrv(c2r a, c2v b)  { return c2V(a.c * b.x - a.s * b.y,  a.s * b.x + a.c * b.y); }\nC2_INLINE c2v c2MulrvT(c2r a, c2v b) { return c2V(a.c * b.x + a.s * b.y, -a.s * b.x + a.c * b.y); }\nC2_INLINE c2r c2Mulrr(c2r a, c2r b)  { c2r c; c.c = a.c * b.c - a.s * b.s; c.s = a.s * b.c + a.c * b.s; return c; }\nC2_INLINE c2r c2MulrrT(c2r a, c2r b) { c2r c; c.c = a.c * b.c + a.s * b.s; c.s = a.c * b.s - a.s * b.c; return c; }\n\nC2_INLINE c2v c2Mulmv(c2m a, c2v b) { c2v c; c.x = a.x.x * b.x + a.y.x * b.y; c.y = a.x.y * b.x + a.y.y * b.y; return c; }\nC2_INLINE c2v c2MulmvT(c2m a, c2v b) { c2v c; c.x = a.x.x * b.x + a.x.y * b.y; c.y = a.y.x * b.x + a.y.y * b.y; return c; }\nC2_INLINE c2m c2Mulmm(c2m a, c2m b)  { c2m c; c.x = c2Mulmv(a, b.x);  c.y = c2Mulmv(a, b.y); return c; }\nC2_INLINE c2m c2MulmmT(c2m a, c2m b) { c2m c; c.x = c2MulmvT(a, b.x); c.y = c2MulmvT(a, b.y); return c; }\n\n// transform ops\nC2_INLINE c2x c2xIdentity(void) { c2x x; x.p = c2V(0, 0); x.r = c2RotIdentity(); return x; }\nC2_INLINE c2v c2Mulxv(c2x a, c2v b) { return c2Add(c2Mulrv(a.r, b), a.p); }\nC2_INLINE c2v c2MulxvT(c2x a, c2v b) { return c2MulrvT(a.r, c2Sub(b, a.p)); }\nC2_INLINE c2x c2Mulxx(c2x a, c2x b) { c2x c; c.r = c2Mulrr(a.r, b.r); c.p = c2Add(c2Mulrv(a.r, b.p), a.p); return c; }\nC2_INLINE c2x c2MulxxT(c2x a, c2x b) { c2x c; c.r = c2MulrrT(a.r, b.r); c.p = c2MulrvT(a.r, c2Sub(b.p, a.p)); return c; }\nC2_INLINE c2x c2Transform(c2v p, float radians) { c2x x; x.r = c2Rot(radians); x.p = p; return x; }\n\n// halfspace ops\nC2_INLINE c2v c2Origin(c2h h) { return c2Mulvs(h.n, h.d); }\nC2_INLINE float c2Dist(c2h h, c2v p) { return c2Dot(h.n, p) - h.d; }\nC2_INLINE c2v c2Project(c2h h, c2v p) { return c2Sub(p, c2Mulvs(h.n, c2Dist(h, p))); }\nC2_INLINE c2h c2Mulxh(c2x a, c2h b) { c2h c; c.n = c2Mulrv(a.r, b.n); c.d = c2Dot(c2Mulxv(a, c2Origin(b)), c.n); return c; }\nC2_INLINE c2h c2MulxhT(c2x a, c2h b) { c2h c; c.n = c2MulrvT(a.r, b.n); c.d = c2Dot(c2MulxvT(a, c2Origin(b)), c.n); return c; }\nC2_INLINE c2v c2Intersect(c2v a, c2v b, float da, float db) { return c2Add(a, c2Mulvs(c2Sub(b, a), (da / (da - db)))); }\n\nC2_INLINE void c2BBVerts(c2v* out, c2AABB* bb)\n{\n\tout[0] = bb->min;\n\tout[1] = c2V(bb->max.x, bb->min.y);\n\tout[2] = bb->max;\n\tout[3] = c2V(bb->min.x, bb->max.y);\n}\n\n#define CUTE_C2_H\n#endif\n\n#ifdef CUTE_C2_IMPLEMENTATION\n#ifndef CUTE_C2_IMPLEMENTATION_ONCE\n#define CUTE_C2_IMPLEMENTATION_ONCE\n\nint c2Collided(const void* A, const c2x* ax, C2_TYPE typeA, const void* B, const c2x* bx, C2_TYPE typeB)\n{\n\tswitch (typeA)\n\t{\n\tcase C2_TYPE_CIRCLE:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  return c2CircletoCircle(*(c2Circle*)A, *(c2Circle*)B);\n\t\tcase C2_TYPE_AABB:    return c2CircletoAABB(*(c2Circle*)A, *(c2AABB*)B);\n\t\tcase C2_TYPE_CAPSULE: return c2CircletoCapsule(*(c2Circle*)A, *(c2Capsule*)B);\n\t\tcase C2_TYPE_POLY:    return c2CircletoPoly(*(c2Circle*)A, (const c2Poly*)B, bx);\n\t\tdefault:              return 0;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_AABB:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  return c2CircletoAABB(*(c2Circle*)B, *(c2AABB*)A);\n\t\tcase C2_TYPE_AABB:    return c2AABBtoAABB(*(c2AABB*)A, *(c2AABB*)B);\n\t\tcase C2_TYPE_CAPSULE: return c2AABBtoCapsule(*(c2AABB*)A, *(c2Capsule*)B);\n\t\tcase C2_TYPE_POLY:    return c2AABBtoPoly(*(c2AABB*)A, (const c2Poly*)B, bx);\n\t\tdefault:              return 0;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_CAPSULE:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  return c2CircletoCapsule(*(c2Circle*)B, *(c2Capsule*)A);\n\t\tcase C2_TYPE_AABB:    return c2AABBtoCapsule(*(c2AABB*)B, *(c2Capsule*)A);\n\t\tcase C2_TYPE_CAPSULE: return c2CapsuletoCapsule(*(c2Capsule*)A, *(c2Capsule*)B);\n\t\tcase C2_TYPE_POLY:    return c2CapsuletoPoly(*(c2Capsule*)A, (const c2Poly*)B, bx);\n\t\tdefault:              return 0;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_POLY:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  return c2CircletoPoly(*(c2Circle*)B, (const c2Poly*)A, ax);\n\t\tcase C2_TYPE_AABB:    return c2AABBtoPoly(*(c2AABB*)B, (const c2Poly*)A, ax);\n\t\tcase C2_TYPE_CAPSULE: return c2CapsuletoPoly(*(c2Capsule*)B, (const c2Poly*)A, ax);\n\t\tcase C2_TYPE_POLY:    return c2PolytoPoly((const c2Poly*)A, ax, (const c2Poly*)B, bx);\n\t\tdefault:              return 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid c2Collide(const void* A, const c2x* ax, C2_TYPE typeA, const void* B, const c2x* bx, C2_TYPE typeB, c2Manifold* m)\n{\n\tm->count = 0;\n\n\tswitch (typeA)\n\t{\n\tcase C2_TYPE_CIRCLE:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  c2CircletoCircleManifold(*(c2Circle*)A, *(c2Circle*)B, m); break;\n\t\tcase C2_TYPE_AABB:    c2CircletoAABBManifold(*(c2Circle*)A, *(c2AABB*)B, m); break;\n\t\tcase C2_TYPE_CAPSULE: c2CircletoCapsuleManifold(*(c2Circle*)A, *(c2Capsule*)B, m); break;\n\t\tcase C2_TYPE_POLY:    c2CircletoPolyManifold(*(c2Circle*)A, (const c2Poly*)B, bx, m); break;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_AABB:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  c2CircletoAABBManifold(*(c2Circle*)B, *(c2AABB*)A, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_AABB:    c2AABBtoAABBManifold(*(c2AABB*)A, *(c2AABB*)B, m); break;\n\t\tcase C2_TYPE_CAPSULE: c2AABBtoCapsuleManifold(*(c2AABB*)A, *(c2Capsule*)B, m); break;\n\t\tcase C2_TYPE_POLY:    c2AABBtoPolyManifold(*(c2AABB*)A, (const c2Poly*)B, bx, m); break;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_CAPSULE:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  c2CircletoCapsuleManifold(*(c2Circle*)B, *(c2Capsule*)A, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_AABB:    c2AABBtoCapsuleManifold(*(c2AABB*)B, *(c2Capsule*)A, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_CAPSULE: c2CapsuletoCapsuleManifold(*(c2Capsule*)A, *(c2Capsule*)B, m); break;\n\t\tcase C2_TYPE_POLY:    c2CapsuletoPolyManifold(*(c2Capsule*)A, (const c2Poly*)B, bx, m); break;\n\t\t}\n\t\tbreak;\n\n\tcase C2_TYPE_POLY:\n\t\tswitch (typeB)\n\t\t{\n\t\tcase C2_TYPE_CIRCLE:  c2CircletoPolyManifold(*(c2Circle*)B, (const c2Poly*)A, ax, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_AABB:    c2AABBtoPolyManifold(*(c2AABB*)B, (const c2Poly*)A, ax, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_CAPSULE: c2CapsuletoPolyManifold(*(c2Capsule*)B, (const c2Poly*)A, ax, m); m->n = c2Neg(m->n); break;\n\t\tcase C2_TYPE_POLY:    c2PolytoPolyManifold((const c2Poly*)A, ax, (const c2Poly*)B, bx, m); break;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nint c2CastRay(c2Ray A, const void* B, const c2x* bx, C2_TYPE typeB, c2Raycast* out)\n{\n\tswitch (typeB)\n\t{\n\tcase C2_TYPE_CIRCLE:  return c2RaytoCircle(A, *(c2Circle*)B, out);\n\tcase C2_TYPE_AABB:    return c2RaytoAABB(A, *(c2AABB*)B, out);\n\tcase C2_TYPE_CAPSULE: return c2RaytoCapsule(A, *(c2Capsule*)B, out);\n\tcase C2_TYPE_POLY:    return c2RaytoPoly(A, (const c2Poly*)B, bx, out);\n\t}\n\n\treturn 0;\n}\n\n#define C2_GJK_ITERS 20\n\ntypedef struct\n{\n\tfloat radius;\n\tint count;\n\tc2v verts[C2_MAX_POLYGON_VERTS];\n} c2Proxy;\n\ntypedef struct\n{\n\tc2v sA;\n\tc2v sB;\n\tc2v p;\n\tfloat u;\n\tint iA;\n\tint iB;\n} c2sv;\n\ntypedef struct\n{\n\tc2sv a, b, c, d;\n\tfloat div;\n\tint count;\n} c2Simplex;\n\nstatic C2_INLINE void c2MakeProxy(const void* shape, C2_TYPE type, c2Proxy* p)\n{\n\tswitch (type)\n\t{\n\tcase C2_TYPE_CIRCLE:\n\t{\n\t\tc2Circle* c = (c2Circle*)shape;\n\t\tp->radius = c->r;\n\t\tp->count = 1;\n\t\tp->verts[0] = c->p;\n\t}\tbreak;\n\n\tcase C2_TYPE_AABB:\n\t{\n\t\tc2AABB* bb = (c2AABB*)shape;\n\t\tp->radius = 0;\n\t\tp->count = 4;\n\t\tc2BBVerts(p->verts, bb);\n\t}\tbreak;\n\n\tcase C2_TYPE_CAPSULE:\n\t{\n\t\tc2Capsule* c = (c2Capsule*)shape;\n\t\tp->radius = c->r;\n\t\tp->count = 2;\n\t\tp->verts[0] = c->a;\n\t\tp->verts[1] = c->b;\n\t}\tbreak;\n\n\tcase C2_TYPE_POLY:\n\t{\n\t\tc2Poly* poly = (c2Poly*)shape;\n\t\tp->radius = 0;\n\t\tp->count = poly->count;\n\t\tfor (int i = 0; i < p->count; ++i) p->verts[i] = poly->verts[i];\n\t}\tbreak;\n\t}\n}\n\nstatic C2_INLINE int c2Support(const c2v* verts, int count, c2v d)\n{\n\tint imax = 0;\n\tfloat dmax = c2Dot(verts[0], d);\n\n\tfor (int i = 1; i < count; ++i)\n\t{\n\t\tfloat dot = c2Dot(verts[i], d);\n\t\tif (dot > dmax)\n\t\t{\n\t\t\timax = i;\n\t\t\tdmax = dot;\n\t\t}\n\t}\n\n\treturn imax;\n}\n\n#define C2_BARY(n, x) c2Mulvs(s->n.x, (den * s->n.u))\n#define C2_BARY2(x) c2Add(C2_BARY(a, x), C2_BARY(b, x))\n#define C2_BARY3(x) c2Add(c2Add(C2_BARY(a, x), C2_BARY(b, x)), C2_BARY(c, x))\n\nstatic C2_INLINE c2v c2L(c2Simplex* s)\n{\n\tfloat den = 1.0f / s->div;\n\tswitch (s->count)\n\t{\n\tcase 1: return s->a.p;\n\tcase 2: return C2_BARY2(p);\n\tdefault: return c2V(0, 0);\n\t}\n}\n\nstatic C2_INLINE void c2Witness(c2Simplex* s, c2v* a, c2v* b)\n{\n\tfloat den = 1.0f / s->div;\n\tswitch (s->count)\n\t{\n\tcase 1: *a = s->a.sA; *b = s->a.sB; break;\n\tcase 2: *a = C2_BARY2(sA); *b = C2_BARY2(sB); break;\n\tcase 3: *a = C2_BARY3(sA); *b = C2_BARY3(sB); break;\n\tdefault: *a = c2V(0, 0); *b = c2V(0, 0);\n\t}\n}\n\nstatic C2_INLINE c2v c2D(c2Simplex* s)\n{\n\tswitch (s->count)\n\t{\n\tcase 1: return c2Neg(s->a.p);\n\tcase 2:\n\t{\n\t\tc2v ab = c2Sub(s->b.p, s->a.p);\n\t\tif (c2Det2(ab, c2Neg(s->a.p)) > 0) return c2Skew(ab);\n\t\treturn c2CCW90(ab);\n\t}\n\tcase 3:\n\tdefault: return c2V(0, 0);\n\t}\n}\n\nstatic C2_INLINE void c22(c2Simplex* s)\n{\n\tc2v a = s->a.p;\n\tc2v b = s->b.p;\n\tfloat u = c2Dot(b, c2Sub(b, a));\n\tfloat v = c2Dot(a, c2Sub(a, b));\n\n\tif (v <= 0)\n\t{\n\t\ts->a.u = 1.0f;\n\t\ts->div = 1.0f;\n\t\ts->count = 1;\n\t}\n\n\telse if (u <= 0)\n\t{\n\t\ts->a = s->b;\n\t\ts->a.u = 1.0f;\n\t\ts->div = 1.0f;\n\t\ts->count = 1;\n\t}\n\n\telse\n\t{\n\t\ts->a.u = u;\n\t\ts->b.u = v;\n\t\ts->div = u + v;\n\t\ts->count = 2;\n\t}\n}\n\nstatic C2_INLINE void c23(c2Simplex* s)\n{\n\tc2v a = s->a.p;\n\tc2v b = s->b.p;\n\tc2v c = s->c.p;\n\n\tfloat uAB = c2Dot(b, c2Sub(b, a));\n\tfloat vAB = c2Dot(a, c2Sub(a, b));\n\tfloat uBC = c2Dot(c, c2Sub(c, b));\n\tfloat vBC = c2Dot(b, c2Sub(b, c));\n\tfloat uCA = c2Dot(a, c2Sub(a, c));\n\tfloat vCA = c2Dot(c, c2Sub(c, a));\n\tfloat area = c2Det2(c2Sub(b, a), c2Sub(c, a));\n\tfloat uABC = c2Det2(b, c) * area;\n\tfloat vABC = c2Det2(c, a) * area;\n\tfloat wABC = c2Det2(a, b) * area;\n\n\tif (vAB <= 0 && uCA <= 0)\n\t{\n\t\ts->a.u = 1.0f;\n\t\ts->div = 1.0f;\n\t\ts->count = 1;\n\t}\n\n\telse if (uAB <= 0 && vBC <= 0)\n\t{\n\t\ts->a = s->b;\n\t\ts->a.u = 1.0f;\n\t\ts->div = 1.0f;\n\t\ts->count = 1;\n\t}\n\n\telse if (uBC <= 0 && vCA <= 0)\n\t{\n\t\ts->a = s->c;\n\t\ts->a.u = 1.0f;\n\t\ts->div = 1.0f;\n\t\ts->count = 1;\n\t}\n\n\telse if (uAB > 0 && vAB > 0 && wABC <= 0)\n\t{\n\t\ts->a.u = uAB;\n\t\ts->b.u = vAB;\n\t\ts->div = uAB + vAB;\n\t\ts->count = 2;\n\t}\n\n\telse if (uBC > 0 && vBC > 0 && uABC <= 0)\n\t{\n\t\ts->a = s->b;\n\t\ts->b = s->c;\n\t\ts->a.u = uBC;\n\t\ts->b.u = vBC;\n\t\ts->div = uBC + vBC;\n\t\ts->count = 2;\n\t}\n\n\telse if (uCA > 0 && vCA > 0 && vABC <= 0)\n\t{\n\t\ts->b = s->a;\n\t\ts->a = s->c;\n\t\ts->a.u = uCA;\n\t\ts->b.u = vCA;\n\t\ts->div = uCA + vCA;\n\t\ts->count = 2;\n\t}\n\n\telse\n\t{\n\t\ts->a.u = uABC;\n\t\ts->b.u = vABC;\n\t\ts->c.u = wABC;\n\t\ts->div = uABC + vABC + wABC;\n\t\ts->count = 3;\n\t}\n}\n\n#include <float.h>\n\nstatic C2_INLINE float c2GJKSimplexMetric(c2Simplex* s)\n{\n\tswitch (s->count)\n\t{\n\tdefault: // fall through\n\tcase 1:  return 0;\n\tcase 2:  return c2Len(c2Sub(s->b.p, s->a.p));\n\tcase 3:  return c2Det2(c2Sub(s->b.p, s->a.p), c2Sub(s->c.p, s->a.p));\n\t}\n}\n\n// Please see http://box2d.org/downloads/ under GDC 2010 for Erin's demo code\n// and PDF slides for documentation on the GJK algorithm. This function is mostly\n// from Erin's version from his online resources.\nfloat c2GJK(const void* A, C2_TYPE typeA, const c2x* ax_ptr, const void* B, C2_TYPE typeB, const c2x* bx_ptr, c2v* outA, c2v* outB, int use_radius, int* iterations, c2GJKCache* cache)\n{\n\tc2x ax;\n\tc2x bx;\n\tif (!ax_ptr) ax = c2xIdentity();\n\telse ax = *ax_ptr;\n\tif (!bx_ptr) bx = c2xIdentity();\n\telse bx = *bx_ptr;\n\n\tc2Proxy pA;\n\tc2Proxy pB;\n\tc2MakeProxy(A, typeA, &pA);\n\tc2MakeProxy(B, typeB, &pB);\n\n\tc2Simplex s;\n\tc2sv* verts = &s.a;\n\n\t// Metric and caching system as designed by E. Catto in Box2D for his conservative advancment/bilateral\n\t// advancement algorithim implementations. The purpose is to reuse old simplex indices (any simplex that\n\t// have not degenerated into a line or point) as a starting point. This skips the first few iterations of\n\t// GJK going from point, to line, to triangle, lowering convergence rates dramatically for temporally\n\t// coherent cases (such as in time of impact searches).\n\tint cache_was_read = 0;\n\tif (cache)\n\t{\n\t\tint cache_was_good = !!cache->count;\n\n\t\tif (cache_was_good)\n\t\t{\n\t\t\tfor (int i = 0; i < cache->count; ++i)\n\t\t\t{\n\t\t\t\tint iA = cache->iA[i];\n\t\t\t\tint iB = cache->iB[i];\n\t\t\t\tc2v sA = c2Mulxv(ax, pA.verts[iA]);\n\t\t\t\tc2v sB = c2Mulxv(bx, pB.verts[iB]);\n\t\t\t\tc2sv* v = verts + i;\n\t\t\t\tv->iA = iA;\n\t\t\t\tv->sA = sA;\n\t\t\t\tv->iB = iB;\n\t\t\t\tv->sB = sB;\n\t\t\t\tv->p = c2Sub(v->sB, v->sA);\n\t\t\t\tv->u = 0;\n\t\t\t}\n\t\t\ts.count = cache->count;\n\t\t\ts.div = cache->div;\n\n\t\t\tfloat metric_old = cache->metric;\n\t\t\tfloat metric = c2GJKSimplexMetric(&s);\n\n\t\t\tfloat min_metric = metric < metric_old ? metric : metric_old;\n\t\t\tfloat max_metric = metric > metric_old ? metric : metric_old;\n\n\t\t\tif (!(min_metric < max_metric * 2.0f && metric < -1.0e8f)) cache_was_read = 1;\n\t\t}\n\t}\n\n\tif (!cache_was_read)\n\t{\n\t\ts.a.iA = 0;\n\t\ts.a.iB = 0;\n\t\ts.a.sA = c2Mulxv(ax, pA.verts[0]);\n\t\ts.a.sB = c2Mulxv(bx, pB.verts[0]);\n\t\ts.a.p = c2Sub(s.a.sB, s.a.sA);\n\t\ts.a.u = 1.0f;\n\t\ts.div = 1.0f;\n\t\ts.count = 1;\n\t}\n\n\tint saveA[3], saveB[3];\n\tint save_count = 0;\n\tfloat d0 = FLT_MAX;\n\tfloat d1 = FLT_MAX;\n\tint iter = 0;\n\tint hit = 0;\n\twhile (iter < C2_GJK_ITERS)\n\t{\n\t\tsave_count = s.count;\n\t\tfor (int i = 0; i < save_count; ++i)\n\t\t{\n\t\t\tsaveA[i] = verts[i].iA;\n\t\t\tsaveB[i] = verts[i].iB;\n\t\t}\n\t\t\n\t\tswitch (s.count)\n\t\t{\n\t\tcase 1: break;\n\t\tcase 2: c22(&s); break;\n\t\tcase 3: c23(&s); break;\n\t\t}\n\n\t\tif (s.count == 3)\n\t\t{\n\t\t\thit = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tc2v p = c2L(&s);\n\t\td1 = c2Dot(p, p);\n\n\t\tif (d1 > d0) break;\n\t\td0 = d1;\n\n\t\tc2v d = c2D(&s);\n\t\tif (c2Dot(d, d) < FLT_EPSILON * FLT_EPSILON) break;\n\n\t\tint iA = c2Support(pA.verts, pA.count, c2MulrvT(ax.r, c2Neg(d)));\n\t\tc2v sA = c2Mulxv(ax, pA.verts[iA]);\n\t\tint iB = c2Support(pB.verts, pB.count, c2MulrvT(bx.r, d));\n\t\tc2v sB = c2Mulxv(bx, pB.verts[iB]);\n\n\t\tc2sv* v = verts + s.count;\n\t\tv->iA = iA;\n\t\tv->sA = sA;\n\t\tv->iB = iB;\n\t\tv->sB = sB;\n\t\tv->p = c2Sub(v->sB, v->sA);\n\n\t\tint dup = 0;\n\t\tfor (int i = 0; i < save_count; ++i)\n\t\t{\n\t\t\tif (iA == saveA[i] && iB == saveB[i])\n\t\t\t{\n\t\t\t\tdup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) break;\n\n\t\t++s.count;\n\t\t++iter;\n\t}\n\n\tc2v a, b;\n\tc2Witness(&s, &a, &b);\n\tfloat dist = c2Len(c2Sub(a, b));\n\n\tif (hit)\n\t{\n\t\ta = b;\n\t\tdist = 0;\n\t}\n\n\telse if (use_radius)\n\t{\n\t\tfloat rA = pA.radius;\n\t\tfloat rB = pB.radius;\n\n\t\tif (dist > rA + rB && dist > FLT_EPSILON)\n\t\t{\n\t\t\tdist -= rA + rB;\n\t\t\tc2v n = c2Norm(c2Sub(b, a));\n\t\t\ta = c2Add(a, c2Mulvs(n, rA));\n\t\t\tb = c2Sub(b, c2Mulvs(n, rB));\n\t\t\tif (a.x == b.x && a.y == b.y) dist = 0;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tc2v p = c2Mulvs(c2Add(a, b), 0.5f);\n\t\t\ta = p;\n\t\t\tb = p;\n\t\t\tdist = 0;\n\t\t}\n\t}\n\n\tif (cache)\n\t{\n\t\tcache->metric = c2GJKSimplexMetric(&s);\n\t\tcache->count = s.count;\n\t\tfor (int i = 0; i < s.count; ++i)\n\t\t{\n\t\t\tc2sv* v = verts + i;\n\t\t\tcache->iA[i] = v->iA;\n\t\t\tcache->iB[i] = v->iB;\n\t\t}\n\t\tcache->div = s.div;\n\t}\n\n\tif (outA) *outA = a;\n\tif (outB) *outB = b;\n\tif (iterations) *iterations = iter;\n\treturn dist;\n}\n\n// Referenced from Box2D's b2ShapeCast function.\n// GJK-Raycast algorithm by Gino van den Bergen.\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls, 2010.\nc2TOIResult c2TOI(const void* A, C2_TYPE typeA, const c2x* ax_ptr, c2v vA, const void* B, C2_TYPE typeB, const c2x* bx_ptr, c2v vB, int use_radius)\n{\n\tfloat t = 0;\n\tc2x ax;\n\tc2x bx;\n\tif (!ax_ptr) ax = c2xIdentity();\n\telse ax = *ax_ptr;\n\tif (!bx_ptr) bx = c2xIdentity();\n\telse bx = *bx_ptr;\n\n\tc2Proxy pA;\n\tc2Proxy pB;\n\tc2MakeProxy(A, typeA, &pA);\n\tc2MakeProxy(B, typeB, &pB);\n\n\tc2Simplex s;\n\ts.count = 0;\n\tc2sv* verts = &s.a;\n\n\tc2v rv = c2Sub(vB, vA);\n\tint iA = c2Support(pA.verts, pA.count, c2MulrvT(ax.r, c2Neg(rv)));\n\tc2v sA = c2Mulxv(ax, pA.verts[iA]);\n\tint iB = c2Support(pB.verts, pB.count, c2MulrvT(bx.r, rv));\n\tc2v sB = c2Mulxv(bx, pB.verts[iB]);\n\tc2v v = c2Sub(sA, sB);\n\n\tfloat rA = pA.radius;\n\tfloat rB = pB.radius;\n\tfloat radius = rA + rB;\n\tif (!use_radius) {\n\t\trA = 0;\n\t\trB = 0;\n\t\tradius = 0;\n\t}\n\tfloat tolerance = 1.0e-4f;\n\n\tc2TOIResult result;\n\tresult.hit = 0;\n\tresult.n = c2V(0, 0);\n\tresult.p = c2V(0, 0);\n\tresult.toi = 1.0f;\n\tresult.iterations = 0;\n\n\tif (!(c2Len(v) - radius > tolerance)) {\n\t\tresult.toi = 0;\n\t\tresult.hit = 1;\n\t\treturn result;\n\t}\n\n\twhile (result.iterations < 20)\n\t{\n\t\tiA = c2Support(pA.verts, pA.count, c2MulrvT(ax.r, c2Neg(v)));\n\t\tsA = c2Mulxv(ax, pA.verts[iA]);\n\t\tiB = c2Support(pB.verts, pB.count, c2MulrvT(bx.r, v));\n\t\tsB = c2Mulxv(bx, pB.verts[iB]);\n\t\tc2v p = c2Sub(sA, sB);\n\t\tv = c2Norm(v);\n\t\tfloat vp = c2Dot(v, p) - radius;\n\t\tfloat vr = c2Dot(v, rv);\n\t\tif (vp > t * vr) {\n\t\t\tif (vr <= 0) return result;\n\t\t\tt = vp / vr;\n\t\t\tif (t > 1.0f) return result;\n\t\t\tresult.n = c2Neg(v);\n\t\t\ts.count = 0;\n\t\t}\n\n\t\tc2sv* sv = verts + s.count;\n\t\tsv->iA = iB;\n\t\tsv->sA = c2Add(sB, c2Mulvs(rv, t));\n\t\tsv->iB = iA;\n\t\tsv->sB = sA;\n\t\tsv->p = c2Sub(sv->sB, sv->sA);\n\t\tsv->u = 1.0f;\n\t\ts.count += 1;\n\n\t\tswitch (s.count)\n\t\t{\n\t\tcase 2: c22(&s); break;\n\t\tcase 3: c23(&s); break;\n\t\t}\n\n\t\tif (s.count == 3) {\n\t\t\tresult.toi = t;\n\t\t\tresult.hit = 1;\n\t\t\treturn result;\n\t\t}\n\n\t\tv = c2L(&s);\n\t\tresult.iterations++;\n\t}\n\n\tif (result.iterations == 0) {\n\t\tresult.hit = 0;\n\t} else {\n\t\tif (c2Dot(v, v) > 0) result.n = c2SafeNorm(c2Neg(v));\n\t\tint i = c2Support(pA.verts, pA.count, c2MulrvT(ax.r, result.n));\n\t\tc2v p = c2Mulxv(ax, pA.verts[i]);\n\t\tp = c2Add(c2Add(p, c2Mulvs(result.n, rA)), c2Mulvs(vA, t));\n\t\tresult.p = p;\n\t\tresult.toi = t;\n\t\tresult.hit = 1;\n\t}\n\n\treturn result;\n}\n\nint c2Hull(c2v* verts, int count)\n{\n\tif (count <= 2) return 0;\n\tcount = c2Min(C2_MAX_POLYGON_VERTS, count);\n\n\tint right = 0;\n\tfloat xmax = verts[0].x;\n\tfor (int i = 1; i < count; ++i)\n\t{\n\t\tfloat x = verts[i].x;\n\t\tif (x > xmax)\n\t\t{\n\t\t\txmax = x;\n\t\t\tright = i;\n\t\t}\n\n\t\telse if (x == xmax)\n\t\tif (verts[i].y < verts[right].y) right = i;\n\t}\n\n\tint hull[C2_MAX_POLYGON_VERTS];\n\tint out_count = 0;\n\tint index = right;\n\n\twhile (1)\n\t{\n\t\thull[out_count] = index;\n\t\tint next = 0;\n\n\t\tfor (int i = 1; i < count; ++i)\n\t\t{\n\t\t\tif (next == index)\n\t\t\t{\n\t\t\t\tnext = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc2v e1 = c2Sub(verts[next], verts[hull[out_count]]);\n\t\t\tc2v e2 = c2Sub(verts[i], verts[hull[out_count]]);\n\t\t\tfloat c = c2Det2(e1, e2);\n\t\t\tif(c < 0) next = i;\n\t\t\tif (c == 0 && c2Dot(e2, e2) > c2Dot(e1, e1)) next = i;\n\t\t}\n\n\t\t++out_count;\n\t\tindex = next;\n\t\tif (next == right) break;\n\t}\n\n\tc2v hull_verts[C2_MAX_POLYGON_VERTS];\n\tfor (int i = 0; i < out_count; ++i) hull_verts[i] = verts[hull[i]];\n\tmemcpy(verts, hull_verts, sizeof(c2v) * out_count);\n\treturn out_count;\n}\n\nvoid c2Norms(c2v* verts, c2v* norms, int count)\n{\n\tfor (int  i = 0; i < count; ++i)\n\t{\n\t\tint a = i;\n\t\tint b = i + 1 < count ? i + 1 : 0;\n\t\tc2v e = c2Sub(verts[b], verts[a]);\n\t\tnorms[i] = c2Norm(c2CCW90(e));\n\t}\n}\n\nvoid c2MakePoly(c2Poly* p)\n{\n\tp->count = c2Hull(p->verts, p->count);\n\tc2Norms(p->verts, p->norms, p->count);\n}\n\nc2Poly c2Dual(c2Poly poly, float skin_factor)\n{\n\tc2Poly dual;\n\tdual.count = poly.count;\n\n\t// Each plane maps to a point by involution (the mapping is its own inverse) by dividing\n\t// the plane normal by its offset factor.\n\t// plane = a * x + b * y - d\n\t// dual = { a / d, b / d }\n\tfor (int i = 0; i < poly.count; ++i) {\n\t\tc2v n = poly.norms[i];\n\t\tfloat d = c2Dot(n, poly.verts[i]) + skin_factor;\n\t\tif (d == 0) dual.verts[i] = c2V(0, 0);\n\t\telse dual.verts[i] = c2Div(n, d);\n\t}\n\n\t// Instead of canonically building the convex hull, can simply take advantage of how\n\t// the vertices are still in proper CCW order, so only the normals must be recomputed.\n\tc2Norms(dual.verts, dual.norms, dual.count);\n\n\treturn dual;\n}\n\n// Inflating a polytope, idea by Dirk Gregorius ~ 2015. Works in both 2D and 3D.\n// Reference: Halfspace intersection with Qhull by Brad Barber\n//            http://www.geom.uiuc.edu/graphics/pix/Special_Topics/Computational_Geometry/half.html\n//\n// Algorithm steps:\n// 1. Find a point within the input poly.\n// 2. Center this point onto the origin.\n// 3. Adjust the planes by a skin factor.\n// 4. Compute the dual vert of each plane. Each plane becomes a vertex.\n//    c2v dual(c2h plane) { return c2V(plane.n.x / plane.d, plane.n.y / plane.d) }\n// 5. Compute the convex hull of the dual verts. This is called the dual.\n// 6. Compute the dual of the dual, this will be the poly to return.\n// 7. Translate the poly away from the origin by the center point from step 2.\n// 8. Return the inflated poly.\nc2Poly c2InflatePoly(c2Poly poly, float skin_factor)\n{\n\tc2v average = poly.verts[0];\n\tfor (int i = 1; i < poly.count; ++i) {\n\t\taverage = c2Add(average, poly.verts[i]);\n\t}\n\taverage = c2Div(average, (float)poly.count);\n\n\tfor (int i = 0; i < poly.count; ++i) {\n\t\tpoly.verts[i] = c2Sub(poly.verts[i], average);\n\t}\n\n\tc2Poly dual = c2Dual(poly, skin_factor);\n\tpoly = c2Dual(dual, 0);\n\n\tfor (int i = 0; i < poly.count; ++i) {\n\t\tpoly.verts[i] = c2Add(poly.verts[i], average);\n\t}\n\n\treturn poly;\n}\n\nvoid c2Inflate(void* shape, C2_TYPE type, float skin_factor)\n{\n\tswitch (type)\n\t{\n\tcase C2_TYPE_CIRCLE:\n\t{\n\t\tc2Circle* circle = (c2Circle*)shape;\n\t\tcircle->r += skin_factor;\n\t}\tbreak;\n\n\tcase C2_TYPE_AABB:\n\t{\n\t\tc2AABB* bb = (c2AABB*)shape;\n\t\tc2v factor = c2V(skin_factor, skin_factor);\n\t\tbb->min = c2Sub(bb->min, factor);\n\t\tbb->max = c2Add(bb->max, factor);\n\t}\tbreak;\n\n\tcase C2_TYPE_CAPSULE:\n\t{\n\t\tc2Capsule* capsule = (c2Capsule*)shape;\n\t\tcapsule->r += skin_factor;\n\t}\tbreak;\n\n\tcase C2_TYPE_POLY:\n\t{\n\t\tc2Poly* poly = (c2Poly*)shape;\n\t\t*poly = c2InflatePoly(*poly, skin_factor);\n\t}\tbreak;\n\t}\n}\n\nint c2CircletoCircle(c2Circle A, c2Circle B)\n{\n\tc2v c = c2Sub(B.p, A.p);\n\tfloat d2 = c2Dot(c, c);\n\tfloat r2 = A.r + B.r;\n\tr2 = r2 * r2;\n\treturn d2 < r2;\n}\n\nint c2CircletoAABB(c2Circle A, c2AABB B)\n{\n\tc2v L = c2Clampv(A.p, B.min, B.max);\n\tc2v ab = c2Sub(A.p, L);\n\tfloat d2 = c2Dot(ab, ab);\n\tfloat r2 = A.r * A.r;\n\treturn d2 < r2;\n}\n\nint c2AABBtoAABB(c2AABB A, c2AABB B)\n{\n\tint d0 = B.max.x < A.min.x;\n\tint d1 = A.max.x < B.min.x;\n\tint d2 = B.max.y < A.min.y;\n\tint d3 = A.max.y < B.min.y;\n\treturn !(d0 | d1 | d2 | d3);\n}\n\nint c2AABBtoPoint(c2AABB A, c2v B)\n{\n\tint d0 = B.x < A.min.x;\n\tint d1 = B.y < A.min.y;\n\tint d2 = B.x > A.max.x;\n\tint d3 = B.y > A.max.y;\n\treturn !(d0 | d1 | d2 | d3);\n}\n\nint c2CircleToPoint(c2Circle A, c2v B)\n{\n\tc2v n = c2Sub(A.p, B);\n\tfloat d2 = c2Dot(n, n);\n\treturn d2 < A.r * A.r;\n}\n\n// See: https://randygaul.github.io/math/collision-detection/2014/07/01/Distance-Point-to-Line-Segment.html\nint c2CircletoCapsule(c2Circle A, c2Capsule B)\n{\n\tc2v n = c2Sub(B.b, B.a);\n\tc2v ap = c2Sub(A.p, B.a);\n\tfloat da = c2Dot(ap, n);\n\tfloat d2;\n\n\tif (da < 0) d2 = c2Dot(ap, ap);\n\telse\n\t{\n\t\tfloat db = c2Dot(c2Sub(A.p, B.b), n);\n\t\tif (db < 0)\n\t\t{\n\t\t\tc2v e = c2Sub(ap, c2Mulvs(n, (da / c2Dot(n, n))));\n\t\t\td2 = c2Dot(e, e);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc2v bp = c2Sub(A.p, B.b);\n\t\t\td2 = c2Dot(bp, bp);\n\t\t}\n\t}\n\n\tfloat r = A.r + B.r;\n\treturn d2 < r * r;\n}\n\nint c2AABBtoCapsule(c2AABB A, c2Capsule B)\n{\n\tif (c2GJK(&A, C2_TYPE_AABB, 0, &B, C2_TYPE_CAPSULE, 0, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2CapsuletoCapsule(c2Capsule A, c2Capsule B)\n{\n\tif (c2GJK(&A, C2_TYPE_CAPSULE, 0, &B, C2_TYPE_CAPSULE, 0, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2CircletoPoly(c2Circle A, const c2Poly* B, const c2x* bx)\n{\n\tif (c2GJK(&A, C2_TYPE_CIRCLE, 0, B, C2_TYPE_POLY, bx, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2AABBtoPoly(c2AABB A, const c2Poly* B, const c2x* bx)\n{\n\tif (c2GJK(&A, C2_TYPE_AABB, 0, B, C2_TYPE_POLY, bx, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2CapsuletoPoly(c2Capsule A, const c2Poly* B, const c2x* bx)\n{\n\tif (c2GJK(&A, C2_TYPE_CAPSULE, 0, B, C2_TYPE_POLY, bx, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2PolytoPoly(const c2Poly* A, const c2x* ax, const c2Poly* B, const c2x* bx)\n{\n\tif (c2GJK(A, C2_TYPE_POLY, ax, B, C2_TYPE_POLY, bx, 0, 0, 1, 0, 0)) return 0;\n\treturn 1;\n}\n\nint c2RaytoCircle(c2Ray A, c2Circle B, c2Raycast* out)\n{\n\tc2v p = B.p;\n\tc2v m = c2Sub(A.p, p);\n\tfloat c = c2Dot(m, m) - B.r * B.r;\n\tfloat b = c2Dot(m, A.d);\n\tfloat disc = b * b - c;\n\tif (disc < 0) return 0;\n\n\tfloat t = -b - c2Sqrt(disc);\n\tif (t >= 0 && t <= A.t)\n\t{\n\t\tout->t = t;\n\t\tc2v impact = c2Impact(A, t);\n\t\tout->n = c2Norm(c2Sub(impact, p));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline float c2SignedDistPointToPlane_OneDimensional(float p, float n, float d)\n{\n\treturn p * n - d * n;\n}\n\nstatic inline float c2RayToPlane_OneDimensional(float da, float db)\n{\n\tif (da < 0) return 0; // Ray started behind plane.\n\telse if (da * db > 0) return 1.0f; // Ray starts and ends on the same of the plane.\n\telse // Ray starts and ends on opposite sides of the plane (or directly on the plane).\n\t{\n\t\tfloat d = da - db;\n\t\tif (d != 0) return da / d;\n\t\telse return 0; // Special case for super tiny ray, or AABB.\n\t}\n}\n\nint c2RaytoAABB(c2Ray A, c2AABB B, c2Raycast* out)\n{\n\tc2v p0 = A.p;\n\tc2v p1 = c2Impact(A, A.t);\n\tc2AABB a_box;\n\ta_box.min = c2Minv(p0, p1);\n\ta_box.max = c2Maxv(p0, p1);\n\n\t// Test B's axes.\n\tif (!c2AABBtoAABB(a_box, B)) return 0;\n\n\t// Test the ray's axes (along the segment's normal).\n\tc2v ab = c2Sub(p1, p0);\n\tc2v n = c2Skew(ab);\n\tc2v abs_n = c2Absv(n);\n\tc2v half_extents = c2Mulvs(c2Sub(B.max, B.min), 0.5f);\n\tc2v center_of_b_box = c2Mulvs(c2Add(B.min, B.max), 0.5f);\n\tfloat d = c2Abs(c2Dot(n, c2Sub(p0, center_of_b_box))) - c2Dot(abs_n, half_extents);\n\tif (d > 0) return 0;\n\n\t// Calculate intermediate values up-front.\n\t// This should play well with superscalar architecture.\n\tfloat da0 = c2SignedDistPointToPlane_OneDimensional(p0.x, -1.0f, B.min.x);\n\tfloat db0 = c2SignedDistPointToPlane_OneDimensional(p1.x, -1.0f, B.min.x);\n\tfloat da1 = c2SignedDistPointToPlane_OneDimensional(p0.x,  1.0f, B.max.x);\n\tfloat db1 = c2SignedDistPointToPlane_OneDimensional(p1.x,  1.0f, B.max.x);\n\tfloat da2 = c2SignedDistPointToPlane_OneDimensional(p0.y, -1.0f, B.min.y);\n\tfloat db2 = c2SignedDistPointToPlane_OneDimensional(p1.y, -1.0f, B.min.y);\n\tfloat da3 = c2SignedDistPointToPlane_OneDimensional(p0.y,  1.0f, B.max.y);\n\tfloat db3 = c2SignedDistPointToPlane_OneDimensional(p1.y,  1.0f, B.max.y);\n\tfloat t0 = c2RayToPlane_OneDimensional(da0, db0);\n\tfloat t1 = c2RayToPlane_OneDimensional(da1, db1);\n\tfloat t2 = c2RayToPlane_OneDimensional(da2, db2);\n\tfloat t3 = c2RayToPlane_OneDimensional(da3, db3);\n\n\t// Calculate hit predicate, no branching.\n\tint hit0 = t0 <= 1.0f;\n\tint hit1 = t1 <= 1.0f;\n\tint hit2 = t2 <= 1.0f;\n\tint hit3 = t3 <= 1.0f;\n\tint hit = hit0 | hit1 | hit2 | hit3;\n\n\tif (hit)\n\t{\n\t\t// Remap t's within 0-1 range, where >= 1 is treated as 0.\n\t\tt0 = (float)hit0 * t0;\n\t\tt1 = (float)hit1 * t1;\n\t\tt2 = (float)hit2 * t2;\n\t\tt3 = (float)hit3 * t3;\n\n\t\t// Sort output by finding largest t to deduce the normal.\n\t\tif (t0 >= t1 && t0 >= t2 && t0 >= t3)\n\t\t{\n\t\t\tout->t = t0 * A.t;\n\t\t\tout->n = c2V(-1, 0);\n\t\t}\n\t\t\n\t\telse if (t1 >= t0 && t1 >= t2 && t1 >= t3)\n\t\t{\n\t\t\tout->t = t1 * A.t;\n\t\t\tout->n = c2V(1, 0);\n\t\t}\n\t\t\n\t\telse if (t2 >= t0 && t2 >= t1 && t2 >= t3)\n\t\t{\n\t\t\tout->t = t2 * A.t;\n\t\t\tout->n = c2V(0, -1);\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tout->t = t3 * A.t;\n\t\t\tout->n = c2V(0, 1);\n\t\t}\n\n\t\treturn 1;\n\t} else return 0; // This can still numerically happen.\n}\n\nint c2RaytoCapsule(c2Ray A, c2Capsule B, c2Raycast* out)\n{\n\tc2m M;\n\tM.y = c2Norm(c2Sub(B.b, B.a));\n\tM.x = c2CCW90(M.y);\n\n\t// rotate capsule to origin, along Y axis\n\t// rotate the ray same way\n\tc2v cap_n = c2Sub(B.b, B.a);\n\tc2v yBb = c2MulmvT(M, cap_n);\n\tc2v yAp = c2MulmvT(M, c2Sub(A.p, B.a));\n\tc2v yAd = c2MulmvT(M, A.d);\n\tc2v yAe = c2Add(yAp, c2Mulvs(yAd, A.t));\n\n\tc2AABB capsule_bb;\n\tcapsule_bb.min = c2V(-B.r, 0);\n\tcapsule_bb.max = c2V(B.r, yBb.y);\n\n\tout->n = c2Norm(cap_n);\n\tout->t = 0;\n\n\t// check and see if ray starts within the capsule\n\tif (c2AABBtoPoint(capsule_bb, yAp)) {\n\t\treturn 1;\n\t} else {\n\t\tc2Circle capsule_a;\n\t\tc2Circle capsule_b;\n\t\tcapsule_a.p = B.a;\n\t\tcapsule_a.r = B.r;\n\t\tcapsule_b.p = B.b;\n\t\tcapsule_b.r = B.r;\n\n\t\tif (c2CircleToPoint(capsule_a, A.p)) {\n\t\t\treturn 1;\n\t\t} else if (c2CircleToPoint(capsule_b, A.p)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (yAe.x * yAp.x < 0 || c2Min(c2Abs(yAe.x), c2Abs(yAp.x)) < B.r)\n\t{\n\t\tc2Circle Ca, Cb;\n\t\tCa.p = B.a;\n\t\tCa.r = B.r;\n\t\tCb.p = B.b;\n\t\tCb.r = B.r;\n\n\t\t// ray starts inside capsule prism -- must hit one of the semi-circles\n\t\tif (c2Abs(yAp.x) < B.r) {\n\t\t\tif (yAp.y < 0) return c2RaytoCircle(A, Ca, out);\n\t\t\telse return c2RaytoCircle(A, Cb, out);\n\t\t}\n\n\t\t// hit the capsule prism\n\t\telse\n\t\t{\n\t\t\tfloat c = yAp.x > 0 ? B.r : -B.r;\n\t\t\tfloat d = (yAe.x - yAp.x);\n\t\t\tfloat t = (c - yAp.x) / d;\n\t\t\tfloat y = yAp.y + (yAe.y - yAp.y) * t;\n\t\t\tif (y <= 0) return c2RaytoCircle(A, Ca, out);\n\t\t\tif (y >= yBb.y) return c2RaytoCircle(A, Cb, out);\n\t\t\telse {\n\t\t\t\tout->n = c > 0 ? M.x : c2Skew(M.y);\n\t\t\t\tout->t = t * A.t;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint c2RaytoPoly(c2Ray A, const c2Poly* B, const c2x* bx_ptr, c2Raycast* out)\n{\n\tc2x bx = bx_ptr ? *bx_ptr : c2xIdentity();\n\tc2v p = c2MulxvT(bx, A.p);\n\tc2v d = c2MulrvT(bx.r, A.d);\n\tfloat lo = 0;\n\tfloat hi = A.t;\n\tint index = ~0;\n\n\t// test ray to each plane, tracking lo/hi times of intersection\n\tfor (int i = 0; i < B->count; ++i)\n\t{\n\t\tfloat num = c2Dot(B->norms[i], c2Sub(B->verts[i], p));\n\t\tfloat den = c2Dot(B->norms[i], d);\n\t\tif (den == 0 && num < 0) return 0;\n\t\telse\n\t\t{\n\t\t\tif (den < 0 && num < lo * den)\n\t\t\t{\n\t\t\t\tlo = num / den;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\telse if (den > 0 && num < hi * den) hi = num / den;\n\t\t}\n\t\tif (hi < lo) return 0;\n\t}\n\n\tif (index != ~0)\n\t{\n\t\tout->t = lo;\n\t\tout->n = c2Mulrv(bx.r, B->norms[index]);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid c2CircletoCircleManifold(c2Circle A, c2Circle B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v d = c2Sub(B.p, A.p);\n\tfloat d2 = c2Dot(d, d);\n\tfloat r = A.r + B.r;\n\tif (d2 < r * r)\n\t{\n\t\tfloat l = c2Sqrt(d2);\n\t\tc2v n = l != 0 ? c2Mulvs(d, 1.0f / l) : c2V(0, 1.0f);\n\t\tm->count = 1;\n\t\tm->depths[0] = r - l;\n\t\tm->contact_points[0] = c2Sub(B.p, c2Mulvs(n, B.r));\n\t\tm->n = n;\n\t}\n}\n\nvoid c2CircletoAABBManifold(c2Circle A, c2AABB B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v L = c2Clampv(A.p, B.min, B.max);\n\tc2v ab = c2Sub(L, A.p);\n\tfloat d2 = c2Dot(ab, ab);\n\tfloat r2 = A.r * A.r;\n\tif (d2 < r2)\n\t{\n\t\t// shallow (center of circle not inside of AABB)\n\t\tif (d2 != 0)\n\t\t{\n\t\t\tfloat d = c2Sqrt(d2);\n\t\t\tc2v n = c2Norm(ab);\n\t\t\tm->count = 1;\n\t\t\tm->depths[0] = A.r - d;\n\t\t\tm->contact_points[0] = c2Add(A.p, c2Mulvs(n, d));\n\t\t\tm->n = n;\n\t\t}\n\n\t\t// deep (center of circle inside of AABB)\n\t\t// clamp circle's center to edge of AABB, then form the manifold\n\t\telse\n\t\t{\n\t\t\tc2v mid = c2Mulvs(c2Add(B.min, B.max), 0.5f);\n\t\t\tc2v e = c2Mulvs(c2Sub(B.max, B.min), 0.5f);\n\t\t\tc2v d = c2Sub(A.p, mid);\n\t\t\tc2v abs_d = c2Absv(d);\n\n\t\t\tfloat x_overlap = e.x - abs_d.x;\n\t\t\tfloat y_overlap = e.y - abs_d.y;\n\n\t\t\tfloat depth;\n\t\t\tc2v n;\n\n\t\t\tif (x_overlap < y_overlap)\n\t\t\t{\n\t\t\t\tdepth = x_overlap;\n\t\t\t\tn = c2V(1.0f, 0);\n\t\t\t\tn = c2Mulvs(n, d.x < 0 ? 1.0f : -1.0f);\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tdepth = y_overlap;\n\t\t\t\tn = c2V(0, 1.0f);\n\t\t\t\tn = c2Mulvs(n, d.y < 0 ? 1.0f : -1.0f);\n\t\t\t}\n\n\t\t\tm->count = 1;\n\t\t\tm->depths[0] = A.r + depth;\n\t\t\tm->contact_points[0] = c2Sub(A.p, c2Mulvs(n, depth));\n\t\t\tm->n = n;\n\t\t}\n\t}\n}\n\nvoid c2CircletoCapsuleManifold(c2Circle A, c2Capsule B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v a, b;\n\tfloat r = A.r + B.r;\n\tfloat d = c2GJK(&A, C2_TYPE_CIRCLE, 0, &B, C2_TYPE_CAPSULE, 0, &a, &b, 0, 0, 0);\n\tif (d < r)\n\t{\n\t\tc2v n;\n\t\tif (d == 0) n = c2Norm(c2Skew(c2Sub(B.b, B.a)));\n\t\telse n = c2Norm(c2Sub(b, a));\n\n\t\tm->count = 1;\n\t\tm->depths[0] = r - d;\n\t\tm->contact_points[0] = c2Sub(b, c2Mulvs(n, B.r));\n\t\tm->n = n;\n\t}\n}\n\nvoid c2AABBtoAABBManifold(c2AABB A, c2AABB B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v mid_a = c2Mulvs(c2Add(A.min, A.max), 0.5f);\n\tc2v mid_b = c2Mulvs(c2Add(B.min, B.max), 0.5f);\n\tc2v eA = c2Absv(c2Mulvs(c2Sub(A.max, A.min), 0.5f));\n\tc2v eB = c2Absv(c2Mulvs(c2Sub(B.max, B.min), 0.5f));\n\tc2v d = c2Sub(mid_b, mid_a);\n\n\t// calc overlap on x and y axes\n\tfloat dx = eA.x + eB.x - c2Abs(d.x);\n\tif (dx < 0) return;\n\tfloat dy = eA.y + eB.y - c2Abs(d.y);\n\tif (dy < 0) return;\n\n\tc2v n;\n\tfloat depth;\n\tc2v p;\n\n\t// x axis overlap is smaller\n\tif (dx < dy)\n\t{\n\t\tdepth = dx;\n\t\tif (d.x < 0)\n\t\t{\n\t\t\tn = c2V(-1.0f, 0);\n\t\t\tp = c2Sub(mid_a, c2V(eA.x, 0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tn = c2V(1.0f, 0);\n\t\t\tp = c2Add(mid_a, c2V(eA.x, 0));\n\t\t}\n\t}\n\n\t// y axis overlap is smaller\n\telse\n\t{\n\t\tdepth = dy;\n\t\tif (d.y < 0)\n\t\t{\n\t\t\tn = c2V(0, -1.0f);\n\t\t\tp = c2Sub(mid_a, c2V(0, eA.y));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tn = c2V(0, 1.0f);\n\t\t\tp = c2Add(mid_a, c2V(0, eA.y));\n\t\t}\n\t}\n\n\tm->count = 1;\n\tm->contact_points[0] = p;\n\tm->depths[0] = depth;\n\tm->n = n;\n}\n\nvoid c2AABBtoCapsuleManifold(c2AABB A, c2Capsule B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2Poly p;\n\tc2BBVerts(p.verts, &A);\n\tp.count = 4;\n\tc2Norms(p.verts, p.norms, 4);\n\tc2CapsuletoPolyManifold(B, &p, 0, m);\n\tm->n = c2Neg(m->n);\n}\n\nvoid c2CapsuletoCapsuleManifold(c2Capsule A, c2Capsule B, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v a, b;\n\tfloat r = A.r + B.r;\n\tfloat d = c2GJK(&A, C2_TYPE_CAPSULE, 0, &B, C2_TYPE_CAPSULE, 0, &a, &b, 0, 0, 0);\n\tif (d < r)\n\t{\n\t\tc2v n;\n\t\tif (d == 0) n = c2Norm(c2Skew(c2Sub(A.b, A.a)));\n\t\telse n = c2Norm(c2Sub(b, a));\n\n\t\tm->count = 1;\n\t\tm->depths[0] = r - d;\n\t\tm->contact_points[0] = c2Sub(b, c2Mulvs(n, B.r));\n\t\tm->n = n;\n\t}\n}\n\nstatic C2_INLINE c2h c2PlaneAt(const c2Poly* p, const int i)\n{\n\tc2h h;\n\th.n = p->norms[i];\n\th.d = c2Dot(p->norms[i], p->verts[i]);\n\treturn h;\n}\n\nvoid c2CircletoPolyManifold(c2Circle A, const c2Poly* B, const c2x* bx_tr, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v a, b;\n\tfloat d = c2GJK(&A, C2_TYPE_CIRCLE, 0, B, C2_TYPE_POLY, bx_tr, &a, &b, 0, 0, 0);\n\n\t// shallow, the circle center did not hit the polygon\n\t// just use a and b from GJK to define the collision\n\tif (d != 0)\n\t{\n\t\tc2v n = c2Sub(b, a);\n\t\tfloat l = c2Dot(n, n);\n\t\tif (l < A.r * A.r)\n\t\t{\n\t\t\tl = c2Sqrt(l);\n\t\t\tm->count = 1;\n\t\t\tm->contact_points[0] = b;\n\t\t\tm->depths[0] = A.r - l;\n\t\t\tm->n = c2Mulvs(n, 1.0f / l);\n\t\t}\n\t}\n\n\t// Circle center is inside the polygon\n\t// find the face closest to circle center to form manifold\n\telse\n\t{\n\t\tc2x bx = bx_tr ? *bx_tr : c2xIdentity();\n\t\tfloat sep = -FLT_MAX;\n\t\tint index = ~0;\n\t\tc2v local = c2MulxvT(bx, A.p);\n\n\t\tfor (int i = 0; i < B->count; ++i)\n\t\t{\n\t\t\tc2h h = c2PlaneAt(B, i);\n\t\t\td = c2Dist(h, local);\n\t\t\tif (d > A.r) return;\n\t\t\tif (d > sep)\n\t\t\t{\n\t\t\t\tsep = d;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\n\t\tc2h h = c2PlaneAt(B, index);\n\t\tc2v p = c2Project(h, local);\n\t\tm->count = 1;\n\t\tm->contact_points[0] = c2Mulxv(bx, p);\n\t\tm->depths[0] = A.r - sep;\n\t\tm->n = c2Neg(c2Mulrv(bx.r, B->norms[index]));\n\t}\n}\n\n// Forms a c2Poly and uses c2PolytoPolyManifold\nvoid c2AABBtoPolyManifold(c2AABB A, const c2Poly* B, const c2x* bx, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2Poly p;\n\tc2BBVerts(p.verts, &A);\n\tp.count = 4;\n\tc2Norms(p.verts, p.norms, 4);\n\tc2PolytoPolyManifold(&p, 0, B, bx, m);\n}\n\n// clip a segment to a plane\nstatic int c2Clip(c2v* seg, c2h h)\n{\n\tc2v out[2];\n\tint sp = 0;\n\tfloat d0, d1;\n\tif ((d0 = c2Dist(h, seg[0])) < 0) out[sp++] = seg[0];\n\tif ((d1 = c2Dist(h, seg[1])) < 0) out[sp++] = seg[1];\n\tif (d0 == 0 && d1 == 0) {\n\t\tout[sp++] = seg[0];\n\t\tout[sp++] = seg[1];\n\t} else if (d0 * d1 <= 0) out[sp++] = c2Intersect(seg[0], seg[1], d0, d1);\n\tseg[0] = out[0]; seg[1] = out[1];\n\treturn sp;\n}\n\n#ifdef _MSC_VER\n\t#pragma warning(push)\n\t#pragma warning(disable:4204) // nonstandard extension used: non-constant aggregate initializer\n#endif\n\nstatic int c2SidePlanes(c2v* seg, c2v ra, c2v rb, c2h* h)\n{\n\tc2v in = c2Norm(c2Sub(rb, ra));\n\tc2h left = { c2Neg(in), c2Dot(c2Neg(in), ra) };\n\tc2h right = { in, c2Dot(in, rb) };\n\tif (c2Clip(seg, left) < 2) return 0;\n\tif (c2Clip(seg, right) < 2) return 0;\n\tif (h) {\n\t\th->n = c2CCW90(in);\n\t\th->d = c2Dot(c2CCW90(in), ra);\n\t}\n\treturn 1;\n}\n\n// clip a segment to the \"side planes\" of another segment.\n// side planes are planes orthogonal to a segment and attached to the\n// endpoints of the segment\nstatic int c2SidePlanesFromPoly(c2v* seg, c2x x, const c2Poly* p, int e, c2h* h)\n{\n\tc2v ra = c2Mulxv(x, p->verts[e]);\n\tc2v rb = c2Mulxv(x, p->verts[e + 1 == p->count ? 0 : e + 1]);\n\treturn c2SidePlanes(seg, ra, rb, h);\n}\n\nstatic void c2KeepDeep(c2v* seg, c2h h, c2Manifold* m)\n{\n\tint cp = 0;\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tc2v p = seg[i];\n\t\tfloat d = c2Dist(h, p);\n\t\tif (d <= 0)\n\t\t{\n\t\t\tm->contact_points[cp] = p;\n\t\t\tm->depths[cp] = -d;\n\t\t\t++cp;\n\t\t}\n\t}\n\tm->count = cp;\n\tm->n = h.n;\n}\n\nstatic C2_INLINE c2v c2CapsuleSupport(c2Capsule A, c2v dir)\n{\n\tfloat da = c2Dot(A.a, dir);\n\tfloat db = c2Dot(A.b, dir);\n\tif (da > db) return c2Add(A.a, c2Mulvs(dir, A.r));\n\telse return c2Add(A.b, c2Mulvs(dir, A.r));\n}\n\nstatic void c2AntinormalFace(c2Capsule cap, const c2Poly* p, c2x x, int* face_out, c2v* n_out)\n{\n\tfloat sep = -FLT_MAX;\n\tint index = ~0;\n\tc2v n = c2V(0, 0);\n\tfor (int i = 0; i < p->count; ++i)\n\t{\n\t\tc2h h = c2Mulxh(x, c2PlaneAt(p, i));\n\t\tc2v n0 = c2Neg(h.n);\n\t\tc2v s = c2CapsuleSupport(cap, n0);\n\t\tfloat d = c2Dist(h, s);\n\t\tif (d > sep)\n\t\t{\n\t\t\tsep = d;\n\t\t\tindex = i;\n\t\t\tn = n0;\n\t\t}\n\t}\n\t*face_out = index;\n\t*n_out = n;\n}\n\nstatic void c2Incident(c2v* incident, const c2Poly* ip, c2x ix, c2v rn_in_incident_space)\n{\n\tint index = ~0;\n\tfloat min_dot = FLT_MAX;\n\tfor (int i = 0; i < ip->count; ++i)\n\t{\n\t\tfloat dot = c2Dot(rn_in_incident_space, ip->norms[i]);\n\t\tif (dot < min_dot)\n\t\t{\n\t\t\tmin_dot = dot;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tincident[0] = c2Mulxv(ix, ip->verts[index]);\n\tincident[1] = c2Mulxv(ix, ip->verts[index + 1 == ip->count ? 0 : index + 1]);\n}\n\nvoid c2CapsuletoPolyManifold(c2Capsule A, const c2Poly* B, const c2x* bx_ptr, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2v a, b;\n\tfloat d = c2GJK(&A, C2_TYPE_CAPSULE, 0, B, C2_TYPE_POLY, bx_ptr, &a, &b, 0, 0, 0);\n\n\t// deep, treat as segment to poly collision\n\tif (d < 1.0e-6f)\n\t{\n\t\tc2x bx = bx_ptr ? *bx_ptr : c2xIdentity();\n\t\tc2Capsule A_in_B;\n\t\tA_in_B.a = c2MulxvT(bx, A.a);\n\t\tA_in_B.b = c2MulxvT(bx, A.b);\n\t\tc2v ab = c2Norm(c2Sub(A_in_B.a, A_in_B.b));\n\n\t\t// test capsule axes\n\t\tc2h ab_h0;\n\t\tab_h0.n = c2CCW90(ab);\n\t\tab_h0.d = c2Dot(A_in_B.a, ab_h0.n);\n\t\tint v0 = c2Support(B->verts, B->count, c2Neg(ab_h0.n));\n\t\tfloat s0 = c2Dist(ab_h0, B->verts[v0]);\n\n\t\tc2h ab_h1;\n\t\tab_h1.n = c2Skew(ab);\n\t\tab_h1.d = c2Dot(A_in_B.a, ab_h1.n);\n\t\tint v1 = c2Support(B->verts, B->count, c2Neg(ab_h1.n));\n\t\tfloat s1 = c2Dist(ab_h1, B->verts[v1]);\n\n\t\t// test poly axes\n\t\tint index = ~0;\n\t\tfloat sep = -FLT_MAX;\n\t\tint code = 0;\n\t\tfor (int i = 0; i < B->count; ++i)\n\t\t{\n\t\t\tc2h h = c2PlaneAt(B, i);\n\t\t\tfloat da = c2Dot(A_in_B.a, c2Neg(h.n));\n\t\t\tfloat db = c2Dot(A_in_B.b, c2Neg(h.n));\n\t\t\tfloat d;\n\t\t\tif (da > db) d = c2Dist(h, A_in_B.a);\n\t\t\telse d = c2Dist(h, A_in_B.b);\n\t\t\tif (d > sep)\n\t\t\t{\n\t\t\t\tsep = d;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\n\t\t// track axis of minimum separation\n\t\tif (s0 > sep) {\n\t\t\tsep = s0;\n\t\t\tindex = v0;\n\t\t\tcode = 1;\n\t\t}\n\n\t\tif (s1 > sep) {\n\t\t\tsep = s1;\n\t\t\tindex = v1;\n\t\t\tcode = 2;\n\t\t}\n\n\t\tswitch (code)\n\t\t{\n\t\tcase 0: // poly face\n\t\t{\n\t\t\tc2v seg[2] = { A.a, A.b };\n\t\t\tc2h h;\n\t\t\tif (!c2SidePlanesFromPoly(seg, bx, B, index, &h)) return;\n\t\t\tc2KeepDeep(seg, h, m);\n\t\t\tm->n = c2Neg(m->n);\n\t\t}\tbreak;\n\n\t\tcase 1: // side 0 of capsule segment\n\t\t{\n\t\t\tc2v incident[2];\n\t\t\tc2Incident(incident, B, bx, ab_h0.n);\n\t\t\tc2h h;\n\t\t\tif (!c2SidePlanes(incident, A_in_B.b, A_in_B.a, &h)) return;\n\t\t\tc2KeepDeep(incident, h, m);\n\t\t}\tbreak;\n\n\t\tcase 2: // side 1 of capsule segment\n\t\t{\n\t\t\tc2v incident[2];\n\t\t\tc2Incident(incident, B, bx, ab_h1.n);\n\t\t\tc2h h;\n\t\t\tif (!c2SidePlanes(incident, A_in_B.a, A_in_B.b, &h)) return;\n\t\t\tc2KeepDeep(incident, h, m);\n\t\t}\tbreak;\n\n\t\tdefault:\n\t\t\t// should never happen.\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < m->count; ++i) m->depths[i] += A.r;\n\t}\n\n\t// shallow, use GJK results a and b to define manifold\n\telse if (d < A.r)\n\t{\n\t\tm->count = 1;\n\t\tm->n = c2Norm(c2Sub(b, a));\n\t\tm->contact_points[0] = c2Add(a, c2Mulvs(m->n, A.r));\n\t\tm->depths[0] = A.r - d;\n\t}\n}\n\n#ifdef _MSC_VER\n\t#pragma warning(pop)\n#endif\n\nstatic float c2CheckFaces(const c2Poly* A, c2x ax, const c2Poly* B, c2x bx, int* face_index)\n{\n\tc2x b_in_a = c2MulxxT(ax, bx);\n\tc2x a_in_b = c2MulxxT(bx, ax);\n\tfloat sep = -FLT_MAX;\n\tint index = ~0;\n\n\tfor (int i = 0; i < A->count; ++i)\n\t{\n\t\tc2h h = c2PlaneAt(A, i);\n\t\tint idx = c2Support(B->verts, B->count, c2Mulrv(a_in_b.r, c2Neg(h.n)));\n\t\tc2v p = c2Mulxv(b_in_a, B->verts[idx]);\n\t\tfloat d = c2Dist(h, p);\n\t\tif (d > sep)\n\t\t{\n\t\t\tsep = d;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\t*face_index = index;\n\treturn sep;\n}\n\n// Please see Dirk Gregorius's 2013 GDC lecture on the Separating Axis Theorem\n// for a full-algorithm overview. The short description is:\n\t// Test A against faces of B, test B against faces of A\n\t// Define the reference and incident shapes (denoted by r and i respectively)\n\t// Define the reference face as the axis of minimum penetration\n\t// Find the incident face, which is most anti-normal face\n\t// Clip incident face to reference face side planes\n\t// Keep all points behind the reference face\nvoid c2PolytoPolyManifold(const c2Poly* A, const c2x* ax_ptr, const c2Poly* B, const c2x* bx_ptr, c2Manifold* m)\n{\n\tm->count = 0;\n\tc2x ax = ax_ptr ? *ax_ptr : c2xIdentity();\n\tc2x bx = bx_ptr ? *bx_ptr : c2xIdentity();\n\tint ea, eb;\n\tfloat sa, sb;\n\tif ((sa = c2CheckFaces(A, ax, B, bx, &ea)) >= 0) return;\n\tif ((sb = c2CheckFaces(B, bx, A, ax, &eb)) >= 0) return;\n\n\tconst c2Poly* rp,* ip;\n\tc2x rx, ix;\n\tint re;\n\tfloat kRelTol = 0.95f, kAbsTol = 0.01f;\n\tint flip;\n\tif (sa * kRelTol > sb + kAbsTol)\n\t{\n\t\trp = A; rx = ax;\n\t\tip = B; ix = bx;\n\t\tre = ea;\n\t\tflip = 0;\n\t}\n\telse\n\t{\n\t\trp = B; rx = bx;\n\t\tip = A; ix = ax;\n\t\tre = eb;\n\t\tflip = 1;\n\t}\n\n\tc2v incident[2];\n\tc2Incident(incident, ip, ix, c2MulrvT(ix.r, c2Mulrv(rx.r, rp->norms[re])));\n\tc2h rh;\n\tif (!c2SidePlanesFromPoly(incident, rx, rp, re, &rh)) return;\n\tc2KeepDeep(incident, rh, m);\n\tif (flip) m->n = c2Neg(m->n);\n}\n\n#endif // CUTE_C2_IMPLEMENTATION_ONCE\n#endif // CUTE_C2_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2023 Randy Gaul https://randygaul.github.io/\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \n\tsoftware, either in source code form or as a compiled binary, for any purpose, \n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this \n\tsoftware dedicate any and all copyright interest in the software to the public \n\tdomain. We make this dedication for the benefit of the public at large and to \n\tthe detriment of our heirs and successors. We intend this dedication to be an \n\tovert act of relinquishment in perpetuity of all present and future rights to \n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_math.h",
          "type": "blob",
          "size": 29.3203125,
          "content": "#if !defined(CUTE_MATH_H)\n\n/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_math.h - v1.02\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_MATH_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\tREVISION HISTORY\n\n\t\t1.00 (12/21/2016) initial release\n\t\t1.01 (10/05/2017) vfloat data type added, removed out-dated comments,\n\t\t                  added compute_mouse_ray, added more m3 ops, added look_at\n\t\t1.02 (06/14/2019) removed vfloat, consistent function naming, setup standard\n\t\t                  calling convention, added implementation section, added\n\t\t                  vector indexing operators, added axis/angle from m3\n\n\tSUMMARY\n\n\t\tA professional level implementation of SSE intrinsics.\n*/\n\n#include <stdint.h>\n#include <math.h>\n#include <xmmintrin.h>\n\n#ifndef CUTE_MATH_ASSERT\n#\tinclude <assert.h>\n#\tdefine CUTE_MATH_ASSERT assert\n#endif\n\n#define CUTE_MATH_SHUFFLE(a, b, x, y, z) _mm_shuffle_ps(a, b, _MM_SHUFFLE(3, z, y, x))\n\n#ifdef _MSC_VER\n#\tdefine CUTE_MATH_CALL __vectorcall\n#else\n#\tdefine CUTE_MATH_CALL\n#endif\n\n#ifdef _WIN32\n#\tdefine CUTE_MATH_INLINE __forceinline\n#\tdefine CUTE_MATH_SELECTANY extern const __declspec(selectany)\n#\tdefine CUTE_MATH_RESTRICT __restrict\n#else\n// Just assume a g++-like compiler.\n#\tdefine CUTE_MATH_INLINE __attribute__((always_inline)) inline\n#\tdefine CUTE_MATH_SELECTANY extern const __attribute__((weak))\n#\tdefine CUTE_MATH_RESTRICT __restrict__\n#endif\n\n#define CUTE_MATH_PI 3.14159265358979323846f\n#define CUTE_MATH_DEG2RAD(X) ((X) * CUTE_MATH_PI / 180.0f)\n#define CUTE_MATH_RAD2DEG(X) ((X) * 180.0f / CUTE_MATH_PI)\n#define CUTE_MATH_FLT_MAX 3.402823466e+38F\n#define CUTE_MATH_FLT_EPSILON 1.19209290E-07f\n\nnamespace cute {\n\n// -------------------------------------------------------------------------------------------------\n// Scalar operations.\n\n#ifndef CUTE_MATH_SCALAR_OPS\n#define CUTE_MATH_SCALAR_OPS\n\nCUTE_MATH_INLINE float min(float a, float b) { return a < b ? a : b; }\nCUTE_MATH_INLINE float max(float a, float b) { return b < a ? a : b; }\nCUTE_MATH_INLINE float clamp(float a, float lo, float hi) { return max(lo, min(a, hi)); }\nCUTE_MATH_INLINE float sign(float a) { return a < 0 ? -1.0f : 1.0f; }\nCUTE_MATH_INLINE float intersect(float da, float db) { return da / (da - db); }\nCUTE_MATH_INLINE float invert_safe(float a) { return a != 0 ? 1.0f / a : 0; }\n\nCUTE_MATH_INLINE int min(int a, int b) { return a < b ? a : b; }\nCUTE_MATH_INLINE int max(int a, int b) { return b < a ? a : b; }\nCUTE_MATH_INLINE int clamp(int a, int lo, int hi) { return max(lo, min(a, hi)); }\nCUTE_MATH_INLINE int sign(int a) { return a < 0 ? -1 : 1; }\n\n#endif // CUTE_MATH_SCALAR_OPS\n\n// -------------------------------------------------------------------------------------------------\n// 3-Vector definition.\n\nstruct v3\n{\n\tCUTE_MATH_INLINE v3() { }\n\tCUTE_MATH_INLINE explicit v3(float x, float y, float z) { m = _mm_set_ps(0, z, y, x); }\n\tCUTE_MATH_INLINE explicit v3(float a) { m = _mm_set_ps(0, a, a, a); }\n\tCUTE_MATH_INLINE explicit v3(float *a) { m = _mm_set_ps(0, a[2], a[1], a[0]); }\n\tCUTE_MATH_INLINE explicit v3(__m128 v) { m = v; }\n\tCUTE_MATH_INLINE operator __m128() { return m; }\n\tCUTE_MATH_INLINE operator const __m128() const { return m; }\n\n\tCUTE_MATH_INLINE float operator[](int i)\n\t{\n\t\tswitch (i)\n\t\t{\n\t\tcase 0: return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(m, m, 0, 0, 0));\n\t\tcase 1: return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(m, m, 1, 1, 1));\n\t\tcase 2: return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(m, m, 2, 2, 2));\n\t\tdefault: CUTE_MATH_ASSERT(0); return 0;\n\t\t}\n\t}\n\n\tCUTE_MATH_INLINE float x() { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(this->m, this->m, 0, 0, 0)); }\n\tCUTE_MATH_INLINE float y() { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(this->m, this->m, 1, 1, 1)); }\n\tCUTE_MATH_INLINE float z() { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(this->m, this->m, 2, 2, 2)); }\n\n\tCUTE_MATH_INLINE v3 xyz() { return *this; }\n\tCUTE_MATH_INLINE v3 xzy() { return v3(CUTE_MATH_SHUFFLE(this->m, this->m, 0, 2, 1)); }\n\tCUTE_MATH_INLINE v3 yxz() { return v3(CUTE_MATH_SHUFFLE(this->m, this->m, 1, 0, 2)); }\n\tCUTE_MATH_INLINE v3 yzx() { return v3(CUTE_MATH_SHUFFLE(this->m, this->m, 1, 2, 0)); }\n\tCUTE_MATH_INLINE v3 zxy() { return v3(CUTE_MATH_SHUFFLE(this->m, this->m, 2, 0, 1)); }\n\tCUTE_MATH_INLINE v3 zyx() { return v3(CUTE_MATH_SHUFFLE(this->m, this->m, 2, 1, 0)); }\n\n\t__m128 m;\n};\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL getx(v3 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 0, 0, 0)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL gety(v3 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 1, 1, 1)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL getz(v3 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 2, 2, 2)); }\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL splatx(v3 a) { return v3(CUTE_MATH_SHUFFLE(a, a, 0, 0, 0)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL splaty(v3 a) { return v3(CUTE_MATH_SHUFFLE(a, a, 1, 1, 1)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL splatz(v3 a) { return v3(CUTE_MATH_SHUFFLE(a, a, 2, 2, 2)); }\n\n// -------------------------------------------------------------------------------------------------\n// Binary operators.\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator+(v3 a, v3 b) { return v3(_mm_add_ps(a, b)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator-(v3 a, v3 b) { return v3(_mm_sub_ps(a, b)); }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator+=(v3 &a, v3 b) { a = a + b; return a; }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator-=(v3 &a, v3 b) { a = a - b; return a; }\n\n// SIMD comparisons return a 4-lane vector. To keep things simple `bool3` is merely a descriptive alias\n// for `v3`, and is not its own type.\nusing bool3 = v3;\n\n// Generally comparisons are followed up with a mask(v3) or any(v3) call.\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator==(v3 a, v3 b) { return bool3(_mm_cmpeq_ps(a, b)); }\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator!=(v3 a, v3 b) { return bool3(_mm_cmpneq_ps(a, b)); }\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator<(v3 a, v3 b) { return bool3(_mm_cmplt_ps(a, b)); }\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator>(v3 a, v3 b) { return bool3(_mm_cmpgt_ps(a, b)); }\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator<=(v3 a, v3 b) { return bool3(_mm_cmple_ps(a, b)); }\nCUTE_MATH_INLINE bool3 CUTE_MATH_CALL operator>=(v3 a, v3 b) { return bool3(_mm_cmpge_ps(a, b)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator-(v3 a) { return v3(_mm_setzero_ps()) - a; }\n\nCUTE_MATH_INLINE unsigned CUTE_MATH_CALL mask(v3 a) { return _mm_movemask_ps(a) & 7; }\nCUTE_MATH_INLINE bool CUTE_MATH_CALL any(v3 a) { return mask(a) != 0; }\nCUTE_MATH_INLINE bool CUTE_MATH_CALL all(v3 a) { return mask(a) == 7; }\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL setx(v3 a, float x)\n{\n\tv3 t0 = v3(_mm_set_ss(x));\n\treturn v3(_mm_move_ss(a, t0));\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL sety(v3 a, float y)\n{\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, a, 1, 0, 2));\n\tv3 t1 = v3(_mm_set_ss(y));\n\tv3 t2 = v3(_mm_move_ss(t0, t1));\n\treturn v3(CUTE_MATH_SHUFFLE(t2, t2, 1, 0, 2));\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL setz(v3 a, float z)\n{\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, a, 2, 1, 0));\n\tv3 t1 = v3(_mm_set_ss(z));\n\tv3 t2 = v3(_mm_move_ss(t0, t1));\n\treturn v3(CUTE_MATH_SHUFFLE(t2, t2, 2, 1, 0));\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator*(v3 a, v3 b) { return v3(_mm_mul_ps(a, b)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator/(v3 a, v3 b) { return v3(_mm_div_ps(a, b)); }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator*=(v3& a, v3 b) { a = a * b; return a; }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator/=(v3& a, v3 b) { a = a / b; return a; }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator*(v3 a, float b) { return v3(_mm_mul_ps(a, v3(b))); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL operator/(v3 a, float b) { return v3(_mm_div_ps(a, v3(b))); }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator*=(v3& a, float b) { a = a * b; return a; }\nCUTE_MATH_INLINE v3& CUTE_MATH_CALL operator/=(v3& a, float b) { a = a / b; return a; }\n\n// -------------------------------------------------------------------------------------------------\n// Helpers for static data.\n\nstruct cute_math_const_integer\n{\n\tunion { uint32_t i[4]; __m128 m; };\n\tCUTE_MATH_INLINE operator v3() const { return v3(m); }\n\tCUTE_MATH_INLINE operator __m128() const { return m; }\n};\n\nstruct cute_math_const_float\n{\n\tunion { float f[4]; __m128 m; };\n\tCUTE_MATH_INLINE operator v3() const { return v3(m); }\n\tCUTE_MATH_INLINE operator __m128() const { return m; }\n};\n\nCUTE_MATH_SELECTANY cute_math_const_integer cute_math_mask_sign = { 0x80000000, 0x80000000, 0x80000000, 0x80000000 };\nCUTE_MATH_SELECTANY cute_math_const_integer cute_math_mask_all_bits = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000 };\nCUTE_MATH_SELECTANY cute_math_const_float cute_math_mask_basis = { 0.57735027f, 0.57735027f, 0.57735027f };\n\n// -------------------------------------------------------------------------------------------------\n// Vector operations.\n\n// `f` must be 16 byte aligned.\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL load(float* f) { return v3(_mm_load_ps(f)); }\nCUTE_MATH_INLINE void CUTE_MATH_CALL store(v3 v, float* f) { _mm_store_ps(f, v); }\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL dot(v3 a, v3 b)\n{\n\tv3 t0 = v3(_mm_mul_ps(a, b));\n\tv3 t1 = v3(CUTE_MATH_SHUFFLE(t0, t0, 1, 0, 0));\n\tv3 t2 = v3(_mm_add_ss(t0, t1));\n\tv3 t3 = v3(CUTE_MATH_SHUFFLE(t2, t2, 2, 0, 0));\n\tv3 t4 = v3(_mm_add_ss(t2, t3));\n\treturn getx(t4);\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL cross(v3 a, v3 b)\n{\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, a, 1, 2, 0));\n\tv3 t1 = v3(CUTE_MATH_SHUFFLE(b, b, 2, 0, 1));\n\tv3 t2 = v3(_mm_mul_ps(t0, t1));\n\n\tt0 = v3(CUTE_MATH_SHUFFLE(t0, t0, 1, 2, 0));\n\tt1 = v3(CUTE_MATH_SHUFFLE(t1, t1, 2, 0, 1));\n\tt0 = v3(_mm_mul_ps(t0, t1));\n\n\treturn v3(_mm_sub_ps(t2, t0));\n}\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL length_sq(v3 a) { return dot(a, a); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL sqrt(v3 a) { return v3(_mm_sqrt_ps(a)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL length(v3 a) { return sqrtf(dot(a, a)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL abs(v3 a) { return v3(_mm_andnot_ps(cute_math_mask_sign, a)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL min(v3 a, v3 b) { return v3(_mm_min_ps(a, b)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL max(v3 a, v3 b) { return v3(_mm_max_ps(a, b)); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL select(v3 a, v3 b, v3 mask) { return v3(_mm_xor_ps(a, _mm_and_ps(mask, _mm_xor_ps(b, a)))); }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL lerp(v3 a, v3 b, float t) { return a + (b - a) * t; }\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL hmin(v3 a)\n{\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, a, 1, 0, 2));\n\ta = min(a, t0);\n\tv3 t1 = v3(CUTE_MATH_SHUFFLE(a, a, 2, 0, 1));\n\treturn getx(min(a, t1));\n}\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL hmax(v3 a)\n{\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, a, 1, 0, 2));\n\ta = max(a, t0);\n\tv3 t1 = v3(CUTE_MATH_SHUFFLE(a, a, 2, 0, 1));\n\treturn getx(max(a, t1));\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL norm(v3 a)\n{\n\tfloat t0 = dot(a, a);\n\tfloat t1 = sqrtf(t0);\n\tv3 t2 = v3(_mm_div_ps(a, v3(t1)));\n\treturn v3(_mm_and_ps(t2, cute_math_mask_all_bits));\n}\n\n// Optimize me.\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL safe_norm(v3 a)\n{\n\tfloat t0 = dot(a, a);\n\tif (t0 == 0) {\n\t\treturn v3(0, 0, 0);\n\t} else {\n\t\tfloat t1 = sqrtf(t0);\n\t\tv3 t2 = v3(_mm_div_ps(a, v3(t1)));\n\t\treturn v3(_mm_and_ps(t2, cute_math_mask_all_bits));\n\t}\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL invert(v3 a)\n{\n\treturn v3(_mm_div_ps(v3(1.0f), a));\n}\n\n// Optimize me.\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL invert_safe(v3 a)\n{\n\tfloat x = a.x();\n\tfloat y = a.y();\n\tfloat z = a.z();\n\treturn v3(\n\t\tx == 0 ? 0 : 1.0f / x,\n\t\ty == 0 ? 0 : 1.0f / y,\n\t\tz == 0 ? 0 : 1.0f / z\n\t);\n}\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL clamp(v3 a, v3 vmin, v3 vmax)\n{\n\tv3 t0 = v3(_mm_max_ps(vmin, a));\n\treturn v3(_mm_min_ps(t0, vmax));\n}\n\n// Sets up a mask of { x ? ~0 : 0, y ? ~0 : 0, z ? ~0 : 0 }, where x, y and z should be 0 or 1.\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL mask(int x, int y, int z)\n{\n\tcute_math_const_integer c;\n\tunsigned elements[] = { 0x00000000, 0xFFFFFFFF };\n\n\tCUTE_MATH_ASSERT(x < 2 && x >= 0);\n\tCUTE_MATH_ASSERT(y < 2 && y >= 0);\n\tCUTE_MATH_ASSERT(z < 2 && z >= 0);\n\n\tc.i[0] = elements[x];\n\tc.i[1] = elements[y];\n\tc.i[2] = elements[z];\n\tc.i[3] = elements[0];\n\n\treturn c;\n}\n\n// `da` and `db` (standing for dot a and dot b) should be distances to plane, i.e. `halfspace::distance`.\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL intersect(v3 a, v3 b, float da, float db)\n{\n\treturn a + (b - a) * (da / (da - db));\n}\n\n// Carefully choose `tolerance`, see: http://www.randygaul.net/2014/11/07/robust-parallel-vector-test/\nCUTE_MATH_INLINE bool CUTE_MATH_CALL parallel(v3 a, v3 b, float tolerance)\n{\n\tfloat k = length(a) / length(b);\n\tv3 bk = b * k;\n\tif (all(abs(a - bk) < v3(tolerance))) return 1;\n\treturn 0;\n}\n\n// -------------------------------------------------------------------------------------------------\n// Matrix operations.\n\nstruct m3\n{\n\tCUTE_MATH_INLINE v3 operator[](int i)\n\t{\n\t\tswitch (i)\n\t\t{\n\t\tcase 0: return x;\n\t\tcase 1: return y;\n\t\tcase 2: return z;\n\t\tdefault: CUTE_MATH_ASSERT(0); return x;\n\t\t}\n\t}\n\n\tv3 x;\n\tv3 y;\n\tv3 z;\n};\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL rows(v3 x, v3 y, v3 z)\n{\n\tm3 m;\n\tm.x = x;\n\tm.y = y;\n\tm.z = z;\n\treturn m;\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL operator-(m3 a, m3 b)\n{\n\tm3 c;\n\tc.x = a.x - b.x;\n\tc.y = a.y - b.y;\n\tc.z = a.z - b.z;\n\treturn c;\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL operator+(m3 a, m3 b)\n{\n\tm3 c;\n\tc.x = a.x + b.x;\n\tc.y = a.y + b.y;\n\tc.z = a.z + b.z;\n\treturn c;\n}\n\nCUTE_MATH_INLINE m3& CUTE_MATH_CALL operator+=(m3& a, m3 b) { a = a + b; return a; }\nCUTE_MATH_INLINE m3& CUTE_MATH_CALL operator-=(m3& a, m3 b) { a = a - b; return a; }\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL operator*(float a, m3 b)\n{\n\tm3 c;\n\tc.x = b.x * a;\n\tc.y = b.y * a;\n\tc.z = b.z * a;\n\treturn c;\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_quat(float x, float y, float z, float w)\n{\n\tfloat x2 = x + x;\n\tfloat y2 = y + y;\n\tfloat z2 = z + z;\n\n\tfloat xx = x * x2;\n\tfloat xy = x * y2;\n\tfloat xz = x * z2;\n\tfloat xw = w * x2;\n\tfloat yy = y * y2;\n\tfloat yz = y * z2;\n\tfloat yw = w * y2;\n\tfloat zz = z * z2;\n\tfloat zw = w * z2;\n\n\treturn rows(\n\t\tv3(1.0f - yy - zz, xy + zw, xz - yw),\n\t\tv3(xy - zw, 1.0f - xx - zz, yz + xw),\n\t\tv3(xz + yw, yz - xw, 1.0f - xx - yy)\n\t);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_axis_angle(v3 axis, float angle)\n{\n\tfloat s = sinf(angle * 0.5f);\n\tfloat c = cosf(angle * 0.5f);\n\n\tfloat x = getx(axis) * s;\n\tfloat y = gety(axis) * s;\n\tfloat z = getz(axis) * s;\n\tfloat w = c;\n\n\treturn m3_from_quat(x, y, z, w);\n}\n\n// Does not preserve 0 in w to get rid of extra shuffles.\n// Oh well. Anyone have a better idea?\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL transpose(m3 a)\n{\n\tv3 t0 = v3(_mm_shuffle_ps(a.x, a.y, _MM_SHUFFLE(1, 0, 1, 0)));\n\tv3 t1 = v3(_mm_shuffle_ps(a.x, a.y, _MM_SHUFFLE(2, 2, 2, 2)));\n\tv3 x =  v3(_mm_shuffle_ps(t0, a.z, _MM_SHUFFLE(0, 0, 2, 0)));\n\tv3 y =  v3(_mm_shuffle_ps(t0, a.z, _MM_SHUFFLE(0, 1, 3, 1)));\n\tv3 z =  v3(_mm_shuffle_ps(t1, a.z, _MM_SHUFFLE(0, 2, 2, 0)));\n\n\ta.x = x;\n\ta.y = y;\n\ta.z = z;\n\n\treturn a;\n}\n\n//  a * b\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL mul(m3 a, v3 b)\n{\n\tv3 x = splatx(b);\n\tv3 y = splaty(b);\n\tv3 z = splatz(b);\n\tx = v3(_mm_mul_ps(x, a.x));\n\ty = v3(_mm_mul_ps(y, a.y));\n\tz = v3(_mm_mul_ps(z, a.z));\n\tv3 t0 = v3(_mm_add_ps(x, y));\n\treturn v3(_mm_add_ps(t0, z));\n}\n\n// a^T * b\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL mul_transpose(m3 a, v3 b) { return mul(transpose(a), b); }\n\n// a * b\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL mul(m3 a, m3 b)\n{\n\tv3 x = mul(a, b.x);\n\tv3 y = mul(a, b.y);\n\tv3 z = mul(a, b.z);\n\treturn rows(x, y, z);\n}\n\n// a^T * b\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL mul_transpose(m3 a, m3 b) { return mul(transpose(a), b); }\n\n// http://box2d.org/2014/02/computing-a-basis/\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL basis(v3 a)\n{\n\t// Suppose vector a has all equal components and is a unit vector: a = (s, s, s)\n\t// Then 3*s*s = 1, s = sqrt(1/3) = 0.57735027. This means that at least one component\n\t// of a unit vector must be greater or equal to 0.57735027.\n\n\tv3 neg_a = -a;\n\tv3 t0 = v3(CUTE_MATH_SHUFFLE(a, neg_a, 1, 1, 0));\n\tv3 b0 = v3(CUTE_MATH_SHUFFLE(t0, t0, 0, 2, 3));\n\tt0 = v3(CUTE_MATH_SHUFFLE(a, neg_a, 2, 2, 1));\n\tv3 b1 = v3(CUTE_MATH_SHUFFLE(t0, t0, 3, 1, 2));\n\n\tv3 mask = v3(_mm_cmpge_ps(cute_math_mask_basis, abs(a)));\n\tmask = splatx(mask);\n\tv3 b = select(b0, b1, mask);\n\tb = v3(norm(b).m);\n\tv3 c = cross(a, b);\n\n\treturn rows(a, b, c);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL outer_product(v3 u, v3 v)\n{\n\tv3 a = v * getx(u);\n\tv3 b = v * gety(u);\n\tv3 c = v * getz(u);\n\treturn rows(a, b, c);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_x_axis(float radians)\n{\n\tfloat s = sinf(radians);\n\tfloat c = cosf(radians);\n\treturn rows(\n\t\tv3(1,  0,  0),\n\t\tv3(0,  c, -s),\n\t\tv3(0,  s,  c)\n\t);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_y_axis(float radians)\n{\n\tfloat s = sinf(radians);\n\tfloat c = cosf(radians);\n\treturn rows(\n\t\tv3( c, 0, s),\n\t\tv3( 0, 1, 0),\n\t\tv3(-s, 0, c)\n\t);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_z_axis(float radians)\n{\n\tfloat s = sinf(radians);\n\tfloat c = cosf(radians);\n\treturn rows(\n\t\tv3(c, -s, 0),\n\t\tv3(s,  c, 0),\n\t\tv3(0,  0, 1)\n\t);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_euler_xyz(float x_radians, float y_radians, float z_radians)\n{\n\tm3 x = m3_from_x_axis(x_radians);\n\tm3 y = m3_from_y_axis(y_radians);\n\tm3 z = m3_from_z_axis(z_radians);\n\treturn mul(mul(x, y), z);\n}\n\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_euler_degrees_xyz(float x_degrees, float y_degrees, float z_degrees)\n{\n\treturn m3_from_euler_xyz(CUTE_MATH_DEG2RAD(x_degrees), CUTE_MATH_DEG2RAD(y_degrees), CUTE_MATH_DEG2RAD(z_degrees));\n}\n\n// -------------------------------------------------------------------------------------------------\n// Transform operations.\n\nstruct transform\n{\n\tv3 p; // position\n\tm3 r; // rotation\n};\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL mul(transform tx, v3 a) { return mul(tx.r, a) + tx.p; }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL mul_transpose(transform tx, v3 a) { return mul(tx.r, a - tx.p); }\n\nCUTE_MATH_INLINE transform CUTE_MATH_CALL mul(transform a, transform b)\n{\n\ttransform c;\n\tc.p = mul(a.r, b.p) + a.p;\n\tc.r = mul(a.r, b.r);\n\treturn c;\n}\n\nCUTE_MATH_INLINE transform CUTE_MATH_CALL mul_transpose(transform a, transform b)\n{\n\ttransform c;\n\tc.p = mul_transpose(a.r, b.p - a.p);\n\tc.r = mul_transpose(a.r, b.r);\n\treturn c;\n}\n\nstruct halfspace\n{\n\tv3 n;\n\tfloat d;\n};\n\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL origin(halfspace h) { return h.n * h.d; }\nCUTE_MATH_INLINE float CUTE_MATH_CALL distance(halfspace h, v3 p) { return dot(h.n, p) - h.d; }\nCUTE_MATH_INLINE v3 CUTE_MATH_CALL projected(halfspace h, v3 p) { return p - h.n * distance(h, p); }\n\nCUTE_MATH_INLINE halfspace CUTE_MATH_CALL mul(transform a, halfspace b)\n{\n\tv3 o = origin(b);\n\to = mul(a, o);\n\tv3 normal = mul(a.r, b.n);\n\thalfspace c;\n\tc.n = normal;\n\tc.d = dot(o, normal);\n\treturn c;\n}\n\nCUTE_MATH_INLINE halfspace CUTE_MATH_CALL mul_transpose(transform a, halfspace b)\n{\n\tv3 o = origin(b);\n\to = mul_transpose(a, o);\n\tv3 normal = mul_transpose(a.r, b.n);\n\thalfspace c;\n\tc.n = normal;\n\tc.d = dot(o, normal);\n\treturn c;\n}\n\n// -------------------------------------------------------------------------------------------------\n// Quaternion operations.\n\nstruct q4\n{\n\tq4() { }\n\tCUTE_MATH_INLINE explicit q4(v3 vector_part, float scalar_part) { m = _mm_set_ps(scalar_part, getz(vector_part), gety(vector_part), getx(vector_part)); }\n\tCUTE_MATH_INLINE explicit q4(float x, float y, float z, float w) { m = _mm_set_ps(w, z, y, x); }\n\n\tCUTE_MATH_INLINE operator __m128() { return m; }\n\tCUTE_MATH_INLINE operator __m128() const { return m; }\n\n\t__m128 m;\n};\n\nCUTE_MATH_INLINE q4 CUTE_MATH_CALL q4_from_axis_angle(v3 axis_normalized, float angle)\n{\n\tfloat s = sinf(angle * 0.5f);\n\tfloat c = cosf(angle * 0.5f);\n\treturn q4(axis_normalized * s, c);\n}\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL getx(q4 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 0, 0, 0)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL gety(q4 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 1, 1, 1)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL getz(q4 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 2, 2, 2)); }\nCUTE_MATH_INLINE float CUTE_MATH_CALL getw(q4 a) { return _mm_cvtss_f32(CUTE_MATH_SHUFFLE(a, a, 3, 3, 3)); }\n\n// Optimize me.\nCUTE_MATH_INLINE q4 CUTE_MATH_CALL norm(q4 q)\n{\n\tfloat x = getx(q);\n\tfloat y = gety(q);\n\tfloat z = getz(q);\n\tfloat w = getw(q);\n\n\tfloat d = w * w + x * x + y * y + z * z;\n\n\tif(d == 0) w = 1.0f;\n\td = 1.0f / sqrtf(d);\n\n\tif (d > 1.0e-8f) {\n\t\tx *= d;\n\t\ty *= d;\n\t\tz *= d;\n\t\tw *= d;\n\t}\n\n\treturn q4(x, y, z, w);\n}\n\n// Optimize me.\nCUTE_MATH_INLINE q4 CUTE_MATH_CALL operator*(q4 a, q4 b)\n{\n\treturn q4(\n\t\tgetw(a) * getx(b) + getx(a) * getw(b) + gety(a) * getz(b) - getz(a) * gety(b),\n\t\tgetw(a) * gety(b) + gety(a) * getw(b) + getz(a) * getx(b) - getx(a) * getz(b),\n\t\tgetw(a) * getz(b) + getz(a) * getw(b) + getx(a) * gety(b) - gety(a) * getx(b),\n\t\tgetw(a) * getw(b) - getx(a) * getx(b) - gety(a) * gety(b) - getz(a) * getz(b)\n\t);\n}\n\n// Optimize me.\nCUTE_MATH_INLINE q4 CUTE_MATH_CALL integrate(q4 q, v3 w, float h)\n{\n\tq4 wq(getx(w) * h, gety(w) * h, getz(w) * h, 0.0f);\n\n\twq = wq * q;\n\n\tq4 q0 = q4(\n\t\tgetx(q) + getx(wq) * 0.5f,\n\t\tgety(q) + gety(wq) * 0.5f,\n\t\tgetz(q) + getz(wq) * 0.5f,\n\t\tgetw(q) + getw(wq) * 0.5f\n\t);\n\n\treturn norm(q0);\n}\n\n// Optimize me.\nCUTE_MATH_INLINE m3 CUTE_MATH_CALL m3_from_q4(q4 q)\n{\n\treturn m3_from_quat(getx(q), gety(q), getz(q), getw(q));\n}\n\nCUTE_MATH_INLINE float CUTE_MATH_CALL trace(m3 m)\n{\n\treturn getx(m.x) + gety(m.y) + getz(m.z);\n}\n\n// -------------------------------------------------------------------------------------------------\n// Globals.\n\nCUTE_MATH_SELECTANY m3 identity_m3 = rows(v3(1.0f, 0.0f, 0.0f), v3(0.0f, 1.0f, 0.0f), v3(0.0f, 0.0f, 1.0f));\nCUTE_MATH_SELECTANY m3 zero_m3 = rows(v3(0.0f, 0.0f, 0.0f), v3(0.0f, 0.0f, 0.0f), v3(0.0f, 0.0f, 0.0f));\nCUTE_MATH_SELECTANY v3 zero_v3 = v3(0.0f, 0.0f, 0.0f);\nCUTE_MATH_SELECTANY q4 identity_q4 = q4(0.0f, 0.0f, 0.0f, 1.0f);\nCUTE_MATH_SELECTANY transform identity_transform = { zero_v3, identity_m3 };\n\n// -------------------------------------------------------------------------------------------------\n// Larger utility functions, defined in the `CUTE_MATH_IMPLEMENTATION` section.\n\nvoid CUTE_MATH_CALL look_at(float* world_to_cam, v3 eye, v3 target, v3 up, float* cam_to_world = NULL);\nvoid CUTE_MATH_CALL mul_vector4_by_matrix4x4(float* a_matrix4x4, float* b_vector4, float* out_vector);\nvoid CUTE_MATH_CALL mul_matrix4x4_by_matrix4x4(float* a, float* b, float* out);\nvoid CUTE_MATH_CALL compute_mouse_ray(float mouse_x, float mouse_y, float fov, float viewport_w, float viewport_h, float* cam_inv, float near_plane_dist, v3* mouse_pos, v3* mouse_dir);\nvoid CUTE_MATH_CALL axis_angle_from_m3(m3 m, v3* axis, float* angle_radians);\n\t\n} // namespace cute\n\n#define CUTE_MATH_H\n#endif\n\n#ifdef CUTE_MATH_IMPLEMENTATION\n#ifndef CUTE_MATH_IMPLEMENTATION_ONCE\n#define CUTE_MATH_IMPLEMENTATION_ONCE\n\nnamespace cute {\n\nvoid CUTE_MATH_CALL look_at(float* world_to_cam, v3 eye, v3 target, v3 up, float* cam_to_world)\n{\n\tv3 front = norm(target - eye);\n\tv3 side = norm(cross(front, up));\n\tv3 top = norm(cross(side, front));\n\n\tworld_to_cam[0] = getx(side);\n\tworld_to_cam[1] = getx(top);\n\tworld_to_cam[2] = -getx(front);\n\tworld_to_cam[3] = 0;\n\n\tworld_to_cam[4] = gety(side);\n\tworld_to_cam[5] = gety(top);\n\tworld_to_cam[6] = -gety(front);\n\tworld_to_cam[7] = 0;\n\n\tworld_to_cam[8] = getz(side);\n\tworld_to_cam[9] = getz(top);\n\tworld_to_cam[10] = -getz(front);\n\tworld_to_cam[11] = 0;\n\n\tv3 x = v3(world_to_cam[0], world_to_cam[4], world_to_cam[8]);\n\tv3 y = v3(world_to_cam[1], world_to_cam[5], world_to_cam[9]);\n\tv3 z = v3(world_to_cam[2], world_to_cam[6], world_to_cam[10]);\n\n\tworld_to_cam[12] = -dot(x, eye);\n\tworld_to_cam[13] = -dot(y, eye);\n\tworld_to_cam[14] = -dot(z, eye);\n\tworld_to_cam[15] = 1.0f;\n\n\tif (cam_to_world) {\n\t\tcam_to_world[0] = getx(side);\n\t\tcam_to_world[1] = gety(side);\n\t\tcam_to_world[2] = getz(side);\n\t\tcam_to_world[3] = 0;\n\n\t\tcam_to_world[4] = getx(top);\n\t\tcam_to_world[5] = gety(top);\n\t\tcam_to_world[6] = getz(top);\n\t\tcam_to_world[7] = 0;\n\n\t\tcam_to_world[8] = -getx(front);\n\t\tcam_to_world[9] = -gety(front);\n\t\tcam_to_world[10] = -getz(front);\n\t\tcam_to_world[11] = 0;\n\n\t\tcam_to_world[12] = getx(eye);\n\t\tcam_to_world[13] = gety(eye);\n\t\tcam_to_world[14] = getz(eye);\n\t\tcam_to_world[15] = 1.0f;\n\t}\n}\n\nvoid CUTE_MATH_CALL mul_vector4_by_matrix4x4(float* a_matrix4x4, float* b_vector4, float* out_vector)\n{\n\tfloat result[4];\n\n\tresult[0] = a_matrix4x4[0] * b_vector4[0] + a_matrix4x4[4] * b_vector4[1] + a_matrix4x4[8]  * b_vector4[2] + a_matrix4x4[12] * b_vector4[3];\n\tresult[1] = a_matrix4x4[1] * b_vector4[0] + a_matrix4x4[5] * b_vector4[1] + a_matrix4x4[9]  * b_vector4[2] + a_matrix4x4[13] * b_vector4[3];\n\tresult[2] = a_matrix4x4[2] * b_vector4[0] + a_matrix4x4[6] * b_vector4[1] + a_matrix4x4[10] * b_vector4[2] + a_matrix4x4[14] * b_vector4[3];\n\tresult[3] = a_matrix4x4[3] * b_vector4[0] + a_matrix4x4[7] * b_vector4[1] + a_matrix4x4[11] * b_vector4[2] + a_matrix4x4[15] * b_vector4[3];\n\n\tout_vector[0] = result[0];\n\tout_vector[1] = result[1];\n\tout_vector[2] = result[2];\n\tout_vector[3] = result[3];\n}\n\nvoid CUTE_MATH_CALL mul_matrix4x4_by_matrix4x4(float* a, float* b, float* out)\n{\n\tfloat result[16];\n\n\tmul_vector4_by_matrix4x4(a, b, result);\n\tmul_vector4_by_matrix4x4(a, b + 4, result + 4);\n\tmul_vector4_by_matrix4x4(a, b + 8, result + 8);\n\tmul_vector4_by_matrix4x4(a, b + 12, result + 12);\n\n\tfor (int i = 0; i < 16; ++i) out[i] = result[i];\n}\n\nvoid CUTE_MATH_CALL compute_mouse_ray(float mouse_x, float mouse_y, float fov, float viewport_w, float viewport_h, float* cam_inv, float near_plane_dist, v3* mouse_pos, v3* mouse_dir)\n{\n\tfloat aspect = (float)viewport_w / (float)viewport_h;\n\tfloat px = 2.0f * aspect * mouse_x / viewport_w - aspect;\n\tfloat py = -2.0f * mouse_y / viewport_h + 1.0f;\n\tfloat pz = -1.0f / tanf(fov / 2.0f);\n\tv3 point_in_view_space(px, py, pz);\n\n\tv3 cam_pos(cam_inv[12], cam_inv[13], cam_inv[14]);\n\tfloat pf[4] = { getx(point_in_view_space), gety(point_in_view_space), getz(point_in_view_space), 1.0f };\n\tmul_vector4_by_matrix4x4(cam_inv, pf, pf);\n\tv3 point_on_clipping_plane(pf[0] , pf[1], pf[2]);\n\tv3 dir_in_world_space = point_on_clipping_plane - cam_pos;\n\n\tv3 dir = norm(dir_in_world_space);\n\tv3 cam_forward(cam_inv[8], cam_inv[9], cam_inv[10]);\n\n\t*mouse_dir = dir;\n\t*mouse_pos = cam_pos + dir * dot(dir, cam_forward) * near_plane_dist;\n}\n\nvoid CUTE_MATH_CALL axis_angle_from_m3(m3 m, v3* axis, float* angle_radians)\n{\n\tconst float k_tol = 1.0e-8f;\n\tfloat c = 0.5f * (trace(m) - 1.0f);\n\tfloat angle = acosf(c);\n\t*angle_radians = angle;\n\n\tbool angle_near_zero = fabsf(angle) < k_tol;\n\tbool angle_not_near_pi = angle < CUTE_MATH_PI - k_tol;\n\tif (angle_near_zero) {\n\t\t// When angle is zero the axis can be anything. X axis is good.\n\t\t*axis = v3(1, 0, 0);\n\t} else if (angle_not_near_pi) {\n\t\t// Standard case with no singularity.\n\t\tv3 n = v3(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]);\n\t\t*axis = norm(n);\n\t} else {\n\t\t// Angle is near 180-degrees.\n\t\tint i = 0;\n\t\tif (m[1][1] > m[0][0]) i = 1;\n\t\tif (m[2][2] > m[i][i]) i = 2;\n\t\tint j = (i + 1) % 3;\n\t\tint k = (j + 1) % 3;\n\t\tfloat s = sqrtf(m[i][i] - m[j][j] - m[k][k] + 1.0f);\n\t\tfloat inv_s = s != 0 ? 1.0f / s : 0;\n\t\tfloat v[3];\n\t\tv[i] = 0.5f * s;\n\t\tv[j] = m[j][i] * inv_s;\n\t\tv[k] = m[i][k] * inv_s;\n\t\t*axis = v3(v[0], v[1], v[2]);\n\t}\n}\n\t\n} // namespace cute\n\n#endif // CUTE_MATH_IMPLEMENTATION_ONCE\n#endif // CUTE_MATH_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2019 Randy Gaul http://www.randygaul.net\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \n\tsoftware, either in source code form or as a compiled binary, for any purpose, \n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this \n\tsoftware dedicate any and all copyright interest in the software to the public \n\tdomain. We make this dedication for the benefit of the public at large and to \n\tthe detriment of our heirs and successors. We intend this dedication to be an \n\tovert act of relinquishment in perpetuity of all present and future rights to \n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_net.h",
          "type": "blob",
          "size": 397.4560546875,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_net.h - v1.03\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_NET_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY\n\n\t\tCute net provides you a way to securely connect clients to servers, and\n\t\timplements all the machinery for sending both reliable-in-order and\n\t\tfire-and-forget (UDP style) packets. This is great for many kinds of games,\n\t\tranging from games who just want TCP-style packets (such as a turn-based\n\t\tRPG), to fast paced platformer or fighting games.\n\n\n\tFEATURES\n\n\t\t* Reliable-in-order packets. These are packets that will be resent if they\n\t\t  aren't received, and will be received in the same order they are sent.\n\t\t* Fire-and-forget packets. These are basic UDP packets, useful for sending\n\t\t  temporal info like transforms for quick updates. They are not resent if\n\t\t  lost, and can arrive out of order.\n\t\t* Client and server abstractions.\n\t\t* State of the art connect tokens for security.\n\t\t* Support for large packets (fragmentation and reassembly).\n\t\t* Bandwidth stats (incoming/outgoing kbps, packet loss).\n\n\n\tTODO FEATURES\n\n\t\t* Bandwidth throttling\n\t\t* TCP-only mode (for web builds via emscripten)\n\t\t* Channel support (for reliable packet stalling mitigation)\n\t\t* Loopback clients for server\n\t\t* Memory stats query for server\n\n\n\tCROSS PLATFORM\n\n\t\tWorks on almost any platform. The main limitation is initialization of\n\t\tcryptographically secure random numbers, as implemented by libhydrogen.\n\t\tBut, it should work pretty much everywhere. You can find the platforms\n\t\tsupported via ctrl + f \"#error Unsupported platform (libhydrogen).\" without\n\t\tquotes. The platforms APIs are (yes, this covers Mac, iOS, Windows, Android\n\t\tand Linux):\n\n\t\t\t* riot\n\t\t\t* mbedtls\n\t\t\t* unix\n\t\t\t* wasi\n\t\t\t* windows\n\t\t\t* NRF\n\t\t\t* particle\n\t\t\t* ESP\n\t\t\t* AVR\n\n\t\tPlease note emscripten (and browsers) are not supported, as Cute Net uses\n\t\tthe UDP transport layer, not TCP.\n\n\n\tLIMITATIONS\n\n\t\tCute net does not implement some high level multiplayer features, such as\n\t\tinterpolation, rollback, or other similar features. Cute net is merely to\n\t\tsetup secure connections between clients and servers, and facilitate\n\t\tpackets through the connection.\n\n\t\tThis is a pretty big library with a lot of code. It's doing a lot under the\n\t\thood, including cryptography, book-keeping, and dealing with the UDP layer.\n\t\tHowever, it's very small for what it's doing!\n\n\t\tThere is no HTTPS support, so distributing connect tokens is *out of scope*\n\t\tof this library. If you want an out-of-the-box solution for making HTTPS\n\t\tcalls to a game server, you can try out the higher level library Cute\n\t\tFramework (https://github.com/RandyGaul/cute_framework).\n\n\n\tSPECIAL THANKS\n\n\t\tSpecial thanks to Glenn Fiedler for his online resources, especially his\n\t\tnetcode.io (https://github.com/networkprotocol/netcode).\n\n\t\tSpecial thanks to Frank Denis for providing the cryptography AEAD primitive\n\t\twithin his libhydrogen (https://github.com/jedisct1/libhydrogen).\n\n\t\tSpecial thanks to Mattias Gustavsson for his rnd and hashtable implementations\n\t\t(https://github.com/mattiasgustavsson/libs).\n\n\n\tRevision history:\n\t\t1.00 (04/22/2022) Initial release.\n\t\t1.01 (07/22/2022) Fixed an old find + replace bug that caused packets to fail\n\t\t                  decryption across different platforms/compilers.\n\t\t1.02 (11/12/2022) Fixed a bug where sequence buffers would desync when sending\n\t\t                  too many reliable packets all at once.\n\t\t                * Implemented stats queries (packet loss, round-trip-time, etc.)\n\t\t                * Return proper error if packets of size 0 are sent.\n\t\t                * Renamed cn_error_t to cn_result_t.\n\t\t                * Fixed a bug where reliable sequence numbers were incremented\n\t\t                  at the wrong time, causing a desynchronization and connection\n\t\t                  drop.\n\t\t1.03 (03/27/2023) Fixed an issue where sometimes a sequence buffer would mark an\n\t\t                  an entry as free before actually free'ing it, inevitably causing\n\t\t                  a double free. Also added a new function cn_server_set_public_ip,\n\t\t                  useful for testing servers behind a NAT: WARNING -- not recommended\n\t\t                  for shipping due to compromised security!!!\n*/\n\n/*\n\tDOCUMENTATION\n\n\t\tClients use connect tokens to connect to game servers. This only allows clients\n\t\twho authenticate themselves to connect and play on your game servers, granting\n\t\tcompletel control over who can or cannot play. This is important as dedicated\n\t\tgame servers are typically fairly expensive to run, and usually only players who\n\t\thave paid for the game are able to obtain connect tokens.\n\n\t\tYou will have to distribute connect tokens to clients. The recommendation is to\n\t\tsetup a web service to provide a REST API, like a simple HTTP server. The client\n\t\tcan send an HTTP request, and the server responds with a connect token.\n\n\t\tThe client then reads the connect token, which contains a list of game servers\n\t\tto try and connect to along with other needed security info. Here's a diagram\n\t\tdescribing the process.\n\n\t\t\t+-----------+\n\t\t\t|    Web    |\n\t\t\t|  Service  |\n\t\t\t+-----------+\n\t\t\t    ^  |\n\t\t\t    |  |                            +-----------+              +-----------+\n\t\t\t  REST Call                         | Dedicated |              | Dedicated |\n\t\t\t  returns a                         | Server  1 |              | Server  2 |\n\t\t\tConnect Token                       +-----------+              +-----------+\n\t\t\t    |  |                                  ^                          ^\n\t\t\t    |  v                                  |                          |\n\t\t\t +--------+   *connect token packet* ->   |   if fail, try next ->   |\n\t\t\t | Client |-------------------------------+--------------------------+----------> ... Token timeout!\n\t\t\t +--------+\n\n\t\tOnce you get a connect token make a call to `cn_client_connect`.\n\n\t\tThe function `cn_generate_connect_token` can be used to generate connect tokens for the web service to distribute.\n\n\t\tThe web service distributes connect tokens. Cute net does not provide an implementation\n\t\tof a web service because there are many different good solutions out there already. The\n\t\tgoal is to only respond and provide connect tokens to clients who have authenticated\n\t\tthemselves over a secure connection with the web service, such as through HTTPS. For\n\t\texample: this is how cute net can be used to filter out players who have no purchased the\n\t\tgame or signed up with an account.\n\n\n\tEXAMPLES\n\t\n\t\tHere is a full example of a client and server, where the client sends a string to the\n\t\tserver to print to the console.\n\n\t\t\tClient example: https://github.com/RandyGaul/cute_headers/tree/master/examples_cute_net/client\n\t\t\tServer example: https://github.com/RandyGaul/cute_headers/tree/master/examples_cute_net/server\n\n\n\tUNIT TESTS\n\n\t\tYou may enable building the unit tests with CUTE_NET_TESTS. Simply call\n\n\t\t\tcn_run_tests(-1, false);\n\n\t\tto run all of the unit tests. The first parameter is the test number to run,\n\t\twhile the second paramater is for a \"soak\" test (run the tests in an in-\n\t\tfinite loop).\n\n\t\tYou will see a bunch of colored text printed to the console about each test\n\t\tand whether or not each test passed or failed.\n\n\n\tCUSTOMIZATION\n\n\t\tThere are a number of macros to override c-runtime functions. Simply define\n\t\tyour own version of these macros before including this header when you setup\n\t\tthe implementation with CUTE_NET_IMPLEMENTATION.\n\n\t\t\tCN_ALLOC\n\t\t\tCN_FREE\n\t\t\tCN_MEMCPY\n\t\t\tCN_MEMSET\n\t\t\tCN_ASSERT\n\t\t\tCN_STRNCPY\n\t\t\tCN_STRLEN\n\t\t\tCN_STRNCMP\n\t\t\tCN_MEMCMP\n\t\t\tCN_SNPRINTF\n\t\t\tCN_FPRINTF\n\t\t\tCN_PRINTF\n\n\t\tYou can disable IPv6 support by defining CUTE_NET_NO_IPV6 like so.\n\n\t\t\t#define CUTE_NET_NO_IPV6\n\t\t\t#define CUTE_NET_IMPLEMENTATION\n\t\t\t#include <cute_net.h>\n\n\t\tYou may override the number of max clients on a server via CN_SERVER_MAX_CLIENTS.\n\t\tThe memory per client is a constant factor, and not too much. From rough back of the\n\t\tenvelope math it was estimated to easily support 2k+ players on a single machine.\n\n\n\tBUGS AND CRASHES\n\n\t\tThis header is quite new and it takes time to test all code; There may be bugs\n\t\there and there, so please open up an issue on github if you have any questions\n\t\tor need help!\n\n\t\thttps://github.com/RandyGaul/cute_headers/issues\n*/\n\n#ifndef CN_NET_H\n#define CN_NET_H\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\n\t#define _CRT_NONSTDC_NO_DEPRECATE\n#endif\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct cn_result_t cn_result_t;\ntypedef struct cn_client_t cn_client_t;\ntypedef struct cn_server_t cn_server_t;\ntypedef struct cn_endpoint_t cn_endpoint_t;\ntypedef struct cn_crypto_key_t { uint8_t key[32]; } cn_crypto_key_t;\ntypedef struct cn_crypto_sign_public_t { uint8_t key[32]; } cn_crypto_sign_public_t;\ntypedef struct cn_crypto_sign_secret_t { uint8_t key[64]; } cn_crypto_sign_secret_t;\ntypedef struct cn_crypto_signature_t { uint8_t bytes[64]; } cn_crypto_signature_t;\n\n#ifdef __cplusplus\n#\tdefine CN_INLINE inline\n#else\n#\tdefine CN_INLINE static inline\n#endif\n\n//--------------------------------------------------------------------------------------------------\n// ENDPOINT\n\ntypedef enum cn_address_type_t\n{\n\tCN_ADDRESS_TYPE_NONE,\n\tCN_ADDRESS_TYPE_IPV4,\n#ifndef CUTE_NET_NO_IPV6\n\tCN_ADDRESS_TYPE_IPV6\n#endif\n} cn_address_type_t;\n\nstruct cn_endpoint_t\n{\n\tcn_address_type_t type;\n\tuint16_t port;\n\n\tunion\n\t{\n\t\tuint8_t ipv4[4];\n#ifndef CUTE_NET_NO_IPV6\n\t\tuint16_t ipv6[8];\n#endif\n\t} u;\n};\n\nint cn_endpoint_init(cn_endpoint_t* endpoint, const char* address_and_port_string);\nvoid cn_endpoint_to_string(cn_endpoint_t endpoint, char* buffer, int buffer_size);\nint cn_endpoint_equals(cn_endpoint_t a, cn_endpoint_t b);\n\n//--------------------------------------------------------------------------------------------------\n// CONNECT TOKEN\n\n#define CN_CONNECT_TOKEN_SIZE 1114\n#define CN_CONNECT_TOKEN_USER_DATA_SIZE 256\n\n/**\n * Generates a cryptography key in a cryptographically secure way.\n */\ncn_crypto_key_t cn_crypto_generate_key();\n\n/**\n * Fills a buffer in a cryptographically secure way (i.e. a slow way).\n */\nvoid cn_crypto_random_bytes(void* data, int byte_count);\n\n/**\n * Generates a cryptographically secure keypair, used for facilitating connect tokens.\n */\nvoid cn_crypto_sign_keygen(cn_crypto_sign_public_t* public_key, cn_crypto_sign_secret_t* secret_key);\n\n/**\n * Generates a connect token, useable by clients to authenticate and securely connect to\n * a server. You can use this function whenever a validated client wants to join your game servers.\n * \n * It's recommended to setup a web service specifically for allowing players to authenticate\n * themselves (login). Once authenticated, the webservice can call this function and hand\n * the connect token to the client. The client can then read the public section of the\n * connect token and see the `address_list` of servers to try and connect to. The client then\n * sends the connect token to one of these servers to start the connection handshake. If the\n * handshake completes successfully, the client will connect to the server.\n *\n * The connect token is protected by an AEAD primitive (https://en.wikipedia.org/wiki/Authenticated_encryption),\n * which means the token cannot be modified or forged as long as the `shared_secret_key` is\n * not leaked. In the event your secret key is accidentally leaked, you can always roll a\n * new one and distribute it to your webservice and game servers.\n */\ncn_result_t cn_generate_connect_token(\n\tuint64_t application_id,                          // A unique number to identify your game, can be whatever value you like.\n\t                                                  // This must be the same number as in `cn_client_create` and `cn_server_create`.\n\tuint64_t creation_timestamp,                      // A unix timestamp of the current time.\n\tconst cn_crypto_key_t* client_to_server_key,      // A unique key for this connect token for the client to encrypt packets, and server to\n\t                                                  // decrypt packets. This can be generated with `cn_crypto_generate_key` on your web service.\n\tconst cn_crypto_key_t* server_to_client_key,      // A unique key for this connect token for the server to encrypt packets, and the client to\n\t                                                  // decrypt packets. This can be generated with `cn_crypto_generate_key` on your web service.\n\tuint64_t expiration_timestamp,                    // A unix timestamp for when this connect token expires and becomes invalid.\n\tuint32_t handshake_timeout,                       // The number of seconds the connection will stay alive during the handshake process before\n\t                                                  // the client and server reject the handshake process as failed.\n\tint address_count,                                // Must be from 1 to 32 (inclusive). The number of addresses in `address_list`.\n\tconst char** address_list,                        // A list of game servers the client can try connecting to, of length `address_count`.\n\tuint64_t client_id,                               // The unique client identifier.\n\tconst uint8_t* user_data,                         // Optional buffer of data of `CN_CONNECT_TOKEN_USER_DATA_SIZE` (256) bytes. Can be NULL.\n\tconst cn_crypto_sign_secret_t* shared_secret_key, // Only your webservice and game servers know this key.\n\tuint8_t* token_ptr_out                            // Pointer to your buffer, should be `CN_CONNECT_TOKEN_SIZE` bytes large.\n);\n\n//--------------------------------------------------------------------------------------------------\n// CLIENT\n\ncn_client_t* cn_client_create(\n\tuint16_t port,                            // Port for opening a UDP socket.\n\tuint64_t application_id,                  // A unique number to identify your game, can be whatever value you like.\n\t                                          // This must be the same number as in `cn_server_create`.\n\tbool use_ipv6 /* = false */,              // Whether or not the socket should turn on ipv6. Some users will not have\n\t                                          // ipv6 enabled, so this defaults to false.\n\tvoid* user_allocator_context /* = NULL */ // Used for custom allocators, this can be set to NULL.\n);\nvoid cn_client_destroy(cn_client_t* client);\n\n/**\n * The client will make an attempt to connect to all servers listed in the connect token, one after\n * another. If no server can be connected to the client's state will be set to an error state. Call\n * `cn_client_state_get` to get the client's state. Once `cn_client_connect` is called then successive calls to\n * `cn_client_update` is expected, where `cn_client_update` will perform the connection handshake and make\n * connection attempts to your servers.\n */\ncn_result_t cn_client_connect(cn_client_t* client, const uint8_t* connect_token);\nvoid cn_client_disconnect(cn_client_t* client);\n\n/**\n * You should call this one per game loop after calling `cn_client_connect`.\n */\nvoid cn_client_update(cn_client_t* client, double dt, uint64_t current_time);\n\n/**\n * Returns a packet from the server if one is available. You must free this packet when you're done by\n * calling `cn_client_free_packet`.\n */\nbool cn_client_pop_packet(cn_client_t* client, void** packet, int* size, bool* was_sent_reliably /* = NULL */);\nvoid cn_client_free_packet(cn_client_t* client, void* packet);\n\n/**\n * Sends a packet to the server. If the packet size is too large (over 1k bytes) it will be split up\n * and sent in smaller chunks.\n * \n * `send_reliably` as true means the packet will be sent reliably an in-order relative to other\n * reliable packets. Under packet loss the packet will continually be sent until an acknowledgement\n * from the server is received. False means to send a typical UDP packet, with no special mechanisms\n * regarding packet loss.\n * \n * Reliable packets are significantly more expensive than unreliable packets, so try to send any data\n * that can be lost due to packet loss as an unreliable packet. Of course, some packets are required\n * to be sent, and so reliable is appropriate. As an optimization some kinds of data, such as frequent\n * transform updates, can be sent unreliably.\n * \n * Will return an error result if the packet cannot be queued up for some reason. This typically means\n * you are sending way too much data to the other end and need to slow down.\n * \n * IMPORTANT NOTE -- If you send reliable packets you _MUST_ be sending packets both to the server\n *                   and to the client. Two-way communication is required. If you only send reliable\n *                   packets one-way, it will never hear back from the other end whether or not those\n *                   packets safely arrived, and you will stall the connection. It's recommended to\n *                   constantly send packets back and forth each game tick. Each packet can confirm\n *                   32 other packets, so as a rule of thumb make sure you are sending at least one\n *                   packet for every 16 received.\n */\ncn_result_t cn_client_send(cn_client_t* client, const void* packet, int size, bool send_reliably);\n\ntypedef enum cn_client_state_t\n{\n\tCN_CLIENT_STATE_CONNECT_TOKEN_EXPIRED         = -6,\n\tCN_CLIENT_STATE_INVALID_CONNECT_TOKEN         = -5,\n\tCN_CLIENT_STATE_CONNECTION_TIMED_OUT          = -4,\n\tCN_CLIENT_STATE_CHALLENGE_RESPONSE_TIMED_OUT  = -3,\n\tCN_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT  = -2,\n\tCN_CLIENT_STATE_CONNECTION_DENIED             = -1,\n\tCN_CLIENT_STATE_DISCONNECTED                  = 0,\n\tCN_CLIENT_STATE_SENDING_CONNECTION_REQUEST    = 1,\n\tCN_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE    = 2,\n\tCN_CLIENT_STATE_CONNECTED                     = 3,\n} cn_client_state_t;\n\ncn_client_state_t cn_client_state_get(const cn_client_t* client);\nconst char* cn_client_state_string(cn_client_state_t state); \nvoid cn_client_enable_network_simulator(cn_client_t* client, double latency, double jitter, double drop_chance, double duplicate_chance);\nfloat cn_client_get_packet_loss_estimate(cn_client_t* client);\nfloat cn_client_get_rtt_estimate(cn_client_t* client);\nfloat cn_client_get_incoming_kbps_estimate(cn_client_t* client);\nfloat cn_client_get_outgoing_kbps_estimate(cn_client_t* client);\n\n//--------------------------------------------------------------------------------------------------\n// SERVER\n\n// Override this macro as seen fit.\n#ifndef CN_SERVER_MAX_CLIENTS\n#\tdefine CN_SERVER_MAX_CLIENTS 32\n#endif\n\ntypedef struct cn_server_config_t\n{\n\tuint64_t application_id;            // A unique number to identify your game, can be whatever value you like.\n\t                                    // This must be the same number as in `cn_client_make`.\n\tint max_incoming_bytes_per_second;  // Not implemented yet.\n\tint max_outgoing_bytes_per_second;  // Not implemented yet.\n\tint connection_timeout;             // The number of seconds before consider a connection as timed out when not\n\t                                    // receiving any packets on the connection.\n\tdouble resend_rate;                 // The number of seconds to wait before resending a packet that has not been\n\t                                    // acknowledge as received by a client.\n\tcn_crypto_sign_public_t public_key; // The public part of your public key cryptography used for connect tokens.\n\t                                    // This can be safely shared with your players publicly.\n\tcn_crypto_sign_secret_t secret_key; // The secret part of your public key cryptography used for connect tokens.\n\t                                    // This must never be shared publicly and remain a complete secret only know to your servers.\n\tvoid* user_allocator_context;\n} cn_server_config_t;\n\nCN_INLINE cn_server_config_t cn_server_config_defaults(void)\n{\n\tcn_server_config_t config;\n\tconfig.application_id = 0;\n\tconfig.max_incoming_bytes_per_second = 0;\n\tconfig.max_outgoing_bytes_per_second = 0;\n\tconfig.connection_timeout = 10;\n\tconfig.resend_rate = 0.1f;\n\treturn config;\n}\n\ncn_server_t* cn_server_create(cn_server_config_t config);\nvoid cn_server_destroy(cn_server_t* server);\n\n/**\n * Starts up the server, ready to receive new client connections.\n * \n * Please note that not all users will be able to access an ipv6 server address, so it might\n * be good to also provide a way to connect through ipv4.\n */\ncn_result_t cn_server_start(cn_server_t* server, const char* address_and_port);\nvoid cn_server_stop(cn_server_t* server);\n\ntypedef enum cn_server_event_type_t\n{\n\tCN_SERVER_EVENT_TYPE_NEW_CONNECTION, // A new incoming connection.\n\tCN_SERVER_EVENT_TYPE_DISCONNECTED,   // A disconnecting client.\n\tCN_SERVER_EVENT_TYPE_PAYLOAD_PACKET, // An incoming packet from a client.\n} cn_server_event_type_t;\n\ntypedef struct cn_server_event_t\n{\n\tcn_server_event_type_t type;\n\tunion\n\t{\n\t\tstruct\n\t\t{\n\t\t\tint client_index;       // An index representing this particular client.\n\t\t\tuint64_t client_id;     // A unique identifier for this particular client, as read from the connect token.\n\t\t\tcn_endpoint_t endpoint; // The address and port of the incoming connection.\n\t\t} new_connection;\n\n\t\tstruct\n\t\t{\n\t\t\tint client_index;       // An index representing this particular client.\n\t\t} disconnected;\n\n\t\tstruct\n\t\t{\n\t\t\tint client_index;       // An index representing this particular client.\n\t\t\tvoid* data;             // Pointer to the packet's payload data. Send this back to `cn_server_free_packet` when done.\n\t\t\tint size;               // Size of the packet at the data pointer.\n\t\t} payload_packet;\n\t} u;\n} cn_server_event_t;\n\n/**\n * Server events notify of when a client connects/disconnects, or has sent a payload packet.\n * You must free the payload packets with `cn_server_free_packet` when done.\n */\nbool cn_server_pop_event(cn_server_t* server, cn_server_event_t* event);\nvoid cn_server_free_packet(cn_server_t* server, int client_index, void* data);\n\nvoid cn_server_update(cn_server_t* server, double dt, uint64_t current_time);\nvoid cn_server_disconnect_client(cn_server_t* server, int client_index, bool notify_client /* = true */);\n\n/**\n * Sends a packet to the client. If the packet size is too large (over 1k bytes) it will be split up\n * and sent in smaller chunks.\n * \n * `send_reliably` as true means the packet will be sent reliably an in-order relative to other\n * reliable packets. Under packet loss the packet will continually be sent until an acknowledgement\n * from the client is received. False means to send a typical UDP packet, with no special mechanisms\n * regarding packet loss.\n * \n * Reliable packets are significantly more expensive than unreliable packets, so try to send any data\n * that can be lost due to packet loss as an unreliable packet. Of course, some packets are required\n * to be sent, and so reliable is appropriate. As an optimization some kinds of data, such as frequent\n * transform updates, can be sent unreliably.\n * \n * Will return an error result if the packet cannot be queued up for some reason. This typically means\n * you are sending way too much data to the other end and need to slow down.\n * \n * IMPORTANT NOTE -- If you send reliable packets you _MUST_ be sending packets both to the server\n *                   and to the client. Two-way communication is required. If you only send reliable\n *                   packets one-way, it will never hear back from the other end whether or not those\n *                   packets safely arrived, and you will stall the connection. It's recommended to\n *                   constantly send packets back and forth each game tick. Each packet can confirm\n *                   32 other packets, so as a rule of thumb make sure you are sending at least one\n *                   packet for every 16 received.\n */\ncn_result_t cn_server_send(cn_server_t* server, const void* packet, int size, int client_index, bool send_reliably);\nbool cn_server_is_client_connected(cn_server_t* server, int client_index);\n\n/**\n * WARNING -- For test/dev builds only!\n * \n * If your server runs in the cloud with a public ip (highly recommended) this function is not at all necessary. However,\n * for testing purposes a lot of developers want to start out with port forwarding on their personal machine. Unfortunately\n * routers nowadays will likely act as your public IP. The connect token a client uses must use the router's IP address. As\n * the token is opened up by the server the server will notice it's local IP (something like 192.168.1.3) will not match the\n * the server's public ip listed in the connect token, causing a disconnect.\n * \n * Instead you may specify the server to match against it's *local IP*, instead of the public IP. This of course compromises\n * the entire security design, but it's a great way to get going before learning how to setup a proper dedicated server with\n * a real public IP address.\n * \n * For some more info/context you can see the original GitHub issue on this topic: https://github.com/RandyGaul/cute_headers/issues/344\n */\nvoid cn_server_set_public_ip(cn_server_t* server, const char* address_and_port);\n\nvoid cn_server_enable_network_simulator(cn_server_t* server, double latency, double jitter, double drop_chance, double duplicate_chance);\nfloat cn_server_get_packet_loss_estimate(cn_server_t* server, int client_index);\nfloat cn_server_get_rtt_estimate(cn_server_t* server, int client_index);\nfloat cn_server_get_incoming_kbps_estimate(cn_server_t* server, int client_index);\nfloat cn_server_get_outgoing_kbps_estimate(cn_server_t* server, int client_index);\n\n//--------------------------------------------------------------------------------------------------\n// ERROR\n\n#define CN_ERROR_SUCCESS (0)\n#define CN_ERROR_FAILURE (-1)\n\nstruct cn_result_t\n{\n\tint code;\n\tconst char* details;\n};\n\nCN_INLINE bool cn_is_error(cn_result_t result) { return result.code == CN_ERROR_FAILURE; }\nCN_INLINE cn_result_t cn_error_failure(const char* details) { cn_result_t result; result.code = CN_ERROR_FAILURE; result.details = details; return result; }\nCN_INLINE cn_result_t cn_error_success(void) { cn_result_t result; result.code = CN_ERROR_SUCCESS; result.details = NULL; return result; }\n#define CN_RETURN_IF_ERROR(x) do { cn_result_t result = (x); if (cn_is_error(result)) return result; } while (0)\n\n#endif // CN_NET_H\n\n#ifndef CN_NET_INTERNAL_H\n#define CN_NET_INTERNAL_H\n\n#define CN_CRYPTO_HEADER_BYTES ((int)(20 + 16))\n#define CN_KB 1024\n#define CN_MB (CN_KB * CN_KB)\n\n#endif // CN_NET_INTERNAL_H\n\n#ifdef CUTE_NET_IMPLEMENTATION\n#ifndef CUTE_NET_IMPLEMENTATION_ONCE\n#define CUTE_NET_IMPLEMENTATION_ONCE\n\n#if defined(_WIN32)\n#\tdefine CN_WINDOWS 1\n#elif defined(__linux__) || defined(__unix__) && !defined(__APPLE__) && !defined(__EMSCRIPTEN__)\n#\tdefine CN_LINUX 1\n#elif defined(__APPLE__)\n#\tinclude <TargetConditionals.h>\n#\tif TARGET_IPHONE_SIMULATOR || TARGET_OS_IPHONE\n#\t\tdefine CN_IOS 1\n#\telif TARGET_OS_MAC\n#\t\tdefine CN_MACOSX 1\n#\telse\n#\t\terror \"Unknown Apple platform\"\n#\tendif\n#elif defined(__ANDROID__)\n#\tdefine CN_ANDROID 1\n#elif defined(__EMSCRIPTEN__)\n#\terror Emscripten is not supported, as Cute Net uses the UDP transport layer.\n#endif\n\n#if !defined(CN_ALLOC)\n\t#include <stdlib.h>\n\t#define CN_ALLOC(size, ctx) malloc(size)\n\t#define CN_FREE(mem, ctx) free(mem)\n#endif\n\n#if !defined(CN_MEMCPY)\n\t#include <string.h>\n\t#define CN_MEMCPY memcpy\n#endif\n\n#if !defined(CN_MEMSET)\n\t#include <string.h>\n\t#define CN_MEMSET memset\n#endif\n\n#if !defined(CN_ASSERT)\n\t#include <assert.h>\n\t#define CN_ASSERT assert\n#endif\n\n#ifndef CN_STRNCPY\n#\tinclude <string.h>\n#\tdefine CN_STRNCPY strncpy\n#endif\n\n#ifndef CN_STRLEN\n#\tinclude <string.h>\n#\tdefine CN_STRLEN strlen\n#endif\n\n#ifndef CN_STRNCMP\n#\tinclude <string.h>\n#\tdefine CN_STRNCMP strncmp\n#endif\n\n#ifndef CN_MEMCMP\n#\tinclude <string.h>\n#\tdefine CN_MEMCMP memcmp\n#endif\n\n#ifndef CN_SNPRINTF\n#\tinclude <stdio.h>\n#\tdefine CN_SNPRINTF snprintf\n#endif\n\n#ifndef CN_FPRINTF\n#\tinclude <stdio.h>\n#\tdefine CN_FPRINTF fprintf\n#endif\n\n#ifndef CN_PRINTF\n#\tdefine CN_PRINTF(...)\n#endif\n\n//--------------------------------------------------------------------------------------------------\n// Embedded libhydrogen packed up from a python script.\n// See https://github.com/jedisct1/libhydrogen for the original source.\n\n#ifndef hydrogen_H\n#define hydrogen_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#ifdef __cplusplus\n#ifdef __GNUC__\n#pragma GCC diagnostic ignored \"-Wlong-long\"\n#endif\nextern \"C\" {\n#endif\n\n#if defined(__clang__) || defined(__GNUC__)\n#define _hydro_attr_(X) __attribute__(X)\n#else\n#define _hydro_attr_(X)\n#endif\n#define _hydro_attr_deprecated_ _hydro_attr_((deprecated))\n#define _hydro_attr_malloc_ _hydro_attr_((malloc))\n#define _hydro_attr_noinline_ _hydro_attr_((noinline))\n#define _hydro_attr_noreturn_ _hydro_attr_((noreturn))\n#define _hydro_attr_warn_unused_result_ _hydro_attr_((warn_unused_result))\n#define _hydro_attr_weak_ _hydro_attr_((weak))\n\n#if defined(__INTEL_COMPILER) || (defined(_MSC_VER) && !defined(__clang__))\n#define _hydro_attr_aligned_(X) __declspec(align(X))\n#elif defined(__clang__) || defined(__GNUC__)\n#define _hydro_attr_aligned_(X) _hydro_attr_((aligned(X)))\n#else\n#define _hydro_attr_aligned_(X)\n#endif\n\n#define HYDRO_VERSION_MAJOR 1\n#define HYDRO_VERSION_MINOR 0\n\nint hydro_init(void);\n\n/* ---------------- */\n\n#define hydro_random_SEEDBYTES 32\n\nuint32_t hydro_random_u32(void);\n\nuint32_t hydro_random_uniform(const uint32_t upper_bound);\n\nvoid hydro_random_buf(void *out, size_t out_len);\n\nvoid hydro_random_buf_deterministic(void *out, size_t out_len,\n\t\t\t\t\t\t\t\t\tconst uint8_t seed[hydro_random_SEEDBYTES]);\n\nvoid hydro_random_ratchet(void);\n\nvoid hydro_random_reseed(void);\n\n/* ---------------- */\n\n#define hydro_hash_BYTES 32\n#define hydro_hash_BYTES_MAX 65535\n#define hydro_hash_BYTES_MIN 16\n#define hydro_hash_CONTEXTBYTES 8\n#define hydro_hash_KEYBYTES 32\n\ntypedef struct hydro_hash_state {\n\tuint32_t state[12];\n\tuint8_t  buf_off;\n\tuint8_t  align[3];\n} hydro_hash_state;\n\nvoid hydro_hash_keygen(uint8_t key[hydro_hash_KEYBYTES]);\n\nint hydro_hash_init(hydro_hash_state *state, const char ctx[hydro_hash_CONTEXTBYTES],\n\t\t\t\t\tconst uint8_t key[hydro_hash_KEYBYTES]);\n\nint hydro_hash_update(hydro_hash_state *state, const void *in_, size_t in_len);\n\nint hydro_hash_final(hydro_hash_state *state, uint8_t *out, size_t out_len);\n\nint hydro_hash_hash(uint8_t *out, size_t out_len, const void *in_, size_t in_len,\n\t\t\t\t\tconst char    ctx[hydro_hash_CONTEXTBYTES],\n\t\t\t\t\tconst uint8_t key[hydro_hash_KEYBYTES]);\n\n/* ---------------- */\n\n#define hydro_secretbox_CONTEXTBYTES 8\n#define hydro_secretbox_HEADERBYTES (20 + 16)\n#define hydro_secretbox_KEYBYTES 32\n#define hydro_secretbox_PROBEBYTES 16\n\nvoid hydro_secretbox_keygen(uint8_t key[hydro_secretbox_KEYBYTES]);\n\nint hydro_secretbox_encrypt(uint8_t *c, const void *m_, size_t mlen, uint64_t msg_id,\n\t\t\t\t\t\t\tconst char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\tconst uint8_t key[hydro_secretbox_KEYBYTES]);\n\nint hydro_secretbox_decrypt(void *m_, const uint8_t *c, size_t clen, uint64_t msg_id,\n\t\t\t\t\t\t\tconst char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\tconst uint8_t key[hydro_secretbox_KEYBYTES])\n\t_hydro_attr_warn_unused_result_;\n\nvoid hydro_secretbox_probe_create(uint8_t probe[hydro_secretbox_PROBEBYTES], const uint8_t *c,\n\t\t\t\t\t\t\t\t  size_t c_len, const char ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\t\t  const uint8_t key[hydro_secretbox_KEYBYTES]);\n\nint hydro_secretbox_probe_verify(const uint8_t probe[hydro_secretbox_PROBEBYTES], const uint8_t *c,\n\t\t\t\t\t\t\t\t size_t c_len, const char ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\t\t const uint8_t key[hydro_secretbox_KEYBYTES])\n\t_hydro_attr_warn_unused_result_;\n\n/* ---------------- */\n\n#define hydro_kdf_CONTEXTBYTES 8\n#define hydro_kdf_KEYBYTES 32\n#define hydro_kdf_BYTES_MAX 65535\n#define hydro_kdf_BYTES_MIN 16\n\nvoid hydro_kdf_keygen(uint8_t key[hydro_kdf_KEYBYTES]);\n\nint hydro_kdf_derive_from_key(uint8_t *subkey, size_t subkey_len, uint64_t subkey_id,\n\t\t\t\t\t\t\t  const char    ctx[hydro_kdf_CONTEXTBYTES],\n\t\t\t\t\t\t\t  const uint8_t key[hydro_kdf_KEYBYTES]);\n\n/* ---------------- */\n\n#define hydro_sign_BYTES 64\n#define hydro_sign_CONTEXTBYTES 8\n#define hydro_sign_PUBLICKEYBYTES 32\n#define hydro_sign_SECRETKEYBYTES 64\n#define hydro_sign_SEEDBYTES 32\n\ntypedef struct hydro_sign_state {\n\thydro_hash_state hash_st;\n} hydro_sign_state;\n\ntypedef struct hydro_sign_keypair {\n\tuint8_t pk[hydro_sign_PUBLICKEYBYTES];\n\tuint8_t sk[hydro_sign_SECRETKEYBYTES];\n} hydro_sign_keypair;\n\nvoid hydro_sign_keygen(hydro_sign_keypair *kp);\n\nvoid hydro_sign_keygen_deterministic(hydro_sign_keypair *kp,\n\t\t\t\t\t\t\t\t\t const uint8_t       seed[hydro_sign_SEEDBYTES]);\n\nint hydro_sign_init(hydro_sign_state *state, const char ctx[hydro_sign_CONTEXTBYTES]);\n\nint hydro_sign_update(hydro_sign_state *state, const void *m_, size_t mlen);\n\nint hydro_sign_final_create(hydro_sign_state *state, uint8_t csig[hydro_sign_BYTES],\n\t\t\t\t\t\t\tconst uint8_t sk[hydro_sign_SECRETKEYBYTES]);\n\nint hydro_sign_final_verify(hydro_sign_state *state, const uint8_t csig[hydro_sign_BYTES],\n\t\t\t\t\t\t\tconst uint8_t pk[hydro_sign_PUBLICKEYBYTES])\n\t_hydro_attr_warn_unused_result_;\n\nint hydro_sign_create(uint8_t csig[hydro_sign_BYTES], const void *m_, size_t mlen,\n\t\t\t\t\t  const char    ctx[hydro_sign_CONTEXTBYTES],\n\t\t\t\t\t  const uint8_t sk[hydro_sign_SECRETKEYBYTES]);\n\nint hydro_sign_verify(const uint8_t csig[hydro_sign_BYTES], const void *m_, size_t mlen,\n\t\t\t\t\t  const char    ctx[hydro_sign_CONTEXTBYTES],\n\t\t\t\t\t  const uint8_t pk[hydro_sign_PUBLICKEYBYTES]) _hydro_attr_warn_unused_result_;\n\n/* ---------------- */\n\n#define hydro_kx_SESSIONKEYBYTES 32\n#define hydro_kx_PUBLICKEYBYTES 32\n#define hydro_kx_SECRETKEYBYTES 32\n#define hydro_kx_PSKBYTES 32\n#define hydro_kx_SEEDBYTES 32\n\ntypedef struct hydro_kx_keypair {\n\tuint8_t pk[hydro_kx_PUBLICKEYBYTES];\n\tuint8_t sk[hydro_kx_SECRETKEYBYTES];\n} hydro_kx_keypair;\n\ntypedef struct hydro_kx_session_keypair {\n\tuint8_t rx[hydro_kx_SESSIONKEYBYTES];\n\tuint8_t tx[hydro_kx_SESSIONKEYBYTES];\n} hydro_kx_session_keypair;\n\ntypedef struct hydro_kx_state {\n\thydro_kx_keypair eph_kp;\n\thydro_hash_state h_st;\n} hydro_kx_state;\n\nvoid hydro_kx_keygen(hydro_kx_keypair *static_kp);\n\nvoid hydro_kx_keygen_deterministic(hydro_kx_keypair *static_kp,\n\t\t\t\t\t\t\t\t   const uint8_t     seed[hydro_kx_SEEDBYTES]);\n\n/* NOISE_N */\n\n#define hydro_kx_N_PACKET1BYTES (32 + 16)\n\nint hydro_kx_n_1(hydro_kx_session_keypair *kp, uint8_t packet1[hydro_kx_N_PACKET1BYTES],\n\t\t\t\t const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t\t const uint8_t peer_static_pk[hydro_kx_PUBLICKEYBYTES]);\n\nint hydro_kx_n_2(hydro_kx_session_keypair *kp, const uint8_t packet1[hydro_kx_N_PACKET1BYTES],\n\t\t\t\t const uint8_t psk[hydro_kx_PSKBYTES], const hydro_kx_keypair *static_kp);\n\n/* NOISE_KK */\n\n#define hydro_kx_KK_PACKET1BYTES (32 + 16)\n#define hydro_kx_KK_PACKET2BYTES (32 + 16)\n\nint hydro_kx_kk_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_KK_PACKET1BYTES],\n\t\t\t\t  const uint8_t           peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t\t  const hydro_kx_keypair *static_kp);\n\nint hydro_kx_kk_2(hydro_kx_session_keypair *kp, uint8_t packet2[hydro_kx_KK_PACKET2BYTES],\n\t\t\t\t  const uint8_t           packet1[hydro_kx_KK_PACKET1BYTES],\n\t\t\t\t  const uint8_t           peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t\t  const hydro_kx_keypair *static_kp);\n\nint hydro_kx_kk_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t\t  const uint8_t           packet2[hydro_kx_KK_PACKET2BYTES],\n\t\t\t\t  const hydro_kx_keypair *static_kp);\n\n/* NOISE_XX */\n\n#define hydro_kx_XX_PACKET1BYTES (32 + 16)\n#define hydro_kx_XX_PACKET2BYTES (32 + 32 + 16 + 16)\n#define hydro_kx_XX_PACKET3BYTES (32 + 16 + 16)\n\nint hydro_kx_xx_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_XX_PACKET1BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES]);\n\nint hydro_kx_xx_2(hydro_kx_state *state, uint8_t packet2[hydro_kx_XX_PACKET2BYTES],\n\t\t\t\t  const uint8_t packet1[hydro_kx_XX_PACKET1BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES], const hydro_kx_keypair *static_kp);\n\nint hydro_kx_xx_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t\t  uint8_t       packet3[hydro_kx_XX_PACKET3BYTES],\n\t\t\t\t  uint8_t       peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t\t  const uint8_t packet2[hydro_kx_XX_PACKET2BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES], const hydro_kx_keypair *static_kp);\n\nint hydro_kx_xx_4(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t\t  uint8_t       peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t\t  const uint8_t packet3[hydro_kx_XX_PACKET3BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES]);\n\n/* NOISE_NK */\n\n#define hydro_kx_NK_PACKET1BYTES (32 + 16)\n#define hydro_kx_NK_PACKET2BYTES (32 + 16)\n\nint hydro_kx_nk_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_NK_PACKET1BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t\t  const uint8_t peer_static_pk[hydro_kx_PUBLICKEYBYTES]);\n\nint hydro_kx_nk_2(hydro_kx_session_keypair *kp, uint8_t packet2[hydro_kx_NK_PACKET2BYTES],\n\t\t\t\t  const uint8_t packet1[hydro_kx_NK_PACKET1BYTES],\n\t\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES], const hydro_kx_keypair *static_kp);\n\nint hydro_kx_nk_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t\t  const uint8_t packet2[hydro_kx_NK_PACKET2BYTES]);\n\n/* ---------------- */\n\n#define hydro_pwhash_CONTEXTBYTES 8\n#define hydro_pwhash_MASTERKEYBYTES 32\n#define hydro_pwhash_STOREDBYTES 128\n\nvoid hydro_pwhash_keygen(uint8_t master_key[hydro_pwhash_MASTERKEYBYTES]);\n\nint hydro_pwhash_deterministic(uint8_t *h, size_t h_len, const char *passwd, size_t passwd_len,\n\t\t\t\t\t\t\t   const char    ctx[hydro_pwhash_CONTEXTBYTES],\n\t\t\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\t\t   uint64_t opslimit, size_t memlimit, uint8_t threads);\n\nint hydro_pwhash_create(uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd,\n\t\t\t\t\t\tsize_t passwd_len, const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\tuint64_t opslimit, size_t memlimit, uint8_t threads);\n\nint hydro_pwhash_verify(const uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd,\n\t\t\t\t\t\tsize_t passwd_len, const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\tuint64_t opslimit_max, size_t memlimit_max, uint8_t threads_max);\n\nint hydro_pwhash_derive_static_key(uint8_t *static_key, size_t static_key_len,\n\t\t\t\t\t\t\t\t   const uint8_t stored[hydro_pwhash_STOREDBYTES],\n\t\t\t\t\t\t\t\t   const char *passwd, size_t passwd_len,\n\t\t\t\t\t\t\t\t   const char    ctx[hydro_pwhash_CONTEXTBYTES],\n\t\t\t\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\t\t\t   uint64_t opslimit_max, size_t memlimit_max, uint8_t threads_max);\n\nint hydro_pwhash_reencrypt(uint8_t       stored[hydro_pwhash_STOREDBYTES],\n\t\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\t   const uint8_t new_master_key[hydro_pwhash_MASTERKEYBYTES]);\n\nint hydro_pwhash_upgrade(uint8_t       stored[hydro_pwhash_STOREDBYTES],\n\t\t\t\t\t\t const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES], uint64_t opslimit,\n\t\t\t\t\t\t size_t memlimit, uint8_t threads);\n\n/* ---------------- */\n\nvoid hydro_memzero(void *pnt, size_t len);\n\nvoid hydro_increment(uint8_t *n, size_t len);\n\nbool hydro_equal(const void *b1_, const void *b2_, size_t len);\n\nint hydro_compare(const uint8_t *b1_, const uint8_t *b2_, size_t len);\n\nchar *hydro_bin2hex(char *hex, size_t hex_maxlen, const uint8_t *bin, size_t bin_len);\n\nint hydro_hex2bin(uint8_t *bin, size_t bin_maxlen, const char *hex, size_t hex_len,\n\t\t\t\t  const char *ignore, const char **hex_end_p);\n\nint hydro_pad(unsigned char *buf, size_t unpadded_buflen, size_t blocksize, size_t max_buflen);\n\nint hydro_unpad(const unsigned char *buf, size_t padded_buflen, size_t blocksize);\n\n/* ---------------- */\n\n#define HYDRO_HWTYPE_ATMEGA328 1\n\n#ifndef HYDRO_HWTYPE\n#ifdef __AVR__\n#define HYDRO_HWTYPE HYDRO_HWTYPE_ATMEGA328\n#endif\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if !defined(__unix__) && (defined(__APPLE__) || defined(__linux__))\n#define __unix__ 1\n#endif\n#ifndef __GNUC__\n#define __restrict__\n#endif\n\n#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && \\\n\t__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define NATIVE_BIG_ENDIAN\n#endif\n#ifndef NATIVE_BIG_ENDIAN\n#ifndef NATIVE_LITTLE_ENDIAN\n#define NATIVE_LITTLE_ENDIAN\n#endif\n#endif\n\n#ifndef TLS\n#if defined(_WIN32) && !defined(__GNUC__)\n#define TLS __declspec(thread)\n#elif (defined(__clang__) || defined(__GNUC__)) && defined(__unix__)\n#define TLS __thread\n#else\n#define TLS\n#endif\n#endif\n\n#ifndef SIZE_MAX\n#define SIZE_MAX ((size_t) -1)\n#endif\n\n#ifdef __OpenBSD__\n#define HAVE_EXPLICIT_BZERO 1\n#elif defined(__GLIBC__) && defined(__GLIBC_PREREQ) && defined(_GNU_SOURCE)\n#if __GLIBC_PREREQ(2, 25)\n#define HAVE_EXPLICIT_BZERO 1\n#endif\n#endif\n\n#define COMPILER_ASSERT(X) (void) sizeof(char[(X) ? 1 : -1])\n\n#define ROTL32(x, b) (uint32_t)(((x) << (b)) | ((x) >> (32 - (b))))\n#define ROTL64(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\n#define ROTR32(x, b) (uint32_t)(((x) >> (b)) | ((x) << (32 - (b))))\n#define ROTR64(x, b) (uint64_t)(((x) >> (b)) | ((x) << (64 - (b))))\n\n#if defined(_MSC_VER)\n#\tpragma warning(push)\n#\tpragma warning(disable : 4197)\n#\tpragma warning(disable : 4146)\n#endif\n\n#define LOAD64_LE(SRC) load64_le(SRC)\nstatic inline uint64_t\nload64_le(const uint8_t src[8])\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tuint64_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint64_t w = (uint64_t) src[0];\n\tw |= (uint64_t) src[1] << 8;\n\tw |= (uint64_t) src[2] << 16;\n\tw |= (uint64_t) src[3] << 24;\n\tw |= (uint64_t) src[4] << 32;\n\tw |= (uint64_t) src[5] << 40;\n\tw |= (uint64_t) src[6] << 48;\n\tw |= (uint64_t) src[7] << 56;\n\treturn w;\n#endif\n}\n\n#define STORE64_LE(DST, W) store64_le((DST), (W))\nstatic inline void\nstore64_le(uint8_t dst[8], uint64_t w)\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[0] = (uint8_t) w;\n\tw >>= 8;\n\tdst[1] = (uint8_t) w;\n\tw >>= 8;\n\tdst[2] = (uint8_t) w;\n\tw >>= 8;\n\tdst[3] = (uint8_t) w;\n\tw >>= 8;\n\tdst[4] = (uint8_t) w;\n\tw >>= 8;\n\tdst[5] = (uint8_t) w;\n\tw >>= 8;\n\tdst[6] = (uint8_t) w;\n\tw >>= 8;\n\tdst[7] = (uint8_t) w;\n#endif\n}\n\n#define LOAD32_LE(SRC) load32_le(SRC)\nstatic inline uint32_t\nload32_le(const uint8_t src[4])\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tuint32_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint32_t w = (uint32_t) src[0];\n\tw |= (uint32_t) src[1] << 8;\n\tw |= (uint32_t) src[2] << 16;\n\tw |= (uint32_t) src[3] << 24;\n\treturn w;\n#endif\n}\n\n#define STORE32_LE(DST, W) store32_le((DST), (W))\nstatic inline void\nstore32_le(uint8_t dst[4], uint32_t w)\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[0] = (uint8_t) w;\n\tw >>= 8;\n\tdst[1] = (uint8_t) w;\n\tw >>= 8;\n\tdst[2] = (uint8_t) w;\n\tw >>= 8;\n\tdst[3] = (uint8_t) w;\n#endif\n}\n\n#define LOAD16_LE(SRC) load16_le(SRC)\nstatic inline uint16_t\nload16_le(const uint8_t src[2])\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tuint16_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint16_t w = (uint16_t) src[0];\n\tw |= (uint16_t) src[1] << 8;\n\treturn w;\n#endif\n}\n\n#define STORE16_LE(DST, W) store16_le((DST), (W))\nstatic inline void\nstore16_le(uint8_t dst[2], uint16_t w)\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[0] = (uint8_t) w;\n\tw >>= 8;\n\tdst[1] = (uint8_t) w;\n#endif\n}\n\n/* ----- */\n\n#define LOAD64_BE(SRC) load64_be(SRC)\nstatic inline uint64_t\nload64_be(const uint8_t src[8])\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tuint64_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint64_t w = (uint64_t) src[7];\n\tw |= (uint64_t) src[6] << 8;\n\tw |= (uint64_t) src[5] << 16;\n\tw |= (uint64_t) src[4] << 24;\n\tw |= (uint64_t) src[3] << 32;\n\tw |= (uint64_t) src[2] << 40;\n\tw |= (uint64_t) src[1] << 48;\n\tw |= (uint64_t) src[0] << 56;\n\treturn w;\n#endif\n}\n\n#define STORE64_BE(DST, W) store64_be((DST), (W))\nstatic inline void\nstore64_be(uint8_t dst[8], uint64_t w)\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[7] = (uint8_t) w;\n\tw >>= 8;\n\tdst[6] = (uint8_t) w;\n\tw >>= 8;\n\tdst[5] = (uint8_t) w;\n\tw >>= 8;\n\tdst[4] = (uint8_t) w;\n\tw >>= 8;\n\tdst[3] = (uint8_t) w;\n\tw >>= 8;\n\tdst[2] = (uint8_t) w;\n\tw >>= 8;\n\tdst[1] = (uint8_t) w;\n\tw >>= 8;\n\tdst[0] = (uint8_t) w;\n#endif\n}\n\n#define LOAD32_BE(SRC) load32_be(SRC)\nstatic inline uint32_t\nload32_be(const uint8_t src[4])\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tuint32_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint32_t w = (uint32_t) src[3];\n\tw |= (uint32_t) src[2] << 8;\n\tw |= (uint32_t) src[1] << 16;\n\tw |= (uint32_t) src[0] << 24;\n\treturn w;\n#endif\n}\n\n#define STORE32_BE(DST, W) store32_be((DST), (W))\nstatic inline void\nstore32_be(uint8_t dst[4], uint32_t w)\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[3] = (uint8_t) w;\n\tw >>= 8;\n\tdst[2] = (uint8_t) w;\n\tw >>= 8;\n\tdst[1] = (uint8_t) w;\n\tw >>= 8;\n\tdst[0] = (uint8_t) w;\n#endif\n}\n\n#define LOAD16_BE(SRC) load16_be(SRC)\nstatic inline uint16_t\nload16_be(const uint8_t src[2])\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tuint16_t w;\n\tmemcpy(&w, src, sizeof w);\n\treturn w;\n#else\n\tuint16_t w = (uint16_t) src[1];\n\tw |= (uint16_t) src[0] << 8;\n\treturn w;\n#endif\n}\n\n#define STORE16_BE(DST, W) store16_be((DST), (W))\nstatic inline void\nstore16_be(uint8_t dst[2], uint16_t w)\n{\n#ifdef NATIVE_BIG_ENDIAN\n\tmemcpy(dst, &w, sizeof w);\n#else\n\tdst[1] = (uint8_t) w;\n\tw >>= 8;\n\tdst[0] = (uint8_t) w;\n#endif\n}\n\nstatic inline void\nmem_cpy(void *__restrict__ dst_, const void *__restrict__ src_, size_t n)\n{\n\tunsigned char *      dst = (unsigned char *) dst_;\n\tconst unsigned char *src = (const unsigned char *) src_;\n\tsize_t               i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = src[i];\n\t}\n}\n\nstatic inline void\nmem_zero(void *dst_, size_t n)\n{\n\tunsigned char *dst = (unsigned char *) dst_;\n\tsize_t         i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = 0;\n\t}\n}\n\nstatic inline void\nmem_xor(void *__restrict__ dst_, const void *__restrict__ src_, size_t n)\n{\n\tunsigned char *      dst = (unsigned char *) dst_;\n\tconst unsigned char *src = (const unsigned char *) src_;\n\tsize_t               i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] ^= src[i];\n\t}\n}\n\nstatic inline void\nmem_xor2(void *__restrict__ dst_, const void *__restrict__ src1_, const void *__restrict__ src2_,\n\t\t size_t n)\n{\n\tunsigned char *      dst  = (unsigned char *) dst_;\n\tconst unsigned char *src1 = (const unsigned char *) src1_;\n\tconst unsigned char *src2 = (const unsigned char *) src2_;\n\tsize_t               i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = src1[i] ^ src2[i];\n\t}\n}\n\nstatic const uint8_t zero[64] = { 0 };\n\n\nstatic int hydro_random_init(void);\n\n/* ---------------- */\n\n#define gimli_BLOCKBYTES 48\n#define gimli_CAPACITY 32\n#define gimli_RATE 16\n\n#define gimli_TAG_HEADER 0x01\n#define gimli_TAG_PAYLOAD 0x02\n#define gimli_TAG_FINAL 0x08\n#define gimli_TAG_FINAL0 0xf8\n#define gimli_TAG_KEY0 0xfe\n#define gimli_TAG_KEY 0xff\n\n#define gimli_DOMAIN_AEAD 0x0\n#define gimli_DOMAIN_XOF 0xf\n\nstatic void gimli_core_u8(uint8_t state_u8[gimli_BLOCKBYTES], uint8_t tag);\n\nstatic inline void\ngimli_pad_u8(uint8_t buf[gimli_BLOCKBYTES], size_t pos, uint8_t domain)\n{\n\tbuf[pos] ^= (domain << 1) | 1;\n\tbuf[gimli_RATE - 1] ^= 0x80;\n}\n\nstatic inline void\nhydro_mem_ct_zero_u32(uint32_t *dst_, size_t n)\n{\n\tvolatile uint32_t *volatile dst = (volatile uint32_t * volatile)(void *) dst_;\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = 0;\n\t}\n}\n\nstatic inline uint32_t hydro_mem_ct_cmp_u32(const uint32_t *b1_, const uint32_t *b2,\n\t\t\t\t\t\t\t\t\t\t\tsize_t n) _hydro_attr_warn_unused_result_;\n\nstatic inline uint32_t\nhydro_mem_ct_cmp_u32(const uint32_t *b1_, const uint32_t *b2, size_t n)\n{\n\tconst volatile uint32_t *volatile b1 = (const volatile uint32_t *volatile)(const void *) b1_;\n\tsize_t   i;\n\tuint32_t cv = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcv |= b1[i] ^ b2[i];\n\t}\n\treturn cv;\n}\n\n/* ---------------- */\n\nstatic int hydro_hash_init_with_tweak(hydro_hash_state *state,\n\t\t\t\t\t\t\t\t\t  const char ctx[hydro_hash_CONTEXTBYTES], uint64_t tweak,\n\t\t\t\t\t\t\t\t\t  const uint8_t key[hydro_hash_KEYBYTES]);\n\n/* ---------------- */\n\n#define hydro_secretbox_NONCEBYTES 20\n#define hydro_secretbox_MACBYTES 16\n\n/* ---------------- */\n\n#define hydro_x25519_BYTES 32\n#define hydro_x25519_PUBLICKEYBYTES 32\n#define hydro_x25519_SECRETKEYBYTES 32\n\nstatic int hydro_x25519_scalarmult(uint8_t       out[hydro_x25519_BYTES],\n\t\t\t\t\t\t\t\t   const uint8_t scalar[hydro_x25519_SECRETKEYBYTES],\n\t\t\t\t\t\t\t\t   const uint8_t x1[hydro_x25519_PUBLICKEYBYTES],\n\t\t\t\t\t\t\t\t   bool          clamp) _hydro_attr_warn_unused_result_;\n\nstatic inline int hydro_x25519_scalarmult_base(uint8_t       pk[hydro_x25519_PUBLICKEYBYTES],\n\t\t\t\t\t\t\t\t\t\t\t   const uint8_t sk[hydro_x25519_SECRETKEYBYTES])\n\t_hydro_attr_warn_unused_result_;\n\nstatic inline void\nhydro_x25519_scalarmult_base_uniform(uint8_t       pk[hydro_x25519_PUBLICKEYBYTES],\n\t\t\t\t\t\t\t\t\t const uint8_t sk[hydro_x25519_SECRETKEYBYTES]);\n\n\nint\nhydro_init(void)\n{\n\tif (hydro_random_init() != 0) {\n\t\tabort();\n\t}\n\treturn 0;\n}\n\nvoid\nhydro_memzero(void *pnt, size_t len)\n{\n#ifdef HAVE_EXPLICIT_BZERO\n\texplicit_bzero(pnt, len);\n#else\n\tvolatile unsigned char *volatile pnt_ = (volatile unsigned char *volatile) pnt;\n\tsize_t i                              = (size_t) 0U;\n\n\twhile (i < len) {\n\t\tpnt_[i++] = 0U;\n\t}\n#endif\n}\n\nvoid\nhydro_increment(uint8_t *n, size_t len)\n{\n\tsize_t        i;\n\tuint_fast16_t c = 1U;\n\n\tfor (i = 0; i < len; i++) {\n\t\tc += (uint_fast16_t) n[i];\n\t\tn[i] = (uint8_t) c;\n\t\tc >>= 8;\n\t}\n}\n\nchar *\nhydro_bin2hex(char *hex, size_t hex_maxlen, const uint8_t *bin, size_t bin_len)\n{\n\tsize_t       i = (size_t) 0U;\n\tunsigned int x;\n\tint          b;\n\tint          c;\n\n\tif (bin_len >= SIZE_MAX / 2 || hex_maxlen <= bin_len * 2U) {\n\t\tabort();\n\t}\n\twhile (i < bin_len) {\n\t\tc = bin[i] & 0xf;\n\t\tb = bin[i] >> 4;\n\t\tx = (unsigned char) (87U + c + (((c - 10U) >> 8) & ~38U)) << 8 |\n\t\t\t(unsigned char) (87U + b + (((b - 10U) >> 8) & ~38U));\n\t\thex[i * 2U] = (char) x;\n\t\tx >>= 8;\n\t\thex[i * 2U + 1U] = (char) x;\n\t\ti++;\n\t}\n\thex[i * 2U] = 0U;\n\n\treturn hex;\n}\n\nint\nhydro_hex2bin(uint8_t *bin, size_t bin_maxlen, const char *hex, size_t hex_len, const char *ignore,\n\t\t\t  const char **hex_end_p)\n{\n\tsize_t        bin_pos = (size_t) 0U;\n\tsize_t        hex_pos = (size_t) 0U;\n\tint           ret     = 0;\n\tunsigned char c;\n\tunsigned char c_alpha0, c_alpha;\n\tunsigned char c_num0, c_num;\n\tuint8_t       c_acc = 0U;\n\tuint8_t       c_val;\n\tunsigned char state = 0U;\n\n\twhile (hex_pos < hex_len) {\n\t\tc        = (unsigned char) hex[hex_pos];\n\t\tc_num    = c ^ 48U;\n\t\tc_num0   = (c_num - 10U) >> 8;\n\t\tc_alpha  = (c & ~32U) - 55U;\n\t\tc_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;\n\t\tif ((c_num0 | c_alpha0) == 0U) {\n\t\t\tif (ignore != NULL && state == 0U && strchr(ignore, c) != NULL) {\n\t\t\t\thex_pos++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tc_val = (uint8_t)((c_num0 & c_num) | (c_alpha0 & c_alpha));\n\t\tif (bin_pos >= bin_maxlen) {\n\t\t\tret   = -1;\n\t\t\terrno = ERANGE;\n\t\t\tbreak;\n\t\t}\n\t\tif (state == 0U) {\n\t\t\tc_acc = c_val * 16U;\n\t\t} else {\n\t\t\tbin[bin_pos++] = c_acc | c_val;\n\t\t}\n\t\tstate = ~state;\n\t\thex_pos++;\n\t}\n\tif (state != 0U) {\n\t\thex_pos--;\n\t\terrno = EINVAL;\n\t\tret   = -1;\n\t}\n\tif (ret != 0) {\n\t\tbin_pos = (size_t) 0U;\n\t}\n\tif (hex_end_p != NULL) {\n\t\t*hex_end_p = &hex[hex_pos];\n\t} else if (hex_pos != hex_len) {\n\t\terrno = EINVAL;\n\t\tret   = -1;\n\t}\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\treturn (int) bin_pos;\n}\n\nbool\nhydro_equal(const void *b1_, const void *b2_, size_t len)\n{\n\tconst volatile uint8_t *volatile b1 = (const volatile uint8_t *volatile) b1_;\n\tconst uint8_t *b2                   = (const uint8_t *) b2_;\n\tsize_t         i;\n\tuint8_t        d = (uint8_t) 0U;\n\n\tif (b1 == b2) {\n\t\td = ~d;\n\t}\n\tfor (i = 0U; i < len; i++) {\n\t\td |= b1[i] ^ b2[i];\n\t}\n\treturn (bool) (1 & ((d - 1) >> 8));\n}\n\nint\nhydro_compare(const uint8_t *b1_, const uint8_t *b2_, size_t len)\n{\n\tconst volatile uint8_t *volatile b1 = (const volatile uint8_t *volatile) b1_;\n\tconst uint8_t *b2                   = (const uint8_t *) b2_;\n\tuint8_t        gt                   = 0U;\n\tuint8_t        eq                   = 1U;\n\tsize_t         i;\n\n\ti = len;\n\twhile (i != 0U) {\n\t\ti--;\n\t\tgt |= ((b2[i] - b1[i]) >> 8) & eq;\n\t\teq &= ((b2[i] ^ b1[i]) - 1) >> 8;\n\t}\n\treturn (int) (gt + gt + eq) - 1;\n}\n\nint\nhydro_pad(unsigned char *buf, size_t unpadded_buflen, size_t blocksize, size_t max_buflen)\n{\n\tunsigned char *        tail;\n\tsize_t                 i;\n\tsize_t                 xpadlen;\n\tsize_t                 xpadded_len;\n\tvolatile unsigned char mask;\n\tunsigned char          barrier_mask;\n\n\tif (blocksize <= 0U || max_buflen > INT_MAX) {\n\t\treturn -1;\n\t}\n\txpadlen = blocksize - 1U;\n\tif ((blocksize & (blocksize - 1U)) == 0U) {\n\t\txpadlen -= unpadded_buflen & (blocksize - 1U);\n\t} else {\n\t\txpadlen -= unpadded_buflen % blocksize;\n\t}\n\tif (SIZE_MAX - unpadded_buflen <= xpadlen) {\n\t\treturn -1;\n\t}\n\txpadded_len = unpadded_buflen + xpadlen;\n\tif (xpadded_len >= max_buflen) {\n\t\treturn -1;\n\t}\n\ttail = &buf[xpadded_len];\n\tmask = 0U;\n\tfor (i = 0; i < blocksize; i++) {\n\t\tbarrier_mask = (unsigned char) (((i ^ xpadlen) - 1U) >> ((sizeof(size_t) - 1U) * CHAR_BIT));\n\t\ttail[-i]     = (tail[-i] & mask) | (0x80 & barrier_mask);\n\t\tmask |= barrier_mask;\n\t}\n\treturn (int) (xpadded_len + 1);\n}\n\nint\nhydro_unpad(const unsigned char *buf, size_t padded_buflen, size_t blocksize)\n{\n\tconst unsigned char *tail;\n\tunsigned char        acc = 0U;\n\tunsigned char        c;\n\tunsigned char        valid   = 0U;\n\tvolatile size_t      pad_len = 0U;\n\tsize_t               i;\n\tsize_t               is_barrier;\n\n\tif (padded_buflen < blocksize || blocksize <= 0U) {\n\t\treturn -1;\n\t}\n\ttail = &buf[padded_buflen - 1U];\n\n\tfor (i = 0U; i < blocksize; i++) {\n\t\tc          = tail[-i];\n\t\tis_barrier = (((acc - 1U) & (pad_len - 1U) & ((c ^ 0x80) - 1U)) >> 8) & 1U;\n\t\tacc |= c;\n\t\tpad_len |= (i & -is_barrier);\n\t\tvalid |= (unsigned char) is_barrier;\n\t}\n\tif (valid == 0) {\n\t\treturn -1;\n\t}\n\treturn (int) (padded_buflen - 1 - pad_len);\n}\n\n#ifdef __SSE2__\n\n\t#include <emmintrin.h>\n\t#ifdef __SSSE3__\n\t# include <tmmintrin.h>\n\t#endif\n\n\t#define S 9\n\n\tstatic inline __m128i\n\tshift(__m128i x, int bits)\n\t{\n\t\treturn _mm_slli_epi32(x, bits);\n\t}\n\n\tstatic inline __m128i\n\trotate(__m128i x, int bits)\n\t{\n\t\treturn _mm_slli_epi32(x, bits) | _mm_srli_epi32(x, 32 - bits);\n\t}\n\n\t#ifdef __SSSE3__\n\tstatic inline __m128i\n\trotate24(__m128i x)\n\t{\n\t\treturn _mm_shuffle_epi8(x, _mm_set_epi8(12, 15, 14, 13, 8, 11, 10, 9, 4, 7, 6, 5, 0, 3, 2, 1));\n\t}\n\t#else\n\tstatic inline __m128i\n\trotate24(__m128i x)\n\t{\n\t\tuint8_t _hydro_attr_aligned_(16) x8[16], y8[16];\n\n\t\t_mm_storeu_si128((__m128i *) (void *) x8, x);\n\n\t\ty8[ 0] = x8[ 1]; y8[ 1] = x8[ 2]; y8[ 2] = x8[ 3]; y8[ 3] = x8[ 0];\n\t\ty8[ 4] = x8[ 5]; y8[ 5] = x8[ 6]; y8[ 6] = x8[ 7]; y8[ 7] = x8[ 4];\n\t\ty8[ 8] = x8[ 9]; y8[ 9] = x8[10]; y8[10] = x8[11]; y8[11] = x8[ 8];\n\t\ty8[12] = x8[13]; y8[13] = x8[14]; y8[14] = x8[15]; y8[15] = x8[12];\n\n\t\treturn _mm_loadu_si128((const __m128i *) (const void *) y8);\n\t}\n\t#endif\n\n\tstatic const uint32_t coeffs[24] _hydro_attr_aligned_(16) = {\n\t\t0x9e377904, 0, 0, 0, 0x9e377908, 0, 0, 0, 0x9e37790c, 0, 0, 0,\n\t\t0x9e377910, 0, 0, 0, 0x9e377914, 0, 0, 0, 0x9e377918, 0, 0, 0,\n\t};\n\n\tstatic void\n\tgimli_core(uint32_t state[gimli_BLOCKBYTES / 4])\n\t{\n\t\t__m128i x = _mm_loadu_si128((const __m128i *) (const void *) &state[0]);\n\t\t__m128i y = _mm_loadu_si128((const __m128i *) (const void *) &state[4]);\n\t\t__m128i z = _mm_loadu_si128((const __m128i *) (const void *) &state[8]);\n\t\t__m128i newy;\n\t\t__m128i newz;\n\t\tint     round;\n\n\t\tfor (round = 5; round >= 0; round--) {\n\t\t\tx    = rotate24(x);\n\t\t\ty    = rotate(y, S);\n\t\t\tnewz = x ^ shift(z, 1) ^ shift(y & z, 2);\n\t\t\tnewy = y ^ x ^ shift(x | z, 1);\n\t\t\tx    = z ^ y ^ shift(x & y, 3);\n\t\t\ty    = newy;\n\t\t\tz    = newz;\n\n\t\t\tx = _mm_shuffle_epi32(x, _MM_SHUFFLE(2, 3, 0, 1));\n\t\t\tx ^= ((const __m128i *) (const void *) coeffs)[round];\n\n\t\t\tx    = rotate24(x);\n\t\t\ty    = rotate(y, S);\n\t\t\tnewz = x ^ shift(z, 1) ^ shift(y & z, 2);\n\t\t\tnewy = y ^ x ^ shift(x | z, 1);\n\t\t\tx    = z ^ y ^ shift(x & y, 3);\n\t\t\ty    = newy;\n\t\t\tz    = newz;\n\n\t\t\tx    = rotate24(x);\n\t\t\ty    = rotate(y, S);\n\t\t\tnewz = x ^ shift(z, 1) ^ shift(y & z, 2);\n\t\t\tnewy = y ^ x ^ shift(x | z, 1);\n\t\t\tx    = z ^ y ^ shift(x & y, 3);\n\t\t\ty    = newy;\n\t\t\tz    = newz;\n\n\t\t\tx = _mm_shuffle_epi32(x, _MM_SHUFFLE(1, 0, 3, 2));\n\n\t\t\tx    = rotate24(x);\n\t\t\ty    = rotate(y, S);\n\t\t\tnewz = x ^ shift(z, 1) ^ shift(y & z, 2);\n\t\t\tnewy = y ^ x ^ shift(x | z, 1);\n\t\t\tx    = z ^ y ^ shift(x & y, 3);\n\t\t\ty    = newy;\n\t\t\tz    = newz;\n\t\t}\n\n\t\t_mm_storeu_si128((__m128i *) (void *) &state[0], x);\n\t\t_mm_storeu_si128((__m128i *) (void *) &state[4], y);\n\t\t_mm_storeu_si128((__m128i *) (void *) &state[8], z);\n\t}\n\t#undef S\n#else\n\n\tstatic void\n\tgimli_core(uint32_t state[gimli_BLOCKBYTES / 4])\n\t{\n\t\tunsigned int round;\n\t\tunsigned int column;\n\t\tuint32_t     x;\n\t\tuint32_t     y;\n\t\tuint32_t     z;\n\n\t\tfor (round = 24; round > 0; round--) {\n\t\t\tfor (column = 0; column < 4; column++) {\n\t\t\t\tx = ROTL32(state[column], 24);\n\t\t\t\ty = ROTL32(state[4 + column], 9);\n\t\t\t\tz = state[8 + column];\n\n\t\t\t\tstate[8 + column] = x ^ (z << 1) ^ ((y & z) << 2);\n\t\t\t\tstate[4 + column] = y ^ x ^ ((x | z) << 1);\n\t\t\t\tstate[column]     = z ^ y ^ ((x & y) << 3);\n\t\t\t}\n\t\t\tswitch (round & 3) {\n\t\t\tcase 0:\n\t\t\t\tx        = state[0];\n\t\t\t\tstate[0] = state[1];\n\t\t\t\tstate[1] = x;\n\t\t\t\tx        = state[2];\n\t\t\t\tstate[2] = state[3];\n\t\t\t\tstate[3] = x;\n\t\t\t\tstate[0] ^= ((uint32_t) 0x9e377900 | round);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tx        = state[0];\n\t\t\t\tstate[0] = state[2];\n\t\t\t\tstate[2] = x;\n\t\t\t\tx        = state[1];\n\t\t\t\tstate[1] = state[3];\n\t\t\t\tstate[3] = x;\n\t\t\t}\n\t\t}\n\t}\n\n#endif\n\nstatic void\ngimli_core_u8(uint8_t state_u8[gimli_BLOCKBYTES], uint8_t tag)\n{\n\tstate_u8[gimli_BLOCKBYTES - 1] ^= tag;\n#ifndef NATIVE_LITTLE_ENDIAN\n\tuint32_t state_u32[12];\n\tint      i;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tstate_u32[i] = LOAD32_LE(&state_u8[i * 4]);\n\t}\n\tgimli_core(state_u32);\n\tfor (i = 0; i < 12; i++) {\n\t\tSTORE32_LE(&state_u8[i * 4], state_u32[i]);\n\t}\n#else\n\tgimli_core((uint32_t *) (void *) state_u8); /* state_u8 must be properly aligned */\n#endif\n}\n\n\nstatic TLS struct {\n\t_hydro_attr_aligned_(16) uint8_t state[gimli_BLOCKBYTES];\n\tuint64_t counter;\n\tuint8_t  initialized;\n\tuint8_t  available;\n} hydro_random_context;\n\n#if defined(AVR) && !defined(__unix__)\n\n\t#include <Arduino.h>\n\n\tstatic bool\n\thydro_random_rbit(uint16_t x)\n\t{\n\t\tuint8_t x8;\n\n\t\tx8 = ((uint8_t)(x >> 8)) ^ (uint8_t) x;\n\t\tx8 = (x8 >> 4) ^ (x8 & 0xf);\n\t\tx8 = (x8 >> 2) ^ (x8 & 0x3);\n\t\tx8 = (x8 >> 1) ^ x8;\n\n\t\treturn (bool) (x8 & 1);\n\t}\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tconst char       ctx[hydro_hash_CONTEXTBYTES] = { 'h', 'y', 'd', 'r', 'o', 'P', 'R', 'G' };\n\t\thydro_hash_state st;\n\t\tuint16_t         ebits = 0;\n\t\tuint16_t         tc;\n\t\tbool             a, b;\n\n\t\tcli();\n\t\tMCUSR = 0;\n\t\tWDTCSR |= _BV(WDCE) | _BV(WDE);\n\t\tWDTCSR = _BV(WDIE);\n\t\tsei();\n\n\t\thydro_hash_init(&st, ctx, NULL);\n\n\t\twhile (ebits < 256) {\n\t\t\tdelay(1);\n\t\t\ttc = TCNT1;\n\t\t\thydro_hash_update(&st, (const uint8_t *) &tc, sizeof tc);\n\t\t\ta = hydro_random_rbit(tc);\n\t\t\tdelay(1);\n\t\t\ttc = TCNT1;\n\t\t\tb  = hydro_random_rbit(tc);\n\t\t\thydro_hash_update(&st, (const uint8_t *) &tc, sizeof tc);\n\t\t\tif (a == b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thydro_hash_update(&st, (const uint8_t *) &b, sizeof b);\n\t\t\tebits++;\n\t\t}\n\n\t\tcli();\n\t\tMCUSR = 0;\n\t\tWDTCSR |= _BV(WDCE) | _BV(WDE);\n\t\tWDTCSR = 0;\n\t\tsei();\n\n\t\thydro_hash_final(&st, hydro_random_context.state, sizeof hydro_random_context.state);\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n\tISR(WDT_vect) {}\n\n#elif (defined(ESP32) || defined(ESP8266)) && !defined(__unix__)\n\n\t// Important: RF *must* be activated on ESP board\n\t// https://techtutorialsx.com/2017/12/22/esp32-arduino-random-number-generation/\n\t#ifdef ESP32\n\t# include <esp_system.h>\n\t#endif\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tconst char       ctx[hydro_hash_CONTEXTBYTES] = { 'h', 'y', 'd', 'r', 'o', 'P', 'R', 'G' };\n\t\thydro_hash_state st;\n\t\tuint16_t         ebits = 0;\n\n\t\thydro_hash_init(&st, ctx, NULL);\n\n\t\twhile (ebits < 256) {\n\t\t\tuint32_t r = esp_random();\n\n\t\t\tdelay(10);\n\t\t\thydro_hash_update(&st, (const uint32_t *) &r, sizeof r);\n\t\t\tebits += 32;\n\t\t}\n\n\t\thydro_hash_final(&st, hydro_random_context.state, sizeof hydro_random_context.state);\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#elif defined(PARTICLE) && defined(PLATFORM_ID) && PLATFORM_ID > 2 && !defined(__unix__)\n\n\t// Note: All particle platforms except for the Spark Core have a HW RNG.  Only allow building on\n\t// supported platforms for now. PLATFORM_ID definitions:\n\t// https://github.com/particle-iot/device-os/blob/mesh-develop/hal/shared/platforms.h\n\n\t#include <Particle.h>\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tconst char       ctx[hydro_hash_CONTEXTBYTES] = { 'h', 'y', 'd', 'r', 'o', 'P', 'R', 'G' };\n\t\thydro_hash_state st;\n\t\tuint16_t         ebits = 0;\n\n\t\thydro_hash_init(&st, ctx, NULL);\n\n\t\twhile (ebits < 256) {\n\t\t\tuint32_t r = HAL_RNG_GetRandomNumber();\n\t\t\thydro_hash_update(&st, (const uint32_t *) &r, sizeof r);\n\t\t\tebits += 32;\n\t\t}\n\n\t\thydro_hash_final(&st, hydro_random_context.state, sizeof hydro_random_context.state);\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#elif (defined(NRF52832_XXAA) || defined(NRF52832_XXAB)) && !defined(__unix__)\n\n\t// Important: The SoftDevice *must* be activated to enable reading from the RNG\n\t// http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.nrf52832.ps.v1.1%2Frng.html\n\n\t#include <nrf_soc.h>\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tconst char       ctx[hydro_hash_CONTEXTBYTES] = { 'h', 'y', 'd', 'r', 'o', 'P', 'R', 'G' };\n\t\thydro_hash_state st;\n\t\tconst uint8_t    total_bytes     = 32;\n\t\tuint8_t          remaining_bytes = total_bytes;\n\t\tuint8_t          available_bytes;\n\t\tuint8_t          rand_buffer[32];\n\n\t\thydro_hash_init(&st, ctx, NULL);\n\n\t\tfor (;;) {\n\t\t\tif (sd_rand_application_bytes_available_get(&available_bytes) != NRF_SUCCESS) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (available_bytes > 0) {\n\t\t\t\tif (available_bytes > remaining_bytes) {\n\t\t\t\t\tavailable_bytes = remaining_bytes;\n\t\t\t\t}\n\t\t\t\tif (sd_rand_application_vector_get(rand_buffer, available_bytes) != NRF_SUCCESS) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\thydro_hash_update(&st, rand_buffer, total_bytes);\n\t\t\t\tremaining_bytes -= available_bytes;\n\t\t\t}\n\t\t\tif (remaining_bytes <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\t\thydro_hash_final(&st, hydro_random_context.state, sizeof hydro_random_context.state);\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#elif defined(_WIN32)\n\n\t#define WIN32_LEAN_AND_MEAN\n\t#include <windows.h>\n\t#define RtlGenRandom SystemFunction036\n\t#if defined(__cplusplus)\n\textern \"C\"\n\t#endif\n\t\tBOOLEAN NTAPI\n\t\tRtlGenRandom(PVOID RandomBuffer, ULONG RandomBufferLength);\n\t#pragma comment(lib, \"advapi32.lib\")\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tif (!RtlGenRandom((PVOID) hydro_random_context.state,\n\t\t\t\t\t\t  (ULONG) sizeof hydro_random_context.state)) {\n\t\t\treturn -1;\n\t\t}\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#elif defined(__wasi__)\n\n\t#include <unistd.h>\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tif (getentropy(hydro_random_context.state, sizeof hydro_random_context.state) != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#elif defined(__unix__)\n\n\t#include <errno.h>\n\t#include <fcntl.h>\n\t#ifdef __linux__\n\t#include <poll.h>\n\t#endif\n\t#include <sys/types.h>\n\t#include <unistd.h>\n\n\t#ifdef __linux__\n\tstatic int\n\thydro_random_block_on_dev_random(void)\n\t{\n\t\tstruct pollfd pfd;\n\t\tint           fd;\n\t\tint           pret;\n\n\t\tfd = open(\"/dev/random\", O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\treturn 0;\n\t\t}\n\t\tpfd.fd      = fd;\n\t\tpfd.events  = POLLIN;\n\t\tpfd.revents = 0;\n\t\tdo {\n\t\t\tpret = poll(&pfd, 1, -1);\n\t\t} while (pret < 0 && (errno == EINTR || errno == EAGAIN));\n\t\tif (pret != 1) {\n\t\t\t(void) close(fd);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\t\treturn close(fd);\n\t}\n\t#endif\n\n\tstatic ssize_t\n\thydro_random_safe_read(const int fd, void *const buf_, size_t len)\n\t{\n\t\tunsigned char *buf = (unsigned char *) buf_;\n\t\tssize_t        readnb;\n\n\t\tdo {\n\t\t\twhile ((readnb = read(fd, buf, len)) < (ssize_t) 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t}\n\t\t\tif (readnb < (ssize_t) 0) {\n\t\t\t\treturn readnb;\n\t\t\t}\n\t\t\tif (readnb == (ssize_t) 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= (size_t) readnb;\n\t\t\tbuf += readnb;\n\t\t} while (len > (ssize_t) 0);\n\n\t\treturn (ssize_t)(buf - (unsigned char *) buf_);\n\t}\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tuint8_t tmp[gimli_BLOCKBYTES + 8];\n\t\tint     fd;\n\t\tint     ret = -1;\n\n\t#ifdef __linux__\n\t\tif (hydro_random_block_on_dev_random() != 0) {\n\t\t\treturn -1;\n\t\t}\n\t#endif\n\t\tdo {\n\t\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\t\t\tif (fd == -1 && errno != EINTR) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} while (fd == -1);\n\t\tif (hydro_random_safe_read(fd, tmp, sizeof tmp) == (ssize_t) sizeof tmp) {\n\t\t\tmemcpy(hydro_random_context.state, tmp, gimli_BLOCKBYTES);\n\t\t\tmemcpy(&hydro_random_context.counter, tmp + gimli_BLOCKBYTES, 8);\n\t\t\thydro_memzero(tmp, sizeof tmp);\n\t\t\tret = 0;\n\t\t}\n\t\tret |= close(fd);\n\n\t\treturn ret;\n\t}\n\n#elif defined(TARGET_LIKE_MBED)\n\n\t#include <mbedtls/ctr_drbg.h>\n\t#include <mbedtls/entropy.h>\n\n\t#if defined(MBEDTLS_ENTROPY_C)\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\tmbedtls_entropy_context entropy;\n\t\tuint16_t                pos = 0;\n\n\t\tmbedtls_entropy_init(&entropy);\n\n\t\t// Pull data directly out of the entropy pool for the state, as it's small enough.\n\t\tif (mbedtls_entropy_func(&entropy, (uint8_t *) &hydro_random_context.counter,\n\t\t\t\t\t\t\t\t sizeof hydro_random_context.counter) != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t// mbedtls_entropy_func can't provide more than MBEDTLS_ENTROPY_BLOCK_SIZE in one go.\n\t\t// This constant depends of mbedTLS configuration (whether the PRNG is backed by SHA256/SHA512\n\t\t// at this time) Therefore, if necessary, we get entropy multiple times.\n\n\t\tdo {\n\t\t\tconst uint8_t dataLeftToConsume = gimli_BLOCKBYTES - pos;\n\t\t\tconst uint8_t currentChunkSize  = (dataLeftToConsume > MBEDTLS_ENTROPY_BLOCK_SIZE)\n\t\t\t\t\t\t\t\t\t\t\t\t ? MBEDTLS_ENTROPY_BLOCK_SIZE\n\t\t\t\t\t\t\t\t\t\t\t\t : dataLeftToConsume;\n\n\t\t\t// Forces mbedTLS to fetch fresh entropy, then get some to feed libhydrogen.\n\t\t\tif (mbedtls_entropy_gather(&entropy) != 0 ||\n\t\t\t\tmbedtls_entropy_func(&entropy, &hydro_random_context.state[pos], currentChunkSize) !=\n\t\t\t\t\t0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpos += MBEDTLS_ENTROPY_BLOCK_SIZE;\n\t\t} while (pos < gimli_BLOCKBYTES);\n\n\t\tmbedtls_entropy_free(&entropy);\n\n\t\treturn 0;\n\t}\n\t#else\n\t# error Need an entropy source\n\t#endif\n\n#elif defined(RIOT_VERSION)\n\n\t#include <random.h>\n\n\tstatic int\n\thydro_random_init(void)\n\t{\n\t\trandom_bytes(hydro_random_context.state, sizeof(hydro_random_context.state));\n\t\thydro_random_context.counter = ~LOAD64_LE(hydro_random_context.state);\n\n\t\treturn 0;\n\t}\n\n#else\n\n\t#error Unsupported platform (libhydrogen).\n\n#endif\n\nstatic void\nhydro_random_check_initialized(void)\n{\n\tif (hydro_random_context.initialized == 0) {\n\t\tif (hydro_random_init() != 0) {\n\t\t\tabort();\n\t\t}\n\t\tgimli_core_u8(hydro_random_context.state, 0);\n\t\thydro_random_ratchet();\n\t\thydro_random_context.initialized = 1;\n\t}\n}\n\nvoid\nhydro_random_ratchet(void)\n{\n\tmem_zero(hydro_random_context.state, gimli_RATE);\n\tSTORE64_LE(hydro_random_context.state, hydro_random_context.counter);\n\thydro_random_context.counter++;\n\tgimli_core_u8(hydro_random_context.state, 0);\n\thydro_random_context.available = gimli_RATE;\n}\n\nuint32_t\nhydro_random_u32(void)\n{\n\tuint32_t v;\n\n\thydro_random_check_initialized();\n\tif (hydro_random_context.available < 4) {\n\t\thydro_random_ratchet();\n\t}\n\tmemcpy(&v, &hydro_random_context.state[gimli_RATE - hydro_random_context.available], 4);\n\thydro_random_context.available -= 4;\n\n\treturn v;\n}\n\nuint32_t\nhydro_random_uniform(const uint32_t upper_bound)\n{\n\tuint32_t min;\n\tuint32_t r;\n\n\tif (upper_bound < 2U) {\n\t\treturn 0;\n\t}\n\tmin = (1U + ~upper_bound) % upper_bound; /* = 2**32 mod upper_bound */\n\tdo {\n\t\tr = hydro_random_u32();\n\t} while (r < min);\n\t/* r is now clamped to a set whose size mod upper_bound == 0\n\t * the worst case (2**31+1) requires 2 attempts on average */\n\n\treturn r % upper_bound;\n}\n\nvoid\nhydro_random_buf(void *out, size_t out_len)\n{\n\tuint8_t *p = (uint8_t *) out;\n\tsize_t   i;\n\tsize_t   leftover;\n\n\thydro_random_check_initialized();\n\tfor (i = 0; i < out_len / gimli_RATE; i++) {\n\t\tgimli_core_u8(hydro_random_context.state, 0);\n\t\tmemcpy(p + i * gimli_RATE, hydro_random_context.state, gimli_RATE);\n\t}\n\tleftover = out_len % gimli_RATE;\n\tif (leftover != 0) {\n\t\tgimli_core_u8(hydro_random_context.state, 0);\n\t\tmem_cpy(p + i * gimli_RATE, hydro_random_context.state, leftover);\n\t}\n\thydro_random_ratchet();\n}\n\nvoid\nhydro_random_buf_deterministic(void *out, size_t out_len,\n\t\t\t\t\t\t\t   const uint8_t seed[hydro_random_SEEDBYTES])\n{\n\tstatic const uint8_t             prefix[] = { 7, 'd', 'r', 'b', 'g', '2', '5', '6' };\n\t_hydro_attr_aligned_(16) uint8_t state[gimli_BLOCKBYTES];\n\tuint8_t *                        p = (uint8_t *) out;\n\tsize_t                           i;\n\tsize_t                           leftover;\n\n\tmem_zero(state, gimli_BLOCKBYTES);\n\tCOMPILER_ASSERT(sizeof prefix + 8 <= gimli_RATE);\n\tmemcpy(state, prefix, sizeof prefix);\n\tSTORE64_LE(state + sizeof prefix, (uint64_t) out_len);\n\tgimli_core_u8(state, 1);\n\tCOMPILER_ASSERT(hydro_random_SEEDBYTES == gimli_RATE * 2);\n\tmem_xor(state, seed, gimli_RATE);\n\tgimli_core_u8(state, 2);\n\tmem_xor(state, seed + gimli_RATE, gimli_RATE);\n\tgimli_core_u8(state, 2);\n\tfor (i = 0; i < out_len / gimli_RATE; i++) {\n\t\tgimli_core_u8(state, 0);\n\t\tmemcpy(p + i * gimli_RATE, state, gimli_RATE);\n\t}\n\tleftover = out_len % gimli_RATE;\n\tif (leftover != 0) {\n\t\tgimli_core_u8(state, 0);\n\t\tmem_cpy(p + i * gimli_RATE, state, leftover);\n\t}\n}\n\nvoid\nhydro_random_reseed(void)\n{\n\thydro_random_context.initialized = 0;\n\thydro_random_check_initialized();\n}\n\n\nint\nhydro_hash_update(hydro_hash_state *state, const void *in_, size_t in_len)\n{\n\tconst uint8_t *in  = (const uint8_t *) in_;\n\tuint8_t *      buf = (uint8_t *) (void *) state->state;\n\tsize_t         left;\n\tsize_t         ps;\n\tsize_t         i;\n\n\twhile (in_len > 0) {\n\t\tleft = gimli_RATE - state->buf_off;\n\t\tif ((ps = in_len) > left) {\n\t\t\tps = left;\n\t\t}\n\t\tfor (i = 0; i < ps; i++) {\n\t\t\tbuf[state->buf_off + i] ^= in[i];\n\t\t}\n\t\tin += ps;\n\t\tin_len -= ps;\n\t\tstate->buf_off += (uint8_t) ps;\n\t\tif (state->buf_off == gimli_RATE) {\n\t\t\tgimli_core_u8(buf, 0);\n\t\t\tstate->buf_off = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* pad(str_enc(\"kmac\") || str_enc(context)) || pad(str_enc(k)) ||\n   msg || right_enc(msg_len) || 0x00 */\n\nint\nhydro_hash_init(hydro_hash_state *state, const char ctx[hydro_hash_CONTEXTBYTES],\n\t\t\t\tconst uint8_t key[hydro_hash_KEYBYTES])\n{\n\tuint8_t block[64] = { 4, 'k', 'm', 'a', 'c', 8 };\n\tsize_t  p;\n\n\tCOMPILER_ASSERT(hydro_hash_KEYBYTES <= sizeof block - gimli_RATE - 1);\n\tCOMPILER_ASSERT(hydro_hash_CONTEXTBYTES == 8);\n\tmem_zero(block + 14, sizeof block - 14);\n\tmemcpy(block + 6, ctx, 8);\n\tif (key != NULL) {\n\t\tblock[gimli_RATE] = (uint8_t) hydro_hash_KEYBYTES;\n\t\tmemcpy(block + gimli_RATE + 1, key, hydro_hash_KEYBYTES);\n\t\tp = (gimli_RATE + 1 + hydro_hash_KEYBYTES + (gimli_RATE - 1)) & ~(size_t)(gimli_RATE - 1);\n\t} else {\n\t\tblock[gimli_RATE] = (uint8_t) 0;\n\t\tp                 = (gimli_RATE + 1 + 0 + (gimli_RATE - 1)) & ~(size_t)(gimli_RATE - 1);\n\t}\n\tmem_zero(state, sizeof *state);\n\thydro_hash_update(state, block, p);\n\n\treturn 0;\n}\n\n/* pad(str_enc(\"tmac\") || str_enc(context)) || pad(str_enc(k)) ||\n   pad(right_enc(tweak)) || msg || right_enc(msg_len) || 0x00 */\n\nstatic int\nhydro_hash_init_with_tweak(hydro_hash_state *state, const char ctx[hydro_hash_CONTEXTBYTES],\n\t\t\t\t\t\t   uint64_t tweak, const uint8_t key[hydro_hash_KEYBYTES])\n{\n\tuint8_t block[80] = { 4, 't', 'm', 'a', 'c', 8 };\n\tsize_t  p;\n\n\tCOMPILER_ASSERT(hydro_hash_KEYBYTES <= sizeof block - 2 * gimli_RATE - 1);\n\tCOMPILER_ASSERT(hydro_hash_CONTEXTBYTES == 8);\n\tmem_zero(block + 14, sizeof block - 14);\n\tmemcpy(block + 6, ctx, 8);\n\tif (key != NULL) {\n\t\tblock[gimli_RATE] = (uint8_t) hydro_hash_KEYBYTES;\n\t\tmemcpy(block + gimli_RATE + 1, key, hydro_hash_KEYBYTES);\n\t\tp = (gimli_RATE + 1 + hydro_hash_KEYBYTES + (gimli_RATE - 1)) & ~(size_t)(gimli_RATE - 1);\n\t} else {\n\t\tblock[gimli_RATE] = (uint8_t) 0;\n\t\tp                 = (gimli_RATE + 1 + 0 + (gimli_RATE - 1)) & ~(size_t)(gimli_RATE - 1);\n\t}\n\tblock[p] = (uint8_t) sizeof tweak;\n\tSTORE64_LE(&block[p + 1], tweak);\n\tp += gimli_RATE;\n\tmem_zero(state, sizeof *state);\n\thydro_hash_update(state, block, p);\n\n\treturn 0;\n}\n\nint\nhydro_hash_final(hydro_hash_state *state, uint8_t *out, size_t out_len)\n{\n\tuint8_t  lc[4];\n\tuint8_t *buf = (uint8_t *) (void *) state->state;\n\tsize_t   i;\n\tsize_t   lc_len;\n\tsize_t   leftover;\n\n\tif (out_len < hydro_hash_BYTES_MIN || out_len > hydro_hash_BYTES_MAX) {\n\t\treturn -1;\n\t}\n\tCOMPILER_ASSERT(hydro_hash_BYTES_MAX <= 0xffff);\n\tlc[1]  = (uint8_t) out_len;\n\tlc[2]  = (uint8_t)(out_len >> 8);\n\tlc[3]  = 0;\n\tlc_len = (size_t)(1 + (lc[2] != 0));\n\tlc[0]  = (uint8_t) lc_len;\n\thydro_hash_update(state, lc, 1 + lc_len + 1);\n\tgimli_pad_u8(buf, state->buf_off, gimli_DOMAIN_XOF);\n\tfor (i = 0; i < out_len / gimli_RATE; i++) {\n\t\tgimli_core_u8(buf, 0);\n\t\tmemcpy(out + i * gimli_RATE, buf, gimli_RATE);\n\t}\n\tleftover = out_len % gimli_RATE;\n\tif (leftover != 0) {\n\t\tgimli_core_u8(buf, 0);\n\t\tmem_cpy(out + i * gimli_RATE, buf, leftover);\n\t}\n\tstate->buf_off = gimli_RATE;\n\n\treturn 0;\n}\n\nint\nhydro_hash_hash(uint8_t *out, size_t out_len, const void *in_, size_t in_len,\n\t\t\t\tconst char ctx[hydro_hash_CONTEXTBYTES], const uint8_t key[hydro_hash_KEYBYTES])\n{\n\thydro_hash_state st;\n\tconst uint8_t *  in = (const uint8_t *) in_;\n\n\tif (hydro_hash_init(&st, ctx, key) != 0 || hydro_hash_update(&st, in, in_len) != 0 ||\n\t\thydro_hash_final(&st, out, out_len) != 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid\nhydro_hash_keygen(uint8_t key[hydro_hash_KEYBYTES])\n{\n\thydro_random_buf(key, hydro_hash_KEYBYTES);\n}\n\n\nint\nhydro_kdf_derive_from_key(uint8_t *subkey, size_t subkey_len, uint64_t subkey_id,\n\t\t\t\t\t\t  const char    ctx[hydro_kdf_CONTEXTBYTES],\n\t\t\t\t\t\t  const uint8_t key[hydro_kdf_KEYBYTES])\n{\n\thydro_hash_state st;\n\n\tCOMPILER_ASSERT(hydro_kdf_CONTEXTBYTES >= hydro_hash_CONTEXTBYTES);\n\tCOMPILER_ASSERT(hydro_kdf_KEYBYTES >= hydro_hash_KEYBYTES);\n\tif (hydro_hash_init_with_tweak(&st, ctx, subkey_id, key) != 0) {\n\t\treturn -1;\n\t}\n\treturn hydro_hash_final(&st, subkey, subkey_len);\n}\n\nvoid\nhydro_kdf_keygen(uint8_t key[hydro_kdf_KEYBYTES])\n{\n\thydro_random_buf(key, hydro_kdf_KEYBYTES);\n}\n\n\n#define hydro_secretbox_IVBYTES 20\n#define hydro_secretbox_SIVBYTES 20\n#define hydro_secretbox_MACBYTES 16\n\nvoid\nhydro_secretbox_keygen(uint8_t key[hydro_secretbox_KEYBYTES])\n{\n\thydro_random_buf(key, hydro_secretbox_KEYBYTES);\n}\n\nstatic void\nhydro_secretbox_xor_enc(uint8_t buf[gimli_BLOCKBYTES], uint8_t *out, const uint8_t *in,\n\t\t\t\t\t\tsize_t inlen)\n{\n\tsize_t i;\n\tsize_t leftover;\n\n\tfor (i = 0; i < inlen / gimli_RATE; i++) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], buf, gimli_RATE);\n\t\tmemcpy(buf, &out[i * gimli_RATE], gimli_RATE);\n\t\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n\t}\n\tleftover = inlen % gimli_RATE;\n\tif (leftover != 0) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], buf, leftover);\n\t\tmem_cpy(buf, &out[i * gimli_RATE], leftover);\n\t}\n\tgimli_pad_u8(buf, leftover, gimli_DOMAIN_AEAD);\n\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n}\n\nstatic void\nhydro_secretbox_xor_dec(uint8_t buf[gimli_BLOCKBYTES], uint8_t *out, const uint8_t *in,\n\t\t\t\t\t\tsize_t inlen)\n{\n\tsize_t i;\n\tsize_t leftover;\n\n\tfor (i = 0; i < inlen / gimli_RATE; i++) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], buf, gimli_RATE);\n\t\tmemcpy(buf, &in[i * gimli_RATE], gimli_RATE);\n\t\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n\t}\n\tleftover = inlen % gimli_RATE;\n\tif (leftover != 0) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], buf, leftover);\n\t\tmem_cpy(buf, &in[i * gimli_RATE], leftover);\n\t}\n\tgimli_pad_u8(buf, leftover, gimli_DOMAIN_AEAD);\n\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n}\n\nstatic void\nhydro_secretbox_setup(uint8_t buf[gimli_BLOCKBYTES], uint64_t msg_id,\n\t\t\t\t\t  const char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t  const uint8_t key[hydro_secretbox_KEYBYTES],\n\t\t\t\t\t  const uint8_t iv[hydro_secretbox_IVBYTES], uint8_t key_tag)\n{\n\tstatic const uint8_t prefix[] = { 6, 's', 'b', 'x', '2', '5', '6', 8 };\n\tuint8_t              msg_id_le[8];\n\n\tmem_zero(buf, gimli_BLOCKBYTES);\n\tCOMPILER_ASSERT(hydro_secretbox_CONTEXTBYTES == 8);\n\tCOMPILER_ASSERT(sizeof prefix + hydro_secretbox_CONTEXTBYTES <= gimli_RATE);\n\tmemcpy(buf, prefix, sizeof prefix);\n\tmemcpy(buf + sizeof prefix, ctx, hydro_secretbox_CONTEXTBYTES);\n\tCOMPILER_ASSERT(sizeof prefix + hydro_secretbox_CONTEXTBYTES == gimli_RATE);\n\tgimli_core_u8(buf, gimli_TAG_HEADER);\n\n\tCOMPILER_ASSERT(hydro_secretbox_KEYBYTES == 2 * gimli_RATE);\n\tmem_xor(buf, key, gimli_RATE);\n\tgimli_core_u8(buf, key_tag);\n\tmem_xor(buf, key + gimli_RATE, gimli_RATE);\n\tgimli_core_u8(buf, key_tag);\n\n\tCOMPILER_ASSERT(hydro_secretbox_IVBYTES < gimli_RATE * 2);\n\tbuf[0] ^= hydro_secretbox_IVBYTES;\n\tmem_xor(&buf[1], iv, gimli_RATE - 1);\n\tgimli_core_u8(buf, gimli_TAG_HEADER);\n\tmem_xor(buf, iv + gimli_RATE - 1, hydro_secretbox_IVBYTES - (gimli_RATE - 1));\n\tSTORE64_LE(msg_id_le, msg_id);\n\tCOMPILER_ASSERT(hydro_secretbox_IVBYTES - gimli_RATE + 8 <= gimli_RATE);\n\tmem_xor(buf + hydro_secretbox_IVBYTES - gimli_RATE, msg_id_le, 8);\n\tgimli_core_u8(buf, gimli_TAG_HEADER);\n}\n\nstatic void\nhydro_secretbox_final(uint8_t *buf, const uint8_t key[hydro_secretbox_KEYBYTES], uint8_t tag)\n{\n\tCOMPILER_ASSERT(hydro_secretbox_KEYBYTES == gimli_CAPACITY);\n\tmem_xor(buf + gimli_RATE, key, hydro_secretbox_KEYBYTES);\n\tgimli_core_u8(buf, tag);\n\tmem_xor(buf + gimli_RATE, key, hydro_secretbox_KEYBYTES);\n\tgimli_core_u8(buf, tag);\n}\n\nstatic int\nhydro_secretbox_encrypt_iv(uint8_t *c, const void *m_, size_t mlen, uint64_t msg_id,\n\t\t\t\t\t\t   const char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t   const uint8_t key[hydro_secretbox_KEYBYTES],\n\t\t\t\t\t\t   const uint8_t iv[hydro_secretbox_IVBYTES])\n{\n\t_hydro_attr_aligned_(16) uint32_t state[gimli_BLOCKBYTES / 4];\n\tuint8_t *                         buf = (uint8_t *) (void *) state;\n\tconst uint8_t *                   m   = (const uint8_t *) m_;\n\tuint8_t *                         siv = &c[0];\n\tuint8_t *                         mac = &c[hydro_secretbox_SIVBYTES];\n\tuint8_t *                         ct  = &c[hydro_secretbox_SIVBYTES + hydro_secretbox_MACBYTES];\n\tsize_t                            i;\n\tsize_t                            leftover;\n\n\tif (c == m) {\n\t\tmemmove(c + hydro_secretbox_HEADERBYTES, m, mlen);\n\t\tm = c + hydro_secretbox_HEADERBYTES;\n\t}\n\n\t/* first pass: compute the SIV */\n\n\thydro_secretbox_setup(buf, msg_id, ctx, key, iv, gimli_TAG_KEY0);\n\tfor (i = 0; i < mlen / gimli_RATE; i++) {\n\t\tmem_xor(buf, &m[i * gimli_RATE], gimli_RATE);\n\t\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n\t}\n\tleftover = mlen % gimli_RATE;\n\tif (leftover != 0) {\n\t\tmem_xor(buf, &m[i * gimli_RATE], leftover);\n\t}\n\tgimli_pad_u8(buf, leftover, gimli_DOMAIN_XOF);\n\tgimli_core_u8(buf, gimli_TAG_PAYLOAD);\n\n\thydro_secretbox_final(buf, key, gimli_TAG_FINAL0);\n\tCOMPILER_ASSERT(hydro_secretbox_SIVBYTES <= gimli_CAPACITY);\n\tmemcpy(siv, buf + gimli_RATE, hydro_secretbox_SIVBYTES);\n\n\t/* second pass: encrypt the message, mix the key, squeeze an extra block for\n\t * the MAC */\n\n\tCOMPILER_ASSERT(hydro_secretbox_SIVBYTES == hydro_secretbox_IVBYTES);\n\thydro_secretbox_setup(buf, msg_id, ctx, key, siv, gimli_TAG_KEY);\n\thydro_secretbox_xor_enc(buf, ct, m, mlen);\n\n\thydro_secretbox_final(buf, key, gimli_TAG_FINAL);\n\tCOMPILER_ASSERT(hydro_secretbox_MACBYTES <= gimli_CAPACITY);\n\tmemcpy(mac, buf + gimli_RATE, hydro_secretbox_MACBYTES);\n\n\treturn 0;\n}\n\nvoid\nhydro_secretbox_probe_create(uint8_t probe[hydro_secretbox_PROBEBYTES], const uint8_t *c,\n\t\t\t\t\t\t\t size_t c_len, const char ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\t const uint8_t key[hydro_secretbox_KEYBYTES])\n{\n\tconst uint8_t *mac;\n\n\tif (c_len < hydro_secretbox_HEADERBYTES) {\n\t\tabort();\n\t}\n\tmac = &c[hydro_secretbox_SIVBYTES];\n\tCOMPILER_ASSERT(hydro_secretbox_CONTEXTBYTES >= hydro_hash_CONTEXTBYTES);\n\tCOMPILER_ASSERT(hydro_secretbox_KEYBYTES >= hydro_hash_KEYBYTES);\n\thydro_hash_hash(probe, hydro_secretbox_PROBEBYTES, mac, hydro_secretbox_MACBYTES, ctx, key);\n}\n\nint\nhydro_secretbox_probe_verify(const uint8_t probe[hydro_secretbox_PROBEBYTES], const uint8_t *c,\n\t\t\t\t\t\t\t size_t c_len, const char ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\t\t const uint8_t key[hydro_secretbox_KEYBYTES])\n{\n\tuint8_t        computed_probe[hydro_secretbox_PROBEBYTES];\n\tconst uint8_t *mac;\n\n\tif (c_len < hydro_secretbox_HEADERBYTES) {\n\t\treturn -1;\n\t}\n\tmac = &c[hydro_secretbox_SIVBYTES];\n\thydro_hash_hash(computed_probe, hydro_secretbox_PROBEBYTES, mac, hydro_secretbox_MACBYTES, ctx,\n\t\t\t\t\tkey);\n\tif (hydro_equal(computed_probe, probe, hydro_secretbox_PROBEBYTES) == 1) {\n\t\treturn 0;\n\t}\n\thydro_memzero(computed_probe, hydro_secretbox_PROBEBYTES);\n\treturn -1;\n}\n\nint\nhydro_secretbox_encrypt(uint8_t *c, const void *m_, size_t mlen, uint64_t msg_id,\n\t\t\t\t\t\tconst char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\tconst uint8_t key[hydro_secretbox_KEYBYTES])\n{\n\tuint8_t iv[hydro_secretbox_IVBYTES];\n\n\thydro_random_buf(iv, sizeof iv);\n\n\treturn hydro_secretbox_encrypt_iv(c, m_, mlen, msg_id, ctx, key, iv);\n}\n\nint\nhydro_secretbox_decrypt(void *m_, const uint8_t *c, size_t clen, uint64_t msg_id,\n\t\t\t\t\t\tconst char    ctx[hydro_secretbox_CONTEXTBYTES],\n\t\t\t\t\t\tconst uint8_t key[hydro_secretbox_KEYBYTES])\n{\n\t_hydro_attr_aligned_(16) uint32_t state[gimli_BLOCKBYTES / 4];\n\tuint32_t                          pub_mac[hydro_secretbox_MACBYTES / 4];\n\tuint8_t *                         buf = (uint8_t *) (void *) state;\n\tconst uint8_t *                   siv;\n\tconst uint8_t *                   mac;\n\tconst uint8_t *                   ct;\n\tuint8_t *                         m = (uint8_t *) m_;\n\tsize_t                            mlen;\n\tuint32_t                          cv;\n\n\tif (clen < hydro_secretbox_HEADERBYTES) {\n\t\treturn -1;\n\t}\n\tsiv = &c[0];\n\tmac = &c[hydro_secretbox_SIVBYTES];\n\tct  = &c[hydro_secretbox_SIVBYTES + hydro_secretbox_MACBYTES];\n\n\tmlen = clen - hydro_secretbox_HEADERBYTES;\n\tmemcpy(pub_mac, mac, sizeof pub_mac);\n\tCOMPILER_ASSERT(hydro_secretbox_SIVBYTES == hydro_secretbox_IVBYTES);\n\thydro_secretbox_setup(buf, msg_id, ctx, key, siv, gimli_TAG_KEY);\n\thydro_secretbox_xor_dec(buf, m, ct, mlen);\n\n\thydro_secretbox_final(buf, key, gimli_TAG_FINAL);\n\tCOMPILER_ASSERT(hydro_secretbox_MACBYTES <= gimli_CAPACITY);\n\tCOMPILER_ASSERT(gimli_RATE % 4 == 0);\n\tcv = hydro_mem_ct_cmp_u32(state + gimli_RATE / 4, pub_mac, hydro_secretbox_MACBYTES / 4);\n\thydro_mem_ct_zero_u32(state, gimli_BLOCKBYTES / 4);\n\tif (cv != 0) {\n\t\tmem_zero(m, mlen);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\n/*\n * Based on Michael Hamburg's STROBE reference implementation.\n * Copyright (c) 2015-2016 Cryptography Research, Inc.\n * MIT License (MIT)\n */\n\n#if defined(__GNUC__) && defined(__SIZEOF_INT128__)\n#define hydro_x25519_WBITS 64\n#else\n#define hydro_x25519_WBITS 32\n#endif\n\n#if hydro_x25519_WBITS == 64\ntypedef uint64_t    hydro_x25519_limb_t;\ntypedef __uint128_t hydro_x25519_dlimb_t;\ntypedef __int128_t  hydro_x25519_sdlimb_t;\n#define hydro_x25519_eswap_limb(X) LOAD64_LE((const uint8_t *) &(X))\n#define hydro_x25519_LIMB(x) x##ull\n#elif hydro_x25519_WBITS == 32\ntypedef uint32_t hydro_x25519_limb_t;\ntypedef uint64_t hydro_x25519_dlimb_t;\ntypedef int64_t  hydro_x25519_sdlimb_t;\n#define hydro_x25519_eswap_limb(X) LOAD32_LE((const uint8_t *) &(X))\n#define hydro_x25519_LIMB(x) (uint32_t)(x##ull), (uint32_t)((x##ull) >> 32)\n#else\n#error \"Need to know hydro_x25519_WBITS\"\n#endif\n\n#define hydro_x25519_NLIMBS (256 / hydro_x25519_WBITS)\ntypedef hydro_x25519_limb_t hydro_x25519_fe[hydro_x25519_NLIMBS];\n\ntypedef hydro_x25519_limb_t hydro_x25519_scalar_t[hydro_x25519_NLIMBS];\n\nstatic const hydro_x25519_limb_t hydro_x25519_MONTGOMERY_FACTOR =\n\t(hydro_x25519_limb_t) 0xd2b51da312547e1bull;\n\nstatic const hydro_x25519_scalar_t hydro_x25519_sc_p = { hydro_x25519_LIMB(0x5812631a5cf5d3ed),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t hydro_x25519_LIMB(0x14def9dea2f79cd6),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t hydro_x25519_LIMB(0x0000000000000000),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t hydro_x25519_LIMB(0x1000000000000000) };\n\nstatic const hydro_x25519_scalar_t hydro_x25519_sc_r2 = { hydro_x25519_LIMB(0xa40611e3449c0f01),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  hydro_x25519_LIMB(0xd00e1ba768859347),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  hydro_x25519_LIMB(0xceec73d217f5be65),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  hydro_x25519_LIMB(0x0399411b7c309a3d) };\n\nstatic const uint8_t hydro_x25519_BASE_POINT[hydro_x25519_BYTES] = { 9 };\n\nstatic const hydro_x25519_limb_t hydro_x25519_a24[1] = { 121665 };\n\nstatic inline hydro_x25519_limb_t\nhydro_x25519_umaal(hydro_x25519_limb_t *carry, hydro_x25519_limb_t acc, hydro_x25519_limb_t mand,\n\t\t\t\t   hydro_x25519_limb_t mier)\n{\n\thydro_x25519_dlimb_t tmp = (hydro_x25519_dlimb_t) mand * mier + acc + *carry;\n\n\t*carry = tmp >> hydro_x25519_WBITS;\n\treturn (hydro_x25519_limb_t) tmp;\n}\n\nstatic inline hydro_x25519_limb_t\nhydro_x25519_adc(hydro_x25519_limb_t *carry, hydro_x25519_limb_t acc, hydro_x25519_limb_t mand)\n{\n\thydro_x25519_dlimb_t total = (hydro_x25519_dlimb_t) *carry + acc + mand;\n\n\t*carry = total >> hydro_x25519_WBITS;\n\treturn (hydro_x25519_limb_t) total;\n}\n\nstatic inline hydro_x25519_limb_t\nhydro_x25519_adc0(hydro_x25519_limb_t *carry, hydro_x25519_limb_t acc)\n{\n\thydro_x25519_dlimb_t total = (hydro_x25519_dlimb_t) *carry + acc;\n\n\t*carry = total >> hydro_x25519_WBITS;\n\treturn (hydro_x25519_limb_t) total;\n}\n\nstatic void\nhydro_x25519_propagate(hydro_x25519_fe x, hydro_x25519_limb_t over)\n{\n\thydro_x25519_limb_t carry;\n\tint                 i;\n\n\tover = x[hydro_x25519_NLIMBS - 1] >> (hydro_x25519_WBITS - 1) | over << 1;\n\tx[hydro_x25519_NLIMBS - 1] &= ~((hydro_x25519_limb_t) 1 << (hydro_x25519_WBITS - 1));\n\tcarry = over * 19;\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tx[i] = hydro_x25519_adc0(&carry, x[i]);\n\t}\n}\n\nstatic void\nhydro_x25519_add(hydro_x25519_fe out, const hydro_x25519_fe a, const hydro_x25519_fe b)\n{\n\thydro_x25519_limb_t carry = 0;\n\tint                 i;\n\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tout[i] = hydro_x25519_adc(&carry, a[i], b[i]);\n\t}\n\thydro_x25519_propagate(out, carry);\n}\n\nstatic void\nhydro_x25519_sub(hydro_x25519_fe out, const hydro_x25519_fe a, const hydro_x25519_fe b)\n{\n\thydro_x25519_sdlimb_t carry = -38;\n\tint                   i;\n\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tout[i] = (hydro_x25519_limb_t)(carry = carry + a[i] - b[i]);\n\t\tcarry >>= hydro_x25519_WBITS;\n\t}\n\thydro_x25519_propagate(out, (hydro_x25519_limb_t)(1 + carry));\n}\n\nstatic void\nhydro_x25519_swapin(hydro_x25519_limb_t *x, const uint8_t *in)\n{\n\tint i;\n\n\tmemcpy(x, in, sizeof(hydro_x25519_fe));\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tx[i] = hydro_x25519_eswap_limb(x[i]);\n\t}\n}\n\nstatic void\nhydro_x25519_swapout(uint8_t *out, hydro_x25519_limb_t *x)\n{\n\tint i;\n\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tx[i] = hydro_x25519_eswap_limb(x[i]);\n\t}\n\tmemcpy(out, x, sizeof(hydro_x25519_fe));\n}\n\nstatic void\nhydro_x25519_mul(hydro_x25519_fe out, const hydro_x25519_fe a, const hydro_x25519_fe b, int nb)\n{\n\thydro_x25519_limb_t accum[2 * hydro_x25519_NLIMBS] = { 0 };\n\thydro_x25519_limb_t carry2;\n\tint                 i, j;\n\n\tfor (i = 0; i < nb; i++) {\n\t\tcarry2                   = 0;\n\t\thydro_x25519_limb_t mand = b[i];\n\t\tfor (j = 0; j < hydro_x25519_NLIMBS; j++) {\n\t\t\taccum[i + j] = hydro_x25519_umaal(&carry2, accum[i + j], mand, a[j]);\n\t\t}\n\t\taccum[i + j] = carry2;\n\t}\n\tcarry2 = 0;\n\tfor (j = 0; j < hydro_x25519_NLIMBS; j++) {\n\t\tconst hydro_x25519_limb_t mand = 38;\n\n\t\tout[j] = hydro_x25519_umaal(&carry2, accum[j], mand, accum[j + hydro_x25519_NLIMBS]);\n\t}\n\thydro_x25519_propagate(out, carry2);\n}\n\nstatic void\nhydro_x25519_sqr(hydro_x25519_fe out, const hydro_x25519_fe a)\n{\n\thydro_x25519_mul(out, a, a, hydro_x25519_NLIMBS);\n}\n\nstatic void\nhydro_x25519_mul1(hydro_x25519_fe out, const hydro_x25519_fe a)\n{\n\thydro_x25519_mul(out, a, out, hydro_x25519_NLIMBS);\n}\n\nstatic void\nhydro_x25519_sqr1(hydro_x25519_fe a)\n{\n\thydro_x25519_mul1(a, a);\n}\n\nstatic void\nhydro_x25519_condswap(hydro_x25519_limb_t a[2 * hydro_x25519_NLIMBS],\n\t\t\t\t\t  hydro_x25519_limb_t b[2 * hydro_x25519_NLIMBS], hydro_x25519_limb_t doswap)\n{\n\tint i;\n\n\tfor (i = 0; i < 2 * hydro_x25519_NLIMBS; i++) {\n\t\thydro_x25519_limb_t xorv = (a[i] ^ b[i]) & doswap;\n\t\ta[i] ^= xorv;\n\t\tb[i] ^= xorv;\n\t}\n}\n\nstatic int\nhydro_x25519_canon(hydro_x25519_fe x)\n{\n\thydro_x25519_sdlimb_t carry;\n\thydro_x25519_limb_t   carry0 = 19;\n\thydro_x25519_limb_t   res;\n\tint                   i;\n\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tx[i] = hydro_x25519_adc0(&carry0, x[i]);\n\t}\n\thydro_x25519_propagate(x, carry0);\n\tcarry = -19;\n\tres   = 0;\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tres |= x[i] = (hydro_x25519_limb_t)(carry += x[i]);\n\t\tcarry >>= hydro_x25519_WBITS;\n\t}\n\treturn ((hydro_x25519_dlimb_t) res - 1) >> hydro_x25519_WBITS;\n}\n\nstatic void\nhydro_x25519_ladder_part1(hydro_x25519_fe xs[5])\n{\n\thydro_x25519_limb_t *x2 = xs[0], *z2 = xs[1], *x3 = xs[2], *z3 = xs[3], *t1 = xs[4];\n\n\thydro_x25519_add(t1, x2, z2);              // t1 = A\n\thydro_x25519_sub(z2, x2, z2);              // z2 = B\n\thydro_x25519_add(x2, x3, z3);              // x2 = C\n\thydro_x25519_sub(z3, x3, z3);              // z3 = D\n\thydro_x25519_mul1(z3, t1);                 // z3 = DA\n\thydro_x25519_mul1(x2, z2);                 // x3 = BC\n\thydro_x25519_add(x3, z3, x2);              // x3 = DA+CB\n\thydro_x25519_sub(z3, z3, x2);              // z3 = DA-CB\n\thydro_x25519_sqr1(t1);                     // t1 = AA\n\thydro_x25519_sqr1(z2);                     // z2 = BB\n\thydro_x25519_sub(x2, t1, z2);              // x2 = E = AA-BB\n\thydro_x25519_mul(z2, x2, hydro_x25519_a24, // z2 = E*a24\n\t\t\t\t\t sizeof(hydro_x25519_a24) / sizeof(hydro_x25519_a24[0]));\n\thydro_x25519_add(z2, z2, t1); // z2 = E*a24 + AA\n}\n\nstatic void\nhydro_x25519_ladder_part2(hydro_x25519_fe xs[5], const hydro_x25519_fe x1)\n{\n\thydro_x25519_limb_t *x2 = xs[0], *z2 = xs[1], *x3 = xs[2], *z3 = xs[3], *t1 = xs[4];\n\n\thydro_x25519_sqr1(z3);        // z3 = (DA-CB)^2\n\thydro_x25519_mul1(z3, x1);    // z3 = x1 * (DA-CB)^2\n\thydro_x25519_sqr1(x3);        // x3 = (DA+CB)^2\n\thydro_x25519_mul1(z2, x2);    // z2 = AA*(E*a24+AA)\n\thydro_x25519_sub(x2, t1, x2); // x2 = BB again\n\thydro_x25519_mul1(x2, t1);    // x2 = AA*BB\n}\n\nstatic void\nhydro_x25519_core(hydro_x25519_fe xs[5], const uint8_t scalar[hydro_x25519_BYTES],\n\t\t\t\t  const uint8_t *x1, bool clamp)\n{\n\thydro_x25519_limb_t  swap;\n\thydro_x25519_limb_t *x2 = xs[0], *x3 = xs[2], *z3 = xs[3];\n\thydro_x25519_fe      x1i;\n\tint                  i;\n\n\thydro_x25519_swapin(x1i, x1);\n\tx1   = (const uint8_t *) x1i;\n\tswap = 0;\n\tmem_zero(xs, 4 * sizeof(hydro_x25519_fe));\n\tx2[0] = z3[0] = 1;\n\tmemcpy(x3, x1, sizeof(hydro_x25519_fe));\n\tfor (i = 255; i >= 0; i--) {\n\t\tuint8_t             bytei = scalar[i / 8];\n\t\thydro_x25519_limb_t doswap;\n\t\thydro_x25519_fe     x1_dup;\n\n\t\tif (clamp) {\n\t\t\tif (i / 8 == 0) {\n\t\t\t\tbytei &= ~7;\n\t\t\t} else if (i / 8 == hydro_x25519_BYTES - 1) {\n\t\t\t\tbytei &= 0x7F;\n\t\t\t\tbytei |= 0x40;\n\t\t\t}\n\t\t}\n\t\tdoswap = 1U + ~(hydro_x25519_limb_t)((bytei >> (i % 8)) & 1);\n\t\thydro_x25519_condswap(x2, x3, swap ^ doswap);\n\t\tswap = doswap;\n\t\thydro_x25519_ladder_part1(xs);\n\t\tmemcpy(x1_dup, x1, sizeof x1_dup);\n\t\thydro_x25519_ladder_part2(xs, x1_dup);\n\t}\n\thydro_x25519_condswap(x2, x3, swap);\n}\n\nstatic int\nhydro_x25519_scalarmult(uint8_t       out[hydro_x25519_BYTES],\n\t\t\t\t\t\tconst uint8_t scalar[hydro_x25519_SECRETKEYBYTES],\n\t\t\t\t\t\tconst uint8_t x1[hydro_x25519_PUBLICKEYBYTES], bool clamp)\n{\n\thydro_x25519_fe      xs[5];\n\thydro_x25519_limb_t *x2, *z2, *z3;\n\thydro_x25519_limb_t *prev;\n\tint                  i;\n\tint                  ret;\n\n\thydro_x25519_core(xs, scalar, x1, clamp);\n\n\t/* Precomputed inversion chain */\n\tx2   = xs[0];\n\tz2   = xs[1];\n\tz3   = xs[3];\n\tprev = z2;\n\n\t/* Raise to the p-2 = 0x7f..ffeb */\n\tfor (i = 253; i >= 0; i--) {\n\t\thydro_x25519_sqr(z3, prev);\n\t\tprev = z3;\n\t\tif (i >= 8 || (0xeb >> i & 1)) {\n\t\t\thydro_x25519_mul1(z3, z2);\n\t\t}\n\t}\n\n\t/* Here prev = z3 */\n\t/* x2 /= z2 */\n\thydro_x25519_mul1(x2, z3);\n\tret = hydro_x25519_canon(x2);\n\thydro_x25519_swapout(out, x2);\n\n\tif (clamp == 0) {\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\nstatic inline int\nhydro_x25519_scalarmult_base(uint8_t       pk[hydro_x25519_PUBLICKEYBYTES],\n\t\t\t\t\t\t\t const uint8_t sk[hydro_x25519_SECRETKEYBYTES])\n{\n\treturn hydro_x25519_scalarmult(pk, sk, hydro_x25519_BASE_POINT, 1);\n}\n\nstatic inline void\nhydro_x25519_scalarmult_base_uniform(uint8_t       pk[hydro_x25519_PUBLICKEYBYTES],\n\t\t\t\t\t\t\t\t\t const uint8_t sk[hydro_x25519_SECRETKEYBYTES])\n{\n\tif (hydro_x25519_scalarmult(pk, sk, hydro_x25519_BASE_POINT, 0) != 0) {\n\t\tabort();\n\t}\n}\n\nstatic void\nhydro_x25519_sc_montmul(hydro_x25519_scalar_t out, const hydro_x25519_scalar_t a,\n\t\t\t\t\t\tconst hydro_x25519_scalar_t b)\n{\n\thydro_x25519_limb_t hic = 0;\n\tint                 i, j;\n\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\thydro_x25519_limb_t carry = 0, carry2 = 0, mand = a[i],\n\t\t\t\t\t\t\tmand2 = hydro_x25519_MONTGOMERY_FACTOR;\n\n\t\tfor (j = 0; j < hydro_x25519_NLIMBS; j++) {\n\t\t\thydro_x25519_limb_t acc = out[j];\n\n\t\t\tacc = hydro_x25519_umaal(&carry, acc, mand, b[j]);\n\t\t\tif (j == 0) {\n\t\t\t\tmand2 *= acc;\n\t\t\t}\n\t\t\tacc = hydro_x25519_umaal(&carry2, acc, mand2, hydro_x25519_sc_p[j]);\n\t\t\tif (j > 0) {\n\t\t\t\tout[j - 1] = acc;\n\t\t\t}\n\t\t}\n\n\t\t/* Add two carry registers and high carry */\n\t\tout[hydro_x25519_NLIMBS - 1] = hydro_x25519_adc(&hic, carry, carry2);\n\t}\n\n\t/* Reduce */\n\thydro_x25519_sdlimb_t scarry = 0;\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tout[i] = (hydro_x25519_limb_t)(scarry = scarry + out[i] - hydro_x25519_sc_p[i]);\n\t\tscarry >>= hydro_x25519_WBITS;\n\t}\n\thydro_x25519_limb_t need_add = (hydro_x25519_limb_t) - (scarry + hic);\n\n\thydro_x25519_limb_t carry = 0;\n\tfor (i = 0; i < hydro_x25519_NLIMBS; i++) {\n\t\tout[i] = hydro_x25519_umaal(&carry, out[i], need_add, hydro_x25519_sc_p[i]);\n\t}\n}\n\n\n#define hydro_kx_AEAD_KEYBYTES hydro_hash_KEYBYTES\n#define hydro_kx_AEAD_MACBYTES 16\n\n#define hydro_kx_CONTEXT \"hydro_kx\"\n\nstatic void\nhydro_kx_aead_init(uint8_t aead_state[gimli_BLOCKBYTES], uint8_t k[hydro_kx_AEAD_KEYBYTES],\n\t\t\t\t   hydro_kx_state *state)\n{\n\tstatic const uint8_t prefix[] = { 6, 'k', 'x', 'x', '2', '5', '6', 0 };\n\n\thydro_hash_final(&state->h_st, k, hydro_kx_AEAD_KEYBYTES);\n\n\tmem_zero(aead_state + sizeof prefix, gimli_BLOCKBYTES - sizeof prefix);\n\tmemcpy(aead_state, prefix, sizeof prefix);\n\tgimli_core_u8(aead_state, gimli_TAG_HEADER);\n\n\tCOMPILER_ASSERT(hydro_kx_AEAD_KEYBYTES == 2 * gimli_RATE);\n\tmem_xor(aead_state, k, gimli_RATE);\n\tgimli_core_u8(aead_state, gimli_TAG_KEY);\n\tmem_xor(aead_state, k + gimli_RATE, gimli_RATE);\n\tgimli_core_u8(aead_state, gimli_TAG_KEY);\n}\n\nstatic void\nhydro_kx_aead_final(uint8_t *aead_state, const uint8_t key[hydro_kx_AEAD_KEYBYTES])\n{\n\tCOMPILER_ASSERT(hydro_kx_AEAD_KEYBYTES == gimli_CAPACITY);\n\tmem_xor(aead_state + gimli_RATE, key, hydro_kx_AEAD_KEYBYTES);\n\tgimli_core_u8(aead_state, gimli_TAG_FINAL);\n\tmem_xor(aead_state + gimli_RATE, key, hydro_kx_AEAD_KEYBYTES);\n\tgimli_core_u8(aead_state, gimli_TAG_FINAL);\n}\n\nstatic void\nhydro_kx_aead_xor_enc(uint8_t aead_state[gimli_BLOCKBYTES], uint8_t *out, const uint8_t *in,\n\t\t\t\t\t  size_t inlen)\n{\n\tsize_t i;\n\tsize_t leftover;\n\n\tfor (i = 0; i < inlen / gimli_RATE; i++) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], aead_state, gimli_RATE);\n\t\tmemcpy(aead_state, &out[i * gimli_RATE], gimli_RATE);\n\t\tgimli_core_u8(aead_state, gimli_TAG_PAYLOAD);\n\t}\n\tleftover = inlen % gimli_RATE;\n\tif (leftover != 0) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], aead_state, leftover);\n\t\tmem_cpy(aead_state, &out[i * gimli_RATE], leftover);\n\t}\n\tgimli_pad_u8(aead_state, leftover, gimli_DOMAIN_AEAD);\n\tgimli_core_u8(aead_state, gimli_TAG_PAYLOAD);\n}\n\nstatic void\nhydro_kx_aead_xor_dec(uint8_t aead_state[gimli_BLOCKBYTES], uint8_t *out, const uint8_t *in,\n\t\t\t\t\t  size_t inlen)\n{\n\tsize_t i;\n\tsize_t leftover;\n\n\tfor (i = 0; i < inlen / gimli_RATE; i++) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], aead_state, gimli_RATE);\n\t\tmemcpy(aead_state, &in[i * gimli_RATE], gimli_RATE);\n\t\tgimli_core_u8(aead_state, gimli_TAG_PAYLOAD);\n\t}\n\tleftover = inlen % gimli_RATE;\n\tif (leftover != 0) {\n\t\tmem_xor2(&out[i * gimli_RATE], &in[i * gimli_RATE], aead_state, leftover);\n\t\tmem_cpy(aead_state, &in[i * gimli_RATE], leftover);\n\t}\n\tgimli_pad_u8(aead_state, leftover, gimli_DOMAIN_AEAD);\n\tgimli_core_u8(aead_state, gimli_TAG_PAYLOAD);\n}\n\nstatic void\nhydro_kx_aead_encrypt(hydro_kx_state *state, uint8_t *c, const uint8_t *m, size_t mlen)\n{\n\t_hydro_attr_aligned_(16) uint8_t aead_state[gimli_BLOCKBYTES];\n\tuint8_t                          k[hydro_kx_AEAD_KEYBYTES];\n\tuint8_t *                        mac = &c[0];\n\tuint8_t *                        ct  = &c[hydro_kx_AEAD_MACBYTES];\n\n\thydro_kx_aead_init(aead_state, k, state);\n\thydro_kx_aead_xor_enc(aead_state, ct, m, mlen);\n\thydro_kx_aead_final(aead_state, k);\n\tCOMPILER_ASSERT(hydro_kx_AEAD_MACBYTES <= gimli_CAPACITY);\n\tmemcpy(mac, aead_state + gimli_RATE, hydro_kx_AEAD_MACBYTES);\n\thydro_hash_update(&state->h_st, c, mlen + hydro_kx_AEAD_MACBYTES);\n}\n\nstatic int hydro_kx_aead_decrypt(hydro_kx_state *state, uint8_t *m, const uint8_t *c,\n\t\t\t\t\t\t\t\t size_t clen) _hydro_attr_warn_unused_result_;\n\nstatic int\nhydro_kx_aead_decrypt(hydro_kx_state *state, uint8_t *m, const uint8_t *c, size_t clen)\n{\n\t_hydro_attr_aligned_(16) uint32_t int_state[gimli_BLOCKBYTES / 4];\n\tuint32_t                          pub_mac[hydro_kx_AEAD_MACBYTES / 4];\n\tuint8_t                           k[hydro_kx_AEAD_KEYBYTES];\n\tuint8_t *                         aead_state = (uint8_t *) (void *) int_state;\n\tconst uint8_t *                   mac;\n\tconst uint8_t *                   ct;\n\tsize_t                            mlen;\n\tuint32_t                          cv;\n\n\tif (clen < hydro_kx_AEAD_MACBYTES) {\n\t\treturn -1;\n\t}\n\tmac  = &c[0];\n\tct   = &c[hydro_kx_AEAD_MACBYTES];\n\tmlen = clen - hydro_kx_AEAD_MACBYTES;\n\tmemcpy(pub_mac, mac, sizeof pub_mac);\n\thydro_kx_aead_init(aead_state, k, state);\n\thydro_hash_update(&state->h_st, c, clen);\n\thydro_kx_aead_xor_dec(aead_state, m, ct, mlen);\n\thydro_kx_aead_final(aead_state, k);\n\tCOMPILER_ASSERT(hydro_kx_AEAD_MACBYTES <= gimli_CAPACITY);\n\tCOMPILER_ASSERT(gimli_RATE % 4 == 0);\n\tcv = hydro_mem_ct_cmp_u32(int_state + gimli_RATE / 4, pub_mac, hydro_kx_AEAD_MACBYTES / 4);\n\thydro_mem_ct_zero_u32(int_state, gimli_BLOCKBYTES / 4);\n\tif (cv != 0) {\n\t\tmem_zero(m, mlen);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* -- */\n\nvoid\nhydro_kx_keygen(hydro_kx_keypair *static_kp)\n{\n\thydro_random_buf(static_kp->sk, hydro_kx_SECRETKEYBYTES);\n\tif (hydro_x25519_scalarmult_base(static_kp->pk, static_kp->sk) != 0) {\n\t\tabort();\n\t}\n}\n\nvoid\nhydro_kx_keygen_deterministic(hydro_kx_keypair *static_kp, const uint8_t seed[hydro_kx_SEEDBYTES])\n{\n\tCOMPILER_ASSERT(hydro_kx_SEEDBYTES >= hydro_random_SEEDBYTES);\n\thydro_random_buf_deterministic(static_kp->sk, hydro_kx_SECRETKEYBYTES, seed);\n\tif (hydro_x25519_scalarmult_base(static_kp->pk, static_kp->sk) != 0) {\n\t\tabort();\n\t}\n}\n\nstatic void\nhydro_kx_init_state(hydro_kx_state *state, const char *name)\n{\n\tmem_zero(state, sizeof *state);\n\thydro_hash_init(&state->h_st, hydro_kx_CONTEXT, NULL);\n\thydro_hash_update(&state->h_st, name, strlen(name));\n\thydro_hash_final(&state->h_st, NULL, 0);\n}\n\nstatic void\nhydro_kx_final(hydro_kx_state *state, uint8_t session_k1[hydro_kx_SESSIONKEYBYTES],\n\t\t\t   uint8_t session_k2[hydro_kx_SESSIONKEYBYTES])\n{\n\tuint8_t kdf_key[hydro_kdf_KEYBYTES];\n\n\thydro_hash_final(&state->h_st, kdf_key, sizeof kdf_key);\n\thydro_kdf_derive_from_key(session_k1, hydro_kx_SESSIONKEYBYTES, 0, hydro_kx_CONTEXT, kdf_key);\n\thydro_kdf_derive_from_key(session_k2, hydro_kx_SESSIONKEYBYTES, 1, hydro_kx_CONTEXT, kdf_key);\n}\n\nstatic int\nhydro_kx_dh(hydro_kx_state *state, const uint8_t sk[hydro_x25519_SECRETKEYBYTES],\n\t\t\tconst uint8_t pk[hydro_x25519_PUBLICKEYBYTES])\n{\n\tuint8_t dh_result[hydro_x25519_BYTES];\n\n\tif (hydro_x25519_scalarmult(dh_result, sk, pk, 1) != 0) {\n\t\treturn -1;\n\t}\n\thydro_hash_update(&state->h_st, dh_result, hydro_x25519_BYTES);\n\n\treturn 0;\n}\n\nstatic void\nhydro_kx_eph_keygen(hydro_kx_state *state, hydro_kx_keypair *kp)\n{\n\thydro_kx_keygen(kp);\n\thydro_hash_update(&state->h_st, kp->pk, sizeof kp->pk);\n}\n\n/* NOISE_N */\n\nint\nhydro_kx_n_1(hydro_kx_session_keypair *kp, uint8_t packet1[hydro_kx_N_PACKET1BYTES],\n\t\t\t const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t const uint8_t peer_static_pk[hydro_kx_PUBLICKEYBYTES])\n{\n\thydro_kx_state state;\n\tuint8_t *      packet1_eph_pk = &packet1[0];\n\tuint8_t *      packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(&state, \"Noise_Npsk0_hydro1\");\n\thydro_hash_update(&state.h_st, peer_static_pk, hydro_x25519_PUBLICKEYBYTES);\n\n\thydro_hash_update(&state.h_st, psk, hydro_kx_PSKBYTES);\n\thydro_kx_eph_keygen(&state, &state.eph_kp);\n\tif (hydro_kx_dh(&state, state.eph_kp.sk, peer_static_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(&state, packet1_mac, NULL, 0);\n\tmemcpy(packet1_eph_pk, state.eph_kp.pk, sizeof state.eph_kp.pk);\n\n\thydro_kx_final(&state, kp->rx, kp->tx);\n\n\treturn 0;\n}\n\nint\nhydro_kx_n_2(hydro_kx_session_keypair *kp, const uint8_t packet1[hydro_kx_N_PACKET1BYTES],\n\t\t\t const uint8_t psk[hydro_kx_PSKBYTES], const hydro_kx_keypair *static_kp)\n{\n\thydro_kx_state state;\n\tconst uint8_t *peer_eph_pk = &packet1[0];\n\tconst uint8_t *packet1_mac = &packet1[hydro_kx_PUBLICKEYBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(&state, \"Noise_Npsk0_hydro1\");\n\thydro_hash_update(&state.h_st, static_kp->pk, hydro_kx_PUBLICKEYBYTES);\n\n\thydro_hash_update(&state.h_st, psk, hydro_kx_PSKBYTES);\n\thydro_hash_update(&state.h_st, peer_eph_pk, hydro_x25519_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(&state, static_kp->sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(&state, NULL, packet1_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_final(&state, kp->tx, kp->rx);\n\n\treturn 0;\n}\n\n/* NOISE_KK */\n\nint\nhydro_kx_kk_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_KK_PACKET1BYTES],\n\t\t\t  const uint8_t           peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t  const hydro_kx_keypair *static_kp)\n{\n\tuint8_t *packet1_eph_pk = &packet1[0];\n\tuint8_t *packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\n\thydro_kx_init_state(state, \"Noise_KK_hydro1\");\n\thydro_hash_update(&state->h_st, static_kp->pk, hydro_kx_PUBLICKEYBYTES);\n\thydro_hash_update(&state->h_st, peer_static_pk, hydro_kx_PUBLICKEYBYTES);\n\n\thydro_kx_eph_keygen(state, &state->eph_kp);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_static_pk) != 0 ||\n\t\thydro_kx_dh(state, static_kp->sk, peer_static_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(state, packet1_mac, NULL, 0);\n\tmemcpy(packet1_eph_pk, state->eph_kp.pk, sizeof state->eph_kp.pk);\n\n\treturn 0;\n}\n\nint\nhydro_kx_kk_2(hydro_kx_session_keypair *kp, uint8_t packet2[hydro_kx_KK_PACKET2BYTES],\n\t\t\t  const uint8_t           packet1[hydro_kx_KK_PACKET1BYTES],\n\t\t\t  const uint8_t           peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t  const hydro_kx_keypair *static_kp)\n{\n\thydro_kx_state state;\n\tconst uint8_t *peer_eph_pk    = &packet1[0];\n\tconst uint8_t *packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\tuint8_t *      packet2_eph_pk = &packet2[0];\n\tuint8_t *      packet2_mac    = &packet2[hydro_kx_PUBLICKEYBYTES];\n\n\thydro_kx_init_state(&state, \"Noise_KK_hydro1\");\n\thydro_hash_update(&state.h_st, peer_static_pk, hydro_kx_PUBLICKEYBYTES);\n\thydro_hash_update(&state.h_st, static_kp->pk, hydro_kx_PUBLICKEYBYTES);\n\n\thydro_hash_update(&state.h_st, peer_eph_pk, hydro_kx_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(&state, static_kp->sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_dh(&state, static_kp->sk, peer_static_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(&state, NULL, packet1_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\n\thydro_kx_eph_keygen(&state, &state.eph_kp);\n\tif (hydro_kx_dh(&state, state.eph_kp.sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_dh(&state, state.eph_kp.sk, peer_static_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(&state, packet2_mac, NULL, 0);\n\thydro_kx_final(&state, kp->tx, kp->rx);\n\tmemcpy(packet2_eph_pk, state.eph_kp.pk, sizeof state.eph_kp.pk);\n\n\treturn 0;\n}\n\nint\nhydro_kx_kk_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t  const uint8_t packet2[hydro_kx_KK_PACKET2BYTES], const hydro_kx_keypair *static_kp)\n{\n\tconst uint8_t *peer_eph_pk = packet2;\n\tconst uint8_t *packet2_mac = &packet2[hydro_kx_PUBLICKEYBYTES];\n\n\thydro_hash_update(&state->h_st, peer_eph_pk, hydro_kx_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_dh(state, static_kp->sk, peer_eph_pk) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (hydro_kx_aead_decrypt(state, NULL, packet2_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_final(state, kp->rx, kp->tx);\n\n\treturn 0;\n}\n\n/* NOISE_XX */\n\nint\nhydro_kx_xx_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_XX_PACKET1BYTES],\n\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES])\n{\n\tuint8_t *packet1_eph_pk = &packet1[0];\n\tuint8_t *packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(state, \"Noise_XXpsk0+psk3_hydro1\");\n\n\thydro_kx_eph_keygen(state, &state->eph_kp);\n\thydro_hash_update(&state->h_st, psk, hydro_kx_PSKBYTES);\n\tmemcpy(packet1_eph_pk, state->eph_kp.pk, sizeof state->eph_kp.pk);\n\thydro_kx_aead_encrypt(state, packet1_mac, NULL, 0);\n\n\treturn 0;\n}\n\nint\nhydro_kx_xx_2(hydro_kx_state *state, uint8_t packet2[hydro_kx_XX_PACKET2BYTES],\n\t\t\t  const uint8_t packet1[hydro_kx_XX_PACKET1BYTES], const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t  const hydro_kx_keypair *static_kp)\n{\n\tconst uint8_t *peer_eph_pk           = &packet1[0];\n\tconst uint8_t *packet1_mac           = &packet1[hydro_kx_PUBLICKEYBYTES];\n\tuint8_t *      packet2_eph_pk        = &packet2[0];\n\tuint8_t *      packet2_enc_static_pk = &packet2[hydro_kx_PUBLICKEYBYTES];\n\tuint8_t *      packet2_mac =\n\t\t&packet2[hydro_kx_PUBLICKEYBYTES + hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(state, \"Noise_XXpsk0+psk3_hydro1\");\n\n\thydro_hash_update(&state->h_st, peer_eph_pk, hydro_kx_PUBLICKEYBYTES);\n\thydro_hash_update(&state->h_st, psk, hydro_kx_PSKBYTES);\n\tif (hydro_kx_aead_decrypt(state, NULL, packet1_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\n\thydro_kx_eph_keygen(state, &state->eph_kp);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_eph_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(state, packet2_enc_static_pk, static_kp->pk, sizeof static_kp->pk);\n\tif (hydro_kx_dh(state, static_kp->sk, peer_eph_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(state, packet2_mac, NULL, 0);\n\n\tmemcpy(packet2_eph_pk, state->eph_kp.pk, sizeof state->eph_kp.pk);\n\n\treturn 0;\n}\n\nint\nhydro_kx_xx_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t  uint8_t       packet3[hydro_kx_XX_PACKET3BYTES],\n\t\t\t  uint8_t       peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t  const uint8_t packet2[hydro_kx_XX_PACKET2BYTES], const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t  const hydro_kx_keypair *static_kp)\n{\n\tuint8_t        peer_static_pk_[hydro_kx_PUBLICKEYBYTES];\n\tconst uint8_t *peer_eph_pk        = &packet2[0];\n\tconst uint8_t *peer_enc_static_pk = &packet2[hydro_kx_PUBLICKEYBYTES];\n\tconst uint8_t *packet2_mac =\n\t\t&packet2[hydro_kx_PUBLICKEYBYTES + hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES];\n\tuint8_t *packet3_enc_static_pk = &packet3[0];\n\tuint8_t *packet3_mac           = &packet3[hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\tif (peer_static_pk == NULL) {\n\t\tpeer_static_pk = peer_static_pk_;\n\t}\n\thydro_hash_update(&state->h_st, peer_eph_pk, hydro_kx_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(state, peer_static_pk, peer_enc_static_pk,\n\t\t\t\t\t\t\t  hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES) != 0 ||\n\t\thydro_kx_dh(state, state->eph_kp.sk, peer_static_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(state, NULL, packet2_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\n\thydro_kx_aead_encrypt(state, packet3_enc_static_pk, static_kp->pk, sizeof static_kp->pk);\n\tif (hydro_kx_dh(state, static_kp->sk, peer_eph_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_hash_update(&state->h_st, psk, hydro_kx_PSKBYTES);\n\thydro_kx_aead_encrypt(state, packet3_mac, NULL, 0);\n\thydro_kx_final(state, kp->rx, kp->tx);\n\n\treturn 0;\n}\n\nint\nhydro_kx_xx_4(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t  uint8_t       peer_static_pk[hydro_kx_PUBLICKEYBYTES],\n\t\t\t  const uint8_t packet3[hydro_kx_XX_PACKET3BYTES], const uint8_t psk[hydro_kx_PSKBYTES])\n{\n\tuint8_t        peer_static_pk_[hydro_kx_PUBLICKEYBYTES];\n\tconst uint8_t *peer_enc_static_pk = &packet3[0];\n\tconst uint8_t *packet3_mac        = &packet3[hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\tif (peer_static_pk == NULL) {\n\t\tpeer_static_pk = peer_static_pk_;\n\t}\n\tif (hydro_kx_aead_decrypt(state, peer_static_pk, peer_enc_static_pk,\n\t\t\t\t\t\t\t  hydro_kx_PUBLICKEYBYTES + hydro_kx_AEAD_MACBYTES) != 0 ||\n\t\thydro_kx_dh(state, state->eph_kp.sk, peer_static_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_hash_update(&state->h_st, psk, hydro_kx_PSKBYTES);\n\tif (hydro_kx_aead_decrypt(state, NULL, packet3_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_final(state, kp->tx, kp->rx);\n\n\treturn 0;\n}\n\n/* NOISE_NK */\n\nint\nhydro_kx_nk_1(hydro_kx_state *state, uint8_t packet1[hydro_kx_NK_PACKET1BYTES],\n\t\t\t  const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t  const uint8_t peer_static_pk[hydro_kx_PUBLICKEYBYTES])\n{\n\tuint8_t *packet1_eph_pk = &packet1[0];\n\tuint8_t *packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(state, \"Noise_NKpsk0_hydro1\");\n\thydro_hash_update(&state->h_st, peer_static_pk, hydro_x25519_PUBLICKEYBYTES);\n\n\thydro_hash_update(&state->h_st, psk, hydro_kx_PSKBYTES);\n\thydro_kx_eph_keygen(state, &state->eph_kp);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_static_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(state, packet1_mac, NULL, 0);\n\tmemcpy(packet1_eph_pk, state->eph_kp.pk, sizeof state->eph_kp.pk);\n\n\treturn 0;\n}\n\nint\nhydro_kx_nk_2(hydro_kx_session_keypair *kp, uint8_t packet2[hydro_kx_NK_PACKET2BYTES],\n\t\t\t  const uint8_t packet1[hydro_kx_NK_PACKET1BYTES], const uint8_t psk[hydro_kx_PSKBYTES],\n\t\t\t  const hydro_kx_keypair *static_kp)\n{\n\thydro_kx_state state;\n\tconst uint8_t *peer_eph_pk    = &packet1[0];\n\tconst uint8_t *packet1_mac    = &packet1[hydro_kx_PUBLICKEYBYTES];\n\tuint8_t *      packet2_eph_pk = &packet2[0];\n\tuint8_t *      packet2_mac    = &packet2[hydro_kx_PUBLICKEYBYTES];\n\n\tif (psk == NULL) {\n\t\tpsk = zero;\n\t}\n\thydro_kx_init_state(&state, \"Noise_NKpsk0_hydro1\");\n\thydro_hash_update(&state.h_st, static_kp->pk, hydro_kx_PUBLICKEYBYTES);\n\n\thydro_hash_update(&state.h_st, psk, hydro_kx_PSKBYTES);\n\thydro_hash_update(&state.h_st, peer_eph_pk, hydro_x25519_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(&state, static_kp->sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(&state, NULL, packet1_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\n\thydro_kx_eph_keygen(&state, &state.eph_kp);\n\tif (hydro_kx_dh(&state, state.eph_kp.sk, peer_eph_pk) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_aead_encrypt(&state, packet2_mac, NULL, 0);\n\thydro_kx_final(&state, kp->tx, kp->rx);\n\tmemcpy(packet2_eph_pk, state.eph_kp.pk, sizeof state.eph_kp.pk);\n\n\treturn 0;\n}\n\nint\nhydro_kx_nk_3(hydro_kx_state *state, hydro_kx_session_keypair *kp,\n\t\t\t  const uint8_t packet2[hydro_kx_NK_PACKET2BYTES])\n{\n\tconst uint8_t *peer_eph_pk = &packet2[0];\n\tconst uint8_t *packet2_mac = &packet2[hydro_kx_PUBLICKEYBYTES];\n\n\thydro_hash_update(&state->h_st, peer_eph_pk, hydro_x25519_PUBLICKEYBYTES);\n\tif (hydro_kx_dh(state, state->eph_kp.sk, peer_eph_pk) != 0 ||\n\t\thydro_kx_aead_decrypt(state, NULL, packet2_mac, hydro_kx_AEAD_MACBYTES) != 0) {\n\t\treturn -1;\n\t}\n\thydro_kx_final(state, kp->rx, kp->tx);\n\n\treturn 0;\n}\n\n\n#define hydro_pwhash_ENC_ALGBYTES 1\n#define hydro_pwhash_HASH_ALGBYTES 1\n#define hydro_pwhash_THREADSBYTES 1\n#define hydro_pwhash_OPSLIMITBYTES 8\n#define hydro_pwhash_MEMLIMITBYTES 8\n#define hydro_pwhash_HASHBYTES 32\n#define hydro_pwhash_SALTBYTES 16\n#define hydro_pwhash_PARAMSBYTES                                                           \\\n\t(hydro_pwhash_HASH_ALGBYTES + hydro_pwhash_THREADSBYTES + hydro_pwhash_OPSLIMITBYTES + \\\n\t hydro_pwhash_MEMLIMITBYTES + hydro_pwhash_SALTBYTES + hydro_pwhash_HASHBYTES)\n#define hydro_pwhash_ENC_ALG 0x01\n#define hydro_pwhash_HASH_ALG 0x01\n#define hydro_pwhash_CONTEXT \"hydro_pw\"\n\nstatic int\n_hydro_pwhash_hash(uint8_t out[hydro_random_SEEDBYTES], size_t h_len,\n\t\t\t\t   const uint8_t salt[hydro_pwhash_SALTBYTES], const char *passwd,\n\t\t\t\t   size_t passwd_len, const char ctx[hydro_pwhash_CONTEXTBYTES],\n\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES], uint64_t opslimit,\n\t\t\t\t   size_t memlimit, uint8_t threads)\n{\n\t_hydro_attr_aligned_(16) uint8_t state[gimli_BLOCKBYTES];\n\thydro_hash_state                 h_st;\n\tuint8_t                          tmp64_u8[8];\n\tuint64_t                         i;\n\tuint8_t                          tmp8;\n\n\tCOMPILER_ASSERT(hydro_pwhash_MASTERKEYBYTES >= hydro_hash_KEYBYTES);\n\thydro_hash_init(&h_st, ctx, master_key);\n\n\tSTORE64_LE(tmp64_u8, (uint64_t) passwd_len);\n\thydro_hash_update(&h_st, tmp64_u8, sizeof tmp64_u8);\n\thydro_hash_update(&h_st, passwd, passwd_len);\n\n\thydro_hash_update(&h_st, salt, hydro_pwhash_SALTBYTES);\n\n\ttmp8 = hydro_pwhash_HASH_ALG;\n\thydro_hash_update(&h_st, &tmp8, 1);\n\n\thydro_hash_update(&h_st, &threads, 1);\n\n\tSTORE64_LE(tmp64_u8, (uint64_t) memlimit);\n\thydro_hash_update(&h_st, tmp64_u8, sizeof tmp64_u8);\n\n\tSTORE64_LE(tmp64_u8, (uint64_t) h_len);\n\thydro_hash_update(&h_st, tmp64_u8, sizeof tmp64_u8);\n\n\thydro_hash_final(&h_st, (uint8_t *) (void *) &state, sizeof state);\n\n\tgimli_core_u8(state, 1);\n\tCOMPILER_ASSERT(gimli_RATE >= 8);\n\tfor (i = 0; i < opslimit; i++) {\n\t\tmem_zero(state, gimli_RATE);\n\t\tSTORE64_LE(state, i);\n\t\tgimli_core_u8(state, 0);\n\t}\n\tmem_zero(state, gimli_RATE);\n\n\tCOMPILER_ASSERT(hydro_random_SEEDBYTES == gimli_CAPACITY);\n\tmemcpy(out, state + gimli_RATE, hydro_random_SEEDBYTES);\n\thydro_memzero(state, sizeof state);\n\n\treturn 0;\n}\n\nvoid\nhydro_pwhash_keygen(uint8_t master_key[hydro_pwhash_MASTERKEYBYTES])\n{\n\thydro_random_buf(master_key, hydro_pwhash_MASTERKEYBYTES);\n}\n\nint\nhydro_pwhash_deterministic(uint8_t *h, size_t h_len, const char *passwd, size_t passwd_len,\n\t\t\t\t\t\t   const char    ctx[hydro_pwhash_CONTEXTBYTES],\n\t\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES], uint64_t opslimit,\n\t\t\t\t\t\t   size_t memlimit, uint8_t threads)\n{\n\tuint8_t seed[hydro_random_SEEDBYTES];\n\n\tCOMPILER_ASSERT(sizeof zero >= hydro_pwhash_SALTBYTES);\n\tCOMPILER_ASSERT(sizeof zero >= hydro_pwhash_MASTERKEYBYTES);\n\n\t(void) memlimit;\n\tif (_hydro_pwhash_hash(seed, h_len, zero, passwd, passwd_len, ctx, master_key, opslimit,\n\t\t\t\t\t\t   memlimit, threads) != 0) {\n\t\treturn -1;\n\t}\n\thydro_random_buf_deterministic(h, h_len, seed);\n\thydro_memzero(seed, sizeof seed);\n\n\treturn 0;\n}\n\nint\nhydro_pwhash_create(uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd, size_t passwd_len,\n\t\t\t\t\tconst uint8_t master_key[hydro_pwhash_MASTERKEYBYTES], uint64_t opslimit,\n\t\t\t\t\tsize_t memlimit, uint8_t threads)\n{\n\tuint8_t *const enc_alg     = &stored[0];\n\tuint8_t *const secretbox   = &enc_alg[hydro_pwhash_ENC_ALGBYTES];\n\tuint8_t *const hash_alg    = &secretbox[hydro_secretbox_HEADERBYTES];\n\tuint8_t *const threads_u8  = &hash_alg[hydro_pwhash_HASH_ALGBYTES];\n\tuint8_t *const opslimit_u8 = &threads_u8[hydro_pwhash_THREADSBYTES];\n\tuint8_t *const memlimit_u8 = &opslimit_u8[hydro_pwhash_OPSLIMITBYTES];\n\tuint8_t *const salt        = &memlimit_u8[hydro_pwhash_MEMLIMITBYTES];\n\tuint8_t *const h           = &salt[hydro_pwhash_SALTBYTES];\n\n\tCOMPILER_ASSERT(hydro_pwhash_STOREDBYTES >= hydro_pwhash_ENC_ALGBYTES +\n\t\t\t\t\t\t\t\t\t\t\t\t\thydro_secretbox_HEADERBYTES +\n\t\t\t\t\t\t\t\t\t\t\t\t\thydro_pwhash_PARAMSBYTES);\n\t(void) memlimit;\n\tmem_zero(stored, hydro_pwhash_STOREDBYTES);\n\t*enc_alg    = hydro_pwhash_ENC_ALG;\n\t*hash_alg   = hydro_pwhash_HASH_ALG;\n\t*threads_u8 = threads;\n\tSTORE64_LE(opslimit_u8, opslimit);\n\tSTORE64_LE(memlimit_u8, (uint64_t) memlimit);\n\thydro_random_buf(salt, hydro_pwhash_SALTBYTES);\n\n\tCOMPILER_ASSERT(sizeof zero >= hydro_pwhash_MASTERKEYBYTES);\n\tif (_hydro_pwhash_hash(h, hydro_pwhash_HASHBYTES, salt, passwd, passwd_len,\n\t\t\t\t\t\t   hydro_pwhash_CONTEXT, zero, opslimit, memlimit, threads) != 0) {\n\t\treturn -1;\n\t}\n\tCOMPILER_ASSERT(hydro_pwhash_MASTERKEYBYTES == hydro_secretbox_KEYBYTES);\n\n\treturn hydro_secretbox_encrypt(secretbox, hash_alg, hydro_pwhash_PARAMSBYTES,\n\t\t\t\t\t\t\t\t   (uint64_t) *enc_alg, hydro_pwhash_CONTEXT, master_key);\n}\n\nstatic int\n_hydro_pwhash_verify(uint8_t       computed_h[hydro_pwhash_HASHBYTES],\n\t\t\t\t\t const uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd,\n\t\t\t\t\t size_t passwd_len, const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t uint64_t opslimit_max, size_t memlimit_max, uint8_t threads_max)\n{\n\tconst uint8_t *const enc_alg   = &stored[0];\n\tconst uint8_t *const secretbox = &enc_alg[hydro_pwhash_ENC_ALGBYTES];\n\n\tuint8_t        params[hydro_pwhash_PARAMSBYTES];\n\tuint8_t *const hash_alg    = &params[0];\n\tuint8_t *const threads_u8  = &hash_alg[hydro_pwhash_HASH_ALGBYTES];\n\tuint8_t *const opslimit_u8 = &threads_u8[hydro_pwhash_THREADSBYTES];\n\tuint8_t *const memlimit_u8 = &opslimit_u8[hydro_pwhash_OPSLIMITBYTES];\n\tuint8_t *const salt        = &memlimit_u8[hydro_pwhash_MEMLIMITBYTES];\n\tuint8_t *const h           = &salt[hydro_pwhash_SALTBYTES];\n\n\tuint64_t opslimit;\n\tsize_t   memlimit;\n\tuint8_t  threads;\n\n\t(void) memlimit;\n\tif (*enc_alg != hydro_pwhash_ENC_ALG) {\n\t\treturn -1;\n\t}\n\tif (hydro_secretbox_decrypt(params, secretbox,\n\t\t\t\t\t\t\t\thydro_secretbox_HEADERBYTES + hydro_pwhash_PARAMSBYTES,\n\t\t\t\t\t\t\t\t(uint64_t) *enc_alg, hydro_pwhash_CONTEXT, master_key) != 0) {\n\t\treturn -1;\n\t}\n\tif (*hash_alg != hydro_pwhash_HASH_ALG || (opslimit = LOAD64_LE(opslimit_u8)) > opslimit_max ||\n\t\t(memlimit = (size_t) LOAD64_LE(memlimit_u8)) > memlimit_max ||\n\t\t(threads = *threads_u8) > threads_max) {\n\t\treturn -1;\n\t}\n\tif (_hydro_pwhash_hash(computed_h, hydro_pwhash_HASHBYTES, salt, passwd, passwd_len,\n\t\t\t\t\t\t   hydro_pwhash_CONTEXT, zero, opslimit, memlimit, threads) == 0 &&\n\t\thydro_equal(computed_h, h, hydro_pwhash_HASHBYTES) == 1) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint\nhydro_pwhash_verify(const uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd,\n\t\t\t\t\tsize_t passwd_len, const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\tuint64_t opslimit_max, size_t memlimit_max, uint8_t threads_max)\n{\n\tuint8_t computed_h[hydro_pwhash_HASHBYTES];\n\tint     ret;\n\n\tret = _hydro_pwhash_verify(computed_h, stored, passwd, passwd_len, master_key, opslimit_max,\n\t\t\t\t\t\t\t   memlimit_max, threads_max);\n\thydro_memzero(computed_h, sizeof computed_h);\n\n\treturn ret;\n}\n\nint\nhydro_pwhash_derive_static_key(uint8_t *static_key, size_t static_key_len,\n\t\t\t\t\t\t\t   const uint8_t stored[hydro_pwhash_STOREDBYTES], const char *passwd,\n\t\t\t\t\t\t\t   size_t passwd_len, const char ctx[hydro_pwhash_CONTEXTBYTES],\n\t\t\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t\t\t   uint64_t opslimit_max, size_t memlimit_max, uint8_t threads_max)\n{\n\tuint8_t computed_h[hydro_pwhash_HASHBYTES];\n\n\tif (_hydro_pwhash_verify(computed_h, stored, passwd, passwd_len, master_key, opslimit_max,\n\t\t\t\t\t\t\t memlimit_max, threads_max) != 0) {\n\t\thydro_memzero(computed_h, sizeof computed_h);\n\t\treturn -1;\n\t}\n\tCOMPILER_ASSERT(hydro_kdf_CONTEXTBYTES <= hydro_pwhash_CONTEXTBYTES);\n\tCOMPILER_ASSERT(hydro_kdf_KEYBYTES <= hydro_pwhash_HASHBYTES);\n\thydro_kdf_derive_from_key(static_key, static_key_len, 0, ctx, computed_h);\n\thydro_memzero(computed_h, sizeof computed_h);\n\n\treturn 0;\n}\n\nint\nhydro_pwhash_reencrypt(uint8_t       stored[hydro_pwhash_STOREDBYTES],\n\t\t\t\t\t   const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES],\n\t\t\t\t\t   const uint8_t new_master_key[hydro_pwhash_MASTERKEYBYTES])\n{\n\tuint8_t *const enc_alg   = &stored[0];\n\tuint8_t *const secretbox = &enc_alg[hydro_pwhash_ENC_ALGBYTES];\n\tuint8_t *const params    = &secretbox[hydro_secretbox_HEADERBYTES];\n\n\tif (*enc_alg != hydro_pwhash_ENC_ALG) {\n\t\treturn -1;\n\t}\n\tif (hydro_secretbox_decrypt(secretbox, secretbox,\n\t\t\t\t\t\t\t\thydro_secretbox_HEADERBYTES + hydro_pwhash_PARAMSBYTES,\n\t\t\t\t\t\t\t\t(uint64_t) *enc_alg, hydro_pwhash_CONTEXT, master_key) != 0) {\n\t\treturn -1;\n\t}\n\tmemmove(params, secretbox, hydro_pwhash_PARAMSBYTES);\n\treturn hydro_secretbox_encrypt(secretbox, params, hydro_pwhash_PARAMSBYTES, (uint64_t) *enc_alg,\n\t\t\t\t\t\t\t\t   hydro_pwhash_CONTEXT, new_master_key);\n}\n\nint\nhydro_pwhash_upgrade(uint8_t       stored[hydro_pwhash_STOREDBYTES],\n\t\t\t\t\t const uint8_t master_key[hydro_pwhash_MASTERKEYBYTES], uint64_t opslimit,\n\t\t\t\t\t size_t memlimit, uint8_t threads)\n{\n\tuint8_t *const enc_alg     = &stored[0];\n\tuint8_t *const secretbox   = &enc_alg[hydro_pwhash_ENC_ALGBYTES];\n\tuint8_t *const params      = &secretbox[hydro_secretbox_HEADERBYTES];\n\tuint8_t *const hash_alg    = &params[0];\n\tuint8_t *const threads_u8  = &hash_alg[hydro_pwhash_HASH_ALGBYTES];\n\tuint8_t *const opslimit_u8 = &threads_u8[hydro_pwhash_THREADSBYTES];\n\tuint8_t *const memlimit_u8 = &opslimit_u8[hydro_pwhash_OPSLIMITBYTES];\n\tuint8_t *const salt        = &memlimit_u8[hydro_pwhash_MEMLIMITBYTES];\n\tuint8_t *const h           = &salt[hydro_pwhash_SALTBYTES];\n\n\t_hydro_attr_aligned_(16) uint8_t state[gimli_BLOCKBYTES];\n\tuint64_t                         i;\n\tuint64_t                         opslimit_prev;\n\n\tif (*enc_alg != hydro_pwhash_ENC_ALG) {\n\t\treturn -1;\n\t}\n\tif (hydro_secretbox_decrypt(secretbox, secretbox,\n\t\t\t\t\t\t\t\thydro_secretbox_HEADERBYTES + hydro_pwhash_PARAMSBYTES,\n\t\t\t\t\t\t\t\t(uint64_t) *enc_alg, hydro_pwhash_CONTEXT, master_key) != 0) {\n\t\treturn -1;\n\t}\n\tmemmove(params, secretbox, hydro_pwhash_PARAMSBYTES);\n\topslimit_prev = LOAD64_LE(opslimit_u8);\n\tif (*hash_alg != hydro_pwhash_HASH_ALG) {\n\t\tmem_zero(stored, hydro_pwhash_STOREDBYTES);\n\t\treturn -1;\n\t}\n\tCOMPILER_ASSERT(hydro_random_SEEDBYTES == gimli_CAPACITY);\n\tmemcpy(state + gimli_RATE, h, hydro_random_SEEDBYTES);\n\tfor (i = opslimit_prev; i < opslimit; i++) {\n\t\tmem_zero(state, gimli_RATE);\n\t\tSTORE64_LE(state, i);\n\t\tgimli_core_u8(state, 0);\n\t}\n\tmem_zero(state, gimli_RATE);\n\tmemcpy(h, state + gimli_RATE, hydro_random_SEEDBYTES);\n\t*threads_u8 = threads;\n\tSTORE64_LE(opslimit_u8, opslimit);\n\tSTORE64_LE(memlimit_u8, (uint64_t) memlimit);\n\n\treturn hydro_secretbox_encrypt(secretbox, params, hydro_pwhash_PARAMSBYTES, (uint64_t) *enc_alg,\n\t\t\t\t\t\t\t\t   hydro_pwhash_CONTEXT, master_key);\n}\n\n\n#define hydro_sign_CHALLENGEBYTES 32\n#define hydro_sign_NONCEBYTES 32\n#define hydro_sign_PREHASHBYTES 64\n\nstatic void\nhydro_sign_p2(uint8_t sig[hydro_x25519_BYTES], const uint8_t challenge[hydro_sign_CHALLENGEBYTES],\n\t\t\t  const uint8_t eph_sk[hydro_x25519_BYTES], const uint8_t sk[hydro_x25519_BYTES])\n{\n\thydro_x25519_scalar_t scalar1, scalar2, scalar3;\n\n\tCOMPILER_ASSERT(hydro_sign_CHALLENGEBYTES == hydro_x25519_BYTES);\n\thydro_x25519_swapin(scalar1, eph_sk);\n\thydro_x25519_swapin(scalar2, sk);\n\thydro_x25519_swapin(scalar3, challenge);\n\thydro_x25519_sc_montmul(scalar1, scalar2, scalar3);\n\tmem_zero(scalar2, sizeof scalar2);\n\thydro_x25519_sc_montmul(scalar2, scalar1, hydro_x25519_sc_r2);\n\thydro_x25519_swapout(sig, scalar2);\n}\n\nstatic void\nhydro_sign_challenge(uint8_t       challenge[hydro_sign_CHALLENGEBYTES],\n\t\t\t\t\t const uint8_t nonce[hydro_sign_NONCEBYTES],\n\t\t\t\t\t const uint8_t pk[hydro_sign_PUBLICKEYBYTES],\n\t\t\t\t\t const uint8_t prehash[hydro_sign_PREHASHBYTES])\n{\n\thydro_hash_state st;\n\n\thydro_hash_init(&st, (const char *) zero, NULL);\n\thydro_hash_update(&st, nonce, hydro_sign_NONCEBYTES);\n\thydro_hash_update(&st, pk, hydro_sign_PUBLICKEYBYTES);\n\thydro_hash_update(&st, prehash, hydro_sign_PREHASHBYTES);\n\thydro_hash_final(&st, challenge, hydro_sign_CHALLENGEBYTES);\n}\n\nstatic int\nhydro_sign_prehash(uint8_t csig[hydro_sign_BYTES], const uint8_t prehash[hydro_sign_PREHASHBYTES],\n\t\t\t\t   const uint8_t sk[hydro_sign_SECRETKEYBYTES])\n{\n\thydro_hash_state st;\n\tuint8_t          challenge[hydro_sign_CHALLENGEBYTES];\n\tconst uint8_t *  pk     = &sk[hydro_x25519_SECRETKEYBYTES];\n\tuint8_t *        nonce  = &csig[0];\n\tuint8_t *        sig    = &csig[hydro_sign_NONCEBYTES];\n\tuint8_t *        eph_sk = sig;\n\n\thydro_random_buf(eph_sk, hydro_x25519_SECRETKEYBYTES);\n\tCOMPILER_ASSERT(hydro_x25519_SECRETKEYBYTES == hydro_hash_KEYBYTES);\n\thydro_hash_init(&st, (const char *) zero, sk);\n\thydro_hash_update(&st, eph_sk, hydro_x25519_SECRETKEYBYTES);\n\thydro_hash_update(&st, prehash, hydro_sign_PREHASHBYTES);\n\thydro_hash_final(&st, eph_sk, hydro_x25519_SECRETKEYBYTES);\n\n\thydro_x25519_scalarmult_base_uniform(nonce, eph_sk);\n\thydro_sign_challenge(challenge, nonce, pk, prehash);\n\n\tCOMPILER_ASSERT(hydro_sign_BYTES == hydro_sign_NONCEBYTES + hydro_x25519_SECRETKEYBYTES);\n\tCOMPILER_ASSERT(hydro_x25519_SECRETKEYBYTES <= hydro_sign_CHALLENGEBYTES);\n\thydro_sign_p2(sig, challenge, eph_sk, sk);\n\n\treturn 0;\n}\n\nstatic int\nhydro_sign_verify_core(hydro_x25519_fe xs[5], const hydro_x25519_limb_t *other1,\n\t\t\t\t\t   const uint8_t other2[hydro_x25519_BYTES])\n{\n\thydro_x25519_limb_t *     z2 = xs[1], *x3 = xs[2], *z3 = xs[3];\n\thydro_x25519_fe           xo2;\n\tconst hydro_x25519_limb_t sixteen = 16;\n\n\thydro_x25519_swapin(xo2, other2);\n\tmemcpy(x3, other1, 2 * sizeof(hydro_x25519_fe));\n\thydro_x25519_ladder_part1(xs);\n\n\t/* Here z2 = t2^2 */\n\thydro_x25519_mul1(z2, other1);\n\thydro_x25519_mul1(z2, other1 + hydro_x25519_NLIMBS);\n\thydro_x25519_mul1(z2, xo2);\n\n\thydro_x25519_mul(z2, z2, &sixteen, 1);\n\n\thydro_x25519_mul1(z3, xo2);\n\thydro_x25519_sub(z3, z3, x3);\n\thydro_x25519_sqr1(z3);\n\n\t/* check equality */\n\thydro_x25519_sub(z3, z3, z2);\n\n\t/* canon(z2): both sides are zero. canon(z3): the two sides are equal. */\n\t/* Reject sigs where both sides are zero. */\n\treturn hydro_x25519_canon(z2) | ~hydro_x25519_canon(z3);\n}\n\nstatic int\nhydro_sign_verify_p2(const uint8_t sig[hydro_x25519_BYTES],\n\t\t\t\t\t const uint8_t challenge[hydro_sign_CHALLENGEBYTES],\n\t\t\t\t\t const uint8_t nonce[hydro_sign_NONCEBYTES],\n\t\t\t\t\t const uint8_t pk[hydro_x25519_BYTES])\n{\n\thydro_x25519_fe xs[7];\n\n\thydro_x25519_core(&xs[0], challenge, pk, 0);\n\thydro_x25519_core(&xs[2], sig, hydro_x25519_BASE_POINT, 0);\n\n\treturn hydro_sign_verify_core(&xs[2], xs[0], nonce);\n}\n\nstatic int\nhydro_sign_verify_challenge(const uint8_t csig[hydro_sign_BYTES],\n\t\t\t\t\t\t\tconst uint8_t challenge[hydro_sign_CHALLENGEBYTES],\n\t\t\t\t\t\t\tconst uint8_t pk[hydro_sign_PUBLICKEYBYTES])\n{\n\tconst uint8_t *nonce = &csig[0];\n\tconst uint8_t *sig   = &csig[hydro_sign_NONCEBYTES];\n\n\treturn hydro_sign_verify_p2(sig, challenge, nonce, pk);\n}\n\nvoid\nhydro_sign_keygen(hydro_sign_keypair *kp)\n{\n\tuint8_t *pk_copy = &kp->sk[hydro_x25519_SECRETKEYBYTES];\n\n\tCOMPILER_ASSERT(hydro_sign_SECRETKEYBYTES ==\n\t\t\t\t\thydro_x25519_SECRETKEYBYTES + hydro_x25519_PUBLICKEYBYTES);\n\tCOMPILER_ASSERT(hydro_sign_PUBLICKEYBYTES == hydro_x25519_PUBLICKEYBYTES);\n\thydro_random_buf(kp->sk, hydro_x25519_SECRETKEYBYTES);\n\thydro_x25519_scalarmult_base_uniform(kp->pk, kp->sk);\n\tmemcpy(pk_copy, kp->pk, hydro_x25519_PUBLICKEYBYTES);\n}\n\nvoid\nhydro_sign_keygen_deterministic(hydro_sign_keypair *kp, const uint8_t seed[hydro_sign_SEEDBYTES])\n{\n\tuint8_t *pk_copy = &kp->sk[hydro_x25519_SECRETKEYBYTES];\n\n\tCOMPILER_ASSERT(hydro_sign_SEEDBYTES >= hydro_random_SEEDBYTES);\n\thydro_random_buf_deterministic(kp->sk, hydro_x25519_SECRETKEYBYTES, seed);\n\thydro_x25519_scalarmult_base_uniform(kp->pk, kp->sk);\n\tmemcpy(pk_copy, kp->pk, hydro_x25519_PUBLICKEYBYTES);\n}\n\nint\nhydro_sign_init(hydro_sign_state *state, const char ctx[hydro_sign_CONTEXTBYTES])\n{\n\treturn hydro_hash_init(&state->hash_st, ctx, NULL);\n}\n\nint\nhydro_sign_update(hydro_sign_state *state, const void *m_, size_t mlen)\n{\n\treturn hydro_hash_update(&state->hash_st, m_, mlen);\n}\n\nint\nhydro_sign_final_create(hydro_sign_state *state, uint8_t csig[hydro_sign_BYTES],\n\t\t\t\t\t\tconst uint8_t sk[hydro_sign_SECRETKEYBYTES])\n{\n\tuint8_t prehash[hydro_sign_PREHASHBYTES];\n\n\thydro_hash_final(&state->hash_st, prehash, sizeof prehash);\n\n\treturn hydro_sign_prehash(csig, prehash, sk);\n}\n\nint\nhydro_sign_final_verify(hydro_sign_state *state, const uint8_t csig[hydro_sign_BYTES],\n\t\t\t\t\t\tconst uint8_t pk[hydro_sign_PUBLICKEYBYTES])\n{\n\tuint8_t        challenge[hydro_sign_CHALLENGEBYTES];\n\tuint8_t        prehash[hydro_sign_PREHASHBYTES];\n\tconst uint8_t *nonce = &csig[0];\n\n\thydro_hash_final(&state->hash_st, prehash, sizeof prehash);\n\thydro_sign_challenge(challenge, nonce, pk, prehash);\n\n\treturn hydro_sign_verify_challenge(csig, challenge, pk);\n}\n\nint\nhydro_sign_create(uint8_t csig[hydro_sign_BYTES], const void *m_, size_t mlen,\n\t\t\t\t  const char    ctx[hydro_sign_CONTEXTBYTES],\n\t\t\t\t  const uint8_t sk[hydro_sign_SECRETKEYBYTES])\n{\n\thydro_sign_state st;\n\n\tif (hydro_sign_init(&st, ctx) != 0 || hydro_sign_update(&st, m_, mlen) != 0 ||\n\t\thydro_sign_final_create(&st, csig, sk) != 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint\nhydro_sign_verify(const uint8_t csig[hydro_sign_BYTES], const void *m_, size_t mlen,\n\t\t\t\t  const char    ctx[hydro_sign_CONTEXTBYTES],\n\t\t\t\t  const uint8_t pk[hydro_sign_PUBLICKEYBYTES])\n{\n\thydro_sign_state st;\n\n\tif (hydro_sign_init(&st, ctx) != 0 || hydro_sign_update(&st, m_, mlen) != 0 ||\n\t\thydro_sign_final_verify(&st, csig, pk) != 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#if defined(_MSC_VER)\n#\tpragma warning(pop)\n#endif\n\n// End of embedded libhydrogen source.\n// See https://github.com/jedisct1/libhydrogen for the original source.\n//--------------------------------------------------------------------------------------------------\n\n//--------------------------------------------------------------------------------------------------\n// PROTOCOL\n\n#define CN_PROTOCOL_VERSION_STRING ((const uint8_t*)\"CUTE 1.00\")\n#define CN_PROTOCOL_VERSION_STRING_LEN (9 + 1)\n#define CN_PROTOCOL_SERVER_MAX_CLIENTS 32\n#define CN_PROTOCOL_PACKET_SIZE_MAX (CN_KB + 256)\n#define CN_PROTOCOL_PACKET_PAYLOAD_MAX (1207 - 2)\n#define CN_PROTOCOL_CLIENT_SEND_BUFFER_SIZE (256 * CN_KB)\n#define CN_PROTOCOL_CLIENT_RECEIVE_BUFFER_SIZE (256 * CN_KB)\n#define CN_PROTOCOL_SERVER_SEND_BUFFER_SIZE (CN_MB * 2)\n#define CN_PROTOCOL_SERVER_RECEIVE_BUFFER_SIZE (CN_MB * 2)\n#define CN_PROTOCOL_EVENT_QUEUE_SIZE (CN_MB * 4)\n#define CN_PROTOCOL_SIGNATURE_SIZE 64\n\n#define CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE 1024\n#define CN_PROTOCOL_CONNECT_TOKEN_SIZE 1114\n#define CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE 256\n#define CN_PROTOCOL_CONNECT_TOKEN_SECRET_SECTION_SIZE (64 + 8 + 32 + 32 + 256)\n#define CN_PROTOCOL_CONNECT_TOKEN_ENDPOINT_MAX 32\n\n#define CN_PROTOCOL_REPLAY_BUFFER_SIZE 256\n#define CN_PROTOCOL_SEND_RATE (1.0f / 10.0f)\n#define CN_PROTOCOL_DISCONNECT_REDUNDANT_PACKET_COUNT 10\n#define CN_PROTOCOL_CHALLENGE_DATA_SIZE 256\n#define CN_PROTOCOL_REDUNDANT_DISCONNECT_PACKET_COUNT 10\n\ntypedef enum cn_protocol_packet_type_t\n{\n\tCN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN,\n\tCN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED,\n\tCN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED,\n\tCN_PROTOCOL_PACKET_TYPE_KEEPALIVE,\n\tCN_PROTOCOL_PACKET_TYPE_DISCONNECT,\n\tCN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST,\n\tCN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE,\n\tCN_PROTOCOL_PACKET_TYPE_PAYLOAD,\n\n\tCN_PROTOCOL_PACKET_TYPE_COUNT,\n} cn_protocol_packet_type_t;\n\ntypedef struct cn_protocol_packet_allocator_t cn_protocol_packet_allocator_t;\ntypedef struct cn_protocol_client_t cn_protocol_client_t;\n\ntypedef enum cn_protocol_client_state_t\n{\n\tCN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED         = -6,\n\tCN_PROTOCOL_CLIENT_STATE_INVALID_CONNECT_TOKEN         = -5,\n\tCN_PROTOCOL_CLIENT_STATE_CONNECTION_TIMED_OUT          = -4,\n\tCN_PROTOCOL_CLIENT_STATE_CHALLENGED_RESPONSE_TIMED_OUT = -3,\n\tCN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT  = -2,\n\tCN_PROTOCOL_CLIENT_STATE_CONNECTION_DENIED             = -1,\n\tCN_PROTOCOL_CLIENT_STATE_DISCONNECTED                  =  0,\n\tCN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST    =  1,\n\tCN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE    =  2,\n\tCN_PROTOCOL_CLIENT_STATE_CONNECTED                     =  3,\n} cn_protocol_client_state_t;\n\ntypedef struct cn_protocol_server_t cn_protocol_server_t;\n\ntypedef enum cn_protocol_server_event_type_t\n{\n\tCN_PROTOCOL_SERVER_EVENT_NEW_CONNECTION,\n\tCN_PROTOCOL_SERVER_EVENT_DISCONNECTED,\n\tCN_PROTOCOL_SERVER_EVENT_PAYLOAD_PACKET,\n} cn_protocol_server_event_type_t;\n\ntypedef struct cn_protocol_server_event_t\n{\n\tcn_protocol_server_event_type_t type;\n\tunion\n\t{\n\t\tstruct\n\t\t{\n\t\t\tint client_index;\n\t\t\tuint64_t client_id;\n\t\t\tcn_endpoint_t endpoint;\n\t\t} new_connection;\n\n\t\tstruct\n\t\t{\n\t\t\tint client_index;\n\t\t} disconnected;\n\n\t\tstruct\n\t\t{\n\t\t\tint client_index;\n\t\t\tvoid* data;\n\t\t\tint size;\n\t\t} payload_packet;\n\t} u;\n} cn_protocol_server_event_t;\n\nvoid cn_write_uint8(uint8_t** p, uint8_t value)\n{\n\t**p = value;\n\t++(*p);\n}\n\nvoid cn_write_uint16(uint8_t** p, uint16_t value)\n{\n\t(*p)[0] = value & 0xFF;\n\t(*p)[1] = value >> 8;\n\t*p += 2;\n}\n\nvoid cn_write_uint32(uint8_t** p, uint32_t value)\n{\n\t(*p)[0] = value & 0xFF;\n\t(*p)[1] = (value >> 8 ) & 0xFF;\n\t(*p)[2] = (value >> 16) & 0xFF;\n\t(*p)[3] = value >> 24;\n\t*p += 4;\n}\n\nvoid cn_write_float(uint8_t** p, float value)\n{\n\tunion\n\t{\n\t\tuint32_t as_uint32;\n\t\tfloat as_float;\n\t} val;\n\tval.as_float = value;\n\tcn_write_uint32(p, val.as_uint32);\n}\n\nvoid cn_write_uint64(uint8_t** p, uint64_t value)\n{\n\t(*p)[0] = value & 0xFF;\n\t(*p)[1] = (value >> 8 ) & 0xFF;\n\t(*p)[2] = (value >> 16) & 0xFF;\n\t(*p)[3] = (value >> 24) & 0xFF;\n\t(*p)[4] = (value >> 32) & 0xFF;\n\t(*p)[5] = (value >> 40) & 0xFF;\n\t(*p)[6] = (value >> 48) & 0xFF;\n\t(*p)[7] = value >> 56;\n\t*p += 8;\n}\n\nvoid cn_write_bytes(uint8_t** p, const uint8_t* byte_array, int num_bytes)\n{\n\tfor (int i = 0; i < num_bytes; ++i)\n\t{\n\t\tcn_write_uint8(p, byte_array[i]);\n\t}\n}\n\nvoid cn_write_endpoint(uint8_t** p, cn_endpoint_t endpoint)\n{\n\tcn_write_uint8(p, (uint8_t)endpoint.type);\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV4) {\n\t\tcn_write_uint8(p, endpoint.u.ipv4[0]);\n\t\tcn_write_uint8(p, endpoint.u.ipv4[1]);\n\t\tcn_write_uint8(p, endpoint.u.ipv4[2]);\n\t\tcn_write_uint8(p, endpoint.u.ipv4[3]);\n\t}\n#ifndef CUTE_NET_NO_IPV6\n\telse if (endpoint.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tcn_write_uint16(p, endpoint.u.ipv6[0]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[1]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[2]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[3]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[4]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[5]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[6]);\n\t\tcn_write_uint16(p, endpoint.u.ipv6[7]);\n\t} \n#endif\n\telse {\n\t\tCN_ASSERT(0);\n\t}\n\tcn_write_uint16(p, endpoint.port);\n}\n\nvoid cn_write_key(uint8_t** p, const cn_crypto_key_t* key)\n{\n\tcn_write_bytes(p, (const uint8_t*)key, sizeof(*key));\n}\n\nvoid cn_write_fourcc(uint8_t** p, const char* fourcc)\n{\n\tcn_write_uint8(p, fourcc[0]);\n\tcn_write_uint8(p, fourcc[1]);\n\tcn_write_uint8(p, fourcc[2]);\n\tcn_write_uint8(p, fourcc[3]);\n}\n\nCN_INLINE uint8_t cn_read_uint8(uint8_t** p)\n{\n\tuint8_t value = **p;\n\t++(*p);\n\treturn value;\n}\n\nCN_INLINE uint16_t cn_read_uint16(uint8_t** p)\n{\n\tuint16_t value;\n\tvalue = (*p)[0];\n\tvalue |= (((uint16_t)((*p)[1])) << 8);\n\t*p += 2;\n\treturn value;\n}\n\nCN_INLINE uint32_t cn_read_uint32(uint8_t** p)\n{\n\tuint32_t value;\n\tvalue  = (*p)[0];\n\tvalue |= (((uint32_t)((*p)[1])) << 8);\n\tvalue |= (((uint32_t)((*p)[2])) << 16);\n\tvalue |= (((uint32_t)((*p)[3])) << 24);\n\t*p += 4;\n\treturn value;\n}\n\nCN_INLINE float cn_read_float(uint8_t** p)\n{\n\tunion\n\t{\n\t\tuint32_t as_uint32;\n\t\tfloat as_float;\n\t} val;\n\tval.as_uint32 = cn_read_uint32(p);\n\treturn val.as_float;\n}\n\nCN_INLINE uint64_t cn_read_uint64(uint8_t** p)\n{\n\tuint64_t value;\n\tvalue  = (*p)[0];\n\tvalue |= (((uint64_t)((*p)[1])) << 8 );\n\tvalue |= (((uint64_t)((*p)[2])) << 16);\n\tvalue |= (((uint64_t)((*p)[3])) << 24);\n\tvalue |= (((uint64_t)((*p)[4])) << 32);\n\tvalue |= (((uint64_t)((*p)[5])) << 40);\n\tvalue |= (((uint64_t)((*p)[6])) << 48);\n\tvalue |= (((uint64_t)((*p)[7])) << 56);\n\t*p += 8;\n\treturn value;\n}\n\nCN_INLINE void cn_read_bytes(uint8_t** p, uint8_t* byte_array, int num_bytes)\n{\n\tfor (int i = 0; i < num_bytes; ++i) {\n\t\tbyte_array[i] = cn_read_uint8(p);\n\t}\n}\n\ncn_endpoint_t cn_read_endpoint(uint8_t** p)\n{\n\tcn_endpoint_t endpoint;\n\tendpoint.type = (cn_address_type_t)cn_read_uint8(p);\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV4) {\n\t\tendpoint.u.ipv4[0] = cn_read_uint8(p);\n\t\tendpoint.u.ipv4[1] = cn_read_uint8(p);\n\t\tendpoint.u.ipv4[2] = cn_read_uint8(p);\n\t\tendpoint.u.ipv4[3] = cn_read_uint8(p);\n\t}\n#ifndef CUTE_NET_NO_IPV6\n\telse if (endpoint.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tendpoint.u.ipv6[0] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[1] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[2] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[3] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[4] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[5] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[6] = cn_read_uint16(p);\n\t\tendpoint.u.ipv6[7] = cn_read_uint16(p);\n\t}\n#endif\n\telse {\n\t\tCN_ASSERT(0);\n\t}\n\tendpoint.port = cn_read_uint16(p);\n\treturn endpoint;\n}\n\nCN_INLINE cn_crypto_key_t cn_read_key(uint8_t** p)\n{\n\tcn_crypto_key_t key;\n\tcn_read_bytes(p, (uint8_t*)&key, sizeof(key));\n\treturn key;\n}\n\nCN_INLINE void cn_read_fourcc(uint8_t** p, uint8_t* fourcc)\n{\n\tfourcc[0] = cn_read_uint8(p);\n\tfourcc[1] = cn_read_uint8(p);\n\tfourcc[2] = cn_read_uint8(p);\n\tfourcc[3] = cn_read_uint8(p);\n}\n\ntypedef struct cn_protocol_replay_buffer_t\n{\n\tuint64_t max;\n\tuint64_t entries[CN_PROTOCOL_REPLAY_BUFFER_SIZE];\n} cn_protocol_replay_buffer_t;\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_protocol_packet_connect_token_t\n{\n\tuint8_t packet_type;\n\tuint64_t expiration_timestamp;\n\tuint32_t handshake_timeout;\n\tuint16_t endpoint_count;\n\tcn_endpoint_t endpoints[CN_PROTOCOL_CONNECT_TOKEN_ENDPOINT_MAX];\n} cn_protocol_packet_connect_token_t;\n\ntypedef struct cn_protocol_packet_connection_accepted_t\n{\n\tuint8_t packet_type;\n\tuint64_t client_id;\n\tuint32_t max_clients;\n\tuint32_t connection_timeout;\n} cn_protocol_packet_connection_accepted_t;\n\ntypedef struct cn_protocol_packet_connection_denied_t\n{\n\tuint8_t packet_type;\n} cn_protocol_packet_connection_denied_t;\n\ntypedef struct cn_protocol_packet_keepalive_t\n{\n\tuint8_t packet_type;\n} cn_protocol_packet_keepalive_t;\n\ntypedef struct cn_protocol_packet_disconnect_t\n{\n\tuint8_t packet_type;\n} cn_protocol_packet_disconnect_t;\n\ntypedef struct cn_protocol_packet_challenge_t\n{\n\tuint8_t packet_type;\n\tuint64_t challenge_nonce;\n\tuint8_t challenge_data[CN_PROTOCOL_CHALLENGE_DATA_SIZE];\n} cn_protocol_packet_challenge_t;\n\ntypedef struct cn_protocol_packet_payload_t\n{\n\tuint8_t packet_type;\n\tuint16_t payload_size;\n\tuint8_t payload[CN_PROTOCOL_PACKET_PAYLOAD_MAX];\n} cn_protocol_packet_payload_t;\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_protocol_connect_token_t\n{\n\tuint64_t creation_timestamp;\n\tcn_crypto_key_t client_to_server_key;\n\tcn_crypto_key_t server_to_client_key;\n\n\tuint64_t expiration_timestamp;\n\tuint32_t handshake_timeout;\n\tuint16_t endpoint_count;\n\tcn_endpoint_t endpoints[CN_PROTOCOL_CONNECT_TOKEN_ENDPOINT_MAX];\n} cn_protocol_connect_token_t;\n\ntypedef struct cn_protocol_connect_token_decrypted_t\n{\n\tuint64_t expiration_timestamp;\n\tuint32_t handshake_timeout;\n\tuint16_t endpoint_count;\n\tcn_endpoint_t endpoints[CN_PROTOCOL_CONNECT_TOKEN_ENDPOINT_MAX];\n\n\tuint64_t client_id;\n\tcn_crypto_key_t client_to_server_key;\n\tcn_crypto_key_t server_to_client_key;\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_signature_t signature;\n} cn_protocol_connect_token_decrypted_t;\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_HASHTABLE_KEY_BYTES (hydro_hash_KEYBYTES)\n#define CN_HASHTABLE_HASH_BYTES (hydro_hash_BYTES)\n\ntypedef struct cn_hashtable_slot_t\n{\n\tuint64_t key_hash;\n\tint item_index;\n\tint base_count;\n} cn_hashtable_slot_t;\n\ntypedef struct cn_hashtable_t\n{\n\tint count;\n\tint slot_capacity;\n\tcn_hashtable_slot_t* slots;\n\n\tuint8_t secret_key[CN_HASHTABLE_KEY_BYTES];\n\n\tint key_size;\n\tint item_size;\n\tint item_capacity;\n\tvoid* items_key;\n\tint* items_slot_index;\n\tvoid* items_data;\n\n\tvoid* temp_key;\n\tvoid* temp_item;\n\tvoid* mem_ctx;\n} cn_hashtable_t;\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_list_node_t cn_list_node_t;\n\nstruct cn_list_node_t\n{\n\tcn_list_node_t* next;\n\tcn_list_node_t* prev;\n};\n\ntypedef struct cn_list_t\n{\n\tcn_list_node_t nodes;\n} cn_list_t;\n\n#define CN_OFFSET_OF(T, member) ((size_t)((uintptr_t)(&(((T*)0)->member))))\n#define CN_LIST_NODE(T, member, ptr) ((cn_list_node_t*)((uintptr_t)ptr + CN_OFFSET_OF(T, member)))\n#define CN_LIST_HOST(T, member, ptr) ((T*)((uintptr_t)ptr - CN_OFFSET_OF(T, member)))\n\nCN_INLINE void cn_list_init_node(cn_list_node_t* node)\n{\n\tnode->next = node;\n\tnode->prev = node;\n}\n\nCN_INLINE void cn_list_init(cn_list_t* list)\n{\n\tcn_list_init_node(&list->nodes);\n}\n\nCN_INLINE void cn_list_push_front(cn_list_t* list, cn_list_node_t* node)\n{\n\tnode->next = list->nodes.next;\n\tnode->prev = &list->nodes;\n\tlist->nodes.next->prev = node;\n\tlist->nodes.next = node;\n}\n\nCN_INLINE void cn_list_push_back(cn_list_t* list, cn_list_node_t* node)\n{\n\tnode->prev = list->nodes.prev;\n\tnode->next = &list->nodes;\n\tlist->nodes.prev->next = node;\n\tlist->nodes.prev = node;\n}\n\nCN_INLINE void cn_list_remove(cn_list_node_t* node)\n{\n\tnode->prev->next = node->next;\n\tnode->next->prev = node->prev;\n\tcn_list_init_node(node);\n}\n\nCN_INLINE cn_list_node_t* cn_list_pop_front(cn_list_t* list)\n{\n\tcn_list_node_t* node = list->nodes.next;\n\tcn_list_remove(node);\n\treturn node;\n}\n\nCN_INLINE cn_list_node_t* cn_list_pop_back(cn_list_t* list)\n{\n\tcn_list_node_t* node = list->nodes.prev;\n\tcn_list_remove(node);\n\treturn node;\n}\n\nCN_INLINE int cn_list_empty(cn_list_t* list)\n{\n\treturn list->nodes.next == list->nodes.prev && list->nodes.next == &list->nodes;\n}\n\nCN_INLINE cn_list_node_t* cn_list_begin(cn_list_t* list)\n{\n\treturn list->nodes.next;\n}\n\nCN_INLINE cn_list_node_t* cn_list_end(cn_list_t* list)\n{\n\treturn &list->nodes;\n}\n\nCN_INLINE cn_list_node_t* cn_list_front(cn_list_t* list)\n{\n\treturn list->nodes.next;\n}\n\nCN_INLINE cn_list_node_t* cn_list_back(cn_list_t* list)\n{\n\treturn list->nodes.prev;\n}\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_PROTOCOL_CONNECT_TOKEN_ENTRIES_MAX (CN_PROTOCOL_SERVER_MAX_CLIENTS * 8)\n\ntypedef struct cn_protocol_connect_token_cache_entry_t\n{\n\tcn_list_node_t* node;\n} cn_protocol_connect_token_cache_entry_t;\n\ntypedef struct cn_protocol_connect_token_cache_node_t\n{\n\tcn_crypto_signature_t signature;\n\tcn_list_node_t node;\n} cn_protocol_connect_token_cache_node_t;\n\ntypedef struct cn_protocol_connect_token_cache_t\n{\n\tint capacity;\n\tcn_hashtable_t table;\n\tcn_list_t list;\n\tcn_list_t free_list;\n\tcn_protocol_connect_token_cache_node_t* node_memory;\n\tvoid* mem_ctx;\n} cn_protocol_connect_token_cache_t;\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_PROTOCOL_ENCRYPTION_STATES_MAX (CN_PROTOCOL_SERVER_MAX_CLIENTS * 2)\n\ntypedef struct cn_protocol_encryption_state_t\n{\n\tuint64_t sequence;\n\tuint64_t expiration_timestamp;\n\tuint32_t handshake_timeout;\n\tdouble last_packet_recieved_time;\n\tdouble last_packet_sent_time;\n\tcn_crypto_key_t client_to_server_key;\n\tcn_crypto_key_t server_to_client_key;\n\tuint64_t client_id;\n\tcn_crypto_signature_t signature;\n} cn_protocol_encryption_state_t;\n\ntypedef struct cn_protocol_encryption_map_t\n{\n\tcn_hashtable_t table;\n} cn_protocol_encryption_map_t;\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_circular_buffer_t\n{\n\tint index0;\n\tint index1;\n\tint size_left;\n\tint capacity;\n\tuint8_t* data;\n\tvoid* user_allocator_context;\n} cn_circular_buffer_t;\n\ncn_circular_buffer_t cn_circular_buffer_create(int initial_size_in_bytes, void* user_allocator_context)\n{\n\tcn_circular_buffer_t buffer;\n\tbuffer.index0 = 0;\n\tbuffer.index1 = 0;\n\tbuffer.size_left = initial_size_in_bytes;\n\tbuffer.capacity = initial_size_in_bytes;\n\tbuffer.data = (uint8_t*)CN_ALLOC(initial_size_in_bytes, user_allocator_context);\n\tbuffer.user_allocator_context = user_allocator_context;\n\treturn buffer;\n}\n\nvoid cn_circular_buffer_free(cn_circular_buffer_t* buffer)\n{\n\tCN_FREE(buffer->data, buffer->user_allocator_context);\n\tCN_MEMSET(buffer, 0, sizeof(*buffer));\n}\n\nvoid cn_circular_buffer_reset(cn_circular_buffer_t* buffer)\n{\n\tbuffer->index0 = 0;\n\tbuffer->index1 = 0;\n\tbuffer->size_left = buffer->capacity;\n}\n\nint cn_circular_buffer_push(cn_circular_buffer_t* buffer, const void* data, int size)\n{\n\tif (buffer->size_left < size) {\n\t\treturn -1;\n\t}\n\n\tint bytes_to_end = buffer->capacity - buffer->index1;\n\tif (size > bytes_to_end) {\n\t\tCN_MEMCPY(buffer->data + buffer->index1, data, bytes_to_end);\n\t\tCN_MEMCPY(buffer->data, (uint8_t*)data + bytes_to_end, size - bytes_to_end);\n\t\tbuffer->index1 = (size - bytes_to_end) % buffer->capacity;\n\t} else {\n\t\tCN_MEMCPY(buffer->data + buffer->index1, data, size);\n\t\tbuffer->index1 = (buffer->index1 + size) % buffer->capacity;\n\t}\n\n\tbuffer->size_left -= size;\n\n\treturn 0;\n}\n\nint cn_circular_buffer_pull(cn_circular_buffer_t* buffer, void* data, int size)\n{\n\tif (buffer->capacity - buffer->size_left < size) {\n\t\treturn -1;\n\t}\n\n\tint bytes_to_end = buffer->capacity - buffer->index0;\n\tif (size > bytes_to_end) {\n\t\tCN_MEMCPY(data, buffer->data + buffer->index0, bytes_to_end);\n\t\tCN_MEMCPY((uint8_t*)data + bytes_to_end, buffer->data, size - bytes_to_end);\n\t\tbuffer->index0 = (size - bytes_to_end) % buffer->capacity;\n\t} else {\n\t\tCN_MEMCPY(data, buffer->data + buffer->index0, size);\n\t\tbuffer->index0 = (buffer->index0 + size) % buffer->capacity;\n\t}\n\n\tbuffer->size_left += size;\n\n\treturn 0;\n}\n\nint cn_circular_buffer_grow(cn_circular_buffer_t* buffer, int new_size_in_bytes)\n{\n\tuint8_t* old_data = buffer->data;\n\tuint8_t* new_data = (uint8_t*)CN_ALLOC(new_size_in_bytes, buffer->user_allocator_context);\n\tif (!new_data) return -1;\n\n\tint index0 = buffer->index0;\n\tint index1 = buffer->index1;\n\n\tif (index0 < index1) {\n\t\tCN_MEMCPY(new_data + index0, old_data + index0, index1 - index0);\n\t} else {\n\t\tCN_MEMCPY(new_data, old_data, index1);\n\t\tint offset_from_end = buffer->capacity - index0;\n\t\tCN_MEMCPY(new_data + new_size_in_bytes - offset_from_end, old_data + index0, offset_from_end);\n\t}\n\n\tCN_FREE(old_data, buffer->user_allocator_context);\n\tbuffer->data = new_data;\n\tbuffer->size_left += new_size_in_bytes - buffer->capacity;\n\tbuffer->capacity = new_size_in_bytes;\n\n\treturn 0;\n}\n\n// -------------------------------------------------------------------------------------------------\n\n#ifdef CN_WINDOWS\n#\tinclude <ws2tcpip.h>   // WSA stuff\n#\tinclude <winsock2.h>   // socket\n#\tpragma comment(lib, \"ws2_32.lib\")\n#else\n#\tinclude <sys/socket.h> // socket\n#\tinclude <fcntl.h>      // fcntl\n#\tinclude <arpa/inet.h>  // inet_pton\n#\tinclude <unistd.h>     // close\n#\tinclude <errno.h>\n#endif\n\nstatic char* s_parse_ipv6_for_port(cn_endpoint_t* endpoint, char* str, int len)\n{\n\tif (*str == '[') {\n\t\tint base_index = len - 1;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint index = base_index - i;\n\t\t\tif (index < 3) return NULL;\n\t\t\tif (str[index] == ':') {\n\t\t\t\tendpoint->port = (uint16_t)atoi(str + index + 1);\n\t\t\t\tstr[index - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tCN_ASSERT(*str == '[');\n\t\t++str;\n\t}\n\treturn str;\n}\n\nstatic int s_parse_ipv4_for_port(cn_endpoint_t* endpoint, char* str)\n{\n\tint len = (int)CN_STRLEN(str);\n\tint base_index = len - 1;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tint index = base_index - i;\n\t\tif (index < 0) break;\n\t\tif (str[index] == ':') {\n\t\t\tendpoint->port = (uint16_t)atoi(str + index + 1);\n\t\t\tstr[index] = '\\0';\n\t\t}\n\t}\n\treturn len;\n}\n\n#define CN_ENDPOINT_STRING_MAX_LENGTH INET6_ADDRSTRLEN\n\nint cn_endpoint_init(cn_endpoint_t* endpoint, const char* address_and_port_string)\n{\n\tCN_ASSERT(address_and_port_string);\n\tCN_MEMSET(endpoint, 0, sizeof(*endpoint));\n\n\tchar buffer[CN_ENDPOINT_STRING_MAX_LENGTH];\n\tCN_STRNCPY(buffer, address_and_port_string, CN_ENDPOINT_STRING_MAX_LENGTH - 1);\n\tbuffer[CN_ENDPOINT_STRING_MAX_LENGTH - 1] = '\\0';\n\n\tchar* str = buffer;\n\tint len = (int)CN_STRLEN(str);\n\n#ifndef CUTE_NET_NO_IPV6\n\tstr = s_parse_ipv6_for_port(endpoint, str, len);\n\tstruct in6_addr sockaddr6;\n\tif (inet_pton(AF_INET6, str, &sockaddr6) == 1) {\n\t\tendpoint->type = CN_ADDRESS_TYPE_IPV6;\n\t\tint i;\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tendpoint->u.ipv6[i] = ntohs(((uint16_t*)&sockaddr6)[i]);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\n\tlen = s_parse_ipv4_for_port(endpoint, str);\n\n\tstruct sockaddr_in sockaddr4;\n\tif (inet_pton(AF_INET, str, &sockaddr4.sin_addr) == 1) {\n\t\tendpoint->type = CN_ADDRESS_TYPE_IPV4;\n\t\tendpoint->u.ipv4[3] = (uint8_t)((sockaddr4.sin_addr.s_addr & 0xFF000000) >> 24);\n\t\tendpoint->u.ipv4[2] = (uint8_t)((sockaddr4.sin_addr.s_addr & 0x00FF0000) >> 16);\n\t\tendpoint->u.ipv4[1] = (uint8_t)((sockaddr4.sin_addr.s_addr & 0x0000FF00) >> 8 );\n\t\tendpoint->u.ipv4[0] = (uint8_t)((sockaddr4.sin_addr.s_addr & 0x000000FF)      );\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nvoid cn_endpoint_to_string(cn_endpoint_t endpoint, char* buffer, int buffer_size)\n{\n\tCN_ASSERT(buffer);\n\tCN_ASSERT(buffer_size >= 0);\n\n#ifndef CUTE_NET_NO_IPV6\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tif (endpoint.port == 0) {\n\t\t\tuint16_t ipv6_network_order[8];\n\t\t\tfor (int i = 0; i < 8; ++i) ipv6_network_order[i] = htons(endpoint.u.ipv6[i]);\n\t\t\tinet_ntop(AF_INET6, (void*)ipv6_network_order, buffer, CN_ENDPOINT_STRING_MAX_LENGTH);\n\t\t} else {\n\t\t\tuint16_t ipv6_network_order[8];\n\t\t\tfor (int i = 0; i < 8; ++i) ipv6_network_order[i] = htons(endpoint.u.ipv6[i]);\n\t\t\tinet_ntop(AF_INET6, (void*)ipv6_network_order, buffer, INET6_ADDRSTRLEN);\n\t\t\tCN_SNPRINTF(buffer, CN_ENDPOINT_STRING_MAX_LENGTH, \"[%s]:%d\", buffer, endpoint.port);\n\t\t}\n\t} \n\telse \n#endif\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV4) {\n\t\tif (endpoint.port != 0) {\n\t\t\tCN_SNPRINTF(buffer, CN_ENDPOINT_STRING_MAX_LENGTH, \"%d.%d.%d.%d:%d\",\n\t\t\t\tendpoint.u.ipv4[0],\n\t\t\t\tendpoint.u.ipv4[1],\n\t\t\t\tendpoint.u.ipv4[2],\n\t\t\t\tendpoint.u.ipv4[3],\n\t\t\t\tendpoint.port);\n\t\t} else {\n\t\t\tCN_SNPRINTF(buffer, CN_ENDPOINT_STRING_MAX_LENGTH, \"%d.%d.%d.%d\",\n\t\t\t\tendpoint.u.ipv4[0],\n\t\t\t\tendpoint.u.ipv4[1],\n\t\t\t\tendpoint.u.ipv4[2],\n\t\t\t\tendpoint.u.ipv4[3]);\n\t\t}\n\t} else {\n\t\tCN_SNPRINTF(buffer, CN_ENDPOINT_STRING_MAX_LENGTH, \"%s\", \"INVALID ADDRESS\");\n\t}\n}\n\nint cn_endpoint_equals(cn_endpoint_t a, cn_endpoint_t b)\n{\n\tif (a.type != b.type) return 0;\n\tif (a.port != b.port) return 0;\n\n\tif (a.type == CN_ADDRESS_TYPE_IPV4) {\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tif (a.u.ipv4[i] != b.u.ipv4[i])\n\t\t\t\treturn 0;\n\t} \n#ifndef CUTE_NET_NO_IPV6\n\telse if (a.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tfor (int i = 0; i < 8; ++i)\n\t\t\tif (a.u.ipv6[i] != b.u.ipv6[i])\n\t\t\t\treturn 0;\n\t} \n#endif\n\telse {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n#ifdef CN_WINDOWS\n\ttypedef SOCKET cn_socket_cn_handle_t;\n#else\n\ttypedef int cn_socket_cn_handle_t;\n#endif\n\ntypedef struct cn_socket_t\n{\n\tcn_socket_cn_handle_t handle;\n\tcn_endpoint_t endpoint;\n} cn_socket_t;\n\nvoid cn_socket_cleanup(cn_socket_t* socket)\n{\n\tCN_ASSERT(socket);\n\n\tif (socket->handle != 0) {\n#if CN_WINDOWS\n\t\tclosesocket(socket->handle);\n#else\n\t\tclose(socket->handle);\n#endif\n\t\tsocket->handle = 0;\n\t}\n}\n\nstatic int s_socket_init(cn_socket_t* the_socket, cn_address_type_t address_type, int send_buffer_size, int receive_buffer_size)\n{\n#ifndef CUTE_NET_NO_IPV6\n\tint af = address_type == CN_ADDRESS_TYPE_IPV6 ? AF_INET6 : AF_INET;\n#else\n\tint af = AF_INET;\n#endif\n\tthe_socket->handle = socket(af, SOCK_DGRAM, IPPROTO_UDP);\n\n#ifdef CN_WINDOWS\n\tif (the_socket->handle == INVALID_SOCKET)\n#else\n\tif (the_socket->handle <= 0)\n#endif\n\t{\n\t\t//error_set(\"Failed to create socket.\");\n\t\treturn -1;\n\t}\n\n#ifndef CUTE_NET_NO_IPV6\n\t// Allow users to enforce ipv6 only.\n\t// See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms738574(v=vs.85).aspx\n\tif (address_type == CN_ADDRESS_TYPE_IPV6) {\n\t\tint enable = 1;\n\t\tif (setsockopt(the_socket->handle, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&enable, sizeof(enable)) != 0) {\n\t\t\t//error_set(\"Failed to strictly set socket only ipv6.\");\n\t\t\tcn_socket_cleanup(the_socket);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n\t// Increase socket send buffer size.\n\tif (setsockopt(the_socket->handle, SOL_SOCKET, SO_SNDBUF, (char*)&send_buffer_size, sizeof(int)) != 0) {\n\t\t//error_set(\"Failed to set socket send buffer size.\");\n\t\tcn_socket_cleanup(the_socket);\n\t\treturn -1;\n\t}\n\n\t// Increase socket receive buffer size.\n\tif (setsockopt(the_socket->handle, SOL_SOCKET, SO_RCVBUF, (char*)&receive_buffer_size, sizeof(int)) != 0) {\n\t\t//error_set(\"Failed to set socket receive buffer size.\");\n\t\tcn_socket_cleanup(the_socket);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int s_socket_bind_port_and_set_non_blocking(cn_socket_t* the_socket, cn_address_type_t address_type, uint16_t port)\n{\n\t// Binding to port zero means \"any port\", so record which one was bound.\n\tif (port == 0)\n\t{\n#ifndef CUTE_NET_NO_IPV6\n\t\tif (address_type == CN_ADDRESS_TYPE_IPV6) {\n\t\t\tstruct sockaddr_in6 sin;\n\t\t\tsocklen_t len = sizeof(sin);\n\t\t\tif (getsockname(the_socket->handle, (struct sockaddr*)&sin, &len) == -1) {\n\t\t\t\t//error_set(\"Failed to get ipv6 socket's assigned port number when binding to port 0.\");\n\t\t\t\tcn_socket_cleanup(the_socket);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthe_socket->endpoint.port = ntohs(sin.sin6_port);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsocklen_t len = sizeof(sin);\n\t\t\tif (getsockname(the_socket->handle, (struct sockaddr*)&sin, &len) == -1) {\n\t\t\t\t//error_set(\"Failed to get ipv4 socket's assigned port number when binding to port 0.\");\n\t\t\t\tcn_socket_cleanup(the_socket);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthe_socket->endpoint.port = ntohs(sin.sin_port);\n\t\t}\n\t}\n\n\t// Set non-blocking io.\n#ifdef CN_WINDOWS\n\n\tDWORD non_blocking = 1;\n\tif (ioctlsocket(the_socket->handle, FIONBIO, &non_blocking) != 0) {\n\t\t//error_set(\"Failed to set socket to non blocking io.\");\n\t\tcn_socket_cleanup(the_socket);\n\t\treturn -1;\n\t}\n\n#else\n\n\tint non_blocking = 1;\n\tif (fcntl(the_socket->handle, F_SETFL, O_NONBLOCK, non_blocking) == -1)\n\t{\n\t\t//error_set(\"Failed to set socket to non blocking io.\");\n\t\tcn_socket_cleanup(the_socket);\n\t\treturn -1;\n\t}\n\n#endif\n\n\treturn 0;\n}\n\nint cn_socket_init1(cn_socket_t* the_socket, cn_address_type_t address_type, uint16_t port, int send_buffer_size, int receive_buffer_size)\n{\n\tCN_MEMSET(&the_socket->endpoint, 0, sizeof(cn_endpoint_t));\n\tthe_socket->endpoint.type = address_type;\n\tthe_socket->endpoint.port = port;\n\n\tif (s_socket_init(the_socket, address_type, send_buffer_size, receive_buffer_size)) {\n\t\treturn -1;\n\t}\n\n\t// Bind port.\n#ifndef CUTE_NET_NO_IPV6\n\tif (address_type == CN_ADDRESS_TYPE_IPV6) {\n\t\tstruct sockaddr_in6 socket_endpoint;\n\t\tCN_MEMSET(&socket_endpoint, 0, sizeof(struct sockaddr_in6));\n\t\tsocket_endpoint.sin6_family = AF_INET6;\n\t\tsocket_endpoint.sin6_addr = in6addr_any;\n\t\tsocket_endpoint.sin6_port = htons(port);\n\n\t\tif (bind(the_socket->handle, (struct sockaddr*)&socket_endpoint, sizeof(socket_endpoint)) < 0) {\n\t\t\t//error_set(\"Failed to bind ipv6 socket.\");\n\t\t\tcn_socket_cleanup(the_socket);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in socket_endpoint;\n\t\tCN_MEMSET(&socket_endpoint, 0, sizeof(socket_endpoint));\n\t\tsocket_endpoint.sin_family = AF_INET;\n\t\tsocket_endpoint.sin_addr.s_addr = INADDR_ANY;\n\t\tsocket_endpoint.sin_port = htons(port);\n\n\t\tif (bind(the_socket->handle, (struct sockaddr*)&socket_endpoint, sizeof(socket_endpoint)) < 0) {\n\t\t\t//error_set(\"Failed to bind ipv4 socket.\");\n\t\t\tcn_socket_cleanup(the_socket);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (s_socket_bind_port_and_set_non_blocking(the_socket, address_type, port)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint cn_socket_init2(cn_socket_t* the_socket, const char* address_and_port, int send_buffer_size, int receive_buffer_size)\n{\n\tcn_endpoint_t endpoint;\n\tif (cn_endpoint_init(&endpoint, address_and_port)) {\n\t\treturn -1;\n\t}\n\n\tthe_socket->endpoint = endpoint;\n\n\tif (s_socket_init(the_socket, endpoint.type, send_buffer_size, receive_buffer_size)) {\n\t\treturn -1;\n\t}\n\n\t// Bind port.\n#ifndef CUTE_NET_NO_IPV6\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tstruct sockaddr_in6 socket_endpoint;\n\t\tCN_MEMSET(&socket_endpoint, 0, sizeof(struct sockaddr_in6));\n\t\tsocket_endpoint.sin6_family = AF_INET6;\n\t\tfor (int i = 0; i < 8; ++i) ((uint16_t*)&socket_endpoint.sin6_addr) [i] = htons(endpoint.u.ipv6[i]);\n\t\tsocket_endpoint.sin6_port = htons(endpoint.port);\n\n\t\tif (bind(the_socket->handle, (struct sockaddr*)&socket_endpoint, sizeof(socket_endpoint)) < 0)\n\t\t{\n\t\t\t//error_set(\"Failed to bind ipv6 socket.\");\n\t\t\tcn_socket_cleanup(the_socket);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in socket_endpoint;\n\t\tCN_MEMSET(&socket_endpoint, 0, sizeof(socket_endpoint));\n\t\tsocket_endpoint.sin_family = AF_INET;\n\t\tsocket_endpoint.sin_addr.s_addr = (((uint32_t) endpoint.u.ipv4[0]))       |\n\t\t                                  (((uint32_t) endpoint.u.ipv4[1]) << 8)  |\n\t\t                                  (((uint32_t) endpoint.u.ipv4[2]) << 16) |\n\t\t                                  (((uint32_t) endpoint.u.ipv4[3]) << 24);\n\t\tsocket_endpoint.sin_port = htons(endpoint.port);\n\n\t\tif (bind(the_socket->handle, (struct sockaddr*)&socket_endpoint, sizeof(socket_endpoint)) < 0) {\n\t\t\t//error_set(\"Failed to bind ipv4 socket.\");\n\t\t\tcn_socket_cleanup(the_socket);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (s_socket_bind_port_and_set_non_blocking(the_socket, endpoint.type, endpoint.port)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint cn_socket_send_internal(cn_socket_t* socket, cn_endpoint_t send_to, const void* data, int byte_count)\n{\n\tcn_endpoint_t endpoint = send_to;\n\tCN_ASSERT(data);\n\tCN_ASSERT(byte_count >= 0);\n\tCN_ASSERT(socket->handle != 0);\n\tCN_ASSERT(endpoint.type != CN_ADDRESS_TYPE_NONE);\n\n#ifndef CUTE_NET_NO_IPV6\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV6) {\n\t\tstruct sockaddr_in6 socket_address;\n\t\tCN_MEMSET(&socket_address, 0, sizeof(socket_address));\n\t\tsocket_address.sin6_family = AF_INET6;\n\t\tint i;\n\t\tfor (i = 0; i < 8; ++i)\n\t\t{\n\t\t\t((uint16_t*) &socket_address.sin6_addr) [i] = htons(endpoint.u.ipv6[i]);\n\t\t}\n\t\tsocket_address.sin6_port = htons(endpoint.port);\n\t\tint result = sendto(socket->handle, (const char*)data, byte_count, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t\treturn result;\n\t}\n\telse \n#endif\n\tif (endpoint.type == CN_ADDRESS_TYPE_IPV4) {\n\t\tstruct sockaddr_in socket_address;\n\t\tCN_MEMSET(&socket_address, 0, sizeof(socket_address));\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_addr.s_addr = (((uint32_t)endpoint.u.ipv4[0]))        |\n\t\t                                 (((uint32_t)endpoint.u.ipv4[1]) << 8)   |\n\t\t                                 (((uint32_t)endpoint.u.ipv4[2]) << 16)  |\n\t\t                                 (((uint32_t)endpoint.u.ipv4[3]) << 24);\n\t\tsocket_address.sin_port = htons(endpoint.port);\n\t\tint result = sendto(socket->handle, (const char*)data, byte_count, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t\treturn result;\n\t}\n\n\treturn -1;\n}\n\nint cn_socket_receive(cn_socket_t* the_socket, cn_endpoint_t* from, void* data, int byte_count)\n{\n\tCN_ASSERT(the_socket);\n\tCN_ASSERT(the_socket->handle != 0);\n\tCN_ASSERT(from);\n\tCN_ASSERT(data);\n\tCN_ASSERT(byte_count >= 0);\n\n#ifdef CN_WINDOWS\n\ttypedef int socklen_t;\n#endif\n\n\tCN_MEMSET(from, 0, sizeof(*from));\n\n\tstruct sockaddr_storage sockaddr_from;\n\tsocklen_t from_length = sizeof(sockaddr_from);\n\tint result = recvfrom(the_socket->handle, (char*)data, byte_count, 0, (struct sockaddr*)&sockaddr_from, &from_length);\n\n#ifdef CN_WINDOWS\n\tif (result == SOCKET_ERROR) {\n\t\tint error = WSAGetLastError();\n\t\tif (error == WSAEWOULDBLOCK || error == WSAECONNRESET) return 0;\n\t\t//error_set(\"The function recvfrom failed.\");\n\t\treturn -1;\n\t}\n#else\n\tif (result <= 0) {\n\t\tif (errno == EAGAIN) return 0;\n\t\t//error_set(\"The function recvfrom failed.\");\n\t\treturn -1;\n\t}\n#endif\n\n#ifndef CUTE_NET_NO_IPV6\n\tif (sockaddr_from.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6* addr_ipv6 = (struct sockaddr_in6*) &sockaddr_from;\n\t\tfrom->type = CN_ADDRESS_TYPE_IPV6;\n\t\tint i;\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tfrom->u.ipv6[i] = ntohs(((uint16_t*) &addr_ipv6->sin6_addr) [i]);\n\t\t}\n\t\tfrom->port = ntohs(addr_ipv6->sin6_port);\n\t}\n\telse\n#endif\n\tif (sockaddr_from.ss_family == AF_INET) {\n\t\tstruct sockaddr_in* addr_ipv4 = (struct sockaddr_in*) &sockaddr_from;\n\t\tfrom->type = CN_ADDRESS_TYPE_IPV4;\n\t\tfrom->u.ipv4[0] = (uint8_t)((addr_ipv4->sin_addr.s_addr & 0x000000FF));\n\t\tfrom->u.ipv4[1] = (uint8_t)((addr_ipv4->sin_addr.s_addr & 0x0000FF00) >> 8);\n\t\tfrom->u.ipv4[2] = (uint8_t)((addr_ipv4->sin_addr.s_addr & 0x00FF0000) >> 16);\n\t\tfrom->u.ipv4[3] = (uint8_t)((addr_ipv4->sin_addr.s_addr & 0xFF000000) >> 24);\n\t\tfrom->port = ntohs(addr_ipv4->sin_port);\n\t} else {\n\t\tCN_ASSERT(0);\n\t\t//error_set(\"The function recvfrom returned an invalid ip format.\");\n\t\treturn -1;\n\t}\n\n\tCN_ASSERT(result >= 0);\n\tint bytes_read = result;\n\treturn bytes_read;\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_simulator_t cn_simulator_t;\n\nstruct cn_protocol_client_t\n{\n\tbool use_ipv6;\n\tuint16_t port;\n\tcn_protocol_client_state_t state;\n\tdouble last_packet_recieved_time;\n\tdouble last_packet_sent_time;\n\tuint64_t application_id;\n\tuint64_t current_time;\n\tuint64_t client_id;\n\tint max_clients;\n\tdouble connection_timeout;\n\tint has_sent_disconnect_packets;\n\tcn_protocol_connect_token_t connect_token;\n\tuint64_t challenge_nonce;\n\tuint8_t challenge_data[CN_PROTOCOL_CHALLENGE_DATA_SIZE];\n\tint goto_next_server;\n\tcn_protocol_client_state_t goto_next_server_tentative_state;\n\tint server_endpoint_index;\n\tcn_endpoint_t web_service_endpoint;\n\tcn_socket_t socket;\n\tuint64_t sequence;\n\tcn_circular_buffer_t packet_queue;\n\tcn_protocol_replay_buffer_t replay_buffer;\n\tcn_simulator_t* sim;\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\tuint8_t connect_token_packet[CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE];\n\tvoid* mem_ctx;\n};\n\n// -------------------------------------------------------------------------------------------------\n\nstruct cn_protocol_server_t\n{\n\tbool running;\n\tuint64_t application_id;\n\tuint64_t current_time;\n\tbool use_developer_mode_public_ip;\n\tcn_endpoint_t developer_mode_public_ip;\n\tcn_socket_t socket;\n\tcn_protocol_packet_allocator_t* packet_allocator;\n\tcn_crypto_sign_public_t public_key;\n\tcn_crypto_sign_secret_t secret_key;\n\tuint32_t connection_timeout;\n\tcn_circular_buffer_t event_queue;\n\tcn_simulator_t* sim;\n\n\tuint64_t challenge_nonce;\n\tcn_protocol_encryption_map_t encryption_map;\n\tcn_protocol_connect_token_cache_t token_cache;\n\n\tint client_count;\n\tcn_hashtable_t client_endpoint_table;\n\tcn_hashtable_t client_id_table;\n\tuint64_t client_id[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tbool client_is_connected[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tbool client_is_confirmed[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tdouble client_last_packet_received_time[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tdouble client_last_packet_sent_time[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tcn_endpoint_t client_endpoint[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tuint64_t client_sequence[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tcn_crypto_key_t client_client_to_server_key[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tcn_crypto_key_t client_server_to_client_key[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\tcn_protocol_replay_buffer_t client_replay_buffer[CN_PROTOCOL_SERVER_MAX_CLIENTS];\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\tvoid* mem_ctx;\n};\n\n// -------------------------------------------------------------------------------------------------\n\n#include <inttypes.h>\n\nstatic uint8_t s_crypto_ctx[] = \"CUTE_CTX\";\n#define CN_CHECK(X) if (X) ret = -1;\n#define CN_CRYPTO_CONTEXT (const char*)s_crypto_ctx\n\nstatic bool s_cn_is_init = false;\n\ncn_result_t cn_crypto_init()\n{\n\tif (hydro_init() != 0) {\n\t\treturn cn_error_failure(\"Unable to initialize crypto library. It is *not safe* to connect to the net.\");\n\t}\n\treturn cn_error_success();\n}\n\ncn_result_t cn_init()\n{\n#ifdef CN_WINDOWS\n\tWSADATA wsa_data;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsa_data) != NO_ERROR) {\n\t\treturn cn_error_failure(\"Unable to initialize WSA.\");\n\t}\n#else\n#endif\n\treturn cn_crypto_init();\n}\n\nCN_INLINE cn_result_t s_cn_init_check()\n{\n\tif (!s_cn_is_init) {\n\t\tif (cn_is_error(cn_init())) {\n\t\t\treturn cn_error_failure(\"Unable to initialization Cute Net.\");\n\t\t} else {\n\t\t\ts_cn_is_init = true;\n\t\t}\n\t}\n\treturn cn_error_success();\n}\n\nvoid cn_crypto_encrypt(const cn_crypto_key_t* key, uint8_t* data, int data_size, uint64_t msg_id)\n{\n\thydro_secretbox_encrypt(data, data, (uint64_t)data_size, msg_id, CN_CRYPTO_CONTEXT, key->key);\n}\n\ncn_result_t cn_crypto_decrypt(const cn_crypto_key_t* key, uint8_t* data, int data_size, uint64_t msg_id)\n{\n\tif (hydro_secretbox_decrypt(data, data, (size_t)data_size, msg_id, CN_CRYPTO_CONTEXT, key->key) != 0) {\n\t\treturn cn_error_failure(\"Message forged.\");\n\t} else {\n\t\treturn cn_error_success();\n\t}\n}\n\ncn_crypto_key_t cn_crypto_generate_key()\n{\n\ts_cn_init_check();\n\tcn_crypto_key_t key;\n\thydro_secretbox_keygen(key.key);\n\treturn key;\n}\n\nvoid cn_crypto_random_bytes(void* data, int byte_count)\n{\n\ts_cn_init_check();\n\thydro_random_buf(data, byte_count);\n}\n\nvoid cn_crypto_sign_keygen(cn_crypto_sign_public_t* public_key, cn_crypto_sign_secret_t* secret_key)\n{\n\ts_cn_init_check();\n\thydro_sign_keypair key_pair;\n\thydro_sign_keygen(&key_pair);\n\tCN_MEMCPY(public_key->key, key_pair.pk, 32);\n\tCN_MEMCPY(secret_key->key, key_pair.sk, 64);\n}\n\nvoid cn_crypto_sign_create(const cn_crypto_sign_secret_t* secret_key, cn_crypto_signature_t* signature, const uint8_t* data, int data_size)\n{\n\thydro_sign_create(signature->bytes, data, (size_t)data_size, CN_CRYPTO_CONTEXT, secret_key->key);\n}\n\ncn_result_t cn_crypto_sign_verify(const cn_crypto_sign_public_t* public_key, const cn_crypto_signature_t* signature, const uint8_t* data, int data_size)\n{\n\tif (hydro_sign_verify(signature->bytes, data, (size_t)data_size, CN_CRYPTO_CONTEXT, public_key->key) != 0) {\n\t\treturn cn_error_failure(\"Message forged.\");\n\t} else {\n\t\treturn cn_error_success();\n\t}\n}\n\nvoid cn_cleanup()\n{\n#ifdef CN_WINDOWS\n\tWSACleanup();\n#endif\n}\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_PROTOCOL_NET_SIMULATOR_MAX_PACKETS (1024 * 5)\n\ntypedef struct cn_rnd_t\n{\n\tuint64_t state[2];\n} cn_rnd_t;\n\nstatic uint64_t cn_rnd_murmur3_avalanche64(uint64_t h)\n{\n\th ^= h >> 33;\n\th *= 0xff51afd7ed558ccd;\n\th ^= h >> 33;\n\th *= 0xc4ceb9fe1a85ec53;\n\th ^= h >> 33;\n\treturn h;\n}\n\nstatic cn_rnd_t cn_rnd_seed(uint64_t seed)\n{\n\tcn_rnd_t rnd;\n\tuint64_t value = cn_rnd_murmur3_avalanche64((seed << 1ULL) | 1ULL);\n\trnd.state[0] = value;\n\trnd.state[1] = cn_rnd_murmur3_avalanche64(value);\n\treturn rnd;\n}\n\nstatic uint64_t cn_rnd_next(cn_rnd_t* rnd)\n{\n\tuint64_t x = rnd->state[0];\n\tuint64_t y = rnd->state[1];\n\trnd->state[0] = y;\n\tx ^= x << 23;\n\tx ^= x >> 17;\n\tx ^= y ^ (y >> 26);\n\trnd->state[1] = x;\n\treturn x + y;\n}\n\nstatic double cn_rnd_next_double(cn_rnd_t* rnd)\n{\n\tuint64_t value = cn_rnd_next(rnd);\n\tuint64_t exponent = 1023;\n\tuint64_t mantissa = value >> 12;\n\tuint64_t result = (exponent << 52) | mantissa;\n\treturn *(double*)&result - 1.0;\n}\n\ntypedef struct cn_simulator_packet_t\n{\n\tdouble delay;\n\tcn_endpoint_t to;\n\tvoid* data;\n\tint size;\n} cn_simulator_packet_t;\n\nstruct cn_simulator_t\n{\n\tcn_socket_t* socket;\n\tdouble latency;\n\tdouble jitter;\n\tdouble drop_chance;\n\tdouble duplicate_chance;\n\tcn_rnd_t rnd;\n\tint index;\n\tvoid* mem_ctx;\n\tcn_simulator_packet_t packets[CN_PROTOCOL_NET_SIMULATOR_MAX_PACKETS];\n};\n\ncn_simulator_t* cn_simulator_create(cn_socket_t* socket, void* mem_ctx)\n{\n\tcn_simulator_t* sim = (cn_simulator_t*)CN_ALLOC(sizeof(cn_simulator_t), mem_ctx);\n\tCN_MEMSET(sim, 0, sizeof(*sim));\n\tsim->socket = socket;\n\tsim->rnd = cn_rnd_seed(0);\n\tsim->mem_ctx = mem_ctx;\n\treturn sim;\n}\n\nvoid cn_simulator_destroy(cn_simulator_t* sim)\n{\n\tif (!sim) return;\n\tfor (int i = 0; i < CN_PROTOCOL_NET_SIMULATOR_MAX_PACKETS; ++i) {\n\t\tcn_simulator_packet_t* p = sim->packets + i;\n\t\tif (p->data) CN_FREE(p->data, sim->mem_ctx);\n\t}\n\tCN_FREE(sim, sim->mem_ctx);\n}\n\nvoid cn_simulator_add(cn_simulator_t* sim, cn_endpoint_t to, const void* packet, int size)\n{\n\tbool drop = cn_rnd_next_double(&sim->rnd) < sim->drop_chance;\n\tif (drop) return;\n\n\tint index = sim->index++ % CN_PROTOCOL_NET_SIMULATOR_MAX_PACKETS;\n\tcn_simulator_packet_t* p = sim->packets + index;\n\tif (p->data) CN_FREE(p->data, sim->mem_ctx);\n\tp->delay = sim->latency + cn_rnd_next_double(&sim->rnd) * sim->jitter;\n\tp->to = to;\n\tp->data = CN_ALLOC(size, sim->mem_ctx);\n\tp->size = size;\n\tCN_MEMCPY(p->data, packet, size);\n}\n\nvoid cn_simulator_update(cn_simulator_t* sim, double dt)\n{\n\tif (!sim) return;\n\tfor (int i = 0; i < CN_PROTOCOL_NET_SIMULATOR_MAX_PACKETS; ++i) {\n\t\tcn_simulator_packet_t* p = sim->packets + i;\n\t\tif (p->data) {\n\t\t\tp->delay -= dt;\n\t\t\tif (p->delay < 0) {\n\t\t\t\tcn_socket_send_internal(sim->socket, p->to, p->data, p->size);\n\t\t\t\tbool duplicate = cn_rnd_next_double(&sim->rnd) < sim->duplicate_chance;\n\t\t\t\tif (!duplicate) {\n\t\t\t\t\tCN_FREE(p->data, sim->mem_ctx);\n\t\t\t\t\tp->data = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tp->delay = cn_rnd_next_double(&sim->rnd) * sim->jitter;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint cn_socket_send(cn_socket_t* socket, cn_simulator_t* sim, cn_endpoint_t to, const void* data, int size)\n{\n\tif (sim) {\n\t\tcn_simulator_add(sim, to, data, size);\n\t\treturn size;\n\t} else {\n\t\treturn cn_socket_send_internal(socket, to, data, size);\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\ncn_result_t cn_generate_connect_token(\n\tuint64_t application_id,\n\tuint64_t creation_timestamp,\n\tconst cn_crypto_key_t* client_to_server_key,\n\tconst cn_crypto_key_t* server_to_client_key,\n\tuint64_t expiration_timestamp,\n\tuint32_t handshake_timeout,\n\tint address_count,\n\tconst char** address_list,\n\tuint64_t client_id,\n\tconst uint8_t* user_data,\n\tconst cn_crypto_sign_secret_t* shared_secret_key,\n\tuint8_t* token_ptr_out\n)\n{\n\tcn_result_t result = s_cn_init_check();\n\tif (cn_is_error(result)) return result;\n\n\tCN_ASSERT(address_count >= 1 && address_count <= 32);\n\tCN_ASSERT(creation_timestamp < expiration_timestamp);\n\n\tuint8_t** p = &token_ptr_out;\n\n\t// Write the REST SECTION.\n\tcn_write_bytes(p, CN_PROTOCOL_VERSION_STRING, CN_PROTOCOL_VERSION_STRING_LEN);\n\tcn_write_uint64(p, application_id);\n\tcn_write_uint64(p, creation_timestamp);\n\tcn_write_key(p, client_to_server_key);\n\tcn_write_key(p, server_to_client_key);\n\n\t// Write the PUBLIC SECTION.\n\tuint8_t* public_section = *p;\n\tcn_write_uint8(p, 0);\n\tcn_write_bytes(p, CN_PROTOCOL_VERSION_STRING, CN_PROTOCOL_VERSION_STRING_LEN);\n\tcn_write_uint64(p, application_id);\n\tcn_write_uint64(p, expiration_timestamp);\n\tcn_write_uint32(p, handshake_timeout);\n\tcn_write_uint32(p, (uint32_t)address_count);\n\tfor (int i = 0; i < address_count; ++i) {\n\t\tcn_endpoint_t endpoint;\n\t\tif (cn_endpoint_init(&endpoint, address_list[i])) return cn_error_failure(\"Unable to initialize endpoint.\");\n\t\tcn_write_endpoint(p, endpoint);\n\t}\n\n\tint bytes_written = (int)(*p - public_section);\n\tCN_ASSERT(bytes_written <= 568);\n\tint zeroes = 568 - bytes_written;\n\tfor (int i = 0; i < zeroes; ++i)\n\t\tcn_write_uint8(p, 0);\n\n\tbytes_written = (int)(*p - public_section);\n\tCN_ASSERT(bytes_written == 568);\n\n\t// Write the SECRET SECTION.\n\tuint8_t* secret_section = *p;\n\tCN_MEMSET(*p, 0, CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES);\n\t*p += CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES;\n\tcn_write_uint64(p, client_id);\n\tcn_write_key(p, client_to_server_key);\n\tcn_write_key(p, server_to_client_key);\n\tif (user_data) {\n\t\tCN_MEMCPY(*p, user_data, CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE);\n\t} else {\n\t\tCN_MEMSET(*p, 0, CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE);\n\t}\n\t*p += CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE;\n\n\t// Encrypt the SECRET SECTION.\n\tcn_crypto_encrypt((const cn_crypto_key_t*)shared_secret_key, secret_section, CN_PROTOCOL_CONNECT_TOKEN_SECRET_SECTION_SIZE - CN_CRYPTO_HEADER_BYTES, 0);\n\t*p += CN_CRYPTO_HEADER_BYTES;\n\n\t// Compute the signature.\n\tcn_crypto_signature_t signature;\n\tcn_crypto_sign_create(shared_secret_key, &signature, public_section, 1024 - CN_PROTOCOL_SIGNATURE_SIZE);\n\n\t// Write the signature.\n\tCN_MEMCPY(*p, signature.bytes, sizeof(signature));\n\t*p += sizeof(signature);\n\tbytes_written = (int)(*p - public_section);\n\tCN_ASSERT(bytes_written == CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE);\n\n\treturn cn_error_success();\n}\n\n// -------------------------------------------------------------------------------------------------\n\nvoid cn_protocol_replay_buffer_init(cn_protocol_replay_buffer_t* replay_buffer)\n{\n\treplay_buffer->max = 0;\n\tCN_MEMSET(replay_buffer->entries, ~0, sizeof(uint64_t) * CN_PROTOCOL_REPLAY_BUFFER_SIZE);\n}\n\nint cn_protocol_replay_buffer_cull_duplicate(cn_protocol_replay_buffer_t* replay_buffer, uint64_t sequence)\n{\n\tif (sequence + CN_PROTOCOL_REPLAY_BUFFER_SIZE < replay_buffer->max) {\n\t\t// This is UDP - just drop old packets.\n\t\treturn -1;\n\t}\n\n\tint index = (int)(sequence % CN_PROTOCOL_REPLAY_BUFFER_SIZE);\n\tuint64_t val = replay_buffer->entries[index];\n\tint empty_slot = val == ~0ULL;\n\tint outdated = val >= sequence;\n\tif (empty_slot | !outdated) {\n\t\treturn 0;\n\t} else {\n\t\t// Duplicate or replayed packet detected.\n\t\treturn -1;\n\t}\n}\n\nvoid cn_protocol_replay_buffer_update(cn_protocol_replay_buffer_t* replay_buffer, uint64_t sequence)\n{\n\tif (replay_buffer->max < sequence) {\n\t\treplay_buffer->max = sequence;\n\t}\n\n\tint index = (int)(sequence % CN_PROTOCOL_REPLAY_BUFFER_SIZE);\n\tuint64_t val = replay_buffer->entries[index];\n\tint empty_slot = val == ~0ULL;\n\tint outdated = val >= sequence;\n\tif (empty_slot | !outdated) {\n\t\treplay_buffer->entries[index] = sequence;\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_memory_pool_t\n{\n\tint element_size;\n\tint arena_size;\n\tuint8_t* arena;\n\tvoid* free_list;\n\tint overflow_count;\n\tvoid* mem_ctx;\n} cn_memory_pool_t;\n\ncn_memory_pool_t* cn_memory_pool_create(int element_size, int element_count, void* user_allocator_context)\n{\n\tsize_t stride = (size_t)element_size > sizeof(void*) ? element_size : sizeof(void*);\n\tsize_t arena_size = sizeof(cn_memory_pool_t) + stride * element_count;\n\tcn_memory_pool_t* pool = (cn_memory_pool_t*)CN_ALLOC(arena_size, user_allocator_context);\n\n\tpool->element_size = element_size;\n\tpool->arena_size = (int)(arena_size - sizeof(cn_memory_pool_t));\n\tpool->arena = (uint8_t*)(pool + 1);\n\tpool->free_list = pool->arena;\n\tpool->overflow_count = 0;\n\n\tfor (int i = 0; i < element_count - 1; ++i)\n\t{\n\t\tvoid** element = (void**)(pool->arena + stride * i);\n\t\tvoid* next = (void*)(pool->arena + stride * (i + 1));\n\t\t*element = next;\n\t};\n\n\tvoid** last_element = (void**)(pool->arena + stride * (element_count - 1));\n\t*last_element = NULL;\n\n\treturn pool;\n}\n\nvoid cn_memory_pool_destroy(cn_memory_pool_t* pool)\n{\n\tif (pool->overflow_count) {\n\t\t// Attempted to destroy pool without freeing all overflow allocations.\n\t\tCN_ASSERT(pool->overflow_count == 0);\n\t}\n\tCN_FREE(pool, pool->mem_ctx);\n}\n\nvoid* cn_memory_pool_try_alloc(cn_memory_pool_t* pool)\n{\n\tif (pool->free_list) {\n\t\tvoid *mem = pool->free_list;\n\t\tpool->free_list = *((void**)pool->free_list);\n\t\treturn mem;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nvoid* cn_memory_pool_alloc(cn_memory_pool_t* pool)\n{\n\tvoid *mem = cn_memory_pool_try_alloc(pool);\n\tif (!mem) {\n\t\tmem = CN_ALLOC(pool->element_size, pool->mem_ctx);\n\t\tif (mem) {\n\t\t\tpool->overflow_count++;\n\t\t}\n\t}\n\treturn mem;\n}\n\nvoid cn_memory_pool_free(cn_memory_pool_t* pool, void* element)\n{\n\tint difference = (int)((uint8_t*)element - pool->arena);\n\tint in_bounds = difference < pool->arena_size;\n\tif (pool->overflow_count && !in_bounds) {\n\t\tCN_FREE(element, pool->mem_ctx);\n\t\tpool->overflow_count--;\n\t} else if (in_bounds) {\n\t\t*(void**)element = pool->free_list;\n\t\tpool->free_list = element;\n\t} else {\n\t\t// Pointer was outside of arena bounds, or a double free was detected.\n\t\tCN_ASSERT(0);\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\nstatic int s_packet_size(cn_protocol_packet_type_t type)\n{\n\tint size = 0;\n\n\tswitch (type)\n\t{\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN:\n\t\tsize = sizeof(cn_protocol_packet_connect_token_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED:\n\t\tsize = sizeof(cn_protocol_packet_connection_accepted_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED:\n\t\tsize = sizeof(cn_protocol_packet_connection_denied_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE:\n\t\tsize = sizeof(cn_protocol_packet_keepalive_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT:\n\t\tsize = sizeof(cn_protocol_packet_disconnect_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST: // fall-thru\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE:\n\t\tsize = sizeof(cn_protocol_packet_challenge_t);\n\t\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD:\n\t\tsize = sizeof(cn_protocol_packet_payload_t);\n\t\tbreak;\n\n\tdefault:\n\t\tsize = -1;\n\t\tCN_ASSERT(false);\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstruct cn_protocol_packet_allocator_t\n{\n\tcn_memory_pool_t* pools[CN_PROTOCOL_PACKET_TYPE_COUNT];\n\tvoid* user_allocator_context;\n};\n\ncn_protocol_packet_allocator_t* cn_protocol_packet_allocator_create(void* user_allocator_context)\n{\n\tcn_protocol_packet_allocator_t* packet_allocator = (cn_protocol_packet_allocator_t*)CN_ALLOC(sizeof(cn_protocol_packet_allocator_t), user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_KEEPALIVE] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_KEEPALIVE), 1024, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_DISCONNECT] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_DISCONNECT), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE), 256, user_allocator_context);\n\tpacket_allocator->pools[CN_PROTOCOL_PACKET_TYPE_PAYLOAD] = cn_memory_pool_create(s_packet_size(CN_PROTOCOL_PACKET_TYPE_PAYLOAD), 1024 * 10, user_allocator_context);\n\tpacket_allocator->user_allocator_context = user_allocator_context;\n\treturn packet_allocator;\n}\n\nvoid cn_protocol_packet_allocator_destroy(cn_protocol_packet_allocator_t* packet_allocator)\n{\n\tfor (int i = 0; i < CN_PROTOCOL_PACKET_TYPE_COUNT; ++i) {\n\t\tcn_memory_pool_destroy(packet_allocator->pools[i]);\n\t}\n\tCN_FREE(packet_allocator, packet_allocator->user_allocator_context);\n}\n\nvoid* cn_protocol_packet_allocator_alloc(cn_protocol_packet_allocator_t* packet_allocator, cn_protocol_packet_type_t type)\n{\n\tif (!packet_allocator) {\n\t\treturn CN_ALLOC(s_packet_size(type), NULL);\n\t} else {\n\t\tvoid* packet = cn_memory_pool_alloc(packet_allocator->pools[type]);\n\t\treturn packet;\n\t}\n}\n\nvoid cn_protocol_packet_allocator_free(cn_protocol_packet_allocator_t* packet_allocator, cn_protocol_packet_type_t type, void* packet)\n{\n\tif (!packet_allocator) {\n\t\tCN_FREE(packet, NULL);\n\t} else {\n\t\tcn_memory_pool_free(packet_allocator->pools[type], packet);\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\ncn_result_t cn_protocol_read_connect_token_packet_public_section(uint8_t* buffer, uint64_t application_id, uint64_t current_time, cn_protocol_packet_connect_token_t* packet)\n{\n\tuint8_t* buffer_start = buffer;\n\n\t// Read public section.\n\tpacket->packet_type = (cn_protocol_packet_type_t)cn_read_uint8(&buffer);\n\tif (packet->packet_type != CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN) return cn_error_failure(\"Expected packet type to be CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN.\");\n\tif (CN_STRNCMP((const char*)buffer, (const char*)CN_PROTOCOL_VERSION_STRING, CN_PROTOCOL_VERSION_STRING_LEN)) {\n\t\treturn cn_error_failure(\"Unable to find `CN_PROTOCOL_VERSION_STRING` string.\");\n\t}\n\tbuffer += CN_PROTOCOL_VERSION_STRING_LEN;\n\tif (cn_read_uint64(&buffer) != application_id) return cn_error_failure(\"Found invalid application id.\");\n\tpacket->expiration_timestamp = cn_read_uint64(&buffer);\n\tif (packet->expiration_timestamp < current_time) return cn_error_failure(\"Packet has expired.\");\n\tpacket->handshake_timeout = cn_read_uint32(&buffer);\n\tpacket->endpoint_count = cn_read_uint32(&buffer);\n\tint count = (int)packet->endpoint_count;\n\tif (count <= 0 || count > 32) return cn_error_failure(\"Invalid endpoint count.\");\n\tfor (int i = 0; i < count; ++i)\n\t\tpacket->endpoints[i] = cn_read_endpoint(&buffer);\n\tint bytes_read = (int)(buffer - buffer_start);\n\tCN_ASSERT(bytes_read <= 568);\n\tbuffer += 568 - bytes_read;\n\tbytes_read = (int)(buffer - buffer_start);\n\tCN_ASSERT(bytes_read == 568);\n\n\treturn cn_error_success();\n}\n\nstatic uint8_t* s_protocol_header(uint8_t** p, uint8_t type, uint64_t sequence)\n{\n\tcn_write_uint8(p, type);\n\tcn_write_uint64(p, sequence);\n\tCN_MEMSET(*p, 0, CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES);\n\t*p += CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES;\n\treturn *p;\n}\n\nint cn_protocol_packet_write(void* packet_ptr, uint8_t* buffer, uint64_t sequence, const cn_crypto_key_t* key)\n{\n\tuint8_t type = *(uint8_t*)packet_ptr;\n\n\tif (type == CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN) {\n\t\tCN_MEMCPY(buffer, packet_ptr, CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE);\n\t\treturn CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE;\n\t}\n\n\tuint8_t* buffer_start = buffer;\n\tuint8_t* payload = s_protocol_header(&buffer, type, sequence);\n\tint payload_size = 0;\n\n\tswitch (type)\n\t{\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED:\n\t{\n\t\tcn_protocol_packet_connection_accepted_t* packet = (cn_protocol_packet_connection_accepted_t*)packet_ptr;\n\t\tcn_write_uint64(&buffer, packet->client_id);\n\t\tcn_write_uint32(&buffer, packet->max_clients);\n\t\tcn_write_uint32(&buffer, packet->connection_timeout);\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 8 + 4 + 4);\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED:\n\t{\n\t\tcn_protocol_packet_connection_denied_t* packet = (cn_protocol_packet_connection_denied_t*)packet_ptr;\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 0);\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE:\n\t{\n\t\tcn_protocol_packet_keepalive_t* packet = (cn_protocol_packet_keepalive_t*)packet_ptr;\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 0);\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT:\n\t{\n\t\tcn_protocol_packet_disconnect_t* packet = (cn_protocol_packet_disconnect_t*)packet_ptr;\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 0);\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST: // fall-thru\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE:\n\t{\n\t\tcn_protocol_packet_challenge_t* packet = (cn_protocol_packet_challenge_t*)packet_ptr;\n\t\tcn_write_uint64(&buffer, packet->challenge_nonce);\n\t\tCN_MEMCPY(buffer, packet->challenge_data, CN_PROTOCOL_CHALLENGE_DATA_SIZE);\n\t\tbuffer += CN_PROTOCOL_CHALLENGE_DATA_SIZE;\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 8 + CN_PROTOCOL_CHALLENGE_DATA_SIZE);\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD:\n\t{\n\t\tcn_protocol_packet_payload_t* packet = (cn_protocol_packet_payload_t*)packet_ptr;\n\t\tcn_write_uint16(&buffer, packet->payload_size);\n\t\tCN_MEMCPY(buffer, packet->payload, packet->payload_size);\n\t\tbuffer += packet->payload_size;\n\t\tpayload_size = (int)(buffer - payload);\n\t\tCN_ASSERT(payload_size == 2 + packet->payload_size);\n\t}\tbreak;\n\t}\n\n\tcn_crypto_encrypt(key, payload, payload_size, sequence);\n\n\tsize_t written = buffer - buffer_start;\n\treturn (int)(written) + CN_CRYPTO_HEADER_BYTES;\n}\n\nvoid* cn_protocol_packet_open(uint8_t* buffer, int size, const cn_crypto_key_t* key, cn_protocol_packet_allocator_t* pa, cn_protocol_replay_buffer_t* replay_buffer, uint64_t* sequence_ptr)\n{\n\tint ret = 0;\n\tuint8_t* buffer_start = buffer;\n\tuint8_t type = cn_read_uint8(&buffer);\n\n\tswitch (type)\n\t{\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED: CN_CHECK(size != 16 + 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED: CN_CHECK(size != 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE: CN_CHECK(size != 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT: CN_CHECK(size != 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST: CN_CHECK(size != 264 + 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE: CN_CHECK(size != 264 + 73); if (ret) return NULL; break;\n\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD: CN_CHECK((size - 73 < 1) | (size - 73 > 1255)); if (ret) return NULL; break;\n\t}\n\n\tuint64_t sequence = cn_read_uint64(&buffer);\n\tint bytes_read = (int)(buffer - buffer_start);\n\tCN_ASSERT(bytes_read == 1 + 8);\n\n\tif (replay_buffer) {\n\t\tCN_CHECK(cn_protocol_replay_buffer_cull_duplicate(replay_buffer, sequence));\n\t\tif (ret) return NULL;\n\t}\n\n\tbuffer += CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES;\n\tbytes_read = (int)(buffer - buffer_start);\n\tCN_ASSERT(bytes_read == 1 + 8 + CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES);\n\tif (cn_is_error(cn_crypto_decrypt(key, buffer, size - 37, sequence))) return NULL;\n\n\tif (replay_buffer) {\n\t\tcn_protocol_replay_buffer_update(replay_buffer, sequence);\n\t}\n\n\tif (sequence_ptr) {\n\t\t*sequence_ptr = sequence;\n\t}\n\n\tswitch (type)\n\t{\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED:\n\t{\n\t\tcn_protocol_packet_connection_accepted_t* packet = (cn_protocol_packet_connection_accepted_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\tpacket->client_id = cn_read_uint64(&buffer);\n\t\tpacket->max_clients = cn_read_uint32(&buffer);\n\t\tpacket->connection_timeout = cn_read_uint32(&buffer);\n\t\treturn packet;\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED:\n\t{\n\t\tcn_protocol_packet_connection_denied_t* packet = (cn_protocol_packet_connection_denied_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\treturn packet;\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE:\n\t{\n\t\tcn_protocol_packet_keepalive_t* packet = (cn_protocol_packet_keepalive_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\treturn packet;\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT:\n\t{\n\t\tcn_protocol_packet_disconnect_t* packet = (cn_protocol_packet_disconnect_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\treturn packet;\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST: // fall-thru\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE:\n\t{\n\t\tcn_protocol_packet_challenge_t* packet = (cn_protocol_packet_challenge_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\tpacket->challenge_nonce = cn_read_uint64(&buffer);\n\t\tCN_MEMCPY(packet->challenge_data, buffer, CN_PROTOCOL_CHALLENGE_DATA_SIZE);\n\t\treturn packet;\n\t}\tbreak;\n\n\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD:\n\t{\n\t\tcn_protocol_packet_payload_t* packet = (cn_protocol_packet_payload_t*)cn_protocol_packet_allocator_alloc(pa, (cn_protocol_packet_type_t)type);\n\t\tpacket->packet_type = type;\n\t\tpacket->payload_size = cn_read_uint16(&buffer);\n\t\tCN_MEMCPY(packet->payload, buffer, packet->payload_size);\n\t\treturn packet;\n\t}\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n// -------------------------------------------------------------------------------------------------\n\nuint8_t* cn_protocol_client_read_connect_token_from_web_service(uint8_t* buffer, uint64_t application_id, uint64_t current_time, cn_protocol_connect_token_t* token)\n{\n\tint ret = 0;\n\n\t// Read rest section.\n\tCN_CHECK(CN_STRNCMP((const char*)buffer, (const char*)CN_PROTOCOL_VERSION_STRING, CN_PROTOCOL_VERSION_STRING_LEN));\n\tbuffer += CN_PROTOCOL_VERSION_STRING_LEN;\n\tCN_CHECK(cn_read_uint64(&buffer) != application_id);\n\ttoken->creation_timestamp = cn_read_uint64(&buffer);\n\ttoken->client_to_server_key = cn_read_key(&buffer);\n\ttoken->server_to_client_key = cn_read_key(&buffer);\n\n\t// Read public section.\n\tuint8_t* connect_token_packet = buffer;\n\tcn_protocol_packet_connect_token_t packet;\n\tif (cn_is_error(cn_protocol_read_connect_token_packet_public_section(buffer, application_id, current_time, &packet))) return NULL;\n\ttoken->expiration_timestamp = packet.expiration_timestamp;\n\ttoken->handshake_timeout = packet.handshake_timeout;\n\ttoken->endpoint_count = packet.endpoint_count;\n\tCN_MEMCPY(token->endpoints, packet.endpoints, sizeof(cn_endpoint_t) * token->endpoint_count);\n\n\treturn ret ? NULL : connect_token_packet;\n}\n\ncn_result_t cn_protocol_server_decrypt_connect_token_packet(uint8_t* packet_buffer, const cn_crypto_sign_public_t* pk, const cn_crypto_sign_secret_t* sk, uint64_t application_id, uint64_t current_time, cn_protocol_connect_token_decrypted_t* token)\n{\n\t// Read public section.\n\tcn_protocol_packet_connect_token_t packet;\n\tcn_result_t result = cn_protocol_read_connect_token_packet_public_section(packet_buffer, application_id, current_time, &packet);\n\tif (cn_is_error(result)) return result;\n\tif (packet.expiration_timestamp <= current_time) return cn_error_failure(\"Invalid timestamp.\");\n\ttoken->expiration_timestamp = packet.expiration_timestamp;\n\ttoken->handshake_timeout = packet.handshake_timeout;\n\ttoken->endpoint_count = packet.endpoint_count;\n\tCN_MEMCPY(token->endpoints, packet.endpoints, sizeof(cn_endpoint_t) * token->endpoint_count);\n\tCN_MEMCPY(token->signature.bytes, packet_buffer + 1024 - CN_PROTOCOL_SIGNATURE_SIZE, CN_PROTOCOL_SIGNATURE_SIZE);\n\n\t// Verify signature.\n\tif (cn_is_error(cn_crypto_sign_verify(pk, &token->signature, packet_buffer, 1024 - CN_PROTOCOL_SIGNATURE_SIZE))) return cn_error_failure(\"Failed authentication.\");\n\n\t// Decrypt the secret section.\n\tuint8_t* secret_section = packet_buffer + 568;\n\n\tif (cn_is_error(cn_crypto_decrypt((cn_crypto_key_t*)sk, secret_section, CN_PROTOCOL_CONNECT_TOKEN_SECRET_SECTION_SIZE, 0))) {\n\t\treturn cn_error_failure(\"Failed decryption.\");\n\t}\n\n\t// Read secret section.\n\tsecret_section += CN_PROTOCOL_SIGNATURE_SIZE - CN_CRYPTO_HEADER_BYTES;\n\ttoken->client_id = cn_read_uint64(&secret_section);\n\ttoken->client_to_server_key = cn_read_key(&secret_section);\n\ttoken->server_to_client_key = cn_read_key(&secret_section);\n\tuint8_t* user_data = secret_section + CN_CRYPTO_HEADER_BYTES;\n\tCN_MEMCPY(token->user_data, user_data, CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE);\n\n\treturn cn_error_success();\n}\n\n// -------------------------------------------------------------------------------------------------\n\n// TODO - Rename this hash table so it's obviously different than cute_hashtable.h -- the difference\n// being one uses an unpredictable hash primitive from libhydrogen while the other uses a simple and\n// fast hash function.\n\nstatic uint32_t s_is_prime(uint32_t x)\n{\n\tif ((x == 2) | (x == 3)) return 1;\n\tif ((x % 2 == 0) | (x % 3 == 0)) return 0;\n\n\tuint32_t divisor = 6;\n\twhile (divisor * divisor - 2 * divisor + 1 <= x) {\n\t\tif (x % (divisor - 1) == 0) return 0;\n\t\tif (x % (divisor + 1) == 0) return 0;\n\t\tdivisor += 6;\n\t}\n\n\treturn 1;\n}\n\nstatic uint32_t s_next_prime(uint32_t a)\n{\n\twhile (1) {\n\t\tif (s_is_prime(a)) return a;\n\t\telse ++a;\n\t}\n}\n\nvoid cn_hashtable_init(cn_hashtable_t* table, int key_size, int item_size, int capacity, void* mem_ctx)\n{\n\tCN_ASSERT(capacity);\n\tCN_MEMSET(table, 0, sizeof(cn_hashtable_t));\n\n\ttable->count = 0;\n\ttable->slot_capacity = s_next_prime(capacity);\n\ttable->key_size = key_size;\n\ttable->item_size = item_size;\n\tint slots_size = (int)(table->slot_capacity * sizeof(*table->slots));\n\ttable->slots = (cn_hashtable_slot_t*)CN_ALLOC((size_t)slots_size, mem_ctx);\n\tCN_MEMSET(table->slots, 0, (size_t) slots_size);\n\n\thydro_hash_keygen(table->secret_key);\n\n\ttable->item_capacity = s_next_prime(capacity + capacity / 2);\n\ttable->items_key = CN_ALLOC(table->item_capacity * (table->key_size + sizeof(*table->items_slot_index) + table->item_size) + table->item_size + table->key_size, mem_ctx);\n\ttable->items_slot_index = (int*)((uint8_t*)table->items_key + table->item_capacity * table->key_size);\n\ttable->items_data = (void*)(table->items_slot_index + table->item_capacity);\n\ttable->temp_key = (void*)(((uintptr_t)table->items_data) + table->item_size * table->item_capacity);\n\ttable->temp_item = (void*)(((uintptr_t)table->temp_key) + table->key_size);\n\ttable->mem_ctx = mem_ctx;\n}\n\nvoid cn_hashtable_cleanup(cn_hashtable_t* table)\n{\n\tCN_FREE(table->slots, table->mem_ctx);\n\tCN_FREE(table->items_key, table->mem_ctx);\n\tCN_MEMSET(table, 0, sizeof(cn_hashtable_t));\n}\n\nstatic int s_keys_equal(const cn_hashtable_t* table, const void* a, const void* b)\n{\n\treturn !CN_MEMCMP(a, b, table->key_size);\n}\n\nstatic void* s_get_key(const cn_hashtable_t* table, int index)\n{\n\tuint8_t* keys = (uint8_t*)table->items_key;\n\treturn keys + index * table->key_size;\n}\n\nstatic void* s_get_item(const cn_hashtable_t* table, int index)\n{\n\tuint8_t* items = (uint8_t*)table->items_data;\n\treturn items + index * table->item_size;\n}\n\nstatic uint64_t s_calc_hash(const cn_hashtable_t* table, const void* key)\n{\n\tuint8_t hash_bytes[CN_HASHTABLE_HASH_BYTES];\n\tif (hydro_hash_hash(hash_bytes, CN_HASHTABLE_HASH_BYTES, (const uint8_t*)key, table->key_size, CN_CRYPTO_CONTEXT, table->secret_key) != 0) {\n\t\tCN_ASSERT(0);\n\t\treturn -1;\n\t}\n\n\tuint64_t hash = *(uint64_t*)hash_bytes;\n\treturn hash;\n}\n\nstatic int cn_hashtable_internal_find_slot(const cn_hashtable_t* table, const void* key)\n{\n\tuint64_t hash = s_calc_hash(table, key);\n\tint base_slot = (int)(hash % (uint64_t)table->slot_capacity);\n\tint base_count = table->slots[base_slot].base_count;\n\tint slot = base_slot;\n\n\twhile (base_count > 0) {\n\t\tuint64_t slot_hash = table->slots[slot].key_hash;\n\n\t\tif (slot_hash) {\n\t\t\tint slot_base = (int)(slot_hash % (uint64_t)table->slot_capacity);\n\t\t\tif (slot_base == base_slot)\n\t\t\t{\n\t\t\t\tCN_ASSERT(base_count > 0);\n\t\t\t\t--base_count;\n\t\t\t\tconst void* found_key = s_get_key(table, table->slots[slot].item_index);\n\t\t\t\tif (slot_hash == hash && s_keys_equal(table, found_key, key))\n\t\t\t\t\treturn slot;\n\t\t\t}\n\t\t}\n\t\tslot = (slot + 1) % table->slot_capacity;\n\t}\n\n\treturn -1;\n}\n\nvoid* cn_hashtable_insert(cn_hashtable_t* table, const void* key, const void* item)\n{\n\tCN_ASSERT(cn_hashtable_internal_find_slot(table, key) < 0);\n\tuint64_t hash = s_calc_hash(table, key);\n\n\tCN_ASSERT(table->count < table->slot_capacity);\n\n\tint base_slot = (int)(hash % (uint64_t)table->slot_capacity);\n\tint base_count = table->slots[base_slot].base_count;\n\tint slot = base_slot;\n\tint first_free = slot;\n\twhile (base_count) {\n\t\tuint64_t slot_hash = table->slots[slot].key_hash;\n\t\tif (slot_hash == 0 && table->slots[first_free].key_hash != 0) first_free = slot;\n\t\tint slot_base = (int)(slot_hash % (uint64_t)table->slot_capacity);\n\t\tif (slot_base == base_slot)\n\t\t\t--base_count;\n\t\tslot = (slot + 1) % table->slot_capacity;\n\t}\n\n\tslot = first_free;\n\twhile (table->slots[slot].key_hash)\n\t\tslot = (slot + 1) % table->slot_capacity;\n\n\tCN_ASSERT(table->count < table->item_capacity);\n\n\tCN_ASSERT(!table->slots[slot].key_hash && (hash % (uint64_t)table->slot_capacity) == (uint64_t)base_slot);\n\tCN_ASSERT(hash);\n\ttable->slots[slot].key_hash = hash;\n\ttable->slots[slot].item_index = table->count;\n\t++table->slots[base_slot].base_count;\n\n\tvoid* item_dst = s_get_item(table, table->count);\n\tvoid* key_dst = s_get_key(table, table->count);\n\tCN_MEMCPY(item_dst, item, table->item_size);\n\tCN_MEMCPY(key_dst, key, table->key_size);\n\ttable->items_slot_index[table->count] = slot;\n\t++table->count;\n\n\treturn item_dst;\n}\n\nvoid cn_hashtable_remove(cn_hashtable_t* table, const void* key)\n{\n\tint slot = cn_hashtable_internal_find_slot(table, key);\n\tCN_ASSERT(slot >= 0);\n\n\tuint64_t hash = table->slots[slot].key_hash;\n\tint base_slot = (int)(hash % (uint64_t)table->slot_capacity);\n\tCN_ASSERT(hash);\n\t--table->slots[base_slot].base_count;\n\ttable->slots[slot].key_hash = 0;\n\n\tint index = table->slots[slot].item_index;\n\tint last_index = table->count - 1;\n\tif (index != last_index)\n\t{\n\t\tvoid* dst_key = s_get_key(table, index);\n\t\tvoid* src_key = s_get_key(table, last_index);\n\t\tCN_MEMCPY(dst_key, src_key, (size_t)table->key_size);\n\t\tvoid* dst_item = s_get_item(table, index);\n\t\tvoid* src_item = s_get_item(table, last_index);\n\t\tCN_MEMCPY(dst_item, src_item, (size_t)table->item_size);\n\t\ttable->items_slot_index[index] = table->items_slot_index[last_index];\n\t\ttable->slots[table->items_slot_index[last_index]].item_index = index;\n\t}\n\t--table->count;\n}\n\nvoid cn_hashtable_clear(cn_hashtable_t* table)\n{\n\ttable->count = 0;\n\tCN_MEMSET(table->slots, 0, sizeof(*table->slots) * table->slot_capacity);\n}\n\nvoid* cn_hashtable_find(const cn_hashtable_t* table, const void* key)\n{\n\tint slot = cn_hashtable_internal_find_slot(table, key);\n\tif (slot < 0) return 0;\n\n\tint index = table->slots[slot].item_index;\n\treturn s_get_item(table, index);\n}\n\nint cn_hashtable_count(const cn_hashtable_t* table)\n{\n\treturn table->count;\n}\n\nvoid* cn_hashtable_items(const cn_hashtable_t* table)\n{\n\treturn table->items_data;\n}\n\nvoid* cn_hashtable_keys(const cn_hashtable_t* table)\n{\n\treturn table->items_key;\n}\n\nvoid cn_hashtable_swap(cn_hashtable_t* table, int index_a, int index_b)\n{\n\tif (index_a < 0 || index_a >= table->count || index_b < 0 || index_b >= table->count) return;\n\n\tint slot_a = table->items_slot_index[index_a];\n\tint slot_b = table->items_slot_index[index_b];\n\n\ttable->items_slot_index[index_a] = slot_b;\n\ttable->items_slot_index[index_b] = slot_a;\n\n\tvoid* key_a = s_get_key(table, index_a);\n\tvoid* key_b = s_get_key(table, index_b);\n\tCN_MEMCPY(table->temp_key, key_a, table->key_size);\n\tCN_MEMCPY(key_a, key_b, table->key_size);\n\tCN_MEMCPY(key_b, table->temp_key, table->key_size);\n\n\tvoid* item_a = s_get_item(table, index_a);\n\tvoid* item_b = s_get_item(table, index_b);\n\tCN_MEMCPY(table->temp_item, item_a, table->item_size);\n\tCN_MEMCPY(item_a, item_b, table->item_size);\n\tCN_MEMCPY(item_b, table->temp_item, table->item_size);\n\n\ttable->slots[slot_a].item_index = index_b;\n\ttable->slots[slot_b].item_index = index_a;\n}\n\n// -------------------------------------------------------------------------------------------------\n\nvoid cn_protocol_connect_token_cache_init(cn_protocol_connect_token_cache_t* cache, int capacity, void* mem_ctx)\n{\n\tcache->capacity = capacity;\n\tcn_hashtable_init(&cache->table, CN_PROTOCOL_SIGNATURE_SIZE, sizeof(cn_protocol_connect_token_cache_entry_t), capacity, mem_ctx);\n\tcn_list_init(&cache->list);\n\tcn_list_init(&cache->free_list);\n\tcache->node_memory = (cn_protocol_connect_token_cache_node_t*)CN_ALLOC(sizeof(cn_protocol_connect_token_cache_node_t) * capacity, mem_ctx);\n\n\tfor (int i = 0; i < capacity; ++i) {\n\t\tcn_list_node_t* node = &cache->node_memory[i].node;\n\t\tcn_list_init_node(node);\n\t\tcn_list_push_front(&cache->free_list, node);\n\t}\n\n\tcache->mem_ctx = mem_ctx;\n}\n\nvoid cn_protocol_connect_token_cache_cleanup(cn_protocol_connect_token_cache_t* cache)\n{\n\tcn_hashtable_cleanup(&cache->table);\n\tCN_FREE(cache->node_memory, cache->mem_ctx);\n\tcache->node_memory = NULL;\n}\n\ncn_protocol_connect_token_cache_entry_t* cn_protocol_connect_token_cache_find(cn_protocol_connect_token_cache_t* cache, const uint8_t* hmac_bytes)\n{\n\tvoid* entry_ptr = cn_hashtable_find(&cache->table, hmac_bytes);\n\tif (entry_ptr) {\n\t\tcn_protocol_connect_token_cache_entry_t* entry = (cn_protocol_connect_token_cache_entry_t*)entry_ptr;\n\t\tcn_list_node_t* node = entry->node;\n\t\tcn_list_remove(node);\n\t\tcn_list_push_front(&cache->list, node);\n\t\treturn entry;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nvoid cn_protocol_connect_token_cache_add(cn_protocol_connect_token_cache_t* cache, const uint8_t* hmac_bytes)\n{\n\tcn_protocol_connect_token_cache_entry_t entry;\n\n\tint table_count = cn_hashtable_count(&cache->table);\n\tCN_ASSERT(table_count <= cache->capacity);\n\tif (table_count == cache->capacity) {\n\t\tcn_list_node_t* oldest_node = cn_list_pop_back(&cache->list);\n\t\tcn_protocol_connect_token_cache_node_t* oldest_entry_node = CN_LIST_HOST(cn_protocol_connect_token_cache_node_t, node, oldest_node);\n\t\tcn_hashtable_remove(&cache->table, oldest_entry_node->signature.bytes);\n\t\tCN_MEMCPY(oldest_entry_node->signature.bytes, hmac_bytes, CN_PROTOCOL_SIGNATURE_SIZE);\n\n\t\tcn_protocol_connect_token_cache_entry_t* entry_ptr = (cn_protocol_connect_token_cache_entry_t*)cn_hashtable_insert(&cache->table, hmac_bytes, &entry);\n\t\tCN_ASSERT(entry_ptr);\n\t\tentry_ptr->node = oldest_node;\n\t\tcn_list_push_front(&cache->list, entry_ptr->node);\n\t} else {\n\t\tcn_protocol_connect_token_cache_entry_t* entry_ptr = (cn_protocol_connect_token_cache_entry_t*)cn_hashtable_insert(&cache->table, hmac_bytes, &entry);\n\t\tCN_ASSERT(entry_ptr);\n\t\tentry_ptr->node = cn_list_pop_front(&cache->free_list);\n\t\tcn_protocol_connect_token_cache_node_t* entry_node = CN_LIST_HOST(cn_protocol_connect_token_cache_node_t, node, entry_ptr->node);\n\t\tCN_MEMCPY(entry_node->signature.bytes, hmac_bytes, CN_PROTOCOL_SIGNATURE_SIZE);\n\t\tcn_list_push_front(&cache->list, entry_ptr->node);\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\nvoid cn_protocol_encryption_map_init(cn_protocol_encryption_map_t* map, void* mem_ctx)\n{\n\tcn_hashtable_init(&map->table, sizeof(cn_endpoint_t), sizeof(cn_protocol_encryption_state_t), CN_PROTOCOL_ENCRYPTION_STATES_MAX, mem_ctx);\n}\n\nvoid cn_protocol_encryption_map_cleanup(cn_protocol_encryption_map_t* map)\n{\n\tcn_hashtable_cleanup(&map->table);\n}\n\nvoid cn_protocol_encryption_map_clear(cn_protocol_encryption_map_t* map)\n{\n\tcn_hashtable_clear(&map->table);\n}\n\nint cn_protocol_encryption_map_count(cn_protocol_encryption_map_t* map)\n{\n\treturn cn_hashtable_count(&map->table);\n}\n\nvoid cn_protocol_encryption_map_insert(cn_protocol_encryption_map_t* map, cn_endpoint_t endpoint, const cn_protocol_encryption_state_t* state)\n{\n\tcn_hashtable_insert(&map->table, &endpoint, state);\n}\n\ncn_protocol_encryption_state_t* cn_protocol_encryption_map_find(cn_protocol_encryption_map_t* map, cn_endpoint_t endpoint)\n{\n\tvoid* ptr = cn_hashtable_find(&map->table, &endpoint);\n\tif (ptr) {\n\t\tcn_protocol_encryption_state_t* state = (cn_protocol_encryption_state_t*)ptr;\n\t\tstate->last_packet_recieved_time = 0;\n\t\treturn state;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nvoid cn_protocol_encryption_map_remove(cn_protocol_encryption_map_t* map, cn_endpoint_t endpoint)\n{\n\tcn_hashtable_remove(&map->table, &endpoint);\n}\n\ncn_endpoint_t* cn_protocol_encryption_map_get_endpoints(cn_protocol_encryption_map_t* map)\n{\n\treturn (cn_endpoint_t*)cn_hashtable_keys(&map->table);\n}\n\ncn_protocol_encryption_state_t* cn_protocol_encryption_map_get_states(cn_protocol_encryption_map_t* map)\n{\n\treturn (cn_protocol_encryption_state_t*)cn_hashtable_items(&map->table);\n}\n\nvoid cn_protocol_encryption_map_look_for_timeouts_or_expirations(cn_protocol_encryption_map_t* map, double dt, uint64_t time)\n{\n\tint index = 0;\n\tint count = cn_protocol_encryption_map_count(map);\n\tcn_endpoint_t* endpoints = cn_protocol_encryption_map_get_endpoints(map);\n\tcn_protocol_encryption_state_t* states = cn_protocol_encryption_map_get_states(map);\n\n\twhile (index < count) {\n\t\tcn_protocol_encryption_state_t* state = states + index;\n\t\tstate->last_packet_recieved_time += dt;\n\t\tint timed_out = state->last_packet_recieved_time >= state->handshake_timeout;\n\t\tint expired = state->expiration_timestamp <= time;\n\t\tif (timed_out | expired) {\n\t\t\tcn_protocol_encryption_map_remove(map, endpoints[index]);\n\t\t\t--count;\n\t\t} else {\n\t\t\t++index;\n\t\t}\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\nCN_INLINE const char* s_protocol_client_state_str(cn_protocol_client_state_t state)\n{\n\tswitch (state)\n\t{\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED: return \"CONNECT_TOKEN_EXPIRED\";\n\tcase CN_PROTOCOL_CLIENT_STATE_INVALID_CONNECT_TOKEN: return \"INVALID_CONNECT_TOKEN\";\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTION_TIMED_OUT: return \"CONNECTION_TIMED_OUT\";\n\tcase CN_PROTOCOL_CLIENT_STATE_CHALLENGED_RESPONSE_TIMED_OUT: return \"CHALLENGED_RESPONSE_TIMED_OUT\";\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT: return \"CONNECTION_REQUEST_TIMED_OUT\";\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTION_DENIED: return \"CONNECTION_DENIED\";\n\tcase CN_PROTOCOL_CLIENT_STATE_DISCONNECTED: return \"DISCONNECTED\";\n\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST: return \"SENDING_CONNECTION_REQUEST\";\n\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE: return \"SENDING_CHALLENGE_RESPONSE\";\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTED: return \"CONNECTED\";\n\t}\n\n\treturn NULL;\n}\n\nstatic void s_protocol_client_set_state(cn_protocol_client_t* client, cn_protocol_client_state_t state)\n{\n\tclient->state = state;\n\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Client: Switching to state %s.\", s_protocol_client_state_str(state));\n}\n\ncn_protocol_client_t* cn_protocol_client_create(uint16_t port, uint64_t application_id, bool use_ipv6, void* user_allocator_context)\n{\n\tcn_protocol_client_t* client = (cn_protocol_client_t*)CN_ALLOC(sizeof(cn_protocol_client_t), user_allocator_context);\n\tCN_MEMSET(client, 0, sizeof(cn_protocol_client_t));\n\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_DISCONNECTED);\n\tclient->use_ipv6 = use_ipv6;\n\tclient->port = port;\n\tclient->application_id = application_id;\n\tclient->mem_ctx = user_allocator_context;\n\tclient->packet_queue = cn_circular_buffer_create(CN_MB, client->mem_ctx);\n\treturn client;\n}\n\nvoid cn_protocol_client_destroy(cn_protocol_client_t* client)\n{\n\t// TODO: Detect if disconnect was not called yet.\n\tcn_simulator_destroy(client->sim);\n\tcn_circular_buffer_free(&client->packet_queue);\n\tCN_FREE(client, client->mem_ctx);\n}\n\ntypedef struct cn_protocol_payload_t\n{\n\tuint64_t sequence;\n\tint size;\n\tvoid* data;\n} cn_protocol_payload_t;\n\ncn_result_t cn_protocol_client_connect(cn_protocol_client_t* client, const uint8_t* connect_token)\n{\n\tuint8_t* connect_token_packet = cn_protocol_client_read_connect_token_from_web_service(\n\t\t(uint8_t*)connect_token,\n\t\tclient->application_id,\n\t\tclient->current_time,\n\t\t&client->connect_token\n\t);\n\tif (!connect_token_packet) {\n\t\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_INVALID_CONNECT_TOKEN);\n\t\treturn cn_error_failure(\"Invalid connect token.\");\n\t}\n\n\tCN_MEMCPY(client->connect_token_packet, connect_token_packet, CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE);\n\n#ifndef CUTE_NET_NO_IPV6\n\tcn_address_type_t sock_addr_type = client->use_ipv6 ? CN_ADDRESS_TYPE_IPV6 : CN_ADDRESS_TYPE_IPV4;\n#else\n\tif (client->use_ipv6) {\n\t\treturn cn_error_failure(\"Unable to open socket. Cute net compiled without IPV6 support but client configured to use ipv6\");\n\t}\n\tcn_address_type_t sock_addr_type = CN_ADDRESS_TYPE_IPV4;\n#endif\n\tif (cn_socket_init1(&client->socket, sock_addr_type, client->port, CN_PROTOCOL_CLIENT_SEND_BUFFER_SIZE, CN_PROTOCOL_CLIENT_RECEIVE_BUFFER_SIZE)) {\n\t\treturn cn_error_failure(\"Unable to open socket.\");\n\t}\n\n\tcn_protocol_replay_buffer_init(&client->replay_buffer);\n\tclient->server_endpoint_index = 0;\n\tclient->last_packet_sent_time = CN_PROTOCOL_SEND_RATE;\n\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST);\n\tclient->goto_next_server_tentative_state = CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT;\n\n\treturn cn_error_success();\n}\n\nCN_INLINE cn_endpoint_t s_protocol_server_endpoint(cn_protocol_client_t* client)\n{\n\treturn client->connect_token.endpoints[client->server_endpoint_index];\n}\n\nCN_INLINE const char* s_protocol_packet_str(uint8_t type)\n{\n\tswitch (type)\n\t{\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN: return \"CONNECT_TOKEN\";\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED: return \"CONNECTION_ACCEPTED\";\n\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED: return \"CONNECTION_DENIED\";\n\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE: return \"KEEPALIVE\";\n\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT: return \"DISCONNECT\";\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST: return \"CHALLENGE_REQUEST\";\n\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE: return \"CHALLENGE_RESPONSE\";\n\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD: return \"PAYLOAD\";\n\t}\n\n\treturn NULL;\n}\n\nstatic void s_protocol_client_send(cn_protocol_client_t* client, void* packet)\n{\n\tint sz = cn_protocol_packet_write(packet, client->buffer, client->sequence++, &client->connect_token.client_to_server_key);\n\n\tif (sz >= 73) {\n\t\tcn_socket_send(&client->socket, client->sim, s_protocol_server_endpoint(client), client->buffer, sz);\n\t\tclient->last_packet_sent_time = 0;\n\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Client: Sent %s packet to server.\", s_protocol_packet_str(*(uint8_t*)packet));\n\t}\n}\n\nbool cn_protocol_client_get_packet(cn_protocol_client_t* client, void** data, int* size, uint64_t* sequence)\n{\n\tcn_protocol_payload_t payload;\n\tif (cn_circular_buffer_pull(&client->packet_queue, &payload, sizeof(cn_protocol_payload_t)) < 0) {\n\t\treturn false;\n\t}\n\n\tif (sequence) *sequence = payload.sequence;\n\tif (size) *size = payload.size;\n\t*data = payload.data;\n\n\treturn true;\n}\n\nvoid cn_protocol_client_free_packet(cn_protocol_client_t* client, void* packet)\n{\n\tcn_protocol_packet_payload_t* payload_packet = (cn_protocol_packet_payload_t*)((uint8_t*)packet - CN_OFFSET_OF(cn_protocol_packet_payload_t, payload));\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)payload_packet->packet_type, payload_packet);\n}\n\nstatic void s_protocol_disconnect(cn_protocol_client_t* client, cn_protocol_client_state_t state, int send_packets)\n{\n\tvoid* packet = NULL;\n\twhile (cn_protocol_client_get_packet(client, &packet, NULL, NULL)) {\n\t\tcn_protocol_client_free_packet(client, packet);\n\t}\n\n\tif (send_packets) {\n\t\tcn_protocol_packet_disconnect_t disconnect_packet;\n\t\tdisconnect_packet.packet_type = CN_PROTOCOL_PACKET_TYPE_DISCONNECT;\n\t\tfor (int i = 0; i < CN_PROTOCOL_REDUNDANT_DISCONNECT_PACKET_COUNT; ++i)\n\t\t{\n\t\t\ts_protocol_client_send(client, &disconnect_packet);\n\t\t}\n\t}\n\n\tcn_socket_cleanup(&client->socket);\n\tcn_circular_buffer_reset(&client->packet_queue);\n\n\ts_protocol_client_set_state(client, state);\n}\n\nvoid cn_protocol_client_disconnect(cn_protocol_client_t* client)\n{\n\tif (client->state <= 0) return;\n\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_DISCONNECTED, 1);\n}\n\nstatic void s_protocol_receive_packets(cn_protocol_client_t* client)\n{\n\tuint8_t* buffer = client->buffer;\n\n\twhile (1)\n\t{\n\t\t// Read packet from UDP stack, and open it.\n\t\tcn_endpoint_t from;\n\t\tint sz = cn_socket_receive(&client->socket, &from, buffer, CN_PROTOCOL_PACKET_SIZE_MAX);\n\t\tif (!sz) break;\n\n\t\tif (!cn_endpoint_equals(s_protocol_server_endpoint(client), from)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sz < 73) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint8_t type = *buffer;\n\t\tif (type > 7) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (type)\n\t\t{\n\t\tcase CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN: // fall-thru\n\t\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE:\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint64_t sequence = ~0u;\n\t\tvoid* packet_ptr = cn_protocol_packet_open(buffer, sz, &client->connect_token.server_to_client_key, NULL, &client->replay_buffer, &sequence);\n\t\tif (!packet_ptr) continue;\n\n\t\t// Handle packet based on client's current state.\n\t\tint free_packet = 1;\n\t\tint should_break = 0;\n\n\t\tswitch (client->state)\n\t\t{\n\t\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST:\n\t\t\tif (type == CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST) {\n\t\t\t\tcn_protocol_packet_challenge_t* packet = (cn_protocol_packet_challenge_t*)packet_ptr;\n\t\t\t\tclient->challenge_nonce = packet->challenge_nonce;\n\t\t\t\tCN_MEMCPY(client->challenge_data, packet->challenge_data, CN_PROTOCOL_CHALLENGE_DATA_SIZE);\n\t\t\t\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE);\n\t\t\t\tclient->goto_next_server_tentative_state = CN_PROTOCOL_CLIENT_STATE_CHALLENGED_RESPONSE_TIMED_OUT;\n\t\t\t\tclient->last_packet_sent_time = CN_PROTOCOL_SEND_RATE;\n\t\t\t\tclient->last_packet_recieved_time = 0;\n\t\t\t} else if (type == CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED) {\n\t\t\t\tclient->goto_next_server = 1;\n\t\t\t\tclient->goto_next_server_tentative_state = CN_PROTOCOL_CLIENT_STATE_CONNECTION_DENIED;\n\t\t\t\tshould_break = 1;\n\t\t\t\t//log(CN_LOG_LEVEL_WARNING, \"Protocol Client: Received CONNECTION_DENIED packet, attempting to connect to next server.\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE:\n\t\t\tif (type == CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED) {\n\t\t\t\tcn_protocol_packet_connection_accepted_t* packet = (cn_protocol_packet_connection_accepted_t*)packet_ptr;\n\t\t\t\tclient->client_id = packet->client_id;\n\t\t\t\tclient->max_clients = packet->max_clients;\n\t\t\t\tclient->connection_timeout = (double)packet->connection_timeout;\n\t\t\t\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\t\t\t\tclient->last_packet_recieved_time = 0;\n\t\t\t} else if (type == CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED) {\n\t\t\t\tclient->goto_next_server = 1;\n\t\t\t\tclient->goto_next_server_tentative_state = CN_PROTOCOL_CLIENT_STATE_CONNECTION_DENIED;\n\t\t\t\tshould_break = 1;\n\t\t\t\t//log(CN_LOG_LEVEL_WARNING, \"Protocol Client: Received CONNECTION_DENIED packet, attempting to connect to next server.\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTED:\n\t\t\tif (type == CN_PROTOCOL_PACKET_TYPE_PAYLOAD) {\n\t\t\t\tclient->last_packet_recieved_time = 0;\n\t\t\t\tcn_protocol_packet_payload_t* packet = (cn_protocol_packet_payload_t*)packet_ptr;\n\t\t\t\tcn_protocol_payload_t payload;\n\t\t\t\tpayload.sequence = sequence;\n\t\t\t\tpayload.size = packet->payload_size;\n\t\t\t\tpayload.data = packet->payload;\n\t\t\t\tif (cn_circular_buffer_push(&client->packet_queue, &payload, sizeof(cn_protocol_payload_t)) < 0) {\n\t\t\t\t\t//log(CN_LOG_LEVEL_WARNING, \"Protocol Client: Packet queue is full; dropped payload packet.\");\n\t\t\t\t\tfree_packet = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfree_packet = 0;\n\t\t\t\t}\n\t\t\t} else if (type == CN_PROTOCOL_PACKET_TYPE_KEEPALIVE) {\n\t\t\t\tclient->last_packet_recieved_time = 0;\n\t\t\t} else if (type == CN_PROTOCOL_PACKET_TYPE_DISCONNECT) {\n\t\t\t\t//log(CN_LOG_LEVEL_WARNING, \"Protocol Client: Received DISCONNECT packet from server.\");\n\t\t\t\tif (free_packet) {\n\t\t\t\t\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)type, packet_ptr);\n\t\t\t\t\tfree_packet = 0;\n\t\t\t\t\tpacket_ptr = NULL;\n\t\t\t\t}\n\t\t\t\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_DISCONNECTED, 0);\n\t\t\t\tshould_break = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (free_packet) {\n\t\t\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)type, packet_ptr);\n\t\t}\n\n\t\tif (should_break) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void s_protocol_send_packets(cn_protocol_client_t* client)\n{\n\tswitch (client->state)\n\t{\n\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST:\n\t\tif (client->last_packet_sent_time >= CN_PROTOCOL_SEND_RATE) {\n\t\t\ts_protocol_client_send(client, client->connect_token_packet);\n\t\t}\n\t\tbreak;\n\n\tcase CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE:\n\t\tif (client->last_packet_sent_time >= CN_PROTOCOL_SEND_RATE) {\n\t\t\tcn_protocol_packet_challenge_t packet;\n\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE;\n\t\t\tpacket.challenge_nonce = client->challenge_nonce;\n\t\t\tCN_MEMCPY(packet.challenge_data, client->challenge_data, CN_PROTOCOL_CHALLENGE_DATA_SIZE);\n\t\t\ts_protocol_client_send(client, &packet);\n\t\t}\n\t\tbreak;\n\n\tcase CN_PROTOCOL_CLIENT_STATE_CONNECTED:\n\t\tif (client->last_packet_sent_time >= CN_PROTOCOL_SEND_RATE) {\n\t\t\tcn_protocol_packet_keepalive_t packet;\n\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_KEEPALIVE;\n\t\t\ts_protocol_client_send(client, &packet);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int s_protocol_goto_next_server(cn_protocol_client_t* client)\n{\n\tif (client->server_endpoint_index + 1 == client->connect_token.endpoint_count) {\n\t\ts_protocol_disconnect(client, client->goto_next_server_tentative_state, 0);\n\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Client: Unable to connect to any server in the server list.\");\n\t\treturn 0;\n\t}\n\n\tint index = ++client->server_endpoint_index;\n\n\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Client: Unable to connect to server index %d; now attempting index %d.\", index - 1, index);\n\n\tclient->last_packet_recieved_time = 0;\n\tclient->last_packet_sent_time = CN_PROTOCOL_SEND_RATE;\n\tclient->goto_next_server = 0;\n\tcn_circular_buffer_reset(&client->packet_queue);\n\n\tclient->server_endpoint_index = index;\n\ts_protocol_client_set_state(client, CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST);\n\n\treturn 1;\n}\n\nvoid cn_protocol_client_update(cn_protocol_client_t* client, double dt, uint64_t current_time)\n{\n\tif (client->state <= 0) {\n\t\treturn;\n\t}\n\n\tclient->current_time = current_time;\n\tclient->last_packet_recieved_time += dt;\n\tclient->last_packet_sent_time += dt;\n\n\tcn_simulator_update(client->sim, dt);\n\ts_protocol_receive_packets(client);\n\ts_protocol_send_packets(client);\n\n\tif (client->state <= 0) {\n\t\treturn;\n\t}\n\n\tint timeout = client->last_packet_recieved_time >= client->connect_token.handshake_timeout;\n\tint is_handshake = client->state >= CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST && client->state <= CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE;\n\tif (is_handshake) {\n\t\tint expired = client->connect_token.expiration_timestamp <= client->current_time;\n\t\tif (expired) {\n\t\t\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED, 1);\n\t\t} else if (timeout | client->goto_next_server) {\n\t\t\tif (s_protocol_goto_next_server(client)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (client->state == CN_PROTOCOL_CLIENT_STATE_SENDING_CONNECTION_REQUEST) {\n\t\t\t\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT, 1);\n\t\t\t} else if (client->state == CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE) {\n\t\t\t\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_CHALLENGED_RESPONSE_TIMED_OUT, 1);\n\t\t\t}\n\t\t}\n\t} else { // CN_PROTOCOL_CLIENT_STATE_CONNECTED\n\t\tCN_ASSERT(client->state == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\t\ttimeout = client->last_packet_recieved_time >= client->connection_timeout;\n\t\tif (timeout) {\n\t\t\ts_protocol_disconnect(client, CN_PROTOCOL_CLIENT_STATE_CONNECTION_TIMED_OUT, 1);\n\t\t}\n\t}\n}\n\ncn_result_t cn_protocol_client_send(cn_protocol_client_t* client, const void* data, int size)\n{\n\tif (size < 0) return cn_error_failure(\"`size` can not be negative.\");\n\tif (size > CN_PROTOCOL_PACKET_PAYLOAD_MAX) return cn_error_failure(\"`size` exceeded `CN_PROTOCOL_PACKET_PAYLOAD_MAX`.\");\n\tcn_protocol_packet_payload_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_PAYLOAD;\n\tpacket.payload_size = size;\n\tCN_MEMCPY(packet.payload, data, size);\n\ts_protocol_client_send(client, &packet);\n\treturn cn_error_success();\n}\n\ncn_protocol_client_state_t cn_protocol_client_get_state(cn_protocol_client_t* client)\n{\n\treturn client->state;\n}\n\nuint64_t cn_protocol_client_get_id(cn_protocol_client_t* client)\n{\n\treturn client->client_id;\n}\n\nuint32_t cn_protocol_client_get_max_clients(cn_protocol_client_t* client)\n{\n\treturn client->max_clients;\n}\n\ncn_endpoint_t cn_protocol_client_get_server_address(cn_protocol_client_t* client)\n{\n\treturn s_protocol_server_endpoint(client);\n}\n\nuint16_t cn_protocol_client_get_port(cn_protocol_client_t* client)\n{\n\treturn client->socket.endpoint.port;\n}\n\nvoid cn_protocol_client_enable_network_simulator(cn_protocol_client_t* client, double latency, double jitter, double drop_chance, double duplicate_chance)\n{\n\tcn_simulator_t* sim = cn_simulator_create(&client->socket, client->mem_ctx);\n\tsim->latency = latency;\n\tsim->jitter = jitter;\n\tsim->drop_chance = drop_chance;\n\tsim->duplicate_chance = duplicate_chance;\n\tclient->sim = sim;\n}\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_CHECK_BUFFER_GROW(ctx, count, capacity, data, type) \\\n\tdo { \\\n\t\tif (ctx->count == ctx->capacity) \\\n\t\t{ \\\n\t\t\tint new_capacity = ctx->capacity * 2; \\\n\t\t\tCN_ASSERT(new_capacity); \\\n\t\t\tvoid* new_data = CN_ALLOC(sizeof(type) * new_capacity, ctx->mem_ctx); \\\n\t\t\tif (!new_data) CN_ASSERT(0); \\\n\t\t\tCN_MEMCPY(new_data, ctx->data, sizeof(type) * ctx->count); \\\n\t\t\tCN_FREE(ctx->data, ctx->mem_ctx); \\\n\t\t\tctx->data = (type*)new_data; \\\n\t\t\tctx->capacity = new_capacity; \\\n\t\t} \\\n\t} while (0)\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef uint64_t cn_handle_t;\n#define CN_INVALID_HANDLE (~0ULL)\n\ntypedef union cn_handle_entry_t\n{\n\tstruct\n\t{\n\t\tuint64_t user_index : 32;\n\t\tuint64_t generation : 32;\n\t} data;\n\tuint64_t val;\n} cn_handle_entry_t;\n\ntypedef struct cn_handle_allocator_t\n{\n\tuint32_t freelist;\n\tint handles_capacity;\n\tint handles_count;\n\tcn_handle_entry_t* handles;\n\tvoid* mem_ctx;\n} cn_handle_allocator_t;\n\nstatic void s_add_elements_to_freelist(cn_handle_allocator_t* table, int first_index, int last_index)\n{\n\tcn_handle_entry_t* handles = table->handles;\n\tfor (int i = first_index; i < last_index; ++i)\n\t{\n\t\tcn_handle_entry_t handle;\n\t\thandle.data.user_index = i + 1;\n\t\thandle.data.generation = 0;\n\t\thandles[i] = handle;\n\t}\n\n\tcn_handle_entry_t last_handle;\n\tlast_handle.data.user_index = UINT32_MAX;\n\tlast_handle.data.generation = 0;\n\thandles[last_index] = last_handle;\n\n\ttable->freelist = first_index;\n}\n\ncn_handle_allocator_t* cn_handle_allocator_create(int initial_capacity, void* user_allocator_context)\n{\n\tcn_handle_allocator_t* table = (cn_handle_allocator_t*)CN_ALLOC(sizeof(cn_handle_allocator_t), user_allocator_context);\n\tif (!table) return NULL;\n\ttable->freelist = ~0u;\n\ttable->handles_capacity = initial_capacity;\n\ttable->handles_count = 0;\n\ttable->handles = NULL;\n\ttable->mem_ctx = user_allocator_context;\n\n\tif (initial_capacity) {\n\t\ttable->handles = (cn_handle_entry_t*)CN_ALLOC(sizeof(cn_handle_entry_t) * initial_capacity, user_allocator_context);\n\t\tif (!table->handles) {\n\t\t\tCN_FREE(table, user_allocator_context);\n\t\t\treturn NULL;\n\t\t}\n\t\tint last_index = table->handles_capacity - 1;\n\t\ts_add_elements_to_freelist(table, 0, last_index);\n\t}\n\n\treturn table;\n}\n\nvoid cn_handle_allocator_destroy(cn_handle_allocator_t* table)\n{\n\tif (!table) return;\n\tvoid* mem_ctx = table->mem_ctx;\n\tCN_FREE(table->handles, mem_ctx);\n\tCN_FREE(table, mem_ctx);\n}\n\ncn_handle_t cn_handle_allocator_alloc(cn_handle_allocator_t* table, uint32_t index)\n{\n\tuint32_t freelist_index = table->freelist;\n\tif (freelist_index == UINT32_MAX) {\n\t\tint first_index = table->handles_capacity;\n\t\tif (!first_index) first_index = 1;\n\t\tCN_CHECK_BUFFER_GROW(table, handles_count, handles_capacity, handles, cn_handle_entry_t);\n\t\tint last_index = table->handles_capacity - 1;\n\t\ts_add_elements_to_freelist(table, first_index, last_index);\n\t\tfreelist_index = table->freelist;\n\t}\n\n\t// Pop freelist.\n\tcn_handle_entry_t* handles = table->handles;\n\ttable->freelist = (uint32_t)handles[freelist_index].data.user_index;\n\ttable->handles_count++;\n\n\t// Setup handle indices.\n\thandles[freelist_index].data.user_index = index;\n\tcn_handle_t handle = (((uint64_t)freelist_index) << 32) | handles[freelist_index].data.generation;\n\treturn handle;\n}\n\nCN_INLINE uint32_t s_table_index(cn_handle_t handle)\n{\n\treturn (uint32_t)((handle & 0xFFFFFFFF00000000ULL) >> 32);\n}\n\nuint32_t cn_handle_allocator_get_index(cn_handle_allocator_t* table, cn_handle_t handle)\n{\n\tcn_handle_entry_t* handles = table->handles;\n\tuint32_t table_index = s_table_index(handle);\n\tuint64_t generation = handle & 0xFFFFFFFF;\n\tCN_ASSERT(handles[table_index].data.generation == generation);\n\treturn (uint32_t)handles[table_index].data.user_index;\n}\n\nvoid cn_handle_allocator_update_index(cn_handle_allocator_t* table, cn_handle_t handle, uint32_t index)\n{\n\tcn_handle_entry_t* handles = table->handles;\n\tuint32_t table_index = s_table_index(handle);\n\tuint64_t generation = handle & 0xFFFFFFFF;\n\tCN_ASSERT(handles[table_index].data.generation == generation);\n\thandles[table_index].data.user_index = index;\n}\n\nvoid cn_handle_allocator_free(cn_handle_allocator_t* table, cn_handle_t handle)\n{\n\t// Push handle onto freelist.\n\tcn_handle_entry_t* handles = table->handles;\n\tuint32_t table_index = s_table_index(handle);\n\thandles[table_index].data.user_index = table->freelist;\n\thandles[table_index].data.generation++;\n\ttable->freelist = table_index;\n\ttable->handles_count--;\n}\n\nint cn_handle_allocator_is_handle_valid(cn_handle_allocator_t* table, cn_handle_t handle)\n{\n\tcn_handle_entry_t* handles = table->handles;\n\tuint32_t table_index = s_table_index(handle);\n\tuint64_t generation = handle & 0xFFFFFFFF;\n\treturn handles[table_index].data.generation == generation;\n}\n\n// -------------------------------------------------------------------------------------------------\n\ncn_protocol_server_t* cn_protocol_server_create(uint64_t application_id, const cn_crypto_sign_public_t* public_key, const cn_crypto_sign_secret_t* secret_key, void* mem_ctx)\n{\n\tcn_protocol_server_t* server = (cn_protocol_server_t*)CN_ALLOC(sizeof(cn_protocol_server_t), mem_ctx);\n\tCN_MEMSET(server, 0, sizeof(cn_protocol_server_t));\n\n\tserver->running = 0;\n\tserver->application_id = application_id;\n\tserver->packet_allocator = cn_protocol_packet_allocator_create(mem_ctx);\n\tserver->event_queue = cn_circular_buffer_create(CN_MB * 10, mem_ctx);\n\tserver->public_key = *public_key;\n\tserver->secret_key = *secret_key;\n\tserver->mem_ctx = mem_ctx;\n\n\treturn server;\n}\n\nvoid cn_protocol_server_destroy(cn_protocol_server_t* server)\n{\n\tcn_simulator_destroy(server->sim);\n\tcn_protocol_packet_allocator_destroy(server->packet_allocator);\n\tcn_circular_buffer_free(&server->event_queue);\n\tCN_FREE(server, server->mem_ctx);\n}\n\ncn_result_t cn_protocol_server_start(cn_protocol_server_t* server, const char* address, uint32_t connection_timeout)\n{\n\tint cleanup_map = 0;\n\tint cleanup_cache = 0;\n\tint cleanup_socket = 0;\n\tint cleanup_endpoint_table = 0;\n\tint cleanup_client_id_table = 0;\n\tint ret = 0;\n\tcn_protocol_encryption_map_init(&server->encryption_map, server->mem_ctx);\n\tcleanup_map = 1;\n\tcn_protocol_connect_token_cache_init(&server->token_cache, CN_PROTOCOL_CONNECT_TOKEN_ENTRIES_MAX, server->mem_ctx);\n\tcleanup_cache = 1;\n\tif (cn_socket_init2(&server->socket, address, CN_PROTOCOL_SERVER_SEND_BUFFER_SIZE, CN_PROTOCOL_SERVER_RECEIVE_BUFFER_SIZE)) ret = -1;\n\tcleanup_socket = 1;\n\tcn_hashtable_init(&server->client_endpoint_table, sizeof(cn_endpoint_t), sizeof(uint64_t), CN_PROTOCOL_SERVER_MAX_CLIENTS, server->mem_ctx);\n\tcleanup_endpoint_table = 1;\n\tcn_hashtable_init(&server->client_id_table, sizeof(uint64_t), sizeof(int), CN_PROTOCOL_SERVER_MAX_CLIENTS, server->mem_ctx);\n\tcleanup_client_id_table = 1;\n\n\tserver->running = true;\n\tserver->challenge_nonce = 0;\n\tserver->client_count = 0;\n\tserver->connection_timeout = connection_timeout;\n\n\tif (ret) {\n\t\tif (cleanup_map) cn_protocol_encryption_map_cleanup(&server->encryption_map);\n\t\tif (cleanup_cache) cn_protocol_connect_token_cache_cleanup(&server->token_cache);\n\t\tif (cleanup_socket) cn_socket_cleanup(&server->socket);\n\t\tif (cleanup_endpoint_table) cn_hashtable_cleanup(&server->client_endpoint_table);\n\t\tif (cleanup_client_id_table) cn_hashtable_cleanup(&server->client_id_table);\n\t\treturn cn_error_failure(NULL); // -- Change this when socket_init is changed to use error_t.\n\t}\n\n\treturn cn_error_success();\n}\n\nCN_INLINE int s_protocol_server_event_pull(cn_protocol_server_t* server, cn_protocol_server_event_t* event)\n{\n\treturn cn_circular_buffer_pull(&server->event_queue, event, sizeof(cn_protocol_server_event_t));\n}\n\nCN_INLINE int s_protocol_server_event_push(cn_protocol_server_t* server, cn_protocol_server_event_t* event)\n{\n\tif (cn_circular_buffer_push(&server->event_queue, event, sizeof(cn_protocol_server_event_t)) < 0) {\n\t\tif (cn_circular_buffer_grow(&server->event_queue, server->event_queue.capacity * 2) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn cn_circular_buffer_push(&server->event_queue, event, sizeof(cn_protocol_server_event_t));\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic void s_protocol_server_disconnect_sequence(cn_protocol_server_t* server, uint32_t index)\n{\n\tfor (int i = 0; i < CN_PROTOCOL_DISCONNECT_REDUNDANT_PACKET_COUNT; ++i) {\n\t\tcn_protocol_packet_disconnect_t packet;\n\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_DISCONNECT;\n\t\tif (cn_protocol_packet_write(&packet, server->buffer, server->client_sequence[index]++, server->client_server_to_client_key + index) == 73) {\n\t\t\tcn_socket_send(&server->socket, server->sim, server->client_endpoint[index], server->buffer, 73);\n\t\t}\n\t}\n}\n\nstatic void s_protocol_server_disconnect_client(cn_protocol_server_t* server, uint32_t index, bool send_packets)\n{\n\tif (!server->client_is_connected[index]) {\n\t\treturn;\n\t}\n\n\tif (send_packets) {\n\t\ts_protocol_server_disconnect_sequence(server, index);\n\t}\n\n\t// Free client resources.\n\tserver->client_count--;\n\tserver->client_is_connected[index] = false;\n\tserver->client_is_confirmed[index] = false;\n\tcn_hashtable_remove(&server->client_id_table, server->client_id + index);\n\tcn_hashtable_remove(&server->client_endpoint_table, server->client_endpoint + index);\n\n\t// Create a user notification.\n\tcn_protocol_server_event_t event;\n\tevent.type = CN_PROTOCOL_SERVER_EVENT_DISCONNECTED;\n\tevent.u.disconnected.client_index = index;\n\ts_protocol_server_event_push(server, &event);\n}\n\nbool cn_protocol_server_pop_event(cn_protocol_server_t* server, cn_protocol_server_event_t* event)\n{\n\treturn s_protocol_server_event_pull(server, event) ? false : true;\n}\n\nvoid cn_protocol_server_free_packet(cn_protocol_server_t* server, void* packet)\n{\n\tcn_protocol_packet_payload_t* payload_packet = (cn_protocol_packet_payload_t*)((uint8_t*)packet - CN_OFFSET_OF(cn_protocol_packet_payload_t, payload));\n\tcn_protocol_packet_allocator_free(server->packet_allocator, (cn_protocol_packet_type_t)payload_packet->packet_type, payload_packet);\n}\n\nvoid cn_protocol_server_stop(cn_protocol_server_t* server)\n{\n\tserver->running = false;\n\n\tfor (int i = 0; i < CN_PROTOCOL_SERVER_MAX_CLIENTS; ++i) {\n\t\ts_protocol_server_disconnect_client(server, i, false);\n\t}\n\n\t// Free any lingering payload packets.\n\twhile (1) {\n\t\tcn_protocol_server_event_t event;\n\t\tif (s_protocol_server_event_pull(server, &event) < 0) break;\n\t\tif (event.type == CN_PROTOCOL_SERVER_EVENT_PAYLOAD_PACKET) {\n\t\t\tcn_protocol_server_free_packet(server, event.u.payload_packet.data);\n\t\t}\n\t}\n\n\tcn_protocol_encryption_map_cleanup(&server->encryption_map);\n\tcn_protocol_connect_token_cache_cleanup(&server->token_cache);\n\tcn_socket_cleanup(&server->socket);\n\tcn_hashtable_cleanup(&server->client_endpoint_table);\n\tcn_hashtable_cleanup(&server->client_id_table);\n\tcn_circular_buffer_reset(&server->event_queue);\n\n\tif (server->sim) {\n\t\tdouble latency = server->sim->latency;\n\t\tdouble jitter = server->sim->jitter;\n\t\tdouble drop_chance = server->sim->drop_chance;\n\t\tdouble duplicate_chance = server->sim->duplicate_chance;\n\t\tcn_simulator_destroy(server->sim);\n\t\tserver->sim = cn_simulator_create(&server->socket, server->mem_ctx);\n\t\tserver->sim->latency = latency;\n\t\tserver->sim->jitter = jitter;\n\t\tserver->sim->drop_chance = drop_chance;\n\t\tserver->sim->duplicate_chance = duplicate_chance;\n\t}\n}\n\nbool cn_protocol_server_running(cn_protocol_server_t* server)\n{\n\treturn server->running;\n}\n\nstatic void s_protocol_server_connect_client(cn_protocol_server_t* server, cn_endpoint_t endpoint, cn_protocol_encryption_state_t* state)\n{\n\tint index = -1;\n\tfor (int i = 0; i < CN_PROTOCOL_SERVER_MAX_CLIENTS; ++i) {\n\t\tif (!server->client_is_connected[i]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == -1) return;\n\n\tserver->client_count++;\n\tCN_ASSERT(server->client_count < CN_PROTOCOL_SERVER_MAX_CLIENTS);\n\n\tcn_protocol_server_event_t event;\n\tevent.type = CN_PROTOCOL_SERVER_EVENT_NEW_CONNECTION;\n\tevent.u.new_connection.client_index = index;\n\tevent.u.new_connection.client_id = state->client_id;\n\tevent.u.new_connection.endpoint = endpoint;\n\tif (s_protocol_server_event_push(server, &event) < 0) return;\n\n\tcn_hashtable_insert(&server->client_id_table, &state->client_id, &index);\n\tcn_hashtable_insert(&server->client_endpoint_table, &endpoint, &state->client_id);\n\n\tserver->client_id[index] = state->client_id;\n\tserver->client_is_connected[index] = true;\n\tserver->client_is_confirmed[index] = false;\n\tserver->client_last_packet_received_time[index] = 0;\n\tserver->client_last_packet_sent_time[index] = 0;\n\tserver->client_endpoint[index] = endpoint;\n\tserver->client_sequence[index] = state->sequence;\n\tserver->client_client_to_server_key[index] = state->client_to_server_key;\n\tserver->client_server_to_client_key[index] = state->server_to_client_key;\n\tcn_protocol_replay_buffer_init(&server->client_replay_buffer[index]);\n\n\tcn_protocol_connect_token_cache_add(&server->token_cache, state->signature.bytes);\n\tcn_protocol_encryption_map_remove(&server->encryption_map, endpoint);\n\n\tcn_protocol_packet_connection_accepted_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED;\n\tpacket.client_id = state->client_id;\n\tpacket.max_clients = CN_PROTOCOL_SERVER_MAX_CLIENTS;\n\tpacket.connection_timeout = server->connection_timeout;\n\tif (cn_protocol_packet_write(&packet, server->buffer, server->client_sequence[index]++, server->client_server_to_client_key + index) == 16 + 73) {\n\t\tcn_socket_send(&server->socket, server->sim, server->client_endpoint[index], server->buffer, 16 + 73);\n\t}\n}\n\nstatic void s_protocol_server_receive_packets(cn_protocol_server_t* server)\n{\n\tuint8_t* buffer = server->buffer;\n\n\twhile (1)\n\t{\n\t\tcn_endpoint_t from;\n\t\tint sz = cn_socket_receive(&server->socket, &from, buffer, CN_PROTOCOL_PACKET_SIZE_MAX);\n\t\tif (!sz) break;\n\n\t\tif (sz < 73) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint8_t type = *buffer;\n\t\tif (type > 7) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (type)\n\t\t{\n\t\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED: // fall-thru\n\t\tcase CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED: // fall-thru\n\t\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == CN_PROTOCOL_PACKET_TYPE_CONNECT_TOKEN) {\n\t\t\tif (sz != 1024) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcn_protocol_connect_token_decrypted_t token;\n\t\t\tif (cn_is_error(cn_protocol_server_decrypt_connect_token_packet(buffer, &server->public_key, &server->secret_key, server->application_id, server->current_time, &token))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcn_endpoint_t server_endpoint = server->socket.endpoint;\n\t\t\tif (server->use_developer_mode_public_ip) {\n\t\t\t\tserver_endpoint = server->developer_mode_public_ip;\n\t\t\t}\n\t\t\tint found = 0;\n\t\t\tfor (int i = 0; i < token.endpoint_count; ++i)\n\t\t\t{\n\t\t\t\tif (cn_endpoint_equals(server_endpoint, token.endpoints[i])) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) continue;\n\n\t\t\tint endpoint_already_connected = !!cn_hashtable_find(&server->client_endpoint_table, &from);\n\t\t\tif (endpoint_already_connected) continue;\n\n\t\t\tint client_id_already_connected = !!cn_hashtable_find(&server->client_id_table, &token.client_id);\n\t\t\tif (client_id_already_connected) continue;\n\n\t\t\tint token_already_in_use = !!cn_protocol_connect_token_cache_find(&server->token_cache, token.signature.bytes);\n\t\t\tif (token_already_in_use) continue;\n\n\t\t\tcn_protocol_encryption_state_t* state = cn_protocol_encryption_map_find(&server->encryption_map, from);\n\t\t\tif (!state) {\n\t\t\t\tcn_protocol_encryption_state_t encryption_state;\n\t\t\t\tencryption_state.sequence = 0;\n\t\t\t\tencryption_state.expiration_timestamp = token.expiration_timestamp;\n\t\t\t\tencryption_state.handshake_timeout = token.handshake_timeout;\n\t\t\t\tencryption_state.last_packet_recieved_time = 0;\n\t\t\t\tencryption_state.last_packet_sent_time = CN_PROTOCOL_SEND_RATE;\n\t\t\t\tencryption_state.client_to_server_key = token.client_to_server_key;\n\t\t\t\tencryption_state.server_to_client_key = token.server_to_client_key;\n\t\t\t\tencryption_state.client_id = token.client_id;\n\t\t\t\tCN_MEMCPY(encryption_state.signature.bytes, token.signature.bytes, CN_PROTOCOL_SIGNATURE_SIZE);\n\t\t\t\tcn_protocol_encryption_map_insert(&server->encryption_map, from, &encryption_state);\n\t\t\t\tstate = cn_protocol_encryption_map_find(&server->encryption_map, from);\n\t\t\t\tCN_ASSERT(state);\n\t\t\t}\n\n\t\t\tif (server->client_count == CN_PROTOCOL_SERVER_MAX_CLIENTS) {\n\t\t\t\tcn_protocol_packet_connection_denied_t packet;\n\t\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED;\n\t\t\t\tif (cn_protocol_packet_write(&packet, server->buffer, state->sequence++, &token.server_to_client_key) == 73) {\n\t\t\t\t\tcn_socket_send(&server->socket, server->sim, from, server->buffer, 73);\n\t\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to potential client (server is full).\", s_protocol_packet_str(packet.packet_type));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tuint64_t* client_id_ptr = (uint64_t*)cn_hashtable_find(&server->client_endpoint_table, &from);\n\t\t\tcn_protocol_replay_buffer_t* replay_buffer = NULL;\n\t\t\tconst cn_crypto_key_t* client_to_server_key;\n\t\t\tcn_protocol_encryption_state_t* state = NULL;\n\t\t\tuint32_t index = ~0u;\n\n\t\t\tint endpoint_already_connected = !!client_id_ptr;\n\t\t\tif (endpoint_already_connected) {\n\t\t\t\tif (type == CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE) {\n\t\t\t\t\t// Someone already connected with this address.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tindex = (uint32_t)*(int*)cn_hashtable_find(&server->client_id_table, client_id_ptr);\n\t\t\t\treplay_buffer = server->client_replay_buffer + index;\n\t\t\t\tclient_to_server_key = server->client_client_to_server_key + index;\n\t\t\t} else {\n\t\t\t\tstate = cn_protocol_encryption_map_find(&server->encryption_map, from);\n\t\t\t\tif (!state) continue;\n\t\t\t\tint connect_token_expired = state->expiration_timestamp <= server->current_time;\n\t\t\t\tif (connect_token_expired) {\n\t\t\t\t\tcn_protocol_encryption_map_remove(&server->encryption_map, from);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient_to_server_key = &state->client_to_server_key;\n\t\t\t}\n\n\t\t\tvoid* packet_ptr = cn_protocol_packet_open(buffer, sz, client_to_server_key, server->packet_allocator, replay_buffer, NULL);\n\t\t\tif (!packet_ptr) continue;\n\n\t\t\tint free_packet = 1;\n\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\tcase CN_PROTOCOL_PACKET_TYPE_KEEPALIVE:\n\t\t\t\tif (index == ~0u) break;\n\t\t\t\tserver->client_last_packet_received_time[index] = 0;\n\t\t\t\tif (!server->client_is_confirmed[index]) //log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Client %\" PRIu64 \" is now *confirmed*.\", server->client_id[index]);\n\t\t\t\tserver->client_is_confirmed[index] = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase CN_PROTOCOL_PACKET_TYPE_DISCONNECT:\n\t\t\t\tif (index == ~0u) break;\n\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Client %\" PRIu64 \" has sent the server a DISCONNECT packet.\", server->client_id[index]);\n\t\t\t\ts_protocol_server_disconnect_client(server, index, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase CN_PROTOCOL_PACKET_TYPE_CHALLENGE_RESPONSE:\n\t\t\t{\n\t\t\t\tCN_ASSERT(!endpoint_already_connected);\n\t\t\t\tint client_id_already_connected = !!cn_hashtable_find(&server->client_id_table, &state->client_id);\n\t\t\t\tif (client_id_already_connected) break;\n\t\t\t\tif (server->client_count == CN_PROTOCOL_SERVER_MAX_CLIENTS) {\n\t\t\t\t\tcn_protocol_packet_connection_denied_t packet;\n\t\t\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED;\n\t\t\t\t\tif (cn_protocol_packet_write(&packet, server->buffer, state->sequence++, &state->server_to_client_key) == 73) {\n\t\t\t\t\t\tcn_socket_send(&server->socket, server->sim, from, server->buffer, 73);\n\t\t\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to potential client (server is full).\", s_protocol_packet_str(packet.packet_type));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts_protocol_server_connect_client(server, from, state);\n\t\t\t\t}\n\t\t\t}\tbreak;\n\n\t\t\tcase CN_PROTOCOL_PACKET_TYPE_PAYLOAD:\n\t\t\t\tif (index == ~0u) break;\n\t\t\t\tserver->client_last_packet_received_time[index] = 0;\n\t\t\t\tif (!server->client_is_confirmed[index]) //log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Client %\" PRIu64 \" is now *confirmed*.\", server->client_id[index]);\n\t\t\t\tserver->client_is_confirmed[index] = 1;\n\t\t\t\tfree_packet = 0;\n\t\t\t\tcn_protocol_packet_payload_t* packet = (cn_protocol_packet_payload_t*)packet_ptr;\n\t\t\t\tcn_protocol_server_event_t event;\n\t\t\t\tevent.type = CN_PROTOCOL_SERVER_EVENT_PAYLOAD_PACKET;\n\t\t\t\tevent.u.payload_packet.client_index = index;\n\t\t\t\tevent.u.payload_packet.size = packet->payload_size;\n\t\t\t\tevent.u.payload_packet.data = packet->payload;\n\t\t\t\tif (s_protocol_server_event_push(server, &event) < 0) {\n\t\t\t\t\t//log(CN_LOG_LEVEL_WARNING, \"Protocol Server: Event queue is full; dropping payload packet for client %\" PRIu64 \".\", server->client_id[index]);\n\t\t\t\t\tfree_packet = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (free_packet) {\n\t\t\t\tcn_protocol_packet_allocator_free(server->packet_allocator, (cn_protocol_packet_type_t)type, packet_ptr);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void s_protocol_server_send_packets(cn_protocol_server_t* server, double dt)\n{\n\tCN_ASSERT(server->running);\n\n\t// Send challenge request packets.\n\tint state_count = cn_protocol_encryption_map_count(&server->encryption_map);\n\tcn_protocol_encryption_state_t* states = cn_protocol_encryption_map_get_states(&server->encryption_map);\n\tcn_endpoint_t* endpoints = cn_protocol_encryption_map_get_endpoints(&server->encryption_map);\n\tuint8_t* buffer = server->buffer;\n\tcn_socket_t* the_socket = &server->socket;\n\tcn_simulator_t* sim = server->sim;\n\tfor (int i = 0; i < state_count; ++i) {\n\t\tcn_protocol_encryption_state_t* state = states + i;\n\t\tstate->last_packet_sent_time += dt;\n\n\t\tif (state->last_packet_sent_time >= CN_PROTOCOL_SEND_RATE) {\n\t\t\tstate->last_packet_sent_time = 0;\n\n\t\t\tcn_protocol_packet_challenge_t packet;\n\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST;\n\t\t\tpacket.challenge_nonce = server->challenge_nonce++;\n\t\t\tcn_crypto_random_bytes(packet.challenge_data, sizeof(packet.challenge_data));\n\n\t\t\tif (cn_protocol_packet_write(&packet, buffer, state->sequence++, &state->server_to_client_key) == 264 + 73) {\n\t\t\t\tcn_socket_send(the_socket, sim, endpoints[i], buffer, 264 + 73);\n\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to potential client %\" PRIu64 \".\", s_protocol_packet_str(packet.packet_type), state->client_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update client timers.\n\tdouble* last_received_times = server->client_last_packet_received_time;\n\tdouble* last_sent_times = server->client_last_packet_sent_time;\n\tbool* connected = server->client_is_connected;\n\tfor (int i = 0; i < CN_PROTOCOL_SERVER_MAX_CLIENTS; ++i) {\n\t\tif (connected[i]) {\n\t\t\tlast_received_times[i] += dt;\n\t\t\tlast_sent_times[i] += dt;\n\t\t}\n\t}\n\n\t// Send keepalive packets.\n\tbool* confirmed = server->client_is_confirmed;\n\tuint64_t* sequences = server->client_sequence;\n\tcn_crypto_key_t* server_to_client_keys = server->client_server_to_client_key;\n\tcn_handle_t* ids = server->client_id;\n\tendpoints = server->client_endpoint;\n\tuint32_t connection_timeout = server->connection_timeout;\n\tfor (int i = 0; i < CN_PROTOCOL_SERVER_MAX_CLIENTS; ++i) {\n\t\tif (connected[i]) {\n\t\t\tif (last_sent_times[i] >= CN_PROTOCOL_SEND_RATE) {\n\t\t\t\tlast_sent_times[i] = 0;\n\n\t\t\t\tif (!confirmed[i]) {\n\t\t\t\t\tcn_protocol_packet_connection_accepted_t packet;\n\t\t\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED;\n\t\t\t\t\tpacket.client_id = ids[i];\n\t\t\t\t\tpacket.max_clients = CN_PROTOCOL_SERVER_MAX_CLIENTS;\n\t\t\t\t\tpacket.connection_timeout = connection_timeout;\n\t\t\t\t\tif (cn_protocol_packet_write(&packet, buffer, sequences[i]++, server_to_client_keys + i) == 16 + 73) {\n\t\t\t\t\t\tcn_socket_send(the_socket, sim, endpoints[i], buffer, 16 + 73);\n\t\t\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to client %\" PRIu64 \".\", s_protocol_packet_str(packet.packet_type), server->client_id[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcn_protocol_packet_keepalive_t packet;\n\t\t\t\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_KEEPALIVE;\n\t\t\t\tif (cn_protocol_packet_write(&packet, buffer, sequences[i]++, server_to_client_keys + i) == 73) {\n\t\t\t\t\tcn_socket_send(the_socket, sim, endpoints[i], buffer, 73);\n\t\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to client %\" PRIu64 \".\", s_protocol_packet_str(packet.packet_type), server->client_id[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid cn_protocol_server_disconnect_client(cn_protocol_server_t* server, int client_index, bool notify_client)\n{\n\tCN_ASSERT(server->client_count >= 1);\n\ts_protocol_server_disconnect_client(server, client_index, notify_client);\n}\n\ncn_result_t cn_protocol_server_send_to_client(cn_protocol_server_t* server, const void* packet, int size, int client_index)\n{\n\tif (size < 0) return cn_error_failure(\"`size` is negative.\");\n\tif (size > CN_PROTOCOL_PACKET_PAYLOAD_MAX) return cn_error_failure(\"`size` exceeds `CN_PROTOCOL_PACKET_PAYLOAD_MAX`.\");\n\tCN_ASSERT(server->client_count >= 1 && client_index >= 0 && client_index < CN_PROTOCOL_SERVER_MAX_CLIENTS);\n\n\tint index = client_index;\n\tif (!server->client_is_confirmed[index]) {\n\t\tcn_protocol_packet_connection_accepted_t conn_accepted_packet;\n\t\tconn_accepted_packet.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED;\n\t\tconn_accepted_packet.client_id = server->client_id[index];\n\t\tconn_accepted_packet.max_clients = CN_PROTOCOL_SERVER_MAX_CLIENTS;\n\t\tconn_accepted_packet.connection_timeout = server->connection_timeout;\n\t\tif (cn_protocol_packet_write(&conn_accepted_packet, server->buffer, server->client_sequence[index]++, server->client_server_to_client_key + index) == 16 + 73) {\n\t\t\tcn_socket_send(&server->socket, server->sim, server->client_endpoint[index], server->buffer, 16 + 73);\n\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to client %\" PRIu64 \".\", s_protocol_packet_str(packet.packet_type), server->client_id[index]);\n\t\t\tserver->client_last_packet_sent_time[index] = 0;\n\t\t} else {\n\t\t\treturn cn_error_failure(\"Failed to write packet.\");\n\t\t}\n\t}\n\n\tcn_protocol_packet_payload_t payload;\n\tpayload.packet_type = CN_PROTOCOL_PACKET_TYPE_PAYLOAD;\n\tpayload.payload_size = size;\n\tCN_MEMCPY(payload.payload, packet, size);\n\tint sz = cn_protocol_packet_write(&payload, server->buffer, server->client_sequence[index]++, server->client_server_to_client_key + index);\n\tif (sz > 73) {\n\t\tcn_socket_send(&server->socket, server->sim, server->client_endpoint[index], server->buffer, sz);\n\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Sent %s to client %\" PRIu64 \".\", s_protocol_packet_str(payload.packet_type), server->client_id[index]);\n\t\tserver->client_last_packet_sent_time[index] = 0;\n\t} else {\n\t\treturn cn_error_failure(\"Failed to write packet.\");\n\t}\n\n\treturn cn_error_success();\n}\n\nstatic void s_protocol_server_look_for_timeouts(cn_protocol_server_t* server)\n{\n\tdouble* last_received_times = server->client_last_packet_received_time;\n\tfor (int i = 0; i < CN_PROTOCOL_SERVER_MAX_CLIENTS;) {\n\t\tif (server->client_is_connected[i]) {\n\t\t\tif (last_received_times[i] >= (double)server->connection_timeout) {\n\t\t\t\t//log(CN_LOG_LEVEL_INFORMATIONAL, \"Protocol Server: Client %\" PRIu64 \" has timed out.\", server->client_id[i]);\n\t\t\t\tcn_protocol_server_disconnect_client(server, i, true);\n\t\t\t} else {\n\t\t\t\t ++i;\n\t\t\t}\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t}\n}\n\nvoid cn_protocol_server_update(cn_protocol_server_t* server, double dt, uint64_t current_time)\n{\n\tserver->current_time = current_time;\n\n\tcn_simulator_update(server->sim, dt);\n\ts_protocol_server_receive_packets(server);\n\ts_protocol_server_send_packets(server, dt);\n\ts_protocol_server_look_for_timeouts(server);\n}\n\nint cn_protocol_server_client_count(cn_protocol_server_t* server)\n{\n\treturn server->client_count;\n}\n\nuint64_t cn_protocol_server_get_client_id(cn_protocol_server_t* server, int client_index)\n{\n\tCN_ASSERT(server->client_count >= 1 && client_index >= 0 && client_index < CN_PROTOCOL_SERVER_MAX_CLIENTS);\n\treturn server->client_id[client_index];\n}\n\nbool cn_protocol_server_is_client_connected(cn_protocol_server_t* server, int client_index)\n{\n\treturn server->client_is_connected[client_index];\n}\n\nvoid cn_protocol_server_enable_network_simulator(cn_protocol_server_t* server, double latency, double jitter, double drop_chance, double duplicate_chance)\n{\n\tcn_simulator_t* sim = cn_simulator_create(&server->socket, server->mem_ctx);\n\tsim->latency = latency;\n\tsim->jitter = jitter;\n\tsim->drop_chance = drop_chance;\n\tsim->duplicate_chance = duplicate_chance;\n\tserver->sim = sim;\n}\n\n//--------------------------------------------------------------------------------------------------\n// RELIABILITY TRANSPORT\n\ntypedef struct cn_sequence_buffer_t\n{\n\tuint16_t sequence;\n\tint capacity;\n\tint stride;\n\tuint32_t* entry_sequence;\n\tuint8_t* entry_data;\n\tvoid* udata;\n\tvoid* mem_ctx;\n} cn_sequence_buffer_t;\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_ACK_SYSTEM_HEADER_SIZE (2 + 2 + 4)\n#define CN_ACK_SYSTEM_MAX_PACKET_SIZE 1180\n\ntypedef struct cn_ack_system_config_t\n{\n\tint max_packet_size;\n\tint initial_ack_capacity;\n\tint sent_packets_sequence_buffer_size;\n\tint received_packets_sequence_buffer_size;\n\n\tint index;\n\tcn_result_t (*send_packet_fn)(int client_index, void* packet, int size, void* udata);\n\n\tvoid* udata;\n\tvoid* user_allocator_context;\n} cn_ack_system_config_t;\n\ncn_ack_system_config_t cn_ack_system_config_defaults()\n{\n\tcn_ack_system_config_t config;\n\tconfig.max_packet_size = CN_ACK_SYSTEM_MAX_PACKET_SIZE;\n\tconfig.initial_ack_capacity = 1024;\n\tconfig.sent_packets_sequence_buffer_size = 1024;\n\tconfig.received_packets_sequence_buffer_size = 1024;\n\tconfig.index = -1;\n\tconfig.send_packet_fn = NULL;\n\tconfig.udata = NULL;\n\tconfig.user_allocator_context = NULL;\n\treturn config;\n}\n\ntypedef enum cn_ack_system_counter_t\n{\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_SENT,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_RECEIVED,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_ACKED,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_STALE,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_INVALID,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_TOO_LARGE_TO_SEND,\n\tCN_ACK_SYSTEM_COUNTERS_PACKETS_TOO_LARGE_TO_RECEIVE,\n\n\tCN_ACK_SYSTEM_COUNTERS_MAX\n} cn_ack_system_counter_t;\n\ntypedef struct cn_ack_system_t\n{\n\tdouble time;\n\tint max_packet_size;\n\n\tvoid* udata;\n\tvoid* mem_ctx;\n\n\tuint16_t sequence;\n\tint acks_count;\n\tint acks_capacity;\n\tuint16_t* acks;\n\tcn_sequence_buffer_t sent_packets;\n\tcn_sequence_buffer_t received_packets;\n\n\tdouble rtt;\n\tdouble packet_loss;\n\tdouble outgoing_bandwidth_kbps;\n\tdouble incoming_bandwidth_kbps;\n\n\tint index;\n\tcn_result_t (*send_packet_fn)(int client_index, void* packet, int size, void* udata);\n\n\tuint64_t counters[CN_ACK_SYSTEM_COUNTERS_MAX];\n} cn_ack_system_t;\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_TRANSPORT_HEADER_SIZE (1 + 2 + 2 + 2 + 2)\n#define CN_TRANSPORT_MAX_FRAGMENT_SIZE 1100\n#define CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES (1024)\n#define CN_TRANSPORT_PACKET_PAYLOAD_MAX (1200)\n\n#define CN_CHECK(X) if (X) ret = -1;\n\n#define CN_SEQUENCE_BUFFER_EMPTY (0xFFFFFFFF)\n\ntypedef void (cn_sequence_buffer_cleanup_entry_fn)(void* data, uint16_t sequence, void* udata, void* mem_ctx);\n\nvoid cn_sequence_buffer_remove(cn_sequence_buffer_t* buffer, uint16_t sequence, cn_sequence_buffer_cleanup_entry_fn* cleanup_fn)\n{\n\tint index = sequence % buffer->capacity;\n\tif (buffer->entry_sequence[index] != CN_SEQUENCE_BUFFER_EMPTY) {\n\t\tif (cleanup_fn) cleanup_fn(buffer->entry_data + buffer->stride * index, buffer->entry_sequence[index], buffer->udata, buffer->mem_ctx);\n\t\tbuffer->entry_sequence[index] = CN_SEQUENCE_BUFFER_EMPTY;\n\t}\n}\n\nvoid cn_sequence_buffer_reset(cn_sequence_buffer_t* buffer, cn_sequence_buffer_cleanup_entry_fn* cleanup_fn)\n{\n\tfor (int i = 0; i < buffer->capacity; ++i) {\n\t\tcn_sequence_buffer_remove(buffer, i, cleanup_fn);\n\t}\n\n\tbuffer->sequence = 0;\n\tCN_MEMSET(buffer->entry_sequence, CN_SEQUENCE_BUFFER_EMPTY, sizeof(uint32_t) * buffer->capacity);\n}\n\nint cn_sequence_buffer_init(cn_sequence_buffer_t* buffer, int capacity, int stride, void* udata, void* mem_ctx)\n{\n\tCN_MEMSET(buffer, 0, sizeof(cn_sequence_buffer_t));\n\tbuffer->capacity = capacity;\n\tbuffer->stride = stride;\n\tbuffer->entry_sequence = (uint32_t*)CN_ALLOC(sizeof(uint32_t) * capacity, mem_ctx);\n\tbuffer->entry_data = (uint8_t*)CN_ALLOC(stride * capacity, mem_ctx);\n\tbuffer->udata = udata;\n\tbuffer->mem_ctx = mem_ctx;\n\tCN_MEMSET(buffer->entry_sequence, CN_SEQUENCE_BUFFER_EMPTY, sizeof(uint32_t) * buffer->capacity);\n\tcn_sequence_buffer_reset(buffer, NULL);\n\treturn 0;\n}\n\nvoid cn_sequence_buffer_cleanup(cn_sequence_buffer_t* buffer, cn_sequence_buffer_cleanup_entry_fn* cleanup_fn)\n{\n\tfor (int i = 0; i < buffer->capacity; ++i) {\n\t\tcn_sequence_buffer_remove(buffer, i, cleanup_fn);\n\t}\n\n\tCN_FREE(buffer->entry_sequence, buffer->mem_ctx);\n\tCN_FREE(buffer->entry_data, buffer->mem_ctx);\n\tCN_MEMSET(buffer, 0, sizeof(cn_sequence_buffer_t));\n}\n\nstatic void s_sequence_buffer_remove_entries(cn_sequence_buffer_t* buffer, int sequence_a, int sequence_b, cn_sequence_buffer_cleanup_entry_fn* cleanup_fn)\n{\n\tif (sequence_b < sequence_a) sequence_b += 65536;\n\tif (sequence_b - sequence_a < buffer->capacity) {\n\t\tfor (int sequence = sequence_a; sequence <= sequence_b; ++sequence) {\n\t\t\tint index = sequence % buffer->capacity;\n\t\t\tif (cleanup_fn && buffer->entry_sequence[index] != CN_SEQUENCE_BUFFER_EMPTY) {\n\t\t\t\tcleanup_fn(buffer->entry_data + buffer->stride * index, buffer->entry_sequence[index], buffer->udata, buffer->mem_ctx);\n\t\t\t}\n\t\t\tbuffer->entry_sequence[index] = CN_SEQUENCE_BUFFER_EMPTY;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i < buffer->capacity; ++i) {\n\t\t\tif (cleanup_fn && buffer->entry_sequence[i] != CN_SEQUENCE_BUFFER_EMPTY) {\n\t\t\t\tcleanup_fn(buffer->entry_data + buffer->stride * i, buffer->entry_sequence[i], buffer->udata, buffer->mem_ctx);\n\t\t\t}\n\t\t\tbuffer->entry_sequence[i] = CN_SEQUENCE_BUFFER_EMPTY;\n\t\t}\n\t}\n}\n\nCN_INLINE int s_sequence_greater_than(uint16_t a, uint16_t b)\n{\n\treturn ((a > b) && (a - b <= 32768)) |\n\t       ((a < b) && (b - a  > 32768));\n}\n\nCN_INLINE int s_sequence_less_than(uint16_t a, uint16_t b)\n{\n\treturn s_sequence_greater_than(b, a);\n}\n\nCN_INLINE int s_sequence_is_stale(cn_sequence_buffer_t* buffer, uint16_t sequence)\n{\n\treturn s_sequence_less_than(sequence, buffer->sequence - ((uint16_t)buffer->capacity));\n}\n\nvoid* cn_sequence_buffer_insert(cn_sequence_buffer_t* buffer, uint16_t sequence, cn_sequence_buffer_cleanup_entry_fn* cleanup_fn)\n{\n\tif (s_sequence_greater_than(sequence + 1, buffer->sequence)) {\n\t\ts_sequence_buffer_remove_entries(buffer, buffer->sequence, sequence, cleanup_fn);\n\t\tbuffer->sequence = sequence + 1;\n\t} else if (s_sequence_is_stale(buffer, sequence)) {\n\t\treturn NULL;\n\t}\n\tint index = sequence % buffer->capacity;\n\tif (cleanup_fn && buffer->entry_sequence[index] != CN_SEQUENCE_BUFFER_EMPTY) {\n\t\tcleanup_fn(buffer->entry_data + buffer->stride * (sequence % buffer->capacity), buffer->entry_sequence[index], buffer->udata, buffer->mem_ctx);\n\t}\n\tbuffer->entry_sequence[index] = sequence;\n\treturn buffer->entry_data + index * buffer->stride;\n}\n\nint cn_sequence_buffer_is_empty(cn_sequence_buffer_t* sequence_buffer, uint16_t sequence)\n{\n\treturn sequence_buffer->entry_sequence[sequence % sequence_buffer->capacity] == CN_SEQUENCE_BUFFER_EMPTY;\n}\n\nvoid* cn_sequence_buffer_find(cn_sequence_buffer_t* sequence_buffer, uint16_t sequence)\n{\n\tint index = sequence % sequence_buffer->capacity;\n\treturn ((sequence_buffer->entry_sequence[index] == (uint32_t)sequence)) ? (sequence_buffer->entry_data + index * sequence_buffer->stride) : NULL;\n}\n\nvoid cn_sequence_buffer_generate_ack_bits(cn_sequence_buffer_t* sequence_buffer, uint16_t* ack, uint32_t* ack_bits)\n{\n\t*ack = sequence_buffer->sequence - 1;\n\t*ack_bits = 0;\n\tuint32_t mask = 1;\n\tfor (int i = 0; i < 32; ++i) {\n\t\tuint16_t sequence = *ack - ((uint16_t)i);\n\t\tif (cn_sequence_buffer_find(sequence_buffer, sequence)) {\n\t\t\t*ack_bits |= mask;\n\t\t}\n\t\tmask <<= 1;\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\n#define CN_PACKET_QUEUE_MAX_ENTRIES (1024)\n\ntypedef struct cn_packet_queue_t\n{\n\tint count;\n\tint index0;\n\tint index1;\n\tint sizes[CN_PACKET_QUEUE_MAX_ENTRIES];\n\tvoid* packets[CN_PACKET_QUEUE_MAX_ENTRIES];\n} cn_packet_queue_t;\n\nvoid cn_packet_queue_init(cn_packet_queue_t* q)\n{\n\tq->count = 0;\n\tq->index0 = 0;\n\tq->index1 = 0;\n}\n\nint cn_packet_queue_push(cn_packet_queue_t* q, void* packet, int size)\n{\n\tif (q->count >= CN_PACKET_QUEUE_MAX_ENTRIES) {\n\t\treturn -1;\n\t} else {\n\t\tq->count++;\n\t\tq->sizes[q->index1] = size;\n\t\tq->packets[q->index1] = packet;\n\t\tq->index1 = (q->index1 + 1) % CN_PACKET_QUEUE_MAX_ENTRIES;\n\t\treturn 0;\n\t}\n}\n\nint cn_packet_queue_pop(cn_packet_queue_t* q, void** packet, int* size)\n{\n\tif (q->count <= 0) {\n\t\treturn -1;\n\t} else {\n\t\tq->count--;\n\t\t*size = q->sizes[q->index0];\n\t\t*packet = q->packets[q->index0];\n\t\tq->index0 = (q->index0 + 1) % CN_PACKET_QUEUE_MAX_ENTRIES;\n\t\treturn 0;\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_socket_send_queue_item_t\n{\n\tuint16_t fragment_sequence;\n\tint fragment_index;\n\tint fragment_count;\n\tint final_fragment_size;\n\n\tint size;\n\tuint8_t* packet;\n} cn_socket_send_queue_item_t;\n\ntypedef struct cn_socket_send_queue_t\n{\n\tint count;\n\tint index0;\n\tint index1;\n\tcn_socket_send_queue_item_t items[CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES];\n} cn_socket_send_queue_t;\n\nstatic void s_send_queue_init(cn_socket_send_queue_t* q)\n{\n\tq->count = 0;\n\tq->index0 = 0;\n\tq->index1 = 0;\n}\n\nstatic int s_send_queue_push(cn_socket_send_queue_t* q, const cn_socket_send_queue_item_t* item)\n{\n\tCN_ASSERT(q->count >= 0);\n\tCN_ASSERT(q->index0 >= 0 && q->index0 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\tCN_ASSERT(q->index1 >= 0 && q->index1 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\n\tif (q->count < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES) {\n\t\tint next_index = (q->index1 + 1) % CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES;\n\t\tq->items[next_index] = *item;\n\t\tq->index1 = next_index;\n\t\t++q->count;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic void s_send_queue_pop(cn_socket_send_queue_t* q)\n{\n\tCN_ASSERT(q->count >= 0 && q->count <= CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\tCN_ASSERT(q->index0 >= 0 && q->index0 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\tCN_ASSERT(q->index1 >= 0 && q->index1 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\n\tint next_index = (q->index0 + 1) % CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES;\n\tq->index0 = next_index;\n\t--q->count;\n}\n\nstatic int s_send_queue_peek(cn_socket_send_queue_t* q, cn_socket_send_queue_item_t** item)\n{\n\tCN_ASSERT(q->count >= 0 && q->count <= CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\tCN_ASSERT(q->index0 >= 0 && q->index0 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\tCN_ASSERT(q->index1 >= 0 && q->index1 < CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES);\n\n\tif (q->count > 0) {\n\t\tint next_index = (q->index0 + 1) % CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES;\n\t\t*item = q->items + next_index;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic void s_send_queue_shutdown(cn_socket_send_queue_t* q, void* mem_ctx)\n{\n\twhile (q->count--) {\n\t\tint next_index = (q->index0 + 1) % CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES;\n\t\tcn_socket_send_queue_item_t* item = q->items + next_index;\n\t\tCN_FREE(item->packet, mem_ctx);\n\t\tq->index0 = next_index;\n\t}\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_fragment_t\n{\n\tuint64_t id;\n\tint index;\n\tdouble timestamp;\n\tuint8_t* data;\n\tint size;\n} cn_fragment_t;\n\ntypedef struct cn_fragment_reassembly_entry_t\n{\n\tint received_final_fragment;\n\tint packet_size;\n\tuint8_t* packet;\n\n\tint fragment_count_so_far;\n\tint fragments_total;\n\tuint8_t* fragment_received;\n} cn_fragment_reassembly_entry_t;\n\ntypedef struct cn_packet_assembly_t\n{\n\tuint16_t send_sequence;\n\tuint16_t receive_sequence;\n\tcn_sequence_buffer_t fragments_received;\n\tcn_packet_queue_t packets_received;\n} cn_packet_assembly_t;\n\nstatic void s_fragment_reassembly_entry_cleanup(void* data, uint16_t sequence, void* udata, void* mem_ctx)\n{\n\tcn_fragment_reassembly_entry_t* reassembly = (cn_fragment_reassembly_entry_t*)data;\n\tCN_FREE(reassembly->packet, mem_ctx);\n\tCN_FREE(reassembly->fragment_received, mem_ctx);\n}\n\nstatic int s_packet_assembly_init(cn_packet_assembly_t* assembly, int max_fragments_in_flight, void* mem_ctx)\n{\n\tint ret = 0;\n\tint reassembly_init = 0;\n\n\tassembly->send_sequence = 0;\n\tassembly->receive_sequence = 0;\n\n\tCN_CHECK(cn_sequence_buffer_init(&assembly->fragments_received, max_fragments_in_flight, sizeof(cn_fragment_reassembly_entry_t), NULL, mem_ctx));\n\treassembly_init = 1;\n\tcn_packet_queue_init(&assembly->packets_received);\n\n\tif (ret) {\n\t\tif (reassembly_init) cn_sequence_buffer_cleanup(&assembly->fragments_received, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic void s_packet_assembly_cleanup(cn_packet_assembly_t* assembly)\n{\n\tcn_sequence_buffer_cleanup(&assembly->fragments_received, s_fragment_reassembly_entry_cleanup);\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_transport_t\n{\n\tfloat resend_rate;\n\tint fragment_size;\n\tint max_packet_size;\n\tint max_fragments_in_flight;\n\tint max_size_single_send;\n\n\tcn_socket_send_queue_t send_queue;\n\n\tint fragments_count;\n\tint fragments_capacity;\n\tcn_fragment_t* fragments;\n\tcn_ack_system_t* ack_system;\n\tcn_sequence_buffer_t sent_fragments;\n\tuint64_t fragment_id_gen;\n\tuint16_t oldest_received_sequence;\n\tcn_packet_assembly_t reliable_and_in_order_assembly;\n\tcn_packet_assembly_t fire_and_forget_assembly;\n\n\tvoid* mem_ctx;\n\tvoid* udata;\n\n\tuint8_t fire_and_forget_buffer[CN_TRANSPORT_MAX_FRAGMENT_SIZE + CN_TRANSPORT_HEADER_SIZE];\n} cn_transport_t;\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_sent_packet_t\n{\n\tdouble timestamp;\n\tint acked;\n\tint size;\n} cn_sent_packet_t;\n\ntypedef struct cn_received_packet_t\n{\n\tdouble timestamp;\n\tint size;\n} cn_received_packet_t;\n\ncn_ack_system_t* cn_ack_system_create(cn_ack_system_config_t config)\n{\n\tint ret = 0;\n\tint sent_packets_init = 0;\n\tint received_packets_init = 0;\n\tvoid* mem_ctx = config.user_allocator_context;\n\n\tif (!config.send_packet_fn) return NULL;\n\tif (config.max_packet_size > CN_TRANSPORT_PACKET_PAYLOAD_MAX) return NULL;\n\n\tcn_ack_system_t* ack_system = (cn_ack_system_t*)CN_ALLOC(sizeof(cn_ack_system_t), mem_ctx);\n\tif (!ack_system) return NULL;\n\n\tack_system->time = 0;\n\tack_system->max_packet_size = config.max_packet_size;\n\tack_system->index = config.index;\n\tack_system->send_packet_fn = config.send_packet_fn;\n\tack_system->udata = config.udata;\n\tack_system->mem_ctx = config.user_allocator_context;\n\n\tack_system->sequence = 0;\n\tack_system->acks_count = 0;\n\tack_system->acks_capacity = config.initial_ack_capacity;\n\tack_system->acks = (uint16_t*)CN_ALLOC(sizeof(uint16_t) * ack_system->acks_capacity, mem_ctx);\n\tCN_CHECK(cn_sequence_buffer_init(&ack_system->sent_packets, config.sent_packets_sequence_buffer_size, sizeof(cn_sent_packet_t), NULL, mem_ctx));\n\tsent_packets_init = 1;\n\tCN_CHECK(cn_sequence_buffer_init(&ack_system->received_packets, config.received_packets_sequence_buffer_size, sizeof(cn_received_packet_t), NULL, mem_ctx));\n\treceived_packets_init = 1;\n\n\tack_system->rtt = 0;\n\tack_system->packet_loss = 0;\n\tack_system->outgoing_bandwidth_kbps = 0;\n\tack_system->incoming_bandwidth_kbps = 0;\n\n\tfor (int i = 0; i < CN_ACK_SYSTEM_COUNTERS_MAX; ++i) {\n\t\tack_system->counters[i] = 0;\n\t}\n\n\tif (ret) {\n\t\tif (ack_system) {\n\t\t\tif (sent_packets_init) cn_sequence_buffer_cleanup(&ack_system->sent_packets, NULL);\n\t\t\tif (received_packets_init) cn_sequence_buffer_cleanup(&ack_system->received_packets, NULL);\n\t\t}\n\t\tCN_FREE(ack_system->acks, mem_ctx);\n\t\tCN_FREE(ack_system, mem_ctx);\n\t}\n\n\treturn ret ? NULL : ack_system;\n}\n\nvoid cn_ack_system_destroy(cn_ack_system_t* ack_system)\n{\n\tif (!ack_system) return;\n\tvoid* mem_ctx = ack_system->mem_ctx;\n\tcn_sequence_buffer_cleanup(&ack_system->sent_packets, NULL);\n\tcn_sequence_buffer_cleanup(&ack_system->received_packets, NULL);\n\tCN_FREE(ack_system->acks, mem_ctx);\n\tCN_FREE(ack_system, mem_ctx);\n}\n\nvoid cn_ack_system_reset(cn_ack_system_t* ack_system)\n{\n\tack_system->sequence = 0;\n\tack_system->acks_count = 0;\n\tcn_sequence_buffer_reset(&ack_system->sent_packets, NULL);\n\tcn_sequence_buffer_reset(&ack_system->received_packets, NULL);\n\n\tack_system->rtt = 0;\n\tack_system->packet_loss = 0;\n\tack_system->outgoing_bandwidth_kbps = 0;\n\tack_system->incoming_bandwidth_kbps = 0;\n\n\tfor (int i = 0; i < CN_ACK_SYSTEM_COUNTERS_MAX; ++i) {\n\t\tack_system->counters[i] = 0;\n\t}\n}\n\nstatic int s_write_ack_system_header(uint8_t* buffer, uint16_t sequence, uint16_t ack, uint32_t ack_bits)\n{\n\tuint8_t* buffer_start = buffer;\n\tcn_write_uint16(&buffer, sequence);\n\tcn_write_uint16(&buffer, ack);\n\tcn_write_uint32(&buffer, ack_bits);\n\treturn (int)(buffer - buffer_start);\n}\n\ncn_result_t cn_ack_system_send_packet(cn_ack_system_t* ack_system, void* data, int size, uint16_t* sequence_out)\n{\n\tif (size > ack_system->max_packet_size || size > CN_ACK_SYSTEM_MAX_PACKET_SIZE) {\n\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_TOO_LARGE_TO_SEND]++;\n\t\treturn cn_error_failure(\"Exceeded max packet size in ack system.\");\n\t}\n\n\tuint16_t sequence = ack_system->sequence++;\n\tuint16_t ack;\n\tuint32_t ack_bits;\n\n\tcn_sequence_buffer_generate_ack_bits(&ack_system->received_packets, &ack, &ack_bits);\n\tcn_sent_packet_t* packet = (cn_sent_packet_t*)cn_sequence_buffer_insert(&ack_system->sent_packets, sequence, NULL);\n\tCN_ASSERT(packet);\n\n\tpacket->timestamp = ack_system->time;\n\tpacket->acked = 0;\n\tpacket->size = size + CN_ACK_SYSTEM_HEADER_SIZE;\n\n\tuint8_t buffer[CN_TRANSPORT_PACKET_PAYLOAD_MAX];\n\tint header_size = s_write_ack_system_header(buffer, sequence, ack, ack_bits);\n\tCN_ASSERT(header_size == CN_ACK_SYSTEM_HEADER_SIZE);\n\tCN_ASSERT(size + header_size < CN_TRANSPORT_PACKET_PAYLOAD_MAX);\n\tCN_MEMCPY(buffer + header_size, data, size);\n\tif (sequence_out) *sequence_out = sequence;\n\tcn_result_t result = ack_system->send_packet_fn(ack_system->index, buffer, size + header_size, ack_system->udata);\n\tif (cn_is_error(result)) {\n\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_INVALID]++;\n\t\treturn result;\n\t}\n\n\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_SENT]++;\n\n\treturn cn_error_success();\n}\n\nuint16_t cn_ack_system_get_sequence(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->sequence;\n}\n\nstatic int s_read_ack_system_header(uint8_t* buffer, int size, uint16_t* sequence, uint16_t* ack, uint32_t* ack_bits)\n{\n\tif (size < CN_ACK_SYSTEM_HEADER_SIZE) return -1;\n\tuint8_t* buffer_start = buffer;\n\t*sequence = cn_read_uint16(&buffer);\n\t*ack = cn_read_uint16(&buffer);\n\t*ack_bits = cn_read_uint32(&buffer);\n\treturn (int)(buffer - buffer_start);\n}\n\ncn_result_t cn_ack_system_receive_packet(cn_ack_system_t* ack_system, void* data, int size)\n{\n\tif (size > ack_system->max_packet_size || size > CN_ACK_SYSTEM_MAX_PACKET_SIZE) {\n\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_TOO_LARGE_TO_RECEIVE]++;\n\t\treturn cn_error_failure(\"Exceeded max packet size in ack system.\");\n\t}\n\n\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_RECEIVED]++;\n\n\tuint16_t sequence;\n\tuint16_t ack;\n\tuint32_t ack_bits;\n\tuint8_t* buffer = (uint8_t*)data;\n\n\tint header_size = s_read_ack_system_header(buffer, size, &sequence, &ack, &ack_bits);\n\tif (header_size < 0) {\n\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_INVALID]++;\n\t\treturn cn_error_failure(\"Failed to write ack header.\");\n\t}\n\tCN_ASSERT(header_size == CN_ACK_SYSTEM_HEADER_SIZE);\n\n\tif (s_sequence_is_stale(&ack_system->received_packets, sequence)) {\n\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_STALE]++;\n\t\treturn cn_error_failure(\"The provided sequence number was stale.\");\n\t}\n\n\tcn_received_packet_t* packet = (cn_received_packet_t*)cn_sequence_buffer_insert(&ack_system->received_packets, sequence, NULL);\n\tCN_ASSERT(packet);\n\tpacket->timestamp = ack_system->time;\n\tpacket->size = size;\n\n\tfor (int i = 0; i < 32; ++i) {\n\t\tint bit_was_set = ack_bits & 1;\n\t\tack_bits >>= 1;\n\n\t\tif (bit_was_set) {\n\t\t\tuint16_t ack_sequence = ack - ((uint16_t)i);\n\t\t\tcn_sent_packet_t* sent_packet = (cn_sent_packet_t*)cn_sequence_buffer_find(&ack_system->sent_packets, ack_sequence);\n\n\t\t\tif (sent_packet && !sent_packet->acked) {\n\t\t\t\tCN_CHECK_BUFFER_GROW(ack_system, acks_count, acks_capacity, acks, uint16_t);\n\t\t\t\tack_system->acks[ack_system->acks_count++] = ack_sequence;\n\t\t\t\tack_system->counters[CN_ACK_SYSTEM_COUNTERS_PACKETS_ACKED]++;\n\t\t\t\tsent_packet->acked = 1;\n\n\t\t\t\tfloat rtt = (float)(ack_system->time - sent_packet->timestamp) * 1000.0f;\n\t\t\t\tif (ack_system->rtt == 0.0f && rtt > 0.0f) ack_system->rtt = rtt;\n\t\t\t\telse ack_system->rtt += (rtt - ack_system->rtt) * 0.001f;\n\t\t\t\tCN_ASSERT(ack_system->rtt >= 0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cn_error_success();\n}\n\nuint16_t* cn_ack_system_get_acks(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->acks;\n}\n\nint cn_ack_system_get_acks_count(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->acks_count;\n}\n\nvoid cn_ack_system_clear_acks(cn_ack_system_t* ack_system)\n{\n\tack_system->acks_count = 0;\n}\n\nCN_INLINE double s_calc_packet_loss(double packet_loss, cn_sequence_buffer_t* sent_packets)\n{\n\tint packet_drop_count = 0;\n\tuint32_t base_sequence = (sent_packets->sequence - sent_packets->capacity + 1) + 0xFFFF;\n\tint num_dropped = 0;\n\tint num_samples = sent_packets->capacity / 2;\n\n\tfor (int i = 0; i < num_samples; ++i) {\n\t\tuint16_t sequence = (uint16_t)(base_sequence + i);\n\t\tcn_sent_packet_t* packet = (cn_sent_packet_t*)cn_sequence_buffer_find(sent_packets, sequence);\n\t\tif (packet) {\n\t\t\tif (!packet->acked) packet_drop_count++;\n\t\t}\n\t}\n\n\tdouble loss = (double)packet_drop_count / (double)num_samples;\n\tif (packet_loss == 0) packet_loss = loss;\n\telse packet_loss += (loss - packet_loss) * 0.1;\n\tCN_ASSERT(packet_loss >= 0);\n\treturn packet_loss;\n}\n\n#include <float.h>\n\nCN_INLINE double s_calc_bandwidth(double bandwidth, cn_sequence_buffer_t* packets)\n{\n\tint bytes_sent = 0;\n\tuint32_t base_sequence = (packets->sequence - packets->capacity + 1) + 0xFFFF;\n\tint num_samples = packets->capacity / 2;\n\tdouble start_timestamp = DBL_MAX;\n\tdouble end_timestamp = 0;\n\n\tfor (int i = 0; i < num_samples; ++i) {\n\t\tuint16_t sequence = (uint16_t)(base_sequence + i);\n\t\tcn_sent_packet_t* packet = (cn_sent_packet_t*)cn_sequence_buffer_find(packets, sequence);\n\t\tif (packet) {\n\t\t\tbytes_sent += packet->size;\n\t\t\tif (packet->timestamp < start_timestamp) start_timestamp = packet->timestamp;\n\t\t\tif (packet->timestamp > end_timestamp) end_timestamp = packet->timestamp;\n\t\t}\n\t}\n\n\tif (start_timestamp != DBL_MAX) {\n\t\tdouble divisor = end_timestamp - start_timestamp;\n\t\tif (divisor > 1.0e-6) {\n\t\t\tdouble sent_bandwidth = (((double)bytes_sent * 8.0) / 1000.0) / divisor;\n\t\t\tbandwidth += (sent_bandwidth - bandwidth) * 0.1f;\n\t\t\tif (bandwidth < 0) bandwidth = 0;\n\t\t}\n\t}\n\n\treturn bandwidth;\n}\n\nvoid cn_ack_system_update(cn_ack_system_t* ack_system, double dt)\n{\n\tack_system->time += dt;\n\tack_system->packet_loss = s_calc_packet_loss(ack_system->packet_loss, &ack_system->sent_packets);\n\tack_system->incoming_bandwidth_kbps = s_calc_bandwidth(ack_system->incoming_bandwidth_kbps, &ack_system->sent_packets);\n\tack_system->outgoing_bandwidth_kbps = s_calc_bandwidth(ack_system->outgoing_bandwidth_kbps, &ack_system->received_packets);\n}\n\ndouble cn_ack_system_rtt(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->rtt;\n}\n\ndouble cn_ack_system_packet_loss(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->packet_loss;\n}\n\ndouble cn_ack_system_bandwidth_outgoing_kbps(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->outgoing_bandwidth_kbps;\n}\n\ndouble cn_ack_system_bandwidth_incoming_kbps(cn_ack_system_t* ack_system)\n{\n\treturn ack_system->incoming_bandwidth_kbps;\n}\n\nuint64_t cn_ack_system_get_counter(cn_ack_system_t* ack_system, cn_ack_system_counter_t counter)\n{\n\treturn ack_system->counters[counter];\n}\n\n// -------------------------------------------------------------------------------------------------\n\ntypedef struct cn_transport_config_t\n{\n\tvoid* mem_ctx;\n\tfloat resend_rate;\n\tint fragment_size;\n\tint max_packet_size;\n\tint max_fragments_in_flight;\n\tint max_size_single_send;\n\tint send_receive_queue_size;\n\tvoid* user_allocator_context;\n\tvoid* udata;\n\n\tint index;\n\tcn_result_t (*send_packet_fn)(int client_index, void* packet, int size, void* udata);\n} cn_transport_config_t;\n\nCN_INLINE cn_transport_config_t cn_transport_config_defaults()\n{\n\tcn_transport_config_t config;\n\tconfig.mem_ctx = 0;\n\tconfig.resend_rate = 0.1f;\n\tconfig.fragment_size = CN_TRANSPORT_MAX_FRAGMENT_SIZE;\n\tconfig.max_packet_size = CN_TRANSPORT_MAX_FRAGMENT_SIZE * 4;\n\tconfig.max_fragments_in_flight = 32;\n\tconfig.max_size_single_send = (CN_MB) * 20;\n\tconfig.send_receive_queue_size = 1024;\n\tconfig.udata = NULL;\n\tconfig.index = -1;\n\tconfig.send_packet_fn = NULL;\n\treturn config;\n}\n\ncn_transport_t* cn_transport_create(cn_transport_config_t config)\n{\n\tif (!config.send_packet_fn) return NULL;\n\n\tint ret = 0;\n\tint table_init = 0;\n\tint sequence_sent_fragments_init = 0;\n\tint assembly_reliable_init = 0;\n\tint assembly_unreliable_init = 0;\n\n\tcn_transport_t* transport = (cn_transport_t*)CN_ALLOC(sizeof(cn_transport_t), config.user_allocator_context);\n\tif (!transport) return NULL;\n\ttransport->resend_rate = config.resend_rate;\n\ttransport->fragment_size = config.fragment_size;\n\ttransport->max_packet_size = config.max_packet_size;\n\ttransport->max_fragments_in_flight = config.max_fragments_in_flight;\n\ttransport->max_size_single_send = config.max_size_single_send;\n\ttransport->udata = config.udata;\n\n\ttransport->fragments_capacity = 256;\n\ttransport->fragments_count = 0;\n\ttransport->fragments = (cn_fragment_t*)CN_ALLOC(sizeof(cn_fragment_t) * transport->fragments_capacity, config.mem_ctx);\n\n\tcn_ack_system_config_t ack_config = cn_ack_system_config_defaults();\n\tack_config.index = config.index;\n\tack_config.send_packet_fn = config.send_packet_fn;\n\tack_config.udata = config.udata;\n\ttransport->ack_system = cn_ack_system_create(ack_config);\n\ttransport->mem_ctx = config.user_allocator_context;\n\n\tCN_CHECK(cn_sequence_buffer_init(&transport->sent_fragments, config.send_receive_queue_size, sizeof(uint64_t), transport, transport->mem_ctx));\n\tsequence_sent_fragments_init = 1;\n\n\ttransport->fragment_id_gen = 0;\n\ttransport->oldest_received_sequence = 0;\n\tCN_CHECK(s_packet_assembly_init(&transport->reliable_and_in_order_assembly, config.send_receive_queue_size, transport->mem_ctx));\n\tassembly_reliable_init = 1;\n\tCN_CHECK(s_packet_assembly_init(&transport->fire_and_forget_assembly, config.send_receive_queue_size, transport->mem_ctx));\n\tassembly_unreliable_init = 1;\n\n\ts_send_queue_init(&transport->send_queue);\n\n\tif (ret) {\n\t\tif (sequence_sent_fragments_init) cn_sequence_buffer_cleanup(&transport->sent_fragments, NULL);\n\t\tif (assembly_reliable_init) s_packet_assembly_cleanup(&transport->reliable_and_in_order_assembly);\n\t\tif (assembly_unreliable_init) s_packet_assembly_cleanup(&transport->fire_and_forget_assembly);\n\t\tCN_FREE(transport, config.user_allocator_context);\n\t}\n\n\treturn ret ? NULL : transport;\n}\n\nstatic void s_transport_cleanup_packet_queue(cn_transport_t* transport, cn_packet_queue_t* q)\n{\n\tint index = q->index0;\n\twhile (q->count--) {\n\t\tint next_index = index + 1 % CN_PACKET_QUEUE_MAX_ENTRIES;\n\t\tCN_FREE(q->packets[index], transport->mem_ctx);\n\t\tindex = next_index;\n\t}\n}\n\nvoid cn_transport_destroy(cn_transport_t* transport)\n{\n\tif (!transport) return;\n\tvoid* mem_ctx = transport->mem_ctx;\n\n\ts_transport_cleanup_packet_queue(transport, &transport->reliable_and_in_order_assembly.packets_received);\n\ts_transport_cleanup_packet_queue(transport, &transport->fire_and_forget_assembly.packets_received);\n\n\tcn_sequence_buffer_cleanup(&transport->sent_fragments, NULL);\n\ts_packet_assembly_cleanup(&transport->reliable_and_in_order_assembly);\n\ts_packet_assembly_cleanup(&transport->fire_and_forget_assembly);\n\tfor (int i = 0; i < transport->fragments_count; ++i) {\n\t\tcn_fragment_t* fragment = transport->fragments + i;\n\t\tCN_FREE(fragment->data, mem_ctx);\n\t}\n\tCN_FREE(transport->fragments, mem_ctx);\n\ts_send_queue_shutdown(&transport->send_queue, transport->mem_ctx);\n\tcn_ack_system_destroy(transport->ack_system);\n\tCN_FREE(transport, mem_ctx);\n}\n\nCN_INLINE int s_transport_write_header(uint8_t* buffer, int size, uint8_t prefix, uint16_t sequence, uint16_t fragment_count, uint16_t fragment_index, uint16_t fragment_size)\n{\n\tif (size < CN_TRANSPORT_HEADER_SIZE) return -1;\n\tuint8_t* buffer_start = buffer;\n\tcn_write_uint8(&buffer, prefix);\n\tcn_write_uint16(&buffer, sequence);\n\tcn_write_uint16(&buffer, fragment_count);\n\tcn_write_uint16(&buffer, fragment_index);\n\tcn_write_uint16(&buffer, fragment_size);\n\treturn (int)(buffer - buffer_start);\n}\n\nstatic cn_result_t s_transport_send_fragments(cn_transport_t* transport)\n{\n\tCN_ASSERT(transport->fragments_count <= transport->max_fragments_in_flight);\n\tif (transport->fragments_count == transport->max_fragments_in_flight) {\n\t\treturn cn_error_failure(\"Too many fragments already in flight.\");\n\t}\n\n\tdouble timestamp = transport->ack_system->time;\n\tint fragments_space_available_send = transport->max_fragments_in_flight - transport->fragments_count;\n\tint fragment_size = transport->fragment_size;\n\n\twhile (fragments_space_available_send) {\n\t\tcn_socket_send_queue_item_t* item;\n\t\tif (s_send_queue_peek(&transport->send_queue, &item) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tuint8_t* data_ptr = item->packet + item->fragment_index * fragment_size;\n\t\tint fragment_count_left = item->fragment_count - item->fragment_index;\n\t\tint fragment_count_to_send = fragments_space_available_send < fragment_count_left ? fragments_space_available_send : fragment_count_left;\n\t\tCN_ASSERT(item->fragment_index + fragment_count_to_send <= item->fragment_count);\n\n\t\tfor (int i = 0; i < fragment_count_to_send; ++i) {\n\t\t\t// Allocate fragment.\n\t\t\tuint16_t fragment_header_index = (uint16_t)(item->fragment_index + i);\n\t\t\tint this_fragment_size = fragment_header_index != item->fragment_count - 1 ? fragment_size : item->final_fragment_size;\n\t\t\tuint8_t* fragment_src = data_ptr + fragment_size * i;\n\t\t\tCN_ASSERT(this_fragment_size <= CN_ACK_SYSTEM_MAX_PACKET_SIZE);\n\t\t\tCN_ASSERT(this_fragment_size > 0);\n\n\t\t\tint fragment_index = transport->fragments_count;\n\t\t\tCN_CHECK_BUFFER_GROW(transport, fragments_count, fragments_capacity, fragments, cn_fragment_t);\n\t\t\tcn_fragment_t* fragment = transport->fragments + transport->fragments_count++;\n\n\t\t\tfragment->id = transport->fragment_id_gen++;\n\t\t\tfragment->index = fragment_header_index;\n\t\t\tfragment->timestamp = timestamp;\n\t\t\tfragment->data = (uint8_t*)CN_ALLOC(fragment_size + CN_TRANSPORT_HEADER_SIZE, transport->mem_ctx);\n\t\t\tfragment->size = this_fragment_size;\n\t\t\t// TODO: Memory pool on sent fragments.\n\n\t\t\t// Write the transport header.\n\t\t\tint header_size = s_transport_write_header(fragment->data, this_fragment_size + CN_TRANSPORT_HEADER_SIZE, 1, item->fragment_sequence, item->fragment_count, fragment_header_index, (uint16_t)this_fragment_size);\n\t\t\tif (header_size != CN_TRANSPORT_HEADER_SIZE) {\n\t\t\t\tCN_FREE(fragment->data, transport->mem_ctx);\n\t\t\t\ttransport->fragments_count--;\n\t\t\t\treturn cn_error_failure(\"Failed to write transport header.\");\n\t\t\t}\n\n\t\t\t// Copy over the `data` from user.\n\t\t\tCN_MEMCPY(fragment->data + header_size, fragment_src, this_fragment_size);\n\n\t\t\t// Send to ack system.\n\t\t\tuint16_t ack_sequence;\n\t\t\tCN_PRINTF(\"Sent reliable sequence %d.\\n\", item->fragment_sequence);\n\t\t\tcn_result_t result = cn_ack_system_send_packet(transport->ack_system, fragment->data, this_fragment_size + CN_TRANSPORT_HEADER_SIZE, &ack_sequence);\n\t\t\tif (cn_is_error(result)) {\n\t\t\t\tCN_FREE(fragment->data, transport->mem_ctx);\n\t\t\t\ttransport->fragments_count--;\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// If all succeeds, record fragment entry. Hopefully it will be acked later.\n\t\t\t// If ack'd it will be remove from the transport->fragments array.\n\t\t\tuint64_t* fragment_id_ptr = (uint64_t*)cn_sequence_buffer_insert(&transport->sent_fragments, ack_sequence, NULL);\n\t\t\tCN_ASSERT(fragment_id_ptr);\n\t\t\t*fragment_id_ptr = fragment->id;\n\t\t}\n\n\t\tif (item->fragment_index + fragment_count_to_send == item->fragment_count) {\n\t\t\ts_send_queue_pop(&transport->send_queue);\n\t\t\tCN_FREE(item->packet, transport->mem_ctx);\n\t\t} else {\n\t\t\titem->fragment_index += fragment_count_to_send;\n\t\t}\n\n\t\tfragments_space_available_send -= fragment_count_to_send;\n\t}\n\n\treturn cn_error_success();\n}\n\ncn_result_t s_transport_send_reliably(cn_transport_t* transport, const void* data, int size)\n{\n\tif (size < 0) return cn_error_failure(\"Negative `size` not allowed.\");\n\tif (size > transport->max_size_single_send) return cn_error_failure(\"`size` exceeded `max_size_single_send` from `transport->config`.\");\n\tif (transport->send_queue.count == CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES) {\n\t\treturn cn_error_failure(\"Send queue for reliable packets is full. Increase `CN_TRANSPORT_SEND_QUEUE_MAX_ENTRIES` or send packets less frequently.\");\n\t}\n\n\tint fragment_size = transport->fragment_size;\n\tint fragment_count = size / fragment_size;\n\tint final_fragment_size = size - (fragment_count * fragment_size);\n\tif (final_fragment_size > 0) fragment_count++;\n\telse final_fragment_size = fragment_size;\n\n\tcn_socket_send_queue_item_t send_item;\n\tsend_item.fragment_sequence = transport->reliable_and_in_order_assembly.send_sequence++;\n\tsend_item.fragment_index = 0;\n\tsend_item.fragment_count = fragment_count;\n\tsend_item.final_fragment_size = final_fragment_size;\n\tsend_item.size = size;\n\tsend_item.packet = (uint8_t*)CN_ALLOC(size, transport->mem_ctx);\n\tCN_MEMCPY(send_item.packet, data, size);\n\ts_send_queue_push(&transport->send_queue, &send_item);\n\n\treturn cn_error_success();\n}\n\ncn_result_t s_transport_send(cn_transport_t* transport, const void* data, int size)\n{\n\tif (size < 0) return cn_error_failure(\"Negative `size` is not valid.\");\n\tif (size > transport->max_size_single_send) return cn_error_failure(\"`size` exceeded `max_size_single_send` config param.\");\n\n\tint fragment_size = transport->fragment_size;\n\tint fragment_count = size / fragment_size;\n\tint final_fragment_size = size - (fragment_count * fragment_size);\n\tif (final_fragment_size > 0) fragment_count++;\n\n\tuint16_t fragment_sequence = transport->fire_and_forget_assembly.send_sequence++;\n\tuint8_t* buffer = transport->fire_and_forget_buffer;\n\n\tuint8_t* data_ptr = (uint8_t*)data;\n\tfor (int i = 0; i < fragment_count; ++i) {\n\t\tint this_fragment_size = i != fragment_count - 1 ? fragment_size : final_fragment_size;\n\t\tuint8_t* fragment_src = data_ptr + fragment_size * i;\n\t\tCN_ASSERT(this_fragment_size <= CN_ACK_SYSTEM_MAX_PACKET_SIZE);\n\n\t\t// Write the transport header.\n\t\t//CN_PRINTF(\"Sending fragment sequence %d.\\n\", fragment_sequence);\n\t\tint header_size = s_transport_write_header(buffer, this_fragment_size + CN_TRANSPORT_HEADER_SIZE, 0, fragment_sequence, fragment_count, (uint16_t)i, (uint16_t)this_fragment_size);\n\t\tif (header_size != CN_TRANSPORT_HEADER_SIZE) {\n\t\t\tCN_ASSERT(false);\n\t\t\treturn cn_error_failure(\"Failed writing transport header -- incorrect size of bytes written (this is probably a bug).\");\n\t\t}\n\n\t\t// Copy over fragment data from src.\n\t\tCN_MEMCPY(buffer + CN_TRANSPORT_HEADER_SIZE, fragment_src, this_fragment_size);\n\n\t\t// Send to ack system.\n\t\tcn_result_t result = cn_ack_system_send_packet(transport->ack_system, buffer, this_fragment_size + CN_TRANSPORT_HEADER_SIZE, NULL);\n\t\tif (cn_is_error(result)) {\n\t\t\tCN_ASSERT(false);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn cn_error_success();\n}\n\ncn_result_t cn_transport_send(cn_transport_t* transport, const void* data, int size, bool send_reliably)\n{\n\tif (send_reliably) {\n\t\treturn s_transport_send_reliably(transport, data, size);\n\t} else {\n\t\treturn s_transport_send(transport, data, size);\n\t}\n}\n\ncn_result_t cn_transport_receive_reliably_and_in_order(cn_transport_t* transport, void** data, int* size)\n{\n\tcn_packet_assembly_t* assembly = &transport->reliable_and_in_order_assembly;\n\tif (cn_packet_queue_pop(&assembly->packets_received, data, size) < 0) {\n\t\t*data = NULL;\n\t\t*size = 0;\n\t\treturn cn_error_failure(\"No data.\");\n\t} else {\n\t\treturn cn_error_success();\n\t}\n}\n\ncn_result_t cn_transport_receive_fire_and_forget(cn_transport_t* transport, void** data, int* size)\n{\n\tcn_packet_assembly_t* assembly = &transport->fire_and_forget_assembly;\n\tif (cn_packet_queue_pop(&assembly->packets_received, data, size) < 0) {\n\t\t*data = NULL;\n\t\t*size = 0;\n\t\treturn cn_error_failure(\"No data.\");\n\t} else {\n\t\treturn cn_error_success();\n\t}\n}\n\nvoid cn_transport_free_packet(cn_transport_t* transport, void* data)\n{\n\tCN_FREE(data, transport->mem_ctx);\n}\n\ncn_result_t cn_transport_process_packet(cn_transport_t* transport, void* data, int size)\n{\n\tif (size < CN_TRANSPORT_HEADER_SIZE) return cn_error_failure(\"`size` is too small to fit `CN_TRANSPORT_HEADER_SIZE`.\");\n\tcn_result_t result = cn_ack_system_receive_packet(transport->ack_system, data, size);\n\tif (cn_is_error(result)) return result;\n\n\t// Read transport header.\n\tuint8_t* buffer = (uint8_t*)data + CN_ACK_SYSTEM_HEADER_SIZE;\n\tuint8_t prefix = cn_read_uint8(&buffer);\n\tuint16_t fragment_sequence = cn_read_uint16(&buffer);\n\tuint16_t fragment_count = cn_read_uint16(&buffer);\n\tuint16_t fragment_index = cn_read_uint16(&buffer);\n\tuint16_t fragment_size = cn_read_uint16(&buffer);\n\tint total_packet_size = fragment_count * transport->fragment_size;\n\tCN_PRINTF(\"Arrived: fragment sequence %d.\\n\", fragment_sequence);\n\n\tif (total_packet_size > transport->max_size_single_send) {\n\t\treturn cn_error_failure(\"Packet exceeded `max_size_single_send` limit.\");\n\t}\n\n\tif (fragment_index > fragment_count) {\n\t\treturn cn_error_failure(\"Fragment index out of bounds.\");\n\t}\n\n\tif (fragment_size > transport->fragment_size) {\n\t\treturn cn_error_failure(\"Fragment size somehow didn't match `transport->fragment_size`.\");\n\t}\n\n\tcn_packet_assembly_t* assembly;\n\tif (prefix) {\n\t\tassembly = &transport->reliable_and_in_order_assembly;\n\t\tif (s_sequence_less_than(fragment_sequence, assembly->receive_sequence)) {\n\t\t\treturn cn_error_failure(\"Sequence is too old.\");\n\t\t}\n\t} else {\n\t\tassembly = &transport->fire_and_forget_assembly;\n\t}\n\n\t// Build reassembly if it doesn't exist yet.\n\tcn_fragment_reassembly_entry_t* reassembly = (cn_fragment_reassembly_entry_t*)cn_sequence_buffer_find(&assembly->fragments_received, fragment_sequence);\n\tif (!reassembly) {\n\t\treassembly = (cn_fragment_reassembly_entry_t*)cn_sequence_buffer_insert(&assembly->fragments_received, fragment_sequence, s_fragment_reassembly_entry_cleanup);\n\t\tif (!reassembly) {\n\t\t\tCN_PRINTF(\"Sequence for this reassembly is stale.\\n\");\n\t\t\treturn cn_error_failure(\"Sequence for this reassembly is stale.\");\n\t\t} else {\n\t\t\tCN_PRINTF(\"Found fragment sequence %d.\\n\", fragment_sequence);\n\t\t}\n\t\treassembly->received_final_fragment = 0;\n\t\treassembly->packet_size = total_packet_size;\n\t\treassembly->packet = (uint8_t*)CN_ALLOC(total_packet_size, transport->mem_ctx);\n\t\treassembly->fragment_count_so_far = 0;\n\t\treassembly->fragments_total = fragment_count;\n\t\treassembly->fragment_received = (uint8_t*)CN_ALLOC(fragment_count, transport->mem_ctx);\n\t\tCN_MEMSET(reassembly->fragment_received, 0, fragment_count);\n\t}\n\n\tif (fragment_count != reassembly->fragments_total) {\n\t\treturn cn_error_failure(\"Full packet not yet received.\");\n\t}\n\n\tif (reassembly->fragment_received[fragment_index]) {\n\t\treturn cn_error_success();\n\t}\n\n\t// Copy in fragment pieces into a single large packet buffer.\n\treassembly->fragment_count_so_far++;\n\treassembly->fragment_received[fragment_index] = 1;\n\n\tuint8_t* packet_fragment = reassembly->packet + fragment_index * transport->fragment_size;\n\tCN_MEMCPY(packet_fragment, buffer, fragment_size);\n\n\tif (fragment_index == fragment_count - 1) {\n\t\treassembly->received_final_fragment = 1;\n\t\treassembly->packet_size -= transport->fragment_size - fragment_size;\n\t\ttotal_packet_size -= transport->fragment_size - fragment_size;\n\t}\n\n\t// Store completed packet for retrieval by user.\n\tresult = cn_error_success();\n\tif (reassembly->fragment_count_so_far == fragment_count) {\n\t\t// Fire and forget packets can be immediately pushed onto the receive queue.\n\t\tif (!prefix) {\n\t\t\tif (cn_packet_queue_push(&assembly->packets_received, reassembly->packet, reassembly->packet_size) < 0) {\n\t\t\t\tresult = cn_error_failure(\"Packet dropped. The other end is sending too many packets.\");\n\t\t\t} else {\n\t\t\t\t//CN_PRINTF(\"Remove unreliable fragment sequence %d.\\n\", fragment_sequence);\n\t\t\t\treassembly->packet = NULL;\n\t\t\t\tcn_sequence_buffer_remove(&assembly->fragments_received, fragment_sequence, s_fragment_reassembly_entry_cleanup);\n\t\t\t}\n\t\t}\n\n\t\t// We just assembled a new reliable packet. We could have received more packets out of order ahead of this sequence.\n\t\t// Look for more finished packets and push them into the receive queue.\n\t\tif (fragment_sequence == assembly->receive_sequence) {\n\t\t\twhile (prefix) {\n\t\t\t\tcn_fragment_reassembly_entry_t* next = (cn_fragment_reassembly_entry_t*)cn_sequence_buffer_find(&assembly->fragments_received, assembly->receive_sequence);\n\t\t\t\tif (next) {\n\t\t\t\t\tif (next->fragment_count_so_far == next->fragments_total) {\n\t\t\t\t\t\tif (cn_packet_queue_push(&assembly->packets_received, next->packet, next->packet_size) < 0) {\n\t\t\t\t\t\t\tresult =  cn_error_failure(\"Packet dropped. The other end is sending too many packets.\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext->packet = NULL;\n\t\t\t\t\t\t\tCN_PRINTF(\"Remove reliable fragment sequence %d.\\n\", assembly->receive_sequence);\n\t\t\t\t\t\t\tcn_sequence_buffer_remove(&assembly->fragments_received, assembly->receive_sequence, s_fragment_reassembly_entry_cleanup);\n\t\t\t\t\t\t\tassembly->receive_sequence++;\n\t\t\t\t\t\t\tCN_ASSERT(assembly->receive_sequence <= assembly->fragments_received.sequence);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvoid cn_transport_remove_flight_fragment(cn_transport_t* transport, uint64_t fragment_id)\n{\n\tfor (int j = 0; j < transport->fragments_count; ++j) {\n\t\tif (transport->fragments[j].id == fragment_id) {\n\t\t\tCN_FREE(transport->fragments[j].data, transport->mem_ctx);\n\t\t\ttransport->fragments[j] = transport->fragments[--transport->fragments_count];\n\t\t}\n\t}\n}\n\nvoid cn_transport_process_acks(cn_transport_t* transport)\n{\n\tuint16_t* acks = cn_ack_system_get_acks(transport->ack_system);\n\tint acks_count = cn_ack_system_get_acks_count(transport->ack_system);\n\n\tfor (int i = 0; i < acks_count; ++i) {\n\t\tuint16_t sequence = acks[i];\n\t\tuint64_t* fragment_id_ptr = (uint64_t*)cn_sequence_buffer_find(&transport->sent_fragments, sequence);\n\t\tif (fragment_id_ptr) {\n\t\t\tcn_transport_remove_flight_fragment(transport, *fragment_id_ptr);\n\t\t\tcn_sequence_buffer_remove(&transport->sent_fragments, sequence, NULL);\n\t\t}\n\t}\n\n\tcn_ack_system_clear_acks(transport->ack_system);\n}\n\nvoid cn_transport_send_fragments(cn_transport_t* transport)\n{\n\t// Resend unacked fragments which were previously sent.\n\tdouble timestamp = transport->ack_system->time;\n\tcn_fragment_t* fragments = transport->fragments;\n\n\tfor (int i = 0; i < transport->fragments_count;) {\n\t\tcn_fragment_t* fragment = fragments + i;\n\t\tif (fragment->timestamp + transport->resend_rate >= timestamp) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Send to ack system.\n\t\tuint16_t sequence;\n\t\tcn_result_t result = cn_ack_system_send_packet(transport->ack_system, fragment->data, fragment->size + CN_TRANSPORT_HEADER_SIZE, &sequence);\n\t\tif (cn_is_error(result)) {\n\t\t\t// Remove failed fragments (this should never happen, and is only here for safety).\n\t\t\tCN_FREE(fragment->data, transport->mem_ctx);\n\t\t\ttransport->fragments[i] = transport->fragments[--transport->fragments_count];\n\t\t\tCN_ASSERT(false);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t ++i;\n\t\t}\n\n\t\tuint64_t* fragment_id_ptr = (uint64_t*)cn_sequence_buffer_insert(&transport->sent_fragments, sequence, NULL);\n\t\tCN_ASSERT(fragment_id_ptr);\n\t\t*fragment_id_ptr = fragment->id;\n\t\tfragment->timestamp = timestamp;\n\t}\n\n\t// Send off any available fragments from the send queue.\n\ts_transport_send_fragments(transport);\n}\n\nint cn_transport_unacked_fragment_count(cn_transport_t* transport)\n{\n\treturn transport->fragments_count;\n}\n\nvoid cn_transport_update(cn_transport_t* transport, double dt)\n{\n\tcn_ack_system_update(transport->ack_system, dt);\n\tcn_transport_process_acks(transport);\n\tcn_transport_send_fragments(transport);\n}\n\n//--------------------------------------------------------------------------------------------------\n// CLIENT\n\nstruct cn_client_t\n{\n\tcn_protocol_client_t* p_client;\n\tcn_transport_t* transport;\n\tvoid* mem_ctx;\n};\n\nstatic cn_result_t s_send(int client_index, void* packet, int size, void* udata)\n{\n\tcn_client_t* client = (cn_client_t*)udata;\n\treturn cn_protocol_client_send(client->p_client, packet, size);\n}\n\ncn_client_t* cn_client_create(uint16_t port, uint64_t application_id, bool use_ipv6, void* user_allocator_context)\n{\n\tcn_result_t result = s_cn_init_check();\n\tif (cn_is_error(result)) return NULL;\n\n\tcn_protocol_client_t* p_client = cn_protocol_client_create(port, application_id, use_ipv6, user_allocator_context);\n\tif (!p_client) return NULL;\n\n\tcn_client_t* client = (cn_client_t*)CN_ALLOC(sizeof(cn_client_t), user_allocator_context);\n\tCN_MEMSET(client, 0, sizeof(*client));\n\tclient->p_client = p_client;\n\tclient->mem_ctx = user_allocator_context;\n\n\tcn_transport_config_t config = cn_transport_config_defaults();\n\tconfig.send_packet_fn = s_send;\n\tconfig.user_allocator_context = user_allocator_context;\n\tconfig.udata = client;\n\tclient->transport = cn_transport_create(config);\n\n\treturn client;\n}\n\nvoid cn_client_destroy(cn_client_t* client)\n{\n\tif (!client) return;\n\tcn_protocol_client_destroy(client->p_client);\n\tcn_transport_destroy(client->transport);\n\tvoid* mem_ctx = client->mem_ctx;\n\tCN_FREE(client, mem_ctx);\n}\n\ncn_result_t cn_client_connect(cn_client_t* client, const uint8_t* connect_token)\n{\n\treturn cn_protocol_client_connect(client->p_client, connect_token);\n}\n\nvoid cn_client_disconnect(cn_client_t* client)\n{\n\tcn_protocol_client_disconnect(client->p_client);\n}\n\nvoid cn_client_update(cn_client_t* client, double dt, uint64_t current_time)\n{\n\tcn_protocol_client_update(client->p_client, dt, current_time);\n\n\tif (cn_protocol_client_get_state(client->p_client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) {\n\t\tcn_transport_update(client->transport, dt);\n\n\t\tvoid* packet;\n\t\tint size;\n\t\tuint64_t sequence;\n\t\twhile (cn_protocol_client_get_packet(client->p_client, &packet, &size, &sequence)) {\n\t\t\tcn_transport_process_packet(client->transport, packet, size);\n\t\t\tcn_protocol_client_free_packet(client->p_client, packet);\n\t\t}\n\t}\n}\n\nbool cn_client_pop_packet(cn_client_t* client, void** packet, int* size, bool* was_sent_reliably)\n{\n\tif (cn_protocol_client_get_state(client->p_client) != CN_PROTOCOL_CLIENT_STATE_CONNECTED) {\n\t\treturn false;\n\t}\n\n\tbool got = !cn_is_error(cn_transport_receive_reliably_and_in_order(client->transport, packet, size));\n\tif (was_sent_reliably && got) *was_sent_reliably = true;\n\tif (!got) {\n\t\tgot = !cn_is_error(cn_transport_receive_fire_and_forget(client->transport, packet, size));\n\t\tif (was_sent_reliably) *was_sent_reliably = false;\n\t}\n\treturn got;\n}\n\nvoid cn_client_free_packet(cn_client_t* client, void* packet)\n{\n\tcn_transport_free_packet(client->transport, packet);\n}\n\ncn_result_t cn_client_send(cn_client_t* client, const void* packet, int size, bool send_reliably)\n{\n\tif (size <= 0) {\n\t\treturn cn_error_failure(\"Empty packets are now allowed.\");\n\t}\n\tif (cn_protocol_client_get_state(client->p_client) != CN_PROTOCOL_CLIENT_STATE_CONNECTED) {\n\t\treturn cn_error_failure(\"Client is not connected.\");\n\t}\n\treturn cn_transport_send(client->transport, packet, size, send_reliably);\n}\n\ncn_client_state_t cn_client_state_get(const cn_client_t* client)\n{\n\treturn (cn_client_state_t)cn_protocol_client_get_state(client->p_client);\n}\n\nconst char* cn_client_state_string(cn_client_state_t state)\n{\n\tswitch (state) {\n\tcase CN_CLIENT_STATE_CONNECT_TOKEN_EXPIRED: return \"CN_CLIENT_STATE_CONNECT_TOKEN_EXPIRED\";\n\tcase CN_CLIENT_STATE_INVALID_CONNECT_TOKEN: return \"CN_CLIENT_STATE_INVALID_CONNECT_TOKEN\";\n\tcase CN_CLIENT_STATE_CONNECTION_TIMED_OUT: return \"CN_CLIENT_STATE_CONNECTION_TIMED_OUT\";\n\tcase CN_CLIENT_STATE_CHALLENGE_RESPONSE_TIMED_OUT: return \"CN_CLIENT_STATE_CHALLENGE_RESPONSE_TIMED_OUT\";\n\tcase CN_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT: return \"CN_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT\";\n\tcase CN_CLIENT_STATE_CONNECTION_DENIED: return \"CN_CLIENT_STATE_CONNECTION_DENIED\";\n\tcase CN_CLIENT_STATE_DISCONNECTED: return \"CN_CLIENT_STATE_DISCONNECTED\";\n\tcase CN_CLIENT_STATE_SENDING_CONNECTION_REQUEST: return \"CN_CLIENT_STATE_SENDING_CONNECTION_REQUEST\";\n\tcase CN_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE: return \"CN_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE\";\n\tcase CN_CLIENT_STATE_CONNECTED: return \"CN_CLIENT_STATE_CONNECTED\";\n\t}\n\tCN_ASSERT(false);\n\treturn NULL;\n}\n\nvoid cn_client_enable_network_simulator(cn_client_t* client, double latency, double jitter, double drop_chance, double duplicate_chance)\n{\n\tcn_protocol_client_enable_network_simulator(client->p_client, latency, jitter, drop_chance, duplicate_chance);\n}\n\nfloat cn_client_get_packet_loss_estimate(cn_client_t* client)\n{\n\treturn (float)client->transport->ack_system->packet_loss;\n}\n\nfloat cn_client_get_rtt_estimate(cn_client_t* client)\n{\n\treturn (float)client->transport->ack_system->rtt;\n}\n\nfloat cn_client_get_incoming_kbps_estimate(cn_client_t* client)\n{\n\treturn (float)client->transport->ack_system->incoming_bandwidth_kbps;\n}\n\nfloat cn_client_get_outgoing_kbps_estimate(cn_client_t* client)\n{\n\treturn (float)client->transport->ack_system->outgoing_bandwidth_kbps;\n}\n\n//--------------------------------------------------------------------------------------------------\n// SERVER\n\nstruct cn_server_t\n{\n\tbool running;\n\tcn_endpoint_t endpoint;\n\tcn_crypto_sign_public_t public_key;\n\tcn_crypto_sign_secret_t secret_key;\n\tcn_server_config_t config;\n\tcn_socket_t socket;\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\tcn_circular_buffer_t event_queue;\n\tcn_transport_t* client_transports[CN_SERVER_MAX_CLIENTS];\n\tcn_protocol_server_t* p_server;\n\tvoid* mem_ctx;\n};\n\nstatic cn_result_t s_send_packet_fn(int client_index, void* packet, int size, void* udata)\n{\n\tcn_server_t* server = (cn_server_t*)udata;\n\treturn cn_protocol_server_send_to_client(server->p_server, packet, size, client_index);\n}\n\ncn_server_t* cn_server_create(cn_server_config_t config)\n{\n\tcn_result_t result = s_cn_init_check();\n\tif (cn_is_error(result)) return NULL;\n\n\tcn_server_t* server = (cn_server_t*)CN_ALLOC(sizeof(cn_server_t), config.user_allocator_context);\n\tCN_MEMSET(server, 0, sizeof(*server));\n\tserver->mem_ctx = config.user_allocator_context;\n\tserver->config = config;\n\tserver->event_queue = cn_circular_buffer_create(CN_MB * 10, config.user_allocator_context);\n\tserver->p_server = cn_protocol_server_create(config.application_id, &server->config.public_key, &server->config.secret_key, server->mem_ctx);\n\n\treturn server;\n}\n\nvoid cn_server_destroy(cn_server_t* server)\n{\n\tif (!server) return;\n\tcn_server_stop(server);\n\tcn_protocol_server_destroy(server->p_server);\n\tvoid* mem_ctx = server->mem_ctx;\n\tcn_circular_buffer_free(&server->event_queue);\n\tCN_FREE(server, mem_ctx);\n}\n\ncn_result_t cn_server_start(cn_server_t* server, const char* address_and_port)\n{\n\tcn_result_t result = cn_protocol_server_start(server->p_server, address_and_port, (uint32_t)server->config.connection_timeout);\n\tif (cn_is_error(result)) return result;\n\n\tfor (int i = 0; i < CN_SERVER_MAX_CLIENTS; ++i) {\n\t\tcn_transport_config_t transport_config = cn_transport_config_defaults();\n\t\ttransport_config.index = i;\n\t\ttransport_config.send_packet_fn = s_send_packet_fn;\n\t\ttransport_config.udata = server;\n\t\ttransport_config.user_allocator_context = server->mem_ctx;\n\t\tserver->client_transports[i] = cn_transport_create(transport_config);\n\t}\n\n\treturn cn_error_success();\n}\n\nvoid cn_server_stop(cn_server_t* server)\n{\n\tif (!server) return;\n\tcn_circular_buffer_reset(&server->event_queue);\n\tcn_protocol_server_stop(server->p_server);\n\tfor (int i = 0; i < CN_SERVER_MAX_CLIENTS; ++i) {\n\t\tcn_transport_destroy(server->client_transports[i]);\n\t\tserver->client_transports[i] = NULL;\n\t}\n}\n\nCN_INLINE int s_server_event_pull(cn_server_t* server, cn_server_event_t* event)\n{\n\treturn cn_circular_buffer_pull(&server->event_queue, event, sizeof(cn_server_event_t));\n}\n\nCN_INLINE int s_server_event_push(cn_server_t* server, cn_server_event_t* event)\n{\n\tif (cn_circular_buffer_push(&server->event_queue, event, sizeof(cn_server_event_t)) < 0) {\n\t\tif (cn_circular_buffer_grow(&server->event_queue, server->event_queue.capacity * 2) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn cn_circular_buffer_push(&server->event_queue, event, sizeof(cn_server_event_t));\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nvoid cn_server_update(cn_server_t* server, double dt, uint64_t current_time)\n{\n\t// Update the protocol server.\n\tcn_protocol_server_update(server->p_server, dt, current_time);\n\n\t// Capture any events from the protocol server and process them.\n\tcn_protocol_server_event_t p_event;\n\tbool packet_queue_full = false;\n\twhile (cn_protocol_server_pop_event(server->p_server, &p_event)) {\n\t\tswitch (p_event.type) {\n\t\tcase CN_PROTOCOL_SERVER_EVENT_NEW_CONNECTION:\n\t\t{\n\t\t\tcn_server_event_t e;\n\t\t\te.type = CN_SERVER_EVENT_TYPE_NEW_CONNECTION;\n\t\t\te.u.new_connection.client_index = p_event.u.new_connection.client_index;\n\t\t\te.u.new_connection.client_id = p_event.u.new_connection.client_id;\n\t\t\te.u.new_connection.endpoint = p_event.u.new_connection.endpoint;\n\t\t\ts_server_event_push(server, &e);\n\t\t}\tbreak;\n\n\t\tcase CN_PROTOCOL_SERVER_EVENT_DISCONNECTED:\n\t\t{\n\t\t\tcn_server_event_t e;\n\t\t\te.type = CN_SERVER_EVENT_TYPE_DISCONNECTED;\n\t\t\te.u.disconnected.client_index = p_event.u.disconnected.client_index;\n\t\t\ts_server_event_push(server, &e);\n\t\t\tcn_transport_destroy(server->client_transports[e.u.disconnected.client_index]);\n\t\t\tcn_transport_config_t transport_config = cn_transport_config_defaults();\n\t\t\ttransport_config.resend_rate = (float)server->config.resend_rate;\n\t\t\ttransport_config.index = e.u.disconnected.client_index;\n\t\t\ttransport_config.send_packet_fn = s_send_packet_fn;\n\t\t\ttransport_config.udata = server;\n\t\t\ttransport_config.user_allocator_context = server->mem_ctx;\n\t\t\tserver->client_transports[e.u.disconnected.client_index] = cn_transport_create(transport_config);\n\t\t}\tbreak;\n\n\t\t// Protocol packets are processed by the reliability transport layer before they\n\t\t// are converted into user-facing server events.\n\t\tcase CN_PROTOCOL_SERVER_EVENT_PAYLOAD_PACKET:\n\t\t{\n\t\t\tint index = p_event.u.payload_packet.client_index;\n\t\t\tvoid* data = p_event.u.payload_packet.data;\n\t\t\tint size = p_event.u.payload_packet.size;\n\t\t\tcn_result_t result = cn_transport_process_packet(server->client_transports[index], data, size);\n\t\t\tcn_protocol_server_free_packet(server->p_server, data);\n\t\t\tpacket_queue_full = cn_is_error(result);\n\t\t}\tbreak;\n\t\t}\n\t}\n\n\t// Update all client reliability transports.\n \tfor (int i = 0; i < CN_SERVER_MAX_CLIENTS; ++i) {\n\t\tif (cn_protocol_server_is_client_connected(server->p_server, i)) {\n\t\t\tcn_transport_update(server->client_transports[i], dt);\n\t\t}\n\t}\n\n\t// Look for any packets to receive from the reliability layer.\n\t// Convert these into server payload events.\n\tfor (int i = 0; i < CN_SERVER_MAX_CLIENTS; ++i) {\n\t\tif (cn_protocol_server_is_client_connected(server->p_server, i)) {\n\t\t\tvoid* data;\n\t\t\tint size;\n\t\t\twhile (!cn_is_error(cn_transport_receive_reliably_and_in_order(server->client_transports[i], &data, &size))) {\n\t\t\t\tcn_server_event_t e;\n\t\t\t\te.type = CN_SERVER_EVENT_TYPE_PAYLOAD_PACKET;\n\t\t\t\te.u.payload_packet.client_index = i;\n\t\t\t\te.u.payload_packet.data = data;\n\t\t\t\te.u.payload_packet.size = size;\n\t\t\t\ts_server_event_push(server, &e);\n\t\t\t}\n\t\t\twhile (!cn_is_error(cn_transport_receive_fire_and_forget(server->client_transports[i], &data, &size))) {\n\t\t\t\tcn_server_event_t e;\n\t\t\t\te.type = CN_SERVER_EVENT_TYPE_PAYLOAD_PACKET;\n\t\t\t\te.u.payload_packet.client_index = i;\n\t\t\t\te.u.payload_packet.data = data;\n\t\t\t\te.u.payload_packet.size = size;\n\t\t\t\ts_server_event_push(server, &e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool cn_server_pop_event(cn_server_t* server, cn_server_event_t* event)\n{\n\treturn s_server_event_pull(server, event) ? false : true;\n}\n\nvoid cn_server_free_packet(cn_server_t* server, int client_index, void* data)\n{\n\tCN_ASSERT(client_index >= 0 && client_index < CN_SERVER_MAX_CLIENTS);\n\tCN_ASSERT(cn_protocol_server_is_client_connected(server->p_server, client_index));\n\tcn_transport_free_packet(server->client_transports[client_index], data);\n}\n\nvoid cn_server_disconnect_client(cn_server_t* server, int client_index, bool notify_client)\n{\n\tCN_ASSERT(client_index >= 0 && client_index < CN_SERVER_MAX_CLIENTS);\n\tCN_ASSERT(cn_protocol_server_is_client_connected(server->p_server, client_index));\n\tcn_protocol_server_disconnect_client(server->p_server, client_index, notify_client);\n}\n\ncn_result_t cn_server_send(cn_server_t* server, const void* packet, int size, int client_index, bool send_reliably)\n{\n\tif (size <= 0) {\n\t\treturn cn_error_failure(\"Empty packets are not allowed.\");\n\t}\n\tCN_ASSERT(client_index >= 0 && client_index < CN_SERVER_MAX_CLIENTS);\n\tCN_ASSERT(cn_protocol_server_is_client_connected(server->p_server, client_index));\n\treturn cn_transport_send(server->client_transports[client_index], packet, size, send_reliably);\n}\n\nbool cn_server_is_client_connected(cn_server_t* server, int client_index)\n{\n\treturn cn_protocol_server_is_client_connected(server->p_server, client_index);\n}\n\nvoid cn_server_set_public_ip(cn_server_t* server, const char* address_and_port)\n{\n\tserver->p_server->use_developer_mode_public_ip = true;\n\tcn_endpoint_init(&server->p_server->developer_mode_public_ip, address_and_port);\n}\n\nvoid cn_server_enable_network_simulator(cn_server_t* server, double latency, double jitter, double drop_chance, double duplicate_chance)\n{\n\tcn_protocol_server_enable_network_simulator(server->p_server, latency, jitter, drop_chance, duplicate_chance);\n}\n\nfloat cn_server_get_packet_loss_estimate(cn_server_t* server, int client_index)\n{\n\tCN_ASSERT(cn_server_is_client_connected(server, client_index));\n\treturn (float)server->client_transports[client_index]->ack_system->packet_loss;\n}\n\nfloat cn_server_get_rtt_estimate(cn_server_t* server, int client_index)\n{\n\tCN_ASSERT(cn_server_is_client_connected(server, client_index));\n\treturn (float)server->client_transports[client_index]->ack_system->rtt;\n}\n\nfloat cn_server_get_incoming_kbps_estimate(cn_server_t* server, int client_index)\n{\n\tCN_ASSERT(cn_server_is_client_connected(server, client_index));\n\treturn (float)server->client_transports[client_index]->ack_system->outgoing_bandwidth_kbps;\n}\n\nfloat cn_server_get_outgoing_kbps_estimate(cn_server_t* server, int client_index)\n{\n\tCN_ASSERT(cn_server_is_client_connected(server, client_index));\n\treturn (float)server->client_transports[client_index]->ack_system->incoming_bandwidth_kbps;\n}\n\n// -------------------------------------------------------------------------------------------------\n// TEST HARNESS\n#ifdef CUTE_NET_TESTS\n#ifndef CUTE_NET_TESTS_ONCE\n#define CUTE_NET_TESTS_ONCE\n\ntypedef int (cn_test_fn)();\n\ntypedef struct cn_test_t\n{\n\tconst char* test_name;\n\tconst char* description;\n\tcn_test_fn* fn_ptr;\n} cn_test_t;\n\n#ifndef CN_TEST_IO_STREAM\n#\tinclude <stdio.h>\n#\tdefine CN_TEST_IO_STREAM stderr\n#endif\n\n#ifdef _MSC_VER\n#define _CRTDBG_MAP_ALLOC\n#include <crtdbg.h>\n\n// At the time of writing, this define requires fairly recent windows version, so it's\n// safest to just define it ourselves... Should be harmless!\n#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING\n#\tdefine ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004\n#endif\n\n// https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences\nvoid windows_turn_on_console_color()\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tDWORD flags = 0;\n\tGetConsoleMode(h, &flags);\n\tflags |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n\tSetConsoleMode(h, flags);\n}\n#endif\n\nint cn_do_test(cn_test_t* test, int i)\n{\n\tconst char* test_name = test->test_name;\n\tconst char* description = test->description;\n\tCN_FPRINTF(CN_TEST_IO_STREAM, \"Running test #%d\\n\\tName:         %s\\n\\tDescription:  %s\\n\\t\", i, test_name, description);\n\tint result = test->fn_ptr();\n\tconst char* result_string = result ? \"\\033[31mFAILED\\033[0m\\n\\n\" : \"\\033[32mPASSED\\033[0m\\n\\n\";\n\tCN_FPRINTF(CN_TEST_IO_STREAM, \"Result:       %s\", result_string);\n\n#ifdef _MSC_VER\n\t_CrtDumpMemoryLeaks();\n#endif\n\n\treturn result;\n}\n\n#define CN_TEST_PRINT_FILE_LINE(s) do { CN_FPRINTF(CN_TEST_IO_STREAM, \"Extra info:   %s\\n\\tLine number:  %d\\n\\tFile:         %s\\n\\t\", s, __LINE__, __FILE__); } while (0)\n#define CN_TEST_ASSERT(x) do { if (!(x)) { CN_TEST_PRINT_FILE_LINE(\"Assertion was false.\"); return -1; } } while (0)\n#define CN_TEST_CHECK(x) do { if (x) { CN_TEST_PRINT_FILE_LINE(\"Return code failed check.\"); return -1; } } while (0)\n#define CN_TEST_CHECK_POINTER(x) do { if (!(x)) { CN_TEST_PRINT_FILE_LINE(\"Pointer failed check.\"); return -1; } } while (0)\n\n#define CN_TEST_CASE(function, description) int function(); cn_test_t cn_test_##function = { #function, description, function }\n#define CN_TEST_CASE_ENTRY(function) cn_test_##function\n\n#define CN_STATIC_ASSERT(cond, message) typedef char cn_static_assert_##message[(cond) ? 1 : -1]\n\n// -------------------------------------------------------------------------------------------------\n// UNIT TESTS\n\nvoid cn_static_asserts()\n{\n\tCN_STATIC_ASSERT(sizeof(cn_crypto_key_t) == 32, cute_protocol_standard_calls_for_encryption_keys_to_be_32_bytes);\n\tCN_STATIC_ASSERT(CN_PROTOCOL_VERSION_STRING_LEN == 10, cute_protocol_standard_calls_for_the_version_string_to_be_10_bytes);\n\tCN_STATIC_ASSERT(CN_PROTOCOL_CONNECT_TOKEN_PACKET_SIZE == 1024, cute_protocol_standard_calls_for_connect_token_packet_to_be_exactly_1024_bytes);\n\tCN_STATIC_ASSERT(CN_PROTOCOL_SIGNATURE_SIZE == sizeof(cn_crypto_signature_t), must_be_equal);\n\n\tCN_STATIC_ASSERT(CN_CRYPTO_HEADER_BYTES == (int)hydro_secretbox_HEADERBYTES, must_be_equal);\n\tCN_STATIC_ASSERT(sizeof(cn_crypto_signature_t) == hydro_sign_BYTES, must_be_equal);\n\tCN_STATIC_ASSERT(sizeof(uint64_t) == sizeof(long long unsigned int), must_be_equal);\n\n\tCN_STATIC_ASSERT(CN_TRANSPORT_PACKET_PAYLOAD_MAX < 1207, cute_rotocol_max_payload_is_1207);\n\tCN_STATIC_ASSERT(CN_ACK_SYSTEM_MAX_PACKET_SIZE + CN_TRANSPORT_HEADER_SIZE < CN_TRANSPORT_PACKET_PAYLOAD_MAX, must_fit_within_cute_protocols_payload_limit);\n\n\tCN_STATIC_ASSERT(CN_SERVER_MAX_CLIENTS == CN_PROTOCOL_SERVER_MAX_CLIENTS, must_be_equal_for_a_simple_implementation);\n\tCN_STATIC_ASSERT(CN_CONNECT_TOKEN_SIZE == CN_PROTOCOL_CONNECT_TOKEN_SIZE, must_be_equal);\n\tCN_STATIC_ASSERT(CN_CONNECT_TOKEN_USER_DATA_SIZE == CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE, must_be_equal);\n\n\tCN_STATIC_ASSERT(sizeof(s_crypto_ctx) >= hydro_secretbox_CONTEXTBYTES, must_be_equal);\n}\n\nCN_TEST_CASE(cn_socket_init_send_recieve_shutdown, \"Test sending one packet on an ipv4 socket, and then retrieve it.\");\nint cn_socket_init_send_recieve_shutdown()\n{\n\tcn_socket_t socket;\n\tCN_TEST_CHECK(cn_socket_init2(&socket, \"127.0.0.1:5000\", CN_MB, CN_MB));\n\n\tconst char* message_string = \"The message.\";\n\tint message_length = (int)CN_STRLEN(message_string) + 1;\n\tuint8_t* message_buffer = (uint8_t*)malloc(sizeof(uint8_t) * message_length);\n\tCN_MEMCPY(message_buffer, message_string, message_length);\n\n\tint bytes_sent = cn_socket_send_internal(&socket, socket.endpoint, message_buffer, message_length);\n\tCN_TEST_ASSERT(bytes_sent == message_length);\n\tCN_MEMSET(message_buffer, 0, message_length);\n\tCN_TEST_ASSERT(CN_MEMCMP(message_buffer, message_string, message_length));\n\t// cn_sleep(1); // TODO - Might need this on some platforms?\n\n\tcn_endpoint_t from;\n\tint bytes_recieved = cn_socket_receive(&socket, &from, message_buffer, message_length);\n\tCN_TEST_ASSERT(bytes_recieved == message_length);\n\tCN_TEST_ASSERT(cn_endpoint_equals(socket.endpoint, from));\n\tCN_TEST_ASSERT(!CN_MEMCMP(message_buffer, message_string, message_length));\n\n\tfree(message_buffer);\n\n\tcn_socket_cleanup(&socket);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_sequence_buffer_basic, \"Create sequence buffer, insert a few entries, find them, remove them.\");\nint cn_sequence_buffer_basic()\n{\n\tcn_sequence_buffer_t sequence_buffer;\n\tcn_sequence_buffer_t* buffer = &sequence_buffer;\n\tCN_TEST_CHECK(cn_sequence_buffer_init(buffer, 256, sizeof(int), NULL, NULL));\n\n\tint entries[3];\n\tint count = sizeof(entries) / sizeof(entries[0]);\n\tfor (int i = 0; i < count; ++i) {\n\t\tint* entry = (int*)cn_sequence_buffer_insert(buffer, i, NULL);\n\t\tCN_TEST_CHECK_POINTER(entry);\n\t\t*entry = entries[i] = i;\n\t}\n\n\tfor (int i = 0; i < count; ++i) {\n\t\tint* entry = (int*)cn_sequence_buffer_find(buffer, i);\n\t\tCN_TEST_CHECK_POINTER(entry);\n\t\tCN_TEST_ASSERT(*entry == entries[i]);\n\t}\n\n\tfor (int i = 0; i < count; ++i) {\n\t\tcn_sequence_buffer_remove(buffer, i, NULL);\n\t\tint* entry = (int*)cn_sequence_buffer_find(buffer, i);\n\t\tCN_TEST_ASSERT(entry == NULL);\n\t}\n\n\tcn_sequence_buffer_cleanup(buffer, NULL);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_replay_buffer_valid_packets, \"Typical use-case example, should pass all sequences.\");\nint cn_replay_buffer_valid_packets()\n{\n\tcn_protocol_replay_buffer_t buffer;\n\tcn_protocol_replay_buffer_init(&buffer);\n\n\tCN_TEST_ASSERT(buffer.max == 0);\n\n\tfor (int i = 0; i < CN_PROTOCOL_REPLAY_BUFFER_SIZE; ++i) {\n\t\tuint64_t sequence = buffer.entries[i];\n\t\tCN_TEST_ASSERT(sequence == ~0ULL);\n\t}\n\n\tfor (int i = 0; i < CN_PROTOCOL_REPLAY_BUFFER_SIZE; ++i) {\n\t\tCN_TEST_CHECK(cn_protocol_replay_buffer_cull_duplicate(&buffer, (uint64_t)i));\n\t\tcn_protocol_replay_buffer_update(&buffer, (uint64_t)i);\n\t}\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_replay_buffer_old_packet_out_of_range, \"Replay buffer should cull packets of sequence older than `CN_REPLAY_BUFFER_SIZE`.\");\nint cn_replay_buffer_old_packet_out_of_range()\n{\n\tcn_protocol_replay_buffer_t buffer;\n\tcn_protocol_replay_buffer_init(&buffer);\n\n\tfor (int i = 0; i < CN_PROTOCOL_REPLAY_BUFFER_SIZE * 2; ++i) {\n\t\tCN_TEST_CHECK(cn_protocol_replay_buffer_cull_duplicate(&buffer, (uint64_t)i));\n\t\tcn_protocol_replay_buffer_update(&buffer, (uint64_t)i);\n\t}\n\n\tCN_TEST_CHECK(!cn_protocol_replay_buffer_cull_duplicate(&buffer, 0));\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_replay_buffer_duplicate, \"Pass in some valid nonces, and then assert the duplicate fails.\");\nint cn_replay_buffer_duplicate()\n{\n\tcn_protocol_replay_buffer_t buffer;\n\tcn_protocol_replay_buffer_init(&buffer);\n\n\tfor (int i = 0; i < CN_PROTOCOL_REPLAY_BUFFER_SIZE; ++i) {\n\t\tCN_TEST_CHECK(cn_protocol_replay_buffer_cull_duplicate(&buffer, (uint64_t)i));\n\t\tcn_protocol_replay_buffer_update(&buffer, (uint64_t)i);\n\t}\n\n\tCN_TEST_CHECK(!cn_protocol_replay_buffer_cull_duplicate(&buffer, 100));\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_hash_table_basic, \"Create table, insert some elements, remove them, free table.\");\nint cn_hash_table_basic()\n{\n\tcn_hashtable_t table;\n\tcn_hashtable_init(&table, 8, 8, 20, NULL);\n\n\tuint64_t key = 5;\n\tuint64_t item = 10;\n\n\tcn_hashtable_insert(&table, &key, &item);\n\n\tvoid* item_ptr = cn_hashtable_find(&table, &key);\n\tCN_TEST_CHECK_POINTER(item_ptr);\n\tCN_TEST_ASSERT(*(uint64_t*)item_ptr == item);\n\n\tcn_hashtable_cleanup(&table);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_hash_table_set, \"Make sure the table also operates as a set (zero size value).\");\nint cn_hash_table_set()\n{\n\tcn_hashtable_t table;\n\tcn_hashtable_init(&table, 8, 0, 20, NULL);\n\n\tuint64_t key = 5;\n\n\tcn_hashtable_insert(&table, &key, NULL);\n\n\tvoid* item_ptr = cn_hashtable_find(&table, &key);\n\tCN_TEST_CHECK_POINTER(item_ptr);\n\n\tcn_hashtable_cleanup(&table);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_hash_table_hammer, \"Fill up table, many lookups, and reset, all a few times.\");\nint cn_hash_table_hammer()\n{\n\tcn_hashtable_t table;\n\tcn_hashtable_init(&table, 8, 8, 128, NULL);\n\n\tuint64_t keys[128];\n\tuint64_t items[128];\n\n\tfor (int i = 0; i < 128; ++i) {\n\t\tkeys[i] = i;\n\t\titems[i] = i * 2;\n\t}\n\n\tfor (int iters = 0; iters < 10; ++iters) {\n\t\tfor (int i = 0; i < 128; ++i) {\n\t\t\tcn_hashtable_insert(&table, keys + i, items + i);\n\t\t}\n\n\t\tfor (int i = 0; i < 128; ++i) {\n\t\t\tvoid* item_ptr = cn_hashtable_find(&table, keys + i);\n\t\t\tCN_TEST_CHECK_POINTER(item_ptr);\n\t\t\tCN_TEST_ASSERT(*(uint64_t*)item_ptr == items[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < 128; ++i) {\n\t\t\tcn_hashtable_remove(&table, keys + i);\n\t\t}\n\t}\n\n\tcn_hashtable_cleanup(&table);\n\n\treturn 0;\n}\n\n\nCN_TEST_CASE(cn_handle_basic, \"Typical use-case example, alloc and free some handles.\");\nint cn_handle_basic()\n{\n\tcn_handle_allocator_t* table = cn_handle_allocator_create(1024, NULL);\n\tCN_TEST_CHECK_POINTER(table);\n\n\tcn_handle_t h0 = cn_handle_allocator_alloc(table, 7);\n\tcn_handle_t h1 = cn_handle_allocator_alloc(table, 13);\n\tCN_TEST_ASSERT(h0 != CN_INVALID_HANDLE);\n\tCN_TEST_ASSERT(h1 != CN_INVALID_HANDLE);\n\tuint32_t index0 = cn_handle_allocator_get_index(table, h0);\n\tuint32_t index1 = cn_handle_allocator_get_index(table, h1);\n\tCN_TEST_ASSERT(index0 == 7);\n\tCN_TEST_ASSERT(index1 == 13);\n\n\tcn_handle_allocator_free(table, h0);\n\tcn_handle_allocator_free(table, h1);\n\n\th0 = cn_handle_allocator_alloc(table, 4);\n\th1 = cn_handle_allocator_alloc(table, 267);\n\tCN_TEST_ASSERT(h0 != CN_INVALID_HANDLE);\n\tCN_TEST_ASSERT(h1 != CN_INVALID_HANDLE);\n\tindex0 = cn_handle_allocator_get_index(table, h0);\n\tindex1 = cn_handle_allocator_get_index(table, h1);\n\tCN_TEST_ASSERT(index0 == 4);\n\tCN_TEST_ASSERT(index1 == 267);\n\n\tcn_handle_allocator_update_index(table, h1, 9);\n\tindex1 = cn_handle_allocator_get_index(table, h1);\n\tCN_TEST_ASSERT(index1 == 9);\n\n\tcn_handle_allocator_destroy(table);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_handle_large_loop, \"Allocate right up the maximum size possible for the table.\");\nint cn_handle_large_loop()\n{\n\tcn_handle_allocator_t* table = cn_handle_allocator_create(1024, NULL);\n\tCN_TEST_CHECK_POINTER(table);\n\n\tfor (int i = 0; i < 1024; ++i) {\n\t\tcn_handle_t h = cn_handle_allocator_alloc(table, i);\n\t\tCN_TEST_ASSERT(h != CN_INVALID_HANDLE);\n\t\tCN_ASSERT(cn_handle_allocator_get_index(table, h) == (uint32_t)i);\n\t}\n\n\tcn_handle_allocator_destroy(table);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_handle_large_loop_and_free, \"\\\"Soak test\\\" to fill up the handle buffer and empty it a few times.\");\nint cn_handle_large_loop_and_free()\n{\n\tcn_handle_allocator_t* table = cn_handle_allocator_create(1024, NULL);\n\tCN_TEST_CHECK_POINTER(table);\n\tcn_handle_t* handles = (cn_handle_t*)malloc(sizeof(cn_handle_t) * 2014);\n\n\tfor (int iters = 0; iters < 5; ++iters) {\n\t\tfor (int i = 0; i < 1024; ++i) {\n\t\t\tcn_handle_t h = cn_handle_allocator_alloc(table, i);\n\t\t\tCN_TEST_ASSERT(h != CN_INVALID_HANDLE);\n\t\t\tCN_ASSERT(cn_handle_allocator_get_index(table, h) == (uint32_t)i);\n\t\t\thandles[i] = h;\n\t\t}\n\n\t\tfor (int i = 0; i < 1024; ++i) {\n\t\t\tcn_handle_t h = handles[i];\n\t\t\tcn_handle_allocator_free(table, h);\n\t\t}\n\t}\n\n\tcn_handle_allocator_destroy(table);\n\tfree(handles);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_handle_alloc_too_many, \"Allocating over 1024 entries should not result in failure.\");\nint cn_handle_alloc_too_many()\n{\n\tcn_handle_allocator_t* table = cn_handle_allocator_create(1024, NULL);\n\tCN_TEST_CHECK_POINTER(table);\n\n\tfor (int i = 0; i < 1024; ++i) {\n\t\tcn_handle_t h = cn_handle_allocator_alloc(table, i);\n\t\tCN_TEST_ASSERT(h != CN_INVALID_HANDLE);\n\t\tCN_ASSERT(cn_handle_allocator_get_index(table, h) == (uint32_t)i);\n\t}\n\n\tcn_handle_t h = cn_handle_allocator_alloc(table, 0);\n\tCN_TEST_ASSERT(h != CN_INVALID_HANDLE);\n\n\tcn_handle_allocator_destroy(table);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_encryption_map_basic, \"Create map, make entry, lookup entry, remove, and cleanup.\");\nint cn_encryption_map_basic()\n{\n\tcn_protocol_encryption_map_t map;\n\tcn_protocol_encryption_map_init(&map, NULL);\n\n\tcn_protocol_encryption_state_t state;\n\tstate.sequence = 0;\n\tstate.expiration_timestamp = 10;\n\tstate.handshake_timeout = 5;\n\tstate.last_packet_recieved_time = 0;\n\tstate.last_packet_sent_time = 0;\n\tstate.client_to_server_key = cn_crypto_generate_key();\n\tstate.server_to_client_key = cn_crypto_generate_key();\n\tstate.client_id = 0;\n\n\tcn_endpoint_t endpoint;\n\tCN_TEST_CHECK(cn_endpoint_init(&endpoint, \"[::]:5000\"));\n\n\tcn_protocol_encryption_map_insert(&map, endpoint, &state);\n\n\tcn_protocol_encryption_state_t* state_looked_up = cn_protocol_encryption_map_find(&map, endpoint);\n\tCN_TEST_CHECK_POINTER(state_looked_up);\n\n\tCN_TEST_ASSERT(!CN_MEMCMP(&state, state_looked_up, sizeof(state)));\n\n\tcn_protocol_encryption_map_cleanup(&map);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_encryption_map_timeout_and_expiration, \"Ensure timeouts and expirations remove entries properly.\");\nint cn_encryption_map_timeout_and_expiration()\n{\n\tcn_protocol_encryption_map_t map;\n\tcn_protocol_encryption_map_init(&map, NULL);\n\n\tcn_protocol_encryption_state_t state0;\n\tstate0.sequence = 0;\n\tstate0.expiration_timestamp = 10;\n\tstate0.handshake_timeout = 5;\n\tstate0.last_packet_recieved_time = 0;\n\tstate0.last_packet_sent_time = 0;\n\tstate0.client_to_server_key = cn_crypto_generate_key();\n\tstate0.server_to_client_key = cn_crypto_generate_key();\n\tstate0.client_id = 0;\n\n\tcn_protocol_encryption_state_t state1;\n\tstate1.sequence = 0;\n\tstate1.expiration_timestamp = 10;\n\tstate1.handshake_timeout = 6;\n\tstate1.last_packet_recieved_time = 0;\n\tstate1.last_packet_sent_time = 0;\n\tstate1.client_to_server_key = cn_crypto_generate_key();\n\tstate1.server_to_client_key = cn_crypto_generate_key();\n\tstate1.client_id = 0;\n\n\tcn_endpoint_t endpoint0;\n\tCN_TEST_CHECK(cn_endpoint_init(&endpoint0, \"[::]:5000\"));\n\n\tcn_endpoint_t endpoint1;\n\tCN_TEST_CHECK(cn_endpoint_init(&endpoint1, \"[::]:5001\"));\n\n\tcn_protocol_encryption_map_insert(&map, endpoint0, &state0);\n\tcn_protocol_encryption_map_insert(&map, endpoint1, &state1);\n\n\tcn_protocol_encryption_state_t* state_looked_up = cn_protocol_encryption_map_find(&map, endpoint0);\n\tCN_TEST_CHECK_POINTER(state_looked_up);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&state0, state_looked_up, sizeof(state0)));\n\n\tstate_looked_up = cn_protocol_encryption_map_find(&map, endpoint1);\n\tCN_TEST_CHECK_POINTER(state_looked_up);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&state1, state_looked_up, sizeof(state1)));\n\n\t// Nothing should timeout or expire just yet.\n\tcn_protocol_encryption_map_look_for_timeouts_or_expirations(&map, 4.0f, 9ULL);\n\n\tstate_looked_up = cn_protocol_encryption_map_find(&map, endpoint0);\n\tCN_TEST_CHECK_POINTER(state_looked_up);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&state0, state_looked_up, sizeof(state0)));\n\n\tstate_looked_up = cn_protocol_encryption_map_find(&map, endpoint1);\n\tCN_TEST_CHECK_POINTER(state_looked_up);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&state1, state_looked_up, sizeof(state1)));\n\n\t// Now timeout state0.\n\tcn_protocol_encryption_map_look_for_timeouts_or_expirations(&map, 6.0f, 9ULL);\n\tCN_TEST_CHECK_POINTER(!cn_protocol_encryption_map_find(&map, endpoint0));\n\n\t// Now expire state1.\n\tcn_protocol_encryption_map_look_for_timeouts_or_expirations(&map, 0, 10ULL);\n\tCN_TEST_CHECK_POINTER(!cn_protocol_encryption_map_find(&map, endpoint1));\n\n\t// Assert that there are no present entries.\n\tCN_TEST_ASSERT(cn_protocol_encryption_map_count(&map) == 0);\n\n\tcn_protocol_encryption_map_cleanup(&map);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_doubly_list, \"Make list of three elements, perform all operations on it, assert correctness.\");\nint cn_doubly_list()\n{\n\tcn_list_t list;\n\n\tcn_list_node_t a;\n\tcn_list_node_t b;\n\tcn_list_node_t c;\n\n\tcn_list_init(&list);\n\tcn_list_init_node(&a);\n\tcn_list_init_node(&b);\n\tcn_list_init_node(&c);\n\n\tCN_TEST_ASSERT(list.nodes.next == &list.nodes);\n\tCN_TEST_ASSERT(list.nodes.prev == &list.nodes);\n\tCN_TEST_ASSERT(a.next == &a);\n\tCN_TEST_ASSERT(a.prev == &a);\n\tCN_TEST_ASSERT(cn_list_empty(&list));\n\n\tcn_list_push_front(&list, &a);\n\tCN_TEST_ASSERT(!cn_list_empty(&list));\n\tCN_TEST_ASSERT(list.nodes.next == &a);\n\tCN_TEST_ASSERT(list.nodes.prev == &a);\n\tCN_TEST_ASSERT(list.nodes.next->next == &list.nodes);\n\tCN_TEST_ASSERT(list.nodes.prev->prev == &list.nodes);\n\tCN_TEST_ASSERT(cn_list_front(&list) == &a);\n\tCN_TEST_ASSERT(cn_list_back(&list) == &a);\n\n\tcn_list_push_front(&list, &b);\n\tCN_TEST_ASSERT(cn_list_front(&list) == &b);\n\tCN_TEST_ASSERT(cn_list_back(&list) == &a);\n\n\tcn_list_push_back(&list, &c);\n\tCN_TEST_ASSERT(cn_list_front(&list) == &b);\n\tCN_TEST_ASSERT(cn_list_back(&list) == &c);\n\n\tcn_list_node_t* nodes[3] = { &b, &a, &c };\n\tint index = 0;\n\tfor (cn_list_node_t* n = cn_list_begin(&list); n != cn_list_end(&list); n = n->next) {\n\t\tCN_TEST_ASSERT(n == nodes[index++]);\n\t}\n\n\tCN_TEST_ASSERT(cn_list_pop_front(&list) == &b);\n\tCN_TEST_ASSERT(cn_list_pop_back(&list) == &c);\n\tCN_TEST_ASSERT(cn_list_pop_back(&list) == &a);\n\n\tCN_TEST_ASSERT(cn_list_empty(&list));\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_crypto_encrypt_decrypt, \"Generate key, encrypt a message, decrypt the message.\");\nint cn_crypto_encrypt_decrypt()\n{\n\tcn_crypto_key_t k = cn_crypto_generate_key();\n\n\tconst char* message_string = \"The message.\";\n\tint message_length = (int)CN_STRLEN(message_string) + 1;\n\tuint8_t* message_buffer = (uint8_t*)malloc(sizeof(uint8_t) * (message_length + CN_CRYPTO_HEADER_BYTES));\n\tCN_MEMCPY(message_buffer, message_string, message_length);\n\n\tcn_crypto_encrypt(&k, message_buffer, message_length, 0);\n\tCN_TEST_ASSERT(CN_MEMCMP(message_buffer, message_string, message_length));\n\tCN_TEST_ASSERT(!cn_is_error(cn_crypto_decrypt(&k, message_buffer, message_length + CN_CRYPTO_HEADER_BYTES, 0)));\n\tCN_TEST_ASSERT(!CN_MEMCMP(message_buffer, message_string, message_length));\n\n\tfree(message_buffer);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_connect_token_cache, \"Add tokens, overflow (eject oldest), ensure LRU correctness.\");\nint cn_connect_token_cache()\n{\n\tint capacity = 3;\n\tcn_protocol_connect_token_cache_t cache;\n\tcn_protocol_connect_token_cache_init(&cache, capacity, NULL);\n\n\tcn_endpoint_t endpoint;\n\tCN_TEST_CHECK(cn_endpoint_init(&endpoint, \"[::]:5000\"));\n\n\tuint8_t hmac_bytes_a[sizeof(cn_crypto_signature_t)];\n\tuint8_t hmac_bytes_b[sizeof(cn_crypto_signature_t)];\n\tuint8_t hmac_bytes_c[sizeof(cn_crypto_signature_t)];\n\tuint8_t hmac_bytes_d[sizeof(cn_crypto_signature_t)];\n\tuint8_t hmac_bytes_e[sizeof(cn_crypto_signature_t)];\n\tcn_crypto_random_bytes(hmac_bytes_a, sizeof(hmac_bytes_a));\n\tcn_crypto_random_bytes(hmac_bytes_b, sizeof(hmac_bytes_b));\n\tcn_crypto_random_bytes(hmac_bytes_c, sizeof(hmac_bytes_c));\n\tcn_crypto_random_bytes(hmac_bytes_d, sizeof(hmac_bytes_d));\n\tcn_crypto_random_bytes(hmac_bytes_e, sizeof(hmac_bytes_e));\n\n\tcn_protocol_connect_token_cache_add(&cache, hmac_bytes_a);\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_a));\n\tcn_protocol_connect_token_cache_add(&cache, hmac_bytes_b);\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_b));\n\tcn_protocol_connect_token_cache_add(&cache, hmac_bytes_c);\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_c));\n\tcn_protocol_connect_token_cache_add(&cache, hmac_bytes_d);\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_d));\n\n\tCN_TEST_ASSERT(!cn_protocol_connect_token_cache_find(&cache, hmac_bytes_a));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_b));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_c));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_d));\n\n\tcn_protocol_connect_token_cache_add(&cache, hmac_bytes_e);\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_e));\n\n\tCN_TEST_ASSERT(!cn_protocol_connect_token_cache_find(&cache, hmac_bytes_a));\n\tCN_TEST_ASSERT(!cn_protocol_connect_token_cache_find(&cache, hmac_bytes_b));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_c));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_d));\n\tCN_TEST_ASSERT(cn_protocol_connect_token_cache_find(&cache, hmac_bytes_e));\n\n\tcn_protocol_connect_token_cache_cleanup(&cache);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_test_generate_connect_token, \"Basic test to generate a connect token and assert the expected token.\");\nint cn_test_generate_connect_token()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t\t\"[::1]:5001\",\n\t\t\"[::1]:5002\"\n\t};\n\n\tuint64_t application_id = ~0ULL;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 10;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t token_buffer[CN_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\t3,\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\ttoken_buffer\n\t)));\n\n\t// Assert reading token from web service as a client.\n\tcn_protocol_connect_token_t token;\n\tuint8_t* connect_token_packet = cn_protocol_client_read_connect_token_from_web_service(token_buffer, application_id, current_timestamp, &token);\n\tCN_TEST_CHECK_POINTER(connect_token_packet);\n\n\tCN_TEST_ASSERT(token.creation_timestamp == current_timestamp);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&client_to_server_key, &token.client_to_server_key, sizeof(cn_crypto_key_t)));\n\tCN_TEST_ASSERT(!CN_MEMCMP(&server_to_client_key, &token.server_to_client_key, sizeof(cn_crypto_key_t)));\n\tCN_TEST_ASSERT(token.expiration_timestamp == expiration_timestamp);\n\tCN_TEST_ASSERT(token.handshake_timeout == handshake_timeout);\n\tCN_TEST_ASSERT(token.endpoint_count == 3);\n\tfor (int i = 0; i < token.endpoint_count; ++i) {\n\t\tcn_endpoint_t endpoint;\n\t\tCN_TEST_CHECK(cn_endpoint_init(&endpoint, endpoints[i]));\n\t\tCN_TEST_ASSERT(cn_endpoint_equals(token.endpoints[i], endpoint));\n\t}\n\n\t// Assert reading *connect token packet* as server, and decrypting it successfully.\n\tcn_protocol_connect_token_decrypted_t decrypted_token;\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_decrypt_connect_token_packet(connect_token_packet, &pk, &sk, application_id, current_timestamp, &decrypted_token)));\n\tCN_TEST_ASSERT(decrypted_token.expiration_timestamp == expiration_timestamp);\n\tCN_TEST_ASSERT(decrypted_token.handshake_timeout == handshake_timeout);\n\tCN_TEST_ASSERT(decrypted_token.endpoint_count == 3);\n\tfor (int i = 0; i < token.endpoint_count; ++i) {\n\t\tcn_endpoint_t endpoint;\n\t\tCN_TEST_CHECK(cn_endpoint_init(&endpoint, endpoints[i]));\n\t\tCN_TEST_ASSERT(cn_endpoint_equals(decrypted_token.endpoints[i], endpoint));\n\t}\n\tCN_TEST_ASSERT(decrypted_token.client_id == client_id);\n\tCN_TEST_ASSERT(!CN_MEMCMP(&client_to_server_key, &decrypted_token.client_to_server_key, sizeof(cn_crypto_key_t)));\n\tCN_TEST_ASSERT(!CN_MEMCMP(&server_to_client_key, &decrypted_token.server_to_client_key, sizeof(cn_crypto_key_t)));\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_client_server, \"Connect a client to server, then disconnect and shutdown both.\");\nint cn_client_server()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tuint64_t application_id = 333;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_server_config_t config = cn_server_config_defaults();\n\tconfig.public_key = pk;\n\tconfig.secret_key = sk;\n\tconfig.application_id = application_id;\n\tcn_server_t* server = cn_server_create(config);\n\tcn_client_t* client = cn_client_create(0, application_id, true, NULL);\n\tCN_TEST_ASSERT(server);\n\tCN_TEST_ASSERT(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_server_start(server, \"[::1]:5000\")));\n\tCN_TEST_CHECK(cn_is_error(cn_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (1) {\n\t\tcn_client_update(client, 0, 0);\n\t\tcn_server_update(server, 0, 0);\n\n\t\tif (cn_client_state_get(client) < 0 || ++iters == 100) {\n\t\t\tCN_TEST_ASSERT(false);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cn_client_state_get(client) == CN_CLIENT_STATE_CONNECTED) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_server_is_client_connected(server, 0));\n\n\tcn_client_disconnect(client);\n\tcn_server_update(server, 0, 0);\n\tCN_TEST_ASSERT(!cn_server_is_client_connected(server, 0));\n\n\tcn_client_destroy(client);\n\tcn_server_stop(server);\n\tcn_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_client_server_payload, \"Connect a client to server, send some packets, then disconnect and shutdown both.\");\nint cn_client_server_payload()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tuint64_t application_id = 333;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_server_config_t config = cn_server_config_defaults();\n\tconfig.public_key = pk;\n\tconfig.secret_key = sk;\n\tconfig.application_id = application_id;\n\tcn_server_t* server = cn_server_create(config);\n\tcn_client_t* client = cn_client_create(0, application_id, true, NULL);\n\tCN_TEST_ASSERT(server);\n\tCN_TEST_ASSERT(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_server_start(server, \"[::1]:5000\")));\n\tCN_TEST_CHECK(cn_is_error(cn_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (1) {\n\t\tcn_client_update(client, 0, 0);\n\t\tcn_server_update(server, 0, 0);\n\n\t\tif (cn_client_state_get(client) < 0 || ++iters == 100) {\n\t\t\tCN_TEST_ASSERT(false);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cn_client_state_get(client) == CN_CLIENT_STATE_CONNECTED) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_server_is_client_connected(server, 0));\n\n\tuint64_t packet = 12345678;\n\tCN_TEST_CHECK(cn_is_error(cn_client_send(client, &packet, sizeof(packet), false)));\n\tcn_client_update(client, 0, 0);\n\tcn_server_update(server, 0, 0);\n\n\tcn_server_event_t e;\n\tCN_TEST_ASSERT(cn_server_pop_event(server, &e));\n\tCN_TEST_ASSERT(e.type == CN_SERVER_EVENT_TYPE_NEW_CONNECTION);\n\tCN_TEST_ASSERT(e.u.new_connection.client_index == 0);\n\tCN_TEST_ASSERT(e.u.new_connection.client_id == client_id);\n\n\tCN_TEST_ASSERT(cn_server_pop_event(server, &e));\n\tCN_TEST_ASSERT(e.type == CN_SERVER_EVENT_TYPE_PAYLOAD_PACKET);\n\tCN_TEST_ASSERT(e.u.payload_packet.size == sizeof(packet));\n\tCN_TEST_ASSERT(*(uint64_t*)e.u.payload_packet.data == packet);\n\tcn_server_free_packet(server, e.u.payload_packet.client_index, e.u.payload_packet.data);\n\n\tcn_client_disconnect(client);\n\tcn_server_update(server, 0, 0);\n\tCN_TEST_ASSERT(!cn_server_is_client_connected(server, 0));\n\tCN_TEST_ASSERT(cn_server_pop_event(server, &e));\n\tCN_TEST_ASSERT(e.type == CN_SERVER_EVENT_TYPE_DISCONNECTED);\n\tCN_TEST_ASSERT(e.u.disconnected.client_index == 0);\n\n\tcn_client_destroy(client);\n\tcn_server_stop(server);\n\tcn_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_client_server_sim, \"Run network simulator between a client and server.\");\nint cn_client_server_sim()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tuint64_t application_id = 333;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_server_config_t config = cn_server_config_defaults();\n\tconfig.public_key = pk;\n\tconfig.secret_key = sk;\n\tconfig.application_id = application_id;\n\tcn_server_t* server = cn_server_create(config);\n\tcn_client_t* client = cn_client_create(0, application_id, true, NULL);\n\tCN_TEST_ASSERT(server);\n\tCN_TEST_ASSERT(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_server_start(server, \"[::1]:5000\")));\n\tCN_TEST_CHECK(cn_is_error(cn_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (1) {\n\t\tcn_client_update(client, 0, 0);\n\t\tcn_server_update(server, 0, 0);\n\n\t\tif (cn_client_state_get(client) < 0 || ++iters == 100) {\n\t\t\tCN_TEST_ASSERT(false);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cn_client_state_get(client) == CN_CLIENT_STATE_CONNECTED) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_server_is_client_connected(server, 0));\n\n\tcn_server_event_t e;\n\tCN_TEST_ASSERT(cn_server_pop_event(server, &e));\n\tCN_TEST_ASSERT(e.type == CN_SERVER_EVENT_TYPE_NEW_CONNECTION);\n\tCN_TEST_ASSERT(e.u.new_connection.client_index == 0);\n\tCN_TEST_ASSERT(e.u.new_connection.client_id == client_id);\n\n\tcn_client_enable_network_simulator(client, 0.02f, 0.005f, 0.5, 0.05f);\n\tcn_server_enable_network_simulator(server, 0.02f, 0.005f, 0.5, 0.05f);\n\n\tbool soak = false;\n\tbool do_send = true;\n\tint packet_size = 1024 * 3;\n\tvoid* packet = CN_ALLOC(packet_size, NULL);\n\tdouble dt = 1.0/60.0;\n\titers = 0;\n\n\tuint64_t keepalive = ~0ULL;\n\n\twhile (1) {\n\t\tif (do_send) {\n\t\t\tcn_crypto_random_bytes(packet, packet_size);\n\t\t\tcn_result_t result = cn_client_send(client, packet, packet_size, true);\n\t\t\tCN_TEST_ASSERT(!cn_is_error(result));\n\t\t\tdo_send = false;\n\t\t}\n\n\t\tcn_client_update(client, dt, 0);\n\t\tcn_server_update(server, dt, 0);\n\t\tcn_server_send(server, &keepalive, sizeof(keepalive), 0, false);\n\n\t\tvoid* client_packet;\n\t\tint client_packet_size;\n\t\tif (cn_client_pop_packet(client, &client_packet, &client_packet_size, NULL)) {\n\t\t\tCN_TEST_ASSERT(client_packet_size == sizeof(keepalive));\n\t\t\tCN_TEST_ASSERT(*(uint64_t*)client_packet == keepalive);\n\t\t\tcn_client_free_packet(client, client_packet);\n\t\t}\n\n\t\tcn_server_event_t e;\n\t\tif (cn_server_pop_event(server, &e)) {\n\t\t\tCN_TEST_ASSERT(e.type == CN_SERVER_EVENT_TYPE_PAYLOAD_PACKET);\n\t\t\tvoid* data = e.u.payload_packet.data;\n\t\t\tint size = e.u.payload_packet.size;\n\t\t\tCN_TEST_ASSERT(size == packet_size);\n\t\t\tCN_TEST_ASSERT(!CN_MEMCMP(data, packet, packet_size));\n\t\t\tdo_send = true;\n\t\t\t++iters;\n\t\t\tcn_server_free_packet(server, 0, data);\n\t\t}\n\n\t\tif (!soak && iters == 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tCN_FREE(packet, NULL);\n\tcn_client_destroy(client);\n\tcn_server_destroy(server);\n\n\treturn 0;\n}\n\ntypedef struct cn_test_transport_data_t\n{\n\tint drop_packet;\n\tint id;\n\tcn_ack_system_t* ack_system_a;\n\tcn_ack_system_t* ack_system_b;\n\tcn_transport_t* transport_a;\n\tcn_transport_t* transport_b;\n} cn_test_transport_data_t;\n\ncn_test_transport_data_t cn_test_transport_data_defaults()\n{\n\tcn_test_transport_data_t data;\n\tdata.drop_packet = 0;\n\tdata.id = ~0;\n\tdata.ack_system_a = NULL;\n\tdata.ack_system_b = NULL;\n\tdata.transport_a = NULL;\n\tdata.transport_b = NULL;\n\treturn data;\n}\n\ncn_result_t cn_test_send_packet_fn(int index, void* packet, int size, void* udata)\n{\n\tcn_test_transport_data_t* data = (cn_test_transport_data_t*)udata;\n\tif (data->drop_packet) {\n\t\treturn cn_error_success();\n\t}\n\n\tif (data->id) {\n\t\tcn_ack_system_receive_packet(data->ack_system_a, packet, size);\n\t} else {\n\t\tcn_ack_system_receive_packet(data->ack_system_b, packet, size);\n\t}\n\n\treturn cn_error_success();\n}\n\nCN_TEST_CASE(cn_ack_system_basic, \"Create ack system, send a few packets, and receive them. Make sure some drop. Assert acks.\");\nint cn_ack_system_basic()\n{\n\tcn_test_transport_data_t data_a = cn_test_transport_data_defaults();\n\tcn_test_transport_data_t data_b = cn_test_transport_data_defaults();\n\tdata_a.id = 0;\n\tdata_b.id = 1;\n\n\tcn_ack_system_config_t config = cn_ack_system_config_defaults();\n\tconfig.send_packet_fn = cn_test_send_packet_fn;\n\tconfig.udata = &data_a;\n\tcn_ack_system_t* ack_system_a = cn_ack_system_create(config);\n\tconfig.udata = &data_b;\n\tcn_ack_system_t* ack_system_b = cn_ack_system_create(config);\n\tdata_a.ack_system_a = ack_system_a;\n\tdata_a.ack_system_b = ack_system_b;\n\tdata_b.ack_system_a = ack_system_a;\n\tdata_b.ack_system_b = ack_system_b;\n\n\tCN_TEST_CHECK_POINTER(ack_system_a);\n\tCN_TEST_CHECK_POINTER(ack_system_b);\n\n\tuint64_t packet_data = 100;\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tif ((i % 3) == 0) {\n\t\t\tdata_a.drop_packet = 1;\n\t\t\tdata_b.drop_packet = 1;\n\t\t} else {\n\t\t\tdata_a.drop_packet = 0;\n\t\t\tdata_b.drop_packet = 0;\n\t\t}\n\t\tuint16_t sequence_a, sequence_b;\n\t\tCN_TEST_CHECK(cn_is_error(cn_ack_system_send_packet(ack_system_a, &packet_data, sizeof(packet_data), &sequence_a)));\n\t\tCN_TEST_CHECK(cn_is_error(cn_ack_system_send_packet(ack_system_b, &packet_data, sizeof(packet_data), &sequence_b)));\n\t}\n\n\tuint64_t a_sent = cn_ack_system_get_counter(ack_system_a, CN_ACK_SYSTEM_COUNTERS_PACKETS_SENT);\n\tuint64_t b_sent = cn_ack_system_get_counter(ack_system_b, CN_ACK_SYSTEM_COUNTERS_PACKETS_SENT);\n\tCN_TEST_ASSERT(a_sent == b_sent);\n\n\tuint64_t a_received = cn_ack_system_get_counter(ack_system_a, CN_ACK_SYSTEM_COUNTERS_PACKETS_RECEIVED);\n\tuint64_t b_received = cn_ack_system_get_counter(ack_system_b, CN_ACK_SYSTEM_COUNTERS_PACKETS_RECEIVED);\n\tCN_TEST_ASSERT(a_received == b_received);\n\n\tCN_TEST_ASSERT(a_sent > a_received);\n\tCN_TEST_ASSERT(b_sent > b_received);\n\n\tuint16_t* acks_a = cn_ack_system_get_acks(ack_system_a);\n\tuint16_t* acks_b = cn_ack_system_get_acks(ack_system_b);\n\tint count_a = cn_ack_system_get_acks_count(ack_system_a);\n\tint count_b = cn_ack_system_get_acks_count(ack_system_b);\n\tCN_TEST_ASSERT(count_a - 1 == count_b);\n\tfor (int i = 0; i < count_b; ++i) {\n\t\tCN_TEST_ASSERT(acks_a[i] == acks_b[i]);\n\t\tCN_TEST_ASSERT(acks_a[i] != 0);\n\t\tCN_TEST_ASSERT(acks_a[i] != 3);\n\t\tCN_TEST_ASSERT(acks_a[i] != 6);\n\t\tCN_TEST_ASSERT(acks_a[i] != 9);\n\t}\n\n\tcn_ack_system_destroy(ack_system_a);\n\tcn_ack_system_destroy(ack_system_b);\n\n\treturn 0;\n}\n\ncn_result_t cn_test_transport_send_packet_fn(int index, void* packet, int size, void* udata)\n{\n\tcn_test_transport_data_t* data = (cn_test_transport_data_t*)udata;\n\tif (data->drop_packet) {\n\t\treturn cn_error_success();\n\t}\n\t\n\tif (data->id) {\n\t\tcn_transport_process_packet(data->transport_a, packet, size);\n\t} else {\n\t\tcn_transport_process_packet(data->transport_b, packet, size);\n\t}\n\n\treturn cn_error_success();\n}\n\ncn_result_t cn_test_transport_open_packet_fn(int index, void* packet, int size, void* udata)\n{\n\tcn_test_transport_data_t* data = (cn_test_transport_data_t*)udata;\n\treturn cn_error_success();\n}\n\nCN_TEST_CASE(cn_transport_basic, \"Create transport, send a couple packets, receive them.\");\nint cn_transport_basic()\n{\n\tcn_test_transport_data_t data_a = cn_test_transport_data_defaults();\n\tcn_test_transport_data_t data_b = cn_test_transport_data_defaults();\n\tdata_a.id = 0;\n\tdata_b.id = 1;\n\n\tcn_transport_config_t config = cn_transport_config_defaults();\n\tconfig.send_packet_fn = cn_test_transport_send_packet_fn;\n\tconfig.udata = &data_a;\n\tcn_transport_t* transport_a = cn_transport_create(config);\n\tconfig.udata = &data_b;\n\tcn_transport_t* transport_b = cn_transport_create(config);\n\tdata_a.transport_a = transport_a;\n\tdata_a.transport_b = transport_b;\n\tdata_b.transport_a = transport_a;\n\tdata_b.transport_b = transport_b;\n\tdouble dt = 1.0/60.0;\n\n\tint packet_size = 4000;\n\tuint8_t* packet = (uint8_t*)CN_ALLOC(packet_size, NULL);\n\tCN_MEMSET(packet, 0xFF, packet_size);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, packet, packet_size, true)));\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, packet, packet_size, true)));\n\n\tcn_transport_update(transport_a, dt);\n\tcn_transport_update(transport_b, dt);\n\n\tvoid* packet_received;\n\tint packet_received_size;\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_a, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_a, packet_received);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_b, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_b, packet_received);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, packet, packet_size, false)));\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, packet, packet_size, false)));\n\n\tcn_transport_update(transport_a, dt);\n\tcn_transport_update(transport_b, dt);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_fire_and_forget(transport_a, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_a, packet_received);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_fire_and_forget(transport_b, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_b, packet_received);\n\n\tCN_FREE(packet, NULL);\n\n\tcn_transport_destroy(transport_a);\n\tcn_transport_destroy(transport_b);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_transport_drop_fragments, \"Create transport, send a couple packets, receive them under packet loss.\");\nint cn_transport_drop_fragments()\n{\n\tcn_test_transport_data_t data_a = cn_test_transport_data_defaults();\n\tcn_test_transport_data_t data_b = cn_test_transport_data_defaults();\n\tdata_a.id = 0;\n\tdata_b.id = 1;\n\n\tcn_transport_config_t config = cn_transport_config_defaults();\n\tconfig.send_packet_fn = cn_test_transport_send_packet_fn;\n\tconfig.udata = &data_a;\n\tcn_transport_t* transport_a = cn_transport_create(config);\n\tconfig.udata = &data_b;\n\tcn_transport_t* transport_b = cn_transport_create(config);\n\tdata_a.transport_a = transport_a;\n\tdata_a.transport_b = transport_b;\n\tdata_b.transport_a = transport_a;\n\tdata_b.transport_b = transport_b;\n\tdouble dt = 1.0/60.0;\n\n\tint packet_size = 4000;\n\tuint8_t* packet = (uint8_t*)CN_ALLOC(packet_size, NULL);\n\tCN_MEMSET(packet, 0xFF, packet_size);\n\n\tdata_b.drop_packet = 1;\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, packet, packet_size, true)));\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, packet, packet_size, true)));\n\n\tcn_transport_update(transport_a, dt);\n\tcn_transport_update(transport_b, dt);\n\n\tvoid* packet_received;\n\tint packet_received_size;\n\n\tCN_TEST_ASSERT(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_a, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(0 == packet_received_size);\n\tCN_TEST_ASSERT(packet_received == NULL);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_b, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_b, packet_received);\n\n\tdata_b.drop_packet = 0;\n\tcn_transport_update(transport_b, 1);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_a, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_a, packet_received);\n\n\tdata_a.drop_packet = 1;\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, packet, packet_size, false)));\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, packet, packet_size, false)));\n\n\tcn_transport_update(transport_a, dt);\n\tcn_transport_update(transport_b, dt);\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_receive_fire_and_forget(transport_a, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\tcn_transport_free_packet(transport_a, packet_received);\n\n\tCN_TEST_ASSERT(cn_is_error(cn_transport_receive_reliably_and_in_order(transport_b, &packet_received, &packet_received_size)));\n\tCN_TEST_ASSERT(0 == packet_received_size);\n\tCN_TEST_ASSERT(packet_received == NULL);\n\n\tCN_FREE(packet, NULL);\n\n\tcn_transport_destroy(transport_a);\n\tcn_transport_destroy(transport_b);\n\n\treturn 0;\n}\n\nint cn_send_packet_many_drops_fn(int index, void* packet, int size, void* udata)\n{\n\tcn_test_transport_data_t* data = (cn_test_transport_data_t*)udata;\n\tif (rand() % 100 != 0) return 0;\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_transport_drop_fragments_reliable_hammer, \"Create and send many fragments under extreme packet loss.\");\nint cn_transport_drop_fragments_reliable_hammer()\n{\n\tsrand(0);\n\n\tcn_test_transport_data_t data_a = cn_test_transport_data_defaults();\n\tcn_test_transport_data_t data_b = cn_test_transport_data_defaults();\n\tdata_a.id = 0;\n\tdata_b.id = 1;\n\tdouble dt = 1.0/60.0;\n\n\tcn_transport_config_t config = cn_transport_config_defaults();\n\tconfig.send_packet_fn = cn_test_transport_send_packet_fn;\n\tconfig.udata = &data_a;\n\tcn_transport_t* transport_a = cn_transport_create(config);\n\tconfig.udata = &data_b;\n\tcn_transport_t* transport_b = cn_transport_create(config);\n\tdata_a.transport_a = transport_a;\n\tdata_a.transport_b = transport_b;\n\tdata_b.transport_a = transport_a;\n\tdata_b.transport_b = transport_b;\n\n\tint packet_size = CN_KB * 10;\n\tuint8_t* packet = (uint8_t*)CN_ALLOC(packet_size, NULL);\n\tfor (int i = 0; i < packet_size; ++i) {\n\t\tpacket[i] = (uint8_t)i;\n\t}\n\n\tint fire_and_forget_packet_size = 64;\n\tuint8_t fire_and_forget_packet[64] = { 0 };\n\n\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, packet, packet_size, true)));\n\n\tvoid* packet_received;\n\tint packet_received_size;\n\n\tint iters = 0;\n\tint received = 0;\n\n\twhile (1) {\n\t\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, fire_and_forget_packet, fire_and_forget_packet_size, false)));\n\t\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, fire_and_forget_packet, fire_and_forget_packet_size, false)));\n\n\t\tcn_transport_update(transport_a, dt);\n\t\tcn_transport_update(transport_b, dt);\n\n\t\tif (!cn_is_error(cn_transport_receive_reliably_and_in_order(transport_b, &packet_received, &packet_received_size))) {\n\t\t\tCN_TEST_ASSERT(packet_size == packet_received_size);\n\t\t\tCN_TEST_ASSERT(!CN_MEMCMP(packet, packet_received, packet_size));\n\t\t\treceived = 1;\n\t\t\tcn_transport_free_packet(transport_b, packet_received);\n\t\t}\n\n\t\tvoid* data;\n\t\tint size;\n\t\tif (!cn_is_error(cn_transport_receive_fire_and_forget(transport_a, &data, &size))) {\n\t\t\tcn_transport_free_packet(transport_a, data);\n\t\t}\n\t\tif (!cn_is_error(cn_transport_receive_fire_and_forget(transport_b, &data, &size))) {\n\t\t\tcn_transport_free_packet(transport_b, data);\n\t\t}\n\t\n\t\tif (received && cn_transport_unacked_fragment_count(transport_a) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++iters == 100) {\n\t\t\tCN_TEST_ASSERT(false);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tCN_TEST_ASSERT(received);\n\tCN_FREE(packet, NULL);\n\n\tcn_transport_destroy(transport_a);\n\tcn_transport_destroy(transport_b);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_transport_send_many_reliables_at_once, \"Send over 8 reliable packets all at once.\");\nint cn_transport_send_many_reliables_at_once()\n{\n\tsrand(0);\n\n\tcn_test_transport_data_t data_a = cn_test_transport_data_defaults();\n\tcn_test_transport_data_t data_b = cn_test_transport_data_defaults();\n\tdata_a.id = 0;\n\tdata_b.id = 1;\n\tdouble dt = 1.0/60.0;\n\n\tcn_transport_config_t config = cn_transport_config_defaults();\n\tconfig.send_packet_fn = cn_test_transport_send_packet_fn;\n\tconfig.udata = &data_a;\n\tcn_transport_t* transport_a = cn_transport_create(config);\n\tconfig.udata = &data_b;\n\tcn_transport_t* transport_b = cn_transport_create(config);\n\tdata_a.transport_a = transport_a;\n\tdata_a.transport_b = transport_b;\n\tdata_b.transport_a = transport_a;\n\tdata_b.transport_b = transport_b;\n\n\tuint8_t packet = 5;\n\n\tvoid* packet_received;\n\tint packet_received_size;\n\tint iters = 0;\n\tbool done = false;\n\tint bigger_packet = 0;\n\tint expected_bigger_packet = 0;\n\n\twhile (!done) {\n\t\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_a, &packet, 1, false)));\n\t\tCN_TEST_CHECK(cn_is_error(cn_transport_send(transport_b, &packet, 1, false)));\n\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tcn_result_t result = cn_transport_send(transport_a, &bigger_packet, sizeof(int), true);\n\t\t\tif (!cn_is_error(result)) {\n\t\t\t\t++bigger_packet;\n\t\t\t}\n\t\t}\n\n\t\tcn_transport_update(transport_a, dt);\n\t\tcn_transport_update(transport_b, dt);\n\n \t\twhile (!cn_is_error(cn_transport_receive_reliably_and_in_order(transport_b, &packet_received, &packet_received_size))) {\n \t\t\tif (packet_received_size == 1) {\n\t\t\t\tCN_TEST_ASSERT(!CN_MEMCMP(&packet, packet_received, 1));\n\t\t\t\tcn_transport_free_packet(transport_b, packet_received);\n\t\t\t} else if (packet_received_size == sizeof(int)) {\n\t\t\t\tCN_TEST_ASSERT(!CN_MEMCMP(&expected_bigger_packet, packet_received, sizeof(int)));\n\t\t\t\texpected_bigger_packet++;\n\t\t\t\tcn_transport_free_packet(transport_b, packet_received);\n\t\t\t\tif (expected_bigger_packet == 5000) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCN_TEST_ASSERT(false);\n\t\t\t}\n\t\t}\n\t\n\t\tif (done && cn_transport_unacked_fragment_count(transport_a) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (iters++ == 10000) {\n\t\t\tCN_TEST_ASSERT(false);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tCN_TEST_ASSERT(done);\n\n\tcn_transport_destroy(transport_a);\n\tcn_transport_destroy(transport_b);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_connection_accepted, \"Write, encrypt, decrypt, and assert the *connection accepted packet*.\");\nint cn_packet_connection_accepted()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_connection_accepted_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_ACCEPTED;\n\tpacket.client_id = 7;\n\tpacket.max_clients = 32;\n\tpacket.connection_timeout = 10;\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_connection_accepted_t* packet_val = (cn_protocol_packet_connection_accepted_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\tCN_TEST_ASSERT(packet_val->client_id == packet.client_id);\n\tCN_TEST_ASSERT(packet_val->max_clients == packet.max_clients);\n\tCN_TEST_ASSERT(packet_val->connection_timeout == packet.connection_timeout);\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_connection_denied, \"Write, encrypt, decrypt, and assert the *connection denied packet*.\");\nint cn_packet_connection_denied()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_connection_denied_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CONNECTION_DENIED;\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_connection_denied_t* packet_val = (cn_protocol_packet_connection_denied_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_keepalive, \"Write, encrypt, decrypt, and assert the *keepalive packet*.\");\nint cn_packet_keepalive()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_keepalive_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_KEEPALIVE;\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_keepalive_t* packet_val = (cn_protocol_packet_keepalive_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_disconnect, \"Write, encrypt, decrypt, and assert the *disconnect packet*.\");\nint cn_packet_disconnect()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_disconnect_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_DISCONNECT;\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_disconnect_t* packet_val = (cn_protocol_packet_disconnect_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_challenge, \"Write, encrypt, decrypt, and assert the *challenge request packet* and *challenge response packet*.\");\nint cn_packet_challenge()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_challenge_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_CHALLENGE_REQUEST;\n\tpacket.challenge_nonce = 30;\n\tcn_crypto_random_bytes(packet.challenge_data, sizeof(packet.challenge_data));\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_challenge_t* packet_val = (cn_protocol_packet_challenge_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\tCN_TEST_ASSERT(packet_val->challenge_nonce == packet.challenge_nonce);\n\tCN_TEST_ASSERT(!(CN_MEMCMP(packet_val->challenge_data, packet.challenge_data, sizeof(packet.challenge_data))));\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_packet_payload, \"Write, encrypt, decrypt, and assert the *payload packet*.\");\nint cn_packet_payload()\n{\n\tcn_crypto_key_t key = cn_crypto_generate_key();\n\tuint64_t sequence = 100;\n\n\tcn_protocol_packet_payload_t packet;\n\tpacket.packet_type = CN_PROTOCOL_PACKET_TYPE_PAYLOAD;\n\tpacket.payload_size = CN_PROTOCOL_PACKET_PAYLOAD_MAX;\n\tcn_crypto_random_bytes(packet.payload, sizeof(packet.payload));\n\n\tuint8_t buffer[CN_PROTOCOL_PACKET_SIZE_MAX];\n\n\tint bytes_written = cn_protocol_packet_write(&packet, buffer, sequence, &key);\n\tCN_TEST_ASSERT(bytes_written > 0);\n\n\tvoid* packet_ptr = cn_protocol_packet_open(buffer, bytes_written, &key, NULL, NULL, NULL);\n\tCN_TEST_CHECK_POINTER(packet_ptr);\n\tcn_protocol_packet_payload_t* packet_val = (cn_protocol_packet_payload_t*)packet_ptr;\n\n\tCN_TEST_ASSERT(packet_val->packet_type == packet.packet_type);\n\tCN_TEST_ASSERT(packet_val->payload_size == packet.payload_size);\n\tCN_TEST_ASSERT(!(CN_MEMCMP(packet_val->payload, packet.payload, sizeof(packet.payload))));\n\n\tcn_protocol_packet_allocator_free(NULL, (cn_protocol_packet_type_t)packet.packet_type, packet_ptr);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_server, \"Create client and server, perform connection handshake, then disconnect.\");\nint cn_protocol_client_server()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 0, 0);\n\t\tcn_protocol_server_update(server, 0, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_no_server_responses, \"Client tries to connect to servers, but none respond at all.\");\nint cn_protocol_client_no_server_responses()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t\t\"[::1]:5001\",\n\t\t\"[::1]:5002\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 10, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t}\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_server_list, \"Client tries to connect to servers, but only third responds.\");\nint cn_protocol_client_server_list()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t\t\"[::1]:5001\",\n\t\t\"[::1]:5002\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 15;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5002\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 1, 0);\n\t\tcn_protocol_server_update(server, 0, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_server_challenge_response_timeout, \"Client times out when sending challenge response.\");\nint cn_protocol_server_challenge_response_timeout()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 0.1, 0);\n\n\t\tif (cn_protocol_client_get_state(client) != CN_PROTOCOL_CLIENT_STATE_SENDING_CHALLENGE_RESPONSE) {\n\t\t\tcn_protocol_server_update(server, 0, 0);\n\t\t}\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CHALLENGED_RESPONSE_TIMED_OUT);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_expired_token, \"Client gets an expired token before connecting.\");\nint cn_protocol_client_expired_token()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\tcn_protocol_client_update(client, 0, 1);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_connect_expired_token, \"Client detects its own token expires in the middle of a handshake.\");\nint cn_protocol_client_connect_expired_token()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\tuint64_t time = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 0, time++);\n\t\tcn_protocol_server_update(server, 0, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_server_connect_expired_token, \"Server detects token expires in the middle of a handshake.\");\nint cn_protocol_server_connect_expired_token()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint iters = 0;\n\tuint64_t time = 0;\n\twhile (iters++ < 100) {\n\t\t++time;\n\t\tcn_protocol_client_update(client, 0, time - 1);\n\t\tcn_protocol_server_update(server, 0, time);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECT_TOKEN_EXPIRED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_bad_keys, \"Client attempts to connect without keys from REST SECTION of connect token.\");\nint cn_protocol_client_bad_keys()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\t// Invalidate client keys.\n\tclient->connect_token.client_to_server_key = cn_crypto_generate_key();\n\tclient->connect_token.server_to_client_key = cn_crypto_generate_key();\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 1, 0);\n\t\tcn_protocol_server_update(server, 1, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_server_not_in_list_but_gets_request, \"Client tries to connect to server, but token does not contain server endpoint.\");\nint cn_protocol_server_not_in_list_but_gets_request()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5001\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\t// This will make packets arrive to correct server address, but connect token has the wrong address.\n\tCN_TEST_CHECK(cn_endpoint_init(client->connect_token.endpoints, \"[::1]:5000\"));\n\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 1, 0);\n\t\tcn_protocol_server_update(server, 1, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_connect_a_few_clients, \"Multiple clients connecting to one server.\");\nint cn_protocol_connect_a_few_clients()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 1;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client0 = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client0);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client0, connect_token)));\n\n\tclient_to_server_key = cn_crypto_generate_key();\n\tserver_to_client_key = cn_crypto_generate_key();\n\tclient_id = 2;\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client1 = cn_protocol_client_create(5002, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client1);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client1, connect_token)));\n\n\tclient_to_server_key = cn_crypto_generate_key();\n\tserver_to_client_key = cn_crypto_generate_key();\n\tclient_id = 3;\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client2 = cn_protocol_client_create(5003, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client2);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client2, connect_token)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 60.0f;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client0, dt, 0);\n\t\tcn_protocol_client_update(client1, dt, 0);\n\t\tcn_protocol_client_update(client2, dt, 0);\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tif (cn_protocol_client_get_state(client0) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client1) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client2) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client0) == CN_PROTOCOL_CLIENT_STATE_CONNECTED &&\n\t\t    cn_protocol_client_get_state(client1) == CN_PROTOCOL_CLIENT_STATE_CONNECTED &&\n\t\t    cn_protocol_client_get_state(client2) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client0) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client1) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client2) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client0);\n\tcn_protocol_client_disconnect(client1);\n\tcn_protocol_client_disconnect(client2);\n\tcn_protocol_client_destroy(client0);\n\tcn_protocol_client_destroy(client1);\n\tcn_protocol_client_destroy(client2);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_keepalive, \"Client and server setup connection and maintain it through keepalive packets.\");\nint cn_protocol_keepalive()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 1;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 60.0f;\n\twhile (iters++ < 1000) {\n\t\tcn_protocol_client_update(client, dt, 0);\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters == 1001);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_initiated_disconnect, \"Client initiates disconnect, assert disconnect occurs cleanly.\");\nint cn_protocol_client_initiated_disconnect()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 1;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 60.0f;\n\twhile (iters++ < 1000) {\n\t\tif (cn_protocol_client_get_state(client) > 0) {\n\t\t\tcn_protocol_client_update(client, dt, 0);\n\t\t}\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tif (iters == 100) {\n\t\t\tCN_TEST_ASSERT(cn_protocol_server_client_count(server) == 1);\n\t\t\tcn_protocol_client_disconnect(client);\n\t\t}\n\n\t\tif (iters == 110) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(cn_protocol_server_client_count(server) == 0);\n\tCN_TEST_ASSERT(iters == 110);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_DISCONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_server_initiated_disconnect, \"Server initiates disconnect, assert disconnect occurs cleanly.\");\nint cn_protocol_server_initiated_disconnect()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 1;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\n\tint client_index;\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 60.0f;\n\twhile (iters++ < 1000) {\n\t\tcn_protocol_client_update(client, dt, 0);\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tif (iters == 100) {\n\t\t\tCN_TEST_ASSERT(cn_protocol_server_client_count(server) == 1);\n\t\t\tcn_protocol_server_event_t event;\n\t\t\tCN_TEST_ASSERT(cn_protocol_server_pop_event(server, &event));\n\t\t\tCN_TEST_ASSERT(event.type == CN_PROTOCOL_SERVER_EVENT_NEW_CONNECTION);\n\t\t\tclient_index = event.u.new_connection.client_index;\n\t\t\tcn_protocol_server_disconnect_client(server, client_index, true);\n\t\t}\n\n\t\tif (iters == 110) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(cn_protocol_server_client_count(server) == 0);\n\tCN_TEST_ASSERT(iters == 110);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_DISCONNECTED);\n\tcn_protocol_server_event_t event;\n\tCN_TEST_ASSERT(cn_protocol_server_pop_event(server, &event));\n\tCN_TEST_ASSERT(event.type == CN_PROTOCOL_SERVER_EVENT_DISCONNECTED);\n\tCN_TEST_ASSERT(event.u.disconnected.client_index == client_index);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_server_payloads, \"Client and server connect and send payload packets. Server should confirm client.\");\nint cn_protocol_client_server_payloads()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\tint client_index;\n\tuint64_t to_server_data = 3;\n\tuint64_t to_client_data = 4;\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 60.0f;\n\tint payloads_received_by_server = 0;\n\tint payloads_received_by_client = 0;\n\twhile (iters++ < 1000) {\n\t\tcn_protocol_client_update(client, dt, 0);\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tcn_protocol_server_event_t event;\n\t\tif (cn_protocol_server_pop_event(server, &event)) {\n\t\t\tCN_TEST_ASSERT(event.type != CN_PROTOCOL_SERVER_EVENT_DISCONNECTED);\n\t\t\tif (event.type == CN_PROTOCOL_SERVER_EVENT_NEW_CONNECTION) {\n\t\t\t\tclient_index = event.u.new_connection.client_index;\n\t\t\t\tCN_TEST_ASSERT(cn_protocol_server_get_client_id(server, client_index) == client_id);\n\t\t\t} else {\n\t\t\t\tCN_TEST_ASSERT(client_index == event.u.payload_packet.client_index);\n\t\t\t\tCN_TEST_ASSERT(sizeof(uint64_t) == event.u.payload_packet.size);\n\t\t\t\tuint64_t* data = (uint64_t*)event.u.payload_packet.data;\n\t\t\t\tCN_TEST_ASSERT(*data == to_server_data);\n\t\t\t\tcn_protocol_server_free_packet(server, data);\n\t\t\t\t++payloads_received_by_server;\n\t\t\t}\n\t\t}\n\n\t\tvoid* packet = NULL;\n\t\tuint64_t sequence = ~0ULL;\n\t\tint size;\n\t\tif (cn_protocol_client_get_packet(client, &packet, &size, &sequence)) {\n\t\t\tCN_TEST_ASSERT(sizeof(uint64_t) == size);\n\t\t\tuint64_t* data = (uint64_t*)packet;\n\t\t\tCN_TEST_ASSERT(*data == to_client_data);\n\t\t\tcn_protocol_client_free_packet(client, packet);\n\t\t\t++payloads_received_by_client;\n\t\t}\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) {\n\t\t\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_send(client, &to_server_data, sizeof(uint64_t))));\n\t\t\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_send_to_client(server, &to_client_data, sizeof(uint64_t), client_index)));\n\t\t}\n\n\t\tif (payloads_received_by_server >= 10 && payloads_received_by_client >= 10) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 1000);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_multiple_connections_and_payloads, \"A server hosts multiple simultaneous clients with payloads and random disconnects/connects.\");\nint cn_protocol_multiple_connections_and_payloads()\n{\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tconst int max_clients = 5;\n\tuint64_t application_id = 100;\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 2)));\n\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 2;\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tcn_protocol_client_t** clients = (cn_protocol_client_t**)CN_ALLOC(sizeof(cn_protocol_client_t*) * max_clients, NULL);\n\n\tfor (int i = 0; i < max_clients; ++i) {\n\t\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\t\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\t\tuint64_t client_id = (uint64_t)i;\n\n\t\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\t\tapplication_id,\n\t\t\tcurrent_timestamp,\n\t\t\t&client_to_server_key,\n\t\t\t&server_to_client_key,\n\t\t\texpiration_timestamp,\n\t\t\thandshake_timeout,\n\t\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\t\tendpoints,\n\t\t\tclient_id,\n\t\t\tuser_data,\n\t\t\t&sk,\n\t\t\tconnect_token\n\t\t)));\n\t\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\t\tCN_TEST_CHECK_POINTER(client);\n\t\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\t\tclients[i] = client;\n\t}\n\n\tuint64_t to_server_data = 3;\n\tuint64_t to_client_data = 4;\n\n\tint iters = 0;\n\tfloat dt = 1.0f / 20.0f;\n\tint payloads_received_by_server = 0;\n\tint* payloads_received_by_client = (int*)CN_ALLOC(sizeof(int) * max_clients, NULL);\n\tCN_MEMSET(payloads_received_by_client, 0, sizeof(int) * max_clients);\n\tint client_count = 2;\n\twhile (iters++ < 100) {\n\t\tfor (int i = 0; i < client_count; ++i)\n\t\t\tcn_protocol_client_update(clients[i], dt, 0);\n\n\t\tcn_protocol_server_update(server, dt, 0);\n\n\t\tfor (int i = 0; i < client_count; ++i)\n\t\t\tif (cn_protocol_client_get_state(clients[i]) <= 0)\n\t\t\t\tbreak;\n\n\t\tif (iters == 4) {\n\t\t\tclient_count += 3;\n\t\t}\n\n\t\tif (iters == 8) {\n\t\t\tclient_count -= 2;\n\t\t}\n\n\t\tcn_protocol_server_event_t event;\n\t\twhile (cn_protocol_server_pop_event(server, &event)) {\n\t\t\tif (event.type == CN_PROTOCOL_SERVER_EVENT_PAYLOAD_PACKET) {\n\t\t\t\tCN_TEST_ASSERT(sizeof(uint64_t) == event.u.payload_packet.size);\n\t\t\t\tuint64_t* data = (uint64_t*)event.u.payload_packet.data;\n\t\t\t\tCN_TEST_ASSERT(*data == to_server_data);\n\t\t\t\tcn_protocol_server_free_packet(server, data);\n\t\t\t\t++payloads_received_by_server;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < client_count; ++i) {\n\t\t\tvoid* packet = NULL;\n\t\t\tuint64_t sequence = ~0ULL;\n\t\t\tint size;\n\t\t\tif (cn_protocol_client_get_packet(clients[i], &packet, &size, &sequence)) {\n\t\t\t\tCN_TEST_ASSERT(sizeof(uint64_t) == size);\n\t\t\t\tuint64_t* data = (uint64_t*)packet;\n\t\t\t\tCN_TEST_ASSERT(*data == to_client_data);\n\t\t\t\tcn_protocol_client_free_packet(clients[i], packet);\n\t\t\t\tpayloads_received_by_client[i]++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < client_count; ++i) {\n\t\t\tif (cn_protocol_client_get_state(clients[i]) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) {\n\t\t\t\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_send(clients[i], &to_server_data, sizeof(uint64_t))));\n\t\t\t\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_send_to_client(server, &to_client_data, sizeof(uint64_t), i)));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < client_count; ++i) {\n\t\tCN_TEST_ASSERT(payloads_received_by_client[i] >= 1);\n\t}\n\tfor (int i = 0; i < max_clients; ++i) {\n\t\tcn_protocol_client_update(clients[i], 0, 0);\n\t\tif (i >= client_count) {\n\t\t\tCN_TEST_ASSERT(cn_protocol_client_get_state(clients[i]) == CN_PROTOCOL_CLIENT_STATE_DISCONNECTED);\n\t\t} else {\n\t\t\tCN_TEST_ASSERT(cn_protocol_client_get_state(clients[i]) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\t\t}\n\t\tcn_protocol_client_disconnect(clients[i]);\n\t\tcn_protocol_client_destroy(clients[i]);\n\t}\n\n\tcn_protocol_server_update(server, dt, 0);\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\tCN_FREE(clients, NULL);\n\tCN_FREE(payloads_received_by_client, NULL);\n\n\treturn 0;\n}\n\nCN_TEST_CASE(cn_protocol_client_reconnect, \"Client connects to server, disconnects, and reconnects.\");\nint cn_protocol_client_reconnect()\n{\n\tcn_crypto_key_t client_to_server_key = cn_crypto_generate_key();\n\tcn_crypto_key_t server_to_client_key = cn_crypto_generate_key();\n\tcn_crypto_sign_public_t pk;\n\tcn_crypto_sign_secret_t sk;\n\tcn_crypto_sign_keygen(&pk, &sk);\n\n\tconst char* endpoints[] = {\n\t\t\"[::1]:5000\",\n\t};\n\n\tuint64_t application_id = 100;\n\tuint64_t current_timestamp = 0;\n\tuint64_t expiration_timestamp = 1;\n\tuint32_t handshake_timeout = 5;\n\tuint64_t client_id = 17;\n\n\tuint8_t user_data[CN_PROTOCOL_CONNECT_TOKEN_USER_DATA_SIZE];\n\tcn_crypto_random_bytes(user_data, sizeof(user_data));\n\n\tuint8_t connect_token[CN_PROTOCOL_CONNECT_TOKEN_SIZE];\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\tcn_protocol_server_t* server = cn_protocol_server_create(application_id, &pk, &sk, NULL);\n\tCN_TEST_CHECK_POINTER(server);\n\n\tcn_protocol_client_t* client = cn_protocol_client_create(0, application_id, true, NULL);\n\tCN_TEST_CHECK_POINTER(client);\n\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_server_start(server, \"[::1]:5000\", 5)));\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\n\t// Connect client.\n\tint iters = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 0, 0);\n\t\tcn_protocol_server_update(server, 0, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\t// Disonnect client.\n\tcn_protocol_client_disconnect(client);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_DISCONNECTED);\n\n\titers = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_server_update(server, 0, 0);\n\t\tif (cn_protocol_server_client_count(server) == 0) break;\n\t}\n\tCN_TEST_ASSERT(iters < 100);\n\n\t// Generate new connect token.\n\tCN_TEST_CHECK(cn_is_error(cn_generate_connect_token(\n\t\tapplication_id,\n\t\tcurrent_timestamp,\n\t\t&client_to_server_key,\n\t\t&server_to_client_key,\n\t\texpiration_timestamp,\n\t\thandshake_timeout,\n\t\tsizeof(endpoints) / sizeof(endpoints[0]),\n\t\tendpoints,\n\t\tclient_id,\n\t\tuser_data,\n\t\t&sk,\n\t\tconnect_token\n\t)));\n\n\t// Reconnect client.\n\tCN_TEST_CHECK(cn_is_error(cn_protocol_client_connect(client, connect_token)));\n\titers = 0;\n\twhile (iters++ < 100) {\n\t\tcn_protocol_client_update(client, 0, 0);\n\t\tcn_protocol_server_update(server, 0, 0);\n\n\t\tif (cn_protocol_client_get_state(client) <= 0) break;\n\t\tif (cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED) break;\n\t}\n\tCN_TEST_ASSERT(cn_protocol_server_running(server));\n\tCN_TEST_ASSERT(iters < 100);\n\tCN_TEST_ASSERT(cn_protocol_client_get_state(client) == CN_PROTOCOL_CLIENT_STATE_CONNECTED);\n\n\tcn_protocol_client_disconnect(client);\n\tcn_protocol_client_destroy(client);\n\n\tcn_protocol_server_update(server, 0, 0);\n\tcn_protocol_server_stop(server);\n\tcn_protocol_server_destroy(server);\n\n\treturn 0;\n}\n\n// -------------------------------------------------------------------------------------------------\n\nint cn_run_tests(int which_test, bool soak)\n{\n\tif (cn_is_error(cn_init())) {\n\t\treturn -1;\n\t}\n\n#ifdef _MSC_VER\n\t_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG | _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n\t_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n\t_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n\t_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\twindows_turn_on_console_color();\n#endif\n\n\tcn_test_t tests[] = {\n\t\tCN_TEST_CASE_ENTRY(cn_socket_init_send_recieve_shutdown),\n\t\tCN_TEST_CASE_ENTRY(cn_sequence_buffer_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_replay_buffer_valid_packets),\n\t\tCN_TEST_CASE_ENTRY(cn_replay_buffer_old_packet_out_of_range),\n\t\tCN_TEST_CASE_ENTRY(cn_replay_buffer_duplicate),\n\t\tCN_TEST_CASE_ENTRY(cn_hash_table_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_hash_table_set),\n\t\tCN_TEST_CASE_ENTRY(cn_hash_table_hammer),\n\t\tCN_TEST_CASE_ENTRY(cn_handle_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_handle_large_loop),\n\t\tCN_TEST_CASE_ENTRY(cn_handle_large_loop_and_free),\n\t\tCN_TEST_CASE_ENTRY(cn_handle_alloc_too_many),\n\t\tCN_TEST_CASE_ENTRY(cn_encryption_map_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_encryption_map_timeout_and_expiration),\n\t\tCN_TEST_CASE_ENTRY(cn_doubly_list),\n\t\tCN_TEST_CASE_ENTRY(cn_crypto_encrypt_decrypt),\n\t\tCN_TEST_CASE_ENTRY(cn_connect_token_cache),\n\t\tCN_TEST_CASE_ENTRY(cn_test_generate_connect_token),\n\t\tCN_TEST_CASE_ENTRY(cn_client_server),\n\t\tCN_TEST_CASE_ENTRY(cn_client_server_payload),\n\t\tCN_TEST_CASE_ENTRY(cn_client_server_sim),\n\t\tCN_TEST_CASE_ENTRY(cn_ack_system_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_transport_basic),\n\t\tCN_TEST_CASE_ENTRY(cn_replay_buffer_duplicate),\n\t\tCN_TEST_CASE_ENTRY(cn_transport_drop_fragments),\n\t\tCN_TEST_CASE_ENTRY(cn_transport_drop_fragments_reliable_hammer),\n\t\tCN_TEST_CASE_ENTRY(cn_transport_send_many_reliables_at_once),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_connection_accepted),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_connection_denied),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_keepalive),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_disconnect),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_challenge),\n\t\tCN_TEST_CASE_ENTRY(cn_packet_payload),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_server),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_no_server_responses),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_server_list),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_server_challenge_response_timeout),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_expired_token),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_connect_expired_token),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_server_connect_expired_token),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_bad_keys),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_server_not_in_list_but_gets_request),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_connect_a_few_clients),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_keepalive),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_initiated_disconnect),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_server_initiated_disconnect),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_server_payloads),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_multiple_connections_and_payloads),\n\t\tCN_TEST_CASE_ENTRY(cn_protocol_client_reconnect),\n\t};\n\t\n\tint test_count = sizeof(tests) / sizeof(*tests);\n\tint fail_count = 0;\n\n\tif (soak) {\n\t\twhile (1)\n\t\t{\n\t\t\tfor (int i = 0; i < test_count; ++i)\n\t\t\t{\n\t\t\t\tcn_test_t* test = tests + i;\n\t\t\t\tint result = cn_do_test(test, i + 1);\n\t\t\t\tif (result) goto break_soak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Run all tests.\n\tif (which_test == -1) {\n\t\tfor (int i = 0; i < test_count; ++i)\n\t\t{\n\t\t\tcn_test_t* test = tests + i;\n\t\t\tif (cn_do_test(test, i + 1)) fail_count++;\n\t\t}\n\t\tif (fail_count) {\n\t\t\tCN_FPRINTF(CN_TEST_IO_STREAM, \"\\033[31mFAILED\\033[0m %d test case%s.\\n\\n\", fail_count, fail_count > 1 ? \"s\" : \"\");\n\t\t} else {\n\t\t\tCN_FPRINTF(CN_TEST_IO_STREAM, \"All %d tests \\033[32mPASSED\\033[0m.\\n\\n\", test_count);\n\t\t}\n\t} else {\n\t\tcn_do_test(tests + which_test, 1);\n\t}\n\n\treturn fail_count ? -1 : 0;\n\nbreak_soak:\n\treturn -1;\n}\n\n#endif // CUTE_NET_TESTS_ONCE\n#endif // CUTE_NET_TESTS\n\n#endif // CUTE_NET_IMPLEMENTATION_ONCE\n#endif // CUTE_NET_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2023 Randy Gaul https://randygaul.github.io/\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \n\tsoftware, either in source code form or as a compiled binary, for any purpose, \n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this \n\tsoftware dedicate any and all copyright interest in the software to the public \n\tdomain. We make this dedication for the benefit of the public at large and to \n\tthe detriment of our heirs and successors. We intend this dedication to be an \n\tovert act of relinquishment in perpetuity of all present and future rights to \n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_png.h",
          "type": "blob",
          "size": 50.376953125,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_png.h - v1.05\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_PNG_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY:\n\n\t\tThis header wraps some very nice functions by Richard Mitton from his\n\t\ttigr (Tiny Graphics) library, with some additional features and small\n\t\tbug-fixes.\n\n\n\tRevision history:\n\t\t1.00 (12/23/2016) initial release\n\t\t1.01 (03/08/2017) tRNS chunk support for paletted images\n\t\t1.02 (10/23/2017) support for explicitly loading paletted png images\n\t\t1.03 (11/12/2017) construct atlas in memory\n\t\t1.04 (08/23/2018) various bug fixes for filter and word decoder\n\t\t                  added `cp_load_blank`\n\t\t1.05 (11/10/2022) added `cp_save_png_to_memory`\n\n\n\tEXAMPLES:\n\n\t\tLoading a PNG from disk, then freeing it\n\t\t\tcp_image_t img = cp_load_png(\"images/pic.png\");\n\t\t\t...\n\t\t\tfree(img.pix);\n\t\t\tCUTE_PNG_MEMSET(&img, 0, sizeof(img));\n\n\t\tLoading a PNG from memory, then freeing it\n\t\t\tcp_image_t img = cp_load_png_mem(memory, sizeof(memory));\n\t\t\t...\n\t\t\tfree(img.pix);\n\t\t\tCUTE_PNG_MEMSET(&img, 0, sizeof(img));\n\n\t\tSaving a PNG to disk\n\t\t\tcp_save_png(\"images/example.png\", &img);\n\t\t\t// img is just a raw RGBA buffer, and can come from anywhere,\n\t\t\t// not only from cp_load*** functions\n\n\t\tCreating a texture atlas in memory\n\t\t\tint w = 1024;\n\t\t\tint h = 1024;\n\t\t\tcp_atlas_image_t* imgs_out = (cp_atlas_image_t*)malloc(sizeof(cp_atlas_image_t) * my_png_count);\n\t\t\tcp_image_t atlas_img = cp_make_atlas(w, int h, my_png_array, my_png_count, imgs_out);\n\t\t\t// just pass an array of pointers to images along with the image count. Make sure to also\n\t\t\t// provide an array of `cp_atlas_image_t` for `cp_make_atlas` to output important UV info for the\n\t\t\t// images that fit into the atlas.\n\n\t\tUsing the default atlas saver\n\t\t\tint errors = cp_default_save_atlas(\"atlas.png\", \"atlas.txt\", atlas_img, atlas_imgs, img_count, names_of_all_images ? names_of_all_images : 0);\n\t\t\tif (errors) { ... }\n\t\t\t// Atlas info (like uv coordinates) are in \"atlas.txt\", and the image was writen to \"atlas.png\".\n\t\t\t// atlas_imgs was an array of `cp_atlas_image_t` from the `cp_make_atlas` function.\n\n\t\tInflating a DEFLATE block (decompressing memory stored in DEFLATE format)\n\t\t\tcp_inflate(in, in_bytes, out, out_bytes);\n\t\t\t// this function requires knowledge of the un-compressed size\n\t\t\t// does *not* do any internal realloc! Will return errors if an\n\t\t\t// attempt to overwrite the out buffer is made\n\n\tCUSTOMIZATION\n\n\t\tThere are various macros in this header you can customize by defining them before\n\t\tincluding cute_png.h. Simply define one to override the default behavior.\n\n\t\t\tCUTE_PNG_ALLOCA\n\t\t\tCUTE_PNG_ALLOC\n\t\t\tCUTE_PNG_FREE\n\t\t\tCUTE_PNG_CALLOC\n\t\t\tCUTE_PNG_REALLOC\n\t\t\tCUTE_PNG_MEMCPY\n\t\t\tCUTE_PNG_MEMCMP\n\t\t\tCUTE_PNG_MEMSET\n\t\t\tCUTE_PNG_ASSERT\n\t\t\tCUTE_PNG_FPRINTF\n\t\t\tCUTE_PNG_SEEK_SET\n\t\t\tCUTE_PNG_SEEK_END\n\t\t\tCUTE_PNG_FILE\n\t\t\tCUTE_PNG_FOPEN\n\t\t\tCUTE_PNG_FSEEK\n\t\t\tCUTE_PNG_FREAD\n\t\t\tCUTE_PNG_FTELL\n\t\t\tCUTE_PNG_FWRITE\n\t\t\tCUTE_PNG_FCLOSE\n\t\t\tCUTE_PNG_FERROR\n\t\t\tCUTE_PNG_ATLAS_MUST_FIT\n\t\t\tCUTE_PNG_ATLAS_FLIP_Y_AXIS_FOR_UV\n\t\t\tCUTE_PNG_ATLAS_EMPTY_COLOR\n*/\n\n/*\n\tContributors:\n\t\tZachary Carter    1.01 - bug catch for tRNS chunk in paletted images\n\t\tDennis Korpel     1.03 - fix some pointer/memory related bugs\n\t\tDennis Korpel     1.04 - fix for filter on first row of pixels\n*/\n\n#if !defined(CUTE_PNG_H)\n\n#ifdef _WIN32\n\t#if !defined(_CRT_SECURE_NO_WARNINGS)\n\t\t#define _CRT_SECURE_NO_WARNINGS\n\t#endif\n#endif\n\n#ifndef CUTE_PNG_ATLAS_MUST_FIT\n\t#define CUTE_PNG_ATLAS_MUST_FIT            1 // returns error from cp_make_atlas if *any* input image does not fit\n#endif // CUTE_PNG_ATLAS_MUST_FIT\n\n#ifndef CUTE_PNG_ATLAS_FLIP_Y_AXIS_FOR_UV\n\t#define CUTE_PNG_ATLAS_FLIP_Y_AXIS_FOR_UV  1 // flips output uv coordinate's y. Can be useful to \"flip image on load\"\n#endif // CUTE_PNG_ATLAS_FLIP_Y_AXIS_FOR_UV\n\n#ifndef CUTE_PNG_ATLAS_EMPTY_COLOR\n\t#define CUTE_PNG_ATLAS_EMPTY_COLOR         0x000000FF // the fill color for empty areas in a texture atlas (RGBA)\n#endif // CUTE_PNG_ATLAS_EMPTY_COLOR\n\n#include <stdint.h>\n#include <limits.h>\n\ntypedef struct cp_pixel_t cp_pixel_t;\ntypedef struct cp_image_t cp_image_t;\ntypedef struct cp_indexed_image_t cp_indexed_image_t;\ntypedef struct cp_atlas_image_t cp_atlas_image_t;\n\n// Read this in the event of errors from any function\nextern const char* cp_error_reason;\n\n// return 1 for success, 0 for failures\nint cp_inflate(void* in, int in_bytes, void* out, int out_bytes);\nint cp_save_png(const char* file_name, const cp_image_t* img);\n\ntypedef struct cp_saved_png_t\n{\n\tint size;   // Size of the `data` buffer.\n\tvoid* data; // Pointer to the saved png in memory.\n\t            // NULL if something went wrong.\n\t            // Call CUTE_PNG_FREE on `data` when done.\n} cp_saved_png_t;\n\n// Saves a png file to memory.\n// Call CUTE_PNG_FREE on .data when done.\ncp_saved_png_t cp_save_png_to_memory(const cp_image_t* img);\n\n// Constructs an atlas image in-memory. The atlas pixels are stored in the returned image. free the pixels\n// when done with them. The user must provide an array of cp_atlas_image_t for the `imgs` param. `imgs` holds\n// information about uv coordinates for an associated image in the `pngs` array. Output image has NULL\n// pixels buffer in the event of errors.\ncp_image_t cp_make_atlas(int atlasWidth, int atlasHeight, const cp_image_t* pngs, int png_count, cp_atlas_image_t* imgs_out);\n\n// A decent \"default\" function, ready to use out-of-the-box. Saves out an easy to parse text formatted info file\n// along with an atlas image. `names` param can be optionally NULL.\nint cp_default_save_atlas(const char* out_path_image, const char* out_path_atlas_txt, const cp_image_t* atlas, const cp_atlas_image_t* imgs, int img_count, const char** names);\n\n// these two functions return cp_image_t::pix as 0 in event of errors\n// call free on cp_image_t::pix when done, or call cp_free_png\ncp_image_t cp_load_png(const char *file_name);\ncp_image_t cp_load_png_mem(const void *png_data, int png_length);\ncp_image_t cp_load_blank(int w, int h); // Alloc's pixels, but `pix` memory is uninitialized.\nvoid cp_free_png(cp_image_t* img);\nvoid cp_flip_image_horizontal(cp_image_t* img);\n\n// Reads the w/h of the png without doing any other decompression or parsing.\nvoid cp_load_png_wh(const void* png_data, int png_length, int* w, int* h);\n\n// loads indexed (paletted) pngs, but does not depalette the image into RGBA pixels\n// these two functions return cp_indexed_image_t::pix as 0 in event of errors\n// call free on cp_indexed_image_t::pix when done, or call cp_free_indexed_png\ncp_indexed_image_t cp_load_indexed_png(const char* file_name);\ncp_indexed_image_t cp_load_indexed_png_mem(const void *png_data, int png_length);\nvoid cp_free_indexed_png(cp_indexed_image_t* img);\n\n// converts paletted image into a standard RGBA image\n// call free on cp_image_t::pix when done\ncp_image_t cp_depallete_indexed_image(cp_indexed_image_t* img);\n\n// Pre-process the pixels to transform the image data to a premultiplied alpha format.\n// Resource: http://www.essentialmath.com/GDC2015/VanVerth_Jim_DoingMathwRGB.pdf\nvoid cp_premultiply(cp_image_t* img);\n\nstruct cp_pixel_t\n{\n\tuint8_t r;\n\tuint8_t g;\n\tuint8_t b;\n\tuint8_t a;\n};\n\nstruct cp_image_t\n{\n\tint w;\n\tint h;\n\tcp_pixel_t* pix;\n};\n\nstruct cp_indexed_image_t\n{\n\tint w;\n\tint h;\n\tuint8_t* pix;\n\tuint8_t palette_len;\n\tcp_pixel_t palette[256];\n};\n\nstruct cp_atlas_image_t\n{\n\tint img_index;    // index into the `imgs` array\n\tint w, h;         // pixel w/h of original image\n\tfloat minx, miny; // u coordinate\n\tfloat maxx, maxy; // v coordinate\n\tint fit;          // non-zero if image fit and was placed into the atlas\n};\n\n#define CUTE_PNG_H\n#endif\n\n#ifdef CUTE_PNG_IMPLEMENTATION\n#ifndef CUTE_PNG_IMPLEMENTATION_ONCE\n#define CUTE_PNG_IMPLEMENTATION_ONCE\n\n#if !defined(CUTE_PNG_ALLOCA)\n\t#define CUTE_PNG_ALLOCA alloca\n\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__linux__)\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#if !defined(CUTE_PNG_ALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_PNG_ALLOC malloc\n#endif\n\n#if !defined(CUTE_PNG_FREE)\n\t#include <stdlib.h>\n\t#define CUTE_PNG_FREE free\n#endif\n\n#if !defined(CUTE_PNG_CALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_PNG_CALLOC calloc\n#endif\n\n#if !defined(CUTE_PNG_REALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_PNG_REALLOC realloc\n#endif\n\n#if !defined(CUTE_PNG_MEMCPY)\n\t#include <string.h>\n\t#define CUTE_PNG_MEMCPY memcpy\n#endif\n\n#if !defined(CUTE_PNG_MEMCMP)\n\t#include <string.h>\n\t#define CUTE_PNG_MEMCMP memcmp\n#endif\n\n#if !defined(CUTE_PNG_MEMSET)\n\t#include <string.h>\n\t#define CUTE_PNG_MEMSET memset\n#endif\n\n#if !defined(CUTE_PNG_ASSERT)\n\t#include <assert.h>\n\t#define CUTE_PNG_ASSERT assert\n#endif\n\n#if !defined(CUTE_PNG_FPRINTF)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FPRINTF fprintf\n#endif\n\n#if !defined(CUTE_PNG_SEEK_SET)\n\t#include <stdio.h>\n\t#define CUTE_PNG_SEEK_SET SEEK_SET\n#endif\n\n#if !defined(CUTE_PNG_SEEK_END)\n\t#include <stdio.h>\n\t#define CUTE_PNG_SEEK_END SEEK_END\n#endif\n\n#if !defined(CUTE_PNG_FILE)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FILE FILE\n#endif\n\n#if !defined(CUTE_PNG_FOPEN)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FOPEN fopen\n#endif\n\n#if !defined(CUTE_PNG_FSEEK)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FSEEK fseek\n#endif\n\n#if !defined(CUTE_PNG_FREAD)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FREAD fread\n#endif\n\n#if !defined(CUTE_PNG_FTELL)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FTELL ftell\n#endif\n\n#if !defined(CUTE_PNG_FWRITE)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FWRITE fwrite\n#endif\n\n#if !defined(CUTE_PNG_FCLOSE)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FCLOSE fclose\n#endif\n\n#if !defined(CUTE_PNG_FERROR)\n\t#include <stdio.h>\n\t#define CUTE_PNG_FERROR ferror\n#endif\n\nstatic cp_pixel_t cp_make_pixel_a(uint8_t r, uint8_t g, uint8_t b, uint8_t a)\n{\n\tcp_pixel_t p;\n\tp.r = r; p.g = g; p.b = b; p.a = a;\n\treturn p;\n}\n\nstatic cp_pixel_t cp_make_pixel(uint8_t r, uint8_t g, uint8_t b)\n{\n\tcp_pixel_t p;\n\tp.r = r; p.g = g; p.b = b; p.a = 0xFF;\n\treturn p;\n}\n\nconst char* cp_error_reason;\n#define CUTE_PNG_FAIL() do { goto cp_err; } while (0)\n#define CUTE_PNG_CHECK(X, Y) do { if (!(X)) { cp_error_reason = Y; CUTE_PNG_FAIL(); } } while (0)\n#define CUTE_PNG_CALL(X) do { if (!(X)) goto cp_err; } while (0)\n#define CUTE_PNG_LOOKUP_BITS 9\n#define CUTE_PNG_LOOKUP_COUNT (1 << CUTE_PNG_LOOKUP_BITS)\n#define CUTE_PNG_LOOKUP_MASK (CUTE_PNG_LOOKUP_COUNT - 1)\n#define CUTE_PNG_DEFLATE_MAX_BITLEN 15\n\n// DEFLATE tables from RFC 1951\nuint8_t cp_fixed_table[288 + 32] = {\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n\t9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n}; // 3.2.6\nuint8_t cp_permutation_order[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 }; // 3.2.7\nuint8_t cp_len_extra_bits[29 + 2] = { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,  0,0 }; // 3.2.5\nuint32_t cp_len_base[29 + 2] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,  0,0 }; // 3.2.5\nuint8_t cp_dist_extra_bits[30 + 2] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,  0,0 }; // 3.2.5\nuint32_t cp_dist_base[30 + 2] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 0,0 }; // 3.2.5\n\ntypedef struct cp_state_t\n{\n\tuint64_t bits;\n\tint count;\n\tuint32_t* words;\n\tint word_count;\n\tint word_index;\n\tint bits_left;\n\n\tint final_word_available;\n\tuint32_t final_word;\n\n\tchar* out;\n\tchar* out_end;\n\tchar* begin;\n\n\tuint16_t lookup[CUTE_PNG_LOOKUP_COUNT];\n\tuint32_t lit[288];\n\tuint32_t dst[32];\n\tuint32_t len[19];\n\tuint32_t nlit;\n\tuint32_t ndst;\n\tuint32_t nlen;\n} cp_state_t;\n\nstatic int cp_would_overflow(cp_state_t* s, int num_bits)\n{\n\treturn (s->bits_left + s->count) - num_bits < 0;\n}\n\nstatic char* cp_ptr(cp_state_t* s)\n{\n\tCUTE_PNG_ASSERT(!(s->bits_left & 7));\n\treturn (char*)(s->words + s->word_index) - (s->count / 8);\n}\n\nstatic uint64_t cp_peak_bits(cp_state_t* s, int num_bits_to_read)\n{\n\tif (s->count < num_bits_to_read)\n\t{\n\t\tif (s->word_index < s->word_count)\n\t\t{\n\t\t\tuint32_t word = s->words[s->word_index++];\n\t\t\ts->bits |= (uint64_t)word << s->count;\n\t\t\ts->count += 32;\n\t\t\tCUTE_PNG_ASSERT(s->word_index <= s->word_count);\n\t\t}\n\n\t\telse if (s->final_word_available)\n\t\t{\n\t\t\tuint32_t word = s->final_word;\n\t\t\ts->bits |= (uint64_t)word << s->count;\n\t\t\ts->count += s->bits_left;\n\t\t\ts->final_word_available = 0;\n\t\t}\n\t}\n\n\treturn s->bits;\n}\n\nstatic uint32_t cp_consume_bits(cp_state_t* s, int num_bits_to_read)\n{\n\tCUTE_PNG_ASSERT(s->count >= num_bits_to_read);\n\tuint32_t bits = s->bits & (((uint64_t)1 << num_bits_to_read) - 1);\n\ts->bits >>= num_bits_to_read;\n\ts->count -= num_bits_to_read;\n\ts->bits_left -= num_bits_to_read;\n\treturn bits;\n}\n\nstatic uint32_t cp_read_bits(cp_state_t* s, int num_bits_to_read)\n{\n\tCUTE_PNG_ASSERT(num_bits_to_read <= 32);\n\tCUTE_PNG_ASSERT(num_bits_to_read >= 0);\n\tCUTE_PNG_ASSERT(s->bits_left > 0);\n\tCUTE_PNG_ASSERT(s->count <= 64);\n\tCUTE_PNG_ASSERT(!cp_would_overflow(s, num_bits_to_read));\n\tcp_peak_bits(s, num_bits_to_read);\n\tuint32_t bits = cp_consume_bits(s, num_bits_to_read);\n\treturn bits;\n}\n\nstatic char* cp_read_file_to_memory(const char* path, int* size)\n{\n\tchar* data = 0;\n\tCUTE_PNG_FILE* fp = CUTE_PNG_FOPEN(path, \"rb\");\n\tint sizeNum = 0;\n\n\tif (fp)\n\t{\n\t\tCUTE_PNG_FSEEK(fp, 0, CUTE_PNG_SEEK_END);\n\t\tsizeNum = CUTE_PNG_FTELL(fp);\n\t\tCUTE_PNG_FSEEK(fp, 0, CUTE_PNG_SEEK_SET);\n\t\tdata = (char*)CUTE_PNG_ALLOC(sizeNum + 1);\n\t\tCUTE_PNG_FREAD(data, sizeNum, 1, fp);\n\t\tdata[sizeNum] = 0;\n\t\tCUTE_PNG_FCLOSE(fp);\n\t}\n\n\tif (size) *size = sizeNum;\n\treturn data;\n}\n\nstatic uint32_t cp_rev16(uint32_t a)\n{\n\ta = ((a & 0xAAAA) >>  1) | ((a & 0x5555) << 1);\n\ta = ((a & 0xCCCC) >>  2) | ((a & 0x3333) << 2);\n\ta = ((a & 0xF0F0) >>  4) | ((a & 0x0F0F) << 4);\n\ta = ((a & 0xFF00) >>  8) | ((a & 0x00FF) << 8);\n\treturn a;\n}\n\n// RFC 1951 section 3.2.2\nstatic int cp_build(cp_state_t* s, uint32_t* tree, uint8_t* lens, int sym_count)\n{\n\tint n, codes[16], first[16], counts[16] = { 0 };\n\n\t// Frequency count\n\tfor (n = 0; n < sym_count; n++) counts[lens[n]]++;\n\n\t// Distribute codes\n\tcounts[0] = codes[0] = first[0] = 0;\n\tfor (n = 1; n <= 15; ++n)\n\t{\n\t\tcodes[n] = (codes[n - 1] + counts[n - 1]) << 1;\n\t\tfirst[n] = first[n - 1] + counts[n - 1];\n\t}\n\n\tif (s) CUTE_PNG_MEMSET(s->lookup, 0, sizeof(s->lookup));\n\tfor (int i = 0; i < sym_count; ++i)\n\t{\n\t\tint len = lens[i];\n\n\t\tif (len != 0)\n\t\t{\n\t\t\tCUTE_PNG_ASSERT(len < 16);\n\t\t\tuint32_t code = codes[len]++;\n\t\t\tuint32_t slot = first[len]++;\n\t\t\ttree[slot] = (code << (32 - len)) | (i << 4) | len;\n\n\t\t\tif (s && len <= CUTE_PNG_LOOKUP_BITS)\n\t\t\t{\n\t\t\t\tint j = cp_rev16(code) >> (16 - len);\n\t\t\t\twhile (j < (1 << CUTE_PNG_LOOKUP_BITS))\n\t\t\t\t{\n\t\t\t\t\ts->lookup[j] = (uint16_t)((len << CUTE_PNG_LOOKUP_BITS) | i);\n\t\t\t\t\tj += (1 << len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_index = first[15];\n\treturn max_index;\n}\n\nstatic int cp_stored(cp_state_t* s)\n{\n\tchar* p;\n\n\t// 3.2.3\n\t// skip any remaining bits in current partially processed byte\n\tcp_read_bits(s, s->count & 7);\n\n\t// 3.2.4\n\t// read LEN and NLEN, should complement each other\n\tuint16_t LEN = (uint16_t)cp_read_bits(s, 16);\n\tuint16_t NLEN = (uint16_t)cp_read_bits(s, 16);\n\tCUTE_PNG_CHECK(LEN == (uint16_t)(~NLEN), \"Failed to find LEN and NLEN as complements within stored (uncompressed) stream.\");\n\tCUTE_PNG_CHECK(s->bits_left / 8 <= (int)LEN, \"Stored block extends beyond end of input stream.\");\n\tp = cp_ptr(s);\n\tCUTE_PNG_MEMCPY(s->out, p, LEN);\n\ts->out += LEN;\n\treturn 1;\n\ncp_err:\n\treturn 0;\n}\n\n// 3.2.6\nstatic int cp_fixed(cp_state_t* s)\n{\n\ts->nlit = cp_build(s, s->lit, cp_fixed_table, 288);\n\ts->ndst = cp_build(0, s->dst, cp_fixed_table + 288, 32);\n\treturn 1;\n}\n\nstatic int cp_decode(cp_state_t* s, uint32_t* tree, int hi)\n{\n\tuint64_t bits = cp_peak_bits(s, 16);\n\tuint32_t search = (cp_rev16((uint32_t)bits) << 16) | 0xFFFF;\n\tint lo = 0;\n\twhile (lo < hi)\n\t{\n\t\tint guess = (lo + hi) >> 1;\n\t\tif (search < tree[guess]) hi = guess;\n\t\telse lo = guess + 1;\n\t}\n\n\tuint32_t key = tree[lo - 1];\n\tuint32_t len = (32 - (key & 0xF));\n\tCUTE_PNG_ASSERT((search >> len) == (key >> len));\n\n\tint code = cp_consume_bits(s, key & 0xF);\n\t(void)code;\n\treturn (key >> 4) & 0xFFF;\n}\n\n// 3.2.7\nstatic int cp_dynamic(cp_state_t* s)\n{\n\tuint8_t lenlens[19] = { 0 };\n\n\tint nlit = 257 + cp_read_bits(s, 5);\n\tint ndst = 1 + cp_read_bits(s, 5);\n\tint nlen = 4 + cp_read_bits(s, 4);\n\n\tfor (int i = 0 ; i < nlen; ++i)\n\t\tlenlens[cp_permutation_order[i]] = (uint8_t)cp_read_bits(s, 3);\n\n\t// Build the tree for decoding code lengths\n\ts->nlen = cp_build(0, s->len, lenlens, 19);\n\tuint8_t lens[288 + 32];\n\n\tfor (int n = 0; n < nlit + ndst;)\n\t{\n\t\tint sym = cp_decode(s, s->len, s->nlen);\n\t\tswitch (sym)\n\t\t{\n\t\tcase 16: for (int i =  3 + cp_read_bits(s, 2); i; --i, ++n) lens[n] = lens[n - 1]; break;\n\t\tcase 17: for (int i =  3 + cp_read_bits(s, 3); i; --i, ++n) lens[n] = 0; break;\n\t\tcase 18: for (int i = 11 + cp_read_bits(s, 7); i; --i, ++n) lens[n] = 0; break;\n\t\tdefault: lens[n++] = (uint8_t)sym; break;\n\t\t}\n\t}\n\n\ts->nlit = cp_build(s, s->lit, lens, nlit);\n\ts->ndst = cp_build(0, s->dst, lens + nlit, ndst);\n\treturn 1;\n}\n\n// 3.2.3\nstatic int cp_block(cp_state_t* s)\n{\n\twhile (1)\n\t{\n\t\tint symbol = cp_decode(s, s->lit, s->nlit);\n\n\t\tif (symbol < 256)\n\t\t{\n\t\t\tCUTE_PNG_CHECK(s->out + 1 <= s->out_end, \"Attempted to overwrite out buffer while outputting a symbol.\");\n\t\t\t*s->out = (char)symbol;\n\t\t\ts->out += 1;\n\t\t}\n\n\t\telse if (symbol > 256)\n\t\t{\n\t\t\tsymbol -= 257;\n\t\t\tint length = cp_read_bits(s, cp_len_extra_bits[symbol]) + cp_len_base[symbol];\n\t\t\tint distance_symbol = cp_decode(s, s->dst, s->ndst);\n\t\t\tint backwards_distance = cp_read_bits(s, cp_dist_extra_bits[distance_symbol]) + cp_dist_base[distance_symbol];\n\t\t\tCUTE_PNG_CHECK(s->out - backwards_distance >= s->begin, \"Attempted to write before out buffer (invalid backwards distance).\");\n\t\t\tCUTE_PNG_CHECK(s->out + length <= s->out_end, \"Attempted to overwrite out buffer while outputting a string.\");\n\t\t\tchar* src = s->out - backwards_distance;\n\t\t\tchar* dst = s->out;\n\t\t\ts->out += length;\n\n\t\t\tswitch (backwards_distance)\n\t\t\t{\n\t\t\tcase 1: // very common in images\n\t\t\t\tCUTE_PNG_MEMSET(dst, *src, length);\n\t\t\t\tbreak;\n\t\t\tdefault: while (length--) *dst++ = *src++;\n\t\t\t}\n\t\t}\n\n\t\telse break;\n\t}\n\n\treturn 1;\n\ncp_err:\n\treturn 0;\n}\n\n// 3.2.3\nint cp_inflate(void* in, int in_bytes, void* out, int out_bytes)\n{\n\tcp_state_t* s = (cp_state_t*)CUTE_PNG_CALLOC(1, sizeof(cp_state_t));\n\ts->bits = 0;\n\ts->count = 0;\n\ts->word_index = 0;\n\ts->bits_left = in_bytes * 8;\n\n\t// s->words is the in-pointer rounded up to a multiple of 4\n\tint first_bytes = (int) ((( (size_t) in + 3) & ~3) - (size_t) in);\n\ts->words = (uint32_t*)((char*)in + first_bytes);\n\ts->word_count = (in_bytes - first_bytes) / 4;\n\tint last_bytes = ((in_bytes - first_bytes) & 3);\n\n\tfor (int i = 0; i < first_bytes; ++i)\n\t\ts->bits |= (uint64_t)(((uint8_t*)in)[i]) << (i * 8);\n\n\ts->final_word_available = last_bytes ? 1 : 0;\n\ts->final_word = 0;\n\tfor(int i = 0; i < last_bytes; i++) \n\t\ts->final_word |= ((uint8_t*)in)[in_bytes - last_bytes+i] << (i * 8);\n\n\ts->count = first_bytes * 8;\n\n\ts->out = (char*)out;\n\ts->out_end = s->out + out_bytes;\n\ts->begin = (char*)out;\n\n\tint count = 0;\n\tint bfinal;\n\tdo\n\t{\n\t\tbfinal = cp_read_bits(s, 1);\n\t\tint btype = cp_read_bits(s, 2);\n\n\t\tswitch (btype)\n\t\t{\n\t\tcase 0: CUTE_PNG_CALL(cp_stored(s)); break;\n\t\tcase 1: cp_fixed(s); CUTE_PNG_CALL(cp_block(s)); break;\n\t\tcase 2: cp_dynamic(s); CUTE_PNG_CALL(cp_block(s)); break;\n\t\tcase 3: CUTE_PNG_CHECK(0, \"Detected unknown block type within input stream.\");\n\t\t}\n\n\t\t++count;\n\t}\n\twhile (!bfinal);\n\n\tCUTE_PNG_FREE(s);\n\treturn 1;\n\ncp_err:\n\tCUTE_PNG_FREE(s);\n\treturn 0;\n}\n\nstatic uint8_t cp_paeth(uint8_t a, uint8_t b, uint8_t c)\n{\n\tint p = a + b - c;\n\tint pa = abs(p - a);\n\tint pb = abs(p - b);\n\tint pc = abs(p - c);\n\treturn (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;\n}\n\ntypedef struct cp_save_png_data_t\n{\n\tuint32_t crc;\n\tuint32_t adler;\n\tuint32_t bits;\n\tuint32_t prev;\n\tuint32_t runlen;\n\tint buflen;\n\tint bufcap;\n\tchar* buffer;\n} cp_save_png_data_t;\n\nuint32_t CP_CRC_TABLE[] = {\n\t0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n\t0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n};\n\nstatic void cp_put8(cp_save_png_data_t* s, uint32_t a)\n{\n\tif (s->buflen >= s->bufcap)\n\t{\n\t\ts->bufcap *= 2;\n\t\ts->buffer = (char*)CUTE_PNG_REALLOC(s->buffer, s->bufcap);\n\t}\n\ts->buffer[s->buflen++] = a;\n\ts->crc = (s->crc >> 4) ^ CP_CRC_TABLE[(s->crc & 15) ^ (a & 15)];\n\ts->crc = (s->crc >> 4) ^ CP_CRC_TABLE[(s->crc & 15) ^ (a >> 4)];\n}\n\nstatic void cp_update_adler(cp_save_png_data_t* s, uint32_t v)\n{\n\tuint32_t s1 = s->adler & 0xFFFF;\n\tuint32_t s2 = (s->adler >> 16) & 0xFFFF;\n\ts1 = (s1 + v) % 65521;\n\ts2 = (s2 + s1) % 65521;\n\ts->adler = (s2 << 16) + s1;\n}\n\nstatic void cp_put32(cp_save_png_data_t* s, uint32_t v)\n{\n\tcp_put8(s, (v >> 24) & 0xFF);\n\tcp_put8(s, (v >> 16) & 0xFF);\n\tcp_put8(s, (v >> 8) & 0xFF);\n\tcp_put8(s, v & 0xFF);\n}\n\nstatic void cp_put_bits(cp_save_png_data_t* s, uint32_t data, uint32_t bitcount)\n{\n\twhile (bitcount--)\n\t{\n\t\tuint32_t prev = s->bits;\n\t\ts->bits = (s->bits >> 1) | ((data & 1) << 7);\n\t\tdata >>= 1;\n\n\t\tif (prev & 1)\n\t\t{\n\t\t\tcp_put8(s, s->bits);\n\t\t\ts->bits = 0x80;\n\t\t}\n\t}\n}\n\nstatic void cp_put_bitsr(cp_save_png_data_t* s, uint32_t data, uint32_t bitcount)\n{\n\twhile (bitcount--)\n\t\tcp_put_bits(s, data >> bitcount, 1);\n}\n\nstatic void cp_begin_chunk(cp_save_png_data_t* s, const char* id, uint32_t len)\n{\n\tcp_put32(s, len);\n\ts->crc = 0xFFFFFFFF;\n\tcp_put8(s, (unsigned char)id[0]);\n\tcp_put8(s, (unsigned char)id[1]);\n\tcp_put8(s, (unsigned char)id[2]);\n\tcp_put8(s, (unsigned char)id[3]);\n}\n\nstatic void cp_encode_literal(cp_save_png_data_t* s, uint32_t v)\n{\n\t// Encode a literal/length using the built-in tables.\n\t// Could do better with a custom table but whatever.\n\t     if (v < 144) cp_put_bitsr(s, 0x030 + v -   0, 8);\n\telse if (v < 256) cp_put_bitsr(s, 0x190 + v - 144, 9);\n\telse if (v < 280) cp_put_bitsr(s, 0x000 + v - 256, 7);\n\telse              cp_put_bitsr(s, 0x0c0 + v - 280, 8);\n}\n\nstatic void cp_encode_len(cp_save_png_data_t* s, uint32_t code, uint32_t bits, uint32_t len)\n{\n\tcp_encode_literal(s, code + (len >> bits));\n\tcp_put_bits(s, len, bits);\n\tcp_put_bits(s, 0, 5);\n}\n\nstatic void cp_end_run(cp_save_png_data_t* s)\n{\n\ts->runlen--;\n\tcp_encode_literal(s, s->prev);\n\n\tif (s->runlen >= 67) cp_encode_len(s, 277, 4, s->runlen - 67);\n\telse if (s->runlen >= 35) cp_encode_len(s, 273, 3, s->runlen - 35);\n\telse if (s->runlen >= 19) cp_encode_len(s, 269, 2, s->runlen - 19);\n\telse if (s->runlen >= 11) cp_encode_len(s, 265, 1, s->runlen - 11);\n\telse if (s->runlen >= 3) cp_encode_len(s, 257, 0, s->runlen - 3);\n\telse while (s->runlen--) cp_encode_literal(s, s->prev);\n}\n\nstatic void cp_encode_byte(cp_save_png_data_t *s, uint8_t v)\n{\n\tcp_update_adler(s, v);\n\n\t// Simple RLE compression. We could do better by doing a search\n\t// to find matches, but this works pretty well TBH.\n\tif (s->prev == v && s->runlen < 115) s->runlen++;\n\n\telse\n\t{\n\t\tif (s->runlen) cp_end_run(s);\n\n\t\ts->prev = v;\n\t\ts->runlen = 1;\n\t}\n}\n\nstatic void cp_save_header(cp_save_png_data_t* s, cp_image_t* img)\n{\n\tconst unsigned char* hdr = (const unsigned char*)\"\\211PNG\\r\\n\\032\\n\";\n\tfor (int i = 0; i < 8; ++i) {\n\t\tcp_put8(s, *hdr++);\n\t}\n\tcp_begin_chunk(s, \"IHDR\", 13);\n\tcp_put32(s, img->w);\n\tcp_put32(s, img->h);\n\tcp_put8(s, 8); // bit depth\n\tcp_put8(s, 6); // RGBA\n\tcp_put8(s, 0); // compression (deflate)\n\tcp_put8(s, 0); // filter (standard)\n\tcp_put8(s, 0); // interlace off\n\tcp_put32(s, ~s->crc);\n}\n\nstatic void cp_save_data(cp_save_png_data_t* s, cp_image_t* img, long dataPos, long* dataSize)\n{\n\tcp_begin_chunk(s, \"IDAT\", 0);\n\tcp_put8(s, 0x08); // zlib compression method\n\tcp_put8(s, 0x1D); // zlib compression flags\n\tcp_put_bits(s, 3, 3); // zlib last block + fixed dictionary\n\n\tfor (int y = 0; y < img->h; ++y)\n\t{\n\t\tcp_pixel_t *row = &img->pix[y * img->w];\n\t\tcp_pixel_t prev = cp_make_pixel_a(0, 0, 0, 0);\n\n\t\tcp_encode_byte(s, 1); // sub filter\n\t\tfor (int x = 0; x < img->w; ++x)\n\t\t{\n\t\t\tcp_encode_byte(s, row[x].r - prev.r);\n\t\t\tcp_encode_byte(s, row[x].g - prev.g);\n\t\t\tcp_encode_byte(s, row[x].b - prev.b);\n\t\t\tcp_encode_byte(s, row[x].a - prev.a);\n\t\t\tprev = row[x];\n\t\t}\n\t}\n\n\tcp_end_run(s);\n\tcp_encode_literal(s, 256); // terminator\n\twhile (s->bits != 0x80) cp_put_bits(s, 0, 1);\n\tcp_put32(s, s->adler);\n\t*dataSize = (s->buflen - dataPos) - 8;\n\tcp_put32(s, ~s->crc);\n}\n\ncp_saved_png_t cp_save_png_to_memory(const cp_image_t* img)\n{\n\tcp_saved_png_t result = { 0 };\n\tcp_save_png_data_t s = { 0 };\n\tlong dataPos, dataSize, fileSize;\n\tif (!img) return result;\n\n\ts.adler = 1;\n\ts.bits = 0x80;\n\ts.prev = 0xFFFF;\n\ts.bufcap = 1024;\n\ts.buffer = (char*)CUTE_PNG_ALLOC(1024);\n\n\tcp_save_header(&s, (cp_image_t*)img);\n\tdataPos = s.buflen;\n\tcp_save_data(&s, (cp_image_t*)img, dataPos, &dataSize);\n\n\t// End chunk.\n\tcp_begin_chunk(&s, \"IEND\", 0);\n\tcp_put32(&s, ~s.crc);\n\n\t// Write back payload size.\n\tfileSize = s.buflen;\n\ts.buflen = dataPos;\n\tcp_put32(&s, dataSize);\n\n\tresult.size = fileSize;\n\tresult.data = s.buffer;\n\treturn result;\n}\n\nint cp_save_png(const char* file_name, const cp_image_t* img)\n{\n\tcp_saved_png_t s;\n\tlong err;\n\tCUTE_PNG_FILE* fp = CUTE_PNG_FOPEN(file_name, \"wb\");\n\tif (!fp) return 1;\n\ts = cp_save_png_to_memory(img);\n\tCUTE_PNG_FWRITE(s.data, s.size, 1, fp);\n\terr = CUTE_PNG_FERROR(fp);\n\tCUTE_PNG_FCLOSE(fp);\n\tCUTE_PNG_FREE(s.data);\n\treturn !err;\n}\n\ntypedef struct cp_raw_png_t\n{\n\tconst uint8_t* p;\n\tconst uint8_t* end;\n} cp_raw_png_t;\n\nstatic uint32_t cp_make32(const uint8_t* s)\n{\n\treturn (s[0] << 24) | (s[1] << 16) | (s[2] << 8) | s[3];\n}\n\nstatic const uint8_t* cp_chunk(cp_raw_png_t* png, const char* chunk, uint32_t minlen)\n{\n\tuint32_t len = cp_make32(png->p);\n\tconst uint8_t* start = png->p;\n\n\tif (!CUTE_PNG_MEMCMP(start + 4, chunk, 4) && len >= minlen)\n\t{\n\t\tint offset = len + 12;\n\n\t\tif (png->p + offset <= png->end)\n\t\t{\n\t\t\tpng->p += offset;\n\t\t\treturn start + 8;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const uint8_t* cp_find(cp_raw_png_t* png, const char* chunk, uint32_t minlen)\n{\n\tconst uint8_t *start;\n\twhile (png->p < png->end)\n\t{\n\t\tuint32_t len = cp_make32(png->p);\n\t\tstart = png->p;\n\t\tpng->p += len + 12;\n\n\t\tif (!CUTE_PNG_MEMCMP(start+4, chunk, 4) && len >= minlen && png->p <= png->end)\n\t\t\treturn start + 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int cp_unfilter(int w, int h, int bpp, uint8_t* raw)\n{\n\tint len = w * bpp;\n\tuint8_t *prev;\n\tint x;\n\n\tif (h > 0)\n\t{\n#define FILTER_LOOP_FIRST(A) for (x = bpp; x < len; x++) raw[x] += A; break\n\t\tswitch (*raw++)\n\t\t{\n\t\tcase 0: break;\n\t\tcase 1: FILTER_LOOP_FIRST(raw[x - bpp]);\n\t\tcase 2: break;\n\t\tcase 3: FILTER_LOOP_FIRST(raw[x - bpp] / 2);\n\t\tcase 4: FILTER_LOOP_FIRST(cp_paeth(raw[x - bpp], 0, 0));\n\t\tdefault: return 0;\n\t\t}\n#undef FILTER_LOOP_FIRST\n\t}\n\n\tprev = raw;\n\traw += len;\n\n\tfor (int y = 1; y < h; y++, prev = raw, raw += len)\n\t{\n#define FILTER_LOOP(A, B) for (x = 0 ; x < bpp; x++) raw[x] += A; for (; x < len; x++) raw[x] += B; break\n\t\tswitch (*raw++)\n\t\t{\n\t\tcase 0: break;\n\t\tcase 1: FILTER_LOOP(0          , raw[x - bpp] );\n\t\tcase 2: FILTER_LOOP(prev[x]    , prev[x]);\n\t\tcase 3: FILTER_LOOP(prev[x] / 2, (raw[x - bpp] + prev[x]) / 2);\n\t\tcase 4: FILTER_LOOP(prev[x]    , cp_paeth(raw[x - bpp], prev[x], prev[x -bpp]));\n\t\tdefault: return 0;\n\t\t}\n#undef FILTER_LOOP\n\t}\n\n\treturn 1;\n}\n\nstatic void cp_convert(int bpp, int w, int h, uint8_t* src, cp_pixel_t* dst)\n{\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\t// skip filter byte\n\t\tsrc++;\n\n\t\tfor (int x = 0; x < w; x++, src += bpp)\n\t\t{\n\t\t\tswitch (bpp)\n\t\t\t{\n\t\t\t\tcase 1: *dst++ = cp_make_pixel(src[0], src[0], src[0]); break;\n\t\t\t\tcase 2: *dst++ = cp_make_pixel_a(src[0], src[0], src[0], src[1]); break;\n\t\t\t\tcase 3: *dst++ = cp_make_pixel(src[0], src[1], src[2]); break;\n\t\t\t\tcase 4: *dst++ = cp_make_pixel_a(src[0], src[1], src[2], src[3]); break;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.tRNS\nstatic uint8_t cp_get_alpha_for_indexed_image(int index, const uint8_t* trns, uint32_t trns_len)\n{\n\tif (!trns) return 255;\n\telse if ((uint32_t)index >= trns_len) return 255;\n\telse return trns[index];\n}\n\nstatic void cp_depalette(int w, int h, uint8_t* src, cp_pixel_t* dst, const uint8_t* plte, const uint8_t* trns, uint32_t trns_len)\n{\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\t// skip filter byte\n\t\t++src;\n\n\t\tfor (int x = 0; x < w; ++x, ++src)\n\t\t{\n\t\t\tint c = *src;\n\t\t\tuint8_t r = plte[c * 3];\n\t\t\tuint8_t g = plte[c * 3 + 1];\n\t\t\tuint8_t b = plte[c * 3 + 2];\n\t\t\tuint8_t a = cp_get_alpha_for_indexed_image(c, trns, trns_len);\n\t\t\t*dst++ = cp_make_pixel_a(r, g, b, a);\n\t\t}\n\t}\n}\n\nstatic uint32_t cp_get_chunk_byte_length(const uint8_t* chunk)\n{\n\treturn cp_make32(chunk - 8);\n}\n\nstatic int cp_out_size(cp_image_t* img, int bpp)\n{\n\treturn (img->w + 1) * img->h * bpp;\n}\n\ncp_image_t cp_load_png_mem(const void* png_data, int png_length)\n{\n\tconst char* sig = \"\\211PNG\\r\\n\\032\\n\";\n\tconst uint8_t* ihdr, *first, *plte, *trns;\n\tint bit_depth, color_type, bpp, w, h, pix_bytes;\n\tint compression, filter, interlace;\n\tint datalen, offset;\n\tuint8_t* out;\n\tcp_image_t img = { 0 };\n\tuint8_t* data = 0;\n\tcp_raw_png_t png;\n\tpng.p = (uint8_t*)png_data;\n\tpng.end = (uint8_t*)png_data + png_length;\n\n\tCUTE_PNG_CHECK(!CUTE_PNG_MEMCMP(png.p, sig, 8), \"incorrect file signature (is this a png file?)\");\n\tpng.p += 8;\n\n\tihdr = cp_chunk(&png, \"IHDR\", 13);\n\tCUTE_PNG_CHECK(ihdr, \"unable to find IHDR chunk\");\n\tbit_depth = ihdr[8];\n\tcolor_type = ihdr[9];\n\tCUTE_PNG_CHECK(bit_depth == 8, \"only bit-depth of 8 is supported\");\n\n\tswitch (color_type)\n\t{\n\t\tcase 0: bpp = 1; break; // greyscale\n\t\tcase 2: bpp = 3; break; // RGB\n\t\tcase 3: bpp = 1; break; // paletted\n\t\tcase 4: bpp = 2; break; // grey+alpha\n\t\tcase 6: bpp = 4; break; // RGBA\n\t\tdefault: CUTE_PNG_CHECK(0, \"unknown color type\");\n\t}\n\n\t// +1 for filter byte (which is dumb! just stick this at file header...)\n\tw = cp_make32(ihdr) + 1;\n\th = cp_make32(ihdr + 4);\n\tCUTE_PNG_CHECK(w >= 1, \"invalid IHDR chunk found, image width was less than 1\");\n\tCUTE_PNG_CHECK(h >= 1, \"invalid IHDR chunk found, image height was less than 1\");\n        CUTE_PNG_CHECK((int64_t) w * h * sizeof(cp_pixel_t) < INT_MAX, \"image too large\");\n\tpix_bytes = w * h * sizeof(cp_pixel_t);\n\timg.w = w - 1;\n\timg.h = h;\n\timg.pix = (cp_pixel_t*)CUTE_PNG_ALLOC(pix_bytes);\n\tCUTE_PNG_CHECK(img.pix, \"unable to allocate raw image space\");\n\n\tcompression = ihdr[10];\n\tfilter = ihdr[11];\n\tinterlace = ihdr[12];\n\tCUTE_PNG_CHECK(!compression, \"only standard compression DEFLATE is supported\");\n\tCUTE_PNG_CHECK(!filter, \"only standard adaptive filtering is supported\");\n\tCUTE_PNG_CHECK(!interlace, \"interlacing is not supported\");\n\n\t// PLTE must come before any IDAT chunk\n\tfirst = png.p;\n\tplte = cp_find(&png, \"PLTE\", 0);\n\tif (!plte) png.p = first;\n\telse first = png.p;\n\n\t// tRNS can come after PLTE\n\ttrns = cp_find(&png, \"tRNS\", 0);\n\tif (!trns) png.p = first;\n\telse first = png.p;\n\n\t// Compute length of the DEFLATE stream through IDAT chunk data sizes\n\tdatalen = 0;\n\tfor (const uint8_t* idat = cp_find(&png, \"IDAT\", 0); idat; idat = cp_chunk(&png, \"IDAT\", 0))\n\t{\n\t\tuint32_t len = cp_get_chunk_byte_length(idat);\n\t\tdatalen += len;\n\t}\n\n\t// Copy in IDAT chunk data sections to form the compressed DEFLATE stream\n\tpng.p = first;\n\tdata = (uint8_t*)CUTE_PNG_ALLOC(datalen);\n\toffset = 0;\n\tfor (const uint8_t* idat = cp_find(&png, \"IDAT\", 0); idat; idat = cp_chunk(&png, \"IDAT\", 0))\n\t{\n\t\tuint32_t len = cp_get_chunk_byte_length(idat);\n\t\tCUTE_PNG_MEMCPY(data + offset, idat, len);\n\t\toffset += len;\n\t}\n\n\t// check for proper zlib structure in DEFLATE stream\n\tCUTE_PNG_CHECK(data && datalen >= 6, \"corrupt zlib structure in DEFLATE stream\");\n\tCUTE_PNG_CHECK((data[0] & 0x0f) == 0x08, \"only zlib compression method (RFC 1950) is supported\");\n\tCUTE_PNG_CHECK((data[0] & 0xf0) <= 0x70, \"innapropriate window size detected\");\n\tCUTE_PNG_CHECK(!(data[1] & 0x20), \"preset dictionary is present and not supported\");\n\n\t// check for integer overflow\n\tCUTE_PNG_CHECK(cp_out_size(&img, 4) >= 1, \"invalid image size found\");\n\tCUTE_PNG_CHECK(cp_out_size(&img, bpp) >= 1, \"invalid image size found\");\n\n\tout = (uint8_t*)img.pix + cp_out_size(&img, 4) - cp_out_size(&img, bpp);\n\tCUTE_PNG_CHECK(cp_inflate(data + 2, datalen - 6, out, pix_bytes), \"DEFLATE algorithm failed\");\n\tCUTE_PNG_CHECK(cp_unfilter(img.w, img.h, bpp, out), \"invalid filter byte found\");\n\n\tif (color_type == 3)\n\t{\n\t\tCUTE_PNG_CHECK(plte, \"color type of indexed requires a PLTE chunk\");\n\t\tuint32_t trns_len = trns ? cp_get_chunk_byte_length(trns) : 0;\n\t\tcp_depalette(img.w, img.h, out, img.pix, plte, trns, trns_len);\n\t}\n\telse cp_convert(bpp, img.w, img.h, out, img.pix);\n\n\tCUTE_PNG_FREE(data);\n\treturn img;\n\ncp_err:\n\tCUTE_PNG_FREE(data);\n\tCUTE_PNG_FREE(img.pix);\n\timg.pix = 0;\n\n\treturn img;\n}\n\ncp_image_t cp_load_blank(int w, int h)\n{\n\tcp_image_t img;\n\timg.w = w;\n\timg.h = h;\n\timg.pix = (cp_pixel_t*)CUTE_PNG_ALLOC(w * h * sizeof(cp_pixel_t));\n\treturn img;\n}\n\ncp_image_t cp_load_png(const char *file_name)\n{\n\tcp_image_t img = { 0 };\n\tint len;\n\tvoid* data = cp_read_file_to_memory(file_name, &len);\n\tif (!data) return img;\n\timg = cp_load_png_mem(data, len);\n\tCUTE_PNG_FREE(data);\n\treturn img;\n}\n\nvoid cp_free_png(cp_image_t* img)\n{\n\tCUTE_PNG_FREE(img->pix);\n\timg->pix = 0;\n\timg->w = img->h = 0;\n}\n\nvoid cp_flip_image_horizontal(cp_image_t* img)\n{\n\tcp_pixel_t* pix = img->pix;\n\tint w = img->w;\n\tint h = img->h;\n\tint flips = h / 2;\n\tfor (int i = 0; i < flips; ++i)\n\t{\n\t\tcp_pixel_t* a = pix + w * i;\n\t\tcp_pixel_t* b = pix + w * (h - i - 1);\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tcp_pixel_t t = *a;\n\t\t\t*a = *b;\n\t\t\t*b = t;\n\t\t\t++a;\n\t\t\t++b;\n\t\t}\n\t}\n}\n\nvoid cp_load_png_wh(const void* png_data, int png_length, int* w_out, int* h_out)\n{\n\tconst char* sig = \"\\211PNG\\r\\n\\032\\n\";\n\tconst uint8_t* ihdr;\n\tcp_raw_png_t png;\n\tint w, h;\n\tpng.p = (uint8_t*)png_data;\n\tpng.end = (uint8_t*)png_data + png_length;\n\n\tif (w_out) *w_out = 0;\n\tif (h_out) *h_out = 0;\n\n\tCUTE_PNG_CHECK(!CUTE_PNG_MEMCMP(png.p, sig, 8), \"incorrect file signature (is this a png file?)\");\n\tpng.p += 8;\n\n\tihdr = cp_chunk(&png, \"IHDR\", 13);\n\tCUTE_PNG_CHECK(ihdr, \"unable to find IHDR chunk\");\n\n\t// +1 for filter byte (which is dumb! just stick this at file header...)\n\tw = cp_make32(ihdr) + 1;\n\th = cp_make32(ihdr + 4);\n\tif (w_out) *w_out = w - 1;\n\tif (h_out) *h_out = h;\n\n\tcp_err:;\n}\n\ncp_indexed_image_t cp_load_indexed_png(const char* file_name)\n{\n\tcp_indexed_image_t img = { 0 };\n\tint len;\n\tvoid* data = cp_read_file_to_memory(file_name, &len);\n\tif (!data) return img;\n\timg = cp_load_indexed_png_mem(data, len);\n\tCUTE_PNG_FREE(data);\n\treturn img;\n}\n\nstatic void cp_unpack_indexed_rows(int w, int h, uint8_t* src, uint8_t* dst)\n{\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\t// skip filter byte\n\t\t++src;\n\n\t\tfor (int x = 0; x < w; ++x, ++src)\n\t\t{\n\t\t\t*dst++ = *src;\n\t\t}\n\t}\n}\n\nvoid cp_unpack_palette(cp_pixel_t* dst, const uint8_t* plte, int plte_len, const uint8_t* trns, int trns_len)\n{\n\tfor (int i = 0; i < plte_len * 3; i += 3)\n\t{\n\t\tunsigned char r = plte[i];\n\t\tunsigned char g = plte[i + 1];\n\t\tunsigned char b = plte[i + 2];\n\t\tunsigned char a = cp_get_alpha_for_indexed_image(i / 3, trns, trns_len);\n\t\tcp_pixel_t p = cp_make_pixel_a(r, g, b, a);\n\t\t*dst++ = p;\n\t}\n}\n\ncp_indexed_image_t cp_load_indexed_png_mem(const void *png_data, int png_length)\n{\n\tconst char* sig = \"\\211PNG\\r\\n\\032\\n\";\n\tconst uint8_t* ihdr, *first, *plte, *trns;\n\tint bit_depth, color_type, bpp, w, h, pix_bytes;\n\tint compression, filter, interlace;\n\tint datalen, offset;\n\tint plte_len;\n\tuint8_t* out;\n\tcp_indexed_image_t img = { 0 };\n\tuint8_t* data = 0;\n\tcp_raw_png_t png;\n\tpng.p = (uint8_t*)png_data;\n\tpng.end = (uint8_t*)png_data + png_length;\n\n\tCUTE_PNG_CHECK(!CUTE_PNG_MEMCMP(png.p, sig, 8), \"incorrect file signature (is this a png file?)\");\n\tpng.p += 8;\n\n\tihdr = cp_chunk(&png, \"IHDR\", 13);\n\tCUTE_PNG_CHECK(ihdr, \"unable to find IHDR chunk\");\n\tbit_depth = ihdr[8];\n\tcolor_type = ihdr[9];\n\tbpp = 1; // bytes per pixel\n\tCUTE_PNG_CHECK(bit_depth == 8, \"only bit-depth of 8 is supported\");\n\tCUTE_PNG_CHECK(color_type == 3, \"only indexed png images (images with a palette) are valid for cp_load_indexed_png_mem\");\n\n\t// +1 for filter byte (which is dumb! just stick this at file header...)\n\tw = cp_make32(ihdr) + 1;\n\th = cp_make32(ihdr + 4);\n        CUTE_PNG_CHECK((int64_t) w * h * sizeof(uint8_t) < INT_MAX, \"image too large\");\n\tpix_bytes = w * h * sizeof(uint8_t);\n\timg.w = w - 1;\n\timg.h = h;\n\timg.pix = (uint8_t*)CUTE_PNG_ALLOC(pix_bytes);\n\tCUTE_PNG_CHECK(img.pix, \"unable to allocate raw image space\");\n\n\tcompression = ihdr[10];\n\tfilter = ihdr[11];\n\tinterlace = ihdr[12];\n\tCUTE_PNG_CHECK(!compression, \"only standard compression DEFLATE is supported\");\n\tCUTE_PNG_CHECK(!filter, \"only standard adaptive filtering is supported\");\n\tCUTE_PNG_CHECK(!interlace, \"interlacing is not supported\");\n\n\t// PLTE must come before any IDAT chunk\n\tfirst = png.p;\n\tplte = cp_find(&png, \"PLTE\", 0);\n\tif (!plte) png.p = first;\n\telse first = png.p;\n\n\t// tRNS can come after PLTE\n\ttrns = cp_find(&png, \"tRNS\", 0);\n\tif (!trns) png.p = first;\n\telse first = png.p;\n\n\t// Compute length of the DEFLATE stream through IDAT chunk data sizes\n\tdatalen = 0;\n\tfor (const uint8_t* idat = cp_find(&png, \"IDAT\", 0); idat; idat = cp_chunk(&png, \"IDAT\", 0))\n\t{\n\t\tuint32_t len = cp_get_chunk_byte_length(idat);\n\t\tdatalen += len;\n\t}\n\n\t// Copy in IDAT chunk data sections to form the compressed DEFLATE stream\n\tpng.p = first;\n\tdata = (uint8_t*)CUTE_PNG_ALLOC(datalen);\n\toffset = 0;\n\tfor (const uint8_t* idat = cp_find(&png, \"IDAT\", 0); idat; idat = cp_chunk(&png, \"IDAT\", 0))\n\t{\n\t\tuint32_t len = cp_get_chunk_byte_length(idat);\n\t\tCUTE_PNG_MEMCPY(data + offset, idat, len);\n\t\toffset += len;\n\t}\n\n\t// check for proper zlib structure in DEFLATE stream\n\tCUTE_PNG_CHECK(data && datalen >= 6, \"corrupt zlib structure in DEFLATE stream\");\n\tCUTE_PNG_CHECK((data[0] & 0x0f) == 0x08, \"only zlib compression method (RFC 1950) is supported\");\n\tCUTE_PNG_CHECK((data[0] & 0xf0) <= 0x70, \"innapropriate window size detected\");\n\tCUTE_PNG_CHECK(!(data[1] & 0x20), \"preset dictionary is present and not supported\");\n\n\tout = img.pix;\n\tCUTE_PNG_CHECK(cp_inflate(data + 2, datalen - 6, out, pix_bytes), \"DEFLATE algorithm failed\");\n\tCUTE_PNG_CHECK(cp_unfilter(img.w, img.h, bpp, out), \"invalid filter byte found\");\n\tcp_unpack_indexed_rows(img.w, img.h, out, img.pix);\n\n\tplte_len = cp_get_chunk_byte_length(plte) / 3;\n\tcp_unpack_palette(img.palette, plte, plte_len, trns, cp_get_chunk_byte_length(trns));\n\timg.palette_len = (uint8_t)plte_len;\n\n\tCUTE_PNG_FREE(data);\n\treturn img;\n\ncp_err:\n\tCUTE_PNG_FREE(data);\n\tCUTE_PNG_FREE(img.pix);\n\timg.pix = 0;\n\n\treturn img;\n}\n\nvoid cp_free_indexed_png(cp_indexed_image_t* img)\n{\n\tCUTE_PNG_FREE(img->pix);\n\timg->pix = 0;\n\timg->w = img->h = 0;\n}\n\ncp_image_t cp_depallete_indexed_image(cp_indexed_image_t* img)\n{\n\tcp_image_t out = { 0 };\n\tout.w = img->w;\n\tout.h = img->h;\n\tout.pix = (cp_pixel_t*)CUTE_PNG_ALLOC(sizeof(cp_pixel_t) * out.w * out.h);\n\n\tcp_pixel_t* dst = out.pix;\n\tuint8_t* src = img->pix;\n\n\tfor (int y = 0; y < out.h; ++y)\n\t{\n\t\tfor (int x = 0; x < out.w; ++x)\n\t\t{\n\t\t\tint index = *src++;\n\t\t\tcp_pixel_t p = img->palette[index];\n\t\t\t*dst++ = p;\n\t\t}\n\t}\n\n\treturn out;\n}\n\ntypedef struct cp_v2i_t\n{\n\tint x;\n\tint y;\n} cp_v2i_t;\n\ntypedef struct cp_integer_image_t\n{\n\tint img_index;\n\tcp_v2i_t size;\n\tcp_v2i_t min;\n\tcp_v2i_t max;\n\tint fit;\n} cp_integer_image_t;\n\nstatic cp_v2i_t cp_v2i(int x, int y)\n{\n\tcp_v2i_t v;\n\tv.x = x;\n\tv.y = y;\n\treturn v;\n}\n\nstatic cp_v2i_t cp_sub(cp_v2i_t a, cp_v2i_t b)\n{\n\tcp_v2i_t v;\n\tv.x = a.x - b.x;\n\tv.y = a.y - b.y;\n\treturn v;\n}\n\nstatic cp_v2i_t cp_add(cp_v2i_t a, cp_v2i_t b)\n{\n\tcp_v2i_t v;\n\tv.x = a.x + b.x;\n\tv.y = a.y + b.y;\n\treturn v;\n}\n\ntypedef struct cp_atlas_node_t\n{\n\tcp_v2i_t size;\n\tcp_v2i_t min;\n\tcp_v2i_t max;\n} cp_atlas_node_t;\n\nstatic cp_atlas_node_t* cp_best_fit(int sp, const cp_image_t* png, cp_atlas_node_t* nodes)\n{\n\tint bestVolume = INT_MAX;\n\tcp_atlas_node_t *best_node = 0;\n\tint width = png->w;\n\tint height = png->h;\n\tint png_volume = width * height;\n\n\tfor (int i = 0; i < sp; ++i)\n\t{\n\t\tcp_atlas_node_t *node = nodes + i;\n\t\tint can_contain = node->size.x >= width && node->size.y >= height;\n\t\tif (can_contain)\n\t\t{\n\t\t\tint node_volume = node->size.x * node->size.y;\n\t\t\tif (node_volume == png_volume) return node;\n\t\t\tif (node_volume < bestVolume)\n\t\t\t{\n\t\t\t\tbestVolume = node_volume;\n\t\t\t\tbest_node = node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_node;\n}\n\nstatic int cp_perimeter_pred(cp_integer_image_t* a, cp_integer_image_t* b)\n{\n\tint perimeterA = 2 * (a->size.x + a->size.y);\n\tint perimeterB = 2 * (b->size.x + b->size.y);\n\treturn perimeterB < perimeterA;\n}\n\nvoid cp_premultiply(cp_image_t* img)\n{\n\tint w = img->w;\n\tint h = img->h;\n\tint stride = w * sizeof(cp_pixel_t);\n\tuint8_t* data = (uint8_t*)img->pix;\n\n\tfor(int i = 0; i < (int)stride * h; i += sizeof(cp_pixel_t))\n\t{\n\t\tfloat a = (float)data[i + 3] / 255.0f;\n\t\tfloat r = (float)data[i + 0] / 255.0f;\n\t\tfloat g = (float)data[i + 1] / 255.0f;\n\t\tfloat b = (float)data[i + 2] / 255.0f;\n\t\tr *= a;\n\t\tg *= a;\n\t\tb *= a;\n\t\tdata[i + 0] = (uint8_t)(r * 255.0f);\n\t\tdata[i + 1] = (uint8_t)(g * 255.0f);\n\t\tdata[i + 2] = (uint8_t)(b * 255.0f);\n\t}\n}\n\nstatic void cp_qsort(cp_integer_image_t* items, int count)\n{\n\tif (count <= 1) return;\n\n\tcp_integer_image_t pivot = items[count - 1];\n\tint low = 0;\n\tfor (int i = 0; i < count - 1; ++i)\n\t{\n\t\tif (cp_perimeter_pred(items + i, &pivot))\n\t\t{\n\t\t\tcp_integer_image_t tmp = items[i];\n\t\t\titems[i] = items[low];\n\t\t\titems[low] = tmp;\n\t\t\tlow++;\n\t\t}\n\t}\n\n\titems[count - 1] = items[low];\n\titems[low] = pivot;\n\tcp_qsort(items, low);\n\tcp_qsort(items + low + 1, count - 1 - low);\n}\n\nstatic void cp_write_pixel(char* mem, long color) {\n\tmem[0] = (color >> 24) & 0xFF;\n\tmem[1] = (color >> 16) & 0xFF;\n\tmem[2] = (color >>  8) & 0xFF;\n\tmem[3] = (color >>  0) & 0xFF;\n}\n\ncp_image_t cp_make_atlas(int atlas_width, int atlas_height, const cp_image_t* pngs, int png_count, cp_atlas_image_t* imgs_out)\n{\n\tfloat w0, h0, div, wTol, hTol;\n\tint atlas_image_size, atlas_stride, sp;\n\tvoid* atlas_pixels = 0;\n\tint atlas_node_capacity = png_count * 2;\n\tcp_image_t atlas_image;\n\tcp_integer_image_t* images = 0;\n\tcp_atlas_node_t* nodes = 0;\n\n\tatlas_image.w = atlas_width;\n\tatlas_image.h = atlas_height;\n\tatlas_image.pix = 0;\n\n\tCUTE_PNG_CHECK(pngs, \"pngs array was NULL\");\n\tCUTE_PNG_CHECK(imgs_out, \"imgs_out array was NULL\");\n\n\timages = (cp_integer_image_t*)CUTE_PNG_ALLOCA(sizeof(cp_integer_image_t) * png_count);\n\tnodes = (cp_atlas_node_t*)CUTE_PNG_ALLOC(sizeof(cp_atlas_node_t) * atlas_node_capacity);\n\tCUTE_PNG_CHECK(images, \"out of mem\");\n\tCUTE_PNG_CHECK(nodes, \"out of mem\");\n\n\tfor (int i = 0; i < png_count; ++i)\n\t{\n\t\tconst cp_image_t* png = pngs + i;\n\t\tcp_integer_image_t* image = images + i;\n\t\timage->fit = 0;\n\t\timage->size = cp_v2i(png->w, png->h);\n\t\timage->img_index = i;\n\t}\n\n\t// Sort PNGs from largest to smallest\n\tcp_qsort(images, png_count);\n\n\t// stack pointer, the stack is the nodes array which we will\n\t// allocate nodes from as necessary.\n\tsp = 1;\n\n\tnodes[0].min = cp_v2i(0, 0);\n\tnodes[0].max = cp_v2i(atlas_width, atlas_height);\n\tnodes[0].size = cp_v2i(atlas_width, atlas_height);\n\n\t// Nodes represent empty space in the atlas. Placing a texture into the\n\t// atlas involves splitting a node into two smaller pieces (or, if a\n\t// perfect fit is found, deleting the node).\n\tfor (int i = 0; i < png_count; ++i)\n\t{\n\t\tcp_integer_image_t* image = images + i;\n\t\tconst cp_image_t* png = pngs + image->img_index;\n\t\tint width = png->w;\n\t\tint height = png->h;\n\t\tcp_atlas_node_t *best_fit = cp_best_fit(sp, png, nodes);\n\t\tif (CUTE_PNG_ATLAS_MUST_FIT) CUTE_PNG_CHECK(best_fit, \"Not enough room to place image in atlas.\");\n\t\telse if (!best_fit) \n\t\t{\n\t\t\timage->fit = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\timage->min = best_fit->min;\n\t\timage->max = cp_add(image->min, image->size);\n\n\t\tif (best_fit->size.x == width && best_fit->size.y == height)\n\t\t{\n\t\t\tcp_atlas_node_t* last_node = nodes + --sp;\n\t\t\t*best_fit = *last_node;\n\t\t\timage->fit = 1;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\timage->fit = 1;\n\n\t\tif (sp == atlas_node_capacity)\n\t\t{\n\t\t\tint new_capacity = atlas_node_capacity * 2;\n\t\t\tcp_atlas_node_t* new_nodes = (cp_atlas_node_t*)CUTE_PNG_ALLOC(sizeof(cp_atlas_node_t) * new_capacity);\n\t\t\tCUTE_PNG_CHECK(new_nodes, \"out of mem\");\n\t\t\tCUTE_PNG_MEMCPY(new_nodes, nodes, sizeof(cp_atlas_node_t) * sp);\n\t\t\tCUTE_PNG_FREE(nodes);\n\t\t\t// best_fit became a dangling pointer, so relocate it\n\t\t\tbest_fit = new_nodes + (best_fit - nodes);\n\t\t\tnodes = new_nodes;\n\t\t\tatlas_node_capacity = new_capacity;\n\t\t}\n\n\t\tcp_atlas_node_t* new_node = nodes + sp++;\n\t\tnew_node->min = best_fit->min;\n\n\t\t// Split bestFit along x or y, whichever minimizes\n\t\t// fragmentation of empty space\n\t\tcp_v2i_t d = cp_sub(best_fit->size, cp_v2i(width, height));\n\t\tif (d.x < d.y)\n\t\t{\n\t\t\tnew_node->size.x = d.x;\n\t\t\tnew_node->size.y = height;\n\t\t\tnew_node->min.x += width;\n\n\t\t\tbest_fit->size.y = d.y;\n\t\t\tbest_fit->min.y += height;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tnew_node->size.x = width;\n\t\t\tnew_node->size.y = d.y;\n\t\t\tnew_node->min.y += height;\n\n\t\t\tbest_fit->size.x = d.x;\n\t\t\tbest_fit->min.x += width;\n\t\t}\n\n\t\tnew_node->max = cp_add(new_node->min, new_node->size);\n\t}\n\n\t// Write the final atlas image, use CUTE_PNG_ATLAS_EMPTY_COLOR as base color\n\tatlas_stride = atlas_width * sizeof(cp_pixel_t);\n\tatlas_image_size = atlas_width * atlas_height * sizeof(cp_pixel_t);\n\tatlas_pixels = CUTE_PNG_ALLOC(atlas_image_size);\n\tCUTE_PNG_CHECK(atlas_pixels, \"out of mem\");\n\t\n\tfor(int i = 0; i < atlas_image_size; i += sizeof(cp_pixel_t)) {\n\t\tcp_write_pixel((char*)atlas_pixels + i, CUTE_PNG_ATLAS_EMPTY_COLOR);\n\t}\n\n\tfor (int i = 0; i < png_count; ++i)\n\t{\n\t\tcp_integer_image_t* image = images + i;\n\n\t\tif (image->fit)\n\t\t{\n\t\t\tconst cp_image_t* png = pngs + image->img_index;\n\t\t\tchar* pixels = (char*)png->pix;\n\t\t\tcp_v2i_t min = image->min;\n\t\t\tcp_v2i_t max = image->max;\n\t\t\tint atlas_offset = min.x * sizeof(cp_pixel_t);\n\t\t\tint tex_stride = png->w * sizeof(cp_pixel_t);\n\n\t\t\tfor (int row = min.y, y = 0; row < max.y; ++row, ++y)\n\t\t\t{\n\t\t\t\tvoid* row_ptr = (char*)atlas_pixels + (row * atlas_stride + atlas_offset);\n\t\t\t\tCUTE_PNG_MEMCPY(row_ptr, pixels + y * tex_stride, tex_stride);\n\t\t\t}\n\t\t}\n\t}\n\n\tatlas_image.pix = (cp_pixel_t*)atlas_pixels;\n\n\t// squeeze UVs inward by 128th of a pixel\n\t// this prevents atlas bleeding. tune as necessary for good results.\n\tw0 = 1.0f / (float)(atlas_width);\n\th0 = 1.0f / (float)(atlas_height);\n\tdiv = 1.0f / 128.0f;\n\twTol = w0 * div;\n\thTol = h0 * div;\n\n\tfor (int i = 0; i < png_count; ++i)\n\t{\n\t\tcp_integer_image_t* image = images + i;\n\t\tcp_atlas_image_t* img_out = imgs_out + i;\n\n\t\timg_out->img_index = image->img_index;\n\t\timg_out->w = image->size.x;\n\t\timg_out->h = image->size.y;\n\t\timg_out->fit = image->fit;\n\n\t\tif (image->fit)\n\t\t{\n\t\t\tcp_v2i_t min = image->min;\n\t\t\tcp_v2i_t max = image->max;\n\n\t\t\tfloat min_x = (float)min.x * w0 + wTol;\n\t\t\tfloat min_y = (float)min.y * h0 + hTol;\n\t\t\tfloat max_x = (float)max.x * w0 - wTol;\n\t\t\tfloat max_y = (float)max.y * h0 - hTol;\n\n\t\t\t// flip image on y axis\n\t\t\tif (CUTE_PNG_ATLAS_FLIP_Y_AXIS_FOR_UV)\n\t\t\t{\n\t\t\t\tfloat tmp = min_y;\n\t\t\t\tmin_y = max_y;\n\t\t\t\tmax_y = tmp;\n\t\t\t}\n\n\t\t\timg_out->minx = min_x;\n\t\t\timg_out->miny = min_y;\n\t\t\timg_out->maxx = max_x;\n\t\t\timg_out->maxy = max_y;\n\t\t}\n\t}\n\n\tCUTE_PNG_FREE(nodes);\n\treturn atlas_image;\n\ncp_err:\n\tCUTE_PNG_FREE(atlas_pixels);\n\tCUTE_PNG_FREE(nodes);\n\tatlas_image.pix = 0;\n\treturn atlas_image;\n}\n\nint cp_default_save_atlas(const char* out_path_image, const char* out_path_atlas_txt, const cp_image_t* atlas, const cp_atlas_image_t* imgs, int img_count, const char** names)\n{\n\tCUTE_PNG_FILE* fp = CUTE_PNG_FOPEN(out_path_atlas_txt, \"wt\");\n\tCUTE_PNG_CHECK(fp, \"unable to open out_path_atlas_txt in cp_default_save_atlas\");\n\n\tCUTE_PNG_FPRINTF(fp, \"%s\\n%d\\n\\n\", out_path_image, img_count);\n\n\tfor (int i = 0; i < img_count; ++i)\n\t{\n\t\tconst cp_atlas_image_t* image = imgs + i;\n\t\tconst char* name = names ? names[image->img_index] : 0;\n\n\t\tif (image->fit)\n\t\t{\n\t\t\tint width = image->w;\n\t\t\tint height = image->h;\n\t\t\tfloat min_x = image->minx;\n\t\t\tfloat min_y = image->miny;\n\t\t\tfloat max_x = image->maxx;\n\t\t\tfloat max_y = image->maxy;\n\n\t\t\tif (name) CUTE_PNG_FPRINTF(fp, \"{ \\\"%s\\\", w = %d, h = %d, u = { %.10f, %.10f }, v = { %.10f, %.10f } }\\n\", name, width, height, min_x, min_y, max_x, max_y);\n\t\t\telse CUTE_PNG_FPRINTF(fp, \"{ w = %d, h = %d, u = { %.10f, %.10f }, v = { %.10f, %.10f } }\\n\", width, height, min_x, min_y, max_x, max_y);\n\t\t}\n\t}\n\n\t// Save atlas image PNG to disk\n\tCUTE_PNG_CHECK(cp_save_png(out_path_image, atlas), \"failed to save atlas image to disk\");\n\ncp_err:\n\tCUTE_PNG_FCLOSE(fp);\n\treturn 0;\n}\n\n#endif // CUTE_PNG_IMPLEMENTATION_ONCE\n#endif // CUTE_PNG_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2019 Randy Gaul http://www.randygaul.net\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \n\tsoftware, either in source code form or as a compiled binary, for any purpose, \n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this \n\tsoftware dedicate any and all copyright interest in the software to the public \n\tdomain. We make this dedication for the benefit of the public at large and to \n\tthe detriment of our heirs and successors. We intend this dedication to be an \n\tovert act of relinquishment in perpetuity of all present and future rights to \n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_sound.h",
          "type": "blob",
          "size": 112.6962890625,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_sound.h - v2.08\n\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_SOUND_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY\n\n\t\tcute_sound is a C API for loading, playing, looping, panning and fading mono\n\t\tand stereo sounds, without any external dependencies other than things that ship\n\t\twith standard OSs, or SDL2 for more uncommon OSs.\n\n\t\tWhile platform detection is done automatically, you are able to explicitly\n\t\tspecify which to use by defining one of the following:\n\n\t\t\t#define CUTE_SOUND_PLATFORM_WINDOWS\n\t\t\t#define CUTE_SOUND_PLATFORM_APPLE\n\t\t\t#define CUTE_SOUND_PLATFORM_SDL\n\n\t\tFor Windows cute_sound uses DirectSound. Due to the use of SSE intrinsics, MinGW\n\t\tbuilds must be made with the compiler option: -march=native, or optionally SSE\n\t\tcan be disabled with CUTE_SOUND_SCALAR_MODE. More on this mode written below.\n\n\t\tFor Apple machines cute_sound uses CoreAudio.\n\n\t\tFor Linux builds cute_sound uses SDL2.\n\n\t\tAn SDL2 implementation of cute_sound is available on platforms SDL2 is available,\n\t\twhich is pretty much everywhere. To use the SDL2 implementation of cute_sound\n\t\tdefine CUTE_SOUND_FORCE_SDL before placing the CUTE_SOUND_IMPLEMENTATION into a\n\t\ttranslation unit in order to force the use of SDL. Here is an example:\n\n\t\t\t#define CUTE_SOUND_FORCE_SDL\n\t\t\t#define CUTE_SOUND_IMPLEMENTATION\n\t\t\t#include <cute_sound.h>\n\n\t\tIf you want to use cute_sound with SDL_RWops, you must enable it by putting this\n\t\tbefore you #include cute_sound.h:\n\n\t\t\t#define CUTE_SOUND_SDL_RWOPS\n\n\n\tREVISION HISTORY\n\n\t\t1.0  (06/04/2016) Initial release.\n\t\t1.01 (06/06/2016) Load WAV from memory.\n\t\t                * Separate portable and OS-specific code in cs_mix.\n\t\t                * Fixed bug causing audio glitches when sounds ended.\n\t\t                * Added stb_vorbis loaders + demo example.\n\t\t1.02 (06/08/2016) error checking + strings in vorbis loaders\n\t\t                * SSE2 implementation of mixer.\n\t\t                * Fix typos on docs/comments.\n\t\t                * Corrected volume bug introduced in 1.01.\n\t\t1.03 (07/05/2016) size calculation helper (to know size of sound in\n\t\t                  bytes on the heap) cs_sound_size\n\t\t1.04 (12/06/2016) Merged in Aaron Balint's contributions.\n\t\t                * SFFT and pitch functions from Stephan M. Bernsee\n\t\t                * cs_mix can run on its own thread with cs_spawn_mix_thread\n\t\t                * Updated documentation, typo fixes.\n\t\t                * Fixed typo in cs_malloc16 that caused heap corruption.\n\t\t1.05 (12/08/2016) cs_stop_all_sounds, suggested by Aaron Balint\n\t\t1.06 (02/17/2017) Port to CoreAudio for Apple machines.\n\t\t1.07 (06/18/2017) SIMD the pitch shift code; swapped out old Bernsee\n\t\t                  code for a new re-write, updated docs as necessary,\n\t\t                  support for compiling as .c and .cpp on Windows,\n\t\t                  port for SDL (for Linux, or any other platform).\n\t\t                * Special thanks to DeXP (Dmitry Hrabrov) for 90% of\n\t\t                  the work on the SDL port!\n\t\t1.08 (09/06/2017) SDL_RWops support by RobLoach\n\t\t1.09 (05/20/2018) Load wav funcs can skip all irrelevant chunks\n\t\t                  Ref counting for playing sounds\n\t\t1.10 (08/24/2019) Introduced plugin interface, reimplemented pitch shifting\n\t\t                  as a plugin, added optional `ctx` to alloc functions\n\t\t1.11 (04/23/2020) scalar SIMD mode and various compiler warning/error fixes\n\t\t1.12 (10/20/2021) removed old and broken assert if driver requested non-\n\t\t                  power of two sample size for mixing updates\n\t\t2.00 (05/21/2022) redesigned the entire API for v2.00, music support, broke\n\t\t                  the pitch/plugin interface (to be fixed), CoreAudio is not\n\t\t                  yet tested, but the SDL2 implementation is well tested,\n\t\t                * ALSA support is dropped entirely\n\t\t2.01 (11/02/2022) Compilation fixes for clang/llvm, added #include <stddef.h>\n\t\t                  to have size_t defined. Correctly finalize the thread when\n\t\t                  cs_shutdown is called for all platforms that spawned it\n\t\t                  (this fixes segmentation fault on cs_shutdown).\n\t\t2.02 (11/10/2022) Removed plugin API -- It was clunky and just not worth the\n\t\t                  maintenence effort. If you're reading this Matt, I haven't\n\t\t                  forgotten all the cool work you did! And will use it in the\n\t\t                  future for sure :) -- Unfortunately this removes pitch.\n\t\t                * Fixed a bug where dsound mixing could run too fast.\n\t\t2.03 (11/12/2022) Added internal queue for freeing audio sources to avoid the\n\t\t                  need for refcount polling.\n\t\t2.04 (02/04/2024) Added `cs_cull_duplicates` helper for removing extra plays\n\t\t                  to the same sound on the exact same update tick.\n\t\t2.05 (03/27/2023) Added cs_get_global_context and friends, and extra accessors\n\t\t                  for panning and similar.\n\t\t2.06 (06/23/2024) Looping sounds play seamlessly.\n\t\t2.07 (06/23/2024) Added pitch shifting support, removed delay support.\n\t\t2.08 (08/07/2024) Added sample_index to sound params, removed unnecessary asserts\n\t\t                  for stopping music, added callbacks sounds/music ending\n\n\n\tCONTRIBUTORS\n\n\t\tAaron Balint      1.04 - real time pitch\n\t\t                  1.04 - separate thread for cs_mix\n\t\t                  1.04 - bugfix, removed extra cs_free16 call for second channel\n\t\tDeXP              1.07 - initial work on SDL port\n\t\tRobLoach          1.08 - SDL_RWops support\n\t\tMatt Rosen        1.10 - Initial experiments with cute_dsp to figure out plugin\n\t\t                         interface needs and use-cases\n\t\tfluffrabbit       1.11 - scalar SIMD mode and various compiler warning/error fixes\n\t\tDaniel Guzman     2.01 - compilation fixes for clang/llvm on MAC. \n\t\tBrie              2.06 - Looping sound rollover\n\t\togam              x.xx - Lots of bugfixes over time, including support negative pitch\n\t\trenex             x.xx - Fixes to popping issues and a crash in the mixer.\n\n\n\tDOCUMENTATION (very quick intro)\n\n\t\tSteps to play audio:\n\n\t\t\t1. create context (call cs_init)\n\t\t\t2. load sounds from disk into memory (call cs_load_wav, or cs_load_ogg with stb_vorbis.c)\n\t\t\t3. play sounds (cs_play_sound), or music (cs_music_play)\n\n\tDISABLE SSE SIMD ACCELERATION\n\n\t\tIf for whatever reason you don't want to use SSE intrinsics and instead would prefer\n\t\tplain C (for example if your platform does not support SSE) then define\n\t\tCUTE_SOUND_SCALAR_MODE before including cute_sound.h while also defining the\n\t\tsymbol definitions. Here's an example:\n\n\t\t\t#define CUTE_SOUND_IMPLEMENTATION\n\t\t\t#define CUTE_SOUND_SCALAR_MODE\n\t\t\t#include <cute_sound.h>\n\t\n\tCUSTOMIZATION\n\n\t\tA few different macros can be overriden to provide custom functionality. Simply define any of these\n\t\tmacros before including this file to override them.\n\n\t\t\tCUTE_SOUND_MINIMUM_BUFFERED_SAMPLES\n\t\t\tCUTE_SOUND_ASSERT\n\t\t\tCUTE_SOUND_ALLOC\n\t\t\tCUTE_SOUND_FREE\n\t\t\tCUTE_SOUND_MEMCPY\n\t\t\tCUTE_SOUND_MEMSET\n\t\t\tCUTE_SOUND_MEMCMP\n\t\t\tCUTE_SOUND_SEEK_SET\n\t\t\tCUTE_SOUND_SEEK_END\n\t\t\tCUTE_SOUND_FILE\n\t\t\tCUTE_SOUND_FOPEN\n\t\t\tCUTE_SOUND_FSEEK\n\t\t\tCUTE_SOUND_FREAD\n\t\t\tCUTE_SOUND_FTELL\n\t\t\tCUTE_SOUND_FCLOSE\n\n\n\tKNOWN LIMITATIONS\n\n\t\t* PCM mono/stereo format is the only formats the LoadWAV function supports. I don't\n\t\t  guarantee it will work for all kinds of wav files, but it certainly does for the common\n\t\t  kind (and can be changed fairly easily if someone wanted to extend it).\n\t\t* Only supports 16 bits per sample.\n\t\t* Mixer does not do any fancy clipping. The algorithm is to convert all 16 bit samples\n\t\t  to float, mix all samples, and write back to audio API as 16 bit integers. In\n\t\t  practice this works very well and clipping is not often a big problem.\n\n\n\tFAQ\n\n\t\tQ : I would like to use my own memory management, how can I achieve this?\n\t\tA : This header makes a couple uses of malloc/free, and cs_malloc16/cs_free16. Simply find these bits\n\t\t    and replace them with your own memory allocation routines. They can be wrapped up into a macro,\n\t\t    or call your own functions directly -- it's up to you. Generally these functions allocate fairly\n\t\t    large chunks of memory, and not very often (if at all).\n\n\t\tQ : Does this library support audio streaming? Something like System::createStream in FMOD.\n\t\tA : No. Typically music files aren't that large (in the megabytes). Compare this to a typical\n\t\t    DXT texture of 1024x1024, at 0.5MB of memory. Now say an average music file for a game is three\n\t\t    minutes long. Loading this file into memory and storing it as raw 16bit samples with two channels,\n\t\t    would be:\n\n\t\t        num_samples = 3 * 60 * 44100 * 2\n\t\t        num_bits = num_samples * 16\n\t\t        num_bytes = num_bits / 8\n\t\t        num_megabytes = num_bytes / (1024 * 1024)\n\t\t        or 30.3mb\n\n\t\t    So say the user has 2gb of spare RAM. That means we could fit 67 different three minute length\n\t\t    music files in there simultaneously. That is a ridiculous amount of spare memory. 30mb is nothing\n\t\t    nowadays. Just load your music file into memory all at once and then play it.\n\n\t\tQ : But I really need streaming of audio files from disk to save memory! Also loading my audio\n\t\t    files (like .OGG) takes a long time (multiple seconds).\n\t\tA : It is recommended to either A) load up your music files before they are needed, perhaps during\n\t\t    a loading screen, or B) stream in the entire audio into memory on another thread. cs_read_mem_ogg is\n\t\t    a great candidate function to throw onto a job pool. Streaming is more a remnant of older machines\n\t\t    (like in the 90's or early 2000's) where decoding speed and RAM were real nasty bottlenecks. For\n\t\t    more modern machines, these aren't really concerns, even with mobile devices. If even after reading\n\t\t    this Q/A section you still want to stream your audio, you can try mini_al as an alternative:\n\t\t    https://github.com/dr-soft/mini_al\n*/\n\n#if !defined(CUTE_SOUND_H)\n\n#if defined(_WIN32)\n\t#if !defined _CRT_SECURE_NO_WARNINGS\n\t\t#define _CRT_SECURE_NO_WARNINGS\n\t#endif\n\t#if !defined _CRT_NONSTDC_NO_DEPRECATE\n\t\t#define _CRT_NONSTDC_NO_DEPRECATE\n\t#endif\n#endif\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n// -------------------------------------------------------------------------------------------------\n// Error handling.\n\ntypedef enum cs_error_t\n{\n\tCUTE_SOUND_ERROR_NONE,\n\tCUTE_SOUND_ERROR_IMPLEMENTATION_ERROR_PLEASE_REPORT_THIS_ON_GITHUB, // https://github.com/RandyGaul/cute_headers/issues\n\tCUTE_SOUND_ERROR_FILE_NOT_FOUND,\n\tCUTE_SOUND_ERROR_INVALID_SOUND,\n\tCUTE_SOUND_ERROR_HWND_IS_NULL,\n\tCUTE_SOUND_ERROR_DIRECTSOUND_CREATE_FAILED,\n\tCUTE_SOUND_ERROR_CREATESOUNDBUFFER_FAILED,\n\tCUTE_SOUND_ERROR_SETFORMAT_FAILED,\n\tCUTE_SOUND_ERROR_AUDIOCOMPONENTFINDNEXT_FAILED,\n\tCUTE_SOUND_ERROR_AUDIOCOMPONENTINSTANCENEW_FAILED,\n\tCUTE_SOUND_ERROR_FAILED_TO_SET_STREAM_FORMAT,\n\tCUTE_SOUND_ERROR_FAILED_TO_SET_RENDER_CALLBACK,\n\tCUTE_SOUND_ERROR_AUDIOUNITINITIALIZE_FAILED,\n\tCUTE_SOUND_ERROR_AUDIOUNITSTART_FAILED,\n\tCUTE_SOUND_ERROR_CANT_OPEN_AUDIO_DEVICE,\n\tCUTE_SOUND_ERROR_CANT_INIT_SDL_AUDIO,\n\tCUTE_SOUND_ERROR_THE_FILE_IS_NOT_A_WAV_FILE,\n\tCUTE_SOUND_ERROR_WAV_FILE_FORMAT_CHUNK_NOT_FOUND,\n\tCUTE_SOUND_ERROR_WAV_DATA_CHUNK_NOT_FOUND,\n\tCUTE_SOUND_ERROR_ONLY_PCM_WAV_FILES_ARE_SUPPORTED,\n\tCUTE_SOUND_ERROR_WAV_ONLY_MONO_OR_STEREO_IS_SUPPORTED,\n\tCUTE_SOUND_ERROR_WAV_ONLY_16_BITS_PER_SAMPLE_SUPPORTED,\n\tCUTE_SOUND_ERROR_CANNOT_SWITCH_MUSIC_WHILE_PAUSED,\n\tCUTE_SOUND_ERROR_CANNOT_CROSSFADE_WHILE_MUSIC_IS_PAUSED,\n\tCUTE_SOUND_ERROR_CANNOT_FADEOUT_WHILE_MUSIC_IS_PAUSED,\n\tCUTE_SOUND_ERROR_TRIED_TO_SET_SAMPLE_INDEX_BEYOND_THE_AUDIO_SOURCES_SAMPLE_COUNT,\n\tCUTE_SOUND_ERROR_STB_VORBIS_DECODE_FAILED,\n\tCUTE_SOUND_ERROR_OGG_UNSUPPORTED_CHANNEL_COUNT,\n} cs_error_t;\n\nconst char* cs_error_as_string(cs_error_t error);\n\n// -------------------------------------------------------------------------------------------------\n// Cute sound context functions.\n\n/**\n * Pass in NULL for `os_handle`, except for the DirectSound backend this should be hwnd.\n * play_frequency_in_Hz depends on your audio file, 44100 seems to be fine.\n * buffered_samples is clamped to be at least 1024.\n */\ncs_error_t cs_init(void* os_handle, unsigned play_frequency_in_Hz, int buffered_samples, void* user_allocator_context /* = NULL */);\nvoid cs_shutdown();\n\n/**\n * Call this function once per game-tick.\n */\nvoid cs_update(float dt);\nvoid cs_set_global_volume(float volume_0_to_1);\nvoid cs_set_global_pan(float pan_0_to_1);\nvoid cs_set_global_pause(bool true_for_paused);\n\n/**\n * Spawns a mixing thread dedicated to mixing audio in the background.\n * If you don't call this function mixing will happen on the main-thread when you call `cs_update`.\n */\nvoid cs_spawn_mix_thread();\n\n/**\n * In cases where the mixing thread takes up extra CPU attention doing nothing, you can force\n * it to sleep manually. You can tune this as necessary, but it's probably not necessary for you.\n */\nvoid cs_mix_thread_sleep_delay(int milliseconds);\n\n/**\n * Sometimes useful for dynamic library shenanigans.\n */\nvoid* cs_get_context_ptr();\nvoid cs_set_context_ptr(void* ctx);\n\n// -------------------------------------------------------------------------------------------------\n// Loaded sounds.\n\ntypedef struct cs_audio_source_t cs_audio_source_t;\n\ncs_audio_source_t* cs_load_wav(const char* path, cs_error_t* err /* = NULL */);\ncs_audio_source_t* cs_read_mem_wav(const void* memory, size_t size, cs_error_t* err /* = NULL */);\nvoid cs_free_audio_source(cs_audio_source_t* audio);\n\n// If stb_vorbis was included *before* cute_sound go ahead and create\n// some functions for dealing with OGG files.\n#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n\tcs_audio_source_t* cs_load_ogg(const char* path, cs_error_t* err /* = NULL */);\n\tcs_audio_source_t* cs_read_mem_ogg(const void* memory, size_t size, cs_error_t* err /* = NULL */);\n\n#endif\n\n// SDL_RWops specific functions\n#if defined(SDL_rwops_h_) && defined(CUTE_SOUND_SDL_RWOPS)\n\n\t// Provides the ability to use cs_load_wav with an SDL_RWops object.\n\tcs_audio_source_t* cs_load_wav_rw(SDL_RWops* context, cs_error_t* err /* = NULL */);\n\n\t#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n\t\t// Provides the ability to use cs_load_ogg with an SDL_RWops object.\n\t\tcs_audio_source_t* cs_load_ogg_rw(SDL_RWops* rw, cs_error_t* err /* = NULL */);\n\n\t#endif\n\n#endif // SDL_rwops_h_\n\n// -------------------------------------------------------------------------------------------------\n// Audio source accessors.\n\nint cs_get_sample_rate(const cs_audio_source_t* audio);\nint cs_get_sample_count(const cs_audio_source_t* audio);\nint cs_get_channel_count(const cs_audio_source_t* audio);\n\n// -------------------------------------------------------------------------------------------------\n// Music sounds.\n\nvoid cs_music_play(cs_audio_source_t* audio, float fade_in_time /* = 0 */);\nvoid cs_music_stop(float fade_out_time /* = 0 */);\nvoid cs_music_pause();\nvoid cs_music_resume();\nvoid cs_music_set_volume(float volume_0_to_1);\nvoid cs_music_set_pitch(float pitch /* = 1.0f */);\nvoid cs_music_set_loop(bool true_to_loop);\nvoid cs_music_switch_to(cs_audio_source_t* audio, float fade_out_time /* = 0 */, float fade_in_time /* = 0 */);\nvoid cs_music_crossfade(cs_audio_source_t* audio, float cross_fade_time /* = 0 */);\nint cs_music_get_sample_index();\ncs_error_t cs_music_set_sample_index(int sample_index);\n\n// -------------------------------------------------------------------------------------------------\n// Playing sounds.\n\ntypedef struct cs_playing_sound_t { uint64_t id; } cs_playing_sound_t;\n#define CUTE_PLAYING_SOUND_INVALID (cs_playing_sound_t){ 0 }\n\ntypedef struct cs_sound_params_t\n{\n\tbool paused  /* = false */;\n\tbool looped  /* = false */;\n\tfloat volume /* = 1.0f */;\n\tfloat pan    /* = 0.5f */; // Can be from 0 to 1.\n\tfloat pitch  /* = 1.0f */;\n\tint sample_index /* = 0 */;\n} cs_sound_params_t;\n\ncs_sound_params_t cs_sound_params_default();\n\ncs_playing_sound_t cs_play_sound(cs_audio_source_t* audio, cs_sound_params_t params);\n\n/**\n * Setup a callback for whenever a sound finishes playing. This will get called from the\n * mixer thread, which means you'll need to deal with a multithreaded callback if you've\n * spawned a separate mixing thread.\n */\nvoid cs_on_sound_finished_callback(void (*on_finish)(cs_playing_sound_t, void*), void* udata);\n\n/**\n * Setup a callback for whenever the current song finishes playing. This will get called from the\n * mixer thread, which means you'll need to deal with a multithreaded callback if you've\n * spawned a separate mixing thread.\n */\nvoid cs_on_music_finished_callback(void (*on_finish)(void*), void* udata);\n\nbool cs_sound_is_active(cs_playing_sound_t sound);\nbool cs_sound_get_is_paused(cs_playing_sound_t sound);\nbool cs_sound_get_is_looped(cs_playing_sound_t sound);\nfloat cs_sound_get_volume(cs_playing_sound_t sound);\nfloat cs_sound_get_pitch(cs_playing_sound_t sound);\nfloat cs_sound_get_pan(cs_playing_sound_t sound);\nint cs_sound_get_sample_index(cs_playing_sound_t sound);\nvoid cs_sound_set_is_paused(cs_playing_sound_t sound, bool true_for_paused);\nvoid cs_sound_set_is_looped(cs_playing_sound_t sound, bool true_for_looped);\nvoid cs_sound_set_volume(cs_playing_sound_t sound, float volume_0_to_1);\nvoid cs_sound_set_pan(cs_playing_sound_t sound, float pan_0_to_1);\nvoid cs_sound_set_pitch(cs_playing_sound_t sound, float pitch);\ncs_error_t cs_sound_set_sample_index(cs_playing_sound_t sound, int sample_index);\nvoid cs_sound_stop(cs_playing_sound_t sound);\n\nvoid cs_set_playing_sounds_volume(float volume_0_to_1);\nvoid cs_stop_all_playing_sounds();\n\n/**\n * Off by default. When enabled only one instance of audio can be created per audio update-tick. This\n * does *not* take into account the starting sample index, so disable this feature if you want to spawn\n * audio with dynamic sample indices, such as when syncing programmatically generated scores/sequences.\n * This also does not take into account pitch differences.\n */\nvoid cs_cull_duplicates(bool true_to_enable);\n\n// -------------------------------------------------------------------------------------------------\n// Global context.\n\nvoid* cs_get_global_context();\nvoid cs_set_global_context(void* context);\n\nvoid* cs_get_global_user_allocator_context();\nvoid cs_set_global_user_allocator_context(void* user_allocator_context);\n\n#define CUTE_SOUND_H\n#endif\n\n#ifdef CUTE_SOUND_IMPLEMENTATION\n#ifndef CUTE_SOUND_IMPLEMENTATION_ONCE\n#define CUTE_SOUND_IMPLEMENTATION_ONCE\n\n#ifndef CUTE_SOUND_MINIMUM_BUFFERED_SAMPLES\n#\tdefine CUTE_SOUND_MINIMUM_BUFFERED_SAMPLES 1024\n#endif\n\n#if !defined(CUTE_SOUND_ASSERT)\n#\tinclude <assert.h>\n#\tdefine CUTE_SOUND_ASSERT assert\n#endif\n\n#if !defined(CUTE_SOUND_ALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_SOUND_ALLOC(size, ctx) malloc(size)\n#endif\n\n#if !defined(CUTE_SOUND_FREE)\n\t#include <stdlib.h>\n\t#define CUTE_SOUND_FREE(mem, ctx) free(mem)\n#endif\n\n#ifndef CUTE_SOUND_MEMCPY\n#\tinclude <string.h>\n#\tdefine CUTE_SOUND_MEMCPY memcpy\n#endif\n\n#ifndef CUTE_SOUND_MEMSET\n#\tinclude <string.h>\n#\tdefine CUTE_SOUND_MEMSET memset\n#endif\n\n#ifndef CUTE_SOUND_MEMCMP\n#\tinclude <string.h>\n#\tdefine CUTE_SOUND_MEMCMP memcmp\n#endif\n\n#ifndef CUTE_SOUND_SEEK_SET\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_SEEK_SET SEEK_SET\n#endif\n\n#ifndef CUTE_SOUND_SEEK_END\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_SEEK_END SEEK_END\n#endif\n\n#ifndef CUTE_SOUND_FILE\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FILE FILE\n#endif\n\n#ifndef CUTE_SOUND_FOPEN\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FOPEN fopen\n#endif\n\n#ifndef CUTE_SOUND_FSEEK\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FSEEK fseek\n#endif\n\n#ifndef CUTE_SOUND_FREAD\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FREAD fread\n#endif\n\n#ifndef CUTE_SOUND_FTELL\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FTELL ftell\n#endif\n\n#ifndef CUTE_SOUND_FCLOSE\n#\tinclude <stdio.h>\n#\tdefine CUTE_SOUND_FCLOSE fclose\n#endif\n\n// Platform detection.\n#define CUTE_SOUND_WINDOWS 1\n#define CUTE_SOUND_APPLE   2\n#define CUTE_SOUND_SDL     3\n\n// Use CUTE_SOUND_FORCE_SDL as a way to force CUTE_SOUND_PLATFORM_SDL.\n#ifdef CUTE_SOUND_FORCE_SDL\n\t#define CUTE_SOUND_PLATFORM_SDL\n#endif\n\n#ifndef CUTE_SOUND_PLATFORM\n\t// Check the specific platform defines.\n\t#ifdef CUTE_SOUND_PLATFORM_WINDOWS\n\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_WINDOWS\n\t#elif defined(CUTE_SOUND_PLATFORM_APPLE)\n\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_APPLE\n\t#elif defined(CUTE_SOUND_PLATFORM_SDL)\n\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_SDL\n\t#else\n\t\t// Detect the platform automatically.\n\t\t#if defined(_WIN32)\n\t\t\t#if !defined _CRT_SECURE_NO_WARNINGS\n\t\t\t\t#define _CRT_SECURE_NO_WARNINGS\n\t\t\t#endif\n\t\t\t#if !defined _CRT_NONSTDC_NO_DEPRECATE\n\t\t\t\t#define _CRT_NONSTDC_NO_DEPRECATE\n\t\t\t#endif\n\t\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_WINDOWS\n\t\t#elif defined(__APPLE__)\n\t\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_APPLE\n\t\t#else\n\t\t\t// Just use SDL on other esoteric platforms.\n\t\t\t#define CUTE_SOUND_PLATFORM CUTE_SOUND_SDL\n\t\t#endif\n\t#endif\n#endif\n\n// Platform specific file inclusions.\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\n\t#ifndef _WINDOWS_\n\t\t#ifndef WIN32_LEAN_AND_MEAN\n\t\t\t#define WIN32_LEAN_AND_MEAN\n\t\t#endif\n\t\t#include <windows.h>\n\t#endif\n\n\t#ifndef _WAVEFORMATEX_\n\t\t#include <mmreg.h>\n\t\t#include <mmsystem.h>\n\t#endif\n\n\t#include <dsound.h>\n\t#undef PlaySound\n\n\t#ifdef _MSC_VER\n\t\t#pragma comment(lib, \"dsound.lib\")\n\t#endif\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\t#include <CoreAudio/CoreAudio.h>\n\t#include <AudioUnit/AudioUnit.h>\n\t#include <pthread.h>\n\t#include <mach/mach_time.h>\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\t\n\t#ifndef SDL_h_\n\t\t// Define CUTE_SOUND_SDL_H to allow changing the SDL.h path.\n\t\t#ifndef CUTE_SOUND_SDL_H\n\t\t\t#define CUTE_SOUND_SDL_H <SDL.h>\n\t\t#endif\n\t\t#include CUTE_SOUND_SDL_H\n\t#endif\n\t#ifndef _WIN32\n\t\t#include <alloca.h>\n\t#endif\n\n#else\n\n\t#error Unsupported platform - please choose one of CUTE_SOUND_WINDOWS, CUTE_SOUND_APPLE, CUTE_SOUND_SDL.\n\n#endif\n\n#ifdef CUTE_SOUND_SCALAR_MODE\n\n\t#include <limits.h>\n\n\t#define CUTE_SOUND_SATURATE16(X) (int16_t)((X) > SHRT_MAX ? SHRT_MAX : ((X) < SHRT_MIN ? SHRT_MIN : (X)))\n\n\ttypedef struct cs__m128\n\t{\n\t\tfloat a, b, c, d;\n\t} cs__m128;\n\n\ttypedef struct cs__m128i\n\t{\n\t\tint32_t a, b, c, d;\n\t} cs__m128i;\n\n\tcs__m128 cs_mm_set_ps(float e3, float e2, float e1, float e0)\n\t{\n\t\tcs__m128 a;\n\t\ta.a = e0;\n\t\ta.b = e1;\n\t\ta.c = e2;\n\t\ta.d = e3;\n\t\treturn a;\n\t}\n\n\tcs__m128 cs_mm_set1_ps(float e)\n\t{\n\t\tcs__m128 a;\n\t\ta.a = e;\n\t\ta.b = e;\n\t\ta.c = e;\n\t\ta.d = e;\n\t\treturn a;\n\t}\n\n\tcs__m128 cs_mm_load_ps(float const* mem_addr)\n\t{\n\t\tcs__m128 a;\n\t\ta.a = mem_addr[0];\n\t\ta.b = mem_addr[1];\n\t\ta.c = mem_addr[2];\n\t\ta.d = mem_addr[3];\n\t\treturn a;\n\t}\n\n\tcs__m128 cs_mm_add_ps(cs__m128 a, cs__m128 b)\n\t{\n\t\tcs__m128 c;\n\t\tc.a = a.a + b.a;\n\t\tc.b = a.b + b.b;\n\t\tc.c = a.c + b.c;\n\t\tc.d = a.d + b.d;\n\t\treturn c;\n\t}\n\n\tcs__m128 cs_mm_sub_ps(cs__m128 a, cs__m128 b)\n\t{\n\t\tcs__m128 c;\n\t\tc.a = a.a - b.a;\n\t\tc.b = a.b - b.b;\n\t\tc.c = a.c - b.c;\n\t\tc.d = a.d - b.d;\n\t\treturn c;\n\t}\n\n\tcs__m128 cs_mm_mul_ps(cs__m128 a, cs__m128 b)\n\t{\n\t\tcs__m128 c;\n\t\tc.a = a.a * b.a;\n\t\tc.b = a.b * b.b;\n\t\tc.c = a.c * b.c;\n\t\tc.d = a.d * b.d;\n\t\treturn c;\n\t}\n\n\tcs__m128i cs_mm_cvtps_epi32(cs__m128 a)\n\t{\n\t\tcs__m128i b;\n\t\tb.a = (int32_t)a.a;\n\t\tb.b = (int32_t)a.b;\n\t\tb.c = (int32_t)a.c;\n\t\tb.d = (int32_t)a.d;\n\t\treturn b;\n\t}\n\n\tcs__m128i cs_mm_unpacklo_epi32(cs__m128i a, cs__m128i b)\n\t{\n\t\tcs__m128i c;\n\t\tc.a = a.a;\n\t\tc.b = b.a;\n\t\tc.c = a.b;\n\t\tc.d = b.b;\n\t\treturn c;\n\t}\n\n\tcs__m128i cs_mm_unpackhi_epi32(cs__m128i a, cs__m128i b)\n\t{\n\t\tcs__m128i c;\n\t\tc.a = a.c;\n\t\tc.b = b.c;\n\t\tc.c = a.d;\n\t\tc.d = b.d;\n\t\treturn c;\n\t}\n\n\tcs__m128i cs_mm_packs_epi32(cs__m128i a, cs__m128i b)\n\t{\n\t\tunion {\n\t\t\tint16_t c[8];\n\t\t\tcs__m128i m;\n\t\t} dst;\n\t\tdst.c[0] = CUTE_SOUND_SATURATE16(a.a);\n\t\tdst.c[1] = CUTE_SOUND_SATURATE16(a.b);\n\t\tdst.c[2] = CUTE_SOUND_SATURATE16(a.c);\n\t\tdst.c[3] = CUTE_SOUND_SATURATE16(a.d);\n\t\tdst.c[4] = CUTE_SOUND_SATURATE16(b.a);\n\t\tdst.c[5] = CUTE_SOUND_SATURATE16(b.b);\n\t\tdst.c[6] = CUTE_SOUND_SATURATE16(b.c);\n\t\tdst.c[7] = CUTE_SOUND_SATURATE16(b.d);\n\t\treturn dst.m;\n\t}\n\n\tcs__m128i cs_mm_cvttps_epi32(cs__m128 a)\n\t{\n\t\tcs__m128i b;\n\t\tb.a = (int32_t)a.a;\n\t\tb.b = (int32_t)a.b;\n\t\tb.c = (int32_t)a.c;\n\t\tb.d = (int32_t)a.d;\n\t\treturn b;\n\t}\n\n\tcs__m128 cs_mm_cvtepi32_ps(cs__m128i a)\n\t{\n\t\tcs__m128 b;\n\t\tb.a = (float)a.a;\n\t\tb.b = (float)a.b;\n\t\tb.c = (float)a.c;\n\t\tb.d = (float)a.d;\n\t\treturn b;\n\t}\n\n\tint32_t cs_mm_extract_epi32(cs__m128i a, const int imm8)\n\t{\n\t\tswitch (imm8) {\n\t\t\tcase 0: return a.a;\n\t\t\tcase 1: return a.b;\n\t\t\tcase 2: return a.c;\n\t\t\tcase 3: return a.d;\n\t\t\tdefault: return 0;\n\t\t}\n\t}\n\n#else // CUTE_SOUND_SCALAR_MODE\n\n\t#include <xmmintrin.h>\n\t#include <emmintrin.h>\n\n\t#define cs__m128 __m128\n\t#define cs__m128i __m128i\n\n\t#define cs_mm_set_ps _mm_set_ps\n\t#define cs_mm_set1_ps _mm_set1_ps\n\t#define cs_mm_add_ps _mm_add_ps\n\t#define cs_mm_sub_ps _mm_sub_ps\n\t#define cs_mm_mul_ps _mm_mul_ps\n\t#define cs_mm_cvtps_epi32 _mm_cvtps_epi32\n\t#define cs_mm_unpacklo_epi32 _mm_unpacklo_epi32\n\t#define cs_mm_unpackhi_epi32 _mm_unpackhi_epi32\n\t#define cs_mm_packs_epi32 _mm_packs_epi32\n\t#define cs_mm_cvttps_epi32 _mm_cvttps_epi32\n\t#define cs_mm_cvtepi32_ps _mm_cvtepi32_ps\n\t#define cs_mm_extract_epi32 _mm_extract_epi32\n\n#endif // CUTE_SOUND_SCALAR_MODE\n\n#define CUTE_SOUND_ALIGN(X, Y) ((((size_t)X) + ((Y) - 1)) & ~((Y) - 1))\n#define CUTE_SOUND_TRUNC(X, Y) ((size_t)(X) & ~((Y) - 1))\n\n// -------------------------------------------------------------------------------------------------\n// hashtable.h implementation by Mattias Gustavsson\n// See: http://www.mattiasgustavsson.com/ and https://github.com/mattiasgustavsson/libs/blob/master/hashtable.h\n// begin hashtable.h\n\n#ifndef CS_HASHTABLEMEMSET\n\t#define CS_HASHTABLEMEMSET(ptr, val, n) CUTE_SOUND_MEMSET(ptr, val, n)\n#endif\n\n#ifndef CS_HASHTABLEMEMCPY\n\t#define CS_HASHTABLEMEMCPY(dst, src, n) CUTE_SOUND_MEMCPY(dst, src, n)\n#endif\n\n#ifndef CS_HASHTABLEMALLOC\n\t#define CS_HASHTABLEMALLOC(ctx, size) CUTE_SOUND_ALLOC(size, ctx)\n#endif\n\n#ifndef CS_HASHTABLEFREE\n\t#define CS_HASHTABLEFREE(ctx, ptr) CUTE_SOUND_FREE(ptr, ctx)\n#endif\n\n/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\nhashtable.h - v1.1 - Cache efficient hash table implementation for C/C++.\nDo this:\n    #define CS_HASHTABLEIMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef cs_hashtableh\n#define cs_hashtableh\n\n#ifndef CS_HASHTABLEU64\n    #define CS_HASHTABLEU64 unsigned long long\n#endif\n\ntypedef struct cs_hashtablet cs_hashtablet;\n\nstatic void cs_hashtableinit( cs_hashtablet* table, int item_size, int initial_capacity, void* memctx );\nstatic void cs_hashtableterm( cs_hashtablet* table );\n\nstatic void* cs_hashtableinsert( cs_hashtablet* table, CS_HASHTABLEU64 key, void const* item );\nstatic void cs_hashtableremove( cs_hashtablet* table, CS_HASHTABLEU64 key );\nstatic void cs_hashtableclear( cs_hashtablet* table );\n\nstatic void* cs_hashtablefind( cs_hashtablet const* table, CS_HASHTABLEU64 key );\n\nstatic int cs_hashtablecount( cs_hashtablet const* table );\nstatic void* cs_hashtableitems( cs_hashtablet const* table );\nstatic CS_HASHTABLEU64 const* cs_hashtablekeys( cs_hashtablet const* table );\n\nstatic void cs_hashtableswap( cs_hashtablet* table, int index_a, int index_b );\n\n\n#endif /* cs_hashtableh */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef cs_hashtablet_h\n#define cs_hashtablet_h\n\n#ifndef CS_HASHTABLEU32\n    #define CS_HASHTABLEU32 unsigned int\n#endif\n\nstruct cs_hashtableinternal_slot_t\n    {\n    CS_HASHTABLEU32 key_hash;\n    int item_index;\n    int base_count;\n    };\n\nstruct cs_hashtablet\n    {\n    void* memctx;\n    int count;\n    int item_size;\n\n    struct cs_hashtableinternal_slot_t* slots;\n    int slot_capacity;\n\n    CS_HASHTABLEU64* items_key;\n    int* items_slot;\n    void* items_data;\n    int item_capacity;\n\n    void* swap_temp;\n    };\n\n#endif /* cs_hashtablet_h */\n\n// end hashtable.h\n\n#define CS_HASHTABLEIMPLEMENTATION\n\n#ifdef CS_HASHTABLEIMPLEMENTATION\n#ifndef CS_HASHTABLEIMPLEMENTATION_ONCE\n#define CS_HASHTABLEIMPLEMENTATION_ONCE\n\n// hashtable.h implementation by Mattias Gustavsson\n// See: http://www.mattiasgustavsson.com/ and https://github.com/mattiasgustavsson/libs/blob/master/hashtable.h\n// begin hashtable.h (continuing from first time)\n\n#ifndef CS_HASHTABLESIZE_T\n    #include <stddef.h>\n    #define CS_HASHTABLESIZE_T size_t\n#endif\n\n#ifndef CS_HASHTABLEASSERT\n    #include <assert.h>\n    #define CS_HASHTABLEASSERT( x ) assert( x )\n#endif\n\n#ifndef CS_HASHTABLEMEMSET\n    #include <string.h>\n    #define CS_HASHTABLEMEMSET( ptr, val, cnt ) ( memset( ptr, val, cnt ) )\n#endif \n\n#ifndef CS_HASHTABLEMEMCPY\n    #include <string.h>\n    #define CS_HASHTABLEMEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef CS_HASHTABLEMALLOC\n    #include <stdlib.h>\n    #define CS_HASHTABLEMALLOC( ctx, size ) ( malloc( size ) )\n    #define CS_HASHTABLEFREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\nstatic CS_HASHTABLEU32 cs_hashtableinternal_pow2ceil( CS_HASHTABLEU32 v )\n    {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n    }\n\n\nstatic void cs_hashtableinit( cs_hashtablet* table, int item_size, int initial_capacity, void* memctx )\n    {\n    initial_capacity = (int)cs_hashtableinternal_pow2ceil( initial_capacity >=0 ? (CS_HASHTABLEU32) initial_capacity : 32U );\n    table->memctx = memctx;\n    table->count = 0;\n    table->item_size = item_size;\n    table->slot_capacity = (int) cs_hashtableinternal_pow2ceil( (CS_HASHTABLEU32) ( initial_capacity + initial_capacity / 2 ) );\n    int slots_size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n    table->slots = (struct cs_hashtableinternal_slot_t*) CS_HASHTABLEMALLOC( table->memctx, (CS_HASHTABLESIZE_T) slots_size );\n    CS_HASHTABLEASSERT( table->slots );\n    CS_HASHTABLEMEMSET( table->slots, 0, (CS_HASHTABLESIZE_T) slots_size );\n    table->item_capacity = (int) cs_hashtableinternal_pow2ceil( (CS_HASHTABLEU32) initial_capacity );\n    table->items_key = (CS_HASHTABLEU64*) CS_HASHTABLEMALLOC( table->memctx,\n        table->item_capacity * ( sizeof( *table->items_key ) + sizeof( *table->items_slot ) + table->item_size ) + table->item_size );\n    CS_HASHTABLEASSERT( table->items_key );\n    table->items_slot = (int*)( table->items_key + table->item_capacity );\n    table->items_data = (void*)( table->items_slot + table->item_capacity );\n    table->swap_temp = (void*)( ( (uintptr_t) table->items_data ) + table->item_size * table->item_capacity ); \n    }\n\n\nstatic void cs_hashtableterm( cs_hashtablet* table )\n    {\n    CS_HASHTABLEFREE( table->memctx, table->items_key );\n    CS_HASHTABLEFREE( table->memctx, table->slots );\n    }\n\n\n// from https://gist.github.com/badboy/6267743\nstatic CS_HASHTABLEU32 cs_hashtableinternal_calculate_hash( CS_HASHTABLEU64 key )\n    {\n    key = ( ~key ) + ( key << 18 );\n    key = key ^ ( key >> 31 );\n    key = key * 21;\n    key = key ^ ( key >> 11 );\n    key = key + ( key << 6 );\n    key = key ^ ( key >> 22 );  \n    CS_HASHTABLEASSERT( key );\n    return (CS_HASHTABLEU32) key;\n    }\n\n\nstatic int cs_hashtableinternal_find_slot( cs_hashtablet const* table, CS_HASHTABLEU64 key )\n    {\n    int const slot_mask = table->slot_capacity - 1;\n    CS_HASHTABLEU32 const hash = cs_hashtableinternal_calculate_hash( key );\n\n    int const base_slot = (int)( hash & (CS_HASHTABLEU32)slot_mask );\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n\n    while( base_count > 0 )\n        {\n        CS_HASHTABLEU32 slot_hash = table->slots[ slot ].key_hash;\n        if( slot_hash )\n            {\n            int slot_base = (int)( slot_hash & (CS_HASHTABLEU32)slot_mask );\n            if( slot_base == base_slot ) \n                {\n                CS_HASHTABLEASSERT( base_count > 0 );\n                --base_count;\n                if( slot_hash == hash && table->items_key[ table->slots[ slot ].item_index ] == key )\n                    return slot;\n                }\n            }\n        slot = ( slot + 1 ) & slot_mask;\n        }   \n\n    return -1;\n    }\n\n\nstatic void cs_hashtableinternal_expand_slots( cs_hashtablet* table )\n    {\n    int const old_capacity = table->slot_capacity;\n    struct cs_hashtableinternal_slot_t* old_slots = table->slots;\n\n    table->slot_capacity *= 2;\n    int const slot_mask = table->slot_capacity - 1;\n\n    int const size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n    table->slots = (struct cs_hashtableinternal_slot_t*) CS_HASHTABLEMALLOC( table->memctx, (CS_HASHTABLESIZE_T) size );\n    CS_HASHTABLEASSERT( table->slots );\n    CS_HASHTABLEMEMSET( table->slots, 0, (CS_HASHTABLESIZE_T) size );\n\n    for( int i = 0; i < old_capacity; ++i )\n        {\n        CS_HASHTABLEU32 const hash = old_slots[ i ].key_hash;\n        if( hash )\n            {\n            int const base_slot = (int)( hash & (CS_HASHTABLEU32)slot_mask );\n            int slot = base_slot;\n            while( table->slots[ slot ].key_hash )\n                slot = ( slot + 1 ) & slot_mask;\n            table->slots[ slot ].key_hash = hash;\n            int item_index = old_slots[ i ].item_index;\n            table->slots[ slot ].item_index = item_index;\n            table->items_slot[ item_index ] = slot; \n            ++table->slots[ base_slot ].base_count;\n            }               \n        }\n\n    CS_HASHTABLEFREE( table->memctx, old_slots );\n    }\n\n\nstatic void cs_hashtableinternal_expand_items( cs_hashtablet* table )\n    {\n    table->item_capacity *= 2;\n     CS_HASHTABLEU64* const new_items_key = (CS_HASHTABLEU64*) CS_HASHTABLEMALLOC( table->memctx, \n         table->item_capacity * ( sizeof( *table->items_key ) + sizeof( *table->items_slot ) + table->item_size ) + table->item_size);\n    CS_HASHTABLEASSERT( new_items_key );\n\n    int* const new_items_slot = (int*)( new_items_key + table->item_capacity );\n    void* const new_items_data = (void*)( new_items_slot + table->item_capacity );\n    void* const new_swap_temp = (void*)( ( (uintptr_t) new_items_data ) + table->item_size * table->item_capacity ); \n\n    CS_HASHTABLEMEMCPY( new_items_key, table->items_key, table->count * sizeof( *table->items_key ) );\n    CS_HASHTABLEMEMCPY( new_items_slot, table->items_slot, table->count * sizeof( *table->items_key ) );\n    CS_HASHTABLEMEMCPY( new_items_data, table->items_data, (CS_HASHTABLESIZE_T) table->count * table->item_size );\n    \n    CS_HASHTABLEFREE( table->memctx, table->items_key );\n\n    table->items_key = new_items_key;\n    table->items_slot = new_items_slot;\n    table->items_data = new_items_data;\n    table->swap_temp = new_swap_temp;\n    }\n\n\nstatic void* cs_hashtableinsert( cs_hashtablet* table, CS_HASHTABLEU64 key, void const* item )\n    {\n    CS_HASHTABLEASSERT( cs_hashtableinternal_find_slot( table, key ) < 0 );\n\n    if( table->count >= ( table->slot_capacity - table->slot_capacity / 3 ) )\n        cs_hashtableinternal_expand_slots( table );\n        \n    int const slot_mask = table->slot_capacity - 1;\n    CS_HASHTABLEU32 const hash = cs_hashtableinternal_calculate_hash( key );\n\n    int const base_slot = (int)( hash & (CS_HASHTABLEU32)slot_mask );\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n    int first_free = slot;\n    while( base_count )\n        {\n        CS_HASHTABLEU32 const slot_hash = table->slots[ slot ].key_hash;\n        if( slot_hash == 0 && table->slots[ first_free ].key_hash != 0 ) first_free = slot;\n        int slot_base = (int)( slot_hash & (CS_HASHTABLEU32)slot_mask );\n        if( slot_base == base_slot ) \n            --base_count;\n        slot = ( slot + 1 ) & slot_mask;\n        }       \n\n    slot = first_free;\n    while( table->slots[ slot ].key_hash )\n        slot = ( slot + 1 ) & slot_mask;\n\n    if( table->count >= table->item_capacity )\n        cs_hashtableinternal_expand_items( table );\n\n    CS_HASHTABLEASSERT( !table->slots[ slot ].key_hash && ( hash & (CS_HASHTABLEU32) slot_mask ) == (CS_HASHTABLEU32) base_slot );\n    CS_HASHTABLEASSERT( hash );\n    table->slots[ slot ].key_hash = hash;\n    table->slots[ slot ].item_index = table->count;\n    ++table->slots[ base_slot ].base_count;\n\n\n    void* dest_item = (void*)( ( (uintptr_t) table->items_data ) + table->count * table->item_size );\n    CS_HASHTABLEMEMCPY( dest_item, item, (CS_HASHTABLESIZE_T) table->item_size );\n    table->items_key[ table->count ] = key;\n    table->items_slot[ table->count ] = slot;\n    ++table->count;\n    return dest_item;\n    } \n\n\nstatic void cs_hashtableremove( cs_hashtablet* table, CS_HASHTABLEU64 key )\n    {\n    int const slot = cs_hashtableinternal_find_slot( table, key );\n    CS_HASHTABLEASSERT( slot >= 0 );\n\n    int const slot_mask = table->slot_capacity - 1;\n    CS_HASHTABLEU32 const hash = table->slots[ slot ].key_hash;\n    int const base_slot = (int)( hash & (CS_HASHTABLEU32) slot_mask );\n    CS_HASHTABLEASSERT( hash );\n    --table->slots[ base_slot ].base_count;\n    table->slots[ slot ].key_hash = 0;\n\n    int index = table->slots[ slot ].item_index;\n    int last_index = table->count - 1;\n    if( index != last_index )\n        {\n        table->items_key[ index ] = table->items_key[ last_index ];\n        table->items_slot[ index ] = table->items_slot[ last_index ];\n        void* dst_item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n        void* src_item = (void*)( ( (uintptr_t) table->items_data ) + last_index * table->item_size );\n        CS_HASHTABLEMEMCPY( dst_item, src_item, (CS_HASHTABLESIZE_T) table->item_size );\n        table->slots[ table->items_slot[ last_index ] ].item_index = index;\n        }\n    --table->count;\n    } \n\n\nstatic void cs_hashtableclear( cs_hashtablet* table )\n    {\n    table->count = 0;\n    CS_HASHTABLEMEMSET( table->slots, 0, table->slot_capacity * sizeof( *table->slots ) );\n    }\n\n\nstatic void* cs_hashtablefind( cs_hashtablet const* table, CS_HASHTABLEU64 key )\n    {\n    int const slot = cs_hashtableinternal_find_slot( table, key );\n    if( slot < 0 ) return 0;\n\n    int const index = table->slots[ slot ].item_index;\n    void* const item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n    return item;\n    }\n\n\nstatic int cs_hashtablecount( cs_hashtablet const* table )\n    {\n    return table->count;\n    }\n\n\nstatic void* cs_hashtableitems( cs_hashtablet const* table )\n    {\n    return table->items_data;\n    }\n\n\nstatic CS_HASHTABLEU64 const* cs_hashtablekeys( cs_hashtablet const* table )\n    {\n    return table->items_key;\n    }\n\n\nstatic void cs_hashtableswap( cs_hashtablet* table, int index_a, int index_b )\n    {\n    if( index_a < 0 || index_a >= table->count || index_b < 0 || index_b >= table->count ) return;\n\n    int slot_a = table->items_slot[ index_a ];\n    int slot_b = table->items_slot[ index_b ];\n\n    table->items_slot[ index_a ] = slot_b;\n    table->items_slot[ index_b ] = slot_a;\n\n    CS_HASHTABLEU64 temp_key = table->items_key[ index_a ];\n    table->items_key[ index_a ] = table->items_key[ index_b ];\n    table->items_key[ index_b ] = temp_key;\n\n    void* item_a = (void*)( ( (uintptr_t) table->items_data ) + index_a * table->item_size );\n    void* item_b = (void*)( ( (uintptr_t) table->items_data ) + index_b * table->item_size );\n    CS_HASHTABLEMEMCPY( table->swap_temp, item_a, table->item_size );\n    CS_HASHTABLEMEMCPY( item_a, item_b, table->item_size );\n    CS_HASHTABLEMEMCPY( item_b, table->swap_temp, table->item_size );\n\n    table->slots[ slot_a ].item_index = index_b;\n    table->slots[ slot_b ].item_index = index_a;\n    }\n\n\n#endif /* CS_HASHTABLEIMPLEMENTATION */\n#endif // CS_HASHTABLEIMPLEMENTATION_ONCE\n\n/*\ncontributors:\n    Randy Gaul (cs_hashtableclear, cs_hashtableswap )\nrevision history:\n    1.1     added cs_hashtableclear, cs_hashtableswap\n    1.0     first released version  \n*/\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses - you may choose the one you like.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2015 Mattias Gustavsson\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n\n// end of hashtable.h\n\n// -------------------------------------------------------------------------------------------------\n// Doubly list.\n\ntypedef struct cs_list_node_t\n{\n\tstruct cs_list_node_t* next /* = this */;\n\tstruct cs_list_node_t* prev /* = this */;\n} cs_list_node_t;\n\ntypedef struct cs_list_t\n{\n\tcs_list_node_t nodes;\n} cs_list_t;\n\n#define CUTE_SOUND_OFFSET_OF(T, member) ((size_t)((uintptr_t)(&(((T*)0)->member))))\n#define CUTE_SOUND_LIST_NODE(T, member, ptr) ((cs_list_node_t*)((uintptr_t)ptr + CUTE_SOUND_OFFSET_OF(T, member)))\n#define CUTE_SOUND_LIST_HOST(T, member, ptr) ((T*)((uintptr_t)ptr - CUTE_SOUND_OFFSET_OF(T, member)))\n\nvoid cs_list_init_node(cs_list_node_t* node)\n{\n\tnode->next = node;\n\tnode->prev = node;\n}\n\nvoid cs_list_init(cs_list_t* list)\n{\n\tcs_list_init_node(&list->nodes);\n}\n\nvoid cs_list_push_front(cs_list_t* list, cs_list_node_t* node)\n{\n\tnode->next = list->nodes.next;\n\tnode->prev = &list->nodes;\n\tlist->nodes.next->prev = node;\n\tlist->nodes.next = node;\n}\n\nvoid cs_list_push_back(cs_list_t* list, cs_list_node_t* node)\n{\n\tnode->prev = list->nodes.prev;\n\tnode->next = &list->nodes;\n\tlist->nodes.prev->next = node;\n\tlist->nodes.prev = node;\n}\n\nvoid cs_list_remove(cs_list_node_t* node)\n{\n\tnode->prev->next = node->next;\n\tnode->next->prev = node->prev;\n\tcs_list_init_node(node);\n}\n\ncs_list_node_t* cs_list_pop_front(cs_list_t* list)\n{\n\tcs_list_node_t* node = list->nodes.next;\n\tcs_list_remove(node);\n\treturn node;\n}\n\ncs_list_node_t* cs_list_pop_back(cs_list_t* list)\n{\n\tcs_list_node_t* node = list->nodes.prev;\n\tcs_list_remove(node);\n\treturn node;\n}\n\nint cs_list_empty(cs_list_t* list)\n{\n\treturn list->nodes.next == list->nodes.prev && list->nodes.next == &list->nodes;\n}\n\ncs_list_node_t* cs_list_begin(cs_list_t* list)\n{\n\treturn list->nodes.next;\n}\n\ncs_list_node_t* cs_list_end(cs_list_t* list)\n{\n\treturn &list->nodes;\n}\n\ncs_list_node_t* cs_list_front(cs_list_t* list)\n{\n\treturn list->nodes.next;\n}\n\ncs_list_node_t* cs_list_back(cs_list_t* list)\n{\n\treturn list->nodes.prev;\n}\n\n// -------------------------------------------------------------------------------------------------\n\nconst char* cs_error_as_string(cs_error_t error) {\n\tswitch (error) {\n\tcase CUTE_SOUND_ERROR_NONE: return \"CUTE_SOUND_ERROR_NONE\";\n\tcase CUTE_SOUND_ERROR_IMPLEMENTATION_ERROR_PLEASE_REPORT_THIS_ON_GITHUB: return \"CUTE_SOUND_ERROR_IMPLEMENTATION_ERROR_PLEASE_REPORT_THIS_ON_GITHUB\";\n\tcase CUTE_SOUND_ERROR_FILE_NOT_FOUND: return \"CUTE_SOUND_ERROR_FILE_NOT_FOUND\";\n\tcase CUTE_SOUND_ERROR_INVALID_SOUND: return \"CUTE_SOUND_ERROR_INVALID_SOUND\";\n\tcase CUTE_SOUND_ERROR_HWND_IS_NULL: return \"CUTE_SOUND_ERROR_HWND_IS_NULL\";\n\tcase CUTE_SOUND_ERROR_DIRECTSOUND_CREATE_FAILED: return \"CUTE_SOUND_ERROR_DIRECTSOUND_CREATE_FAILED\";\n\tcase CUTE_SOUND_ERROR_CREATESOUNDBUFFER_FAILED: return \"CUTE_SOUND_ERROR_CREATESOUNDBUFFER_FAILED\";\n\tcase CUTE_SOUND_ERROR_SETFORMAT_FAILED: return \"CUTE_SOUND_ERROR_SETFORMAT_FAILED\";\n\tcase CUTE_SOUND_ERROR_AUDIOCOMPONENTFINDNEXT_FAILED: return \"CUTE_SOUND_ERROR_AUDIOCOMPONENTFINDNEXT_FAILED\";\n\tcase CUTE_SOUND_ERROR_AUDIOCOMPONENTINSTANCENEW_FAILED: return \"CUTE_SOUND_ERROR_AUDIOCOMPONENTINSTANCENEW_FAILED\";\n\tcase CUTE_SOUND_ERROR_FAILED_TO_SET_STREAM_FORMAT: return \"CUTE_SOUND_ERROR_FAILED_TO_SET_STREAM_FORMAT\";\n\tcase CUTE_SOUND_ERROR_FAILED_TO_SET_RENDER_CALLBACK: return \"CUTE_SOUND_ERROR_FAILED_TO_SET_RENDER_CALLBACK\";\n\tcase CUTE_SOUND_ERROR_AUDIOUNITINITIALIZE_FAILED: return \"CUTE_SOUND_ERROR_AUDIOUNITINITIALIZE_FAILED\";\n\tcase CUTE_SOUND_ERROR_AUDIOUNITSTART_FAILED: return \"CUTE_SOUND_ERROR_AUDIOUNITSTART_FAILED\";\n\tcase CUTE_SOUND_ERROR_CANT_OPEN_AUDIO_DEVICE: return \"CUTE_SOUND_ERROR_CANT_OPEN_AUDIO_DEVICE\";\n\tcase CUTE_SOUND_ERROR_CANT_INIT_SDL_AUDIO: return \"CUTE_SOUND_ERROR_CANT_INIT_SDL_AUDIO\";\n\tcase CUTE_SOUND_ERROR_THE_FILE_IS_NOT_A_WAV_FILE: return \"CUTE_SOUND_ERROR_THE_FILE_IS_NOT_A_WAV_FILE\";\n\tcase CUTE_SOUND_ERROR_WAV_FILE_FORMAT_CHUNK_NOT_FOUND: return \"CUTE_SOUND_ERROR_WAV_FILE_FORMAT_CHUNK_NOT_FOUND\";\n\tcase CUTE_SOUND_ERROR_WAV_DATA_CHUNK_NOT_FOUND: return \"CUTE_SOUND_ERROR_WAV_DATA_CHUNK_NOT_FOUND\";\n\tcase CUTE_SOUND_ERROR_ONLY_PCM_WAV_FILES_ARE_SUPPORTED: return \"CUTE_SOUND_ERROR_ONLY_PCM_WAV_FILES_ARE_SUPPORTED\";\n\tcase CUTE_SOUND_ERROR_WAV_ONLY_MONO_OR_STEREO_IS_SUPPORTED: return \"CUTE_SOUND_ERROR_WAV_ONLY_MONO_OR_STEREO_IS_SUPPORTED\";\n\tcase CUTE_SOUND_ERROR_WAV_ONLY_16_BITS_PER_SAMPLE_SUPPORTED: return \"CUTE_SOUND_ERROR_WAV_ONLY_16_BITS_PER_SAMPLE_SUPPORTED\";\n\tcase CUTE_SOUND_ERROR_CANNOT_SWITCH_MUSIC_WHILE_PAUSED: return \"CUTE_SOUND_ERROR_CANNOT_SWITCH_MUSIC_WHILE_PAUSED\";\n\tcase CUTE_SOUND_ERROR_CANNOT_CROSSFADE_WHILE_MUSIC_IS_PAUSED: return \"CUTE_SOUND_ERROR_CANNOT_CROSSFADE_WHILE_MUSIC_IS_PAUSED\";\n\tcase CUTE_SOUND_ERROR_CANNOT_FADEOUT_WHILE_MUSIC_IS_PAUSED: return \"CUTE_SOUND_ERROR_CANNOT_FADEOUT_WHILE_MUSIC_IS_PAUSED\";\n\tcase CUTE_SOUND_ERROR_TRIED_TO_SET_SAMPLE_INDEX_BEYOND_THE_AUDIO_SOURCES_SAMPLE_COUNT: return \"CUTE_SOUND_ERROR_TRIED_TO_SET_SAMPLE_INDEX_BEYOND_THE_AUDIO_SOURCES_SAMPLE_COUNT\";\n\tcase CUTE_SOUND_ERROR_STB_VORBIS_DECODE_FAILED: return \"CUTE_SOUND_ERROR_STB_VORBIS_DECODE_FAILED\";\n\tcase CUTE_SOUND_ERROR_OGG_UNSUPPORTED_CHANNEL_COUNT: return \"CUTE_SOUND_ERROR_OGG_UNSUPPORTED_CHANNEL_COUN\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\n// Cute sound context functions.\n\nvoid cs_mix();\n\ntypedef struct cs_audio_source_t\n{\n\tint sample_rate;\n\tint sample_count;\n\tint channel_count;\n\n\t// Number of instances currently referencing this audio. Must be zero\n\t// in order to safely delete the audio. References are automatically\n\t// updated whenever playing instances are inserted into the context.\n\tint playing_count;\n\n\t// The actual raw audio samples in memory.\n\tvoid* channels[2];\n} cs_audio_source_t;\n\ntypedef struct cs_sound_inst_t\n{\n\tuint64_t id;\n\tbool is_music;\n\tbool active;\n\tbool paused;\n\tbool looped;\n\tfloat volume;\n\tfloat pan0;\n\tfloat pan1;\n\tfloat pitch;\n\tint sample_index;\n\tcs_audio_source_t* audio;\n\tcs_list_node_t node;\n} cs_sound_inst_t;\n\ntypedef enum cs_music_state_t\n{\n\tCUTE_SOUND_MUSIC_STATE_NONE,\n\tCUTE_SOUND_MUSIC_STATE_PLAYING,\n\tCUTE_SOUND_MUSIC_STATE_FADE_OUT,\n\tCUTE_SOUND_MUSIC_STATE_FADE_IN,\n\tCUTE_SOUND_MUSIC_STATE_SWITCH_TO_0,\n\tCUTE_SOUND_MUSIC_STATE_SWITCH_TO_1,\n\tCUTE_SOUND_MUSIC_STATE_CROSSFADE,\n\tCUTE_SOUND_MUSIC_STATE_PAUSED\n} cs_music_state_t;\n\n#define CUTE_SOUND_PAGE_INSTANCE_COUNT 1024\n\ntypedef struct cs_inst_page_t\n{\n\tstruct cs_inst_page_t* next;\n\tcs_sound_inst_t instances[CUTE_SOUND_PAGE_INSTANCE_COUNT];\n} cs_inst_page_t;\n\ntypedef struct cs_context_t\n{\n\tfloat global_pan /* = 0.5f */;\n\tfloat global_volume /* = 1.0f */;\n\tbool global_pause /* = false */;\n\tfloat music_volume /* = 1.0f */;\n\tfloat music_pitch /* = 1.0f */;\n\tfloat sound_volume /* = 1.0f */;\n\tbool cull_duplicates /* = false */;\n\tvoid** duplicates /* = NULL */;\n\tint duplicate_count /* = 0 */;\n\tint duplicate_capacity /* = 0 */;\n\tvoid (*on_finish)(cs_playing_sound_t, void*); /* = NULL */;\n\tvoid* on_finish_udata /* = NULL */;\n\tvoid (*on_music_finish)(void*); /* = NULL */;\n\tvoid* on_music_finish_udata /* = NULL */;\n\n\tbool music_paused /* = false */;\n\tbool music_looped /* = true */;\n\tfloat t /* = 0 */;\n\tfloat fade /* = 0 */;\n\tfloat fade_switch_1 /* = 0 */;\n\tcs_music_state_t music_state /* = MUSIC_STATE_NONE */;\n\tcs_music_state_t music_state_to_resume_from_paused /* = MUSIC_STATE_NONE */;\n\tcs_sound_inst_t* music_playing /* = NULL */;\n\tcs_sound_inst_t* music_next /* = NULL */;\n\n\tint audio_sources_to_free_capacity /* = 0 */;\n\tint audio_sources_to_free_size /* = 0 */;\n\tcs_audio_source_t** audio_sources_to_free /* = NULL */;\n\tuint64_t instance_id_gen /* = 1 */;\n\tcs_hashtablet instance_map; // <uint64_t, cs_audio_source_t*>\n\tcs_inst_page_t* pages /* = NULL */;\n\tcs_list_t playing_sounds;\n\tcs_list_t free_sounds;\n\n\tunsigned latency_samples;\n\tint Hz;\n\tint bps;\n\tint wide_count;\n\tcs__m128* floatA;\n\tcs__m128* floatB;\n\tcs__m128i* samples;\n\tbool separate_thread;\n\tbool running;\n\tint sleep_milliseconds;\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tDWORD last_cursor;\n\tunsigned running_index;\n\tint buffer_size;\n\tLPDIRECTSOUND dsound;\n\tLPDIRECTSOUNDBUFFER primary;\n\tLPDIRECTSOUNDBUFFER secondary;\n\n\t// data for cs_mix thread, enable these with cs_spawn_mix_thread\n\tCRITICAL_SECTION critical_section;\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\tunsigned index0; // read\n\tunsigned index1; // write\n\tunsigned samples_in_circular_buffer;\n\tint sample_count;\n\n\t// platform specific stuff\n\tAudioComponentInstance inst;\n\n\t// data for cs_mix thread, enable these with cs_spawn_mix_thread\n\tpthread_t thread;\n\tpthread_mutex_t mutex;\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tunsigned index0; // read\n\tunsigned index1; // write\n\tunsigned samples_in_circular_buffer;\n\tint sample_count;\n\tSDL_AudioDeviceID dev;\n\n\t// data for cs_mix thread, enable these with cs_spawn_mix_thread\n\tSDL_Thread* thread;\n\tSDL_mutex* mutex;\n\n#endif\n} cs_context_t;\n\nvoid* s_mem_ctx;\ncs_context_t* s_ctx = NULL;\n\nvoid cs_sleep(int milliseconds)\n{\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\tSleep(milliseconds);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\tstruct timespec ts = { 0, milliseconds * 1000000 };\n\tnanosleep(&ts, NULL);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\tSDL_Delay(milliseconds);\n#endif\n}\n\nstatic void* cs_malloc16(size_t size)\n{\n\tvoid* p = CUTE_SOUND_ALLOC(size + 16, s_mem_ctx);\n\tif (!p) return 0;\n\tunsigned char offset = (size_t)p & 15;\n\tp = (void*)CUTE_SOUND_ALIGN(p + 1, 16);\n\t*((char*)p - 1) = 16 - offset;\n\tCUTE_SOUND_ASSERT(!((size_t)p & 15));\n\treturn p;\n}\n\nstatic void cs_free16(void* p)\n{\n\tif (!p) return;\n\tCUTE_SOUND_FREE((char*)p - (((size_t)*((char*)p - 1)) & 0xFF), s_mem_ctx);\n}\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL || CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\tstatic int cs_samples_written()\n\t{\n\t\treturn s_ctx->samples_in_circular_buffer;\n\t}\n\n\tstatic int cs_samples_unwritten()\n\t{\n\t\treturn s_ctx->sample_count - s_ctx->samples_in_circular_buffer;\n\t}\n\n\tstatic int cs_samples_to_mix()\n\t{\n\t\tint lat = s_ctx->latency_samples;\n\t\tint written = cs_samples_written();\n\t\tint dif = lat - written;\n\t\tCUTE_SOUND_ASSERT(dif >= 0);\n\t\tif (dif)\n\t\t{\n\t\t\tint unwritten = cs_samples_unwritten();\n\t\t\treturn dif < unwritten ? dif : unwritten;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t#define CUTE_SOUND_SAMPLES_TO_BYTES(interleaved_sample_count) ((interleaved_sample_count) * s_ctx->bps)\n\t#define CUTE_SOUND_BYTES_TO_SAMPLES(byte_count) ((byte_count) / s_ctx->bps)\n\n\tstatic void cs_push_bytes(void* data, int size)\n\t{\n\t\tint index1 = s_ctx->index1;\n\t\tint samples_to_write = CUTE_SOUND_BYTES_TO_SAMPLES(size);\n\t\tint sample_count = s_ctx->sample_count;\n\n\t\tint unwritten = cs_samples_unwritten();\n\t\tif (unwritten < samples_to_write) samples_to_write = unwritten;\n\t\tint samples_to_end = sample_count - index1;\n\n\t\tif (samples_to_write > samples_to_end) {\n\t\t\tCUTE_SOUND_MEMCPY((char*)s_ctx->samples + CUTE_SOUND_SAMPLES_TO_BYTES(index1), data, CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end));\n\t\t\tCUTE_SOUND_MEMCPY(s_ctx->samples, (char*)data + CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end), size - CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end));\n\t\t\ts_ctx->index1 = (samples_to_write - samples_to_end) % sample_count;\n\t\t} else {\n\t\t\tCUTE_SOUND_MEMCPY((char*)s_ctx->samples + CUTE_SOUND_SAMPLES_TO_BYTES(index1), data, size);\n\t\t\ts_ctx->index1 = (s_ctx->index1 + samples_to_write) % sample_count;\n\t\t}\n\n\t\ts_ctx->samples_in_circular_buffer += samples_to_write;\n\t}\n\n\tstatic int cs_pull_bytes(void* dst, int size)\n\t{\n\t\tint index0 = s_ctx->index0;\n\t\tint allowed_size = CUTE_SOUND_SAMPLES_TO_BYTES(cs_samples_written());\n\t\tint sample_count = s_ctx->sample_count;\n\t\tint zeros = 0;\n\n\t\tif (allowed_size < size) {\n\t\t\tzeros = size - allowed_size;\n\t\t\tsize = allowed_size;\n\t\t}\n\n\t\tint samples_to_read = CUTE_SOUND_BYTES_TO_SAMPLES(size);\n\t\tint samples_to_end = sample_count - index0;\n\n\t\tif (samples_to_read > samples_to_end) {\n\t\t\tCUTE_SOUND_MEMCPY(dst, ((char*)s_ctx->samples) + CUTE_SOUND_SAMPLES_TO_BYTES(index0), CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end));\n\t\t\tCUTE_SOUND_MEMCPY(((char*)dst) + CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end), s_ctx->samples, size - CUTE_SOUND_SAMPLES_TO_BYTES(samples_to_end));\n\t\t\ts_ctx->index0 = (samples_to_read - samples_to_end) % sample_count;\n\t\t} else {\n\t\t\tCUTE_SOUND_MEMCPY(dst, ((char*)s_ctx->samples) + CUTE_SOUND_SAMPLES_TO_BYTES(index0), size);\n\t\t\ts_ctx->index0 = (s_ctx->index0 + samples_to_read) % sample_count;\n\t\t}\n\n\t\ts_ctx->samples_in_circular_buffer -= samples_to_read;\n\n\t\treturn zeros;\n\t}\n\n#endif\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tstatic DWORD WINAPI cs_ctx_thread(LPVOID lpParameter)\n\t{\n\t\t(void)lpParameter;\n\t\twhile (s_ctx->running) {\n\t\t\tcs_mix();\n\t\t\tif (s_ctx->sleep_milliseconds) cs_sleep(s_ctx->sleep_milliseconds);\n\t\t\telse YieldProcessor();\n\t\t}\n\n\t\ts_ctx->separate_thread = false;\n\t\treturn 0;\n\t}\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\tstatic void* cs_ctx_thread(void* udata)\n\t{\n\t\twhile (s_ctx->running) {\n\t\t\tcs_mix();\n\t\t\tif (s_ctx->sleep_milliseconds) cs_sleep(s_ctx->sleep_milliseconds);\n\t\t\telse pthread_yield_np();\n\t\t}\n\n\t\ts_ctx->separate_thread = 0;\n\t\tpthread_exit(0);\n\t\treturn 0;\n\t}\n\n\tstatic OSStatus cs_memcpy_to_coreaudio(void* udata, AudioUnitRenderActionFlags* ioActionFlags, const AudioTimeStamp* inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList* ioData)\n\t{\n\t\tint bps = s_ctx->bps;\n\t\tint samples_requested_to_consume = inNumberFrames;\n\t\tAudioBuffer* buffer = ioData->mBuffers;\n\n\t\tCUTE_SOUND_ASSERT(ioData->mNumberBuffers == 1);\n\t\tCUTE_SOUND_ASSERT(buffer->mNumberChannels == 2);\n\t\tint byte_size = buffer->mDataByteSize;\n\t\tCUTE_SOUND_ASSERT(byte_size == samples_requested_to_consume * bps);\n\n\t\tint zero_bytes = cs_pull_bytes(buffer->mData, byte_size);\n\t\tCUTE_SOUND_MEMSET(((char*)buffer->mData) + (byte_size - zero_bytes), 0, zero_bytes);\n\n\t\treturn noErr;\n\t}\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tint cs_ctx_thread(void* udata)\n\t{\n\t\twhile (s_ctx->running) {\n\t\t\tcs_mix();\n\t\t\tif (s_ctx->sleep_milliseconds) cs_sleep(s_ctx->sleep_milliseconds);\n\t\t\telse cs_sleep(1);\n\t\t}\n\n\t\ts_ctx->separate_thread = false;\n\t\treturn 0;\n\t}\n\n\tstatic void cs_sdl_audio_callback(void* udata, Uint8* stream, int len)\n\t{\n\t\tint zero_bytes = cs_pull_bytes(stream, len);\n\t\tCUTE_SOUND_MEMSET(stream + (len - zero_bytes), 0, zero_bytes);\n\t}\n\n#endif\n\nstatic void s_add_page()\n{\n\tcs_inst_page_t* page = (cs_inst_page_t*)CUTE_SOUND_ALLOC(sizeof(cs_inst_page_t), user_allocator_context);\n\tfor (int i = 0; i < CUTE_SOUND_PAGE_INSTANCE_COUNT; ++i) {\n\t\tcs_list_init_node(&page->instances[i].node);\n\t\tcs_list_push_back(&s_ctx->free_sounds, &page->instances[i].node);\n\t}\n\tpage->next = s_ctx->pages;\n\ts_ctx->pages = page;\n}\n\ncs_error_t cs_init(void* os_handle, unsigned play_frequency_in_Hz, int buffered_samples, void* user_allocator_context /* = NULL */)\n{\n\tbuffered_samples = buffered_samples < CUTE_SOUND_MINIMUM_BUFFERED_SAMPLES ? CUTE_SOUND_MINIMUM_BUFFERED_SAMPLES : buffered_samples;\n\tint sample_count = buffered_samples;\n\tint wide_count = (int)CUTE_SOUND_ALIGN(sample_count, 4);\n\tint bps = sizeof(uint16_t) * 2;\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tint buffer_size = buffered_samples * bps;\n\tLPDIRECTSOUND dsound = NULL;\n\tLPDIRECTSOUNDBUFFER primary_buffer = NULL;\n\tLPDIRECTSOUNDBUFFER secondary_buffer = NULL;\n\n\tif (!os_handle) return CUTE_SOUND_ERROR_HWND_IS_NULL;\n\t{\n\t\tWAVEFORMATEX format = { 0, 0, 0, 0, 0, 0, 0 };\n\t\tDSBUFFERDESC bufdesc = { 0, 0, 0, 0, 0, { 0, 0, 0, 0 } };\n\t\tHRESULT res = DirectSoundCreate(0, &dsound, 0);\n\t\tif (res != DS_OK) return CUTE_SOUND_ERROR_DIRECTSOUND_CREATE_FAILED;\n\t\tIDirectSound_SetCooperativeLevel(dsound, (HWND)os_handle, DSSCL_PRIORITY);\n\t\tbufdesc.dwSize = sizeof(bufdesc);\n\t\tbufdesc.dwFlags = DSBCAPS_PRIMARYBUFFER;\n\n\t\tres = IDirectSound_CreateSoundBuffer(dsound, &bufdesc, &primary_buffer, 0);\n\t\tif (res != DS_OK) CUTE_SOUND_ERROR_CREATESOUNDBUFFER_FAILED;\n\n\t\tformat.wFormatTag = WAVE_FORMAT_PCM;\n\t\tformat.nChannels = 2;\n\t\tformat.nSamplesPerSec = play_frequency_in_Hz;\n\t\tformat.wBitsPerSample = 16;\n\t\tformat.nBlockAlign = (format.nChannels * format.wBitsPerSample) / 8;\n\t\tformat.nAvgBytesPerSec = format.nSamplesPerSec * format.nBlockAlign;\n\t\tformat.cbSize = 0;\n\t\tres = IDirectSoundBuffer_SetFormat(primary_buffer, &format);\n\t\tif (res != DS_OK) CUTE_SOUND_ERROR_SETFORMAT_FAILED;\n\n\t\tbufdesc.dwSize = sizeof(bufdesc);\n\t\tbufdesc.dwFlags = DSBCAPS_GETCURRENTPOSITION2;\n\t\tbufdesc.dwBufferBytes = buffer_size;\n\t\tbufdesc.lpwfxFormat = &format;\n\t\tres = IDirectSound_CreateSoundBuffer(dsound, &bufdesc, &secondary_buffer, 0);\n\t\tif (res != DS_OK) CUTE_SOUND_ERROR_SETFORMAT_FAILED;\n\n\t\t// Silence the initial audio buffer.\n\t\tvoid* region1;\n\t\tDWORD size1;\n\t\tvoid* region2;\n\t\tDWORD size2;\n\t\tres = IDirectSoundBuffer_Lock(secondary_buffer, 0, bufdesc.dwBufferBytes, &region1, &size1, &region2, &size2, DSBLOCK_ENTIREBUFFER);\n\t\tif (res == DS_OK) {\n\t\t\tCUTE_SOUND_MEMSET(region1, 0, size1);\n\t\t\tIDirectSoundBuffer_Unlock(secondary_buffer, region1, size1, region2, size2);\n\t\t}\n\t}\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\tAudioComponentDescription comp_desc = { 0 };\n\tcomp_desc.componentType = kAudioUnitType_Output;\n\tcomp_desc.componentSubType = kAudioUnitSubType_DefaultOutput;\n\tcomp_desc.componentFlags = 0;\n\tcomp_desc.componentFlagsMask = 0;\n\tcomp_desc.componentManufacturer = kAudioUnitManufacturer_Apple;\n\n\tAudioComponent comp = AudioComponentFindNext(NULL, &comp_desc);\n\tif (!comp) return CUTE_SOUND_ERROR_AUDIOCOMPONENTFINDNEXT_FAILED;\n\n\tAudioStreamBasicDescription stream_desc = { 0 };\n\tstream_desc.mSampleRate = (double)play_frequency_in_Hz;\n\tstream_desc.mFormatID = kAudioFormatLinearPCM;\n\tstream_desc.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagsNativeEndian | kAudioFormatFlagIsPacked;\n\tstream_desc.mFramesPerPacket = 1;\n\tstream_desc.mChannelsPerFrame = 2;\n\tstream_desc.mBitsPerChannel = sizeof(uint16_t) * 8;\n\tstream_desc.mBytesPerPacket = bps;\n\tstream_desc.mBytesPerFrame = bps;\n\tstream_desc.mReserved = 0;\n\n\tAudioComponentInstance inst;\n\tOSStatus ret;\n\tAURenderCallbackStruct input;\n\n\tret = AudioComponentInstanceNew(comp, &inst);\n\tif (ret != noErr) return CUTE_SOUND_ERROR_AUDIOCOMPONENTINSTANCENEW_FAILED;\n\n\tret = AudioUnitSetProperty(inst, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &stream_desc, sizeof(stream_desc));\n\tif (ret != noErr) return CUTE_SOUND_ERROR_FAILED_TO_SET_STREAM_FORMAT;\n\n\tret = AudioUnitInitialize(inst);\n\tif (ret != noErr) return CUTE_SOUND_ERROR_AUDIOUNITINITIALIZE_FAILED;\n\n\tret = AudioOutputUnitStart(inst);\n\tif (ret != noErr) return CUTE_SOUND_ERROR_AUDIOUNITSTART_FAILED;\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tSDL_AudioSpec wanted, have;\n\tint ret = SDL_InitSubSystem(SDL_INIT_AUDIO);\n\tif (ret < 0) return CUTE_SOUND_ERROR_CANT_INIT_SDL_AUDIO;\n\n#endif\n\n\ts_ctx = (cs_context_t*)CUTE_SOUND_ALLOC(sizeof(cs_context_t), user_allocator_context);\n\ts_ctx->global_pan = 0.5f;\n\ts_ctx->global_volume = 1.0f;\n\ts_ctx->global_pause = false;\n\ts_ctx->music_volume = 1.0f;\n\ts_ctx->music_pitch = 1.0f;\n\ts_ctx->sound_volume = 1.0f;\n\ts_ctx->music_looped = true;\n\ts_ctx->music_paused = false;\n\ts_ctx->on_finish = NULL;\n\ts_ctx->on_finish_udata = NULL;\n\ts_ctx->on_music_finish = NULL;\n\ts_ctx->on_music_finish_udata = NULL;\n\ts_ctx->t = 0;\n\ts_ctx->fade = 0;\n\ts_ctx->fade_switch_1 = 0;\n\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_NONE;\n\ts_ctx->music_state_to_resume_from_paused = CUTE_SOUND_MUSIC_STATE_NONE;\n\ts_ctx->music_playing = NULL;\n\ts_ctx->music_next = NULL;\n\ts_ctx->audio_sources_to_free_capacity = 32;\n\ts_ctx->audio_sources_to_free_size = 0;\n\ts_ctx->audio_sources_to_free = (cs_audio_source_t**)CUTE_SOUND_ALLOC(sizeof(cs_audio_source_t*) * s_ctx->audio_sources_to_free_capacity, s_mem_ctx);\n\ts_ctx->instance_id_gen = 1;\n\tcs_hashtableinit(&s_ctx->instance_map, sizeof(cs_audio_source_t*), 1024, user_allocator_context);\n\ts_ctx->pages = NULL;\n\tcs_list_init(&s_ctx->playing_sounds);\n\tcs_list_init(&s_ctx->free_sounds);\n\ts_add_page();\n\ts_mem_ctx = user_allocator_context;\n\ts_ctx->latency_samples = buffered_samples;\n\ts_ctx->Hz = play_frequency_in_Hz;\n\ts_ctx->bps = bps;\n\ts_ctx->wide_count = wide_count;\n\ts_ctx->floatA = (cs__m128*)cs_malloc16(sizeof(cs__m128) * wide_count);\n\ts_ctx->floatB = (cs__m128*)cs_malloc16(sizeof(cs__m128) * wide_count);\n\ts_ctx->samples = (cs__m128i*)cs_malloc16(sizeof(cs__m128i) * wide_count);\n\ts_ctx->running = true;\n\ts_ctx->separate_thread = false;\n\ts_ctx->sleep_milliseconds = 0;\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\ts_ctx->last_cursor = 0;\n\ts_ctx->running_index = 0;\n\ts_ctx->buffer_size = buffer_size;\n\ts_ctx->dsound = dsound;\n\ts_ctx->primary = primary_buffer;\n\ts_ctx->secondary = secondary_buffer;\n\tInitializeCriticalSectionAndSpinCount(&s_ctx->critical_section, 0x00000400);\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\n\ts_ctx->index0 = 0;\n\ts_ctx->index1 = 0;\n\ts_ctx->samples_in_circular_buffer = 0;\n\ts_ctx->sample_count = wide_count * 4;\n\ts_ctx->inst = inst;\n\tpthread_mutex_init(&s_ctx->mutex, NULL);\n\n\tinput.inputProc = cs_memcpy_to_coreaudio;\n\tinput.inputProcRefCon = s_ctx;\n\tret = AudioUnitSetProperty(inst, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &input, sizeof(input));\n\tif (ret != noErr) return CUTE_SOUND_ERROR_FAILED_TO_SET_RENDER_CALLBACK; // This leaks memory, oh well.\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tSDL_memset(&wanted, 0, sizeof(wanted));\n\tSDL_memset(&have, 0, sizeof(have));\n\twanted.freq = play_frequency_in_Hz;\n\twanted.format = AUDIO_S16SYS;\n\twanted.channels = 2; /* 1 = mono, 2 = stereo */\n\twanted.samples = buffered_samples;\n\twanted.callback = cs_sdl_audio_callback;\n\twanted.userdata = s_ctx;\n\ts_ctx->index0 = 0;\n\ts_ctx->index1 = 0;\n\ts_ctx->samples_in_circular_buffer = 0;\n\ts_ctx->sample_count = wide_count * 4;\n\ts_ctx->dev = SDL_OpenAudioDevice(NULL, 0, &wanted, &have, 0);\n\tif (s_ctx->dev < 0) return CUTE_SOUND_ERROR_CANT_OPEN_AUDIO_DEVICE; // This leaks memory, oh well.\n\tSDL_PauseAudioDevice(s_ctx->dev, 0);\n\ts_ctx->mutex = SDL_CreateMutex();\n\n#endif\n\ts_ctx->duplicate_capacity = 0;\n\ts_ctx->duplicate_count = 0;\n\ts_ctx->duplicates = NULL;\n\ts_ctx->cull_duplicates = false;\n\treturn CUTE_SOUND_ERROR_NONE;\n}\n\nvoid cs_lock();\nvoid cs_unlock();\n\nvoid cs_shutdown()\n{\n\tif (!s_ctx) return;\n\tif (s_ctx->separate_thread) {\n\t\tcs_lock();\n\t\ts_ctx->running = false;\n\t\tcs_unlock();\n\t\twhile (s_ctx->separate_thread) cs_sleep(1);\n\t}\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tDeleteCriticalSection(&s_ctx->critical_section);\n\tIDirectSoundBuffer_Release(s_ctx->secondary);\n\tIDirectSoundBuffer_Release(s_ctx->primary);\n\tIDirectSoundBuffer_Release(s_ctx->dsound);\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tSDL_DestroyMutex(s_ctx->mutex);\n\tSDL_CloseAudioDevice(s_ctx->dev);\n\n#endif\n\n\tif (!cs_list_empty(&s_ctx->playing_sounds)) {\n\t\tcs_list_node_t* playing_node = cs_list_begin(&s_ctx->playing_sounds);\n\t\tcs_list_node_t* end_node = cs_list_end(&s_ctx->playing_sounds);\n\t\tdo {\n\t\t\tcs_list_node_t* next_node = playing_node->next;\n\t\t\tcs_sound_inst_t* playing = CUTE_SOUND_LIST_HOST(cs_sound_inst_t, node, playing_node);\n\t\t\tcs_audio_source_t* audio = playing->audio;\n\t\t\tif (audio) audio->playing_count = 0;\n\t\t\tplaying_node = next_node;\n\t\t} while (playing_node != end_node);\n\t}\n\n\tcs_inst_page_t* page = s_ctx->pages;\n\twhile (page) {\n\t\tcs_inst_page_t* next = page->next;\n\t\tCUTE_SOUND_FREE(page, s_mem_ctx);\n\t\tpage = next;\n\t}\n\n\tfor (int i = 0; i < s_ctx->audio_sources_to_free_size; ++i) {\n\t\tcs_audio_source_t* audio = s_ctx->audio_sources_to_free[i];\n\t\tcs_free16(audio->channels[0]);\n\t\tCUTE_SOUND_FREE(audio, s_mem_ctx);\n\t}\n\tCUTE_SOUND_FREE(s_ctx->audio_sources_to_free, s_mem_ctx);\n\n\tcs_free16(s_ctx->floatA);\n\tcs_free16(s_ctx->floatB);\n\tcs_free16(s_ctx->samples);\n\tcs_hashtableterm(&s_ctx->instance_map);\n\tCUTE_SOUND_FREE(s_ctx, s_mem_ctx);\n\ts_ctx = NULL;\n}\n\nstatic float s_smoothstep(float x) { return x * x * (3.0f - 2.0f * x); }\n\nvoid cs_update(float dt)\n{\n\tif (!s_ctx->separate_thread) cs_mix();\n\n\tswitch (s_ctx->music_state) {\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_OUT:\n\t{\n\t\ts_ctx->t += dt;\n\t\tif (s_ctx->t >= s_ctx->fade) {\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_NONE;\n\t\t\ts_ctx->music_playing->active = false;\n\t\t\ts_ctx->music_playing = NULL;\n\t\t} else {\n\t\t\ts_ctx->music_playing->volume = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));;\n\t\t}\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_IN:\n\t{\n\t\ts_ctx->t += dt;\n\t\tif (s_ctx->t >= s_ctx->fade) {\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_PLAYING;\n\t\t\ts_ctx->t = s_ctx->fade;\n\t\t}\n\t\ts_ctx->music_playing->volume = s_smoothstep(1.0f - ((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0:\n\t{\n\t\ts_ctx->t += dt;\n\t\tif (s_ctx->t >= s_ctx->fade) {\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_SWITCH_TO_1;\n\t\t\ts_ctx->music_playing->active = false;\n\t\t\ts_ctx->music_playing->volume = 0;\n\t\t\ts_ctx->t = 0;\n\t\t\ts_ctx->fade = s_ctx->fade_switch_1;\n\t\t\ts_ctx->fade_switch_1 = 0;\n\t\t\ts_ctx->music_next->paused = false;\n\t\t} else {\n\t\t\ts_ctx->music_playing->volume = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));;\n\t\t}\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_1:\n\t{\n\t\ts_ctx->t += dt;\n\t\tif (s_ctx->t >= s_ctx->fade) {\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_PLAYING;\n\t\t\ts_ctx->t = s_ctx->fade;\n\t\t\ts_ctx->music_next->volume = 1.0f;\n\t\t\ts_ctx->music_playing = s_ctx->music_next;\n\t\t\ts_ctx->music_next = NULL;\n\t\t} else {\n\t\t\tfloat t = s_smoothstep(1.0f - ((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\tfloat volume = t;\n\t\t\ts_ctx->music_next->volume = volume;\n\t\t}\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_CROSSFADE:\n\t{\n\t\ts_ctx->t += dt;\n\t\tif (s_ctx->t >= s_ctx->fade) {\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_PLAYING;\n\t\t\ts_ctx->music_playing->active = false;\n\t\t\ts_ctx->music_next->volume = 1.0f;\n\t\t\ts_ctx->music_playing = s_ctx->music_next;\n\t\t\ts_ctx->music_next = NULL;\n\t\t} else {\n\t\t\tfloat t0 = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\tfloat t1 = s_smoothstep(1.0f - ((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\tfloat v0 = t0;\n\t\t\tfloat v1 = t1;\n\t\t\ts_ctx->music_playing->volume = v0;\n\t\t\ts_ctx->music_next->volume = v1;\n\t\t}\n\t}\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid cs_set_global_volume(float volume_0_to_1)\n{\n\tif (volume_0_to_1 < 0) volume_0_to_1 = 0;\n\ts_ctx->global_volume = volume_0_to_1;\n}\n\nvoid cs_set_global_pan(float pan_0_to_1)\n{\n\tif (pan_0_to_1 < 0) pan_0_to_1 = 0;\n\tif (pan_0_to_1 > 1) pan_0_to_1 = 1;\n\ts_ctx->global_pan = pan_0_to_1;\n}\n\nvoid cs_set_global_pause(bool true_for_paused)\n{\n\ts_ctx->global_pause = true_for_paused;\n}\n\nvoid cs_lock()\n{\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\tEnterCriticalSection(&s_ctx->critical_section);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\tpthread_mutex_lock(&s_ctx->mutex);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\tSDL_LockMutex(s_ctx->mutex);\n#endif\n}\n\nvoid cs_unlock()\n{\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\tLeaveCriticalSection(&s_ctx->critical_section);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\tpthread_mutex_unlock(&s_ctx->mutex);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\tSDL_UnlockMutex(s_ctx->mutex);\n#endif\n}\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\nstatic void cs_dsound_get_bytes_to_fill(int* byte_to_lock, int* bytes_to_write)\n{\n\tDWORD play_cursor;\n\tDWORD write_cursor;\n\tDWORD lock;\n\tDWORD target_cursor;\n\tDWORD write;\n\tDWORD status;\n\n\tHRESULT hr = IDirectSoundBuffer_GetCurrentPosition(s_ctx->secondary, &play_cursor, &write_cursor);\n\tif (hr != DS_OK) {\n\t\tif (hr == DSERR_BUFFERLOST) {\n\t\t\thr = IDirectSoundBuffer_Restore(s_ctx->secondary);\n\t\t}\n\t\t*byte_to_lock = write_cursor;\n\t\t*bytes_to_write = s_ctx->latency_samples * s_ctx->bps;\n\t\tif (!SUCCEEDED(hr)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\ts_ctx->last_cursor = write_cursor;\n\n\tIDirectSoundBuffer_GetStatus(s_ctx->secondary, &status);\n\tif (!(status & DSBSTATUS_PLAYING)) {\n\t\thr = IDirectSoundBuffer_Play(s_ctx->secondary, 0, 0, DSBPLAY_LOOPING);\n\t\tif (!SUCCEEDED(hr)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlock = (s_ctx->running_index * s_ctx->bps) % s_ctx->buffer_size;\n\ttarget_cursor = (write_cursor + s_ctx->latency_samples * s_ctx->bps);\n\tif (target_cursor > (DWORD)s_ctx->buffer_size) target_cursor %= s_ctx->buffer_size;\n\ttarget_cursor = (DWORD)CUTE_SOUND_TRUNC(target_cursor, 16);\n\n\tif (lock > target_cursor) {\n\t\twrite = (s_ctx->buffer_size - lock) + target_cursor;\n\t} else {\n\t\twrite = target_cursor - lock;\n\t}\n\n\t*byte_to_lock = lock;\n\t*bytes_to_write = write;\n}\n\nstatic void cs_dsound_memcpy_to_driver(int16_t* samples, int byte_to_lock, int bytes_to_write)\n{\n\t// copy mixer buffers to direct sound\n\tvoid* region1;\n\tDWORD size1;\n\tvoid* region2;\n\tDWORD size2;\n\tHRESULT hr = IDirectSoundBuffer_Lock(s_ctx->secondary, byte_to_lock, bytes_to_write, &region1, &size1, &region2, &size2, 0);\n\tif (hr == DSERR_BUFFERLOST) {\n\t\tIDirectSoundBuffer_Restore(s_ctx->secondary);\n\t\thr = IDirectSoundBuffer_Lock(s_ctx->secondary, byte_to_lock, bytes_to_write, &region1, &size1, &region2, &size2, 0);\n\t}\n\tif (!SUCCEEDED(hr)) {\n\t\treturn;\n\t}\n\n\tunsigned running_index = s_ctx->running_index;\n\tINT16* sample1 = (INT16*)region1;\n\tDWORD sample1_count = size1 / s_ctx->bps;\n\tCUTE_SOUND_MEMCPY(sample1, samples, sample1_count * sizeof(INT16) * 2);\n\tsamples += sample1_count * 2;\n\trunning_index += sample1_count;\n\n\tINT16* sample2 = (INT16*)region2;\n\tDWORD sample2_count = size2 / s_ctx->bps;\n\tCUTE_SOUND_MEMCPY(sample2, samples, sample2_count * sizeof(INT16) * 2);\n\tsamples += sample2_count * 2;\n\trunning_index += sample2_count;\n\n\tIDirectSoundBuffer_Unlock(s_ctx->secondary, region1, size1, region2, size2);\n\ts_ctx->running_index = running_index;\n}\n\nvoid cs_dsound_dont_run_too_fast()\n{\n\tDWORD status;\n\tDWORD cursor;\n\tDWORD junk;\n\tHRESULT hr;\n\n\thr = IDirectSoundBuffer_GetCurrentPosition(s_ctx->secondary, &junk, &cursor);\n\tif (hr != DS_OK) {\n\t\tif (hr == DSERR_BUFFERLOST) {\n\t\t\tIDirectSoundBuffer_Restore(s_ctx->secondary);\n\t\t}\n\t\treturn;\n\t}\n\n\t// Prevent mixing thread from sending samples too quickly.\n\twhile (cursor == s_ctx->last_cursor) {\n\t\tcs_sleep(1);\n\n\t\tIDirectSoundBuffer_GetStatus(s_ctx->secondary, &status);\n\t\tif ((status & DSBSTATUS_BUFFERLOST)) {\n\t\t\tIDirectSoundBuffer_Restore(s_ctx->secondary);\n\t\t\tIDirectSoundBuffer_GetStatus(s_ctx->secondary, &status);\n\t\t\tif ((status & DSBSTATUS_BUFFERLOST)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thr = IDirectSoundBuffer_GetCurrentPosition(s_ctx->secondary, &junk, &cursor);\n\t\tif (hr != DS_OK) {\n\t\t\t// Eek! Not much to do here I guess.\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#endif // CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\nvoid cs_mix()\n{\n\tcs__m128i* samples;\n\tcs__m128* floatA;\n\tcs__m128* floatB;\n\tint samples_needed;\n\tint write_offset = 0;\n\n\tcs_lock();\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tint byte_to_lock;\n\tint bytes_to_write;\n\tcs_dsound_get_bytes_to_fill(&byte_to_lock, &bytes_to_write);\n\n\tif (bytes_to_write < (int)s_ctx->latency_samples) goto unlock;\n\tsamples_needed = bytes_to_write / s_ctx->bps;\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE || CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\tint bytes_to_write;\n\tsamples_needed = cs_samples_to_mix();\n\tif (!samples_needed) goto unlock;\n\tbytes_to_write = samples_needed * s_ctx->bps;\n\n#endif\n\n\t// Clear mixer buffers.\n\tfloatA = s_ctx->floatA;\n\tfloatB = s_ctx->floatB;\n\tCUTE_SOUND_MEMSET(floatA, 0, sizeof(cs__m128) * s_ctx->wide_count);\n\tCUTE_SOUND_MEMSET(floatB, 0, sizeof(cs__m128) * s_ctx->wide_count);\n\n\t// Mix all playing sounds into the mixer buffers.\n\tif (!s_ctx->global_pause && !cs_list_empty(&s_ctx->playing_sounds)) {\n\t\tcs_list_node_t* playing_node = cs_list_begin(&s_ctx->playing_sounds);\n\t\tcs_list_node_t* end_node = cs_list_end(&s_ctx->playing_sounds);\n\t\tdo {\n\t\t\tcs_list_node_t* next_node = playing_node->next;\n\t\t\tcs_sound_inst_t* playing = CUTE_SOUND_LIST_HOST(cs_sound_inst_t, node, playing_node);\n\t\t\tcs_audio_source_t* audio = playing->audio;\n\n\t\t\tif (!audio) goto remove;\n\t\t\tif (!playing->active || !s_ctx->running) goto remove;\n\t\t\tif (playing->paused || playing->pitch==0.0f) goto get_next_playing_sound;\n\t\t\tif (s_ctx->cull_duplicates) {\n\t\t\t\tfor (int i = 0; i < s_ctx->duplicate_count; ++i) {\n\t\t\t\t\tif (s_ctx->duplicates[i] == (void*)audio) {\n\t\t\t\t\t\tgoto remove;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s_ctx->duplicate_count == s_ctx->duplicate_capacity) {\n\t\t\t\t\tint new_capacity = s_ctx->duplicate_capacity ? s_ctx->duplicate_capacity * 2 : 1024;\n\t\t\t\t\tvoid* duplicates = CUTE_SOUND_ALLOC(sizeof(void*) * new_capacity, s_ctx->mem_ctx);\n\t\t\t\t\tCUTE_SOUND_MEMCPY(duplicates, s_ctx->duplicates, sizeof(void*) * s_ctx->duplicate_count);\n\t\t\t\t\tCUTE_SOUND_FREE(s_ctx->duplicates, s_ctx->mem_ctx);\n\t\t\t\t\ts_ctx->duplicates = (void**)duplicates;\n\t\t\t\t\ts_ctx->duplicate_capacity = new_capacity;\n\t\t\t\t}\n\t\t\t\ts_ctx->duplicates[s_ctx->duplicate_count++] = (void*)audio;\n\t\t\t}\n\n\t\t\t// Jump here for looping sounds if we need to wrap-around the audio source\n\t\t\t// and continue mixing more samples.\n\t\t\tmix_more:\n\n\t\t\t{\n\t\t\t\tcs__m128* cA = (cs__m128*)audio->channels[0];\n\t\t\t\tcs__m128* cB = (cs__m128*)audio->channels[1];\n\n\t\t\t\t// Attempted to play a sound with no audio.\n\t\t\t\t// Make sure the audio file was loaded properly.\n\t\t\t\tCUTE_SOUND_ASSERT(cA);\n\n\t\t\t\tfloat gpan0 = 1.0f - s_ctx->global_pan;\n\t\t\t\tfloat gpan1 = s_ctx->global_pan;\n\t\t\t\tfloat vA0 = playing->volume * playing->pan0 * gpan0 * s_ctx->global_volume;\n\t\t\t\tfloat vB0 = playing->volume * playing->pan1 * gpan1 * s_ctx->global_volume;\n\t\t\t\tif (!playing->is_music) {\n\t\t\t\t\tvA0 *= s_ctx->sound_volume;\n\t\t\t\t\tvB0 *= s_ctx->sound_volume;\n\t\t\t\t} else {\n\t\t\t\t\tvA0 *= s_ctx->music_volume;\n\t\t\t\t\tvB0 *= s_ctx->music_volume;\n\t\t\t\t}\n\t\t\t\tcs__m128 vA = cs_mm_set1_ps(vA0);\n\t\t\t\tcs__m128 vB = cs_mm_set1_ps(vB0);\n\n\t\t\t\tint prev_playing_sample_index = playing->sample_index;\n\t\t\t\tint samples_to_read = (int)(samples_needed * playing->pitch);\n\t\t\t\tif (samples_to_read + playing->sample_index > audio->sample_count) {\n\t\t\t\t\tsamples_to_read = audio->sample_count - playing->sample_index;\n\t\t\t\t} else if (samples_to_read + playing->sample_index < 0) {\n\t\t\t\t\t// When pitch shifting is negative, samples_to_read is also negative so that offset needs to\n\t\t\t\t\t// be accounted for otherwise the sample index cursor gets stuck at sample count.\n\t\t\t\t\tplaying->sample_index = audio->sample_count + samples_to_read + playing->sample_index;\n\t\t\t\t}\n\t\t\t\tint sample_index_wide = (int)CUTE_SOUND_TRUNC(playing->sample_index, 4) / 4;\n\t\t\t\tint samples_to_write = (int)(samples_to_read / playing->pitch);\n\t\t\t\tint write_wide = CUTE_SOUND_ALIGN(samples_to_write, 4) / 4;\n\t\t\t\tint write_offset_wide = (int)CUTE_SOUND_ALIGN(write_offset, 4) / 4;\n\t\t\t\tstatic int written_so_far = 0;\n\t\t\t\twritten_so_far += samples_to_read;\n\n\t\t\t\t// Do the actual mixing: Apply volume, load samples into float buffers.\n\t\t\t\tif (playing->pitch != 1.0f) {\n\t\t\t\t\t// Pitch shifting -- We read in samples at a resampled rate (multiply by pitch). These samples\n\t\t\t\t\t// are read in one at a time in scalar mode, but then mixed together via SIMD.\n\t\t\t\t\tcs__m128 pitch = cs_mm_set1_ps(playing->pitch);\n\t\t\t\t\tcs__m128 index_offset = cs_mm_set1_ps((float)playing->sample_index);\n\t\t\t\t\tswitch (audio->channel_count) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0, j = 0; i < write_wide; ++i, j += 4) {\n\t\t\t\t\t\t\tcs__m128 index = cs_mm_set_ps((float)j + 3, (float)j + 2, (float)j + 1, (float)j);\n\t\t\t\t\t\t\tindex = cs_mm_add_ps(cs_mm_mul_ps(index, pitch), index_offset);\n\t\t\t\t\t\t\tcs__m128i index_int = cs_mm_cvttps_epi32(index);\n\t\t\t\t\t\t\tcs__m128 index_frac = cs_mm_sub_ps(index, cs_mm_cvtepi32_ps(index_int));\n\t\t\t\t\t\t\tint i0 = cs_mm_extract_epi32(index_int, 3);\n\t\t\t\t\t\t\tint i1 = cs_mm_extract_epi32(index_int, 2);\n\t\t\t\t\t\t\tint i2 = cs_mm_extract_epi32(index_int, 1);\n\t\t\t\t\t\t\tint i3 = cs_mm_extract_epi32(index_int, 0);\n\n\t\t\t\t\t\t\tcs__m128 loA = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 > audio->sample_count ? 0 : i0 < 0 ? audio->sample_count : ((float*)cA)[i0],\n\t\t\t\t\t\t\t\ti1 > audio->sample_count ? 0 : i1 < 0 ? audio->sample_count : ((float*)cA)[i1],\n\t\t\t\t\t\t\t\ti2 > audio->sample_count ? 0 : i2 < 0 ? audio->sample_count : ((float*)cA)[i2],\n\t\t\t\t\t\t\t\ti3 > audio->sample_count ? 0 : i3 < 0 ? audio->sample_count : ((float*)cA)[i3]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcs__m128 hiA = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 + 1 > audio->sample_count ? 0 : i0 + 1 < 0 ? audio->sample_count : ((float*)cA)[i0 + 1],\n\t\t\t\t\t\t\t\ti1 + 1 > audio->sample_count ? 0 : i1 + 1 < 0 ? audio->sample_count : ((float*)cA)[i1 + 1],\n\t\t\t\t\t\t\t\ti2 + 1 > audio->sample_count ? 0 : i2 + 1 < 0 ? audio->sample_count : ((float*)cA)[i2 + 1],\n\t\t\t\t\t\t\t\ti3 + 1 > audio->sample_count ? 0 : i3 + 1 < 0 ? audio->sample_count : ((float*)cA)[i3 + 1]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcs__m128 A = cs_mm_add_ps(loA, cs_mm_mul_ps(index_frac, cs_mm_sub_ps(hiA, loA)));\n\t\t\t\t\t\t\tcs__m128 B = cs_mm_mul_ps(A, vB);\n\t\t\t\t\t\t\tA = cs_mm_mul_ps(A, vA);\n\t\t\t\t\t\t\tfloatA[i + write_offset_wide] = cs_mm_add_ps(floatA[i + write_offset_wide], A);\n\t\t\t\t\t\t\tfloatB[i + write_offset_wide] = cs_mm_add_ps(floatB[i + write_offset_wide], B);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0, j = 0; i < write_wide; ++i, j += 4) {\n\t\t\t\t\t\t\tcs__m128 index = cs_mm_set_ps((float)j + 3, (float)j + 2, (float)j + 1, (float)j);\n\t\t\t\t\t\t\tindex = cs_mm_add_ps(cs_mm_mul_ps(index, pitch), index_offset);\n\t\t\t\t\t\t\tcs__m128i index_int = cs_mm_cvttps_epi32(index);\n\t\t\t\t\t\t\tcs__m128 index_frac = cs_mm_sub_ps(index, cs_mm_cvtepi32_ps(index_int));\n\t\t\t\t\t\t\tint i0 = cs_mm_extract_epi32(index_int, 3);\n\t\t\t\t\t\t\tint i1 = cs_mm_extract_epi32(index_int, 2);\n\t\t\t\t\t\t\tint i2 = cs_mm_extract_epi32(index_int, 1);\n\t\t\t\t\t\t\tint i3 = cs_mm_extract_epi32(index_int, 0);\n\n\t\t\t\t\t\t\tcs__m128 loA = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 > audio->sample_count ? 0 : i0 < 0 ? audio->sample_count : ((float*)cA)[i0],\n\t\t\t\t\t\t\t\ti1 > audio->sample_count ? 0 : i1 < 0 ? audio->sample_count : ((float*)cA)[i1],\n\t\t\t\t\t\t\t\ti2 > audio->sample_count ? 0 : i2 < 0 ? audio->sample_count : ((float*)cA)[i2],\n\t\t\t\t\t\t\t\ti3 > audio->sample_count ? 0 : i3 < 0 ? audio->sample_count : ((float*)cA)[i3]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcs__m128 hiA = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 + 1 > audio->sample_count ? 0 : i0 + 1 < 0 ? audio->sample_count : ((float*)cA)[i0 + 1],\n\t\t\t\t\t\t\t\ti1 + 1 > audio->sample_count ? 0 : i1 + 1 < 0 ? audio->sample_count : ((float*)cA)[i1 + 1],\n\t\t\t\t\t\t\t\ti2 + 1 > audio->sample_count ? 0 : i2 + 1 < 0 ? audio->sample_count : ((float*)cA)[i2 + 1],\n\t\t\t\t\t\t\t\ti3 + 1 > audio->sample_count ? 0 : i3 + 1 < 0 ? audio->sample_count : ((float*)cA)[i3 + 1]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcs__m128 loB = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 > audio->sample_count ? 0 : i0 < 0 ? audio->sample_count : ((float*)cB)[i0],\n\t\t\t\t\t\t\t\ti1 > audio->sample_count ? 0 : i1 < 0 ? audio->sample_count : ((float*)cB)[i1],\n\t\t\t\t\t\t\t\ti2 > audio->sample_count ? 0 : i2 < 0 ? audio->sample_count : ((float*)cB)[i2],\n\t\t\t\t\t\t\t\ti3 > audio->sample_count ? 0 : i3 < 0 ? audio->sample_count : ((float*)cB)[i3]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcs__m128 hiB = cs_mm_set_ps(\n\t\t\t\t\t\t\t\ti0 + 1 > audio->sample_count ? 0 : i0 + 1 < 0 ? audio->sample_count : ((float*)cB)[i0 + 1],\n\t\t\t\t\t\t\t\ti1 + 1 > audio->sample_count ? 0 : i1 + 1 < 0 ? audio->sample_count : ((float*)cB)[i1 + 1],\n\t\t\t\t\t\t\t\ti2 + 1 > audio->sample_count ? 0 : i2 + 1 < 0 ? audio->sample_count : ((float*)cB)[i2 + 1],\n\t\t\t\t\t\t\t\ti3 + 1 > audio->sample_count ? 0 : i3 + 1 < 0 ? audio->sample_count : ((float*)cB)[i3 + 1]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcs__m128 A = cs_mm_add_ps(loA, cs_mm_mul_ps(index_frac, cs_mm_sub_ps(hiA, loA)));\n\t\t\t\t\t\t\tcs__m128 B = cs_mm_add_ps(loB, cs_mm_mul_ps(index_frac, cs_mm_sub_ps(hiB, loB)));\n\n\t\t\t\t\t\t\tA = cs_mm_mul_ps(A, vA);\n\t\t\t\t\t\t\tB = cs_mm_mul_ps(B, vB);\n\t\t\t\t\t\t\tfloatA[i + write_offset_wide] = cs_mm_add_ps(floatA[i + write_offset_wide], A);\n\t\t\t\t\t\t\tfloatB[i + write_offset_wide] = cs_mm_add_ps(floatB[i + write_offset_wide], B);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No pitch shifting, just add samples together.\n\t\t\t\t\tswitch (audio->channel_count) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i < write_wide; ++i) {\n\t\t\t\t\t\t\tcs__m128 A = cA[i + sample_index_wide];\n\t\t\t\t\t\t\tcs__m128 B = cs_mm_mul_ps(A, vB);\n\t\t\t\t\t\t\tA = cs_mm_mul_ps(A, vA);\n\t\t\t\t\t\t\tfloatA[i + write_offset_wide] = cs_mm_add_ps(floatA[i + write_offset_wide], A);\n\t\t\t\t\t\t\tfloatB[i + write_offset_wide] = cs_mm_add_ps(floatB[i + write_offset_wide], B);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i < write_wide; ++i) {\n\t\t\t\t\t\t\tcs__m128 A = cA[i + sample_index_wide];\n\t\t\t\t\t\t\tcs__m128 B = cB[i + sample_index_wide];\n\n\t\t\t\t\t\t\tA = cs_mm_mul_ps(A, vA);\n\t\t\t\t\t\t\tB = cs_mm_mul_ps(B, vB);\n\t\t\t\t\t\t\tfloatA[i + write_offset_wide] = cs_mm_add_ps(floatA[i + write_offset_wide], A);\n\t\t\t\t\t\t\tfloatB[i + write_offset_wide] = cs_mm_add_ps(floatB[i + write_offset_wide], B);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// playing list logic\n\t\t\t\tplaying->sample_index += samples_to_read;\n\t\t\t\tCUTE_SOUND_ASSERT(playing->sample_index <= audio->sample_count);\n\t\t\t\tif (playing->pitch < 0) {\n\t\t\t\t\t// When pitch shifting is negative adjust the timing a bit further back from sample count to avoid any clipping.\n\t\t\t\t\tif (prev_playing_sample_index - playing->sample_index < 0) {\n\t\t\t\t\t\tif (playing->looped) {\n\t\t\t\t\t\t\tplaying->sample_index = audio->sample_count - samples_needed;\n\t\t\t\t\t\t\twrite_offset += samples_to_write;\n\t\t\t\t\t\t\tsamples_needed -= samples_to_write;\n\t\t\t\t\t\t\tCUTE_SOUND_ASSERT(samples_needed >= 0);\n\t\t\t\t\t\t\tif (samples_needed == 0) break;\n\t\t\t\t\t\t\tgoto mix_more;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgoto remove;\n\t\t\t\t\t}\n\t\t\t\t} else if (playing->sample_index == audio->sample_count) {\n\t\t\t\t\tif (playing->looped) {\n\t\t\t\t\t\tplaying->sample_index = 0;\n\t\t\t\t\t\twrite_offset += samples_to_write;\n\t\t\t\t\t\tsamples_needed -= samples_to_write;\n\t\t\t\t\t\tCUTE_SOUND_ASSERT(samples_needed >= 0);\n\t\t\t\t\t\tif (samples_needed == 0) break;\n\t\t\t\t\t\tgoto mix_more;\n\t\t\t\t\t}\n\n\t\t\t\t\tgoto remove;\n\t\t\t\t}\n\t\t\t}\n\n\t\tget_next_playing_sound:\n\t\t\tplaying_node = next_node;\n\t\t\twrite_offset = 0;\n\t\t\tcontinue;\n\n\t\tremove:\n\t\t\tplaying->sample_index = 0;\n\t\t\tplaying->active = false;\n\n\t\t\tif (playing->audio) {\n\t\t\t\tif (s_ctx->running) {\n\t\t\t\t\tplaying->audio->playing_count -= 1;\n\t\t\t\t} else {\n\t\t\t\t\tplaying->audio->playing_count = 0;\n\t\t\t\t}\n\t\t\t\tCUTE_SOUND_ASSERT(playing->audio->playing_count >= 0);\n\t\t\t}\n\n\t\t\tcs_list_remove(playing_node);\n\t\t\tcs_list_push_front(&s_ctx->free_sounds, playing_node);\n\t\t\tcs_hashtableremove(&s_ctx->instance_map, playing->id);\n\t\t\tplaying_node = next_node;\n\t\t\twrite_offset = 0;\n\t\t\tif (s_ctx->on_finish && !playing->is_music) {\n\t\t\t\tcs_playing_sound_t snd = { playing->id };\n\t\t\t\ts_ctx->on_finish(snd, s_ctx->on_finish_udata);\n\t\t\t} else if (s_ctx->on_music_finish && playing->is_music) {\n\t\t\t\ts_ctx->on_music_finish(s_ctx->on_music_finish_udata);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} while (playing_node != end_node);\n\t}\n\n\ts_ctx->duplicate_count = 0;\n\n\t// load all floats into 16 bit packed interleaved samples\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\n\tsamples = s_ctx->samples;\n\tfor (int i = 0; i < s_ctx->wide_count; ++i) {\n\t\tcs__m128i a = cs_mm_cvtps_epi32(floatA[i]);\n\t\tcs__m128i b = cs_mm_cvtps_epi32(floatB[i]);\n\t\tcs__m128i a0b0a1b1 = cs_mm_unpacklo_epi32(a, b);\n\t\tcs__m128i a2b2a3b3 = cs_mm_unpackhi_epi32(a, b);\n\t\tsamples[i] = cs_mm_packs_epi32(a0b0a1b1, a2b2a3b3);\n\t}\n\tcs_dsound_memcpy_to_driver((int16_t*)samples, byte_to_lock, bytes_to_write);\n\tcs_dsound_dont_run_too_fast();\n\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE || CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\n\t// Since the ctx->samples array is already in use as a ring buffer\n\t// reusing floatA to store output is a good way to temporarly store\n\t// the final samples. Then a single ring buffer push can be used\n\t// afterwards. Pretty hacky, but whatever :)\n\tsamples = (cs__m128i*)floatA;\n\tfor (int i = 0; i < s_ctx->wide_count; ++i) {\n\t\tcs__m128i a = cs_mm_cvtps_epi32(floatA[i]);\n\t\tcs__m128i b = cs_mm_cvtps_epi32(floatB[i]);\n\t\tcs__m128i a0b0a1b1 = cs_mm_unpacklo_epi32(a, b);\n\t\tcs__m128i a2b2a3b3 = cs_mm_unpackhi_epi32(a, b);\n\t\tsamples[i] = cs_mm_packs_epi32(a0b0a1b1, a2b2a3b3);\n\t}\n\n\tcs_push_bytes(samples, bytes_to_write);\n\n#endif\n\n\t// Free up any queue'd free's for audio sources at zero refcount.\n\tfor (int i = 0; i < s_ctx->audio_sources_to_free_size;) {\n\t\tcs_audio_source_t* audio = s_ctx->audio_sources_to_free[i];\n\t\tif (audio->playing_count == 0) {\n\t\t\tcs_free16(audio->channels[0]);\n\t\t\tCUTE_SOUND_FREE(audio, s_mem_ctx);\n\t\t\ts_ctx->audio_sources_to_free[i] = s_ctx->audio_sources_to_free[--s_ctx->audio_sources_to_free_size];\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t}\n\n\tunlock:\n\tcs_unlock();\n}\n\nvoid cs_spawn_mix_thread()\n{\n\tif (s_ctx->separate_thread) return;\n\ts_ctx->separate_thread = true;\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_WINDOWS\n\tCreateThread(0, 0, cs_ctx_thread, s_ctx, 0, 0);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_APPLE\n\tpthread_create(&s_ctx->thread, 0, cs_ctx_thread, s_ctx);\n#elif CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL\n\ts_ctx->thread = SDL_CreateThread(&cs_ctx_thread, \"CuteSoundThread\", s_ctx);\n#endif\n}\n\nvoid cs_mix_thread_sleep_delay(int milliseconds)\n{\n\ts_ctx->sleep_milliseconds = milliseconds;\n}\n\nvoid* cs_get_context_ptr()\n{\n\treturn (void*)s_ctx;\n}\n\nvoid cs_set_context_ptr(void* ctx)\n{\n\ts_ctx = (cs_context_t*)ctx;\n}\n\n// -------------------------------------------------------------------------------------------------\n// Loaded sounds.\n\nstatic void* cs_read_file_to_memory(const char* path, int* size)\n{\n\tvoid* data = 0;\n\tCUTE_SOUND_FILE* fp = CUTE_SOUND_FOPEN(path, \"rb\");\n\tint sizeNum = 0;\n\n\tif (fp) {\n\t\tCUTE_SOUND_FSEEK(fp, 0, CUTE_SOUND_SEEK_END);\n\t\tsizeNum = (int)CUTE_SOUND_FTELL(fp);\n\t\tCUTE_SOUND_FSEEK(fp, 0, CUTE_SOUND_SEEK_SET);\n\t\tdata = CUTE_SOUND_ALLOC(sizeNum, s_mem_ctx);\n\t\tCUTE_SOUND_FREAD(data, sizeNum, 1, fp);\n\t\tCUTE_SOUND_FCLOSE(fp);\n\t}\n\n\tif (size) *size = sizeNum;\n\treturn data;\n}\n\nstatic int cs_four_cc(const char* CC, void* memory)\n{\n\tif (!CUTE_SOUND_MEMCMP(CC, memory, 4)) return 1;\n\treturn 0;\n}\n\nstatic char* cs_next(char* data)\n{\n\tuint32_t size = *(uint32_t*)(data + 4);\n\tsize = (size + 1) & ~1;\n\treturn data + 8 + size;\n}\n\nstatic void cs_last_element(cs__m128* a, int i, int j, int16_t* samples, int offset)\n{\n\tswitch (offset) {\n\tcase 1:\n\t\ta[i] = cs_mm_set_ps(samples[j], 0.0f, 0.0f, 0.0f);\n\t\tbreak;\n\n\tcase 2:\n\t\ta[i] = cs_mm_set_ps(samples[j], samples[j + 1], 0.0f, 0.0f);\n\t\tbreak;\n\n\tcase 3:\n\t\ta[i] = cs_mm_set_ps(samples[j], samples[j + 1], samples[j + 2], 0.0f);\n\t\tbreak;\n\n\tcase 0:\n\t\ta[i] = cs_mm_set_ps(samples[j], samples[j + 1], samples[j + 2], samples[j + 3]);\n\t\tbreak;\n\t}\n}\n\ncs_audio_source_t* cs_load_wav(const char* path, cs_error_t* err /* = NULL */)\n{\n\tint size;\n\tvoid* wav = cs_read_file_to_memory(path, &size);\n\tif (!wav) return NULL;\n\tcs_audio_source_t* audio = cs_read_mem_wav(wav, size, err);\n\tCUTE_SOUND_FREE(wav, s_mem_ctx);\n\treturn audio;\n}\n\ncs_audio_source_t* cs_read_mem_wav(const void* memory, size_t size, cs_error_t* err)\n{\n\tif (err) *err = CUTE_SOUND_ERROR_NONE;\n\tif (!memory) { if (err) *err = CUTE_SOUND_ERROR_FILE_NOT_FOUND; return NULL; }\n\n\t#pragma pack(push, 1)\n\ttypedef struct\n\t{\n\t\tuint16_t wFormatTag;\n\t\tuint16_t nChannels;\n\t\tuint32_t nSamplesPerSec;\n\t\tuint32_t nAvgBytesPerSec;\n\t\tuint16_t nBlockAlign;\n\t\tuint16_t wBitsPerSample;\n\t\tuint16_t cbSize;\n\t\tuint16_t wValidBitsPerSample;\n\t\tuint32_t dwChannelMask;\n\t\tuint8_t SubFormat[18];\n\t} Fmt;\n\t#pragma pack(pop)\n\n\tcs_audio_source_t* audio = NULL;\n\tchar* data = (char*)memory;\n\tchar* end = data + size;\n\tif (!cs_four_cc(\"RIFF\", data)) { if (err) *err = CUTE_SOUND_ERROR_THE_FILE_IS_NOT_A_WAV_FILE; return NULL; }\n\tif (!cs_four_cc(\"WAVE\", data + 8)) { if (err) *err = CUTE_SOUND_ERROR_THE_FILE_IS_NOT_A_WAV_FILE; return NULL; }\n\n\tdata += 12;\n\n\twhile (1) {\n\t\tif (!(end > data)) { if (err) *err = CUTE_SOUND_ERROR_WAV_FILE_FORMAT_CHUNK_NOT_FOUND; return NULL; }\n\t\tif (cs_four_cc(\"fmt \", data)) break;\n\t\tdata = cs_next(data);\n\t}\n\n\tFmt fmt;\n\tfmt = *(Fmt*)(data + 8);\n\tif (fmt.wFormatTag != 1) { if (err) *err = CUTE_SOUND_ERROR_WAV_FILE_FORMAT_CHUNK_NOT_FOUND; return NULL; }\n\tif (!(fmt.nChannels == 1 || fmt.nChannels == 2)) { if (err) *err = CUTE_SOUND_ERROR_WAV_ONLY_MONO_OR_STEREO_IS_SUPPORTED; return NULL; }\n\tif (!(fmt.wBitsPerSample == 16)) { if (err) *err = CUTE_SOUND_ERROR_WAV_ONLY_16_BITS_PER_SAMPLE_SUPPORTED; return NULL; }\n\tif (!(fmt.nBlockAlign == fmt.nChannels * 2)) { if (err) *err = CUTE_SOUND_ERROR_IMPLEMENTATION_ERROR_PLEASE_REPORT_THIS_ON_GITHUB; return NULL; }\n\n\twhile (1) {\n\t\tif (!(end > data)) { if (err) *err = CUTE_SOUND_ERROR_WAV_DATA_CHUNK_NOT_FOUND; return NULL; }\n\t\tif (cs_four_cc(\"data\", data)) break;\n\t\tdata = cs_next(data);\n\t}\n\n\taudio = (cs_audio_source_t*)CUTE_SOUND_ALLOC(sizeof(cs_audio_source_t), s_mem_ctx);\n\tCUTE_SOUND_MEMSET(audio, 0, sizeof(*audio));\n\taudio->sample_rate = (int)fmt.nSamplesPerSec;\n\n\t{\n\t\tint sample_size = *((uint32_t*)(data + 4));\n\t\tint sample_count = sample_size / (fmt.nChannels * sizeof(uint16_t));\n\t\t//to account for interpolation in the pitch shifter, we lie about length\n\t\t//this fixes random popping at the end of sounds\n\t\taudio->sample_count = sample_count-1;\n\t\taudio->channel_count = fmt.nChannels;\n\n\t\tint wide_count = (int)CUTE_SOUND_ALIGN(sample_count, 4) / 4;\n\t\tint wide_offset = sample_count & 3;\n\t\tint16_t* samples = (int16_t*)(data + 8);\n\n\t\tswitch (audio->channel_count) {\n\t\tcase 1:\n\t\t{\n\t\t\taudio->channels[0] = cs_malloc16(wide_count * sizeof(cs__m128));\n\t\t\taudio->channels[1] = 0;\n\t\t\tcs__m128* a = (cs__m128*)audio->channels[0];\n\t\t\tfor (int i = 0, j = 0; i < wide_count - 1; ++i, j += 4) {\n\t\t\t\ta[i] = cs_mm_set_ps((float)samples[j+3], (float)samples[j+2], (float)samples[j+1], (float)samples[j]);\n\t\t\t}\n\t\t\tcs_last_element(a, wide_count - 1, (wide_count - 1) * 4, samples, wide_offset);\n\t\t}\tbreak;\n\n\t\tcase 2:\n\t\t{\n\t\t\tcs__m128* a = (cs__m128*)cs_malloc16(wide_count * sizeof(cs__m128) * 2);\n\t\t\tcs__m128* b = a + wide_count;\n\t\t\tfor (int i = 0, j = 0; i < wide_count - 1; ++i, j += 8){\n\t\t\t\ta[i] = cs_mm_set_ps((float)samples[j+6], (float)samples[j+4], (float)samples[j+2], (float)samples[j]);\n\t\t\t\tb[i] = cs_mm_set_ps((float)samples[j+7], (float)samples[j+5], (float)samples[j+3], (float)samples[j+1]);\n\t\t\t}\n\t\t\tcs_last_element(a, wide_count - 1, (wide_count - 1) * 4, samples, wide_offset);\n\t\t\tcs_last_element(b, wide_count - 1, (wide_count - 1) * 4 + 4, samples, wide_offset);\n\t\t\taudio->channels[0] = a;\n\t\t\taudio->channels[1] = b;\n\t\t}\tbreak;\n\n\t\tdefault:\n\t\t\tif (err) *err = CUTE_SOUND_ERROR_WAV_ONLY_MONO_OR_STEREO_IS_SUPPORTED;\n\t\t\tCUTE_SOUND_ASSERT(false);\n\t\t}\n\t}\n\n\tif (err) *err = CUTE_SOUND_ERROR_NONE;\n\treturn audio;\n}\n\nvoid cs_free_audio_source(cs_audio_source_t* audio)\n{\n\tif (s_ctx) {\n\t\tcs_lock();\n\t\tif (audio->playing_count == 0) {\n\t\t\tcs_free16(audio->channels[0]);\n\t\t\tCUTE_SOUND_FREE(audio, s_mem_ctx);\n\t\t} else {\n\t\t\tif (s_ctx->audio_sources_to_free_size == s_ctx->audio_sources_to_free_capacity) {\n\t\t\t\tint new_capacity = s_ctx->audio_sources_to_free_capacity * 2;\n\t\t\t\tcs_audio_source_t** new_sources = (cs_audio_source_t**)CUTE_SOUND_ALLOC(new_capacity, s_mem_ctx);\n\t\t\t\tCUTE_SOUND_MEMCPY(new_sources, s_ctx->audio_sources_to_free, sizeof(cs_audio_source_t*) * s_ctx->audio_sources_to_free_size);\n\t\t\t\tCUTE_SOUND_FREE(s_ctx->audio_sources_to_free, s_mem_ctx);\n\t\t\t\ts_ctx->audio_sources_to_free = new_sources;\n\t\t\t\ts_ctx->audio_sources_to_free_capacity = new_capacity;\n\t\t\t}\n\t\t\ts_ctx->audio_sources_to_free[s_ctx->audio_sources_to_free_size++] = audio;\n\t\t}\n\t\tcs_unlock();\n\t} else {\n\t\tCUTE_SOUND_ASSERT(audio->playing_count == 0);\n\t\tcs_free16(audio->channels[0]);\n\t\tCUTE_SOUND_FREE(audio, s_mem_ctx);\n\t}\n}\n\nint cs_get_sample_rate(const cs_audio_source_t* audio)\n{\n\treturn audio->sample_rate;   \n}\n\nint cs_get_sample_count(const cs_audio_source_t* audio)\n{\n\treturn audio->sample_count;\n}\n\nint cs_get_channel_count(const cs_audio_source_t* audio)\n{\n\treturn audio->channel_count;\n}\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL && defined(SDL_rwops_h_) && defined(CUTE_SOUND_SDL_RWOPS)\n\n\t// Load an SDL_RWops object's data into memory.\n\t// Ripped straight from: https://wiki.libsdl.org/SDL_RWread\n\tstatic void* cs_read_rw_to_memory(SDL_RWops* rw, int* size)\n\t{\n\t\tSint64 res_size = SDL_RWsize(rw);\n\t\tchar* data = (char*)CUTE_SOUND_ALLOC((size_t)(res_size + 1), s_mem_ctx);\n\n\t\tSint64 nb_read_total = 0, nb_read = 1;\n\t\tchar* buf = data;\n\t\twhile (nb_read_total < res_size && nb_read != 0)\n\t\t{\n\t\t\tnb_read = SDL_RWread(rw, buf, 1, (size_t)(res_size - nb_read_total));\n\t\t\tnb_read_total += nb_read;\n\t\t\tbuf += nb_read;\n\t\t}\n\n\t\tSDL_RWclose(rw);\n\n\t\tif (nb_read_total != res_size)\n\t\t{\n\t\t\tCUTE_SOUND_FREE(data, s_mem_ctx);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (size) *size = (int)res_size;\n\t\treturn data;\n\t}\n\n\tcs_audio_source_t* cs_load_wav_rw(SDL_RWops* context, cs_error_t* err)\n\t{\n\t\tint size;\n\t\tchar* wav = (char*)cs_read_rw_to_memory(context, &size);\n\t\tif (!memory) return NULL;\n\t\tcs_audio_source_t* audio = cs_read_mem_wav(wav, length, err);\n\t\tCUTE_SOUND_FREE(wav, s_mem_ctx);\n\t\treturn audio;\n\t}\n\n#endif\n\n// If stb_vorbis was included *before* cute_sound go ahead and create\n// some functions for dealing with OGG files.\n#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H\n\ncs_audio_source_t* cs_read_mem_ogg(const void* memory, size_t length, cs_error_t* err)\n{\n\tint16_t* samples = 0;\n\tcs_audio_source_t* audio = NULL;\n\tint channel_count;\n\tint sample_rate;\n\tint sample_count = stb_vorbis_decode_memory((const unsigned char*)memory, (int)length, &channel_count, &sample_rate, &samples);\n\tif (sample_count <= 0) { if (err) *err = CUTE_SOUND_ERROR_STB_VORBIS_DECODE_FAILED; return NULL; }\n\taudio = (cs_audio_source_t*)CUTE_SOUND_ALLOC(sizeof(cs_audio_source_t), s_mem_ctx);\n\tCUTE_SOUND_MEMSET(audio, 0, sizeof(*audio));\n\n\t{\n\t\tint wide_count = (int)CUTE_SOUND_ALIGN(sample_count, 4) / 4;\n\t\tint wide_offset = sample_count & 3;\n\t\tcs__m128* a = NULL;\n\t\tcs__m128* b = NULL;\n\n\t\tswitch (channel_count)\n\t\t{\n\t\tcase 1:\n\t\t{\n\t\t\ta = (cs__m128*)cs_malloc16(wide_count * sizeof(cs__m128));\n\t\t\tb = 0;\n\t\t\tfor (int i = 0, j = 0; i < wide_count - 1; ++i, j += 4) {\n\t\t\t\ta[i] = cs_mm_set_ps((float)samples[j+3], (float)samples[j+2], (float)samples[j+1], (float)samples[j]);\n\t\t\t}\n\t\t\tcs_last_element(a, wide_count - 1, (wide_count - 1) * 4, samples, wide_offset);\n\t\t}\tbreak;\n\n\t\tcase 2:\n\t\t\ta = (cs__m128*)cs_malloc16(wide_count * sizeof(cs__m128) * 2);\n\t\t\tb = a + wide_count;\n\t\t\tfor (int i = 0, j = 0; i < wide_count - 1; ++i, j += 8) {\n\t\t\t\ta[i] = cs_mm_set_ps((float)samples[j+6], (float)samples[j+4], (float)samples[j+2], (float)samples[j]);\n\t\t\t\tb[i] = cs_mm_set_ps((float)samples[j+7], (float)samples[j+5], (float)samples[j+3], (float)samples[j+1]);\n\t\t\t}\n\t\t\tcs_last_element(a, wide_count - 1, (wide_count - 1) * 4, samples, wide_offset);\n\t\t\tcs_last_element(b, wide_count - 1, (wide_count - 1) * 4 + 4, samples, wide_offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (err) *err = CUTE_SOUND_ERROR_OGG_UNSUPPORTED_CHANNEL_COUNT;\n\t\t\tCUTE_SOUND_ASSERT(false);\n\t\t}\n\n\t\taudio->sample_rate = sample_rate;\n\t\taudio->sample_count = sample_count;\n\t\taudio->channel_count = channel_count;\n\t\taudio->channels[0] = a;\n\t\taudio->channels[1] = b;\n\t\taudio->playing_count = 0;\n\t\tCUTE_SOUND_FREE(samples, s_mem_ctx);\n\t}\n\n\tif (err) *err = CUTE_SOUND_ERROR_NONE;\n\treturn audio;\n}\n\ncs_audio_source_t* cs_load_ogg(const char* path, cs_error_t* err)\n{\n\tint length;\n\tvoid* memory = cs_read_file_to_memory(path, &length);\n\tif (!memory) return NULL;\n\tcs_audio_source_t* audio = cs_read_mem_ogg(memory, length, err);\n\tCUTE_SOUND_FREE(memory, s_mem_ctx);\n\treturn audio;\n}\n\n#if CUTE_SOUND_PLATFORM == CUTE_SOUND_SDL && defined(SDL_rwops_h_) && defined(CUTE_SOUND_SDL_RWOPS)\n\n\tcs_audio_source_t* cs_load_ogg_rw(SDL_RWops* rw, cs_error_t* err)\n\t{\n\t\tint length;\n\t\tvoid* memory = cs_read_rw_to_memory(rw, &length);\n\t\tif (!memory) return NULL;\n\t\tcs_audio_source_t* audio = cs_read_ogg_wav(memory, length, err);\n\t\tCUTE_SOUND_FREE(memory, s_mem_ctx);\n\t\treturn audio;\n\t}\n\n#endif\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n// -------------------------------------------------------------------------------------------------\n// Music sounds.\n\nstatic void s_insert(cs_sound_inst_t* inst)\n{\n\tcs_lock();\n\tcs_list_push_back(&s_ctx->playing_sounds, &inst->node);\n\tinst->audio->playing_count += 1;\n\tinst->active = true;\n\tinst->id = s_ctx->instance_id_gen++;\n\tcs_hashtableinsert(&s_ctx->instance_map, inst->id, &inst);\n\tcs_unlock();\n}\n\nstatic cs_sound_inst_t* s_inst_music(cs_audio_source_t* src, float volume)\n{\n\tif (cs_list_empty(&s_ctx->free_sounds)) {\n\t\ts_add_page();\n\t}\n\tCUTE_SOUND_ASSERT(!cs_list_empty(&s_ctx->free_sounds));\n\tcs_sound_inst_t* inst = CUTE_SOUND_LIST_HOST(cs_sound_inst_t, node, cs_list_pop_back(&s_ctx->free_sounds));\n\tinst->is_music = true;\n\tinst->looped = s_ctx->music_looped;\n\tif (!s_ctx->music_paused) inst->paused = false;\n\tinst->volume = volume;\n\tinst->pan0 = 0.5f;\n\tinst->pan1 = 0.5f;\n\tinst->pitch = 1.0f;\n\tinst->audio = src;\n\tinst->sample_index = 0;\n\tcs_list_init_node(&inst->node);\n\ts_insert(inst);\n\treturn inst;\n}\n\nstatic cs_sound_inst_t* s_inst(cs_audio_source_t* src, cs_sound_params_t params)\n{\n\tif (cs_list_empty(&s_ctx->free_sounds)) {\n\t\ts_add_page();\n\t}\n\tCUTE_SOUND_ASSERT(!cs_list_empty(&s_ctx->free_sounds));\n\tcs_sound_inst_t* inst = CUTE_SOUND_LIST_HOST(cs_sound_inst_t, node, cs_list_pop_back(&s_ctx->free_sounds));\n\tfloat pan = params.pan;\n\tif (pan > 1.0f) pan = 1.0f;\n\telse if (pan < 0.0f) pan = 0.0f;\n\tfloat panl = 1.0f - pan;\n\tfloat panr = pan;\n\tinst->is_music = false;\n\tinst->paused = params.paused;\n\tinst->looped = params.looped;\n\tinst->volume = params.volume;\n\tinst->pan0 = panl;\n\tinst->pan1 = panr;\n\tinst->pitch = params.pitch;\n\tinst->audio = src;\n\tinst->sample_index = params.sample_index;\n\tCUTE_SOUND_ASSERT(inst->sample_index < src->sample_count);\n\tcs_list_init_node(&inst->node);\n\ts_insert(inst);\n\treturn inst;\n}\n\nvoid cs_music_play(cs_audio_source_t* audio_source, float fade_in_time)\n{\n\tif (s_ctx->music_state != CUTE_SOUND_MUSIC_STATE_PLAYING) {\n\t\tcs_music_stop(0);\n\t}\n\n\tif (fade_in_time < 0) fade_in_time = 0;\n\tif (fade_in_time) {\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_FADE_IN;\n\t} else {\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_PLAYING;\n\t}\n\ts_ctx->fade = fade_in_time;\n\ts_ctx->t = 0;\n\n\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\ts_ctx->music_playing = inst;\n\ts_ctx->music_next = NULL;\n}\n\nvoid cs_music_stop(float fade_out_time)\n{\n\tif (fade_out_time < 0) fade_out_time = 0;\n\n\tif (fade_out_time == 0) {\n\t\t// Immediately turn off all music if no fade out time.\n\t\tif (s_ctx->music_playing) {\n\t\t\ts_ctx->music_playing->active = false;\n\t\t\ts_ctx->music_playing->paused = false;\n\t\t}\n\t\tif (s_ctx->music_next) {\n\t\t\ts_ctx->music_next->active = false;\n\t\t\ts_ctx->music_next->paused = false;\n\t\t}\n\t\ts_ctx->music_playing = NULL;\n\t\ts_ctx->music_next = NULL;\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_NONE;\n\t} else {\n\t\tswitch (s_ctx->music_state) {\n\t\tcase CUTE_SOUND_MUSIC_STATE_NONE:\n\t\t\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_PLAYING:\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_FADE_OUT;\n\t\t\ts_ctx->fade = fade_out_time;\n\t\t\ts_ctx->t = 0;\n\t\t\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_FADE_OUT:\n\t\t\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_FADE_IN:\n\t\t{\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_FADE_OUT;\n\t\t\ts_ctx->t = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\ts_ctx->fade = fade_out_time;\n\t\t}\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0:\n\t\t{\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_FADE_OUT;\n\t\t\ts_ctx->t = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\ts_ctx->fade = fade_out_time;\n\t\t\ts_ctx->music_next = NULL;\n\t\t}\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_1:\n\t\t\t// Fall-through.\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_CROSSFADE:\n\t\t{\n\t\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_FADE_OUT;\n\t\t\ts_ctx->t = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\t\ts_ctx->fade = fade_out_time;\n\t\t\ts_ctx->music_playing = s_ctx->music_next;\n\t\t\ts_ctx->music_next = NULL;\n\t\t}\tbreak;\n\n\t\tcase CUTE_SOUND_MUSIC_STATE_PAUSED:\n\t\t\tcs_music_stop(0);\n\t\t}\n\t}\n}\n\nvoid cs_music_set_volume(float volume_0_to_1)\n{\n\tif (volume_0_to_1 < 0) volume_0_to_1 = 0;\n\ts_ctx->music_volume = volume_0_to_1;\n\tif (s_ctx->music_playing) s_ctx->music_playing->volume = volume_0_to_1;\n\tif (s_ctx->music_next) s_ctx->music_next->volume = volume_0_to_1;\n}\n\nvoid cs_music_set_pitch(float pitch)\n{\n\ts_ctx->music_pitch = pitch;\n\tif (s_ctx->music_playing) s_ctx->music_playing->pitch = pitch;\n\tif (s_ctx->music_next) s_ctx->music_next->pitch = pitch;\n}\n\nvoid cs_music_set_loop(bool true_to_loop)\n{\n\ts_ctx->music_looped = true_to_loop;\n\tif (s_ctx->music_playing) s_ctx->music_playing->looped = true_to_loop;\n\tif (s_ctx->music_next) s_ctx->music_next->looped = true_to_loop;\n}\n\nvoid cs_music_pause()\n{\n\tif (s_ctx->music_state == CUTE_SOUND_MUSIC_STATE_PAUSED) return;\n\tif (s_ctx->music_playing) s_ctx->music_playing->paused = true;\n\tif (s_ctx->music_next) s_ctx->music_next->paused = true;\n\ts_ctx->music_paused = true;\n\ts_ctx->music_state_to_resume_from_paused = s_ctx->music_state;\n\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_PAUSED;\n}\n\nvoid cs_music_resume()\n{\n\tif (s_ctx->music_state != CUTE_SOUND_MUSIC_STATE_PAUSED) return;\n\tif (s_ctx->music_playing) s_ctx->music_playing->paused = false;\n\tif (s_ctx->music_next) s_ctx->music_next->paused = false;\n\ts_ctx->music_state = s_ctx->music_state_to_resume_from_paused;\n}\n\nvoid cs_music_switch_to(cs_audio_source_t* audio_source, float fade_out_time, float fade_in_time)\n{\n\tif (fade_in_time < 0) fade_in_time = 0;\n\tif (fade_out_time < 0) fade_out_time = 0;\n\n\tswitch (s_ctx->music_state) {\n\tcase CUTE_SOUND_MUSIC_STATE_NONE:\n\t\tcs_music_play(audio_source, fade_in_time);\n\t\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_PLAYING:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next == NULL);\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade = fade_out_time;\n\t\ts_ctx->fade_switch_1 = fade_in_time;\n\t\ts_ctx->t = 0;\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_OUT:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next == NULL);\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade_switch_1 = fade_in_time;\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_IN:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next == NULL);\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade_switch_1 = fade_in_time;\n\t\ts_ctx->t = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next != NULL);\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\t\ts_ctx->music_next->active = false;\n\t\ts_ctx->music_next = inst;\n\t\ts_ctx->fade_switch_1 = fade_in_time;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_CROSSFADE: // Fall-through.\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_1:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next != NULL);\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, fade_in_time == 0 ? 1.0f : 0);\n\t\ts_ctx->music_playing = s_ctx->music_next;\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->t = s_smoothstep(((s_ctx->fade - s_ctx->t) / s_ctx->fade));\n\t\ts_ctx->fade_switch_1 = fade_in_time;\n\t\ts_ctx->fade = fade_out_time;\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_PAUSED:\n\t\tcs_music_stop(0);\n\t\tcs_music_switch_to(audio_source, fade_out_time, fade_in_time);\n\t\tbreak;\n\t}\n}\n\nvoid cs_music_crossfade(cs_audio_source_t* audio_source, float cross_fade_time)\n{\n\tif (cross_fade_time < 0) cross_fade_time = 0;\n\n\tswitch (s_ctx->music_state) {\n\tcase CUTE_SOUND_MUSIC_STATE_NONE:\n\t\tcs_music_play(audio_source, cross_fade_time);\n\n\tcase CUTE_SOUND_MUSIC_STATE_PLAYING:\n\t{\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next == NULL);\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_CROSSFADE;\n\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, cross_fade_time == 0 ? 1.0f : 0);\n\t\tinst->paused = false;\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade = cross_fade_time;\n\t\ts_ctx->t = 0;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_OUT:\n\t\tCUTE_SOUND_ASSERT(s_ctx->music_next == NULL);\n\t\t// Fall-through.\n\n\tcase CUTE_SOUND_MUSIC_STATE_FADE_IN:\n\t{\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_CROSSFADE;\n\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, cross_fade_time == 0 ? 1.0f : 0);\n\t\tinst->paused = false;\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade = cross_fade_time;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_0:\n\t{\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_CROSSFADE;\n\t\ts_ctx->music_next->active = false;\n\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, cross_fade_time == 0 ? 1.0f : 0);\n\t\tinst->paused = false;\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade = cross_fade_time;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_SWITCH_TO_1: // Fall-through.\n\tcase CUTE_SOUND_MUSIC_STATE_CROSSFADE:\n\t{\n\t\ts_ctx->music_state = CUTE_SOUND_MUSIC_STATE_CROSSFADE;\n\t\ts_ctx->music_playing->active = false;\n\t\ts_ctx->music_playing = s_ctx->music_next;\n\n\t\tcs_sound_inst_t* inst = s_inst_music(audio_source, cross_fade_time == 0 ? 1.0f : 0);\n\t\tinst->paused = false;\n\t\ts_ctx->music_next = inst;\n\n\t\ts_ctx->fade = cross_fade_time;\n\t}\tbreak;\n\n\tcase CUTE_SOUND_MUSIC_STATE_PAUSED:\n\t\tcs_music_stop(0);\n\t\tcs_music_crossfade(audio_source, cross_fade_time);\n\t}\n}\n\nint cs_music_get_sample_index()\n{\n\tif (s_ctx->music_playing) return 0;\n\telse return s_ctx->music_playing->sample_index;\n}\n\ncs_error_t cs_music_set_sample_index(int sample_index)\n{\n\tif (s_ctx->music_playing) return CUTE_SOUND_ERROR_INVALID_SOUND;\n\tif (sample_index > s_ctx->music_playing->audio->sample_count) return CUTE_SOUND_ERROR_TRIED_TO_SET_SAMPLE_INDEX_BEYOND_THE_AUDIO_SOURCES_SAMPLE_COUNT;\n\ts_ctx->music_playing->sample_index = sample_index;\n\treturn CUTE_SOUND_ERROR_NONE;\n}\n\n// -------------------------------------------------------------------------------------------------\n// Playing sounds.\n\ncs_sound_params_t cs_sound_params_default()\n{\n\tcs_sound_params_t params;\n\tparams.paused = false;\n\tparams.looped = false;\n\tparams.volume = 1.0f;\n\tparams.pan = 0.5f;\n\tparams.pitch = 1.0f;\n\tparams.sample_index = 0;\n\treturn params;\n}\n\nstatic cs_sound_inst_t* s_get_inst(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t** inst = (cs_sound_inst_t**)cs_hashtablefind(&s_ctx->instance_map, sound.id);\n\tif (inst) return *inst;\n\treturn NULL;\n}\n\ncs_playing_sound_t cs_play_sound(cs_audio_source_t* audio, cs_sound_params_t params)\n{\n\tcs_sound_inst_t* inst = s_inst(audio, params);\n\tcs_playing_sound_t sound = { inst->id };\n\treturn sound;\n}\n\nvoid cs_on_sound_finished_callback(void (*on_finish)(cs_playing_sound_t, void*), void* udata)\n{\n\ts_ctx->on_finish = on_finish;\n\ts_ctx->on_finish_udata = udata;\n}\n\nvoid cs_on_music_finished_callback(void (*on_finish)(void*), void* udata)\n{\n\ts_ctx->on_music_finish = on_finish;\n\ts_ctx->on_music_finish_udata = udata;\n}\n\nbool cs_sound_is_active(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return false;\n\treturn inst->active;\n}\n\nbool cs_sound_get_is_paused(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return false;\n\treturn inst->paused;\n}\n\nbool cs_sound_get_is_looped(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return false;\n\treturn inst->looped;\n}\n\nfloat cs_sound_get_volume(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return 0;\n\treturn inst->volume;\n}\n\nfloat cs_sound_get_pitch(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return 0;\n\treturn inst->pitch;\n}\n\nfloat cs_sound_get_pan(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return 0;\n\treturn inst->pan1;\n}\n\nint cs_sound_get_sample_index(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return 0;\n\treturn inst->sample_index;\n}\n\nvoid cs_sound_set_is_paused(cs_playing_sound_t sound, bool true_for_paused)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->paused = true_for_paused;\n}\n\nvoid cs_sound_set_is_looped(cs_playing_sound_t sound, bool true_for_looped)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->looped = true_for_looped;\n}\n\nvoid cs_sound_set_volume(cs_playing_sound_t sound, float volume_0_to_1)\n{\n\tif (volume_0_to_1 < 0) volume_0_to_1 = 0;\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->volume = volume_0_to_1;\n}\n\nvoid cs_sound_set_pitch(cs_playing_sound_t sound, float pitch)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->pitch = pitch;\n}\n\nvoid cs_sound_set_pan(cs_playing_sound_t sound, float pan_0_to_1)\n{\n\tif (pan_0_to_1 < 0) pan_0_to_1 = 0;\n\tif (pan_0_to_1 > 1) pan_0_to_1 = 1;\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->pan0 = 1.0f - pan_0_to_1;\n\tinst->pan1 = pan_0_to_1;\n}\n\ncs_error_t cs_sound_set_sample_index(cs_playing_sound_t sound, int sample_index)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return CUTE_SOUND_ERROR_INVALID_SOUND;\n\tif (sample_index > inst->audio->sample_count) return CUTE_SOUND_ERROR_TRIED_TO_SET_SAMPLE_INDEX_BEYOND_THE_AUDIO_SOURCES_SAMPLE_COUNT;\n\tinst->sample_index = sample_index;\n\treturn CUTE_SOUND_ERROR_NONE;\n}\n\nvoid cs_sound_stop(cs_playing_sound_t sound)\n{\n\tcs_sound_inst_t* inst = s_get_inst(sound);\n\tif (!inst) return;\n\tinst->active = false;\n}\n\nvoid cs_set_playing_sounds_volume(float volume_0_to_1)\n{\n\tif (volume_0_to_1 < 0) volume_0_to_1 = 0;\n\ts_ctx->sound_volume = volume_0_to_1;\n}\n\nvoid cs_stop_all_playing_sounds()\n{\n\tcs_lock();\n\n\t// Set all playing sounds (that aren't music) active to false.\n\tif (cs_list_empty(&s_ctx->playing_sounds)) {\n\t\tcs_unlock();\n\t\treturn;\n\t}\n\tcs_list_node_t* playing_sound = cs_list_begin(&s_ctx->playing_sounds);\n\tcs_list_node_t* end = cs_list_end(&s_ctx->playing_sounds);\n\n\tdo {\n\t\tcs_sound_inst_t* inst = CUTE_SOUND_LIST_HOST(cs_sound_inst_t, node, playing_sound);\n\t\tcs_list_node_t* next = playing_sound->next;\n\t\tif (inst != s_ctx->music_playing && inst != s_ctx->music_next) {\n\t\t\tinst->active = false; // Let cs_mix handle cleaning this up.\n\t\t}\n\t\tplaying_sound = next;\n\t} while (playing_sound != end);\n\n\tcs_unlock();\n}\n\nvoid cs_cull_duplicates(bool true_to_enable)\n{\n\ts_ctx->cull_duplicates = true_to_enable;\n}\n\nvoid* cs_get_global_context()\n{\n\treturn s_ctx;\n}\n\nvoid cs_set_global_context(void* context)\n{\n\ts_ctx = (cs_context_t*)context;\n}\n\nvoid* cs_get_global_user_allocator_context()\n{\n\treturn s_mem_ctx;\n}\n\nvoid cs_set_global_user_allocator_context(void* user_allocator_context)\n{\n\ts_mem_ctx = user_allocator_context;\n}\n\n#endif // CUTE_SOUND_IMPLEMENTATION_ONCE\n#endif // CUTE_SOUND_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2023 Randy Gaul https://randygaul.github.io/\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t\t claim that you wrote the original software. If you use this software\n\t\t in a product, an acknowledgment in the product documentation would be\n\t\t appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t\t be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\n\tsoftware, either in source code form or as a compiled binary, for any purpose,\n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this\n\tsoftware dedicate any and all copyright interest in the software to the public\n\tdomain. We make this dedication for the benefit of the public at large and to\n\tthe detriment of our heirs and successors. We intend this dedication to be an\n\tovert act of relinquishment in perpetuity of all present and future rights to\n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_spritebatch.h",
          "type": "blob",
          "size": 82.2080078125,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_spritebatch.h - v1.06\n\n\tTo create implementation (the function definitions)\n\t\t#define SPRITEBATCH_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\tSUMMARY:\n\n\t\tThis header implements a 2D sprite batcher by tracking different textures within\n\t\ta rolling atlas cache. Over time atlases are decayed and recreated when textures\n\t\tstop being used. This header is useful for batching sprites at run-time. This avoids\n\t\tthe need to compile texture atlases as a pre-process step, letting the game load\n\t\timages up individually, dramatically simplifying art pipelines.\n\n\tMORE DETAILS:\n\n\t\t`spritebatch_push` is used to push sprite instances into a buffer. Rendering sprites\n\t\tworks by calling `spritebatch_flush`. `spritebatch_flush` will use a user-supplied\n\t\tcallback to report sprite batches. This callback is of type `submit_batch_fn`. The\n\t\tbatches are reported as an array of `spritebatch_sprite_t` sprites, and can be\n\t\tfurther sorted by the user (for example to sort by depth). Sprites in a batch share\n\t\tthe same texture handle (either from the same base image, or from the same internal\n\t\tatlas).\n\n\t\tcute_spritebatch does not know anything about how to generate texture handles, or\n\t\tdestroy them. As such, the user must supply two callbacks for creating handles and\n\t\tdestroying them. These can be simple wrappers around, for example, `glGenTextures`\n\t\tand `glDeleteTextures`.\n\n\t\tFinally, cute_spritebatch will periodically need access to pixels from images. These\n\t\tpixels are used to generate textures, or to build atlases (which in turn generate a\n\t\ttexture). cute_spritebatch does not need to know much about your images, other than\n\t\tthe pixel stride. The user supplies callback of type `get_pixels_fn`, which lets\n\t\tcute_spritebatch retreive the pixels associated with a particular image. The pixels\n\t\tcan be stored in RAM and handed to cute_spritebatch whenever requested, or the pixels\n\t\tcan be fetched directly from disk and handed to cute_spritebatch. It doesn't matter\n\t\tto cute_spritebatch. Since `get_pixels_fn` can be called from `spritebatch_flush` it\n\t\tis recommended to avoid file i/o within the `get_pixels_fn` callback, and instead try\n\t\tto already have pixels ready in RAM.\n\n\t\tThe `spritebatch_defrag` function performs atlas creation and texture management. It\n\t\tshould be called periodically. It can be called once per game tick (once per render),\n\t\tor optionally called at a different frequency (once every N game ticks).\n\n\tPROS AND CONS:\n\n\t\tPROS\n\t\t- Texture atlases are completely hidden behind an api. The api in this header can\n\t\t  easily be implemented with different backend sprite batchers. For example on\n\t\t  some platforms bindless textures can be utilized in order to avoid texture\n\t\t  atlases entirely! Code using this API can have the backend implementation swapped\n\t\t  without requiring any user code to change.\n\t\t- Sprites are batched in an effective manner to dramatically reduce draw call counts.\n\t\t- Supporting hotswapping or live-reloading of images can be trivialized due to\n\t\t  moving atlas creation out of the art-pipeline and into the run-time.\n\t\t- Since atlases are built at run-time and continually maintained, images are\n\t\t  guaranteed to be drawn at the same time on-screen as their atlas neighbors. This is\n\t\t  typically not the case for atlas preprocessors, as a *guess* must be made to try\n\t\t  and organize images together in atlases that need to be drawn at roughly the same\n\t\t  time.\n\n\t\tCONS\n\t\t- Performance hits in the `spritebatch_defrag` function, and a little as well in\n\t\t  the `spritebatch_flush` function. Extra run-time memory usage for bookkeeping,\n\t\t  which implies a RAM hit as well as more things to clog the CPU cache.\n\t\t- If each texture comes from a separate image on-disk, opening individual files on\n\t\t  disk can be very slow. For example on Windows just performing permissions and\n\t\t  related work to open a file is time-consuming. This can be mitigated by moving\n\t\t  assets into a single larger file, for example a .zip archive and read from using\n\t\t  a file io abstraction like PHYSFS.\n\t\t- For large numbers of separate images, some file abstraction is necessary to avoid\n\t\t  a large performance hit on opening/closing many individual files. This problem is\n\t\t  *not* solved by cute_spritebatch.h, and instead should be solved by some separate\n\t\t  file abstraction system. PHYSFS is a good example of a solid file io abstraction.\n\n\tEXAMPLE USAGE:\n\n\t\tspritebatch_config_t config;\n\t\tspritebatch_set_default_config(&config);\n\t\tconfig.batch_callback = my_report_batches_function;\n\t\tconfig.get_pixels_callback = my_get_pixels_function;\n\t\tconfig.generate_texture_callback = my_make_texture_handle_function;\n\t\tconfig.delete_texture_callback = my_destroy_texture_handle_function;\n\n\t\tspritebatch_t batcher;\n\t\tspritebatch_init(&batcher, &config);\n\n\t\twhile (game_is_running)\n\t\t{\n\t\t\tfor (int i = 0; i < sprite_count; ++i)\n\t\t\t\tspritebatch_push(\n\t\t\t\t\t&batcher,\n\t\t\t\t\tsprites[i].image_id,\n\t\t\t\t\tsprites[i].image_width_in_pixels,\n\t\t\t\t\tsprites[i].image_height_in_pixels, \n\t\t\t\t\tsprites[i].position_x,\n\t\t\t\t\tsprites[i].poxition_y,\n\t\t\t\t\tsprites[i].scale_x,\n\t\t\t\t\tsprites[i].scale_y,\n\t\t\t\t\tsprites[i].cos_rotation_angle,\n\t\t\t\t\tsprites[i].sin_rotation_angle\n\t\t\t\t\t);\n\n\t\t\tspritebatch_tick(&batcher);\n\t\t\tspritebatch_defrag(&batcher);\n\t\t\tspritebatch_flush(&batcher);\n\t\t}\n\n\tCUSTOMIZATION:\n\n\t\tThe following macros can be defined before including this header with the\n\t\tSPRITEBATCH_IMPLEMENTATION symbol defined, in order to customize the internal\n\t\tbehavior of cute_spritebatch.h. Search this header to find how each macro is\n\t\tdefined and used. Note that MALLOC/FREE functions can optionally take a context\n\t\tparameter for custom allocation.\n\n\t\tSPRITEBATCH_MALLOC\n\t\tSPRITEBATCH_MEMCPY\n\t\tSPRITEBATCH_MEMSET\n\t\tSPRITEBATCH_MEMMOVE\n\t\tSPRITEBATCH_ASSERT\n\t\tSPRITEBATCH_ATLAS_FLIP_Y_AXIS_FOR_UV\n\t\tSPRITEBATCH_ATLAS_EMPTY_COLOR\n\t\tSPRITEBATCH_LOG\n\n\tRevision history:\n\t\t0.01 (11/20/2017) experimental release\n\t\t1.00 (04/14/2018) initial release\n\t\t1.01 (05/07/2018) modification for easier file embedding\n\t\t1.02 (02/03/2019) moved def of spritebatch_t for easier embedding,\n\t\t                  inverted get pixels callback to let users have an easier time\n\t\t                  with memory management, added support for pixel padding along\n\t\t                  the edges of all textures (useful for certain shader effects)\n\t\t1.03 (08/18/2020) refactored `spritebatch_push` so that sprites can have userdata\n\t\t1.04 (08/20/2021) qsort -> mergesort to avoid sort bugs, optional override\n\t\t                  `sprites_sorter_fn` sorting routines provided by Kariem, added\n\t\t                  new function `spritebatch_prefetch`\n\t\t1.05 (12/10/2022) added `SPRITEBATCH_SPRITE_GEOMETRY`, a way to put custom geom-\n\t\t                  etry in sprites. Added `spritebatch_register_premade_atlas`, a\n\t\t                  way to inject premade atlases into spritebatch\n\t\t1.06 (03/24/2023) added `spritebatch_invalidate`, useful for updating pixels NOW\n*/\n\n/*\n\tContributors:\n\t\tKariem            1.04 - Optional sorter function `sprites_sorter_fn`\n\t\tKariem            1.05 - Initial work on premade atlases\n*/\n\n#ifndef SPRITEBATCH_H\n\n#ifndef SPRITEBATCH_U64\n\t#define SPRITEBATCH_U64 unsigned long long\n#endif // SPRITEBATCH_U64\n\ntypedef struct spritebatch_t spritebatch_t;\ntypedef struct spritebatch_config_t spritebatch_config_t;\ntypedef struct spritebatch_sprite_t spritebatch_sprite_t;\n\n// This define is *completely optional*. It lets you override the default layout of\n// data passed through the sprite batcher. By default it contains the minimal info\n// needed for a quad (position, scale, rotation, etc.). You can override this macro\n// to define your own geometry for batching. For example, you could have a union to\n// support both quads and individual triangles, as opposed to just quads by default.\n// \n// IMPROTANT NOTE (ignore unless you override this macro):\n// Just note you'll have to calculate your own uv coordinates after each batch is\n// reported. You should also be careful about the scale of your geometry if you opt\n// to use `atlas_use_border_pixels`, as you'll have to account for border pixels\n// included in the reported uvs. Search `SPRITEBATCH_SPRITE_GEOMETRY_DEFAULT` for\n// more an example on how to do this yourself.\n#ifndef SPRITEBATCH_SPRITE_GEOMETRY\n\ttypedef struct spritebatch_primitive_t\n\t{\n\t\tfloat x, y;   // x and y position\n\t\tfloat sx, sy; // scale on x and y axis\n\t\tfloat c, s;   // cosine and sine (represents cos(angle) and sin(angle))\n\t} spritebatch_primitive_t;\n#\tdefine SPRITEBATCH_SPRITE_GEOMETRY spritebatch_primitive_t\n\n\t// Used to automatically scale reported sprites according to border pixels.\n#\tdefine SPRITEBATCH_SPRITE_GEOMETRY_DEFAULT\n#endif\n\n// Sprites will be pushed into the spritebatch with this struct. All the fields\n// should be set before calling `spritebatch_push`, though `texture_id` and\n// `sort_bits` can simply be set to zero.\n//\n// After sprites are pushed onto the spritebatch via `spritebatch_push`, they will\n// be sorted, `texture_id` is assigned to a generated atlas, and handed back to you\n// via the `submit_batch_fn` callback.\nstruct spritebatch_sprite_t\n{\n\t// `image_id` must be a unique identifier for the image a sprite references.\n\t// You must set this value!\n\tSPRITEBATCH_U64 image_id;\n\n\t// `texture_id` can be set to zero. This value will be overwritten with a valid\n\t// texture id before batches are reported back to you. This id will map to an\n\t// atlas created internally.\n\tSPRITEBATCH_U64 texture_id;\n\n\t// Contains all of the sprite's geometry. By default this is just a scale +\n\t// translation + rotation. However, you can overload this macro to use your own\n\t// geometry definition. See comments at this macro definition above for more info.\n\tSPRITEBATCH_SPRITE_GEOMETRY geom;\n\n\tint w, h;         // width and height of this sprite's image in pixels\n\tfloat minx, miny; // u coordinate - this will be overwritten\n\tfloat maxx, maxy; // v coordinate - this will be overwritten\n\n\t// This field is *completely optional* -- just set it to zero if you don't want to bother.\n\t// User-defined sorting key, see: http://realtimecollisiondetection.net/blog/?p=86\n\tint sort_bits;\n\n\t// This is a *completely optional* feature. You can insert your own user data\n\t// struct into each sprite. It is *never* touched internally, and simply handed\n\t// back to you later.\n#ifdef SPRITEBATCH_SPRITE_USERDATA\n\tSPRITEBATCH_SPRITE_USERDATA udata;\n#endif // SPRITEBATCH_SPRITE_USERDATA\n};\n\n// Pushes a sprite onto an internal buffer. Does no other logic.\nint spritebatch_push(spritebatch_t* sb, spritebatch_sprite_t sprite);\n\n// Ensures the image associated with your unique `image_id` is loaded up into spritebatch. This\n// function pretends to draw a sprite referencing `image_id` but doesn't actually do any\n// drawing at all. Use this function as an optimization to pre-load images you know will be\n// drawn very soon, e.g. prefetch all ten images within a single animation just as it starts\n// playing.\nvoid spritebatch_prefetch(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h);\n\n// Useful for re-uploading pixels to the GPU.\n// Invalidates the internal cache for a specific sprite. If this sprite resides in a texture atlas\n// the entire atlas is recompiled. If the sprite resides in the lonely buffer only the individual\n// texture gets recreated. You may want to beef up `lonely_buffer_count_till_flush` in the config\n// `spritebatch_config_t` if you want to invalidate sprites often -- this can help prevent constantly\n// invalidating internal atlases and recompiling them, and instead get your dynamic textures into the\n// lonely buffer.\nvoid spritebatch_invalidate(spritebatch_t* sb, SPRITEBATCH_U64 image_id);\n\n// If a match for `image_id` is found, the texture id and uv coordinates are looked up and returned\n// as a sprite instance. This is sometimes useful to render sprites through an external mechanism,\n// such as Dear ImGui. The return result will be valid until the next call to `spritebatch_defrag`.\nspritebatch_sprite_t spritebatch_fetch(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h);\n\n// Increments internal timestamps on all textures, for use in `spritebatch_defrag`.\nvoid spritebatch_tick(spritebatch_t* sb);\n\n// Sorts the internal sprites and flushes the buffer built by `spritebatch_push`. Will call\n// the `submit_batch_fn` function for each batch of sprites and return them as an array. Any `image_id`\n// within the `spritebatch_push` buffer that do not yet have a texture handle will request pixels\n// from the image via `get_pixels_fn` and request a texture handle via `generate_texture_handle_fn`.\n// Returns the number of batches created and submitted.\nint spritebatch_flush(spritebatch_t* sb);\n\n// All textures created so far by `spritebatch_flush` will be considered as candidates for creating\n// new internal texture atlases. Internal texture atlases compress images together inside of one\n// texture to dramatically reduce draw calls. When an atlas is created, the most recently used `image_id`\n// instances are prioritized, to ensure atlases are filled with images all drawn at the same time.\n// As some textures cease to draw on screen, they \"decay\" over time. Once enough images in an atlas\n// decay, the atlas is removed, and any \"live\" images in the atlas are used to create new atlases.\n// Can be called every 1/N times `spritebatch_flush` is called.\nint spritebatch_defrag(spritebatch_t* sb);\n\nint spritebatch_init(spritebatch_t* sb, spritebatch_config_t* config, void* udata);\nvoid spritebatch_term(spritebatch_t* sb);\n\ntypedef struct spritebatch_premade_sprite_t\n{\n\t// `image_id` must be a unique identifier for the image a sprite references. This id is *not* local\n\t// to a particular atlas, and instead is global to the entire spritebatch.\n\tSPRITEBATCH_U64 image_id;\n\tint w, h;         // width and height of this sprite's image in pixels\n\tfloat minx, miny; // u coordinate in the premade atlas\n\tfloat maxx, maxy; // v coordinate in the premade atlas\n} spritebatch_premade_sprite_t;\n\n// Registers a premade atlas into the sprite batcher. This function is provided here mostly for\n// convenience. Sometimes you may already have a pre-created atlas and want a simple way to draw all\n// sprites through spritebatch.\n// \n// In terms of performance, premade atlases provide another way to tune the performance of batching.\n// If you know ahead of time it's better to inject a premade atlas into the spritebatch, instead of\n// using `spritebatch_push`, this can be a good option. For example, this makes sense for text\n// rendering systems that create their own font texture atlas. Understanding the performance impact\n// can become a lot simpler than flooding `spritebatch_push` with a lot of unique glyphs used briefly.\nvoid spritebatch_register_premade_atlas(spritebatch_t* sb, SPRITEBATCH_U64 texture_id, int w, int h, int sprite_count, spritebatch_premade_sprite_t* sprites);\n\n// Sprite batches are submit via synchronous callback back to the user. This function is called\n// from inside `spritebatch_flush`. Each time `submit_batch_fn` is called an array of sprites\n// is handed to the user. The sprites are intended to be further sorted by the user as desired\n// (for example, additional sorting based on depth). `w` and `h` are the width/height, respectively,\n// of the texture the batch of sprites resides upon. w/h can be useful for knowing texture dim-\n// ensions, which is needed to know texel size or other measurements.\ntypedef void (submit_batch_fn)(spritebatch_sprite_t* sprites, int count, int texture_w, int texture_h, void* udata);\n\n// cute_spritebatch.h needs to know how to get the pixels of an image, generate textures handles (for\n// example glGenTextures for OpenGL), and destroy texture handles. These functions are all called\n// from within the `spritebatch_defrag` function, and sometimes from `spritebatch_flush`.\n\n// Called when the pixels are needed from the user. `image_id` maps to a unique image, and is *not*\n// related to `texture_id` at all. `buffer` must be filled in with `bytes_to_fill` number of bytes.\n// The user is assumed to know the width/height of the image, and can optionally verify that\n// `bytes_to_fill` matches the user's w * h * stride for this particular image.\ntypedef void (get_pixels_fn)(SPRITEBATCH_U64 image_id, void* buffer, int bytes_to_fill, void* udata);\n\n// Called with a new texture handle is needed. This will happen whenever a new atlas is created,\n// and whenever new `image_id`s first appear to cute_spritebatch, and have yet to find their way\n// into an appropriate atlas.\ntypedef SPRITEBATCH_U64 (generate_texture_handle_fn)(void* pixels, int w, int h, void* udata);\n\n// Called whenever a texture handle is ready to be free'd up. This happens whenever a particular image\n// or a particular atlas has not been used for a while, and is ready to be released.\ntypedef void (destroy_texture_handle_fn)(SPRITEBATCH_U64 texture_id, void* udata);\n\n// (Optional) If the user provides this callback, cute_spritebatch will call it to sort all of sprites before submit_batch \n// callback is called. The intention of sorting is to minimize the submit_batch calls. cute_spritebatch\n// provides its own internal sorting function which will be used if the user does not provide this callback.\n// \n// Example using std::sort (C++) - Please note the lambda needs to be a non-capturing one.\n// \n//     config.sprites_sorter_callback = [](spritebatch_sprite_t* sprites, int count)\n//     {\n//         std::sort(sprites, sprites + count,\n//         [](const spritebatch_sprite_t& a, const spritebatch_sprite_t& b) {\n//             if (a.sort_bits < b.sort_bits) return true;\n//             if (a.sort_bits == b.sort_bits && a.texture_id < b.texture_id) return true;\n//             return false;\n//         });\n//     };\ntypedef void (sprites_sorter_fn)(spritebatch_sprite_t* sprites, int count);\n\n// Sets all function pointers originally defined in the `config` struct when calling `spritebatch_init`.\n// Useful if DLL's are reloaded, or swapped, etc.\nvoid spritebatch_reset_function_ptrs(spritebatch_t* sb, submit_batch_fn* batch_callback, get_pixels_fn* get_pixels_callback, generate_texture_handle_fn* generate_texture_callback, destroy_texture_handle_fn* delete_texture_callback, sprites_sorter_fn* sprites_sorter_callback);\n\n// Initializes a set of good default paramaters. The users must still set\n// the four callbacks inside of `config`.\nvoid spritebatch_set_default_config(spritebatch_config_t* config);\n\nstruct spritebatch_config_t\n{\n\tint pixel_stride;\n\tint atlas_width_in_pixels;\n\tint atlas_height_in_pixels;\n\tint atlas_use_border_pixels;\n\tint ticks_to_decay_texture;         // number of ticks it takes for a texture handle to be destroyed via `destroy_texture_handle_fn`\n\tint lonely_buffer_count_till_flush; // Number of unique textures allowed to persist that are not a part of an atlas yet, each one allowed is another draw call.\n\t                                    // These are called \"lonely textures\", since they don't belong to any atlas yet. Set this to 0 if you want all textures to be\n\t                                    // immediately put into atlases. Setting a higher number, like 64, will buffer up 64 unique textures (which means up to an\n\t                                    // additional 64 draw calls) before flushing them into atlases. Too low of a lonely buffer count combined with a low tick\n\t                                    // to decay rate will cause performance problems where atlases are constantly created and immedately destroyed -- you have\n\t                                    // been warned! Use `SPRITEBATCH_LOG` to gain some insight on what's going on inside the spritebatch when tuning these settings.\n\tfloat ratio_to_decay_atlas;         // from 0 to 1, once ratio is less than `ratio_to_decay_atlas`, flush active textures in atlas to lonely buffer\n\tfloat ratio_to_merge_atlases;       // from 0 to 0.5, attempts to merge atlases with some ratio of empty space\n\tsubmit_batch_fn* batch_callback;\n\tget_pixels_fn* get_pixels_callback;\n\tgenerate_texture_handle_fn* generate_texture_callback;\n\tdestroy_texture_handle_fn* delete_texture_callback;\n\tsprites_sorter_fn* sprites_sorter_callback; // (Optional)\n\tvoid* allocator_context;\n};\n\n#define SPRITEBATCH_H\n#endif\n\n#if !defined(SPRITE_BATCH_INTERNAL_H)\n\n// hashtable.h implementation by Mattias Gustavsson\n// See: http://www.mattiasgustavsson.com/ and https://github.com/mattiasgustavsson/libs/blob/master/hashtable.h\n// begin hashtable.h\n\n/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nhashtable.h - v1.1 - Cache efficient hash table implementation for C/C++.\n\nDo this:\n    #define HASHTABLE_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef hashtable_h\n#define hashtable_h\n\n#ifndef HASHTABLE_U64\n    #define HASHTABLE_U64 unsigned long long\n#endif\n\ntypedef struct hashtable_t hashtable_t;\n\nvoid hashtable_init( hashtable_t* table, int item_size, int initial_capacity, void* memctx );\nvoid hashtable_term( hashtable_t* table );\n\nvoid* hashtable_insert( hashtable_t* table, HASHTABLE_U64 key, void const* item );\nvoid hashtable_remove( hashtable_t* table, HASHTABLE_U64 key );\nvoid hashtable_clear( hashtable_t* table );\n\nvoid* hashtable_find( hashtable_t const* table, HASHTABLE_U64 key );\n\nint hashtable_count( hashtable_t const* table );\nvoid* hashtable_items( hashtable_t const* table );\nHASHTABLE_U64 const* hashtable_keys( hashtable_t const* table );\n\nvoid hashtable_swap( hashtable_t* table, int index_a, int index_b );\n\n\n#endif /* hashtable_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef hashtable_t_h\n#define hashtable_t_h\n\n#ifndef HASHTABLE_U32\n    #define HASHTABLE_U32 unsigned int\n#endif\n\nstruct hashtable_internal_slot_t\n    {\n    HASHTABLE_U32 key_hash;\n    int item_index;\n    int base_count;\n    };\n\nstruct hashtable_t\n    {\n    void* memctx;\n    int count;\n    int item_size;\n\n    struct hashtable_internal_slot_t* slots;\n    int slot_capacity;\n\n    HASHTABLE_U64* items_key;\n    int* items_slot;\n    void* items_data;\n    int item_capacity;\n\n    void* swap_temp;\n    };\n\n#endif /* hashtable_t_h */\n\n// end hashtable.h (more later)\n\ntypedef struct spritebatch_internal_sprite_t\n{\n\tSPRITEBATCH_U64 image_id;\n\tint sort_bits;\n\tSPRITEBATCH_SPRITE_GEOMETRY geom;\n\tint w, h;                         // w/h of image in pixels\n\tfloat premade_minx, premade_miny; // u coordinate for premade \n\tfloat premade_maxx, premade_maxy; // v coordinate for premade\n#ifdef SPRITEBATCH_SPRITE_USERDATA\n\tSPRITEBATCH_SPRITE_USERDATA udata;\n#endif // SPRITEBATCH_SPRITE_USERDATA\n} spritebatch_internal_sprite_t;\n\ntypedef struct spritebatch_internal_texture_t\n{\n\tint timestamp;\n\tint w, h;\n\tfloat minx, miny;\n\tfloat maxx, maxy;\n\tSPRITEBATCH_U64 image_id;\n} spritebatch_internal_texture_t;\n\ntypedef struct spritebatch_internal_atlas_t\n{\n\tSPRITEBATCH_U64 texture_id;\n\tfloat volume_ratio;\n\thashtable_t sprites_to_textures;\n\tstruct spritebatch_internal_atlas_t* next;\n\tstruct spritebatch_internal_atlas_t* prev;\n} spritebatch_internal_atlas_t;\n\ntypedef struct spritebatch_internal_lonely_texture_t\n{\n\tint timestamp;\n\tint w, h;\n\tSPRITEBATCH_U64 image_id;\n\tSPRITEBATCH_U64 texture_id;\n} spritebatch_internal_lonely_texture_t;\n\ntypedef struct spritebatch_internal_premade_sprite_t\n{\n\tint atlas_w, atlas_h;\n\tfloat minx, miny;\n\tfloat maxx, maxy;\n\tSPRITEBATCH_U64 texture_id;\n} spritebatch_internal_premade_sprite_t;\n\nstruct spritebatch_t\n{\n\tint input_count;\n\tint input_capacity;\n\tspritebatch_internal_sprite_t* input_buffer;\n\n\tint sprite_count;\n\tint sprite_capacity;\n\tspritebatch_sprite_t* sprites;\n\tspritebatch_sprite_t* sprites_scratch;\n\n\tint key_buffer_count;\n\tint key_buffer_capacity;\n\tSPRITEBATCH_U64* key_buffer;\n\n\tint pixel_buffer_size; // number of pixels\n\tvoid* pixel_buffer;\n\n\thashtable_t sprites_to_premades;\n\thashtable_t sprites_to_lonely_textures;\n\thashtable_t sprites_to_atlases;\n\n\tspritebatch_internal_atlas_t* atlases;\n\n\tint pixel_stride;\n\tint atlas_width_in_pixels;\n\tint atlas_height_in_pixels;\n\tint atlas_use_border_pixels;\n\tint ticks_to_decay_texture;\n\tint lonely_buffer_count_till_flush;\n\tint lonely_buffer_count_till_decay;\n\tfloat ratio_to_decay_atlas;\n\tfloat ratio_to_merge_atlases;\n\tsubmit_batch_fn* batch_callback;\n\tget_pixels_fn* get_pixels_callback;\n\tgenerate_texture_handle_fn* generate_texture_callback;\n\tdestroy_texture_handle_fn* delete_texture_callback;\n\tsprites_sorter_fn* sprites_sorter_callback;\n\tvoid* mem_ctx;\n\tvoid* udata;\n};\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\n\t#define _CRT_NONSTDC_NO_DEPRECATE\n#endif\n\n#ifndef SPRITEBATCH_MALLOC\n\t#include <stdlib.h>\n\t#define SPRITEBATCH_MALLOC(size, ctx) malloc(size)\n\t#define SPRITEBATCH_FREE(ptr, ctx) free(ptr)\n#endif\n\n#ifndef SPRITEBATCH_MEMCPY\n\t#include <string.h>\n\t#define SPRITEBATCH_MEMCPY(dst, src, n) memcpy(dst, src, n)\n#endif\n\n#ifndef SPRITEBATCH_MEMSET\n\t#include <string.h>\n\t#define SPRITEBATCH_MEMSET(ptr, val, n) memset(ptr, val, n)\n#endif\n\n#ifndef SPRITEBATCH_MEMMOVE\n\t#include <string.h>\n\t#define SPRITEBATCH_MEMMOVE(dst, src, n) memmove(dst, src, n)\n#endif\n\n#ifndef SPRITEBATCH_ASSERT\n\t#include <assert.h>\n\t#define SPRITEBATCH_ASSERT(condition) assert(condition)\n#endif\n\n// flips output uv coordinate's y. Can be useful to \"flip image on load\"\n#ifndef SPRITEBATCH_ATLAS_FLIP_Y_AXIS_FOR_UV\n\t#define SPRITEBATCH_ATLAS_FLIP_Y_AXIS_FOR_UV 1\n#endif\n\n// flips output uv coordinate's y. Can be useful to \"flip image on load\"\n#ifndef SPRITEBATCH_LONELY_FLIP_Y_AXIS_FOR_UV\n\t#define SPRITEBATCH_LONELY_FLIP_Y_AXIS_FOR_UV 1\n#endif\n\n#ifndef SPRITEBATCH_ATLAS_EMPTY_COLOR\n\t#define SPRITEBATCH_ATLAS_EMPTY_COLOR 0x00000000\n#endif\n\n#ifndef SPRITEBATCH_LOG\n\t#if 0\n\t\t#define SPRITEBATCH_LOG printf\n\t#else\n\t\t#define SPRITEBATCH_LOG(...)\n\t#endif\n#endif\n\n#ifndef HASHTABLE_MEMSET\n\t#define HASHTABLE_MEMSET(ptr, val, n) SPRITEBATCH_MEMSET(ptr, val, n)\n#endif\n\n#ifndef HASHTABLE_MEMCPY\n\t#define HASHTABLE_MEMCPY(dst, src, n) SPRITEBATCH_MEMCPY(dst, src, n)\n#endif\n\n#ifndef HASHTABLE_MALLOC\n\t#define HASHTABLE_MALLOC(ctx, size) SPRITEBATCH_MALLOC(size, ctx)\n#endif\n\n#ifndef HASHTABLE_FREE\n\t#define HASHTABLE_FREE(ctx, ptr) SPRITEBATCH_FREE(ptr, ctx)\n#endif\n\n#define SPRITE_BATCH_INTERNAL_H\n#endif\n\n#ifdef SPRITEBATCH_IMPLEMENTATION\n#ifndef SPRITEBATCH_IMPLEMENTATION_ONCE\n#define SPRITEBATCH_IMPLEMENTATION_ONCE\n\n#define HASHTABLE_IMPLEMENTATION\n\n#ifdef HASHTABLE_IMPLEMENTATION\n#ifndef HASHTABLE_IMPLEMENTATION_ONCE\n#define HASHTABLE_IMPLEMENTATION_ONCE\n\n// hashtable.h implementation by Mattias Gustavsson\n// See: http://www.mattiasgustavsson.com/ and https://github.com/mattiasgustavsson/libs/blob/master/hashtable.h\n// begin hashtable.h (continuing from first time)\n\n#ifndef HASHTABLE_SIZE_T\n    #include <stddef.h>\n    #define HASHTABLE_SIZE_T size_t\n#endif\n\n#ifndef HASHTABLE_ASSERT\n    #include <assert.h>\n    #define HASHTABLE_ASSERT( x ) assert( x )\n#endif\n\n#ifndef HASHTABLE_MEMSET\n    #include <string.h>\n    #define HASHTABLE_MEMSET( ptr, val, cnt ) ( memset( ptr, val, cnt ) )\n#endif \n\n#ifndef HASHTABLE_MEMCPY\n    #include <string.h>\n    #define HASHTABLE_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef HASHTABLE_MALLOC\n    #include <stdlib.h>\n    #define HASHTABLE_MALLOC( ctx, size ) ( malloc( size ) )\n    #define HASHTABLE_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\nstatic HASHTABLE_U32 hashtable_internal_pow2ceil( HASHTABLE_U32 v )\n    {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n    }\n\n\nvoid hashtable_init( hashtable_t* table, int item_size, int initial_capacity, void* memctx )\n    {\n    initial_capacity = (int)hashtable_internal_pow2ceil( initial_capacity >=0 ? (HASHTABLE_U32) initial_capacity : 32U );\n    table->memctx = memctx;\n    table->count = 0;\n    table->item_size = item_size;\n    table->slot_capacity = (int) hashtable_internal_pow2ceil( (HASHTABLE_U32) ( initial_capacity + initial_capacity / 2 ) );\n    int slots_size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n    table->slots = (struct hashtable_internal_slot_t*) HASHTABLE_MALLOC( table->memctx, (HASHTABLE_SIZE_T) slots_size );\n    HASHTABLE_ASSERT( table->slots );\n    HASHTABLE_MEMSET( table->slots, 0, (HASHTABLE_SIZE_T) slots_size );\n    table->item_capacity = (int) hashtable_internal_pow2ceil( (HASHTABLE_U32) initial_capacity );\n    table->items_key = (HASHTABLE_U64*) HASHTABLE_MALLOC( table->memctx,\n        table->item_capacity * ( sizeof( *table->items_key ) + sizeof( *table->items_slot ) + table->item_size ) + table->item_size );\n    HASHTABLE_ASSERT( table->items_key );\n    table->items_slot = (int*)( table->items_key + table->item_capacity );\n    table->items_data = (void*)( table->items_slot + table->item_capacity );\n    table->swap_temp = (void*)( ( (uintptr_t) table->items_data ) + table->item_size * table->item_capacity ); \n    }\n\n\nvoid hashtable_term( hashtable_t* table )\n    {\n    HASHTABLE_FREE( table->memctx, table->items_key );\n    HASHTABLE_FREE( table->memctx, table->slots );\n    }\n\n\n// from https://gist.github.com/badboy/6267743\nstatic HASHTABLE_U32 hashtable_internal_calculate_hash( HASHTABLE_U64 key )\n    {\n    key = ( ~key ) + ( key << 18 );\n    key = key ^ ( key >> 31 );\n    key = key * 21;\n    key = key ^ ( key >> 11 );\n    key = key + ( key << 6 );\n    key = key ^ ( key >> 22 );  \n    HASHTABLE_ASSERT( key );\n    return (HASHTABLE_U32) key;\n    }\n\n\nstatic int hashtable_internal_find_slot( hashtable_t const* table, HASHTABLE_U64 key )\n    {\n    int const slot_mask = table->slot_capacity - 1;\n    HASHTABLE_U32 const hash = hashtable_internal_calculate_hash( key );\n\n    int const base_slot = (int)( hash & (HASHTABLE_U32)slot_mask );\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n\n    while( base_count > 0 )\n        {\n        HASHTABLE_U32 slot_hash = table->slots[ slot ].key_hash;\n        if( slot_hash )\n            {\n            int slot_base = (int)( slot_hash & (HASHTABLE_U32)slot_mask );\n            if( slot_base == base_slot ) \n                {\n                HASHTABLE_ASSERT( base_count > 0 );\n                --base_count;\n                if( slot_hash == hash && table->items_key[ table->slots[ slot ].item_index ] == key )\n                    return slot;\n                }\n            }\n        slot = ( slot + 1 ) & slot_mask;\n        }   \n\n    return -1;\n    }\n\n\nstatic void hashtable_internal_expand_slots( hashtable_t* table )\n    {\n    int const old_capacity = table->slot_capacity;\n    struct hashtable_internal_slot_t* old_slots = table->slots;\n\n    table->slot_capacity *= 2;\n    int const slot_mask = table->slot_capacity - 1;\n\n    int const size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n    table->slots = (struct hashtable_internal_slot_t*) HASHTABLE_MALLOC( table->memctx, (HASHTABLE_SIZE_T) size );\n    HASHTABLE_ASSERT( table->slots );\n    HASHTABLE_MEMSET( table->slots, 0, (HASHTABLE_SIZE_T) size );\n\n    for( int i = 0; i < old_capacity; ++i )\n        {\n        HASHTABLE_U32 const hash = old_slots[ i ].key_hash;\n        if( hash )\n            {\n            int const base_slot = (int)( hash & (HASHTABLE_U32)slot_mask );\n            int slot = base_slot;\n            while( table->slots[ slot ].key_hash )\n                slot = ( slot + 1 ) & slot_mask;\n            table->slots[ slot ].key_hash = hash;\n            int item_index = old_slots[ i ].item_index;\n            table->slots[ slot ].item_index = item_index;\n            table->items_slot[ item_index ] = slot; \n            ++table->slots[ base_slot ].base_count;\n            }               \n        }\n\n    HASHTABLE_FREE( table->memctx, old_slots );\n    }\n\n\nstatic void hashtable_internal_expand_items( hashtable_t* table )\n    {\n    table->item_capacity *= 2;\n     HASHTABLE_U64* const new_items_key = (HASHTABLE_U64*) HASHTABLE_MALLOC( table->memctx, \n         table->item_capacity * ( sizeof( *table->items_key ) + sizeof( *table->items_slot ) + table->item_size ) + table->item_size);\n    HASHTABLE_ASSERT( new_items_key );\n\n    int* const new_items_slot = (int*)( new_items_key + table->item_capacity );\n    void* const new_items_data = (void*)( new_items_slot + table->item_capacity );\n    void* const new_swap_temp = (void*)( ( (uintptr_t) new_items_data ) + table->item_size * table->item_capacity ); \n\n    HASHTABLE_MEMCPY( new_items_key, table->items_key, table->count * sizeof( *table->items_key ) );\n    HASHTABLE_MEMCPY( new_items_slot, table->items_slot, table->count * sizeof( *table->items_key ) );\n    HASHTABLE_MEMCPY( new_items_data, table->items_data, (HASHTABLE_SIZE_T) table->count * table->item_size );\n    \n    HASHTABLE_FREE( table->memctx, table->items_key );\n\n    table->items_key = new_items_key;\n    table->items_slot = new_items_slot;\n    table->items_data = new_items_data;\n    table->swap_temp = new_swap_temp;\n    }\n\n\nvoid* hashtable_insert( hashtable_t* table, HASHTABLE_U64 key, void const* item )\n    {\n    HASHTABLE_ASSERT( hashtable_internal_find_slot( table, key ) < 0 );\n\n    if( table->count >= ( table->slot_capacity - table->slot_capacity / 3 ) )\n        hashtable_internal_expand_slots( table );\n        \n    int const slot_mask = table->slot_capacity - 1;\n    HASHTABLE_U32 const hash = hashtable_internal_calculate_hash( key );\n\n    int const base_slot = (int)( hash & (HASHTABLE_U32)slot_mask );\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n    int first_free = slot;\n    while( base_count )\n        {\n        HASHTABLE_U32 const slot_hash = table->slots[ slot ].key_hash;\n        if( slot_hash == 0 && table->slots[ first_free ].key_hash != 0 ) first_free = slot;\n        int slot_base = (int)( slot_hash & (HASHTABLE_U32)slot_mask );\n        if( slot_base == base_slot ) \n            --base_count;\n        slot = ( slot + 1 ) & slot_mask;\n        }       \n\n    slot = first_free;\n    while( table->slots[ slot ].key_hash )\n        slot = ( slot + 1 ) & slot_mask;\n\n    if( table->count >= table->item_capacity )\n        hashtable_internal_expand_items( table );\n\n    HASHTABLE_ASSERT( !table->slots[ slot ].key_hash && ( hash & (HASHTABLE_U32) slot_mask ) == (HASHTABLE_U32) base_slot );\n    HASHTABLE_ASSERT( hash );\n    table->slots[ slot ].key_hash = hash;\n    table->slots[ slot ].item_index = table->count;\n    ++table->slots[ base_slot ].base_count;\n\n\n    void* dest_item = (void*)( ( (uintptr_t) table->items_data ) + table->count * table->item_size );\n    memcpy( dest_item, item, (HASHTABLE_SIZE_T) table->item_size );\n    table->items_key[ table->count ] = key;\n    table->items_slot[ table->count ] = slot;\n    ++table->count;\n    return dest_item;\n    } \n\n\nvoid hashtable_remove( hashtable_t* table, HASHTABLE_U64 key )\n    {\n    int const slot = hashtable_internal_find_slot( table, key );\n    HASHTABLE_ASSERT( slot >= 0 );\n\n    int const slot_mask = table->slot_capacity - 1;\n    HASHTABLE_U32 const hash = table->slots[ slot ].key_hash;\n    int const base_slot = (int)( hash & (HASHTABLE_U32) slot_mask );\n    HASHTABLE_ASSERT( hash );\n    --table->slots[ base_slot ].base_count;\n    table->slots[ slot ].key_hash = 0;\n\n    int index = table->slots[ slot ].item_index;\n    int last_index = table->count - 1;\n    if( index != last_index )\n        {\n        table->items_key[ index ] = table->items_key[ last_index ];\n        table->items_slot[ index ] = table->items_slot[ last_index ];\n        void* dst_item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n        void* src_item = (void*)( ( (uintptr_t) table->items_data ) + last_index * table->item_size );\n        HASHTABLE_MEMCPY( dst_item, src_item, (HASHTABLE_SIZE_T) table->item_size );\n        table->slots[ table->items_slot[ last_index ] ].item_index = index;\n        }\n    --table->count;\n    } \n\n\nvoid hashtable_clear( hashtable_t* table )\n    {\n    table->count = 0;\n    HASHTABLE_MEMSET( table->slots, 0, table->slot_capacity * sizeof( *table->slots ) );\n    }\n\n\nvoid* hashtable_find( hashtable_t const* table, HASHTABLE_U64 key )\n    {\n    int const slot = hashtable_internal_find_slot( table, key );\n    if( slot < 0 ) return 0;\n\n    int const index = table->slots[ slot ].item_index;\n    void* const item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n    return item;\n    }\n\n\nint hashtable_count( hashtable_t const* table )\n    {\n    return table->count;\n    }\n\n\nvoid* hashtable_items( hashtable_t const* table )\n    {\n    return table->items_data;\n    }\n\n\nHASHTABLE_U64 const* hashtable_keys( hashtable_t const* table )\n    {\n    return table->items_key;\n    }\n\n\nvoid hashtable_swap( hashtable_t* table, int index_a, int index_b )\n    {\n    if( index_a < 0 || index_a >= table->count || index_b < 0 || index_b >= table->count ) return;\n\n    int slot_a = table->items_slot[ index_a ];\n    int slot_b = table->items_slot[ index_b ];\n\n    table->items_slot[ index_a ] = slot_b;\n    table->items_slot[ index_b ] = slot_a;\n\n    HASHTABLE_U64 temp_key = table->items_key[ index_a ];\n    table->items_key[ index_a ] = table->items_key[ index_b ];\n    table->items_key[ index_b ] = temp_key;\n\n    void* item_a = (void*)( ( (uintptr_t) table->items_data ) + index_a * table->item_size );\n    void* item_b = (void*)( ( (uintptr_t) table->items_data ) + index_b * table->item_size );\n    HASHTABLE_MEMCPY( table->swap_temp, item_a, table->item_size );\n    HASHTABLE_MEMCPY( item_a, item_b, table->item_size );\n    HASHTABLE_MEMCPY( item_b, table->swap_temp, table->item_size );\n\n    table->slots[ slot_a ].item_index = index_b;\n    table->slots[ slot_b ].item_index = index_a;\n    }\n\n\n#endif /* HASHTABLE_IMPLEMENTATION */\n#endif // HASHTABLE_IMPLEMENTATION_ONCE\n\n/*\n\ncontributors:\n    Randy Gaul (hashtable_clear, hashtable_swap )\n\nrevision history:\n    1.1     added hashtable_clear, hashtable_swap\n    1.0     first released version  \n\n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n\n// end of hashtable.h\n\n#include <stdbool.h>\n\nbool sprite_batch_internal_use_scratch_buffer(spritebatch_t* sb)\n{\n\treturn sb->sprites_sorter_callback == 0;\n}\n\nint spritebatch_init(spritebatch_t* sb, spritebatch_config_t* config, void* udata)\n{\n\t// read config params\n\tif (!config | !sb) return 1;\n\tsb->pixel_stride = config->pixel_stride;\n\tsb->atlas_width_in_pixels = config->atlas_width_in_pixels;\n\tsb->atlas_height_in_pixels = config->atlas_height_in_pixels;\n\tsb->atlas_use_border_pixels = config->atlas_use_border_pixels;\n\tsb->ticks_to_decay_texture = config->ticks_to_decay_texture;\n\tsb->lonely_buffer_count_till_flush = config->lonely_buffer_count_till_flush;\n\tsb->lonely_buffer_count_till_decay = sb->lonely_buffer_count_till_flush / 2;\n\tif (sb->lonely_buffer_count_till_decay <= 0) sb->lonely_buffer_count_till_decay = 1;\n\tsb->ratio_to_decay_atlas = config->ratio_to_decay_atlas;\n\tsb->ratio_to_merge_atlases = config->ratio_to_merge_atlases;\n\tsb->batch_callback = config->batch_callback;\n\tsb->get_pixels_callback = config->get_pixels_callback;\n\tsb->generate_texture_callback = config->generate_texture_callback;\n\tsb->delete_texture_callback = config->delete_texture_callback;\n\tsb->sprites_sorter_callback = config->sprites_sorter_callback;\n\tsb->mem_ctx = config->allocator_context;\n\tsb->udata = udata;\n\n\tif (sb->atlas_width_in_pixels < 1 || sb->atlas_height_in_pixels < 1) return 1;\n\tif (sb->ticks_to_decay_texture < 1) return 1;\n\tif (sb->ratio_to_decay_atlas < 0 || sb->ratio_to_decay_atlas > 1.0f) return 1;\n\tif (sb->ratio_to_merge_atlases < 0 || sb->ratio_to_merge_atlases > 0.5f) return 1;\n\tif (!sb->batch_callback) return 1;\n\tif (!sb->get_pixels_callback) return 1;\n\tif (!sb->generate_texture_callback) return 1;\n\tif (!sb->delete_texture_callback) return 1;\n\n\t// initialize input buffer\n\tsb->input_count = 0;\n\tsb->input_capacity = 1024;\n\tsb->input_buffer = (spritebatch_internal_sprite_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_sprite_t) * sb->input_capacity, sb->mem_ctx);\n\tif (!sb->input_buffer) return 1;\n\n\t// initialize sprite buffer\n\tsb->sprite_count = 0;\n\tsb->sprite_capacity = 1024;\n\tsb->sprites = (spritebatch_sprite_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_sprite_t) * sb->sprite_capacity, sb->mem_ctx);\n\n\tsb->sprites_scratch = 0;\n\tif (sprite_batch_internal_use_scratch_buffer(sb))\n\t{\n\t\tsb->sprites_scratch = (spritebatch_sprite_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_sprite_t) * sb->sprite_capacity, sb->mem_ctx);\n\t}\n\tif (!sb->sprites) return 1;\n\n\tif (sprite_batch_internal_use_scratch_buffer(sb))\n\t{\n\t\tif (!sb->sprites_scratch) return 1;\n\t}\n\n\t// initialize key buffer (for marking hash table entries for deletion)\n\tsb->key_buffer_count = 0;\n\tsb->key_buffer_capacity = 1024;\n\tsb->key_buffer = (SPRITEBATCH_U64*)SPRITEBATCH_MALLOC(sizeof(SPRITEBATCH_U64) * sb->key_buffer_capacity, sb->mem_ctx);\n\n\t// initialize pixel buffer for grabbing pixel data from the user as needed\n\tsb->pixel_buffer_size = 1024;\n\tsb->pixel_buffer = SPRITEBATCH_MALLOC(sb->pixel_buffer_size * sb->pixel_stride, sb->mem_ctx);\n\n\t// setup tables\n\thashtable_init(&sb->sprites_to_lonely_textures, sizeof(spritebatch_internal_lonely_texture_t), 1024, sb->mem_ctx);\n\thashtable_init(&sb->sprites_to_premades, sizeof(spritebatch_internal_premade_sprite_t), 1024 * 10, sb->mem_ctx);\n\thashtable_init(&sb->sprites_to_atlases, sizeof(spritebatch_internal_atlas_t*), 16, sb->mem_ctx);\n\n\tsb->atlases = 0;\n\n\treturn 0;\n}\n\nvoid spritebatch_term(spritebatch_t* sb)\n{\n\tSPRITEBATCH_FREE(sb->input_buffer, sb->mem_ctx);\n\tSPRITEBATCH_FREE(sb->sprites, sb->mem_ctx);\n\tif (sb->sprites_scratch)\n\t{\n\t\tSPRITEBATCH_FREE(sb->sprites_scratch, sb->mem_ctx);\n\t}\n\tSPRITEBATCH_FREE(sb->key_buffer, sb->mem_ctx);\n\tSPRITEBATCH_FREE(sb->pixel_buffer, ctx->mem_ctx);\n\thashtable_term(&sb->sprites_to_lonely_textures);\n\thashtable_term(&sb->sprites_to_premades);\n\thashtable_term(&sb->sprites_to_atlases);\n\n\tif (sb->atlases)\n\t{\n\t\tspritebatch_internal_atlas_t* atlas = sb->atlases;\n\t\tspritebatch_internal_atlas_t* sentinel = sb->atlases;\n\t\tdo\n\t\t{\n\t\t\thashtable_term(&atlas->sprites_to_textures);\n\t\t\tspritebatch_internal_atlas_t* next = atlas->next;\n\t\t\tSPRITEBATCH_FREE(atlas, sb->mem_ctx);\n\t\t\tatlas = next;\n\t\t}\n\t\twhile (atlas != sentinel);\n\t}\n\n\tSPRITEBATCH_MEMSET(sb, 0, sizeof(spritebatch_t));\n}\n\nvoid spritebatch_reset_function_ptrs(spritebatch_t* sb, submit_batch_fn* batch_callback, get_pixels_fn* get_pixels_callback, generate_texture_handle_fn* generate_texture_callback, destroy_texture_handle_fn* delete_texture_callback, sprites_sorter_fn* sprites_sorter_callback)\n{\n\tsb->batch_callback = batch_callback;\n\tsb->get_pixels_callback = get_pixels_callback;\n\tsb->generate_texture_callback = generate_texture_callback;\n\tsb->delete_texture_callback = delete_texture_callback;\n\tsb->sprites_sorter_callback = sprites_sorter_callback;\n}\n\nvoid spritebatch_set_default_config(spritebatch_config_t* config)\n{\n\tconfig->pixel_stride = sizeof(char) * 4;\n\tconfig->atlas_width_in_pixels = 2048;\n\tconfig->atlas_height_in_pixels = 2048;\n\tconfig->atlas_use_border_pixels = 0;\n\tconfig->ticks_to_decay_texture = 60 * 30;\n\tconfig->lonely_buffer_count_till_flush = 64;\n\tconfig->ratio_to_decay_atlas = 0.5f;\n\tconfig->ratio_to_merge_atlases = 0.25f;\n\tconfig->batch_callback = 0;\n\tconfig->generate_texture_callback = 0;\n\tconfig->delete_texture_callback = 0;\n\tconfig->sprites_sorter_callback = 0;\n\tconfig->allocator_context = 0;\n}\n\n#define SPRITEBATCH_CHECK_BUFFER_GROW(ctx, count, capacity, data, type) \\\n\tdo { \\\n\t\tif (ctx->count == ctx->capacity) \\\n\t\t{ \\\n\t\t\tint new_capacity = ctx->capacity * 2; \\\n\t\t\tvoid* new_data = SPRITEBATCH_MALLOC(sizeof(type) * new_capacity, ctx->mem_ctx); \\\n\t\t\tif (!new_data) return 0; \\\n\t\t\tSPRITEBATCH_MEMCPY(new_data, ctx->data, sizeof(type) * ctx->count); \\\n\t\t\tSPRITEBATCH_FREE(ctx->data, ctx->mem_ctx); \\\n\t\t\tctx->data = (type*)new_data; \\\n\t\t\tctx->capacity = new_capacity; \\\n\t\t} \\\n\t} while (0)\n\n\nint spritebatch_internal_fill_internal_sprite(spritebatch_t* sb, spritebatch_sprite_t sprite, spritebatch_internal_sprite_t* out)\n{\n\tSPRITEBATCH_ASSERT(sprite.w <= sb->atlas_width_in_pixels);\n\tSPRITEBATCH_ASSERT(sprite.h <= sb->atlas_height_in_pixels);\n\tSPRITEBATCH_CHECK_BUFFER_GROW(sb, input_count, input_capacity, input_buffer, spritebatch_internal_sprite_t);\n\n\tout->image_id = sprite.image_id;\n\tout->sort_bits = sprite.sort_bits;\n\tout->geom = sprite.geom;\n\tout->w = sprite.w;\n\tout->h = sprite.h;\n#ifdef SPRITEBATCH_SPRITE_GEOMETRY_DEFAULT\n\tout->geom.sx = sprite.geom.sx + (sb->atlas_use_border_pixels ? (sprite.geom.sx / (float)sprite.w) * 2.0f : 0);\n\tout->geom.sy = sprite.geom.sy + (sb->atlas_use_border_pixels ? (sprite.geom.sy / (float)sprite.h) * 2.0f : 0);\n#endif\n\n\tout->premade_minx = sprite.minx;\n\tout->premade_miny = sprite.miny;\n\tout->premade_maxx = sprite.maxx;\n\tout->premade_maxy = sprite.maxy;\n\n#ifdef SPRITEBATCH_SPRITE_USERDATA\n\tout->udata = sprite.udata;\n#endif\n\n\treturn 1;\n}\n\nvoid spritebatch_internal_append_sprite(spritebatch_t* sb, spritebatch_internal_sprite_t sprite)\n{\n\tsb->input_buffer[sb->input_count++] = sprite;\n}\n\nint spritebatch_push(spritebatch_t* sb, spritebatch_sprite_t sprite)\n{\n\tspritebatch_internal_sprite_t sprite_out;\n\tspritebatch_internal_fill_internal_sprite(sb, sprite, &sprite_out);\n\tsb->input_buffer[sb->input_count++] = sprite_out;\n\treturn 1;\n}\n\nvoid spritebatch_register_premade_atlas(spritebatch_t* sb, SPRITEBATCH_U64 texture_id, int w, int h, int sprite_count, spritebatch_premade_sprite_t* sprites)\n{\n\tfor (int i = 0; i < sprite_count; ++i) {\n\t\tspritebatch_internal_premade_sprite_t premade;\n\t\tpremade.atlas_w = w;\n\t\tpremade.atlas_h = h;\n\t\tpremade.minx = sprites[i].minx;\n\t\tpremade.miny = sprites[i].miny;\n\t\tpremade.maxx = sprites[i].maxx;\n\t\tpremade.maxy = sprites[i].maxy;\n\t\tpremade.texture_id = texture_id;\n\t\tvoid* find = hashtable_find(&sb->sprites_to_premades, sprites[i].image_id);\n\t\tif (find) {\n\t\t\tSPRITEBATCH_MEMCPY(find, &premade, sizeof(premade));\n\t\t} else {\n\t\t\thashtable_insert(&sb->sprites_to_premades, sprites[i].image_id, &premade);\n\t\t}\n\t}\n}\n\nint spritebatch_internal_lonely_sprite(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h, spritebatch_sprite_t* sprite_out, int skip_missing_textures);\nspritebatch_internal_premade_sprite_t* spritebatch_internal_premade_sprite(spritebatch_t* sb, SPRITEBATCH_U64 image_id, spritebatch_sprite_t* sprite_out);\n\nvoid spritebatch_prefetch(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h)\n{\n\tspritebatch_internal_premade_sprite_t* premade = spritebatch_internal_premade_sprite(sb, image_id, NULL);\n\tif(!premade) {\n\t\tvoid* atlas_ptr = hashtable_find(&sb->sprites_to_atlases, image_id);\n\t\tif (!atlas_ptr) spritebatch_internal_lonely_sprite(sb, image_id, w, h, NULL, 0);\n\t}\n}\n\nspritebatch_sprite_t spritebatch_fetch(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h)\n{\n\tspritebatch_sprite_t s;\n\tSPRITEBATCH_MEMSET(&s, 0, sizeof(s));\n\n\tspritebatch_internal_premade_sprite_t* premade = (spritebatch_internal_premade_sprite_t*)hashtable_find(&sb->sprites_to_premades, image_id);\n\tif(!premade)\n\t{\n\t\tvoid* atlas_ptr = hashtable_find(&sb->sprites_to_atlases, image_id);\n\t\tif (atlas_ptr) {\n\t\t\tspritebatch_internal_atlas_t* atlas = *(spritebatch_internal_atlas_t**)atlas_ptr;\n\t\t\ts.texture_id = atlas->texture_id;\n\n\t\t\tspritebatch_internal_texture_t* tex = (spritebatch_internal_texture_t*)hashtable_find(&atlas->sprites_to_textures, image_id);\n\t\t\tif (tex) {\n\t\t\t\ts.maxx = tex->maxx;\n\t\t\t\ts.maxy = tex->maxy;\n\t\t\t\ts.minx = tex->minx;\n\t\t\t\ts.miny = tex->miny;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tspritebatch_internal_lonely_sprite(sb, image_id, w, h, &s, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tspritebatch_internal_premade_sprite(sb, image_id, &s);\n\t}\n\treturn s;\n}\n\nstatic int spritebatch_internal_sprite_less_than_or_equal(spritebatch_sprite_t* a, spritebatch_sprite_t* b)\n{\n\tif (a->sort_bits <= b->sort_bits) return 1;\n\tif (a->sort_bits == b->sort_bits && a->texture_id <= b->texture_id) return 1;\n\treturn 0;\n}\n\nvoid spritebatch_internal_merge_sort_iteration(spritebatch_sprite_t* a, int lo, int split, int hi, spritebatch_sprite_t* b)\n{\n\tint i = lo, j = split;\n\tfor (int k = lo; k < hi; k++) {\n\t\tif (i < split && (j >= hi || spritebatch_internal_sprite_less_than_or_equal(a + i, a + j))) {\n\t\t\tb[k] = a[i];\n\t\t\ti = i + 1;\n\t\t} else {\n\t\t\tb[k] = a[j];\n\t\t\tj = j + 1;\n\t\t}\n\t}\n}\n\nvoid spritebatch_internal_merge_sort_recurse(spritebatch_sprite_t* b, int lo, int hi, spritebatch_sprite_t* a)\n{\n\tif (hi - lo <= 1) return;\n\tint split = (lo + hi) / 2;\n\tspritebatch_internal_merge_sort_recurse(a, lo,  split, b);\n\tspritebatch_internal_merge_sort_recurse(a, split, hi, b);\n\tspritebatch_internal_merge_sort_iteration(b, lo, split, hi, a);\n}\n\nvoid spritebatch_internal_merge_sort(spritebatch_sprite_t* a, spritebatch_sprite_t* b, int n)\n{\n\tSPRITEBATCH_MEMCPY(b, a, sizeof(spritebatch_sprite_t) * n);\n\tspritebatch_internal_merge_sort_recurse(b, 0, n, a);\n}\n\nvoid spritebatch_internal_sort_sprites(spritebatch_t* sb)\n{\n\tif (sb->sprites_sorter_callback) sb->sprites_sorter_callback(sb->sprites, sb->sprite_count);\n\telse spritebatch_internal_merge_sort(sb->sprites, sb->sprites_scratch, sb->sprite_count);\n}\n\nstatic inline void spritebatch_internal_get_pixels(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h)\n{\n\tint size = sb->atlas_use_border_pixels ? sb->pixel_stride * (w + 2) * (h + 2) : sb->pixel_stride * w * h;\n\tif (size > sb->pixel_buffer_size)\n\t{\n\t\tSPRITEBATCH_FREE(sb->pixel_buffer, ctx->mem_ctx);\n\t\tsb->pixel_buffer_size = size;\n\t\tsb->pixel_buffer = SPRITEBATCH_MALLOC(sb->pixel_buffer_size, ctx->mem_ctx);\n\t\tif (!sb->pixel_buffer) return;\n\t}\n\n\tSPRITEBATCH_MEMSET(sb->pixel_buffer, 0, size);\n\tint size_from_user = sb->pixel_stride * w * h;\n\tsb->get_pixels_callback(image_id, sb->pixel_buffer, size_from_user, sb->udata);\n\n\tif (sb->atlas_use_border_pixels) {\n\t\t// Expand image from top-left corner, offset by (1, 1).\n\t\tint w0 = w;\n\t\tint h0 = h;\n\t\tw += 2;\n\t\th += 2;\n\t\tchar* buffer = (char*)sb->pixel_buffer;\n\t\tint dst_row_stride = w * sb->pixel_stride;\n\t\tint src_row_stride = w0 * sb->pixel_stride;\n\t\tint src_row_offset = sb->pixel_stride;\n\t\tfor (int i = 0; i < h - 2; ++i)\n\t\t{\n\t\t\tchar* src_row = buffer + (h0 - i - 1) * src_row_stride;\n\t\t\tchar* dst_row = buffer + (h - i - 2) * dst_row_stride + src_row_offset;\n\t\t\tSPRITEBATCH_MEMMOVE(dst_row, src_row, src_row_stride);\n\t\t}\n\n\t\t// Clear the border pixels.\n\t\tint pixel_stride = sb->pixel_stride;\n\t\tSPRITEBATCH_MEMSET(buffer, 0, dst_row_stride);\n\t\tfor (int i = 1; i < h - 1; ++i)\n\t\t{\n\t\t\tSPRITEBATCH_MEMSET(buffer + i * dst_row_stride, 0, pixel_stride);\n\t\t\tSPRITEBATCH_MEMSET(buffer + i * dst_row_stride + src_row_stride + src_row_offset, 0, pixel_stride);\n\t\t}\n\t\tSPRITEBATCH_MEMSET(buffer + (h - 1) * dst_row_stride, 0, dst_row_stride);\n\t}\n}\n\nstatic inline SPRITEBATCH_U64 spritebatch_internal_generate_texture_handle(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h)\n{\n\tspritebatch_internal_get_pixels(sb, image_id, w, h);\n\tif (sb->atlas_use_border_pixels)\n\t{\n\t\tw += 2;\n\t\th += 2;\n\t}\n\treturn sb->generate_texture_callback(sb->pixel_buffer, w, h, sb->udata);\n}\n\nspritebatch_internal_lonely_texture_t* spritebatch_internal_lonelybuffer_push(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h, int make_tex)\n{\n\tspritebatch_internal_lonely_texture_t texture;\n\ttexture.timestamp = 0;\n\ttexture.w = w;\n\ttexture.h = h;\n\ttexture.image_id = image_id;\n\ttexture.texture_id = make_tex ? spritebatch_internal_generate_texture_handle(sb, image_id, w, h) : ~0;\n\treturn (spritebatch_internal_lonely_texture_t*)hashtable_insert(&sb->sprites_to_lonely_textures, image_id, &texture);\n}\n\nint spritebatch_internal_lonely_sprite(spritebatch_t* sb, SPRITEBATCH_U64 image_id, int w, int h, spritebatch_sprite_t* sprite_out, int skip_missing_textures)\n{\n\tspritebatch_internal_lonely_texture_t* tex = (spritebatch_internal_lonely_texture_t*)hashtable_find(&sb->sprites_to_lonely_textures, image_id);\n\n\tif (skip_missing_textures)\n\t{\n\t\tif (!tex) spritebatch_internal_lonelybuffer_push(sb, image_id, w, h, 0);\n\t\treturn 1;\n\t}\n\n\telse\n\t{\n\t\tif (!tex) tex = spritebatch_internal_lonelybuffer_push(sb, image_id, w, h, 1);\n\t\telse if (tex->texture_id == ~0) tex->texture_id = spritebatch_internal_generate_texture_handle(sb, image_id, w, h);\n\t\ttex->timestamp = 0;\n\n\t\tif (sprite_out) {\n\t\t\tsprite_out->texture_id = tex->texture_id;\n\t\t\tsprite_out->minx = sprite_out->miny = 0;\n\t\t\tsprite_out->maxx = sprite_out->maxy = 1.0f;\n\n\t\t\tif (SPRITEBATCH_LONELY_FLIP_Y_AXIS_FOR_UV)\n\t\t\t{\n\t\t\t\tfloat tmp = sprite_out->miny;\n\t\t\t\tsprite_out->miny = sprite_out->maxy;\n\t\t\t\tsprite_out->maxy = tmp;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nspritebatch_internal_premade_sprite_t* spritebatch_internal_premade_sprite(spritebatch_t* sb, SPRITEBATCH_U64 image_id, spritebatch_sprite_t* sprite_out)\n{\n\tspritebatch_internal_premade_sprite_t* tex = (spritebatch_internal_premade_sprite_t*)hashtable_find(&sb->sprites_to_premades, image_id);\n\tif (!tex) return NULL;\n\tSPRITEBATCH_ASSERT(tex->texture_id != ~0);\n\tif (sprite_out) {\n\t\tsprite_out->texture_id = tex->texture_id;\n\t}\n\treturn tex;\n}\n\nint spritebatch_internal_push_sprite(spritebatch_t* sb, spritebatch_internal_sprite_t* s, int skip_missing_textures)\n{\n\tint skipped_tex = 0;\n\tspritebatch_sprite_t sprite;\n\tsprite.image_id = s->image_id;\n\tsprite.sort_bits = s->sort_bits;\n\tsprite.geom = s->geom;\n\tsprite.w = s->w;\n\tsprite.h = s->h;\n\n\tsprite.minx = s->premade_minx;\n\tsprite.miny = s->premade_miny;\n\tsprite.maxx = s->premade_maxx;\n\tsprite.maxy = s->premade_maxy;\n\n#ifdef SPRITEBATCH_SPRITE_USERDATA\n\tsprite.udata = s->udata;\n#endif\n\n\tspritebatch_internal_premade_sprite_t* premade = spritebatch_internal_premade_sprite(sb, s->image_id, &sprite);\n\n\tif(!premade)\n\t{\n\t\tvoid* atlas_ptr = hashtable_find(&sb->sprites_to_atlases, s->image_id);\n\t\tif (atlas_ptr)\n\t\t{\n\t\t\tspritebatch_internal_atlas_t* atlas = *(spritebatch_internal_atlas_t**)atlas_ptr;\n\t\t\tsprite.texture_id = atlas->texture_id;\n\n\t\t\tspritebatch_internal_texture_t* tex = (spritebatch_internal_texture_t*)hashtable_find(&atlas->sprites_to_textures, s->image_id);\n\t\t\tSPRITEBATCH_ASSERT(tex);\n\t\t\ttex->timestamp = 0;\n\t\t\tsprite.w = tex->w;\n\t\t\tsprite.h = tex->h;\n\t\t\tsprite.minx = tex->minx;\n\t\t\tsprite.miny = tex->miny;\n\t\t\tsprite.maxx = tex->maxx;\n\t\t\tsprite.maxy = tex->maxy;\n\t\t}\n\t\telse skipped_tex = spritebatch_internal_lonely_sprite(sb, s->image_id, s->w, s->h, &sprite, skip_missing_textures);\n\t}\n\telse\n\t{\n\t\tsprite.texture_id = premade->texture_id;\n\t}\n\n\tif (!skipped_tex)\n\t{\n\t\tif (sb->sprite_count >= sb->sprite_capacity) {\n\t\t\tint new_capacity = sb->sprite_capacity * 2;\n\t\t\tvoid* new_data = SPRITEBATCH_MALLOC(sizeof(spritebatch_sprite_t) * new_capacity, sb->mem_ctx);\n\t\t\tif (!new_data) return 0;\n\t\t\tSPRITEBATCH_MEMCPY(new_data, sb->sprites, sizeof(spritebatch_sprite_t) * sb->sprite_count);\n\t\t\tSPRITEBATCH_FREE(sb->sprites, sb->mem_ctx);\n\t\t\tsb->sprites = (spritebatch_sprite_t*)new_data;\n\t\t\tsb->sprite_capacity = new_capacity;\n\n\t\t\tif (sb->sprites_scratch)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_FREE(sb->sprites_scratch, sb->mem_ctx);\n\t\t\t}\n\n\t\t\tif (sprite_batch_internal_use_scratch_buffer(sb))\n\t\t\t{\n\t\t\t\tsb->sprites_scratch = (spritebatch_sprite_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_sprite_t) * new_capacity, sb->mem_ctx);\n\t\t\t}\n\t\t}\n\t\tsb->sprites[sb->sprite_count++] = sprite;\n\t}\n\n\treturn skipped_tex;\n}\n\nvoid spritebatch_internal_process_input(spritebatch_t* sb, int skip_missing_textures)\n{\n\tint skipped_index = 0;\n\tfor (int i = 0; i < sb->input_count; ++i)\n\t{\n\t\tspritebatch_internal_sprite_t* s = sb->input_buffer + i;\n\t\tint skipped = spritebatch_internal_push_sprite(sb, s, skip_missing_textures);\n\t\tif (skip_missing_textures && skipped) sb->input_buffer[skipped_index++] = *s;\n\t}\n\n\tsb->input_count = skipped_index;\n}\n\nvoid spritebatch_tick(spritebatch_t* sb)\n{\n\tspritebatch_internal_atlas_t* atlas = sb->atlases;\n\tif (atlas)\n\t{\n\t\tspritebatch_internal_atlas_t* sentinel = atlas;\n\t\tdo\n\t\t{\n\t\t\tint texture_count = hashtable_count(&atlas->sprites_to_textures);\n\t\t\tspritebatch_internal_texture_t* textures = (spritebatch_internal_texture_t*)hashtable_items(&atlas->sprites_to_textures);\n\t\t\tfor (int i = 0; i < texture_count; ++i) textures[i].timestamp += 1;\n\t\t\tatlas = atlas->next;\n\t\t}\n\t\twhile (atlas != sentinel);\n\t}\n\n\tint texture_count = hashtable_count(&sb->sprites_to_lonely_textures);\n\tspritebatch_internal_lonely_texture_t* lonely_textures = (spritebatch_internal_lonely_texture_t*)hashtable_items(&sb->sprites_to_lonely_textures);\n\tfor (int i = 0; i < texture_count; ++i) lonely_textures[i].timestamp += 1;\n}\n\nint spritebatch_flush(spritebatch_t* sb)\n{\n\t// process input buffer, make any necessary lonely textures\n\t// convert user sprites to internal format\n\t// lookup uv coordinates\n\tspritebatch_internal_process_input(sb, 0);\n\n\t// patchup any missing lonely textures that may have come from atlases decaying and whatnot\n\tint texture_count = hashtable_count(&sb->sprites_to_lonely_textures);\n\tspritebatch_internal_lonely_texture_t* lonely_textures = (spritebatch_internal_lonely_texture_t*)hashtable_items(&sb->sprites_to_lonely_textures);\n\tfor (int i = 0; i < texture_count; ++i)\n\t{\n\t\tspritebatch_internal_lonely_texture_t* lonely = lonely_textures + i;\n\t\tif (lonely->texture_id == ~0) lonely->texture_id = spritebatch_internal_generate_texture_handle(sb, lonely->image_id, lonely->w, lonely->h);\n\t}\n\n\t// sort internal sprite buffer and submit batches\n\tspritebatch_internal_sort_sprites(sb);\n\n\tint min = 0;\n\tint max = 0;\n\tint done = !sb->sprite_count;\n\tint count = 0;\n\twhile (!done)\n\t{\n\t\tSPRITEBATCH_U64 id = sb->sprites[min].texture_id;\n\t\tSPRITEBATCH_U64 image_id = sb->sprites[min].image_id;\n\n\t\twhile (1)\n\t\t{\n\t\t\tif (max == sb->sprite_count)\n\t\t\t{\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (id != sb->sprites[max].texture_id)\n\t\t\t\tbreak;\n\n\t\t\t++max;\n\t\t}\n\n\t\tint batch_count = max - min;\n\t\tif (batch_count)\n\t\t{\n\t\t\tint w, h;\n\t\t\tspritebatch_internal_premade_sprite_t* premade = (spritebatch_internal_premade_sprite_t*)hashtable_find(&sb->sprites_to_premades, image_id);\n\t\t\tif (!premade)\n\t\t\t{\n\t\t\t\tvoid* atlas_ptr = hashtable_find(&sb->sprites_to_atlases, image_id);\n\n\t\t\t\tif (atlas_ptr)\n\t\t\t\t{\n\t\t\t\t\tw = sb->atlas_width_in_pixels;\n\t\t\t\t\th = sb->atlas_height_in_pixels;\n\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tspritebatch_internal_lonely_texture_t* tex = (spritebatch_internal_lonely_texture_t*)hashtable_find(&sb->sprites_to_lonely_textures, image_id);\n\t\t\t\t\tSPRITEBATCH_ASSERT(tex);\n\t\t\t\t\tw = tex->w;\n\t\t\t\t\th = tex->h;\n\t\t\t\t\tif (sb->atlas_use_border_pixels)\n\t\t\t\t\t{\n\t\t\t\t\t\tw += 2;\n\t\t\t\t\t\th += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\tw = premade->atlas_w;\n\t\t\t\th = premade->atlas_h;\n\t\t\t}\n\n\t\t\tsb->batch_callback(sb->sprites + min, batch_count, w, h, sb->udata);\n\t\t\t++count;\n\t\t}\n\t\tmin = max;\n\t}\n\n\tsb->sprite_count = 0;\n\tif (count > 1) {\n\t\tSPRITEBATCH_LOG(\"Flushed %d batches.\\n\", count);\n\t}\n\n\treturn count;\n}\n\ntypedef struct\n{\n\tint x;\n\tint y;\n} spritebatch_v2_t;\n\ntypedef struct\n{\n\tint img_index;\n\tspritebatch_v2_t size;\n\tspritebatch_v2_t min;\n\tspritebatch_v2_t max;\n\tint fit;\n} spritebatch_internal_integer_image_t;\n\nstatic spritebatch_v2_t spritebatch_v2(int x, int y)\n{\n\tspritebatch_v2_t v;\n\tv.x = x;\n\tv.y = y;\n\treturn v;\n}\n\nstatic spritebatch_v2_t spritebatch_sub(spritebatch_v2_t a, spritebatch_v2_t b)\n{\n\tspritebatch_v2_t v;\n\tv.x = a.x - b.x;\n\tv.y = a.y - b.y;\n\treturn v;\n}\n\nstatic spritebatch_v2_t spritebatch_add(spritebatch_v2_t a, spritebatch_v2_t b)\n{\n\tspritebatch_v2_t v;\n\tv.x = a.x + b.x;\n\tv.y = a.y + b.y;\n\treturn v;\n}\n\ntypedef struct\n{\n\tspritebatch_v2_t size;\n\tspritebatch_v2_t min;\n\tspritebatch_v2_t max;\n} spritebatch_internal_atlas_node_t;\n\nstatic spritebatch_internal_atlas_node_t* spritebatch_best_fit(int sp, int w, int h, spritebatch_internal_atlas_node_t* nodes)\n{\n\tint best_volume = INT_MAX;\n\tspritebatch_internal_atlas_node_t *best_node = 0;\n\tint img_volume = w * h;\n\n\tfor ( int i = 0; i < sp; ++i )\n\t{\n\t\tspritebatch_internal_atlas_node_t *node = nodes + i;\n\t\tint can_contain = node->size.x >= w && node->size.y >= h;\n\t\tif ( can_contain )\n\t\t{\n\t\t\tint node_volume = node->size.x * node->size.y;\n\t\t\tif ( node_volume == img_volume ) return node;\n\t\t\tif ( node_volume < best_volume )\n\t\t\t{\n\t\t\t\tbest_volume = node_volume;\n\t\t\t\tbest_node = node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_node;\n}\n\nstatic int spritebatch_internal_image_less_than_or_equal(spritebatch_internal_integer_image_t* a, spritebatch_internal_integer_image_t* b)\n{\n\tint perimeterA = 2 * (a->size.x + a->size.y);\n\tint perimeterB = 2 * (b->size.x + b->size.y);\n\treturn perimeterB <= perimeterA;\n}\n\nvoid spritebatch_internal_image_merge_sort_iteration(spritebatch_internal_integer_image_t* a, int lo, int split, int hi, spritebatch_internal_integer_image_t* b)\n{\n\tint i = lo, j = split;\n\tfor (int k = lo; k < hi; k++) {\n\t\tif (i < split && (j >= hi || spritebatch_internal_image_less_than_or_equal(a + i, a + j))) {\n\t\t\tb[k] = a[i];\n\t\t\ti = i + 1;\n\t\t} else {\n\t\t\tb[k] = a[j];\n\t\t\tj = j + 1;\n\t\t}\n\t}\n}\n\nvoid spritebatch_internal_image_merge_sort_recurse(spritebatch_internal_integer_image_t* b, int lo, int hi, spritebatch_internal_integer_image_t* a)\n{\n\tif (hi - lo <= 1) return;\n\tint split = (lo + hi) / 2;\n\tspritebatch_internal_image_merge_sort_recurse(a, lo,  split, b);\n\tspritebatch_internal_image_merge_sort_recurse(a, split, hi, b);\n\tspritebatch_internal_image_merge_sort_iteration(b, lo, split, hi, a);\n}\n\nvoid spritebatch_internal_image_merge_sort(spritebatch_internal_integer_image_t* a, spritebatch_internal_integer_image_t* b, int n)\n{\n\tSPRITEBATCH_MEMCPY(b, a, sizeof(spritebatch_internal_integer_image_t) * n);\n\tspritebatch_internal_image_merge_sort_recurse(b, 0, n, a);\n}\n\ntypedef struct spritebatch_internal_atlas_image_t\n{\n\tint img_index;    // index into the `imgs` array\n\tint w, h;         // pixel w/h of original image\n\tfloat minx, miny; // u coordinate\n\tfloat maxx, maxy; // v coordinate\n\tint fit;          // non-zero if image fit and was placed into the atlas\n} spritebatch_internal_atlas_image_t;\n\n#define SPRITEBATCH_CHECK( X, Y ) do { if ( !(X) ) { SPRITEBATCH_LOG(Y); goto sb_err; } } while ( 0 )\n\nvoid spritebatch_make_atlas(spritebatch_t* sb, spritebatch_internal_atlas_t* atlas_out, const spritebatch_internal_lonely_texture_t* imgs, int img_count)\n{\n\tfloat iw, ih;\n\tint atlas_image_size, atlas_stride, sp;\n\tvoid* atlas_pixels = 0;\n\tint atlas_node_capacity = img_count * 2;\n\tspritebatch_internal_integer_image_t* images = 0;\n\tspritebatch_internal_integer_image_t* images_scratch = 0;\n\tspritebatch_internal_atlas_node_t* nodes = 0;\n\tint pixel_stride = sb->pixel_stride;\n\tint atlas_width = sb->atlas_width_in_pixels;\n\tint atlas_height = sb->atlas_height_in_pixels;\n\tfloat volume_used = 0;\n\n\timages = (spritebatch_internal_integer_image_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_integer_image_t) * img_count, sb->mem_ctx);\n\timages_scratch = (spritebatch_internal_integer_image_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_integer_image_t) * img_count, sb->mem_ctx);\n\tnodes = (spritebatch_internal_atlas_node_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_atlas_node_t) * atlas_node_capacity, sb->mem_ctx);\n\tSPRITEBATCH_CHECK(images, \"out of mem\");\n\tSPRITEBATCH_CHECK(nodes, \"out of mem\");\n\n\tfor (int i = 0; i < img_count; ++i)\n\t{\n\t\tconst spritebatch_internal_lonely_texture_t* img = imgs + i;\n\t\tspritebatch_internal_integer_image_t* image = images + i;\n\t\timage->fit = 0;\n\t\timage->size = sb->atlas_use_border_pixels ? spritebatch_v2(img->w + 2, img->h + 2) : spritebatch_v2(img->w, img->h);\n\t\timage->img_index = i;\n\t}\n\n\t// Sort PNGs from largest to smallest\n\tspritebatch_internal_image_merge_sort(images, images_scratch, img_count);\n\n\t// stack pointer, the stack is the nodes array which we will\n\t// allocate nodes from as necessary.\n\tsp = 1;\n\n\tnodes[0].min = spritebatch_v2(0, 0);\n\tnodes[0].max = spritebatch_v2(atlas_width, atlas_height);\n\tnodes[0].size = spritebatch_v2(atlas_width, atlas_height);\n\n\t// Nodes represent empty space in the atlas. Placing a texture into the\n\t// atlas involves splitting a node into two smaller pieces (or, if a\n\t// perfect fit is found, deleting the node).\n\tfor (int i = 0; i < img_count; ++i)\n\t{\n\t\tspritebatch_internal_integer_image_t* image = images + i;\n\t\tint width = image->size.x;\n\t\tint height = image->size.y;\n\t\tspritebatch_internal_atlas_node_t *best_fit = spritebatch_best_fit(sp, width, height, nodes);\n\n\t\tif (!best_fit) {\n\t\t\timage->fit = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\timage->min = best_fit->min;\n\t\timage->max = spritebatch_add(image->min, image->size);\n\n\t\tif (best_fit->size.x == width && best_fit->size.y == height)\n\t\t{\n\t\t\tspritebatch_internal_atlas_node_t* last_node = nodes + --sp;\n\t\t\t*best_fit = *last_node;\n\t\t\timage->fit = 1;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\timage->fit = 1;\n\n\t\tif (sp == atlas_node_capacity)\n\t\t{\n\t\t\tint new_capacity = atlas_node_capacity * 2;\n\t\t\tspritebatch_internal_atlas_node_t* new_nodes = (spritebatch_internal_atlas_node_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_atlas_node_t) * new_capacity, mem_ctx);\n\t\t\tSPRITEBATCH_CHECK(new_nodes, \"out of mem\");\n\t\t\tmemcpy(new_nodes, nodes, sizeof(spritebatch_internal_atlas_node_t) * sp);\n\t\t\tSPRITEBATCH_FREE(nodes, mem_ctx);\n\t\t\tnodes = new_nodes;\n\t\t\tatlas_node_capacity = new_capacity;\n\t\t}\n\n\t\tspritebatch_internal_atlas_node_t* new_node = nodes + sp++;\n\t\tnew_node->min = best_fit->min;\n\n\t\t// Split bestFit along x or y, whichever minimizes\n\t\t// fragmentation of empty space\n\t\tspritebatch_v2_t d = spritebatch_sub(best_fit->size, spritebatch_v2(width, height));\n\t\tif (d.x < d.y)\n\t\t{\n\t\t\tnew_node->size.x = d.x;\n\t\t\tnew_node->size.y = height;\n\t\t\tnew_node->min.x += width;\n\n\t\t\tbest_fit->size.y = d.y;\n\t\t\tbest_fit->min.y += height;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tnew_node->size.x = width;\n\t\t\tnew_node->size.y = d.y;\n\t\t\tnew_node->min.y += height;\n\n\t\t\tbest_fit->size.x = d.x;\n\t\t\tbest_fit->min.x += width;\n\t\t}\n\n\t\tnew_node->max = spritebatch_add(new_node->min, new_node->size);\n\t}\n\n\t// Write the final atlas image, use SPRITEBATCH_ATLAS_EMPTY_COLOR as base color\n\tatlas_stride = atlas_width * pixel_stride;\n\tatlas_image_size = atlas_width * atlas_height * pixel_stride;\n\tatlas_pixels = SPRITEBATCH_MALLOC(atlas_image_size, mem_ctx);\n\tSPRITEBATCH_CHECK(atlas_image_size, \"out of mem\");\n\tSPRITEBATCH_MEMSET(atlas_pixels, SPRITEBATCH_ATLAS_EMPTY_COLOR, atlas_image_size);\n\n\tfor (int i = 0; i < img_count; ++i)\n\t{\n\t\tspritebatch_internal_integer_image_t* image = images + i;\n\n\t\tif (image->fit)\n\t\t{\n\t\t\tconst spritebatch_internal_lonely_texture_t* img = imgs + image->img_index;\n\t\t\tspritebatch_internal_get_pixels(sb, img->image_id, img->w, img->h);\n\t\t\tchar* pixels = (char*)sb->pixel_buffer;\n\n\t\t\tspritebatch_v2_t min = image->min;\n\t\t\tspritebatch_v2_t max = image->max;\n\t\t\tint atlas_offset = min.x * pixel_stride;\n\t\t\tint tex_stride = image->size.x * pixel_stride;\n\n\t\t\tfor (int row = min.y, y = 0; row < max.y; ++row, ++y)\n\t\t\t{\n\t\t\t\tvoid* row_ptr = (char*)atlas_pixels + (row * atlas_stride + atlas_offset);\n\t\t\t\tSPRITEBATCH_MEMCPY(row_ptr, pixels + y * tex_stride, tex_stride);\n\t\t\t}\n\t\t}\n\t}\n\n\thashtable_init(&atlas_out->sprites_to_textures, sizeof(spritebatch_internal_texture_t), img_count, sb->mem_ctx);\n\tatlas_out->texture_id = sb->generate_texture_callback(atlas_pixels, atlas_width, atlas_height, sb->udata);\n\n\tiw = 1.0f / (float)(atlas_width);\n\tih = 1.0f / (float)(atlas_height);\n\n\tfor (int i = 0; i < img_count; ++i)\n\t{\n\t\tspritebatch_internal_integer_image_t* img = images + i;\n\n\t\tif (img->fit)\n\t\t{\n\t\t\tspritebatch_v2_t min = img->min;\n\t\t\tspritebatch_v2_t max = img->max;\n\t\t\tvolume_used += img->size.x * img->size.y;\n\n\t\t\tfloat min_x = (float)min.x * iw;\n\t\t\tfloat min_y = (float)min.y * ih;\n\t\t\tfloat max_x = (float)max.x * iw;\n\t\t\tfloat max_y = (float)max.y * ih;\n\n\t\t\t// flip image on y axis\n\t\t\tif (SPRITEBATCH_ATLAS_FLIP_Y_AXIS_FOR_UV)\n\t\t\t{\n\t\t\t\tfloat tmp = min_y;\n\t\t\t\tmin_y = max_y;\n\t\t\t\tmax_y = tmp;\n\t\t\t}\n\n\t\t\tspritebatch_internal_texture_t texture;\n\t\t\ttexture.w = img->size.x;\n\t\t\ttexture.h = img->size.y;\n\t\t\ttexture.timestamp = 0;\n\t\t\ttexture.minx = min_x;\n\t\t\ttexture.miny = min_y;\n\t\t\ttexture.maxx = max_x;\n\t\t\ttexture.maxy = max_y;\n\t\t\tSPRITEBATCH_ASSERT(!(img->size.x < 0));\n\t\t\tSPRITEBATCH_ASSERT(!(img->size.y < 0));\n\t\t\tSPRITEBATCH_ASSERT(!(min_x < 0));\n\t\t\tSPRITEBATCH_ASSERT(!(max_x < 0));\n\t\t\tSPRITEBATCH_ASSERT(!(min_y < 0));\n\t\t\tSPRITEBATCH_ASSERT(!(max_y < 0));\n\t\t\ttexture.image_id = imgs[img->img_index].image_id;\n\t\t\thashtable_insert(&atlas_out->sprites_to_textures, texture.image_id, &texture);\n\t\t}\n\t}\n\n\t// Need to adjust atlas_width and atlas_height in config params, as none of the images for this\n\t// atlas actually fit inside of the atlas! Either adjust the config, or stop sending giant images\n\t// to the sprite batcher.\n\tSPRITEBATCH_ASSERT(volume_used > 0);\n\n\tatlas_out->volume_ratio = volume_used / (atlas_width * atlas_height);\n\nsb_err:\n\t// no specific error handling needed here (yet)\n\n\tSPRITEBATCH_FREE(atlas_pixels, mem_ctx);\n\tSPRITEBATCH_FREE(nodes, mem_ctx);\n\tSPRITEBATCH_FREE(images, mem_ctx);\n\tSPRITEBATCH_FREE(images_scratch, mem_ctx);\n\treturn;\n}\n\nstatic int spritebatch_internal_lonely_pred(spritebatch_internal_lonely_texture_t* a, spritebatch_internal_lonely_texture_t* b)\n{\n\treturn a->timestamp < b->timestamp;\n}\n\nstatic void spritebatch_internal_qsort_lonely(hashtable_t* lonely_table, spritebatch_internal_lonely_texture_t* items, int count)\n{\n\tif (count <= 1) return;\n\n\tspritebatch_internal_lonely_texture_t pivot = items[count - 1];\n\tint low = 0;\n\tfor (int i = 0; i < count - 1; ++i)\n\t{\n\t\tif (spritebatch_internal_lonely_pred(items + i, &pivot))\n\t\t{\n\t\t\thashtable_swap(lonely_table, i, low);\n\t\t\tlow++;\n\t\t}\n\t}\n\n\thashtable_swap(lonely_table, low, count - 1);\n\tspritebatch_internal_qsort_lonely(lonely_table, items, low);\n\tspritebatch_internal_qsort_lonely(lonely_table, items + low + 1, count - 1 - low);\n}\n\nint spritebatch_internal_buffer_key(spritebatch_t* sb, SPRITEBATCH_U64 key)\n{\n\tSPRITEBATCH_CHECK_BUFFER_GROW(sb, key_buffer_count, key_buffer_capacity, key_buffer, SPRITEBATCH_U64);\n\tsb->key_buffer[sb->key_buffer_count++] = key;\n\treturn 0;\n}\n\nvoid spritebatch_internal_remove_table_entries(spritebatch_t* sb, hashtable_t* table)\n{\n\tfor (int i = 0; i < sb->key_buffer_count; ++i) hashtable_remove(table, sb->key_buffer[i]);\n\tsb->key_buffer_count = 0;\n}\n\nvoid spritebatch_internal_flush_atlas(spritebatch_t* sb, spritebatch_internal_atlas_t* atlas, spritebatch_internal_atlas_t** sentinel, spritebatch_internal_atlas_t** next)\n{\n\tint ticks_to_decay_texture = sb->ticks_to_decay_texture;\n\tint texture_count = hashtable_count(&atlas->sprites_to_textures);\n\tspritebatch_internal_texture_t* textures = (spritebatch_internal_texture_t*)hashtable_items(&atlas->sprites_to_textures);\n\n\tfor (int i = 0; i < texture_count; ++i)\n\t{\n\t\tspritebatch_internal_texture_t* atlas_texture = textures + i;\n\t\tif (atlas_texture->timestamp < ticks_to_decay_texture)\n\t\t{\n\t\t\tint w = atlas_texture->w;\n\t\t\tint h = atlas_texture->h;\n\t\t\tif (sb->atlas_use_border_pixels)\n\t\t\t{\n\t\t\t\tw -= 2;\n\t\t\t\th -= 2;\n\t\t\t}\n\t\t\tspritebatch_internal_lonely_texture_t* lonely_texture = spritebatch_internal_lonelybuffer_push(sb, atlas_texture->image_id, w, h, 0);\n\t\t\tlonely_texture->timestamp = atlas_texture->timestamp;\n\t\t}\n\t\thashtable_remove(&sb->sprites_to_atlases, atlas_texture->image_id);\n\t}\n\n\tif (sb->atlases == atlas)\n\t{\n\t\tif (atlas->next == atlas) sb->atlases = 0;\n\t\telse sb->atlases = atlas->prev;\n\t}\n\n\t// handle loop end conditions if sentinel was removed from the chain\n\tif (sentinel && next)\n\t{\n\t\tif (*sentinel == atlas)\n\t\t{\n\t\t\tSPRITEBATCH_LOG(\"\\t\\tsentinel was also atlas: %p\\n\", *sentinel);\n\t\t\tif ((*next)->next != *sentinel)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_LOG(\"\\t\\t*next = (*next)->next : %p = (*next)->%p\\n\", *next, (*next)->next);\n\t\t\t\t*next = (*next)->next;\n\t\t\t}\n\n\t\t\tSPRITEBATCH_LOG(\"\\t\\t*sentinel = *next : %p =  %p\\n\", *sentinel, *next);\n \t\t\t*sentinel = *next;\n\n\t\t}\n\t}\n\n\tatlas->next->prev = atlas->prev;\n\tatlas->prev->next = atlas->next;\n\thashtable_term(&atlas->sprites_to_textures);\n\tsb->delete_texture_callback(atlas->texture_id, sb->udata);\n\tSPRITEBATCH_FREE(atlas, sb->mem_ctx);\n}\n\nvoid spritebatch_invalidate(spritebatch_t* sb, SPRITEBATCH_U64 image_id)\n{\n\tvoid* atlas_ptr = hashtable_find(&sb->sprites_to_atlases, image_id);\n\tif (atlas_ptr) {\n\t\tspritebatch_internal_atlas_t* atlas = *(spritebatch_internal_atlas_t**)atlas_ptr;\n\t\tspritebatch_internal_flush_atlas(sb, atlas, 0, 0);\n\t}\n\tif (hashtable_find(&sb->sprites_to_lonely_textures, image_id)) {\n\t\thashtable_remove(&sb->sprites_to_lonely_textures, image_id);\n\t}\n}\n\nvoid spritebatch_internal_log_chain(spritebatch_internal_atlas_t* atlas)\n{\n\tif (atlas)\n\t{\n\t\tspritebatch_internal_atlas_t* sentinel = atlas;\n\t\tSPRITEBATCH_LOG(\"sentinel: %p\\n\", sentinel);\n\t\tdo\n\t\t{\n\t\t\tspritebatch_internal_atlas_t* next = atlas->next;\n\t\t\tSPRITEBATCH_LOG(\"\\tatlas %p\\n\", atlas);\n\t\t\tatlas = next;\n\t\t}\n\t\twhile (atlas != sentinel);\n\t}\n}\n\nint spritebatch_defrag(spritebatch_t* sb)\n{\n\t// remove decayed atlases and flush them to the lonely buffer\n\t// only flush textures that are not decayed\n\tint ticks_to_decay_texture = sb->ticks_to_decay_texture;\n\tfloat ratio_to_decay_atlas = sb->ratio_to_decay_atlas;\n\tspritebatch_internal_atlas_t* atlas = sb->atlases;\n\tif (atlas)\n\t{\n\t\tspritebatch_internal_log_chain(atlas);\n\t\tspritebatch_internal_atlas_t* sentinel = atlas;\n\t\tdo\n\t\t{\n\t\t\tspritebatch_internal_atlas_t* next = atlas->next;\n\t\t\tint texture_count = hashtable_count(&atlas->sprites_to_textures);\n\t\t\tspritebatch_internal_texture_t* textures = (spritebatch_internal_texture_t*)hashtable_items(&atlas->sprites_to_textures);\n\t\t\tint decayed_texture_count = 0;\n\t\t\tfor (int i = 0; i < texture_count; ++i) if (textures[i].timestamp >= ticks_to_decay_texture) decayed_texture_count++;\n\n\t\t\tfloat ratio;\n\t\t\tif (!decayed_texture_count) ratio = 0;\n\t\t\telse ratio = (float)texture_count / (float)decayed_texture_count;\n\t\t\tif (ratio > ratio_to_decay_atlas)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_LOG(\"flushed atlas %p\\n\", atlas);\n\t\t\t\tspritebatch_internal_flush_atlas(sb, atlas, &sentinel, &next);\n\t\t\t}\n\t\t\tatlas = next;\n\t\t}\n\t\twhile (atlas != sentinel);\n\t}\n\n\t// merge mostly empty atlases\n\tfloat ratio_to_merge_atlases = sb->ratio_to_merge_atlases;\n\tatlas = sb->atlases;\n\tif (atlas)\n\t{\n\t\tint sp = 0;\n\t\tspritebatch_internal_atlas_t* merge_stack[2];\n\n\t\tspritebatch_internal_atlas_t* sentinel = atlas;\n\t\tdo\n\t\t{\n\t\t\tspritebatch_internal_atlas_t* next = atlas->next;\n\n\t\t\tSPRITEBATCH_ASSERT(sp >= 0 && sp <= 2);\n\t\t\tif (sp == 2)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_LOG(\"merged 2 atlases\\n\");\n\t\t\t\tspritebatch_internal_flush_atlas(sb, merge_stack[0], &sentinel, &next);\n\t\t\t\tspritebatch_internal_flush_atlas(sb, merge_stack[1], &sentinel, &next);\n\t\t\t\tsp = 0;\n\t\t\t}\n\n\t\t\tfloat ratio = atlas->volume_ratio;\n\t\t\tif (ratio < ratio_to_merge_atlases) merge_stack[sp++] = atlas;\n\n\t\t\tatlas = next;\n\t\t}\n\t\twhile (atlas != sentinel);\n\n\t\tif (sp == 2)\n\t\t{\n\t\t\tSPRITEBATCH_LOG(\"merged 2 atlases (out of loop)\\n\");\n\t\t\tspritebatch_internal_flush_atlas(sb, merge_stack[0], 0, 0);\n\t\t\tspritebatch_internal_flush_atlas(sb, merge_stack[1], 0, 0);\n\t\t}\n\t}\n\n\t// remove decayed textures from the lonely buffer\n\tint lonely_buffer_count_till_decay = sb->lonely_buffer_count_till_decay;\n\tint lonely_count = hashtable_count(&sb->sprites_to_lonely_textures);\n\tspritebatch_internal_lonely_texture_t* lonely_textures = (spritebatch_internal_lonely_texture_t*)hashtable_items(&sb->sprites_to_lonely_textures);\n\tif (lonely_count >= lonely_buffer_count_till_decay)\n\t{\n\t\tspritebatch_internal_qsort_lonely(&sb->sprites_to_lonely_textures, lonely_textures, lonely_count);\n\t\tint index = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (index == lonely_count) break;\n\t\t\tif (lonely_textures[index].timestamp >= ticks_to_decay_texture) break;\n\t\t\t++index;\n\t\t}\n\t\tfor (int i = index; i < lonely_count; ++i)\n\t\t{\n\t\t\tSPRITEBATCH_U64 texture_id = lonely_textures[i].texture_id;\n\t\t\tif (texture_id != ~0) sb->delete_texture_callback(texture_id, sb->udata);\n\t\t\tspritebatch_internal_buffer_key(sb, lonely_textures[i].image_id);\n\t\t\tSPRITEBATCH_LOG(\"lonely texture decayed\\n\");\n\t\t}\n\t\tspritebatch_internal_remove_table_entries(sb, &sb->sprites_to_lonely_textures);\n\t\tlonely_count -= lonely_count - index;\n\t\tSPRITEBATCH_ASSERT(lonely_count == hashtable_count(&sb->sprites_to_lonely_textures));\n\t}\n\n\t// process input, but don't make textures just yet\n\tspritebatch_internal_process_input(sb, 1);\n\tlonely_count = hashtable_count(&sb->sprites_to_lonely_textures);\n\n\t// while greater than lonely_buffer_count_till_flush elements in lonely buffer\n\t// grab lonely_buffer_count_till_flush of them and make an atlas\n\tint lonely_buffer_count_till_flush = sb->lonely_buffer_count_till_flush;\n\tint stuck = 0;\n\twhile (lonely_count > lonely_buffer_count_till_flush && !stuck)\n\t{\n\t\tatlas = (spritebatch_internal_atlas_t*)SPRITEBATCH_MALLOC(sizeof(spritebatch_internal_atlas_t), sb->mem_ctx);\n\t\tif (sb->atlases)\n\t\t{\n\t\t\tatlas->prev = sb->atlases;\n\t\t\tatlas->next = sb->atlases->next;\n\t\t\tsb->atlases->next->prev = atlas;\n\t\t\tsb->atlases->next = atlas;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tatlas->next = atlas;\n\t\t\tatlas->prev = atlas;\n\t\t\tsb->atlases = atlas;\n\t\t}\n\n\t\tspritebatch_make_atlas(sb, atlas, lonely_textures, lonely_count);\n\t\tSPRITEBATCH_LOG(\"making atlas\\n\");\n\n\t\tint tex_count_in_atlas = hashtable_count(&atlas->sprites_to_textures);\n\t\tif (tex_count_in_atlas != lonely_count)\n\t\t{\n\t\t\tint hit_count = 0;\n\t\t\tfor (int i = 0; i < lonely_count; ++i)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_U64 key = lonely_textures[i].image_id;\n\t\t\t\tif (hashtable_find(&atlas->sprites_to_textures, key))\n\t\t\t\t{\n\t\t\t\t\tspritebatch_internal_buffer_key(sb, key);\n\t\t\t\t\tSPRITEBATCH_U64 texture_id = lonely_textures[i].texture_id;\n\t\t\t\t\tif (texture_id != ~0) sb->delete_texture_callback(texture_id, sb->udata);\n\t\t\t\t\thashtable_insert(&sb->sprites_to_atlases, key, &atlas);\n\t\t\t\t\tSPRITEBATCH_LOG(\"removing lonely texture for atlas%s\\n\", texture_id != ~0 ? \"\" : \" (tex was ~0)\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\thit_count++;\n\t\t\t\t\tSPRITEBATCH_ASSERT(lonely_textures[i].w <= sb->atlas_width_in_pixels);\n\t\t\t\t\tSPRITEBATCH_ASSERT(lonely_textures[i].h <= sb->atlas_height_in_pixels);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspritebatch_internal_remove_table_entries(sb, &sb->sprites_to_lonely_textures);\n\n\t\t\tlonely_count = hashtable_count(&sb->sprites_to_lonely_textures);\n\n\t\t\tif (!hit_count)\n\t\t\t{\n\t\t\t\t// TODO\n\t\t\t\t// handle case where none fit in atlas\n\t\t\t\tstuck = 1;\n\t\t\t\tSPRITEBATCH_ASSERT(0);\n\t\t\t}\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < lonely_count; ++i)\n\t\t\t{\n\t\t\t\tSPRITEBATCH_U64 key = lonely_textures[i].image_id;\n\t\t\t\tSPRITEBATCH_U64 texture_id = lonely_textures[i].texture_id;\n\t\t\t\tif (texture_id != ~0) sb->delete_texture_callback(texture_id, sb->udata);\n\t\t\t\thashtable_insert(&sb->sprites_to_atlases, key, &atlas);\n\t\t\t\tSPRITEBATCH_LOG(\"(fast path) removing lonely texture for atlas%s\\n\", texture_id != ~0 ? \"\" : \" (tex was ~0)\" );\n\t\t\t}\n\t\t\thashtable_clear(&sb->sprites_to_lonely_textures);\n\t\t\tlonely_count = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#endif // SPRITEBATCH_IMPLEMENTATION_ONCE\n#endif // SPRITEBATCH_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2023 Randy Gaul https://randygaul.github.io/\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \n\tsoftware, either in source code form or as a compiled binary, for any purpose, \n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this \n\tsoftware dedicate any and all copyright interest in the software to the public \n\tdomain. We make this dedication for the benefit of the public at large and to \n\tthe detriment of our heirs and successors. We intend this dedication to be an \n\tovert act of relinquishment in perpetuity of all present and future rights to \n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_sync.h",
          "type": "blob",
          "size": 34.3046875,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_sync.h - v1.01\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_SYNC_IMPLEMENTATION\n\t\t#define CUTE_SYNC_WINDOWS\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\tSUMMARY\n\n\t\tCollection of practical syncronization primitives for Windows/Posix/SDL2.\n\n\t\tHere is a list of all supported primitives.\n\n\t\t\t* atomic integer/pointer\n\t\t\t* thread\n\t\t\t* mutex\n\t\t\t* condition variable\n\t\t\t* semaphore\n\t\t\t* read/write lock\n\t\t\t* thread pool\n\n\t\tHere are some slides I wrote for those interested in learning prequisite\n\t\tknowledge for utilizing this header:\n\t\thttp://www.randygaul.net/2014/09/24/multi-threading-best-practices-for-gamedev/\n\n\t\tA good chunk of this code came from Mattias Gustavsson's thread.h header.\n\t\tIt really is quite a good header, and worth considering!\n\t\thttps://github.com/mattiasgustavsson/libs\n\n\n\tPLATFORMS\n\n\t\tThe current supported platforms are Windows/Posix/SDL. Here are the macros for\n\t\tpicking each implementation.\n\n\t\t\t* CUTE_SYNC_WINDOWS\n\t\t\t* CUTE_SYNC_POSIX\n\t\t\t* CUTE_SYNC_SDL\n\n\n\tREVISION HISTORY\n\n\t\t1.0  (05/31/2018) initial release\n\t\t1.01 (08/25/2019) Windows and pthreads port\n*/\n\n#if !defined(CUTE_SYNC_H)\n\ntypedef union cute_atomic_int_t cute_atomic_int_t;\ntypedef union cute_mutex_t cute_mutex_t;\ntypedef union cute_cv_t cute_cv_t;\ntypedef struct cute_semaphore_t cute_semaphore_t;\ntypedef struct cute_thread_t cute_thread_t;\ntypedef unsigned long long cute_thread_id_t;\ntypedef int (cute_thread_fn)(void *udata);\n\n/**\n * Creates an unlocked mutex.\n */\ncute_mutex_t cute_mutex_create();\n\n/**\n * Returns 1 on success, zero otherwise.\n */\nint cute_lock(cute_mutex_t* mutex);\n\n/**\n * Returns 1 on success, zero otherwise.\n */\nint cute_unlock(cute_mutex_t* mutex);\n\n/**\n * Attempts to lock the mutex without blocking. Returns one if lock was acquired,\n * otherwise returns zero.\n */\nint cute_trylock(cute_mutex_t* mutex);\nvoid cute_mutex_destroy(cute_mutex_t* mutex);\n\n/**\n * Constructs a condition variable, used to sleep or wake threads.\n */\ncute_cv_t cute_cv_create();\n\n/**\n * Signals all sleeping threads to wake that are waiting on the condition variable.\n * Returns 1 on success, zero otherwise.\n */\nint cute_cv_wake_all(cute_cv_t* cv);\n\n/**\n * Signals a single thread to wake that are waiting on the condition variable.\n * Returns 1 on success, zero otherwise.\n */\nint cute_cv_wake_one(cute_cv_t* cv);\n\n/**\n * Places a thread to wait on the condition variable.\n * Returns 1 on success, zero otherwise.\n */\nint cute_cv_wait(cute_cv_t* cv, cute_mutex_t* mutex);\nvoid cute_cv_destroy(cute_cv_t* cv);\n\n/**\n * Creates a semaphore with an initial internal value of `initial_count`.\n * Returns NULL on failure.\n */\ncute_semaphore_t cute_semaphore_create(int initial_count);\n\n/**\n * Automically increments the semaphore's value and then wakes a sleeping thread.\n * Returns 1 on success, zero otherwise.\n */\nint cute_semaphore_post(cute_semaphore_t* semaphore);\n\n/**\n * Non-blocking version of `cute_semaphore_wait`.\n * Returns 1 on success, zero otherwise.\n */\nint cute_semaphore_try(cute_semaphore_t* semaphore);\n\n/**\n * Suspends the calling thread's execution unless the semaphore's value is positive. Will\n * decrement the value atomically afterwards.\n * Returns 1 on success, zero otherwise.\n */\nint cute_semaphore_wait(cute_semaphore_t* semaphore);\nint cute_semaphore_value(cute_semaphore_t* semaphore);\nvoid cute_semaphore_destroy(cute_semaphore_t* semaphore);\n\ncute_thread_t* cute_thread_create(cute_thread_fn func, const char* name, void* udata);\n\n/**\n * An optimization, meaning the thread will never have `cute_thread_wait` called on it.\n * Useful for certain long-lived threads.\n * It is invalid to call `cute_thread_wait` on a detached thread.\n * It is invalid to call `cute_thread_wait` on a thread more than once.\n * Please see this link for a longer description: https://wiki.libsdl.org/SDL_DetachThread\n */\nvoid cute_thread_detach(cute_thread_t* thread);\ncute_thread_id_t cute_thread_get_id(cute_thread_t* thread);\ncute_thread_id_t cute_thread_id();\n\n/**\n * Waits until the thread exits (unless it has already exited), and returns the thread's\n * return code. Unless the thread was detached, this function must be used, otherwise it\n * is considered a leak to leave an thread hanging around (even if it finished execution\n * and returned).\n */\nint cute_thread_wait(cute_thread_t* thread);\n\n/**\n * Returns the number of CPU cores on the machine. Can be affected my machine dependent technology,\n * such as Intel's hyperthreading.\n */\nint cute_core_count();\n\n/**\n * Returns the size of CPU's L1's cache line size in bytes.\n */\nint cute_cacheline_size();\n\n/**\n * Returns the size of the machine's RAM in megabytes.\n */\nint cute_ram_size();\n\n/**\n * Atomically adds `addend` at `atomic` and returns the old value at `atomic`.\n */\nint cute_atomic_add(cute_atomic_int_t* atomic, int addend);\n\n/**\n * Atomically sets `value` at `atomic` and returns the old value at `atomic`.\n */\nint cute_atomic_set(cute_atomic_int_t* atomic, int value);\n\n/**\n * Atomically fetches the value at `atomic`.\n */\nint cute_atomic_get(cute_atomic_int_t* atomic);\n\n/**\n * Atomically sets `atomic` to `value` if `expected` equals `atomic`.\n * Returns 1 of the value was set, 0 otherwise.\n */\nint cute_atomic_cas(cute_atomic_int_t* atomic, int expected, int value);\n\n/**\n * Atomically sets `value` at `atomic` and returns the old value at `atomic`.\n */\nvoid* cute_atomic_ptr_set(void** atomic, void* value);\n\n/**\n * Atomically fetches the value at `atomic`.\n */\nvoid* cute_atomic_ptr_get(void** atomic);\n\n/**\n * Atomically sets `atomic` to `value` if `expected` equals `atomic`.\n * Returns 1 of the value was set, 0 otherwise.\n */\nint cute_atomic_ptr_cas(void** atomic, void* expected, void* value);\n\n/**\n * A reader/writer mutual exclusion lock. Allows many simultaneous readers or a single writer.\n *\n * The number of readers is capped by `CUTE_RW_LOCK_MAX_READERS` (or in other words, a nearly indefinite\n * number). Exceeding `CUTE_RW_LOCK_MAX_READERS` simultaneous readers results in undefined behavior.\n */\ntypedef struct cute_rw_lock_t cute_rw_lock_t;\n#define CUTE_RW_LOCK_MAX_READERS (1 << 30)\n\n/**\n * Constructs an unlocked mutual exclusion read/write lock. The `rw` lock can safely sit\n * on the stack.\n */\ncute_rw_lock_t cute_rw_lock_create();\n\n/**\n * Locks for reading. Many simultaneous readers are allowed.\n */\nvoid cute_read_lock(cute_rw_lock_t* rw);\n\n/**\n * Undoes a single call to `cute_read_lock`.\n */\nvoid cute_read_unlock(cute_rw_lock_t* rw);\n\n/**\n * Locks for writing. When locked for writing, only one writer can be present, and no readers.\n *\n * Will wait for active readers to call `cute_read_unlock`, or for active writers to call\n * `cute_write_unlock`.\n */\nvoid cute_write_lock(cute_rw_lock_t* rw);\n\n/**\n * Undoes a single call to `cute_write_lock`.\n */\nvoid cute_write_unlock(cute_rw_lock_t* rw);\n\n/**\n * Destroys the internal semaphores, and mutex.\n */\nvoid cute_rw_lock_destroy(cute_rw_lock_t* rw);\n\ntypedef struct cute_threadpool_t cute_threadpool_t;\n\n/**\n * Constructs a threadpool containing `thread_count`, useful for implementing job/task systems.\n * `mem_ctx` can be NULL, and is used for custom allocation purposes.\n *\n * Returns NULL on error. Will return NULL if `CUTE_SYNC_CACHELINE_SIZE` is less than the actual\n * cache line size on a given machine. `CUTE_SYNC_CACHELINE_SIZE` defaults to 128 bytes, and can\n * be overidden by defining CUTE_SYNC_CACHELINE_SIZE before including cute_sync.h\n *\n * Makes a modest attempt at memory aligning to avoid false sharing, as an optimization.\n */\ncute_threadpool_t* cute_threadpool_create(int thread_count, void* mem_ctx);\n\n/**\n * Atomically adds a single task to the internal task stack (FIFO order). The task is represented\n * as a function pointer `func`, which does work. The `param` is passed to the `func` when the\n * task is started.\n */\nvoid cute_threadpool_add_task(cute_threadpool_t* pool, void (*func)(void*), void* param);\n\n/**\n * Wakes internal threads to perform tasks, and waits for all tasks to complete before returning.\n * The calling thread will help perform available tasks while waiting.\n */\nvoid cute_threadpool_kick_and_wait(cute_threadpool_t* pool);\n\n/**\n * Wakes internal threads to perform tasks and immediately returns.\n */\nvoid cute_threadpool_kick(cute_threadpool_t* pool);\n\n/**\n * Cleans up all resources created from `cute_threadpool_create`.\n */\nvoid cute_threadpool_destroy(cute_threadpool_t* pool);\n\n#define CUTE_SYNC_H\n#endif\n\n//--------------------------------------------------------------------------------------------------\n\n#ifndef CUTE_SYNC_TYPE_DEFINITIONS_H\n\nunion  cute_atomic_int_t { void* align; long i;                  };\nunion  cute_mutex_t      { void* align; char data[64];           };\nunion  cute_cv_t         { void* align; char data[64];           };\nstruct cute_semaphore_t  { void* id;    cute_atomic_int_t count; };\n\nstruct cute_rw_lock_t\n{\n\tcute_mutex_t mutex;\n\tcute_semaphore_t write_sem;\n\tcute_semaphore_t read_sem;\n\tcute_atomic_int_t readers;\n\tcute_atomic_int_t readers_departing;\n};\n\n#define CUTE_SYNC_TYPE_DEFINITIONS_H\n#endif\n\n//--------------------------------------------------------------------------------------------------\n\n#if defined(CUTE_SYNC_IMPLEMENTATION)\n#if !defined(CUTE_SYNC_IMPLEMENTATION_ONCE)\n#define CUTE_SYNC_IMPLEMENTATION_ONCE\n\n#if defined(CUTE_SYNC_SDL)\n#elif defined(CUTE_SYNC_WINDOWS)\n\t#define WIN32_LEAN_AND_MEAN\n\t// To use GetThreadId and other methods we must require Windows Vista minimum.\n\t#if _WIN32_WINNT < 0x0600\n\t\t#undef _WIN32_WINNT\n\t\t#define _WIN32_WINNT 0x0600 // requires Windows Vista minimum\n\t\t// 0x0400=Windows NT 4.0, 0x0500=Windows 2000, 0x0501=Windows XP, 0x0502=Windows Server 2003, 0x0600=Windows Vista,\n\t\t// 0x0601=Windows 7, 0x0602=Windows 8, 0x0603=Windows 8.1, 0x0A00=Windows 10\n\t#endif\n\t#include <Windows.h>\n#elif defined(CUTE_SYNC_POSIX)\n\t#include <pthread.h>\n\t#include <semaphore.h>\n\n\t// Just platforms with unistd.h are supported for now.\n\t// So no FreeBSD, OS/2, or other weird platforms.\n\t#include <unistd.h> // sysconf\n\n\t#if defined(__APPLE__)\n\t#include <sys/sysctl.h> // sysctlbyname\n\t#endif\n#else\n\t#error Please choose a base implementation between CUTE_SYNC_SDL, CUTE_SYNC_WINDOWS and CUTE_SYNC_POSIX.\n#endif\n\n#if !defined(CUTE_SYNC_ALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_SYNC_ALLOC(size, ctx) malloc(size)\n\t#define CUTE_SYNC_FREE(ptr, ctx) free(ptr)\n#endif\n\n#if !defined(CUTE_SYNC_MEMCPY)\n\t#include <string.h>\n\t#define CUTE_SYNC_MEMCPY memcpy\n#endif\n\n#if !defined(CUTE_SYNC_YIELD)\n\t#ifdef CUTE_SYNC_WINDOWS\n\t\t#define WIN32_LEAN_AND_MEAN\n\t\t#include <Windows.h> // winnt\n\t\t#define CUTE_SYNC_YIELD YieldProcessor\n\t#elif defined(CUTE_SYNC_POSIX)\n\t\t#include <sched.h>\n\t\t#define CUTE_SYNC_YIELD sched_yield\n\t#else\n\t\t#define CUTE_SYNC_YIELD() // Not implemented by SDL.\n\t#endif\n#endif\n\n#if !defined(CUTE_SYNC_ASSERT)\n\t#include <assert.h>\n\t#define CUTE_SYNC_ASSERT assert\n#endif\n\n#if !defined(CUTE_SYNC_CACHELINE_SIZE)\n\t// Sized generously to try and avoid guessing \"too low\". Too small would incur serious overhead\n\t// inside of `cute_threadpool_t` as false sharing would run amok between pooled threads.\n\t#define CUTE_SYNC_CACHELINE_SIZE 128\n#endif\n\n// Atomics implementation.\n// Use SDL2's implementation if available, otherwise WIN32 and GCC-like compilers are supported out-of-the-box.\n#ifdef CUTE_SYNC_SDL\n\nint cute_atomic_add(cute_atomic_int_t* atomic, int addend)\n{\n\treturn SDL_AtomicAdd((SDL_atomic_t*)atomic, addend);\n}\n\nint cute_atomic_set(cute_atomic_int_t* atomic, int value)\n{\n\treturn SDL_AtomicSet((SDL_atomic_t*)atomic, value);\n}\n\nint cute_atomic_get(cute_atomic_int_t* atomic)\n{\n\treturn SDL_AtomicGet((SDL_atomic_t*)atomic);\n}\n\nint cute_atomic_cas(cute_atomic_int_t* atomic, int expected, int value)\n{\n\treturn SDL_AtomicCAS((SDL_atomic_t*)atomic, expected, value);\n}\n\nvoid* cute_atomic_ptr_set(void** atomic, void* value)\n{\n\treturn SDL_AtomicSetPtr(atomic, value);\n}\n\nvoid* cute_atomic_ptr_get(void** atomic)\n{\n\treturn SDL_AtomicGetPtr(atomic);\n}\n\nint cute_atomic_ptr_cas(void** atomic, void* expected, void* value)\n{\n\treturn SDL_AtomicCASPtr(atomic, expected, value);\n}\n\n#elif defined(CUTE_SYNC_WINDOWS)\n\nint cute_atomic_add(cute_atomic_int_t* atomic, int addend)\n{\n\treturn (int)_InterlockedExchangeAdd(&atomic->i, (LONG)addend);\n}\n\nint cute_atomic_set(cute_atomic_int_t* atomic, int value)\n{\n\treturn (int)_InterlockedExchange(&atomic->i, value);\n}\n\nint cute_atomic_get(cute_atomic_int_t* atomic)\n{\n\treturn (int)_InterlockedCompareExchange(&atomic->i, 0, 0);\n}\n\nint cute_atomic_cas(cute_atomic_int_t* atomic, int expected, int value)\n{\n\treturn (int)_InterlockedCompareExchange(&atomic->i, value, expected) == value;\n}\n\nvoid* cute_atomic_ptr_set(void** atomic, void* value)\n{\n\treturn _InterlockedExchangePointer(atomic, value);\n}\n\nvoid* cute_atomic_ptr_get(void** atomic)\n{\n\treturn _InterlockedCompareExchangePointer(atomic, NULL, NULL);\n}\n\nint cute_atomic_ptr_cas(void** atomic, void* expected, void* value)\n{\n\treturn _InterlockedCompareExchangePointer(atomic, value, expected) == value;\n}\n\n#elif defined(CUTE_SYNC_POSIX)\n\n#if !(defined(__linux__) || defined(__APPLE__) || defined(__ANDROID__))\n#\terror Unsupported platform found - no atomics implementation available for this compiler.\n#\terror The section only implements GCC atomics.\n#endif\n\nint cute_atomic_add(cute_atomic_int_t* atomic, int addend)\n{\n\treturn (int)__sync_fetch_and_add(&atomic->i, addend);\n}\n\nint cute_atomic_set(cute_atomic_int_t* atomic, int value)\n{\n\tint result = (int)__sync_lock_test_and_set(&atomic->i, value);\n\t__sync_lock_release(&atomic->i);\n\treturn result;\n}\n\nint cute_atomic_get(cute_atomic_int_t* atomic)\n{\n\treturn (int)__sync_fetch_and_add(&atomic->i, 0);\n}\n\nint cute_atomic_cas(cute_atomic_int_t* atomic, int expected, int value)\n{\n\treturn (int)__sync_val_compare_and_swap(&atomic->i, expected, value) == value;\n}\n\nvoid* cute_atomic_ptr_set(void** atomic, void* value)\n{\n\tvoid* result = __sync_lock_test_and_set(atomic, value);\n\t__sync_lock_release(atomic);\n\treturn result;\n}\n\nvoid* cute_atomic_ptr_get(void** atomic)\n{\n\treturn __sync_fetch_and_add(atomic, NULL);\n}\n\nint cute_atomic_ptr_cas(void** atomic, void* expected, void* value)\n{\n\treturn __sync_val_compare_and_swap(atomic, expected, value) == value;\n}\n\n#endif // End atomics implementation.\n\n#if defined(CUTE_SYNC_SDL)\n\ncute_mutex_t cute_mutex_create()\n{\n\tcute_mutex_t mutex;\n\tmutex.align = SDL_CreateMutex();\n\treturn mutex;\n}\n\nint cute_lock(cute_mutex_t* mutex)\n{\n\treturn !SDL_LockMutex((SDL_mutex*)mutex->align);\n}\n\nint cute_unlock(cute_mutex_t* mutex)\n{\n\treturn !SDL_UnlockMutex((SDL_mutex*)mutex->align);\n}\n\nint cute_trylock(cute_mutex_t* mutex)\n{\n\treturn !SDL_TryLockMutex((SDL_mutex*)mutex->align);\n}\n\nvoid cute_mutex_destroy(cute_mutex_t* mutex)\n{\n\tSDL_DestroyMutex((SDL_mutex*)mutex->align);\n}\n\ncute_cv_t cute_cv_create()\n{\n\tcute_cv_t cv;\n\tcv.align = SDL_CreateCond();\n\treturn cv;\n}\n\nint cute_cv_wake_all(cute_cv_t* cv)\n{\n\treturn !SDL_CondBroadcast((SDL_cond*)cv->align);\n}\n\nint cute_cv_wake_one(cute_cv_t* cv)\n{\n\treturn !SDL_CondSignal((SDL_cond*)cv->align);\n}\n\nint cute_cv_wait(cute_cv_t* cv, cute_mutex_t* mutex)\n{\n\treturn !SDL_CondWait((SDL_cond*)cv, (SDL_mutex*)mutex->align);\n}\n\nvoid cute_cv_destroy(cute_cv_t* cv)\n{\n\tSDL_DestroyCond((SDL_cond*)cv->align);\n}\n\ncute_semaphore_t cute_semaphore_create(int initial_count)\n{\n\tcute_semaphore_t semaphore;\n\tsemaphore.id = SDL_CreateSemaphore(initial_count);\n\tsemaphore.count.i = initial_count;\n\treturn semaphore;\n}\n\nint cute_semaphore_post(cute_semaphore_t* semaphore)\n{\n\treturn !SDL_SemPost((SDL_sem*)semaphore->id);\n}\n\nint cute_semaphore_try(cute_semaphore_t* semaphore)\n{\n\treturn !SDL_SemTryWait((SDL_sem*)semaphore->id);\n}\n\nint cute_semaphore_wait(cute_semaphore_t* semaphore)\n{\n\treturn !SDL_SemWait((SDL_sem*)semaphore->id);\n}\n\nint cute_semaphore_value(cute_semaphore_t* semaphore)\n{\n\treturn SDL_SemValue((SDL_sem*)semaphore->id);\n}\n\nvoid cute_semaphore_destroy(cute_semaphore_t* semaphore)\n{\n\tSDL_DestroySemaphore((SDL_sem*)semaphore->id);\n}\n\ncute_thread_t* cute_thread_create(cute_thread_fn func, const char* name, void* udata)\n{\n\treturn (cute_thread_t*)SDL_CreateThread(func, name, udata);\n}\n\nvoid cute_thread_detach(cute_thread_t* thread)\n{\n\tSDL_DetachThread((SDL_Thread*)thread);\n}\n\ncute_thread_id_t cute_thread_get_id(cute_thread_t* thread)\n{\n\treturn SDL_GetThreadID((SDL_Thread*)thread);\n}\n\ncute_thread_id_t cute_thread_id()\n{\n\treturn SDL_ThreadID();\n}\n\nint cute_thread_wait(cute_thread_t* thread)\n{\n\tint ret;\n\tSDL_WaitThread((SDL_Thread*)thread, &ret);\n\treturn ret;\n}\n\nint cute_core_count()\n{\n\treturn SDL_GetCPUCount();\n}\n\nint cute_cacheline_size()\n{\n\treturn SDL_GetCPUCacheLineSize();\n}\n\nint cute_ram_size()\n{\n\treturn SDL_GetSystemRAM();\n}\n\n#elif defined(CUTE_SYNC_WINDOWS)\n\ncute_mutex_t cute_mutex_create()\n{\n\tCUTE_SYNC_ASSERT(sizeof(CRITICAL_SECTION) <= sizeof(cute_mutex_t));\n\tcute_mutex_t mutex;\n\tInitializeCriticalSectionAndSpinCount((CRITICAL_SECTION*)&mutex, 2000);\n\treturn mutex;\n}\n\nint cute_lock(cute_mutex_t* mutex)\n{\n\tEnterCriticalSection((CRITICAL_SECTION*)mutex);\n\treturn 1;\n}\n\nint cute_unlock(cute_mutex_t* mutex)\n{\n\tLeaveCriticalSection((CRITICAL_SECTION*)mutex);\n\treturn 1;\n}\n\nint cute_trylock(cute_mutex_t* mutex)\n{\n\treturn !TryEnterCriticalSection((CRITICAL_SECTION*)mutex);\n}\n\nvoid cute_mutex_destroy(cute_mutex_t* mutex)\n{\n\tDeleteCriticalSection((CRITICAL_SECTION*)mutex);\n}\n\ncute_cv_t cute_cv_create()\n{\n\tCUTE_SYNC_ASSERT(sizeof(CONDITION_VARIABLE) <= sizeof(cute_cv_t));\n\tcute_cv_t cv;\n\tInitializeConditionVariable((CONDITION_VARIABLE*)&cv);\n\treturn cv;\n}\n\nint cute_cv_wake_all(cute_cv_t* cv)\n{\n\tWakeAllConditionVariable((CONDITION_VARIABLE*)cv);\n\treturn 1;\n}\n\nint cute_cv_wake_one(cute_cv_t* cv)\n{\n\tWakeConditionVariable((CONDITION_VARIABLE*)cv);\n\treturn 1;\n}\n\nint cute_cv_wait(cute_cv_t* cv, cute_mutex_t* mutex)\n{\n\treturn !!SleepConditionVariableCS((CONDITION_VARIABLE*)cv, (CRITICAL_SECTION*)mutex, INFINITE);\n}\n\nvoid cute_cv_destroy(cute_cv_t* cv)\n{\n\t// Nothing needed here on Windows... Weird!\n\t// https://stackoverflow.com/questions/28975958/why-does-windows-have-no-deleteconditionvariable-function-to-go-together-with\n}\n\ncute_semaphore_t cute_semaphore_create(int initial_count)\n{\n\tcute_semaphore_t semaphore;\n\tsemaphore.id = CreateSemaphoreA(NULL, (LONG)initial_count, LONG_MAX, NULL);\n\tsemaphore.count.i = initial_count;\n\treturn semaphore;\n}\n\nint cute_semaphore_post(cute_semaphore_t* semaphore)\n{\n\t_InterlockedIncrement(&semaphore->count.i);\n\tif (ReleaseSemaphore(semaphore->id, 1, NULL) == FALSE) {\n\t\t_InterlockedDecrement(&semaphore->count.i);\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nstatic int s_wait(cute_semaphore_t* semaphore, DWORD milliseconds)\n{\n\tif (WaitForSingleObjectEx(semaphore->id, milliseconds, FALSE) == WAIT_OBJECT_0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint cute_semaphore_try(cute_semaphore_t* semaphore)\n{\n\treturn s_wait(semaphore, 0);\n}\n\nint cute_semaphore_wait(cute_semaphore_t* semaphore)\n{\n\treturn s_wait(semaphore, INFINITE);\n}\n\nint cute_semaphore_value(cute_semaphore_t* semaphore)\n{\n\treturn cute_atomic_get(&semaphore->count);\n}\n\nvoid cute_semaphore_destroy(cute_semaphore_t* semaphore)\n{\n\tCloseHandle((HANDLE)semaphore->id);\n}\n\ncute_thread_t* cute_thread_create(cute_thread_fn fn, const char* name, void* udata)\n{\n\t(void)name;\n\tDWORD unused;\n\tHANDLE id = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, udata, 0, &unused);\n\treturn (cute_thread_t*)id;\n}\n\nvoid cute_thread_detach(cute_thread_t* thread)\n{\n\tCloseHandle((HANDLE)thread);\n}\n\ncute_thread_id_t cute_thread_get_id(cute_thread_t* thread)\n{\n\treturn GetThreadId((HANDLE)thread);\n}\n\ncute_thread_id_t cute_thread_id()\n{\n\treturn GetCurrentThreadId();\n}\n\nint cute_thread_wait(cute_thread_t* thread)\n{\n\tWaitForSingleObject((HANDLE)thread, INFINITE);\n\tCloseHandle((HANDLE)thread);\n\treturn 1;\n}\n\nint cute_core_count()\n{\n\tSYSTEM_INFO info;\n\tGetSystemInfo(&info);\n\treturn (int)info.dwNumberOfProcessors;\n}\n\nint cute_cacheline_size()\n{\n\tDWORD buffer_size;\n\tSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer[256];\n\n\tGetLogicalProcessorInformation(0, &buffer_size);\n\tDWORD buffer_count = buffer_size / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);\n\tif (buffer_count > 256) {\n\t\t// Just guess... Since this machine has more than 256 cores?\n\t\t// Supporting more than 256 cores would probably require a malloc here.\n\t\treturn 128;\n\t}\n\n\tGetLogicalProcessorInformation(buffer, &buffer_size);\n\n\tfor (DWORD i = 0; i < buffer_count; ++i) {\n\t\tif (buffer[i].Relationship == RelationCache && buffer[i].Cache.Level == 1) {\n\t\t\treturn (int)buffer[i].Cache.LineSize;\n\t\t}\n\t}\n\n\t// Just guess...\n\treturn 128;\n}\n\nint cute_ram_size()\n{\n\tMEMORYSTATUSEX status;\n\tstatus.dwLength = sizeof(status);\n\tGlobalMemoryStatusEx(&status);\n\treturn (int)(status.ullTotalPhys / (1024 * 1024));\n}\n\n#elif defined(CUTE_SYNC_POSIX)\n\ncute_mutex_t cute_mutex_create()\n{\n\tCUTE_SYNC_ASSERT(sizeof(pthread_mutex_t) <= sizeof(cute_mutex_t));\n\tcute_mutex_t mutex;\n\tpthread_mutex_init((pthread_mutex_t*)&mutex, NULL);\n\treturn mutex;\n}\n\nint cute_lock(cute_mutex_t* mutex)\n{\n\tpthread_mutex_lock((pthread_mutex_t*)mutex);\n\treturn 1;\n}\n\nint cute_unlock(cute_mutex_t* mutex)\n{\n\tpthread_mutex_unlock((pthread_mutex_t*)mutex);\n\treturn 1;\n}\n\nint cute_trylock(cute_mutex_t* mutex)\n{\n\treturn !pthread_mutex_trylock((pthread_mutex_t*)mutex);\n}\n\nvoid cute_mutex_destroy(cute_mutex_t* mutex)\n{\n\tpthread_mutex_destroy((pthread_mutex_t*)mutex);\n}\n\ncute_cv_t cute_cv_create()\n{\n\tCUTE_SYNC_ASSERT(sizeof(pthread_cond_t) <= sizeof(cute_cv_t));\n\tcute_cv_t cv;\n\tpthread_cond_init((pthread_cond_t*)&cv, NULL);\n\treturn cv;\n}\n\nint cute_cv_wake_all(cute_cv_t* cv)\n{\n\tpthread_cond_broadcast((pthread_cond_t*)cv);\n\treturn 1;\n}\n\nint cute_cv_wake_one(cute_cv_t* cv)\n{\n\tpthread_cond_signal((pthread_cond_t*)cv);\n\treturn 1;\n}\n\nint cute_cv_wait(cute_cv_t* cv, cute_mutex_t* mutex)\n{\n\treturn !pthread_cond_wait((pthread_cond_t*)cv, (pthread_mutex_t*)mutex);\n}\n\nvoid cute_cv_destroy(cute_cv_t* cv)\n{\n\tpthread_cond_destroy((pthread_cond_t*)cv);\n}\n\n#if !defined(__APPLE__)\n\ncute_semaphore_t cute_semaphore_create(int initial_count)\n{\n\tcute_semaphore_t semaphore;\n\tsemaphore.id = CUTE_SYNC_ALLOC(sizeof(sem_t), NULL);\n\tsem_init((sem_t*)semaphore.id, 0, (unsigned)initial_count);\n\tsemaphore.count.i = initial_count;\n\treturn semaphore;\n}\n\nint cute_semaphore_post(cute_semaphore_t* semaphore)\n{\n\treturn !sem_post((sem_t*)semaphore->id);\n}\n\nint cute_semaphore_try(cute_semaphore_t* semaphore)\n{\n\treturn !sem_trywait((sem_t*)semaphore->id);\n}\n\nint cute_semaphore_wait(cute_semaphore_t* semaphore)\n{\n\treturn !sem_wait((sem_t*)semaphore->id);\n}\n\nint cute_semaphore_value(cute_semaphore_t* semaphore)\n{\n\tint result = 0;\n\tsem_getvalue((sem_t*)semaphore->id, &result);\n\treturn result;\n}\n\nvoid cute_semaphore_destroy(cute_semaphore_t* semaphore)\n{\n\tsem_destroy((sem_t*)semaphore->id);\n\tCUTE_SYNC_FREE(semaphore->id, NULL);\n}\n\n#elif defined(__APPLE__)\n\n// Because Apple sucks and deprecated posix semaphores we must make our own...\n\ntypedef struct cute_apple_sem_t\n{\n\tint count;\n\tint waiting_count;\n\tcute_mutex_t lock;\n\tcute_cv_t cv;\n} cute_apple_sem_t;\n\ncute_semaphore_t cute_semaphore_create(int initial_count)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)CUTE_SYNC_ALLOC(sizeof(cute_apple_sem_t), NULL);\n\tapple_sem->count = initial_count;\n\tapple_sem->waiting_count = 0;\n\tapple_sem->lock = cute_mutex_create();\n\tapple_sem->cv = cute_cv_create();\n\tcute_semaphore_t semaphore;\n\tsemaphore.id = (void*)apple_sem;\n\tsemaphore.count.i = initial_count;\n\treturn semaphore;\n}\n\nint cute_semaphore_post(cute_semaphore_t* semaphore)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)semaphore->id;\n\tcute_lock(&apple_sem->lock);\n\tif (apple_sem->waiting_count > 0) {\n\t\tcute_cv_wake_one(&apple_sem->cv);\n\t}\n\tapple_sem->count += 1;\n\tcute_unlock(&apple_sem->lock);\n\treturn 1;\n}\n\nint cute_semaphore_try(cute_semaphore_t* semaphore)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)semaphore->id;\n\tint result = 0;\n\tcute_lock(&apple_sem->lock);\n\tif (apple_sem->count > 0) {\n\t\tapple_sem->count -= 1;\n\t\tresult = 1;\n\t}\n\tcute_unlock(&apple_sem->lock);\n\treturn result;\n}\n\nint cute_semaphore_wait(cute_semaphore_t* semaphore)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)semaphore->id;\n\tint result = 1;\n\tcute_lock(&apple_sem->lock);\n\twhile (apple_sem->count == 0 && result) {\n\t\tresult = cute_cv_wait(&apple_sem->cv, &apple_sem->lock);\n\t}\n\tapple_sem->waiting_count -= 1;\n\tif (result) {\n\t\tapple_sem->count -= 1;\n\t}\n\tcute_unlock(&apple_sem->lock);\n\treturn result;\n}\n\nint cute_semaphore_value(cute_semaphore_t* semaphore)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)semaphore->id;\n\tint value;\n\tcute_lock(&apple_sem->lock);\n\tvalue = apple_sem->count;\n\tcute_unlock(&apple_sem->lock);\n\treturn value;\n}\n\nvoid cute_semaphore_destroy(cute_semaphore_t* semaphore)\n{\n\tcute_apple_sem_t* apple_sem = (cute_apple_sem_t*)semaphore->id;\n\twhile (apple_sem->waiting_count > 0) {\n\t\tcute_cv_wake_all(&apple_sem->cv);\n\t\tCUTE_SYNC_YIELD();\n\t}\n\tcute_cv_destroy(&apple_sem->cv);\n\tcute_lock(&apple_sem->lock);\n\tcute_unlock(&apple_sem->lock);\n\tcute_mutex_destroy(&apple_sem->lock);\n\tCUTE_SYNC_FREE(apple_sem, NULL);\n}\n\n#endif\n\ncute_thread_t* cute_thread_create(cute_thread_fn fn, const char* name, void* udata)\n{\n\tpthread_t thread;\n\tpthread_create(&thread, NULL, (void* (*)(void*))fn, udata);\n#if !defined(__APPLE__)\n\tif (name) pthread_setname_np(thread, name);\n#else\n\t(void)name;\n#endif\n\treturn (cute_thread_t*)thread;\n}\n\nvoid cute_thread_detach(cute_thread_t* thread)\n{\n\tpthread_detach((pthread_t)thread);\n}\n\ncute_thread_id_t cute_thread_get_id(cute_thread_t* thread)\n{\n\treturn (cute_thread_id_t)thread;\n}\n\ncute_thread_id_t cute_thread_id()\n{\n\treturn (cute_thread_id_t)pthread_self();\n}\n\nint cute_thread_wait(cute_thread_t* thread)\n{\n\tpthread_join((pthread_t)thread, NULL);\n\treturn 1;\n}\n\nint cute_core_count()\n{\n\treturn (int)sysconf(_SC_NPROCESSORS_ONLN);\n}\n\nint cute_cacheline_size()\n{\n#if defined(__APPLE__)\n\tsize_t sz;\n\tsize_t szsz = sizeof(sz);\n\tsysctlbyname(\"hw.cachelinesize\", &sz, &szsz, 0, 0);\n\treturn (int)sz;\n#else\n\treturn (int)sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n#endif\n}\n\nint cute_ram_size()\n{\n\treturn (int)(sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGESIZE) / (1024*1024));\n}\n\n#else\n\n\t#error Please choose a base implementation between CUTE_SYNC_SDL, CUTE_SYNC_WINDOWS and CUTE_SYNC_POSIX.\n\n#endif\n\ncute_rw_lock_t cute_rw_lock_create()\n{\n\tcute_rw_lock_t rw;\n\trw.mutex = cute_mutex_create();\n\trw.write_sem = cute_semaphore_create(0);\n\trw.read_sem = cute_semaphore_create(0);\n\trw.readers.i = 0;\n\trw.readers_departing.i = 0;\n\treturn rw;\n}\n\nvoid cute_read_lock(cute_rw_lock_t* rw)\n{\n\t// Wait on writers.\n\t// Negative means locked for writing, or there is a pending writer.\n\tif (cute_atomic_add(&rw->readers, 1) < 0) {\n\t\tcute_semaphore_wait(&rw->read_sem);\n\t}\n}\n\nvoid cute_read_unlock(cute_rw_lock_t* rw)\n{\n\t// Write is pending.\n\tif (cute_atomic_add(&rw->readers, -1) < 0) {\n\t\t// The final departing reader notifies the pending writer.\n\t\tif (cute_atomic_add(&rw->readers_departing, -1) - 1 == 0) {\n\t\t\tcute_semaphore_post(&rw->write_sem);\n\t\t}\n\t}\n}\n\nvoid cute_write_lock(cute_rw_lock_t* rw)\n{\n\tcute_lock(&rw->mutex);\n\n\t// Flip to negative to force new readers to wait. Record the number of active\n\t// readers at that moment, which need to depart to allow write access.\n\tint readers = cute_atomic_add(&rw->readers, -CUTE_RW_LOCK_MAX_READERS);\n\n\t// Wait for departing readers.\n\tif (cute_atomic_add(&rw->readers_departing, readers) + readers != 0) {\n\t\tcute_semaphore_wait(&rw->write_sem);\n\t}\n}\n\nvoid cute_write_unlock(cute_rw_lock_t* rw)\n{\n\t// Flip to positive to allow new readers. Record the number of waiting readers\n\t// at that moment.\n\tint readers = cute_atomic_add(&rw->readers, CUTE_RW_LOCK_MAX_READERS) + CUTE_RW_LOCK_MAX_READERS;\n\n\t// Signal all waiting readers to wake.\n\tfor (int i = 0; i < readers; ++i) {\n\t\tcute_semaphore_post(&rw->read_sem);\n\t}\n\n\tcute_unlock(&rw->mutex);\n}\n\nvoid cute_rw_lock_destroy(cute_rw_lock_t* rw)\n{\n\tcute_mutex_destroy(&rw->mutex);\n\tcute_semaphore_destroy(&rw->write_sem);\n\tcute_semaphore_destroy(&rw->read_sem);\n}\n\n#define CUTE_SYNC_ALIGN_PTR(X, Y) ((((size_t)X) + ((Y) - 1)) & ~((Y) - 1))\n\nstatic void* cute_malloc_aligned(size_t size, int alignment, void* mem_ctx)\n{\n\t(void)mem_ctx;\n\tint is_power_of_2 = alignment && !(alignment & (alignment - 1));\n\tCUTE_SYNC_ASSERT(is_power_of_2);\n\tvoid* p = CUTE_SYNC_ALLOC(size + alignment, mem_ctx);\n\tif (!p) return 0;\n\tunsigned char offset = (unsigned char)((size_t)p & (alignment - 1));\n\tp = (void*)CUTE_SYNC_ALIGN_PTR(p + 1, alignment);\n\t*((char*)p - 1) = alignment - offset;\n\treturn p;\n}\n\nstatic void cute_free_aligned(void* p, void* mem_ctx)\n{\n\t(void)mem_ctx;\n\tif (!p) return;\n\tsize_t alignment = (size_t)*((char*)p - 1) & 0xFF;\n\tCUTE_SYNC_FREE((char*)p - alignment, mem_ctx);\n}\n\ntypedef struct cute_task_t\n{\n\tvoid (*do_work)(void*);\n\tvoid* param;\n} cute_task_t;\n\ntypedef struct cute_threadpool_t\n{\n\tint task_capacity;\n\tint task_count;\n\tcute_task_t* tasks;\n\tcute_mutex_t task_mutex;\n\n\tint thread_count;\n\tcute_thread_t** threads;\n\n\tcute_atomic_int_t running;\n\tcute_mutex_t sem_mutex;\n\tcute_semaphore_t semaphore;\n\tvoid* mem_ctx;\n} cute_threadpool_t;\n\nint cute_try_pop_task_internal(cute_threadpool_t* pool, cute_task_t* task)\n{\n\tcute_lock(&pool->task_mutex);\n\n\tif (pool->task_count) {\n\t\t*task = pool->tasks[--pool->task_count];\n\t\tcute_unlock(&pool->task_mutex);\n\t\treturn 1;\n\t}\n\n\tcute_unlock(&pool->task_mutex);\n\treturn 0;\n}\n\nint cute_worker_thread_internal(void* udata)\n{\n\tcute_threadpool_t* pool = (cute_threadpool_t*)udata;\n\twhile (cute_atomic_get(&pool->running)) {\n\t\tcute_task_t task;\n\t\tif (cute_try_pop_task_internal(pool, &task)) {\n\t\t\ttask.do_work(task.param);\n\t\t}\n\n\t\tcute_semaphore_wait(&pool->semaphore);\n\t}\n\treturn 0;\n}\n\ncute_threadpool_t* cute_threadpool_create(int thread_count, void* mem_ctx)\n{\n\tif (CUTE_SYNC_CACHELINE_SIZE < cute_cacheline_size()) return 0;\n\n\tcute_threadpool_t* pool = (cute_threadpool_t*)CUTE_SYNC_ALLOC(sizeof(cute_threadpool_t), mem_ctx);\n\tpool->task_capacity = 64;\n\tpool->task_count = 0;\n\tpool->tasks = (cute_task_t*)cute_malloc_aligned(sizeof(cute_task_t) * pool->task_capacity, CUTE_SYNC_CACHELINE_SIZE, mem_ctx);\n\tpool->task_mutex = cute_mutex_create();\n\tpool->thread_count = thread_count;\n\tpool->threads = (cute_thread_t**)cute_malloc_aligned(sizeof(cute_thread_t*) * thread_count, CUTE_SYNC_CACHELINE_SIZE, mem_ctx);\n\tcute_atomic_set(&pool->running, 1);\n\tpool->sem_mutex = cute_mutex_create();\n\tpool->semaphore = cute_semaphore_create(0);\n\tpool->mem_ctx = mem_ctx;\n\n\tfor (int i = 0; i < thread_count; ++i) {\n\t\tpool->threads[i] = cute_thread_create(cute_worker_thread_internal, 0, pool);\n\t}\n\n\treturn pool;\n}\n\nvoid cute_threadpool_add_task(cute_threadpool_t* pool, void (*func)(void*), void* param)\n{\n\tcute_lock(&pool->task_mutex);\n\n\tif (pool->task_count == pool->task_capacity) {\n\t\tint new_cap = pool->task_capacity * 2;\n\t\tcute_task_t* new_tasks = (cute_task_t*)cute_malloc_aligned(sizeof(cute_task_t) * new_cap, CUTE_SYNC_CACHELINE_SIZE, pool->mem_ctx);\n\t\tCUTE_SYNC_MEMCPY(new_tasks, pool->tasks, sizeof(cute_task_t) * pool->task_count);\n\t\tcute_free_aligned(pool->tasks, pool->mem_ctx);\n\t\tpool->task_capacity = new_cap;\n\t\tpool->tasks = new_tasks;\n\t}\n\n\tcute_task_t task;\n\ttask.do_work = func;\n\ttask.param = param;\n\tpool->tasks[pool->task_count++] = task;\n\n\tcute_unlock(&pool->task_mutex);\n}\n\nvoid cute_threadpool_kick_and_wait(cute_threadpool_t* pool)\n{\n\tcute_threadpool_kick(pool);\n\n\twhile (pool->task_count) {\n\t\tcute_task_t task;\n\t\tif (cute_try_pop_task_internal(pool, &task)) {\n\t\t\tcute_semaphore_try(&pool->semaphore);\n\t\t\ttask.do_work(task.param);\n\t\t}\n\t\tCUTE_SYNC_YIELD();\n\t}\n}\n\nvoid cute_threadpool_kick(cute_threadpool_t* pool)\n{\n\tif (pool->task_count) {\n\t\tint count = pool->task_count < pool->thread_count ? pool->task_count : pool->thread_count;\n\t\tfor (int i = 0; i < count; ++i) {\n\t\t\tcute_semaphore_post(&pool->semaphore);\n\t\t}\n\t}\n}\n\nvoid cute_threadpool_destroy(cute_threadpool_t* pool)\n{\n\tcute_atomic_set(&pool->running, 0);\n\n\tfor (int i = 0; i < pool->thread_count; ++i) {\n\t\tcute_semaphore_post(&pool->semaphore);\n\t}\n\n\tfor (int i = 0; i < pool->thread_count; ++i) {\n\t\tcute_thread_wait(pool->threads[i]);\n\t}\n\n\tcute_free_aligned(pool->tasks, pool->mem_ctx);\n\tcute_free_aligned(pool->threads, pool->mem_ctx);\n\tvoid* mem_ctx = pool->mem_ctx;\n\t(void)mem_ctx;\n\tCUTE_SYNC_FREE(pool, mem_ctx);\n}\n\n#endif // CUTE_SYNC_IMPLEMENTATION_ONCE\n#endif // CUTE_SYNC_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2019 Randy Gaul http://www.randygaul.net\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\n\tsoftware, either in source code form or as a compiled binary, for any purpose,\n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this\n\tsoftware dedicate any and all copyright interest in the software to the public\n\tdomain. We make this dedication for the benefit of the public at large and to\n\tthe detriment of our heirs and successors. We intend this dedication to be an\n\tovert act of relinquishment in perpetuity of all present and future rights to\n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_tiled.h",
          "type": "blob",
          "size": 94.099609375,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_tiled.h - v1.06\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_TILED_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\tSUMMARY\n\n\t\tParses Tiled (http://www.mapeditor.org/) files saved as the JSON file\n\t\tformat. See http://doc.mapeditor.org/en/latest/reference/json-map-format/\n\t\tfor a complete description of the JSON Tiled format. An entire map file\n\t\tis loaded up in entirety and used to fill in a set of structs. The entire\n\t\tstruct collection is then handed to the user.\n\n\t\tThis header is up to date with Tiled's documentation Revision 40049fd5 and\n\t\tverified to work with Tiled stable version 1.4.1.\n\t\thttp://doc.mapeditor.org/en/latest/reference/json-map-format/\n\n\t\tHere is a past discussion thread on this header:\n\t\thttps://www.reddit.com/r/gamedev/comments/87680n/cute_tiled_tiled_json_map_parserloader_in_c/\n\n\tRevision history:\n\t\t1.00 (03/24/2018) initial release\n\t\t1.01 (05/04/2018) tile descriptors in tilesets for collision geometry\n\t\t1.02 (05/07/2018) reverse lists for ease of use, incorporate fixes by ZenToad\n\t\t1.03 (01/11/2019) support for Tiled 1.2.1 with the help of dpeter99 and tanis2000\n\t\t1.04 (04/30/2020) support for Tiled 1.3.3 with the help of aganm\n\t\t1.05 (07/19/2020) support for Tiled 1.4.1 and tileset tile animations\n\t\t1.06 (04/05/2021) support for Tiled 1.5.0 parallax\n\t\t1.07 (03/01/2022) support for c89\n*/\n\n/*\n\tContributors:\n\t\tZenToad           1.02 - Bug reports and goto statement errors for g++\n\t\tdpeter99          1.03 - Help with updating to Tiled 1.2.1 JSON format\n\t\ttanis2000         1.03 - Help with updating to Tiled 1.2.1 JSON format\n\t\taganm             1.04 - Help with updating to Tiled 1.3.3 JSON format\n\t\tmupf              1.07 - Adding support for C89\n*/\n\n/*\n\tDOCUMENTATION\n\n\t\tLoad up a Tiled json exported file, either from disk or memory, like so:\n\n\t\t\tcute_tiled_map_t* map = cute_tiled_load_map_from_memory(memory, size, 0);\n\n\t\tThen simply access the map's fields like so:\n\n\t\t\t// get map width and height\n\t\t\tint w = map->width;\n\t\t\tint h = map->height;\n\n\t\t\t// loop over the map's layers\n\t\t\tcute_tiled_layer_t* layer = map->layers;\n\t\t\twhile (layer)\n\t\t\t{\n\t\t\t\tint* data = layer->data;\n\t\t\t\tint data_count = layer->data_count;\n\n\t\t\t\t// do something with the tile data\n\t\t\t\tUserFunction_HandleTiles(data, data_count);\n\n\t\t\t\tlayer = layer->next;\n\t\t\t}\n\n\t\tFinally, free it like so:\n\n\t\t\tcute_tiled_free_map(map);\n\n\tLIMITATIONS\n\n\t\tMore uncommon fields are not supported, and are annotated in this header.\n\t\tSearch for \"Not currently supported.\" without quotes to find them. cute_tiled\n\t\tlogs a warning whenever a known unsupported field is encountered, and will\n\t\tattempt to gracefully skip the field. If a field with completely unknown\n\t\tsyntax is encountered (which can happen if cute_tiled is used on a newer\n\t\tand unsupported version of Tiled), undefined behavior may occur (crashes).\n\n\t\tIf you would like a certain feature to be supported simply open an issue on\n\t\tGitHub and provide a JSON exported map with the unsupported features. Changing\n\t\tthe parser to support new fields and objects is quite easy, as long as a map\n\t\tfile is provided for debugging and testing!\n\n\t\tGitHub : https://github.com/RandyGaul/cute_headers/\n\n\t\tCompression of the tile GIDs is *not* supported in this header. Exporting\n\t\ta map from Tiled will create a JSON file. This JSON file itself can very\n\t\ttrivially be compressed in its entirety, thus making Tiled's internal\n\t\tcompression exporting not a useful feature for this header to support.\n\t\tSimply wrap calls to `cute_tiled_load_map_from_file` in a decompression\n\t\troutine. Here is an example (assuming `zlib_uncompress` is already imp-\n\t\tlemented somewhere in the user's codebase):\n\n\t\t\tint size;\n\t\t\tvoid* uncompressed_data = zlib_uncompress(path_to_zipped_map_file, &size);\n\t\t\tcute_tiled_map_t* map = cute_tiled_load_map_from_memory(uncompressed_data, size, 0);\n*/\n\n#if !defined(CUTE_TILED_H)\n\n#include <stdint.h> // uint32_t\n\n// Read this in the event of errors\nextern const char* cute_tiled_error_reason;\nextern int cute_tiled_error_line;\n\n\ntypedef struct cute_tiled_map_t cute_tiled_map_t;\ntypedef struct cute_tiled_tileset_t cute_tiled_tileset_t;\n\n/*!\n * Load a map from disk, placed into heap allocated memory. \\p mem_ctx can be\n * NULL. It is used for custom allocations.\n */\ncute_tiled_map_t* cute_tiled_load_map_from_file(const char* path, void* mem_ctx);\n\n/*!\n * Load a map from memory. \\p mem_ctx can be NULL. It is used for custom allocations.\n */\ncute_tiled_map_t* cute_tiled_load_map_from_memory(const void* memory, int size_in_bytes, void* mem_ctx);\n\n/*!\n * Reverses the layers order, so they appear in reverse-order from what is shown in the Tiled editor.\n */\nvoid cute_tiled_reverse_layers(cute_tiled_map_t* map);\n\n/*!\n * Free all dynamic memory associated with this map.\n */\nvoid cute_tiled_free_map(cute_tiled_map_t* map);\n\n/*!\n * Load an external tileset from disk, placed into heap allocated memory. \\p mem_ctx can be\n * NULL. It is used for custom allocations.\n *\n * Please note this function is *entirely optional*, and only useful if you want to intentionally\n * load tilesets externally from your map. If so, please also consider defining\n * `CUTE_TILED_NO_EXTERNAL_TILESET_WARNING` to disable warnings about missing embedded tilesets.\n */\ncute_tiled_tileset_t* cute_tiled_load_external_tileset(const char* path, void* mem_ctx);\n\n/*!\n * Load an external tileset from memory. \\p mem_ctx can be NULL. It is used for custom allocations.\n *\n * Please note this function is *entirely optional*, and only useful if you want to intentionally\n * load tilesets externally from your map. If so, please also consider defining\n * `CUTE_TILED_NO_EXTERNAL_TILESET_WARNING` to disable warnings about missing embedded tilesets.\n */\ncute_tiled_tileset_t* cute_tiled_load_external_tileset_from_memory(const void* memory, int size_in_bytes, void* mem_ctx);\n\n/*!\n * Free all dynamic memory associated with this external tileset.\n */\nvoid cute_tiled_free_external_tileset(cute_tiled_tileset_t* tileset);\n\n#if !defined(CUTE_TILED_U64)\n\t#define CUTE_TILED_U64 unsigned long long\n#endif\n\n#if !defined(CUTE_TILED_INLINE)\n\t#if defined(_MSC_VER)\n\t\t#define CUTE_TILED_INLINE __inline\n\t#else\n\t\t#define CUTE_TILED_INLINE __inline__\n\t#endif\n#endif\n\ntypedef struct cute_tiled_layer_t cute_tiled_layer_t;\ntypedef struct cute_tiled_object_t cute_tiled_object_t;\ntypedef struct cute_tiled_frame_t cute_tiled_frame_t;\ntypedef struct cute_tiled_tile_descriptor_t cute_tiled_tile_descriptor_t;\ntypedef struct cute_tiled_property_t cute_tiled_property_t;\ntypedef union cute_tiled_string_t cute_tiled_string_t;\n\n/*!\n * To access a string, simply do: object->name.ptr; this union is needed\n * as a workaround for 32-bit builds where the size of a pointer is only\n * 32 bits.\n *\n * More info:\n * This unions is needed to support a single-pass parser, with string\n * interning, where the parser copies value directly into the user-facing\n * structures. As opposed to the parser copying values into an intermediate\n * structure, and finally copying the intermediate values into the\n * user-facing struct at the end. The latter option requires more code!\n */\nunion cute_tiled_string_t\n{\n\tconst char* ptr;\n\tCUTE_TILED_U64 hash_id;\n};\n\ntypedef enum CUTE_TILED_PROPERTY_TYPE\n{\n\tCUTE_TILED_PROPERTY_NONE,\n\tCUTE_TILED_PROPERTY_INT,\n\tCUTE_TILED_PROPERTY_BOOL,\n\tCUTE_TILED_PROPERTY_FLOAT,\n\tCUTE_TILED_PROPERTY_STRING,\n\n\t// Note: currently unused! File properties are reported as strings in\n\t// this header, and it is up to users to know a-priori which strings\n\t// contain file paths.\n\tCUTE_TILED_PROPERTY_FILE,\n\n\tCUTE_TILED_PROPERTY_COLOR,\n} CUTE_TILED_PROPERTY_TYPE;\n\nstruct cute_tiled_property_t\n{\n\tunion\n\t{\n\t\tint integer;\n\t\tint boolean;\n\t\tfloat floating;\n\t\tcute_tiled_string_t string;\n\t\tcute_tiled_string_t file;\n\t\tuint32_t color;\n\t} data;\n\tCUTE_TILED_PROPERTY_TYPE type;\n\tcute_tiled_string_t name;\n};\n\nstruct cute_tiled_object_t\n{\n\tint ellipse;                         // 0 or 1. Used to mark an object as an ellipse.\n\tint gid;                             // GID, only if object comes from a Tilemap.\n\tfloat height;                        // Height in pixels. Ignored if using a gid.\n\tint id;                              // Incremental id - unique across all objects.\n\tcute_tiled_string_t name;            // String assigned to name field in editor.\n\tint point;                           // 0 or 1. Used to mark an object as a point.\n\n\t// Example to index each vert of a polygon/polyline:\n\t/*\n\t\tfloat x, y;\n\t\tfor(int i = 0; i < vert_count * 2; i += 2)\n\t\t{\n\t\t\tx = vertices[i];\n\t\t\ty = vertices[i + 1];\n\t\t}\n\t*/\n\tint vert_count;\n\tfloat* vertices;                     // Represents both type `polyline` and `polygon`.\n\tint vert_type;                       // 1 for `polygon` and 0 for `polyline`.\n\n\tint property_count;                  // Number of elements in the `properties` array.\n\tcute_tiled_property_t* properties;   // Array of properties.\n\tfloat rotation;                      // Angle in degrees clockwise.\n\t/* template */                       // Not currently supported.\n\t/* text */                           // Not currently supported.\n\tcute_tiled_string_t type;            // String assigned to type field in editor.\n\t/* class */                          // Not currently supported.\n\tint visible;                         // 0 or 1. Whether object is shown in editor.\n\tfloat width;                         // Width in pixels. Ignored if using a gid.\n\tfloat x;                             // x coordinate in pixels.\n\tfloat y;                             // y coordinate in pixels.\n\tcute_tiled_object_t* next;           // Pointer to next object. NULL if final object.\n};\n\n/*!\n * Example of using both helper functions below to process the `data` pointer of a layer,\n * containing an array of `GID`s.\n *\n * for (int i = 0; i < layer->data_count; i++)\n * {\n *     int hflip, vflip, dflip;\n *     int tile_id = layer->data[i];\n *     cute_tiled_get_flags(tile_id, &hflip, &vflip, &dflip);\n *     tile_id = cute_tiled_unset_flags(tile_id);\n *     DoSomethingWithFlags(tile_id, flip, vflip, dlfip);\n *     DoSomethingWithTileID(tile_id);\n * }\n */\n\n#define CUTE_TILED_FLIPPED_HORIZONTALLY_FLAG 0x80000000\n#define CUTE_TILED_FLIPPED_VERTICALLY_FLAG   0x40000000\n#define CUTE_TILED_FLIPPED_DIAGONALLY_FLAG   0x20000000\n\n/*!\n * Helper for processing tile data in /ref `cute_tiled_layer_t` `data`. Unsets all of\n * the image flipping flags in the higher bit of /p `tile_data_gid`.\n */\nstatic CUTE_TILED_INLINE int cute_tiled_unset_flags(int tile_data_gid)\n{\n\tconst int flags = ~(CUTE_TILED_FLIPPED_HORIZONTALLY_FLAG | CUTE_TILED_FLIPPED_VERTICALLY_FLAG | CUTE_TILED_FLIPPED_DIAGONALLY_FLAG);\n\treturn tile_data_gid & flags;\n}\n\n/*!\n * Helper for processing tile data in /ref `cute_tiled_layer_t` `data`. Flags are\n * stored in the GID array `data` for flipping the image. Retrieves all three flag types.\n */\nstatic CUTE_TILED_INLINE void cute_tiled_get_flags(int tile_data_gid, int* flip_horizontal, int* flip_vertical, int* flip_diagonal)\n{\n\t*flip_horizontal = !!(tile_data_gid & CUTE_TILED_FLIPPED_HORIZONTALLY_FLAG);\n\t*flip_vertical = !!(tile_data_gid & CUTE_TILED_FLIPPED_VERTICALLY_FLAG);\n\t*flip_diagonal = !!(tile_data_gid & CUTE_TILED_FLIPPED_DIAGONALLY_FLAG);\n}\n\nstruct cute_tiled_layer_t\n{\n\t/* chunks */                         // Not currently supported.\n\tcute_tiled_string_t class_;          // The class of the layer (since 1.9, optional).\n\t/* compression; */                   // Not currently supported.\n\tint data_count;                      // Number of integers in `data`.\n\tint* data;                           // Array of GIDs. `tilelayer` only. Only support CSV style exports.\n\tcute_tiled_string_t draworder;       // `topdown` (default) or `index`. `objectgroup` only.\n\t/* encoding; */                      // Not currently supported.\n\tint height;                          // Row count. Same as map height for fixed-size maps.\n\tcute_tiled_layer_t* layers;          // Linked list of layers. Only appears if `type` is `group`.\n\tcute_tiled_string_t name;            // Name assigned to this layer.\n\tcute_tiled_object_t* objects;        // Linked list of objects. `objectgroup` only.\n\tfloat offsetx;                       // Horizontal layer offset.\n\tfloat offsety;                       // Vertical layer offset.\n\tfloat opacity;                       // Value between 0 and 1.\n\tint property_count;                  // Number of elements in the `properties` array.\n\tcute_tiled_property_t* properties;   // Array of properties.\n\tuint32_t transparentcolor;           // Hex-formatted color (#AARRGGBB) (optional).\n\tuint32_t tintcolor;                  // Hex-formatted color (#AARRGGBB) (optional).\n\tcute_tiled_string_t type;            // `tilelayer`, `objectgroup`, `imagelayer` or `group`.\n\tcute_tiled_string_t image;           // An image filepath. Used if layer is type `imagelayer`.\n\tint visible;                         // 0 or 1. Whether layer is shown or hidden in editor.\n\tint width;                           // Column count. Same as map width for fixed-size maps.\n\tint x;                               // Horizontal layer offset in tiles. Always 0.\n\tint y;                               // Vertical layer offset in tiles. Always 0.\n\tfloat parallaxx;                     // X axis parallax factor.\n\tfloat parallaxy;                     // Y axis parallax factor.\n\tint repeatx;                         // Repeat image in the X direction\n\tint repeaty;                         // Repeat image in the Y direction\n\tint id;                              // ID of the layer.\n\tcute_tiled_layer_t* next;            // Pointer to the next layer. NULL if final layer.\n};\n\nstruct cute_tiled_frame_t\n{\n\tint duration;                        // Frame duration in milliseconds.\n\tint tileid;                          // Local tile ID representing this frame.\n};\n\nstruct cute_tiled_tile_descriptor_t\n{\n\tint tile_index;                      // ID of the tile local to the associated tileset.\n\tcute_tiled_string_t type;            // String assigned to type field in editor.\n\tint frame_count;                     // The number of animation frames in the `animation` array.\n\tcute_tiled_frame_t* animation;       // An array of `cute_tiled_frame_t`'s. Can be NULL.\n\tcute_tiled_string_t image;           // Image used for a tile in a tileset of type collection of images (relative path from map file to source image).\n\t\t\t\t\t     // Tileset is a collection of images if image.ptr isn't NULL.\n\tint imageheight;                     // Image height of a tile in a tileset of type collection of images.\n\tint imagewidth;                      // Image width of a tile in a tileset of type collection of images.\n\tcute_tiled_layer_t* objectgroup;     // Linked list of layers of type `objectgroup` only. Useful for holding collision info.\n\tint property_count;                  // Number of elements in the `properties` array.\n\tcute_tiled_property_t* properties;   // Array of properties.\n\t/* terrain */                        // Not currently supported.\n\tfloat probability;                   // The probability used when painting with the terrain brush in `Random Mode`.\n\tcute_tiled_tile_descriptor_t* next;  // Pointer to the next tile descriptor. NULL if final tile descriptor.\n};\n\n// IMPORTANT NOTE\n// If your tileset is not embedded you will get a warning -- to disable this warning simply define\n// this macro CUTE_TILED_NO_EXTERNAL_TILESET_WARNING.\n//\n// Here is an example.\n//\n//    #define CUTE_TILED_NO_EXTERNAL_TILESET_WARNING\n//    #define CUTE_TILED_IMPLEMENTATION\n//    #include <cute_tiled.h>\nstruct cute_tiled_tileset_t\n{\n\tuint32_t backgroundcolor;                 // Hex-formatted color (#RRGGBB or #AARRGGBB) (optional).\n\tcute_tiled_string_t class_;          // The class of the tileset (since 1.9, optional).\n\tint columns;                         // The number of tile columns in the tileset.\n\tint firstgid;                        // GID corresponding to the first tile in the set.\n\t/* grid */                           // Not currently supported.\n\tcute_tiled_string_t image;           // Image used for tiles in this set (relative path from map file to source image).\n\tint imagewidth;                      // Width of source image in pixels.\n\tint imageheight;                     // Height of source image in pixels.\n\tint margin;                          // Buffer between image edge and first tile (pixels).\n\tcute_tiled_string_t name;            // Name given to this tileset.\n\tcute_tiled_string_t objectalignment; // Alignment to use for tile objects (unspecified (default), topleft, top, topright, left, center, right, bottomleft, bottom or bottomright) (since 1.4).\n\tint property_count;                  // Number of elements in the `properties` array.\n\tcute_tiled_property_t* properties;   // Array of properties.\n\tint spacing;                         // Spacing between adjacent tiles in image (pixels).\n\t/* terrains */                       // Not currently supported.\n\tint tilecount;                       // The number of tiles in this tileset.\n\tcute_tiled_string_t tiledversion;    // The Tiled version used to save the tileset.\n\tint tileheight;                      // Maximum height of tiles in this set.\n\tint tileoffset_x;                    // Pixel offset to align tiles to the grid.\n\tint tileoffset_y;                    // Pixel offset to align tiles to the grid.\n\tcute_tiled_tile_descriptor_t* tiles; // Linked list of tile descriptors. Can be NULL.\n\tint tilewidth;                       // Maximum width of tiles in this set.\n\tuint32_t transparentcolor;           // Hex-formatted color (#AARRGGBB) (optional).\n\tcute_tiled_string_t type;            // `tileset` (for tileset files, since 1.0).\n\tcute_tiled_string_t source;          // Relative path to tileset, when saved externally from the map file.\n\tcute_tiled_tileset_t* next;          // Pointer to next tileset. NULL if final tileset.\n\tfloat version;                       // The JSON format version (like 1.2).\n\tvoid* _internal;                     // For internal use only. Don't touch.\n};\n\nstruct cute_tiled_map_t\n{\n\tuint32_t backgroundcolor;                 // Hex-formatted color (#RRGGBB or #AARRGGBB) (optional).\n\tcute_tiled_string_t class_;          // The class of the map (since 1.9, optional).\n\tint height;                          // Number of tile rows.\n\t/* hexsidelength */                  // Not currently supported.\n\tint infinite;                        // Whether the map has infinite dimensions.\n\tcute_tiled_layer_t* layers;          // Linked list of layers. Can be NULL.\n\tint nextobjectid;                    // Auto-increments for each placed object.\n\tcute_tiled_string_t orientation;     // `orthogonal`, `isometric`, `staggered` or `hexagonal`.\n\tint property_count;                  // Number of elements in the `properties` array.\n\tcute_tiled_property_t* properties;   // Array of properties.\n\tcute_tiled_string_t renderorder;     // Rendering direction (orthogonal maps only).\n\t/* staggeraxis */                    // Not currently supported.\n\t/* staggerindex */                   // Not currently supported.\n\tcute_tiled_string_t tiledversion;    // The Tiled version used to save the file.\n\tint tileheight;                      // Map grid height.\n\tcute_tiled_tileset_t* tilesets;      // Linked list of tilesets.\n\tint tilewidth;                       // Map grid width.\n\tcute_tiled_string_t type;            // `map` (since 1.0).\n\tfloat version;                       // The JSON format version (like 1.2).\n\tint width;                           // Number of tile columns.\n\tint nextlayerid;                     // The ID of the following layer.\n};\n\n#define CUTE_TILED_H\n#endif\n\n#ifdef CUTE_TILED_IMPLEMENTATION\n#ifndef CUTE_TILED_IMPLEMENTATION_ONCE\n#define CUTE_TILED_IMPLEMENTATION_ONCE\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\n\t#define _CRT_NONSTDC_NO_DEPRECATE\n#endif\n\n#if !defined(CUTE_TILED_ALLOC)\n\t#include <stdlib.h>\n\t#define CUTE_TILED_ALLOC(size, ctx) malloc(size)\n\t#define CUTE_TILED_FREE(mem, ctx) free(mem)\n#endif\n\n\n#ifndef STRPOOL_EMBEDDED_MALLOC\n\t#define STRPOOL_EMBEDDED_MALLOC(ctx, size) CUTE_TILED_ALLOC(size, ctx)\n#endif\n\n#ifndef STRPOOL_EMBEDDED_FREE\n\t#define STRPOOL_EMBEDDED_FREE(ctx, ptr) CUTE_TILED_FREE(ptr, ctx)\n#endif\n\n#define STRPOOL_EMBEDDED_IMPLEMENTATION\n\n/*\n\tbegin embedding modified strpool.h\n*/\n\n/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nstrpool.h - v1.4 - Highly efficient string pool for C/C++.\n\nDo this:\n    #define STRPOOL_EMBEDDED_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef strpool_embedded_h\n#define strpool_embedded_h\n\n#ifndef STRPOOL_EMBEDDED_U32\n    #define STRPOOL_EMBEDDED_U32 unsigned int\n#endif\n#ifndef STRPOOL_EMBEDDED_U64\n    #define STRPOOL_EMBEDDED_U64 unsigned long long\n#endif\n\ntypedef struct strpool_embedded_t strpool_embedded_t;\n\ntypedef struct strpool_embedded_config_t\n    {\n    void* memctx;\n    int ignore_case;\n    int counter_bits;\n    int index_bits;\n    int entry_capacity;\n    int block_capacity;\n    int block_size;\n    int min_length;\n    } strpool_embedded_config_t;\n\nextern strpool_embedded_config_t const strpool_embedded_default_config;\n\nvoid strpool_embedded_init( strpool_embedded_t* pool, strpool_embedded_config_t const* config );\nvoid strpool_embedded_term( strpool_embedded_t* pool );\n\nSTRPOOL_EMBEDDED_U64 strpool_embedded_inject( strpool_embedded_t* pool, char const* string, int length );\nchar const* strpool_embedded_cstr( strpool_embedded_t const* pool, STRPOOL_EMBEDDED_U64 handle );\n\n#endif /* strpool_embedded_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef strpool_embedded_impl\n#define strpool_embedded_impl\n\nstruct strpool_embedded_internal_hash_slot_t;\nstruct strpool_embedded_internal_entry_t;\nstruct strpool_embedded_internal_handle_t;\nstruct strpool_embedded_internal_block_t;\n\nstruct strpool_embedded_t\n    {\n    void* memctx;\n    int ignore_case;\n    int counter_shift;\n    STRPOOL_EMBEDDED_U64 counter_mask;\n    STRPOOL_EMBEDDED_U64 index_mask;\n\n    int initial_entry_capacity;\n    int initial_block_capacity;\n    int block_size;\n    int min_data_size;\n\n    struct strpool_embedded_internal_hash_slot_t* hash_table;\n    int hash_capacity;\n\n    struct strpool_embedded_internal_entry_t* entries;\n    int entry_capacity;\n    int entry_count;\n\n    struct strpool_embedded_internal_handle_t* handles;\n    int handle_capacity;\n    int handle_count;\n    int handle_freelist_head;\n    int handle_freelist_tail;\n\n    struct strpool_embedded_internal_block_t* blocks;\n    int block_capacity;\n    int block_count;\n    int current_block;\n    };\n\n\n#endif /* strpool_embedded_impl */\n\n\n#ifdef STRPOOL_EMBEDDED_IMPLEMENTATION\n#ifndef STRPOOL_EMBEDDED_IMPLEMENTATION_ONCE\n#define STRPOOL_EMBEDDED_IMPLEMENTATION_ONCE\n\n#include <stddef.h>\n\n#ifndef STRPOOL_EMBEDDED_ASSERT\n    #include <assert.h>\n    #define STRPOOL_EMBEDDED_ASSERT( x ) assert( x )\n#endif\n\n#ifndef STRPOOL_EMBEDDED_MEMSET\n    #include <string.h>\n    #define STRPOOL_EMBEDDED_MEMSET( ptr, val, cnt ) ( memset( ptr, val, cnt ) )\n#endif\n\n#ifndef STRPOOL_EMBEDDED_MEMCPY\n    #include <string.h>\n    #define STRPOOL_EMBEDDED_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif\n\n#ifndef STRPOOL_EMBEDDED_MEMCMP\n    #include <string.h>\n    #define STRPOOL_EMBEDDED_MEMCMP( pr1, pr2, cnt ) ( memcmp( pr1, pr2, cnt ) )\n#endif\n\n#ifndef STRPOOL_EMBEDDED_STRNICMP\n    #ifdef _WIN32\n        #include <string.h>\n        #define STRPOOL_EMBEDDED_STRNICMP( s1, s2, len ) ( _strnicmp( s1, s2, len ) )\n    #else\n        #include <string.h>\n        #include <strings.h>\n        #define STRPOOL_EMBEDDED_STRNICMP( s1, s2, len ) ( strncasecmp( s1, s2, len ) )\n    #endif\n#endif\n\n#ifndef STRPOOL_EMBEDDED_MALLOC\n    #include <stdlib.h>\n    #define STRPOOL_EMBEDDED_MALLOC( ctx, size ) ( malloc( size ) )\n    #define STRPOOL_EMBEDDED_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\ntypedef struct strpool_embedded_internal_hash_slot_t\n    {\n    STRPOOL_EMBEDDED_U32 hash_key;\n    int entry_index;\n    int base_count;\n    } strpool_embedded_internal_hash_slot_t;\n\n\ntypedef struct strpool_embedded_internal_entry_t\n    {\n    int hash_slot;\n    int handle_index;\n    char* data;\n    int size;\n    int length;\n    int refcount;\n    } strpool_embedded_internal_entry_t;\n\n\ntypedef struct strpool_embedded_internal_handle_t\n    {\n    int entry_index;\n    int counter;\n    } strpool_embedded_internal_handle_t;\n\n\ntypedef struct strpool_embedded_internal_block_t\n    {\n    int capacity;\n    char* data;\n    char* tail;\n    int free_list;\n    } strpool_embedded_internal_block_t;\n\n\ntypedef struct strpool_embedded_internal_free_block_t\n    {\n    int size;\n    int next;\n    } strpool_embedded_internal_free_block_t;\n\n\nstrpool_embedded_config_t const strpool_embedded_default_config =\n    {\n    /* memctx         = */ 0,\n    /* ignore_case    = */ 0,\n    /* counter_bits   = */ 32,\n    /* index_bits     = */ 32,\n    /* entry_capacity = */ 4096,\n    /* block_capacity = */ 32,\n    /* block_size     = */ 256 * 1024,\n    /* min_length     = */ 23,\n    };\n\n\n\nstatic STRPOOL_EMBEDDED_U32 strpool_embedded_internal_pow2ceil( STRPOOL_EMBEDDED_U32 v )\n    {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n    }\n\n\nstatic int strpool_embedded_internal_add_block( strpool_embedded_t* pool, int size )\n    {\n    if( pool->block_count >= pool->block_capacity )\n        {\n        strpool_embedded_internal_block_t* new_blocks;\n        pool->block_capacity *= 2;\n        new_blocks = (strpool_embedded_internal_block_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n            pool->block_capacity * sizeof( *pool->blocks ) );\n        STRPOOL_EMBEDDED_ASSERT( new_blocks );\n        STRPOOL_EMBEDDED_MEMCPY( new_blocks, pool->blocks, pool->block_count * sizeof( *pool->blocks ) );\n        STRPOOL_EMBEDDED_FREE( pool->memctx, pool->blocks );\n        pool->blocks = new_blocks;\n        }\n    pool->blocks[ pool->block_count ].capacity = size;\n    pool->blocks[ pool->block_count ].data = (char*) STRPOOL_EMBEDDED_MALLOC( pool->memctx, (size_t) size );\n    STRPOOL_EMBEDDED_ASSERT( pool->blocks[ pool->block_count ].data );\n    pool->blocks[ pool->block_count ].tail = pool->blocks[ pool->block_count ].data;\n    pool->blocks[ pool->block_count ].free_list = -1;\n    return pool->block_count++;\n    }\n\n\nvoid strpool_embedded_init( strpool_embedded_t* pool, strpool_embedded_config_t const* config )\n    {\n    if( !config ) config = &strpool_embedded_default_config;\n\n    pool->memctx = config->memctx;\n    pool->ignore_case = config->ignore_case;\n\n    STRPOOL_EMBEDDED_ASSERT( config->counter_bits + config->index_bits <= 64 );\n    pool->counter_shift = config->index_bits;\n    pool->counter_mask = ( 1ULL << (STRPOOL_EMBEDDED_U64) config->counter_bits ) - 1;\n    pool->index_mask = ( 1ULL << (STRPOOL_EMBEDDED_U64) config->index_bits ) - 1;\n\n    pool->initial_entry_capacity =\n        (int) strpool_embedded_internal_pow2ceil( config->entry_capacity > 1 ? (STRPOOL_EMBEDDED_U32)config->entry_capacity : 2U );\n    pool->initial_block_capacity =\n        (int) strpool_embedded_internal_pow2ceil( config->block_capacity > 1 ? (STRPOOL_EMBEDDED_U32)config->block_capacity : 2U );\n    pool->block_size =\n        (int) strpool_embedded_internal_pow2ceil( config->block_size > 256 ? (STRPOOL_EMBEDDED_U32)config->block_size : 256U );\n    pool->min_data_size =\n        (int) ( sizeof( int ) * 2 + 1 + ( config->min_length > 8 ? (STRPOOL_EMBEDDED_U32)config->min_length : 8U ) );\n\n    pool->hash_capacity = pool->initial_entry_capacity * 2;\n    pool->entry_capacity = pool->initial_entry_capacity;\n    pool->handle_capacity = pool->initial_entry_capacity;\n    pool->block_capacity = pool->initial_block_capacity;\n\n    pool->handle_freelist_head = -1;\n    pool->handle_freelist_tail = -1;\n    pool->block_count = 0;\n    pool->handle_count = 0;\n    pool->entry_count = 0;\n\n    pool->hash_table = (strpool_embedded_internal_hash_slot_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->hash_capacity * sizeof( *pool->hash_table ) );\n    STRPOOL_EMBEDDED_ASSERT( pool->hash_table );\n    STRPOOL_EMBEDDED_MEMSET( pool->hash_table, 0, pool->hash_capacity * sizeof( *pool->hash_table ) );\n    pool->entries = (strpool_embedded_internal_entry_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->entry_capacity * sizeof( *pool->entries ) );\n    STRPOOL_EMBEDDED_ASSERT( pool->entries );\n    pool->handles = (strpool_embedded_internal_handle_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->handle_capacity * sizeof( *pool->handles ) );\n    STRPOOL_EMBEDDED_ASSERT( pool->handles );\n    pool->blocks = (strpool_embedded_internal_block_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->block_capacity * sizeof( *pool->blocks ) );\n    STRPOOL_EMBEDDED_ASSERT( pool->blocks );\n\n    pool->current_block = strpool_embedded_internal_add_block( pool, pool->block_size );\n    }\n\n\nvoid strpool_embedded_term( strpool_embedded_t* pool )\n    {\n    int i;\n#if 0\n    // Debug statistics\n    printf( \"\\n\\n\" );\n    printf( \"Handles: %d/%d\\n\", pool->handle_count, pool->handle_capacity );\n    printf( \"Entries: %d/%d\\n\", pool->entry_count, pool->entry_capacity );\n    printf( \"Hashtable: %d/%d\\n\", pool->entry_count, pool->hash_capacity );\n    printf( \"Blocks: %d/%d\\n\", pool->block_count, pool->block_capacity );\n    for( int i = 0; i < pool->block_count; ++i )\n        {\n        printf( \"\\n\" );\n        printf( \"BLOCK: %d\\n\", i );\n        printf( \"Capacity: %d\\n\", pool->blocks[ i ].capacity );\n        printf( \"Free: [ %d ]\", pool->blocks[ i ].capacity - ( pool->blocks[ i ].tail - pool->blocks[ i ].data ) );\n        int fl = pool->blocks[ i ].free_list;\n        int count = 0;\n        int size = 0;\n        int total = 0;\n        while( fl >= 0 )\n            {\n            strpool_embedded_free_block_t* free_entry = (strpool_embedded_free_block_t*) ( pool->blocks[ i ].data + fl );\n            total += free_entry->size;\n            if( size == 0 ) { size = free_entry->size; }\n            if( size != free_entry->size )\n                {\n                printf( \", %dx%d\", count, size );\n                count = 1;\n                size = free_entry->size;\n                }\n            else\n                {\n                ++count;\n                }\n            fl = free_entry->next;\n            }\n        if( size != 0 ) printf( \", %dx%d\", count, size );\n        printf( \", { %d }\\n\", total );\n        }\n    printf( \"\\n\\n\" );\n#endif\n\n    for( i = 0; i < pool->block_count; ++i ) STRPOOL_EMBEDDED_FREE( pool->memctx, pool->blocks[ i ].data );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->blocks );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->handles );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->entries );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->hash_table );\n    }\n\n\nstatic STRPOOL_EMBEDDED_U64 strpool_embedded_internal_make_handle( int index, int counter, STRPOOL_EMBEDDED_U64 index_mask, int counter_shift,\n    STRPOOL_EMBEDDED_U64 counter_mask )\n    {\n    STRPOOL_EMBEDDED_U64 i = (STRPOOL_EMBEDDED_U64) ( index + 1 );\n    STRPOOL_EMBEDDED_U64 c = (STRPOOL_EMBEDDED_U64) counter;\n    return ( ( c & counter_mask ) << counter_shift ) | ( i & index_mask );\n    }\n\n\nstatic int strpool_embedded_internal_counter_from_handle( STRPOOL_EMBEDDED_U64 handle, int counter_shift, STRPOOL_EMBEDDED_U64 counter_mask  )\n    {\n    return (int) ( ( handle >> counter_shift ) & counter_mask ) ;\n    }\n\n\nstatic int strpool_embedded_internal_index_from_handle( STRPOOL_EMBEDDED_U64 handle, STRPOOL_EMBEDDED_U64 index_mask )\n    {\n    return ( (int) ( handle & index_mask ) ) - 1;\n    }\n\n\nstatic strpool_embedded_internal_entry_t* strpool_embedded_internal_get_entry( strpool_embedded_t const* pool, STRPOOL_EMBEDDED_U64 handle )\n    {\n    int index = strpool_embedded_internal_index_from_handle( handle, pool->index_mask );\n    int counter = strpool_embedded_internal_counter_from_handle( handle, pool->counter_shift, pool->counter_mask );\n\n    if( index >= 0 && index < pool->handle_count &&\n        counter == (int) ( pool->handles[ index ].counter & pool->counter_mask ) )\n            return &pool->entries[ pool->handles[ index ].entry_index ];\n\n    return 0;\n    }\n\n\nstatic STRPOOL_EMBEDDED_U32 strpool_embedded_internal_find_in_blocks( strpool_embedded_t const* pool, char const* string, int length )\n    {\n    int i;\n    for( i = 0; i < pool->block_count; ++i )\n        {\n        strpool_embedded_internal_block_t* block = &pool->blocks[ i ];\n        // Check if string comes from pool\n        if( string >= block->data + 2 * sizeof( STRPOOL_EMBEDDED_U32 ) && string < block->data + block->capacity )\n            {\n            STRPOOL_EMBEDDED_U32* ptr = (STRPOOL_EMBEDDED_U32*) string;\n            int stored_length = (int)( *( ptr - 1 ) ); // Length is stored immediately before string\n            STRPOOL_EMBEDDED_U32 hash;\n            if( stored_length != length || string[ length ] != '\\0' ) return 0; // Invalid string\n            hash = *( ptr - 2 ); // Hash is stored before the length field\n            return hash;\n            }\n        }\n\n    return 0;\n    }\n\n\nstatic STRPOOL_EMBEDDED_U32 strpool_embedded_internal_calculate_hash( char const* string, int length, int ignore_case )\n    {\n    STRPOOL_EMBEDDED_U32 hash = 5381U;\n    int i;\n\n    if( ignore_case)\n        {\n        for( i = 0; i < length; ++i )\n            {\n            char c = string[ i ];\n            c = ( c <= 'z' && c >= 'a' ) ? c - ( 'a' - 'A' ) : c;\n            hash = ( ( hash << 5U ) + hash) ^ c;\n            }\n        }\n    else\n        {\n        for( i = 0; i < length; ++i )\n            {\n            char c = string[ i ];\n            hash = ( ( hash << 5U ) + hash) ^ c;\n            }\n        }\n\n    hash = ( hash == 0 ) ? 1 : hash; // We can't allow 0-value hash keys, but dupes are ok\n    return hash;\n    }\n\n\nstatic void strpool_embedded_internal_expand_hash_table( strpool_embedded_t* pool )\n    {\n    int old_capacity = pool->hash_capacity;\n    strpool_embedded_internal_hash_slot_t* old_table = pool->hash_table;\n    int i;\n\n    pool->hash_capacity *= 2;\n\n    pool->hash_table = (strpool_embedded_internal_hash_slot_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->hash_capacity * sizeof( *pool->hash_table ) );\n    STRPOOL_EMBEDDED_ASSERT( pool->hash_table );\n    STRPOOL_EMBEDDED_MEMSET( pool->hash_table, 0, pool->hash_capacity * sizeof( *pool->hash_table ) );\n\n    for( i = 0; i < old_capacity; ++i )\n        {\n        STRPOOL_EMBEDDED_U32 hash_key = old_table[ i ].hash_key;\n        if( hash_key )\n            {\n            int base_slot = (int)( hash_key & (STRPOOL_EMBEDDED_U32)( pool->hash_capacity - 1 ) );\n            int slot = base_slot;\n            while( pool->hash_table[ slot ].hash_key )\n                slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n            STRPOOL_EMBEDDED_ASSERT( hash_key );\n            pool->hash_table[ slot ].hash_key = hash_key;\n            pool->hash_table[ slot ].entry_index = old_table[ i ].entry_index;\n            pool->entries[ pool->hash_table[ slot ].entry_index ].hash_slot = slot;\n            ++pool->hash_table[ base_slot ].base_count;\n            }\n        }\n\n    STRPOOL_EMBEDDED_FREE( pool->memctx, old_table );\n    }\n\n\nstatic void strpool_embedded_internal_expand_entries( strpool_embedded_t* pool )\n    {\n    strpool_embedded_internal_entry_t* new_entries;\n    pool->entry_capacity *= 2;\n    new_entries = (strpool_embedded_internal_entry_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->entry_capacity * sizeof( *pool->entries ) );\n    STRPOOL_EMBEDDED_ASSERT( new_entries );\n    STRPOOL_EMBEDDED_MEMCPY( new_entries, pool->entries, pool->entry_count * sizeof( *pool->entries ) );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->entries );\n    pool->entries = new_entries;\n    }\n\n\nstatic void strpool_embedded_internal_expand_handles( strpool_embedded_t* pool )\n    {\n    strpool_embedded_internal_handle_t* new_handles;\n    pool->handle_capacity *= 2;\n    new_handles = (strpool_embedded_internal_handle_t*) STRPOOL_EMBEDDED_MALLOC( pool->memctx,\n        pool->handle_capacity * sizeof( *pool->handles ) );\n    STRPOOL_EMBEDDED_ASSERT( new_handles );\n    STRPOOL_EMBEDDED_MEMCPY( new_handles, pool->handles, pool->handle_count * sizeof( *pool->handles ) );\n    STRPOOL_EMBEDDED_FREE( pool->memctx, pool->handles );\n    pool->handles = new_handles;\n    }\n\n\nstatic char* strpool_embedded_internal_get_data_storage( strpool_embedded_t* pool, int size, int* alloc_size )\n    {\n    char* data;\n    int i;\n    int offset;\n    if( size < (int)sizeof( strpool_embedded_internal_free_block_t ) ) size = sizeof( strpool_embedded_internal_free_block_t );\n    if( size < pool->min_data_size ) size = pool->min_data_size;\n    size = (int)strpool_embedded_internal_pow2ceil( (STRPOOL_EMBEDDED_U32)size );\n\n    // Try to find a large enough free slot in existing blocks\n    for( i = 0; i < pool->block_count; ++i )\n        {\n        int free_list = pool->blocks[ i ].free_list;\n        int prev_list = -1;\n        while( free_list >= 0 )\n            {\n            strpool_embedded_internal_free_block_t* free_entry =\n                (strpool_embedded_internal_free_block_t*) ( pool->blocks[ i ].data + free_list );\n            if( free_entry->size / 2 < size )\n                {\n                // At this point, all remaining slots are too small, so bail out if the current slot is not large enough\n                if( free_entry->size < size ) break;\n\n                if( prev_list < 0 )\n                    {\n                    pool->blocks[ i ].free_list = free_entry->next;\n                    }\n                else\n                    {\n                    strpool_embedded_internal_free_block_t* prev_entry =\n                        (strpool_embedded_internal_free_block_t*) ( pool->blocks[ i ].data + prev_list );\n                    prev_entry->next = free_entry->next;\n                    }\n                *alloc_size = free_entry->size;\n                return (char*) free_entry;\n                }\n            prev_list = free_list;\n            free_list = free_entry->next;\n            }\n        }\n\n    // Use current block, if enough space left\n    offset = (int) ( pool->blocks[ pool->current_block ].tail - pool->blocks[ pool->current_block ].data );\n    if( size <= pool->blocks[ pool->current_block ].capacity - offset )\n        {\n        char* data = pool->blocks[ pool->current_block ].tail;\n        pool->blocks[ pool->current_block ].tail += size;\n        *alloc_size = size;\n        return data;\n        }\n\n    // Allocate a new block\n    pool->current_block = strpool_embedded_internal_add_block( pool, size > pool->block_size ? size : pool->block_size );\n    data = pool->blocks[ pool->current_block ].tail;\n    pool->blocks[ pool->current_block ].tail += size;\n    *alloc_size = size;\n    return data;\n    }\n\n\nSTRPOOL_EMBEDDED_U64 strpool_embedded_inject( strpool_embedded_t* pool, char const* string, int length )\n    {\n    STRPOOL_EMBEDDED_U32 hash;\n    int base_slot;\n    int base_count;\n    int slot;\n    int first_free;\n    int handle_index;\n    strpool_embedded_internal_entry_t* entry;\n    int data_size;\n    char* data;\n    if( !string || length < 0 ) return 0;\n\n    hash = strpool_embedded_internal_find_in_blocks( pool, string, length );\n    // If no stored hash, calculate it from data\n    if( !hash ) hash = strpool_embedded_internal_calculate_hash( string, length, pool->ignore_case );\n\n    // Return handle to existing string, if it is already in pool\n    base_slot = (int)( hash & (STRPOOL_EMBEDDED_U32)( pool->hash_capacity - 1 ) );\n    base_count = pool->hash_table[ base_slot ].base_count;\n    slot = base_slot;\n    first_free = slot;\n    while( base_count > 0 )\n        {\n        STRPOOL_EMBEDDED_U32 slot_hash = pool->hash_table[ slot ].hash_key;\n        int slot_base;\n        if( slot_hash == 0 && pool->hash_table[ first_free ].hash_key != 0 ) first_free = slot;\n        slot_base = (int)( slot_hash & (STRPOOL_EMBEDDED_U32)( pool->hash_capacity - 1 ) );\n        if( slot_base == base_slot )\n            {\n            STRPOOL_EMBEDDED_ASSERT( base_count > 0 );\n            --base_count;\n            if( slot_hash == hash )\n                {\n                int index = pool->hash_table[ slot ].entry_index;\n                strpool_embedded_internal_entry_t* entry = &pool->entries[ index ];\n                if( entry->length == length &&\n                    (\n                       ( !pool->ignore_case &&   STRPOOL_EMBEDDED_MEMCMP( entry->data + 2 * sizeof( STRPOOL_EMBEDDED_U32 ), string, (size_t)length ) == 0 )\n                    || (  pool->ignore_case && STRPOOL_EMBEDDED_STRNICMP( entry->data + 2 * sizeof( STRPOOL_EMBEDDED_U32 ), string, (size_t)length ) == 0 )\n                    )\n                  )\n                    {\n                    int handle_index = entry->handle_index;\n                    return strpool_embedded_internal_make_handle( handle_index, pool->handles[ handle_index ].counter,\n                        pool->index_mask, pool->counter_shift, pool->counter_mask );\n                    }\n                }\n            }\n        slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n        }\n\n    // This is a new string, so let's add it\n\n    if( pool->entry_count >= ( pool->hash_capacity  - pool->hash_capacity / 3 ) )\n        {\n        strpool_embedded_internal_expand_hash_table( pool );\n\n        base_slot = (int)( hash & (STRPOOL_EMBEDDED_U32)( pool->hash_capacity - 1 ) );\n        slot = base_slot;\n        first_free = slot;\n        while( base_count )\n            {\n            STRPOOL_EMBEDDED_U32 slot_hash = pool->hash_table[ slot ].hash_key;\n            int slot_base;\n            if( slot_hash == 0 && pool->hash_table[ first_free ].hash_key != 0 ) first_free = slot;\n            slot_base = (int)( slot_hash & (STRPOOL_EMBEDDED_U32)( pool->hash_capacity - 1 ) );\n            if( slot_base == base_slot )  --base_count;\n            slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n            }\n        }\n\n    slot = first_free;\n    while( pool->hash_table[ slot ].hash_key )\n        slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n\n    if( pool->entry_count >= pool->entry_capacity )\n        strpool_embedded_internal_expand_entries( pool );\n\n    STRPOOL_EMBEDDED_ASSERT( !pool->hash_table[ slot ].hash_key && ( hash & ( (STRPOOL_EMBEDDED_U32) pool->hash_capacity - 1 ) ) == (STRPOOL_EMBEDDED_U32) base_slot );\n    STRPOOL_EMBEDDED_ASSERT( hash );\n    pool->hash_table[ slot ].hash_key = hash;\n    pool->hash_table[ slot ].entry_index = pool->entry_count;\n    ++pool->hash_table[ base_slot ].base_count;\n\n    if( pool->handle_count < pool->handle_capacity )\n        {\n        handle_index = pool->handle_count;\n        pool->handles[ pool->handle_count ].counter = 1;\n        ++pool->handle_count;\n        }\n    else if( pool->handle_freelist_head >= 0 )\n        {\n        handle_index = pool->handle_freelist_head;\n        if( pool->handle_freelist_tail == pool->handle_freelist_head )\n            pool->handle_freelist_tail = pool->handles[ pool->handle_freelist_head ].entry_index;\n        pool->handle_freelist_head = pool->handles[ pool->handle_freelist_head ].entry_index;\n        }\n    else\n        {\n        strpool_embedded_internal_expand_handles( pool );\n        handle_index = pool->handle_count;\n        pool->handles[ pool->handle_count ].counter = 1;\n        ++pool->handle_count;\n        }\n\n    pool->handles[ handle_index ].entry_index = pool->entry_count;\n\n    entry = &pool->entries[ pool->entry_count ];\n    ++pool->entry_count;\n\n    data_size = length + 1 + (int) ( 2 * sizeof( STRPOOL_EMBEDDED_U32 ) );\n    data = strpool_embedded_internal_get_data_storage( pool, data_size, &data_size );\n    entry->hash_slot = slot;\n    entry->handle_index = handle_index;\n    entry->data = data;\n    entry->size = data_size;\n    entry->length = length;\n    entry->refcount = 0;\n\n    *(STRPOOL_EMBEDDED_U32*)(data) = hash;\n    data += sizeof( STRPOOL_EMBEDDED_U32 );\n    *(STRPOOL_EMBEDDED_U32*)(data) = (STRPOOL_EMBEDDED_U32) length;\n    data += sizeof( STRPOOL_EMBEDDED_U32 );\n    STRPOOL_EMBEDDED_MEMCPY( data, string, (size_t) length );\n    data[ length ] = 0; // Ensure trailing zero\n\n    return strpool_embedded_internal_make_handle( handle_index, pool->handles[ handle_index ].counter, pool->index_mask,\n        pool->counter_shift, pool->counter_mask );\n    }\n\n\nchar const* strpool_embedded_cstr( strpool_embedded_t const* pool, STRPOOL_EMBEDDED_U64 handle )\n    {\n    strpool_embedded_internal_entry_t const* entry = strpool_embedded_internal_get_entry( pool, handle );\n    if( entry ) return entry->data + 2 * sizeof( STRPOOL_EMBEDDED_U32 ); // Skip leading hash value\n    return NULL;\n    }\n\n#endif // STRPOOL_EMBEDDED_IMPLEMENTATION_ONCE\n#endif /* STRPOOL_EMBEDDED_IMPLEMENTATION */\n\n\n/*\nrevision history:\n    1.4     fixed find_in_blocks substring bug, removed realloc, added docs\n    1.3     fixed typo in mask bit shift\n    1.2     made it possible to override standard library functions\n    1.1     added is_valid function to query a handles validity\n    1.0     first released version\n*/\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n\n/*\n\tend embedding strpool.h\n*/\n\n#if !defined(CUTE_TILED_WARNING)\n\t#define CUTE_TILED_DEFAULT_WARNING\n\t#define CUTE_TILED_WARNING(msg) cute_tiled_warning(msg, __LINE__)\n#endif\n\n#if !defined(CUTE_TILED_MEMCPY)\n\t#include <string.h> // memcpy\n\t#define CUTE_TILED_MEMCPY memcpy\n#endif\n\n#if !defined(CUTE_TILED_MEMSET)\n\t#include <string.h> // memset\n\t#define CUTE_TILED_MEMSET memset\n#endif\n\n#if !defined(CUTE_TILED_UNUSED)\n\t#if defined(_MSC_VER)\n\t\t#define CUTE_TILED_UNUSED(x) (void)x\n\t#else\n\t\t#define CUTE_TILED_UNUSED(x) (void)(sizeof(x))\n\t#endif\n#endif\n\n#if !defined(CUTE_TILED_SNPRINTF)\n\t#include <stdio.h> // snprintf\n\t#define CUTE_TILED_SNPRINTF snprintf\n#endif\n\n#if !defined(CUTE_TILED_SEEK_SET)\n\t#include <stdio.h> // SEEK_SET\n\t#define CUTE_TILED_SEEK_SET SEEK_SET\n#endif\n\n#if !defined(CUTE_TILED_SEEK_END)\n\t#include <stdio.h> // SEEK_END\n\t#define CUTE_TILED_SEEK_END SEEK_END\n#endif\n\n#if !defined(CUTE_TILED_FILE)\n\t#include <stdio.h> // FILE\n\t#define CUTE_TILED_FILE FILE\n#endif\n\n#if !defined(CUTE_TILED_FOPEN)\n\t#include <stdio.h> // fopen\n\t#define CUTE_TILED_FOPEN fopen\n#endif\n\n#if !defined(CUTE_TILED_FSEEK)\n\t#include <stdio.h> // fseek\n\t#define CUTE_TILED_FSEEK fseek\n#endif\n\n#if !defined(CUTE_TILED_FREAD)\n\t#include <stdio.h> // fread\n\t#define CUTE_TILED_FREAD fread\n#endif\n\n#if !defined(CUTE_TILED_FTELL)\n\t#include <stdio.h> // ftell\n\t#define CUTE_TILED_FTELL ftell\n#endif\n\n#if !defined(CUTE_TILED_FCLOSE)\n\t#include <stdio.h> // fclose\n\t#define CUTE_TILED_FCLOSE fclose\n#endif\n\nint cute_tiled_error_cline; \t\t\t// The line in cute_tiled.h where the error was triggered.\nconst char* cute_tiled_error_reason; \t\t// The error message.\nint cute_tiled_error_line;  \t\t\t// The line where the error happened in the json.\nconst char* cute_tiled_error_file = NULL; \t// The filepath of the file being parsed. NULL if from memory.\n\n#ifdef CUTE_TILED_DEFAULT_WARNING\n\t#include <stdio.h>\n\n\tvoid cute_tiled_warning(const char* warning, int line)\n\t{\n\t\tconst char *error_file = cute_tiled_error_file ? cute_tiled_error_file : \"MEMORY\";\n\t\tcute_tiled_error_cline = line;\n\t\tprintf(\"WARNING (cute_tiled.h:%i): %s (%s:%i)\\n\", cute_tiled_error_cline, warning, error_file, cute_tiled_error_line);\n\t}\n#endif\n\n#include <stdlib.h>\n\n#if !defined(CUTE_TILED_STRTOLL)\n\t#define CUTE_TILED_STRTOLL strtoll\n#endif\n\n#if !defined(CUTE_TILED_STRTOULL)\n\t#define CUTE_TILED_STRTOULL strtoull\n#endif\n\n#if !defined(CUTE_TILED_STRTOD)\n\t#define CUTE_TILED_STRTOD strtod\n#endif\n\ntypedef struct cute_tiled_page_t cute_tiled_page_t;\ntypedef struct cute_tiled_map_internal_t cute_tiled_map_internal_t;\n\nstruct cute_tiled_page_t\n{\n\tcute_tiled_page_t* next;\n\tvoid* data;\n};\n\n#define CUTE_TILED_INTERNAL_BUFFER_MAX 1024\n\nstruct cute_tiled_map_internal_t\n{\n\tchar* in;\n\tchar* end;\n\tcute_tiled_map_t map;\n\tstrpool_embedded_t strpool;\n\tvoid* mem_ctx;\n\tint page_size;\n\tint bytes_left_on_page;\n\tcute_tiled_page_t* pages;\n\tint scratch_len;\n\tchar scratch[CUTE_TILED_INTERNAL_BUFFER_MAX];\n};\n\nvoid* cute_tiled_alloc(cute_tiled_map_internal_t* m, int size)\n{\n\tvoid* data;\n\tif (size > m->page_size) return NULL; // Should never happen.\n\tif (m->bytes_left_on_page < size)\n\t{\n\t\tcute_tiled_page_t* page = (cute_tiled_page_t*)CUTE_TILED_ALLOC(sizeof(cute_tiled_page_t) + m->page_size, m->mem_ctx);\n\t\tif (!page) return 0;\n\t\tpage->next = m->pages;\n\t\tpage->data = page + 1;\n\t\tm->pages = page;\n\t\tm->bytes_left_on_page = m->page_size;\n\t}\n\n\tdata = ((char*)m->pages->data) + (m->page_size - m->bytes_left_on_page);\n\tm->bytes_left_on_page -= size;\n\treturn data;\n}\n\nCUTE_TILED_U64 cute_tiled_FNV1a(const void* buf, int len)\n{\n\tCUTE_TILED_U64 h = (CUTE_TILED_U64)14695981039346656037U;\n\tconst char* str = (const char*)buf;\n\n\twhile (len--)\n\t{\n\t\tchar c = *str++;\n\t\th = h ^ (CUTE_TILED_U64)c;\n\t\th = h * (CUTE_TILED_U64)1099511628211;\n\t}\n\n\treturn h;\n}\n\nstatic char* cute_tiled_read_file_to_memory_and_null_terminate(const char* path, int* size, void* mem_ctx)\n{\n\tchar* data = 0;\n\tCUTE_TILED_FILE* fp = CUTE_TILED_FOPEN(path, \"rb\");\n\tint sz = 0;\n\tCUTE_TILED_UNUSED(mem_ctx);\n\n\tif (fp)\n\t{\n\t\tCUTE_TILED_FSEEK(fp, 0, CUTE_TILED_SEEK_END);\n\t\tsz = CUTE_TILED_FTELL(fp);\n\t\tCUTE_TILED_FSEEK(fp, 0, CUTE_TILED_SEEK_SET);\n\t\tdata = (char*)CUTE_TILED_ALLOC(sz + 1, mem_ctx);\n\t\tCUTE_TILED_FREAD(data, sz, 1, fp);\n\t\tdata[sz] = 0;\n\t\tCUTE_TILED_FCLOSE(fp);\n\t}\n\n\tif (size) *size = sz;\n\treturn data;\n}\n\ncute_tiled_map_t* cute_tiled_load_map_from_file(const char* path, void* mem_ctx)\n{\n\tint size;\n\tvoid* file;\n\tcute_tiled_map_t* map;\n\tcute_tiled_error_file = path;\n\n\tfile = cute_tiled_read_file_to_memory_and_null_terminate(path, &size, mem_ctx);\n\tif (!file) CUTE_TILED_WARNING(\"Unable to find map file.\");\n\tmap = cute_tiled_load_map_from_memory(file, size, mem_ctx);\n\tCUTE_TILED_FREE(file, mem_ctx);\n\n\tcute_tiled_error_file = NULL;\n\n\treturn map;\n}\n\n#define CUTE_TILED_CHECK(X, Y) do { if (!(X)) { cute_tiled_error_reason = Y; cute_tiled_error_cline = __LINE__; goto cute_tiled_err; } } while (0)\n#define CUTE_TILED_FAIL_IF(X) do { if (X) { goto cute_tiled_err; } } while (0)\n\nstatic int cute_tiled_isspace(char c)\n{\n\tcute_tiled_error_line += c == '\\n';\n\n\treturn (c == ' ') |\n\t\t(c == '\\t') |\n\t\t(c == '\\n') |\n\t\t(c == '\\v') |\n\t\t(c == '\\f') |\n\t\t(c == '\\r');\n}\n\nstatic char cute_tiled_peak(cute_tiled_map_internal_t* m)\n{\n\twhile (cute_tiled_isspace(*m->in)) m->in++;\n\treturn *m->in;\n}\n\n#ifdef __clang__\n    #define CUTE_TILED_CRASH() __builtin_trap()\n#else\n    #define CUTE_TILED_CRASH() *(int*)0 = 0\n#endif\n\nstatic char cute_tiled_next(cute_tiled_map_internal_t* m)\n{\n\tchar c;\n\tif (m->in == m->end) CUTE_TILED_CRASH();\n\twhile (cute_tiled_isspace(c = *m->in++));\n\treturn c;\n}\n\nstatic char cute_tiled_string_next(cute_tiled_map_internal_t* m)\n{\n\tchar c;\n\tif (m->in == m->end) CUTE_TILED_CRASH();\n\tc = *m->in++;\n\treturn c;\n}\n\nstatic int cute_tiled_try(cute_tiled_map_internal_t* m, char expect)\n{\n\tif (m->in == m->end) CUTE_TILED_CRASH();\n\tif (cute_tiled_peak(m) == expect)\n\t{\n\t\tm->in++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define cute_tiled_expect(m, expect) \\\n\tdo { \\\n\t\tstatic char error[128]; \\\n\t\tCUTE_TILED_SNPRINTF(error, sizeof(error), \"Found unexpected token '%c', expected '%c' (is this a valid JSON file?).\", *m->in, expect); \\\n\t\tCUTE_TILED_CHECK(cute_tiled_next(m) == (expect), error); \\\n\t} while (0)\n\nchar cute_tiled_parse_char(char c)\n{\n\tswitch (c)\n\t{\n\t\tcase '\\\\': return '\\\\';\n\t\tcase '\\'': return '\\'';\n\t\tcase '\"': return '\"';\n\t\tcase 't': return '\\t';\n\t\tcase 'f': return '\\f';\n\t\tcase 'n': return '\\n';\n\t\tcase 'r': return '\\r';\n\t\tcase '0': return '\\0';\n\t\tdefault: return c;\n\t}\n}\n\nstatic int cute_tiled_skip_object_internal(cute_tiled_map_internal_t* m)\n{\n\tint depth = 1;\n\tcute_tiled_expect(m, '{');\n\n\twhile (depth) {\n\t\tchar c;\n\t\tCUTE_TILED_CHECK(m->in <= m->end, \"Attempted to read passed input buffer (is this a valid JSON file?).\");\n\n\t\tc = cute_tiled_next(m);\n\n\t\tswitch(c)\n\t\t{\n\t\tcase '{':\n\t\t\tdepth += 1;\n\t\t\tbreak;\n\n\t\tcase '}':\n\t\t\tdepth -= 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_skip_object(m) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_skip_object_internal(m)); \\\n\t} while (0)\n\nstatic int cute_tiled_skip_array_internal(cute_tiled_map_internal_t* m)\n{\n\tint depth = 1;\n\tcute_tiled_expect(m, '[');\n\n\twhile (depth)\n\t{\n\t\tchar c;\n\t\tCUTE_TILED_CHECK(m->in <= m->end, \"Attempted to read passed input buffer (is this a valid JSON file?).\");\n\n\t\tc = cute_tiled_next(m);\n\n\t\tswitch(c)\n\t\t{\n\t\tcase '[':\n\t\t\tdepth += 1;\n\t\t\tbreak;\n\n\t\tcase ']':\n\t\t\tdepth -= 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_skip_array(m) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_skip_array_internal(m)); \\\n\t} while (0)\n\nstatic int cute_tiled_read_string_internal(cute_tiled_map_internal_t* m)\n{\n\tint count = 0;\n\tint done = 0;\n\tcute_tiled_expect(m, '\"');\n\n\twhile (!done)\n\t{\n\t\tchar c;\n\t\tCUTE_TILED_CHECK(count < CUTE_TILED_INTERNAL_BUFFER_MAX, \"String exceeded max length of CUTE_TILED_INTERNAL_BUFFER_MAX.\");\n\t\tc = cute_tiled_string_next(m);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase '\"':\n\t\t\tm->scratch[count] = 0;\n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tcase '\\\\':\n\t\t{\n\t\t\tchar the_char = cute_tiled_parse_char(cute_tiled_string_next(m));\n\t\t\tm->scratch[count++] = the_char;\n\t\t}\tbreak;\n\n\t\tdefault:\n\t\t\tm->scratch[count++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tm->scratch_len = count;\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_string(m) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_string_internal(m)); \\\n\t} while (0)\n\nstatic int cute_tiled_read_int_internal(cute_tiled_map_internal_t* m, int* out)\n{\n\tchar* end;\n\tint val = (int)CUTE_TILED_STRTOLL(m->in, &end, 10);\n\tif (*end == '.') CUTE_TILED_STRTOD(m->in, &end); // If we're reading a float as an int, then just skip the decimal part.\n\tCUTE_TILED_CHECK(m->in != end, \"Invalid integer found during parse.\");\n\tm->in = end;\n\t*out = val;\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_int(m, num) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_int_internal(m, num)); \\\n\t} while (0)\n\nstatic uint32_t cute_tiled_read_hex_int_internal(cute_tiled_map_internal_t* m, uint32_t* out)\n{\n\tchar* end;\n\tunsigned long long int val;\n\tint val_length = 0;\n\tswitch (cute_tiled_peak(m))\n\t{\n\tcase '#':\n\t\tcute_tiled_next(m);\n\t\tbreak;\n\n\tcase '0':\n\t{\n\t\tchar c;\n\t\tcute_tiled_next(m);\n\t\tc = cute_tiled_next(m);\n\t\tCUTE_TILED_CHECK((c == 'x') | (c == 'X'), \"Expected 'x' or 'X' while parsing a hex number.\");\n\t}\tbreak;\n\t}\n\n\tval = CUTE_TILED_STRTOULL(m->in, &end, 16);\n\tCUTE_TILED_CHECK(m->in != end, \"Invalid integer found during parse.\");\n\n\t// Count the length of the value to determine if we need to force AARRGGBB, instead of RRGGBB.\n\twhile (m->in != end) {\n\t\tm->in++;\n\t\tval_length++;\n\t}\n\t*out = (uint32_t)val;\n\n\t// When less than 6 characters, force an alpha channel of 255.\n\tif (val_length <= 6) {\n\t\tuint32_t alpha = 0xFF << 24;\n\t\t*out = (*out & 0x00FFFFFF) | alpha;\n\t}\n\n\tm->in = end;\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_hex_int(m, num) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_hex_int_internal(m, num)); \\\n\t} while (0)\n\nstatic int cute_tiled_read_float_internal(cute_tiled_map_internal_t* m, float* out)\n{\n\tchar* end;\n\tfloat val = (float)strtod(m->in, &end);\n\tCUTE_TILED_CHECK(m->in != end, \"Invalid integer found during parse.\");\n\tm->in = end;\n\t*out = val;\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_float(m, num) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_float_internal(m, num)); \\\n\t} while (0)\n\nstatic int cute_tiled_read_bool_internal(cute_tiled_map_internal_t* m, int* out)\n{\n\tif ((cute_tiled_peak(m) == 't') | (cute_tiled_peak(m) == 'T'))\n\t{\n\t\tm->in += 4;\n\t\t*out = 1;\n\t}\n\n\telse if ((cute_tiled_peak(m) == 'f') | (cute_tiled_peak(m) == 'F'))\n\t{\n\t\tm->in += 5;\n\t\t*out = 0;\n\t}\n\n\telse goto cute_tiled_err;\n\n\tCUTE_TILED_CHECK(m->in <= m->end, \"Attempted to read passed input buffer (is this a valid JSON file?).\");\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_bool(m, b) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_bool_internal(m, b)); \\\n\t} while (0)\n\nint cute_tiled_read_csv_integers_internal(cute_tiled_map_internal_t* m, int* count_out, int** out)\n{\n\tint count = 0;\n\tint capacity = 1024;\n\tint* integers = (int*)CUTE_TILED_ALLOC(capacity * sizeof(int), m->mem_ctx);\n\n\tchar c;\n\tdo\n\t{\n\t\tint val;\n\t\tcute_tiled_read_int(m, &val);\n\t\tif (count == capacity)\n\t\t{\n\t\t\tint* new_integers;\n\t\t\tcapacity *= 2;\n\t\t\tnew_integers = (int*)CUTE_TILED_ALLOC(capacity * sizeof(int), m->mem_ctx);\n\t\t\tCUTE_TILED_MEMCPY(new_integers, integers, sizeof(int) * count);\n\t\t\tCUTE_TILED_FREE(integers, m->mem_ctx);\n\t\t\tintegers = new_integers;\n\t\t}\n\t\tintegers[count++] = val;\n\t\tc = cute_tiled_next(m);\n\t}\n\twhile (c != ']');\n\n\t*count_out = count;\n\t*out = integers;\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_csv_integers(m, count_out, out) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_csv_integers_internal(m, count_out, out)); \\\n\t} while (0)\n\nint cute_tiled_intern_string_internal(cute_tiled_map_internal_t* m, cute_tiled_string_t* out)\n{\n\tSTRPOOL_EMBEDDED_U64 id;\n\tcute_tiled_read_string(m);\n\n\t// Store string id inside the memory of the pointer. This is important since\n\t// the string pool can relocate strings while parsing the map file at any\n\t// time.\n\n\t// Later there will be a second pass to patch all these string\n\t// pointers by doing: *out = (const char*)strpool_embedded_cstr(&m->strpool, id);\n\n\tid = strpool_embedded_inject(&m->strpool, m->scratch, m->scratch_len);\n\t// if (sizeof(const char*) < sizeof(STRPOOL_EMBEDDED_U64)) *(int*)0 = 0; // sanity check\n\tout->hash_id = id;\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_intern_string(m, out) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_intern_string_internal(m, out)); \\\n\t} while (0)\n\nint cute_tiled_read_vertex_array_internal(cute_tiled_map_internal_t* m, int* out_count, float** out_verts)\n{\n\tint vert_count = 0;\n\tint capacity = 32;\n\tfloat *verts;\n\tcute_tiled_expect(m, '[');\n\n\tverts = (float*)CUTE_TILED_ALLOC(sizeof(float) * capacity * 2, m->mem_ctx);\n\n\twhile (cute_tiled_peak(m) != ']')\n\t{\n\t\tint swap;\n\t\tfloat x = 0, y = 0;\n\t\tcute_tiled_expect(m, '{');\n\t\tcute_tiled_expect(m, '\"');\n\n\t\tswap = cute_tiled_try(m, 'x') ? 0 : 1;\n\n\t\tcute_tiled_expect(m, '\"');\n\t\tcute_tiled_expect(m, ':');\n\t\tcute_tiled_read_float(m, swap ? &y : &x);\n\t\tcute_tiled_expect(m, ',');\n\t\tcute_tiled_expect(m, '\"');\n\t\tcute_tiled_expect(m, swap ? 'x' : 'y');\n\t\tcute_tiled_expect(m, '\"');\n\t\tcute_tiled_expect(m, ':');\n\t\tcute_tiled_read_float(m, swap ? &x : &y);\n\t\tcute_tiled_expect(m, '}');\n\t\tcute_tiled_try(m, ',');\n\n\t\tif (vert_count == capacity)\n\t\t{\n\t\t\tfloat* new_verts;\n\t\t\tcapacity *= 2;\n\t\t\tnew_verts = (float*)CUTE_TILED_ALLOC(sizeof(float) * capacity * 2, m->mem_ctx);\n\t\t\tCUTE_TILED_MEMCPY(new_verts, verts, sizeof(float) * 2 * vert_count);\n\t\t\tCUTE_TILED_FREE(verts, m->mem_ctx);\n\t\t\tverts = new_verts;\n\t\t}\n\n\t\tverts[vert_count * 2] = x;\n\t\tverts[vert_count * 2 + 1] = y;\n\t\t++vert_count;\n\t}\n\n\tcute_tiled_expect(m, ']');\n\t*out_count = vert_count;\n\t*out_verts = verts;\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_vertex_array(m, out_count, out_verts) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_vertex_array_internal(m, out_count, out_verts)); \\\n\t} while (0)\n\nint cute_tiled_skip_until_after_internal(cute_tiled_map_internal_t* m, char c)\n{\n\twhile (*m->in != c) {\n\t\tcute_tiled_error_line += *m->in == '\\n';\n\t\tm->in++;\n\t}\n\tcute_tiled_expect(m, c);\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_skip_until_after(m, c) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_skip_until_after_internal(m, c)); \\\n\t} while (0)\n\nint cute_tiled_read_properties_internal(cute_tiled_map_internal_t* m, cute_tiled_property_t** out_properties, int* out_count)\n{\n\tint count = 0;\n\tint capacity = 32;\n\tcute_tiled_property_t* props = (cute_tiled_property_t*)CUTE_TILED_ALLOC(capacity * sizeof(cute_tiled_property_t), m->mem_ctx);\n\n\tcute_tiled_expect(m, '[');\n\n\twhile (cute_tiled_peak(m) != ']')\n\t{\n\t\tcute_tiled_property_t prop;\n\t\tchar type_char;\n\t\tchar c;\n\t\tcute_tiled_expect(m, '{');\n\n\t\tprop.type = CUTE_TILED_PROPERTY_NONE;\n\n\t\t// Read in the property name.\n\t\tcute_tiled_skip_until_after(m, ':');\n\t\tcute_tiled_intern_string(m, &prop.name);\n\n\t\t// Read in the property type. The value type is deduced while parsing, this is only used for float because the JSON format omits decimals on round floats.\n\t\tcute_tiled_skip_until_after(m, ':');\n\t\tcute_tiled_expect(m, '\"');\n\t\ttype_char = cute_tiled_next(m);\n\n\t\t// Skip extraneous JSON information and go find the actual value data.\n\t\tcute_tiled_skip_until_after(m, ':');\n\n\t\tc = cute_tiled_peak(m);\n\n\t\tif (((c == 't') | (c == 'T')) | ((c == 'f') | (c == 'F')))\n\t\t{\n\t\t\tcute_tiled_read_bool(m, &prop.data.boolean);\n\t\t\tprop.type = CUTE_TILED_PROPERTY_BOOL;\n\t\t}\n\n\t\telse if (c == '\"')\n\t\t{\n\t\t\tchar* s = m->in + 1;\n\t\t\tint is_hex_color = 1;\n\n\t\t\tif (*s++ != '#') is_hex_color = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile ((c = *s++) != '\"')\n\t\t\t\t{\n\t\t\t\t\tswitch (c)\n\t\t\t\t\t{\n\t\t\t\t\tcase '0': case '1': case '2': case '3': case '4': case '5': case '6':\n\t\t\t\t\tcase '7': case '8': case '9': case 'a': case 'b': case 'c': case 'd':\n\t\t\t\t\tcase 'e': case 'f': case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tis_hex_color = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!is_hex_color) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_hex_color)\n\t\t\t{\n\t\t\t\tcute_tiled_expect(m, '\"');\n\t\t\t\tcute_tiled_read_hex_int(m, &prop.data.color);\n\t\t\t\tcute_tiled_expect(m, '\"');\n\t\t\t\tprop.type = CUTE_TILED_PROPERTY_COLOR;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tcute_tiled_intern_string(m, &prop.data.string);\n\t\t\t\tprop.type = CUTE_TILED_PROPERTY_STRING;\n\t\t\t}\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tchar* s = m->in;\n\t\t\tint is_float = 0;\n\t\t\twhile ((c = *s++) != ',')\n\t\t\t{\n\t\t\t\tif (c == '.')\n\t\t\t\t{\n\t\t\t\t\tis_float = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_float || type_char == 'f')\n\t\t\t{\n\t\t\t\tcute_tiled_read_float(m, &prop.data.floating);\n\t\t\t\tprop.type = CUTE_TILED_PROPERTY_FLOAT;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tcute_tiled_read_int(m, &prop.data.integer);\n\t\t\t\tprop.type = CUTE_TILED_PROPERTY_INT;\n\t\t\t}\n\t\t}\n\n\t\tif (count == capacity)\n\t\t{\n\t\t\tcute_tiled_property_t* new_props;\n\t\t\tcapacity *= 2;\n\t\t\tnew_props = (cute_tiled_property_t*)CUTE_TILED_ALLOC(capacity * sizeof(cute_tiled_property_t), m->mem_ctx);\n\t\t\tCUTE_TILED_MEMCPY(new_props, props, sizeof(cute_tiled_property_t) * count);\n\t\t\tCUTE_TILED_FREE(props, m->mem_ctx);\n\t\t\tprops = new_props;\n\t\t}\n\t\tprops[count++] = prop;\n\n\t\tcute_tiled_expect(m, '}');\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, ']');\n\tcute_tiled_try(m, ',');\n\n\t*out_properties = count ? props : NULL;\n        if (!count) CUTE_TILED_FREE(props, m->mem_ctx);\n\t*out_count = count;\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_properties(m, out_properties, out_count) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_properties_internal(m, out_properties, out_count)); \\\n\t} while (0)\n\ncute_tiled_object_t* cute_tiled_read_object(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_object_t* object = (cute_tiled_object_t*)cute_tiled_alloc(m, sizeof(cute_tiled_object_t));\n\tCUTE_TILED_MEMSET(object, 0, sizeof(cute_tiled_object_t));\n\tcute_tiled_expect(m, '{');\n\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tCUTE_TILED_U64 h;\n\t\tcute_tiled_read_string(m);\n\t\tcute_tiled_expect(m, ':');\n\t\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\t\tswitch (h)\n\t\t{\n\t\tcase 14479365350473253539U: // ellipse\n\t\t\tcute_tiled_read_bool(m, &object->ellipse);\n\t\t\tbreak;\n\n\t\tcase 14992147199312073281U: // gid\n\t\t\tcute_tiled_read_int(m, &object->gid);\n\t\t\tbreak;\n\n\t\tcase 809651598226485190U: // height\n\t\t\tcute_tiled_read_float(m, &object->height);\n\t\t\tbreak;\n\n\t\tcase 3133932603199444032U: // id\n\t\t\tcute_tiled_read_int(m, &object->id);\n\t\t\tbreak;\n\n\t\tcase 12661511911333414066U: // name\n\t\t\tcute_tiled_intern_string(m, &object->name);\n\t\t\tbreak;\n\n\t\tcase 15925463322410838979U: // point\n\t\t\tcute_tiled_read_bool(m, &object->point);\n\t\t\tbreak;\n\n\t\tcase 11191351929714760271U: // polyline\n\t\t\tcute_tiled_read_vertex_array(m, &object->vert_count, &object->vertices);\n\t\t\tobject->vert_type = 0;\n\t\t\tbreak;\n\n\t\tcase 6623316362411997547U: // polygon\n\t\t\tcute_tiled_read_vertex_array(m, &object->vert_count, &object->vertices);\n\t\t\tobject->vert_type = 1;\n\t\t\tbreak;\n\n\t\tcase 8368542207491637236U: // properties\n\t\t\tcute_tiled_read_properties(m, &object->properties, &object->property_count);\n\t\t\tbreak;\n\n\t\tcase 17386473859969670701U: // rotation\n\t\t\tcute_tiled_read_float(m, &object->rotation);\n\t\t\tbreak;\n\n\t\tcase 7758770083360183834U: // text\n\t\t\tCUTE_TILED_WARNING(\"Text field of Tiled objects is not yet supported. Ignoring field.\");\n\t\t\twhile (cute_tiled_peak(m) != ',' && cute_tiled_peak(m) != '}') cute_tiled_next(m);\n\t\t\tif (cute_tiled_peak(m) == '}')\tcontinue;\n\t\t\tbreak;\n\n\t\tcase 13509284784451838071U: // type\n\t\t\tcute_tiled_intern_string(m, &object->type);\n\t\t\tbreak;\n\n\t\tcase 128234417907068947U: // visible\n\t\t\tcute_tiled_read_bool(m, &object->visible);\n\t\t\tbreak;\n\n\t\tcase 7400839267610537869U: // width\n\t\t\tcute_tiled_read_float(m, &object->width);\n\t\t\tbreak;\n\n\t\tcase 644252274336276709U: // x\n\t\t\tcute_tiled_read_float(m, &object->x);\n\t\t\tbreak;\n\n\t\tcase 643295699219922364U: // y\n\t\t\tcute_tiled_read_float(m, &object->y);\n\t\t\tbreak;\n\n\t\tcase 1485919047363370797U: // class\n\t\t\t// This is technically different than type, but it used the same way in newer versions of Tiled\n\t\t\tcute_tiled_intern_string(m, &object->type);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t\t}\n\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, '}');\n\treturn object;\n\ncute_tiled_err:\n\treturn 0;\n}\n\ncute_tiled_layer_t* cute_tiled_layers(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_layer_t* layer = (cute_tiled_layer_t*)cute_tiled_alloc(m, sizeof(cute_tiled_layer_t));\n\tCUTE_TILED_MEMSET(layer, 0, sizeof(cute_tiled_layer_t));\n\tlayer->parallaxx = 1.0f;\n\tlayer->parallaxy = 1.0f;\n\tlayer->repeatx = 0;\n\tlayer->repeaty = 0;\n\n\tcute_tiled_expect(m, '{');\n\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tCUTE_TILED_U64 h;\n\t\tcute_tiled_read_string(m);\n\t\tcute_tiled_expect(m, ':');\n\t\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\t\tswitch (h)\n\t\t{\n\t\tcase 1485919047363370797U: // class\n\t\t\tcute_tiled_intern_string(m, &layer->class_);\n\t\t\tbreak;\n\n\t\tcase 14868627273436340303U: // compression\n\t\t\tCUTE_TILED_CHECK(0, \"Compression is not yet supported. The expected tile format is CSV (uncompressed). Please see the docs if you are interested in compression.\");\n\t\t\tbreak;\n\n\t\tcase 4430454992770877055U: // data\n\t\t\tCUTE_TILED_CHECK(cute_tiled_peak(m) == '[', \"The expected tile format is CSV (uncompressed). It looks like Base64 (uncompressed) was selected. Please see the docs if you are interested in compression.\");\n\t\t\tcute_tiled_expect(m, '[');\n\t\t\tcute_tiled_read_csv_integers(m, &layer->data_count, &layer->data);\n\t\t\tbreak;\n\n\t\tcase 1888774307506158416U: // encoding\n\t\t\tCUTE_TILED_CHECK(0, \"Encoding is not yet supported. The expected tile format is CSV (uncompressed). Please see the docs if you are interested in compression.\");\n\t\t\tbreak;\n\n\t\tcase 2841939415665718447U: // draworder\n\t\t\tcute_tiled_intern_string(m, &layer->draworder);\n\t\t\tbreak;\n\n\t\tcase 809651598226485190U: // height\n\t\t\tcute_tiled_read_int(m, &layer->height);\n\t\t\tbreak;\n\n\t\tcase 13522647194774232494U: // image\n\t\t\tcute_tiled_intern_string(m, &layer->image);\n\t\t\tbreak;\n\n\t\tcase 4566956252693479661U: // layers\n\t\tcute_tiled_expect(m, '[');\n\n\t\twhile (cute_tiled_peak(m) != ']')\n\t\t{\n\t\t\tcute_tiled_layer_t* child_layer = cute_tiled_layers(m);\n\t\t\tCUTE_TILED_FAIL_IF(!child_layer);\n\t\t\tchild_layer->next = layer->layers;\n\t\t\tlayer->layers = child_layer;\n\t\t\tcute_tiled_try(m, ',');\n\t\t}\n\n\t\tcute_tiled_expect(m, ']');\n\t\tbreak;\n\n\t\tcase 12661511911333414066U: // name\n\t\t\tcute_tiled_intern_string(m, &layer->name);\n\t\t\tbreak;\n\n\t\tcase 107323337999513585U: // objects\n\t\t\tcute_tiled_expect(m, '[');\n\n\t\t\twhile (cute_tiled_peak(m) != ']')\n\t\t\t{\n\t\t\t\tcute_tiled_object_t* object = cute_tiled_read_object(m);\n\t\t\t\tCUTE_TILED_FAIL_IF(!object);\n\t\t\t\tobject->next = layer->objects;\n\t\t\t\tlayer->objects = object;\n\t\t\t\tcute_tiled_try(m, ',');\n\t\t\t}\n\n\t\t\tcute_tiled_expect(m, ']');\n\t\t\tbreak;\n\n\t\tcase 5195853646368960386U: // offsetx\n\t\t\tcute_tiled_read_float(m, &layer->offsetx);\n\t\t\tbreak;\n\n\t\tcase 5196810221485314731U: // offsety\n\t\t\tcute_tiled_read_float(m, &layer->offsety);\n\t\t\tbreak;\n\n\t\tcase 11746902372727406098U: // opacity\n\t\t\tcute_tiled_read_float(m, &layer->opacity);\n\t\t\tbreak;\n\n\t\tcase 8368542207491637236U: // properties\n\t\t\tcute_tiled_read_properties(m, &layer->properties, &layer->property_count);\n\t\t\tbreak;\n\n\t\tcase 8489814081865549564U: // transparentcolor\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tcute_tiled_read_hex_int(m, &layer->transparentcolor);\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tbreak;\n\n\t\tcase 1211175872446544425U: // tintcolor\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tcute_tiled_read_hex_int(m, &layer->tintcolor);\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tbreak;\n\n\t\tcase 13509284784451838071U: // type\n\t\t\tcute_tiled_intern_string(m, &layer->type);\n\t\t\tbreak;\n\n\t\tcase 128234417907068947U: // visible\n\t\t\tcute_tiled_read_bool(m, &layer->visible);\n\t\t\tbreak;\n\n\t\tcase 7400839267610537869U: // width\n\t\t\tcute_tiled_read_int(m, &layer->width);\n\t\t\tbreak;\n\n\t\tcase 644252274336276709U: // x\n\t\t\tcute_tiled_read_int(m, &layer->x);\n\t\t\tbreak;\n\n\t\tcase 643295699219922364U: // y\n\t\t\tcute_tiled_read_int(m, &layer->y);\n\t\t\tbreak;\n\n\t\tcase 18212633776084966362U: // parallaxx\n\t\t\tcute_tiled_read_float(m, &layer->parallaxx);\n\t\t\tbreak;\n\n\t\tcase 18213590351201320707U: // parallaxy\n\t\t\tcute_tiled_read_float(m, &layer->parallaxy);\n\t\t\tbreak;\n\n\t\tcase 222650047040294978U: // repeatx\n\t\t\tcute_tiled_read_bool(m, &layer->repeatx);\n\t\t\tbreak;\n\n\t\tcase 223606622156649323U: // repeaty\n\t\t\tcute_tiled_read_bool(m, &layer->repeaty);\n\t\t\tbreak;\n\n\t\tcase 3133932603199444032U: // id\n\t\t\tcute_tiled_read_int(m, &layer->id);\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t\t}\n\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, '}');\n\treturn layer;\n\ncute_tiled_err:\n\treturn 0;\n}\n\nint cute_tiled_read_animation_frames_internal(cute_tiled_map_internal_t* m, cute_tiled_frame_t** out_frames, int* out_count)\n{\n\tint count = 0;\n\tint capacity = 32;\n\tcute_tiled_frame_t* frames = (cute_tiled_frame_t*)CUTE_TILED_ALLOC(capacity * sizeof(cute_tiled_frame_t), m->mem_ctx);\n\n\tcute_tiled_expect(m, '[');\n\n\twhile (cute_tiled_peak(m) != ']')\n\t{\n\t\tcute_tiled_frame_t frame;\n\t\tcute_tiled_expect(m, '{');\n\n\t\t// Read in the duration and tileid.\n\t\tcute_tiled_skip_until_after(m, ':');\n\t\tcute_tiled_read_int(m, &frame.duration);\n\t\tcute_tiled_expect(m, ',');\n\t\tcute_tiled_skip_until_after(m, ':');\n\t\tcute_tiled_read_int(m, &frame.tileid);\n\n\t\tif (count == capacity)\n\t\t{\n\t\t\tcute_tiled_frame_t* new_frames;\n\t\t\tcapacity *= 2;\n\t\t\tnew_frames = (cute_tiled_frame_t*)CUTE_TILED_ALLOC(capacity * sizeof(cute_tiled_frame_t), m->mem_ctx);\n\t\t\tCUTE_TILED_MEMCPY(new_frames, frames, sizeof(cute_tiled_frame_t) * count);\n\t\t\tCUTE_TILED_FREE(frames, m->mem_ctx);\n\t\t\tframes = new_frames;\n\t\t}\n\t\tframes[count++] = frame;\n\n\t\tcute_tiled_expect(m, '}');\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, ']');\n\tcute_tiled_try(m, ',');\n\n\t*out_frames = frames;\n\t*out_count = count;\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_animation_frames(m, out_frames, out_count) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_animation_frames_internal(m, out_frames, out_count)); \\\n\t} while (0)\n\ncute_tiled_tile_descriptor_t* cute_tiled_read_tile_descriptor(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_tile_descriptor_t* tile_descriptor = (cute_tiled_tile_descriptor_t*)cute_tiled_alloc(m, sizeof(cute_tiled_tile_descriptor_t));\n\tCUTE_TILED_MEMSET(tile_descriptor, 0, sizeof(cute_tiled_tile_descriptor_t));\n\n\tcute_tiled_expect(m, '{');\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tCUTE_TILED_U64 h;\n\t\tcute_tiled_read_string(m);\n\t\tcute_tiled_expect(m, ':');\n\t\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\t\tswitch (h)\n\t\t{\n\t\tcase 3133932603199444032U: // id\n\t\t\tcute_tiled_read_int(m, &tile_descriptor->tile_index);\n\t\t\tbreak;\n\n\t\tcase 13509284784451838071U: // type\n\t\t\tcute_tiled_intern_string(m, &tile_descriptor->type);\n\t\t\tbreak;\n\n\t\tcase 13522647194774232494U: // image\n\t\t\tcute_tiled_intern_string(m, &tile_descriptor->image);\n\t\t\tbreak;\n\n\t\tcase 7796197983149768626U: // imagewidth\n\t\t\tcute_tiled_read_int(m, &tile_descriptor->imagewidth);\n\t\t\tbreak;\n\n\t\tcase 2114495263010514843U: // imageheight\n\t\t\tcute_tiled_read_int(m, &tile_descriptor->imageheight);\n\t\t\tbreak;\n\n\t\tcase 8368542207491637236U: // properties\n\t\t\tcute_tiled_read_properties(m, &tile_descriptor->properties, &tile_descriptor->property_count);\n\t\t\tbreak;\n\n\t\tcase 6659907350341014391U: // objectgroup\n\t\t{\n\t\t\tcute_tiled_layer_t* layer = cute_tiled_layers(m);\n\t\t\tCUTE_TILED_FAIL_IF(!layer);\n\t\t\tlayer->next = tile_descriptor->objectgroup;\n\t\t\ttile_descriptor->objectgroup = layer;\n\t\t}\tbreak;\n\n\t\tcase 6875414612738028948: // probability\n\t\t\tcute_tiled_read_float(m, &tile_descriptor->probability);\n\t\t\tbreak;\n\n\t\tcase 2784044778313316778U: // terrain: used by tiled editor only\n\t\t\tcute_tiled_skip_array(m);\n\t\t\tbreak;\n\n\t\tcase 3115399308714904519U: // animation\n\t\t\tcute_tiled_read_animation_frames(m, &tile_descriptor->animation, &tile_descriptor->frame_count);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t\t}\n\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, '}');\n\treturn tile_descriptor;\n\ncute_tiled_err:\n\treturn 0;\n}\n\nint cute_tiled_read_point_internal(cute_tiled_map_internal_t* m, int* point_x, int* point_y)\n{\n\t*point_x = 0;\n\t*point_y = 0;\n\n\tcute_tiled_expect(m, '{');\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tCUTE_TILED_U64 h;\n\t\tcute_tiled_read_string(m);\n\t\tcute_tiled_expect(m, ':');\n\t\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\t\tswitch (h)\n\t\t{\n\t\tcase 644252274336276709U: // x\n\t\t\tcute_tiled_read_int(m, point_x);\n\t\t\tbreak;\n\n\t\tcase 643295699219922364U: // y\n\t\t\tcute_tiled_read_int(m, point_y);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t\t}\n\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, '}');\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_read_point(m, x, y) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_read_point_internal(m, x, y)); \\\n\t} while (0)\n\nstatic CUTE_TILED_INLINE int cute_tiled_skip_curly_braces_internal(cute_tiled_map_internal_t* m)\n{\n\tint count = 1;\n\tcute_tiled_expect(m, '{');\n\twhile (count)\n\t{\n\t\tchar c = cute_tiled_next(m);\n\t\tif (c == '}') --count;\n\t\telse if (c == '{') ++count;\n\t}\n\n\treturn 0;\n\ncute_tiled_err:\n\treturn 1;\n}\n\ncute_tiled_tileset_t* cute_tiled_tileset(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_tileset_t* tileset = (cute_tiled_tileset_t*)cute_tiled_alloc(m, sizeof(cute_tiled_tileset_t));\n\tCUTE_TILED_MEMSET(tileset, 0, sizeof(cute_tiled_tileset_t));\n\tcute_tiled_expect(m, '{');\n\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tCUTE_TILED_U64 h;\n\t\tcute_tiled_read_string(m);\n\t\tcute_tiled_expect(m, ':');\n\t\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\t\tswitch (h)\n\t\t{\n\t\tcase 17465100621023921744U: // backgroundcolor\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tcute_tiled_read_hex_int(m, &tileset->backgroundcolor);\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tbreak;\n\n\t\tcase 1485919047363370797U: // class\n\t\t\tcute_tiled_intern_string(m, &tileset->class_);\n\t\t\tbreak;\n\n\t\tcase 12570673734542705940U: // columns\n\t\t\tcute_tiled_read_int(m, &tileset->columns);\n\t\t\tbreak;\n\n\t\tcase 13648382824248632287U: // editorsettings\n\t\t\tcute_tiled_skip_object(m);\n\t\t\tbreak;\n\n\t\tcase 13956389100366699181U: // firstgid\n\t\t\tcute_tiled_read_int(m, &tileset->firstgid);\n\t\t\tbreak;\n\n\t\tcase 16920059161811221315U: // grid: unsupported\n\t\t\tcute_tiled_skip_object(m);\n\t\t\tbreak;\n\n\t\tcase 13522647194774232494U: // image\n\t\t\tcute_tiled_intern_string(m, &tileset->image);\n\t\t\tbreak;\n\n\t\tcase 7796197983149768626U: // imagewidth\n\t\t\tcute_tiled_read_int(m, &tileset->imagewidth);\n\t\t\tbreak;\n\n\t\tcase 2114495263010514843U: // imageheight\n\t\t\tcute_tiled_read_int(m, &tileset->imageheight);\n\t\t\tbreak;\n\n\t\tcase 4864566659847942049U: // margin\n\t\t\tcute_tiled_read_int(m, &tileset->margin);\n\t\t\tbreak;\n\n\t\tcase 12661511911333414066U: // name\n\t\t\tcute_tiled_intern_string(m, &tileset->name);\n\t\t\tbreak;\n\n\t\tcase 1007832939408977147U: // tiledversion\n\t\t\tcute_tiled_intern_string(m, &tileset->tiledversion);\n\t\t\tbreak;\n\n\t\tcase 8196820454517111669U: // version\n\t\t\tif (*m->in == '\"')\n\t\t\t\tm->in++;\n\t\t\tcute_tiled_read_float(m, &tileset->version);\n\t\t\tif (*m->in == '\"')\n\t\t\t\tm->in++;\n\t\t\tbreak;\n\n\t\tcase 8368542207491637236U: // properties\n\t\t\tcute_tiled_read_properties(m, &tileset->properties, &tileset->property_count);\n\t\t\tbreak;\n\n\t\tcase 6491372721122724890U: // spacing\n\t\t\tcute_tiled_read_int(m, &tileset->spacing);\n\t\t\tbreak;\n\n\t\tcase 4065097716972592720U: // tilecount\n\t\t\tcute_tiled_read_int(m, &tileset->tilecount);\n\t\t\tbreak;\n\n\t\tcase 13337683360624280154U: // tileheight\n\t\t\tcute_tiled_read_int(m, &tileset->tileheight);\n\t\t\tbreak;\n\n\t\tcase 2769630600247906626U: // tileoffset\n\t\t\tcute_tiled_read_point(m, &tileset->tileoffset_x, &tileset->tileoffset_y);\n\t\t\tbreak;\n\n\t\tcase 7277156227374254384U: // tileproperties\n\t\t\tCUTE_TILED_WARNING(\"`tileproperties` is deprecated. Attempting to skip.\");\n\t\t\tCUTE_TILED_FAIL_IF(cute_tiled_skip_curly_braces_internal(m));\n\t\t\tbreak;\n\n\t\tcase 15569462518706435895U: // tilepropertytypes\n\t\t\tCUTE_TILED_WARNING(\"`tilepropertytypes` is deprecated. Attempting to skip.\");\n\t\t\tCUTE_TILED_FAIL_IF(cute_tiled_skip_curly_braces_internal(m));\n\t\t\tbreak;\n\n\t\tcase 6504415465426505561U: // tilewidth\n\t\t\tcute_tiled_read_int(m, &tileset->tilewidth);\n\t\t\tbreak;\n\n\t\tcase 8489814081865549564U: // transparentcolor\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tcute_tiled_read_hex_int(m, &tileset->transparentcolor);\n\t\t\tcute_tiled_expect(m, '\"');\n\t\t\tbreak;\n\n\t\tcase 13509284784451838071U: // type\n\t\t\tcute_tiled_intern_string(m, &tileset->type);\n\t\t\tbreak;\n\n\t\tcase 8053780534892277672U: // source\n\t\t\tcute_tiled_intern_string(m, &tileset->source);\n#ifndef CUTE_TILED_NO_EXTERNAL_TILESET_WARNING\n\t\t\tCUTE_TILED_WARNING(\"You might have forgotten to embed your tileset -- Most fields of `cute_tiled_tileset_t` will be zero'd out (unset).\");\n#endif /* CUTE_TILED_NO_EXTERNAL_TILESET_WARNING */\n\t\t\tbreak;\n\n\t\tcase 1819203229U: // objectalignment\n\t\t\tcute_tiled_intern_string(m, &tileset->objectalignment);\n\t\t\tbreak;\n\n\t\tcase 104417158474046698U: // tiles\n\t\t{\n\t\t\tcute_tiled_expect(m, '[');\n\t\t\twhile (cute_tiled_peak(m) != ']')\n\t\t\t{\n\t\t\t\tcute_tiled_tile_descriptor_t* tile_descriptor = cute_tiled_read_tile_descriptor(m);\n\t\t\t\tCUTE_TILED_FAIL_IF(!tile_descriptor);\n\t\t\t\ttile_descriptor->next = tileset->tiles;\n\t\t\t\ttileset->tiles = tile_descriptor;\n\t\t\t\tcute_tiled_try(m, ',');\n\t\t\t}\n\t\t\tcute_tiled_expect(m, ']');\n\t\t}\tbreak;\n\n\t\tcase 14766449174202642533U: // terrains: used by tiled editor only\n\t\t\tcute_tiled_skip_array(m);\n\t\t\tbreak;\n\n\t\tcase 6029584663444593209U: // wangsets: used by tiled editor only\n\t\t\tcute_tiled_skip_array(m);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t\t}\n\n\t\tcute_tiled_try(m, ',');\n\t}\n\n\tcute_tiled_expect(m, '}');\n\treturn tileset;\n\ncute_tiled_err:\n\treturn 0;\n}\n\nstatic int cute_tiled_dispatch_map_internal(cute_tiled_map_internal_t* m)\n{\n\tCUTE_TILED_U64 h;\n\tcute_tiled_read_string(m);\n\tcute_tiled_expect(m, ':');\n\th = cute_tiled_FNV1a(m->scratch, m->scratch_len + 1);\n\n\tswitch (h)\n\t{\n\tcase 17465100621023921744U: // backgroundcolor\n\t\tcute_tiled_expect(m, '\"');\n\t\tcute_tiled_read_hex_int(m, &m->map.backgroundcolor);\n\t\tcute_tiled_expect(m, '\"');\n\t\tbreak;\n\n\tcase 1485919047363370797U: // class\n\t\tcute_tiled_intern_string(m, &m->map.class_);\n\t\tbreak;\n\n\tcase 5549108793316760247U: // compressionlevel\n\t{\n\t\tint compressionlevel;\n\t\tcute_tiled_read_int(m, &compressionlevel);\n\t\tCUTE_TILED_CHECK(compressionlevel == -1 || compressionlevel == 0, \"Compression is not yet supported.\");\n\t}\tbreak;\n\n\tcase 13648382824248632287U: // editorsettings\n\t\tcute_tiled_skip_object(m);\n\t\tbreak;\n\n\tcase 809651598226485190U: // height\n\t\tcute_tiled_read_int(m, &m->map.height);\n\t\tbreak;\n\n\tcase 16529928297377797591U: // infinite\n\t\tcute_tiled_read_bool(m, &m->map.infinite);\n\t\tbreak;\n\n\tcase 4566956252693479661U: // layers\n\t\tcute_tiled_expect(m, '[');\n\n\t\twhile (cute_tiled_peak(m) != ']')\n\t\t{\n\t\t\tcute_tiled_layer_t* layer = cute_tiled_layers(m);\n\t\t\tCUTE_TILED_FAIL_IF(!layer);\n\t\t\tlayer->next = m->map.layers;\n\t\t\tm->map.layers = layer;\n\t\t\tcute_tiled_try(m, ',');\n\t\t}\n\n\t\tcute_tiled_expect(m, ']');\n\t\tbreak;\n\n\tcase 11291153769551921430U: // nextobjectid\n\t\tcute_tiled_read_int(m, &m->map.nextobjectid);\n\t\tbreak;\n\n\tcase 563935667693078739U: // orientation\n\t\tcute_tiled_intern_string(m, &m->map.orientation);\n\t\tbreak;\n\n\tcase 8368542207491637236U: // properties\n\t\tcute_tiled_read_properties(m, &m->map.properties, &m->map.property_count);\n\t\tbreak;\n\n\tcase 16693886730115578029U: // renderorder\n\t\tcute_tiled_intern_string(m, &m->map.renderorder);\n\t\tbreak;\n\n\tcase 1007832939408977147U: // tiledversion\n\t\tcute_tiled_intern_string(m, &m->map.tiledversion);\n\t\tbreak;\n\n\tcase 13337683360624280154U: // tileheight\n\t\tcute_tiled_read_int(m, &m->map.tileheight);\n\t\tbreak;\n\n\tcase 8310322674355535532U: // tilesets\n\t{\n\t\tcute_tiled_expect(m, '[');\n\n\t\twhile (cute_tiled_peak(m) != ']')\n\t\t{\n\t\t\tcute_tiled_tileset_t* tileset = cute_tiled_tileset(m);\n\t\t\tCUTE_TILED_FAIL_IF(!tileset);\n\t\t\ttileset->next = m->map.tilesets;\n\t\t\tm->map.tilesets = tileset;\n\t\t\tcute_tiled_try(m, ',');\n\t\t}\n\n\t\tcute_tiled_expect(m, ']');\n\t}\tbreak;\n\n\tcase 6504415465426505561U: // tilewidth\n\t\tcute_tiled_read_int(m, &m->map.tilewidth);\n\t\tbreak;\n\n\tcase 13509284784451838071U: // type\n\t\tcute_tiled_intern_string(m, &m->map.type);\n\t\tbreak;\n\n\tcase 8196820454517111669U: // version\n\t\tif (*m->in == '\"')\n\t\t\tm->in++;\n\t\tcute_tiled_read_float(m, &m->map.version);\n\t\tif (*m->in == '\"')\n\t\t\tm->in++;\n\t\tbreak;\n\n\tcase 7400839267610537869U: // width\n\t\tcute_tiled_read_int(m, &m->map.width);\n\t\tbreak;\n\n\tcase 2498445529143042872U: // nextlayerid\n\t\tcute_tiled_read_int(m, &m->map.nextlayerid);\n\t\tbreak;\n\n\tdefault:\n\t\tCUTE_TILED_CHECK(0, \"Unknown identifier found.\");\n\t}\n\n\treturn 1;\n\ncute_tiled_err:\n\treturn 0;\n}\n\n#define cute_tiled_dispatch_map(m) \\\n\tdo { \\\n\t\tCUTE_TILED_FAIL_IF(!cute_tiled_dispatch_map_internal(m)); \\\n\t} while (0)\n\nstatic CUTE_TILED_INLINE void cute_tiled_deintern_string(cute_tiled_map_internal_t* m, cute_tiled_string_t* s)\n{\n\ts->ptr = strpool_embedded_cstr(&m->strpool, s->hash_id);\n}\n\nstatic void cute_tiled_deintern_properties(cute_tiled_map_internal_t* m, cute_tiled_property_t* properties, int property_count)\n{\n\tint i;\n\tfor (i = 0; i < property_count; ++i)\n\t{\n\t\tcute_tiled_property_t* p = properties + i;\n\t\tcute_tiled_deintern_string(m, &p->name);\n\t\tif (p->type == CUTE_TILED_PROPERTY_STRING) cute_tiled_deintern_string(m, &p->data.string);\n\t}\n}\n\nstatic void cute_tiled_deintern_layer(cute_tiled_map_internal_t* m, cute_tiled_layer_t* layer)\n{\n\twhile (layer)\n\t{\n\t\tcute_tiled_object_t* object;\n\t\tcute_tiled_deintern_string(m, &layer->class_);\n\t\tcute_tiled_deintern_string(m, &layer->draworder);\n\t\tcute_tiled_deintern_string(m, &layer->name);\n\t\tcute_tiled_deintern_string(m, &layer->type);\n\t\tcute_tiled_deintern_string(m, &layer->image);\n\t\tcute_tiled_deintern_properties(m, layer->properties, layer->property_count);\n\n\t\tobject = layer->objects;\n\t\twhile (object)\n\t\t{\n\t\t\tcute_tiled_deintern_string(m, &object->name);\n\t\t\tcute_tiled_deintern_string(m, &object->type);\n\t\t\tcute_tiled_deintern_properties(m, object->properties, object->property_count);\n\t\t\tobject = object->next;\n\t\t}\n\n\t\tcute_tiled_deintern_layer(m, layer->layers);\n\n\t\tlayer = layer->next;\n\t}\n}\n\nstatic void cute_tiled_patch_tileset_strings(cute_tiled_map_internal_t* m, cute_tiled_tileset_t* tileset)\n{\n\tcute_tiled_tile_descriptor_t* tile_descriptor;\n\tcute_tiled_deintern_string(m, &tileset->class_);\n\tcute_tiled_deintern_string(m, &tileset->image);\n\tcute_tiled_deintern_string(m, &tileset->name);\n\tcute_tiled_deintern_string(m, &tileset->type);\n\tcute_tiled_deintern_string(m, &tileset->source);\n\tcute_tiled_deintern_string(m, &tileset->tiledversion);\n\tcute_tiled_deintern_string(m, &tileset->objectalignment);\n\tcute_tiled_deintern_properties(m, tileset->properties, tileset->property_count);\n\ttile_descriptor = tileset->tiles;\n\twhile (tile_descriptor)\n\t{\n\t\tcute_tiled_deintern_string(m, &tile_descriptor->image);\n\t\tcute_tiled_deintern_string(m, &tile_descriptor->type);\n\t\tcute_tiled_deintern_properties(m, tile_descriptor->properties, tile_descriptor->property_count);\n\t\ttile_descriptor = tile_descriptor->next;\n\t}\n}\n\nstatic void cute_tiled_patch_interned_strings(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_tileset_t* tileset;\n\tcute_tiled_layer_t* layer;\n\tcute_tiled_deintern_string(m, &m->map.class_);\n\tcute_tiled_deintern_string(m, &m->map.orientation);\n\tcute_tiled_deintern_string(m, &m->map.renderorder);\n\tcute_tiled_deintern_string(m, &m->map.tiledversion);\n\tcute_tiled_deintern_string(m, &m->map.type);\n\tcute_tiled_deintern_properties(m, m->map.properties, m->map.property_count);\n\n\ttileset = m->map.tilesets;\n\twhile (tileset)\n\t{\n\t\tcute_tiled_patch_tileset_strings(m, tileset);\n\t\ttileset = tileset->next;\n\t}\n\n\tlayer = m->map.layers;\n\tcute_tiled_deintern_layer(m, layer);\n}\n\nstatic void cute_tiled_free_objects(cute_tiled_object_t* objects, void* mem_ctx)\n{\n\tcute_tiled_object_t* object = objects;\n\tCUTE_TILED_UNUSED(mem_ctx);\n\twhile (object)\n\t{\n\t\tif (object->properties) CUTE_TILED_FREE(object->properties, mem_ctx);\n\t\tif (object->vertices) CUTE_TILED_FREE(object->vertices, mem_ctx);\n\t\tobject = object->next;\n\t}\n}\n\nstatic void cute_tiled_free_layers(cute_tiled_layer_t* layers, void* mem_ctx)\n{\n\tcute_tiled_layer_t* layer = layers;\n\tCUTE_TILED_UNUSED(mem_ctx);\n\twhile (layer)\n\t{\n\t\tif (layer->data) CUTE_TILED_FREE(layer->data, mem_ctx);\n\t\tif (layer->properties) CUTE_TILED_FREE(layer->properties, mem_ctx);\n\t\tcute_tiled_free_layers(layer->layers, mem_ctx);\n\t\tcute_tiled_free_objects(layer->objects, mem_ctx);\n\t\tlayer = layer->next;\n\t}\n}\n\nstatic void cute_tiled_free_map_internal(cute_tiled_map_internal_t* m)\n{\n\tcute_tiled_tileset_t* tileset;\n\tcute_tiled_page_t* page;\n\tstrpool_embedded_term(&m->strpool);\n\n\tcute_tiled_free_layers(m->map.layers, m->mem_ctx);\n\tif (m->map.properties) CUTE_TILED_FREE(m->map.properties, m->mem_ctx);\n\n\ttileset = m->map.tilesets;\n\twhile (tileset)\n\t{\n\t\tcute_tiled_tile_descriptor_t* desc;\n\t\tif (tileset->properties) CUTE_TILED_FREE(tileset->properties, m->mem_ctx);\n\t\tdesc = tileset->tiles;\n\t\twhile (desc)\n\t\t{\n\t\t\tif (desc->properties) CUTE_TILED_FREE(desc->properties, m->mem_ctx);\n\t\t\tif (desc->animation) CUTE_TILED_FREE(desc->animation, mem_ctx);\n\t\t\tcute_tiled_free_layers(desc->objectgroup, m->mem_ctx);\n\t\t\tdesc = desc->next;\n\t\t}\n\t\ttileset = tileset->next;\n\t}\n\n\t// cute_tiled_read_csv_integers\n\t// cute_tiled_read_vertex_array\n\t// cute_tiled_read_properties\n\n\tpage = m->pages;\n\twhile (page)\n\t{\n\t\tcute_tiled_page_t* next = page->next;\n\t\tCUTE_TILED_FREE(page, m->mem_ctx);\n\t\tpage = next;\n\t}\n\n\tCUTE_TILED_FREE(m, m->mem_ctx);\n}\n\n#define CUTE_TILED_REVERSE_LIST(T, root) \\\n\tdo { \\\n\t\tT* n = 0; \\\n\t\twhile (root) { \\\n\t\t\tT* next = root->next; \\\n\t\t\troot->next = n; \\\n\t\t\tn = root; \\\n\t\t\troot = next; \\\n\t\t} \\\n\t\troot = n; \\\n\t} while (0)\n\nvoid cute_tiled_reverse_layers(cute_tiled_map_t* map)\n{\n\tCUTE_TILED_REVERSE_LIST(cute_tiled_layer_t, map->layers);\n}\n\nstatic cute_tiled_map_internal_t* cute_tiled_map_internal_alloc_internal(void* memory, int size_in_bytes, void* mem_ctx)\n{\n\tstrpool_embedded_config_t config;\n\tcute_tiled_map_internal_t* m = (cute_tiled_map_internal_t*)CUTE_TILED_ALLOC(sizeof(cute_tiled_map_internal_t), mem_ctx);\n\tCUTE_TILED_MEMSET(m, 0, sizeof(cute_tiled_map_internal_t));\n\tm->in = (char*)memory;\n\tm->end = m->in + size_in_bytes;\n\tm->mem_ctx = mem_ctx;\n\tm->page_size = 1024 * 10;\n\tm->bytes_left_on_page = m->page_size;\n\tm->pages = (cute_tiled_page_t*)CUTE_TILED_ALLOC(sizeof(cute_tiled_page_t) + m->page_size, mem_ctx);\n\tm->pages->next = 0;\n\tm->pages->data = m->pages + 1;\n\tconfig = strpool_embedded_default_config;\n\tconfig.memctx = mem_ctx;\n\tstrpool_embedded_init(&m->strpool, &config);\n\treturn m;\n}\n\ncute_tiled_map_t* cute_tiled_load_map_from_memory(const void* memory, int size_in_bytes, void* mem_ctx)\n{\n\tcute_tiled_map_internal_t* m;\n\tcute_tiled_layer_t* layer;\n\tcute_tiled_tileset_t* tileset;\n\tcute_tiled_error_line = 1;\n\n\tif (!memory) {\n\t\t// Make sure your map file was correctly found and loaded.\n\t\t// If you called `cute_tiled_load_map_from_file` make sure your path was correct, and check\n\t\t// your printf warnings.\n\t\tCUTE_TILED_CRASH();\n\t}\n\n\tm = cute_tiled_map_internal_alloc_internal((void*)memory, size_in_bytes, mem_ctx);\n\tlayer = m->map.layers;\n\ttileset = m->map.tilesets;\n\tcute_tiled_expect(m, '{');\n\twhile (cute_tiled_peak(m) != '}')\n\t{\n\t\tcute_tiled_dispatch_map(m);\n\t\tcute_tiled_try(m, ',');\n\t}\n\tcute_tiled_expect(m, '}');\n\n\t// finalize output by patching strings and reversing singly linked lists\n\tcute_tiled_patch_interned_strings(m);\n\tCUTE_TILED_REVERSE_LIST(cute_tiled_layer_t, m->map.layers);\n\tCUTE_TILED_REVERSE_LIST(cute_tiled_tileset_t, m->map.tilesets);\n\twhile (layer)\n\t{\n\t\tCUTE_TILED_REVERSE_LIST(cute_tiled_object_t, layer->objects);\n\t\tlayer = layer->next;\n\t}\n\twhile (tileset)\n\t{\n\t\tCUTE_TILED_REVERSE_LIST(cute_tiled_tile_descriptor_t, tileset->tiles);\n\t\ttileset = tileset->next;\n\t}\n\n\treturn &m->map;\n\ncute_tiled_err:\n\tcute_tiled_free_map_internal(m);\n\tCUTE_TILED_WARNING(cute_tiled_error_reason);\n\treturn 0;\n}\n\nvoid cute_tiled_free_map(cute_tiled_map_t* map)\n{\n\tcute_tiled_map_internal_t* m = (cute_tiled_map_internal_t*)(((char*)map) - (size_t)(&((cute_tiled_map_internal_t*)0)->map));\n\tcute_tiled_free_map_internal(m);\n}\n\ncute_tiled_tileset_t* cute_tiled_load_external_tileset(const char* path, void* mem_ctx)\n{\n\tint size;\n\tvoid* file;\n\tcute_tiled_tileset_t* tileset;\n\tcute_tiled_error_file = path;\n\n\tfile = cute_tiled_read_file_to_memory_and_null_terminate(path, &size, mem_ctx);\n\tif (!file) CUTE_TILED_WARNING(\"Unable to find external tileset file.\");\n\ttileset = cute_tiled_load_external_tileset_from_memory(file, size, mem_ctx);\n\tCUTE_TILED_FREE(file, mem_ctx);\n\n\tcute_tiled_error_file = NULL;\n\n\treturn tileset;\n}\n\ncute_tiled_tileset_t* cute_tiled_load_external_tileset_from_memory(const void* memory, int size_in_bytes, void* mem_ctx)\n{\n\tcute_tiled_map_internal_t* m = cute_tiled_map_internal_alloc_internal((void*)memory, size_in_bytes, mem_ctx);\n\tcute_tiled_tileset_t* tileset = cute_tiled_tileset(m);\n\tcute_tiled_patch_tileset_strings(m, tileset);\n\tCUTE_TILED_REVERSE_LIST(cute_tiled_tile_descriptor_t, tileset->tiles);\n\ttileset->_internal = m;\n\treturn tileset;\n}\n\nvoid cute_tiled_free_external_tileset(cute_tiled_tileset_t* tileset)\n{\n\tcute_tiled_map_internal_t* m = (cute_tiled_map_internal_t*)tileset->_internal;\n\tcute_tiled_free_map_internal(m);\n}\n\n#endif // CUTE_TILED_IMPLEMENTATION_ONCE\n#endif // CUTE_TILED_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2017 Randy Gaul http://www.randygaul.net\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\n\tsoftware, either in source code form or as a compiled binary, for any purpose,\n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this\n\tsoftware dedicate any and all copyright interest in the software to the public\n\tdomain. We make this dedication for the benefit of the public at large and to\n\tthe detriment of our heirs and successors. We intend this dedication to be an\n\tovert act of relinquishment in perpetuity of all present and future rights to\n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cute_tls.h",
          "type": "blob",
          "size": 43.7841796875,
          "content": "/*\n\t------------------------------------------------------------------------------\n\t\tLicensing information can be found at the end of the file.\n\t------------------------------------------------------------------------------\n\n\tcute_tls.h - v1.01\n\n\tTo create implementation (the function definitions)\n\t\t#define CUTE_TLS_IMPLEMENTATION\n\tin *one* C/CPP file (translation unit) that includes this file\n\n\n\tSUMMARY\n\n\t\tcute_tls.h is a single-file header that implements some functions to\n\t\tmake a connection over TLS 1.2 and send some data back and forth over a\n\t\tTCP socket. It's meant mainly for making some simple HTTPS requsts to a web\n\t\tserver, but nothing heavy-duty requiring extreme performance. It uses native\n\t\tAPIs on Windows and Apple machines to get access to highly robust TLS\n\t\timplementations for security. This header merely facilitates these native APIs\n\t\tthrough a TCP socket.\n\n\t\tOn Windows Secure Channel is used. On Apple machines the Network.framework is used.\n\t\tFor *Nix s2n can be used a third-party solution, since no good OS-level TLS\n\t\thandshake is currently available on Linux.\n\n\n\tGENERAL INFORMATION ABOUT HTTPS\n\n\t\tThis header is great for providing a TLS tunnel to hook up to your favorite\n\t\thttps writer. Simply pipe the finalized HTTP buffer through a TLS connection\n\t\tcreated by this header, and boom -- you have HTTPS.\n\n\t\tThe general theory behind how it works: websites out in the world ask a special\n\t\tentity called a Certificate Authority (CA) to recognize them as a valid website.\n\t\tThe CA gives them a certificate (usually an X.509 cert). It usually lasts for some\n\t\tnumber of years, and is used to validate that a message came from the website you\n\t\tthink it did. This prevents anyone from pretending to who they are not, and also\n\t\tprevents anyone from reading or tampering with packets between yourself and the website.\n\n\t\tThis works by requesting the website provide you with their certificate. Everyone's\n\t\tmachines have built-in mechanisms to ask a trusted CA if the website's certificate\n\t\tis valid. These are usually installed along with the operating system or browser.\n\n\t\tHTTPS is HTTP over the TLS protocol, using high-powered cryptography via certificates.\n\t\tBy opening a connection with cute_tls.h we immediately have access to making HTTPS\n\t\trequests!\n\n\n\tLIMITATIONS\n\n\t\tEmscripten/Android platforms are not currently supported.\n\n\t\tClient credentials are not supported.\n\n\t\tIPv6 is not supported, though this is totally possible, just not initially in v1.00.\n\n\t\tThe server side of the connection is *not* supported. This is a client-only implementation.\n\n\n\tBUILDING ON APPLE DEVICES\n\n\t\tTo build on Apple devices you must compile this file as an Objective-C file (.m). This is\n\t\tkind of icky and super lame, but blame Apple for continually deprecating their C APIs and\n\t\treleasing newer Obj-C replacements.\n\n\t\tLink against Network.framework, and Security.framework. Make sure automatic reference\n\t\tcounting (ARC) is off if you're using XCode.\n\n\t\tExample command line:\n\n\t\t\tclang -framework Network main.cpp -o my_executable\n\n\n\tBUILDING ON *NIX (INCLUDING APPLE DEVICES)\n\n\t\tA wrapping implementation of s2n is implemented, see: https://github.com/aws/s2n-tls\n\t\ts2n is a pretty good library for implementing TLS servers, but can also be used for\n\t\tclients. It's quite a good library for Apple/Linux, but has no Windows support. Since\n\t\tLinux has no out-of-the-box TLS handshake implementation at the OS-level, unlike Apple/Windows,\n\t\twe have to choose some third-party tool to get things done. Another decent choice could\n\t\thave been mbedtls, but s2n is implemented with much less code, and was thus chosen instead.\n\n\t\tIf on MacOS for development make sure to install s2n on your machine. I suggest using brew.\n\n\t\t\tbrew install s2n\n\n\t\tRegardless of how you install s2n make sure your compiler can find the static library and\n\t\theaders in order to properly link against s2n. Here's an example implementation for devloping\n\t\ton MacOS: https://github.com/RandyGaul/cute_headers/tree/master/examples_cute_tls/macos/s2n\n\n\t\tFor Linux it's basically he same story. If you're using Linux I assume you know what you're\n\t\tdoing, so follow along on the s2n docs as you see fit: https://github.com/aws/s2n-tls\n\n\n\tOTHER OPERATING SYSTEMS (e.g. ANDROID/EMSCRIPTEN)\n\n\t\tAndroid is a bit of another story. I don't have too much Android dev experience, but the best\n\t\toption may be to call from C into Java and use Android's on SSL socket, or their HTTPS APi\n\t\tdirectly from Java: https://developer.android.com/training/articles/security-ssl\n\n\t\tFor Emscripten it looks like they have a C++ websocket wrapper that might work, though I\n\t\thave yet to try it: https://emscripten.org/docs/porting/networking.html#emscripten-websockets-api\n\n\n\tCUSTOMIZATION\n\n\t\tA variety of macros can be overriden by merely defining them before including the implementation\n\t\tsection of this file. Define any one of them to use your own custom functions.\n\n\t\tTLS_MALLOC\n\t\tTLS_MEMCPY\n\t\tTLS_MEMSET\n\t\tTLS_MEMMOVE\n\t\tTLS_ASSERT\n\t\tTLS_STRCMP\n\t\tTLS_PACKET_QUEUE_MAX_ENTRIES (default at 64)\n\n\n\tSPECIAL THANKS\n\n\t\tA special thanks goes to Martins Mozeiko for their sample code on setting up a TLS\n\t\tconnection via SChannel: https://gist.github.com/mmozeiko/c0dfcc8fec527a90a02145d2cc0bfb6d\n\n\t\tA special thanks goes to Mattias Gustavsson for their API design in https.h:\n\t\thttps://github.com/mattiasgustavsson/libs/blob/main/http.h\n\n\n\tRevision history:\n\t\t1.00 (06/17/2023) initial release\n\t\t1.01 (06/19/2023) s2n implementation for apple/linux\n*/\n\n/*\n\tDOCUMENTATION\n\n\t\t1. Call tls_connect\n\t\t\tTLS_Connection connection = tls_connect(hostname, 443);\n\t\t\n\t\t2. Call tls_process\n\t\t\twhile (1) {\n\t\t\t\tTLS_State state = tls_process(connection);\n\t\t\t\t...\n\t\t\t}\n\t\t\n\t\t3. Call tls_read or tls_send\n\t\t\ttls_send(connection, buffer, size);\n\t\t\tor\n\t\t\ttls_read(connection, buffer, size);\n\t\t\n\t\t4. Call tls_disconnect\n\t\t\n\t\t5. For errors call tls_state_string on the return value of tls_process.\n\n\n\tFULL DEMO PROGRAM\n\t\n\t\tHere's a full program that connects to a given website and sends an HTTP GET request.\n\t\tThe entire HTTP response is saved to a file called \"response.txt\". You may also try using\n\t\tbadssl.com to try out a variety of failure cases (the commented strings at the top of the\n\t\tdemo function).\n\n\t\t\t#define CUTE_TLS_IMPLEMENTATION\n\t\t\t#include \"cute_tls.h\"\n\t\t\t\n\t\t\tint main()\n\t\t\t{\n\t\t\t\tconst char* hostname = \"www.google.com\";\n\t\t\t\t//const char* hostname = \"badssl.com\";\n\t\t\t\t//const char* hostname = \"expired.badssl.com\";\n\t\t\t\t//const char* hostname = \"wrong.host.badssl.com\";\n\t\t\t\t//const char* hostname = \"self-signed.badssl.com\";\n\t\t\t\t//const char* hostname = \"untrusted-root.badssl.com\";\n\n\t\t\t\tTLS_Connection connection = tls_connect(hostname, 443);\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tTLS_State state = tls_process(connection);\n\t\t\t\t\tif (state == TLS_STATE_CONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (state < 0) {\n\t\t\t\t\t\tprintf(\"Error connecting to to %s with code %s.\\n\", hostname, tls_state_string(state));\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprintf(\"Connected!\\n\");\n\n\t\t\t\t// Send GET request.\n\t\t\t\tchar req[1024];\n\t\t\t\tint len = sprintf(req, \"GET / HTTP/1.1\\r\\nHost: %s\\r\\nConnection: close\\r\\n\\r\\n\", hostname);\n\t\t\t\tif (tls_send(connection, req, len) < 0) {\n\t\t\t\t\ttls_disconnect(connection);\n\t\t\t\t\tprintf(\"Failed to send data.\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t// Write the full HTTP response to file.\n\t\t\t\tFILE* fp = fopen(\"response.txt\", \"wb\");\n\t\t\t\tint received = 0;\n\t\t\t\tchar buf[TLS_MAX_PACKET_SIZE];\n\t\t\t\twhile (1) {\n\t\t\t\t\tTLS_State state = tls_process(connection);\n\t\t\t\t\tif (state == TLS_STATE_DISCONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tint bytes = tls_read(connection, buf, sizeof(buf));\n\t\t\t\t\tif (bytes < 0) {\n\t\t\t\t\t\ttls_disconnect(connection);\n\t\t\t\t\t\tprintf(\"Failed reading bytes.\\n\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (bytes) {\n\t\t\t\t\t\tfwrite(buf, 1, bytes, fp);\n\t\t\t\t\t\tfflush(fp);\n\t\t\t\t\t\treceived += bytes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\n\t\t\t\tprintf(\"Received %d bytes\\n\", received);\n\n\t\t\t\ttls_disconnect(connection);\n\t\t\t}\n*/\n\n#ifndef CUTE_TLS_H\n#define CUTE_TLS_H\n\ntypedef struct TLS_Connection { unsigned long long id; } TLS_Connection;\n\n// Initiates a new TLS 1.2 connection.\nTLS_Connection tls_connect(const char* hostname, int port);\n\n// Frees up all resources associated with the connection.\nvoid tls_disconnect(TLS_Connection connection);\n\ntypedef enum TLS_State\n{\n\tTLS_STATE_BAD_CERTIFICATE                       = -8, // Bad or unsupported cert format.\n\tTLS_STATE_SERVER_ASKED_FOR_CLIENT_CERTS         = -7, // Not supported.\n\tTLS_STATE_CERTIFICATE_EXPIRED                   = -6,\n\tTLS_STATE_BAD_HOSTNAME                          = -5,\n\tTLS_STATE_CANNOT_VERIFY_CA_CHAIN                = -4,\n\tTLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS     = -3,\n\tTLS_STATE_INVALID_SOCKET                        = -2,\n\tTLS_STATE_UNKNOWN_ERROR                         = -1,\n\tTLS_STATE_DISCONNECTED                          = 0,\n\tTLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN = 1,  // The TCP socket closed, but you should keep calling `tls_read`.\n\tTLS_STATE_PENDING                               = 2,  // Handshake in progress.\n\tTLS_STATE_CONNECTED                             = 3,\n\tTLS_STATE_PACKET_QUEUE_FILLED                   = 4,  // Not calling `tls_read` enough. Did you forget to call this in a loop after `tls_process`?\n} TLS_State;\n\n// Call this in a loop to update the connection.\n// This will perform the initial connect sequence, and also fetch data off the wire once connected.\nTLS_State tls_process(TLS_Connection connection);\n\n// Returns `TLS_State` as a string.\nconst char* tls_state_string(TLS_State state);\n\n// Returns number of bytes read on success, -1 on failure.\nint tls_read(TLS_Connection connection, void* data, int size);\n\n// Reads up to size bytes, returns amount of bytes received on success (<= size).\n// Returns 0 on disconnect or -1 on error.\nint tls_send(TLS_Connection connection, const void* data, int size);\n\n#define TLS_1_KB 1024\n#define TLS_MAX_RECORD_SIZE (16 * TLS_1_KB)                  // TLS defines records to be up to 16kb.\n#define TLS_MAX_PACKET_SIZE (TLS_MAX_RECORD_SIZE + TLS_1_KB) // Some extra rooms for records split over two packets.\n\n#endif // CUTE_TLS_H\n\n#ifdef CUTE_TLS_IMPLEMENTATION\n#ifndef CUTE_TLS_IMPLEMENTATION_ONCE\n#define CUTE_TLS_IMPLEMENTATION_ONCE\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#\tdefine _CRT_SECURE_NO_WARNINGS\n#endif\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\n#\tdefine _CRT_NONSTDC_NO_DEPRECATE\n#endif\n#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\n#\tdefine _WINSOCK_DEPRECATED_NO_WARNINGS\n#endif\n\n#ifdef CUTE_TLS_S2N\n#\tdefine TLS_S2N\n#endif\n\n#ifndef TLS_S2N\n#\tifdef _WIN32\n#\t\tdefine TLS_WINDOWS\n#\telif defined(__APPLE__)\n#\t\tdefine TLS_APPLE\n#\telif defined(__linux__) || defined(__unix__) && !defined(__APPLE__) && !defined(__EMSCRIPTEN__)\n#\t\tdefine TLS_S2N\n#\telse\n#\t\terror Platform not yet supported.\n#\tendif\n#endif\n\n#ifdef TLS_WINDOWS\n#\tifndef WIN32_LEAN_AND_MEAN\n#\t\tdefine WIN32_LEAN_AND_MEAN\n#\tendif\n#\tifndef NOMINMAX\n#\t\tdefine NOMINMAX\n#\tendif\n#\tinclude <winsock2.h>\n#\tinclude <ws2tcpip.h>\n#\tinclude <windows.h>\n#\tifndef SECURITY_WIN32\n#\t\tdefine SECURITY_WIN32\n#\tendif\n#\tinclude <security.h>\n#\tinclude <schannel.h>\n#\tinclude <shlwapi.h>\n#\tinclude <assert.h>\n#\tinclude <stdio.h>\n\n#\tpragma comment (lib, \"ws2_32.lib\")\n#\tpragma comment (lib, \"secur32.lib\")\n#\tpragma comment (lib, \"shlwapi.lib\")\n#elif defined(TLS_APPLE)\n#\tinclude <Network/Network.h>\n#\tinclude <pthread.h>\n#elif defined(TLS_S2N)\n#\tinclude <assert.h>\n#\tinclude <stdio.h>\n#\tinclude <stdlib.h>\n#\tinclude <string.h>\n#\tinclude <sys/socket.h>\n#\tinclude <fcntl.h>\n#\tinclude <unistd.h>\n#\tinclude <netdb.h>\n#\tinclude <errno.h>\n#\tinclude <s2n.h>\n#else\n#\terror No supported backend implementation found.\n#endif\n\n#define TLS_MIN(x, y) ((x) < (y) ? (x) : (y))\n#define TLS_ARRAYSIZE(A) (sizeof(A) / sizeof(*A))\n\n#ifndef TLS_MALLOC\n#\tdefine TLS_MALLOC malloc\n#\tdefine TLS_FREE free\n#endif\n\n#ifndef TLS_MEMCPY\n#\tdefine TLS_MEMCPY memcpy\n#endif\n\n#ifndef TLS_MEMSET\n#\tdefine TLS_MEMSET memset\n#endif\n\n#ifndef TLS_MEMMOVE\n#\tdefine TLS_MEMMOVE memmove\n#endif\n\n#ifndef TLS_ASSERT\n#\tdefine TLS_ASSERT assert\n#endif\n\n#ifndef TLS_STRCMP\n#\tdefine TLS_STRCMP strcmp\n#endif\n\n#ifndef TLS_STRNCMP\n#\tdefine TLS_STRNCMP strncmp\n#endif\n\n#ifndef TLS_PACKET_QUEUE_MAX_ENTRIES\n#\tdefine TLS_PACKET_QUEUE_MAX_ENTRIES (64)\n#endif\n\ntypedef struct TLS_PacketQueue\n{\n#ifdef TLS_APPLE\n\tpthread_mutex_t lock;\n#endif\n\tint count;\n\tint index0;\n\tint index1;\n\tint sizes[TLS_PACKET_QUEUE_MAX_ENTRIES];\n\tvoid* packets[TLS_PACKET_QUEUE_MAX_ENTRIES];\n} TLS_PacketQueue;\n\nstatic void tls_packet_queue_push(TLS_PacketQueue* q, void* packet, int size)\n{\n\t#ifdef TLS_APPLE\n\t\tpthread_mutex_lock(&q->lock);\n\t#endif\n\tif (q->count < TLS_PACKET_QUEUE_MAX_ENTRIES) {\n\t\tq->count++;\n\t\tq->sizes[q->index1] = size;\n\t\tq->packets[q->index1] = packet;\n\t\tq->index1 = (q->index1 + 1) % TLS_PACKET_QUEUE_MAX_ENTRIES;\n\t}\n\t#ifdef TLS_APPLE\n\t\tpthread_mutex_unlock(&q->lock);\n\t#endif\n}\n\nvoid tls_packet_queue_pop(TLS_PacketQueue* q, void** packet, int* size)\n{\n\t#ifdef TLS_APPLE\n\t\tpthread_mutex_lock(&q->lock);\n\t#endif\n\tif (q->count > 0) {\n\t\tq->count--;\n\t\t*size = q->sizes[q->index0];\n\t\t*packet = q->packets[q->index0];\n\t\tq->index0 = (q->index0 + 1) % TLS_PACKET_QUEUE_MAX_ENTRIES;\n\t}\n\t#ifdef TLS_APPLE\n\t\tpthread_mutex_unlock(&q->lock);\n\t#endif\n}\n\ntypedef struct TLS_Context\n{\n\tTLS_PacketQueue q;    // For receiving packets.\n\tTLS_State state;      // Current state of the connection. Negative values are errors.\n\tconst char* hostname; // Website or address to connect to.\n\tvoid* packet;\n\tint packet_size;\n\n#ifdef TLS_WINDOWS\n\tSOCKET sock;\n\tCredHandle handle;\n\tCtxtHandle context;\n\tSecPkgContext_StreamSizes sizes;\n\tbool tcp_connect_pending;\n\tbool first_call;\n\tint received;    // Byte count in incoming buffer (ciphertext).\n\tint used;        // Byte count used from incoming buffer to decrypt current packet.\n\tint available;   // Byte count available for decrypted bytes.\n\tchar* decrypted; // Points to incoming buffer where data is decrypted in-place.\n\tchar incoming[TLS_MAX_PACKET_SIZE];\n#elif defined(TLS_S2N)\n\tint sock;\n\tstruct s2n_connection* connection;\n\tbool tcp_connect_pending;\n\tint received;\n\tchar incoming[TLS_MAX_PACKET_SIZE];\n#elif defined(TLS_APPLE)\n\tdispatch_queue_t dispatch;\n\tnw_connection_t connection;\n#endif\n} TLS_Context;\n\n#ifdef TLS_S2N\nint tls_s2n_init = 0;\n#endif\n\n// Called in a poll-style manner on Windows.\n// For Apple we call this once on init to setup a tail-end recursive callback loop.\nstatic void tls_recv(TLS_Context* ctx)\n{\n\t#ifdef TLS_WINDOWS\n\t\tfd_set sockets_to_check;\n\t\tFD_ZERO(&sockets_to_check);\n\t\tFD_SET(ctx->sock, &sockets_to_check);\n\t\tstruct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 0;\n\t\twhile (select((int)(ctx->sock + 1), &sockets_to_check, NULL, NULL, &timeout) == 1) {\n\t\t\tint r = recv(ctx->sock, ctx->incoming + ctx->received, sizeof(ctx->incoming) - ctx->received, 0);\n\t\t\tif (r == 0) {\n\t\t\t\t// Server disconnected the socket.\n\t\t\t\tctx->state = TLS_STATE_DISCONNECTED;\n\t\t\t\tbreak;\n\t\t\t} else if (r == SOCKET_ERROR) {\n\t\t\t\t// Socket related error.\n\t\t\t\tctx->state = TLS_STATE_INVALID_SOCKET;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tctx->received += r;\n\t\t\t}\n\t\t}\n\t#endif // TLS_WINDOWS\n\n\t#ifdef TLS_APPLE\n\t\t// Queue up an asynchronous receive block loop.\n\t\tnw_connection_receive(ctx->connection, 1, TLS_MAX_PACKET_SIZE, ^(dispatch_data_t content, nw_content_context_t context, bool is_complete, \tnw_error_t receive_error) {\n\t\t\tif (content != NULL) {\n\t\t\t\t// What a horrid API design... So over-engineered to simply memcpy a buffer.\n\t\t\t\tint size = (int)dispatch_data_get_size(content);\n\t\t\t\tvoid* packet = TLS_MALLOC(size);\n\t\t\t\tdispatch_data_apply(content, ^bool(dispatch_data_t content, size_t offset, const void* buffer, size_t size) {\n\t\t\t\t\tTLS_MEMCPY((char*)packet + offset, buffer, size);\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\ttls_packet_queue_push(&ctx->q, packet, size);\n\t\t\t}\n\t\t\tif (is_complete && !receive_error) {\n\t\t\t\tctx->state = TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN;\n\t\t\t} else if (receive_error) {\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t} else {\n\t\t\t\t// Queue up another call to this function to receive the next packet.\n\t\t\t\ttls_recv(ctx);\n\t\t\t}\n\t\t});\n\t#endif // TLS_APPLE\n\n\t#ifdef TLS_S2N\n\t\ts2n_blocked_status blocked = S2N_NOT_BLOCKED;\n\t\tint bytes_read = 0;\n\t\twhile (bytes_read < sizeof(ctx->incoming)) {\n\t\t\tint r = s2n_recv(ctx->connection, ctx->incoming + bytes_read, sizeof(ctx->incoming) - bytes_read, &blocked);\n\t\t\ts2n_error_type etype = (s2n_error_type)s2n_error_get_type(s2n_errno);\n\t\t\tif (r == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (r > 0) {\n\t\t\t\tbytes_read += r;\n\t\t\t} else if (etype == S2N_ERR_T_CLOSED) {\n\t\t\t\tctx->state = TLS_STATE_DISCONNECTED;\n\t\t\t\tbreak;\n\t\t\t} else if (etype == S2N_ERR_T_IO) {\n\t\t\t\tctx->state = TLS_STATE_INVALID_SOCKET;\n\t\t\t\tbreak;\n\t\t\t} else if (etype != S2N_ERR_T_BLOCKED) {\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctx->received = bytes_read;\n\t#endif // TLS_S2N\n}\n\nTLS_Connection tls_connect(const char* hostname, int port)\n{\n\tTLS_Connection result = { 0 };\n\n\tTLS_Context* ctx = (TLS_Context*)TLS_MALLOC(sizeof(TLS_Context));\n\tTLS_MEMSET(ctx, 0, sizeof(*ctx));\n\tctx->hostname = hostname;\n\n\tchar sport[64];\n\tsnprintf(sport, sizeof(sport), \"%u\", port);\n\n\t#if defined(TLS_WINDOWS) || defined(TLS_S2N)\n\t\tctx->tcp_connect_pending = 1;\n\n\t\t#ifdef TLS_WINDOWS\n\t\t\tctx->first_call = 1;\n\n\t\t\t// Initialize winsock.\n\t\t\tWSADATA wsadata;\n\t\t\tif (WSAStartup(MAKEWORD(2, 2), &wsadata) != 0) {\n\t\t\t\tTLS_FREE(ctx);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t#elif defined(TLS_S2N)\n\t\t\tif (!tls_s2n_init) {\n\t\t\t\ttls_s2n_init = 1;\n\t\t\t\ts2n_init();\n\t\t\t}\n\t\t#endif\n\t#endif // defined(TLS_WINDOWS) || defined(TLS_S2N)\n\n\t#if defined(TLS_WINDOWS) || defined(TLS_S2N)\n\t\t// Perform DNS lookup.\n\t\tstruct addrinfo hints;\n\t\tTLS_MEMSET(&hints, 0, sizeof(hints));\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\thints.ai_protocol = IPPROTO_TCP;\n\t\tstruct addrinfo* addri = NULL;\n\t\tif (getaddrinfo(hostname, sport, &hints, &addri) != 0) {\n\t\t\tfreeaddrinfo(addri);\n\t\t\tTLS_FREE(ctx);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Create a TCP IPv4 socket.\n\t\tctx->sock = socket(AF_INET, SOCK_STREAM, 0);\n\t\tif (ctx->sock == -1) {\n\t\t\tfreeaddrinfo(addri);\n\t\t\tTLS_FREE(ctx);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Set non-blocking IO.\n\t\t{\n\t\t\t#ifdef TLS_WINDOWS\n\t\t\t\tDWORD non_blocking = 1;\n\t\t\t\tint res = ioctlsocket(ctx->sock, FIONBIO, &non_blocking);\n\t\t\t#else\n\t\t\t\tint flags = fcntl(ctx->sock, F_GETFL, 0);\n\t\t\t\tint res = fcntl(ctx->sock, F_SETFL, flags | O_NONBLOCK);\n\t\t\t#endif\n\t\t\tif (res != 0) {\n\t\t\t\t#ifdef TLS_WINDOWS\n\t\t\t\t\tclosesocket(ctx->sock);\n\t\t\t\t#else\n\t\t\t\t\tclose(ctx->sock);\n\t\t\t\t#endif\n\t\t\t\tfreeaddrinfo(addri);\n\t\t\t\tTLS_FREE(ctx);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// Startup the TCP connection.\n\t\tif (connect(ctx->sock, addri->ai_addr, (int)addri->ai_addrlen) == -1) {\n\t\t\t#ifdef TLS_WINDOWS\n\t\t\t\tint error = WSAGetLastError();\n\t\t\t\tif (error != WSAEWOULDBLOCK && error != WSAEINPROGRESS) {\n\t\t\t\t\tfreeaddrinfo(addri);\n\t\t\t\t\tclosesocket(ctx->sock);\n\t\t\t\t\tTLS_FREE(ctx);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t#else\n\t\t\t\tif (errno != EWOULDBLOCK && errno != EINPROGRESS && errno != EAGAIN) {\n\t\t\t\t\tfreeaddrinfo(addri);\n\t\t\t\t\tclose(ctx->sock);\n\t\t\t\t\tTLS_FREE(ctx);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t#endif\n\t\t} else {\n\t\t\tfreeaddrinfo(addri);\n\t\t\taddri = NULL;\n\t\t}\n\n\t\tctx->state = TLS_STATE_PENDING;\n\n\t\t#ifdef TLS_WINDOWS\n\t\t// Initialize a credentials handle for Secure Channel.\n\t\t// This is needed for InitializeSecurityContextA.\n\t\t{\n\t\t\tSCHANNEL_CRED cred = { 0 };\n\t\t\tcred.dwVersion = SCHANNEL_CRED_VERSION;\n\t\t\tcred.dwFlags = SCH_USE_STRONG_CRYPTO          // Disable deprecated or otherwise weak algorithms (on as default).\n\t\t\t\t\t\t | SCH_CRED_AUTO_CRED_VALIDATION  // Automatically validate server cert (on as default), as opposed to manual verify.\n\t\t\t\t\t\t | SCH_CRED_NO_DEFAULT_CREDS;     // Client certs are not supported.\n\t\t\tcred.grbitEnabledProtocols = SP_PROT_TLS1_2;  // Specifically pick only TLS 1.2.\n\n\t\t\tif (AcquireCredentialsHandleA(NULL, (char*)UNISP_NAME_A, SECPKG_CRED_OUTBOUND, NULL, &cred, NULL, NULL, &ctx->handle, NULL) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tclosesocket(ctx->sock);\n\t\t\t\tTLS_FREE(ctx);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t#elif defined(TLS_S2N)\n\t\t\t// Create connection and set our socket onto it. s2n wraps our socket -- actually\n\t\t\t// a pretty cool API design, which actually simplifies send/recv in our implementation.\n\t\t\tstruct s2n_connection* connection = s2n_connection_new(S2N_CLIENT);\n\t\t\tif (!connection) {\n\t\t\t\tclose(ctx->sock);\n\t\t\t\tTLS_FREE(ctx);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (s2n_connection_set_fd(connection, ctx->sock) < 0) {\n\t\t\t\tclose(ctx->sock);\n\t\t\t\tTLS_FREE(ctx);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tctx->connection = connection;\n\n\t\t\t// Disable client certs (not supported).\n\t\t\ts2n_connection_set_client_auth_type(connection, S2N_CERT_AUTH_NONE);\n\n\t\t\t// Make sure the cert hostname matches our expectation. If this isn't set here\n\t\t\t// the connection will fail to validate. We could also use `s2n_connection_set_verify_host_callback`\n\t\t\t// but this makes use of a built-in default callback (as per s2n docs). This was *not* at all\n\t\t\t// clear in the docs, and was figured out through painful trial + error.\n\t\t\ts2n_set_server_name(connection, hostname);\n\n\t\t\t// Turn off randomized side-channel blinding. This feature is useful for highly\n\t\t\t// secure servers, but for our simple client it's just annoying.\n\t\t\ts2n_connection_set_blinding(connection, S2N_SELF_SERVICE_BLINDING);\n\t\t#endif\n\t#endif // defined(TLS_WINDOWS) || defined(TLS_S2N)\n\n\t#ifdef TLS_APPLE\n\t\t// Used for syncing the packet queue.\n\t\tpthread_mutex_init(&ctx->q.lock, NULL);\n\n\t\t// Turn on TLS (default config).\n\t\tnw_endpoint_t endpoint = nw_endpoint_create_host(hostname, sport);\n\t\tnw_parameters_configure_protocol_block_t configure_tls = NW_PARAMETERS_DEFAULT_CONFIGURATION;\n\t\tnw_parameters_t parameters = nw_parameters_create_secure_tcp(configure_tls, NW_PARAMETERS_DEFAULT_CONFIGURATION);\n\n\t\t// Set ipv4.\n\t\tnw_protocol_stack_t protocol_stack = nw_parameters_copy_default_protocol_stack(parameters);\n\t\tnw_protocol_options_t ip_options = nw_protocol_stack_copy_internet_protocol(protocol_stack);\n\t\tnw_ip_options_set_version(ip_options, nw_ip_version_4);\n\n\t\t// Create actual connection object.\n\t\tctx->connection = nw_connection_create(endpoint, parameters);\n\t\tnw_retain(ctx->connection);\n\n\t\t// Create an async queue for dispatching all of our connection's callbacks/blocks.\n\t\tctx->dispatch = dispatch_queue_create(\"com.tls.internal_queue\", DISPATCH_QUEUE_SERIAL);\n\t\tdispatch_retain(ctx->dispatch);\n\n\t\t// Various calls into Network.framework are asynchronous and use a queue to dispatch callbacks (blocks).\n\t\tnw_connection_set_queue(ctx->connection, ctx->dispatch);\n\n\t\t// Get notification of when the connection is ready.\n\t\tnw_connection_set_state_changed_handler(ctx->connection, ^(nw_connection_state_t state, nw_error_t error) {\n\t\t\tif (error) {\n\t\t\t\tint code = nw_error_get_error_code(error);\n\t\t\t\tnw_error_domain_t domain = nw_error_get_error_domain(error);\n\t\t\t\tif (domain == nw_error_domain_tls) {\n\t\t\t\t\tif (code == errSSLCertExpired) {\n\t\t\t\t\t\tctx->state = TLS_STATE_CERTIFICATE_EXPIRED;\n\t\t\t\t\t} else if (code == errSSLNegotiation) {\n\t\t\t\t\t\tctx->state = TLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS;\n\t\t\t\t\t} else if (code == errSSLClientCertRequested) {\n\t\t\t\t\t\tctx->state = TLS_STATE_SERVER_ASKED_FOR_CLIENT_CERTS;\n\t\t\t\t\t} else if (code == errSSLHostNameMismatch) {\n\t\t\t\t\t\tctx->state = TLS_STATE_BAD_HOSTNAME;\n\t\t\t\t\t} else if (code == errSSLXCertChainInvalid || code == errSSLPeerUnknownCA) {\n\t\t\t\t\t\tctx->state = TLS_STATE_CANNOT_VERIFY_CA_CHAIN;\n\t\t\t\t\t} else if (code == errSSLBadCert) {\n\t\t\t\t\t\tctx->state = TLS_STATE_BAD_CERTIFICATE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\t// More codes found at:\n\t\t\t\t\t// https://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/SecureTransport.h.auto.html\n\t\t\t\t} else if (domain == nw_error_domain_dns) {\n\t\t\t\t\tif (code == -65554) { // Could not find what fucking header this code is defined within... *Shakes head at Tim Cook*\n\t\t\t\t\t\tctx->state = TLS_STATE_BAD_HOSTNAME;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else if (domain == TLS_STATE_INVALID_SOCKET) {\n\t\t\t\t\tctx->state = TLS_STATE_INVALID_SOCKET;\n\t\t\t\t} else {\n\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == nw_connection_state_ready) {\n\t\t\t\t\tctx->state = TLS_STATE_CONNECTED;\n\t\t\t\t} else if (state > nw_connection_state_ready) {\n\t\t\t\t\tctx->state = TLS_STATE_DISCONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Asynchronously start the connection.\n\t\tnw_connection_start(ctx->connection);\n\t\tctx->state = TLS_STATE_PENDING;\n\n\t\t// Accept incoming packets.\n\t\ttls_recv(ctx);\n\n\t\tnw_release(ip_options);\n\t\tnw_release(protocol_stack);\n\t\tnw_release(parameters);\n\t\tnw_release(endpoint);\n\t#endif\n\n\tresult.id = (unsigned long long)ctx;\n\treturn result;\n}\n\nTLS_State tls_process(TLS_Connection connection)\n{\n\tTLS_Context* ctx = (TLS_Context*)connection.id;\n\tif (ctx->state < 0) {\n\t\treturn ctx->state;\n\t} else if (ctx->state == TLS_STATE_PENDING) {\n\t\t#if defined(TLS_WINDOWS) || defined(TLS_S2N)\n\t\t\t// Wait for TCP to connect.\n\t\t\tif (ctx->tcp_connect_pending) {\n\t\t\t\tfd_set sockets_to_check;\n\t\t\t\tFD_ZERO(&sockets_to_check);\n\t\t\t\tFD_SET(ctx->sock, &sockets_to_check);\n\t\t\t\tstruct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 0;\n\t\t\t\tif (select((int)(ctx->sock + 1), NULL, &sockets_to_check, NULL, &timeout) == 1) {\n\t\t\t\t\tint opt = -1;\n\t\t\t\t\tsocklen_t len = sizeof(opt);\n\t\t\t\t\tif (getsockopt(ctx->sock, SOL_SOCKET, SO_ERROR, (char*)(&opt), &len) >= 0 && opt == 0) {\n\t\t\t\t\t\tctx->tcp_connect_pending = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ctx->tcp_connect_pending) {\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t}\n\t\t\t}\n\t\t#endif // defined(TLS_WINDOWS) || defined(TLS_S2N)\n\n\t\t#ifdef TLS_WINDOWS\n\t\t\t// TLS handshake algorithm.\n\t\t\t// 1. Call InitializeSecurityContext.\n\t\t\t//    The first call creates a security context.\n\t\t\t//    Subsequent calls update the security context.\n\t\t\t// 2. Check InitializeSecurityContext's return value.\n\t\t\t//    SEC_E_OK                     - Handshake completed, TLS tunnel ready to go.\n\t\t\t//    SEC_I_INCOMPLETE_CREDENTIALS - The server asked for client certs (not supported).\n\t\t\t//    SEC_I_CONTINUE_NEEDED        - Success, keep calling InitializeSecurityContext (and send).\n\t\t\t//    SEC_E_INCOMPLETE_MESSAGE     - Success, continue reading data from the server (recv).\n\t\t\t// 3. Otherwise an error may have been encountered. Set an error state and return.\n\t\t\t// 4. Read data from the server (recv).\n\t\n\t\t\t// 1. Call InitializeSecurityContext.\n\t\t\tif (ctx->first_call || ctx->received) {\n\t\t\t\tSecBuffer inbuffers[2] = { 0 };\n\t\t\t\tinbuffers[0].BufferType = SECBUFFER_TOKEN;\n\t\t\t\tinbuffers[0].pvBuffer = ctx->incoming;\n\t\t\t\tinbuffers[0].cbBuffer = ctx->received;\n\t\t\t\tinbuffers[1].BufferType = SECBUFFER_EMPTY;\n\t\n\t\t\t\tSecBuffer outbuffers[1] = { 0 };\n\t\t\t\toutbuffers[0].BufferType = SECBUFFER_TOKEN;\n\t\n\t\t\t\tSecBufferDesc indesc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(inbuffers), inbuffers };\n\t\t\t\tSecBufferDesc outdesc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(outbuffers), outbuffers };\n\t\n\t\t\t\tDWORD flags = ISC_REQ_USE_SUPPLIED_CREDS | ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_CONFIDENTIALITY | ISC_REQ_REPLAY_DETECT | \tISC_REQ_SEQUENCE_DETECT | ISC_REQ_STREAM;\n\t\t\t\tSECURITY_STATUS sec = InitializeSecurityContextA(\n\t\t\t\t\t&ctx->handle,\n\t\t\t\t\tctx->first_call ? NULL : &ctx->context,\n\t\t\t\t\tctx->first_call ? (SEC_CHAR*)ctx->hostname : NULL,\n\t\t\t\t\tflags,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tctx->first_call ? NULL : &indesc,\n\t\t\t\t\t0,\n\t\t\t\t\tctx->first_call ? &ctx->context : NULL,\n\t\t\t\t\t&outdesc,\n\t\t\t\t\t&flags,\n\t\t\t\t\tNULL\n\t\t\t\t);\n\t\n\t\t\t\t// After the first call we are supposed to re-use the same context.\n\t\t\t\tctx->first_call = 0;\n\t\n\t\t\t\t// Fetch incoming data.\n\t\t\t\tif (inbuffers[1].BufferType == SECBUFFER_EXTRA) {\n\t\t\t\t\tTLS_MEMMOVE(ctx->incoming, ctx->incoming + (ctx->received - inbuffers[1].cbBuffer), inbuffers[1].cbBuffer);\n\t\t\t\t\tctx->received = inbuffers[1].cbBuffer;\n\t\t\t\t} else if (inbuffers[1].BufferType != SECBUFFER_MISSING) {\n\t\t\t\t\tctx->received = 0;\n\t\t\t\t}\n\t\n\t\t\t\t// 2. Check InitializeSecurityContext's return value.\n\t\t\t\tif (sec == SEC_E_OK) {\n\t\t\t\t\t// Successfully completed handshake. TLS tunnel is now operational.\n\t\t\t\t\tQueryContextAttributes(&ctx->context, SECPKG_ATTR_STREAM_SIZES, &ctx->sizes);\n\t\t\t\t\tctx->state = TLS_STATE_CONNECTED;\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else if (sec == SEC_I_INCOMPLETE_CREDENTIALS) {\n\t\t\t\t\t// Client certs are not supported.\n\t\t\t\t\tctx->state = TLS_STATE_SERVER_ASKED_FOR_CLIENT_CERTS;\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else if (sec == SEC_I_CONTINUE_NEEDED) {\n\t\t\t\t\t// Continue sending data to the server.\n\t\t\t\t\tchar* buffer = (char*)outbuffers[0].pvBuffer;\n\t\t\t\t\tint size = outbuffers[0].cbBuffer;\n\t\t\t\t\twhile (size != 0) {\n\t\t\t\t\t\tint d = send(ctx->sock, buffer, size, 0);\n\t\t\t\t\t\tif (d <= 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsize -= d;\n\t\t\t\t\t\tbuffer += d;\n\t\t\t\t\t}\n\t\t\t\t\tFreeContextBuffer(outbuffers[0].pvBuffer);\n\t\t\t\t\tif (size != 0) {\n\t\t\t\t\t\t// Somehow failed to send() data to server.\n\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t\treturn ctx->state;\n\t\t\t\t\t}\n\t\t\t\t} else if (sec != SEC_E_INCOMPLETE_MESSAGE) {\n\t\t\t\t\tif (sec == SEC_E_CERT_EXPIRED) {\n\t\t\t\t\t\tctx->state = TLS_STATE_CERTIFICATE_EXPIRED;\n\t\t\t\t\t} else if (sec == SEC_E_WRONG_PRINCIPAL) {\n\t\t\t\t\t\tctx->state = TLS_STATE_BAD_HOSTNAME;\n\t\t\t\t\t} else if (sec == SEC_E_UNTRUSTED_ROOT) {\n\t\t\t\t\t\tctx->state = TLS_STATE_CANNOT_VERIFY_CA_CHAIN;\n\t\t\t\t\t} else if (sec == SEC_E_ILLEGAL_MESSAGE || sec == SEC_E_ALGORITHM_MISMATCH) {\n\t\t\t\t\t\tctx->state = TLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else {\n\t\t\t\t\tTLS_ASSERT(sec == SEC_E_INCOMPLETE_MESSAGE);\n\t\t\t\t\t// Need to read more bytes.\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (ctx->received == sizeof(ctx->incoming)) {\n\t\t\t\t// Server is sending too much data instead of proper handshake?\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\treturn ctx->state;\n\t\t\t}\n\t\n\t\t\t// 4. Read data from the server (recv).\n\t\t\ttls_recv(ctx);\n\t\t#endif // TLS_WINDOWS\n\n\t\t#ifdef TLS_APPLE\n\t\t\t// Nothing needed here.\n\t\t#endif // TLS_APPLE\n\n\t\t#ifdef TLS_S2N\n\t\t\t// s2n wraps a file descriptor (our socket) and performs the entire\n\t\t\t// handshake for us. Pretty nice!\n\t\t\ts2n_blocked_status blocked = S2N_NOT_BLOCKED;\n\t\t\ts2n_errno = S2N_ERR_T_OK;\n\t\t\tif (s2n_negotiate(ctx->connection, &blocked) != S2N_SUCCESS) {\n\t\t\t\ts2n_error_type etype = (s2n_error_type)s2n_error_get_type(s2n_errno);\n\t\t\t\tif (etype == S2N_ERR_T_PROTO) {\n\t\t\t\t\t// For some unknown reason s2n doesn't expose their error constants, like at all.\n\t\t\t\t\t// So to avoid finding the correct header and including it, we can at least us\n\t\t\t\t\t// string comparisons, as that's the only way s2n has exposed error codes that aren't\n\t\t\t\t\t// a nightmare to hookup, and likely won't break as they add new error types.\n\t\t\t\t\t#define TLS_S2N_ERROR_MATCHES(X) (!TLS_STRCMP(s2n_strerror_name(s2n_errno), #X))\n\t\t\t\t\tif (TLS_S2N_ERROR_MATCHES(S2N_ERR_CERT_UNTRUSTED) ||\n\t\t\t\t\t    TLS_S2N_ERROR_MATCHES(S2N_ERR_CERT_REVOKED) ||\n\t\t\t\t\t    TLS_S2N_ERROR_MATCHES(S2N_ERR_CERT_TYPE_UNSUPPORTED) ||\n\t\t\t\t\t    TLS_S2N_ERROR_MATCHES(S2N_ERR_CERT_INVALID)) {\n\t\t\t\t\t\tctx->state = TLS_STATE_BAD_CERTIFICATE;\n\t\t\t\t\t} else if (TLS_S2N_ERROR_MATCHES(S2N_ERR_CERT_EXPIRED)) {\n\t\t\t\t\t\tctx->state = TLS_STATE_CERTIFICATE_EXPIRED;\n\t\t\t\t\t} else if (TLS_S2N_ERROR_MATCHES(S2N_ERR_NO_APPLICATION_PROTOCOL)) {\n\t\t\t\t\t\tctx->state = TLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS;\n\t\t\t\t\t}\n\t\t\t\t} else if (etype == S2N_ERR_T_IO) {\n\t\t\t\t\tctx->state = TLS_STATE_INVALID_SOCKET;\n\t\t\t\t} else if (etype != S2N_ERR_T_BLOCKED) {\n\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t} else {\n\t\t\t\t\t// Continue calling s2n_negotiate...\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx->state = TLS_STATE_CONNECTED;\n\t\t\t}\n\t\t#endif // TLS_S2N\n\t} else if (ctx->state >= 0) {\n\t\t// Stall if the packet queue is full.\n\t\tif (ctx->q.count == TLS_PACKET_QUEUE_MAX_ENTRIES) {\n\t\t\t// User needs to call tls_read.\n\t\t\treturn TLS_STATE_PACKET_QUEUE_FILLED;\n\t\t}\n\n\t\t// If any ciphertext data available then try to decrypt it.\n\t\t#ifdef TLS_WINDOWS\n\t\t\t// Read data from the TCP socket.\n\t\t\ttls_recv(ctx);\n\t\t\n\t\t\tif (ctx->received != 0) {\n\t\t\t\tSecBuffer buffers[4];\n\t\t\t\tTLS_ASSERT(ctx->sizes.cBuffers == TLS_ARRAYSIZE(buffers));\n\n\t\t\t\tbuffers[0].BufferType = SECBUFFER_DATA;\n\t\t\t\tbuffers[0].pvBuffer = ctx->incoming;\n\t\t\t\tbuffers[0].cbBuffer = ctx->received;\n\t\t\t\tbuffers[1].BufferType = SECBUFFER_EMPTY;\n\t\t\t\tbuffers[2].BufferType = SECBUFFER_EMPTY;\n\t\t\t\tbuffers[3].BufferType = SECBUFFER_EMPTY;\n\n\t\t\t\tSecBufferDesc desc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(buffers), buffers };\n\n\t\t\t\tSECURITY_STATUS sec = DecryptMessage(&ctx->context, &desc, 0, NULL);\n\t\t\t\tif (sec == SEC_E_OK) {\n\t\t\t\t\t// Successfully decrypted some data.\n\t\t\t\t\tTLS_ASSERT(buffers[0].BufferType == SECBUFFER_STREAM_HEADER);\n\t\t\t\t\tTLS_ASSERT(buffers[1].BufferType == SECBUFFER_DATA);\n\t\t\t\t\tTLS_ASSERT(buffers[2].BufferType == SECBUFFER_STREAM_TRAILER);\n\n\t\t\t\t\tctx->decrypted = (char*)buffers[1].pvBuffer;\n\t\t\t\t\tctx->available = buffers[1].cbBuffer;\n\t\t\t\t\tctx->used = ctx->received - (buffers[3].BufferType == SECBUFFER_EXTRA ? buffers[3].cbBuffer : 0);\n\t\t\t\t} else if (sec == SEC_I_CONTEXT_EXPIRED) {\n\t\t\t\t\t// Server closed TLS connection (but socket is still open).\n\t\t\t\t\tctx->state = TLS_STATE_DISCONNECTED;\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else if (sec == SEC_I_RENEGOTIATE) {\n\t\t\t\t\t// Server wants to renegotiate TLS connection, not implemented here.\n\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else if (sec != SEC_E_INCOMPLETE_MESSAGE) {\n\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\treturn ctx->state;\n\t\t\t\t} else {\n\t\t\t\t\tTLS_ASSERT(sec == SEC_E_INCOMPLETE_MESSAGE);\n\t\t\t\t\t// More data needs to be read.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy out a decrypted buffer into an output packet.\n\t\t\tif (ctx->decrypted) {\n\t\t\t\tTLS_ASSERT(ctx->decrypted);\n\t\t\t\tint size = ctx->available;\n\t\t\t\tvoid* data = TLS_MALLOC(size);\n\t\t\t\tTLS_MEMCPY(data, ctx->decrypted, size);\n\n\t\t\t\t// All decrypted data is used, remove ciphertext from incoming buffer so next time it starts from beginning.\n\t\t\t\tTLS_MEMMOVE(ctx->incoming, ctx->incoming + ctx->used, ctx->received - ctx->used);\n\t\t\t\tctx->received -= ctx->used;\n\t\t\t\tctx->used = 0;\n\t\t\t\tctx->available = 0;\n\t\t\t\tctx->decrypted = NULL;\n\n\t\t\t\ttls_packet_queue_push(&ctx->q, data, size);\n\n\t\t\t\tif (ctx->state == TLS_STATE_DISCONNECTED) {\n\t\t\t\t\tctx->state = TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN;\n\t\t\t\t}\n\t\t\t}\n\t\t#endif // TLS_WINDOWS\n\n\t\t#ifdef TLS_APPLE\n\t\t\t// Nothing on Apple.\n\t\t\t// Reads are setup via chained callbacks upon connection starting.\n\t\t#endif\n\n\t\t#ifdef TLS_S2N\n\t\t\ttls_recv(ctx);\n\n\t\t\t// We don't need to do anything special for encryption (unlike SChannel)\n\t\t\t// since s2n wraps our file descriptor (socket) for us.\n\n\t\t\t// Push our incoming buffer into packet queue.\n\t\t\tif (ctx->received) {\n\t\t\t\tint size = ctx->received;\n\t\t\t\tvoid* data = TLS_MALLOC(size);\n\t\t\t\tTLS_MEMCPY(data, ctx->incoming, size);\n\t\t\t\tctx->received = 0;\n\n\t\t\t\ttls_packet_queue_push(&ctx->q, data, size);\n\n\t\t\t\tif (ctx->state == TLS_STATE_DISCONNECTED) {\n\t\t\t\t\tctx->state = TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN;\n\t\t\t\t}\n\t\t\t}\n\t\t#endif // TLS_S2N\n\t}\n\n\treturn ctx->state;\n}\n\nconst char* tls_state_string(TLS_State state)\n{\n\tswitch (state) {\n\tcase TLS_STATE_BAD_CERTIFICATE                       : return \"TLS_STATE_BAD_CERTIFICATE\";\n\tcase TLS_STATE_SERVER_ASKED_FOR_CLIENT_CERTS         : return \"TLS_STATE_SERVER_ASKED_FOR_CLIENT_CERTS\";\n\tcase TLS_STATE_CERTIFICATE_EXPIRED                   : return \"TLS_STATE_CERTIFICATE_EXPIRED\";\n\tcase TLS_STATE_BAD_HOSTNAME                          : return \"TLS_STATE_BAD_HOSTNAME\";\n\tcase TLS_STATE_CANNOT_VERIFY_CA_CHAIN                : return \"TLS_STATE_CANNOT_VERIFY_CA_CHAIN\";\n\tcase TLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS     : return \"TLS_STATE_NO_MATCHING_ENCRYPTION_ALGORITHMS\";\n\tcase TLS_STATE_INVALID_SOCKET                        : return \"TLS_STATE_INVALID_SOCKET\";\n\tcase TLS_STATE_UNKNOWN_ERROR                         : return \"TLS_STATE_UNKNOWN_ERROR\";\n\tcase TLS_STATE_DISCONNECTED                          : return \"TLS_STATE_DISCONNECTED\";\n\tcase TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN : return \"TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN\";\n\tcase TLS_STATE_PENDING                               : return \"TLS_STATE_PENDING\";\n\tcase TLS_STATE_CONNECTED                             : return \"TLS_STATE_CONNECTED\";\n\tcase TLS_STATE_PACKET_QUEUE_FILLED                   : return \"TLS_STATE_PACKET_QUEUE_FILLED\";\n\t}\n\treturn NULL;\n}\n\nvoid tls_disconnect(TLS_Connection connection)\n{\n\tTLS_Context* ctx = (TLS_Context*)connection.id;\n\n\t#ifdef _WIN32\n\t\tif (ctx->state >= 0) {\n\t\t\tDWORD type = SCHANNEL_SHUTDOWN;\n\n\t\t\tSecBuffer inbuffers[1];\n\t\t\tinbuffers[0].BufferType = SECBUFFER_TOKEN;\n\t\t\tinbuffers[0].pvBuffer = &type;\n\t\t\tinbuffers[0].cbBuffer = sizeof(type);\n\n\t\t\tSecBufferDesc indesc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(inbuffers), inbuffers };\n\t\t\tApplyControlToken(&ctx->context, &indesc);\n\n\t\t\tSecBuffer outbuffers[1];\n\t\t\toutbuffers[0].BufferType = SECBUFFER_TOKEN;\n\n\t\t\tSecBufferDesc outdesc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(outbuffers), outbuffers };\n\t\t\tDWORD flags = ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_CONFIDENTIALITY | ISC_REQ_REPLAY_DETECT | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_STREAM;\n\t\t\tif (InitializeSecurityContextA(&ctx->handle, &ctx->context, NULL, flags, 0, 0, &outdesc, 0, NULL, &outdesc, &flags, NULL) == SEC_E_OK) {\n\t\t\t\tchar* buffer = (char*)outbuffers[0].pvBuffer;\n\t\t\t\tint size = outbuffers[0].cbBuffer;\n\t\t\t\twhile (size != 0) {\n\t\t\t\t\tint d = send(ctx->sock, buffer, size, 0);\n\t\t\t\t\tbuffer += d;\n\t\t\t\t\tsize -= d;\n\t\t\t\t}\n\t\t\t\tFreeContextBuffer(outbuffers[0].pvBuffer);\n\t\t\t}\n\t\t\tshutdown(ctx->sock, SD_BOTH);\n\t\t}\n\t\tDeleteSecurityContext(&ctx->context);\n\t\tFreeCredentialsHandle(&ctx->handle);\n\t\tclosesocket(ctx->sock);\n\t#endif\n\n\t#ifdef TLS_APPLE\n\t\tdispatch_release(ctx->dispatch);\n\t\tnw_release(ctx->connection);\n\t\tpthread_mutex_destroy(&ctx->q.lock);\n\t#endif\n\n\t#ifdef TLS_S2N\n\t\t// This is supposed to be in a loop, but, we're not going to do that as\n\t\t// it's too much effort and doesn't play nicely with the API design here.\n\t\ts2n_blocked_status blocked = S2N_NOT_BLOCKED;\n\t\ts2n_shutdown(ctx->connection, &blocked);\n\n\t\ts2n_connection_free(ctx->connection);\n\t#endif\n\n\twhile (ctx->q.count) {\n\t\tvoid* packet;\n\t\tint size;\n\t\ttls_packet_queue_pop(&ctx->q, &packet, &size);\n\t\tTLS_FREE(packet);\n\t}\n\tTLS_FREE(ctx);\n}\n\nint tls_read(TLS_Connection connection, void* data, int size)\n{\n\tTLS_Context* ctx = (TLS_Context*)connection.id;\n\tif (ctx->state < 0) {\n\t\treturn -1;\n\t}\n\n\tif (!ctx->packet) {\n\t\ttls_packet_queue_pop(&ctx->q, &ctx->packet, &ctx->packet_size);\n\t}\n\n\tif (ctx->state == TLS_STATE_DISCONNECTED_BUT_PACKETS_STILL_REMAIN && ctx->q.count == 0) {\n\t\tctx->state = TLS_STATE_DISCONNECTED;\n\t}\n\n\tif (ctx->packet) {\n\t\tif (size >= ctx->packet_size) {\n\t\t\t// Copy out the entire packet.\n\t\t\tTLS_MEMCPY(data, ctx->packet, ctx->packet_size);\n\t\t\tint result = ctx->packet_size;\n\t\t\tTLS_FREE(ctx->packet);\n\t\t\tctx->packet = NULL;\n\t\t\tctx->packet_size = 0;\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Copy only a portion of the packet out, since the user buffer is small.\n\t\t\t// Shift unread bytes all the way to the front of the packet buffer.\n\t\t\tTLS_MEMCPY(data, ctx->packet, size);\n\t\t\tTLS_MEMMOVE(ctx->packet, (void*)((uintptr_t)ctx->packet + size), ctx->packet_size - size);\n\t\t\tctx->packet_size -= size;\n\t\t\tTLS_ASSERT(ctx->packet_size > 0);\n\t\t\treturn size;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint tls_send(TLS_Connection connection, const void* data, int size)\n{\n\tTLS_Context* ctx = (TLS_Context*)connection.id;\n\tif (ctx->state <= 0) return -1;\n\n\t#ifdef TLS_WINDOWS\n\t\twhile (size != 0) {\n\t\t\tint use = TLS_MIN(size, (int)ctx->sizes.cbMaximumMessage);\n\n\t\t\tchar wbuffer[TLS_MAX_PACKET_SIZE];\n\t\t\tTLS_ASSERT(ctx->sizes.cbHeader + ctx->sizes.cbMaximumMessage + ctx->sizes.cbTrailer <= sizeof(wbuffer));\n\n\t\t\tSecBuffer buffers[3];\n\t\t\tbuffers[0].BufferType = SECBUFFER_STREAM_HEADER;\n\t\t\tbuffers[0].pvBuffer = wbuffer;\n\t\t\tbuffers[0].cbBuffer = ctx->sizes.cbHeader;\n\t\t\tbuffers[1].BufferType = SECBUFFER_DATA;\n\t\t\tbuffers[1].pvBuffer = wbuffer + ctx->sizes.cbHeader;\n\t\t\tbuffers[1].cbBuffer = use;\n\t\t\tbuffers[2].BufferType = SECBUFFER_STREAM_TRAILER;\n\t\t\tbuffers[2].pvBuffer = wbuffer + ctx->sizes.cbHeader + use;\n\t\t\tbuffers[2].cbBuffer = ctx->sizes.cbTrailer;\n\n\t\t\tTLS_MEMCPY(buffers[1].pvBuffer, data, use);\n\n\t\t\tSecBufferDesc desc = { SECBUFFER_VERSION, TLS_ARRAYSIZE(buffers), buffers };\n\t\t\tSECURITY_STATUS sec = EncryptMessage(&ctx->context, 0, &desc, 0);\n\t\t\tif (sec != SEC_E_OK) {\n\t\t\t\t// This should not happen, but just in case check it.\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint total = buffers[0].cbBuffer + buffers[1].cbBuffer + buffers[2].cbBuffer;\n\t\t\tint sent = 0;\n\t\t\twhile (sent != total) {\n\t\t\t\tint d = send(ctx->sock, wbuffer + sent, total - sent, 0);\n\t\t\t\tif (d <= 0) {\n\t\t\t\t\t#ifdef _WIN32\n\t\t\t\t\t\tint error = WSAGetLastError();\n\t\t\t\t\t\tif (error != WSAEWOULDBLOCK && error != WSAEINPROGRESS) {\n\t\t\t\t\t\t\t// Error sending data to socket, or server disconnected.\n\t\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t#else\n\t\t\t\t\t\tif (errno != EAGAIN) {\n\t\t\t\t\t\t\t// Error sending data to socket, or server disconnected.\n\t\t\t\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\tsent += d;\n\t\t\t}\n\n\t\t\tdata = (const void*)((uintptr_t)data + use);\n\t\t\tsize -= use;\n\t\t}\n\t#endif // TLS_WINDOWS\n\n\t#ifdef TLS_APPLE\n\t\t// Again, so over-engineered. We just need to send a blob of bytes...\n\t\tvoid* copy = TLS_MALLOC(size);\n\t\tTLS_MEMCPY(copy, data, size);\n\t\tdispatch_data_t dispatch_data = dispatch_data_create(copy, size, ctx->dispatch, DISPATCH_DATA_DESTRUCTOR_FREE);\n\t\tnw_connection_send(ctx->connection, dispatch_data, NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT, true, ^(nw_error_t error) {\n\t\t\tif (error) {\n\t\t\t\tint code = nw_error_get_error_code(error);\n\t\t\t\t(void)code;\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t}\n\t\t});\n\t#endif // TLS_APPLE\n\n\t#ifdef TLS_S2N\n\t\ts2n_blocked_status blocked = S2N_NOT_BLOCKED;\n\t\tint bytes_written = 0;\n\t\twhile (bytes_written < size) {\n\t\t\tint w = s2n_send(ctx->connection, (const void*)((uintptr_t)data + bytes_written), size - bytes_written, &blocked);\n\t\t\tif (w >= 0) {\n\t\t\t\tbytes_written += w;\n\t\t\t} else if (s2n_error_get_type(s2n_errno) != S2N_ERR_T_BLOCKED) {\n\t\t\t\t// Error sending data to socket, or server disconnected.\n\t\t\t\tctx->state = TLS_STATE_UNKNOWN_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t#endif // TLS_S2N\n\n\treturn 0;\n}\n\n#endif // CUTE_TLS_IMPLEMENTATION_ONCE\n#endif // CUTE_TLS_IMPLEMENTATION\n\n/*\n\t------------------------------------------------------------------------------\n\tThis software is available under 2 licenses - you may choose the one you like.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE A - zlib license\n\tCopyright (c) 2023 Randy Gaul https://randygaul.github.io/\n\tThis software is provided 'as-is', without any express or implied warranty.\n\tIn no event will the authors be held liable for any damages arising from\n\tthe use of this software.\n\tPermission is granted to anyone to use this software for any purpose,\n\tincluding commercial applications, and to alter it and redistribute it\n\tfreely, subject to the following restrictions:\n\t  1. The origin of this software must not be misrepresented; you must not\n\t     claim that you wrote the original software. If you use this software\n\t     in a product, an acknowledgment in the product documentation would be\n\t     appreciated but is not required.\n\t  2. Altered source versions must be plainly marked as such, and must not\n\t     be misrepresented as being the original software.\n\t  3. This notice may not be removed or altered from any source distribution.\n\t------------------------------------------------------------------------------\n\tALTERNATIVE B - Public Domain (www.unlicense.org)\n\tThis is free and unencumbered software released into the public domain.\n\tAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\n\tsoftware, either in source code form or as a compiled binary, for any purpose,\n\tcommercial or non-commercial, and by any means.\n\tIn jurisdictions that recognize copyright laws, the author or authors of this\n\tsoftware dedicate any and all copyright interest in the software to the public\n\tdomain. We make this dedication for the benefit of the public at large and to\n\tthe detriment of our heirs and successors. We intend this dedication to be an\n\tovert act of relinquishment in perpetuity of all present and future rights to\n\tthis software under copyright law.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n\tACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "examples_cute_gl_and_c2",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_gl_and_tiled_and_spritebatch",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_net",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_png",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_sound",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_spritebatch",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_cute_tls",
          "type": "tree",
          "content": null
        },
        {
          "name": "player2d",
          "type": "commit",
          "content": null
        },
        {
          "name": "test_cute_math",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_cute_tiled",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}