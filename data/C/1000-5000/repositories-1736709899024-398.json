{
  "metadata": {
    "timestamp": 1736709899024,
    "page": 398,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "RamonUnch/AltSnap",
      "stars": 2655,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0751953125,
          "content": "*.dni text linguist-language=ini working-tree-encoding=utf-16le-bom eol=crlf\n"
        },
        {
          "name": "AltSnap.dni",
          "type": "blob",
          "size": 53.0859375,
          "content": "ï»¿; Disable and enable AltSnap to refresh configuration.\r\n; Created for AltSnap v1.64\r\n; If this file is present named AltSnap.ini next to AltSnap.exe,\r\n; then it will picked (portable mode). Otherwise AltSnap will look\r\n; in \"%APPDATA%\\AltSnap\\AltSnap.ini\" (per-user config).\r\n; If no ini file is present in the user folder,\r\n; AltSnap Will copy \"<exefolder>\\AltSnap.dni\" --> \"<userfolder>\\AltSnap.ini\"\r\n\r\n[General]\r\n\r\nLanguage=Auto\r\n; Available languages: en-US (English), fr-FR (French), pl-PL (Polish) etc...\r\n; Default is Auto for automatic selection based on local.\r\n; Please help with translations if you can.\r\n\r\nTheme=\r\n; Set desired icon theme. If set empty default icons are loaded.\r\n; You can already try Theme=erasmion, You can make your own themes esealy\r\n; You just need to create a floder in the Themes folder with 3 icons for\r\n; the tray: TRAY_OFF.ico, TRAY_ON.ico TRAY_SUS.ico\r\n; to load a theme specify the name of the floder.\r\n; Note: a full AltSnap restart is required to update the theme!\r\n\r\nAutoFocus=0\r\n; Automatically raises and focuses the windows you drag.\r\n\r\nAero=1\r\n; Mimics Windows 7+ Aero Snap behavior.\r\n; Drag windows to the left, right, top, or bottom side of the monitor.\r\n; Corners work too! Hold Ctrl to trap the mouse cursor within the current\r\n; monitor for easier snapping when using multiple monitors.\r\n\r\nSmartAero=1\r\n; If set to 1 (default), AltSnap will adjust the dimensions of\r\n; a snapped window to other resized snapped windows.\r\n; If set to 0, disabled, restores the old AltDrag behavior.\r\n; If 2 is added, AltSnap will be smarter and snap to more windows.\r\n; If 4 is added, AltSnapped windows will never be restored.\r\n\r\nStickyResize=0\r\n; If set to 1 or 3, other windows that are snapped to the current one\r\n; can be resized by holding the Shift key.\r\n; If set to 2, The above is done without the Shift key (Shift will disable it instead).\r\n; If set to 0, sticky resizing is disabled.\r\n\r\nMMMaximize=1\r\n; Set the way MouseMove can maximize default is 1.\r\n; If set to 1, to use resize/move combo (default).\r\n; If set to 2, restores a window on a single left click instead of a drag.\r\n; If set to 3, does both of the above (like the original AltDrag).\r\n; If set to 0, disabled, does none of the above.\r\n\r\nAeroHoffset=50\r\nAeroVoffset=50\r\n; Horizontal and vertical position (from top left in percent) where the aero\r\n; windows will meet default is 50 50, at the center of the monitor.\r\n; If you set AeroHoffset=33, for example, the windows snapped\r\n; on the left will use only 33% of the monitor width, those on the right will\r\n; have the remaining 67%. I strongly advise you to play around with this if\r\n; you use Aero snapping...\r\n\r\nInactiveScroll=0\r\n; Adds the ability to scroll inactive windows. Hold shift to scroll horizontally.\r\n; DO NOT USE under Windows 10/11, it is reserved for Win 8 and previous.\r\n\r\nAutoSnap=2\r\n; Makes a window automatically snap to other windows, without the need to press shift.\r\n; List of settings:\r\n; 0: Disabled.\r\n; 1: Automatically snaps to the screen borders and the taskbar.\r\n; 2: Also automatically snaps to the outside of windows.\r\n; 3: Also automatically snaps to the inside of windows.\r\n\r\nMDI=1\r\n; Enables support for MDI windows (Multiple Document Interface), e.g. mIRC.\r\n; A blacklist can be set to prevent this behavior on some windows (see below)\r\n\r\nResizeCenter=1\r\n; 0: Bottom right mode will be used at the center.\r\n; 1: Enables the center \"All directions\" mode for resizing (default).\r\n; 2: The windows will be moved instead.\r\n; 3: The closest side mode will be used at the center.\r\n\r\nCenterFraction=24\r\n; A fraction in a percent from 0 to 100 that defines the size of the central\r\n; resizing region (default is 24), used to be 33% in AltDrag beta.\r\n\r\nSidesFraction=24\r\n; A fraction in a percent from 0 to 100 that defines the size of the side\r\n; resizing regions (default is 100) any value greater than CenterFraction\r\n; will have the same effect than SidesFraction == CenterFraction.\r\n\r\nMoveTrans=255\r\n; Transparency from 1-254, which is set to the window that is currently\r\n; moved/resized. Lower values are more transparent.\r\n; If set to 0 or 255, the feature is disabled (default is 255).\r\n\r\n[Input]\r\n\r\nUniKeyHoldMenu=0\r\n; If enabled, then a long key press will popup a menu with a list of\r\n; extended/unicode characters that can be typed.\r\n\r\nLMB=Move\r\nRMB=Resize\r\nMB4=Nothing\r\nMB5=Nothing\r\nScroll=Transparency\r\nHScroll=Nothing\r\n; Mouse actions for Left, Middle, and Right mouse buttons (MB), MB4,5 and wheel.\r\n; List: Nothing, Move, Resize, Menu, Minimize, Maximize\r\n; Center, AlwaysOnTop, Close, Lower, Borderless\r\n; Kill, Pause, Resume, MaximizeHV, MinAllOther, Mute, SideSnap,\r\n; NStacked, NStacked2, PStacked, PStacked2, StackList, StackList2, ASOnOff, MoveOnOff\r\n; MLZone, MTZone, MRZone, MBZone XLZone, XTZone, XRZone, XBZone\r\n; Wheel actions : Roll, AltTab, Volume, Transparency, HScroll\r\n; Zoom, Zoom2, NPStacked, NPStacked2\r\n; When moving and resizing windows, hold shift to snap to other windows.\r\n; For Volume, Transparency and Zoom, try holding shift to adjust the speed.\r\n\r\nLMBB=Nothing\r\nMMBB=AltTabList\r\nRMBB=Nothing\r\nMB4B=Nothing\r\nMB5B=Nothing\r\nScrollB=Volume\r\nHScrollB=Nothing\r\n; Alternative action for each button (used when the ModKey is pressed).\r\n\r\nLMBT=Nothing\r\nMMBT=Lower\r\nRMBT=Nothing\r\nMB4T=Nothing\r\nMB5T=Nothing\r\nScrollT=Roll\r\nHScrollT=Nothing\r\n; Actions to be performed in the titlebar,\r\n; with or without Alt, see TTBActions.\r\nLMBTB=Nothing\r\nMMBTB=Nothing\r\nRMBTB=Nothing\r\nMB4TB=Nothing\r\nMB5TB=Nothing\r\nScrollTB=Nothing\r\nHScrollTB=Nothing\r\n; Alternate titlebar actions (.ini only)\r\n\r\nLMBM=Nothing\r\nLMBR=SideSnap\r\nMMBM=Nothing\r\nMMBR=ExtendTNEdge\r\nRMBM=Nothing\r\nRMBR=Nothing\r\nMB4M=Nothing\r\nMB4R=Nothing\r\nMB5M=Nothing\r\nMB5R=Nothing\r\nScrollM=NPStacked2\r\nScrollR=Zoom\r\nHScrollM=Nothing\r\nHScrollR=Nothing\r\n; Actions to do when we are already Moving(M)/Resizing(R)\r\n\r\nGrabWithAlt=Nothing\r\nGrabWithAltB=Nothing\r\n; Substitute Nothing with a hotkey, so you can perform the action\r\n; without needing to click. This is useful for touchpads.\r\n; Try with GrabWithAlt=Resize and set ResizeCenter=2 and CenterFraction=60\r\n\r\nMoveUp=Nothing\r\nMoveUpT=Nothing\r\nResizeUp=Nothing\r\nResizeUpT=Nothing\r\nMoveUpB=Nothing\r\nResizeUpB=Nothing\r\n; Actions that will be performed on the click UP even of a Move/Resize\r\n; IF no drag occured AND the click was long or PiercingClick=1.\r\n; The B sufixed version apply if the ModKey is down, as usual.\r\n; /!\\ Those actions are not associated with buttons but with Move/Resize.\r\n\r\nTTBActions=0\r\n; Perform specific actions when clicking in the titlebar\r\n; If set to 1, to perform the action without Alt\r\n; If set to 2, to perform the action with Alt.\r\n; If set to 3, does both of the above.\r\n\r\nScrollLockState=0\r\n; If set to 1, AltSnap will be disabled when Scroll Lock is OFF.\r\n; If set to 3, AltSnap will be disabled when Scroll Lock is ON.\r\n\r\nHScrollKey=10\r\n; List of keys used to transform a vertical scroll into a Horizontal scroll,\r\n; applies only when the InactiveScroll option is used (Old windows versions).\r\n; Default value is 10 ie VK_SHIFT.\r\n\r\nHotkeys=A4 A5\r\n; Space-separated hexadecimal values.\r\n; Quick reminder:\r\n; A4 A5 => Left (A4) and right (A5) ALT\r\n; 5B 5C => Left (5B) and right (5C) WIN\r\n; A0 A1 => Left (A0) and right (A1) SHIFT\r\n; A2 A3 => Left (A2) and right (A3) CTRL\r\n; 70 to 87 => F1 to F24 keys\r\n; Values at: https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes\r\n; You can specify up to 7 keys.\r\n\r\n; Modifier keys to use the B action of each button.\r\n\r\nKillkeys=09 2E\r\n; Keys that will disable AltSnap when pressed down!\r\n; Space-separated hexadecimal values.\r\n; All keys from A-Z always disable AltSnap, so do not add them here.\r\n; Default is TAB: 09 (for DisplayFusion's Alt+Tab).\r\n; 2E for the DEL key (for Ctrl+Alt+DEL).\r\n\r\nShiftkeys=A0 A1\r\n; Key that is used to snap windows and modify actions\r\n; defaut sis A0 A1 for left and right shift.\r\n\r\nEndSendKey=11\r\n; Key sent at the end of a movement to avoid menu selecting because of Alt\r\n; or to avoid poping up the Windows menu when using WinKey as a hotkey.\r\n; Since the original AltDrag the default value is 11 (VK_CONTROL).\r\n; You can try sending other keys or set to 00 to disable key sending.\r\n; You can try WinKey(5C) if you use Alt(12) as a hotkey or vice-versa.\r\n; You can try using some of the undefined VK-codes such as 0E or FF.\r\n; AHK recomends using FF.\r\n\r\nHotclicks=\r\n; Mouse clicks that can be used to trigger AltSnap.\r\n; This can be used together with the Hotkeys or as a replacement.\r\n; Space-separated hexadecimal values.\r\n; Values: MMB=04, MB4=05, MB5=06, MB6=07, MB7=08, MB8=09, MB9=0A,\r\n; MB10=0B, MB11=0C, MB12=0D, MB13=0E, MB14=0F, MB15=10,\r\n; MB16=11, MB17=12\r\n; Just do not try this with LMB and RMB, please....\r\n; For example, I would suggest using MB4 and MB5 ie: Hotclicks=05 06\r\n; And using MB4=Move and MB5=Resize.\r\n; To use MB6-MB9 see the XXButtons section.\r\nXXButtons=\r\n; List of keys that are actually mapped to extra mouse button (6-17)\r\n; You can specify up to 15 values in the button order you prefer.\r\n; Any key specified here will behave like a mouse button for AltSnap.\r\n; Also the key will ALWAYS be unusable outside of AltSnap\r\n; This is intended for mouse buttons that that are mapped by a\r\n; driver to keyboard keys, If possible use keys that does not exist\r\n; on your keyboard ie: F13-F24.\r\n; The extra buttons defined like this are mapped to MB6/7/8/9(B)(T)\r\n; If you set for example XXButtons=7C 7D 7E 7F, then:\r\n; the F13 key will be mapped to MB6, F14 to MB7 etc.\r\n; MB20 is the maximum button. Those buttons can be added to the Hotclicks\r\n\r\nKeyCombo=0\r\n; If set to 1, you will actually need to press two hotkeys\r\n; to enable AltSnap (any combination of two hotkeys).\r\n; You need at least TWO hotkeys!\r\n; Does not apply to Hotclicks!\r\n\r\nLongClickMove=0\r\n; Turns a long click in a move.\r\n; This is a way to use AltSnap without keyboard.\r\n; Set to 0 to disable (default)\r\n; Set to 1 to enable and long click delay will be double click delay.\r\n\r\nFrameColor=80 00 88\r\n; Hexadecimal color of the hollow rectangle that is used when you disabled\r\n; the FullWin option/Show window content while dragging.\r\n; You need to put spaces between each pair of characters (RR GG BB)\r\n; eg: 00 00 00 for black, FF 00 00 for red, 80 00 80 dark violet...\r\n\r\nPinColor=FF FF 00 54\r\n; Like FrameColor but concerns the color of the always on top indicator\r\n; The last byte represents the hex ASCII of the letter to be drawn.\r\n; Default is FF FF 00 54 for Yellow with a T (54).\r\n\r\n;Shrt0=B0.2\r\n;Shrt1=B1.2\r\n;Shrt2=FF.2 12.u A2.d 57.2 A2.u\r\n; Shortcuts number X=0-9 and A-Y\r\n; you can specify an arbitrary vKey sequence with up and down events.\r\n; ie: \"A2.d A2.u\" =>  sends A2 Down and then Up A2.2 for both Down+Up\r\n; Most shortcuts will have to start with \"FF.2 12.u\" to release Alt(12)\r\n; without trigerring the menu. Use \"FF.2 5B.u\" to release LeftWin.\r\n\r\nModKey=\r\nMMB=Menu\r\n; Ctrl+W\r\n;\r\n[Blacklist]\r\n; For all blacklists, items must be separated with a comma (no space before the coma).\r\n; Spaces can be present in the item itself. eg: \"Virtual PC.exe\"\r\n; Unicode is fully supported for blacklist items in Windows 2000+\r\n; blacklist format consists in, exename:title|class each field is optional.\r\n; exename, == exename:*|*,\r\n; title|class, == *:title|class,\r\n\r\nProcesses=StartMenuExperienceHost.exe,SearchApp.exe,mstsc.exe,msrdc.exe,osk.exe,Virtual PC.exe,LeageClient.exe,LeageClientUx.exe,LeageClientUxRender.exe\r\n; List of processes (comma separated) that AltSnap will not interfere with\r\n\r\nWindows=Program Manager|Progman,*|MultitaskingViewFrame,Volume Control|Tray Volume,*|TaskSwitcherWnd,*|TaskSwitcherOverlayWnd,|WorkerW,|Shell_TrayWnd,|BaseBar,|#32768,*|XamlExplorerHostIslandWindow,|MozillaDropShadowWindowClass,*|VistaSwitcher_SwitcherWnd,|TaskListThumbnailWnd,|NotifyIconOverflowWindow,*|Windows.UI.Core.CoreWindow,|NativeHWNDHost,*|Xaml_WindowedPopupClass,|Shell_SecondaryTrayWnd,*|SimpleWindowSwitcher_{BEA057BB-66C7-4758-A610-FAE6013E9F98},yui.exe:Yui|YuiWnd\r\n; List of windows for which AltSnap is completely disabled\r\n\r\nScroll=\r\n; List of windows that should just ignore the scroll action\r\n; eg: *|Photoshop\r\n\r\nIScroll=*|ApplicationFrameWindow\r\n; List of windows on which the scroll inactive window option will not apply.\r\n\r\nMDIs=*|PPTFrameClass,*|MMCMainFrame,*|classFoxitReader\r\n; List of windows for which AltSnap ignores MDI option\r\n; Default is Powerpoint, Microsoft Management Console and Foxit.\r\n\r\nPause=taskmgr.exe,explorer.exe,dwm.exe,Virtual PC.exe,AltSnap.exe\r\n; List of processes that will not be paused or killed\r\n; when using the Pause/resume and Kill keyboard actions.\r\n\r\nSnaplist=*|BaseWindow_RootWnd,*|SkinWnd,*|ChatSkinWnd,*|SpotifyMainWindow,*|USurface_*,*|Winamp*,*|M4W_MainWindow,*|SunAwtDialog\r\n; List of windows that should be snapped to, even though they have no caption.\r\n; Use Snaplist=*|* if you want to enable snapping to all border-less windows.\r\n\r\nMMBLower=*|CASCADIA_HOSTING_WINDOW_CLASS,*|MozillaDialogClass\r\n; List of windows for which the Titlebar action should not be performed.\r\n; default is MS-WindowTerminal and some popup windows of Firefox.\r\n\r\n; For Windows, Snaplist and MDIs:\r\n; Three options are offered to you in this case:\r\n; 1) Set the whole title|class windows info.\r\n; 2) Set all windows from this class with ,*|class.\r\n; 3) Set the window title only with ,title|*.\r\n; Use the \"Identify window\" option in AltSnap Config.\r\n\r\nAResize=*|SunAwtDialog\r\n; List of windows that AltSnap should consider as resizeable\r\n; Only applies when ResizeAll=0\r\n; eg: *|SunAwtDialog for MATLAB's help.\r\n\r\nNResize=\r\n; List of windows that AltSnap should Never consider as resizeable\r\n; Only applies when ResizeAll=0\r\n\r\nSSizeMove=*|iTunes\r\n; List of windows to which the WM_ENTERSIZEMOVE / WM_EXITSIZEMOVE will not\r\n; be sent. Keep the default value unless you know what you are doing.\r\n\r\nNCHittest=*|ApplicationFrameWindow\r\n; List of windows for which AltSnap should try directly to question the\r\n; ancestor window for the Hittest, in order to know where the title bar is.\r\n; Default is *|ApplicationFrameWindow for all METRO apps on Win10+\r\n\r\nBottommost=*|RainmeterMeterWindow\r\n; List of windows that should be kept below other Windows that are lowered\r\n; by AltSnap. Default is *|RainmeterMeterWindow for Rainmaker skin windows.\r\n\r\n[Advanced]\r\n\r\n;; MENU OPTIONS ;;\r\nMenuShowEmptyLabelWin=0\r\n; If set to 1, actions that show lists of windows (StackList, AltTabList, etc.)\r\n; will include windows with empty titles.\r\n\r\nMenuShowOffscreenWin=0\r\n; If set to 1, both AltTabList and AltTabFullList will include windows\r\n; that are off-screen.\r\n\r\nAblockHotclick=0\r\n; Set to 1 to Always block hotclicks, Otherwise AltSnap trys\r\n; to forward the click if no action was performed.\r\nNumberMenuItems=0\r\n; Use numbers instead of a-z for shortcuts in windows list menu.\r\n\r\nMaxMenuWidth=80\r\n; Maximum line width in characters allowed in a windows list menu.\r\n; From 0-255, use 0 for unlimited. Default 80 (like old AltSanp versions)\r\n\r\n;; METRICS ;;\r\nLongClickMoveDelay=0\r\n; Delay in ms before considering a click to be long for the LongClickMove\r\n; option. Default is 0 to use the double click delay.\r\n\r\nDragThreshold=1\r\n; Require a small drag before actually starting a movement.\r\n; Set to 0 to disable (like for AtSnap 1.58 and below)\r\n; Set to 1 to have a drag threshold for maximized/snapped windows only (default).\r\n; Set to 2 to always have a drag threshold.\r\n; Set to 3 to have a drag threshold also when resizing the window.\r\n\r\nSnapThreshold=20\r\n; The distance, in number of pixels, when snapping starts (default 20).\r\n\r\nAeroThreshold=5\r\n; Distance in pixels, when Aero snapping to monitor sides (default 5).\r\n\r\nSnapGap=0\r\n; Gap in pixels from -128 to +127 between two snapped windows.\r\n; Use negative values if you want an overlap, default is 0\r\n; I suggest -1 under Win10.\r\n\r\nKBMoveStep=100\r\nKBMoveSStep=20\r\n; Value in pixels from 1-255.\r\n; To change the steps in pixels\r\n; when moving windows with the keyboard\r\n\r\nAeroMaxSpeed=65535\r\nAeroSpeedTau=64\r\n; Speed beyond which AeroSnaps will not occur while Moving.\r\n; AeroMaxSpeed is in pixels/Tau (from 0-65535).\r\n; AeroSpeedTau to specifies Tau time in milliseconds (default 64).\r\n; (i) Set AeroMaxSpeed to a \"high\" value (like 100) and try to move fast\r\n; a window between two monitors, if it gets aero-snapped, decrease the value\r\n; until it no longer snaps, and check that the window still snaps when you\r\n; want it to.\r\n\r\nMinAlpha=32\r\n; Minimum alpha for the transparency action, from 1-255 (default 32).\r\nAlphaDelta=64\r\nAlphaDeltaShift=8\r\n; Alpha step for the transparency action, from -128 to +127 (default 64).\r\n; The other value is applied when Shift is pressed (default 8).\r\n\r\nZoomFrac=16\r\nZoomFracShift=64\r\n; By which fraction (2-255) the Zoom action should increase/decrease the size\r\n; of the pointed window. ZoomFrac is without shift and ZoomFracShift\r\n; is with shift. Default is 16th/64th (ZoomFrac=16, ZoomFracShift=64).\r\n; Formula: New Window Size = OldSize + OldSize/ZoomFrac\r\n\r\n;; BEHAVIOR ;;\r\nTopmostIndicator=1\r\n; Show an indicator on the always on top windows\r\n\r\nAutoRemaximize=0\r\n; Automatically re-maximize windows when you move them between monitors.\r\n\r\nMultipleInstances=0\r\n; If set to 1, allows running multiple instances of AltSnap.\r\n\r\nAlwaysElevate=0\r\n; If set to 1, AltSnap will always request elevation.\r\n\r\nResizeAll=1\r\n; If set to 1, all windows are resizable, even those without borders.\r\n; Note that windows that are in the AResize list will still be resizable.\r\n; Also windows that were made borderless by AltSnap will be resizable.\r\n\r\nFullScreen=0\r\n; If set to 1, all fullscreen windows are moveable.\r\n; If set to 0, blacklists all fullscreen windows.\r\n; A fullscreen window is set to your monitor size and has no title bar.\r\n; It is not exactly the same than a Maximized window (see below)\r\n\r\nBLMaximized=0\r\n; Set to 1 to disable AltSnap on all Maximized windows.\r\n; If set to 0 (default) maximized windows will be restored by AltSnap.\r\n; Not the same thing than \"fullscreen\" window but looks quite similar.\r\n\r\nAeroTopMaximizes=1\r\n; If set to 1, windows get maximized when snapped at the top\r\n; of the monitor instead of being resized to fill its top half.\r\n; If set to 2, Shift behavior will be inverted for double-right-click:\r\n; Aero Snap <-> Extend border to monitor.\r\n; If set to 3, both of the above work.\r\n; You can always hold Shift to invert the behavior.\r\n\r\nUseCursor=1\r\n; If set to 0, disables any cursor handling (not recommended).\r\n; If set to 1, enables all cursor sets (default)\r\n; If set to 2, disables the Hand cursor when moving\r\n; If set to 3, normal cursor is always used, even when resizing.\r\n; If set to 4, uses the ResizeAll cursor for movement instead of the Hand.\r\n\r\nShiftSnaps=1\r\n; Set to 0 if you do not want border-to-border windows snapping to be\r\n; Enabled by the shift key (default is 1: enabled).\r\n\r\nPiercingClick=0\r\n; Set to 1 to enable, in this case, if you press Alt+Click without moving,\r\n; the click will be transmitted to the pointed program.\r\n; Enabling this option will disable doubleclicking actions!\r\n; If you keep it disabled (default) you still will have the click\r\n; transmission if you hold the click down more than a double click delay.\r\n\r\nDragSendsAltCtrl=0\r\n; If set to 1, then Alt_Down, Ctrl_Down, Ctrl_Up, Alt_Up will be sent.\r\n; at the begining of a move/resize action, unless Alt is already down.\r\n; This can help to pop down context menu when the drag starts.\r\n\r\nIgnoreMinMaxInfo=0\r\n; Set to 0 to take into account the MinMax Info (default, recommended)\r\n; Set to 1 if you want to ignore the minimum window size\r\n; set to 2 if you want to ignore the maximum window size\r\n; set to 3 to completely ignore Min/Max info\r\n\r\nNotifyWinEvent=1\r\n; Determines if AltSnap should send the EVENT_SYSTEM_MOVESIZESTART/END\r\n; events when moving a window. This is useful when interacting with\r\n; some other accessibility tools (default 1).\r\n\r\nBLCapButtons=3\r\n; Mouse Buttons for which the caption buttons will not be considered\r\n; by AltSnap for the Titlebar action.\r\n; Use 0 to include all mouse buttons.\r\n; Use 1 to exclude the left mouse button only.\r\n; Use 3 (1+2) to exclude the left and right mouse buttons (default).\r\n; Use -1 to exclude all mouse buttons and wheel.\r\n; You can specify any value in decimal converted from a bit mask in the order\r\n; of mouse buttons ie: LMB RMB MMB MB4 MB5...MB20 VWHEEL HWHEEL.\r\n; use BLCapButtons=0 if you always want titlebar actions to be applied\r\n; when clicking caption buttons and use -1 if you never want this.\r\n; For a custom value add the numbers corresponding to each mouse button:\r\n; LMB: 1, RMB: 2, MMB: 4, MB4: 8 MB5: 16 MBX: 2^(X-2)\r\n; VWheel: 1048576, HWheel: 2097152 (buttons 21 and 22)\r\nBLUpperBorder=3\r\n; Same than BLCapButtons except that it concerns the top resizing borders\r\n; instead of only the caption buttons. Default value is 3.\r\n\r\nACMenuItems=-1\r\n; Menu items that will be displayed in the action menu (bit-mask).\r\n; Default is -1 for all menu items.\r\n; If you want only a selection of the menu items, pick them up in the list\r\n; below, sum up the associated numbers and assign the value to `ACMenuItems`\r\n; 1      Toggle Always on top\r\n; 2      Toggle Borderless\r\n; 4      Center window on screen\r\n; 8      Roll/Unroll window\r\n; 16     Lower Window\r\n; 32     Maximize vertically\r\n; 64     Minimize other windows\r\n; 128    Snap To side/corner\r\n; 256    ------------------\r\n; 512    Maximize window\r\n; 1024   Minimize window\r\n; 2048   Close window\r\n; 4096   ----------------\r\n; 8192   Kill program\r\n; 16384  -----------------\r\n; 32768  Movement disabled\r\n; 65536  -----------------\r\n; 131072 Send original click\r\n; 262144 Nothing\r\n; Example: 131072+1+2+8=131083 Nothing+Topmost+Borderless+Roll\r\n\r\nMaxKeysNum=0\r\n; Maximum number of keys that can be pressed on the keyboard\r\n; at the same time beyond which AltSnap click will no longer activate.\r\n; It will not interupt AltSnap if it is already in the middle of an action.\r\n; Default is 0 (unlimited).\r\n\r\n[Performance]\r\n;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;;\r\n;; Formula for best perf:\r\n;; 1) If you got a monitor to 60Hz set RezTimer=1 (or 2, should be default).\r\n;; 2) If you got a high frequency monitor and a high freq mouse:\r\n;;   a. Set RezTimer=3 or 4,\r\n;;   b. Calculate the ratio Mouse frequency / Monitor frequency and take\r\n;;      half that value as a starting point for MoveRate and ResizeRate.\r\n;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;; ;;\r\nFullWin=2\r\n; Set to 1 to force the Drag Full Windows option (old default)\r\n; Set to 0 to force off\r\n; Default is 2: autodetect based on Windows setting\r\n\r\nTransWinOpacity=0\r\n; Set opacity from 1-255 of the transparent window used when FullWin=0\r\n; default is 0 which mean no transparency is used (best for performance).\r\n; also 255 has good performance but there is zero opacity.\r\n; If you are using desktop composition or Windows 8+ then there will be\r\n; no significant performance impact to any value.\r\n\r\nPinRate=32\r\n; Rate in miliseconds from 1-255 at which the always on top indicator\r\n; will be refreshed. Default is 32. Smaller values will make the\r\n; indicator more reactive but will decrease the performances.\r\n\r\nRezTimer=2\r\n; Set to 1 to move the window only when the timestamp of\r\n; a mouse event is different from the previous one, every 16ms\r\n; more or less. MoveRate and ResizeRate and RefreshRate\r\n; will have no effect if the option is enabled.\r\n; This is overall the option that gives the best performances.\r\n; It can be combined with FullWin=0 mode for ~0% CPU usage.\r\n; Set to 2 for auto-mode, where RezTimer is only enabled if\r\n; display frequency is set to 60Hz.\r\n; Set to 3 to combine with the MoveRate and ResizeRate options\r\n; Set to 4 for auto-mode bis (1 if 60Hz monitor and 3 otherwise).\r\n\r\nRefreshRate=0\r\n; Minimum delay, in milliseconds, between two refreshes of a window.\r\n; For minimum CPU usage use a value around your monitor's rate:\r\n; 75Hz monitor => RefreshRate=13\r\n; Max value is 255 (4 Hz), sane values are below 100 (10 Hz).\r\n; If set to 0 (default), you get the most reactivity.\r\n\r\nMoveRate=2\r\nResizeRate=4\r\n; The number of pixels to wait before actually moving the window.\r\n; If set to 1, updates will be instant. You will have better perf with\r\n; higher values but you will lose precision in moving/resizing.\r\n; Sane values are below 10. Recommended is 1 to 5\r\n\r\n[Zones]\r\nUseZones=0\r\n; If set to 1, enables Snap Layouts (Zones)\r\n; If set to 3, enables Grid mode (configure below)\r\n; If 4 is added window is extended without Ctrl.\r\n; If 8 is added snapping will occur without Shift ie: 1+8 => UseZones=9.\r\n; Shift will disable Zones instead.\r\n; recomended is UseZones=1 or 9 for normal snap Layout with or w/o shift\r\n; and 3+4 => UseZones=7 for grid mode.\r\n\r\nZSnapMode=1\r\n; Zone snapping strategy\r\n; Set to 0 to snap to the zones pointed by the cursor (default).\r\n; Set to 1 to snap to the zone which center is the nearest from the cursor\r\n; There is always the InterZone tolerance to snap to several zones.\r\n\r\nInterZone=32\r\n; Size in pixels between zones from -128 to +127 (default 32)\r\n; where the window will be snapped to the union of zones.\r\n; If set to 0, you cannot cover more than one zone.\r\n\r\nShowZonesPrevw=1\r\n; Enable/Disables Layout preview (default 1)\r\n\r\nZonesPrevwOpacity=128\r\n; Opacity from 0-255 of the Zone preview (default 160).\r\n; Use 0 if you disabled Desktop composition.\r\n\r\nZonesPrevwBGCol=FF FF FF\r\nZonesPrevwBDCol=00 00 00\r\n; Color of the Snap Layout preview, ZonesPrevwBGCol for background color\r\n; and ZonesPrevwBDCol for the border color. default are white and black.\r\n; Use a dark beckground and a light border if you use dark theme.\r\n\r\nMaxLayouts=4\r\n; Maximum number of layouts that you can switch btween\r\n; Set to 0 or 1 if you want a single layout, 10 max.\r\nLayoutNumber=0\r\n; Currently selected layout (from 0 to MaxLayouts-1)\r\n\r\n; If you set UseZones to 3 or 7 then you enabled the\r\n; GRID MODE that simply cuts each screen into 'parts'.\r\n; You can set the number of parts below:\r\nGridNx=3\r\n; Number of grid columns\r\nGridNy=2\r\n; Number of grid lines\r\nGridNx1=4\r\nGridNy1=3\r\nGridNx2=2\r\nGridNy2=2\r\n\r\nFancyZone=0\r\n; If set to 1, enables better FancyZones integration (x64 builds only!).\r\n; Windows snapped by FancyZones will be restored by AltDrag.\r\n; Set to 2 if you do not want AltSnap to rescale\r\n; the window to the current dpi setting.\r\n\r\nZone0=\r\nZone1=\r\nZone2=\r\nZone3=\r\nZone4=\r\n\r\n; List of zones coordinates LEFT,TOP,RIGHT,BOTTOM,\r\n; Up to 2048 zones and all zones end with a comma\r\n; You can use the \"Identify Window\" option to get the RECT of any window\r\n; You can save a \"Snap Layout\" from test windows using the tray menu\r\n; This is the preferred way to configure your snap layout.\r\n\r\n\r\n[KBShortcuts]\r\nUsePtWindow=0\r\nMenu=0\r\nLower=0\r\nKill=0\r\n\r\n; Set UsePtWindow=1 if you want the pointed window to be used\r\n; instead of the foreground window.\r\n;\r\n; Formula: add the folowing:\r\n; One VK_NUMBER (decimal)\r\n; +256  Alt\r\n; +512  Control\r\n; +1024 Shift\r\n; +2048 Winkey\r\n;\r\n; 883  => Ctrl+Alt+F4\r\n; 2644 => Ctrl+Win+T\r\n; 2336 => Alt+Win+SPACE\r\n"
        },
        {
          "name": "AltSnap.exe.manifest",
          "type": "blob",
          "size": 1.4091796875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\" xmlns:v3=\"urn:schemas-microsoft-com:asm.v3\">\n<assemblyIdentity version=\"1.0.0.0\" processorArchitecture=\"*\" name=\"XP style\" type=\"win32\" />\n\n<v3:trustInfo><v3:security>\n  <v3:requestedPrivileges><v3:requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\" /></v3:requestedPrivileges>\n</v3:security></v3:trustInfo>\n\n<dependency>\n  <dependentAssembly>\n    <assemblyIdentity type=\"win32\"\n      name=\"Microsoft.Windows.Common-Controls\" version=\"6.0.0.0\"\n      processorArchitecture=\"*\" publicKeyToken=\"6595b64144ccf1df\"\n      language=\"*\" />\n  </dependentAssembly>\n</dependency>\n<v3:application>\n  <v3:windowsSettings>\n    <dpiAware xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\">true</dpiAware>\n    <dpiAwareness xmlns=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">PerMonitorV2,PerMonitor</dpiAwareness>\n  </v3:windowsSettings>\n</v3:application>\n<compatibility xmlns=\"urn:schemas-microsoft-com:compatibility.v1\">\n  <application>\n    <supportedOS Id=\"{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}\"/>\n    <supportedOS Id=\"{1f676c76-80e1-4239-95bb-83d0f6d0da78}\"/>\n    <supportedOS Id=\"{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}\"/>\n    <supportedOS Id=\"{35138b9a-5d96-4fbd-8e2d-a2440225f93a}\"/>\n    <supportedOS Id=\"{e2011457-1546-43c5-a5fe-008deee3d3f0}\"/>\n  </application>\n</compatibility>\n\n</assembly>\n"
        },
        {
          "name": "AltSnap.txt",
          "type": "blob",
          "size": 82.4609375,
          "content": "*=========================================================================*\r\n*            ALTSNAP for Windows NT4/2000/XP/Vista/7/8.x/10/11            *\r\n*  Modified by Raymond Gillibert from original AltDrag by Stefan Sundin   *\r\n*                       release 1.64 (June XX, 2024)                      *\r\n*-------------------------------------------------------------------------*\r\n* Download MEGA: https://mega.nz/folder/mW5ExCCT#gI8DQICICk-y4FIjxaqtGg   *\r\n* Download GitHub: https://github.com/RamonUnch/AltSnap/releases/         *\r\n* Original Stefan Sundin: https://stefansundin.github.io/altdrag/         *\r\n*=========================================================================*\r\n\r\n== INTRODUCTION ==\r\nAltSnap gives you the ability to move and resize your windows in a new way.\r\nWhen AltSnap is running, you can simply hold down the Alt key and then click\r\nand drag any window.\r\n\r\nThis behavior already exists in Linux and other operating systems,\r\nand AltSnap was made with the mission to copy that behavior to the\r\nWindows platform.\r\n___________\r\nMOVE WINDOW\r\nYou can Move a Window by pressing Alt and using (by default) the left mouse\r\nbutton. If you double-click it will maximize/restore the window, and if you\r\nhold Shift while double-clicking, it will roll/unroll the window on its\r\ntitle bar.\r\n_____________\r\nRESIZE WINDOW\r\nYou can use (by default) the right mouse button to resize windows.\r\nImagine the window divided into nine squares, and you will resize the\r\ncorner nearest to where you press. The corners are slightly bigger\r\nthan the middle regions by default (adjust using AltSnap.ini).\r\n ____________________________________________\r\n/ @ Title bar   |            |         _ O X \\\r\n|===============+============+===============|\r\n|    top        |    top     |        top    |\r\n|    left       |            |      right    |\r\n|---------------+------------+---------------|\r\n|               |            |               |\r\n|    left       |   center   |      right    |\r\n|               |            |               |\r\n|---------------+------------+---------------|\r\n|               |            |               |\r\n|    bottom     |            |     bottom    |\r\n|    left       |   bottom   |      right    |\r\n|_______________|____________|_______________|\r\n\r\nIf you double-click (double right click) these regions, the window will be\r\nmoved to the respective corner on your screen (like Aero Snap), so you can\r\nquickly arrange your windows to fit on the screen. If you press Shift in\r\naddition, the respective window side will be extended to the monitor side.\r\nFinally if you press Ctrl and double-click on the center region it will\r\nmaximize/restore the window.\r\nThe center region can be configured to behave differently (see options).\r\n_____________\r\nOTHER ACTIONS\r\nAltSnap can be configured quite finely You can set any button to perform\r\nany action among a list: Move, Resize, Close, Minimize, Maximize, Lower,\r\nAlwaysOnTop, Borderless, Center, Roll, Menu, Kill and Nothing.\r\n\r\nBy default the middle mouse button is configured for the Maximize action,\r\nthat maximizes/restores the window. Press Shift to minimize.\r\n____________________________\r\nTRICKS YOU SHOULD KNOW ABOUT\r\n* AltSnap will not bring windows to front by default. Press Ctrl to bring the\r\n  window to front, or configure AltSnap to do that automatically.\r\n* AltSnap will mimic Aero Snap by default, so try dragging windows to the\r\n  edges of your monitor. Corners work too!\r\n* If you use multiple monitors, you can hold Ctrl or Shift while dragging to\r\n  trap the window within the current monitor. This is particularly useful if\r\n  you want to Aero Snap at edges between monitors.\r\n* While dragging, windows borders will snap to each-other. This behavior can\r\n  be changed in the config. If you disable it you can still press Shift while\r\n  dragging to force windows borders to snap to each other.\r\n* If you have automatic snapping enabled, you can temporarily disable it by\r\n  pressing the space bar while dragging.\r\n* If you are moving a window you can press the right mouse button to toggle\r\n  the maximized state.\r\n* If you use the scroll wheel to change the volume, you can hold shift to\r\n  increase the rate the volume is changed. If you use the scroll wheel to\r\n  change the transparency, you can hold shift to decrease the rate the\r\n  transparency is changed.\r\n* If you have Scroll inactive windows enabled, you can hold the Shift key to\r\n  scroll horizontally. Note that this relies on that the program has support\r\n  for normal horizontal mouse wheel scrolling, which not all programs have.\r\n* If you can't move a particular window, try elevating AltSnap.\r\n  Normal programs can't interact with programs that are started with\r\n  administrator privileges.\r\n* If you need to Alt+Click on a program and do not want to blacklist the\r\n  program, you can use the Winkey instead of Alt. If this is not enough\r\n  or if you do not want to use the Winkey, you can hit Ctrl and release it\r\n  while keeping Alt pressed and then click.\r\n* A key combo can be used in order to activate AltSnap, this allows using\r\n  Alt+Winkey to drag windows and leaves alone the Win+Click and the Alt+Click\r\n  that some programs may require.\r\n* Try to add the Shift modifier key for any action, usually it has an effect.\r\n_____________\r\nCONFIGURATION\r\nTo change the configuration from default, double-click on the tray icon, and\r\nyou will be presented with a lot of choices.\r\n\r\nIf you want to go further into the configuration, open the AltSnap.ini file\r\nby middle-clicking on the tray icon. You will see all the option there with\r\na short description.\r\n_________\r\nLANGUAGES\r\nAltSnap is fully translated in French, Italian and mostly translated in many\r\nother languages. All translations are simple ini files encoded in UTF-16 LE.\r\nIf you want to create or improve a translation, just add or modify the\r\nassociated ini file in the Lang directory, and no not forget to send it to\r\nme via a GitHub pull request/issue or PM me, so that everyone can enjoy your\r\ntranslation. You can use \"Lang\\_en_US baseline.txt\" as a starting point if\r\nyou want to translate everything to a new language.\r\n______\r\nUPDATE\r\nTo avoid useless bloat and potential vulnerability AltSnap no longer\r\nauto-updates. You can check for new versions on the GitHub page\r\nIf you want automation, install altsnap via the chocolatey package.\r\n-install with> choco install altsnap\r\n-update with> choco update altsnap\r\n-uninstall with > choco uninstall altsnap\r\nYou can do the same with winget. Note that the chocolatey/winget package\r\nmay take a few days before getting updated.\r\n_________\r\nBLACKLIST\r\nSometime an AltSnap action interacts with a window you do not want.\r\nFor example if you use Alt+Click on a specific window and you do not want\r\nAltSnap to move the window you can add the window name to the windows\r\nblacklist. more details below:\r\nAll the list are coma separated and take no spaces before the coma.\r\nA space can be present in the item itself or before the item.\r\n\r\n- Process blacklist: List of programs names for which move/resize from\r\n  AltSnap as well as the scroll actions are disabled. Example: Notepad.exe\r\n- Windows blacklist: List of windows with the title|class format for which\r\n  move/resize actions from AltSnap will be disabled\r\n  Example: Program Manager|Progman,|Shell_TrayWnd,*|Notepad\r\n- Windows that should ignore the scroll action: List of windows with the\r\n  title|class format that for which the scroll action of AltSnap will not\r\n  apply. Example: *|Photoshop\r\n- MDIs not to be treated as such: List of windows for which AltSnap will not\r\n  try to find MDI subwindow. This only applies if the Support MDI is enabled\r\n  and by default contains *|PPTFrameClass,*|MMCMainFrame which correspond to\r\n  the PowerPoint window and all the Microsoft Management application such as\r\n  the services.msc windows or the device drivers window.\r\n- Process not to be paused or killed: Only applies for the Pause and kill\r\n  action when enabled on Alt+Shift+Pause of Ctrl+Alt+F4,\r\n  this are program names.\r\n\r\nProgram names are pretty straightforward to find. However a finer control can\r\nbe done using the window's title|class information; they can be found for a\r\nspecific window using the small target in the identify window section of the\r\nBlacklist tab. You can include all the possible names by using the *|class\r\nformat. This is useful for most programs that have a non-constant title, for\r\nexample notepad's title is actually the name of the file you are currently\r\nediting.\r\nThe other way around can be used and you can specify title|* which means that\r\nall the windows that have this title regardless of their class name will be\r\nblacklisted. This is a much less common usage.\r\n\r\nThe title can also be empty for example: |Shell_TrayWnd corresponds to the\r\nWindows task bar and has an empty title.\r\n\r\nFinally more blacklists can be found in the AltSnap.ini file:\r\n- Snaplist: List of windows with the name|clas format to which other windows\r\n  should snap. By default windows that have no borders cannot be snapped to.\r\n- MMBLower: List of windows that should not be lowered with mouse middle\r\n  click on the title bar. Default: *|CASCADIA_HOSTING_WINDOW_CLASS that\r\n  corresponds to the Windows Terminal window.\r\n\r\n===========================================================================\r\n== USAGE ==\r\nExtract to any folder, and double click on AltSnap.exe\r\nEnjoy dragging windows...\r\n\r\nYou will see a new Icon in the tray\r\n- Right click on the Tray Icon to see the option menu\r\n- Left click on the Tray Icon to enable/disable\r\n- Go to the \"Configure\" menu entry for basic options\r\n- Middle click on the Tray Icon to open config file AltSnap.ini (advanced)\r\n- You can hide the icon if you want. To show it again relaunch AltSnap.exe\r\n\r\nAltSnap Wiki: https://github.com/RamonUnch/AltSnap/wiki\r\nNote that this version has some more feature.\r\n\r\n===========================================================================\r\n== CHANGELOG ==\r\n\r\n== AltSnap 1.64 ==\r\n + Multi-user is now supported. Portable mode is still automatic if\r\n   AltSnap.ini is located next to AltSnap.exe.\r\n\r\n + uiAccess flag was added to the .manifest file, see #538 for more details.\r\n\r\n * Fixed bad offset  when restoring MDI window.\r\n\r\n * Add League of Legends to blacklist (not a joke) #533\r\n\r\n * Improve move to top/left/right/bottom. #534\r\n\r\n * Ignore Ctrl if simulated (vai Alt Gr for exmple) #518\r\n\r\n== AltSnap 1.63 ==\r\n\r\n + Snap Layout preview #511, #359, 464.\r\n   Configure via the folowing options:\r\n```\r\n   in the [Zones] section\r\n\r\n   ShowZonesPrevw=1\r\n   ; Enable/Disables Layout preview (default 1)\r\n\r\n   ZonesPrevwOpacity=160\r\n   ; Opacity from 0-255 of the Zone preview (default 160).\r\n   ; Use 0 if you disabled Desktop composition.\r\n\r\n   ZonesPrevwBGCol=FF FF FF\r\n   ZonesPrevwBDCol=00 00 00\r\n   ; Color of the Snap Layout preview, ZonesPrevwBGCol for background color\r\n   ; and ZonesPrevwBDCol for the border color. default are white and black.\r\n   ; Use a dark beckground and a light border if you use dark theme.\r\n```\r\n\r\n * Fixed: Titlebar action now has precedence over hotclick. #503\r\n\r\n * Fixed Scheduled task script #505, thanks to @VladKappa\r\n\r\n * Updated Polish translation, thanks to @xeophyte\r\n\r\n * Updated Chinese translation, thanks to @yatli\r\n\r\n * Updated Korean translation, thanks to @1kko\r\n\r\n\r\n== AltSnap 1.62 ==\r\n\r\n + Add the focus left/top/right/bottom window actions. They can be used\r\n   by setting up keyboard shortcut or via the command line.\r\n   FocusL; FocusT, FocusR, FocusB. #465\r\n\r\n + Add the option to change the LongClick move delay, use LongClickMoveDelay.\r\n   option in the [Advanced] section of the ini file. #468\r\n\r\n + Add sch_On.bat and sch_Off.bat batch files to setup Scheduled task #475\r\n\r\n + Add the `-lX` cmdline option to select Snap Layout layout number X. #479\r\n\r\n + Add the `-r` cmdline option to reload altsnap config. #452\r\n\r\n + Add RezTimer=4 to automatically select 1 if display frequency is 60Hz\r\n   or 3 otherwise. #452\r\n\r\n * Allow more messages to filter through elevation so that AltSnap command\r\n   line option can pass from non-elevated to elevated. #452, #483\r\n\r\n * Transform action list-box into an actual Edit+List combo-box. This is useful\r\n   when typing ShrtX actions and helps with long list boxes.\r\n\r\n * Audio balance resets when decreasing the system volume to Zero,\r\n   so now AltSnap mutes the sound instead. #186\r\n\r\n * Also disable Alt+Scroll when Movement is disabled on a window. #484\r\n\r\n * Fix border calculation error in the Move To Next Edge actions. #491\r\n\r\n * Fix negative border problems when starting from a maximized state. #445\r\n\r\n * Transform Snap to corner in move to next edge for non-resizable windows\r\n   when not using the Resize all windows option. #447\r\n\r\n== AltSnap 1.61 ==\r\n\r\n + Added the Focus Window action. #408\r\n\r\n + Add the **Edit snap layout** tray menu entry that re-opens all the windows\r\n   fom the currently selected layout for easier edition. #407\r\n\r\n + You can now set RezTimer=3 in the [Performance] section of the .ini file\r\n   to combine a timer based resizing with the usual MoveRate and ResizeRate\r\n   multiplication factors. See #451 and #452 for more details.\r\n\r\n * Fix Action without click #455, #456. (huge regression, sorry for that).\r\n\r\n * Always focus the window on Always On Top toggle #442\r\n\r\n * Fixed: Allow xxbutton as hotclick (1.55 regression). #433\r\n\r\n * Fixed: the send Original click option must be shown on hotclick,\r\n   not just for the titlebar action.\r\n\r\n * Fixed: AltSnap hotkeys not working properly when using AltSnap elevated\r\n   with a non admin account (make use of the ChangeWindowMessageFilterEx()\r\n   function when running on Windows 7 and later). #428\r\n\r\n * Partially fixed window resizing when going to a monitor with a\r\n   different DPI. #413\r\n\r\n * Fixed French translation, thanks to @TroudhuK\r\n\r\n * Updated Japaneese translation, thanks to @kakakaya\r\n\r\n * Updated Korean translation, thanks to @1kko-ahnlabio\r\n\r\n * Add Finish Translation by @6sto based on AltDrag 1.0, see\r\n   https://github.com/stefansundin/altdrag/issues/170\r\n\r\n== AltSnap 1.60 ==\r\n\r\n + Added the `ZSnapMode` option in the [Zones] section of the ini file,\r\n   to change the strategy for choosing the zone zone on which the dragged\r\n   windows will snap. #405\r\n   Set to 0 to snap to the pointed zones (default, old behavior).\r\n   Set to 1 to snap to the zone which center is the nearest from cursor.\r\n   The second mode will be needed if you want to use overlapped zones.\r\n\r\n + The Test Window will now also display the mouse events.\r\n\r\n + The test Window will now have a full-screen mode (toggle with F11).\r\n\r\n + Added the `MenuShowEmptyLabelWin` Advanced option to display the windows\r\n   with empty titles inside the Windows list menu. #401 @mbartlett21\r\n\r\n + Add the **All windows list** action that will behave like the\r\n   Window list action but will even display windows outside the\r\n   current monitor. Thanks to @mbartlett21 for this. #384\r\n\r\n + You can now set `IgnoreMinMaxInfo` option in the Advanced section\r\n   of the ini file if you want to ba able to resize Windos beyond their\r\n   usual limits, Set to 0 (default) to always disable, set to 1 to ignore\r\n   the minimum size, 2 to ignore maximum size and 3 to ignore both. #374\r\n\r\n + You can set the `MenuShowOffscreenWin=1` in the [Advanced] section\r\n   of the ini file to still display windows in a windows menu even\r\n   if they are outside of any monitors. Thanks to @mbartlett21. #384\r\n\r\n + The *clear AltSnap state* key can now be set to any other key, using\r\n   the `ESCkeys` key list in the [Input] section of the ini file. Defalut\r\n   value is `1B` (ESCAPE), like with previous AltSnap versions. #386\r\n\r\n * Fixed inconsistant key state leading to drag-free actions not working\r\n   and to blocked LMB in some cases. #392, #388.\r\n\r\n * Fixed: Now FancyZones snapped Windows will be restored to their proper\r\n   dpi-scaled size. If this causes any issues for you you can always set\r\n   `FancyZone=2` in the [Zones] section to prevent scaling.\r\n\r\n * Updated Chinese translation, thanks to @yatli,\r\n   Updated Polish translation, thanks to @xeophyte,\r\n   Updated German translation, thanks to @Ichisich\r\n   Updated French and Italian translations.\r\n\r\n== AltSnap 1.59 ==\r\n\r\n + Now AltSnap will respect the system drag threshold. Use `DragThreshold`\r\n   value in the [Advanced] section of the ini file to determine when the\r\n   threshold will be respected. Possible values are:\r\n   0: disabled, like old AltSnap versions,\r\n   1: Enabled when restoring snapped window (default),\r\n   2: Always wait the drag threshold before moving the window,\r\n   3: Same than 2 but also applies to the resize action. #365\r\n\r\n + Generalized combo actions: Now you can select any action that will apply\r\n   if a move or a resize action was started. You can configure them in the\r\n   Mouse tab of the config dialog by selecting the **While moving** and\r\n   **While resizing** radio buttons. Those options are available via the\r\n   ini file in the [Input] section using the `M` and `R` sufixes.\r\n   ie: `MMBR=ExtendTNEdge`. Also an extra `B` sufix can be added for\r\n   alternate action (only available via ini). #217, #362.\r\n\r\n + Multiple *snap layouts* are now supported... #232\r\n\r\n + New `IScroll` blacklist in the `[Blacklist]` section of the ini file\r\n   That only applies to the Inactive scroll option. #351\r\n\r\n + Added the **Move/Extend to next edge** action, That will extend the next\r\n   edge from a snapped window, also available as keyboard shortcuts. #368\r\n\r\n + Added the `--help` option, also available as `-help` or `-?` or `/?`.\r\n   It will display a very short summary of available commands. #370\r\n\r\n * Fixed: Now a hotclick will not always be blocked, It will be forwarded\r\n   in case no action was done. If you want a hotclick to always be blocked\r\n   set `AblockHotclick=1` in the `[Advanced]` section of the ini file.\r\n\r\n * Fixed: Next/Previous stacked window keyboard shortcut no longer depends\r\n   on cursor position, unless you enabled **use pointed window**. #372\r\n\r\n * Added the missing Next/Previous laser stacked window. #362\r\n\r\n * Fix delay when forwarding a click in some cases. #352\r\n\r\n * Fix button up being improperly blocked sometime. #355\r\n\r\n * Fixed occasional crash when editing the config dialog.\r\n\r\n * Updated German, Korean, French and Italian translations.\r\n\r\n== AltSnap 1.58 ==\r\n\r\n + Tray icon theme support was added, put an icon theme in the Themes\\\r\n   folder and then set `Theme=ThemeName` in the [General] secion of the ini\r\n   file. A theme is a folder containing three tray icons named: TRAY_OFF.ico,\r\n   TRAY_ON.ico, TRAY_SUS.ico. Thanks to @erasmion for supplying a theme,\r\n   You can try it with Theme=erasmion. #313\r\n\r\n + The maximum width in characters of an item in a window list menu can now\r\n   be set from 0-255 by the user using the `MaxMenuWidth` option in the\r\n   [Advanded] section of the ini file. Use 0 for unlimited, default is 80.\r\n   Thanks to @mbartlett21 for the pull request #341.\r\n\r\n + Side fraction can now be set independently from center fraction for more\r\n   flexible configuration. Have a look at the test window and play with those\r\n   values, accessible through the Advanced tab of the config dialog. #318\r\n\r\n + Blacklist were improved to allow a mix of both exe names and title|class.\r\n   You can now specify `exename.exe:title|class`. If you omit the ':' and '|'\r\n   the format is assumed to be an exe name only. If you only specify '|',\r\n   the exe check will be omitted and the format will be assumed to be\r\n   title|class, like it was the case before. Example: You want to blacklist\r\n   the `*|CabinetWClass` windows only if they are from explorer.exe, use:\r\n   `explorer.exe:*|CabinetWClass`.\r\n\r\n + New **Open ini file** option was added to the tray menu for easy access.\r\n\r\n + New: `MaxKeysNum` option can be set to specify the maximum number of\r\n   keys that can be pressed in order to activate AltSnap. This does not\r\n   apply to the keys that are pressed after activation, use the KillKeys\r\n   for this. Default value is 0 (unlimited). #324\r\n\r\n * Fixed hotclicks not behaving properly for left and right mouse buttons\r\n   Now you can setup AltSnap to Move/Resize window with right click while\r\n   still being able to left click without drag. #340\r\n\r\n * Fix Tray icon not displaying properly in some cases #315.\r\n\r\n * Fix: No lines drawn in the test window when CenterFraction=0. #319\r\n\r\n * Fix lockup when using hotclick on blacklisted window. Part of #334\r\n\r\n * Styling options were fixed and AltSnap can now be build with -std=c99\r\n   -Wpedantic flags.\r\n\r\n * TCHAR is now preferred over wchar_t so that code is more portable and\r\n   future proof\r\n\r\n * Optimizations for ini file loading, this should reduce start time on\r\n   Slow media such as old HDD/CDRom/floppy.\r\n\r\n * Updated German, French and Italian translations.\r\n\r\n\r\n== AltSnap 1.57 ==\r\n\r\n + New keyboard  actions to move the window in steps to each directions.\r\n   You have the choice between large steps and small steps. To setup the\r\n   size of the steps in pixels, use the `KBMoveStep` and `KBMoveSStep`\r\n   values in the [Advanced] section of the .ini file.\r\n   Default is 100 for large steps and 10 for small steps. #304\r\n\r\n + Now the *Restore Window* action is available as a mouse action and will\r\n   let you restore AltSnapped windows to their original size with a single\r\n   click. Setup as a titlebar action it can be used to better integrate\r\n   in the native snapping experiment. #292\r\n\r\n + Now the right mouse button can be used inside a menu item of a  window\r\n   list to minimize the corresponding window. The middle mouse button will\r\n   close the window. he menu will remain opened. #290\r\n\r\n + Now the `NumberMenuItems` option can be set to 1 in the `[Advanced]`\r\n   section of the .ini file in order to number menu elements from 0-9\r\n   instead of A-Z. This applies to all windows list menu.\r\n\r\n + New: Window list action that list all windows on your monitors. It can\r\n   be an alternative to Alt+Tab. #298\r\n\r\n + New Laser stacked windows list action is now available as a mouse and\r\n   keyboard action previously it was only available with the shift modifier\r\n   on the Stacked windows list action.\r\n\r\n + New: You now have a *Send original click* option in the action menu\r\n   if you triggered it from the title bar. #302\r\n\r\n + New: You now have the **Movement Disabled** entry on the action menu\r\n   that will prevent AltSnap movement from happening in the window.\r\n   The flag can be enabled and disabled as desired for any window. #283\r\n\r\n + Now any keyboard shortcut can be setup to suspend/resume Altsnap. #283\r\n\r\n + New: AltSnap actions can now be Invoked from the command line. Actions\r\n   will behave like the corresponding keyboard action. AltSnap\r\n   must already be launched and the allow multiple instance option must be\r\n   disabled. Then you can Launch AltSnap:\r\n   `AltSnap.exe -apACTION` to perform the ACTION on the Pointed window\r\n   `AltSnap.exe -afACTION` to perform the ACTION on the Foreground window\r\n   example: AltSnap.exe -afAlwaysOnTop will toggle the topmost flag on the\r\n   foreground window. #285\r\n\r\n * Now title or class blacklist item can match start or end with a `*`\r\n   ie: `*ttl|class*` or `*ttl|*class` or `ttl*|*class` or `ttl*|class*`\r\n   You cannot have a star at both ends of an item though. Previously\r\n   matching was limited to the `*ttl|class*` form. #305\r\n\r\n * Now with the `EndSendKey` option in the [Input] section of the ini file,\r\n   you can specify which key will be sent at the end of a movement to\r\n   prevent menu being selection or the window menu from popping up\r\n   The default value is `EndSendKey=11` that corresponds to the Ctrl\r\n   key that is used since ever in AltSanp and AltDrag. #309\r\n\r\n * Try as much as possible to Maximize/restore windows asynchronously to\r\n   avoid mouse locking.\r\n\r\n * Fixed Stacked windows menu font is now the current system menu font\r\n   instead of the dialog font. #284\r\n\r\n * Fixed: Crash in the Stacked window list. #284\r\n\r\n * Fixed: Pressing ESC when cancelling a stack window menu will no longer\r\n   focus the first window of the list. #284\r\n\r\n * Fixed: Some crashes in low memory situation.\r\n\r\n * Fixed: The hooks.dll file will only be loaded from AltSnap's directory.\r\n\r\n * Fixed: #239 Window transparency would sometime not be restored when\r\n   using the Opacity while moving option.\r\n\r\n * Fixed: #295, Windows Terminal will no longer minimizes when selecting\r\n   the Minimize all other windows option.\r\n\r\n * Fixed: Removes the topmost indicator or display the context menu when\r\n   the click is released instead of down for more consistent UI experience.\r\n   This will also allow to handle drags in the future if needed.\r\n\r\n\r\n== AltSnap 1.56 ==\r\n\r\n * Fixed Move windows with long left click option (1.55 regression).\r\n\r\n * GUI: Minor adjustments to avoid clipping of the topmost indicator option\r\n   in the Advanced tab.\r\n\r\n * Adjustments to the French translation by @TroudhuK\r\n\r\n== AltSnap 1.55 ==\r\n\r\n + New action, you can now pop up a **Stacked window list** that will show\r\n   the list of windows that are stacked with the pointed window. You can\r\n   then select the window you want and it will be set to the foreground.\r\n   Shift extends the stack to all windows that are under the mouse pointer.\r\n\r\n + New action: **Next/Prev stacked window**, available as mouse action and\r\n   as wheel action. Again add shift to extend the stack.\r\n\r\n + New: Now an indicator for windows that were set AlwaysOnTop can be set.\r\n   Check  the **Show an indicator on always on top windows** option in the\r\n   Advanced tab. The indicator will also show a list of other AlwaysOnTop\r\n   windows when right-clicked. You can also set the `PinColor` option in\r\n   the [Input] section of the .ini and the `PinRate` option in the\r\n   [Performance] section of the .ini can be used to set the color of the\r\n   indicator and the rate at which it gets refreshed.\r\n\r\n + New: You can now setup any keyboard shortcut for any action.\r\n   Note that this creates system level keyboard shortcuts and you will be\r\n   unable to setup a shortcut that already existed (this is a good thing).\r\n   Go to the Keyboard tab of the config dialog, select the option for which\r\n   you want to setup a shortcut, then edit it manually or click the\r\n   Pick keys button and press your shortcut, then hit the Save button.\r\n   You can decide whether those keyboard-only actions should apply to the\r\n   pointed or to the focused window. #264, #268\r\n   You will need to reconfigure Kill on Ctrl+Alt+F4 and such.\r\n\r\n + New keyboard-only actions to move/extend the window to the surrounding\r\n   zones in the snap layout.\r\n\r\n + New: Now you can set up `MoveUpT` and `ResizeUpT` actions to be\r\n   performed when the click was performed inside the titlebar.\r\n   CHECK YOUR CONFIG, as those options did not exist before and\r\n   will default to Nothing. The options were also added to the GUI.\r\n\r\n + New: Two Zoom window action that can be setup for a mouse wheel.\r\n   The first one will resize only vertically/horizontally when the\r\n   mouse points at the pure side sectors, and the second one will\r\n   always zoom proportionally instead. In addition you can adjust\r\n   the fraction by which the window is zoomed using the `ZoomFrac`\r\n   and `ZoomFracShift` options. #239\r\n\r\n + New: To fix menu not getting canceled in some cases, you can add the\r\n   `DragSendsAltCtrl` option in the [Advanced] section of the ini. #255\r\n\r\n + New now you can set the value of `BLUpperBorder` in the `[Advanced]`\r\n   section of the .ini file and it will select in the same fashion than\r\n   `BLCapButtons` but this time only for the top resizing border. Default\r\n   value is also 3 to prevent left and right button to trigger AltSnap in\r\n   the top resizing borders. `BLCapButtons` now concerns only the caption\r\n   buttons and no longer the top resizing border.\r\n\r\n + Now you can customize the action menu by adding or removing menu items\r\n   using the `ACMenuItems` option in the `[Advanced]` section of the .ini\r\n   file. Default value is -1 for all menu entry. #240\r\n\r\n + Updated German translation thanks to @Ichisich\r\n\r\n * GUI: Now the `SnapGap` option is available through the GUI. #200\r\n\r\n * Fixed #150: The top owner window is now used for the always on top\r\n   action. This avoids some parts of the program not being affected.\r\n\r\n * Fixed #235: Inconsistent focusing of windows.\r\n\r\n * Fixed #274: The window is now refocused when the action menu is canceled.\r\n\r\n * Fixed: More reliable prevention of menu activation and/or start menu\r\n   popping up problems.\r\n\r\n * Fixed: Window maximum and minimum sized would be ignored in center\r\n   resizing mode, leading to window running outside the screen when\r\n   resizing it beyond their maximum size.\r\n\r\n * Fixed: Focus windows when dragging not working in some cases. #250\r\n\r\n * Fixed: The titlebar Action menu not disappearing on defocusing in some\r\n   cases. #263.\r\n\r\n * Fixed now if the owner window has an empty RECT it will no longer be\r\n   used to hold the topmost indicator (ie: ForceToolkit main window).\r\n\r\n\r\n== AltSnap 1.54 ==\r\n\r\n + New: You can now set `UseZones=9` in the `[Zones]` section of the .ini\r\n   file and Windows will snap to the layout without having to press Shift.\r\n   Pressing shift or hitting space will disable zone-snapping instead. #219\r\n\r\n + Now if you use Zones, and disable the **Toggle maximize state with the\r\n   resize button while moving** advanced option, then Zone snapping will be\r\n   toggled by any secondary buttons, like with FancyZones. #219\r\n\r\n + New: Now you can set the opacity of the hollow rectangle (0-255) used\r\n   when the show window content while dragging option is disabled or when\r\n   FullWin=0. to do this you must modify the `TransWinOpacity` value in the\r\n   `[Performance]` section of the .ini file. #223\r\n\r\n + New now you can set the value of `BLCapButtons` in the `[Advanced]`\r\n   section of the .ini file to choose for each mouse button if the titlebar\r\n   action will be or not extended to the caption buttons and the top\r\n   resizing border. Use `BLCapButtons=0` if you want all buttons to\r\n   consider the extended caption and use -1 for none of them. The default\r\n   value is 3 to avoid the extended caption for the left and right mouse\r\n   buttons so that AltSnap avoids interaction with the minimize, maximize\r\n   and close caption buttons ([_] [O] [X]). If you are unsure stick to\r\n   the default value if you want less titlebar detection use -1. #236\r\n\r\n * Now a checkmark in the action menu will indicate the always on top state\r\n   of the pointed window. Same for Maximized and Borderless flags (#184).\r\n\r\n * Changed: Now when auto Snapping is enabled at the maximum level, then\r\n   pressing shift will disable snapping instead of doing nothing.\r\n\r\n * Changed: Now several keys can be selected for the alternate action\r\n   ie: the `ModKey` value in the `[Input]` section is a key list and works\r\n   like the Hotkeys value. Same was applied to `HScrollKey`. (#207)\r\n\r\n * Fixed: Now smarter areo-snapping will be properly re-enabled when you\r\n   release Shift. (#211)\r\n\r\n * Fixed: Snapping to the layout  will no longer ignore the Max snapping\r\n   speed option. (#218)\r\n\r\n * Fixed multiple Action menu popping up in some cases. (#213)\r\n\r\n * Fixed some stuck mouse buttons in some cases when using the Move\r\n   Windows with a long left click option.\r\n\r\n * Fixed #220, Minic aero snapping is no longer necessary for Snapping\r\n   to the snap layout (Zones).\r\n\r\n * Fixed: Modifying the config will no longer reset the `UseZones` value.\r\n\r\n * Fixed #226, #229: Now the `DWMWA_CAPTION_BUTTON_BOUNDS` rectangle is\r\n   used to ensure that we are inside a titlebar and not caption buttons.\r\n   This fixes an annoying Windows 10 bug.\r\n\r\n * Fixed, now the common french e dans l'o `Â` character is available in\r\n   the default extended character menu (LATIN SMALL/CAPITAL LIGATURE OE).\r\n\r\n * Updated Chinese translation, thanks to @yatli.\r\n\r\n== AltSnap 1.53 ==\r\n\r\n * New: An extra key menu can now be enabled in the Keyboard tab of the\r\n   config and a popup menu with additional characters will show up when\r\n   you press a key from A-Z for a long time. This is similar to the way\r\n   Android and MacOS behave. The menu entry can be selected by pressing\r\n   the accelerator key (first column), or using the usual arrows/mouse.\r\n   The menu can be configured individually for each language (#181).\r\n\r\n * New: Now any key can be mapped to mouse button 6-20, this is useful if\r\n   you have more than 5 mouse buttons and want to use your extra buttons with\r\n   AltSnap. You can first bind your extra mouse buttons to keys that you\r\n   would never use ie F13-F24, or some multimedia keys or even in some cases\r\n   to undefined virtual-keys codes, then add those virtual key codes in the\r\n   `XXButtons` key list (space separated hexadecimal values). Then those key\r\n   will be turned in MB6, 7, 8... events in the order of the list, finally\r\n   you can map an action to the corresponding mouse button, in the [input]\r\n   section of the .ini file. I advise to also add those buttons to the\r\n   `Hotclicks` key list. Finally keep in mind that any keys added to the\r\n   `XXButtons` list will be unusable outside of AltSnap.\r\n   Check issue #175 for the feature development and more tricks.\r\n\r\n * New: the `Bottommost` list was added to the `[Blacklist]` section of the\r\n   ini file. When AltSnap lowers a window, it will try to keep it above all\r\n   those Bottommost windows. Default value is `*|RainmeterMeterWindow` for\r\n   the Rainmaker skin windows (fixes #189).\r\n\r\n * New: You can now replace the all directions center resize mode by the\r\n   **Closest side** mode that picks the closest side resizing mode instead.\r\n   The test window will be updated accordingly (see issue #193).\r\n\r\n * New: Now pressing Ctrl+N in a test window will open a New one.\r\n\r\n * Fixed: Now maximizing a window with the Action without click option will\r\n   no longer prevent further movement.\r\n\r\n * Fixed: The long click move option now works when left and right buttons\r\n   are swapped, it will also no longer interact with blacklisted windows.\r\n\r\n * Fixed MDI ancestor detection to avoid AltSnap freezing on WinTabber.\r\n\r\n * Fixed: `MinAlpha` and `AeroSpeedTau` being ignored (1.52 regression).\r\n\r\n * Fixed: #183 Titlebar move action would not work properly when no primary\r\n   action was selected.\r\n\r\n * Fixed: #179 Smarter aero snapping mode will always consider the current\r\n   window size/position and ignore the original AltSnapping.\r\n\r\n * Fixed: Now it will remain possible to snap to windows that were made\r\n   borderless using AltSnap (partially fixes #185).\r\n\r\n * Changed: minor code refactoring, inducing even more exe size reduction.\r\n\r\n * Updated German translation thanks to @Ichisich, updated Korean translation\r\n   thanks to @1kko.\r\n\r\n== AltSnap 1.52 ==\r\n\r\n * New: Now a help message is added to the test window to indicate how to\r\n   setup snap layout (zones).\r\n\r\n * Changed: some code refactoring and unification inducing size reduction.\r\n\r\n * Fixed: Lag when dragging and resizing some programs (issue #160)\r\n\r\n * Fixed: #172, drag was locked down when combining and action and hotclick.\r\n   Also, now if a hotclick is combined with the Move or Resize action then a\r\n   long click will be forwarded to the pointed program is no drag occurred.\r\n   This long click will not even be necessary if you enabled the\r\n   **Avoid blocking Alt+Click** option in the General tab of the config.\r\n\r\n * Fixed: #124, A window will be restored to its original position when\r\n   using the Move+Resize click combo without a drag.\r\n\r\n * Fixed: bugs in rolling and snapping code.\r\n\r\n * Updated French and Italian translations\r\n\r\n * Updated German translation, thanks to @Ichisich.\r\n\r\n== AltSnap 1.51 ==\r\n\r\n * Fixed regression that would make it impossible to select alternate action\r\n   for mouse button 4 and 5.\r\n\r\n * Fixed: Now the LongClick Move will no longer trigger if the cursor is\r\n   pointing toward a system menu or a scroll bar or any of the caption\r\n   buttons [?][_][O][X], in the titlebar.\r\n\r\n== AltSnap 1.50 ==\r\n\r\n * New: Major changes in the title bar handling. A set of specific actions\r\n   can be configured for each mouse button to apply when clicking on the\r\n   title bar. Those actions can be configured to be used without pressing\r\n   the hotkey if you want. This replaces all special title bars options:\r\n   `LowerWithMMB`, `RollWithTBScroll`, `NormRestore`, `TitlebarMove`,\r\n   now removed. **CHECK YOUR CONFIG** when you install this update...\r\n\r\n * New: Now, if you perform a long Alt+Click, the click will be forwarded\r\n   to the pointed program, simulating a normal Alt+Click. You can also check\r\n   the **Avoid blocking Alt+Click** option (General tab) and the Click will\r\n   always be redirected, this will also disable all double-click actions.\r\n\r\n * New: A specific action can be configured when the Move or Resize action\r\n   is release without performing a drag, so for example you can set\r\n   `MoveUp=Minimize` in the `[Input]` section of the ini file and then\r\n   Alt+Move+drag will just move the window as normal, but Alt+Move+Release\r\n   will minimize the window. By default it needs to be a long click but if\r\n   you check the avoid blocking Alt+Click option then any click will work.\r\n   Same for the resize action using `ResizeUp` option. You also have the\r\n   Alternate versions for each one with the B sufix. Also if you Hold Ctrl\r\n   while releasing the click the action will not be performed.\r\n\r\n * New: Now the Resize+Move click combo will snap the window to the\r\n   corresponding corner (similar to Move+Resize => Maximize).\r\n\r\n * New: Mute sounds action to toggle mute state on Win2k+.\r\n\r\n * New: Snap to side/corner action is available, and is equivalent to the\r\n   double-right-click aero-snapping.\r\n\r\n * New: The `RezTimer` option was added to the `[Performance]` section of\r\n   the ini file and permits to move the cursor only at the default event\r\n   time resolution (every 16ms). It can be combined with FullWin=0 and is\r\n   very low on resources consumption. It is an advised mode if your monitor\r\n   refresh rate is only 60Hz. If the option is used then all the other\r\n   rates are ignored.\r\n\r\n * French, Italian, translations are up to date and thanks to @1kko for\r\n   Korean Translation and thanks to @Ichisich for German translation\r\n\r\n * Fixed: now the config dialog will show up in the corner your cursor is\r\n   when you click on the tray icon.\r\n\r\n * Fixed: now the borderless action will save the old window style.\r\n   Also Windows that have been set borderless by AltSnap will still be\r\n   considered resizable.\r\n\r\n * Fixed: Colors of the *Test Window* now depends on system colors.\r\n\r\n * Fixed: Now the `RefreshRate` delay is almost millisecond accurate, it used\r\n   to be 16 ms accurate, rendering it useless on high-spec computers.\r\n\r\n * Fixed: the show window content while dragging will no longer be ignored\r\n   on newer Windows versions. The `FullWin` option in the `[Performance]`\r\n   section of the .ini file can be set to 1: force on, 0: Force hollow,\r\n   and 2: Autodetect based on Windows setting.\r\n   The color of the hollow rectangle can be set in hex RGB via the\r\n   `FrameColor` option in the [Input] section, default is 80 00 80.\r\n\r\n * Fixed: Alt+Shift will be blocked, by sending Ctrl, if an action occurred.\r\n   This avoids unwanted keymap changes.\r\n\r\n * Fixed: Volume action now simply sends the multimedia key events.\r\n   It should work on Win2k+, and will show a visual indicator on Win10.\r\n\r\n * Fixed: Sometime a maximized window could become impossible to restore\r\n   with AltSnap.\r\n\r\n== AltSnap 1.49 ==\r\n\r\n * New: New way of arranging your windows: Grid mode. It replaces the snap\r\n   layout with a simple grid than can be configured in the ini file. You can\r\n   Set `UseZones=3` in the [Zones] section of the .ini file to enable grid\r\n   mode then you can set the number of grid lines/columns using the\r\n   `GridNx/GridNy` options. Gor Grid mode I suggest to set UseZones=7 (3+4)\r\n   so that the window get extended without having to press Ctrl.\r\n\r\n * New option to disable AltSnap on Maximized windows (advanced tab)\r\n   You can also use the `BLMaximized` option in the .ini file.\r\n\r\n * New: AltSnap can now be activated with a long mouse click, check the\r\n   corresponding option at the bottom of the Mouse tab. Default long click\r\n   delay is the system double-click delay, it can also be manually set via\r\n   the `LongClickMove` option in the ini file. Only the left click for\r\n   movement is supported, it was suggested by @actforjason.\r\n\r\n * GUI: `Smarter Aero Snap dimensions` and `Never restore AltSnapped windows`\r\n   options were added to the GUI so they can be configured easily.\r\n\r\n * Fix: When using the Kill Action on a suspended window, AltSnap will send\r\n   the WM_CLOSE message and the terminate confirmation should appear. For now\r\n   it is impossible to really kill the process via AltSnap because its\r\n   window is Ghosted as soon as windows detects the process is hung.\r\n\r\n * Fix: Never restore AltSnapped windows option can be combined with Smart\r\n   aero snap dimensions, and perform properly (#133)\r\n\r\n * Fix: Now all keys from A-Z are in the Killkeys list to avoid interaction\r\n   with system shortcuts that might put AltSnap in an inconsistent state\r\n   ie: Win+L, Win+V...\r\n\r\n * Fix: The Close Action now behaves correctly on Excel.\r\n\r\n * Fix: Maximum number of zones in the snap layout was raised to 2048.\r\n\r\n * Updated German and Chinese translations.\r\n\r\n== AltSnap 1.48 ==\r\n\r\n* New action: Minimize all other windows, similar to aero-shake, but available\r\n  as a mouse action, and in the action menu.\r\n\r\n* New: Now when using the **Lower windows by middle-clicking on title bars**\r\n  option Ctrl+Middle-click in the title bar will toggle the Always on top\r\n  state and so will Middle-click on the Min/Max/Close buttons.\r\n\r\n* New: `SnapGap` value can be set into the `[Advanced]` section of the ini\r\n  file and will set an additional gap between snapped windows/monitor sides.\r\n  You can put a negative value if you want an overlap. Default is 0\r\n\r\n* New: `Shiftkeys` keys list was added in the [input section of the ini file,\r\n  to setup another key instead of the Shift key. The default is `A0 A1`,\r\n  for left and right shift but this is now a customizable key list.\r\n\r\n* New: `ShiftSnaps` option was added in the `[Advanced]` section of the ini\r\n  in order to enable/disable the border-border snapping activation with the\r\n  shift key (default is 1).\r\n\r\n* Fixed: Now when resizing several windows at the same time the DeferPos\r\n  windows functions are used to minimize flicker.\r\n\r\n* Fixed: Now when disabling window to window snapping with space while\r\n  dragging, the smart window snapping will also be disabled.\r\n\r\n* Fixed AltSnap would block Alt+Space if no drag occurred, this was a problem\r\n  when using **Action without click**.\r\n\r\n* Fixed: smart aero-snapping only taking into account windows snapped on the\r\n  other side of the monitor.\r\n\r\n* Fixed: non-resizable windows will longer be maximized with right click\r\n  while moving.\r\n\r\n* Fixed Maximize Vertically action that would erase the old restore state.\r\n\r\n* Fixed some crash when launching again AltSnap with a previous instance.\r\n\r\n* Fixed Tray icon handling under Win10.\r\n\r\n* Changed: Now when the space key is pressed for a movement the snap sate\r\n  will be toggled between no snapping and all border-borders snapping.\r\n\r\n== AltSnap 1.47 ==\r\n\r\n* Project was renamed from **AltDrag** to **AltSnap** to avoid conflict with\r\n  Original AltDrag from Stefan Sundin. Old choco package will no longer be\r\n  updated and will be given back as soon as Stefan asks for it.\r\n  I advise to all users to uninstall AltDrag and install AltSnap.\r\n\r\n* New: Support of Snap Layouts, also called Zones. All associated settings\r\n  are in the `[Zones]` section of the .ini file **Read carefully:**\r\n  1) Check the **Snap to layout** option (`UseZones=1` in the .ini).\r\n  2) Configure your layout by opening several *Test Windows* from the tray.\r\n  3) Arrange those windows across all of your monitors as you you wish.\r\n  4) Go again to the tray menu and hit **Save test windows as snap layout**\r\n  5) A confirmation dialog will ask you if you want to save, hit yes.\r\n  Now you will be able using the Shift key to sanp the window you move to the\r\n  pointed zone, Add the Ctrl key and drag the cursor to extend the windows\r\n  across several zones. If the cursor is close from two or more zones then\r\n  the window will also be extended to several zones. Use the `InterZone`\r\n  value to adjust this threshold distance in pixels (default 32).\r\n\r\n* New: Added the **Restore FancyZones snapped windows** option in the\r\n  Advanced tab and `FancyZone` option in the `[Zones]` section of the ini.\r\n  set it to 1 if you want AltSnap to be able to restore windows that were\r\n  snapped using PowerToys' FancyZones. This only applies to x86_64 builds\r\n  of AltSnap. I highly recommend this to FancyZones users.\r\n\r\n* New added a `AResize` whitelist in the `[Blacklist]` section of the .ini\r\n  file in order to force altdrag to resize windows that do not have the\r\n  `WS_THICKFRAME` style, when the Resize all windows option is disabled.\r\n\r\n* New: Added the option to move windows via AltDrag without hotkey,\r\n  by clickling on the titlebar. It is similar to the **hooks windows**\r\n  feature that was present in the original AltDrag and can be activated\r\n  via the `TitlebarMove` option in the `[Advanced]` section of the .ini.\r\n\r\n* New: Now a **modifier key** can be set instead of the invert Move/resize\r\n  key in order to use an lternatye set of customizable actions for all\r\n  buttons. They can be configured in the Mouse tab of the config dialog,\r\n  or manually in the .ini, using a B sufix for buttons eg LMBB=Resize.\r\n\r\n* New: Maximize Vertically action, use Shift to maximize horizontally.\r\n\r\n* Changed default `RefreshRate` to 0 to favor smoothest movement instead\r\n  of performances also default is now `MoveRate=1` and `ResizeRate=2`.\r\n\r\n* Restore informations for snapped windows are now stored in Windows\r\n  properties. This simplifies the code, and allows altdrag to be restarted\r\n  without loosing restore info, also restore informations become shared\r\n  between different AltSnap instances.\r\n\r\n* Updated to tdm-gcc-10.3 for i386 and x86_64 builds with one compiler.\r\n\r\n* Updated Chinese translation by *Yatao Li* (zh_CN.ini).\r\n\r\n* Updated German translation by *Ichisich* (de_DE.ini).\r\n\r\n* Fixed: Sometime the mouseup would triger a menu after an action.\r\n\r\n* Fixed: potential crash using the config pannel.\r\n\r\n* Fixed: display maximize/restore animations when using the maximize action\r\n\r\n* Fixed: avoid to play the minimize/restore animations when unrolling\r\n  a maximized-rolled window.\r\n\r\n* Fixed: Now cloacked windows will no longer be snapped to, this also\r\n  prevents windows from snapping to others through different virtual\r\n  desktops under Win10.\r\n\r\n* Fixed: When disabling the \"Resize all windows\" option, then windows would\r\n  no longer snap properly, even if they were resizeable.\r\n\r\n== AltDrag 1.46 ==\r\n\r\n* Fix -elevate command line parameter being ignored. this also fixes the\r\n  **Elevate to administrator priviledge** option for autostart.\r\n\r\n* Fix major bug: AltDrag would capture the wheel input when Alt Was pressed\r\n  even if `Nothing` was selected as wheel action.\r\n\r\n* Minor code tuneup\r\n\r\n== AltDrag 1.45 ==\r\n\r\n+ New: Now the `ScrollLockState` option in the [Input] section of the ini\r\n  file can be set to 3 to enable AltDrag only when Scroll Lock is off.\r\n\r\n* Fixed: Now the `SWP_NOSIZE` and flag is used when simply moving a window.\r\n  This prevents rolled windows from partially unrolling. Also the\r\n  SWP_ASYNCWINDOWPOS flag was added where applicable and this fixes\r\n  an ugly Win 10 bug that would changes the borders of some moved window.\r\n\r\n* Fixed: When using maximizing a window by snapping to the top,\r\n  it would sometime prevent further movement when FullWin=0.\r\n\r\n* Fixed a last minute bug introduced in 1.44 that would restore rolled\r\n  windows as soon as you moved them.\r\n\r\n* Fixed: Now when AltDrag is suspended with the Scroll lock state option,\r\n  The notification icon will change.\r\n\r\n* Fixed some stuck alt bugs thanks to **scx**.\r\n\r\n\r\n== AltDrag 1.44 ==\r\n\r\n+ **Smart aero dimensions** was added in the General Tab of the config.\r\n  With this option checked (default) AltDrag will adjust the dimensions of\r\n  the snapped window to the other snapped windows that were resized.\r\n  Also snapped windows will still be restored by the move action even after\r\n  having been resized. This was suggested by *KoleckOLP*. MDI also work.\r\n\r\n+ New important feature: The **Resize other snapped windows with Shift**\r\n  option was added in the General tab of the config. If it is checked, then\r\n  any window snapped or touching to sides of the currently resized window\r\n  will be resized to remain stuck to the current window when you press the\r\n  Shift key. If you want to always resize the touching windows, then you\r\n  can manually set StickyResizing=2 in the [General] tab in AltDrag.ini.\r\n  In this case, pressing shift will prevent the \"sticky resizing\".\r\n  MDI windows are also supported.\r\n\r\n+ New setting to enable/disable AltDrag based on **Scroll Lock** state.\r\n  see in the Keyboard Tab.\r\n\r\n+ Now an action can be selected for both scroll wheels independently.\r\n\r\n+ New action for scroll wheel: Horizontal scroll.\r\n\r\n+ New now the '*' joker can be used at the end of the class or at the\r\n  beginning of the title, in the form: `*end of title|class start*`\r\n  Example: `*|Winamp*`. This may be useful to make better rules.\r\n  Note that the processes blacklists are not concerned by this.\r\n\r\n+ New: If the first element of a blacklist is *|*, then all windows that\r\n  are not listed will be considered as part of the blacklist. This turns\r\n  the blacklist into a whitelist ie: list of windows for which AltDrag\r\n  will be enabled. It can be useful if you only want to use AltDrag on\r\n  very few programs, then you just enable it on those programs.\r\n  Both title|class and processes.exe styles are supported.\r\n  Exemple: `Processes=*|*, explorer.exe, notepad.exe` will enable AltDrag\r\n  only on the explorer and the notepad windows.\r\n\r\n+ New setting: UseCursor=4 in the [Advanced] section of AltDrag.ini,\r\n  in order to use the ResizeAll cursor for movement instead of the Hand.\r\n\r\n+ New: Now more info are displayed in the Identify window section in the\r\n  options to help debugging.\r\n\r\n+ New: Now the key used to transform scroll in Horizontal scroll can be\r\n  chosen using the `HScrollKey` option in the `[Input]` section of\r\n  AltDrag.ini. Default is 10, you can set an empty value to remove the\r\n  ability of scrolling modification. Note that It only applies when the\r\n  **Scroll inactive windows** option is checked.\r\n\r\n* Fixed: When snapping to the top of the monitor in maximize mode, dragging\r\n  the window to a corner would make a maximize-resized window instead of a\r\n  snapped window.\r\n\r\n* Fixed: now the snapping region when using Mimic Aero snap option will no\r\n  longer extend beyond aero-threshold distance in the corners.\r\n\r\n* Fixed: the **Lower windows with middle clicking on title bars** as well\r\n  as the **Roll/Unroll windows with Alt+Scroll on title bars** now work\r\n  better and lets user closes the tabs on Sumatra PDF with middle click.\r\n  The options also apply properly to MDI windows now.\r\n\r\n* Fixed: now the center action will no longer apply to Maximized windows.\r\n\r\n* Fixed Process blacklist not working on Windows 8.1\r\n\r\n* Fixed: the cursor at the End of a movement would force the repaint of\r\n  a 256x256 pixels around it. This is no longer the case.\r\n\r\n* Fixed: Hotkeys list would not be read properly sometime.\r\n\r\n* Fixed: Now windows focusing will work properly inside MDI windows.\r\n  Also advanced mouse actions now work properly inside MDI.\r\n\r\n* Fixed: now the MMBLower blacklist will only apply to the middle-click in\r\n  the title bar and the normal restore option.\r\n\r\n* Maximized-rolled window will now be restored to the pre-maximized state.\r\n  Rolled-maximized-rolled-unrolled windows, will be restored to the first\r\n  rolled state with the memory of the rolled state, as expected.\r\n\r\n* Now the config dialog box no longer instantly applies the settings.\r\n  This simplifies the code and is more desirable in my opinion. You now\r\n  need to click OK or Apply in order to apply the settings. This also\r\n  avoids useless confusion when compared to a normal property sheet.\r\n\r\n* Fixed: Now Ctrl+Alt+Click will focus windows without needing to move\r\n  them or to press Ctrl after the click.\r\n\r\n* Fixed: Now the Max Aero Speed will also apply to top snapping.\r\n\r\n* Fixed: now the application icon will display properly when Alt+Tabbing.\r\n\r\n* Fixed: the Shift key was not working properly to enable snapping when\r\n  all snapping was disabled.\r\n\r\n* Fixed: a Rolled then double-clicked-snapped window will now be restored\r\n  to its pre-rolled state, as expected.\r\n\r\n* Fixed: The AltDrag icon is now properly displayed in Alt+Tab window.\r\n\r\n* Better monitor handling on old windows.\r\n\r\n* Other minor fixes and code improvement, leading to smaller exe.\r\n\r\n== AltDrag 1.43 ==\r\n\r\n+ New Wiki for altdrag usage: https://github.com/RamonUnch/AltDrag/wiki\r\n\r\n+ New: An option to make the window translucent while dragging was added.\r\n  See MoveTrans in the [General] section of AltDrag.ini. You can change it\r\n  via the Advanced tab, using the opacity while moving option, from 1-254.\r\n  Use 255, 0 or an empty value to disable (default).\r\n\r\n+ Now the AeroMaxSpeed calculus is based on a timer rather than the number\r\n  of mouse frames. The time intervals for the measurement can be specified\r\n  using the AeroSpeedTau variable in milliseconds in the [Advanced] section\r\n  of AltDrag.ini (default 32ms). The max speed can now be specified in the\r\n  Advanced tab of the config. Good values are around 10-100px/32ms. Use\r\n  65535 or an empty value to disable (default). recomended: 64px/32ms.\r\n\r\n+ New: SSizeMove blacklist was added in the [Blacklist] section of the ini.\r\n  Any windows added in this list will NOT receive the WM_ENTERSIZEMOVE and\r\n  WM_EXITSIZEMOVE messages when moved or resized. This is useful for some\r\n  buggy applications such as iTunes (default value is *|iTunes).\r\n\r\n+ New: AltDrag.xml file that can be imported from the Task Scheduler in\r\n  order to setup auto start in elevated mode.\r\n\r\n+ Updated Spanish translation by *Carlos SÃ¡nchez*.\r\n\r\n* Now an AMD64 build of AltDrag, can be compiled. builds are not provided\r\n  because there are no real benefits for now (use mk64.bat).\r\n\r\n* Removed dependency to msvcrt.dll. This avoids some mess and reduce the\r\n  suspiciousness of the AltDrag.exe file to antiviruses. This also reduces\r\n  the size of the exe.\r\n\r\n* Fixed: Windows borders will now properly snap to taskbar on the second\r\n  monitor. Instead of looking for the taskbars, I chose to look tor the\r\n  rcWork field of the monitor info that directly contains the area in which\r\n  windows should be sanpped. This also simplifies the code.\r\n\r\n* Fixed: a snapped, then maximized window will be restored to its original\r\n  size when alt-dragging it out of maximized state. If a windows like this\r\n  is restored by double-click, then it will be restored to the previously\r\n  snapped state and its normal position will be restored only when moving\r\n  it out of its maximized state like expected.\r\n\r\n* Fixed: Now the ESC key will always release Ctrl and Shift.\r\n\r\n* Fixed: Added  the DEL key (2E) to the default Killkeys list.\r\n\r\n* Fixed strange cropping bug that occasionally occurred with Chromium based\r\n  Programs such as several Browsers and VSCode.\r\n\r\n* Fixed potential segmentation fault in the `Enum` code.\r\n\r\n* Fixed potential division by zero.\r\n\r\n* Now all the memory should be unallocated when unloading hooks.dll. This\r\n  avoids memory leaks of a couple of KB when disabling/enabling AltDrag.\r\n\r\n* Fixed some occasional problem with snapping in older windows versions.\r\n\r\n* Fixed: Now spaces can be added after a coma in a blacklist.\r\n\r\n* Added StartMenuExperienceHost.exe,SearchApp.exe to the default process\r\n  blacklist, thanks *LittleboyHarry*.\r\n\r\n* Added *|classFoxitReader to the default MDI blacklist.\r\n\r\n* Minor code cleanup.\r\n\r\n== AltDrag 1.42 ==\r\n\r\n+ Now Ctrl+Alt+Double-Left-Click will minimize the pointed window.\r\n\r\n* Avoid some more 'Stuck alt' bugs by better checking the key state.\r\n\r\n* WARNING: The Hotclick values have changed, check your configuration if you\r\n  use mouse button to activate AltDrag.\r\n\r\n* Now the Killkeys list also contains tle 'L' key (4C) by default, this will\r\n  fix AltDrag problem if you use Win as a hotkey and use Win+L\r\n\r\n* The MDIs blacklist was also updated with *|classFoxitReader.\r\n\r\n* Improved the Roll/Unroll window action: now the file explorer windows will\r\n  be really reduced to the title bar under Win10, until the user moves it.\r\n\r\n* Re-introduced left and right control option in the GUI keyboard tab.\r\n\r\n* Fixed: Process blacklists, now compatible with all versions of PSAPI.DLL.\r\n\r\n* Fixed: The LowLevelMouseProc@12 should never have been exported by\r\n  hooks.dll because it is only internally used. It does not change anything\r\n  for the user but fixes potential vulnerabilities.\r\n\r\n* Fixed: The scroll action is no more disabled on non full screen windows\r\n  when they have no system menu. It fixes problems with VS Code and Discord.\r\n\r\n* Fixed: The cursor will no longer be unconditionally unclipped when\r\n  releasing Shift or Ctrl keys.\r\n\r\n== AltDrag 1.41 ==\r\n\r\n* Fixed compilation flags in the release build and Switched to NSIS 2.46\r\n  and TDMGCC. to avoid false positives with some antiviruses. This also\r\n  results in even smaller exe and dll.\r\n\r\n* Minor dialog adjustement to help with russian language.\r\n\r\n* More translation corrections and improvements from *Alexandr Smolnikov*,\r\n  *Yatao Li* and myself.\r\n\r\n== AltDrag 1.40 ==\r\n\r\n+ NEW: Action menu can now be selected as a mouse action and will pop up\r\n  a menu that let you chose a list of others actions.\r\n  Thanks to *Yatao Li* (yalti) for implementing this action.\r\n\r\n+ New a kill action was added and can be activated with Ctrl+Alt+F4 or by\r\n  using the Action menu, after activating the option. The Pause blacklist\r\n  applies to this action.\r\n\r\n+ New Test Window that shows the resizing regions was implemented and is\r\n  available in the Advanced tab (suggested by *redactedscribe*).\r\n\r\n* Fixed: Some windows could not be created under older WinNT versions.\r\n\r\n* Fixed: Now the windows registered by hooks.dll will be unregistered when\r\n  unloading it (Under Win9x it was unnecessary but we are under NT...).\r\n\r\n* Fixed: Makefile mk.bat is now compatible with MingW's GCC 10.2\r\n\r\n* More fixes to French Translation by *TroudhuK*.\r\n\r\n* Russian translation improvement by *Alexandr Smolnikov* (bigcrush).\r\n\r\n* Chinese translation improvement by *Yatao Li* (yalti).\r\n\r\n== AltDrag 1.39 ==\r\n\r\n* New the LowerWithMMB option can now be set to 2 and you will need Alt to\r\n  be pressed to lower the windows with middle click on title bar.\r\n\r\n* New: An 'Enable on full screen windows' option was added in the advanced\r\n  tab of AltDrag default is on like previous versions. A full screen window\r\n  is a windows that fits exactly into the monitor and has no title bar.\r\n\r\n* New/fix: A Killkeys list was added in the [Input] section of AltDragh.ini.\r\n  It contains a list of key that will disable AltDrag when pressed down.\r\n  Default value is 09 for the TAB key. This fixes a bug with DisplayFusion's\r\n  Alt+Tab feature (Thanks *Daniele-f*).\r\n\r\n* Fix: Made ESC key a bit more aggressive in disabling AltDrag.\r\n\r\n* Minor refactoring and code cleanup, towards a more generic key mapping.\r\n\r\n* Fixed French translation thanks *TroudhuK* and his very funny name...\r\n\r\n== AltDrag 1.38 ==\r\n\r\n+ GUI changed: Mouse and Keyboard are now separated tabs and contain more\r\n  options. All the new options should be available. Have a look!\r\n  Translation is supported but not updated outside of FR and IT.\r\n\r\n+ New: You can now invert the behavior of the shift key for double-right-\r\n  click action (Resize) that aerosnaps or extends windows borders to monitor\r\n  depending on the state of the Shift key. See the advanced tab.\r\n\r\n+ New: You can now set the Hotclicks variable in the [Input] section of the\r\n  ini file to add the mouse buttons as hotkeys (hence the Hotclick name).\r\n  In the case the mouse button is also mapped to an action, the action will\r\n  be performed on a single click. For example you can set MB4=Move,\r\n  MB5=Resize and Hotclicks=80 81 and the mouse 4/5 button will respectively\r\n  Move/Resize the window without needing to press any other button or key.\r\n  In all cases this click will not be usable for anything else than AltDrag.\r\n  Action suggested by *displayerror*.\r\n\r\n+ New Hotkey combo is now available. Set KeyCombo=1 in the [Input] section\r\n  of AltDrag.ini and you will need to press two of the hotkeys in order to\r\n  activate AltDrag. This was suggested by *MarqueIV*.\r\n\r\n+ New: The keyboard can now be used to activate AltDrag without clicking.\r\n  For example set GrabWithAlt=Move in the [Input] section of AltDrag.ini.\r\n  Press Alt and the pointed window will directly be moved wen moving the\r\n  mouse without requiring a click. You can set any other action. I advise\r\n  to use a hotkey combo for this feature or to use a very useless key on\r\n  your keyboard. Action suggested by *pixelbase*.\r\n\r\n+ New: A key can be set to toggle between move and resize action. it can be\r\n  used in order to have a single click configuration that will turn into the\r\n  other action when pressing this key. This later can be set with the\r\n  ToggleRsMvKey in the [Input] section of AltDrag.ini. You can set it to A2\r\n  for example and have Ctrl+Alt+LClic => Resize instead of Move. Leave it\r\n  empty if you do not want this feature. Only one key can be specified.\r\n  It can also be combined with a hotkey. You could for example use Alt+LClick\r\n  to move and Win+LClick to resize with a single instance of AltDrag.\r\n\r\n+ New: The Ctrl key can be presses and released when a hotkey is on in order\r\n  to prevent AltDrag from grabbing a window.\r\n  Exemple: Alt+Clicl => Move window with AltDrag. Alt+Ctrl_down+Ctrl_up+Click\r\n  Will be like a Simple Alt+Click without AltDrag running.\r\n\r\n- Removed PearceDBClick option that was buggy and is now mostly unnecessary.\r\n\r\n* Fixed: Now the doubleclick actions will check that the same button/key\r\n  was used for both clicks.\r\n\r\n* Fixed: Ctrl delay problem. Now Alt+Ctrl should not need to wait for the\r\n  keyboard auto-repeat delay. It was a stupid bug sorry for that...\r\n\r\n* Fixed potential bug in the hook chain.\r\n\r\n* Changed the cursor window no longer capture the input as it should not\r\n  be necessary and may lead to some bugs. The cursor code was also made a\r\n  bit more conservative.\r\n\r\n== AltDrag 1.37 ==\r\n\r\n+ GUI New: now the Identify window option will show the program image name.\r\n\r\n+ GUI Fixed: re-introduction of the Advanced tab in the options with more\r\n  options that previously required direct ini file edition. This should be\r\n  helpful for all users. It is not yet translated though.\r\n\r\n* Fixed: Now moveable full screen windows should be restored to full screen\r\n  when changing monitor. This was not working properly in 1.36. Note that\r\n  many full screen windows are really not moveable anyway.\r\n  Under Windows 10 the file explorer will behave correctly, not Firefox.\r\n\r\n* Fixed: the Scroll list was added in the [Blacklist] section of AltDrag.ini\r\n  in order to disable the scroll action for any window. In addition the\r\n  Processes blacklist will apply to scroll action as well.\r\n\r\n* Fixed bug when the origin monitor was a NULL pointer in some cases under\r\n  older windows versions.\r\n\r\n* Fixed ini file: the proper name of the two settings about max aero speed\r\n  are AeroMaxSpeed and AeroSpeedInt.\r\n\r\n* Fixed: manifest file now fallback to per monitor dpi awareness version 1\r\n  if version 2 is not available ie. Win 8.1 and Win10 before build 1703.\r\n\r\n* More code cleanup, some code was moved to functions and potential NULL\r\n  pointer dereferencing were fixed.\r\n\r\n* GUI Fixed: Now the Snaplist has to be edited with the ini file and the\r\n  Scroll blacklist is visible instead (much more useful). Snapplist is\r\n  a quite advanced detail anyway.\r\n\r\n== AltDrag 1.36 ==\r\n\r\n+ Added MMMaximize option in the [General] section of altdrag.ini in order to\r\n  restore old AltDrag behavior (thanks brian6932):\r\n  Set to 1 to maximize/restore on left+right click (default).\r\n  Set to 2 to restore on a single left click instead of a drag.\r\n  Set to 3 for both (like the original AltDrag).\r\n  Set to 0 to disable any of those.\r\n\r\n+ Now the AeroMaxSpeed value can be set to put a speed limit beyond which the\r\n  moved window will not be Aero-Snapped. This is useful to move windows\r\n  between monitors without \"flicker\". You have to set AeroMaxSpeed and\r\n  AeroSpeedInt in the [Advanced] section of AltDrag.ini.\r\n  AeroMaxSpeed is in pixels/X frames (from 1-65535)\r\n  AeroSpeedInt to specifies the number of frames (default 1) from 1-255.\r\n  To set this value: (i) See the frequency of your mouse and set an\r\n  AeroSpeedInt to average over 10ms or so, so if you have a 1kHz mouse,\r\n  set it to 8-10, if you have a ~100Hz mouse (typical) keep it to 1 or 2.\r\n  (ii) Set AeroMaxSpeed to a \"high\" value (like 50) and try to move fast\r\n  a window between two monitors, if it get aero-snapped, decrease the value\r\n  until it \"just\" no longer snaps. (iii) Check that the window does snap\r\n  when you want it to sap, if the window tends to restore when you do not\r\n  want, increase the AeroMaxSpeed value.\r\n\r\n+ Roll/Unroll action was added: It collapses the window in its title bar.\r\n  It can also be used with the move action (Alt+Shift+DoubleLeftClick).\r\n  You can also set RollWithTBScroll=1 in the [Input] section of your ini file\r\n  to enable Alt+Wheel to roll/unroll window when pointing to their title bar.\r\n  If not pointing to the title bar the normal Scroll action will be performed.\r\n  If Ctrl is pressed the normal Scroll action will always be performed\r\n\r\n+ New: Now when using Alt+Shift+DoubleRightClick, the window will be extended\r\n  to the corner/border of the monitor according to which area of the window\r\n  was double clicked. Alt+DoubleRightClick works as before and Aero-snaps\r\n  the window to the monitor sides/corners. Finally to Maximize a window you\r\n  can use Alt+Ctrl+DBLeftClick on the center portion of the window (this is\r\n  useful if you use a single button config with resize center set to \"move\".\r\n\r\n+ New: Now the AlphaDelta and AlphaDeltaShift value can be set into the\r\n  [Advanced] section of AltDrag.ini to tune from -128 to +127 the step at\r\n  which the transparency is changed when using the Transparency Action.\r\n  Default is 64 and 8 with the Shift modifier. You can put negative values\r\n  if you want to invert wheel Up/Down direction.\r\n\r\n* Fixed/New: When Aero-snapping with AltDrag, the window can be restored\r\n  via the title bar like normal. This is enabled if NormRestore=1 in the\r\n  [General] section of AltDrag.ini.\r\n\r\n* Fixed/New: Now a full screen window will be resized to full screen when\r\n  moving it to a different monitor. If you want you can set ResizeAll=3\r\n  to force move/resize of all full screen window. Keep in mind that some\r\n  full screen windows are really not resizable (eg Firefox and Edge).\r\n\r\n* Fixed: Now if MinAlpha is set to 0, it will be clamped back to 1, because\r\n  setting to zero the alpha of a window disables any interaction with it.\r\n  Everyone should also add \",Program Manager|Progman\" to their windows\r\n  blacklist (without the quotes).\r\n\r\n* New: Improved the AltDrag.txt file, read it for some basic documentation.\r\n\r\n* Fixed: cleaned up some code and corrected potential bugs, moved some more\r\n  code into functions.\r\n\r\n* Fixed: Now the AutoRemaximize option should always work.\r\n\r\n== AltDrag 1.35 ==\r\n\r\n* Changed: to simplify the code and avoid bugs, the Ctrl is no longer\r\n  suggested as a hotkey and if using it (using the ini file) other Ctrl\r\n  functions will be unavailable (it was buggy in the first place anyway).\r\n\r\n* Fixed a typo in the Alt+Tab scroll actions that lead to some bugs.\r\n\r\n* Fixed: Ctrl in some cases does not work properly to retain window\r\n  in current monitor and would be stuck sometime (thanks redactedscribe).\r\n  To avoid those problems that are specific to Ctrl, the Shift key can now\r\n  be used to restrict cursor to current monitor when dragging a window.\r\n\r\n* Fixed: When adding a monitor, AltDrag needed a restart for Aero Snapping\r\n  to work properly, this is no longer the case.\r\n\r\n* Fixed .manifest file so that proper windows version can be obtained.\r\n\r\n* GUI fixed: Now under Windows 10, the 'scroll inactive window' option will\r\n  be grayed out unless it is activated, so that users do not enable it by\r\n  mistake and to make it clear that it is useless for Win10.\r\n\r\n* GUI Fixed: Now if desktop composition is enabled, it will no longer be\r\n  possible to disable the Drag Full Window option (GDI Performances problem).\r\n\r\n== AltDrag 1.34 ==\r\n\r\n+ Added MMBLower in the [Blacklists] section of AltDrag.ini in order to\r\n  disable the \"Lower windows by middle clicking on the title bar\" option\r\n  for any window. use the name|class format.\r\n  Example: MMBLower=*|CASCADIA_HOSTING_WINDOW_CLASS\r\n  if you want to close tabs with middle click on Windows Terminal.\r\n\r\n* Fixed: now the Lower action will deselect the lowered window if possible\r\n  so that it can be reselected easily (thanks redactedscribe).\r\n\r\n* Fixed: Now when a windows is snapped normally under windows,\r\n  it will be restored properly if AltDragging it out. If a window is\r\n  snapped with AltDrag, however it can only be restored with AltDrag.\r\n\r\n* Fixed: Scroll Action was restored to the 1.29 version behavior (kimks3).\r\n\r\n== AltDrag 1.33 ==\r\n\r\n+ Added a MinAlpha option in the [Advanded] section of AltDrag.ini, in order\r\n  to adjust from 0 to 255 the minimum opacity of a windows (default is 8).\r\n\r\n* Fixed AltDrag freezing when changing DPI scaling or going to sleep mode.\r\n\r\n* Fixed Stupid bug that would restart AltDrag wen moving windows between\r\n  monitors with different DPI scaling.\r\n\r\n* Improved English on the snapping windows option (thanks redactedscribe).\r\n\r\n* Now settings should be kept when updating AltDrag (thanks FSund).\r\n\r\n== AltDrag 1.32 ==\r\n\r\n+ Added the PearceDBClick option in [Advanced] section of Altdrag.ini.\r\n  Use 1 to disable the maximize on Alt+double-cklick. It only applies to\r\n  the Move action for now, maybe more will come if needed.\r\n\r\n+ Added the UseCursor option in the [Advanced] section of AltDrag.ini\r\n  Use 0 to disable any cursor handeling (not recomended).\r\n  Use 1 to enable all cursors changes (default).\r\n  Use 2 to disable only the Hand cursor when dragging a window (icyhoty2k).\r\n  Use 3 to always use the default cursor, even when resizing.\r\n  Note that none of those settings is expected to affect performances in\r\n  any significant way.\r\n\r\n+ Now when pressing the SHIFT key while using doubleclick snapping on the\r\n  center-top section of the window, this later will be maximized/restored,\r\n  instead of being snapped to the top. This will be usefull when using\r\n  the Move instead of resize-center option.\r\n\r\n* Lower with Middle mouse button option will no longer ignore the window\r\n  blacklist, this will avoid interactions with taskbar.\r\n\r\n* Fixed Scroll inactive windows, hopefully for real this time.\r\n\r\n* Avoid some more loockup in the case of very unresponsive windows by using\r\n  PostMessage instead of SendMessage, when applicable.\r\n\r\n* Fixed: Now doubleclick snapping will respect Aero(H/V)offset settings.\r\n\r\n* Fixed some more minor drawing problems when using FullWin=0\r\n\r\n== AltDrag 1.31 ==\r\n\r\n+ Added option to replace the resize center mode with Move mode.\r\n  GUI was adjusted accordingly\r\n\r\n* Improved the non full windows dragging mode, it will no longer move the\r\n  window when it snaps but only the transparent square and the window will\r\n  be moved when click is released as expected.\r\n\r\n* Simplified window database and removed useless code.\r\n\r\n* Fixed slightly too large window when resizing from a maximized window\r\n  inside an MDI.\r\n\r\n* Fixed some annoying behavior in the in case of unresponsive windows.\r\n\r\n== AltDrag 1.30 ==\r\n\r\n+ Re-introduced the Aero snap at top to maximize a window. this behavior can\r\n  be disabled with the AeroTopMaximizes option in the [Advanced] section of\r\n  AltDrag.ini. The Shift key will also invert the behavior.\r\n\r\n+ Now when auto re-maximize option is on, the re-maximizing can be prevented\r\n  by pressing the shift key before releasing the mouse.\r\n\r\n* Fixed overcompensation of Win10 invisible borders in center mode in the\r\n  case of double click Aero-snapping.\r\n\r\n* Fixed horizontal double-click Aero-snapping maximization in the case of\r\n  MDI windows.\r\n\r\n* Fixed: Now the Volume action is not limited to Vista and later. This later\r\n  will use the WINMM API on NT4/2000/XP to change the waveOut volume.\r\n\r\n* Fixed the Scroll inactive windows option, that would prevent scrolling\r\n  in all metro apps under Win 10. Note that I advise against using this\r\n  option anyway because Win 10 does it already natively by default.\r\n\r\n* Now \"Start|Windows.UI.Core.CoreWindow\" is in the default blacklist.\r\n  This will avoid AltDrag interactions with Win10's Start menu.\r\n\r\n== AltDrag 1.29 ==\r\n\r\n+ Added Maximize scroll action that behaves as expected: wheel up maximize\r\n  the pointed window, wheel down restore a maximized window and minimize to\r\n  taskbar a normal window. This action was proposed by bluebird11.\r\n\r\n+ Now when Aero-snapping with double right-click, the window will be resized\r\n  to full monitor width when double-clicking on the center of the window\r\n  while pressing the shift key.\r\n\r\n* The cursor is now properly limited to MDI client area when using Ctrl.\r\n\r\n* Cleaned up some code by removing useless global variables.\r\n\r\n* Lower action will no longer ignore the AutoFocus config flag.\r\n\r\n* Minor refactoring, moved some code toward function and fixed some gcc's\r\n  -Wsign-compare warnings.\r\n\r\n* Fixed: Sometime when pressing escape while resizing, it would prevent\r\n  further window move/resize.\r\n\r\n* Rewrote the auto remaximize procedure. It is now much simpler and handier\r\n  in my opinion. The window is now remaximized when released on the current\r\n  monitor, if it was maximized when move started AND was dragged to an other\r\n  monitor. There is no more 1s delay option...\r\n  Note this procedure was not working properly on previous releases.\r\n\r\n* Fixed: Position of the mouse cursor relative to the restored windows\r\n  should be always correct now, this was a stupid bug I introduced...\r\n\r\n* Fixed: Desktop window is now properly ignored.\r\n\r\n* Fixed: When using Ctrl, the cursor will be properly restricted to the\r\n  current monitor.\r\n\r\n* Removed unused variables and cleaned up some code.\r\n\r\n* Remove hard dependency to ole32.dll, it will be loaded only when using\r\n  the Volume action.\r\n\r\n== AltDrag 1.28 ==\r\n\r\n+ Added hardening flags for gcc.\r\n\r\n+ Added a RefreshRate in the [Performance] section of AltDrag.ini that\r\n  allows you to set a minimum time in milliseconds between two Windows\r\n  Redraw when FullWin=1, I recommend a value that corresponds to the\r\n  refresh rate of your monitor ie: 60Hz => RefreshRate=16.\r\n\r\n+ Added Maximize action, it can be used to toggle the maximized state,\r\n  combine with Shift to minimize. (Thanks to Jim Teunis for suggestion).\r\n\r\n+ Added the CenterFraction in the [General] section of AltDrag.ini to adjust\r\n  The size of the region in percent that is used for the center resizing\r\n  mode. Default is 24% meaning 38% for the sides. You can, for example set\r\n  it to 0 to enable a 4 regions mode instead or the 9 default regions.\r\n  You can also set CenterFraction=100 and combine with the ResizeCenter=0\r\n  option in order to have a pure bottom right mode.\r\n\r\n+ Added AeroThreshold option in the [Advanced] options. Default value is 5.\r\n  It corresponds to the threshold distance in pixels at which a window will\r\n  be snapped automatically to the monitor (aero style). If you do not like\r\n  windows snapping for a fraction of second when changing monitors, try to\r\n  set this value to only 2, in such a case it will be necessary to use Ctrl\r\n  to snap windows between monitors. On the other hand if you want you can\r\n  increase this value and this will make snapping between monitors easier\r\n  without Ctrl key...\r\n\r\n* Removed dependency to Advapi32.dll from hooks.dll (it was unnecessary).\r\n\r\n* Fixed: An Aero-snapped window will now require mouse movement before\r\n  moving, instead of a simple Alt+Click.\r\n\r\n* Fixed when a window is in full screen you will actually need to move the\r\n  mouse in order to resize it.\r\n\r\n* Fixed a remaining Win 10 invisible borders bug that would shrink slightly\r\n  a window when resizing it from a full screen state.\r\n\r\n* Fixed application hang when changing DPI scaling under Win10. Note that\r\n  for the moment the solution is to restart AltDrag when receiving the\r\n  WM_DPICHANGED message, I hope to have better solution in the future.\r\n\r\n* Fixed bug in Transparency action where the windows transparency could no\r\n  longer be modified in some cases.\r\n\r\n* Misc. cleanup and code refactoring here and there + Fixed all warnings.\r\n  using gcc -Wall parameter.\r\n\r\n* Minor GUI improvement for WinNT4 and Win2000.\r\n\r\n== AltDrag 1.27 ==\r\n\r\n+ Added Elevate option to the tray menu as suggested by Loxaan Oxyde.\r\n\r\n+ Added Pause Process option, use Alt+Shift+Pause to pause the process\r\n  of the windows under your cursor, press Alt+Pause to Resume.\r\n  The Option AgressivePause must be set to 1 in [Input] config.\r\n  Use the associated Pause blacklist. This function needs XP or later.\r\n  Note 1: This is a very aggressive option use with caution.\r\n  Note 2: The windows of the paused process will no longer be drawn leading\r\n  to screen tearing on the windows itself.\r\n  Note 3: If you use WIN as a hotkey, then you can still obtain the\r\n  WIN+PAUSE System Properties by pointing first the cursor to the taskbar.\r\n\r\n+ Now when using Aero Snap, and resizing towards the top, the windows will\r\n  be maximized vertically when the cursor will touch the top of the screen.\r\n  Same behavior for the left. This behavior is ONLY for the top and left\r\n  when using respectively the pure top and pure left resize modes.\r\n\r\n* Actually fixed DPI scaling under Win10 with the .manifest I made a typo\r\n  in the first place and never fixed it, because I was not using DPI scaling\r\n  and I thought I was...\r\n\r\n* Fixed the toggle borderless action under Windows 10, the window would\r\n  not be properly refreshed because of buggy DWM.\r\n\r\n* Fixed: Now the Transparency action will not ignore blacklists.\r\n\r\n* Improved translation handling, now all translations are ini files in the\r\n  \"Lang\" subdirectory of AltDrag. This will simplify addition of new\r\n  Locals, this also allow anyone with notepad to fix his own language.\r\n  Finally you can remove languages that you donot need and if you want only\r\n  english you can remove the whole \"Lang\" directory.\r\n\r\n* Updated zh_CN.ini (Chinese) with Zepp Lu's corrections\r\n\r\n* More French and Italian corrections.\r\n\r\n== AltDrag 1.25 ==\r\n\r\n* Fixed Memory leaks.\r\n\r\n== AltDrag 1.24 ==\r\n\r\n* Fixed crash in the config dialog.\r\n\r\n* Fixed: Some windows such as mplayer's windows can now be resized again.\r\n\r\n* Fixed translations in French and Italian in particular.\r\n\r\n* Fixed Incorrect snapping of windows in an MDI under Windows 10.\r\n\r\n* Fixed: Now on a blacklist, an empty title will be considered as a really\r\n  empty title instead of 'any' title. You should use '*|class' to include\r\n  all windows from a given class instead of just |class. This gives a more\r\n  fine control over blacklist to the user.\r\n\r\n* Fixed minor drawing problems when using FullWin=0\r\n\r\n== AltDrag 1.23 ==\r\n\r\n+ Add option to disable resizing windows that are not resizable\r\n  ie: No WS_THICKFRAME. Default is to resize everything.\r\n\r\n* Fixed: Now config dialog can be used on NT4.\r\n\r\n* Fixed: Now AeroSnap takes into account the taskbar on NT4.\r\n\r\n* Fixed: Now when a window is not responding, move/resize will be disabled.\r\n\r\n* Some optimizations were done.\r\n\r\n* Fixed: Windows will be moved/resized in an independent thread avoiding any\r\n  mouse delay/lockup when a window is very unresponsive. This is helpful for\r\n  Slow video drivers on Win8/10, and for web browsers windows.\r\n\r\n== AltDrag 1.22 ==\r\n\r\n+ Added options to choose the Aero Snap ratio. You can now chose the position\r\n  in percentage of screen size, where the AeroSnap corners will meet.\r\n  Default is 50%:50% ie:\r\n  AeroHoffset=50 ; Horizontal from left\r\n  AeroVoffset=50 ; Vertical from top\r\n  You could set for example AeroHoffset to 33, this mean that a windows\r\n  snapped to the left will use only 33% of the screen and a window snapped\r\n  to the right will use 67%. The same logic applies to AeroVoffset for the\r\n  vertical direction. This will be appreciated by the widescreen users.\r\n\r\n+ Added toggle window title bar and border on/off Action (Igor Bochkariov)\r\n  I used a different implementation though. If you want to just disable the\r\n  titlebar and keep borders, press shift.\r\n\r\n* Fixed Transparency action. Now when setting back the windows to an opaque\r\n  state, the WS_EX_LAYERED attribute is removed as it should be. This will\r\n  avoid useless performance issues when using this feature\r\n\r\n* Fixed: Now under Windows 10, the DWM API will be used when available to\r\n  obtain correct window rectangle and avoid gaps between snapping windows\r\n\r\n* Fixed: now full screen windows that have a system menu will not be\r\n  automatically blacklisted.\r\n\r\n* Now a full screen window will not be restored unless the mouse is moved\r\n  instead of a simple Alt+click as before. It was an annoying behavior.\r\n\r\n* Double click will maximize a normal window and restore a maximized window.\r\n\r\n== AltDrag 1.20 ==\r\n\r\n+ Ability to drag only a square instead of the full windows (better perf.)\r\n+ Added an option to replace center resizing mode by bottom-right mode.\r\n+ Added MDIs blacklist: Windows for which MDI behavior will be disabled.\r\n\r\n- No more HookWindows as (unstable and mixing 64 and 32 bit code)\r\n- No more FocusOnTyping (too buggy).\r\n- No more auto updates and internet connectivity.\r\n\r\n* Fixed cursor performances problems, before the cursor windows used alpha\r\n  blending which is very slow. I just told the windows to do nothing when\r\n  it receive the WM_PAINT or WM_ERASEBKGND messages and that's it, this also\r\n  means proper display for all windows versions instead of being limited to\r\n  Windows 2000+\r\n\r\n* Now compatible with Windows NT4 sp3+\r\n* Removed dependencies to shlwapi.dll\r\n* Removed dependency to WININET.DLL\r\n* Dynamically import PSAPI.DLL in case it is missing (it is not much used)\r\n\r\n* Fixed: Cursor windows now captures the mouse input (prevents some bugs).\r\n* Fixed completely opaque blacklist reading procedure, it will be trivial to\r\n  add or remove blacklists from now.\r\n* Fixed some drawing problems (not all).\r\n\r\n* Fixed .manifest information for high dpi awareness.\r\n* Refactoring by putting some code into functions\r\n* Use GetPrivateProfileInt instead of the 'String version for all int values.\r\n* Avoid floating point arithmetic. Only integer math are used.\r\n* Add -nostdlib flag to gcc to avoid useless bloat to the dll and exe.\r\n* Avoid GUI locking when windows is very slow to resize (with FullWin=0 only)\r\n\r\n===========================================================================\r\n== OS Requirement ==\r\nAltDrag should work on NT4sp3+/2000/XP/2003/Vista/7/8.x/10/11.\r\nAlso works on ReactOS (little testing).\r\n\r\nThis program needs at least Windows NT4 service pack 3 or later.\r\nThis is because it relies on the 'LowLevel Keyboard/Mouse Proc' functions\r\nthat is only supported by the NT based Windows and from NT4 sp3. You will\r\nnote that the program also depends on 'SendInput()' that appeared at the\r\nsame time. This later dependency is not necessary but is convenient.\r\n\r\n== END OF FILE ==\r\n"
        },
        {
          "name": "AltSnap.xml",
          "type": "blob",
          "size": 2.744140625,
          "content": "ï»¿<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<Task version=\"1.2\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\">\r\n  <RegistrationInfo>\r\n    <URI>\\AltSnap</URI>\r\n  </RegistrationInfo>\r\n  <Triggers>\r\n    <LogonTrigger>\r\n      <Enabled>true</Enabled>\r\n      <Delay>PT10S</Delay>\r\n    </LogonTrigger>\r\n  </Triggers>\r\n  <Principals>\r\n    <Principal id=\"Author\">\r\n      <GroupId>S-1-5-32-545</GroupId>\r\n      <RunLevel>HighestAvailable</RunLevel>\r\n    </Principal>\r\n  </Principals>\r\n  <Settings>\r\n    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>\r\n    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>\r\n    <StopIfGoingOnBatteries>true</StopIfGoingOnBatteries>\r\n    <AllowHardTerminate>true</AllowHardTerminate>\r\n    <StartWhenAvailable>false</StartWhenAvailable>\r\n    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>\r\n    <IdleSettings>\r\n      <StopOnIdleEnd>true</StopOnIdleEnd>\r\n      <RestartOnIdle>false</RestartOnIdle>\r\n    </IdleSettings>\r\n    <AllowStartOnDemand>true</AllowStartOnDemand>\r\n    <Enabled>true</Enabled>\r\n    <Hidden>false</Hidden>\r\n    <RunOnlyIfIdle>false</RunOnlyIfIdle>\r\n    <WakeToRun>false</WakeToRun>\r\n    <ExecutionTimeLimit>PT0S</ExecutionTimeLimit>\r\n    <Priority>5</Priority>\r\n  </Settings>\r\n  <Actions Context=\"Author\">\r\n    <Exec>\r\n      <Command>%APPDATA%\\AltSnap\\AltSnap.exe</Command>\r\n    </Exec>\r\n  </Actions>\r\n</Task>\r\n"
        },
        {
          "name": "HelpImages",
          "type": "tree",
          "content": null
        },
        {
          "name": "Lang",
          "type": "tree",
          "content": null
        },
        {
          "name": "License.txt",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.33984375,
          "content": "CC=gcc\r\nWR=windres\r\n\r\nWARNINGS=-Wall  \\\r\n\t-Wformat-security \\\r\n\t-Wstrict-overflow \\\r\n\t-Wsign-compare \\\r\n\t-Wclobbered \\\r\n\t-Wempty-body \\\r\n\t-Wignored-qualifiers \\\r\n\t-Wsuggest-attribute=pure \\\r\n\t-Wsuggest-attribute=const \\\r\n\t-Wsuggest-attribute=noreturn \\\r\n\t-Wuninitialized \\\r\n\t-Wtype-limits \\\r\n\t-Woverride-init \\\r\n\t-Wlogical-op \\\r\n\t-Wno-multichar \\\r\n\t-Wno-attributes \\\r\n\t-Wno-unused-function \\\r\n\t-Wshadow \\\r\n\t-Warray-bounds=2 \\\r\n\t-Wstack-usage=4096 \\\r\n\t-Werror=vla \\\r\n\t-pedantic \\\r\n\t-Wc++-compat\r\n\t-Wstringop-overflow=4 \\\r\n\t-Wduplicated-cond \\\r\n\t-Wduplicated-branches \\\r\n\t-Wnull-dereference \\\r\n\r\n# -Wunused-parameter\r\n# -Wtraditional-conversion\r\n# -fira-region=one/mixed\r\n# -Wstack-usage=2048\r\n# -finput-charset=UTF-8\r\n# -Wc++-compat\r\n# -fmerge-all-constants\r\n\r\nCFLAGS=-Os -std=c99 \\\r\n\t-finput-charset=UTF-8 \\\r\n\t-fshort-wchar \\\r\n\t-m32 -march=i386 -mtune=i686 \\\r\n\t-mno-stack-arg-probe \\\r\n\t-mpreferred-stack-boundary=2 \\\r\n\t-momit-leaf-frame-pointer \\\r\n\t-fno-stack-check \\\r\n\t-fno-stack-protector \\\r\n\t-fno-ident \\\r\n\t-fomit-frame-pointer \\\r\n\t-fshort-enums \\\r\n\t-fno-exceptions \\\r\n\t-fno-dwarf2-cfi-asm \\\r\n\t-fno-asynchronous-unwind-tables \\\r\n\t-fmerge-all-constants \\\r\n\t-fno-semantic-interposition \\\r\n\t-fgcse-sm \\\r\n\t-fgcse-las \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 \\\r\n\t-Wp,-D_FORTIFY_SOURCE=2 \\\r\n\t$(WARNINGS) \\\r\n\t-fno-plt\r\n\r\nLDFLAGS=-nostdlib \\\r\n\t-lmsvcrt \\\r\n\t-lkernel32 \\\r\n\t-luser32 \\\r\n\t-lgdi32 \\\r\n\t-s \\\r\n\t-Wl,-s,-dynamicbase \\\r\n\t-Wl,-nxcompat \\\r\n\t-Wl,--no-seh \\\r\n\t-Wl,--relax \\\r\n\t-Wl,--disable-runtime-pseudo-reloc \\\r\n\t-Wl,--enable-auto-import \\\r\n\t-Wl,--disable-stdcall-fixup \\\r\n\r\nEXELD = $(LDFLAGS) \\\r\n\t-Wl,--tsaware \\\r\n\t-lcomctl32 \\\r\n\t-ladvapi32 \\\r\n\t-lshell32 \\\r\n\t-Wl,--disable-reloc-section\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooksr.o $(CFLAGS) $(LDFLAGS) -mdll -e_DllMain@12 -Wl,--kill-at\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnapr.o $(CFLAGS) $(EXELD) -mwindows -e_unfuckWinMain@0\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\t$(WR) altsnap.rc altsnapr.o -Fpe-i386\r\n\r\nhooksr.o: hooks.rc\r\n\t$(WR) hooks.rc hooksr.o -Fpe-i386\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "MakefileClang",
          "type": "blob",
          "size": 2.02734375,
          "content": "CC=clang\r\nWR=llvm-rc\r\n\r\n# We need to include MINGW headers files (for i386 here)\r\nMINGW=-ID:\\Straw\\llvm-mingw\\include \\\r\n\t-LD:\\Straw\\llvm-mingw\\i686-w64-mingw32\\lib\r\n\r\n\r\nWARNINGS=-Wall \\\r\n\t-Wformat-security \\\r\n\t-Wstrict-overflow \\\r\n\t-Wsign-compare \\\r\n\t-Wempty-body \\\r\n\t-Wignored-qualifiers \\\r\n\t-Wuninitialized \\\r\n\t-Wtype-limits \\\r\n\t-Wno-multichar \\\r\n\t-Wno-attributes \\\r\n\t-Wnull-dereference \\\r\n\t-Wno-unused-function \\\r\n\t-Wshadow \\\r\n\t-Werror=vla \\\r\n\t-Wno-typedef-redefinition \\\r\n\t-Wno-macro-redefined \\\r\n\t-Wno-unknown-pragmas \\\r\n\t-Wno-missing-declarations \\\r\n\t-Wno-pragma-pack\r\n\r\n# -Wunused-parameter\r\n# -Wtraditional-conversion\r\n# -fira-region=one/mixed\r\n# -Wstack-usage=2048\r\n# -finput-charset=UTF-8\r\n# -Wc++-compat\r\n\r\nCFLAGS=-Os -std=c99 \\\r\n\t-target i386-pc-windows-gnu \\\r\n\t-finput-charset=UTF-8 \\\r\n\t-m32 -march=i386 -mtune=i686 \\\r\n\t-momit-leaf-frame-pointer \\\r\n\t-fno-stack-check \\\r\n\t-fno-stack-protector \\\r\n\t-fno-ident \\\r\n\t-fomit-frame-pointer \\\r\n\t-fshort-enums \\\r\n\t-fno-exceptions \\\r\n\t-fno-dwarf2-cfi-asm \\\r\n\t-fno-asynchronous-unwind-tables \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 \\\r\n\t-Wp,-D_FORTIFY_SOURCE=2 \\\r\n\t$(WARNINGS) \\\r\n\t$(MINGW) \\\r\n\t-DCLANG\r\n\r\n\r\nLDFLAGS=-nostdlib \\\r\n\t-lkernel32 \\\r\n\t-luser32 \\\r\n\t-lgdi32 \\\r\n\t-s \\\r\n\t-Wl,-s,-dynamicbase \\\r\n\t-Wl,-nxcompat \\\r\n\t-Wl,--no-seh \\\r\n\t-Wl,--enable-auto-import\r\n\r\nEXELD = $(LDFLAGS) \\\r\n\t-Wl,--tsaware \\\r\n\t-lcomctl32 \\\r\n\t-ladvapi32 \\\r\n\t-lshell32\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooks.res $(CFLAGS) $(LDFLAGS) -shared -e_DllMain@12 -v -Wl,--kill-at\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnap.res $(CFLAGS) $(EXELD) -mwindows -e_unfuckWinMain@0 -v\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\t$(WR) altsnap.rc\r\n\r\nhooksr.o: hooks.rc\r\n\t$(WR) hooks.rc\r\n\r\nclean :\r\n\trm altsnap.res AltSnap.exe hooks.res hooks.dll\r\n"
        },
        {
          "name": "MakefileClangdb",
          "type": "blob",
          "size": 1.966796875,
          "content": "CC=clang\r\nWR=llvm-rc\r\n\r\n# We need to include GCC headers files (for i386 here)\r\n#MINGW=-ID:\\Straw\\tdm64\\x86_64-w64-mingw32\\include \\\r\n#\t-LD:\\Straw\\tdm64\\x86_64-w64-mingw32\\lib32\r\nMINGW=-ID:\\Straw\\llvm-mingw\\include \\\r\n\t-LD:\\Straw\\llvm-mingw\\i686-w64-mingw32\\lib\r\n\r\n\r\nWARNINGS=-Wall \\\r\n\t-Wformat-security \\\r\n\t-Wstrict-overflow \\\r\n\t-Wsign-compare \\\r\n\t-Wempty-body \\\r\n\t-Wignored-qualifiers \\\r\n\t-Wuninitialized \\\r\n\t-Wtype-limits \\\r\n\t-Wno-multichar \\\r\n\t-Wno-attributes \\\r\n\t-Wnull-dereference \\\r\n\t-Wno-unused-function \\\r\n\t-Wshadow \\\r\n\t-Werror=vla \\\r\n\t-Wno-typedef-redefinition \\\r\n\t-Wno-macro-redefined \\\r\n\t-Wno-unknown-pragmas \\\r\n\t-Wno-missing-declarations \\\r\n\t-Wno-pragma-pack\r\n\r\n# -Wunused-parameter\r\n# -Wtraditional-conversion\r\n# -fira-region=one/mixed\r\n# -Wstack-usage=2048\r\n# -finput-charset=UTF-8\r\n# -Wc++-compat\r\n\r\nCFLAGS=-Og -g -std=c99 \\\r\n\t-target i386-pc-windows-gnu \\\r\n\t-finput-charset=UTF-8 \\\r\n\t-m32 -march=i386 -mtune=i686 \\\r\n\t-fshort-enums \\\r\n\t-fno-asynchronous-unwind-tables \\\r\n\t-fsanitize=address \\\r\n\t-fno-omit-frame-pointer \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 \\\r\n\t-Wp,-D_FORTIFY_SOURCE=2 \\\r\n\t$(WARNINGS) \\\r\n\t$(MINGW) \\\r\n\t-DCLANG\r\n\r\n\r\nLDFLAGS=-lkernel32 \\\r\n\t-luser32 \\\r\n\t-lgdi32 \\\r\n\t-Wl,-dynamicbase \\\r\n\t-Wl,-nxcompat \\\r\n\t-Wl,--no-seh\r\n\r\nEXELD = $(LDFLAGS) \\\r\n\t-Wl,--tsaware \\\r\n\t-lcomctl32 \\\r\n\t-ladvapi32 \\\r\n\t-lshell32 \\\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooks.res $(CFLAGS) $(LDFLAGS) -shared -e_DllMain@12 -v -Wl,--kill-at\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnap.res $(CFLAGS) $(EXELD) -mwindows -e_unfuckWinMain@0 -v\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\t$(WR) altsnap.rc\r\n\r\nhooksr.o: hooks.rc\r\n\t$(WR) hooks.rc\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "MakefileTCC",
          "type": "blob",
          "size": 1.06640625,
          "content": "CC=tcc\r\n# You still need a resource builder, gcc's windres works just fine.\r\nWR=windres\r\n\r\nCFLAGS=-w -m32 -Os -DNO_VISTA\r\n\r\nDLLEXP=-DLOAD_PROC=\\\"_Load@4\\\" -DLOW_LEVEL_KB_PROC=\\\"_LowLevelKeyboardProc@12\\\" -DUNLOAD_PROC=\\\"_Unload@0\\\"\r\n\r\nLDFLAGS= \\\r\n\t-lmsvcrt \\\r\n\t-lkernel32 \\\r\n\t-luser32 \\\r\n\t-lgdi32 \\\r\n\t-ladvapi32 \\\r\n\r\nEXELD = $(LDFLAGS) \\\r\n\t-lcomctl32 \\\r\n\t-ladvapi32 \\\r\n\t-lshell32\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooksr.o $(CFLAGS) $(LDFLAGS) -shared\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnapr.o $(DLLEXP) $(CFLAGS) $(EXELD) -Wl,-subsystem=gui -DtWinMain=wWinMain\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\t$(WR) altsnap.rc altsnapr.o -Fpe-i386\r\n\r\nhooksr.o: hooks.rc\r\n\t$(WR) hooks.rc hooksr.o -Fpe-i386\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "MakefileX64",
          "type": "blob",
          "size": 1.66796875,
          "content": "CC=gcc\r\nWR=windres\r\n\r\nWARNINGS=-Wall -Wformat-security -Wstrict-overflow -Wsign-compare -Wclobbered \\\r\n    -Wempty-body -Wignored-qualifiers -Wuninitialized -Wtype-limits -Woverride-init \\\r\n    -Wlogical-op -Wno-multichar -Wno-attributes -Wduplicated-cond -Wduplicated-branches \\\r\n    -Wnull-dereference -Wno-unused-function -Wshadow -Wstack-usage=4096 -pedantic -Wc++-compat\r\n\r\nCFLAGS=-Os -fno-stack-check -fno-stack-protector -fno-ident -fomit-frame-pointer -fmerge-all-constants \\\r\n    -mno-stack-arg-probe -momit-leaf-frame-pointer -m64 -march=x86-64 -mtune=generic \\\r\n    -nostdlib -lmsvcrt -lkernel32 -luser32 -lgdi32 -lmsvcrt -lwinmm -s -fgcse-sm -fgcse-las -fno-plt \\\r\n    -Wl,-dynamicbase,-nxcompat,--no-seh,--relax,--disable-runtime-pseudo-reloc,--enable-auto-import,--disable-stdcall-fixup \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 -Wp,-D_FORTIFY_SOURCE=2 -fshort-enums\\\r\n    $(INCLUDE) $(WARNINGS) -fno-exceptions -fno-dwarf2-cfi-asm -fno-asynchronous-unwind-tables\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooksr.o $(CFLAGS) -mdll -eDllMain -Wl,--kill-at\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnapr.o $(CFLAGS) -Wl,--tsaware,--disable-reloc-section -mwindows -lcomctl32 -ladvapi32 -lshell32 -eunfuckWinMain\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\t$(WR) altsnap.rc altsnapr.o\r\n\r\nhooksr.o: hooks.rc\r\n\t$(WR) hooks.rc hooksr.o\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "MakefileX64db",
          "type": "blob",
          "size": 1.4755859375,
          "content": "CC=gcc\r\n\r\nWARNINGS=-Wall -Wformat-security -Wstrict-overflow -Wsign-compare -Wclobbered \\\r\n    -Wempty-body -Wignored-qualifiers -Wuninitialized -Wtype-limits -Woverride-init \\\r\n    -Wlogical-op -Wno-multichar -Wno-attributes -Wduplicated-cond -Wduplicated-branches \\\r\n    -Wnull-dereference -Wno-unused-function -Wshadow -Wstack-usage=4096\r\n\r\n## DEBUG FLAGS\r\nCFLAGS= -nostdlib -Os -g -DLOG_STUFF=1 -m64 -march=x86-64 -mtune=generic \\\r\n    -lmsvcrt -lkernel32 -luser32 -lgdi32 -fgcse-sm -fgcse-las -fno-plt \\\r\n    -Wl,-dynamicbase,-nxcompat,--no-seh,--relax,--disable-runtime-pseudo-reloc,--enable-auto-import,--disable-stdcall-fixup \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 -fshort-enums\\\r\n    $(INCLUDE) $(WARNINGS) -fno-exceptions -fno-dwarf2-cfi-asm -fno-asynchronous-unwind-tables\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooksr.o $(CFLAGS) -mdll -eDllMain -Wl,--kill-at\r\n\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnapr.o $(CFLAGS) -Wl,--tsaware,--disable-reloc-section -lcomctl32 -ladvapi32 -lshell32 -eunfuckWinMain\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\twindres altsnap.rc altsnapr.o\r\n\r\nhooksr.o: hooks.rc\r\n\twindres hooks.rc hooksr.o\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "Makefiledb",
          "type": "blob",
          "size": 1.638671875,
          "content": "CC=gcc\r\n\r\nWARNINGS=-Wall -Wformat-security -Wstrict-overflow -Wsign-compare -Wclobbered \\\r\n    -Wempty-body -Wignored-qualifiers -Wuninitialized -Wtype-limits -Woverride-init \\\r\n    -Wlogical-op -Wno-multichar -Wno-attributes -Wduplicated-cond -Wduplicated-branches \\\r\n    -Wnull-dereference -Wno-unused-function -Wshadow -Wstack-usage=4096\r\n\r\n# -Wunused-parameter\r\n# -Wtraditional-conversion\r\n#-fira-region=one/mixed\r\n# -Wstack-usage=2048\r\n\r\n## DEBUG FLAGS\r\n#    -Wl,--print-memory-usage -fstack-usage -fcallgraph-info \r\nCFLAGS= -nostdlib -Og -g -ggdb -DLOG_STUFF=1 -m32 -march=i686 -mtune=generic \\\r\n\t-fno-omit-frame-pointer -lgcc -ftrapv -fbounds-check \\\r\n    -lmsvcrt -lkernel32 -luser32 -lgdi32 \\\r\n    -Wl,-dynamicbase,-nxcompat,--no-seh,--relax,--enable-auto-import,--disable-stdcall-fixup \\\r\n\t-D__USE_MINGW_ANSI_STDIO=0 -Wp,-D_FORTIFY_SOURCE=2 -fshort-enums\\\r\n    $(INCLUDE) $(WARNINGS) -DDEBUG\r\n\r\ndefault: AltSnap.exe hooks.dll\r\n\r\nhooks.dll : hooks.c hooks.h hooksr.o unfuck.h nanolibc.h zones.c snap.c\r\n\t$(CC) -o hooks.dll hooks.c hooksr.o $(CFLAGS) -mdll -e_DllMain@12 -Wl,--kill-at\r\n\r\n#--disable-reloc-section,  -mwindows\r\nAltSnap.exe : altsnapr.o altsnap.c hooks.h tray.c config.c languages.h languages.c unfuck.h nanolibc.h\r\n\t$(CC) -o AltSnap.exe altsnap.c altsnapr.o $(CFLAGS) -Wl,--tsaware -lcomctl32 -ladvapi32 -lshell32 -e_unfuckWinMain@0\r\n\r\naltsnapr.o : altsnap.rc window.rc resource.h AltSnap.exe.manifest media/find.cur media/find.ico media/icon.ico media/tray-disabled.ico media/tray-enabled.ico\r\n\twindres altsnap.rc altsnapr.o -Fpe-i386\r\n\r\nhooksr.o: hooks.rc\r\n\twindres hooks.rc hooksr.o -Fpe-i386\r\n\r\nclean :\r\n\trm altsnapr.o AltSnap.exe hooksr.o hooks.dll\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3505859375,
          "content": "English | [ä¸­æ](./README_zh-CN.md) | [íêµ­ì´](./README_ko-KR.md)\r\n# AltSnap\r\nFork from Stefan Sundin's AltDrag.\r\n\r\nCheck the Wiki: https://github.com/RamonUnch/AltSnap/wiki\r\n\r\nOriginal documentation: https://stefansundin.github.io/altdrag/doc/\r\n\r\nNote that the documentation is not 100% accurate because it is a fork.\r\nRead the changelog for more details.\r\n\r\nIt allows you to move and resize windows by using the Alt key and clicking wherever on the window instead of relying on very precise clicking.\r\nThis behavior is very common on Linux distributions and is not actually hard to implement on Windows.\r\n\r\nThis fork tries to keep a version up to date with minimal amount of bugs while keeping it feature-rich.\r\n\r\nIt is oriented towards all Windows users from Windows NT 4 to Windows 11, even though it is mostly tested on Windows XP and Windows 10.\r\n\r\nMain differences:\r\nTo simplify the code greatly the Hooks windows feature was removed, it allowed you have windows snapping while dragging them normally. It required however to inject a dll in every application and induced thus an obvious security risk. The amount of mess added to the code just for this feature was substantial and in addition forced to have both a 32bits and a 64bits version of the program running at the same time.\r\n\r\nThis version injects nothing into other applications. This means you do not have to worry whether you have a 32 or a 64bit operating system.\r\n\r\nAnother feature that was disabled is focus on typing, that was too much unusable for me to even start testing, so I removed it.\r\n\r\nOtherwise this has a much simpler source code, added a few extra options, such as transparent windows dragging, Maximize action, pause process options, more blacklists for finer control of AltSnap etc. \r\n\r\nFinally it fixed a ton of undesired behavior and bugs from the original AltDrag.\r\n\r\nWHAT'S NEW\r\n\r\nMany new features can be seen in the option dialog box, however some of them are only available through editing the AltSnap.ini file (middle click on tyhe tray icon for this).\r\n\r\n# VirusTotal false positive\r\nYou will see with the latest builds that there are some allerts, usually from SecureAge APEX sometime also from another vendor. Those are false positive and I stopped to contact the APEX team for every release becase it is a loss of time I would rather spend on improving the program.\r\nI already redued a lot the numberof false positive, simply by changing build flags and by switching to an older version of NSIS installer system. This is an indication of the impertinance of some modern antivirus solutions. Chocolatey considers that up to 5 positives on VirusTotal is not even suspicious.\r\n\r\n# Build\r\nAltSnap builds with gcc, I use Mingw-w64 (for i686).\r\nJust install the latest version (I use TDM-gcc 10.3, MinGW64 based) and use:\r\n\r\n`> make` for i386 Win32 GCC build.\r\n\r\n`> make -fMakefiledb` for i386 GCC debug build.\r\n\r\n`> make -fMakefileX64` for x86_64 GCC build.\r\n\r\n`> make -fMakefileX64db` for x86_64 GCC debug build.\r\n\r\n`> make -fMakefileClang` for i386 build using LLVM Clang.\r\n\r\n`> make -fMakefileTCC` for i386 build using tcc, [Bellard's thiny c compiler](https://bellard.org/tcc/)\r\n\r\nYou can also use mk.bat and mk64.bat files.\r\nFor Clang, I use LLVM5.0.1 with the headers and libs from Mingw-w64.\r\nBe sure to adjust your include and lib directorries on the command line with `-IPath\\to\\mingw\\include` and `-LPath\\to\\mingw\\lib`.\r\n"
        },
        {
          "name": "README_ko-KR.md",
          "type": "blob",
          "size": 4.2353515625,
          "content": "[English](./README.md) | [ä¸­æ](./README_zh-CN.md) | íêµ­ì´\n# AltSnap\nStefan Sundinì AltDragìì í¬í¬ëììµëë¤.\n\nìí¤ë¥¼ íì¸íì¸ì: https://github.com/RamonUnch/AltSnap/wiki\n\nê¸°ì¡´ ë¬¸ì: https://stefansundin.github.io/altdrag/doc/\n\ní¬í¬ë ì½ëë¼ì ë¬¸ìê° 100% ì ííì§ë ììµëë¤.\nì¢ ë ìì¸í ì¬í­ì´ ê¶ê¸íìë©´ ë³ê²½ì¬í­(changelog)ì íì¸ë°ëëë¤.\n\nAltSnapì Alt í¤ë¥¼ ëë¥´ê³  ìë ì°½ì ìë¬´ê³³ì´ë í´ë¦­íì¬ ì°½ì ì´ëíê³  í¬ê¸°ë¥¼ ì¡°ì í  ì ìëë¡ íë ì í¸ë¦¬í°ìëë¤.\në¦¬ëì¤ììë ì´ë¬í ê¸°ë¥ê³¼ ëìì´ ì¼ë°ì ì¼ë¡ ì ì©ëì´ìê³  ì¤ì ë¡ ìëì°ììë ì ì©íê¸° ì´ë µì§ ììµëë¤.\n\nì´ í¬í¬ë íë¶í ê¸°ë¥ì ì ì§íë©´ìë ìµìíì ë²ê·¸ë¥¼ ìµìííì¬, ìµì  ë²ì ì¼ë¡ ì ì§íë ¤ê³  ë¸ë ¥íëë° ëª©ì ì´ ììµëë¤.\n\nì´ í¬í¬ë ì£¼ë¡ Windows XPì Windows 10ìì íì¤í¸ ëììµëë¤ë§ Windows NT 4ìì Windows 11ê¹ì§ì ëª¨ë  Windowsìì ì¬ì©ì´ ê°ë¥í©ëë¤.\n\nì£¼ì ì°¨ì´ì :\nì½ëë¥¼ ìµëí ë¨ìííê¸° ìí´ ì°½ì íí¬(Hook)íë ë°©ìì ì ê±°íììµëë¤. ì´ë¬í ë°©ìì ëëê·¸ë¥¼ íëëì ì´ë í ì°½ì´ë  ì¤ëí  ì ìëë¡ íë ì¥ì ì´ ìë ë°ë©´ì, ëª¨ë  ìì© íë¡ê·¸ë¨ì dllì ì½ì(DLL Injection)í´ì¼ íìì¼ë¯ë¡ ëªë°±í ë³´ììì ìíì´ ìììµëë¤. ë¨ìí ì´ ê¸°ë¥ì ìí´ ìë¹í ìì ì½ëê° ì¶ê°ëìì¼ë©° ëìì 32ë¹í¸ ë° 64ë¹í¸ ë²ì ì íë¡ê·¸ë¨ì ëª¨ë ì¤íí´ì¼ íê¸° ëë¬¸ì ì½ëì ë³µì¡ëë¥¼ í¬ê² ì¦ê°ìì¼°ìµëë¤.\n\nì´ ë²ì ì ë¤ë¥¸ ì´íë¦¬ì¼ì´ìì ìë¬´ê²ë ì½ì(Injection)íì§ ììµëë¤. ë°ë¼ì 32ë¹í¸ ì´ìì²´ì ë¥¼ ì¬ì©íë  64ë¹í¸ ì´ìì²´ì ë¥¼ ì¬ì©íë  ê±±ì í  íìê° ììµëë¤.\n\nì´ì¸ì ì ê±°ë ê¸°ë¥ì \"íì´íì í¬ì»¤ì¤\"ë¡, íì¤í¸ë¥¼ ììíê¸°ë ì ì ì´ë¯¸ ì¬ì©í  ì ìë ìíìì¼ë¯ë¡ ì ê±° íìµëë¤.\n\nì´ë¬í ë³íë¡ ìì¤ì½ëê° í¨ì  ê°ê²°í´ì¡ê³ , ì½ê°ì ì¶ê°ì ì¸ ìµìì ë£ììµëë¤. ìë¥¼ ë¤ë©´ ëëê·¸ íë ëì í¬ëª ìëì°ë¥¼ í¬ëªíê² íë¤ëê°, ìµëí ì¡ì, íë¡ì¸ì¤ ì¼ì ì¤ì§, AltSnapì ì¡°ê¸ ë ì¸ë°íê² ì ì´í  ì ìë ë¸ëë¦¬ì¤í¸ ë±ì ì¶ê° ìµìì´ ì¶ê°ëììµëë¤. \n\në§ì§ë§ì¼ë¡ ê¸°ì¡´ì AltDragìì ë°ìíë ì´ì ëìê³¼ ë²ê·¸ë¥¼ ìë© ìì íìµëë¤.\n\nìë¡ì´ ê¸°ë¥\n\nê¸°ë³¸ì ì¼ë¡ ìµì ë¤ì´ì¼ë¡ê·¸ ì°½ìì ìë¡ì´ ê¸°ë¥ì ë§ëë³´ì¤ ì ìì§ë§, ì¼ë¶ ê¸°ë¥ì AltSnap.ini íì¼ì ì§ì  ìì í´ì¼ë§ í©ëë¤. (í¸ë ì´ ìì´ì½ì ê°ì´ë° í´ë¦­í´ ë³´ì¸ì)\n\n# VirusTotal ì¤í\nìµì  ë¹ëììë ì¼ë°ì ì¼ë¡ ë¤ë¥¸ ê³µê¸ìì²´ì SecureAge APEXì ë§ì°¬ê°ì§ë¡ ì¢ì¢ ê²½ê³ ê° íìëë ê²ì ë³¼ ì ììµëë¤. ì´ë¬í ê²½ê³ ë ì¤íì´ë©° íë¡ê·¸ë¨ ê°ì ì ìê°ì ë­ë¹íë ê²ì´ê¸° ëë¬¸ì ë§¤ ë¦´ë¦¬ì¤ë§ë¤ APEX íì ì°ë½íë ê²ì ì¤ë¨íìµëë¤. ë¹ë íëê·¸ë¥¼ ë³ê²½íê³  ì´ì  ë²ì ì NSIS ì¸ì¤í¨ë¬ ìì¤íì¼ë¡ ì ííë ê²ë§ì¼ë¡ ì´ë¯¸ ì¤íì ìë¥¼ ë§ì´ ì¤ììµëë¤. ì´ê²ì ì¼ë¶ ìµì  ë°ì´ë¬ì¤ ë°±ì  ìë£¨ìì ë¶ì¡±í¨ì ëíëëë¤. Chocolateyììë VirusTotalìì 5ê°ì ëì ìì± íì§ë ì í ìì¬ì´ê²ì´ ìëë¼ê³  ê°ì£¼íê³  ììµëë¤.\n\n# ë¹ë\nAltSnapì gccë¡ ë¹ëí  ì ììµëë¤. ì  ê²½ì°ì i686ì©ì ë¹ëí ë Mingw-w64ë¥¼ ì¬ì©í©ëë¤.\n\nìµì  ë²ì ì ì¤ì¹íì  í (ì ë MinGW64 ê¸°ë°ì TDM-gcc 10.3ë¥¼ ì¬ì©ì¤ìëë¤):\n\n`> make` i386 Win32 GCC ë¹ë.\n\n`> make -fMakefiledb` i386 GCC ëë²ê·¸ ë¹ë.\n\n`> make -fMakefileX64` x86_64 GCC ë¹ë.\n\n`> make -fMakefileX64db` x86_64 GCC ëë²ê·¸ ë¹ë.\n\n`> make -fMakefileClang` LLVM Clangì ì´ì©í i386 ë¹ë.\n\n`> make -fMakefileTCC` tcc(Bellard's thiny c compiler)[https://bellard.org/tcc/]ë¥¼ ì´ì©í i386 ë¹ë \n\n`mk.bat` ì `mk64.bat`íì¼ì ì¬ì©íì¤ ìë ììµëë¤. Clangì ê²½ì° ì ë LLVM5.0.1ê³¼  Mingw-w64ì header ë° libë¥¼ ì¬ì©í©ëë¤. ì»¤ë§¨ëë¼ì¸ì ë³ê²½í´ì `-IPath\\to\\mingw\\include` and `-LPath\\to\\mingw\\lib`ë¥¼ ì¶ê°íë ê²ì ìì§ë§ì¸ì.\n"
        },
        {
          "name": "README_zh-CN.md",
          "type": "blob",
          "size": 2.29296875,
          "content": "[English](./README.md) | ä¸­æ | [íêµ­ì´](./README_ko-KR.md)\r\n# AltSnap\r\nç±Stefan SundinçAltDragå¶ä½çä¸ä¸ªçåæ¯ã\r\n\r\næ¥çWikiï¼https://github.com/RamonUnch/AltSnap/wiki\r\n\r\nåå§ææ¡£ï¼https://stefansundin.github.io/altdrag/doc/\r\n\r\nè¯·æ³¨æï¼å ä¸ºè¿æ¯ä¸ä¸ªåæ¯ï¼æä»¥åå§çææ¡£å¹¶ä¸æ¯100%åç¡®çãè¯·éè¯»æ´æ°æ¥å¿æ¥äºè§£æ´å¤è¯¦ç»ä¿¡æ¯ã\r\n\r\nå®åè®¸æ¨éè¿æä½Alté®å¹¶åå»çªå£ä¸çä»»ä½ä½ç½®æ¥ç§»å¨åè°æ´çªå£å¤§å°ï¼å¹¶ä¸éè¦ä»»ä½ç²¾ç¡®çç¹å»ã\r\nè¿ç§æ¹å¼å¨Linuxåè¡çä¸å¾å¸¸è§ï¼å¶å®ä¹å¹¶ä¸é¾å¨Windowsä¸å®ç°ã\r\n\r\nè¿ä¸ªåæ¯çç®æ æ¯å¨ä¿æåè½ä¸°å¯çæåµä¸åæ¶è®©ææ°çæ¬çéè¯¯æå°ã\r\n\r\nå°½ç®¡å®ä¸»è¦å¨Windows XPåWindows 10ä¸è¿è¡æµè¯ï¼ä½å®çè®ºä¸åºè¯¥å¯ä»¥å¨Windows NT 4.0å°Windows 11ä¹é´çä»»æWindowsçæ¬ä¸ä½¿ç¨ï¼\r\n\r\nä¸åçä¸»è¦çä¸åï¼\r\nä¸ºäºå¤§å¤§ç®åä»£ç ï¼Hooksçªå£çåè½è¢«å é¤ï¼å®åè®¸å¨æ­£å¸¸æå¨çªå£çåæ¶ææçªå£ãç¶èï¼å®éè¦å¨æ¯ä¸ªåºç¨ç¨åºä¸­æ³¨å¥ä¸ä¸ªdllï¼ä»èå¯¼è´äºææ¾çå®å¨é£é©ãä»ä»ä¸ºäºè¿ä¸ªç¹æ§èæ·»å å°ä»£ç ä¸­çæ··ä¹±ç¨åº¦æ¯å·¨å¤§çï¼æ­¤å¤è¿è¢«è¿«åæ¶è¿è¡32ä½å64ä½çæ¬çç¨åºã\r\n\r\næ­¤çæ¬ä¸åå¶ä»åºç¨ç¨åºæ³¨å¥ä»»ä½åå®¹ãè¿æå³çæ¨ä¸å¿æå¿æ¨ä½¿ç¨çæ¯32ä½è¿æ¯64ä½æä½ç³»ç»ã\r\n\r\nå¦ä¸ä¸ªè¢«ç¦ç¨çåè½æ¯âä¸æ³¨äºæå­âï¼æçè³æ æ³å¼å§æµè¯è¿ä¸ªåè½ï¼æä»¥æå é¤äºå®ã\r\n\r\né¤æ­¤ä¹å¤ï¼å®è¿æä¸ä¸ªç®åå¾å¤çæºä»£ç ï¼æ·»å äºä¸äºé¢å¤çéé¡¹ï¼å¦éæçªå£æå¨ãæå¤§åæä½ãæåè¿ç¨éé¡¹ãæ´å¤ç¨äºæ´ç²¾ç»å°æ§å¶AltSnapçé»ååç­ã\r\n\r\næåï¼å®ä¿®å¤äºåå§AltDragä¸­çå¤§éä¸è¯è¡ä¸ºåéè¯¯ã\r\n\r\næ°ä¸è¥¿ï¼\r\n\r\nå¨éé¡¹å¯¹è¯æ¡ä¸­å¯ä»¥çå°è®¸å¤æ°åè½ï¼ä½å¶ä¸­ä¸äºåè½åªè½éè¿ç¼è¾AltSnap.iniæä»¶æè½ä½¿ç¨ï¼ç¨é¼ æ ä¸­é®åå»è¯¥æä»¶çæçå¾æ ï¼ã\r\n\r\n# æå»º\r\nAltSnapä½¿ç¨gccæå»ºï¼å¯¹äºi686æ¥è¯´ï¼æä½¿ç¨Mingw-w64ã\r\nåªéè¦å®è£ææ°çæ¬ï¼æä½¿ç¨åºäºMinGW64çTDM-gcc 10.3ï¼å¹¶ä½¿ç¨ï¼\r\n\r\n`> make` ç¨äºi386 Win32çæå»º\r\n\r\n`> make -fMakefileX64` ç¨äºx86_64æå»ºã\r\n\r\n`> make -fMakefileX64db` ç¨äºæå»ºx86_64çè°è¯çæ¬ã\r\n\r\næ¨ä¹å¯ä»¥ä½¿ç¨mk.batåmk64.batæä»¶ã\r\n"
        },
        {
          "name": "Themes",
          "type": "tree",
          "content": null
        },
        {
          "name": "altsnap.c",
          "type": "blob",
          "size": 25.044921875,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2021                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#include \"hooks.h\"\r\n\r\n// Messages\r\n#define SWM_TOGGLE     (WM_APP+1)\r\n#define SWM_HIDE       (WM_APP+2)\r\n#define SWM_ELEVATE    (WM_APP+3)\r\n#define SWM_CONFIG     (WM_APP+4)\r\n#define SWM_ABOUT      (WM_APP+5)\r\n#define SWM_EXIT       (WM_APP+6)\r\n#define SWM_FIND       (WM_APP+7)\r\n#define SWM_HELP       (WM_APP+8)\r\n#define SWM_SAVEZONES  (WM_APP+9)\r\n#define SWM_TESTWIN    (WM_APP+10)\r\n#define SWM_OPENINIFILE (WM_APP+11)\r\n#define SWM_SNAPLAYOUT    (WM_APP+12)\r\n#define SWM_SNAPLAYOUTEND (WM_APP+22)\r\n#define SWM_EDITLAYOUT    (WM_APP+30)\r\n#define SWM_CLOSEZONES    (WM_APP+31)\r\n\r\n// Boring stuff\r\nstatic HINSTANCE g_hinst = NULL;\r\nstatic HWND g_hwnd = NULL;\r\nstatic UINT WM_TASKBARCREATED = 0;\r\nstatic TCHAR inipath[MAX_PATH];\r\n\r\nstatic HWND g_dllmsgHKhwnd = NULL;\r\n\r\n// Cool stuff\r\nHINSTANCE hinstDLL = NULL;\r\nHHOOK keyhook = NULL;\r\nstatic DWORD ACMenuItems=-1;\r\nstatic char elevated = 0;\r\nstatic char ScrollLockState = 0;\r\nstatic char SnapGap = 0;\r\nstatic BYTE WinVer = 0;\r\n\r\n#define WIN2K (WinVer >= 5)\r\n#define VISTA (WinVer >= 6)\r\n#define WIN10 (WinVer >= 10)\r\n\r\n#define ENABLED() (!!keyhook)\r\n#define GetWindowRectL(hwnd, rect) GetWindowRectLL(hwnd, rect, SnapGap)\r\nstatic void UpdateSettings();\r\n\r\n// Include stuff\r\n#include \"languages.c\"\r\n#include \"tray.c\"\r\n#include \"config.c\"\r\n\r\nstatic HINSTANCE LoadHooksDLL()\r\n{\r\n    // Load library\r\n    TCHAR path[MAX_PATH];\r\n    DWORD ret = GetModuleFileName(NULL, path, ARR_SZ(path));\r\n    if(!ret || ret == ARR_SZ(path))\r\n        return NULL;\r\n    PathRemoveFileSpecL(path);\r\n    lstrcat_s(path, ARR_SZ(path), TEXT(\"\\\\hooks.dll\"));\r\n    return LoadLibrary(path);\r\n}\r\nstatic void FreeHooksDLL()\r\n{\r\n    if (hinstDLL) {\r\n        FreeLibrary(hinstDLL);\r\n        hinstDLL = NULL;\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nint HookSystem()\r\n{\r\n    if (keyhook) return 1; // System already hooked\r\n    LOG(\"Going to Hook the system...\");\r\n\r\n    if (!hinstDLL) {\r\n        hinstDLL = LoadHooksDLL();\r\n        if (!hinstDLL) {\r\n            LOG(\"Could not load HOOKS.DLL!!!\");\r\n            return 1;\r\n        }\r\n    }\r\n    HWND (WINAPI *Load)(HWND, const TCHAR *) = (HWND (WINAPI *)(HWND, const TCHAR*))GetProcAddress(hinstDLL, LOAD_PROC);\r\n    if(Load) {\r\n        g_dllmsgHKhwnd = Load(g_hwnd, inipath);\r\n    }\r\n\r\n    LOG(\"HOOKS.DLL Loaded\");\r\n\r\n    // Load keyboard hook\r\n    HOOKPROC procaddr;\r\n    if (!keyhook) {\r\n        // Get address to keyboard hook (beware name mangling)\r\n        procaddr = (HOOKPROC) GetProcAddress(hinstDLL, LOW_LEVEL_KB_PROC);\r\n        if (procaddr == NULL) {\r\n            LOG(\"Could not find \"LOW_LEVEL_KB_PROC\" entry point in HOOKS.DLL\");\r\n            return 1;\r\n        }\r\n        // Set up the keyboard hook\r\n        keyhook = SetWindowsHookEx(WH_KEYBOARD_LL, procaddr, hinstDLL, 0);\r\n        if (keyhook == NULL) {\r\n            LOG(\"Keyboard HOOK could not be set\");\r\n            return 1;\r\n        }\r\n    }\r\n    LOG(\"Keyboard HOOK set\");\r\n\r\n    // Reading some config options...\r\n    UseZones = GetPrivateProfileInt(TEXT(\"Zones\"), TEXT(\"UseZones\"), 0, inipath);\r\n    SnapGap = CLAMP(-128, GetPrivateProfileInt(TEXT(\"Advanced\"), TEXT(\"SnapGap\"), 0, inipath), 127);\r\n    ACMenuItems = GetPrivateProfileInt(TEXT(\"Advanced\"), TEXT(\"ACMenuItems\"), -1, inipath);\r\n    UpdateTray();\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nint showerror = 1;\r\nint UnhookSystem()\r\n{\r\n    LOG(\"Going to UnHook the system...\");\r\n    if (!keyhook) { // System not hooked\r\n        return 1;\r\n    } else if (!UnhookWindowsHookEx(keyhook) && showerror) {\r\n        MessageBox(NULL, l10n->unhook_error, TEXT(APP_NAMEA),\r\n                   MB_ICONINFORMATION|MB_OK|MB_TOPMOST|MB_SETFOREGROUND);\r\n    }\r\n    keyhook = NULL;\r\n\r\n    // Tell dll file that we are unloading\r\n    void (WINAPI *Unload)() = (void (WINAPI *)()) GetProcAddress(hinstDLL, UNLOAD_PROC);\r\n    if (Unload) {\r\n        Unload();\r\n        // Zero out the message hwnd from DLL.\r\n        g_dllmsgHKhwnd = NULL;\r\n    }\r\n    FreeHooksDLL();\r\n\r\n    // Success\r\n    UpdateTray();\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nvoid ToggleState()\r\n{\r\n    if (ENABLED()) {\r\n        UnhookSystem();\r\n    } else {\r\n        // SendMessage(g_hwnd, WM_UPDATESETTINGS, 0, 0);\r\n        HookSystem();\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void UpdateSettings()\r\n{\r\n    //PostMessage(g_hwnd, WM_UPDATESETTINGS, 0, 0);\r\n    if (ENABLED()) {\r\n        UnhookSystem();\r\n        HookSystem();\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nvoid ShowSClickMenu(HWND hwnd, LPARAM param)\r\n{\r\n    POINT pt;\r\n    if (param&LP_CURSORPOS) {\r\n        // Use cursor position to place menu.\r\n        GetCursorPos(&pt);\r\n    } else {\r\n        // Use the pointed window\r\n        RECT rc;\r\n        HWND clickhwnd = (HWND)SendMessage(hwnd, WM_GETCLICKHWND, 0, 0);\r\n        GetWindowRect(clickhwnd, &rc);\r\n        pt.x = rc.left + GetSystemMetricsForWin(SM_CXSIZEFRAME, clickhwnd);\r\n        pt.y = rc.top + GetSystemMetricsForWin(SM_CYSIZEFRAME, clickhwnd)\r\n                      + GetSystemMetricsForWin(SM_CYCAPTION, clickhwnd);\r\n    }\r\n    HMENU menu = CreatePopupMenu();\r\n    UCHAR show_oriclick = (param&LP_NOALTACTION)? AC_ORICLICK: 0xFF;\r\n\r\n    #define CHK(LP_FLAG) MF_STRING|((param&LP_FLAG)?MF_CHECKED:MF_UNCHECKED)\r\n\r\n    const struct {\r\n        UCHAR action; WORD mf; TCHAR *str;\r\n    } mnlst[] = {\r\n       /* hide, action,      MF_FLAG/CHECKED,    menu string */\r\n        { AC_ALWAYSONTOP, CHK(LP_TOPMOST),    l10n->input_actions_alwaysontop },\r\n        { AC_BORDERLESS,  CHK(LP_BORDERLESS), l10n->input_actions_borderless },\r\n        { AC_CENTER,      MF_STRING,          l10n->input_actions_center},\r\n        { AC_ROLL,        CHK(LP_ROLLED),     l10n->input_actions_roll},\r\n        { AC_LOWER,       MF_STRING,          l10n->input_actions_lower},\r\n        { AC_MAXHV,       MF_STRING,          l10n->input_actions_maximizehv},\r\n        { AC_MINALL,      MF_STRING,          l10n->input_actions_minallother},\r\n        { AC_SIDESNAP,    MF_STRING,          l10n->input_actions_sidesnap},\r\n        { 0,              MF_SEPARATOR, NULL }, /* ------------------------ */\r\n        { AC_MAXIMIZE,    CHK(LP_MAXIMIZED),  l10n->input_actions_maximize},\r\n        { AC_MINIMIZE,    MF_STRING,          l10n->input_actions_minimize},\r\n        { AC_CLOSE,       MF_STRING,          l10n->input_actions_close},\r\n        { 0,              MF_SEPARATOR, NULL }, /* ------------------------ */\r\n        { AC_KILL,        MF_STRING,          l10n->input_actions_kill},\r\n        { 0,              MF_SEPARATOR, NULL }, /* ------------------------ */\r\n        { AC_MOVEONOFF,   CHK(LP_MOVEONOFF),  l10n->input_actions_moveonoff},\r\n        { 0,              MF_SEPARATOR, NULL }, /* ------------------------ */\r\n        { show_oriclick,  MF_STRING,          l10n->input_actions_oriclick},\r\n        { AC_NONE,        MF_STRING,          l10n->input_actions_nothing},\r\n    };\r\n    #undef CHK\r\n    #undef K\r\n    unsigned i;\r\n    for (i=0; i < ARR_SZ(mnlst); i++) {\r\n        if ( (ACMenuItems>>i)&1 && mnlst[i].action != 0xFF) // Put the action in the HIWORD of wParam\r\n            AppendMenu(menu, mnlst[i].mf, mnlst[i].action<<16, mnlst[i].str);\r\n    }\r\n    TrackPopupMenu(menu, GetSystemMetrics(SM_MENUDROPALIGNMENT), pt.x, pt.y, 0, hwnd, NULL);\r\n    DestroyMenu(menu);\r\n    PostMessage(hwnd, WM_CLOSE, 0, 0);\r\n}\r\n// To get the caret position in screen coordinate.\r\n// We first try to get the carret rect\r\n#include <oleacc.h>\r\n//static const GUID  my_IID_IAccessible = { 0x618736e0, 0x3c3d, 0x11cf, {0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71} };\r\nstatic void GetKaretPos(POINT *pt)\r\n{\r\n    GUITHREADINFO gui;\r\n    gui.cbSize = sizeof(GUITHREADINFO);\r\n    gui.hwndCaret = NULL;\r\n    if (GetGUIThreadInfo(0, &gui)) {\r\n        pt->x = (gui.rcCaret.right + gui.rcCaret.left)>>1;\r\n        pt->y = (gui.rcCaret.top + gui.rcCaret.bottom)>>1;\r\n        if (gui.hwndCaret) {\r\n            ClientToScreen(gui.hwndCaret, pt);\r\n            return;\r\n//        } else if (gui.hwndFocus) {\r\n//            IAccessible *pacc = NULL;\r\n//            if ( S_OK==AccessibleObjectFromWindow(gui.hwndFocus, OBJID_CARET, &my_IID_IAccessible, (void**)&pacc) ) {\r\n//        //        MessageBox(NULL, NULL, NULL, 0);\r\n//                LONG x=0, y=0, w=0, h=0;\r\n//                VARIANT varCaret;\r\n//                varCaret.vt = VT_I4;\r\n//                varCaret.lVal = CHILDID_SELF;\r\n//                if (S_OK == pacc->lpVtbl->accLocation(pacc, &x, &y, &w, &h, varCaret)) {\r\n//                    pt->x = x+w/2;\r\n//                    pt->y = y+h/2;\r\n//                    pacc->lpVtbl->Release(pacc);\r\n//                    return;\r\n//                }\r\n//            }\r\n        }\r\n    }\r\n\r\n    GetCursorPos(pt);\r\n}\r\nstatic void ShowUnikeyMenu(HWND hwnd, LPARAM param)\r\n{\r\n    UCHAR vkey = LOBYTE(LOWORD(param));\r\n    UCHAR capital = HIBYTE(LOWORD(param));\r\n    TCHAR *const* const ukmap = &l10n->a; //EXTRAKEYS_MAP;\r\n    HMENU menu = CreatePopupMenu();\r\n    if (!menu) return;\r\n\r\n    const TCHAR *kl, *keylist = ukmap[vkey - 0x41];\r\n    UCHAR i;\r\n    for (kl = keylist, i='A'; *kl; kl++) {\r\n        if(*kl==L'%') {\r\n            AppendMenu(menu, MF_SEPARATOR, 0, NULL);\r\n            continue;\r\n        }\r\n        TCHAR unichar = *kl;\r\n        if (kl[1] == L'|') {\r\n            kl+=2;\r\n            if (capital) unichar = *kl;\r\n        } else if (capital) {\r\n            unichar = (TCHAR)(LONG_PTR)CharUpper((TCHAR *)(LONG_PTR)*kl);\r\n        }\r\n        if (i > 'Z') i = '1';\r\n        TCHAR mwstr[6];\r\n        mwstr[0] = L'&';\r\n        mwstr[1] = i++;\r\n        mwstr[2] = L'\\t';\r\n        DWORD utf16c;\r\n        if (IS_SURROGATE_PAIR(unichar, kl[1])) {\r\n            utf16c =*(DWORD*)kl;\r\n            mwstr[3] = LOWORD(utf16c);\r\n            mwstr[4] = HIWORD(utf16c);\r\n            mwstr[5] = L'\\0';\r\n            kl++; // skip high surrogate\r\n        } else {\r\n            mwstr[3] = utf16c = unichar;\r\n            mwstr[4] = L'\\0';\r\n        }\r\n        if (!AppendMenu(menu, MF_STRING, utf16c, mwstr))\r\n            break;\r\n    }\r\n    if (kl > keylist) {\r\n        POINT pt;\r\n        GetKaretPos(&pt);\r\n        TrackPopupMenu(menu, GetSystemMetrics(SM_MENUDROPALIGNMENT), pt.x, pt.y, 0, hwnd, NULL);\r\n    }\r\n    DestroyMenu(menu);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (!msg) {\r\n        // In case some messages are not registered.\r\n    } else if(wParam && msg == WM_ERASEBKGND) {\r\n        return 1;\r\n    } else if (wParam && (msg == WM_PAINT || msg == WM_NCPAINT)) {\r\n        return 0;\r\n    } else if (msg == WM_TRAY) {\r\n        if (lParam == WM_LBUTTONDOWN || lParam == WM_LBUTTONDBLCLK) {\r\n            ToggleState();\r\n            if (lParam == WM_LBUTTONDBLCLK) {\r\n                SendMessage(hwnd, WM_OPENCONFIG, 0, 0);\r\n            }\r\n        } else if (lParam == WM_MBUTTONDOWN) {\r\n            SendMessage(hwnd, WM_COMMAND, SWM_OPENINIFILE, 0);\r\n        } else if (lParam == WM_RBUTTONUP) {\r\n            ShowContextMenu(hwnd);\r\n        }\r\n    } else if (msg == WM_SCLICK && wParam) {\r\n        ShowSClickMenu((HWND)wParam, lParam);\r\n    } else if (msg == WM_UNIKEYMENU) {\r\n        ShowUnikeyMenu((HWND)wParam, lParam);\r\n    } else if (msg == WM_UPDATESETTINGS) {\r\n        // Reload hooks\r\n        UpdateSettings();\r\n    } else if (msg == WM_ADDTRAY) {\r\n        hide = 0;\r\n        UpdateTray();\r\n    } else if (msg == WM_UPDATETRAY) {\r\n        UpdateTray();\r\n    } else if (msg == WM_HIDETRAY) {\r\n        hide = 1;\r\n        RemoveTray();\r\n    } else if (msg == WM_OPENCONFIG && (lParam || !hide)) {\r\n        OpenConfig(wParam);\r\n    } else if (msg == WM_CLOSECONFIG) {\r\n        CloseConfig();\r\n    } else if (msg == WM_TASKBARCREATED) {\r\n        // Try to add the tray icon because explorer started.\r\n        tray_added = 0;\r\n        UpdateTray();\r\n    } else if (msg == WM_COMMAND) {\r\n        int wmId = LOWORD(wParam); // int wmEvent = HIWORD(wParam);\r\n        if (wmId == SWM_TOGGLE) {\r\n            ToggleState();\r\n        } else if (wmId == SWM_HIDE) {\r\n            hide = 1;\r\n            RemoveTray();\r\n        } else if (wmId == SWM_ELEVATE) {\r\n           ElevateNow(0);\r\n        } else if (wmId == SWM_CONFIG) {\r\n            SendMessage(hwnd, WM_OPENCONFIG, 0, 0);\r\n        } else if (wmId == SWM_ABOUT) {\r\n            SendMessage(hwnd, WM_OPENCONFIG, 5, 0);\r\n        } else if (wmId == SWM_OPENINIFILE) {\r\n            ShellExecute(NULL, TEXT(\"open\"), inipath, NULL, NULL, SW_SHOWNORMAL);\r\n        } else if (wmId == SWM_EXIT) {\r\n            DestroyWindow(hwnd);\r\n        } else if (wmId == SWM_SAVEZONES) {\r\n            TCHAR txt[256];\r\n            lstrcpy_s(txt, ARR_SZ(txt), l10n->zone_confirmation);\r\n            lstrcat_s(txt, ARR_SZ(txt), TEXT(\"\\n\\n\"));\r\n            catFullLayoutName(txt, ARR_SZ(txt), LayoutNumber);\r\n            int ret = MessageBox(NULL, txt, TEXT(APP_NAMEA), MB_OKCANCEL);\r\n            if (ret == IDOK) {\r\n                UnhookSystem();\r\n                SaveCurrentLayout();\r\n                WriteCurrentLayoutNumber();\r\n                HookSystem();\r\n            }\r\n        } else if (wmId == SWM_CLOSEZONES) {\r\n            CloseAllTestWindows();\r\n        } else if (wmId == SWM_TESTWIN) {\r\n            NewTestWindow();\r\n        } else if (SWM_SNAPLAYOUT <= wmId && wmId <= SWM_SNAPLAYOUTEND) {\r\n            // Inform hooks.dll that the snap layout changed\r\n            LayoutNumber = wmId-SWM_SNAPLAYOUT;\r\n            if(g_dllmsgHKhwnd)\r\n                PostMessage(g_dllmsgHKhwnd, WM_SETLAYOUTNUM, LayoutNumber, 0);\r\n            // Save new value in the .ini file\r\n            WriteCurrentLayoutNumber();\r\n        } else if (wmId == SWM_EDITLAYOUT) {\r\n            if (g_dllmsgHKhwnd) {\r\n                unsigned len = SendMessage(g_dllmsgHKhwnd, WM_GETZONESLEN, LayoutNumber, 0);\r\n                if (!len) {\r\n                    // Empty layout, Let's open a new Test Window\r\n                    return !NewTestWindow();\r\n                }\r\n                RECT *zones = (RECT*)malloc(len * sizeof(RECT));\r\n                if(!zones) return 0;\r\n\r\n                SendMessage(g_dllmsgHKhwnd, WM_GETZONES, LayoutNumber, (LPARAM)zones);\r\n                // Open them from bottom to top to ensure\r\n                // the windows are in the correct order.\r\n                while (len--) {\r\n                    const RECT *rc = &zones[len];\r\n                    NewTestWindowAt(rc->left, rc->top, rc->right-rc->left, rc->bottom-rc->top);\r\n                }\r\n                free(zones);\r\n            }\r\n        }\r\n    } else if (msg == WM_QUERYENDSESSION) {\r\n        showerror = 0;\r\n        UnhookSystem();\r\n    } else if (msg == WM_DESTROY) {\r\n        UnhookSystem();\r\n        RemoveTray();\r\n        PostQuitMessage(0);\r\n    } else if (msg == WM_LBUTTONDOWN || msg == WM_MBUTTONDOWN || msg == WM_RBUTTONDOWN) {\r\n        // Hide cursorwnd if clicked on, this might happen if\r\n        // it wasn't hidden by hooks.c for some reason\r\n        ShowWindow(hwnd, SW_HIDE);\r\n        return 0;\r\n    } else if (msg == WM_DISPLAYCHANGE || (msg == WM_SETTINGCHANGE && wParam  == SPI_SETWORKAREA)) {\r\n        LOG(\"WM_DISPLAYCHANGE %d:%d, %dbpp in WindowProc\", LOWORD(lParam), HIWORD(lParam), wParam );\r\n        if (g_dllmsgHKhwnd) {\r\n            int bestlayout = SendMessage(g_dllmsgHKhwnd, WM_GETBESTLAYOUT, 0, 0);\r\n            if( bestlayout != LayoutNumber\r\n            &&  0 <= bestlayout && bestlayout < MaxLayouts ) {\r\n                LayoutNumber = bestlayout;\r\n                PostMessage(g_dllmsgHKhwnd, WM_SETLAYOUTNUM, LayoutNumber, 0);\r\n            }\r\n        }\r\n    }\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nint WINAPI tWinMain(HINSTANCE hInst, HINSTANCE hPrevInstance, TCHAR *params, int iCmdShow)\r\n{\r\n    g_hinst = hInst;\r\n\r\n    // Get ini path\r\n    LOG(\"\\n\\nALTSNAP STARTED\");\r\n    GetModuleFileName(NULL, inipath, ARR_SZ(inipath));\r\n    inipath[MAX_PATH-1] = '\\0';\r\n    lstrcpy_s(&inipath[lstrlen(inipath)-3], 4, TEXT(\"ini\"));\r\n    if (INVALID_FILE_ATTRIBUTES == GetFileAttributes(inipath)\r\n    && GetEnvironmentVariable(TEXT(\"APPDATA\"), NULL, 0)) {\r\n        // .ini file is not in current directorry, and APPDATA exists\r\n        // we should look for %APPDATA%\\AltSnap\\AltSnap.ini\r\n        TCHAR userini[MAX_PATH];\r\n        GetEnvironmentVariable(TEXT(\"APPDATA\"), userini, ARR_SZ(userini));\r\n        lstrcat_s(userini, ARR_SZ(userini), TEXT(\"\\\\AltSnap\"));\r\n        if (INVALID_FILE_ATTRIBUTES == GetFileAttributes(userini)) {\r\n            CreateDirectory(userini, NULL);\r\n            LOG(\"CreateDirectory(%S)\", userini);\r\n        }\r\n        // Full user ini name.\r\n        lstrcat_s(userini, ARR_SZ(userini), TEXT(\"\\\\AltSnap.ini\"));\r\n        if (INVALID_FILE_ATTRIBUTES == GetFileAttributes(userini)) {\r\n            // Copy AltSnap.dni (Default ini file) if no ini present\r\n            lstrcpy_s(&inipath[lstrlen(inipath)-3], 4, TEXT(\"dni\"));\r\n            CopyFile(inipath, userini, FALSE); // AltSnap.dni -> AltSnap.ini\r\n            LOG(\"CopyFile(%S -> %S)\", inipath, userini);\r\n        }\r\n\r\n        lstrcpy_s(inipath, ARR_SZ(inipath), userini);\r\n    }\r\n    LOG(\"ini file: %S\", inipath);\r\n\r\n    // Read parameters on command line\r\n    int help    = !!lstrstr(params, TEXT(\"-help\"))\r\n               || !!lstrstr(params, TEXT(\"/?\"))\r\n               || !!lstrstr(params, TEXT(\"-?\"));\r\n    if (help) {\r\n        static const TCHAR *txthelp =\r\n            TEXT(\"AltSnap command line options:\\n\\n\")\r\n            TEXT(\"--help\\tShow this help!\\n\")\r\n            TEXT(\"-h\\tHide the tray icon\\n\")\r\n            TEXT(\"-q\\tQuiet mode\\n\")\r\n            TEXT(\"-m\\tMultiple instances allowed\\n\")\r\n            TEXT(\"-c\\tOpen Config dialog\\n\")\r\n            TEXT(\"-e\\tElevate AltSnap\\n\")\r\n            TEXT(\"-r\\tRelaod AltSnap settings\\n\")\r\n            TEXT(\"-lX\\tSelect Snap Layout number X\\n\")\r\n            TEXT(\"-afX\\tExecute action X for the foreground window\\n\")\r\n            TEXT(\"-apX\\tExecute action X for the pointed window\\n\");\r\n\r\n        MessageBox(NULL, txthelp, TEXT(APP_NAMEA)TEXT(\" Usage\"), MB_OK|MB_ICONINFORMATION);\r\n        return 0;\r\n    }\r\n\r\n    hide        = !!lstrstr(params, TEXT(\"-h\"));\r\n    int quiet   = !!lstrstr(params, TEXT(\"-q\"));\r\n    int elevate = !!lstrstr(params, TEXT(\"-e\"));\r\n    int multi   = !!lstrstr(params, TEXT(\"-m\"));\r\n    int config  = !!lstrstr(params, TEXT(\"-c\"));\r\n    int rlini   = !!lstrstr(params, TEXT(\"-r\"));\r\n\r\n    // Check if elevated if in >= WinVer\r\n    WinVer = LOBYTE(LOWORD(GetVersion()));\r\n    LOG(\"Running with Windows version %lX\", GetVersion());\r\n    #ifndef NO_VISTA\r\n    if (WinVer >= 6) { // Vista +\r\n        HANDLE token=NULL;\r\n        TOKEN_ELEVATION elevation={0};\r\n        DWORD len=0;\r\n        if (OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &token)\r\n        && GetTokenInformation(token, TokenElevation, &elevation, sizeof(elevation), &len)) {\r\n            elevated = elevation.TokenIsElevated;\r\n            CloseHandle(token);\r\n        }\r\n        LOG(\"Process started %s elevated\", elevated? \"already\": \"non\");\r\n    }\r\n    #endif // NO_VISTA\r\n    LOG(\"Command line parameters read, hide=%d, quiet=%d, elevate=%d, multi=%d, config=%d\"\r\n                                     , hide, quiet, elevate, multi, config);\r\n\r\n    // Look for previous instance\r\n    if (!multi && !GetPrivateProfileInt(TEXT(\"Advanced\"), TEXT(\"MultipleInstances\"), 0, inipath)){\r\n        if (quiet) return 0;\r\n\r\n        HWND previnst = FindWindow(TEXT(APP_NAMEA), TEXT(\"\"));\r\n        if (previnst) {\r\n            // Ask old HotKey window to perform an action.\r\n            const TCHAR *actionstr = lstrstr(params, TEXT(\"-a\"));\r\n            if (actionstr && actionstr[2] && actionstr[3] && actionstr[4]) {\r\n                enum action action = MapActionW(&actionstr[3]);\r\n                HWND msghwnd;\r\n                if ((msghwnd = FindWindow( TEXT(APP_NAMEA)TEXT(\"-HotKeys\"), TEXT(\"\")))) {\r\n                    PostMessage(msghwnd, WM_HOTKEY, (actionstr[2] == 'p')*0x1000+action, 0);\r\n                    return 0;\r\n                }\r\n            }\r\n            // Change layout if asked...\r\n            #define isUDigit(x) ( TEXT('0') <= (x) && (x) <= TEXT('9') )\r\n            const TCHAR *layout = lstrstr(params, TEXT(\"-l\"));\r\n            if (layout && isUDigit(layout[2])) {\r\n                TCHAR numstr[3] = { layout[2], layout[3], TEXT('\\0') };\r\n                if (!isUDigit(numstr[1]))\r\n                    numstr[1] = TEXT('\\0');\r\n                //MessageBox(NULL, NULL, NULL, 0);\r\n                int layoutnumber = CLAMP(0, strtoi(numstr)-1, 9);\r\n                PostMessage(previnst, WM_COMMAND, SWM_SNAPLAYOUT+layoutnumber, 0);\r\n                return 0;\r\n            }\r\n            // Update old instance if no action to be made.\r\n            LOG(\"Previous instance found and no -multi mode\");\r\n            if(hide)   PostMessage(previnst, WM_CLOSECONFIG, 0, 0);\r\n            if(config) PostMessage(previnst, WM_OPENCONFIG, 0, 0);\r\n            if(rlini)  PostMessage(previnst, WM_UPDATESETTINGS, 0, 0);\r\n            PostMessage(previnst, hide? WM_HIDETRAY : WM_ADDTRAY, 0, 0);\r\n            LOG(\"Updated old instance and NORMAL EXIT\");\r\n            return 0;\r\n        }\r\n        LOG(\"No previous instance found\");\r\n    }\r\n\r\n    // Check AlwaysElevate (Vista+ only)\r\n    if (WinVer >= 6 && !elevated) {\r\n        if(!elevate) elevate = GetPrivateProfileInt(TEXT(\"Advanced\"), TEXT(\"AlwaysElevate\"), 0, inipath);\r\n\r\n        // Handle request to elevate to administrator privileges\r\n        if (elevate) {\r\n            LOG(\"Elevation requested\");\r\n            TCHAR path[MAX_PATH];\r\n            GetModuleFileName(NULL, path, ARR_SZ(path));\r\n            HINSTANCE ret = ShellExecute(NULL, TEXT(\"runas\"), path, (hide? TEXT(\"-h\"): NULL), NULL, SW_SHOWNORMAL);\r\n            if ((DorQWORD)ret > 32) {\r\n                LOG(\"Elevation Faild => Not cool NORMAL EXIT\");\r\n                return 0;\r\n            }\r\n            LOG(\"Elevation sucess\");\r\n        } else {\r\n            LOG(\"No Elevation requested\");\r\n        }\r\n    }\r\n    // Language\r\n    UpdateLanguage(); LOG(\"Language updated\");\r\n\r\n    // Create window\r\n    WNDCLASSEX wnd =\r\n        { sizeof(WNDCLASSEX), 0\r\n        , WindowProc, 0, 0, hInst, NULL, NULL\r\n        , NULL, NULL, TEXT(APP_NAMEA), NULL };\r\n    RegisterClassEx(&wnd);\r\n    g_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW|WS_EX_TOPMOST| WS_EX_TRANSPARENT\r\n                            , wnd.lpszClassName , NULL , WS_POPUP\r\n                            , 0, 0, 0, 0, NULL, NULL, hInst, NULL);\r\n    LOG(\"Create main APP Window: %s\", g_hwnd? \"Sucess\": \"Failed\");\r\n    if (elevated) {\r\n        // AltSnap was started elevated!\r\n        // Allow some messages to be sent from non-elevated instance\r\n        // so that user can do AltSnap.exe -c/r/h/l\r\n        UINT i;\r\n        for (i = WM_UPDATETRAY; i <= WM_HIDETRAY; i++)\r\n            ChangeWindowMessageFilterExL(g_hwnd, i, /*MSGFLT_ALLOW*/1, NULL);\r\n    }\r\n    // Tray icon\r\n\r\n    InitTray();\r\n    UpdateTray();\r\n\r\n    // Hook system\r\n    HookSystem();\r\n\r\n    // Add tray if hook failed, even though -hide was supplied\r\n    if (hide && !keyhook) {\r\n        hide = 0;\r\n        UpdateTray();\r\n    }\r\n    // Open config if -config was supplied\r\n    if (config) {\r\n        PostMessage(g_hwnd, WM_OPENCONFIG, 0, 0);\r\n    }\r\n    // Message loop\r\n    LOG(\"Starting \"APP_NAMEA\" message loop...\");\r\n    BOOL ret;\r\n    MSG msg;\r\n    while ((ret = GetMessage( &msg, NULL, 0, 0 )) != 0) {\r\n        if (ret == -1) {\r\n            break;\r\n        } else {\r\n            TranslateMessage(&msg);\r\n            DispatchMessage(&msg);\r\n        }\r\n    }\r\n\r\n    UnhookSystem();\r\n    FreeHooksDLL();\r\n    DestroyWindow(g_hwnd);\r\n    LOG(\"GOOD NORMAL EXIT\");\r\n    return msg.wParam;\r\n}\r\nstatic pure const TCHAR *ParamsFromCmdline(const TCHAR *cmdl)\r\n{\r\n    /* in case it starts with \" we need to go to the next \" */\r\n    if (cmdl[0] == TEXT('\"')) {\r\n        do {\r\n            cmdl++;\r\n        } while(*cmdl && *cmdl != TEXT('\"'));\r\n    } else {\r\n        while(*cmdl && *cmdl != TEXT(' ') && *cmdl != TEXT('\\t')) {\r\n            cmdl++;\r\n        }\r\n    }\r\n    cmdl += !!*cmdl; // Skip the \" or the ' '\r\n    while(*cmdl == TEXT(' ') || *cmdl == TEXT('\\t')) cmdl++;\r\n    return cmdl;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Use -nostdlib and -e_unfuckMain@0 to use this main, -eunfuckMain for x64.\r\n#ifdef _MSC_VER\r\n#pragma comment(linker, \"/entry:\\\"unfuckWinMain\\\"\")\r\n#endif\r\nvoid noreturn WINAPI unfuckWinMain(void)\r\n{\r\n    HINSTANCE hInst;\r\n    HINSTANCE hPrevInstance = NULL;\r\n    const TCHAR *szCmdLine;\r\n    int iCmdShow = 0;\r\n\r\n    hInst = GetModuleHandle(NULL);\r\n    szCmdLine = ParamsFromCmdline(GetCommandLine());\r\n\r\n    ExitProcess(tWinMain(hInst, hPrevInstance, (TCHAR *)szCmdLine, iCmdShow));\r\n}\r\n"
        },
        {
          "name": "altsnap.nsi",
          "type": "blob",
          "size": 5.974609375,
          "content": "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\r\n# define the name of the installer\r\n\r\n!define APP_NAME \"AltSnap\"\r\n!define APP_VERSION \"1.64\"\r\n# define the name of the installer\r\nOutFile \"${APP_NAME}${APP_VERSION}-inst.exe\"\r\nName \"${APP_NAME} ${APP_VERSION}\"\r\n\r\nInstallDir \"$APPDATA\\${APP_NAME}\\\"\r\nInstallDirRegKey HKCU \"Software\\${APP_NAME}\" \"Install_Dir\"\r\n;RequestExecutionLevel user\r\nShowInstDetails show\r\nShowUninstDetails show\r\nSetCompressor /SOLID lzma\r\n\r\n;!include \"LogicLib.nsh\"\r\n;!include \"FileFunc.nsh\"\r\n;!include \"x64.nsh\"\r\n\r\n; The text to prompt the user to enter a directory\r\nDirText \"This will install AltSnap on your computer. Choose a directory\"\r\nPage directory\r\nPage instfiles\r\nPage custom customPage \"\" \": custom page\"\r\n\r\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\r\n# DEFAULT SECTION\r\nSection\r\n\r\n    Call CloseApp\r\n\r\n    # define the output path for this file\r\n    SetOutPath $INSTDIR\r\n\r\n    File AltSnap.dni\r\n\r\n    # define what to install and place it in the output path\r\n    File AltSnap.exe\r\n    File AltSnap.txt\r\n    File AltSnap.xml\r\n    File hooks.dll\r\n    File License.txt\r\n    File sch_On.bat\r\n    File sch_Off.bat\r\n    SetOutPath $INSTDIR\\Lang\r\n    File \"Lang\\_en_US baseline.txt\"\r\n    File Lang\\ca_ES.ini\r\n    File Lang\\de_DE.ini\r\n    File Lang\\es_ES.ini\r\n    File Lang\\fi_FI.ini\r\n    File Lang\\fr_FR.ini\r\n    File Lang\\gl_ES.ini\r\n    File Lang\\it_IT.ini\r\n    File Lang\\ja_JP.ini\r\n    File Lang\\ko_KR.ini\r\n    File Lang\\nb_NO.ini\r\n    File Lang\\nl_NL.ini\r\n    File Lang\\pl_PL.ini\r\n    File Lang\\pt_PR.ini\r\n    File Lang\\ru_RU.ini\r\n    File Lang\\sz_SK.ini\r\n    File Lang\\zh_CN.ini\r\n    File Lang\\zh_TW.ini\r\n\r\n    SetOutPath $INSTDIR\\Themes\\erasmion\r\n    File Themes\\erasmion\\TRAY_OFF.ico\r\n    File Themes\\erasmion\\TRAY_ON.ico\r\n    File Themes\\erasmion\\TRAY_SUS.ico\r\n\r\n    SetOutPath $INSTDIR\r\n    CreateShortcut \"$SMPROGRAMS\\AltSnap.lnk\" \"$INSTDIR\\AltSnap.exe\"\r\n\r\n    WriteRegStr HKCU \"Software\\${APP_NAME}\" \"Install_Dir\" \"$INSTDIR\"\r\n    WriteRegStr HKCU \"Software\\${APP_NAME}\" \"Version\" \"${APP_VERSION}\"\r\n\r\n    ; Create uninstaller\r\n    WriteUninstaller \"Uninstall.exe\"\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"UninstallString\" '\"$INSTDIR\\Uninstall.exe\"'\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"QuietUninstallString\" '\"$INSTDIR\\Uninstall.exe\" /S'\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"DisplayName\" \"${APP_NAME}\"\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"DisplayIcon\" '\"$INSTDIR\\${APP_NAME}.exe\"'\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"DisplayVersion\" \"${APP_VERSION}\"\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"HelpLink\" \"https://github.com/RamonUnch/AltSnap/wiki\"\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"Publisher\" \"Raymond Gillibert\"\r\n    WriteRegStr HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"InstallLocation\" \"$INSTDIR\\\"\r\n    WriteRegDWORD HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"NoModify\" 1\r\n    WriteRegDWORD HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"NoRepair\" 1\r\n\r\n    ; Compute size for uninstall information\r\n    ;${GetSize} \"$INSTDIR\" \"/S=0K\" $0 $1 $2\r\n    ;IntFmt $0 \"0x%08X\" $0\r\n    WriteRegDWORD HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\" \"EstimatedSize\" \"400\"\r\n\r\nSectionEnd\r\n\r\nFunction customPage\r\n  MessageBox MB_YESNO \"Run AltSnap now?\" IDNO NoRunNow\r\n    Exec \"$INSTDIR\\AltSnap.exe\" ; view readme or whatever, if you want.\r\n  NoRunNow:\r\nFunctionEnd\r\n\r\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\r\n# CLOSEAPP\r\n!define WM_CLOSE 0x0010\r\n!macro CloseApp un\r\nFunction ${un}CloseApp\r\n  ; Close app if running\r\n  FindWindow $0 \"${APP_NAME}\" \"\"\r\n  IntCmp $0 0 done\r\n    DetailPrint \"Attempting to close running ${APP_NAME}...\"\r\n    SendMessage $0 ${WM_CLOSE} 0 0 /TIMEOUT=500\r\n    waitloop:\r\n      Sleep 10\r\n      FindWindow $0 \"${APP_NAME}\" \"\"\r\n      IntCmp $0 0 closed waitloop waitloop\r\n  closed:\r\n  Sleep 100 ; Sleep a little extra to let Windows do its thing\r\n\r\n  done:\r\nFunctionEnd\r\n!macroend\r\n!insertmacro CloseApp \"\"\r\n!insertmacro CloseApp \"un.\"\r\n\r\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\r\n# UNINSTALL\r\nSection \"Uninstall\"\r\n\r\n    Call un.CloseApp\r\n\r\n    SetOutPath $INSTDIR\r\n    # Always delete uninstaller first\r\n    Delete \"$INSTDIR\\Uninstall.exe\"\r\n\r\n    # now delete installed file\r\n    Delete \"$INSTDIR\\AltSnap.exe\"\r\n    Delete \"$INSTDIR\\AltSnap.txt\"\r\n    Delete \"$INSTDIR\\AltSnap.xml\"\r\n    Delete \"$INSTDIR\\AltSnap.dni\"\r\n    Delete \"$INSTDIR\\AltSnap.ini\"\r\n    Delete \"$INSTDIR\\AltSnap-old.ini\"\r\n    Delete \"$INSTDIR\\hooks.dll\"\r\n    Delete \"$INSTDIR\\License.txt\"\r\n    Delete \"$INSTDIR\\sch_On.bat\"\r\n    Delete \"$INSTDIR\\sch_Off.bat\"\r\n\r\n    Delete \"Lang\\_en_US baseline.txt\"\r\n    Delete Lang\\ca_ES.ini\r\n    Delete Lang\\de_DE.ini\r\n    Delete Lang\\es_ES.ini\r\n    Delete Lang\\fi_FI.ini\r\n    Delete Lang\\fr_FR.ini\r\n    Delete Lang\\gl_ES.ini\r\n    Delete Lang\\it_IT.ini\r\n    Delete Lang\\ja_JP.ini\r\n    Delete Lang\\ko_KR.ini\r\n    Delete Lang\\nb_NO.ini\r\n    Delete Lang\\nl_NL.ini\r\n    Delete Lang\\pl_PL.ini\r\n    Delete Lang\\pt_PR.ini\r\n    Delete Lang\\ru_RU.ini\r\n    Delete Lang\\sz_SK.ini\r\n    Delete Lang\\zh_CN.ini\r\n    Delete Lang\\zh_TW.ini\r\n    RMDir \"$INSTDIR\\Lang\"\r\n\r\n    Delete Themes\\erasmion\\TRAY_OFF.ico\r\n    Delete Themes\\erasmion\\TRAY_ON.ico\r\n    Delete Themes\\erasmion\\TRAY_SUS.ico\r\n    RMDir \"$INSTDIR\\Themes\\erasmion\"\r\n    RMDir \"$INSTDIR\\Themes\"\r\n\r\n    SetOutPath $APPDATA\r\n    RMDir \"$INSTDIR\"\r\n\r\n    Delete $SMPROGRAMS\\AltSnap.lnk\r\n    DeleteRegValue HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\" \"AltSnap\"\r\n    DeleteRegKey /ifempty HKCU \"Software\\AltSnap\"\r\n    DeleteRegKey /ifempty HKCU \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\AltSnap\"\r\n\r\nSectionEnd\r\n"
        },
        {
          "name": "altsnap.rc",
          "type": "blob",
          "size": 0.859375,
          "content": "#include \"resource.h\"\n\nAPP_ICON ICON \"media/icon.ico\"\nTRAY_OFF ICON \"media/tray-disabled.ico\"\nTRAY_ON  ICON \"media/tray-enabled.ico\"\nTRAY_SUS ICON \"media/tray-suspended.ico\"\n\n#include \"window.rc\"\n\nCREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST \"AltSnap.exe.manifest\"\n\n#define VS_VERSION_INFO 1\nVS_VERSION_INFO VERSIONINFO\n  FILEVERSION VERSIONRC\n  PRODUCTVERSION VERSIONRC\n  FILEFLAGSMASK 0x3fL\n  FILEFLAGS 0x0L\n  FILEOS 0x40004L\n  FILETYPE 0x1L\n  FILESUBTYPE 0x0L\nBEGIN\n  BLOCK \"StringFileInfo\"\n  BEGIN\n    BLOCK \"040904b0\"\n    BEGIN\n      VALUE \"FileDescription\", \"AltSnap\"\n      VALUE \"FileVersion\", APP_VERSION\n      VALUE \"InternalName\", \"altsnap\"\n      VALUE \"OriginalFilename\", \"AltSnap.exe\"\n      VALUE \"CompanyName\", \"Gillibert Software\"\n      VALUE \"LegalCopyright\", \"Gillibert\"\n    END\n  END\n  BLOCK \"VarFileInfo\"\n  BEGIN\n    VALUE \"Translation\", 0x409, 1200\n  END\nEND\n"
        },
        {
          "name": "config.c",
          "type": "blob",
          "size": 88.75,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2020                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#include <commctrl.h>\r\n#include \"resource.h\"\r\n\r\n#ifndef TTM_SETMAXTIPWIDTH\r\n#define TTM_SETMAXTIPWIDTH (WM_USER+24)\r\n#endif\r\n#ifndef PSH_NOCONTEXTHELP\r\n#define PSH_NOCONTEXTHELP 0x02000000\r\n#endif\r\n\r\nBOOL    CALLBACK PropSheetProc(HWND, UINT, LPARAM);\r\nINT_PTR CALLBACK GeneralPageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK MousePageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK KeyboardPageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK BlacklistPageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK AboutPageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK AdvancedPageDialogProc(HWND, UINT, WPARAM, LPARAM);\r\nLRESULT CALLBACK FindWindowProc(HWND, UINT, WPARAM, LPARAM);\r\n\r\nHWND g_cfgwnd = NULL;\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// No error reporting since we don't want the user to be interrupted\r\nstatic void CheckAutostart(int *_on, int *_hidden, int *_elevated)\r\n{\r\n    *_on = *_hidden = *_elevated = 0;\r\n    // Read registry\r\n    HKEY key;\r\n    TCHAR value[MAX_PATH+20] = TEXT(\"\");\r\n    DWORD len = sizeof(value);\r\n    RegOpenKeyEx(HKEY_CURRENT_USER, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"), 0, KEY_QUERY_VALUE, &key);\r\n    RegQueryValueEx(key, TEXT(APP_NAMEA), NULL, NULL, (LPBYTE)value, &len);\r\n    RegCloseKey(key);\r\n\r\n    // Compare to what it should be\r\n    TCHAR compare[MAX_PATH+20];\r\n    GetModuleFileName(NULL, &compare[1], MAX_PATH);\r\n    compare[0] = '\\\"';\r\n    unsigned ll = lstrlen(compare);\r\n    compare[ll] = '\\\"'; compare[++ll]='\\0';\r\n\r\n    if (lstrstr(value, compare) != value) {\r\n        return;\r\n    }\r\n    // Autostart is on, check arguments\r\n    *_on = 1;\r\n    if (lstrstr(value, TEXT(\" -hide\")) != NULL) {\r\n        *_hidden = 1;\r\n    }\r\n    if (lstrstr(value, TEXT(\" -elevate\")) != NULL) {\r\n        *_elevated = 1;\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void SetAutostart(int on, int hhide, int eelevate)\r\n{\r\n    // Open key\r\n    HKEY key;\r\n    int error = RegCreateKeyEx(HKEY_CURRENT_USER\r\n                              , TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\")\r\n                              , 0, NULL, 0, KEY_SET_VALUE, NULL, &key, NULL);\r\n    if (error != ERROR_SUCCESS) return;\r\n    if (on) {\r\n        // Get path\r\n        TCHAR value[MAX_PATH+20];\r\n        GetModuleFileName(NULL, &value[1], MAX_PATH);\r\n        value[0] = '\\\"';\r\n        unsigned ll = lstrlen(value);\r\n        value[ll] = '\\\"'; value[++ll]='\\0';\r\n        // Add -hide or -elevate flags\r\n        if (hhide)    lstrcat_s(value, ARR_SZ(value), TEXT(\" -hide\"));\r\n        if (eelevate) lstrcat_s(value, ARR_SZ(value), TEXT(\" -elevate\"));\r\n        // Set autostart\r\n        RegSetValueEx(key, TEXT(APP_NAMEA), 0, REG_SZ, (LPBYTE)value, (lstrlen(value)+1)*sizeof(value[0]));\r\n    } else {\r\n        // Remove\r\n        RegDeleteValue(key, TEXT(APP_NAMEA));\r\n    }\r\n    // Close key\r\n    RegCloseKey(key);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Only used in the case of Vista+\r\nstatic BOOL ElevateNow(int showconfig)\r\n{\r\n        TCHAR path[MAX_PATH];\r\n        GetModuleFileName(NULL, path, ARR_SZ(path));\r\n        INT_PTR ret;\r\n        if (showconfig)\r\n            ret = (INT_PTR)ShellExecute(NULL, TEXT(\"runas\"), path, TEXT(\"-config -multi\"), NULL, SW_SHOWNORMAL);\r\n        else\r\n            ret = (INT_PTR)ShellExecute(NULL, TEXT(\"runas\"), path, TEXT(\"-multi\"), NULL, SW_SHOWNORMAL);\r\n\r\n        if (ret > 32) {\r\n            PostMessage(g_hwnd, WM_CLOSE, 0, 0);\r\n        } else {\r\n            MessageBox(NULL, l10n->general_elevation_aborted, TEXT(APP_NAMEA), MB_ICONINFORMATION | MB_OK);\r\n        }\r\n        return FALSE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Entry point\r\nstatic void OpenConfig(int startpage)\r\n{\r\n    ListAllTranslations(); // In case\r\n    if (IsWindow(g_cfgwnd)) {\r\n        PropSheet_SetCurSel(g_cfgwnd, 0, startpage);\r\n        SetForegroundWindow(g_cfgwnd);\r\n        return;\r\n    }\r\n    // Define the pages\r\n    static const struct {\r\n        WORD pszTemplate;\r\n        DLGPROC pfnDlgProc;\r\n    } pages[] = {\r\n        { IDD_GENERALPAGE,   (DLGPROC)GeneralPageDialogProc  },\r\n        { IDD_MOUSEPAGE,     (DLGPROC)MousePageDialogProc    },\r\n        { IDD_KBPAGE,        (DLGPROC)KeyboardPageDialogProc },\r\n        { IDD_BLACKLISTPAGE, (DLGPROC)BlacklistPageDialogProc},\r\n        { IDD_ADVANCEDPAGE,  (DLGPROC)AdvancedPageDialogProc },\r\n        { IDD_ABOUTPAGE,     (DLGPROC)AboutPageDialogProc    }\r\n    };\r\n    PROPSHEETPAGE psp[ARR_SZ(pages)];\r\n    mem00(&psp[0], sizeof(psp));\r\n    size_t i;\r\n    for (i = 0; i < ARR_SZ(pages); i++) {\r\n        psp[i].dwSize = sizeof(PROPSHEETPAGE);\r\n        psp[i].hInstance = g_hinst;\r\n        psp[i].pszTemplate = MAKEINTRESOURCE(pages[i].pszTemplate);\r\n        psp[i].pfnDlgProc = pages[i].pfnDlgProc;\r\n    }\r\n\r\n    // Define the property sheet\r\n    PROPSHEETHEADER psh;\r\n    mem00(&psh, sizeof(PROPSHEETHEADER));\r\n    psh.dwSize = sizeof(PROPSHEETHEADER);\r\n    psh.dwFlags = VISTA? PSH_PROPSHEETPAGE|PSH_USECALLBACK|PSH_USEHICON|PSH_NOCONTEXTHELP\r\n                       : PSH_PROPSHEETPAGE|PSH_USECALLBACK|PSH_USEHICON;\r\n    psh.hwndParent = NULL;\r\n    psh.hInstance = g_hinst;\r\n    psh.hIcon = icons[1]; //LoadIcon(g_hinst, iconstr[1]);\r\n    psh.pszCaption = TEXT(APP_NAMEA);\r\n    psh.nPages = ARR_SZ(pages);\r\n    psh.ppsp = psp;\r\n    psh.pfnCallback = PropSheetProc;\r\n    psh.nStartPage = startpage;\r\n\r\n    // Open the property sheet\r\n    InitCommonControls();\r\n    PropertySheet(&psh);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void CloseConfig()\r\n{\r\n    PostMessage(g_cfgwnd, WM_CLOSE, 0, 0);\r\n}\r\n\r\nstatic void MoveButtonUporDown(WORD id, WINDOWPLACEMENT *wndpl, int diffrows)\r\n{\r\n    HWND button = GetDlgItem(g_cfgwnd, id);\r\n    GetWindowPlacement(button, wndpl);\r\n    int height = wndpl->rcNormalPosition.bottom - wndpl->rcNormalPosition.top;\r\n    wndpl->rcNormalPosition.top += 18 * diffrows;\r\n    wndpl->rcNormalPosition.bottom = wndpl->rcNormalPosition.top + height;\r\n    SetWindowPlacement(button, wndpl);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void UpdateStrings()\r\n{\r\n    // Update window title\r\n    PropSheet_SetTitle(g_cfgwnd, 0, l10n->title);\r\n\r\n    // Update tab titles\r\n    // tc = PropSheet_GetTabControl(g_cfgwnd);\r\n    HWND tc = (HWND)SendMessage(g_cfgwnd, PSM_GETTABCONTROL, 0, 0);\r\n    int numrows_prev = TabCtrl_GetRowCount(tc);\r\n    const TCHAR *titles[6];\r\n    titles[0] = l10n->tab_general;\r\n    titles[1] = l10n->tab_mouse;\r\n    titles[2] = l10n->tab_keyboard;\r\n    titles[3] = l10n->tab_blacklist;\r\n    titles[4] = l10n->tab_advanced;\r\n    titles[5] = l10n->tab_about;\r\n    size_t i;\r\n    for (i = 0; i < ARR_SZ(titles); i++) {\r\n        TCITEM ti;\r\n        ti.mask = TCIF_TEXT;\r\n        ti.pszText = (TCHAR *)titles[i];\r\n        TabCtrl_SetItem(tc, i, &ti);\r\n    }\r\n\r\n    // Modify UI if number of rows have changed\r\n    int numrows = TabCtrl_GetRowCount(tc);\r\n    if (numrows_prev != numrows) {\r\n        HWND page = PropSheet_GetCurrentPageHwnd(g_cfgwnd);\r\n        if (page != NULL) {\r\n            int diffrows = numrows - numrows_prev;\r\n            WINDOWPLACEMENT wndpl; wndpl.length = sizeof(WINDOWPLACEMENT);\r\n            // Resize window\r\n            GetWindowPlacement(g_cfgwnd, &wndpl);\r\n            wndpl.rcNormalPosition.bottom += 18 * diffrows;\r\n            SetWindowPlacement(g_cfgwnd, &wndpl);\r\n            // Resize tabcontrol\r\n            GetWindowPlacement(tc, &wndpl);\r\n            wndpl.rcNormalPosition.bottom += 18 * diffrows;\r\n            SetWindowPlacement(tc, &wndpl);\r\n            // Move button\r\n            MoveButtonUporDown(IDOK,     &wndpl, diffrows);\r\n            MoveButtonUporDown(IDCANCEL, &wndpl, diffrows);\r\n            MoveButtonUporDown(IDAPPLY,  &wndpl, diffrows);\r\n            // Re-select tab\r\n            PropSheet_SetCurSel(g_cfgwnd, page, 0);\r\n            // Invalidate region\r\n            GetWindowPlacement(g_cfgwnd, &wndpl);\r\n            InvalidateRect(g_cfgwnd, &wndpl.rcNormalPosition, TRUE);\r\n        }\r\n    }\r\n}\r\nstatic void MoveToCorner(HWND hwnd)\r\n{\r\n    hwnd = GetAncestor(hwnd, GA_ROOT);\r\n    static HWND ohwnd;\r\n    if(hwnd == ohwnd) return;\r\n    ohwnd = hwnd;\r\n\r\n    RECT rc;\r\n    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n    POINT pt;\r\n    GetCursorPos(&pt);\r\n    GetMonitorInfo(MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST), &mi);\r\n\r\n    GetWindowRect(hwnd, &rc);\r\n    int x, y;\r\n    long h = rc.bottom - rc.top;\r\n    long w = rc.right - rc.left;\r\n    if (pt.x < (mi.rcWork.right - mi.rcWork.left)/2) {\r\n        x = mi.rcWork.left;\r\n    } else {\r\n        x = mi.rcWork.right - w;\r\n    }\r\n    if (pt.y < (mi.rcWork.bottom - mi.rcWork.top)/2) {\r\n        y = mi.rcWork.top;\r\n    } else {\r\n        y = mi.rcWork.bottom - h;\r\n    }\r\n    SetWindowPos(hwnd, NULL, x, y, w, h\r\n        , SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE|SWP_NOSIZE|SWP_ASYNCWINDOWPOS);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nBOOL CALLBACK PropSheetProc(HWND hwnd, UINT msg, LPARAM lParam)\r\n{\r\n    if (msg == PSCB_INITIALIZED) {\r\n        g_cfgwnd = hwnd;\r\n        UpdateStrings();\r\n\r\n        // Set new icon specifically for the taskbar and Alt+Tab, without changing window icon\r\n        HICON taskbar_icon = (HICON)LoadImageA(g_hinst, \"APP_ICON\", IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);\r\n        SendMessage(g_cfgwnd, WM_SETICON, ICON_BIG, (LPARAM) taskbar_icon);\r\n    }\r\n    return TRUE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic DWORD IsUACEnabled()\r\n{\r\n    DWORD uac_enabled = 0;\r\n    if (elevated) {\r\n        DWORD len = sizeof(uac_enabled);\r\n        HKEY key;\r\n        RegOpenKeyEx(\r\n            HKEY_LOCAL_MACHINE\r\n          , TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System\")\r\n          , 0, KEY_QUERY_VALUE, &key);\r\n\r\n        RegQueryValueEx(key, TEXT(\"EnableLUA\"), NULL, NULL, (LPBYTE) &uac_enabled, &len);\r\n        RegCloseKey(key);\r\n    }\r\n    return uac_enabled;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Helper functions and Macro\r\n#define IsChecked(idc) IsDlgButtonChecked(hwnd, idc)\r\n//#define IsCheckedW(idc) itostr(IsChecked(idc), txt, 10)\r\n\r\n#define CB_ResetContent(hwnd) SendMessage(hwnd, CB_RESETCONTENT, 0, 0)\r\n#define CB_AddString(hwnd, txt) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)txt)\r\n#define CB_DeleteString(hwnd, i) SendMessage(hwnd, CB_DELETESTRING, i, 0)\r\n#define CB_SetCurSel(hwnd, i) SendMessage(hwnd, CB_SETCURSEL, i, 0)\r\n#define CB_GetCurSel(hwnd) (int)(DWORD)SendMessage(hwnd, CB_GETCURSEL, 0, 0)\r\nstatic int CB_GetCurSelDlgItem(HWND hwnd, UINT id) { return (int)(DWORD)SendMessage(GetDlgItem(hwnd, id), CB_GETCURSEL, 0, 0); }\r\n#define CB_GetCurSelId(id) CB_GetCurSelDlgItem(hwnd, id)\r\n#define CB_GetText(id, txt, txtlen) (int)(DWORD)SendMessage(GetDlgItem(hwnd, id), WM_GETTEXT, (WPARAM)txtlen, (LPARAM)txt)\r\nstatic void WriteOptionBoolW(HWND hwnd, WORD id, const TCHAR *section, const char *name_s)\r\n{\r\n    TCHAR name[64];\r\n    str2tchar(name, name_s);\r\n    WritePrivateProfileString(section, name, IsDlgButtonChecked(hwnd, id)? TEXT(\"1\"): TEXT(\"0\"), inipath);\r\n}\r\n#define WriteOptionBool(id, section, name) WriteOptionBoolW(hwnd, id, section, name)\r\nstatic int WriteOptionBoolBW(HWND hwnd, WORD id, const TCHAR *section, const char *name_s, int bit)\r\n{\r\n    TCHAR txt[UINT_DIGITS+1];\r\n    TCHAR name[64];\r\n    str2tchar(name, name_s);\r\n    int val = GetPrivateProfileInt(section, name, 0, inipath);\r\n    if (IsDlgButtonChecked(hwnd, id))\r\n        val = setBit(val, bit);\r\n    else\r\n        val = clearBit(val, bit);\r\n\r\n    WritePrivateProfileString(section, name, Uint2lStr(txt, val), inipath);\r\n    return val;\r\n}\r\n#define WriteOptionBoolB(id, section, name, bit) WriteOptionBoolBW(hwnd, id, section, name, bit)\r\n\r\nstatic void WriteOptionStrW(HWND hwnd, WORD id, const TCHAR *section, const char *name_s)\r\n{\r\n    TCHAR txt[1024];\r\n    TCHAR name[64];\r\n    str2tchar(name, name_s);\r\n    GetDlgItemText(hwnd, id, txt, ARR_SZ(txt));\r\n    WritePrivateProfileString(section, name, txt, inipath);\r\n}\r\n#define WriteOptionStr(id, section, name)  WriteOptionStrW(hwnd, id, section, name)\r\n\r\nstatic void ReadOptionStrW(HWND hwnd, WORD id, const TCHAR *section, const char *name_s, const TCHAR *def)\r\n{\r\n    TCHAR txt[1024];\r\n    TCHAR name[64];\r\n    str2tchar(name, name_s);\r\n    GetPrivateProfileString(section, name, def, txt, ARR_SZ(txt), inipath);\r\n    SetDlgItemText(hwnd, id, txt);\r\n}\r\n#define ReadOptionStr(id, section, name, def) ReadOptionStrW(hwnd, id, section, name, def)\r\n\r\nstatic int ReadOptionIntW(HWND hwnd, WORD id, const TCHAR *section, const char *name_s, int def, int mask)\r\n{\r\n    TCHAR name[64];\r\n    str2tchar(name, name_s);\r\n    int ret = GetPrivateProfileInt(section, name, def, inipath);\r\n    CheckDlgButton(hwnd, id, (ret&mask)? BST_CHECKED: BST_UNCHECKED);\r\n    return ret;\r\n}\r\n#define ReadOptionInt(id, section, name, def, mask) ReadOptionIntW(hwnd, id, section, name, def, mask)\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Description:\r\n//   Creates a tooltip for an item in a dialog box.\r\n// Parameters:\r\n//   idTool - identifier of an dialog box item.\r\n//   nDlg - window handle of the dialog box.\r\n//   pszText - string to use as the tooltip text.\r\n// Returns:\r\n//   The handle to the tooltip.\r\n//\r\nstatic HWND CreateInfoTip(HWND hDlg, int toolID, const TCHAR * const pszText)\r\n{\r\n    if (!toolID || !hDlg || !pszText || !*pszText)\r\n        return NULL;\r\n\r\n    // Get the window of the tool.\r\n    HWND hwndTool = GetDlgItem(hDlg, toolID);\r\n\r\n    // Create the tooltip. g_hInst is the global instance handle.\r\n    // Windows are owned by the dialog box so we do not need\r\n    // to explicitely  destroy them.\r\n    HWND hwndTip = CreateWindowEx(0, TOOLTIPS_CLASS, NULL,\r\n                       WS_POPUP | TTS_ALWAYSTIP ,\r\n                       CW_USEDEFAULT, CW_USEDEFAULT,\r\n                       CW_USEDEFAULT, CW_USEDEFAULT,\r\n                       hDlg, NULL, g_hinst, NULL);\r\n\r\n   if (!hwndTool || !hwndTip)\r\n       return NULL;\r\n\r\n    // Associate the tooltip with the tool.\r\n    TOOLINFO toolInfo = { 0 };\r\n    toolInfo.cbSize = sizeof(toolInfo);\r\n    toolInfo.hwnd = hDlg;\r\n    toolInfo.uFlags = TTF_IDISHWND | TTF_SUBCLASS ;\r\n    toolInfo.uId = (UINT_PTR)hwndTool;\r\n    toolInfo.lpszText = (TCHAR * const)pszText;\r\n    SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo);\r\n    SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELONG(32767,0));\r\n    RECT rc; GetClientRect(hDlg, &rc);\r\n    SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, (rc.right-rc.left)*3/4);\r\n\r\n    return hwndTip;\r\n}\r\nstruct dialogstring { short idc; short l10nidx; /* const TCHAR *const helpstr; */ };\r\nstatic void UpdateDialogStrings(HWND hwnd, const struct dialogstring * const strlst, unsigned size)\r\n{\r\n    unsigned i;\r\n    for (i=0; i < size; i++) {\r\n        SetDlgItemText(hwnd, strlst[i].idc, L10NSTR(strlst[i].l10nidx));\r\n        //CreateInfoTip(hwnd, strlst[i].idc, L10NSTR(strlst[i].l10nidx));\r\n    }\r\n}\r\n// Options to bead or written...\r\nenum opttype {T_BOL=0, T_BMK=1, T_STR=2};\r\nstruct optlst {\r\n    short idc;\r\n    UCHAR type;\r\n    UCHAR bitN;\r\n    TCHAR *section;\r\n    char *name;\r\n    void *def;\r\n};\r\nstatic void ReadDialogOptions(HWND hwnd,const struct optlst *ol, unsigned size)\r\n{\r\n    unsigned i;\r\n    for (i=0; i < size; i++) {\r\n        if (ol[i].type == T_BOL)\r\n            ReadOptionIntW(hwnd, ol[i].idc, ol[i].section, ol[i].name, (int)(DorQWORD)ol[i].def, -1);\r\n        else if (ol[i].type == T_BMK)\r\n            ReadOptionIntW(hwnd, ol[i].idc, ol[i].section, ol[i].name, (int)(DorQWORD)ol[i].def, 1<<ol[i].bitN);\r\n        else\r\n            ReadOptionStrW(hwnd, ol[i].idc, ol[i].section, ol[i].name, (TCHAR*)ol[i].def);\r\n    }\r\n}\r\nstatic void WriteDialogOptions(HWND hwnd,const struct optlst *ol, unsigned size)\r\n{\r\n    unsigned i;\r\n    for (i=0; i < size; i++) {\r\n        if (ol[i].type == T_BOL)\r\n            WriteOptionBoolW(hwnd, ol[i].idc, ol[i].section, ol[i].name);\r\n        else if(ol[i].type == T_BMK)\r\n            WriteOptionBoolBW(hwnd, ol[i].idc, ol[i].section, ol[i].name, ol[i].bitN);\r\n        else\r\n            WriteOptionStrW(hwnd, ol[i].idc, ol[i].section, ol[i].name);\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// to be used with EnumDesktopWindows()\r\nBOOL CALLBACK RefreshTestWin(HWND hwnd, LPARAM lp)\r\n{\r\n    TCHAR classn[256];\r\n    if (GetClassName(hwnd, classn, ARR_SZ(classn))\r\n    && !lstrcmp(TEXT(APP_NAMEA)TEXT(\"-Test\"), classn) ) {\r\n        PostMessage(hwnd, WM_UPDCFRACTION, 0, 0);\r\n        SetWindowPos(hwnd, NULL, 0, 0, 0, 0\r\n            , SWP_NOCOPYBITS|SWP_NOMOVE|SWP_NOREPOSITION|SWP_NOSIZE );\r\n    }\r\n    return TRUE;\r\n}\r\n\r\nstatic int FindIDCStrIDX(const struct dialogstring sl[], size_t len, int idc)\r\n{\r\n    size_t i;\r\n    for (i=0; i<len; i++) {\r\n        if (idc == (int)sl[i].idc)\r\n            return sl[i].l10nidx;\r\n    }\r\n    return -1;\r\n}\r\nstatic void ShowContextHelp(const struct dialogstring sl[], size_t len, HWND hwnd, LPHELPINFO hi)\r\n{\r\n    if (hi->iContextType == HELPINFO_WINDOW) {\r\n        int id = FindIDCStrIDX(sl, len, hi->iCtrlId);\r\n        if (id >= 0) {\r\n            SetDlgItemText( hwnd, IDC_HELPPANNEL, L10NSTR(id) );\r\n            //MessageBox(hwnd, L10NSTR(id), NULL, 0);\r\n        }\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK GeneralPageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    #define V (void *)\r\n    // Options to bead or written...\r\n    static const struct optlst optlst[] = {\r\n       // dialog id, type, bit number, section name, option name, def val.\r\n        { IDC_AUTOFOCUS,     T_BOL, 0,  TEXT(\"General\"),  \"AutoFocus\", V 0 },\r\n        { IDC_AERO,          T_BOL, 0,  TEXT(\"General\"),  \"Aero\", V 1 },\r\n        { IDC_SMARTAERO,     T_BMK, 0,  TEXT(\"General\"),  \"SmartAero\", V 1 },\r\n        { IDC_SMARTERAERO,   T_BMK, 1,  TEXT(\"General\"),  \"SmartAero\", V 0 },\r\n        { IDC_STICKYRESIZE,  T_BOL, 0,  TEXT(\"General\"),  \"StickyResize\", V 1 },\r\n        { IDC_INACTIVESCROLL,T_BOL, 0,  TEXT(\"General\"),  \"InactiveScroll\", V 0 },\r\n        { IDC_MDI,           T_BOL, 0,  TEXT(\"General\"),  \"MDI\", V 1 },\r\n        { IDC_RESIZEALL,     T_BOL, 0,  TEXT(\"Advanced\"), \"ResizeAll\", V 1 },\r\n        { IDC_USEZONES,      T_BMK, 0,  TEXT(\"Zones\"),    \"UseZones\", V 0 },\r\n        { IDC_PIERCINGCLICK, T_BOL, 0,  TEXT(\"Advanced\"), \"PiercingClick\", V 0 },\r\n    };\r\n    #undef V\r\n\r\n    static const struct dialogstring strlst[] = {\r\n        { IDC_GENERAL_BOX,      L10NIDX(general_box) },\r\n        { IDC_AUTOFOCUS,        L10NIDX(general_autofocus) },\r\n        { IDC_AERO,             L10NIDX(general_aero) },\r\n        { IDC_SMARTAERO,        L10NIDX(general_smartaero) },\r\n        { IDC_SMARTERAERO,      L10NIDX(general_smarteraero) },\r\n        { IDC_STICKYRESIZE,     L10NIDX(general_stickyresize) },\r\n        { IDC_INACTIVESCROLL,   L10NIDX(general_inactivescroll) },\r\n        { IDC_MDI,              L10NIDX(general_mdi) },\r\n        { IDC_AUTOSNAP_HEADER,  L10NIDX(general_autosnap) },\r\n        { IDC_LANGUAGE_HEADER,  L10NIDX(general_language) },\r\n        { IDC_USEZONES,         L10NIDX(general_usezones) },\r\n        { IDC_PIERCINGCLICK,    L10NIDX(general_piercingclick) },\r\n        { IDC_RESIZEALL,        L10NIDX(general_resizeall) },\r\n        { IDC_RESIZECENTER,     L10NIDX(general_resizecenter) },\r\n        { IDC_RZCENTER_NORM,    L10NIDX(general_resizecenter_norm) },\r\n        { IDC_RZCENTER_BR,      L10NIDX(general_resizecenter_br) },\r\n        { IDC_RZCENTER_MOVE,    L10NIDX(general_resizecenter_move) },\r\n        { IDC_RZCENTER_CLOSE,   L10NIDX(general_resizecenter_close) },\r\n        { IDC_AUTOSTART_BOX,    L10NIDX(general_autostart_box) },\r\n        { IDC_AUTOSTART,        L10NIDX(general_autostart) },\r\n        { IDC_AUTOSTART_HIDE,   L10NIDX(general_autostart_hide) },\r\n        { IDC_AUTOSTART_ELEVATE,L10NIDX(general_autostart_elevate) }\r\n    };\r\n\r\n    int updatestrings = 0;\r\n    static int have_to_apply = 0;\r\n    if (msg == WM_INITDIALOG) {\r\n        MoveToCorner(g_cfgwnd);\r\n        int ret;\r\n        ReadDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n\r\n        ret = GetPrivateProfileInt(TEXT(\"General\"), TEXT(\"ResizeCenter\"), 1, inipath);\r\n        ret = ret==1? IDC_RZCENTER_NORM: ret==2? IDC_RZCENTER_MOVE: ret==3? IDC_RZCENTER_CLOSE: IDC_RZCENTER_BR;\r\n        CheckRadioButton(hwnd, IDC_RZCENTER_NORM, IDC_RZCENTER_CLOSE, ret);\r\n\r\n        HWND control = GetDlgItem(hwnd, IDC_LANGUAGE);\r\n        CB_ResetContent(control);\r\n        EnableWindow(control, TRUE);\r\n        int i;\r\n        if (langinfo) {\r\n            for (i = 0; i < nlanguages; i++) {\r\n                CB_AddString(control, langinfo[i].lang);\r\n                if (langinfo[i].code && !lstrcmpi(l10n->code, langinfo[i].code) ) {\r\n                    CB_SetCurSel(control, i);\r\n                }\r\n            }\r\n        }\r\n        EnableDlgItem(hwnd, IDC_ELEVATE, VISTA && !elevated);\r\n//    } else if (msg == WM_HELP) {\r\n//        ShowContextHelp(strlst, ARR_SZ(strlst), hwnd, (LPHELPINFO)lParam);\r\n    } else if (msg == WM_COMMAND) {\r\n        int id = LOWORD(wParam);\r\n        int event = HIWORD(wParam);\r\n        int val = IsDlgButtonChecked(hwnd, id);\r\n        if (id == IDC_SMARTAERO) {\r\n            EnableDlgItem(hwnd, IDC_SMARTERAERO, IsChecked(IDC_SMARTAERO));\r\n        }\r\n\r\n        if (id != IDC_ELEVATE && (event == 0 ||  event == CBN_SELCHANGE)) {\r\n            PropSheet_Changed(g_cfgwnd, hwnd);\r\n            have_to_apply = 1;\r\n        }\r\n        if (IDC_RZCENTER_NORM <= id && id <= IDC_RZCENTER_CLOSE) {\r\n            CheckRadioButton(hwnd, IDC_RZCENTER_NORM, IDC_RZCENTER_CLOSE, id);\r\n        } else if (id == IDC_AUTOSTART) {\r\n            EnableDlgItem(hwnd, IDC_AUTOSTART_HIDE, val);\r\n            EnableDlgItem(hwnd, IDC_AUTOSTART_ELEVATE, val && VISTA);\r\n            if (!val) {\r\n                CheckDlgButton(hwnd, IDC_AUTOSTART_HIDE, BST_UNCHECKED);\r\n                CheckDlgButton(hwnd, IDC_AUTOSTART_ELEVATE, BST_UNCHECKED);\r\n            }\r\n        } else if (id == IDC_AUTOSTART_ELEVATE) {\r\n            if (val && IsUACEnabled()) {\r\n                MessageBox(NULL, l10n->general_autostart_elevate_tip, TEXT(APP_NAMEA), MB_ICONINFORMATION | MB_OK);\r\n            }\r\n        } else if (id == IDC_ELEVATE) {\r\n            return ElevateNow(1);\r\n        }\r\n    } else if (msg == WM_NOTIFY) {\r\n        LPNMHDR pnmh = (LPNMHDR) lParam;\r\n\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            updatestrings = 1;\r\n\r\n            // Autostart\r\n            int autostart = 0, hidden = 0, eelevated = 0;\r\n            CheckAutostart(&autostart, &hidden, &eelevated);\r\n            CheckDlgButton(hwnd, IDC_AUTOSTART, autostart ? BST_CHECKED : BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_AUTOSTART_HIDE, hidden ? BST_CHECKED : BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_AUTOSTART_ELEVATE, eelevated ? BST_CHECKED : BST_UNCHECKED);\r\n            EnableDlgItem(hwnd, IDC_AUTOSTART_HIDE, autostart);\r\n            EnableDlgItem(hwnd, IDC_AUTOSTART_ELEVATE, autostart && VISTA);\r\n            if(WIN10) EnableDlgItem(hwnd, IDC_INACTIVESCROLL, IsChecked(IDC_INACTIVESCROLL));\r\n        } else if (pnmh->code == PSN_APPLY && have_to_apply) {\r\n            // all bool options (checkboxes).\r\n            WriteDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n\r\n            TCHAR txt[UINT_DIGITS+1];\r\n            int val = CB_GetCurSelId(IDC_AUTOSNAP);\r\n            WritePrivateProfileString(TEXT(\"General\"),    TEXT(\"AutoSnap\"), Uint2lStr(txt, val), inipath);\r\n\r\n            val = IsChecked(IDC_RZCENTER_NORM)? 1: IsChecked(IDC_RZCENTER_MOVE)? 2:IsChecked(IDC_RZCENTER_CLOSE)? 3: 0;\r\n            WritePrivateProfileString(TEXT(\"General\"),    TEXT(\"ResizeCenter\"), Uint2lStr(txt, val), inipath);\r\n\r\n            // Load selected Language\r\n            int i = CB_GetCurSelId(IDC_LANGUAGE);\r\n            if (i < nlanguages && langinfo && lstrcmp(l10n->code, langinfo[i].code)) {\r\n                LoadTranslation(langinfo[i].fn);\r\n                #ifdef UNICODE\r\n                wchar_t curlang[16];\r\n                GetCUserLanguage_xx_XX(curlang);\r\n                if (!lstrcmpi(l10n->code, curlang)) // Use Auto if selected language is the current user's one.\r\n                    WritePrivateProfileString(TEXT(\"General\"), TEXT(\"Language\"), TEXT(\"Auto\"), inipath);\r\n                else\r\n                    WritePrivateProfileString(TEXT(\"General\"), TEXT(\"Language\"), l10n->code, inipath);\r\n                #else\r\n                WritePrivateProfileString(TEXT(\"General\"), TEXT(\"Language\"), l10n->code, inipath);\r\n                #endif\r\n                updatestrings = 1;\r\n                UpdateStrings();\r\n            }\r\n\r\n            // Autostart\r\n            SetAutostart(IsChecked(IDC_AUTOSTART), IsChecked(IDC_AUTOSTART_HIDE), IsChecked(IDC_AUTOSTART_ELEVATE));\r\n\r\n            UpdateSettings();\r\n            // Update Test windows in if open.\r\n            EnumThreadWindows(GetCurrentThreadId(), RefreshTestWin, 0);\r\n\r\n            have_to_apply = 0;\r\n        }\r\n    }\r\n    if (updatestrings) {\r\n        // Update text\r\n        UpdateDialogStrings(hwnd, strlst, ARR_SZ(strlst));\r\n        // spetial case...\r\n        //CreateToolTip(IDC_AUTOFOCUS, hwnd, TEXT(\"String\\nExample\"));\r\n        SetDlgItemText(hwnd, IDC_ELEVATE, elevated?l10n->general_elevated: l10n->general_elevate);\r\n\r\n        // AutoSnap\r\n        HWND control = GetDlgItem(hwnd, IDC_AUTOSNAP);\r\n        CB_ResetContent(control);\r\n        CB_AddString(control, l10n->general_autosnap0);\r\n        CB_AddString(control, l10n->general_autosnap1);\r\n        CB_AddString(control, l10n->general_autosnap2);\r\n        CB_AddString(control, l10n->general_autosnap3);\r\n        TCHAR txt[8];\r\n        GetPrivateProfileString(TEXT(\"General\"), TEXT(\"AutoSnap\"), TEXT(\"0\"), txt, ARR_SZ(txt), inipath);\r\n        CB_SetCurSel(control, strtoi(txt));\r\n\r\n        // Language\r\n        control = GetDlgItem(hwnd, IDC_LANGUAGE);\r\n        CB_DeleteString(control, nlanguages);\r\n    }\r\n    return FALSE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int pure IsKeyInList(TCHAR *keys, unsigned vkey)\r\n{\r\n    unsigned temp, numread;\r\n    TCHAR *pos = keys;\r\n    while (*pos != '\\0') {\r\n        numread = 0;\r\n        temp = lstrhex2u(pos);\r\n        while (pos[numread] && pos[numread] != ' ') numread++;\r\n        while (pos[numread] == ' ') numread++;\r\n        if (temp == vkey) {\r\n            return 1;\r\n        }\r\n        pos += numread;\r\n    }\r\n    return 0;\r\n}\r\nstatic void AddvKeytoList(TCHAR keys[32], unsigned vkey)\r\n{\r\n    // Check if it is already in the list.\r\n    if (IsKeyInList(keys, vkey))\r\n        return;\r\n    // Add a key to the hotkeys list\r\n    if (*keys != '\\0') {\r\n        lstrcat_s(keys, 32, TEXT(\" \"));\r\n    }\r\n    TCHAR buf[LPTR_HDIGITS+1];\r\n    lstrcat_s(keys, 32, LPTR2Hex(buf, vkey));\r\n}\r\nstatic void RemoveKeyFromList(TCHAR keys[32], unsigned vkey)\r\n{\r\n    // Remove the key from the hotclick list\r\n    unsigned temp, numread;\r\n    TCHAR *pos = keys;\r\n    while (*pos != '\\0') {\r\n        numread = 0;\r\n        temp = lstrhex2u(pos);\r\n        while(pos[numread] && pos[numread] != ' ') numread++;\r\n        while(pos[numread] == ' ') numread++;\r\n        if (temp == vkey) {\r\n            keys[pos - keys] = '\\0';\r\n            lstrcat_s(keys, 32, pos + numread);\r\n            break;\r\n        }\r\n        pos += numread;\r\n    }\r\n    // Strip eventual remaining spaces\r\n    unsigned ll = lstrlen(keys);\r\n    while (ll > 0 && keys[--ll] == ' ') keys[ll]='\\0';\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstruct hk_struct {\r\n    unsigned control;\r\n    unsigned vkey;\r\n};\r\nstatic void SaveHotKeys(const struct hk_struct *const hotkeys, HWND hwnd, const TCHAR *const name)\r\n{\r\n    TCHAR keys[32];\r\n    // Get the current config in case there are some user added keys.\r\n    GetPrivateProfileString(TEXT(\"Input\"), name, TEXT(\"\"), keys, ARR_SZ(keys), inipath);\r\n    unsigned i;\r\n    for (i = 0; hotkeys[i].control; i++) {\r\n         if (IsChecked(hotkeys[i].control)) {\r\n             AddvKeytoList(keys, hotkeys[i].vkey);\r\n         } else {\r\n             RemoveKeyFromList(keys, hotkeys[i].vkey);\r\n         }\r\n    }\r\n    WritePrivateProfileString(TEXT(\"Input\"), name, keys, inipath);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void CheckConfigHotKeys(const struct hk_struct *hotkeys, HWND hwnd, const TCHAR *hotkeystr, const TCHAR* def)\r\n{\r\n    // Hotkeys\r\n    size_t i;\r\n    unsigned temp;\r\n    TCHAR txt[32];\r\n    GetPrivateProfileString(TEXT(\"Input\"), hotkeystr, def, txt, ARR_SZ(txt), inipath);\r\n    TCHAR *pos = txt;\r\n    while (*pos != '\\0') {\r\n        temp = lstrhex2u(pos);\r\n        while(*pos && *pos != ' ') pos++;\r\n        while(*pos == ' ') pos++;\r\n\r\n        // What key was that?\r\n        for (i = 0; hotkeys[i].control ; i++) {\r\n            if (temp == hotkeys[i].vkey) {\r\n                CheckDlgButton(hwnd, hotkeys[i].control, BST_CHECKED);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstruct actiondl {\r\n    TCHAR *action;\r\n    short l10nidx;\r\n//    const unsigned short flgs;\r\n//    const TCHAR *const l10n;\r\n};\r\nstatic void FillActionDropListS(HWND hwnd, int idc, TCHAR *inioption, const struct actiondl *actions)\r\n{\r\n    HWND control = GetDlgItem(hwnd, idc);\r\n    TCHAR txt[64];\r\n    int sel=0, j;\r\n    CB_ResetContent(control);\r\n    if (inioption) {\r\n        sel = -1; // Selection to be made\r\n        GetPrivateProfileString(TEXT(\"Input\"), inioption, TEXT(\"Nothing\"), txt, ARR_SZ(txt), inipath);\r\n    }\r\n    for (j = 0; actions[j].action; j++) {\r\n        TCHAR action_name[256];\r\n        lstrcpy_noaccel(action_name, L10NSTR(actions[j].l10nidx), ARR_SZ(action_name));\r\n        CB_AddString(control, action_name);\r\n        if (inioption && !lstrcmp(txt, actions[j].action)) {\r\n            sel = j;\r\n        }\r\n    }\r\n    if (sel < 0) {\r\n        // sel is negative if the string was not found in the struct actiondl:\r\n        // UNKNOWN ACTION, so we add it manually at the end of the list\r\n        CB_AddString(control, txt);\r\n        sel = j; // And select this unknown action.\r\n    }\r\n    CB_SetCurSel(control, sel);\r\n}\r\nstatic void WriteActionDropListS(HWND hwnd, int idc, TCHAR *inioption, const struct actiondl *actions)\r\n{\r\n    HWND control = GetDlgItem(hwnd, idc);\r\n    int j = SendMessage(control, CB_GETCURSEL, 0, 0);\r\n    if (j >= 0 && actions[j].action) { // Inside of known values\r\n        WritePrivateProfileString(TEXT(\"Input\"), inioption, actions[j].action, inipath);\r\n        return; // DONE!\r\n    }\r\n\r\n    // User directly Wrote the specified string?\r\n    TCHAR txt[128]=TEXT(\"\");\r\n    if (0 < (int)(DWORD)SendMessage(control, WM_GETTEXT, ARR_SZ(txt), (LPARAM)txt) && *txt ) {\r\n        // Action was direcly written!\r\n        j = SendMessage(control, CB_FINDSTRINGEXACT, /*start index=*/-1, (LPARAM)txt);\r\n        if( j>=0 ) // Found index.\r\n            WritePrivateProfileString(TEXT(\"Input\"), inioption, actions[j].action, inipath);\r\n        else\r\n            WritePrivateProfileString(TEXT(\"Input\"), inioption, txt, inipath);\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK MousePageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    static int have_to_apply = 0;\r\n    // Mouse actions\r\n    static const struct {\r\n        int control; // Same control\r\n        TCHAR *option[5]; // Prim/alt/TTB/WM/WR\r\n    } mouse_buttons[] = {\r\n        { IDC_LMB,     {TEXT(\"LMB\"), TEXT(\"LMBB\"), TEXT(\"LMBT\"), TEXT(\"LMBM\"), TEXT(\"LMBR\")} },\r\n        { IDC_MMB,     {TEXT(\"MMB\"), TEXT(\"MMBB\"), TEXT(\"MMBT\"), TEXT(\"MMBM\"), TEXT(\"MMBR\")} },\r\n        { IDC_RMB,     {TEXT(\"RMB\"), TEXT(\"RMBB\"), TEXT(\"RMBT\"), TEXT(\"RMBM\"), TEXT(\"RMBR\")} },\r\n        { IDC_MB4,     {TEXT(\"MB4\"), TEXT(\"MB4B\"), TEXT(\"MB4T\"), TEXT(\"MB4M\"), TEXT(\"MB4R\")} },\r\n        { IDC_MB5,     {TEXT(\"MB5\"), TEXT(\"MB5B\"), TEXT(\"MB5T\"), TEXT(\"MB5M\"), TEXT(\"MB5M\")} },\r\n    };\r\n    static const struct {\r\n        int control; // Same control\r\n        TCHAR *option[5]; // Prim/alt/TTB/WM/WR\r\n    } mouse_buttonsUP[] = {\r\n        { IDC_MOVEUP,  {TEXT(\"MoveUp\"), TEXT(\"MoveUpB\"), TEXT(\"MoveUpT\"), TEXT(\"MoveUp\"), TEXT(\"MoveUp\")} },\r\n        { IDC_RESIZEUP,{TEXT(\"ResizeUp\"), TEXT(\"ResizeUpB\"), TEXT(\"ResizeUpT\"), TEXT(\"ResizeUp\"), TEXT(\"ResizeUp\")} },\r\n    };\r\n\r\n    #define COMMON_ACTIONS \\\r\n        {TEXT(\"Close\"),       L10NIDX(input_actions_close) },   \\\r\n        {TEXT(\"Kill\"),        L10NIDX(input_actions_kill) },    \\\r\n        {TEXT(\"Minimize\"),    L10NIDX(input_actions_minimize) }, \\\r\n        {TEXT(\"Maximize\"),    L10NIDX(input_actions_maximize) }, \\\r\n        {TEXT(\"Lower\"),       L10NIDX(input_actions_lower) },    \\\r\n        {TEXT(\"Focus\"),       L10NIDX(input_actions_focus) },    \\\r\n        {TEXT(\"NStacked\"),    L10NIDX(input_actions_nstacked) }, \\\r\n        {TEXT(\"PStacked\"),    L10NIDX(input_actions_pstacked) }, \\\r\n        {TEXT(\"StackList\"),   L10NIDX(input_actions_stacklist) }, \\\r\n        {TEXT(\"StackList2\"),  L10NIDX(input_actions_stacklist2) }, \\\r\n        {TEXT(\"AltTabList\"),  L10NIDX(input_actions_alttablist) }, \\\r\n        {TEXT(\"AltTabFullList\"), L10NIDX(input_actions_alttabfulllist) }, \\\r\n        {TEXT(\"Roll\"),        L10NIDX(input_actions_roll) },  \\\r\n        {TEXT(\"AlwaysOnTop\"), L10NIDX(input_actions_alwaysontop) }, \\\r\n        {TEXT(\"Borderless\"),  L10NIDX(input_actions_borderless) }, \\\r\n        {TEXT(\"Center\"),      L10NIDX(input_actions_center) }, \\\r\n        {TEXT(\"MaximizeHV\"),  L10NIDX(input_actions_maximizehv) }, \\\r\n        {TEXT(\"SideSnap\"),    L10NIDX(input_actions_sidesnap) }, \\\r\n        {TEXT(\"ExtendSnap\"),  L10NIDX(input_actions_extendsnap) }, \\\r\n        {TEXT(\"ExtendTNEdge\"),L10NIDX(input_actions_extendtnedge) }, \\\r\n        {TEXT(\"MoveTNEdge\"),  L10NIDX(input_actions_movetnedge) }, \\\r\n        {TEXT(\"MinAllOther\"), L10NIDX(input_actions_minallother) }, \\\r\n        {TEXT(\"Mute\"),        L10NIDX(input_actions_mute) }, \\\r\n        {TEXT(\"Menu\"),        L10NIDX(input_actions_menu) }, \\\r\n\r\n\r\n    static const struct actiondl mouse_actions[] = {\r\n        // Specific to the Primary/Alternate/Titlebar\r\n        // And not available for the MoveUp/ResizeUp\r\n        {TEXT(\"Move\"),        L10NIDX(input_actions_move) },\r\n        {TEXT(\"Resize\"),      L10NIDX(input_actions_resize) },\r\n        {TEXT(\"Restore\"),     L10NIDX(input_actions_restore) },\r\n        // Common mouse actions\r\n        COMMON_ACTIONS\r\n\r\n        {TEXT(\"Nothing\"),     L10NIDX(input_actions_nothing) },\r\n        {NULL, 0}\r\n    };\r\n\r\n    // Actions on MoveUp/ResizeUP\r\n    const struct actiondl *mouse_actionsUP = &mouse_actions[3];\r\n\r\n    // While moving/resizing\r\n    const struct actiondl *mouse_actionsWMR = &mouse_actions[3];\r\n\r\n//    static const struct actiondl mouse_actionsWMR[] = {\r\n//        // Spetial actions first\r\n//        {TEXT(\"ZoneSnapTogg\"), L10NIDX(input_actions_zonesnaptog) },\r\n//        {TEXT(\"SnapTogg\"),     L10NIDX(input_actions_snaptogg) },\r\n//        // Then the common mouse actions\r\n//        COMMON_ACTIONS\r\n//\r\n//        {TEXT(\"Nothing\"),     L10NIDX(input_actions_nothing) },\r\n//        {NULL, 0}\r\n//    };\r\n\r\n    // Scroll\r\n    static const struct {\r\n        int control; // Same control\r\n        TCHAR *option[5]; // Prim/alt/TTB/WM/WR\r\n    } mouse_wheels[] = {\r\n        { IDC_SCROLL,  {TEXT(\"Scroll\"),  TEXT(\"ScrollB\"),  TEXT(\"ScrollT\"), TEXT(\"ScrollM\"), TEXT(\"ScrollR\")}  },\r\n        { IDC_HSCROLL, {TEXT(\"HScroll\"), TEXT(\"HScrollB\"), TEXT(\"HScrollT\"), TEXT(\"HScrollM\"), TEXT(\"HScrollR\") } }\r\n    };\r\n\r\n    static const struct actiondl scroll_actions[] = {\r\n        {TEXT(\"AltTab\"),       L10NIDX(input_actions_alttab) },\r\n        {TEXT(\"Volume\"),       L10NIDX(input_actions_volume) },\r\n        {TEXT(\"Transparency\"), L10NIDX(input_actions_transparency) },\r\n        {TEXT(\"Zoom\"),         L10NIDX(input_actions_zoom) },\r\n        {TEXT(\"Zoom2\"),        L10NIDX(input_actions_zoom2) },\r\n        {TEXT(\"Lower\"),        L10NIDX(input_actions_lower) },\r\n        {TEXT(\"Roll\"),         L10NIDX(input_actions_roll) },\r\n        {TEXT(\"Maximize\"),     L10NIDX(input_actions_maximize) },\r\n        {TEXT(\"NPStacked\"),    L10NIDX(input_actions_npstacked) },\r\n        {TEXT(\"NPStacked2\"),   L10NIDX(input_actions_npstacked2) },\r\n        {TEXT(\"HScroll\"),      L10NIDX(input_actions_hscroll) },\r\n        {TEXT(\"Nothing\"),      L10NIDX(input_actions_nothing) },\r\n        {NULL, 0}\r\n    };\r\n\r\n    // Hotkeys\r\n    static const struct hk_struct hotclicks [] = {\r\n        { IDC_MMB_HC, 0x04 },\r\n        { IDC_MB4_HC, 0x05 },\r\n        { IDC_MB5_HC, 0X06 },\r\n        { 0, 0 }\r\n    };\r\n\r\n    static const struct optlst optlst[] = {\r\n        { IDC_TTBACTIONSNA,  T_BMK, 0, TEXT(\"Input\"), \"TTBActions\", 0    },\r\n        { IDC_TTBACTIONSWA,  T_BMK, 1, TEXT(\"Input\"), \"TTBActions\", 0    },\r\n        { IDC_LONGCLICKMOVE, T_BOL, 0, TEXT(\"Input\"), \"LongClickMove\", 0 }\r\n    };\r\n\r\n    LPNMHDR pnmh = (LPNMHDR) lParam;\r\n\r\n\r\n    if (msg == WM_INITDIALOG) {\r\n        // Hotclicks buttons\r\n        ReadDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n        CheckRadioButton(hwnd, IDC_MBA1, IDC_WHILER, IDC_MBA1); // Check the primary action\r\n        CheckConfigHotKeys(hotclicks, hwnd, TEXT(\"Hotclicks\"), TEXT(\"\"));\r\n    } else if (msg == WM_COMMAND) {\r\n        int event = HIWORD(wParam);\r\n        int id = LOWORD(wParam);\r\n        if (id >= IDC_MBA1 && id <= IDC_WHILER) {\r\n            CheckRadioButton(hwnd, IDC_MBA1, IDC_WHILER, id); // Check the selected action\r\n            goto FILLACTIONS;\r\n        }\r\n\r\n        if (event == 0 || event == CBN_SELCHANGE || event == CBN_EDITCHANGE){\r\n            PropSheet_Changed(g_cfgwnd, hwnd);\r\n            have_to_apply = 1;\r\n        }\r\n    } else if (msg == WM_NOTIFY) {\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            TCHAR txt[8];\r\n            GetPrivateProfileString(TEXT(\"Input\"), TEXT(\"ModKey\"), TEXT(\"\"), txt, ARR_SZ(txt), inipath);\r\n            EnableDlgItem(hwnd, IDC_MBA2, txt[0]);\r\n            // Disable inside ttb\r\n            EnableDlgItem(hwnd, IDC_INTTB, IsChecked(IDC_TTBACTIONSNA)||IsChecked(IDC_TTBACTIONSWA));\r\n\r\n            FILLACTIONS: {\r\n            unsigned i;\r\n            // Mouse actions\r\n            int optoff = IsChecked(IDC_MBA2)? 1\r\n                       : IsChecked(IDC_INTTB)? 2\r\n                       : IsChecked(IDC_WHILEM)? 3\r\n                       : IsChecked(IDC_WHILER)? 4: 0;\r\n\r\n            // We must disable MoveUp and ResizeUp for the\r\n            // While Moving/While resizing opts.\r\n            EnableDlgItem(hwnd, IDC_MOVEUP,   optoff < 3);\r\n            EnableDlgItem(hwnd, IDC_RESIZEUP, optoff < 3);\r\n            for (i = 0; i < ARR_SZ(mouse_buttons); i++) {\r\n                FillActionDropListS(hwnd, mouse_buttons[i].control, mouse_buttons[i].option[optoff], optoff<3?mouse_actions:mouse_actionsWMR);\r\n            }\r\n            if (optoff < 3) {\r\n                for (i = 0; i < ARR_SZ(mouse_buttonsUP); i++) {\r\n                    FillActionDropListS(hwnd, mouse_buttonsUP[i].control, mouse_buttonsUP[i].option[optoff], mouse_actionsUP);\r\n                }\r\n            }\r\n            // Scroll actions, always the same.\r\n            for (i = 0; i < ARR_SZ(mouse_wheels); i++) {\r\n                FillActionDropListS(hwnd, mouse_wheels[i].control, mouse_wheels[i].option[optoff], scroll_actions);\r\n            }\r\n\r\n            // Update text\r\n            static const struct dialogstring strlst[] = {\r\n                { IDC_MBA1,            L10NIDX(input_mouse_btac1 ) },\r\n                { IDC_MBA2,            L10NIDX(input_mouse_btac2 ) },\r\n                { IDC_INTTB,           L10NIDX(input_mouse_inttb ) },\r\n                { IDC_WHILEM,          L10NIDX(input_mouse_whilem ) },\r\n                { IDC_WHILER,          L10NIDX(input_mouse_whiler ) },\r\n\r\n                { IDC_MOUSE_BOX,       L10NIDX(input_mouse_box ) },\r\n                { IDC_LMB_HEADER,      L10NIDX(input_mouse_lmb ) },\r\n                { IDC_MMB_HEADER,      L10NIDX(input_mouse_mmb ) },\r\n                { IDC_RMB_HEADER,      L10NIDX(input_mouse_rmb ) },\r\n                { IDC_MB4_HEADER,      L10NIDX(input_mouse_mb4 ) },\r\n                { IDC_MB5_HEADER,      L10NIDX(input_mouse_mb5 ) },\r\n                { IDC_SCROLL_HEADER,   L10NIDX(input_mouse_scroll ) },\r\n                { IDC_HSCROLL_HEADER,  L10NIDX(input_mouse_hscroll ) },\r\n                { IDC_MOVEUP_HEADER,   L10NIDX(input_mouse_moveup ) },\r\n                { IDC_RESIZEUP_HEADER, L10NIDX(input_mouse_resizeup ) },\r\n                { IDC_TTBACTIONS_BOX,  L10NIDX(input_mouse_ttbactions_box ) },\r\n                { IDC_TTBACTIONSNA,    L10NIDX(input_mouse_ttbactionsna ) },\r\n                { IDC_TTBACTIONSWA,    L10NIDX(input_mouse_ttbactionswa ) },\r\n\r\n                { IDC_HOTCLICKS_BOX,   L10NIDX(input_hotclicks_box ) },\r\n                { IDC_HOTCLICKS_MORE,  L10NIDX(input_hotclicks_more ) },\r\n                { IDC_MMB_HC,          L10NIDX(input_mouse_mmb_hc ) },\r\n                { IDC_MB4_HC,          L10NIDX(input_mouse_mb4_hc ) },\r\n                { IDC_MB5_HC,          L10NIDX(input_mouse_mb5_hc ) },\r\n                { IDC_LONGCLICKMOVE,   L10NIDX(input_mouse_longclickmove ) },\r\n            };\r\n            UpdateDialogStrings(hwnd, strlst, ARR_SZ(strlst));\r\n            }\r\n\r\n        } else if (pnmh->code == PSN_APPLY && have_to_apply) {\r\n            // Mouse actions, for all mouse buttons...\r\n            unsigned i;\r\n            // Add 2 if in titlear add one for secondary action.\r\n            // Mouse actions\r\n            int optoff = IsChecked(IDC_MBA2)? 1\r\n                       : IsChecked(IDC_INTTB)? 2\r\n                       : IsChecked(IDC_WHILEM)? 3\r\n                       : IsChecked(IDC_WHILER)? 4: 0;\r\n            for (i = 0; i < ARR_SZ(mouse_buttons); i++) {\r\n                WriteActionDropListS(hwnd, mouse_buttons[i].control , mouse_buttons[i].option[optoff]\r\n                                   , optoff<3? mouse_actions: mouse_actionsWMR);\r\n            }\r\n            if (optoff < 3) {\r\n                for (i = 0; i < ARR_SZ(mouse_buttonsUP); i++) {\r\n                    WriteActionDropListS(hwnd, mouse_buttonsUP[i].control, mouse_buttonsUP[i].option[optoff], mouse_actionsUP);\r\n                }\r\n            }\r\n            // Scroll\r\n            for (i = 0; i < ARR_SZ(mouse_wheels); i++) {\r\n                WriteActionDropListS(hwnd, mouse_wheels[i].control, mouse_wheels[i].option[optoff], scroll_actions);\r\n            }\r\n\r\n            // Checkboxes...\r\n            WriteDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n            // Hotclicks\r\n            SaveHotKeys(hotclicks, hwnd, TEXT(\"Hotclicks\"));\r\n            UpdateSettings();\r\n            have_to_apply = 0;\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\nstatic BOOL CALLBACK EnableAllControlsProc(HWND hwnd, LPARAM lp)\r\n{\r\n    if (IsWindowVisible(hwnd)) {\r\n        EnableWindow(hwnd, lp);\r\n    }\r\n    return TRUE;\r\n}\r\nstatic LRESULT WINAPI PickShortcutWinProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n    static const UCHAR vkbl[] = {\r\n        VK_CONTROL, VK_LCONTROL, VK_RCONTROL,\r\n        VK_SHIFT, VK_LSHIFT, VK_RSHIFT,\r\n        VK_MENU, VK_LMENU, VK_RMENU,\r\n        VK_LWIN, VK_RWIN\r\n        , '\\0'\r\n    };\r\n//    static int was_enabled;\r\n\r\n    switch (msg) {\r\n//    case WM_CREATE: {\r\n//        was_enabled = ENABLED();\r\n//        if (was_enabled) UnhookSystem();\r\n//    } break;\r\n    case WM_CHAR:\r\n    case WM_SYSKEYDOWN:\r\n    case WM_SYSKEYUP:\r\n    case WM_SYSDEADCHAR:\r\n    case WM_SYSCHAR:\r\n        break;\r\n    case WM_KEYUP: {\r\n        if (!IsHotkeyy((UCHAR)wp, vkbl)) {\r\n            TCHAR txt[LPTR_HDIGITS+1];\r\n            HWND phwnd = GetParent(hwnd);\r\n            SetDlgItemText(phwnd, IDC_SHORTCUTS_VK, LPTR2Hex(txt, wp));\r\n\r\n            CheckDlgButton(phwnd, IDC_SHIFT,  GetKeyState(VK_SHIFT)&0x8000? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(phwnd, IDC_CONTROL,GetKeyState(VK_CONTROL)&0x8000? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(phwnd, IDC_WINKEY, GetKeyState(VK_LWIN)&0x8000||GetKeyState(VK_RWIN)&0x8000? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(phwnd, IDC_ALT,    GetKeyState(VK_MENU)&0x8000? BST_CHECKED: BST_UNCHECKED);\r\n            DestroyWindow(hwnd);\r\n        }\r\n    } break;\r\n    case WM_LBUTTONDOWN:\r\n    case WM_KILLFOCUS: {\r\n        DestroyWindow(hwnd);\r\n    } break;\r\n\r\n    case WM_DESTROY: {\r\n        HWND phwnd = GetParent(hwnd);\r\n        EnableDlgItem(phwnd, IDC_SHORTCUTS_PICK, 1);\r\n        EnumChildWindows(phwnd, EnableAllControlsProc, 1);\r\n        NMHDR lpn;\r\n        lpn.hwndFrom = NULL; lpn.code = PSN_SETACTIVE;\r\n        SendMessage(phwnd, WM_NOTIFY, 0, (LPARAM)&lpn);\r\n        HWND sethwnd = GetDlgItem(phwnd, IDC_SHORTCUTS_SET);\r\n        EnableWindow(sethwnd, TRUE);\r\n        SetFocus(sethwnd);\r\n//        if (was_enabled) HookSystem();\r\n    } break;\r\n    default:\r\n        return DefWindowProc(hwnd, msg, wp, lp);\r\n    }\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK KeyboardPageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    static int have_to_apply = 0;\r\n    static int edit_shortcut_idx = 0;\r\n    // Hotkeys\r\n    static const struct hk_struct hotkeys[] = {\r\n        { IDC_LEFTALT,     VK_LMENU    },\r\n        { IDC_RIGHTALT,    VK_RMENU    },\r\n        { IDC_LEFTWINKEY,  VK_LWIN     },\r\n        { IDC_RIGHTWINKEY, VK_RWIN     },\r\n        { IDC_LEFTCTRL,    VK_LCONTROL },\r\n        { IDC_RIGHTCTRL,   VK_RCONTROL },\r\n        { 0, 0 }\r\n    };\r\n    static const struct actiondl kb_actions[] = {\r\n        {TEXT(\"Move\"),        L10NIDX(input_actions_move) },\r\n        {TEXT(\"Resize\"),      L10NIDX(input_actions_resize) },\r\n        {TEXT(\"Close\"),       L10NIDX(input_actions_close) },\r\n        {TEXT(\"Minimize\"),    L10NIDX(input_actions_minimize) },\r\n        {TEXT(\"Maximize\"),    L10NIDX(input_actions_maximize) },\r\n        {TEXT(\"Lower\"),       L10NIDX(input_actions_lower) },\r\n        {TEXT(\"Roll\"),        L10NIDX(input_actions_roll) },\r\n        {TEXT(\"AlwaysOnTop\"), L10NIDX(input_actions_alwaysontop) },\r\n        {TEXT(\"Borderless\"),  L10NIDX(input_actions_borderless) },\r\n        {TEXT(\"Center\"),      L10NIDX(input_actions_center) },\r\n        {TEXT(\"MaximizeHV\"),  L10NIDX(input_actions_maximizehv) },\r\n        {TEXT(\"MinAllOther\"), L10NIDX(input_actions_minallother) },\r\n        {TEXT(\"Menu\"),        L10NIDX(input_actions_menu) },\r\n        {TEXT(\"Nothing\"),     L10NIDX(input_actions_nothing) },\r\n        {NULL, 0}\r\n    };\r\n    static const struct actiondl kbshortcut_actions[] = {\r\n        {TEXT(\"Kill\"),        L10NIDX(input_actions_kill) },\r\n        {TEXT(\"Pause\"),       L10NIDX(input_actions_pause) },\r\n        {TEXT(\"Resume\"),      L10NIDX(input_actions_resume) },\r\n        {TEXT(\"ASOnOff\"),     L10NIDX(input_actions_asonoff) },\r\n        {TEXT(\"Lower\"),       L10NIDX(input_actions_lower) },\r\n        {TEXT(\"Roll\"),        L10NIDX(input_actions_roll) },\r\n        {TEXT(\"AlwaysOnTop\"), L10NIDX(input_actions_alwaysontop) },\r\n        {TEXT(\"Borderless\"),  L10NIDX(input_actions_borderless) },\r\n        {TEXT(\"Center\"),      L10NIDX(input_actions_center) },\r\n        {TEXT(\"Mute\"),        L10NIDX(input_actions_mute) },\r\n        {TEXT(\"Menu\"),        L10NIDX(input_actions_menu) },\r\n\r\n        {TEXT(\"NStacked\"),    L10NIDX(input_actions_nstacked) },\r\n        {TEXT(\"NStacked2\"),   L10NIDX(input_actions_nstacked2) },\r\n        {TEXT(\"PStacked\"),    L10NIDX(input_actions_pstacked) },\r\n        {TEXT(\"PStacked2\"),   L10NIDX(input_actions_pstacked2) },\r\n        {TEXT(\"StackList\"),   L10NIDX(input_actions_stacklist) },\r\n        {TEXT(\"StackList2\"),  L10NIDX(input_actions_stacklist2) },\r\n        {TEXT(\"AltTabList\"),  L10NIDX(input_actions_alttablist) },\r\n        {TEXT(\"AltTabFullList\"),L10NIDX(input_actions_alttabfulllist) },\r\n\r\n        {TEXT(\"ExtendTNEdge\"),L10NIDX(input_actions_extendtnedge) },\r\n        {TEXT(\"XTNLEdge\"),    L10NIDX(input_actions_xtnledge) },\r\n        {TEXT(\"XTNTEdge\"),    L10NIDX(input_actions_xtntedge) },\r\n        {TEXT(\"XTNREdge\"),    L10NIDX(input_actions_xtnredge) },\r\n        {TEXT(\"XTNBEdge\"),    L10NIDX(input_actions_xtnbedge) },\r\n        {TEXT(\"MoveTNEdge\"),  L10NIDX(input_actions_movetnedge) },\r\n        {TEXT(\"MTNLEdge\"),    L10NIDX(input_actions_mtnledge) },\r\n        {TEXT(\"MTNTEdge\"),    L10NIDX(input_actions_mtntedge) },\r\n        {TEXT(\"MTNREdge\"),    L10NIDX(input_actions_mtnredge) },\r\n        {TEXT(\"MTNBEdge\"),    L10NIDX(input_actions_mtnbedge) },\r\n\r\n        {TEXT(\"MLZone\"),      L10NIDX(input_actions_mlzone) },\r\n        {TEXT(\"MTZone\"),      L10NIDX(input_actions_mtzone) },\r\n        {TEXT(\"MRZone\"),      L10NIDX(input_actions_mrzone) },\r\n        {TEXT(\"MBZone\"),      L10NIDX(input_actions_mbzone) },\r\n        {TEXT(\"XLZone\"),      L10NIDX(input_actions_xlzone) },\r\n        {TEXT(\"XTZone\"),      L10NIDX(input_actions_xtzone) },\r\n        {TEXT(\"XRZone\"),      L10NIDX(input_actions_xrzone) },\r\n        {TEXT(\"XBZone\"),      L10NIDX(input_actions_xbzone) },\r\n\r\n        {TEXT(\"StepL\"),       L10NIDX(input_actions_stepl) },\r\n        {TEXT(\"StepT\"),       L10NIDX(input_actions_stept) },\r\n        {TEXT(\"StepR\"),       L10NIDX(input_actions_stepr) },\r\n        {TEXT(\"StepB\"),       L10NIDX(input_actions_stepb) },\r\n        {TEXT(\"SStepL\"),      L10NIDX(input_actions_sstepl) },\r\n        {TEXT(\"SStepT\"),      L10NIDX(input_actions_sstept) },\r\n        {TEXT(\"SStepR\"),      L10NIDX(input_actions_sstepr) },\r\n        {TEXT(\"SStepB\"),      L10NIDX(input_actions_sstepb) },\r\n\r\n        {TEXT(\"FocusL\"),       L10NIDX(input_actions_focusl) },\r\n        {TEXT(\"FocusT\"),       L10NIDX(input_actions_focust) },\r\n        {TEXT(\"FocusR\"),       L10NIDX(input_actions_focusr) },\r\n        {TEXT(\"FocusB\"),       L10NIDX(input_actions_focusb) },\r\n        {NULL, 0}\r\n    };\r\n\r\n    // Hotkeys\r\n    static const struct actiondl togglekeys[] = {\r\n        {TEXT(\"\"),      L10NIDX(input_actions_nothing)},\r\n        {TEXT(\"A4 A5\"), L10NIDX(input_hotkeys_alt)},\r\n        {TEXT(\"5B 5C\"), L10NIDX(input_hotkeys_winkey)},\r\n        {TEXT(\"A2 A3\"), L10NIDX(input_hotkeys_ctrl)},\r\n        {TEXT(\"A0 A1\"), L10NIDX(input_hotkeys_shift)},\r\n        {TEXT(\"A4\"),    L10NIDX(input_hotkeys_leftalt)},\r\n        {TEXT(\"A5\"),    L10NIDX(input_hotkeys_rightalt)},\r\n        {TEXT(\"5B\"),    L10NIDX(input_hotkeys_leftwinkey)},\r\n        {TEXT(\"5C\"),    L10NIDX(input_hotkeys_rightwinkey)},\r\n        {TEXT(\"A2\"),    L10NIDX(input_hotkeys_leftctrl)},\r\n        {TEXT(\"A3\"),    L10NIDX(input_hotkeys_rightctrl)},\r\n        {TEXT(\"A0\"),    L10NIDX(input_hotkeys_leftshift)},\r\n        {TEXT(\"A1\"),    L10NIDX(input_hotkeys_rightshift)},\r\n        {NULL, 0},\r\n    };\r\n    static const struct optlst optlst[] = {\r\n        { IDC_SCROLLLOCKSTATE,  T_BMK, 0, TEXT(\"Input\"), \"ScrollLockState\", 0},\r\n        { IDC_UNIKEYHOLDMENU,   T_BOL, 0, TEXT(\"Input\"), \"UniKeyHoldMenu\", 0},\r\n        { IDC_KEYCOMBO,         T_BOL, 0, TEXT(\"Input\"), \"KeyCombo\", 0 },\r\n        { IDC_USEPTWINDOW,      T_BOL, 0, TEXT(\"KBShortcuts\"), \"UsePtWindow\", 0},\r\n    };\r\n\r\n    LPNMHDR pnmh = (LPNMHDR) lParam;\r\n\r\n    if (msg == WM_INITDIALOG) {\r\n        edit_shortcut_idx = 0;\r\n        ReadDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n        // Agressive Pause\r\n        CheckConfigHotKeys(hotkeys, hwnd, TEXT(\"Hotkeys\"), TEXT(\"A4 A5\"));\r\n\r\n      # ifndef WIN64\r\n        // Always enabled in 64 bit mode.\r\n        EnableDlgItem(hwnd, IDC_AGGRESSIVEPAUSE, HaveProc(\"NTDLL.DLL\", \"NtResumeProcess\"));\r\n        EnableDlgItem(hwnd, IDC_UNIKEYHOLDMENU, WIN2K);\r\n      # endif\r\n\r\n    } else if (msg == WM_COMMAND) {\r\n        int event = HIWORD(wParam);\r\n        int id = LOWORD(wParam);\r\n        if (id == IDC_ALT ||  id == IDC_WINKEY || id == IDC_CONTROL || id == IDC_SHIFT) {\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 1);\r\n        } else if (event == EN_UPDATE && id == IDC_SHORTCUTS_VK) {\r\n            TCHAR txt[4];\r\n            GetDlgItemText(hwnd, IDC_SHORTCUTS_VK, txt, 3);\r\n            BYTE vKey = lstrhex2u(txt);\r\n            TCHAR keyname[32]; keyname[0] = L'\\0';\r\n            GetKeyNameText(MapVirtualKey(vKey, 0)<<16, keyname, ARR_SZ(keyname)-8);\r\n            SetDlgItemText(hwnd, IDC_SHORTCUTS, keyname);\r\n\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 1);\r\n        } else if (event == CBN_EDITCHANGE\r\n            || ((event == 0 || event == EN_UPDATE || event == CBN_SELCHANGE)\r\n               && (IDC_SHORTCUTS > id || id > IDC_SHORTCUTS_CLEAR))) {\r\n            PropSheet_Changed(g_cfgwnd, hwnd);\r\n            have_to_apply = 1;\r\n        }\r\n\r\n        // KEYBOARD SHORTCUTS HANDLING\r\n        // READ Keyboard Shortcut\r\n        if (id == IDC_SHORTCUTS_AC && event == CBN_SELCHANGE) {\r\n            // Update the shortcut with the current one.\r\n            int i = CB_GetCurSelId(IDC_SHORTCUTS_AC);\r\n            edit_shortcut_idx = i;\r\n            WORD shortcut= GetPrivateProfileInt(TEXT(\"KBShortcuts\"), kbshortcut_actions[i].action, 0, inipath);\r\n            BYTE vKey = LOBYTE(shortcut);\r\n            BYTE mod = HIBYTE(shortcut);\r\n            TCHAR txt[LPTR_HDIGITS+1];\r\n            SetDlgItemText(hwnd, IDC_SHORTCUTS_VK, LPTR2Hex(txt, vKey));\r\n\r\n            CheckDlgButton(hwnd, IDC_CONTROL,(mod&MOD_CONTROL)? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_SHIFT,  (mod&MOD_SHIFT)? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_WINKEY, (mod&MOD_WIN)? BST_CHECKED: BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_ALT,    (mod&MOD_ALT)? BST_CHECKED: BST_UNCHECKED);\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 0);\r\n        }\r\n        // WRITE Current Keyboard Shortcut\r\n        if (id == IDC_SHORTCUTS_SET) {\r\n            TCHAR txt[UINT_DIGITS+1];\r\n            // MOD_ALT=1, MOD_CONTROL=2, MOD_SHIFT=4, MOD_WIN=8\r\n            GetDlgItemText(hwnd, IDC_SHORTCUTS_VK, txt, 3);\r\n            BYTE vKey = lstrhex2u(txt);\r\n            BYTE mod =  IsChecked(IDC_ALT)\r\n                     | (IsChecked(IDC_CONTROL)<<1)\r\n                     | (IsChecked(IDC_SHIFT)<<2)\r\n                     | (IsChecked(IDC_WINKEY)<<3);\r\n            WORD shortcut = vKey | (mod << 8);\r\n            int i = CB_GetCurSelId(IDC_SHORTCUTS_AC);\r\n            if (kbshortcut_actions[i].action && kbshortcut_actions[i].action[0] != '\\0')\r\n                WritePrivateProfileString(TEXT(\"KBShortcuts\"), kbshortcut_actions[i].action, Uint2lStr(txt, shortcut), inipath);\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 0);\r\n            SetFocus(GetDlgItem(hwnd, IDC_SHORTCUTS_AC));\r\n            goto APPLY_ALL;\r\n        }\r\n        if (id == IDC_SHORTCUTS_PICK) {\r\n            HWND pickhwnd;\r\n            WNDCLASSEX wnd;\r\n            if (!GetClassInfoEx(g_hinst, TEXT(APP_NAMEA)TEXT(\"-PickShortcut\"), &wnd)) {\r\n                WNDCLASSEX wndd = {\r\n                    sizeof(WNDCLASSEX)\r\n                  , CS_PARENTDC\r\n                  , PickShortcutWinProc\r\n                  , 0, 0, g_hinst\r\n                  , NULL //LoadIcon(g_hinst, iconstr[1])\r\n                  , NULL //LoadCursor(NULL, IDC_ARROW)\r\n                  , NULL //(HBRUSH)(COLOR_HIGHLIGHT+1)\r\n                  , NULL, TEXT(APP_NAMEA)TEXT(\"-PickShortcut\"), NULL\r\n                };\r\n                RegisterClassEx(&wndd);\r\n            }\r\n            RECT rc;\r\n            GetClientRect(hwnd, &rc);\r\n            pickhwnd = CreateWindowEx(WS_EX_TOPMOST\r\n                 , TEXT(APP_NAMEA)TEXT(\"-PickShortcut\"), NULL\r\n                 , WS_CHILD|WS_VISIBLE\r\n                 , rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top\r\n                 , hwnd , NULL, g_hinst, NULL);\r\n            // Disable all other child windows\r\n            EnumChildWindows(hwnd, EnableAllControlsProc, 0);\r\n            EnableWindow(pickhwnd, TRUE);\r\n            SetFocus(pickhwnd);\r\n            SetActiveWindow(pickhwnd);\r\n            // SetDlgItemText(hwnd, IDC_SHORTCUTS, TEXT(\"Press Keys...\"));\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_PICK, 0);\r\n        }\r\n        if (id == IDC_SHORTCUTS_CLEAR) {\r\n            // We must clear the current shotrcut\r\n            CheckDlgButton(hwnd, IDC_SHIFT, BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_CONTROL, BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_WINKEY,BST_UNCHECKED);\r\n            CheckDlgButton(hwnd, IDC_ALT,   BST_UNCHECKED);\r\n            SetDlgItemText(hwnd, IDC_SHORTCUTS_VK, TEXT(\"\"));\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 1);\r\n        }\r\n\r\n    } else if (msg == WM_NOTIFY) {\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            // GrabWithAlt\r\n            TCHAR txt[64];\r\n\r\n            GetPrivateProfileString(TEXT(\"Input\"), TEXT(\"ModKey\"), TEXT(\"\"), txt, ARR_SZ(txt), inipath);\r\n            EnableDlgItem(hwnd, IDC_GRABWITHALTB_H, txt[0]);\r\n            EnableDlgItem(hwnd, IDC_GRABWITHALTB,   txt[0]);\r\n\r\n            FillActionDropListS(hwnd, IDC_GRABWITHALT, TEXT(\"GrabWithAlt\"), kb_actions);\r\n            FillActionDropListS(hwnd, IDC_GRABWITHALTB, TEXT(\"GrabWithAltB\"), kb_actions);\r\n            FillActionDropListS(hwnd, IDC_SHORTCUTS_AC, NULL, kbshortcut_actions);\r\n            CB_SetCurSel(GetDlgItem(hwnd, IDC_SHORTCUTS_AC), edit_shortcut_idx);\r\n            EnableDlgItem(hwnd, IDC_SHORTCUTS_SET, 0);\r\n            if(pnmh->hwndFrom != NULL)PostMessage(hwnd, WM_COMMAND, IDC_SHORTCUTS_AC|CBN_SELCHANGE<<16, 0);\r\n\r\n            // ModKey init\r\n            HWND control = GetDlgItem(hwnd, IDC_MODKEY);\r\n            CB_ResetContent(control);\r\n            unsigned j, sel = 0;\r\n            for (j = 0; j < ARR_SZ(togglekeys)-1; j++) {\r\n                TCHAR key_name[256];\r\n                lstrcpy_noaccel(key_name, L10NSTR(togglekeys[j].l10nidx), ARR_SZ(key_name));\r\n                CB_AddString(control, key_name);\r\n                if (!lstrcmp(txt, togglekeys[j].action)) {\r\n                    sel = j;\r\n                }\r\n            }\r\n            // Add the current ModKey string to the list if not found!\r\n            if (sel == 0 && txt[0]) {\r\n                CB_AddString(control, &txt[0]);\r\n                sel = ARR_SZ(togglekeys)-1;\r\n            }\r\n            CB_SetCurSel(control, sel); // select current ModKey\r\n\r\n            // Update text\r\n            static const struct dialogstring strlst[] = {\r\n                { IDC_KEYBOARD_BOX,    L10NIDX(tab_keyboard) },\r\n                { IDC_SCROLLLOCKSTATE, L10NIDX(input_scrolllockstate) },\r\n                { IDC_UNIKEYHOLDMENU,  L10NIDX(input_unikeyholdmenu) },\r\n                { IDC_HOTKEYS_BOX,     L10NIDX(input_hotkeys_box) },\r\n                { IDC_MODKEY_H,        L10NIDX(input_hotkeys_modkey) },\r\n\r\n                { IDC_ALT,             L10NIDX(input_hotkeys_alt) },\r\n                { IDC_SHIFT,           L10NIDX(input_hotkeys_shift) },\r\n                { IDC_CONTROL,         L10NIDX(input_hotkeys_ctrl) },\r\n                { IDC_WINKEY,          L10NIDX(input_hotkeys_winkey) },\r\n                { IDC_SHORTCUTS_H,     L10NIDX(input_hotkeys_shortcuts) },\r\n                { IDC_SHORTCUTS_PICK,  L10NIDX(input_hotkeys_shortcutspick) },\r\n                { IDC_SHORTCUTS_CLEAR, L10NIDX(input_hotkeys_shortcutsclear) },\r\n                { IDC_SHORTCUTS_SET,   L10NIDX(input_hotkeys_shortcutset) },\r\n                { IDC_USEPTWINDOW,     L10NIDX(input_hotkeys_useptwindow) },\r\n                { IDC_LEFTALT,         L10NIDX(input_hotkeys_leftalt) },\r\n                { IDC_RIGHTALT,        L10NIDX(input_hotkeys_rightalt) },\r\n                { IDC_LEFTWINKEY,      L10NIDX(input_hotkeys_leftwinkey) },\r\n                { IDC_RIGHTWINKEY,     L10NIDX(input_hotkeys_rightwinkey) },\r\n                { IDC_LEFTCTRL,        L10NIDX(input_hotkeys_leftctrl) },\r\n                { IDC_RIGHTCTRL,       L10NIDX(input_hotkeys_rightctrl) },\r\n                { IDC_HOTKEYS_MORE,    L10NIDX(input_hotkeys_more) },\r\n                { IDC_KEYCOMBO,        L10NIDX(input_keycombo) },\r\n                { IDC_GRABWITHALT_H,   L10NIDX(input_grabwithalt) },\r\n                { IDC_GRABWITHALTB_H,  L10NIDX(input_grabwithaltb) }\r\n            };\r\n            UpdateDialogStrings(hwnd, strlst, ARR_SZ(strlst));\r\n\r\n        } else if (pnmh->code == PSN_APPLY && have_to_apply ) {\r\n            APPLY_ALL:;\r\n//            int i;\r\n            // Action without click\r\n            WriteActionDropListS(hwnd, IDC_GRABWITHALT, TEXT(\"GrabWithAlt\"), kb_actions);\r\n            WriteActionDropListS(hwnd, IDC_GRABWITHALTB, TEXT(\"GrabWithAltB\"), kb_actions);\r\n\r\n            WriteDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n            ScrollLockState = WriteOptionBoolB(IDC_SCROLLLOCKSTATE, TEXT(\"Input\"), \"ScrollLockState\", 0);\r\n            // Modifier key (similar to action list)\r\n            WriteActionDropListS(hwnd, IDC_MODKEY, TEXT(\"ModKey\"), togglekeys);\r\n            // Hotkeys\r\n            SaveHotKeys(hotkeys, hwnd, TEXT(\"Hotkeys\"));\r\n            WriteOptionBool(IDC_KEYCOMBO,  TEXT(\"Input\"), \"KeyCombo\");\r\n            UpdateSettings();\r\n            have_to_apply = 0;\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK BlacklistPageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    #pragma GCC diagnostic ignored \"-Wint-conversion\"\r\n    static const struct optlst optlst[] = {\r\n        { IDC_PROCESSBLACKLIST, T_STR, 0, TEXT(\"Blacklist\"), \"Processes\", TEXT(\"\") },\r\n        { IDC_BLACKLIST,        T_STR, 0, TEXT(\"Blacklist\"), \"Windows\", TEXT(\"\") },\r\n        { IDC_SCROLLLIST,       T_STR, 0, TEXT(\"Blacklist\"), \"Scroll\", TEXT(\"\") },\r\n        { IDC_MDIS,             T_STR, 0, TEXT(\"Blacklist\"), \"MDIs\", TEXT(\"\") },\r\n        { IDC_PAUSEBL,          T_STR, 0, TEXT(\"Blacklist\"), \"Pause\", TEXT(\"\") },\r\n    };\r\n    #pragma GCC diagnostic pop\r\n\r\n    static int have_to_apply = 0;\r\n\r\n    if (msg == WM_INITDIALOG) {\r\n        ReadDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n        BOOL haveProcessBL = HaveProc(\"PSAPI.DLL\", \"GetModuleFileNameExW\");\r\n        EnableDlgItem(hwnd, IDC_PROCESSBLACKLIST, haveProcessBL);\r\n        EnableDlgItem(hwnd, IDC_PAUSEBL, haveProcessBL);\r\n    } else if (msg == WM_COMMAND) {\r\n        int id = LOWORD(wParam);\r\n        int event = HIWORD(wParam);\r\n        if (event == EN_UPDATE\r\n        && id != IDC_NEWRULE && id != IDC_NEWPROGNAME\r\n        && id != IDC_DWMCAPBUTTON && id != IDC_GWLEXSTYLE\r\n        && id != IDC_NCHITTEST && id != IDC_GWLSTYLE && id != IDC_RECT) {\r\n            PropSheet_Changed(g_cfgwnd, hwnd); // Enable the Apply Button\r\n            have_to_apply = 1;\r\n        } else if (event == STN_CLICKED && id == IDC_FINDWINDOW) {\r\n            // Get size of workspace\r\n            int left=0, top=0, width, height;\r\n            if(GetSystemMetrics(SM_CMONITORS) >= 1) {\r\n                left   = GetSystemMetrics(SM_XVIRTUALSCREEN);\r\n                top    = GetSystemMetrics(SM_YVIRTUALSCREEN);\r\n                width  = GetSystemMetrics(SM_CXVIRTUALSCREEN);\r\n                height = GetSystemMetrics(SM_CYVIRTUALSCREEN);\r\n             } else { // NT4...\r\n                 width = GetSystemMetrics(SM_CXFULLSCREEN)+32;\r\n                 height= GetSystemMetrics(SM_CYFULLSCREEN)+256;\r\n             }\r\n\r\n            // Create Transparent window covering the whole workspace\r\n            WNDCLASSEX wnd = { sizeof(WNDCLASSEX), 0, FindWindowProc, 0, 0, g_hinst, NULL, NULL\r\n                             , (HBRUSH) (COLOR_WINDOW + 1), NULL, TEXT(APP_NAMEA)TEXT(\"-find\"), NULL };\r\n            wnd.hCursor = LoadCursor(g_hinst, MAKEINTRESOURCE(IDI_FIND));\r\n            RegisterClassEx(&wnd);\r\n            HWND findhwnd = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_TRANSPARENT\r\n                           , wnd.lpszClassName, NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hinst, NULL);\r\n            ShowWindow(findhwnd, SW_SHOWNA); // And show it\r\n            MoveWindow(findhwnd, left, top, width, height, FALSE);\r\n\r\n            // Hide icon\r\n            ShowWindowAsync(GetDlgItem(hwnd, IDC_FINDWINDOW), SW_HIDE);\r\n        }\r\n\r\n    } else if (msg == WM_NOTIFY) {\r\n        LPNMHDR pnmh = (LPNMHDR) lParam;\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            // Update text\r\n            static const struct dialogstring strlst[] = {\r\n                { IDC_BLACKLIST_BOX          , L10NIDX(blacklist_box ) },\r\n                { IDC_PROCESSBLACKLIST_HEADER, L10NIDX(blacklist_processblacklist ) },\r\n                { IDC_BLACKLIST_HEADER       , L10NIDX(blacklist_blacklist ) },\r\n                { IDC_SCROLLLIST_HEADER      , L10NIDX(blacklist_scrolllist ) },\r\n                { IDC_MDISBL_HEADER          , L10NIDX(blacklist_mdis ) },\r\n                { IDC_PAUSEBL_HEADER         , L10NIDX(blacklist_pause ) },\r\n                { IDC_FINDWINDOW_BOX         , L10NIDX(blacklist_findwindow_box ) }\r\n            };\r\n            UpdateDialogStrings(hwnd, strlst, ARR_SZ(strlst));\r\n            // Enable or disable buttons if needed\r\n            EnableDlgItem(hwnd, IDC_MDIS, GetPrivateProfileInt(TEXT(\"General\"), TEXT(\"MDI\"), 1, inipath));\r\n            EnableDlgItem(hwnd, IDC_PAUSEBL\r\n                  ,  GetPrivateProfileInt(TEXT(\"KBShortcuts\"), TEXT(\"Kill\"), 0, inipath)\r\n                  || GetPrivateProfileInt(TEXT(\"Advanced\"), TEXT(\"ACMenuItems\"), -1, inipath)&8192);\r\n        } else if (pnmh->code == PSN_APPLY && have_to_apply) {\r\n            // Save to the config\r\n            WriteDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n            UpdateSettings();\r\n            have_to_apply = 0;\r\n        }\r\n    }\r\n\r\n    return FALSE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nLRESULT CALLBACK FindWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (msg == WM_LBUTTONUP || msg == WM_MBUTTONUP || msg == WM_RBUTTONUP) {\r\n        DWORD msgpos = GetMessagePos();\r\n        POINT pt = { GET_X_LPARAM(msgpos), GET_Y_LPARAM(msgpos) };\r\n        RECT fwRc;\r\n        HWND page = PropSheet_GetCurrentPageHwnd(g_cfgwnd);\r\n        HWND findHwnd = GetDlgItem(page, IDC_FINDWINDOW);\r\n        GetWindowRect(findHwnd, &fwRc);\r\n        if (PtInRect(&fwRc, pt))\r\n            return 0;\r\n\r\n       ShowWindow(hwnd, SW_HIDE);\r\n       if (msg == WM_LBUTTONUP) {\r\n//            POINT pt;\r\n//            GetCursorPos(&pt);\r\n            HWND nwindow = WindowFromPoint(pt);\r\n            HWND window = GetAncestor(nwindow, GA_ROOT);\r\n\r\n            TCHAR title[256], classname[256];\r\n            GetWindowText(window, title, ARR_SZ(title));\r\n            GetClassName(window, classname, ARR_SZ(classname));\r\n\r\n            TCHAR txt[512];\r\n            txt[0] = '\\0';\r\n            lstrcat_s(txt, ARR_SZ(txt), title);\r\n            lstrcat_s(txt, ARR_SZ(txt), TEXT(\"|\"));\r\n            lstrcat_s(txt, ARR_SZ(txt), classname);\r\n            SetDlgItemText(page, IDC_NEWRULE, txt);\r\n\r\n            if (GetWindowProgName(window, txt, ARR_SZ(txt))) {\r\n                SetDlgItemText(page, IDC_NEWPROGNAME, txt);\r\n            }\r\n            SetDlgItemText(page, IDC_GWLSTYLE, LPTR2Hex(txt, GetWindowLongPtr(window, GWL_STYLE)));\r\n            SetDlgItemText(page, IDC_GWLEXSTYLE, LPTR2Hex(txt, GetWindowLongPtr(window, GWL_EXSTYLE)));\r\n            // WM_NCHITTEST messages info at current pt\r\n            TCHAR tt[32];\r\n            lstrcpy_s(txt, ARR_SZ(txt), Int2lStr(tt, HitTestTimeout(nwindow, pt.x, pt.y)) );\r\n            lstrcat_s(txt, ARR_SZ(txt), TEXT(\"/\"));\r\n            lstrcat_s(txt, ARR_SZ(txt), Int2lStr(tt, HitTestTimeout(window, pt.x, pt.y)) );\r\n            SetDlgItemText(page, IDC_NCHITTEST, txt);\r\n            // IDC_DWMCAPBUTTON\r\n            RECT rc;\r\n            SetDlgItemText(page, IDC_DWMCAPBUTTON\r\n                , (GetCaptionButtonsRect(window, &rc) && PtInRect(&rc, pt))?TEXT(\"Yes\"):TEXT(\"No\"));\r\n\r\n            // Window rectangle info\r\n            if (GetWindowRectL(window, &rc)) {\r\n                SetDlgItemText(page, IDC_RECT, RectToStr(&rc, txt));\r\n            }\r\n            // IDC_WINHANDLES\r\n            lstrcpy_s( txt, ARR_SZ(txt), TEXT(\"Hwnd: \") );\r\n            lstrcat_s( txt, ARR_SZ(txt), LPTR2Hex(tt, (ULONG_PTR)nwindow) );\r\n            lstrcat_s( txt, ARR_SZ(txt), TEXT(\", Root: \") );\r\n            lstrcat_s( txt, ARR_SZ(txt), LPTR2Hex(tt, (ULONG_PTR)window) );\r\n            lstrcat_s( txt, ARR_SZ(txt), TEXT(\", Owner: \") );\r\n            lstrcat_s( txt, ARR_SZ(txt), LPTR2Hex(tt, (ULONG_PTR)GetWindow(window, GW_OWNER)) );\r\n            SetDlgItemText(page, IDC_WINHANDLES, txt);\r\n        }\r\n        // Show icon again\r\n        ShowWindowAsync(findHwnd, SW_SHOW);\r\n\r\n        DestroyWindow(hwnd);\r\n        UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-find\"), g_hinst);\r\n        return 0;\r\n    } else if (wParam && msg ==  WM_ERASEBKGND) {\r\n        return 1;\r\n    } else if (wParam && msg == WM_PAINT) {\r\n        return 0;\r\n    }\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK AboutPageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (msg == WM_INITDIALOG) {\r\n        MoveToCorner(g_cfgwnd);\r\n    } else if (msg == WM_NOTIFY) {\r\n        LPNMHDR pnmh = (LPNMHDR) lParam;\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            // Update text\r\n            SetDlgItemText(hwnd, IDC_ABOUT_BOX,        l10n->about_box);\r\n            SetDlgItemText(hwnd, IDC_VERSION,          l10n->about_version);\r\n            SetDlgItemText(hwnd, IDC_URL,              TEXT(\"https://github.com/RamonUnch/AltSnap\"));\r\n            SetDlgItemText(hwnd, IDC_AUTHOR,           l10n->about_author);\r\n            SetDlgItemText(hwnd, IDC_AUTHOR2,          l10n->about_author2);\r\n            SetDlgItemText(hwnd, IDC_LICENSE,          l10n->about_license);\r\n            SetDlgItemText(hwnd, IDC_TRANSLATIONS_BOX, l10n->about_translation_credit);\r\n\r\n            TCHAR txt[1024] = TEXT(\"\");\r\n            int i;\r\n            if (langinfo) {\r\n                for (i = 0; i < nlanguages; i++) {\r\n                    lstrcat_s(txt, ARR_SZ(txt), langinfo[i].lang_english);\r\n                    lstrcat_s(txt, ARR_SZ(txt), TEXT(\": \"));\r\n                    lstrcat_s(txt, ARR_SZ(txt), langinfo[i].author);\r\n                    if (i + 1 != nlanguages) {\r\n                        lstrcat_s(txt, ARR_SZ(txt), TEXT(\"\\r\\n\"));\r\n                    }\r\n                }\r\n            }\r\n            SetDlgItemText(hwnd, IDC_TRANSLATIONS, txt);\r\n        }\r\n    }\r\n\r\n    return FALSE;\r\n}\r\nstatic HWND NewTestWindow();\r\nstatic void ToggleFullScreen(HWND hwnd)\r\n{\r\n    LONG_PTR fs = GetWindowLongPtr(hwnd, 0);\r\n    LONG_PTR fl = GetWindowLongPtr(hwnd, GWL_STYLE);\r\n    if (fs) {\r\n        // We are fullscreen, we need to restore olfd style\r\n        if ( !(fs & WS_MAXIMIZE) )\r\n            SendMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);\r\n        if ( !(fl & WS_MAXIMIZE) )\r\n            fs &=~WS_MAXIMIZE; //\r\n        SetWindowLongPtr(hwnd, GWL_STYLE, fs|(WS_CAPTION|WS_THICKFRAME));\r\n        SetWindowLongPtr(hwnd, 0, 0); // Clear fs falg.\r\n        SetWindowPos(hwnd, NULL, 0, 0, 0, 0\r\n               , SWP_ASYNCWINDOWPOS|SWP_NOSIZE|SWP_NOMOVE|SWP_FRAMECHANGED|SWP_NOZORDER);\r\n    } else {\r\n        SetWindowLongPtr(hwnd, 0, fl); // store fs falg.\r\n        SetWindowLongPtr(hwnd, GWL_STYLE, fl&~(WS_CAPTION|WS_THICKFRAME));\r\n        SetWindowPos(hwnd, NULL, 0, 0, 0, 0\r\n               , SWP_ASYNCWINDOWPOS|SWP_NOSIZE|SWP_NOMOVE|SWP_FRAMECHANGED|SWP_NOZORDER);\r\n        SendMessage(hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);\r\n    }\r\n\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Simple windows proc that draws the resizing regions.\r\nLRESULT CALLBACK TestWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    #define MAXLINES 16\r\n    #define MAXLL    48\r\n    static UCHAR centerfrac=24;\r\n    static UCHAR sidefrac=100;\r\n    static UCHAR centermode=1;\r\n    static UCHAR uDarkMode = 0; // Using dark mode?\r\n    struct lastkeyss {\r\n        int idx;\r\n        TCHAR lastkey[MAXLINES][MAXLL];\r\n    };\r\n    TCHAR *buttonstr=NULL;\r\n\r\n    switch (msg) {\r\n    case WM_CREATE: {\r\n        // uDarkMode = AllowDarkTitlebar(hwnd);\r\n\r\n        // Allocate sace for the list of last keys.\r\n        void *lastkeys = calloc(1, sizeof(struct lastkeyss));\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lastkeys);\r\n\r\n        } break;\r\n\r\n    case WM_KEYDOWN:\r\n\r\n        // Ctrl+N (VK_N = 0x4E)\r\n        if (wParam == 0x4E && (GetKeyState(VK_CONTROL)&0x8000)) {\r\n            NewTestWindow();\r\n            break;\r\n        }\r\n        if (wParam == VK_F11)\r\n            ToggleFullScreen(hwnd);\r\n\r\n        goto PRINTT;\r\n    case WM_LBUTTONDOWN:\r\n        buttonstr = TEXT(\"LClick D\"); goto PRINTT;\r\n    case WM_RBUTTONDOWN:\r\n        buttonstr = TEXT(\"RClick D\"); goto PRINTT;\r\n    case WM_MBUTTONDOWN:\r\n        buttonstr = TEXT(\"MClick D\"); goto PRINTT;\r\n    case WM_XBUTTONDOWN:\r\n        buttonstr = HIWORD(wParam) == 1? TEXT(\"XClick 1 D\"): TEXT(\"XClick 2 D\");\r\n        goto PRINTT;\r\n    case WM_LBUTTONUP:\r\n        buttonstr = TEXT(\"LClick U\"); goto PRINTT;\r\n    case WM_RBUTTONUP:\r\n        buttonstr = TEXT(\"RClick U\"); goto PRINTT;\r\n    case WM_MBUTTONUP:\r\n        buttonstr = TEXT(\"MClick U\"); goto PRINTT;\r\n    case WM_XBUTTONUP:\r\n        buttonstr = HIWORD(wParam) == 1? TEXT(\"XClick 1 U\"): TEXT(\"XClick 2 U\");\r\n        goto PRINTT;\r\n    case WM_MOUSEWHEEL:\r\n        buttonstr = TEXT(\"Wheel\"); goto PRINTT;\r\n    case WM_MOUSEHWHEEL:\r\n        buttonstr = TEXT(\"HWheel\"); goto PRINTT;\r\n    case WM_KEYUP:\r\n    case WM_SYSKEYUP:\r\n    case WM_SYSKEYDOWN:\r\n    PRINTT: {\r\n        TCHAR txt[32];\r\n        struct lastkeyss *lks = (struct lastkeyss *)GetWindowLongPtr(hwnd, GWLP_USERDATA);\r\n        if (!lks) break;\r\n        int idx = lks->idx;\r\n        TCHAR (*lastkey)[MAXLL] = lks->lastkey;\r\n\r\n        if (!buttonstr) {\r\n            lstrcpy_s(lastkey[idx], MAXLL, TEXT(\"vK=\"));\r\n            lstrcat_s(lastkey[idx], MAXLL, LPTR2Hex(txt, (BYTE)wParam));\r\n            lstrcat_s(lastkey[idx], MAXLL, lParam&(1u<<31)? TEXT(\" U\"): lParam&(1u<<30)? TEXT(\" R\") :TEXT(\" D\"));\r\n            lstrcat_s(lastkey[idx], MAXLL, TEXT(\" sC=\"));\r\n            lstrcat_s(lastkey[idx], MAXLL, LPTR2Hex(txt, HIWORD(lParam)&0x00FF));\r\n            lstrcat_s(lastkey[idx], MAXLL, TEXT(\", LP=\") );\r\n            lstrcat_s(lastkey[idx], MAXLL, LPTR2Hex(txt, lParam));\r\n            txt[0] = L','; txt[1] = L' '; txt[2] = L'\\0';\r\n            if (GetKeyNameText(lParam, txt+2, ARR_SZ(txt)-2))\r\n                lstrcat_s(lastkey[idx], MAXLL, txt);\r\n        } else {\r\n            short x = LOWORD(lParam);\r\n            short y = HIWORD(lParam);\r\n            lstrcpy_s(lastkey[idx], MAXLL, buttonstr);\r\n            if (msg == WM_MOUSEWHEEL || msg == WM_MOUSEHWHEEL) {\r\n                short delta = HIWORD(wParam);\r\n                if (delta >= 0) {\r\n                    lstrcat_s(lastkey[idx], MAXLL, TEXT(\" +\"));\r\n                } else {\r\n                    delta = -delta;\r\n                    lstrcat_s(lastkey[idx], MAXLL, TEXT(\" -\"));\r\n                }\r\n                lstrcat_s(lastkey[idx], MAXLL, Int2lStr(txt, delta));\r\n            }\r\n            lstrcat_s(lastkey[idx], MAXLL, TEXT(\" (\"));\r\n            lstrcat_s(lastkey[idx], MAXLL, Int2lStr(txt, x));\r\n            lstrcat_s(lastkey[idx], MAXLL, TEXT(\", \"));\r\n            lstrcat_s(lastkey[idx], MAXLL, Int2lStr(txt, y));\r\n            lstrcat_s(lastkey[idx], MAXLL, TEXT(\"), WP=\"));\r\n            lstrcat_s(lastkey[idx], MAXLL, LPTR2Hex(txt, wParam));\r\n        }\r\n        RECT crc;\r\n        GetClientRect(hwnd, &crc);\r\n        long lineheight = MulDiv(11, ReallyGetDpiForWindow(hwnd), 72);\r\n        lineheight = lineheight + lineheight/8;\r\n\r\n        long splitheight = crc.bottom-lineheight*MAXLINES;\r\n        RECT trc =  { lineheight/2, splitheight, crc.right, crc.bottom };\r\n        InvalidateRect(hwnd, &trc, TRUE);\r\n        idx++;\r\n        idx = idx%MAXLINES;\r\n        lks->idx = idx;\r\n    } break;\r\n\r\n    case WM_PAINT: {\r\n        if(!GetUpdateRect(hwnd, NULL, FALSE)) return 0;\r\n        /* We must keep track of pens and delete them. */\r\n        const UINT dpi = GetDpiForWindow(hwnd);\r\n        const UINT penwidth = GetSystemMetricsForDpi(SM_CXEDGE, dpi);\r\n\r\n        const COLORREF txtcolor = uDarkMode? RGB(255, 255, 255): GetSysColor(COLOR_BTNTEXT);\r\n        const HBRUSH bgbrush =    uDarkMode? CreateSolidBrush(RGB(32, 32, 32)): (HBRUSH)(COLOR_BTNFACE+1);\r\n        const HPEN pen = (HPEN) CreatePen(PS_SOLID, penwidth, txtcolor);\r\n\r\n        const struct lastkeyss *lks = (struct lastkeyss *)GetWindowLongPtr(hwnd, GWLP_USERDATA);\r\n        if (!lks) break;\r\n        int idx = lks->idx;\r\n        const TCHAR (*lastkey)[MAXLL] = lks->lastkey;\r\n\r\n        PAINTSTRUCT ps;\r\n        HDC hdc = BeginPaint(hwnd, &ps);\r\n\r\n        RECT wRect;\r\n        GetWindowRect(hwnd, &wRect);\r\n        POINT Offset = { wRect.left, wRect.top };\r\n        ScreenToClient(hwnd, &Offset);\r\n\r\n        SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));\r\n        HPEN oripen = (HPEN)SelectObject(hdc, pen);\r\n        SetROP2(hdc, R2_COPYPEN);\r\n\r\n        const int width = wRect.right - wRect.left;\r\n        const int height = wRect.bottom - wRect.top;\r\n        const int cwidth = width*centerfrac/100;\r\n        const int cheight = height*centerfrac/100;\r\n\r\n        FillRect(hdc, &ps.rcPaint, bgbrush);\r\n        if (centermode != 3)\r\n            Rectangle(hdc // Draw central rectangle\r\n                , Offset.x + (width-cwidth)/2\r\n                , Offset.y + (height-cheight)/2\r\n                , Offset.x + (width+cwidth)/2 +1\r\n                , Offset.y + (height+cheight)/2+1);\r\n\r\n        // Side lines\r\n        const int swidth = width*sidefrac/100;\r\n        const int sheight = height*sidefrac/100;\r\n        const int kwidth = max(cwidth, swidth);\r\n        const int kheight = max(cheight, sheight);\r\n        POINT ptss[16]={// Left\r\n                        { 0,                (height-sheight)/2 },\r\n                        { (width-kwidth)/2, (height-sheight)/2 },\r\n                        { 0,                (height+sheight)/2 },\r\n                        { (width-kwidth)/2, (height+sheight)/2 },\r\n                        // Right\r\n                        { (width+kwidth)/2, (height-sheight)/2 },\r\n                        { width,            (height-sheight)/2 },\r\n                        { (width+kwidth)/2, (height+sheight)/2 },\r\n                        { width,            (height+sheight)/2 },\r\n                        // Top\r\n                        { (width-swidth)/2, 0                  },\r\n                        { (width-swidth)/2, (height-kheight)/2 },\r\n                        { (width+swidth)/2, 0                  },\r\n                        { (width+swidth)/2, (height-kheight)/2 },\r\n                        // Bottom\r\n                        { (width-swidth)/2, (height+kheight)/2 },\r\n                        { (width-swidth)/2, height             },\r\n                        { (width+swidth)/2, (height+kheight)/2 },\r\n                        { (width+swidth)/2, height             },\r\n                      };\r\n        OffsetPoints(ptss, Offset.x, Offset.y, 16);\r\n        int j;\r\n        for (j=0; j < 16; j+=2) {\r\n            Polyline(hdc, &ptss[j], 2);\r\n        }\r\n        if (centerfrac < sidefrac) {\r\n            // We must draw 4 extra diagonal lines.\r\n            POINT pts[8]={ // Top-Left\r\n                          { (width-kwidth)/2, (height-sheight)/2 },\r\n                          { (width-cwidth)/2, (height-cheight)/2 },\r\n                          // Top-Right\r\n                          { (width+kwidth)/2, (height-sheight)/2 },\r\n                          { (width+cwidth)/2, (height-cheight)/2 },\r\n                          // Bottom-Left\r\n                          { (width-swidth)/2, (height+kheight)/2 },\r\n                          { (width-cwidth)/2, (height+cheight)/2 },\r\n                          // Bottom-Right\r\n                          { (width+swidth)/2, (height+kheight)/2 },\r\n                          { (width+cwidth)/2, (height+cheight)/2 },\r\n                         };\r\n            OffsetPoints(pts, Offset.x, Offset.y, 16);\r\n            for (j=0; j < 8; j+=2) {\r\n                Polyline(hdc, &pts[j], 2);\r\n            }\r\n        }\r\n\r\n        if (centermode == 3) { // Closest side mode\r\n            // Draw diagonal lines\r\n            POINT pts[4] ={ { (width-cwidth)/2, (height-cheight)/2 },\r\n                            { (width+cwidth)/2, (height+cheight)/2 },\r\n                            { (width-cwidth)/2, (height+cheight)/2 },\r\n                            { (width+cwidth)/2, (height-cheight)/2 },\r\n                          };\r\n            OffsetPoints(pts, Offset.x, Offset.y, 4);\r\n            Polyline(hdc, pts  , 2);\r\n            Polyline(hdc, pts+2, 2);\r\n\r\n            HPEN dotpen = (HPEN)CreatePen(PS_DOT, 1, txtcolor);\r\n            HPEN prevpen = (HPEN)SelectObject(hdc, dotpen);\r\n            int oldbkmode = SetBkMode(hdc, TRANSPARENT);\r\n            Rectangle(hdc // Draw dashed central rectagle\r\n                , Offset.x+(width-cwidth)/2\r\n                , Offset.y+(height-cheight)/2\r\n                , (width+cwidth)/2 + Offset.x+1\r\n                , (height+cheight)/2 + Offset.y+1);\r\n            // restore oldpen and delete dotpen\r\n            SetBkMode(hdc, oldbkmode);\r\n            DeleteObject(SelectObject(hdc, prevpen));\r\n        }\r\n\r\n        // Draw textual info....\r\n        LOGFONT lfont;\r\n        GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfont);\r\n        lfont.lfHeight = -MulDiv(11, ReallyGetDpiForWindow(hwnd), 72);\r\n        long lineheight = -(lfont.lfHeight + lfont.lfHeight/8);\r\n        HFONT oldfont = (HFONT)SelectObject(hdc, CreateFontIndirect(&lfont));\r\n        SetBkMode(hdc, TRANSPARENT);\r\n        SetTextColor(hdc, txtcolor);\r\n\r\n        RECT crc;\r\n        GetClientRect(hwnd, &crc);\r\n        UCHAR i;\r\n        long splitheight = crc.bottom - lineheight*MAXLINES;\r\n        for (i=0; i < MAXLINES; i++) {\r\n            UCHAR didx = (idx+i)%MAXLINES;\r\n            RECT trc = {lineheight/2, crc.bottom-lineheight*(MAXLINES-i), crc.right, crc.bottom};\r\n            DrawText(hdc, lastkey[didx], lstrlen(lastkey[didx]), &trc, DT_NOCLIP|DT_TABSTOP);\r\n        }\r\n        TCHAR *str = l10n->zone_testwinhelp;\r\n        if (UseZones&1) {\r\n            RECT trc2 = { lineheight/2, lineheight/2, crc.right, splitheight };\r\n            DrawText(hdc, str, lstrlen(str), &trc2, DT_NOCLIP|DT_TABSTOP);\r\n        }\r\n        SelectObject(hdc, oripen);\r\n        DeleteObject(SelectObject(hdc, oldfont));\r\n\r\n        EndPaint(hwnd, &ps);\r\n\r\n        DeleteObject(pen); // delete pen\r\n        if (bgbrush != (HBRUSH)(COLOR_BTNFACE+1))\r\n            DeleteObject(bgbrush);// Delete brush if needed.\r\n\r\n        return 0;\r\n    } break;\r\n\r\n//    case WM_ERASEBKGND:\r\n//        Sleep(200); break;\r\n//        return 1;\r\n\r\n    case WM_UPDCFRACTION: {\r\n        centerfrac = GetPrivateProfileInt(TEXT(\"General\"), TEXT(\"CenterFraction\"), 24, inipath);\r\n        centermode = GetPrivateProfileInt(TEXT(\"General\"), TEXT(\"ResizeCenter\"), 1, inipath);\r\n        sidefrac   = GetPrivateProfileInt(TEXT(\"General\"), TEXT(\"SidesFraction\"), 255, inipath);\r\n        if (sidefrac == 255) sidefrac = centerfrac;\r\n        return 0;\r\n    } break;\r\n    case WM_DESTROY : {\r\n        // Free the allocatde memory for the key list.\r\n        void *lastkeyss = (void *)GetWindowLongPtr(hwnd, GWLP_USERDATA);\r\n        free(lastkeyss);\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)NULL); // In case\r\n    } break;\r\n    }\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n#undef MAXLINES\r\n\r\nstatic HWND NewTestWindow()\r\n{\r\n    HWND testwnd;\r\n    WNDCLASSEX wnd;\r\n    if (!GetClassInfoEx(g_hinst, TEXT(APP_NAMEA)TEXT(\"-Test\"), &wnd)) {\r\n        WNDCLASSEX wndd = {\r\n            sizeof(WNDCLASSEX)\r\n          , CS_HREDRAW|CS_VREDRAW\r\n          , TestWindowProc\r\n          , 0, sizeof(LONG_PTR) // To store old GWL_STYLE\r\n          , g_hinst, icons[1] //LoadIcon(g_hinst, iconstr[1])\r\n          , LoadCursor(NULL, IDC_ARROW)\r\n          , NULL //(HBRUSH)(COLOR_BACKGROUND+1)\r\n          , NULL, TEXT(APP_NAMEA)TEXT(\"-Test\"), NULL\r\n        };\r\n        RegisterClassEx(&wndd);\r\n    }\r\n    TCHAR wintitle[256];\r\n    lstrcpy_noaccel(wintitle, l10n->advanced_testwindow, ARR_SZ(wintitle));\r\n    testwnd = CreateWindowEx(0\r\n         , TEXT(APP_NAMEA)TEXT(\"-Test\"), wintitle\r\n         , WS_OVERLAPPEDWINDOW\r\n         , CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT\r\n         , NULL, NULL, g_hinst, NULL);\r\n    PostMessage(testwnd, WM_UPDCFRACTION, 0, 0);\r\n    ShowWindow(testwnd, SW_SHOW);\r\n\r\n    return testwnd;\r\n}\r\nstatic HWND NewTestWindowAt(int x, int y, int width, int height)\r\n{\r\n    HWND hwnd = NewTestWindow();\r\n    if (hwnd) {\r\n        RECT bd;\r\n        FixDWMRectLL(hwnd, &bd, 0);\r\n        MoveWindow(hwnd, x-bd.left, y-bd.top, width+bd.left+bd.right, height+bd.top+bd.bottom, TRUE);\r\n    }\r\n    return hwnd;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nINT_PTR CALLBACK AdvancedPageDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    #define V (void *)\r\n    static const struct optlst optlst[] = {\r\n        { IDC_AUTOREMAXIMIZE,   T_BOL, 0, TEXT(\"Advanced\"), \"AutoRemaximize\", V 0 },\r\n        { IDC_AEROTOPMAXIMIZES, T_BMK, 0, TEXT(\"Advanced\"), \"AeroTopMaximizes\", V 1 },// bit 0\r\n        { IDC_AERODBCLICKSHIFT, T_BMK, 1, TEXT(\"Advanced\"), \"AeroTopMaximizes\", V 1 },// bit 1\r\n        { IDC_MULTIPLEINSTANCES,T_BOL, 0, TEXT(\"Advanced\"), \"MultipleInstances\",V 0 },\r\n        { IDC_FULLSCREEN,       T_BOL, 0, TEXT(\"Advanced\"), \"FullScreen\", V 1 },\r\n        { IDC_BLMAXIMIZED,      T_BOL, 0, TEXT(\"Advanced\"), \"BLMaximized\", V 0 },\r\n        { IDC_FANCYZONE,        T_BOL, 0, TEXT(\"Zones\"),    \"FancyZone\", V 0 },\r\n        { IDC_NORESTORE,        T_BMK, 2, TEXT(\"General\"),  \"SmartAero\", V 0 },  // bit 2\r\n        { IDC_MAXWITHLCLICK,    T_BMK, 0, TEXT(\"General\"),  \"MMMaximize\", V 1 }, // bit 0\r\n        { IDC_RESTOREONCLICK,   T_BMK, 1, TEXT(\"General\"),  \"MMMaximize\", V 0 }, // bit 1\r\n        { IDC_TOPMOSTINDICATOR, T_BOL, 0, TEXT(\"Advanced\"), \"TopmostIndicator\", V 0},\r\n\r\n        { IDC_CENTERFRACTION,   T_STR, 0, TEXT(\"General\"),  \"CenterFraction\",V TEXT(\"24\") },\r\n        { IDC_SIDESFRACTION,    T_STR, 0, TEXT(\"General\"),  \"SidesFraction\", V TEXT(\"255\")},\r\n        { IDC_AEROHOFFSET,      T_STR, 0, TEXT(\"General\"),  \"AeroHoffset\",   V TEXT(\"50\") },\r\n        { IDC_AEROVOFFSET,      T_STR, 0, TEXT(\"General\"),  \"AeroVoffset\",   V TEXT(\"50\") },\r\n        { IDC_SNAPTHRESHOLD,    T_STR, 0, TEXT(\"Advanced\"), \"SnapThreshold\", V TEXT(\"20\") },\r\n        { IDC_AEROTHRESHOLD,    T_STR, 0, TEXT(\"Advanced\"), \"AeroThreshold\", V TEXT(\"5\")  },\r\n        { IDC_SNAPGAP,          T_STR, 0, TEXT(\"Advanced\"), \"SnapGap\",       V TEXT(\"0\")  },\r\n        { IDC_AEROSPEED,        T_STR, 0, TEXT(\"Advanced\"), \"AeroMaxSpeed\",  V TEXT(\"\")   },\r\n        { IDC_AEROSPEEDTAU,     T_STR, 0, TEXT(\"Advanced\"), \"AeroSpeedTau\",  V TEXT(\"32\") },\r\n        { IDC_MOVETRANS,        T_STR, 0, TEXT(\"General\"),  \"MoveTrans\",     V TEXT(\"\")   },\r\n    };\r\n    #undef V\r\n\r\n//    static HWND testwnd=NULL;\r\n    static int have_to_apply = 0;\r\n    if (msg == WM_INITDIALOG) {\r\n      ReadDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n      # ifndef WIN64\r\n        EnableDlgItem(hwnd, IDC_FANCYZONE, 0);\r\n      # endif\r\n\r\n    } else if (msg == WM_COMMAND) {\r\n        int id = LOWORD(wParam);\r\n        int event = HIWORD(wParam);\r\n\r\n        if (id != IDC_TESTWINDOW && (event == 0 || event == EN_UPDATE)) {\r\n            PropSheet_Changed(g_cfgwnd, hwnd);\r\n            have_to_apply = 1;\r\n        }\r\n        if (id == IDC_TESTWINDOW) { // Click on the Test Window button\r\n            NewTestWindow();\r\n        }\r\n    } else if (msg == WM_NOTIFY) {\r\n        LPNMHDR pnmh = (LPNMHDR) lParam;\r\n        if (pnmh->code == PSN_SETACTIVE) {\r\n            // Update text\r\n            static const struct dialogstring strlst[] = {\r\n                { IDC_METRICS_BOX,      L10NIDX(advanced_metrics_box ) },\r\n                { IDC_CENTERFRACTION_H, L10NIDX(advanced_centerfraction ) },\r\n                { IDC_AEROHOFFSET_H,    L10NIDX(advanced_aerohoffset ) },\r\n                { IDC_AEROVOFFSET_H,    L10NIDX(advanced_aerovoffset ) },\r\n                { IDC_SNAPTHRESHOLD_H,  L10NIDX(advanced_snapthreshold ) },\r\n                { IDC_AEROTHRESHOLD_H,  L10NIDX(advanced_aerothreshold ) },\r\n                { IDC_SNAPGAP_H,        L10NIDX(advanced_snapgap ) },\r\n                { IDC_AEROSPEED_H,      L10NIDX(advanced_aerospeed ) },\r\n                { IDC_MOVETRANS_H,      L10NIDX(advanced_movetrans ) },\r\n                { IDC_TESTWINDOW,       L10NIDX(advanced_testwindow ) },\r\n\r\n                { IDC_BEHAVIOR_BOX,     L10NIDX(advanced_behavior_box ) },\r\n                { IDC_MULTIPLEINSTANCES,L10NIDX(advanced_multipleinstances ) },\r\n                { IDC_AUTOREMAXIMIZE,   L10NIDX(advanced_autoremaximize ) },\r\n                { IDC_AEROTOPMAXIMIZES, L10NIDX(advanced_aerotopmaximizes ) },\r\n                { IDC_AERODBCLICKSHIFT, L10NIDX(advanced_aerodbclickshift ) },\r\n                { IDC_MAXWITHLCLICK,    L10NIDX(advanced_maxwithlclick ) },\r\n                { IDC_RESTOREONCLICK,   L10NIDX(advanced_restoreonclick ) },\r\n                { IDC_FULLSCREEN,       L10NIDX(advanced_fullscreen ) },\r\n                { IDC_BLMAXIMIZED,      L10NIDX(advanced_blmaximized ) },\r\n                { IDC_FANCYZONE,        L10NIDX(advanced_fancyzone ) },\r\n                { IDC_NORESTORE,        L10NIDX(advanced_norestore ) },\r\n                { IDC_TOPMOSTINDICATOR, L10NIDX(advanced_topmostindicator ) },\r\n            };\r\n            UpdateDialogStrings(hwnd, strlst, ARR_SZ(strlst));\r\n\r\n        } else if (pnmh->code == PSN_APPLY && have_to_apply) {\r\n            // Apply or OK button was pressed.\r\n            // Save settings\r\n            WriteDialogOptions(hwnd, optlst, ARR_SZ(optlst));\r\n            UpdateSettings();\r\n            // Update Test windows in if open.\r\n            EnumThreadWindows(GetCurrentThreadId(), RefreshTestWin, 0);\r\n            have_to_apply = 0;\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n"
        },
        {
          "name": "hooks.c",
          "type": "blob",
          "size": 245.9375,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2022                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#include \"hooks.h\"\r\nstatic void MoveWindowAsync(HWND hwnd, int x, int y, int w, int h);\r\nstatic BOOL CALLBACK EnumMonitorsProc(HMONITOR, HDC, LPRECT , LPARAM );\r\nstatic LRESULT CALLBACK MenuWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// Timer messages\r\n#define REHOOK_TIMER    WM_APP+1\r\n#define SPEED_TIMER     WM_APP+2\r\n#define GRAB_TIMER      WM_APP+3\r\n//#define ALTUP_TIMER     WM_APP+4\r\n#define POOL_TIMER      WM_APP+5\r\n\r\n// #define NO_HOOK_LL\r\n\r\n#define CURSOR_ONLY 66\r\n#define NOT_MOVED 33\r\n#define RESET_OFFSET 22\r\n#define DRAG_WAIT 77\r\n// Number of actions per button!\r\n//  2 for Alt+Clikc\r\n// +2 for Titlebar action\r\n// +2 for Action while moving\r\n// +2 for action while resizing\r\n#define NACPB 8\r\n\r\n#define STACK 0x1000\r\n\r\nstatic HWND g_transhwnd[4]; // 4 windows to make a hollow window\r\nstatic HWND g_timerhwnd;    // For various timers\r\nstatic HWND g_mchwnd;       // For the Action menu messages\r\nstatic HWND g_hkhwnd;       // For the hotkeys message window.\r\n\r\nstatic void UnhookMouse();\r\nstatic void HookMouse();\r\nstatic void UnhookMouseOnly();\r\nstatic HWND KreateMsgWin(WNDPROC proc, const TCHAR *name, LONG_PTR userdata);\r\n\r\n// Enumerators\r\nenum button { BT_NONE=0, BT_LMB=0x02, BT_RMB=0x03, BT_MMB=0x04, BT_MB4=0x05\r\n            , BT_MB5=0x06,  BT_MB6=0x07,  BT_MB7=0x08,  BT_MB8=0x09\r\n            , BT_MB9=0x0A,  BT_MB10=0x0B, BT_MB11=0x0C, BT_MB12=0x0D\r\n            , BT_MB13=0x0E, BT_MB14=0x0F, BT_MB15=0x10, BT_MB16=0x11\r\n            , BT_MB17=0x12, BT_MB18=0x13, BT_MB19=0x14, BT_MB20=0x15\r\n            , BT_WHEEL=0x16, BT_HWHEEL=0x17 };\r\nenum resizeX { RZ_XNONE=0, RZ_LEFT=1, RZ_RIGHT= 2, RZ_XCENTER=3 };\r\nenum resizeY { RZ_YNONE=0, RZ_TOP= 1, RZ_BOTTOM=2, RZ_YCENTER=3 };\r\nenum buttonstate {STATE_NONE, STATE_DOWN, STATE_UP};\r\n\r\n#define BT_PROBE (1<<16)\r\n\r\nstatic int init_movement_and_actions(POINT pt, HWND hwnd, enum action action, int button);\r\nstatic void FinishMovement();\r\nstatic void MoveTransWin(int x, int y, int w, int h);\r\n\r\nstatic struct windowRR {\r\n    HWND hwnd;\r\n    int x;\r\n    int y;\r\n    int width;\r\n    int height;\r\n    UINT odpi;\r\n    UCHAR end;\r\n    UCHAR start;\r\n    UCHAR moveonly;\r\n    UCHAR maximize;\r\n    UCHAR snap;\r\n} LastWin;\r\n\r\nstruct resizeXY {\r\n    enum resizeX x;\r\n    enum resizeY y;\r\n};\r\nstatic const struct resizeXY AUTORESIZE =   {RZ_XNONE, RZ_YNONE};\r\n// State\r\nstatic struct {\r\n    struct {\r\n        POINT Min;\r\n        POINT Max;\r\n    } mmi;\r\n    POINT clickpt;\r\n    POINT prevpt;\r\n    POINT ctrlpt;\r\n    POINT shiftpt;\r\n    POINT offset;\r\n    POINT mdipt;\r\n\r\n    HWND hwnd;\r\n    HWND sclickhwnd;\r\n    HWND mdiclient;\r\n    DWORD clicktime;\r\n    short hittest;\r\n    short delta;\r\n    unsigned Speed;\r\n    HMENU unikeymenu;\r\n    volatile LONG ignorekey;\r\n    volatile LONG ignoreclick;\r\n\r\n    UCHAR alt;\r\n    UCHAR alt1;\r\n    UCHAR blockaltup;\r\n    UCHAR ctrl;\r\n\r\n    UCHAR shift;\r\n    UCHAR snap;\r\n    UCHAR altsnaponoff;\r\n    UCHAR moving;\r\n\r\n    UCHAR blockmouseup;\r\n    UCHAR fwmouseup;\r\n    UCHAR enumed;\r\n    UCHAR usezones;\r\n\r\n    UCHAR clickbutton;\r\n    UCHAR resizable;\r\n    struct {\r\n        UCHAR maximized;\r\n        UCHAR fullscreen;\r\n        RECT mon;\r\n        HMONITOR monitor;\r\n        int width;\r\n        int height;\r\n        int right;\r\n        int bottom;\r\n        UINT dpi;\r\n    } origin;\r\n\r\n    UCHAR sactiondone;\r\n    UCHAR xxbutton;\r\n    UCHAR ignorept;\r\n    enum action action;\r\n    struct resizeXY resize;\r\n} state;\r\n\r\n// Snap\r\nRECT *monitors = NULL;\r\nunsigned nummonitors = 0;\r\nRECT *wnds = NULL;\r\nunsigned numwnds = 0;\r\nHWND *hwnds = NULL;\r\nunsigned numhwnds = 0;\r\n\r\n// Settings\r\n#define MAXKEYS 15\r\nstatic struct config {\r\n    // System settings\r\n    short dragXth;\r\n    short dragYth;\r\n    short dbclickX;\r\n    short dbclickY;\r\n    // [General]\r\n    UCHAR AutoFocus;\r\n    UCHAR AutoSnap;\r\n    UCHAR Aero;\r\n    UCHAR SmartAero;\r\n    UCHAR StickyResize;\r\n    UCHAR InactiveScroll;\r\n    UCHAR MDI;\r\n    UCHAR ResizeCenter;\r\n    UCHAR CenterFraction;\r\n    UCHAR SidesFraction;\r\n    UCHAR AVoff;\r\n    UCHAR AHoff;\r\n    UCHAR MoveTrans;\r\n    UCHAR MMMaximize;\r\n    // [Advanced]\r\n    UCHAR ResizeAll;\r\n    UCHAR FullScreen;\r\n    UCHAR BLMaximized;\r\n    UCHAR AutoRemaximize;\r\n    UCHAR SnapThreshold;\r\n    UCHAR AeroThreshold;\r\n    UCHAR KBMoveStep;\r\n    UCHAR KBMoveSStep;\r\n    UCHAR AeroTopMaximizes;\r\n    UCHAR UseCursor;\r\n    UCHAR MinAlpha;\r\n    char AlphaDelta;\r\n    char AlphaDeltaShift;\r\n    UCHAR ZoomFrac;\r\n    UCHAR ZoomFracShift;\r\n    UCHAR NumberMenuItems;\r\n    UCHAR MaxMenuWidth;\r\n    UCHAR AeroSpeedTau;\r\n    char SnapGap;\r\n    UCHAR ShiftSnaps;\r\n    UCHAR PiercingClick;\r\n    UCHAR DragSendsAltCtrl;\r\n    UCHAR TopmostIndicator;\r\n    UCHAR RCCloseMItem;\r\n    UCHAR MaxKeysNum;\r\n    UCHAR DragThreshold;\r\n    UCHAR AblockHotclick;\r\n    UCHAR MenuShowOffscreenWin;\r\n    UCHAR MenuShowEmptyLabelWin;\r\n    UCHAR IgnoreMinMaxInfo;\r\n    UCHAR NotifyWinEvent;\r\n    // [Performance]\r\n    UCHAR FullWin;\r\n    UCHAR TransWinOpacity;\r\n    UCHAR RefreshRate;\r\n    UCHAR RezTimer;\r\n    UCHAR PinRate;\r\n    UCHAR MoveRate;\r\n    UCHAR ResizeRate;\r\n    // [Input]\r\n    UCHAR TTBActions;\r\n    UCHAR KeyCombo;\r\n    UCHAR ScrollLockState;\r\n    UCHAR LongClickMove;\r\n    UCHAR UniKeyHoldMenu;\r\n    // [Zones]\r\n    UCHAR UseZones;\r\n    UCHAR ShowZonesPrevw;\r\n    UCHAR ZonesPrevwOpacity;\r\n    UCHAR ZSnapMode;\r\n    UCHAR LayoutNumber;\r\n    char InterZone;\r\n  # ifdef WIN64\r\n    UCHAR FancyZone;\r\n  #endif\r\n    // [KBShortcuts]\r\n    UCHAR UsePtWindow;\r\n    // -- -- -- -- -- -- --\r\n    UCHAR keepMousehook;\r\n    UCHAR EndSendKey; // Used to be VK_CONTROL\r\n    WORD AeroMaxSpeed;\r\n    WORD LongClickMoveDelay;\r\n    DWORD BLCapButtons;\r\n    DWORD BLUpperBorder;\r\n    int PinColor;\r\n\r\n    UCHAR Hotkeys[MAXKEYS+1];\r\n    UCHAR Shiftkeys[MAXKEYS+1];\r\n    UCHAR Hotclick[MAXKEYS+1];\r\n    UCHAR Killkey[MAXKEYS+1];\r\n    UCHAR XXButtons[MAXKEYS+1];\r\n    UCHAR ModKey[MAXKEYS+1];\r\n    UCHAR HScrollKey[MAXKEYS+1];\r\n    UCHAR ESCkeys[MAXKEYS+1];\r\n\r\n    struct {\r\n        enum action // Up to 20 BUTTONS!!!\r\n          LMB[NACPB],  RMB[NACPB],  MMB[NACPB],  MB4[NACPB],  MB5[NACPB]\r\n        , MB6[NACPB],  MB7[NACPB],  MB8[NACPB],  MB9[NACPB],  MB10[NACPB]\r\n        , MB11[NACPB], MB12[NACPB], MB13[NACPB], MB14[NACPB], MB15[NACPB]\r\n        , MB16[NACPB], MB17[NACPB], MB18[NACPB], MB19[NACPB], MB20[NACPB]\r\n        , Scroll[NACPB], HScroll[NACPB]; // Plus vertical and horizontal wheels\r\n    } Mouse;\r\n    enum action GrabWithAlt[NACPB]; // Actions without click\r\n    enum action MoveUp[NACPB];      // Actions on (long) Move Up w/o drag\r\n    enum action ResizeUp[NACPB];    // Actions on (long) Resize Up w/o drag\r\n\r\n    UCHAR *inputSequences[AC_SHRTF-AC_SHRT0]; // 36\r\n} conf;\r\n\r\nstruct OptionListItem {\r\n   const char *name; int def;\r\n};\r\n// [General]\r\nstatic const struct OptionListItem General_uchars[] = {\r\n    { \"AutoFocus\", 0 },\r\n    { \"AutoSnap\", 0 },\r\n    { \"Aero\", 1 },\r\n    { \"SmartAero\", 1 },\r\n    { \"StickyResize\", 0 },\r\n    { \"InactiveScroll\", 0 },\r\n    { \"MDI\", 0 },\r\n    { \"ResizeCenter\", 1 },\r\n    { \"CenterFraction\", 24 },\r\n    { \"SidesFraction\", 255 },\r\n    { \"AeroHoffset\", 50 },\r\n    { \"AeroVoffset\", 50 },\r\n    { \"MoveTrans\", 255 },\r\n    { \"MMMaximize\", 1 },\r\n};\r\n// [Advanced]\r\nstatic const struct OptionListItem Advanced_uchars[] = {\r\n    { \"ResizeAll\", 1 },\r\n    { \"FullScreen\", 1 },\r\n    { \"BLMaximized\", 0 },\r\n    { \"AutoRemaximize\", 0 },\r\n    { \"SnapThreshold\", 20 },\r\n    { \"AeroThreshold\", 5 },\r\n    { \"KBMoveStep\", 100 },\r\n    { \"KBMoveSStep\", 10 },\r\n    { \"AeroTopMaximizes\", 1 },\r\n    { \"UseCursor\", 1 },\r\n    { \"MinAlpha\", 32 },\r\n    { \"AlphaDelta\", 64 },\r\n    { \"AlphaDeltaShift\", 8 },\r\n    { \"ZoomFrac\", 16 },\r\n    { \"ZoomFracShift\", 64 },\r\n    { \"NumberMenuItems\", 0},\r\n    { \"MaxMenuWidth\", 80},\r\n    { \"AeroSpeedTau\", 64 },\r\n    { \"SnapGap\", 0 },\r\n    { \"ShiftSnaps\", 1 },\r\n    { \"PiercingClick\", 0 },\r\n    { \"DragSendsAltCtrl\", 0 },\r\n    { \"TopmostIndicator\", 0 },\r\n    { \"RCCloseMItem\", 1 },\r\n    { \"MaxKeysNum\", 0 },\r\n    { \"DragThreshold\", 1 },\r\n    { \"AblockHotclick\", 0 },\r\n    { \"MenuShowOffscreenWin\", 0 },\r\n    { \"MenuShowEmptyLabelWin\", 0 },\r\n    { \"IgnoreMinMaxInfo\", 0 },\r\n    { \"NotifyWinEvent\", 1},\r\n};\r\n// [Performance]\r\nstatic const struct OptionListItem Performance_uchars[] = {\r\n    { \"FullWin\", 2 },\r\n    { \"TransWinOpacity\", 0 },\r\n    { \"RefreshRate\", 0 },\r\n    { \"RezTimer\", 0 },\r\n    { \"PinRate\", 32 },\r\n    { \"MoveRate\", 2 },\r\n    { \"ResizeRate\", 4 },\r\n};\r\n// [Input]\r\nstatic const struct OptionListItem Input_uchars[] = {\r\n    { \"TTBActions\", 0 },\r\n    { \"KeyCombo\", 0 },\r\n    { \"ScrollLockState\", 0 },\r\n    { \"LongClickMove\", 0 },\r\n    { \"UniKeyHoldMenu\", 0 },\r\n};\r\n// [Zones]\r\nstatic const struct OptionListItem Zones_uchars[] = {\r\n    { \"UseZones\", 0 },\r\n    { \"ShowZonesPrevw\", 1 },\r\n    { \"ZonesPrevwOpacity\", 161 },\r\n    { \"ZSnapMode\", 0 },\r\n    { \"LayoutNumber\", 0 },\r\n    { \"InterZone\", 32 },\r\n  # ifdef WIN64\r\n    { \"FancyZone\", 0 },\r\n  # endif\r\n};\r\n\r\n// Blacklist (dynamically allocated)\r\nstruct blacklistitem {\r\n    const TCHAR *title;\r\n    const TCHAR *classname;\r\n    const TCHAR *exename;\r\n};\r\nstruct blacklist {\r\n    struct blacklistitem *items;\r\n    unsigned length;\r\n    TCHAR *data;\r\n};\r\nstatic struct {\r\n    struct blacklist Processes;\r\n    struct blacklist Windows;\r\n    struct blacklist Snaplist;\r\n    struct blacklist MDIs;\r\n    struct blacklist Pause;\r\n    struct blacklist MMBLower;\r\n    struct blacklist Scroll;\r\n    struct blacklist IScroll;\r\n    struct blacklist AResize;\r\n    struct blacklist SSizeMove;\r\n    struct blacklist NCHittest;\r\n    struct blacklist Bottommost;\r\n} BlkLst;\r\n// MUST MATCH THE ABOVE!!!\r\nstatic const char *BlackListStrings[] = {\r\n    \"Processes\", // Max length is 15 char + NULL\r\n    \"Windows\",\r\n    \"Snaplist\",\r\n    \"MDIs\",\r\n    \"Pause\",\r\n    \"MMBLower\",\r\n    \"Scroll\",\r\n    \"IScroll\",\r\n    \"AResize\",\r\n    \"SSizeMove\",\r\n    \"NCHittest\",\r\n    \"Bottommost\"\r\n};\r\n// Cursor data\r\nHWND g_mainhwnd = NULL;\r\n\r\n// Hook data\r\nHINSTANCE hinstDLL = NULL;\r\nHHOOK mousehook = NULL;\r\n\r\n#define FixDWMRect(hwnd, rect) FixDWMRectLL(hwnd, rect, conf.SnapGap)\r\n#undef GetWindowRectL\r\n#define GetWindowRectL(hwnd, rect) GetWindowRectLL(hwnd, rect, conf.SnapGap)\r\n\r\n// To clamp width and height of windows\r\nstatic pure int CLAMPW(int width)  { return CLAMP(state.mmi.Min.x, width,  state.mmi.Max.x); }\r\nstatic pure int CLAMPH(int height) { return CLAMP(state.mmi.Min.y, height, state.mmi.Max.y); }\r\nstatic pure int ISCLAMPEDW(int x)  { return state.mmi.Min.x <= x && x <= state.mmi.Max.x; }\r\nstatic pure int ISCLAMPEDH(int y)  { return state.mmi.Min.y <= y && y <= state.mmi.Max.y; }\r\n\r\n/* If pt and ptt are it is the same points with 4px tolerence */\r\nstatic xpure int IsSamePTT(const POINT *pt, const POINT *ptt)\r\n{\r\n    const short Tx = conf.dbclickX;\r\n    const short Ty = conf.dbclickY;\r\n    return !( pt->x > ptt->x+Tx || pt->y > ptt->y+Ty || pt->x < ptt->x-Tx || pt->y < ptt->y-Ty );\r\n}\r\n\r\nstatic xpure int IsPtDragOut(const POINT *pt, const POINT *ptt)\r\n{\r\n    const short Tx = conf.dragXth;\r\n    const short Ty = conf.dragYth;\r\n    return !( pt->x > ptt->x+Tx || pt->y > ptt->y+Ty || pt->x < ptt->x-Tx || pt->y < ptt->y-Ty );\r\n}\r\n\r\n// Specific includes\r\n#include \"snap.c\"\r\n#include \"zones.c\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Wether a window is present or not in a blacklist\r\nstatic pure int blacklisted(HWND hwnd, const struct blacklist *list)\r\n{\r\n    // Null hwnd or empty list\r\n    if (!hwnd || !list->length || !list->items)\r\n        return 0;\r\n    // If the first element is *:*|* (NULL:NULL|NULL)then we are in whitelist mode\r\n    // mode = 1 => blacklist, mode = 0 => whitelist;\r\n    UCHAR mode = list->items[0].classname\r\n              || list->items[0].title\r\n              || list->items[0].exename;\r\n    unsigned i = !mode; // Skip the first item...\r\n\r\n    TCHAR title[256], classname[256];\r\n    TCHAR exename[MAX_PATH];\r\n    title[0] = classname[0] = exename[0] = '\\0';\r\n    GetWindowText(hwnd, title, ARR_SZ(title));\r\n    GetClassName(hwnd, classname, ARR_SZ(classname));\r\n    GetWindowProgName(hwnd, exename, ARR_SZ(exename));\r\n\r\n    for ( ; i < list->length; i++) {\r\n        if (!lstrcmp_star(classname, list->items[i].classname)\r\n        &&  !lstrcmp_star(title, list->items[i].title)\r\n        && (!list->items[i].exename || !lstrcmpi(exename, list->items[i].exename))\r\n        ) {\r\n            return mode;\r\n        }\r\n    }\r\n    return !mode;\r\n}\r\n\r\nstatic int isClassName(HWND hwnd, const TCHAR *str)\r\n{\r\n    TCHAR classname[256];\r\n    return GetClassName(hwnd, classname, ARR_SZ(classname))\r\n        && !lstrcmp(classname, str);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// The second bit (&2) will always correspond to the WS_THICKFRAME flag\r\nstatic int pure IsResizable(HWND hwnd)\r\n{\r\n    int thickf = !!(GetWindowLongPtr(hwnd, GWL_STYLE)&WS_THICKFRAME);\r\n    int ret =  conf.ResizeAll // bit two is the real thickframe state.\r\n            | thickf | (thickf<<1);\r\n\r\n    if (!ret) ret = !!GetBorderlessFlag(hwnd);\r\n    if (!ret) ret = !!blacklisted(hwnd, &BlkLst.AResize); // Always resize list\r\n\r\n    return ret;\r\n}\r\nstatic HMONITOR GetMonitorInfoFromWin(HWND hwnd, MONITORINFO *mi)\r\n{\r\n    mi->cbSize = sizeof(MONITORINFO);\r\n    HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\r\n    GetMonitorInfo(hmon, mi);\r\n    return hmon;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic BOOL IsFullscreen(HWND hwnd)\r\n{\r\n    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);\r\n\r\n    if ((style&WS_CAPTION) != WS_CAPTION) {\r\n        RECT rc;\r\n        if (GetWindowRect(hwnd, &rc)) {\r\n            MONITORINFO mi;\r\n            GetMonitorInfoFromWin(hwnd, &mi);\r\n            return EqualRect(&rc, &mi.rcMonitor);\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\nstatic int IsFullscreenF(HWND hwnd, const RECT *wnd, const RECT *fmon)\r\n{\r\n    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);\r\n\r\n    // No caption and fullscreen window\r\n    return ((style&WS_CAPTION) != WS_CAPTION)\r\n        && EqualRect(wnd, fmon);\r\n}\r\nstatic int IsFullScreenBL(HWND hwnd)\r\n{\r\n    return conf.FullScreen && IsFullscreen(hwnd);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// WM_ENTERSIZEMOVE or WM_EXITSIZEMOVE...\r\nstatic void NotifySizeMoveStaEnd(HWND hwnd, UCHAR sta)\r\n{\r\n    //LOGA(\"NotifySizeMoveStaEnd(%d)\", (int)sta);\r\n    // Don't send WM_ENTER/EXIT SIZEMOVE if the window is in SSizeMove BL\r\n    if(!blacklisted(hwnd, &BlkLst.SSizeMove)) {\r\n        PostMessage(hwnd, sta? WM_ENTERSIZEMOVE: WM_EXITSIZEMOVE, 0, 0);\r\n    }\r\n    // Always send the NotifyWinEvent for IAccessible interface.\r\n    if (conf.NotifyWinEvent)\r\n        NotifyWinEvent(sta? EVENT_SYSTEM_MOVESIZESTART : EVENT_SYSTEM_MOVESIZEEND, hwnd, 0, 0);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Overloading of the Hittest function to include a whitelist\r\n// x and y are in screen coordinate.\r\nstatic int HitTestTimeoutbl(HWND hwnd, POINT pt)\r\n{\r\n    DorQWORD area=0;\r\n\r\n    // Try first with the ancestor window for some buggy AppX?\r\n    HWND ancestor = GetAncestor(hwnd, GA_ROOT);\r\n    if (blacklisted(ancestor, &BlkLst.MMBLower)) return 0;\r\n    if (hwnd != ancestor\r\n    && blacklisted(ancestor, &BlkLst.NCHittest)) {\r\n        SendMessageTimeout(ancestor, WM_NCHITTEST, 0, MAKELPARAM(pt.x, pt.y), SMTO_NORMAL, 200, &area);\r\n        if(area == HTCAPTION) goto DOUBLECHECK_CAPTION;\r\n    }\r\n    area = HitTestTimeoutL(hwnd, MAKELPARAM(pt.x, pt.y));\r\n    DOUBLECHECK_CAPTION:\r\n    if (area == HTCAPTION) {\r\n        // Double check that we are not inside one of the\r\n        // caption buttons buttons because of buggy Win10..\r\n        RECT buttonRc;\r\n        if (GetCaptionButtonsRect(ancestor, &buttonRc) && PtInRect(&buttonRc, pt)) {\r\n            // let us assume it is the minimize button, it makes no sence\r\n            // But Windows is too buggy\r\n            area = HTMINBUTTON;\r\n        }\r\n    }\r\n    return area;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic void GetMinMaxInfo(HWND hwnd, POINT *Min, POINT *Max)\r\n{\r\n    GetMinMaxInfoF(hwnd, Min, Max, conf.IgnoreMinMaxInfo);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Use NULL to restore old transparency.\r\n// Set to -1 to clear old state\r\nstatic void SetWindowTrans(HWND hwnd)\r\n{\r\n    static BYTE oldtrans;\r\n    static HWND oldhwnd;\r\n    if (conf.MoveTrans == 0 || conf.MoveTrans == 255) return;\r\n    if (oldhwnd == hwnd) return; // Nothing to do\r\n    if ((DorQWORD)hwnd == (DorQWORD)(-1)) {\r\n        oldhwnd = NULL;\r\n        oldtrans = 0;\r\n        return;\r\n    }\r\n\r\n    if (hwnd && !oldtrans) {\r\n        oldhwnd = hwnd;\r\n        LONG_PTR exstyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);\r\n        if (exstyle&WS_EX_LAYERED) {\r\n            BYTE ctrans=0;\r\n            if(GetLayeredWindowAttributes(hwnd, NULL, &ctrans, NULL))\r\n                if(ctrans) oldtrans = ctrans;\r\n        } else {\r\n            SetWindowLongPtr(hwnd, GWL_EXSTYLE, exstyle|WS_EX_LAYERED);\r\n            oldtrans = 255;\r\n        }\r\n        SetLayeredWindowAttributes(hwnd, 0, conf.MoveTrans, LWA_ALPHA);\r\n    } else if (!hwnd && oldhwnd) { // restore old trans;\r\n        LONG_PTR exstyle = GetWindowLongPtr(oldhwnd, GWL_EXSTYLE);\r\n        if (!oldtrans || oldtrans == 255) {\r\n            SetWindowLongPtr(oldhwnd, GWL_EXSTYLE, exstyle & ~WS_EX_LAYERED);\r\n        } else {\r\n            SetLayeredWindowAttributes(oldhwnd, 0, oldtrans, LWA_ALPHA);\r\n        }\r\n        oldhwnd = NULL;\r\n        oldtrans = 0;\r\n    }\r\n}\r\nstatic void *GetEnoughSpace(void *ptr, unsigned num, unsigned *alloc, size_t size)\r\n{\r\n    if (num >= *alloc) {\r\n        void *nptr = realloc(ptr, (*alloc+4)*size);\r\n        if (!nptr) { free(ptr);  *alloc=0; return NULL; }\r\n        ptr = nptr;\r\n        if(ptr) *alloc = (*alloc+4); // Realloc succeeded, increase count.\r\n        else *alloc = 0;\r\n    }\r\n    return ptr;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Enumerate callback proc\r\nunsigned monitors_alloc = 0;\r\nBOOL CALLBACK EnumMonitorsProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)\r\n{\r\n    // Make sure we have enough space allocated\r\n    monitors = (RECT *)GetEnoughSpace(monitors, nummonitors, &monitors_alloc, sizeof(RECT));\r\n    if (!monitors) return FALSE; // Stop enum, we failed\r\n    // Add monitor\r\n    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n    GetMonitorInfo(hMonitor, &mi);\r\n    CopyRect(&monitors[nummonitors++], &mi.rcWork); //*lprcMonitor;\r\n\r\n    return TRUE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void OffsetRectMDI(RECT *wnd)\r\n{\r\n    OffsetRect(wnd, -state.mdipt.x, -state.mdipt.y);\r\n}\r\nstatic int ShouldSnapTo(HWND hwnd)\r\n{\r\n    LONG_PTR style;\r\n    return hwnd != state.hwnd\r\n        && IsVisible(hwnd)\r\n        && !IsIconic(hwnd)\r\n        && !(GetWindowLongPtr(hwnd, GWL_EXSTYLE)&WS_EX_NOACTIVATE) // != WS_EX_NOACTIVATE\r\n        &&( ((style=GetWindowLongPtr(hwnd, GWL_STYLE))&WS_CAPTION) == WS_CAPTION\r\n           || (style&WS_THICKFRAME)\r\n           || GetBorderlessFlag(hwnd)//&(WS_THICKFRAME|WS_CAPTION)\r\n           || blacklisted(hwnd, &BlkLst.Snaplist)\r\n        );\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nunsigned wnds_alloc = 0;\r\nBOOL CALLBACK EnumWindowsProc(HWND window, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    wnds = (RECT *)GetEnoughSpace(wnds, numwnds, &wnds_alloc, sizeof(RECT));\r\n    if (!wnds) return FALSE; // Stop enum, we failed\r\n\r\n    // Only store window if it's visible, not minimized to taskbar,\r\n    // not the window we are dragging and not blacklisted\r\n    RECT wnd;\r\n    if (ShouldSnapTo(window) && GetWindowRectL(window, &wnd)) {\r\n\r\n        // Maximized?\r\n        if (IsZoomed(window)) {\r\n            // Skip maximized windows in MDI clients\r\n            if (state.mdiclient) return TRUE;\r\n            // Get monitor size\r\n            MONITORINFO mi;\r\n            GetMonitorInfoFromWin(window, &mi);\r\n            // Crop this window so that it does not exceed the size of the monitor\r\n            // This is done because when maximized, windows have an extra invisible\r\n            // border (a border that stretches onto other monitors)\r\n            CropRect(&wnd, &mi.rcWork);\r\n        }\r\n        OffsetRectMDI(&wnd);\r\n        // Return if this window is overlapped by another window\r\n        unsigned i;\r\n        for (i=0; i < numwnds; i++) {\r\n            if (RectInRect(&wnds[i], &wnd)) {\r\n                return TRUE;\r\n            }\r\n        }\r\n        // Add window to wnds db\r\n        CopyRect(&wnds[numwnds++], &wnd);\r\n    }\r\n    return TRUE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// snapped windows database.\r\nstruct snwdata {\r\n    RECT wnd;\r\n    HWND hwnd;\r\n    unsigned flag;\r\n};\r\nstruct snwdata *snwnds;\r\nunsigned numsnwnds = 0;\r\nunsigned snwnds_alloc = 0;\r\n\r\nBOOL CALLBACK EnumSnappedWindows(HWND hwnd, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    snwnds = (struct snwdata *)GetEnoughSpace(snwnds, numsnwnds, &snwnds_alloc, sizeof(struct snwdata));\r\n    if (!snwnds) return FALSE; // Stop enum, we failed\r\n\r\n    RECT wnd;\r\n    if (ShouldSnapTo(hwnd)\r\n    && !IsZoomed(hwnd)\r\n    && GetWindowRectL(hwnd, &wnd)) {\r\n        unsigned restore;\r\n\r\n        if (conf.SmartAero&2 || IsWindowSnapped(hwnd)) {\r\n            // In SMARTER snapping mode or if the WINDOW IS SNAPPED\r\n            // We only consider the position of the window\r\n            // to determine its snapping state\r\n            MONITORINFO mi;\r\n            GetMonitorInfoFromWin(hwnd, &mi);\r\n            snwnds[numsnwnds].flag = WhichSideRectInRect(&mi.rcWork, &wnd);\r\n        } else if ((restore = GetRestoreFlag(hwnd)) && restore&SNAPPED && restore&SNAPPEDSIDE) {\r\n            // The window was AltSnapped...\r\n            snwnds[numsnwnds].flag = restore;\r\n        } else {\r\n            // thiw window is not snapped.\r\n            return TRUE; // next hwnd\r\n        }\r\n        // Add the window to the list\r\n        OffsetRectMDI(&wnd);\r\n        CopyRect(&snwnds[numsnwnds].wnd, &wnd);\r\n        snwnds[numsnwnds].hwnd = hwnd;\r\n        numsnwnds++;\r\n    }\r\n    return TRUE;\r\n}\r\n// If lParam is set to 1 then only windows that are\r\n// touching the current window will be considered.\r\nstatic void EnumSnapped()\r\n{\r\n    numsnwnds = 0;\r\n    if (conf.SmartAero&1) {\r\n        if(state.mdiclient)\r\n            EnumChildWindows(state.mdiclient, EnumSnappedWindows, 0);\r\n        else\r\n            EnumDesktopWindows(NULL, EnumSnappedWindows, 0);\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Uses the same DB than snapped windows db because they will never\r\n// be used together Enum() vs EnumSnapped()\r\nBOOL CALLBACK EnumTouchingWindows(HWND hwnd, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    snwnds = (struct snwdata *)GetEnoughSpace(snwnds, numsnwnds, &snwnds_alloc, sizeof(*snwnds));\r\n    if (!snwnds) return FALSE; // Stop enum, we failed\r\n\r\n    RECT wnd;\r\n    if (ShouldSnapTo(hwnd)\r\n    && !IsZoomed(hwnd)\r\n    && IsResizable(hwnd)\r\n    && !blacklisted(hwnd, &BlkLst.Windows)\r\n    && GetWindowRectL(hwnd, &wnd)) {\r\n        // Only considers windows that are\r\n        // touching the currently resized window\r\n        RECT statewnd;\r\n        GetWindowRectL(state.hwnd, &statewnd);\r\n        unsigned flag = AreRectsTouchingT(&statewnd, &wnd, conf.SnapThreshold/2);\r\n        if (flag) {\r\n            OffsetRectMDI(&wnd);\r\n\r\n            // Return if this window is overlapped by another window\r\n            unsigned i;\r\n            for (i=0; i < numsnwnds; i++) {\r\n                if (RectInRect(&snwnds[i].wnd, &wnd)) {\r\n                    return TRUE;\r\n                }\r\n            }\r\n\r\n            CopyRect(&snwnds[numsnwnds].wnd, &wnd);\r\n            snwnds[numsnwnds].flag = flag;\r\n            snwnds[numsnwnds].hwnd = hwnd;\r\n            numsnwnds++;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic DWORD WINAPI EndDeferWindowPosThread(LPVOID hwndSS)\r\n{\r\n    EndDeferWindowPos(hwndSS);\r\n    if (conf.RefreshRate) Sleep(conf.RefreshRate);\r\n    LastWin.hwnd = NULL;\r\n    return TRUE;\r\n}\r\nstatic void EndDeferWindowPosAsync(HDWP hwndSS)\r\n{\r\n    DWORD lpThreadId;\r\n    CloseHandle(CreateThread(NULL, STACK, EndDeferWindowPosThread, hwndSS, STACK_SIZE_PARAM_IS_A_RESERVATION, &lpThreadId));\r\n}\r\nstatic int ShouldResizeTouching()\r\n{\r\n    return state.action == AC_RESIZE\r\n        && ( (conf.StickyResize&1 && state.shift)\r\n          || ((conf.StickyResize&3)==2 && !state.shift)\r\n        );\r\n}\r\nstatic void EnumOnce(RECT **bd);\r\nstatic int ResizeTouchingWindows(LPVOID lwptr)\r\n{\r\n    if (!ShouldResizeTouching()) return 0;\r\n    RECT *bd;\r\n    EnumOnce(&bd);\r\n    if (!snwnds || !numsnwnds) return 0;\r\n    struct windowRR *lw = (struct windowRR *)lwptr;\r\n    // posx, posy,  correspond to the VISIBLE rect\r\n    // of the current window...\r\n    int posx = lw->x + bd->left;\r\n    int posy = lw->y + bd->top;\r\n    int width = lw->width - (bd->left+bd->right);\r\n    int height = lw->height - (bd->top+bd->bottom);\r\n\r\n    HDWP hwndSS = NULL; // For DeferwindowPos.\r\n    if (conf.FullWin) {\r\n        hwndSS = BeginDeferWindowPos(numsnwnds+1);\r\n    }\r\n    unsigned i;\r\n    for (i=0; i < numsnwnds; i++) {\r\n        RECT *nwnd = &snwnds[i].wnd;\r\n        unsigned flag = snwnds[i].flag;\r\n        HWND hwnd = snwnds[i].hwnd;\r\n\r\n        POINT tpt;\r\n        tpt.x = (nwnd->left+nwnd->right)/2;\r\n        tpt.y = (nwnd->top+nwnd->bottom)/2 ;\r\n        if(!PtInRect(&state.origin.mon, tpt))\r\n            continue;\r\n\r\n        if (PureLeft(flag)) {\r\n            nwnd->right = posx;\r\n        } else if (PureRight(flag)) {\r\n            POINT Min, Max;\r\n            GetMinMaxInfo(hwnd, &Min, &Max);\r\n            nwnd->left = CLAMP(nwnd->right-Max.x, posx + width, nwnd->right-Min.x);\r\n        } else if (PureTop(flag)) {\r\n            nwnd->bottom = posy;\r\n        } else if (PureBottom(flag)) {\r\n            POINT Min, Max;\r\n            GetMinMaxInfo(hwnd, &Min, &Max);\r\n            nwnd->top = CLAMP(nwnd->bottom-Max.x, posy + height, nwnd->bottom-Min.x);\r\n        } else {\r\n            continue;\r\n        }\r\n        if (hwndSS) {\r\n            RECT nbd;\r\n            FixDWMRect(hwnd, &nbd);\r\n            hwndSS = DeferWindowPos(hwndSS, hwnd, NULL\r\n                    , nwnd->left - nbd.left\r\n                    , nwnd->top - nbd.top\r\n                    , nwnd->right - nwnd->left + nbd.left + nbd.right\r\n                    , nwnd->bottom - nwnd->top + nbd.top + nbd.bottom\r\n                    , SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);\r\n        }\r\n        snwnds[i].flag = flag|TORESIZE;\r\n    }\r\n\r\n    if (hwndSS) {\r\n        // Draw changes ONLY if full win is ON,\r\n        hwndSS = DeferWindowPos(hwndSS, state.hwnd, NULL\r\n                  , lw->x, lw->y, lw->width, lw->height\r\n                  , SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);\r\n        if(hwndSS) EndDeferWindowPosAsync(hwndSS);\r\n    }\r\n    return 1;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void ResizeAllSnappedWindowsAsync()\r\n{\r\n    if (!conf.StickyResize || !numsnwnds) return;\r\n\r\n    HDWP hwndSS = BeginDeferWindowPos(numsnwnds+1);\r\n    unsigned i;\r\n    for (i=0; i < numsnwnds; i++) {\r\n        if(hwndSS && snwnds[i].flag&TORESIZE) {\r\n            RECT bd;\r\n            FixDWMRect(snwnds[i].hwnd, &bd);\r\n            InflateRectBorder(&snwnds[i].wnd, &bd);\r\n            hwndSS = DeferWindowPos(hwndSS, snwnds[i].hwnd, NULL\r\n                    , snwnds[i].wnd.left\r\n                    , snwnds[i].wnd.top\r\n                    , snwnds[i].wnd.right - snwnds[i].wnd.left\r\n                    , snwnds[i].wnd.bottom - snwnds[i].wnd.top\r\n                    , SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);\r\n        }\r\n    }\r\n    if (hwndSS)\r\n        hwndSS = DeferWindowPos(hwndSS, LastWin.hwnd, NULL\r\n               , LastWin.x, LastWin.y, LastWin.width, LastWin.height\r\n               , SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);\r\n    if(hwndSS) EndDeferWindowPosAsync(hwndSS);\r\n    LastWin.hwnd = NULL;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Just used in Enum\r\nstatic void EnumMdi()\r\n{\r\n    // Make sure we have enough space allocated\r\n    monitors = (RECT *)GetEnoughSpace(monitors, nummonitors, &monitors_alloc, sizeof(RECT));\r\n    if (!monitors) return; // Fail\r\n\r\n    // Add MDIClient as the monitor\r\n    nummonitors = !!GetClientRect(state.mdiclient, &monitors[0]);\r\n\r\n    if (state.snap > 1) {\r\n        EnumChildWindows(state.mdiclient, EnumWindowsProc, 0);\r\n    }\r\n    if (conf.StickyResize) {\r\n        EnumChildWindows(state.mdiclient, EnumTouchingWindows, 0);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Enumerate all monitors/windows/MDI depending on state.\r\nstatic void Enum()\r\n{\r\n    nummonitors = 0;\r\n    numwnds = 0;\r\n    numsnwnds = 0;\r\n\r\n    // MDI\r\n    if (state.mdiclient && IsWindow(state.mdiclient)) {\r\n        EnumMdi();\r\n        return;\r\n    }\r\n\r\n    // Enumerate monitors\r\n    EnumDisplayMonitors(NULL, NULL, EnumMonitorsProc, 0);\r\n\r\n    // Enumerate windows\r\n    if (state.snap >= 2) {\r\n        EnumDesktopWindows(NULL, EnumWindowsProc, 0);\r\n    }\r\n\r\n    if (conf.StickyResize) {\r\n        EnumDesktopWindows(NULL, EnumTouchingWindows, 0);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n#define RECALC_INVISIBLE_BORDERS ((RECT **)1)\r\nstatic void EnumOnce(RECT **bd)\r\n{\r\n    static RECT borders;\r\n    if (bd == RECALC_INVISIBLE_BORDERS) {\r\n        FixDWMRect(state.hwnd, &borders);\r\n        return;\r\n    }\r\n    if (bd && !(state.enumed&1)) {\r\n        // LOGA(\"Enum\");\r\n        Enum(); // Enumerate monitors and windows\r\n        FixDWMRect(state.hwnd, &borders);\r\n        state.enumed |= 1;\r\n        *bd = &borders;\r\n    } else if (bd && state.enumed) {\r\n        *bd = &borders;\r\n\r\n    }\r\n}\r\nstatic void EnumSnappedOnce()\r\n{\r\n    if (!(state.enumed&2)) {\r\n        // LOGA(\"EnumSnapped\");\r\n        EnumSnapped();\r\n        state.enumed |= 2;\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid MoveSnap(int *_posx, int *_posy, int wndwidth, int wndheight, UCHAR pth)\r\n{\r\n    RECT *bd;\r\n    if (!state.snap || state.Speed > conf.AeroMaxSpeed) return;\r\n    EnumOnce(&bd);\r\n\r\n    int posx = *_posx + bd->left;\r\n    int posy = *_posy + bd->top;\r\n    wndwidth  -= bd->left + bd->right;\r\n    wndheight -= bd->top + bd->bottom;\r\n\r\n    // thresholdx and thresholdy will shrink to make sure\r\n    // the dragged window will snap to the closest windows\r\n    int stickx=0, sticky=0;\r\n    short thresholdx, thresholdy;\r\n    UCHAR stuckx=0, stucky=0;\r\n    thresholdx = thresholdy = pth; // conf.SnapThreshold;\r\n\r\n    // Loop monitors and windows\r\n    unsigned i, j;\r\n    for (i=0, j=0; i < nummonitors || j < numwnds; ) {\r\n        RECT snapwnd;\r\n        UCHAR snapinside=0;\r\n\r\n        // Get snapwnd\r\n        if (monitors && i < nummonitors) {\r\n            snapwnd = monitors[i];\r\n            snapinside = 1;\r\n            i++;\r\n        } else if (wnds && j < numwnds) {\r\n            snapwnd = wnds[j];\r\n            snapinside = (state.snap != 2);\r\n            j++;\r\n        } else {\r\n            // No monitors and no windows to snap to.\r\n            return;\r\n        }\r\n\r\n        // Check if posx snaps\r\n        if (IsInRangeT(posy, snapwnd.top, snapwnd.bottom, thresholdx)\r\n        ||  IsInRangeT(snapwnd.top, posy, posy+wndheight, thresholdx)) {\r\n            UCHAR snapinside_cond = (snapinside\r\n                                  || posy + wndheight - thresholdx < snapwnd.top\r\n                                  || snapwnd.bottom < posy + thresholdx);\r\n            if (IsEqualT(snapwnd.right, posx, thresholdx)) {\r\n                // The left edge of the dragged window will snap to this window's right edge\r\n                stuckx = 1;\r\n                stickx = snapwnd.right;\r\n                thresholdx = snapwnd.right-posx;\r\n            } else if (snapinside_cond && IsEqualT(snapwnd.right, posx+wndwidth, thresholdx)) {\r\n                // The right edge of the dragged window will snap to this window's right edge\r\n                stuckx = 1;\r\n                stickx = snapwnd.right - wndwidth;\r\n                thresholdx = snapwnd.right-(posx+wndwidth);\r\n            } else if (snapinside_cond && IsEqualT(snapwnd.left, posx, thresholdx)) {\r\n                // The left edge of the dragged window will snap to this window's left edge\r\n                stuckx = 1;\r\n                stickx = snapwnd.left;\r\n                thresholdx = snapwnd.left-posx;\r\n            } else if (IsEqualT(snapwnd.left, posx+wndwidth, thresholdx)) {\r\n                // The right edge of the dragged window will snap to this window's left edge\r\n                stuckx = 1;\r\n                stickx = snapwnd.left - wndwidth;\r\n                thresholdx = snapwnd.left-(posx+wndwidth);\r\n            }\r\n        }// end if posx snaps\r\n\r\n        // Check if posy snaps\r\n        if (IsInRangeT(posx, snapwnd.left, snapwnd.right, thresholdy)\r\n        ||  IsInRangeT(snapwnd.left, posx, posx+wndwidth, thresholdy)) {\r\n            UCHAR snapinside_cond = (snapinside || posx + wndwidth - thresholdy < snapwnd.left\r\n                                  || snapwnd.right < posx+thresholdy);\r\n            if (IsEqualT(snapwnd.bottom, posy, thresholdy)) {\r\n                // The top edge of the dragged window will snap to this window's bottom edge\r\n                stucky = 1;\r\n                sticky = snapwnd.bottom;\r\n                thresholdy = snapwnd.bottom-posy;\r\n            } else if (snapinside_cond && IsEqualT(snapwnd.bottom, posy+wndheight, thresholdy)) {\r\n                // The bottom edge of the dragged window will snap to this window's bottom edge\r\n                stucky = 1;\r\n                sticky = snapwnd.bottom - wndheight;\r\n                thresholdy = snapwnd.bottom-(posy+wndheight);\r\n            } else if (snapinside_cond && IsEqualT(snapwnd.top, posy, thresholdy)) {\r\n                // The top edge of the dragged window will snap to this window's top edge\r\n                stucky = 1;\r\n                sticky = snapwnd.top;\r\n                thresholdy = snapwnd.top-posy;\r\n            } else if (IsEqualT(snapwnd.top, posy+wndheight, thresholdy)) {\r\n                // The bottom edge of the dragged window will snap to this window's top edge\r\n                stucky = 1;\r\n                sticky = snapwnd.top-wndheight;\r\n                thresholdy = snapwnd.top-(posy+wndheight);\r\n            }\r\n        } // end if posy snaps\r\n    } // end for\r\n\r\n    // Update posx and posy\r\n    if (stuckx) {\r\n        *_posx = stickx - bd->left;\r\n    }\r\n    if (stucky) {\r\n        *_posy = sticky - bd->top;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void ResizeSnap(int *posx, int *posy, int *wndwidth, int *wndheight, UCHAR pthx, UCHAR pthy)\r\n{\r\n    if(!state.snap || state.Speed > conf.AeroMaxSpeed) return;\r\n\r\n    // thresholdx and thresholdy will shrink to make sure\r\n    // the dragged window will snap to the closest windows\r\n    short thresholdx, thresholdy;\r\n    UCHAR stuckleft=0, stucktop=0, stuckright=0, stuckbottom=0;\r\n    int stickleft=0, sticktop=0, stickright=0, stickbottom=0;\r\n    thresholdx = pthx;\r\n    thresholdy = pthy;\r\n    RECT *borders;\r\n    EnumOnce(&borders);\r\n\r\n    // Loop monitors and windows\r\n    unsigned i, j;\r\n    for (i=0, j=0; i < nummonitors || j < numwnds;) {\r\n        RECT snapwnd;\r\n        UCHAR snapinside;\r\n\r\n        // Get snapwnd\r\n        if (monitors && i < nummonitors) {\r\n            CopyRect(&snapwnd, &monitors[i]);\r\n            snapinside = 1;\r\n            i++;\r\n        } else if (wnds && j < numwnds) {\r\n            CopyRect(&snapwnd, &wnds[j]);\r\n            snapinside = (state.snap != 2);\r\n            j++;\r\n        } else {\r\n            // nothing to snap to.\r\n            return;\r\n        }\r\n\r\n        // Check if posx snaps\r\n        if (IsInRangeT(*posy, snapwnd.top, snapwnd.bottom, thresholdx)\r\n         || IsInRangeT(snapwnd.top, *posy, *posy + *wndheight, thresholdx)) {\r\n\r\n            UCHAR snapinside_cond =  snapinside\r\n                                 || (*posy+*wndheight-thresholdx < snapwnd.top)\r\n                                 || (snapwnd.bottom < *posy+thresholdx) ;\r\n            if (state.resize.x == RZ_LEFT\r\n            && IsEqualT(snapwnd.right, *posx, thresholdx)) {\r\n                // The left edge of the dragged window will snap to this window's right edge\r\n                stuckleft = 1;\r\n                stickleft = snapwnd.right;\r\n                thresholdx = snapwnd.right - *posx;\r\n            } else if (snapinside_cond && state.resize.x == RZ_RIGHT\r\n            && IsEqualT(snapwnd.right, *posx+*wndwidth, thresholdx)) {\r\n                // The right edge of the dragged window will snap to this window's right edge\r\n                stuckright = 1;\r\n                stickright = snapwnd.right;\r\n                thresholdx = snapwnd.right - (*posx + *wndwidth);\r\n            } else if (snapinside_cond && state.resize.x == RZ_LEFT\r\n            && IsEqualT(snapwnd.left, *posx, thresholdx)) {\r\n                // The left edge of the dragged window will snap to this window's left edge\r\n                stuckleft = 1;\r\n                stickleft = snapwnd.left;\r\n                thresholdx = snapwnd.left-*posx;\r\n            } else if (state.resize.x == RZ_RIGHT\r\n            && IsEqualT(snapwnd.left, *posx + *wndwidth, thresholdx)) {\r\n                // The right edge of the dragged window will snap to this window's left edge\r\n                stuckright = 1;\r\n                stickright = snapwnd.left;\r\n                thresholdx = snapwnd.left - (*posx + *wndwidth);\r\n            }\r\n        }\r\n\r\n        // Check if posy snaps\r\n        if (IsInRangeT(*posx, snapwnd.left, snapwnd.right, thresholdy)\r\n         || IsInRangeT(snapwnd.left, *posx, *posx+*wndwidth, thresholdy)) {\r\n\r\n            UCHAR snapinside_cond = snapinside\r\n                                 || (*posx+*wndwidth-thresholdy < snapwnd.left)\r\n                                 || (snapwnd.right < *posx+thresholdy) ;\r\n            if (state.resize.y == RZ_TOP\r\n            && IsEqualT(snapwnd.bottom, *posy, thresholdy)) {\r\n                // The top edge of the dragged window will snap to this window's bottom edge\r\n                stucktop = 1;\r\n                sticktop = snapwnd.bottom;\r\n                thresholdy = snapwnd.bottom-*posy;\r\n            } else if (snapinside_cond && state.resize.y == RZ_BOTTOM\r\n            && IsEqualT(snapwnd.bottom, *posy + *wndheight, thresholdy)) {\r\n                // The bottom edge of the dragged window will snap to this window's bottom edge\r\n                stuckbottom = 1;\r\n                stickbottom = snapwnd.bottom;\r\n                thresholdy = snapwnd.bottom-(*posy+*wndheight);\r\n            } else if (snapinside_cond && state.resize.y == RZ_TOP\r\n            && IsEqualT(snapwnd.top, *posy, thresholdy)) {\r\n                // The top edge of the dragged window will snap to this window's top edge\r\n                stucktop = 1;\r\n                sticktop = snapwnd.top;\r\n                thresholdy = snapwnd.top-*posy;\r\n            } else if (state.resize.y == RZ_BOTTOM\r\n            && IsEqualT(snapwnd.top, *posy+*wndheight, thresholdy)) {\r\n                // The bottom edge of the dragged window will snap to this window's top edge\r\n                stuckbottom = 1;\r\n                stickbottom = snapwnd.top;\r\n                thresholdy = snapwnd.top-(*posy+*wndheight);\r\n            }\r\n        }\r\n    } // end for\r\n\r\n    // Update posx, posy, wndwidth and wndheight\r\n    if (stuckleft) {\r\n        *wndwidth = *wndwidth+*posx-stickleft + borders->left;\r\n        *posx = stickleft - borders->left;\r\n    }\r\n    if (stucktop) {\r\n        *wndheight = *wndheight+*posy-sticktop + borders->top;\r\n        *posy = sticktop - borders->top;\r\n    }\r\n    if (stuckright) {\r\n        *wndwidth = stickright-*posx + borders->right;\r\n    }\r\n    if (stuckbottom) {\r\n        *wndheight = stickbottom-*posy + borders->bottom;\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Call with SW_MAXIMIZE or SW_RESTORE or below.\r\n// Set origin&1 to set the restore position to the original dimentions\r\n// set origin&2 for ASYNC window plamcemnt\r\n#define SW_FULLSCREEN 28\r\nstatic void MaximizeRestore_atpt(HWND hwnd, UINT sw_cmd, int origin)\r\n{\r\n    WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n    GetWindowPlacement(hwnd, &wndpl);\r\n    if (sw_cmd != SW_FULLSCREEN)\r\n        wndpl.showCmd = sw_cmd;\r\n\r\n    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n    if(sw_cmd == SW_MAXIMIZE || sw_cmd == SW_FULLSCREEN) {\r\n        HMONITOR wndmonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\r\n        HMONITOR monitor = MonitorFromPoint(state.prevpt, MONITOR_DEFAULTTONEAREST);\r\n\r\n        if (origin&1) {\r\n            // set normal windpw plasement to origin.\r\n            wndpl.rcNormalPosition.right = wndpl.rcNormalPosition.left + state.origin.width;\r\n            wndpl.rcNormalPosition.bottom = wndpl.rcNormalPosition.top + state.origin.height;\r\n        }\r\n\r\n        GetMonitorInfo(monitor, &mi);\r\n\r\n        // Center window on monitor, if needed\r\n        if (monitor != wndmonitor) {\r\n            CenterRectInRect(&wndpl.rcNormalPosition, &mi.rcWork);\r\n        }\r\n    }\r\n    if (origin&2) wndpl.flags |= WPF_ASYNCWINDOWPLACEMENT;\r\n    SetWindowPlacement(hwnd, &wndpl);\r\n    if (sw_cmd == SW_FULLSCREEN) {\r\n        MoveWindowAsync(hwnd, mi.rcMonitor.left , mi.rcMonitor.top\r\n                      , mi.rcMonitor.right-mi.rcMonitor.left\r\n                      , mi.rcMonitor.bottom-mi.rcMonitor.top);\r\n    }\r\n}\r\n\r\nstatic void MoveWindowAsync1(HWND hwnd, int x, int y, int w, int h)\r\n{\r\n    UINT flags = SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_ASYNCWINDOWPOS;\r\n    if (conf.IgnoreMinMaxInfo) flags |= SWP_NOSENDCHANGING;\r\n    SetWindowPos(hwnd, NULL, x, y, w, h, flags);\r\n}\r\nstatic void RestoreWindowToRect(HWND hwnd, const RECT *rc, UINT flags)\r\n{\r\n    RECT zbd, bd;\r\n    FixDWMRect(hwnd, &zbd); // Zoomed invisible borders (that were applied)\r\n    WINDOWPLACEMENT wndpl; wndpl.length = sizeof(WINDOWPLACEMENT);\r\n    GetWindowPlacement(hwnd, &wndpl);\r\n    wndpl.showCmd = SW_RESTORE;\r\n    wndpl.flags |= flags;\r\n    CopyRect(&wndpl.rcNormalPosition, rc);\r\n    if (LOBYTE(GetVersion()) >= 10) {\r\n        // On Windows 10+ we got invisible borders...\r\n        wndpl.flags &= ~WPF_ASYNCWINDOWPLACEMENT;\r\n        // Synchronus restore because we have to check for Invisible\r\n        // borders again that are different when Zoomed/restored.\r\n        SetWindowPlacement(hwnd, &wndpl);\r\n        FixDWMRect(hwnd, &bd); // Restored invisible borders\r\n        if( !EqualRect(&zbd, &bd) ) {\r\n            // Wrong invisible borders were applied,\r\n            // correct it with an async move.\r\n            #define r wndpl.rcNormalPosition\r\n            DeflateRectBorder(&r, &zbd);\r\n            InflateRectBorder(&r, &bd);\r\n            MoveWindowAsync1(hwnd, r.left, r.top, r.right-r.left, r.bottom-r.top);\r\n            #undef r\r\n        }\r\n    } else {\r\n        SetWindowPlacement(hwnd, &wndpl);\r\n    }\r\n}\r\nstatic void RestoreWindowTo(HWND hwnd, int x, int y, int w, int h)\r\n{\r\n    RECT rc = {x, y, x+w, y+h };\r\n    RestoreWindowToRect(hwnd, &rc, 0);\r\n}\r\n/* Helper function to call SetWindowPos with the SWP_ASYNCWINDOWPOS flag\r\n * Also restores the window if needed.\r\n * Note that WPF_ASYNCWINDOWPLACEMENT was introduced with Windows 2000\r\n * but it seems not to be a problem for NT4, so it can be kept here. */\r\nstatic void MoveWindowAsync(HWND hwnd, int x, int y, int w, int h)\r\n{\r\n    if (IsZoomed(hwnd) || IsWindowSnapped(hwnd)) {\r\n        RECT rc = {x, y, x+w, y+h };\r\n        RestoreWindowToRect(hwnd, &rc, WPF_ASYNCWINDOWPLACEMENT);\r\n    } else {\r\n        MoveWindowAsync1(hwnd, x, y, w, h);\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Move the windows in a thread in case it is very slow to resize\r\nstatic void MoveResizeWindowThread(struct windowRR *lw, UINT flag)\r\n{\r\n    HWND hwnd;\r\n    hwnd = lw->hwnd;\r\n\r\n    if (lw->end && conf.FullWin) Sleep(8); // At the End of movement...\r\n\r\n\r\n    // Send WM_ENTERSIZEMOVE and EVENT_SYSTEM_MOVESIZESTART\r\n    if (lw->start)\r\n        NotifySizeMoveStaEnd(hwnd, 1); // Once darg actually starts.\r\n\r\n\r\n    if (lw->end && !lw->maximize && (IsZoomed(hwnd) || IsWindowSnapped(hwnd))) {\r\n        // Use Restore\r\n        RestoreWindowTo(hwnd, lw->x, lw->y, lw->width, lw->height);\r\n    } else {\r\n//        PostMessage(hwnd, WM_MOUSEMOVE, MK_LBUTTON, MAKELPARAM(state.prevpt.x, state.prevpt.y));\r\n//        if(!(flag&SWP_NOSIZE)) {\r\n//            RECT rc = { lw->x, lw->y, lw->x + lw->width, lw->y + lw->height };\r\n//            SendMessage(hwnd, WM_SIZING, WMSZ_BOTTOMRIGHT, (LPARAM)&rc);\r\n//        }\r\n        SetWindowPos(hwnd, NULL, lw->x, lw->y, lw->width, lw->height, flag);\r\n\r\n        // Send WM_SYNCPAINT in case to wait for the end of movement\r\n        // And to avoid windows to \"slide through\" the whole WM_MOVE queue\r\n        if(flag&SWP_ASYNCWINDOWPOS) SendMessage(hwnd, WM_SYNCPAINT, 0, 0);\r\n        if (conf.RefreshRate) ASleep(conf.RefreshRate); // Accurate!!!\r\n    }\r\n\r\n    if (lw->end && !conf.FullWin)\r\n        NotifySizeMoveStaEnd(hwnd, 0);\r\n\r\n    lw->hwnd = NULL;\r\n    lw->end = 0;\r\n    lw->start = 0;\r\n}\r\n\r\n/* MOVEASYNC |SWP_DEFERERASE ??*/\r\n#define RESIZEFLAG        SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE\r\n#define MOVETHICKBORDERS  SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE|SWP_NOSIZE\r\n#define MOVEASYNC         SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE|SWP_NOSIZE|SWP_ASYNCWINDOWPOS\r\nstatic DWORD WINAPI MoveWindowThread(LPVOID LastWinV)\r\n{\r\n    struct windowRR *lw = (struct windowRR *)LastWinV;\r\n//    RECT rc;\r\n//    int notsamesize = 0;\r\n//    if (GetWindowRect(lw->hwnd, &rc)) {\r\n//        int cW = rc.right - rc.left;\r\n//        int cH = rc.bottom - rc.top;\r\n//        UINT cdpi = GetDpiForWindow(lw->hwnd);\r\n//        if ( cdpi && cdpi != lw->odpi ) {\r\n//            // If dpi is not the same we must check the *scaled* values.\r\n//            if (cW == lw->width && cH == lw->height)\r\n//                // Window had no time to resize between monitors?\r\n//                notsamesize = 0;\r\n//            else\r\n//                notsamesize = (cW * lw->odpi)>>3 != (lw->width  * cdpi)>>3\r\n//                       || (cH * lw->odpi)>>3 != (lw->height * cdpi)>>3;\r\n//        } else {\r\n//            notsamesize =  cW != lw->width ||  cH != lw->height;\r\n//        }\r\n//        //LOGA(\"MV: %d:%d/%d -> %d:%d/%d %s\", cW, cH, cdpi , lw->width, lw->height, lw->odpi, notsamesize?\"(dif)\":\"(eq)\");\r\n//    }\r\n//    UINT flag = notsamesize? RESIZEFLAG: state.resizable&2 ? MOVETHICKBORDERS: MOVEASYNC;\r\n    int notsamesize = 1;\r\n    int nothingtodo = 0;\r\n    RECT rc;\r\n    if (conf.FullWin) {\r\n        notsamesize = !lw->moveonly;\r\n        if ( lw->odpi == GetDpiForWindow(lw->hwnd)\r\n        && GetWindowRect(lw->hwnd, &rc) ) {\r\n            int cW = rc.right - rc.left;\r\n            int cH = rc.bottom - rc.top;\r\n            nothingtodo =  rc.left == lw->x && rc.top == lw->y\r\n                        && cW == lw->width &&  cH == lw->height;\r\n        }\r\n\r\n    } else {\r\n        // Hollow rectangle mode.\r\n        if( GetWindowRect(lw->hwnd, &rc) ) {\r\n            int cW = rc.right - rc.left;\r\n            int cH = rc.bottom - rc.top;\r\n            notsamesize =  cW != lw->width ||  cH != lw->height;\r\n        }\r\n    }\r\n\r\n    UINT flag = notsamesize? RESIZEFLAG: state.resizable&2 ? MOVETHICKBORDERS: MOVEASYNC;\r\n    if (conf.IgnoreMinMaxInfo) flag |= SWP_NOSENDCHANGING;\r\n\r\n    if (nothingtodo)\r\n        lw->hwnd = NULL; // DONE!\r\n    else\r\n        MoveResizeWindowThread(lw, flag);\r\n\r\n    return 0;\r\n}\r\n#undef RESIZEFLAG\r\n#undef MOVETHICKBORDERS\r\n#undef MOVEASYNC\r\n\r\nstatic void MoveWindowInThread(struct windowRR *lw)\r\n{\r\n    DWORD lpThreadId;\r\n    CloseHandle(\r\n        CreateThread( NULL, STACK\r\n            , MoveWindowThread\r\n            , lw, STACK_SIZE_PARAM_IS_A_RESERVATION, &lpThreadId)\r\n    );\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// use snwnds[numsnwnds].wnd / .flag\r\nstatic void GetAeroSnappingMetrics(int *leftWidth, int *rightWidth, int *topHeight, int *bottomHeight, const RECT *mon)\r\n{\r\n    *leftWidth    = CLAMPW((mon->right - mon->left)* conf.AHoff     /100);\r\n    *rightWidth   = CLAMPW((mon->right - mon->left)*(100-conf.AHoff)/100);\r\n    *topHeight    = CLAMPH((mon->bottom - mon->top)* conf.AVoff     /100);\r\n    *bottomHeight = CLAMPH((mon->bottom - mon->top)*(100-conf.AVoff)/100);\r\n\r\n    // do not go further is snapping state is toggled or shift is down.\r\n    if (state.snap != conf.AutoSnap) return;\r\n    EnumSnappedOnce();\r\n\r\n    // Check on all the other snapped windows from the bottom most\r\n    // To give precedence to the topmost windows\r\n    unsigned i = numsnwnds;\r\n    while (i--) {\r\n        unsigned flag = snwnds[i].flag;\r\n        const RECT *wnd = &snwnds[i].wnd;\r\n        // if the window is in current monitor\r\n        POINT tpt;\r\n        tpt.x = (wnd->left+wnd->right)/2;\r\n        tpt.y = (wnd->top+wnd->bottom)/2 ;\r\n        if (PtInRect(mon, tpt)) {\r\n            // We have a snapped window in the monitor\r\n            if (flag & SNLEFT) {\r\n                *leftWidth  = CLAMPW(wnd->right - wnd->left);\r\n                *rightWidth = CLAMPW(mon->right - wnd->right);\r\n            } else if (flag & SNRIGHT) {\r\n                *rightWidth = CLAMPW(wnd->right - wnd->left);\r\n                *leftWidth  = CLAMPW(wnd->left - mon->left);\r\n            }\r\n            if (flag & SNTOP) {\r\n                *topHeight    = CLAMPH(wnd->bottom - wnd->top);\r\n                *bottomHeight = CLAMPH(mon->bottom - wnd->bottom);\r\n            } else if (flag & SNBOTTOM) {\r\n                *bottomHeight = CLAMPH(wnd->bottom - wnd->top);\r\n                *topHeight    = CLAMPH(wnd->top - mon->top);\r\n            }\r\n        }\r\n    } // next i\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void GetMonitorRect(const POINT *pt, int full, RECT *_mon)\r\n{\r\n    if (state.mdiclient\r\n    && GetClientRect(state.mdiclient, _mon)) {\r\n        return; // MDI!\r\n    }\r\n\r\n    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n    GetMonitorInfo(MonitorFromPoint(*pt, MONITOR_DEFAULTTONEAREST), &mi);\r\n\r\n    CopyRect(_mon, full? &mi.rcMonitor : &mi.rcWork);\r\n}\r\n/////////////////////////////////////////////////////////////////////////\r\n// also return monitor's DPI\r\n//static UINT GetDPIMonitorRect(const POINT *pt, int full, RECT *_mon)\r\n//{\r\n//    UINT dpi = 0;\r\n//    if (state.mdiclient\r\n//    && GetClientRect(state.mdiclient, _mon)) {\r\n//        return GetDpiForWindow(state.mdiclient); // MDI!\r\n//    }\r\n//\r\n//    HMONITOR hmon = MonitorFromPoint(*pt, MONITOR_DEFAULTTONEAREST);\r\n//    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n//    GetMonitorInfo(hmon, &mi);\r\n//\r\n//    UINT dpiX, dpiY;\r\n//    if(S_OK == GetDpiForMonitorL(hmon, MDT_DEFAULT, &dpiX, &dpiY)) {\r\n//        dpi = dpiX;\r\n//    }\r\n//\r\n//    CopyRect(_mon, full? &mi.rcMonitor : &mi.rcWork);\r\n//    return dpi;\r\n//}\r\n\r\nstatic void WaitMovementEnd()\r\n{ // Only wait 64ms maximum\r\n    if (conf.FullWin) {\r\n        int i=0;\r\n        while (LastWin.hwnd && i++ < 4) Sleep(16);\r\n    }\r\n    LastWin.hwnd = NULL; // Zero out in case.\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n#define AERO_TH conf.AeroThreshold\r\n#define MM_THREAD_ON (LastWin.hwnd && conf.FullWin)\r\nstatic int AeroMoveSnap(POINT pt, int *posx, int *posy, int *wndwidth, int *wndheight)\r\n{\r\n    // return if last resizing is not finished or no Aero or not resizable.\r\n    if((!conf.Aero && !(conf.UseZones&1)) || !state.resizable) return 0;\r\n\r\n    LastWin.maximize = 0;\r\n    LastWin.snap = 0;\r\n\r\n    // We HAVE to check the monitor for each pt...\r\n    RECT mon;\r\n    GetMonitorRect(&pt, 0, &mon);\r\n\r\n    int pLeft  = mon.left   + AERO_TH ;\r\n    int pRight = mon.right  - AERO_TH ;\r\n    int pTop   = mon.top    + AERO_TH ;\r\n    int pBottom= mon.bottom - AERO_TH ;\r\n    int leftWidth, rightWidth, topHeight, bottomHeight;\r\n\r\n    int Left  = pLeft   + AERO_TH ;\r\n    int Right = pRight  - AERO_TH ;\r\n    int Top   = pTop    + AERO_TH ;\r\n    int Bottom= pBottom - AERO_TH ;\r\n\r\n    unsigned restore = GetRestoreFlag(state.hwnd);\r\n    RECT trc;\r\n    trc.left = pLeft; trc.top = pTop;\r\n    trc.right = pRight; trc.bottom =pBottom;\r\n    if (PtInRect(&trc, pt) || !conf.Aero) goto restore;\r\n\r\n    GetAeroSnappingMetrics(&leftWidth, &rightWidth, &topHeight, &bottomHeight, &mon);\r\n    LastWin.moveonly = 0; // We shall snap!\r\n    // Move window\r\n    if (pt.y < Top && pt.x < Left) {\r\n        // Top left\r\n        restore = SNAPPED|SNTOPLEFT;\r\n        *wndwidth =  leftWidth;\r\n        *wndheight = topHeight;\r\n        *posx = mon.left;\r\n        *posy = mon.top;\r\n    } else if (pt.y < Top && Right < pt.x) {\r\n        // Top right\r\n        restore = SNAPPED|SNTOPRIGHT;\r\n        *wndwidth = rightWidth;\r\n        *wndheight = topHeight;\r\n        *posx = mon.right-*wndwidth;\r\n        *posy = mon.top;\r\n    } else if (Bottom < pt.y && pt.x < Left) {\r\n        // Bottom left\r\n        restore = SNAPPED|SNBOTTOMLEFT;\r\n        *wndwidth = leftWidth;\r\n        *wndheight = bottomHeight;\r\n        *posx = mon.left;\r\n        *posy = mon.bottom - *wndheight;\r\n    } else if (Bottom < pt.y && Right < pt.x) {\r\n        // Bottom right\r\n        restore = SNAPPED|SNBOTTOMRIGHT;\r\n        *wndwidth = rightWidth;\r\n        *wndheight= bottomHeight;\r\n        *posx = mon.right - *wndwidth;\r\n        *posy = mon.bottom - *wndheight;\r\n    } else if (pt.y < pTop) {\r\n        // Pure Top\r\n        if (!state.shift ^ !(conf.AeroTopMaximizes&1)\r\n        && (state.Speed < conf.AeroMaxSpeed)) {\r\n             if (conf.FullWin) {\r\n                MaximizeRestore_atpt(state.hwnd, SW_MAXIMIZE, 1);\r\n                LastWin.hwnd = NULL;\r\n                state.moving = 2;\r\n                return 1;\r\n            } else {\r\n                *posx = mon.left;\r\n                *posy = mon.top;\r\n                *wndwidth = CLAMPW(mon.right - mon.left);\r\n                *wndheight = CLAMPH( mon.bottom-mon.top );\r\n                LastWin.maximize = 1;\r\n                SetRestoreFlag(state.hwnd, SNAPPED|SNCLEAR); // To clear eventual snapping info\r\n                return 0;\r\n            }\r\n        } else {\r\n            restore = SNAPPED|SNTOP;\r\n            *wndwidth = CLAMPW(mon.right - mon.left);\r\n            *wndheight = topHeight;\r\n            *posx = mon.left + (mon.right-mon.left)/2 - *wndwidth/2; // Center\r\n            *posy = mon.top;\r\n        }\r\n    } else if (pt.y > pBottom) {\r\n        // Pure Bottom\r\n        restore = SNAPPED|SNBOTTOM;\r\n        *wndwidth  = CLAMPW( mon.right-mon.left);\r\n        *wndheight = bottomHeight;\r\n        *posx = mon.left + (mon.right-mon.left)/2 - *wndwidth/2; // Center\r\n        *posy = mon.bottom - *wndheight;\r\n    } else if (pt.x < pLeft) {\r\n        // Pure Left\r\n        restore = SNAPPED|SNLEFT;\r\n        *wndwidth = leftWidth;\r\n        *wndheight = CLAMPH( mon.bottom-mon.top );\r\n        *posx = mon.left;\r\n        *posy = mon.top + (mon.bottom-mon.top)/2 - *wndheight/2; // Center\r\n    } else if (pt.x > pRight) {\r\n        // Pure Right\r\n        restore = SNAPPED|SNRIGHT;\r\n        *wndwidth =  rightWidth;\r\n        *wndheight = CLAMPH( mon.bottom-mon.top );\r\n        *posx = mon.right - *wndwidth;\r\n        *posy = mon.top + (mon.bottom-mon.top)/2 - *wndheight/2; // Center\r\n    } else {\r\n        restore:\r\n        if (restore&SNAPPED && !MM_THREAD_ON) {\r\n            // Restore original window size\r\n            // Clear restore data at the end of the movement\r\n            LastWin.moveonly = 0;\r\n            SetRestoreFlag(state.hwnd, restore|SNCLEAR);\r\n            restore = 0;\r\n            *wndwidth = state.origin.width;\r\n            *wndheight = state.origin.height;\r\n        }\r\n    }\r\n\r\n    // Aero-move the window?\r\n    if (restore&SNAPPED) {\r\n        *wndwidth  = CLAMPW(*wndwidth);\r\n        *wndheight = CLAMPH(*wndheight);\r\n\r\n        SetRestoreData(state.hwnd, state.origin.width, state.origin.height, restore);\r\n\r\n        RECT borders;\r\n        FixDWMRect(state.hwnd, &borders);\r\n        *posx -= borders.left;\r\n        *posy -= borders.top;\r\n        *wndwidth += borders.left+borders.right;\r\n        *wndheight+= borders.top+borders.bottom;\r\n\r\n        // If we go too fast then do not move the window\r\n        if (state.Speed > conf.AeroMaxSpeed) return 1;\r\n        LastWin.moveonly = 0;\r\n        if (conf.FullWin) {\r\n            if (IsZoomed(state.hwnd)) {\r\n                // Avoids flickering\r\n                RestoreWindowTo(state.hwnd, *posx, *posy, *wndwidth, *wndheight);\r\n                EnumOnce(RECALC_INVISIBLE_BORDERS);\r\n            }\r\n            int mmthreadend = !LastWin.hwnd;\r\n            LastWin.hwnd = state.hwnd;\r\n            LastWin.x = *posx;\r\n            LastWin.y = *posy;\r\n            LastWin.width = *wndwidth;\r\n            LastWin.height = *wndheight;\r\n            LastWin.snap = 1;\r\n            if (mmthreadend) {\r\n                MoveWindowInThread(&LastWin);\r\n                return 1;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void AeroResizeSnap(POINT pt, int *posx, int *posy, int *wndwidth, int *wndheight)\r\n{\r\n    // return if last resizing is not finished\r\n    if(!conf.Aero || MM_THREAD_ON || state.Speed > conf.AeroMaxSpeed)\r\n        return;\r\n\r\n    static RECT borders;\r\n    if(!state.moving) {\r\n        FixDWMRect(state.hwnd, &borders);\r\n    }\r\n    unsigned restore = GetRestoreFlag(state.hwnd);\r\n    if (state.resize.x == RZ_XCENTER && state.resize.y == RZ_TOP && pt.y < state.origin.mon.top + AERO_TH) {\r\n        restore = SNAPPED|SNMAXH;\r\n        *wndheight = CLAMPH(state.origin.mon.bottom - state.origin.mon.top + borders.bottom + borders.top);\r\n        *posy = state.origin.mon.top - borders.top;\r\n    } else if (state.resize.x == RZ_LEFT && state.resize.y == RZ_YCENTER && pt.x < state.origin.mon.left + AERO_TH) {\r\n        restore = SNAPPED|SNMAXW;\r\n        *wndwidth = CLAMPW(state.origin.mon.right - state.origin.mon.left + borders.left + borders.right);\r\n        *posx = state.origin.mon.left - borders.left;\r\n    }\r\n    // Aero-move the window?\r\n    if (restore&SNAPPED && restore&(SNMAXH|SNMAXW)) {\r\n        SetRestoreData(state.hwnd, state.origin.width, state.origin.height, restore);\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void HideCursor()\r\n{\r\n    // Reduce the size to 0 to avoid redrawing.\r\n    SetWindowPos(g_mainhwnd, NULL, 0,0,0,0\r\n        , SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOREDRAW|SWP_DEFERERASE);\r\n    ShowWindow(g_mainhwnd, SW_HIDE);\r\n}\r\nstatic pure int IsAKeyDown(const UCHAR *k)\r\n{\r\n    while (*k) {\r\n        if(GetKeyState(*k++)&0x8000)\r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Mod Key can return 0 or 1, maybe more in the future...\r\nstatic pure int ModKey()\r\n{\r\n    return conf.ModKey[0]\r\n        && IsAKeyDown(conf.ModKey);\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Get action of button\r\nstatic enum action GetAction(const int button)\r\n{\r\n    if (button) { // Ugly pointer arithmetic (LMB <==> button == 2)\r\n        return conf.Mouse.LMB[(button-2)*NACPB+ModKey()];\r\n    } else {\r\n        return AC_NONE;\r\n    }\r\n}\r\nstatic enum action GetActionT(const int button)\r\n{\r\n    if (button) { // Ugly pointer arithmetic +2 compared to non titlebar\r\n        return conf.Mouse.LMB[2+(button-2)*NACPB+ModKey()];\r\n    } else {\r\n        return AC_NONE;\r\n    }\r\n}\r\nstatic enum action GetActionMR(const int button)\r\n{\r\n    if (button) {\r\n        // Ugly pointer arithmetic\r\n        // state.action == 1 or 2\r\n        // MB[4/5] == Action/Alt while moving\r\n        // MB[6/7] == Action/Alt while Resizing\r\n        int offset = state.action<<1; // 2 or 4\r\n        return conf.Mouse.LMB[2+offset+(button-2)*NACPB+ModKey()];\r\n    } else {\r\n        return AC_NONE;\r\n    }\r\n}\r\n#define IsHotkey(a)   IsHotkeyy(a, conf.Hotkeys)\r\n#define IsHotclick(a) IsHotkeyy(a, conf.Hotclick)\r\nstatic int pure IsKillkey(unsigned char a)\r\n{\r\n    return\r\n        (0x41 <= a && a <= 0x5A) // A-Z vkeys\r\n        || IsHotkeyy(a, conf.Killkey) ;\r\n}\r\nstatic xpure int IsModKey(const UCHAR vkey)\r\n{\r\n    return IsHotkeyy(vkey, conf.ModKey);\r\n}\r\n\r\nstatic UCHAR TotNumberOfKeysDown()\r\n{\r\n    BYTE kb_state[256];\r\n    GetKeyState(0); // You need that for GetKeyboardState()\r\n    GetKeyboardState(kb_state);\r\n    UCHAR numkeys=0;\r\n    BYTE i;\r\n    for (i=0x13; i < 0xFF; i++) {\r\n        // vK codes go from 0 to 254 and we must skip a few\r\n        if((0x3A <= i && i<=0x40) // Undefineds\r\n        ||  i == 0x5E             // Reserved\r\n        || (0x88 <= i && i<=0x8F) // Unassigned\r\n        || (0x97 <= i && i<=0x9F) // Unassigned\r\n        || (0xB8 <= i && i<=0xB9) // Reserved\r\n        || (0xC1 <= i && i<=0xDA) // Reserved + Unassigned (D8-DA)\r\n        || i == 0xE0 // Reserved\r\n        || i == 0xE8 // Unassigned\r\n        ) continue;\r\n\r\n        numkeys += !!(kb_state[i]&0x80);\r\n                 /*!!(GetKeyState(i)&0x8000)*/\r\n    }\r\n    return numkeys;\r\n}\r\n// Return true if required amount of hotkeys are holded.\r\n// If KeyCombo is disabled, user needs to hold only one hotkey.\r\n// Otherwise, user needs to hold at least two hotkeys.\r\nstatic int IsHotkeyDown()\r\n{\r\n    // required keys 1 or 2\r\n    UCHAR ckeys = 1 + conf.KeyCombo;\r\n\r\n    // loop over all hotkeys\r\n    const UCHAR *pos=&conf.Hotkeys[0];\r\n    while (*pos && ckeys) {\r\n        // check if key is held down. Use GetKeyState()?\r\n        ckeys -= !!(GetAsyncKeyState(*pos++)&0x8000);\r\n    }\r\n    // return true if required amount of hotkeys are down\r\n    return !ckeys && (!conf.MaxKeysNum || TotNumberOfKeysDown() <= conf.MaxKeysNum);\r\n}\r\n\r\n// returns the number of hotkeys/ModKeys that are pressed.\r\nstatic int NumKeysDown()\r\n{\r\n    UCHAR keys = 0;\r\n    // loop over all hotkeys\r\n    const UCHAR *Hpos=&conf.Hotkeys[0];\r\n    const UCHAR *Mpos=&conf.ModKey[0];\r\n    while (*Hpos) {\r\n        // check if key is held down\r\n        keys += !!(GetKeyState(*Hpos++)&0x8000);\r\n        keys += !!(GetKeyState(*Mpos++)&0x8000);\r\n    }\r\n    return keys;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// index 1 => normal restore on any move restore & 1\r\n// restore & 3 => Both 1 & 2 ie: Maximized then rolled.\r\nstatic void RestoreOldWin(const POINT pt, unsigned was_snapped, RECT *ownd)\r\n{\r\n    // Restore old width/height?\r\n    unsigned restore = 0;\r\n    int rwidth=0, rheight=0;\r\n    unsigned rdata_flag = GetRestoreData(state.hwnd, &rwidth, &rheight);\r\n\r\n    if (((rdata_flag & SNAPPED) && !(state.origin.maximized&&rdata_flag&2))) {\r\n        // Set origin width and height to the saved values\r\n        if (!state.usezones) {\r\n            restore = rdata_flag;\r\n            state.origin.width = rwidth;\r\n            state.origin.height = rheight;\r\n            ClearRestoreData(state.hwnd);\r\n        }\r\n    }\r\n\r\n    RECT wnd;\r\n    GetWindowRect(state.hwnd, &wnd);\r\n    // In case window is Maximized + Rolled get bottom where it needs to be\r\n    // So that the window stays fully in the monitor\r\n    // Note: a maximized then rolled window does not have the rolled flag.\r\n    if (state.origin.maximized)\r\n        wnd.bottom = state.origin.mon.bottom + state.mdipt.y;\r\n\r\n    // Set offset\r\n    state.offset.x = state.origin.width  * min(pt.x-wnd.left, wnd.right-wnd.left)\r\n                   / max(wnd.right-wnd.left,1);\r\n    state.offset.y = state.origin.height * min(pt.y-wnd.top, wnd.bottom-wnd.top)\r\n                   / max(wnd.bottom-wnd.top,1);\r\n\r\n    if (rdata_flag&ROLLED) {\r\n        if (state.origin.maximized || was_snapped) {\r\n            // if we restore a Rolled + Maximized/snapped window...\r\n            state.offset.y = GetSystemMetricsForWin(SM_CYMIN, state.hwnd)/2;\r\n        } else {\r\n            state.offset.x = pt.x - wnd.left;\r\n            state.offset.y = pt.y - wnd.top;\r\n        }\r\n    }\r\n\r\n    if (restore) {\r\n        LastWin.moveonly = 0;\r\n//        SetWindowPos(state.hwnd, NULL\r\n//                , pt.x - state.offset.x - state.mdipt.x\r\n//                , pt.y - state.offset.y - state.mdipt.y\r\n//                , state.origin.width, state.origin.height\r\n//                , SWP_NOZORDER);\r\n        ownd->left = pt.x - state.offset.x - state.mdipt.x;\r\n        ownd->top =  pt.y - state.offset.y - state.mdipt.y;\r\n        ownd->right = ownd->left + state.origin.width;\r\n        ownd->bottom = ownd->top + state.origin.height;\r\n        ClearRestoreData(state.hwnd);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Do not reclip the cursor if it is already clipped\r\n// Do not unclip the cursor if it was not clipped by AltDrag.\r\nstatic void ClipCursorOnce(const RECT *clip)\r\n{\r\n    static char trapped=0;\r\n    if (trapped && !clip) {\r\n        ClipCursor(NULL);\r\n        trapped=0;\r\n    } else if(!trapped && clip) {\r\n        ClipCursor(clip);\r\n        trapped = 1;\r\n    }\r\n}\r\n\r\nstatic void RestrictCursorToMon()\r\n{\r\n    // Restrict pt within origin monitor if Ctrl is being pressed\r\n    if (state.ctrl) {\r\n        static HMONITOR origMonitor;\r\n        static RECT fmon;\r\n        if (origMonitor != state.origin.monitor || !state.origin.monitor) {\r\n            origMonitor = state.origin.monitor;\r\n            MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n            GetMonitorInfo(state.origin.monitor, &mi);\r\n            CopyRect(&fmon, &mi.rcMonitor);\r\n            fmon.left++; fmon.top++;\r\n            fmon.right--; fmon.bottom--;\r\n        }\r\n        RECT clip;\r\n        if (state.mdiclient) {\r\n            CopyRect(&clip, &state.origin.mon);\r\n            OffsetRect(&clip, state.mdipt.x, state.mdipt.y);\r\n        } else {\r\n            CopyRect(&clip, &fmon);\r\n        }\r\n        ClipCursorOnce(&clip);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Get state.mdipt and mdi monitor\r\nstatic BOOL GetMDInfo(POINT *mdicpt, RECT *wnd)\r\n{\r\n    mdicpt->x = mdicpt->y = 0;\r\n    if (!GetClientRect(state.mdiclient, wnd)\r\n    ||  !ClientToScreen(state.mdiclient, mdicpt) ) {\r\n         return FALSE;\r\n    }\r\n    return TRUE;\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic void SetOriginFromRestoreData(HWND hwnd, enum action action)\r\n{\r\n    // Set Origin width and height needed for AC_MOVE/RESIZE/CENTER/MAXHV\r\n    int rwidth=0, rheight=0;\r\n    unsigned rdata_flag = GetRestoreData(hwnd, &rwidth, &rheight);\r\n    // Clear snapping info if asked.\r\n    if (rdata_flag&SNCLEAR || (conf.SmartAero&4 && action == AC_MOVE)) {\r\n        ClearRestoreData(hwnd);\r\n        rdata_flag=0;\r\n    }\r\n    // Replace origin width/height if available in the restore Data.\r\n    if (rdata_flag && !state.origin.maximized) {\r\n        state.origin.width = rwidth;\r\n        state.origin.height = rheight;\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Transparent window\r\n// We use 4 thin windows to simulate a hollow window because the\r\n// SetWindowRgn() function is very slow and would have to be called at every\r\n// Mouse frame when resizing.\r\nstatic void ShowTransWin(int nCmdShow)\r\n{\r\n    if(conf.TransWinOpacity) {\r\n        if(g_transhwnd[0]) ShowWindow(g_transhwnd[0], nCmdShow);\r\n    } else {\r\n        int i;\r\n        for (i=0; i<4; i++ )if(g_transhwnd[i]) ShowWindow(g_transhwnd[i], nCmdShow);\r\n    }\r\n}\r\n#define HideTransWin() ShowTransWin(SW_HIDE)\r\nstatic BOOL IsTransWinVisible() { return IsVisible(g_transhwnd[0]); }\r\n\r\nstatic void MoveTransWinRaw(int x, int y, int w, int h)\r\n{\r\n    #define f SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOSENDCHANGING //|SWP_DEFERERASE\r\n//      HDWP hwndSS = BeginDeferWindowPos(4);\r\n    if(conf.TransWinOpacity) {\r\n        SetWindowPos(g_transhwnd[0],NULL, x, y, w, h, f);\r\n    } else {\r\n        SetWindowPos(g_transhwnd[0],NULL,  x    , y    , w, 4, f);\r\n        SetWindowPos(g_transhwnd[1],NULL,  x    , y    , 4, h, f);\r\n        SetWindowPos(g_transhwnd[2],NULL,  x    , y+h-4, w, 4, f);\r\n        SetWindowPos(g_transhwnd[3],NULL,  x+w-4, y    , 4, h, f);\r\n    }\r\n    #undef f\r\n//      if(hwndSS) EndDeferWindowPos(hwndSS);\r\n}\r\nstatic void MoveTransWin(int x, int y, int w, int h)\r\n{\r\n    if (state.origin.dpi) {\r\n        POINT pt = { x + w/2, y + h/2 };\r\n        HMONITOR hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\r\n        if (hmon != state.origin.monitor && !GetRestoreFlag(state.hwnd)) {\r\n            UINT ptdpi=0, dpiy_ignore=0;\r\n            if ( S_OK == GetDpiForMonitorL(hmon, MDT_DEFAULT, &ptdpi, &dpiy_ignore) && ptdpi ) {\r\n                w = MulDiv(w, ptdpi, state.origin.dpi);\r\n                h = MulDiv(h, ptdpi, state.origin.dpi);\r\n            }\r\n        }\r\n    }\r\n    MoveTransWinRaw(x, y, w, h);\r\n}\r\nstatic DWORD CALLBACK WinPlacmntTrgead(LPVOID wndplptr)\r\n{\r\n    SetWindowPlacement(LastWin.hwnd, (WINDOWPLACEMENT *)wndplptr);\r\n    LastWin.hwnd = NULL;\r\n    return 0;\r\n}\r\nstatic void SetWindowPlacementThread(HWND hwnd, WINDOWPLACEMENT *wndplptr)\r\n{\r\n    LastWin.hwnd = hwnd;\r\n    DWORD lpThreadId;\r\n    CloseHandle(CreateThread(NULL, STACK, WinPlacmntTrgead, wndplptr, STACK_SIZE_PARAM_IS_A_RESERVATION, &lpThreadId));\r\n}\r\n// state.origin.mon initialized in init_mov..\r\n// returns the final window rectangle.\r\nstatic void RestoreToMonitorSize(HWND hwnd, RECT *wnd)\r\n{\r\n    ClearRestoreData(hwnd); //Clear restore flag and data\r\n    WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n    GetWindowPlacement(hwnd, &wndpl);\r\n\r\n    // Set size to origin monitor to prevent flickering\r\n    // Get monitor info\r\n    MONITORINFO mi;\r\n    GetMonitorInfoFromWin(hwnd, &mi);\r\n\r\n    CopyRect(wnd, &mi.rcWork);\r\n    CopyRect(&wndpl.rcNormalPosition, wnd);\r\n\r\n    if (state.mdiclient) {\r\n        // Make it a little smaller since MDIClients by\r\n        // default have scrollbars that would otherwise appear\r\n        wndpl.rcNormalPosition.right -= 8;\r\n        wndpl.rcNormalPosition.bottom -= 8;\r\n    }\r\n    wndpl.showCmd = SW_RESTORE;\r\n    SetWindowPlacement(hwnd, &wndpl);\r\n    if (state.mdiclient) {\r\n        // Get new values from MDIClient,\r\n        // since restoring the child have changed them,\r\n        Sleep(1); // Sometimes needed\r\n        GetMDInfo(&state.mdipt, wnd);\r\n        CopyRect(&state.origin.mon, wnd);\r\n\r\n        state.origin.right = wnd->right;\r\n        state.origin.bottom=wnd->bottom;\r\n    }\r\n    // Fix wnd for MDI offset and invisible borders\r\n    RECT borders;\r\n    FixDWMRect(hwnd, &borders);\r\n    OffsetRect(wnd, state.mdipt.x, state.mdipt.y);\r\n    InflateRectBorder(wnd, &borders);\r\n}\r\n// Call if you need to resize the window.\r\n// If smart areo is not enabled then, we need to clear the restore date\r\nstatic void ClearRestoreFlagOnResizeIfNeeded(HWND hwnd)\r\n{\r\n    if (!(conf.SmartAero&1)) {\r\n        // Always clear when AeroSmart is disabled.\r\n        ClearRestoreData(hwnd);\r\n    } else {\r\n        // Do not clear is the window was snapped to some side or rolled.\r\n        unsigned smart_restore_flag=(SNZONE|SNAPPEDSIDE|ROLLED);\r\n        if(!(GetRestoreFlag(hwnd) & smart_restore_flag))\r\n            ClearRestoreData(hwnd);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void UpdateCursor(POINT pt);\r\nstatic void SetEdgeAndOffset(const RECT *wnd, POINT pt);\r\nstatic void MouseMove(POINT pt)\r\n{\r\n    // Check if window still exists\r\n    if (!IsWindow(state.hwnd))\r\n        { LastWin.hwnd = NULL; UnhookMouse(); return; }\r\n\r\n    if (conf.UseCursor) // Draw the invisible cursor window\r\n        MoveWindow(g_mainhwnd, pt.x-128, pt.y-128, 256, 256, FALSE);\r\n\r\n    if (state.moving == CURSOR_ONLY) {\r\n        if (state.action == AC_RESIZE) {\r\n            RECT rc;\r\n            GetWindowRect(state.hwnd, &rc);\r\n            SetEdgeAndOffset(&rc, pt);\r\n            UpdateCursor(pt);\r\n        }\r\n        return; // Movement was blocked...\r\n    }\r\n\r\n    static RECT wnd; // wnd will be updated and is initialized once.\r\n    if (!state.moving && !GetWindowRect(state.hwnd, &wnd)) return;\r\n    int posx=0, posy=0, wndwidth=0, wndheight=0;\r\n\r\n    // Restore Aero snapped window when movement starts\r\n    UCHAR was_snapped = 0;\r\n    if (!state.moving) {\r\n        LastWin.odpi = state.origin.dpi;\r\n        SetOriginFromRestoreData(state.hwnd, state.action);\r\n        if (state.action == AC_MOVE) {\r\n            was_snapped = IsWindowSnapped(state.hwnd);\r\n            RestoreOldWin(pt, was_snapped, &wnd);\r\n        }\r\n    }\r\n\r\n\r\n    // Convert pt in MDI coordinates.\r\n    // state.mdipt is global!\r\n    pt.x -= state.mdipt.x;\r\n    pt.y -= state.mdipt.y;\r\n\r\n    RestrictCursorToMon(); // When CTRL is pressed.\r\n\r\n    // Get new position for window\r\n    LastWin.end = 0;\r\n    LastWin.moveonly = 0;\r\n    if (state.action == AC_MOVE) {\r\n        // SWP_NOSIZE to SetWindowPos\r\n        LastWin.moveonly = state.moving;\r\n        posx = pt.x-state.offset.x;\r\n        posy = pt.y-state.offset.y;\r\n        wndwidth = wnd.right-wnd.left;\r\n        wndheight = wnd.bottom-wnd.top;\r\n\r\n        // Check if the window will snap anywhere\r\n        int ret = AeroMoveSnap(pt, &posx, &posy, &wndwidth, &wndheight);\r\n        if (ret == 1) { state.moving = 1; return; }\r\n        MoveSnap(&posx, &posy, wndwidth, wndheight, conf.SnapThreshold);\r\n        MoveSnapToZone(pt, &posx, &posy, &wndwidth, &wndheight);\r\n\r\n        // Restore window if maximized when starting\r\n        if (!LastWin.snap && (was_snapped || IsZoomed(state.hwnd))) {\r\n            LastWin.moveonly = 0;\r\n            WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n            GetWindowPlacement(state.hwnd, &wndpl);\r\n            // Restore original width and height in case we are restoring\r\n            // A Snapped + Maximized window.\r\n            wndpl.showCmd = SW_RESTORE;\r\n            unsigned restore = GetRestoreFlag(state.hwnd);\r\n            if (!(restore&ROLLED)) { // Not if window is rolled!\r\n                wndpl.rcNormalPosition.left = posx;\r\n                wndpl.rcNormalPosition.top = posy;\r\n                wndpl.rcNormalPosition.right = wndpl.rcNormalPosition.left + state.origin.width;\r\n                wndpl.rcNormalPosition.bottom= wndpl.rcNormalPosition.top +  state.origin.height;\r\n            }\r\n            if (restore&SNTHENROLLED) ClearRestoreData(state.hwnd);// Only Flag?\r\n            // Update wndwidth and wndheight\r\n            wndwidth  = wndpl.rcNormalPosition.right - wndpl.rcNormalPosition.left;\r\n            wndheight = wndpl.rcNormalPosition.bottom - wndpl.rcNormalPosition.top;\r\n            if( !conf.FullWin && LOBYTE(GetVersion()) < 10 )\r\n                wndpl.flags |= WPF_ASYNCWINDOWPLACEMENT;\r\n            SetWindowPlacement(state.hwnd, &wndpl);\r\n            EnumOnce(RECALC_INVISIBLE_BORDERS);\r\n//            if (!conf.FullWin) {\r\n//                wndpl.flags |= WPF_ASYNCWINDOWPLACEMENT;\r\n//                SetWindowPlacement(state.hwnd, &wndpl);\r\n//            } else {\r\n//                LastWin.end=1;\r\n//            }\r\n        }\r\n\r\n    } else if (state.action == AC_RESIZE) {\r\n        // Restore the window (to monitor size) if it's maximized\r\n        if (!state.moving && IsZoomed(state.hwnd)) {\r\n              RestoreToMonitorSize(state.hwnd, &wnd);\r\n        }\r\n        // Clear restore flag if needed\r\n        ClearRestoreFlagOnResizeIfNeeded(state.hwnd);\r\n        // Figure out new placement\r\n        if (state.resize.x == RZ_XCENTER && state.resize.y == RZ_YCENTER) {\r\n            if (state.shift) pt.x = state.shiftpt.x;\r\n            else if (state.ctrl) pt.y = state.ctrlpt.y;\r\n            wndwidth  = wnd.right-wnd.left + 2*(pt.x-state.offset.x);\r\n            wndheight = wnd.bottom-wnd.top + 2*(pt.y-state.offset.y);\r\n            posx = wnd.left - (pt.x - state.offset.x) - state.mdipt.x;\r\n            posy = wnd.top  - (pt.y - state.offset.y) - state.mdipt.y;\r\n\r\n            // Keep the window perfectly centered.\r\n            // even when going out of min or max sizes\r\n            int W = CLAMPW(wndwidth);\r\n            int dW = wndwidth - W;\r\n            posx +=  dW/2;\r\n            wndwidth = W;\r\n            int H = CLAMPH(wndheight);\r\n            int dH = wndheight - H;\r\n            posy +=  dH/2;\r\n            wndheight = H;\r\n\r\n            state.offset.x = pt.x;\r\n            state.offset.y = pt.y;\r\n\r\n        } else {\r\n            if (state.resize.y == RZ_TOP) {\r\n                wndheight = CLAMPH( (wnd.bottom-pt.y+state.offset.y) - state.mdipt.y );\r\n                posy = state.origin.bottom - wndheight;\r\n            } else if (state.resize.y == RZ_YCENTER) {\r\n                posy = wnd.top - state.mdipt.y;\r\n                wndheight = wnd.bottom - wnd.top;\r\n            } else if (state.resize.y == RZ_BOTTOM) {\r\n                posy = wnd.top - state.mdipt.y;\r\n                wndheight = pt.y - posy + state.offset.y;\r\n            }\r\n            if (state.resize.x == RZ_LEFT) {\r\n                wndwidth = CLAMPW( (wnd.right-pt.x+state.offset.x) - state.mdipt.x );\r\n                posx = state.origin.right - wndwidth;\r\n            } else if (state.resize.x == RZ_XCENTER) {\r\n                posx = wnd.left - state.mdipt.x;\r\n                wndwidth = wnd.right - wnd.left;\r\n            } else if (state.resize.x == RZ_RIGHT) {\r\n                posx = wnd.left - state.mdipt.x;\r\n                wndwidth = pt.x - posx+state.offset.x;\r\n            }\r\n            wndwidth =CLAMPW(wndwidth);\r\n            wndheight=CLAMPH(wndheight);\r\n\r\n            // Check if the window will snap anywhere\r\n            ResizeSnap(&posx, &posy, &wndwidth, &wndheight, conf.SnapThreshold, conf.SnapThreshold);\r\n            AeroResizeSnap(pt, &posx, &posy, &wndwidth, &wndheight);\r\n        }\r\n    }\r\n    // LastWin is GLOBAL !\r\n    UCHAR mouse_thread_finished = !LastWin.hwnd;\r\n    LastWin.x      = posx;\r\n    LastWin.y      = posy;\r\n    LastWin.width  = wndwidth;\r\n    LastWin.height = wndheight;\r\n\r\n    // Update the static wnd with new dimentions.\r\n    wnd.left   = posx + state.mdipt.x;\r\n    wnd.top    = posy + state.mdipt.y;\r\n    wnd.right  = posx + state.mdipt.x + wndwidth;\r\n    wnd.bottom = posy + state.mdipt.y + wndheight;\r\n\r\n    // Save hwnd After we are sure movement will occur.\r\n    LastWin.hwnd   = state.hwnd;\r\n\r\n    if (!conf.FullWin) {\r\n        static RECT bd;\r\n        if(!state.moving) FixDWMRectLL(state.hwnd, &bd, 0);\r\n        int tx      = posx + state.mdipt.x + bd.left;\r\n        int ty      = posy + state.mdipt.y + bd.top;\r\n        int twidth  = wndwidth - bd.left - bd.right;\r\n        int theight = wndheight - bd.top - bd.bottom;\r\n        MoveTransWin(tx, ty, twidth, theight);\r\n        if (!IsTransWinVisible())\r\n            ShowTransWin(SW_SHOWNA);\r\n        state.moving=1;\r\n        ResizeTouchingWindows(&LastWin);\r\n\r\n    } else if (mouse_thread_finished) {\r\n        // Resize other windows\r\n        if (!ResizeTouchingWindows(&LastWin)) {\r\n            // The resize touching also resizes LastWin.\r\n            MoveWindowInThread(&LastWin);\r\n        }\r\n        state.moving = 1;\r\n    } else {\r\n        Sleep(0);\r\n        state.moving = NOT_MOVED; // Could not Move Window\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void Send_KEY(unsigned char vkey)\r\n{\r\n    KEYBDINPUT ctrl[2] = { {0, 0, 0, 0, 0}, {0, 0 , KEYEVENTF_KEYUP, 0, 0} };\r\n    ctrl[0].wVk = ctrl[1].wVk = vkey;\r\n    ctrl[0].dwExtraInfo = ctrl[1].dwExtraInfo = GetMessageExtraInfo();\r\n//    ctrl[0].time = ctrl[1].time = GetTickCount();\r\n    INPUT input[2]={{0},{0}};\r\n    input[0].type = input[1].type = INPUT_KEYBOARD;\r\n    input[0].ki = ctrl[0]; input[1].ki = ctrl[1];\r\n    InterlockedIncrement(&state.ignorekey);\r\n    SendInput(2, input, sizeof(INPUT));\r\n    InterlockedDecrement(&state.ignorekey);\r\n}\r\n#define KEYEVENTF_KEYDOWN 0\r\n// Call with or KEYEVENTF_KEYDOWN/KEYEVENTF_KEYUP\r\nstatic void Send_KEY_UD(unsigned char vkey, WORD flags)\r\n{\r\n    KEYBDINPUT ctrl = {0, 0, 0, 0, 0};\r\n    ctrl.wVk = vkey;\r\n    ctrl.dwExtraInfo = GetMessageExtraInfo();\r\n    ctrl.dwFlags = flags;\r\n    ctrl.time = GetTickCount();\r\n    INPUT input={0};\r\n    input.type = INPUT_KEYBOARD;\r\n    input.ki = ctrl;\r\n\r\n    InterlockedIncrement(&state.ignorekey);\r\n    SendInput(1, &input, sizeof(INPUT));\r\n    InterlockedDecrement(&state.ignorekey);\r\n}\r\n#define Send_CTRL() if (conf.EndSendKey) Send_KEY(conf.EndSendKey)\r\n\r\n// Send a sequence of Inputs.....\r\nstatic void SendInputSequence(const UCHAR *seq)\r\n{\r\n    UCHAR len = *seq;\r\n    while (len--) {\r\n        UCHAR vKey = *++seq;\r\n        UCHAR Down = *++seq;\r\n        if(Down == 2) // Combined U, then D\r\n            Send_KEY(vKey);\r\n        else\r\n            Send_KEY_UD(vKey, Down? KEYEVENTF_KEYDOWN: KEYEVENTF_KEYUP);\r\n        //LOGA(\"Sending %x, %s\", (UINT)vKey, Down? \"Down\": \"Up\");\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Sends the click down/click up sequence to the system\r\nstatic DWORD WINAPI Send_ClickProc(LPVOID buttonD)\r\n{\r\n    enum button button = (enum button)(LONG_PTR)buttonD;\r\n    static const WORD bmapping[] = {\r\n          MOUSEEVENTF_LEFTDOWN\r\n        , MOUSEEVENTF_RIGHTDOWN\r\n        , MOUSEEVENTF_MIDDLEDOWN\r\n        , MOUSEEVENTF_XDOWN, MOUSEEVENTF_XDOWN\r\n    };\r\n    if (!button || button > BT_MB5) return 0;\r\n\r\n    DWORD MouseEvent = bmapping[button-2];\r\n    DWORD mdata = 0;\r\n    if (MouseEvent == MOUSEEVENTF_XDOWN) // XBUTTON\r\n        mdata = button - 0x04; // mdata = 1 for X1 and 2 for X2\r\n    // MouseEvent<<1 corresponds to MOUSEEVENTF_*UP\r\n    MOUSEINPUT click[2];\r\n    mem00(&click[0], sizeof(MOUSEINPUT)*2);\r\n    click[0].mouseData = click[1].mouseData = mdata;\r\n    click[0].dwFlags = MouseEvent;\r\n    click[1].dwFlags = MouseEvent<<1;\r\n    click[0].dwExtraInfo = click[1].dwExtraInfo = GetMessageExtraInfo();\r\n    INPUT input[2];\r\n    input[0].type = input[1].type = INPUT_MOUSE;\r\n    input[0].mi = click[0]; input[1].mi = click[1];\r\n\r\n    InterlockedIncrement(&state.ignoreclick);\r\n    SendInput(2, input, sizeof(INPUT));\r\n    InterlockedDecrement(&state.ignoreclick);\r\n    return 0;\r\n}\r\n#define Send_Click(x) Send_ClickProc((LPVOID)(LONG_PTR)(x));\r\nstatic void Send_Click_Thread(enum button button)\r\n{\r\n    DWORD id;\r\n    CloseHandle(CreateThread(NULL, STACK, Send_ClickProc, (LPVOID)(LONG_PTR)button, STACK_SIZE_PARAM_IS_A_RESERVATION, &id));\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Sends an unicode character to the system.\r\n// KEYEVENTF_UNICODE requires at least Windows 2000\r\n// Extended unicode page can be accessed by sending both lo&hi surrogates\r\nstatic void SendUnicodeKey(WORD w)\r\n{\r\n    KEYBDINPUT ctrl[2] = {\r\n        {0, 0, KEYEVENTF_UNICODE, 0, 0},\r\n        {0, 0, KEYEVENTF_UNICODE|KEYEVENTF_KEYUP, 0, 0}\r\n    };\r\n    // mem00(&click[0], sizeof(KEYBDINPUT)*2);\r\n    ctrl[0].wScan = ctrl[1].wScan = w;\r\n//    ctrl[0].dwFlags = KEYEVENTF_UNICODE;\r\n//    ctrl[1].dwFlags = KEYEVENTF_UNICODE|KEYEVENTF_KEYUP;\r\n    ctrl[0].dwExtraInfo = ctrl[1].dwExtraInfo = GetMessageExtraInfo();\r\n//    ctrl[0].time = ctrl[1].time = GetTickCount();\r\n    INPUT input[2];\r\n    input[0].type = input[1].type = INPUT_KEYBOARD;\r\n    input[0].ki = ctrl[0]; input[1].ki = ctrl[1];\r\n\r\n    InterlockedIncrement(&state.ignorekey);\r\n    SendInput(2, input, sizeof(INPUT));\r\n    InterlockedDecrement(&state.ignorekey);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void RestrictToCurentMonitor()\r\n{\r\n    if (state.action || state.alt) {\r\n        POINT pt;\r\n        GetCursorPos(&pt);\r\n        state.origin.maximized = 0; // To prevent auto-remax on Ctrl\r\n        state.origin.monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void HotkeyUp()\r\n{\r\n    // Prevent the alt keyup from triggering the window menu to be selected\r\n    // The way this works is that the alt key is \"disguised\" by sending\r\n    // ctrl keydown/keyup events\r\n    if (state.blockaltup || state.action) {\r\n        //LOGA(\"SendCtrl\");\r\n        Send_CTRL();\r\n        state.blockaltup = 0;\r\n        // If there is more that one key down remaining\r\n        // then we must block the next alt up.\r\n        if (NumKeysDown() > 1) state.blockaltup = 1;\r\n    }\r\n\r\n    // Hotkeys have been released\r\n    state.alt = 0;\r\n    state.alt1 = 0;\r\n    if (state.action\r\n    && (conf.GrabWithAlt[0] || conf.GrabWithAlt[1])\r\n    && (MOUVEMENT(conf.GrabWithAlt[0]) || MOUVEMENT(conf.GrabWithAlt[1]))) {\r\n        FinishMovement();\r\n    }\r\n\r\n    // Unhook mouse if no actions is ongoing.\r\n    if (!state.action) {\r\n        UnhookMouse();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic int ActionPause(HWND hwnd, UCHAR pause)\r\n{\r\n//    LOGA(\"Entering pause/resume %d\", (int)pause);\r\n    if (!blacklisted(hwnd, &BlkLst.Pause)) {\r\n        DWORD pid=0;\r\n        GetWindowThreadProcessId(hwnd, &pid);\r\n\r\n        #define P1_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xfff)\r\n        #define P2_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xffff)\r\n        HANDLE ProcessHandle = OpenProcess(P2_ALL_ACCESS, FALSE, pid);\r\n        if(!ProcessHandle)\r\n            ProcessHandle = OpenProcess(P1_ALL_ACCESS, FALSE, pid);\r\n        if(!ProcessHandle)\r\n            ProcessHandle = OpenProcess(PROCESS_SUSPEND_RESUME, FALSE, pid);\r\n\r\n        if (ProcessHandle) {\r\n//            LOGA(\"Going to pause/resume %d\", (int)pause);\r\n            if (pause) NtSuspendProcess(ProcessHandle);\r\n            else       NtResumeProcess(ProcessHandle);\r\n\r\n            CloseHandle(ProcessHandle);\r\n//            LOGA(\"Done\");\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Kill the process from hwnd\r\nDWORD WINAPI ActionKillThread(LPVOID hwnd)\r\n{\r\n    if (state.shift) {\r\n        // TODO: Aggressive command such as:\r\n        // taskkill.exe /F /FI \"status eq NOT RESPONDING\" /FI \"IMAGENAME ne AltSnap.exe\" /FI \"IMAGENAME ne dwm.exe\"\r\n    } else {\r\n        DWORD pid;\r\n        GetWindowThreadProcessId((HWND)hwnd, &pid);\r\n        //LOG(\"pid=%lu\", pid);\r\n\r\n        // Open the process\r\n        HANDLE proc = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\r\n        //LOG(\"proc=%lx\", (DWORD)proc);\r\n        if (proc) {\r\n            TerminateProcess(proc, 1);\r\n            CloseHandle(proc);\r\n        }\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nstatic int ActionKill(HWND hwnd)\r\n{\r\n    //LOG(\"hwnd=%lx\",(DWORD) hwnd);\r\n    if (!hwnd) return 0;\r\n\r\n    if(isClassName(hwnd, TEXT(\"Ghost\"))) {\r\n        PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0);\r\n        return 1;\r\n    }\r\n\r\n    if(blacklisted(hwnd, &BlkLst.Pause))\r\n       return 0;\r\n\r\n    DWORD lpThreadId;\r\n    CloseHandle(CreateThread(NULL, STACK, ActionKillThread, hwnd, STACK_SIZE_PARAM_IS_A_RESERVATION, &lpThreadId));\r\n\r\n    return 1;\r\n}\r\n// Try harder to actually set the window foreground.\r\nstatic void ReallySetForegroundWindow(HWND hwnd)\r\n{\r\n    if (!hwnd) return;\r\n    // Check existing foreground Window.\r\n    HWND  fore = GetForegroundWindow();\r\n    if (fore != hwnd) {\r\n        if (state.alt != VK_MENU &&  state.alt != VK_CONTROL\r\n        && !(GetKeyState(VK_CONTROL)&0x8000)\r\n        && !(GetKeyState(VK_MENU)&0x8000)) {\r\n            // If the physical Alt or Ctrl keys are not down\r\n            // We need to activate the window with key input.\r\n            // CTRL seems to work. Also Alt works but trigers the menu\r\n            // So it is simpler to stick to CTRL.\r\n            Send_KEY(VK_CONTROL);\r\n        }\r\n        BringWindowToTop(hwnd);\r\n        SetForegroundWindow(hwnd);\r\n    }\r\n}\r\nstatic void SetForegroundWindowL(HWND hwnd)\r\n{\r\n    if (!state.mdiclient) {\r\n        ReallySetForegroundWindow(hwnd);\r\n    } else {\r\n        ReallySetForegroundWindow(state.mdiclient);\r\n        PostMessage(state.mdiclient, WM_MDIACTIVATE, (WPARAM)hwnd, 0);\r\n    }\r\n}\r\n// Returns true if AltDrag must be disabled based on scroll lock\r\n// If conf.ScrollLockState&2 then Altdrag is disabled by Scroll Lock\r\n// otherwise it is enabled by Scroll lock.\r\nstatic int ScrollLockState()\r\n{\r\n    if (state.altsnaponoff)\r\n        return 1; // AltSnap was disabled by AC_ASONOFF\r\n\r\n    if( (conf.ScrollLockState&1)\r\n    && !( !(GetKeyState(VK_SCROLL)&1) ^ !(conf.ScrollLockState&2) ) ) {\r\n        if (state.action)\r\n            FinishMovement();\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nstatic void LogState(const char *Title)\r\n{\r\n    FILE *f=fopen(\"ad.log\", \"a\"); // append data...\r\n    fputs(Title, f);\r\n    fprintf(f,\r\n        \"action=%d\\n\"\r\n        \"moving=%d\\n\"\r\n        \"ctrl=%d\\n\"\r\n        \"shift=%d\\n\"\r\n        \"alt=%d\\n\"\r\n        \"alt1=%d\\n\"\r\n    , (int)state.action\r\n    , (int)state.moving\r\n    , (int)state.ctrl\r\n    , (int)state.shift\r\n    , (int)state.alt\r\n       , (int)state.alt1);\r\n\r\n    fprintf(f,\r\n       \"clickbutton=%d\\n\"\r\n       \"hwnd=%lx\\n\"\r\n       \"lwhwnd=%lx\\n\"\r\n       \"lwend=%d\\n\"\r\n       \"lwmoveonly=%d\\n\"\r\n       \"lwmaximize=%d\\n\"\r\n       \"lwsnap=%d\\n\"\r\n       \"blockaltup=%d\\n\"\r\n       \"blockmouseup=%d\\n\"\r\n       \"ignorekey=%d\\n\\n\\n\"\r\n    , (int)state.clickbutton\r\n    , (DWORD)(DorQWORD)state.hwnd\r\n    , (DWORD)(DorQWORD)LastWin.hwnd\r\n    , (int)LastWin.end\r\n    , (int)LastWin.moveonly\r\n    , (int)LastWin.maximize\r\n    , (int)LastWin.snap\r\n    , (int)state.blockaltup\r\n    , (int)state.blockmouseup\r\n    , (int)state.ignorekey );\r\n    fclose(f);\r\n}\r\nstatic pure int XXButtonIndex(UCHAR vkey)\r\n{\r\n    WORD i;\r\n    for (i=0; i < MAXKEYS && conf.XXButtons[i]; i++) {\r\n        if(conf.XXButtons[i] == vkey)\r\n            return i+3;\r\n    }\r\n    return -1;\r\n}\r\nLRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam);\r\nstatic int SimulateXButton(WPARAM wp, WORD xbtidx)\r\n{\r\n//    WORD xbtidx = XXButtonIndex(vkey);\r\n    MSLLHOOKSTRUCT msg;\r\n    GetCursorPos(&msg.pt);\r\n    // XButton number is in HIWORD(mouseData)\r\n    msg.mouseData= xbtidx << 16;\r\n    msg.flags=0;\r\n    msg.time = GetTickCount();\r\n    LowLevelMouseProc(HC_ACTION, wp, (LPARAM)&msg);\r\n    return 1;\r\n}\r\n// Destroy AltSnap's menu\r\nstatic void KillAltSnapMenu()\r\n{\r\n//    if (state.unikeymenu) {\r\n//        EnableWindow(g_mchwnd, FALSE);\r\n//        DestroyMenu(state.unikeymenu);\r\n//        state.unikeymenu = NULL;\r\n//    }\r\n    if (g_mchwnd) {\r\n        SendMessage(g_mchwnd, WM_CLOSE, 0, 0);\r\n        g_mchwnd = NULL;\r\n    }\r\n    state.unikeymenu = NULL;\r\n}\r\nstatic void ToggleSnapState(void)\r\n{\r\n    state.snap = state.snap? 0: 3;\r\n}\r\nstatic void TogglesAlwaysOnTop(HWND hwnd);\r\nstatic HWND MDIorNOT(HWND hwnd, HWND *mdiclient_);\r\n///////////////////////////////////////////////////////////////////////////\r\n// Keep this one minimalist, it is always on.\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n#endif\r\n__declspec(dllexport) LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\r\n{\r\n#if defined(_MSC_VER) && _MSC_VER > 1300\r\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__)\r\n#endif\r\n\r\n    if (nCode != HC_ACTION || state.ignorekey) return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n\r\n    PKBDLLHOOKSTRUCT kbh = ((PKBDLLHOOKSTRUCT)lParam);\r\n    unsigned char vkey = kbh->vkCode;\r\n//    DWORD scode = kbh->scanCode;\r\n    int xxbtidx;\r\n    HWND fhwnd = NULL;\r\n//    if (vkey!=VK_F5) { // show key codes\r\n//        LOGA(\"wp=%u, vKey=%lx, sCode=%lx, flgs=%lx, ex=%lx\"\r\n//        , wParam, kbh->vkCode, kbh->scanCode, kbh->flags, kbh->dwExtraInfo);\r\n//    }\r\n    if (vkey == VK_SCROLL) PostMessage(g_mainhwnd, WM_UPDATETRAY, 0, 0);\r\n    if (ScrollLockState()) return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n\r\n    if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {\r\n        if (!state.alt && !state.action\r\n        && (!conf.KeyCombo || (state.alt1 && state.alt1 != vkey))\r\n        && IsHotkey(vkey)\r\n        && (!conf.MaxKeysNum || TotNumberOfKeysDown() < conf.MaxKeysNum)) {\r\n            //LOGA(\"\\nALT DOWN\");\r\n            state.alt = vkey;\r\n            state.blockaltup = 0;\r\n            state.sclickhwnd = NULL;\r\n            KillAltSnapMenu(); // Hide unikey menu in case...\r\n\r\n            // Release ALt even if we receave no AltUP message because of.\r\n            // Stupid software that like to steal Alt.\r\n            #ifdef ALTUP_TIMER\r\n            DWORD kbspeed=2;\r\n            if (GetKeyState(state.alt) & 0x8000) {\r\n               // If the key is autorepeating\r\n               SystemParametersInfo( SPI_GETKEYBOARDSPEED, 0, &kbspeed, 0 );\r\n               kbspeed = 33 + kbspeed * 12; // [0-31] -> 33 - 400 ms\r\n               //LOGA(\"Set ALTUP_TIMER to %u (autorepeat)\", kbspeed);\r\n            } else {\r\n               SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, &kbspeed, 0 );\r\n               kbspeed = 250 + kbspeed * 250; // [0-3] -> 250 - 1000 ms\r\n               //LOGA(\"Set ALTUP_TIMER to %u (First)\", kbspeed);\r\n            }\r\n            KillTimer(g_timerhwnd, ALTUP_TIMER);\r\n            SetTimer(g_timerhwnd, ALTUP_TIMER, kbspeed, NULL);\r\n            #endif\r\n\r\n            // Hook mouse\r\n            HookMouse();\r\n            if (conf.GrabWithAlt[0] || conf.GrabWithAlt[1]) {\r\n                POINT pt;\r\n                enum action action = conf.GrabWithAlt[IsModKey(vkey) || (!IsHotkey(conf.ModKey[0])&&ModKey())];\r\n                if (action) {\r\n                    state.blockmouseup = 0; // In case.\r\n                    GetCursorPos(&pt);\r\n                    if (!init_movement_and_actions(pt, NULL, action, vkey)) {\r\n                        UnhookMouse();\r\n                    }\r\n                    state.blockmouseup = 0; // In case.\r\n                }\r\n            }\r\n        } else if (conf.KeyCombo && !state.alt1 && IsHotkey(vkey)) {\r\n            state.alt1 = vkey;\r\n\r\n        } else if (IsHotkeyy(vkey, conf.Shiftkeys)) {\r\n            if (!state.shift && !IsModKey(vkey)/* != conf.ModKey*/) {\r\n                if (conf.ShiftSnaps) {\r\n                    state.snap = conf.AutoSnap==3? 0: 3;\r\n                }\r\n                state.shift = 1;\r\n                state.usezones = (conf.UseZones&9) != 9; // Zones and\r\n                state.shiftpt = state.prevpt; // Save point where shift was pressed.\r\n                state.enumed = 0; // Reset enum state.\r\n            }\r\n\r\n            // Block keydown to prevent Windows from changing keyboard layout\r\n            if (state.alt && state.action) {\r\n                return 1;\r\n            }\r\n        } else if (vkey == VK_SPACE && state.action && !IsSamePTT(&state.clickpt, &state.prevpt)) {\r\n            ToggleSnapState();\r\n            return 1; // Block to avoid sys menu.\r\n        } else if (state.alt && state.action == conf.GrabWithAlt[ModKey()] && IsKillkey(vkey)) {\r\n           // Release Hook on Alt+KillKey\r\n           // eg: DisplayFusion Alt+Tab elevated windows captures AltUp\r\n            HotkeyUp();\r\n        } else if ( IsHotkeyy(vkey, conf.ESCkeys) ) { // USER PRESSED ESCAPE! (vkey == VK_ESCAPE)\r\n            // Alsays disable shift and ctrl, in case of Ctrl+Shift+ESC.\r\n            // LogState(\"ESCAPE KEY WAS PRESSED:\\n\"); // Debug stuff....\r\n            state.ctrl = 0;\r\n            state.shift = 0;\r\n            LastWin.hwnd = NULL;\r\n            state.ignorekey = 0; // In case ...\r\n            state.ignoreclick = 0; // In case ...\r\n            if (state.unikeymenu || g_mchwnd) {\r\n                int ret = IsMenu(state.unikeymenu);\r\n                KillAltSnapMenu();\r\n                if (ret) return 1;\r\n            }\r\n\r\n            // Stop current action\r\n            if (state.action || state.alt) {\r\n                enum action action = state.action;\r\n                HideTransWin();\r\n                // Send WM_EXITSIZEMOVE and EVENT_SYSTEM_MOVESIZEEND\r\n                NotifySizeMoveStaEnd(state.hwnd, 0);\r\n\r\n                state.alt = 0;\r\n                state.alt1 = 0;\r\n\r\n                UnhookMouse();\r\n\r\n                // Block ESC if an action was ongoing\r\n                if (action) return 1;\r\n            }\r\n        } else if (!state.ctrl\r\n               && state.alt!=vkey\r\n               && (vkey == VK_LCONTROL || vkey == VK_RCONTROL)\r\n               && !(kbh->scanCode&SCANCODE_SIMULATED) /* Ignore ALT GR Scan Code (&0x0200) */\r\n               && !IsModKey(vkey)/*vkey != conf.ModKey*/ ) {\r\n            RestrictToCurentMonitor();\r\n            // If menu is present inform it that we pressed Ctrl.\r\n            //if (state.unikeymenu) PostMessage(g_mchwnd, WM_CLOSEMODE, 1, 0);\r\n            //LOGA(\"sC=%lu\", kbh->scanCode);\r\n            state.ctrl = 1;\r\n            state.ctrlpt = state.prevpt; // Save point where ctrl was pressed.\r\n            if (state.action) {\r\n                SetForegroundWindowL(state.hwnd);\r\n            }\r\n        } else if (state.sclickhwnd && g_mchwnd && state.alt && (vkey == VK_LMENU || vkey == VK_RMENU)) {\r\n            // Block Alt down when the altsnap's menu just opened\r\n            if (state.unikeymenu==(HMENU)1\r\n            || (IsWindow(state.sclickhwnd)  && IsWindow(g_mchwnd) && IsMenu(state.unikeymenu)))\r\n                return 1;\r\n        } else if ((xxbtidx = XXButtonIndex(vkey)) >=0\r\n        && (GetAction(BT_MMB+xxbtidx) ||  GetActionT(BT_MMB+xxbtidx) || IsHotclick(BT_MMB+xxbtidx))) {\r\n            if (!state.xxbutton) {\r\n                state.xxbutton = 1; // To Ignore autorepeat...\r\n                SimulateXButton(WM_XBUTTONDOWN, xxbtidx);\r\n            }\r\n            return 1;\r\n\r\n\r\n        } else if (conf.UniKeyHoldMenu\r\n        && (fhwnd=GetForegroundWindow())\r\n        && !IsFullScreenBL(fhwnd)\r\n        && !blacklisted(fhwnd, &BlkLst.Processes)\r\n        && !blacklisted(fhwnd, &BlkLst.Windows)) {\r\n            // Key lists used below...\r\n            static const UCHAR ctrlaltwinkeys[] =\r\n                {VK_CONTROL, VK_MENU, VK_LWIN, VK_RWIN, 0};\r\n            static const UCHAR menupopdownkeys[] =\r\n                { VK_BACK, VK_TAB, VK_APPS, VK_DELETE, VK_SPACE, VK_LEFT, VK_RIGHT\r\n                , VK_PRIOR, VK_NEXT, VK_END, VK_HOME, 0};\r\n            if (state.unikeymenu && IsMenu(state.unikeymenu) && !(GetKeyState(vkey)&0x8000)) {\r\n                if (vkey == VK_SNAPSHOT) return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n                if (IsHotkeyy(vkey, menupopdownkeys)) {\r\n                    KillAltSnapMenu();\r\n                    return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n                }\r\n\r\n                // Forward all keys to the menu...\r\n                PostMessage(g_mchwnd, WM_KEYDOWN, vkey, 0); // all keys are \"directed to the Menu\"\r\n                return 1; // block keydown\r\n\r\n            } else if (!state.ctrl && !state.alt && (0x41 <= vkey && vkey <= 0x5A) && !IsAKeyDown(ctrlaltwinkeys) ) {\r\n                // handle long A-Z keydown.\r\n                if (GetKeyState(vkey)&0x8000) { // The key is autorepeating.\r\n                    if(!IsMenu(state.unikeymenu)) {\r\n                        KillAltSnapMenu();\r\n                        state.unikeymenu = (HMENU)1;\r\n                        g_mchwnd = KreateMsgWin(MenuWindowProc, TEXT(APP_NAMEA)TEXT(\"-SClick\"), 2);\r\n                        UCHAR shiftdown = GetKeyState(VK_SHIFT)&0x8000 || GetKeyState(VK_CAPITAL)&1;\r\n                        PostMessage(g_mainhwnd, WM_UNIKEYMENU, (WPARAM)g_mchwnd, vkey|(shiftdown<<8) );\r\n                    }\r\n                    return 1; // block keydown\r\n                }\r\n            }\r\n        }\r\n    } else if (wParam == WM_KEYUP || wParam == WM_SYSKEYUP) {\r\n        if (IsHotkey(vkey)) {\r\n            //LOGA(\"ALT UP\");\r\n            HotkeyUp();\r\n        } else if (IsHotkeyy(vkey, conf.Shiftkeys)) {\r\n            state.shift = 0;\r\n            state.usezones = (conf.UseZones&9) == 9;\r\n            state.snap = conf.AutoSnap;\r\n            // if an action was performed and Alt is still down.\r\n            if (state.alt && state.blockaltup && (vkey == VK_LSHIFT || vkey == VK_RSHIFT))\r\n                Send_CTRL(); // send Ctrl to avoid Alt+Shift=>switch keymap\r\n        } else if (state.blockaltup && IsModKey(vkey)) {\r\n            // We release ModKey before Hotkey\r\n            //LOGA(\"SendCtrlM\");\r\n            Send_CTRL();\r\n            state.blockaltup = 0;\r\n            // If there is more that one key down remaining\r\n            // then we must block the next alt up.\r\n            if (NumKeysDown() > 1) state.blockaltup = 1;\r\n        } else if (vkey == VK_LCONTROL || vkey == VK_RCONTROL) {\r\n            // If menu is present inform it that we released Ctrl.\r\n            //if (state.unikeymenu) PostMessage(g_mchwnd, WM_CLOSEMODE, 0, 0);\r\n            ClipCursorOnce(NULL); // Release cursor trapping\r\n            state.ctrl = 0;\r\n       // If there is no action then Control UP prevents AltDragging...\r\n            if (!state.action) state.alt = 0;\r\n        } else if ((xxbtidx = XXButtonIndex(vkey)) >=0 ) {\r\n            state.xxbutton = 0;\r\n            SimulateXButton(WM_XBUTTONUP, xxbtidx);\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// 1.44\r\nstatic int ScrollPointedWindow(POINT pt, int delta, WPARAM wParam)\r\n{\r\n    // Get window and foreground window\r\n    HWND hwnd = WindowFromPoint(pt);\r\n    if (!hwnd || blacklisted(hwnd, &BlkLst.IScroll))\r\n        return 0;\r\n\r\n    HWND foreground = GetForegroundWindow();\r\n\r\n    // Return if foreground window is blacklisted\r\n    if (foreground && blacklisted(foreground,&BlkLst.Windows))\r\n        return 0;\r\n\r\n    // If it's a groupbox, grab the real window\r\n    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);\r\n    if ((style&BS_GROUPBOX) && isClassName(hwnd, TEXT(\"Button\"))) {\r\n        HWND groupbox = hwnd;\r\n        EnableWindow(groupbox, FALSE);\r\n        hwnd = WindowFromPoint(pt);\r\n        EnableWindow(groupbox, TRUE);\r\n        if (!hwnd) return 0;\r\n    }\r\n\r\n    // Get wheel info\r\n    WPARAM wp = delta << 16;\r\n    LPARAM lp = MAKELPARAM(pt.x, pt.y);\r\n\r\n    // Change WM_MOUSEWHEEL to WM_MOUSEHWHEEL if shift is being depressed\r\n    // Introduced in Vista and far from all programs have implemented it.\r\n    if (wParam == WM_MOUSEWHEEL && IsAKeyDown(conf.HScrollKey)) {\r\n        wParam = WM_MOUSEHWHEEL;\r\n        wp = -wp ; // Up is left, down is right\r\n    }\r\n\r\n    // Add button information since we don't get it with the hook\r\n    static const UCHAR toOr[] = {\r\n        VK_LBUTTON, // MK_LBUTTON  }, 1\r\n        VK_RBUTTON, // MK_RBUTTON  }, 2\r\n        VK_CONTROL, // MK_CONTROL  }, 4\r\n        VK_SHIFT,   // MK_SHIFT    }, 8\r\n        VK_MBUTTON, // MK_MBUTTON  }, 16\r\n        VK_XBUTTON1,// MK_XBUTTON1 }, 32\r\n        VK_XBUTTON2,// MK_XBUTTON2 }  64\r\n    };\r\n    unsigned i;\r\n    for (i=0; i < ARR_SZ(toOr); i++) // Should we use GetKeyState?\r\n        if (GetAsyncKeyState(toOr[i]) &0x8000) wp |= (1<<i);\r\n\r\n    // Forward scroll message\r\n    SendMessage(hwnd, wParam, wp, lp);\r\n    // Simulate small steps wheel (can be used to debug other programs)\r\n    //SendMessage(hwnd, WM_MOUSEWHEEL, (state.shift?(delta/7):delta)<<16, lp);\r\n\r\n    // Block original scroll event\r\n    return 1;\r\n}\r\n// Determine if we should select the window through AltTab equivalents\r\n// We do not want the desktop window nor taskbar in this list\r\n// We want usually a window with a taskbar or that has the WS_EX_APPWINDOW\r\n// extended flag. Another case is the windows that were made borderless.\r\n// We include all windows that do not have the WS_EX_TOOLWINDOW exstyle\r\n// De also exclude all windows that are in the Bottommost list.\r\nstatic int IsAltTabAble(HWND window)\r\n{\r\n    LONG_PTR xstyle;\r\n    TCHAR txt[2];\r\n    return IsVisible(window)\r\n       && ((xstyle=GetWindowLongPtr(window, GWL_EXSTYLE))&WS_EX_NOACTIVATE) != WS_EX_NOACTIVATE\r\n       && ( // Has a caption or borderless or present in taskbar.\r\n            (xstyle&WS_EX_TOOLWINDOW) != WS_EX_TOOLWINDOW // Not a tool window\r\n          ||(GetWindowLongPtr(window, GWL_STYLE)&WS_CAPTION) == WS_CAPTION // or has a caption\r\n          ||(xstyle&WS_EX_APPWINDOW) == WS_EX_APPWINDOW // Or is forced in taskbar\r\n          || GetBorderlessFlag(window) // Or we made it borderless\r\n       )\r\n       && (conf.MenuShowEmptyLabelWin || (GetWindowText(window, txt, ARR_SZ(txt)) && txt[0]))\r\n       && !blacklisted(window, &BlkLst.Bottommost); // Exclude bottommost windows\r\n}\r\nstatic int IsToolWindow(HWND hwnd)\r\n{\r\n    return GetWindowLongPtr(hwnd, GWL_EXSTYLE)&WS_EX_TOOLWINDOW;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nunsigned hwnds_alloc = 0;\r\n\r\n// lParam means to include minimized windows (pass TRK_LASERMODE to TrackMenuOfWindows)\r\nBOOL CALLBACK EnumAltTabWindows(HWND window, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    hwnds = (HWND *)GetEnoughSpace(hwnds, numhwnds, &hwnds_alloc, sizeof(HWND));\r\n    if (!hwnds) return FALSE; // Stop enum, we failed\r\n\r\n    // Only store window if it's visible, not minimized\r\n    // to taskbar and on the same monitor as the cursor\r\n    if (IsAltTabAble(window)\r\n    && (!IsIconic(window) || (lParam && !IsToolWindow(window)))\r\n    && state.origin.monitor == MonitorFromWindow(window,\r\n            conf.MenuShowOffscreenWin ? MONITOR_DEFAULTTONEAREST : MONITOR_DEFAULTTONULL)) {\r\n        hwnds[numhwnds++] = window;\r\n    }\r\n    return TRUE;\r\n}\r\nBOOL CALLBACK EnumAllAltTabWindows(HWND window, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    hwnds = (HWND *)GetEnoughSpace(hwnds, numhwnds, &hwnds_alloc, sizeof(HWND));\r\n    if (!hwnds) return FALSE; // Stop enum, we failed\r\n\r\n    // Only store window if it's visible, not minimized\r\n    // to taskbar, and either:\r\n    //   offscreen windows are shown, or\r\n    //   the window touches a monitor\r\n    if (IsAltTabAble(window)\r\n    && (!IsIconic(window) || (lParam && !IsToolWindow(window)))\r\n    && (conf.MenuShowOffscreenWin || MonitorFromWindow(window, MONITOR_DEFAULTTONULL))) {\r\n        hwnds[numhwnds++] = window;\r\n    }\r\n    return TRUE;\r\n}\r\nBOOL CALLBACK EnumTopMostWindows(HWND window, LPARAM lParam)\r\n{\r\n    // Make sure we have enough space allocated\r\n    hwnds = (HWND *)GetEnoughSpace(hwnds, numhwnds, &hwnds_alloc, sizeof(HWND));\r\n    if (!hwnds) return FALSE; // Stop enum, we failed\r\n\r\n    // Only store window if it's visible, not minimized\r\n    // to taskbar and on the same monitor as the cursor\r\n    if (IsAltTabAble(window)\r\n    && GetWindowLongPtr(window, GWL_EXSTYLE)&WS_EX_TOPMOST) {\r\n        hwnds[numhwnds++] = window;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic pure BOOL StackedRectsT(const RECT *a, const RECT *b, const int T)\r\n{ // Determine wether or not the windows are stacked...\r\n    return RectInRectT(a, b, T) ||  RectInRectT(b, a, T);\r\n}\r\n// Similar to the EnumAltTabWindows, to be used in AltTab();\r\nBOOL CALLBACK EnumStackedWindowsProc(HWND hwnd, LPARAM lasermode)\r\n{\r\n    // Make sure we have enough space allocated\r\n\r\n    hwnds = (HWND *)GetEnoughSpace(hwnds, numhwnds, &hwnds_alloc, sizeof(HWND));\r\n    if (!hwnds) return FALSE; // Stop enum, we failed\r\n    // Only store window if it's visible, not minimized to taskbar\r\n    RECT wnd, refwnd;\r\n    if (IsAltTabAble(hwnd)\r\n    && !IsIconic(hwnd)\r\n    && GetWindowRectL(state.hwnd, &refwnd)\r\n    && GetWindowRectL(hwnd, &wnd)\r\n    && (lasermode || StackedRectsT(&refwnd, &wnd, conf.SnapThreshold/2) )\r\n    && InflateRect(&wnd, conf.SnapThreshold, conf.SnapThreshold)\r\n    &&(state.ignorept || PtInRect(&wnd, state.prevpt))\r\n    ){\r\n        hwnds[numhwnds++] = hwnd;\r\n        LOG(\"EnumStackedWindowsProc found\");\r\n    } else {\r\n        LOG(\"EnumStackedWindowsProc skip\");\r\n    }\r\n    return TRUE;\r\n}\r\n////////////////////////////////////////////////////////////////////////////\r\n// Returns the GA_ROOT window if not MDI or MDIblacklist\r\nstatic HWND MDIorNOT(HWND hwnd, HWND *mdiclient_)\r\n{\r\n    HWND mdiclient = NULL;\r\n    HWND root = GetAncestor(hwnd, GA_ROOT);\r\n\r\n    if (conf.MDI && !blacklisted(root, &BlkLst.MDIs)) {\r\n        while (hwnd != root) {\r\n            HWND parent = GetParent(hwnd);\r\n            if (!parent)             return root;\r\n            else if (parent == hwnd) return hwnd;\r\n\r\n            LONG_PTR exstyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);\r\n            if ((exstyle&WS_EX_MDICHILD)) {\r\n                // Found MDI child, parent is now MDIClient window\r\n                mdiclient = parent;\r\n                break;\r\n            }\r\n            hwnd = parent;\r\n        }\r\n    } else {\r\n        hwnd = root;\r\n    }\r\n    *mdiclient_ = mdiclient;\r\n    return hwnd;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int ActionAltTab(POINT pt, short delta, short laser, WNDENUMPROC lpEnumFunc)\r\n{\r\n    numhwnds = 0;\r\n\r\n    if (conf.MDI) {\r\n        // Get Class name\r\n        HWND hwnd = WindowFromPoint(pt);\r\n        if (!hwnd) return 0;\r\n\r\n        // Get MDIClient\r\n        HWND mdiclient = NULL;\r\n        if (isClassName(hwnd, TEXT(\"MDIClient\"))) {\r\n            mdiclient = hwnd; // we are pointing to the MDI client!\r\n        } else {\r\n            MDIorNOT(hwnd, &mdiclient); // Get mdiclient from hwnd\r\n        }\r\n        // Enumerate and then reorder MDI windows\r\n        if (mdiclient) {\r\n            EnumChildWindows(mdiclient, lpEnumFunc, laser);\r\n\r\n            if (numhwnds > 1) {\r\n                if (delta > 0) {\r\n                    PostMessage(mdiclient, WM_MDIACTIVATE, (WPARAM) hwnds[numhwnds-1], 0);\r\n                } else {\r\n                    SetWindowLevel(hwnds[0], hwnds[numhwnds-1]);\r\n                    PostMessage(mdiclient, WM_MDIACTIVATE, (WPARAM) hwnds[1], 0);\r\n                }\r\n            }\r\n        }\r\n    } // End if MDI\r\n\r\n    // Enumerate windows\r\n    if (numhwnds <= 1) {\r\n        state.origin.monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\r\n        numhwnds = 0;\r\n        EnumDesktopWindows(NULL, lpEnumFunc, laser);\r\n        if (numhwnds <= 1) {\r\n            return 0;\r\n        }\r\n\r\n        // Reorder windows\r\n        if (delta > 0) {\r\n            ReallySetForegroundWindow(hwnds[numhwnds-1]);\r\n        } else {\r\n            SetWindowLevel(hwnds[0], hwnds[numhwnds-1]);\r\n            ReallySetForegroundWindow(hwnds[1]);\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Helper function with a stupid static accululator for\r\n// The wheel in case we have a fine wheel that is unable to\r\n// trigger a single step.\r\nstatic short ScaleDeltaAndAccum(short delta, short tar_delta)\r\n{\r\n    short step = ((int)tar_delta * (int)delta) / WHEEL_DELTA;\r\n    // Only accumulate\r\n    if( step == 0 )\r\n    { // step is too small, we need to accumulate delta\r\n        static short delta_acc = 0;\r\n        delta_acc += delta;\r\n        // Recalculate the step.\r\n        step = (tar_delta * delta_acc) / WHEEL_DELTA;\r\n        if( step == 0 )\r\n            return 0;\r\n        else // Reset the value (simpler)\r\n            delta_acc = 0;\r\n    }\r\n    return step;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Changes the Volume on Windows 2000+ using VK_VOLUME_UP/VK_VOLUME_DOWN\r\n// Also uses OLE API if available\r\n#ifndef NO_OLEAPI\r\nstatic const CLSID my_CLSID_MMDeviceEnumerator= {0xBCDE0395,0xE52F,0x467C,{0x8E,0x3D,0xC4,0x57,0x92,0x91,0x69,0x2E}};\r\nstatic const GUID  my_IID_IMMDeviceEnumerator = {0xA95664D2,0x9614,0x4F35,{0xA7,0x46,0xDE,0x8D,0xB6,0x36,0x17,0xE6}};\r\nstatic const GUID  my_IID_IAudioEndpointVolume= {0x5CDF2C82,0x841E,0x4546,{0x97,0x22,0x0C,0xF7,0x40,0x78,0x22,0x9A}};\r\n#define _WIN32_WINNT 0x0600\r\n#include <mmdeviceapi.h>\r\n#include <endpointvolume.h>\r\n#undef _WIN32_WINNT\r\n/* OLE32.DLL */\r\nstatic HRESULT (WINAPI *myCoInitialize)(LPVOID pvReserved);\r\nstatic VOID (WINAPI *myCoUninitialize)( );\r\nstatic HRESULT (WINAPI *myCoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID * ppv);\r\n\r\nstatic BOOL LoadOleDll()\r\n{\r\n\r\n    HINSTANCE h = LoadLibraryA(\"OLE32.DLL\");\r\n    if (!h) return FALSE;\r\n\r\n    myCoInitialize = (HRESULT (WINAPI *)(LPVOID))GetProcAddress(h, \"CoInitialize\");\r\n    myCoUninitialize= (VOID (WINAPI *)( ))GetProcAddress(h, \"CoUninitialize\");\r\n    myCoCreateInstance= (HRESULT (WINAPI *)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID *))GetProcAddress(h, \"CoCreateInstance\");\r\n    if (!myCoCreateInstance || !myCoUninitialize || !myCoInitialize) {\r\n        FreeLibrary(h);\r\n        return FALSE;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\nstatic BOOL LoadOLEDLLOnce()\r\n{\r\n    static char HaveV=-1;\r\n    if (HaveV == -1) {\r\n        HaveV = LoadOleDll();\r\n    }\r\n    return HaveV;\r\n}\r\n// Use IAudioEndpointVolume COM interface to determine current Volume (Vista+)\r\nstatic HRESULT GetCurrentVolumeMute(UINT *curentVol, UINT *maxVol, BOOL *muted)\r\n{\r\n    BYTE osver=LOBYTE(GetVersion());\r\n    if (osver >= 6 && LoadOLEDLLOnce()) {\r\n        HRESULT hr;\r\n        IMMDeviceEnumerator *pDevEnum = NULL;\r\n        IMMDevice *pDev = NULL;\r\n        IAudioEndpointVolume *pAudioEndp = NULL;\r\n\r\n        // Get audio endpoint\r\n        myCoInitialize(NULL); // Needed for IAudioEndpointVolume\r\n        hr = myCoCreateInstance(&my_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL\r\n                              , &my_IID_IMMDeviceEnumerator, (void**)&pDevEnum);\r\n        if (hr != S_OK) goto fail;\r\n\r\n        hr = pDevEnum->lpVtbl->GetDefaultAudioEndpoint(pDevEnum, eRender, eMultimedia, &pDev);\r\n        pDevEnum->lpVtbl->Release(pDevEnum);\r\n        if (hr != S_OK) goto fail;\r\n\r\n        hr = pDev->lpVtbl->Activate(pDev, &my_IID_IAudioEndpointVolume, CLSCTX_ALL, NULL, (void**)&pAudioEndp);\r\n        pDev->lpVtbl->Release(pDev);\r\n        if (hr != S_OK) goto fail;\r\n\r\n        hr = pAudioEndp->lpVtbl->GetVolumeStepInfo(pAudioEndp, curentVol, maxVol)\r\n           | pAudioEndp->lpVtbl->GetMute(pAudioEndp, muted);\r\n\r\n        pAudioEndp->lpVtbl->Release(pAudioEndp);\r\n\r\n        LOG(\"%d==GetVolumeStepInfo() -> %u (0 - %u) Muted=%d \", hr, curentVol, maxVol, muted);\r\n\r\n        fail:\r\n        myCoUninitialize();\r\n        return hr;\r\n    }\r\n    return E_NOTIMPL;\r\n}\r\n#endif\r\n// Under Vista this will change the main volume with ole interface,\r\nstatic void ActionVolume(int delta)\r\n{\r\n    int num = (state.shift)?5:1;\r\n    num = ScaleDeltaAndAccum(delta, num);\r\n    num = abs(num);\r\n    if(!num) return;\r\n\r\n    #ifndef NO_OLEAPI\r\n    UINT curentvol=0, maxvol=0;\r\n    BOOL muted=FALSE;\r\n    if (S_OK==GetCurrentVolumeMute(&curentvol, &maxvol, &muted) && curentvol) {\r\n        if( delta < 0 && (UINT)num >= curentvol ) {\r\n            // We would Set the volume to Zero\r\n            // We prefer to mute instead,\r\n            // because otherwise it resets volume balance.\r\n            if( !muted)\r\n                Send_KEY(VK_VOLUME_MUTE); // Mute\r\n            return;\r\n        } else if (delta > 0) {\r\n            if( muted ) {\r\n                Send_KEY(VK_VOLUME_MUTE); // UnMute\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    #endif // NO_OLEAPI\r\n    while (num--)\r\n        Send_KEY(delta>0? VK_VOLUME_UP: VK_VOLUME_DOWN);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Windows 2000+ Only\r\nstatic int ActionTransparency(HWND hwnd, short delta)\r\n{\r\n    static int alpha=255;\r\n\r\n    if (blacklisted(hwnd, &BlkLst.Windows)) return 0; // Spetial\r\n    if (MOUVEMENT(state.action)) SetWindowTrans((HWND)-1);\r\n\r\n    short pre_delta = (state.shift)? conf.AlphaDeltaShift: conf.AlphaDelta;\r\n    int alpha_delta = ScaleDeltaAndAccum(delta, pre_delta);\r\n    if (!alpha_delta) return 1;\r\n\r\n    LONG_PTR exstyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);\r\n    if (alpha_delta < 0 && !(exstyle&WS_EX_LAYERED)) {\r\n        // Add layered attribute to be able to change alpha\r\n        SetWindowLongPtr(hwnd, GWL_EXSTYLE, exstyle|WS_EX_LAYERED);\r\n        SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);\r\n    }\r\n\r\n    BYTE old_alpha;\r\n    if (GetLayeredWindowAttributes(hwnd, NULL, &old_alpha, NULL)) {\r\n         alpha = old_alpha; // If possible start from the current aplha.\r\n    }\r\n\r\n    alpha = CLAMP(conf.MinAlpha, alpha+alpha_delta, 255); // Limit alpha\r\n\r\n    if (alpha >= 255) // Remove layered attribute if opacity is 100%\r\n        SetWindowLongPtr(hwnd, GWL_EXSTYLE, exstyle & ~WS_EX_LAYERED);\r\n    else\r\n        SetLayeredWindowAttributes(hwnd, 0, alpha, LWA_ALPHA);\r\n\r\n    return 1;\r\n}\r\nstatic void SetBottomMost(HWND hwnd)\r\n{\r\n    HWND lowhwnd = HWND_BOTTOM; // Lowest hwnd to consider.\r\n\r\n    if(!blacklisted(hwnd, &BlkLst.Bottommost)) {\r\n        // Ignore bottommost list if the lowered windows is also part of it.\r\n        HWND tmph=hwnd;\r\n        int i=0;\r\n        while ((tmph = GetNextWindow(tmph, GW_HWNDNEXT)) && i++ < 1024) {\r\n            if (IsVisible(tmph)\r\n            && !IsIconic(tmph)\r\n            && blacklisted(tmph, &BlkLst.Bottommost)) {\r\n                lowhwnd = GetNextWindow(tmph, GW_HWNDPREV);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (lowhwnd) SetWindowLevel(hwnd, lowhwnd);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int xpure IsAeraCapbutton(int area);\r\nstatic void ActionLower(HWND hwnd, short delta, UCHAR shift, UCHAR fg)\r\n{\r\n    if (delta > 0) {\r\n        if (shift) {\r\n            ToggleMaxRestore(hwnd);\r\n        } else {\r\n            if (conf.AutoFocus || fg) SetForegroundWindowL(hwnd);\r\n            SetWindowLevel(hwnd, HWND_TOPMOST);\r\n            SetWindowLevel(hwnd, HWND_NOTOPMOST);\r\n        }\r\n    } else if (delta == 0 && (state.ctrl || IsAeraCapbutton(state.hittest))) {\r\n        // turn lower in *Always on top* if Ctrl or [_][O][X]\r\n        TogglesAlwaysOnTop(hwnd);\r\n    } else {\r\n        if (shift) {\r\n            MinimizeWindow(hwnd);\r\n        } else {\r\n            if(hwnd == GetAncestor(GetForegroundWindow(), GA_ROOT)) {\r\n                HWND tmp = GetWindow(hwnd, GW_HWNDNEXT);\r\n                if(!tmp) tmp = GetWindow(hwnd, GW_HWNDPREV);\r\n                if(tmp && hwnd != GetAncestor(tmp, GA_ROOT))\r\n                    SetForegroundWindowL(tmp);\r\n            }\r\n            // Takes bottommost blacklist into account.\r\n            SetBottomMost(hwnd);\r\n        }\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void ActionMaxRestMin(HWND hwnd, int delta)\r\n{\r\n    int maximized = IsZoomed(hwnd);\r\n    if (state.shift) {\r\n        ActionLower(hwnd, delta, 0, state.ctrl);\r\n        return;\r\n    }\r\n\r\n    if (delta > 0) {\r\n        if (!maximized && IsResizable(hwnd))\r\n            MaximizeWindow(hwnd);\r\n    } else {\r\n        if (maximized)\r\n            RestoreWindow(hwnd);\r\n        else\r\n            MinimizeWindow(hwnd);\r\n    }\r\n    if (conf.AutoFocus) SetForegroundWindowL(hwnd);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Adjust brightness\r\nstatic void ActionBrightness(const POINT pt, const short delta)\r\n{\r\n// Works oly for Desktop monitors.\r\n#ifndef NO_BRIGHTNESS\r\n    typedef struct _PHYSICAL_MONITOR {\r\n        HANDLE hPhysicalMonitor;\r\n        WCHAR  szPhysicalMonitorDescription[128];\r\n    } PHYSICAL_MONITOR, *LPPHYSICAL_MONITOR;\r\n    enum { MC_CAPS_BRIGHTNESS=2 };\r\n\r\n    BOOL (WINAPI *myGetPhysMonitorsFromHM)(HMONITOR hMonitor, DWORD sz, LPPHYSICAL_MONITOR pmarr);\r\n    BOOL (WINAPI *myGetMonitorBrightness)(HANDLE hMonitor, LPDWORD min, LPDWORD cur, LPDWORD max);\r\n    BOOL (WINAPI *mySetMonitorBrightness)(HANDLE hMonitor, DWORD dwNewBrightness);\r\n    BOOL (WINAPI *myDestroyPhysicalMonitors)(DWORD cnt, LPPHYSICAL_MONITOR pmarr);\r\n    BOOL (WINAPI *myGetNumberOfPhysmons)(HMONITOR hMonitor, LPDWORD pdwNumberOfPhysicalMonitors);\r\n    BOOL (WINAPI *myGetMonitorCapabilities)(HANDLE hMonitor, LPDWORD supcap, LPDWORD supcoltemp);\r\n    HMODULE dll = LoadLibraryA(\"DXVA2.DLL\");\r\n    if (dll) {\r\n        int ok;\r\n        PHYSICAL_MONITOR *pm;\r\n        DWORD dwMCap=0, wdColtemp=0;\r\n        DWORD numpm=0;\r\n        HMONITOR hmon;\r\n\r\n        LOG(\"DXVA2.DLL Loaded\");\r\n        myGetPhysMonitorsFromHM =(BOOL (WINAPI *)(HMONITOR , DWORD , LPPHYSICAL_MONITOR))\r\n            GetProcAddress(dll, \"GetPhysicalMonitorsFromHMONITOR\");\r\n        myGetMonitorBrightness = (BOOL (WINAPI *)(HANDLE, LPDWORD, LPDWORD, LPDWORD))\r\n            GetProcAddress(dll, \"GetMonitorBrightness\");\r\n        mySetMonitorBrightness = (BOOL (WINAPI *)(HANDLE , DWORD ))\r\n            GetProcAddress(dll, \"SetMonitorBrightness\");\r\n        myDestroyPhysicalMonitors=(BOOL (WINAPI *)(DWORD, LPPHYSICAL_MONITOR))\r\n            GetProcAddress(dll, \"DestroyPhysicalMonitors\");\r\n        myGetNumberOfPhysmons   =(BOOL (WINAPI *)(HMONITOR, LPDWORD))\r\n            GetProcAddress(dll, \"GetNumberOfPhysicalMonitorsFromHMONITOR\");\r\n        myGetMonitorCapabilities=(BOOL (WINAPI *)(HANDLE, LPDWORD, LPDWORD))\r\n            GetProcAddress(dll, \"GetMonitorCapabilities\");\r\n\r\n        if (!(myGetPhysMonitorsFromHM && myGetMonitorBrightness\r\n        && mySetMonitorBrightness && myDestroyPhysicalMonitors\r\n        && myGetNumberOfPhysmons && myGetMonitorCapabilities))\r\n            goto fail;\r\n\r\n        LOG(\"We got Monitor Brightness functions!\");\r\n        hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\r\n\r\n        if (!hmon || !myGetNumberOfPhysmons(hmon, &numpm) || !numpm) {\r\n            LOG(\"GetNumberOfPhysmons(%x) failed\", (UINT)(UINT_PTR)hmon);\r\n            goto fail;\r\n        }\r\n\r\n        LOG(\"NumberOfPhysmons=%lu\", numpm);\r\n        pm = (PHYSICAL_MONITOR *)calloc(numpm, sizeof(PHYSICAL_MONITOR));\r\n        if( !pm ) goto fail;\r\n        pm->szPhysicalMonitorDescription[0] = '\\0';\r\n        if (!myGetPhysMonitorsFromHM(hmon, numpm, pm)) {\r\n            LOG(\"Unable to get PhysicalMonitor\");\r\n            goto fail;\r\n        }\r\n        LOG( \"Physical Monitor=%x, %ls\", pm->hPhysicalMonitor, pm->szPhysicalMonitorDescription);\r\n\r\n        ok = myGetMonitorCapabilities(pm->hPhysicalMonitor, &dwMCap, &wdColtemp);\r\n        LOG(\"GetMonitorCapabilities()=%d => CAP=%lx\", ok, dwMCap);\r\n        if (ok && MC_CAPS_BRIGHTNESS & dwMCap) {\r\n            DWORD min=0, cur=0, max=0;\r\n            ok = myGetMonitorBrightness(pm->hPhysicalMonitor, &min, &cur, &max);\r\n            LOG(\"GetMonitorBrightness()=%d\", ok);\r\n            LOG(\"Brightness of %ls: min=%lu, cur=%lu, max=%lu\" , pm->szPhysicalMonitorDescription, min, cur, max);\r\n            if (ok) {\r\n                int step = max(1, (max-min)/20);\r\n                int newbr = cur + (delta>0? step: -step);\r\n                newbr = CLAMP(min, newbr, max);\r\n                ok = mySetMonitorBrightness(pm->hPhysicalMonitor, newbr);\r\n                LOG( \"SetMonitorBrightness(%x, %d)=%d\", (UINT)(UINT_PTR)pm->hPhysicalMonitor, newbr, ok);\r\n            }\r\n        }\r\n\r\n        ok = myDestroyPhysicalMonitors(numpm, pm);\r\n        LOG( \"DestroyPhysicalMonitors(%lu, %x)=%d\", numpm, (UINT)(UINT_PTR)pm, ok);\r\n        free(pm);\r\n\r\n        fail:\r\n        LOG(\"Free DXVA2.DLL\");\r\n        FreeLibrary(dll);\r\n    }\r\n#endif //NO_BRIGHTNESS\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic HCURSOR CursorToDraw()\r\n{\r\n    HCURSOR cursor;\r\n\r\n    if (conf.UseCursor == 3) {\r\n        return LoadCursor(NULL, IDC_ARROW);\r\n    }\r\n    if (state.action == AC_MOVE) {\r\n        if (conf.UseCursor == 4)\r\n            return LoadCursor(NULL, IDC_SIZEALL);\r\n        cursor = LoadCursor(NULL, conf.UseCursor>1? IDC_ARROW: IDC_HAND);\r\n        if (!cursor) cursor = LoadCursor(NULL, IDC_ARROW); // Fallback;\r\n        return cursor;\r\n    }\r\n\r\n    if ((state.resize.y == RZ_TOP && state.resize.x == RZ_LEFT)\r\n     || (state.resize.y == RZ_BOTTOM && state.resize.x == RZ_RIGHT)) {\r\n        return LoadCursor(NULL, IDC_SIZENWSE);\r\n    } else if ((state.resize.y == RZ_TOP && state.resize.x == RZ_RIGHT)\r\n     || (state.resize.y == RZ_BOTTOM && state.resize.x == RZ_LEFT)) {\r\n        return LoadCursor(NULL, IDC_SIZENESW);\r\n    } else if ((state.resize.y == RZ_TOP && state.resize.x == RZ_XCENTER)\r\n     || (state.resize.y == RZ_BOTTOM && state.resize.x == RZ_XCENTER)) {\r\n        return LoadCursor(NULL, IDC_SIZENS);\r\n    } else if ((state.resize.y == RZ_YCENTER && state.resize.x == RZ_LEFT)\r\n     || (state.resize.y == RZ_YCENTER && state.resize.x == RZ_RIGHT)) {\r\n        return LoadCursor(NULL, IDC_SIZEWE);\r\n    } else {\r\n        return LoadCursor(NULL, IDC_SIZEALL);\r\n    }\r\n}\r\nstatic void UpdateCursor(POINT pt)\r\n{\r\n    // Update cursor\r\n    if (conf.UseCursor && g_mainhwnd) {\r\n        SetClassLongPtr(g_mainhwnd, GCLP_HCURSOR, (LONG_PTR)CursorToDraw());\r\n        ShowWindow(g_mainhwnd, SW_SHOWNA);\r\n        SetWindowPos(g_mainhwnd, HWND_TOPMOST, pt.x-8, pt.y-8, 16, 16\r\n            , SWP_NOACTIVATE|SWP_NOREDRAW|SWP_DEFERERASE|SWP_NOSENDCHANGING);\r\n\r\n    }\r\n}\r\n\r\nstatic int IsMXRolled(HWND hwnd, const RECT *rc)\r\n{\r\n    MONITORINFO mi;\r\n    GetMonitorInfoFromWin(hwnd, &mi);\r\n    // Consider the window rolled if its height less than a quarter of monitors\r\n    return (rc->bottom - rc->top) < (mi.rcWork.bottom - mi.rcWork.top) / 4;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Roll/Unroll Window. If delta > 0: Roll if < 0: Unroll if == 0: Toggle.\r\nstatic void RollWindow(HWND hwnd, int delta)\r\n{\r\n    // if the window is maximized do a spetial\r\n    // treatement with no restore flags\r\n    RECT rc;\r\n    GetWindowRect(hwnd, &rc);\r\n\r\n    if (IsZoomed(hwnd)) {\r\n        int ismxrolled = IsMXRolled(hwnd, &rc);\r\n        if (delta <= 0 && ismxrolled) {\r\n            // Unroll Maximized window\r\n            WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n            GetWindowPlacement(hwnd, &wndpl);\r\n            wndpl.showCmd = SW_SHOWMINIMIZED;\r\n            SetWindowPlacement(hwnd, &wndpl);\r\n            wndpl.showCmd = SW_SHOWMAXIMIZED;\r\n            SetWindowPlacement(hwnd, &wndpl);\r\n        } else if(delta >= 0 && !ismxrolled) {\r\n            // Roll maximized window\r\n            SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left\r\n                  , GetSystemMetrics(SM_CYMIN)\r\n                  , SWP_NOMOVE|SWP_NOZORDER|SWP_NOSENDCHANGING|SWP_ASYNCWINDOWPOS);\r\n\r\n        }\r\n        return;\r\n    }\r\n    // Handle non maximized windows\r\n    unsigned restore = GetRestoreFlag(hwnd);\r\n\r\n    if (restore&ROLLED && delta <= 0) { // UNROLL\r\n        // Restore the Old height\r\n        // Set origin width and height to the saved values\r\n        int width, height;\r\n        GetRestoreData(hwnd, &width, &height);\r\n        width = rc.right - rc.left; // keep current width\r\n        ClearRestoreData(hwnd);\r\n         SetWindowPos(hwnd, NULL, 0, 0, width, height\r\n                , SWP_NOSENDCHANGING|SWP_NOZORDER|SWP_NOMOVE|SWP_ASYNCWINDOWPOS);\r\n\r\n    } else if (((!(restore&ROLLED) && delta == 0)) || delta > 0 ) { // ROLL\r\n        if (!(restore & ROLLED)) { // Save window size if not saved already.\r\n            SetRestoreData(hwnd, rc.right - rc.left, rc.bottom - rc.top, 0);\r\n            // Add the SNAPPED falg is maximized and and add the SNTHENROLLED flag is snapped\r\n            SetRestoreFlag(hwnd, ROLLED|IsWindowSnapped(hwnd)<<10);\r\n        }\r\n        SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left\r\n              , GetSystemMetrics(SM_CYMIN)\r\n              , SWP_NOMOVE|SWP_NOZORDER|SWP_NOSENDCHANGING|SWP_ASYNCWINDOWPOS);\r\n    }\r\n}\r\n\r\nstatic int ActionZoom(HWND hwnd, short delta, short center)\r\n{\r\n    if(!IsResizable(hwnd)) return 0;\r\n\r\n    RECT rc, orc;\r\n    GetWindowRect(hwnd, &rc);\r\n    if (IsZoomed(hwnd)) RestoreToMonitorSize(hwnd, &rc);\r\n    ClearRestoreFlagOnResizeIfNeeded(hwnd);\r\n    SetEdgeAndOffset(&rc, state.prevpt);\r\n    OffsetRectMDI(&rc);\r\n    CopyRect(&orc, &rc);\r\n\r\n    int left=0, right=0, top=0, bottom=0;\r\n    int div = state.shift ? conf.ZoomFracShift: conf.ZoomFrac;\r\n    // We increase/decrease at least 1 pixel or SnapThreshold/2.\r\n    UCHAR T = state.shift? 1: conf.SnapThreshold/2+1;\r\n    UCHAR CT = !center ^ !state.ctrl\r\n             || (state.resize.x == RZ_XCENTER && state.resize.y == RZ_YCENTER);\r\n\r\n    if (!conf.AutoSnap\r\n    || (CT && (state.resize.x == RZ_XCENTER || state.resize.y == RZ_YCENTER)) )\r\n    {   // Try to conserve a bit better the aspect ratio when in center mode.\r\n        T = 1; // Or when no snapping has to occur.\r\n    }\r\n\r\n    GetMinMaxInfo(hwnd, &state.mmi.Min, &state.mmi.Max); // for CLAMPH/W functions\r\n\r\n    if (state.resize.x == RZ_LEFT) {\r\n        right = max(T, (rc.right-rc.left)/div);\r\n        state.resize.x = RZ_RIGHT;\r\n    } else if (state.resize.x == RZ_RIGHT) {\r\n        left  = max(T, (rc.right-rc.left)/div);\r\n        state.resize.x = RZ_LEFT;\r\n    } else if (state.resize.x == RZ_XCENTER && CT) {\r\n        left  = max(T, (state.prevpt.x-rc.left)  /div);\r\n        right = max(T, (rc.right-state.prevpt.x) /div);\r\n    }\r\n\r\n    if (state.resize.y == RZ_TOP) {\r\n        bottom = max(T, (rc.bottom-rc.top)/div);\r\n        state.resize.y = RZ_BOTTOM;\r\n    } else if (state.resize.y == RZ_BOTTOM) {\r\n        top    = max(T, (rc.bottom-rc.top)/div);\r\n        state.resize.y = RZ_TOP;\r\n    } else if (state.resize.y == RZ_YCENTER && CT) {\r\n        top   = max(T, (state.prevpt.y-rc.top)   /div);\r\n        bottom= max(T, (rc.bottom-state.prevpt.y)/div);\r\n    }\r\n    if (delta < 0) {\r\n        // Zoom out\r\n        rc.left += left;\r\n        rc.right -= right;\r\n        rc.top += top;\r\n        rc.bottom -= bottom;\r\n    } else {\r\n        // Zoom in\r\n        rc.left -= left;\r\n        rc.right +=right;\r\n        rc.top -= top;\r\n        rc.bottom += bottom;\r\n    }\r\n\r\n    int x = rc.left, y = rc.top, width = rc.right-rc.left, height= rc.bottom-rc.top;\r\n\r\n    state.hwnd = hwnd;\r\n    state.snap = conf.AutoSnap; // Only use autosnap setting.\r\n\r\n    ResizeSnap(&x, &y, &width, &height\r\n              , min( max(left, right)-1, conf.SnapThreshold )  // initial x threshold\r\n              , min( max(top, bottom)-1, conf.SnapThreshold ) );// initial y threshold\r\n    // Make sure that the windows does not move\r\n    // in case it is resized from bottom/right\r\n    if (state.resize.x == RZ_LEFT) x = x+width - CLAMPW(width);\r\n    if (state.resize.y == RZ_TOP) y = y+height - CLAMPH(height);\r\n    // Avoid runaway effect when zooming in/out too much.\r\n    if (state.resize.x == RZ_XCENTER && !ISCLAMPEDW(width)) x = orc.left;\r\n    if (state.resize.y == RZ_YCENTER && !ISCLAMPEDH(height)) y = orc.top;\r\n    width = CLAMPW(width); // Double check\r\n    height = CLAMPH(height);\r\n\r\n    MoveWindowAsync(hwnd, x, y, width, height);\r\n    return 1;\r\n}\r\nstatic int IsDoubleClick(int button)\r\n{ // Never validate a double-click if the click has to pierce\r\n    return !conf.PiercingClick && state.clickbutton == button\r\n        && GetTickCount()-state.clicktime <= GetDoubleClickTime();\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int ActionMove(POINT pt, int button)\r\n{\r\n    // If this is a double-click\r\n    if (IsDoubleClick(button)) {\r\n        SetOriginFromRestoreData(state.hwnd, AC_MOVE);\r\n        LastWin.hwnd = NULL;\r\n        if (state.shift) {\r\n            RollWindow(state.hwnd, 0); // Roll/Unroll Window...\r\n        } else if (state.ctrl) {\r\n            MinimizeWindow(state.hwnd);\r\n        } else if (state.resizable) {\r\n            // Toggle Maximize window\r\n            state.action = AC_NONE; // Stop move action\r\n            state.clicktime = 0; // Reset double-click time\r\n            state.blockmouseup = 1; // Block the mouseup, otherwise it can trigger a context menu\r\n            ToggleMaxRestore(state.hwnd);\r\n        }\r\n        // Prevent mousedown from propagating\r\n        return 1;\r\n    } else if (conf.MMMaximize&2) {\r\n        MouseMove(pt); // Restore with simple Click\r\n    } else if (conf.DragThreshold >= 2 || (conf.DragThreshold == 1 && IsAnySnapped(state.hwnd))) {\r\n        // Wait some move threshold before drag...\r\n        // If the Window was maximized or if the user enabled the option.\r\n        state.moving = DRAG_WAIT;\r\n    }\r\n\r\n    return -1;\r\n}\r\nstatic void SetEdgeAndOffsetCF(const RECT *wnd, const UCHAR centerfrac, POINT pt)\r\n{\r\n    // Set edge and offset\r\n    // Think of the window as nine boxes (corner regions get 38%, middle only 24%)\r\n    // Does not use state.origin.width/height since that is based on wndpl.rcNormalPosition\r\n    // which is not what you see when resizing a window that Windows Aero resized\r\n    int wndwidth  = wnd->right  - wnd->left;\r\n    int wndheight = wnd->bottom - wnd->top;\r\n    int SideS = (100-centerfrac)/2;\r\n    int CenteR = 100-SideS;\r\n\r\n    if (pt.x-wnd->left < (wndwidth*SideS)/100) {\r\n        state.resize.x = RZ_LEFT;\r\n        state.offset.x = pt.x-wnd->left;\r\n    } else if (pt.x-wnd->left < (wndwidth*CenteR)/100) {\r\n        state.resize.x = RZ_XCENTER;\r\n        state.offset.x = pt.x-state.mdipt.x; // Used only if both x and y are CENTER\r\n    } else {\r\n        state.resize.x = RZ_RIGHT;\r\n        state.offset.x = wnd->right-pt.x;\r\n    }\r\n    if (pt.y-wnd->top < (wndheight*SideS)/100) {\r\n        state.resize.y = RZ_TOP;\r\n        state.offset.y = pt.y-wnd->top;\r\n    } else if (pt.y-wnd->top < (wndheight*CenteR)/100) {\r\n        state.resize.y = RZ_YCENTER;\r\n        state.offset.y = pt.y-state.mdipt.y;\r\n    } else {\r\n        state.resize.y = RZ_BOTTOM;\r\n        state.offset.y = wnd->bottom-pt.y;\r\n    }\r\n    // Set window right/bottom origin\r\n    state.origin.right = wnd->right-state.mdipt.x;\r\n    state.origin.bottom = wnd->bottom-state.mdipt.y;\r\n}\r\n\r\n// Use disgonals to determine the closest side.\r\nstatic void SetEdgeToClosestSide(const RECT *wnd, const POINT pt)\r\n{\r\n    const int W = wnd->right - wnd->left;\r\n    const int H = wnd->bottom - wnd->top;\r\n    const int x = pt.x - wnd->left;\r\n    const int y = pt.y - wnd->top;\r\n    char TR = y * W     <= H * x; // T/C or R/C mode\r\n    char TL = (H-y) * W >= H * x; // B/C or C/C mode\r\n    if (TR) { // Top or right\r\n        if (TL) {\r\n            state.resize.y = RZ_TOP;\r\n            state.offset.y = pt.y-wnd->top;\r\n        } else {\r\n            state.resize.x = RZ_RIGHT;\r\n            state.offset.x = wnd->right-pt.x;\r\n        }\r\n    } else { // Bottom or Left\r\n        if (TL) { // Bottom right\r\n            state.resize.x = RZ_LEFT;\r\n            state.offset.x = pt.x-wnd->left;\r\n        } else {\r\n            state.resize.y = RZ_BOTTOM;\r\n            state.offset.y = wnd->bottom-pt.y;\r\n        }\r\n    }\r\n}\r\nstatic void SetEdgeAndOffset(const RECT *wnd, const POINT pt)\r\n{\r\n    SetEdgeAndOffsetCF(wnd, conf.CenterFraction, pt);\r\n    if (conf.SidesFraction == conf.CenterFraction) {\r\n        // Classic 9 quadrent mode\r\n        return;\r\n    }\r\n    // Special mode.\r\n    if (state.resize.x != RZ_XCENTER || state.resize.y != RZ_YCENTER) {\r\n        SetEdgeAndOffsetCF(wnd, conf.SidesFraction, pt);\r\n        if (conf.SidesFraction < conf.CenterFraction) {\r\n        } else { // (SidesFraction > CenterFraction)\r\n            SetEdgeToClosestSide(wnd, pt);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nstatic void NextBorders(RECT *pos, const RECT *cur, const RECT *def)\r\n{\r\n    unsigned i;\r\n    CopyRect(pos, def);\r\n    for (i=0; i<numsnwnds; i++) {\r\n        const RECT *rc = &snwnds[i].wnd;\r\n        const unsigned flg = snwnds[i].flag;\r\n        POINT tpt;\r\n        tpt.x =  (rc->left+rc->right)/2; tpt.y = (rc->top+rc->bottom)/2;\r\n        if (!PtInRect(def, tpt) )\r\n            continue;\r\n\r\n        if (flg&(SNZONE|SNLEFT)   && rc->right < cur->left) pos->left   = max(pos->left, rc->right);\r\n        if (flg&(SNZONE|SNTOP)    && rc->bottom < cur->top) pos->top    = max(pos->top, rc->bottom);\r\n        if (flg&(SNZONE|SNRIGHT)  && rc->left > cur->right) pos->right  = min(pos->right, rc->left);\r\n        if (flg&(SNZONE|SNBOTTOM) && rc->top > cur->bottom) pos->bottom = min(pos->bottom, rc->top);\r\n    }\r\n}\r\n#define SNTO_CNSNAP 0\r\n#define SNTO_EXTEND 1\r\n#define SNTO_NEXTBD 2\r\n#define SNTO_MOVETO 4\r\nstatic void SnapToCorner(HWND hwnd, struct resizeXY resize, UCHAR flags)\r\n{\r\n    // When trying to Snap or extend a non-resizeable window\r\n    if (!(flags&SNTO_MOVETO) && !IsResizable(hwnd))\r\n        flags = SNTO_MOVETO | SNTO_NEXTBD; // Move to next bd instead\r\n\r\n    SetOriginFromRestoreData(hwnd, AC_MOVE);\r\n    GetMinMaxInfo(hwnd, &state.mmi.Min, &state.mmi.Max); // for CLAMPH/W functions\r\n\r\n    // Get and set new position\r\n    int posx, posy; // wndwidth and wndheight are defined above\r\n    unsigned restore = 1;\r\n    RECT *mon = &state.origin.mon;\r\n    RECT bd, wnd;\r\n    GetWindowRect(hwnd, &wnd);\r\n    SetEdgeAndOffset(&wnd, state.prevpt); // state.resize.x/y & state.offset.x/y\r\n    if (!resize.x && !resize.y)\r\n        resize = state.resize;\r\n    FixDWMRect(hwnd, &bd);\r\n    int wndwidth  = wnd.right  - wnd.left;\r\n    int wndheight = wnd.bottom - wnd.top;\r\n\r\n    RECT tmp;\r\n\r\n    if (flags & SNTO_NEXTBD) {\r\n        // Find next borders in each direction and set it up as monitor.\r\n        EnumSnapped();\r\n        RECT vwnd;\r\n        GetWindowRectL(hwnd, &vwnd);\r\n        NextBorders(&tmp, &vwnd, mon);\r\n        mon = &tmp;\r\n    }\r\n    if (flags & SNTO_EXTEND) {\r\n    /* Extend window's borders to monitor/Next border */\r\n        posx = wnd.left - state.mdipt.x;\r\n        posy = wnd.top - state.mdipt.y;\r\n\r\n        if (resize.y == RZ_TOP) {\r\n            posy = mon->top - bd.top;\r\n            wndheight = CLAMPH(wnd.bottom-state.mdipt.y - mon->top + bd.top);\r\n        } else if (resize.y == RZ_BOTTOM) {\r\n            wndheight = CLAMPH(mon->bottom - wnd.top+state.mdipt.y + bd.bottom);\r\n        }\r\n        if (resize.x == RZ_RIGHT) {\r\n            wndwidth =  CLAMPW(mon->right - wnd.left+state.mdipt.x + bd.right);\r\n        } else if (resize.x == RZ_LEFT) {\r\n            posx = mon->left - bd.left;\r\n            wndwidth =  CLAMPW(wnd.right-state.mdipt.x - mon->left + bd.left);\r\n        } else if (resize.x == RZ_XCENTER && resize.y == RZ_YCENTER) {\r\n            wndwidth = CLAMPW(mon->right - mon->left + bd.left + bd.right);\r\n            posx = mon->left - bd.left;\r\n            posy = wnd.top - state.mdipt.y + bd.top ;\r\n            restore |= SNMAXW;\r\n        }\r\n    } else if (flags & SNTO_MOVETO) {\r\n    /* Move the windows to a border (monitor or next border) */\r\n        posx = wnd.left - state.mdipt.x;\r\n        posy = wnd.top - state.mdipt.y;\r\n        if (resize.x == RZ_LEFT) {\r\n            posx =  mon->left - bd.left;\r\n        } else if (resize.x == RZ_RIGHT) {\r\n            posx = mon->right + bd.right - wndwidth;\r\n        }\r\n        if (resize.y == RZ_TOP) {\r\n            posy =  mon->top - bd.top;\r\n        } else if (resize.y == RZ_BOTTOM) {\r\n            posy = mon->bottom + bd.bottom - wndheight;\r\n        }\r\n    } else { /* Aero Snap to corresponding side/corner */\r\n        int leftWidth, rightWidth, topHeight, bottomHeight;\r\n        // EnumSnapped();\r\n        GetAeroSnappingMetrics(&leftWidth, &rightWidth, &topHeight, &bottomHeight, mon);\r\n        wndwidth =  leftWidth;\r\n        wndheight = topHeight;\r\n        posx = mon->left;\r\n        posy = mon->top;\r\n        restore = SNTOPLEFT;\r\n\r\n        if (resize.y == RZ_YCENTER) {\r\n            wndheight = CLAMPH(mon->bottom - mon->top); // Max Height\r\n            posy += (mon->bottom - mon->top)/2 - wndheight/2;\r\n            restore &= ~SNTOP;\r\n        } else if (resize.y == RZ_BOTTOM) {\r\n            wndheight = bottomHeight;\r\n            posy = mon->bottom - wndheight;\r\n            restore &= ~SNTOP;\r\n            restore |= SNBOTTOM;\r\n        }\r\n\r\n        if (resize.x == RZ_XCENTER && resize.y != RZ_YCENTER) {\r\n            wndwidth = CLAMPW( (mon->right-mon->left) ); // Max width\r\n            posx += (mon->right - mon->left)/2 - wndwidth/2;\r\n            restore &= ~SNLEFT;\r\n        } else if (resize.x == RZ_XCENTER) {\r\n            restore &= ~SNLEFT;\r\n            if(resize.y == RZ_YCENTER) {\r\n                restore |= SNMAXH;\r\n                if(state.ctrl) {\r\n                    LastWin.hwnd = NULL;\r\n                    ToggleMaxRestore(hwnd);\r\n                    return;\r\n                }\r\n            }\r\n            wndwidth = wnd.right - wnd.left - bd.left - bd.right;\r\n            posx = wnd.left - state.mdipt.x + bd.left;\r\n        } else if (resize.x == RZ_RIGHT) {\r\n            wndwidth = rightWidth;\r\n            posx = mon->right - wndwidth;\r\n            restore |= SNRIGHT;\r\n            restore &= ~SNLEFT;\r\n        }\r\n        // FixDWMRect\r\n        posx -= bd.left; posy -= bd.top;\r\n        wndwidth += bd.left+bd.right; wndheight += bd.top+bd.bottom;\r\n    }\r\n    MoveWindowAsync(hwnd, posx, posy, wndwidth, wndheight);\r\n    // Save data to the window...\r\n    if ( !(GetRestoreFlag(hwnd)&SNAPPED) )\r\n        SetRestoreData(hwnd, state.origin.width, state.origin.height, SNAPPED|restore);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int ActionResize(POINT pt, const RECT *wnd, int button)\r\n{\r\n    if(!state.resizable) {\r\n        state.action = AC_NONE;\r\n        return 0;// Next Hook\r\n    }\r\n    // Aero-move this window if this is a double-click\r\n    if (IsDoubleClick(button)) {\r\n        state.action = AC_NONE; // Stop resize action\r\n        SnapToCorner(state.hwnd, AUTORESIZE, !state.shift ^ !(conf.AeroTopMaximizes&2));\r\n        state.blockmouseup = 1; // Block mouse up (context menu would pop)\r\n        state.clicktime = 0;    // Reset double-click time\r\n        // Prevent mousedown from propagating\r\n        return 1;\r\n    }\r\n    SetEdgeAndOffset(wnd, pt);\r\n    if (state.resize.y == RZ_YCENTER && state.resize.x == RZ_XCENTER) {\r\n        if (conf.ResizeCenter == 0) {\r\n            // Use Bottom Right Mode\r\n            state.resize.x = RZ_RIGHT;\r\n            state.resize.y = RZ_BOTTOM;\r\n            state.offset.y = wnd->bottom-pt.y;\r\n            state.offset.x = wnd->right-pt.x;\r\n        } else if (conf.ResizeCenter == 2) {\r\n            // Switch to Move action\r\n            state.action = AC_MOVE;\r\n        } else if (conf.ResizeCenter == 3) {\r\n            // Use diagonals to select pure L/C R/C T/C B/C\r\n            SetEdgeToClosestSide(wnd, pt);\r\n        }\r\n    }\r\n    if (conf.DragThreshold >= 3) {\r\n        state.moving = DRAG_WAIT;\r\n    }\r\n    return -1;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void ActionBorderless(HWND hwnd)\r\n{\r\n    LONG_PTR style=0;\r\n    // Get anc clear eventual old style.\r\n    LONG_PTR ostyle = ClearBorderlessFlag(hwnd);\r\n    if (ostyle) {\r\n        // Restore old style if found\r\n        style = ostyle;\r\n    } else {\r\n        style=GetWindowLongPtr(hwnd, GWL_STYLE);\r\n        if (!style) return;\r\n        SetBorderlessFlag(hwnd, style); // Save style\r\n        if((style&WS_CAPTION) == WS_CAPTION || style&WS_THICKFRAME) {\r\n            style &= state.shift? ~WS_CAPTION: ~(WS_CAPTION|WS_THICKFRAME);\r\n        } else {\r\n            style |= WS_OVERLAPPEDWINDOW;\r\n        }\r\n    }\r\n    SetWindowLongPtr(hwnd, GWL_STYLE, style);\r\n\r\n    // Under Windows 10, with DWM we HAVE to resize the windows twice\r\n    // to have proper drawing. this is a bug.\r\n    RECT rc;\r\n    GetWindowRect(hwnd, &rc);\r\n    SetWindowPos(hwnd, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top+1\r\n               , SWP_ASYNCWINDOWPOS|SWP_NOMOVE|SWP_FRAMECHANGED|SWP_NOZORDER);\r\n    SetWindowPos(hwnd, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top\r\n               , SWP_ASYNCWINDOWPOS|SWP_NOMOVE|SWP_NOZORDER);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n#define CW_RESTORE (1<<0)\r\n#define CW_TRIM    (1<<1)\r\nstatic void CenterWindow(HWND hwnd, unsigned flags)\r\n{\r\n    RECT mon;// = state.origin.mon;\r\n    POINT pt;\r\n    int width, height;\r\n    if (flags & CW_RESTORE) {\r\n        SetOriginFromRestoreData(hwnd, AC_MOVE);\r\n        width = state.origin.width;\r\n        height = state.origin.height;\r\n    } else {\r\n        RECT rc;\r\n        GetWindowRect(hwnd, &rc);\r\n        width = rc.right - rc.left;\r\n        height = rc.bottom - rc.top;\r\n    }\r\n    GetCursorPos(&pt);\r\n    GetMonitorRect(&pt, 0, &mon);\r\n\r\n    RECT bd;\r\n    FixDWMRectLL(hwnd, &bd, 0);\r\n\r\n    // extra calculation to centre the portion that is inside the invisible borders\r\n    int x = mon.left+ ((mon.right-mon.left)-(width - bd.left - bd.right))/2 - bd.left;\r\n    int y = mon.top + ((mon.bottom-mon.top)-(height - bd.top - bd.bottom))/2 - bd.top;\r\n\r\n    if (flags & CW_TRIM) {\r\n        // Trim the window to the current monitor\r\n        if (x < mon.left - bd.left) {\r\n            x = mon.left - bd.left;\r\n            width = mon.right - mon.left + bd.left + bd.right;\r\n        }\r\n\r\n        if (y < mon.top - bd.top) {\r\n            y = mon.top - bd.top;\r\n            height = mon.bottom - mon.top + bd.top + bd.bottom;\r\n        }\r\n    }\r\n    MoveWindowAsync(hwnd, x, y, width, height);\r\n}\r\n\r\n//#define EVENT_HOOK\r\n// TODO: Event Hook\r\n#ifdef EVENT_HOOK\r\nstatic HWND GetPinWindow(HWND owner);\r\nstatic BOOL CALLBACK PostPinWindowsProcMessage(HWND hwnd, LPARAM lp);\r\nstatic void CALLBACK HandleWinEvent(\r\n    HWINEVENTHOOK hook, DWORD event, HWND hwnd,\r\n    LONG idObject, LONG idChild,\r\n    DWORD dwEventThread, DWORD dwmsEventTime)\r\n{\r\n    HWND pinhwnd = (HWND) hook; // 1st param...\r\n    if (hwnd\r\n    && (event == EVENT_OBJECT_DESTROY || event == EVENT_OBJECT_LOCATIONCHANGE\r\n       || event == EVENT_SYSTEM_FOREGROUND || event == 0xB || event == 0xA)\r\n    && idChild == INDEXID_CONTAINER\r\n    && idObject == OBJID_WINDOW) {\r\n        if (pinhwnd && GetParent(pinhwnd) == hwnd) {\r\n            //TCHAR txt[32];\r\n            //MessageBox(NULL, itostr(event, txt, 16), NULL, 0);\r\n            PostMessage(pinhwnd, WM_TIMER, 0, 0);\r\n        }\r\n    }\r\n//    if(event == 0xB || event == 0xA)\r\n//    \tLOGA(\"event = %x\", event);\r\n}\r\n#endif // EVENT_HOOK\r\n\r\n// Used with TrackMenuOfWindows\r\n#define TRK_LASERMODE (1<<0)\r\n#define TRK_MOVETOMONITOR (1<<1)\r\n\r\nstatic void TrackMenuOfWindows(WNDENUMPROC EnumProc, LPARAM flags);\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Pin window callback function\r\n// We store the old owner window style in GWLP_USERDATA\r\n// and the rightoffset/topoffset in the first LONG_PTR of cbWndExtra (+0)\r\nstatic LRESULT CALLBACK PinWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n    switch(msg) {\r\n    case WM_CREATE: {\r\n#ifdef EVENT_HOOK\r\n// TODO: Event Hook\r\n        HWND owner = GetWindow(hwnd, GW_OWNER);\r\n        DWORD lpdwProcessId;\r\n        DWORD threadid = GetWindowThreadProcessId(owner, &lpdwProcessId);\r\n        int prop = SetProp(owner, TEXT(APP_NAMEA)TEXT(\"-Pin\"), NULL);\r\n        RemoveProp(owner,  TEXT(APP_NAMEA)TEXT(\"-Pin\"));\r\n\r\n        if (prop && threadid && lpdwProcessId) {\r\n            #if defined(_M_AMD64) || defined(WIN64)\r\n                #define THUNK_SIZE 22\r\n            #else\r\n                #define THUNK_SIZE 13\r\n            #endif\r\n            BYTE *thunk = (BYTE*)VirtualAlloc( NULL, THUNK_SIZE, MEM_COMMIT, PAGE_READWRITE );\r\n            if (!thunk) break;\r\n            // Replace the first parameter with the handle of the PinWindow.\r\n            // FIXME: Handle MIPS/Alpha/PowerPC/ia-64/ARM/ARM64...\r\n            #if defined(_M_AMD64) || defined(WIN64)\r\n                // AMD x86_64 windows : rcx, rdx, r8, r9 (ints).\r\n                // xmm0, xmm1, xmm2, xmm3, floating points\r\n                // Then push right to left.\r\n                // ----------------------------------\r\n                // ; mov rcx hwnd\r\n                // ; mov rax Procedure\r\n                // ; jmp rax\r\n                *(WORD  *)(thunk+ 0) = 0xB948;\r\n                *(HWND  *)(thunk+ 2) = hwnd; // <- Replace 1st param\r\n                *(WORD  *)(thunk+10) = 0xB848;\r\n                *(void **)(thunk+12) = (LONG_PTR*)HandleWinEvent;\r\n                *(WORD  *)(thunk+20) = 0xE0FF;\r\n            #elif defined(_M_IX86)\r\n                // i386 __stdcall: push right to left\r\n                // ----------------------------------\r\n                // ; mov dword ptr [esp+4] hwnd\r\n                // ; jmp Procedure\r\n                *(DWORD *)(thunk+0) = 0x042444C7;\r\n                *(HWND  *)(thunk+4) = hwnd; // <- Replace 1st param\r\n                *(BYTE  *)(thunk+8) = 0xE9;\r\n                *(DWORD *)(thunk+9) = (BYTE*)((void*)HandleWinEvent)-(thunk+13);\r\n            #else\r\n                #error Unsupported CPU type, implement thunking or undefine EVENT_HOOK.\r\n            #endif\r\n            DWORD oldprotect;\r\n            // Restrict thunk to execute only.\r\n            BOOL ret = VirtualProtect(thunk, THUNK_SIZE, PAGE_EXECUTE, &oldprotect);\r\n            if (!ret) break;\r\n            FlushInstructionCache(GetCurrentProcess(), thunk, THUNK_SIZE);\r\n\r\n            HWINEVENTHOOK hook =\r\n            SetWinEventHook(\r\n                //EVENT_OBJECT_DESTROY, EVENT_OBJECT_LOCATIONCHANGE, // Range of events=8001-800Bh\r\n                0, EVENT_OBJECT_LOCATIONCHANGE,\r\n                NULL, // Handle to DLL.\r\n                (WINEVENTPROC)thunk, // The callback function (thunked)\r\n                lpdwProcessId, threadid, // Process and thread IDs of interest (0 = all)\r\n                WINEVENT_OUTOFCONTEXT // Flags.\r\n                );\r\n            SetWindowLongPtr(hwnd, 0+sizeof(LONG_PTR), (LONG_PTR)hook); // save hook\r\n            SetWindowLongPtr(hwnd, 0+2*sizeof(LONG_PTR), (LONG_PTR)thunk); // save thunk\r\n            if (hook) {\r\n                PostMessage(hwnd, WM_TIMER, 0, 0);\r\n                break;\r\n            }\r\n        }\r\n#endif // EVENT_HOOK\r\n        SetTimer(hwnd, 1, conf.PinRate, NULL);\r\n\r\n    } break;\r\n    case WM_DPICHANGED: {\r\n        // Reset the oldstyle, so we have to recalculate size/offset\r\n        // of the pin window on DPI change.\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);\r\n    } break;\r\n    case WM_SETTINGCHANGE: {\r\n        if (wp == SPI_SETNONCLIENTMETRICS) {\r\n            // We have to recalculate size/offset on global\r\n            // non client metrics change.\r\n            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);\r\n        }\r\n    } break;\r\n    case WM_TIMER: {\r\n        HWND ow;\r\n        if (!(ow=GetWindow(hwnd, GW_OWNER))) {\r\n            // Owner no longer exists!\r\n            // We have no reasons to be anymore.\r\n            DestroyWindow(hwnd);\r\n            return 0;\r\n        }\r\n        // Destroy the pin if the owner is no longer topmost\r\n        // or no longer exists\r\n        LONG_PTR xstyle;\r\n        if(!IsWindow(ow)\r\n        || !IsWindowVisible(ow)\r\n        || !((xstyle = GetWindowLongPtr(ow, GWL_EXSTYLE))&WS_EX_TOPMOST)) {\r\n            DestroyWindow(hwnd);\r\n            return 0;\r\n        }\r\n\r\n        RECT rc; // Owner rect.\r\n        GetWindowRect(ow, &rc);\r\n        LONG_PTR style  = GetWindowLongPtr(ow, GWL_STYLE);\r\n        LONG_PTR OldOwStyle = GetWindowLongPtr(hwnd, GWLP_USERDATA);\r\n        if (OldOwStyle == style) {\r\n            // the data were saved for the correct style!!!\r\n            LONG_PTR RTOffset = GetWindowLongPtr(hwnd, 0); // get Right and Top offset\r\n            SetWindowPos(hwnd, NULL\r\n                , rc.right-LOWORDPTR(RTOffset), rc.top+HIWORDPTR(RTOffset), 0, 0\r\n                , SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOSIZE|SWP_NOSENDCHANGING);\r\n            return 0; // DONE!\r\n        }\r\n\r\n        // Calculate offsets, sets window position and save data\r\n        // to the GWLP_USERDATA stuff!\r\n        UINT dpi = GetDpiForWindow(hwnd); // Use pin's hwnd\r\n        int CapButtonWidth, PinW, PinH;\r\n        PinW = GetSystemMetricsForDpi(SM_CXSIZE, dpi); // Caption button width\r\n        PinH = GetSystemMetricsForDpi(SM_CYSIZE, dpi); // Caption button height\r\n\r\n        int bdx=0, bdy=0;\r\n        if (style&WS_THICKFRAME) {\r\n            bdx = GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi);\r\n            bdy = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi);\r\n        } else if (style&WS_CAPTION) { // Caption or border\r\n            bdx = GetSystemMetricsForDpi(SM_CXFIXEDFRAME, dpi);\r\n            bdy = GetSystemMetricsForDpi(SM_CYFIXEDFRAME, dpi);\r\n        }\r\n        // Vista/7/8.x/10 extra padding Not working???\r\n        // bdy += GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);\r\n\r\n        RECT btrc;\r\n        if (GetCaptionButtonsRect(ow, &btrc)) {\r\n            CapButtonWidth = btrc.right - btrc.left;\r\n            // bdx = rc.right - btrc.right;\r\n        } else {\r\n            UCHAR btnum=0; // Number of caption buttons.\r\n            if ((style&(WS_SYSMENU|WS_CAPTION)) == (WS_SYSMENU|WS_CAPTION)) {\r\n                btnum++;                         // WS_SYSMENU => Close button [X]\r\n                btnum += 2 * !!(style&(WS_MINIMIZEBOX|WS_MAXIMIZEBOX)); // [O] [_]\r\n                btnum += ( (xstyle&WS_EX_CONTEXTHELP)                       // [?]\r\n                          && (style&(WS_MINIMIZEBOX|WS_MAXIMIZEBOX)) != (WS_MINIMIZEBOX|WS_MAXIMIZEBOX) );\r\n            }\r\n            CapButtonWidth = btnum * PinW;\r\n        }\r\n        // Adjust PinW and PinH to have nice stuff.\r\n        PinW -= 2;\r\n        PinH -= 2;\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, style); // Save old window style\r\n        int rightoffset = CapButtonWidth+PinW+bdx+GetSystemMetricsForDpi(SM_CXBORDER, dpi)*2;\r\n        int topoffset = bdy+1;\r\n        // Cache local hwnd storage for pin win offsets in the first LONG_PTR of cbWndExtra\r\n        SetWindowLongPtr(hwnd, 0, MAKELONGPTR(rightoffset,topoffset));\r\n        // Move and size the window...\r\n        SetWindowPos(hwnd, NULL\r\n            , rc.right-rightoffset, rc.top+topoffset, PinW, PinH\r\n            , SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOSENDCHANGING);\r\n        return 0;\r\n    } break;\r\n    case WM_PAINT: {\r\n        TCHAR Topchar = HIBYTE(HIWORD(conf.PinColor&0xFF000000));\r\n        if (Topchar) {\r\n            if(!GetUpdateRect(hwnd, NULL, FALSE))\r\n                return 0;\r\n            PAINTSTRUCT ps;\r\n            RECT cr;\r\n            GetClientRect(hwnd, &cr);\r\n            BeginPaint(hwnd, &ps);\r\n            SetBkMode(ps.hdc, TRANSPARENT);\r\n            DrawText(ps.hdc, &Topchar, 1, &cr, DT_VCENTER|DT_CENTER|DT_SINGLELINE);\r\n            EndPaint(hwnd, &ps);\r\n            return 0;\r\n      }\r\n    } break;\r\n    case WM_LBUTTONUP: {\r\n        DestroyWindow(hwnd);\r\n        return 0;\r\n    } break;\r\n    case WM_RBUTTONUP: {\r\n        state.mdiclient = NULL; // In case...\r\n        TrackMenuOfWindows(EnumTopMostWindows, 0);\r\n        return 0;\r\n    } break;\r\n//    case WM_GETPINNEDHWND: {\r\n//        // Returns the handle to the topmost window\r\n//        HWND ow = GetWindow(hwnd, GW_OWNER);\r\n//        if(ow && IsWindow(ow)) return (LRESULT)ow;\r\n//    } break;\r\n    case WM_DESTROY: {\r\n        KillTimer(hwnd, 1);\r\n\r\n// TODO: Event Hook\r\n#ifdef EVENT_HOOK\r\n        HWINEVENTHOOK hook = (HWINEVENTHOOK)GetWindowLongPtr(hwnd, 0+sizeof(LONG_PTR));\r\n        if (hook) UnhookWinEvent(hook);\r\n        // Free the thunk.\r\n        BYTE *thunk = (BYTE *)GetWindowLongPtr(hwnd, 0+2*sizeof(LONG_PTR));\r\n        if (thunk) VirtualFree(thunk, 0, MEM_RELEASE);\r\n#endif // EVENT_HOOK\r\n        // Remove topmost flag if the pin gets destroyed.\r\n        HWND ow;\r\n        if((ow=GetWindow(hwnd, GW_OWNER))\r\n        && IsWindow(ow)\r\n        && (GetWindowLongPtr(ow, GWL_EXSTYLE)&WS_EX_TOPMOST) )\r\n            SetWindowLevel(ow, HWND_NOTOPMOST);\r\n    } break;\r\n    }\r\n    return DefWindowProc(hwnd, msg, wp, lp);\r\n}\r\nstatic HWND CreatePinWindow(const HWND owner)\r\n{\r\n    WNDCLASSEX wnd;\r\n    if(!GetClassInfoEx(hinstDLL, TEXT(APP_NAMEA)TEXT(\"-Pin\"), &wnd)) {\r\n        // Register the class if no already created.\r\n        mem00(&wnd, sizeof(wnd));\r\n        wnd.cbSize = sizeof(WNDCLASSEX);\r\n        wnd.style = CS_NOCLOSE|CS_HREDRAW|CS_VREDRAW;\r\n        wnd.lpfnWndProc = PinWindowProc;\r\n#ifdef EVENT_HOOK\r\n        // We need some data to save the thunk and event hook.\r\n        wnd.cbWndExtra = sizeof(LONG_PTR) * 3;\r\n#else\r\n        wnd.cbWndExtra = sizeof(LONG_PTR);\r\n#endif\r\n        wnd.hInstance = hinstDLL;\r\n        wnd.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n        wnd.hbrBackground = CreateSolidBrush(conf.PinColor&0x00FFFFFF);\r\n        wnd.lpszClassName =  TEXT(APP_NAMEA)TEXT(\"-Pin\");\r\n        RegisterClassEx(&wnd);\r\n    }\r\n    HWND ret = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_TOPMOST\r\n                   , TEXT(APP_NAMEA)TEXT(\"-Pin\"), NULL\r\n                   , WS_POPUP|WS_BORDER /* Start invisible */\r\n                   , 0, 0, 0, 0\r\n                   , owner, NULL, hinstDLL, NULL);\r\n    // Show pin window without activating it to avoid focus loss.\r\n    ShowWindow(ret, SW_SHOWNA);\r\n    return ret;\r\n}\r\nstatic BOOL CALLBACK PostPinWindowsProcMessage(HWND hwnd, LPARAM lp)\r\n{\r\n    if(isClassName(hwnd, TEXT(APP_NAMEA)TEXT(\"-Pin\"))) {\r\n        if(lp == WM_CLOSE)\r\n            DestroyWindow(hwnd);\r\n        else\r\n            PostMessage(hwnd, lp, 0, 0);\r\n    }\r\n\r\n    return TRUE; // Next hwnd\r\n}\r\nstatic BOOL CALLBACK FindPinWinProc(HWND hwnd, LPARAM lp)\r\n{\r\n    HWND *inouth = (HWND *)lp;\r\n    if(GetWindow(hwnd, GW_OWNER) == inouth[1]) {\r\n        inouth[0] = hwnd;\r\n        return FALSE;\r\n    }\r\n    return TRUE;\r\n}\r\nstatic HWND GetPinWindow(HWND owner)\r\n{\r\n    HWND inouth[2] = { NULL, owner };\r\n    EnumThreadWindows(GetCurrentThreadId(), FindPinWinProc, (LPARAM)inouth);\r\n    return inouth[0];\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void TogglesAlwaysOnTop(HWND hwnd)\r\n{\r\n    // Use the Root owner\r\n    hwnd = GetRootOwner(hwnd);\r\n    LONG_PTR topmost = GetWindowLongPtr(hwnd, GWL_EXSTYLE)&WS_EX_TOPMOST;\r\n    SetWindowLevel(hwnd, topmost? HWND_NOTOPMOST: HWND_TOPMOST);\r\n\r\n    if (!topmost) {\r\n        if (conf.TopmostIndicator) CreatePinWindow(hwnd);\r\n    } else {\r\n        // Destroy Pin Window?\r\n        if (conf.TopmostIndicator) DestroyWindow(GetPinWindow(hwnd));\r\n    }\r\n    // Always set foreground #442\r\n    ReallySetForegroundWindow(hwnd);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void ActionMaximize(HWND hwnd)\r\n{\r\n    LastWin.hwnd = NULL;\r\n    if (state.shift) {\r\n        MinimizeWindow(hwnd);\r\n    } else if (IsResizable(hwnd)) {\r\n        ToggleMaxRestore(hwnd);\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void MaximizeHV(HWND hwnd, int horizontal)\r\n{\r\n    RECT rc, bd, mon;\r\n    if (!IsResizable(hwnd) || !GetWindowRect(hwnd, &rc)) return;\r\n    OffsetRectMDI(&rc);\r\n\r\n    POINT pt;\r\n    GetCursorPos(&pt);\r\n    GetMonitorRect(&pt, 0, &mon);\r\n    SetOriginFromRestoreData(hwnd, AC_MOVE);\r\n\r\n    SetRestoreData(hwnd, state.origin.width, state.origin.height, SNAPPED);\r\n    FixDWMRect(hwnd, &bd);\r\n    if (horizontal) {\r\n        SetRestoreFlag(hwnd, SNAPPED|SNMAXW);\r\n        MoveWindowAsync(hwnd\r\n            , mon.left-bd.left\r\n            , rc.top\r\n            , mon.right-mon.left + bd.left+bd.right\r\n            , rc.bottom-rc.top);\r\n    } else { // vertical\r\n        SetRestoreFlag(hwnd, SNAPPED|SNMAXH);\r\n        MoveWindowAsync(hwnd\r\n            , rc.left\r\n            , mon.top - bd.top\r\n            , rc.right - rc.left\r\n            , mon.bottom - mon.top + bd.top+bd.bottom);\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nHWND *minhwnds=NULL;\r\nunsigned minhwnds_alloc=0;\r\nunsigned numminhwnds=0;\r\nstruct MinimizeWindowProcParams {\r\n    HMONITOR hMon;\r\n    HWND clickedhwnd;\r\n};\r\nBOOL CALLBACK MinimizeWindowProc(HWND hwnd, LPARAM lParam)\r\n{\r\n    minhwnds = (HWND *)GetEnoughSpace(minhwnds, numminhwnds, &minhwnds_alloc, sizeof(HWND));\r\n    if (!minhwnds) return FALSE; // Stop enum, we failed\r\n    const struct MinimizeWindowProcParams *p = (const struct MinimizeWindowProcParams *) lParam;\r\n    hwnd = GetRootOwner(hwnd);\r\n\r\n    if (hwnd != p->clickedhwnd\r\n    // && IsAltTabAble(hwnd) ????\r\n    && IsVisible(hwnd)\r\n    && !IsIconic(hwnd)\r\n    && (WS_MINIMIZEBOX&GetWindowLongPtr(hwnd, GWL_STYLE))){\r\n        if (!p->hMon || p->hMon == MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST)) {\r\n            MinimizeWindow(hwnd);\r\n            minhwnds[numminhwnds++] = hwnd;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r\nstatic void MinimizeAllOtherWindows(HWND hwnd, int CurrentMonOnly)\r\n{\r\n    static HWND restore = NULL;\r\n    HMONITOR hMon = NULL;\r\n    hwnd = GetRootOwner(hwnd);\r\n//    if (!hwnd) return;\r\n\r\n    if (CurrentMonOnly) hMon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\r\n\r\n    if (restore == hwnd) {\r\n        // We have to restore all saved windows (minhwnds) when\r\n        // we click again on the same hwnd and have everything saved...\r\n        unsigned i;\r\n        for (i=0; i < numminhwnds; i++) {\r\n            HWND hrest = minhwnds[i];\r\n            if (IsWindow(hrest)\r\n            && IsIconic(hrest)\r\n            && (!hMon || hMon == MonitorFromWindow(hrest, MONITOR_DEFAULTTONEAREST))){\r\n                // Synchronus restoration to keep the order of windows...\r\n                ShowWindow(hrest, SW_RESTORE);\r\n                SetWindowLevel(hrest, HWND_BOTTOM);\r\n            }\r\n        }\r\n        SetForegroundWindowL(hwnd);\r\n        numminhwnds = 0;\r\n        restore = NULL;\r\n    } else {\r\n        struct MinimizeWindowProcParams p = { NULL, hwnd };\r\n        restore = hwnd;\r\n        numminhwnds = 0;\r\n        if (state.mdiclient) {\r\n            EnumChildWindows(state.mdiclient, MinimizeWindowProc, (LPARAM)&p);\r\n        } else {\r\n            p.hMon = hMon;\r\n            EnumDesktopWindows(NULL, MinimizeWindowProc, (LPARAM)&p);\r\n        }\r\n    }\r\n}\r\n\r\nstatic pure BOOL IsRectInMonitors(const RECT *rc)\r\n{\r\n    unsigned i;\r\n    for(i=0; i < nummonitors; i++) {\r\n        int inx = monitors[i].left < rc->right-8 && rc->left+8 < monitors[i].right;\r\n        int iny = monitors[i].top < rc->bottom-8 && rc->top+8 < monitors[i].bottom;\r\n        if (inx && iny) // Windows is inside one of the monitors.\r\n            return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n// Move the window step by step to a direction.\r\n// signed step size and direction = 0 for X 1 for Y\r\nstatic void StepWindow(HWND hwnd, short step, UCHAR direction)\r\n{\r\n    RECT rc;\r\n    if (IsZoomed(hwnd)) {\r\n        //return;\r\n        RestoreToMonitorSize(hwnd, &rc);\r\n    }\r\n    if(!GetWindowRect(hwnd, &rc)) return;\r\n    int x=rc.left, y=rc.top;\r\n    int width = rc.right - rc.left;\r\n    int height = rc.bottom - rc.top;\r\n    UCHAR threshold = min(abs(step)-1, conf.SnapThreshold);\r\n\r\n    if (direction==0) {\r\n        x += step; // x-axis\r\n        if (threshold) MoveSnap(&x, &y, width, height, threshold);\r\n        y = rc.top; // y does not change.\r\n        rc.left = x;\r\n        rc.right = x + width;\r\n    } else {\r\n        y += step; // y-axis;\r\n        if (threshold) MoveSnap(&x, &y, width, height, threshold);\r\n        x = rc.left; // x does not change.\r\n        rc.top = y;\r\n        rc.bottom = y + height;\r\n    }\r\n\r\n    if(IsRectInMonitors(&rc)) {\r\n        // Do not move if target rect is not in a monitor.\r\n        UINT flags = SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE|SWP_NOSIZE|SWP_ASYNCWINDOWPOS;\r\n        if (conf.IgnoreMinMaxInfo) flags |= SWP_NOSENDCHANGING;\r\n        SetWindowPos(hwnd, NULL, x, y, 0, 0, flags);\r\n    }\r\n}\r\n// Make a menu filled with the windows that are enumed through EnumProc\r\n// And Track it!!!!\r\nstatic TCHAR Int2Accel(int i)\r\n{\r\n    if (conf.NumberMenuItems)\r\n        return i<10? TEXT('0')+i: TEXT('A')+i-10;\r\n    else\r\n        return i<26? TEXT('A')+i: TEXT('0')+i-26;\r\n}\r\n#include <oleacc.h>\r\nstruct menuitemdata {\r\n    #ifdef _UNICODE\r\n    MSAAMENUINFO msaa;\r\n    #endif\r\n    TCHAR *txtptr;\r\n    HICON icon;\r\n};\r\nstatic void MoveToCurrentMonitorIfNeeded(HWND hwnd)\r\n{\r\n    if (state.mdiclient) return;\r\n    RECT rc;\r\n    GetWindowRect(hwnd, &rc);\r\n\r\n    POINT pt;\r\n    pt.x = rc.left + (rc.right - rc.left) / 2;\r\n    pt.y = rc.top + (rc.bottom - rc.top) / 2;\r\n\r\n    assert(state.origin.monitor != 0);\r\n\r\n    // If the window centre is outside the current monitor\r\n    // (use the point instead of window, since MonitorFromWindow\r\n    // returns ones that are only touching, which are still not\r\n    // accessible for the user)\r\n    if (MonitorFromPoint(pt, MONITOR_DEFAULTTONULL) != state.origin.monitor) {\r\n        // Put the window on-screen\r\n        CenterWindow(hwnd, CW_TRIM);\r\n    }\r\n}\r\nstatic void TrackMenuOfWindows(WNDENUMPROC EnumProc, LPARAM flags)\r\n{\r\n    state.sclickhwnd = NULL;\r\n    KillAltSnapMenu();\r\n    g_mchwnd = KreateMsgWin(MenuWindowProc, TEXT(APP_NAMEA)TEXT(\"-SClick\"), 3);\r\n    if (!g_mchwnd) return; // Failed to create g_mchwnd...\r\n    // Fill up hwnds[] with the stacked windows.\r\n    numhwnds = 0;\r\n    HWND mdiclient = state.mdiclient;\r\n    if (mdiclient) {\r\n        EnumChildWindows(mdiclient, EnumProc, flags & TRK_LASERMODE);\r\n    } else {\r\n        EnumDesktopWindows(NULL, EnumProc, flags & TRK_LASERMODE);\r\n    }\r\n    if (!hwnds) return; // Enum failed\r\n\r\n    LOG(\"Number of stacked windows = %u\", numhwnds);\r\n    if(numhwnds == 0) return;\r\n\r\n    state.sclickhwnd = state.hwnd;\r\n    numhwnds = min(numhwnds, 36); // Max 36 stacked windows\r\n\r\n    HMENU menu = CreatePopupMenu();\r\n    state.unikeymenu = menu;\r\n    unsigned i;\r\n    TCHAR * const failed_string = TEXT(\"---\");\r\n\r\n    struct menuitemdata data[36]; // Always fits into the stack\r\n    for (i=0; i < numhwnds; i++) {\r\n        int textlen = GetWindowTextLength(hwnds[i]);\r\n        // Limit the size to the asked width\r\n        if (conf.MaxMenuWidth)\r\n            textlen = min(textlen, conf.MaxMenuWidth);\r\n\r\n        // 5 + textlen + 1 * null\r\n        // Allocate some memory\r\n        data[i].txtptr = (TCHAR *)malloc((textlen + 6) * sizeof(TCHAR));\r\n        if (data[i].txtptr) {\r\n            // Allocation succeeded\r\n            TCHAR *txt = data[i].txtptr;\r\n            GetWindowText(hwnds[i], txt+5, textlen + 1);\r\n            txt[0] = TEXT('&');\r\n            txt[1] = Int2Accel(i);\r\n            txt[2] = TEXT(' '); txt[3] = TEXT('-'); txt[4] = TEXT(' ');\r\n        } else {\r\n           // Display static text.\r\n           data[i].txtptr = failed_string;\r\n        }\r\n        // Fill up MSAA structure for screen readers.\r\n        #ifdef _UNICODE // Only available in unicode mode\r\n        data[i].msaa.dwMSAASignature = MSAA_MENU_SIG;\r\n        data[i].msaa.cchWText = lstrlen(data[i].txtptr);\r\n        data[i].msaa.pszWText = data[i].txtptr;\r\n        #endif\r\n\r\n        // GetWindowIcon return a shared resource not to be freed\r\n        data[i].icon = GetWindowIcon(hwnds[i]);\r\n        MENUITEMINFO lpmi= { sizeof(MENUITEMINFO) };\r\n        lpmi.fMask = MIIM_DATA|MIIM_TYPE|MIIM_ID;\r\n        lpmi.fType = MFT_OWNERDRAW; /*MFT_STRING*/\r\n        lpmi.wID = i+1; // Id starts at 1 because 0 is for ESCAPE.\r\n        lpmi.dwItemData = (ULONG_PTR)&data[i];\r\n        #ifdef _UNICODE\r\n        lpmi.dwTypeData = (LPWSTR)&data[i].msaa;\r\n        lpmi.cch = sizeof(MSAAMENUINFO);\r\n        #else\r\n        lpmi.dwTypeData=NULL;\r\n        lpmi.cch=0;\r\n        #endif\r\n        InsertMenuItem(menu, i+1, FALSE, &lpmi);\r\n    }\r\n    POINT pt;\r\n    GetCursorPos(&pt);\r\n    ReallySetForegroundWindow(g_mchwnd);\r\n    i = (unsigned)TrackPopupMenu(menu,\r\n        TPM_RETURNCMD/*|TPM_NONOTIFY*/|GetSystemMetrics(SM_MENUDROPALIGNMENT)\r\n        , pt.x, pt.y, 0, g_mchwnd, NULL);\r\n    state.mdiclient = mdiclient;\r\n    LOG(\"menu=%u\", i);\r\n    // if the return value is in the range..\r\n    if (0 < i && i <= numhwnds) {\r\n        HWND hwnd = hwnds[i-1];\r\n//        TCHAR buf[128];\r\n//        PrintHwndDetails(hwnd, buf);\r\n//        MessageBox(NULL, buf, TEXT(\"Info\"), 0);\r\n        if(IsIconic(hwnd))\r\n            RestoreWindow(hwnd);\r\n        SetForegroundWindowL(hwnd);\r\n\r\n        if (flags & TRK_MOVETOMONITOR)\r\n            MoveToCurrentMonitorIfNeeded(hwnd);\r\n    }\r\n\r\n    DestroyMenu(menu);\r\n    DestroyWindow(g_mchwnd);\r\n    g_mchwnd = NULL;\r\n\r\n    // Free strings\r\n    for (i=0; i < numhwnds; i++) {\r\n        if (data[i].txtptr != failed_string)\r\n            free(data[i].txtptr);\r\n    }\r\n\r\n    return;\r\n}\r\nstatic void ActionStackList(int lasermode)\r\n{\r\n    // Just post the message to the Hotkeys message only window\r\n    // So that we do not get stuck in the hook chain.\r\n    PostMessage(g_hkhwnd, WM_STACKLIST, lasermode, (LPARAM)EnumStackedWindowsProc);\r\n}\r\nstatic void ActionASOnOff()\r\n{\r\n    if (state.action) FinishMovement();\r\n    state.altsnaponoff = !GetProp(g_mainhwnd, APP_ASONOFF);\r\n    SetProp(g_mainhwnd, APP_ASONOFF, (HANDLE)(DorQWORD)state.altsnaponoff);\r\n    PostMessage(g_mainhwnd, WM_UPDATETRAY, 0, 0);\r\n}\r\nstatic void ActionMoveOnOff(HWND hwnd)\r\n{\r\n    if (GetProp(hwnd, APP_MOVEONOFF))\r\n        RemoveProp(hwnd, APP_MOVEONOFF);\r\n    else\r\n        SetProp(hwnd, APP_MOVEONOFF, (HANDLE)1);\r\n}\r\nstatic void ActionMenu(HWND hwnd)\r\n{\r\n    state.sclickhwnd = NULL;\r\n    KillAltSnapMenu();\r\n    g_mchwnd = KreateMsgWin(MenuWindowProc, TEXT(APP_NAMEA)TEXT(\"-SClick\"), 1);\r\n    state.sclickhwnd = hwnd;\r\n    // Send message to Open Action Menu\r\n    ReallySetForegroundWindow(g_mainhwnd);\r\n    PostMessage(\r\n        g_mainhwnd, WM_SCLICK, (WPARAM)g_mchwnd,\r\n       ( !state.ignorept )                                    // LP_CURSORPOS\r\n       | !!(GetWindowLongPtr(hwnd, GWL_EXSTYLE)&WS_EX_TOPMOST)<<1//LP_TOPMOST\r\n       | !!GetBorderlessFlag(hwnd) << 2                      // LP_BORDERLESS\r\n       | IsZoomed(hwnd) << 3                                  // LP_MAXIMIZED\r\n       | !!(GetRestoreFlag(hwnd)&2) << 4                         // LP_ROLLED\r\n       | !!GetProp(state.hwnd, APP_MOVEONOFF) << 5            // LP_MOVEONOFF\r\n       | (state.alt <= BT_MB5) << 6                         // LP_NOALTACTION\r\n    );\r\n}\r\n// Finds the window that is just next the specified one.\r\n// Works better if they are arranged like in snap layouts.\r\nstruct FindTiledWindow_struct {\r\n    POINT opt; // in\r\n    long owidth;\r\n    long oheight;\r\n    HWND ihwnd; // in\r\n    HWND ohwnd; // out\r\n    POINT distance; // internal\r\n    unsigned char direction; // in\r\n    unsigned char diagonal; // in\r\n};\r\nstatic BOOL CALLBACK FindTiledWindowEnumProc(HWND hwnd, LPARAM lp)\r\n{\r\n    struct FindTiledWindow_struct *tw = (struct FindTiledWindow_struct *)lp;\r\n    RECT rc;\r\n    if (tw->ihwnd == hwnd || !IsAltTabAble(hwnd) || !GetWindowRectL(hwnd, &rc))\r\n        return TRUE; // Next hwnd\r\n    POINT pt;\r\n    pt.x = (rc.left + rc.right) / 2;\r\n    pt.y = (rc.top + rc.bottom) / 2;\r\n    long dx = pt.x - tw->opt.x;\r\n    long dy = pt.y - tw->opt.y;\r\n    long adx = abs(dx);\r\n    long ady = abs(dy);\r\n    //LOGA(\"adx = %d, ady = %d, tw->opt=%d,%d tw->oheight = %d, tw->owidth = %d\"\r\n    //    , adx,      ady,   tw->opt.x,tw->opt.y,  tw->oheight, tw->owidth);\r\n\r\n    if(tw->diagonal) {\r\n        // We only use the position of the center of each window.\r\n        // We check windows within a 45deg cone around the direction of choice.\r\n        switch (tw->direction) {\r\n        case 0: // LEFT\r\n            if (dx < 0 && ady <= adx\r\n            && (adx < tw->distance.x || (adx == tw->distance.x && ady < tw->distance.y)) )\r\n                break; // Window is closer...\r\n            return TRUE; // skip\r\n        case 1: // UP\r\n            if (dy < 0 && adx <= ady\r\n            && (ady < tw->distance.y || (ady == tw->distance.y && adx < tw->distance.x)) )\r\n                break;\r\n            return TRUE;\r\n        case 2: // RIGHT\r\n            if (dx > 0 && ady <= adx\r\n            && (adx < tw->distance.x || (adx == tw->distance.x && ady < tw->distance.y)) )\r\n                break;\r\n            return TRUE;\r\n        case 3: // DOWN\r\n            if (dy > 0 && adx <= ady\r\n            && (ady < tw->distance.y || (ady == tw->distance.y && adx < tw->distance.x)) )\r\n                break;\r\n            return TRUE;\r\n        default: // WTF?\r\n            UNREACHABLE();\r\n        }\r\n    } else {\r\n        // Square mode (not all space is covered)\r\n        long beamW = min(tw->oheight, tw->owidth);\r\n        switch (tw->direction) {\r\n        case 0: // LEFT\r\n            if (dx < 0 && ady < beamW\r\n            && (adx < tw->distance.x || (adx == tw->distance.x && ady < tw->distance.y)) )\r\n                break; // Window is closer...\r\n            return TRUE; // skip\r\n        case 1: // UP\r\n            if (dy < 0 && adx < beamW\r\n            && (ady < tw->distance.y || (ady == tw->distance.y && adx < tw->distance.x)) )\r\n                break;\r\n            return TRUE;\r\n        case 2: // RIGHT\r\n            if (dx > 0 && ady < beamW\r\n            && (adx < tw->distance.x || (adx == tw->distance.x && ady < tw->distance.y)) )\r\n                break;\r\n            return TRUE;\r\n        case 3: // DOWN\r\n            if (dy > 0 && adx < beamW\r\n            && (ady < tw->distance.y || (ady == tw->distance.y && adx < tw->distance.x)) )\r\n                break;\r\n            return TRUE;\r\n        default: // WTF?\r\n            UNREACHABLE();\r\n        }\r\n    }\r\n    // Update tw struct if we find a closer window.\r\n    tw->distance.x = adx;\r\n    tw->distance.y = ady;\r\n    tw->ohwnd = hwnd;\r\n\r\n    return TRUE;\r\n}\r\nstatic HWND FindTiledWindow(HWND hwnd, unsigned char direction)\r\n{\r\n    assert(direction < 4 );\r\n\r\n    RECT rc;\r\n    if (GetWindowRectL(hwnd, &rc)) {\r\n        struct FindTiledWindow_struct tw;\r\n        long w = (rc.right - rc.left) / 2;\r\n        long h = (rc.bottom - rc.top )/ 2;\r\n        tw.opt.x = (rc.left + rc.right) / 2;\r\n        tw.opt.y = (rc.top + rc.bottom) / 2;\r\n        tw.owidth  = w;\r\n        tw.oheight = h;\r\n        tw.ihwnd = hwnd;\r\n        tw.ohwnd = NULL;\r\n        tw.distance.x = 0x7ffffff0;\r\n        tw.distance.y = 0x7ffffff0;\r\n        tw.direction = direction;\r\n        tw.diagonal = 0;\r\n\r\n        EnumDesktopWindows(NULL, FindTiledWindowEnumProc, (LPARAM)&tw);\r\n        if (!tw.ohwnd) { // Try again with diagonals\r\n            tw.diagonal = 1;\r\n            EnumDesktopWindows(NULL, FindTiledWindowEnumProc, (LPARAM)&tw);\r\n        }\r\n//        // Last resort, try with larger and larger beam...\r\n//        tw.diagonal = 0;\r\n//        int i;\r\n//        for (i=2; !tw.ohwnd && i<5; i++) {\r\n//            tw.oheight = i*h;\r\n//            tw.owidth  = i*h;\r\n//            EnumDesktopWindows(NULL, FindTiledWindowEnumProc, (LPARAM)&tw);\r\n//        }\r\n//        // TODO: Handle MDI clients.\r\n//        if (state.mdiclient) {\r\n//            EnumChildWindows(state.mdiclient, FindTiledWindowEnumProc, (LPARAM)&tw);\r\n//        } else {\r\n//            EnumDesktopWindows(NULL, FindTiledWindowEnumProc, (LPARAM)&tw);\r\n//        }\r\n        // Log hwnd details (usefull for debugging)\r\n//        TCHAR buf[1024]=TEXT(\"\");\r\n//        PrintHwndDetails(tw.ohwnd, buf);\r\n//        static const char *directionStr=\"LTRB\";\r\n//        LOGA(\"FOCUSING_%c %S\", directionStr[direction], buf);\r\n\r\n        return tw.ohwnd;\r\n    }\r\n    return NULL;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Single click commands\r\nstatic void SClickActions(HWND hwnd, enum action action)\r\n{\r\n    const struct resizeXY RXY_LEFT_CENTER =   {RZ_LEFT, RZ_YCENTER};\r\n    const struct resizeXY RXY_RIGHT_CENTER =  {RZ_RIGHT, RZ_YCENTER};\r\n    const struct resizeXY RXY_CENTER_TOP =    {RZ_XCENTER, RZ_TOP};\r\n    const struct resizeXY RXY_CENTER_BOTTOM = {RZ_XCENTER, RZ_BOTTOM};\r\n\r\n    state.sactiondone = action;\r\n    LOG(\"Going to perform action %d\", (int)action);\r\n    switch (action) {\r\n    case AC_MINIMIZE:    MinimizeWindow(hwnd); break;\r\n    case AC_MAXIMIZE:    ActionMaximize(hwnd); break;\r\n    case AC_CENTER:      CenterWindow(hwnd, !state.shift /*state.shift? 0: CW_RESTORE*/); break;\r\n    case AC_ALWAYSONTOP: TogglesAlwaysOnTop(hwnd); break;\r\n    case AC_CLOSE:       PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0); break;\r\n    case AC_LOWER:       ActionLower(hwnd, 0, state.shift, state.ctrl); break;\r\n    case AC_FOCUS:       ActionLower(hwnd, +120, state.shift, 1); break;\r\n    case AC_BORDERLESS:  ActionBorderless(hwnd); break;\r\n    case AC_KILL:        ActionKill(hwnd); break;\r\n    case AC_PAUSE:       ActionPause(hwnd, 1); break;\r\n    case AC_RESUME:      ActionPause(hwnd, 0); break;\r\n    case AC_ROLL:        RollWindow(hwnd, 0); break;\r\n    case AC_MAXHV:       MaximizeHV(hwnd, state.shift); break;\r\n    case AC_MINALL:      MinimizeAllOtherWindows(hwnd, state.shift); break;\r\n    case AC_MUTE:        Send_KEY(VK_VOLUME_MUTE); break;\r\n    case AC_SIDESNAP:    SnapToCorner(hwnd, AUTORESIZE, !!state.shift); break;\r\n    case AC_EXTENDSNAP:  SnapToCorner(hwnd, AUTORESIZE, !state.shift); break;\r\n    case AC_EXTENDTNEDGE:SnapToCorner(hwnd, AUTORESIZE, state.shift?SNTO_MOVETO|SNTO_NEXTBD:SNTO_EXTEND|SNTO_NEXTBD); break;\r\n    case AC_MOVETNEDGE:  SnapToCorner(hwnd, AUTORESIZE, state.shift?SNTO_EXTEND|SNTO_NEXTBD:SNTO_MOVETO|SNTO_NEXTBD); break;\r\n    case AC_MENU:        ActionMenu(hwnd); break;\r\n    case AC_NSTACKED:    ActionAltTab(state.prevpt, +120,  state.shift, EnumStackedWindowsProc); break;\r\n    case AC_NSTACKED2:   ActionAltTab(state.prevpt, +120, !state.shift, EnumStackedWindowsProc); break;\r\n    case AC_PSTACKED:    ActionAltTab(state.prevpt, -120,  state.shift, EnumStackedWindowsProc); break;\r\n    case AC_PSTACKED2:   ActionAltTab(state.prevpt, -120, !state.shift, EnumStackedWindowsProc); break;\r\n    case AC_STACKLIST:   ActionStackList(state.shift ? TRK_LASERMODE : 0); break;\r\n    case AC_STACKLIST2:  ActionStackList(state.shift ? 0 : TRK_LASERMODE); break;\r\n    case AC_ALTTABLIST:\r\n        PostMessage(g_hkhwnd, WM_STACKLIST, TRK_MOVETOMONITOR | TRK_LASERMODE,\r\n            state.shift?(LPARAM)EnumAllAltTabWindows:(LPARAM)EnumAltTabWindows); break;\r\n    case AC_ALTTABFULLLIST:\r\n        PostMessage(g_hkhwnd, WM_STACKLIST, TRK_MOVETOMONITOR | TRK_LASERMODE,\r\n            state.shift?(LPARAM)EnumAltTabWindows:(LPARAM)EnumAllAltTabWindows); break;\r\n    case AC_MLZONE:      MoveWindowToTouchingZone(hwnd, 0, 0); break; // mLeft\r\n    case AC_MTZONE:      MoveWindowToTouchingZone(hwnd, 1, 0); break; // mTop\r\n    case AC_MRZONE:      MoveWindowToTouchingZone(hwnd, 2, 0); break; // mRight\r\n    case AC_MBZONE:      MoveWindowToTouchingZone(hwnd, 3, 0); break; // mBottom\r\n    case AC_XLZONE:      MoveWindowToTouchingZone(hwnd, 0, 1); break; // xLeft\r\n    case AC_XTZONE:      MoveWindowToTouchingZone(hwnd, 1, 1); break; // xTop\r\n    case AC_XRZONE:      MoveWindowToTouchingZone(hwnd, 2, 1); break; // xRight\r\n    case AC_XBZONE:      MoveWindowToTouchingZone(hwnd, 3, 1); break; // xBottom\r\n    case AC_XTNLEDGE:    SnapToCorner(hwnd, RXY_LEFT_CENTER,   SNTO_EXTEND|SNTO_NEXTBD); break;\r\n    case AC_XTNTEDGE:    SnapToCorner(hwnd, RXY_CENTER_TOP,    SNTO_EXTEND|SNTO_NEXTBD); break;\r\n    case AC_XTNREDGE:    SnapToCorner(hwnd, RXY_RIGHT_CENTER,  SNTO_EXTEND|SNTO_NEXTBD); break;\r\n    case AC_XTNBEDGE:    SnapToCorner(hwnd, RXY_CENTER_BOTTOM, SNTO_EXTEND|SNTO_NEXTBD); break;\r\n    case AC_MTNLEDGE:    SnapToCorner(hwnd, RXY_LEFT_CENTER,   SNTO_MOVETO|SNTO_NEXTBD); break;\r\n    case AC_MTNTEDGE:    SnapToCorner(hwnd, RXY_CENTER_TOP,    SNTO_MOVETO|SNTO_NEXTBD); break;\r\n    case AC_MTNREDGE:    SnapToCorner(hwnd, RXY_RIGHT_CENTER,  SNTO_MOVETO|SNTO_NEXTBD); break;\r\n    case AC_MTNBEDGE:    SnapToCorner(hwnd, RXY_CENTER_BOTTOM, SNTO_MOVETO|SNTO_NEXTBD); break;\r\n    case AC_STEPL:       StepWindow(hwnd, -conf.KBMoveStep, 0); break;\r\n    case AC_STEPT:       StepWindow(hwnd, -conf.KBMoveStep, 1); break;\r\n    case AC_STEPR:       StepWindow(hwnd, +conf.KBMoveStep, 0); break;\r\n    case AC_STEPB:       StepWindow(hwnd, +conf.KBMoveStep, 1); break;\r\n    case AC_SSTEPL:      StepWindow(hwnd, -conf.KBMoveSStep, 0); break;\r\n    case AC_SSTEPT:      StepWindow(hwnd, -conf.KBMoveSStep, 1); break;\r\n    case AC_SSTEPR:      StepWindow(hwnd, +conf.KBMoveSStep, 0); break;\r\n    case AC_SSTEPB:      StepWindow(hwnd, +conf.KBMoveSStep, 1); break;\r\n    case AC_FOCUSL:      ReallySetForegroundWindow(FindTiledWindow(hwnd, 0)); break;\r\n    case AC_FOCUST:      ReallySetForegroundWindow(FindTiledWindow(hwnd, 1)); break;\r\n    case AC_FOCUSR:      ReallySetForegroundWindow(FindTiledWindow(hwnd, 2)); break;\r\n    case AC_FOCUSB:      ReallySetForegroundWindow(FindTiledWindow(hwnd, 3)); break;\r\n\r\n    case AC_ASONOFF:     ActionASOnOff(); break;\r\n    case AC_MOVEONOFF:   ActionMoveOnOff(hwnd); break;\r\n    default:\r\n        // Shortcuts 0 - 35\r\n        if (AC_SHRT0 <=action && action < AC_SHRT0+ARR_SZ(conf.inputSequences)\r\n        &&  conf.inputSequences[action-AC_SHRT0] ) {\r\n            SendInputSequence(conf.inputSequences[action-AC_SHRT0]); break;\r\n        }\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic int DoWheelActions(HWND hwnd, enum action action)\r\n{\r\n    state.sactiondone = action;\r\n    // Return if in the scroll blacklist.\r\n    if (blacklisted(hwnd, &BlkLst.Scroll)) {\r\n        return 0; // Next hook!\r\n    }\r\n    int ret=1;\r\n    switch (action) {\r\n    case AC_ALTTAB:       ActionAltTab(state.prevpt, state.delta, /*laser=0*/0\r\n                             , state.shift?EnumStackedWindowsProc:EnumAltTabWindows); break;\r\n    case AC_VOLUME:       ActionVolume(state.delta); break;\r\n    case AC_TRANSPARENCY: ret = ActionTransparency(hwnd, state.delta); break;\r\n    case AC_LOWER:        ActionLower(hwnd, state.delta, state.shift, state.ctrl); break;\r\n    case AC_MAXIMIZE:     ActionMaxRestMin(hwnd, state.delta); break;\r\n    case AC_ROLL:         RollWindow(hwnd, state.delta); break;\r\n    case AC_HSCROLL:      ret = ScrollPointedWindow(state.prevpt, -state.delta, WM_MOUSEHWHEEL); break;\r\n    case AC_ZOOM:         ret = ActionZoom(hwnd, state.delta, 0); break;\r\n    case AC_ZOOM2:        ret = ActionZoom(hwnd, state.delta, 1); break;\r\n    case AC_NPSTACKED:    ActionAltTab(state.prevpt, state.delta,  state.shift, EnumStackedWindowsProc); break;\r\n    case AC_NPSTACKED2:   ActionAltTab(state.prevpt, state.delta, !state.shift, EnumStackedWindowsProc); break;\r\n//    case AC_BRIGHTNESS:   ActionBrightness(state.prevpt, state.delta); break;\r\n    default: {\r\n        ret = 0; // No action\r\n        // Use Shrt(X) on WheelUp and Shrt(X+1) on Wheel Down.\r\n        UCHAR rac = action + (state.delta<0);\r\n        if (AC_SHRT0 <=rac && rac < AC_SHRT0+ARR_SZ(conf.inputSequences)\r\n        &&  conf.inputSequences[rac-AC_SHRT0] ) {\r\n            ret = 1;\r\n            SendInputSequence(conf.inputSequences[rac-AC_SHRT0]); break;\r\n        }\r\n    }break;\r\n    }\r\n    // ret is 0: next hook or 1: block whel and AltUp.\r\n    state.blockaltup = ret && state.alt > BT_HWHEEL; // block or not;\r\n    return ret; // block or next hook\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void StartSpeedMes()\r\n{\r\n    if (conf.AeroMaxSpeed < 65535)\r\n        SetTimer(g_timerhwnd, SPEED_TIMER, conf.AeroSpeedTau, NULL);\r\n}\r\nstatic void StopSpeedMes()\r\n{\r\n    if (conf.AeroMaxSpeed < 65535)\r\n        KillTimer(g_timerhwnd, SPEED_TIMER); // Stop speed measurement\r\n}\r\nstatic DWORD WINAPI SendAltCtrlAlt(LPVOID p)\r\n{\r\n    Send_KEY_UD(VK_MENU, KEYEVENTF_KEYDOWN);\r\n    Send_KEY(VK_CONTROL);\r\n    Send_KEY_UD(VK_MENU, KEYEVENTF_KEYUP);\r\n\r\n    return 1;\r\n}\r\nstatic int xpure DoubleClamp(int ptx, int left, int right, int rwidth)\r\n{ // Same logic applies to y axis\r\n    int posx;\r\n    int cwidth = min(rwidth, right-left);\r\n    if (right-ptx < cwidth/2)\r\n        posx = right - rwidth;\r\n    else if (ptx-left < cwidth/2)\r\n        posx = left;\r\n    else\r\n        posx = ptx - 2*rwidth/5;\r\n\r\n    return posx;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// If we pass buttonX BT_PROBE it will tell us if we pass the blacklist.\r\nstatic int init_movement_and_actions(POINT pt, HWND hwnd, enum action action, int buttonX)\r\n{\r\n    RECT wnd;\r\n    state.prevpt = pt; // in case\r\n    int button = LOWORD(buttonX);\r\n    UCHAR probemode = HIWORD(buttonX);\r\n\r\n    // Make sure nothing is in the way\r\n    HideCursor();\r\n    state.sclickhwnd = NULL;\r\n    KillAltSnapMenu();\r\n\r\n    // Get window from point or use the given one.\r\n    // Get MDI chlild hwnd or root hwnd if not MDI!\r\n    state.mdiclient = NULL;\r\n    state.hwnd = hwnd? hwnd: MDIorNOT(WindowFromPoint(pt), &state.mdiclient);\r\n    if (!state.hwnd || state.hwnd == LastWin.hwnd || !IsWindow(state.hwnd)) {\r\n        return 0;\r\n    }\r\n\r\n    // Get monitor info\r\n    HMONITOR monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\r\n    MONITORINFO mi; mi.cbSize = sizeof(MONITORINFO);\r\n    GetMonitorInfo(monitor, &mi);\r\n    CopyRect(&state.origin.mon, &mi.rcWork);\r\n//    LOGA(\"MonitorInfo got!\");\r\n\r\n    // state.mdipt HAS to be set to Zero for ClientToScreen adds the offset\r\n    state.mdipt.x = state.mdipt.y = 0;\r\n    if (state.mdiclient) {\r\n        GetMDInfo(&state.mdipt, &mi.rcMonitor);\r\n        CopyRect(&state.origin.mon, &mi.rcMonitor);\r\n    }\r\n//    LOGA(\"MDI info got!\");\r\n\r\n    WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n    // Return if window is blacklisted,\r\n    // if we can't get information about it,\r\n    // or if the window is fullscreen.\r\n    // state.hwnd == GetDesktopWindow()\r\n    // state.hwnd == GetShellWindow()\r\n    if (blacklisted(state.hwnd, &BlkLst.Processes)\r\n    || isClassName(state.hwnd, TEXT(APP_NAMEA)TEXT(\"-Pin\"))\r\n    ||(blacklisted(state.hwnd, &BlkLst.Windows)\r\n       && !state.hittest && button != BT_WHEEL && button != BT_HWHEEL\r\n      )// does not apply in titlebar, nor for the wheel action...\r\n    || GetWindowPlacement(state.hwnd, &wndpl) == 0\r\n    || GetWindowRect(state.hwnd, &wnd) == 0\r\n    || ((state.origin.maximized = IsZoomed(state.hwnd)) && conf.BLMaximized)\r\n    || ((state.origin.fullscreen = IsFullscreenF(state.hwnd, &wnd, &mi.rcMonitor)) && !conf.FullScreen)\r\n    ){\r\n        return 0;\r\n    }\r\n//    LOGA(\"Blacklists passed!\");\r\n\r\n    // If no action is to be done then we passed all balcklists\r\n    if (probemode || action == AC_NONE) return 1;\r\n\r\n    // Set state\r\n    state.blockaltup = state.alt; // If alt is down...\r\n    // return if window has to be moved/resized and does not respond in 1/4 s.\r\n    state.prevpt=pt;\r\n\r\n    // Set origin width/height by default from current state/wndpl.\r\n    state.origin.monitor = MonitorFromWindow(state.hwnd, MONITOR_DEFAULTTONEAREST);\r\n    state.origin.dpi     = GetDpiForWindow(state.hwnd);\r\n    state.origin.width  = wndpl.rcNormalPosition.right-wndpl.rcNormalPosition.left;\r\n    state.origin.height = wndpl.rcNormalPosition.bottom-wndpl.rcNormalPosition.top;\r\n    state.resizable = IsResizable(state.hwnd);\r\n\r\n    GetMinMaxInfo(state.hwnd, &state.mmi.Min, &state.mmi.Max); // for CLAMPH/W functions\r\n\r\n    // Do things depending on what button was pressed\r\n    if (MOUVEMENT(action)) {\r\n        state.sactiondone = action;\r\n        if (GetProp(state.hwnd, APP_MOVEONOFF)) {\r\n            state.action = AC_NONE;\r\n            return 0; // Movement was disabled for this window.\r\n        }\r\n        // AutoFocus on movement/resize.\r\n        if (conf.AutoFocus || state.ctrl) {\r\n            SetForegroundWindowL(state.hwnd);\r\n        }\r\n        if (conf.DragSendsAltCtrl\r\n        && !(GetKeyState(VK_MENU)&0x8000)\r\n        && !(GetKeyState(VK_SHIFT)&0x8000)) {\r\n            // This will pop down menu and stuff\r\n            // In case autofocus did not do it.\r\n            // LOGA(\"SendAltCtrlAlt\");\r\n            DWORD lpThreadId; // In new thread because of lag under Win10\r\n            CloseHandle(CreateThread(NULL, STACK, SendAltCtrlAlt, 0, STACK_SIZE_PARAM_IS_A_RESERVATION, &lpThreadId));\r\n        }\r\n\r\n        // Set action statte.\r\n        state.action = action; // MOVE OR RESIZE\r\n        // Wether or not we will use the zones\r\n        state.usezones = ((conf.UseZones&9) == 9)^state.shift;\r\n\r\n        state.enumed = 0; // Reset enum stuff\r\n        StartSpeedMes(); // Speed timer\r\n\r\n        int ret;\r\n        if (state.action == AC_MOVE) {\r\n            ret = ActionMove(pt, button);\r\n        } else {\r\n            ret = ActionResize(pt, &wnd, button);\r\n        }\r\n        if      (ret == 1) return 1; // block mouse down!\r\n        else if (ret == 0) return 0; // Next hook!\r\n        // else ret == -1 ...\r\n        UpdateCursor(pt);\r\n        SetWindowTrans(state.hwnd);\r\n\r\n        // Send WM_ENTERSIZEMOVE and EVENT_SYSTEM_MOVESIZESTART\r\n        //NotifySizeMoveStaEnd(statse.hwnd, 1);\r\n        LastWin.start = 1;\r\n    } else if(button == BT_WHEEL || button == BT_HWHEEL) {\r\n        // Wheel actions, directly return here\r\n        // because maybe the action will not be done\r\n        if (GetProp(state.hwnd, APP_MOVEONOFF)) {\r\n            state.action = AC_NONE;\r\n            return 0; // Wheel was disabled for this window.\r\n        }\r\n        return DoWheelActions(state.hwnd, action);\r\n    } else if (action==AC_RESTORE) {\r\n        int rwidth, rheight;\r\n        if (GetRestoreData(state.hwnd, &rwidth, &rheight)&SNAPPED) {\r\n            ClearRestoreData(state.hwnd);\r\n            RECT rc;\r\n            GetWindowRect(state.hwnd, &rc);\r\n            int posx = DoubleClamp(pt.x, rc.left, rc.right, rwidth) - state.mdipt.x;\r\n            int posy = DoubleClamp(pt.y, rc.top, rc.bottom, rheight) - state.mdipt.y;\r\n\r\n            MoveWindowAsync(state.hwnd, posx, posy, rwidth, rheight);\r\n        }\r\n        if (state.hittest==2 && button == BT_LMB) return 0;\r\n        state.blockmouseup = 1;\r\n    } else {\r\n        SClickActions(state.hwnd, action);\r\n        state.blockmouseup = 1; // because the action is done\r\n    }\r\n    // AN ACTION HAS BEEN DONE!!!\r\n\r\n    // Remember time, position and button of this click\r\n    // so we can check for double-click\r\n    state.clicktime = GetTickCount();\r\n    state.clickpt = pt;\r\n    state.clickbutton = button;\r\n\r\n    // Prevent mousedown from propagating\r\n    return 1;\r\n}\r\nstatic int xpure IsAeraCapbutton(int area)\r\n{\r\n    return area == HTMINBUTTON\r\n        || area == HTMAXBUTTON\r\n        || area == HTCLOSE\r\n        || area == HTHELP;\r\n}\r\nstatic int xpure IsAreaAnyCap(int area)\r\n{\r\n    return area == HTCAPTION // Caption\r\n       || area == HTSYSMENU  // System menu\r\n       || IsAeraCapbutton(area); // Caption buttons\r\n}\r\nstatic int xpure IsAreaTopRZ(int area)\r\n{\r\n    return (area >= HTTOP && area <= HTTOPRIGHT); // Top resizing border\r\n}\r\nstatic int InTitlebar(POINT pt, enum action action,  enum button button)\r\n{\r\n    int willtest = ((conf.TTBActions&1) && !state.alt)\r\n                || ((conf.TTBActions&2) &&  state.alt);\r\n    if (willtest && action) {\r\n        HWND nhwnd = WindowFromPoint(pt);\r\n        if (!nhwnd) return 0; // Next hook!\r\n        // HWND hwnd = MDIorNOT(nhwnd, &state.mdiclient);\r\n        // if (blacklisted(hwnd, &BlkLst.Windows)) return 0; // Next hook\r\n\r\n        // Hittest to see if we are in a caption!\r\n        // Only accept caption buttons as a titlebar for the buttons that are\r\n        // Not in the blacklist (default LMB and RMB ttb actions only apply\r\n        // to the real titlebar (hittest=2).\r\n        assert(button-2 < 32 && button-2 >= 0); // Max is 32 buttons.\r\n        int area = HitTestTimeoutbl(nhwnd, pt);\r\n        if ( area == HTCAPTION // Real caption\r\n        || ( !(conf.BLCapButtons&(1<<(button-2))) && IsAreaAnyCap(area))\r\n        || ( !(conf.BLUpperBorder&(1<<(button-2))) && IsAreaTopRZ(area)) )\r\n        {\r\n            return area;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Actions to be performed in the Titlebar...\r\nstatic int TitleBarActions(POINT pt, enum action action, enum button button)\r\n{\r\n    state.hittest = 0; // Cursor in titlebar?\r\n    if (!conf.TTBActions) return -1; // fall through\r\n    if ((state.hittest = InTitlebar(pt, action, button))) {\r\n        return init_movement_and_actions(pt, NULL, action, button);\r\n    }\r\n    return -1; // Fall through\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Called on MouseUp and on AltUp when using GrabWithAlt\r\n//static void FinishMovement() { PostMessage(g_hkhwnd, WM_FINISHMOVEMENT, 0, 0); }\r\nstatic void FinishMovement()\r\n{\r\n    LOG(\"FinishMovement\");\r\n    //LogState(\"\");\r\n    StopSpeedMes();\r\n    ShowSnapLayoutPreview(ZONES_PREV_HIDE);\r\n//    Sleep(5000);\r\n    if (LastWin.hwnd\r\n    && (state.moving == NOT_MOVED || (!conf.FullWin && state.moving == 1))) {\r\n        if (!conf.FullWin && state.action == AC_RESIZE) {\r\n            ResizeAllSnappedWindowsAsync();\r\n        }\r\n        if (IsWindow(LastWin.hwnd) && !LastWin.snap){\r\n            if (LastWin.maximize) {\r\n                MaximizeRestore_atpt(LastWin.hwnd, SW_MAXIMIZE, 3);\r\n                LastWin.hwnd = NULL;\r\n            } else {\r\n                LastWin.end = 1;\r\n                MoveWindowInThread(&LastWin);\r\n            }\r\n        }\r\n    }\r\n    // Clear restore data if needed\r\n    unsigned rdata_flag = GetRestoreFlag(state.hwnd);\r\n    if (rdata_flag&SNCLEAR) {\r\n        ClearRestoreData(state.hwnd);\r\n    }\r\n\r\n    // Auto Remaximize if option enabled and conditions are met.\r\n    if (conf.AutoRemaximize && state.moving\r\n    && (state.origin.maximized || state.origin.fullscreen)\r\n    && !state.shift && !state.mdiclient && state.action == AC_MOVE) {\r\n        state.action = AC_NONE;\r\n        HMONITOR monitor = MonitorFromPoint(state.prevpt, MONITOR_DEFAULTTONEAREST);\r\n        if (monitor != state.origin.monitor) {\r\n            Sleep(8);  // Wait a little for moveThread.\r\n            WaitMovementEnd(); // extra waiting in case...\r\n\r\n            if (state.origin.maximized) {\r\n                MaximizeRestore_atpt(state.hwnd, SW_MAXIMIZE, 2);\r\n            }\r\n            if (state.origin.fullscreen) {\r\n                MaximizeRestore_atpt(state.hwnd, SW_FULLSCREEN, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    HideTransWin();\r\n    // Send WM_EXITSIZEMOVE and EVENT_SYSTEM_MOVESIZEEND\r\n    //NotifySizeMoveStaEnd(state.hwnd, 0);\r\n\r\n    if(conf.FullWin && state.moving == 1)\r\n        NotifySizeMoveStaEnd(state.hwnd, 0);\r\n\r\n    state.action = AC_NONE;\r\n    state.moving = 0;\r\n    state.snap = conf.AutoSnap;\r\n\r\n    // Unhook mouse if Alt is released\r\n    if (!state.alt) {\r\n        UnhookMouse();\r\n    } else {\r\n        // Just hide g_mainhwnd\r\n        HideCursor();\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// state.action is the current action\r\n// TODO: Generalize click combo...\r\nstatic void LockMovement()\r\n{\r\n    state.moving = CURSOR_ONLY;\r\n    LastWin.hwnd = NULL;\r\n    if(!conf.FullWin) HideTransWin();\r\n}\r\nstatic int ClickComboActions(enum action action)\r\n{\r\n    if (!(conf.MMMaximize&1)) return 0;\r\n    // Maximize/Restore the window if pressing Move, Resize mouse buttons.\r\n    if (state.action == AC_MOVE && action == AC_RESIZE) {\r\n        WaitMovementEnd();\r\n        if (IsZoomed(state.hwnd)) {\r\n            if (IsSamePTT(&state.clickpt, &state.prevpt)) {\r\n                state.moving = CURSOR_ONLY;\r\n                RestoreWindow(state.hwnd);\r\n            } else {\r\n                state.moving = 0;\r\n                MouseMove(state.prevpt);\r\n            }\r\n        } else if (state.resizable) {\r\n            LockMovement();\r\n            if (IsHotclick(state.alt)) {\r\n                state.action = AC_NONE;\r\n                state.moving = 0;\r\n            }\r\n            MaximizeRestore_atpt(state.hwnd, SW_MAXIMIZE, 2);\r\n        }\r\n        state.blockmouseup = 1;\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Generalization of Click combo.\r\nstatic void DoComboActions(enum action action, enum button button)\r\n{\r\n    // For safety\r\n    if( !MOUVEMENT(state.action) )\r\n        return;\r\n\r\n    enum action accombo = GetActionMR(button);\r\n    if (ActionInfo(accombo) & (ACINFO_MOVE|ACINFO_RESIZE|ACINFO_CLOSE)) {\r\n        LockMovement();\r\n    }\r\n    if (button == BT_WHEEL || button == BT_HWHEEL) {\r\n        // Handle wheel combo.\r\n        if (accombo) {\r\n            DoWheelActions(state.hwnd, accombo);\r\n            // No mouseup to block for wheel actions...\r\n        }\r\n    } else {\r\n        // Other buttons.\r\n        if (accombo) {\r\n            SClickActions(state.hwnd, accombo);\r\n            state.blockmouseup = 1;\r\n        } else {\r\n            // Try to do Move/Resize combo..\r\n            if( ClickComboActions(action) )\r\n                return;\r\n\r\n            // Make default actions if nothing was overwritten.\r\n            switch(button) {\r\n            //case BT_MB4: break;\r\n            // MB5 toggles the snapping mode\r\n            case BT_MB5: ToggleSnapState(); break;\r\n            // Toggle SnapToZones with RMB/MMB by default.\r\n            default: ActionToggleSnapToZoneMode(); break;\r\n            }\r\n            state.blockmouseup = 1; // Block anyway\r\n        }\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic xpure int GetButton(WPARAM wp, LPARAM lp)\r\n{\r\n    PMSLLHOOKSTRUCT msg = (PMSLLHOOKSTRUCT)lp;\r\n    return\r\n        (wp==WM_LBUTTONDOWN||wp==WM_LBUTTONUP)?BT_LMB:\r\n        (wp==WM_MBUTTONDOWN||wp==WM_MBUTTONUP)?BT_MMB:\r\n        (wp==WM_RBUTTONDOWN||wp==WM_RBUTTONUP)?BT_RMB:\r\n        (wp==WM_MOUSEWHEEL)?BT_WHEEL:\r\n        (wp==WM_MOUSEHWHEEL)?BT_HWHEEL:\r\n        (wp==WM_XBUTTONDOWN||wp==WM_XBUTTONUP)? BT_MB4-1+HIWORD(msg->mouseData):\r\n        BT_NONE;\r\n}\r\nstatic xpure enum buttonstate GetButtonState(WPARAM wp)\r\n{\r\n    return\r\n        (  wp==WM_LBUTTONDOWN||wp==WM_MBUTTONDOWN\r\n        || wp==WM_RBUTTONDOWN||wp==WM_XBUTTONDOWN)? STATE_DOWN\r\n        : (wp==WM_LBUTTONUP  ||wp==WM_MBUTTONUP\r\n        || wp==WM_RBUTTONUP  ||wp==WM_XBUTTONUP)? STATE_UP\r\n        : (wp==WM_MOUSEWHEEL ||wp==WM_MOUSEHWHEEL)? STATE_DOWN\r\n        : STATE_NONE;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// This is somewhat the main function, it is active only when the ALT key is\r\n// pressed, or is always on when conf.keepMousehook is enabled.\r\n//\r\n// We should not call the next Hook for button 6-20 (manual call only).\r\n#define CALLNEXTHOOK (button>BT_MB5 && button <= BT_MB20? 1: CallNextHookEx(NULL, nCode, wParam, lParam))\r\n\r\n#ifdef NO_HOOK_LL\r\n#define CallNextHookEx(NULL, nCode, wParam, lParam) 0\r\n#endif // NO_HOOK_LL\r\n//\r\nLRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam)\r\n{\r\n//    if (state.ignoreclick) LOGA(\"IgnoreClick\")\r\n    // Set up some variables\r\n    PMSLLHOOKSTRUCT msg = (PMSLLHOOKSTRUCT)lParam;\r\n    POINT pt = msg->pt;\r\n//    if ((0x201 > wParam || wParam > 0x205) && wParam != 0x20a && wParam != WM_MOUSEMOVE)\r\n//        LOGA(\"wParam=%lx, data=%lx, time=%lu, extra=%lx, block?=%d, ignored?=%d\", (DWORD)wParam\r\n//            , (DWORD)msg->mouseData, (DWORD)msg->time, (DWORD)msg->dwExtraInfo\r\n//            , (int)state.blockmouseup, (int)state.ignoreclick);\r\n    if (nCode != HC_ACTION || state.ignoreclick || ScrollLockState())\r\n        return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n\r\n    // Mouse move, only if it is not exactly the same point than before\r\n    if (wParam == WM_MOUSEMOVE) {\r\n        if (SamePt(pt, state.prevpt)) return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n        // Store prevpt so we can check if the hook goes stale\r\n        if( state.moving == DRAG_WAIT ) {\r\n            if (IsPtDragOut(&state.prevpt, &pt))\r\n                return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n            state.moving = 0;\r\n\r\n            MouseMove(state.prevpt);\r\n        }\r\n        state.prevpt = pt;\r\n\r\n        // Reset double-click time\r\n        if (!IsSamePTT(&pt, &state.clickpt)) {\r\n            state.clicktime = 0;\r\n        }\r\n        // Move the window  && (state.moving || !IsSamePTT(&pt, &state.clickpt))\r\n        if (state.action && !state.blockmouseup) { // resize or move...\r\n            // Move the window every few frames.\r\n            static DWORD oldtime;\r\n            if (conf.RezTimer==1) {\r\n                // Only move window if the EVENT TIME is different.\r\n                //LOGA(\"msg->time=%lu\", msg->time);\r\n                if (msg->time != oldtime) {\r\n                    MouseMove(pt);\r\n                    oldtime = msg->time;\r\n                }\r\n            } else {\r\n                static UCHAR updaterate;\r\n                updaterate = (updaterate+1)%(state.action==AC_MOVE? conf.MoveRate: conf.ResizeRate);\r\n                if (!updaterate) {\r\n                    MouseMove(pt);\r\n                } else if (conf.RezTimer == 3 && msg->time != oldtime) {\r\n                    MouseMove(pt);\r\n                    oldtime = msg->time;\r\n                }\r\n            }\r\n        }\r\n        return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n    }\r\n\r\n    //Get Button state and data.\r\n    enum buttonstate buttonstate = GetButtonState(wParam);\r\n    enum button button = (enum button)GetButton(wParam, lParam);\r\n    // Get wheel delta\r\n    state.delta = GET_WHEEL_DELTA_WPARAM(msg->mouseData);\r\n\r\n//    if (button<=BT_MB5)\r\n//        LOGA(\"button=%d, %s\", button, buttonstate==STATE_DOWN?\"DOWN\":buttonstate==STATE_UP?\"UP\":\"NONE\");\r\n\r\n    // Get actions or alternate (depends on ModKey())!\r\n    enum action action = GetAction(button); // Normal action\r\n    enum action ttbact = GetActionT(button);// Titlebar action\r\n\r\n    // Handle another click if we are already busy with an action\r\n    if (buttonstate == STATE_DOWN && state.action && state.action != conf.GrabWithAlt[ModKey()]) {\r\n        // Handle click combo action!\r\n        DoComboActions(action, button);\r\n        return 1; // Block mousedown so altsnap does not remove g_mainhwnd\r\n    }\r\n\r\n    // Handle Titlebars actions if any\r\n    if (ttbact && buttonstate == STATE_DOWN) {\r\n        int ret = TitleBarActions(pt, ttbact, button);\r\n        // If we have nothing to do in the titlebar\r\n        if (ret < 0 && conf.InactiveScroll && !state.alt && !state.action\r\n        && (wParam == WM_MOUSEWHEEL || wParam == WM_MOUSEHWHEEL)) {\r\n            // Scroll inactive window with wheel action...\r\n            ret = ScrollPointedWindow(pt, state.delta, wParam);\r\n        }\r\n        if (ret == 0) return CALLNEXTHOOK;\r\n        else if (ret == 1) return 1;\r\n        ttbact = AC_NONE; // No titlebar action to be done.\r\n    }\r\n\r\n    // Check if the click is is a Hotclick and should enable ALT.\r\n    // If the hotclick is also mapped to an action, then we execute it.\r\n    int is_hotclick = IsHotclick(button);\r\n    if (!state.alt && is_hotclick && buttonstate == STATE_DOWN) {\r\n        state.alt = button;\r\n        // Start an action now if hotclick is also an action.\r\n        // If action == AC_NONE, we are checking for blacklists...\r\n        if (!action) {\r\n            // If no action is to be made,we must reset\r\n            // clickpt and actiondone for the Click UP\r\n            // to be forwarded.\r\n            state.sactiondone = AC_NONE;\r\n            state.clickpt = pt;\r\n        }\r\n        int ret = init_movement_and_actions(pt, NULL, action, button);\r\n        if (ret) {\r\n            // Not balcklisted, action may have been performed!\r\n            if (action) state.alt = 0; // Done!\r\n            return 1;\r\n        }\r\n\r\n        // Window is blacklisted.\r\n        // So me must forward the click...\r\n        state.alt = 0; // release alt!\r\n        state.fwmouseup = 1; // Forward up click...\r\n        return CALLNEXTHOOK; // forward down click\r\n    } else if (state.alt == button && is_hotclick && buttonstate == STATE_UP) {\r\n        state.alt = 0;\r\n        // Block hotclick up if not an action\r\n        // Because it will not be done by state.blockmouseup\r\n        // if (!action) return 1;\r\n        if (!action && (conf.AblockHotclick || state.sactiondone))\r\n            return 1;\r\n        // If no action is to be done, we forward the click\r\n        Send_Click_Thread(button);\r\n        return 1;\r\n    }\r\n\r\n    // Check if we must BLOCK MOUSE UP... (after releasing hotclicks)\r\n    if (buttonstate == STATE_UP) {\r\n        // fw/block mouse up and decrement counter.\r\n        if (state.fwmouseup) {\r\n            state.fwmouseup = 0;\r\n            //LOGA(\"forwarded BT%d mouse up\", button);\r\n            return CALLNEXTHOOK;\r\n        } else if (state.blockmouseup) {\r\n            state.blockmouseup--;\r\n            if(!state.blockmouseup && !state.action && !state.alt)\r\n                UnhookMouseOnly(); // We no longer need the hook.\r\n            //LOGA(\"blocked BT%d mouse up\", button);\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    // Long click grab timer\r\n    if (conf.LongClickMove && !state.action && !state.alt) {\r\n        if (wParam == WM_LBUTTONDOWN) {\r\n            state.clickpt = pt;\r\n            // Start Grab timer\r\n            SetTimer(g_timerhwnd, GRAB_TIMER, conf.LongClickMoveDelay, NULL);\r\n        } else {\r\n            // Cancel Grab timer.\r\n            KillTimer(g_timerhwnd, GRAB_TIMER);\r\n            return CALLNEXTHOOK;\r\n        }\r\n    }\r\n\r\n    // Nothing to do...\r\n    if (!action && !ttbact && buttonstate == STATE_DOWN)\r\n        return CALLNEXTHOOK;//CallNextHookEx(NULL, nCode, wParam, lParam);\r\n\r\n    // INIT ACTIONS on mouse down if Alt is down...\r\n    if (buttonstate == STATE_DOWN && state.alt) {\r\n        //LogState(\"BUTTON DOWN:\\n\");\r\n        // Double ckeck some hotkey is pressed.\r\n        if (!state.action\r\n        && !IsHotclick(state.alt)\r\n        && !IsHotkeyDown()) {\r\n            UnhookMouse();\r\n            return CALLNEXTHOOK; //CallNextHookEx(NULL, nCode, wParam, lParam);\r\n        }\r\n        // Start an action (alt is down)\r\n        int ret = init_movement_and_actions(pt, NULL, action, button);\r\n        if (!ret) return CALLNEXTHOOK;//CallNextHookEx(NULL, nCode, wParam, lParam);\r\n        else      return 1; // block mousedown\r\n\r\n    // BUTTON UP\r\n    } else if (buttonstate == STATE_UP) {\r\n        //LogState(\"BUTTON UP:\\n\");\r\n        SetWindowTrans(NULL); // Reset window transparency\r\n\r\n        if( action\r\n        &&( state.action == action || (state.action == AC_MOVE && action == AC_RESIZE))\r\n        &&(!state.moving || state.moving == DRAG_WAIT)// No drag occured\r\n        &&  state.sactiondone <= AC_RESIZE // Only move/resize may have happened in the meantime\r\n        && !state.ctrl // Ctrl is not down (because of focusing)\r\n        && IsSamePTT(&pt, &state.clickpt) // same point (within drag)\r\n        && !IsDoubleClick(button)) { // Long click unless PiercingClick=1\r\n            FinishMovement();\r\n            // Mouse UP actions here only in case of MOVEMENT!:\r\n            // Perform an action on mouse up without drag on move/resize\r\n            int inTTB = 2*(!!state.hittest); //If we are in the titlebar add two\r\n            if (action == AC_MOVE)   action = conf.MoveUp[ModKey()+inTTB];\r\n            if (action == AC_RESIZE) action = conf.ResizeUp[ModKey()+inTTB];\r\n\r\n            if (action > AC_RESIZE) {\r\n                SClickActions(state.hwnd, action);\r\n            } else {\r\n                LOG(\"Forwarding the %d the click!\", button);\r\n                // Forward the click if no action was Mapped!\r\n                // Win 10+ does not like receaving button down\r\n                // when the button is already down, so we create a thread.\r\n                Send_Click_Thread(button);\r\n            }\r\n            return 1; // block mouseup\r\n        }\r\n        // If a button performing an action is released,\r\n        // we finish all moveent and proceed.\r\n        if (action && state.action) {\r\n            FinishMovement();\r\n            return 1;\r\n        }\r\n    }\r\n    return CALLNEXTHOOK; //CallNextHookEx(NULL, nCode, wParam, lParam);\r\n} // END OF LL MOUSE PROCK\r\n#undef CALLNEXTHOOK\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void HookMouse()\r\n{\r\n    state.moving = 0; // Used to know the first time we call MouseMove.\r\n    #ifndef NO_HOOK_LL\r\n    if (conf.keepMousehook) {\r\n        PostMessage(g_timerhwnd, WM_TIMER, REHOOK_TIMER, 0);\r\n    }\r\n    #endif\r\n\r\n    // Check if mouse is already hooked\r\n    if (mousehook)\r\n        return ;\r\n\r\n    // Set up the mouse hook\r\n    #ifdef NO_HOOK_LL\r\n    mousehook = (void*)SetTimer(g_timerhwnd, POOL_TIMER, 32, NULL);\r\n    #else\r\n    mousehook = SetWindowsHookEx(WH_MOUSE_LL, LowLevelMouseProc, hinstDLL, 0);\r\n    #endif\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void UnhookMouseOnly()\r\n{\r\n    // Do not unhook if not hooked or if the hook is still used for something\r\n    if (!mousehook || conf.keepMousehook || state.blockmouseup)\r\n        return;\r\n\r\n    // Remove mouse hook\r\n    #ifdef NO_HOOK_LL\r\n    KillTimer(g_timerhwnd, POOL_TIMER);\r\n    #else\r\n    UnhookWindowsHookEx(mousehook);\r\n    #endif\r\n    mousehook = NULL;\r\n}\r\nstatic void UnhookMouse()\r\n{\r\n    // Stop action\r\n    state.action = AC_NONE;\r\n    state.ctrl = 0;\r\n    state.shift = 0;\r\n    state.moving = 0;\r\n\r\n    SetWindowTrans(NULL);\r\n    StopSpeedMes();\r\n\r\n    HideCursor();\r\n\r\n    // Release cursor trapping in case...\r\n    ClipCursorOnce(NULL);\r\n\r\n    UnhookMouseOnly();\r\n}\r\nstatic xpure int IsAreaLongClikcable(int area)\r\n{\r\n    return IsAeraCapbutton(area)\r\n        || area == HTHSCROLL\r\n        || area == HTVSCROLL\r\n        || area == HTSYSMENU;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Window for timers only...\r\nLRESULT CALLBACK TimerWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (msg == WM_TIMER) {\r\n        switch (wParam) {\r\n        #ifndef NO_HOOK_LL\r\n        case REHOOK_TIMER: {\r\n            // Silently rehook hooks if they have been stopped (>= Win7 and LowLevelHooksTimeout)\r\n            // This can often happen if locking or sleeping the computer a lot\r\n            POINT pt;\r\n            GetCursorPos(&pt); // I donot know if we should really use the ASYN version.\r\n            if (mousehook && !SamePt(state.prevpt, pt)) {\r\n                UnhookWindowsHookEx(mousehook);\r\n                mousehook = SetWindowsHookEx(WH_MOUSE_LL, LowLevelMouseProc, hinstDLL, 0);\r\n            }\r\n            } break;\r\n        #endif\r\n        case SPEED_TIMER: {\r\n            static POINT oldpt;\r\n            static int has_moved_to_fixed_pt;\r\n            if (state.moving)\r\n                state.Speed=max(abs(oldpt.x-state.prevpt.x), abs(oldpt.y-state.prevpt.y));\r\n            else state.Speed=0;\r\n            oldpt = state.prevpt;\r\n            if (state.moving && state.Speed == 0 && !has_moved_to_fixed_pt && !MM_THREAD_ON) {\r\n                has_moved_to_fixed_pt = 1;\r\n                MouseMove(state.prevpt);\r\n            }\r\n            if (state.Speed) has_moved_to_fixed_pt = 0;\r\n            } break;\r\n        case GRAB_TIMER: {\r\n            // Grab the action after a certain amount of time of click down\r\n            HWND ptwnd;\r\n            UCHAR buttonswaped;\r\n            POINT pt;\r\n            GetMsgPT(&pt); // Hopefully the real current cursor position\r\n            if (IsSamePTT(&pt, &state.clickpt)\r\n            &&  GetAsyncKeyState(1 + (buttonswaped = !!GetSystemMetrics(SM_SWAPBUTTON)))\r\n            && (ptwnd = WindowFromPoint(pt))\r\n            &&!IsAreaLongClikcable(HitTestTimeoutbl(ptwnd, pt))) {\r\n                // Determine if we should actually move the Window by probing with AC_NONE\r\n                state.hittest = 0; // No specific hittest here.\r\n                int ret = init_movement_and_actions(pt, NULL, AC_MOVE, BT_PROBE);\r\n                if (ret) { // Release mouse click if we have to move.\r\n                    InterlockedIncrement(&state.ignoreclick);\r\n                    mouse_event(buttonswaped?MOUSEEVENTF_RIGHTUP:MOUSEEVENTF_LEFTUP\r\n                               , 0, 0, 0, GetMessageExtraInfo());\r\n                    InterlockedDecrement(&state.ignoreclick);\r\n                    init_movement_and_actions(pt, NULL, AC_MOVE, 0);\r\n                }\r\n            }\r\n            KillTimer(g_timerhwnd, GRAB_TIMER);\r\n            return 0;\r\n            } break;\r\n        #ifdef ALTUP_TIMER\r\n        case ALTUP_TIMER : {\r\n            // Simulate AltUp (dumb)\r\n            HotkeyUp();\r\n            KillTimer(g_timerhwnd, ALTUP_TIMER);\r\n            } break;\r\n        #endif\r\n        #ifdef NO_HOOK_LL\r\n        case POOL_TIMER: {\r\n            static MSLLHOOKSTRUCT omsll; // old state\r\n            static BYTE obts[4];\r\n            BYTE nbts[4] = {\r\n                !!(GetAsyncKeyState(VK_LBUTTON)&0x8000),\r\n                !!(GetAsyncKeyState(VK_RBUTTON)&0x8000),\r\n                !!(GetAsyncKeyState(VK_MBUTTON)&0x8000),\r\n                0,\r\n            };\r\n            MSLLHOOKSTRUCT nmsll = {0};\r\n            GetCursorPos(&nmsll.pt);\r\n            nmsll.time = GetTickCount();\r\n            if (nmsll.time == omsll.time)\r\n                return 0;\r\n\r\n            if (!SamePt(nmsll.pt, omsll.pt))\r\n                LowLevelMouseProc(HC_ACTION, WM_MOUSEMOVE, (LPARAM)&nmsll);\r\n            if (nbts[0] != obts[0])\r\n                LowLevelMouseProc(HC_ACTION, nbts[0]?WM_LBUTTONDOWN:WM_LBUTTONUP, (LPARAM)&nmsll);\r\n            if (nbts[1] != obts[1])\r\n                LowLevelMouseProc(HC_ACTION, nbts[1]?WM_RBUTTONDOWN:WM_RBUTTONUP, (LPARAM)&nmsll);\r\n            if (nbts[2] != obts[2])\r\n                LowLevelMouseProc(HC_ACTION, nbts[2]?WM_MBUTTONDOWN:WM_MBUTTONUP, (LPARAM)&nmsll);\r\n\r\n            memcpy(&omsll, &nmsll, sizeof(omsll));\r\n            memcpy(obts, nbts, sizeof(obts));\r\n            return 0;\r\n            } break;\r\n        #endif // NO_HOOK_LL\r\n        default:;\r\n        }\r\n    } else if (msg == WM_DESTROY) {\r\n        KillTimer(g_timerhwnd, REHOOK_TIMER);\r\n        KillTimer(g_timerhwnd, SPEED_TIMER);\r\n        KillTimer(g_timerhwnd, GRAB_TIMER);\r\n        #ifdef NO_HOOK_LL\r\n        KillTimer(g_timerhwnd, POOL_TIMER);\r\n        #endif // NO_HOOK_LL\r\n\r\n    }\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Function to calculate the necessary dimentions for the menuitem.\r\n// In response to the WM_MEASUREITEM message\r\nstatic LPARAM MeasureMenuItem(HWND hwnd, WPARAM wParam, LPARAM lParam, UINT dpi, HFONT mfont)\r\n{\r\n    LPMEASUREITEMSTRUCT lpmi = (LPMEASUREITEMSTRUCT)lParam;\r\n    if(!lpmi) return FALSE;\r\n    struct menuitemdata *data = (struct menuitemdata *)lpmi->itemData;\r\n    if(!data) return FALSE;\r\n    TCHAR *text = data->txtptr;\r\n    //LOGA(\"WM_MEASUREITEM: id=%u, txt=%S\", lpmi->itemID, data->txtptr);\r\n\r\n    HDC dc = GetDC(hwnd);\r\n\r\n    // Select proper font.\r\n//    HFONT mfont = CreateNCMenuFont(dpi);\r\n    HFONT oldfont=(HFONT)SelectObject(dc, mfont);\r\n\r\n    int xmargin = GetSystemMetricsForDpi(SM_CXFIXEDFRAME, dpi);\r\n    int ymargin = GetSystemMetricsForDpi(SM_CYFIXEDFRAME, dpi);\r\n    int xicosz =  GetSystemMetricsForDpi(SM_CXSMICON, dpi);\r\n    int yicosz =  GetSystemMetricsForDpi(SM_CYSMICON, dpi);\r\n\r\n    SIZE sz; // Get text size in both dimentions\r\n    GetTextExtentPoint32(dc, text, lstrlen(text), &sz);\r\n\r\n    // Text width + icon width + 4 margins\r\n    lpmi->itemWidth = sz.cx + xicosz + 4*xmargin;\r\n\r\n    // Text height/Icon height + margin\r\n    lpmi->itemHeight = max(sz.cy, yicosz) + ymargin;\r\n\r\n    SelectObject(dc, oldfont); // restore old font\r\n//    DeleteObject(mfont); // Delete menufont.\r\n    ReleaseDC(hwnd, dc);\r\n    return TRUE;\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Function to custom draw the menu item, in response to WM_DRAWITEM.\r\n// We must both draw he small icon and the menu text.\r\n// We must also draw the selected menu with the highligh color.\r\nstatic LRESULT DrawMenuItem(HWND hwnd, WPARAM wParam, LPARAM lParam, UINT dpi, HFONT mfont)\r\n{\r\n    LPDRAWITEMSTRUCT di = (LPDRAWITEMSTRUCT)lParam;\r\n    if (!di) return FALSE;\r\n    struct menuitemdata *data = (struct menuitemdata *)di->itemData;\r\n    if (!data) return FALSE;\r\n\r\n    // Try to be dpi-aware as good as we can...\r\n    int xmargin = GetSystemMetricsForDpi(SM_CXFIXEDFRAME, dpi);\r\n    int xicosz =  GetSystemMetricsForDpi(SM_CXSMICON, dpi);\r\n    int yicosz =  GetSystemMetricsForDpi(SM_CYSMICON, dpi);\r\n\r\n    //LOGA(\"WM_DRAWITEM: id=%u, txt=%S\", di->itemID, data->txtptr);\r\n\r\n    int bgcol, txcol;\r\n    if(di->itemState & ODS_SELECTED) {\r\n        // Item is highlited\r\n        bgcol = COLOR_HIGHLIGHT ;\r\n        txcol = COLOR_HIGHLIGHTTEXT ;\r\n    } else {\r\n        // normal\r\n        bgcol = COLOR_MENU ;\r\n        txcol = COLOR_MENUTEXT ;\r\n    }\r\n    if(di->itemState & ODS_GRAYED) {\r\n        txcol = COLOR_GRAYTEXT;\r\n    }\r\n\r\n    HBRUSH bgbrush = GetSysColorBrush(bgcol);\r\n    // Set\r\n    SetBkColor(di->hDC, GetSysColor(bgcol));\r\n    SetTextColor(di->hDC, GetSysColor(txcol));\r\n\r\n    // Highlight menu entry\r\n    HPEN oldpen=(HPEN)SelectObject(di->hDC, GetStockObject(NULL_PEN));\r\n    HBRUSH oldbrush=(HBRUSH)SelectObject(di->hDC, bgbrush);\r\n    Rectangle(di->hDC, di->rcItem.left, di->rcItem.top, di->rcItem.right+1, di->rcItem.bottom+1);\r\n\r\n//    HFONT mfont = CreateNCMenuFont(dpi);\r\n    HFONT oldfont=(HFONT)SelectObject(di->hDC, mfont);\r\n\r\n    SIZE sz;\r\n    GetTextExtentPoint32(di->hDC, data->txtptr, lstrlen(data->txtptr), &sz);\r\n    //LOGA(\"WM_DRAWITEM: txtXY=%u, %u, txt=%S\", (UINT)sz.cx, (UINT)sz.cy, data->txtptr);\r\n\r\n    int totheight = di->rcItem.bottom - di->rcItem.top; // total menuitem height\r\n    int yicooffset = (totheight - yicosz)/2; // Center icon vertically\r\n    int ytxtoffset = (totheight - sz.cy)/2;   // Center text vertically\r\n\r\n    DrawIconEx(di->hDC\r\n        , di->rcItem.left+xmargin\r\n        , di->rcItem.top + yicooffset\r\n        , (di->itemState & ODS_GRAYED)\r\n          ? LoadIcon(NULL, IDI_HAND)\r\n          : data->icon\r\n        , xicosz, yicosz\r\n        , 0, NULL, DI_NORMAL);\r\n    if (IsIconic(hwnds[di->itemID-1])) {\r\n        HPEN npen = CreatePen(PS_SOLID, yicosz/5, GetSysColor(txcol));\r\n        HPEN prevpen = (HPEN)SelectObject(di->hDC, npen);\r\n        MoveToEx(di->hDC, di->rcItem.left+xmargin, di->rcItem.top + yicooffset+yicosz-1, NULL);\r\n        LineTo(di->hDC, di->rcItem.left+xmargin+xicosz,di->rcItem.top + yicooffset+yicosz-1);\r\n        DeleteObject(SelectObject(di->hDC, prevpen));\r\n    }\r\n// TODO: Draw a cross...\r\n//    if (state.ctrl) {\r\n//        HPEN npen = CreatePen(PS_SOLID, yicosz/5, GetSysColor(txcol));\r\n//        HPEN prevpen = SelectObject(di->hDC, npen);\r\n//        MoveToEx(di->hDC, di->rcItem.left+xmargin,        di->rcItem.top + yicooffset, NULL);\r\n//        LineTo(di->hDC,   di->rcItem.left+xmargin+xicosz, di->rcItem.top + yicooffset+yicosz);\r\n//        MoveToEx(di->hDC, di->rcItem.left+xmargin, di->rcItem.top + yicooffset+yicosz, NULL);\r\n//        LineTo(di->hDC,   di->rcItem.left+xmargin+xicosz, di->rcItem.top + yicooffset);\r\n//\r\n//        DeleteObject(SelectObject(di->hDC, prevpen));\r\n//    }\r\n\r\n    // Adjust x offset for Text drawing...\r\n    di->rcItem.left += xicosz + xmargin*3;\r\n    di->rcItem.top += ytxtoffset;\r\n    //LOGA(\"menuitemheight = %ld\", di->rcItem.bottom-di->rcItem.top);\r\n    DrawText(di->hDC, data->txtptr, -1, &di->rcItem, 0); // Menuitem Text\r\n\r\n    // Restore dc context\r\n    SelectObject(di->hDC, oldfont); // restore old font\r\n//    DeleteObject(mfont); // Delete menufont.\r\n    SelectObject(di->hDC, oldpen);\r\n    SelectObject(di->hDC, oldbrush);\r\n\r\n    return TRUE;\r\n}\r\nstatic void SendSYSCOMMANDToMenuItem(HWND hwnd, int id, HMENU hmenu, WPARAM sc_command )\r\n{\r\n    if (conf.RCCloseMItem\r\n    && 0 <= id && (UINT)id < numhwnds\r\n    && GetWindowLongPtr(hwnd, GWLP_USERDATA) == 3\r\n    && IsWindow(hwnds[id]) ) {\r\n        if (sc_command == SC_CLOSE // remove topmost flag for close command\r\n        &&  GetWindowLongPtr(hwnds[id], GWL_EXSTYLE)&WS_EX_TOPMOST) {\r\n            HWND pinhwnd = GetPinWindow(hwnds[id]);\r\n            if (pinhwnd) DestroyWindow(pinhwnd);\r\n        }\r\n        PostMessage(hwnds[id], WM_SYSCOMMAND, sc_command, 0);\r\n\r\n        if (sc_command == SC_CLOSE)\r\n            EnableMenuItem(hmenu, id, MF_BYPOSITION|MF_GRAYED);\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Window for single click commands for menu\r\nLRESULT CALLBACK MenuWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    static UINT dpi;\r\n    static HFONT mfont= NULL;\r\n    static HWND fhwndori = NULL;\r\n    switch (msg) {\r\n    case WM_CREATE: {\r\n        // Save the original foreground window.\r\n        dpi = GetDpiForWindow(hwnd);\r\n        fhwndori = GetForegroundWindow();\r\n        mfont = NULL;\r\n        } break;\r\n    case WM_DPICHANGED: {\r\n        dpi = LOWORD(wParam); // Update dpi value if changed...\r\n        if (mfont) {\r\n            DeleteObject(mfont); // Delete menufont if needed.\r\n            mfont = NULL;\r\n        }\r\n        } break;\r\n    case WM_INITMENU:\r\n        state.unikeymenu = (HMENU)wParam;\r\n        break;\r\n    case WM_GETCLICKHWND:\r\n        return (LRESULT)state.sclickhwnd;\r\n    case WM_COMMAND: {\r\n        if (LOWORD(wParam)) {\r\n            // UNIKEY MENU (LOWORD of wParam munst be non NULL.\r\n            // LOG(\"Unikey menu WM_COMMAND, wp=%X, lp=%X\", (UINT)wParam, (UINT)lParam);\r\n            Send_KEY(VK_BACK); // Errase old char...\r\n\r\n            // Send UCS-2 or Lower+Upper UTF-16 surrogates of the UNICODE char.\r\n            SendUnicodeKey(LOWORD(wParam)); // USC-2 or Lower surrogate\r\n            if(HIWORD(wParam)) SendUnicodeKey(HIWORD(wParam)); // Upper surrogate\r\n\r\n            state.sclickhwnd = NULL;\r\n        } else if (HIWORD(wParam) && IsWindow(state.sclickhwnd) ) {\r\n            // ACTION MENU LOWORD(wParam) has to be zero to differenctiae with unikey menu\r\n            LOG(\"Action Menu WM_COMMAND, wp=%X, lp=%X\", (UINT)wParam, (UINT)lParam);\r\n            enum action action = (enum action)HIWORD(wParam);\r\n            if (action) {\r\n                state.prevpt = state.clickpt;\r\n                if(action == AC_ORICLICK) {\r\n                    ShowWindow(hwnd, SW_HIDE);\r\n                    SetCursorPos(state.clickpt.x, state.clickpt.y);\r\n                    Send_Click(state.clickbutton);\r\n                } else {\r\n                    SClickActions(state.sclickhwnd, action);\r\n                }\r\n\r\n                // We should not refocus windows if those\r\n                // actions were performed...\r\n                if (action == AC_LOWER || action == AC_MINIMIZE\r\n                ||  action == AC_KILL || action == AC_CLOSE)\r\n                    fhwndori = NULL;\r\n            }\r\n            // Menu closes now.\r\n            state.unikeymenu = NULL;\r\n            PostMessage(hwnd, WM_CLOSE, 0, 0); // Done!\r\n            return 0;\r\n        }\r\n        } break;\r\n    case WM_MENURBUTTONUP:\r\n    case WM_MBUTTONUP: {\r\n        // The user released the right button.\r\n        // We must close the corresponding Window in the windows list\r\n        int id = wParam; // Zero-based menu id.\r\n        WPARAM sc_command = SC_MINIMIZE;\r\n        HMENU hmenu = (HMENU)lParam;\r\n        if (msg == WM_MBUTTONUP) {\r\n            // Simulate teh same thing with Middle mouse UP.\r\n            POINT pt;\r\n            DWORD msgpos = GetMessagePos();\r\n            pt.x = GET_X_LPARAM(msgpos);\r\n            pt.y = GET_Y_LPARAM(msgpos);\r\n            hmenu = state.unikeymenu;\r\n            id = MenuItemFromPoint(hwnd, hmenu, pt);\r\n            sc_command = SC_CLOSE;\r\n        }\r\n        SendSYSCOMMANDToMenuItem(hwnd, id, hmenu, sc_command);\r\n        } break;\r\n    // OWNER DRAWN MENU !!!!!\r\n    case WM_MEASUREITEM:\r\n        // Create Menu font if not already created.\r\n        if(!mfont) mfont = CreateNCMenuFont(dpi);\r\n        return MeasureMenuItem(hwnd, wParam, lParam, dpi, mfont);\r\n\r\n//    case msg == WM_MENUSELECT; {\r\n//        USHORT id = (UINT) LOWORD(wParam); // identifier of the menu item\r\n//        USHORT fuFlags = (UINT) HIWORD(wParam);\r\n//        if (fuFlags == 0xFFFF && !lParam) {\r\n//            ShowTransWin(SW_HIDE);\r\n//        } else if (fuFlags&MF_HILITE && fuFlags&MF_OWNERDRAW\r\n//        && 0 < id && id <= numhwnds) {\r\n//            HWND selhwnd = hwnds[id-1]; // currently selected hwnd.\r\n//            RECT rc;\r\n//            GetWindowRectL(selhwnd, &rc);\r\n//            ShowTransWin(SW_SHOWNA);\r\n//            MoveTransWin(rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top);\r\n//        }\r\n//        } break;\r\n\r\n    case WM_DRAWITEM:\r\n        return DrawMenuItem(hwnd, wParam, lParam, dpi, mfont);\r\n\r\n    case WM_MENUCHAR: {\r\n//        LOGA(\"WM_MENUCHAR: %X\", wParam);\r\n        // Turn the input character into a menu identifier.\r\n        WORD cc = LOWORD(wParam);\r\n        TCHAR c = (TCHAR)( cc  |  (('A' <= cc && cc <= 'Z')<<5) );\r\n        if (cc==VK_ESCAPE) return MNC_CLOSE<<16;\r\n        if (GetWindowLongPtr(hwnd, GWLP_USERDATA) == 3) {\r\n            int closewindow=0;\r\n            WORD item;\r\n            if (conf.NumberMenuItems) {\r\n                // Lower case the input character.\r\n                // O-9 then A-Z\r\n                item = ('0' <= c && c <= '9')? c-'0'\r\n                     : ('a' <= c && c <= 'z')? c-'a'+10\r\n                     : 0xFFFF;\r\n            } else {\r\n                // A-Z then 0-9\r\n                // If UPPERCASE\r\n                closewindow = conf.RCCloseMItem && 'A' <= cc && cc <= 'Z' && GetKeyState(VK_SHIFT)&0x8000;\r\n                item = ('a' <= c && c <= 'z')? c-'a'\r\n                     : ('0' <= c && c <= '9')? c-'0'+26\r\n                     : 0xFFFF;\r\n            }\r\n            // Execute item if the key is valid.\r\n            if (item != 0xFFFF && item <=  numhwnds) {\r\n                if (closewindow)\r\n                    //PostMessage(hwnd, WM_MENURBUTTONUP, item, lParam);\r\n                    SendSYSCOMMANDToMenuItem(hwnd, item, (HMENU)lParam, SC_CLOSE);\r\n                else\r\n                    return item|MNC_EXECUTE<<16;\r\n            }\r\n        }\r\n        } break;\r\n    case WM_SYSCHAR:\r\n        MessageBox(NULL, NULL, NULL, 0);\r\n        break;\r\n    case WM_KILLFOCUS:\r\n        // Menu gets hiden, be sure to zero-out the clickhwnd\r\n        state.sclickhwnd = NULL;\r\n        break;\r\n    case WM_DESTROY: {\r\n        LOG(\"Destroying Menu window!\");\r\n        if (mfont) DeleteObject(mfont); // Delete menufont if needed.\r\n        if (fhwndori\r\n        && state.sclickhwnd == fhwndori\r\n        && GetWindowLongPtr(hwnd, GWLP_USERDATA) == 1\r\n        && IsWindow(fhwndori)) {\r\n            // Restore the old foreground window\r\n            SetForegroundWindow(fhwndori);\r\n        }\r\n        fhwndori = NULL;\r\n        state.sclickhwnd = NULL;\r\n        state.unikeymenu = NULL;\r\n        } break;\r\n    }\r\n    // LOGA(\"msg=%X, wParam=%X, lParam=%lX\", msg, wParam, lParam);\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n\r\nLRESULT CALLBACK HotKeysWinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (msg == WM_HOTKEY) {\r\n        int actionint = 0;\r\n        int ptwindow = 0;\r\n        if (wParam > 0xC000) { // HOTKEY\r\n            // The user Pressed a hotkey.\r\n            actionint = wParam - 0xC000; // Remove the Offset\r\n            ptwindow = conf.UsePtWindow;\r\n            LOG(\"Hotkey Pressed, action = %d\", actionint);\r\n        } else if (0x0000 < wParam && wParam < 0x1000) {\r\n            // The user called AltSnap.exe -afACTION\r\n            actionint = wParam - 0x0000; // Remove the Offset\r\n            ptwindow = 0;\r\n        } else if (0x1000 < wParam && wParam < 0x2000) {\r\n            // The user called AltSnap.exe -apACTION\r\n            actionint = wParam - 0x1000; // Remove the Offset\r\n            ptwindow = 1;\r\n        }\r\n        enum action action =  (enum action)actionint;\r\n\r\n        if (action > AC_RESIZE) { // Exclude resize action in case...\r\n            POINT pt;\r\n            GetMsgPT(&pt);\r\n            static const enum action noinitactions[] = { AC_KILL, AC_PAUSE, AC_RESUME, AC_ASONOFF, AC_NONE };\r\n            if (IsActionInList(action, noinitactions)) {\r\n                // Some actions pass directly through the default blacklists...\r\n                HWND targethwnd = ptwindow? WindowFromPoint(pt): GetForegroundWindow();\r\n                if (IsWindow(targethwnd)) {\r\n                    SClickActions(targethwnd, action);\r\n                }\r\n            } else {\r\n                // For all other actions.\r\n                HWND target_hwnd = NULL;\r\n                if (!ptwindow) {\r\n                    target_hwnd = GetForegroundWindow();\r\n                    // List of actions for which point should default to center.\r\n                    static const enum action resetPTaclist[] = {AC_MENU, AC_NSTACKED, AC_PSTACKED, AC_NONE };\r\n                    if (IsActionInList(action, resetPTaclist)) {\r\n                        state.ignorept = 1;\r\n                    }\r\n                    // Might be of use for something?\r\n                    //} else if (IsActionInList(action, ptCenterAcList)) {\r\n                    //    // We must select the center of the current window as the point\r\n                    //    // pt to which the action will be done.\r\n                    //    RECT rc;\r\n                    //    GetWindowRect(target_hwnd, &rc);\r\n                    //    pt.x = (rc.left+rc.right)/2;\r\n                    //    pt.y = (rc.top+rc.bottom)/2;\r\n                    //}\r\n                }\r\n                state.shift = state.ctrl = 0; // In case...\r\n                init_movement_and_actions(pt, target_hwnd, action, 0);\r\n                state.blockmouseup = 0; // We must not block mouseup in this case...\r\n                state.ignorept = 0; // Reset...\r\n            }\r\n            return 0;\r\n        }\r\n    } else if (msg == WM_STACKLIST) {\r\n        TrackMenuOfWindows((WNDENUMPROC)lParam, wParam);\r\n        return 0;\r\n//    } else if (msg == WM_FINISHMOVEMENT) {\r\n//        FinishMovementWM();\r\n    } else if (msg == WM_SETLAYOUTNUM) {\r\n        SetLayoutNumber(wParam);\r\n    } else if (msg == WM_GETLAYOUTREZ) {\r\n        return GetLayoutRez(wParam);\r\n    } else if (msg == WM_GETBESTLAYOUT) {\r\n        return GetBestLayoutFromMonitors();\r\n    } else if (msg == WM_GETZONESLEN) {\r\n        unsigned idx = (unsigned)wParam;\r\n        return nzones[idx];\r\n    } else if (msg == WM_GETZONES) {\r\n        unsigned idx = (unsigned)wParam;\r\n        RECT *dZones = (RECT*)lParam;\r\n        CopyZones(dZones, idx);\r\n    }\r\n\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\n\r\nstatic void freeblacklists()\r\n{\r\n    struct blacklist *list = (struct blacklist *)&BlkLst;\r\n    unsigned i;\r\n    for (i=0; i< sizeof(BlkLst)/sizeof(struct blacklist); i++) {\r\n        free(list->data);\r\n        free(list->items);\r\n        list++;\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// To be called before Free Library. Ideally it should free everything\r\nstatic void freeallinputSequences(void);\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n#endif\r\n__declspec(dllexport) void WINAPI Unload()\r\n{\r\n#if defined(_MSC_VER) && _MSC_VER > 1300\r\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__)\r\n#endif\r\n    conf.keepMousehook = 0;\r\n    if (mousehook) { UnhookWindowsHookEx(mousehook); mousehook = NULL; }\r\n    DestroyWindow(g_timerhwnd);\r\n    KillAltSnapMenu();\r\n    if (conf.TransWinOpacity) {\r\n        DestroyWindow(g_transhwnd[0]);\r\n        g_transhwnd[0] = NULL;\r\n    } else {\r\n        int i;\r\n        for (i=0; i<4; i++) {\r\n            DestroyWindow(g_transhwnd[i]);\r\n            g_transhwnd[i] = NULL;\r\n        }\r\n    }\r\n\r\n    unsigned ac;\r\n    for(ac=AC_MENU; ac<AC_MAXVALUE; ac++)\r\n        UnregisterHotKey(g_hkhwnd, 0xC000+ac);\r\n    DestroyWindow(g_hkhwnd);\r\n\r\n    EnumThreadWindows(GetCurrentThreadId(), PostPinWindowsProcMessage, WM_CLOSE);\r\n    UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-Timers\"), hinstDLL);\r\n    UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-SClick\"), hinstDLL);\r\n    UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-Trans\"),  hinstDLL);\r\n    UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-Pin\"),    hinstDLL);\r\n    UnregisterClass(TEXT(APP_NAMEA)TEXT(\"-HotKeys\"),hinstDLL);\r\n\r\n    SnapLayoutPreviewCreateDestroy(NULL /*DESTROY*/);\r\n\r\n    freeblacklists();\r\n\r\n    freeallinputSequences();\r\n\r\n    free(monitors);\r\n    free(hwnds);\r\n    free(wnds);\r\n    free(snwnds);\r\n    free(minhwnds);\r\n    freezones();\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// blacklist is coma separated and title and class are | separated.\r\n// valid items are: exename.exe:title|class, title|class, exename:title, title\r\nstatic void readblacklist(const TCHAR *section, struct blacklist *blacklist, const char *bl_str)\r\n{\r\n    LPCTSTR txt = GetSectionOptionCStr(section, bl_str, NULL);\r\n    if (!txt || !*txt) {\r\n        return;\r\n    }\r\n    blacklist->data = (TCHAR *)malloc((lstrlen(txt)+1)*sizeof(TCHAR));\r\n    if (!blacklist->data) return;\r\n    lstrcpy(blacklist->data, txt);\r\n    TCHAR *pos = blacklist->data;\r\n\r\n    while (pos) {\r\n        TCHAR *exenm = pos;\r\n\r\n        // Move pos to next item (if any)\r\n        pos = lstrchr(pos, TEXT(','));\r\n        // Zero out the coma and eventual spaces\r\n        if (pos) {\r\n            do {\r\n                *pos++ = '\\0';\r\n            } while(*pos == ' ');\r\n        } // No more changes to pos.\r\n\r\n        TCHAR *title = lstrchr(exenm, TEXT(':')); // go to the :\r\n        // Look for the klass\r\n        TCHAR *klass = lstrchr(exenm, TEXT('|')); // go to the next |\r\n\r\n        // Split the item with NULL\r\n        if (title) {\r\n            // if klass we are in the exename:title|class, format?\r\n            if (klass) {\r\n                if (klass < title) {\r\n                    // if a ':' comes after a '|' the there is a ':' in the class\r\n                    // and exename is not specified ie: title|class format.\r\n                    // We do this because there can be no '|' in a filename\r\n                    title = exenm;\r\n                    exenm = NULL;\r\n                } else {\r\n                    // we are in the exename:title(|klass), format\r\n                    *title = '\\0'; // zero out the ':'\r\n                    title++;\r\n                }\r\n                *klass++ = '\\0'; // zero out the '|'\r\n            }\r\n        } else if (klass) {\r\n            // We did not find the ':' but we found a '|'\r\n            // => we are in the title|class format !\r\n            // => no exe name specified.\r\n            *klass = '\\0'; // Split the item with NULL\r\n            klass++;\r\n            title = exenm;\r\n            exenm = NULL;\r\n        } else {\r\n            // We found no ':' nor '|'\r\n            // We are in the exename only format.\r\n        }\r\n\r\n        // Add blacklist item\r\n        if (title && title[0] == '*' && title[1] == '\\0') {\r\n            title = NULL; // Title is a single *\r\n        }\r\n        if (klass && klass[0] == '*' && klass[1] == '\\0') {\r\n            klass = NULL; // class is a single *\r\n        }\r\n        if (exenm && exenm[0] == '*' && exenm[1] == '\\0') {\r\n            exenm = NULL; // exename is a single *\r\n        }\r\n        // Allocate space\r\n        struct blacklistitem *olditem = blacklist->items;\r\n        blacklist->items = (struct blacklistitem *)realloc(blacklist->items, (blacklist->length+1)*sizeof(struct blacklistitem));\r\n        if (!blacklist->items) {\r\n            // restore old item if realloc failed\r\n            // It will jst be a shorter blacklist\r\n            // May be NULL as well...\r\n            blacklist->items=olditem;\r\n            break; // Stop the loop\r\n        }\r\n\r\n        // Store item\r\n        LOG( \"%ls:%ls|%ls\", exenm, title, klass);\r\n        blacklist->items[blacklist->length].exename = exenm;\r\n        blacklist->items[blacklist->length].title = title;\r\n        blacklist->items[blacklist->length].classname = klass;\r\n        blacklist->length++;\r\n    } // end while\r\n}\r\n// Read all the blacklitsts\r\nvoid readallblacklists(const TCHAR *inipath)\r\n{\r\n    enum { blacklist_section_length = 32767 };\r\n    mem00(&BlkLst, sizeof(BlkLst));\r\n\r\n    TCHAR *section = (TCHAR *)malloc(blacklist_section_length*sizeof(TCHAR));\r\n    if (!section) return;\r\n    GetPrivateProfileSection(TEXT(\"Blacklist\"), section, blacklist_section_length, inipath);\r\n\r\n    struct blacklist *list = &BlkLst.Processes;\r\n    unsigned i;\r\n    for (i=0; i< sizeof(BlkLst)/sizeof(struct blacklist); i++) {\r\n        readblacklist(section, list+i, BlackListStrings[i]);\r\n    }\r\n    free(section);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Used to read Hotkeys and Hotclicks\r\nstatic unsigned readhotkeys(const TCHAR *inisection, const char *name, const TCHAR *def, UCHAR *keys, unsigned MaxKeys)\r\n{\r\n    LPCTSTR txt = GetSectionOptionCStr(inisection, name, def);\r\n    unsigned i=0;\r\n    if(!txt || !*txt) return i;\r\n    const TCHAR *pos = txt;\r\n    while (*pos) {\r\n        // Store key\r\n        if (i == MaxKeys) break;\r\n        keys[i++] = lstrhex2u(pos);\r\n\r\n        while (*pos && *pos >= '0') pos++; // go to the end of the word\r\n        while (*pos && *pos < '0') pos++; // go to next char after spaces.\r\n    }\r\n    keys[i] = 0;\r\n    return i;\r\n}\r\nstatic enum action readaction(const TCHAR *section, const char *key)\r\n{\r\n    LPCTSTR txt = GetSectionOptionCStr(section, key, TEXT(\"Nothing\"));\r\n    if(!txt || !*txt) return AC_NONE;\r\n\r\n    return MapActionW(txt);\r\n}\r\n// Read all buttons actions from inipath\r\nvoid readbuttonactions(const TCHAR *inputsection)\r\n{\r\n    static const char* buttons[] = {\r\n        \"LMB\", \"RMB\", \"MMB\", \"MB4\", \"MB5\",\r\n        \"MB6\",  \"MB7\",  \"MB8\",\r\n        \"MB9\",  \"MB10\", \"MB11\", \"MB12\",\r\n        \"MB13\", \"MB14\", \"MB15\", \"MB16\",\r\n        \"MB17\", \"MB18\", \"MB19\", \"MB20\",\r\n        \"Scroll\", \"HScroll\",\r\n\r\n        \"GrabWithAlt\",\r\n        \"MoveUp\", \"ResizeUp\",\r\n    };\r\n\r\n    unsigned i;\r\n    for (i=0; i < ARR_SZ(buttons); i++) {\r\n        enum action * const actionptr = &conf.Mouse.LMB[0]; // first action in list\r\n\r\n        char key[32];\r\n        strcpy(key, buttons[i]);\r\n        int len = lstrlenA(key);\r\n        // Read primary action (no sufix)\r\n        actionptr[NACPB*i+0] = readaction(inputsection, key);\r\n        key[len] = 'B'; key[len+1] = '\\0'; // Secondary B sufixe\r\n        actionptr[NACPB*i+1] = readaction(inputsection, key);\r\n\r\n        // Titlbar actions\r\n        key[len] = 'T'; key[len+1] = '\\0'; // Titlebar T sufixes\r\n        actionptr[NACPB*i+2] = readaction(inputsection, key);\r\n        key[len+1] = 'B'; key[len+2] = '\\0'; // TB\r\n        actionptr[NACPB*i+3] = readaction(inputsection, key);\r\n\r\n        // Action while moving\r\n        key[len] = 'M'; key[len+1] = '\\0'; // Action while Moving M sufixe\r\n        actionptr[NACPB*i+4] = readaction(inputsection, key);\r\n        key[len+1] = 'B'; key[len+2] = '\\0'; // MB\r\n        actionptr[NACPB*i+5] = readaction(inputsection, key);\r\n\r\n        // Action while resizing\r\n        key[len] = 'R'; key[len+1] = '\\0'; // Action while Moving M sufixe\r\n        actionptr[NACPB*i+6] = readaction(inputsection, key);\r\n        key[len+1] = 'B'; key[len+2] = '\\0'; // MB\r\n        actionptr[NACPB*i+7] = readaction(inputsection, key);\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////\r\n// Create a window for msessages handeling timers, menu etc.\r\nstatic HWND KreateMsgWin(WNDPROC proc, const TCHAR *name, LONG_PTR userdata)\r\n{\r\n    WNDCLASSEX wnd;\r\n    if(!GetClassInfoEx(hinstDLL, name, &wnd)) {\r\n        // Register the class if no already created.\r\n        mem00(&wnd, sizeof(wnd));\r\n        wnd.cbSize = sizeof(WNDCLASSEX);\r\n        wnd.lpfnWndProc = proc;\r\n        wnd.hInstance = hinstDLL;\r\n        wnd.lpszClassName = name;\r\n        RegisterClassEx(&wnd);\r\n    }\r\n    HWND parent =  (LOBYTE(LOWORD(GetVersion())) >= 5)?HWND_MESSAGE:g_mainhwnd;\r\n    HWND hwnd = CreateWindowEx(0, wnd.lpszClassName, NULL, 0\r\n                     , 0, 0, 0, 0, parent, NULL, hinstDLL, NULL);\r\n    if (hwnd && userdata)\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, userdata);\r\n    return hwnd;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void CreateTransWin(const TCHAR *inisection)\r\n{\r\n    int color[2];\r\n    // Read the color for the TransWin from ini file\r\n    readhotkeys(inisection, \"FrameColor\",  TEXT(\"80 00 80\"), (UCHAR *)&color[0], 3);\r\n    WNDCLASSEX wnd;\r\n    mem00(&wnd, sizeof(wnd));\r\n    wnd.cbSize = sizeof(WNDCLASSEX);\r\n//    wnd.style = CS_SAVEBITS;\r\n    wnd.lpfnWndProc = DefWindowProc;\r\n    wnd.hInstance = hinstDLL;\r\n    wnd.hbrBackground = CreateSolidBrush(color[0]);\r\n    wnd.lpszClassName = TEXT(APP_NAMEA)TEXT(\"-Trans\");\r\n    RegisterClassEx(&wnd);\r\n    g_transhwnd[0] = NULL;\r\n    if (conf.TransWinOpacity) {\r\n        int xflags = conf.TransWinOpacity==255\r\n                   ? WS_EX_TOPMOST|WS_EX_TOOLWINDOW\r\n                   : WS_EX_TOPMOST|WS_EX_TOOLWINDOW|WS_EX_LAYERED;\r\n        g_transhwnd[0] = CreateWindowEx(xflags\r\n                             , wnd.lpszClassName, NULL, WS_POPUP\r\n                             , 0, 0, 0, 0, NULL, NULL, hinstDLL, NULL);\r\n        if(conf.TransWinOpacity != 255)\r\n            SetLayeredWindowAttributes(g_transhwnd[0], 0, conf.TransWinOpacity, LWA_ALPHA);\r\n    }\r\n    if (!g_transhwnd[0]) {\r\n        int i;\r\n        for (i=0; i<4; i++) { // the transparent window is made with 4 thin windows\r\n            g_transhwnd[i] = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW\r\n                             , wnd.lpszClassName, NULL, WS_POPUP\r\n                             , 0, 0, 0, 0, g_mainhwnd, NULL, hinstDLL, NULL);\r\n            LOG(\"CreateWindowEx[i] = %lX\", (DWORD)(DorQWORD)g_transhwnd[i]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid registerAllHotkeys(const TCHAR* inipath)\r\n{\r\n    g_hkhwnd = KreateMsgWin(HotKeysWinProc, TEXT(APP_NAMEA)TEXT(\"-HotKeys\"), 0);\r\n    ChangeWindowMessageFilterExL(g_hkhwnd, WM_HOTKEY, /*MSGFLT_ALLOW*/1, NULL);\r\n    // MOD_ALT=1, MOD_CONTROL=2, MOD_SHIFT=4, MOD_WIN=8\r\n    // RegisterHotKey(g_hkhwnd, 0xC000 + AC_KILL,   MOD_ALT|MOD_CONTROL, VK_F4); // F4=73h\r\n    // Read All shortcuts in the [KBShortcuts] section.\r\n    TCHAR inisection[1800];\r\n    GetPrivateProfileSection(TEXT(\"KBShortcuts\"), inisection, ARR_SZ(inisection), inipath);\r\n\r\n    conf.UsePtWindow = GetSectionOptionInt(inisection, \"UsePtWindow\", 0);\r\n\r\n    #define ACVALUE(a, b, c) (b),\r\n    static const char *action_names[] = { ACTION_MAP };\r\n    #undef ACVALUE\r\n    unsigned ac;\r\n    for (ac=AC_MENU; ac < ARR_SZ(action_names); ac++) {\r\n        WORD HK = GetSectionOptionInt(inisection, action_names[ac], 0);\r\n        if(LOBYTE(HK) && HIBYTE(HK)) {\r\n            // Lobyte is the virtual key code and hibyte is the mod_key\r\n            if(!RegisterHotKey(g_hkhwnd, 0xC000 + ac, HIBYTE(HK), LOBYTE(HK))) {\r\n                LOG(\"Error registering hotkey %s=%x\", action_names[ac], (unsigned)HK);\r\n                #ifdef LOG_STUFF\r\n                TCHAR title[76], acN[32];\r\n                lstrcpy_s(title, ARR_SZ(title), TEXT(APP_NAMEA)TEXT(\": unable to register hotkey for action \"));\r\n                str2tchar_s(acN, ARR_SZ(acN)-1, action_names[ac]);\r\n                lstrcat_s(title, ARR_SZ(title), acN);\r\n                ErrorBox(title);\r\n                #endif // LOG_STUFF\r\n            }\r\n            LOG(\"OK registering hotkey %s=%x\", action_names[ac], (unsigned)HK);\r\n        }\r\n    }\r\n}\r\nstatic void readalluchars(UCHAR *dest, const TCHAR * const inisection, const struct OptionListItem *optlist, size_t listlen)\r\n{\r\n    // Read all char options\r\n    unsigned i;\r\n    for (i=0; i < listlen; i++) {\r\n        *dest++ = GetSectionOptionInt(inisection, optlist[i].name, optlist[i].def);\r\n    }\r\n}\r\nvoid readallinputSequences(const TCHAR *inisection)\r\n{\r\n    UCHAR buf[512];\r\n    char shrtN[6] = \"Shrt0\";\r\n    size_t i;\r\n\r\n    mem00(conf.inputSequences, sizeof(conf.inputSequences));\r\n\r\n    for (i=0; i< ARR_SZ(conf.inputSequences); i++) {\r\n        shrtN[4] = i<10? '0' + i: 'A'-10 + i;\r\n        unsigned len = readhotkeys(inisection, shrtN, TEXT(\"\"), buf+1, 508) / 2;\r\n        buf[0] = len;\r\n        if (len) {\r\n            UCHAR *seq = (UCHAR *)malloc(len*2+1*sizeof(UCHAR));\r\n            if (seq) {\r\n                memcpy(seq, buf, len*2+1*sizeof(UCHAR));\r\n                conf.inputSequences[i] = seq;\r\n            }\r\n        }\r\n    }\r\n}\r\nstatic void freeallinputSequences(void)\r\n{\r\n    size_t i;\r\n    for (i=0; i< ARR_SZ(conf.inputSequences); i++)\r\n        free(conf.inputSequences[i]);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Has to be called at startup, it mainly reads the config.\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n#endif\r\n__declspec(dllexport) HWND WINAPI Load(HWND mainhwnd, const TCHAR inipath[AT_LEAST MAX_PATH])\r\n{\r\n#if defined(_MSC_VER) && _MSC_VER > 1300\r\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__)\r\n#endif\r\n    // Load settings\r\n    unsigned i;\r\n    state.action = AC_NONE;\r\n    state.shift = 0;\r\n    state.moving = 0;\r\n    LastWin.hwnd = NULL;\r\n\r\n    // GET SYSTEM SETTINGS\r\n    DWORD dragthreshold=0;\r\n    if (SystemParametersInfo(/*SPI_GETMOUSEDRAGOUTTHRESHOLD*/0x0084, 0, &dragthreshold, 0)) {\r\n        conf.dragXth = conf.dragYth = dragthreshold;\r\n    } else {\r\n        // Unable to retreave the new drag-out Threshold\r\n        // Default to twice the usual drag threshold.\r\n        conf.dragXth  = GetSystemMetrics(SM_CXDRAG)<<1;\r\n        conf.dragYth  = GetSystemMetrics(SM_CYDRAG)<<1;\r\n    }\r\n\r\n    conf.dbclickX = GetSystemMetrics(SM_CXDOUBLECLK);\r\n    conf.dbclickY = GetSystemMetrics(SM_CYDOUBLECLK);\r\n\r\n\r\n    // Get ini path\r\n//    GetModuleFileName(NULL, inipath, ARR_SZ(inipath));\r\n//    lstrcpy(&inipath[lstrlen(inipath)-3], TEXT(\"ini\"));\r\n\r\n    TCHAR stk_inisection[1420], *inisection; // Stack buffer.\r\n    size_t inisectionlen = 8192;\r\n    inisection = (TCHAR *)malloc(inisectionlen*sizeof(TCHAR));\r\n    if(!inisection) {\r\n        inisection = stk_inisection;\r\n        inisectionlen = ARR_SZ(stk_inisection);\r\n    }\r\n\r\n    // [General]\r\n    GetPrivateProfileSection(TEXT(\"General\"), inisection, inisectionlen, inipath);\r\n    readalluchars(&conf.AutoFocus, inisection, General_uchars, ARR_SZ(General_uchars));\r\n\r\n    // [General] consistency checks\r\n    conf.CenterFraction=min(conf.CenterFraction, 100);\r\n    if(conf.SidesFraction == 255) conf.SidesFraction = conf.CenterFraction;\r\n    conf.AHoff        = min(conf.AHoff,          100);\r\n    conf.AVoff        = min(conf.AVoff,          100);\r\n    conf.AeroSpeedTau = max(1, conf.AeroSpeedTau);\r\n    conf.MinAlpha     = max(1, conf.MinAlpha);\r\n    state.snap = conf.AutoSnap;\r\n\r\n    // [Advanced]\r\n    GetPrivateProfileSection(TEXT(\"Advanced\"), inisection, inisectionlen, inipath);\r\n    readalluchars(&conf.ResizeAll, inisection, Advanced_uchars, ARR_SZ(Advanced_uchars));\r\n\r\n    conf.ZoomFrac      = max(2, conf.ZoomFrac);\r\n    conf.ZoomFracShift = max(2, conf.ZoomFracShift);\r\n    conf.BLCapButtons  = GetSectionOptionInt(inisection, \"BLCapButtons\", 3);\r\n    conf.BLUpperBorder = GetSectionOptionInt(inisection, \"BLUpperBorder\", 3);\r\n    conf.AeroMaxSpeed  = GetSectionOptionInt(inisection, \"AeroMaxSpeed\", 65535);\r\n    conf.LongClickMoveDelay = GetSectionOptionInt(inisection, \"LongClickMoveDelay\", 0);\r\n    if (conf.LongClickMoveDelay == 0)\r\n        conf.LongClickMoveDelay = GetDoubleClickTime();\r\n\r\n    GetPrivateProfileSection(TEXT(\"Performance\"), inisection, inisectionlen, inipath);\r\n    readalluchars(&conf.FullWin, inisection, Performance_uchars, ARR_SZ(Performance_uchars));\r\n    conf.MoveRate     = max(1, conf.MoveRate);\r\n    conf.ResizeRate   = max(1, conf.ResizeRate);\r\n\r\n    // [Performance]\r\n    if (conf.RezTimer == 2 || conf.RezTimer == 4) {\r\n        // 2 => Auto 1 (if 60Hz monitor) or 0.\r\n        // 4 => Auto 1 (if 60Hz monitor) or 3.\r\n        conf.RezTimer = conf.RezTimer == 2? 0: 3;\r\n        DEVMODE dvm;\r\n        mem00(&dvm, sizeof(dvm));\r\n        dvm.dmSize = sizeof(DEVMODE);\r\n        if (EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &dvm)) {\r\n            LOG(\"Display Frequency = %dHz\", dvm.dmDisplayFrequency);\r\n            if (dvm.dmDisplayFrequency == 60)\r\n                conf.RezTimer = 1;\r\n        }\r\n    }\r\n    if (conf.RezTimer) conf.RefreshRate=0; // Ignore the refresh rate in RezTimer mode.\r\n    if (conf.FullWin == 2) { // Use current config to determine if we use FullWin.\r\n        BOOL drag_full_win=1;  // Default to ON if unable to detect\r\n        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &drag_full_win, 0);\r\n        conf.FullWin = drag_full_win;\r\n    }\r\n\r\n    GetPrivateProfileSection(TEXT(\"Input\"), inisection, inisectionlen, inipath);\r\n    readalluchars(&conf.TTBActions, inisection, Input_uchars, ARR_SZ(Input_uchars));\r\n    readbuttonactions(inisection);\r\n\r\n    if (conf.TopmostIndicator) {\r\n        int color[2];\r\n        readhotkeys(inisection, \"PinColor\",  TEXT(\"FF FF 00 54\"), (UCHAR *)&color[0], 4);\r\n        conf.PinColor = color[0];\r\n    }\r\n    // Prepare the transparent window\r\n    if (!conf.FullWin) {\r\n        CreateTransWin(inisection);\r\n    }\r\n\r\n    // Same order than in the conf struct\r\n    static const struct hklst {\r\n        char *name; TCHAR *def;\r\n    } hklst[] = {\r\n        { \"Hotkeys\",   TEXT(\"A4 A5\") }, // VK_LMENU VK_RMENU\r\n        { \"Shiftkeys\", TEXT(\"A0 A1\") }, // VK_LSHIFT VK_RSHIFT\r\n        { \"Hotclicks\", NULL },\r\n        { \"Killkeys\",  TEXT(\"09 2E\") }, // VK_TAB VK_DELETE\r\n        { \"XXButtons\", NULL },\r\n        { \"ModKey\",    NULL },\r\n        { \"HScrollKey\", TEXT(\"10\") }, // VK_SHIFT\r\n        { \"ESCKeys\",   TEXT(\"1B\") }, // VK_ESCAPE = 1B\r\n    };\r\n    for (i=0; i < ARR_SZ(hklst); i++) {\r\n        readhotkeys(inisection, hklst[i].name, hklst[i].def, &conf.Hotkeys[i*(MAXKEYS+1)], MAXKEYS);\r\n    }\r\n    UCHAR eHKs[MAXKEYS+1]; // Key to be sent at the end of a movment.\r\n    readhotkeys(inisection, \"EndSendKey\", TEXT(\"11\"), eHKs, MAXKEYS);\r\n    conf.EndSendKey = eHKs[0];\r\n\r\n    // Read User Shortcuts/InputSequences\r\n    readallinputSequences(inisection);\r\n\r\n    // Read all the BLACKLITSTS\r\n    readallblacklists(inipath);\r\n\r\n    ResetDB(); // Zero database of restore info (snap.c)\r\n\r\n    GetPrivateProfileSection(TEXT(\"Zones\"), inisection, inisectionlen, inipath);\r\n    readalluchars(&conf.UseZones, inisection, Zones_uchars, ARR_SZ(Zones_uchars));\r\n\r\n    if (conf.UseZones&1) { // We are using Zones\r\n        if(conf.UseZones&2) { // Grid Mode\r\n            ReadGrids(inisection);\r\n        } else {\r\n            ReadZones(inisection);\r\n        }\r\n        SnapLayoutPreviewCreateDestroy(inisection /*CREATE*/);\r\n    }\r\n\r\n    if (inisection != stk_inisection)\r\n        free(inisection);\r\n\r\n    conf.keepMousehook = ((conf.TTBActions&1) // titlebar action w/o Alt\r\n                       || conf.InactiveScroll // Inactive scrolling\r\n                       || conf.Hotclick[0] // Hotclick\r\n                       || conf.LongClickMove); // Move with long click\r\n    // Capture main hwnd from caller. This is also the cursor wnd\r\n    g_mainhwnd = mainhwnd;\r\n\r\n    if (conf.keepMousehook || conf.AeroMaxSpeed < 65535) {\r\n        g_timerhwnd = KreateMsgWin(TimerWindowProc, TEXT(APP_NAMEA)TEXT(\"-Timers\"), 0);\r\n    }\r\n\r\n    // read and register all shortcuts related options.\r\n    registerAllHotkeys(inipath);\r\n\r\n    // Hook mouse if a permanent hook is needed\r\n    if (conf.keepMousehook) {\r\n        HookMouse();\r\n        SetTimer(g_timerhwnd, REHOOK_TIMER, 5000, NULL); // Start rehook timer\r\n    }\r\n    return g_hkhwnd;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Do not forget the -e_DllMain@12 for gcc... -eDllMain for x86_64\r\nBOOL APIENTRY DllMain(HINSTANCE hInst, DWORD reason, LPVOID reserved)\r\n{\r\n    if (reason == DLL_PROCESS_ATTACH) {\r\n        DisableThreadLibraryCalls(hInst);\r\n        hinstDLL = hInst;\r\n    }\r\n    return TRUE;\r\n}\r\n"
        },
        {
          "name": "hooks.h",
          "type": "blob",
          "size": 8.296875,
          "content": "#ifndef ALTDRAG_RPC_H\r\n#define ALTDRAG_RPC_H\r\n\r\n#define UNICODE\r\n#define _UNICODE\r\n#define _WIN32_WINNT 0x0600\r\n#define WINVER 0x0600\r\n#include <windows.h>\r\n#include \"unfuck.h\"\r\n\r\n#ifndef LOW_LEVEL_KB_PROC\r\n\t#ifndef DECORATED_HOOKS_DLL_PROCS\r\n\t\t#define LOW_LEVEL_KB_PROC \"LowLevelKeyboardProc\"\r\n\t\t#define LOAD_PROC \"Load\"\r\n\t\t#define UNLOAD_PROC \"Unload\"\r\n\t#else\r\n\t\t#define LOW_LEVEL_KB_PROC \"_LowLevelKeyboardProc@12\"\r\n\t\t#define LOAD_PROC \"_Load@8\"\r\n\t\t#define UNLOAD_PROC \"_Unload@0\"\r\n\t#endif\r\n#endif\r\n\r\n// Extra messages for Action Menu\r\n#define LP_CURSORPOS   (1<<0)\r\n#define LP_TOPMOST     (1<<1)\r\n#define LP_BORDERLESS  (1<<2)\r\n#define LP_MAXIMIZED   (1<<3)\r\n#define LP_ROLLED      (1<<4)\r\n#define LP_MOVEONOFF   (1<<5)\r\n#define LP_NOALTACTION (1<<6)\r\n\r\n// App\r\n#define APP_NAME       TEXT(\"AltSnap\")\r\n#define APP_NAMEA      \"AltSnap\"\r\n#define APP_PROPPT     APP_NAME TEXT(\"-RDim\")\r\n#define APP_PROPFL     APP_NAME TEXT(\"-RFlag\")\r\n#define APP_PROPOFFSET APP_NAME TEXT(\"-ROffset\")\r\n#define APP_PRBDLESS   APP_NAME TEXT(\"-RStyle\")\r\n#define APP_ROLLED     APP_NAME TEXT(\"-Rolled\")\r\n#define APP_ASONOFF    APP_NAME TEXT(\"-ASOnOff\")\r\n#define APP_MOVEONOFF  APP_NAME TEXT(\"-MoveOnOff\")\r\n#define APP_PRODPI     APP_NAME TEXT(\"-ODPI\")\r\n#define APP_OWDMCP     APP_NAME TEXT(\"-OWDMCP\")\r\n#define FZ_PROPPT      TEXT(\"FancyZones_RestoreSize\")\r\n#define FZ_PROPZONES   TEXT(\"FancyZones_zones\")\r\n\r\n// User Messages\r\n#define WM_TRAY           (WM_USER+2)\r\n#define WM_SCLICK         (WM_USER+3)\r\n#define WM_UPDCFRACTION   (WM_USER+4)\r\n#define WM_UPDATETRAY     (WM_USER+5)\r\n#define WM_OPENCONFIG     (WM_USER+6)\r\n#define WM_CLOSECONFIG    (WM_USER+7)\r\n#define WM_UPDATESETTINGS (WM_USER+8)\r\n#define WM_ADDTRAY        (WM_USER+9)\r\n#define WM_HIDETRAY       (WM_USER+10)\r\n#define WM_UNIKEYMENU     (WM_USER+11)\r\n#define WM_GETCLICKHWND   (WM_USER+12)\r\n#define WM_STACKLIST      (WM_USER+13)\r\n#define WM_FINISHMOVEMENT (WM_USER+14)\r\n#define WM_CLOSEMODE      (WM_USER+15)\r\n#define WM_SETLAYOUTNUM   (WM_USER+16)\r\n#define WM_GETLAYOUTREZ   (WM_USER+17)\r\n#define WM_GETBESTLAYOUT  (WM_USER+18)\r\n#define WM_GETZONESLEN    (WM_USER+19)\r\n#define WM_GETZONES       (WM_USER+20)\r\n\r\n// List of possible actions\r\n// ACVALUE(AC_ENUM, \"IniString\", Info)\r\n#define ACTION_MAP \\\r\n    ACVALUE(AC_NONE=0,       \"Nothing\",     00) \\\r\n    ACVALUE(AC_MOVE,         \"Move\",        MR) \\\r\n    ACVALUE(AC_RESIZE,       \"Resize\",      MR) \\\r\n    ACVALUE(AC_RESTORE,      \"Restore\",     MR) \\\r\n    ACVALUE(AC_MENU,         \"Menu\",        CL) \\\r\n    ACVALUE(AC_MINIMIZE,     \"Minimize\",    MR) \\\r\n    ACVALUE(AC_MAXIMIZE,     \"Maximize\",    MR) \\\r\n    ACVALUE(AC_CENTER,       \"Center\",      MR) \\\r\n    ACVALUE(AC_ALWAYSONTOP,  \"AlwaysOnTop\", ZO) \\\r\n    ACVALUE(AC_CLOSE,        \"Close\",       CL) \\\r\n    ACVALUE(AC_LOWER,        \"Lower\",       ZO) \\\r\n    ACVALUE(AC_FOCUS,        \"Focus\",       ZO) \\\r\n    ACVALUE(AC_BORDERLESS,   \"Borderless\",  00) \\\r\n    ACVALUE(AC_KILL,         \"Kill\",        CL) \\\r\n    ACVALUE(AC_PAUSE,        \"Pause\",       CL) \\\r\n    ACVALUE(AC_RESUME,       \"Resume\",      CL) \\\r\n    ACVALUE(AC_MAXHV,        \"MaximizeHV\",  MR) \\\r\n    ACVALUE(AC_MINALL,       \"MinAllOther\", 00) \\\r\n    ACVALUE(AC_MUTE,         \"Mute\",        00) \\\r\n    ACVALUE(AC_SIDESNAP,     \"SideSnap\",    MR) \\\r\n    ACVALUE(AC_EXTENDSNAP,   \"ExtendSnap\",  MR) \\\r\n    ACVALUE(AC_EXTENDTNEDGE, \"ExtendTNEdge\",MR) \\\r\n    ACVALUE(AC_MOVETNEDGE,   \"MoveTNEdge\",  MV) \\\r\n    ACVALUE(AC_NSTACKED,     \"NStacked\",    ZO) \\\r\n    ACVALUE(AC_NSTACKED2,    \"NStacked2\",   ZO) \\\r\n    ACVALUE(AC_PSTACKED,     \"PStacked\",    ZO) \\\r\n    ACVALUE(AC_PSTACKED2,    \"PStacked2\",   ZO) \\\r\n    ACVALUE(AC_STACKLIST,    \"StackList\",   CL) \\\r\n    ACVALUE(AC_STACKLIST2,   \"StackList2\",  CL) \\\r\n    ACVALUE(AC_ALTTABLIST,   \"AltTabList\",  CL) \\\r\n    ACVALUE(AC_ALTTABFULLLIST, \"AltTabFullList\",  CL) \\\r\n    ACVALUE(AC_ASONOFF,      \"ASOnOff\",     CL) \\\r\n    ACVALUE(AC_MOVEONOFF,    \"MoveOnOff\",   CL) \\\r\n    \\\r\n    ACVALUE(AC_MLZONE, \"MLZone\", MR) \\\r\n    ACVALUE(AC_MTZONE, \"MTZone\", MR) \\\r\n    ACVALUE(AC_MRZONE, \"MRZone\", MR) \\\r\n    ACVALUE(AC_MBZONE, \"MBZone\", MR) \\\r\n    ACVALUE(AC_XLZONE, \"XLZone\", MR) \\\r\n    ACVALUE(AC_XTZONE, \"XTZone\", MR) \\\r\n    ACVALUE(AC_XRZONE, \"XRZone\", MR) \\\r\n    ACVALUE(AC_XBZONE, \"XBZone\", MR) \\\r\n    \\\r\n    ACVALUE(AC_XTNLEDGE, \"XTNLEdge\", MR) \\\r\n    ACVALUE(AC_XTNTEDGE, \"XTNTEdge\", MR) \\\r\n    ACVALUE(AC_XTNREDGE, \"XTNREdge\", MR) \\\r\n    ACVALUE(AC_XTNBEDGE, \"XTNBEdge\", MR) \\\r\n    ACVALUE(AC_MTNLEDGE, \"MTNLEdge\", MV) \\\r\n    ACVALUE(AC_MTNTEDGE, \"MTNTEdge\", MV) \\\r\n    ACVALUE(AC_MTNREDGE, \"MTNREdge\", MV) \\\r\n    ACVALUE(AC_MTNBEDGE, \"MTNBEdge\", MV) \\\r\n    \\\r\n    ACVALUE(AC_STEPL,  \"StepL\",  MR) \\\r\n    ACVALUE(AC_STEPT,  \"StepT\",  MR) \\\r\n    ACVALUE(AC_STEPR,  \"StepR\",  MR) \\\r\n    ACVALUE(AC_STEPB,  \"StepB\",  MR) \\\r\n    ACVALUE(AC_SSTEPL, \"SStepL\", MR) \\\r\n    ACVALUE(AC_SSTEPT, \"SStepT\", MR) \\\r\n    ACVALUE(AC_SSTEPR, \"SStepR\", MR) \\\r\n    ACVALUE(AC_SSTEPB, \"SStepB\", MR) \\\r\n    \\\r\n    ACVALUE(AC_FOCUSL,  \"FocusL\",  ZO) \\\r\n    ACVALUE(AC_FOCUST,  \"FocusT\",  ZO) \\\r\n    ACVALUE(AC_FOCUSR,  \"FocusR\",  ZO) \\\r\n    ACVALUE(AC_FOCUSB,  \"FocusB\",  ZO) \\\r\n    \\\r\n    ACVALUE(AC_ROLL,         \"Roll\",         MR) \\\r\n    ACVALUE(AC_ALTTAB,       \"AltTab\",       ZO) \\\r\n    ACVALUE(AC_VOLUME,       \"Volume\",       00) \\\r\n /* ACVALUE(AC_BRIGHTNESS,   \"Brightness\",   00) */ \\\r\n    ACVALUE(AC_TRANSPARENCY, \"Transparency\", 00) \\\r\n    ACVALUE(AC_HSCROLL,      \"HScroll\",      00) \\\r\n    ACVALUE(AC_ZOOM,         \"Zoom\",         MR) \\\r\n    ACVALUE(AC_ZOOM2,        \"Zoom2\",        MR) \\\r\n    ACVALUE(AC_NPSTACKED,    \"NPStacked\",    ZO) \\\r\n    ACVALUE(AC_NPSTACKED2,   \"NPStacked2\",   ZO)\r\n\r\n#define ACVALUE(a, b, c) a,\r\nenum action { ACTION_MAP AC_MAXVALUE, AC_SHRT0, AC_SHRTF=AC_SHRT0+36, AC_ORICLICK };\r\n#undef ACVALUE\r\n\r\n// List of extra info options\r\n#define ACINFO_MOVE     (1)\r\n#define ACINFO_RESIZE   (2)\r\n#define ACINFO_ZORDER   (4)\r\n#define ACINFO_CLOSE    (8)\r\n#define MV ACINFO_MOVE\r\n#define RZ ACINFO_RESIZE\r\n#define ZO ACINFO_ZORDER\r\n#define CL ACINFO_CLOSE\r\n\r\n#define MR (ACINFO_MOVE|ACINFO_RESIZE)\r\n\r\n// Helper function to get extra action info\r\nstatic xpure UCHAR ActionInfo(enum action action)\r\n{\r\n    #define ACVALUE(a, b, c) (c),\r\n    static const UCHAR action_info[] = { ACTION_MAP };\r\n\r\n    #undef ACVALUE\r\n    return action_info[action];\r\n}\r\n#undef MV\r\n#undef RZ\r\n#undef ZO\r\n#undef CL\r\n#undef MR\r\n\r\n#define MOUVEMENT(action) (action <= AC_RESIZE)\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Check if key is assigned in the HKlist\r\nstatic int pure IsHotkeyy(unsigned char key, const unsigned char *HKlist)\r\n{\r\n    const UCHAR *pos=&HKlist[0];\r\n    while (*pos) {\r\n        if (key == *pos) {\r\n            return 1;\r\n        }\r\n        pos++;\r\n    }\r\n    return 0;\r\n}\r\nstatic int pure IsActionInList(const enum action ac, const enum action *aclst)\r\n{\r\n    do {\r\n        if(ac == *aclst)\r\n            return 1;\r\n    } while(*aclst++ != AC_NONE);\r\n\r\n    return 0;\r\n}\r\n// Convert zone number to ini name entry\r\nstatic TCHAR *ZidxToZonestr(int laynum, int idx, TCHAR zname[AT_LEAST 32])\r\n{\r\n    if (laynum > 9 ) return NULL;\r\n    TCHAR txt[UINT_DIGITS+1];\r\n    zname[0] = !laynum?TEXT('\\0'): TEXT('A')+laynum-1 ;\r\n    zname[1] = '\\0';\r\n    lstrcat_s(zname, 32, TEXT(\"Zone\"));\r\n    lstrcat_s(zname, 32, Uint2lStr(txt, idx)); // Zone Name from zone number\r\n\r\n    return zname;\r\n}\r\nstatic char *ZidxToZonestrA(int laynum, int idx, char zname[AT_LEAST 32])\r\n{\r\n    if (laynum > 9 ) return NULL;\r\n    char txt[16];\r\n    zname[0] = !laynum?'\\0': 'A'+laynum-1 ;\r\n    zname[1] = '\\0';\r\n    lstrcat_sA(zname, 32, \"Zone\");\r\n    lstrcat_sA(zname, 32, Uint2lStrA(txt, idx)); // Zone Name from zone number\r\n\r\n    return zname;\r\n}\r\n\r\n// Map action string to actual action enum\r\nstatic enum action MapActionW(const TCHAR *txt)\r\n{\r\n    #define ACVALUE(a, b, c) (b),\r\n    static const char *action_map[] = { ACTION_MAP };\r\n    #undef ACVALUE\r\n    UCHAR ac;\r\n    for (ac=0; ac < ARR_SZ(action_map); ac++) {\r\n        if(!strtotcharicmp(txt, action_map[ac]))\r\n            return (enum action)ac;\r\n    }\r\n    // ShrtX X = 0 to F.\r\n    if (txt[0] == 'S' && txt[1] == 'h' && txt[2] == 'r' && txt[3] == 't'\r\n    && '0' <= txt[4] && txt[4] <= 'Z' && txt[5] == '\\0' ) {\r\n        TCHAR c = txt[4];\r\n        UCHAR num = c<='9' ? c - '0' : c-'A'+10;\r\n        num = min(num, AC_SHRTF-AC_SHRT0-1);\r\n        return (enum action)(AC_SHRT0 + num);\r\n    }\r\n    return AC_NONE;\r\n}\r\n\r\n#endif /* ALTDRAG_RPC_H */\r\n"
        },
        {
          "name": "hooks.rc",
          "type": "blob",
          "size": 0.5869140625,
          "content": "#include \"resource.h\"\n\n1 VERSIONINFO\n  FILEVERSION VERSIONRC\n  PRODUCTVERSION VERSIONRC\n  FILEFLAGSMASK 0x3fL\n  FILEFLAGS 0x0L\n  FILEOS 0x40004L\n  FILETYPE 0x1L\n  FILESUBTYPE 0x0L\nBEGIN\n  BLOCK \"StringFileInfo\"\n  BEGIN\n    BLOCK \"040904b0\"\n    BEGIN\n      VALUE \"FileDescription\", \"Hooks for AltSnap\"\n      VALUE \"InternalName\", \"hooks\"\n      VALUE \"OriginalFilename\", \"hooks.dll\"\n      VALUE \"FileVersion\", APP_VERSION\n      VALUE \"CompanyName\", \"Gillibert Software\"\n      VALUE \"LegalCopyright\", \"Gillibert\"\n    END\n  END\n  BLOCK \"VarFileInfo\"\n  BEGIN\n    VALUE \"Translation\", 0x409, 1200\n  END\nEND\n"
        },
        {
          "name": "languages.c",
          "type": "blob",
          "size": 7.978515625,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2022                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#include \"languages.h\"\r\n\r\nstatic const struct strings *l10n_ini = NULL;\r\nstatic const struct strings *l10n = &en_US;\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Copies and remove the accelerators & sign. and txt between ( ).\r\nstatic size_t lstrcpy_noaccel(TCHAR *__restrict__ dest, const TCHAR *__restrict__ source, size_t destlen)\r\n{\r\n    size_t i=0, j=0;\r\n    while(i < destlen && source[i]) {\r\n        dest[j] = source[i];\r\n        if (source[i] == '(') {\r\n            // If we found a '(' go to the closing one ')'.\r\n            while(i < destlen && source[i] && source[i] != ')') i++;\r\n            i++;\r\n            i += source[i] == ' '; // Remove space after ) if there is one.\r\n        } else {\r\n            j += source[i] != '&';\r\n            i++;\r\n        }\r\n    }\r\n    dest[j] = '\\0';\r\n    return j;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic pure size_t lstrlen_resolved(const TCHAR *__restrict__ str)\r\n{\r\n    // Return the length of str, having resolved escape sequences\r\n    const TCHAR *ptr;\r\n    int num_escape_sequences = 0;\r\n    for (ptr=str; *ptr != '\\0'; ptr++) {\r\n        if (*ptr == '\\\\' && *(ptr+1) != '\\0') {\r\n            ptr++;\r\n            num_escape_sequences++;\r\n        }\r\n    }\r\n    return ptr-str-num_escape_sequences;\r\n}\r\n\r\nstatic void lstrcpy_resolve(TCHAR *__restrict__ dest, const TCHAR *__restrict__ source)\r\n{\r\n    // Copy from source to dest, resolving \\\\n to \\n\r\n    for (; *source != '\\0'; source++,dest++) {\r\n        if (*source == '\\\\' && *(source+1) == 'n') {\r\n            *dest = '\\n';\r\n            source++;\r\n        } else {\r\n            *dest = *source;\r\n        }\r\n    }\r\n    *dest = '\\0';\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\nstatic void LoadTranslation(const TCHAR *__restrict__ ini)\r\n{\r\n    size_t i;\r\n    if (!ini) {\r\n        l10n = (struct strings *)&en_US;\r\n        return;\r\n    } else if( INVALID_FILE_ATTRIBUTES == GetFileAttributes(ini) ) {\r\n        return;\r\n    }\r\n    // if english is not seleced then we have to allocate l10_ini strings struct\r\n    // and we have to read the ini file...\r\n    DWORD ret;\r\n    DWORD tsectionlen=16383;\r\n    TCHAR *tsection = NULL;\r\n    do {\r\n         tsectionlen *=2;\r\n         TCHAR *tmp = (TCHAR *)realloc(tsection, tsectionlen*sizeof(TCHAR));\r\n         if(!tmp) { free(tsection); return; }\r\n         tsection = tmp;\r\n         ret = GetPrivateProfileSection(TEXT(\"Translation\"), tsection, tsectionlen, ini);\r\n    } while (ret == tsectionlen-2);\r\n    if (!ret) return;\r\n\r\n    if(!l10n_ini) l10n_ini = (struct strings *)calloc(1, sizeof(struct strings));\r\n    if(!l10n_ini) return; // Unable to allocate mem\r\n    for (i=0; i < ARR_SZ(l10n_inimapping); i++) {\r\n        // Get pointer to default English string to be used if ini entry doesn't exist\r\n        const TCHAR *const def = ((TCHAR **)&en_US)[i];\r\n        const TCHAR *txt = GetSectionOptionCStr(tsection, l10n_inimapping[i], def);\r\n\r\n        TCHAR buf[128];\r\n        TCHAR **deststr = &((TCHAR **)l10n_ini)[i];\r\n        if (deststr == &l10n_ini->about_version) {\r\n            // Append version number to version....\r\n            lstrcpy_s(buf, ARR_SZ(buf), txt);\r\n            lstrcat_s(buf, ARR_SZ(buf), TEXT(\" \") TEXT(APP_VERSION));\r\n            txt = (const TCHAR*)buf;\r\n        }\r\n        *deststr = (TCHAR *)realloc( *deststr, (lstrlen_resolved(txt)+1)*sizeof(TCHAR) );\r\n        lstrcpy_resolve(*deststr, txt);\r\n    }\r\n    l10n = l10n_ini;\r\n    free(tsection); // free the cached Translation section.\r\n}\r\nstruct langinfoitem *langinfo = NULL;\r\nint nlanguages;\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nvoid ListAllTranslations()\r\n{\r\n    if (langinfo) return;\r\n\r\n    HANDLE hFind = INVALID_HANDLE_VALUE;\r\n    WIN32_FIND_DATA ffd;\r\n    TCHAR szDir[MAX_PATH], fpath[MAX_PATH*2];\r\n    LPCTSTR txt;\r\n\r\n    // First element\r\n    langinfo = (struct langinfoitem *)malloc( sizeof(struct langinfoitem) );\r\n    if (!langinfo) return;\r\n    langinfo[0].code = en_US.code;\r\n    langinfo[0].lang_english = en_US.lang_english;\r\n    langinfo[0].lang = en_US.lang;\r\n    langinfo[0].author = en_US.author;\r\n    langinfo[0].fn = NULL;\r\n    nlanguages = 1;\r\n\r\n    GetModuleFileName(NULL, szDir, ARR_SZ(szDir));\r\n    PathRemoveFileSpecL(szDir);\r\n    lstrcat_s(szDir, ARR_SZ(szDir), TEXT(\"\\\\Lang\\\\*.ini\"));\r\n    lstrcpy_s(fpath, ARR_SZ(fpath), szDir);\r\n    TCHAR *end = fpath; // not the star!\r\n    end += lstrlen(fpath)-5;\r\n    hFind = FindFirstFile(szDir, &ffd);\r\n\r\n    if (hFind != INVALID_HANDLE_VALUE) {\r\n        int n=1;\r\n        do {\r\n            nlanguages++;\r\n            lstrcpy(end, ffd.cFileName); // add filenale at the end of the path\r\n            struct langinfoitem *tmp = (struct langinfoitem *)realloc(langinfo, sizeof(*tmp) * nlanguages);\r\n            if (!tmp) break;\r\n            langinfo = tmp;\r\n\r\n            // Preload section start\r\n            TCHAR tsection[512];\r\n            DWORD ret = GetPrivateProfileSection(TEXT(\"Translation\"), tsection, ARR_SZ(tsection), fpath);\r\n            if(!ret) continue;\r\n\r\n            // Short language code such as en-US, fr-FR, it-IT etc.\r\n            txt = GetSectionOptionCStr(tsection, \"Code\", TEXT(\"\"));\r\n            langinfo[n].code = (TCHAR *)calloc(lstrlen(txt)+1, sizeof(TCHAR));\r\n            if (!langinfo[n].code) break;\r\n            lstrcpy(langinfo[n].code, txt);\r\n\r\n            // Language name in English\r\n            txt = GetSectionOptionCStr(tsection, \"LangEnglish\", TEXT(\"\"));\r\n            langinfo[n].lang_english = (TCHAR *)calloc(lstrlen(txt)+1, sizeof(TCHAR));\r\n            if (!langinfo[n].lang_english) break;\r\n            lstrcpy(langinfo[n].lang_english, txt);\r\n\r\n            // Language name in original language\r\n            txt = GetSectionOptionCStr(tsection, \"Lang\", TEXT(\"\"));\r\n            langinfo[n].lang = (TCHAR *)calloc(lstrlen(txt)+1, sizeof(TCHAR));\r\n            if (!langinfo[n].lang) break;\r\n            lstrcpy(langinfo[n].lang, txt);\r\n\r\n            // Author\r\n            txt = GetSectionOptionCStr(tsection, \"Author\", TEXT(\"\"));\r\n            langinfo[n].author = (TCHAR *)calloc(lstrlen(txt)+1, sizeof(TCHAR));\r\n            if (!langinfo[n].author) break;\r\n            lstrcpy(langinfo[n].author, txt);\r\n\r\n            // Full file path\r\n            langinfo[n].fn = (TCHAR *)malloc(lstrlen(fpath)*sizeof(TCHAR)+4);\r\n            if (!langinfo[n].fn) break;\r\n            lstrcpy(langinfo[n].fn, fpath);\r\n\r\n            n++;\r\n        } while (FindNextFile(hFind, &ffd));\r\n\r\n        FindClose(hFind);\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Helper function to get \r\nstatic int GetCUserLanguage_xx_XX(wchar_t txt[AT_LEAST 16])\r\n{\r\n    txt[0] = L'\\0';\r\n    return LCIDToLocaleNameL(GetUserDefaultLCID(), txt, 16, 0);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nvoid UpdateLanguage()\r\n{\r\n    TCHAR txt[16];\r\n    GetPrivateProfileString(TEXT(\"General\"), TEXT(\"Language\"), TEXT(\"Auto\"), txt, ARR_SZ(txt), inipath);\r\n\r\n    // Determine which language should be used\r\n    // based on current user's LCID\r\n    #ifdef _UNICODE\r\n    if (!lstrcmpi(txt, TEXT(\"Auto\"))) {\r\n        GetCUserLanguage_xx_XX(txt);\r\n    }\r\n    #endif // _UNICODE\r\n\r\n    if (!lstrcmpi(txt, TEXT(\"en-US\")))\r\n        return; // Hardcoded language\r\n\r\n    ListAllTranslations();\r\n    int i;\r\n    for (i=0; i < nlanguages; i++) {\r\n        if (!lstrcmpi(txt, langinfo[i].code)) {\r\n            LoadTranslation(langinfo[i].fn);\r\n            break;\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "name": "languages.h",
          "type": "blob",
          "size": 23.7392578125,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * This file must be UTF-8, Ãe fichier doit Ãªtre encodÃ© en UTF8          *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2020                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#ifndef ALTSNAP_STRINGS_H\r\n#define ALTSNAP_STRINGS_H\r\n\r\n#include <stddef.h>\r\n#include <windows.h>\r\n#include \"resource.h\"\r\n\r\n// Resolve index from entry name.\r\n#define L10NIDX(entryname) (short)( offsetof(struct strings, entryname)/sizeof(TCHAR**) )\r\n\r\n// Resolve entry name from index.\r\n#define L10NSTR(i) ( ((const TCHAR*const*const)l10n)[i] )\r\n\r\nstruct langinfoitem {\r\n  TCHAR *code;\r\n  TCHAR *lang_english;\r\n  TCHAR *lang;\r\n  TCHAR *author;\r\n  TCHAR *fn;\r\n};\r\n\r\n#define LANGUAGE_MAP \\\r\n  LNGVALUE(code, \"Code\", TEXT(\"en-US\")) \\\r\n  LNGVALUE(lang_english, \"LangEnglish\", TEXT(\"English\")) \\\r\n  LNGVALUE(lang, \"Lang\", TEXT(\"English\")) \\\r\n  LNGVALUE(author, \"Author\", TEXT(\"Stefan Sundin, RamonUnch\")) \\\r\n  /* Menu */ \\\r\n  LNGVALUE(menu_enable,       \"MenuEnable\",        TEXT(\"&Enable\")) \\\r\n  LNGVALUE(menu_disable,      \"MenuDisable\",       TEXT(\"&Disable\")) \\\r\n  LNGVALUE(menu_hide,         \"MenuHideTray\",      TEXT(\"&Hide tray\")) \\\r\n  LNGVALUE(menu_config,       \"MenuConfigure\",     TEXT(\"&Configure...\")) \\\r\n  LNGVALUE(menu_about,        \"MenuAbout\",         TEXT(\"&About\")) \\\r\n  LNGVALUE(menu_openinifile,  \"MenuOpenIniFile\",   TEXT(\"&Open ini file\")) \\\r\n  LNGVALUE(menu_savezones,    \"MenuSaveZones\",     TEXT(\"&Save test windows as snap layout\")) \\\r\n  LNGVALUE(menu_emptyzone,    \"MenuEmptyZone\",     TEXT(\"(empty)\")) \\\r\n  LNGVALUE(menu_snaplayout,   \"MenuSnapLayout\",    TEXT(\"Snap layout &\")) \\\r\n  LNGVALUE(menu_editlayout,   \"MenuEditLayout\",    TEXT(\"Edi&t snap layout\")) \\\r\n  LNGVALUE(menu_closeallzones,\"MenuCloseAllZones\", TEXT(\"C&lose all test windows\")) \\\r\n  LNGVALUE(menu_exit,         \"MenuExit\",          TEXT(\"E&xit\")) \\\r\n  /* Config Title and Tabs */ \\\r\n  LNGVALUE(title, \"ConfigTitle\", APP_NAME TEXT(\" Configuration\")) \\\r\n  LNGVALUE(tab_general,   \"ConfigTabGeneral\",   TEXT(\"General\")) \\\r\n  LNGVALUE(tab_mouse,     \"ConfigTabMouse\",     TEXT(\"Mouse\")) \\\r\n  LNGVALUE(tab_keyboard,  \"ConfigTabKeyboard\",  TEXT(\"Keyboard\")) \\\r\n  LNGVALUE(tab_blacklist, \"ConfigTabBlacklist\", TEXT(\"Blacklist\")) \\\r\n  LNGVALUE(tab_advanced,  \"ConfigTabAdvanced\",  TEXT(\"Advanced\")) \\\r\n  LNGVALUE(tab_about,     \"ConfigTabAbout\",     TEXT(\"About\")) \\\r\n  /* General Box */ \\\r\n  LNGVALUE(general_box, \"GeneralBox\", TEXT(\"General settings\")) \\\r\n  LNGVALUE(general_autofocus,      \"GeneralAutoFocus\",      TEXT(\"&Focus windows when dragging.\\nYou can also press Ctrl to focus windows.\")) \\\r\n  LNGVALUE(general_aero,           \"GeneralAero\",           TEXT(\"Mimi&c Aero Snap\")) \\\r\n  LNGVALUE(general_smartaero,      \"GeneralSmartAero\",      TEXT(\"Smart Aero Sna&p dimensions\")) \\\r\n  LNGVALUE(general_smarteraero,    \"GeneralSmarterAero\",    TEXT(\"Smarter Aer&o Snap dimensions\")) \\\r\n  LNGVALUE(general_stickyresize,   \"GeneralStickyResize\",   TEXT(\"Resi&ze other snapped windows with Shift\")) \\\r\n  LNGVALUE(general_inactivescroll, \"GeneralInactiveScroll\", TEXT(\"&Scroll inactive windows\")) \\\r\n  LNGVALUE(general_mdi,            \"GeneralMDI\",            TEXT(\"&MDI support\")) \\\r\n  LNGVALUE(general_autosnap,       \"GeneralAutoSnap\",       TEXT(\"S&nap window edges to:\")) \\\r\n  LNGVALUE(general_autosnap0,      \"GeneralAutoSnap0\",      TEXT(\"Disabled\")) \\\r\n  LNGVALUE(general_autosnap1,      \"GeneralAutoSnap1\",      TEXT(\"To screen borders\")) \\\r\n  LNGVALUE(general_autosnap2,      \"GeneralAutoSnap2\",      TEXT(\"+ outside of windows\")) \\\r\n  LNGVALUE(general_autosnap3,      \"GeneralAutoSnap3\",      TEXT(\"+ inside of windows\")) \\\r\n  LNGVALUE(general_language,       \"GeneralLanguage\",       TEXT(\"&Language:\")) \\\r\n  LNGVALUE(general_fullwin,        \"GeneralFullWin\",        TEXT(\"&Drag full windows\")) \\\r\n  LNGVALUE(general_usezones,       \"GeneralUseZones\",       TEXT(\"Snap to Layo&ut with Shift (configure with tray menu)\")) \\\r\n  LNGVALUE(general_piercingclick,  \"GeneralPiercingClick\",  TEXT(\"Avoi&d blocking Alt+Click (disables AltSnap double-clicks)\")) \\\r\n  LNGVALUE(general_resizeall,      \"GeneralResizeAll\",      TEXT(\"&Resize all windows\")) \\\r\n  LNGVALUE(general_resizecenter,   \"GeneralResizeCenter\",   TEXT(\"Center resize mode\")) \\\r\n  LNGVALUE(general_resizecenter_norm, \"GeneralResizeCenterNorm\", TEXT(\"All d&irections\")) \\\r\n  LNGVALUE(general_resizecenter_br,   \"GeneralResizeCenterBr\",   TEXT(\"&Bottom right\")) \\\r\n  LNGVALUE(general_resizecenter_move, \"GeneralResizeCenterMove\", TEXT(\"Mo&ve\")) \\\r\n  LNGVALUE(general_resizecenter_close,\"GeneralResizeCenterClose\",TEXT(\"Clos&est side\")) \\\r\n  LNGVALUE(general_autostart_box,         \"GeneralAutostartBox\",        TEXT(\"Autostart\")) \\\r\n  LNGVALUE(general_autostart,             \"GeneralAutostart\",           TEXT(\"S&tart \") APP_NAME TEXT(\" when logging on\")) \\\r\n  LNGVALUE(general_autostart_hide,        \"GeneralAutostartHide\",       TEXT(\"&Hide tray\")) \\\r\n  LNGVALUE(general_autostart_elevate,     \"GeneralAutostartElevate\",    TEXT(\"&Elevate to administrator privileges\")) \\\r\n  LNGVALUE(general_autostart_elevate_tip, \"GeneralAutostartElevateTip\", TEXT(\"Note that a UAC prompt will appear every time you log in, unless you disable UAC completely or use the Task Scheduler.\\nTo setup a Scheduled task for this purpose, you can use the sch_On.bat batch files in Altsnap's folder.\")) \\\r\n  LNGVALUE(general_elevate,               \"GeneralElevate\",             TEXT(\"E&levate\")) \\\r\n  LNGVALUE(general_elevated,              \"GeneralElevated\",            TEXT(\"Elevated\")) \\\r\n  LNGVALUE(general_elevation_aborted,     \"GeneralElevationAborted\",    TEXT(\"Elevation aborted.\")) \\\r\n  /* Keyboard & Mouse tabs */ \\\r\n  LNGVALUE(input_mouse_box, \"InputMouseBox\", TEXT(\"Mouse actions\")) \\\r\n  LNGVALUE(input_mouse_btac1,   \"InputMouseBtAc1\",   TEXT(\"&1. Primary\")) \\\r\n  LNGVALUE(input_mouse_btac2,   \"InputMouseBtAc2\",   TEXT(\"&2. Alternate\")) \\\r\n  LNGVALUE(input_mouse_inttb,   \"InputMouseINTTB\",   TEXT(\"&Title bar\")) \\\r\n  LNGVALUE(input_mouse_whilem,  \"InputMouseWhileM\",  TEXT(\"Whil&e moving\")) \\\r\n  LNGVALUE(input_mouse_whiler,  \"InputMouseWhileR\",  TEXT(\"While resi&zing\")) \\\r\n  LNGVALUE(input_mouse_lmb,     \"InputMouseLMB\",     TEXT(\"Left mouse &button:\")) \\\r\n  LNGVALUE(input_mouse_mmb,     \"InputMouseMMB\",     TEXT(\"&Middle mouse button:\")) \\\r\n  LNGVALUE(input_mouse_rmb,     \"InputMouseRMB\",     TEXT(\"Ri&ght mouse button:\")) \\\r\n  LNGVALUE(input_mouse_mb4,     \"InputMouseMB4\",     TEXT(\"Mouse button &4:\")) \\\r\n  LNGVALUE(input_mouse_mb5,     \"InputMouseMB5\",     TEXT(\"Mouse button &5:\")) \\\r\n  LNGVALUE(input_mouse_scroll,  \"InputMouseScroll\",  TEXT(\"&Scroll wheel:\")) \\\r\n  LNGVALUE(input_mouse_hscroll, \"InputMouseHScroll\", TEXT(\"Scroll wheel (&horizontal):\")) \\\r\n  LNGVALUE(input_mouse_moveup,  \"InputMouseMoveUp\",  TEXT(\"Long &drag-free Move:\")) \\\r\n  LNGVALUE(input_mouse_resizeup,\"InputMouseResizeUp\",TEXT(\"Long drag-&free Resize:\")) \\\r\n  LNGVALUE(input_mouse_ttbactions_box, \"InputMouseTTBActionBox\", TEXT(\"Use specific actions when clicking the Title bar\")) \\\r\n  LNGVALUE(input_mouse_ttbactionsna,   \"InputMouseTTBActionNA\",  TEXT(\"Without hot&key\")) \\\r\n  LNGVALUE(input_mouse_ttbactionswa,   \"InputMouseTTBActionWA\",  TEXT(\"&With hotkey\")) \\\r\n  LNGVALUE(input_mouse_mmb_hc, \"InputMouseMMBHC\", TEXT(\"M&iddle mouse button\")) \\\r\n  LNGVALUE(input_mouse_mb4_hc, \"InputMouseMB4HC\", TEXT(\"M&ouse button 4\")) \\\r\n  LNGVALUE(input_mouse_mb5_hc, \"InputMouseMB5HC\", TEXT(\"Mo&use button 5\")) \\\r\n  LNGVALUE(input_mouse_longclickmove, \"InputMouseLongClickMove\", TEXT(\"Mo&ve windows with a long left-click\")) \\\r\n  LNGVALUE(input_scrolllockstate,     \"InputScrollLockState\",    TEXT(\"Suspend/Resume AltSnap based on &Scroll lock state\")) \\\r\n  LNGVALUE(input_unikeyholdmenu,      \"InputUniKeyHoldMenu\",     TEXT(\"Pop&up an extended character menu when holding an alphabetic key down\")) \\\r\n  LNGVALUE(input_keycombo,          \"InputKeyCombo\",        TEXT(\"Use two keys &combo to activate\")) \\\r\n  LNGVALUE(input_grabwithalt,       \"InputGrabWithAlt\",     TEXT(\"&Action without click:\")) \\\r\n  LNGVALUE(input_grabwithaltb,      \"InputGrabWithAltB\",    TEXT(\"Acti&on without click (alt):\")) \\\r\n  LNGVALUE(input_actions_move,      \"InputActionMove\",      TEXT(\"Move window\")) \\\r\n  LNGVALUE(input_actions_resize,    \"InputActionResize\",    TEXT(\"Resize window\")) \\\r\n  LNGVALUE(input_actions_restore,   \"InputActionRestore\",   TEXT(\"Restore window\")) \\\r\n  LNGVALUE(input_actions_close,     \"InputActionClose\",     TEXT(\"&Close window\")) \\\r\n  LNGVALUE(input_actions_kill,      \"InputActionKill\",      TEXT(\"&Kill program\")) \\\r\n  LNGVALUE(input_actions_pause,     \"InputActionPause\",     TEXT(\"Pause program\")) \\\r\n  LNGVALUE(input_actions_resume,    \"InputActionResume\",    TEXT(\"Resume program\")) \\\r\n  LNGVALUE(input_actions_asonoff,   \"InputActionASOnOff\",   TEXT(\"S&uspend/Resume AltSnap\")) \\\r\n  LNGVALUE(input_actions_moveonoff, \"InputActionMoveOnOff\", TEXT(\"Movement dis&abled\")) \\\r\n  LNGVALUE(input_actions_minimize,  \"InputActionMinimize\",  TEXT(\"Mi&nimize window\")) \\\r\n  LNGVALUE(input_actions_maximize,  \"InputActionMaximize\",  TEXT(\"Ma&ximize window\")) \\\r\n  LNGVALUE(input_actions_lower,     \"InputActionLower\",     TEXT(\"&Lower window\")) \\\r\n  LNGVALUE(input_actions_focus,     \"InputActionFocus\",     TEXT(\"Focus window\")) \\\r\n  LNGVALUE(input_actions_nstacked,  \"InputActionNStacked\",  TEXT(\"Next stacked window\")) \\\r\n  LNGVALUE(input_actions_nstacked2, \"InputActionNStacked2\", TEXT(\"Next laser stacked window\")) \\\r\n  LNGVALUE(input_actions_pstacked,       \"InputActionPStacked\",   TEXT(\"Previous stacked window\")) \\\r\n  LNGVALUE(input_actions_pstacked2,      \"InputActionPStacked2\",  TEXT(\"Previous laser stacked window\")) \\\r\n  LNGVALUE(input_actions_npstacked,      \"InputActionNPStacked\",  TEXT(\"Next/Prev stacked window\")) \\\r\n  LNGVALUE(input_actions_npstacked2,     \"InputActionNPStacked2\", TEXT(\"Next/Prev laser stacked window\")) \\\r\n  LNGVALUE(input_actions_stacklist,      \"InputActionStackList\",  TEXT(\"Stacked windows list\")) \\\r\n  LNGVALUE(input_actions_stacklist2,     \"InputActionStackList2\", TEXT(\"Laser stacked windows list\")) \\\r\n  LNGVALUE(input_actions_alttablist,     \"InputActionAltTabList\", TEXT(\"Windows list\")) \\\r\n  LNGVALUE(input_actions_alttabfulllist, \"InputActionAltTabFullList\", TEXT(\"All windows list\")) \\\r\n  LNGVALUE(input_actions_mlzone,   \"InputActionMLZone\",   TEXT(\"Move to the left zone\")) \\\r\n  LNGVALUE(input_actions_mtzone,   \"InputActionMTZone\",   TEXT(\"Move to the top zone\")) \\\r\n  LNGVALUE(input_actions_mrzone,   \"InputActionMRZone\",   TEXT(\"Move to the right zone\")) \\\r\n  LNGVALUE(input_actions_mbzone,   \"InputActionMBZone\",   TEXT(\"Move to the bottom zone\")) \\\r\n  LNGVALUE(input_actions_xlzone,   \"InputActionXLZone\",   TEXT(\"Extend to the left zone\")) \\\r\n  LNGVALUE(input_actions_xtzone,   \"InputActionXTZone\",   TEXT(\"Extend to the top zone\")) \\\r\n  LNGVALUE(input_actions_xrzone,   \"InputActionXRZone\",   TEXT(\"Extend to the right zone\")) \\\r\n  LNGVALUE(input_actions_xbzone,   \"InputActionXBZone\",   TEXT(\"Extend to the bottom zone\")) \\\r\n  LNGVALUE(input_actions_xtnledge, \"InputActionXTNLEdge\", TEXT(\"Extend to the next left edge\")) \\\r\n  LNGVALUE(input_actions_xtntedge, \"InputActionXTNTEdge\", TEXT(\"Extend to the next top edge\")) \\\r\n  LNGVALUE(input_actions_xtnredge, \"InputActionXTNREdge\", TEXT(\"Extend to the next right edge\")) \\\r\n  LNGVALUE(input_actions_xtnbedge, \"InputActionXTNBEdge\", TEXT(\"Extend to the next bottom edge\")) \\\r\n  LNGVALUE(input_actions_mtnledge, \"InputActionMTNLEdge\", TEXT(\"Move to the next left edge\")) \\\r\n  LNGVALUE(input_actions_mtntedge, \"InputActionMTNTEdge\", TEXT(\"Move to the next top edge\")) \\\r\n  LNGVALUE(input_actions_mtnredge, \"InputActionMTNREdge\", TEXT(\"Move to the next right edge\")) \\\r\n  LNGVALUE(input_actions_mtnbedge, \"InputActionMTNBEdge\", TEXT(\"Move to the next bottom edge\")) \\\r\n  LNGVALUE(input_actions_stepl,    \"InputActionStepl\",    TEXT(\"Step left\")) \\\r\n  LNGVALUE(input_actions_stept,    \"InputActionStepT\",    TEXT(\"Step up\")) \\\r\n  LNGVALUE(input_actions_stepr,    \"InputActionStepR\",    TEXT(\"Step right\")) \\\r\n  LNGVALUE(input_actions_stepb,    \"InputActionStepB\",    TEXT(\"Step down\")) \\\r\n  LNGVALUE(input_actions_sstepl,   \"InputActionSStepl\",   TEXT(\"Small step left\")) \\\r\n  LNGVALUE(input_actions_sstept,   \"InputActionSStepT\",   TEXT(\"Small step up\")) \\\r\n  LNGVALUE(input_actions_sstepr,   \"InputActionSStepR\",   TEXT(\"Small step right\")) \\\r\n  LNGVALUE(input_actions_sstepb,   \"InputActionSStepB\",   TEXT(\"Small step down\")) \\\r\n  LNGVALUE(input_actions_focusl,   \"InputActionFocusL\",   TEXT(\"Focus left window\")) \\\r\n  LNGVALUE(input_actions_focust,   \"InputActionFocusT\",   TEXT(\"Focus top window\")) \\\r\n  LNGVALUE(input_actions_focusr,   \"InputActionFocusR\",   TEXT(\"Focus right window\")) \\\r\n  LNGVALUE(input_actions_focusb,   \"InputActionFocusB\",   TEXT(\"Focus bottom window\")) \\\r\n  LNGVALUE(input_actions_roll,     \"InputActionRoll\",     TEXT(\"&Roll/Unroll window\")) \\\r\n  LNGVALUE(input_actions_alwaysontop,  \"InputActionAlwaysOnTop\",  TEXT(\"Toggle always on &top\")) \\\r\n  LNGVALUE(input_actions_borderless,   \"InputActionBorderless\",   TEXT(\"Toggle &borderless\")) \\\r\n  LNGVALUE(input_actions_center,       \"InputActionCenter\",       TEXT(\"C&enter window on screen\")) \\\r\n  LNGVALUE(input_actions_oriclick,     \"InputActionOriClick\",     TEXT(\"Send ori&ginal click\")) \\\r\n  LNGVALUE(input_actions_nothing,      \"InputActionNothing\",      TEXT(\"Nothing\")) \\\r\n  LNGVALUE(input_actions_alttab,       \"InputActionAltTab\",       TEXT(\"Alt+Tab\")) \\\r\n  LNGVALUE(input_actions_volume,       \"InputActionVolume\",       TEXT(\"Volume\")) \\\r\n  LNGVALUE(input_actions_mute,         \"InputActionMute\",         TEXT(\"Mute &sounds\")) \\\r\n  LNGVALUE(input_actions_menu,         \"InputActionMenu\",         TEXT(\"Action menu\")) \\\r\n  LNGVALUE(input_actions_maximizehv,   \"InputActionMaximizeHV\",   TEXT(\"Maximize &Vertically\")) \\\r\n  LNGVALUE(input_actions_sidesnap,     \"InputActionSideSnap\",     TEXT(\"&Snap to monitor side/corner\")) \\\r\n  LNGVALUE(input_actions_extendsnap ,  \"InputActionExtendSnap\",   TEXT(\"Extend to monitor side/corner\")) \\\r\n  LNGVALUE(input_actions_extendtnedge, \"InputActionExtendTNEdge\", TEXT(\"Extend to next edge\")) \\\r\n  LNGVALUE(input_actions_movetnedge,   \"InputActionMoveTNEdge\",   TEXT(\"Move to next edge\")) \\\r\n  LNGVALUE(input_actions_minallother,  \"InputActionMinAllOther\",  TEXT(\"Minimize &other windows\")) \\\r\n  LNGVALUE(input_actions_transparency, \"InputActionTransparency\", TEXT(\"Transparency\")) \\\r\n  LNGVALUE(input_actions_zoom,         \"InputActionZoom\",         TEXT(\"Zoom window\")) \\\r\n  LNGVALUE(input_actions_zoom2,        \"InputActionZoom2\",        TEXT(\"Zoom window 2\")) \\\r\n  LNGVALUE(input_actions_hscroll,      \"InputActionHScroll\",      TEXT(\"Horizontal scroll\")) \\\r\n  \\\r\n  LNGVALUE(input_hotkeys_box,     \"InputHotkeysBox\", TEXT(\"Hotkeys\")) \\\r\n  LNGVALUE(input_hotkeys_modkey,  \"InputHotkeysModKey\", TEXT(\"Modifier key for al&ternate action:\")) \\\r\n  LNGVALUE(input_hotclicks_box,   \"InputHotclicksBox\", TEXT(\"Hotclick (activate with a click)\")) \\\r\n  LNGVALUE(input_hotclicks_more,  \"InputHotclicksMore\", TEXT(\"A checked button can be combined with an action but it will always be blocked in this case.\")) \\\r\n  LNGVALUE(input_hotkeys_alt,     \"InputHotkeysAlt\", TEXT(\"Alt\")) \\\r\n  LNGVALUE(input_hotkeys_winkey,  \"InputHotkeysWinkey\", TEXT(\"Winkey\")) \\\r\n  LNGVALUE(input_hotkeys_ctrl,    \"InputHotkeysCtrl\", TEXT(\"Ctrl\")) \\\r\n  LNGVALUE(input_hotkeys_shift,   \"InputHotkeysShift\", TEXT(\"Shift\")) \\\r\n  LNGVALUE(input_hotkeys_shortcuts,      \"InputHotkeysShortcuts\",      TEXT(\"S&hortcut for action:\")) \\\r\n  LNGVALUE(input_hotkeys_shortcutspick,  \"InputHotkeysShortcutsPick\",  TEXT(\"Pick &keys\")) \\\r\n  LNGVALUE(input_hotkeys_shortcutsclear, \"InputHotkeysShortcutsClear\", TEXT(\"Clear ke&ys\")) \\\r\n  LNGVALUE(input_hotkeys_shortcutset,    \"InputHotkeysShortcutsSet\",   TEXT(\"Sa&ve\")) \\\r\n  LNGVALUE(input_hotkeys_useptwindow,    \"InputHotkeysUsePtWindow\",    TEXT(\"Apply to the &pointed window\")) \\\r\n  LNGVALUE(input_hotkeys_leftalt,        \"InputHotkeysLeftAlt\",        TEXT(\"L&eft Alt\")) \\\r\n  LNGVALUE(input_hotkeys_rightalt,       \"InputHotkeysRightAlt\",       TEXT(\"&Right Alt\")) \\\r\n  LNGVALUE(input_hotkeys_leftwinkey,     \"InputHotkeysLeftWinkey\",     TEXT(\"Left &Winkey\")) \\\r\n  LNGVALUE(input_hotkeys_rightwinkey,    \"InputHotkeysRightWinkey\",    TEXT(\"Right W&inkey\")) \\\r\n  LNGVALUE(input_hotkeys_leftctrl,       \"InputHotkeysLeftCtrl\",       TEXT(\"&Left Ctrl\")) \\\r\n  LNGVALUE(input_hotkeys_rightctrl,      \"InputHotkeysRightCtrl\",      TEXT(\"Ri&ght Ctrl\")) \\\r\n  LNGVALUE(input_hotkeys_leftshift,      \"InputHotkeysLeftShift\",      TEXT(\"Left Shift\")) \\\r\n  LNGVALUE(input_hotkeys_rightshift,     \"InputHotkeysRightShift\",     TEXT(\"Right Shift\")) \\\r\n  LNGVALUE(input_hotkeys_more, \"InputHotkeysMore\", TEXT(\"You can add any key by editing the ini file.\\nUse the shift key to snap windows to each other.\")) \\\r\n  /* Blacklits Tab*/ \\\r\n  LNGVALUE(blacklist_box,              \"BlacklistBox\",              TEXT(\"Blacklist settings\")) \\\r\n  LNGVALUE(blacklist_processblacklist, \"BlacklistProcessBlacklist\", TEXT(\"&Process blacklist:\")) \\\r\n  LNGVALUE(blacklist_blacklist,        \"BlacklistBlacklist\",        TEXT(\"&Windows blacklist:\")) \\\r\n  LNGVALUE(blacklist_scrolllist,       \"BlacklistScrolllist\",       TEXT(\"Windows that should ignore &scroll action:\")) \\\r\n  LNGVALUE(blacklist_mdis,             \"BlacklistMDIs\",             TEXT(\"&MDIs not to be treated as such:\")) \\\r\n  LNGVALUE(blacklist_pause,            \"BlacklistPause\",            TEXT(\"Processes not to be pa&used or killed:\")) \\\r\n  LNGVALUE(blacklist_findwindow_box,   \"BlacklistFindWindowBox\",    TEXT(\"Identify window\")) \\\r\n  /* Advanced Tab */ \\\r\n  LNGVALUE(advanced_metrics_box,      \"AdvancedMetricsBox\",       TEXT(\"Metrics\")) \\\r\n  LNGVALUE(advanced_centerfraction,   \"AdvancedCenterFraction\",   TEXT(\"&Center/Sides fraction (%):\")) \\\r\n  LNGVALUE(advanced_aerohoffset,      \"AdvancedAeroHoffset\",      TEXT(\"Aero offset(%) &Horizontal:\")) \\\r\n  LNGVALUE(advanced_aerovoffset,      \"AdvancedAeroVoffset\",      TEXT(\"&Vertical:\")) \\\r\n  LNGVALUE(advanced_snapthreshold,    \"AdvancedSnapThreshold\",    TEXT(\"&Snap Threshold (pixels):\")) \\\r\n  LNGVALUE(advanced_aerothreshold,    \"AdvancedAeroThreshold\",    TEXT(\"A&ero Threshold (pixels):\")) \\\r\n  LNGVALUE(advanced_snapgap,          \"AdvancedSnapGap\",          TEXT(\"Snapping &gap (pixels):\")) \\\r\n  LNGVALUE(advanced_aerospeed,        \"AdvancedAeroSpeed\",        TEXT(\"Ma&x snapping speed (pixels):\")) \\\r\n  LNGVALUE(advanced_testwindow,       \"AdvancedTestWindow\",       TEXT(\"Test &Window\")) \\\r\n  LNGVALUE(advanced_movetrans,        \"AdvancedMoveTrans\",        TEXT(\"Opacit&y when moving:\")) \\\r\n  LNGVALUE(advanced_behavior_box,     \"AdvancedBehaviorBox\",      TEXT(\"Behavior\")) \\\r\n  LNGVALUE(advanced_multipleinstances,\"AdvancedMultipleInstances\",TEXT(\"Allow multiple &instances of AltSnap\")) \\\r\n  LNGVALUE(advanced_autoremaximize,   \"AdvancedAutoRemaximize\",   TEXT(\"Automatically &remaximize windows when changing monitor\")) \\\r\n  LNGVALUE(advanced_aerotopmaximizes, \"AdvancedAeroTopMaximizes\", TEXT(\"&Maximize windows snapped at top\")) \\\r\n  LNGVALUE(advanced_aerodbclickshift, \"AdvancedAeroDBClickShift\", TEXT(\"Invert shift &behavior for double-click aero snapping\")) \\\r\n  LNGVALUE(advanced_maxwithlclick,    \"AdvancedMaxWithLClick\",    TEXT(\"&Toggle maximize state with the resize button while moving\")) \\\r\n  LNGVALUE(advanced_restoreonclick,   \"AdvancedRestoreOnClick\",   TEXT(\"Rest&ore window with single click like original AltDrag\")) \\\r\n  LNGVALUE(advanced_fullscreen,       \"AdvancedFullScreen\",       TEXT(\"Enable on &full screen windows\")) \\\r\n  LNGVALUE(advanced_blmaximized,      \"AdvancedBLMaximized\",      TEXT(\"&Disable AltSnap on Maximized windows\")) \\\r\n  LNGVALUE(advanced_fancyzone,        \"AdvancedFancyZone\",        TEXT(\"Restore Fancy&Zones snapped windows\")) \\\r\n  LNGVALUE(advanced_norestore,        \"AdvancedNoRestore\",        TEXT(\"Never restore AltSna&pped windows\")) \\\r\n  LNGVALUE(advanced_topmostindicator, \"AdvancedTopmostIndicator\", TEXT(\"Show an i&ndicator on always on top windows\")) \\\r\n  /* About Tab */ \\\r\n  LNGVALUE(about_box,     \"AboutBox\",      TEXT(\"About \") APP_NAME ) \\\r\n  LNGVALUE(about_version, \"AboutVersion\",  TEXT(\"Version \") TEXT( APP_VERSION )) \\\r\n  LNGVALUE(about_author,  \"AboutAuthor\",   TEXT(\"Created by Stefan Sundin\")) \\\r\n  LNGVALUE(about_author2, \"AboutAuthor2\",  TEXT(\"Maintained by Raymond Gillibert\")) \\\r\n  LNGVALUE(about_license, \"AboutLicense\",  APP_NAME TEXT(\" is free and open source software!\\nFeel free to redistribute!\")) \\\r\n  LNGVALUE(about_translation_credit, \"AboutTranslationCredit\", TEXT(\"Translation credit\")) \\\r\n  /* Misc */ \\\r\n  LNGVALUE(unhook_error,      \"MiscUnhookError\",      TEXT(\"There was an error disabling AltDrag. This was most likely caused by Windows having already disabled AltDrag's hooks.\\n\\nIf this is the first time this has happened, you can safely ignore it and continue using AltDrag.\\n\\nIf this is happening repeatedly, you can read on the website how to prevent this from happening again (look for 'AltDrag mysteriously stops working' in the documentation).\")) \\\r\n  LNGVALUE(zone_confirmation, \"MiscZoneConfirmation\", TEXT(\"Erase old snap layout and save current Test Windows positions as the new snap layout?\")) \\\r\n  LNGVALUE(zone_testwinhelp,  \"MiscZoneTestWinHelp\",  TEXT(\"To setup Snap layout:\\n1) Open several of those Test Windows\\n2) Dispose them as you please\\n3) Hit the *&Save test windows as snap layout* option in the tray menu\")) \\\r\n  /* Extended character list  for each virtual key */ \\\r\n  LNGVALUE(a, \"A\", TEXT(\"Ã Ã¡Ã¢Ã¤Ã¦Ã£Ã¥Âª%ÄÄÄÇÇÇ¡Ç£Ç»Ç½ÈÈÈ§|È¦á¸%â±¥|ÈºÉ|â±¯É|â±­É|â±°â²|â²â\")) \\\r\n  LNGVALUE(b, \"B\", TEXT(\"%ÆÉÆÆÉ%Éá¸á¸á¸â\")) \\\r\n  LNGVALUE(c, \"C\", TEXT(\"Ã§Â¢Â©%ÄÄÄÄÆá¸È¼|È»Éâ\")) \\\r\n  LNGVALUE(d, \"D\", TEXT(\"Ã°%ÄÄÉÉÆÆá¸á¸á¸á¸á¸ÇÇÇ³Ç²È¡È¸â\")) \\\r\n  LNGVALUE(e, \"E\", TEXT(\"Ã¨Ã©ÃªÃ«â¬%ÄÄÄÄÄÇÉÉÈÈá¸á¸á¸á¸È©|È¨á¸É|Éâ±¸â\")) \\\r\n  LNGVALUE(f, \"F\", TEXT(\"Æ%á¸É¸â±·â%â©âªâ®â­â¯â¬â«\")) \\\r\n  LNGVALUE(g, \"G\", TEXT(\"%ÇµÇ§á¸¡É É£Ç¥â\")) \\\r\n  LNGVALUE(h, \"H\", TEXT(\"%Ä¥Ä§ÆÇ¶á¸£á¸¥á¸§á¸©á¸«È|Èâ±¨|â±§â±¶|â±µáºâ\")) \\\r\n  LNGVALUE(i, \"I\", TEXT(\"Ã¬Ã­Ã®Ã¯%Ä©Ä«Ä­ÇÈÈÄ¯Ä°Ä±Ä³É©É¨á¸­á¸¯â\")) \\\r\n  LNGVALUE(j, \"J\", TEXT(\"%ÄµÇ°È·É|Éâ\")) \\\r\n  LNGVALUE(k, \"K\", TEXT(\"%Ä·Ä¸ÆÇ©á¸±á¸³â±ª|â±©ê|êÊ|ê°â\")) \\\r\n  LNGVALUE(l, \"L\", TEXT(\"Â£%ÄºÄ¼Ä¾ÅÅÆÇÇÈ´Æ|È½â±¡|â± É«|â±¢á¸·á¸¹á¸»á¸½â\")) \\\r\n  LNGVALUE(m, \"M\", TEXT(\"Âµ%á¸¿á¹á¹É±|â±®É¯â\")) \\\r\n  LNGVALUE(n, \"N\", TEXT(\"Ã±%ÅÅÅÅÅÉ²Æ|È ÇÇÇ¹Èµ%á¹á¹á¹á¹â\")) \\\r\n  LNGVALUE(o, \"O\", TEXT(\"Ã²Ã³Ã´Ã¶ÅÃµÃ¸Â°%ÅÅÅ%ÉÉµÆ¡Æ£ÇÇ«Ç­Ç¿ÈÈÈ£|È¢È«|ÈªÈ­|È¬È¯|È®È±|È°á¹á¹á¹á¹%â±ºâ\")) \\\r\n  LNGVALUE(p, \"P\", TEXT(\"Â¶Ã¾Â·â¢%Æ¥áµ½|â±£á¹á¹â\")) \\\r\n  LNGVALUE(q, \"Q\", TEXT(\"Â¿Â¤â°ââââââ¦ââÂ«Â»â¹âº%È¹É|Éâ \")) \\\r\n  LNGVALUE(r, \"R\", TEXT(\"Â®%ÅÅÅÆ¦ÈÈá¹á¹á¹á¹É|ÉÉ½|â±¤â±¹â¡\")) \\\r\n  LNGVALUE(s, \"S\", TEXT(\"Å¡ÃÂ§%ÅÅÅÅ¿%Æ¨ÊÆªÈ|ÈÈ¿|â±¾%á¹¡á¹£á¹¥á¹§á¹©â¢\")) \\\r\n  LNGVALUE(t, \"T\", TEXT(\"â â¡â¢%Å£Å¥Å§Æ«Æ­ÊÈ|ÈÈ¶â±¦|È¾%á¹«á¹­á¹¯á¹±áºâ£\")) \\\r\n  LNGVALUE(u, \"U\", TEXT(\"Ã¹ÃºÃ»Ã¼%Å©Å«Å¯Å­Å±Å³%Æ°ÊÇÇÇÇÇÈÈÊ|É%á¹³á¹µá¹·á¹¹á¹»â¤\")) \\\r\n  LNGVALUE(v, \"V\", TEXT(\"%ÊÉâ±±â±´%á¹½á¹¿â¥\")) \\\r\n  LNGVALUE(w, \"W\", TEXT(\"%áºáºÅµáºâ±³|â±²%áºáºâ¦\")) \\\r\n  LNGVALUE(x, \"X\", TEXT(\"Â±ÃÃ·Â¬%áºáºâ§\")) \\\r\n  LNGVALUE(y, \"Y\", TEXT(\"Ã½Ã¿Â¥%Å·áºÈ³|È²Æ´É|Éâ¨\")) \\\r\n  LNGVALUE(z, \"Z\", TEXT(\"Å¾%ÅºáºÅ¼áºáº%Æ¶ÊÆ¹ÆºÇ¯È¥|È¤É|â±¿â±¬|â±«â©\"))\r\n\r\n\r\n#define LNGVALUE(x, y, z) TCHAR *x;\r\n// String structure definition\r\nstruct strings { LANGUAGE_MAP };\r\n#undef LNGVALUE\r\n\r\n#define LNGVALUE(x, y, z) y,\r\n// Name of values ini entries\r\nstatic const char* l10n_inimapping[] = { LANGUAGE_MAP };\r\n#undef LNGVALUE\r\n\r\n#define LNGVALUE(x, y, z) z,\r\n// Default values en-US\r\nstatic const struct strings en_US = { LANGUAGE_MAP };\r\n#undef LANGVALUE\r\n\r\n#endif\r\n"
        },
        {
          "name": "makerelease.bat",
          "type": "blob",
          "size": 0.763671875,
          "content": "if !%VERSION% == ! goto FAIL\r\n\r\ntaskkill /IM AltSnap.exe 2> nul\r\n\r\ndel AltSnap%version%bin_x64.zip\r\ndel AltSnap%version%bin.zip\r\ndel AltSnap%version%src.zip\r\ndel AltSnap%version%bin.zip\r\ndel AltSnap%version%-x64-inst.exe\r\n\r\nmake -fMakefileX64 clean\r\nmake -fMakefileX64\r\ncall nsi.bat\r\nrename AltSnap%VERSION%-inst.exe AltSnap%VERSION%-x64-inst.exe \r\n\r\ncall ziprelease.bat\r\nrename AltSnap_bin.zip AltSnap%version%bin_x64.zip\r\n\r\nmake clean\r\nmake\r\ncall nsi.bat\r\n\r\nrhash --sha256 AltSnap%VERSION%-x64-inst.exe > SHA256.TXT\r\nrhash --sha256 AltSnap%VERSION%-inst.exe >> SHA256.TXT\r\n\r\ncall ziprelease.bat\r\nrename AltSnap_bin.zip AltSnap%version%bin.zip\r\n\r\ncall zzip.bat\r\nrename AltSnap_src.zip AltSnap%version%src.zip\r\n\r\n@GOTO END\r\n:FAIL\r\n@echo Error set the VERSION env variable!\r\n\r\n:END\r\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "mk.bat",
          "type": "blob",
          "size": 0.1396484375,
          "content": "@taskkill /IM AltSnap.exe 2> nul\r\n@taskkill /IM AltSnap.exe 2> nul\r\n\r\nmake %1\r\n\r\n@if !%1 == !clean GOTO FINISH\r\n@start AltSnap.exe\r\n\r\n:FINISH\r\n"
        },
        {
          "name": "mk64.bat",
          "type": "blob",
          "size": 0.2744140625,
          "content": "@taskkill /IM AltSnap.exe 2> nul\r\n@taskkill /IM AltSnap.exe 2> nul\r\n\r\n@if !%1 == !db GOTO DEBUG\r\n\r\nmake -fMakefileX64 %1\r\n\r\n@if !%1 == !clean GOTO FINISH\r\n@start AltSnap.exe\r\n@GOTO FINISH\r\n\r\n: DEBUG\r\n@echo x86_64b Debug build\r\nmake -fMakefileX64db\r\ngdb.exe AltSnap.exe\r\n\r\n:FINISH\r\n"
        },
        {
          "name": "mkvcc6.bat",
          "type": "blob",
          "size": 0.7275390625,
          "content": "rc hooks.rc\r\nrc altsnap.rc\r\n\r\n@set DEFINES=/D \"DWORD_PTR=DWORD\" /D \"LONG_PTR=INT_PTR\" /D \"ULONG_PTR=DWORD\"\r\n@set DEFINES= %DEFINES% /D \"NO_VISTA\" /D \"NO_OLEAPI\" /D \"DECORATED_HOOKS_DLL_PROCS\"\r\n\r\ncl /c /Tp altsnap.c /nologo /Ox /Oi /Os /Gy  %DEFINES%\r\n\r\nlink altsnap.obj altsnap.res /nodefaultlib /filealign:512 /subsystem:windows /OPT:REF /OPT:ICF,7 /LARGEADDRESSAWARE  /machine:I386  /entry:unfuckWinMain kernel32.lib user32.lib shell32.lib advapi32.lib gdi32.lib comctl32.lib\r\n\r\ncl /c /Tp hooks.c /nologo /Ox /Oi /Os /Gy /GS- /LD %DEFINES%\r\n\r\nlink hooks.obj hooks.res /nodefaultlib /DLL /filealign:512 /subsystem:windows /OPT:REF /OPT:ICF,7 /LARGEADDRESSAWARE  /machine:I386  /entry:DllMain kernel32.lib user32.lib gdi32.lib\r\n\r\n@set DEFINES=\r\n"
        },
        {
          "name": "nanolibc.h",
          "type": "blob",
          "size": 17.0029296875,
          "content": "#ifndef NANOLIBC_H\r\n#define NANOLIBC_H\r\n\r\n#include <windows.h>\r\n\r\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L && !defined(__WATCOMC__)\r\n\t// C99+ mode but not buggy watcom C99\r\n\t#define AT_LEAST static\r\n#else\r\n\t#define AT_LEAST\r\n#endif\r\n\r\n#ifdef __GNUC__\r\n#define flatten __attribute__((flatten))\r\n#define xpure __attribute__((const))\r\n#define pure __attribute__((pure))\r\n#define noreturn __attribute__((noreturn))\r\n#define fastcall __attribute__((fastcall))\r\n#define ainline __attribute__((always_inline))\r\n#define mallocatrib __attribute__((malloc, freeL))\r\n#define allnonnull __attribute__((nonnull))\r\n#define nonnull1(x) __attribute__((nonnull (x)))\r\n#define nonnull2(x, y) __attribute__((nonnull (x, y)))\r\n#define ASSUME(x) do { if (!(x)) __builtin_unreachable(); } while (0)\r\n#define UNREACHABLE() __builtin_unreachable()\r\n#else\r\n#define flatten\r\n#define xpure\r\n#define pure\r\n#define noreturn\r\n#define fastcall\r\n#define ainline\r\n#define mallocatrib\r\n#define allnonnull\r\n#define nonnull1(x)\r\n#define nonnull2(x, y)\r\n#define __restrict__\r\n#define inline\r\n#define ASSUME(x)\r\n#define UNREACHABLE()\r\n#endif\r\n/* return +/-1 if x is +/- and 0 if x == 0 */\r\nstatic xpure int sign(int x)\r\n{\r\n    return (x > 0) - (x < 0);\r\n}\r\n\r\n//#if defined(__GNUC__) && (defined(__i386__) && !defined(__x86_64__)) && !defined(CLANG)\r\n//static __attribute__(( regparm(1) )) xpure\r\n//int Iabs(int x)\r\n//{\r\n//    __asm__ (\r\n//        \"cdq \\n\"\r\n//        \"xor %%edx, %%eax \\n\"\r\n//        \"sub %%edx, %%eax \\n\"\r\n//    : \"=eax\" (x)\r\n//    : \"eax\" (x)\r\n//    : \"%edx\"\r\n//    );\r\n//    return x;\r\n//}\r\n//#define abs(x) Iabs(x)\r\n//#else\r\n//#define abs(x) ((x)>0? (x): -(x))\r\n//#endif // x86\r\n\r\n#define abs(x) ((x)>0? (x): -(x))\r\n/* Function to set the kth bit of n */\r\nstatic int setBit(int n, int k)\r\n{\r\n    return (n | (1 << (k)));\r\n}\r\n\r\n/* Function to clear the kth bit of n */\r\nstatic int clearBit(int n, int k)\r\n{\r\n    return (n & (~(1 << (k))));\r\n}\r\n\r\n/* Function to toggle the kth bit of n */\r\nstatic int toggleBit(int n, int k)\r\n{\r\n    return (n ^ (1 << (k)));\r\n}\r\n\r\nstatic void str2tchar(TCHAR *w, const char *s)\r\n{\r\n    while((*w++ = *s++));\r\n}\r\n\r\nstatic void str2tchar_s(TCHAR *w, size_t N, const char *s)\r\n{\r\n    const TCHAR *wmax = w + N-1;\r\n    while(w < wmax && (*w++ = *s++));\r\n}\r\n\r\nstatic void mem00(void *dst, size_t count)\r\n{\r\n    register char * a = (char *)dst;\r\n    while (count--)\r\n        *a++ = 0;\r\n}\r\n\r\n#ifdef CLANG\r\n\r\nvoid * __cdecl memset(void *dst, int s, size_t count)\r\n{\r\n    register char * a = dst;\r\n    count++;\r\n    while (--count)\r\n        *a++ = s;\r\n    return dst;\r\n}\r\n/* in case */\r\n__cdecl size_t strlen(const char *str)\r\n{\r\n    const char *ptr;\r\n    for (ptr=str; *ptr != '\\0'; ptr++);\r\n    return ptr-str;\r\n}\r\nvoid * __cdecl memcpy(void *dst, const void * __restrict__ src, size_t n)\r\n{\r\n    size_t i;\r\n    char *d = (char *)dst;\r\n    const char *s = (char *)src;\r\n\r\n    for (i=0; i<n; i++)\r\n        d++ = s++;\r\n    return dst;\r\n}\r\n#endif\r\n\r\nstatic allnonnull wchar_t *wcsuprL(wchar_t *s)\r\n{\r\n    while (*s) {\r\n        wchar_t  x = *s - 'a';\r\n        *s -= (x < 26u) << 5;\r\n        s++;\r\n    }\r\n    return s;\r\n}\r\nstatic allnonnull wchar_t *wcslwrL(wchar_t *s)\r\n{\r\n    while (*s) {\r\n        wchar_t  x = *s - 'A';\r\n        *s += (x < 26u) << 5;\r\n        s++;\r\n    }\r\n    return s;\r\n}\r\n\r\nstatic nonnull1(1) pure wchar_t *wcschrL(wchar_t *__restrict__ str, const wchar_t c)\r\n{\r\n    while(*str != c) {\r\n        if(!*str) return NULL;\r\n        str++;\r\n    }\r\n    return str;\r\n}\r\n#define wcschr wcschrL\r\n\r\nstatic nonnull1(1) pure char *strchrL(char *__restrict__ str, const char c)\r\n{\r\n    while(*str != c) {\r\n        if(!*str) return NULL;\r\n        str++;\r\n    }\r\n    return str;\r\n}\r\n#define strchr strchrL\r\n\r\n\r\nstatic allnonnull pure int atoiL(const char *s)\r\n{\r\n    long int v=0;\r\n    int ssign=1;\r\n    while (*s == ' ') s++; /*  ||  (unsigned int)(*s - 9) < 5u */\r\n\r\n    switch (*s) {\r\n    case '-': ssign=-1; /* fall through */\r\n    case '+': ++s;\r\n    }\r\n    while ((unsigned)(*s - '0') < 10u) {\r\n        v = v * 10 + (*s - '0');\r\n        ++s;\r\n    }\r\n    return ssign*v;\r\n}\r\n#define atoi atoiL\r\n\r\nstatic pure allnonnull int wtoiL(const wchar_t *s)\r\n{\r\n    long int v=0;\r\n    int ssign=1;\r\n    while (*s == ' ') s++; /*  ||  (unsigned int)(*s - 9) < 5u */\r\n\r\n    switch (*s) {\r\n    case '-': ssign=-1; /* fall through */\r\n    case '+': ++s;\r\n    }\r\n    while ((unsigned)(*s - '0') < 10u) {\r\n        v = v * 10 + (*s - '0');\r\n        ++s;\r\n    }\r\n    return ssign*v;\r\n}\r\n#define _wtoi wtoiL\r\nstatic nonnull1(1) void reverseW(wchar_t *str, int length)\r\n{\r\n    int start = 0;\r\n    int end = length -1;\r\n    while (start < end) {\r\n        wchar_t tmp;\r\n        tmp = str[start];\r\n        str[start] = str[end];\r\n        str[end] = tmp;\r\n        start++;\r\n        end--;\r\n    }\r\n}\r\nstatic nonnull1(2) wchar_t *itowL(unsigned num, wchar_t *str, int base)\r\n{\r\n    int i = 0;\r\n    int isNegative = 0;\r\n\r\n    /* Handle 0 explicitely */\r\n    if (num == 0) {\r\n        str[i++] = '0';\r\n        str[i] = '\\0';\r\n        return str;\r\n    }\r\n\r\n    /* In standard itoa(), negative numbers are handled only with\r\n     * base 10. Otherwise numbers are considered unsigned. */\r\n    if ((int)num < 0 && base == 10) {\r\n        isNegative = 1;\r\n        num = -(int)num;\r\n    }\r\n\r\n    /* Process individual digits */\r\n    while (num != 0) {\r\n        int rem = num % base;\r\n        /* str[i++] = (rem > 9)? (rem-10) + 'A' : rem + '0'; */\r\n        str[i++] = rem + '0' + (rem > 9) * ('A' - '0' - 10); /* branchless version */\r\n\r\n        num = num/base;\r\n    }\r\n\r\n    /* If number is negative, append '-' */\r\n    if (isNegative)\r\n        str[i++] = '-';\r\n\r\n    str[i] = '\\0'; /* Append string terminator */\r\n\r\n    /* Reverse the string */\r\n    reverseW(str, i);\r\n\r\n    return str;\r\n}\r\n#define _itow itowL\r\nstatic nonnull1(1) inline void reverseA(char *str, int length)\r\n{\r\n    int start = 0;\r\n    int end = length -1;\r\n    while (start < end) {\r\n        char tmp;\r\n        tmp = str[start];\r\n        str[start] = str[end];\r\n        str[end] = tmp;\r\n        start++;\r\n        end--;\r\n    }\r\n}\r\nstatic nonnull1(2) char *itoaL(unsigned num, char *str, int base)\r\n{\r\n    int i = 0;\r\n    int isNegative = 0;\r\n\r\n    /* Handle 0 explicitely */\r\n    if (num == 0) {\r\n        str[i++] = '0';\r\n        str[i] = '\\0';\r\n        return str;\r\n    }\r\n\r\n    /* In standard itoa(), negative numbers are handled only with\r\n     * base 10. Otherwise numbers are considered unsigned. */\r\n    if ((int)num < 0 && base == 10) {\r\n        isNegative = 1;\r\n        num = -(int)num;\r\n    }\r\n\r\n    /* Process individual digits */\r\n    while (num != 0) {\r\n        int rem = num % base;\r\n        str[i++] = (rem > 9)? (rem-10) + 'A' : rem + '0';\r\n        /* str[i++] = rem + '0' + (rem > 9) * ('A' - '0' - 10);*//* branchless version */\r\n\r\n        num = num/base;\r\n    }\r\n\r\n    /* If number is negative, append '-' */\r\n    if (isNegative)\r\n        str[i++] = '-';\r\n\r\n    str[i] = '\\0'; /* Append string terminator */\r\n\r\n    /* Reverse the string */\r\n    reverseA(str, i);\r\n\r\n    return str;\r\n}\r\n#define _itoa itoaL\r\n\r\n#define INT_DIGITS 11\r\n#define UINT_DIGITS 10\r\nstatic const TCHAR *Int2lStr(TCHAR str[AT_LEAST INT_DIGITS+1], int n)\r\n{\r\n    int i = 0;\r\n    BOOL minus;\r\n    minus = (n<0);\r\n    str[INT_DIGITS] = TEXT('\\0');\r\n\r\n    for( i=INT_DIGITS-1; ; --i )\r\n    {\r\n        str[i] = TEXT('0') + (minus ? -1*(n%10) : n%10);\r\n        n /= 10;\r\n        if( n==0 )\r\n            break;\r\n    }\r\n\r\n    if( minus )\r\n        str[--i] = TEXT('-');\r\n\r\n    return str+i;\r\n}\r\n\r\nstatic const wchar_t *Uint2lStrW(wchar_t str[AT_LEAST UINT_DIGITS+1], unsigned n)\r\n{\r\n    int i = 0;\r\n    str[UINT_DIGITS] = TEXT('\\0');\r\n\r\n    for( i=UINT_DIGITS-1; ; --i )\r\n    {\r\n        str[i] = TEXT('0') + (wchar_t)(n%10);\r\n        if( n < 10 )\r\n            break;\r\n        n /= 10;\r\n    }\r\n\r\n    return str+i;\r\n}\r\nstatic const char *Uint2lStrA(char str[AT_LEAST UINT_DIGITS+1], unsigned n)\r\n{\r\n    int i = 0;\r\n    str[UINT_DIGITS] = TEXT('\\0');\r\n\r\n    for( i=UINT_DIGITS-1; ; --i )\r\n    {\r\n        str[i] = TEXT('0') + (char)(n%10);\r\n        if( n < 10 )\r\n            break;\r\n        n /= 10;\r\n    }\r\n\r\n    return str+i;\r\n}\r\n\r\n#ifdef WIN64\r\n#define LPTR_HDIGITS 16\r\n#else\r\n#define LPTR_HDIGITS 8\r\n#endif\r\nstatic const TCHAR *LPTR2Hex(TCHAR str[AT_LEAST LPTR_HDIGITS+1], UINT_PTR n)\r\n{\r\n    int i = 0;\r\n    str[LPTR_HDIGITS] = TEXT('\\0');\r\n\r\n    for( i=LPTR_HDIGITS-1; ; --i )\r\n    {\r\n        TCHAR rem = n & 15; // MD 16\r\n        str[i] = (rem > 9)? (rem-10) + 'A' : rem + '0';\r\n        /*str[i++] = rem + '0' + (rem > 9) * ('A' - '0' - 10); *//* branchless version */\r\n\r\n        n >>=4 ; // Divide by 16.\r\n        if (n==0)\r\n            break;\r\n    }\r\n\r\n    return str+i;\r\n}\r\n\r\n\r\nstatic allnonnull pure size_t wcslenL(const wchar_t *__restrict__ const str)\r\n{\r\n    const wchar_t *ptr;\r\n    for (ptr=str; *ptr != '\\0'; ptr++);\r\n    return ptr-str;\r\n}\r\n#define wcslen wcslenL\r\n\r\nstatic allnonnull pure size_t strlenL(const char * const str)\r\n{\r\n    const char *ptr;\r\n    for (ptr=str; *ptr != '\\0'; ptr++);\r\n    return ptr-str;\r\n}\r\n\r\nstatic int pure allnonnull wcscmpL(const wchar_t *__restrict__ a, const wchar_t *__restrict__ b)\r\n{\r\n    while(*a && *a == *b) { a++; b++; }\r\n    return *a - *b;\r\n}\r\n#define wcscmp wcscmpL\r\n\r\n/* Reverse of the next function */\r\nstatic nonnull1(1) pure int lstrcmp_rstar(const TCHAR *__restrict__ a, const TCHAR *__restrict__ b)\r\n{\r\n    const TCHAR *oa = a, *ob=b;\r\n    if(!b) return 0;\r\n\r\n    while(*a++) ;\r\n    a--;\r\n    while(*b++) ;\r\n    b--;\r\n    if(*ob != '*' && a-oa != b-ob)\r\n        return 1;\r\n\r\n    while(a > oa && b > ob && *a == *b) { a--; b--; }\r\n\r\n    return (*a != *b) & (*b != '*');\r\n}\r\n/* stops comp at the '*' in the b param.\r\n * this is a kind of mini regexp that has no performance hit.\r\n * It also returns 0 (equal) if the b param is NULL */\r\nstatic nonnull1(1) pure int lstrcmp_star(const TCHAR *__restrict__ a, const TCHAR *__restrict__ b)\r\n{\r\n    if(!b) return 0;\r\n    if(*b == L'*') return lstrcmp_rstar(a, b);\r\n\r\n    while(*a && *a == *b) { a++; b++; }\r\n    return (*a != *b) & (*b != '*');\r\n}\r\n#define tolower(x) ( (x) | ('A'<(x) && (x)<'Z') << 5 )\r\n#define tolowerevil(x) ( (x) | 1 << 5 )\r\n\r\n/* Returns 0 if both strings start the same */\r\nstatic nonnull1(1) int pure lstrcmpi_samestart(const TCHAR *__restrict__ a, const TCHAR *__restrict__ b)\r\n{\r\n    while(*a && tolower(*a) == tolower(*b)) { a++; b++; }\r\n    return (*a != *b) && (*b != '\\0');\r\n}\r\n\r\nstatic allnonnull int pure lstrcmp_samestart(const TCHAR *__restrict__ a, const TCHAR *__restrict__ b)\r\n{\r\n    while(*a && *a == *b) { a++; b++; }\r\n    return (*a != *b) && (*b != '\\0');\r\n}\r\n\r\nstatic allnonnull wchar_t *wcscpyL(wchar_t *__restrict__ dest, const wchar_t *__restrict__ in)\r\n{\r\n    wchar_t *ret = dest;\r\n    while ((*dest++ = *in++));\r\n    return ret;\r\n}\r\n#define wcscpy wcscpyL\r\n\r\nstatic nonnull2(1,2) wchar_t *wcsncpyL(wchar_t *__restrict__ dest, const wchar_t *__restrict__ src, size_t n)\r\n{\r\n    wchar_t *orig = dest;\r\n    for (; dest < orig+n && (*dest=*src); ++src, ++dest) ;\r\n    for (; dest < orig+n; ++dest) *dest=0;\r\n    return orig;\r\n}\r\n#define wcsncpy wcsncpyL\r\n\r\nstatic allnonnull char *strcpyL(char *__restrict__ dest, const char *__restrict__ in)\r\n{\r\n    char *ret = dest;\r\n    while ((*dest++ = *in++));\r\n    return ret;\r\n}\r\n#define strcpy strcpyL\r\n\r\nstatic allnonnull pure int stricmpL(const char* s1, const char* s2)\r\n{\r\n    unsigned x1, x2;\r\n\r\n    while (1) {\r\n        x2 = *s2 - 'A';\r\n        x2 |= (x2 < 26u) << 5; /* Add 32 if UPPERCASE. */\r\n\r\n        x1 = *s1 - 'A';\r\n        x1 |= (x1 < 26u) << 5;\r\n\r\n        s1++; s2++;\r\n        if (x2 != x1)\r\n            break;\r\n        if (x1 == (unsigned)-'A')\r\n            break;\r\n    }\r\n    return x1 - x2;\r\n}\r\n#define stricmp stricmpL\r\n\r\nstatic allnonnull pure int wcsicmpL(const wchar_t* s1, const wchar_t* s2)\r\n{\r\n    unsigned x1, x2;\r\n\r\n    while (1) {\r\n        x2 = *s2 - 'A';\r\n        x2 |= (x2 < 26u) << 5; /* Add 32 if UPPERCASE. */\r\n\r\n        x1 = *s1 - 'A';\r\n        x1 |= (x1 < 26u) << 5;\r\n\r\n        s1++; s2++;\r\n        if (x2 != x1)\r\n            break;\r\n        if (x1 == (unsigned)-'A')\r\n            break;\r\n    }\r\n    return x1 - x2;\r\n}\r\n#define wcsicmp wcsicmpL\r\n\r\nstatic allnonnull pure int strtotcharicmp(const TCHAR* s1, const char* s2)\r\n{\r\n    unsigned x1, x2;\r\n\r\n    while (1) {\r\n        x2 = *s2 - 'A';\r\n        x2 |= (x2 < 26u) << 5; /* Add 32 if UPPERCASE. */\r\n\r\n        x1 = *s1 - 'A';\r\n        x1 |= (x1 < 26u) << 5;\r\n\r\n        s1++; s2++;\r\n        if (x2 != x1)\r\n            break;\r\n        if (x1 == (unsigned)-'A')\r\n            break;\r\n    }\r\n    return x1 - x2;\r\n}\r\n\r\nallnonnull wchar_t *wcscatL(wchar_t *__restrict__ dest, const wchar_t *__restrict__ src)\r\n{\r\n    wchar_t *orig=dest;\r\n    for (; *dest; ++dest) ;    /* go to end of dest */\r\n    for (; (*dest=*src); ++src,++dest) ;    /* then append from src */\r\n    return orig;\r\n}\r\nallnonnull char *strcatL(char *__restrict__ dest, const char *__restrict__ src)\r\n{\r\n    char *orig=dest;\r\n    for (; *dest; ++dest) ;    /* go to end of dest */\r\n    for (; (*dest=*src); ++src,++dest) ;    /* then append from src */\r\n    return orig;\r\n}\r\n\r\nstatic nonnull2(1,3) char *strcat_sL(char *__restrict__ dest, const size_t N, const char *__restrict__ src)\r\n{\r\n    char *orig=dest;\r\n    const char *dmax=dest+N-1; /* keep space for a terminating NULL */\r\n    for (; dest<dmax &&  *dest ; ++dest);             /* go to end of dest */\r\n    for (; dest<dmax && (*dest=*src); ++src,++dest);  /* then append from src */\r\n    *dest='\\0'; /* ensure result is NULL terminated */\r\n    return orig;\r\n}\r\n#define strcat_s strcat_sL\r\n\r\nnonnull2(1,3) wchar_t *wcscat_sL(wchar_t *__restrict__ dest, const size_t N, const wchar_t *__restrict__ src)\r\n{\r\n    wchar_t *orig=dest;\r\n    const wchar_t *dmax=dest+N-1; /* keep space for a terminating NULL */\r\n    for (; dest<dmax &&  *dest ; ++dest);             /* go to end of dest */\r\n    for (; dest<dmax && (*dest=*src); ++src,++dest);  /* then append from src */\r\n    *dest='\\0'; /* ensure result is NULL terminated */\r\n    return orig;\r\n}\r\n#define wcscat_s wcscat_sL\r\n\r\nstatic nonnull2(1,3) TCHAR *lstrcpy_s(TCHAR *__restrict__ dest, const size_t N, const TCHAR *__restrict__ src)\r\n{\r\n    TCHAR *orig=dest;\r\n    const TCHAR *dmax=dest+N-1; /* keep space for a terminating NULL */\r\n    for (; dest<dmax && (*dest=*src); ++src,++dest);  /* then append from src */\r\n    *dest='\\0'; /* ensure result is NULL terminated */\r\n    return orig;\r\n}\r\n\r\nstatic allnonnull pure int strcmpL(const char *X, const char *Y)\r\n{\r\n    while (*X && *X == *Y) {\r\n        X++;\r\n        Y++;\r\n    }\r\n    return *(const unsigned char*)X - *(const unsigned char*)Y;\r\n}\r\n#define strcmp strcmpL\r\n\r\nstatic allnonnull const char *lstrstrA(const char *haystack, const char *needle)\r\n{\r\n    size_t i,j;\r\n    for (i=0; haystack[i]; ++i) {\r\n        for (j=0; haystack[i+j]==needle[j] && needle[j]; ++j) ;\r\n        if (!needle[j]) return &haystack[i];\r\n    }\r\n    return NULL;\r\n}\r\nstatic allnonnull const wchar_t *lstrstrW(const wchar_t *haystack, const wchar_t *needle)\r\n{\r\n    size_t i,j;\r\n    for (i=0; haystack[i]; ++i) {\r\n        for (j=0; haystack[i+j]==needle[j] && needle[j]; ++j) ;\r\n        if (!needle[j]) return &haystack[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\n#define itostrA itoaL\r\n#define itostrW itowL\r\n#define strtoiA atoiL\r\n#define strtoiW wtoiL\r\n#define wcsstr lstrstrW\r\n#define strstr lstrstrA\r\n#define lstrcpyA strcpy\r\n#define lstrcpyW wcscpy\r\n#define lstrcatA strcat\r\n#define lstrcat_sA strcat_s\r\n#define lstrcat_sW wcscat_s\r\n#define lstrcatW wcscat\r\n#define lstrlenA strlenL\r\n#define lstrlenW wcslenL\r\n#define lstrcmpA strcmp\r\n#define lstrcmpW wcscmp\r\n#define lstrcmpiA stricmp\r\n#define lstrcmpiW wcsicmp\r\n#define lstrchrA strchrL\r\n#define lstrchrW wcschrL\r\n#ifdef UNICODE\r\n#define lstrstr lstrstrW\r\n#define lstrchr lstrchrW\r\n#define itostr itostrW\r\n#define strtoi strtoiW\r\n#define lstrcat_s lstrcat_sW\r\n#define _itot itowL\r\n#define Uint2lStr Uint2lStrW\r\n#else\r\n#define lstrstr lstrstrA\r\n#define lstrchr lstrchrA\r\n#define itostr itostrA\r\n#define strtoi strtoiA\r\n#define lstrcat_s lstrcat_sA\r\n#define _itot itoaL\r\n#define Uint2lStr Uint2lStrA\r\n#endif\r\n\r\nstatic inline unsigned h2u(const TCHAR c)\r\n{\r\n    if      (c >= '0' && c <= '9') return c - '0';\r\n    else if (c >= 'A' && c <= 'F') return c-'A'+10;\r\n    else if (c >= 'a' && c <= 'f') return c-'a'+10;\r\n    else return 0;\r\n}\r\n\r\nstatic pure int IsSeparator(TCHAR c)\r\n{\r\n    return c <= '0';\r\n}\r\n/* stops at the end of the string or at a any char before '0' */\r\nstatic allnonnull pure unsigned lstrhex2u(const TCHAR *s)\r\n{\r\n    unsigned ret=0;\r\n    while(*s >= '0')\r\n       ret = ret << 4 | h2u(*s++) ;\r\n\r\n    return ret;\r\n}\r\n\r\nstatic void *reallocL(void *mem, size_t sz)\r\n{\r\n//    if (rand()%256 < 200) return NULL;\r\n    if(!mem) return HeapAlloc(GetProcessHeap(), 0, sz);\r\n    return HeapReAlloc(GetProcessHeap(), 0, mem, sz);\r\n}\r\n#define realloc reallocL\r\n\r\nstatic mallocatrib void *mallocL(size_t sz)\r\n{\r\n//    if (rand()%256 < 200) return NULL;\r\n    return HeapAlloc(GetProcessHeap(), 0, sz);\r\n}\r\n#define malloc mallocL\r\n\r\nstatic mallocatrib void *callocL(size_t sz, size_t mult)\r\n{\r\n    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sz*mult);\r\n}\r\n#define calloc callocL\r\n\r\nstatic BOOL freeL(void *mem)\r\n{\r\n    if(mem) return HeapFree(GetProcessHeap(), 0, mem);\r\n    return FALSE;\r\n}\r\n#define free freeL\r\n\r\n#endif\r\n"
        },
        {
          "name": "nsi.bat",
          "type": "blob",
          "size": 0.0556640625,
          "content": "\"%PROGRAMFILES%\\nsis-2.51\\makensis.exe\" /V2 AltSnap.nsi\r\n"
        },
        {
          "name": "oldmk64.bat",
          "type": "blob",
          "size": 0.966796875,
          "content": "@set WARNINGS=-Wall -Wformat-security -Wstrict-overflow -Wsign-compare -Wclobbered -Wempty-body -Wignored-qualifiers -Wuninitialized -Wtype-limits -Woverride-init  -Wlogical-op\r\n\r\n@set CFLAGS=-Os -m64 -momit-leaf-frame-pointer -mno-stack-arg-probe -fno-ident -fomit-frame-pointer -fno-stack-check -fno-stack-protector -lkernel32 -lmsvcrt -luser32 -lgdi32 -flto -Wl,-dynamicbase,-nxcompat,--no-seh -s -Wp,-D_FORTIFY_SOURCE=2\r\n\r\n:: -finline-functions-called-once \r\n:: -Wunused-parameter\r\n:: -nostdlib \r\n:: -Wduplicated-cond  -Wduplicated-branches -Wnull-dereference\r\n\r\n@taskkill /IM AltSnap.exe 2> nul\r\n\r\n@ECHO WINDRES ALTDRAG.RC\r\n@windres altsnap.rc altsnapr.o\r\n\r\n@ECHO WINDRES HOOKS.RC\r\n@windres hooks.rc hooksr.o\r\n\r\n@ECHO CC ALTSNAP.EXE\r\n@gcc -o AltSnap.exe altsnap.c altsnapr.o %CFLAGS% -lcomctl32 -mwindows -ladvapi32 -lshell32\r\n\r\n@ECHO CC HOOKS.DLL\r\n@gcc -o hooks.dll hooks.c hooksr.o -nostdlib %CFLAGS% -mdll -D__USE_MINGW_ANSI_STDIO=0 -eDllMain\r\n\r\n@set CFLAGS=\r\n\r\n@start AltSnap.exe\r\n"
        },
        {
          "name": "resource.h",
          "type": "blob",
          "size": 8.38671875,
          "content": "#ifndef AS_RESOURCE_H\r\n#define AS_RESOURCE_H\r\n\r\n#ifndef IDC_STATIC\r\n#define IDC_STATIC (-1)\r\n#endif\r\n\r\n#define VERSIONRC     1,6,4,0\r\n#define APP_VERSION  \"1.64\"\r\n\r\n#define APP_ICON                         101\r\n#define TRAY_OFF                         102\r\n#define TRAY_ON                          103\r\n#define TRAY_SUS                         104\r\n\r\n#define IDD_GENERALPAGE                  201\r\n#define IDD_MOUSEPAGE                    202\r\n#define IDD_KBPAGE                       203\r\n#define IDD_BLACKLISTPAGE                204\r\n#define IDD_ADVANCEDPAGE                 205\r\n#define IDD_ABOUTPAGE                    206\r\n\r\n#define IDI_FIND                         301\r\n#define IDI_BIGICON                      302\r\n#define IDC_HELPPANNEL                   303\r\n\r\n#define IDC_AUTOSNAP_HEADER             1000\r\n#define IDC_FINDWINDOW                  1000\r\n#define IDC_CHECKNOW                    1001\r\n#define IDC_LANGUAGE_HEADER             1001\r\n#define IDC_TTBACTIONSNA                1001\r\n#define IDC_TRANSLATIONS_BOX            1001\r\n#define IDC_INI                         1002\r\n#define IDC_NEWRULE                     1002\r\n#define IDC_MDI                         1003\r\n#define IDC_SCROLL                      1003\r\n#define IDC_TRANSLATIONS                1003\r\n#define IDC_AUTOSAVE                    1004\r\n#define IDC_PROCESSBLACKLIST_HEADER     1004\r\n#define IDC_SCROLL_HEADER               1004\r\n#define IDC_AUTOSTART_ELEVATE           1005\r\n#define IDC_BLACKLIST_HEADER            1006\r\n#define IDC_ELEVATE                     1006\r\n#define IDC_LMB_HEADER                  1006\r\n#define IDC_MMB_HEADER                  1007\r\n#define IDC_RMB_HEADER                  1008\r\n#define IDC_CHECKONSTARTUP              1009\r\n#define IDC_MB4_HEADER                  1009\r\n#define IDC_BETA                        1010\r\n#define IDC_MB5_HEADER                  1010\r\n#define IDC_FINDWINDOW_BOX              1012\r\n#define IDC_HOTKEYS_MORE                1013\r\n#define IDC_BLACKLIST_BOX               1014\r\n#define IDC_SCROLLLIST_HEADER           1015\r\n#define IDC_BLACKLIST_EXPLANATION       1016\r\n#define IDC_ADVANCED_BOX                1017\r\n#define IDC_GENERAL_BOX                 1018\r\n#define IDC_AUTOSTART_BOX               1019\r\n#define IDC_AUTOFOCUS                   1101\r\n#define IDC_AUTOSNAP                    1102\r\n#define IDC_AERO                        1103\r\n#define IDC_INACTIVESCROLL              1104\r\n#define IDC_LANGUAGE                    1105\r\n#define IDC_LMB                         1201\r\n#define IDC_MMB                         1202\r\n#define IDC_RMB                         1203\r\n#define IDC_MB4                         1204\r\n#define IDC_MB5                         1205\r\n#define IDC_LEFTALT                     1206\r\n#define IDC_RIGHTALT                    1207\r\n#define IDC_LEFTWINKEY                  1208\r\n#define IDC_RIGHTWINKEY                 1209\r\n#define IDC_LEFTCTRL                    1210\r\n#define IDC_RIGHTCTRL                   1211\r\n#define IDC_HOOKWINDOWS                 1401\r\n#define IDC_OPENINI                     1402\r\n#define IDC_DONATE                      1501\r\n#define IDC_SCROLLLIST                  1505\r\n#define IDC_BLACKLIST                   1506\r\n#define IDC_PROCESSBLACKLIST            1507\r\n#define IDC_AUTOSTART                   1508\r\n#define IDC_AUTOSTART_HIDE              1511\r\n#define IDC_MOUSE_BOX                   1511\r\n#define IDC_HOTKEYS_BOX                 1512\r\n#define IDC_FINDWINDOW_EXPLANATION      1513\r\n#define IDC_ABOUT_BOX                   1514\r\n#define IDC_VERSION                     1515\r\n#define IDC_AUTHOR                      1516\r\n#define IDC_LICENSE                     1517\r\n#define IDC_URL                         1518\r\n#define IDC_NEWPROGNAME                 1519\r\n#define IDC_HOTCLICKS_BOX               1520\r\n#define IDC_AUTHOR2                     1521\r\n\r\n#define IDC_MBA1                        1601\r\n#define IDC_MBA2                        1602\r\n#define IDC_INTTB                       1603\r\n#define IDC_WHILEM                      1604\r\n#define IDC_WHILER                      1605\r\n\r\n#define IDC_FULLWIN                     2008\r\n#define IDC_SHOWCURSOR                  2009\r\n#define IDC_RESIZECENTER                2010\r\n#define IDC_RESIZEALL                   2011\r\n\r\n#define IDC_AGGRESSIVEPAUSE             2012\r\n#define IDC_PAUSEBL_HEADER              2013\r\n#define IDC_PAUSEBL                     2014\r\n#define IDC_MDISBL_HEADER               2015\r\n#define IDC_MDIS                        2016\r\n\r\n#define IDC_RZCENTER_NORM               2017\r\n#define IDC_RZCENTER_BR                 2018\r\n#define IDC_RZCENTER_MOVE               2019\r\n#define IDC_RZCENTER_CLOSE              2020\r\n\r\n#define IDC_AUTOREMAXIMIZE              2021\r\n#define IDC_AEROTOPMAXIMIZES            2022\r\n#define IDC_MULTIPLEINSTANCES           2023\r\n#define IDC_CENTERFRACTION              2024\r\n#define IDC_CENTERFRACTION_H            2025\r\n#define IDC_AEROHOFFSET                 2026\r\n#define IDC_AEROHOFFSET_H               2027\r\n#define IDC_AEROVOFFSET                 2028\r\n#define IDC_AEROVOFFSET_H               2029\r\n#define IDC_SNAPTHRESHOLD               2030\r\n#define IDC_SNAPTHRESHOLD_H             2031\r\n#define IDC_AEROTHRESHOLD               2032\r\n#define IDC_AEROTHRESHOLD_H             2033\r\n#define IDC_NORMRESTORE                 2034\r\n#define IDC_MAXWITHLCLICK               2035\r\n#define IDC_RESTOREONCLICK              2036\r\n#define IDC_TTBACTIONSWA                2037\r\n#define IDC_MMB_HC                      2038\r\n#define IDC_MB4_HC                      2039\r\n#define IDC_MB5_HC                      2040\r\n#define IDC_KEYBOARD_BOX                2041\r\n#define IDC_KEYCOMBO                    2042\r\n#define IDC_HOTCLICKS_MORE              2043\r\n#define IDC_GRABWITHALT                 2044\r\n#define IDC_GRABWITHALT_H               2045\r\n#define IDC_METRICS_BOX                 2046\r\n#define IDC_BEHAVIOR_BOX                2047\r\n#define IDC_MODKEY_H                    2048\r\n#define IDC_MODKEY                      2049\r\n#define IDC_AERODBCLICKSHIFT            2050\r\n#define IDC_FULLSCREEN                  2051\r\n#define IDC_AGGRESSIVEKILL              2052\r\n#define IDC_TESTWINDOW                  2053\r\n#define IDC_MOVETRANS_H                 2054\r\n#define IDC_MOVETRANS                   2055\r\n#define IDC_AEROSPEED_H                 2056\r\n#define IDC_AEROSPEED                   2057\r\n#define IDC_AEROSPEEDTAU                2058\r\n#define IDC_SMARTAERO                   2059\r\n#define IDC_STICKYRESIZE                2060\r\n#define IDC_NCHITTEST                   2061\r\n#define IDC_GWLSTYLE                    2062\r\n#define IDC_HSCROLL                     2063\r\n#define IDC_HSCROLL_HEADER              2064\r\n#define IDC_SCROLLLOCKSTATE             2065\r\n#define IDC_TITLEBARMOVE                2066\r\n#define IDC_GRABWITHALTB                2067\r\n#define IDC_GRABWITHALTB_H              2068\r\n#define IDC_RECT                        2069\r\n#define IDC_TTBACTIONS_BOX              2070\r\n#define IDC_PEARCEDBCLICK               2071\r\n\r\n#define IDC_USEZONES                    2072\r\n#define IDC_FANCYZONE                   2073\r\n#define IDC_GWLEXSTYLE                  2074\r\n#define IDC_SMARTERAERO                 2075\r\n#define IDC_NORESTORE                   2076\r\n#define IDC_LONGCLICKMOVE               2077\r\n#define IDC_BLMAXIMIZED                 2078\r\n#define IDC_PIERCINGCLICK               2079\r\n\r\n#define IDC_OUTTB                       2083\r\n#define IDC_UNIKEYHOLDMENU              2084\r\n#define IDC_DWMCAPBUTTON                2085\r\n#define IDC_WINHANDLES                  2086\r\n\r\n#define IDC_MOVEUP                      2087\r\n#define IDC_MOVEUP_HEADER               2088\r\n#define IDC_RESIZEUP                    2089\r\n#define IDC_RESIZEUP_HEADER             2090\r\n#define IDC_SNAPGAP                     2091\r\n#define IDC_SNAPGAP_H                   2092\r\n#define IDC_NPSTACKED                   2093\r\n#define IDC_TOPMOSTINDICATOR            2094\r\n\r\n#define IDC_SHORTCUTS                   2095\r\n#define IDC_SHORTCUTS_H                 2096\r\n#define IDC_SHORTCUTS_AC                2097\r\n#define IDC_SHORTCUTS_SET               2098\r\n#define IDC_SHORTCUTS_PICK              2099\r\n#define IDC_ALT                         2100\r\n#define IDC_WINKEY                      2101\r\n#define IDC_CONTROL                     2102\r\n#define IDC_SHIFT                       2103\r\n#define IDC_SHORTCUTS_VK                2104\r\n#define IDC_SHORTCUTS_CLEAR             2105\r\n#define IDC_USEPTWINDOW                 2106\r\n#define IDC_SIDESFRACTION               2107\r\n\r\n#endif // AS_RESOURCE_H\r\n"
        },
        {
          "name": "sch_Off.bat",
          "type": "blob",
          "size": 0.5048828125,
          "content": "@echo =============================================================================\r\n@echo = This batch will remove the AltSnap's Scheduled task!                      =\r\n@echo = If you do not want to continue, close the window or hit Ctrl+C            =\r\n@echo =============================================================================\r\n@echo Going to run command:\r\n@echo schtasks.exe /DELETE /TN \"AltSnap\" %1 %2 %3 %4 %5 %6 %7 %8 %9\r\n@pause\r\nschtasks.exe /DELETE /TN \"AltSnap\" %1 %2 %3 %4 %5 %6 %7 %8 %9\r\n@pause\r\n"
        },
        {
          "name": "sch_On.bat",
          "type": "blob",
          "size": 1.38671875,
          "content": "::schtasks /CREATE /XML .\\AltSnap.xml /TR \"%~dp0AltSnap.exe\"\r\n:: If you do not want to use the xml file you can use:\r\n:: schtasks.exe /CREATE /TN \"AltSnap\" /TR \"%~dp0AltSnap.exe\" /SC onlogon /RL highest /DELAY 0:10\r\n:: However AltSnap will be killed after 3 days by default.\r\n:: The only way not to have this autokill is to use an xml file.\r\n:: Make sure to adjust the path to the AltSnap executable in the AltSnap.xml file.\r\n@echo =======================================================================================================\r\n@echo = Setup Scheduled task for elevated AltSnap auto-start without UAC prompt                             =\r\n@echo = Make sure you are running this from an elevated shell                                               =\r\n@echo = Default AltSnap executable location is %%APPDATA%%\\AltSnap\\AltSnap.exe                                =\r\n@echo = Adjust the executable location in AltSnap.xml file if AltSnap is installed in a different location  =\r\n@echo = If you do not want to continue, close the window or hit Ctrl+C                                      =\r\n@echo =======================================================================================================\r\n@echo Going to run command:\r\n@echo schtasks.exe /CREATE /XML .\\AltSnap.xml /TN \"AltSnap\" %1 %2 %3 %4 %5 %6 %7 %8 %9\r\n@pause\r\nschtasks.exe /CREATE /XML .\\AltSnap.xml /TN \"AltSnap\" %1 %2 %3 %4 %5 %6 %7 %8 %9\r\n@pause\r\n"
        },
        {
          "name": "snap.c",
          "type": "blob",
          "size": 9.2158203125,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * (C) Raymond GILLIBERT                                                 *\r\n * Functions to handle Snap/restore informations AltSnap                 *\r\n * Snapping informations set with Set/GetProp.                          *\r\n * Window database is used as fallback.                                  *\r\n * General Public License Version 3 or later (Free Software Foundation)  *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#define SNAPPED  1\r\n#define ROLLED   2\r\n#define SNLEFT    (1<<2)\r\n#define SNRIGHT   (1<<3)\r\n#define SNTOP     (1<<4)\r\n#define SNBOTTOM  (1<<5)\r\n#define SNMAXH    (1<<6)\r\n#define SNMAXW    (1<<7)\r\n#define SNCLEAR   (1<<8) // to clear the flag at init movement.\r\n#define TORESIZE  (1<<9)\r\n#define SNTHENROLLED (1<<10)\r\n#define SNZONE    (1<<11)\r\n#define SNMIN     (1<<12)\r\n#define SNTOPLEFT     (SNTOP|SNLEFT)\r\n#define SNTOPRIGHT    (SNTOP|SNRIGHT)\r\n#define SNBOTTOMLEFT  (SNBOTTOM|SNLEFT)\r\n#define SNBOTTOMRIGHT (SNBOTTOM|SNRIGHT)\r\n#define SNAPPEDSIDE   (SNTOPLEFT|SNBOTTOMRIGHT)\r\n\r\n#define PureLeft(flag)   ( (flag&SNLEFT) &&  !(flag&(SNTOP|SNBOTTOM))  )\r\n#define PureRight(flag)  ( (flag&SNRIGHT) && !(flag&(SNTOP|SNBOTTOM))  )\r\n#define PureTop(flag)    ( (flag&SNTOP) && !(flag&(SNLEFT|SNRIGHT))    )\r\n#define PureBottom(flag) ( (flag&SNBOTTOM) && !(flag&(SNLEFT|SNRIGHT)) )\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#define NUMWNDDB 16\r\nstruct wnddata {\r\n    unsigned restore;\r\n    HWND hwnd;\r\n    int width;\r\n    int height;\r\n//    int rolledh;\r\n//    UINT odpi\r\n};\r\nstatic struct wnddata wnddb[NUMWNDDB];\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Database functions: used as fallback if SetProp fails\r\n\r\n// Zero-out the database to be called in Load()\r\nstatic void ResetDB()\r\n{\r\n    int i;\r\n    for (i=0; i < NUMWNDDB; i++) {\r\n        wnddb[i].hwnd = NULL;\r\n        wnddb[i].restore = 0;\r\n    }\r\n}\r\n// Return the entry if it was already in db. Or NULL otherwise\r\nstatic pure int GetWindowInDB(HWND hwndd)\r\n{\r\n    // Check if window is already in the wnddb database\r\n    // And set it in the current state\r\n    unsigned i;\r\n    for (i=0; i < NUMWNDDB; i++) {\r\n        if (wnddb[i].hwnd == hwndd) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nstatic void AddWindowToDB(HWND hwndd, int width, int height, unsigned flag)\r\n{\r\n    int idx = GetWindowInDB(hwndd);\r\n\r\n    // Find a nice place in wnddb if not already present\r\n    if (idx < 0) {\r\n        int i;\r\n        for (i=0; i < NUMWNDDB && wnddb[i].hwnd; i++);\r\n        if (i >= NUMWNDDB) return;\r\n        idx = i;\r\n    }\r\n    wnddb[idx].hwnd = hwndd;\r\n    wnddb[idx].width = width;\r\n    wnddb[idx].height = height;\r\n    wnddb[idx].restore = flag;\r\n}\r\nstatic void DelWindowFromDB(HWND hwnd)\r\n{\r\n    unsigned i;\r\n    for (i=0; i < NUMWNDDB; i++) {\r\n        if (wnddb[i].hwnd == hwnd) {\r\n            wnddb[i].hwnd = NULL;\r\n            wnddb[i].restore = 0;\r\n        }\r\n    }\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Windows restore data are saved in properties\r\n// In 32b mode width and height are shrunk to 16b WORDS\r\n// In 64b mode width and height are stored on 32b DWORDS\r\n// I 64b mode we also check for FancyZone info that are stored the same way!\r\n// There is a lot of cast because of annoying warnings...\r\n// There is also a fallback to a database for some spetial windows.\r\nstatic unsigned GetRestoreData(HWND hwnd, int *width, int *height)\r\n{\r\n    DorQWORD WH = (DorQWORD)GetProp(hwnd, APP_PROPPT);\r\n    if (WH) {\r\n        *width  = (int)LOWORDPTR(WH);\r\n        *height = (int)HIWORDPTR(WH);\r\n        UINT dpi = GetDpiForWindow(hwnd);\r\n        UINT odpi;\r\n        if (dpi && (odpi = (UINT)(DorQWORD)GetProp(hwnd, APP_PRODPI)) && odpi != dpi) {\r\n            // The current dpi is different for the window, We must scale the content.\r\n            *width  = MulDiv(*width,  dpi, odpi);\r\n            *height = MulDiv(*height, dpi, odpi);\r\n        }\r\n        return (unsigned)(DorQWORD)GetProp(hwnd, APP_PROPFL);;\r\n\r\n  # ifdef WIN64 // Try fancy zone flag only in 64bit mode!\r\n    } else if (conf.FancyZone && (WH = (DorQWORD)GetProp(hwnd, FZ_PROPPT))) {\r\n        // It seems FancyZones stores size info in points, not pixels.\r\n        *width  = (int)LOWORDPTR(WH);\r\n        *height = (int)HIWORDPTR(WH);\r\n        if (conf.FancyZone != 2) {\r\n            int dpi = GetDpiForWindow(hwnd);\r\n            if (dpi) {\r\n                // Scale bcak to current dpi from 96\r\n                *width  = MulDiv(*width,  dpi, 96);\r\n                *height = MulDiv(*height, dpi, 96);\r\n            }\r\n        }\r\n        return SNAPPED|SNZONE;\r\n  # endif\r\n    } else { // fallback to database\r\n        int idx = GetWindowInDB(hwnd);\r\n        if (idx >= 0) {\r\n            *width = wnddb[idx].width;\r\n            *height = wnddb[idx].height;\r\n            return wnddb[idx].restore;\r\n        }\r\n    }\r\n    // Unable to find the window in the db\r\n    *width = *height = 0;\r\n    return 0;\r\n}\r\nstatic void ClearRestoreData(HWND hwnd)\r\n{\r\n    RemoveProp(hwnd, APP_PROPPT);\r\n    RemoveProp(hwnd, APP_PROPFL);\r\n    // RemoveProp(hwnd, APP_PROPOFFSET);\r\n  # ifdef WIN64\r\n    if(conf.FancyZone) {\r\n        RemoveProp(hwnd, FZ_PROPPT);\r\n        RemoveProp(hwnd, FZ_PROPZONES);\r\n    }\r\n  # endif\r\n    DelWindowFromDB(hwnd);\r\n}\r\n// Sets width, height and restore flag in a hwnd\r\nstatic void SetRestoreData(HWND hwnd, int width, int height, unsigned restore)\r\n{\r\n    BOOL ret;\r\n    ret  = SetProp(hwnd, APP_PROPFL, (HANDLE)(DorQWORD)restore);\r\n    ret &= SetProp(hwnd, APP_PROPPT, (HANDLE)MAKELONGPTR(width, height));\r\n    UINT dpi=0;\r\n    if ( (dpi = GetDpiForWindow(hwnd)) )\r\n        ret &= SetProp(hwnd, APP_PRODPI, (HANDLE)(DorQWORD)dpi);\r\n\r\n    if (!ret) AddWindowToDB(hwnd, width, height, restore);\r\n}\r\n\r\nstatic unsigned GetRestoreFlag(HWND hwnd)\r\n{\r\n    unsigned flag = (DorQWORD)GetProp(hwnd, APP_PROPFL);\r\n\r\n  # ifdef WIN64\r\n    if(conf.FancyZone && GetProp(hwnd, FZ_PROPPT))\r\n        flag |= SNAPPED|SNZONE;\r\n  # endif\r\n\r\n    int idx; // fallback to db.\r\n    if (!flag && ((idx = GetWindowInDB(hwnd)) >=0)) {\r\n        return wnddb[idx].restore;\r\n    }\r\n    return flag;\r\n}\r\nstatic void SetRestoreFlag(HWND hwnd, unsigned flag)\r\n{\r\n    BOOL ret = SetProp(hwnd, APP_PROPFL, (HANDLE)(DorQWORD)flag);\r\n    int idx;\r\n    if (!ret && ((idx = GetWindowInDB(hwnd)) >=0)) {\r\n        wnddb[idx].restore = flag;\r\n    }\r\n}\r\n\r\nstatic int IsAnySnapped(HWND hwnd)\r\n{\r\n    // Any kind of snapping, including maximization.\r\n    // In short whenever the window will be restored.\r\n    unsigned flg;\r\n    return  IsZoomed(hwnd)\r\n        ||( !(conf.SmartAero&4) && SNAPPED & (flg=GetRestoreFlag(hwnd)) && !(flg&SNCLEAR) )\r\n        ||  IsWindowSnapped(hwnd);\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\n// borderless flag (saving old GWL_STYLE)\r\nstatic void SetBorderlessFlag(HWND hwnd, LONG_PTR flag)\r\n{\r\n    SetProp(hwnd, APP_PRBDLESS,(HANDLE)flag);\r\n}\r\nstatic LONG_PTR GetBorderlessFlag(HWND hwnd)\r\n{\r\n    return (LONG_PTR)GetProp(hwnd, APP_PRBDLESS);\r\n}\r\nstatic LONG_PTR ClearBorderlessFlag(HWND hwnd)\r\n{\r\n    return (LONG_PTR)RemoveProp(hwnd, APP_PRBDLESS);\r\n}\r\n\r\nstatic void SetSquareCorners(HWND hwnd)\r\n{\r\n    int cornerPref = DWMWCP_DEFAULT;\r\n    HRESULT ok = DwmGetWindowAttributeL(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &cornerPref, sizeof(cornerPref));\r\n    if (ok) {\r\n        SetProp(hwnd, APP_OWDMCP, (HANDLE)(UINT_PTR)(cornerPref+1)); // Do not store Zero.\r\n        cornerPref = DWMWCP_DONOTROUND;\r\n        DwmSetWindowAttributeL(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &cornerPref, sizeof(cornerPref));\r\n    }\r\n}\r\nstatic void RestoreOldCorners(HWND hwnd)\r\n{\r\n    int cp = (int)(UINT_PTR)GetProp(hwnd, APP_OWDMCP);\r\n    RemoveProp(hwnd, APP_OWDMCP);\r\n    if (cp) {\r\n        cp--;\r\n        DwmSetWindowAttributeL(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &cp, sizeof(cp));\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//// Roll unroll stuff\r\n//static int GetRolledHeight(HWND hwnd)\r\n//{\r\n//    int ret = (int)GetProp(hwnd, APP_ROLLED);\r\n//    int idx;\r\n//    if (!ret && ((idx = GetWindowInDB(hwnd)) >=0)) {\r\n//        ret = wnddb[idx].rolledh;\r\n//    }\r\n//    return ret;\r\n//}\r\n//static int ClearRolledHeight(HWND hwnd)\r\n//{\r\n//    int ret = (int)RemoveProp(hwnd, APP_ROLLED);\r\n//\r\n//    int idx;\r\n//    if (!ret && ((idx = GetWindowInDB(hwnd)) >=0)) {\r\n//        ret = wnddb[idx].rolledh;\r\n//        wnddb[idx].rolledh = 0;\r\n//    }\r\n//    return ret;\r\n//}\r\n//static void SetRolledHeight(HWND hwnd, int rolledh)\r\n//{\r\n//    BOOL ret = SetProp(hwnd, APP_ROLLED, (HANDLE)(DorQWORD)rolledh);\r\n//    if (ret) return;\r\n//\r\n//    int idx;\r\n//    if (((idx = GetWindowInDB(hwnd)) >=0)) {\r\n//        wnddb[idx].rolledh = rolledh;\r\n//    } else {\r\n//        int i;\r\n//        for (i=0; i < NUMWNDDB && wnddb[i].hwnd; i++);\r\n//        if (i >= NUMWNDDB) return;\r\n//        idx = i;\r\n//        wnddb[idx].hwnd = hwnd;\r\n//        wnddb[idx].rolledh = rolledh;\r\n//        wnddb[idx].restore = 0;\r\n//    }\r\n//\r\n//}\r\n//static void AddToFlag(HWND hwnd, unsigned flag)\r\n//{\r\n//    SetRestoreFlag(hwnd, flag|GetRestoreFlag(hwnd));\r\n//}\r\n//\r\n//static void RemoveToFlag(HWND hwnd, unsigned flag)\r\n//{\r\n//    SetRestoreFlag(hwnd, flag & (~GetRestoreFlag(hwnd)));\r\n//}\r\n"
        },
        {
          "name": "tray.c",
          "type": "blob",
          "size": 10.9072265625,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Copyright (C) 2015    Stefan Sundin                                   *\r\n * This program is free software: you can redistribute it and/or modify  *\r\n * it under the terms of the GNU General Public License as published by  *\r\n * the Free Software Foundation, either version 3 or later.              *\r\n * Modified By Raymond Gillibert in 2020                                 *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#ifndef NIF_INFO\r\n#define NIF_INFO 0x00000010\r\n#endif\r\n\r\nstatic struct { // NOTIFYICONDATA for NT4\r\n    DWORD cbSize;\r\n    HWND hWnd;\r\n    UINT uID;\r\n    UINT uFlags;\r\n    UINT uCallbackMessage;\r\n    HICON hIcon;\r\n    TCHAR szTip[64];\r\n} tray;\r\n\r\nstatic int tray_added = 0;\r\nstatic int hide = 0;\r\nstatic int UseZones = 0;\r\nstatic int LayoutNumber=0;\r\nstatic int MaxLayouts=0;\r\n\r\nstatic const TCHAR *iconstr[] = {\r\n    TEXT(\"TRAY_OFF\"),\r\n    TEXT(\"TRAY_ON\"),\r\n    TEXT(\"TRAY_SUS\")\r\n};\r\nstatic const TCHAR *traystr[] = {\r\n    TEXT(APP_NAMEA)TEXT(\" (Off)\"),\r\n    TEXT(APP_NAMEA)TEXT(\" (On)\"),\r\n    TEXT(APP_NAMEA)TEXT(\"...\"),\r\n};\r\nstatic HICON icons[3];\r\n\r\nstatic void LoadAllIcons()\r\n{\r\n    TCHAR theme[MAX_PATH]; // Get theme name\r\n    int ret = GetPrivateProfileString(TEXT(\"General\"), TEXT(\"Theme\"), TEXT(\"\"), theme, ARR_SZ(theme), inipath);\r\n    if (ret && theme[1]) {\r\n        TCHAR path[MAX_PATH];\r\n        DWORD mod = GetModuleFileName(NULL, path, ARR_SZ(path));\r\n        if (mod) {\r\n            PathRemoveFileSpecL(path);\r\n            lstrcat_s(path, ARR_SZ(path), TEXT(\"\\\\Themes\\\\\")); // Themes subfolder\r\n            lstrcat_s(path, ARR_SZ(path), theme); // Theme name\r\n            int len = lstrlen(path);\r\n            TCHAR *p = path+len;\r\n            *p++ = TEXT('\\\\');\r\n            if (len < MAX_PATH-13) { // strlen(\"TRAY_OFF.ICO\")==12\r\n                UCHAR i;\r\n                for(i=0; i<3; i++) {\r\n                    lstrcpy_s(p, ARR_SZ(path)-len, iconstr[i]);\r\n                    lstrcat_s(path, ARR_SZ(path), TEXT(\".ico\"));\r\n                    HICON tmp = (HICON)LoadImage(g_hinst, path, IMAGE_ICON,0,0, LR_LOADFROMFILE|LR_DEFAULTSIZE|LR_LOADTRANSPARENT);\r\n                    icons[i] = tmp? tmp: LoadIcon(g_hinst, MAKEINTRESOURCE( TRAY_OFF+i ));\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // Fallback to internal icons.\r\n    UCHAR i;\r\n    for (i=0; i<3; i++)\r\n        icons[i] = LoadIcon(g_hinst, MAKEINTRESOURCE( TRAY_OFF+i ));\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int InitTray()\r\n{\r\n    ScrollLockState = GetPrivateProfileInt(TEXT(\"Input\"), TEXT(\"ScrollLockState\"), 0, inipath);\r\n    LayoutNumber    = GetPrivateProfileInt(TEXT(\"Zones\"), TEXT(\"LayoutNumber\"), 0, inipath);\r\n    MaxLayouts      = GetPrivateProfileInt(TEXT(\"Zones\"), TEXT(\"MaxLayouts\"), 0, inipath);\r\n    MaxLayouts = CLAMP(0, MaxLayouts, 10);\r\n    LayoutNumber = CLAMP(0, LayoutNumber, max(0,MaxLayouts-1));\r\n\r\n    LoadAllIcons();\r\n\r\n    // Create icondata\r\n    tray.cbSize = sizeof(tray);\r\n    tray.hWnd = g_hwnd;\r\n    tray.uID = 0;\r\n    tray.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;\r\n    tray.uCallbackMessage = WM_TRAY;\r\n\r\n    // Register TaskbarCreated so we can re-add the tray icon if (when) explorer.exe crashes\r\n    WM_TASKBARCREATED = RegisterWindowMessage(TEXT(\"TaskbarCreated\"));\r\n    LOG(\"Register TaskbarCreated message: %X\", WM_TASKBARCREATED);\r\n\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int UpdateTray()\r\n{\r\n    int Index = !!ENABLED();\r\n    if (Index) {\r\n        Index += (ScrollLockState&1)\r\n               && !( !(GetKeyState(VK_SCROLL)&1) ^ !(ScrollLockState&2) );\r\n        if (GetProp(g_hwnd, APP_ASONOFF))\r\n            Index=2;\r\n    }\r\n    // Load info tool tip and tray icon\r\n    lstrcpy_s(tray.szTip, ARR_SZ(tray.szTip), traystr[Index]);\r\n    tray.hIcon = icons[Index];\r\n\r\n    // Only add or modify if not hidden or if balloon will be displayed\r\n    if (!hide || tray.uFlags&NIF_INFO) {\r\n        // Try a few times, sleep 100 ms between each attempt\r\n        int i=1;\r\n        LOG(\"Updating tray icon\");\r\n        while (!Shell_NotifyIcon(tray_added? NIM_MODIFY: NIM_ADD, (PNOTIFYICONDATA)&tray) ) {\r\n            LOG(\"Failed in try No. %d\", i);\r\n\r\n            // Maybe we just tried to add an already existing tray.\r\n            // Happens after DPI change under Win 10 (TaskbarCreated) msg.\r\n            if (!tray_added && Shell_NotifyIcon(NIM_MODIFY, (PNOTIFYICONDATA)&tray)) {\r\n                LOG(\"Updated tray icon\");\r\n                tray_added = 1;\r\n                return 0;\r\n            }\r\n\r\n            if (i > 2) {\r\n                LOG(\"Failed all atempts!!\");\r\n                return 1;\r\n            }\r\n            Sleep(100);\r\n            i++;\r\n        }\r\n        LOG(\"Sucess at try %d\", i);\r\n        // Success\r\n        tray_added = 1;\r\n    }\r\n    return 0;\r\n}\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic int RemoveTray()\r\n{\r\n    if (!tray_added)\r\n        return 1;\r\n\r\n    if (!Shell_NotifyIcon(NIM_DELETE, (PNOTIFYICONDATA)&tray))\r\n        return 1;\r\n\r\n    // Success\r\n    tray_added = 0;\r\n    return 0;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Zones functions\r\nstatic void WriteCurrentLayoutNumber()\r\n{\r\n    if (MaxLayouts) {\r\n        TCHAR txt[UINT_DIGITS+1];\r\n        WritePrivateProfileString(TEXT(\"Zones\"), TEXT(\"LayoutNumber\"), Uint2lStr(txt, LayoutNumber), inipath);\r\n    }\r\n}\r\nstatic TCHAR *RectToStr(const RECT *rc, TCHAR rectstr[AT_LEAST INT_DIGITS*4+4+1])\r\n{\r\n    TCHAR txt[INT_DIGITS+1];\r\n    int i;\r\n    const long *RC = (const long *)rc;\r\n    rectstr[0] = '\\0';\r\n    for(i = 0; i < 4; i++) {\r\n        lstrcat_s(rectstr, 64, Int2lStr(txt, (int)RC[i]));\r\n        lstrcat_s(rectstr, 64, TEXT(\",\"));\r\n    }\r\n    return rectstr;\r\n}\r\n// Save a rect as a string in a Zone<num> entry in the inifile\r\nstatic void SaveZone(const RECT *rc, unsigned num)\r\n{\r\n    TCHAR txt[64], name[32];\r\n    WritePrivateProfileString(TEXT(\"Zones\"), ZidxToZonestr(LayoutNumber, num, name), RectToStr(rc, txt), inipath);\r\n}\r\nstatic void ClearAllZones()\r\n{\r\n    int i;\r\n    TCHAR txt[128], name[32];\r\n    for (i = 0; i < 2048; i++) {\r\n        ZidxToZonestr(LayoutNumber, i, name);\r\n        if (GetPrivateProfileString(TEXT(\"Zones\"), name, TEXT(\"\"), txt, ARR_SZ(txt), inipath)) {\r\n            WritePrivateProfileString(TEXT(\"Zones\"), name, TEXT(\"\"), inipath);\r\n        }\r\n    }\r\n}\r\n// Call with lParam = 1 to reset NZones\r\nBOOL CALLBACK SaveTestWindow(HWND hwnd, LPARAM lParam)\r\n{\r\n    static unsigned NZones;\r\n    if (lParam) { // Reset number of Zones\r\n        NZones = 0;\r\n        return FALSE;\r\n    }\r\n\r\n    TCHAR classn[256];\r\n    RECT rc;\r\n    if (IsWindowVisible(hwnd)\r\n    && GetClassName(hwnd, classn, ARR_SZ(classn))\r\n    && !lstrcmp(classn, TEXT(APP_NAMEA) TEXT(\"-Test\"))\r\n    && GetWindowRectL(hwnd, &rc)) {\r\n        SaveZone(&rc, NZones++);\r\n        PostMessage(hwnd, WM_CLOSE, 0, 0);\r\n    }\r\n    return TRUE;\r\n}\r\n\r\nstatic void SaveCurrentLayout()\r\n{\r\n    ClearAllZones();\r\n    SaveTestWindow(NULL, 1);\r\n    EnumThreadWindows(GetCurrentThreadId(), SaveTestWindow, 0);\r\n}\r\n\r\nBOOL CALLBACK CloseTestWindowCB(HWND hwnd, LPARAM lParam)\r\n{\r\n    TCHAR classn[256];\r\n    if (GetClassName(hwnd, classn, ARR_SZ(classn))\r\n    && !lstrcmp(classn, TEXT(APP_NAMEA) TEXT(\"-Test\")) ) {\r\n        PostMessage(hwnd, WM_CLOSE, 0, 0);\r\n    }\r\n    return TRUE;\r\n}\r\n\r\nstatic void CloseAllTestWindows()\r\n{\r\n    EnumThreadWindows(GetCurrentThreadId(), CloseTestWindowCB, 0);\r\n}\r\n\r\nstatic void catFullLayoutName(TCHAR *txt, size_t len, int laynum)\r\n{\r\n    TCHAR n1[UINT_DIGITS+1];\r\n    lstrcat_s(txt, len, l10n->menu_snaplayout);\r\n    lstrcat_s(txt, len, Uint2lStr(n1, laynum+1));\r\n    if (g_dllmsgHKhwnd) {\r\n        DWORD rez =0;\r\n        if ((rez = SendMessage(g_dllmsgHKhwnd, WM_GETLAYOUTREZ, laynum, 0))) {\r\n            // TCHAR n2[UINT_DIGITS+1];\r\n            // Add (width:height) to label the layout.\r\n            // lstrcatM_s(txt, len ,TEXT(\"  (\"), Uint2lStr(n1, LOWORD(rez)),TEXT(\":\"),Uint2lStr(n2, HIWORD(rez)), TEXT(\")\"), NULL);\r\n            lstrcat_s(txt, len, TEXT(\"  (\"));\r\n            lstrcat_s(txt, len, Uint2lStr(n1, LOWORD(rez)));\r\n            lstrcat_s(txt, len, TEXT(\":\"));\r\n            lstrcat_s(txt, len, Uint2lStr(n1, HIWORD(rez)));\r\n            lstrcat_s(txt, len, TEXT(\")\"));\r\n        } else {\r\n            lstrcat_s(txt, len, TEXT(\"  \"));\r\n            lstrcat_s(txt, len, l10n->menu_emptyzone); // (empty)\r\n        }\r\n    } else {\r\n        lstrcat_s(txt, len, TEXT(\"  (...)\"));\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nstatic void ShowContextMenu(HWND hwnd)\r\n{\r\n    POINT pt;\r\n    GetCursorPos(&pt);\r\n    HMENU menu = CreatePopupMenu();\r\n\r\n    AppendMenu(menu, MF_STRING, SWM_TOGGLE, (ENABLED()?l10n->menu_disable:l10n->menu_enable));\r\n    AppendMenu(menu, MF_STRING, SWM_HIDE, l10n->menu_hide);\r\n    if(VISTA)\r\n        InsertMenu(menu, -1, elevated?MF_BYPOSITION|MF_GRAYED:MF_BYPOSITION\r\n                 , SWM_ELEVATE, (elevated? l10n->general_elevated: l10n->general_elevate));\r\n\r\n    AppendMenu(menu, MF_SEPARATOR, 0, NULL);\r\n    AppendMenu(menu, MF_STRING, SWM_CONFIG, l10n->menu_config);\r\n    AppendMenu(menu, MF_STRING, SWM_ABOUT, l10n->menu_about);\r\n    AppendMenu(menu, MF_STRING, SWM_OPENINIFILE, l10n->menu_openinifile);\r\n\r\n    if (UseZones&1) { // Zones section\r\n        if(MaxLayouts)\r\n            AppendMenu(menu, MF_SEPARATOR, 0, NULL);\r\n        int i;\r\n        TCHAR txt[128];\r\n        for (i=0; i < MaxLayouts; i++) {\r\n            txt[0] = '\\0';\r\n            catFullLayoutName(txt, ARR_SZ(txt), i);\r\n            // Check the current layout We use a simple checkmark,\r\n            // because a radio button is more complex to setup.\r\n            UINT mfflags = i==LayoutNumber? MF_STRING|MF_CHECKED: MF_STRING|MF_UNCHECKED;\r\n            AppendMenu(menu, mfflags, SWM_SNAPLAYOUT+i, txt);\r\n        }\r\n\r\n        if (!(UseZones&2)) {\r\n            TCHAR numstr[INT_DIGITS+1];\r\n            lstrcpy_s(txt, ARR_SZ(txt), l10n->menu_editlayout);\r\n            lstrcat_s(txt, ARR_SZ(txt), TEXT(\" \"));\r\n            lstrcat_s(txt, ARR_SZ(txt), Int2lStr(numstr, LayoutNumber+1));\r\n            AppendMenu(menu, MF_SEPARATOR, 0, NULL);\r\n            AppendMenu(menu, MF_STRING, SWM_TESTWIN,  l10n->advanced_testwindow);\r\n            AppendMenu(menu, MF_STRING, SWM_EDITLAYOUT, txt);\r\n            AppendMenu(menu, FindWindow(TEXT(APP_NAMEA)TEXT(\"-test\"), NULL)? MF_STRING :MF_STRING|MF_GRAYED\r\n                      , SWM_SAVEZONES, l10n->menu_savezones);\r\n\r\n            AppendMenu(menu, FindWindow(TEXT(APP_NAMEA)TEXT(\"-test\"), NULL)? MF_STRING :MF_STRING|MF_GRAYED\r\n                      , SWM_CLOSEZONES, l10n->menu_closeallzones);\r\n        }\r\n    }\r\n\r\n    AppendMenu(menu, MF_SEPARATOR, 0, NULL);\r\n    AppendMenu(menu, MF_STRING, SWM_EXIT, l10n->menu_exit);\r\n\r\n    // Track menu\r\n    SetForegroundWindow(hwnd);\r\n    TrackPopupMenu(menu, TPM_BOTTOMALIGN, pt.x, pt.y, 0, hwnd, NULL);\r\n    DestroyMenu(menu);\r\n}\r\n"
        },
        {
          "name": "unfuck.h",
          "type": "blob",
          "size": 51.2578125,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * Compatibility layer for old NT OSes                                   *\r\n * Written by Raymond Gillibert in 2021                                  *\r\n * THIS FILE IS NOT UNDER GPL but under the WTFPL.                       *\r\n * DO WHAT THE FUCK YOU WANT WITH THIS CODE!                             *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#ifndef _UNFUCK_NT_\r\n#define _UNFUCK_NT_\r\n\r\n#include <windows.h>\r\n#include <oleacc.h>\r\n#include <stdio.h>\r\n#include \"nanolibc.h\"\r\n\r\n/* #include <dwmapi.h> */\r\nenum DWMWINDOWATTRIBUTE {\r\n  /* Windows Vista+ */\r\n  DWMWA_NCRENDERING_ENABLED=1,\r\n  DWMWA_NCRENDERING_POLICY,\r\n  DWMWA_TRANSITIONS_FORCEDISABLED,\r\n  DWMWA_ALLOW_NCPAINT,\r\n  DWMWA_CAPTION_BUTTON_BOUNDS,\r\n  DWMWA_NONCLIENT_RTL_LAYOUT,\r\n  DWMWA_FORCE_ICONIC_REPRESENTATION,\r\n  DWMWA_FLIP3D_POLICY,\r\n  DWMWA_EXTENDED_FRAME_BOUNDS,\r\n  DWMWA_HAS_ICONIC_BITMAP,\r\n  /* Windows 7+ */\r\n  DWMWA_DISALLOW_PEEK,\r\n  DWMWA_EXCLUDED_FROM_PEEK,\r\n  DWMWA_CLOAK,\r\n  /* Windows 8+ */\r\n  DWMWA_CLOAKED, /* 14 */\r\n  DWMWA_FREEZE_REPRESENTATION,\r\n  DWMWA_PASSIVE_UPDATE_MODE,\r\n  DWMWA_USE_HOSTBACKDROPBRUSH,              /* Set, *pvAttribute=BOOL */\r\n\r\n  /* Windows 10 1809 + (17763 <= build < 18985), Undocumented */\r\n  DWMWA_USE_IMMERSIVE_DARK_MODE_PRE20H1=19, /* Set, *pvAttribute=BOOL */\r\n  /* Windows 10 21H1 + (build >= 18985) */\r\n  DWMWA_USE_IMMERSIVE_DARK_MODE = 20,  /* Documented value since Win 11 build 22000 */\r\n\r\n  /* Windows 11 Build 22000 + */\r\n  DWMWA_WINDOW_CORNER_PREFERENCE = 33,\r\n  DWMWA_BORDER_COLOR,\r\n  DWMWA_CAPTION_COLOR,\r\n  DWMWA_TEXT_COLOR,\r\n  DWMWA_VISIBLE_FRAME_BORDER_THICKNESS,\r\n  /* Windows 11 Build 22621 + */\r\n  DWMWA_SYSTEMBACKDROP_TYPE,\r\n  DWMWA_LAST,\r\n};\r\n\r\nenum DWM_WINDOW_CORNER_PREFERENCE {\r\n    DWMWCP_DEFAULT = 0,\r\n    DWMWCP_DONOTROUND = 1,\r\n    DWMWCP_ROUND = 2,\r\n    DWMWCP_ROUNDSMALL = 3,\r\n};\r\n\r\nenum MONITOR_DPI_TYPE {\r\n  MDT_EFFECTIVE_DPI = 0,\r\n  MDT_ANGULAR_DPI = 1,\r\n  MDT_RAW_DPI = 2,\r\n  MDT_DEFAULT = MDT_EFFECTIVE_DPI\r\n};\r\n\r\n/* Invalid pointer with which we initialize\r\n * all dynamically imported functions */\r\n#define IPTR ((FARPROC)(1))\r\n\r\n#define QWORD unsigned long long\r\n#ifdef WIN64\r\n    #define CopyRect(x, y) (*(x) = *(y))\r\n    #define DorQWORD QWORD\r\n    #define HIWORDPTR(ll)   ((DWORD) (((QWORD) (ll) >> 32) & 0xFFFFFFFF))\r\n    #define LOWORDPTR(ll)   ((DWORD) (ll))\r\n    #define MAKELONGPTR(lo, hi) ((QWORD) (((DWORD) (lo)) | ((QWORD) ((DWORD) (hi))) << 32))\r\n#else\r\n    #define DorQWORD unsigned long\r\n    #define HIWORDPTR(l)   ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))\r\n    #define LOWORDPTR(l)   ((WORD) (l))\r\n    #define MAKELONGPTR(lo, hi) ((DWORD) (((WORD) (lo)) | ((DWORD) ((WORD) (hi))) << 16))\r\n#endif\r\n#ifndef LOBYTE\r\n#define LOBYTE(w) ((BYTE)(w))\r\n#endif\r\n\r\n#ifndef HIBYTE\r\n#define HIBYTE(w) ( (BYTE)(((WORD) (w) >> 8) & 0xFF) )\r\n#endif\r\n\r\n#ifndef GET_X_LPARAM\r\n#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))\r\n#endif\r\n\r\n\r\n#define ARR_SZ(x) (sizeof(x) / sizeof((x)[0]))\r\n#define IDAPPLY 0x3021\r\n\r\n#ifndef IS_SURROGATE_PAIR\r\n#define IS_HIGH_SURROGATE(wch) (((wch) >= 0xd800) && ((wch) <= 0xdbff))\r\n#define IS_LOW_SURROGATE(wch) (((wch) >= 0xdc00) && ((wch) <= 0xdfff))\r\n#define IS_SURROGATE_PAIR(hs, ls) (IS_HIGH_SURROGATE (hs) && IS_LOW_SURROGATE (ls))\r\n#endif\r\n\r\n#ifndef NIIF_USER\r\n#define NIIF_USER 0x00000004\r\n#endif\r\n\r\n#ifndef INVALID_FILE_ATTRIBUTES\r\n#define INVALID_FILE_ATTRIBUTES 0xFFFFFFFF\r\n#endif\r\n\r\n#ifndef STACK_SIZE_PARAM_IS_A_RESERVATION\r\n#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x10000L\r\n#endif\r\n\r\n#ifndef WPF_ASYNCWINDOWPLACEMENT\r\n#define WPF_ASYNCWINDOWPLACEMENT 0x0004\r\n#endif\r\n#ifndef WM_DPICHANGED\r\n#define WM_DPICHANGED 0x02E0\r\n#endif\r\n\r\n#if defined(_MSC_VER) && _MSC_VER <= 1200\r\n#define InterlockedIncrement(x) InterlockedIncrement((LONG*)(x))\r\n#define InterlockedDecrement(x) InterlockedDecrement((LONG*)(x))\r\n#endif\r\n\r\n#ifndef SCANCODE_SIMULATED\r\n#define SCANCODE_SIMULATED 0x0200\r\n#endif\r\n\r\n#ifndef EVENT_SYSTEM_MOVESIZESTART\r\n#define EVENT_SYSTEM_MOVESIZESTART 0x000A\r\n#define EVENT_SYSTEM_MOVESIZEEND 0x000B\r\n#endif\r\n\r\n#ifndef MSAA_MENU_SIG\r\n#define MSAA_MENU_SIG 0xAA0DF00D\r\ntypedef struct tagMSAAMENUINFO {\r\n  DWORD dwMSAASignature;\r\n  DWORD cchWText;\r\n  LPWSTR pszWText;\r\n} MSAAMENUINFO,*LPMSAAMENUINFO;\r\n#endif\r\n\r\n#ifndef GetWindowLongPtr\r\n    #define GetWindowLongPtr GetWindowLong\r\n    #define SetWindowLongPtr SetWindowLong\r\n    #define GetClassLongPtr GetClassLong\r\n    #define SetClassLongPtr SetClassLong\r\n    #define GWLP_WNDPROC (-4)\r\n    #define GWLP_HINSTANCE (-6)\r\n    #define GWLP_HWNDPARENT (-8)\r\n    #define GWLP_USERDATA (-21)\r\n    #define GWLP_ID (-12)\r\n#endif\r\n\r\n#ifndef PROCESS_SUSPEND_RESUME\r\n#define PROCESS_SUSPEND_RESUME (0x0800)\r\n#endif\r\n\r\n#ifndef WS_EX_LAYERED\r\n    #define WS_EX_LAYERED 0x00080000\r\n    #define WS_EX_NOACTIVATE 0x08000000\r\n    #define LWA_COLORKEY 0x00000001\r\n    #define LWA_ALPHA 0x00000002\r\n#endif\r\n\r\n#ifndef WM_XBUTTONDOWN\r\n    #define GET_WHEEL_DELTA_WPARAM(wParam) ((short)HIWORD(wParam))\r\n    #define WM_XBUTTONDOWN 0x020B\r\n    #define WM_XBUTTONUP 0x020C\r\n    #define WM_XBUTTONDBLCLK 0x020D\r\n    #define WM_MOUSEHWHEEL 0x020e\r\n    #define VK_XBUTTON1 0x05\r\n    #define VK_XBUTTON2 0x06\r\n    #define VK_VOLUME_MUTE 0xAD\r\n    #define VK_VOLUME_DOWN 0xAE\r\n    #define VK_VOLUME_UP 0xAF\r\n    #define MOUSEEVENTF_XDOWN 0x0080\r\n    #define MOUSEEVENTF_XUP 0x0100\r\n    #define KEYEVENTF_UNICODE 0x0004\r\n    #define KEYEVENTF_SCANCODE 0x0008\r\n#endif\r\n\r\n#ifndef GCLP_HCURSOR\r\n    #define GCLP_HCURSOR (-12)\r\n    #define GCLP_HICON (-14)\r\n#endif\r\n\r\n//#define LOGA(X, ...) {DWORD err=GetLastError(); FILE *LOG=fopen(\"ad.log\", \"a\"); fprintf(LOG, X, ##__VA_ARGS__); fprintf(LOG,\", LastError=%lu\\n\",err); fclose(LOG); SetLastError(0); }\r\n#define LOGA LOGfunk\r\n/* Cool warpper for wvsprintf */\r\nstatic void LOGfunk( const char *fmt, ... )\r\n{\r\n    DWORD lerr = GetLastError();\r\n    va_list arglist;\r\n    char str[512];\r\n    HANDLE h;\r\n\r\n    va_start( arglist, fmt );\r\n    wvsprintfA( str, fmt, arglist );\r\n    va_end( arglist );\r\n\r\n    h = CreateFileA( \"ad.log\",\r\n        FILE_APPEND_DATA, FILE_SHARE_READ, NULL, OPEN_ALWAYS,\r\n        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);\r\n    if( h == INVALID_HANDLE_VALUE )\r\n        return;\r\n    {\r\n    char lerrorstr[16];\r\n    DWORD dummy;\r\n    lstrcat_sA(str, ARR_SZ(str), \" (\");\r\n    lstrcat_sA(str, ARR_SZ(str), itostrA(lerr, lerrorstr, 10));\r\n    lstrcat_sA(str, ARR_SZ(str), \")\\n\");\r\n    WriteFile( h, str, lstrlenA(str), &dummy, NULL );\r\n    CloseHandle(h);\r\n    SetLastError(0);\r\n    }\r\n}\r\n#ifdef LOG_STUFF\r\n#define LOG LOGfunk\r\n#else\r\n    #define LOG if(0) LOGdummy\r\n    static void LOGdummy(const char *fmt, ...) {}\r\n#endif\r\n\r\n#ifdef DEBUG\r\n#include <assert.h>\r\n#else\r\n#undef assert\r\n#define assert(x)\r\n#endif\r\n\r\n#if !defined(__STDC_VERSION__) || __STDC_VERSION__ <= 202300L\r\n#ifndef static_assert\r\n    #if defined(__STDC_VERSION__)  && __STDC_VERSION__ >= 201112L\r\n        // C11 cool _Static_assert\r\n        #define static_assert _Static_assert\r\n    #else\r\n        #define static_assert(x, y) enum assert_static__ { assert_static___ = 1/(x) };\r\n    #endif\r\n#endif //static_assert\r\n#endif // [C89 - C23[\r\n\r\n/* Stuff missing in MinGW */\r\n#ifndef WM_MOUSEHWHEEL\r\n#define WM_MOUSEHWHEEL 0x020E\r\n#endif\r\n\r\n/* on both x64 and x32 */\r\n#define NtSuspendProcess NtSuspendProcessL\r\n#define NtResumeProcess NtResumeProcessL\r\n#ifndef WIN64\r\n    #define GetLayeredWindowAttributes GetLayeredWindowAttributesL\r\n    #define SetLayeredWindowAttributes SetLayeredWindowAttributesL\r\n    #define GetAncestor GetAncestorL\r\n    #undef GetMonitorInfo\r\n    #define GetMonitorInfo GetMonitorInfoL\r\n    #define EnumDisplayMonitors EnumDisplayMonitorsL\r\n    #define MonitorFromPoint MonitorFromPointL\r\n    #define MonitorFromWindow MonitorFromWindowL\r\n/*    #define GetGUIThreadInfo GetGUIThreadInfoL (NT4 SP3+/Win98+) */\r\n#endif\r\n\r\n/* Helper function to pop a message bow with error code*/\r\nstatic void ErrorBox(const TCHAR * const title)\r\n{\r\n    LPVOID lpMsgBuf;\r\n    FormatMessage(\r\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\r\n        FORMAT_MESSAGE_FROM_SYSTEM |\r\n        FORMAT_MESSAGE_IGNORE_INSERTS,\r\n        NULL,\r\n        GetLastError(),\r\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\r\n        (TCHAR *)&lpMsgBuf,\r\n        0, NULL\r\n    );\r\n    MessageBox( NULL, (LPCTSTR)lpMsgBuf, title, MB_OK | MB_ICONWARNING );\r\n    /* Free the buffer using LocalFree. */\r\n    LocalFree( lpMsgBuf );\r\n}\r\n\r\n/* Helper functiont to strcat variable amount of TCHAR*s */\r\nstatic size_t lstrcatM_s(TCHAR *d, size_t dl, ...)\r\n{\r\n    while( *d && dl-- ) d++;\r\n    va_list arglist;\r\n    va_start( arglist, dl );\r\n\r\n    while(1) {\r\n        if(dl == 0) break; /* End of string! */\r\n        const TCHAR *s = (const TCHAR *)va_arg(arglist, const TCHAR*);\r\n        if (s == NULL) break;\r\n        /* inline naive strcpy_s */\r\n        for (; dl && (*d=*s); ++s,++d,--dl);\r\n    }\r\n    *d = TEXT('\\0'); /* Ensure NULL termination */\r\n\r\n    va_end( arglist );\r\n\r\n    return dl; /* Remaining TCHARs */\r\n}\r\n\r\nstatic int PrintHwndDetails(HWND hwnd, TCHAR buf[AT_LEAST 512+40+2*8+4*12+1])\r\n{\r\n    TCHAR klass[256]=TEXT(\"\"), title[256]=TEXT(\"\");\r\n    RECT rc;\r\n    GetWindowRect(hwnd, &rc);\r\n    GetClassName(hwnd, klass, ARR_SZ(klass));\r\n    GetWindowText(hwnd, title, ARR_SZ(title));\r\n    return wsprintf(buf\r\n        , TEXT(\"Hwnd=%x, %s|%s, style=%x, xstyle=%x, rect=%ld,%ld,%ld,%ld\")\r\n        , (UINT)(UINT_PTR)hwnd\r\n        , title, klass\r\n        , (UINT)GetWindowLongPtr(hwnd, GWL_STYLE)\r\n        , (UINT)GetWindowLongPtr(hwnd, GWL_EXSTYLE)\r\n        , rc.left, rc.top, rc.right, rc.bottom\r\n        );\r\n}\r\n\r\n/* Helper to be able to enable/disable dialog items\r\n * easily while ensuring we move keyboard focus to\r\n * the next control if it was selected */\r\nstatic BOOL EnableDlgItem(HWND hdlg, UINT id, BOOL enable)\r\n{\r\n    HWND hwndControl = GetDlgItem(hdlg, id);\r\n    if (!enable && hwndControl == GetFocus()) {\r\n        SendMessage(hdlg, WM_NEXTDLGCTL, 0, FALSE);\r\n    }\r\n    return EnableWindow(hwndControl, enable);\r\n}\r\n\r\nstatic DWORD GetMsgPT(POINT *pt)\r\n{\r\n    DWORD point = GetMessagePos();\r\n    pt->x = GET_X_LPARAM(point);\r\n    pt->y = GET_Y_LPARAM(point);\r\n\r\n    return point;\r\n}\r\n\r\n/* Removes the trailing file name from a path */\r\nstatic BOOL PathRemoveFileSpecL(TCHAR *p)\r\n{\r\n    int i=0;\r\n    if (!p) return FALSE;\r\n\r\n    while(p[++i] != '\\0');\r\n    while(i > 0 && p[i] != '\\\\') i--;\r\n    p[i]='\\0';\r\n\r\n    return TRUE;\r\n}\r\n\r\n/* Removes the path and keeps only the file name */\r\nstatic void PathStripPathL(TCHAR *p)\r\n{\r\n    int i=0, j;\r\n    if (!p) return;\r\n\r\n    while(p[++i] != '\\0');\r\n    while(i >= 0 && p[i] != '\\\\') i--;\r\n    i++;\r\n    for(j=0; p[i+j] != '\\0'; j++) p[j]=p[i+j];\r\n    p[j]= '\\0';\r\n}\r\n\r\nstatic BOOL HaveProc(const char * const DLLname, const char * const PROCname)\r\n{\r\n    HINSTANCE hdll = LoadLibraryA(DLLname);\r\n    BOOL ret = FALSE;\r\n    if (hdll) {\r\n        if(GetProcAddress(hdll, PROCname)) {\r\n            ret = TRUE ;\r\n        }\r\n        FreeLibrary(hdll);\r\n    }\r\n    return ret;\r\n}\r\n\r\nstatic FARPROC LoadDLLProc(const char *DLLname, const char *PROCname)\r\n{\r\n    HINSTANCE hdll;\r\n    FARPROC ret = (FARPROC)NULL;\r\n\r\n    if((hdll = GetModuleHandleA(DLLname))) {\r\n        return GetProcAddress(hdll, PROCname);\r\n    }\r\n    hdll = LoadLibraryA(DLLname);\r\n    if (hdll) {\r\n        ret = GetProcAddress(hdll, PROCname);\r\n        if (!ret) FreeLibrary(hdll);\r\n    }\r\n    return ret;\r\n}\r\n\r\n/* Accurate Sleep, needs WINMM.DLL */\r\nstatic void ASleep(DWORD duration_ms)\r\n{\r\n    static MMRESULT (WINAPI *mtimeGetDevCaps)(LPTIMECAPS ptc, UINT cbtc) = (MMRESULT (WINAPI *)(LPTIMECAPS ptc, UINT cbtc))IPTR;\r\n    static MMRESULT (WINAPI *mtimeBeginPeriod)(UINT uPeriod);\r\n    static MMRESULT (WINAPI *mtimeEndPeriod)(UINT uPeriod);\r\n\r\n    if (duration_ms > 15) {\r\n        /* No need for accurate sleep... */\r\n        Sleep(duration_ms);\r\n        return;\r\n    }\r\n    if (mtimeGetDevCaps == (MMRESULT (WINAPI *)(LPTIMECAPS ptc, UINT cbtc))IPTR) {\r\n        HINSTANCE h=LoadLibraryA(\"WINMM.DLL\");\r\n        if (h) {\r\n            mtimeGetDevCaps =(MMRESULT (WINAPI *)(LPTIMECAPS ptc, UINT cbtc))GetProcAddress(h, \"timeGetDevCaps\");\r\n            mtimeBeginPeriod=(MMRESULT (WINAPI *)(UINT uPeriod))GetProcAddress(h, \"timeBeginPeriod\");\r\n            mtimeEndPeriod  =(MMRESULT (WINAPI *)(UINT uPeriod))GetProcAddress(h, \"timeEndPeriod\");\r\n            if(!mtimeGetDevCaps || !mtimeBeginPeriod || !mtimeEndPeriod) {\r\n                mtimeGetDevCaps=NULL;\r\n                FreeLibrary(h);\r\n            }\r\n        }\r\n    }\r\n    /* We have winmm functions */\r\n    /* This absurd code makes Sleep() more accurate\r\n     * - without it, Sleep() is not even +-10ms accurate\r\n     * - with it, Sleep is around +-1.5 ms accurate\r\n     */\r\n    if(mtimeGetDevCaps) {\r\n        TIMECAPS tc;\r\n        mtimeGetDevCaps(&tc, sizeof(tc));\r\n        mtimeBeginPeriod(tc.wPeriodMin); /* begin accurate sleep */\r\n\r\n        Sleep(duration_ms); /* perform The SLEEP */\r\n\r\n        mtimeEndPeriod(tc.wPeriodMin); /* end accurate sleep*/\r\n    } else {\r\n        Sleep(duration_ms);\r\n    }\r\n}\r\n\r\nstatic BOOL FreeDLLByName(const char * const DLLname)\r\n{\r\n    HINSTANCE hdll;\r\n    if((hdll = GetModuleHandleA(DLLname)))\r\n        return FreeLibrary(hdll);\r\n    return FALSE;\r\n}\r\nstatic HWND GetAncestorL(HWND hwnd, UINT gaFlags)\r\n{\r\n    typedef HWND (WINAPI *funk_t)(HWND hwnd, UINT gaFlags);\r\n    static funk_t funk = (funk_t)IPTR;\r\n    HWND hlast, hprevious;\r\n    LONG wlong;\r\n    if(!hwnd) return NULL;\r\n    hprevious = hwnd;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetAncestor\");\r\n    }\r\n    if(funk) { /* We know we have the function */\r\n        return funk(hwnd, gaFlags);\r\n    }\r\n    /* Fallback */\r\n    while ( (hlast = GetParent(hprevious)) != NULL ){\r\n        wlong=GetWindowLong(hprevious, GWL_STYLE);\r\n        if(wlong&(WS_POPUP)) break;\r\n        hprevious=hlast;\r\n    }\r\n    return hprevious;\r\n}\r\n\r\n#ifndef MSGFLTINFO_NONE\r\n\r\n#define MSGFLTINFO_NONE 0\r\n#define MSGFLTINFO_ALREADYALLOWED_FORWND 1\r\n#define MSGFLTINFO_ALREADYDISALLOWED_FORWND 2\r\n#define MSGFLTINFO_ALLOWED_HIGHER 3\r\n\r\ntypedef struct tagCHANGEFILTERSTRUCT {\r\n  DWORD cbSize;\r\n  DWORD ExtStatus;\r\n} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;\r\n#endif\r\n\r\n// On Windows Vista we have to use this one that applies process wide.\r\nstatic BOOL ChangeWindowMessageFilterL(UINT msg, DWORD ac)\r\n{\r\n    typedef BOOL (WINAPI* funk_t)(UINT msg, DWORD ac);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"ChangeWindowMessageFilter\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(msg, ac);\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n// Available only on Windows 7+s\r\nstatic BOOL ChangeWindowMessageFilterExL(HWND hwnd, UINT msg, DWORD ac, PCHANGEFILTERSTRUCT pC)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HWND hwnd, UINT msg, DWORD ac, PCHANGEFILTERSTRUCT pC);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"ChangeWindowMessageFilterEx\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd, msg, ac, pC);\r\n    }\r\n    // Process-wide Fallback for Windows Vista!\r\n    return ChangeWindowMessageFilterL(msg, ac);\r\n}\r\n\r\nstatic BOOL GetLayeredWindowAttributesL(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetLayeredWindowAttributes\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd, pcrKey, pbAlpha, pdwFlags);\r\n    }\r\n    return FALSE;\r\n}\r\n\r\nstatic BOOL SetLayeredWindowAttributesL(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n        funk= (funk_t)LoadDLLProc(\"USER32.DLL\", \"SetLayeredWindowAttributes\");\r\n    }\r\n    if(funk) { /* We know we have the function */\r\n        return funk(hwnd, crKey, bAlpha, dwFlags);\r\n    }\r\n    return FALSE;\r\n}\r\n\r\nstatic BOOL GetMonitorInfoL(HMONITOR hMonitor, LPMONITORINFO lpmi)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HMONITOR hMonitor, LPMONITORINFO lpmi);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) {\r\n    #ifdef _UNICODE\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetMonitorInfoW\");\r\n    #else\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetMonitorInfoA\");\r\n    #endif\r\n    }\r\n    if(funk) { /* We know we have the function */\r\n        if(hMonitor) return funk(hMonitor, lpmi);\r\n    }\r\n    /* Fallback for NT4 */\r\n    GetClientRect(GetDesktopWindow(), &lpmi->rcMonitor);\r\n    SystemParametersInfo(SPI_GETWORKAREA, 0, &lpmi->rcWork, 0);\r\n    lpmi->dwFlags = MONITORINFOF_PRIMARY;\r\n\r\n    return TRUE;\r\n}\r\n\r\nstatic BOOL EnumDisplayMonitorsL(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);\r\n    static funk_t funk = (funk_t)IPTR;\r\n\r\n    MONITORINFO mi;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk= (funk_t)LoadDLLProc(\"USER32.DLL\", \"EnumDisplayMonitors\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hdc, lprcClip, lpfnEnum, dwData);\r\n    }\r\n\r\n    /* Fallbak */\r\n    GetMonitorInfoL(NULL, &mi);\r\n    lpfnEnum(NULL, NULL, &mi.rcMonitor, 0); /* Callback function */\r\n\r\n    return TRUE;\r\n}\r\n\r\nstatic HMONITOR MonitorFromPointL(POINT pt, DWORD dwFlags)\r\n{\r\n    typedef HMONITOR (WINAPI *funk_t)(POINT pt, DWORD dwFlags);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"MonitorFromPoint\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(pt, dwFlags);\r\n    }\r\n    return NULL;\r\n}\r\n\r\nstatic HMONITOR MonitorFromWindowL(HWND hwnd, DWORD dwFlags)\r\n{\r\n    typedef HMONITOR (WINAPI *funk_t)(HWND hwnd, DWORD dwFlags);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"MonitorFromWindow\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd, dwFlags);\r\n    }\r\n    return NULL;\r\n}\r\n\r\nstatic BOOL GetGUIThreadInfoL(DWORD pid, GUITHREADINFO *lpgui)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(DWORD pid, GUITHREADINFO *lpgui);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetGUIThreadInfo\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(pid, lpgui);\r\n    }\r\n    return FALSE;\r\n}\r\n\r\nstatic int GetSystemMetricsForDpiL(int  nIndex, UINT dpi)\r\n{\r\n    typedef int (WINAPI *funk_t)(int  nIndex, UINT dpi);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (dpi) {\r\n        if (funk == (funk_t)IPTR) { /* First time */\r\n            funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetSystemMetricsForDpi\");\r\n        }\r\n        if (funk) { /* We know we have the function */\r\n            return funk(nIndex, dpi);\r\n        }\r\n    }\r\n    /* Use non dpi stuff if dpi == 0 or if it does not exist. */\r\n    return GetSystemMetrics(nIndex);\r\n}\r\n#define GetSystemMetricsForDpi GetSystemMetricsForDpiL\r\n\r\nstatic HRESULT GetDpiForMonitorL(HMONITOR hmonitor, int dpiType, UINT *dpiX, UINT *dpiY)\r\n{\r\n    typedef HRESULT (WINAPI *funk_t)(HMONITOR hmonitor, int dpiType, UINT *dpiX, UINT *dpiY);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"SHCORE.DLL\", \"GetDpiForMonitor\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hmonitor, dpiType, dpiX, dpiY);\r\n    }\r\n    return 666; /* Fail with 666 error */\r\n}\r\n\r\n/* Supported wince Windows 10, version 1607 [desktop apps only] */\r\nstatic UINT GetDpiForWindowL(const HWND hwnd)\r\n{\r\n    typedef UINT (WINAPI *funk_t)(const HWND hwnd);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"GetDpiForWindow\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd);\r\n    }\r\n\r\n    /* Windows 8.1 / Server2012 R2 Fallback */\r\n    UINT dpiX=0;\r\n    UINT dpiY=0;\r\n    HMONITOR hmon;\r\n    if ((hmon = MonitorFromWindowL(hwnd, MONITOR_DEFAULTTONEAREST))\r\n    && S_OK == GetDpiForMonitorL(hmon, MDT_DEFAULT, &dpiX, &dpiY)) {\r\n        return dpiX;\r\n    }\r\n\r\n    return 0; /* Not handled */\r\n}\r\n#define GetDpiForWindow GetDpiForWindowL\r\n\r\nstatic UINT ReallyGetDpiForWindow(const HWND hwnd)\r\n{\r\n    UINT dpi = GetDpiForWindowL(hwnd);\r\n    if (!dpi) {\r\n        HDC hdc = GetDC(hwnd);\r\n        if(hdc) {\r\n            dpi = (UINT)GetDeviceCaps(hdc, LOGPIXELSY);\r\n            ReleaseDC(hwnd, hdc);\r\n            if (!dpi) dpi = 96; /* Default to 96 dpi*/\r\n        } else {\r\n            dpi = 96; /* cannot et a DC, default to 96 dpi */\r\n        }\r\n    }\r\n    return dpi;\r\n}\r\n/* https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-enablenonclientdpiscaling\r\n * Available since Windows 10.0.14342 (~1607) https://stackoverflow.com/questions/36864894\r\n * Useless since Windows 10.0.15063 (1703)\r\n * So it is only useful in builds frim 1607 to 1703\r\n * To be called in the WM_NCCREATE message handler.\r\n */\r\nstatic BOOL EnableNonClientDpiScalingL(HWND hwnd)\r\n{\r\n    /* For Windows 10 below build 15063 */\r\n    typedef BOOL (WINAPI *funk_t)(HWND hwnd);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"EnableNonClientDpiScaling\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd);\r\n    }\r\n    return FALSE;\r\n}\r\n/* Only applies to Windows NT for build number */\r\nstatic xpure BOOL OredredWinVer()\r\n{\r\n    DWORD oVer;\r\n    DWORD ver = GetVersion();\r\n    oVer = (ver&0x000000FF) << 24 /* MAJOR */\r\n           | (ver&0x0000FF00) << 8  /* MINOR */\r\n           | (ver&0xFFFF0000) >> 16;/* BUILDID */\r\n\r\n    /* On Windows 9x, no buildID is available in GetVer */\r\n    if (ver & 0x80000000) {\r\n        // Only use minor/major ver.\r\n        oVer |= 0xFFFF0000;\r\n    }\r\n    return oVer;\r\n}\r\nstatic BOOL IsDarkModeEnabled(void)\r\n{\r\n    DWORD value = 0;\r\n    if ( OredredWinVer() >= 0x0A004563 ) {\r\n        /* In case of Windows 10 build 10.0.17763 or 10.x (future) or 11+ */\r\n        DWORD len=sizeof(DWORD);\r\n        HKEY key;\r\n        if (RegOpenKeyEx(HKEY_CURRENT_USER\r\n                , TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\")\r\n                , 0, KEY_QUERY_VALUE, &key) == ERROR_SUCCESS)\r\n        {\r\n            if (RegQueryValueEx(key, TEXT(\"AppsUseLightTheme\"), NULL, NULL, (LPBYTE)&value, &len) == ERROR_SUCCESS) {\r\n                value = !value;\r\n            }\r\n            RegCloseKey(key);\r\n        }\r\n   }\r\n   return value;\r\n}\r\nstatic BOOL IsHighContrastEnabled()\r\n{\r\n    HIGHCONTRAST hc = { sizeof(hc) };\r\n    if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, FALSE))\r\n        return hc.dwFlags & HCF_HIGHCONTRASTON;\r\n\r\n    return FALSE;\r\n}\r\n/* We can use the DWMWA_USE_IMMERSIVE_DARK_MODE=20 DWM style\r\n * It is documented for Win11 build 22000 but it also appears to work for Win10\r\n * However from build 1809 to 2004 it the value was =19 and it is =20\r\n * Since Windows 10 build 20H1 and on Win11\r\n * DWMWA_USE_IMMERSIVE_DARK_MODE=19 up to Win10 2004\r\n * DWMWA_USE_IMMERSIVE_DARK_MODE=20 since Win10 20H1 */\r\nstatic HRESULT DwmSetWindowAttributeL(HWND hwnd, DWORD a, PVOID b, DWORD c);\r\nstatic BOOL AllowDarkTitlebar(HWND hwnd)\r\n{\r\n    if( IsHighContrastEnabled() )\r\n        return FALSE; /* Nothing to do and ignore DarkMode */\r\n\r\n    BOOL DarkMode = IsDarkModeEnabled();\r\n    if ( OredredWinVer() >= 0x0A004A29 ) {\r\n        /* Windows 10 build 10.0.18985 ie 20H1 */\r\n        DwmSetWindowAttributeL(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &DarkMode, sizeof(DarkMode));\r\n    } else if ( OredredWinVer() >= 0x0A004563) {\r\n        /* Windows 10 build 10.0.17763 ie: 1809 or later */\r\n\r\n        if ( OredredWinVer() < 0x0A0047BA) {\r\n            /* Windows 10 build 10.0.18362 ie: before 1903 */\r\n            SetProp(hwnd, TEXT(\"UseImmersiveDarkModeColors\"), (HANDLE)(UINT_PTR)DarkMode);\r\n        }\r\n        DwmSetWindowAttributeL(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE_PRE20H1, &DarkMode, sizeof(DarkMode));\r\n    }\r\n    /* We must return the actual state of the Dark mode */\r\n    return DarkMode;\r\n}\r\n\r\n/* Helper function */\r\nstatic int GetSystemMetricsForWin(int nIndex, HWND hwnd)\r\n{\r\n    return GetSystemMetricsForDpiL(nIndex, GetDpiForWindowL(hwnd));\r\n}\r\nstatic BOOL SystemParametersInfoForDpiL(UINT uiAction, UINT uiParam, PVOID pvParam, UINT  fWinIni, UINT dpi)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT  fWinIni, UINT dpi);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (dpi) {\r\n        if (funk == (funk_t)IPTR) { /* First time */\r\n            funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"SystemParametersInfoForDpi\");\r\n        }\r\n        if (funk) { /* We know we have the function */\r\n            return funk(uiAction, uiParam, pvParam, fWinIni, dpi);\r\n        }\r\n    }\r\n    /* Not handeled */\r\n    return SystemParametersInfo(uiAction, uiParam, pvParam, fWinIni);\r\n}\r\n#define SystemParametersInfoForDpi SystemParametersInfoForDpiL\r\n\r\nstatic HWINEVENTHOOK SetWinEventHookL(\r\n      DWORD eventMin, DWORD eventMax\r\n    , HMODULE hmodWinEventProc\r\n    , WINEVENTPROC pfnWinEventProc\r\n    , DWORD idProcess, DWORD idThread, DWORD dwFlags)\r\n{\r\n    typedef HWINEVENTHOOK (WINAPI *funk_t)(DWORD evm, DWORD evM, HMODULE hmod, WINEVENTPROC wevp, DWORD idProcess, DWORD idThread, DWORD dwFlags);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"SetWinEventHook\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(eventMin, eventMax, hmodWinEventProc\r\n                    , pfnWinEventProc, idProcess, idThread, dwFlags);\r\n    }\r\n    /* Failed */\r\n    return NULL;\r\n}\r\nstatic BOOL UnhookWinEventL(HWINEVENTHOOK hWinEventHook)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HWINEVENTHOOK hWinEventHook);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"UnhookWinEvent\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hWinEventHook);\r\n    }\r\n    /* Failed */\r\n    return FALSE;\r\n}\r\n\r\n\r\n#ifndef WIN64\r\nstatic void NotifyWinEventL(DWORD event, HWND hwnd, LONG idObj, LONG idChild)\r\n{\r\n    typedef  void (WINAPI *funk_t)(DWORD, HWND, LONG, LONG);\r\n    static funk_t funk = (funk_t)1;\r\n    if (funk == (funk_t)1)\r\n        funk = (funk_t)LoadDLLProc(\"USER32.DLL\", \"NotifyWinEvent\");\r\n\r\n    if (funk)\r\n        funk(event, hwnd, idObj, idChild);\r\n}\r\n#define NotifyWinEvent NotifyWinEventL\r\n#endif\r\n\r\nstatic HRESULT DwmGetWindowAttributeL(HWND hwnd, DWORD a, PVOID b, DWORD c)\r\n{\r\n    typedef HRESULT (WINAPI *funk_t)(HWND hwnd, DWORD a, PVOID b, DWORD c);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"DWMAPI.DLL\", \"DwmGetWindowAttribute\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd, a, b, c);\r\n    }\r\n    /* DwmGetWindowAttribute return 0 on sucess ! */\r\n    return 666; /* Here we FAIL with 666 error    */\r\n}\r\n\r\nstatic HRESULT DwmSetWindowAttributeL(HWND hwnd, DWORD a, PVOID b, DWORD c)\r\n{\r\n    typedef HRESULT (WINAPI *funk_t)(HWND hwnd, DWORD a, PVOID b, DWORD c);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"DWMAPI.DLL\", \"DwmSetWindowAttribute\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hwnd, a, b, c);\r\n    }\r\n    /* myDwmSetWindowAttribute return 0 on sucess ! */\r\n    return 666; /* Here we FAIL with 666 error    */\r\n}\r\n\r\nstatic HRESULT DwmGetColorizationColorL(DWORD *a, BOOL *b)\r\n{\r\n    typedef HRESULT (WINAPI *funk_t)(DWORD *a, BOOL *b);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"DWMAPI.DLL\", \"DwmGetColorizationColor\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(a, b);\r\n    }\r\n    /* return 0 on sucess ! */\r\n    return 666; /* Here we FAIL with 666 error    */\r\n}\r\n\r\nstatic COLORREF GetSysColorizationColor()\r\n{\r\n    DWORD color=0;\r\n    BOOL b=FALSE;\r\n    if(S_OK == DwmGetColorizationColorL(&color, &b)) {\r\n        /* Re orde- bytes because\r\n         * COLORREF:  0x00BBGGRR and not 0xAARRGGBB */\r\n        return  (color&0x000000FF) << 16  /* blue */\r\n              | (color&0x0000FF00)        /* green */\r\n              | (color&0x00FF0000) >> 16; /* red */\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic long xpure average(long a, long b)\r\n{\r\n    return (a>>1) + (b>>1) + ( ((a&1) + (b&1))>>1 );\r\n}\r\nstatic long xpure averageX(const RECT *rc)\r\n{\r\n    return average(rc->left, rc->right);\r\n}\r\nstatic long xpure averageY(const RECT *rc)\r\n{\r\n    return average(rc->top, rc->bottom);\r\n}\r\n\r\n/* #define DwmGetWindowAttribute DwmGetWindowAttributeL */\r\n\r\nstatic void SubRect(RECT *__restrict__ frame, const RECT *rect)\r\n{\r\n    frame->left -= rect->left;\r\n    frame->top  -= rect->top;\r\n    frame->right = rect->right - frame->right;\r\n    frame->bottom = rect->bottom - frame->bottom;\r\n}\r\nstatic void InflateRectBorder(RECT *__restrict__ rc, const RECT *bd)\r\n{\r\n    rc->left   -= bd->left;\r\n    rc->top    -= bd->top;\r\n    rc->right  += bd->right;\r\n    rc->bottom += bd->bottom;\r\n}\r\n\r\nstatic void DeflateRectBorder(RECT *__restrict__ rc, const RECT *bd)\r\n{\r\n    rc->left   += bd->left;\r\n    rc->top    += bd->top;\r\n    rc->right  -= bd->right;\r\n    rc->bottom -= bd->bottom;\r\n}\r\n\r\nstatic void OffsetPoints(POINT *pts, long dx, long dy, unsigned count)\r\n{\r\n    while(count--) {\r\n        pts->x += dx;\r\n        pts->y += dy;\r\n        pts++;\r\n    }\r\n}\r\n\r\nstatic void FixDWMRectLL(HWND hwnd, RECT *bbb, const int SnapGap)\r\n{\r\n    RECT rect, frame;\r\n\r\n    if(S_OK == DwmGetWindowAttributeL(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &frame, sizeof(RECT))\r\n       && GetWindowRect(hwnd, &rect)){\r\n        SubRect(&frame, &rect);\r\n        CopyRect(bbb, &frame);\r\n    } else {\r\n        SetRectEmpty(bbb);\r\n        /*SetRect(bbb, 10, 10, 10, 10);*/\r\n    }\r\n    if (SnapGap) OffsetRect(bbb, -SnapGap, -SnapGap);\r\n//    if (IsZoomed(hwnd)) OffsetRect(bbb, 10, 10); // Test for Zoomed stuff\r\n}\r\n\r\n/* This function is here because under Windows 10, the GetWindowRect function\r\n * includes invisible borders, if those borders were visible it would make\r\n * sense, this is the case on Windows 7 and 8.x for example\r\n * We use DWM api when available in order to get the REAL client area\r\n */\r\nstatic BOOL GetWindowRectLL(HWND hwnd, RECT *rect, const int SnapGap)\r\n{\r\n    HRESULT ret = DwmGetWindowAttributeL(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, rect, sizeof(RECT));\r\n    if( ret == S_OK) {\r\n        ret = TRUE;\r\n    } else {\r\n        ret = GetWindowRect(hwnd, rect); /* Fallback to normal */\r\n    }\r\n    if (SnapGap) InflateRect(rect, SnapGap, SnapGap);\r\n    return ret;\r\n}\r\n/* Under Win8 and later a window can be cloaked\r\n * This falg can be obtained with this function\r\n * 1 The window was cloaked by its owner application.\r\n * 2 The window was cloaked by the Shell.\r\n * 4 The cloak value was inherited from its owner window.\r\n * For windows that are supposed to be logically \"visible\", in addition to WS_VISIBLE.\r\n * EDIT: Now Raymond Chen did an article about this:\r\n * https://devblogs.microsoft.com/oldnewthing/20200302-00/?p=103507\r\n * I had to figure it out the Hard way...\r\n */\r\nstatic int IsWindowCloaked(HWND hwnd)\r\n{\r\n    int cloaked=0;\r\n    return S_OK == DwmGetWindowAttributeL(hwnd, DWMWA_CLOAKED, &cloaked, sizeof(cloaked))\r\n        && cloaked;\r\n}\r\n/* Some windows might have a size of 0x0 (e.g., a 'Setup' window in Windows 11\r\n * that appears to be visible despite having no size). It is assumed that this\r\n * is an issue specific to a system update window in Windows 11 (and maybe other\r\n * versions as well), although this has not been confirmed.\r\n */\r\nstatic BOOL HasWindowSizeZero(HWND hwnd)\r\n{\r\n    RECT rc;\r\n    return GetWindowRect(hwnd, &rc) && (rc.right == rc.left || rc.bottom == rc.top);\r\n}\r\nstatic BOOL IsVisible(HWND hwnd)\r\n{\r\n    return IsWindowVisible(hwnd) && !IsWindowCloaked(hwnd) && !HasWindowSizeZero(hwnd);\r\n}\r\n\r\n/* Gets the original owner of hwnd.\r\n * stops going back the owner chain if invisible. */\r\nstatic HWND GetRootOwner(HWND hwnd)\r\n{\r\n    HWND parent;\r\n    int i=0;\r\n    while (( parent = (GetWindowLongPtr(hwnd, GWL_STYLE)&WS_CHILD)\r\n           ? GetParent(hwnd) : GetWindow(hwnd, GW_OWNER)\r\n          )) {\r\n\r\n        RECT prc;\r\n        if (parent == hwnd || i++ > 2048 || !IsVisible(parent)\r\n        || !GetWindowRect(parent, &prc) || IsRectEmpty(&prc)) {\r\n            /* Stop if in a loop or if parent is not visible\r\n             * or if the parent rect is empty */\r\n            break;\r\n        }\r\n        hwnd = parent;\r\n    }\r\n\r\n    return hwnd;\r\n}\r\n\r\n/* Use the DWM api to obtain the rectangel that *should* contain all\r\n * caption buttons. This is usefull to ensure we are not in one of them.\r\n */\r\nstatic BOOL GetCaptionButtonsRect(HWND hwnd, RECT *rc)\r\n{\r\n    int ret = DwmGetWindowAttributeL(hwnd, DWMWA_CAPTION_BUTTON_BOUNDS, rc, sizeof(RECT));\r\n    /* Convert rectangle to to screen coordinate. */\r\n    if (ret == S_OK) {\r\n        RECT wrc;\r\n        GetWindowRect(hwnd, &wrc);\r\n        OffsetRect(rc, wrc.left, wrc.top);\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic LONG NtSuspendProcessL(HANDLE ProcessHandle)\r\n{\r\n    typedef HRESULT (NTAPI *funk_t)(HANDLE ProcessHandle);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"NTDLL.DLL\", \"NtSuspendProcess\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(ProcessHandle);\r\n    }\r\n    return 666; /* Here we FAIL with 666 error    */\r\n}\r\n\r\nstatic LONG NtResumeProcessL(HANDLE ProcessHandle)\r\n{\r\n    typedef HRESULT (NTAPI *funk_t)(HANDLE ProcessHandle);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk = (funk_t)LoadDLLProc(\"NTDLL.DLL\", \"NtResumeProcess\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(ProcessHandle);\r\n    }\r\n    return 666; /* Here we FAIL with 666 error    */\r\n}\r\n\r\nstatic HRESULT DwmIsCompositionEnabledL(BOOL *pfEnabled)\r\n{\r\n    typedef HRESULT (WINAPI *funk_t)(BOOL *pfEnabled);\r\n    funk_t funk;\r\n\r\n    HINSTANCE hdll=NULL;\r\n    HRESULT ret ;\r\n\r\n    *pfEnabled = FALSE;\r\n    ret = 666;\r\n\r\n    hdll = LoadLibraryA(\"DWMAPI.DLL\");\r\n    if (hdll) {\r\n        funk = (funk_t)GetProcAddress(hdll, \"DwmIsCompositionEnabled\");\r\n        if(funk) {\r\n            ret = funk(pfEnabled);\r\n        } else {\r\n            *pfEnabled = FALSE;\r\n            ret = 666;\r\n        }\r\n        FreeLibrary(hdll);\r\n    }\r\n    return ret;\r\n}\r\n\r\nstatic BOOL HaveDWM()\r\n{\r\n    static int first=1;\r\n    static BOOL have_dwm = FALSE;\r\n    if(first)\r\n        DwmIsCompositionEnabledL(&have_dwm);\r\n    first = 0;\r\n\r\n    return have_dwm;\r\n}\r\n\r\nstatic BOOL DwmDefWindowProcL(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)\r\n{\r\n    typedef BOOL (WINAPI *funk_t)(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n        funk= (funk_t)LoadDLLProc(\"DWMAPI.DLL\", \"DwmDefWindowProc\");\r\n    }\r\n    if (funk) { /* We know we have the function */\r\n        return funk(hWnd, msg, wParam, lParam, plResult);\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n/* PSAPI.DLL */\r\nstatic DWORD GetModuleFileNameExL(HANDLE hProcess, HMODULE hModule, LPTSTR lpFilename, DWORD nSize)\r\n{\r\n    typedef DWORD (WINAPI *funk_t)(HANDLE hProcess, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n    #ifdef _UNICODE\r\n        funk = (funk_t)LoadDLLProc(\"PSAPI.DLL\", \"GetModuleFileNameExW\");\r\n    #else\r\n        funk = (funk_t)LoadDLLProc(\"PSAPI.DLL\", \"GetModuleFileNameExA\");\r\n    #endif\r\n    }\r\n    if (funk) { /* We have the function */\r\n        return funk(hProcess, hModule, lpFilename, nSize);\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic DWORD GetProcessImageFileNameL(HANDLE hProcess, TCHAR *lpImageFileName, DWORD nSize)\r\n{\r\n    typedef DWORD (WINAPI *funk_t)(HANDLE hProcess, TCHAR *lpImageFileName, DWORD nSize);\r\n    static funk_t funk=(funk_t)IPTR;\r\n\r\n    if (funk == (funk_t)IPTR) { /* First time */\r\n    #ifdef _UNICODE\r\n        funk = (funk_t)LoadDLLProc(\"PSAPI.DLL\", \"GetProcessImageFileNameW\");\r\n    #else\r\n        funk = (funk_t)LoadDLLProc(\"PSAPI.DLL\", \"GetProcessImageFileNameA\");\r\n    #endif\r\n    }\r\n    if (funk) {\r\n        return funk(hProcess, lpImageFileName, nSize);\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic DWORD GetWindowProgName(HWND hwnd, TCHAR *title, size_t title_len)\r\n{\r\n    DWORD pid=0;\r\n    HANDLE proc;\r\n    DWORD ret=0;\r\n    if (!GetWindowThreadProcessId(hwnd, &pid) || !pid )\r\n        return 0;\r\n    proc = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ, FALSE, pid);\r\n\r\n    if (proc)\r\n        ret = GetModuleFileNameExL(proc, NULL, title, title_len);\r\n    else\r\n        proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\r\n    if(!proc)\r\n        return 0;\r\n\r\n    // Try other function\r\n    if (!ret) ret = GetProcessImageFileNameL(proc, title, title_len);\r\n\r\n    CloseHandle(proc);\r\n\r\n    PathStripPathL(title);\r\n    return ret? pid: 0;\r\n}\r\n\r\n/* Function to get the best possible small icon associated with a window\r\n * We always use SendMessageTimeout to ensure we do not get  locked\r\n * We start with ICON_SMALL, then ICON_SMALL2, then ICON_BIG and finally\r\n * we try to get the icon from the window class if everything failed or\r\n * if the first message timed out (freezing program).\r\n * Note that ICON_SMALL2 was introduced by Windows XP (I think) */\r\n#ifndef ICON_SMALL2\r\n#define ICON_SMALL2 2\r\n#endif\r\n#ifndef GCLP_HICON\r\n#define GCLP_HICON (-14)\r\n#endif\r\n#ifndef GCLP_HICONSM\r\n#define GCLP_HICONSM (-34)\r\n#endif\r\nstatic HICON GetWindowIcon(HWND hwnd)\r\n{\r\n    #define TIMEOUT 64\r\n    HICON icon;\r\n    if (SendMessageTimeout(hwnd, WM_GETICON, ICON_SMALL, 0, SMTO_ABORTIFHUNG, TIMEOUT, (DWORD_PTR*)&icon)) {\r\n        /* The message failed without timeout */\r\n        if (icon) return icon; /* Sucess */\r\n\r\n        /* ICON_SMALL2 exists since Windows XP only */\r\n        static BYTE WINXP_PLUS=0xFF;\r\n        if (WINXP_PLUS == 0xFF) {\r\n            WORD wVer = LOWORD(GetVersion());\r\n            BYTE ver = LOBYTE(wVer);\r\n            BYTE min = LOBYTE(wVer);\r\n            WINXP_PLUS = ver > 5 || (ver == 5 && min > 0); /* XP is NT 5.1 */\r\n        }\r\n        if (WINXP_PLUS\r\n        &&  SendMessageTimeout(hwnd, WM_GETICON, ICON_SMALL2, 0, SMTO_ABORTIFHUNG, TIMEOUT, (DWORD_PTR*)&icon) && icon)\r\n            return icon;\r\n\r\n        /* Try again with the big icon if we were unable to retreave the small one. */\r\n        if (SendMessageTimeout(hwnd, WM_GETICON, ICON_BIG, 0, SMTO_ABORTIFHUNG, TIMEOUT, (DWORD_PTR*)&icon) && icon)\r\n            return icon;\r\n    }\r\n    /* Try the Class icon if nothing can be get */\r\n    if ((icon = (HICON)GetClassLongPtr(hwnd, GCLP_HICONSM))) return icon;\r\n    if ((icon = (HICON)GetClassLongPtr(hwnd, GCLP_HICON))) return icon;\r\n\r\n    return LoadIcon(NULL, IDI_WINLOGO); /* Default to generic window icon */\r\n    #undef TIMEOUT\r\n}\r\n/* Helper function to get the current system menu font.\r\n * We need to use the newer NONCLIENTMETRICS for Window 8+ dpi aware\r\n * SystemParametersInfoForDpi() and We must ude the old NONCLIENTMETRICS\r\n * structure when using Windows XP or lower.\r\n * (vistal added the iPaddedBorderWidth int element */\r\nstruct OLDNONCLIENTMETRICSAW {\r\n  UINT cbSize;\r\n  int iBorderWidth;\r\n  int iScrollWidth;\r\n  int iScrollHeight;\r\n  int iCaptionWidth;\r\n  int iCaptionHeight;\r\n  LOGFONT lfCaptionFont;\r\n  int iSmCaptionWidth;\r\n  int iSmCaptionHeight;\r\n  LOGFONT lfSmCaptionFont;\r\n  int iMenuWidth;\r\n  int iMenuHeight;\r\n  LOGFONT lfMenuFont;\r\n  LOGFONT lfStatusFont;\r\n  LOGFONT lfMessageFont;\r\n};\r\nstruct NEWNONCLIENTMETRICSAW {\r\n  UINT cbSize;\r\n  int iBorderWidth;\r\n  int iScrollWidth;\r\n  int iScrollHeight;\r\n  int iCaptionWidth;\r\n  int iCaptionHeight;\r\n  LOGFONT lfCaptionFont;\r\n  int iSmCaptionWidth;\r\n  int iSmCaptionHeight;\r\n  LOGFONT lfSmCaptionFont;\r\n  int iMenuWidth;\r\n  int iMenuHeight;\r\n  LOGFONT lfMenuFont;\r\n  LOGFONT lfStatusFont;\r\n  LOGFONT lfMessageFont;\r\n  int iPaddedBorderWidth; /* New in Window Vista */\r\n};\r\nstatic BOOL GetNonClientMetricsDpi(struct NEWNONCLIENTMETRICSAW *ncm, UINT dpi)\r\n{\r\n    mem00(ncm, sizeof(struct NEWNONCLIENTMETRICSAW));\r\n    ncm->cbSize = sizeof(struct NEWNONCLIENTMETRICSAW);\r\n    BOOL ret = SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, sizeof(struct NEWNONCLIENTMETRICSAW), ncm, 0, dpi);\r\n    if (!ret) { /* Old Windows versions... XP and below */\r\n        ncm->cbSize = sizeof(struct OLDNONCLIENTMETRICSAW);\r\n        ret = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(struct OLDNONCLIENTMETRICSAW), ncm, 0);\r\n    }\r\n    return ret;\r\n}\r\nstatic HFONT CreateNCMenuFont(UINT dpi)\r\n{\r\n    struct NEWNONCLIENTMETRICSAW ncm;\r\n    GetNonClientMetricsDpi(&ncm, dpi);\r\n    return CreateFontIndirect(&ncm.lfMenuFont);\r\n}\r\n\r\nstatic void MaximizeWindow(HWND hwnd)\r\n{\r\n    PostMessage(hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);\r\n}\r\nstatic void RestoreWindow(HWND hwnd)\r\n{\r\n    PostMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);\r\n}\r\nstatic void ToggleMaxRestore(HWND hwnd)\r\n{\r\n    PostMessage(hwnd, WM_SYSCOMMAND, IsZoomed(hwnd)? SC_RESTORE: SC_MAXIMIZE, 0);\r\n}\r\nstatic void MinimizeWindow(HWND hwnd)\r\n{\r\n    PostMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);\r\n}\r\n/* Just changes the window Z-order */\r\nstatic BOOL SetWindowLevel(HWND hwnd, HWND hafter)\r\n{\r\n    return SetWindowPos(hwnd, hafter, 0, 0, 0, 0\r\n    , SWP_ASYNCWINDOWPOS|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);\r\n}\r\nstatic int HitTestTimeoutL(HWND hwnd, LPARAM lParam)\r\n{\r\n    DorQWORD area=0;\r\n\r\n/*\r\n    if(DwmDefWindowProcL(hwnd, WM_NCHITTEST, 0, lParam, (LRESULT*)&area))\r\n        return area;\r\n*/\r\n\r\n    while(hwnd && SendMessageTimeout(hwnd, WM_NCHITTEST, 0, lParam, SMTO_NORMAL, 255, &area)){\r\n        if((int)area == HTTRANSPARENT)\r\n            hwnd = GetParent(hwnd);\r\n        else\r\n            break;\r\n    }\r\n    return (int)area;\r\n}\r\n#define HitTestTimeout(hwnd, x, y) HitTestTimeoutL(hwnd, MAKELPARAM(x, y))\r\n\r\n\r\n/* This is used to detect is the window was snapped normally outside of\r\n * AltDrag, in this case the window appears as normal\r\n * ie: wndpl.showCmd=SW_SHOWNORMAL, but  its actual rect does not match with\r\n * its rcNormalPosition and if the WM_RESTORE command is sent, The window\r\n * will be restored. This is a non documented behaviour. */\r\nstatic int IsWindowSnapped(HWND hwnd)\r\n{\r\n    RECT rect;\r\n    int W, H, nW, nH;\r\n    WINDOWPLACEMENT wndpl; wndpl.length =sizeof(WINDOWPLACEMENT);\r\n\r\n    if(!GetWindowRect(hwnd, &rect)) return 0;\r\n    W = rect.right  - rect.left;\r\n    H = rect.bottom - rect.top;\r\n\r\n    GetWindowPlacement(hwnd, &wndpl);\r\n    nW = wndpl.rcNormalPosition.right - wndpl.rcNormalPosition.left;\r\n    nH = wndpl.rcNormalPosition.bottom - wndpl.rcNormalPosition.top;\r\n\r\n    return wndpl.showCmd != SW_MAXIMIZE && (W != nW || H != nH);\r\n}\r\n\r\n/* Helper function to get the Min and Max tracking sizes */\r\nstatic void GetMinMaxInfoF(HWND hwnd, POINT *Min, POINT *Max, UCHAR flags)\r\n{\r\n    MINMAXINFO mmi;\r\n    mem00(&mmi, sizeof(mmi));\r\n    UINT dpi = GetDpiForWindow(hwnd);\r\n    mmi.ptMinTrackSize.x = GetSystemMetricsForDpi(SM_CXMINTRACK, dpi);\r\n    mmi.ptMinTrackSize.y = GetSystemMetricsForDpi(SM_CYMINTRACK, dpi);\r\n    mmi.ptMaxTrackSize.x = GetSystemMetricsForDpi(SM_CXMAXTRACK, dpi);\r\n    mmi.ptMaxTrackSize.y = GetSystemMetricsForDpi(SM_CYMAXTRACK, dpi);\r\n    *Min = mmi.ptMinTrackSize;\r\n    *Max = mmi.ptMaxTrackSize;\r\n    if ((flags&3) != 3) {\r\n        DWORD_PTR ret; // 32ms timeout\r\n        SendMessageTimeout(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&mmi, SMTO_ABORTIFHUNG, 32, &ret);\r\n        if(!(flags&1)) *Min = mmi.ptMinTrackSize;\r\n        if(!(flags&2)) *Max = mmi.ptMaxTrackSize;\r\n    }\r\n\r\n}\r\n\r\nstatic xpure int SamePt(const POINT a, const POINT b)\r\n{\r\n    return (a.x == b.x && a.y == b.y);\r\n}\r\n\r\n/* Limit x between l and h */\r\nstatic xpure int CLAMP(int l, int x, int h)\r\n{\r\n    return (x < l)? l: ((x > h)? h: x);\r\n}\r\n\r\n/* Says if a rect is inside another one */\r\nstatic pure BOOL RectInRect(const RECT *big, const RECT *wnd)\r\n{\r\n    return wnd->left >= big->left && wnd->top >= big->top\r\n        && wnd->right <= big->right && wnd->bottom <= big->bottom;\r\n}\r\n\r\nstatic pure BOOL RectInRectT(const RECT *big, const RECT *wnd, const int T)\r\n{\r\n    return wnd->left+T >= big->left && wnd->top+T >= big->top\r\n        && wnd->right <= big->right+T && wnd->bottom <= big->bottom+T;\r\n}\r\n\r\nstatic pure unsigned WhichSideRectInRect(const RECT *mon, const RECT *wnd)\r\n{\r\n    unsigned flag;\r\n    flag  = ((wnd->left == mon->left) & (mon->right-wnd->right > 16)) << 2;\r\n    flag |= ((wnd->right == mon->right) & (wnd->left-mon->left > 16)) << 3;\r\n    flag |= ((wnd->top == mon->top) & (mon->bottom-wnd->bottom > 16)) << 4;\r\n    flag |= ((wnd->bottom == mon->bottom) & (wnd->top-mon->top > 16)) << 5;\r\n\r\n    return flag;\r\n}\r\n\r\nstatic xpure int IsEqualT(int a, int b, int th)\r\n{\r\n    return (b - th <= a) & (a <= b + th);\r\n}\r\nstatic int IsInRangeT(int x, int a, int b, int T)\r\n{\r\n    return (a-T <= x) & (x <= b+T);\r\n}\r\nstatic pure int EqualRectT(const RECT *a, const RECT *b, const int T)\r\n{\r\n    return IsEqualT(a->left, b->left, T) && IsEqualT(a->right, b->right, T)\r\n        && IsEqualT(a->top, b->top, T) && IsEqualT(a->bottom, b->bottom, T);\r\n}\r\nstatic pure unsigned AreRectsAlignedT(const RECT *a, const RECT *b, const int tol)\r\n{\r\n    return IsEqualT(a->left, b->right, tol) << 2\r\n         | IsEqualT(a->top, b->bottom, tol) << 4\r\n         | IsEqualT(a->right, b->left, tol) << 3\r\n         | IsEqualT(a->bottom, b->top, tol) << 5;\r\n}\r\nstatic int InRange(int x, int a, int b)\r\n{\r\n    return (x >= a) && (x <= b);\r\n}\r\nstatic xpure int SegT(long ax, long bx, const long *_ay12, const long *_by12, int tol)\r\n{\r\n    const long by1 = _by12[0]; /* left/top */\r\n    const long by2 = _by12[2]; /* right/bottom */\r\n    const long ay1 = _ay12[0]; /* left/top */\r\n    const long ay2 = _ay12[2]; /* right/bottom */\r\n    return IsEqualT(ax, bx, tol) /* ax == bx */\r\n        && ( InRange(ay1, by1, by2)\r\n          || InRange(by1, ay1, ay2)\r\n          || InRange(ay2, by1, by2)\r\n          || InRange(by2, ay1, ay2) );\r\n}\r\n/* Tells if rect b is touching rect a and on which side\r\n * 2^X, x=2 for Left, 3 for right, 4 for top and 5 for Bottom*/\r\nstatic pure unsigned AreRectsTouchingT(const RECT *a, const RECT *b, const int tol)\r\n{\r\n    return SegT(a->left, b->right, &a->top, &b->top, tol) << 2 /* Left */\r\n         | SegT(a->right, b->left, &a->top, &b->top, tol) << 3 /* Right */\r\n         | SegT(a->top, b->bottom, &a->left, &b->left, tol) << 4 /* Top */\r\n         | SegT(a->bottom, b->top, &a->left, &b->left, tol) << 5; /* Bottom */\r\n}\r\nstatic void CropRect(RECT *__restrict__ wnd, const RECT *crop)\r\n{\r\n    wnd->left   = max(wnd->left,   crop->left);\r\n    wnd->top    = max(wnd->top,    crop->top);\r\n    wnd->right  = min(wnd->right,  crop->right);\r\n    wnd->bottom = min(wnd->bottom, crop->bottom);\r\n}\r\n\r\nstatic void CenterRectInRect(RECT *__restrict__ wnd, const RECT *mon)\r\n{\r\n    int width  = wnd->right  - wnd->left;\r\n    int height = wnd->bottom - wnd->top;\r\n    wnd->left = mon->left + (mon->right-mon->left)/2-width/2;\r\n    wnd->top  = mon->top  + (mon->bottom-mon->top)/2-height/2;\r\n    wnd->right  = wnd->left + width;\r\n    wnd->bottom = wnd->top  + height;\r\n}\r\n\r\nstatic void ClampPointInRect(const RECT *rc, POINT *__restrict__ pt)\r\n{\r\n    pt->x = CLAMP(rc->left, pt->x, rc->right-1);\r\n    pt->y = CLAMP(rc->top, pt->y, rc->bottom-1);\r\n}\r\nstatic void RectFromPts(RECT *rc, const POINT a, const POINT b)\r\n{\r\n    rc->left = min(a.x, b.x);\r\n    rc->top = min(a.y, b.y);\r\n    rc->right = max(a.x, b.x);\r\n    rc->bottom= max(a.y, b.y);\r\n}\r\n\r\n/* DownlevelLCIDToLocaleName in NLSDL.DLL */\r\n/* LCIDToLocaleName  in KERNEL32.DLL*/\r\n#ifdef _UNICODE\r\nstatic int LCIDToLocaleNameL(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)\r\n{\r\n    typedef int (WINAPI *funk_t)(LCID Locale, LPWSTR  lpName, int cchName, DWORD dwFlags);\r\n    funk_t funk = (funk_t)GetProcAddress(GetModuleHandleA(\"KERNEL32.DLL\"), \"LCIDToLocaleName\");\r\n\r\n    if (funk) { /* Function in KERNEL32.DLL */\r\n        return funk(Locale, lpName, cchName, dwFlags);\r\n    }\r\n    /* Unable to find KERNEL32.DLL::LCIDToLocaleName\r\n     * Try with NLSDL.DLL::DownlevelLCIDToLocaleName */\r\n    HINSTANCE h = LoadLibraryA(\"NLSDL.DLL\");\r\n    if (h) {\r\n        int ret=0;\r\n        funk = (funk_t)GetProcAddress(h, \"DownlevelLCIDToLocaleName\");\r\n        if (funk)\r\n            ret = funk(Locale, lpName, cchName, dwFlags);\r\n        FreeLibrary(h);\r\n        return ret;\r\n    }\r\n    return 0;\r\n}\r\n#endif // UNICODE\r\n\r\n#if 0\r\n/* Get the string inside the section returned by GetPrivateProfileSection */\r\nstatic void GetSectionOptionStr(const TCHAR *section, const char * const oname, const TCHAR *def, TCHAR * __restrict__ txt, size_t txtlen)\r\n{\r\n    if (section) {\r\n        TCHAR name[128];\r\n        str2tchar_s(name, ARR_SZ(name)-1, oname);\r\n        lstrcat_s(name, ARR_SZ(name), TEXT(\"=\")); /* Add equal at the end of name */\r\n        const TCHAR *p = section;\r\n        while (p[0] && p[1]) { /* Double NULL treminated string */\r\n            if(!lstrcmpi_samestart(p, name)) {\r\n                /* Copy the buffer */\r\n                lstrcpy_s(txt, txtlen, p+lstrlen(name));\r\n                return; /* DONE! */\r\n            } else {\r\n                /* Go to next string... */\r\n                p += lstrlen(p); /* p in on the '\\0' */\r\n                p++; /* next string start. */\r\n                if (!*p) break;\r\n            }\r\n        }\r\n    }\r\n    /* Default to the provided def string */\r\n    if (def)\r\n        lstrcpy_s(txt, txtlen, def);\r\n    else if (txtlen)\r\n        txt[0] = TEXT('\\0');  // Empty string\r\n}\r\n#endif\r\nstatic const TCHAR* GetSectionOptionCStr(const TCHAR *section, const char * const oname, const TCHAR *const def)\r\n{\r\n    TCHAR name[128];\r\n    str2tchar_s(name, ARR_SZ(name)-1, oname);\r\n    lstrcat_s(name, ARR_SZ(name), TEXT(\"=\")); /* Add equal at the end of name */\r\n    const TCHAR *p = section;\r\n    while (p[0] && p[1]) { /* Double NULL treminated string */\r\n        if(!lstrcmpi_samestart(p, name)) {\r\n            return p+lstrlen(name); /* DONE! */\r\n        } else {\r\n            /* Go to next string... */\r\n            p += lstrlen(p); /* p in on the '\\0' */\r\n            p++; /* next string start. */\r\n            if (!*p) break;\r\n        }\r\n    }\r\n    /* Default to the provided def string */\r\n    return def;\r\n}\r\n/* Get the int inside the section returned by GetPrivateProfileSection */\r\nstatic int GetSectionOptionInt(const TCHAR *section, const char * const oname, const int def)\r\n{\r\n    if (section) {\r\n        TCHAR name[128];\r\n        str2tchar_s(name, ARR_SZ(name)-1, oname);\r\n        lstrcat_s(name, ARR_SZ(name), TEXT(\"=\")); /* Add equal at the end of name */\r\n        const TCHAR *p = section;\r\n        while (p[0] && p[1]) { /* Double NULL treminated string */\r\n            if(!lstrcmpi_samestart(p, name)) {\r\n                /* DONE !*/\r\n                return strtoi(p+lstrlen(name));\r\n            } else {\r\n                /* Go to next string... */\r\n                p += lstrlen(p); /* p in on the '\\0' */\r\n                p++; /* next string start. */\r\n                if (!*p) break;\r\n            }\r\n        }\r\n    }\r\n    /* Default to the provided def value */\r\n    return def;\r\n}\r\n\r\n#endif\r\n"
        },
        {
          "name": "window.rc",
          "type": "blob",
          "size": 12.6455078125,
          "content": "#include <windows.h>\r\n\r\n#include \"resource.h\"\r\n#define MY_CBS_STYLE CBS_DROPDOWN|WS_TABSTOP|WS_VSCROLL|CBS_AUTOHSCROLL\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_ABOUTPAGE DIALOG 0, 0, 220, 225\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nCAPTION \"\" // ABOUT\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n    GROUPBOX        \"\",IDC_ABOUT_BOX, 3,1, 212,105\r\n\r\n    ICON            APP_ICON, IDC_STATIC, 15,15,0,0\r\n    LTEXT           \"\",IDC_VERSION, 48, 15, 160,8\r\n    EDITTEXT        IDC_URL, 48,25,160,10, ES_READONLY|NOT WS_BORDER\r\n    LTEXT           \"\",IDC_AUTHOR, 10, 40, 200, 8\r\n    LTEXT           \"https://stefansundin.com/\", 0, 10,50,200,10\r\n\r\n    LTEXT           \"\",IDC_AUTHOR2, 10, 65, 200, 8\r\n\r\n    LTEXT           \"\", IDC_LICENSE,10, 80, 200, 20\r\n\r\n    GROUPBOX        \"\",IDC_TRANSLATIONS_BOX,3,111,212,110\r\n    EDITTEXT        IDC_TRANSLATIONS,10,120,200,95, ES_MULTILINE|ES_AUTOHSCROLL|ES_READONLY|WS_VSCROLL\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_BLACKLISTPAGE DIALOG DISCARDABLE  0, 0, 220, 225\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nCAPTION \"\" // BLACKLIST\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n\r\n    GROUPBOX    \"\", IDC_BLACKLIST_BOX,           3,1,212,138\r\n    LTEXT       \"\", IDC_PROCESSBLACKLIST_HEADER, 10,11,200,8\r\n    EDITTEXT    IDC_PROCESSBLACKLIST,10,20, 200,14,ES_AUTOHSCROLL\r\n    LTEXT       \"\", IDC_BLACKLIST_HEADER,        10,36,200,8\r\n    EDITTEXT    IDC_BLACKLIST,       10,45, 200,14,ES_AUTOHSCROLL\r\n    LTEXT       \"\", IDC_SCROLLLIST_HEADER,         10,61,200,8\r\n    EDITTEXT    IDC_SCROLLLIST,      10,70, 200,14,ES_AUTOHSCROLL\r\n    LTEXT       \"\", IDC_MDISBL_HEADER,          10,86,200,8\r\n    EDITTEXT    IDC_MDIS,            10,95,200,14,ES_AUTOHSCROLL\r\n    LTEXT       \"\", IDC_PAUSEBL_HEADER,         10,111,200,8\r\n    EDITTEXT    IDC_PAUSEBL,         10,120,200,14,ES_AUTOHSCROLL\r\n\r\n    GROUPBOX    \"\", IDC_FINDWINDOW_BOX,          3,140,212,78\r\n    ICON        IDI_FIND,         IDC_FINDWINDOW,  12,160,16,16, SS_NOTIFY|SS_REALSIZEIMAGE\r\n    EDITTEXT    IDC_NEWRULE,      30,150,180,12,ES_AUTOHSCROLL\r\n    EDITTEXT    IDC_NEWPROGNAME,  30,165,95,12,ES_AUTOHSCROLL\r\n    RTEXT       \"STYLE:\", 0, 125,167,32,8\r\n    EDITTEXT    IDC_GWLSTYLE,  160,165,50,12,ES_AUTOHSCROLL\r\n\r\n    RTEXT       \"WM_NCHITTEST:\", IDC_STATIC, 10,183,60,8\r\n    EDITTEXT    IDC_NCHITTEST,  72,180,25,12,ES_AUTOHSCROLL\r\n    RTEXT       \"In DWM Buttons:\", IDC_STATIC, 10,197,60,8\r\n    EDITTEXT    IDC_DWMCAPBUTTON,  72,195,25,12,ES_AUTOHSCROLL\r\n    RTEXT       \"EXSTYLE:\", IDC_STATIC, 115,182,42,8\r\n    EDITTEXT    IDC_GWLEXSTYLE,  160,180,50,12,ES_AUTOHSCROLL\r\n    LTEXT       \"RECT:\", IDC_STATIC, 102,197,22,8\r\n    EDITTEXT    IDC_RECT,  125,195,85,12,ES_AUTOHSCROLL\r\n    LTEXT       \"\", IDC_WINHANDLES, 6,208,206,8\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_GENERALPAGE DIALOG 0, 0, 220, 225\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nEXSTYLE WS_EX_WINDOWEDGE\r\nCAPTION \"\" // GENERAL\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n    GROUPBOX      \"\", IDC_GENERAL_BOX,3,1,212,172\r\n    CONTROL       \"\",   IDC_AUTOFOCUS,     \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP|BS_MULTILINE,10,12,203,18\r\n    CONTROL       \"\",   IDC_AERO,          \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 30, 203,8\r\n    CONTROL       \"\",   IDC_SMARTAERO,     \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 40, 203,8\r\n    CONTROL       \"\",   IDC_SMARTERAERO,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 50, 203,8\r\n    CONTROL       \"\",   IDC_STICKYRESIZE,  \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 60, 203,8\r\n    CONTROL       \"\",   IDC_INACTIVESCROLL,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 70, 203,8\r\n    CONTROL       \"\",   IDC_MDI,           \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 80, 203,8\r\n    CONTROL       \"\",   IDC_RESIZEALL,     \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10, 90, 203,8\r\n    CONTROL       \"\",   IDC_USEZONES,      \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,100, 203,8\r\n    CONTROL       \"\",   IDC_PIERCINGCLICK, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,110, 203,8\r\n\r\n    GROUPBOX      \"\",   IDC_RESIZECENTER,  108,120, 104, 50\r\n    RADIOBUTTON   \"\",   IDC_RZCENTER_NORM, 112,130,  95,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON   \"\",   IDC_RZCENTER_BR,   112,140, 95,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON   \"\",   IDC_RZCENTER_MOVE, 112,150, 95,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON   \"\",   IDC_RZCENTER_CLOSE,112,160, 95,8, WS_GROUP|WS_TABSTOP\r\n\r\n    LTEXT         \"\",   IDC_AUTOSNAP_HEADER,10,122,95,8\r\n    COMBOBOX      IDC_AUTOSNAP, 10,131 ,95,120, CBS_DROPDOWNLIST|CBS_HASSTRINGS|WS_TABSTOP|WS_VSCROLL\r\n    LTEXT         \"\",   IDC_LANGUAGE_HEADER,10,145,95,8\r\n    COMBOBOX      IDC_LANGUAGE, 10,155,95,120, CBS_DROPDOWNLIST|CBS_HASSTRINGS|WS_TABSTOP|WS_VSCROLL\r\n\r\n    GROUPBOX      \"\",   IDC_AUTOSTART_BOX ,3,175,212,43\r\n    CONTROL       \"\",   IDC_AUTOSTART,        \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10,185,203,8\r\n    CONTROL       \"\",   IDC_AUTOSTART_HIDE,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10,195,145,8\r\n    CONTROL       \"\",   IDC_AUTOSTART_ELEVATE,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10,205,145,8\r\n    DEFPUSHBUTTON \"\",   IDC_ELEVATE, 157,200,55,14\r\n\r\n//    EDITTEXT      IDC_HELPPANNEL,220,5,175,210, NOT WS_TABSTOP|ES_MULTILINE|ES_READONLY\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_MOUSEPAGE DIALOG DISCARDABLE  0, 0, 220, 230\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nCAPTION \"\" // MOUSE\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n    GROUPBOX  \"\", IDC_MOUSE_BOX,    3,1,212,178\r\n    RADIOBUTTON \"\", IDC_MBA1,   10,10,60,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON \"\", IDC_MBA2,   75,10,60,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON \"\", IDC_INTTB, 140,10,60,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON \"\", IDC_WHILEM, 10,20,100,8, WS_GROUP|WS_TABSTOP\r\n    RADIOBUTTON \"\", IDC_WHILER,111,20,100,8, WS_GROUP|WS_TABSTOP\r\n\r\n    LTEXT     \"\", IDC_LMB_HEADER, 10,33,95,8\r\n    COMBOBOX  IDC_LMB,   105,30,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_MMB_HEADER, 10,47,95,8\r\n    COMBOBOX  IDC_MMB,   105,44,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_RMB_HEADER, 10,61,95,8\r\n    COMBOBOX  IDC_RMB,   105,58,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_MB4_HEADER, 10,75,95,8\r\n    COMBOBOX  IDC_MB4,   105,72,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_MB5_HEADER, 10,89,95,8\r\n    COMBOBOX  IDC_MB5,   105,86,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_SCROLL_HEADER,10,103,95,8\r\n    COMBOBOX  IDC_SCROLL,105,100,105,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_HSCROLL_HEADER,10,117,95,8\r\n    COMBOBOX  IDC_HSCROLL,105,114,105,160, MY_CBS_STYLE\r\n\r\n    LTEXT     \"\", IDC_MOVEUP_HEADER,10,131,105,8\r\n    COMBOBOX  IDC_MOVEUP,115,128,95,160, MY_CBS_STYLE\r\n    LTEXT     \"\", IDC_RESIZEUP_HEADER,10,145,105,8\r\n    COMBOBOX  IDC_RESIZEUP,115,142,95,160, MY_CBS_STYLE\r\n\r\n    GROUPBOX  \"\", IDC_TTBACTIONS_BOX,  6,155,206,21\r\n    CONTROL   \"\", IDC_TTBACTIONSNA, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 12,165,95,8\r\n    CONTROL   \"\", IDC_TTBACTIONSWA, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 112,165,95,8\r\n\r\n    GROUPBOX  \"\", IDC_HOTCLICKS_BOX,  3,179,212,51\r\n    CONTROL   \"\", IDC_MMB_HC,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10 ,188,80,10\r\n    CONTROL   \"\", IDC_MB4_HC,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10 ,198,80,10\r\n    CONTROL   \"\", IDC_MB5_HC,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10 ,208,80,10\r\n    CONTROL   \"\", IDC_LONGCLICKMOVE,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10 ,218,203,10\r\n    RTEXT     \"\", IDC_HOTCLICKS_MORE, 100,186,110,32\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_KBPAGE DIALOG DISCARDABLE  0, 0, 220, 225\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nCAPTION \"\" // KEYBOARD\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n    GROUPBOX    \"\", IDC_KEYBOARD_BOX,    3,1,212,138\r\n    LTEXT       \"\", IDC_GRABWITHALT_H, 10,13,90,8\r\n    COMBOBOX    IDC_GRABWITHALT,   105,10,105,160, MY_CBS_STYLE\r\n    LTEXT       \"\", IDC_GRABWITHALTB_H,10,27,90,8\r\n    COMBOBOX    IDC_GRABWITHALTB,  105,24,105,160, MY_CBS_STYLE\r\n\r\n    CONTROL     \"\", IDC_SCROLLLOCKSTATE,\"Button\", BS_AUTOCHECKBOX|WS_TABSTOP|BS_MULTILINE,10,40,203,16\r\n    CONTROL     \"\", IDC_UNIKEYHOLDMENU, \"Button\", BS_AUTOCHECKBOX|WS_TABSTOP|BS_MULTILINE,10,60,203,16\r\n\r\n    LTEXT       \"\", IDC_SHORTCUTS_H,  10,82,90,8\r\n    COMBOBOX    IDC_SHORTCUTS_AC, 105,80,105,160, MY_CBS_STYLE\r\n    RTEXT       \"vKey:\", 0,  60,98,20,8\r\n    EDITTEXT    IDC_SHORTCUTS_VK, 85, 96, 16, 12\r\n    LTEXT       \"\", IDC_SHORTCUTS, 104,98,55,8\r\n    CONTROL     \"\", IDC_SHIFT,  \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,98,50,8\r\n    CONTROL     \"\", IDC_CONTROL,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,112,50,8\r\n    CONTROL     \"\", IDC_WINKEY, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 60,112,50,8\r\n    CONTROL     \"\", IDC_ALT,    \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,110,112,50,8\r\n    DEFPUSHBUTTON \"\", IDC_SHORTCUTS_PICK, 160, 95, 50, 13\r\n    DEFPUSHBUTTON \"\", IDC_SHORTCUTS_CLEAR, 160, 109, 50, 13\r\n    DEFPUSHBUTTON \"\", IDC_SHORTCUTS_SET, 160, 123, 50, 13\r\n    CONTROL     \"\", IDC_USEPTWINDOW, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,10,125,150,8\r\n\r\n    GROUPBOX    \"\",    IDC_HOTKEYS_BOX,  3,139,212, 80\r\n    LTEXT       \"\", IDC_MODKEY_H, 10,152,150,8\r\n    COMBOBOX    IDC_MODKEY,   160,149,50,120, MY_CBS_STYLE\r\n    CONTROL     \"\", IDC_LEFTALT,    \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,165,60,8\r\n    CONTROL     \"\", IDC_RIGHTALT,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,175,60,8\r\n    CONTROL     \"\", IDC_LEFTWINKEY, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 71,165,72,8\r\n    CONTROL     \"\", IDC_RIGHTWINKEY,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 71,175,72,8\r\n    CONTROL     \"\", IDC_LEFTCTRL,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,145,165,65,8\r\n    CONTROL     \"\", IDC_RIGHTCTRL,  \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP,145,175,65,8\r\n\r\n    CONTROL     \"\", IDC_KEYCOMBO,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,187,203,8\r\n    LTEXT       \"\", IDC_HOTKEYS_MORE, 10,197,203,20\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\nIDD_ADVANCEDPAGE DIALOG DISCARDABLE  0, 0, 220, 225\r\nSTYLE WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_3DLOOK\r\nCAPTION \"\" // ADVANCED\r\nFONT 8, \"Ms Shell Dlg\"\r\nBEGIN\r\n    GROUPBOX  \"\", IDC_METRICS_BOX, 3,1,212,101\r\n    LTEXT     \"\", IDC_CENTERFRACTION_H, 10,12,130,8\r\n    EDITTEXT  IDC_CENTERFRACTION, 143, 10, 30, 12, ES_NUMBER\r\n    LTEXT     \"/\", IDC_STATIC, 175,12,7,8\r\n    EDITTEXT  IDC_SIDESFRACTION,  180, 10, 30, 12, ES_NUMBER\r\n\r\n    LTEXT     \"\", IDC_AEROHOFFSET_H, 10,25,90,8\r\n    EDITTEXT  IDC_AEROHOFFSET, 100, 23, 30, 12, ES_NUMBER\r\n    RTEXT     \"\", IDC_AEROVOFFSET_H, 132,25,45,8\r\n    EDITTEXT  IDC_AEROVOFFSET, 180, 23, 30, 12, ES_NUMBER\r\n\r\n    LTEXT     \"\", IDC_SNAPTHRESHOLD_H, 10,38,165,8\r\n    EDITTEXT  IDC_SNAPTHRESHOLD, 180, 36, 30, 12, ES_NUMBER\r\n    LTEXT     \"\", IDC_AEROTHRESHOLD_H, 10,51,165,8\r\n    EDITTEXT  IDC_AEROTHRESHOLD, 180, 49, 30, 12, ES_NUMBER\r\n    LTEXT     \"\", IDC_SNAPGAP_H, 10,64,165,8\r\n    EDITTEXT  IDC_SNAPGAP, 180, 62, 30, 12\r\n\r\n    LTEXT     \"\", IDC_AEROSPEED_H, 10,76,130,8\r\n    EDITTEXT  IDC_AEROSPEED, 140, 74, 30, 12, ES_NUMBER\r\n    LTEXT     \"/\", 0, 172,76,10,8\r\n    LTEXT     \"\", IDC_AEROSPEEDTAU, 178, 76, 20, 8, ES_READONLY\r\n    LTEXT     \"ms\", IDC_STATIC, 195,76,10,8\r\n\r\n    LTEXT     \"\", IDC_MOVETRANS_H, 10,90,100,8\r\n    EDITTEXT  IDC_MOVETRANS, 110, 88, 25, 12, ES_NUMBER\r\n\r\n    DEFPUSHBUTTON   \"\",  IDC_TESTWINDOW, 138,88,73,12\r\n\r\n    GROUPBOX  \"\", IDC_BEHAVIOR_BOX,  3,103,212,122\r\n    CONTROL   \"\", IDC_MULTIPLEINSTANCES,\"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,113,203,8\r\n    CONTROL   \"\", IDC_AUTOREMAXIMIZE,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,123,203,8\r\n    CONTROL   \"\", IDC_AEROTOPMAXIMIZES, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,133,203,8\r\n    CONTROL   \"\", IDC_AERODBCLICKSHIFT, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,143,203,8\r\n    CONTROL   \"\", IDC_MAXWITHLCLICK,    \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,153,203,8\r\n    CONTROL   \"\", IDC_RESTOREONCLICK,   \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,163,203,8\r\n    CONTROL   \"\", IDC_FULLSCREEN,       \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,173,203,8\r\n    CONTROL   \"\", IDC_BLMAXIMIZED,      \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,183,203,8\r\n    CONTROL   \"\", IDC_FANCYZONE,        \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,193,203,8\r\n    CONTROL   \"\", IDC_NORESTORE,        \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,203,203,8\r\n    CONTROL   \"\", IDC_TOPMOSTINDICATOR, \"Button\",BS_AUTOCHECKBOX|WS_TABSTOP, 10,213,203,8\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Cursor\r\nIDI_FIND                CURSOR  DISCARDABLE     \"media/find.cur\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Icon with lowest ID value placed first to ensure application icon\r\n// remains consistent on all systems.\r\nIDI_FIND                ICON    DISCARDABLE     \"media/find.ico\"\r\n"
        },
        {
          "name": "ziprelease.bat",
          "type": "blob",
          "size": 0.1357421875,
          "content": "advzipNT -a4 -i 128 AltSnap_bin.zip AltSnap.txt AltSnap.exe hooks.dll AltSnap.ini AltSnap.xml License.txt Lang\\*\r\nDeflopt AltSnap_bin.zip\r\n"
        },
        {
          "name": "zones.c",
          "type": "blob",
          "size": 21.0751953125,
          "content": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n * (C) Raymond GILLIBERT                                                 *\r\n * Functions to handle Snap Layouts under AltSnap                        *\r\n * General Public License Version 3 or later (Free Software Foundation)  *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\r\n\r\n#include \"hooks.h\"\r\nstatic void MouseMove(POINT pt);\r\nstatic void ShowSnapLayoutPreview(unsigned char yep);\r\n\r\nenum { MAX_ZONES=2048, MAX_LAYOUTS=10 };\r\n#define INVALID_ZONE_IDX 0xffffffffU\r\n\r\nRECT *Zones[MAX_LAYOUTS];\r\nunsigned nzones[MAX_LAYOUTS];\r\nDWORD Grids[MAX_LAYOUTS];\r\n\r\nenum { ZONES_PREV_HIDE=0, ZONES_PREV_SHOW=1 };\r\n\r\n\r\nstatic void freezones()\r\n{\r\n    unsigned i;\r\n    for (i=0; i<ARR_SZ(Zones);i++)\r\n        free(Zones[i]);\r\n}\r\nstatic int ReadRectFromini(RECT *zone, unsigned laynum, unsigned idx, const TCHAR *inisection)\r\n{\r\n    if (idx > MAX_ZONES) return 0;\r\n\r\n    long *ZONE = (long *)zone;\r\n    char zname[32]=\"\";\r\n    TCHAR zaschii[128];\r\n\r\n    LPCTSTR txt = GetSectionOptionCStr(inisection, ZidxToZonestrA(laynum, idx, zname), NULL);\r\n    if (!txt || !txt[0])\r\n        return 0;\r\n    //LOGA(\"Zone(%u, %u) = %S\", laynum, idx, txt);\r\n    // Copy to modifyable buffer.\r\n    lstrcpy_s(zaschii, ARR_SZ(zaschii), txt);\r\n    TCHAR *oldptr, *newptr;\r\n    oldptr = &zaschii[0];\r\n    UCHAR i;\r\n    for (i=0; i < 4; i++) {\r\n        newptr = lstrchr(oldptr, ',');\r\n        if (!newptr) return 0;\r\n        *newptr = '\\0';\r\n        newptr++;\r\n        if(!*oldptr) return 0;\r\n        ZONE[i] = strtoi(oldptr); // 0 left, 1 top, 2 right, 3 bottom;\r\n        oldptr = newptr;\r\n    }\r\n    return 1;\r\n}\r\nstatic void ReadZonesFromLayout(const TCHAR *inisection, unsigned laynum)\r\n{\r\n    nzones[laynum] = 0;\r\n    Zones[laynum] = NULL;\r\n    RECT tmpzone;\r\n    while (ReadRectFromini(&tmpzone, laynum, nzones[laynum], inisection)) {\r\n        RECT *tmp = (RECT *)realloc( Zones[laynum], (nzones[laynum]+1) * sizeof(*tmp) );\r\n        if(!tmp) return;\r\n        Zones[laynum] = tmp;\r\n        CopyRect(&Zones[laynum][nzones[laynum]++], &tmpzone);\r\n    }\r\n}\r\n// Load all zones from ini file\r\nstatic void ReadZones(const TCHAR *inisection)\r\n{\r\n    UCHAR i;\r\n    for(i=0; i<ARR_SZ(Zones); i++)\r\n        ReadZonesFromLayout(inisection, i);\r\n}\r\nstatic unsigned CopyZones(RECT *dZones, unsigned idx)\r\n{\r\n    unsigned i;\r\n    RECT * const lZones = Zones[idx];\r\n    for (i=0; i < nzones[idx]; ++i) {\r\n        CopyRect(&dZones[i], &lZones[i]);\r\n    }\r\n    return i;\r\n}\r\n// Generate a grid if asked\r\nstatic void GenerateGridZones(unsigned layout, unsigned short Nx, unsigned short Ny)\r\n{\r\n    // Enumerate monitors\r\n    nummonitors = 0;\r\n    unsigned nz = 0;\r\n    EnumDisplayMonitors(NULL, NULL, EnumMonitorsProc, 0);\r\n    RECT *tmp = (RECT *)realloc(Zones[layout], nummonitors * Nx * Ny * sizeof(*tmp));\r\n    if(!tmp) return;\r\n    Zones[layout] = tmp;\r\n\r\n    // Loop on all monitors\r\n    unsigned m;\r\n    for (m=0; m<nummonitors; m++) {\r\n        const RECT *mon = &monitors[m];\r\n        unsigned i;\r\n        for(i=0; i<Nx; i++) { // Horizontal\r\n            unsigned j;\r\n            for(j=0; j<Ny; j++) { //Vertical\r\n                Zones[layout][nz].left  = mon->left+(( i ) * (mon->right - mon->left))/Nx;\r\n                Zones[layout][nz].top   = mon->top +(( j ) * (mon->bottom - mon->top))/Ny;\r\n                Zones[layout][nz].right = mon->left+((i+1) * (mon->right - mon->left))/Nx;\r\n                Zones[layout][nz].bottom= mon->top +((j+1) * (mon->bottom - mon->top))/Ny;\r\n                nz++;\r\n            }\r\n        }\r\n    }\r\n    nzones[layout] = nz;\r\n}\r\nstatic void ReadGrids(const TCHAR *inisection)\r\n{\r\n    UCHAR i;\r\n    char gnamex[8];\r\n    char gnamey[8];\r\n    strcpy(gnamex, \"GridNx\");\r\n    strcpy(gnamey, \"GridNy\");\r\n    gnamex[7] = '\\0';\r\n    gnamey[7] = '\\0';\r\n    for (i=0; i < ARR_SZ(Grids); i++) {\r\n        Grids[i] = 0;\r\n        unsigned short GridNx = GetSectionOptionInt(inisection, gnamex, 0);\r\n        unsigned short GridNy = GetSectionOptionInt(inisection, gnamey, 0);\r\n        if (GridNx && GridNy && GridNx*GridNy <= MAX_ZONES) {\r\n            Grids[i] = GridNx | GridNy << 16; // Store grid dimentions\r\n            GenerateGridZones(i, GridNx, GridNy);\r\n        }\r\n        // GridNx1, GridNx2, GridNx3...\r\n        gnamex[6] = '1' + i;\r\n        gnamey[6] = '1' + i;\r\n    }\r\n}\r\n// Recalculate the zones from the Grid info.\r\n// Needed in case resolution changes.\r\nstatic void RecalculateZonesFromGrids()\r\n{\r\n    UCHAR i;\r\n    for (i=0; i<ARR_SZ(Grids); i++) {\r\n        unsigned short GridNx = LOWORD(Grids[i]);\r\n        unsigned short GridNy = HIWORD(Grids[i]);\r\n        if(GridNx && GridNy)\r\n            GenerateGridZones(i, GridNx, GridNy);\r\n    }\r\n}\r\n\r\nstatic xpure unsigned long PtDist2(POINT pt, POINT Zpt)\r\n{\r\n    long dx = (pt.x - Zpt.x)>>1;\r\n    long dy = (pt.y - Zpt.y)>>1;\r\n\r\n    return dx*dx + dy*dy;\r\n}\r\n\r\n\r\nstatic xpure unsigned long ClacPtRectDist(const POINT pt, const RECT *zone)\r\n{\r\n    POINT Zpt = { (zone->left+zone->right)/2, (zone->top+zone->bottom)/2 };\r\n    return PtDist2(pt, Zpt);\r\n}\r\n\r\nstatic unsigned GetNearestZoneDist(POINT pt, unsigned long *dist_)\r\n{\r\n    RECT * const lZones = Zones[conf.LayoutNumber];\r\n    if(!lZones) return 0;\r\n    unsigned long dist = 0xffffffff;\r\n    unsigned idx = 0;\r\n    unsigned i;\r\n    for (i=0; i < nzones[conf.LayoutNumber]; i++) {\r\n        unsigned long dst = ClacPtRectDist(pt, &lZones[i]);\r\n        if ( dst < dist ) {\r\n            dist = dst;\r\n            idx = i;\r\n        }\r\n    }\r\n    *dist_ = dist;\r\n    return idx;\r\n}\r\n\r\nstatic unsigned GetZoneNearestFromPoint(POINT pt, RECT *urc, int extend)\r\n{\r\n\r\n    RECT * const lZones = Zones[conf.LayoutNumber];\r\n    if(!lZones) return 0;\r\n    unsigned i, ret=0;\r\n    SetRectEmpty(urc);\r\n    int iz = conf.InterZone;\r\n    iz = (iz * iz) << 1;\r\n    unsigned long mindist=0;\r\n\r\n    i = GetNearestZoneDist(pt, &mindist);\r\n    ret = mindist != 0xffffffff;\r\n    if (!ret) return 0;\r\n    CopyRect(urc, &lZones[i]);\r\n    mindist += iz; // Add iz tolerance.\r\n    for (i=0; i < nzones[conf.LayoutNumber]; i++) {\r\n\r\n        BOOL inrect = mindist > ClacPtRectDist(pt, &lZones[i]);\r\n        if ((state.ctrl||extend) && !inrect)\r\n            inrect = mindist > ClacPtRectDist(extend?state.shiftpt:state.ctrlpt, &lZones[i]);\r\n\r\n        if (inrect) {\r\n            UnionRect(urc, urc, &lZones[i]);\r\n            ret++;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nstatic unsigned GetZoneContainingPoint(POINT pt, RECT *urc, int extend)\r\n{\r\n\r\n    RECT * const lZones = Zones[conf.LayoutNumber];\r\n    if(!lZones) return 0;\r\n    unsigned i, ret=0;\r\n    SetRectEmpty(urc);\r\n    int iz = conf.InterZone;\r\n    for (i=0; i < nzones[conf.LayoutNumber]; i++) {\r\n        if (iz) InflateRect(&lZones[i], iz, iz);\r\n\r\n        int inrect=0;\r\n        inrect = PtInRect(&lZones[i], pt);\r\n        if ((state.ctrl||extend) && !inrect)\r\n            inrect = PtInRect(&lZones[i], extend?state.shiftpt:state.ctrlpt);\r\n\r\n        if (iz) InflateRect(&lZones[i], -iz, -iz);\r\n        if (inrect) {\r\n            UnionRect(urc, urc, &lZones[i]);\r\n            ret++;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nstatic unsigned GetZoneFromPoint(POINT pt, RECT *urc, int extend)\r\n{\r\n    switch (conf.ZSnapMode) {\r\n    case 0: return GetZoneContainingPoint(pt, urc, extend);\r\n    case 1: return GetZoneNearestFromPoint(pt, urc, extend);\r\n    }\r\n    // Invalid Snap mode!\r\n    return 0;\r\n}\r\nstatic int pure IsResizable(HWND hwnd);\r\n\r\nstatic void ActionToggleSnapToZoneMode()\r\n{\r\n    if (conf.UseZones&1 && state.action == AC_MOVE) {\r\n        state.usezones = !state.usezones;\r\n        MouseMove(state.prevpt);\r\n    }\r\n}\r\nstatic void MoveSnapToZone(POINT pt, int *posx, int *posy, int *width, int *height)\r\n{\r\n    if(!(conf.UseZones&1) || state.mdiclient || !state.resizable) // Zones disabled\r\n        return;\r\n\r\n    static POINT oldpt;\r\n    if(state.Speed > conf.AeroMaxSpeed)\r\n        pt=oldpt; // do not move the window if speed is too high.\r\n    else\r\n        oldpt=pt;\r\n\r\n    if (conf.UseZones&8 && state.snap != conf.AutoSnap) // Zones toggled by other click\r\n        return;\r\n\r\n    if (!state.usezones) {\r\n        ShowSnapLayoutPreview(ZONES_PREV_HIDE);\r\n        return;\r\n    }\r\n\r\n    ShowSnapLayoutPreview(ZONES_PREV_SHOW);\r\n    RECT rc, bd;\r\n    unsigned ret = GetZoneFromPoint(pt, &rc, conf.UseZones&4);\r\n    if (!ret) return; // Outside of a rect\r\n\r\n    LastWin.end = 0;\r\n    FixDWMRect(state.hwnd, &bd);\r\n    InflateRectBorder(&rc, &bd);\r\n\r\n    SetRestoreData(state.hwnd, state.origin.width, state.origin.height, SNAPPED|SNZONE);\r\n    *posx = rc.left;\r\n    *posy = rc.top;\r\n    *width = rc.right - rc.left;\r\n    *height = rc.bottom - rc.top;\r\n}\r\n\r\nstatic xpure int IsPtInCone(POINT pt, POINT op, UCHAR direction)\r\n{\r\n    const long dx = pt.x - op.x, dy = pt.y - op.y;\r\n    switch (direction) {\r\n    case 0: // LEFT\r\n        return dx <= 0 && (dy <= -dx && dy > dx);\r\n\r\n    case 1: // TOP\r\n        return dy <= 0 && (dx <= -dy && dx > dy);\r\n\r\n    case 2: // RIGHT\r\n        return dx > 0 && (dy <= dx && dy > -dx);\r\n\r\n    case 3: // BOTTOM\r\n        return dy > 0 && (dx <= dy && dx > -dy);\r\n    }\r\n    return 0;\r\n}\r\nstatic unsigned GetNearestZoneFromPointInDirection(const RECT *rc, RECT *out, UCHAR direction)\r\n{\r\n    unsigned idx = INVALID_ZONE_IDX;\r\n    RECT * const lZones = Zones[conf.LayoutNumber];\r\n    unsigned nZones = nzones[conf.LayoutNumber];\r\n    if(!lZones) return 0;\r\n\r\n    POINT opt = { (rc->left+rc->right)/2, (rc->top+rc->bottom)/2 };\r\n\r\n    unsigned long dist = 0xffffffff;\r\n    for(unsigned i=0; i < nZones; i++) {\r\n        const RECT *zrc = &lZones[i];\r\n        const POINT pt = { (zrc->left+zrc->right)/2, (zrc->top+zrc->bottom)/2 };\r\n        unsigned long dst = PtDist2(pt, opt);\r\n        if (!EqualRect(rc, zrc) && dst < dist && IsPtInCone(pt, opt, direction)) {\r\n            dist = dst;\r\n            idx = i;\r\n        }\r\n    }\r\n\r\n    if (idx != INVALID_ZONE_IDX) {\r\n        CopyRect(out, &lZones[idx]);\r\n        return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n//\r\n//static void SnapToRect(HWND hwnd, RECT *fr)\r\n//{\r\n//    RECT bd;\r\n//    LastWin.end = 0;\r\n//    FixDWMRect(hwnd, &bd);\r\n//    InflateRectBorder(fr, &bd);\r\n//\r\n//    SetRestoreData(hwnd, state.origin.width, state.origin.height, SNAPPED|SNZONE);\r\n//    MoveWindowAsync(hwnd, fr->left, fr->top, CLAMPW(fr->right-fr->left), CLAMPH(fr->bottom-fr->top));\r\n//}\r\n\r\nstatic void SetOriginFromRestoreData(HWND hnwd, enum action action);\r\nstatic HMONITOR GetMonitorInfoFromWin(HWND hwnd, MONITORINFO *mi);\r\nstatic void MoveWindowToTouchingZone(HWND hwnd, UCHAR direction, UCHAR extend)\r\n{\r\n    if(!(conf.UseZones&1) || state.mdiclient || !state.resizable) // Zones disabled\r\n        return;\r\n\r\n    SetOriginFromRestoreData(hwnd, AC_MOVE);\r\n    // 1st get current window position.\r\n    RECT rc;\r\n    GetWindowRectL(hwnd, &rc);\r\n    POINT pt;\r\n\r\n    int offset = abs(conf.InterZone)+16;\r\n\r\n    if        (direction == 0) { // LEFT\r\n        pt.x = rc.left - offset; // Mid Left segment\r\n        pt.y = (rc.top+rc.bottom)/2;\r\n    } else if (direction == 1) { // TOP\r\n        pt.x = (rc.right+rc.left)/2; // Mid Top segment\r\n        pt.y = rc.top - offset;\r\n    } else if (direction == 2) { // RIGHT\r\n        pt.x = rc.right + offset; // Mid Right segment\r\n        pt.y = (rc.top+rc.bottom)/2;\r\n    } else if (direction == 3) { // BOTTOM\r\n        pt.x = (rc.right+rc.left)/2; // Mid Bottom segment\r\n        pt.y = rc.bottom + offset;\r\n    }\r\n    if (IsZoomed(hwnd) && extend) return;\r\n\r\n    // Clamp point inside monitor\r\n    MONITORINFO mi;\r\n    GetMonitorInfoFromWin(hwnd, &mi);\r\n    ClampPointInRect(&mi.rcWork, &pt);\r\n\r\n    RECT zrc;\r\n    unsigned ret=0;\r\n    switch (conf.ZSnapMode) {\r\n        case 0: ret = GetZoneContainingPoint(pt, &zrc, 0); break;\r\n        case 1: ret = GetNearestZoneFromPointInDirection(&rc, &zrc, direction); break;\r\n    }\r\n    if (!ret) return; // Outside of a rect\r\n\r\n    RECT fr; // final rect...\r\n    if (extend) { // extend the zone instead.\r\n        UnionRect(&fr, &rc, &zrc); // Union of original and new rect\r\n    } else {\r\n        CopyRect(&fr, &zrc);\r\n    }\r\n    LastWin.end = 0;\r\n    RECT bd;\r\n    FixDWMRect(hwnd, &bd);\r\n    InflateRectBorder(&fr, &bd);\r\n\r\n    SetRestoreData(hwnd, state.origin.width, state.origin.height, SNAPPED|SNZONE);\r\n    MoveWindowAsync(hwnd, fr.left, fr.top, CLAMPW(fr.right-fr.left), CLAMPH(fr.bottom-fr.top));\r\n}\r\n// Sets urc as the union of all the rcs array or RECT, of length N\r\nstatic void UnionMultiRect(RECT *urc, const RECT *rcs, unsigned N)\r\n{\r\n    CopyRect(urc, &rcs[0]);\r\n    while (--N) {\r\n        rcs++;\r\n        urc->left    = min(urc->left,   rcs->left);\r\n        urc->top     = min(urc->top,    rcs->top);\r\n        urc->right   = max(urc->right,  rcs->right);\r\n        urc->bottom  = max(urc->bottom, rcs->bottom);\r\n    }\r\n}\r\nstatic pure DWORD GetLayoutRez(int laynum)\r\n{\r\n    laynum = CLAMP(0, laynum, ARR_SZ(Zones)-1);\r\n    if (conf.UseZones&2) {\r\n        // In Grid mode we return the grid dimentions!\r\n        return Grids[laynum];\r\n    }\r\n    unsigned nz = nzones[laynum];\r\n    const RECT *zone = Zones[laynum];\r\n    if (!zone || !nz) return 0;\r\n    RECT urc;\r\n    UnionMultiRect(&urc, zone, nz);\r\n    return  (urc.right-urc.left) | (urc.bottom-urc.top)<<16;\r\n}\r\n// Calculate the dimentions of union rectangle that contains all\r\n// the work area of every monitors.\r\nstatic DWORD GetFullMonitorsRez()\r\n{\r\n    // Enumerate monitors\r\n    EnumDisplayMonitors(NULL, NULL, EnumMonitorsProc, 0);\r\n    if (!monitors || !nummonitors)\r\n        return 0; // ERROR! do nothing\r\n    RECT urc;\r\n    UnionMultiRect(&urc, monitors, nummonitors);\r\n\r\n    // Return dimentions width:height\r\n    return (urc.right-urc.left) | (urc.bottom-urc.top)<<16;\r\n}\r\n\r\n// Return a layout number if its dimentions exactly fit\r\n// the display monitor.\r\nstatic int GetBestLayoutFromMonitors()\r\n{\r\n    if (!(conf.UseZones&1))\r\n        return -1;\r\n    if (conf.UseZones&2) {\r\n        // Grid mode! Do not change Grid, just recalculate them all...\r\n        RecalculateZonesFromGrids();\r\n        return -1; // DONE!\r\n    }\r\n    DWORD curRZ = GetLayoutRez(conf.LayoutNumber);\r\n\r\n    // If the current rez is 0:0 we should not change it.\r\n    // Because it can be used as a dummy mode, plus a user\r\n    // might have selected it in advance to configure it\r\n    // later for the new display settings, so selecting\r\n    // an other one would bother him.\r\n    if (!curRZ)\r\n        return -1;\r\n\r\n    // Check if the current Layout is good for the current monitor\r\n    DWORD monRZ;\r\n    if (nummonitors <= 1) {\r\n        RECT mrc;\r\n        SystemParametersInfo(SPI_GETWORKAREA, 0, &mrc, 0);\r\n        monRZ = (mrc.right-mrc.left) | (mrc.bottom-mrc.top)<<16;\r\n        // In Single monitor mode we use SPI_GETWORKAREA.\r\n        // Because EnumDisplayMonitor often gives bad values.\r\n        // I am unsure on how to properly handle multiple monitors...\r\n        if(monRZ == curRZ) {\r\n            return -1; // Current layout is good!\r\n        }\r\n    } else if ( (monRZ = GetFullMonitorsRez()) == curRZ ) {\r\n        // GetFullMonitorsRez gives us the union of all monitors.rcWork\r\n        return -1; // Current layout is good!\r\n    }\r\n\r\n    UCHAR i;\r\n    for (i=0; i<ARR_SZ(Zones); i++) {\r\n        DWORD rez = GetLayoutRez(i);\r\n        if( rez == monRZ )\r\n            return i;\r\n    }\r\n    // No perfect match found!\r\n    return -1;\r\n}\r\n\r\nstatic HWND g_zphwnd = NULL;\r\nCOLORREF g_ZPrevBDCol=RGB(0,0,0);\r\nLRESULT CALLBACK SnapLayoutWinProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n    static HPEN pen = NULL;\r\n\r\n    switch (msg) {\r\n    case WM_CREATE: {\r\n        pen = (HPEN)CreatePen(PS_INSIDEFRAME, 4, g_ZPrevBDCol);\r\n    } break;\r\n\r\n    case WM_PAINT: {\r\n        // Create Font\r\n//        struct NEWNONCLIENTMETRICSAW ncm;\r\n//        int dpi = GetDpiForWindow(hwnd);\r\n//        GetNonClientMetricsDpi(&ncm, dpi);\r\n//        ncm.lfCaptionFont.lfHeight = 64;\r\n//        HFONT font = CreateFontIndirect(&ncm.lfCaptionFont);\r\n\r\n        PAINTSTRUCT ps;\r\n        POINT opt = { 0, 0 };\r\n        ScreenToClient(hwnd, &opt);\r\n        BeginPaint(hwnd, &ps);\r\n        HPEN oldpen = (HPEN)SelectObject(ps.hdc, pen);\r\n//        HFONT oldfont = (HFONT)SelectObject(ps.hdc, font);\r\n        // PaintDesktop(ps.hdc);\r\n        HBRUSH oldBrush = (HBRUSH)SelectObject(ps.hdc, GetStockObject(HOLLOW_BRUSH));\r\n        for (size_t i=0; i < nzones[conf.LayoutNumber]; i++) {\r\n            RECT *rc = &Zones[conf.LayoutNumber][i];\r\n            if (!AreRectsTouchingT(rc, &ps.rcPaint, 0)) {\r\n//                TCHAR buf[16]; SIZE sz;\r\n//                const TCHAR *num = Int2lStr(buf, i);\r\n//                int txtlen = lstrlen(num);\r\n//                GetTextExtentPoint32(ps.hdc, num, txtlen, &sz);\r\n//                int txtX = (rc->left + rc->right - sz.cx) / 2 + opt.x;\r\n//                int txtY = (rc->top + rc->bottom - sz.cy) / 2 + opt.y;\r\n//                TextOut(ps.hdc, txtX, txtY, num, txtlen);\r\n                Rectangle(ps.hdc, rc->left+opt.x, rc->top+opt.y, rc->right+opt.x, rc->bottom+opt.y);\r\n            }\r\n        }\r\n//        SelectObject(ps.hdc, oldfont);  // Restore old font\r\n        SelectObject(ps.hdc, oldBrush); // Restore old pen\r\n        SelectObject(ps.hdc, oldpen);   // Restore old brush\r\n\r\n        EndPaint(hwnd, &ps);\r\n\r\n//        DeleteObject(font);\r\n    } return 0;\r\n\r\n    case WM_RBUTTONUP:\r\n    case WM_MBUTTONUP:\r\n    case WM_LBUTTONUP:\r\n        ShowWindow(hwnd, SW_HIDE);\r\n        break;\r\n\r\n    case WM_DESTROY: {\r\n        DeleteObject(pen);\r\n    } break;\r\n    }\r\n    return DefWindowProc(hwnd, msg, wp, lp);\r\n}\r\n\r\n\r\nstatic void ShowSnapLayoutPreview(unsigned char yep)\r\n{\r\n    if (g_zphwnd) { // Window was created\r\n        if (!yep) {\r\n            ShowWindow(g_zphwnd, SW_HIDE);\r\n        } else if (!IsWindowVisible(g_zphwnd)) {\r\n            ShowWindow(g_zphwnd, SW_SHOW);\r\n            SetWindowLevel(g_zphwnd, state.hwnd); // Behind currently moving hwn\r\n        }\r\n    }\r\n}\r\n\r\nstatic void ZonesPrevResetRegion()\r\n{\r\n    if (conf.ZonesPrevwOpacity != 0)\r\n        return;\r\n    POINT opt = { 0, 0 };\r\n    RECT wrc;\r\n    GetWindowRect(g_zphwnd, &wrc);\r\n    ScreenToClient(g_zphwnd, &opt);\r\n    HRGN hregion = CreateRectRgn(0,0,0,0);\r\n    if (Zones[conf.LayoutNumber]) {\r\n        for (unsigned i=0; i < nzones[conf.LayoutNumber]; i++) {\r\n            RECT rc;\r\n            CopyRect(&rc, &Zones[conf.LayoutNumber][i]);\r\n            OffsetRect(&rc, opt.x, opt.y);\r\n            HRGN tmpr = CreateRectRgn(rc.left, rc.top, rc.right, rc.top+4); // top  ^^^^\r\n            CombineRgn(hregion, hregion, tmpr, RGN_OR);\r\n            DeleteObject(tmpr);\r\n            tmpr = CreateRectRgn(rc.left, rc.bottom-4, rc.right, rc.bottom); //     ____ bottom\r\n            CombineRgn(hregion, hregion, tmpr, RGN_OR);\r\n            DeleteObject(tmpr);\r\n            tmpr = CreateRectRgn(rc.left, rc.top, rc.left+4, rc.bottom); //   left  |...\r\n            CombineRgn(hregion, hregion, tmpr, RGN_OR);\r\n            DeleteObject(tmpr);\r\n            tmpr = CreateRectRgn(rc.right-4, rc.top, rc.right, rc.bottom); //       ...| right\r\n            CombineRgn(hregion, hregion, tmpr, RGN_OR);\r\n            DeleteObject(tmpr);\r\n        }\r\n    }\r\n    SetWindowRgn(g_zphwnd, hregion, FALSE);\r\n}\r\n\r\nstatic unsigned readhotkeys(const TCHAR *inisection, const char *name, const TCHAR *def, UCHAR *keys, unsigned MaxKeys);\r\nstatic void SnapLayoutPreviewCreateDestroy(const TCHAR *inisection)\r\n{\r\n    if(!conf.ShowZonesPrevw)\r\n        return;\r\n    if (inisection) {\r\n        int bgcol[2], bdcol[2];\r\n        readhotkeys(inisection, \"ZonesPrevwBGCol\",  TEXT(\"FF FF FF\"), (UCHAR *)&bgcol[0], 3);\r\n        readhotkeys(inisection, \"ZonesPrevwBDCol\",  TEXT(\"00 00 00\"), (UCHAR *)&bdcol[0], 3);\r\n        g_ZPrevBDCol = bdcol[0];\r\n        const UCHAR opacity = conf.ZonesPrevwOpacity;\r\n        const UCHAR usetrans = opacity!=0 && opacity!=255;\r\n        const WNDPROC wproc  = opacity==0? DefWindowProc: SnapLayoutWinProc;\r\n        const HBRUSH wbrush  = opacity==0? CreateSolidBrush(bdcol[0]): CreateSolidBrush(bgcol[0]);\r\n        const WNDCLASSEX wnd = {\r\n            sizeof(WNDCLASSEX), 0\r\n          , wproc\r\n          , 0, 0, hinstDLL\r\n          , NULL, NULL, wbrush\r\n          , NULL, APP_NAME\"-ZonesPreview\", NULL };\r\n        RegisterClassEx(&wnd);\r\n\r\n        int left=0, top=0, width, height;\r\n        if(GetSystemMetrics(SM_CMONITORS) >= 1) {\r\n            left   = GetSystemMetrics(SM_XVIRTUALSCREEN);\r\n            top    = GetSystemMetrics(SM_YVIRTUALSCREEN);\r\n            width  = GetSystemMetrics(SM_CXVIRTUALSCREEN);\r\n            height = GetSystemMetrics(SM_CYVIRTUALSCREEN);\r\n         } else { // NT4...\r\n             width = GetSystemMetrics(SM_CXFULLSCREEN)+256;\r\n             height= GetSystemMetrics(SM_CYFULLSCREEN)+256;\r\n         }\r\n         g_zphwnd = CreateWindowEx(usetrans? WS_EX_TOOLWINDOW|WS_EX_LAYERED: WS_EX_TOOLWINDOW\r\n                             , wnd.lpszClassName, NULL, WS_POPUP\r\n                             , left, top, width, height, g_mainhwnd, NULL, hinstDLL, NULL);\r\n        SetWindowLevel(g_zphwnd, state.hwnd); // Behind\r\n        if (usetrans)\r\n            SetLayeredWindowAttributesL(g_zphwnd, 0, opacity, LWA_ALPHA);\r\n\r\n         // Set Window Region to only show outlines if needed...\r\n         ZonesPrevResetRegion();\r\n\r\n    } else {\r\n        if (g_zphwnd) DestroyWindow(g_zphwnd);\r\n        UnregisterClass(APP_NAME\"-ZonesPreview\", hinstDLL);\r\n    }\r\n}\r\n\r\nstatic void SetLayoutNumber(WPARAM number)\r\n{\r\n    conf.LayoutNumber=CLAMP(0, number, 9);\r\n    ZonesPrevResetRegion(); // re-calculate\r\n}\r\n"
        },
        {
          "name": "zzip.bat",
          "type": "blob",
          "size": 0.2880859375,
          "content": "advzipNT -a4 -i 16 AltSnap_src.zip AltSnap.txt AltSnap.ini AltSnap.xml altsnap.nsi License.txt altsnap.c altsnap.rc config.c hooks.c hooks.rc languages.c languages.h resource.h tray.c hooks.h unfuck.h nanolibc.h window.rc AltSnap.exe.manifest makefile media\\* Lang\\*\r\n\r\nDeflopt AltSnap_src.zip\r\n"
        }
      ]
    }
  ]
}