{
  "metadata": {
    "timestamp": 1736709978237,
    "page": 541,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "libgit2/rugged",
      "stars": 2253,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1044921875,
          "content": "test/fixtures/*.git/packed-refs text eol=lf\ntest/fixtures/*.git/logs/**/* text eol=lf\n\nscript/* text eol=lf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.201171875,
          "content": "*.bundle\n*.swp\nGemfile.lock\ntmp/\ntest/fixtures/testrepo.git\next/rugged/vendor/libgit2-dist/\next/rugged/vendor/mkmf.log\next/rugged/libgit2_embed.a\nlib/rugged/**/rugged.so\n.yardoc\nvendor/gems\nbin/\npkg/\nrdoc/\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.095703125,
          "content": "[submodule \"vendor/libgit2\"]\n\tpath = vendor/libgit2\n\turl = https://github.com/libgit2/libgit2.git\n"
        },
        {
          "name": ".yardopts",
          "type": "blob",
          "size": 0.083984375,
          "content": "{lib,app}/**/*.rb ext/rugged/rugged_object.c ext/rugged/rugged_reference.c ext/**/*.c\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.2109375,
          "content": "*   Add `Rugged::Repository#checkout_index`.\n\n    This allows to perform checkout from a given GIT index.\n    It might be handy in case of manual merge conflicts resolution with user intervention.\n\n    *Dmytro Milinevskyy*\n\n*   Add accessors for the Repository ident.\n\n    Added `Repository#ident` and `Repository#ident=` to read and set the\n    identity that is used when writing reflog entries.\n\n    *Arthur Schreiber*\n\n*   `Rugged::Remote` instances are now immutable.\n\n    * `Remote#clear_refspecs` and `Remote#save` were removed without\n      replacement.\n\n    * `Remote#url=` and `Remote#push_url=` were removed and replaced by\n      `RemoteCollection#set_url` and `RemoteCollection#set_push_url`.\n\n    * `Remote#add_push` and `Remote#add_fetch` were removed and replaced by\n      `RemoteCollection#add_push_refspec` and\n      `RemoteCollection#add_fetch_refspec`.\n\n    *Arthur Schreiber*\n\n*   Update bundled libgit2 to 9042693e283f65d9afb4906ed693a862a250664b.\n\n    *Arthur Schreiber*\n\n*   Updated the API of reflog modifying methods.\n\n    This removes both the optional `:message` as well as `:signature` options from\n    the following methods:\n\n    * `BranchCollection#create`, `BranchCollection#move`, `BranchCollection#rename`\n    * `ReferenceCollection#create`, `ReferenceCollection#rename`\n    * `Remote#push`\n    * `Repository#reset`\n\n    Additionally, the `:signature` option from `Remote#fetch` was removed as well.\n\n    The reflog message is now automatically generated and committed with the\n    the identity that is set in the Repository's configuration.\n\n    *Arthur Schreiber*\n\n*   The `:safe_create` flag was removed from `Repository#checkout_tree`.\n\n    You can use `:create` in combination with `:recreate_missing` instead.\n\n    *Arthur Schreiber*\n\n\n## Rugged 0.22.2 (May 17, 2015) ##\n\n*   Update bundled libgit2 to 0.22.2.\n\n    See https://github.com/libgit2/libgit2/releases/tag/v0.22.0,\n    https://github.com/libgit2/libgit2/releases/tag/v0.22.1 and\n    https://github.com/libgit2/libgit2/releases/tag/v0.22.2 for a list\n    of fixed issues and new features.\n\n    *Arthur Schreiber*\n\n*   Add `Rugged::Tree#count_recursive`.\n\n    This counts all blobs in a tree, recursively, with an optional limit\n    to bail early. This allows asking things like: \"Are there more\n    than 1 million files in this repo?\" in a very performant way.\n\n    Fixes #464.\n\n    *Andy Delcambre*\n\n*   Add missing handling of libgit2 errors in `Rugged::BranchCollection#each`\n    and `Rugged::BranchCollection#each_name`.\n\n    Fixes #457.\n\n    *aiionx*\n\n*   The `Rugged::Tree::Builder` API was changed to account for libgit2 changes.\n\n    When creating a new `Rugged::Tree::Builder` instance through\n    `Rugged::Tree::Builder.new` you have to pass a repository instance,\n    while `Rugged::Tree::Builder#write` does not take any arguments anymore.\n\n    *Vicent Martí*\n\n*   Add alternative backend support (experimental).\n\n    Bare repositories can now be stored using an alternative backend.\n\n    Fixes #410.\n\n    *Viktor Charypar*\n\n*   Replace `Remote#rename!` with `RemoteCollection#rename`.\n\n    This brings the `RemoteCollection` more in line with the API of\n    `ReferenceCollection` and `BranchCollection`.\n\n    *Arthur Schreiber*\n\n*   Remove URL validation from `Remote#url=`, `Remote#push_url=`,\n    `RemoteCollection#create_anonymous` and `RemoteCollection#create`,\n    as the underlying function `git_remote_supported_url()` was removed\n    from libgit2.\n\n    *Arthur Schreiber*\n\n*   Add `Repository#merge_bases`.\n\n    This returns an array containing all merge bases between one or\n    multiple commits.\n\n    *Arthur Schreiber*\n\n*   Add submodule support.\n\n    Expose git submodules functionality through `Rugged::Submodule` and\n    `Rugged::SubmoduleCollection`.\n\n    *Nikolai Vladimirov*\n\n*   Add `Rugged::Walker#push_range`.\n\n    *Evgeniy Sokovikov*\n\n*   Implement `Rugged::Blob::HashSignature` and `Rugged::Blob#hashsig`.\n\n    Allows similarity detection of `Rugged::Blob` instances against other blobs or\n    arbitrary strings.\n\n    *Vicent Martí*\n\n*   Add `Rugged::Repository#attributes`.\n\n    This method allows accessing the attributes for different path names as\n    specified by `.gitattributes` files.\n\n    *Vicent Martí*\n\n*   Add `Rugged::TagCollection#create_annotation`.\n\n    This method allows the creation of a tag object, but without creating\n    a tag reference.\n\n    *Charlie Somerville*\n\n*   Add `Rugged::Repository#cherrypick`.\n\n    *Arthur Schreiber*\n\n*   Add `Rugged::Repository#descendant_of?`\n\n    *Jake Douglas*\n\n*   `Rugged::Index#read_tree` now actually checks that the given object is a\n    `Rugged::Tree` instance.\n\n    Fixes #401.\n\n    *Andy Delcambre*\n\n*   Add `Rugged::Repository#expand_oids`.\n\n    This allows expanding a list of shortened SHA1 strings, optionally restricting\n    the expansion to a specific object type.\n\n    *Vicent Martí*\n\n*   Add `Rugged::Remote#check_connection`.\n\n    This is useful if one needs to check if it is possible to fetch/push\n    from/to the remote.\n\n    Basically, it is analogue to `git fetch --dry-run` and `git push --dry-run`.\n\n    *Dmitry Medvinsky*\n\n*   Remove defunct `Rugged::Diff::Line#hunk` and `Rugged::Diff::Line#owner`.\n\n    Fixes #390.\n\n    *Arthur Schreiber*\n\n*   Remove `Rugged::Diff#tree` and change `Rugged::Diff#owner` to return the\n    repository that the `Rugged::Diff` object belongs to.\n\n    We need to keep a reference from the `Rugged::Diff` to the repository to\n    ensure that the underlying libgit2 data does not get freed accidentally.\n\n    Fixes #389.\n\n    *Arthur Schreiber*\n\n*   Add `#additions` and `#deletions` to `Rugged::Patch`.\n\n    *Mindaugas Mozūras*\n\n\n## Rugged 0.21.4 (January 18, 2015) ##\n\n*   Update bundled libgit2 to 0.21.4.\n\n    See https://github.com/libgit2/libgit2/releases/tag/v0.21.4 for a list\n    of fixed issues.\n\n    *Arthur Schreiber*\n\n\n## Rugged 0.21.3 (December 18, 2014) ##\n\n*   Update bundled libgit2 to 0.21.3.\n\n    See https://github.com/libgit2/libgit2/releases/tag/v0.21.3 for a list\n    of fixed issues.\n\n    *Arthur Schreiber*\n\n\n## Rugged 0.21.2 (November 16, 2014) ##\n\n*   Update bundled libgit2 to 0.21.2 (from 0.21.0).\n\n    See https://github.com/libgit2/libgit2/releases/tag/v0.21.1 and\n    https://github.com/libgit2/libgit2/releases/tag/v0.21.2 for a list\n    of fixed issues.\n\n    *Arthur Schreiber*\n"
        },
        {
          "name": "Gemfile",
          "type": "blob",
          "size": 0.1181640625,
          "content": "source \"http://rubygems.org\"\n\nif RUBY_VERSION <= '2.7'\n  platforms :rbx do\n    gem 'rubysl', '~> 2.0'\n  end\nend\n\ngemspec\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.080078125,
          "content": "The MIT License\n\nCopyright (c) 2016 GitHub, Inc\nCopyright (c) Rugged Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.76171875,
          "content": "# Rugged [![Rugged CI](https://github.com/libgit2/rugged/actions/workflows/ci.yml/badge.svg)](https://github.com/libgit2/rugged/actions/workflows/ci.yml)\n**libgit2 bindings in Ruby**\n\nRugged is a library for accessing [libgit2](https://github.com/libgit2/libgit2) in Ruby. It gives you the speed and\nportability of libgit2 with the beauty of the Ruby language.\n\n### libgit2\n\nlibgit2 is a pure C implementation of the Git core methods. It's designed to be\nfast and portable. For more information about libgit2,\n[check out libgit2's website](http://libgit2.github.com) or browse the\n[libgit2 organization](https://github.com/libgit2) on GitHub.\n\n## Install\n\nRugged is a self-contained gem. You can install it by running:\n\n    $ gem install rugged\n\n## Prerequisites\nYou need to have CMake and `pkg-config` installed on your system to be able to build the included version of `libgit2`. \n\n### Debian, Including Ubuntu\nAll Debian-derived Linux distros provide `apt`:\n```bash\n$ sudo apt install libgit2-dev cmake pkg-config\n```\n\nNote that you only need `libgit2-dev` if you want to build with the system\nlibgit2 rather than the vendored version. In this case, note that the major and\nminor versions of libgit2 and rugged must match.\n\n### Mac\nOn OS X, after installing [Homebrew](http://brew.sh/), you can get the required packages with:\n```bash\n$ brew install cmake pkg-config\n```\n\nPlease follow the above in case installation of the gem fails with `ERROR: CMake is required to build Rugged.`.\n\n### Options\n\nIf you want to build Rugged with HTTPS and SSH support, check out the list of optional [libgit2 dependencies](https://github.com/libgit2/libgit2#optional-dependencies).\n\nTo install `rugged` with SSH support ensure you have the `LibSSH2` library present, then pass the required `CMAKE_FLAGS`:\n```bash\nCMAKE_FLAGS='-DUSE_SSH=ON' gem install rugged\n```\n\nOr pass the `--with-ssh` build option:\n```bash\ngem install rugged -- --with-ssh\n```\n\nIf you're using bundler and want to bundle `libgit2` with Rugged, you can use the `:submodules` option:\n\n```ruby\ngem 'rugged', git: 'git://github.com/libgit2/rugged.git', submodules: true\n```\n\nIf you would like to bundle rugged with SSH support add the `--with-ssh` build option to the bundler config:\n```bash\nbundle config build.rugged --with-ssh\n```\n\n## Usage\nTo load Rugged, you'll usually want to add something like this:\n\n```ruby\nrequire 'rugged'\n```\n\n### Use the system provided libgit2\n\nBy default, Rugged builds and uses a bundled version of libgit2. If you\nwant to use the system library instead, you can install rugged as follows:\n\n```\ngem install rugged -- --use-system-libraries\n```\n\nOr if you are using bundler:\n\n```\nbundle config build.rugged --use-system-libraries\nbundle install\n```\n\nHowever, note that Rugged does only support specific versions of libgit2.\n\n## Usage\n\nRugged gives you access to the many parts of a Git repository. You can read and\nwrite objects, walk a tree, access the staging area, and lots more. Let's look\nat each area individually.\n\n### Repositories\n\n#### Instantiation\n\nThe repository is naturally central to Git. Rugged has a `Repository` class that\nyou can instantiate with a path to open an existing repository :\n\n```ruby\nrepo = Rugged::Repository.new('path/to/my/repository')\n# => #<Rugged::Repository:2228536260 {path: \"path/to/my/repository/.git/\"}>\n```\n\nYou can create a new repository with `init_at`. Add a second parameter `:bare` to make a bare repository:\n\n```ruby\nRugged::Repository.init_at('.', :bare)\n```\n\nYou can also let Rugged discover the path to the .git directory if you give it a\nsubdirectory.\n\n```ruby\nRugged::Repository.discover(\"/Users/me/projects/repo/lib/subdir/\")\n# => \"/Users/me/projects/repo/.git/\"\n```\n\nOnce your Repository instantiated (in the following examples, as `repo`), you\ncan access or modify it.\n\n#### Accessing a Repository\n\n```ruby\n# Does the given SHA1 exist in this repository?\nrepo.exists?('07b44cbda23b726e5d54e2ef383495922c024202')\n# => true\n\n# Boolean repository state values:\nrepo.bare?\n# => false\nrepo.empty?\n# => true\nrepo.head_unborn?\n# => false\nrepo.head_detached?\n# => false\n\n# Path accessors\nrepo.path\n# => \"path/to/my/repository/.git/\"\nrepo.workdir\n# => \"path/to/my/repository/\"\n\n# The HEAD of the repository.\nref = repo.head\n# => #<Rugged::Reference:2228467240 {name: \"refs/heads/master\", target:  #<Rugged::Commit:2228467250 {message: \"helpful message\", tree: #<Rugged::Tree:2228467260 {oid: 5d6f29220a0783b8085134df14ec4d960b6c3bf2}>}>\n\n# From the returned ref, you can also access the `name`, `target`, and target SHA:\nref.name\n# => \"refs/heads/master\"\nref.target\n# => #<Rugged::Commit:2228467250 {message: \"helpful message\", tree: #<Rugged::Tree:2228467260 {oid: 5d6f29220a0783b8085134df14ec4d960b6c3bf2}>}>\nref.target_id\n# => \"2bc6a70483369f33f641ca44873497f13a15cde5\"\n\n# Reading an object\nobject = repo.read('a0ae5566e3c8a3bddffab21022056f0b5e03ef07')\n# => #<Rugged::OdbObject:0x109a64780>\nobject.len\n# => 237\nobject.data\n# => \"tree 76f23f186076fc291742816721ea8c3e95567241\\nparent 8e3c5c52b8f29da0adc7e8be8a037cbeaea6de6b\\nauthor Vicent Mart\\303\\255 <tanoku@gmail.com> 1333859005 +0200\\ncommitter Vicent Mart\\303\\255 <tanoku@gmail.com> 1333859005 +0200\\n\\nAdd `Repository#blob_at`\\n\"\nobject.type\n# => :commit\n```\n\n#### Writing to a Repository\n\nThere's a few ways to write to a repository. To write directly from your\ninstantiated repository object:\n\n```ruby\nsha = repo.write(content, type)\n```\n\nYou can also use the `Commit` object directly to craft a commit; this is a bit\nmore high-level, so it may be preferable:\n\n```ruby\noid = repo.write(\"This is a blob.\", :blob)\nindex = repo.index\nindex.read_tree(repo.head.target.tree)\nindex.add(:path => \"README.md\", :oid => oid, :mode => 0100644)\n\noptions = {}\noptions[:tree] = index.write_tree(repo)\n\noptions[:author] = { :email => \"testuser@github.com\", :name => 'Test Author', :time => Time.now }\noptions[:committer] = { :email => \"testuser@github.com\", :name => 'Test Author', :time => Time.now }\noptions[:message] ||= \"Making a commit via Rugged!\"\noptions[:parents] = repo.empty? ? [] : [ repo.head.target ].compact\noptions[:update_ref] = 'HEAD'\n\nRugged::Commit.create(repo, options)\n```\n\n---\n\n### Objects\n\n`Object` is the main object class - it shouldn't be created directly, but all of\nthese methods should be useful in their derived classes.\n\n```ruby\nobj = repo.lookup(sha)\nobj.oid  # object sha\nobj.type # One of :commit, :tree, :blob or :tag\n\nrobj = obj.read_raw\nstr  = robj.data\nint  = robj.len\n```\n\nThere are four base object types in Git: **blobs**, **commits**, **tags**, and\n**trees**. Each of these object types have a corresponding class within Rugged.\n\n### Commit Objects\n\n```ruby\ncommit = repo.lookup('a0ae5566e3c8a3bddffab21022056f0b5e03ef07')\n# => #<Rugged::Commit:2245304380>\n\ncommit.message\n# => \"Add `Repository#blob_at`\\n\"\n\ncommit.time\n# => Sat Apr 07 21:23:25 -0700 2012\n\ncommit.author\n# => {:email=>\"tanoku@gmail.com\", :name=>\"Vicent Mart\\303\\255\", :time=>Sun Apr 08 04:23:25 UTC 2012}\n\ncommit.tree\n# => #<Rugged::Tree:2245269740>\n\ncommit.parents\n# => [#<Rugged::Commit:2245264600 {message: \"Merge pull request #47 from isaac/remotes\\n\\nAdd Rugged::Repository#remotes\", tree: #<Rugged::Tree:2245264240 {oid: 6a2aee58a41fa007d07aa55565e2231f9b39b4a9}>]\n```\n\nYou can also write new objects to the database this way:\n\n```ruby\nauthor = {:email=>\"tanoku@gmail.com\", :time=>Time.now, :name=>\"Vicent Mart\\303\\255\"}\n\nRugged::Commit.create(r,\n\t:author => author,\n\t:message => \"Hello world\\n\\n\",\n\t:committer => author,\n\t:parents => [\"2cb831a8aea28b2c1b9c63385585b864e4d3bad1\"],\n\t:tree => some_tree,\n\t:update_ref => \"HEAD\") #=> \"f148106ca58764adc93ad4e2d6b1d168422b9796\"\n```\n\n### Tag Objects\n\n```ruby\ntag  = repo.lookup(tag_sha)\n\nobject = tag.target\nsha    = tag.target.oid\nstr    = tag.target_type # :commit, :tag, :blob\nstr    = tag.name        # \"v1.0\"\nstr    = tag.message\nperson = tag.tagger\n```\n\n### Tree Objects\n\n```ruby\ntree = repo.lookup('779fbb1e17e666832773a9825875300ea736c2da')\n# => #<Rugged::Tree:2245194360>\n\n# number of tree entries\ntree.count\n\ntree[0]           # or...\ntree.first        # or...\ntree.get_entry(0)\n# => {:type=>:blob, :oid=>\"99e7edb53db9355f10c6f2dfaa5a183f205d93bf\", :filemode=>33188, :name=>\".gitignore\"}\n```\n\nThe tree object is an Enumerable, so you can also do stuff like this:\n\n```ruby\ntree.each { |e| puts e[:oid] }\ntree.sort { |a, b| a[:oid] <=> b[:oid] }.map { |e| e[:name] }.join(':')\n```\n\nAnd there are some Rugged-specific methods, too:\n\n```ruby\ntree.each_tree { |entry| puts entry[:name] }  # list subdirs\ntree.each_blob { |entry| puts entry[:name] }  # list only files\n```\n\nYou can also write trees with the `TreeBuilder`:\n\n```ruby\noid = repo.write(\"This is a blob.\", :blob)\nbuilder = Rugged::Tree::Builder.new(repo)\nbuilder << { :type => :blob, :name => \"README.md\", :oid => oid, :filemode => 0100644 }\n\noptions = {}\noptions[:tree] = builder.write\n\noptions[:author] = { :email => \"testuser@github.com\", :name => 'Test Author', :time => Time.now }\noptions[:committer] = { :email => \"testuser@github.com\", :name => 'Test Author', :time => Time.now }\noptions[:message] ||= \"Making a commit via Rugged!\"\noptions[:parents] = repo.empty? ? [] : [ repo.head.target ].compact\noptions[:update_ref] = 'HEAD'\n\nRugged::Commit.create(repo, options)\n```\n\n### Blob Objects\n\nBlob objects represent the data in the files of a Tree Object.\n\n```ruby\nblob = repo.lookup('e1253910439ea902cf49be8a9f02f3c08d89ac73')\nblob.content # => Gives you the content of the blob.\n```\n\n#### Streaming Blob Objects\n\nThere is currently no way to stream data from a blob, because `libgit2` itself does not (yet) support\nstreaming blobs out of the git object database. While there are hooks and interfaces for supporting it,\nthe default file system backend always loads the entire blob contents into memory. \n\nIf you need to access a Blob object through an IO-like API, you can wrap it with the `StringIO` class.\nNote that the only advantage here is a stream-compatible interface, the complete blob object will still\nbe loaded into memory. Below is an example for streaming a Blob using the Sinatra framework:\n\n```ruby\n# Sinatra endpoint\nget \"/blobs/:sha\" do\n  repo = Rugged::Repository.new(my_repo_path)\n  blob = repo.lookup params[:sha]\n\n  headers({\n    \"Vary\" => \"Accept\",\n    \"Connection\" => \"keep-alive\",\n    \"Transfer-Encoding\" => \"chunked\",\n    \"Content-Type\" => \"application/octet-stream\",\n  })\n\n  stream do |out|\n    StringIO.new(blob.content).each(8000) do |chunk|\n      out << chunk\n    end\n  end\nend\n```\n\n---\n\n### Commit Walker\n\n`Rugged::Walker` is a class designed to help you traverse a set of commits over\na repository.\n\nYou first push head SHAs onto the walker, and then call next to get a list of\nthe reachable commit objects one at a time. You can also `hide()` commits if you\nare not interested in anything beneath them (useful in situations like when\nyou're running something like `git log master ^origin/master`).\n\n```ruby\nwalker = Rugged::Walker.new(repo)\nwalker.sorting(Rugged::SORT_TOPO | Rugged::SORT_REVERSE) # optional\nwalker.push(hex_sha_interesting)\nwalker.hide(hex_sha_uninteresting)\nwalker.each { |c| puts c.inspect }\nwalker.reset\n```\n\n---\n\n### Index (\"staging\") area\n\nWe can inspect and manipulate the Git Index as well. To work with the index\ninside an existing repository, instantiate it by using the `Repository.index`\nmethod instead of manually opening the Index by its path.\n\n```ruby\nindex = Rugged::Index.new(path)\n\n# Re-read the index file from disk.\nindex.reload\n\n# Count up index entries.\ncount = index.count\n\n# The collection of index entries.\nindex.entries\n\n# Iterating over index entries.\nindex.each { |i| puts i.inspect }\n\n# Get a particular entry in the index.\nindex[path]\n\n# Unstage.\nindex.remove(path)\n\n# Stage. Also updates existing entry if there is one.\nindex.add(ientry)\n\n# Stage. Create ientry from file in path, updates the index.\nindex.add(path)\n```\n\n---\n\n### Refs\n\nYou can access references through the `Rugged::ReferenceCollection` object returned by `Repository#references`.\n\n```ruby\nref = repo.references[\"refs/heads/master\"]\n\nsha = ref.target_id\nstr = ref.type   # :direct\nstr = ref.name   # \"refs/heads/master\"\n```\n\nYou can also easily iterate over all references:\n\n```ruby\nrepo.references.each do |ref|\n  puts ref.name\nend\n```\n\nOr only over references that match the given pattern (glob):\n\n```ruby\nrepo.references.each(\"refs/tags/*\") do |ref|\n  puts ref.name\nend\n```\n\nIt is also easy to create, update, rename or delete a reference:\n\n```ruby\nref = repo.references.create(\"refs/heads/unit_test\", some_commit_sha)\n\nrepo.references.update(ref, new_sha) # or...\nrepo.references.update(\"refs/heads/unit_test\", new_sha)\n\nrepo.references.rename(ref, \"refs/heads/blead\") # or...\nrepo.references.rename(\"refs/heads/unit_test\", \"refs/heads/blead\")\n\nrepo.references.delete(ref) # or...\nrepo.references.delete(\"refs/heads/unit_test\") # or...\n```\n\nFinally, you can access the reflog for any branch:\n\n```ruby\nref = repo.references[\"refs/heads/master\"]\nentry = ref.log.first\nsha   = entry[:id_old]\nsha   = entry[:id_new]\nstr   = entry[:message]\nprsn  = entry[:committer]\n```\n\n---\n\n### Branches\n\nThe `Rugged::BranchCollection` object returned by `Repository#branches` will help\nyou with all of your branch-related needs.\n\nIterate over all branches:\n\n```ruby\nrepo.branches.each_name().sort\n# => [\"master\", \"origin/HEAD\", \"origin/master\", \"origin/packed\"]\n\nrepo.branches.each_name(:local).sort\n# => [\"master\"]\n\nrepo.branches.each_name(:remote).sort\n# => [\"origin/HEAD\", \"origin/master\", \"origin/packed\"]\n```\n\nLook up branches and get attributes:\n\n```ruby\nbranch = repo.branches[\"master\"]\nbranch.name # => 'master'\nbranch.canonical_name # => 'refs/heads/master'\n```\n\nLook up the id for the target of a branch:\n\n```ruby\nrepo.branches[\"master\"].target_id\n# => \"36060c58702ed4c2a40832c51758d5344201d89a\"\n```\n\nCreation and deletion:\n\n```ruby\nbranch = repo.branches.create(\"test_branch\", \"HEAD\")\n\nrepo.branches.rename(\"test_branch\", \"new_branch\") # or...\nrepo.branches.rename(\"refs/heads/test_branch\", \"new_branch\") # or...\nrepo.branches.rename(ref, \"new_branch\") # or...\n\nrepo.branches.delete(\"test_branch\") # or...\nrepo.branches.delete(\"refs/heads/test_branch\") # or...\nrepo.branches.delete(ref) # or...\n```\n\n---\n\n### Diffs\n\nThere are various ways to get hands on diffs:\n\n```ruby\n# Diff between two subsequent commits\ndiff_commits = commit_object.parents[0].diff(commit_object)\n\n# Diff between two tree objects\ndiff_trees = tree_object_a.diff(tree_object_b)\n\n# Diff between index/staging and current working directory\ndiff_index = repository.index.diff\n\n# Diff between index/staging and another diffable (commit/tree/index)\ndiff_index_diffable = repository.index.diff(some_diffable)\n```\n\nWhen you already have a diff object, you can examine it:\n\n```ruby\n# Get patch\ndiff.patch\n=> \"diff --git a/foo1 b/foo1\\nnew file mode 100644\\nindex 0000000..81b68f0\\n--- /dev/null\\n+++ b/foo1\\n@@ -0,0 +1,2 @@\\n+abc\\n+add line1\\ndiff --git a/txt1 b/txt1\\ndeleted file mode 100644\\nindex 81b68f0..0000000\\n--- a/txt1\\n+++ /dev/null\\n@@ -1,2 +0,0 @@\\n-abc\\n-add line1\\ndiff --git a/txt2 b/txt2\\nindex a7bb42f..a357de7 100644\\n--- a/txt2\\n+++ b/txt2\\n@@ -1,2 +1,3 @@\\n abc2\\n add line2-1\\n+add line2-2\\n\"\n\n# Get delta (faster, if you only need information on what files changed)\ndiff.each_delta{ |d| puts d.inspect }\n#<Rugged::Diff::Delta:70144372137380 {old_file: {:oid=>\"0000000000000000000000000000000000000000\", :path=>\"foo1\", :size=>0, :flags=>6, :mode=>0}, new_file: {:oid=>\"81b68f040b120c9627518213f7fc317d1ed18e1c\", :path=>\"foo1\", :size=>14, :flags=>6, :mode=>33188}, similarity: 0, status: :added>\n#<Rugged::Diff::Delta:70144372136540 {old_file: {:oid=>\"81b68f040b120c9627518213f7fc317d1ed18e1c\", :path=>\"txt1\", :size=>14, :flags=>6, :mode=>33188}, new_file: {:oid=>\"0000000000000000000000000000000000000000\", :path=>\"txt1\", :size=>0, :flags=>6, :mode=>0}, similarity: 0, status: :deleted>\n#<Rugged::Diff::Delta:70144372135780 {old_file: {:oid=>\"a7bb42f71183c162efea5e4c80597437d716c62b\", :path=>\"txt2\", :size=>17, :flags=>6, :mode=>33188}, new_file: {:oid=>\"a357de7d870823acc3953f1b2471f9c18d0d56ea\", :path=>\"txt2\", :size=>29, :flags=>6, :mode=>33188}, similarity: 0, status: :modified>\n\n# Detect renamed files\n# Note that the status field changed from :added/:deleted to :renamed\ndiff.find_similar!\ndiff.each_delta{ |d| puts d.inspect }\n#<Rugged::Diff::Delta:70144372230920 {old_file: {:oid=>\"81b68f040b120c9627518213f7fc317d1ed18e1c\", :path=>\"txt1\", :size=>14, :flags=>6, :mode=>33188}, new_file: {:oid=>\"81b68f040b120c9627518213f7fc317d1ed18e1c\", :path=>\"foo1\", :size=>14, :flags=>6, :mode=>33188}, similarity: 100, status: :renamed>\n#<Rugged::Diff::Delta:70144372230140 {old_file: {:oid=>\"a7bb42f71183c162efea5e4c80597437d716c62b\", :path=>\"txt2\", :size=>17, :flags=>6, :mode=>33188}, new_file: {:oid=>\"a357de7d870823acc3953f1b2471f9c18d0d56ea\", :path=>\"txt2\", :size=>29, :flags=>6, :mode=>33188}, similarity: 0, status: :modified>\n\n# Merge one diff into another (mutating the first one)\ndiff1.merge!(diff2)\n\n# Write a patch into a file (or any other object responding to write)\n# Note that the patch as in diff.patch will be written, it won't be applied\nfile = File.open('/some/file', 'w')\ndiff.write_patch(file)\nfile.close\n```\n\n---\n\n### Config files\n\nIt's also easy to read and manipulate the Git config file data with Rugged.\n\n```ruby\n# Read values\nrepo.config['core.bare']\n\n# Set values\nrepo.config['user.name'] = true\n\n# Delete values\nrepo.config.delete('user.name')\n```\n\n---\n\n### General methods\n\nRugged also includes a general library for handling basic Git operations. One of\nthese is converting a raw sha (20 bytes) into a readable hex sha (40\ncharacters).\n\n```ruby\nRugged.hex_to_raw('bfde59cdd0dfac1d892814f66a95641abd8a1faf')\n# => \"\\277\\336Y\\315\\320\\337\\254\\035\\211(\\024\\366j\\225d\\032\\275\\212\\037\\257\"\n\nRugged.raw_to_hex(\"\\277\\336Y\\315\\320\\337\\254\\035\\211(\\024\\366j\\225d\\032\\275\\212\\037\\257\")\n=> \"bfde59cdd0dfac1d892814f66a95641abd8a1faf\"\n```\n\n---\n\n### Alternative backends\n\nYou can store bare repositories in alternative backends instead of storing on disk. (see\n`redbadger/rugged-redis` for an example of how a rugged backend works).\n\n```ruby\na_backend = MyProject::CustomObjectDB(opt1: 'setting', opt2: 'setting')\n\nrepo = Rugged::Repository.init_at('repo_name', :bare, backend: a_backend)\n\n# or\n\nrepo = Rugged::Repository.bare('repo_name', backend: a_backend)\n```\n---\n\n## Contributing\n\nFork libgit2/rugged on GitHub, make it awesomer (preferably in a branch named\nfor the topic), send a pull request.\n\n\n## Development\n\nSimply clone and install:\n\n    $ git clone https://github.com/libgit2/rugged.git\n    $ cd rugged\n    $ bundle install\n    $ rake compile\n    $ rake test\n\n## Support\n\nWe encourage you to use StackOverflow for any questions or concerns regarding Rugged. Please tag your questions with the [rugged](http://stackoverflow.com/questions/tagged/rugged) keyword.\n\nFor bug reports, please open a ticket on the GitHub [issue tracker](https://github.com/libgit2/rugged/issues).\n\n## Authors\n\n* Vicent Marti <tanoku@gmail.com>\n* Scott Chacon <schacon@gmail.com>\n* Arthur Schreiber <schreiber.arthur@gmail.com>\n\n\n## License\n\nMIT. See LICENSE file.\n"
        },
        {
          "name": "Rakefile",
          "type": "blob",
          "size": 1.271484375,
          "content": "require 'rake/testtask'\n\nbegin\n  require 'rake/extensiontask'\nrescue LoadError\n  abort <<-error\n  rake-compiler is missing; Rugged depends on rake-compiler to build the C wrapping code.\n\n  Install it by running `gem i rake-compiler`\nerror\nend\n\ngemspec = Gem::Specification::load(File.expand_path('../rugged.gemspec', __FILE__))\n\nGem::PackageTask.new(gemspec) do |pkg|\nend\n\nRake::ExtensionTask.new('rugged', gemspec) do |r|\n  r.lib_dir = 'lib/rugged'\nend\n\ndesc \"checkout libgit2 source\"\ntask :checkout do\n  if !ENV['CI_BUILD']\n    sh \"git submodule update --init\"\n  end\nend\nRake::Task[:compile].prerequisites.insert(0, :checkout)\n\nnamespace :clean do\n  task :libgit2 do\n    FileUtils.rm_rf(\"vendor/libgit2/build\")\n  end\nend\nRake::Task[:clean].prerequisites << \"clean:libgit2\"\n\ndesc \"Open an irb session preloaded with Rugged\"\ntask :console do\n  exec \"script/console\"\nend\n\n#\n# Tests\n#\ntask :default => [:compile, :test]\n\ntask :cover do\n  ruby 'test/coverage/cover.rb'\nend\n\nRake::TestTask.new do |t|\n  t.libs << 'lib' << 'test'\n  t.pattern = 'test/**/*_test.rb'\n  t.verbose = false\n  t.warning = true\nend\n\nbegin\n  require 'rdoc/task'\n  Rake::RDocTask.new do |rdoc|\n    rdoc.rdoc_dir = 'rdoc'\n    rdoc.rdoc_files.include('ext/**/*.c')\n    rdoc.rdoc_files.include('lib/**/*.rb')\n  end\nrescue LoadError\nend\n\n"
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "rugged.gemspec",
          "type": "blob",
          "size": 1.5302734375,
          "content": "$:.push File.expand_path(\"../lib\", __FILE__)\n\nif ENV['DEVELOPMENT']\n  VERSION = `git describe --tags`.strip.gsub('-', '.')[1..-1]\nelse\n  require 'rugged/version'\n  VERSION = Rugged::Version\nend\n\nGem::Specification.new do |s|\n  s.name                  = \"rugged\"\n  s.version               = VERSION\n  s.date                  = Time.now.strftime('%Y-%m-%d')\n  s.summary               = \"Rugged is a Ruby binding to the libgit2 linkable library\"\n  s.homepage              = \"https://github.com/libgit2/rugged\"\n  s.email                 = \"schacon@gmail.com\"\n  s.authors               = [ \"Scott Chacon\", \"Vicent Marti\" ]\n  s.license               = \"MIT\"\n  s.files                 = %w( README.md LICENSE )\n  s.files                 += Dir.glob(\"lib/**/*.rb\")\n  s.files                 += Dir.glob(\"ext/**/*.[ch]\")\n  s.files                 += Dir.glob(\"vendor/libgit2/cmake/**/*\")\n  s.files                 += Dir.glob(\"vendor/libgit2/{include,src,deps}/**/*\")\n  s.files                 += Dir.glob(\"vendor/libgit2/{CMakeLists.txt,Makefile.embed,AUTHORS,COPYING,libgit2.pc.in}\")\n  s.extensions            = ['ext/rugged/extconf.rb']\n  s.required_ruby_version = '>= 1.9.3'\n  s.description           = <<desc\nRugged is a Ruby bindings to the libgit2 linkable C Git library. This is\nfor testing and using the libgit2 library in a language that is awesome.\ndesc\n  s.add_development_dependency \"rake-compiler\", \">= 0.9.0\"\n  s.add_development_dependency \"pry\"\n  s.add_development_dependency \"minitest\", \"~> 5.0\"\n  s.metadata[\"msys2_mingw_dependencies\"] = \"libssh2 cmake\"\nend\n"
        },
        {
          "name": "script",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}