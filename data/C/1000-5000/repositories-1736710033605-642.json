{
  "metadata": {
    "timestamp": 1736710033605,
    "page": 642,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kaltura/nginx-vod-module",
      "stars": 2017,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.21875,
          "content": "# Change log\n\nNote: the list of changes below does not include all changes, it includes mostly \"breaking\" changes.\n\tUsually, these are changes that require some update to nginx.conf in order to retain the existing behavior.\n\n\t\n## 2017/08/13 - hls/fmp4 support\n\nThe following configuration settings were renamed:\n* vod_hls_interleave_frames -> vod_hls_mpegts_interleave_frames\n* vod_hls_align_frames -> vod_hls_mpegts_align_frames\n* vod_hls_output_id3_timestamps -> vod_hls_mpegts_output_id3_timestamps\n\n## 2016/06/09 - live timing enhancements\n\nThe following configuration settings were removed:\n* vod_live_segment_count - use vod_live_window_duration instead, multiply by vod_segment_duration.\n\t\n## 2016/05/08 - provide more control of the domain of returned URLs\n\nThe following configuration settings were removed:\n* vod_https_header_name - use vod_base_url instead, e.g. if vod_https_header_name was set\n\tto `my-https-header`, the updated config may look like:\n```\nhttp {\n\n\tmap $http_my_https_header $protocol {\n\t\tdefault             \"http\";\n\t\t\"ON\"                \"https\";\n\t}\n\n\tserver {\n\n\t\tif ($http_host != \"\") {\n\t\t\tset $base_url \"$protocol://$http_host\";\n\t\t}\n\t\n\t\tif ($http_host = \"\") {\n\t\t\tset $base_url \"\";\t\t# no host header - use relative urls\n\t\t}\n\n\t\tvod_base_url $base_url;\n```\n\nThe behavior of the following configurations were changed:\n* vod_segments_base_url - when this variable is defined and evaluates to a non-empty string,\n\tit is assumed to contain both the scheme and the host name. Before the change, when the \n\turl did not contain a scheme, a defualt scheme was added.\n\n## 2016/03/06 - ad stitching supporting features\n\nThe following configuration settings were removed:\n* vod_path_mapping_cache - replaced by vod_mapping_cache\n* vod_live_path_mapping_cache - replaced by vod_live_mapping_cache\n\t\n## 2016/02/03 - added support for Matroska container\n\nThe following configuration settings were removed:\n* vod_moov_cache - replaced by vod_metadata_cache\n* vod_max_moov_size - replaced by vod_max_metadata_size\n\t\n## 2015/12/15 - removed the upstream module implementation\n\t\nnginx-vod is now built to make use of standard nginx upstream modules (e.g. proxy)\nThe following configuration settings were removed:\n* vod_child_request - use proxy_pass instead\n* vod_child_request_path - replaced by vod_xxx_upstream_location\n* vod_upstream_host_header - use proxy_set_header instead\n* vod_upstream - replaced by vod_upstream_location\n* vod_connect_timeout - use proxy_connect_timeout\n* vod_send_timeout - use proxy_send_timeout\n* vod_read_timeout - use proxy_read_timeout\n* vod_fallback_upstream - replaced by vod_fallback_upstream_location\n* vod_fallback_connect_timeout - use proxy_connect_timeout\n* vod_fallback_send_timeout - use proxy_send_timeout\n* vod_fallback_read_timeout - use proxy_read_timeout\n* vod_drm_upstream - replaced by vod_drm_upstream_location\n* vod_drm_connect_timeout - use proxy_connect_timeout\n* vod_drm_send_timeout - use proxy_send_timeout\n* vod_drm_read_timeout - use proxy_read_timeout\n\n## 2015/12/06 - added support for MP4 edit lists\n\nnginx-vod now respects edit lists (elst MP4 atom), this can change the set of frames returned in media segments,\nand cause errors in case of a live upgrade. To retain the previous behavior, set vod_ignore_edit_list to on.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 33.69140625,
          "content": "GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version 3, 19 November 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU Affero General Public License is a free, copyleft license for\nsoftware and other kinds of works, specifically designed to ensure\ncooperation with the community in the case of network server software.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nour General Public Licenses are intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  Developers that use our General Public Licenses protect your rights\nwith two steps: (1) assert copyright on the software, and (2) offer\nyou this License which gives you legal permission to copy, distribute\nand/or modify the software.\n\n  A secondary benefit of defending all users' freedom is that\nimprovements made in alternate versions of the program, if they\nreceive widespread use, become available for other developers to\nincorporate.  Many developers of free software are heartened and\nencouraged by the resulting cooperation.  However, in the case of\nsoftware used on network servers, this result may fail to come about.\nThe GNU General Public License permits making a modified version and\nletting the public access it on a server without ever releasing its\nsource code to the public.\n\n  The GNU Affero General Public License is designed specifically to\nensure that, in such cases, the modified source code becomes available\nto the community.  It requires the operator of a network server to\nprovide the source code of the modified version running there to the\nusers of that server.  Therefore, public use of a modified version, on\na publicly accessible server, gives the public access to the source\ncode of the modified version.\n\n  An older license, called the Affero General Public License and\npublished by Affero, was designed to accomplish similar goals.  This is\na different license, not a version of the Affero GPL, but Affero has\nreleased a new version of the Affero GPL which permits relicensing under\nthis license.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU Affero General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Remote Network Interaction; Use with the GNU General Public License.\n\n  Notwithstanding any other provision of this License, if you modify the\nProgram, your modified version must prominently offer all users\ninteracting with it remotely through a computer network (if your version\nsupports such interaction) an opportunity to receive the Corresponding\nSource of your version by providing access to the Corresponding Source\nfrom a network server at no charge, through some standard or customary\nmeans of facilitating copying of software.  This Corresponding Source\nshall include the Corresponding Source for any work covered by version 3\nof the GNU General Public License that is incorporated pursuant to the\nfollowing paragraph.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the work with which it is combined will remain governed by version\n3 of the GNU General Public License.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU Affero General Public License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU Affero General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU Affero General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU Affero General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If your software can interact with users remotely through a computer\nnetwork, you should also make sure that it provides a way for users to\nget its source.  For example, if your program is a web application, its\ninterface could display a \"Source\" link that leads users to an archive\nof the code.  There are many ways you could offer source, and different\nsolutions will be better for different programs; see section 13 for the\nspecific requirements.\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU AGPL, see\n<http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 83.77734375,
          "content": "# NGINX-based VOD Packager\n## nginx-vod-module [![Build Status](https://travis-ci.org/kaltura/nginx-vod-module.svg?branch=master)](https://travis-ci.org/kaltura/nginx-vod-module)\n\n[Join the list of organizations using this video packager project](https://github.com/kaltura/nginx-vod-module/issues/730/).\n\nFor live video streaming, please use [Media-Framework](https://github.com/kaltura/media-framework/).\n\n### Features\n\n* On-the-fly repackaging of MP4 files to DASH, HDS, HLS, MSS\n\n* Working modes:\n  1. Local - serve locally accessible files (local disk/NFS mounted)\n  2. Remote - serve files accessible via HTTP using range requests\n  3. Mapped - serve files according to a specification encoded in JSON format. The JSON can pulled from a remote server, or read from a local file\n\n* Adaptive bitrate support\n\n* Playlist support (playing several different media files one after the other) - mapped mode only\n\n* Simulated live support (generating a live stream from MP4 files) - mapped mode only\n\n* Fallback support for file not found in local/mapped modes (useful in multi-datacenter environments)\n  \n* Video codecs: H264, H265 (DASH/HLS), AV1 (DASH/HLS), VP8 (DASH), VP9 (DASH)\n\n* Audio codecs: AAC, MP3 (HLS/HDS/MSS), AC-3 (DASH/HLS), E-AC-3 (DASH/HLS), VORBIS (DASH), OPUS (DASH), FLAC (HLS), DTS (HLS)\n\n* Captions support - \n  \n  Input:\n  1. WebVTT\n  2. SRT\n  3. DFXP/TTML\n  4. CAP (Cheetah)\n  \n  Output:\n  1. DASH - either a single WebVTT or SMPTE-TT segments (configurable)\n  2. HLS - segmented WebVTT (m3u8)\n  3. MSS - converted to TTML and packaged in fragmented MP4 (no support for styling)\n\n* Audio only/video only files\n\n* Alternative audio renditions - supporting both:\n  1. Generation of manifest with different audio renditions, allowing selection on the client side\n  2. Muxing together audio and video streams from separate files / tracks - provides the ability\n\tto serve different audio renditions of a single video, without the need for any special support\n\ton the client side.\n\n* Track selection for multi audio/video MP4 files\n\n* Playback rate change - 0.5x up to 2x (requires libavcodec and libavfilter)\n\n* Source file clipping (only from I-Frame to P-frame)\n\n* Support for variable segment lengths - enabling the player to select the optimal bitrate fast,\nwithout the overhead of short segments for the whole duration of the video\n\n* Clipping of MP4 files for progressive download playback\n\n* Thumbnail capture (requires libavcodec) and resize (requires libswscale)\n\n* Volume map (requires libavcodec) - returns a CSV containing the volume level in each interval\n\n* Decryption of CENC-encrypted MP4 files (it is possible to create such files with MP4Box)\n\n* DASH: common encryption (CENC) support\n\n* MSS: PlayReady encryption support\n\n* HLS: Generation of I-frames playlist (EXT-X-I-FRAMES-ONLY)\n\n* HLS: support for AES-128 / SAMPLE-AES encryption\n\n### Limitations\n\n* Track selection and playback rate change are not supported in progressive download\n\n* I-frames playlist generation is not supported when encryption is enabled\n\n* Tested on Linux only\n\n### Compilation\n\n#### Dependencies\n\nIn general, if you have the dependencies that are required to build nginx, you should be able to build nginx-vod-module.\nHowever, some optional features of this module depend on additional packages. The module detects these packages \nduring `configure` - if a package is missing, the respective feature will be disabled.\n\nThe optional features are:\n1. Thumbnail capture & volume map - depend on ffmpeg (3.0 or newer)\n2. Audio filtering (for changing playback rate / gain) - depends on ffmpeg (3.0 or newer) and also on libfdk_aac.\n\tDue to licensing issues, libfdk_aac is not built into kaltura ffmpeg packages\n3. Encryption / decryption (DRM / HLS AES) - depends on openssl\n4. DFXP captions - depends on libxml2\n5. UTF-16 encoded SRT files - depends on iconv\n\n#### Build\n\nTo link statically against nginx, cd to nginx source directory and execute:\n\n    ./configure --add-module=/path/to/nginx-vod-module\n    make\n    make install\n\nTo compile as a dynamic module (nginx 1.9.11+), use:\n  \n\t./configure --add-dynamic-module=/path/to/nginx-vod-module\n\nIn this case, the `load_module` directive should be used in nginx.conf in order to load the module.\n\nOptional recommended settings:\n1. `--with-file-aio` - enable asynchronous I/O support, highly recommended, relevant only to local and mapped modes\n2. `--with-threads` (nginx 1.7.11+) - enable asynchronous file open using thread pool (also requires `vod_open_file_thread_pool` in nginx.conf), relevant only to local and mapped modes\n3. `--with-cc-opt=\"-O3 -mpopcnt\"` - enable additional compiler optimizations (we saw about 8% reduction in the mp4 parse time\n\tand frame processing time compared to the nginx default `-O`)\n\nDebug settings:\n1. `--with-debug` - enable debug messages (also requires passing `debug` in the `error_log` directive in nginx.conf).\n2. `--with-cc-opt=\"-O0\"` - disable compiler optimizations (for debugging with gdb)\n\nC Macro Configurations:\n1. `--with-cc-opt=\"-DNGX_VOD_MAX_TRACK_COUNT=256 -mavx2\"` - increase the maximum track count (preferably to multiples of 64). It's recommended to enable vector extensions (AVX2) as well.\n\n### Installation\n\n#### RHEL/CentOS 6/7 RPM\n```sh\n# rpm -ihv http://installrepo.kaltura.org/releases/kaltura-release.noarch.rpm\n# yum install kaltura-nginx\n```\n\n#### Debian/Ubuntu deb package\n*Ubuntu NOTE: before trying to install kaltura-nginx, you must also make sure the multiverse repo is enabled*\n\nFor Debian Wheezy [7], Debian Jessie [8], Ubuntu 14.04 and 14.10, add this repo:\n```sh\n# wget -O - http://installrepo.kaltura.org/repo/apt/debian/kaltura-deb-curr.gpg.key|apt-key add -\n# echo \"deb [arch=amd64] http://installrepo.kaltura.org/repo/apt/debian propus main\" > /etc/apt/sources.list.d/kaltura.list\n```\n\nFor Ubuntu 16.04, 16.10 add this repo:\n```sh\n# wget -O - http://installrepo.kaltura.org/repo/apt/xenial/kaltura-deb-curr-256.gpg.key|apt-key add -\n# echo \"deb [arch=amd64] http://installrepo.kaltura.org/repo/apt/xenial propus main\" > /etc/apt/sources.list.d/kaltura.list\n```\n\nFor Ubuntu 20.04 add this repo:\n```sh\n# wget -O - http://installrepo.kaltura.org/repo/aptn/focal/kaltura-deb-256.gpg.key|apt-key add -\n# echo \"deb [arch=amd64] http://installrepo.kaltura.org/repo/aptn/focal quasar main\" > /etc/apt/sources.list.d/kaltura.list\n```\n\n\nThen install the kaltura-nginx package:\n```sh\n# apt-get update\n# apt-get install kaltura-nginx\n```\n\n\nIf you wish to make use of the following features:\n- Thumbnail capture\n- Playback rate change - 0.5x up to 2x\n\nYou will also need to install the kaltura-ffmpeg (>= 3.1) package.\n\n### URL structure\n\n#### Basic URL structure\n\nThe basic structure of an nginx-vod-module URL is:\n`http://<domain>/<location>/<fileuri>/<filename>`\n\nWhere:\n* domain - the domain of the nginx-vod-module server\n* location - the location specified in the nginx conf\n* fileuri - a URI to the mp4 file:\n  * local mode - the full file path is determined according to the root / alias nginx.conf directives\n  * mapped mode - the full file path is determined according to the JSON received from the upstream / local file\n  * remote mode - the mp4 file is read from upstream in chunks\n  * Note: in mapped & remote modes, the URL of the upstream request is `http://<upstream>/<location>/<fileuri>?<extraargs>`\n  (extraargs is determined by the `vod_upstream_extra_args` parameter)\n* filename - detailed below\n\n#### Multi URL structure\n\nMulti URLs are used to encode several URLs on a single URL. A multi URL can be used to specify\nthe URLs of several different MP4 files that should be included together in a DASH MPD for example.\n\nThe structure of a multi URL is:\n`http://<domain>/<location>/<prefix>,<middle1>,<middle2>,<middle3>,<postfix>.urlset/<filename>`\n\nThe sample URL above represents 3 URLs:\n* `http://<domain>/<location>/<prefix><middle1><postfix>/<filename>`\n* `http://<domain>/<location>/<prefix><middle2><postfix>/<filename>`\n* `http://<domain>/<location>/<prefix><middle3><postfix>/<filename>`\n\nThe suffix `.urlset` (can be changed using `vod_multi_uri_suffix`) indicates that the URL should be treated as a multi URL.\nFor example - the URL `http://example.com/hls/videos/big_buck_bunny_,6,9,15,00k.mp4.urlset/master.m3u8` will return a manifest containing:\n* http://example.com/hls/videos/big_buck_bunny_600k.mp4/index.m3u8\n* http://example.com/hls/videos/big_buck_bunny_900k.mp4/index.m3u8\n* http://example.com/hls/videos/big_buck_bunny_1500k.mp4/index.m3u8\n\n#### URL path parameters\n\nThe following parameters are supported on the URL path:\n* clipFrom - an offset in milliseconds since the beginning of the video, where the generated stream should start. \n\tFor example, `.../clipFrom/10000/...` will generate a stream that starts 10 seconds into the video.\n* clipTo - an offset in milliseconds since the beginning of the video, where the generated stream should end.\n\tFor example, `.../clipTo/60000/...` will generate a stream truncated to 60 seconds.\n* tracks - can be used to select specific audio/video tracks. The structure of the parameter is: `v<id1>-v<id2>-a<id1>-a<id2>...`\n\tFor example, `.../tracks/v1-a1/...` will select the first video track and first audio track.\n\tThe default is to include all tracks.\n* shift - can be used to apply a timing shift to one or more streams. The structure of the parameter is: `v<vshift>-a<ashift>-s<sshift>`\n\tFor example, `.../shift/v100/...` will apply a forward shift of 100ms to the video timestamps.\n\n#### Filename structure\n\nThe structure of filename is:\n`<basename>[<seqparams>][<fileparams>][<trackparams>][<langparams>].<extension>`\n\nWhere:\n* basename + extension - the set of options is packager specific (the list below applies to the default settings):\n  * dash - manifest.mpd\n  * hds - manifest.f4m\n  * hls master playlist - master.m3u8\n  * hls media playlist - index.m3u8\n  * mss - manifest\n  * thumb - `thumb-<offset>[<resizeparams>].jpg` (offset is the thumbnail video offset in milliseconds)\n  * volume_map - `volume_map.csv`\n* seqparams - can be used to select specific sequences by id (provided in the mapping JSON), e.g. master-sseq1.m3u8.\n* fileparams - can be used to select specific sequences by index when using multi URLs.\n\tFor example, manifest-f1.mpd will return an MPD only from the first URL.\n* trackparams - can be used to select specific audio/video tracks.\n\tFor example, manifest-a1.f4m will return an F4M containing only the first audio stream of each sequence.\n\tThe default is to include the first audio and first video tracks of each file.\n\tThe tracks selected on the file name are AND-ed with the tracks selected with the /tracks/ path parameter.\n\tv0/a0 select all video/audio tracks respectively.\n\tThe a/v parameters can be combined with f/s, e.g. f1-v1-f2-a1 = video1 of file1 + audio1 of file2, f1-f2-v1 = video1 of file1 + video1 of file2.\n* langparams - can be used to filter audio tracks/subtitles according to their language (ISO639-3 code).\n\tFor example, master-leng.m3u8 will return only english audio tracks.\n* resizeparams - can be used to resize the returned thumbnail image. For example, thumb-1000-w150-h100.jpg captures a thumbnail\n\t1 second into the video, and resizes it to 150x100. If one of the dimensions is omitted, its value is set so that the \n\tresulting image will retain the aspect ratio of the video frame.\n\n### Mapping response format\n\nWhen configured to run in mapped mode, nginx-vod-module issues an HTTP request to a configured upstream server \nin order to receive the layout of media streams it should generate.\nThe response has to be in JSON format. \n\nThis section contains a few simple examples followed by a reference of the supported objects and fields. \nBut first, a couple of definitions:\n\n1. `Source Clip` - a set of audio and/or video frames (tracks) extracted from a single media file\n2. `Generator` - a component that can generate audio/video frames. Currently, the only supported generator is the silence generator.\n3. `Filter` - a manipulation that can be applied on audio/video frames. The following filters are supported: \n  * rate (speed) change - applies to both audio and video\n  * audio volume change\n  * mix - can be used to merge several audio tracks together, or to merge the audio of source A with the video of source B\n4. `Clip` - the result of applying zero or more filters on a set of source clips\n5. `Dynamic Clip` - a clip whose contents is not known in advance, e.g. targeted ad content\n6. `Sequence` - a set of clips that should be played one after the other. \n7. `Set` - several sequences that play together as an adaptive set, each sequence must have the same number of clips.\n\n#### Simple mapping\n\nThe JSON below maps the request URI to a single MP4 file:\n```json\n{\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\nWhen using multi URLs, this is the only allowed JSON pattern. In other words, it is not\npossible to combine more complex JSONs using multi URL.\n\n#### Adaptive set\n\nAs an alternative to using multi URL, an adaptive set can be defined via JSON:\n```json\n{\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/bitrate1.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/bitrate2.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n#### Playlist\n\nThe JSON below will play 35 seconds of video1 followed by 22 seconds of video2:\n```json\n{\n\t\"durations\": [ 35000, 22000 ],\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video1.mp4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video2.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n#### Filters\n\nThe JSON below takes video1, plays it at x1.5 and mixes the audio of the result with the audio of video2,\nafter reducing it to 50% volume:\n```json\n{\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mixFilter\",\n\t\t\t\t\t\"sources\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"rateFilter\",\n\t\t\t\t\t\t\t\"rate\": 1.5,\n\t\t\t\t\t\t\t\"source\": {\n\t\t\t\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\t\t\t\"path\": \"/path/to/video1.mp4\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"gainFilter\",\n\t\t\t\t\t\t\t\"gain\": 0.5,\n\t\t\t\t\t\t\t\"source\": {\n\t\t\t\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\t\t\t\"path\": \"/path/to/video2.mp4\",\n\t\t\t\t\t\t\t\t\"tracks\": \"a1\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n#### Continuous live\n\nThe JSON below is a sample of a continuous live stream (=a live stream in which all videos have exactly the same encoding parameters).\nIn practice, this JSON will have to be generated by some script, since it is time dependent.\n(see test/playlist.php for a sample implementation)\n```json\n{\n\t\"playlistType\": \"live\",\n\t\"discontinuity\": false,\n\t\"segmentBaseTime\": 1451904060000,\n\t\"firstClipTime\": 1451917506000,\n\t\"durations\": [83000, 83000],\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video1.mp4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video2.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n#### Non-continuous live\n\nThe JSON below is a sample of a non-continuous live stream (=a live stream in which the videos have different encoding parameters).\nIn practice, this JSON will have to be generated by some script, since it is time dependent \n(see test/playlist.php for a sample implementation)\n```json\n{\n\t\"playlistType\": \"live\",\n\t\"discontinuity\": true,\n\t\"initialClipIndex\": 171,\n\t\"initialSegmentIndex\": 153,\n\t\"firstClipTime\": 1451918170000,\n\t\"durations\": [83000, 83000],\n\t\"sequences\": [\n\t\t{\n\t\t\t\"clips\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video1.mp4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"source\",\n\t\t\t\t\t\"path\": \"/path/to/video2.mp4\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n### Mapping reference\n\n#### Set (top level object in the mapping JSON)\n\nMandatory fields:\n* `sequences` - array of Sequence objects. \n\tThe mapping has to contain at least one sequence and up to 32 sequences.\n\t\nOptional fields:\n* `id` - a string that identifies the set. The id can be retrieved by `$vod_set_id`.\n* `playlistType` - string, can be set to `live`, `vod` or `event` (only supported for HLS playlists), default is `vod`.\n* `durations` - an array of integers representing clip durations in milliseconds.\n\tThis field is mandatory if the mapping contains more than a single clip per sequence.\n\tIf specified, this array must contain at least one element and up to 128 elements.\n* `discontinuity` - boolean, indicates whether the different clips in each sequence have\n\tdifferent media parameters. This field has different manifestations according to the \n\tdelivery protocol - a value of true will generate `#EXT-X-DISCONTINUITY` in HLS, \n\tand a multi period MPD in DASH. The default value is true, set to false only if the media\n\tfiles were transcoded with exactly the same parameters (in AVC for example, \n\tthe clips should have exactly the same SPS/PPS).\n* `segmentDuration` - integer, sets the segment duration in milliseconds. This field, \n\tif specified, takes priority over the value set in `vod_segment_duration`.\n* `consistentSequenceMediaInfo` - boolean, currently affects only DASH. When set to true (default)\n\tthe MPD will report the same media parameters in each period element. Setting to false\n\tcan have severe performance implications for long sequences (nginx-vod-module has \n\tto read the media info of all clips included in the mapping in order to generate the MPD)\n* `referenceClipIndex` - integer, sets the (1-based) index of the clip that should be used \n\tto retrieve the video metadata for manifest requests (codec, width, height etc.)\n\tIf `consistentSequenceMediaInfo` is set to false, this parameter has no effect -\n\tall clips are parsed. If this parameter is not specified, nginx-vod-module uses the last clip \n\tby default.\n* `notifications` - array of notification objects (see below), when a segment is requested,\n\tall the notifications that fall between the start/end times of the segment are fired.\n\tthe notifications must be ordered in an increasing offset order.\n* `clipFrom` - integer, contains a timestamp indicating where the returned stream should start.\n\tSetting this parameter is equivalent to passing /clipFrom/ on the URL.\n* `clipTo` - integer, contains a timestamp indicating where the returned stream should end.\n\tSetting this parameter is equivalent to passing /clipTo/ on the URL.\n* `cache` - boolean, if set to false, the mapping response will not be saved to cache (vod_mapping_cache).\n\tThe default value is true.\n* `closedCaptions` - array of closed captions objects (see below), containing languages and ids\n\tof any embedded CEA-608 / CEA-708 captions. If an empty array is provided, the module will output\n\t`CLOSED-CAPTIONS=NONE` on each `EXT-X-STREAM-INF` tag. If the list does not appear in the JSON, the \n\tmodule will not output any `CLOSED-CAPTIONS` fields in the playlist.\n\t\nLive fields:\n* `firstClipTime` - integer, mandatory for all live playlists unless `clipTimes` is specified.\n\tContains the absolute time of the first clip in the playlist, in milliseconds since the epoch (unixtime x 1000)\n* `clipTimes` - array of integers, sets the absolute time of all the clips in the playlist, \n\tin milliseconds since the epoch (unixtime x 1000). This field can be used only when \n\t`discontinuity` is set to true. The timestamps may contain gaps, but they are not allowed to overlap\n\t(`clipTimes[n + 1] >= clipTimes[n] + durations[n]`)\n* `segmentBaseTime` - integer, mandatory for continuous live streams, contains the absolute\n\ttime of the first segment of the stream, in milliseconds since the epoch (unixtime x 1000).\n\tThis value must not change during playback.\n\tFor discontinuous live streams, this field is optional:\n\t* if not set, sequential segment indexes will be used throughout the playlist.\n\t\tIn this case, the upstream server generating the mapping json has to maintain state,\n\t\tand update initialSegmentIndex every time a clip is removed from the playlist.\n\t* if set, the timing gaps between clips must not be lower than `vod_segment_duration`.\n* `firstClipStartOffset` - integer, optional, measured in milliseconds. This field contains the\n\tdifference between first clip time, and the original start time of the first clip -\n\tthe time it had when it was initially added (before the live window shifted)\n* `initialClipIndex` - integer, mandatory for non-continuous live streams that mix videos having\n\tdifferent encoding parameters (SPS/PPS), contains the index of the first clip in the playlist. \n\tWhenever a clip is pushed out of the head of the playlist, this value must be incremented by one.\n* `initialSegmentIndex` - integer, mandatory for live streams that do not set `segmentBaseTime`, \n\tcontains the index of the first segment in the playlist. Whenever a clip is pushed out of the head of\n\tthe playlist, this value must be incremented by the number of segments in the clip.\n* `presentationEndTime` - integer, optional, measured in milliseconds since the epoch.\n\twhen supplied, the module will compare the current time to the supplied value, \n\tand signal the end of the live presentation if `presentationEndTime` has passed. \n\tIn HLS, for example, this parameter controls whether an `#EXT-X-ENDLIST` tag should be \n\tincluded in the media playlist.\n\tWhen the parameter is not supplied, the module will not signal live presentation end.\n* `expirationTime` - integer, optional, measured in milliseconds since the epoch.\n\twhen supplied, the module will compare the current time to the supplied value, \n\tand if `expirationTime` has passed, the module will return a 404 error for manifest requests \n\t(segment requests will continue to be served).\n\twhen both presentationEndTime and expirationTime have passed, presentationEndTime takes\n\tpriority, i.e. manifest requests will be served and signal presentation end.\n* `liveWindowDuration` - integer, optional, provides a way to override `vod_live_window_duration`\n\tspecified in the configuration. If the value exceeds the absolute value specified in \n\t`vod_live_window_duration`, it is ignored.\n* `timeOffset` - integer, sets an offset that should be applied to the server clock when serving\n\tlive requests. This parameter can be used to test future/past events.\n\t\n#### Sequence\n\nMandatory fields:\n* `clips` - array of Clip objects (mandatory). The number of elements must match the number\n\tthe durations array specified on the set. If the durations array is not specified,\n\tthe clips array must contain a single element.\n\t\nOptional fields:\n* `id` - a string that identifies the sequence. The id can be retrieved by `$vod_sequence_id`.\n* `language` - a 3-letter (ISO-639-2) language code, this field takes priority over any language\n\tspecified on the media file (MP4 mdhd atom)\n* `label` - a friendly string that identifies the sequence. If a language is specified,\n\ta default label will be automatically derived by it - e.g. if language is `ita`, \n\tby default `italiano` will be used as the label.\n* `default` - a boolean that sets the value of the DEFAULT attribute of EXT-X-MEDIA tags using this sequence.\n\tIf not specified, the first EXT-X-MEDIA tag in each group returns DEFAULT=YES, while the others return DEFAULT=NO.\n* `bitrate` - an object that can be used to set the bitrate for the different media types,\n\tin bits per second. For example, `{\"v\": 900000, \"a\": 64000}`. If the bitrate is not supplied,\n\tnginx-vod-module will estimate it based on the last clip in the sequence.\n* `avg_bitrate` - an object that can be used to set the average bitrate for the different media types,\n\tin bits per second. See `bitrate` above for a sample object. If specified, the module will use\n\tthe value to populate the AVERAGE-BANDWIDTH attribute of `#EXT-X-STREAM-INF` in HLS.\n\n#### Clip (abstract)\n\nMandatory fields:\n* `type` - a string that defines the type of the clip. Allowed values are:\n\t* source\n\t* rateFilter\n\t* mixFilter\n\t* gainFilter\n\t* silence\n\t* concat\n\t* dynamic\n\nOptional fields:\n* `keyFrameDurations` - array of integers, containing the durations in milliseconds of the video key frames\n\tin the clip. This property can only be supplied on the top level clips of each sequence,\n\tsupplying this property on nested clips has no effect.\n\tSupplying the key frame durations enables the module to both:\n\t1. align the segments to key frames \n\t2. report the correct segment durations in the manifest - providing an alternative to setting\n\t\t`vod_manifest_segment_durations_mode` to `accurate`, which is not supported for multi clip\n\t\tmedia sets (for performance reasons).\n* `firstKeyFrameOffset` - integer, offset of the first video key frame in the clip, \n\tmeasured in milliseconds relative to `firstClipTime`. Defaults to 0 if not supplied.\n\n#### Source clip\n\nMandatory fields:\n* `type` - a string with the value `source`\n* `path` - a string containing the path of the MP4 file. The string `\"empty\"` can be used to represent\n\tan empty captions file (useful in case only some videos in a playlist have captions)\n\nOptional fields:\n* `id` - a string that identifies the source clip\n* `sourceType` - sets the interface that should be used to read the MP4 file, allowed values are:\n\t`file` and `http`. By default, the module uses `http` if `vod_remote_upstream_location` is set,\n\tand `file` otherwise.\n* `tracks` - a string that specifies the tracks that should be used, the default is \"v1-a1\",\n\twhich means the first video track and the first audio track\n* `clipFrom` - an integer that specifies an offset in milliseconds, from the beginning of the \n\tmedia file, from which to start loading frames\n* `encryptionKey` - a base64 encoded string containing the key (128/192/256 bit) that should be used\n\tto decrypt the file.\n* `encryptionIv` - a base64 encoded string containing the iv (128 bit) that should be used\n\tto decrypt the file.\n* `encryptionScheme` - the encryption scheme that was used to encrypt the file. Currently,\n\tonly two schemes are supported - `cenc` for MP4 files, `aes-cbc` for caption files.\n\n#### Rate filter clip\n\nMandatory fields:\n* `type` - a string with the value `rateFilter`\n* `rate` - a float that specified the acceleration factor, e.g. a value of 2 means double speed.\n\tAllowed values are in the range 0.5 - 2 with up to two decimal points\n* `source` - a clip object on which to perform the rate filtering\n\n#### Gain filter clip\n\nMandatory fields:\n* `type` - a string with the value `gainFilter`\n* `gain` - a float that specified the amplification factor, e.g. a value of 2 means twice as loud.\n\tThe gain must be positive with up to two decimal points\n* `source` - a clip object on which to perform the gain filtering\n\n#### Mix filter clip\n\nMandatory fields:\n* `type` - a string with the value `mixFilter`\n* `sources` - an array of Clip objects to mix. This array must contain at least one clip and\n\tup to 32 clips.\n\n#### Concat clip\n\nMandatory fields:\n* `type` - a string with the value `concat`\n* `durations` - an array of integers representing MP4 durations in milliseconds,\n\tthis array must match the `paths` array in count and order.\n\nOptional fields:\n* `paths` - an array of strings, containing the paths of the MP4 files. Either `paths` or `clipIds` must be specified.\n* `clipIds` - an array of strings, containing the ids of source clips. \n\tThe ids are translated to paths by issuing a request to the uri specified in `vod_source_clip_map_uri`.\n\tEither `paths` or `clipIds` must be specified.\n* `tracks` - a string that specifies the tracks that should be used, the default is \"v1-a1\",\n\twhich means the first video track and the first audio track\n* `offset` - an integer in milliseconds that indicates the timestamp offset of the \n\tfirst frame in the concatenated stream relative to the clip start time\n* `basePath` - a string that should be added as a prefix to all the paths\n* `notifications` - array of notification objects (see below), when a segment is requested,\n\tall the notifications that fall between the start/end times of the segment are fired.\n\tthe notifications must be ordered in an increasing offset order.\n\n#### Dynamic clip\n\nMandatory fields:\n* `type` - a string with the value `dynamic`\n* `id` - a string that uniquely identifies the dynamic clip, used for mapping the clip to its content\n\n#### Notification\n\nMandatory fields:\n* `offset` - an integer in milliseconds that indicates the time in which the notification should be fired.\n\twhen the notification object is contained in the media set, `offset` is relative to `firstClipTime`\n\t(0 for vod). when the notification object is contained in a concat clip, `offset` is relative to\n\tthe beginning of the concat clip.\n* `id` - a string that identifies the notification, this id can be referenced by `vod_notification_uri`\n\tusing the variable `$vod_notification_id`\n\n#### Closed Captions\n\nMandatory fields:\n* `id` - a string that identifies the embedded captions. This will become the `INSTREAM-ID` field and must\nhave one of the following values: `CC1`, `CC3`, `CC3`, `CC4`, or `SERVICEn`, where `n` is between 1 and 63.\n* `label` - a friendly string that indicates the language of the closed caption track.\n\nOptional fields:\n* `language` - a 3-letter (ISO-639-2) language code that indicates the language of the closed caption track.\n\n\n### Security\n\n#### Authorization\n\n##### CDN-based delivery\n\nMedia packaged by nginx-vod-module can be protected using CDN tokens, this works as follows:\n* Some application authenticates the user and decides whether the user should be allowed \n\tto watch a specific video. If the user is allowed, the application generates a tokenized\n\tURL for the manifest of the video.\n* The CDN validates the token, and if found to be valid, forwards the request to nginx-vod-module \n\ton the origin. \n* The nginx server builds the manifest response and generates tokens for the segment URLs\n\tcontained inside it. The module https://github.com/kaltura/nginx-secure-token-module can\n\tbe used to accomplish this task, it currently support Akamai tokens and CloudFront tokens.\n\tSee the readme of this module for more details.\n* The CDN validates the token on each segment that is requested.\n\nIn this setup it also highly recommended to block direct access to the origin server by\nauthenticating the CDN requests. Without this protection, a user who somehow gets the address\nof the origin will be able to bypass the CDN token enforcement. If using Akamai, this can\nbe accomplished using https://github.com/refractalize/nginx_mod_akamai_g2o.\nFor other CDNs, it may be possible to configure the CDN to send a secret header to the origin\nand then simply enforce the header using an nginx if statement:\n```c\n\t\tif ($http_x_secret_origin_header != \"secret value\") {\n\t\t\treturn 403;\n\t\t}\n```\n\nIn addition to the above, most CDNs support other access control settings, such as geo-location.\nThese restrictions are completely transparent to the origin and should work well. \n\n##### Direct delivery\n\nDeployments in which the media is pulled directly from nginx-vod-module can protect the media\nusing nginx access control directives, such `allow`, `deny`, or `access_by_lua` (for more complex\nscenarios).\n\nIn addition, it is possible to build a token based solution (as detailed in the previous section) \nwithout a CDN, by having the nginx server validate the token. \nThe module https://github.com/kaltura/nginx-akamai-token-validate-module can be used\nto validate Akamai tokens. Locations on which the module is enabled will return 403 unless the \nrequest contains a valid Akamai token. See the readme of this module for more details.\n\n#### URL encryption\n\nAs an alternative to tokenization, URL encryption can be used to prevent an attacker from being\nable to craft a playable URL. URL encryption can be implemented with \nhttps://github.com/kaltura/nginx-secure-token-module, and is supported for HLS and DASH (with \nmanifest format set to segmentlist). \n\nIn terms of security, the main advantage of CDN tokens over URL encryption is that CDN tokens\nusually expire, while encrypted URLs do not (someone who obtains a playable URL will be able to\nuse it indefinitely)\n\n#### Media encryption\n\nNginx-vod-module supports AES-128 and SAMPLE-AES HLS encryption schemes. The main difference between\nmedia encryption and DRM (detailed below) is the mechanism used to transfer the encryption key to \nthe client. With media encryption the key is fetched by the client by performing a simple GET request\nto nginx-vod-module, while with DRM the key is returned inside a vendor specific license response.\n\nMedia encryption reduces the problem of securing the media to the need to secure the encryption key. \nThe media segment URLs (which compose the vast majority of the traffic) can be completely unprotected, \nand easily cacheable by any proxies between the client and servers (unlike tokenization). \nThe encryption key request can then be protected using one of the methods mentioned above (CDN tokens,\nnginx access rules etc.). \n\nIn addition, it is possible to configure nginx-vod-module to return the encryption key over HTTPS\nwhile having the segments delivered over HTTP. The way to configure this is to set `vod_segments_base_url`\nto `http://nginx-vod-host` and set `vod_base_url` to `https://nginx-vod-host`.\n\n#### DRM\n\nNginx-vod-module has the ability to perform on-the-fly encryption for MPEG DASH (CENC), MSS Play Ready and FairPlay HLS.\nAs in the case of media encryption, the encryption is performed while serving a video/audio segment to the client, \ntherefore, when working with DRM it is recommended not to serve the content directly from nginx-vod-module to end-users.\nA more scalable architecture would be to use proxy servers or a CDN in order to cache the encrypted segments.\n\nIn order to perform the encryption, nginx-vod-module needs several parameters, including key & key_id, these parameters\nare fetched from an external server via HTTP GET requests.\nThe `vod_drm_upstream_location` parameter specifies an nginx location that is used to access the DRM server,\nand the request uri is configured using `vod_drm_request_uri` (this parameter can include nginx variables). \nThe response of the DRM server is a JSON, with the following format:\n\n```json\n[{\n\t\"pssh\": [{\n\t\t\t\"data\": \"CAESEGMyZjg2MTczN2NjNGYzODIaB2thbHR1cmEiCjBfbmptaWlwbXAqBVNEX0hE\", \n\t\t\t\"uuid\": \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n\t\t}], \n\t\"key\": \"GzoNU9Dfwc//Iq3/zbzMUw==\", \n\t\"key_id\": \"YzJmODYxNzM3Y2M0ZjM4Mg==\"\n}]\n```\n\n* `pssh.data` - base64 encoded binary data, the format of this data is drm vendor specific\n* `pssh.uuid` - the drm system UUID, in this case, edef8ba9-79d6-4ace-a3c8-27dcd51d21ed stands for Widevine\n* `key` - base64 encoded encryption key (128 bit)\n* `key_id` - base64 encoded key identifier (128 bit)\n* `iv` - optional base64 encoded initialization vector (128 bit). The IV is currently used only in HLS (FairPlay), \n\tin the other protocols an IV is generated automatically by nginx-vod-module.\n\n##### Sample configurations\n\nApple FairPlay HLS:\n```nginx\nlocation ~ ^/fpshls/p/\\d+/(sp/\\d+/)?serveFlavor/entryId/([^/]+)/(.*) {\n\tvod hls;\n\tvod_hls_encryption_method sample-aes;\n\tvod_hls_encryption_key_uri \"skd://entry-$2\";\n\tvod_hls_encryption_key_format \"com.apple.streamingkeydelivery\";\n\tvod_hls_encryption_key_format_versions \"1\";\n\n\tvod_drm_enabled on;\n\tvod_drm_request_uri \"/udrm/system/ovp/$vod_suburi\";\n\n\tvod_last_modified_types *;\n\tadd_header Access-Control-Allow-Headers '*';\n\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\tadd_header Access-Control-Allow-Origin '*';\n\texpires 100d;\n}\n```\n\nCommon Encryption HLS:\n```nginx\nlocation ~ ^/cenchls/p/\\d+/(sp/\\d+/)?serveFlavor/entryId/([^/]+)/(.*) {\n\tvod hls;\n\tvod_hls_encryption_method sample-aes-cenc;\n\tvod_hls_encryption_key_format \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\";\n\tvod_hls_encryption_key_format_versions \"1\";\n\n\tvod_drm_enabled on;\n\tvod_drm_request_uri \"/udrm/system/ovp/$vod_suburi\";\n\n\tvod_last_modified_types *;\n\tadd_header Access-Control-Allow-Headers '*';\n\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\tadd_header Access-Control-Allow-Origin '*';\n\texpires 100d;\n}\n```\n\n##### Verified configurations\n\nFollowing is a list of configurations that were tested and found working:\n* DASH/CENC with PlayReady & Widevine PSSH together\n* MSS PlayReady\n* HLS FairPlay\n\n### Performance recommendations\n\n1. For medium/large scale deployments, don't have users play the videos directly from nginx-vod-module.\n\tSince all the different streaming protocols supported by nginx vod are HTTP based, they can be cached by standard HTTP proxies / CDNs. \n\tFor medium scale add a layer of caching proxies between the vod module and the end users \n\t(can use standard nginx servers with proxy_pass & proxy_cache). \n\tFor large scale deployments, it is recommended to use a CDN (such as Akamai, Level3 etc.). \n\t\n\tIn general, it's best to have nginx vod as close as possible to where the mp4 files are stored, \n\tand have the caching proxies as close as possible to the end users.\n2. Enable nginx-vod-module caches:\n\t* `vod_metadata_cache` - saves the need to re-read the video metadata for each segment. This cache should be rather large, in the order of GBs.\n\t* `vod_response_cache` - saves the responses of manifest requests. This cache may not be required when using a second layer of caching servers before nginx vod. \n\t\tNo need to allocate a large buffer for this cache, 128M is probably more than enough for most deployments.\n\t* `vod_mapping_cache` - for mapped mode only, few MBs is usually enough.\n\t* nginx's open_file_cache - caches open file handles.\n\n\tThe hit/miss ratios of these caches can be tracked by enabling performance counters (`vod_performance_counters`)\n\tand setting up a status page for nginx vod (`vod_status`)\n3. In local & mapped modes, enable aio. - nginx has to be compiled with aio support, and it has to be enabled in nginx conf (aio on). \n\tYou can verify it works by looking at the performance counters on the vod status page - read_file (aio off) vs. async_read_file (aio on)\n4. In local & mapped modes, enable asynchronous file open - nginx has to be compiled with threads support, and `vod_open_file_thread_pool`\n\thas to be specified in nginx.conf. You can verify it works by looking at the performance counters on the vod status page - \n\topen_file vs. async_open_file. Note that open_file may be nonzero with vod_open_file_thread_pool enabled, due to the open file cache - \n\topen requests that are served from cache will be counted as synchronous open_file.\n5. When using DRM enabled DASH/MSS, if the video files have a single nalu per frame, set `vod_min_single_nalu_per_frame_segment` to non-zero.\n6. The muxing overhead of the streams generated by this module can be reduced by changing the following parameters:\n\t* HDS - set `vod_hds_generate_moof_atom` to off\n\t* HLS - set `vod_hls_mpegts_align_frames` to off and `vod_hls_mpegts_interleave_frames` to on\n7. Enable gzip compression on manifest responses - \n\n\t`gzip_types application/vnd.apple.mpegurl video/f4m application/dash+xml text/xml`\n8. Apply common nginx performance best practices, such as tcp_nodelay=on, client_header_timeout etc.\n\n### Configuration directives - base\n\n#### vod\n* **syntax**: `vod segmenter`\n* **default**: `n/a`\n* **context**: `location`\n\nEnables the nginx-vod module on the enclosing location. \nThe allowed values for `segmenter` are:\n\n1. `none` - serves the MP4 files as is / clipped\n2. `dash` - Dynamic Adaptive Streaming over HTTP packager\n3. `hds` - Adobe HTTP Dynamic Streaming packager\n4. `hls` - Apple HTTP Live Streaming packager\n5. `mss` - Microsoft Smooth Streaming packager\n6. `thumb` - thumbnail capture\n7. `volume_map` - audio volume map\n\n#### vod_mode\n* **syntax**: `vod_mode mode`\n* **default**: `local`\n* **context**: `http`, `server`, `location`\n\nSets the file access mode - local, remote or mapped (see the features section above for more details)\n\n#### vod_status\n* **syntax**: `vod_status`\n* **default**: `n/a`\n* **context**: `location`\n\nEnables the nginx-vod status page on the enclosing location. \nThe following query params are supported:\n* `?reset=1` - resets the performance counters and cache stats.\n* `?format=prom` - returns the output in format compatible with Prometheus (the default format is XML).\n\n### Configuration directives - segmentation\n\n#### vod_segment_duration\n* **syntax**: `vod_segment_duration duration`\n* **default**: `10s`\n* **context**: `http`, `server`, `location`\n\nSets the segment duration in milliseconds. It is highly recommended to use a segment duration that is a multiple of the GOP duration.\nIf the segment duration is not a multiple of GOP duration, and `vod_align_segments_to_key_frames` is enabled, there could be significant\ndifferences between the segment duration that is reported in the manifest and the actual segment duration. This could also lead to\nthe appearance of empty segments within the stream.\n\n#### vod_live_window_duration\n* **syntax**: `vod_live_window_duration duration`\n* **default**: `30000`\n* **context**: `http`, `server`, `location`\n\nSets the total duration in milliseconds of the segments that should be returned in a live manifest.\nIf the value is positive, nginx vod returns a range of maximum `vod_live_window_duration` milliseconds, ending at the current server time.\nIf the value is negative, nginx vod returns a range of maximum `-vod_live_window_duration` milliseconds from the end of the mapping json.\nIf the value is set to zero, the live manifest will contain all the segments that are fully contained in the mapping json time frame.\n\n#### vod_force_playlist_type_vod\n* **syntax**: `vod_force_playlist_type_vod on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nGenerate a vod stream even when the media set has `playlistType=live`. \nEnabling this setting has the following effects:\n1. Frame timestamps will be continuous and start from zero\n2. Segment indexes will start from one\n3. In case of HLS, the returned manifest will have both `#EXT-X-PLAYLIST-TYPE:VOD` and `#EXT-X-ENDLIST`\n\nThis can be useful for clipping vod sections out of a live stream.\n\n#### vod_force_continuous_timestamps\n* **syntax**: `vod_force_continuous_timestamps on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nGenerate continuous timestamps even when the media set has gaps (gaps can created by the use of `clipTimes`)\nIf ID3 timestamps are enabled (`vod_hls_mpegts_output_id3_timestamps`), they contain the original timestamps that were set in `clipTimes`.\n\n#### vod_bootstrap_segment_durations\n* **syntax**: `vod_bootstrap_segment_durations duration`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nAdds a bootstrap segment duration in milliseconds. This setting can be used to make the first few segments\nshorter than the default segment duration, thus making the adaptive bitrate selection kick-in earlier without \nthe overhead of short segments throughout the video.\n\n#### vod_align_segments_to_key_frames\n* **syntax**: `vod_align_segments_to_key_frames on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module forces all segments to start with a key frame. Enabling this setting can lead to differences\nbetween the actual segment durations and the durations reported in the manifest (unless `vod_manifest_segment_durations_mode` is set to accurate).\n\n#### vod_segment_count_policy\n* **syntax**: `vod_segment_count_policy last_short/last_long/last_rounded`\n* **default**: `last_short`\n* **context**: `http`, `server`, `location`\n\nConfigures the policy for calculating the segment count, for segment_duration = 10 seconds:\n* last_short - a file of 33 sec is partitioned as - 10, 10, 10, 3\n* last_long - a file of 33 sec is partitioned as - 10, 10, 13\n* last_rounded - a file of 33 sec is partitioned as - 10, 10, 13, a file of 38 sec is partitioned as 10, 10, 10, 8\n\n#### vod_manifest_duration_policy\n* **syntax**: `vod_manifest_duration_policy min/max`\n* **default**: `max`\n* **context**: `http`, `server`, `location`\n\nConfigures the policy for calculating the duration of a manifest containing multiple streams:\n* max - uses the maximum stream duration (default)\n* min - uses the minimum non-zero stream duration\n\n#### vod_manifest_segment_durations_mode\n* **syntax**: `vod_manifest_segment_durations_mode estimate/accurate`\n* **default**: `estimate`\n* **context**: `http`, `server`, `location`\n\nConfigures the calculation mode of segment durations within manifest requests:\n* estimate - reports the duration as configured in nginx.conf, e.g. if `vod_segment_duration` has the value 10000,\nan HLS manifest will contain #EXTINF:10\n* accurate - reports the exact duration of the segment, taking into account the frame durations, e.g. for a \nframe rate of 29.97 and 10 second segments it will report the first segment as 10.01. accurate mode also\ntakes into account the key frame alignment, in case `vod_align_segments_to_key_frames` is on\n\n#### vod_media_set_override_json\n* **syntax**: `vod_media_set_override_json json`\n* **default**: `{}`\n* **context**: `http`, `server`, `location`\n\nThis parameter provides a way to override portions of the media set JSON (mapped mode only).\nFor example, `vod_media_set_override_json '{\"clipTo\":20000}'` clips the media set to 20 sec.\nThe parameter value can contain variables.\n\n### Configuration directives - upstream\n\n#### vod_upstream_location\n* **syntax**: `vod_upstream_location location`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets an nginx location that is used to read the MP4 file (remote mode) or mapping the request URI (mapped mode).\n\n#### vod_remote_upstream_location\n* **syntax**: `vod_remote_upstream_location location`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets an nginx location that is used to read the MP4 file on remote or mapped mode. If this directive is set on mapped mode, the module reads \nthe MP4 files over HTTP, treating the paths in the mapping JSON as URIs (the default behavior is to read from local files)\n\n#### vod_max_upstream_headers_size\n* **syntax**: `vod_max_upstream_headers_size size`\n* **default**: `4k`\n* **context**: `http`, `server`, `location`\n\nSets the size that is allocated for holding the response headers when issuing upstream requests (to vod_xxx_upstream_location).\n\n#### vod_upstream_extra_args\n* **syntax**: `vod_upstream_extra_args \"arg1=value1&arg2=value2&...\"`\n* **default**: `empty`\n* **context**: `http`, `server`, `location`\n\nExtra query string arguments that should be added to the upstream request (remote/mapped modes only).\nThe parameter value can contain variables.\n\n#### vod_media_set_map_uri\n* **syntax**: `vod_media_set_map_uri uri`\n* **default**: `$vod_suburi`\n* **context**: `http`, `server`, `location`\n\nSets the uri of media set mapping requests, the parameter value can contain variables.\nIn case of multi url, `$vod_suburi` will be the current sub uri (a separate request is issued per sub URL)\n\n#### vod_path_response_prefix\n* **syntax**: `vod_path_response_prefix prefix`\n* **default**: `{\"sequences\":[{\"clips\":[{\"type\":\"source\",\"path\":\"`\n* **context**: `http`, `server`, `location`\n\nSets the prefix that is expected in URI mapping responses (mapped mode only).\n\n#### vod_path_response_postfix\n* **syntax**: `vod_path_response_postfix postfix`\n* **default**: `\"}]}]}`\n* **context**: `http`, `server`, `location`\n\nSets the postfix that is expected in URI mapping responses (mapped mode only).\n\n#### vod_max_mapping_response_size\n* **syntax**: `vod_max_mapping_response_size length`\n* **default**: `1K`\n* **context**: `http`, `server`, `location`\n\nSets the maximum length of a path returned from upstream (mapped mode only).\n\n### Configuration directives - fallback\n\n#### vod_fallback_upstream_location\n* **syntax**: `vod_fallback_upstream_location location`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets an nginx location to which the request is forwarded after encountering a file not found error (local/mapped modes only).\n\n#### vod_proxy_header_name\n* **syntax**: `vod_proxy_header_name name`\n* **default**: `X-Kaltura-Proxy`\n* **context**: `http`, `server`, `location`\n\nSets the name of an HTTP header that is used to prevent fallback proxy loops (local/mapped modes only).\n\n#### vod_proxy_header_value\n* **syntax**: `vod_proxy_header_value name`\n* **default**: `dumpApiRequest`\n* **context**: `http`, `server`, `location`\n\nSets the value of an HTTP header that is used to prevent fallback proxy loops (local/mapped modes only).\n\n### Configuration directives - performance\n\n#### vod_metadata_cache\n* **syntax**: `vod_metadata_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the video metadata cache. For MP4 files, this cache holds the moov atom.\n\n#### vod_mapping_cache\n* **syntax**: `vod_mapping_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the mapping cache for vod (mapped mode only).\n\n#### vod_live_mapping_cache\n* **syntax**: `vod_live_mapping_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the mapping cache for live (mapped mode only).\n\n#### vod_response_cache\n* **syntax**: `vod_response_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the response cache. The response cache holds manifests\nand other non-video content (like DASH init segment, HLS encryption key etc.). Video segments are not cached.\n\n#### vod_live_response_cache\n* **syntax**: `vod_live_response_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the response cache for time changing live responses. \nThis cache holds the following types of responses for live: DASH MPD, HLS index M3U8, HDS bootstrap, MSS manifest.\n\n#### vod_initial_read_size\n* **syntax**: `vod_initial_read_size size`\n* **default**: `4K`\n* **context**: `http`, `server`, `location`\n\nSets the size of the initial read operation of the MP4 file.\n\n#### vod_max_metadata_size\n* **syntax**: `vod_max_metadata_size size`\n* **default**: `128MB`\n* **context**: `http`, `server`, `location`\n\nSets the maximum supported video metadata size (for MP4 - moov atom size)\n\n#### vod_max_frames_size\n* **syntax**: `vod_max_frames_size size`\n* **default**: `16MB`\n* **context**: `http`, `server`, `location`\n\nSets the limit on the total size of the frames of a single segment\n\n#### vod_max_frame_count\n* **syntax**: `vod_max_frame_count count`\n* **default**: `1048576`\n* **context**: `http`, `server`, `location`\n\nSets the limit on the total count of the frames read to serve non segment (e.g. playlist) request.\n\n#### vod_segment_max_frame_count\n* **syntax**: `vod_segment_max_frame_count count`\n* **default**: `65536`\n* **context**: `http`, `server`, `location`\n\nSets the limit on the total count of the frames read to serve segment request.\n\n#### vod_cache_buffer_size\n* **syntax**: `vod_cache_buffer_size size`\n* **default**: `256K`\n* **context**: `http`, `server`, `location`\n\nSets the size of the cache buffers used when reading MP4 frames.\n\n#### vod_open_file_thread_pool\n* **syntax**: `vod_open_file_thread_pool pool_name`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nEnables the use of asynchronous file open via thread pool.\nThe thread pool must be defined with a thread_pool directive, if no pool name is specified the default pool is used.\nThis directive is supported only on nginx 1.7.11 or newer when compiling with --add-threads.\nNote: this directive currently disables the use of nginx's open_file_cache by nginx-vod-module\n\n#### vod_output_buffer_pool\n* **syntax**: `vod_output_buffer_pool size count`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nPre-allocates buffers for generating response data, saving the need allocate/free the buffers on every request.\n\n#### vod_performance_counters\n* **syntax**: `vod_performance_counters zone_name`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the shared memory object name of the performance counters\n\n### Configuration directives - url structure\n\n#### vod_base_url\n* **syntax**: `vod_base_url url`\n* **default**: `see below`\n* **context**: `http`, `server`, `location`\n\nSets the base URL (scheme + domain) that should be returned in manifest responses.\nThe parameter value can contain variables, if the parameter evaluates to an empty string, relative URLs will be used.\nIf the parameter evaluates to a string ending with /, it is assumed to be a full URL - the module only appends the\nfile name to it, instead of a full URI.\nIf not set, the base URL is determined as follows:\n1. If the request did not contain a host header (HTTP/1.0) relative URLs will be returned\n2. Otherwise, the base URL will be `$scheme://$http_host`\nThe setting currently affects only HLS and DASH. In MSS and HDS, relative URLs are always returned.\n\n#### vod_segments_base_url\n* **syntax**: `vod_segments_base_url url`\n* **default**: `see below`\n* **context**: `http`, `server`, `location`\n\nSets the base URL (scheme + domain) that should be used for delivering video segments.\nThe parameter value can contain variables, if the parameter evaluates to an empty string, relative URLs will be used.\nIf not set, vod_base_url will be used.\nThe setting currently affects only HLS.\n\n#### vod_multi_uri_suffix\n* **syntax**: `vod_multi_uri_suffix suffix`\n* **default**: `.urlset`\n* **context**: `http`, `server`, `location`\n\nA URL suffix that is used to identify multi URLs. A multi URL is a way to encode several different URLs\nthat should be played together as an adaptive streaming set, under a single URL. When the default suffix is\nused, an HLS set URL may look like: \nhttp://host/hls/common-prefix,bitrate1,bitrate2,common-suffix.urlset/master.m3u8\n\n#### vod_clip_to_param_name\n* **syntax**: `vod_clip_to_param_name name`\n* **default**: `clipTo`\n* **context**: `http`, `server`, `location`\n\nThe name of the clip to request parameter.\n\n#### vod_clip_from_param_name\n* **syntax**: `vod_clip_from_param_name name`\n* **default**: `clipFrom`\n* **context**: `http`, `server`, `location`\n\nThe name of the clip from request parameter.\n\n#### vod_tracks_param_name\n* **syntax**: `vod_tracks_param_name name`\n* **default**: `tracks`\n* **context**: `http`, `server`, `location`\n\nThe name of the tracks request parameter.\n\n#### vod_time_shift_param_name\n* **syntax**: `vod_time_shift_param_name name`\n* **default**: `shift`\n* **context**: `http`, `server`, `location`\n\nThe name of the shift request parameter.\n\n#### vod_speed_param_name\n* **syntax**: `vod_speed_param_name name`\n* **default**: `speed`\n* **context**: `http`, `server`, `location`\n\nThe name of the speed request parameter.\n\n#### vod_lang_param_name\n* **syntax**: `vod_lang_param_name name`\n* **default**: `lang`\n* **context**: `http`, `server`, `location`\n\nThe name of the language request parameter.\n\n#### vod_force_sequence_index\n* **syntax**: `vod_force_sequence_index on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nUse sequence index in segment uris even if there is only one sequence\n\n### Configuration directives - response headers\n\n#### vod_expires\n* **syntax**: `vod_expires time`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the value of the \"Expires\" and \"Cache-Control\" response headers for successful requests.\nThis directive is similar to nginx's built-in `expires` directive, except that it only supports the expiration interval scenario\n(epoch, max, off, day time are not supported)\nMain motivation for using this directive instead of the built-in `expires` is to have different expiration for VOD and dynamic live content.\nIf this directive is not specified, nginx-vod-module will not set the \"Expires\" / \"Cache-Control\" headers.\nThis setting affects all types of requests in VOD playlists and segment requests in live playlists.\n\n#### vod_expires_live\n* **syntax**: `vod_expires_live time`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSame as `vod_expires` (above) for live requests that are not time dependent and not segments (e.g. HLS - master.m3u8, HDS - manifest.f4m).\n\n#### vod_expires_live_time_dependent\n* **syntax**: `vod_expires_live_time_dependent time`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSame as `vod_expires` (above) for live requests that are time dependent (HLS - index.m3u8, HDS - bootstrap.abst, MSS - manifest, DASH - manifest.mpd).\n\n#### vod_last_modified\n* **syntax**: `vod_last_modified time`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the value of the Last-Modified header returned on the response, by default the module does not return a Last-Modified header.\nThe reason for having this parameter here is in order to support If-Modified-Since / If-Unmodified-Since.\nSince nginx's builtin ngx_http_not_modified_filter_module runs before any other header filter module, it will not see any headers set by add_headers / more_set_headers.\nThis makes nginx always reply as if the content changed (412 for If-Unmodified-Since / 200 for If-Modified-Since)\nFor live requests that are not segments (e.g. live DASH MPD), Last-Modified is set to the current server time.\n\n#### vod_last_modified_types\n* **syntax**: `vod_last_modified_types mime-type1 mime-type2 ...`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the MIME types for which the Last-Modified header should be set.\nThe special value \"*\" matches any MIME type.\n\n### Configuration directives - ad stitching (mapped mode only)\n\n#### vod_dynamic_mapping_cache\n* **syntax**: `vod_dynamic_mapping_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the cache that stores the mapping of dynamic clips.\n\n#### vod_dynamic_clip_map_uri\n* **syntax**: `vod_dynamic_clip_map_uri uri`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the uri that should be used to map dynamic clips. \nThe parameter value can contain variables, specifically, `$vod_clip_id` contains the id of the clip that should be mapped.\nThe expected response from this uri is a JSON containing a concat clip object.\n\n#### vod_source_clip_map_uri\n* **syntax**: `vod_source_clip_map_uri uri`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the uri that should be used to map source clips defined using the clipIds property of concat. \nThe parameter value can contain variables, specifically, `$vod_clip_id` contains the id of the clip that should be mapped.\nThe expected response from this uri is a JSON containing a source clip object.\n\n#### vod_redirect_segments_url\n* **syntax**: `vod_redirect_segments_url url`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets a url to which requests for segments should be redirected.\nThe parameter value can contain variables, specifically, `$vod_dynamic_mapping` contains a serialized representation of the mapping of dynamic clips.\n\n#### vod_apply_dynamic_mapping\n* **syntax**: `vod_apply_dynamic_mapping mapping`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nMaps dynamic clips to concat clips using the given expression, previously generated by `$vod_dynamic_mapping`.\nThe parameter value can contain variables.\n\n#### vod_notification_uri\n* **syntax**: `vod_notification_uri uri`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the uri that should be used to issue notifications. \nThe parameter value can contain variables, specifically, `$vod_notification_id` contains the id of the notification that is being fired.\nThe response from this uri is ignored.\n\n### Configuration directives - DRM / encryption\n\n#### vod_secret_key\n* **syntax**: `vod_secret_key string`\n* **default**: `empty`\n* **context**: `http`, `server`, `location`\n\nSets the seed that is used to generate the TS encryption key and DASH/MSS encryption IVs.\nThe parameter value can contain variables, and will usually have the structure \"secret-$vod_filepath\".\nSee the list of nginx variables added by this module below.\n\n#### vod_encryption_iv_seed\n* **syntax**: `vod_encryption_iv_seed string`\n* **default**: `empty`\n* **context**: `http`, `server`, `location`\n\nSets the seed that is used to generate the encryption IV, currently applies only to HLS/fMP4 with AES-128 encryption.\nThe parameter value can contain variables.\n\n#### vod_drm_enabled\n* **syntax**: `vod_drm_enabled on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module encrypts the media segments according to the response it gets from the drm upstream.\nCurrently supported only for dash and mss (play ready).\n\n#### vod_drm_single_key\n* **syntax**: `vod_drm_single_key on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module requests the drm info only for the first sequence and applies it to all sequences.\nWhen disabled, the drm info is requested for each sequence separately.\nIn addition, in DASH, enabling this setting makes the module place the ContentProtection tag under AdaptationSet,\notherwise, it is placed under Representation.\n\n#### vod_drm_clear_lead_segment_count\n* **syntax**: `vod_drm_clear_lead_segment_count count`\n* **default**: `1`\n* **context**: `http`, `server`, `location`\n\nSets the number of clear (unencrypted) segments in the beginning of the stream. A clear lead enables the player to start playing without having to wait for the license response.\n\n#### vod_drm_max_info_length\n* **syntax**: `vod_drm_max_info_length length`\n* **default**: `4K`\n* **context**: `http`, `server`, `location`\n\nSets the maximum length of a drm info returned from upstream.\n\n#### vod_drm_upstream_location\n* **syntax**: `vod_drm_upstream_location location`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the nginx location that should be used for getting the DRM info for the file.\n\n#### vod_drm_info_cache\n* **syntax**: `vod_drm_info_cache zone_name zone_size [expiration]`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nConfigures the size and shared memory object name of the drm info cache.\n\n#### vod_drm_request_uri\n* **syntax**: `vod_drm_request_uri uri`\n* **default**: `$vod_suburi`\n* **context**: `http`, `server`, `location`\n\nSets the uri of drm info requests, the parameter value can contain variables.\nIn case of multi url, `$vod_suburi` will be the current sub uri (a separate drm info request is issued per sub URL)\n\n#### vod_min_single_nalu_per_frame_segment\n* **syntax**: `vod_min_single_nalu_per_frame_segment index`\n* **default**: `0`\n* **context**: `http`, `server`, `location`\n\nSets the minimum segment index (1-based) that should be assumed to have a single h264 nalu per frame.\nIf the value is 0, no assumption is being made on the number of nal units per frame.\nThis setting only affects DASH and MSS configurations that have DRM enabled.\n\nWhen transcoding videos using libx264, by default, all frames have a single nal unit, except the first frame\nthat contains an additional nalu with the libx264 copyright information. Setting this parameter to a value\ngreater than 0 can provide a significant performance improvement, since the layout of the segment can be\ncalculated in advance, allowing the module to:\n* Output segment buffers as they are generated (it doesn't have to wait for the whole segment to complete)\n* Avoid frame processing for requests that do not need the segment data (e.g. HEAD, range 0-0, etc.)\n\n### Configuration directives - DASH\n\n#### vod_dash_absolute_manifest_urls\n* **syntax**: `vod_dash_absolute_manifest_urls on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns absolute URLs in MPD requests\n\n#### vod_dash_manifest_file_name_prefix\n* **syntax**: `vod_dash_manifest_file_name_prefix name`\n* **default**: `manifest`\n* **context**: `http`, `server`, `location`\n\nThe name of the MPD file (an mpd extension is implied).\n\n#### vod_dash_profiles\n* **syntax**: `vod_dash_profiles profiles`\n* **default**: `urn:mpeg:dash:profile:isoff-main:2011`\n* **context**: `http`, `server`, `location`\n\nSets the profiles that are returned in the MPD tag in manifest responses.\n\n#### vod_dash_init_file_name_prefix\n* **syntax**: `vod_dash_init_file_name_prefix name`\n* **default**: `init`\n* **context**: `http`, `server`, `location`\n\nThe name of the MP4 initialization file (an mp4 extension is implied).\n\n#### vod_dash_fragment_file_name_prefix\n* **syntax**: `vod_dash_fragment_file_name_prefix name`\n* **default**: `frag`\n* **context**: `http`, `server`, `location`\n\nThe name of the fragment files (an m4s extension is implied).\n\n#### vod_dash_manifest_format\n* **syntax**: `vod_dash_manifest_format format`\n* **default**: `segmenttimeline`\n* **context**: `http`, `server`, `location`\n\nSets the MPD format, available options are:\n* `segmentlist` - uses SegmentList and SegmentURL tags, in this format the URL of each fragment is explicitly set in the MPD\n* `segmenttemplate` - uses SegmentTemplate, reporting a single duration for all fragments\n* `segmenttimeline` - uses SegmentTemplate and SegmentTimeline to explicitly set the duration of the fragments\n\n#### vod_dash_subtitle_format\n* **syntax**: `vod_dash_subtitle_format format`\n* **default**: `webvtt`\n* **context**: `http`, `server`, `location`\n\nSets the format of the subtitles returned in the MPD, available options are:\n* `webvtt` - WebVTT\n* `smpte-tt` - SMPTE Timed Text\n\n#### vod_dash_init_mp4_pssh\n* **syntax**: `vod_dash_init_mp4_pssh on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the DRM pssh boxes are returned in the DASH init segment and in the manifest.\nWhen disabled, the pssh boxes are returned only in the manifest.\n\n#### vod_dash_duplicate_bitrate_threshold\n* **syntax**: `vod_dash_duplicate_bitrate_threshold threshold`\n* **default**: `4096`\n* **context**: `http`, `server`, `location`\n\nThe bitrate threshold for removing identical bitrates, streams whose bitrate differences are less than\nthis value will be considered identical.\n\n#### vod_dash_use_base_url_tag\n* **syntax**: `vod_dash_use_base_url_tag on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, a BaseURL tag will be used to specify the fragments/init segment base url.\nOtherwise, the media/initialization attributes under SegmentTemplate will contain absolute URLs. \n\n### Configuration directives - HDS\n\n#### vod_hds_absolute_manifest_urls\n* **syntax**: `vod_hds_absolute_manifest_urls on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns the base URL in the F4M manifest\n\n#### vod_hds_manifest_file_name_prefix\n* **syntax**: `vod_hds_manifest_file_name_prefix name`\n* **default**: `manifest`\n* **context**: `http`, `server`, `location`\n\nThe name of the HDS manifest file (an f4m extension is implied).\n\n#### vod_hds_fragment_file_name_prefix\n* **syntax**: `vod_hds_fragment_file_name_prefix name`\n* **default**: `frag`\n* **context**: `http`, `server`, `location`\n\nThe prefix of fragment file names, the actual file name is `frag-f<file-index>-v<video-track-index>-a<audio-track-index>-Seg1-Frag<index>`.\n\n#### vod_hds_generate_moof_atom\n* **syntax**: `vod_hds_generate_moof_atom on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the module generates a moof atom in the HDS fragments, when disabled only an mdat atom is generated.\nTurning this parameter off reduces the packaging overhead, however the default is on since Adobe tools are generating this atom.\n\n### Configuration directives - HLS\n\n#### vod_hls_encryption_method\n* **syntax**: `vod_hls_encryption_method method`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the encryption method of HLS segments, allowed values are: none (default), aes-128, sample-aes, sample-aes-cenc.\n\n#### vod_hls_force_unmuxed_segments\n* **syntax**: `vod_hls_force_unmuxed_segments on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns the audio stream in separate segments than the ones used by the video stream (using EXT-X-MEDIA)\n\n#### vod_hls_container_format\n* **syntax**: `vod_hls_container_format mpegts/fmp4/auto`\n* **default**: `auto`\n* **context**: `http`, `server`, `location`\n\nSets the container format of the HLS segments. \nThe default behavior is to use fmp4 for HEVC, and mpegts otherwise (Apple does not support HEVC over MPEG TS).\n\n#### vod_hls_absolute_master_urls\n* **syntax**: `vod_hls_absolute_master_urls on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns absolute playlist URLs in master playlist requests\n\n#### vod_hls_absolute_index_urls\n* **syntax**: `vod_hls_absolute_index_urls on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns absolute segment URLs in media playlist requests\n\n#### vod_hls_absolute_iframe_urls\n* **syntax**: `vod_hls_absolute_iframe_urls on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled the server returns absolute segment URLs in iframe playlist requests\n\n#### vod_hls_output_iframes_playlist\n* **syntax**: `vod_hls_output_iframes_playlist on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen disabled iframe playlists are not returned as part of master playlists\n\n#### vod_hls_master_file_name_prefix\n* **syntax**: `vod_hls_master_file_name_prefix name`\n* **default**: `master`\n* **context**: `http`, `server`, `location`\n\nThe name of the HLS master playlist file (an m3u8 extension is implied).\n\n#### vod_hls_index_file_name_prefix\n* **syntax**: `vod_hls_index_file_name_prefix name`\n* **default**: `index`\n* **context**: `http`, `server`, `location`\n\nThe name of the HLS media playlist file (an m3u8 extension is implied).\n\n#### vod_hls_iframes_file_name_prefix\n* **syntax**: `vod_hls_iframes_file_name_prefix name`\n* **default**: `iframes`\n* **context**: `http`, `server`, `location`\n\nThe name of the HLS I-frames playlist file (an m3u8 extension is implied).\n\n#### vod_hls_segment_file_name_prefix\n* **syntax**: `vod_hls_segment_file_name_prefix name`\n* **default**: `seg`\n* **context**: `http`, `server`, `location`\n\nThe prefix of segment file names, the actual file name is `seg-<index>-v<video-track-index>-a<audio-track-index>.ts`.\n\n#### vod_hls_init_file_name_prefix\n* **syntax**: `vod_hls_init_file_name_prefix name`\n* **default**: `init`\n* **context**: `http`, `server`, `location`\n\nThe name of the init segment file name, only relevant when using fmp4 container.\n\n#### vod_hls_encryption_key_file_name\n* **syntax**: `vod_hls_encryption_key_file_name name`\n* **default**: `encryption.key`\n* **context**: `http`, `server`, `location`\n\nThe name of the encryption key file name, only relevant when encryption method is not `none`.\n\n#### vod_hls_encryption_key_uri\n* **syntax**: `vod_hls_encryption_key_uri uri`\n* **default**: `a url pointing to encryption.key`\n* **context**: `http`, `server`, `location`\n\nSets the value of the URI attribute of EXT-X-KEY, only relevant when encryption method is not `none`.\nThe parameter value can contain variables.\n\n#### vod_hls_encryption_key_format\n* **syntax**: `vod_hls_encryption_key_format format`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the value of the KEYFORMAT attribute of EXT-X-KEY, only relevant when encryption method is not `none`.\n\n#### vod_hls_encryption_key_format_versions\n* **syntax**: `vod_hls_encryption_key_format_versions versions`\n* **default**: `none`\n* **context**: `http`, `server`, `location`\n\nSets the value of the KEYFORMATVERSIONS attribute of EXT-X-KEY, only relevant when encryption method is not `none`.\n\n#### vod_hls_mpegts_interleave_frames\n* **syntax**: `vod_hls_mpegts_interleave_frames on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the HLS muxer interleaves frames of different streams (audio / video).\nWhen disabled, on every switch between audio / video the muxer flushes the MPEG TS packet.\n\n#### vod_hls_mpegts_align_frames\n* **syntax**: `vod_hls_mpegts_align_frames on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, every video / audio frame is aligned to MPEG TS packet boundary,\npadding is added as needed.\n\n#### vod_hls_mpegts_output_id3_timestamps\n* **syntax**: `vod_hls_mpegts_output_id3_timestamps on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, an ID3 TEXT frame is outputted in each TS segment.\nThe content of the ID3 TEXT frame can be set using the directive `vod_hls_mpegts_id3_data`.\n\n#### vod_hls_mpegts_id3_data\n* **syntax**: `vod_hls_mpegts_id3_data string`\n* **default**: `{\"timestamp\":$vod_segment_time,\"sequenceId\":\"$vod_sequence_id\"}`\n* **context**: `http`, `server`, `location`\n\nSets the data of the ID3 TEXT frame outputted in each TS segment, when `vod_hls_mpegts_output_id3_timestamps` is set to `on`.\nWhen the directive is not set, the ID3 frames contain by default a JSON object of the format `{\"timestamp\":1459779115000,\"sequenceId\":\"{id}\"}`:\n- `timestamp` - an absolute time measured in milliseconds since the epoch (unixtime x 1000).\n- `sequenceId` - the id field of the sequence object, as specified in the mapping JSON. The field is omitted when the sequence id is empty / not specified in the mapping JSON.\nThe parameter value can contain variables.\n\n#### vod_hls_mpegts_align_pts\n* **syntax**: `vod_hls_mpegts_align_pts on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module will shift back the dts timestamps by the pts delay of the initial frame.\nThis can help keep the pts timestamps aligned across multiple renditions.\n\n#### vod_hls_encryption_output_iv\n* **syntax**: `vod_hls_encryption_output_iv on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module outputs the `IV` attribute in returned `#EXT-X-KEY` tags.\n\n### Configuration directives - MSS\n\n#### vod_mss_manifest_file_name_prefix\n* **syntax**: `vod_mss_manifest_file_name_prefix name`\n* **default**: `manifest`\n* **context**: `http`, `server`, `location`\n\nThe name of the manifest file (has no extension).\n\n#### vod_mss_duplicate_bitrate_threshold\n* **syntax**: `vod_mss_duplicate_bitrate_threshold threshold`\n* **default**: `4096`\n* **context**: `http`, `server`, `location`\n\nThe bitrate threshold for removing identical bitrates, streams whose bitrate differences are less than\nthis value will be considered identical.\n\n### Configuration directives - thumbnail capture\n\n#### vod_thumb_file_name_prefix\n* **syntax**: `vod_thumb_file_name_prefix name`\n* **default**: `thumb`\n* **context**: `http`, `server`, `location`\n\nThe name of the thumbnail file (a jpg extension is implied).\n\n#### vod_thumb_accurate_positioning\n* **syntax**: `vod_thumb_accurate_positioning on/off`\n* **default**: `on`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module grabs the frame that is closest to the requested offset.\nWhen disabled, the module uses the keyframe that is closest to the requested offset.\nSetting this parameter to off can result in faster thumbnail capture, since the module \nalways decodes a single video frame per request.\n\n#### vod_gop_look_behind\n* **syntax**: `vod_gop_look_behind millis`\n* **default**: `10000`\n* **context**: `http`, `server`, `location`\n\nSets the interval (in milliseconds) before the thumbnail offset that should be loaded.\nThis setting should be set to the maximum GOP size, setting it to a lower value may result in capture failure.\nNote that the metadata of all frames between `offset - vod_gop_look_behind` and `offset + vod_gop_look_ahead`\nis loaded, however only the frames of the minimum GOP containing `offset` will be read and decoded.\n\n#### vod_gop_look_ahead\n* **syntax**: `vod_gop_look_ahead millis`\n* **default**: `1000`\n* **context**: `http`, `server`, `location`\n\nSets the interval (in milliseconds) after the thumbnail offset that should be loaded.\n\n### Configuration directives - volume map\n\n#### vod_volume_map_file_name_prefix\n* **syntax**: `vod_volume_map_file_name_prefix name`\n* **default**: `volume_map`\n* **context**: `http`, `server`, `location`\n\nThe name of the volume map file (a csv extension is implied).\n\n#### vod_volume_map_interval\n* **syntax**: `vod_volume_map_interval millis`\n* **default**: `1000`\n* **context**: `http`, `server`, `location`\n\nSets the interval/resolution (in milliseconds) of the volume map.\n\n### Configuration directives - misc\n\n#### vod_ignore_edit_list\n* **syntax**: `vod_ignore_edit_list on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module ignores any edit lists (elst) in the MP4 file.\n\n#### vod_parse_hdlr_name\n* **syntax**: `vod_parse_hdlr_name on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module parses the name field of the hdlr MP4 atom, and uses it as the stream label.\n\n#### vod_parse_udta_name\n* **syntax**: `vod_parse_udta_name on/off`\n* **default**: `off`\n* **context**: `http`, `server`, `location`\n\nWhen enabled, the module parses the name atom child of the udta MP4 atom, and uses it as the stream label.\n\n### Nginx variables\n\nThe module adds the following nginx variables:\n* `$vod_suburi` - the current sub uri. For example, if the url is:\n  `http://<domain>/<location>/<prefix>,<middle1>,<middle2>,<middle3>,<postfix>.urlset/<filename>`\n  `$vod_suburi` will have the value `http://<domain>/<location>/<prefix><middle1><postfix>/<filename>` \n  when processing the first uri.\n* `$vod_filepath` - in local / mapped modes, the file path of current sub uri. In remote mode, has the same value as `$vod_suburi`.\n* `$vod_set_id` - contains the id of the set.\n* `$vod_sequence_id` - contains the id of the current sequence, if no id was specified in the mapping json this variable will be the same as `$vod_suburi`.\n* `$vod_clip_id` - the id of the current clip, this variable has a value during these phases:\n  1. Mapping of dynamic clips to concat clips\n  2. Mapping of source clip to paths\n* `$vod_notification_id` - the id of the current notification, the value is non-empty only when referenced by `vod_notification_uri`\n* `$vod_dynamic_mapping` - a serialized representation of the mapping of dynamic clips to concat clips.\n* `$vod_request_params` - a serialized representation of the request params, e.g. 12-f2-v1-a1. The variable contains:\n  1. The segment index (for a segment request)\n  2. The sequence index\n  3. A selection of audio/video tracks\n* `$vod_status` - the internal error code of the module, provides a more fine grained classification of errors than http status.\n\tthe following values are defined:\n\t`BAD_REQUEST` - the request is invalid, for example, `clipFrom` is larger than the video duration\n\t`NO_STREAMS` - an invalid segment index was requested\n\t`EMPTY_MAPPING` - the mapping response is empty\n\t`BAD_MAPPING` - the mapping json is invalid, for example, the `sequences` element is missing\n\t`BAD_DATA` - the video file is corrupt\n\t`EXPIRED` - the current server time is larger than `expirationTime`\n\t`ALLOC_FAILED` - the module failed to allocate memory\n\t`UNEXPECTED` - a scenario that is not supposed to happen, most likely a bug in the module\n* `$vod_segment_time` - for segment requests, contains the absolute timestamp of the first frame in the segment, measured in milliseconds since the epoch (unixtime x 1000).\n* `$vod_segment_duration` - for segment requests, contains the duration of the segment in milliseconds\n* `$vod_frames_bytes_read` - for segment requests, total number of bytes read while processing media frames\n\nNote: Configuration directives that can accept variables are explicitly marked as such.\n\n### Sample configurations\n\n#### Local configuration\n```nginx\n\thttp {\n\t\tupstream fallback {\n\t\t\tserver fallback.kaltura.com:80;\n\t\t}\n\n\t\tserver {\n\t\t\t# vod settings\n\t\t\tvod_mode local;\n\t\t\tvod_fallback_upstream_location /fallback;\n\t\t\tvod_last_modified 'Sun, 19 Nov 2000 08:52:00 GMT';\n\t\t\tvod_last_modified_types *;\n\n\t\t\t# vod caches\n\t\t\tvod_metadata_cache metadata_cache 512m;\n\t\t\tvod_response_cache response_cache 128m;\n\t\t\t\n\t\t\t# gzip manifests\n\t\t\tgzip on;\n\t\t\tgzip_types application/vnd.apple.mpegurl;\n\n\t\t\t# file handle caching / aio\n\t\t\topen_file_cache          max=1000 inactive=5m;\n\t\t\topen_file_cache_valid    2m;\n\t\t\topen_file_cache_min_uses 1;\n\t\t\topen_file_cache_errors   on;\n\t\t\taio on;\n\t\t\t\n\t\t\tlocation ^~ /fallback/ {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass http://fallback/;\n\t\t\t\tproxy_set_header Host $http_host;\n\t\t\t}\n\n\t\t\tlocation /content/ {\n\t\t\t\troot /web/;\n\t\t\t\tvod hls;\n\t\t\t\t\n\t\t\t\tadd_header Access-Control-Allow-Headers '*';\n\t\t\t\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\t\t\t\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\t\t\t\tadd_header Access-Control-Allow-Origin '*';\n\t\t\t\texpires 100d;\n\t\t\t}\n\t\t}\n\t}\n```\n\n#### Mapped configuration\n```nginx\n\thttp {\n\t\tupstream kalapi {\n\t\t\tserver www.kaltura.com:80;\n\t\t}\n\n\t\tupstream fallback {\n\t\t\tserver fallback.kaltura.com:80;\n\t\t}\n\n\t\tserver {\n\t\t\t# vod settings\n\t\t\tvod_mode mapped;\n\t\t\tvod_upstream_location /kalapi;\n\t\t\tvod_upstream_extra_args \"pathOnly=1\";\n\t\t\tvod_fallback_upstream_location /fallback;\n\t\t\tvod_last_modified 'Sun, 19 Nov 2000 08:52:00 GMT';\n\t\t\tvod_last_modified_types *;\n\n\t\t\t# vod caches\n\t\t\tvod_metadata_cache metadata_cache 512m;\n\t\t\tvod_response_cache response_cache 128m;\n\t\t\tvod_mapping_cache mapping_cache 5m;\n\t\t\t\n\t\t\t# gzip manifests\n\t\t\tgzip on;\n\t\t\tgzip_types application/vnd.apple.mpegurl;\n\n\t\t\t# file handle caching / aio\n\t\t\topen_file_cache          max=1000 inactive=5m;\n\t\t\topen_file_cache_valid    2m;\n\t\t\topen_file_cache_min_uses 1;\n\t\t\topen_file_cache_errors   on;\n\t\t\taio on;\n\t\t\t\n\t\t\tlocation ^~ /fallback/ {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass http://fallback/;\n\t\t\t\tproxy_set_header Host $http_host;\n\t\t\t}\n\n\t\t\tlocation ^~ /kalapi/ {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass http://kalapi/;\n\t\t\t\tproxy_set_header Host $http_host;\n\t\t\t}\n\n\t\t\tlocation ~ ^/p/\\d+/(sp/\\d+/)?serveFlavor/ {\n\t\t\t\t# encrypted hls\n\t\t\t\tvod hls;\n\t\t\t\tvod_secret_key \"mukkaukk$vod_filepath\";\n\t\t\t\tvod_hls_encryption_method aes-128;\n\t\t\t\t\n\t\t\t\tadd_header Access-Control-Allow-Headers '*';\n\t\t\t\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\t\t\t\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\t\t\t\tadd_header Access-Control-Allow-Origin '*';\n\t\t\t\texpires 100d;\n\t\t\t}\n\t\t}\n\t}\n```\n\n#### Mapped + Remote configuration\n```nginx\n\thttp {\n\t\tupstream jsonupstream {\n\t\t\tserver jsonserver:80;\n\t\t}\n\n\t\tserver {\n\t\t\t# vod settings\n\t\t\tvod_mode mapped;\n\t\t\tvod_upstream_location /json;\n\t\t\tvod_remote_upstream_location /proxy;\n\t\t\tvod_upstream_extra_args \"pathOnly=1\";\n\t\t\tvod_last_modified 'Sun, 19 Nov 2000 08:52:00 GMT';\n\t\t\tvod_last_modified_types *;\n\n\t\t\t# vod caches\n\t\t\tvod_metadata_cache metadata_cache 512m;\n\t\t\tvod_response_cache response_cache 128m;\n\t\t\tvod_mapping_cache mapping_cache 5m;\n\n\t\t\t# gzip manifests\n\t\t\tgzip on;\n\t\t\tgzip_types application/vnd.apple.mpegurl;\n\n\t\t\t# file handle caching / aio\n\t\t\topen_file_cache\t  max=1000 inactive=5m;\n\t\t\topen_file_cache_valid    2m;\n\t\t\topen_file_cache_min_uses 1;\n\t\t\topen_file_cache_errors   on;\n\t\t\taio on;\n\n\t\t\tlocation ^~ /json/hls/ {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass http://jsonupstream/;\n\t\t\t\tproxy_set_header Host $http_host;\n\t\t\t}\n\n\t\t\tlocation ~ /proxy/([^/]+)/(.*) {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass $1://$2;\n\t\t\t\tresolver 8.8.8.8;\n\t\t\t}\n\n\t\t\tlocation ~ ^/hls/ {\n\t\t\t\tvod hls;\n\n\t\t\t\tadd_header Access-Control-Allow-Headers '*';\n\t\t\t\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\t\t\t\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\t\t\t\tadd_header Access-Control-Allow-Origin '*';\n\t\t\t\texpires 100d;\n\t\t\t}\n\t\t}\n\t}\n```\n\nSet it up so that http://jsonserver:80/test.json returns the following JSON:\n```json\n\t{\n\t\t\"sequences\": [{\n\t\t\t\"clips\": [{\n\t\t\t\t\"type\": \"source\",\n\t\t\t\t\"path\": \"/http/commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n\t\t\t}]\n\t\t}]\n\t}\n```\n\nAnd use this stream URL - http://nginx-vod-server/hls/test.json/master.m3u8\n\n#### Remote configuration\n```nginx\n\thttp {\n\t\tupstream kalapi {\n\t\t\tserver www.kaltura.com:80;\n\t\t}\n\n\t\tserver {\n\t\t\t# vod settings\n\t\t\tvod_mode remote;\n\t\t\tvod_upstream_location /kalapi;\n\t\t\tvod_last_modified 'Sun, 19 Nov 2000 08:52:00 GMT';\n\t\t\tvod_last_modified_types *;\n\n\t\t\t# vod caches\n\t\t\tvod_metadata_cache metadata_cache 512m;\n\t\t\tvod_response_cache response_cache 128m;\n\t\t\t\n\t\t\t# gzip manifests\n\t\t\tgzip on;\n\t\t\tgzip_types application/vnd.apple.mpegurl;\n\t\t\t\n\t\t\tlocation ^~ /kalapi/ {\n\t\t\t\tinternal;\n\t\t\t\tproxy_pass http://kalapi/;\n\t\t\t\tproxy_set_header Host $http_host;\n\t\t\t}\n\n\t\t\tlocation ~ ^/p/\\d+/(sp/\\d+/)?serveFlavor/ {\n\t\t\t\tvod hls;\n\t\t\t\t\n\t\t\t\tadd_header Access-Control-Allow-Headers '*';\n\t\t\t\tadd_header Access-Control-Expose-Headers 'Server,range,Content-Length,Content-Range';\n\t\t\t\tadd_header Access-Control-Allow-Methods 'GET, HEAD, OPTIONS';\n\t\t\t\tadd_header Access-Control-Allow-Origin '*';\n\t\t\t\texpires 100d;\n\t\t\t}\n\t\t}\n\t}\n```\n### Copyright & License\n\nAll code in this project is released under the [AGPLv3 license](http://www.gnu.org/licenses/agpl-3.0.html) unless a different license for a particular library is specified in the applicable library path. \n\nCopyright © Kaltura Inc. All rights reserved.\n"
        },
        {
          "name": "ci_build.sh",
          "type": "blob",
          "size": 2.2373046875,
          "content": "#!/bin/sh\nset -eo nounset                              # Treat unset variables as an error\n\nBASE_DOWNLOAD_URI=http://nginx.org/download\nNGINX_VERSION=`curl -L \"$BASE_DOWNLOAD_URI\" |\n   grep -oP 'href=\"nginx-\\K[0-9]+\\.[0-9]+\\.[0-9]+' |\n   sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1`\nNGINX_URI=\"$BASE_DOWNLOAD_URI/nginx-$NGINX_VERSION.tar.gz\"\n\nif [ ! -x \"`which curl 2>/dev/null`\" ];then\n        echo \"Need to install curl.\"\n        exit 2\nfi\n\nmkdir -p /tmp/builddir/nginx-$NGINX_VERSION\ncp -r . /tmp/builddir/nginx-$NGINX_VERSION/nginx-vod-module\ncd /tmp/builddir\ncurl $NGINX_URI > kaltura-nginx-$NGINX_VERSION.tar.gz\ntar zxf kaltura-nginx-$NGINX_VERSION.tar.gz\nmv nginx-$NGINX_VERSION nginx\ncd nginx\n\nFFMPEG_VERSION=4.2.2\nLD_LIBRARY_PATH=/opt/kaltura/ffmpeg-$FFMPEG_VERSION/lib\nLIBRARY_PATH=/opt/kaltura/ffmpeg-$FFMPEG_VERSION/lib\nC_INCLUDE_PATH=/opt/kaltura/ffmpeg-$FFMPEG_VERSION/include\nexport LD_LIBRARY_PATH LIBRARY_PATH C_INCLUDE_PATH\n\n./configure \\\n        --prefix=/etc/nginx \\\n        --sbin-path=/sbin/nginx \\\n        --conf-path=/etc/nginx/nginx.conf \\\n        --error-log-path=/var/log/log/nginx/error.log \\\n        --http-log-path=/var/log/log/nginx/access.log \\\n        --pid-path=/var/log/run/nginx.pid \\\n        --lock-path=/var/log/run/nginx.lock \\\n        --http-client-body-temp-path=/var/log/cache/nginx/client_temp \\\n        --http-proxy-temp-path=/var/log/cache/nginx/proxy_temp \\\n        --http-fastcgi-temp-path=/var/log/cache/nginx/fastcgi_temp \\\n        --http-uwsgi-temp-path=/var/log/cache/nginx/uwsgi_temp \\\n        --http-scgi-temp-path=/var/log/cache/nginx/scgi_temp \\\n        --with-http_ssl_module \\\n        --with-http_realip_module \\\n        --with-http_addition_module \\\n        --with-http_sub_module \\\n        --with-http_dav_module \\\n        --with-http_flv_module \\\n        --with-http_mp4_module \\\n        --with-http_gunzip_module \\\n        --with-http_gzip_static_module \\\n        --with-http_random_index_module \\\n        --with-http_secure_link_module \\\n        --with-http_stub_status_module \\\n        --with-http_auth_request_module \\\n        --with-mail \\\n        --with-mail_ssl_module \\\n        --with-file-aio \\\n        --with-ipv6 \\\n        --with-debug \\\n        --with-threads \\\n\t--with-cc-opt=\"-O3 -mpopcnt\" \\\n        $*\nmake -j $(nproc)\n"
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "blob",
          "size": 19.0048828125,
          "content": "ngx_addon_name=ngx_http_vod_module\nngx_module_incs=\nngx_module_libs=\nVOD_SRCS=\nVOD_DEPS=\n\n# version\n#\nVOD_DEFAULT_VERSION=1.11\nVOD_VERSION=${VOD_VERSION:-`git --git-dir=$ngx_addon_dir/.git describe 2>/dev/null`}\nVOD_VERSION=${VOD_VERSION:-$VOD_DEFAULT_VERSION}\necho \"#define NGINX_VOD_VERSION \\\"\"$VOD_VERSION\"\\\"\" > $NGX_OBJS/ngx_vod_version.h\n\n# taken from echo-nginx-module\n# nginx won't have HTTP_POSTPONE_FILTER_MODULE & HTTP_POSTPONE_FILTER_SRCS\n# defined since 1.9.11\nif test -z \"$HTTP_POSTPONE_FILTER_MODULE\"; then\n    HTTP_POSTPONE_FILTER_MODULE=ngx_http_postpone_filter_module\n    HTTP_POSTPONE_FILTER_SRCS=src/http/ngx_http_postpone_filter_module.c\nfi\n\n# This module depends upon the postpone filter being activated\nif [ \"$HTTP_POSTPONE\" = NO ]; then\n    HTTP_FILTER_MODULES=\"$HTTP_FILTER_MODULES $HTTP_POSTPONE_FILTER_MODULE\"\n    HTTP_SRCS=\"$HTTP_SRCS $HTTP_POSTPONE_FILTER_SRCS\"\n    HTTP_POSTPONE=YES\nfi\n\n# zlib\n#\nif [ $ZLIB = NONE ]; then\n    ngx_feature=\"zlib library\"\n    ngx_feature_name=\"NGX_HAVE_ZLIB\"\n    ngx_feature_run=no\n    ngx_feature_incs=\"#include <zlib.h>\"\n    ngx_feature_path=\n    ngx_feature_libs=\"-lz\"\n    ngx_feature_test=\"z_stream z; deflate(&z, Z_NO_FLUSH)\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        ngx_module_libs=\"$ngx_module_libs $ngx_feature_libs\"\n    fi\nelse\n    cat << END >> $NGX_AUTO_CONFIG_H\n\n#ifndef NGX_HAVE_ZLIB\n#define NGX_HAVE_ZLIB  1\n#endif\n\nEND\nfi\n\n# openssl evp\n#\nVOD_FEATURE_SRCS=\"                                      \\\n    $ngx_addon_dir/vod/dash/edash_packager.c            \\\n    $ngx_addon_dir/vod/hls/aes_cbc_encrypt.c            \\\n    $ngx_addon_dir/vod/hls/eac3_encrypt_filter.c        \\\n    $ngx_addon_dir/vod/hls/frame_encrypt_filter.c       \\\n    $ngx_addon_dir/vod/hls/sample_aes_avc_filter.c      \\\n    $ngx_addon_dir/vod/mp4/mp4_aes_ctr.c                \\\n    $ngx_addon_dir/vod/mp4/mp4_cbcs_encrypt.c           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_decrypt.c           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_encrypt.c           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_passthrough.c       \\\n    $ngx_addon_dir/vod/mss/mss_playready.c              \\\n    \"\n\nVOD_FEATURE_DEPS=\"                                      \\\n    $ngx_addon_dir/vod/dash/edash_packager.h            \\\n    $ngx_addon_dir/vod/hls/aes_cbc_encrypt.h            \\\n    $ngx_addon_dir/vod/hls/eac3_encrypt_filter.h        \\\n    $ngx_addon_dir/vod/hls/frame_encrypt_filter.h       \\\n    $ngx_addon_dir/vod/hls/sample_aes_avc_filter.h      \\\n    $ngx_addon_dir/vod/mp4/mp4_aes_ctr.h                \\\n    $ngx_addon_dir/vod/mp4/mp4_cbcs_encrypt.h           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_decrypt.h           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_encrypt.h           \\\n    $ngx_addon_dir/vod/mp4/mp4_cenc_passthrough.h       \\\n    $ngx_addon_dir/vod/mss/mss_playready.h              \\\n    \"\n\nif [ $OPENSSL = NONE ]; then\n    LIB_CRYPTO=${LIB_CRYPTO:--lcrypto}\n    LIB_PTHREAD=${LIB_PTHREAD:--lpthread}\n\n    ngx_feature=\"OpenSSL EVP library\"\n    ngx_feature_name=\"NGX_HAVE_OPENSSL_EVP\"\n    ngx_feature_run=no\n    ngx_feature_incs=\"#include <openssl/evp.h>\"\n    ngx_feature_path=\n    ngx_feature_libs=\"$LIB_CRYPTO $NGX_LIBDL $LIB_PTHREAD\"\n    ngx_feature_test=\"EVP_CIPHER_CTX_new();\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        ngx_module_libs=\"$ngx_module_libs $ngx_feature_libs\"\n        VOD_SRCS=\"$VOD_SRCS $VOD_FEATURE_SRCS\"\n        VOD_DEPS=\"$VOD_DEPS $VOD_FEATURE_DEPS\"\n    fi\nelse\n    VOD_SRCS=\"$VOD_SRCS $VOD_FEATURE_SRCS\"\n    VOD_DEPS=\"$VOD_DEPS $VOD_FEATURE_DEPS\"\n    cat << END >> $NGX_AUTO_CONFIG_H\n\n#ifndef NGX_HAVE_OPENSSL_EVP\n#define NGX_HAVE_OPENSSL_EVP  1\n#endif\n\nEND\nfi\n\n# iconv\n#\nngx_feature=\"iconv\"\nngx_feature_name=\"NGX_HAVE_ICONV\"\nngx_feature_run=no\nngx_feature_incs=\"#include <iconv.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"iconv_open(NULL, NULL);\"\n. auto/feature\n\n# clock_gettime\n#\nngx_feature=\"clock_gettime()\"\nngx_feature_name=\"NGX_HAVE_CLOCK_GETTIME\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sched.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"clock_gettime()\"\n. auto/feature\n\nif [ $ngx_found != yes ]; then\n\n    ngx_feature=\"clock_gettime() in librt\"\n    ngx_feature_libs=\"-lrt\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        ngx_module_libs=\"$ngx_module_libs $ngx_feature_libs\"\n    fi\nfi\n\n# libavcodec\n#\nLIB_AV_UTIL=${LIB_AV_UTIL:--lavutil}\nLIB_AV_CODEC=${LIB_AV_CODEC:--lavcodec}\n\nngx_feature=\"libavcodec\"\nngx_feature_name=\"NGX_HAVE_LIB_AV_CODEC\"\nngx_feature_run=no\nngx_feature_incs=\"#include <libavcodec/avcodec.h>\"\nngx_feature_path=\nngx_feature_libs=\"$LIB_AV_CODEC\"\nngx_feature_test=\"avcodec_send_packet(NULL, NULL)\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    ngx_module_libs=\"$ngx_module_libs $LIB_AV_CODEC $LIB_AV_UTIL -lm\"\n    VOD_FEATURE_SRCS=\"                                      \\\n        $ngx_addon_dir/ngx_http_vod_thumb.c                 \\\n        $ngx_addon_dir/ngx_http_vod_volume_map.c            \\\n        $ngx_addon_dir/vod/filters/audio_decoder.c          \\\n        $ngx_addon_dir/vod/filters/audio_encoder.c          \\\n        $ngx_addon_dir/vod/filters/volume_map.c             \\\n        $ngx_addon_dir/vod/thumb/thumb_grabber.c            \\\n        \"\n\n    VOD_FEATURE_DEPS=\"                                      \\\n        $ngx_addon_dir/ngx_http_vod_thumb.h                 \\\n        $ngx_addon_dir/ngx_http_vod_thumb_commands.h        \\\n        $ngx_addon_dir/ngx_http_vod_thumb_conf.h            \\\n        $ngx_addon_dir/ngx_http_vod_volume_map.h            \\\n        $ngx_addon_dir/ngx_http_vod_volume_map_commands.h   \\\n        $ngx_addon_dir/ngx_http_vod_volume_map_conf.h       \\\n        $ngx_addon_dir/vod/filters/audio_decoder.h          \\\n        $ngx_addon_dir/vod/filters/audio_encoder.h          \\\n        $ngx_addon_dir/vod/filters/volume_map.h             \\\n        $ngx_addon_dir/vod/thumb/thumb_grabber.h            \\\n        \"\n\n    VOD_SRCS=\"$VOD_SRCS $VOD_FEATURE_SRCS\"\n    VOD_DEPS=\"$VOD_DEPS $VOD_FEATURE_DEPS\"\nfi\n\n# libswscale\n#\nngx_feature=\"libswscale\"\nngx_feature_name=\"NGX_HAVE_LIB_SW_SCALE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <libswscale/swscale.h>\"\nngx_feature_path=\nngx_feature_libs=\"-lswscale\"\nngx_feature_test=\"sws_scale(NULL, NULL, NULL, 0, 0, NULL, NULL)\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    ngx_module_libs=\"$ngx_module_libs -lswscale\"\nfi\n\n# libavfilter\n#\nLIB_AV_FILTER=${LIB_AV_FILTER:--lavfilter}\n\nngx_feature=\"libavfilter\"\nngx_feature_name=\"NGX_HAVE_LIB_AV_FILTER\"\nngx_feature_run=no\nngx_feature_incs=\"#include <libavfilter/avfilter.h>\n                  #include <libavfilter/buffersrc.h>\n                  #include <libavfilter/buffersink.h>\"\nngx_feature_path=\nngx_feature_libs=\"$LIB_AV_FILTER\"\nngx_feature_test=\"avfilter_get_by_name(NULL)\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    ngx_module_libs=\"$ngx_module_libs $LIB_AV_FILTER $LIB_AV_UTIL\"\nfi\n\n# libxml2\n#\nngx_feature=\"libxml2\"\nngx_feature_name=\"NGX_HAVE_LIBXML2\"\nngx_feature_run=no\nngx_feature_incs=\"#include <libxml/parser.h>\n                  #include <libxml/tree.h>\"\nngx_feature_path=\"/usr/include/libxml2\"\nngx_feature_libs=\"-lxml2\"\nngx_feature_test=\"xmlReadMemory(NULL, 0, NULL, NULL, 0);\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    ngx_module_incs=\"$ngx_module_incs $ngx_feature_path\"\n    ngx_module_libs=\"$ngx_module_libs $ngx_feature_libs\"\n    VOD_FEATURE_SRCS=\"                                      \\\n        $ngx_addon_dir/vod/subtitle/dfxp_format.c           \\\n        \"\n    VOD_FEATURE_DEPS=\"                                      \\\n        $ngx_addon_dir/vod/subtitle/dfxp_format.h           \\\n        \"\n    VOD_SRCS=\"$VOD_SRCS $VOD_FEATURE_SRCS\"\n    VOD_DEPS=\"$VOD_DEPS $VOD_FEATURE_DEPS\"\nfi\n\nVOD_DEPS=\"$VOD_DEPS                                           \\\n          $ngx_addon_dir/ngx_async_open_file_cache.h          \\\n          $ngx_addon_dir/ngx_buffer_cache.h                   \\\n          $ngx_addon_dir/ngx_buffer_cache_internal.h          \\\n          $ngx_addon_dir/ngx_child_http_request.h             \\\n          $ngx_addon_dir/ngx_file_reader.h                    \\\n          $ngx_addon_dir/ngx_http_vod_conf.h                  \\\n          $ngx_addon_dir/ngx_http_vod_dash.h                  \\\n          $ngx_addon_dir/ngx_http_vod_dash_commands.h         \\\n          $ngx_addon_dir/ngx_http_vod_dash_conf.h             \\\n          $ngx_addon_dir/ngx_http_vod_hds.h                   \\\n          $ngx_addon_dir/ngx_http_vod_hds_commands.h          \\\n          $ngx_addon_dir/ngx_http_vod_hds_conf.h              \\\n          $ngx_addon_dir/ngx_http_vod_hls.h                   \\\n          $ngx_addon_dir/ngx_http_vod_hls_commands.h          \\\n          $ngx_addon_dir/ngx_http_vod_hls_conf.h              \\\n          $ngx_addon_dir/ngx_http_vod_module.h                \\\n          $ngx_addon_dir/ngx_http_vod_mss.h                   \\\n          $ngx_addon_dir/ngx_http_vod_mss_commands.h          \\\n          $ngx_addon_dir/ngx_http_vod_mss_conf.h              \\\n          $ngx_addon_dir/ngx_http_vod_request_parse.h         \\\n          $ngx_addon_dir/ngx_http_vod_status.h                \\\n          $ngx_addon_dir/ngx_http_vod_submodule.h             \\\n          $ngx_addon_dir/ngx_http_vod_utils.h                 \\\n          $ngx_addon_dir/ngx_perf_counters.h                  \\\n          $ngx_addon_dir/ngx_perf_counters_x.h                \\\n          $ngx_addon_dir/vod/aes_defs.h                       \\\n          $ngx_addon_dir/vod/avc_defs.h                       \\\n          $ngx_addon_dir/vod/avc_parser.h                     \\\n          $ngx_addon_dir/vod/avc_hevc_parser.h                \\\n          $ngx_addon_dir/vod/bit_read_stream.h                \\\n          $ngx_addon_dir/vod/buffer_pool.h                    \\\n          $ngx_addon_dir/vod/codec_config.h                   \\\n          $ngx_addon_dir/vod/common.h                         \\\n          $ngx_addon_dir/vod/dash/dash_packager.h             \\\n          $ngx_addon_dir/vod/dynamic_buffer.h                 \\\n          $ngx_addon_dir/vod/filters/audio_filter.h           \\\n          $ngx_addon_dir/vod/filters/concat_clip.h            \\\n          $ngx_addon_dir/vod/filters/dynamic_clip.h           \\\n          $ngx_addon_dir/vod/filters/filter.h                 \\\n          $ngx_addon_dir/vod/filters/gain_filter.h            \\\n          $ngx_addon_dir/vod/filters/mix_filter.h             \\\n          $ngx_addon_dir/vod/filters/rate_filter.h            \\\n          $ngx_addon_dir/vod/hds/hds_amf0_encoder.h           \\\n          $ngx_addon_dir/vod/hds/hds_amf0_fields_x.h          \\\n          $ngx_addon_dir/vod/hds/hds_encryption.h             \\\n          $ngx_addon_dir/vod/hds/hds_fragment.h               \\\n          $ngx_addon_dir/vod/hds/hds_manifest.h               \\\n          $ngx_addon_dir/vod/hevc_parser.h                    \\\n          $ngx_addon_dir/vod/hls/adts_encoder_filter.h        \\\n          $ngx_addon_dir/vod/hls/bit_fields.h                 \\\n          $ngx_addon_dir/vod/hls/buffer_filter.h              \\\n          $ngx_addon_dir/vod/hls/frame_joiner_filter.h        \\\n          $ngx_addon_dir/vod/hls/hls_encryption.h             \\\n          $ngx_addon_dir/vod/hls/hls_muxer.h                  \\\n          $ngx_addon_dir/vod/hls/id3_encoder_filter.h         \\\n          $ngx_addon_dir/vod/hls/m3u8_builder.h               \\\n          $ngx_addon_dir/vod/hls/media_filter.h               \\\n          $ngx_addon_dir/vod/hls/mp4_to_annexb_filter.h       \\\n          $ngx_addon_dir/vod/hls/mpegts_encoder_filter.h      \\\n          $ngx_addon_dir/vod/input/silence_generator.h        \\\n          $ngx_addon_dir/vod/input/frames_source.h            \\\n          $ngx_addon_dir/vod/input/frames_source_cache.h      \\\n          $ngx_addon_dir/vod/input/frames_source_memory.h     \\\n          $ngx_addon_dir/vod/input/read_cache.h               \\\n          $ngx_addon_dir/vod/json_parser.h                    \\\n          $ngx_addon_dir/vod/language_code.h                  \\\n          $ngx_addon_dir/vod/languages_hash_params.h          \\\n          $ngx_addon_dir/vod/languages_x.h                    \\\n          $ngx_addon_dir/vod/manifest_utils.h                 \\\n          $ngx_addon_dir/vod/media_clip.h                     \\\n          $ngx_addon_dir/vod/media_format.h                   \\\n          $ngx_addon_dir/vod/media_set.h                      \\\n          $ngx_addon_dir/vod/media_set_parser.h               \\\n          $ngx_addon_dir/vod/mkv/ebml.h                       \\\n          $ngx_addon_dir/vod/mkv/mkv_builder.h                \\\n          $ngx_addon_dir/vod/mkv/mkv_defs.h                   \\\n          $ngx_addon_dir/vod/mkv/mkv_format.h                 \\\n          $ngx_addon_dir/vod/mp4/mp4_clipper.h                \\\n          $ngx_addon_dir/vod/mp4/mp4_defs.h                   \\\n          $ngx_addon_dir/vod/mp4/mp4_format.h                 \\\n          $ngx_addon_dir/vod/mp4/mp4_fragment.h               \\\n          $ngx_addon_dir/vod/mp4/mp4_init_segment.h           \\\n          $ngx_addon_dir/vod/mp4/mp4_muxer.h                  \\\n          $ngx_addon_dir/vod/mp4/mp4_parser.h                 \\\n          $ngx_addon_dir/vod/mp4/mp4_parser_base.h            \\\n          $ngx_addon_dir/vod/mp4/mp4_write_stream.h           \\\n          $ngx_addon_dir/vod/mss/mss_packager.h               \\\n          $ngx_addon_dir/vod/subtitle/cap_format.h            \\\n          $ngx_addon_dir/vod/subtitle/dfxp_format.h           \\\n          $ngx_addon_dir/vod/subtitle/subtitle_format.h       \\\n          $ngx_addon_dir/vod/subtitle/ttml_builder.h          \\\n          $ngx_addon_dir/vod/subtitle/webvtt_builder.h        \\\n          $ngx_addon_dir/vod/subtitle/webvtt_format.h         \\\n          $ngx_addon_dir/vod/subtitle/webvtt_format_template.h \\\n          $ngx_addon_dir/vod/parse_utils.h                    \\\n          $ngx_addon_dir/vod/read_stream.h                    \\\n          $ngx_addon_dir/vod/segmenter.h                      \\\n          $ngx_addon_dir/vod/udrm.h                           \\\n          $ngx_addon_dir/vod/write_buffer.h                   \\\n          $ngx_addon_dir/vod/write_buffer_queue.h             \\\n          $ngx_addon_dir/vod/write_stream.h                   \\\n          \"\n\nVOD_SRCS=\"$VOD_SRCS                                           \\\n          $ngx_addon_dir/ngx_async_open_file_cache.c          \\\n          $ngx_addon_dir/ngx_buffer_cache.c                   \\\n          $ngx_addon_dir/ngx_child_http_request.c             \\\n          $ngx_addon_dir/ngx_file_reader.c                    \\\n          $ngx_addon_dir/ngx_http_vod_conf.c                  \\\n          $ngx_addon_dir/ngx_http_vod_dash.c                  \\\n          $ngx_addon_dir/ngx_http_vod_hds.c                   \\\n          $ngx_addon_dir/ngx_http_vod_hls.c                   \\\n          $ngx_addon_dir/ngx_http_vod_module.c                \\\n          $ngx_addon_dir/ngx_http_vod_mss.c                   \\\n          $ngx_addon_dir/ngx_http_vod_request_parse.c         \\\n          $ngx_addon_dir/ngx_http_vod_status.c                \\\n          $ngx_addon_dir/ngx_http_vod_submodule.c             \\\n          $ngx_addon_dir/ngx_http_vod_utils.c                 \\\n          $ngx_addon_dir/ngx_perf_counters.c                  \\\n          $ngx_addon_dir/vod/avc_parser.c                     \\\n          $ngx_addon_dir/vod/avc_hevc_parser.c                \\\n          $ngx_addon_dir/vod/buffer_pool.c                    \\\n          $ngx_addon_dir/vod/codec_config.c                   \\\n          $ngx_addon_dir/vod/common.c                         \\\n          $ngx_addon_dir/vod/dash/dash_packager.c             \\\n          $ngx_addon_dir/vod/dynamic_buffer.c                 \\\n          $ngx_addon_dir/vod/filters/audio_filter.c           \\\n          $ngx_addon_dir/vod/filters/concat_clip.c            \\\n          $ngx_addon_dir/vod/filters/dynamic_clip.c           \\\n          $ngx_addon_dir/vod/filters/filter.c                 \\\n          $ngx_addon_dir/vod/filters/gain_filter.c            \\\n          $ngx_addon_dir/vod/filters/mix_filter.c             \\\n          $ngx_addon_dir/vod/filters/rate_filter.c            \\\n          $ngx_addon_dir/vod/hds/hds_amf0_encoder.c           \\\n          $ngx_addon_dir/vod/hds/hds_fragment.c               \\\n          $ngx_addon_dir/vod/hds/hds_manifest.c               \\\n          $ngx_addon_dir/vod/hevc_parser.c                    \\\n          $ngx_addon_dir/vod/hls/adts_encoder_filter.c        \\\n          $ngx_addon_dir/vod/hls/buffer_filter.c              \\\n          $ngx_addon_dir/vod/hls/frame_joiner_filter.c        \\\n          $ngx_addon_dir/vod/hls/hls_muxer.c                  \\\n          $ngx_addon_dir/vod/hls/id3_encoder_filter.c         \\\n          $ngx_addon_dir/vod/hls/m3u8_builder.c               \\\n          $ngx_addon_dir/vod/hls/mp4_to_annexb_filter.c       \\\n          $ngx_addon_dir/vod/hls/mpegts_encoder_filter.c      \\\n          $ngx_addon_dir/vod/input/silence_generator.c        \\\n          $ngx_addon_dir/vod/input/frames_source_cache.c      \\\n          $ngx_addon_dir/vod/input/frames_source_memory.c     \\\n          $ngx_addon_dir/vod/input/read_cache.c               \\\n          $ngx_addon_dir/vod/json_parser.c                    \\\n          $ngx_addon_dir/vod/language_code.c                  \\\n          $ngx_addon_dir/vod/manifest_utils.c                 \\\n          $ngx_addon_dir/vod/media_format.c                   \\\n          $ngx_addon_dir/vod/media_set.c                      \\\n          $ngx_addon_dir/vod/media_set_parser.c               \\\n          $ngx_addon_dir/vod/mkv/ebml.c                       \\\n          $ngx_addon_dir/vod/mkv/mkv_builder.c                \\\n          $ngx_addon_dir/vod/mkv/mkv_defs.c                   \\\n          $ngx_addon_dir/vod/mkv/mkv_format.c                 \\\n          $ngx_addon_dir/vod/mp4/mp4_clipper.c                \\\n          $ngx_addon_dir/vod/mp4/mp4_format.c                 \\\n          $ngx_addon_dir/vod/mp4/mp4_fragment.c               \\\n          $ngx_addon_dir/vod/mp4/mp4_init_segment.c           \\\n          $ngx_addon_dir/vod/mp4/mp4_muxer.c                  \\\n          $ngx_addon_dir/vod/mp4/mp4_parser.c                 \\\n          $ngx_addon_dir/vod/mp4/mp4_parser_base.c            \\\n          $ngx_addon_dir/vod/mss/mss_packager.c               \\\n          $ngx_addon_dir/vod/subtitle/cap_format.c            \\\n          $ngx_addon_dir/vod/subtitle/subtitle_format.c       \\\n          $ngx_addon_dir/vod/subtitle/ttml_builder.c          \\\n          $ngx_addon_dir/vod/subtitle/webvtt_builder.c        \\\n          $ngx_addon_dir/vod/subtitle/webvtt_format.c         \\\n          $ngx_addon_dir/vod/parse_utils.c                    \\\n          $ngx_addon_dir/vod/segmenter.c                      \\\n          $ngx_addon_dir/vod/udrm.c                           \\\n          $ngx_addon_dir/vod/write_buffer.c                   \\\n          $ngx_addon_dir/vod/write_buffer_queue.c             \\\n          \"\n\nif [ -n \"$ngx_module_link\" ]; then\n    ngx_module_type=HTTP_AUX_FILTER\n    ngx_module_name=ngx_http_vod_module\n    ngx_module_deps=\"$VOD_DEPS\"\n    ngx_module_srcs=\"$VOD_SRCS\"\n\n    . auto/module\nelse\n    HTTP_AUX_FILTER_MODULES=\"$HTTP_AUX_FILTER_MODULES ngx_http_vod_module\"\n    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $VOD_DEPS\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $VOD_SRCS\"\n    CORE_INCS=\"$CORE_INCS $ngx_module_incs\"\n    CORE_LIBS=\"$CORE_LIBS $ngx_module_libs\"\nfi\n"
        },
        {
          "name": "ngx_async_open_file_cache.c",
          "type": "blob",
          "size": 33.5068359375,
          "content": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n\n#if (NGX_THREADS)\n\n#include \"ngx_async_open_file_cache.h\"\n\n/*\n * open file cache caches\n *    open file handles with stat() info;\n *    directories stat() info;\n *    files and directories errors: not found, access denied, etc.\n */\n\n\n#define NGX_MIN_READ_AHEAD  (128 * 1024)\n\n\n#if (NGX_HAVE_OPENAT)\nstatic ngx_fd_t ngx_openat_file_owner(ngx_fd_t at_fd, const u_char *name,\n    ngx_int_t mode, ngx_int_t create, ngx_int_t access, ngx_log_t *log);\n#if (NGX_HAVE_O_PATH)\nstatic ngx_int_t ngx_file_o_path_info(ngx_fd_t fd, ngx_file_info_t *fi,\n    ngx_log_t *log);\n#endif\n#endif\nstatic ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name,\n    ngx_open_file_info_t *of, ngx_int_t mode, ngx_int_t create,\n    ngx_int_t access, ngx_log_t *log);\nstatic ngx_int_t ngx_file_info_wrapper(ngx_str_t *name,\n    ngx_open_file_info_t *of, ngx_file_info_t *fi, ngx_log_t *log);\nstatic ngx_int_t ngx_open_and_stat_file(ngx_str_t *name,\n    ngx_open_file_info_t *of, ngx_log_t *log);\nstatic void ngx_open_file_add_event(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log);\nstatic void ngx_open_file_cleanup(void *data);\nstatic void ngx_close_cached_file(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_uint_t min_uses, ngx_log_t *log);\nstatic void ngx_open_file_del_event(ngx_cached_open_file_t *file);\nstatic void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache,\n    ngx_uint_t n, ngx_log_t *log);\nstatic ngx_cached_open_file_t *\n    ngx_open_file_lookup(ngx_open_file_cache_t *cache, ngx_str_t *name,\n    uint32_t hash);\nstatic void ngx_open_file_cache_remove(ngx_event_t *ev);\n\n\nstatic ngx_int_t\nngx_save_open_file_to_cache(ngx_open_file_cache_t *cache, ngx_cached_open_file_t *file, ngx_str_t *name, uint32_t hash,\n    ngx_open_file_info_t *of, ngx_log_t *log, ngx_pool_cleanup_t *cln, ngx_int_t open_rc)\n{\n    time_t                          now;\n    ngx_open_file_cache_cleanup_t  *ofcln;\n\n    now = ngx_time();\n\n    if (file) {\n\n        file->count--;\n\n        if (open_rc != NGX_OK && (of->err == 0 || !of->errors)) {\n\n            ngx_open_file_del_event(file);\n\n            if (file->close) {\n\n                /* file was already removed from rbtree and cache->current was decremented,\n                    cleaning it up here instead of going to failed since that will make it happen again */\n\n                if (file->count == 0) {\n\n                    if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n                        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                            ngx_close_file_n \" \\\"%s\\\" failed\",\n                            file->name);\n                    }\n\n                    ngx_free(file->name);\n                    ngx_free(file);\n                }\n\n                file = NULL;\n\n            } else {\n\n                ngx_queue_remove(&file->queue);\n            }\n\n            goto failed;\n        }\n\n        if (!of->is_dir && of->err == 0 && of->uniq == file->uniq) {\n\n            file->uses++;\n\n            if (!file->close) {\n                ngx_queue_remove(&file->queue);\n            }\n\n            if (file->event) {\n                file->use_event = 1;\n            }\n\n            of->is_directio = file->is_directio;\n\n            goto update;\n        }\n\n        if (file->close) {\n\n            ngx_close_cached_file(cache, file, 0, log);\n\n            file = ngx_open_file_lookup(cache, name, hash);\n        }\n\n    } else {\n\n        file = ngx_open_file_lookup(cache, name, hash);\n    }\n\n    if (file) {\n\n        file->uses++;\n\n        ngx_queue_remove(&file->queue);\n\n        if (file->fd == NGX_INVALID_FILE && file->err == 0 && !file->is_dir) {\n\n            /* file was not used often enough to keep open */\n            if (open_rc != NGX_OK && (of->err == 0 || !of->errors)) {\n                goto failed;\n            }\n\n            goto add_event;\n        }\n\n        if (file->use_event\n            || (file->event == NULL\n                && (of->uniq == 0 || of->uniq == file->uniq)\n                && now - file->created < of->valid\n#if (NGX_HAVE_OPENAT)\n                && of->disable_symlinks == file->disable_symlinks\n                && of->disable_symlinks_from == file->disable_symlinks_from\n#endif\n            ))\n        {\n            /* initially had a cache miss, but now that the open completed, there's a cache hit\n                closing the file handle and using the cached handle instead */\n            if (of->fd != NGX_INVALID_FILE) {\n\n                ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, log, 0, \"file cleanup: fd:%d\",\n                               of->fd);\n\n                if (ngx_close_file(of->fd) == NGX_FILE_ERROR) {\n                    ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                                  ngx_close_file_n \" \\\"%s\\\" failed\", name->data);\n                }\n                of->fd = NGX_INVALID_FILE;\n            }\n            \n            if (file->err == 0) {\n                of->err = 0;\n                of->failed = NULL;\n\n                of->fd = file->fd;\n                of->uniq = file->uniq;\n                of->mtime = file->mtime;\n                of->size = file->size;\n\n                of->is_dir = file->is_dir;\n                of->is_file = file->is_file;\n                of->is_link = file->is_link;\n                of->is_exec = file->is_exec;\n                of->is_directio = file->is_directio;\n\n                if (!file->is_dir) {\n                    file->count++;\n                    ngx_open_file_add_event(cache, file, of, log);\n                }\n\n            } else {\n                of->err = file->err;\n#if (NGX_HAVE_OPENAT)\n                of->failed = file->disable_symlinks ? ngx_openat_file_n\n                                                    : ngx_open_file_n;\n#else\n                of->failed = ngx_open_file_n;\n#endif\n            }\n\n            goto found;\n        }\n\n        if (open_rc != NGX_OK && (of->err == 0 || !of->errors)) {\n            goto failed;\n        }\n        \n        if (of->is_dir) {\n\n            if (file->is_dir || file->err) {\n                goto update;\n            }\n\n            /* file became directory */\n\n        } else if (of->err == 0) {  /* file */\n\n            if (file->is_dir || file->err) {\n                goto add_event;\n            }\n\n            /* file was changed */\n\n        } else { /* error to cache */\n\n            if (file->err || file->is_dir) {\n                goto update;\n            }\n\n            /* file was removed, etc. */\n        }\n\n        if (file->count == 0) {\n\n            ngx_open_file_del_event(file);\n\n            if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                              ngx_close_file_n \" \\\"%V\\\" failed\", name);\n            }\n\n            goto add_event;\n        }\n\n        ngx_rbtree_delete(&cache->rbtree, &file->node);\n\n        cache->current--;\n\n        file->close = 1;\n\n        goto create;\n    }\n\n    /* not found */\n    \n    if (open_rc != NGX_OK && (of->err == 0 || !of->errors)) {\n        goto failed;\n    }\n\ncreate:\n\n    if (cache->current >= cache->max) {\n        ngx_expire_old_cached_files(cache, 0, log);\n    }\n\n    file = ngx_alloc(sizeof(ngx_cached_open_file_t), log);\n\n    if (file == NULL) {\n        goto failed;\n    }\n\n    file->name = ngx_alloc(name->len + 1, log);\n\n    if (file->name == NULL) {\n        ngx_free(file);\n        file = NULL;\n        goto failed;\n    }\n\n    ngx_cpystrn(file->name, name->data, name->len + 1);\n\n    file->node.key = hash;\n\n    ngx_rbtree_insert(&cache->rbtree, &file->node);\n\n    cache->current++;\n\n    file->uses = 1;\n    file->count = 0;\n    file->use_event = 0;\n    file->event = NULL;\n    file->close = 0;\n\nadd_event:\n\n    ngx_open_file_add_event(cache, file, of, log);\n\nupdate:\n\n    file->fd = of->fd;\n    file->err = of->err;\n#if (NGX_HAVE_OPENAT)\n    file->disable_symlinks = of->disable_symlinks;\n    file->disable_symlinks_from = of->disable_symlinks_from;\n#endif\n\n    if (of->err == 0) {\n        file->uniq = of->uniq;\n        file->mtime = of->mtime;\n        file->size = of->size;\n\n        file->is_dir = of->is_dir;\n        file->is_file = of->is_file;\n        file->is_link = of->is_link;\n        file->is_exec = of->is_exec;\n        file->is_directio = of->is_directio;\n\n        if (!of->is_dir) {\n            file->count++;\n        }\n    }\n\n    file->created = now;\n\nfound:\n\n    file->accessed = now;\n\n    if (!file->close)\n    {\n        ngx_queue_insert_head(&cache->expire_queue, &file->queue);\n    }\n\n    ngx_log_debug5(NGX_LOG_DEBUG_CORE, log, 0,\n                   \"cached open file: %s, fd:%d, c:%d, e:%d, u:%d\",\n                   file->name, file->fd, file->count, file->err, file->uses);\n\n    if (of->err == 0) {\n\n        if (!of->is_dir) {\n            cln->handler = ngx_open_file_cleanup;\n            ofcln = cln->data;\n\n            ofcln->cache = cache;\n            ofcln->file = file;\n            ofcln->min_uses = of->min_uses;\n            ofcln->log = log;\n        }\n\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n\nfailed:\n\n    if (file) {\n        ngx_rbtree_delete(&cache->rbtree, &file->node);\n\n        cache->current--;\n\n        if (file->count == 0) {\n\n            if (file->fd != NGX_INVALID_FILE) {\n                if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n                    ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                                  ngx_close_file_n \" \\\"%s\\\" failed\",\n                                  file->name);\n                }\n            }\n\n            ngx_free(file->name);\n            ngx_free(file);\n\n        } else {\n            file->close = 1;\n        }\n    }\n\n    if (of->fd != NGX_INVALID_FILE) {\n        if (ngx_close_file(of->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%V\\\" failed\", name);\n        }\n    }\n\n    return NGX_ERROR;\n}\n\n\n#if (NGX_HAVE_OPENAT)\n\nstatic ngx_fd_t\nngx_openat_file_owner(ngx_fd_t at_fd, const u_char *name,\n    ngx_int_t mode, ngx_int_t create, ngx_int_t access, ngx_log_t *log)\n{\n    ngx_fd_t         fd;\n    ngx_err_t        err;\n    ngx_file_info_t  fi, atfi;\n\n    /*\n     * To allow symlinks with the same owner, use openat() (followed\n     * by fstat()) and fstatat(AT_SYMLINK_NOFOLLOW), and then compare\n     * uids between fstat() and fstatat().\n     *\n     * As there is a race between openat() and fstatat() we don't\n     * know if openat() in fact opened symlink or not.  Therefore,\n     * we have to compare uids even if fstatat() reports the opened\n     * component isn't a symlink (as we don't know whether it was\n     * symlink during openat() or not).\n     */\n\n    fd = ngx_openat_file(at_fd, name, mode, create, access);\n\n    if (fd == NGX_INVALID_FILE) {\n        return NGX_INVALID_FILE;\n    }\n\n    if (ngx_file_at_info(at_fd, name, &atfi, AT_SYMLINK_NOFOLLOW)\n        == NGX_FILE_ERROR)\n    {\n        err = ngx_errno;\n        goto failed;\n    }\n\n#if (NGX_HAVE_O_PATH)\n    if (ngx_file_o_path_info(fd, &fi, log) == NGX_ERROR) {\n        err = ngx_errno;\n        goto failed;\n    }\n#else\n    if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {\n        err = ngx_errno;\n        goto failed;\n    }\n#endif\n\n    if (fi.st_uid != atfi.st_uid) {\n        err = NGX_ELOOP;\n        goto failed;\n    }\n\n    return fd;\n\nfailed:\n\n    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                      ngx_close_file_n \" \\\"%V\\\" failed\", name);\n    }\n\n    ngx_set_errno(err);\n\n    return NGX_INVALID_FILE;\n}\n\n\n#if (NGX_HAVE_O_PATH)\n\nstatic ngx_int_t\nngx_file_o_path_info(ngx_fd_t fd, ngx_file_info_t *fi, ngx_log_t *log)\n{\n    static ngx_uint_t  use_fstat = 1;\n\n    /*\n     * In Linux 2.6.39 the O_PATH flag was introduced that allows to obtain\n     * a descriptor without actually opening file or directory.  It requires\n     * less permissions for path components, but till Linux 3.6 fstat() returns\n     * EBADF on such descriptors, and fstatat() with the AT_EMPTY_PATH flag\n     * should be used instead.\n     *\n     * Three scenarios are handled in this function:\n     *\n     * 1) The kernel is newer than 3.6 or fstat() with O_PATH support was\n     *    backported by vendor.  Then fstat() is used.\n     *\n     * 2) The kernel is newer than 2.6.39 but older than 3.6.  In this case\n     *    the first call of fstat() returns EBADF and we fallback to fstatat()\n     *    with AT_EMPTY_PATH which was introduced at the same time as O_PATH.\n     *\n     * 3) The kernel is older than 2.6.39 but nginx was build with O_PATH\n     *    support.  Since descriptors are opened with O_PATH|O_RDONLY flags\n     *    and O_PATH is ignored by the kernel then the O_RDONLY flag is\n     *    actually used.  In this case fstat() just works.\n     */\n\n    if (use_fstat) {\n        if (ngx_fd_info(fd, fi) != NGX_FILE_ERROR) {\n            return NGX_OK;\n        }\n\n        if (ngx_errno != NGX_EBADF) {\n            return NGX_ERROR;\n        }\n\n        ngx_log_error(NGX_LOG_NOTICE, log, 0,\n                      \"fstat(O_PATH) failed with EBADF, \"\n                      \"switching to fstatat(AT_EMPTY_PATH)\");\n\n        use_fstat = 0;\n    }\n\n    if (ngx_file_at_info(fd, \"\", fi, AT_EMPTY_PATH) != NGX_FILE_ERROR) {\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n}\n\n#endif\n\n#endif /* NGX_HAVE_OPENAT */\n\n\nstatic ngx_fd_t\nngx_open_file_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,\n    ngx_int_t mode, ngx_int_t create, ngx_int_t access, ngx_log_t *log)\n{\n    ngx_fd_t  fd;\n\n#if !(NGX_HAVE_OPENAT)\n\n    fd = ngx_open_file(name->data, mode, create, access);\n\n    if (fd == NGX_INVALID_FILE) {\n        of->err = ngx_errno;\n        of->failed = ngx_open_file_n;\n        return NGX_INVALID_FILE;\n    }\n\n    return fd;\n\n#else\n\n    u_char           *p, *cp, *end;\n    ngx_fd_t          at_fd;\n    ngx_str_t         at_name;\n\n    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {\n        fd = ngx_open_file(name->data, mode, create, access);\n\n        if (fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_open_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        return fd;\n    }\n\n    p = name->data;\n    end = p + name->len;\n\n    at_name = *name;\n\n    if (of->disable_symlinks_from) {\n\n        cp = p + of->disable_symlinks_from;\n\n        *cp = '\\0';\n\n        at_fd = ngx_open_file(p, NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                              NGX_FILE_OPEN, 0);\n\n        *cp = '/';\n\n        if (at_fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_open_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        at_name.len = of->disable_symlinks_from;\n        p = cp + 1;\n\n    } else if (*p == '/') {\n\n        at_fd = ngx_open_file(\"/\",\n                              NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                              NGX_FILE_OPEN, 0);\n\n        if (at_fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_openat_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        at_name.len = 1;\n        p++;\n\n    } else {\n        at_fd = NGX_AT_FDCWD;\n    }\n\n    for ( ;; ) {\n        cp = ngx_strlchr(p, end, '/');\n        if (cp == NULL) {\n            break;\n        }\n\n        if (cp == p) {\n            p++;\n            continue;\n        }\n\n        *cp = '\\0';\n\n        if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_NOTOWNER) {\n            fd = ngx_openat_file_owner(at_fd, p,\n                                       NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                                       NGX_FILE_OPEN, 0, log);\n\n        } else {\n            fd = ngx_openat_file(at_fd, p,\n                           NGX_FILE_SEARCH|NGX_FILE_NONBLOCK|NGX_FILE_NOFOLLOW,\n                           NGX_FILE_OPEN, 0);\n        }\n\n        *cp = '/';\n\n        if (fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_openat_file_n;\n            goto failed;\n        }\n\n        if (at_fd != NGX_AT_FDCWD && ngx_close_file(at_fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%V\\\" failed\", &at_name);\n        }\n\n        p = cp + 1;\n        at_fd = fd;\n        at_name.len = cp - at_name.data;\n    }\n\n    if (p == end) {\n\n        /*\n         * If pathname ends with a trailing slash, assume the last path\n         * component is a directory and reopen it with requested flags;\n         * if not, fail with ENOTDIR as per POSIX.\n         *\n         * We cannot rely on O_DIRECTORY in the loop above to check\n         * that the last path component is a directory because\n         * O_DIRECTORY doesn't work on FreeBSD 8.  Fortunately, by\n         * reopening a directory, we don't depend on it at all.\n         */\n\n        fd = ngx_openat_file(at_fd, \".\", mode, create, access);\n        goto done;\n    }\n\n    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_NOTOWNER\n        && !(create & (NGX_FILE_CREATE_OR_OPEN|NGX_FILE_TRUNCATE)))\n    {\n        fd = ngx_openat_file_owner(at_fd, p, mode, create, access, log);\n\n    } else {\n        fd = ngx_openat_file(at_fd, p, mode|NGX_FILE_NOFOLLOW, create, access);\n    }\n\ndone:\n\n    if (fd == NGX_INVALID_FILE) {\n        of->err = ngx_errno;\n        of->failed = ngx_openat_file_n;\n    }\n\nfailed:\n\n    if (at_fd != NGX_AT_FDCWD && ngx_close_file(at_fd) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                      ngx_close_file_n \" \\\"%V\\\" failed\", &at_name);\n    }\n\n    return fd;\n#endif\n}\n\n\nstatic ngx_int_t\nngx_file_info_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,\n    ngx_file_info_t *fi, ngx_log_t *log)\n{\n    ngx_int_t  rc;\n\n#if !(NGX_HAVE_OPENAT)\n\n    rc = ngx_file_info(name->data, fi);\n\n    if (rc == NGX_FILE_ERROR) {\n        of->err = ngx_errno;\n        of->failed = ngx_file_info_n;\n        return NGX_FILE_ERROR;\n    }\n\n    return rc;\n\n#else\n\n    ngx_fd_t  fd;\n\n    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {\n\n        rc = ngx_file_info(name->data, fi);\n\n        if (rc == NGX_FILE_ERROR) {\n            of->err = ngx_errno;\n            of->failed = ngx_file_info_n;\n            return NGX_FILE_ERROR;\n        }\n\n        return rc;\n    }\n\n    fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,\n                               NGX_FILE_OPEN, 0, log);\n\n    if (fd == NGX_INVALID_FILE) {\n        return NGX_FILE_ERROR;\n    }\n\n    rc = ngx_fd_info(fd, fi);\n\n    if (rc == NGX_FILE_ERROR) {\n        of->err = ngx_errno;\n        of->failed = ngx_fd_info_n;\n    }\n\n    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                      ngx_close_file_n \" \\\"%V\\\" failed\", name);\n    }\n\n    return rc;\n#endif\n}\n\n\nstatic ngx_int_t\nngx_open_and_stat_file(ngx_str_t *name, ngx_open_file_info_t *of,\n    ngx_log_t *log)\n{\n    ngx_fd_t         fd;\n    ngx_file_info_t  fi;\n\n    if (of->fd != NGX_INVALID_FILE) {\n\n        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {\n            of->fd = NGX_INVALID_FILE;\n            return NGX_ERROR;\n        }\n\n        if (of->uniq == ngx_file_uniq(&fi)) {\n            goto done;\n        }\n\n    } else if (of->test_dir) {\n\n        if (ngx_file_info_wrapper(name, of, &fi, log) == NGX_FILE_ERROR) {\n            of->fd = NGX_INVALID_FILE;\n            return NGX_ERROR;\n        }\n\n        if (ngx_is_dir(&fi)) {\n            goto done;\n        }\n    }\n\n    if (!of->log) {\n\n        /*\n         * Use non-blocking open() not to hang on FIFO files, etc.\n         * This flag has no effect on a regular files.\n         */\n\n        fd = ngx_open_file_wrapper(name, of, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,\n                                   NGX_FILE_OPEN, 0, log);\n\n    } else {\n        fd = ngx_open_file_wrapper(name, of, NGX_FILE_APPEND,\n                                   NGX_FILE_CREATE_OR_OPEN,\n                                   NGX_FILE_DEFAULT_ACCESS, log);\n    }\n\n    if (fd == NGX_INVALID_FILE) {\n        of->fd = NGX_INVALID_FILE;\n        return NGX_ERROR;\n    }\n\n    if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n                      ngx_fd_info_n \" \\\"%V\\\" failed\", name);\n\n        if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%V\\\" failed\", name);\n        }\n\n        of->fd = NGX_INVALID_FILE;\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_is_dir(&fi)) {\n        if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%V\\\" failed\", name);\n        }\n\n        of->fd = NGX_INVALID_FILE;\n\n    } else {\n        of->fd = fd;\n\n        if (of->read_ahead && ngx_file_size(&fi) > NGX_MIN_READ_AHEAD) {\n            if (ngx_read_ahead(fd, of->read_ahead) == NGX_ERROR) {\n                ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                              ngx_read_ahead_n \" \\\"%V\\\" failed\", name);\n            }\n        }\n\n        if (of->directio <= ngx_file_size(&fi)) {\n            if (ngx_directio_on(fd) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                              ngx_directio_on_n \" \\\"%V\\\" failed\", name);\n\n            } else {\n                of->is_directio = 1;\n            }\n        }\n    }\n\ndone:\n\n    of->uniq = ngx_file_uniq(&fi);\n    of->mtime = ngx_file_mtime(&fi);\n    of->size = ngx_file_size(&fi);\n    of->fs_size = ngx_file_fs_size(&fi);\n    of->is_dir = ngx_is_dir(&fi);\n    of->is_file = ngx_is_file(&fi);\n    of->is_link = ngx_is_link(&fi);\n    of->is_exec = ngx_is_exec(&fi);\n\n    return NGX_OK;\n}\n\n\n/*\n * we ignore any possible event setting error and\n * fallback to usual periodic file retests\n */\n\nstatic void\nngx_open_file_add_event(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log)\n{\n    ngx_open_file_cache_event_t  *fev;\n\n    if (!(ngx_event_flags & NGX_USE_VNODE_EVENT)\n        || !of->events\n        || file->event\n        || of->fd == NGX_INVALID_FILE\n        || file->uses < of->min_uses)\n    {\n        return;\n    }\n\n    file->use_event = 0;\n\n    file->event = ngx_calloc(sizeof(ngx_event_t), log);\n    if (file->event== NULL) {\n        return;\n    }\n\n    fev = ngx_alloc(sizeof(ngx_open_file_cache_event_t), log);\n    if (fev == NULL) {\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    fev->fd = of->fd;\n    fev->file = file;\n    fev->cache = cache;\n\n    file->event->handler = ngx_open_file_cache_remove;\n    file->event->data = fev;\n\n    /*\n     * although vnode event may be called while ngx_cycle->poll\n     * destruction, however, cleanup procedures are run before any\n     * memory freeing and events will be canceled.\n     */\n\n    file->event->log = ngx_cycle->log;\n\n    if (ngx_add_event(file->event, NGX_VNODE_EVENT, NGX_ONESHOT_EVENT)\n        != NGX_OK)\n    {\n        ngx_free(file->event->data);\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    /*\n     * we do not set file->use_event here because there may be a race\n     * condition: a file may be deleted between opening the file and\n     * adding event, so we rely upon event notification only after\n     * one file revalidation on next file access\n     */\n\n    return;\n}\n\n\nstatic void\nngx_open_file_cleanup(void *data)\n{\n    ngx_open_file_cache_cleanup_t  *c = data;\n\n    c->file->count--;\n\n    ngx_close_cached_file(c->cache, c->file, c->min_uses, c->log);\n\n    /* drop one or two expired open files */\n    ngx_expire_old_cached_files(c->cache, 1, c->log);\n}\n\n\nstatic void\nngx_close_cached_file(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_uint_t min_uses, ngx_log_t *log)\n{\n    ngx_log_debug5(NGX_LOG_DEBUG_CORE, log, 0,\n                   \"close cached open file: %s, fd:%d, c:%d, u:%d, %d\",\n                   file->name, file->fd, file->count, file->uses, file->close);\n\n    if (!file->close) {\n\n        file->accessed = ngx_time();\n\n        ngx_queue_remove(&file->queue);\n\n        ngx_queue_insert_head(&cache->expire_queue, &file->queue);\n\n        if (file->uses >= min_uses || file->count) {\n            return;\n        }\n    }\n\n    ngx_open_file_del_event(file);\n\n    if (file->count) {\n        return;\n    }\n\n    if (file->fd != NGX_INVALID_FILE) {\n\n        if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\", file->name);\n        }\n\n        file->fd = NGX_INVALID_FILE;\n    }\n\n    if (!file->close) {\n        return;\n    }\n\n    ngx_free(file->name);\n    ngx_free(file);\n}\n\n\nstatic void\nngx_open_file_del_event(ngx_cached_open_file_t *file)\n{\n    if (file->event == NULL) {\n        return;\n    }\n\n    (void) ngx_del_event(file->event, NGX_VNODE_EVENT,\n                         file->count ? NGX_FLUSH_EVENT : NGX_CLOSE_EVENT);\n\n    ngx_free(file->event->data);\n    ngx_free(file->event);\n    file->event = NULL;\n    file->use_event = 0;\n}\n\n\nstatic void\nngx_expire_old_cached_files(ngx_open_file_cache_t *cache, ngx_uint_t n,\n    ngx_log_t *log)\n{\n    time_t                   now;\n    ngx_queue_t             *q;\n    ngx_cached_open_file_t  *file;\n\n    now = ngx_time();\n\n    /*\n     * n == 1 deletes one or two inactive files\n     * n == 0 deletes least recently used file by force\n     *        and one or two inactive files\n     */\n\n    while (n < 3) {\n\n        if (ngx_queue_empty(&cache->expire_queue)) {\n            return;\n        }\n\n        q = ngx_queue_last(&cache->expire_queue);\n\n        file = ngx_queue_data(q, ngx_cached_open_file_t, queue);\n\n        if (n++ != 0 && now - file->accessed <= cache->inactive) {\n            return;\n        }\n\n        ngx_queue_remove(q);\n\n        ngx_rbtree_delete(&cache->rbtree, &file->node);\n\n        cache->current--;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,\n                       \"expire cached open file: %s\", file->name);\n\n        if (!file->err && !file->is_dir) {\n            file->close = 1;\n            ngx_close_cached_file(cache, file, 0, log);\n\n        } else {\n            ngx_free(file->name);\n            ngx_free(file);\n        }\n    }\n}\n\n\nstatic ngx_cached_open_file_t *\nngx_open_file_lookup(ngx_open_file_cache_t *cache, ngx_str_t *name,\n    uint32_t hash)\n{\n    ngx_int_t                rc;\n    ngx_rbtree_node_t       *node, *sentinel;\n    ngx_cached_open_file_t  *file;\n\n    node = cache->rbtree.root;\n    sentinel = cache->rbtree.sentinel;\n\n    while (node != sentinel) {\n\n        if (hash < node->key) {\n            node = node->left;\n            continue;\n        }\n\n        if (hash > node->key) {\n            node = node->right;\n            continue;\n        }\n\n        /* hash == node->key */\n\n        file = (ngx_cached_open_file_t *) node;\n\n        rc = ngx_strcmp(name->data, file->name);\n\n        if (rc == 0) {\n            return file;\n        }\n\n        node = (rc < 0) ? node->left : node->right;\n    }\n\n    return NULL;\n}\n\n\nstatic void\nngx_open_file_cache_remove(ngx_event_t *ev)\n{\n    ngx_cached_open_file_t       *file;\n    ngx_open_file_cache_event_t  *fev;\n\n    fev = ev->data;\n    file = fev->file;\n\n    ngx_queue_remove(&file->queue);\n\n    ngx_rbtree_delete(&fev->cache->rbtree, &file->node);\n\n    fev->cache->current--;\n\n    /* NGX_ONESHOT_EVENT was already deleted */\n    file->event = NULL;\n    file->use_event = 0;\n\n    file->close = 1;\n\n    ngx_close_cached_file(fev->cache, file, 0, ev->log);\n\n    /* free memory only when fev->cache and fev->file are already not needed */\n\n    ngx_free(ev->data);\n    ngx_free(ev);\n}\n\n\n/* Note: returns NGX_DONE on cache miss */\nstatic ngx_int_t\nngx_get_open_file_from_cache(ngx_open_file_cache_t *cache, ngx_str_t *name,\nuint32_t hash, ngx_open_file_info_t *of, ngx_log_t *log, ngx_pool_cleanup_t *cln, ngx_cached_open_file_t **out_file)\n{\n    time_t                          now;\n    ngx_cached_open_file_t         *file;\n    ngx_open_file_cache_cleanup_t  *ofcln;\n\n    now = ngx_time();\n\n    file = ngx_open_file_lookup(cache, name, hash);\n\n    if (!file) {\n        return NGX_DONE;\n    }\n\n    if (file->fd == NGX_INVALID_FILE && file->err == 0 && !file->is_dir) {\n\n        /* file was not used often enough to keep open */\n\n        return NGX_DONE;\n    }\n\n    if (!file->use_event\n        && (file->event != NULL\n            || (of->uniq != 0 && of->uniq != file->uniq)\n            || now - file->created >= of->valid\n#if (NGX_HAVE_OPENAT)\n            || of->disable_symlinks != file->disable_symlinks\n            || of->disable_symlinks_from != file->disable_symlinks_from\n#endif\n        ))\n    {\n        ngx_log_debug4(NGX_LOG_DEBUG_CORE, log, 0,\n                       \"retest open file: %s, fd:%d, c:%d, e:%d\",\n                       file->name, file->fd, file->count, file->err);\n\n        if (file->is_dir) {\n\n            /*\n             * chances that directory became file are very small\n             * so test_dir flag allows to use a single syscall\n             * in ngx_file_info() instead of three syscalls\n             */\n\n            of->test_dir = 1;\n        }\n        else if (!file->err)\n        {\n            /* increment the count to prevent the handle from getting closed by some other request */\n            file->count++;\n\n            *out_file = file;\n        }\n\n        of->fd = file->fd;\n        of->uniq = file->uniq;\n\n        return NGX_DONE;\n    }\n    \n    if (file->err == 0) {\n\n        of->fd = file->fd;\n        of->uniq = file->uniq;\n        of->mtime = file->mtime;\n        of->size = file->size;\n\n        of->is_dir = file->is_dir;\n        of->is_file = file->is_file;\n        of->is_link = file->is_link;\n        of->is_exec = file->is_exec;\n        of->is_directio = file->is_directio;\n\n        if (!file->is_dir) {\n            file->count++;\n            ngx_open_file_add_event(cache, file, of, log);\n        }\n\n    } else {\n        of->err = file->err;\n#if (NGX_HAVE_OPENAT)\n        of->failed = file->disable_symlinks ? ngx_openat_file_n\n                                            : ngx_open_file_n;\n#else\n        of->failed = ngx_open_file_n;\n#endif\n    }\n\n    file->uses++;\n\n    file->accessed = now;\n\n    ngx_queue_remove(&file->queue);\n\n    ngx_queue_insert_head(&cache->expire_queue, &file->queue);\n\n    ngx_log_debug5(NGX_LOG_DEBUG_CORE, log, 0,\n                   \"cached open file: %s, fd:%d, c:%d, e:%d, u:%d\",\n                   file->name, file->fd, file->count, file->err, file->uses);\n\n    if (of->err == 0) {\n\n        if (!of->is_dir) {\n            cln->handler = ngx_open_file_cleanup;\n            ofcln = cln->data;\n\n            ofcln->cache = cache;\n            ofcln->file = file;\n            ofcln->min_uses = of->min_uses;\n            ofcln->log = log;\n        }\n\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n}\n\ntypedef struct {\n\tngx_open_file_cache_t *cache;\n\tngx_str_t name;\n\tuint32_t hash;\n\tngx_open_file_info_t *of;\n\tngx_cached_open_file_t *file;\n\tngx_async_open_file_callback_t callback;\n\tvoid* context;\n\tngx_log_t* log;\n\tngx_pool_cleanup_t *cln;\n\tngx_int_t err;\n} ngx_async_open_file_ctx_t;\n\nstatic void\nngx_thread_open_handler(void *data, ngx_log_t *log)\n{\n\tngx_async_open_file_ctx_t* ctx = data;\n\t\n\tctx->err = ngx_open_and_stat_file(&ctx->name, ctx->of, log);\n}\n\nstatic void\nngx_async_open_thread_event_handler(ngx_event_t *ev)\n{\n\tngx_pool_cleanup_file_t *clnf;\n\tngx_async_open_file_ctx_t* ctx;\n\tngx_int_t rc;\n\n\tctx = ev->data;\n\n\tif (ctx->cache != NULL)\n\t{\n\t\trc = ngx_save_open_file_to_cache(ctx->cache, ctx->file, &ctx->name, ctx->hash, ctx->of, ctx->log, ctx->cln, ctx->err);\n\t}\n\telse\n\t{\n\t\trc = ctx->err;\n\n\t\t// set up the cleanup of the file\n\t\tif (ctx->err == NGX_OK && !ctx->of->is_dir) {\n\t\t\tctx->cln->handler = ngx_pool_cleanup_file;\n\t\t\tclnf = ctx->cln->data;\n\n\t\t\tclnf->fd = ctx->of->fd;\n\t\t\tclnf->name = ctx->name.data;\n\t\t\tclnf->log = ctx->log;\n\t\t}\n\t}\n\n\t// notify the caller\n\tctx->callback(ctx->context, rc);\n}\n\nngx_int_t\nngx_async_open_cached_file(\n\tngx_open_file_cache_t *cache, \n\tngx_str_t *name,\n\tngx_open_file_info_t *of, \n\tngx_pool_t *pool, \n\tngx_thread_pool_t *tp, \n\tngx_thread_task_t **taskp, \n\tngx_async_open_file_callback_t callback, \n\tvoid* context)\n{\n\tngx_async_open_file_ctx_t* ctx;\n\tngx_cached_open_file_t *file = NULL;\n\tngx_pool_cleanup_t *cln;\n\tngx_thread_task_t *task;\n\tngx_int_t rc;\n\tuint32_t hash = 0;\n\n\tof->fd = NGX_INVALID_FILE;\n\tof->err = 0;\n\n\tif (cache != NULL)\n\t{\n\t\tcln = ngx_pool_cleanup_add(pool, sizeof(ngx_open_file_cache_cleanup_t));\n\t\tif (cln == NULL) \n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\thash = ngx_crc32_long(name->data, name->len);\n\n\t\t// try to fetch from cache\n\t\trc = ngx_get_open_file_from_cache(cache, name, hash, of, pool->log, cln, &file);\n\t\tif (rc != NGX_DONE)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t));\n\t\tif (cln == NULL) \n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, pool->log, 0,\n\t\t\t\t\"ngx_async_open_cached_file: ngx_pool_cleanup_add failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\t}\n\n\t// allocate the task if needed\n\ttask = *taskp;\n\n\tif (task == NULL) {\n\t\ttask = ngx_thread_task_alloc(pool, sizeof(ngx_async_open_file_ctx_t));\n\t\tif (task == NULL) \n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, pool->log, 0,\n\t\t\t\t\"ngx_async_open_cached_file: ngx_thread_task_alloc failed\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\ttask->handler = ngx_thread_open_handler;\n\n\t\t*taskp = task;\n\t}\n\n\t// initialize the context\n\tctx = task->ctx;\n\tctx->cache = cache;\n\tctx->name = *name;\n\tctx->hash = hash;\n\tctx->of = of;\n\tctx->file = file;\n\tctx->callback = callback;\n\tctx->context = context;\n\tctx->log = pool->log;\n\tctx->cln = cln;\n\n\t// post the task\n\ttask->event.data = ctx;\n\ttask->event.handler = ngx_async_open_thread_event_handler;\n\n\tif (ngx_thread_task_post(tp, task) != NGX_OK) \n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, pool->log, 0,\n\t\t\t\"ngx_async_open_cached_file: ngx_thread_task_post failed\");\n\t\tgoto failed;\n\t}\n\n\treturn NGX_AGAIN;\n\nfailed:\n\n\tif (file != NULL)\n\t{\n\t\tfile->count--;\n\t\tngx_close_cached_file(cache, file, of->min_uses, pool->log);\n\t}\n\n\treturn NGX_ERROR;\n}\n\n#endif // NGX_THREADS\n"
        },
        {
          "name": "ngx_async_open_file_cache.h",
          "type": "blob",
          "size": 0.642578125,
          "content": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_open_file_cache.h>\n#include <ngx_thread_pool.h>\n\n#ifndef _NGX_ASYNC_OPEN_FILE_CACHE_H_INCLUDED_\n#define _NGX_ASYNC_OPEN_FILE_CACHE_H_INCLUDED_\n\n\ntypedef void(*ngx_async_open_file_callback_t)(void* context, ngx_int_t rc);\n\n\nngx_int_t ngx_async_open_cached_file(\n\tngx_open_file_cache_t *cache, \n\tngx_str_t *name,\n    ngx_open_file_info_t *of, \n\tngx_pool_t *pool, \n\tngx_thread_pool_t *tp, \n\tngx_thread_task_t **taskp, \n\tngx_async_open_file_callback_t callback, \n\tvoid* context);\n\n\n#endif /* _NGX_ASYNC_OPEN_FILE_CACHE_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_buffer_cache.c",
          "type": "blob",
          "size": 14.2919921875,
          "content": "#include \"ngx_buffer_cache_internal.h\"\n\n/*\n\tshared memory layout:\n\t\tshared memory start\n\t\tfixed size headers\n\t\tentries_start\n\t\t...\n\t\tentries_end\n\n\t\tbuffers_start\n\t\t...\n\t\tbuffers_end\n\t\tshared memory end\n\n\tthe shared memory is composed of 3 sections:\n\t1. fixed size headers - contains the ngx_slab_pool_t struct allocated by nginx,\n\t\tthe log context string and ngx_buffer_cache_sh_t\n\t2. entries - an array of ngx_buffer_cache_entry_t, each entry has a key and \n\t\tpoints to a buffer in the buffers section. the entries are connected with a \n\t\tred/black tree for fast lookup by key. the entries section grows as needed until \n\t\tit bumps into the buffers section. each entry is a member of one of 2 doubly \n\t\tlinked lists - the free queue and the used queue. the entries move between these \n\t\tqueues as they are allocated / deallocated\n\t3. buffers - a cyclic queue of variable size buffers. the buffers section starts\n\t\tat the end of the shared memory and grows towards its beginning until it bumps\n\t\tinto the entries section. the buffers section has 2 pointers:\n\t\ta. when a buffer is allocated, it is allocated before the write head\n\t\tb. when an entry is freed, the read head of the buffers section moves\n\n*/\n\n// Note: code taken from ngx_str_rbtree_insert_value, updated the node comparison\nstatic void\nngx_buffer_cache_rbtree_insert_value(\n\tngx_rbtree_node_t *temp, \n\tngx_rbtree_node_t *node, \n\tngx_rbtree_node_t *sentinel)\n{\n\tngx_buffer_cache_entry_t *n, *t;\n\tngx_rbtree_node_t **p;\n\n\tfor (;;) \n\t{\n\t\tn = (ngx_buffer_cache_entry_t *)node;\n\t\tt = (ngx_buffer_cache_entry_t *)temp;\n\n\t\tif (node->key != temp->key) \n\t\t{\n\t\t\tp = (node->key < temp->key) ? &temp->left : &temp->right;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tp = (ngx_memcmp(n->key, t->key, BUFFER_CACHE_KEY_SIZE) < 0)\n\t\t\t\t? &temp->left : &temp->right;\n\t\t}\n\n\t\tif (*p == sentinel) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ttemp = *p;\n\t}\n\n\t*p = node;\n\tnode->parent = temp;\n\tnode->left = sentinel;\n\tnode->right = sentinel;\n\tngx_rbt_red(node);\n}\n\n// Note: code taken from ngx_str_rbtree_lookup, updated the node comparison\nstatic ngx_buffer_cache_entry_t *\nngx_buffer_cache_rbtree_lookup(ngx_rbtree_t *rbtree, const u_char* key, uint32_t hash)\n{\n\tngx_buffer_cache_entry_t *n;\n\tngx_rbtree_node_t *node, *sentinel;\n\tngx_int_t rc;\n\n\tnode = rbtree->root;\n\tsentinel = rbtree->sentinel;\n\n\twhile (node != sentinel) \n\t{\n\t\tn = (ngx_buffer_cache_entry_t *)node;\n\n\t\tif (hash != node->key) \n\t\t{\n\t\t\tnode = (hash < node->key) ? node->left : node->right;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = ngx_memcmp(key, n->key, BUFFER_CACHE_KEY_SIZE);\n\t\tif (rc < 0) \n\t\t{\n\t\t\tnode = node->left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc > 0) \n\t\t{\n\t\t\tnode = node->right;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn n;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nngx_buffer_cache_reset(ngx_buffer_cache_sh_t *cache)\n{\n\tcache->entries_end = cache->entries_start;\n\tcache->buffers_start = cache->buffers_end;\n\tcache->buffers_read = cache->buffers_end;\n\tcache->buffers_write = cache->buffers_end;\n\tngx_rbtree_init(&cache->rbtree, &cache->sentinel, ngx_buffer_cache_rbtree_insert_value);\n\tngx_queue_init(&cache->used_queue);\n\tngx_queue_init(&cache->free_queue);\n\n\t// update stats (everything is evicted)\n\tcache->stats.evicted = cache->stats.store_ok;\n\tcache->stats.evicted_bytes = cache->stats.store_bytes;\n}\n\nstatic ngx_int_t\nngx_buffer_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n{\n\tngx_buffer_cache_sh_t *sh;\n\tngx_buffer_cache_t *ocache = data;\n\tngx_buffer_cache_t *cache;\n\tu_char* p;\n\n\tcache = shm_zone->data;\n\n\tif (ocache)\n\t{\n\t\tcache->sh = ocache->sh;\n\t\tcache->shpool = ocache->shpool;\n\t\treturn NGX_OK;\n\t}\n\n\tcache->shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;\n\n\tif (shm_zone->shm.exists) \n\t{\n\t\tcache->sh = cache->shpool->data;\n\t\treturn NGX_OK;\n\t}\n\n\t// start following the ngx_slab_pool_t that was allocated at the beginning of the chunk\n\tp = shm_zone->shm.addr + sizeof(ngx_slab_pool_t);\n\n\t// initialize the log context\n\tcache->shpool->log_ctx = p;\n\tp = ngx_sprintf(cache->shpool->log_ctx, \" in buffer cache \\\"%V\\\"%Z\", &shm_zone->shm.name);\n\n\t// allocate the shared cache state\n\tp = ngx_align_ptr(p, sizeof(void *));\n\tsh = (ngx_buffer_cache_sh_t*)p;\n\tp += sizeof(*sh);\n\tcache->sh = sh;\n\n\tcache->shpool->data = sh;\n\n\t// initialize fixed cache fields\n\tp = ngx_align_ptr(p, sizeof(void *));\n\tsh->entries_start = (ngx_buffer_cache_entry_t*)p;\n\tsh->buffers_end = shm_zone->shm.addr + shm_zone->shm.size;\n\tsh->access_time = 0;\n\n\t// reset the stats\n\tngx_memzero(&sh->stats, sizeof(sh->stats));\n\n\t// reset the cache status\n\tngx_buffer_cache_reset(sh);\n\tsh->reset = 0;\n\n\treturn NGX_OK;\n}\n\n/* Note: must be called with the mutex locked */\nstatic ngx_buffer_cache_entry_t*\nngx_buffer_cache_free_oldest_entry(ngx_buffer_cache_sh_t *cache, uint32_t expiration)\n{\n\tngx_buffer_cache_entry_t* entry;\n\n\t// verify we have an entry to free\n\tif (ngx_queue_empty(&cache->used_queue))\n\t{\n\t\treturn NULL;\n\t}\n\n\t// verify the entry is not locked\n\tentry = container_of(ngx_queue_head(&cache->used_queue), ngx_buffer_cache_entry_t, queue_node);\n\tif (entry->ref_count > 0 &&\n\t\tngx_time() < entry->access_time + ENTRY_LOCK_EXPIRATION)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// make sure the entry is expired, if that is the requirement\n\tif (expiration && ngx_time() < (time_t)(entry->write_time + expiration))\n\t{\n\t\treturn NULL;\n\t}\n\t\n\t// update the state\n\tentry->state = CES_FREE;\n\n\t// remove from rb tree\n\tngx_rbtree_delete(&cache->rbtree, &entry->node);\n\n\t// move from used_queue to free_queue\n\tngx_queue_remove(&entry->queue_node);\n\tngx_queue_insert_tail(&cache->free_queue, &entry->queue_node);\n\n\tif (ngx_queue_empty(&cache->used_queue))\n\t{\n\t\t// queue is empty reset the read/write pointers\n\t\tcache->buffers_read = cache->buffers_end;\n\t\tcache->buffers_write = cache->buffers_end;\n\t}\n\telse\n\t{\n\t\t// update the read buffer pointer\n\t\tcache->buffers_read = entry->start_offset;\n\t}\n\n\t// update stats\n\tcache->stats.evicted++;\n\tcache->stats.evicted_bytes += entry->buffer_size;\n\n\treturn entry;\n}\n\n/* Note: must be called with the mutex locked */\nstatic ngx_buffer_cache_entry_t*\nngx_buffer_cache_get_free_entry(ngx_buffer_cache_sh_t *cache)\n{\n\tngx_buffer_cache_entry_t* entry;\n\n\tif (!ngx_queue_empty(&cache->free_queue))\n\t{\n\t\t// return the free queue head\n\t\treturn container_of(ngx_queue_head(&cache->free_queue), ngx_buffer_cache_entry_t, queue_node);\n\t}\n\t\n\tif ((u_char*)(cache->entries_end + 1) < cache->buffers_start)\n\t{\n\t\t// enlarge the entries buffer\n\t\tentry = cache->entries_end;\n\t\tcache->entries_end++;\n\n\t\t// initialize the state and add to free queue\n\t\tentry->state = CES_FREE;\n\t\tngx_queue_insert_tail(&cache->free_queue, &entry->queue_node);\n\t\treturn entry;\n\t}\n\t\n\treturn ngx_buffer_cache_free_oldest_entry(cache, 0);\n}\n\n/* Note: must be called with the mutex locked */\nstatic u_char*\nngx_buffer_cache_get_free_buffer(\n\tngx_buffer_cache_sh_t *cache,\n\tsize_t size)\n{\n\tu_char* buffer_start;\n\n\t// check whether it's possible to allocate the requested size\n\tif ((u_char*)(cache->entries_end + ENTRIES_ALLOC_MARGIN) + size + BUFFER_ALIGNMENT > cache->buffers_end)\n\t{\n\t\treturn NULL;\n\t}\n\n\tbuffer_start = (u_char*)((intptr_t)(cache->buffers_write - size) & (~(BUFFER_ALIGNMENT - 1)));\n\n\tfor (;;)\n\t{\n\t\t// Layout:\tS\tW/////R\t\tE\n\t\tif (cache->buffers_write < cache->buffers_read || \n\t\t\t(cache->buffers_write == cache->buffers_read && ngx_queue_empty(&cache->used_queue)))\n\t\t{\n\t\t\tif (buffer_start >= cache->buffers_start)\n\t\t\t{\n\t\t\t\t// have enough room here\n\t\t\t\treturn buffer_start;\n\t\t\t}\n\n\t\t\tif (buffer_start > (u_char*)(cache->entries_end + ENTRIES_ALLOC_MARGIN))\n\t\t\t{\n\t\t\t\t// enlarge the buffer\n\t\t\t\tcache->buffers_start = buffer_start;\n\t\t\t\treturn buffer_start;\n\t\t\t}\n\n\t\t\t// cannot allocate here, move the write position to the end\n\t\t\tcache->buffers_write = cache->buffers_end;\n\t\t\tbuffer_start = (u_char*)((intptr_t)(cache->buffers_write - size) & (~(BUFFER_ALIGNMENT - 1)));\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Layout:\tS////R\t\tW///E\n\t\tif (buffer_start > cache->buffers_read)\n\t\t{\n\t\t\t// have enough room here\n\t\t\treturn buffer_start;\n\t\t}\n\n\t\t// not enough room, free an entry\n\t\tif (ngx_buffer_cache_free_oldest_entry(cache, 0) == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nngx_flag_t\nngx_buffer_cache_fetch(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tngx_str_t* buffer,\n\tuint32_t* token)\n{\n\tngx_buffer_cache_entry_t* entry;\n\tngx_buffer_cache_sh_t *sh = cache->sh;\n\tngx_flag_t result = 0;\n\tuint32_t hash;\n\n\thash = ngx_crc32_short(key, BUFFER_CACHE_KEY_SIZE);\n\n\tngx_shmtx_lock(&cache->shpool->mutex);\n\n\tif (!sh->reset)\n\t{\n\t\tentry = ngx_buffer_cache_rbtree_lookup(&sh->rbtree, key, hash);\n\t\tif (entry != NULL && entry->state == CES_READY && \n\t\t\t(cache->expiration == 0 || ngx_time() < (time_t)(entry->write_time + cache->expiration)))\n\t\t{\n\t\t\tresult = 1;\n\n\t\t\t// update stats\n\t\t\tsh->stats.fetch_hit++;\n\t\t\tsh->stats.fetch_bytes += entry->buffer_size;\n\n\t\t\t// copy buffer pointer and size\n\t\t\tbuffer->data = entry->start_offset;\n\t\t\tbuffer->len = entry->buffer_size;\n\t\t\t*token = entry->write_time;\n\n\t\t\t// Note: setting the access time of the entry and cache to prevent it \n\t\t\t//\t\tfrom being freed while the caller uses the buffer\n\t\t\tsh->access_time = entry->access_time = ngx_time();\n\t\t\t(void)ngx_atomic_fetch_add(&entry->ref_count, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// update stats\n\t\t\tsh->stats.fetch_miss++;\n\t\t}\n\t}\n\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n\n\treturn result;\n}\n\nvoid\nngx_buffer_cache_release(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tuint32_t token)\n{\n\tngx_buffer_cache_entry_t* entry;\n\tngx_buffer_cache_sh_t *sh = cache->sh;\n\tuint32_t hash;\n\n\thash = ngx_crc32_short(key, BUFFER_CACHE_KEY_SIZE);\n\n\tngx_shmtx_lock(&cache->shpool->mutex);\n\n\tif (!sh->reset)\n\t{\n\t\tentry = ngx_buffer_cache_rbtree_lookup(&sh->rbtree, key, hash);\n\t\tif (entry != NULL && entry->state == CES_READY && (uint32_t)entry->write_time == token)\n\t\t{\n\t\t\t(void)ngx_atomic_fetch_add(&entry->ref_count, -1);\n\t\t}\n\t}\n\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n}\n\nngx_flag_t\nngx_buffer_cache_store_gather(\n\tngx_buffer_cache_t* cache, \n\tu_char* key, \n\tngx_str_t* buffers,\n\tsize_t buffer_count)\n{\n\tngx_buffer_cache_entry_t* entry;\n\tngx_buffer_cache_sh_t *sh = cache->sh;\n\tngx_str_t* cur_buffer;\n\tngx_str_t* last_buffer;\n\tsize_t buffer_size;\n\tuint32_t hash;\n\tuint32_t evictions;\n\tu_char* target_buffer;\n\n\thash = ngx_crc32_short(key, BUFFER_CACHE_KEY_SIZE);\n\n\tngx_shmtx_lock(&cache->shpool->mutex);\n\n\tif (sh->reset)\n\t{\n\t\t// a previous store operation was killed in progress, need to reset the cache\n\t\t// since the data structures may be corrupt. we can only reset the cache after\n\t\t// the access time expires since other processes may still be reading from / \n\t\t// writing to the cache\n\t\tif (ngx_time() < sh->access_time + CACHE_LOCK_EXPIRATION)\n\t\t{\n\t\t\tngx_shmtx_unlock(&cache->shpool->mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// reset the cache, leave the reset flag enabled\n\t\tngx_buffer_cache_reset(sh);\n\n\t\t// update stats\n\t\tsh->stats.reset++;\n\t}\n\telse\n\t{\n\t\t// remove expired entries\n\t\tif (cache->expiration)\n\t\t{\n\t\t\tfor (evictions = MAX_EVICTIONS_PER_STORE; evictions > 0; evictions--)\n\t\t\t{\n\t\t\t\tif (!ngx_buffer_cache_free_oldest_entry(sh, cache->expiration))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make sure the entry does not already exist\n\t\tentry = ngx_buffer_cache_rbtree_lookup(&sh->rbtree, key, hash);\n\t\tif (entry != NULL)\n\t\t{\n\t\t\tsh->stats.store_exists++;\n\t\t\tngx_shmtx_unlock(&cache->shpool->mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// enable the reset flag before we start making any changes\n\t\tsh->reset = 1;\n\t}\n\n\t// allocate a new entry\n\tentry = ngx_buffer_cache_get_free_entry(sh);\n\tif (entry == NULL)\n\t{\n\t\tgoto error;\n\t}\n\n\t// calculate the buffer size\n\tlast_buffer = buffers + buffer_count;\n\tbuffer_size = 0;\n\tfor (cur_buffer = buffers; cur_buffer < last_buffer; cur_buffer++)\n\t{\n\t\tbuffer_size += cur_buffer->len;\n\t}\n\n\t// allocate a buffer to hold the data\n\ttarget_buffer = ngx_buffer_cache_get_free_buffer(sh, buffer_size + 1);\n\tif (target_buffer == NULL)\n\t{\n\t\tgoto error;\n\t}\n\n\t// initialize the entry\n\tentry->state = CES_ALLOCATED;\n\tentry->ref_count = 1;\n\tentry->node.key = hash;\n\tmemcpy(entry->key, key, BUFFER_CACHE_KEY_SIZE);\n\tentry->start_offset = target_buffer;\n\tentry->buffer_size = buffer_size;\n\n\t// update the write position\n\tsh->buffers_write = target_buffer;\n\n\t// move from free_queue to used_queue\n\tngx_queue_remove(&entry->queue_node);\n\tngx_queue_insert_tail(&sh->used_queue, &entry->queue_node);\n\n\t// insert to rbtree\n\tngx_rbtree_insert(&sh->rbtree, &entry->node);\n\n\t// update stats\n\tsh->stats.store_ok++;\n\tsh->stats.store_bytes += buffer_size;\n\n\t// Note: the memcpy is performed after releasing the lock to avoid holding the lock for a long time\n\t//\t\tsetting the access time of the entry and cache prevents it from being freed\n\tsh->access_time = entry->access_time = ngx_time();\n\tentry->write_time = ngx_time();\n\n\tsh->reset = 0;\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n\n\tfor (cur_buffer = buffers; cur_buffer < last_buffer; cur_buffer++)\n\t{\n\t\ttarget_buffer = ngx_copy(target_buffer, cur_buffer->data, cur_buffer->len);\n\t}\n\t*target_buffer = '\\0';\n\n\t// Note: no need to obtain the lock since state is ngx_atomic_t\n\tentry->state = CES_READY;\n\t(void)ngx_atomic_fetch_add(&entry->ref_count, -1);\n\n\treturn 1;\n\nerror:\n\tsh->stats.store_err++;\n\tsh->reset = 0;\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n\treturn 0;\n}\n\nngx_flag_t\nngx_buffer_cache_store(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tu_char* source_buffer,\n\tsize_t buffer_size)\n{\n\tngx_str_t buffer;\n\n\tbuffer.data = source_buffer;\n\tbuffer.len = buffer_size;\n\n\treturn ngx_buffer_cache_store_gather(cache, key, &buffer, 1);\n}\n\nvoid\nngx_buffer_cache_get_stats(\n\tngx_buffer_cache_t* cache,\n\tngx_buffer_cache_stats_t* stats)\n{\n\tngx_buffer_cache_sh_t *sh = cache->sh;\n\n\tngx_shmtx_lock(&cache->shpool->mutex);\n\n\tmemcpy(stats, &sh->stats, sizeof(sh->stats));\n\n\tstats->entries = sh->entries_end - sh->entries_start;\n\tstats->data_size = sh->buffers_end - sh->buffers_start;\n\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n}\n\nvoid\nngx_buffer_cache_reset_stats(ngx_buffer_cache_t* cache)\n{\n\tngx_shmtx_lock(&cache->shpool->mutex);\n\n\tngx_memzero(&cache->sh->stats, sizeof(cache->sh->stats));\n\n\tngx_shmtx_unlock(&cache->shpool->mutex);\n}\n\nngx_buffer_cache_t*\nngx_buffer_cache_create(ngx_conf_t *cf, ngx_str_t *name, size_t size, time_t expiration, void *tag)\n{\n\tngx_buffer_cache_t* cache;\n\n\tcache = ngx_pcalloc(cf->pool, sizeof(ngx_buffer_cache_t));\n\tif (cache == NULL) \n\t{\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tcache->expiration = expiration;\n\n\tcache->shm_zone = ngx_shared_memory_add(cf, name, size, tag);\n\tif (cache->shm_zone == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tif (cache->shm_zone->data) \n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"duplicate zone \\\"%V\\\"\", name);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tcache->shm_zone->init = ngx_buffer_cache_init;\n\tcache->shm_zone->data = cache;\n\n\treturn cache;\n}\n"
        },
        {
          "name": "ngx_buffer_cache.h",
          "type": "blob",
          "size": 1.421875,
          "content": "#ifndef _NGX_BUFFER_CACHE_H_INCLUDED_\n#define _NGX_BUFFER_CACHE_H_INCLUDED_\n\n// includes\n#include <ngx_core.h>\n\n// constants\n#define BUFFER_CACHE_KEY_SIZE (16)\n\n// typedefs\nstruct ngx_buffer_cache_s;\ntypedef struct ngx_buffer_cache_s ngx_buffer_cache_t;\n\ntypedef struct {\n\tngx_atomic_t store_ok;\n\tngx_atomic_t store_bytes;\n\tngx_atomic_t store_err;\n\tngx_atomic_t store_exists;\n\tngx_atomic_t fetch_hit;\n\tngx_atomic_t fetch_bytes;\n\tngx_atomic_t fetch_miss;\n\tngx_atomic_t evicted;\n\tngx_atomic_t evicted_bytes;\n\tngx_atomic_t reset;\n\n\t// updated only when the stats are fetched\n\tngx_atomic_t entries;\n\tngx_atomic_t data_size;\n} ngx_buffer_cache_stats_t;\n\n// functions\nngx_flag_t ngx_buffer_cache_fetch(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tngx_str_t* buffer,\n\tuint32_t* token);\n\nvoid ngx_buffer_cache_release(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tuint32_t token);\n\nngx_flag_t ngx_buffer_cache_store(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tu_char* source_buffer,\n\tsize_t buffer_size);\n\nngx_flag_t ngx_buffer_cache_store_gather(\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tngx_str_t* buffers,\n\tsize_t buffer_count);\n\nvoid ngx_buffer_cache_get_stats(\n\tngx_buffer_cache_t* cache,\n\tngx_buffer_cache_stats_t* stats);\n\nvoid ngx_buffer_cache_reset_stats(ngx_buffer_cache_t* cache);\n\nngx_buffer_cache_t* ngx_buffer_cache_create(\n\tngx_conf_t *cf, \n\tngx_str_t *name, \n\tsize_t size, \n\ttime_t expiration, \n\tvoid *tag);\n\n#endif // _NGX_BUFFER_CACHE_H_INCLUDED_\n"
        },
        {
          "name": "ngx_buffer_cache_internal.h",
          "type": "blob",
          "size": 1.4248046875,
          "content": "#ifndef _NGX_BUFFER_CACHE_INTERNAL_H_INCLUDED_\n#define _NGX_BUFFER_CACHE_INTERNAL_H_INCLUDED_\n\n#include \"ngx_buffer_cache.h\"\n#include \"ngx_queue.h\"\n\n// macros\n#define container_of(ptr, type, member) (type *)((char *)(ptr) - offsetof(type, member))\n\n// constants\n#define CACHE_LOCK_EXPIRATION (5)\n#define ENTRY_LOCK_EXPIRATION (5)\n#define ENTRIES_ALLOC_MARGIN (1024)\t\t// 1K entries ~= 100KB, we reserve this space to make sure allocating entries does not become the bottleneck\n#define BUFFER_ALIGNMENT (16)\n#define MAX_EVICTIONS_PER_STORE (128)\n\n// enums\nenum {\n\tCES_FREE,\n\tCES_ALLOCATED,\n\tCES_READY,\n};\n\n// typedefs\ntypedef struct {\n\tngx_rbtree_node_t node;\n\tngx_queue_t queue_node;\n\tu_char* start_offset;\n\tsize_t buffer_size;\n\tngx_atomic_t state;\n\tngx_atomic_t ref_count;\n\ttime_t access_time;\n\ttime_t write_time;\n\tu_char key[BUFFER_CACHE_KEY_SIZE];\n} ngx_buffer_cache_entry_t;\n\ntypedef struct {\n\tngx_atomic_t reset;\n\ttime_t access_time;\n\tngx_rbtree_t rbtree;\n\tngx_rbtree_node_t sentinel;\n\tngx_queue_t used_queue;\n\tngx_queue_t free_queue;\n\tngx_buffer_cache_entry_t* entries_start;\n\tngx_buffer_cache_entry_t* entries_end;\n\tu_char* buffers_start;\n\tu_char* buffers_end;\n\tu_char* buffers_read;\n\tu_char* buffers_write;\n\tngx_buffer_cache_stats_t stats;\n} ngx_buffer_cache_sh_t;\n\nstruct ngx_buffer_cache_s {\n\tngx_buffer_cache_sh_t *sh;\n\tngx_slab_pool_t *shpool;\n\n\tuint32_t expiration;\n\n\tngx_shm_zone_t *shm_zone;\n};\n\n#endif // _NGX_BUFFER_CACHE_INTERNAL_H_INCLUDED_\n"
        },
        {
          "name": "ngx_child_http_request.c",
          "type": "blob",
          "size": 19.35546875,
          "content": "#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include <nginx.h>\n#include <ngx_event.h>\n\n#include \"ngx_child_http_request.h\"\n#include \"ngx_http_vod_module.h\"\n\n// constants\n#define RANGE_FORMAT \"bytes=%O-%O\"\n\n// macros\n#define is_in_memory(ctx) (ctx->response_buffer != NULL)\n\n// typedefs\ntypedef struct {\n\n\t// fixed\n\tngx_child_request_callback_t callback;\n\tvoid* callback_context;\n\n\t// deferred init\n\tngx_buf_t* response_buffer;\n#if defined(nginx_version) && nginx_version >= 1013010\n\tngx_chain_t* response_chain;\n#endif\n\tngx_list_t upstream_headers;\n\n\t// temporary completion state\n\tngx_http_request_t* sr;\n\tngx_int_t error_code;\n\tngx_http_event_handler_pt original_write_event_handler;\n\tvoid *original_context;\n\n\t// misc\n\tngx_flag_t dont_send_header;\n\tngx_int_t send_header_result;\n\n} ngx_child_request_context_t;\n\ntypedef struct {\n\tngx_str_t name;\n\toff_t offset;\n} ngx_child_request_hide_header_t;\n\n// constants\nstatic ngx_str_t ngx_http_vod_head_method = { 4, (u_char *) \"HEAD \" };\n\nstatic ngx_str_t range_key = ngx_string(\"Range\");\nstatic u_char* range_lowcase_key = (u_char*)\"range\";\nstatic ngx_uint_t range_hash =\n\tngx_hash(ngx_hash(ngx_hash(ngx_hash('r', 'a'), 'n'), 'g'), 'e');\n\nstatic ngx_child_request_hide_header_t hide_headers[] = {\n\t{ ngx_string(\"Accept\"), \n#if (NGX_HTTP_HEADERS)\t\n\t\toffsetof(ngx_http_headers_in_t, accept)\n#else\n\t\t-1\n#endif\n\t},\n\t{ ngx_string(\"Accept-Charset\"), -1 },\n\t{ ngx_string(\"Accept-Datetime\"), -1 },\n\t{ ngx_string(\"Accept-Encoding\"), \n#if (NGX_HTTP_GZIP)\n\t\toffsetof(ngx_http_headers_in_t, accept_encoding)\n#else\n\t\t-1\n#endif\n\t},\n\t{ ngx_string(\"Accept-Language\"), \n#if (NGX_HTTP_HEADERS)\t\n\t\toffsetof(ngx_http_headers_in_t, accept_language)\n#else\n\t\t-1\n#endif\n\t},\n\t{ ngx_string(\"If-Match\"), offsetof(ngx_http_headers_in_t, if_match) },\n\t{ ngx_string(\"If-Modified-Since\"), offsetof(ngx_http_headers_in_t, if_modified_since) },\n\t{ ngx_string(\"If-None-Match\"), offsetof(ngx_http_headers_in_t, if_none_match) },\n\t{ ngx_string(\"If-Range\"), offsetof(ngx_http_headers_in_t, if_range) },\n\t{ ngx_string(\"If-Unmodified-Since\"), offsetof(ngx_http_headers_in_t, if_unmodified_since) },\n\t{ ngx_null_string, -1 },\n};\n\n// globals\nstatic ngx_http_output_header_filter_pt ngx_http_next_header_filter;\nstatic ngx_hash_t hide_headers_hash;\n\nstatic void\nngx_child_request_wev_handler(ngx_http_request_t *r)\n{\n\tngx_child_request_context_t* ctx;\n\tngx_http_upstream_t *u;\n\tngx_http_request_t* sr;\n\tngx_buf_t* b;\n\tngx_int_t rc;\n\toff_t content_length;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\t// restore the write event handler\n\tr->write_event_handler = ctx->original_write_event_handler;\n\tctx->original_write_event_handler = NULL;\n\n\t// restore the original context\n\tngx_http_set_ctx(r, ctx->original_context, ngx_http_vod_module);\n\n\t// get the completed upstream\n\tsr = ctx->sr;\n\tctx->sr = NULL;\n\n\tif (sr == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_child_request_wev_handler: unexpected, subrequest is null\");\n\t\treturn;\n\t}\n\n\tu = sr->upstream;\n\n#if defined(nginx_version) && nginx_version >= 1013010\n\tif (is_in_memory(ctx))\n\t{\n\t\tif (sr->out == NULL || sr->out->buf == NULL)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_child_request_wev_handler: unexpected, output buffer is null\");\n\t\t\treturn;\n\t\t}\n\n\t\tb = sr->out->buf;\n\t}\n\telse\n\t{\n\t\tb = NULL;\n\t}\n#else\n\tif (u == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_child_request_wev_handler: unexpected, upstream is null\");\n\t\treturn;\n\t}\n\n\tb = &u->buffer;\n#endif\n\n\t// code taken from echo-nginx-module to work around nginx subrequest issues\n\tif (r == r->connection->data && r->postponed) {\n\n\t\tif (r->postponed->request) {\n\t\t\tr->connection->data = r->postponed->request;\n\n#if defined(nginx_version) && nginx_version >= 8012\n\t\t\tngx_http_post_request(r->postponed->request, NULL);\n#else\n\t\t\tngx_http_post_request(r->postponed->request);\n#endif\n\n\t\t}\n\t\telse {\n\t\t\tngx_http_output_filter(r, NULL);\n\t\t}\n\t}\n\n\t// get the final error code\n\trc = ctx->error_code;\n\tif (rc == NGX_OK && is_in_memory(ctx) && u != NULL)\n\t{\n\t\tswitch (u->headers_in.status_n)\n\t\t{\n\t\tcase NGX_HTTP_OK:\n\t\tcase NGX_HTTP_PARTIAL_CONTENT:\n\t\t\tif (u->headers_in.content_length_n > 0 && u->headers_in.content_length_n != b->last - b->pos)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_child_request_wev_handler: upstream connection was closed with %O bytes left to read\", \n\t\t\t\t\tu->headers_in.content_length_n - (b->last - b->pos));\n\t\t\t\trc = NGX_HTTP_BAD_GATEWAY;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NGX_HTTP_RANGE_NOT_SATISFIABLE:\n\t\t\t// ignore this error, treat it like a successful read with empty body\n\t\t\trc = NGX_OK;\n\t\t\tb->last = b->pos;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (u->headers_in.status_n != 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_child_request_wev_handler: upstream returned a bad status %ui\", u->headers_in.status_n);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_child_request_wev_handler: failed to get upstream status\");\n\t\t\t}\n\t\t\trc = NGX_HTTP_BAD_GATEWAY;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (rc == NGX_ERROR)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_child_request_wev_handler: got error -1, changing to 502\");\n\t\trc = NGX_HTTP_BAD_GATEWAY;\n\t}\n\n\tif (ctx->send_header_result == NGX_ERROR || ctx->send_header_result > NGX_OK)\n\t{\n\t\trc = ctx->send_header_result;\n\t}\n\n\t// get the content length\n\tif (is_in_memory(ctx))\n\t{\n\t\tcontent_length = b->last - b->pos;\n\t}\n\telse if (u != NULL && u->state != NULL)\n\t{\n\t\tcontent_length = u->state->response_length;\n\t}\n\telse\n\t{\n\t\tcontent_length = 0;\n\t}\n\n\tif (ctx->callback != NULL)\n\t{\n\t\t// notify the caller\n\t\tctx->callback(ctx->callback_context, rc, b, content_length);\n\t}\n\telse\n\t{\n\t\tif (r->header_sent || ctx->dont_send_header)\n\t\t{\n\t\t\t// flush the buffer and close the request\n\t\t\tngx_http_send_special(r, NGX_HTTP_LAST);\n\t\t\tngx_http_finalize_request(r, NGX_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// finalize the request\n\t\t\tngx_http_finalize_request(r, rc);\n\t\t}\n\t}\n}\n\nstatic ngx_int_t\nngx_child_request_finished_handler(\n\tngx_http_request_t *r, \n\tvoid *data, \n\tngx_int_t rc)\n{\n\tngx_http_request_t          *pr;\n\tngx_child_request_context_t* ctx;\n\n\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\"ngx_child_request_finished_handler: error code %i\", rc);\n\n\t// make sure we are not called twice for the same request\n\tr->post_subrequest = NULL;\n\n\t// save the completed upstream and error code in the context for the write event handler\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_child_request_finished_handler: unexpected, context is null\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tctx->sr = r;\n\tctx->error_code = rc;\n\n\tif (ctx->original_write_event_handler != NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_child_request_finished_handler: \"\n\t\t\t\"unexpected original_write_event_handler not null\");\n\t\treturn NGX_ERROR;\n\t}\n\n\t// replace the parent write event handler\n\tpr = r->parent;\n\n\tctx->original_write_event_handler = pr->write_event_handler;\n\tpr->write_event_handler = ngx_child_request_wev_handler;\n\n\t// temporarily replace the parent context\n\tctx->original_context = ngx_http_get_module_ctx(pr, ngx_http_vod_module);\n\tngx_http_set_ctx(pr, ctx, ngx_http_vod_module);\n\n\t// work-around issues in nginx's event module (from echo-nginx-module)\n\tif (r != r->connection->data\n\t\t&& r->postponed\n\t\t&& (r->main->posted_requests == NULL\n\t\t|| r->main->posted_requests->request != pr))\n\t{\n#if defined(nginx_version) && nginx_version >= 8012\n\t\tngx_http_post_request(pr, NULL);\n#else\n\t\tngx_http_post_request(pr);\n#endif\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic void\nngx_child_request_initial_wev_handler(ngx_http_request_t *r)\n{\n\tngx_child_request_context_t* ctx;\n\tngx_http_upstream_t* u;\n\tngx_connection_t    *c;\n\n\tc = r->connection;\n\n\t// call the default request handler\n\tr->write_event_handler = ngx_http_handler;\n\tngx_http_handler(r);\n\n\t// if request was destroyed ignore\n\tif (c->destroyed)\n\t{\n\t\treturn;\n\t}\n\n\t// at this point the upstream should have been allocated by the proxy module\n\tu = r->upstream;\n\tif (u == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n\t\t\t\"ngx_child_request_initial_wev_handler: upstream is null\");\n\t\treturn;\n\t}\n\n\t// if the upstream module already started receiving, don't touch the buffer\n\tif (u->buffer.start != NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n\t\t\t\"ngx_child_request_initial_wev_handler: upstream buffer was already allocated\");\n\t\treturn;\n\t}\n\n\t// initialize the upstream buffer\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n\t\t\t\"ngx_child_request_initial_wev_handler: context is null\");\n\t\treturn;\n\t}\n\n#if defined(nginx_version) && nginx_version >= 1013010\n\tr->out = ctx->response_chain;\n#else\n\tu->buffer = *ctx->response_buffer;\n#endif\n\n\t// initialize the headers list\n\tu->headers_in.headers = ctx->upstream_headers;\n\tu->headers_in.headers.last = &u->headers_in.headers.part;\n}\n\n#if !defined(nginx_version) || nginx_version < 1023000\nstatic void\nngx_child_request_update_multi_header(\n\tngx_array_t* arr, \n\tngx_table_elt_t* cur_value, \n\tngx_table_elt_t* new_value)\n{\n\tngx_table_elt_t** cur = arr->elts;\n\tngx_table_elt_t** last = cur + arr->nelts;\n\n\tfor (; cur < last; cur++)\n\t{\n\t\tif (*cur != cur_value)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t*cur = new_value;\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic ngx_int_t\nngx_child_request_copy_headers(\n\tngx_http_request_t* r,\n\tngx_child_request_params_t* params,\n\tngx_http_headers_in_t* dest,\n\tngx_http_headers_in_t* src)\n{\n\tngx_child_request_hide_header_t *hide_header;\n\tngx_http_core_main_conf_t  *cmcf;\n\tngx_list_part_t *part;\n\tngx_table_elt_t *output;\n\tngx_table_elt_t *ch;\n\tngx_table_elt_t *h;\n\tngx_uint_t i = 0;\n\tngx_http_header_t *hh;\n\tngx_table_elt_t  **ph;\n\tngx_uint_t count;\n\tngx_int_t rc;\n\n\t// get the total header count\n\tcount = 0;\n\tfor (part = &src->headers.part; part; part = part->next)\n\t{\n\t\tcount += part->nelts;\n\t}\n\n\t// allocate dest array\n\trc = ngx_list_init(&dest->headers, r->pool, count + 2, sizeof(ngx_table_elt_t));\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_child_request_copy_headers: ngx_list_init failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n#if defined(nginx_version) && nginx_version >= 1023000\n\t// zero all named header fields\n\tfor (hh = ngx_http_headers_in; hh->name.len; hh++) {\n\t\tph = (ngx_table_elt_t **)((char *)dest + hh->offset);\n\t\t*ph = NULL;\n\t}\n#endif\n\n\toutput = dest->headers.last->elts;\n\n\t// copy relevant headers\n\tcmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\tpart = &src->headers.part;\n\th = part->elts;\n\n\tfor (i = 0; /* void */; i++)\n\t{\n\t\tif (i >= part->nelts)\n\t\t{\n\t\t\tif (part->next == NULL)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpart = part->next;\n\t\t\th = part->elts;\n\t\t\ti = 0;\n\t\t}\n\n\t\tch = h + i;\n\n\t\t// remove range if needed\n\t\tif (ch->hash == range_hash && !params->proxy_range && params->range_start >= params->range_end &&\n\t\t\tch->key.len == range_key.len &&\n\t\t\tngx_memcmp(ch->lowcase_key, range_lowcase_key, range_key.len) == 0)\n\t\t{\n\t\t\tdest->range = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (!params->proxy_all_headers)\n\t\t{\n\t\t\t// remove headers from the hide list\n\t\t\thide_header = ngx_hash_find(&hide_headers_hash, ch->hash, ch->lowcase_key, ch->key.len);\n\t\t\tif (hide_header != NULL)\n\t\t\t{\n\t\t\t\tif (hide_header->offset >= 0)\n\t\t\t\t{\n\t\t\t\t\t*(ngx_table_elt_t**)((u_char*)dest + hide_header->offset) = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// add the header to the output list\n\t\t*output = *ch;\n\n\t\t// update the header pointer, if exists\n\t\thh = ngx_hash_find(&cmcf->headers_in_hash, ch->hash,\n\t\t\tch->lowcase_key, ch->key.len);\n\t\tif (hh)\n\t\t{\n#if defined(nginx_version) && nginx_version >= 1023000\n\t\t\tph = (ngx_table_elt_t **)((char *)dest + hh->offset);\n\n\t\t\toutput->next = *ph;\n\t\t\t*ph = output;\n#else\n\t\t\tif ((ch->key.len == sizeof(\"cookie\") - 1 &&\n\t\t\t\tngx_memcmp(ch->lowcase_key, \"cookie\", sizeof(\"cookie\") - 1) == 0) ||\n\t\t\t\t(ch->key.len == sizeof(\"x-forwarded-for\") - 1 &&\n\t\t\t\tngx_memcmp(ch->lowcase_key, \"x-forwarded-for\", sizeof(\"x-forwarded-for\") - 1) == 0))\n\t\t\t{\n\t\t\t\t// multi header\n\t\t\t\tngx_child_request_update_multi_header(\n\t\t\t\t\t(ngx_array_t*)((char *)dest + hh->offset),\n\t\t\t\t\tch,\n\t\t\t\t\toutput);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// single header\n\t\t\t\tph = (ngx_table_elt_t **)((char *)dest + hh->offset);\n\n\t\t\t\t*ph = output;\n\t\t\t}\n#endif\n\t\t}\n\n\t\toutput++;\n\t}\n\n\t// add the extra header if needed\n\tif (params->extra_header.key.len != 0)\n\t{\n\t\t*output++ = params->extra_header;\n\t}\n\n\t// set the range if needed\n\tif (params->range_start < params->range_end)\n\t{\n\t\tif (dest->range == NULL)\n\t\t{\n\t\t\th = output++;\n\t\t\th->hash = range_hash;\n#if defined(nginx_version) && nginx_version >= 1023000\n\t\t\th->next = NULL;\n#endif\n\t\t\th->key = range_key;\n\t\t\th->lowcase_key = range_lowcase_key;\n\t\t\tdest->range = h;\n\t\t}\n\t\telse\n\t\t{\n\t\t\th = dest->range;\n\t\t}\n\n\t\th->value.data = ngx_pnalloc(r->pool, sizeof(RANGE_FORMAT) + 2 * NGX_OFF_T_LEN);\n\t\tif (h->value.data == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_child_request_copy_headers: ngx_pnalloc failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\th->value.len = ngx_sprintf(\n\t\t\th->value.data,\n\t\t\tRANGE_FORMAT,\n\t\t\tparams->range_start,\n\t\t\tparams->range_end - 1) - h->value.data;\n\t\th->value.data[h->value.len] = '\\0';\n\t}\n\n\t// update the element count\n\tdest->headers.last->nelts = output - (ngx_table_elt_t*)dest->headers.last->elts;\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_child_request_start(\n\tngx_http_request_t *r,\n\tngx_child_request_callback_t callback,\n\tvoid* callback_context,\n\tngx_str_t* internal_location,\n\tngx_child_request_params_t* params,\n\tngx_buf_t* response_buffer)\n{\n\tngx_child_request_context_t* child_ctx;\n\tngx_http_post_subrequest_t *psr;\n\tngx_http_request_t *sr;\n\tngx_uint_t flags;\n\tngx_str_t uri;\n\tngx_int_t rc;\n\tu_char* p;\n\n\t// create the child context\n\tchild_ctx = ngx_pcalloc(r->pool, sizeof(*child_ctx));\n\tif (child_ctx == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_child_request_start: ngx_pcalloc failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tchild_ctx->callback = callback;\n\tchild_ctx->callback_context = callback_context;\n\tchild_ctx->response_buffer = response_buffer;\n\n#if defined(nginx_version) && nginx_version >= 1013010\n\tif (response_buffer != NULL)\n\t{\n\t\tchild_ctx->response_chain = ngx_alloc_chain_link(r->pool);\n\t\tif (child_ctx->response_chain == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_child_request_start: ngx_alloc_chain_link failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tchild_ctx->response_chain->buf = response_buffer;\n\t}\n#endif\n\n\t// build the subrequest uri\n\turi.data = ngx_pnalloc(r->pool, internal_location->len + params->base_uri.len + 1);\n\tif (uri.data == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_child_request_start: ngx_palloc failed (2)\");\n\t\treturn NGX_ERROR;\n\t}\n\tp = ngx_copy(uri.data, internal_location->data, internal_location->len);\n\tp = ngx_copy(p, params->base_uri.data, params->base_uri.len);\n\t*p = '\\0';\n\turi.len = p - uri.data;\n\n\t// create the subrequest\n\tpsr = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t));\n\tif (psr == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_child_request_start: ngx_palloc failed (3)\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tpsr->handler = ngx_child_request_finished_handler;\n\tpsr->data = r;\n\n\tif (is_in_memory(child_ctx))\n\t{\n\t\tif (ngx_list_init(&child_ctx->upstream_headers, r->pool, 8,\n\t\t\tsizeof(ngx_table_elt_t)) != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_child_request_start: ngx_list_init failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tflags = NGX_HTTP_SUBREQUEST_WAITED | NGX_HTTP_SUBREQUEST_IN_MEMORY;\n\t}\n\telse\n\t{\n\t\tflags = NGX_HTTP_SUBREQUEST_WAITED;\n\t}\n\n\trc = ngx_http_subrequest(r, &uri, &params->extra_args, &sr, psr, flags);\n\tif (rc == NGX_ERROR)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_child_request_start: ngx_http_subrequest failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\t// set the context of the subrequest\n\tngx_http_set_ctx(sr, child_ctx, ngx_http_vod_module);\n\n\t// change the write_event_handler in order to inject the response buffer into the upstream \n\t//\t(this can be done only after the proxy module allocates the upstream)\n\tif (is_in_memory(child_ctx))\n\t{\n\t\tsr->write_event_handler = ngx_child_request_initial_wev_handler;\n\t}\n\n\t// Note: ngx_http_subrequest always sets the subrequest method to GET\n\tif (params->method == NGX_HTTP_HEAD)\n\t{\n\t\tsr->method = NGX_HTTP_HEAD;\n\t\tsr->method_name = ngx_http_vod_head_method;\n\t}\n\t\n\t// build the request headers\n\trc = ngx_child_request_copy_headers(r, params, &sr->headers_in, &r->headers_in);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\"ngx_child_request_start: completed successfully sr=%p\", sr);\n\n\treturn NGX_AGAIN;\n}\n\nstatic ngx_int_t\nngx_child_request_header_filter(ngx_http_request_t *r)\n{\n\tngx_child_request_context_t* ctx;\n\tngx_http_request_t* pr = r->parent;\n\n\t// if the request is not a child of a vod request, ignore\n\tif (pr == NULL || pr->header_sent || ngx_http_get_module_ctx(pr, ngx_http_vod_module) == NULL)\n\t{\n\t\treturn ngx_http_next_header_filter(r);\n\t}\n\n\t// if the request is not a vod request or it's in memory, ignore\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\treturn ngx_http_next_header_filter(r);\n\t}\n\n\tif (is_in_memory(ctx))\n\t{\n\t\t// check the returned content length, this is required only for nginx 1.13.10+\n\t\t// in older versions, the validation will be performed by the upstream module\n\t\tif (r->upstream != NULL &&\n\t\t\tr->upstream->headers_in.content_length_n > ctx->response_buffer->end - ctx->response_buffer->last)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n\t\t\t\t\"ngx_child_request_header_filter: upstream buffer is too small to read response\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\treturn ngx_http_next_header_filter(r);\n\t}\n\n\tif (r->headers_out.status != 0)\n\t{\n\t\t// send the parent request headers\n\t\tpr->headers_out = r->headers_out;\n\t\tif (r->headers_out.headers.last == &r->headers_out.headers.part)\n\t\t{\n\t\t\tpr->headers_out.headers.last = &pr->headers_out.headers.part;\n\t\t}\n\t\tctx->send_header_result = ngx_http_send_header(pr);\n\t}\n\telse\n\t{\n\t\t// no status code, this can happen in case the proxy module got an invalid status line\n\t\t//\tand assumed it's HTTP/0.9, just don't send any header and close the connection when done\n\t\tctx->dont_send_header = 1;\n\t\tpr->keepalive = 0;\n\t}\n\n\treturn ngx_http_next_header_filter(r);\n}\n\nngx_int_t\nngx_child_request_init(ngx_conf_t *cf)\n{\n\tngx_child_request_hide_header_t *h;\n\tngx_array_t hide_headers_arr;\n\tngx_hash_key_t  *hk;\n\tngx_hash_init_t hash;\n\n\t// Note: need to install a header filter in order to support dumping requests -\n\t//\tthe headers of the parent request need to be sent before any body data is written\n\tngx_http_next_header_filter = ngx_http_top_header_filter;\n\tngx_http_top_header_filter = ngx_child_request_header_filter;\n\n\t// initialize hide_headers_hash\n\tif (ngx_array_init(\n\t\t&hide_headers_arr,\n\t\tcf->temp_pool, \n\t\tsizeof(hide_headers) / sizeof(hide_headers[0]), \n\t\tsizeof(ngx_hash_key_t)) != NGX_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\tfor (h = hide_headers; h->name.len; h++)\n\t{\n\t\thk = ngx_array_push(&hide_headers_arr);\n\t\tif (hk == NULL) \n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\thk->key = h->name;\n\t\thk->key_hash = ngx_hash_key_lc(h->name.data, h->name.len);\n\t\thk->value = h;\n\t}\n\n\thash.max_size = 512;\n\thash.bucket_size = ngx_align(64, ngx_cacheline_size);\n\thash.name = \"vod_hide_headers_hash\";\n\n\thash.hash = &hide_headers_hash;\n\thash.key = ngx_hash_key_lc;\n\thash.pool = cf->pool;\n\thash.temp_pool = NULL;\n\n\tif (ngx_hash_init(&hash, hide_headers_arr.elts, hide_headers_arr.nelts) != NGX_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n"
        },
        {
          "name": "ngx_child_http_request.h",
          "type": "blob",
          "size": 1.2080078125,
          "content": "#ifndef _NGX_CHILD_HTTP_REQUEST_INCLUDED_\n#define _NGX_CHILD_HTTP_REQUEST_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n\n// typedefs\ntypedef void(*ngx_child_request_callback_t)(void* context, ngx_int_t rc, ngx_buf_t* buf, ssize_t bytes_read);\n\ntypedef struct {\n\tngx_uint_t method;\n\tngx_str_t base_uri;\n\tngx_str_t extra_args;\n\toff_t range_start;\n\toff_t range_end;\n\tngx_table_elt_t extra_header;\n\tngx_flag_t proxy_range;\n\tngx_flag_t proxy_all_headers;\n} ngx_child_request_params_t;\n\n// functions\n\n// Notes:\n//\t1. callback is optional, if it is not supplied, the module will finalize the request\n//\t\twhen the upstream request completes.\n//\t2. response_buffer is optional, if it is not supplied, the upstream response gets written\n//\t\tto the parent request. when a response buffer is supplied, the response is written to it, \n//\t\tthe buffer should be large enough to contain both the response body and the response headers.\nngx_int_t ngx_child_request_start(\n\tngx_http_request_t *r,\n\tngx_child_request_callback_t callback,\n\tvoid* callback_context,\n\tngx_str_t* internal_location,\n\tngx_child_request_params_t* params,\n\tngx_buf_t* response_buffer);\n\nngx_int_t ngx_child_request_init(ngx_conf_t *cf);\n\n#endif // _NGX_CHILD_HTTP_REQUEST_INCLUDED_\n"
        },
        {
          "name": "ngx_file_reader.c",
          "type": "blob",
          "size": 10.1943359375,
          "content": "#include \"ngx_file_reader.h\"\n#include <ngx_event.h>\n\nstatic ngx_int_t\nngx_file_reader_init_open_file_info(\n\tngx_open_file_info_t* of, \n\tngx_http_request_t *r,\n\tngx_http_core_loc_conf_t *clcf, \n\tngx_str_t* path)\n{\n\tngx_int_t rc;\n\n\tngx_memzero(of, sizeof(ngx_open_file_info_t));\n\n\tof->read_ahead = clcf->read_ahead;\n\tof->directio = NGX_MAX_OFF_T_VALUE;\n\tof->valid = clcf->open_file_cache_valid;\n\tof->min_uses = clcf->open_file_cache_min_uses;\n\tof->errors = clcf->open_file_cache_errors;\n\tof->events = clcf->open_file_cache_events;\n\n\trc = ngx_http_set_disable_symlinks(r, clcf, path, of);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_file_reader_init_open_file_info: ngx_http_set_disable_symlinks failed %i\", rc);\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn rc;\n}\n\nstatic ngx_int_t\nngx_file_reader_update_state_file_info(ngx_file_reader_state_t* state, ngx_open_file_info_t* of, ngx_int_t rc)\n{\n\tngx_uint_t level;\n\n\tif (rc != NGX_OK)\n\t{\n\t\tswitch (of->err)\n\t\t{\n\t\tcase 0:\n\t\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\n\t\tcase NGX_ENOENT:\n\t\tcase NGX_ENOTDIR:\n\t\tcase NGX_ENAMETOOLONG:\n\n\t\t\tlevel = NGX_LOG_ERR;\n\t\t\trc = NGX_HTTP_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tcase NGX_EACCES:\n#if (NGX_HAVE_OPENAT)\n\t\tcase NGX_EMLINK:\n\t\tcase NGX_ELOOP:\n#endif // NGX_HAVE_OPENAT\n\n\t\t\tlevel = NGX_LOG_ERR;\n\t\t\trc = NGX_HTTP_FORBIDDEN;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tlevel = NGX_LOG_CRIT;\n\t\t\trc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc != NGX_HTTP_NOT_FOUND || state->log_not_found)\n\t\t{\n\t\t\tngx_log_error(level, state->log, of->err, \"ngx_file_reader_update_state_file_info: %s \\\"%s\\\" failed\", of->failed, state->file.name.data);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tif (!of->is_file)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, state->log, 0, \"ngx_file_reader_update_state_file_info: \\\"%s\\\" is not a file\", state->file.name.data);\n\t\tif (of->fd != NGX_INVALID_FILE)\n\t\t{\n\t\t\tif (ngx_close_file(of->fd) == NGX_FILE_ERROR)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ALERT, state->log, ngx_errno, \"ngx_file_reader_update_state_file_info: \" ngx_close_file_n \" \\\"%s\\\" failed\", state->file.name.data);\n\t\t\t}\n\t\t}\n\n\t\treturn NGX_HTTP_FORBIDDEN;\n\t}\n\n\tstate->file.fd = of->fd;\n\tstate->file_size = of->size;\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_file_reader_init(\n\tngx_file_reader_state_t* state,\n\tngx_async_read_callback_t read_callback,\n\tvoid* callback_context,\n\tngx_http_request_t *r,\n\tngx_http_core_loc_conf_t *clcf,\n\tngx_str_t* path,\n\tuint32_t flags)\n{\n\tngx_open_file_info_t of;\n\tngx_int_t rc;\n\n\tstate->r = r;\n\tstate->file.name = *path;\n\tstate->file.log = r->connection->log;\n\tstate->directio = clcf->directio;\n\tstate->log_not_found = clcf->log_not_found;\n\tstate->log = r->connection->log;\n#if (NGX_HAVE_FILE_AIO)\n\tstate->use_aio = clcf->aio;\n\tstate->read_callback = read_callback;\n\tstate->callback_context = callback_context;\n#endif // NGX_HAVE_FILE_AIO\n\n\trc = ngx_file_reader_init_open_file_info(&of, r, clcf, path);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\trc = ngx_open_cached_file(\n\t\t(flags & OPEN_FILE_NO_CACHE) != 0 ? NULL : clcf->open_file_cache, \n\t\tpath, \n\t\t&of, \n\t\tr->pool);\n\n\treturn ngx_file_reader_update_state_file_info(state, &of, rc);\n}\n\n#if (NGX_THREADS)\n\ntypedef struct {\n\tngx_file_reader_state_t* state;\n\tngx_open_file_info_t of;\n\tngx_async_open_file_callback_t open_callback;\n\tvoid* callback_context;\n\tngx_thread_task_t *task;\n} ngx_file_reader_async_open_context_t;\n\nstatic void\nngx_file_reader_async_open_callback(void* ctx, ngx_int_t rc)\n{\n\tngx_file_reader_async_open_context_t* context = ctx;\n\tngx_file_reader_state_t* state = context->state;\n\tngx_http_request_t *r = state->r;\n\tngx_connection_t *c = r->connection;\n\n\tr->main->blocked--;\n\tr->aio = 0;\n\n\trc = ngx_file_reader_update_state_file_info(state, &context->of, rc);\n\n\tcontext->open_callback(context->callback_context, rc);\n\n\tngx_http_run_posted_requests(c);\n}\n\nngx_int_t \nngx_file_reader_init_async(\n\tngx_file_reader_state_t* state,\n\tvoid** context,\n\tngx_thread_pool_t *thread_pool,\n\tngx_async_open_file_callback_t open_callback,\n\tngx_async_read_callback_t read_callback,\n\tvoid* callback_context,\n\tngx_http_request_t *r,\n\tngx_http_core_loc_conf_t *clcf,\n\tngx_str_t* path,\n\tuint32_t flags)\n{\n\tngx_file_reader_async_open_context_t* open_context;\n\tngx_int_t rc;\n\n\tstate->r = r;\n\tstate->file.name = *path;\n\tstate->file.log = r->connection->log;\n\tstate->directio = clcf->directio;\n\tstate->log_not_found = clcf->log_not_found;\n\tstate->log = r->connection->log;\n#if (NGX_HAVE_FILE_AIO)\n\tstate->use_aio = clcf->aio;\n\tstate->read_callback = read_callback;\n\tstate->callback_context = callback_context;\n#endif // NGX_HAVE_FILE_AIO\n\n\topen_context = *context;\n\n\tif (open_context == NULL)\n\t{\n\t\topen_context = ngx_palloc(r->pool, sizeof(ngx_file_reader_async_open_context_t));\n\t\tif (open_context == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\t\"ngx_file_reader_init_async: ngx_palloc failed\");\n\t\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t\topen_context->task = NULL;\t\t// all other fields explicitly set below\n\n\t\t*context = open_context;\n\t}\n\n\topen_context->state = state;\n\topen_context->open_callback = open_callback;\n\topen_context->callback_context = callback_context;\n\n\trc = ngx_file_reader_init_open_file_info(&open_context->of, r, clcf, path);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\trc = ngx_async_open_cached_file(\n\t\t(flags & OPEN_FILE_NO_CACHE) != 0 ? NULL : clcf->open_file_cache, \n\t\tpath,\n\t\t&open_context->of,\n\t\tr->pool,\n\t\tthread_pool,\n\t\t&open_context->task,\n\t\tngx_file_reader_async_open_callback,\n\t\topen_context);\n\tif (rc == NGX_AGAIN)\n\t{\n\t\tr->main->blocked++;\n\t\tr->aio = 1;\n\n\t\treturn NGX_AGAIN;\n\t}\n\n\treturn ngx_file_reader_update_state_file_info(state, &open_context->of, rc);\n}\n\n#endif // NGX_THREADS\n\nngx_int_t\nngx_file_reader_dump_file_part(void* context, off_t start, off_t end)\n{\n\tngx_file_reader_state_t* state = context;\n\tngx_http_request_t* r = state->r;\n\tngx_buf_t                 *b;\n\tngx_int_t                  rc;\n\tngx_chain_t                out;\n\n\tb = ngx_calloc_buf(r->pool);\n\tif (b == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\"ngx_file_reader_dump_file_part: ngx_pcalloc failed (1)\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tb->file = ngx_pcalloc(r->pool, sizeof(ngx_file_t));\n\tif (b->file == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\"ngx_file_reader_dump_file_part: ngx_pcalloc failed (2)\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tb->file_pos = start;\n\tif (end != 0)\n\t{\n\t\tif (end > state->file_size)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, state->log, ngx_errno,\n\t\t\t\t\"ngx_file_reader_dump_file_part: end offset %O exceeds file size %O, probably a truncated file\", end, state->file_size);\n\t\t\treturn NGX_HTTP_NOT_FOUND;\n\t\t}\n\t\tb->file_last = end;\n\t}\n\telse\n\t{\n\t\tb->file_last = state->file_size;\n\t}\n\n\tb->in_file = b->file_last ? 1 : 0;\n\tb->last_buf = (r == r->main) ? 1 : 0;\n\tb->last_in_chain = 1;\n\n\tb->file->fd = state->file.fd;\n\tb->file->name = state->file.name;\n\tb->file->log = state->log;\n\tb->file->directio = state->file.directio;\n\n\tout.buf = b;\n\tout.next = NULL;\n\n\trc = ngx_http_output_filter(r, &out);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\"ngx_file_reader_dump_file_part: ngx_http_output_filter failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_file_reader_enable_directio(ngx_file_reader_state_t* state)\n{\n\tif (state->directio <= state->file_size)\n\t{\n\t\tif (ngx_directio_on(state->file.fd) == NGX_FILE_ERROR) \n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ALERT, state->log, ngx_errno,\n\t\t\t\t\"ngx_file_reader_enable_directio: \" ngx_directio_on_n \" \\\"%s\\\" failed\", state->file.name.data);\n\t\t\treturn NGX_FILE_ERROR;\n\t\t}\n\n\t\tstate->file.directio = 1;\n\t}\n\n\treturn NGX_OK;\n}\n\nsize_t \nngx_file_reader_get_size(void* context)\n{\n\tngx_file_reader_state_t* state = context;\n\n\treturn state->file_size;\n}\n\nvoid\nngx_file_reader_get_path(void* context, ngx_str_t* path)\n{\n\tngx_file_reader_state_t* ctx = context;\n\n\t*path = ctx->file.name;\n}\n\n#if (NGX_HAVE_FILE_AIO)\n\nstatic void\nngx_async_read_completed_callback(ngx_event_t *ev)\n{\n\tngx_file_reader_state_t* state;\n\tngx_http_request_t *r;\n\tngx_connection_t *c;\n\tngx_event_aio_t *aio;\n\tssize_t bytes_read;\n\tssize_t rc;\n\n\taio = ev->data;\n\tstate = aio->data;\n\tr = state->r;\n\tc = r->connection;\n\n\tr->main->blocked--;\n\tr->aio = 0;\n\n\t// get the number of bytes read (offset, size, buffer are ignored in this case)\n\trc = ngx_file_aio_read(&state->file, NULL, 0, 0, r->pool);\n\n\tif (rc < 0)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\"ngx_async_read_completed_callback: ngx_file_aio_read failed rc=%z\", rc);\n\t\tbytes_read = 0;\n\t}\n\telse\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0, \"ngx_async_read_completed_callback: ngx_file_aio_read returned %z\", rc);\n\t\tstate->buf->last += rc;\n\t\tbytes_read = rc;\n\t\trc = NGX_OK;\n\t}\n\n\tstate->read_callback(state->callback_context, rc, NULL, bytes_read);\n\n\tngx_http_run_posted_requests(c);\n}\n\nngx_int_t \nngx_async_file_read(ngx_file_reader_state_t* state, ngx_buf_t *buf, size_t size, off_t offset)\n{\n\tssize_t rc;\n\n\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, state->log, 0, \"ngx_async_file_read: reading offset %O size %uz\", offset, size);\n\n\tif (state->use_aio)\n\t{\n\t\trc = ngx_file_aio_read(&state->file, buf->last, size, offset, state->r->pool);\n\t\tif (rc == NGX_AGAIN)\n\t\t{\n\t\t\t// wait for completion\n\t\t\tstate->file.aio->data = state;\n\t\t\tstate->file.aio->handler = ngx_async_read_completed_callback;\n\n\t\t\tstate->r->main->blocked++;\n\t\t\tstate->r->aio = 1;\n\n\t\t\tstate->buf = buf;\n\t\t\treturn rc;\n\t\t}\n\t}\n\telse\n\t{\n\t\trc = ngx_read_file(&state->file, buf->last, size, offset);\n\t}\n\n\tif (rc < 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, state->log, 0, \"ngx_async_file_read: ngx_file_aio_read failed rc=%z\", rc);\n\t\treturn rc;\n\t}\n\n\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0, \"ngx_async_file_read: ngx_file_aio_read returned %z\", rc);\n\tbuf->last += rc;\n\t\n\treturn NGX_OK;\n}\n\n#else\n\nngx_int_t \nngx_async_file_read(ngx_file_reader_state_t* state, ngx_buf_t *buf, size_t size, off_t offset)\n{\n\tssize_t rc;\n\n\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, state->log, 0, \"ngx_async_file_read: reading offset %O size %uz\", offset, size);\n\n\trc = ngx_read_file(&state->file, buf->last, size, offset);\n\tif (rc < 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, state->log, 0, \"ngx_async_file_read: ngx_read_file failed rc=%z\", rc);\n\t\treturn rc;\n\t}\n\n\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0, \"ngx_async_file_read: ngx_read_file returned %z\", rc);\n\tbuf->last += rc;\n\n\treturn NGX_OK;\n}\n\n#endif // NGX_HAVE_FILE_AIO\n"
        },
        {
          "name": "ngx_file_reader.h",
          "type": "blob",
          "size": 1.7314453125,
          "content": "#ifndef _NGX_FILE_READER_H_INCLUDED_\n#define _NGX_FILE_READER_H_INCLUDED_\n\n// includes\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include <nginx.h>\n\n#if (NGX_THREADS)\n#include \"ngx_async_open_file_cache.h\"\n#endif // NGX_THREADS\n\n// constants\n#define OPEN_FILE_NO_CACHE (0x1)\n\n// typedefs\ntypedef void (*ngx_async_read_callback_t)(void* context, ngx_int_t rc, ngx_buf_t* buf, ssize_t bytes_read);\n\ntypedef struct {\n\tngx_http_request_t *r;\n\tngx_file_t file;\n\toff_t directio;\n\tngx_flag_t log_not_found;\n\tngx_log_t* log;\n\toff_t file_size;\n#if (NGX_HAVE_FILE_AIO)\n\tngx_flag_t use_aio;\n\tngx_async_read_callback_t read_callback;\n\tvoid* callback_context;\n\tngx_buf_t* buf;\n#endif // NGX_HAVE_FILE_AIO\n} ngx_file_reader_state_t;\n\n// functions\nngx_int_t ngx_file_reader_init(\n\tngx_file_reader_state_t* state,\n\tngx_async_read_callback_t read_callback,\n\tvoid* callback_context,\n\tngx_http_request_t *r,\n\tngx_http_core_loc_conf_t  *clcf,\n\tngx_str_t* path,\n\tuint32_t flags);\n\n#if (NGX_THREADS)\nngx_int_t ngx_file_reader_init_async(\n\tngx_file_reader_state_t* state,\n\tvoid** context,\n\tngx_thread_pool_t *thread_pool,\n\tngx_async_open_file_callback_t open_callback,\n\tngx_async_read_callback_t read_callback,\n\tvoid* callback_context,\n\tngx_http_request_t *r,\n\tngx_http_core_loc_conf_t  *clcf,\n\tngx_str_t* path,\n\tuint32_t flags);\n#endif // NGX_THREADS\n\nngx_int_t ngx_file_reader_dump_file_part(void* context, off_t start, off_t end);\n\nsize_t ngx_file_reader_get_size(void* context);\n\nvoid ngx_file_reader_get_path(void* context, ngx_str_t* path);\n\nngx_int_t ngx_async_file_read(ngx_file_reader_state_t* state, ngx_buf_t *buf, size_t size, off_t offset);\n\nngx_int_t ngx_file_reader_enable_directio(ngx_file_reader_state_t* state);\n\n#endif // _NGX_FILE_READER_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_conf.c",
          "type": "blob",
          "size": 42.1640625,
          "content": "#include \"ngx_http_vod_conf.h\"\n#include \"ngx_http_vod_request_parse.h\"\n#include \"ngx_child_http_request.h\"\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_module.h\"\n#include \"ngx_http_vod_status.h\"\n#include \"ngx_perf_counters.h\"\n#include \"ngx_buffer_cache.h\"\n#include \"vod/media_set_parser.h\"\n#include \"vod/buffer_pool.h\"\n#include \"vod/common.h\"\n#include \"vod/udrm.h\"\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n#include \"ngx_http_vod_thumb.h\"\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n// globals\nstatic ngx_str_t ngx_http_vod_last_modified_default_types[] = {\n\tngx_null_string\n};\n\nstatic ngx_int_t\nngx_http_vod_init_parsers(ngx_conf_t *cf)\n{\n\tvod_status_t rc;\n\t\n\trc = media_set_parser_init(cf->pool, cf->temp_pool);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to initialize media set parsers %i\", rc);\n\t\treturn NGX_ERROR;\n\t}\n\n\trc = udrm_init_parser(cf->pool, cf->temp_pool);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to initialize udrm parser %i\", rc);\n\t\treturn NGX_ERROR;\n\t}\n\n\trc = ngx_child_request_init(cf);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to initialize hide headers hash %i\", rc);\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic void *\nngx_http_vod_create_loc_conf(ngx_conf_t *cf)\n{\n    ngx_http_vod_loc_conf_t  *conf;\n\tconst ngx_http_vod_submodule_t** cur_module;\n\tint type;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_vod_loc_conf_t));\n    if (conf == NULL) \n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,\n\t\t\t\"ngx_http_vod_create_loc_conf: ngx_pcalloc failed\");\n\t\treturn NGX_CONF_ERROR;\n    }\n\n\t// base params\n\tconf->submodule.parse_uri_file_name = NGX_CONF_UNSET_PTR;\n\tconf->request_handler = NGX_CONF_UNSET_PTR;\n\tconf->segmenter.segment_duration = NGX_CONF_UNSET_UINT;\n\tconf->segmenter.live_window_duration = NGX_CONF_UNSET;\n\tconf->segmenter.bootstrap_segments = NGX_CONF_UNSET_PTR;\n\tconf->segmenter.align_to_key_frames = NGX_CONF_UNSET;\n\tconf->segmenter.get_segment_count = NGX_CONF_UNSET_PTR;\n\tconf->segmenter.get_segment_durations = NGX_CONF_UNSET_PTR;\n\tconf->segmenter.manifest_duration_policy = NGX_CONF_UNSET_UINT;\n\tconf->segmenter.gop_look_ahead = NGX_CONF_UNSET_UINT;\n\tconf->segmenter.gop_look_behind = NGX_CONF_UNSET_UINT;\n\tconf->force_playlist_type_vod = NGX_CONF_UNSET;\n\tconf->force_continuous_timestamps = NGX_CONF_UNSET;\n\tconf->force_sequence_index = NGX_CONF_UNSET;\n\tconf->initial_read_size = NGX_CONF_UNSET_SIZE;\n\tconf->max_metadata_size = NGX_CONF_UNSET_SIZE;\n\tconf->max_frames_size = NGX_CONF_UNSET_SIZE;\n\tconf->max_frame_count = NGX_CONF_UNSET_UINT;\n\tconf->segment_max_frame_count = NGX_CONF_UNSET_UINT;\n\tconf->cache_buffer_size = NGX_CONF_UNSET_SIZE;\n\tconf->max_upstream_headers_size = NGX_CONF_UNSET_SIZE;\n\tconf->ignore_edit_list = NGX_CONF_UNSET;\n\tconf->parse_hdlr_name = NGX_CONF_UNSET;\n\tconf->parse_udta_name = NGX_CONF_UNSET;\n\tconf->max_mapping_response_size = NGX_CONF_UNSET_SIZE;\n\n\tconf->metadata_cache = NGX_CONF_UNSET_PTR;\n\tconf->dynamic_mapping_cache = NGX_CONF_UNSET_PTR;\n\tfor (type = 0; type < CACHE_TYPE_COUNT; type++)\n\t{\n\t\tconf->response_cache[type] = NGX_CONF_UNSET_PTR;\n\t\tconf->mapping_cache[type] = NGX_CONF_UNSET_PTR;\n\t}\n\n\tfor (type = 0; type < EXPIRES_TYPE_COUNT; type++)\n\t{\n\t\tconf->expires[type] = NGX_CONF_UNSET;\n\t}\n\tconf->last_modified_time = NGX_CONF_UNSET;\n\n\tconf->drm_enabled = NGX_CONF_UNSET;\n\tconf->drm_single_key = NGX_CONF_UNSET;\n\tconf->drm_clear_lead_segment_count = NGX_CONF_UNSET_UINT;\n\tconf->drm_max_info_length = NGX_CONF_UNSET_SIZE;\n\tconf->drm_info_cache = NGX_CONF_UNSET_PTR;\n\tconf->min_single_nalu_per_frame_segment = NGX_CONF_UNSET_UINT;\n\n#if (NGX_THREADS)\n\tconf->open_file_thread_pool = NGX_CONF_UNSET_PTR;\n#endif // NGX_THREADS\n\n\t// submodules\n\tfor (cur_module = submodules; *cur_module != NULL; cur_module++)\n\t{\n\t\t(*cur_module)->create_loc_conf(cf, (u_char*)conf + (*cur_module)->conf_offset);\n\t}\n\n    return conf;\n}\n\nstatic char *\nngx_http_vod_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n\tngx_http_vod_loc_conf_t *prev = parent;\n\tngx_http_vod_loc_conf_t *conf = child;\n\tconst ngx_http_vod_submodule_t** cur_module;\n\tngx_int_t rc;\n\tint type;\n\tchar* err;\n\n\t// base params\n\tngx_conf_merge_str_value(conf->upstream_location, prev->upstream_location, \"\");\n\tif (conf->submodule.parse_uri_file_name == NGX_CONF_UNSET_PTR)\n\t{\n\t\tif (prev->submodule.parse_uri_file_name != NGX_CONF_UNSET_PTR)\n\t\t{\n\t\t\tconf->submodule = prev->submodule;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// zero module = serve files\n\t\t\tngx_memzero(&conf->submodule, sizeof(conf->submodule));\n\t\t}\n\t}\n\tngx_conf_merge_str_value(conf->remote_upstream_location, prev->remote_upstream_location, \"\");\n\tngx_conf_merge_ptr_value(conf->request_handler, prev->request_handler, ngx_http_vod_local_request_handler);\n\tngx_conf_merge_str_value(conf->multi_uri_suffix, prev->multi_uri_suffix, \".urlset\");\n\n\tngx_conf_merge_uint_value(conf->segmenter.segment_duration, prev->segmenter.segment_duration, 10000);\n\tngx_conf_merge_value(conf->segmenter.live_window_duration, prev->segmenter.live_window_duration, 30000);\n\tngx_conf_merge_ptr_value(conf->segmenter.bootstrap_segments, prev->segmenter.bootstrap_segments, NULL);\n\tngx_conf_merge_value(conf->segmenter.align_to_key_frames, prev->segmenter.align_to_key_frames, 0);\n\tngx_conf_merge_ptr_value(conf->segmenter.get_segment_count, prev->segmenter.get_segment_count, segmenter_get_segment_count_last_short);\n\tngx_conf_merge_ptr_value(conf->segmenter.get_segment_durations, prev->segmenter.get_segment_durations, segmenter_get_segment_durations_estimate);\n\tngx_conf_merge_uint_value(conf->segmenter.manifest_duration_policy, prev->segmenter.manifest_duration_policy, MDP_MAX);\n\tngx_conf_merge_uint_value(conf->segmenter.gop_look_ahead, prev->segmenter.gop_look_ahead, 1000);\n\tngx_conf_merge_uint_value(conf->segmenter.gop_look_behind, prev->segmenter.gop_look_behind, 10000);\n\tngx_conf_merge_value(conf->force_playlist_type_vod, prev->force_playlist_type_vod, 0);\n\tngx_conf_merge_value(conf->force_continuous_timestamps, prev->force_continuous_timestamps, 0);\n\tngx_conf_merge_value(conf->force_sequence_index, prev->force_sequence_index, 0);\n\n\tif (conf->secret_key == NULL)\n\t{\n\t\tconf->secret_key = prev->secret_key;\n\t}\n\n\tif (conf->encryption_iv_seed == NULL)\n\t{\n\t\tconf->encryption_iv_seed = prev->encryption_iv_seed;\n\t}\n\n\tif (conf->base_url == NULL)\n\t{\n\t\tconf->base_url = prev->base_url;\n\t}\n\n\tif (conf->segments_base_url == NULL)\n\t{\n\t\tconf->segments_base_url = prev->segments_base_url;\n\t}\n\n\tngx_conf_merge_ptr_value(conf->metadata_cache, prev->metadata_cache, NULL);\n\tngx_conf_merge_ptr_value(conf->dynamic_mapping_cache, prev->dynamic_mapping_cache, NULL);\n\n\tfor (type = 0; type < CACHE_TYPE_COUNT; type++)\n\t{\n\t\tngx_conf_merge_ptr_value(conf->response_cache[type], prev->response_cache[type], NULL);\n\t\tngx_conf_merge_ptr_value(conf->mapping_cache[type], prev->mapping_cache[type], NULL);\n\t}\n\n\tfor (type = 0; type < EXPIRES_TYPE_COUNT; type++)\n\t{\n\t\tngx_conf_merge_value(conf->expires[type], prev->expires[type], -1);\n\t}\n\n\tngx_conf_merge_size_value(conf->initial_read_size, prev->initial_read_size, 4096);\n\tngx_conf_merge_size_value(conf->max_metadata_size, prev->max_metadata_size, 128 * 1024 * 1024);\n\tngx_conf_merge_size_value(conf->max_frames_size, prev->max_frames_size, 16 * 1024 * 1024);\n\tngx_conf_merge_uint_value(conf->max_frame_count, prev->max_frame_count, 1024 * 1024);\n\tngx_conf_merge_uint_value(conf->segment_max_frame_count, prev->segment_max_frame_count, 64 * 1024);\n\tngx_conf_merge_size_value(conf->cache_buffer_size, prev->cache_buffer_size, 256 * 1024);\n\tngx_conf_merge_size_value(conf->max_upstream_headers_size, prev->max_upstream_headers_size, 4 * 1024);\n\n\tif (conf->output_buffer_pool == NULL)\n\t{\n\t\tconf->output_buffer_pool = prev->output_buffer_pool;\n\t}\n\n\tngx_conf_merge_value(conf->ignore_edit_list, prev->ignore_edit_list, 0);\n\tngx_conf_merge_value(conf->parse_hdlr_name, prev->parse_hdlr_name, 0);\n\tngx_conf_merge_value(conf->parse_udta_name, prev->parse_udta_name, 0);\n\n\tconf->parse_flags = 0;\n\tif (!conf->ignore_edit_list)\n\t{\n\t\tconf->parse_flags |= PARSE_FLAG_EDIT_LIST;\n\t}\n\tif (conf->parse_hdlr_name)\n\t{\n\t\tconf->parse_flags |= PARSE_FLAG_HDLR_NAME;\n\t}\n\tif (conf->parse_udta_name)\n\t{\n\t\tconf->parse_flags |= PARSE_FLAG_UDTA_NAME;\n\t}\n\n\tif (conf->upstream_extra_args == NULL)\n\t{\n\t\tconf->upstream_extra_args = prev->upstream_extra_args;\n\t}\n\n\tngx_conf_merge_str_value(conf->path_response_prefix, prev->path_response_prefix, \"{\\\"sequences\\\":[{\\\"clips\\\":[{\\\"type\\\":\\\"source\\\",\\\"path\\\":\\\"\");\n\tngx_conf_merge_str_value(conf->path_response_postfix, prev->path_response_postfix, \"\\\"}]}]}\");\n\tngx_conf_merge_size_value(conf->max_mapping_response_size, prev->max_mapping_response_size, 1024);\n\tif (conf->notification_uri == NULL)\n\t{\n\t\tconf->notification_uri = prev->notification_uri;\n\t}\n\tif (conf->dynamic_clip_map_uri == NULL)\n\t{\n\t\tconf->dynamic_clip_map_uri = prev->dynamic_clip_map_uri;\n\t}\n\tif (conf->source_clip_map_uri == NULL)\n\t{\n\t\tconf->source_clip_map_uri = prev->source_clip_map_uri;\n\t}\n\tif (conf->redirect_segments_url == NULL)\n\t{\n\t\tconf->redirect_segments_url = prev->redirect_segments_url;\n\t}\n\tif (conf->media_set_map_uri == NULL)\n\t{\n\t\tconf->media_set_map_uri = prev->media_set_map_uri;\n\t}\n\tif (conf->apply_dynamic_mapping == NULL)\n\t{\n\t\tconf->apply_dynamic_mapping = prev->apply_dynamic_mapping;\n\t}\n\tif (conf->media_set_override_json == NULL)\n\t{\n\t\tconf->media_set_override_json = prev->media_set_override_json;\n\t}\n\n\tngx_conf_merge_str_value(conf->fallback_upstream_location, prev->fallback_upstream_location, \"\");\n\tngx_conf_merge_str_value(conf->proxy_header.key, prev->proxy_header.key, \"X-Kaltura-Proxy\");\n\tngx_conf_merge_str_value(conf->proxy_header.value, prev->proxy_header.value, \"dumpApiRequest\");\n\n\tngx_conf_merge_value(conf->last_modified_time, prev->last_modified_time, -1);\n\tif (ngx_http_merge_types(\n\t\tcf,\n\t\t&conf->last_modified_types_keys,\n\t\t&conf->last_modified_types,\n\t\t&prev->last_modified_types_keys,\n\t\t&prev->last_modified_types,\n\t\tngx_http_vod_last_modified_default_types) != NGX_OK)\n\t{\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tngx_conf_merge_value(conf->drm_enabled, prev->drm_enabled, 0);\n\tngx_conf_merge_value(conf->drm_single_key, prev->drm_single_key, 0);\n\tngx_conf_merge_uint_value(conf->drm_clear_lead_segment_count, prev->drm_clear_lead_segment_count, 1);\n\tngx_conf_merge_str_value(conf->drm_upstream_location, prev->drm_upstream_location, \"\");\n\tngx_conf_merge_size_value(conf->drm_max_info_length, prev->drm_max_info_length, 4096);\n\tngx_conf_merge_ptr_value(conf->drm_info_cache, prev->drm_info_cache, NULL);\n\tif (conf->drm_request_uri == NULL)\n\t{\n\t\tconf->drm_request_uri = prev->drm_request_uri;\n\t}\n\tngx_conf_merge_uint_value(conf->min_single_nalu_per_frame_segment, prev->min_single_nalu_per_frame_segment, 0);\n\t\n\tngx_conf_merge_str_value(conf->clip_to_param_name, prev->clip_to_param_name, \"clipTo\");\n\tngx_conf_merge_str_value(conf->clip_from_param_name, prev->clip_from_param_name, \"clipFrom\");\n\tngx_conf_merge_str_value(conf->tracks_param_name, prev->tracks_param_name, \"tracks\");\n\tngx_conf_merge_str_value(conf->time_shift_param_name, prev->time_shift_param_name, \"shift\");\n\tngx_conf_merge_str_value(conf->speed_param_name, prev->speed_param_name, \"speed\");\n\tngx_conf_merge_str_value(conf->lang_param_name, prev->lang_param_name, \"lang\");\n\n\tif (conf->perf_counters_zone == NULL)\n\t{\n\t\tconf->perf_counters_zone = prev->perf_counters_zone;\n\t}\n\n#if (NGX_THREADS)\n\tngx_conf_merge_ptr_value(conf->open_file_thread_pool, prev->open_file_thread_pool, NULL);\n#endif // NGX_THREADS\n\n\t// validate vod_upstream / vod_upstream_host_header used when needed\n\tif (conf->request_handler == ngx_http_vod_remote_request_handler)\n\t{\n\t\tif (conf->upstream_location.len == 0)\n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\t\"\\\"vod_upstream_location\\\" is mandatory for remote mode\");\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\t}\n\n\tif (conf->segmenter.segment_duration <= 0)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_segment_duration\\\" must be positive\");\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n\tif (conf->submodule.name == thumb.name)\n\t{\n\t\tconf->segmenter.align_to_key_frames = 1;\n\t}\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n\trc = segmenter_init_config(&conf->segmenter, cf->pool);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to initialize the segmenter %i\", rc);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->drm_enabled)\n\t{\n\t\tif (conf->drm_upstream_location.len == 0)\n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\t\"\\\"vod_drm_upstream_location\\\" is mandatory for drm\");\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\t}\n\n\t// validate the lengths of uri parameters\n\tif (conf->clip_to_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_clip_to_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->clip_from_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_clip_from_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->tracks_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_tracks_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->time_shift_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_time_shift_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->speed_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_speed_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (conf->lang_param_name.len > MAX_URI_PARAM_NAME_LEN)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"\\\"vod_lang_param_name\\\" should not be more than %d characters\", MAX_URI_PARAM_NAME_LEN);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\t// calculate the proxy header lower case and hash\n\tconf->proxy_header.lowcase_key = ngx_palloc(cf->pool, conf->proxy_header.key.len);\n\tif (conf->proxy_header.lowcase_key == NULL)\n\t{\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tngx_strlow(conf->proxy_header.lowcase_key, conf->proxy_header.key.data, conf->proxy_header.key.len);\n\tconf->proxy_header.hash = ngx_hash_key(conf->proxy_header.lowcase_key, conf->proxy_header.key.len);\n\n\t// init the hash table of the uri params (clipTo, clipFrom etc.)\n\trc = ngx_http_vod_init_uri_params_hash(cf, conf);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,\n\t\t\t\"ngx_http_vod_merge_loc_conf: ngx_http_vod_init_uri_params_hash failed\");\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\t// merge the submodules configuration\n\tfor (cur_module = submodules; *cur_module != NULL; cur_module++)\n\t{\n\t\terr = (*cur_module)->merge_loc_conf(\n\t\t\tcf, \n\t\t\tconf, \n\t\t\t(u_char*)conf + (*cur_module)->conf_offset, \n\t\t\t(u_char*)prev + (*cur_module)->conf_offset);\n\t\tif (err != NGX_CONF_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,\n\t\t\t\t\"ngx_http_vod_merge_loc_conf: submodule merge_loc_conf failed\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n    return NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_set_time_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tchar  *p = conf;\n\n\ttime_t           *sp;\n\tngx_str_t        *value;\n\tngx_conf_post_t  *post;\n\n\n\tsp = (time_t *)(p + cmd->offset);\n\tif (*sp != NGX_CONF_UNSET) {\n\t\treturn \"is duplicate\";\n\t}\n\n\tvalue = cf->args->elts;\n\n\t*sp = ngx_http_parse_time(value[1].data, value[1].len);\n\tif (*sp == (time_t)NGX_ERROR) {\n\t\treturn \"invalid value\";\n\t}\n\n\tif (cmd->post) {\n\t\tpost = cmd->post;\n\t\treturn post->post_handler(cf, post, sp);\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_set_signed_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tchar  *p = conf;\n\n\tngx_int_t        *np;\n\tngx_str_t        *value;\n\tngx_conf_post_t  *post;\n\n\n\tnp = (ngx_int_t *)(p + cmd->offset);\n\n\tif (*np != NGX_CONF_UNSET) {\n\t\treturn \"is duplicate\";\n\t}\n\n\tvalue = cf->args->elts;\n\tif (value[1].len > 0 && value[1].data[0] == '-')\n\t{\n\t\t*np = ngx_atoi(value[1].data + 1, value[1].len - 1);\n\t\tif (*np == NGX_ERROR) {\n\t\t\treturn \"invalid number\";\n\t\t}\n\t\t*np = -(*np);\n\t}\n\telse\n\t{\n\t\t*np = ngx_atoi(value[1].data, value[1].len);\n\t\tif (*np == NGX_ERROR) {\n\t\t\treturn \"invalid number\";\n\t\t}\n\t}\n\n\tif (cmd->post) {\n\t\tpost = cmd->post;\n\t\treturn post->post_handler(cf, post, np);\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_mode_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_http_vod_loc_conf_t    *vod_conf = conf;\n\tngx_str_t                       *value;\n\n\tvalue = cf->args->elts;\n\n\tif (ngx_strcasecmp(value[1].data, (u_char *) \"local\") == 0) \n\t{\n\t\tvod_conf->request_handler = ngx_http_vod_local_request_handler;\n\t}\n\telse if (ngx_strcasecmp(value[1].data, (u_char *) \"remote\") == 0) \n\t{\n\t\tvod_conf->request_handler = ngx_http_vod_remote_request_handler;\n\t}\n\telse if (ngx_strcasecmp(value[1].data, (u_char *) \"mapped\") == 0) \n\t{\n\t\tvod_conf->request_handler = ngx_http_vod_mapped_request_handler;\n\t}\n\telse \n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"invalid value \\\"%s\\\" in \\\"%s\\\" directive, \"\n\t\t\t\"it must be \\\"local\\\", \\\"remote\\\" or \\\"mapped\\\"\",\n\t\t\tvalue[1].data, cmd->name.data);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_segment_count_policy_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_http_vod_loc_conf_t    *vod_conf = conf;\n\tngx_str_t                       *value;\n\n\tvalue = cf->args->elts;\n\n\tif (ngx_strcasecmp(value[1].data, (u_char *) \"last_short\") == 0)\n\t{\n\t\tvod_conf->segmenter.get_segment_count = segmenter_get_segment_count_last_short;\n\t}\n\telse if (ngx_strcasecmp(value[1].data, (u_char *) \"last_long\") == 0)\n\t{\n\t\tvod_conf->segmenter.get_segment_count = segmenter_get_segment_count_last_long;\n\t}\n\telse if (ngx_strcasecmp(value[1].data, (u_char *) \"last_rounded\") == 0)\n\t{\n\t\tvod_conf->segmenter.get_segment_count = segmenter_get_segment_count_last_rounded;\n\t}\n\telse\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"invalid value \\\"%s\\\" in \\\"%s\\\" directive, \"\n\t\t\t\"it must be \\\"last_short\\\", \\\"last_long\\\" or \\\"last_rounded\\\"\",\n\t\t\tvalue[1].data, cmd->name.data);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\n#if (NGX_THREADS)\nstatic char *\nngx_http_vod_thread_pool_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_thread_pool_t **tp = (ngx_thread_pool_t **)((u_char*)conf + cmd->offset);\n\tngx_str_t  *value;\n\n\tif (*tp != NGX_CONF_UNSET_PTR) {\n\t\treturn \"is duplicate\";\n\t}\n\n\tvalue = cf->args->elts;\n\n\tif (cf->args->nelts > 1)\n\t{\n\t\t*tp = ngx_thread_pool_add(cf, &value[1]);\n\t}\n\telse\n\t{\n\t\t*tp = ngx_thread_pool_add(cf, NULL);\n\t}\n\n\tif (*tp == NULL)\n\t{\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n#endif // NGX_THREADS\n\nstatic char *\nngx_http_vod_manifest_segment_durations_mode_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_http_vod_loc_conf_t    *vod_conf = conf;\n\tngx_str_t                       *value;\n\n\tvalue = cf->args->elts;\n\n\tif (ngx_strcasecmp(value[1].data, (u_char *) \"estimate\") == 0)\n\t{\n\t\tvod_conf->segmenter.get_segment_durations = segmenter_get_segment_durations_estimate;\n\t}\n\telse if (ngx_strcasecmp(value[1].data, (u_char *) \"accurate\") == 0)\n\t{\n\t\tvod_conf->segmenter.get_segment_durations = segmenter_get_segment_durations_accurate;\n\t}\n\telse\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"invalid value \\\"%s\\\" in \\\"%s\\\" directive, \"\n\t\t\t\"it must be \\\"estimate\\\" or \\\"accurate\\\"\",\n\t\t\tvalue[1].data, cmd->name.data);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_cache_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_buffer_cache_t **cache = (ngx_buffer_cache_t **)((u_char*)conf + cmd->offset);\n\tngx_str_t  *value;\n\tssize_t size;\n\ttime_t expiration;\n\n\tvalue = cf->args->elts;\n\n\tif (*cache != NGX_CONF_UNSET_PTR)\n\t{\n\t\treturn \"is duplicate\";\n\t}\n\n\tif (ngx_strcmp(value[1].data, \"off\") == 0) \n\t{\n\t\t*cache = NULL;\n\t\treturn NGX_CONF_OK;\n\t}\n\n\tif (cf->args->nelts < 3)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"size not specified in \\\"%V\\\"\", &cmd->name);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tsize = ngx_parse_size(&value[2]);\n\tif (size == NGX_ERROR)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"invalid size %V\", &value[2]);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\tif (cf->args->nelts > 3)\n\t{\n\t\texpiration = ngx_parse_time(&value[3], 1);\n\t\tif (expiration == (time_t)NGX_ERROR) \n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\t\"invalid expiration %V\", &value[3]);\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\t}\n\telse\n\t{\n\t\texpiration = 0;\n\t}\n\n\t*cache = ngx_buffer_cache_create(cf, &value[1], size, expiration, &ngx_http_vod_module);\n\tif (*cache == NULL)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to create cache\");\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_perf_counters_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_shm_zone_t **zone = (ngx_shm_zone_t **)((u_char*)conf + cmd->offset);\n\tngx_str_t  *value;\n\n\tvalue = cf->args->elts;\n\n\tif (*zone != NULL)\n\t{\n\t\treturn \"is duplicate\";\n\t}\n\n\tif (ngx_strcmp(value[1].data, \"off\") == 0)\n\t{\n\t\t*zone = NULL;\n\t\treturn NGX_CONF_OK;\n\t}\n\n\t*zone = ngx_perf_counters_create_zone(cf, &value[1], &ngx_http_vod_module);\n\tif (*zone == NULL)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"failed to create perf counters cache zone\");\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char*\nngx_http_vod_buffer_pool_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tbuffer_pool_t** buffer_pool = (buffer_pool_t **)((u_char*)conf + cmd->offset);\n\tngx_str_t  *value;\n\tngx_int_t count;\n\tssize_t buffer_size;\n\n\tif (*buffer_pool != NULL)\n\t{\n\t\treturn \"is duplicate\";\n\t}\n\n\tvalue = cf->args->elts;\n\n\tbuffer_size = ngx_parse_size(&value[1]);\n\tif (buffer_size == NGX_ERROR)\n\t{\n\t\treturn \"invalid size\";\n\t}\n\n\tcount = ngx_atoi(value[2].data, value[2].len);\n\tif (count == NGX_ERROR)\n\t{\n\t\treturn \"invalid count\";\n\t}\n\t\n\t*buffer_pool = buffer_pool_create(cf->pool, cf->log, buffer_size, count);\n\tif (*buffer_pool == NULL)\n\t{\n\t\treturn NGX_CONF_ERROR;\n\t}\n\t\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tconst ngx_http_vod_submodule_t** cur_module;\n\tngx_http_vod_loc_conf_t *vod_conf = conf;\n\tngx_http_core_loc_conf_t *clcf;\n\tngx_flag_t found_module;\n\tngx_str_t *value;\n\tngx_str_t module_names;\n\tsize_t module_names_size;\n\tu_char* p;\n\n\tclcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n\tclcf->handler = ngx_http_vod_handler;\n\n\tvalue = cf->args->elts;\n\n\t// file serve\n\tif (ngx_strcasecmp(value[1].data, (u_char *) \"none\") == 0)\n\t{\n\t\tngx_memzero(&vod_conf->submodule, sizeof(vod_conf->submodule));\n\t\treturn NGX_CONF_OK;\n\t}\n\n\t// submodule\n\tfound_module = 0;\n\tmodule_names_size = 1;\n\tfor (cur_module = submodules; *cur_module != NULL; cur_module++)\n\t{\n\t\tif (ngx_strcasecmp(value[1].data, (*cur_module)->name) == 0)\n\t\t{\n\t\t\tvod_conf->submodule = **cur_module;\n\t\t\tfound_module = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmodule_names_size += (*cur_module)->name_len + 1;\n\t}\n\n\tif (!found_module)\n\t{\n\t\t// combine the module names\n\t\tmodule_names.data = ngx_palloc(cf->pool, module_names_size);\n\t\tif (module_names.data == NULL)\n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"failed to allocate modules names\");\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\n\t\tp = module_names.data;\n\t\tfor (cur_module = submodules; *cur_module != NULL; cur_module++)\n\t\t{\n\t\t\t*p++ = ',';\n\t\t\tp = ngx_copy(p, (*cur_module)->name, (*cur_module)->name_len);\n\t\t}\n\t\t*p = '\\0';\n\t\tmodule_names.len = p - module_names.data;\n\n\t\t// print the error message\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\"invalid value \\\"%s\\\" in \\\"%s\\\" directive, \"\n\t\t\t\"it must be one of: none%V\",\n\t\t\tvalue[1].data, cmd->name.data, &module_names);\n\t\treturn NGX_CONF_ERROR;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic char *\nngx_http_vod_status(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n\tngx_http_core_loc_conf_t *clcf;\n\n\tclcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n\tclcf->handler = ngx_http_vod_status_handler;\n\n\treturn NGX_CONF_OK;\n}\n\nstatic ngx_conf_enum_t manifest_duration_policies[] = {\n\t{ ngx_string(\"max\"), MDP_MAX },\n\t{ ngx_string(\"min\"), MDP_MIN },\n\t{ ngx_null_string, 0 }\n};\n\nngx_command_t ngx_http_vod_commands[] = {\n\n\t// basic parameters\n\t{ ngx_string(\"vod\"),\n\tNGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\t0,\n\tNULL },\n\n\t{ ngx_string(\"vod_mode\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_mode_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\t0,\n\tNULL },\n\n\t{ ngx_string(\"vod_status\"),\n\tNGX_HTTP_LOC_CONF | NGX_CONF_NOARGS,\n\tngx_http_vod_status,\n\t0,\n\t0,\n\tNULL },\n\n\t// output generation parameters\n\t{ ngx_string(\"vod_multi_uri_suffix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, multi_uri_suffix),\n\tNULL },\n\n\t{ ngx_string(\"vod_segment_duration\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.segment_duration),\n\tNULL },\n\n\t{ ngx_string(\"vod_live_window_duration\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_set_signed_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.live_window_duration),\n\tNULL },\n\n\t{ ngx_string(\"vod_bootstrap_segment_durations\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_array_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.bootstrap_segments),\n\tNULL },\n\n\t{ ngx_string(\"vod_align_segments_to_key_frames\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.align_to_key_frames),\n\tNULL },\n\n\t{ ngx_string(\"vod_gop_look_ahead\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.gop_look_ahead),\n\tNULL },\n\n\t{ ngx_string(\"vod_gop_look_behind\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.gop_look_behind),\n\tNULL },\n\n\t{ ngx_string(\"vod_segment_count_policy\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_segment_count_policy_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\t0,\n\tNULL },\n\n\t{ ngx_string(\"vod_manifest_duration_policy\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_enum_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segmenter.manifest_duration_policy),\n\tmanifest_duration_policies },\n\n\t{ ngx_string(\"vod_manifest_segment_durations_mode\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_manifest_segment_durations_mode_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\t0,\n\tNULL },\n\n\t{ ngx_string(\"vod_force_playlist_type_vod\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, force_playlist_type_vod),\n\tNULL },\n\n\t{ ngx_string(\"vod_force_continuous_timestamps\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, force_continuous_timestamps),\n\tNULL },\n\n\t{ ngx_string(\"vod_force_sequence_index\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, force_sequence_index),\n\tNULL },\n\n\t{ ngx_string(\"vod_secret_key\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, secret_key),\n\tNULL },\n\n\t{ ngx_string(\"vod_encryption_iv_seed\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, encryption_iv_seed),\n\tNULL },\n\n\t{ ngx_string(\"vod_base_url\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, base_url),\n\tNULL },\n\n\t{ ngx_string(\"vod_segments_base_url\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segments_base_url),\n\tNULL },\n\t\n\t// mp4 reading parameters\n\t{ ngx_string(\"vod_metadata_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, metadata_cache),\n\tNULL },\n\n\t{ ngx_string(\"vod_response_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, response_cache[CACHE_TYPE_VOD]),\n\tNULL },\n\n\t{ ngx_string(\"vod_live_response_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, response_cache[CACHE_TYPE_LIVE]),\n\tNULL },\n\n\t{ ngx_string(\"vod_initial_read_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, initial_read_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_max_metadata_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, max_metadata_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_max_frames_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, max_frames_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_max_frame_count\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, max_frame_count),\n\tNULL },\n\n\t{ ngx_string(\"vod_segment_max_frame_count\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, segment_max_frame_count),\n\tNULL },\n\n\t{ ngx_string(\"vod_cache_buffer_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, cache_buffer_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_ignore_edit_list\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, ignore_edit_list),\n\tNULL },\n\n\t{ ngx_string(\"vod_parse_hdlr_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, parse_hdlr_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_parse_udta_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, parse_udta_name),\n\tNULL },\n\n\t// upstream parameters - only for mapped/remote modes\n\t{ ngx_string(\"vod_max_upstream_headers_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, max_upstream_headers_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_upstream_location\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, upstream_location),\n\tNULL },\n\n\t{ ngx_string(\"vod_remote_upstream_location\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, remote_upstream_location),\n\tNULL },\n\n\t{ ngx_string(\"vod_upstream_extra_args\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, upstream_extra_args),\n\tNULL },\n\n\t// path request parameters - mapped mode only\n\t{ ngx_string(\"vod_mapping_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, mapping_cache[CACHE_TYPE_VOD]),\n\tNULL },\n\n\t{ ngx_string(\"vod_live_mapping_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, mapping_cache[CACHE_TYPE_LIVE]),\n\tNULL },\n\n\t{ ngx_string(\"vod_dynamic_mapping_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, dynamic_mapping_cache),\n\tNULL },\n\n\t{ ngx_string(\"vod_path_response_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, path_response_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_path_response_postfix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, path_response_postfix),\n\tNULL },\n\n\t{ ngx_string(\"vod_max_mapping_response_size\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, max_mapping_response_size),\n\tNULL },\n\n\t{ ngx_string(\"vod_notification_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, notification_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_dynamic_clip_map_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, dynamic_clip_map_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_source_clip_map_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, source_clip_map_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_redirect_segments_url\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, redirect_segments_url),\n\tNULL },\n\n\t{ ngx_string(\"vod_media_set_map_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, media_set_map_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_apply_dynamic_mapping\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, apply_dynamic_mapping),\n\tNULL },\n\n\t{ ngx_string(\"vod_media_set_override_json\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, media_set_override_json),\n\tNULL },\n\n\t// fallback upstream - only for local/mapped modes\n\t{ ngx_string(\"vod_fallback_upstream_location\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, fallback_upstream_location),\n\tNULL },\n\n\t{ ngx_string(\"vod_proxy_header_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, proxy_header.key),\n\tNULL },\n\n\t{ ngx_string(\"vod_proxy_header_value\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, proxy_header.value),\n\tNULL },\n\n\t// expires\n\t{ ngx_string(\"vod_expires\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_sec_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, expires[EXPIRES_TYPE_VOD]),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_expires_live\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_sec_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, expires[EXPIRES_TYPE_LIVE]),\n\tNULL },\n\n\t{ ngx_string(\"vod_expires_live_time_dependent\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_sec_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, expires[EXPIRES_TYPE_LIVE_TIME_DEPENDENT]),\n\tNULL },\n\n\t// last modified\n\t{ ngx_string(\"vod_last_modified\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_set_time_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, last_modified_time),\n\tNULL },\n\n\t{ ngx_string(\"vod_last_modified_types\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_1MORE,\n\tngx_http_types_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, last_modified_types_keys),\n\tNULL },\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\t// drm\n\t{ ngx_string(\"vod_drm_enabled\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_enabled),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_single_key\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_single_key),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_clear_lead_segment_count\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_clear_lead_segment_count),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_max_info_length\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_size_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_max_info_length),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_upstream_location\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_upstream_location),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_info_cache\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE123,\n\tngx_http_vod_cache_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_info_cache),\n\tNULL },\n\n\t{ ngx_string(\"vod_drm_request_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, drm_request_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_min_single_nalu_per_frame_segment\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, min_single_nalu_per_frame_segment),\n\tNULL },\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\t// request format settings\n\t{ ngx_string(\"vod_clip_to_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, clip_to_param_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_clip_from_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, clip_from_param_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_tracks_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, tracks_param_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_time_shift_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, time_shift_param_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_speed_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, speed_param_name),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_lang_param_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, lang_param_name),\n\tNULL },\n\n\t{ ngx_string(\"vod_performance_counters\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_vod_perf_counters_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, perf_counters_zone),\n\tNULL },\n\n\t{ ngx_string(\"vod_output_buffer_pool\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE2,\n\tngx_http_vod_buffer_pool_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, output_buffer_pool),\n\tNULL },\n\n#if (NGX_THREADS)\n\t{ ngx_string(\"vod_open_file_thread_pool\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_NOARGS | NGX_CONF_TAKE1,\n\tngx_http_vod_thread_pool_command,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\toffsetof(ngx_http_vod_loc_conf_t, open_file_thread_pool),\n\tNULL },\n#endif // NGX_THREADS\n\n#include \"ngx_http_vod_dash_commands.h\"\n#include \"ngx_http_vod_hds_commands.h\"\n#include \"ngx_http_vod_hls_commands.h\"\n#include \"ngx_http_vod_mss_commands.h\"\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n#include \"ngx_http_vod_thumb_commands.h\"\n#include \"ngx_http_vod_volume_map_commands.h\"\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n\tngx_null_command\n};\n\nngx_http_module_t  ngx_http_vod_module_ctx = {\n\tngx_http_vod_preconfiguration,      /* preconfiguration */\n\tngx_http_vod_init_parsers,          /* postconfiguration */\n\n\tNULL,                               /* create main configuration */\n\tNULL,                               /* init main configuration */\n\n\tNULL,                               /* create server configuration */\n\tNULL,                               /* merge server configuration */\n\n\tngx_http_vod_create_loc_conf,       /* create location configuration */\n\tngx_http_vod_merge_loc_conf         /* merge location configuration */\n};\n"
        },
        {
          "name": "ngx_http_vod_conf.h",
          "type": "blob",
          "size": 3.5830078125,
          "content": "#ifndef _NGX_HTTP_VOD_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_dash_conf.h\"\n#include \"ngx_http_vod_hds_conf.h\"\n#include \"ngx_http_vod_hls_conf.h\"\n#include \"ngx_http_vod_mss_conf.h\"\n#include \"vod/segmenter.h\"\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n#include \"ngx_http_vod_thumb_conf.h\"\n#include \"ngx_http_vod_volume_map_conf.h\"\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n// enum\nenum {\n\tEXPIRES_TYPE_VOD,\n\tEXPIRES_TYPE_LIVE,\n\tEXPIRES_TYPE_LIVE_TIME_DEPENDENT,\n\n\tEXPIRES_TYPE_COUNT\n};\n\nenum {\n\tCACHE_TYPE_VOD,\n\tCACHE_TYPE_LIVE,\n\n\tCACHE_TYPE_COUNT\n};\n\n// typedefs\nstruct ngx_http_vod_request_params_s;\n\nstruct ngx_http_vod_loc_conf_s {\n\t// config fields\n\tngx_http_vod_submodule_t submodule;\n\tngx_str_t upstream_location;\n\tngx_str_t remote_upstream_location;\n\tngx_int_t(*request_handler)(ngx_http_request_t *r);\n\tngx_str_t multi_uri_suffix;\n\tsegmenter_conf_t segmenter;\n\tngx_http_complex_value_t *secret_key;\n\tngx_http_complex_value_t *encryption_iv_seed;\n\tngx_http_complex_value_t *base_url;\n\tngx_http_complex_value_t *segments_base_url;\n\tngx_buffer_cache_t* metadata_cache;\n\tngx_buffer_cache_t* response_cache[CACHE_TYPE_COUNT];\n\tsize_t initial_read_size;\n\tsize_t max_metadata_size;\n\tsize_t max_frames_size;\n\tngx_uint_t max_frame_count;\n\tngx_uint_t segment_max_frame_count;\n\tsize_t cache_buffer_size;\n\tbuffer_pool_t* output_buffer_pool;\n\tsize_t max_upstream_headers_size;\n\tngx_flag_t ignore_edit_list;\n\tngx_flag_t parse_hdlr_name;\n\tngx_flag_t parse_udta_name;\n\tint parse_flags;\n\tngx_http_complex_value_t *upstream_extra_args;\n\tngx_buffer_cache_t* mapping_cache[CACHE_TYPE_COUNT];\n\tngx_buffer_cache_t* dynamic_mapping_cache;\n\tngx_str_t path_response_prefix;\n\tngx_str_t path_response_postfix;\n\tsize_t max_mapping_response_size;\n\tngx_http_complex_value_t* notification_uri;\n\tngx_http_complex_value_t* dynamic_clip_map_uri;\n\tngx_http_complex_value_t* source_clip_map_uri;\n\tngx_http_complex_value_t* redirect_segments_url;\n\tngx_http_complex_value_t* media_set_map_uri;\n\tngx_http_complex_value_t* apply_dynamic_mapping;\n\tngx_http_complex_value_t* media_set_override_json;\n\tngx_str_t fallback_upstream_location;\n\tngx_table_elt_t proxy_header;\n\tngx_flag_t force_playlist_type_vod;\n\tngx_flag_t force_continuous_timestamps;\n\tngx_flag_t force_sequence_index;\n\n\ttime_t expires[EXPIRES_TYPE_COUNT];\n\ttime_t last_modified_time;\n\tngx_hash_t  last_modified_types;\n\tngx_array_t *last_modified_types_keys;\n\n\tngx_flag_t drm_enabled;\n\tngx_flag_t drm_single_key;\n\tngx_uint_t drm_clear_lead_segment_count;\n\tngx_str_t drm_upstream_location;\n\tsize_t drm_max_info_length;\n\tngx_buffer_cache_t* drm_info_cache;\n\tngx_http_complex_value_t *drm_request_uri;\n\tngx_uint_t min_single_nalu_per_frame_segment;\n\n\tngx_str_t clip_to_param_name;\n\tngx_str_t clip_from_param_name;\n\tngx_str_t tracks_param_name;\n\tngx_str_t time_shift_param_name;\n\tngx_str_t speed_param_name;\n\tngx_str_t lang_param_name;\n\n\tngx_shm_zone_t* perf_counters_zone;\n\n#if (NGX_THREADS)\n\tngx_thread_pool_t *open_file_thread_pool;\n#endif // NGX_THREADS\n\n\t// derived fields\n\tngx_hash_t uri_params_hash;\n\tngx_hash_t pd_uri_params_hash;\n\n\t// submodules\n\tngx_http_vod_dash_loc_conf_t dash;\n\tngx_http_vod_hds_loc_conf_t hds;\n\tngx_http_vod_hls_loc_conf_t hls;\n\tngx_http_vod_mss_loc_conf_t mss;\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n\tngx_http_vod_thumb_loc_conf_t thumb;\n\tngx_http_vod_volume_map_loc_conf_t volume_map;\n#endif // NGX_HAVE_LIB_AV_CODEC\n};\n\ntypedef struct ngx_http_vod_loc_conf_s ngx_http_vod_loc_conf_t;\n\n// globals\nextern ngx_http_module_t ngx_http_vod_module_ctx;\nextern ngx_command_t ngx_http_vod_commands[];\n\n#endif // _NGX_HTTP_VOD_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_dash.c",
          "type": "blob",
          "size": 20.359375,
          "content": "#include <ngx_http.h>\n#include <ngx_md5.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/dash/dash_packager.h\"\n#include \"vod/mkv/mkv_builder.h\"\n#include \"vod/mp4/mp4_fragment.h\"\n#include \"vod/mp4/mp4_init_segment.h\"\n#include \"vod/subtitle/webvtt_builder.h\"\n#include \"vod/subtitle/ttml_builder.h\"\n#include \"vod/udrm.h\"\n\n#if (NGX_HAVE_OPENSSL_EVP)\n#include \"vod/dash/edash_packager.h\"\n#endif // NGX_HAVE_OPENSSL_EVP\n\n// constants\n#define SUPPORTED_CODECS_MP4 (VOD_CODEC_FLAG(AVC) | VOD_CODEC_FLAG(HEVC) | VOD_CODEC_FLAG(AAC) | VOD_CODEC_FLAG(AC3) | VOD_CODEC_FLAG(EAC3))\n#define SUPPORTED_CODECS_WEBM (VOD_CODEC_FLAG(VP8) | VOD_CODEC_FLAG(VP9) | VOD_CODEC_FLAG(AV1) | VOD_CODEC_FLAG(VORBIS) | VOD_CODEC_FLAG(OPUS))\n#define SUPPORTED_CODECS (SUPPORTED_CODECS_MP4 | SUPPORTED_CODECS_WEBM)\n\nngx_conf_enum_t  dash_manifest_formats[] = {\n\t{ ngx_string(\"segmentlist\"), FORMAT_SEGMENT_LIST },\n\t{ ngx_string(\"segmenttemplate\"), FORMAT_SEGMENT_TEMPLATE },\n\t{ ngx_string(\"segmenttimeline\"), FORMAT_SEGMENT_TIMELINE },\n\t{ ngx_null_string, 0 }\n};\n\nngx_conf_enum_t  dash_subtitle_formats[] = {\n\t{ ngx_string(\"webvtt\"), SUBTITLE_FORMAT_WEBVTT },\n\t{ ngx_string(\"smpte-tt\"), SUBTITLE_FORMAT_SMPTE_TT },\n\t{ ngx_null_string, 0 }\n};\n\n// content types\nstatic u_char mpd_content_type[] = \"application/dash+xml\";\nstatic u_char webm_audio_content_type[] = \"audio/webm\";\nstatic u_char webm_video_content_type[] = \"video/webm\";\nstatic u_char vtt_content_type[] = \"text/vtt\";\n\n// file extensions\nstatic const u_char manifest_file_ext[] = \".mpd\";\nstatic const u_char init_segment_file_ext[] = \".mp4\";\nstatic const u_char fragment_file_ext[] = \".m4s\";\nstatic const u_char webm_file_ext[] = \".webm\";\nstatic const u_char vtt_file_ext[] = \".vtt\";\nstatic const u_char ttml_file_ext[] = \".ttml\";\n\nstatic ngx_int_t \nngx_http_vod_dash_handle_manifest(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tdash_manifest_extensions_t extensions;\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\tngx_str_t file_uri;\n\n\tif (conf->dash.absolute_manifest_urls)\n\t{\n\t\tif (conf->dash.mpd_config.manifest_format == FORMAT_SEGMENT_LIST)\n\t\t{\n\t\t\tfile_uri.data = NULL;\n\t\t\tfile_uri.len = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfile_uri = submodule_context->r->uri;\n\t\t}\n\n\t\trc = ngx_http_vod_get_base_url(submodule_context->r, conf->base_url, &file_uri, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tif (conf->drm_enabled)\n\t{\n\t\trc = edash_packager_build_mpd(\n\t\t\t&submodule_context->request_context,\n\t\t\t&conf->dash.mpd_config,\n\t\t\t&base_url,\n\t\t\t&submodule_context->media_set,\n\t\t\tconf->drm_single_key,\n\t\t\tresponse);\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\tvod_memzero(&extensions, sizeof(extensions));\n\n\t\trc = dash_packager_build_mpd(\n\t\t\t&submodule_context->request_context,\n\t\t\t&conf->dash.mpd_config,\n\t\t\t&base_url,\n\t\t\t&submodule_context->media_set,\n\t\t\t&extensions,\n\t\t\tresponse);\n\t}\n\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_handle_manifest: (e)dash_packager_build_mpd failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = mpd_content_type;\n\tcontent_type->len = sizeof(mpd_content_type) - 1;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_mp4_handle_init_segment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tuint32_t flags;\n\n\tif (conf->drm_enabled)\n\t{\n\t\tflags = 0;\n\n\t\tif (conf->dash.init_mp4_pssh)\n\t\t{\n\t\t\tflags |= EDASH_INIT_MP4_WRITE_PSSH;\n\t\t}\n\n\t\tif (conf->drm_clear_lead_segment_count > 0)\n\t\t{\n\t\t\tflags |= EDASH_INIT_MP4_HAS_CLEAR_LEAD;\n\t\t}\n\n\t\trc = edash_packager_build_init_mp4(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tflags,\n\t\t\tngx_http_vod_submodule_size_only(submodule_context),\n\t\t\tresponse);\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\trc = mp4_init_segment_build(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tngx_http_vod_submodule_size_only(submodule_context),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tresponse);\n\t}\n\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_mp4_handle_init_segment: (e)dash_packager_build_init_mp4 failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tmp4_fragment_get_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_mp4_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tdash_fragment_header_extensions_t header_extensions;\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tfragment_writer_state_t* state;\n\tvod_status_t rc;\n\tbool_t reuse_buffers = FALSE;\n\tbool_t size_only = ngx_http_vod_submodule_size_only(submodule_context);\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tsegment_writer_t drm_writer;\n\n\tif (conf->drm_enabled &&\n\t\tsubmodule_context->request_params.segment_index >= conf->drm_clear_lead_segment_count)\n\t{\n\t\tdrm_writer = *segment_writer;\t\t// must not change segment_writer, otherwise the header will be encrypted\n\n\t\t// encyrpted fragment\n\t\trc = edash_packager_get_fragment_writer(\n\t\t\t&drm_writer,\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\tconf->min_single_nalu_per_frame_segment > 0 && \n\t\t\t\tsubmodule_context->media_set.initial_segment_clip_relative_index >= conf->min_single_nalu_per_frame_segment - 1,\n\t\t\tsubmodule_context->media_set.sequences[0].encryption_key,\t\t// iv\n\t\t\tsize_only,\n\t\t\toutput_buffer,\n\t\t\tresponse_size);\n\t\tswitch (rc)\n\t\t{\n\t\tcase VOD_DONE:\t\t// passthrough\n\t\t\tbreak;\n\n\t\tcase VOD_OK:\n\t\t\tsegment_writer = &drm_writer;\n\t\t\treuse_buffers = TRUE;\t\t// mp4_cenc_encrypt allocates new buffers\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_dash_mp4_init_frame_processor: edash_packager_get_fragment_writer failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\t// unencrypted\n\t\tngx_memzero(&header_extensions, sizeof(header_extensions));\n\n\t\trc = dash_packager_build_fragment_header(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\tconf->drm_enabled ? 2 : 0,\t// sample description index\n\t\t\t&header_extensions,\n\t\t\tsize_only,\n\t\t\toutput_buffer,\n\t\t\tresponse_size);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_dash_mp4_init_frame_processor: dash_packager_build_fragment_header failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t}\n\n\t// initialize the frame processor\n\tif (!size_only || *response_size == 0)\n\t{\n\t\trc = mp4_fragment_frame_writer_init(\n\t\t\t&submodule_context->request_context,\n\t\t\tsubmodule_context->media_set.sequences,\n\t\t\tsegment_writer->write_tail,\n\t\t\tsegment_writer->context,\n\t\t\treuse_buffers,\n\t\t\t&state);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_dash_mp4_init_frame_processor: mp4_fragment_frame_writer_init failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\n\t\t*frame_processor = (ngx_http_vod_frame_processor_t)mp4_fragment_frame_writer_process;\n\t\t*frame_processor_state = state;\n\t}\n\n\t// set the 'Content-type' header\n\tmp4_fragment_get_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic void\nngx_http_vod_dash_get_webm_content_type(\n\tbool_t video,\n\tngx_str_t* content_type)\n{\n\tif (video)\n\t{\n\t\tcontent_type->data = webm_video_content_type;\n\t\tcontent_type->len = sizeof(webm_video_content_type) - 1;\n\t}\n\telse\n\t{\n\t\tcontent_type->data = webm_audio_content_type;\n\t\tcontent_type->len = sizeof(webm_audio_content_type) - 1;\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_webm_handle_init_segment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\tngx_md5_t md5;\n\tngx_str_t* uri;\n\tuint64_t track_uid;\n\tu_char uri_key[16];\n\n\t// calculate a uid for track based on the request uri\n\turi = &submodule_context->r->uri;\n\tngx_md5_init(&md5);\n\tngx_md5_update(&md5, uri->data, uri->len);\n\tngx_md5_final(uri_key, &md5);\n\tngx_memcpy(&track_uid, uri_key, sizeof(track_uid));\n\n\trc = mkv_build_init_segment(\n\t\t&submodule_context->request_context,\n\t\tsubmodule_context->media_set.sequences[0].filtered_clips[0].first_track,\n\t\ttrack_uid,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_webm_handle_init_segment: mkv_build_init_segment failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tngx_http_vod_dash_get_webm_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_webm_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tmkv_encryption_type_t encryption_type;\n\tvod_status_t rc;\n\n\tif (conf->drm_enabled)\n\t{\n\t\tif (submodule_context->request_params.segment_index >= conf->drm_clear_lead_segment_count)\n\t\t{\n\t\t\tencryption_type = MKV_ENCRYPTED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryption_type = MKV_CLEAR_LEAD;\n\t\t}\n\t}\n\telse\n\t{\n\t\tencryption_type = MKV_CLEAR;\n\t}\n\n\trc = mkv_builder_frame_writer_init(\n\t\t&submodule_context->request_context,\n\t\tsubmodule_context->media_set.sequences,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\tFALSE,\n\t\tencryption_type,\n\t\tsubmodule_context->media_set.sequences[0].encryption_key,\n\t\toutput_buffer,\n\t\tresponse_size,\n\t\tframe_processor_state);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_webm_init_frame_processor: mkv_builder_frame_writer_init failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\t*frame_processor = (ngx_http_vod_frame_processor_t)mkv_builder_frame_writer_process;\n\n\t// set the 'Content-type' header\n\tngx_http_vod_dash_get_webm_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_handle_vtt_file(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n\trc = webvtt_builder_build(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tsubmodule_context->media_set.use_discontinuity,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_handle_vtt_file: webvtt_builder_build failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->len = sizeof(vtt_content_type) - 1;\n\tcontent_type->data = (u_char *)vtt_content_type;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_handle_ttml_fragment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tdash_fragment_header_extensions_t header_extensions;\n\tvod_status_t rc;\n\tsize_t ignore;\n\n\tngx_memzero(&header_extensions, sizeof(header_extensions));\n\n\theader_extensions.mdat_atom_max_size = ttml_builder_get_max_size(&submodule_context->media_set);\n\theader_extensions.write_mdat_atom_callback = (dash_write_mdat_atom_callback_t)ttml_builder_write;\n\theader_extensions.write_mdat_atom_context = &submodule_context->media_set;\n\n\trc = dash_packager_build_fragment_header(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tsubmodule_context->request_params.segment_index,\n\t\t0,\n\t\t&header_extensions,\n\t\tFALSE,\n\t\tresponse,\n\t\t&ignore);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_dash_handle_ttml_fragment: dash_packager_build_fragment_header failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tmp4_fragment_get_content_type(TRUE, content_type);\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t dash_manifest_request = {\n\tREQUEST_FLAG_TIME_DEPENDENT_ON_LIVE,\n\tPARSE_FLAG_DURATION_LIMITS_AND_TOTAL_SIZE | PARSE_FLAG_INITIAL_PTS_DELAY | PARSE_FLAG_CODEC_NAME,\n\tREQUEST_CLASS_MANIFEST,\n\tSUPPORTED_CODECS | VOD_CODEC_FLAG(WEBVTT),\n\tDASH_TIMESCALE,\n\tngx_http_vod_dash_handle_manifest,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t dash_mp4_init_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_BASIC_METADATA_ONLY | PARSE_FLAG_SAVE_RAW_ATOMS,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS_MP4 | VOD_CODEC_FLAG(WEBVTT),\n\tDASH_TIMESCALE,\n\tngx_http_vod_dash_mp4_handle_init_segment,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t dash_mp4_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_MP4,\n\tDASH_TIMESCALE,\n\tNULL,\n\tngx_http_vod_dash_mp4_init_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t edash_mp4_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_INITIAL_PTS_DELAY | PARSE_FLAG_PARSED_EXTRA_DATA,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_MP4,\n\tDASH_TIMESCALE,\n\tNULL,\n\tngx_http_vod_dash_mp4_init_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t dash_webm_init_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_BASIC_METADATA_ONLY,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS_WEBM,\n\tDASH_TIMESCALE,\n\tngx_http_vod_dash_webm_handle_init_segment,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t dash_webm_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_WEBM,\n\tDASH_TIMESCALE,\n\tNULL,\n\tngx_http_vod_dash_webm_init_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t dash_webvtt_file_request = {\n\tREQUEST_FLAG_SINGLE_TRACK | REQUEST_FLAG_PARSE_ALL_CLIPS,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_OTHER,\n\tVOD_CODEC_FLAG(WEBVTT),\n\tWEBVTT_TIMESCALE,\n\tngx_http_vod_dash_handle_vtt_file,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t dash_ttml_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_SEGMENT,\n\tVOD_CODEC_FLAG(WEBVTT),\n\tTTML_TIMESCALE,\n\tngx_http_vod_dash_handle_ttml_fragment,\n\tNULL,\n};\n\nstatic void\nngx_http_vod_dash_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_dash_loc_conf_t *conf)\n{\n\tconf->absolute_manifest_urls = NGX_CONF_UNSET;\n\tconf->init_mp4_pssh = NGX_CONF_UNSET;\n\tconf->mpd_config.manifest_format = NGX_CONF_UNSET_UINT;\n\tconf->mpd_config.subtitle_format = NGX_CONF_UNSET_UINT;\n\tconf->mpd_config.duplicate_bitrate_threshold = NGX_CONF_UNSET_UINT;\n\tconf->mpd_config.write_playready_kid = NGX_CONF_UNSET;\n\tconf->mpd_config.use_base_url_tag = NGX_CONF_UNSET;\n}\n\nstatic char *\nngx_http_vod_dash_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_dash_loc_conf_t *conf,\n\tngx_http_vod_dash_loc_conf_t *prev)\n{\n\tngx_conf_merge_value(conf->absolute_manifest_urls, prev->absolute_manifest_urls, 1);\n\tngx_conf_merge_value(conf->init_mp4_pssh, prev->init_mp4_pssh, 1);\n\n\tngx_conf_merge_str_value(conf->manifest_file_name_prefix, prev->manifest_file_name_prefix, \"manifest\");\n\tngx_conf_merge_str_value(conf->mpd_config.profiles, prev->mpd_config.profiles, \"urn:mpeg:dash:profile:isoff-main:2011\");\n\tngx_conf_merge_str_value(conf->mpd_config.init_file_name_prefix, prev->mpd_config.init_file_name_prefix, \"init\");\n\tngx_conf_merge_str_value(conf->mpd_config.fragment_file_name_prefix, prev->mpd_config.fragment_file_name_prefix, \"fragment\");\n\tngx_conf_merge_str_value(conf->mpd_config.subtitle_file_name_prefix, prev->mpd_config.subtitle_file_name_prefix, \"sub\");\n\tngx_conf_merge_uint_value(conf->mpd_config.manifest_format, prev->mpd_config.manifest_format, FORMAT_SEGMENT_TIMELINE);\n\tngx_conf_merge_uint_value(conf->mpd_config.subtitle_format, prev->mpd_config.subtitle_format, SUBTITLE_FORMAT_WEBVTT);\n\tngx_conf_merge_uint_value(conf->mpd_config.duplicate_bitrate_threshold, prev->mpd_config.duplicate_bitrate_threshold, 4096);\n\tngx_conf_merge_value(conf->mpd_config.write_playready_kid, prev->mpd_config.write_playready_kid, 0);\n\tngx_conf_merge_value(conf->mpd_config.use_base_url_tag, prev->mpd_config.use_base_url_tag, 0);\n\n\treturn NGX_CONF_OK;\n}\n\nstatic int\nngx_http_vod_dash_get_file_path_components(ngx_str_t* uri)\n{\n\treturn 1;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tngx_int_t rc;\n\tuint32_t flags;\n\n\t// fragment\n\tif (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.fragment_file_name_prefix, fragment_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.fragment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(fragment_file_ext) - 1);\n\t\t*request = conf->drm_enabled ? &edash_mp4_fragment_request : &dash_mp4_fragment_request;\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// init segment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.init_file_name_prefix, init_segment_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.init_file_name_prefix.len;\n\t\tend_pos -= (sizeof(init_segment_file_ext) - 1);\n\t\t*request = &dash_mp4_init_request;\n\t\tflags = PARSE_FILE_NAME_ALLOW_CLIP_INDEX;\n\t}\n\t// webm fragment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.fragment_file_name_prefix, webm_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.fragment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(webm_file_ext) - 1);\n\t\t*request = &dash_webm_fragment_request;\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// webm init segment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.init_file_name_prefix, webm_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.init_file_name_prefix.len;\n\t\tend_pos -= (sizeof(webm_file_ext) - 1);\n\t\t*request = &dash_webm_init_request;\n\t\tflags = PARSE_FILE_NAME_ALLOW_CLIP_INDEX;\n\t}\n\t// manifest\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.manifest_file_name_prefix, manifest_file_ext))\n\t{\n\t\tstart_pos += conf->dash.manifest_file_name_prefix.len;\n\t\tend_pos -= (sizeof(manifest_file_ext) - 1);\n\t\t*request = &dash_manifest_request;\n\t\tflags = PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE;\n\t}\n\t// smpte fragment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.fragment_file_name_prefix, ttml_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.fragment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(ttml_file_ext) - 1);\n\t\t*request = &dash_ttml_request;\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// webvtt file\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->dash.mpd_config.subtitle_file_name_prefix, vtt_file_ext))\n\t{\n\t\tstart_pos += conf->dash.mpd_config.subtitle_file_name_prefix.len;\n\t\tend_pos -= (sizeof(vtt_file_ext) - 1);\n\t\t*request = &dash_webvtt_file_request;\n\t\tflags = PARSE_FILE_NAME_ALLOW_CLIP_INDEX;\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_dash_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\t// parse the required tracks string\n\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, flags, request_params);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_dash_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dash_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tvod_status_t rc;\n\n\trc = udrm_parse_response(\n\t\t&submodule_context->request_context,\n\t\tdrm_info,\n\t\tTRUE,\n\t\toutput);\n\tif (rc != VOD_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nDEFINE_SUBMODULE(dash);\n"
        },
        {
          "name": "ngx_http_vod_dash.h",
          "type": "blob",
          "size": 0.2197265625,
          "content": "#ifndef _NGX_HTTP_VOD_DASH_H_INCLUDED_\n#define _NGX_HTTP_VOD_DASH_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t dash;\n\n#endif // _NGX_HTTP_VOD_DASH_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_dash_commands.h",
          "type": "blob",
          "size": 3.29296875,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, dash)\n\n\t{ ngx_string(\"vod_dash_absolute_manifest_urls\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, absolute_manifest_urls),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_dash_init_mp4_pssh\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, init_mp4_pssh),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_manifest_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, manifest_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_profiles\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.profiles),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_init_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.init_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_fragment_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.fragment_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_subtitle_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.subtitle_file_name_prefix),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_dash_manifest_format\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_enum_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.manifest_format),\n\tdash_manifest_formats },\n\n\t{ ngx_string(\"vod_dash_subtitle_format\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_enum_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.subtitle_format),\n\tdash_subtitle_formats },\n\n\t{ ngx_string(\"vod_dash_duplicate_bitrate_threshold\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.duplicate_bitrate_threshold),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_dash_write_playready_kid\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.write_playready_kid),\n\tNULL },\n\n\t{ ngx_string(\"vod_dash_use_base_url_tag\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_dash_loc_conf_t, mpd_config.use_base_url_tag),\n\tNULL },\n\n#undef BASE_OFFSET\n"
        },
        {
          "name": "ngx_http_vod_dash_conf.h",
          "type": "blob",
          "size": 0.501953125,
          "content": "#ifndef _NGX_HTTP_VOD_DASH_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_DASH_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"vod/dash/dash_packager.h\"\n\n// typedefs\ntypedef struct\n{\n\tngx_str_t manifest_file_name_prefix;\n\tngx_flag_t absolute_manifest_urls;\n\tngx_flag_t init_mp4_pssh;\n\tdash_manifest_config_t mpd_config;\n} ngx_http_vod_dash_loc_conf_t;\n\n// globals\nextern ngx_conf_enum_t dash_manifest_formats[];\n\nextern ngx_conf_enum_t dash_subtitle_formats[];\n\n#endif // _NGX_HTTP_VOD_DASH_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_hds.c",
          "type": "blob",
          "size": 8.734375,
          "content": "#include <ngx_http.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/hds/hds_manifest.h\"\n#include \"vod/hds/hds_fragment.h\"\n#include \"vod/udrm.h\"\n\n// constants\n#define SUPPORTED_CODECS (VOD_CODEC_FLAG(AVC) | VOD_CODEC_FLAG(AAC) | VOD_CODEC_FLAG(MP3))\n\n// content types\nstatic u_char f4m_content_type[] = \"video/f4m\";\nstatic u_char f4f_content_type[] = \"video/f4f\";\nstatic u_char abst_content_type[] = \"video/abst\";\n\n// file extensions\nstatic const u_char manifest_file_ext[] = \".f4m\";\nstatic const u_char bootstrap_file_ext[] = \".abst\";\n\nstatic ngx_int_t \nngx_http_vod_hds_handle_manifest(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\n\tif (conf->hds.absolute_manifest_urls)\n\t{\n\t\trc = ngx_http_vod_get_base_url(submodule_context->r, conf->base_url, &submodule_context->r->uri, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = hds_packager_build_manifest(\n\t\t&submodule_context->request_context,\n\t\t&conf->hds.manifest_config,\n\t\t&base_url,\n\t\t&submodule_context->r->uri,\n\t\t&submodule_context->media_set,\n\t\tconf->drm_enabled,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hds_handle_manifest: hds_packager_build_manifest failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = f4m_content_type;\n\tcontent_type->len = sizeof(f4m_content_type) - 1;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hds_handle_bootstrap(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\t\n\trc = hds_packager_build_bootstrap(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hds_handle_bootstrap: hds_packager_build_bootstrap failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = abst_content_type;\n\tcontent_type->len = sizeof(abst_content_type) - 1;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hds_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\thds_muxer_state_t* state;\n\thds_encryption_params_t encryption_params;\n\tvod_status_t rc;\n\tdrm_info_t* drm_info;\n\n\tif (submodule_context->conf->drm_enabled)\n\t{\n\t\tdrm_info = submodule_context->media_set.sequences[0].drm_info;\n\n\t\tencryption_params.type = HDS_ENC_SELECTIVE;\n\t\tencryption_params.key = drm_info->key;\n\t\tencryption_params.iv = submodule_context->media_set.sequences[0].encryption_key;\n\t}\n\telse\n\t{\n\t\tencryption_params.type = HDS_ENC_NONE;\n\t}\n\n\trc = hds_muxer_init_fragment(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->conf->hds.fragment_config,\n\t\t&encryption_params,\n\t\tsubmodule_context->request_params.segment_index,\n\t\t&submodule_context->media_set,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\tngx_http_vod_submodule_size_only(submodule_context),\n\t\toutput_buffer,\n\t\tresponse_size,\n\t\t&state);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hds_init_frame_processor: hds_muxer_init_fragment failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\t*frame_processor = (ngx_http_vod_frame_processor_t)hds_muxer_process_frames;\n\t*frame_processor_state = state;\n\n\t// set the 'Content-type' header\n\tcontent_type->len = sizeof(f4f_content_type) - 1;\n\tcontent_type->data = (u_char *)f4f_content_type;\n\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t hds_manifest_request = {\n\t0,\n\tPARSE_FLAG_DURATION_LIMITS_AND_TOTAL_SIZE,\n\tREQUEST_CLASS_MANIFEST,\n\tSUPPORTED_CODECS,\n\tHDS_TIMESCALE,\n\tngx_http_vod_hds_handle_manifest,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hds_bootstrap_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE | REQUEST_FLAG_TIME_DEPENDENT_ON_LIVE,\n\t0,\n\tREQUEST_CLASS_MANIFEST,\n\tSUPPORTED_CODECS,\n\tHDS_TIMESCALE,\n\tngx_http_vod_hds_handle_bootstrap,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hds_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS,\n\tHDS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_hds_init_frame_processor,\n};\n\nstatic void\nngx_http_vod_hds_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_hds_loc_conf_t *conf)\n{\n\tconf->absolute_manifest_urls = NGX_CONF_UNSET;\n\tconf->fragment_config.generate_moof_atom = NGX_CONF_UNSET;\n}\n\nstatic char *\nngx_http_vod_hds_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_hds_loc_conf_t *conf,\n\tngx_http_vod_hds_loc_conf_t *prev)\n{\n\tngx_conf_merge_value(conf->absolute_manifest_urls, prev->absolute_manifest_urls, 0);\n\tngx_conf_merge_str_value(conf->manifest_config.fragment_file_name_prefix, prev->manifest_config.fragment_file_name_prefix, \"frag\");\n\tngx_conf_merge_str_value(conf->manifest_config.bootstrap_file_name_prefix, prev->manifest_config.bootstrap_file_name_prefix, \"bootstrap\");\n\tngx_conf_merge_str_value(conf->manifest_file_name_prefix, prev->manifest_file_name_prefix, \"manifest\");\n\tngx_conf_merge_value(conf->fragment_config.generate_moof_atom, prev->fragment_config.generate_moof_atom, 1);\n\n\treturn NGX_CONF_OK;\n}\n\nstatic int\nngx_http_vod_hds_get_file_path_components(ngx_str_t* uri)\n{\n\treturn 1;\n}\n\nstatic ngx_int_t\nngx_http_vod_hds_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tuint32_t flags = 0;\n\tngx_int_t rc;\n\n\t// fragment request\n\tif (ngx_http_vod_starts_with(start_pos, end_pos, &conf->hds.manifest_config.fragment_file_name_prefix))\n\t{\n\t\t// sample fragment file name: frag-f3-v1-a1-Seg1-Frag1\n\t\tstart_pos += conf->hds.manifest_config.fragment_file_name_prefix.len;\n\n\t\t// parse the fragment index\n\t\tend_pos = ngx_http_vod_extract_uint32_token_reverse(start_pos, end_pos, &request_params->segment_index);\n\t\tif (request_params->segment_index == 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_hds_parse_uri_file_name: failed to parse fragment index\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\trequest_params->segment_index--;\t\t// convert to 0-based\n\n\t\t// extract the '-Seg1-Frag' part\n\t\tend_pos -= sizeof(\"-Seg1-Frag\") - 1;\n\t\tif (end_pos < start_pos ||\n\t\t\tngx_memcmp(end_pos, \"-Seg1-Frag\", sizeof(\"-Seg1-Frag\") - 1) != 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_hds_parse_uri_file_name: invalid segment / fragment requested\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\t*request = &hds_fragment_request;\n\t}\n\t// bootstrap request\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hds.manifest_config.bootstrap_file_name_prefix, bootstrap_file_ext))\n\t{\n\t\tstart_pos += conf->hds.manifest_config.bootstrap_file_name_prefix.len;\n\t\tend_pos -= (sizeof(bootstrap_file_ext) - 1);\n\t\t*request = &hds_bootstrap_request;\n\t}\n\t// manifest request\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hds.manifest_file_name_prefix, manifest_file_ext))\n\t{\n\t\tstart_pos += conf->hds.manifest_file_name_prefix.len;\n\t\tend_pos -= (sizeof(manifest_file_ext) - 1);\n\t\t*request = &hds_manifest_request;\n\t\tflags = PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE;\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_hds_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\t// parse the required tracks string\n\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, flags, request_params);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_hds_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hds_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tdrm_info_t* result;\n\tngx_int_t rc;\n\t\n\trc = udrm_parse_response(\n\t\t&submodule_context->request_context,\n\t\tdrm_info,\n\t\tFALSE,\n\t\t(void**)&result);\n\tif (rc != VOD_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\tif (result->pssh_array.count != 1)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hds_parse_drm_info: pssh array must contain a single element\");\n\t\treturn NGX_ERROR;\n\t}\n\n\t*output = result;\n\n\treturn NGX_OK;\n}\n\nDEFINE_SUBMODULE(hds);\n"
        },
        {
          "name": "ngx_http_vod_hds.h",
          "type": "blob",
          "size": 0.2158203125,
          "content": "#ifndef _NGX_HTTP_VOD_HDS_H_INCLUDED_\n#define _NGX_HTTP_VOD_HDS_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t hds;\n\n#endif // _NGX_HTTP_VOD_HDS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_hds_commands.h",
          "type": "blob",
          "size": 1.1533203125,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, hds)\n\n\t{ ngx_string(\"vod_hds_absolute_manifest_urls\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hds_loc_conf_t, absolute_manifest_urls),\n\tNULL },\n\n\t{ ngx_string(\"vod_hds_manifest_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hds_loc_conf_t, manifest_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hds_fragment_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hds_loc_conf_t, manifest_config.fragment_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hds_generate_moof_atom\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hds_loc_conf_t, fragment_config.generate_moof_atom),\n\tNULL },\n\n#undef BASE_OFFSET\n"
        },
        {
          "name": "ngx_http_vod_hds_conf.h",
          "type": "blob",
          "size": 0.439453125,
          "content": "#ifndef _NGX_HTTP_VOD_HDS_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_HDS_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"vod/hds/hds_manifest.h\"\n#include \"vod/hds/hds_fragment.h\"\n\n// typedefs\ntypedef struct\n{\n\tngx_flag_t absolute_manifest_urls;\n\tngx_str_t manifest_file_name_prefix;\n\thds_manifest_config_t manifest_config;\n\thds_fragment_config_t fragment_config;\n} ngx_http_vod_hds_loc_conf_t;\n\n#endif // _NGX_HTTP_VOD_HDS_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_hls.c",
          "type": "blob",
          "size": 38.0771484375,
          "content": "#include <ngx_http.h>\n#include <ngx_md5.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/subtitle/webvtt_builder.h\"\n#include \"vod/hls/hls_muxer.h\"\n#include \"vod/mp4/mp4_muxer.h\"\n#include \"vod/mp4/mp4_fragment.h\"\n#include \"vod/mp4/mp4_init_segment.h\"\n#include \"vod/udrm.h\"\n\n#if (NGX_HAVE_OPENSSL_EVP)\n#include \"vod/dash/edash_packager.h\"\n#include \"vod/mp4/mp4_cbcs_encrypt.h\"\n#include \"vod/hls/aes_cbc_encrypt.h\"\n#endif // NGX_HAVE_OPENSSL_EVP\n\n// constants\n#define SUPPORTED_CODECS_MP4 \\\n\t(VOD_CODEC_FLAG(AVC) | \\\n\tVOD_CODEC_FLAG(HEVC) | \\\n\tVOD_CODEC_FLAG(AV1) | \\\n\tVOD_CODEC_FLAG(AAC) | \\\n\tVOD_CODEC_FLAG(AC3) | \\\n\tVOD_CODEC_FLAG(EAC3) | \\\n\tVOD_CODEC_FLAG(MP3) | \\\n\tVOD_CODEC_FLAG(DTS) | \\\n\tVOD_CODEC_FLAG(FLAC))\n\n#define SUPPORTED_CODECS_TS \\\n\t(VOD_CODEC_FLAG(AVC) | \\\n\tVOD_CODEC_FLAG(HEVC) | \\\n\tVOD_CODEC_FLAG(AAC) | \\\n\tVOD_CODEC_FLAG(AC3) | \\\n\tVOD_CODEC_FLAG(EAC3) | \\\n\tVOD_CODEC_FLAG(MP3) | \\\n\tVOD_CODEC_FLAG(DTS))\n\n#define SUPPORTED_CODECS (SUPPORTED_CODECS_MP4 | SUPPORTED_CODECS_TS)\n\n#define ID3_TEXT_JSON_FORMAT \"{\\\"timestamp\\\":%uL}%Z\"\n#define ID3_TEXT_JSON_SEQUENCE_ID_PREFIX_FORMAT \"{\\\"timestamp\\\":%uL,\\\"sequenceId\\\":\\\"\"\n#define ID3_TEXT_JSON_SEQUENCE_ID_SUFFIX \"\\\"}\"\n\n\n// content types\nstatic u_char m3u8_content_type[] = \"application/vnd.apple.mpegurl\";\nstatic u_char encryption_key_content_type[] = \"application/octet-stream\";\nstatic u_char mpeg_ts_content_type[] = \"video/MP2T\";\nstatic u_char vtt_content_type[] = \"text/vtt\";\n\nstatic const u_char ts_file_ext[] = \".ts\";\nstatic const u_char m4s_file_ext[] = \".m4s\";\nstatic const u_char vtt_file_ext[] = \".vtt\";\nstatic const u_char mp4_file_ext[] = \".mp4\";\nstatic const u_char m3u8_file_ext[] = \".m3u8\";\nstatic const u_char key_file_ext[] = \".key\";\n\n// constants\nstatic ngx_str_t empty_string = ngx_null_string;\n\nngx_conf_enum_t  hls_encryption_methods[] = {\n\t{ ngx_string(\"none\"), HLS_ENC_NONE },\n\t{ ngx_string(\"aes-128\"), HLS_ENC_AES_128 },\n\t{ ngx_string(\"sample-aes\"), HLS_ENC_SAMPLE_AES },\n\t{ ngx_string(\"sample-aes-cenc\"), HLS_ENC_SAMPLE_AES_CENC },\n\t{ ngx_null_string, 0 }\n};\n\nngx_conf_enum_t  hls_container_formats[] = {\n\t{ ngx_string(\"auto\"), HLS_CONTAINER_AUTO },\n\t{ ngx_string(\"mpegts\"), HLS_CONTAINER_MPEGTS },\n\t{ ngx_string(\"fmp4\"), HLS_CONTAINER_FMP4 },\n\t{ ngx_null_string, 0 }\n};\n\nstatic ngx_uint_t\nngx_http_vod_hls_get_container_format(\n\tngx_http_vod_hls_loc_conf_t* conf,\n\tmedia_set_t* media_set)\n{\n\tmedia_track_t* track;\n\n\tif (conf->m3u8_config.container_format != HLS_CONTAINER_AUTO)\n\t{\n\t\treturn conf->m3u8_config.container_format;\n\t}\n\n\ttrack = media_set->filtered_tracks;\n\tif ((track->media_info.media_type == MEDIA_TYPE_VIDEO && track->media_info.codec_id != VOD_CODEC_ID_AVC) ||\n\t\tconf->encryption_method == HLS_ENC_SAMPLE_AES_CENC)\n\t{\n\t\treturn HLS_CONTAINER_FMP4;\n\t}\n\n\treturn HLS_CONTAINER_MPEGTS;\n}\n\n#if (NGX_HAVE_OPENSSL_EVP)\n// some random salt to prevent the iv from being equal to key in case encryption_iv_seed is null\nstatic u_char iv_salt[] = { 0xa7, 0xc6, 0x17, 0xab, 0x52, 0x2c, 0x40, 0x3c, 0xf6, 0x8a };\n\nstatic void\nngx_http_vod_hls_init_encryption_iv(u_char* iv, uint32_t segment_index)\n{\n\tu_char* p;\n\n\t// the IV is the segment index in big endian\n\tvod_memzero(iv, AES_BLOCK_SIZE - sizeof(uint32_t));\n\tsegment_index++;\n\tp = iv + AES_BLOCK_SIZE - sizeof(uint32_t);\n\t*p++ = (u_char)(segment_index >> 24);\n\t*p++ = (u_char)(segment_index >> 16);\n\t*p++ = (u_char)(segment_index >> 8);\n\t*p++ = (u_char)(segment_index);\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_get_iv_seed(\n\tngx_http_vod_submodule_context_t* submodule_context, \n\tmedia_sequence_t* sequence,\n\tngx_str_t* result)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tngx_http_complex_value_t* value;\n\n\tif (conf->encryption_iv_seed != NULL)\n\t{\n\t\tvalue = conf->encryption_iv_seed;\n\t}\n\telse if (conf->secret_key != NULL)\n\t{\n\t\tvalue = conf->secret_key;\n\t}\n\telse\n\t{\n\t\t*result = sequence->mapped_uri;\n\t\treturn NGX_OK;\n\t}\n\n\tif (ngx_http_complex_value(\n\t\tsubmodule_context->r,\n\t\tvalue,\n\t\tresult) != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_get_iv_seed: ngx_http_complex_value failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_init_encryption_params(\n\thls_encryption_params_t* encryption_params,\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_uint_t container_format)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tmedia_sequence_t* sequence;\n\tdrm_info_t* drm_info;\n\tngx_str_t iv_seed;\n\tngx_md5_t md5;\n\tngx_int_t rc;\n\n\tencryption_params->type = conf->hls.encryption_method;\n\tif (encryption_params->type == HLS_ENC_NONE)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\tencryption_params->iv = encryption_params->iv_buf;\n\tencryption_params->return_iv = conf->hls.output_iv;\n\n\tsequence = &submodule_context->media_set.sequences[0];\n\n\tif (conf->drm_enabled)\n\t{\n\t\tdrm_info = sequence->drm_info;\n\t\tencryption_params->key = drm_info->key;\n\n\t\tif (drm_info->iv_set)\n\t\t{\n\t\t\tencryption_params->iv = drm_info->iv;\n\t\t\treturn NGX_OK;\n\t\t}\n\t}\n\telse\n\t{\n\t\tencryption_params->key = sequence->encryption_key;\n\t}\n\n\tif (container_format != HLS_CONTAINER_FMP4 || encryption_params->type != HLS_ENC_AES_128)\n\t{\n\t\tngx_http_vod_hls_init_encryption_iv(\n\t\t\tencryption_params->iv_buf,\n\t\t\tsubmodule_context->request_params.segment_index);\n\t\treturn NGX_OK;\n\t}\n\n\t// must generate an iv in this case\n\trc = ngx_http_vod_hls_get_iv_seed(\n\t\tsubmodule_context,\n\t\tsequence,\n\t\t&iv_seed);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tngx_md5_init(&md5);\n\tngx_md5_update(&md5, iv_salt, sizeof(iv_salt));\n\tngx_md5_update(&md5, iv_seed.data, iv_seed.len);\n\tngx_md5_final(encryption_params->iv_buf, &md5);\n\tencryption_params->return_iv = TRUE;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_init_segment_encryption(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_uint_t container_format,\n\thls_encryption_params_t* encryption_params)\n{\n\taes_cbc_encrypt_context_t* encrypted_write_context;\n\tbuffer_pool_t* buffer_pool;\n\tvod_status_t rc;\n\n\trc = ngx_http_vod_hls_init_encryption_params(encryption_params, submodule_context, container_format);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (encryption_params->type != HLS_ENC_AES_128)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\tif (container_format == HLS_CONTAINER_MPEGTS)\n\t{\n\t\tbuffer_pool = submodule_context->request_context.output_buffer_pool;\n\t}\n\telse\n\t{\n\t\t// Note: should not use buffer pool for fmp4 since the buffers have varying sizes\n\t\tbuffer_pool = NULL;\n\t}\n\n\trc = aes_cbc_encrypt_init(\n\t\t&encrypted_write_context,\n\t\t&submodule_context->request_context,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\tbuffer_pool,\n\t\tencryption_params->key,\n\t\tencryption_params->iv);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_init_segment_encryption: aes_cbc_encrypt_init failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tsegment_writer->write_tail = (write_callback_t)aes_cbc_encrypt_write;\n\tsegment_writer->context = encrypted_write_context;\n\treturn NGX_OK;\n}\n#endif // NGX_HAVE_OPENSSL_EVP\n\nstatic ngx_int_t\nngx_http_vod_hls_get_default_id3_data(ngx_http_vod_submodule_context_t* submodule_context, ngx_str_t* id3_data)\n{\n\tmedia_set_t* media_set;\n\tvod_str_t* sequence_id;\n\tint64_t timestamp;\n\tu_char* p;\n\tsize_t sequence_id_escape;\n\tsize_t data_size;\n\n\tmedia_set = &submodule_context->media_set;\n\tsequence_id = &media_set->sequences[0].id;\n\tif (sequence_id->len != 0)\n\t{\n\t\tsequence_id_escape = vod_escape_json(NULL, sequence_id->data, sequence_id->len);\n\t\tdata_size = sizeof(ID3_TEXT_JSON_SEQUENCE_ID_PREFIX_FORMAT) + VOD_INT64_LEN +\n\t\t\tsequence_id->len + sequence_id_escape +\n\t\t\tsizeof(ID3_TEXT_JSON_SEQUENCE_ID_SUFFIX);\n\t}\n\telse\n\t{\n\t\tsequence_id_escape = 0;\n\t\tdata_size = sizeof(ID3_TEXT_JSON_FORMAT) + VOD_INT64_LEN;\n\t}\n\n\ttimestamp = media_set_get_segment_time_millis(media_set);\n\n\tp = ngx_pnalloc(submodule_context->request_context.pool, data_size);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_get_default_id3_data: ngx_pnalloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_ALLOC_FAILED);\n\t}\n\n\tid3_data->data = p;\n\n\tif (sequence_id->len != 0)\n\t{\n\t\tp = vod_sprintf(p, ID3_TEXT_JSON_SEQUENCE_ID_PREFIX_FORMAT, timestamp);\n\t\tif (sequence_id_escape)\n\t\t{\n\t\t\tp = (u_char*)vod_escape_json(p, sequence_id->data, sequence_id->len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp = vod_copy(p, sequence_id->data, sequence_id->len);\n\t\t}\n\t\tp = vod_copy(p, ID3_TEXT_JSON_SEQUENCE_ID_SUFFIX, sizeof(ID3_TEXT_JSON_SEQUENCE_ID_SUFFIX));\n\n\t}\n\telse\n\t{\n\t\tp = vod_sprintf(p, ID3_TEXT_JSON_FORMAT, timestamp);\n\t}\n\n\tid3_data->len = p - id3_data->data;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_init_muxer_conf(ngx_http_vod_submodule_context_t* submodule_context, hls_mpegts_muxer_conf_t* conf)\n{\n\tngx_http_vod_hls_loc_conf_t* hls_conf;\n\n\thls_conf = &submodule_context->conf->hls;\n\n\tconf->interleave_frames = hls_conf->interleave_frames;\n\tconf->align_frames = hls_conf->align_frames;\n\tconf->align_pts = hls_conf->align_pts;\n\n\tif (!hls_conf->output_id3_timestamps)\n\t{\n\t\tconf->id3_data.data = NULL;\n\t\tconf->id3_data.len = 0;\n\t\treturn NGX_OK;\n\t}\n\n\tif (hls_conf->id3_data != NULL)\n\t{\n\t\tif (ngx_http_complex_value(\n\t\t\tsubmodule_context->r,\n\t\t\thls_conf->id3_data,\n\t\t\t&conf->id3_data) != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_init_muxer_conf: ngx_http_complex_value failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\treturn NGX_OK;\n\t}\n\n\treturn ngx_http_vod_hls_get_default_id3_data(submodule_context, &conf->id3_data);\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_handle_master_playlist(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\n\tif (conf->hls.absolute_master_urls)\n\t{\n\t\trc = ngx_http_vod_get_base_url(submodule_context->r, conf->base_url, &empty_string, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = m3u8_builder_build_master_playlist(\n\t\t&submodule_context->request_context,\n\t\t&conf->hls.m3u8_config,\n\t\tconf->hls.encryption_method,\n\t\t&base_url,\n\t\t&submodule_context->media_set,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_master_playlist: m3u8_builder_build_master_playlist failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = m3u8_content_type;\n\tcontent_type->len = sizeof(m3u8_content_type) - 1;\n\t\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t \nngx_http_vod_hls_handle_index_playlist(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\thls_encryption_params_t encryption_params;\n\tngx_uint_t container_format;\n\tngx_str_t segments_base_url = ngx_null_string;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\n\tif (conf->hls.absolute_index_urls)\n\t{\n\t\trc = ngx_http_vod_get_base_url(submodule_context->r, conf->base_url, &submodule_context->r->uri, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (conf->segments_base_url != NULL)\n\t\t{\n\t\t\trc = ngx_http_vod_get_base_url(\n\t\t\t\tsubmodule_context->r,\n\t\t\t\tconf->segments_base_url,\n\t\t\t\t&submodule_context->r->uri,\n\t\t\t\t&segments_base_url);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsegments_base_url = base_url;\n\t\t}\n\t}\n\n\tcontainer_format = ngx_http_vod_hls_get_container_format(\n\t\t&conf->hls, \n\t\t&submodule_context->media_set);\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\trc = ngx_http_vod_hls_init_encryption_params(&encryption_params, submodule_context, container_format);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (encryption_params.type != HLS_ENC_NONE)\n\t{\n\t\tif (conf->hls.encryption_key_uri != NULL)\n\t\t{\n\t\t\tif (ngx_http_complex_value(\n\t\t\t\tsubmodule_context->r,\n\t\t\t\tconf->hls.encryption_key_uri,\n\t\t\t\t&encryption_params.key_uri) != NGX_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_hls_handle_index_playlist: ngx_http_complex_value failed\");\n\t\t\t\treturn NGX_ERROR;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryption_params.key_uri.len = 0;\n\t\t}\n\t}\n#else\n\tencryption_params.type = HLS_ENC_NONE;\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\trc = m3u8_builder_build_index_playlist(\n\t\t&submodule_context->request_context,\n\t\t&conf->hls.m3u8_config,\n\t\t&base_url,\n\t\t&segments_base_url,\n\t\t&encryption_params,\n\t\tcontainer_format,\n\t\t&submodule_context->media_set,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_index_playlist: m3u8_builder_build_index_playlist failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = m3u8_content_type;\n\tcontent_type->len = sizeof(m3u8_content_type) - 1;\n\t\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_handle_iframe_playlist(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\thls_mpegts_muxer_conf_t muxer_conf;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\t\n\tif (conf->hls.encryption_method != HLS_ENC_NONE)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_iframe_playlist: iframes playlist not supported with encryption\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n\t}\n\n\tif (submodule_context->media_set.audio_filtering_needed)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_iframe_playlist: iframes playlist not supported with audio filtering\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n\t}\n\n\tif (conf->hls.absolute_iframe_urls)\n\t{\n\t\trc = ngx_http_vod_get_base_url(submodule_context->r, conf->base_url, &submodule_context->r->uri, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (ngx_http_vod_hls_get_container_format(\n\t\t&conf->hls,\n\t\t&submodule_context->media_set) == HLS_CONTAINER_FMP4)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_iframe_playlist: iframes playlist not supported with fmp4 container\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n\t}\n\n\trc = ngx_http_vod_hls_init_muxer_conf(submodule_context, &muxer_conf);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\trc = m3u8_builder_build_iframe_playlist(\n\t\t&submodule_context->request_context,\n\t\t&conf->hls.m3u8_config,\n\t\t&muxer_conf,\n\t\t&base_url,\n\t\t&submodule_context->media_set,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_iframe_playlist: m3u8_builder_build_iframe_playlist failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = m3u8_content_type;\n\tcontent_type->len = sizeof(m3u8_content_type) - 1;\n\t\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_handle_encryption_key(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tu_char* encryption_key;\n\n\tencryption_key = ngx_palloc(submodule_context->request_context.pool, BUFFER_CACHE_KEY_SIZE);\n\tif (encryption_key == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_encryption_key: ngx_palloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_ALLOC_FAILED);\n\t}\n\n\tngx_memcpy(encryption_key, submodule_context->media_set.sequences[0].encryption_key, BUFFER_CACHE_KEY_SIZE);\n\n\tresponse->data = encryption_key;\n\tresponse->len = BUFFER_CACHE_KEY_SIZE;\n\n\tcontent_type->data = encryption_key_content_type;\n\tcontent_type->len = sizeof(encryption_key_content_type) - 1;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_init_ts_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\thls_encryption_params_t encryption_params;\n\thls_mpegts_muxer_conf_t muxer_conf;\n\thls_muxer_state_t* state;\n\tvod_status_t rc;\n\tbool_t reuse_output_buffers;\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\trc = ngx_http_vod_hls_init_segment_encryption(\n\t\tsubmodule_context,\n\t\tsegment_writer,\n\t\tHLS_CONTAINER_MPEGTS,\n\t\t&encryption_params);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (encryption_params.type == HLS_ENC_SAMPLE_AES_CENC)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_init_ts_frame_processor: sample aes cenc not supported with mpeg ts container\");\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n\t}\n\n\treuse_output_buffers = encryption_params.type == HLS_ENC_AES_128;\n#else\n\tencryption_params.type = HLS_ENC_NONE;\n\treuse_output_buffers = FALSE;\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\trc = ngx_http_vod_hls_init_muxer_conf(submodule_context, &muxer_conf);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\trc = hls_muxer_init_segment(\n\t\t&submodule_context->request_context,\n\t\t&muxer_conf,\n\t\t&encryption_params,\n\t\tsubmodule_context->request_params.segment_index,\n\t\t&submodule_context->media_set,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\treuse_output_buffers,\n\t\tresponse_size, \n\t\toutput_buffer,\n\t\t&state);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_init_ts_frame_processor: hls_muxer_init failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tif (encryption_params.type == HLS_ENC_AES_128 && \n\t\t*response_size != 0)\n\t{\n\t\t*response_size = aes_round_up_to_block(*response_size);\n\t}\n\n\t*frame_processor = (ngx_http_vod_frame_processor_t)hls_muxer_process;\n\t*frame_processor_state = state;\n\n\tcontent_type->len = sizeof(mpeg_ts_content_type) - 1;\n\tcontent_type->data = (u_char *)mpeg_ts_content_type;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_handle_mp4_init_segment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tatom_writer_t* stsd_atom_writers = NULL;\n\tvod_status_t rc;\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\taes_cbc_encrypt_context_t* encrypted_write_context;\n\thls_encryption_params_t encryption_params;\n\tdrm_info_t* drm_info;\n\n\trc = ngx_http_vod_hls_init_encryption_params(&encryption_params, submodule_context, HLS_CONTAINER_FMP4);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tswitch (encryption_params.type)\n\t{\n\tcase HLS_ENC_SAMPLE_AES:\n\t\trc = mp4_init_segment_get_encrypted_stsd_writers(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tSCHEME_TYPE_CBCS,\n\t\t\tFALSE,\n\t\t\tNULL,\n\t\t\tencryption_params.iv,\n\t\t\t&stsd_atom_writers);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_handle_mp4_init_segment: mp4_init_segment_get_encrypted_stsd_writers failed %i (1)\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t\tbreak;\n\n\tcase HLS_ENC_SAMPLE_AES_CENC:\n\t\tdrm_info = (drm_info_t*)submodule_context->media_set.sequences[0].drm_info;\n\n\t\trc = mp4_init_segment_get_encrypted_stsd_writers(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tSCHEME_TYPE_CENC,\n\t\t\tFALSE,\n\t\t\tdrm_info->key_id,\n\t\t\tNULL,\n\t\t\t&stsd_atom_writers);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_handle_mp4_init_segment: mp4_init_segment_get_encrypted_stsd_writers failed %i (2)\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t\tbreak;\n\n\tdefault:;\n\t}\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\trc = mp4_init_segment_build(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tngx_http_vod_submodule_size_only(submodule_context),\n\t\tNULL,\n\t\tstsd_atom_writers,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_mp4_init_segment: mp4_init_segment_build failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tif (encryption_params.type == HLS_ENC_AES_128)\n\t{\n\t\trc = aes_cbc_encrypt_init(\n\t\t\t&encrypted_write_context,\n\t\t\t&submodule_context->request_context,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tencryption_params.key,\n\t\t\tencryption_params.iv);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_handle_mp4_init_segment: aes_cbc_encrypt_init failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\n\t\trc = aes_cbc_encrypt(\n\t\t\tencrypted_write_context,\n\t\t\tresponse,\n\t\t\tresponse,\n\t\t\tTRUE);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_handle_mp4_init_segment: aes_cbc_encrypt failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t}\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\tmp4_fragment_get_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_init_fmp4_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tdash_fragment_header_extensions_t header_extensions;\n\tfragment_writer_state_t* state;\n\tmp4_muxer_state_t* muxer_state;\n\tsegment_writer_t* segment_writers;\n\tvod_status_t rc;\n\tbool_t per_stream_writer;\n\tbool_t reuse_input_buffers = FALSE;\n\tbool_t size_only = ngx_http_vod_submodule_size_only(submodule_context);\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\thls_encryption_params_t encryption_params;\n\tsegment_writer_t drm_writer;\n\n\trc = ngx_http_vod_hls_init_segment_encryption(\n\t\tsubmodule_context,\n\t\tsegment_writer,\n\t\tHLS_CONTAINER_FMP4,\n\t\t&encryption_params);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\treuse_input_buffers = encryption_params.type != HLS_ENC_NONE;\n\n\tif (conf->hls.encryption_method == HLS_ENC_SAMPLE_AES)\n\t{\n\t\trc = mp4_cbcs_encrypt_get_writers(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tsegment_writer,\n\t\t\tencryption_params.key,\n\t\t\tencryption_params.iv,\n\t\t\t&segment_writers);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: mp4_cbcs_encrypt_get_writers failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t\tper_stream_writer = TRUE;\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\tsegment_writers = segment_writer;\n\t\tper_stream_writer = FALSE;\n\t}\n\n\tif (submodule_context->media_set.total_track_count > 1)\n\t{\n#if (NGX_HAVE_OPENSSL_EVP)\n\t\tif (encryption_params.type == HLS_ENC_SAMPLE_AES_CENC)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: multiple streams not supported for sample aes cenc\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n\t\t}\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\t\t// muxed segment\n\t\trc = mp4_muxer_init_fragment(\n\t\t\t&submodule_context->request_context,\n\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\t&submodule_context->media_set,\n\t\t\tsegment_writers,\n\t\t\tper_stream_writer,\n\t\t\treuse_input_buffers,\n\t\t\tsize_only,\n\t\t\toutput_buffer,\n\t\t\tresponse_size,\n\t\t\t&muxer_state);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: mp4_muxer_init_fragment failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\n\t\t*frame_processor = (ngx_http_vod_frame_processor_t)mp4_muxer_process_frames;\n\t\t*frame_processor_state = muxer_state;\n\t}\n\telse\n\t{\n#if (NGX_HAVE_OPENSSL_EVP)\n\t\tif (encryption_params.type == HLS_ENC_SAMPLE_AES_CENC)\n\t\t{\n\t\t\tdrm_writer = *segment_writer;\t\t// must not change segment_writer, otherwise the header will be encrypted\n\n\t\t\t// encyrpted fragment\n\t\t\trc = edash_packager_get_fragment_writer(\n\t\t\t\t&drm_writer,\n\t\t\t\t&submodule_context->request_context,\n\t\t\t\t&submodule_context->media_set,\n\t\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\t\tconf->min_single_nalu_per_frame_segment > 0 &&\n\t\t\t\tsubmodule_context->media_set.initial_segment_clip_relative_index >= conf->min_single_nalu_per_frame_segment - 1,\n\t\t\t\tsubmodule_context->media_set.sequences[0].encryption_key,\t\t// iv\n\t\t\t\tsize_only,\n\t\t\t\toutput_buffer,\n\t\t\t\tresponse_size);\n\t\t\tswitch (rc)\n\t\t\t{\n\t\t\tcase VOD_DONE:\t\t// passthrough\n\t\t\t\tbreak;\n\n\t\t\tcase VOD_OK:\n\t\t\t\tsegment_writers = &drm_writer;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: edash_packager_get_fragment_writer failed %i\", rc);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t\t}\n\t\t}\n\t\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t\t{\n\t\t\t// for single stream use dash segments\n\t\t\tngx_memzero(&header_extensions, sizeof(header_extensions));\n\n\t\t\trc = dash_packager_build_fragment_header(\n\t\t\t\t&submodule_context->request_context,\n\t\t\t\t&submodule_context->media_set,\n\t\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\t\t0,\t// sample description index\n\t\t\t\t&header_extensions,\n\t\t\t\tsize_only,\n\t\t\t\toutput_buffer,\n\t\t\t\tresponse_size);\n\t\t\tif (rc != VOD_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: dash_packager_build_fragment_header failed %i\", rc);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t\t}\n\t\t}\n\n\t\t// initialize the frame processor\n\t\tif (!size_only || *response_size == 0)\n\t\t{\n\t\t\trc = mp4_fragment_frame_writer_init(\n\t\t\t\t&submodule_context->request_context,\n\t\t\t\tsubmodule_context->media_set.sequences,\n\t\t\t\tsegment_writers[0].write_tail,\n\t\t\t\tsegment_writers[0].context,\n\t\t\t\treuse_input_buffers,\n\t\t\t\t&state);\n\t\t\tif (rc != VOD_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_hls_init_fmp4_frame_processor: mp4_fragment_frame_writer_init failed %i\", rc);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t\t}\n\n\t\t\t*frame_processor = (ngx_http_vod_frame_processor_t)mp4_fragment_frame_writer_process;\n\t\t\t*frame_processor_state = state;\n\t\t}\n\t}\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tif (encryption_params.type == HLS_ENC_AES_128)\n\t{\n\t\t*response_size = aes_round_up_to_block(*response_size);\n\t}\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\t// set the 'Content-type' header\n\tmp4_fragment_get_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_handle_vtt_segment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\t\n\trc = webvtt_builder_build(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tFALSE,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_hls_handle_vtt_segment: webvtt_builder_build failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->len = sizeof(vtt_content_type) - 1;\n\tcontent_type->data = (u_char *)vtt_content_type;\n\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t hls_master_request = {\n\t0,\n\tPARSE_FLAG_DURATION_LIMITS_AND_TOTAL_SIZE | PARSE_FLAG_KEY_FRAME_BITRATE | PARSE_FLAG_CODEC_NAME | PARSE_FLAG_PARSED_EXTRA_DATA_SIZE | PARSE_FLAG_CODEC_TRANSFER_CHAR,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS | VOD_CODEC_FLAG(WEBVTT),\n\tHLS_TIMESCALE,\n\tngx_http_vod_hls_handle_master_playlist,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hls_index_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE | REQUEST_FLAG_TIME_DEPENDENT_ON_LIVE,\n\tPARSE_BASIC_METADATA_ONLY,\n\tREQUEST_CLASS_MANIFEST,\n\tSUPPORTED_CODECS | VOD_CODEC_FLAG(WEBVTT),\n\tHLS_TIMESCALE,\n\tngx_http_vod_hls_handle_index_playlist,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hls_iframes_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE | REQUEST_FLAG_PARSE_ALL_CLIPS,\n\tPARSE_FLAG_FRAMES_ALL_EXCEPT_OFFSETS | PARSE_FLAG_PARSED_EXTRA_DATA_SIZE,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS_TS,\n\tHLS_TIMESCALE,\n\tngx_http_vod_hls_handle_iframe_playlist,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hls_enc_key_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_BASIC_METADATA_ONLY,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS,\n\tHLS_TIMESCALE,\n\tngx_http_vod_hls_handle_encryption_key,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hls_ts_segment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_PARSED_EXTRA_DATA | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_TS,\n\tHLS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_hls_init_ts_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t hls_mp4_segment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_MP4,\n\tHLS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_hls_init_fmp4_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t hls_mp4_segment_request_cbcs = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_MP4,\n\tHLS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_hls_init_fmp4_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t hls_mp4_segment_request_cenc = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_PARSED_EXTRA_DATA | PARSE_FLAG_INITIAL_PTS_DELAY,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS_MP4,\n\tHLS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_hls_init_fmp4_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t hls_vtt_segment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_SEGMENT,\n\tVOD_CODEC_FLAG(WEBVTT),\n\tWEBVTT_TIMESCALE,\n\tngx_http_vod_hls_handle_vtt_segment,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t hls_mp4_init_request = {\n\tREQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE,\n\tPARSE_BASIC_METADATA_ONLY | PARSE_FLAG_SAVE_RAW_ATOMS,\n\tREQUEST_CLASS_OTHER,\n\tSUPPORTED_CODECS_MP4,\n\tHLS_TIMESCALE,\n\tngx_http_vod_hls_handle_mp4_init_segment,\n\tNULL,\n};\n\nstatic void\nngx_http_vod_hls_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_hls_loc_conf_t *conf)\n{\n\tconf->absolute_master_urls = NGX_CONF_UNSET;\n\tconf->absolute_index_urls = NGX_CONF_UNSET;\n\tconf->absolute_iframe_urls = NGX_CONF_UNSET;\n\tconf->interleave_frames = NGX_CONF_UNSET;\n\tconf->align_frames = NGX_CONF_UNSET;\n\tconf->align_pts = NGX_CONF_UNSET;\n\tconf->output_id3_timestamps = NGX_CONF_UNSET;\n\tconf->encryption_method = NGX_CONF_UNSET_UINT;\n\tconf->output_iv = NGX_CONF_UNSET;\n\tconf->m3u8_config.output_iframes_playlist = NGX_CONF_UNSET;\n\tconf->m3u8_config.force_unmuxed_segments = NGX_CONF_UNSET;\n\tconf->m3u8_config.container_format = NGX_CONF_UNSET_UINT;\n}\n\nstatic char *\nngx_http_vod_hls_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_hls_loc_conf_t *conf,\n\tngx_http_vod_hls_loc_conf_t *prev)\n{\n\tngx_conf_merge_value(conf->absolute_master_urls, prev->absolute_master_urls, 1);\n\tngx_conf_merge_value(conf->absolute_index_urls, prev->absolute_index_urls, 1);\n\tngx_conf_merge_value(conf->absolute_iframe_urls, prev->absolute_iframe_urls, 0);\n\tngx_conf_merge_value(conf->output_iv, prev->output_iv, 0);\n\tngx_conf_merge_value(conf->m3u8_config.output_iframes_playlist, prev->m3u8_config.output_iframes_playlist, 1);\n\n\tngx_conf_merge_str_value(conf->master_file_name_prefix, prev->master_file_name_prefix, \"master\");\n\tngx_conf_merge_str_value(conf->m3u8_config.index_file_name_prefix, prev->m3u8_config.index_file_name_prefix, \"index\");\n\tngx_conf_merge_str_value(conf->m3u8_config.iframes_file_name_prefix, prev->m3u8_config.iframes_file_name_prefix, \"iframes\");\n\tngx_conf_merge_str_value(conf->m3u8_config.segment_file_name_prefix, prev->m3u8_config.segment_file_name_prefix, \"seg\");\n\tngx_conf_merge_str_value(conf->m3u8_config.init_file_name_prefix, prev->m3u8_config.init_file_name_prefix, \"init\");\n\n\tngx_conf_merge_str_value(conf->m3u8_config.encryption_key_file_name, prev->m3u8_config.encryption_key_file_name, \"encryption\");\n\tngx_conf_merge_str_value(conf->m3u8_config.encryption_key_format, prev->m3u8_config.encryption_key_format, \"\");\n\tngx_conf_merge_str_value(conf->m3u8_config.encryption_key_format_versions, prev->m3u8_config.encryption_key_format_versions, \"\");\n\tif (conf->encryption_key_uri == NULL)\n\t{\n\t\tconf->encryption_key_uri = prev->encryption_key_uri;\n\t}\n\tngx_conf_merge_value(conf->m3u8_config.force_unmuxed_segments, prev->m3u8_config.force_unmuxed_segments, 0);\n\tngx_conf_merge_uint_value(conf->m3u8_config.container_format, prev->m3u8_config.container_format, HLS_CONTAINER_AUTO);\n\n\tngx_conf_merge_value(conf->interleave_frames, prev->interleave_frames, 0);\n\tngx_conf_merge_value(conf->align_frames, prev->align_frames, 1);\n\tngx_conf_merge_value(conf->align_pts, prev->align_pts, 0);\n\tngx_conf_merge_value(conf->output_id3_timestamps, prev->output_id3_timestamps, 0);\n\tif (conf->id3_data == NULL)\n\t{\n\t\tconf->id3_data = prev->id3_data;\n\t}\n\n\tngx_conf_merge_uint_value(conf->encryption_method, prev->encryption_method, HLS_ENC_NONE);\n\n\tm3u8_builder_init_config(\n\t\t&conf->m3u8_config,\n\t\tbase->segmenter.max_segment_duration, \n\t\tconf->encryption_method);\n\n\tswitch (conf->encryption_method)\n\t{\n\tcase HLS_ENC_NONE:\n\t\tbreak;\n\n\tcase HLS_ENC_SAMPLE_AES_CENC:\n\t\tif (!base->drm_enabled)\n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\t\"drm must be enabled when \\\"vod_hls_encryption_method\\\" is sample-aes-cenc\");\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (base->secret_key == NULL &&\n\t\t\t!base->drm_enabled)\n\t\t{\n\t\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n\t\t\t\t\"\\\"vod_secret_key\\\" must be set when \\\"vod_hls_encryption_method\\\" is not none\");\n\t\t\treturn NGX_CONF_ERROR;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NGX_CONF_OK;\n}\n\nstatic int \nngx_http_vod_hls_get_file_path_components(ngx_str_t* uri)\n{\n\treturn 1;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tuint32_t flags;\n\tngx_int_t rc;\n\n\t// ts segment\n\tif (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.segment_file_name_prefix, ts_file_ext))\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.segment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(ts_file_ext) - 1);\n\t\t*request = &hls_ts_segment_request;\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// fmp4 segment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.segment_file_name_prefix, m4s_file_ext))\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.segment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(m4s_file_ext) - 1);\n\n\t\tswitch (conf->hls.encryption_method)\n\t\t{\n\t\tcase HLS_ENC_SAMPLE_AES:\n\t\t\t*request = &hls_mp4_segment_request_cbcs;\n\t\t\tbreak;\n\n\t\tcase HLS_ENC_SAMPLE_AES_CENC:\n\t\t\t*request = &hls_mp4_segment_request_cenc;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*request = &hls_mp4_segment_request;\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// vtt segment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.segment_file_name_prefix, vtt_file_ext))\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.segment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(vtt_file_ext) - 1);\n\t\t*request = &hls_vtt_segment_request;\n\t\tflags = PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX;\n\t}\n\t// manifest\n\telse if (ngx_http_vod_ends_with_static(start_pos, end_pos, m3u8_file_ext))\n\t{\n\t\tend_pos -= (sizeof(m3u8_file_ext) - 1);\n\n\t\t// make sure the file name begins with 'index' or 'iframes'\n\t\tif (ngx_http_vod_starts_with(start_pos, end_pos, &conf->hls.m3u8_config.index_file_name_prefix))\n\t\t{\n\t\t\t*request = &hls_index_request;\n\t\t\tstart_pos += conf->hls.m3u8_config.index_file_name_prefix.len;\n\t\t\tflags = 0;\n\t\t}\n\t\telse if (ngx_http_vod_starts_with(start_pos, end_pos, &conf->hls.m3u8_config.iframes_file_name_prefix))\n\t\t{\n\t\t\t*request = &hls_iframes_request;\n\t\t\tstart_pos += conf->hls.m3u8_config.iframes_file_name_prefix.len;\n\t\t\tflags = 0;\n\t\t}\n\t\telse if (ngx_http_vod_starts_with(start_pos, end_pos, &conf->hls.master_file_name_prefix))\n\t\t{\n\t\t\t*request = &hls_master_request;\n\t\t\tstart_pos += conf->hls.master_file_name_prefix.len;\n\t\t\tflags = PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_hls_parse_uri_file_name: unidentified m3u8 request\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\t}\n\t// encryption key\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.encryption_key_file_name, key_file_ext) &&\n\t\t!conf->drm_enabled &&\n\t\tconf->hls.encryption_method != HLS_ENC_NONE)\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.encryption_key_file_name.len;\n\t\tend_pos -= (sizeof(key_file_ext) - 1);\n\t\t*request = &hls_enc_key_request;\n\t\tflags = 0;\n\t}\n\t// init segment\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.init_file_name_prefix, mp4_file_ext))\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.init_file_name_prefix.len;\n\t\tend_pos -= (sizeof(mp4_file_ext) - 1);\n\t\t*request = &hls_mp4_init_request;\n\t\tflags = PARSE_FILE_NAME_ALLOW_CLIP_INDEX;\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_hls_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\t// parse the required tracks string\n\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, flags, request_params);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_hls_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_hls_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tvod_status_t rc;\n\n\trc = udrm_parse_response(\n\t\t&submodule_context->request_context,\n\t\tdrm_info,\n\t\tTRUE,\n\t\toutput);\n\tif (rc != VOD_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nDEFINE_SUBMODULE(hls);\n"
        },
        {
          "name": "ngx_http_vod_hls.h",
          "type": "blob",
          "size": 0.2158203125,
          "content": "#ifndef _NGX_HTTP_VOD_HLS_H_INCLUDED_\n#define _NGX_HTTP_VOD_HLS_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t hls;\n\n#endif // _NGX_HTTP_VOD_HLS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_hls_commands.h",
          "type": "blob",
          "size": 5.9541015625,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, hls)\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\t{ ngx_string(\"vod_hls_encryption_method\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_enum_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, encryption_method),\n\thls_encryption_methods },\n\n\t{ ngx_string(\"vod_hls_encryption_key_file_name\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.encryption_key_file_name),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_hls_encryption_key_uri\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, encryption_key_uri),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_encryption_key_format\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.encryption_key_format),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_encryption_key_format_versions\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.encryption_key_format_versions),\n\tNULL },\t\n\n\t{ ngx_string(\"vod_hls_encryption_output_iv\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, output_iv),\n\tNULL },\n#endif // NGX_HAVE_OPENSSL_EVP\n\n\t{ ngx_string(\"vod_hls_container_format\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_enum_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.container_format),\n\thls_container_formats },\n\n\t{ ngx_string(\"vod_hls_absolute_master_urls\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, absolute_master_urls),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_absolute_index_urls\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, absolute_index_urls),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_absolute_iframe_urls\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, absolute_iframe_urls),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_master_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, master_file_name_prefix),\n\tNULL },\n\t\n\t{ ngx_string(\"vod_hls_index_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.index_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_output_iframes_playlist\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.output_iframes_playlist),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_iframes_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.iframes_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_segment_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.segment_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_init_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.init_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_mpegts_interleave_frames\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, interleave_frames),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_mpegts_align_frames\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, align_frames),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_mpegts_output_id3_timestamps\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, output_id3_timestamps),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_mpegts_id3_data\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_http_set_complex_value_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, id3_data),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_mpegts_align_pts\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, align_pts),\n\tNULL },\n\n\t{ ngx_string(\"vod_hls_force_unmuxed_segments\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_hls_loc_conf_t, m3u8_config.force_unmuxed_segments),\n\tNULL },\n\n#undef BASE_OFFSET\n"
        },
        {
          "name": "ngx_http_vod_hls_conf.h",
          "type": "blob",
          "size": 0.78125,
          "content": "#ifndef _NGX_HTTP_VOD_HLS_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_HLS_CONF_H_INCLUDED_\n\n// includes\n#include \"vod/hls/m3u8_builder.h\"\n#include \"vod/hls/hls_muxer.h\"\n\n// typedefs\ntypedef struct\n{\n\tngx_flag_t absolute_master_urls;\n\tngx_flag_t absolute_index_urls;\n\tngx_flag_t absolute_iframe_urls;\n\tngx_str_t master_file_name_prefix;\n\tbool_t interleave_frames;\n\tbool_t align_frames;\n\tbool_t align_pts;\n\tbool_t output_id3_timestamps;\n\tngx_http_complex_value_t* id3_data;\n\tvod_uint_t encryption_method;\n\tngx_http_complex_value_t* encryption_key_uri;\n\tbool_t output_iv;\n\n\t// derived fields\n\tm3u8_config_t m3u8_config;\n} ngx_http_vod_hls_loc_conf_t;\n\n// globals\nextern ngx_conf_enum_t  hls_encryption_methods[];\nextern ngx_conf_enum_t  hls_container_formats[];\n\n#endif // _NGX_HTTP_VOD_HLS_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_module.c",
          "type": "blob",
          "size": 150.724609375,
          "content": "#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include <nginx.h>\n#include <ngx_event.h>\n#include <ngx_md5.h>\n\n#include \"ngx_http_vod_module.h\"\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_request_parse.h\"\n#include \"ngx_child_http_request.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"ngx_perf_counters.h\"\n#include \"ngx_http_vod_conf.h\"\n#include \"ngx_file_reader.h\"\n#include \"ngx_buffer_cache.h\"\n#include \"vod/mp4/mp4_format.h\"\n#include \"vod/mkv/mkv_format.h\"\n#include \"vod/subtitle/webvtt_format.h\"\n#include \"vod/subtitle/cap_format.h\"\n#include \"vod/input/read_cache.h\"\n#include \"vod/filters/audio_filter.h\"\n#include \"vod/filters/dynamic_clip.h\"\n#include \"vod/filters/concat_clip.h\"\n#include \"vod/filters/rate_filter.h\"\n#include \"vod/filters/filter.h\"\n#include \"vod/media_set_parser.h\"\n#include \"vod/manifest_utils.h\"\n#include \"vod/input/silence_generator.h\"\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n#include \"ngx_http_vod_thumb.h\"\n#include \"ngx_http_vod_volume_map.h\"\n#include \"vod/filters/audio_decoder.h\"\n#include \"vod/filters/audio_encoder.h\"\n#include \"vod/thumb/thumb_grabber.h\"\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n#if (NGX_HAVE_LIBXML2)\n#include \"vod/subtitle/dfxp_format.h\"\n#endif // NGX_HAVE_LIBXML2\n\n// macros\n#define DEFINE_VAR(name) \\\n\t{ ngx_string(\"vod_\" #name), ngx_http_vod_set_##name##_var, 0 }\n\n// constants\n#define OPEN_FILE_FALLBACK_ENABLED (0x80000000)\n#define MAX_STALE_RETRIES (2)\n\nenum {\n\t// mapping state machine\n\tSTATE_MAP_INITIAL,\n\tSTATE_MAP_OPEN,\n\tSTATE_MAP_READ,\n\n\t// main state machine\n\tSTATE_READ_DRM_INFO,\n\tSTATE_READ_METADATA_INITIAL,\n\tSTATE_READ_METADATA_OPEN_FILE,\n\tSTATE_READ_METADATA_READ,\n\tSTATE_READ_FRAMES_OPEN_FILE,\n\tSTATE_READ_FRAMES_READ,\n\tSTATE_OPEN_FILE,\n\tSTATE_FILTER_FRAMES,\n\tSTATE_PROCESS_FRAMES,\n\tSTATE_DUMP_OPEN_FILE,\n\tSTATE_DUMP_FILE_PART,\n};\n\nenum {\n\tREADER_FILE,\n\tREADER_HTTP,\n\tREADER_COUNT\n};\n\n// typedefs\nstruct ngx_http_vod_ctx_s;\ntypedef struct ngx_http_vod_ctx_s ngx_http_vod_ctx_t;\n\ntypedef ngx_int_t(*ngx_http_vod_state_machine_t)(ngx_http_vod_ctx_t* ctx);\ntypedef ngx_int_t(*ngx_http_vod_open_file_t)(ngx_http_request_t* r, ngx_str_t* path, uint32_t flags, void** context);\ntypedef ngx_int_t(*ngx_http_vod_async_read_func_t)(void* context, ngx_buf_t *buf, size_t size, off_t offset);\ntypedef ngx_int_t(*ngx_http_vod_dump_part_t)(void* context, off_t start, off_t end);\ntypedef size_t(*ngx_http_vod_get_size_t)(void* context);\ntypedef void(*ngx_http_vod_get_path_t)(void* context, ngx_str_t* path);\ntypedef ngx_int_t(*ngx_http_vod_enable_directio_t)(void* context);\n\ntypedef ngx_int_t(*ngx_http_vod_dump_request_t)(void* context);\ntypedef ngx_int_t(*ngx_http_vod_mapping_apply_t)(ngx_http_vod_ctx_t *ctx, ngx_str_t* mapping, int* cache_index);\ntypedef ngx_int_t(*ngx_http_vod_mapping_get_uri_t)(ngx_http_vod_ctx_t *ctx, ngx_str_t* uri);\n\ntypedef struct {\n\tuint32_t type;\n\tuint32_t part_count;\n} multipart_cache_header_t;\n\ntypedef struct {\n\tsize_t content_type_len;\n\tuint32_t media_set_type;\n} response_cache_header_t;\n\ntypedef struct {\n\tngx_http_request_t* r;\n\tngx_chain_t* chain_head;\n\tngx_chain_t* chain_end;\n\tsize_t total_size;\n} ngx_http_vod_write_segment_context_t;\n\ntypedef struct {\n\tngx_http_request_t* r;\n\tngx_str_t cur_remote_suburi;\n\tngx_str_t upstream_location;\n} ngx_http_vod_http_reader_state_t;\n\ntypedef struct {\n\tu_char cache_key[MEDIA_CLIP_KEY_SIZE];\n\tngx_str_t* cache_key_prefix;\n\tngx_buffer_cache_t** caches;\n\tuint32_t cache_count;\n\tuint32_t stale_retries;\n\n\t// reading abstraction (over file / http)\n\tngx_http_vod_reader_t* reader;\n\tvoid* reader_context;\n\n\tsize_t max_response_size;\n\tngx_http_vod_mapping_get_uri_t get_uri;\n\tngx_http_vod_mapping_apply_t apply;\n} ngx_http_vod_mapping_context_t;\n\nstruct ngx_http_vod_reader_s {\n\tngx_http_vod_open_file_t open;\n\tngx_http_vod_dump_part_t dump_part;\n\tngx_http_vod_dump_request_t dump_request;\n\tngx_http_vod_get_size_t get_size;\n\tngx_http_vod_get_path_t get_path;\n\tngx_http_vod_enable_directio_t enable_directio;\n\tngx_http_vod_async_read_func_t read;\n};\n\nstruct ngx_http_vod_ctx_s {\n\t// base params\n\tngx_http_vod_submodule_context_t submodule_context;\n\tconst struct ngx_http_vod_request_s* request;\n\tint state;\n\tu_char request_key[BUFFER_CACHE_KEY_SIZE];\n\tu_char child_request_key[BUFFER_CACHE_KEY_SIZE];\n\tngx_http_vod_state_machine_t state_machine;\n\n\t// iterators\n\tmedia_sequence_t* cur_sequence;\n\tmedia_clip_source_t* cur_source;\n\tmedia_clip_t* cur_clip;\n\n\t// performance counters\n\tint perf_counter_async_read;\n\tngx_perf_counters_t* perf_counters;\n\tngx_perf_counter_context(perf_counter_context);\n\tngx_perf_counter_context(total_perf_counter_context);\n\n\t// mapping\n\tngx_http_vod_mapping_context_t mapping;\n\n\t// read metadata state\n\tngx_buf_t read_buffer;\n\tuint32_t read_flags;\n\tmedia_format_t* format;\n\tngx_buf_t prefix_buffer;\n\toff_t requested_offset;\n\toff_t read_offset;\n\tsize_t read_size;\n\tvoid* metadata_reader_context;\n\tngx_str_t* metadata_parts;\n\tsize_t metadata_part_count;\n\n\t// read frames state\n\tmedia_base_metadata_t* base_metadata;\n\tmedia_format_read_request_t frames_read_req;\n\n\t// clipper\n\tmedia_clipper_parse_result_t* clipper_parse_result;\n\n\tngx_http_vod_reader_t* default_reader;\n\n\t// read state - file\n#if (NGX_THREADS)\n\tvoid* async_open_context;\n#endif // NGX_THREADS\n\n\t// read state - http\n\tngx_str_t* file_key_prefix;\n\tngx_str_t upstream_extra_args;\n\n\t// segment requests only\n\tsize_t content_length;\n\tsize_t size_limit;\n\tread_cache_state_t read_cache_state;\n\tngx_http_vod_frame_processor_t frame_processor;\n\tvoid* frame_processor_state;\n\tngx_chain_t out;\n\tsegment_writer_t segment_writer;\n\tngx_http_vod_write_segment_context_t write_segment_buffer_context;\n\tmedia_notification_t* notification;\n\tuint32_t frames_bytes_read;\n};\n\n// typedefs\ntypedef struct {\n\tngx_str_t name;\n\tngx_http_get_variable_pt handler;\n\tuintptr_t data;\n} ngx_http_vod_variable_t;\n\n// forward declarations\nstatic ngx_int_t ngx_http_vod_run_state_machine(ngx_http_vod_ctx_t *ctx);\nstatic ngx_int_t ngx_http_vod_send_notification(ngx_http_vod_ctx_t *ctx);\nstatic ngx_int_t ngx_http_vod_init_process(ngx_cycle_t *cycle);\nstatic void ngx_http_vod_exit_process();\n\nstatic ngx_int_t ngx_http_vod_init_file_reader_with_fallback(ngx_http_request_t *r, ngx_str_t* path, uint32_t flags, void** context);\nstatic ngx_int_t ngx_http_vod_init_file_reader(ngx_http_request_t *r, ngx_str_t* path, uint32_t flags, void** context);\nstatic ngx_int_t ngx_http_vod_dump_file(void* context);\n\nstatic ngx_int_t ngx_http_vod_http_reader_open_file(ngx_http_request_t* r, ngx_str_t* path, uint32_t flags, void** context);\nstatic ngx_int_t ngx_http_vod_dump_http_part(void* context, off_t start, off_t end);\nstatic ngx_int_t ngx_http_vod_dump_http_request(void* context);\nstatic void ngx_http_vod_http_reader_get_path(void* context, ngx_str_t* path);\nstatic ngx_int_t ngx_http_vod_async_http_read(ngx_http_vod_http_reader_state_t *state, ngx_buf_t *buf, size_t size, off_t offset);\n\n// globals\nngx_module_t  ngx_http_vod_module = {\n    NGX_MODULE_V1,\n    &ngx_http_vod_module_ctx,         /* module context */\n    ngx_http_vod_commands,            /* module directives */\n    NGX_HTTP_MODULE,                  /* module type */\n    NULL,                             /* init master */\n    NULL,                             /* init module */\n    ngx_http_vod_init_process,        /* init process */\n    NULL,                             /* init thread */\n    NULL,                             /* exit thread */\n    ngx_http_vod_exit_process,        /* exit process */\n    ngx_http_vod_exit_process,        /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\nstatic ngx_str_t options_content_type = ngx_string(\"text/plain\");\nstatic ngx_str_t empty_file_string = ngx_string(\"empty\");\nstatic ngx_str_t empty_string = ngx_null_string;\n\nstatic media_format_t* media_formats[] = {\n\t&mp4_format,\n\t// XXXXX add &mkv_format,\n\t&webvtt_format,\n#if (NGX_HAVE_LIBXML2)\n\t&dfxp_format,\n#endif // NGX_HAVE_LIBXML2\n\t&cap_format,\n\tNULL\n};\n\nstatic ngx_http_vod_reader_t reader_file_with_fallback = {\n\tngx_http_vod_init_file_reader_with_fallback,\n\tngx_file_reader_dump_file_part,\n\tngx_http_vod_dump_file,\n\tngx_file_reader_get_size,\n\tngx_file_reader_get_path,\n\t(ngx_http_vod_enable_directio_t)ngx_file_reader_enable_directio,\n\t(ngx_http_vod_async_read_func_t)ngx_async_file_read,\n};\n\nstatic ngx_http_vod_reader_t reader_file = {\n\tngx_http_vod_init_file_reader,\n\tngx_file_reader_dump_file_part,\n\tngx_http_vod_dump_file,\n\tngx_file_reader_get_size,\n\tngx_file_reader_get_path,\n\t(ngx_http_vod_enable_directio_t)ngx_file_reader_enable_directio,\n\t(ngx_http_vod_async_read_func_t)ngx_async_file_read,\n};\n\nstatic ngx_http_vod_reader_t reader_http = {\n\tngx_http_vod_http_reader_open_file,\n\tngx_http_vod_dump_http_part,\n\tngx_http_vod_dump_http_request,\n\tNULL,\n\tngx_http_vod_http_reader_get_path,\n\tNULL,\n\t(ngx_http_vod_async_read_func_t)ngx_http_vod_async_http_read,\n};\n\nstatic const u_char wvm_file_magic[] = { 0x00, 0x00, 0x01, 0xba, 0x44, 0x00, 0x04, 0x00, 0x04, 0x01 };\n\n////// Variables\n\nstatic ngx_int_t\nngx_http_vod_set_status_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\t// this variable is explicitly set when an error is mapped, if we got here, there's no value\n\tv->not_found = 1;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_filepath_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL ||\n\t\tctx->cur_sequence < ctx->submodule_context.media_set.sequences ||\n\t\tctx->cur_sequence >= ctx->submodule_context.media_set.sequences_end)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tvalue = &ctx->cur_sequence->mapped_uri;\n\tif (value->len == 0)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\tv->len = value->len;\n\tv->data = value->data;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_suburi_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tmedia_sequence_t* sequence;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tif (ctx->cur_sequence >= ctx->submodule_context.media_set.sequences &&\n\t\tctx->cur_sequence < ctx->submodule_context.media_set.sequences_end)\n\t{\n\t\tsequence = ctx->cur_sequence;\n\t}\n\telse if (ctx->cur_source != NULL)\n\t{\n\t\tsequence = ctx->cur_source->sequence;\n\t}\n\telse\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tvalue = &sequence->stripped_uri;\n\tif (value->len == 0)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\tv->len = value->len;\n\tv->data = value->data;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_set_id_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tvalue = &ctx->submodule_context.media_set.id;\n\tif (value->len == 0)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\tv->len = value->len;\n\tv->data = value->data;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_sequence_id_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tmedia_sequence_t* cur_sequence;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\t\n\tcur_sequence = ctx->cur_sequence;\n\tif (cur_sequence == NULL && ctx->submodule_context.media_set.sequence_count == 1)\n\t{\n\t\tcur_sequence = ctx->submodule_context.media_set.sequences;\n\t}\n\n\tif (cur_sequence < ctx->submodule_context.media_set.sequences ||\n\t\tcur_sequence >= ctx->submodule_context.media_set.sequences_end)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tvalue = &cur_sequence->id;\n\tif (value->len == 0)\n\t{\n\t\tvalue = &cur_sequence->stripped_uri;\n\t\tif (value->len == 0)\n\t\t{\n\t\t\tv->not_found = 1;\n\t\t\treturn NGX_OK;\n\t\t}\n\t}\n\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\tv->len = value->len;\n\tv->data = value->data;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_clip_id_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tmedia_clip_source_t* clip_source;\n\tngx_http_vod_ctx_t *ctx;\n\tmedia_clip_t* cur_clip;\n\tmedia_set_t* media_set;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tgoto not_found;\n\t}\n\n\tcur_clip = ctx->cur_clip;\n\tif (cur_clip == NULL)\n\t{\n\t\tmedia_set = &ctx->submodule_context.media_set;\n\t\tif (media_set->sequence_count == 1 && media_set->clip_count == 1)\n\t\t{\n\t\t\tcur_clip = media_set->sequences->clips[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgoto not_found;\n\t\t}\n\t}\n\n\tswitch (cur_clip->type)\n\t{\n\tcase MEDIA_CLIP_SOURCE:\n\t\tclip_source = (media_clip_source_t*)cur_clip;\n\t\tif (clip_source->id.len != 0)\n\t\t{\n\t\t\tvalue = &clip_source->id;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = &clip_source->mapped_uri;\n\t\t}\n\t\tbreak;\n\n\tcase MEDIA_CLIP_DYNAMIC:\n\t\tvalue = &((media_clip_dynamic_t*)cur_clip)->id;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto not_found;\n\t}\n\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\tv->len = value->len;\n\tv->data = value->data;\n\n\treturn NGX_OK;\n\nnot_found:\n\n\tv->not_found = 1;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_dynamic_mapping_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tvod_status_t rc;\n\tngx_str_t value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\trc = dynamic_clip_get_mapping_string(\n\t\t&ctx->submodule_context.request_context,\n\t\tctx->submodule_context.media_set.dynamic_clips_head,\n\t\t&value);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_set_dynamic_mapping_var: dynamic_clip_get_mapping_string failed %i\", rc);\n\t\treturn NGX_ERROR;\n\t}\n\n\tv->data = value.data;\n\tv->len = value.len;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_request_params_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\trequest_params_t* request_params;\n\tngx_http_vod_ctx_t *ctx;\n\tvod_status_t rc;\n\tngx_str_t value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\trequest_params = &ctx->submodule_context.request_params;\n\n\trc = manifest_utils_build_request_params_string(\n\t\t&ctx->submodule_context.request_context,\n\t\trequest_params->tracks_mask,\t\t// the media set may not be ready yet, include all tracks that were passed on the request\n\t\trequest_params->segment_index,\n\t\trequest_params->sequences_mask,\n\t\trequest_params->sequence_tracks_mask,\n\t\trequest_params->sequence_tracks_mask_end,\n\t\trequest_params->tracks_mask,\n\t\t&value);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_set_request_params_var: manifest_utils_build_request_params_string failed %i\", rc);\n\t\treturn NGX_ERROR;\n\t}\n\n\tif (value.len > 0 && value.data[0] == '-')\n\t{\n\t\tvalue.data++;\n\t\tvalue.len--;\n\t}\n\n\tv->data = value.data;\n\tv->len = value.len;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_notification_id_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_str_t* value;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL || ctx->notification == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tvalue = &ctx->notification->id;\n\tv->data = value->data;\n\tv->len = value->len;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_segment_time_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t* ctx;\n\tmedia_set_t* media_set;\n\tint64_t value;\n\tu_char* p;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tmedia_set = &ctx->submodule_context.media_set;\n\tif (media_set->filtered_tracks >= media_set->filtered_tracks_end)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tp = ngx_pnalloc(r->pool, NGX_INT64_LEN);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_set_segment_time_var: ngx_pnalloc failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tvalue = media_set_get_segment_time_millis(media_set);\n\n\tv->data = p;\n\tv->len = ngx_sprintf(p, \"%L\", value) - p;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_segment_duration_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tmedia_track_t* last_track;\n\tmedia_track_t* cur_track;\n\tmedia_set_t* media_set;\n\tuint32_t timescale;\n\tuint64_t value;\n\tu_char* p;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tmedia_set = &ctx->submodule_context.media_set;\n\tcur_track = media_set->filtered_tracks;\n\tlast_track = cur_track + media_set->total_track_count * media_set->clip_count;\n\tif (cur_track >= last_track)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tp = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_set_segment_duration_var: ngx_pnalloc failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\ttimescale = cur_track->media_info.timescale;\n\n\tvalue = 0;\n\tfor (; cur_track < last_track; cur_track += media_set->total_track_count)\n\t{\n\t\tvalue += cur_track->total_frames_duration;\n\t}\n\n\tv->data = p;\n\tv->len = ngx_sprintf(p, \"%uD\", (uint32_t)rescale_time(value, timescale, 1000)) - p;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_set_uint32_var(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tuint32_t int_value;\n\tu_char* p;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tif (ctx == NULL)\n\t{\n\t\tv->not_found = 1;\n\t\treturn NGX_OK;\n\t}\n\n\tp = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_set_uint32_var: ngx_pnalloc failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tint_value = *(uint32_t*)(((u_char*)ctx) + data);\n\n\tv->data = p;\n\tv->len = ngx_sprintf(p, \"%uD\", int_value) - p;\n\tv->valid = 1;\n\tv->no_cacheable = 1;\n\tv->not_found = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_http_vod_variable_t ngx_http_vod_variables[] = {\n\tDEFINE_VAR(status),\n\tDEFINE_VAR(filepath),\n\tDEFINE_VAR(suburi),\n\tDEFINE_VAR(set_id),\n\tDEFINE_VAR(sequence_id),\n\tDEFINE_VAR(clip_id),\n\tDEFINE_VAR(dynamic_mapping),\n\tDEFINE_VAR(request_params),\n\tDEFINE_VAR(notification_id),\n\tDEFINE_VAR(segment_time),\n\tDEFINE_VAR(segment_duration),\n\t{ ngx_string(\"vod_frames_bytes_read\"), ngx_http_vod_set_uint32_var, offsetof(ngx_http_vod_ctx_t, frames_bytes_read) },\n};\n\nngx_int_t\nngx_http_vod_preconfiguration(ngx_conf_t *cf)\n{\n\tngx_http_vod_variable_t* vars_cur = ngx_http_vod_variables;\n\tngx_http_vod_variable_t* vars_end = vars_cur + vod_array_entries(ngx_http_vod_variables);\n\tngx_http_variable_t  *var;\n\tngx_int_t rc;\n\n\tfor (; vars_cur < vars_end; vars_cur++)\n\t{\n\t\tvar = ngx_http_add_variable(cf, &vars_cur->name, NGX_HTTP_VAR_NOCACHEABLE);\n\t\tif (var == NULL)\n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tvar->get_handler = vars_cur->handler;\n\t\tvar->data = vars_cur->data;\n\t}\n\n\trc = ngx_http_get_variable_index(cf, &ngx_http_vod_variables[0].name);\n\tif (rc == NGX_ERROR) \n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\tngx_http_vod_set_status_index(rc);\n\n#if (NGX_HAVE_LIBXML2)\n\tdfxp_init_process();\n#endif // NGX_HAVE_LIBXML2\n\n#if (VOD_HAVE_ICONV)\n\twebvtt_init_process(cf->log);\n#endif // VOD_HAVE_ICONV\n\n\treturn NGX_OK;\n}\n\n////// Perf counter wrappers\n\nstatic ngx_flag_t\nngx_buffer_cache_fetch_perf(\n\tngx_perf_counters_t* perf_counters,\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tngx_str_t* buffer,\n\tuint32_t* token)\n{\n\tngx_perf_counter_context(pcctx);\n\tngx_flag_t result;\n\t\n\tngx_perf_counter_start(pcctx);\n\n\tresult = ngx_buffer_cache_fetch(cache, key, buffer, token);\n\n\tngx_perf_counter_end(perf_counters, pcctx, PC_FETCH_CACHE);\n\n\treturn result;\n}\n\nstatic int\nngx_buffer_cache_fetch_multi_perf(\n\tngx_perf_counters_t* perf_counters,\n\tngx_buffer_cache_t** caches,\n\tuint32_t cache_count,\n\tu_char* key,\n\tngx_str_t* buffer,\n\tuint32_t* token)\n{\n\tngx_perf_counter_context(pcctx);\n\tngx_buffer_cache_t* cache;\n\tngx_flag_t result;\n\tuint32_t cache_index;\n\n\tngx_perf_counter_start(pcctx);\n\n\tfor (cache_index = 0; cache_index < cache_count; cache_index++)\n\t{\n\t\tcache = caches[cache_index];\n\t\tif (cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = ngx_buffer_cache_fetch(cache, key, buffer, token);\n\t\tif (!result)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tngx_perf_counter_end(perf_counters, pcctx, PC_FETCH_CACHE);\n\n\t\treturn cache_index;\n\t}\n\n\tngx_perf_counter_end(perf_counters, pcctx, PC_FETCH_CACHE);\n\n\treturn -1;\n}\n\nstatic int\nngx_buffer_cache_fetch_copy_perf(\n\tngx_http_request_t* r,\n\tngx_perf_counters_t* perf_counters,\n\tngx_buffer_cache_t** caches,\n\tuint32_t cache_count,\n\tu_char* key,\n\tngx_str_t* buffer)\n{\n\tngx_str_t original_buffer;\n\tuint32_t token;\n\tu_char* buffer_copy;\n\tint result;\n\n\tresult = ngx_buffer_cache_fetch_multi_perf(\n\t\tperf_counters,\n\t\tcaches,\n\t\tcache_count,\n\t\tkey,\n\t\t&original_buffer,\n\t\t&token);\n\tif (result < 0)\n\t{\n\t\treturn result;\n\t}\n\n\tbuffer_copy = ngx_palloc(r->pool, original_buffer.len + 1);\n\tif (buffer_copy == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_buffer_cache_fetch_copy_perf: ngx_palloc failed\");\n\t\treturn -1;\n\t}\n\n\tngx_memcpy(buffer_copy, original_buffer.data, original_buffer.len);\n\tbuffer_copy[original_buffer.len] = '\\0';\n\n\tngx_buffer_cache_release(caches[result], key, token);\n\n\tbuffer->data = buffer_copy;\n\tbuffer->len = original_buffer.len;\n\n\treturn result;\n}\n\nstatic ngx_flag_t\nngx_buffer_cache_store_perf(\n\tngx_perf_counters_t* perf_counters,\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tu_char* source_buffer,\n\tsize_t buffer_size)\n{\n\tngx_perf_counter_context(pcctx);\n\tngx_flag_t result;\n\n\tngx_perf_counter_start(pcctx);\n\n\tresult = ngx_buffer_cache_store(cache, key, source_buffer, buffer_size);\n\n\tngx_perf_counter_end(perf_counters, pcctx, PC_STORE_CACHE);\n\n\treturn result;\n}\n\nstatic ngx_flag_t \nngx_buffer_cache_store_gather_perf(\n\tngx_perf_counters_t* perf_counters,\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tngx_str_t* buffers,\n\tsize_t buffer_count)\n{\n\tngx_perf_counter_context(pcctx);\n\tngx_flag_t result;\n\n\tngx_perf_counter_start(pcctx);\n\n\tresult = ngx_buffer_cache_store_gather(cache, key, buffers, buffer_count);\n\n\tngx_perf_counter_end(perf_counters, pcctx, PC_STORE_CACHE);\n\n\treturn result;\n}\n\n////// Multipart cache functions\n\nstatic ngx_flag_t \nngx_buffer_cache_store_multipart_perf(\n\tngx_http_vod_ctx_t *ctx,\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tmultipart_cache_header_t* header,\n\tngx_str_t* parts)\n{\n\tngx_str_t* buffers;\n\tngx_str_t* cur_part;\n\tngx_str_t* parts_end;\n\tuint32_t part_count = header->part_count;\n\tu_char* p;\n\tsize_t* cur_size;\n\t\n\tp = ngx_palloc(\n\t\tctx->submodule_context.request_context.pool, \n\t\tsizeof(buffers[0]) * (part_count + 1) + sizeof(*header) + sizeof(size_t) * part_count);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_buffer_cache_store_multipart_perf: ngx_palloc failed\");\n\t\treturn 0;\n\t}\n\n\tbuffers = (void*)p;\n\tp += sizeof(buffers[0]) * (part_count + 1);\n\n\tbuffers[0].data = p;\n\tbuffers[0].len = sizeof(*header) + sizeof(size_t) * part_count;\n\tngx_memcpy(buffers + 1, parts, part_count * sizeof(buffers[0]));\n\n\tp = ngx_copy(p, header, sizeof(*header));\n\n\tcur_size = (void*)p;\n\tparts_end = parts + part_count;\n\tfor (cur_part = parts; cur_part < parts_end; cur_part++)\n\t{\n\t\t*cur_size++ = cur_part->len;\n\t}\n\n\treturn ngx_buffer_cache_store_gather_perf(\n\t\tctx->perf_counters,\n\t\tcache,\n\t\tkey,\n\t\tbuffers,\n\t\tpart_count + 1);\n}\n\nstatic ngx_flag_t\nngx_buffer_cache_fetch_multipart_perf(\n\tngx_http_vod_ctx_t *ctx,\n\tngx_buffer_cache_t* cache,\n\tu_char* key,\n\tmultipart_cache_header_t* header,\n\tngx_str_t** out_parts,\n\tuint32_t* token)\n{\n\tvod_str_t* cur_part;\n\tvod_str_t* parts;\n\tngx_str_t cache_buffer;\n\tuint32_t part_count;\n\tsize_t* part_sizes;\n\tsize_t cur_size;\n\tu_char* end;\n\tu_char* p;\n\n\tif (!ngx_buffer_cache_fetch_perf(\n\t\tctx->perf_counters,\n\t\tcache,\n\t\tkey,\n\t\t&cache_buffer,\n\t\ttoken))\n\t{\n\t\treturn 0;\n\t}\n\n\tif (cache_buffer.len < sizeof(*header))\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_buffer_cache_fetch_multipart_perf: size %uz smaller than header size\", cache_buffer.len);\n\t\treturn 0;\n\t}\n\n\tp = cache_buffer.data;\n\tend = p + cache_buffer.len;\n\n\t*header = *(multipart_cache_header_t*)p;\n\tp += sizeof(*header);\n\n\tpart_count = header->part_count;\n\tif ((size_t)(end - p) < part_count * sizeof(part_sizes[0]))\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_buffer_cache_fetch_multipart_perf: size %uz too small to hold %uD parts\", \n\t\t\tcache_buffer.len, part_count);\n\t\treturn 0;\n\t}\n\tpart_sizes = (void*)p;\n\tp += part_count * sizeof(part_sizes[0]);\n\n\tparts = ngx_palloc(ctx->submodule_context.request_context.pool, sizeof(parts[0]) * part_count);\n\tif (parts == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_buffer_cache_fetch_multipart_perf: ngx_palloc failed\");\n\t\treturn 0;\n\t}\n\n\tcur_part = parts;\n\n\tfor (; part_count > 0; part_count--)\n\t{\n\t\tcur_size = *part_sizes++;\n\t\tif ((size_t)(end - p) < cur_size)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_buffer_cache_fetch_multipart_perf: size left %uz smaller than part size %uz\", \n\t\t\t\t(size_t)(end - p), cur_size);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcur_part->data = p;\n\t\tp += cur_size;\n\n\t\tcur_part->len = cur_size;\n\t\tcur_part++;\n\t}\n\n\t*out_parts = parts;\n\treturn 1;\n}\n\n////// Utility functions\n\nstatic ngx_int_t\nngx_http_vod_send_header(\n\tngx_http_request_t* r, \n\toff_t content_length_n, \n\tngx_str_t* content_type, \n\tuint32_t media_set_type,\n\tconst ngx_http_vod_request_t* request)\n{\n\tngx_http_vod_loc_conf_t* conf;\n\tngx_int_t rc;\n\ttime_t expires;\n\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\n\tif (content_type != NULL)\n\t{\n\t\tr->headers_out.content_type = *content_type;\n\t\tr->headers_out.content_type_len = content_type->len;\n\t}\n\t\n\tr->headers_out.status = NGX_HTTP_OK;\n\tr->headers_out.content_length_n = content_length_n;\n\n\t// last modified\n\tif (request == NULL || \n\t\t(request->request_class & (REQUEST_CLASS_SEGMENT | REQUEST_CLASS_THUMB)) != 0 ||\n\t\tmedia_set_type == MEDIA_SET_VOD)\n\t{\n\t\tif (conf->last_modified_time != -1 &&\n\t\t\tngx_http_test_content_type(r, &conf->last_modified_types) != NULL)\n\t\t{\n\t\t\tr->headers_out.last_modified_time = conf->last_modified_time;\n\t\t}\n\n\t\texpires = conf->expires[EXPIRES_TYPE_VOD];\n\t}\n\telse\n\t{\n\t\tr->headers_out.last_modified_time = ngx_time();\n\n\t\tif ((request->flags & REQUEST_FLAG_TIME_DEPENDENT_ON_LIVE) != 0)\n\t\t{\n\t\t\texpires = conf->expires[EXPIRES_TYPE_LIVE_TIME_DEPENDENT];\n\t\t}\n\t\telse\n\t\t{\n\t\t\texpires = conf->expires[EXPIRES_TYPE_LIVE];\n\t\t}\n\t}\n\n\t// expires\n\tif (expires >= 0)\n\t{\n\t\trc = ngx_http_vod_set_expires(r, expires);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_send_header: ngx_http_vod_set_expires failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t// set the etag\n\trc = ngx_http_set_etag(r);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_header: ngx_http_set_etag failed %i\", rc);\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t// send the response headers\n\trc = ngx_http_send_header(r);\n\tif (rc == NGX_ERROR || rc > NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_header: ngx_http_send_header failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic void\nngx_http_vod_finalize_request(ngx_http_vod_ctx_t *ctx, ngx_int_t rc)\n{\n\tif (ctx->submodule_context.r->header_sent && rc != NGX_OK)\n\t{\n\t\trc = NGX_ERROR;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->total_perf_counter_context, PC_TOTAL);\n\n\tngx_http_finalize_request(ctx->submodule_context.r, rc);\n}\n\nstatic ngx_int_t\nngx_http_vod_alloc_read_buffer(ngx_http_vod_ctx_t *ctx, size_t size, off_t alignment)\n{\n\tu_char* start = ctx->read_buffer.start;\n\n\tsize += VOD_BUFFER_PADDING_SIZE;\t\t// for null termination / ffmpeg padding\n\n\tif (start == NULL ||\t\t\t\t\t\t\t\t\t\t// no buffer\n\t\tstart + size > ctx->read_buffer.end ||\t\t\t\t\t// buffer too small\n\t\t((intptr_t)start & (alignment - 1)) != 0)\t// buffer not conforming to alignment\n\t{\n\t\tif (alignment > 1)\n\t\t{\n\t\t\tstart = ngx_pmemalign(ctx->submodule_context.request_context.pool, size, alignment);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart = ngx_palloc(ctx->submodule_context.request_context.pool, size);\n\t\t}\n\n\t\tif (start == NULL)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_alloc_read_buffer: failed to allocate read buffer of size %uz\", size);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t\t}\n\n\t\tctx->read_buffer.start = start;\n\t\tctx->read_buffer.end = start + size;\n\t\tctx->read_buffer.temporary = 1;\n\t}\n\n\tctx->read_buffer.pos = start;\n\tctx->read_buffer.last = start;\n\n\treturn NGX_OK;\n}\n\n////// DRM\n\nstatic void\nngx_http_vod_copy_drm_info(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_sequence_t* ref_sequence = ctx->cur_sequence;\n\tmedia_sequence_t* cur_sequence;\n\n\tfor (cur_sequence = ref_sequence + 1;\n\t\tcur_sequence < ctx->submodule_context.media_set.sequences_end;\n\t\tcur_sequence++)\n\t{\n\t\tcur_sequence->drm_info = ref_sequence->drm_info;\n\t}\n}\n\nstatic void\nngx_http_vod_drm_info_request_finished(void* context, ngx_int_t rc, ngx_buf_t* response, ssize_t content_length)\n{\n\tngx_http_vod_loc_conf_t *conf;\n\tngx_http_vod_ctx_t *ctx;\n\tngx_http_request_t *r = context;\n\tngx_str_t drm_info;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tconf = ctx->submodule_context.conf;\n\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_drm_info_request_finished: upstream request failed %i\", rc);\n\t\tgoto finalize_request;\n\t}\n\n\tif (response->last >= response->end)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_drm_info_request_finished: not enough room in buffer for null terminator\");\n\t\trc = NGX_HTTP_BAD_GATEWAY;\n\t\tgoto finalize_request;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_GET_DRM_INFO);\n\n\tdrm_info.data = response->pos;\n\tdrm_info.len = content_length;\n\t*response->last = '\\0';\n\n\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \n\t\t\"ngx_http_vod_drm_info_request_finished: result %V\", &drm_info);\n\n\t// parse the drm info\n\trc = conf->submodule.parse_drm_info(&ctx->submodule_context, &drm_info, &ctx->cur_sequence->drm_info);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_drm_info_request_finished: invalid drm info response %V\", &drm_info);\n\t\trc = NGX_HTTP_SERVICE_UNAVAILABLE;\n\t\tgoto finalize_request;\n\t}\n\n\t// save to cache\n\tif (conf->drm_info_cache != NULL)\n\t{\n\t\tif (ngx_buffer_cache_store_perf(\n\t\t\tctx->perf_counters,\n\t\t\tconf->drm_info_cache,\n\t\t\tctx->child_request_key,\n\t\t\tdrm_info.data,\n\t\t\tdrm_info.len))\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_drm_info_request_finished: stored in drm info cache\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_drm_info_request_finished: failed to store drm info in cache\");\n\t\t}\n\t}\n\n\tif (conf->drm_single_key)\n\t{\n\t\tngx_http_vod_copy_drm_info(ctx);\n\t\tctx->cur_sequence = ctx->submodule_context.media_set.sequences_end;\n\t}\n\telse\n\t{\n\t\tctx->cur_sequence++;\n\t}\n\n\trc = ngx_http_vod_run_state_machine(ctx);\n\tif (rc == NGX_AGAIN)\n\t{\n\t\treturn;\n\t}\n\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_drm_info_request_finished: ngx_http_vod_run_state_machine failed %i\", rc);\n\t}\n\nfinalize_request:\n\n\tngx_http_vod_finalize_request(ctx, rc);\n}\n\nstatic ngx_int_t\nngx_http_vod_state_machine_get_drm_info(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_child_request_params_t child_params;\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\tngx_http_request_t* r = ctx->submodule_context.r;\n\tngx_int_t rc;\n\tngx_str_t drm_info;\n\tngx_str_t base_uri;\n\tngx_md5_t md5;\n\tuint32_t cache_token;\n\n\tfor (;\n\t\tctx->cur_sequence < ctx->submodule_context.media_set.sequences_end;\n\t\tctx->cur_sequence++)\n\t{\n\t\t// get the request uri\n\t\tif (conf->drm_request_uri != NULL)\n\t\t{\n\t\t\tif (ngx_http_complex_value(\n\t\t\t\tr,\n\t\t\t\tconf->drm_request_uri,\n\t\t\t\t&base_uri) != NGX_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_state_machine_get_drm_info: ngx_http_complex_value failed\");\n\t\t\t\treturn NGX_ERROR;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase_uri = ctx->cur_sequence->stripped_uri;\n\t\t}\n\n\t\tif (conf->drm_info_cache != NULL)\n\t\t{\n\t\t\t// generate a request key\n\t\t\tngx_md5_init(&md5);\n\t\t\tngx_md5_update(&md5, conf->drm_upstream_location.data, conf->drm_upstream_location.len);\n\t\t\tngx_md5_update(&md5, base_uri.data, base_uri.len);\n\t\t\tngx_md5_final(ctx->child_request_key, &md5);\n\n\t\t\t// try to read the drm info from cache\n\t\t\tif (ngx_buffer_cache_fetch_perf(\n\t\t\t\tctx->perf_counters, \n\t\t\t\tconf->drm_info_cache, \n\t\t\t\tctx->child_request_key,\n\t\t\t\t&drm_info, \n\t\t\t\t&cache_token))\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_state_machine_get_drm_info: drm info cache hit, size is %uz\", drm_info.len);\n\n\t\t\t\trc = conf->submodule.parse_drm_info(&ctx->submodule_context, &drm_info, &ctx->cur_sequence->drm_info);\n\t\t\t\tif (rc != NGX_OK)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_get_drm_info: invalid drm info in cache %V\", &drm_info);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\tngx_buffer_cache_release(\n\t\t\t\t\tconf->drm_info_cache,\n\t\t\t\t\tctx->child_request_key, \n\t\t\t\t\tcache_token);\n\n\t\t\t\tif (conf->drm_single_key)\n\t\t\t\t{\n\t\t\t\t\tngx_http_vod_copy_drm_info(ctx);\n\t\t\t\t\tctx->cur_sequence = ctx->submodule_context.media_set.sequences_end - 1;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_state_machine_get_drm_info: drm info cache miss\");\n\t\t\t}\n\t\t}\n\n\t\tr->connection->log->action = \"getting drm info\";\n\n\t\trc = ngx_http_vod_alloc_read_buffer(ctx, conf->drm_max_info_length + conf->max_upstream_headers_size + 1, 1);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// start the drm request\n\t\tngx_memzero(&child_params, sizeof(child_params));\n\t\tchild_params.method = NGX_HTTP_GET;\n\t\tchild_params.base_uri = base_uri;\n\n\t\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t\trc = ngx_child_request_start(\n\t\t\tr,\n\t\t\tngx_http_vod_drm_info_request_finished,\n\t\t\tr,\n\t\t\t&conf->drm_upstream_location,\n\t\t\t&child_params,\n\t\t\t&ctx->read_buffer);\n\t\tif (rc != NGX_AGAIN)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_state_machine_get_drm_info: ngx_child_request_start failed %i\", rc);\n\t\t}\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\n////// Common media processing\n\nstatic void\nngx_http_vod_update_source_tracks(\n\trequest_context_t* request_context,\n\tmedia_clip_source_t* cur_source)\n{\n\tmedia_track_t* cur_track;\n\tfile_info_t file_info;\n\tuint32_t time_shift;\n\tint64_t original_clip_time;\n\n\tfile_info.source = cur_source;\n\tfile_info.uri = cur_source->uri;\n\tfile_info.drm_info = cur_source->sequence->drm_info;\n\n\toriginal_clip_time = cur_source->range != NULL ?\n\t\tcur_source->range->original_clip_time : cur_source->clip_time;\n\n\tfor (cur_track = cur_source->track_array.first_track;\n\t\tcur_track < cur_source->track_array.last_track;\n\t\tcur_track++)\n\t{\n\t\ttime_shift = cur_source->time_shift[cur_track->media_info.media_type];\n\t\tcur_track->first_frame_time_offset += rescale_time(time_shift, 1000, cur_track->media_info.timescale);\n\t\tcur_track->clip_start_time = cur_source->clip_time;\n\t\tcur_track->original_clip_time = original_clip_time;\n\t\tcur_track->file_info = file_info;\n\n\t\tvod_log_debug1(VOD_LOG_DEBUG_LEVEL, request_context->log, 0,\n\t\t\t\"ngx_http_vod_update_source_tracks: first frame dts is %uL\",\n\t\t\trescale_time(cur_track->first_frame_time_offset, cur_track->media_info.timescale, 1000) +\n\t\t\tcur_track->clip_start_time);\n\t}\n}\n\nstatic void\nngx_http_vod_get_sequence_tracks_mask(\n\trequest_params_t* request_params,\n\tmedia_sequence_t* sequence,\n\ttrack_mask_t** result)\n{\n\tsequence_tracks_mask_t* sequence_tracks_mask;\n\tngx_str_t* cur_sequence_id;\n\tint32_t index;\n\n\tfor (sequence_tracks_mask = request_params->sequence_tracks_mask; \n\t\tsequence_tracks_mask < request_params->sequence_tracks_mask_end;\n\t\tsequence_tracks_mask++)\n\t{\n\t\tindex = sequence_tracks_mask->index;\n\t\tif (index >= 0)\n\t\t{\n\t\t\tif (sequence->index != (uint32_t)index)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur_sequence_id = request_params->sequence_ids + (-index - 1);\n\t\t\tif (sequence->id.len != cur_sequence_id->len ||\n\t\t\t\tvod_memcmp(sequence->id.data, cur_sequence_id->data, cur_sequence_id->len) != 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t*result = sequence_tracks_mask->tracks_mask;\n\t\tbreak;\n\t}\n}\n\nstatic void\nngx_http_vod_init_parse_params_metadata(\n\tngx_http_vod_ctx_t *ctx,\n\ttrack_mask_t* tracks_mask,\n\tmedia_parse_params_t* parse_params)\n{\n\tconst ngx_http_vod_request_t* request = ctx->request;\n\tmedia_clip_source_t* cur_source = ctx->cur_source;\n\tsegmenter_conf_t* segmenter = ctx->submodule_context.media_set.segmenter_conf;\n\ttrack_mask_t* request_tracks_mask;\n\tuint32_t media_type;\n\n\tif (request != NULL)\n\t{\n\t\tparse_params->parse_type = request->parse_type;\n\t\tif (request->request_class == REQUEST_CLASS_MANIFEST &&\n\t\t\tctx->submodule_context.media_set.timing.durations == NULL)\n\t\t{\n\t\t\tparse_params->parse_type |= segmenter->parse_type;\n\t\t}\n\t\tparse_params->parse_type |= ctx->submodule_context.conf->parse_flags;\n\t\tparse_params->codecs_mask = request->codecs_mask;\n\t}\n\n\trequest_tracks_mask = ctx->submodule_context.request_params.tracks_mask;\n\tif (ctx->submodule_context.request_params.sequence_tracks_mask != NULL)\n\t{\n\t\tngx_http_vod_get_sequence_tracks_mask(\n\t\t\t&ctx->submodule_context.request_params,\n\t\t\tcur_source->sequence,\n\t\t\t&request_tracks_mask);\n\t}\n\n\tfor (media_type = 0; media_type < MEDIA_TYPE_COUNT; media_type++)\n\t{\n\t\tvod_track_mask_and_bits(tracks_mask[media_type], cur_source->tracks_mask[media_type], request_tracks_mask[media_type]);\n\t}\n\tparse_params->required_tracks_mask = tracks_mask;\n\tparse_params->langs_mask = ctx->submodule_context.request_params.langs_mask;\n\tparse_params->source = cur_source;\n}\n\nstatic ngx_int_t\nngx_http_vod_init_parse_params_frames(\n\tngx_http_vod_ctx_t *ctx,\n\tmedia_range_t* range,\n\tmedia_parse_params_t* parse_params)\n{\n\tconst ngx_http_vod_request_t* request = ctx->request;\n\tget_clip_ranges_params_t get_ranges_params;\n\tget_clip_ranges_result_t clip_ranges;\n\tmedia_clip_source_t* cur_source = ctx->cur_source;\n\trequest_context_t* request_context = &ctx->submodule_context.request_context;\n\tsegmenter_conf_t* segmenter = ctx->submodule_context.media_set.segmenter_conf;\n\tvod_fraction_t rate;\n\tvod_status_t rc;\n\tuint64_t last_segment_end;\n\tuint32_t duration_millis;\n\n\tparse_params->max_frames_size = ctx->submodule_context.conf->max_frames_size;\n\n\tif ((request->request_class & (REQUEST_CLASS_MANIFEST | REQUEST_CLASS_OTHER)) != 0)\n\t{\n\t\trequest_context->simulation_only = TRUE;\n\n\t\tparse_params->max_frame_count = ctx->submodule_context.conf->max_frame_count;\n\t\trange->timescale = 1000;\n\t\trange->original_clip_time = 0;\n\t\trange->start = 0;\n\t\tif (cur_source->clip_to == ULLONG_MAX)\n\t\t{\n\t\t\trange->end = ULLONG_MAX;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trange->end = cur_source->clip_to - cur_source->clip_from;\n\t\t}\n\t\tparse_params->range = range;\n\t\treturn NGX_OK;\n\t}\n\n\trequest_context->simulation_only = FALSE;\n\n\tparse_params->max_frame_count = ctx->submodule_context.conf->segment_max_frame_count;\n\n\tif (cur_source->range != NULL)\n\t{\n\t\t// the range was already determined while parsing the media set\n\t\tparse_params->range = cur_source->range;\n\t\treturn NGX_OK;\n\t}\n\n\t// get the rate\n\tif (cur_source->base.parent != NULL && cur_source->base.parent->type == MEDIA_CLIP_RATE_FILTER)\n\t{\n\t\trate = ((media_clip_rate_filter_t*)cur_source->base.parent)->rate;\n\t}\n\telse\n\t{\n\t\trate.num = 1;\n\t\trate.denom = 1;\n\t}\n\n\t// get the last segment end\n\tif (cur_source->clip_to == ULLONG_MAX)\n\t{\n\t\tlast_segment_end = ULLONG_MAX;\n\t}\n\telse\n\t{\n\t\tlast_segment_end = ((cur_source->clip_to - cur_source->clip_from) * rate.denom) / rate.num;\n\t}\n\n\t// get the start/end offsets\n\tduration_millis = rescale_time(ctx->base_metadata->duration * rate.denom, ctx->base_metadata->timescale * rate.num, 1000);\n\n\tget_ranges_params.request_context = request_context;\n\tget_ranges_params.conf = segmenter;\n\tget_ranges_params.last_segment_end = last_segment_end;\n\tget_ranges_params.key_frame_durations = NULL;\n\tget_ranges_params.allow_last_segment = TRUE;\n\n\tngx_memzero(&get_ranges_params.timing, sizeof(get_ranges_params.timing));\n\tget_ranges_params.timing.durations = &duration_millis;\n\tget_ranges_params.timing.total_count = 1;\n\tget_ranges_params.timing.total_duration = duration_millis;\n\tget_ranges_params.timing.times = &get_ranges_params.timing.first_time;\n\tget_ranges_params.timing.original_times = &get_ranges_params.timing.first_time;\n\n\tif (ctx->submodule_context.request_params.segment_index != INVALID_SEGMENT_INDEX)\n\t{\n\t\t// segment request\n\t\tget_ranges_params.segment_index = ctx->submodule_context.request_params.segment_index;\n\n\t\trc = segmenter_get_start_end_ranges_no_discontinuity(\n\t\t\t&get_ranges_params,\n\t\t\t&clip_ranges);\n\n\t\tctx->submodule_context.media_set.initial_segment_clip_relative_index = clip_ranges.clip_relative_segment_index;\n\t}\n\telse\n\t{\n\t\t// thumbnail request\n\t\tget_ranges_params.time = ctx->submodule_context.request_params.segment_time;\n\n\t\trc = segmenter_get_start_end_ranges_gop(\n\t\t\t&get_ranges_params,\n\t\t\t&clip_ranges);\n\t}\n\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, request_context->log, 0,\n\t\t\t\"ngx_http_vod_init_parse_params_frames: segmenter_get_start_end_ranges_no_discontinuity failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\tif (clip_ranges.clip_count == 0)\n\t{\n\t\treturn NGX_DONE;\n\t}\n\n\tif (clip_ranges.clip_ranges->end == ULLONG_MAX)\n\t{\n\t\tctx->submodule_context.media_set.segment_duration =\n\t\t\tduration_millis - clip_ranges.clip_ranges->start;\n\t}\n\telse\n\t{\n\t\tctx->submodule_context.media_set.segment_duration =\n\t\t\tclip_ranges.clip_ranges->end - clip_ranges.clip_ranges->start;\n\t}\n\tctx->submodule_context.media_set.segment_start_time = clip_ranges.clip_ranges->start;\n\n\tparse_params->range = clip_ranges.clip_ranges;\n\tparse_params->range->start = (parse_params->range->start * rate.num) / rate.denom;\n\tif (parse_params->range->end != ULLONG_MAX)\n\t{\n\t\tparse_params->range->end = (parse_params->range->end * rate.num) / rate.denom;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t \nngx_http_vod_parse_metadata(\n\tngx_http_vod_ctx_t *ctx, \n\tngx_flag_t fetched_from_cache)\n{\n\tmedia_parse_params_t parse_params;\n\tconst ngx_http_vod_request_t* request = ctx->request;\n\tmedia_clip_source_t* cur_source = ctx->cur_source;\n\trequest_context_t* request_context = &ctx->submodule_context.request_context;\n\tmedia_range_t range;\n\tvod_status_t rc;\n\ttrack_mask_t tracks_mask[MEDIA_TYPE_COUNT];\n\n\t// initialize clipping params\n\tif (cur_source->clip_to == ULLONG_MAX)\n\t{\n\t\tif (cur_source->clip_from >= UINT_MAX)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, request_context->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_metadata: clip from value %uL too large\", cur_source->clip_from);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tparse_params.clip_to = UINT_MAX;\n\t}\n\telse\n\t{\n\t\tif (cur_source->clip_to >= UINT_MAX)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, request_context->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_metadata: clip to value %uL too large\", cur_source->clip_to);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tparse_params.clip_to = cur_source->clip_to;\n\t}\n\tparse_params.clip_from = cur_source->clip_from;\n\n\tngx_http_vod_init_parse_params_metadata(\n\t\tctx,\n\t\ttracks_mask,\n\t\t&parse_params);\n\n\tif (request == NULL)\n\t{\n\t\t// Note: the other fields in parse_params are not required here\n\n\t\tif (ctx->format->clipper_parse == NULL)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, request_context->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_metadata: clipping not supported for %V\", &ctx->format->name);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\trc = ctx->format->clipper_parse(\n\t\t\trequest_context,\n\t\t\t&parse_params,\n\t\t\tctx->metadata_parts,\n\t\t\tctx->metadata_part_count,\n\t\t\tfetched_from_cache,\n\t\t\t&ctx->clipper_parse_result);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, request_context->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_metadata: clipper_parse(%V) failed %i\", &ctx->format->name, rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\treturn NGX_OK;\n\t}\n\n\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t// parse the basic metadata\n\trc = ctx->format->parse_metadata(\n\t\trequest_context,\n\t\t&parse_params,\n\t\tctx->metadata_parts,\n\t\tctx->metadata_part_count,\n\t\t&ctx->base_metadata);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, request_context->log, 0,\n\t\t\t\"ngx_http_vod_parse_metadata: parse_metadata(%V) failed %i\", &ctx->format->name, rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\tif (ctx->base_metadata->tracks.nelts == 0)\n\t{\n\t\tngx_memzero(&cur_source->track_array, sizeof(cur_source->track_array));\n\t\treturn VOD_OK;\n\t}\n\n\trc = ngx_http_vod_init_parse_params_frames(\n\t\tctx,\n\t\t&range,\n\t\t&parse_params);\n\tswitch (rc)\n\t{\n\tcase NGX_OK:\n\t\tbreak;\t\t// handled outside the switch\n\n\tcase NGX_DONE:\n\t\tngx_memzero(&cur_source->track_array, sizeof(cur_source->track_array));\n\t\treturn NGX_OK;\n\n\tdefault:\n\t\treturn rc;\n\t}\n\n\t// parse the frames\n\trc = ctx->format->read_frames(\n\t\trequest_context,\n\t\tctx->base_metadata,\n\t\t&parse_params,\n\t\tctx->submodule_context.media_set.segmenter_conf,\n\t\t&ctx->read_cache_state,\n\t\tNULL,\n\t\t&ctx->frames_read_req,\n\t\t&cur_source->track_array);\n\tswitch (rc)\n\t{\n\tcase VOD_OK:\n\t\tbreak;\t// handled outside the switch\n\n\tcase VOD_AGAIN:\n\t\treturn NGX_AGAIN;\n\n\tdefault:\n\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, request_context->log, 0,\n\t\t\t\"ngx_http_vod_parse_metadata: read_frames(%V) failed %i\", &ctx->format->name, rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\tngx_http_vod_update_source_tracks(request_context, cur_source);\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_MEDIA_PARSE);\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_identify_format(ngx_http_vod_ctx_t* ctx, ngx_str_t* buffer)\n{\n\tmedia_format_t** cur_format_ptr;\n\tmedia_format_t* cur_format;\n\tvod_status_t rc;\n\tngx_str_t path;\n\n\tfor (cur_format_ptr = media_formats; ; cur_format_ptr++)\n\t{\n\t\tcur_format = *cur_format_ptr;\n\t\tif (cur_format == NULL)\n\t\t{\n\t\t\tif (buffer->len > sizeof(wvm_file_magic) &&\n\t\t\t\tngx_memcmp(buffer->data, wvm_file_magic, sizeof(wvm_file_magic)) == 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_identify_format: wvm format is not supported\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tctx->cur_source->reader->get_path(ctx->cur_source->reader_context, &path);\n\t\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_identify_format: failed to identify the file format %V\", &path);\n\t\t\t}\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t\t}\n\n\t\trc = cur_format->init_metadata_reader(\n\t\t\t&ctx->submodule_context.request_context,\n\t\t\tbuffer,\n\t\t\tctx->submodule_context.conf->max_metadata_size,\n\t\t\t&ctx->metadata_reader_context);\n\t\tif (rc == VOD_NOT_FOUND)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_identify_format: init_metadata_reader(%V) failed %i\", &cur_format->name, rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\tctx->format = cur_format;\n\t\tbreak;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_init_format(ngx_http_vod_ctx_t* ctx, uint32_t format_id)\n{\n\tmedia_format_t** cur_format_ptr;\n\tmedia_format_t* cur_format;\n\n\tfor (cur_format_ptr = media_formats; ; cur_format_ptr++)\n\t{\n\t\tcur_format = *cur_format_ptr;\n\t\tif (cur_format == NULL)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_init_format: format id %uD not found\", format_id);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n\t\t}\n\n\t\tif (cur_format->id != format_id)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx->format = cur_format;\n\t\tbreak;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_async_read(ngx_http_vod_ctx_t* ctx, media_format_read_request_t* read_req)\n{\n\tsize_t prefix_size;\n\tsize_t buffer_size;\n\tsize_t read_size;\n\toff_t alignment;\n\toff_t read_offset;\n\tngx_int_t rc;\n\n\t// if we already reached the end of file and read offset is after the previous one, there's nothing to read\n\tif ((off_t)read_req->read_offset >= ctx->read_offset &&\n\t\t(size_t)(ctx->read_buffer.last - ctx->read_buffer.pos) < ctx->read_size)\n\t{\n\t\tctx->requested_offset = read_req->read_offset;\n\t\treturn NGX_OK;\n\t}\n\n\talignment = ctx->cur_source->alignment;\n\n\t// align the read size and offset\n\tread_offset = read_req->read_offset & (~(alignment - 1));\n\tif (read_req->read_size == 0)\n\t{\n\t\tread_size = ctx->submodule_context.conf->initial_read_size;\n\t}\n\telse\n\t{\n\t\tread_size = read_req->read_size + read_req->read_offset - read_offset;\n\t}\n\n\tread_size = (read_size + alignment - 1) & (~(alignment - 1));\n\n\t// optimization for the case in which the current range is a prefix of the new range\n\tbuffer_size = ctx->read_buffer.last - ctx->read_buffer.pos;\n\tprefix_size = 0;\n\n\tif (read_offset >= ctx->read_offset && \n\t\tread_offset < (off_t)(ctx->read_offset + buffer_size) &&\n\t\tctx->read_buffer.start != NULL)\n\t{\n\t\tprefix_size = ctx->read_offset + buffer_size - read_offset;\n\t\tctx->prefix_buffer = ctx->read_buffer;\n\t\tctx->prefix_buffer.pos = ctx->prefix_buffer.last - prefix_size;\n\t\tctx->read_buffer.start = NULL;\n\t}\n\telse if ((read_req->flags & MEDIA_READ_FLAG_REALLOC_BUFFER) != 0)\n\t{\n\t\tctx->read_buffer.start = NULL;\n\t}\n\n\t// allocate the read buffer\n\trc = ngx_http_vod_alloc_read_buffer(ctx, read_size + ctx->cur_source->alloc_extra_size, alignment);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (ctx->prefix_buffer.start != NULL)\n\t{\n\t\tctx->read_buffer.start += prefix_size;\n\t\tctx->read_buffer.pos = ctx->read_buffer.start;\n\t\tctx->read_buffer.last = ctx->read_buffer.start;\n\t}\n\n\t// perform the read\n\tctx->read_offset = read_offset;\n\tctx->requested_offset = read_req->read_offset;\n\tctx->read_size = read_size;\n\tctx->read_flags = read_req->flags;\n\n\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\trc = ctx->cur_source->reader->read(\n\t\tctx->cur_source->reader_context,\n\t\t&ctx->read_buffer,\n\t\tread_size - prefix_size,\n\t\tread_offset + prefix_size);\n\tif (rc != NGX_OK)\n\t{\n\t\tif (rc != NGX_AGAIN)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_async_read: async_read failed %i\", rc);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_READ_FILE);\n\n\treturn NGX_OK;\n}\n\n#if (NGX_HAVE_OPENSSL_EVP)\nstatic ngx_int_t\nngx_http_vod_decrypt_read_buffer(ngx_http_vod_ctx_t* ctx, vod_str_t* read_buffer)\n{\n\tmedia_clip_source_t* source;\n\tconst EVP_CIPHER* cipher;\n\tEVP_CIPHER_CTX* cc;\n\tngx_int_t rc;\n\tsize_t buffer_size;\n\tint out_size;\n\n\tif (ctx->read_offset != 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: invalid offset %O\", ctx->read_offset);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n\t}\n\n\tsource = ctx->cur_source;\n\n\tswitch (source->encryption.key.len)\n\t{\n\tcase 16:\n\t\tcipher = EVP_aes_128_cbc();\n\t\tbreak;\n\n\tcase 24:\n\t\tcipher = EVP_aes_192_cbc();\n\t\tbreak;\n\n\tcase 32:\n\t\tcipher = EVP_aes_256_cbc();\n\t\tbreak;\n\n\tdefault:\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: invalid key length %uz\", source->encryption.key.len);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_MAPPING);\n\t}\n\n\tif (source->encryption.iv.len != AES_BLOCK_SIZE)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: invalid iv length %uz\", source->encryption.iv.len);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_MAPPING);\n\t}\n\n\tbuffer_size = ctx->read_buffer.last - ctx->read_buffer.pos;\n\n\tread_buffer->data = ngx_palloc(ctx->submodule_context.request_context.pool, buffer_size + AES_BLOCK_SIZE + 1);\n\tif (read_buffer->data == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: alloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t}\n\n\tcc = EVP_CIPHER_CTX_new();\n\tif (cc == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: EVP_CIPHER_CTX_new failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t}\n\n\tif (EVP_DecryptInit_ex(cc, cipher, NULL, source->encryption.key.data, source->encryption.iv.data) != 1)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: EVP_DecryptInit_ex failed\");\n\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t\tgoto done;\n\t}\n\n\tif (EVP_DecryptUpdate(cc, read_buffer->data, &out_size, ctx->read_buffer.pos, buffer_size) != 1)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_decrypt_read_buffer: EVP_DecryptUpdate failed\");\n\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n\t\tgoto done;\n\t}\n\n\tread_buffer->len = out_size;\n\n\tif (buffer_size < ctx->read_size)\n\t{\n\t\tif (EVP_DecryptFinal_ex(cc, read_buffer->data + read_buffer->len, &out_size) != 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_decrypt_read_buffer: EVP_DecryptFinal_ex failed\");\n\t\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t\t\tgoto done;\n\t\t}\n\n\t\tread_buffer->len += out_size;\n\t}\n\n\trc = NGX_OK;\n\ndone:\n\n\tEVP_CIPHER_CTX_free(cc);\n\treturn rc;\n}\n#endif // NGX_HAVE_OPENSSL_EVP\n\nstatic ngx_int_t\nngx_http_vod_get_async_read_result(ngx_http_vod_ctx_t* ctx, vod_str_t* read_buffer)\n{\n#if (NGX_HAVE_OPENSSL_EVP)\n\tngx_int_t rc;\n#endif // NGX_HAVE_OPENSSL_EVP\n\tsize_t prefix_size;\n\toff_t buffer_offset;\n\n\tif (ctx->prefix_buffer.start != NULL)\n\t{\n\t\t// prepend the prefix buffer\n\t\tprefix_size = ctx->prefix_buffer.last - ctx->prefix_buffer.pos;\n\t\tctx->read_buffer.start -= prefix_size;\n\n\t\tctx->read_buffer.pos -= prefix_size;\n\t\tngx_memcpy(ctx->read_buffer.pos, ctx->prefix_buffer.pos, prefix_size);\n\n\t\tif ((ctx->read_flags & MEDIA_READ_FLAG_REALLOC_BUFFER) == 0)\t// should not free the buffer if there are references to it\n\t\t{\n\t\t\tngx_pfree(ctx->submodule_context.r->pool, ctx->prefix_buffer.start);\n\t\t}\n\t\tctx->prefix_buffer.start = NULL;\n\t}\n\n\t// adjust the buffer pointer following the alignment\n\tbuffer_offset = ctx->requested_offset - ctx->read_offset;\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tif (ctx->cur_source->encryption.key.len != 0 &&\n\t\tctx->cur_source->encryption.scheme == MCS_ENC_AES_CBC)\n\t{\n\t\trc = ngx_http_vod_decrypt_read_buffer(ctx, read_buffer);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\tif (ctx->read_buffer.last >= ctx->read_buffer.end)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_get_async_read_result: not enough room for null terminator\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n\t\t}\n\n\t\tread_buffer->data = ctx->read_buffer.pos;\n\t\tread_buffer->len = ctx->read_buffer.last - ctx->read_buffer.pos;\n\t}\n\n\tif (read_buffer->len < (size_t)buffer_offset)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_get_async_read_result: buffer size %uz is smaller than buffer offset %O\",\n\t\t\tread_buffer->len, buffer_offset);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t}\n\n\tread_buffer->data += buffer_offset;\n\tread_buffer->len -= buffer_offset;\n\n\t// null terminate the buffer\n\tread_buffer->data[read_buffer->len] = '\\0';\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_read_metadata(ngx_http_vod_ctx_t* ctx)\n{\n\tmedia_format_read_metadata_result_t result;\n\tvod_str_t read_buffer;\n\tngx_int_t rc;\n\n\tfor (;;)\n\t{\n\t\trc = ngx_http_vod_get_async_read_result(ctx, &read_buffer);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (ctx->metadata_reader_context == NULL)\n\t\t{\n\t\t\t// identify the format\n\t\t\trc = ngx_http_vod_identify_format(ctx, &read_buffer);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\t// run the read state machine\n\t\trc = ctx->format->read_metadata(\n\t\t\tctx->metadata_reader_context,\n\t\t\tctx->requested_offset,\n\t\t\t&read_buffer,\n\t\t\t&result);\n\t\tif (rc == VOD_OK)\n\t\t{\n\t\t\tctx->metadata_parts = result.parts;\n\t\t\tctx->metadata_part_count = result.part_count;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc != VOD_AGAIN)\n\t\t{\n\t\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_read_metadata: read_metadata(%V) failed %i\", &ctx->format->name, rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\t// issue another read request\n\t\trc = ngx_http_vod_async_read(ctx, &result.read_req);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_read_frames(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_format_read_request_t read_req;\n\trequest_context_t* request_context = &ctx->submodule_context.request_context;\n\tvod_str_t read_buffer;\n\tngx_int_t rc;\n\n\tfor (;;)\n\t{\n\t\trc = ngx_http_vod_get_async_read_result(ctx, &read_buffer);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// run the read state machine\n\t\trc = ctx->format->read_frames(\n\t\t\trequest_context,\n\t\t\tctx->base_metadata,\n\t\t\tNULL,\n\t\t\tctx->submodule_context.media_set.segmenter_conf,\n\t\t\t&ctx->read_cache_state,\n\t\t\t&read_buffer,\n\t\t\t&read_req,\n\t\t\t&ctx->cur_source->track_array);\n\t\tif (rc == VOD_OK)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc != VOD_AGAIN)\n\t\t{\n\t\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, request_context->log, 0,\n\t\t\t\t\"ngx_http_vod_read_frames: read_frames(%V) failed %i\", &ctx->format->name, rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\t// issue another read request\n\t\trc = ngx_http_vod_async_read(ctx, &read_req);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tngx_http_vod_update_source_tracks(request_context, ctx->cur_source);\n\n\treturn NGX_OK;\n}\n\nstatic void\nngx_http_vod_get_alloc_params(ngx_http_vod_ctx_t* ctx, ngx_http_vod_reader_t* reader, off_t* alignment, size_t* alloc_extra_size)\n{\n\tngx_http_core_loc_conf_t* clcf;\n\n\tif (reader == &reader_http)\n\t{\n\t\t*alignment = 1;\n\t\t*alloc_extra_size = ctx->submodule_context.conf->max_upstream_headers_size + 1;\t\t// the + 1 is discussed here : http://trac.nginx.org/nginx/ticket/680\n\t}\n\telse\n\t{\n\t\tclcf = ngx_http_get_module_loc_conf(ctx->submodule_context.r, ngx_http_core_module);\n\n\t\t*alignment = clcf->directio_alignment;\n\t\t*alloc_extra_size = 0;\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_open_file(ngx_http_vod_ctx_t* ctx, media_clip_source_t* source)\n{\n\tswitch (source->source_type)\n\t{\n\tcase MEDIA_CLIP_SOURCE_FILE:\n\t\tsource->reader = &reader_file;\n\t\tbreak;\n\n\tcase MEDIA_CLIP_SOURCE_HTTP:\n\t\tsource->reader = &reader_http;\n\t\tbreak;\n\n\tdefault:\t// MEDIA_CLIP_SOURCE_DEFAULT\n\t\tsource->reader = ctx->default_reader;\n\t\tbreak;\n\t}\n\n\tngx_http_vod_get_alloc_params(ctx, source->reader, &source->alignment, &source->alloc_extra_size);\n\n\treturn source->reader->open(ctx->submodule_context.r, &source->mapped_uri, 0, &source->reader_context);\n}\n\nstatic ngx_int_t\nngx_http_vod_state_machine_parse_metadata(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\tmultipart_cache_header_t multipart_header;\n\tmedia_clip_source_t* cur_source;\n\tngx_http_request_t* r = ctx->submodule_context.r;\n\tngx_int_t rc;\n\tuint32_t cache_token;\n\tbool_t metadata_loaded;\n\n\tif (ctx->cur_source == NULL)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\tfor (;;)\n\t{\n\t\tswitch (ctx->state)\n\t\t{\n\t\tcase STATE_READ_METADATA_INITIAL:\n\t\t\tmetadata_loaded = FALSE;\n\t\t\tcache_token = 0;\n\t\t\tcur_source = ctx->cur_source;\n\n\t\t\tif (cur_source->mapped_uri.len == empty_file_string.len &&\n\t\t\t\tngx_strncasecmp(cur_source->mapped_uri.data, empty_file_string.data, empty_file_string.len) == 0)\n\t\t\t{\n\t\t\t\t// the string \"empty\" identifies an empty srt file\n\t\t\t\tctx->metadata_parts = ngx_palloc(ctx->submodule_context.request_context.pool,\n\t\t\t\t\tsizeof(*ctx->metadata_parts) + 1);\n\t\t\t\tif (ctx->metadata_parts == NULL)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: ngx_palloc failed\");\n\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t\t\t\t}\n\n\t\t\t\tctx->metadata_parts[0].len = 0;\n\t\t\t\tctx->metadata_parts[0].data = (void*)(ctx->metadata_parts + 1);\n\t\t\t\tctx->metadata_parts[0].data[0] = '\\0';\n\t\t\t\tmultipart_header.type = FORMAT_ID_WEBVTT;\n\t\t\t\tmetadata_loaded = TRUE;\n\t\t\t}\n\t\t\telse if (conf->metadata_cache != NULL)\n\t\t\t{\n\t\t\t\t// try to fetch from cache\n\t\t\t\tif (ngx_buffer_cache_fetch_multipart_perf(\n\t\t\t\t\tctx,\n\t\t\t\t\tconf->metadata_cache,\n\t\t\t\t\tcur_source->file_key,\n\t\t\t\t\t&multipart_header,\n\t\t\t\t\t&ctx->metadata_parts,\n\t\t\t\t\t&cache_token))\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: metadata cache hit\");\n\t\t\t\t\tmetadata_loaded = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: metadata cache miss\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (metadata_loaded)\n\t\t\t{\n\t\t\t\t// parse the metadata\n\t\t\t\trc = ngx_http_vod_init_format(ctx, multipart_header.type);\n\t\t\t\tif (rc != NGX_OK)\n\t\t\t\t{\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\trc = ngx_http_vod_parse_metadata(ctx, 1);\n\n\t\t\t\tif (cache_token && \n\t\t\t\t\tctx->request != NULL)\t\t// in case of progressive, the metadata parts are used in clipper_build_header\n\t\t\t\t{\n\t\t\t\t\tngx_buffer_cache_release(\n\t\t\t\t\t\tconf->metadata_cache,\n\t\t\t\t\t\tcur_source->file_key,\n\t\t\t\t\t\tcache_token);\n\t\t\t\t}\n\n\t\t\t\tif (rc == NGX_OK)\n\t\t\t\t{\n\t\t\t\t\tctx->cur_source = cur_source->next;\n\t\t\t\t\tif (ctx->cur_source == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn NGX_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rc != NGX_AGAIN)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: ngx_http_vod_parse_metadata failed %i\", rc);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\tctx->state = STATE_READ_FRAMES_OPEN_FILE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tctx->state = STATE_READ_METADATA_OPEN_FILE;\n\t\t\t}\n\n\t\t\t// open the file\n\t\t\trc = ngx_http_vod_open_file(ctx, cur_source);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\tif (rc != NGX_AGAIN)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: open_file failed %i\", rc);\n\t\t\t\t}\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase STATE_READ_METADATA_OPEN_FILE:\n\t\t\t// allocate the initial read buffer\n\t\t\tcur_source = ctx->cur_source;\n\n\t\t\trc = ngx_http_vod_alloc_read_buffer(ctx, conf->initial_read_size + cur_source->alloc_extra_size, cur_source->alignment);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// read the file header\n\t\t\tr->connection->log->action = \"reading media header\";\n\t\t\tctx->state = STATE_READ_METADATA_READ;\n\t\t\tctx->metadata_reader_context = NULL;\n\n\t\t\tctx->read_offset = 0;\n\t\t\tctx->read_size = conf->initial_read_size;\n\t\t\tctx->requested_offset = 0;\n\t\t\tctx->read_flags = MEDIA_READ_FLAG_ALLOW_EMPTY_READ;\n\n\t\t\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t\t\trc = cur_source->reader->read(cur_source->reader_context, &ctx->read_buffer, conf->initial_read_size, 0);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\tif (rc != NGX_AGAIN)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: async_read failed %i\", rc);\n\t\t\t\t}\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// read completed synchronously\n\t\t\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_READ_FILE);\n\t\t\t// fall through\n\n\t\tcase STATE_READ_METADATA_READ:\n\t\t\t// read the metadata\n\t\t\trc = ngx_http_vod_read_metadata(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\tif (rc != NGX_AGAIN)\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: ngx_http_vod_read_metadata failed %i\", rc);\n\t\t\t\t}\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// parse the metadata\n\t\t\trc = ngx_http_vod_parse_metadata(ctx, 0);\n\t\t\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: ngx_http_vod_parse_metadata failed %i\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// save the metadata to cache\n\t\t\tcur_source = ctx->cur_source;\n\n\t\t\tif (conf->metadata_cache != NULL)\n\t\t\t{\n\t\t\t\tmultipart_header.type = ctx->format->id;\n\t\t\t\tmultipart_header.part_count = ctx->metadata_part_count;\n\n\t\t\t\tif (ngx_buffer_cache_store_multipart_perf(\n\t\t\t\t\tctx,\n\t\t\t\t\tconf->metadata_cache,\n\t\t\t\t\tcur_source->file_key,\n\t\t\t\t\t&multipart_header,\n\t\t\t\t\tctx->metadata_parts))\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: stored metadata in cache\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: failed to store metadata in cache\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ctx->request != NULL)\n\t\t\t{\n\t\t\t\t// no longer need the metadata buffer\n\t\t\t\tngx_pfree(ctx->submodule_context.r->pool, ctx->read_buffer.start);\n\t\t\t\tctx->read_buffer.start = NULL;\n\t\t\t}\n\n\t\t\tif (rc == NGX_OK)\n\t\t\t{\n\t\t\t\t// move to the next source\n\t\t\t\tctx->state = STATE_READ_METADATA_INITIAL;\n\n\t\t\t\tctx->cur_source = cur_source->next;\n\t\t\t\tif (ctx->cur_source == NULL)\n\t\t\t\t{\n\t\t\t\t\treturn NGX_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// fall through\n\n\t\tcase STATE_READ_FRAMES_OPEN_FILE:\n\t\t\tctx->state = STATE_READ_FRAMES_READ;\n\t\t\tctx->read_buffer.start = NULL;\t\t\t// don't reuse buffers from the metadata phase\n\t\t\tctx->read_size = 0;\n\n\t\t\trc = ngx_http_vod_async_read(ctx, &ctx->frames_read_req);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\t// fall through\n\n\t\tcase STATE_READ_FRAMES_READ:\n\t\t\trc = ngx_http_vod_read_frames(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// move to the next source\n\t\t\tctx->state = STATE_READ_METADATA_INITIAL;\n\n\t\t\tctx->cur_source = ctx->cur_source->next;\n\t\t\tif (ctx->cur_source == NULL)\n\t\t\t{\n\t\t\t\treturn NGX_OK;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_state_machine_parse_metadata: invalid state %d\", ctx->state);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_UNEXPECTED);\n\t\t}\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_validate_streams(ngx_http_vod_ctx_t *ctx)\n{\n\tif (ctx->submodule_context.media_set.total_track_count == 0)\n\t{\n\t\tif (ctx->request->request_class == REQUEST_CLASS_SEGMENT)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: no matching streams were found, probably invalid segment index\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_NO_STREAMS);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: no matching streams were found\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\t}\n\t\n\tif ((ctx->request->flags & REQUEST_FLAG_SINGLE_TRACK) != 0)\n\t{\n\t\tif (ctx->submodule_context.media_set.sequence_count != 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: request has more than one sequence while only one is supported\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tif (ctx->submodule_context.media_set.total_track_count != 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: got %uD streams while only a single stream is supported\",\n\t\t\t\tctx->submodule_context.media_set.total_track_count);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\t}\n\telse if ((ctx->request->flags & REQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE) != 0)\n\t{\n\t\tif (ctx->submodule_context.media_set.sequence_count != 1 && ctx->submodule_context.media_set.sequence_count != 2)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: invalid sequence count %uD\", ctx->submodule_context.media_set.sequence_count);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tif (ctx->submodule_context.media_set.track_count[MEDIA_TYPE_VIDEO] > 1 ||\n\t\t\tctx->submodule_context.media_set.track_count[MEDIA_TYPE_AUDIO] > 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: one stream at most per media type is allowed video=%uD audio=%uD\",\n\t\t\t\tctx->submodule_context.media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\t\t\tctx->submodule_context.media_set.track_count[MEDIA_TYPE_AUDIO]);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tif (ctx->submodule_context.media_set.track_count[MEDIA_TYPE_SUBTITLE] > 0 &&\n\t\t\tctx->submodule_context.media_set.total_track_count != 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_validate_streams: cannot have more than a single subtitle track and it cannot be mixed with other track types\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\t}\n\t\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_update_track_timescale(\n\tngx_http_vod_ctx_t *ctx, \n\tmedia_track_t* track, \n\tuint32_t new_timescale, \n\tuint32_t pts_delay)\n{\n\tframe_list_part_t* part;\n\tinput_frame_t* last_frame;\n\tinput_frame_t* cur_frame;\n\tuint64_t next_scaled_dts;\n\tuint64_t last_frame_dts;\n\tuint64_t clip_start_dts;\n\tuint64_t clip_end_pts;\n\tuint64_t clip_end_dts;\n\tuint64_t scaled_dts;\n\tuint64_t scaled_pts;\n\tuint64_t dts;\n\tuint64_t pts;\n\tuint32_t cur_timescale = track->media_info.timescale;\n\n\t// frames\n\tdts = track->first_frame_time_offset;\n\tscaled_dts = rescale_time(dts, cur_timescale, new_timescale);\n\tclip_start_dts = scaled_dts;\n\n\ttrack->first_frame_time_offset = scaled_dts;\n\ttrack->total_frames_duration = 0;\n\n\t// initialize the first part\n\tpart = &track->frames;\n\tcur_frame = part->first_frame;\n\tlast_frame = part->last_frame;\n\tif (part->clip_to != UINT_MAX && cur_frame < last_frame)\n\t{\n\t\tclip_end_dts = rescale_time(part->clip_to, 1000, new_timescale);\n\t\tif (track->media_info.media_type == MEDIA_TYPE_VIDEO)\n\t\t{\n\t\t\tclip_end_pts = clip_end_dts + rescale_time(track->media_info.u.video.initial_pts_delay,\n\t\t\t\tcur_timescale, new_timescale);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclip_end_pts = ULLONG_MAX;\n\t\t}\n\t}\n\telse\n\t{\n\t\tclip_end_dts = ULLONG_MAX;\n\t\tclip_end_pts = ULLONG_MAX;\n\t}\n\n\tfor (;; cur_frame++)\n\t{\n\t\tif (cur_frame >= last_frame)\n\t\t{\n\t\t\tif (clip_end_dts != ULLONG_MAX)\n\t\t\t{\n\t\t\t\tclip_end_dts = rescale_time(part->clip_to, 1000, new_timescale);\n\t\t\t\tlast_frame_dts = scaled_dts - cur_frame[-1].duration;\n\n\t\t\t\tif (clip_end_dts > last_frame_dts)\n\t\t\t\t{\n\t\t\t\t\tcur_frame[-1].duration = clip_end_dts - last_frame_dts;\n\t\t\t\t\tscaled_dts = clip_end_dts;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tngx_log_error(NGX_LOG_WARN, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_update_track_timescale: last frame dts %uL greater than clip end dts %uL\",\n\t\t\t\t\t\tlast_frame_dts, clip_end_dts);\n\t\t\t\t}\n\n\t\t\t\ttrack->total_frames_duration += scaled_dts - clip_start_dts;\n\n\t\t\t\tdts = 0;\n\t\t\t\tscaled_dts = 0;\n\t\t\t\tclip_start_dts = 0;\n\t\t\t}\n\n\t\t\tif (part->next == NULL)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// initialize the next part\n\t\t\tpart = part->next;\n\t\t\tcur_frame = part->first_frame;\n\t\t\tlast_frame = part->last_frame;\n\t\t\tif (part->clip_to != UINT_MAX && cur_frame < last_frame)\n\t\t\t{\n\t\t\t\tclip_end_dts = rescale_time(part->clip_to, 1000, new_timescale);\n\t\t\t\tif (track->media_info.media_type == MEDIA_TYPE_VIDEO)\n\t\t\t\t{\n\t\t\t\t\tclip_end_pts = clip_end_dts + rescale_time(track->media_info.u.video.initial_pts_delay,\n\t\t\t\t\t\tcur_timescale, new_timescale);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tclip_end_dts = ULLONG_MAX;\n\t\t\t\tclip_end_pts = ULLONG_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// get the pts delay\n\t\tpts = dts + cur_frame->pts_delay;\n\t\tscaled_pts = rescale_time(pts, cur_timescale, new_timescale);\n\t\tif (scaled_pts > clip_end_pts)\n\t\t{\n\t\t\tscaled_pts = ngx_max(clip_end_pts, scaled_dts);\n\t\t}\n\t\tcur_frame->pts_delay = scaled_pts - scaled_dts + pts_delay;\n\n\t\t// get the duration\n\t\tdts += cur_frame->duration;\n\t\tnext_scaled_dts = rescale_time(dts, cur_timescale, new_timescale);\n\t\tcur_frame->duration = next_scaled_dts - scaled_dts;\n\t\tscaled_dts = next_scaled_dts;\n\t}\n\n\ttrack->total_frames_duration += scaled_dts - clip_start_dts;\n\ttrack->clip_from_frame_offset = rescale_time(track->clip_from_frame_offset, cur_timescale, new_timescale);\n\n\t// media info\n\ttrack->media_info.duration = rescale_time(track->media_info.duration, cur_timescale, new_timescale);\n\ttrack->media_info.full_duration = rescale_time(track->media_info.full_duration, cur_timescale, new_timescale);\n\tif (track->media_info.full_duration == 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_update_track_timescale: full duration is zero following rescale\");\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t}\n\n\tif (track->media_info.media_type == MEDIA_TYPE_VIDEO)\n\t{\n\t\tif (track->media_info.min_frame_duration != 0)\n\t\t{\n\t\t\ttrack->media_info.min_frame_duration =\n\t\t\t\trescale_time(track->media_info.min_frame_duration, cur_timescale, new_timescale);\n\t\t\tif (track->media_info.min_frame_duration == 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_WARN, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_update_track_timescale: min frame duration is zero following rescale\");\n\t\t\t\ttrack->media_info.min_frame_duration = 1;\n\t\t\t}\n\t\t}\n\n\t\ttrack->media_info.u.video.initial_pts_delay =\n\t\t\trescale_time(track->media_info.u.video.initial_pts_delay, cur_timescale, new_timescale);\n\t}\n\n\ttrack->media_info.timescale = new_timescale;\n\ttrack->media_info.frames_timescale = new_timescale;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_update_timescale(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_set_t* media_set = &ctx->submodule_context.media_set;\n\tmedia_track_t* track;\n\tngx_int_t rc;\n\n\tfor (track = media_set->filtered_tracks; track < media_set->filtered_tracks_end; track++)\n\t{\n\t\trc = ngx_http_vod_update_track_timescale(\n\t\t\tctx, \n\t\t\ttrack, \n\t\t\tctx->request->timescale, \n\t\t\tctx->submodule_context.request_params.pts_delay);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn NGX_OK;\n}\n\n////// Metadata request handling\n\nstatic ngx_int_t\nngx_http_vod_handle_metadata_request(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\tresponse_cache_header_t cache_header;\n\tngx_buffer_cache_t* cache;\n\tngx_str_t cache_buffers[3];\n\tngx_str_t content_type;\n\tngx_str_t response = ngx_null_string;\n\tngx_int_t rc;\n\tint cache_type;\n\n\trc = ngx_http_vod_update_timescale(ctx);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tngx_perf_counter_start(ctx->perf_counter_context);\n\t\n\tif(conf->force_sequence_index)\n\t{\n\t\tctx->submodule_context.media_set.has_multi_sequences = TRUE;\n\t}\n\t\n\trc = ctx->request->handle_metadata_request(\n\t\t&ctx->submodule_context,\n\t\t&response,\n\t\t&content_type);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_handle_metadata_request: handle_metadata_request failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_BUILD_MANIFEST);\n\n\tif (ctx->submodule_context.media_set.original_type != MEDIA_SET_LIVE ||\n\t\t(ctx->request->flags & REQUEST_FLAG_TIME_DEPENDENT_ON_LIVE) == 0)\n\t{\n\t\tcache_type = CACHE_TYPE_VOD;\n\t}\n\telse\n\t{\n\t\tcache_type = CACHE_TYPE_LIVE;\n\t}\n\n\tcache = conf->response_cache[cache_type];\n\tif (cache != NULL && response.data != NULL)\n\t{\n\t\tcache_header.content_type_len = content_type.len;\n\t\tcache_header.media_set_type = ctx->submodule_context.media_set.type;\n\t\tcache_buffers[0].data = (u_char*)&cache_header;\n\t\tcache_buffers[0].len = sizeof(cache_header);\n\t\tcache_buffers[1] = content_type;\n\t\tcache_buffers[2] = response;\n\n\t\tif (ngx_buffer_cache_store_gather_perf(ctx->perf_counters, cache, ctx->request_key, cache_buffers, 3))\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_handle_metadata_request: stored in response cache\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_handle_metadata_request: failed to store response in cache\");\n\t\t}\n\t}\n\n\trc = ngx_http_vod_send_header(\n\t\tctx->submodule_context.r, \n\t\tresponse.len, \n\t\t&content_type, \n\t\tctx->submodule_context.media_set.type, \n\t\tctx->request);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\t\n\treturn ngx_http_vod_send_response(ctx->submodule_context.r, &response, NULL);\n}\n\n////// Segment request handling\n\nstatic ngx_int_t\nngx_http_vod_state_machine_open_files(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_clip_source_t* cur_source;\n\tngx_int_t rc;\n\n\tfor (cur_source = ctx->cur_source;\n\t\tcur_source != NULL;\n\t\tcur_source = cur_source->next)\n\t{\n\t\t// open the file if not already opened\n\t\tif (cur_source->reader_context != NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = ngx_http_vod_open_file(ctx, cur_source);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_state_machine_open_files: open_file failed %i\", rc);\n\t\t\t}\n\n\t\t\tctx->cur_source = cur_source;\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tctx->cur_source = NULL;\n\treturn NGX_OK;\n}\n\nstatic void\nngx_http_vod_enable_directio(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_clip_source_t* cur_source;\n\n\tfor (cur_source = ctx->submodule_context.media_set.sources_head;\n\t\tcur_source != NULL;\n\t\tcur_source = cur_source->next)\n\t{\n\t\tif (cur_source->reader->enable_directio != NULL)\n\t\t{\n\t\t\tcur_source->reader->enable_directio(cur_source->reader_context);\n\t\t}\n\t}\n}\n\nstatic vod_status_t\nngx_http_vod_write_segment_header_buffer(void* ctx, u_char* buffer, uint32_t size)\n{\n\tngx_http_vod_write_segment_context_t* context = (ngx_http_vod_write_segment_context_t*)ctx;\n\tngx_chain_t *chain_head;\n\tngx_chain_t *chain;\n\tngx_buf_t *b;\n\n\tif (context->r->header_sent)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, context->r->connection->log, 0,\n\t\t\t\"ngx_http_vod_write_segment_header_buffer: called after the headers were already sent\");\n\t\treturn VOD_UNEXPECTED;\n\t}\n\n\tb = ngx_calloc_buf(context->r->pool);\n\tif (b == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, context->r->connection->log, 0,\n\t\t\t\"ngx_http_vod_write_segment_header_buffer: ngx_calloc_buf failed\");\n\t\treturn VOD_ALLOC_FAILED;\n\t}\n\n\tb->pos = buffer;\n\tb->last = buffer + size;\n\tb->temporary = 1;\n\n\tchain = ngx_alloc_chain_link(context->r->pool);\n\tif (chain == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, context->r->connection->log, 0,\n\t\t\t\"ngx_http_vod_write_segment_header_buffer: ngx_alloc_chain_link failed\");\n\t\treturn VOD_ALLOC_FAILED;\n\t}\n\n\tchain_head = context->chain_head;\n\n\tchain->buf = chain_head->buf;\n\tchain->next = chain_head->next;\n\n\tchain_head->buf = b;\n\tchain_head->next = chain;\n\n\tif (chain_head == context->chain_end)\n\t{\n\t\tcontext->chain_end = chain;\n\t}\n\n\tcontext->total_size += size;\n\n\treturn VOD_OK;\n}\n\nstatic vod_status_t \nngx_http_vod_write_segment_buffer(void* ctx, u_char* buffer, uint32_t size)\n{\n\tngx_http_vod_write_segment_context_t* context;\n\tngx_buf_t *b;\n\tngx_chain_t *chain;\n\tngx_chain_t out;\n\tngx_int_t rc;\n\n\tif (size <= 0)\n\t{\n\t\treturn VOD_OK;\n\t}\n\n\tcontext = (ngx_http_vod_write_segment_context_t*)ctx;\n\t\n\t// create a wrapping ngx_buf_t\n\tb = ngx_calloc_buf(context->r->pool);\n\tif (b == NULL) \n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, context->r->connection->log, 0,\n\t\t\t\"ngx_http_vod_write_segment_buffer: ngx_calloc_buf failed\");\n\t\treturn VOD_ALLOC_FAILED;\n\t}\n\n\tb->pos = buffer;\n\tb->last = buffer + size;\n\tb->temporary = 1;\n\n\tif (context->r->header_sent)\n\t{\n\t\t// headers already sent, output the chunk\n\t\tout.buf = b;\n\t\tout.next = NULL;\n\n\t\trc = ngx_http_output_filter(context->r, &out);\n\t\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t\t{\n\t\t\t// either the connection dropped, or some allocation failed\n\t\t\t// in case the connection dropped, the error code doesn't matter anyway\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, context->r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_write_segment_buffer: ngx_http_output_filter failed %i\", rc);\n\t\t\treturn VOD_ALLOC_FAILED;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// headers not sent yet, add the buffer to the chain\n\t\tif (context->chain_end->buf != NULL)\n\t\t{\n\t\t\tchain = ngx_alloc_chain_link(context->r->pool);\n\t\t\tif (chain == NULL) \n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, context->r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_write_segment_buffer: ngx_alloc_chain_link failed\");\n\t\t\t\treturn VOD_ALLOC_FAILED;\n\t\t\t}\n\n\t\t\tcontext->chain_end->next = chain;\n\t\t\tcontext->chain_end = chain;\n\t\t}\n\t\tcontext->chain_end->buf = b;\n\t}\n\n\tcontext->total_size += size;\n\n\treturn VOD_OK;\n}\n\nstatic ngx_int_t \nngx_http_vod_init_frame_processing(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_request_t* r = ctx->submodule_context.r;\n\tngx_str_t output_buffer = ngx_null_string;\n\tngx_str_t content_type;\n\tngx_int_t rc;\n\toff_t range_start;\n\toff_t range_end;\n\n\trc = ngx_http_vod_update_timescale(ctx);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\t// initialize the response writer\n\tctx->write_segment_buffer_context.r = r;\n\tctx->write_segment_buffer_context.chain_head = &ctx->out;\n\tctx->write_segment_buffer_context.chain_end = &ctx->out;\n\n\tctx->segment_writer.write_tail = ngx_http_vod_write_segment_buffer;\n\tctx->segment_writer.write_head = ngx_http_vod_write_segment_header_buffer;\n\tctx->segment_writer.context = &ctx->write_segment_buffer_context;\n\n\t// initialize the protocol specific frame processor\n\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\trc = ctx->request->init_frame_processor(\n\t\t&ctx->submodule_context,\n\t\t&ctx->segment_writer,\n\t\t&ctx->frame_processor,\n\t\t&ctx->frame_processor_state,\n\t\t&output_buffer,\n\t\t&ctx->content_length,\n\t\t&content_type);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_init_frame_processing: init_frame_processor failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_INIT_FRAME_PROCESS);\n\n\tr->headers_out.content_type_len = content_type.len;\n\tr->headers_out.content_type.len = content_type.len;\n\tr->headers_out.content_type.data = content_type.data;\n\n\t// if the frame processor can't determine the size in advance we have to build the whole response before we can start sending it\n\tif (ctx->content_length != 0)\n\t{\n\t\t// send the response header\n\t\trc = ngx_http_vod_send_header(r, ctx->content_length, NULL, MEDIA_SET_VOD, NULL);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (r->header_only || r->method == NGX_HTTP_HEAD)\n\t\t{\n\t\t\treturn NGX_DONE;\n\t\t}\n\n\t\t// in case of range request, get the end offset\n\t\tif (ctx->submodule_context.r->headers_in.range != NULL &&\n\t\t\tngx_http_vod_range_parse(\n\t\t\t\t&ctx->submodule_context.r->headers_in.range->value,\n\t\t\t\tctx->content_length,\n\t\t\t\t&range_start,\n\t\t\t\t&range_end) == NGX_OK)\n\t\t{\n\t\t\tctx->size_limit = range_end;\n\t\t}\n\t}\n\n\t// write the initial buffer if provided\n\tif (output_buffer.len != 0)\n\t{\n\t\trc = ctx->segment_writer.write_tail(\n\t\t\tctx->segment_writer.context, \n\t\t\toutput_buffer.data, \n\t\t\toutput_buffer.len);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_init_frame_processing: write_tail failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\t// in case of a range request that is fully contained in the output buffer (e.g. 0-0), we're done\n\t\tif (ctx->size_limit != 0 && output_buffer.len >= ctx->size_limit && r->header_sent)\n\t\t{\n\t\t\treturn NGX_DONE;\n\t\t}\n\t}\n\n\trc = read_cache_allocate_buffer_slots(&ctx->read_cache_state, 0);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_init_frame_processing: read_cache_allocate_buffer_slots failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t \nngx_http_vod_process_media_frames(ngx_http_vod_ctx_t *ctx)\n{\n\tread_cache_get_read_buffer_t read_buf;\n\tsize_t cache_buffer_size;\n\tvod_status_t rc;\n\n\tfor (;;)\n\t{\n\t\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t\trc = ctx->frame_processor(ctx->frame_processor_state);\n\n\t\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_PROCESS_FRAMES);\n\n\t\tswitch (rc)\n\t\t{\n\t\tcase VOD_OK:\n\t\t\t// we're done\n\t\t\treturn NGX_OK;\n\n\t\tcase VOD_AGAIN:\n\t\t\t// handled outside the switch\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_process_media_frames: frame_processor failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\tif (ctx->size_limit != 0 && \n\t\t\tctx->write_segment_buffer_context.total_size >= ctx->size_limit && \n\t\t\tctx->submodule_context.r->header_sent)\n\t\t{\n\t\t\treturn NGX_OK;\n\t\t}\n\n\t\t// get a buffer to read into\n\t\tread_cache_get_read_buffer(\n\t\t\t&ctx->read_cache_state,\n\t\t\t&read_buf);\n\n\t\tcache_buffer_size = ctx->submodule_context.conf->cache_buffer_size;\n\n\t\tctx->read_buffer.start = read_buf.buffer;\n\t\tif (read_buf.buffer != NULL)\n\t\t{\n\t\t\tctx->read_buffer.end = read_buf.buffer + cache_buffer_size;\n\t\t}\n\n\t\trc = ngx_http_vod_alloc_read_buffer(ctx, cache_buffer_size + read_buf.source->alloc_extra_size, read_buf.source->alignment);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t\t\n\t\t// perform the read\n\t\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t\trc = read_buf.source->reader->read(\n\t\t\tread_buf.source->reader_context, \n\t\t\t&ctx->read_buffer, \n\t\t\tread_buf.size, \n\t\t\tread_buf.offset);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_process_media_frames: async_read failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_READ_FILE);\n\n\t\t// read completed synchronously, update the read cache\n\t\tread_cache_read_completed(&ctx->read_cache_state, &ctx->read_buffer);\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_finalize_segment_response(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_request_t *r = ctx->submodule_context.r;\n\tngx_int_t rc;\n\n\trc = ctx->segment_writer.write_tail(ctx->segment_writer.context, NULL, 0);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_finalize_segment_response: write_tail failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(r, rc);\n\t}\n\n\t// if we already sent the headers and all the buffers, just signal completion and return\n\tif (r->header_sent)\n\t{\n\t\tif (ctx->write_segment_buffer_context.total_size != ctx->content_length &&\n\t\t\t(ctx->size_limit == 0 || ctx->write_segment_buffer_context.total_size < ctx->size_limit))\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_finalize_segment_response: actual content length %uz is different than reported length %uz\",\n\t\t\t\tctx->write_segment_buffer_context.total_size, ctx->content_length);\n\t\t}\n\n\t\trc = ngx_http_send_special(r, NGX_HTTP_LAST);\n\t\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_finalize_segment_response: ngx_http_send_special failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\treturn NGX_OK;\n\t}\n\n\t// mark the current buffer as last\n\tif (ctx->write_segment_buffer_context.chain_end->buf == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_finalize_segment_response: no buffers were written\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_UNEXPECTED);\n\t}\n\n\tctx->write_segment_buffer_context.chain_end->next = NULL;\n\tctx->write_segment_buffer_context.chain_end->buf->last_buf = 1;\n\n\t// send the response header\n\trc = ngx_http_vod_send_header(r, ctx->write_segment_buffer_context.total_size, NULL, MEDIA_SET_VOD, NULL);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (r->header_only || r->method == NGX_HTTP_HEAD)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\t// send the response buffer chain\n\trc = ngx_http_output_filter(r, &ctx->out);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_finalize_segment_response: ngx_http_output_filter failed %i\", rc);\n\t\treturn rc;\n\t}\n\treturn NGX_OK;\n}\n\n////// Audio filtering\n\nstatic ngx_int_t\nngx_http_vod_init_process(ngx_cycle_t *cycle)\n{\n\tvod_status_t rc;\n\n\taudio_filter_process_init(cycle->log);\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n\taudio_decoder_process_init(cycle->log);\n\taudio_encoder_process_init(cycle->log);\n\tthumb_grabber_process_init(cycle->log);\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n\trc = language_code_process_init(cycle->pool, cycle->log);\n\tif (rc != VOD_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic void \nngx_http_vod_exit_process()\n{\n#if (VOD_HAVE_ICONV)\n\twebvtt_exit_process();\n#endif // VOD_HAVE_ICONV\n\n#if (NGX_HAVE_LIBXML2)\n\tdfxp_exit_process();\n#endif // NGX_HAVE_LIBXML2\n}\n\n////// Clipping\n\nstatic ngx_int_t\nngx_http_vod_send_clip_header(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_request_t* r = ctx->submodule_context.r;\n\tngx_chain_t* out;\n\tuint64_t first_offset;\n\tuint64_t last_offset;\n\tsize_t response_size;\n\tngx_str_t content_type;\n\tngx_int_t rc;\n\toff_t range_start;\n\toff_t range_end;\n\toff_t header_size;\n\toff_t mdat_size;\n\n\trc = ctx->format->clipper_build_header(\n\t\t&ctx->submodule_context.request_context,\n\t\tctx->metadata_parts,\n\t\tctx->metadata_part_count,\n\t\tctx->clipper_parse_result,\n\t\t&out,\n\t\t&response_size, \n\t\t&content_type);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_clip_header: clipper_build_header(%V) failed %i\", &ctx->format->name, rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(r, rc);\n\t}\n\n\t// send the response header\n\trc = ngx_http_vod_send_header(r, response_size, &content_type, MEDIA_SET_VOD, NULL);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (r->header_only || r->method == NGX_HTTP_HEAD)\n\t{\n\t\treturn NGX_DONE;\n\t}\n\n\trc = ngx_http_output_filter(r, out);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_clip_header: ngx_http_output_filter failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tif (ctx->submodule_context.conf->request_handler == ngx_http_vod_remote_request_handler && \n\t\tctx->submodule_context.r->headers_in.range)\n\t{\n\t\t// in case of range request in remote mode, apply the requested range to the mdat dump offsets.\n\t\t// nginx's range filter module does not touch the dumped part since it is written in the context\n\t\t// a subrequest. \n\n\t\t// TODO: apply the range on the mp4 header as well and return 206, to avoid making assumptions on\n\t\t//\t\tnginx subrequest/range filter implementations\n\n\t\trc = ngx_http_vod_range_parse(\n\t\t\t&ctx->submodule_context.r->headers_in.range->value,\n\t\t\tresponse_size,\n\t\t\t&range_start,\n\t\t\t&range_end);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_send_clip_header: failed to parse range header \\\"%V\\\"\",\n\t\t\t\t&ctx->submodule_context.r->headers_in.range->value);\n\t\t\treturn rc;\n\t\t}\n\n\t\tfirst_offset = ctx->clipper_parse_result->first_offset;\n\t\tlast_offset = ctx->clipper_parse_result->last_offset;\n\n\t\tmdat_size = last_offset - first_offset;\n\t\theader_size = response_size - mdat_size;\n\n\t\tif (range_end < header_size)\n\t\t{\n\t\t\tlast_offset = 0;\n\t\t}\n\t\telse if (mdat_size > range_end - header_size)\n\t\t{\n\t\t\tlast_offset = first_offset + range_end - header_size;\n\t\t}\n\n\t\tif (range_start > header_size)\n\t\t{\n\t\t\tfirst_offset += range_start - header_size;\n\t\t}\n\n\t\tctx->clipper_parse_result->first_offset = first_offset;\n\t\tctx->clipper_parse_result->last_offset = last_offset;\n\t}\n\n\treturn NGX_OK;\n}\n\n////// Common\n\nstatic ngx_flag_t\nngx_http_vod_generator_matches(\n\tmedia_parse_params_t* parse_params,\n\tmedia_generator_t* generator)\n{\n\tuint32_t media_type;\n\ttrack_mask_t track_mask_temp;\n\n\tif ((parse_params->codecs_mask & generator->codec_mask) == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tfor (media_type = 0; media_type < MEDIA_TYPE_COUNT; media_type++)\n\t{\n\t\tvod_track_mask_and_bits(track_mask_temp, parse_params->required_tracks_mask[media_type], generator->tracks_mask[media_type]);\n\t\tif (vod_track_mask_is_any_bit_set(track_mask_temp))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ngx_int_t\nngx_http_vod_run_generators(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_clip_source_t* cur_source;\n\tmedia_parse_params_t parse_params;\n\tmedia_generator_t* generator;\n\tmedia_range_t range;\n\ttrack_mask_t tracks_mask[MEDIA_TYPE_COUNT];\n\tngx_int_t rc;\n\n\tfor (cur_source = ctx->submodule_context.media_set.generators_head;\n\t\tcur_source != NULL;\n\t\tcur_source = cur_source->next)\n\t{\n\t\tctx->cur_source = cur_source;\n\n\t\tif (cur_source->clip_to >= UINT_MAX)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_run_generators: unbounded generator source\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tparse_params.clip_to = cur_source->clip_to;\n\t\tparse_params.clip_from = 0;\n\n\t\tngx_http_vod_init_parse_params_metadata(ctx, tracks_mask, &parse_params);\n\n\t\t// Note: currently, the only generator is the silence generator\n\t\tgenerator = &silence_generator;\n\n\t\tif (!ngx_http_vod_generator_matches(\n\t\t\t&parse_params,\n\t\t\tgenerator))\n\t\t{\n\t\t\tngx_memzero(&cur_source->track_array, sizeof(cur_source->track_array));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parse_params.langs_mask != NULL &&\n\t\t\t!vod_is_bit_set(parse_params.langs_mask, cur_source->sequence->tags.language))\n\t\t{\n\t\t\tngx_memzero(&cur_source->track_array, sizeof(cur_source->track_array));\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = ngx_http_vod_init_parse_params_frames(\n\t\t\tctx,\n\t\t\t&range,\n\t\t\t&parse_params);\n\t\tswitch (rc)\n\t\t{\n\t\tcase NGX_OK:\n\t\t\tbreak;\t\t// handled outside the switch\n\n\t\tcase NGX_DONE:\n\t\t\tngx_memzero(&cur_source->track_array, sizeof(cur_source->track_array));\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = generator->generate(\n\t\t\t&ctx->submodule_context.request_context,\n\t\t\t&parse_params,\n\t\t\t&cur_source->track_array);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_run_generators: generator failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t}\n\n\t\tngx_http_vod_update_source_tracks(&ctx->submodule_context.request_context, ctx->cur_source);\n\t}\n\n\tctx->cur_source = NULL;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_run_state_machine(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_int_t rc;\n\tuint32_t max_frame_count;\n\tuint32_t output_codec_id;\n\n\tswitch (ctx->state)\n\t{\n\tcase STATE_READ_DRM_INFO:\n\t\trc = ngx_http_vod_state_machine_get_drm_info(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tctx->state = STATE_READ_METADATA_INITIAL;\n\t\tctx->cur_sequence = ctx->submodule_context.media_set.sequences;\n\t\t// fall through\n\n\tcase STATE_READ_METADATA_INITIAL:\n\tcase STATE_READ_METADATA_OPEN_FILE:\n\tcase STATE_READ_METADATA_READ:\n\tcase STATE_READ_FRAMES_OPEN_FILE:\n\tcase STATE_READ_FRAMES_READ:\n\n\t\trc = ngx_http_vod_state_machine_parse_metadata(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (ctx->request == NULL)\n\t\t{\n\t\t\trc = ngx_http_vod_send_clip_header(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\tif (rc == NGX_DONE)\n\t\t\t\t{\n\t\t\t\t\trc = NGX_OK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_run_state_machine: ngx_http_vod_send_clip_header failed %i\", rc);\n\t\t\t\t}\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trc = ngx_http_vod_run_generators(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\trc = filter_init_filtered_clips(\n\t\t\t\t&ctx->submodule_context.request_context,\n\t\t\t\t&ctx->submodule_context.media_set, \n\t\t\t\t(ctx->request->parse_type & PARSE_FLAG_FRAMES_DURATION) != 0);\n\t\t\tif (rc != VOD_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_run_state_machine: filter_init_filtered_clips failed %i\", rc);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t\t}\n\n\t\t\trc = ngx_http_vod_validate_streams(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\t// handle metadata requests\n\t\t\tif (ctx->request->handle_metadata_request != NULL)\n\t\t\t{\n\t\t\t\treturn ngx_http_vod_handle_metadata_request(ctx);\n\t\t\t}\n\n\t\t\t// initialize the read cache\n\t\t\tread_cache_init(\n\t\t\t\t&ctx->read_cache_state,\n\t\t\t\t&ctx->submodule_context.request_context,\n\t\t\t\tctx->submodule_context.conf->cache_buffer_size);\n\t\t}\n\n\t\tctx->state = STATE_OPEN_FILE;\n\t\tctx->cur_source = ctx->submodule_context.media_set.sources_head;\n\t\t// fall through\n\n\tcase STATE_OPEN_FILE:\n\t\trc = ngx_http_vod_state_machine_open_files(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// enable directio if enabled in the configuration (ignore errors)\n\t\t// Note that directio is set on transfer only to allow the kernel to cache the \"moov\" atom\n\t\tngx_http_vod_enable_directio(ctx);\n\n\t\tif (ctx->request == NULL)\n\t\t{\n\t\t\tif (ctx->clipper_parse_result->first_offset < ctx->clipper_parse_result->last_offset)\n\t\t\t{\n\t\t\t\tctx->cur_source = ctx->submodule_context.media_set.sources_head;\n\n\t\t\t\tctx->state = STATE_DUMP_FILE_PART;\n\n\t\t\t\trc = ctx->cur_source->reader->dump_part(\n\t\t\t\t\tctx->cur_source->reader_context,\n\t\t\t\t\tctx->clipper_parse_result->first_offset,\n\t\t\t\t\tctx->clipper_parse_result->last_offset);\n\t\t\t\tif (rc != NGX_OK)\n\t\t\t\t{\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trc = ngx_http_send_special(ctx->submodule_context.r, NGX_HTTP_LAST);\n\t\t\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_run_state_machine: ngx_http_send_special failed %i\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\treturn NGX_OK;\n\t\t}\n\n\t\tif (ctx->submodule_context.media_set.audio_filtering_needed)\n\t\t{\n\t\t\t// initialize the filtering of audio frames\n\t\t\tctx->state = STATE_FILTER_FRAMES;\n\t\t\tctx->cur_source = ctx->submodule_context.media_set.sources_head;\n\n\t\t\tif ((ctx->request->request_class & (REQUEST_CLASS_MANIFEST | REQUEST_CLASS_OTHER)) != 0)\n\t\t\t{\n\t\t\t\tmax_frame_count = ctx->submodule_context.conf->max_frame_count;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax_frame_count = ctx->submodule_context.conf->segment_max_frame_count;\n\t\t\t}\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n\t\t\tif (ctx->submodule_context.conf->submodule.name == volume_map.name)\n\t\t\t{\n\t\t\t\toutput_codec_id = VOD_CODEC_ID_VOLUME_MAP;\n\t\t\t}\n\t\t\telse\n#endif // NGX_HAVE_LIB_AV_CODEC\n\t\t\t{\n\t\t\t\toutput_codec_id = VOD_CODEC_ID_AAC;\n\t\t\t}\n\n\t\t\trc = filter_init_state(\n\t\t\t\t&ctx->submodule_context.request_context,\n\t\t\t\t&ctx->read_cache_state,\n\t\t\t\t&ctx->submodule_context.media_set,\n\t\t\t\tmax_frame_count,\n\t\t\t\toutput_codec_id,\n\t\t\t\t&ctx->frame_processor_state);\n\t\t\tif (rc != VOD_OK)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_run_state_machine: filter_init_state failed %i\", rc);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t\t\t}\n\n\t\t\tctx->frame_processor = filter_run_state_machine;\n\t\t}\n\n\t\t// fall through\n\n\tcase STATE_FILTER_FRAMES:\n\t\t// if audio filtering already started, process frames\n\t\tif (ctx->frame_processor != NULL)\n\t\t{\n\t\t\trc = ngx_http_vod_process_media_frames(ctx);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\t// initialize the processing of the video/audio frames\n\t\trc = ngx_http_vod_init_frame_processing(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc == NGX_DONE)\n\t\t\t{\n\t\t\t\trc = NGX_OK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_run_state_machine: ngx_http_vod_init_frame_processing failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (ctx->frame_processor_state == NULL)\n\t\t{\n\t\t\treturn ngx_http_vod_finalize_segment_response(ctx);\n\t\t}\n\n\t\tctx->submodule_context.request_context.log->action = \"processing frames\";\n\t\tctx->state = STATE_PROCESS_FRAMES;\n\t\t// fall through\n\n\tcase STATE_PROCESS_FRAMES:\n\t\trc = ngx_http_vod_process_media_frames(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_run_state_machine: ngx_http_vod_process_media_frames failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\treturn ngx_http_vod_finalize_segment_response(ctx);\n\n\tcase STATE_DUMP_OPEN_FILE:\n\t\treturn ctx->cur_source->reader->dump_request(ctx->cur_source->reader_context);\n\n\tcase STATE_DUMP_FILE_PART:\n\t\trc = ngx_http_send_special(ctx->submodule_context.r, NGX_HTTP_LAST);\n\t\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_run_state_machine: ngx_http_send_special failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\treturn NGX_OK;\n\t}\n\n\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\"ngx_http_vod_run_state_machine: invalid state %d\", ctx->state);\n\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n}\n\nstatic void\nngx_http_vod_handle_read_completed(void* context, ngx_int_t rc, ngx_buf_t* buf, ssize_t bytes_read)\n{\n\tngx_http_vod_ctx_t *ctx = (ngx_http_vod_ctx_t *)context;\n\tssize_t expected_size;\n\n\tif (rc != NGX_OK)\n\t{\n\t\tif (rc == NGX_AGAIN)\n\t\t{\n\t\t\tngx_http_finalize_request(ctx->submodule_context.r, rc);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctx->state == STATE_MAP_READ && \n\t\t\tctx->mapping.stale_retries > 0 && \n\t\t\terrno == ESTALE)\n\t\t{\n\t\t\tctx->mapping.stale_retries--;\n\t\t\tctx->state = STATE_MAP_INITIAL;\n\n\t\t\trc = ctx->state_machine(ctx);\n\t\t\tif (rc == NGX_AGAIN)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgoto finalize_request;\n\t\t}\n\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_handle_read_completed: read failed %i\", rc);\n\t\tgoto finalize_request;\n\t}\n\n\tif (ctx->state == STATE_DUMP_FILE_PART)\n\t{\n\t\texpected_size = ctx->clipper_parse_result->last_offset - ctx->clipper_parse_result->first_offset;\n\t\tif (bytes_read != expected_size)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_handle_read_completed: read size %z different than expected %z, probably a truncated file\", \n\t\t\t\tbytes_read, expected_size);\n\t\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t\t\tgoto finalize_request;\n\t\t}\n\t}\n\telse if (bytes_read <= 0)\n\t{\n\t\tswitch (ctx->state)\n\t\t{\n\t\tcase STATE_MAP_READ:\t\t// the mapping state machine handles the case of empty mapping\n\t\t\tbreak;\n\n\t\tcase STATE_READ_METADATA_READ:\n\t\t\tif ((ctx->read_flags & MEDIA_READ_FLAG_ALLOW_EMPTY_READ) != 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// fall through\n\n\t\tdefault:\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_handle_read_completed: bytes read is zero\");\n\t\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_DATA);\n\t\t\tgoto finalize_request;\n\t\t}\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, ctx->perf_counter_async_read);\n\n\tswitch (ctx->state)\n\t{\n\tcase STATE_FILTER_FRAMES:\n\tcase STATE_PROCESS_FRAMES:\n\t\tif (buf == NULL)\n\t\t{\n\t\t\tbuf = &ctx->read_buffer;\n\t\t}\n\t\tctx->frames_bytes_read += (buf->last - buf->pos);\n\t\tread_cache_read_completed(&ctx->read_cache_state, buf);\n\t\tbreak;\n\n\tdefault:\n\t\tif (buf != NULL)\n\t\t{\n\t\t\tctx->read_buffer = *buf;\n\t\t}\n\t\tbreak;\n\t}\n\n\t// run the state machine\n\trc = ctx->state_machine(ctx);\n\tif (rc == NGX_AGAIN)\n\t{\n\t\treturn;\n\t}\n\nfinalize_request:\n\n\tngx_http_vod_finalize_request(ctx, rc);\n}\n\nstatic void\nngx_http_vod_init_file_key(media_clip_source_t* cur_source, ngx_str_t* prefix)\n{\n\tngx_md5_t md5;\n\n\tngx_md5_init(&md5);\n\tif (prefix != NULL)\n\t{\n\t\tngx_md5_update(&md5, prefix->data, prefix->len);\n\t}\n\tngx_md5_update(&md5, cur_source->mapped_uri.data, cur_source->mapped_uri.len);\n\tngx_md5_final(cur_source->file_key, &md5);\n}\n\nstatic ngx_int_t\nngx_http_vod_init_encryption_key(\n\tngx_http_request_t *r, \n\tngx_http_vod_loc_conf_t* conf, \n\tmedia_sequence_t* cur_sequence)\n{\n\tngx_str_t encryption_key_seed;\n\tngx_md5_t md5;\n\n\tif (conf->secret_key != NULL)\n\t{\n\t\t// calculate the encryption key seed\n\t\tif (ngx_http_complex_value(\n\t\t\tr,\n\t\t\tconf->secret_key,\n\t\t\t&encryption_key_seed) != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_init_encryption_key: ngx_http_complex_value failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\t}\n\telse\n\t{\n\t\tencryption_key_seed = cur_sequence->mapped_uri;\n\t}\n\n\t// hash the seed to get the key\n\tngx_md5_init(&md5);\n\tngx_md5_update(&md5, encryption_key_seed.data, encryption_key_seed.len);\n\tngx_md5_final(cur_sequence->encryption_key, &md5);\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_start_processing_media_file(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf;\n\tmedia_clip_source_t* cur_source;\n\tngx_http_request_t *r;\n\tngx_int_t rc;\n\n\t// update request flags\n\tr = ctx->submodule_context.r;\n\tr->root_tested = !r->error_page;\n\tr->allow_ranges = 1;\n\n\t// set the state machine\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tctx->state_machine = ngx_http_vod_run_state_machine;\n\n\tcur_source = ctx->submodule_context.media_set.sources_head;\n\n\t// handle serve requests\n\tif (ctx->request == NULL &&\n\t\tcur_source->clip_from == 0 &&\n\t\tcur_source->clip_to == ULLONG_MAX &&\n\t\tvod_track_mask_are_all_bits_set(cur_source->tracks_mask[MEDIA_TYPE_AUDIO]) &&\n\t\tvod_track_mask_are_all_bits_set(cur_source->tracks_mask[MEDIA_TYPE_VIDEO]))\n\t{\n\t\tctx->state = STATE_DUMP_OPEN_FILE;\n\n\t\tctx->cur_source = cur_source;\n\n\t\trc = ngx_http_vod_open_file(ctx, cur_source);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_start_processing_media_file: open_file failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\treturn cur_source->reader->dump_request(cur_source->reader_context);\n\t}\n\n\t// initialize the file keys\n\tconf = ctx->submodule_context.conf;\n\n\tfor (; cur_source != NULL; cur_source = cur_source->next)\n\t{\n\t\tngx_http_vod_init_file_key(cur_source, ctx->file_key_prefix);\n\t}\n\n\t// initialize the uri / encryption keys\n\tif (conf->drm_enabled || conf->secret_key != NULL)\n\t{\n\t\tfor (ctx->cur_sequence = ctx->submodule_context.media_set.sequences;\n\t\t\tctx->cur_sequence < ctx->submodule_context.media_set.sequences_end;\n\t\t\tctx->cur_sequence++)\n\t\t{\n\t\t\trc = ngx_http_vod_init_encryption_key(r, conf, ctx->cur_sequence);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\t// restart the file index/uri params\n\tctx->cur_source = ctx->submodule_context.media_set.sources_head;\n\n\tif (ctx->submodule_context.conf->drm_enabled)\n\t{\n\t\tctx->state = STATE_READ_DRM_INFO;\n\t\tctx->cur_sequence = ctx->submodule_context.media_set.sequences;\n\t}\n\telse\n\t{\n\t\tctx->state = STATE_READ_METADATA_INITIAL;\n\t}\n\n\treturn ngx_http_vod_run_state_machine(ctx);\n}\n\n////// Local & mapped modes\n\nstatic ngx_int_t\nngx_http_vod_map_uris_to_paths(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_clip_source_t* cur_source;\n\tngx_http_request_t *r = ctx->submodule_context.r;\n\tngx_str_t original_uri;\n\tu_char *last;\n\tsize_t root;\n\tngx_str_t path;\n\n\toriginal_uri = r->uri;\n\tfor (cur_source = ctx->submodule_context.media_set.sources_head;\n\t\tcur_source != NULL;\n\t\tcur_source = cur_source->next)\n\t{\n\t\tctx->cur_source = cur_source;\n\t\tr->uri = cur_source->stripped_uri;\n\t\tlast = ngx_http_map_uri_to_path(r, &path, &root, 0);\n\t\tr->uri = original_uri;\n\t\tif (last == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_map_uris_to_paths: ngx_http_map_uri_to_path failed\");\n\t\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t\tpath.len = last - path.data;\n\n\t\tcur_source->mapped_uri = path;\n\t}\n\n\tctx->cur_source = ctx->submodule_context.media_set.sources_head;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_dump_request_to_fallback(ngx_http_request_t *r)\n{\n\tngx_http_vod_loc_conf_t* conf;\n\tngx_child_request_params_t child_params;\n\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\n\tif (conf->fallback_upstream_location.len == 0)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_dump_request_to_fallback: no fallback configured\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tif (ngx_http_vod_header_exists(r, &conf->proxy_header.key))\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_dump_request_to_fallback: proxy header exists\");\n\t\treturn NGX_ERROR;\n\t}\n\n\t// dump the request to the fallback upstream\n\tngx_memzero(&child_params, sizeof(child_params));\n\tchild_params.method = r->method;\n\tchild_params.base_uri = r->uri;\n\tchild_params.extra_args = r->args;\n\tchild_params.extra_header = conf->proxy_header;\n\tchild_params.proxy_range = 1;\n\tchild_params.proxy_all_headers = 1;\n\n\treturn ngx_child_request_start(\n\t\tr,\n\t\tNULL,\n\t\tNULL,\n\t\t&conf->fallback_upstream_location,\n\t\t&child_params,\n\t\tNULL);\n}\n\n#if (NGX_THREADS)\nstatic void\nngx_http_vod_file_open_completed_internal(void* context, ngx_int_t rc, ngx_flag_t fallback)\n{\n\tngx_http_vod_ctx_t *ctx = (ngx_http_vod_ctx_t *)context;\n\n\tif (rc != NGX_OK)\n\t{\n\t\tif (fallback && rc == NGX_HTTP_NOT_FOUND)\n\t\t{\n\t\t\t// try the fallback\n\t\t\trc = ngx_http_vod_dump_request_to_fallback(ctx->submodule_context.r);\n\t\t\tif (rc == NGX_AGAIN)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trc = NGX_HTTP_NOT_FOUND;\n\t\t\tgoto finalize_request;\n\t\t}\n\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.r->connection->log, 0,\n\t\t\t\"ngx_http_vod_file_open_completed_internal: read failed %i\", rc);\n\t\tgoto finalize_request;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_ASYNC_OPEN_FILE);\n\n\t// run the state machine\n\trc = ctx->state_machine(ctx);\n\tif (rc == NGX_AGAIN)\n\t{\n\t\treturn;\n\t}\n\nfinalize_request:\n\n\tngx_http_vod_finalize_request(ctx, rc);\n}\n\nstatic void\nngx_http_vod_file_open_completed(void* context, ngx_int_t rc)\n{\n\tngx_http_vod_file_open_completed_internal(context, rc, 0);\n}\n\nstatic void\nngx_http_vod_file_open_completed_with_fallback(void* context, ngx_int_t rc)\n{\n\tngx_http_vod_file_open_completed_internal(context, rc, 1);\n}\n#endif // NGX_THREADS\n\nstatic ngx_int_t\nngx_http_vod_init_file_reader_internal(ngx_http_request_t *r, ngx_str_t* path, void** context, uint32_t flags)\n{\n\tngx_file_reader_state_t* state;\n\tngx_http_core_loc_conf_t *clcf;\n\tngx_http_vod_ctx_t *ctx;\n\tngx_flag_t fallback = (flags & OPEN_FILE_FALLBACK_ENABLED) != 0;\n\tngx_int_t rc;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\tclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n\tstate = ngx_pcalloc(r->pool, sizeof(*state));\n\tif (state == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_init_file_reader_internal: ngx_pcalloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\n\t*context = state;\n\n\tngx_perf_counter_start(ctx->perf_counter_context);\n\n#if (NGX_THREADS)\n\tif (ctx->submodule_context.conf->open_file_thread_pool != NULL)\n\t{\n\t\trc = ngx_file_reader_init_async(\n\t\t\tstate,\n\t\t\t&ctx->async_open_context,\n\t\t\tctx->submodule_context.conf->open_file_thread_pool,\n\t\t\tfallback ? ngx_http_vod_file_open_completed_with_fallback : ngx_http_vod_file_open_completed,\n\t\t\tngx_http_vod_handle_read_completed,\n\t\t\tctx,\n\t\t\tr,\n\t\t\tclcf,\n\t\t\tpath,\n\t\t\tflags);\n\t}\n\telse\n#endif // NGX_THREADS\n\t{\n\t\trc = ngx_file_reader_init(\n\t\t\tstate,\n\t\t\tngx_http_vod_handle_read_completed,\n\t\t\tctx,\n\t\t\tr,\n\t\t\tclcf,\n\t\t\tpath,\n\t\t\tflags);\n\t}\n\tif (rc != NGX_OK)\n\t{\n\t\tif (fallback && rc == NGX_HTTP_NOT_FOUND)\n\t\t{\n\t\t\t// try the fallback\n\t\t\trc = ngx_http_vod_dump_request_to_fallback(r);\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\treturn NGX_HTTP_NOT_FOUND;\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (rc != NGX_AGAIN)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_init_file_reader_internal: ngx_file_reader_init failed %i\", rc);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_OPEN_FILE);\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_init_file_reader(ngx_http_request_t *r, ngx_str_t* path, uint32_t flags, void** context)\n{\n\treturn ngx_http_vod_init_file_reader_internal(r, path, context, flags);\n}\n\nstatic ngx_int_t\nngx_http_vod_init_file_reader_with_fallback(ngx_http_request_t *r, ngx_str_t* path, uint32_t flags, void** context)\n{\n\treturn ngx_http_vod_init_file_reader_internal(r, path, context, flags | OPEN_FILE_FALLBACK_ENABLED);\n}\n\n// Note: this function initializes r->exten in order to have nginx select the correct mime type for the request\n//\t\tthe code was copied from nginx's ngx_http_set_exten\nstatic void\nngx_http_vod_set_request_extension(ngx_http_request_t *r, ngx_str_t* path)\n{\n\tngx_int_t  i;\n\n\tngx_str_null(&r->exten);\n\n\tfor (i = path->len - 1; i > 1; i--) {\n\t\tif (path->data[i] == '.' && path->data[i - 1] != '/') {\n\n\t\t\tr->exten.len = path->len - i - 1;\n\t\t\tr->exten.data = &path->data[i + 1];\n\n\t\t\treturn;\n\n\t\t}\n\t\telse if (path->data[i] == '/') {\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic ngx_int_t\nngx_http_vod_dump_file(void* context)\n{\n\tngx_file_reader_state_t* state = context;\n\tngx_http_request_t* r = state->r;\n\tngx_int_t rc;\n\n\tngx_http_vod_set_request_extension(r, &state->file.name);\n\n\trc = ngx_http_set_content_type(r);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, state->log, 0,\n\t\t\t\"ngx_http_vod_dump_file: ngx_http_set_content_type failed %i\", rc);\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t// send the response header\n\trc = ngx_http_vod_send_header(r, state->file_size, NULL, MEDIA_SET_VOD, NULL);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (r->header_only || r->method == NGX_HTTP_HEAD)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\tngx_file_reader_enable_directio(state);\t\t// ignore errors\n\n\treturn ngx_file_reader_dump_file_part(state, 0, 0);\n}\n\n////// Remote & mapped modes\n\nstatic ngx_int_t\nngx_http_vod_async_http_read(ngx_http_vod_http_reader_state_t *state, ngx_buf_t *buf, size_t size, off_t offset)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_child_request_params_t child_params;\n\n\tctx = ngx_http_get_module_ctx(state->r, ngx_http_vod_module);\n\n\tngx_memzero(&child_params, sizeof(child_params));\n\tchild_params.method = NGX_HTTP_GET;\n\tchild_params.base_uri = state->cur_remote_suburi;\n\tchild_params.extra_args = ctx->upstream_extra_args;\n\tchild_params.range_start = offset;\n\tchild_params.range_end = offset + size;\n\n\treturn ngx_child_request_start(\n\t\tstate->r,\n\t\tngx_http_vod_handle_read_completed,\n\t\tctx,\n\t\t&state->upstream_location,\n\t\t&child_params,\n\t\tbuf);\n}\n\nstatic ngx_int_t\nngx_http_vod_dump_http_part(void* context, off_t start, off_t end)\n{\n\tngx_http_vod_http_reader_state_t *state = context;\n\tngx_child_request_params_t child_params;\n\tngx_http_request_t* r = state->r;\n\tngx_http_vod_ctx_t *ctx;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\tngx_memzero(&child_params, sizeof(child_params));\n\tchild_params.method = NGX_HTTP_GET;\n\tchild_params.base_uri = state->cur_remote_suburi;\n\tchild_params.extra_args = ctx->upstream_extra_args;\n\tchild_params.range_start = start;\n\tchild_params.range_end = end;\n\n\treturn ngx_child_request_start(\n\t\tr,\n\t\tngx_http_vod_handle_read_completed,\n\t\tctx,\n\t\t&state->upstream_location,\n\t\t&child_params,\n\t\tNULL);\n}\n\nstatic ngx_int_t\nngx_http_vod_dump_http_request(void* context)\n{\n\tngx_http_vod_http_reader_state_t* state = context;\n\tngx_child_request_params_t child_params;\n\tngx_http_request_t* r = state->r;\n\tngx_http_vod_ctx_t *ctx;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\tngx_memzero(&child_params, sizeof(child_params));\n\tchild_params.method = r->method;\n\tchild_params.base_uri = state->cur_remote_suburi;\n\tchild_params.extra_args = ctx->upstream_extra_args;\n\tchild_params.proxy_range = 1;\n\tchild_params.proxy_all_headers = 1;\n\n\treturn ngx_child_request_start(\n\t\tr,\n\t\tNULL,\n\t\tNULL,\n\t\t&state->upstream_location,\n\t\t&child_params,\n\t\tNULL);\n}\n\nstatic ngx_int_t\nngx_http_vod_http_reader_open_file(ngx_http_request_t* r, ngx_str_t* path, uint32_t flags, void** context)\n{\n\tngx_http_vod_http_reader_state_t* state;\n\tngx_http_vod_ctx_t *ctx;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\t// initialize the upstream variables\n\tif (ctx->upstream_extra_args.len == 0 &&\n\t\tctx->submodule_context.conf->upstream_extra_args != NULL)\n\t{\n\t\tif (ngx_http_complex_value(\n\t\t\tctx->submodule_context.r,\n\t\t\tctx->submodule_context.conf->upstream_extra_args,\n\t\t\t&ctx->upstream_extra_args) != NGX_OK)\n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\t}\n\n\tstate = ngx_palloc(r->pool, sizeof(*state));\n\tif (state == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_http_reader_open_file: ngx_palloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\n\t// Note: for http, no need to open any files, just save the remote uri\n\tstate->r = r;\n\tstate->cur_remote_suburi = *path;\n\tif (ctx->state == STATE_MAP_OPEN || ctx->submodule_context.conf->remote_upstream_location.len == 0)\n\t{\n\t\tstate->upstream_location = ctx->submodule_context.conf->upstream_location;\n\t}\n\telse\n\t{\n\t\tstate->upstream_location = ctx->submodule_context.conf->remote_upstream_location;\n\t}\n\t*context = state;\n\n\treturn NGX_OK;\n}\n\nstatic void\t\nngx_http_vod_http_reader_get_path(void* context, ngx_str_t* path)\n{\n\tngx_http_vod_http_reader_state_t* ctx = context;\n\n\t*path = ctx->cur_remote_suburi;\n}\n\n////// Local mode only\n\nngx_int_t\nngx_http_vod_local_request_handler(ngx_http_request_t *r)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_int_t rc;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\t// map all uris to paths\n\trc = ngx_http_vod_map_uris_to_paths(ctx);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\t// initialize for reading files\n\tctx->default_reader = &reader_file_with_fallback;\n\tctx->perf_counter_async_read = PC_ASYNC_READ_FILE;\n\n\t// start the state machine\n\trc = ngx_http_vod_start_processing_media_file(ctx);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_local_request_handler: ngx_http_vod_start_processing_media_file failed %i\", rc);\n\t}\n\n\treturn rc;\n}\n\n////// Mapped mode only\n\nstatic ngx_int_t\nngx_http_vod_map_run_step(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_buffer_cache_t* cache;\n\tngx_buf_t* response;\n\tngx_str_t* prefix;\n\tngx_str_t mapping;\n\tngx_str_t uri;\n\tngx_md5_t md5;\n\tngx_int_t rc;\n\tsize_t read_size;\n\tint store_cache_index;\n\tint fetch_cache_index;\n\tuint32_t cache_token;\n\tsize_t alloc_extra_size;\n\toff_t alignment;\n\n\tswitch (ctx->state)\n\t{\n\tcase STATE_MAP_INITIAL:\n\t\t// get the uri\n\t\trc = ctx->mapping.get_uri(ctx, &uri);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// calculate the cache key\n\t\tprefix = ctx->mapping.cache_key_prefix;\n\t\tngx_md5_init(&md5);\n\t\tif (prefix != NULL)\n\t\t{\n\t\t\tngx_md5_update(&md5, prefix->data, prefix->len);\n\t\t}\n\t\tngx_md5_update(&md5, uri.data, uri.len);\n\t\tngx_md5_final(ctx->mapping.cache_key, &md5);\n\n\t\t// try getting the mapping from cache\n\t\tfetch_cache_index = ngx_buffer_cache_fetch_multi_perf(\n\t\t\tctx->perf_counters,\n\t\t\tctx->mapping.caches,\n\t\t\tctx->mapping.cache_count,\n\t\t\tctx->mapping.cache_key,\n\t\t\t&mapping,\n\t\t\t&cache_token);\n\t\tif (fetch_cache_index >= 0)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_run_step: mapping cache hit %V\", &mapping);\n\n\t\t\trc = ctx->mapping.apply(ctx, &mapping, &store_cache_index);\n\n\t\t\tngx_buffer_cache_release(\n\t\t\t\tctx->mapping.caches[fetch_cache_index], \n\t\t\t\tctx->mapping.cache_key, \n\t\t\t\tcache_token);\n\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_run_step: mapping cache miss\");\n\t\t}\n\n\t\t// open the mapping file\n\t\tctx->submodule_context.request_context.log->action = \"getting mapping\";\n\n\t\tctx->state = STATE_MAP_OPEN;\n\n\t\trc = ctx->mapping.reader->open(ctx->submodule_context.r, &uri, OPEN_FILE_NO_CACHE, &ctx->mapping.reader_context);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: open_file failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t// fall through\n\n\tcase STATE_MAP_OPEN:\n\n\t\tif (ctx->mapping.reader->get_size != NULL)\n\t\t{\n\t\t\tread_size = ctx->mapping.reader->get_size(ctx->mapping.reader_context);\n\t\t\tif (read_size <= 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: empty mapping response\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_EMPTY_MAPPING);\n\t\t\t}\n\t\t\telse if (read_size > ctx->mapping.max_response_size)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: mapping size %uz greater than limit %uz\", \n\t\t\t\t\tread_size, ctx->mapping.max_response_size);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_MAPPING);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_size = ctx->mapping.max_response_size;\n\t\t}\n\n\t\tngx_http_vod_get_alloc_params(ctx, ctx->mapping.reader, &alignment, &alloc_extra_size);\n\n\t\trc = ngx_http_vod_alloc_read_buffer(ctx, read_size + alloc_extra_size, alignment);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// read the mapping\n\t\tctx->state = STATE_MAP_READ;\n\t\tngx_perf_counter_start(ctx->perf_counter_context);\n\n\t\trc = ctx->mapping.reader->read(ctx->mapping.reader_context, &ctx->read_buffer, read_size, 0);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: async_read failed %i\", rc);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\tngx_perf_counter_end(ctx->perf_counters, ctx->perf_counter_context, PC_MAP_PATH);\n\n\t\t// fall through\n\n\tcase STATE_MAP_READ:\n\n\t\tresponse = &ctx->read_buffer;\n\n\t\tif (response->last == response->pos)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_run_step: empty mapping response\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_EMPTY_MAPPING);\n\t\t}\n\n\t\t// apply the mapping\n\t\tif (response->last >= response->end)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_run_step: not enough room in buffer for null terminator\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_MAPPING);\n\t\t}\n\n\t\t*response->last = '\\0';\n\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_run_step: mapping result %s\", response->pos);\n\n\t\tmapping.data = response->pos;\n\t\tmapping.len = response->last - response->pos;\n\t\trc = ctx->mapping.apply(ctx, &mapping, &store_cache_index);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// save to cache\n\t\tif (store_cache_index >= 0)\n\t\t{\n\t\t\tcache = ctx->mapping.caches[store_cache_index];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcache = NULL;\n\t\t}\n\n\t\tif (cache != NULL)\n\t\t{\n\t\t\tif (ngx_buffer_cache_store_perf(\n\t\t\t\tctx->perf_counters,\n\t\t\t\tcache,\n\t\t\t\tctx->mapping.cache_key,\n\t\t\t\tresponse->pos,\n\t\t\t\tresponse->last - response->pos))\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: stored in mapping cache\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_run_step: failed to store mapping in cache\");\n\t\t\t}\n\t\t}\n\n\t\tctx->state = STATE_MAP_INITIAL;\n\t\tbreak;\n\n\tdefault:\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_run_step: invalid state %d\", ctx->state);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_UNEXPECTED);\n\t}\n\n\treturn NGX_OK;\n}\n\n/// map source clip\n\nstatic ngx_int_t\nngx_http_vod_map_source_clip_done(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf;\n\tconf = ctx->submodule_context.conf;\n\n\tif (conf->remote_upstream_location.len == 0)\n\t{\n\t\t// initialize for reading files\n\t\tctx->default_reader = &reader_file;\n\t}\n\telse\n\t{\n\t\t// initialize for http read\n\t\tctx->default_reader = &reader_http;\n\t}\n\tctx->perf_counter_async_read = PC_ASYNC_READ_FILE;\n\t// run the main state machine\n\treturn ngx_http_vod_start_processing_media_file(ctx);\n}\n\nstatic ngx_int_t\nngx_http_vod_map_source_clip_get_uri(ngx_http_vod_ctx_t *ctx, ngx_str_t* uri)\n{\n\tif (ngx_http_complex_value(\n\t\tctx->submodule_context.r,\n\t\tctx->submodule_context.conf->source_clip_map_uri,\n\t\turi) != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_source_clip_get_uri: ngx_http_complex_value failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_map_source_clip_apply(ngx_http_vod_ctx_t *ctx, ngx_str_t* mapping, int* cache_index)\n{\n\tmedia_clip_source_t* cur_clip = vod_container_of(ctx->cur_clip, media_clip_source_t, base);\n\tvod_status_t rc;\n\n\trc = media_set_map_source(&ctx->submodule_context.request_context, mapping->data, cur_clip);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_source_clip_apply: media_set_map_source failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\t*cache_index = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_map_source_clip_state_machine(ngx_http_vod_ctx_t *ctx)\n{\n\tmedia_clip_source_t* cur_clip;\n\tngx_int_t rc;\n\n\t// map the uris\n\tfor (;;)\n\t{\n\t\trc = ngx_http_vod_map_run_step(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tcur_clip = (media_clip_source_t*)ctx->cur_clip;\n\t\tif (cur_clip->next == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->cur_clip = &cur_clip->next->base;\n\t}\n\n\t// merge the mapped sources list with the sources list\n\tcur_clip->next = ctx->submodule_context.media_set.sources_head;\n\tctx->submodule_context.media_set.sources_head = ctx->submodule_context.media_set.mapped_sources_head;\n\tctx->cur_clip = NULL;\n\n\treturn ngx_http_vod_map_source_clip_done(ctx);\n}\n\nstatic ngx_int_t\nngx_http_vod_map_source_clip_start(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\n\tif (conf->source_clip_map_uri == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_source_clip_start: media set contains mapped source clips and \\\"vod_source_clip_map_uri\\\" was not configured\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tctx->mapping.caches = conf->mapping_cache;\n\tctx->mapping.cache_count = 1;\n\tctx->mapping.get_uri = ngx_http_vod_map_source_clip_get_uri;\n\tctx->mapping.apply = ngx_http_vod_map_source_clip_apply;\n\n\tctx->cur_clip = &ctx->submodule_context.media_set.mapped_sources_head->base;\n\tctx->state_machine = ngx_http_vod_map_source_clip_state_machine;\n\n\treturn ngx_http_vod_map_source_clip_state_machine(ctx);\n}\n\n/// send notifications\n\nstatic void\nngx_http_vod_notification_finished(void* context, ngx_int_t rc, ngx_buf_t* buf, ssize_t bytes_read)\n{\n\tngx_http_vod_ctx_t *ctx = context;\n\n\t// ignore errors\n\n\trc = ngx_http_vod_send_notification(ctx);\n\tif (rc != NGX_AGAIN)\n\t{\n\t\tngx_http_vod_finalize_request(ctx, rc);\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_send_notification(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_child_request_params_t child_params;\n\tngx_http_vod_loc_conf_t *conf;\n\tmedia_notification_t* notification;\n\tngx_int_t rc;\n\n\tnotification = ctx->submodule_context.media_set.notifications_head;\n\tif (notification == NULL)\n\t{\n\t\t// sent all notifications, redirect the segment request\n\t\treturn ngx_http_send_response(\n\t\t\tctx->submodule_context.r,\n\t\t\tNGX_HTTP_MOVED_TEMPORARILY,\n\t\t\tNULL,\n\t\t\tctx->submodule_context.conf->redirect_segments_url);\n\t}\n\n\t// remove the notification from list\n\tctx->submodule_context.media_set.notifications_head = notification->next;\n\n\t// get the notification uri\n\tconf = ctx->submodule_context.conf;\n\tif (conf->notification_uri == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_send_notification: no notification uri was configured\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tngx_memzero(&child_params, sizeof(child_params));\n\tctx->notification = notification;\n\n\tif (ngx_http_complex_value(\n\t\tctx->submodule_context.r,\n\t\tconf->notification_uri,\n\t\t&child_params.base_uri) != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_send_notification: ngx_http_complex_value failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\tctx->notification = NULL;\n\n\t// send the notification\n\trc = ngx_http_vod_alloc_read_buffer(ctx, conf->max_upstream_headers_size + 1, 1);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tchild_params.method = NGX_HTTP_GET;\n\tchild_params.extra_args = ctx->upstream_extra_args;\n\tchild_params.range_start = 0;\n\tchild_params.range_end = 1;\n\n\treturn ngx_child_request_start(\n\t\tctx->submodule_context.r,\n\t\tngx_http_vod_notification_finished,\n\t\tctx,\n\t\t&conf->upstream_location,\n\t\t&child_params,\n\t\t&ctx->read_buffer);\n}\n\n/// map dynamic clip\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_done(ngx_http_vod_ctx_t *ctx)\n{\n\t// if it's a segment request and redirect segment urls is set, send notifications\n\tif (ctx->submodule_context.conf->redirect_segments_url != NULL &&\n\t\tctx->request->request_class != REQUEST_CLASS_MANIFEST)\n\t{\n\t\treturn ngx_http_vod_send_notification(ctx);\n\t}\n\n\t// map source clips\n\tif (ctx->submodule_context.media_set.mapped_sources_head != NULL)\n\t{\n\t\treturn ngx_http_vod_map_source_clip_start(ctx);\n\t}\n\n\treturn ngx_http_vod_map_source_clip_done(ctx);\n}\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_get_uri(ngx_http_vod_ctx_t *ctx, ngx_str_t* uri)\n{\n\tif (ngx_http_complex_value(\n\t\tctx->submodule_context.r,\n\t\tctx->submodule_context.conf->dynamic_clip_map_uri,\n\t\turi) != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_dynamic_clip_get_uri: ngx_http_complex_value failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_apply(ngx_http_vod_ctx_t *ctx, ngx_str_t* mapping, int* cache_index)\n{\n\tvod_status_t rc;\n\t\n\trc = dynamic_clip_apply_mapping_json(\n\t\tvod_container_of(ctx->cur_clip, media_clip_dynamic_t, base),\n\t\t&ctx->submodule_context.request_context,\n\t\tmapping->data,\n\t\t&ctx->submodule_context.media_set);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_dynamic_clip_apply: dynamic_clip_apply_mapping_json failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\t*cache_index = 0;\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_state_machine(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_int_t rc;\n\n\t// map the uris\n\twhile (ctx->cur_clip != NULL)\n\t{\n\t\trc = ngx_http_vod_map_run_step(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tctx->cur_clip = &((media_clip_dynamic_t*)ctx->cur_clip)->next->base;\n\t}\n\n\treturn ngx_http_vod_map_dynamic_clip_done(ctx);\n}\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_start(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\n\t// map the dynamic clips by calling the upstream\n\tif (conf->dynamic_clip_map_uri == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_dynamic_clip_start: media set contains dynamic clips and \\\"vod_dynamic_clip_map_uri\\\" was not configured\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tctx->mapping.caches = &conf->dynamic_mapping_cache;\n\tctx->mapping.cache_count = 1;\n\tctx->mapping.get_uri = ngx_http_vod_map_dynamic_clip_get_uri;\n\tctx->mapping.apply = ngx_http_vod_map_dynamic_clip_apply;\n\n\tctx->cur_clip = &ctx->submodule_context.media_set.dynamic_clips_head->base;\n\tctx->state_machine = ngx_http_vod_map_dynamic_clip_state_machine;\n\n\treturn ngx_http_vod_map_dynamic_clip_state_machine(ctx);\n\n}\n\nstatic ngx_int_t\nngx_http_vod_map_dynamic_clip_apply_from_string(ngx_http_vod_ctx_t *ctx)\n{\n\tvod_status_t rc;\n\tngx_str_t mapping;\n\n\tif (ngx_http_complex_value(\n\t\tctx->submodule_context.r,\n\t\tctx->submodule_context.conf->apply_dynamic_mapping,\n\t\t&mapping) != NGX_OK)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_dynamic_clip_apply_from_string: ngx_http_complex_value failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\trc = dynamic_clip_apply_mapping_string(\n\t\t&ctx->submodule_context.request_context,\n\t\t&ctx->submodule_context.media_set,\n\t\t&mapping);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_dynamic_clip_apply_from_string: dynamic_clip_apply_mapping_string failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\treturn NGX_OK;\n}\n\n/// map media set\n\nstatic ngx_int_t\nngx_http_vod_map_media_set_get_uri(ngx_http_vod_ctx_t *ctx, ngx_str_t* uri)\n{\n\tif (ctx->submodule_context.conf->media_set_map_uri != NULL)\n\t{\n\t\tif (ngx_http_complex_value(\n\t\t\tctx->submodule_context.r,\n\t\t\tctx->submodule_context.conf->media_set_map_uri,\n\t\t\turi) != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_media_set_get_uri: ngx_http_complex_value failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\t}\n\telse\n\t{\n\t\t*uri = ctx->cur_source->mapped_uri;\n\t}\n\n\treturn NGX_OK;\n}\n\n#if (NGX_HAVE_LIB_AV_CODEC)\nstatic ngx_int_t\nngx_http_vod_handle_thumb_redirect(\n\tngx_http_vod_ctx_t *ctx, \n\tmedia_set_t* media_set)\n{\n\tngx_http_request_t* r = ctx->submodule_context.r;\n\tngx_table_elt_t* location;\n\tngx_str_t url;\n\tngx_int_t rc;\n\n\trc = ngx_http_vod_thumb_get_url(\n\t\t&ctx->submodule_context,\n\t\tmedia_set->has_multi_sequences ? (uint32_t)(1 << media_set->sequences[0].index) : 0xffffffff,\n\t\t&url);\n\tif (rc != NGX_OK)\n\t{\n\t\treturn rc;\n\t}\n\n\tif (ngx_http_discard_request_body(r) != NGX_OK)\n\t{\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tr->headers_out.status = NGX_HTTP_MOVED_TEMPORARILY;\n\n\tlocation = ngx_list_push(&r->headers_out.headers);\n\tif (location == NULL)\n\t{\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tlocation->hash = 1;\n#if (nginx_version >= 1023000)\n\tlocation->next = NULL;\n#endif\n\tngx_str_set(&location->key, \"Location\");\n\tlocation->value = url;\n\n\tngx_http_clear_location(r);\n\n\tr->headers_out.location = location;\n\n\treturn r->headers_out.status;\n}\n#endif // NGX_HAVE_LIB_AV_CODEC\n\nstatic ngx_int_t\nngx_http_vod_map_media_set_apply(ngx_http_vod_ctx_t *ctx, ngx_str_t* mapping, int* cache_index)\n{\n\tngx_http_vod_loc_conf_t* conf = ctx->submodule_context.conf;\n\tngx_perf_counter_context(perf_counter_context);\n\tmedia_clip_source_t *cur_source = ctx->cur_source;\n\tmedia_clip_source_t* mapped_source;\n\tmedia_sequence_t* sequence;\n\tmedia_set_t mapped_media_set;\n\tngx_str_t override;\n\tngx_str_t src_path;\n\tngx_str_t path;\n\tngx_int_t rc;\n\tuint32_t request_flags;\n\tu_char* override_str = NULL;\n\n\tif (conf->media_set_override_json != NULL)\n\t{\n\t\tif (ngx_http_complex_value(\n\t\t\tctx->submodule_context.r,\n\t\t\tconf->media_set_override_json,\n\t\t\t&override) != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_media_set_apply: ngx_http_complex_value failed\");\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tif (override.len > 0)\n\t\t{\n\t\t\t// copy the string to make sure it's null terminated\n\t\t\toverride_str = ngx_pnalloc(ctx->submodule_context.request_context.pool, override.len + 1);\n\t\t\tif (override_str == NULL)\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\t\"ngx_http_vod_map_media_set_apply: ngx_pnalloc failed\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t\t\t}\n\n\t\t\tngx_memcpy(override_str, override.data, override.len);\n\t\t\toverride_str[override.len] = '\\0';\n\t\t}\n\t}\n\n\t// optimization for the case of simple mapping response\n\tif (mapping->len >= conf->path_response_prefix.len + conf->path_response_postfix.len &&\n\t\tngx_memcmp(mapping->data, conf->path_response_prefix.data, conf->path_response_prefix.len) == 0 &&\n\t\tngx_memcmp(mapping->data + mapping->len - conf->path_response_postfix.len,\n\t\t\tconf->path_response_postfix.data, conf->path_response_postfix.len) == 0 &&\n\t\tmemchr(mapping->data + conf->path_response_prefix.len, '\"',\n\t\t\tmapping->len - conf->path_response_prefix.len - conf->path_response_postfix.len) == NULL &&\n\t\toverride_str == NULL)\n\t{\n\t\tsrc_path.len = mapping->len - conf->path_response_prefix.len - conf->path_response_postfix.len;\n\t\tif (src_path.len <= 0)\n\t\t{\n\t\t\t// file not found\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_media_set_apply: empty path returned from upstream %V\",\n\t\t\t\t&cur_source->stripped_uri);\n\n\t\t\t// try the fallback\n\t\t\trc = ngx_http_vod_dump_request_to_fallback(ctx->submodule_context.r);\n\t\t\tif (rc != NGX_AGAIN)\n\t\t\t{\n\t\t\t\trc = ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_EMPTY_MAPPING);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\tsrc_path.data = mapping->data + conf->path_response_prefix.len;\n\n\t\t// copy the path to decode it and make it null terminated\n\t\tpath.data = ngx_palloc(ctx->submodule_context.request_context.pool, src_path.len + 1);\n\t\tif (path.data == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_media_set_apply: ngx_palloc failed\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_ALLOC_FAILED);\n\t\t}\n\n\t\tpath.len = 0;\n\n\t\trc = vod_json_decode_string(&path, &src_path);\n\t\tif (rc != VOD_JSON_OK)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_map_media_set_apply: vod_json_decode_string failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_MAPPING);\n\t\t}\n\n\t\tpath.data[path.len] = '\\0';\n\n\t\t// move to the next suburi\n\t\tcur_source->sequence->mapped_uri = path;\n\t\tcur_source->mapped_uri = path;\n\n\t\t*cache_index = CACHE_TYPE_VOD;\n\n\t\treturn NGX_OK;\n\t}\n\n\t// TODO: in case the new media set may replace the existing one, propagate rate\n\n\tngx_perf_counter_start(perf_counter_context);\n\n\trequest_flags = ctx->request != NULL ? ctx->request->flags : 0;\n\n\tif (conf->force_continuous_timestamps)\n\t{\n\t\trequest_flags |= REQUEST_FLAG_NO_DISCONTINUITY;\n\t}\n\n\tif (conf->force_playlist_type_vod)\n\t{\n\t\trequest_flags |= REQUEST_FLAG_FORCE_PLAYLIST_TYPE_VOD;\n\t}\n\n\trc = media_set_parse_json(\n\t\t&ctx->submodule_context.request_context,\n\t\tmapping->data,\n\t\toverride_str,\n\t\t&ctx->submodule_context.request_params,\n\t\tctx->submodule_context.media_set.segmenter_conf,\n\t\tcur_source,\n\t\trequest_flags,\n\t\t&mapped_media_set);\n\n\tswitch (rc)\n\t{\n\tcase VOD_NOT_FOUND:\n\t\t// file not found, try the fallback\n\t\trc = ngx_http_vod_dump_request_to_fallback(ctx->submodule_context.r);\n\t\tif (rc != NGX_AGAIN)\n\t\t{\n\t\t\trc = NGX_HTTP_NOT_FOUND;\n\t\t}\n\t\treturn rc;\n\n\tcase VOD_OK:\n\t\tbreak;\t\t// handled outside the switch\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n\tcase VOD_REDIRECT:\n\t\treturn ngx_http_vod_handle_thumb_redirect(ctx, &mapped_media_set);\n#endif // NGX_HAVE_LIB_AV_CODEC\n\n\tdefault:\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_media_set_apply: media_set_parse_json failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, rc);\n\t}\n\n\tngx_perf_counter_end(ctx->perf_counters, perf_counter_context, PC_PARSE_MEDIA_SET);\n\n\tif (mapped_media_set.sequence_count == 1 &&\n\t\tmapped_media_set.timing.durations == NULL &&\n\t\tmapped_media_set.sequences[0].clips[0]->type == MEDIA_CLIP_SOURCE &&\n\t\t!mapped_media_set.has_multi_sequences &&\n\t\tmapped_media_set.closed_captions == NULL)\n\t{\n\t\tmapped_source = (media_clip_source_t*)*mapped_media_set.sequences[0].clips;\n\n\t\tif (mapped_source->clip_from == 0 &&\n\t\t\tmapped_source->clip_to == ULLONG_MAX &&\n\t\t\tvod_track_mask_are_all_bits_set(mapped_source->tracks_mask[MEDIA_TYPE_AUDIO]) &&\n\t\t\tvod_track_mask_are_all_bits_set(mapped_source->tracks_mask[MEDIA_TYPE_VIDEO]))\n\t\t{\n\t\t\t// TODO: drop the sequence when request params filter by id and the id does not match\n\n\t\t\t// mapping result is a simple file path, set the uri of the current source\n\t\t\tctx->submodule_context.media_set.id = mapped_media_set.id;\n\t\t\tctx->submodule_context.media_set.segmenter_conf = mapped_media_set.segmenter_conf;\n\t\t\tsequence = cur_source->sequence;\n\t\t\tsequence->mapped_uri = mapped_source->mapped_uri;\n\t\t\tsequence->tags = mapped_media_set.sequences->tags;\n\t\t\tsequence->id = mapped_media_set.sequences->id;\n\t\t\tngx_memcpy(sequence->bitrate, mapped_media_set.sequences->bitrate, sizeof(sequence->bitrate));\n\t\t\tngx_memcpy(sequence->avg_bitrate, mapped_media_set.sequences->avg_bitrate, sizeof(sequence->avg_bitrate));\n\t\t\tcur_source->mapped_uri = mapped_source->mapped_uri;\n\t\t\tcur_source->source_type = mapped_source->source_type;\n\t\t\tcur_source->encryption = mapped_source->encryption;\n\n\t\t\t*cache_index = mapped_media_set.cache_mapping ? CACHE_TYPE_VOD : -1;\n\n\t\t\treturn NGX_OK;\n\t\t}\n\t}\n\n\tif (ctx->request == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\t\"ngx_http_vod_map_media_set_apply: unsupported - non-trivial mapping in progressive download\");\n\t\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n\t}\n\n\tif (ctx->submodule_context.media_set.sequence_count == 1 &&\n\t\tctx->submodule_context.media_set.sequences[0].clips[0]->type == MEDIA_CLIP_SOURCE)\n\t{\n\t\t// media set was a single source, replace it with the mapping result\n\t\tctx->submodule_context.media_set = mapped_media_set;\n\n\t\t// cur_source is pointing to the old media set, move it to the end of the new one\n\t\tctx->cur_source = NULL;\n\n\t\t// Note: this is ok because CACHE_TYPE_xxx matches MEDIA_TYPE_xxx in order\n\t\t*cache_index = mapped_media_set.cache_mapping ? (int)mapped_media_set.original_type : -1;\n\n\t\treturn NGX_OK;\n\t}\n\n\tngx_log_error(NGX_LOG_ERR, ctx->submodule_context.request_context.log, 0,\n\t\t\"ngx_http_vod_map_media_set_apply: unsupported - multi uri/filtered request %V did not return a simple json\",\n\t\t&cur_source->stripped_uri);\n\treturn ngx_http_vod_status_to_ngx_error(ctx->submodule_context.r, VOD_BAD_REQUEST);\n}\n\nstatic ngx_int_t\nngx_http_vod_map_media_set_state_machine(ngx_http_vod_ctx_t *ctx)\n{\n\tngx_int_t rc;\n\n\t// map the uris\n\twhile (ctx->cur_source != NULL)\n\t{\n\t\trc = ngx_http_vod_map_run_step(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t\t\n\t\t// Note: cur_source can be null in case the media set is replaced\n\t\tif (ctx->cur_source == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->cur_source = ctx->cur_source->next;\n\t}\n\n\t// check whether dynamic clip mapping is needed\n\tif (ctx->submodule_context.media_set.dynamic_clips_head == NULL)\n\t{\n\t\treturn ngx_http_vod_map_dynamic_clip_done(ctx);\n\t}\n\n\t// apply the mapping passed on vod_apply_dynamic_mapping\n\tif (ctx->submodule_context.conf->apply_dynamic_mapping != NULL)\n\t{\n\t\trc = ngx_http_vod_map_dynamic_clip_apply_from_string(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (ctx->submodule_context.media_set.dynamic_clips_head == NULL)\n\t\t{\n\t\t\treturn ngx_http_vod_map_dynamic_clip_done(ctx);\n\t\t}\n\t}\n\n\treturn ngx_http_vod_map_dynamic_clip_start(ctx);\n}\n\n/// mapped mode main\n\nngx_int_t\nngx_http_vod_mapped_request_handler(ngx_http_request_t *r)\n{\n\tngx_http_vod_loc_conf_t* conf;\n\tngx_http_vod_ctx_t *ctx;\n\tngx_int_t rc;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\tconf = ctx->submodule_context.conf;\n\n\tif (conf->upstream_location.len == 0)\n\t{\n\t\t// map the uris to files\n\t\trc = ngx_http_vod_map_uris_to_paths(ctx);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\t// initialize for reading files\n\t\tctx->mapping.reader = &reader_file;\n\t\tctx->mapping.stale_retries = MAX_STALE_RETRIES;\n\t}\n\telse\n\t{\n\t\t// initialize for http read\n\t\tctx->mapping.reader = &reader_http;\n\t}\n\n\t// initialize the mapping context\n\tctx->mapping.cache_key_prefix = (r->headers_in.host != NULL ? &r->headers_in.host->value : NULL);\n\tctx->mapping.caches = conf->mapping_cache;\n\tctx->mapping.cache_count = CACHE_TYPE_COUNT;\n\tctx->mapping.max_response_size = conf->max_mapping_response_size;\n\tctx->mapping.get_uri = ngx_http_vod_map_media_set_get_uri;\n\tctx->mapping.apply = ngx_http_vod_map_media_set_apply;\n\n\tctx->perf_counter_async_read = PC_MAP_PATH;\n\tctx->state_machine = ngx_http_vod_map_media_set_state_machine;\n\n\trc = ngx_http_vod_map_media_set_state_machine(ctx);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_mapped_request_handler: ngx_http_vod_map_media_set_state_machine failed %i\", rc);\n\t}\n\n\treturn rc;\n}\n\n////// Remote mode only\n\nngx_int_t\nngx_http_vod_remote_request_handler(ngx_http_request_t *r)\n{\n\tngx_http_vod_ctx_t *ctx;\n\tngx_int_t rc;\n\n\tctx = ngx_http_get_module_ctx(r, ngx_http_vod_module);\n\n\tctx->default_reader = &reader_http;\n\tctx->perf_counter_async_read = PC_ASYNC_READ_FILE;\n\tctx->file_key_prefix = (r->headers_in.host != NULL ? &r->headers_in.host->value : NULL);\n\n\trc = ngx_http_vod_start_processing_media_file(ctx);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_remote_request_handler: ngx_http_vod_start_processing_media_file failed %i\", rc);\n\t}\n\n\treturn rc;\n}\n\n////// Main\n\nstatic ngx_int_t\nngx_http_vod_parse_uri(\n\tngx_http_request_t *r, \n\tngx_http_vod_loc_conf_t *conf, \n\trequest_params_t* request_params,\n\tmedia_set_t* media_set,\n\tconst ngx_http_vod_request_t** request)\n{\n\tngx_str_t uri_path;\n\tngx_str_t uri_file_name;\n\tngx_int_t rc;\n\tint file_components;\n\t\n\tfile_components = conf->submodule.get_file_path_components(&r->uri);\n\n\tif (!ngx_http_vod_split_uri_file_name(&r->uri, file_components, &uri_path, &uri_file_name))\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri: ngx_http_vod_split_uri_file_name failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\trequest_params->segment_index = INVALID_SEGMENT_INDEX;\n\trequest_params->segment_time = INVALID_SEGMENT_TIME;\n\n\trc = conf->submodule.parse_uri_file_name(r, conf, uri_file_name.data, uri_file_name.data + uri_file_name.len, request_params, request);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri: parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\trc = ngx_http_vod_parse_uri_path(\n\t\tr, \n\t\t&conf->multi_uri_suffix, \n\t\t&conf->uri_params_hash, \n\t\t&uri_path, \n\t\trequest_params, \n\t\tmedia_set);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri: ngx_http_vod_parse_uri_path failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tif (media_set->sequence_count != 1)\n\t{\n\t\tif (((*request)->flags & REQUEST_FLAG_SINGLE_TRACK) != 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri: request has more than one sub uri while only one is supported\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tif (media_set->sequence_count != 2 &&\n\t\t\t((*request)->flags & REQUEST_FLAG_SINGLE_TRACK_PER_MEDIA_TYPE) != 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri: request has more than two sub uris while only a single track per media type is allowed\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\t}\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_http_vod_handler(ngx_http_request_t *r)\n{\n\tngx_perf_counter_context(pcctx);\n\tresponse_cache_header_t cache_header;\n\tngx_perf_counters_t* perf_counters;\n\tngx_http_vod_ctx_t *ctx;\n\trequest_params_t request_params;\n\tmedia_set_t media_set;\n\tconst ngx_http_vod_request_t* request;\n\tngx_http_vod_loc_conf_t *conf;\n\tu_char request_key[BUFFER_CACHE_KEY_SIZE];\n\tngx_md5_t md5;\n\tngx_str_t cache_buffer;\n\tngx_str_t content_type;\n\tngx_str_t response;\n\tngx_str_t base_url;\n\tngx_int_t rc;\n\tint cache_type;\n#if (NGX_DEBUG)\n\tngx_str_t time_str;\n#endif // NGX_DEBUG\n\n\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"ngx_http_vod_handler: started\");\n\n\tngx_perf_counter_start(pcctx);\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\tperf_counters = ngx_perf_counter_get_state(conf->perf_counters_zone);\n\n\tif (r->method == NGX_HTTP_OPTIONS)\n\t{\n\t\tresponse.data = NULL;\n\t\tresponse.len = 0;\n\n\t\trc = ngx_http_vod_send_header(r, response.len, &options_content_type, MEDIA_SET_VOD, NULL);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = ngx_http_vod_send_response(r, &response, NULL);\n\t\tgoto done;\n\t}\n\n\t// we respond to 'GET' and 'HEAD' requests only\n\tif (!(r->method & (NGX_HTTP_GET | NGX_HTTP_HEAD)))\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_handler: unsupported method %ui\", r->method);\n\t\trc = NGX_HTTP_NOT_ALLOWED;\n\t\tgoto done;\n\t}\n\n\t// discard request body, since we don't need it here\n\trc = ngx_http_discard_request_body(r);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_handler: ngx_http_discard_request_body failed %i\", rc);\n\t\tgoto done;\n\t}\n\n\t// parse the uri\n\tngx_memzero(&request_params, sizeof(request_params));\n\tngx_memzero(&media_set, sizeof(media_set));\n\tif (conf->submodule.parse_uri_file_name != NULL)\n\t{\n\t\trc = ngx_http_vod_parse_uri(r, conf, &request_params, &media_set, &request);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_handler: ngx_http_vod_parse_uri failed %i\", rc);\n\t\t\tgoto done;\n\t\t}\n\t}\n\telse\n\t{\n\t\trequest = NULL;\n\t\trequest_params.sequences_mask = 1;\n\t\tvod_track_mask_set_all_bits(request_params.tracks_mask[MEDIA_TYPE_VIDEO]);\n\t\tvod_track_mask_set_all_bits(request_params.tracks_mask[MEDIA_TYPE_AUDIO]);\n\n\t\trc = ngx_http_vod_parse_uri_path(\n\t\t\tr,\n\t\t\t&conf->multi_uri_suffix,\n\t\t\t&conf->pd_uri_params_hash,\n\t\t\t&r->uri,\n\t\t\t&request_params,\n\t\t\t&media_set);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_handler: ngx_http_vod_parse_uri_path failed %i\", rc);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (media_set.sequence_count != 1)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_handler: request has more than one sub uri while only one is supported\");\n\t\t\trc = ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (request != NULL &&\n\t\trequest->handle_metadata_request != NULL)\n\t{\n\t\t// calc request key from host + uri\n\t\tngx_md5_init(&md5);\n\n\t\tbase_url.len = 0;\n\t\trc = ngx_http_vod_get_base_url(r, conf->base_url, &empty_string, &base_url);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\treturn rc;\n\t\t}\n\t\tngx_md5_update(&md5, base_url.data, base_url.len);\n\n\t\tif (conf->segments_base_url != NULL)\n\t\t{\n\t\t\tbase_url.len = 0;\n\t\t\trc = ngx_http_vod_get_base_url(r, conf->segments_base_url, &empty_string, &base_url);\n\t\t\tif (rc != NGX_OK)\n\t\t\t{\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tngx_md5_update(&md5, base_url.data, base_url.len);\n\t\t}\n\n\t\tngx_md5_update(&md5, r->uri.data, r->uri.len);\n\n\t\tngx_md5_final(request_key, &md5);\n\n\t\t// try to fetch from cache\n\t\tcache_type = ngx_buffer_cache_fetch_copy_perf(\n\t\t\tr,\n\t\t\tperf_counters,\n\t\t\tconf->response_cache,\n\t\t\tCACHE_TYPE_COUNT,\n\t\t\trequest_key,\n\t\t\t&cache_buffer);\n\t\tif (cache_type >= 0 &&\n\t\t\tcache_buffer.len > sizeof(cache_header))\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_handler: response cache hit, size is %uz\", cache_buffer.len);\n\n\t\t\t// extract the content type\n\t\t\tngx_memcpy(&cache_header, cache_buffer.data, sizeof(cache_header));\n\t\t\tcache_buffer.data += sizeof(cache_header);\n\t\t\tcache_buffer.len -= sizeof(cache_header);\n\n\t\t\tcontent_type.data = cache_buffer.data;\n\t\t\tcontent_type.len = cache_header.content_type_len;\n\n\t\t\tif (cache_buffer.len >= content_type.len)\n\t\t\t{\n\t\t\t\t// extract the response buffer\n\t\t\t\tresponse.data = cache_buffer.data + content_type.len;\n\t\t\t\tresponse.len = cache_buffer.len - content_type.len;\n\n\t\t\t\t// update request flags\n\t\t\t\tr->root_tested = !r->error_page;\n\t\t\t\tr->allow_ranges = 1;\n\n\t\t\t\t// return the response\n\t\t\t\trc = ngx_http_vod_send_header(r, response.len, &content_type, cache_header.media_set_type, request);\n\t\t\t\tif (rc != NGX_OK)\n\t\t\t\t{\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\trc = ngx_http_vod_send_response(r, &response, NULL);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_handler: response cache miss\");\n\t\t}\n\t}\n\n\t// initialize the context\n\tctx = ngx_pcalloc(r->pool, sizeof(ngx_http_vod_ctx_t));\n\tif (ctx == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_handler: ngx_pcalloc failed\");\n\t\trc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto done;\n\t}\n\n\tngx_memcpy(ctx->request_key, request_key, sizeof(request_key));\n\tctx->submodule_context.r = r;\n\tctx->submodule_context.conf = conf;\n\tctx->submodule_context.request_params = request_params;\n\tctx->submodule_context.media_set = media_set;\n\tctx->submodule_context.media_set.segmenter_conf = &conf->segmenter;\n\tctx->submodule_context.media_set.version = request_params.version;\n\tctx->request = request;\n\tctx->cur_source = media_set.sources_head;\n\tctx->submodule_context.request_context.pool = r->pool;\n\tctx->submodule_context.request_context.log = r->connection->log;\n\tctx->submodule_context.request_context.output_buffer_pool = conf->output_buffer_pool;\n\tctx->perf_counters = perf_counters;\n\tngx_perf_counter_copy(ctx->total_perf_counter_context, pcctx);\n\n#if (NGX_DEBUG)\n\t// in debug builds allow overriding the server time\n\tif (ngx_http_arg(r, (u_char *) \"time\", sizeof(\"time\") - 1, &time_str) == NGX_OK)\n\t{\n\t\tctx->submodule_context.request_context.time = ngx_atotm(time_str.data, time_str.len);\n\t}\n#endif // NGX_DEBUG\n\n\tngx_http_set_ctx(r, ctx, ngx_http_vod_module);\n\n\t// call the mode specific handler (remote/mapped/local)\n\trc = conf->request_handler(r);\n\ndone:\n\n\tif (rc == NGX_AGAIN)\n\t{\n\t\trc = NGX_DONE;\n\t\tr->main->count++;\n\t}\n\telse\n\t{\n\t\tngx_perf_counter_end(perf_counters, pcctx, PC_TOTAL);\n\t}\n\n\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"ngx_http_vod_handler: done\");\n\n\treturn rc;\n}\n"
        },
        {
          "name": "ngx_http_vod_module.h",
          "type": "blob",
          "size": 0.5869140625,
          "content": "#ifndef _NGX_HTTP_VOD_MODULE_H_INCLUDED_\n#define _NGX_HTTP_VOD_MODULE_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include <ngx_vod_version.h>\n\n// globals\nextern ngx_module_t  ngx_http_vod_module;\n\n// main\nngx_int_t ngx_http_vod_handler(ngx_http_request_t *r);\n\n// variables\nngx_int_t ngx_http_vod_preconfiguration(ngx_conf_t *cf);\n\n// handlers\nngx_int_t ngx_http_vod_local_request_handler(ngx_http_request_t *r);\nngx_int_t ngx_http_vod_mapped_request_handler(ngx_http_request_t *r);\nngx_int_t ngx_http_vod_remote_request_handler(ngx_http_request_t *r);\n\n#endif // _NGX_HTTP_VOD_MODULE_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_mss.c",
          "type": "blob",
          "size": 12.04296875,
          "content": "#include <ngx_http.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/mp4/mp4_fragment.h\"\n#include \"vod/mss/mss_packager.h\"\n#include \"vod/subtitle/ttml_builder.h\"\n#include \"vod/udrm.h\"\n\n#if (NGX_HAVE_OPENSSL_EVP)\n#include \"vod/mss/mss_playready.h\"\n#endif // NGX_HAVE_OPENSSL_EVP\n\n// constants\n#define SUPPORTED_CODECS (VOD_CODEC_FLAG(AVC) | VOD_CODEC_FLAG(AAC) | VOD_CODEC_FLAG(MP3))\n\n// typedefs\ntypedef struct {\n\tuint64_t bitrate;\n\tuint64_t time;\n\tngx_str_t media_type;\n} fragment_params_t;\n\n// constants\nstatic const ngx_http_vod_match_definition_t fragment_match_definition[] = {\n\t{ MATCH_FIXED_STRING,\t0,\t\t\t\t\t\t\t\t\t\t\t0,\tngx_string(\"QualityLevels(\") },\n\t{ MATCH_NUMBER,\t\t\toffsetof(fragment_params_t, bitrate),\t\t0,\tngx_null_string },\n\t{ MATCH_FIXED_STRING,\t0,\t\t\t\t\t\t\t\t\t\t\t0,\tngx_string(\")/Fragments(\") },\n\t{ MATCH_DELIM_STRING,\toffsetof(fragment_params_t, media_type),\t'=',ngx_null_string },\n\t{ MATCH_NUMBER,\t\t\toffsetof(fragment_params_t, time),\t\t\t0,\tngx_null_string },\n\t{ MATCH_FIXED_STRING,\t0,\t\t\t\t\t\t\t\t\t\t\t0,\tngx_string(\")\") },\n\t{ MATCH_END,\t\t\t0,\t\t\t\t\t\t\t\t\t\t\t0,\tngx_null_string },\n};\n\n// content types\nstatic u_char manifest_content_type[] = \"text/xml\";\t\t// TODO: consider moving to application/vnd.ms-sstr+xml\n\n// extensions\nstatic const u_char m4s_file_ext[] = \".m4s\";\n\nstatic ngx_int_t \nngx_http_vod_mss_handle_manifest(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tif (submodule_context->conf->drm_enabled)\n\t{\n\t\trc = mss_playready_build_manifest(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->conf->mss.manifest_conf,\n\t\t\t&submodule_context->media_set,\n\t\t\tresponse);\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\trc = mss_packager_build_manifest(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->conf->mss.manifest_conf,\n\t\t\t&submodule_context->media_set,\n\t\t\t0,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tresponse);\n\t}\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_mss_handle_manifest: mss_packager_build_manifest failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tcontent_type->data = manifest_content_type;\n\tcontent_type->len = sizeof(manifest_content_type) - 1;\n\n\treturn NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_vod_mss_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tfragment_writer_state_t* state;\n\tvod_status_t rc;\n\tbool_t reuse_buffers = FALSE;\n\tbool_t size_only = ngx_http_vod_submodule_size_only(submodule_context);\n\n#if (NGX_HAVE_OPENSSL_EVP)\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tsegment_writer_t drm_writer;\n\n\tif (conf->drm_enabled)\n\t{\n\t\tdrm_writer = *segment_writer;\t\t// must not change segment_writer, otherwise the header will be encrypted\n\n\t\trc = mss_playready_get_fragment_writer(\n\t\t\t&drm_writer,\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\tconf->min_single_nalu_per_frame_segment > 0 && submodule_context->request_params.segment_index >= conf->min_single_nalu_per_frame_segment - 1,\n\t\t\tsubmodule_context->media_set.sequences[0].encryption_key,\t\t// iv\n\t\t\tsize_only,\n\t\t\toutput_buffer,\n\t\t\tresponse_size);\n\t\tswitch (rc)\n\t\t{\n\t\tcase VOD_DONE:\t\t// passthrough\n\t\t\tbreak;\n\n\t\tcase VOD_OK:\n\t\t\tsegment_writer = &drm_writer;\n\t\t\treuse_buffers = TRUE;\t\t// mp4_cenc_encrypt allocates new buffers\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_mss_init_frame_processor: mss_playready_get_fragment_writer failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t}\n\telse\n#endif // NGX_HAVE_OPENSSL_EVP\n\t{\n\t\trc = mss_packager_build_fragment_header(\n\t\t\t&submodule_context->request_context,\n\t\t\t&submodule_context->media_set,\n\t\t\tsubmodule_context->request_params.segment_index,\n\t\t\t0,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tsize_only,\n\t\t\toutput_buffer,\n\t\t\tresponse_size);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_mss_init_frame_processor: mss_packager_build_fragment_header failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\t}\n\n\tif (!size_only || *response_size == 0)\n\t{\n\t\trc = mp4_fragment_frame_writer_init(\n\t\t\t&submodule_context->request_context,\n\t\t\tsubmodule_context->media_set.sequences,\n\t\t\tsegment_writer->write_tail,\n\t\t\tsegment_writer->context,\n\t\t\treuse_buffers,\n\t\t\t&state);\n\t\tif (rc != VOD_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\t\"ngx_http_vod_mss_init_frame_processor: mp4_fragment_frame_writer_init failed %i\", rc);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t\t}\n\n\t\t*frame_processor = (ngx_http_vod_frame_processor_t)mp4_fragment_frame_writer_process;\n\t\t*frame_processor_state = state;\n\t}\n\n\t// set the 'Content-type' header\n\tmp4_fragment_get_content_type(\n\t\tsubmodule_context->media_set.track_count[MEDIA_TYPE_VIDEO],\n\t\tcontent_type);\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_mss_handle_ttml_fragment(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* response,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n\trc = ttml_build_mp4(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tsubmodule_context->request_params.segment_index,\n\t\tMSS_TIMESCALE,\n\t\tresponse);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_mss_handle_ttml_fragment: ttml_build_mp4 failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\tmp4_fragment_get_content_type(TRUE, content_type);\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t mss_manifest_request = {\n\tREQUEST_FLAG_TIME_DEPENDENT_ON_LIVE | REQUEST_FLAG_LOOK_AHEAD_SEGMENTS | REQUEST_FLAG_NO_DISCONTINUITY,\n\tPARSE_FLAG_TOTAL_SIZE_ESTIMATE | PARSE_FLAG_PARSED_EXTRA_DATA,\n\tREQUEST_CLASS_MANIFEST,\n\tSUPPORTED_CODECS | VOD_CODEC_FLAG(WEBVTT),\n\tMSS_TIMESCALE,\n\tngx_http_vod_mss_handle_manifest,\n\tNULL,\n};\n\nstatic const ngx_http_vod_request_t mss_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK | REQUEST_FLAG_LOOK_AHEAD_SEGMENTS | REQUEST_FLAG_NO_DISCONTINUITY,\n\tPARSE_FLAG_FRAMES_ALL,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS,\n\tMSS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_mss_init_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t mss_playready_fragment_request = {\n\tREQUEST_FLAG_SINGLE_TRACK | REQUEST_FLAG_LOOK_AHEAD_SEGMENTS | REQUEST_FLAG_NO_DISCONTINUITY,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_PARSED_EXTRA_DATA,\n\tREQUEST_CLASS_SEGMENT,\n\tSUPPORTED_CODECS,\n\tMSS_TIMESCALE,\n\tNULL,\n\tngx_http_vod_mss_init_frame_processor,\n};\n\nstatic const ngx_http_vod_request_t mss_ttml_request = {\n\tREQUEST_FLAG_SINGLE_TRACK | REQUEST_FLAG_NO_DISCONTINUITY,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA | PARSE_FLAG_RELATIVE_TIMESTAMPS,\n\tREQUEST_CLASS_SEGMENT,\n\tVOD_CODEC_FLAG(WEBVTT),\n\tTTML_TIMESCALE,\n\tngx_http_vod_mss_handle_ttml_fragment,\n\tNULL,\n};\n\nstatic void\nngx_http_vod_mss_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_mss_loc_conf_t *conf)\n{\n\tconf->manifest_conf.duplicate_bitrate_threshold = NGX_CONF_UNSET_UINT;\n}\n\nstatic char *\nngx_http_vod_mss_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_mss_loc_conf_t *conf,\n\tngx_http_vod_mss_loc_conf_t *prev)\n{\n\tngx_conf_merge_str_value(conf->manifest_file_name_prefix, prev->manifest_file_name_prefix, \"manifest\");\n\tngx_conf_merge_uint_value(conf->manifest_conf.duplicate_bitrate_threshold, prev->manifest_conf.duplicate_bitrate_threshold, 4096);\n\treturn NGX_CONF_OK;\n}\n\nstatic int \nngx_http_vod_mss_get_file_path_components(ngx_str_t* uri)\n{\n\tu_char* end_pos = uri->data + uri->len;\n\n\tif (end_pos[-1] == ')')\n\t{\n\t\t// parse \"QualityLevels(2364883)/Fragments(video=0)\" as the file part of the path\n\t\treturn 2;\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_mss_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tfragment_params_t fragment_params;\n\tngx_int_t rc;\n\n\t// fragment\n\tif (end_pos[-1] == ')')\n\t{\n\t\tif (!ngx_http_vod_parse_string(fragment_match_definition, start_pos, end_pos, &fragment_params))\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_mss_parse_uri_file_name: ngx_http_vod_parse_string failed\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\trequest_params->sequences_mask = (1 << mss_sequence_index(fragment_params.bitrate));\n\n\t\trequest_params->segment_time = fragment_params.time / 10000;\n\n\t\t// Note: assuming no discontinuity, if this changes the segment index will be recalculated\n\t\trequest_params->segment_index = segmenter_get_segment_index_no_discontinuity(\n\t\t\t&conf->segmenter,\n\t\t\trequest_params->segment_time + SEGMENT_FROM_TIMESTAMP_MARGIN);\n\n\t\tif (fragment_params.media_type.len == sizeof(MSS_STREAM_TYPE_VIDEO) - 1 &&\n\t\t\tngx_memcmp(fragment_params.media_type.data, MSS_STREAM_TYPE_VIDEO, sizeof(MSS_STREAM_TYPE_VIDEO) - 1) == 0)\n\t\t{\n\t\t\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_VIDEO]);\n\t\t\tvod_set_bit(request_params->tracks_mask[MEDIA_TYPE_VIDEO], mss_track_index(fragment_params.bitrate));\n\t\t}\n\t\telse if (fragment_params.media_type.len == sizeof(MSS_STREAM_TYPE_AUDIO) - 1 &&\n\t\t\tngx_memcmp(fragment_params.media_type.data, MSS_STREAM_TYPE_AUDIO, sizeof(MSS_STREAM_TYPE_AUDIO) - 1) == 0)\n\t\t{\n\t\t\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_AUDIO]);\n\t\t\tvod_set_bit(request_params->tracks_mask[MEDIA_TYPE_AUDIO], mss_track_index(fragment_params.bitrate));\n\t\t}\n\t\telse if (fragment_params.media_type.len == sizeof(MSS_STREAM_TYPE_TEXT) - 1 &&\n\t\t\tngx_memcmp(fragment_params.media_type.data, MSS_STREAM_TYPE_TEXT, sizeof(MSS_STREAM_TYPE_TEXT) - 1) == 0)\n\t\t{\n\t\t\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_SUBTITLE]);\n\t\t\tvod_set_bit(request_params->tracks_mask[MEDIA_TYPE_SUBTITLE], 0);\n\t\t\t*request = &mss_ttml_request;\n\t\t\treturn NGX_OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_mss_parse_uri_file_name: invalid media type %V\", &fragment_params.media_type);\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\t*request = conf->drm_enabled ? &mss_playready_fragment_request : &mss_fragment_request;\n\n\t\treturn NGX_OK;\n\t}\n\t// manifest\n\telse if (ngx_http_vod_starts_with(start_pos, end_pos, &conf->mss.manifest_file_name_prefix))\n\t{\n\t\t*request = &mss_manifest_request;\n\t\tstart_pos += conf->mss.manifest_file_name_prefix.len;\n\n\t\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE, request_params);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_mss_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\treturn NGX_OK;\n\t}\n\t// fragment with non-standard format (used with redirect)\n\telse if (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->hls.m3u8_config.segment_file_name_prefix, m4s_file_ext))\n\t{\n\t\tstart_pos += conf->hls.m3u8_config.segment_file_name_prefix.len;\n\t\tend_pos -= (sizeof(m4s_file_ext) - 1);\n\t\t*request = conf->drm_enabled ? &mss_playready_fragment_request : &mss_fragment_request;\n\n\t\treturn ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX, request_params);\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_mss_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n}\n\nstatic ngx_int_t\nngx_http_vod_mss_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tvod_status_t rc;\n\t\n\trc = udrm_parse_response(\n\t\t&submodule_context->request_context,\n\t\tdrm_info,\n\t\tTRUE,\n\t\toutput);\n\tif (rc != VOD_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nDEFINE_SUBMODULE(mss);\n"
        },
        {
          "name": "ngx_http_vod_mss.h",
          "type": "blob",
          "size": 0.2158203125,
          "content": "#ifndef _NGX_HTTP_VOD_MSS_H_INCLUDED_\n#define _NGX_HTTP_VOD_MSS_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t mss;\n\n#endif // _NGX_HTTP_VOD_MSS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_mss_commands.h",
          "type": "blob",
          "size": 0.626953125,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, mss)\n\n\t{ ngx_string(\"vod_mss_manifest_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_mss_loc_conf_t, manifest_file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_mss_duplicate_bitrate_threshold\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_mss_loc_conf_t, manifest_conf.duplicate_bitrate_threshold),\n\tNULL },\n\t\n#undef BASE_OFFSET\n"
        },
        {
          "name": "ngx_http_vod_mss_conf.h",
          "type": "blob",
          "size": 0.330078125,
          "content": "#ifndef _NGX_HTTP_VOD_MSS_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_MSS_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"vod/mss/mss_packager.h\"\n\n// typedefs\ntypedef struct\n{\n\tngx_str_t manifest_file_name_prefix;\n\tmss_manifest_config_t manifest_conf;\n} ngx_http_vod_mss_loc_conf_t;\n\n#endif // _NGX_HTTP_VOD_MSS_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_request_parse.c",
          "type": "blob",
          "size": 28.80859375,
          "content": "#include \"ngx_http_vod_request_parse.h\"\n#include \"ngx_http_vod_module.h\"\n#include \"ngx_http_vod_conf.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/filters/rate_filter.h\"\n#include \"vod/parse_utils.h\"\n\n// macros\n#define skip_dash(start_pos, end_pos)\t\\\n\tif (start_pos >= end_pos)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn NGX_OK;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tif (*start_pos == '-')\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\tstart_pos++;\t\t\t\t\t\\\n\t\tif (start_pos >= end_pos)\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\\\n\t\t\treturn NGX_OK;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t}\n\n// typedefs\ntypedef ngx_int_t(*ngx_http_vod_param_parser_t)(ngx_str_t* value, void* output, int offset);\n\ntypedef struct {\n\tint name_conf_offset;\n\tchar* name;\n\tngx_http_vod_param_parser_t parser;\n\tint target_offset;\n} ngx_http_vod_uri_param_def_t;\n\ntypedef struct {\n\tngx_str_t prefix;\n\tngx_str_t middle_parts[MAX_SUB_URIS];\n\tngx_str_t postfix;\n\tuint32_t parts_count;\n} ngx_http_vod_multi_uri_t;\n\nbool_t\nngx_http_vod_parse_string(\n\tconst ngx_http_vod_match_definition_t* match_def, \n\tu_char* start_pos, \n\tu_char* end_pos, \n\tvoid* output)\n{\n\tuint64_t value;\n\tu_char* delim_pos;\n\n\tfor (;;)\n\t{\n\t\tswitch (match_def->match_type)\n\t\t{\n\t\tcase MATCH_END:\n\t\t\treturn start_pos == end_pos;\n\n\t\tcase MATCH_FIXED_STRING:\n\t\t\tif (end_pos - start_pos < (ssize_t)match_def->string.len ||\n\t\t\t\tngx_memcmp(start_pos, match_def->string.data, match_def->string.len) != 0)\n\t\t\t{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tstart_pos += match_def->string.len;\n\t\t\tbreak;\n\n\t\tcase MATCH_NUMBER:\n\t\t\tvalue = 0;\n\t\t\tfor (; start_pos < end_pos && *start_pos >= '0' && *start_pos <= '9'; start_pos++)\n\t\t\t{\n\t\t\t\tvalue = value * 10 + *start_pos - '0';\n\t\t\t}\n\t\t\t*(uint64_t*)((u_char*)output + match_def->target_offset) = value;\n\t\t\tbreak;\n\n\t\tcase MATCH_DELIM_STRING:\n\t\t\tdelim_pos = memchr(start_pos, match_def->delim, end_pos - start_pos);\n\t\t\tif (delim_pos == NULL)\n\t\t\t{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t((ngx_str_t*)((u_char*)output + match_def->target_offset))->data = start_pos;\n\t\t\t((ngx_str_t*)((u_char*)output + match_def->target_offset))->len = delim_pos - start_pos;\n\t\t\tstart_pos = delim_pos + 1;\n\t\t\tbreak;\n\t\t}\n\t\tmatch_def++;\n\t}\n}\n\nbool_t\nngx_http_vod_split_uri_file_name(\n\tngx_str_t* uri,\n\tint components,\n\tngx_str_t* path,\n\tngx_str_t* file_name)\n{\n\tu_char* cur_pos = uri->data + uri->len - 1;\n\n\tfor (cur_pos = uri->data + uri->len - 1; cur_pos >= uri->data; cur_pos--)\n\t{\n\t\tif (*cur_pos != '/')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomponents--;\n\t\tif (components > 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tpath->data = uri->data;\n\t\tpath->len = cur_pos - uri->data;\n\t\tfile_name->data = cur_pos + 1;\n\t\tfile_name->len = uri->data + uri->len - file_name->data;\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nu_char*\nngx_http_vod_extract_uint32_token_reverse(u_char* start_pos, u_char* end_pos, uint32_t* result)\n{\n\tuint32_t multiplier;\n\tuint32_t value = 0;\n\tfor (multiplier = 1;\n\t\tend_pos > start_pos && end_pos[-1] >= '0' && end_pos[-1] <= '9';\n\t\tend_pos--, multiplier *= 10)\n\t{\n\t\tvalue += (end_pos[-1] - '0') * multiplier;\n\t}\n\t*result = value;\n\treturn end_pos;\n}\n\nstatic u_char*\nngx_http_vod_extract_track_tokens(\n\tngx_http_request_t* r,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\ttrack_mask_t* result)\n{\n\tuint32_t stream_index;\n\tint media_type;\n\n\tngx_memzero(result, sizeof(result[0]) * MEDIA_TYPE_COUNT);\n\n\tfor (;;)\n\t{\n\t\tswitch (*start_pos)\n\t\t{\n\t\tcase 'v':\n\t\t\tmedia_type = MEDIA_TYPE_VIDEO;\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tmedia_type = MEDIA_TYPE_AUDIO;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn start_pos;\n\t\t}\n\n\t\tstart_pos++;\t\t// skip the v/a\n\n\t\tstream_index = 0;\n\t\tfor (; start_pos < end_pos && *start_pos >= '0' && *start_pos <= '9'; start_pos++)\n\t\t{\n\t\t\tstream_index = stream_index * 10 + *start_pos - '0';\n\t\t}\n\n\t\tif (stream_index == 0)\n\t\t{\n\t\t\t// no index => all streams of the media type\n\t\t\tvod_track_mask_set_all_bits(result[media_type]);\n\t\t}\n\t\telse if (stream_index > MAX_TRACK_COUNT)\n\t\t{\n\t\t\tvod_log_error(NGX_LOG_WARN, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_extract_track_tokens: the track index %uD of type %d exceeds the maximum track count of %i\",\n\t\t\t\tstream_index, media_type, (ngx_int_t)MAX_TRACK_COUNT);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvod_set_bit(result[media_type], stream_index - 1);\n\t\t}\n\n\t\tif (start_pos >= end_pos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*start_pos == '-')\n\t\t{\n\t\t\tstart_pos++;\n\t\t\tif (start_pos >= end_pos)\n\t\t\t{\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nngx_int_t\nngx_http_vod_parse_uri_file_name(\n\tngx_http_request_t* r,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\tuint32_t flags,\n\trequest_params_t* result)\n{\n\tsequence_tracks_mask_t* sequence_tracks_mask_end;\n\tsequence_tracks_mask_t* sequence_tracks_mask;\n\tngx_str_t* cur_sequence_id;\n\tngx_str_t* last_sequence_id;\n\ttrack_mask_t default_tracks_mask;\n\ttrack_mask_t* tracks_mask;\n\tuint32_t segment_index_shift;\n\tuint32_t sequence_index;\n\tuint32_t clip_index;\n\tuint32_t media_type;\n\tuint32_t pts_delay;\n\tuint32_t version;\n\tbool_t tracks_mask_updated;\n\tlanguage_id_t lang_id;\n\n\tif (flags & PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE)\n\t{\n\t\tvod_track_mask_set_all_bits(default_tracks_mask);\n\t}\n\telse\n\t{\n\t\tvod_track_mask_reset_all_bits(default_tracks_mask);\n\t\tvod_set_bit(default_tracks_mask, 0);\n\t}\n\tfor (media_type = 0; media_type < MEDIA_TYPE_COUNT; media_type++)\n\t{\n\t\tvod_memcpy(result->tracks_mask[media_type], default_tracks_mask, sizeof(result->tracks_mask[media_type]));\n\t}\n\tresult->sequences_mask = 0xffffffff;\n\tresult->clip_index = INVALID_CLIP_INDEX;\n\n\t// segment index\n\tif ((flags & PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX) != 0)\n\t{\n\t\tif (start_pos < end_pos && *start_pos == '-')\n\t\t{\n\t\t\tstart_pos++;\t\t// skip the -\n\t\t}\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &result->segment_index);\n\t\tif (result->segment_index <= 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse segment index\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\t\tresult->segment_index--;\t\t// convert to 0-based\n\n\t\tskip_dash(start_pos, end_pos);\n\n\t\t// index shift\n\t\tif (*start_pos == 'i')\n\t\t{\n\t\t\tstart_pos++;\t\t// skip the i\n\n\t\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &segment_index_shift);\n\t\t\tif (segment_index_shift <= 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse segment index shift\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t}\n\n\t\t\tresult->segment_index += segment_index_shift;\n\n\t\t\tskip_dash(start_pos, end_pos);\n\t\t}\n\t}\n\telse\n\t{\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\t// clip index\n\tif (*start_pos == 'c' && (flags & PARSE_FILE_NAME_ALLOW_CLIP_INDEX) != 0)\n\t{\n\t\tstart_pos++;\t\t// skip the c\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &clip_index);\n\t\tif (clip_index <= 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse clip index\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tresult->clip_index = clip_index - 1;\n\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\t// sequence (file) index\n\tif (*start_pos == 'f' || *start_pos == 's')\n\t{\n\t\tresult->sequences_mask = 0;\n\t\tcur_sequence_id = result->sequence_ids;\n\t\tlast_sequence_id = cur_sequence_id + MAX_SEQUENCE_IDS;\n\t\tsequence_tracks_mask = NULL;\n\t\tsequence_tracks_mask_end = NULL;\n\t\ttracks_mask_updated = FALSE;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tif (*start_pos == 'f')\n\t\t\t{\n\t\t\t\t// sequence index\n\t\t\t\tstart_pos++;\t\t// skip the f\n\n\t\t\t\tif (start_pos >= end_pos || *start_pos < '1' || *start_pos > '9')\n\t\t\t\t{\n\t\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: missing index following sequence selector\");\n\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t\t}\n\n\t\t\t\tsequence_index = *start_pos - '0';\n\t\t\t\tstart_pos++;\t\t// skip the digit\n\n\t\t\t\tif (start_pos < end_pos && *start_pos >= '0' && *start_pos <= '9')\n\t\t\t\t{\n\t\t\t\t\tsequence_index = sequence_index * 10 + *start_pos - '0';\n\t\t\t\t\tif (sequence_index > MAX_SEQUENCES)\n\t\t\t\t\t{\n\t\t\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: sequence index too big\");\n\t\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t\t\t}\n\t\t\t\t\tstart_pos++;\t\t// skip the digit\n\t\t\t\t}\n\n\t\t\t\tsequence_index--;\t\t// Note: sequence_index cannot be 0 here\n\t\t\t\tresult->sequences_mask |= (1 << sequence_index);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// sequence id\n\t\t\t\tstart_pos++;\t\t// skip the s\n\n\t\t\t\tif (cur_sequence_id >= last_sequence_id)\n\t\t\t\t{\n\t\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: the number of sequence ids exceeds the limit\");\n\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t\t}\n\n\t\t\t\tcur_sequence_id->data = start_pos;\n\n\t\t\t\twhile (start_pos < end_pos && *start_pos != '-')\n\t\t\t\t{\n\t\t\t\t\tstart_pos++;\n\t\t\t\t}\n\n\t\t\t\tcur_sequence_id->len = start_pos - cur_sequence_id->data;\n\n\t\t\t\tcur_sequence_id++;\n\t\t\t\tsequence_index = -(cur_sequence_id - result->sequence_ids);\n\t\t\t}\n\n\t\t\tskip_dash(start_pos, end_pos);\n\n\t\t\t// tracks spec\n\t\t\tif (*start_pos == 'v' || *start_pos == 'a')\n\t\t\t{\n\t\t\t\tif (sequence_tracks_mask != NULL)\n\t\t\t\t{\n\t\t\t\t\tif (sequence_tracks_mask >= sequence_tracks_mask_end)\n\t\t\t\t\t{\n\t\t\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: the number of track specs exceeds the limit\");\n\t\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t\t\t}\n\n\t\t\t\t\tsequence_tracks_mask->index = sequence_index;\n\t\t\t\t\ttracks_mask = sequence_tracks_mask->tracks_mask;\n\t\t\t\t\tsequence_tracks_mask++;\n\t\t\t\t\tresult->sequence_tracks_mask_end = sequence_tracks_mask;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttracks_mask_updated = TRUE;\n\t\t\t\t\ttracks_mask = result->tracks_mask;\n\t\t\t\t}\n\n\t\t\t\tstart_pos = ngx_http_vod_extract_track_tokens(\n\t\t\t\t\tr,\n\t\t\t\t\tstart_pos, \n\t\t\t\t\tend_pos, \n\t\t\t\t\ttracks_mask);\n\t\t\t\tif (start_pos == NULL)\n\t\t\t\t{\n\t\t\t\t\treturn NGX_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*start_pos != 'f' && *start_pos != 's')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sequence_tracks_mask != NULL)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// more than one sequence, allocate the per sequence tracks mask\n\t\t\tsequence_tracks_mask = ngx_palloc(r->pool, \n\t\t\t\tsizeof(sequence_tracks_mask[0]) * MAX_SEQUENCE_TRACKS_MASKS);\n\t\t\tif (sequence_tracks_mask == NULL)\n\t\t\t{\n\t\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: ngx_palloc failed\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t\t\t}\n\n\t\t\tsequence_tracks_mask_end = sequence_tracks_mask + MAX_SEQUENCE_TRACKS_MASKS;\n\n\t\t\tresult->sequence_tracks_mask = sequence_tracks_mask;\n\t\t\tresult->sequence_tracks_mask_end = sequence_tracks_mask;\n\n\t\t\tif (tracks_mask_updated)\n\t\t\t{\n\t\t\t\t// add the currently parsed mask to the array\n\t\t\t\tsequence_tracks_mask->index = sequence_index;\n\t\t\t\tngx_memcpy(sequence_tracks_mask->tracks_mask, result->tracks_mask, sizeof(sequence_tracks_mask->tracks_mask));\n\t\t\t\tsequence_tracks_mask++;\n\t\t\t\tresult->sequence_tracks_mask_end = sequence_tracks_mask;\n\n\t\t\t\t// restore the global mask to the default\n\t\t\t\tfor (media_type = 0; media_type < MEDIA_TYPE_COUNT; media_type++)\n\t\t\t\t{\n\t\t\t\t\tvod_memcpy(result->tracks_mask[media_type], default_tracks_mask, sizeof(result->tracks_mask[media_type]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (*start_pos == 'v' || *start_pos == 'a')\n\t{\n\t\t// tracks\n\t\tstart_pos = ngx_http_vod_extract_track_tokens(r, start_pos, end_pos, result->tracks_mask);\n\t\tif (start_pos == NULL)\n\t\t{\n\t\t\treturn NGX_OK;\n\t\t}\n\t}\n\n\t// pts delay\n\tif (*start_pos == 'p')\n\t{\n\t\tstart_pos++;\t\t// skip the p\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &pts_delay);\n\t\tif (pts_delay <= 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse pts delay\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tresult->pts_delay = pts_delay;\n\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\t// languages\n\tif (*start_pos == 'l')\n\t{\n\t\tresult->langs_mask = ngx_pcalloc(r->pool, LANG_MASK_SIZE * sizeof(result->langs_mask[0]));\n\t\tif (result->langs_mask == NULL)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_file_name: ngx_palloc failed\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t\t}\n\n\t\tfor (;;)\n\t\t{\n\t\t\tstart_pos++;\t\t// skip the l\n\t\t\tif (start_pos + LANG_ISO639_3_LEN > end_pos)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: language specifier length must be 3 characters\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t}\n\n\t\t\tlang_id = lang_parse_iso639_3_code(iso639_3_str_to_int(start_pos));\n\t\t\tif (lang_id == 0)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse language specifier %*s\", (size_t)3, start_pos);\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t}\n\n\t\t\tvod_set_bit(result->langs_mask, lang_id);\n\n\t\t\tstart_pos += LANG_ISO639_3_LEN;\n\n\t\t\tskip_dash(start_pos, end_pos);\n\n\t\t\tif (*start_pos != 'l')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// version\n\tif (*start_pos == 'x')\n\t{\n\t\tstart_pos++;\t\t// skip the x\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &version);\n\t\tif (version <= 0)\n\t\t{\n\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_file_name: failed to parse version\");\n\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t}\n\n\t\tresult->version = version - 1;\n\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\"ngx_http_vod_parse_uri_file_name: did not consume the whole name\");\n\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n}\n\nstatic ngx_int_t\nngx_http_vod_parse_multi_uri(\n\tngx_http_request_t* r,\n\tngx_str_t* uri,\n\tngx_str_t* multi_uri_suffix,\n\tngx_http_vod_multi_uri_t* result)\n{\n\tu_char* cur_pos;\n\tu_char* end_pos;\n\tu_char* last_comma_pos;\n\tuint32_t part_index;\n\n\tresult->prefix.data = uri->data;\n\tresult->prefix.len = uri->len;\n\tresult->postfix.data = NULL;\n\tresult->postfix.len = 0;\n\n\tif (uri->len < multi_uri_suffix->len ||\n\t\tngx_memcmp(multi_uri_suffix->data, uri->data + uri->len - multi_uri_suffix->len, multi_uri_suffix->len) != 0)\n\t{\n\t\t// not a multi uri\n\t\tresult->middle_parts[0].data = NULL;\n\t\tresult->middle_parts[0].len = 0;\n\t\tresult->parts_count = 1;\n\t\treturn NGX_OK;\n\t}\n\n\turi->len -= multi_uri_suffix->len;\n\n\tend_pos = uri->data + uri->len;\n\tlast_comma_pos = NULL;\n\tpart_index = 0;\n\tfor (cur_pos = uri->data; cur_pos < end_pos; cur_pos++)\n\t{\n\t\tif (*cur_pos != ',')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (last_comma_pos == NULL)\n\t\t{\n\t\t\tresult->prefix.len = cur_pos - uri->data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (part_index >= MAX_SUB_URIS)\n\t\t\t{\n\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\"ngx_http_vod_parse_multi_uri: number of url parts exceeds the limit\");\n\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t\t\t}\n\n\t\t\tresult->middle_parts[part_index].data = last_comma_pos;\n\t\t\tresult->middle_parts[part_index].len = cur_pos - last_comma_pos;\n\t\t\tpart_index++;\n\t\t}\n\n\t\tlast_comma_pos = cur_pos + 1;\n\t}\n\n\tif (last_comma_pos == NULL)\n\t{\n\t\t// no commas at all\n\t\tresult->postfix.data = NULL;\n\t\tresult->postfix.len = 0;\n\t}\n\telse\n\t{\n\t\t// 1 comma or more\n\t\tresult->postfix.data = last_comma_pos;\n\t\tresult->postfix.len = end_pos - last_comma_pos;\n\t}\n\n\tif (part_index == 0)\n\t{\n\t\t// no commas at all or a single comma\n\t\tresult->middle_parts[0].data = NULL;\n\t\tresult->middle_parts[0].len = 0;\n\t\tresult->parts_count = 1;\n\t}\n\telse\n\t{\n\t\t// 2 commas or more\n\t\tresult->parts_count = part_index;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_parse_uint64_param(ngx_str_t* value, void* output, int offset)\n{\n\tngx_int_t result;\n\n\tresult = ngx_atoi(value->data, value->len);\n\tif (result < 0)\n\t{\n\t\treturn NGX_HTTP_BAD_REQUEST;\n\t}\n\n\t*(uint64_t*)((u_char*)output + offset) = result;\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_parse_tracks_param(ngx_str_t* value, void* output, int offset)\n{\n\ttrack_mask_t* tracks_mask = (track_mask_t*)((u_char*)output + offset);\n\tu_char* end_pos;\n\n\tngx_memzero(tracks_mask, sizeof(tracks_mask[0]) * MEDIA_TYPE_COUNT);\n\tend_pos = parse_utils_extract_track_tokens(value->data, value->data + value->len, tracks_mask);\n\tif (end_pos != value->data + value->len)\n\t{\n\t\treturn NGX_HTTP_BAD_REQUEST;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_parse_time_shift_param(ngx_str_t* value, void* output, int offset)\n{\n\tuint32_t* time_shift = (uint32_t*)((u_char*)output + offset);\n\tuint32_t media_type;\n\tuint32_t cur_shift;\n\tu_char* cur_pos = value->data;\n\tu_char* end_pos = cur_pos + value->len;\n\tu_char* new_pos;\n\n\twhile (cur_pos < end_pos)\n\t{\n\t\tswitch (*cur_pos)\n\t\t{\n\t\tcase 'v':\n\t\t\tmedia_type = MEDIA_TYPE_VIDEO;\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tmedia_type = MEDIA_TYPE_AUDIO;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tmedia_type = MEDIA_TYPE_SUBTITLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn NGX_HTTP_BAD_REQUEST;\n\t\t}\n\t\tcur_pos++;\n\n\t\tnew_pos = parse_utils_extract_uint32_token(cur_pos, end_pos, &cur_shift);\n\t\tif (new_pos <= cur_pos)\n\t\t{\n\t\t\treturn NGX_HTTP_BAD_REQUEST;\n\t\t}\n\n\t\ttime_shift[media_type] = cur_shift;\n\n\t\tif (new_pos >= end_pos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcur_pos = new_pos;\n\t\tif (*cur_pos == '-')\n\t\t{\n\t\t\tcur_pos++;\n\t\t}\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_parse_lang_param(ngx_str_t* value, void* output, int offset)\n{\n\tmedia_clip_source_t* clip = output;\n\tmedia_sequence_t* sequence = clip->sequence;\n\tlanguage_id_t result;\n\n\tif (value->len < LANG_ISO639_3_LEN)\n\t{\n\t\treturn NGX_HTTP_BAD_REQUEST;\n\t}\n\n\tresult = lang_parse_iso639_3_code(iso639_3_str_to_int(value->data));\n\tif (result == 0)\n\t{\n\t\treturn NGX_HTTP_BAD_REQUEST;\n\t}\n\n\tsequence->tags.lang_str.data = (u_char *)lang_get_rfc_5646_name(result);\n\tsequence->tags.lang_str.len = ngx_strlen(sequence->tags.lang_str.data);\n\tsequence->tags.language = result;\n\tlang_get_native_name(result, &sequence->tags.label);\n\n\treturn VOD_OK;\n}\n\nstatic ngx_http_vod_uri_param_def_t uri_param_defs[] = {\n\t{ offsetof(ngx_http_vod_loc_conf_t, clip_to_param_name), \"clip to\", ngx_http_vod_parse_uint64_param, offsetof(media_clip_source_t, clip_to) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, clip_from_param_name), \"clip from\", ngx_http_vod_parse_uint64_param, offsetof(media_clip_source_t, clip_from) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, tracks_param_name), \"tracks\", ngx_http_vod_parse_tracks_param, offsetof(media_clip_source_t, tracks_mask) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, time_shift_param_name), \"time shift\", ngx_http_vod_parse_time_shift_param, offsetof(media_clip_source_t, time_shift) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, lang_param_name), \"lang\", ngx_http_vod_parse_lang_param, 0 },\n\t{ offsetof(ngx_http_vod_loc_conf_t, speed_param_name), \"speed\", NULL, 0 },\n\t{ -1, NULL, NULL, 0}\n};\n\nstatic ngx_http_vod_uri_param_def_t pd_uri_param_defs[] = {\n\t{ offsetof(ngx_http_vod_loc_conf_t, clip_to_param_name), \"clip to\", ngx_http_vod_parse_uint64_param, offsetof(media_clip_source_t, clip_to) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, clip_from_param_name), \"clip from\", ngx_http_vod_parse_uint64_param, offsetof(media_clip_source_t, clip_from) },\n\t{ offsetof(ngx_http_vod_loc_conf_t, tracks_param_name), \"tracks\", ngx_http_vod_parse_tracks_param, offsetof(media_clip_source_t, tracks_mask) },\n\t{ -1, NULL, NULL, 0 }\n};\n\nstatic ngx_int_t\nngx_http_vod_init_hash(\n\tngx_conf_t *cf, \n\tngx_http_vod_uri_param_def_t* elements,\n\tngx_http_vod_loc_conf_t* conf, \n\tchar* hash_name, \n\tngx_hash_t* output)\n{\n\tngx_http_vod_uri_param_def_t *element;\n\tngx_array_t elements_arr;\n\tngx_hash_key_t *hash_key;\n\tngx_hash_init_t hash;\n\tngx_str_t* cur_key;\n\n\tif (ngx_array_init(&elements_arr, cf->temp_pool, 32, sizeof(ngx_hash_key_t)) != NGX_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\tfor (element = elements; element->name_conf_offset >= 0; element++)\n\t{\n\t\tcur_key = (ngx_str_t*)((u_char*)conf + element->name_conf_offset);\n\t\tif (cur_key->len == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\thash_key = ngx_array_push(&elements_arr);\n\t\tif (hash_key == NULL)\n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\thash_key->key = *cur_key;\n\t\thash_key->key_hash = ngx_hash_key_lc(cur_key->data, cur_key->len);\n\t\thash_key->value = element;\n\t}\n\n\thash.hash = output;\n\thash.key = ngx_hash_key_lc;\n\thash.max_size = 512;\n\thash.bucket_size = ngx_align(64, ngx_cacheline_size);\n\thash.name = hash_name;\n\thash.pool = cf->pool;\n\thash.temp_pool = NULL;\n\n\tif (ngx_hash_init(&hash, elements_arr.elts, elements_arr.nelts) != NGX_OK)\n\t{\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_http_vod_init_uri_params_hash(ngx_conf_t *cf, ngx_http_vod_loc_conf_t* conf)\n{\n\tngx_int_t rc;\n\n\trc = ngx_http_vod_init_hash(\n\t\tcf,\n\t\turi_param_defs,\n\t\tconf,\n\t\t\"uri_params_hash\",\n\t\t&conf->uri_params_hash);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"failed to initialize uri params hash\");\n\t\treturn rc;\n\t}\n\n\trc = ngx_http_vod_init_hash(\n\t\tcf,\n\t\tpd_uri_param_defs,\n\t\tconf,\n\t\t\"pd_uri_params_hash\",\n\t\t&conf->pd_uri_params_hash);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"failed to initialize progressive download uri params hash\");\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_extract_uri_params(\n\tngx_http_request_t* r,\n\tngx_hash_t* params_hash,\n\tngx_str_t* uri,\n\tmedia_sequence_t* sequence,\n\tuint32_t* clip_id,\n\tmedia_clip_source_t* source_clip,\n\tmedia_clip_t** result)\n{\n\tngx_http_vod_uri_param_def_t* param_def = NULL;\n\tmedia_clip_rate_filter_t* rate_filter = NULL;\n\trequest_context_t request_context;\n\tngx_uint_t  cur_key_hash = 0;\n\tngx_str_t cur_param;\n\tngx_int_t rc;\n\tuint32_t parsed_params_mask = 0;\n\tuint32_t param_index;\n\tu_char param_name[MAX_URI_PARAM_NAME_LEN + 1];\n\tu_char* param_name_end = param_name + sizeof(param_name);\n\tu_char* param_name_pos = param_name;\n\tu_char* copy_start = uri->data;\n\tu_char* cur_pos;\n\tu_char* end_pos = uri->data + uri->len;\n\tu_char* last_slash = NULL;\n\tu_char* p;\n\n\t// set the source defaults\n\tngx_memzero(source_clip, sizeof(*source_clip));\n\n\tsource_clip->base.type = MEDIA_CLIP_SOURCE;\n\tsource_clip->base.id = (*clip_id)++;\n\n\tsource_clip->clip_to = ULLONG_MAX;\n\tngx_memset(source_clip->tracks_mask, 0xff, sizeof(source_clip->tracks_mask));\n\tsource_clip->uri = *uri;\n\tsource_clip->sequence = sequence;\n\t\n\t*result = &source_clip->base;\n\n\t// allocate the stripped uri\n\tp = ngx_palloc(r->pool, uri->len + 1);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_extract_uri_params: ngx_palloc failed (1)\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\tsource_clip->stripped_uri.data = p;\n\n\tfor (cur_pos = uri->data; cur_pos <= end_pos; cur_pos++)\n\t{\n\t\tif (cur_pos < end_pos && *cur_pos != '/')\n\t\t{\n\t\t\tif (param_name_pos < param_name_end)\n\t\t\t{\n\t\t\t\t*param_name_pos = ngx_tolower(*cur_pos);\n\t\t\t\tcur_key_hash = ngx_hash(cur_key_hash, *param_name_pos);\n\t\t\t\tparam_name_pos++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (last_slash == NULL)\n\t\t{\n\t\t\tlast_slash = cur_pos;\n\t\t\tcur_key_hash = 0;\n\t\t\tparam_name_pos = param_name;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (param_def == NULL)\n\t\t{\n\t\t\tparam_def = ngx_hash_find(params_hash, cur_key_hash, param_name, param_name_pos - param_name);\n\t\t\tif (param_def != NULL)\n\t\t\t{\n\t\t\t\tp = ngx_copy(p, copy_start, last_slash - copy_start);\n\t\t\t\tcopy_start = last_slash;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparam_index = param_def - uri_param_defs;\n\t\t\tif ((parsed_params_mask & (1 << param_index)) == 0)\t\t// first instance of a param takes priority\n\t\t\t{\n\t\t\t\tparsed_params_mask |= (1 << param_index);\n\t\t\t\tcur_param.data = last_slash + 1;\n\t\t\t\tcur_param.len = cur_pos - (last_slash + 1);\n\n\t\t\t\tif (param_def->name_conf_offset == offsetof(ngx_http_vod_loc_conf_t, speed_param_name))\n\t\t\t\t{\n\t\t\t\t\trequest_context.pool = r->pool;\n\t\t\t\t\trequest_context.log = r->connection->log;\n\n\t\t\t\t\trc = rate_filter_create_from_string(\n\t\t\t\t\t\t&request_context,\n\t\t\t\t\t\t&cur_param,\n\t\t\t\t\t\t&source_clip->base, \n\t\t\t\t\t\t&rate_filter);\n\t\t\t\t\tif (rc != VOD_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn ngx_http_vod_status_to_ngx_error(r, rc);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rate_filter->rate.num != rate_filter->rate.denom)\n\t\t\t\t\t{\n\t\t\t\t\t\trate_filter->base.id = (*clip_id)++;\n\t\t\t\t\t\t*result = &rate_filter->base;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trc = param_def->parser(&cur_param, source_clip, param_def->target_offset);\n\t\t\t\t\tif (rc != NGX_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\t\t\t\"ngx_http_vod_extract_uri_params: %s parser failed %i\", param_def->name, rc);\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcopy_start = cur_pos;\n\t\t\tparam_def = NULL;\n\t\t}\n\n\t\tlast_slash = cur_pos;\n\t\tcur_key_hash = 0;\n\t\tparam_name_pos = param_name;\n\t}\n\n\tif (source_clip->clip_from >= source_clip->clip_to)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_extract_uri_params: clip from %uL is larger than clip to %uL\", source_clip->clip_from, source_clip->clip_to);\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\tp = ngx_copy(p, copy_start, end_pos - copy_start);\n\t*p = '\\0';\n\n\tsource_clip->stripped_uri.len = p - source_clip->stripped_uri.data;\n\tsource_clip->mapped_uri = source_clip->stripped_uri;\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_http_vod_parse_uri_path(\n\tngx_http_request_t* r,\n\tngx_str_t* multi_uri_suffix,\n\tngx_hash_t* params_hash,\n\tngx_str_t* uri,\n\trequest_params_t* request_params,\n\tmedia_set_t* media_set)\n{\n\tmedia_sequence_t* cur_sequence;\n\tmedia_clip_source_t* cur_source;\n\tmedia_clip_source_t* sources_head;\n\tngx_http_vod_multi_uri_t multi_uri;\n\tmedia_clip_t** cur_clip_ptr;\n\tmedia_clip_t* cur_clip;\n\tngx_str_t parts[3];\n\tngx_str_t cur_uri;\n\tngx_int_t rc;\n\ttrack_mask_t track_mask_temp;\n\tuint32_t sequences_mask;\n\tuint32_t parts_mask;\n\tuint32_t media_type;\n\tuint32_t clip_id = 1;\n\tuint32_t i;\n\tbool_t has_tracks;\n\tint uri_count;\n\n\tmedia_set->uri = *uri;\t\t// must save the uri before calling ngx_http_vod_parse_multi_uri as it may change\n\n\tmulti_uri.parts_count = 0;\n\n\trc = ngx_http_vod_parse_multi_uri(r, uri, multi_uri_suffix, &multi_uri);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri_path: ngx_http_vod_parse_multi_uri failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tif (multi_uri.parts_count > 1 && \n\t\trequest_params->sequence_ids[0].len == 0)\n\t{\n\t\tsequences_mask = request_params->sequences_mask;\n\t\trequest_params->sequences_mask = 0xffffffff;\t// reset the sequences mask so that it won't be applied again on the mapping request\n\t}\n\telse\n\t{\n\t\tsequences_mask = 0xffffffff;\n\t}\n\n\tparts_mask = (1 << multi_uri.parts_count) - 1;\n\t\n\turi_count = vod_get_number_of_set_bits32(sequences_mask & parts_mask);\n\tif (uri_count == 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri_path: request has no uris\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\tcur_sequence = ngx_palloc(r->pool,\n\t\t(sizeof(*cur_sequence) + sizeof(*cur_source) + sizeof(*cur_clip_ptr)) * uri_count);\n\tif (cur_sequence == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri_path: ngx_palloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\tmedia_set->sequences = cur_sequence;\n\n\tcur_source = (void*)(cur_sequence + uri_count);\n\n\tcur_clip_ptr = (void*)(cur_source + uri_count);\n\n\tsources_head = NULL;\n\n\tparts[0] = multi_uri.prefix;\n\tparts[2] = multi_uri.postfix;\n\n\tfor (i = 0; i < multi_uri.parts_count; i++)\n\t{\n\t\tif ((sequences_mask & (1 << i)) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_sequence->id.len = 0;\n\t\tcur_sequence->tags.lang_str.len = 0;\n\t\tcur_sequence->tags.language = 0;\n\t\tcur_sequence->tags.label.len = 0;\n\t\tcur_sequence->tags.is_default = -1;\n\t\tcur_sequence->first_key_frame_offset = 0;\n\t\tcur_sequence->key_frame_durations = NULL;\n\t\tcur_sequence->drm_info = NULL;\n\t\tngx_memzero(cur_sequence->bitrate, sizeof(cur_sequence->bitrate));\n\t\tngx_memzero(cur_sequence->avg_bitrate, sizeof(cur_sequence->avg_bitrate));\n\n\t\tparts[1] = multi_uri.middle_parts[i];\n\t\trc = ngx_http_vod_merge_string_parts(r, parts, 3, &cur_uri);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_path: ngx_http_vod_merge_string_parts failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = ngx_http_vod_extract_uri_params(r, params_hash, &cur_uri, cur_sequence, &clip_id, cur_source, &cur_clip);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_parse_uri_path: ngx_http_vod_extract_uri_params failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\thas_tracks = FALSE;\n\t\tfor (media_type = 0; media_type < MEDIA_TYPE_COUNT; media_type++)\n\t\t{\n\t\t\tvod_track_mask_and_bits(track_mask_temp, cur_source->tracks_mask[media_type], request_params->tracks_mask[media_type]);\n\t\t\tif (vod_track_mask_is_any_bit_set(track_mask_temp))\n\t\t\t{\n\t\t\t\thas_tracks = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!has_tracks)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t*cur_clip_ptr = cur_clip;\n\n\t\tcur_source->next = sources_head;\n\t\tsources_head = cur_source;\n\n\t\tcur_sequence->clips = cur_clip_ptr;\n\t\tcur_sequence->index = i;\n\t\tcur_sequence->stripped_uri = cur_source->stripped_uri;\n\t\tcur_sequence->mapped_uri = cur_source->stripped_uri;\n\n\t\tcur_source++;\n\t\tcur_sequence++;\n\t\tcur_clip_ptr++;\n\t}\n\n\t// need to test again since we filtered sub uris that didn't have any required tracks\n\tmedia_set->sequence_count = cur_sequence - media_set->sequences;\n\tif (media_set->sequence_count <= 0)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_parse_uri_path: request has no uris after track filtering\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\tmedia_set->sources_head = sources_head;\n\tmedia_set->sequences_end = cur_sequence;\n\tmedia_set->has_multi_sequences = (multi_uri.parts_count > 1);\n\tmedia_set->timing.total_count = 1;\n\tmedia_set->clip_count = 1;\n\tmedia_set->presentation_end = TRUE;\n\n\treturn NGX_OK;\n}\n"
        },
        {
          "name": "ngx_http_vod_request_parse.h",
          "type": "blob",
          "size": 2.5244140625,
          "content": "#ifndef _NGX_HTTP_VOD_REQUEST_PARSE_H_INCLUDED_\n#define _NGX_HTTP_VOD_REQUEST_PARSE_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"ngx_buffer_cache.h\"\n#include \"vod/mp4/mp4_parser.h\"\n#include \"vod/media_set.h\"\n\n// constants\n#define MAX_SUB_URIS (32)\n#define MAX_URI_PARAM_NAME_LEN (32)\t\t\t// clipTo, clipFrom etc.\n\n#define PARSE_FILE_NAME_EXPECT_SEGMENT_INDEX\t(0x1)\n#define PARSE_FILE_NAME_MULTI_STREAMS_PER_TYPE\t(0x2)\n#define PARSE_FILE_NAME_ALLOW_CLIP_INDEX\t\t(0x4)\n\n// macros\n#define ngx_http_vod_starts_with(start_pos, end_pos, prefix)\t\\\n\t((end_pos) - (start_pos) >= (int)(prefix)->len && ngx_memcmp((start_pos), (prefix)->data, (prefix)->len) == 0)\n\n#define ngx_http_vod_ends_with(start_pos, end_pos, postfix)\t\\\n\t((end_pos) - (start_pos) >= (int)(postfix)->len && ngx_memcmp((end_pos) - (postfix)->len, (postfix)->data, (postfix)->len) == 0)\n\n#define ngx_http_vod_ends_with_static(start_pos, end_pos, postfix)\t\\\n\t((end_pos) - (start_pos) >= (int)sizeof(postfix) - 1 && ngx_memcmp((end_pos) - (sizeof(postfix) - 1), (postfix), sizeof(postfix) - 1) == 0)\n\n#define ngx_http_vod_match_prefix_postfix(start_pos, end_pos, prefix, postfix)\t\t\t\t\\\n\t((end_pos) - (start_pos) >= (int)(prefix)->len + (int)sizeof(postfix) - 1 &&\t\t\t\\\n\tngx_memcmp((end_pos) - (sizeof(postfix) - 1), (postfix), sizeof(postfix) - 1) == 0 &&\t\\\n\tngx_memcmp((start_pos), (prefix)->data, (prefix)->len) == 0)\n\n// typedefs\nstruct ngx_http_vod_request_s;\nstruct ngx_http_vod_loc_conf_s;\n\nenum {\n\tMATCH_END,\n\tMATCH_FIXED_STRING,\n\tMATCH_DELIM_STRING,\n\tMATCH_NUMBER,\n};\n\ntypedef struct {\n\tint match_type;\n\tint target_offset;\n\tint delim;\n\tngx_str_t string;\n} ngx_http_vod_match_definition_t;\n\n// functions\nbool_t ngx_http_vod_split_uri_file_name(\n\tngx_str_t* uri,\n\tint components,\n\tngx_str_t* path,\n\tngx_str_t* file_name);\n\nngx_int_t ngx_http_vod_parse_uri_path(\n\tngx_http_request_t* r,\n\tngx_str_t* multi_uri_suffix,\n\tngx_hash_t* params_hash,\n\tngx_str_t* uri,\n\trequest_params_t* request_params,\n\tmedia_set_t* media_set);\n\nngx_int_t ngx_http_vod_init_uri_params_hash(\n\tngx_conf_t *cf, \n\tstruct ngx_http_vod_loc_conf_s* conf);\n\n// utility functions for submodules\nu_char* ngx_http_vod_extract_uint32_token_reverse(\n\tu_char* start_pos, \n\tu_char* end_pos, \n\tuint32_t* result);\n\nbool_t ngx_http_vod_parse_string(\n\tconst ngx_http_vod_match_definition_t* match_def,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\tvoid* output);\n\nngx_int_t ngx_http_vod_parse_uri_file_name(\n\tngx_http_request_t* r,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\tuint32_t flags,\n\trequest_params_t* result);\n\n#endif // _NGX_HTTP_VOD_REQUEST_PARSE_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_status.c",
          "type": "blob",
          "size": 11.115234375,
          "content": "// includes\n#include \"ngx_http_vod_status.h\"\n#include \"ngx_http_vod_module.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"ngx_http_vod_conf.h\"\n#include \"ngx_perf_counters.h\"\n#include \"ngx_buffer_cache.h\"\n\n// macros\n#define DEFINE_STAT(x) { { sizeof(#x) - 1, (u_char *) #x }, offsetof(ngx_buffer_cache_stats_t, x) }\n\n// constants\n#define PATH_PERF_COUNTERS_OPEN \"<performance_counters>\\r\\n\"\n#define PATH_PERF_COUNTERS_CLOSE \"</performance_counters>\\r\\n\"\n#define PERF_COUNTER_FORMAT \"<sum>%uA</sum>\\r\\n<count>%uA</count>\\r\\n<max>%uA</max>\\r\\n<max_time>%uA</max_time>\\r\\n<max_pid>%uA</max_pid>\\r\\n\"\n\n#define PROM_STATUS_PREFIX\t\t\t\t\t\t\t\t\\\n\t\"nginx_vod_build_info{version=\\\"\" NGINX_VOD_VERSION \"\\\"} 1\\n\\n\"\n#define PROM_VOD_CACHE_METRIC_FORMAT \"vod_cache_%V{cache=\\\"%V\\\"} %uA\\n\"\n#define PROM_PERF_COUNTER_METRICS\t\t\t\t\t\t\\\n\t\"vod_perf_counter_sum{action=\\\"%V\\\"} %uA\\n\"\t\t\t\\\n\t\"vod_perf_counter_count{action=\\\"%V\\\"} %uA\\n\"\t\t\\\n\t\"vod_perf_counter_max{action=\\\"%V\\\"} %uA\\n\"\t\t\t\\\n\t\"vod_perf_counter_max_time{action=\\\"%V\\\"} %uA\\n\"\t\\\n\t\"vod_perf_counter_max_pid{action=\\\"%V\\\"} %uA\\n\\n\"\t\\\n\n// typedefs\ntypedef struct {\n\tint conf_offset;\n\tngx_str_t open_tag;\n\tngx_str_t close_tag;\n} ngx_http_vod_cache_info_t;\n\ntypedef struct {\n\tngx_str_t name;\n\tunsigned offset;\n} ngx_http_vod_stat_def_t;\n\n// constants\nstatic const u_char status_prefix[] = \n\t\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\r\\n\"\n\t\"<vod>\\r\\n\"\n\t\"<version>\" NGINX_VOD_VERSION \"</version>\\r\\n\";\nstatic const u_char status_postfix[] = \"</vod>\\r\\n\";\n\nstatic ngx_str_t xml_content_type = ngx_string(\"text/xml\");\nstatic ngx_str_t text_content_type = ngx_string(\"text/plain\");\nstatic ngx_str_t reset_response = ngx_string(\"OK\\r\\n\");\n\nstatic ngx_http_vod_stat_def_t buffer_cache_stat_defs[] = {\n\tDEFINE_STAT(store_ok),\n\tDEFINE_STAT(store_bytes),\n\tDEFINE_STAT(store_err),\n\tDEFINE_STAT(store_exists),\n\tDEFINE_STAT(fetch_hit),\n\tDEFINE_STAT(fetch_bytes),\n\tDEFINE_STAT(fetch_miss),\n\tDEFINE_STAT(evicted),\n\tDEFINE_STAT(evicted_bytes),\n\tDEFINE_STAT(reset),\n\tDEFINE_STAT(entries),\n\tDEFINE_STAT(data_size),\n\t{ ngx_null_string, 0 }\n};\n\nstatic ngx_http_vod_cache_info_t cache_infos[] = {\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, metadata_cache),\n\t\tngx_string(\"<metadata_cache>\\r\\n\"),\n\t\tngx_string(\"</metadata_cache>\\r\\n\"),\n\t},\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, response_cache[CACHE_TYPE_VOD]),\n\t\tngx_string(\"<response_cache>\\r\\n\"),\n\t\tngx_string(\"</response_cache>\\r\\n\"),\n\t},\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, response_cache[CACHE_TYPE_LIVE]),\n\t\tngx_string(\"<live_response_cache>\\r\\n\"),\n\t\tngx_string(\"</live_response_cache>\\r\\n\"),\n\t},\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, mapping_cache[CACHE_TYPE_VOD]),\n\t\tngx_string(\"<mapping_cache>\\r\\n\"),\n\t\tngx_string(\"</mapping_cache>\\r\\n\"),\n\t},\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, mapping_cache[CACHE_TYPE_LIVE]),\n\t\tngx_string(\"<live_mapping_cache>\\r\\n\"),\n\t\tngx_string(\"</live_mapping_cache>\\r\\n\"),\n\t},\n\t{\n\t\toffsetof(ngx_http_vod_loc_conf_t, drm_info_cache),\n\t\tngx_string(\"<drm_info_cache>\\r\\n\"),\n\t\tngx_string(\"</drm_info_cache>\\r\\n\"),\n\t},\n};\n\nstatic u_char*\nngx_http_vod_append_cache_stats(u_char* p, ngx_buffer_cache_stats_t* stats)\n{\n\tngx_http_vod_stat_def_t* cur_stat;\n\n\tfor (cur_stat = buffer_cache_stat_defs; cur_stat->name.data != NULL; cur_stat++)\n\t{\n\t\t// opening tag\n\t\t*p++ = '<';\n\t\tp = ngx_copy(p, cur_stat->name.data, cur_stat->name.len);\n\t\t*p++ = '>';\n\n\t\t// value\n\t\tp = ngx_sprintf(p, \"%uA\", *(ngx_atomic_t*)((u_char*)stats + cur_stat->offset));\n\n\t\t// closing tag\n\t\t*p++ = '<';\n\t\t*p++ = '/';\n\t\tp = ngx_copy(p, cur_stat->name.data, cur_stat->name.len);\n\t\t*p++ = '>';\n\n\t\t// newline\n\t\t*p++ = CR;\n\t\t*p++ = LF;\n\t}\n\n\treturn p;\n}\n\nstatic ngx_int_t\nngx_http_vod_status_reset(ngx_http_request_t *r)\n{\n\tngx_http_vod_loc_conf_t *conf;\n\tngx_perf_counters_t* perf_counters;\n\tngx_buffer_cache_t *cur_cache;\n\tunsigned i;\n\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\tperf_counters = ngx_perf_counter_get_state(conf->perf_counters_zone);\n\n\tfor (i = 0; i < sizeof(cache_infos) / sizeof(cache_infos[0]); i++)\n\t{\n\t\tcur_cache = *(ngx_buffer_cache_t **)((u_char*)conf + cache_infos[i].conf_offset);\n\t\tif (cur_cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tngx_buffer_cache_reset_stats(cur_cache);\n\t}\n\n\tif (perf_counters != NULL)\n\t{\n\t\tfor (i = 0; i < PC_COUNT; i++)\n\t\t{\n\t\t\tperf_counters->counters[i].sum = 0;\n\t\t\tperf_counters->counters[i].count = 0;\n\t\t\tperf_counters->counters[i].max = 0;\n\t\t\tperf_counters->counters[i].max_time = 0;\n\t\t\tperf_counters->counters[i].max_pid = 0;\n\t\t}\n\t}\n\n\treturn ngx_http_vod_send_response(r, &reset_response, &text_content_type);\n}\n\nstatic ngx_int_t\nngx_http_vod_status_xml_handler(ngx_http_request_t *r)\n{\n\tngx_buffer_cache_stats_t stats;\n\tngx_http_vod_loc_conf_t *conf;\n\tngx_http_vod_stat_def_t* cur_stat;\n\tngx_perf_counters_t* perf_counters;\n\tngx_buffer_cache_t *cur_cache;\n\tngx_str_t response;\n\tu_char* p;\n\tsize_t cache_stats_len = 0;\n\tsize_t result_size;\n\tunsigned i;\n\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\tperf_counters = ngx_perf_counter_get_state(conf->perf_counters_zone);\n\n\t// calculate the buffer size\n\tfor (cur_stat = buffer_cache_stat_defs; cur_stat->name.data != NULL; cur_stat++)\n\t{\n\t\tcache_stats_len += sizeof(\"<></>\\r\\n\") - 1 + 2 * cur_stat->name.len + NGX_ATOMIC_T_LEN;\n\t}\n\n\tresult_size = sizeof(status_prefix) - 1;\n\tfor (i = 0; i < sizeof(cache_infos) / sizeof(cache_infos[0]); i++)\n\t{\n\t\tcur_cache = *(ngx_buffer_cache_t **)((u_char*)conf + cache_infos[i].conf_offset);\n\t\tif (cur_cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult_size += cache_infos[i].open_tag.len + cache_stats_len + cache_infos[i].close_tag.len;\n\t}\n\n\tif (perf_counters != NULL)\n\t{\n\t\tresult_size += sizeof(PATH_PERF_COUNTERS_OPEN);\n\t\tfor (i = 0; i < PC_COUNT; i++)\n\t\t{\n\t\t\tresult_size += perf_counters_open_tags[i].len + sizeof(PERF_COUNTER_FORMAT) + 5 * NGX_ATOMIC_T_LEN + perf_counters_close_tags[i].len;\n\t\t}\n\t\tresult_size += sizeof(PATH_PERF_COUNTERS_CLOSE);\n\t}\n\n\tresult_size += sizeof(status_postfix);\n\n\t// allocate the buffer\n\tresponse.data = ngx_palloc(r->pool, result_size);\n\tif (response.data == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_status_xml_handler: ngx_palloc failed\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t// populate the buffer\n\tp = ngx_copy(response.data, status_prefix, sizeof(status_prefix) - 1);\n\n\tfor (i = 0; i < sizeof(cache_infos) / sizeof(cache_infos[0]); i++)\n\t{\n\t\tcur_cache = *(ngx_buffer_cache_t **)((u_char*)conf + cache_infos[i].conf_offset);\n\t\tif (cur_cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tngx_buffer_cache_get_stats(cur_cache, &stats);\n\n\t\tp = ngx_copy(p, cache_infos[i].open_tag.data, cache_infos[i].open_tag.len);\n\t\tp = ngx_http_vod_append_cache_stats(p, &stats);\n\t\tp = ngx_copy(p, cache_infos[i].close_tag.data, cache_infos[i].close_tag.len);\n\t}\n\n\tif (perf_counters != NULL)\n\t{\n\t\tp = ngx_copy(p, PATH_PERF_COUNTERS_OPEN, sizeof(PATH_PERF_COUNTERS_OPEN) - 1);\n\t\tfor (i = 0; i < PC_COUNT; i++)\n\t\t{\n\t\t\tp = ngx_copy(p, perf_counters_open_tags[i].data, perf_counters_open_tags[i].len);\n\t\t\tp = ngx_sprintf(p, PERF_COUNTER_FORMAT, \n\t\t\t\tperf_counters->counters[i].sum, \n\t\t\t\tperf_counters->counters[i].count, \n\t\t\t\tperf_counters->counters[i].max, \n\t\t\t\tperf_counters->counters[i].max_time, \n\t\t\t\tperf_counters->counters[i].max_pid);\n\t\t\tp = ngx_copy(p, perf_counters_close_tags[i].data, perf_counters_close_tags[i].len);\n\t\t}\n\t\tp = ngx_copy(p, PATH_PERF_COUNTERS_CLOSE, sizeof(PATH_PERF_COUNTERS_CLOSE) - 1);\n\t}\n\n\tp = ngx_copy(p, status_postfix, sizeof(status_postfix) - 1);\n\t\n\tresponse.len = p - response.data;\n\t\n\tif (response.len > result_size)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_status_xml_handler: response length %uz exceeded allocated length %uz\",\n\t\t\tresponse.len, result_size);\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn ngx_http_vod_send_response(r, &response, &xml_content_type);\n}\n\nstatic ngx_int_t\nngx_http_vod_status_prom_handler(ngx_http_request_t *r)\n{\n\tngx_buffer_cache_stats_t stats;\n\tngx_http_vod_stat_def_t* cur_stat;\n\tngx_http_vod_loc_conf_t *conf;\n\tngx_perf_counters_t* perf_counters;\n\tngx_buffer_cache_t *cur_cache;\n\tngx_str_t response;\n\tngx_str_t cache_name;\n\tngx_str_t action;\n\tunsigned i;\n\tu_char* p;\n\tsize_t result_size;\n\tsize_t names_len;\n\n\tconf = ngx_http_get_module_loc_conf(r, ngx_http_vod_module);\n\tperf_counters = ngx_perf_counter_get_state(conf->perf_counters_zone);\n\n\tnames_len = 0;\n\tfor (cur_stat = buffer_cache_stat_defs; cur_stat->name.data != NULL; cur_stat++)\n\t{\n\t\tnames_len += cur_stat->name.len;\n\t}\n\n\tresult_size = sizeof(PROM_STATUS_PREFIX) - 1;\n\tfor (i = 0; i < vod_array_entries(cache_infos); i++)\n\t{\n\t\tcur_cache = *(ngx_buffer_cache_t **)((u_char*)conf + cache_infos[i].conf_offset);\n\t\tif (cur_cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult_size += (sizeof(PROM_VOD_CACHE_METRIC_FORMAT) - 1 + cache_infos[i].open_tag.len + NGX_ATOMIC_T_LEN) *\n\t\t\tvod_array_entries(buffer_cache_stat_defs) + names_len + sizeof(\"\\n\") - 1;\n\t}\n\n\tif (perf_counters != NULL)\n\t{\n\t\tfor (i = 0; i < PC_COUNT; i++)\n\t\t{\n\t\t\tresult_size += sizeof(PROM_PERF_COUNTER_METRICS) - 1 + (perf_counters_open_tags[i].len + NGX_ATOMIC_T_LEN) * 5;\n\t\t}\n\t}\n\n\t// allocate the buffer\n\tp = ngx_palloc(r->pool, result_size);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_status_prom_handler: ngx_palloc failed\");\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tresponse.data = p;\n\n\tp = ngx_copy(p, PROM_STATUS_PREFIX, sizeof(PROM_STATUS_PREFIX) - 1);\n\n\tfor (i = 0; i < vod_array_entries(cache_infos); i++)\n\t{\n\t\tcur_cache = *(ngx_buffer_cache_t **)((u_char*)conf + cache_infos[i].conf_offset);\n\t\tif (cur_cache == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tngx_buffer_cache_get_stats(cur_cache, &stats);\n\n\t\tcache_name.data = cache_infos[i].open_tag.data + 1;\n\t\tcache_name.len = cache_infos[i].open_tag.len - 4;\n\n\t\tfor (cur_stat = buffer_cache_stat_defs; cur_stat->name.data != NULL; cur_stat++)\n\t\t{\n\t\t\tp = ngx_sprintf(p, PROM_VOD_CACHE_METRIC_FORMAT, &cur_stat->name, &cache_name, *(ngx_atomic_t*)((u_char*)&stats + cur_stat->offset));\n\t\t}\n\t\t*p++ = '\\n';\n\t}\n\n\tif (perf_counters != NULL)\n\t{\n\t\tfor (i = 0; i < PC_COUNT; i++)\n\t\t{\n\t\t\taction.data = perf_counters_open_tags[i].data + 1;\n\t\t\taction.len = perf_counters_open_tags[i].len - 4;\n\n\t\t\tp = ngx_sprintf(p, PROM_PERF_COUNTER_METRICS,\n\t\t\t\t&action, perf_counters->counters[i].sum,\n\t\t\t\t&action, perf_counters->counters[i].count,\n\t\t\t\t&action, perf_counters->counters[i].max,\n\t\t\t\t&action, perf_counters->counters[i].max_time,\n\t\t\t\t&action, perf_counters->counters[i].max_pid);\n\t\t}\n\t}\n\n\tresponse.len = p - response.data;\n\n\tif (response.len > result_size)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_status_prom_handler: response length %uz exceeded allocated length %uz\",\n\t\t\tresponse.len, result_size);\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn ngx_http_vod_send_response(r, &response, &xml_content_type);\n}\n\nngx_int_t\nngx_http_vod_status_handler(ngx_http_request_t *r)\n{\n\tngx_str_t value;\n\n\tif (ngx_http_arg(r, (u_char *) \"reset\", sizeof(\"reset\") - 1, &value) == NGX_OK &&\n\t\tvalue.len == 1 &&\n\t\tvalue.data[0] == '1')\n\t{\n\t\treturn ngx_http_vod_status_reset(r);\n\t}\n\n\tif (ngx_http_arg(r, (u_char *) \"format\", sizeof(\"format\") - 1, &value) == NGX_OK &&\n\t\tvalue.len == sizeof(\"prom\") - 1 &&\n\t\tngx_strncmp(value.data, \"prom\", sizeof(\"prom\") - 1) == 0)\n\t{\n\t\treturn ngx_http_vod_status_prom_handler(r);\n\t}\n\n\treturn ngx_http_vod_status_xml_handler(r);\n}\n"
        },
        {
          "name": "ngx_http_vod_status.h",
          "type": "blob",
          "size": 0.2314453125,
          "content": "#ifndef _NGX_HTTP_VOD_STATUS_H_INCLUDED_\n#define _NGX_HTTP_VOD_STATUS_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n\n// functions\nngx_int_t ngx_http_vod_status_handler(ngx_http_request_t *r);\n\n#endif // _NGX_HTTP_VOD_STATUS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_submodule.c",
          "type": "blob",
          "size": 0.4130859375,
          "content": "#include \"ngx_http_vod_dash.h\"\n#include \"ngx_http_vod_hds.h\"\n#include \"ngx_http_vod_hls.h\"\n#include \"ngx_http_vod_mss.h\"\n\n#if (NGX_HAVE_LIB_AV_CODEC)\n#include \"ngx_http_vod_thumb.h\"\n#include \"ngx_http_vod_volume_map.h\"\n#endif // NGX_HAVE_LIB_AV_CODEC\n\nconst ngx_http_vod_submodule_t* submodules[] = {\n\t&dash,\n\t&hds,\n\t&hls,\n\t&mss,\n#if (NGX_HAVE_LIB_AV_CODEC)\n\t&thumb,\n\t&volume_map,\n#endif // NGX_HAVE_LIB_AV_CODEC\n\tNULL,\n};\n"
        },
        {
          "name": "ngx_http_vod_submodule.h",
          "type": "blob",
          "size": 2.9189453125,
          "content": "#ifndef _NGX_HTTP_VOD_SUBMODULE_H_INCLUDED_\n#define _NGX_HTTP_VOD_SUBMODULE_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_request_parse.h\"\n#include \"vod/common.h\"\n\n// macros\n#define DEFINE_SUBMODULE(x) const ngx_http_vod_submodule_t x = {\t\\\n\t\t(u_char*)#x,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsizeof(#x) - 1,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\toffsetof(ngx_http_vod_loc_conf_t, x),\t\t\t\t\t\\\n\t\t(ngx_http_vod_create_loc_conf_t)ngx_http_vod_##x##_create_loc_conf,\t\\\n\t\t(ngx_http_vod_merge_loc_conf_t)ngx_http_vod_##x##_merge_loc_conf,\t\\\n\t\tngx_http_vod_##x##_get_file_path_components,\t\t\t\\\n\t\tngx_http_vod_##x##_parse_uri_file_name,\t\t\t\t\t\\\n\t\tngx_http_vod_##x##_parse_drm_info,\t\t\t\t\t\t\\\n}\n\n#define ngx_http_vod_submodule_size_only(submodule_context)\t\t\\\n\t((submodule_context)->r->header_only || (submodule_context)->r->method == NGX_HTTP_HEAD)\n\n// request classes\n#define REQUEST_CLASS_MANIFEST\t(0x01)\n#define REQUEST_CLASS_SEGMENT\t(0x02)\n#define REQUEST_CLASS_THUMB\t\t(0x04)\n#define REQUEST_CLASS_OTHER\t\t(0x08)\t\t// dash init segment, hls iframes manifest, hls master manifest, hls encryption key\n\nstruct ngx_http_vod_loc_conf_s;\n\n// typedefs\ntypedef vod_status_t (*ngx_http_vod_frame_processor_t)(void* context);\n\ntypedef void (*ngx_http_vod_create_loc_conf_t)(\n\tngx_conf_t *cf, \n\tvoid *conf);\n\ntypedef char* (*ngx_http_vod_merge_loc_conf_t)(\n\tngx_conf_t *cf, \n\tstruct ngx_http_vod_loc_conf_s *base, \n\tvoid *conf, \n\tvoid *prev);\n\ntypedef struct {\n\trequest_context_t request_context;\n\tmedia_set_t media_set;\n\trequest_params_t request_params;\n\tngx_http_request_t* r;\n\tstruct ngx_http_vod_loc_conf_s* conf;\n} ngx_http_vod_submodule_context_t;\n\n// submodule request\nstruct ngx_http_vod_request_s {\n\tint flags;\n\tint parse_type;\n\tint request_class;\n\tint codecs_mask;\n\tuint32_t timescale;\n\t\n\tngx_int_t (*handle_metadata_request)(\n\t\t// in\n\t\tngx_http_vod_submodule_context_t* submodule_context,\n\t\t// out\n\t\tngx_str_t* response,\n\t\tngx_str_t* content_type);\n\t\t\n\tngx_int_t (*init_frame_processor)(\n\t\t// in\n\t\tngx_http_vod_submodule_context_t* submodule_context,\n\t\tsegment_writer_t* segment_writer,\n\t\t// out\n\t\tngx_http_vod_frame_processor_t* frame_processor,\n\t\tvoid** frame_processor_state,\n\t\tngx_str_t* output_buffer,\n\t\tsize_t* response_size,\n\t\tngx_str_t* content_type);\n};\n\ntypedef struct ngx_http_vod_request_s ngx_http_vod_request_t;\n\n// submodule\ntypedef struct {\n\tu_char* name;\n\tsize_t name_len;\n\n\tint conf_offset;\n\n\tngx_http_vod_create_loc_conf_t create_loc_conf;\n\n\tngx_http_vod_merge_loc_conf_t merge_loc_conf;\n\n\tint (*get_file_path_components)\n\t\t(ngx_str_t* uri);\n\n\tngx_int_t (*parse_uri_file_name)(\n\t\tngx_http_request_t *r,\n\t\tstruct ngx_http_vod_loc_conf_s *conf,\n\t\tu_char* start_pos,\n\t\tu_char* end_pos,\n\t\trequest_params_t* request_params,\n\t\tconst ngx_http_vod_request_t** request);\n\n\tngx_int_t (*parse_drm_info)(\n\t\tngx_http_vod_submodule_context_t* submodule_context,\n\t\tngx_str_t* drm_info,\n\t\tvoid** output);\n\n} ngx_http_vod_submodule_t;\n\n// globals\nextern const ngx_http_vod_submodule_t* submodules[];\n\n#endif // _NGX_HTTP_VOD_SUBMODULE_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_thumb.c",
          "type": "blob",
          "size": 8.75,
          "content": "#include <ngx_http.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/thumb/thumb_grabber.h\"\n#include \"vod/manifest_utils.h\"\n#include \"vod/parse_utils.h\"\n\n#define THUMB_TIMESCALE (1000)\n\n// macros\n#define skip_dash(start_pos, end_pos)\t\\\n\tif (start_pos >= end_pos)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn start_pos;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tif (*start_pos == '-')\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\tstart_pos++;\t\t\t\t\t\\\n\t\tif (start_pos >= end_pos)\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\\\n\t\t\treturn start_pos;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t}\n\nstatic const u_char jpg_file_ext[] = \".jpg\";\nstatic u_char jpeg_content_type[] = \"image/jpeg\";\n\nngx_int_t \nngx_http_vod_thumb_get_url(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tuint32_t sequences_mask,\n\tngx_str_t* result)\n{\n\tngx_http_vod_loc_conf_t* conf = submodule_context->conf;\n\tngx_http_request_t* r = submodule_context->r;\n\trequest_params_t* request_params = &submodule_context->request_params;\n\tngx_str_t request_params_str;\n\tngx_str_t base_url = ngx_null_string;\n\tvod_status_t rc;\n\tsize_t result_size;\n\tu_char* p;\n\n\t// get the base url\n\trc = ngx_http_vod_get_base_url(\n\t\tr,\n\t\tconf->segments_base_url != NULL ? conf->segments_base_url : conf->base_url,\n\t\t&r->uri,\n\t\t&base_url);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_thumb_get_url: ngx_http_vod_get_base_url failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\t// get the request params string\n\trc = manifest_utils_build_request_params_string(\n\t\t&submodule_context->request_context,\n\t\trequest_params->tracks_mask,\n\t\tINVALID_SEGMENT_INDEX,\n\t\tsequences_mask,\n\t\tNULL,\n\t\tNULL,\n\t\trequest_params->tracks_mask,\n\t\t&request_params_str);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_thumb_get_url: manifest_utils_build_request_params_string failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(r, rc);\n\t}\n\n\t// get the result size\n\tresult_size = base_url.len + conf->thumb.file_name_prefix.len + \n\t\t1 + VOD_INT64_LEN + request_params_str.len + sizeof(jpg_file_ext) - 1;\n\n\t// allocate the result buffer\n\tp = ngx_pnalloc(submodule_context->request_context.pool, result_size);\n\tif (p == NULL)\n\t{\n\t\tvod_log_debug0(VOD_LOG_DEBUG_LEVEL, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_thumb_get_url: ngx_pnalloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\n\tresult->data = p;\n\n\t// write the result\n\tif (base_url.len != 0)\n\t{\n\t\tp = vod_copy(p, base_url.data, base_url.len);\n\t}\n\n\tp = vod_copy(p, conf->thumb.file_name_prefix.data, conf->thumb.file_name_prefix.len);\n\tp = vod_sprintf(p, \"-%uL\", request_params->segment_time);\n\tp = vod_copy(p, request_params_str.data, request_params_str.len);\n\tp = vod_copy(p, jpg_file_ext, sizeof(jpg_file_ext) - 1);\n\n\tresult->len = p - result->data;\n\n\tif (result->len > result_size)\n\t{\n\t\tvod_log_error(VOD_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_thumb_get_url: result length %uz exceeded allocated length %uz\",\n\t\t\tresult->len, result_size);\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_UNEXPECTED);\n\t}\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_thumb_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n\trc = thumb_grabber_init_state(\n\t\t&submodule_context->request_context,\n\t\tsubmodule_context->media_set.filtered_tracks,\n\t\t&submodule_context->request_params,\n\t\tsubmodule_context->conf->thumb.accurate,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\tframe_processor_state);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_thumb_init_frame_processor: thumb_grabber_init_state failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\t*frame_processor = (ngx_http_vod_frame_processor_t)thumb_grabber_process;\n\n\tcontent_type->len = sizeof(jpeg_content_type) - 1;\n\tcontent_type->data = (u_char *)jpeg_content_type;\n\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t thumb_request = {\n\tREQUEST_FLAG_SINGLE_TRACK,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_THUMB,\n\tVOD_CODEC_FLAG(AVC) | VOD_CODEC_FLAG(HEVC) | VOD_CODEC_FLAG(VP8) | VOD_CODEC_FLAG(VP9) | VOD_CODEC_FLAG(AV1),\n\tTHUMB_TIMESCALE,\n\tNULL,\n\tngx_http_vod_thumb_init_frame_processor,\n};\n\nstatic void\nngx_http_vod_thumb_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_thumb_loc_conf_t *conf)\n{\n\tconf->accurate = NGX_CONF_UNSET;\n}\n\nstatic char *\nngx_http_vod_thumb_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_thumb_loc_conf_t *conf,\n\tngx_http_vod_thumb_loc_conf_t *prev)\n{\n\tngx_conf_merge_str_value(conf->file_name_prefix, prev->file_name_prefix, \"thumb\");\n\tngx_conf_merge_value(conf->accurate, prev->accurate, 1);\n\treturn NGX_CONF_OK;\n}\n\nstatic int \nngx_http_vod_thumb_get_file_path_components(ngx_str_t* uri)\n{\n\treturn 1;\n}\n\n#if (NGX_HAVE_LIB_SW_SCALE)\nstatic u_char*\nngx_http_vod_thumb_parse_dimensions(\n\tngx_http_request_t* r,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* result)\n{\n\tskip_dash(start_pos, end_pos);\n\n\t// width\n\tif (*start_pos == 'w')\n\t{\n\t\tstart_pos++;\t\t// skip the w\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &result->width);\n\t\tif (result->width <= 0)\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\t// height\n\tif (*start_pos == 'h')\n\t{\n\t\tstart_pos++;\t\t// skip the h\n\n\t\tstart_pos = parse_utils_extract_uint32_token(start_pos, end_pos, &result->height);\n\t\tif (result->height <= 0)\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\n\t\tskip_dash(start_pos, end_pos);\n\t}\n\n\treturn start_pos;\n}\n#endif // NGX_HAVE_LIB_SW_SCALE\n\nstatic ngx_int_t\nngx_http_vod_thumb_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tsegment_time_type_t time_type;\n\tint64_t time;\n\tngx_int_t rc;\n\n\tif (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->thumb.file_name_prefix, jpg_file_ext))\n\t{\n\t\tstart_pos += conf->thumb.file_name_prefix.len;\n\t\tend_pos -= (sizeof(jpg_file_ext) - 1);\n\t\t*request = &thumb_request;\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_thumb_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\t// parse the time\n\tif (start_pos < end_pos && *start_pos == '-')\n\t{\n\t\tstart_pos++;\t\t// skip the -\n\t}\n\n\ttime_type = SEGMENT_TIME_ABSOLUTE;\n\tif (start_pos < end_pos)\n\t{\n\t\tswitch (*start_pos)\n\t\t{\n\t\tcase '-':\n\t\t\tstart_pos++;\t\t// skip the -\n\t\t\ttime_type = SEGMENT_TIME_END_RELATIVE;\n\t\t\tbreak;\n\n\t\tcase '+':\n\t\t\tstart_pos++;\t\t// skip the +\n\t\t\ttime_type = SEGMENT_TIME_START_RELATIVE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start_pos >= end_pos || *start_pos < '0' || *start_pos > '9')\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_thumb_parse_uri_file_name: failed to parse thumbnail time\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\ttime = 0;\n\tdo \n\t{\n\t\ttime = time * 10 + *start_pos++ - '0';\n\t} while (start_pos < end_pos && *start_pos >= '0' && *start_pos <= '9');\n\n\tif (time == INVALID_SEGMENT_TIME)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_thumb_parse_uri_file_name: failed to parse thumbnail time\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n#if (NGX_HAVE_LIB_SW_SCALE)\n\tstart_pos = ngx_http_vod_thumb_parse_dimensions(r, start_pos, end_pos, request_params);\n\tif (start_pos == NULL)\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_thumb_parse_uri_file_name: failed to parse width/height\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n#endif // NGX_HAVE_LIB_SW_SCALE\n\n\t// parse the required tracks string\n\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, 0, request_params);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_thumb_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\t\n\trequest_params->segment_time = time;\n\trequest_params->segment_time_type = time_type;\n\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_AUDIO]);\n\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_SUBTITLE]);\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_thumb_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\"ngx_http_vod_thumb_parse_drm_info: unexpected - drm enabled on thumbnail request\");\n\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n}\n\nDEFINE_SUBMODULE(thumb);\n"
        },
        {
          "name": "ngx_http_vod_thumb.h",
          "type": "blob",
          "size": 0.373046875,
          "content": "#ifndef _NGX_HTTP_VOD_THUMB_H_INCLUDED_\n#define _NGX_HTTP_VOD_THUMB_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t thumb;\n\n// functions\nngx_int_t ngx_http_vod_thumb_get_url(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tuint32_t sequences_mask,\n\tngx_str_t* result);\n\n#endif // _NGX_HTTP_VOD_THUMB_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_thumb_commands.h",
          "type": "blob",
          "size": 0.580078125,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, thumb)\n\n\t{ ngx_string(\"vod_thumb_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_thumb_loc_conf_t, file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_thumb_accurate_positioning\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_flag_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_thumb_loc_conf_t, accurate),\n\tNULL },\n\n#undef BASE_OFFSET\n"
        },
        {
          "name": "ngx_http_vod_thumb_conf.h",
          "type": "blob",
          "size": 0.2802734375,
          "content": "#ifndef _NGX_HTTP_VOD_THUMB_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_THUMB_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n\n// typedefs\ntypedef struct\n{\n\tngx_str_t file_name_prefix;\n\tngx_flag_t accurate;\n} ngx_http_vod_thumb_loc_conf_t;\n\n#endif // _NGX_HTTP_VOD_THUMB_CONF_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_utils.c",
          "type": "blob",
          "size": 11.896484375,
          "content": "#include \"ngx_http_vod_utils.h\"\n\nstatic const ngx_int_t error_map[VOD_ERROR_LAST - VOD_ERROR_FIRST] = {\n\tNGX_HTTP_NOT_FOUND,\t\t\t\t// VOD_BAD_DATA\n\tNGX_HTTP_INTERNAL_SERVER_ERROR, // VOD_ALLOC_FAILED\n\tNGX_HTTP_INTERNAL_SERVER_ERROR, // VOD_UNEXPECTED\n\tNGX_HTTP_BAD_REQUEST,\t\t\t// VOD_BAD_REQUEST\n\tNGX_HTTP_SERVICE_UNAVAILABLE,\t// VOD_BAD_MAPPING\n\tNGX_HTTP_NOT_FOUND,\t\t\t\t// VOD_EXPIRED\n\tNGX_HTTP_NOT_FOUND,\t\t\t\t// VOD_NO_STREAMS\n\tNGX_HTTP_NOT_FOUND,\t\t\t\t// VOD_EMPTY_MAPPING\n\tNGX_HTTP_INTERNAL_SERVER_ERROR, // VOD_NOT_FOUND (not expected to reach top level)\n\tNGX_HTTP_INTERNAL_SERVER_ERROR, // VOD_REDIRECT (not expected to reach top level)\n};\n\nstatic ngx_str_t error_codes[VOD_ERROR_LAST - VOD_ERROR_FIRST] = {\n\tngx_string(\"BAD_DATA\"),\n\tngx_string(\"ALLOC_FAILED\"),\n\tngx_string(\"UNEXPECTED\"),\n\tngx_string(\"BAD_REQUEST\"),\n\tngx_string(\"BAD_MAPPING\"),\n\tngx_string(\"EXPIRED\"),\n\tngx_string(\"NO_STREAMS\"),\n\tngx_string(\"EMPTY_MAPPING\"),\n\tngx_string(\"UNEXPECTED\"),\n\tngx_string(\"UNEXPECTED\"),\n};\n\nstatic ngx_uint_t ngx_http_vod_status_index;\n\nstatic ngx_str_t empty_string = ngx_null_string;\n\nvoid ngx_http_vod_set_status_index(ngx_uint_t index)\n{\n\tngx_http_vod_status_index = index;\n}\n\nngx_int_t\nngx_http_vod_send_response(ngx_http_request_t *r, ngx_str_t *response, ngx_str_t* content_type)\n{\n\tngx_chain_t  out;\n\tngx_int_t    rc;\n\tngx_buf_t* b;\n\n\tif (!r->header_sent)\n\t{\n\t\t// set the content type\n\t\tr->headers_out.content_type = *content_type;\n\t\tr->headers_out.content_type_len = content_type->len;\n\n\t\t// set the status line\n\t\tr->headers_out.status = NGX_HTTP_OK;\n\t\tr->headers_out.content_length_n = response->len;\n\n\t\trc = ngx_http_set_etag(r);\n\t\tif (rc != NGX_OK)\n\t\t{\n\t\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_send_response: ngx_http_set_etag failed\");\n\t\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t\t// send the headers\n\t\trc = ngx_http_send_header(r);\n\t\tif (rc == NGX_ERROR || rc > NGX_OK)\n\t\t{\n\t\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_send_response: ngx_http_send_header failed %i\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (r->header_only || r->method == NGX_HTTP_HEAD)\n\t{\n\t\treturn NGX_OK;\n\t}\n\n\t// wrap the response with ngx_buf_t\n\tb = ngx_calloc_buf(r->pool);\n\tif (b == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_response: ngx_pcalloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\n\tb->pos = response->data;\n\tb->last = response->data + response->len;\n\tif (response->len > 0)\n\t{\n\t\tb->temporary = 1;\n\t}\n\tb->last_buf = 1;  // this is the last buffer in the buffer chain\n\n\t// attach the buffer to the chain\n\tout.buf = b;\n\tout.next = NULL;\n\n\t// send the buffer chain\n\trc = ngx_http_output_filter(r, &out);\n\tif (rc != NGX_OK && rc != NGX_AGAIN)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_send_response: ngx_http_output_filter failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\treturn NGX_OK;\n}\n\nngx_int_t \nngx_http_vod_status_to_ngx_error(\n\tngx_http_request_t* r, \n\tvod_status_t rc)\n{\n\tngx_http_variable_value_t *vv;\n\tngx_int_t index;\n\n\tif (rc < VOD_ERROR_FIRST || rc >= VOD_ERROR_LAST)\n\t{\n\t\treturn NGX_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\t\n\tindex = rc - VOD_ERROR_FIRST;\n\n\t// update the status variable\n\t// Note: need to explicitly set the value (instead of calculating it in get_handler)\n\t//\t\tso that it won't get lost in case of a redirect to an error page\n\tvv = &r->variables[ngx_http_vod_status_index];\n\n\tvv->valid = 1;\n\tvv->not_found = 0;\n\tvv->no_cacheable = 0;\n\n\tvv->data = error_codes[index].data;\n\tvv->len = error_codes[index].len;\n\n\treturn error_map[index];\n}\n\nngx_flag_t\nngx_http_vod_header_exists(ngx_http_request_t* r, ngx_str_t* searched_header)\n{\n\tngx_table_elt_t *header;\n\tngx_table_elt_t *last_header;\n\tngx_list_part_t *part;\n\n\tpart = &r->headers_in.headers.part;\n\n\twhile (part)\n\t{\n\t\theader = part->elts;\n\t\tlast_header = header + part->nelts;\n\t\tfor (; header < last_header; header++)\n\t\t{\n\t\t\tif (header->key.len == searched_header->len &&\n\t\t\t\tngx_strncasecmp(header->key.data, searched_header->data, searched_header->len) == 0)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tpart = part->next;\n\t}\n\treturn 0;\n}\n\nstatic void *\nngx_http_vod_memrchr(const u_char *s, int c, size_t n)\n{\n\tconst u_char *cp;\n\n\tfor (cp = s + n; cp > s; )\n\t{\n\t\tif (*(--cp) == (u_char)c)\n\t\t\treturn (void*)cp;\n\t}\n\treturn NULL;\n}\n\nngx_int_t\nngx_http_vod_get_base_url(\n\tngx_http_request_t* r,\n\tngx_http_complex_value_t* conf_base_url,\n\tngx_str_t* file_uri,\n\tngx_str_t* result)\n{\n\tngx_flag_t use_https;\n\tngx_str_t base_url;\n\tngx_str_t* host_name = NULL;\n\tsize_t uri_path_len;\n\tsize_t result_size;\n\tu_char* last_slash;\n\tu_char* p;\n\n\tif (conf_base_url != NULL)\n\t{\n\t\tif (ngx_http_complex_value(\n\t\t\tr,\n\t\t\tconf_base_url,\n\t\t\t&base_url) != NGX_OK)\n\t\t{\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tif (base_url.len == 0)\n\t\t{\n\t\t\t// conf base url evaluated to empty string, use relative URLs\n\t\t\treturn NGX_OK;\n\t\t}\n\n\t\tif (base_url.data[base_url.len - 1] == '/')\n\t\t{\n\t\t\tfile_uri = &empty_string;\n\t\t}\n\n\t\tresult_size = base_url.len;\n\t}\n\telse\n\t{\n\t\t// when the request has no host header (HTTP 1.0), use relative URLs\n\t\tif (r->headers_in.host == NULL)\n\t\t{\n\t\t\treturn NGX_OK;\n\t\t}\n\n\t\thost_name = &r->headers_in.host->value;\n\n\t\tresult_size = sizeof(\"https://\") - 1 + host_name->len;\n\t}\n\n\tif (file_uri->len)\n\t{\n\t\tlast_slash = ngx_http_vod_memrchr(file_uri->data, '/', file_uri->len);\n\t\tif (last_slash == NULL)\n\t\t{\n\t\t\tvod_log_error(VOD_LOG_ERR, r->connection->log, 0,\n\t\t\t\t\"ngx_http_vod_get_base_url: no slash found in uri %V\", file_uri);\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\turi_path_len = last_slash + 1 - file_uri->data;\n\t}\n\telse\n\t{\n\t\turi_path_len = 0;\n\t}\n\n\t// allocate the base url\n\tresult_size += uri_path_len + sizeof(\"/\");\n\tp = ngx_palloc(r->pool, result_size);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_get_base_url: ngx_palloc failed\");\n\t\treturn NGX_ERROR;\n\t}\n\n\t// build the url\n\tresult->data = p;\n\n\tif (conf_base_url != NULL)\n\t{\n\t\tp = vod_copy(p, base_url.data, base_url.len);\n\t}\n\telse\n\t{\n#if (NGX_HTTP_SSL)\n\t\tuse_https = (r->connection->ssl != NULL);\n#else\n\t\tuse_https = 0;\n#endif // NGX_HTTP_SSL\n\n\t\tif (use_https)\n\t\t{\n\t\t\tp = ngx_copy(p, \"https://\", sizeof(\"https://\") - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp = ngx_copy(p, \"http://\", sizeof(\"http://\") - 1);\n\t\t}\n\n\t\tp = ngx_copy(p, host_name->data, host_name->len);\n\t}\n\n\tp = ngx_copy(p, file_uri->data, uri_path_len);\n\t*p = '\\0';\n\n\tresult->len = p - result->data;\n\n\tif (result->len > result_size)\n\t{\n\t\tvod_log_error(VOD_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_get_base_url: result length %uz exceeded allocated length %uz\",\n\t\t\tresult->len, result_size);\n\t\treturn NGX_ERROR;\n\t}\n\n\treturn NGX_OK;\n}\n\nngx_int_t\nngx_http_vod_merge_string_parts(ngx_http_request_t* r, ngx_str_t* parts, uint32_t part_count, ngx_str_t* result)\n{\n\tngx_str_t* cur_part;\n\tngx_str_t* last_part = parts + part_count;\n\tu_char* p;\n\tsize_t len = 0;\n\n\tfor (cur_part = parts; cur_part < last_part; cur_part++)\n\t{\n\t\tlen += cur_part->len;\n\t}\n\n\tp = ngx_palloc(r->pool, len);\n\tif (p == NULL)\n\t{\n\t\tngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_merge_string_parts: ngx_palloc failed\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_ALLOC_FAILED);\n\t}\n\n\tresult->data = p;\n\n\tfor (cur_part = parts; cur_part < last_part; cur_part++)\n\t{\n\t\tp = ngx_copy(p, cur_part->data, cur_part->len);\n\t}\n\n\tresult->len = p - result->data;\n\n\treturn NGX_OK;\n}\n\n// Implemented according to nginx's ngx_http_range_parse, dropping multi range support\nngx_int_t\nngx_http_vod_range_parse(ngx_str_t* range, off_t content_length, off_t* out_start, off_t* out_end)\n{\n    u_char            *p;\n    off_t              start, end, cutoff, cutlim;\n    ngx_uint_t         suffix;\n\n    if (range->len < 7 ||\n        ngx_strncasecmp(range->data,\n        (u_char *) \"bytes=\", 6) != 0) {\n        return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n    }\n\n    p = range->data + 6;\n\n    cutoff = NGX_MAX_OFF_T_VALUE / 10;\n    cutlim = NGX_MAX_OFF_T_VALUE % 10;\n\n    start = 0;\n    end = 0;\n    suffix = 0;\n\n    while (*p == ' ') { p++; }\n\n    if (*p != '-') {\n        if (*p < '0' || *p > '9') {\n            return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n        }\n\n        while (*p >= '0' && *p <= '9') {\n            if (start >= cutoff && (start > cutoff || *p - '0' > cutlim)) {\n                return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n            }\n\n            start = start * 10 + *p++ - '0';\n        }\n\n        while (*p == ' ') { p++; }\n\n        if (*p++ != '-') {\n            return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n        }\n\n        while (*p == ' ') { p++; }\n\n        if (*p == '\\0') {\n            end = content_length;\n            goto found;\n        }\n\n    } else {\n        suffix = 1;\n        p++;\n    }\n\n    if (*p < '0' || *p > '9') {\n        return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n    }\n\n    while (*p >= '0' && *p <= '9') {\n        if (end >= cutoff && (end > cutoff || *p - '0' > cutlim)) {\n            return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n        }\n\n        end = end * 10 + *p++ - '0';\n    }\n\n    while (*p == ' ') { p++; }\n\n    if (*p != '\\0') {\n        return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n    }\n\n    if (suffix) {\n        start = content_length - end;\n        end = content_length - 1;\n    }\n\n    if (end >= content_length) {\n        end = content_length;\n    } else {\n        end++;\n    }\n\nfound:\n\n    if (start >= end) {\n        return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n    }\n\n    *out_start = start;\n    *out_end = end;\n\n    return NGX_OK;\n}\n\n#if (nginx_version >= 1023000)\nstatic ngx_table_elt_t *\nngx_http_vod_push_cache_control(ngx_http_request_t *r)\n{\n\tngx_table_elt_t  *cc;\n\n\tcc = r->headers_out.cache_control;\n\n\tif (cc == NULL) {\n\n\t\tcc = ngx_list_push(&r->headers_out.headers);\n\t\tif (cc == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr->headers_out.cache_control = cc;\n\t\tcc->next = NULL;\n\n\t\tcc->hash = 1;\n\t\tngx_str_set(&cc->key, \"Cache-Control\");\n\n\t} else {\n\t\tfor (cc = cc->next; cc; cc = cc->next) {\n\t\t\tcc->hash = 0;\n\t\t}\n\n\t\tcc = r->headers_out.cache_control;\n\t\tcc->next = NULL;\n\t}\n\n\treturn cc;\n}\n#else\nstatic ngx_table_elt_t *\nngx_http_vod_push_cache_control(ngx_http_request_t *r)\n{\n\tngx_uint_t        i;\n\tngx_table_elt_t  *cc, **ccp;\n\n\tccp = r->headers_out.cache_control.elts;\n\n\tif (ccp == NULL) {\n\n\t\tif (ngx_array_init(&r->headers_out.cache_control, r->pool,\n\t\t\t1, sizeof(ngx_table_elt_t *))\n\t\t\t!= NGX_OK)\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\n\t\tccp = ngx_array_push(&r->headers_out.cache_control);\n\t\tif (ccp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcc = ngx_list_push(&r->headers_out.headers);\n\t\tif (cc == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcc->hash = 1;\n\t\tngx_str_set(&cc->key, \"Cache-Control\");\n\t\t*ccp = cc;\n\n\t} else {\n\t\tfor (i = 1; i < r->headers_out.cache_control.nelts; i++) {\n\t\t\tccp[i]->hash = 0;\n\t\t}\n\n\t\tcc = ccp[0];\n\t}\n\n\treturn cc;\n}\n#endif\n\n// A run down version of ngx_http_set_expires\nngx_int_t\nngx_http_vod_set_expires(ngx_http_request_t *r, time_t expires_time)\n{\n\tsize_t            len;\n\ttime_t            now, max_age;\n\tngx_table_elt_t  *e, *cc;\n\n\te = r->headers_out.expires;\n\n\tif (e == NULL) {\n\n\t\te = ngx_list_push(&r->headers_out.headers);\n\t\tif (e == NULL) {\n\t\t\treturn NGX_ERROR;\n\t\t}\n\n\t\tr->headers_out.expires = e;\n#if (nginx_version >= 1023000)\n\t\te->next = NULL;\n#endif\n\n\t\te->hash = 1;\n\t\tngx_str_set(&e->key, \"Expires\");\n\t}\n\n\tlen = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\");\n\te->value.len = len - 1;\n\n\tcc = ngx_http_vod_push_cache_control(r);\n\tif (cc == NULL) {\n\t\te->hash = 0;\n\t\treturn NGX_ERROR;\n\t}\n\n\te->value.data = ngx_pnalloc(r->pool, len);\n\tif (e->value.data == NULL) {\n\t\te->hash = 0;\n\t\tcc->hash = 0;\n\t\treturn NGX_ERROR;\n\t}\n\n\tif (expires_time == 0) {\n\t\tngx_memcpy(e->value.data, ngx_cached_http_time.data,\n\t\t\tngx_cached_http_time.len + 1);\n\t\tngx_str_set(&cc->value, \"max-age=0\");\n\t\treturn NGX_OK;\n\t}\n\n\tnow = ngx_time();\n\n\tmax_age = expires_time;\n\texpires_time += now;\n\n\tngx_http_time(e->value.data, expires_time);\n\n\tif (max_age < 0) {\n\t\tngx_str_set(&cc->value, \"no-cache\");\n\t\treturn NGX_OK;\n\t}\n\n\tcc->value.data = ngx_pnalloc(r->pool,\n\t\tsizeof(\"max-age=\") + NGX_TIME_T_LEN + 1);\n\tif (cc->value.data == NULL) {\n\t\tcc->hash = 0;\n\t\treturn NGX_ERROR;\n\t}\n\n\tcc->value.len = ngx_sprintf(cc->value.data, \"max-age=%T\", max_age)\n\t\t- cc->value.data;\n\n\treturn NGX_OK;\n}\n"
        },
        {
          "name": "ngx_http_vod_utils.h",
          "type": "blob",
          "size": 1.0625,
          "content": "#ifndef _NGX_HTTP_VOD_UTILS_H_INCLUDED_\n#define _NGX_HTTP_VOD_UTILS_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n#include \"ngx_http_vod_request_parse.h\"\n#include \"ngx_http_vod_conf.h\"\n#include \"vod/common.h\"\n\n// functions\nvoid ngx_http_vod_set_status_index(ngx_uint_t index);\n\nngx_int_t ngx_http_vod_send_response(ngx_http_request_t *r, ngx_str_t *response, ngx_str_t* content_type);\n\nngx_int_t ngx_http_vod_status_to_ngx_error(\n\tngx_http_request_t* r,\n\tvod_status_t rc);\n\nngx_flag_t ngx_http_vod_header_exists(ngx_http_request_t* r, ngx_str_t* searched_header);\n\nngx_int_t ngx_http_vod_get_base_url(\n\tngx_http_request_t* r,\n\tngx_http_complex_value_t* conf_base_url,\n\tngx_str_t* file_uri,\n\tngx_str_t* result);\n\nngx_int_t ngx_http_vod_merge_string_parts(\n\tngx_http_request_t* r,\n\tngx_str_t* parts,\n\tuint32_t part_count,\n\tngx_str_t* result);\n\nngx_int_t ngx_http_vod_range_parse(\n\tngx_str_t* range, \n\toff_t content_length, \n\toff_t* out_start, \n\toff_t* out_end);\n\nngx_int_t ngx_http_vod_set_expires(\n\tngx_http_request_t *r,\n\ttime_t expires_time);\n\n#endif // _NGX_HTTP_VOD_UTILS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_volume_map.c",
          "type": "blob",
          "size": 3.8203125,
          "content": "#include <ngx_http.h>\n#include \"ngx_http_vod_submodule.h\"\n#include \"ngx_http_vod_utils.h\"\n#include \"vod/filters/volume_map.h\"\n\n#define VOLUME_MAP_TIMESCALE (1000)\n\nstatic const u_char csv_file_ext[] = \".csv\";\nstatic u_char csv_content_type[] = \"text/csv\";\nstatic ngx_str_t csv_header = ngx_string(\"pts,rms_level\\n\");\n\nstatic ngx_int_t\nngx_http_vod_volume_map_init_frame_processor(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tsegment_writer_t* segment_writer,\n\tngx_http_vod_frame_processor_t* frame_processor,\n\tvoid** frame_processor_state,\n\tngx_str_t* output_buffer,\n\tsize_t* response_size,\n\tngx_str_t* content_type)\n{\n\tvod_status_t rc;\n\n\trc = volume_map_writer_init(\n\t\t&submodule_context->request_context,\n\t\t&submodule_context->media_set,\n\t\tsubmodule_context->conf->volume_map.interval,\n\t\tsegment_writer->write_tail,\n\t\tsegment_writer->context,\n\t\tframe_processor_state);\n\tif (rc != VOD_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, submodule_context->request_context.log, 0,\n\t\t\t\"ngx_http_vod_volume_map_init_frame_processor: volume_map_writer_init failed %i\", rc);\n\t\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, rc);\n\t}\n\n\t*frame_processor = (ngx_http_vod_frame_processor_t)volume_map_writer_process;\n\n\t*output_buffer = csv_header;\n\tcontent_type->len = sizeof(csv_content_type) - 1;\n\tcontent_type->data = (u_char *)csv_content_type;\n\n\treturn NGX_OK;\n}\n\nstatic const ngx_http_vod_request_t volume_map_request = {\n\tREQUEST_FLAG_SINGLE_TRACK | REQUEST_FLAG_PARSE_ALL_CLIPS,\n\tPARSE_FLAG_FRAMES_ALL | PARSE_FLAG_EXTRA_DATA,\n\tREQUEST_CLASS_OTHER,\n\tVOD_CODEC_FLAG(AAC),\n\tVOLUME_MAP_TIMESCALE,\n\tNULL,\n\tngx_http_vod_volume_map_init_frame_processor,\n};\n\nstatic void\nngx_http_vod_volume_map_create_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_volume_map_loc_conf_t *conf)\n{\n\tconf->interval = NGX_CONF_UNSET_UINT;\n}\n\nstatic char *\nngx_http_vod_volume_map_merge_loc_conf(\n\tngx_conf_t *cf,\n\tngx_http_vod_loc_conf_t *base,\n\tngx_http_vod_volume_map_loc_conf_t *conf,\n\tngx_http_vod_volume_map_loc_conf_t *prev)\n{\n\tngx_conf_merge_str_value(conf->file_name_prefix, prev->file_name_prefix, \"volume_map\");\n\tngx_conf_merge_uint_value(conf->interval, prev->interval, 1000);\n\treturn NGX_CONF_OK;\n}\n\nstatic int \nngx_http_vod_volume_map_get_file_path_components(ngx_str_t* uri)\n{\n\treturn 1;\n}\n\nstatic ngx_int_t\nngx_http_vod_volume_map_parse_uri_file_name(\n\tngx_http_request_t *r,\n\tngx_http_vod_loc_conf_t *conf,\n\tu_char* start_pos,\n\tu_char* end_pos,\n\trequest_params_t* request_params,\n\tconst ngx_http_vod_request_t** request)\n{\n\tngx_int_t rc;\n\n\tif (ngx_http_vod_match_prefix_postfix(start_pos, end_pos, &conf->volume_map.file_name_prefix, csv_file_ext))\n\t{\n\t\tstart_pos += conf->volume_map.file_name_prefix.len;\n\t\tend_pos -= (sizeof(csv_file_ext) - 1);\n\t\t*request = &volume_map_request;\n\t}\n\telse\n\t{\n\t\tngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_volume_map_parse_uri_file_name: unidentified request\");\n\t\treturn ngx_http_vod_status_to_ngx_error(r, VOD_BAD_REQUEST);\n\t}\n\n\t// parse the required tracks string\n\trc = ngx_http_vod_parse_uri_file_name(r, start_pos, end_pos, 0, request_params);\n\tif (rc != NGX_OK)\n\t{\n\t\tngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n\t\t\t\"ngx_http_vod_volume_map_parse_uri_file_name: ngx_http_vod_parse_uri_file_name failed %i\", rc);\n\t\treturn rc;\n\t}\n\n\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_VIDEO]);\n\tvod_track_mask_reset_all_bits(request_params->tracks_mask[MEDIA_TYPE_SUBTITLE]);\n\n\treturn NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_vod_volume_map_parse_drm_info(\n\tngx_http_vod_submodule_context_t* submodule_context,\n\tngx_str_t* drm_info,\n\tvoid** output)\n{\n\tngx_log_error(NGX_LOG_ERR, submodule_context->request_context.log, 0,\n\t\t\"ngx_http_vod_volume_map_parse_drm_info: unexpected - drm enabled on volume map request\");\n\treturn ngx_http_vod_status_to_ngx_error(submodule_context->r, VOD_BAD_REQUEST);\n}\n\nDEFINE_SUBMODULE(volume_map);\n"
        },
        {
          "name": "ngx_http_vod_volume_map.h",
          "type": "blob",
          "size": 0.2431640625,
          "content": "#ifndef _NGX_HTTP_VOD_VOLUME_MAP_H_INCLUDED_\n#define _NGX_HTTP_VOD_VOLUME_MAP_H_INCLUDED_\n\n// includes\n#include \"ngx_http_vod_submodule.h\"\n\n// globals\nextern const ngx_http_vod_submodule_t volume_map;\n\n#endif // _NGX_HTTP_VOD_VOLUME_MAP_H_INCLUDED_\n"
        },
        {
          "name": "ngx_http_vod_volume_map_commands.h",
          "type": "blob",
          "size": 0.5908203125,
          "content": "#define BASE_OFFSET offsetof(ngx_http_vod_loc_conf_t, volume_map)\n\n\t{ ngx_string(\"vod_volume_map_file_name_prefix\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_str_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_volume_map_loc_conf_t, file_name_prefix),\n\tNULL },\n\n\t{ ngx_string(\"vod_volume_map_interval\"),\n\tNGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_CONF_TAKE1,\n\tngx_conf_set_num_slot,\n\tNGX_HTTP_LOC_CONF_OFFSET,\n\tBASE_OFFSET + offsetof(ngx_http_vod_volume_map_loc_conf_t, interval),\n\tNULL },\n\n#undef BASE_OFFSET"
        },
        {
          "name": "ngx_http_vod_volume_map_conf.h",
          "type": "blob",
          "size": 0.2978515625,
          "content": "#ifndef _NGX_HTTP_VOD_VOLUME_MAP_CONF_H_INCLUDED_\n#define _NGX_HTTP_VOD_VOLUME_MAP_CONF_H_INCLUDED_\n\n// includes\n#include <ngx_http.h>\n\n// typedefs\ntypedef struct\n{\n\tngx_str_t file_name_prefix;\n\tuintptr_t interval;\n} ngx_http_vod_volume_map_loc_conf_t;\n\n#endif // _NGX_HTTP_VOD_VOLUME_MAP_CONF_H_INCLUDED_"
        },
        {
          "name": "ngx_perf_counters.c",
          "type": "blob",
          "size": 1.62109375,
          "content": "#include \"ngx_perf_counters.h\"\n\n#define LOG_CONTEXT_FORMAT \" in perf counters \\\"%V\\\"%Z\"\n\nconst ngx_str_t perf_counters_open_tags[] = {\n#define PC(id, name) { sizeof(#name) - 1 + 4, (u_char*)(\"<\" #name \">\\r\\n\") },\n#include \"ngx_perf_counters_x.h\"\n#undef PC\n};\n\nconst ngx_str_t perf_counters_close_tags[] = {\n#define PC(id, name) { sizeof(#name) - 1 + 5, (u_char*)(\"</\" #name \">\\r\\n\") },\n#include \"ngx_perf_counters_x.h\"\n#undef PC\n};\n\nstatic ngx_int_t\nngx_perf_counters_init(ngx_shm_zone_t *shm_zone, void *data)\n{\n\tngx_perf_counters_t *state;\n\tngx_slab_pool_t *shpool;\n\tu_char* p;\n\n\tif (data)\n\t{\n\t\tshm_zone->data = data;\n\t\treturn NGX_OK;\n\t}\n\n\tshpool = (ngx_slab_pool_t *)shm_zone->shm.addr;\n\n\tif (shm_zone->shm.exists)\n\t{\n\t\tshm_zone->data = shpool->data;\n\t\treturn NGX_OK;\n\t}\n\n\t// start following the ngx_slab_pool_t that was allocated at the beginning of the chunk\n\tp = shm_zone->shm.addr + sizeof(ngx_slab_pool_t);\n\n\t// initialize the log context\n\tshpool->log_ctx = p;\n\tp = ngx_sprintf(shpool->log_ctx, LOG_CONTEXT_FORMAT, &shm_zone->shm.name);\n\n\t// allocate the perf couonters state\n\tp = ngx_align_ptr(p, sizeof(ngx_atomic_t));\n\tstate = (ngx_perf_counters_t*)p;\n\n\tngx_memzero(state, sizeof(*state));\n\n\tshpool->data = state;\n\n\treturn NGX_OK;\n}\n\nngx_shm_zone_t*\nngx_perf_counters_create_zone(ngx_conf_t *cf, ngx_str_t *name, void *tag)\n{\n\tngx_shm_zone_t* result;\n\tsize_t size;\n\n\tsize = sizeof(ngx_slab_pool_t) + sizeof(LOG_CONTEXT_FORMAT) + name->len + sizeof(ngx_atomic_t) + sizeof(ngx_perf_counters_t);\n\n\tresult = ngx_shared_memory_add(cf, name, size, tag);\n\tif (result == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tresult->init = ngx_perf_counters_init;\n\treturn result;\n}\n"
        },
        {
          "name": "ngx_perf_counters.h",
          "type": "blob",
          "size": 3.1689453125,
          "content": "#ifndef _NGX_PERF_COUNTERS_H_INCLUDED_\n#define _NGX_PERF_COUNTERS_H_INCLUDED_\n\n// includes\n#include <ngx_core.h>\n\n// comment the line below to remove the support for performance counters\n#define NGX_PERF_COUNTERS_ENABLED\n\n// get tick count\n#if (NGX_HAVE_CLOCK_GETTIME)\n\ntypedef struct timespec ngx_tick_count_t;\n\n#define ngx_get_tick_count(tp)  (void) clock_gettime(CLOCK_MONOTONIC, tp)\n\n#define ngx_tick_count_diff(start, end) \\\n\t(((end).tv_sec - (start).tv_sec) * 1000000 + ((end).tv_nsec - (start).tv_nsec) / 1000)\n\n#else\n\ntypedef struct timeval ngx_tick_count_t;\n\n#define ngx_get_tick_count(tp) ngx_gettimeofday(tp)\n\n#define ngx_tick_count_diff(start, end) \\\n\t(((end).tv_sec - (start).tv_sec) * 1000000 + ((end).tv_usec - (start).tv_usec))\n\t\n#endif // NGX_HAVE_CLOCK_GETTIME\n\n#ifdef NGX_PERF_COUNTERS_ENABLED\n\n// perf counters macros\n#define ngx_perf_counter_get_state(shm_zone)\t\t\t\t\t\t\\\n\t(shm_zone != NULL ? ((ngx_slab_pool_t *)shm_zone->shm.addr)->data : NULL)\n\n#define ngx_perf_counter_context(ctx)\t\t\t\t\t\t\t\t\\\n\tngx_perf_counter_context_t ctx\n\n#define ngx_perf_counter_start(ctx)\t\t\t\t\t\t\t\t\t\\\n\tngx_get_tick_count(&ctx.start);\n\n// Note: the calculation of 'max' has a race condition, the value can decrease since the condition\n//\t\tand the assignment are not performed atomically. however, the value of max is expected to\n//\t\tconverge quickly so that its updates will be performed less and less frequently, so it \n//\t\tshould be accurate enough.\n#define ngx_perf_counter_end(state, ctx, type)\t\t\t\t\t\t\\\n\tif (state != NULL)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tngx_tick_count_t __end;\t\t\t\t\t\t\t\t\t\t\\\n\t\tngx_atomic_t __delta;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tngx_get_tick_count(&__end);\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t__delta = ngx_tick_count_diff(ctx.start, __end);\t\t\t\\\n\t\t(void)ngx_atomic_fetch_add(&state->counters[type].sum, __delta);\t\\\n\t\t(void)ngx_atomic_fetch_add(&state->counters[type].count, 1);\t\t\\\n\t\tif (__delta > state->counters[type].max)\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tstruct timeval __tv;\t\t\t\t\t\t\t\t\t\\\n\t\t\tngx_gettimeofday(&__tv);\t\t\t\t\t\t\t\t\\\n\t\t\tstate->counters[type].max = __delta;\t\t\t\t\t\\\n\t\t\tstate->counters[type].max_time = __tv.tv_sec;\t\t\t\\\n\t\t\tstate->counters[type].max_pid = ngx_pid;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define ngx_perf_counter_copy(target, source)\ttarget = source\n\n// typedefs\nenum {\n#define PC(id, name) PC_##id,\n\t#include \"ngx_perf_counters_x.h\"\n#undef PC\n\n\tPC_COUNT\n};\n\ntypedef struct {\n\tngx_tick_count_t start;\n} ngx_perf_counter_context_t;\n\n#else\n\n// empty macros\n#define ngx_perf_counter_get_state(shm_zone) (NULL)\n#define ngx_perf_counter_context(ctx)\n#define ngx_perf_counter_start(ctx)\n#define ngx_perf_counter_end(state, ctx, type)\n#define ngx_perf_counter_copy(target, source)\n\n#define PC_COUNT (0)\n\n#endif // NGX_PERF_COUNTERS_ENABLED\n\n// typedefs\ntypedef struct {\n\tngx_atomic_t sum;\n\tngx_atomic_t count;\n\tngx_atomic_t max;\n\tngx_atomic_t max_time;\n\tngx_atomic_t max_pid;\n} ngx_perf_counter_t;\n\ntypedef struct {\n\tngx_perf_counter_t counters[PC_COUNT];\n} ngx_perf_counters_t;\n\n// globals\nextern const ngx_str_t perf_counters_open_tags[];\nextern const ngx_str_t perf_counters_close_tags[];\n\n// functions\nngx_shm_zone_t* ngx_perf_counters_create_zone(ngx_conf_t *cf, ngx_str_t *name, void *tag);\n\n#endif // _NGX_PERF_COUNTERS_H_INCLUDED_\n"
        },
        {
          "name": "ngx_perf_counters_x.h",
          "type": "blob",
          "size": 0.458984375,
          "content": "PC(FETCH_CACHE,\t\t\t\tfetch_cache)\nPC(STORE_CACHE,\t\t\t\tstore_cache)\nPC(MAP_PATH,\t\t\t\tmap_path)\nPC(PARSE_MEDIA_SET,\t\t\tparse_media_set)\nPC(GET_DRM_INFO,\t\t\tget_drm_info)\nPC(OPEN_FILE,\t\t\t\topen_file)\nPC(ASYNC_OPEN_FILE,\t\t\tasync_open_file)\nPC(READ_FILE,\t\t\t\tread_file)\nPC(ASYNC_READ_FILE,\t\t\tasync_read_file)\nPC(MEDIA_PARSE,\t\t\t\tmedia_parse)\nPC(BUILD_MANIFEST,\t\t\tbuild_manifest)\nPC(INIT_FRAME_PROCESS,\t\tinit_frame_processing)\nPC(PROCESS_FRAMES,\t\t\tprocess_frames)\nPC(TOTAL,\t\t\t\t\ttotal)\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "vod",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}