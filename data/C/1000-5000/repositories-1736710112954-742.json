{
  "metadata": {
    "timestamp": 1736710112954,
    "page": 742,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "luke-jr/bfgminer",
      "stars": 1857,
      "defaultBranch": "bfgminer",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6572265625,
          "content": "bfgminer\nbfgminer.exe\nbfgminer-rpc\nbfgminer-rpc.exe\nbitforce-firmware-flash\ncgminer\ncgminer.exe\nminerd\nminerd.exe\n*.o\n*.bin\n\nautom4te.cache\n.deps\n\nMakefile\nMakefile.in\nINSTALL\naclocal.m4\nconfigure\ndepcomp\nmissing\ninstall-sh\nstamp-h1\ncpuminer-config.h*\ncompile\nconfig.log\nconfig.status\nconfig.guess\nconfig.sub\n70-bfgminer.rules\n\nmingw32-config.cache\n\n*~\n*.orig\n*.rej\n*.swp\n*.kate-swp\n\next_deps\nconfig.h.in\nconfig.h\n\nccan*/libccan.a\nlib/arg-nonnull.h\nlib/c++defs.h\nlib/libgnu.a\nlib/signal.h\nlib/string.h\nlib/stdint.h\nlib/warn-on-use.h\niospeeds_local.h\nversion.h\nversion.h.new\n\nmkinstalldirs\n\n.pc\nbfgminer-bitforce.conf\n\nvgcore.*\ncore*\n*.log\n*.json\n*.patch\n*.zip\n*.tbz2\n*.bz2\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.3359375,
          "content": "[submodule \"libblkmaker\"]\n\tpath = libblkmaker\n\turl = git://github.com/bitcoin/libblkmaker.git\n[submodule \"ccan\"]\n\tpath = ccan-upstream\n\turl = git://git.ozlabs.org/~ccan/ccan\n[submodule \"libbase58\"]\n\tpath = libbase58\n\turl = git://github.com/luke-jr/libbase58.git\n[submodule \"knc-asic\"]\n\tpath = knc-asic\n\turl = git://github.com/KnCMiner/knc-asic\n"
        },
        {
          "name": ".travis.deps",
          "type": "blob",
          "size": 1.4775390625,
          "content": "test \"x$1\" = \"xI-am-okay-with-destroying-my-system\" || exit 1\nset -ex\n\n# Upgrading GCC triggers locale rebuild, so just do the one in use\nsudo rm /var/lib/locales/supported.d/*\necho $LANG UTF-8 | sudo tee /var/lib/locales/supported.d/en\n\necho -e 'deb http://ftp.us.debian.org/debian/ wheezy main\\ndeb http://security.debian.org/ wheezy/updates main' | sudo tee '/etc/apt/sources.list'\nsudo rm -r /etc/apt/sources.list.d\ncurl https://ftp-master.debian.org/keys/archive-key-7.0.asc | sudo apt-key add -\nsudo apt-get update -qq\nif [ -z \"$CROSS_BINPKGS\" ]; then\n\tDEV_DEPS='libcurl4-gnutls-dev libjansson-dev uthash-dev'\nfi\nsudo apt-get install -y build-essential autoconf automake libtool $DEV_DEPS $EXTRA_DEPS\n\nif [ -n \"$UBUNTU_DEPS\" ]; then\n\tcat <<\\EOF | sudo tee '/etc/apt/sources.list'\ndeb http://gb.archive.ubuntu.com/ubuntu/ trusty main restricted universe\ndeb http://gb.archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe\ndeb http://gb.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe\ndeb http://security.ubuntu.com/ubuntu trusty-security main restricted universe\nEOF\n\tsudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 3B4FE6ACC0B21F32\n\tsudo apt-get update -qq\n\tsudo apt-get install -y $UBUNTU_DEPS\nfi\n\nif [ -n \"$CROSS_BINPKGS\" ]; then\n\twget \"https://github.com/luke-jr/cross-binpkgs/archive/${CROSS_BINPKGS}.zip\"\n\tunzip \"${CROSS_BINPKGS}.zip\"\n\tfor f in \"cross-binpkgs-${CROSS_BINPKGS/+/-}\"/*/*; do\n\t\tsudo tar -C \"/usr/${CROSS_BINPKGS/+*/}/\" -xjvpf \"$f\"\n\tdone\nfi\n"
        },
        {
          "name": ".travis.script",
          "type": "blob",
          "size": 0.6474609375,
          "content": "test \"x$1\" = \"xI-am-okay-with-destroying-my-system\" || exit 1\nset -ex\n\nif [ -n \"$CROSS_BINPKGS\" ]; then\n\tCROSS_BINPKGS=\"${CROSS_BINPKGS/+*/}\"\n\tmyCC=\"${CROSS_BINPKGS}-gcc\"\n\tCC_ARGS=\"-I/usr/${CROSS_BINPKGS}/usr/include\"\n\texport LDFLAGS=\"-L/usr/${CROSS_BINPKGS}/usr/lib -L/usr/${CROSS_BINPKGS}/usr/bin\"\n\texport PKG_CONFIG_PATH=\"/usr/${CROSS_BINPKGS}/usr/lib/pkgconfig/\"\n\texport PKG_CONFIG_SYSROOT_DIR=\"/usr/${CROSS_BINPKGS}\"\nfi\n\nexport CC=\"$(which \"$myCC\") $CC_ARGS\"\n$CC --version\n\n./autogen.sh\n./configure $GLOBAL_CONFIGURE_ARGS $CONFIGURE_ARGS\nmake CFLAGS=\"$GLOBAL_CFLAGS $BUILD_CFLAGS\" $MAKEOPTS\nif [ -z \"$CROSS_BINPKGS\" ]; then\n\tmake check\n\tsudo make install\nfi\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 14.68359375,
          "content": "os: linux\nlanguage: c\ncompiler: gcc\nenv:\n  global:\n    - MAKEOPTS=-j3\n    - GLOBAL_CFLAGS='-O2 -Wall'\n    - GLOBAL_CONFIGURE_ARGS='--prefix=/usr'\nmatrix:\n  fast_finish: true\n  include:\n    - compiler: \": Full GCC\"\n      # Upgrade GCC to avoid false warnings; build the full project with -Werror\n      env: myCC='gcc' UBUNTU_DEPS='gcc libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' BUILD_CFLAGS='-Werror' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-system-libbase58 --enable-tool'\n    - compiler: \": Full LLVM\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' BUILD_CFLAGS='-Werror' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-system-libbase58 --enable-tool'\n    - compiler: \": pkgconf\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev pkgconf' EXTRA_DEPS='libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' BUILD_CFLAGS='-Werror' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-system-libbase58 --enable-tool'\n    - compiler: \": MinGW64 ncurses\"\n      env: UBUNTU_DEPS='gcc-mingw-w64-x86-64' EXTRA_DEPS='pkg-config yasm' CROSS_BINPKGS='x86_64-w64-mingw32+ncurses' BUILD_CFLAGS='-Werror' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-system-libbase58 --host=x86_64-w64-mingw32 --disable-knc --disable-bfsb --disable-jingtian --disable-metabank --disable-minergate --disable-titan --disable-kncasic --disable-minion'\n    - compiler: \": MinGW64 pdcurses\"\n      env: UBUNTU_DEPS='gcc-mingw-w64-x86-64' EXTRA_DEPS='pkg-config yasm' CROSS_BINPKGS='x86_64-w64-mingw32' BUILD_CFLAGS='-Werror' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-system-libbase58 --host=x86_64-w64-mingw32 --disable-knc --disable-bfsb --disable-jingtian --disable-metabank --disable-minergate --disable-titan --disable-kncasic --disable-minion'\n    - compiler: \": Standard\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-keccak --enable-scrypt'\n    - compiler: \": Std SHA2\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS=''\n    - compiler: \": Std Keccak\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-keccak'\n    - compiler: \": Std scrypt\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-scrypt'\n    - compiler: \": No hidapi\"\n      env: myCC='clang' UBUNTU_DEPS='linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt'\n    - compiler: \": No VFIO\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-vfio'\n    - compiler: \": No UIO\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-uio'\n    - compiler: \": No VFIO/UIO\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-uio --without-vfio'\n    - compiler: \": Non-wide ncurses\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncurses5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --with-curses=ncurses5'\n    - compiler: \": No curses\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-curses'\n    - compiler: \": No libudev\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-libudev'\n    - compiler: \": No libusb\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-libusb'\n    - compiler: \": No libevent\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libmicrohttpd-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-libevent'\n    - compiler: \": No libmicrohttpd\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libi2c-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-libmicrohttpd'\n    - compiler: \": No libi2c-dev\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev yasm libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --disable-knc --disable-titan --disable-kncasic'\n    - compiler: \": No yasm\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev libsensors4-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt'\n    - compiler: \": No libsensors\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev libudev-dev libusb-1.0-0-dev libevent-dev libmicrohttpd-dev libi2c-dev yasm' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-sensors'\n    - compiler: \": No opt deps\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-uio --without-vfio --without-sensors --without-libmicrohttpd --without-libevent --without-libusb --without-curses --without-libudev --disable-knc --disable-titan --disable-kncasic'\n    - compiler: \": Only ncurses\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--enable-other-drivers --enable-keccak --enable-scrypt --without-uio --without-vfio --without-sensors --without-libmicrohttpd --without-libevent --without-libusb --without-libudev --disable-knc --disable-titan --disable-kncasic'\n    - compiler: \": Only CPU\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev yasm' CONFIGURE_ARGS='--disable-other-drivers --enable-cpumining --enable-keccak --enable-scrypt'\n    - compiler: \": Only OpenCL\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libsensors4-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-opencl --enable-keccak --enable-scrypt'\n    - compiler: \": OpenCL w/o ADL\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libsensors4-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-opencl --enable-keccak --enable-scrypt --disable-adl'\n    - compiler: \": OpenCL w/o sensors\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-opencl --enable-keccak --enable-scrypt'\n    - compiler: \": OpenCL w/o ADL or sensors\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-opencl --enable-keccak --enable-scrypt --disable-adl'\n    - compiler: \": Only alchemist\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-scrypt --enable-alchemist'\n    - compiler: \": Only bitforce\"\n      env: myCC='clang' UBUNTU_DEPS='linux-libc-dev' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitforce'\n    - compiler: \": Only bitmain\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitmain'\n    - compiler: \": Only icarus\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-icarus'\n    - compiler: \": Only dualminer\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-icarus --enable-dualminer --enable-scrypt'\n    - compiler: \": Only zeusminer\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-icarus --enable-zeusminer --enable-scrypt'\n    - compiler: \": Only gridseed\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-gridseed --enable-scrypt'\n    - compiler: \": Only avalon\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-avalon'\n    - compiler: \": Only avalonmm\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-avalonmm'\n    - compiler: \": Only knc\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libi2c-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-knc'\n    - compiler: \": Only kncasic\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libi2c-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-scrypt --enable-kncasic'\n    - compiler: \": Only modminer\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-modminer'\n    - compiler: \": Only cointerra\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-cointerra'\n    - compiler: \": Only klondike\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-klondike'\n    - compiler: \": Only titan\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libi2c-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-scrypt --enable-titan'\n    - compiler: \": Only x6500\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-x6500'\n    - compiler: \": Only ztex\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-ztex'\n    - compiler: \": Only bifury\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bifury'\n    - compiler: \": Only bitfury\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury'\n    - compiler: \": Only bfsb\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-bfsb'\n    - compiler: \": Only bigpic\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-bigpic'\n    - compiler: \": Only bfx\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-bfx'\n    - compiler: \": Only drillbit\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-drillbit'\n    - compiler: \": Only twinfury\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-twinfury'\n    - compiler: \": Only littlefury\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-littlefury'\n    - compiler: \": Only nanofury\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-nanofury'\n    - compiler: \": Only hashbuster\"\n      env: myCC='clang' UBUNTU_DEPS='libhidapi-dev' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-hashbuster'\n    - compiler: \": Only hashbusterusb\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev libusb-1.0-0-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-hashbusterusb'\n    - compiler: \": Only hashfast\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-hashfast'\n    - compiler: \": Only jingtian\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-jingtian'\n    - compiler: \": Only metabank\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-bitfury --enable-metabank'\n    - compiler: \": Only minergate\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-minergate'\n    - compiler: \": Only minion\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-minion'\n    - compiler: \": Only rockminer\"\n      env: myCC='clang' EXTRA_DEPS='pkg-config libncursesw5-dev' CONFIGURE_ARGS='--disable-other-drivers --enable-rockminer'\n  exclude:\n    - compiler: gcc\ninstall:\n  - bash .travis.deps I-am-okay-with-destroying-my-system\nscript:\n  - bash .travis.script I-am-okay-with-destroying-my-system\n"
        },
        {
          "name": "70-bfgminer.rules.in",
          "type": "blob",
          "size": 3.716796875,
          "content": "# do not edit this file, it will be overwritten on update\n\nACTION==\"add\", SUBSYSTEMS==\"usb\", GOTO=\"bfgminer_start\"\nGOTO=\"bfgminer_end\"\nLABEL=\"bfgminer_start\"\n\n@USE_BIFURY_TRUE@ENV{ID_MODEL}==\"*bi•fury*\", GOTO=\"bfgminer_add\"\n@USE_BIGPIC_TRUE@ENV{ID_MODEL}==\"*Bitfury*BF1*\", GOTO=\"bfgminer_add\"\n@USE_BITFORCE_TRUE@ENV{ID_MODEL}==\"*BitFORCE*SHA256*\", GOTO=\"bfgminer_add\"\n@USE_COINTERRA_TRUE@ENV{ID_MODEL}==\"*GoldStrike*\", GOTO=\"bfgminer_add\"\n@USE_DRILLBIT_TRUE@ENV{manufacturer}==\"*Drillbit*\", GOTO=\"bfgminer_add\"\n@USE_ICARUS_TRUE@ENV{ID_MODEL}==\"*Antminer*\", GOTO=\"bfgminer_add\"\n@USE_ICARUS_TRUE@ENV{ID_MODEL}==\"*Cairnsmore1*\", GOTO=\"bfgminer_add\"\n@USE_ICARUS_TRUE@ENV{ID_MODEL}==\"*Compac*Bitcoin*\", GOTO=\"bfgminer_add\"\n@USE_ICARUS_TRUE@ENV{ID_MODEL}==\"*Block*Erupter*\", GOTO=\"bfgminer_add\"\n@USE_HASHBUSTER_TRUE@ENV{ID_MODEL}==\"*HashBuster*\", GOTO=\"bfgminer_add\"\n@USE_HASHBUSTERUSB_TRUE@ENV{ID_MODEL}==\"*HashBuster*\", GOTO=\"bfgminer_add\"\n@USE_HASHFAST_TRUE@ENV{idVendor}==\"297c\", ENV{manufacturer}==\"*HashFast*\", GOTO=\"bfgminer_add\"\n@USE_HASHFAST_TRUE@ENV{ID_MODEL}==\"*GoldenNonce*\", GOTO=\"bfgminer_add\"\n@USE_KLONDIKE_TRUE@ENV{idVendor}==\"04d8\", ENV{idProduct}==\"f60a\", ENV{manufacturer}==\"*Klondike*\", GOTO=\"bfgminer_add\"\n@USE_KLONDIKE_TRUE@ENV{idVendor}==\"fa05\", ENV{idProduct}==\"0001\", ENV{manufacturer}==\"*HashBuster*\", GOTO=\"bfgminer_add\"\n@USE_LITTLEFURY_TRUE@ENV{ID_MODEL}==\"*LittleFury*\", GOTO=\"bfgminer_add\"\n@USE_MODMINER_TRUE@ENV{ID_MODEL}==\"*ModMiner*\", GOTO=\"bfgminer_add\"\n@USE_NANOFURY_TRUE@ENV{idVendor}==\"04d8\", ENV{idProduct}==\"00de\", ENV{ID_MODEL}==\"*NanoFury*\", GOTO=\"bfgminer_add\"\n@USE_ROCKMINER_TRUE@ENV{ID_MODEL}==\"*R-BOX miner*\", GOTO=\"bfgminer_add\"\n@USE_ROCKMINER_TRUE@ENV{ID_MODEL}==\"*RX-BOX miner*\", GOTO=\"bfgminer_add\"\n@USE_TWINFURY_TRUE@ENV{ID_MODEL}==\"*Twinfury*\", GOTO=\"bfgminer_add\"\n@USE_X6500_TRUE@ENV{idVendor}==\"0403\", ENV{idProduct}==\"6001\", ENV{ID_MODEL}==\"*X6500 FPGA Miner*\", GOTO=\"bfgminer_add\"\n@USE_ZTEX_TRUE@ENV{ID_MODEL}==\"*btcminer for ZTEX*\", GOTO=\"bfgminer_add\"\n\n# The below are broad udev rules that may match devices other than the miners expected.\n# You can uncomment them with the --enable-broad-udevrules configure option.\n\n# Avalon1\n@BROAD_UDEVRULES_TRUE@@USE_AVALON_TRUE@ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6001\", GOTO=\"bfgminer_add\"\n# AvalonMM\n@BROAD_UDEVRULES_TRUE@@USE_AVALONMM_TRUE@ATTRS{idVendor}==\"067b\", ATTRS{idProduct}==\"2303\", GOTO=\"bfgminer_add\"\n# DualMiner\n@BROAD_UDEVRULES_TRUE@@USE_DUALMINER_TRUE@ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6010\", GOTO=\"bfgminer_add\"\n# GridSeed\n@BROAD_UDEVRULES_TRUE@@USE_GRIDSEED_TRUE@ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"5740\", GOTO=\"bfgminer_add\"\n# Icarus\n@BROAD_UDEVRULES_TRUE@@USE_ICARUS_TRUE@ATTRS{idVendor}==\"067b\", ATTRS{idProduct}==\"2303\", GOTO=\"bfgminer_add\"\n# Cairnsmore1\n@BROAD_UDEVRULES_TRUE@@USE_ICARUS_TRUE@ATTRS{idVendor}==\"067b\", ATTRS{idProduct}==\"0230\", GOTO=\"bfgminer_add\"\n@BROAD_UDEVRULES_TRUE@@USE_ICARUS_TRUE@ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"8350\", GOTO=\"bfgminer_add\"\n# Block Erupter and Antminer U*\n@BROAD_UDEVRULES_TRUE@@USE_ICARUS_TRUE@ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", GOTO=\"bfgminer_add\"\n# ZeusMiner\n@BROAD_UDEVRULES_TRUE@@USE_ZEUSMINER_TRUE@ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", GOTO=\"bfgminer_add\"\n# Possibly unprogrammed ZTEX\n@BROAD_UDEVRULES_TRUE@@USE_ZTEX_TRUE@ATTRS{idVendor}==\"221a\", ATTRS{idProduct}==\"0100\", GOTO=\"bfgminer_add\"\n# BFx2\n@BROAD_UDEVRULES_TRUE@@USE_BFX_TRUE@ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6014\", GOTO=\"bfgminer_add\"\n# RockMiner\n@BROAD_UDEVRULES_TRUE@@USE_ROCKMINER_TRUE@ATTRS{idVendor}==\"10c4\", ATTRS{idProduct}==\"ea60\", GOTO=\"bfgminer_add\"\n\nGOTO=\"bfgminer_end\"\n\nLABEL=\"bfgminer_add\"\n\n@USE_UDEVRULES_GROUP_TRUE@GROUP=\"@UDEVRULES_GROUP@\"\nENV{ID_MM_DEVICE_IGNORE}=\"1\"\n\nLABEL=\"bfgminer_end\"\n"
        },
        {
          "name": "ADL",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 2.9326171875,
          "content": "CURRENT MAINTAINERS:\n\nLuke Dashjr <luke-jr+bfgminer@utopios.org> 1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh\nJohn Stefanopoulos <jstefanop@mac.com>\n\nDebian packaging: Dmitry Smirnov <onlyjob@member.fsf.org>\n\n---\n\nPAST MAINTAINERS:\n\nAnatoly Legkodymov <legko777@fastmail.fm>\nAndreas Auer <aauer1@gmail.com>\nAndrew Smith <kan0i@kano-kun.net> 1Jjk2LmktEQKnv8r2cZ9MvLiZwZ9gxabKm\nCon Kolivas <kernel@kolivas.org> 15qSxP1SQcUX3o4nhkfdbgyoWEFMomJ4rZ\nJeff Garzik <jgarzik@pobox.com>\nNate Woolls <nwoolls@gmail.com> 1JnZoFeCVYJgaKbKwDUxSkTZWWpBmwWTgV\nNelisky <nelisky.btc@gmail.com>\nPelle Nilsson <per.nilsson@xelmo.com>\nVitalii Demianets <vitalii@orsoc.se>\nXiangfu <xiangfu@openmobilefree.net>\n\n---\n\nCONTRIBUTORS:\n\nAbracadabra <hocuscapocus@gmail.com>\nanajavi\nAndrew McDonald <andrew@mcdonald.org.uk>\nAng Iongchun <angiongchun@gmail.com>\nArtForz\nBFL_Jonathon <jonathon@butterflylabs.com>\nBitfury\nblinkier <blinkiest@gmail.com>\nbluemurder <bluemurder@engineer.com>\ncapa66 <capa66@x204.com>\nChristian Berendt <berendt@b1-systems.de>\nColin Percival\nDaniel Mack <daniel@caiaq.de>\nDenis Ahrens <denis@h3q.com>\nDmitriy Korniychuk <dmitriy@korniychuk.org.ua>\nDmitry Sorokin <asfins@gmail.com>\nDualminer Team <dualminer@broadeng.net>\nfleger <florian6.leger@laposte.net>\nGlenn Francis Murray <glenn@gfm.cc>\ngluk <glukolog@mail.ru>\nGraeme Humphries <graeme@sudo.ca>\nGridSeed Team <develop@gridseed.com>\nHashBuster team <contact@hashbuster.com>\nHuang Le <4tarhl@gmail.com>\nIsidoro Ghezzi <isidoro.ghezzi@icloud.com>\nJames Hilliard <james.hilliard1@gmail.com>\nJames Morris <jmorris@intercode.com.au>\nJason Hughes <wizkid057@gmail.com>\nJason Snell <abysss@gmail.com>\nJean-Luc Cooke <jlcooke@certainkey.com>\nJonathan Lynch <jonathan.lynch@intel.com>\nJosh Lehan <krellan@krellan.net>\nKiyoaki Matsugae <matsugae.kiyoaki@gmail.com>\nLauri Kasanen <curaga@operamail.com>\nLingchao Xu <lingchao.xu@bitmaintech.com>\nLuke Mitchell <Luke.Mitchell.2011@my.bristol.ac.uk>\nMark Crichton <crichton@gmail.com>\nMartin Danielsen <kalroth@gmail.com>\nMichael Kedzierski <michael@kedzierski.id.au>\nMr O <notanatheist@gmail.com>\nmtrlt\nNeil Kettle <neil@digit-labs.org>\nNico Oelgart <nico@nicoswd.com>\nOlivier Gay <olivier.gay@a3.epfl.ch>\nPaul Sheppard <shepsoft@gmail.com>\nPaul Wouters <pwouters@redhat.com>\nPavel Semjanov <pavel@semjanov.com>\nPeter Stuge <peter@stuge.se>\nPhateus <Jesse.Moll@gmail.com>\nPhilip Kaufmann <phil.kaufmann@t-online.de>\npontus <liquidpontus@yahoo.se>\npooler <pooler@litecoinpool.org>\nRaulo <p987341@gmail.com>\nRed_Wolf_2 <redwolf@wolfnexus.net>\nRicardo Iván Vieitez Parra <cop3504@memoryplate.com>\nRonny Van Keer\nRusty Russell <rusty@rustcorp.com.au>\nСерёга <netswalker@yandex.ru>\nslax0r <frcole@gmail.com>\nTeemu Suikki <zuikkis@gmail.com>\nThorsten Gilling <tgilling@web.de>\nTim Bartletts <github@tim.bartletts.id.au>\nTydus <Tydus@Tydus.org>\nUfasoft <support@ufasoft.com>\nVladimir Strinski <vstrinski@nanofury.com>\nZefir Kurtisi <zefir.kurtisi@gmail.com>\nZeusMiner Team <cs@zeusminer.com>\nZnort 987 <znort987@yahoo.com>\n"
        },
        {
          "name": "CL",
          "type": "tree",
          "content": null
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 34.3232421875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 0.15625,
          "content": "See git repository ('git log') for full changelog.\n\nGit repo can be found at:\nhttps://github.com/luke-jr/bfgminer\n\nThe NEWS file contains most of the changelog\n"
        },
        {
          "name": "HACKING",
          "type": "blob",
          "size": 6.951171875,
          "content": "Driver API\n==========\n\nNOTE: This API is subject to change. It is recommended that you submit your\ndriver, even if obscure, to the mainline BFGMiner codebase so that it will be\nupdated when the API changes.\n\nBFGMiner defines 3 different units that drivers can use:\n- \"Device\" is a logical unit used for mining. It is represented by its first\n  processor's `struct cgpu_info`. Example: ButterFly Labs MiniRig SC.\n- \"Processor\" is a logical work processing unit. It is represented by a `struct\n  cgpu_info` and one or more `struct thr_info`. Example: a single board within\n  ButterFly Labs MiniRig SC.\n- \"Thread\" is a sequence of instructions and stack that manages hashing on one\n  or more Processors within a single Device. It is represented by a `struct\n  thr_info`.\n\nIt should be noted that while every Processor has a `struct thr_info`, this may\nnot represent the same Thread which is managing hashing on the Processor.\nInstead, this `struct thr_info` is only used to store status information needed\nfor the Processor, and is maintained by the managing Thread in addition to its\nown `struct thr_info`. New drivers are encouraged to use an asynchronous model\nto manage as many Processors as possible within a single Thread.\n\nstruct device_drv basics\n------------------------\n\nEvery driver defines a `struct device_drv`. The `dname` field contains a\nshort name of the driver. This should consist only of lowercase alphabetic\ncharacters, and be the same name used in the source file: driver-foobar.c\ndefines `dname` \"foobar\". The `name` field contains a three-letter abbreviation\nfor the device, used in the representation of devices. For example, `dname`\n\"FOO\" would result in devices represented as \"FOO 0\", \"FOO 1\", etc and\nprocessors represented as \"FOO 0a\", \"FOO 0b\", etc.\n\nDrivers must define a function `drv_detect`, which is run at startup to detect\ndevices. For each device (note: NOT each processor), it should allocate a\n`struct cgpu_info`, set some basic parameters on it, and call the `add_cgpu`\nfunction with it as an argument. Various values you can initialize are:\n\t.drv         This MUST be set to your driver's `struct device_drv`!\n\t.deven       Should be set to DEV_ENABLED\n\t.procs       Number of Processors for this device\n\t.threads     Number of threads your device needs - should be either a\n\t             multiple of .procs (threads will be allocated to each\n\t             Processor), or one (a single thread will be allocated only to\n\t             the Device, to manage all Processors)\n\t.name        Null-terminated name of the device itself\n`drv_detect` should return the total number of devices created. It should leave\nthe device in an unused state, as the user may opt to delete it outright.\n\nThreads\n-------\n\nThe first interaction BFGMiner will have with a device is by calling the\ndriver's `thread_prepare` function for each Thread. This occurs while BFGMiner\nis still in a single-threaded state, before any Threads have actually started\nrunning independently. It should do only the minimal initialization necessary\nto proceed, and return true iff successful.\n\nOnce all the Threads are setup, BFGMiner starts them off by calling the\n`thread_init` function. This should do all initialization that can occur in\nparallel with other Threads.\n\nThe driver should specify a `minerloop` to use. For the purposes of this\ndocument, it is assumed you will be using `minerloop_async`. Please note that\nthe default is currently `minerloop_scanhash`, and much of the documentation\nhere will NOT work with this `minerloop`.\n\nProcessors\n----------\n\nProcessors work with `struct work` objects, which each represent a block header\nto find a solution for. Before your driver sees a `struct work`, it will be\npassed to the function `prepare_work` with pointers to the Processor `struct\nthr_info` and the `struct work` as arguments. Most drivers do not need to do\nanything at this stage, so feel free to omit the `prepare_work` function.\n\nFor each job, the `job_prepare` function is called in advance, with three\narguments: Processor `struct thr_info *`, `struct work *`, and a `uint64_t`\nlimiting how many nonces to check (starting from `work->blk.nonce`). Unless you\nimplement a `can_limit_work` function, you will always receive a full nonce\nrange from 0 to 0xffffffff. `job_prepare` increments `work->blk.nonce` to the\nlast nonce the processor will be attempting and returns true when successful.\nPlease note this will be called while the previous job is still executing.\n\nWhen it is time to actually start the new job, the `job_start` function will be\ncalled. This is given the Processor `struct thr_info *` as its only argument,\nand should start the job most recently prepared with `job_prepare`. Note that\nit is possible for `job_prepare` to be called for a job that never starts\n(another `job_prepare` may be executed to override the previous one instead).\n`job_start` must call `mt_job_transition` as soon as the actual switchover to\nthe new job takes place, and must call `job_start_complete` when successful;\nin case of a failure, it should call `job_start_abort` instead. `job_start`\nmust set `thr->tv_morework` to the time the device expects to need its next\nwork item. It is generally advisable to set this a bit early to ensure any\ndelays do not make it late. `job_start` is expected to always succeed and does\nnot have a return value.\n\nImmediately before `job_start` is called to change from one job to the next,\n`job_get_results` will be called to fetch any volatile results from the\nprevious job. It is provided the Processor's `struct thr_info *` and the\ncurrently executing job's `struct work *`. It should ONLY fetch the raw data\nfor the results, and not spend any time processing or submitting it. If\n`job_get_results` is defined for your driver, it must (directly or indirectly)\nensure `job_results_fetched` is called when complete (including the case of\nfailure). After the new job has been started, your driver's\n`job_process_results` function will be called to complete the submission of\nthese results with the same arguments, plus a bool to tell you whether the\nprocessor is being stopped. If it is, your driver must call `mt_disable_start`\nwhen it has successfully stopped hashing.\n\nDrivers may define a `poll` function. If this is defined, `thr->tv_poll` must\nalways be set to a valid time to next execute it, for each Processor.\n\nWhenever a solution is found (at any point), the function `submit_nonce` should\nbe called, passing the Processor `struct thr_info *`, `struct work *`, and\nnonce as arguments. If the solution is invalid (any of the final 32 bits of the\nhash are nonzero), it will be recorded as a hardware error and your driver's\n`hw_error` function (if one is defined) will be called.\n\nAs often as results are processed, your driver should call the `hashes_done`\nfunction with a number of arguments: Processor `struct thr_info *`, count of\nhashes completed (including calls to `submit_nonce`), a `struct timeval *`\nthat tells how long it took to find these hashes (usually time since the last\ncall to `hashes_done`, and a `uint32_t *` which should usually be NULL.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.0986328125,
          "content": "BFGMiner is available under the terms of the GNU Public License version 3.\n\nSee COPYING for details.\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 9.0849609375,
          "content": "# Copyright 2012-2014 Luke Dashjr\n# Copyright 2012 zefir\n# Copyright 2011-2013 Con Kolivas\n# Copyright 2013 James Z.M. Gao\n# Copyright 2013-2014 Nate Woolls\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the Free\n# Software Foundation; either version 3 of the License, or (at your option)\n# any later version.  See COPYING for more details.\n\nACLOCAL_AMFLAGS = -I m4\n\nEXTRA_DIST\t= \\\n\tm4/gnulib-cache.m4 \\\n\tlinux-usb-bfgminer \\\n\twindows-build.txt\n\ndist_doc_DATA = \\\n\t\t  AUTHORS COPYING HACKING NEWS README \\\n\t\t  example.conf \\\n\t\t  README.RPC\n\nrpcexamplesdir = $(docdir)/rpc-examples\ndist_rpcexamples_DATA = \\\n\t\t  api-example.php miner.php \\\n\t\t  api-example.c \\\n                  api-example.py\n\nSUBDIRS\t\t= lib ccan.bfg\n\n# Without a redirected rule, code depending on different lib/*.h files may try to build dependencies of that in parallel, which can fail\nlib/%: lib_directory\n\t@test -e $@\nlib_directory:\n\t$(MAKE) -C lib\nccan.bfg/libccan.a:\n\t$(MAKE) -C ccan.bfg $*\n\nINCLUDES\t= -fno-strict-aliasing\n\nbin_PROGRAMS\t= bfgminer\n\nsbin_SCRIPTS =\n\nif HAVE_WINDOWS\nelse\nbin_SCRIPTS = start-bfgminer.sh\nendif\n\n# first, our own stuff\nbfgminer_LDADD    = lib/libgnu.a ccan.bfg/libccan.a\nbfgminer_LDFLAGS  =\nbfgminer_CPPFLAGS = -I$(top_builddir)/lib -I$(top_srcdir)/lib -I$(top_srcdir)/ccan-upstream\n\n# second, potentially embedded libs\nbfgminer_LDADD    += $(libbase58_LIBS)   $(libblkmaker_LIBS)\nbfgminer_CPPFLAGS += $(libbase58_CFLAGS) $(libblkmaker_CFLAGS)\n\n# finally, everything else\nbfgminer_LDFLAGS += $(PTHREAD_FLAGS)\nbfgminer_LDADD   += $(DLOPEN_FLAGS) @LIBCURL_LIBS@ @JANSSON_LIBS@ @PTHREAD_LIBS@ \\\n\t\t  @NCURSES_LIBS@ @PDCURSES_LIBS@ @WS2_LIBS@ \\\n\t\t  @UDEV_LIBS@ @LIBUSB_LIBS@ @MM_LIBS@ @RT_LIBS@ \\\n                    $(MATH_LIBS)\nbfgminer_CPPFLAGS += @LIBUSB_CFLAGS@ @LIBCURL_CFLAGS@\n\nbfgminer_CPPFLAGS += -DCGMINER_PREFIX='\"$(pkgdatadir)\"'\n\nbfgminer_CPPFLAGS += @JANSSON_CFLAGS@\nbfgminer_CPPFLAGS += $(PTHREAD_FLAGS)\nbfgminer_CPPFLAGS += $(NCURSES_CPPFLAGS)\n\nbfgminer_CPPFLAGS += $(AUTOSCAN_CPPFLAGS)\nbfgminer_LDADD += $(AUTOSCAN_LIBS)\n\n# common sources\nbfgminer_SOURCES := miner.c\n\nbfgminer_SOURCES += miner.h compat.h  \\\n\tdeviceapi.c deviceapi.h \\\n\t\t   util.c util.h logging.h\t\t\\\n\t\t   sha2.c sha2.h api.c\nEXTRA_bfgminer_DEPENDENCIES =\n\nTESTS = test-bfgminer.sh\nEXTRA_DIST += test-bfgminer.sh\nSH_LOG_COMPILER = /bin/sh\nAM_TESTS_ENVIRONMENT = PATH='$(srcdir)':\"$$PATH\"; export PATH;\nTESTS_ENVIRONMENT = $(AM_TESTS_ENVIRONMENT)\nTEST_EXTENSIONS = .sh\n\n.PHONY: update-version\nupdate-version:\n\t( cd $(top_srcdir) && $(top_srcdir)/gen-version.sh ) >version.h.new\n\tcmp $(top_srcdir)/version.h version.h.new && rm version.h.new || mv version.h.new $(top_srcdir)/version.h\nversion.h: update-version\nbfgminer_SOURCES += version.c version.h\nBUILT_SOURCES = version.h\n\nSUBDIRS += $(libbase58_SUBDIRS) $(libblkmaker_SUBDIRS)\nEXTRA_bfgminer_DEPENDENCIES += $(libbase58_EXTRADEPS) $(libblkmaker_EXTRADEPS)\n@BUNDLED_LIB_RULES@\n\nbfgminer_SOURCES\t+= logging.c\n\nif HAVE_WINDOWS\nbfgminer_SOURCES += winhacks.h\nendif\n\nif USE_UDEVRULES\ndist_udevrules_DATA = 70-bfgminer.rules\nendif\n\nif NEED_BFG_DRIVER_PROXY\nbfgminer_SOURCES += driver-proxy.c driver-proxy.h\nendif\n\nif USE_LIBMICROHTTPD\nbfgminer_SOURCES += httpsrv.c httpsrv.h driver-getwork.c\nbfgminer_LDADD += $(libmicrohttpd_LIBS)\nbfgminer_LDFLAGS += $(libmicrohttpd_LDFLAGS)\nbfgminer_CPPFLAGS += $(libmicrohttpd_CFLAGS)\nendif\n\nif USE_LIBEVENT\nbfgminer_SOURCES  += driver-stratum.c\nbfgminer_LDADD    += $(libevent_LIBS)\nbfgminer_LDFLAGS  += $(libevent_LDFLAGS)\nbfgminer_CPPFLAGS += $(libevent_CFLAGS)\nendif\n\n\nif USE_OPENCL\nbfgminer_SOURCES += driver-opencl.h driver-opencl.c\nbfgminer_SOURCES += ocl.c ocl.h findnonce.c findnonce.h\nbfgminer_SOURCES += adl.c adl.h adl_functions.h\n\nkernelsdir = $(pkgdatadir)/opencl\ndist_kernels_DATA =\n\ndist_doc_DATA += README.GPU\n\nif HAVE_SENSORS\nbfgminer_LDADD += $(sensors_LIBS)\nendif\n\nendif\n\n\nif USE_KECCAK\nbfgminer_SOURCES += malgo/keccak.c\n\nif USE_OPENCL\ndist_kernels_DATA += $(top_srcdir)/opencl/keccak.cl\nendif\nendif\n\nif USE_SHA256D\nbfgminer_SOURCES += malgo/sha256d.c\n\nif USE_OPENCL\ndist_kernels_DATA += \\\n\t$(top_srcdir)/opencl/diablo.cl  \\\n\t$(top_srcdir)/opencl/diakgcn.cl  \\\n\t$(top_srcdir)/opencl/phatk.cl  \\\n\t$(top_srcdir)/opencl/poclbm.cl\nendif\n\nif USE_CPUMINING\nbfgminer_SOURCES\t+= \\\n\t\t  sha256_generic.c sha256_via.c\t\\\n\t\t  sha256_cryptopp.c sha256_sse2_amd64.c\t\t\\\n\t\t  sha256_sse4_amd64.c \t\\\n\t\t  sha256_altivec_4way.c\n\nif HAVE_SSE2\nbfgminer_LDADD  += libsse2cpuminer.a\nnoinst_LIBRARIES = libsse2cpuminer.a\nlibsse2cpuminer_a_SOURCES = sha256_4way.c\nlibsse2cpuminer_a_CFLAGS = $(bfgminer_CPPFLAGS) $(SSE2_CFLAGS)\nendif\n\nif HAS_YASM\n\nAM_CFLAGS\t= -DHAS_YASM\nif HAVE_x86_64\nSUBDIRS\t\t+= x86_64\nx86_64/libx8664.a:\n\t$(MAKE) -C x86_64 $*\nbfgminer_LDADD\t+= x86_64/libx8664.a\nelse # HAVE_x86_64\nSUBDIRS\t\t+= x86_32\nx86_32/libx8632.a:\n\t$(MAKE) -C x86_32 $*\nbfgminer_LDADD\t+= x86_32/libx8632.a\n\nif HAVE_SSE2\nlibsse2cpuminer_a_SOURCES +=  sha256_sse2_i386.c\nendif\n\nendif # HAVE_x86_64\nendif # HAS_YASM\nendif # USE_CPUMINING\nendif # USE_SHA256D\n\nif USE_SCRYPT\nbfgminer_SOURCES += malgo/scrypt.c malgo/scrypt.h\ndist_doc_DATA += README.scrypt\n\nif USE_OPENCL\ndist_kernels_DATA += \\\n\t$(top_srcdir)/opencl/psw.cl  \\\n\t$(top_srcdir)/opencl/scrypt.cl  \\\n\t$(top_srcdir)/opencl/zuikkis.cl\nendif\nendif\n\nif USE_CPUMINING\ndist_doc_DATA += README.CPU\nbfgminer_SOURCES += driver-cpu.h driver-cpu.c\nendif # USE_CPUMINING\n\nif NEED_BFG_LOWL_VCOM\nbfgminer_SOURCES += lowl-vcom.c lowl-vcom.h\nif HAVE_WINDOWS\nelse\nbfgminer_SOURCES += iospeeds.h iospeeds_posix.h\nendif\nendif\n\nif HAVE_LIBUSB\nbfgminer_SOURCES += lowl-usb.c lowl-usb.h\nendif\n\nif NEED_BFG_BINLOADER\nbfgminer_SOURCES += binloader.c binloader.h\nendif\n\nif NEED_BFG_LOWLEVEL\nbfgminer_SOURCES += lowlevel.c lowlevel.h\nendif\n\nif NEED_DYNCLOCK\nbfgminer_SOURCES += dynclock.c dynclock.h\nendif\n\nif NEED_BFG_WORK2D\nbfgminer_SOURCES  += work2d.c work2d.h\nendif\n\nif HAS_FPGA\ndist_doc_DATA += README.FPGA\nendif\n\nif HAS_ASIC\ndist_doc_DATA += README.ASIC\nendif\n\nif USE_ALCHEMIST\nbfgminer_SOURCES += driver-alchemist.c\nendif\n\nif USE_BITFORCE\nbfgminer_SOURCES += driver-bitforce.c\nendif\n\nif USE_BITMAIN\nbfgminer_SOURCES += driver-bitmain.c driver-bitmain.h\nendif\n\nif USE_BIGPIC\nbfgminer_SOURCES += driver-bigpic.c driver-bigpic.h\nendif\n\nif USE_DRILLBIT\nbfgminer_SOURCES += driver-drillbit.c\nendif\n\nif USE_TWINFURY\nbfgminer_SOURCES += driver-twinfury.c driver-twinfury.h\nendif\n\nif USE_ICARUS\nbfgminer_SOURCES += driver-icarus.c driver-icarus.h\nbfgminer_SOURCES += driver-cairnsmore.c\nbfgminer_SOURCES += driver-erupter.c\nbfgminer_SOURCES += driver-antminer.c\nendif\n\nif USE_GC3355\nbfgminer_SOURCES += gc3355.c gc3355.h\nendif\n\nif USE_GRIDSEED\nbfgminer_SOURCES += driver-gridseed.c\nendif\n\nif USE_DUALMINER\nbfgminer_SOURCES += driver-dualminer.c\nendif\n\nif USE_ZEUSMINER\nbfgminer_SOURCES += driver-zeusminer.c\nendif\n\nif USE_AVALON\nbfgminer_SOURCES += driver-avalon.c driver-avalon.h\nendif\n\nif USE_AVALONMM\nbfgminer_SOURCES += driver-avalonmm.c\nendif\n\nif USE_KNC\nbfgminer_SOURCES += driver-knc.c\nendif\n\nif USE_KNCASIC\nbfgminer_SOURCES += driver-kncasic.c\nendif\n\nif USE_KLONDIKE\nbfgminer_SOURCES += driver-klondike.c driver-klondike.h driver-hashbusteravalon.c\nendif\n\nif USE_MODMINER\nbfgminer_SOURCES += driver-modminer.c\nendif\n\nif USE_TITAN\nbfgminer_SOURCES += driver-titan.c titan-asic.c titan-asic.h\nendif\n\nif NEED_KNC_ASIC\nbfgminer_SOURCES += knc-asic/knc-asic.c knc-asic/knc-spimux.c knc-asic/knc-transport-spimux.c knc-asic/include/knc-asic.h knc-asic/include/knc-transport.h\nendif\n\nif USE_X6500\nbfgminer_SOURCES += driver-x6500.c jtag.c jtag.h\nendif\n\nif USE_ZTEX\nbfgminer_SOURCES += driver-ztex.c libztex.c libztex.h\nendif\n\nif USE_BIFURY\nbfgminer_SOURCES += driver-bifury.c\nendif\n\nif USE_BITFURY\nbfgminer_SOURCES += driver-bitfury.c driver-bitfury.h libbitfury.c libbitfury.h\n\nif USE_BFSB\nbfgminer_SOURCES += driver-bfsb.c\nendif\n\nif USE_BFX\nbfgminer_SOURCES += driver-bfx.c\nendif\n\nif USE_METABANK\nbfgminer_SOURCES += driver-metabank.c tm_i2c.h tm_i2c.c\nendif\n\nif USE_LITTLEFURY\nbfgminer_SOURCES += driver-littlefury.c\nendif\n\nif USE_NANOFURY\nbfgminer_SOURCES += driver-nanofury.c mcp2210.c mcp2210.h\nendif\n\nif USE_HASHBUSTER\nbfgminer_SOURCES += driver-hashbuster.c\nendif\n\nif USE_HASHBUSTERUSB\nbfgminer_SOURCES += driver-hashbusterusb.c\nendif\n\nendif\n\nif USE_COINTERRA\nbfgminer_SOURCES += driver-cointerra.c driver-cointerra.h\nendif\n\nif USE_HASHFAST\nbfgminer_SOURCES += driver-hashfast.c\nendif\n\nif USE_JINGTIAN\nbfgminer_SOURCES += driver-aan.c driver-aan.h\nbfgminer_SOURCES += driver-jingtian.c\nendif\n\nif USE_MINERGATE\nbfgminer_SOURCES += driver-minergate.c\nendif\n\nif USE_MINION\nbfgminer_SOURCES += driver-minion.c\nendif\n\nif USE_ROCKMINER\nbfgminer_SOURCES += driver-rockminer.c\nendif\n\nif NEED_BFG_LOWL_FTDI\nbfgminer_SOURCES += lowl-ftdi.c lowl-ftdi.h\nendif\n\nif NEED_BFG_LOWL_HID\nbfgminer_SOURCES += lowl-hid.c lowl-hid.h\nbfgminer_CPPFLAGS += $(hidapi_CFLAGS)\nendif\n\nif NEED_BFG_LOWL_MSWIN\nbfgminer_SOURCES += lowl-mswin.c lowl-mswin.h\nendif\n\nif NEED_BFG_LOWL_PCI\nbfgminer_SOURCES += lowl-pci.c lowl-pci.h\n\nif USE_VFIO\nsbin_SCRIPTS += setup-vfio\nendif\nendif\n\nif NEED_BFG_LOWL_SPI\nbfgminer_SOURCES += lowl-spi.h lowl-spi.c\nendif\n\nbin_PROGRAMS += bfgminer-rpc\nbfgminer_rpc_SOURCES = api-example.c\nbfgminer_rpc_LDADD = @WS2_LIBS@\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 414.1591796875,
          "content": "BFGMiner Version 5.5.0 - January 3, 2018\n\n- Update official Win32/64 build compiler and libraries:\n- - Win64 compiler (GCC) from 5.3.0 to 7.2.0 (Win32 remains at 4.7.4)\n- - c-ares from 1.10.0-r1 to 1.11.0\n- - libjansson from 2.7 to 2.10\n- - libcurl from 7.47.1 to 7.57.0\n- - libevent from 2.1.5-r4 to 2.1.8\n- - libusb from 1.0.20 to 1.0.21\n- - libmicrohttpd from 0.9.48 to 0.9.58\n- - zlib from 1.2.8-r1 to 1.2.11-r1\n- Update copyrights\n- AUTHORS: Update\n- README.ASIC: Update Alcheminer\n- alchemist: Reset using DTR as well\n- alchemist: Experimental USB->UART Dongle Support on RPi\n- make-release: Add crypt32.dll to OS-provided library list\n- README: Expand on --set-device documentation\n- Update libblkmaker to 0.6.0\n- openwrt: Update for LEDE 17.01\n- ccan: Update to latest version (which fixes musl libc support)\n- Bugfix: probe_device_thread: Fix threadname buffer size\n- Bugfix: appdata_file_call: Fix buffer size and loop\n- Bugfix: SSM: Clear desired_default_share_pdiff when initialising\ndesired_share_pdiff before authentication\n- cpu: Avoid relocations for x86_64 assembly that interfere with building\nBFGMiner as a PIE\n- Bugfix: SSM: We already hold the pool lock when we need to call stale_work,\nso avoid trying to lock it a second time inside the function\n- Bugfix: Hold the control lock when updating the generate-to script\n- Bugfix: Hold the pool lock when updating lp_id\n- Bugfix: icarus: Explicitly specify type wide enough for bitshift in\nicarus_proc_for_nonce\n- configure: BFG_FIND_INCLUDE_PATH: Handle more unusual syntax correctly\n- Bugfix: SSM: Handle network problems safely, and use thread-safe libevent\n\n\nBFGMiner Version 5.4.2 - March 26, 2016\n\n- Update official Win32/64 build compiler and libraries:\n- - Win64 compiler (GCC) from 4.7.4 to 5.3.0 (Win32 remains at 4.7.4)\n- - libcurl from 7.39.0 to 7.47.1\n- - libevent from 2.0.21 to 2.1.5-r4\n- - libusb from 1.0.18 (Win32) and 1.0.19 (Win64) to 1.0.20\n- - libmicrohttpd from 0.9.38_pre33603 to 0.9.48\n- Update libblkmaker to 0.5.3\n- Bugfix: Sanitise lock situation for work2d\n- Bugfix: SSM: Never issue the same work2d twice in a row\n- Bugfix: SSM: Never send mining.notify for stale work2d\n- SSM: Refactor work2d check and job pruning from _stratumsrv_update_notify\ninto stratumsrv_update_notify_str\n- Updates for OpenWrt 15.05\n- Bugfix: Correct work2d handling for GBT servers\n\n\nBFGMiner Version 5.4.1 - November 21, 2015\n\n- bitmain: Use more portable PRIu64 rather than %llu (which fails on Windows)\n- icarus: Use more portable PRIu64 rather than %llu (which fails on Windows)\n- Bugfix: openwrt: Fix bitmain option\n- Bugfix: antminer: Avoid strstr(NULL, ...) when device has no [available]\nproduct string\n- Update libblkmaker to 0.5.2\n- openwrt: Add option to enable bitmain driver\n- openwrt: Update libusb device list\n\n\nBFGMiner Version 5.4.0 - October 23, 2015\n\n- AUTHORS: Move jstefanop to current maintainers\n- Disable alchemist by default, add Travis build, and document configure option\nin README\n- alchemist: New scrypt ASIC driver\n- hashfast: Support setting clock speed from TUI Manage\n- avalon: Support setting clock speed from TUI Manage\n- antminer: Support setting clock speed from TUI Manage (hidden for non-BM1382/4\ndevices)\n- jingtian: Allow changing clock speed from TUI\n- Debuglog for retrodiff being disabled\n- Disable retrodiff when it was not explicitly enabled, and the pool doesn't\nseem to like it\n- Bugfix: Only adjust work_difficulty on retrodiff submissions, so we can still\ndetect them on rejection\n- (Re-)enable retrodiff by default for stratum pools, since some servers\nimplement mining.set_difficulty wrong in this way\n- New pool option \"retrodiff\"\n- If a share passes difficulty check for the updated pool target,   record that\ntarget for correct accounting of diff_stale.\n- DevAPI: Remove unused temporary variable from driver iteration\n- README.ASIC: Expand Antminer S5 section to S1-S5 for completeness, since in\ntheory they should work\n- bitmain: Make reg_data optional for S4 and S5, calculating it from clock\n- Document Bitmain Antminer S5 support\n- bitmain: Remove poll_prio_threshold and just ensure we poll at a regular\ninterval to avoid nonce buffer overruns\n- bitmain: Remove dead per-device constants\n- bitmain: Only have one set of actual maximums\n- bitmain: Migrate BITMAIN_MAX_NONCE_NUM to runtime packet_max_nonce\n- bitmain: Migrate BITMAIN_MAX_WORK_QUEUE_NUM/bitmain_work_poll_prio to runtime\npoll_prio_threshold\n- bitmain: Migrate BITMAIN_MAX_WORK_NUM to runtime packet_max_work\n- bitmain: Dummy model parameter\n- bitmain: Remove baud/flush, as the fake VCOM kernel driver ignores (and\ncomplains about) both\n- bitmain: Poll after queuing work, once enough is queued\n- bitmain: Sleep a little between polling\n- bitmain: Flush queues for work restarts\n- bitmain: Queue multiple works at a time\n- bitmain: Remove more dead code\n- bitmain: Prune old work eventually\n- Bugfix: bitmain: Properly count work-search failures as HW errors\n- bitmain: Refactor to work with minerloop_queue (leaks work memory)\n- bitmain: Avoid busy-looping on network devices\n- bitmain: Support for talking to a device over the network\n- bitmain: Use the hottest reading for device temperature\n- Bugfix: bitmain: Actually use baud setting\n- bitmain: Remove more dead code\n- bitmain: Handle stale results normally\n- bitmain: Simplify num2bit\n- bitmain: Initial set-device based configuration\n- bitmain: Use lowl-vcom abstractions\n- Update copyrights\n- Bugfix: bitmain: Type-safe printf-format usage\n- Travis: Test bitmain-only build\n- Build bitmain driver\n- bitmain: Hardcode configuration for now\n- bitmain: Rework nonce_diff handling\n- bitmain: Update headers\n- bitmain: Deal with unused variable warnings sanely\n- bitmain: Explicitly de-const device_path for freeing\n- Bugfix: bitmain: Correct type of cgpu->temp reference\n- Bugfix: bitmain: Use uint8_t consistently for binary data\n- Bugfix: bitmain: Clear opt_bitmain_dev string properly\n- bitmain: Remove non-existent bitmain_detect parameter\n- bitmain: Cleanup unnecessary code\n- bitmain: Use uthash to find queued work\n- bitmain: Implement inc_dev_status within record_temp_fan\n- bitmain: Remove non-applicable limits\n- bitmain: Remove obsolete get_statline_before function\n- bitmain: Move g_miner_version to bitmain_info struct\n- bitmain: Remove direct USB code\n- bitmain: Update driver registration\n- bitmain: Update symbol names\n- bitmain: Remove dead code\n- bitmain: Replace custom hexdump with normal bin2hex\n- bitmain: Get network difficulty from first work task\n- bitmain: No-op htole8\n- bitmain: Simulate cgminer work_block somewhat\n- bitmain: Update bin2hex usage for malloc-free version\n- bitmain: Copy low-level code from Bitmain cgminer usbutils\n- Copy working driver-bitmain.c from Bitmain's cgminer at commit\n4ecf89341657ea7efecdf588586ca3f068ab17ab\n- Add api_add_percent to miner.h\n- Bugfix: DevAPI: Update includes from uthash to utlist and support older\nversions of uthash\n- Bugfix: RPC: Need to include utlist.h for config file list\n- Bugfix: antminer: Avoid NULL dereference for non-BM1382/4 devices\n- README.ASIC: Update documentation for BM1382/4 clock calculation support\n- antminer: Support for setting BM1382/4 clock by frequency MHz\n- Bugfix: Keep JSON from getaccountaddress around long enough for debug messages\n- Bugfix: Run gen-version.sh from source directory\n- Fix to enable building into directory out of source tree\n- Bugfix: Clean up JSON from getaccountaddress\n- Bugfix: Do not use hash tables for driver lists, since they require unique\nkeys\n- Pool option #cksuggest to use CKPool-compatible mining.suggest_difficulty\n- RPC: Add \"Rotate Period\" to config\n- RPC: Extend setconfig to change strategy\n- Allow setting strategy by name\n- bitforce: Enable changing voltage from the Manage TUI\n- avalonmm: Use proc_set_device_tui_wrapper instead of avalonmm_tui_wrapper\n- DevAPI: Add generic proc_set_device_tui_wrapper\n- bitforce: Add \"voltage\" setting to send V?X commands\n- Bugfix: compac: Set dname so assignments match\n- README.RPC: Add missing setconfig|stratum-port documentation\n- README.RPC: Add missing setconfig|http-port documentation\n- Bugfix: lowl-vcom: Check for tcgetattr/tcsetattr/tcflush failure\n- configure: List compac driver in output\n- Travis: Workaround Travis bug\n- configure: Use AC_PROG_SED to find sed\n\n\nBFGMiner Version 5.3.0 - September 5, 2015\n\n- README.ASIC: Compac docs\n- antminer: Explicit support for GekkoScience's Compac BM1384 Bitcoin Miner\n- icarus: Use all null padding when probing work division (BM1384 reacts\nstrangely - using part as start nonce?)\n- antminer: Match Product strings including \"Antminer\"\n- Bugfix: icarus: Never set timeout to 0, since it disables the timeout\naltogether\n\n\nBFGMiner Version 5.2.0 - June 5, 2015\n\n- Upgraded Windows hidapi library from 0.8.0_pre20130121 to 0.8.0_rc1_p20140719\n- Update bundled libbase58 to 0.1.4\n- README.ASIC: Document usage with AntMiner U3\n- icarus: Include ns/hash estimates for each nonce result, in debug logging\n- icarus: Cleanup dev vs proc repr in logging\n- Bugfix: update_block_display: Ensure we have console lock, and avoid rare\nrelock when resizing windows inside curses_print_status\n- gitmodules: Change libblkmaker URI to use GitHub since Gitorious is defunct\n- Bugfix: DevAPI: Avoid infinite hang in set_device help\n- bitforce: Wait until pre-initialisation jobs all flush completely before\nstarting to avoid sanity check issues\n- bitforce: Wait to clear job queue (at init) until we have actually opened the\ndevice\n- bitforce: Remove unnecessary delay\n- Bugfix: vcom: Avoid overflowing cc_t before division to deciseconds\n- Bugfix: bitforce: Ensure hashes_done is called for every completed job\n- antminer: Adapt default configuration to work with U3 as well as U1/U2\n- antminer: Add U3 voltage setting (x??? format only for now)\n- antminer: getstatus needs to read a result for every chip, but we don't use\nthe output anyway, so just skip it\n- icarus: Modify work division detection packet to be compatible with Antminer\nU3\n- icarus: Replace decisecond-precision read_count with read_timeout_ms\n(millisecond precision) to handle faster devices like the Antminer U3 that\ncomplete works in under 1ds\n- lowl-vcom: vcom_set_timeout_ms function (increases precision to ms on Windows\nonly)\n- util: timer_remaining_us function\n- configure: Improve path finding macro to work with more possible CPP output\n- configure: Macroify header path search\n- Reduce HTTP request failure log level to DEBUG since it often occurs probing\nstratum pools\n- Bugfix: DevAPI: Guarantee set_device functions never get passed a NULL pointer\nfor newvalue\n- Always update block display after pool display in case of username wrapping\naround\n- icarus: Pass device representation to icarus_{gets,write} so logging can use\nit rather than fd numbers\n- Bugfix: icarus: Check for impossibly fast hw errors (and don't report Eh/s\nwhen they occur)\n- Bugfix: icarus: Avoid a race with watchdog applying settings by setting\ndevice_data before add_cgpu\n- RPC: Clean up api_add_* somewhat\n- Bugfix: util: Fix is_power_of_two\n- Port antminer driver to use set_device_funcs\n\n\nBFGMiner Version 5.1.0 - February 19, 2015\n\n- Fix broken driver options in configure script\n- Bugfix: extract_domain: Correctly handle query/fragment in URI without path\n- kncasic: Do flush!\n- kncasic: avoid duplicate nonces to be reported\n- kncasic: Fix logging levels\n- kncasic: Neptune-compatible API interface for enabling/disabling dies\n- kncasic: Use one bfgminer processor per die (not per core)\n- Update libblkmaker to 0.5.1\n- Titan: Lower log level when reconfiguring dies\n- Titan: does not need SHA256d algo\n- Titan: lower log level for flush messages\n- Titan: adjust log levels in knc_titan_get_info\n- get_master_rolling_hashrate -> get_proc_rolling_hashrate\n- Update webconfig code to latest BFGMiner\n- allow url based config files\n- kncasic: Fix \"double free\" error\n- kncasic: We need to free queued work to avoid memory leaks\n- Bugfix: minion: Don't try to add 0-chip devices\n- configure: Avoid BASHisms for better portability\n\n\nBFGMiner Version 5.0.0 - November 29, 2014\n\n- opencl: Fail gracefully if clGetProgramInfo/CL_PROGRAM_NUM_DEVICES returns\nzero\n- opencl: Remember results of global offset testing\n- opencl: Only save kernel binary when we built from source\n- opencl: Only try to patch BFI_INT when compiling a kernel from source\n- opencl: Major refactor, splitting up opencl_load_kernel into many new\nfunctions\n- titan: Initialise variables to satisfy compilers\n- Bugfix: opencl: Correctly handle non-goffset kernels\n- Fixing column spacing of non-curses device output\n- Bugfix: opencl: free memory if clState creation fails\n- Titan: Do not do actual configuration job in API thread context. Instead, send\ncommands to the worker thread to do the actual job.\n- Titan: bugfix: dies are not configured if die#0 is OFF\n- Titan: unused function argument\n- Titan: unused variables\n- Update knc-asic: Titan FPGA image with spi->i2c commands removed and fixed\nsome lock-up scenarios\n- Titan code rework: Use one bfgminer processor per die (instead of core)\n- minion: Reinitialise chips if they don't seem to be progressing\n- minion: Read temperature sensor\n- minion: TUI clock speed control\n- minion: Include \"Frequency\" in RPC status\n- minion: Add \"clock\" setting\n- minion: Set configuration parameters we care about\n- minion: Reset chip at initialization\n- minion: Configure PLL to 900 MHz at startup\n- minion: Report hashes done as accurately as we can\n- minion: Core enable/disable control\n- minion: Implement queue flushing\n- minion: Implement basic mining\n- lowl-spi: linux_spi_txrx2 to include device protocol dumping\n- minion: Detection code for the Prospero X1\n- Actually add version.c file\n- Only rebuild a minimal version.c file when git commit changes\n- Bugfix: Use HASH_ADD_KEYPTR for const char *, not HASH_ADD_STR\n- Bugfix: Re-lock stgd_lock when we don't have a malgo-specific pool to use\n- scrypt: Disable OpenCL by default\n- opencl: Remove support for \"OCL1\" kernel define (indicated OpenCL 1.1+)\n- opencl: Autodetect whether global offset actually works\n- opencl: Add no-goffset support to scrypt kernels\n- opencl: Determine kernel support for goffset by code analysis\n- opencl: Add \"goffset\" setting to override detection of support for global work\noffsets\n- util: seek_data_cb: Check validity of offset\n- Allow libcurl to rewind the upload buffer\n- cpu: Set the priority of miner threads to idle on Windows\n- cpu: Use _SC_NPROCESSORS_CONF instead of _SC_NPROCESSORS_ONLN\n- cpu: Do not set thread affinity on single-processor systems\n- Adding additional boolean keywords enable and disable\n- AUTHORS: Move Pelle and Vitalii to \"Current Maintainers\" since they actively\nmaintain the Titan driver\n- AUTHORS: Add Ronny Van Keer (Keccak C implementation)\n- Titan: supply its own rolling hashrate implementation\n- A driver can supply its own rolling hashrate function   (in case generic\nrolling hashrate implementation does not work)\n- Bugfix: configure: kncasic does not actually need i2c-tools\n- Keccak: Simplify keccak_hash_data\n- keccak: Adapt opencl intensity interpretation to have approximately the same\ndesktop interactivity affect as SHA256d\n- Keccak: Include support in various builds\n- Travis: Update with Keccak\n- opencl/keccak: Add non-goffset support\n- opencl/keccak: Unroll all the hash rounds properly\n- opencl: Add Keccak support via \"fullheader\" kernel interface\n- keccak: Adapt for BFGMiner\n- Keccak: Import algorithm code as-is\n- opencl: Add a simple \"fullheader\" kernel interface\n- Update stratum mining.capabilities method to use a single Object for all\nparameters\n- Bugfix: Correct USE_SHA256D macro name to ensure SHA256d is always preferred\nas default algorithm\n- cpu: Generic scanhash that can support any PoW algorithm\n- RPC: Include Hash Method in minecoin for new algorithms\n- opencl: Teach findnonce to behave based on kernel interface rather than mining\nalgorithm\n- opencl: Get min_nonce_diff from struct mining_algorithm\n- Move malgo-specific code to dedicated source files\n- opencl: Simplify kernel-specific data handling\n- Update knc-asic: Fix issue with detect_die crashing due to errors in response\n- titan: Init last_nonce on die reconfiguration to avoid lots of \"unknown work\"\nmessages\n- Bugfix: titan: Extra garbage was sent on SPI with new commands\n- titan: Remove temporary log messages for manual report checks\n- titan: Wrong variable used in new per-die iteration\n- titan: Do manual core checks in parallel with normal ones\n- titan: Fix: Only one die was checked after flush in last commit\n- titan: Manually check all cores for reports after flush\n- opencl: Remove redundant checks for USE_OPENCL\n- cpu: Remove redundant checks for USE_CPUMINING\n- opencl: Only attempt to BFI_INT patch SHA256d kernels\n- Significantly rewrite configure script to handle driver dependencies cleaner\n- Make SHA256d mining optional\n- Bugfix: cointerra: Can handle nonces down to pdiff 1\n- kncasic: Initialise first_cgpu to silence false warning\n- Bugfix: Clarify goffset decision code, and refuse to compile kernels in\nsituations where they won't work\n- Bugfix: opencl: Output buffer must be readable by kernel since it is used with\na count/position iterator\n- Bugfix: opencl: Skip NULL kernel interface entry\n- DevAPI: hashes_done: Simplify and improve precision of max_nonce calculation\n- opencl: Avoid duplicating kernel_interfaces mapping in select_kernel\n- opencl: Avoid duplicating kernel_interfaces mapping in\nopencl_scanhash_get_kernel\n- cpu: Drivers should not be doing fulltest on their own, so remove it\n- cpu: Pass full work struct to scanhash functions\n- kncasic: Split up each ASIC channel to its own device\n- kncasic: Use consistent naming for KNC_MAX_DIES_PER_CORE\n- kncasic: Refactoring: coreid is not used, remove it\n- kncasic: Refactoring: put all device architecture defines in one place (knc-asic.h)\n- kncasic: Add lock to protect concurrent accesses to knc_state\n- kncasic: Fix auto\n- Build system fixes for kncasic driver\n- configure: Deduplicate Linux i2c-dev.h checks for KnCMiner drivers\n- Travis: Update for kncasic driver\n- kncasic: Only show the relevant die for RPC stats\n- kncasic: Use proc_repr for logging\n- kncasic: Split up logical processors\n- kncasic: Silence warning about unhandled enumeration values\n- Bugfix: kncasic: Proper format specifications\n- kncasic: Remove unused code\n- kncasic: Minimal changes to get it compiling\n- kncasic: Import gen 2 driver from cgminer commit\nbc153552be8591250cb3214bf5202501d4a39922\n- titan: Move thread_reportin() call to poll function\n- titan: reportin every process_report to avoid falsely tripping the watchdog\n- titan: Remove unused variables\n- Bump knc-asic submodule\n- titan: Increase FPGA to ASIC SPI frequency to 6 MHz\n- titan: Use new get_work_status prototype and print FPGA CRC error counters to\nlog\n- Titan flush optimization fix: Don't send get_info commands when FPGA is\nspeaking to ASIC\n- titan: All dies use same nonce working range\n- Titan flush optimization bugfix: FPGA status was checked once per poll instead\nof once per ASIC\n- Titan flush optimization: Bugfix: Flush time measurement only worked with one\nASIC\n- Titan flush optimization: Point knc-asic submodule to include new FPGA image\n- Titan flush optimization: Remove temporary debug messages\n- Titan flush optimization: Keep works in local queue until slot number is\nreused\n- Titan flush optimization: Point knc-asic submodule to needed revision\n- Titan flush optimization: Measure new flush time\n- Titan flush optimization: Send works to all dies after flush\n- Titan flush optimization: First rough implementation\n- Titan: Less clobber on the screen: group some \"failure\" messages\n- Bugfix: Prefer not using work created just to ensure a specific algorithm is\nqueued, so strategies work as much as possible\n- Stratum: Enable mining.set_goal to change parameters on the current goal\n- cpu: Fail gracefully if unsupported mining algo gets into scanhash\n- opencl: Fail gracefully if unsupported mining algo gets into\nopencl_scanhash_get_kernel\n- SSM: Send goal malgo to goal-enabled clients\n- Allow pools with #change_goal_malgo attribute to change the mining algorithm\nused by their assigned goal\n- Gracefully fail when no pool can be found to generate specific-algo work\n- Remove opt_scrypt\n- dualminer: Replace opt_scrypt with a per-device \"scrypt\" option\n- dualminer: Make dual_mode a per-device option as it should be\n- opencl: Nearly complete migration to per-work mining algorithms\n- pool_actively_desired: If we are the highest priority, workable pool for a\ngiven algorithm, we are needed\n- Ignore opt_queue for unused mining algorithms\n- Set name and aliases on mining algorithms\n- When hotplug is enabled and a mining algorithm is configured for the first\ntime, schedule a rescan of hardware to pick up anything now applicable that may\nnot have been before\n- Try to keep enough work queued for each mining algorithm in use\n- Move select_loadbalance and select_failover logic into their own functions\n- Keep track of how much work is staged per-algorithm\n- Keep track of how many goals reference each mining algorithm\n- Abstract goal_set_malgo function\n- Build a mining_algorithms list\n- get_work: Restore previous getwork rollntime behaviour\n- get_work: Only return work items compatible with processor (degrades getwork\nrollntime support)\n- opencl: Support for per-work mining algorithms\n- Build without POW_SCRYPT at all\n- opencl: Defer loading kernel until it is needed\n- opencl: Split initCl into opencl_create_clState and opencl_load_kernel\n- SSM: Implement mining.capabilities including proxying mining.set_goal\n- Replace mining.goal.subscribe with mining.capabilities\n- Stratum: Avoid resetting the goal if the old and new name match\n- Allow specifying goal options as eg, --pool-goal name:malgo=scrypt\n- cpu: Support for per-work mining algorithms\n- Replace cgpu.min_nonce_diff with drv.drv_min_nonce_diff(cgpu, malgo)\n- proxy: Avoid assumptions about mining algorithm at initialisation\n- Core only: Partially move most of opt_scrypt to mining_goal\n- opencl: Reintroduce independent intensity setting internally\n- Move MAX_*_INTENSITY stuff to driver-opencl.h\n- proxy: Minimise minimum difficulty for proxy clients\n- Enable --generate-to option (was --coinbase-addr) to work with non-default\ngoals\n- Save pool goals in written config files\n- README: Update documentation for multiple blockchain support\n- RPC: Add \"Difficulty Accepted\" to \"coin\" command\n- RPC: Add \"Mining Goal\" to \"pools\" command\n- RPC: Accept an additional argument for \"addpool\" to indicate mining goal by\nname\n- Stratum: Support for mining.set_goal(\"goal name\") - currently just resetting\nthe user-configured goal\n- Teach longpoll logic about multiple mining goals\n- RPC: Include non-default goals in reply to \"coin\" command\n- Ignore generation address/script on pools using non-default mining goals\n- Only include block display lines for active goals\n- Move income to block display line, and show extra block display lines for each\nadditional mining goal\n- New --pool-goal option to set a distinct named goal per-pool\n- Parameterise most references to global mining_goal_info\n- Move block_time to be per block_info\n- Show \"?\" for income if block height is unknown\n- Move block height tracking onto block_info\n- Calculate current_fullhash only when needed (for RPC 'coins')\n- Replace current_block_id with blkchain->currentblk[->block_id]\n- Move current_hash to goal->current_goal_detail\n- Clean up struct block_info names\n- Use full prevblock hash as block key (also gets rid of dead code)\n- Move global variables related to the blockchain or mining goals on to global\nstructs\n\n\nBFGMiner Version 4.10.1 - November 29, 2014\n\n- Upgraded Windows libcurl from 7.38.0 to 7.39.0\n- Bugfix: bytes_free: Set buf to NULL so the bytes_t is reusable\n- Bugfix: minergate: Avoid malloc(0) if stats file has too few values\n- Bugfix: modminer: Avoid leaking devname when detecting claimed devices\n- Bugfix: free memory allocated for config file loading/writing\n- Bugfix: nanofury: Avoid NULL pointer dereference on init failure\n- Bugfix: varint_decode: Correctly decode multibyte numbers\n- cpu: Fix processor count detection with HW_NCPU\n- cpu: SCHED_IDLE and SCHED_BATCH can only be used with sched_priority 0\n- cpu: fix sched_setaffinity parameter : sizeof(cpu_set_t)\n- Bugfix: opencl: Correctly accept negative intensities and set dynamic\nintensity without changing current value\n- Since longpoll connections are never reused, explicitly forbid reuse so\nlibcurl cleans them up immediately\n- Bugfix: Correct already-in-use getcbaddr message\n- Demote some Bitfury debug log messages to only with device protocol dumping\n- Update bundled libbase58 to 0.1.3\n- README.ASIC: Minor cleanups to Zeusminer section\n- README.ASIC: Explain Zeusminer options\n- Makefile: Specify .cl files explicitly, and only include scrypt ones when\nconfigured with scrypt support\n- Bugfix: DevAPI: hashes_done: Explicitly cast to uint64_t for big calculations\n(LLVM was allowing overflow)\n- Bugfix: titan: First core in each die got too big nonce area to work on\n- Travis: Build MinGW64 with ncurses\n- Bugfix: Declare manual_enable_pool in miner.h, for api.c use\n- Bugfix: bitfury: Use long long and llabs to avoid under/over flows misbehaving\n- Bugfix: Highlight all active pools, in pool listing\n- Set quota to 1 when enabling a failover-only pool, and disable failover-only\nwhen setting quota\n- Bugfix: pool_actively_desired: Detect failover-only conditions for loadbalance\nand balance strategies\n- Bugfix: Only display pools as Failover state when it is effectively so\n- Make sure KEY_EVENT from wincon is ignored (it conflicts with ncurses)\n- README.ASIC: Add details for BFx2 USB\n- Titan: Submit stale shares while doing flushes\n- README.ASIC: Remove CFLAGS hack not needed for KnCMiner Titan build\n- Bugfix: Need unicode_micro in non-Unicode curses builds\n- Remove unused variables from curses-less builds\n- Bugfix: Cannot duplicate userpass option or we end up with it processed double\n\n\nBFGMiner Version 4.10.0 - October 21, 2014\n\n- Upgraded Windows libjansson from 2.6 to 2.7\n- i2c-tools are not required by Titan\n- minergate: Fix hashmeter\n- minergate: Support minergate-side ntime rolling for SP30 only\n- minergate: Autodetect SP30 on /tmp/connection_pipe_sp30\n- minergate: Make stats file configurable\n- minergate: SP30 only wants max 10 queue requests at a time\n- minergate: Use work_completed flag for SP30\n- minergate: Only SP10 has a second winner_nonce\n- minergate: Simplify multi-winner_nonce handling\n- Bugfix: minergate: Correct endian for 2nd winner_nonce\n- minergate: Vary max jobs queued\n- minergate: Vary number of requests/responses per packet\n- minergate: Support --set MGT:protover=N\n- Titan: fix compiler warning \"maybe-uninitialized\"\n- Titan: Increase die inactivity timeout to 20 secs\n- Titan: Slightly improve some debug messages\n- Titan: Use multi-part batched SPI transfers for flushes (saves 2 secs on each\nflush)\n- Titan: Fix buffer overflow\n- Titan: Increase queue prefill value up to 20\n- Titan: Flag for fast broadcast flushes. Not enabled: DC/DCs trip off easily!\n- Titan: Monitor die health, reconfigure it if no shares in 10 seconds\n- Titan: Make log level of some messages lower, to not clobber the screen\n- Titan: Work assignment and flushing is per-die, not per-ASIC\n- Titan: Set flush flag after re-configuring the die\n- Titan: Refactoring: intermediate variables for first_proc and repr\n- Titan: Flush cores one-by-one right before reconfiguring them\n- Titan: Define for the broadcast core address\n- Titan: Re-configuring dies through API command \"procset\"\n- Titan: Use correct version of knc_titan_setup_core\n- Titan: configure_one_die func for configuring single die\n- Titan: fill all non-found ASIC structs with the same (invalid) data\n- Titan: Core init parameters (nonce range) independent of number of found dies\n\n\nBFGMiner Version 4.9.0 - October 5, 2014\n\n- Upgraded Windows libraries:\n- - libcurl from 7.37.0 to 7.38.0\n- - libusb from 1.0.18 to 1.0.19 (Win64 only)\n- - mingw64-runtime from 3.1.0 to 3.2.0 (Win64 only)\n- - uthash from 1.9.7 to 1.9.9\n- Travis: Update for titan driver\n- configure: Accept --enable-titan=CONTROLLER to select controller\n- make-release: Remove unnecessary knc-asic/{*.rbf,*system,waas} from release\nsource\n- extra_work_queue so devices can influence their effect on the central work\nqueue somewhat (titan needs less than 1-per-proc)\n- Avoid adding include paths for titan driver\n- Bugfix: titan: Add missing printf formatting for core busy status\n- avalon: Drop custom hexdump logging\n- Build titan driver independently from knc (Jupiter) driver\n- titan: Do not fill up next slot immediately after urgent setwork\n- titan: Pre-fill work queue so that all ASICs have fresh jobs after a flush\n- Build instructions for KnC Titan\n- Doesn't compile without explicitly included inttypes.h on some machines\n- knc-asic: Updated to e5c986d3c44fde8c5b069508ef6979f2f2be92d6\n- Fix Makefile.am to build bfgminer for titan\n- titan: Subdivide full nonce range only between cores in one ASIC (because\nworks are now distributed per-ASIC too)\n- titan: DC/DCs does not like broadcast flushes (urgent setwork). Do not do it!\n- titan: Preparation to setting threads-per-core externally, by user\n- titan: Re-flush cores in case of slot number collision\n- titan: Per-ASIC flush, per-ASIC work management\n- titan: Start cores after flush individually, not by broadcast.\n- titan: Default frequency is 275 MHz\n- titan: Difficulty is offset by one in ASIC cores.\n- titan: Fix first_proc pointer\n- titan: Use 2 threads per core\n- titan: Use setup_core from knc-asic library\n- titan: Poll all enabled ASICs amd dies, not only one\n- titan: Properly set work_accepted flag\n- titan: Hint detection function about expected device type\n- titan: Fix setup_core command\n- titan: Use knc-asic library for transport layer\n- Add knc-asic as submodule\n- titan: Change spi device to spidev1.0\n- titan: Add define to .h file\n- titan: Increase workqueue size up to number of slots per core\n- titan: Send data to hashmeter\n- titan: Disregard stale reports after flush\n- titan: Check for next asic/die switch when processing info results\n- Bugfix: titan: Fix segfault\n- titan: Set actual hardware nonce_diff for works in prepare_work\n- titan: Do clean flush (\"purge\") on init\n- titan: Store last_nonce right\n- titan: First attempt to process nonce responses\n- titan: Change 'scanhash' minerloop to 'queue'\n- titan: Init all cores for their own nonce ranges\n- titan: For RPi we use spidev0.1\n- titan: Setup_core command implemented\n- titan: New commands set_work & get_report\n- titan: Move asic-specific functionality to the separate file (titan-asic.c)\n- titan: First ugly detect of Titan chip over SPI\n- knc-titan: Begin work on Titan (scrypt miner) driver\n- libbase58: Use git URI for submodule to avoid failure on systems without HTTPS\nsupport\n- Travis: Cross-compile a Win64 build\n- RPC: Initialise json_config to silence false warning\n- Make sure MOUSE_MOVED from wincon is ignored (it conflicts with curses)\n- Travis: Perform full builds with libbase58's base58 tool (which is used for\ntests)\n- Travis: Test many configuration variations\n- Travis: Build with libsensors and VFIO\n- Travis: Upgrading GCC triggers locale rebuild, so just do the one in use\n- Travis: No need to upgrade GCC for LLVM build\n- Travis build configuration\n- Run BFGMiner's unit tests for 'make check', and have --unittest exit with\nfailure if any problems occur\n- libbase58: Update to pick up on LLVM fixes\n- Bugfix: configure: Affect gridseed driver with --disable-other-drivers\n- Bugfix: configure: minergate driver needs lowlevel for claiming sockets\n- Bugfix: configure: --disable-other-drivers should not affect non-driver\noptions\n- Bugfix: configure: --with[out]-vfio needs $withval, not $enableval\n- Bugfix: rockminer: Correct types for short read error message\n- Bugfix: icarus: fix the STATS RPC API call crashes with a multi-proc device\n- Bugfix: cointerra: Check lowlevel device is USB before trying to probe it (as\nUSB)\n- bitforce: Reinstate device work inprogress count sanity check for 28nm devices\n- littlefury: Read uC temperature sensor\n- littlefury: Keep track of enabled chips and power state explicitly in case of\ntrouble\n- Bugfix: async minerloop fix for devices disabled at start\n- twinfury: Implement device protocol dump more low-level\n\n\nBFGMiner Version 4.8.0 - September 10, 2014\n\n- Improve precision of total_secs used in (at least) RPC summary Elapsed\n- Bump embedded libblkmaker to 0.5.0\n- Bump embedded libbase58 to 0.1.1\n- Remove now-unused bfg_cond_timedwait which cannot be made portable\n- Spawn a new thread for cmd-idle rather than relying on problematic pthread\ntimedwait\n- README: --coinbase-check-* options\n- Bugfix: Accept actual percentages for --coinbase-check-percent\n- Optimise coinbase check logic by using actual script bytes everywhere possible\n- Pool option #skipcbcheck to disable new coinbase checks\n- pool_check_coinbase: Avoid redisabling an already misbehaving pool\n- Bugfix: Keep connection active for rejecting and misbehaving pools so we can\ndetect when they recover\n- Share pool coinbase check reaction code\n- Initial version of coinbase checking function for GBT and stratum\n- cointerra: Ensure devlog messages cannot overflow\n- Bugfix: cointerra: Defer setting USB timeout until after initialisation\n- cointerra: Set configuration and claim interface\n- Bugfix: cointerra: Check ep is open before trying to talk to it (crash at init\nfailure)\n- cointerra: Support for --set cta:load=N\n- cointerra: Store load setting on struct cointerra_info\n- cointerra: Operate within a single thread\n- cointerra: Update to minerloop_queue\n- cointerra: Split work packet into cointerra_queue_append function\n- cointerra: Prepare for splitting work packet into cointerra_queue_append\nfunction\n- cointerra: Use more fresh code for work packet\n- cointerra: Use fresh code for work packet\n- Bugfix: cointerra: Use bfg_cond_timedwait to avoid spinning\n- cointerra: Claim and release lowlevel device\n- cointerra: Propagate per-core temperatures to each processor\n- cointerra: Reduce redundant stats information\n- cointerra: Correctly divide up individual processors\n- cointerra: Update to latest BFGMiner\n- work_ntime_range helper function\n- work_{get,set}_ntime inline functions\n- Store a reference timeval with ntime_roll_limits\n- util: min macro\n- cointerra: Cleanup debugging\n- cointerra: Divide up processors\n- cointerra: Wait for info packet on probe\n- cointerra: Dirty BFGMiner port\n- lowl-usb: Cleanup dead code\n- notifier_wait, notifier_wait_us, and notifier_reset functions\n- Export the flush_queue function for use by drivers.\n- Provide a function to discard queued work based on age.\n- Export share_diff function and add flip12 macro\n- Provide a copy_work_noffset function for copying a work struct but changing\nits ntime.\n- Add api_add_int16 to API functions.\n- cointerra: Remove nodev checks for now\n- cointerra: Replace reset semaphore with a simple notifier\n- Build cointerra driver\n- cointerra: Import driver from cgminer as-is\n- Silently ignore shares rejected if they were above target and only got\nsubmitted \"just in case\"\n- Abstract put_in_parens function\n- Abstract extract_reject_reason function\n- Remove dead code\n- Bugfix: bfg_cond_timedwait providing semantics expected for --cmd-idle\nimplementation\n- Per-processor TUI: Align columns for more-than-one proc letter\n- m4/bundled_lib: Workaround bug in autoconf <2.64\n- If full version is too long, try truncating it at '-'\n- Bugfix: Fix CPU miner benchmarking within benchmark-intense mode\n- benchmark: Detect duplicate shares within 5 minutes\n- benchmark-intense: benchmark_update_interval constant in code\n- benchmark-intense: Detect stale results\n- benchmark-intense: Update work every second\n- benchmark-intense: Simulate 250 KB generation transaction\n- benchmark-intense: Generate individual work items from 2D work (tests host CPU\nrate of work production)\n- Introduce --benchmark-intense option\n- Import libbase58 for base58 encoding/decoding\n- Cleanup libblkmaker bundling code to mostly live in autoconf macros\n- Always check if we should switch pools when enabling one, and always enable\npools we want to switch to\n\n\nBFGMiner Version 4.7.1 - September 10, 2014\n\n- Bugfix: Reorder LDADD and such for priority\n- Bugfix: bitforce: Initialise variable to NULL\n- Bugfix: SSM: Use client_next member consistently when working with\nstratumsrv_connlist\n- Bugfix: SSM: Check that a username is provided to mining.authorize\n- Bugfix: SSM: When n2pad<0, release lock before returning\n- Bugfix: SSM: Make buffers long enough to avoid overflows\n- Bugfix: Need signed types for ntime min/max offsets\n- Bugfix: rockminer: Fix processor disabling\n- rockminer: Limit even unsafe frequencies to 640 MHz, since above that\noverflows frequency bits and triggers fan control\n- tq_pop: Remove abstime argument since nothing used it and it wouldn't work\nanyway (uses CLOCK_REALTIME while we use CLOCK_MONOTONIC[_RAW] when possible)\n- Bugfix: Check last solo generation tx against new template rather than most\nrecent\n- README: Explicitly mention automatic solo mining configuration, and stress the\nimportance of --coinbase-sig\n- Bugfix: Recheck current_pool after calling pool_died\n- Bugfix: Stable pool recovery: Only care if the pool is enabled\n- README.ASIC: Add a section for Gridseed\n- Bugfix: benchmark: Free json_null() after use\n- Bugfix: minergate: Claim socket before we initialise a cgpu for it\n- Bugfix: avalonmm: Claim device before we initialise a cgpu for it\n- Bugfix: switch_pools: Broadcast lp_cond outside of control_lock to avoid\ndeadlocking\n- Protect enabled_pools by a mutex in disable_pool function\n- Combine reject_pool into disable_pool function, and don't allow it to override\na manual disable\n- Call disable_pool() at the begin of remove_pool() and combine them when\nappears together in the code\n- Bugfix: Always call enable_pool and disable_pool to ensure consistent handling\nof the situations\n- Remove dead CPU mining code to silence warnings\n\n\nBFGMiner Version 4.7.0 - August 17, 2014\n\n- openwrt/multibuild: Avoid copying bitforce-firmware-flash, which is no longer\nincluded\n- AUTHORS: Simpler design, alphabetise lists\n- Remove obsolete SuSE packaging\n- Bugfix: test_hash: Fix Htarg calculation for exact binary divisions of diff 1\n- Fix target calculation from diff < 1.0 in test_hash()\n- avalonmm: Try to autodetect a sane default voltage and clock from MM version\n- avalonmm: Only poll one module at a time, so they don't try to talk over each\nother\n- avalonmm: Set baud rate for detection\n- Stratum: Ignore response from mining.extranonce.subscribe\n- Stratum: Implement mining.set_extranonce, and advertise support for it to\npools with a #xnsub flag\n- Stratum: Keep nonce1 and n2size in a \"staging\" state until mining.notify is\nreceived\n- Stratum: Avoid putting new targets on pool stratum_work until mining.notify is\nreceived for it\n- minergate: Flush during init\n- minergate: Flush ready-to-queue list\n- minergate: Avoid preparing new jobs to queue while we are pending a flush,\nsince the flush would occur after queuing the new jobs\n- minergate: Check for reused job ids\n- minergate: Avoid counting flushed jobs toward hashes done\n- minergate: Report all temperatures individually to RPC\n- minergate: Load temperatures from stats file\n- minergate: Implement hashmeter\n- minergate: Scale nonce difficulty up to pdiff 32\n- minergate: Implement mining\n- minergate: Support for detecting a SP10\n- Bugfix: configure: avalonmm needs work2d\n- Bugfix: bitforce: Remove sanity check triggered by race conditions on 65nm\ndevices\n- Bugfix: bitforce: Avoid double-free of voltage data\n\n\nBFGMiner Version 4.6.0 - August 2, 2014\n\n- avalonmm: Even if no fans report speed, display set %\n- Bugfix: avalonmm: Fix fan speed setting\n- Bugfix: avalonmm: Actually read the result needed to get the correct module id\n- README.ASIC: Document AvalonMM driver usage with Avalon 2/3 rigs\n- Bugfix: Makefile.am: Remove reference to non-existent driver-avalonmm.h\n- avalonmm: Safely handle an improper job id that is within the last 2 sent\n- avalonmm: Include asserted fan speed in RPC\n- avalonmm: Include asserted fan speed in ManageTUI\n- avalonmm: Silence warning about detect ack at runtime\n- avalonmm: Make fan speed an option (both RPC and TUI)\n- avalonmm: Allow changing clock speed and voltage from Manage TUI\n- Bugfix: avalonmm: Show proper units for fans & voltage\n- avalonmm: Support for disabling the entire chain\n- Implement broad_udevrules for avalonmm\n- avalonmm: Show extranonce1, module id, temperatures, fans, clock, and voltage\nin Manage TUI\n- avalonmm: Include Module Id and ExtraNonce1 in RPC devdetails\n- avalonmm: Add Temperature0/1 and Fan Percent 0/1 to RPC\n- avalonmm: Add Frequency and Voltage to RPC\n- avalonmm: Add voltage setting (defaults to 0.6625 V)\n- avalonmm: Add clock setting and try to autodetect it if not provided\n- avalonmm: Implement hashmeter\n- avalonmm: Adjust device target up to pdiff 32 when possible\n- avalonmm: Update job when current pool changes\n- Bugfix: avalonmm: MM flips the xnonce2, so we need to do the same\n- avalonmm: Implement mining logic\n- lowl-spi: Move bit order reverse to bitflip8 function in util\n- avalonmm: Treat multiple chained modules as slaves rather than processors\n- avalonmm: Probing for devices using Avalon Miner Manager (Avalon2/3 rigs)\n- littlefury: Move crc16 logic to util\n- Use BUILT_SOURCES to ensure version.h is always built first\n- configure option --with-udevrules-group to allow customising the group name\nused\n- Bugfix: zero_stats: Only call cgpu function if it exists\n- Remove FPGA-only bitforce-firmware-flash tool (now located at\nhttps://github.com/luke-jr/bitforce-fpga-firmware-flash )\n\n\nBFGMiner Version 4.5.0 - July 26, 2014\n\n- Bugfix: zeusminer: Fix crash in TUI with newly introduced feature\n- Bugfix: gridseed: Fix crash in TUI with newly introduced feature\n- gridseed: Add the ability to set clock speed via the TUI\n- bitforce: Support for Monarch devices on Windows using new \"mswin\" lowlevel\ninterface to scan for KMDF driver\n- Bugfix: gridseed: Implement a proper scanhash routine for GridSeeds\n- zeusminer: Add the ability to set clock speed via the TUI\n- Bugfix: gridseed: Only set PLL frequency once (not once per processor)\n- Bugfix: zeusminer: Retry detection on failure - ZM fails detection 1 / ~30\ntimes\n- Bugfix: zeusminer: Enabling the ZeusMiner driver should flag needing lowl-vcom\n- aan: Silence false warnings\n- Include broad udev rules when configured with --enable-broad-udevrules option\n- Bugfix: util: Lower the threshold for considering pool Scrypt diff broken\n- Bugfix: gc3355: Do not send work_id (or anything) in the last 4 bytes of work\n- gridseed: Refactor code to clean up and organize\n- gridseed: Document GridSeed specifics with comments and URLs\n- Copyright cleanups and updates\n- Bugfix: zeusminer: using icarus timing can lead to false positive Idle\ndetection\n- zeusminer: Return the Chip # via the RPC API call procdetails\n- zeusminer: Display the Chip # in the UI when viewing per-proc details\n- Bugfix: miner: Check work->blk.nonce to see if work should be abandoned\n- rockminer: Allow setting clock 300-2560 as long as prefixed by \"unsafe:\"\n- util: Work around broken Scrypt pools automatically using realistic pdiff\nassumptions\n- scanhash: Document scanhash related methods with comments\n- Bugfix: gridseed: Report communication errors using dev_error()\n- gc3355: Return bytes read to distinguish 0 bytes from error\n- Bugfix: gridseed: Add delay between Scrypt reset and sending work\n- gridseed: Bugfix: fix the constant used for estimated hash rates\n- klondike: zero_stats support\n- bitforce: zero_stats support (Temperature, Voltage, and Avg Wait)\n- avalon: zero_stats support (temp_max, no_matching_work, match_work_count%d)\n- Add driver interface for zero_stats function\n- Bugfix: bitforce: Short-circuit bitforce_read(0) to avoid lowlif issues\n- Bugfix: bitforce: Ensure data for the current command is always read (and only\nonce), with lowl-pci\n- Bugfix: setup-vfio: Add device ids to vfio-pci even if they didn't have a\ndriver previously\n- Bugfix: lowl-pci: Use volatile qualifier for PCI mmaps\n- Bugfix: bitforce: Use lowlevel interface device was probed with, for actual\nmining\n- setup-vfio: New shell script to automatically configure VFIO\n- README.ASIC: Monarch: Need to do new_id for every affected device, and only\nafter unbinding them\n- README.ASIC: Monarch: Use shell variables for commands\n- gridseed: Bugfix: Revert earlier changes to scanhash based on feedback\n- hashfast: Support for changing clock at runtime\n- hashfast: Store a copy of what we believe to be the chip configuration data\n- hashfast: Store firmware revision\n- util: pk_uNle macro for changing a number inside a packed structure\n- README.ASIC: KnCMiner: Talk about additional i2c-tools dependency\n- README.ASIC: KnCMiner: Remove mention of now-obsolete Bertmod\n- README.ASIC: KnCMiner: Grammatical corrections\n- Bugfix: RPC: Avoid processor-specific details in devdetails\n- gridseed: Bugfix: log invalid detect responses as debug info, not an error\n- zeusminer: Support setting clock via RPC API procset call\n- README: Add Controla and Minera controller software links & info\n- gridseed: Bugfix: Fix hash-rate calculation when no nonces are being found\n- dualminer: Bugfix: assign the proper value for work_division\n- gridseed: Refactor to clarify GridSeed terminology\n- gridseed: Add support for displaying per-chip statistics\n- gridseed: Convert to use newer set_device_funcs interface\n- Bugfix: gridseed: Don't leak cgpu_info when devices are already claimed\n- icarus: Processor detail support\n- DevAPI: Allow using device_proc_by_id with const struct cgpu_info\n- icarus: Ensure fpga_count is finalised before add_cgpu is called\n- icarus: Move work_division autodetection code into new\nicarus_probe_work_division function\n- icarus: Remove ability to change fpga_count at runtime\n- Bugfix: gen-version.sh: Replace bashism (\"here string\")\n- gridseed: Support devices with more than 255 physical processors\n- Use `git describe` to generate version.h to avoid user confusion over builds\nfrom git\n- zeusminer: Support devices with more than 255 physical processors\n- hashfast: Include chip/core address in RPC procdetails\n- gridseed: Reduce traffic sending work to GridSeed devices\n- gridseed: Bugfix: previous refactor (unpublished) changed logic\n- gc3355: Refactor to remove SHA2 code specific to the 5-Chip GridSeed Orb\n- lowl-vcom: Bugfix: do not attempt to open the USB devices when enumerating\n\n\nBFGMiner Version 4.4.0 - July 7, 2014\n\n- Update official Windows build compiler from GCC 4.7.3 to 4.7.4\n- lowl-vcom: Added support for auto scanning (-S auto) on Mac OS X\n- rockminer: implement --device-protocol-dump for debugging\n- README: Update for commandline options\n- README: Update configure options\n- Bugfix: bfg_gpio_setpin_output: Clear alt-function bits via INP_GPIO macro\n- jingtian: Explicitly configure SPI device while opening\n- jingtian: Toggle ASIC reset GPIO at startup\n- aan: Set defaults as soon as a proc is initialised\n- aan: Allow specifying clock as xHEXX for a raw PLL register config\n- aan: Include current frequency in RPC status\n- aan: Implement --set jtn:clock=MHz\n- aan: Logic to calculate PLL configurations for a given frequency\n- jingtian: Use SPI enable GPIO to disconnect SPI during chipselect changes\n- aan: Set PLL to 850 MHz\n- aan: Simplify register buffer\n- jingtian: Decode extra temperature bytes in read_reg\n- aan: Add a read_reg hook\n- aan: Enable configuring nonce diff with (eg) --set jtn:diff=32\n- aan: Properly handle nonce_diff\n- aan: Implement mining\n- DevAPI: Some designs set the main thr tv_poll from secondary thrs, so check it\nafter the loop\n- aan: aan_spi_parse_rx implies spi_clear_buf\n- jingtian: Do detection asynchronously across all possible chipselects so they\ncomplete in parallel\n- aan: Refactor aan_spi_cmd a bit\n- jingtian: Implement device protocol dump\n- jingtian: Detection-only code for new driver\n- lowl-spi: GPIO access functions\n- lowl-spi: Move knc_spi_txrx to linux_spi_txrx\n- SGW: Support for proxy-share difficulty preferences\n- SSM: Propagate proxy-share difficulty changes to established connections\n- SSM: Track stratum connections for each proxy user\n- SSM: Track authorised users for each connection\n- SSM: Initialise proxyshare difficulty from --set pxy:diff=N\n- proxy: Accept --set pxy:diff=N to set preferred proxyshare difficulty\n- proxy: Provide a place to store desired proxyshare difficulty on a\nper-username basis, and copy it to SSM connections when authorising them\n- SSM: Track proxy share difficulties\n- Expose target_diff function and add pdiff_to_bdiff macro\n- util: double_find_precision function to identify ideal precision for a fp\nnumber\n- work2d: Expose WORK2D_MAX_DIVISIONS in header\n- add_local_gbt: Avoid adding servers already configured\n- Bugfix: Avoid writing automatically configured local GBT servers to the config\nfile unless they have been manually enabled\n- add_local_gbt: Use rpcconnect when configured\n- rockminer: Bugfix: must specify a baud rate (maximum of 115200) to get a read\nresponse\n- Bugfix: Use atexit() to ensure a final \\n is always printed at exit to work\ncleanly with new logging design\n- Restore compatibility with old versions of libblkmaker\n- Bugfix: probe for ZeusMiner before probing for DualMiner\n- Wait until coinbase-addr is needed again, before updating it following a block\nchange (always using getaccountaddress)\n- Don't automatically use #getcbaddr for local bitcoind if the user provided\ntheir own\n- Bugfix: refresh_bitcoind_address: Check for NULL json (which is not JSON\n\"null\")\n- Bugfix: add_pool: If no current pool set, initialise it (otherwise pool\ntesting may start a longpoll thread which tries to access currentpool\nuninitialised)\n- devpath_to_devid: *nix: Reject anything that doesn't begin with a /\n\n\nBFGMiner Version 4.3.0 - June 30, 2014\n\n- Bugfix: zeusminer: Include config.h\n- openwrt: Disable libusb via --without-libusb\n- Avoid waiting for local bitcoind test if we have other pools defined already\n- lowl-pci: Silence warning on big endian\n- bitfury: Portability fixes, including big endian compatibility\n- Bugfix: bifury: strtoll already implies native endian, no need to flip it\nagain\n- bitforce: Additional sanity checks, including ensuring our final queued count\nmatches that seen by the device\n- bitforce: Go back to ignoring race-triggered sanity check warnings for ZqX\n- bitforce: Refactor FLB and queue flush sanity checks\n- bitforce: Use binary FLB protocol for Monarch\n- bitforce: Add bitforce_read function to deal with binary responses\n- bitforce: Support for queue id based jobs\n- Make work->device_id unsigned\n- bitforce: Support device explicit \"Scan Interval\" to override hardcoded sleep\ntimes\n- bitforce: Allow queued_max to exceed BITFORCE_MAX_QUEUED_MAX iff the firmware\nprovides an explicit Queue Depth\n- bitforce: Fix bitforce_chips_to_plan_for to work beyond 32 chips\n- configure: Clean up zeusminer logic\n- icarus: Use estimated hashes for hw errors (more accurate hashrate for devices\nwhere hw error values vary significantly from hashes performed)\n- zeusminer: Bugfix: calculate work_division based on chips and cores\n- Replace swabn with bswap_32mult (matching swap32yes parameters and\nperformance)\n- Bugfix: zeusminer: Correctly encode job header regardless of native endian\n- zeusminer: support added for ZeusMiner scrypt ASICs\n- icarus: refactoring: commenting ICARUS_INFO members\n- icarus: Accept any power of two as a valid work_division\n- icarus: option added for Icarus-based drivers to ignore the golden nonce\nduring probe\n- util: is_power_of_two function\n- Bugfix: Display proper statline R and HW error percents for values < 1\n- openwrt: Provide scrypt option\n- Benchmark: Debuglog headers generated\n- Bugfix: cpu: Fix scrypt CPU miner\n- Bugfix: scrypt: Fix scrypt hash postprocessing for big endian\n- Bugfix: scrypt: Correct endian handling in PBKDF2_SHA256_80_128\n- scrypt: Add unit test for scrypt_1024_1_1_256_sp\n- scrypt: Add unit tests for PBKDF2_SHA256_80_128 and salsa20_8\n- Bugfix: Copy ALL the data with swap32to<native>\n- Automatically add pool configured from bitcoin.conf for failover only\n- Add failover_only pool flag, to avoid using it regardless of strategy\n- Accept --default-config option to search and load default configuration files,\neven if user is specifying their own\n- Use appdata_file_call to find BFGMiner config file(s)\n- util: appdata_file_call and appdata_file_find_first functions\n- ccan: Update to latest version (which includes floatval option support)\n- Bugfix: Adapt quit function to new logging design\n- Workaround GCC 4.6 initialisation bugs with BYTES_INIT\n- Bugfix: Use int rather than ssize_t to type-match %d expectation\n- Minor refactor of text-only mode: avoid wasting bottom line of console, and\nsave status lines as they are replaced by log items\n- Bugfix: Wake up wait_lpcurrent if its conditions for returning may have\nchanged\n- Defer determining --quit-summary default until it is needed, so hotplugged\ndevices affect it\n- Bugfix: In benchmark mode, only remove the new pools after putting them in the\narray, since the removal will try to remove it from the array\n- Bugfix: Initialise struct pool in add_pool rather than halfway through startup\n- URI parameter #getcbaddr to request coinbase address from bitcoind or\ncompatible servers\n- pool_set_uri function\n- util: bytes_eq and bytes_assimilate\n- Replace struct _cbscript_t with bytes_t for simplicity\n- Bugfix: Parse userpass option with strchr rather than strtok to avoid\nusernameless passwords getting into the username field and being displayed\n- Bugfix: Free old coinbase script before setting a new one\n- util: upper_power_of_two_u32 function\n- Avoid unnecessarily finding drivers in a loop\n- lowl-pci: Never probe via -S *:all\n- configure: Succeed even if the libblkmaker submodule is missing (only\n--with-system-libblkmaker)\n- rockminer: Reset task timeout when queuing work\n- rockminer: When we detect a task failure, check if we ought to grab a new work\nrather than resend\n- rockminer: Add a time limit before resending work even outside of midtask\nstate\n- Bugfix: rockminer: Keep count of requested jobs properly\n- make-release: Include ccan LICENSE symlinks as symlinks even in ZIP\n- make-release: Ensure ccan licenses get included in source\n- Bugfix: make-release: Correctly avoid unused parts of ccan\n- make-release: Do builds with the official source release, to test that it\nworks\n- Bugfix: DevAPI: Make for_each_logical_proc work correctly\n- Avoid double hashing of shares\n- Create work_hash function to abstractly produce work->hash from work->data\nregardless of algorithm used\n\n\nBFGMiner Version 4.2.0 - June 11, 2014\n\n- Upgraded Windows libmicrohttpd from 0.9.35 to 0.9.38_pre33603\n- SGW: Workaround BE Cube bugs with new libmicrohttpd by forcing HTTP 1.0\nresponse\n- rockminer: Increase hw error count for problems\n- rockminer: Autodetect with \"R-BOX miner\" or \"RX-BOX miner\" product strings\n- rockminer: Support for seeing and setting clock frequency in Manage TUI\n- rockminer: Include clock frequency in RPC processor status\n- rockminer: Support for setting clock frequency\n- rockminer: Workaround lost tasks by resending them\n- rockminer: Support for temperature sensors\n- rockminer: Debug messages\n- Bugfix: rockminer: Initialise rockminer_chip_data\n- Bugfix: rockminer: Ensure work actually exists before testing against it\n- rockminer: Mine at 270 MHz\n- rockminer: Implement mining (at 200 MHz)\n- DevAPI: Move device_proc_by_id out of bifury driver, since it is generically\nuseful\n- rockminer: Detection code for new driver\n- bfg_socket wrapper to ensure sockets are close-on-exec\n- set_cloexec_socket: Explicitly cast SOCKET to HANDLE\n\n\nBFGMiner Version 4.1.0 - June 6, 2014\n\n- Bugfix: Ensure variables are declared even without ADL support\n- RPC: Include a list of config files loaded in \"config\" reply\n- Bugfix: Save a linked list of config files loaded so output makes sense\n(previously only the most recent config file was named, and errors were reported\ninconsistently)\n- README.RPC: Document Coinbase-Sig in config reply\n- Bugfix: Safely handle pool status line when no pools are alive\n- bitforce: Refactor bitforce_vcom_gets slightly to be more sane\n- Bugfix: initiate_stratum: Ensure extranonce2 size is not negative (which could\nlead to exploits later as too little memory gets allocated)\n- Stratum: extract_sockaddr: Truncate overlong addresses rather than stack\noverflow\n- Stratum: tlsca parameter to require CA validation of TLS certificate\n- Bugfix: Avoid setting tv_idle before testing pool (it will be set if the test\nfails)\n- restart_stratum: Make use of return_via\n- return_via helper function family to assign a variable and goto\n- Bugfix: restart_stratum: Release pool_test_lock on failure\n- bfsb: Disable all banks before enabling the one we want, to avoid having two\nenabled at the same time (eg, when switching from bank 3 to bank 2)\n- Interpret present \"tls\" parameter to require TLS\n- uri_get_param_bool2 returning a tristate\n- Tests for uri_find_param\n- Split uri_find_param out of uri_get_param_bool\n- gridseed: Allow specifying an arbitrary number of chips with --set gsd:chips=X\n- gridseed: added support for the 80-chip (two blades of 40 chips) G-Blade\nScrypt-only miner\n- Bugfix: gridseed: use a signed integer so that returning -1 has defined\nbehavior\n- RPC: Return integer difficulties without decimal places\n- Bugfix: Zero pool \"Works\"\n- Bugfix: Set any listening sockets to close-on-exec/non-inheritable to avoid\nissues rebinding them on restart\n- RPC: Explicitly shutdown communication on client sockets to avoid them being\nheld open by forked processes\n- RPC: Clean up mcast socket with tidyup_socket\n- RPC: Move socket tidyup code to its own function\n- Bugfix: RPC: Use pthread_exit rather than returning from the RPC thread, to\nensure tidyup gets called\n- Bugfix: bitforce: During initialisation, clear each XLink slave exactly once\nonly\n\n\nBFGMiner Version 4.0.0 - May 26, 2014\n\n- Update openwrt Makefile for xz source\n- Update libblkmaker to 0.4.0\n- Workaround Homebrew-induced segfault during device scan\n- Allow hotplug with scrypt\n- Bugfix: test_domain_funcs: printf precisions must be int, not size_t\n- littlefury: Cleanup to make avoiding memory leak easier\n- Bugfix: Avoid using an enum type to hold a bitfield\n- ruby extension is \"rb\" not \"py\"\n- README.RPC: Document api-example.rb\n- Add Ruby Api Example\n- hashfast: Check devices with Product matching \"GoldenNonce\" so we have a\nvendor-neutral way to detect them\n- Reduce set_device-not-implemented message to debug log level, since it can\noccur for init-only settings\n- Use a mutex to block pool_active on a common check per pool at any given time\n- Use cURL return code to check if cURL sockets hit CURLE_AGAIN\n- Abstract pool_recently_got_work into a dedicated function\n- AUTHORS: Dmitry Smirnov contributes BFGMiner packaging to Debian\n- README: Talk about more GUIs and mining OSs\n- icarus: Minor optimisation (swap byte order in 32-bit always-aligned groups,\nand skip pointless memory copy)\n- icarus: Initialise ob_bin to avoid leaking other memory to device\n- Bugfix: bitfury: Set stat_elapsed_secs early, just in case we jump with goto\n- Bugfix: Report actual kernel name in RPC, rather than kernel interface name\n- README.scrypt: Document psw kernel\n- opencl: Another optimised scrypt kernel (\"psw\")\n- README.scrypt: Document zuikkis kernel\n- opencl: Optimised scrypt kernel (\"zuikkis\")\n- Bugfix: Silence harmless warnings\n- Bugfix: vcom_set_timeout: Return whether successful\n- bitforce: Set name for ASIC devices\n- Bugfix: Avoid unnecessary rescans due to wrong devtype\n- bitforce: Support 28nm ChannelNN format for ZCX\n- Bugfix: bitforce: Don't confuse channels with X-Link\n- Bugfix: bitforce: Set VCOM timeout to 1 second for ZGX request, since it\nsometimes lacks a newline\n- lowl-vcom: vcom_set_timeout function\n- bitfury: Eventually (after 30 seconds) give up trying to detect chip\ngeneration and just assume gen1\n- bitfury: Use other nonces for gen1 detection so one bad core can't break it\n- Bugfix: bitfury: Account for necessary nonce fudging during chipgen detection\n- gridseed: Switch from the Queued miner loop to the Scanhash miner loop\nImproves performance on Raspberry Pi Fixes inaccurate hashrate estimates Fixes\nbug overwriting work inadvertently\n- If the current pool lacks its own block change detection, keep the pool used\nfor that connected\n- pool_active_lp_pool function to complement select_longpoll_pool\n- Track which pools have active longpoll connections\n- Avoid retrying longpoll requests for removed pools (and possibly change block\nchange notification source for existing ones) if longpoll connection gets\ndropped\n- util: Pass full json_rpc_call_state to upload_data_cb\n- Remove now-unused variable\n- nanofury: Update enable/disable/reinit to cleanly handle multichip devices\n- bifury: Default max_queued to chips * 5 + 6 so it is back up to the original\n16 for bi*fury (which seems to need it sometimes)\n- bifury: Default max_queued to chips * 5 for extra breathing room (avoids\noccasional issues with Hex*Fury)\n- README.ASIC: Document workarounds for OSM/Hex*Fury firmware bugs\n- bifury: Measure hashes done by nonces found since we cannot tell what\ngeneration chip is in use\n- bifury: Default max_queued to chips * 4\n- bifury: chips init setting to workaround buggy hardware which reports wrong\nchip count\n- bifury: free_after_job setting to workaround buggy hardware which ignores\nmaxroll\n- bfg_strtobool helper function\n- bifury: Enable runtime modification of max_queued\n- bifury: Migrate to set_device_funcs interface\n- Stratum: Accept a \"notls\" parameter on pool URIs to disable opportunistic TLS\n- uri_get_param_bool helper function for pool parameters\n- nanofury: Only ramp up osc6_bits on multichip devices\n- Bugfix: nanofury: Move the bitfury pointer back to the last element before\nstarting the ramp up loop\n- Bugfix: Use pdiff 1/0x10000 for scrypt benchmarking\n- benchmark: Use sane bits (of a very high difficulty to avoid triggering\nanti-reorg protections)\n- Ignore work difficulty minisculely harder (ie, rounding error) than what\ndevice supports\n- Benchmark: Add 2D work support\n- SSM: Use a lower share difficulty in scrypt mode\n- Rework test_nonce to share common logic for scrypt and SHA256d\n- work2d: Accept nonce difficulty with submissions\n- configure: Make work2d building abstract from libevent\n- work2d: Standardised way to pad extranonce beyond what work2d manages\n- Abstract code from stratumsrv_mining_submit into new work2d_submit_nonce\nfunction\n- Avoid handling hex encoding in work2d\n- Move/rename _ssm_gen_dummy_work to work2d_gen_dummy_work\n- SSM: Refactor _ssm_gen_dummy_work to work with struct stratum_work instead of\nstruct stratumsrv_job\n- Move \"nonce1\" session id from struct pool to struct stratum_work\n- Add pool and work_restart_id to struct stratum_work so they can be used\nindependently of struct pool\n- Move n2size from struct pool to struct stratum_work\n- autogen.sh: Automate cleaning INSTALL out of libblkmaker so git updates\nproperly\n- Update libblkmaker to 0.4.0\n- Replace drv_rolllimit with struct ntime_roll_limits\n- util: Unpack and pack utility functions ([u]pk_u{8,16,32}{le,be})\n- GBT: Do not allow drivers to roll ntime\n- GBT: Use libblkmaker 2D work to service SSM and potentially other 2D work\ndrivers\n- Hide blktemplate_t behind bfg_tmpl_ref to abstract reference counter\n- Add pool_has_usable_swork function\n- SSM: Split stratum work division into 2D work manager (\"work2d\")\n- bitforce: Avoid crashing when broken devices report more jobs flushed than\nthey had to flush\n- nanofury: Gradually ramp up osc6_bits for NF6 design\n- util: memrchr is not portable (GNU extension), so implement our own my_memrchr\n- bitfury: Report correct hashrate for gen2 chips\n- bitfury: Detect gen2 chips\n- Stratum: If difficulty calculates out to 0.999 to 1, round it up to 1 to avoid\nsomething SHA2 hardware cannot handle\n- Stratum: If the pool target has changed since the job a work came from, check\nany shares against the new target too in case it expects retroactive difficulty\nadjustments\n- Stratum: Interpret integer difficulty values as pdiff (or Ldiff, for scrypt)\nto avoid losing shares on non-compliant servers\n- Rework difficulty-to-target functions to error on the safe side, and\nconsistently work in pdiff or bdiff\n- Simplify stratum to convert difficulty to target immediately\n- Stratum: Attempt connection with unauthenticated TLS, with failover to raw TCP\n- Stratum: Return to curl_easy_{send,recv}\n- get_registered_domain: Return full IP for raw IP addresses, so they can at\nleast redirect to the same IP\n- Reject redirection across different registered domain names (can be disabled\nby appending #redirect to pool URI)\n- util: match_domains function\n- util: Add isCalpha, get_registered_domain, and extract_domain functions\n- README: Update for gridseed 5-chip orb\n- configure: Clean up gridseed logic to only build by default when scrypt is\nenabled\n- gridseed: Fix warnings\n- gridseed: Added support for Scrypt hashing with 5-chip GridSeed devices\n- dualminer: Only one debug message needed for all init options\n- dualminer: Move opt_dual_mode to dualminer file\n- gc3355: move scrypt_only_reset_cmd out of scrypt_only_reset\n- dualminer: No need to reconfigure frequency every work\n- dualminer: refactor gc3355 code for readability, maintainability and use with\nother devices\n- dualminer: Abstract dualminer_init_hashrate out of dualminer_init_firstrun\n- dualminer: Initialise opt_pll_freq along with opt_sha2_units\n- dualminer: Move opt_sha2_units initialisation to new dualminer_set_defaults\nfunction\n- dualminer: Remove unnecessary opt_sha2_number\n- dualminer: Simplify teardown\n- dualminer: No need to parse strings for SHA2 unit counts\n- gc3355: Support for appending jobs with task id\n- gc3355: increase delays to 20ms\n- gc3355: use NULL for end-of-command terminator\n- dualminer: comment what various things are for and/or do\n- dualminer: Split gc3355_scrypt_prepare_work and gc3355_sha2_prepare_work out\nof dualminer_job_prepare\n- dualminer: Use cgsleep_ms rather than usleep\n- gc3355: Remove unused opt_hubfans variable\n- dualminer: rename various things to be clearer\n- Use a common enum bfg_gpio_value for both lowl-vcom (cts, dtr, rts) and\nmcp2210\n- README.RPC: Document quit/restart reply format change\n- RPC: Provide a full status section for quit/restart commands\n- RPC: Add \"Miner\" to version response to include software name along with\nversion\n- Bugfix: Dereference udev monitor events when done with them\n- opencl: Workaround false warning regarding Mesa version number parsing\n- knc: use_dcdc setting that Nov batch users can use to disable DCDC usage\n- configure: Include <stddef.h> for _Static_assert check\n- opencl: If kernel does not specify an interface in scrypt mode, assume it's\nthe scrypt interface\n- opencl: Replace dated versioning with hash of source code\n- opencl: Search all the same kernel paths when setting kernel\n- opencl: Accept arbitrary kernel filenames, provided they specify a kernel\ninterface somewhere in the source file\n- Bugfix: Explicitly pass precision and width as int type\n- Make pool stability message use nicer English\n- Failover pool switching back delay is now configurable.\n- Expand extranonce2 size to 64-bit\n- README.ASIC: KnCMiner: Suggest --disable-other-drivers and remove\nno-optimisation CFLAGS\n- configure: libusb is implied by lowl-usb, so no need to list it as an option\nseparately\n- Silence warnings when built without various drivers\n- DevAPI: Remove long deprecated serial_detect function family\n- Bugfix: Turn spidevc into lowl-spi to fix building the knc driver without the\nbitfury driver\n- Avoid triggering unnecessary device rescans (such as with pre-lowlevel\ndrivers)\n- Replace --no-client-reconnect with --no-pool-redirect which also disables\nX-Stratum header redirects\n- Partial: A new --no-client-reconnect command that disables the\n'client.reconnect' function.\n- ftdi: Rename files to lowl-ftdi.{c,h} to fit with naming convention\n- bfx: New driver for BFx2 Bitfury USB stick miners\n- ftdi: ft232h_mpsse_readwrite_all function to do both reading and writing\nconcurrently in MPSSE mode\n- ftdi: ft232h_mpsse_set_axbus function\n- ftdi: Support for ft232h MPSSE mode (currently only works with\nft232r_write_all)\n- ftdi: Split most of ft232r_open into a ftdi_common_open function\n- ftdi: Support for --device-protocol-dump\n- ftdi: Scan for ft232h-based devices\n- ftdi: Avoid neutering lowlevel_device_info when opening it\n- ftdi: Accept const data in write functions\n- ftdi: Use actual USB packet size for FTDI status removal\n- ftdi: Make ftdi lowlevel code independent of x6500 driver\n- dualminer: Workaround false compiler warning in gc3355_config_cpm\n- Bugfix: --disable-other-drivers should not force libusb to be unused\n- Bugfix: README: Alphabetise and categorise build configuration options (and\nadd missing ones)\n- TUI: Use _wlogprint for pool proto to avoid compiler warning\n- Bugfix: TUI: Fall back to RPC URI if sockaddr_url hasn't been extracted (such\nas benchmark mode)\n- Hide work update messages unless explicitly enabled with hidden\n--verbose-work-updates flag\n- TUI: Redesign pool info line to include share difficulties in multipool modes\nand last explicity work update timestamp\n- nanofury: Abstract both power gpios into a nanofury_power_enable function\n- nanofury: Add NANOFURY_GP_PIN_PWR_EN0 (inverted PWR_EN) - support for power\nmanagement (hardware) optimizations\n- Bugfix: nanofury: Set cgpu_data for all processors (eg, to avoid crashing in\nnanofury_set_ledmode for non-first procs)\n- Bugfix: nanofury: Use correct SPI port for baud setting\n- proxy: \"Report in\" clients when their info is looked up by username\n- opencl: Replace (and deprecate) --no-opencl-binaries option, with --set\nopencl:binary=no\n- opencl: Reenable OpenCL kernel binaries for Mesa OpenCL >= 10.1\n- gc3355: Replace frequency-setting hex blobs with logic\n- README: Update for DualMiner\n- make-release: Switch to xz for source releases\n- Stratum: If a pool explicitly tells us it doesn't support get_transactions, no\nneed to wait for a timeout\n- api - buffer size off by 1 for joined commands\n- miner.php - define a default rigport (that can be changed) and don't require a\nport number in the rigs array\n- miner.php allow links for rig buttons in tables and allow using the 4th IP\noctet if no rig name - default disabled for both\n- Remove wrong goto\n- Remove the unqueued work reference when we discard work from get queued as'\nwell.\n- Wake the global work scheduler when we remove a work item from the unqueued\nwork pointer.\n- Discard work that is stale in the get_queued() function, returning NULL\ninstead.\n- Bugfix: dualminer: Declare support for both SHA256d and scrypt algorithms\n- gc3355: Use lowl-vcom set_serial_dtr function\n- lowl-vcom: Implement set_serial_dtr\n- gc3355: Use lowl-vcom cts/rts functions\n- lowl-vcom: Implement set_serial_rts for Windows\n- lowl-vcom: set_serial_rts should return the new rts value, if anything\n- Rename icarus-common.h to driver-icarus.h\n- icarus: probe_timeout setting to control how long we wait before giving up on\nprobes\n- icarus: Defer initial open until init\n- Remove debugging garbage that snuck in\n- configure: New --disable-other-drivers options for users who want to build\njust select drivers\n- Simplify _now_gettimeofday on Windows, working around weird WINE crash\n- cpu: Fix and simplify benchmarking on Windows (removes hidden --bench-algo\noption)\n- Remove old bench_block.h, no longer needed\n- Bugfix: cpu: Adapt benchmarking code to new benchmark work generator\n- Report precise share difficulties below 1\n- Bugfix: lowlevel: Pretend drivers not matching the active algorithm don't\nexist\n- Bugfix: dualminer: Set min_nonce_diff before getting work\n- Bugfix: gc3355: Use correct byte counts for hex2bin\n- configure: Fix up dualminer logic\n- dualminer: Support for mining both Scrypt and SHA2 using DualMiner GC3355\nthumb sticks\n- miner: scan for low level devices even if --scrypt is specified by the user\n(to detect Scrypt ASICs)\n- icarus: output protocol information if the user specifies\n--device-protocol-dump\n- icarus: Support for driver-specified job command lengths\n- icarus: Support for custom driver job start function\n- icarus: Support for custom driver initialisation function\n- icarus: Call icarus_job_prepare via driver job_prepare key so it can be\noverridden\n- icarus: generic support for devices that return little-endian nonces\n- icarus: allow custom probes\n- icarus: expose do_icarus_close\n- RPC: Remove separate CPU and GPU counters from devs Msg\n- RPC: Optimise find_index_by_cgpu\n- Bugfix: RPC: Restore PGA index counting\n- Accept decimal values for --shares, and clarify weighed nature of the value\n- benchmark: Remove all real pools, and prevent adding them\n- benchmark: Fake submission of \"shares\"\n- benchmark: Roll data before nonce only\n- Bugfix: configure: Report bitforce:pci instead of bitforce:uio\n- bitforce: Workaround broken/old compilers by setting device_fd outside of\ninitialisation\n- AUTHORS: Update email for Kano\n- RPC: Add \"MHS rolling\" key to status mirroring \"MHS %ds\"\n- minorfix: remove extra semicolon\n- Drillbit: Revert needless commit 270c1d01f, thanks @luke-jr\n- Drillbit: Add upper and lower bounds to \"Eight boards have a multiple of 8\nASICs\" check\n- Drillbit: Clarify use of device_data pointer to store capabilities/protocol\nversion temporarily\n- Drillbit: Keep reading work for as long as the device returns results.\n- Drillbit: Be strict about not accepting any boards with newer protocol\nversions. Protocol version bumps are non-backwards-compatible.\n- Drillbit: Add support for \"protocol version 4\", non-device-specific\nconfiguration packet format\n- README.RPC: Add link to Node.js RPC wrapper\n- opencl: Get temperature and fan speed updates with get_stats interface rather\nthan abusing statline override interface\n- Bugfix: Remove devtype variable from driver API\n- opencl: Deprecate --auto-{fan,gpu} and --gpu-dyninterval options\n- opencl: Infer autoengine mode when the clock setting receives a range\n- opencl: Infer autofan mode when the fan setting receives a range\n- Bugfix: opencl: Defer initial intensity assignment until init, so opt_scrypt\nhas a chance to be set\n- opencl: Strip leading and trailing spaces from names\n- trimmed_strdup helper function\n- icarus: Replace hard-coded \"Icarus\" mentions\n- opencl: Deprecate all dedicated commandline options for parameters accessible\nvia set_device\n- opencl: Make current intensity, xintensity, and oclthreads available via RPC\n- opencl: Redo Manage TUI detail line to use xintensity when more reasonable\n- opencl: Support for setting oclthreads as intensity=xNNN (for NNN xintensity);\nalso allow setting d<whatever> for an initial dynamic intensity\n- opencl: Store oclthreads and only convert to/from intensity numbers when\ndealing with external interfaces\n- RPC: Deprecate all cpu* and gpu* commands, and remove CPU/GPU counts from\n'devs' response\n- RPC: pgarestart command to match {cpu,gpu}restart\n- RPC: Unify common code under get_pga_cgpu function\n- README.RPC: Deprecate gpu{intensity,mem,engine,fan,vddc} now that they can be\naccessed via {pga,proc}set\n- RPC: Consider CPU and OpenCL devices as \"PGAs\" to begin migration to a simpler\ninterface\n- RPC: Turn gpu{intensity,mem,engine,fan,vddc} into wrappers around set_device\n- opencl: Support configuration using set_device interface\n- Bugfix: miner_thread: Don't call cgpu_set_defaults if it has already been\ncalled\n- Common add_set_device_option for automatically generated --set-device options\n- Bugfix: opencl: Safely handle work->device_data across work copies and cleans\n- set_device: Accept underscores for temp_{cutoff,target}\n- opencl: Allow specifying a comma separated list for --gpu-threads\n- opencl: _SET_INT_LIST2 to set variables not necessarily within\nopencl_device_data\n- hashfast: Enable setting device-wide clock at probe time using USB_INIT\n- Bugfix: hashfast: Use signed type for manipulating raw temperature data, in\ncase it is below 0 C\n- hashbusteravalon: Add udev rule\n- klondike: Split up work and submissions among logical processors\n- klondike: Make reply_wait_time a settable variable (configured lower for\nhashbusteravalon)\n- klondike: Explicitly enable slaves as well as the master\n- hashbusteravalon: Klondike-based metadriver\n- klondike: Pre-initialise klninfo separately from probe\n- klondike: Allow setting max_work_count and max_work_time via set_device\n- klondike: Variablise max_work_count and old_work_ms\n- Move all OpenCL-specific data behind device_data pointers, and relocate\nOpenCL-specific code out of miner.c\n- opencl: Macro-ise code for list options\n- Reduce failure applying set-device rules to debug loglevel\n- Add --set as alias for --set-device\n- Bugfix: miner.c: Correct ccan include\n- Bugfix: Correct ccan-upstream directory include\n- Load default config before commandline options, so the latter override the\nformer (but prioritise defaultconfig pools last)\n- configure: Check for sys/termios.h used by ccan/opt\n- make-release: Only include specific components of ccan\n- Use git submodule for ccan (moving opt_*_floatval into miner.c)\n- Probe erupter before icarus, since they are far more common now\n- Accept --no-config option to inhibit loading default config file, even without\nspecifying another config\n- Bugfix: RPC: Ensure isjoin always gets initialised\n- bitforce: Remove two really-unused variables\n- nanofury: Silence false warning from some compilers about uninitialised\nvariable use\n- hashfast: Promote problematic write() replies to warning level\n- hashfast: Log errno on write failures\n- Extend maximum processor count to 17,576 (3 letters)\n- DevAPI: Make processor lettering code more extensible\n- Remove shorthand option for undocumented --bench-algo\n- Remove long-deprecated and non-functional --enable-cpu option\n- Deprecate shorthand options for uncommonly-used --algo, --cpu-threads,\n--expiry, --gpu-threads, --intensity, --kernel-path, --kernel, --scan-time,\n--vectors, and --worksize\n- API-README correct new text format documentation\n- API allow multiple commands/replies in one request\n- Due to work restarts causing ~all processors to request work at once, it is\nalways ideal to stage at least mining_threads extra works\n- scrypt: raise the maximum GPU intensity for scrypt mining to 31 - benefits\nshown for AMD R9 290 models\n- Bugfix: bitforce: ZNX/ZWX expect size minus 1\n- Bugfix: bitforce: Start building send_queue command at the real end\n- Bugfix: bitforce: Defer opening until after devdata is initialised (since it\nis now used to track open-ness)\n- Document uio/vfio configure options as --without-* since they are enabled by\ndefault when available\n- Include list of lowlevels built in configure and --help output\n- lowl-pci: Autodetect build-time support for UIO and/or VFIO during configure\n- README.ASIC: Document how to use Monarch in a PCI-Express arrangement on Linux\n- lowl-pci/vfio: Support pread/pwrite access to bars\n- lowl-pci: Support for vfio\n- Abstract UIO-specific code from bitforce driver into lowl-pci\n- bitforce: Initialise lasttag based on response register\n- bitforce: Tie in UIO with lowl-pci\n- lowl-pci: New lowlevel driver for raw PCI devices\n- util: bfg_slurp_file function to quickly read a file\n- bitforce: Support for PCI interface via UIO\n- bitforce: Hide vcom interfaces behind new struct bitforce_lowl_interface\n- bitforce: Let the lowlevel interface deal only with the actual device\ncgpu_info\n- bitforce: Abstract most of VCOM layer away from driver code\n- bitforce: Avoid checking fd by adding is_open flag\n- bitforce: Replace BF{open,close} with more abstract bitforce_vcom_{open,close}\n- bitforce: Abstract fd access mostly down to BFgets/BFwrite\n- bitforce: Support for 28nm WX single-stage bulkqueue command\n- bitforce: Use enum for style (FPGA vs SC)\n- bitforce: Remove never-used and buggy \"work queue\" mode\n- Round temperature to an integer in thermal cutoff warning\n- Bugfix: icarus: Initialise read_count and other timing-related variables\n- Change default log interval to 20 seconds\n- hashfast: Bump default thermal cutoff temperature to 100 C\n- Bugfix: DevAPI: Ensure temp-cutoff and temp-target are always supported\nsettings\n- Bugfix: Initialise cutoff and target temperatures in allocate_cgpu if not\ninitialised by the driver\n- Include temperature in thermal cutoff warning\n- Avoid automatic rescans when hotplug is disabled\n- nanofury: New \"ledmode\" RPC setting, to control LED behaviour\n- nanofury: Support for changing baud rate\n- nanofury: Detect number of chips, so multiple can be used\n- bitfury: When detecting chips, oscillate slower and tolerate clocks outside of\na predefined range\n- Default --quit-summary to devs if there are more than 24 processors\n- Control printing of quit device summary with --quit-summary option\n- bitfury: Migrate all drivers to set_device_funcs interface\n- drv_set_defaults: Take devpath and serial params so matching by those can work\n- avalon: Replace avalon-options with set_device_funcs\n- klondike: Replace klondike-options with set_device_funcs\n- Replace temp-cutoff and temp-target parameters with set-device options\n- README.FPGA: Update documentation for Icarus driver\n- icarus: Replace icarus-timing with set_device_funcs (including wrapper for\nsingle icarus-timing case)\n- icarus: Replace icarus-options with set_device_funcs (including wrapper for\nsingle icarus-options case)\n- drv_set_defaults2 function to work with set_device_funcs\n- icarus: Clarify user_set flags with an enum\n- icarus: Clarify reopen modes with an enum\n- Accept parameter to set_device \"help\" as a request for help on a specific\nsetting\n- set_device_funcs support for returning messages on success\n- RPC: Support for alternate message strings\n- bitfurce: Use new set_device_funcs interface\n- Refactor set_device interface to use option arrays\n- configure: Turn _Static_assert into a noop if the compiler lacks support\n- Store when the last getwork was retrieved and display it in the API summary.\n- bitforce: Consistently use fd -1 when device is not open\n- hashfast: Support for voltage in RPC stats\n- hashfast: Support for voltage displayed in ManageTUI\n- hashfast: Support for temperature\n- Trigger automatic rescans if an expected probe fails (assuming the device just\nneeds more time to initialise)\n- Schedule rescan after a 1 second delay, should it be requested twice\n- hotplug: Wait 100ms before rescanning, so plugging in a hub can be handled at\nonce and drivers have time to finish initialisation\n- Linux hotplug: Ignore EAGAIN and EINTR from epoll_wait so debugging works\n- Common hotplug_trigger function to use regardless of platform-specific\nimplementation\n- Autoscan for new devices on Linux using libudev\n- Autoscan for new devices on Windows when DBT_DEVNODES_CHANGED message is\nbroadcast\n- Replace suffix_string with a wrapper around format_unit3\n- Skip lowlevel-based scans in scrypt mode\n- README.GPU: Document new opencl autodetect behaviour\n- opencl: Enable by default in scrypt mode\n\n\nBFGMiner Version 3.10.1 - May 26, 2014\n\n- Upgraded Windows libraries:\n- - libcurl from 7.34.0 to 7.37.0 (and SSL support enabled)\n- - libjansson from 2.4 to 2.6\n- - libmicrohttpd from 0.9.30 to 0.9.35 (now Win64 also)\n- - libusb from libusbx 1.0.17 to 1.0.18\n- DevAPI: for_each_{managed,logical}_proc helper macros\n- Update libblkmaker to 0.3.3\n- make-release: Copy submodules from local system\n- make-release: Automatically determine DLL dependencies to include\n- Bugfix: littlefury: Avoid memory leak for already-claimed devices\n- Bugfix: drillbit: Avoid 9-byte memory leak for already-claimed devices\n- Bugfix: lowl-ftdi: ft232r_close: Free device handle\n- Bugfix: bitfury: Avoid memory leaks when detect fails\n- Bugfix: klondike: Correct case of dname\n- Bugfix: hashfast: Set LIFE_INIT2 so a dead engine doesn't hold up the stats\nline\n- Bugfix: bitforce: Restore device name loading for FPGA Singles\n- Bugfix: Add config.h include to files missing it\n- Bugfix: swap32to?e: Ensure conditionals always have the same type\n- Bugfix: Protect prev_cancelstate variables under console lock\n- opencl: Silence warning about duplicate const qualifier\n- hashbuster: Avoid signed char problems in return status check\n- Bugfix: bfg_claim_any: Use a mutex to avoid races around device claims\n- SSM: Silence JSON parse error message for HTTP POST and TLS attempts\n- bifury: Defer precision loss until after checking osc6_bits value\n- opencl: bfg_clBuildProgram function to share common error handling (logging)\ncode\n- opencl: Avoid printing empty build logs\n- Bugfix: opencl: Free allocated memory when done with it\n- Bugfix: Stratum: Use an error buffer on struct pool rather than the stack, so\nit remains valid for the lifetime of the connection\n- Bugfix: Reset tv_idle on pools after test failure\n- Bugfix: Ignore last work time if pool is known to be down\n- pick_unit: Avoid infinite loop when passed inf float\n- Bugfix: bitfury: Correct comment about how much of the nonce range chips\nprocess\n- Bugfix: Initialise getq (and stgd_lock) earlier so it is ready in case startup\ninteractive pool-add tries to stage work\n- bitfury: Wait for two low frequency measurements before acting on a freq drop\n(in case of a single misread)\n- Bugfix: SSM: decref parsed JSON when done with it\n- knc: Replace numeric constants with KNC_CORES_PER_DIE, KNC_DIE_PER_CHIP, and\nKNC_CORES_PER_CHIP defines\n- Bugfix: knc: Actually skip over extra processors rather than infinite loop\n- Bugfix: Use rlim_t type for old_soft_limit so comparison with RLIM_INFINITY is\ncorrect on all platforms\n- Update alloca logic to work on more platforms\n- start-bfgminer.sh: Shell script to (re)start bfgminer in a background screen\nsession\n- Bugfix: Handle disabled CPU support properly in various places\n- Bugfix: README.ASIC: KnCMiner: Use supported Angstrom feeds only\n- Bugfix: pool_active: Skip testing explicitly when we have a recent answer\n- RPC: Use struct timeval for mcast bind timer\n- Bugfix: Restore 2-minutes-past-last-work wait before terminating unused\nstratum connections\n- Partial: Bugfix: Turn spidevc into lowl-spi to fix building the knc driver\nwithout the bitfury driver\n- SSM: Silence JSON parse error message for HTTP attempts\n- Bugfix: Use UTF-8 for micro prefix internally (and in logging)\n- Consistently allocate space used for formatting numbers\n- util: utf8_len and utf8_strlen functions to quickly measure a character or\nstring\n- Bugfix: README: Add missing driver build configuration options\n- Bugfix: renumber_cgpu: No need to copy dev_repr over itself (and trying to is\nundefined)\n- Move OpenCL kernel FAQ to README.GPU and clarify it a bit\n- Bugfix: Log work updates for all active pools in multipool mode\n- test_work_current: Cleanup\n- Bugfix: Differentiate pool_actively_desired from pool_actively_in_use for\ncnx_needed\n- Abstract pool_actively_in_use to handle multipool checking for multiple uses\n- Bugfix: antminer: Fix typo\n- Bugfix: renumber_cgpu: Rebuild repr strings to match new information\n- Bugfix: Skip final pool_active check in balancing modes (where pools switch\naround often)\n- Bugfix: Adjust quota GCD only after completely adding the pool, otherwise it\nwill be ignored by the adjustment\n- Bugfix: opencl: Can only BFI_INT patch if using OpenCL binaries\n- SGW: Support for scrypt\n- README: Document VCOM low_latency flag and latency_timer sysfs attribute,\nwhich can help run more VCOM-based devices on low-end USB hosts\n- Add USB faqs.\n- Bugfix: Stratum: Wait a bit for a response before assuming the pool is hiding\nblock contents\n- README: FAQ about Raspberry Pi issues\n- Check for when errno is set on windows as well as the windows variant for\nerrors.\n- Partial: Handle interruptions to various select calls in util.c\n- Bugfix: configure: Only fail due to not having libusb, if the user really\nneeds or wants libusb\n- Bugfix: Update help display to replace (U)tility with (I)ncome\n- Bugfix: Deduplicate % symbols in help display\n- Bugfix: Correct documentation for --shares option\n- cpu/scrypt: Fix last_nonce to be host endian also\n- Bugfix: cpu: Correct results found by scrypt algorithm\n- Bugfix: lowl-vcom: _get_osfhandle failure returns INVALID_HANDLE_VALUE, not\nNULL\n- Bugfix: lowl-vcom: Invalid fd checks should be for -1, not 0\n- Bugfix: SSM: Actually acquire and release extranonce1s\n- Bugfix: C reserves identifiers beginning with an underscore and uppercase\nletter or another underscore\n- Skip trying to submit shares in benchmark mode\n- Rework benchmark mode\n- Bugfix: configure: Only pull in lowl-usb for lowl-vcom if libusb is available\n- Bugfix: hashfast: Ensure size of hex data passed to applog is of type int\n- README.ASIC: Update \"SGW\" virtual device identifier to current \"PXY\"\n- Bugfix: klondike: Reenable hw error reporting on nonces found for unknown work\n- Bugfix: Expand deprecated work->subid field to int width, needed by klondike\ndriver for tracking work\n- Bugfix: erupter: Sapphire detected as Emerald and Emerald not detected\n- configure: Remove duplicate sys/file.h check\n- Bugfix: httpsrv: Add missing includes for stdarg, stddef, stdio, and stdlib\n- hashbusterusb: Initialise send packets fully to avoid leaking uninitialised\ndata to devices\n- Bugfix: Correct typo in --help (\"AlgoritHms\")\n- Bugfix: twinfury: Avoid crashing when next_work is not populated here\n- Bugfix: hashbusterusb: Close device after failures\n- Bugfix: hashbuster: Close device after failures\n- README: List --quota in options\n- README.ASIC: Update documentation for Avalon\n- Bugfix: Leave thr->*work alone when disabling non-minerloop_async devices\n- udev rules: Set flag so ModemManager ignores devices\n- bifury: Thermal overheat causes restart losing the clock, so resend it while\ntemperature is over 80 C\n- bitforce: Explicitly assign indexes for bitforce_proto enum\n- Bugfix: RPC: MSG_PGASETOK does not have a string param\n- littlefury: Close device if there are any communication problems\n- littlefury: Abstract out littlefury_set_power\n- Bugfix: hashfast: Add missing serial_claim\n- Bugfix: drillbit: Add missing serial_claim\n- Bugfix: bifury: Add missing serial_claim\n- Bugfix: littlefury: Add missing serial_claim\n- Bugfix: Allocate all new devices completely, before trying to activate any\n(since the first processor may control the secondary ones)\n- Since scrypt miners tend to work at actual share difficulty, use that for\ndiff1 counting\n- Bugfix: diff1 measurements should be increased by nonce difficulty, not share\ndifficulty\n- drillbit: strtol into a long int so negative responses properly get an error\n- Rename *nonces variables to *_diff1 to reflect their nature better\n- Refactor diff1 records to properly weigh non-diff1 work\n- AUTHORS: Add Nico Oelgart\n- Fixed multiple XSS injection vectors\n- drillbit: Expand allowed external clock range to 0-65535\n\n\nBFGMiner Version 3.10.0 - January 15, 2014\n\n- Downgrade official Windows build compiler to GCC 4.7.3.\n- Update official Win64 build mingw64-runtime from 3.0.0 to 3.1.0\n- Bugfix: Stratum: Accept JSON Number type for port number\n- Bugfix: proxy: Set start timer when creating new virtual devices\n- antminer: Add support for the Identify function - flashes LED 10 times\n- drillbit: Expand allowed external clock range to 0-255\n- drillbit: Forbid setting external clock usage if not supported by device\n- Check for DBC_TEMP capability before trying to read temperature\n- Bugfix: drillbit: Reduce work message to correct size\n- README: Update documentation for new udev rules and \"video\" group\n- Bugfix: opencl/adl: Set iSpeedType for get-fanspeed requests, and ensure we\ndon't change do something weird with the fan when initially setting user-defined\nspeed flag.\n- Bugfix: drillbit: Initialise rv variable\n- Bugfix: Simplify adding \"http://\" prefix to avoid strncat overflow (length\nexcludes null byte)\n- hashfast: Debuglog work flushing\n- hashfast: Implement OP_NONCE search flag\n- hashfast: Log seq numbers for nonces found\n- hashfast: Count hashes done by nonces found, rather than no-pending-work\n(which could be triggered by flushes)\n- hashfast: Just keep a queue of the 32 most recent work items per core\n- hashfast: Convert to minerloop_queue driver model\n- hashfast: Gracefully complain if we are given an unknown chip or core address\n- udev rule for hashfast devices\n- hashfast: New driver using UMS protocol\n- CRC-8-CCITT implementation\n- AUTHORS: Add Lingchao Xu and move nwoolls up to antminer driver (and mention\nTwinFury driver for Andreas)\n- knc: Workaround false compiler warning about \"uninitialised\" vars\n- Bugfix: drillbit: Access fd after potentially reopening\n- Remove Christmas colouring\n- drillbit: Add udev rule\n- drillbit: Correct configure logic to check for generic bitfury code (needed to\ndecode nonces)\n- drillbit: Implement some basic problem recovery\n- drillbit: Support identify command\n- drillbit: Read/write access to clock and voltage configuration from RPC and\nManageTUI\n- drillbit: Store board configuration\n- drillbit: Read temperature sensor\n- drillbit: Check nonces against prev work\n- drillbit: Implement mining\n- drillbit: Only detection code\n- antminer: Initial support for the Bitmain AntMiner U1 ASIC Includes support\nfor identifying the U1 separately from Icarus and Block Erupter Also includes\noverclocking via --set-device antminer:clock=xHEX\n- Extend horizontal lines to full screen width\n- Log devid for USB string request failures\n- Bugfix: segmentation fault if the terminal window is too narrow for the Help\nand Quit items\n- Accept \"address\" spelled out in --coinbase-addr option\n- Bugfix: document the need to package zlib1.dll in the Windows build\ninstructions\n- Bugfix: Stratum: Re-read pool sock var after suspend+restart\n- Silence false uninitialised var use warning and calculate dev_runtime only\nonce\n- Bugfix: HID API not properly detected on Mac OS X\n- Adjust device list size as necessary when accessing options\n- Avoid erasing the screen when statusy is not changing\n- Abstract common set_statusy code out of change_logwinsize and check_winsizes\n- TUI: Support pgup/pgdown for scrolling device list by page\n- Bugfix: icarus: quirk_reopen is an int\n- Bugfix: Do not allocate spi_port on the Stack, even to initialize -\nEXC_BAD_ACCESS on OS X\n- get_statline3: Simplify statistics gathering\n- Bugfix: twinfury: Use serial number formatted over USB, so it works with\n--scan\n- twinfury: Only debuglog temperature debugging data when --device-protocol-dump\nis enabled\n- Bugfix: twinfury: Populate temperature info on both processors\n- Option --weighed-stats to display A and R values weighed by difficulty\n- README.GPU: Document always-disabled-by-default for OpenCL driver\n- AUTHORS: Add Nate Woolls\n- Extend menu to full width of window\n- Abstract out spaces-to-eol to bfg_wspctoeol function\n- Elaborate on spi_port+stack problem in comments\n- Bugfix: Do not allocate spi_port on the Stack - EXC_BAD_ACCESS on OS X\n- Bugfix: don't attempt to probe Bluetooth devices when scanning hardware\n- x6500: Allow overriding the maximum frequency used by the dynclock logic Can\nnow use e.g. --set-device x6500:maxclock=210 Prevents spending time on\nfrequencies that only produce HW errors\n- HACKING: Clearly document that dname must be lowercase and alphabetic\n- bifury: Tolerate corruption in submit message, remapping shares to the first\nprocessor if chip id is unrecognised\n- bifury: Tolerate corruption in hwerror message\n- bifury: Tolerate corruption in job message, and only count hashes done when\ncompleting a known job\n- Use a lowercase driver name to fix --scan pattern matching Otherwise the\nfollowing doesn't work: -S noauto -S twinfury:auto\n\n\nBFGMiner Version 3.9.0 - December 25, 2013\n\n- Update official Win32 build compiler and library:\n- - Upgrade GCC from 4.8.1 to 4.8.2\n- - Upgrade libcurl from 7.28.1 to 7.34.0\n- Update official Win64 build compiler and library:\n- - Upgrade GCC from 4.7.3 to 4.8.2\n- - Upgrade mingw64-runtime from 2.0.8 to 3.0.0\n- Green-on-red title colours for Christmas release\n- write_config: Include http-port and stratum-port options\n- Interpret F1 as a request for Help\n- Bugfix: SSM: Free old _ssm_notify before replacing it\n- Bugfix: SSM: Clean _ssm_cur_job_work as needed to avoid memory leaks\n- Support matching --scan with lowlevel devid\n- cgpu_match: Unit test for USB device path matching\n- Bugfix: cgpu_match: Handle digits in dname (x6500)\n- cgpu_match: More unit tests (dname with digit)\n- cgpu_match: More unit tests (dname and case insensitivity)\n- Display \"NO DEVICES FOUND\" line in place of device list, when there are none\n- bitfury: Use drv_set_defaults to enable setting baud before probe\n- bitfury: Split out SPI port configuration option (\"baud\") to its own function\n- drv_set_defaults wrapper function around cgpu_set_defaults for use with\noptions that may need to be set during probe\n- bitfury: Set poll interval to start iteration before responses are processed\n- modminer: Check identification begins with \"ModMiner\" to avoid false detection\n- Bugfix: hashbusterusb: Correct return value of hashbusterusb_vrm_unlock\n- Support for installing a udev rules file for Linux\n- twinfury: Remove unused variable to silence warning\n- cgpu_request_control should be a noop when called from the main thread\n- Bugfix: Handle errors creating a vcom devid more gracefully\n- Bugfix: _wlog: Allocate enough space for complete copy of log line\n- bfsb: Remove unused clock_gettime\n- Bugfix: bfsb: Remove useless slot_on which was never properly initialised\n- Bugfix: When QueryDosDevice fails, skip trying to parse its (undefined)\nresults\n- hashbusterusb: Voltage should be in volts (not millivolts) for RPC\n- hashbusterusb: Provide access to VRM stuff from RPC\n- hashbusterusb: Use cgpu_request_control interface to safely access device from\noutside main thread\n- hashbusterusb: Include Voltage in RPC stats\n- Bugfix: hashbusterusb: Ensure unlock code is always allocated, even if null\n- hashbusterusb: Abstract code into hashbusterusb_vrm_lock\n- hashbusterusb: Abstract code into hashbusterusb_vrm_unlock\n- hashbusterusb: Abstract code into hashbusterusb_set_voltage\n- Bugfix: hashbusterusb: Check for voltage change error correctly\n- Abstract mutex_request code from X6500 driver into generic device API\ninterface\n- hashbusterusb: Use standard identification behaviour\n- hashbusterusb: Abstract hashbusterusb_set_colour function\n- hashbusterusb: Get voltage with temperature\n- hashbusterusb: Clean up unused variable warnings\n- hashbusterusb: Use bitfury_wlogprint_status for osc6_bits displaying in Manage\nTUI\n- Bugfix: hashbusterusb: Remove ignored prompt for VRM lock\n- hashbusterusb: Use Manage/osc6_bits code from main bitfury driver\n- hashbusterusb: Provide access to VRM and identification in Manage TUI\n- hashbusterusb: Shutdown PSU\n- nanofury: Support identify function by turning off LED for 5 seconds\n- nanofury: nanofury_state structure\n- bitfury: Set poll interval to start iteration before responses are processed\n- Twinfury: moved voltage reading to the thread init function\n- Twinfury supply voltage initial reading: error log improved\n- Twinfury: Reading supply voltage on startup\n- Voltage scaling for twinfury implemented\n\n\nBFGMiner Version 3.8.1 - December 9, 2013\n\n- bfgminer-rpc: Catch error when server host fails to resolve to an IP\n- RPC: Remove unnecessary delay from RPC server startup\n- Call WSAStartup for our own needs independently of libcurl etc\n- hashbusterusb: Give more meaningful errors before serial number is known\n- hashbusterusb: Populate device_path with USB devid\n- Rename hashbuster2 to hashbusterusb (only a-z allowed in driver names)\n- Include libusb in options list, since it is no longer tied to specific drivers\n- Make hashbuster serial number output match formatting on physical board\n- Fix for hashbuster first init after power up\n- Workaround Microsoft's non-standard swprintf\n- vcom: Fabricate vcom devinfo for any existing paths specified to --scan, in\ncase enumeration fails\n- Bugfix: hashbuster2: Check for errors setting up libusb handle\n- Bugfix: Draw statuswin in line order to ensure overflow is cutoff properly\n- Fixed one byte stack overflow in mcast recvfrom.\n- Bugfix: Let libc do any translation for %lc before adding wide characters to\ncurses\n- Specifically handle mining.get_transactions failures so they get logged at the\nlower debug loglevel\n- Bugfix: lowlevel: Use LL_DELETE2 when cleaning up secondary list\n\n\nBFGMiner Version 3.8.0 - December 1, 2013\n\n- Bugfix: lowl-usb.h: Add missing includes for stdbool/stdint\n- hashbuster2: Retry writing request if no response received in 100ms\n- lowl-usb: usb_ep_set_timeouts_ms function that behaves similar to termios\nVTIME (timeout before begin of read/write)\n- hashbuster2: Use new lowl_usb_endpoint for i/o\n- lowl-usb: Add tools for more reliable read/write using bulk transfers\n- Add bytes_extend_buf, bytes_preappend, bytes_postappend for reading direct to\na bytes_t\n- New / updated instructions for building bfgminer on Windows\n- configure: Adjust header-path discovery to work sanely with spaces and\nbackslashes in paths\n- Bugfix: configure: More fixing BSD sed syntax for curses header search\n- bitfury: Reinitialise chips if their frequency drops over 50%\n- bfg_strerror: Trim C whitespace off the right of FormatMessage output, since\nWindows can add \\r\\n\n- Demote commonish errors to debug loglevel\n- klondike: Add support for Avalon2-based designs\n- klondike: Remove unnecessary limit of 999 on clock speed displayed in Manage\nDevice\n- Bugfix: hashbuster2: Claim USB device internally\n- Bugfix: hashbuster2: Do not try to use lowl-hid.h\n- Bugfix: hashbuster2: Close device and free memory allocated, when no chips are\nfound\n- Bugfix: hashbuster2: Remove libusb init and debug level setting\n- Bugfix: hashbuster2: Avoid add_cgpu when no chips found\n- Bugfix: klondike: Claim USB device internally\n- Bugfix: devpath_to_devid: Check stat for error before allocating memory\n- Bugfix: lowlevel: Free hash table data when done with it\n- Bugfix: bifury: Free memory used by version reply\n- bfgtls: Implement destructor to free memory when threads exit\n- hashbuster2: Remove unnecessary libusb_detach_kernel_driver\n- hashbuster2: Read unique serial number from device\n- hashbuster2: Use hashbuster2_io for probe\n- hashbuster2: Clean up warnings about unused variables\n- README: Document --enable-opencl configure option\n- README: Update for HashBuster Micro\n- hashbuster2: Integrate into BFGMiner as a separate driver\n- hashbuster2: Import driver for new protocol\n- Bugfix: nanofury: Check if mcp2210_device exists before trying to power it off\n- Bugfix: lowl-vcom: Check for error getting root hub path\n- openwrt: Update package description\n- configure: Add --without-libusb option to explicitly disable using it\n- Bugfix: Pass newlines as ASCII (fixes lack of them in non-unicode builds)\n\n\nBFGMiner Version 3.7.0 - November 27, 2013\n\n- FTDI scan: Use intptr_t to avoid warning about different size type cast\n- Bugfix: proxy: Add missing unistd.h include\n- Bugfix: bifury: Precision specifications should be int, not size_t\n- Bugfix: klondike: Include config.h first\n- Bugfix: binloader: Include config.h first\n- README.ASIC: Include support URI for bi*fury driver and firmware\n- Added MultiMiner as an example of a GUI application that wraps bfgminer using\nthe RPC interface\n- Silence non-issue warnings\n- bifury: Add support for hwerror message\n- inc_hw_errors2: Support reporting hw errors without a known nonce\n- bifury: Initialise cutofftemp to 75 C\n- bifury: Turn chips off and on when disabled and enabled\n- bifury: Split out bifury_send_clock\n- Bugfix: bifury: Avoid double-free and double-close on version parse errors\nduring probe\n- bifury: Add support for clock command\n- bifury: Update for \"job\" protocol change\n- bifury: Update to current git\n- bifury: Workaround bugs in older firmware by flooding device with work until\nit proves it has needwork\n- bifury: Attempt to submit shares even if maxroll limit is ignored\n- Clone cgminer's submit_noffset_nonce interface\n- Bugfix: bifury: Check that there is a line before comparing it to \"version \"\n- bifury: Prune jobs older than 16 queued, to eventually clean up discarded work\n(from flushes)\n- Replace ucs2tochar* with ucs2_to_utf8* to handle Unicode\n- README.ASIC: Document Bi*Fury firmware upgrade\n- bifury: Free work when we know it's complete\n- bifury: Implement hashrate reporting using \"job\" messages\n- bifury: Tolerate other data before version reply\n- bifury: Abstract line parsing into bifury_readln function\n- Bugfix: bifury: Use a char array, rather than pointer to char array, for\nbifury_init_cmds\n- bifury: Unify SEND devprotodump logging code\n- fpgautils: Skip SetCommConfig on Windows if baud is not to be set\n- Check for U+2022 and replace it with \"*\" is unprintable\n- Use replacement character for non-printable Unicode\n- Use UTF-8 for Unicode\n- Implement a utf8_decode function to produce wchar_t needed by curses\n- bifury: New driver\n- Bugfix: twinfury: Handle flash request for both chips, and avoid using proc\nuninitialised\n- Bugfix: twinfury: Fix various technicalities\n- Bugfix: twinfury: Remove incorrect tcflush\n- Twinfury communication protocol changed to be more robust. A preamble is sent\nbefore the actual command.\n- LED flashing changed: - setting a flag and flash the LED during the poll\ncycle - mutex removed\n- Renamed bf2 driver -> twinfury driver bin2hex utility used to convert the\nserial number\n- BF2 driver comment edited\n- BF2 - Twin Bitfury USB miner driver added\n- Deprecate --ndevs|-n (redundant with -d? and GPU-only)\n- Never abort startup just because we have no devices (there may be cases this\nis pointless, but at least it's consistent)\n- cgpu_match: Accept ranges for letter processor specification\n- cgpu_match: Accept ranges for numeric elements\n- test_cgpu_match: Test with more than one device/processor\n- configure: Condense configuration options summary a bit\n- configure: Put configuration options summary back after everything completes\n- Workaround bug in MinGW-w64: Check for strtok_r to be defined at compile-time,\nand don't override it unless we really want to override\n- Bugfix: configure: Use new need_lowl_vcom instead of need_fpgautils\n- configure: Explicitly check for sleep\n- Bugfix: Set LIBUSB_LIBS for non-pkgconf non-header-subdir libusb installations\n- Move unused winsock2.h includes to the end of config.h\n- Use lround instead of llround, since it has better compatibility with older\nMingW and Cygwin versions\n- lowl-hid: Save and use hid_enumerate results from library test\n- Silence Windows build warnings\n- mcp2210: Remove cruft leftover from HID code (moved out)\n- lowl-vcom: sysfs scan: Simplify maybe_strdup into _sysfs_do_read\n- lowl-vcom: sysfs scan: Don't bother getting product string until we confirm it\nis in fact a tty device\n- input_pool: Accept a null password\n- Bugfix: Move const data into the scope it needs to be in\n- Bugfix: Restore case insensitivity to --scan driver names\n- Accept \"@\" separator for serial/path in --scan to match --device and\n--set-device better\n- README: Uppercase the sequence letter when talking about multiple pools\n- README: Mention \"make install\" and clarify saving settings\n- Bugfix: avalon: Don't \"probe\" with -S <path/serial>\n- bitforce: Add lowl_* to bitforce_queue so it can be specified by name as a\ndriver\n- Bugfix: devpath_to_devid: Be strict about COM port specifications on Windows\n- Bugfix: avalon: Don't \"probe\" with -S all\n- Bugfix: Only count devices in -d?\n- RPC: {dev,proc}details: Add 'Processors', 'Manufacturer', 'Product',\n'Serial', 'Target Temperature', 'Cutoff Temperature'\n- debian: Need to explicitly add opencl support to build.\n- Correctly document klondike as being enabled by default\n- Simplify logic for README.ASIC and README.FPGA install\n- Split fpgautils into lowl-vcom and binloader, and fix internal build\ndependencies\n- Add README.CPU to \"make install\" distribution when built with CPU mining\nsupport\n- line 2913 added urlencode\n- Bugfix: RPC: Release apisock on error in tidyup\n- klondike - dont try to flush if not initialised\n- Rename --scan-serial to --scan\n- Bugfix: Handle invalid driver names cleanly\n- Workaround libcurl bug to properly support HTTP proxies for stratum\n- Bugfix: Write klondike options for klondike-options (not icarus options)\n- README.OpenWrt: Change example repository to \"latest\", and document\nalternatives\n- mcp2210: Add support for --device-protocol-dump\n- Bugfix: Initialise dynamic osc6_bits variables\n- README: Fixed a few typos here and there and improved wording (Thanks\nminingpenguin!)\n- README: Moved CPU sections to README.CPU and elaborated more on it\n- README*: Grammatical cleanups\n- README.ASIC: More KnCMiner\n- README.ASIC: Add section about KnCMiner\n- Bugfix: opencl: Dynamic mode should disable threads for this device, not just\nN after the first\n- Bugfix: Make curses_input return NULL on a blank line, as most callers expect\n- Duplicate (hidden) --userpass option before --pool-priority so it can be used\nin config files\n- Only probe VCOM devices on bare \"all\" scan-serial request\n- Provide backports of uthash LL_{PREPEND,FOREACH{,_SAFE}}2 (only added in\n1.9.7, not yet in major distros)\n- Upgrade required uthash version to 1.9.4 for LL_CONCAT\n- README: Update documentation for scan-serial\n- README: Bitstreams no longer included with BFGMiner source\n- README: Remove incomplete and unnecessary list of ASIC/FPGA devices\n- write_config: Add scan-serial and set-device\n- write_config: Update to make JSON Array of named parameters\n- Remove support for comma-separated values in --device, and update\ndocumentation\n- lowlevel: Collapse multiple lowlevel drivers on the same devid to a secondary\nlinked list, and only spawn one thread to probe all lowlevels on a given devid\n- Bugfix: vcom_devinfo_scan: Clean up hashtable when done\n- README: Update cgminer driver FAQ with Windows-specific answer, now that we\nhave a workaround for *nix\n- cpu/opencl: Always disable by default; removes deprecated -G option entirely\n- vcom_lowl_probe_wrapper: Attempt to reattach detached USB devices\n- Bugfix: erupter: Prioritise Emerald after Sapphire\n- Bugfix: Allow \"drv:auto\" to override general \"noauto\"\n- Bugfix: _probe_device_match: Fix inverted logic\n- Bugfix: Don't try to call lowl_probe for drivers that don't support that\ninterface\n- lowl-hid: Use usb devids for libusb-based hidapi devices\n- Replace bfg_claim_hid with lowlevel_claim\n- lowlevel: Generic claim interface for lowlevel info\n- cgpu_match: Compare dev_t under paths\n- Rework -d? output to display more useful information now that device ordering\nis non-deterministic\n- cgpu_match: Add support for matching by serial number or path\n- Unit tests for cgpu_match\n- Rework --device option to accept a pattern and JSON Array in config; removes\nsupport for processor ranges\n- Remove --remove-disabled option, as it conflicts with hotplug, per-processor\nstuff, etc already\n- Bugfix: Reimplement \"noauto\" flag\n- Bugfix: Restore \"-S foo\" without driver name functionality\n- Bugfix: scan-serial: Compare dev_t as well\n- littlefury: Convert to lowl_probe\n- hashbuster: Convert to lowl_probe\n- avalon: Convert to lowl_probe\n- cairnsmore/erupter/icarus: Convert to lowl_probe\n- bigpic: Convert to lowl_probe\n- ztex: Convert to lowl_probe\n- x6500: Convert to lowl_probe\n- nanofury: Convert to lowl_probe\n- modminer: Convert to lowl_probe\n- klondike: Convert to lowl_probe\n- bitforce: Convert to lowl_probe\n- fpgautils: Wrapper to easily adapt an old detectone to new lowl_probe\n- lowlevel: Add match variants of detect functions\n- DevAPI: add_cgpu: Use mutex to ensure thread safety\n- Make detectone_meta_info thread-local\n- New threaded device probe framework\n\n\nBFGMiner Version 3.6.0 - November 12, 2013\n\n- RPC: Bump to 2.2 for Works in POOLS\n- Bugfix: klondike: Don't try to free off the stack\n- configure: Update klondike checks for libusb\n- klondike: Autodetect by VID/PID/Manufacturer, rather than too-short \"K16\"\nProduct search\n- Remove accidentally added ASIC-README\n- klondike: Remove noop identify function\n- klondike: Replace deprecated statline with temperature and ManageTUI stuff\n- --shares should be scaled to diff1 not absolute number of shares\n- More README updates.\n- Minor README updates.\n- sha2 allow external access to some macros and the K array\n- klondike: Fixed a math issue when reporting fan speed on the status line.\n- Add a get and queue helper work function.\n- Reset the work_restart bool after the scanwork loop in case the driver flushes\nwork synchronously.\n- Get rid of the stage thread since all work can be asynchronously added now via\nhash_push anyway.\n- Fix for opt_worktime on big endian machines.\n- Do get_work in fill_queue without holding other locks.\n- Make hash_pop signal the work scheduler each time it waits on the conditional\nthat it should look for more work.\n- Remove discarded work from quota used.\n- Display works completed in summary and API data.\n- Store how many work items are worked on per pool.\n- Add the ability to add uint8 and uint16 entities to api data.\n- klondike - initialise stat_lock\n- klondike - better to unlock locks than to lock them twice :)\n- Remove roundl check and define\n- 'llround' is more suitable here than 'roundl'\n- klondike - change options to clock and temptarget only\n- klondike - fix another uninit dev warning\n- klondike - downgrade 'late update' but add an idle detect - and correct error\nlevels\n- klondike - fix isc uninit warning\n- klondike - drop the device for hotplug if it's unresponsive\n- klondike - single 'shutdown' and ensure it happens\n- klondike remove SCNu8 - unsupported on windows\n- klondike - fix uninitialised dev bug\n- Don't attempt to disable curses or print a summary during an app restart to\nprevent deadlocks.\n- klondike - error condition handling\n- Modify Makefile to only include opencl related code when configured in.\n- Convert opencl to need to be explicitly enabled during build with\n--enable-opencl\n- Implement a cglock_destroy function.\n- Implement a rwlock_destroy function.\n- Implement a mutex_destroy function.\n- Simplify queued hashtable by storing unqueued work separately in a single\npointer.\n- Add cgminer compatibility macro for ms_tdiff\n- klondike rewrite work control\n- allow __work_complete() access\n- miner.h allow devices to tv_stamp work\n- klondike - can only calculate the nonce difference on or after the 2nd nonce\n- klondike - correct/reverse min/max stats\n- klondike: Remove unnecessary devlock\n- klondike - use a link list queue rather than a circular buffer - and add\ntiming stats\n- Klondike - increase circular read buffer size\n- Klondike - extra zero value and range checking in temp conversion\n- klondike - display MHz also\n- klondike correct cvtKlnToC() temperature calculation\n- klondike - correct 1st reply debug based on define\n- klondike - debug dump structured replies\n- klondike - avoid division by zero if maxcount is unexpectedly zero\n- klondike store and report errorcount and noise\n- klondike - fix chipstats api stats buffer overrun with 16 chips\n- klondike add new nonecount only once\n- klondike - report mh/s based on nonces found + put old estimate into API stats\n- klondike use a memcpy\n- klondike fix bracket tabs indenting\n- klondike: Update code to current git\n- Klondike update code to current git\n- Add Klondike to README\n- Add Klondike to README.ASIC\n- Klondike to main directory\n- Klondike consistent code spacing\n- Klondike update driver code to current git\n- klondike: update firmware for 16 chips, add dist files\n- klondike: beta final 0.3.0 release\n- klondike: updated firmware, IOC method\n- klondike: prevent nonces when not state W\n- klondike: added driver config option support\n- klondike: fixes for 300 MHz, fix K1 parts list\n- klondike: update driver, docs\n- klondike: update firmware & utils\n- klondike: updated cgminer driver for 3.3.1\n- klondike: update firmware and driver, create new cgminer fork\n- update klondike driver\n- klondike: add cgminer driver file as-is\n\n\nBFGMiner Version 3.5.2 - November 12, 2013\n\n- README.scrypt: Update to reflect current status of code (unmaintained); remove\nCon's litecoin donation address (leaving his bitcoin one) since it is unknown if\nhe still accepts donations with litecoin\n- Bugfix: minerloop_async: Check the correct _mt_disable_called flag\n- bitforce: Allow ZCX response to override Manufacturer string\n- Bugfix: RPC: Restore null termination on responses\n- Bugfix: configure: We need DLOPEN_FLAGS for lowlevel hid too\n- Add additional debug information to help track work through BFGMiner\n- README: Update hidapi dependency for HashBuster\n- Bugfix: bigpic: Convert device serial and nonces to host endian\n- Bugfix: modminer: Ensure devices that fail probe are closed properly\n- Bugfix: bitforce: Ensure devices that fail probe are closed properly\n- Bugfix: littlefury: Ensure devices that fail probe are closed properly\n- Bugfix: bigpic: Ensure devices that fail probe are closed properly\n- nanofury: Attempt to be more resilient to problems\n\n\nBFGMiner Version 3.5.1 - November 7, 2013\n\n- Bugfix: make-release: Add README.GPU document\n- Demote USB string fetch failure to LOG_DEBUG since it is rather common\n- Bugfix: RPC: devscan shouldn't be available to read-only access\n- Bugfix: bigpic: Ignore the bitfury chip's counter as best we can\n- Bugfix: bigpic: Accept other delimiters in Bitfury BF1 product string in\nautodetection\n- Bugfix: Fix VCOM/fpgautils build check\n- Bugfix: Only include VCOM code when VCOM/fpgautils support is being built\n- Bugfix: Reimplement scan-serial \"all\" keyword\n- Bugfix: bitforce detect: Close device after ZGX failure\n- Bugfix: Define lowl_usb even if libusb support is omitted, since VCOM and HID\ndrivers check against it for warnings\n\n\nBFGMiner Version 3.5.0 - November 6, 2013\n\n- bigpic: Probe sooner than most drivers, but still after icarus/erupter\n- cpu/opencl: Fix probe priorities to be last\n- Bugfix: RPC: Correct per-device Work Utility to be per-minute instead of\nper-second\n- Bugfix: Fix Windows VCOM enumeration to work with new lowlevel code\n- Bugfix: nanofury: Use maybe_strdup in case strings may be missing\n- Bugfix: bitfury: Fix processor disable/enable for all bitfury-based devices\n- hashbuster: Get temperature when available\n- Bugfix: hashbuster: Use maybe_strdup where there might not be a string\n- hid: Treat null-length strings as missing entirely\n- hashbuster: Enable dynamic osc6_bits\n- hashbuster: New driver\n- Split a hid lowlevel out of mcp2210\n- ztex: Convert to use lowlevel usb enumerator\n- A quick flag to allow drivers to convey the desire to rescan devices (from\nlowlevel up)\n- Lowlevel USB enumerator for libusb\n- dname for lowlevel drivers\n- Bugfix: lowlevel: Avoid null pointer dereference on devices that are missing\nUSB strings\n- lowlevel: Add a userpointer to lowl_found_devinfo_func_t and use it for\nserial_autodetect\n- Rework VCOM autodetection to go through lowlevel interface, avoiding repeat\nUSB string fetching\n- lowlevel: Keep track of the claimed devid and debuglog every found device\n- ft232r: devinfo_scan: Don't skip claimed USB devices\n- ft232r: Be more tolerant of USB open failure or missing strings\n- RPC: Build most of CONFIG \"Device Code\" by iterating over registered driver\nlist\n- drv_detect_all: Use priority-sorted list of registered drivers\n- Build hash tables to find drivers by dname or name\n- Build a linked list of registered drivers\n- BFG_REGISTER_DRIVER macro to commonly pre-define device_drv structures\n- Move have_libusb checks out of drv_detect_all\n- Replace opt_nogpu with simple function that adds opencl:noauto to scan-serial\nlist\n- opencl: Remove ancient gpu_threads variable, not really needed anymore\n- Bugfix: Stop waiting for pool testing as soon as one is active\n- bitfury: Clean up by making private functions static, and naming public ones\nwith [lib]bitfury_ prefix\n- bitfury: Remove old (unused) driver code\n- bitfury_gpio: Convert to using current bitfury driver code\n- Bugfix: littlefury: Upgrade to use current bitfury driver (old one didn't work\nwith littlefury anymore anyway)\n- Bugfix: test_work_current: Make hexstr buffer large enough for blkhashstr\nlater on (issuing old work msg)\n- README: Document --enable-knc configure option\n- README: Document --disable-nanofury configure option\n- Windows autodetect: clear detectone meta info\n- Check for Windows DDK headers, and where they are (and build without them if\nunavailable)\n- Windows SetupAPI-based detection for USB VCOM devices (tested with CP210x and\nCDC)\n- ucs2tochar{,_dup} functions to convert USB string descriptors to char* format\n- bfg_strerror: Support for Windows system errors\n- Introduce applogfail* macros\n- Bugfix: scrypt: Add missing include stdbool.h\n- Bugfix: Explicitly cast uses of be32toh to uint32_t\n- Bugfix: Add missing includes of config.h, stdbool.h, and stdint.h\n- lowlevel: Convey device manufacturer up to nanofury cgpus\n- nanofury: Store device HID path for RPC\n- lowlevel: Promote path to a normal element for devices to simplify things a\nbit\n- nanofury: Claim mcp2210/hid devices\n- mcp2210: Implement claim on HID paths\n- fpgautils: Use string identifiers for internal hardware claims\n- ztex: Keep interface claimed as a lock\n- Bugfix: mcp2210: Check for NULL hid device strings before trying to convert\nthem to ASCII\n- FTDI autodetect: Enable populating USB product and serial number\n- Bugfix: FTDI autodetect: Add missing parameter values and remove unused buffer\n- Bugfix: bigpic: Don't active poll event without a poll function\n\n\nBFGMiner Version 3.4.0 - October 26, 2013\n\n- Bugfix: knc: Use separate DEV_RECOVER_DRV deven when doing automatic core\ndisable/re-enable, so user-initiated disables are left alone\n- Document existing enum dev_enable usage\n- Bugfix: knc: Only try to re-enable cores after we've actually asserted them as\ndisabled, otherwise we won't actually assert the enable either\n- knc: Automatically disable and re-enable problematic cores\n- AUTHORS: Add Dmitry Sorokin\n- bitfury: Disable dynamic osc6_bits when manually setting a specific value\n- bitfury_do_io: Make use of timer_elapsed\n- bitfury: Only use dynamic osc6_bits with boards that support it explicitly\n(BFSB and Metabank for now)\n- bitfury: More debugging info for dynamic osc6_bits\n- Bugfix: bitfury: Fix tv_stat to persist\n- bitfury: Remove useless debugging\n- bitfury: Simplify dynamic osc6_bits logic such that the range is defined in\none place\n- bitfury: Remove unused skip_stat\n- Bugfix: bitfury: Stick to tracking best_done per-chip, and never call\nzero_stats (which is for users, not drivers)\n- Bugfix: bitfury: Use proc_repr rather than incorrectly calculated chip_id\n- Bugfix: bitfury: struct bitfury_device is already chip-specific\n- bitfury: dynamic osc_6 bits\n- bitfury: Improve frequency calculation - fixes occasional miscalculations as\nwell as makes it safer with multiple devices\n- bitfury: Added frequency calculation\n- tm_i2c: Corrected copyright\n- Allow --set-device opt=val without a device specification to attempt setting\nit on every device\n- Bugfix: knc: Maintain queue_full for all cores, so they continue to queue work\neven if the first is disabled\n- bitfury: Allow setting osc6_bits up to 60\n- Bugfix: Set status to LIFE_DEAD2 when killing threads at shut off, to avoid\ncalling driver code\n- Skip \"testing stability\" message at startup\n- Try switching pools if for some reason we end up with only idle pools and have\nended up current_pool set to an idle one.\n- Check a pool is stable for >5 mins before switching back to it.\n- ManageTUI: Slash key performs processor selection by search\n- nanofury: Populate dev_product and dev_serial\n- mcp2210: Implement mcp2210_close\n- Bugfix: mcp2210: hid_write needs a report id, especially on Windows\n- mcp2210: Workaround some Windows snprintf not handling wide strings correctly\nby simply copying character-per-character (only works for ASCII data)\n- Bugfix: chroot: Check that chdir succeeds\n- AUTHORS: Add pontus\n- knc: Expose Voltage and DCDC Current to TUI Manage device\n- knc: Expose Voltage and DCDC Current to RPC status\n- knc: Store volt/current on knccore\n- knc: Read voltage/current from DCDCs\n- Bugfix: knc: Fix temperature readout of half-celcius\n- Bugfix: Only define have_libusb if building with libusb support\n- littlefury: Remove unused code\n- bitfury: RPC procset: Ignore extra data (like newline) after numbers\n- Add --set-device option to allow setting default procset commands\n- README: Document hidapi dependency for NanoFury sticks\n- AUTHORS: Include Vladimir Strinski for NanoFury code\n- mcp2210: Set GPIO output mode atomically with their output values\n- nanofury: Power off device when shutting down\n- make-release: Include libhidapi-0.dll\n- mcp2210: Port to Windows\n- configure: Find hidapi.h for mcp2210 using pkg-config\n- bitfury: Provide read/write access to osc6_bits from the Manage TUI\n- nanofury: Reduce oscillator bits to 50 to stay within USB specs\n- bitfury: If multiple integers differ after 4 tries, just go with the first so\nwe can start mining\n- nanofury: Implement actual mining code\n- nanofury: Turn off device after checkport\n- nanofury: New driver; detect device\n- mcp2210: Implement protocol required for NanoFury USB sticks\n- mcp2210: Skeleton low-level driver for MCP2210 USB to SPI Master bridge\n- ft232r: Use lowlevel interface for ft232r_open\n- Abstract ft232r scan+probe interface into new generic lowlevel driver\ninterface\n- configure: Error if knc driver is requested, but linux/i2c-dev.h is missing or\nnot from i2c-tools\n- knc: Attempt to express core enable/disable to controller\n- knc: Put knc_device on every processor device_data\n- Refactor device disable/enable logic so that drv.thread_{disable,enable}\nactually get called\n- Bugfix: knc: Check that device actually has work queued, before trying to find\nthe most recent one\n- knc: Read temperature sensors\n- DevAPI: minerloop_queue: Run watchdog in device thread\n- knc: Pass queue flush to device when its most recent job produces stale shares\n- knc: Issue flush command at init\n- Bugfix: knc: Perform le32toh on unknown-work nonces\n- knc: Use independent device_id for works to enforce 15-bit size\n- Bugfix: spi_emit_nop: Correct counter logic\n- knc: Implement mining\n- knc: Use FPGA i2c to identify present ASICs\n- knc: Basic detection of boards on expected i2c buses\n- DevAPI: generic_detect: Just use an enum for flags\n- Use list of drivers/algos/options generated by configure in --help info\n- miner.php correct sort gen field names largest to smallest\n- api ... the code related to device elapsed\n- api add device elapsed since hotplug devices Elapsed is less than cgminer Elapsed\n- RPC: Include more info in per-device/processor status\n- API add 'MHS %ds' to 'summary'\n- Icarus remove unneeded opt_debug tests due to applog being a macro\n- We should only yield once in cg_wunlock\n- Provide a function to downgrade a cglock from a write lock to an intermediate\nvariant.\n- Reset quotas on load balance for all pools at the same time to avoid running\nout during selection and unintentionally dropping to fallback.\n- Break out of select pool from a common point for appropriate debug messages\nand to avoid further tests.\n- Find the greatest common denominator in quotas and use the smallest number of\nconsecutive work items per pool in quota load balance mode to smooth hashrate\nacross pools with large quotas. Give excess quota to priority pool 0 instead of\npool 0.\n- Add subdir-objects to automake options.\n- Use the --failover-only flag to have special meaning in combination with\nload-balance mode to distribute any unused quota back to pool 0 to maintain\nratios amongst other pools.\n- Display quota and allow it to be modified via the pool menu.\n- More README about quotas.\n- Document quotas and new load-balance strategy.\n- Add API commands and modify output to support pool quota displaying and\nchanging.\n- Change message in status when using a balanced pool strategy to notify if\nthere's a stratum pool as well.\n- Add quota support to configuration files.\n- Rotate pools on all failures to set a pool in select_pool.\n- Use quotas for load-balance pool strategy.\n- Provide a mechanism for setting a pool quota to be used by load-balance.\n- Change --socks-proxy option to default to SOCKS5\n- Cope with trailing slashes in stratum urls.\n- Make extract_sockaddr set variables passed to it rather than pool struct\nmembers.\n- miner.php sort the mcast rigs so they are always in the same relative order\n- miner.php allow sending the muticast message multiple times\n- miner.php mcast ignore duplicate replies\n- miner.php coding warning\n- miner.php disable 'gen' by default\n- miner.php allow formula generation of new fields\n- miner.php add doctype\n- miner.php remove incorrect echo\n- miner.php optional error if not enough mcast rigs are found\n- take_queued_work_bymidstate should use a write lock.\n- API mcast add a description option with miner.php\n- Skip dissecting opt->names in parse_config if it doesn't exist.\n- ICA optional limit timing with short=N or long=N\n- logging - applogsiz() for large messages\n- Provide a funcion that looks up queued work by midstate and then removes it\nfrom the device hash database.\n- Wait until all pools are done testing before giving up, regardless of how long\nthey take to fail\n- AUTHORS: Add Ricardo Iván Vieitez Parra and Paul Wouters\n- Bugfix: Check that setgid succeeds\n- When using --chroot, chdir to the new root\n- Bugfix: Add missing drivers to --help list\n- Bugfix: Zero stats: cgpu->diff_stale\n- fpgautils: serial_close: Explicitly release advisory lock before closing, in\ncase fd has been inherited by a process forked by system()\n- Use serial_close to pair with every serial_open\n- Workaround bug in Plibc by resetting locale to \"C\" at startup\n- Bugfix: bitfury: Check for necessity of linux/i2c.h so build succeeds with\ni2c-tools's userspace linux/i2c-dev.h\n- bitforce: Workaround bugs in current firmware for the Chili\n- Bugfix: DevAPI: Reduce race-collision delay to 1ms so thread_shutdown actually\ngets called before threads are killed forcefully\n- Bugfix: configure: Use AC_SYS_LARGEFILE to ensure nonce/share log files can\nsafely grow bigger than 2 GB\n- Bugfix: Correct argument type for --submit-threads option\n- littlefury: Workaround Xcode bug initialising fields in anonymous unions\n- Bugfix: write_config: Make intensity list writing more readable, and avoid\nextraneous argument in dynamic intensity case\n- DevAPI: Trigger mt_disable_start after init, if a device is disabled before\nminerloop starts\n- icarus: Skip sending new work if entering DEV_RECOVER* modes\n- icarus: When disabling, close device fd and stop sending new work\n- RPC: Use get_api_extra_device_status for full-device status, for devices with\nonly a single processor\n\n\nBFGMiner Version 3.3.0 - October 11, 2013\n\n- openwrt: Optional libevent support\n- RPC: Add missing drivers to Device Code\n- bigpic_process_results: Cleanup\n- RPC: Use procs count for device summaries, rather than iterating over linked\nlist (which may span multiple devices)\n- Bugfix: Use bfg_waddstr for cg_[mv]wprintw so special characters get\ninterpreted properly\n- Bugfix: bitfury: Clear force_reinit flag after reinit\n- Bugfix: Use base unit for zero, and only if all values are zero\n- RPC: Always build pga* and proc* methods\n- Bugfix: icarus: Check for valid fd before all usage\n- Bugfix: Stratum initiate: Clear json var after freeing it, to avoid a\npotential double-free if retry fails before new JSON is parsed\n- Bugfix: Correct --log-file error message\n- Cleanly fall back to other micro- prefix symbols if locale doesn't support the\npreferred one(s)\n- Bugfix: bfg_waddstr: Missing break after selecting degrees symbol\n- Silence warning about (never really) uninitalised variable use in notifystatus\n- RPC: Complete split between devs/pga* and proc* methods\n- RPC: Internal restructuring to support device-wide view\n- RPC: Remove devdetail method, and rework newer devdetails to use its code\n- configure: Advise running ldconfig when detected and probably necessary\n- configure: Simplify final information summary\n- Bugfix: configure: Disable httpsrv/libevent if not available\n- README: Mention free GPU mining dependencies\n- Write config: Avoid writing default temperature settings\n- bitforce: Set default cutoff temperature to 85C for SC-class devices\n- When shutting down, don't wait for mining threads any longer after the 1\nsecond sleep\n- bitfury: Silence warning about (never possible) uninitialised variable use\n- bigpic: Handle write failures\n- json_rpc_call_completed: Silence incorrect type cast warning\n- icarus: Silence warning about (never really) uninitalised variable use in\nicarus_scanhash\n- fpgautils: Check for fgets error\n- Silence warning about (never really) uninitalised variable use in\nmulti_format_unit\n- ft232r: Silence warning about (never really) uninitalised variable use\n- Silence unused result warnings for notifier_{read,wake}\n- Log a warning if --cmd-* returns a non-zero exit code\n- configure: Update bigpic driver dependency on bitfury code\n- metabank: Initialise --temp-cutoff to 50C\n- README.ASIC: Document special care needed for some bitfury-based miners\n- Bugfix: bitfury: Correct results from RPC pgaset\n- bitfury: Move Slot and fasync RPC info to details instead of status\n- bitfury: Include chip fasync in RPC status\n- bfsb: Split up processors among a separate device per board\n- Bugfix: bitfury: Copy rxbufs to stack in case we need to do SPI communication\nin the meantime\n- bfsb: Merge bfsb_detect_chips into bfsb_autodetect (unchanged)\n- bfsb/metabank: Allow pgaset to change osc6_bits and SPI baud rate\n- bitfury: Fix code indentation\n- bitfury: bitfury_init_oldbuf: Optimise during runtime\n- metabank: Remove unused variables\n- bitfury: Send a work with lots of nonces to help cold-started bitfurys fill a\nstatic buffer\n- Bugfix: configure: Show --enable-bfsb/metabank in help, since they are\ndisabled by default\n- metabank: Reduce i2c banking to only when necessary\n- bfsb: Only build spi_bfsb_select_bank if bfsb driver is being compiled\n- bitfury: Reorganize polling to hit chips sequentially, so SPI traffic can be\nminimised\n- bitfury: spi_emit_data: Return address read data will be located at after txrx\n- bitfury: After 8 bad nonces in a sample period, reinit immediately rather than\nwaiting for the remaining up-to-0x38\n- bitfury: Reinitialise chips if their active nonce stops changing\n- bitfury: Recalibrate immediately when we know we need it\n- bitfury: Reset chips if more than 8 hw errors are found in a 0x40 result\nsample period\n- bitfury: If previous nonce mismatch persists, try recalibrating oldbuf\n- bfsb: Shutdown chip when disabling\n- bfsb: Expose Clock Bits and Slot to RPC\n- configure: Simplify dynclock necessity detection\n- configure: Tie libudev usage to fpgautils\n- configure: Simplify fpgautils necessity detection\n- DevAPI: add_cgpu_slave for more elegant multi-device threads\n- Use procs count for device summaries, rather than iterating over linked list\n(which may span multiple devices)\n- metabank: Split up processors among a separate device per board\n- metabank: Merge metabank_detect_chips into metabank_autodetect (unchanged)\n- Removed temperature output from metabank_api_extra_device_status().\n- Modified code to store temperature at cgpu->temp for metabank devices.\n- bitfury: Added get_api_extra_device_status for 'devs' request in metabank\ndriver: Slot, Clock Bits, Temperature, Voltage.\n- minerloop_async: Run watchdog code within actual device thread\n- bitfury: Remove unused libbitfury_readHashData\n- Bugfix: DevAPI: Don't call job_process_results when there was no previous job\n- bigpic: Convert to async minerloop\n- bitfury: Port to Windows\n- bigpic: Use bitfury_fudge_nonce\n- Use common bitfury_decnonce for all bitfury-based devices\n- Rename bf1 driver to bigpic, as the same device has other brands too\n- bf1: Clean up log messages\n- bf1: Reduce loglevel of debug messages\n- Bugfix: bf1: Add missing header to Makefile.am, and fix .dname/.name\n- Bugfix: bf1: Fix warnings\n- BF1 driver modified to work under Windows -> packing of structs isn't working\nwith Windows\n- Corrected hash rate estimation for BF1. Only 756 out of 1024 nonces are\nscanned.\n- Cleaning up the bf1 driver code\n- BF1 driver working\n- Bitfury BF1 source files added\n- bfsb: modified to use LukeJr:'s new code\n- configure: Reorder output\n- configure: Allow to build *fury drivers only\n- bitfury: Turn commented debug stuff into #ifdef BITFURY_SENDHASHDATA_DEBUG\n- bitfury: Implement queue_full to ensure all processors have a work ready\nbefore scanwork\n- bfsb: set api speed to 625khz\n- initial support for bitfurystrikesback boards\n- bitfury: LINE_LEN instead of 2048\n- bitfury: 4Mhz SPI by default\n- bitfury: double SPI polling\n- bitfury: +Strange Counter -printf Counter\n- bitfury: tuning of parameters; fixed cycles calculation\n- bitfury: Move clock increase from common code to metabank driver init\n- bitfury: Add driver-bitfury.h for shared function declarations\n- bitfury: Do debug logging of read data before rotation\n- bitfury: Decode nonce array sooner to make debugging easier\n- bitfury: Check that the previous nonce still matches, to detect response\ncorruption\n- bitfury: Workaround corruption by looking for matches rather than changes\n- bitfury: Rewrite using async minerloop (currently only setup on metabank\ndriver)\n- bitfury: Fix memory issues\n- littlefury: Turn off chips when exiting\n- littlefury: Adapt to 16-bit payload size (protocol change)\n- Bugfix: littlefury: Fix bitfury_do_packet\n- bitfury: Report bad nonces properly\n- bitfury: Unify common nonce fudging code\n- Bugfix: bitfury: Chips only scan 0xbd000000 nonces per work\n- bitfury: Fix logging to use applog\n- bitfury: Split driver into bitfury_gpio (bare GPIO) and metabank (i2c banked\nGPIO)\n- littlefury: Use bitfury driver scanwork\n- bitfury: Eliminate more static variables\n- bitfury: Treat each chip as its own processor\n- bitfury: Resolve devices[chip] only once per chip\n- bitfury: Move second_run logic back to libbitfury\n- bitfury: Loop over chips once during scanwork\n- bitfury: Abstract hashes_done2 which keeps track of time deltas per thr on its\nown\n- littlefury: Need to set tv_morework\n- bitfury: Abstract out payload_to_atrvec\n- littlefury: Log read return value when unexpected\n- bitfury: Eliminate non-const global variables\n- littlefury: Safeguard on job switching\n- Bugfix: littlefury: Keep reading until error, EOF, or buffer filled\n- littlefury: Log devproto of incomplete reads\n- Enable littlefury detection\n- Bugfix: configure: Enable bitfury by default properly\n- bitfury: Require explicit -S bitfury:auto to probe GPIO-based SPI\n- bitfury: Move i2c slot handling to metabank-specific driver code\n- littlefury: Initial driver for BitCentury's USB miner\n- bitfury: Split actual chip detection into simple function\n- Bugfix: bitfury: Fix driver \"name\" to be correct length\n- bitfury: Abstract SPI interface\n- Bugfix: bitfury: Fix more warnings\n- Bugfix: bitfury: Fix warnings\n- bitfury: Intercept and use applog for perror calls\n- Bugfix: bitfury: Handle SPI init failure cleanly\n- bitfury: major intermediate update\n- bitfury: added chip series detection; multiple chip mining\n- Bitfury ASIC initial support\n- DynClk: Improve commented documentation\n- Replace Utility with (expected) Income calculated by actual shares submitted\nin 100% PPS value\n- format_unit3: BTC formatting with 2 decimal place digits\n- format_unit3: Support for nano- and pico- sizes\n- format_unit3: Use an enum for float-precision parameter\n- format_unit2: Support milli- and micro- unit prefixes\n- opencl: Disable by default if other devices are found; to enable, use -S\nopencl:auto\n- write_config: Save request-diff option\n- Stratum: Clear unused extranonce2 space\n- Don't even show 'Attempting to restart' for devices that don't support it\n- Workaround bug in PDCurses wresize\n- Bugfix: Include config.h in sha2.c first\n- make-release: Include libevent-2-0-5.dll in Windows packages\n- README: Document dependency on libevent\n- README: Document new --chroot-dir and --setuid options\n- Bugfix: Use correct configure define for chroot\n- Remove --disable-chroot build option: always compile --chroot-dir if supported\n- Bugfix: Use correct configure define for pwd.h\n- Improvements on code\n- Update miner.c\n- Added basic chroot support, added option to configure.ac.\n- Updated miner.c\n- Added basic chroot support\n- Replace u-hashrate with nonce-based hashrate adjusted for rejects/stales\n- SSM: Windows port\n- SSM: Allow configuring stratum port via --stratum-port option and RPC\nsetconfig\n- SSM: Implement mining.hashes_done extension\n- Proxy: Catch invalid usernames and error\n- SSM: Report hashes done based on share submissions\n- SSM: Include current time in job ids to avoid false hardware errors due to job\nid reuse\n- SSM: If no notify is currently set, try to set it before refusing a subscribe\n- SSM: Prune old jobs after expiry\n- SSM: Use pool data read lock when subdividing notify\n- SSM: Gracefully fail when upstream stratum notify cannot be subdivided\n- SSM: Gracefully fail when upstream pool is not stratum (by closing subscribed\nclients, and refusing to subscribe new ones)\n- SSM: Properly fail cleanly when maximum clients are connected\n- SSM: Clean up stratumsrv_job when pruning it\n- SSM: Avoid responding to notifications, and give an error for unknown methods\n- SSM: Propagate work updates to clients\n- Mostly functional stratum proxy driver\n- Stratum: Split actual work generation away from the current pool data\n- Bugfix: Stratum: Dereference pool swork coinbase buffer inside data lock\n- SGW: Split proxy code out from driver-getwork into driver-proxy\n- Bugfix: miner.php: Check $dototal[$name] is set before comparing its value\n- Bugfix: RPC: Use bad_nonces in Hardware% instead of generic hw_errors\n- Bugfix: RPC: Handle LIFE_DEAD2 case\n- Make failure to open sharelog or noncelog abort startup\n- Nonce logging option --noncelog to simply store every nonce and its info\n- Abstract --sharelog option parsing\n\n\nBFGMiner Version 3.2.1 - September 19, 2013\n\n- Only show long-poll message in pool summary if it's not using stratum.\n- README.ASIC: Clarify syntax of --scan-serial usage for USB Erupters\n- Bugfix: RPC: Defer allocation of apisock until after we check for --api-listen\n- make-release: Only try to include libmicrohttpd if bfgminer.exe depends on it\n- Bugfix: make-release: Include libplibc-1.dll if available\n- SGW: For Windows builds, include winsock2.h instead of POSIX networking\nheaders\n- configure: Display getwork proxy server support in summary\n- Bugfix: SGW: Pass actual cgpu_info to prune_worklog_thread instead of silently\ncasting one from getwork_client\n- Bugfix: Get total_staged with lock for TS stat, before getting console lock\n- Bugfix: bitforce: Correct fanmode RPC help\n- bitforce: Hide fan control when disabled in firmware\n- Bugfix: bitforce: Correct fanspeed TUI setting\n- Bugfix: logging: Allow up to 4 KB for log lines\n- Bugfix: icarus: Ensure last2_work exists before trying to check nonces fit it\n- README.OpenWrt: Include serialusb drivers\n- README: Include OpenWrt serialusb driver package names\n- Bugfix: Initialise notifier (as invalid) for no-thread devices (SGW)\n- Bugfix: Free temporary kernel path copy when writing config file\n- Bugfix: Put kernel path on the (main) stack after initialisation from\ncommandline/config, to avoid appending an argv or jansson string\n- Bugfix: Always allow startup with curses enabled (since the user can use\nManage devices to add new ones, and display Ctrl-C for text-only quit help\n- Bugfix: Ignore/reject libmicrohttpd before 0.9.5, which introduced symbols we\nneed\n- README: Elaborate on format of BW\n- Bugfix: Try to initialise libusb later, so any mutexes applog might need are\ninitialised\n- Bugfix: Implicitly initialise timer_set_now when it is first called\n- util: Eliminate unsafe const-removing casts\n- configure: Cleanup CFLAGS/LDFLAGS display\n- Show RT_LIBS in ./configure output.\n\n\nBFGMiner Version 3.2.0 - August 29, 2013\n- cpu: sse2_64: Rename sha256_init to sha256_init_sse2 to avoid conflict with\nnew sha2.c\n- httpsrv: Some older versions of libmicrohttpd need stdint.h included first\n- make-release: Include libmicrohttpd-10.dll if it exists\n- Fixes column alignment in decimal fields. Workaround for printf rounding up\nwhen formatting decimals into limited width.\n- New hidden --unittest option. No longer runs unit tests at startup by default,\nfor faster startup. Added unit test for width printing of decimal numbers.\n- Bugfix: configure: More fixing BSD sed syntax for curses header search\n- Bugfix: configure: More fixing BSD sed syntax for libusb header search\n- README: Update solo mining docs\n- erupter: Continue searching a job until the end, even if an earlier result is\nfound\n- icarus: Do hwerror-triggered reopen before sending the next job the first\ntime, to avoid having to resend it later\n- icarus: Avoid sending a new job if the nonce found was for one before the\ncurrent job anyway\n- icarus: Double-buffer work to solve nonces found before work change takes\neffect\n- icarus: Abstract nonce processing\n- Bugfix: icarus: Avoid trying to submit 0 on comms error\n- icarus: Skip unnecessary nonce memcpy\n- icarus: Make state->last_work a pointer and store it on the heap\n- miner.php fix missing global\n- Bugfix: erupter: After identify, skip starting work if next scanhash is\nalready decided to be a \"first run\" (eg, device errors)\n- Bugfix: erupter: Fix identify following hw error\n- Bugfix: icarus: Don't try to send work if device open failed\n- Debug log when zeroing stats\n- Upgrade libblkmaker to 0.3.2\n- Bugfix: GBT: Advertise coinbasevalue capability\n- Bugfix: Always compile add_serial now that it's somewhat generic\n- icarus: Avoid sending a new job if the nonce found was for one before the\ncurrent job anyway\n- icarus: Double-buffer work to solve nonces found before work change takes\neffect\n- icarus: Abstract nonce processing\n- Bugfix: icarus: Avoid trying to submit 0 on comms error\n- icarus: Skip unnecessary nonce memcpy\n- icarus: Make state->last_work a pointer and store it on the heap\n- README.RPC: Remove usbstats mention\n- README: Add FAQ regarding cgminer messing up drivers\n- README.RPC: Fix miner name\n- README.RPC: Correct to mention other supported devices for pgaidentify\n- api.c fix mcast debug message bug\n- README.RPC: break all lines at most 80 characters\n- Update the API Multicast documentation\n- miner.php implement API Multicast handling to automatically find your local\nnet miners\n- Bugfix: RPC: Fix log format types in io_flush\n- Set RT_LIBS correctly from autoconf detection\n- Explicitly check for clock_nanosleep and only use it when available\n- Further integrate cgsleep API into BFGMiner's timer system, so clock_nanosleep\nis only used on platforms with CLOCK_MONOTONIC\n- Convert cgtimer_t to struct timeval\n- Bugfix: Fix BSD sed syntax for curses header search\n- Bugfix: configure: Really fix BSD sed syntax for libusb header search\n- README.RPC: Mention multicast detection\n- README: Include --mcast-* options in usage\n- Use ccan's standard char* set/show functions for --api-mcast-{addr,code}\n- Bugfix: RPC: Use the same mcast code in reply, and log it correctly\n- API mcast only reply to remote IP's that are allowed access\n- Initial API Multicast response v0.1 to find cgminer APIs\n- Check for cnx_needed on each loop through wait_lp_current.\n- Return positive for cnx_needed when no_work is true.\n- Add no_work bool to set when we are in an underrun situation\n- Reorder support names alphabetically.\n- We don't want to continue into the hash_pop function if the getq is frozen.\n- Carve out the unused portions of sha2 implementation.\n- Import Aaron D. Gifford's fast sha256 implementation.\n- Use cloned work when finding avalon results since another thread can discard\nthe work item while it's in use.\n- Provide a variant of find_work_bymidstate that returns a clone of the found\nwork.\n- Use timespecs on windows as cgtimer_t to capitalise on the higher resolution\nclock changes.\n- Abstract out the conversion of system time to an lldiv_t in decimicroseconds.\n- Use our own gettimeofday implementation on windows for it to be consistent\nacross ming builds and higher resolution.\n- Provide cgtimer_sub helper functions.\n- Provide cgtimer_to_ms helper functions.\n- Rename cgsleep_prepare_r as cgtimer_time to get time in cgtimer_t format and\ncall cgsleep_prepare_r as a macro for cgtimer_time\n- TimeBeginPeriod and TimeEndPeriod do not add significant overhead when run the\nentire time for cgminer so avoid trying to maintain balanced numbers of them for\nspecific time calls to simplify code.\n- Replace all references to the old n*sleep functions with the equivalent\ncgsleep_*s replacements.\n- timeGetTime uses huge resources on windows so revert to using timevals for its\nimplementation of cgtimer_t\n- Quotient/remainder error in ms division.\n- Provide cgtimer_to_timeval helper functions.\n- Provide a timeval_to_cgtime helper function to reuse values.\n- Simplify cgsleep code for windows by using a typedef for cgtimer_t that\nresolves to clock resolution, using that internally.\n- On windows use the higher accuracy timegettime function to really get 1ms\nclock and timer accuracy.\n- Fix missed endtimeperiod in overrun timer on windows.\n- Make cgsleep_us_r take an int64_t for us.\n- Make the cgsleep functions build on windows.\n- Set high resolution timing on windows within the cgsleep functions.\n- Provide reentrant versions of cgsleep functions to allow start time to be set\nseparately from the beginning of the actual sleep, allowing scheduling delays to\nbe counted in the sleep.\n- Make the nmsleep and nusleep functions use the new cgsleep functions internally\ntill functions are migrated to the new cgsleep API.\n- Add a ms_to_timespec helper function, and create a cgsleep_ms function that\nuses absolute timers with clock_nanosleep to avoid overruns.\n- Add rt lib linkage to enable use of clock_nanosleep functions with older\nglibc.\n- Add a timeraddspec helper function.\n- Provide a us_to_timespec helper function.\n- Provide a us_to_timeval helper function.\n- Add helper functions to convert timespec to timeval and vice versa.\n- Bugfix: SGW: Discard work from log only by expiry, so post-startup hardware\nerrors are truly only hardware errors\n- bitforce: Make voltages available to RPC\n- bitforce: Save voltages as array of longs internally\n- Bugfix: Clear device bad nonces when zeroing stats\n- cpu & opencl: Defer RUNONCE to actual autodetection, so they can be added once\nafter startup\n- Bugfix: Avoid crash activating [M]anage devices with no currently defined\ndevices\n- TUI: Support for adding new devices using the plus key from [M]anage devices\n- Bugfix: Use add_serial function for scan_serial, so that \"all\" keyword works\ncorrectly\n- SGW: Add support for new X-Hashes-Done header to allow devices to more\naccurately report their work\n- SGW: Add X-Mining-Identifier header to inform devices what they are\nrepresented by in BFGMiner\n- SGW: Use JSON for 401 response; add Server HTTP header\n- AUTHORS: Add contributor Josh Lehan\n- Changed comparison constants to allow for floating-point rounding\n- Install README.ASIC for Block Erupter related drivers as well as Avalon\n- make-release: Windows users don't need README.Debian\n- README.OpenWrt: Import from BFGMiner downloads\n- Silence Windows warning about send data signedness\n- Fix block info\n- API/miner.php add some % fields\n- Don't yield on grabbing the read lock variant of cglocks.\n- util.c expand quit to show file/func/line\n- We should be using a cg_wlock initially in generating stratum work before\ndowngrading the lock.\n- Add the ability to downgrade a write variant of the cglocks.\n- Yield after releasing a lock in case we are on a device with limited CPU\nresources.\n- Fix --scrypt being required before scrypt intensities on command line or not\nworking at all via config files.\n- Limit intensity range according to whether scrypt is in use or not.\n- Do not allow benchmark mode to be used with scrypt.\n- miner.php format Best Share\n- README.ASIC block erupter USB brief\n- Check for negative wait time in socket_full.\n- Adjust socket wait timeout in recv_line according to how long we've already\nwaited to avoid a 60 second wait dropping to 1 second due to a blocked socket.\n- force type checking on curses\n- logging - size check sprintf\n- Only use length-counted variants of format_unit and percentf\n- Implement snprintf-like versions of format_unit and percentf\n- miner - size check all sprintf\n- size check get_datestamp/get_timestamp and remove unused cgpu->init\n- make all statline overflow safe\n- Convert the decay_time function into one that truly creates an exponentially\ndecaying average over opt_log_interval.\n- GPU fan rpm display 9999 when it overflows\n- Change mode on python file.\n- Only update hashmeter if we have done hashes or haven't updated longer than\nthe log interval, fixing a us/ms error.\n- README.ASIC: Document usage with Block Erupter Blades\n- README: Add mention of libmicrohttpd to dependencies\n- SGW: Include hash1 in work\n- SGW: Include application/json Content-Type header\n- Fix build without libmicrohttpd\n- Allow startup to proceed with no devices, as long as RPC or HTTP are listening\n- SGW: Refuse to issue new work to disabled devices\n- SGW: Respond with stale rejection if share is known to be immediately stale\n- Expose HTTP getwork username in Manage TUI and devdetails RPC\n- Add --cmd-idle notification command for REST/WAIT conditions\n- bfgminer-rpc: Accept unlimited size replies\n- api-example.py: Accept unlimited size replies\n- RPC: Rewrite io_data to cleanly handle unlimited sized responses\n- Configure options to build --without-libmicrohttpd support\n- RPC: setconfig can now change http-port (enabling or disabling the http\nservice included)\n- Embedded HTTP server to handle getwork-based mining devices\n- inc_hw_errors2 function can handle a bad nonce without a known work\n- Split up scan_serial function to enable internally adding ad-hoc cgpu\n- Helper functions bfg_json_obj_string and share __json_array_string\n- bytes_t: Add bytes_shift and bytes_nullterminate\n- Fix configure help for --without-sensors\n- README: Document --with-system-libblkmaker\n- Bugfix: Use BSD-friendly sed syntax for libusb header search\n- Bugfix: Handle bitstreams properly\n- Bugfix: Skip search for addwstr since it breaks --with-curses=preference\n- Bugfix: configure: Find correct curses include path without *-config\n- README.FPGA: Further clarify ZTEX setup\n- Display a friendly error directing to README.FPGA when bitstream cannot be\nloaded\n- Remove bitstreams from BFGMiner distribution entirely, and include pointers\nwhere to find them in README.FPGA\n- ztex: Use load_bitstream_bytes for .bin files\n- fpgautils: load_bitstream_bytes support for Intel HEX format (.ihx) files\n- Add missing 16-bit byteswap macros\n- fpgautils: load_bitstream_bytes function to load a bitstream into a bytes_t\n- bytes_t functions: bytes_init, bytes_append, bytes_reset\n- Look for bitstreams in /usr/share/bitstreams\n- Disable Unicode support by default (use --unicode to enable)\n- make-release: Skip stripping debug info from Windows EXEs, for now\n- Bugfix: Ensure work variable is assigned before checking its thr_id\n- Bugfix: notifier_init (Windows): setsockopt needs an int for SO_REUSEADDR\n- Bugfix: Avoid turning totals red just because a processor is idle\n- Enable notifications for sick/dead with --cmd-sick and --cmd-dead options that\nexecute commands when the event occurs\n- RPC: Add cpu enable/disable/restart\n- windows-build: Update to use libpdcursesw.dll\n- Ensure socket error messages are used for socket errors on Windows\n- fpgautils: Attempt to use Linux advisory locks on serial devices\n- Bugfix: README: --temp-cutoff sets the maximum temperature before cutoff, not\ntemperature that triggers cutoff\n- Bugfix: Avoid incrementing dev_thermal_cutoff_count when just updating\ntimestamp on status\n- Detect curses support for wide characters during configure\n- configure: Check for more variants of curses library names\n- Bugfix: ztex: Avoid trying to format non-libusb error with libusb error name\n- Bugfix: Avoid trying to assign const use_unicode variable with --no-unicode\noption\n- Remove long-unused opt_time variable\n- RPC: Avoid exposing Coinbase-Sig when it isn't supported\n- Bugfix: Fix build with libblkmaker < 0.2\n- Attempt stratum mining.suggest_target before mining.subscribe, if\n--request-diff is used\n- Retry stratum if initiation fails for any reason after we have sent something\n(assuming there is more older variants we can try)\n- Bugfix: Restore delay for authorization on stratum mining.get_transactions\n- Bugfix: Fix TUI-only build\n- bitforce: Extend pgaset _cmd to variable-length commands\n- Bugfix: Use red for total processor count\n- bitforce: Undocumented _cmd1 pgaset for experimenting with firmware\n- Bugfix: curses: use_default_colors() when possible\n- Bugfix: Calculate scrolling range with new cursor lines\n- Bugfix: Ensure use_unicode and have_unicode_degrees constants are defined for\ncurses-less builds\n- Bugfix: Replace block_timeval with (time_t) block_time\n- README: Update for --no-unicode option\n\n\nBFGMiner Version 3.1.4 - August 2, 2013\n- Windows: Rebuild pdcurses with UTF-8 and wide character support\n- Bugfix: Avoid using wide curses symbols/macros when USE_UNICODE is not defined\n- Unicode: Use line drawing in TUI Help\n- Use bfg_waddstr even with Unicode disabled, since it's needed for red\nhighlight\n- Colour bad conditions in red\n- Unicode: Cross-tee intersecting lines\n- Unicode: Use WACS_VLINE for vertical lines\n- Unicode: If degrees symbol is available, add it to temperatures\n- Unicode: bfg_waddstr wrapper to handle non-ASCII characters, currently used\nonly by logging and statlines\n- Unicode: Use WACS_HLINE for horizontal lines\n- Add framework for using Unicode in TUI (can be disabled with --no-unicode)\n- Avoid using potentially locale-dependent ctype functions in locale-independent\ncontexts\n- Refactor temperature in TUI statlines to share code nicer\n- Bugfix: avalon: Fix applog formatting\n- Bugfix: Align totals columns in per-processor view\n- Bugfix: Fix curses-less build\n- configure: Workaround buggy autoconf versions\n- Bugfix: erupter: Include headers in order necessary for Windows\n- Bugfix: Reimplement get_intrange using strtol instead of sscanf (which is\nbroken on Windows)\n- Bugfix: get_intrange: Check for extra garbage at the end, only after we know\nwe have an end-position\n- Bugfix: Fix Enter key in TUI on Windows\n- erupter: Split identify-handling logic into handle_identify function\n- Bugfix: erupter: Ensure identify is handled during no-once or firstrun\n- erupter: After identify, check if a work restart is needed immediately\n- erupter: Implement identify function by pausing hashing for 3 seconds\n- Bugfix: icarus: Remember firstrun state in case it gets changed for the next\nrun\n- icarus: Move actual dynclock updates to icarus_job_start\n- icarus: Split out icarus_job_prepare, and rename icarus_job_start\n- Bugfix: ZeroStats: Reset column widths to 1\n- miner.php: Include max temperature in device totals line\n- Bugfix: Stratum Fix debug logging of initial mining.subscribe command\n- Bugfix: Call pool_set_opaque from work_decode, so block content hiding/\nproviding messages work for getwork/GBT\n- Split block contents hiding/providing notices out from stratum code\n- Add test suite for get_intrange\n- Bugfix: Check for error conditions in get_intrange to not have weird --device\nbehaviour when bad values are provided\n- Bugfix: erupter: Take advantage of detectone_meta_info to handle Emerald\nautodetection\n- TUI Help describing the various status fields (contributed by midnightmagic)\n- Bugfix: ManageTUI: Allow 'I' key to be used by devices not supporting identify\n- Bugfix: Prefer Sapphire over Emerald for -S erupter:*\n- Bugfix: Clear total_bad_nonces when zeroing statistics\n- Bugfix: modminer: Since we are not searching iManuf string for needles, only\nlook for \"ModMiner\"\n- Bugfix: sysfs autodetect: Recurse into tty/ subdirectory (necessary for\nCDC/ACM ttys)\n- sysfs autodetect: Split tty* directory search into new _sysfs_find_tty\nfunction\n- modminer: Reduce default clock to 190 MHz\n- README: Update driver info to include Erupter driver\n- README: FAQ about scrypt and difficulty\n- Include count of working devices/processors in totals statline\n- Format totals statline the same way as individual device/processor statlines\n- Rearrange TUI a bit, including menu at the top (+1 log line) and hashrate\ntotal closer to device summaries\n- Bugfix: setup_stratum_curl: Need to release stratum lock on connection failure\ntoo\n- Bugfix: Avoid unnecessary locks inside curses_print_status, which is called\nwith the console lock held\n- Bugfix: setup_stratum_curl: Hold stratum lock until connection completes, to\navoid potential races\n- Bugfix: stratum_works: If stratum is already active, it works (avoid trying to\ninitialise it again)\n- Replace hashrate_to_bufstr/ti_hashrate_bufstr with format_unit/\nmulti_format_unit_array\n- New multi_format_unit_array to fill multiple buffers instead of building a\ndelimited string\n- multi_format_unit: Skip recounting length of fixed-length strings\n- Shrink status line to fit in 80 columns\n- Add network bandwidth rate to TUI\n- New multi_format_unit variadic macro to handle formatting multiple numbers at\nonce\n- format_unit: Option to choose 3-digit integer display vs 5-character floating-\npoint display\n- Optimization: format_unit: Handle number first, to avoid having to restore\nsuffix later\n- Generalise hashrate_pick_unit/hashrate_to_bufstr into pick_unit/format_unit\n- Extend hashrate_pick_unit/hashrate_to_bufstr to handle sub-kilo units\n- Split total_bytes_xfer to total_bytes_rcvd and total_bytes_sent\n- Bugfix: _decode_udev_enc_dup: Allocate enough space for full string\n- Bugfix: Never use waddstr for logwin, since it would bypass special newline\nhandling\n- Bugfix: bitforce: Set kname on chip processors\n- bitforce: Include voltages in Manage device TUI\n- Defer newlines going to curses logwin, to avoid a useless blank line at the\nbottom of the window\n- Ensure printing to logwin always goes through _wlog\n- Remove blank line above log window\n- bitforce: Identify parallel queue protocol distinctly from mere bulk queue\n- ManageTUI: Include kernel name, when available\n- Stratum: Roll ntime as we generate work\n- Stratum: Make swork.ntime native-endian\n- Stratum: Treat ntime as uint32_t (as it should be), still always big endian\n- Debuglog ManageTUI actions/responses\n- ManageTUI: Add generic Identify support\n- Bugfix: Move serial_detect* and open_bitstream to DevAPI code so CPU/OpenCL\ncan build properly without fpgautils\n- Short-circuit logging sooner in quiet mode\n- Write to both stderr and console within same console lock \"session\"\n- Bugfix: Also hold the console lock when writing to stderr\n- Use common console locking function for stdout in logging.c\n- Move console lock and unlock functions (which also handle thread cancelstate)\nto miner.h\n- Bugfix: bitforce: Only try to clear queues of SC devices, since FPGA MR boards\ninterpret ZQX/ZOX differently\n- Timer-based gettimeofday substitute for systems with poor time-of-day clocks\n(Windows)\n- Use clock_gettime(CLOCK_MONOTONIC) for timers when available\n- Use QueryPerformanceCounter for timers on Windows\n- Generic refactoring for timer_set_now\n- Replace all remaining uses of gettimeofday for timers, with timer_set_now (aka\ncgtime)\n- Don't mix timers with timestamps (visual only)\n- Always use struct timeval for timers, and don't mix timers with timestamps\n(functional only)\n- get_datestamp: Change timeval parameter to time_t, and implement\nget_now_datestamp for common \"current time\" use case\n- Use get_datestamp for (non-microsecond) log timestamps\n- Bugfix: ztex: Allocate final processor names on the heap, so they survive when\nthe stack for ztex_prepare is gone\n- Bugfix: ztex: Copy serial number to device \"name\" before cloning it for other\nprocessors\n- Bugfix: x6500: Use cgpu->temp directly since there is only one sensor per\nprocessor\n- Bugfix: Actually show the highest temperature, not just calculate it\n- x6500: Allow changing clock speed from TUI Manage device\n- x6500: Port pgaset clock from modminer driver at\n66d2a3ab072fcdbc3c7ed41a97f265afa917bbee\n- modminer: Allow changing clock speed from TUI Manage device\n- bitforce: Flush job and result queues at startup to avoid unnecessary warnings\n- x6500: Reduce default clock to 190 MHz\n- Bugfix: fpgautils: Close libusb handle after copying USB strings\n- use BSD sed syntax to generate iospeed_local.h\n\n\nBFGMiner Version 3.1.3 - July 11, 2013\n- Bugfix: Reset staged_full flag when discarding (stale) popped work, or\nincreasing the queue minimum\n- Bugfix: Only trigger staged work underrun if a mining thread was actually\nwaiting for it (and do so sooner, before it has the work made)\n- bytes_cpy: avoid malloc and memcpy when size is zero\n- fix infinite loop in bytes_cpy when size is zero\n- Bugfix: Generate iospeeds_local.h based on termios.h defines, and only try to\nuse POSIX standard if that fails\n\n\nBFGMiner Version 3.1.2 - July 8, 2013\n- When not compiling with optimizations, initialize unused nonce2 space to avoid\nwarnings from memory checking tools\n- TUI Manage devices: Support PgUp/PgDn keys to skip over processors within the\nsame device\n- Bugfix: bitforce: Prefer 2nd temperature if higher than 1st\n- When displaying device summary statlines, use the highest temperature reported\nby any processor\n- Stratum: Fix nonce2 sizes greater than 4 and (on big-endian) smaller than 4\n- bitforce: Manage TUI: Display both temperatures (if two), and enable changing\nfan speed\n- opencl: Add fan speed to Manage device TUI now that it's been removed from\nstatline\n- DevAPI: Remove old statline APIs entirely, and add new override_statline_temp\n(used by modminer/x6500 for upload %)\n- README: Update statlines\n- TUI: Replace DevAPI statline_before with a predefined temperature column to\nfree up statline space\n- Refactor and simplify bin2hex to speed up and avoid unnecessary heap use\n- stratum: Refactor work generation to do hex2bin conversions once, rather than\nevery single header generated\n- Implement bytes_t for generic binary data storage (including smart realloc-\nbased resize)\n- Bugfix: fpgautils: Only try to change baud rate when requested\n- x6500: Provide manuf/product/serial to cgpu interface\n- ztex: Provide manuf/product/serial to cgpu interface\n- erupter: Use baud 115200 by default\n- List valid baud rates once in iospeeds.h and standardize conversions\n- TUI: Display device manufacturer/product/serial in Manage device screen, when\navailable\n- DevAPI: Store manufacturer/product/serial for each device\n- fpgautils: detectone_meta_info to provide metainformation (manufacturer,\nproduct, serial) on devices to detectone functions\n- Bugfix: fpgautils: Close product string file from sysfs (autodetect)\n- erupter: New icarus-based driver to handle autodetection of Block Erupter\ndevices\n- Add --log-file option which redirects stderr to a file, but valid anywhere in\nthe commandline or config file\n- Detect staged work underruns and increase queue to avoid them\n- Rewrite hex2bin to perform much faster (reduces minirig CPU usage by more than\nhalf!)\n- README: Add condensed list of dependencies\n- Enable \"maintainer mode\" by default\n- Bugfix: opencl: TUI manage: \"Change settings\" must not be compiled in with\nno-ADL builds\n- Bugfix: Detect whether the linker accepts -zorigin before attempting to use it\n- opencl: ADL: ADL_Adapter_ID_Get fails with newer drivers, so tolerate its\nfailure best we can\n- opencl: Don't try to use BFI_INT patching with APP-SDK newer than 1084\n(Catalyst 13.1), since it doesn't work\n- fpgautils: Elaborate that bitstream open failures are probably due to missing\nbitstream package\n- fpgautils: s/firmware/bitstream/\n- Bugfix: Cleanup handling of complete device/driver failure\n- Deprecate -C (enable CPU) and -G (disable GPU) options, now that -S\ndrv:[no]auto can be used for the same purposes\n- Bugfix: Since at least one of unix (or __APPLE__) or WIN32 is required by\nutil.h, make sure unix is defined if WIN32 is not\n- Bugfix: Set ELF rpath for bundled libblkmaker to use $ORIGIN so it can be run\nfrom other directories\n- Bugfix: Cleanup needs to happen before printing the final quit message, or it\ngets lost in TUI mode\n- Bugfix: fpgautils: Initialize my_dev_t instances with null bytes, to ensure\nrandom unused data cannot influence hash keys\n- opencl: ManageTUI: Clear log cleanly for changing settings\n- Remove \"GPU management\" TUI entirely\n- opencl: Use new \"Manage device\" interface to do everything \"GPU management\"\nused to be used for\n- DevAPI: Add interface for drivers to define custom \"Manage device\" options\n- DevAPI: New function called to display additional processor information for\n\"Manage devices\"\n- TUI: Add enable/disable commands to device management\n- TUI: Implement beginnings of generic device management interface\n- Bugfix: avalon: Fix LIFE_INIT2 setting\n- Add LIFE_INIT2 status (safe to call functions, but not mining yet) for devices\nthat want to report initialization status in their statline\n- Bugfix: modminer: Only program once for --force-dev-init\n- Bugfix: x6500: Only program once for --force-dev-init\n- fpgautils: Workaround and document Xcode clang bug\n- Bugfix: avalon: Correctly claim serial port\n- Bugfix: -S all: Mac OS X needs to probe /dev/cu.*, not just /dev/cu.usb*\n- cpu & opencl: Refuse to detect more than once\n- cpu & opencl: Respect scan-serial auto/noauto instructions\n- ft232r & libztex: Skip probe of claimed devices\n- fpgautils: Check for devices being claimed before calling detectone from autodetectors\n- x6500 & ztex: Claim USB devices\n- fpgautils: Implement bfg_claim_usb for claiming devices by USB bus number and\naddress\n- fpgautils: Replace serial_claim with bfg_claim_serial using a more cleanly\nextensible interface and implementation\n- fpgautils: serial_claim: Include a bus enum in hash key\n- Add serial port claiming logic to avalon, bitforce, and modminer drivers\n- RPC: \"devscan\" command to probe for new devices\n- New (internal) scan_serial function to probe for new devices at runtime\n- Split out per-cgpu temperature configuration code to load_temp_config_cgpu\n- DevAPI: Modify add_cgpu to use temporary devices_new array, so detection can\nbe done without touching live variables\n- Move more cgpu initialization to allocate_cgpu\n- Move devtype default assignment to allocate_cgpu\n- Move cgpu startup routine to new start_cgpu function\n- Move cgpu_info allocation to new allocate_cgpu function\n- Move *.drv_detect calls to a new drv_detect_all function\n- DevAPI: add_cgpu: There is no need to hold mutexes while creating devices\n- Bugfix: cpu: Update device \"kernel name\" with auto-selected algorithm\n- usbtest: Improve portability to at least 2.7 and 3.2\n- usbtest: Avoid messing up the display by escaping weird bytes via repr()\n- usbtest: Skip last 2 optional parameters, since we use the defaults and they\nare not in older versions of pyserial\n- Bugfix: bitforce: ZOX limits results to 16 results per call, so repeat ZOX\nuntil there are fewer\n- Bugfix: Initialization for bfgtls needs to be done in each thread\n- Bugfix: stratum: Be patient with stratum lines that come in slower than we can\nprocess them\n- Use bfg_strerror in locations previously just logging raw error numbers\n- Bugfix: stratum: Log WSAGetLastError() for error number on recv failures on\nWindows\n- Use bfg_strerror where it is already needed (for thread-safety)\n- New thread-safe bfg_strerror function to portably stringify error codes\n- Bugfix: bitforce_queue: Initialize buf2 so errors don't cause the work queue\nto flush\n- TUI: Display percentage invalid of found nonces with hw errors\n- Bugfix: modminer & x6500: Increment *->diff1 for all bad nonces\n- percentf2 that takes t as precalculated total\n- Keep track of bad nonces independently from generic hw errors\n- inc_hw_errors: Resolve cgpu outside of mutex\n- Use inc_hw_errors function at every site which increases hw_errors\n\n\nBFGMiner Version 3.1.1 - June 22, 2013\n- stratum: Deliver exact socket-error within the debug error message\n- Don't install docs for (compile-time) disabled functionality\n- Bugfix: Handle make dependencies on subdirectory files properly\n- Bugfix: Use EXTRA_*_DEPENDENCIES for Cygwin workaround, to fix program make\ndependencies\n- Support new overclocking speeds for avalon: 325, 350 and 375\n- Bugfix: logging: Since we are inlining snprintf, stdio.h is needed\n- Bugfix: serial_autodetect_ftdi: Debuglog FTDI COM port mappings returned, fix\ntype of FT_HANDLE\n- Bugfix: Allow starting non-libusb devices if libusb_init fails\n- Bugfix: Add missing newline to libusb_init failure message\n- Bugfix: opencl: Remove unnecessary casts from rot() macro, which created type\nissues\n- Bugfix: Remove unused variables\n- Suspend stratum connections when we know they've failed and don't try to recv\ndata from them once the socket no longer exists.\n- applog/quit fix GPU errors created\n- logging remove extra added <LF>\n- remove varargs from logging/quit/in general as much as possible\n- compile unix code on Mac OS X fixes not finding the config file in $HOME\n- Create a pool_localgen bool function for testing when a pool can generate work\nlocally.\n- Use mining start time for device MH/U calculations\n- Bugfix: Save start time for stats to correct \"Elapsed\" key on \"stats\" RPC\nrequest\n- modminer: tidy up free in device detect function\n- bitforce: RPC pgaset fanmode 9 for auto fan control\n- Bugfix: usbtest: Correct obvious typos\n- Initial import of usbtest.py script\n- Include microseconds in log output with new --log-microseconds option\n- bitforce: Workaround chip ids not necessarily being in order by choosing\nprocessor count based on expected chip ids rather than parallelization\n- serial_autodetect_ftdi: Debuglog FTDI COM port mappings returned\n- Bugfix: On stratum disconnect, clear stratum_active and stratum_notify\natomically along with sock\n- Windows: Use backtrace.dll to print usable backtraces to stderr on crash\n- Bugfix: bitforce: parallelized: Properly handle parallelized protocol with\nonly 1 chip\n- Bugfix: bitforce: XLINK: Increment boardno when moving on to the next board\n- bitforce: XLINK: Update to use actual length,xlinkid header order\n- Bugfix: bitforce: XLINK: Avoid trying to send 0 bytes after each write\n- Bugfix: opencl: Build fpgautils even if OpenCL is the only driver, now that it\nuses it for kernel-finding\n- Bugfix: Do not try to call get_stats or get_statline* if device is still\ninitializing\n- Bugfix: opencl: Add missing include for fpgautils.h (needed for\nopen_bitstream)\n\n\nBFGMiner Version 3.1.0 - June 13, 2013\n- Bugfix: openwrt: Expect fixed bitstream path for input\n- Improve Makefile organization and fix \"make install\"\n- icarus: Upgrade work division autodetection probe to be faster and also detect\n8 core\n- Calculate rejection percentage based on weighed shares, not absolute counts\n- Count weighed discarded (stale) shares per cgpu\n- Bugfix: Cleanly count discarded (stale) shares without overlapping\ndevices/sshare locks within clear_stratum_shares\n- configure: Enable Avalon support by default now that it behaves reasonably\n- avalon: Since detection is not really implemented, only probe devices when the\ndriver is specified to -S by name (eg, \"avalon:/dev/ttyUSB0\")\n- Bugfix: bitforce_queue: Never try to reinitialize a slave processor\n- Bugfix: bitforce_queue: Use work_list_del everywhere we remove from work_list\nto ensure work gets freed properly when done\n- Reduce HW error logging to debug level, so it doesn't clutter the TUI log by\ndefault\n- DevAPI: When a device has more than 26 processors, represent them as aa-zz\n- bitforce: bitforce: Fix TUI display of slave processors on parallelized boards\n- bitforce: Only display temperature in TUI for the first chip on parallelized\nboards\n- Bugfix: bitforce: Set temperature for all processors on the board\n- Bugfix: bitforce_queue: Initialize proc->device_data to board data for\nparallelized chip processors\n- Bugfix: bitforce_queue: Defer nonce count check until after thiswork has been\nidentified (or handled as NULL)\n- avalon: avalon_clear_readbuf can simply wait for a single read timeout on\nWindows to avoid select\n- avalon: Simplify avalon_get_result by using avalon_gets\n- avalon: Go back to good old serial timeouts for gets, since select() is for\nsockets (only, on Windows)\n- Updated api.c to return the hashrate with 3 decimal places\n- Change hashrate display to never display 3 fractional digits, because it looks\na bit ugly\n- bitforce: Credit hashrate to the correct chip on parallelized devices\n- Re-set work thr_id on share submissions, to ensure the result gets credited to\nthe correct device in case of shared job queues (as in BitForce long boards)\n- bitforce: Turn parallelization into separate logical processors for more\ndetails on each, including working with XLink\n- bitforce_queue: Implement job sanity checks using new \"ZqX\" for devices using\nparallelization\n- bitforce_queue: Minimal support for parallelization\n- Add --device-protocol-dump option to debuglog low-level bitforce protocol\ndetails\n- When shutting down, set work restart flag (and trigger notifier) to help\nmining threads escape to their main minerloop (and check for shutdown)\n- Document and check for uthash version 1.9.2+\n- Bugfix: Don't report failure for graceful mining thread shutdown\n- Name devices in mining thread failures\n- Warn about killing mining threads\n- Bugfix: Wake up mining threads when asking them to shutdown\n- Disable pthread cancel within curses locking\n- Shorten the avalon statline to fit in the curses interface and show the lowest\nspeed fan cooling the asic devices.\n- Change switch_compact function name to switch_logsize to be used for other\nchanges.\n- Only adjust cursor positions with curses locked.\n- devs display - fix GPU duplicate bug\n- basic copyright statement in API.java\n- Change the --device parameter parsing and configuration to accept ranges and\ncomma separated values.\n- Modify scrypt kernel message.\n- Check for pool_disabled in wait_lp_current\n- Check for pool enabled in cnx_needed.\n- Add README.ASIC to debian packaging and make-release\n- Document avalon options in ASIC-README\n- Create README.ASIC with basic summary of supported ASIC devices.\n- Do avalon driver detection last as it will try to claim any similar device and\nthey are not reliably detected.\n- Set the fanspeed to the nominal chosen for GPUs.\n- Clamp initial GPU fanspeed to within user specified range.\n- Avalon fan factor is already multiplied into the info values.\n- Get rid of zeros which corrupt display.\n- Logic fail on minimum fanspeed reporting.\n- Provide a workaround for fan0 sensor not being used on avalon and pad fan RPM\nwith zeros.\n- Add ambient temp and lowest fan RPM information to avalon statline.\n- Display max temperature and fanspeed data for avalon.\n- Set devices to disabled after they exit the hashing loops to prevent the\nwatchdog thread from trying to act on them.\n- Scanhash functions perform driver shutdown so don't repeat it.\n- Change the opencl shutdown sequence.\n- Send the shutdown message to threads and do the thread shutdown functions\nbefore more forcefully sending pthread_cancel to threads.\n- Icarus report data direction with comms errors\n- Execute driver shutdown sequence during kill_work.\n- Provide an nusleep equivalent function to nmsleep.\n- Set avalon_info to device data void struct.\n- Make submit_nonce return a bool for whether it's a valid share or not.\n- Do a non-blocking read of anything in the avalon buffer after opening the\ndevice.\n- Assign the avalon info data to the device_data in cgpu_info.\n- Rename cgpu_data to use new device_data\n- miner.h remove unused device_file and add device_data\n- Must unlock curses as well in logwin_update.\n- icarus report usb write error information\n- Make mining threads report out during work submission.\n- submit_work_async is no longer used directly by driver code.\n- Create a logwin_update function which mandatorily updates the logwin and use\nit when input is expected to prevent display refresh delays.\n- All stratum calls to recv_line are serialised from the one place so there is\nno need to use locking around recv().\n- Only allow the mining thread to be cancelled when it is not within driver\ncode, making for cleaner shutdown and allowing us to pthread_join the miner\nthreads on kill_work().\n- Implement pthread_testcancel replacement for BIONIC\n- Attribute whatever stats we can get on untracked stratum shares based on\ncurrent pool diff.\n- Downgrade OpenCL headers to 1.0, which work fine for our purposes and are more\ncompatible\n- icarus: If work_division autodetect fails, just use the old default of 2\n- avalonhost-raminst script to help with installing to RAM on Avalon-host\nrouters\n- Attempt to probe /dev/cu.usb* for fallback \"-S all\"\n- openwrt: Download uthash dependency\n- Bugfix: openwrt: Always build with libsensors support disabled\n- configure: Check for uthash headers\n- Bugfix: ztex: Only destroy libztex device after the last handle to it has been\nreleased\n- ztex: Remove libztex slave device interface, simply passing fpgaNum to\nselectFpga\n- Bugfix: cpu: Fix yasm and sse2 detection\n- cpu: Check for SSE2 support independently from yasm\n- Bugfix: cpu: Make sure to link libsse2cpuminer.a before x86_32/libx8632.a\n- Bugfix: cpu: Only build libsse2cpuminer iff yasm is available and targetting\nx86_32\n- Bugfix: Free work only after deleting it from list\n- Remove embedded uthash.h and utlist.h from Makefile\n- windows-build.txt: Update for system uthash\n- Remove embedded uthash (and add dependency on system uthash)\n- Replace elist.h with utlist.h\n- Bugfix: Fix build with CPU mining and *without* yasm\n- cpu: Be explicit about size of sha256_init address\n- cpu: Add --algo fastauto (new default) to detect a usable algorithm without\ntaking over a minute\n- cpu: Default to --algo auto\n- cpu: Support all platform-applicable assembly algorithms, even if used CFLAGS\ndon't support them\n- Ubuntu: Updated changelog, added scrypt support.\n- cpu: Set fixed symbol names for stuff shared with assembly\n- cpu: Create Mach-O asm binaries on Darwin-based systems\n- Bugfix: cpu: Use COFF yasm binfmt on Cygwin\n- Bugfix: cpu: Get correct nonce from data, where the CPU sub-drivers leave it\n- Remove redundant \"Reject ratio\" in exit-time summary\n- Apply \"R+S(%)\" formatting to long-form statistics\n- Group stale shares in with rejects (but still distinctly counted) and make the\npercentage be (reject+stale)/total\n- Include rejected shares as a percentage\n- Move Utility and Best Share to status line\n- Remove LW from status line, since it is basically useless\n- ztex: Clean up a lot of ugly casting\n- Bugfix: Correctly avoid SIGPIPE on Mac\n- Make set_work_target a function to set a specified char as target for use\nelsewhere.\n- Minor typo.\n- Support more shares to be returned for scrypt mining.\n- Set all stratum sockets to nonblocking to avoid trying to use MSG_DONTWAIT on\nwindows.\n- Only use MSG_NOSIGNAL for !win32 since it doesn't exist on windows.\n- Use MSG_NOSIGNAL on stratum send()\n- Set TCP_NODELAY for !linux for raw sockets.\n- Use TCP_NODELAY with raw sockets if !opt_delaynet\n- Recheck select succeeds on EWOULDBLOCK for stratum.\n- Don't use TCP_NODELAY if opt_delaynet is enabled with stratum.\n- Fix warnings in avalon driver.\n- correct applog typing\n- Simplify the many lines passed as API data in the avalon driver now that the\nAPI does not need persistent storage for the name.\n- Duplicate the name string always in api_add_data_full to not need persistent\nstorage for names passed to it.\n- Add extra matching work count data in API for Avalon with 4 modules.\n- Clean up summary slightly better on exit.\n- opencl: Disable using binary kernels on Apple by default\n- Use sock_blocks in api.c\n- Fix build and distdir.\n- compile on win32\n- Update README.scrypt with improved hashrates for 7970.\n- Use copy_time helper throughout miner.c\n- Provide wrappers for commonly used timer routines with API stats.\n- Use flip32 function instead of open coding it in gen_stratum_work.\n- Move util.c exports to util.h\n- Replace gettimeofday usage with cgtime\n- Adopt gettimeofday wrapper from cgminer (cgtime) that is always called with tz\nset to NULL and increases the resolution on windows.\n- Add high resolution to nmsleep wrapper on windows.\n- Bugfix: Export stats_lock for deviceapi\n- Set default ocl work size for scrypt to 256.\n- fliter out the wrong result from adjust fan code\n- Set last device valid work on adding device.\n- Make scrypt submission use the submit_nonce code, with nonces matching\nendianness.\n- Increment hardware error count from the one site.\n- compile avalon driver on win32 and win64\n- build out of source dir\n- Rename scrypt regenhash function for consistency.\n- Add Mac FAQ.\n- Further driver FAQs.\n- Check for work restart after disable in the hash queued work loop since it may\nbe a long time before we re-enable a device.\n- Unconditionally test for many wrong results on avalon and reset to avoid\npassing a corrupt avalon result to temperature code.\n- Only reset an avalon device with no results when there are no results\nconsecutively.\n- More FAQs.\n- Avoid applog in recalloc_sock.\n- Avoid applog under cg_wlock.\n- Put spacing around locking code for clarity.\n- Avoid applog under pool_lock.\n- Avoid more recursive locks.\n- Avoid applog while ch_lock is held.\n- Avoid recursive locks in fill_queue.\n- Variable is already initialised in global scope.\n- More GPU FAQs.\n- More README faqs.\n- Yet more README faqs.\n- Add more FAQs to README.\n- Wrap result wrong tests in avalon scanhash in unlikely() and only consider a\nhash count of zero wrong if a restart wasn't issued.\n- avalon: if result_wrong >= get_work_count jump out the read loop\n- Fix warning on 32bit.\n- fix the fan control on max temp2/3\n- for some reason network down. one simple bfgminer command:   \"bfgminer -o\n127.0.0.1:8888 -O fa:ke --avalon-options 115200:32:10:50:256\" can idle the\navalon for safe power and protect chip\n- if hash_count == 0; reinit avalon, fix the 0MHS bug use the max value of temp1\nand temp2 for fan control\n- Reinstate the matching_work_count per subdevice on avalon based on the work\nsubid.\n- Rationalise and simplify the share diff and block solve detection to a common\nsite.\n- subid field for devices that do not yet support the distinct device/processor\ninterface\n- Make the avalon array size a macro.\n- Use replacement of work items in the avalon buffer as needed instead of\nflushing them.\n- Reinstate wrong work count to reset avalon regardless and display number of\nwrong results.\n- select() on serial usb in avalon does not work properly with zero timeout.\n- Use no timeout on further reads in avalon_gets\n- Do sequential reads in avalon_get_reset to cope with partial reads.\n- Show read discrepancy in avalon_get_reset.\n- Reuse avalon_get_work_count variable.\n- Check for AVA_GETS_RESTART when deciding if avalon has messed up.\n- Make the detection of all wrong results on avalon much more conservative to\navoid false positives on work restarts.\n- Show error codes on select and read fail in avalon.\n- If we get a restart message in avalon_gets still check if there's a receive\nmessage to parse first without a timeout before returning AVA_GETS_RESTART.\n- avalon_gets is always called from the one call site so inline it.\n- The read_count is unused by the avalon get result code and no longer required\nfor avalon reset so simplify code removing it.\n- Use a separate avalon_get_reset function for resetting avalon instead of using\navalon_get_result.\n- The current hash count returned by avalon scanhash is just an obfuscated\nutility counter so make it explicit.\n- Check for a restart before a timeout in message parsing code in avalon.\n- We should check for a restart message before checking for a timeout in avalon\nscanhash.\n- Store the subid for the work item in avalon.\n- Fix record_temp_fan function in avalon driver.\n- Remove inappropriate memset of struct avalon result which was corrupting fan\nvalues.\n- Only do_avalon_close once on multiple errors.\n- Reset the result_wrong count on block change in avalon scanhash to prevent\nfalse positives for all nonces failed.\n- Small timeouts on select() instead of instant timeout increase reliability of\nsocket reads and writes.\n- Rotate the avalon work array and free work on AVA_SEND_BUFFER_EMPTY as well.\n- Only get extra work in fill_queue if we don't have any unqueued work in the\nlist.\n- Don't get any work if our queue is already full in avalon_fill.\n- Free avalon->works in the event we call avalon_prepare on failure to\ninitialise.\n- Fix warnings.\n- Create an array of 4 lots of work for avalon and cycle through them.\n- Remove unused per unit matching work count for avalon.\n- Rename the confusing avalon_info pointer.\n- Simplify avalon scanhash code using the new find_queued_work_bymidstate\nfunction.\n- Members of cgpu_info for avalon are not meant to be in the union.\n- Use correct struct device_drv for avalon_drv.\n- Check enough work is queued before queueing more in avalon_fill.\n- Actually put the work in the avalon queue.\n- Rename avalon_api to avalon_drv.\n- First draft of port of avalon driver to new cgminer queued infrastructure.\n- Minor README updates.\n- README.GPU: Properly warn about overclocking damage\n- Add example 7970 tuning for scrypt in readme.\n- Update driver recommendations.\n- Add extensive GPU FAQs for the flood of new Scrypt miners.\n- Bugfix: Expect bitstreams and kernels to be in the srcdir, not build dir\n- cpu: Prefer sse4_64 algorithm if supported\n- cpu: sse2_32: Force bare symbols for cross-asm/C symbols\n- Compile CPU mining for win32 and win64\n- configure: Check for pthread in -lwinpthread\n- Use has_pth flag instead of trying to mess with pthread internals\n- configure: Explicitly check for nanosleep\n- configure: Include \"no\" response in BFG_PTHREAD_FLAG_CHECK\n- miner.h missing extern\n- Update links and recommended SDKs.\n- Bugfix: README.GPU: Fix some typos\n- Update README to match changes to display.\n- Remove increasingly irrelevant discarded work from status lines.\n- Remove increasingly irrelevant GW value from status.\n- README.GPU: Correct terminology\n- Update README about intensity.\n- Bugfix: Restore always autodetecting stratum as non-scrypt\n- icarus: Replace default of 2 work_division/fpga_count with autodetection of 1,\n2, or 4\n- Update scrypt readme with newer information and to match changes in code.\n- Set default GPU threads to 1 for scrypt.\n- Connect backup stratum pools if the primary pool cannot deliver work.\n- Use a new algorithm for choosing a thread concurrency when none or no shader\nvalue is specified for scrypt.\n- Do not round up the bufsize to the maximum allocable with scrypt.\n- Remove the rounding-up of the scrypt padbuffer which was not effectual and\ncounter-productive on devices with lots of ram, limiting thread concurrencies\nand intensities.\n- Make pool adding while running asynchronous, using the pool test thread\nfunctionality.\n- Only curl easy cleanup a stratum curl if it exists.\n- Add intermediate variants of cglocks that can be up or downgraded to read or\nwrite locks and use them for stratum work generation.\n- Move the stratum data to be protected under a new cg_lock data_lock.\n- Convert the ch_lock to cg_lock.\n- Convert the control_lock to a cg_lock.\n- Remove unused qd_lock.\n- Implement cg_lock write biased rwlocks.\n- Don't start testing any pools with the watchpool thread if any of the test\nthreads are still active.\n- Set sockd to false should curl setup fail on stratum.\n- Reopen the socket whenever we're retrying stratum.\n- Set pool died on failed testing to allow idle flag and time to be set.\n- Remove unused pthread_t typedefs from struct pool.\n- Perform pool_resus on all pools that are found alive with the test pool\nthreads.\n- Use pool_unworkable in select_balanced as well.\n- Differentiate pool_unusable from pool_unworkable.\n- Keep a connection open on higher priority stratum pools to fail back to them.\n- Set the wrong bool in pool_active\n- Only bypass unusable pools if they're not the selected ones.\n- Find the first usable pool in preference to the current pool in select_pool\nfor work.\n- Add a pool_unusable function which checks if a pool is stratum but not active\nto use within switch_pools.\n- API no longer ignore send() status\n- API make the main socket non-static\n- Start the stratum thread only if we successfully init and authorise it,\notherwise unset the init flag.\n- Make the initialisation of the stratum thread more robust allowing the\nwatchpool thread safe access to it after the stratum thread is started.\n- Shorten the time before keepalive probes are sent out and how frequently\nthey're sent with stratum curls.\n- Display select return value on select fail in stratum thread.\n- Clear the socket of anything in the receive buffer if we're going to retry\nconnecting.\n- Perform pool resus on pools that were not set as the initial pool at startup.\n- Allow pools to be resuscitated on first startup by the watchpool thread.\n- Check all pools simultaneously at startup switching to the first alive one to\nspeed up startup.\n- Close any sockets opened if we fail to initiate stratum but have opened the\nsocket.\n- API use control_lock when switching pools\n- Clear last pool work on switching pools if the current pool supports local\nwork generation or we are in failover only mode.\n- make rw locks: mining_thr_lock and devices_lock\n- work queues - remove new but unnecessary functions\n- functions for handling work queues\n- find_work() to find work in devices work queue\n- Add a get_queued function for devices to use to retrieve work items from the\nqueued hashtable.\n- Add the choice of hash loop to the device driver, defaulting to hash_sole_work\nif none is specified.\n- Add a driver specific flush_work for queued devices that may have work items\nalready queued to abort working on them on the device and discard them.\n- Flush queued work on a restart from the hash database and discard the work\nstructs.\n- Create a central point for removal of work items completed by queued device\ndrivers.\n- Create a fill_queue function that creates hashtables of as many work items as\nis required by the device driver till it flags the queue full.\n- Create the hash queued work variant for use with devices that are fast enough\nto require a queue.\n- Make sure to do full avalon_init if the device_fd is invalid.\n- Document extra zero byte in avalon_reset.\n- Microoptimise likely paths in avalon_gets.\n- Make sure to set timeout to 100ms instead of 1ms in avalon read loop for\nselect.\n- Make sure to get time of first response in avalon read loop.\n- Use select for a reliable timeout in avalon read and don't read 1 byte at a\ntime, optimising read loop.\n- We should break on the loop on a work restart in avalon, and only consider all\nerrors if we actually have gotten some results.\n- Avalon init on comms error as well.\n- Reinit avalon device in case of FPGA controller mess up.\n- Increase reliability of avalon startup by only opening and resetting the\ndevice once, looking for the id sequence offset by one byte as well, and still\nignoring if it's wrong, assuming it is an avalon.\n- Nest avalon_decode functions to avoid doing unnecessary lookups once we have\nfound the nonce.\n- Use htole32 wrapper for nonce encoding in avalon.\n- Remove unused rev8 function from avalon driver.\n- Remove const qualifier from driver structs\n- rename device_api -> device_drv and all related api -> drv\n- rename get_proc_by_id() to get_devices()\n- Wrap access to devices array under a mutex\n- Provide wrappers for grabbing of thr value under the mining_thr_lock.\n- mutex all access to mining_thr\n- Split thr_info array into control_thr and mining_thr pointers so more mining\nthreads can be added later\n- Update the hashmeter at most 5 times per second.\n- Speed up watchdog interval and therefore display updates to 2 seconds.\n- Add README.GPU to EXTRA_DIST.\n- Split out the GPU specific information from the README into a README.GPU file.\n- Update docs and reorder README to show executive summary near top.\n- Add more FAQs about crossfire.\n- Convert error getting device IDs in ocl code to info log level only since\nmultiple platforms may be installed and the error is harmless there.\n- Unnecessary extra array in ocl code.\n- Cope with the highest opencl platform not having usable devices.\n- Update kernel file names signifying changes.\n- Use constants from the array of __constants throughout the diablo kernel.\n- Create a __constant array for use within diablo kernel.\n- Use global constant arrays for all other constants used in scrypt kernel.\n- Use global __constants for sha functions in scrypt kernel.\n- Use constants for endian swap macros.\n- Revise scrypt kernel copyright notice.\n- Separate out additions in scrypt kernel.\n- Reuse some Vals[] variables that can be assigned to constants earlier in the\npoclbm kernel, making for fewer ops.\n- Put all constants used in poclbm kernel into __const memory array to speed up\nconcurrent reads on the wavefront.\n- opencl: Support for reading temperature from free software radeon drivers via\nlibsensors\n\n\nBFGMiner Version 3.0.3 - June 13, 2013\n\n- make-release: Include all submodules, recursively\n- Remove API.java example (no copyright license)\n- Minimally fix \"make install\" to ignore bitstream sources\n- Add submodule for ZtexBTCMiner (aka ztex_ufm1_*)\n- Add submodule for X6000_ztex_comm4 (aka x6500-overclocker-0402)\n- ztex: Use standard file header/comment formatting, and update license to GPLv3\n- bitforce: Allow a longer timeout (1250ms) for ZCX (Device Information)\ncommands\n- Bugfix: pdcurses doesn't like changing logwin size without clearing it also,\nso do that in display options\n- -S all: Start QueryDosDevices probe with 256-byte buffer\n- Use common code to ensure the prefix of -S *:all remains in all\nimplementations of it (/dev glob was removing prefixes)\n- bitforce_queue: Ensure comma following nonce count is there, to error cleanly\n- bitforce: Report queue send failures, and count as hw errors\n- Bugfix: bitforce_queue: Don't try to send ready-to-queue work to device, when\nthere is no ready-to-queue work\n- Bugfix: bitforce: Clear want_to_send_queue flag when flushing queue, since we\ncan't send an empty queue\n- bitforce: Include new total queued count in flush debugging\n- Bugfix: bitforce_queue: Implement a minimum wait time of 10ms\n- README: Document serial device format for Mac OS X\n- Bugfix: cairnsmore1: Enable building with libudev autodetection even if only\nicarus drivers are enabled\n- Bugfix: sysfs autodetect: Continue searching even after finding one tty (fixes\nmultiple ttys per device, such as some Cairnsmore1s)\n- Bugfix: ztex: Avoid destroying libztex device in case other processors are\nstill in use (fixes crash when 1.15y becomes unavailable)\n- Update windows-build.txt\n- ccan: Add missing copyright comment headers\n- Remove obsolete mknsis.sh\n- Add missing copyright sections to files that may need them\n- Standard copyright format (including year) for adl_functions.h\n- Bugfix: When disabling device, ensure its prev_work (if any) gets freed\nproperly\n- Check stratum socket exists and is writable before even considering whether\nthe sessionid is the same or not\n- Bugfix: Check that the stratum_share struct for a failed submission is still\nin the submission hashtable before trying to delete it\n- README: Add missing documentation for CPU algorithms cryptopp_asm32, sse2_32,\nand altivec_4way\n- Bugfix: icarus: Check work restart before timeout\n- Bugfix: icarus: Debuglog the correct read timeout (and omit from work restart\nsince there's no trivial way to get it)\n- README: Update links\n- Bugfix: cpu: Fix warning on Win64\n- Bugfix: avalon: Strict formatting\n- Bugfix: Cleanup trivial warnings\n- Bugfix: bitforce: Seek to end of nonce counter to find nonces, in case there\nare more than 9\n- Bugfix: Build hexdump.c into the project normally like everything else\n- Bugfix: Really fix device entries in saved config file\n- Update the write config to properly record device entries and remove disabled\noption.\n- avalon: Really fix applog formatting\n- va_copy is meant to be matched by a va_end in log_generic.\n- Further fix distdir for hexdump.c\n- Fulltest is true if value is <= target.\n- Fix warning with no curses built in.\n- Bugfix: configure: Check NEED_FPGAUTILS correctly\n- configure: Better grammar for --enable-cpumining help\n- Bugfix: Check for SSE 4.1 support before building sse4_64 asm CPU miner (uses\nMOVNTDQA instruction)\n- Bugfix: elist: Use uintptr_t for member offset\n- Bugfix: opencl/adl: Fix format string\n- Bugfix: opencl: Correct usage of formatted prints\n- Increase fd limits as much as possible at startup\n- Bugfix: bitforce: bulk queue: Cleanly retry for high temperature recovery\n- Fixed deps for raring, which has newer libudev1.\n- bitforce: debuglog actual result data\n- Bugfix: Missing 'else' can result in null pointer dereference in race\n- Minor grammo in avalon driver.\n- Make avalon temperature reading LOG_INFO level.\n- Fix the problem of seting up termio of ttyUSB0 for icarus. the CSIZE is the\nmask of CS2/4/8\n- bufsize is an unsigned integer, make it so for debug.\n- Bugfix: bitforce: Include get_api_stats in BQUEUE mode\n- Bugfix: Always compile support for commandline --temp-target and\n--temp-cutoff, and write them in the config for all devices\n- Bugfix: Ensure cURL timers get set correctly in submission thread\n- Bugfix: modminer: Remove unused parameter to sprintf\n- Bugfix: modminer: Use correct format for bytes left in bitstream upload\nmessage\n- Bugfix: Access strategy name string directly instead of accidentally\n- Add printf-format syntax checks to more functions that should use it\n- AUTHORS: Add more contributors\n- Support configure flag --with-system-libblkmaker to allow building without the\nbundled copy\n- Bugfix: Use HTTP/1.1 compatible product token for User-Agent header\n\n\nBFGMiner Version 3.0.2 - April 28, 2013\n\n- Receive failures in recv_line should unconditionally fail.\n- Use sock_blocks function for stratum send and receive.\n- Avoid applog under stratum_lock in __stratum_send.\n- Create an OS specific sock_blocks function.\n- There should be no error response code with return value 0 in recv_line.\n- Check for errors on stratum recv for any recv return value less than 1 and\nonly parse the response if it's positive.\n- Avoid applog under stratum_lock in recv_line.\n\n\nBFGMiner Version 3.0.1 - April 24, 2013\n\n- Bugfix: configure: Move actual roundl macro back to miner.h after math.h\nshould be included\n- Bugfix: configure: Use dummy pointer to correctly detect roundl when conftest\nmain is missing argc parameter\n- Bugfix: configure: Use variable argument to roundl to prevent compilers from\noptimizing it out entirely\n- Remove bitstreams from Windows binary distributions (README directs users to\ndownload source and copy them)\n- make-release: Remove autom4te.cache from distributed source\n- Bugfix: Omit --no-opencl-binaries option from build if OpenCL is not being\ncompiled\n- Bugfix: Check that all pools have URIs set before starting\n- Bugfix: bitforce: Make noncebuf large enough for max qresults +1 (for OK line)\n- opencl: Ability to avoid using binary kernels with new --no-opencl-binaries\noption\n- README: Include jansson PKG_CONFIG_PATH in example for Mac\n- Include trailing \\0 with coinbase sigs if there's room\n- Differentiate socket closed from socket error in recv_line.\n- Add new best share info to verbose logging.\n- Add notice for when network diff is changed.\n- convert sleep(const) to nmsleep()\n- Rename longpoll threads according to what pool they're associated with\n- miner.php report 'Last Valid Work' as time before request\n- API V1.25 - add 'Last Valid Work' time for each device\n- add 'count' to customsummarypage 'calc'\n- Bugfix: ztex: Initialize fw_buf pointer to NULL so a free before allocation is\nsafe\n- Cleanup when stratum curl fails to initialise.\n- LTC text typo\n- Recreate cURL for new stratum connections, and clear stratum_notify on\nsuspending them\n- clear_stratum_shares: Rename diff_stale variable to diff_cleared\n- MMQ it's a bitstream\n- Update a pool's last work time when the work is popped as well as staged.\n- Extend stratum connections another minute (total 2 minutes) after the last\nwork item was staged, and maintain last_work_time for non-stratum pools.\n- Fix --benchmark generating valid work for cgminer.\n- Bugfix: Correct pdbuilder result directory\n- Omit add_serial_all code when serial support is not wanted\n- Use configure to detect presence of roundl to avoid redefining an actual\nfunction (possibly inline)\n- Bugfix: roundl: Add needed parenthesis to perform ?: before +\n- Bugfix: ft232r: Defer allocating structure until after USB endpoint is\nsuccessfully opened, so it won't leak in case of failure\n- Bugfix: ztex: Free bitstream in memory when done with it\n- Bugfix: Safely handle all-space cURL debug messages, should they ever happen\n- Silence warnings about poor format usage for quit()\n- Apply noreturn and printf-format attributes to quit() function definition\n- Bugfix: set_serial_rts get flags to manipulate them correctly\n- Bugfix: Missing return for /dev globbing\n- Bugfix: Free unused work when retrying failed lp request\n- Display processor name with thread disabled/re-enabled messages\n- Move best share to top summary line, and add network difficulty to block line\n- opencl: Default to phatk kernel for Mesa platform\n- opencl: Default to single thread with Mesa OpenCL\n- opencl: Check for Mesa OpenCL and avoid using binary kernels with it\n- bitforce: Never increase bulkqueue poll wait time during queue underruns\n- bitforce: Start off polling bulk queue every 100ms\n- bitforce: Log device queue size after getting bulk results\n- bitforce: Ensure bulkqueue polling occurs at least once a second\n- opencl: Include OpenCL platform in kernel binary filenames\n- bitforce: Use bulk queue mode for all SC devices\n- Bugfix: bitforce: When reinitializing, free all known works to avoid\ndecrementing reset queued counter\n- bitforce: Handle timeout during ZOX as cleanly as possible\n- Bugfix: bitforce: Make reinitialization more complete and safe\n- Bugfix: bitforce: Close opened fd if reinit fails\n- Bugfix: bitforce: Retry ZGX until device is NOT busy\n- bitforce: Log when zero queued results are received\n\n\nBFGMiner Version 3.0.0 - April 5, 2013\n\n- Update libblkmaker to 0.3.0\n- debian: Include new api-example.py in docs\n- added example for Python using the RPC API\n- added SPEC file for SUSE distributions\n- Bugfix: bitforce: Free initialization data to avoid trivial one-time memory\nleak\n- Support for local submission of found blocks (GBT only)\n- bitforce: RPC pgaset fanmode 0-5 for manual fan control\n- bitforce: More debugging information\n- Bugfix: modminer: Since RPC always includes the temperature, we don't need to\nadd it specially\n- bitforce: Expose dual temperature sensors to RPC\n- bitforce: Support for up to 2 temperature sensors per processor\n- Bugfix: bitforce: BFP_QUEUE: Attempt to recover from extra queue results, or\nthe next job finishing early\n- bitforce: Always send a new job ASAP after flushing the queue\n- bitforce: Implement \"Queue Job Pack\" (ZWX) and use it for XLINK devices to\navoid USB latency issues\n- bitforce: Ignore INPROCESS added to ZOX response\n- Implement minerloop_queue for devices that process work items too fast to keep\ntrack of which one they're currently working on\n- bitforce: Split ZOX command into its own function\n- Bugfix: DevAPI: Free work when preparing it fails\n- DevAPI: Abstract get_and_prepare_work for minerloops\n- DevAPI: Move select() logic from minerloop_async to do_notifier_select\n- Clarify stratum mining.set_difficulty debug log message\n- No longer call configure from autogen.sh\n- Bugfix: bitforce: Ensure result_busy_polled gets set for queue mode to avoid\nunnecessary 10ms wait times\n- Bugfix: bitforce: Use common code for end of job_get_results, so queue results\ndon't short-circuit timing code\n- Bugfix: bitforce: Ensure \"OK\" doesn't remain in queued results buffer\n- Bugfix: bitforce: next_line needs to increment beyond the newline character\n- Update README for x970 memdiff values.\n- Do not scan other gpu platforms if one is specified.\n- Update README for sync objects on windows.\n- Add information for setting gpu max alloc and sync parameters for windows with\nscrypt.\n- Whitelist AMD APP SDK 2.8 for diablo kernel.\n- Show pool number in switch message\n- Clear just the socket buffer when we don't care what is left in a stratum\nsocket.\n- Clear the stratum socket whenever we are closing it since the buffer is going\nto be reused.\n- Do not continue work from a stratum pool where the connection has been\ninterrupted.\n- Close any existing stratum socket if we are attempting to restart stratum so\nthe pool knows the connection has gone.\n- Show mechanism of stratum interruption if select times out.\n- Make stratum connection interrupted message higher priority to be visible at\nnormal logging levels.\n- API add 'Network Difficulty' to 'coin'\n- avalon: if all result are wrong in one batch read. reinit the avalon\n- avalon: record the last result temperature info\n- delay when close avalon; only record matched result\n- avalon: fix no_matching_work only count when debug\n- avalon: minor change\n- avalon: add idle code\n- avalon: fliter the temp_max >= 100, print the result for debug.\n- avalon: export more data to API stats\n- avalon: add default chip frequency\n- avalon: fix the work_i3 init\n- avalon: add reinit_device\n- avalon: the temp_history_count base on timeout\n- avalon: fix mistake on adjest_fan\n- avalon.c: fix the copyright\n- bfgminer-rpc: add -o option: no format, only the result\n- avalon: update fan pwm\n- avalon: update the FAN_PWM MAX/MIN\n- avalon: minor change\n- avalon: overclock code\n- avalon: fix the display\n- avalon: minor change\n- avalon: fix the fan/temp control\n- avalon: fix the temp_avg\n- avalon: fix temp\n- avalon: add fan/temp control\n- avalon: add FAN speed factor\n- avalon: add TODO on fan/temp control. cleanup detect\n- avalon: add the gate_miner bits\n- avalon: only send one byte on reset\n- avalon: add support on send 2 bulk taskes at begin\n- avalon: fix the hash_count return\n- avalon: fix the LOG_WARNING\n- avalon: add comment on hash_count\n- avalon: WORKAROUND on hashrate\n- avalon: update max miner_num\n- avalon: add more info on api\n- avalon: add nonce_elf and more info on match miner_num\n- avalon: change reset to 300ms\n- avalon: move bulk buffer to it's info structrue\n- avalon: more work on hashrate and read_count\n- avalon: add baud 38400 support\n- avalon: fix nonce_range EB\n- avalon: fix the hashrate wrong\n- more info on avalon API\n- avalon: fix the nonce_range EL\n- avalon: fix the read count\n- avalon: more work on nonce_range\n- avalon: read() times and send delay fixed\n- avalon: add the send delay option\n- avalon: print out fan/temp info\n- avalon: add the result info (fan/temp etc)\n- avalon: more check on hardware error\n- avalon: more work on get_work_count\n- avalon: now we have dynamic get_work_count\n- avalon: more work on parameters\n- avalon: add timeout parameter\n- avalon: baud as parameter now\n- avalon: send work pitch should be : (15*(8+2)*4/19200)s\n- avalon: more work on match work\n- avalon: fix free_work\n- avalon: continue on reset work. wait for buffer empty\n- avalon: add options, if write() error. sleep(1) before reset()\n- avalon: more cleanup\n- avalon: finish read when Buffer empty\n- avalon: fix the nonce EB issue\n- avalon: MORE work\n- avalon: fix the EB/LB issue\n- avalon: some cleanup\n- avalon: fix the first configure task\n- more work on the avalon buffer\n- avalon: fix the BIG_ENDIAN issue\n- avalon: Fix the buffer statu\n- change defines to avalon parameters\n- fix the cts return\n- avalon: change the data to uint8_t, add some test temp code\n- avalon: fix task init\n- avalon: more data format work\n- change to avalon data format\n- debug: add a debug hexdump.c\n- avalon: add some code on match work\n- avalon: try to correct the pool_status and dev_status\n- avalon: more work on multi-works\n- avalon: more work on read\n- avalon: more work on get results\n- more RTS code on avalon.c/h\n- more RTS code\n- avalon: some cleanup\n- avalon: more work on new work queue structrue\n- fpgautils.c: use lancelot as target\n- avalon: since we submit task as bulk data. modify again\n- add scanhash_queue\n- renmae avalon.h to driver-avalon.h\n- fpgautils.c: add get_serial_cts\n- understand the avalon protocol more\n- avalon: new software structrue but target as lancelot\n- add avalon.h\n- avalon: fix warning\n- avalon: add TODO comments\n- more AVALON defines\n- avalon: more work\n- add driver-avalon.c\n- add avalon support to automake\n- Default to work queue mode on BitForce SC devices\n- bitforce: Implement support for non-contiguous XLINK slave addressing\n- gnulib: stdint: fix build with Android's Bionic fox x86\n- gnulib: stdint: Improve support for Android.\n- gnulib: stdint: Add support for Android.\n- Check for ?e##toh macros independently from hto?e##\n- If pthread_cancel is missing/emulated, set asynchronous thread cancel type on\nstage, watchdog, watchpool, and longpoll threads since the emulation cannot\nsupport deferred cancellation\n- If pthread_cancel is missing (Bionic/Android), emulate it using pthread_kill\nand pthread_exit\n- configure: Intelligently detect what flags/libs get us working pthread, and\ndefine HAVE_PTHREAD_CANCEL if pthread_cancel is available\n- Bugfix: Initialize mutex_request to invalid so devices that don't use it\n(bitforce) don't try to\n- RPC: pools: Add \"Message\" to show last client.show_message received over\nstratum\n- Stratum: Support client.show_message method\n- Don't retry without resume support, if the first attempt just timed out\n- Bugfix: minerloop_async: Intelligently handle work updates and device disables\nduring transitions\n- Bugfix: minerloop_async: Free old (unused) prepared work when replacing it\nwith an upgraded one\n- Bugfix: Free pool sessionid before replacing it\n- Bugfix: Stratum: Address dereference-after-free and memory leak introduced in\nresume support\n- Stratum: If old protocol fails as well, try to resume again next time around\n- Bugfix: Stratum: Only failover to old mining.subscribe protocol if the\nprevious attempt was the new one (fixes a flood of retries)\n- Try to extract the sessionid associated with mining.notify on 3rd level array\nand submit it along with the userid to support mining resume, failing gracefully\nand restarting if the pool rejects it.\n- Cope with misread sessionid on stratum for now.\n- Use the sessionid as passed on stratum connect to attempt to resume a\nconnection once and then clear it if it fails, to use a new connection.\n- Move to storing the nonce1 in the work struct instead of the sessionid for the\nnow defunct first draft mining.resume protocol.\n- Only continue submitting shares with mining.resume support on stratum when the\nsession id matches.\n- Provide support for mining.resume with stratum, currently re-authorising after\nsuccessful resumption pending finalising of the protocol process.\n- Provide basic framework for restarting stratum depending on whether resume\nsupport exists or not.\n- Abstract out the setting up of the stratum curl socket.\n- Remove redundant setting of strings to NULL since the whole work struct is\nzeroed.\n- Only clear stratum shares mandatorily on stratum dropouts when the pool does\nnot support resume.\n- Stratum: Keep trying to submit shares, even across reconnects\n- Use new select loop primitives in submission thread\n- Bugfix: Missing pool_no parameter to applog for no-stratum-sessionid debug\nmessage\n- Do as much outside of mutex locking of sshare_lock as possible.\n- Remove last reference to struct work used outside the sshare_lock in\nsubmit_work_thread\n- Unlock the sshare_lock in submit_work_thread when all references to work and\nsshare are complete.\n- Bugfix: Copy and free sessionid on work objects\n- Add timestamps to stratum_share structs as they're generated and copy the\nstratum sessionid if it exists to stratum work generated.\n- Store session id for stratum if the pool supports it for future mining.resume\nsupport.\n- Keep the unique id of each work item across copy_work to prevent multiple work\nitems having the same id.\n- x6500: Never consider processors idle if they're enabled\n- x6500: Make mutex management cleaner by blocking device select loop during\nidle get_stats\n- Bugfix: minerloop_async: Always refer to real thread for select loop\n- Bugfix: Initialize work_restart_notifier[1] to INVSOCK instead of -1 to be\nportable\n- ztex: Use restart_wait to react quicker to work updates\n- Handy TIMEVAL_USECS macro\n- Restore blocking restart_wait function with nearly identical semantics as old\none\n- Bugfix: bitforce: Rework sleep delay adjustment logic to properly deal with\nmore accurate timing readings (added in device API update)\n- Hidden --force-rollntime option for getwork pools (use like --pool-priority,\nafter each pool definition)\n- Include processor id in get_work logging\n- Support for BIP23 BPE request target extension via new --request-diff option\n- Hidden option to reduce \"work update\" messages to debug level:\n--quiet-work-updates\n- Change \"work restart\" to \"work update\" in messages to reflect reality more\naccurately (no work is lost), and normalize case of \"longpoll\"\n- HACK: Since get_work still blocks, reportin all processors dependent on this\nthread\n- Move FD_SETSIZE definition to configure so it affects everywhere it needs to\n- Move absolute_uri function to util.c\n- Remove now-unused blocking-wait code (restart_cond, restart_wait, and\nstale_wait)\n- Bugfix: bitforce: Zero hashes complete if we get an invalid response\n- HACK: Since get_work still blocks, reportout all processors dependent on this\nthread\n- bitforce: Support for work queue protocol on BitForce SC devices\n- Use new double-stage format for SC devices\n- modminer+x6500: Expose frequencies to API in terms of MHz to be consistent\nwith ztex driver and cgminer\n- bitforce: Replace (bool)cgpu->nonce_range with (enum)bitforce_data->proto\n- bitforce: XLINK support for multiple processors\n- bitforce: Prepare log messages for XLINK by separating into proc and dev\nmessages\n- bitforce: Always use fd/mutex pointers on actual device, to prepare for XLINK\nsupport\n- bitforce: Get fd/mutex pointers only once per function\n- bitforce: Abstract commands to bitforce_cmd1 (single-stage) and bitforce_cmd2\n(double-stage) functions\n- bitforce: Debuglog device information during detection\n- Bugfix: Missing includes needed on Windows\n- Bugfix: Use waddstr instead of wprintw to display completed device summary\nline, so literal %s don't get interpreted as formatting options\n- Bugfix: bitforce: Avoid polling continuously between work restart and job\ncompletion\n- bitforce: Use poll device API when job_get_results needs to wait\n- bitforce: Use poll device API when job_start needs to wait\n- stale_work_future function to determine in advance if a work/share will be\nstale at some future time\n- bitforce: Minimally refactor to adapt to new minerloop_async\n- minerloop_async: Break out of select on work_restart_notifier\n- Replace UNIX-only work_restart_fd pipe with portable work_restart_notifier\n- Bugfix: Clean out unused variables from minerloop_async\n- Move new device API code to new deviceapi.c source file\n- Make minerloop_async more async, using some callbacks to handle event\ncompletions\n- Split part of minerloop_async into do_get_results, and a bit other\nreorganization\n- Abstract select_timeout function to convert a realtime timeval to a timeout\npointer for select()\n- Split part of minerloop_async into do_process_results, and don't allow\napi->job_get_results to return hashes\n- Split part of minerloop_async into do_job_prepare and do_job_start\n- Initialize thr->tv_poll to -1 (disabled)\n- Update the hashmeter one last time before disabling a device\n- minerloop_async: Break out of select for wakeup notifications\n- Replace mining thread queues (which were only used for wakeup pings) with\nnotifiers (which can be used with select and co)\n- Unify all mining thread wakeup to mt_enable (simplifying code)\n- Bugfix: get_statline: Correct device summary status, only showing DEAD or OFF\nif it affects all processors\n- Working processor disable/enable with new async minerloop (currently gets\nstuck if all processors disabled)\n- Bugfix: get_statline: Only care about the processor status if\n--show-processors is set\n- Bugfix: watchdog: Use processor thr_info even if it isn't a real thread\n- Only support thread-per-device or N-threads-per-processor; simplify\nwork_restart check\n- x6500: Remove mutex, since driver is single-threaded now\n- Bugfix: Update utility every get_statline call, and include every processor\ninvolved\n- HACKING: New text file to document the internal workings of (currently) the\ndevice API\n- Bugfix: mining_threads is now a total of thr_info objects, not necessarily\nactual running threads\n- x6500: Working (but incomplete) asynchronous/single-threaded driver\n- Incomplete (but workable) asynchronous minerloop\n- Core support for managing multiple processors from a single thread\n- Allow device drivers to implement their own minerloop\n- Move cgpu_info and thr_info initialization to main, and ensure all get\ninitialized before starting any threads\n- Refactor and simplify miner_thread (no major behavioural changes)\n- Move difficulties to end of share result message, so they can be made to line\nup nicely\n- Bugfix: Consolidate share result message code (including fixing displayed\nhash portion for stratum)\n- miner.php: Include ProcID in Device column as a letter\n- Show summaries per-device unless --show-processors is used (also available on\nDisplay TUI menu)\n- Order next_proc linked list in processor id order\n- Consolidate processor summary line generation for TUI and text-only modes\n- RPC: Update to include ProcID so multiprocessor devices can be understood\ncorrectly\n- RPC: Common function for adding device-identifying fields\n- modminer: Make single-processor statline look like other temperature-only\nstatlines\n- modminer: Split each FPGA into its own logical processor (in the same device\nstill)\n- modminer: Get mutex pointer only once per function\n- ztex: Combine master+slave devices into a single multiprocessor device\n- Preformat dev_repr (device representation) and proc_repr (processor\nrepresentation) once for use everywhere\n- x6500: Split each FPGA into its own logical processor (in the same device\nstill)\n- x6500: Get mutex pointer only once per function\n- Minimal support for defining devices with multiple logical processors\n- Rename all README files to standard README.* style\n\n\nBFGMiner Version 2.10.6 - April 5, 2013\n\n- Bugfix: Restore missing variable\n- Bugfix: openwrt: Never include _ in platform name\n- Bugfix: Fixed typo in bfgminer-rpc usage\n- pool_active: Ensure temporary curl is always cleaned up\n- Try to find jansson via pkg-config first, and fall back to checking system\ndefaults if that fails\n- Attempt to find libjansson via pkg-config if AC_CHECK_LIB fails\n- Update scrypt readme re drivers and sdk.\n- Bugfix: README: Move --device out of GPU only options\n- Update .gitignore\n- Added bfgminer-rpc binary to .gitignore\n- Bugfix: Actually change to the newly selected pool when statum is inactive and\nit decides to change\n- Bugfix: modminer: Properly fail on dynclock error\n- Bugfix: opencl: Clean pc_data->work before freeing pc_data\n- Bugfix: Correct order of libblkmaker libraries so static builds work\n- Bugfix: Need to ensure __BIG_ENDIAN__ is defined before including uthash.h\n- Bugfix: Stratum: When destroying cURL easy handle, be sure to clear pool\nstratum_curl pointer\n- Bugfix: bitforce: Fix warning\n- Bugfix: Stratum: Properly handle non-integer \"id\" for client.get_version\nrequests\n- json_dumps_ANY utility function to portably implement json_dumps(..., ... |\nJSON_ENCODE_ANY)\n- Bugfix: bitforce: Free old name when updating it on reinitialization\n- Stratum: Include pool number in send/recv protocol logging\n- Include pool number in stratum thread name\n- API always report failed send() replies\n- API.java allow partial reads\n- Bugfix: Stratum: Use curl_easy_cleanup to close connection, so cURL\nunderstands what is going on\n- Bugfix: hash_pop: If a work should be rolled, use a clone of it rather than\nconsume a rollable work\n- openwrt: Move Makefile into a bfgminer subdirectory to avoid symlinking issues\n- openwrt: Use --with-curses=ncurses to avoid ncursesw dependency\n- configure: Support --with-curses=FOO to look for curses implementation in\nlibFOO\n- Set pool socket to INVSOCK after closing connection, just in case\n- Clean up compiler warnings\n- Bugfix: Check that pool is active one last time before selecting it\n- Bugfix: Trim whitespace (like newlines) off the end of debug info from\nlibcurl\n- Bugfix: submit_nonce: Backup the original work->blk.nonce since the miner\ncode uses it to track work consumption\n- Bugfix: Scheduler needs to unpause disabled devices, even if it isn't waking\nthem up\n- Bugfix: Use SOCKETTYPE for notifiers, to avoid potential overflow on Win64\n- Bugfix: Some versions of MingW define localtime_r, but don't handle the\ntimeval.tv_sec case that we use; so undef any preexisting one and use our own\n- Bugfix: reinit_gpu: Remember the selected device to correctly change\nproperties of\n- Bugfix: cpu: reinit_device hasn't worked since 93b284d, so just remove it\nentirely instead of letting it screw with thread 0\n- Document necessity to run ldconfig and possibly configure ld.so\n- Bugfix: Complete startup after just one pool is found active, no need to wait\nfor the rest\n- Bugfix: Update links\n- miner.php: Replace PGA dev number with concatenated device ID\n- Bugfix: miner.php: Display devices with aligned columns instead of assuming\nthey come out of the RPC aligned\n- Bugfix: miner.php: Silence PHP \"local timezone\" warning\n- Bugfix: api-example: Try to use BSD sockets on any non-Windows platform\n- Bugfix: stratum: Delay mining.get_transactions request until after auth has\nsucceeded, so its failure doesn't abort the connection (also avoids any delay\nfrom a large result)\n- --no-getwork option to disable getwork protocol support\n- Clarify dependencies with Debian/Ubuntu package names\n\n\nBFGMiner Version 2.10.5 - February 8, 2013\n\n- Bugfix: Actually increment template_nonce when we use it\n- Change file modes.\n- Fix logic fail on partial writes with stratum send that was leading to corrupt\nmessage submissions.\n\n\nBFGMiner Version 2.10.4 - February 7, 2013\n\n- New platform ports: OpenWrt and Win64\n- Update official Windows build compiler and libraries:\n- - Upgrade GCC from 4.6.3 to 4.7.2\n- - Upgrade libusbx from 1.0.10 to 1.0.14\n- - Upgrade jansson from 2.3.1 to 2.4\n- - Upgrade libcurl from 7.26.0 to 7.28.1\n- - Upgrade pthreads-win32 from 2.8.0 to 2.9.1\n- Bugfix: Release libudev handle when ID_MODEL doesn't match what we're looking\nfor\n- openwrt: Script to build for multiple platforms easily\n- openwrt: Bitstreams should be \"all\" arch\n- Working OpenWrt Buildroot Makefile\n- Do not enable the pool disable on reject feature unless explicitly enabled\nwith --disable-rejecting.\n- Check for calloc failure for completeness in gen_stratum_work.\n- Cache the coinbase length to speed up stratum work generation.\n- Cache the header length when generating stratum work to avoid calculating it\non every work generation, and to only need one alloc+sprintf, speeding up work\ngeneration.\n- Use heap ram for coinbase in gen_stratum_work, zeroing it before use.\n- Provide a wrapper for aligning lengths of size_t to 4 byte boundaries.\n- Bugfix: ztex: While 1.15y can finish highspeed FPGA config immediately, at\nleast 1.15x needs some delay\n- Use CURLOPT_OPENSOCKETFUNCTION to intercept the socket being created for\nstratum, in order to workaround CURLINFO_LASTSOCKET breakage on Win64\n- make-release: Update for Win64 and bfgminer-rpc.exe\n- Use localtime_r instead of localtime, including a Windows implementation that\nhandles Win64's broken struct timeval.tv_sec\n- Use standard execv arg type on Win64\n- Bugfix: Correct various size mismatches\n- Ensure winsock2.h is always included before windows.h\n- Bugfix: Add necessary Winsock library to bfgminer-rpc linking\n- Bugfix: Remove dependencies of compat.h on miner.h for Windows (moves\ntimersub/timeradd to compat.h where it belongs)\n- modminer: Raise default/maximum clocks to 210 and 250 respectively\n- modminer: Use better-performing X6500 overclocker bitstream\n- Disable libusb linkage/usage when neither X6500 nor ZTEX support is desired\n- Add support for \"--scan-serial all\" via simply globbing /dev\n- fpgautils: serial_autodetect implementation using sysfs\n- fpgautils: Unified serial_autodetect function to find a serial device\nregardless of the underlying method\n- fpgautils: Look for bitstreams in ../share/bfgminer/ too\n- Bugfix: Ensure curses library is always linked in NCURSES_LIBS, to avoid\nunnecessary dependencies for (non-curses) tools\n- Bugfix: GBT: work->data is always little-endian, but libblkmaker wants the\nnonce in native-endian\n- Bugfix: cpu: Corrections necessary to get 'c' and 'cryptopp' algorithms\nworking on big endian\n- Bugfix: Sanity check for bits exponent in real_block_target\n- Bugfix: cpu: Increment nonce after checking (rather than before), to avoid\nskipping the first nonce of each scanhash call\n- cpu: via: Only swap back the nonce, rather than all data\n- cpu: Minor optimization by checking H==0 before calling fulltest\n- Bugfix: Skip yasm check when building for non-x86 platforms\n- Allow --scantime alias to --scan-time\n- Build bfgminer-rpc program from api-example.c\n- Bugfix: Remove miner.h include from api-example.c since it isn't needed and\npulls in libblkmaker\n- Make wrapping consistent at 79-80 characters per line\n- Bugfix: Correct numerous misspellings, typos, etc\n- Bugfix: Prefer using a non-frozen mining thread for watchdog\n- Bugfix: x6500: Expose x6500_fpga_data even if JTAG reset/detect fail, since\nit is still used to store temperature info if the other FPGA initializes\n- Adding ZTEX Windows guide from Jason Snell\n\n\nBFGMiner Version 2.10.3 - January 22, 2013\n\n- Revert \"x6500: Whenever we get a hardware error, purge buffers just in case\nof read/write desync\"\n- Bugfix: libblkmaker: Check that zero-padding on base58check input matches\noutput (needed to properly reject addresses with too many or too few prefix/pad\n'1's)\n- Bugfix: Free bin2hex output in __update_block_title\n- Bugfix: Allocate space for the terminating null byte on new current_hash\n- Display tail end of prevblock hash rather than start+32bits\n- Try to extract block height from coinbase scriptSig, when mining stratum\n- Display next block height when using GBT\n- Use suffixes for target-difficulty also, in share accept/reject loglines\n- Bugfix: Implement common target_diff function, fixing scrypt-specific bugs in\nand simplifying common code shared by set_blockdiff, calc_diff, and share_diff\n- Set DISPLAY to :0 by default (on non-Windows)\n- Bugfix: Reset pool bytes received when zeroing stats\n- miner.php trim trailing zeros on some of the STATS numbers\n- Semi-Cherrypick: API stats - include pool network bytes + in miner.php\n- Best Share readme\n- API zero - zero statistics - all or bestshare - with optional on screen\nsummary\n- api.c pgaenable not re-enabling the device - plus related debug\n- diffexactone pool diff1 used for share value calculation is ffffffff... not\n100000000... :P\n- miner.php user/pass fix 'usr' is readonly\n- miner.php optional user/pass login restrictions\n- zero (most) API stats\n- Remember best share per pool and return in API pools\n- ztex: precheck the secondary solutions to avoid hw errors the ztex bitstreams\ngives back the latest checked nonce and its hash7 value and two possible\nsolutions.\n- Bugfix: configure: if blocks require at least one command, so fill with true\n- Bugfix: Only log stratum resume if it was actually \"idle\" before\n- Zero the best share string memory when zeroing stats.\n- Change the pool stratum socket buffer to new cgminer implementation, to\nallocate it in a grow-only fashon and reduce virtual memory fragmentation at\nthe expense of CPU time.\n- Differentiate socket full from sock full.\n- Allow stratum to startup without notify but check it is valid before creating\nstratum work.\n- Do not try to generate stratum work unless the notify command has succeeded.\n- Document Mac OS X configure usage with Homebrew pkg-config path\n- Clean up post-configure display of compile environment\n- Bugfix: If native ncurses detection fails, print \"none?\" result before moving\non to try AC_SEARCH_LIBS scan\n- Fix more printf-format non-compatibilities\n- Update windows-build.txt\n\n\nBFGMiner Version 2.10.2 - December 27, 2012\n\n- Update documentation to include block difficulty\n- Reset all stats when requested\n- Reset total diff1 shares when zeroing stats as well to show correct work\nutility.\n- Update documentation.\n- Parse anything in the stratum socket if it's full without waiting. Empty the\nsocket even if a connection is not needed in case there are share returns.\n- Provide a mechanism to zero all the statistics from the menu.\n- Display the current pool diff in the status line.\n- Display block diff in status line.\n- Generalise the code for solving a block to enable block solve detection with\nscrypt mining.\n- Generate the output hash for scrypt as well and use the one function to set\nshare_diff.\n- Use one size for scratchbuf as a macro in scrypt.c\n- Remove the unused sha224 functions.\n- Check staged_rollable under staged lock, when cloning available work.\n- scrypt_diff uses a uint64_t as well.\n- Correct target for stratum support with scrypt mining.\n- Bugfix: Ensure nonces are put in data as little-endian in test_nonce*\n- Add low-level debugging info for data_buffer (some only enabled with\n-DDEBUG_DATABUF)\n- Make all_data_cb fwrite-compliant by returning nmembs, and check for unlikely\noverflows\n- Bugfix: Need to do extract_sockaddr before trying to initiate stratum\n(erroneous http URI usage, except at startup)\n- Bugfix: Update last GBT work in pool_active before staging it, since otherwise\nit could possibly be consumed before we copy it\n- Bugfix: Address Windows-specific formatting issues (including lack of support\nfor %ll*)\n- Bugfix: ztex: Correct formatting for reset failure error\n- ztex: Fix formatting in a debug message\n- cairnsmore: Don't bother timing dynclock detection, since there's no standard\nway to log it accurately\n- Correct formatting in FPGA drivers\n- opencl/adl: Fix formatting to fit strict rules\n- Explicitly cast all_data.buf to char* for debug printing\n- Follow strict time_t handling rules\n- Use GNU format-checking attribute when available for applog\n\n\nBFGMiner Version 2.10.1 - December 21, 2012\n\n- libztex: fixed a typo\n- libztex: check returnvalue of libusb_claim_interface() and release the\ninterface in case of early exit\n- Bugfix: submissions: Skip FD_ISSET when fd==-1 (let the next select setup deal\nwith cleaning them out)\n- Bugfix: Remove sws from write_sws list when discarding it due to pre-send\nstratum disconnection\n- Bugfix: Shutdown stratum socket when initiate fails, so it doesn't linger\n- Bugfix: Clear stratum receive buffer when initializing, in case there was\nextra unprocessed data in it from a previous connection\n- Stop all work from the current pool if it's a stratum pool once it is\ndisconnected since it will be invalid upon reconnecting.\n- Discard all staged work from stratum pools as well as the shares upon\ndisconnection since all the work becomes invalid.\n- Use correct cbreak after 15 second delay when no pool is found alive.\n- modminer: Set default clock frequency to user request so it sticks better\n- modminer: Make valid frequency range consistent: 2-230\n- Allow stratum to work with scrypt.\n- MMQ add api pgaset for clock\n- API V1.23 - new pgaset command, to be used soon\n- Protect the best_share/best_diff values under control lock.\n- Bugfix: modminer: Return failure to change frequency when device reports it\n- opencl: Look in the right place for OpenCL library on Mac OS X\n- Bugfix: AC_C_BIGENDIAN is reported to have problems, and invasive even if\nburied in a conditional, so don't use it\n- Bugfix: Check for bswap_* first, to avoid redefinition based on other variants\n- Bugfix: autoheader isn't smart enough to figure out variable defines, so use\nAH_TEMPLATE for each possible header\n- Check a stratum pool hasn't gone dead while being a backup pool and missed\nhaving its idle flag cleared.\n- Fix null pointer issue when one chip on an X6500 is not initialized yet when\nreading temperature.\n- Hot-patch broken libcurl pkgconfig CFLAGS found in libcurl's Windows binaries\n- Update OpenCL 1.2 headers from http://www.khronos.org/registry/cl/api/1.2/\n- Reorganize detection of platform byteswap macros and endian to be more robust\nusing autoconf\n- Move new bandwidth-based Efficiency to status line\n- Replace work-based efficiency with new bandwidth-based efficiency\n- Bugfix: Pull out GBT request collapsing since it is no longer needed with new\nget_work main loop\n- Bugfix: Free unused work when waiting on external GBT request\n- README: Explicitly mention automake dependency\n- README: Update AMD APP SDK URIs\n- Bugfix: Free shares discarded before beginning submission\n- Bugfix: Discard stratum shares waiting for a writable socket, if the pool\ndisconnects in the meantime\n- Bugfix: Always let watchpool thread handle dead pool recovery (including for\nstratum-only pools)\n- Bugfix: Avoid lingering stratum_auth when connection is lost\n- API-README explain custom page extensions in miner.php\n- miner.php add a sample group pool report\n- miner.php allow where,group,having on cumstom pages\n- Bugfix: Hook CURLOPT_DEBUGFUNCTION to count actual bytes sent/received by\nlibcurl\n- Bugfix: Reset pool transparency_time when connecting to stratum\n- Bugfix: Immediately discard shares found on disconnected stratum pools, since\nthere is no way to submit them\n- Bugfix: Decrement total_submitting when stale shares are discarded before any\nsubmission attempts\n- Bugfix: Only try to compare stratum job_id for work that has a job_id (ie,\nones that came from stratum)\n- Bugfix: Recheck has_stratum even if the pool hasn't changed, in case pool has\nswitched to another protocol in the process; also only delay 5 seconds before\nretry if pool is the same\n- Bugfix: Try GBT if no pool protocol is known (can occur in the process of\nstratum failover to GBT)\n- Bugfix: Correctly track discarded stratum shares, and log them as \"disconnect\"\nin sharelog\n- Check for EWOULDBLOCK when supported in send and recv as well.\n- Use the raw send() command instead of curl_easy_send since curl raw socket\nusage introduces random bugs on windows.\n- Use raw recv() command in place of curl_easy_recv since the curl\nimplementation introduces random bugs on windows builds when the recv fails.\n- miner.php when displaying a single rig, add prev/next rig buttons if they\nexist, next to refresh\n- miner.php allow custom page joins for STATS\n- miner.php - include windows easyphp link\n- driver-ztex: use the correct size for the swap array\n- API stats - display pool byte transfer stats\n- Pool store data transfer stats\n- Benchmark incorrect work size\n- ChangeLog refer to NEWS\n- driver-ztex: search the complete noncerange based on the actual speed\n- API-README update\n- api use a dynamic io buffer, truncated before it reaches the current ~64k\nlimit\n\n\nBFGMiner Version 2.10.0 - December 11, 2012\n\n- Bugfix: Free work before replacing it with clone\n- Bugfix: Since we are using pipes for select notifier on *nix, we need to use\nread/write there\n- Bugfix: Winsock needs send/recv for sockets, not write/read\n- Bugfix: opencl: Initialize pc_data to avoid clean_work checking uninitialized\npointers\n- Bugfix: Correct parenthesis in bind() call in Windows notifier_init\n- Include Windows error messages in notifier_init errors\n- Include prctl header for thread renaming to work.\n- Set tv_idle time if a pool is not active when input from the menu.\n- minor unlikely zero pointer test\n- BeaverCreek doesn't like BFI INT patching.\n- Only stratum pools that are idle need to be kicked via cnx_needed.\n- Do not do any setup if opt_api_listen is disabled in api.c.\n- libztex: in case the selectFpga() failed set the selected fpga to unknown\n- Only set the lagging flag for select_pool() on failed getwork if we're not in\nopt_fail_only mode.\n- driver-ztex: support for broken fpga on a multifpga board\n- libztex: use a function for the twice called firmware reset code\n- libztex: removed an unused struct member (ztex->valid)\n- Set the pool lagging flag on startup to avoid it being shown initially, and\nonly unset it once the maximum number of staged work items has been reached.\n- libztex: Include compat.h for substitute libusb_error_name (on older libusb\nversions missing it)\n- Suppress warning about \"succeeded\" not being used in finish_req_in_progress\nfor now\n- Bugfix: Always give the get_work thread a curl, regardless of other\noutstanding curls in use\n- Bugfix: Failover after even a single job-request failure (or else it takes\ntoo long on timeouts)\n- Bugfix: Need to remove and re-add curl easy handles from multi to start a new\nrequest\n- Access total_submitting under mutex lock to avoid any potential races, and\nincrement it as soon as we queue the submission up\n- Just leave the submit_work thread running persistently\n- Bugfix: Restore work->pool after prepare_rpc_req since clean_work now clears\nit\n- Bugfix: Now that stage_work is trying to manipulate staged_work in the same\nthread, clone_available needs to stage it outside of its own lock\n- Make main() the getwork scheduler once everything is set up, so that all app\nexits use the kill_work and quit paths.\n- Set successful connect to true on auth stratum to allow summary on exit from\nsingle stratum pool.\n- Hash_pop should signal further waiters on its own pthread conditional in case\nthere are multiple waiters.\n- Check the job_id has not changed on stratum work when deciding if the work is\nstale as might occur across disconnections.\n- Perform pool_resus on getwork pool that generates work in getwork_thread.\n- Set pool lagging message for getwork pool that falls to zero staged in getwork\nthread.\n- Stage extra work when the primary pool is a getwork pool without rolltime.\n- Do not try to clean up twice if kill message is given.\n- Only recalculate total_staged in getwork thread if required.\n- Include the correct config header in libztex and include it before other\nincludes.\n- Implement a completely new getwork scheduler. Stage all work from the one\nthread, making it possible to serialise all requests minimising the number of\ngetworks requested or local work generated. Use a pthread conditional to wake up\nthe thread whenever work is removed to generate enough work to stay above the\nwatermark set by opt_queue. Remove all remnants of the old queueing mechanism,\ndeleting the now defunct queued count.\n- Bugfix: Clean up share hashing and target checks, fixing share difficulty\ncalculation for above-target would-be-shares\n- Use templates from pool_active and longpolls without fetching more\nunnecessarily\n- Try to avoid requesting GBT jobs when there is already a request in progress\nthat will likely provide sufficient work\n- Reuse most recent GBT job if in get_work_thread if it isn't stale\n- libztex: fixed some warnings and removed some whitespaces\n- Remove all references to the now unused workio_cmd structure.\n- Remove the old workio command queue thread, replacing it with a kill\nconditional to exit the program.\n- Remove getwork command from workio_cmd queues and do them directly from\nqueue_request.\n- Begin tearing down the old workio command queues by removing submit commands\nfrom there and submit them asynchronously via their own threads.\n- driver-ztex: changed two pairs of malloc()/memset() to calloc()\n- libztex: Read bitstream file in 2kb blocks with simpler and faster code\n- Added the binary versions of ztex_ufm1_15d4.ihx and ztex_ufm1_15y1.ihx\n- libztex: Add firmware download support for ZTEX 1.15d and 1.15x\n- libztex: Factor out local version of libusb_get_string_descriptor_ascii()\n- libztex: Don't return error when a bitstream was already configured\n- libztex: Read bitstream file in 64kb blocks with simpler and faster code\n- libztex: Verify that the mining firmware is not a dummy firmware\n- libztex: Match mining firmware ZTEX descriptor against the dummy firmware\n- libztex: Start download sequence only after reading in the new firmware\n- libztex: Download mining firmware to all devices with dummy firmware\n- Update windows build instructions.\n- Set pool probed to true on successful authorisation with stratum to avoid it\nbeing pinged later.\n- Style changes.\n- Allow pool active to be called on stratum or disabled pools in the watchpool\nthread if the pool has not been probed.\n- lock (most of) the threaded statistics updates\n- README stats don't add up\n- Rearrange summary lines and include count of active submissions in progress\n- Defer submissions instead of blocking in pop_curl_entry\n- Run a single share submission thread asynchronously submitting all shares in\nparallel\n- Handle share submissions asynchronously, one at a time (still threaded)\n- Split up json_rpc_call so it can be used asynchronously in libcurl-multi\n- Split submit_upstream_work into _request and _completed stages, pulling out\njson_rpc_call\n- Bugfix: Adjust USB_* variables to new LIBUSB_* names\n- Bugfix: Avoid double-free due to realloc_strcat moving memory around\n- Bugfix: Stratum connections might be needed for share submissions up to a\nminute after the last time they are used to generate work\n- Bugfix: Clean work before trying to generate new stratum work on top of it\n- Bugfix: modminer: Get rid of useless usbutils include\n- Make need connection return true if a pool is idle.\n- New --skip-security-checks option to allow miners to skip checks when it\nsaves bandwidth\n- Skip stratum transaction download when there are no transactions\n- API add Best Share to summary\n- API lock access to some summary statistics (and copy them)\n- Enable backup stratum connections for getwork when the primary pool doesn't\nhave longpoll aka solo mining.\n- Check for correct absence of opt_fail_only in cnx_needed.\n- Remove unused variable.\n- The specification for stratum has been elaborated to say that a changed diff\napplies only to new work so do not retarget when submitting shares.\n- Suspend stratum connections to backup pools when there is no requirement to\npotentially grab work from them.\n- Rename rename_thr to RenameThread to match cgminer\n- modminer: Adopt symbolic command names from kanoi\n- Make gen_stratum_work more robust by using a dynamically allocated array for\nthe header in case bogus data is sent by the pool to avoid overflowing a static\narray.\n- scrypt_diff now returns a uint64_t\n- Support monitoring and reporting much higher diffs for scrypt mining,\ntruncating irrelevant zeroes from displayed hash.\n- Pass ostate values around in scrypt to be able to extract full hashes if\nneeded later on.\n- Revert \"Handle crash exceptions by trying to restart cgminer unless the\n--no-restart option is used.\"\n- Provide helper function realloc_strcat to extend arbitrary length arrays\nbased on string length.\n- Use base_work for comparison just for cleanness in __copy_work\n- Remove all static work structs, using the make and free functions.\n- Add pool no. to stale share detected message.\n- Add info about which pool share became stale while resubmitting.\n- Reduce extra slots in the max backlog for ztex to minimise memory waste.\n- Get rid of unused last_work in opencl thread data.\n- Do away with the flaky free_work api in the driver code which would often lose\nthe work data in opencl and simply flush it before exiting the opencl scanhash.\n- Minor work handling restructure, including moving some stratum data from\nfixed-size buffers to their own heap allocations.\n- opencl: Use new dev_error function for REASON_DEV_NOSTART\n- Provide rudimentary support for the balancing failover strategies with stratum\nand GBT by switching pools silently on getwork requests.\n- Convert remaining modminer and bfl uses of usleep to nmsleep.\n- Convert libztex to nmsleep where possible.\n- Convert unreliable usleep calls to nmsleep calls in ztex driver.\n- Tidy up device error counts\n- Only increase gpu engine speed by a larger step if the temperature is below\nhysteresis instead of increasing it to max speed.\n- Convert pool not responding and pool alive message on backup pools to verbose\nlevel only since they mean a single failed getwork.\n- Use stratum block change from backup pools as an alternative to longpoll for\npools that don't support LP.\n- Round some more static string arrays to 4 byte boundaries.\n- There is no need for the static arrays to be larger than required, so long as\nthey're 4 byte aligned to appease ARM.\n- Hash1 is only used by the CPU mining code and never changes so remove it from\nthe work struct and bypass needing to process the value for all other mining.\n\n\nBFGMiner Version 2.9.5 - December 11, 2012\n\n- Bugfix: Copy share hash to work->hash before doing 4-byte flip required by\nfulltest\n- driver-ztex: libztex_setFreq() must be called before ztex_releaseFpga()\n- libztex: Make log messages say bitstream when refering to bitstreams\n- Increase FD_SETSIZE to 4096 on Windows\n- Bugfix: Use AC_PROG_CPP in libusb include subdirectory detection for improved\nportability\n- Bugfix: Free input memory after prioritising pools in TUI\n- Bugfix: Free filename entry for writing config file when done with it\n- Bugfix: Free stratum nonce1 before replacing it with new value on reconnect\n\n\nBFGMiner Version 2.9.4 - December 4, 2012\n\n- Update libblkmaker to 0.2.1\n- Count template number, and append it to the coinbase of templates without any\ncbtxn\n- Bugfix: bitforce: Always increment global hw error counter when incrementing\ndevice hwe\n- Bugfix: Correct order of printf-style arguments in cbappend fail\n- Bugfix: Capitalize \"MHz\" correctly\n- ztex: Correctly release mutex and reset FPGA if configuration fails\n- ztex: Harmonize low-speed FPGA configuration code with high-speed code\n- libztex: Silence warning: comparison between signed and unsigned\n- Count longpoll decodes as queued work since the count otherwise remains\nstatic.\n- Bugfix: Assign header-based rolltime before decoding work, so GBT expires\noverrides it properly\n- Look for libusb_init in -lusb, since FreeBSD has it there\n- Bugfix: Use pkgconfig for libusb when available, and try to guess the include\npath if not\n- Bugfix: FPGA-README: Correct idVendor in example MMQ udev rule\n- fixes target calc for mips openwrt\n- Bugfix: clear_work: Whether the template is in fact being freed or not, the\nwork reference to it needs to be\n- libztex: Work around ZTEX USB firmware bug exposed by the FreeBSD libusb\n- README: Document solo mining usage\n- README: Update dependencies\n- Bugfix: We should never roll stale work\n- Ubuntu: Removing erroneous libssl dep again. GITHUB#94\n- Bugfix: Clear out stratum share work before freeing it\n- Provide rudimentary support for literal ipv6 addresses when parsing stratum\nURLs.\n- Do not attempt to remove the stratum share hash after unsuccessful submission\nsince it may already be removed by clear_stratum_shares.\n\n\nBFGMiner Version 2.9.3 - November 16, 2012\n\n- Bugfix: Properly process new stratum jobs through test_work_current, even if\nold shares are still accepted, and copy submit_old flag correctly\n- Ensure pdiff 1 is always caught regardless of bdiff precision, and ceil all\nother cases to ensure we never lose valid shares\n- Check against a double for current pool diff.\n- Support for fractional diffs and the classic just-below-1 share all FFs diff\ntarget.\n- Check share target diff for best_share to be calculated when solo mining.\n- Store the full stratum url information in rpc_url for correct configuration\nfile saving.\n- Put in a hack to prevent dud work from sneaking into test_work_current being\nseen as a new block.\n- Reset the work->longpoll flag where it will affect stratum work items as\nwell.\n- Bugfix: Stratum does not guarantee notify messages every minute, so extend\ntimeout to 2 full minutes\n- Bugfix: Always honour libblkmaker time limits\n- Always (debug)log when stratum template is updated by the pool\n- Bugfix: When a stratum connection is interrupted, ensure all work/shares for\nit are considered stale\n- Bugfix: clear_sock should return on socket errors\n- Bugfix: Force calculation of work_difficulty since set_work_target fails to\nconsider the pdiff<bdiff difference\n- Bugfix: Minimal support for handling real difficulties from stratum server\n- Bugfix: Never consider shares to be accepted if the submission response is an\nerror\n- Bugfix: Always fail scrypt detection if Stratum is chosen\n\n\nBFGMiner Version 2.9.2 - November 7, 2012\n\n- Add endian swap defines for where missing.\n- Only retarget stratum shares to new pool diff if diff has dropped.\n- Bugfix: x6500: Use json_object_set_new to correctly count references to\nper-FPGA RPC data\n- Bugfix: modminer: Use json_object_set_new to correctly count references to\nper-FPGA RPC data\n- Bugfix: Only append newline when printing protocol data\n- Bugfix: Use memchr to look for newlines in socket line data, since the buffer\nisn't null terminated\n- Bugfix: Ensure GETWORK_MODE_GBT isn't replaced with GETWORK_MODE_POOL\n- Count lost stratum share submits and increase message priority to warning.\n- Show which pool untracked share messages have come from.\n- Sleep 5 seconds before retrying submit.\n- Changes to build prototypes to support building on FreeBSD 9.1-RC2 amd64\n- Count lost shares with stratum as submit stale lost.\n- Discard record of stratum shares sent and report lost shares on disconnection\nsince they will never be reported back.\n- Check that count of transactions received via stratum is reasonable\n- Use realloc'd data_buffer to support stratum lines longer than 8 KB, and\nparse stratum responses during auth\n- Use mining.get_transactions to check for stratum pool transparency (actual\nresponse ignored for now)\n- ztex: Silence false \"unexpected\" hardware errors, and don't count them as hw\nerrors\n- README: Update build instructions to reflect current reality\n- x6500: Expose per-FPGA details to RPC API\n- x6500: Implement support for --temp-target\n- x6500: Increase default clock frequency to 200 Mhz, now that new bitstream\nseems to run well around that\n- x6500: Flush nonces in FPGA buffer at initialization to avoid false hw errors\non restart\n- x6500: Release device lock sooner during initialization, before logging\ninitial frequency info\n- x6500: Read temperature sensors after sending work, when enabled\n- Bugfix: jtag: Fix optimized register reading code (it was reading an extra\nbit before the last, corrupting outside the buffer)\n- Implement new --force-dev-init option to force bitstream upload to modminer\nand x6500 devices\n- Bugfix: x6500: Include --scan-serial option even for x6500-only builds\n- Bugfix: ztex: Include --scan-serial option even for ztex-only builds, so it\ncan be used to disable autodetect if needed\n- FPGA-README: Discuss X6500 --scan-serial usage of cases where it may be\nneeded\n- ft232r: If we are searching for a specific serial, pay no attention to the\nproduct id\n- x6500: Try a more flexible approach to applying dynclock logic\n- Bugfix: dynclock: Use standard C struct initializer to handle initialization,\ninstead of memsetting memory to nulls\n- x6500: Whenever we get a hardware error, purge buffers just in case of\nread/write desync\n- Bugfix: x6500: When purging ft232r buffers (during bitstream upload), also\nclear JTAG delayed read counter to avoid any potential desync\n- Bugfix: ft232r: Always flush writes before purging buffers, and empty local\nread buffer when flushing ftdi read buffer\n- There is no need for addrinfo any more.\n- Fix filename for x6500 bitstream to match previous commit's rename\n- Rename x6500 bitstream to match existing licensing naming setup\n- x6500 dual temp sensor support\n- x6500 is far more stable with its own bitstream\n\n\nBFGMiner Version 2.9.1 - October 30, 2012\n\n- When we find a block, always progress to it for mining\n- Bugfix: Enforce --expiry, but split --expiry-lp for a longer expiry on\nlongpoll setups\n- Bugfix: regeneratehash needs to compare hash segments in Little Endian, not\nBig Endian\n- Bugfix: Always fail scrypt detection if Stratum is working\n- Bugfix: Scan for ft232r devices later, after console lock and other mutexes\nare initialized properly\n- ft232r: Debuglog non-FTDI device IDs found\n- Bugfix: Wait to release JSON result in case of JSON-RPC error until we've\nlogged the error\n- Bugfix: RPC: Defer release of JSON until after cmd is used\n- Bugfix: Release JSON result in case of JSON-RPC error\n- Bugfix: Release job JSON result as soon as we are done using it\n- Bugfix: Release JSON received from RPC socket after we're done using it\n- Bugfix: Use clear_work and workdup everywhere work is copied around\n- Bugfix: Clear work before replacing it with new, to free any pointers\n- server and client sockaddr_in are no longer used in struct pool.\n- Set sshare id and swork_id within the sshare mutex to avoid multiple share\nsubmits with the same id.\n- Bugfix: Really use freeaddrinfo to clean up in extract_sockaddr\n- Update documentation for X6500\n- Bugfix: Free unused JSON returned when switching to Stratum\n- Bugfix: Free unused work when switching to Stratum instead\n- Bugfix: Use freeaddrinfo to clean up in extract_sockaddr\n- RPC: Include PGA support for X6500-only builds\n- RPC: Abstract code to handle any new device drivers as PGAs without special\nsupport\n- Bugfix: Release GBT submission JSON objects after dumping them\n- Bugfix: Free old stratum_work data before replacing it\n- Bugfix: Release memory allocated by prior stratum sockaddr extractions\n- Bugfix: Clear work template when preparing a new request\n- Bugfix: Initialize temporary stratum work\n- Bugfix: x6500: jtag_read buffer needs to be initialized since reading JTAG\nimplies writing too\n- Replace now-redundant accepted_weighed with equivalent diff_accepted\n- Fail on select() failing in stratum thread without needing to attempt\nrecv_line.\n- Add share to stratum database before sending it again in case we get a\nresponse from the pool before it's added.\n- Bugfix: modminer: Check that we have a valid fd before trying to start work\n- Shorten the initiate stratum connect timeout to 30 seconds.\n- Shorten the stratum timeout on read to 90 seconds to detect unresponsive pool.\n- Display best share difficulty on exit.\n- Make stratum socket fail more robust on windows by disabling the send buffer.\n- Reuse the same curl handle forcing a new connection instead of risking\nderefencing.\n- Add information about submission failure to stratum send.\n\n\nBFGMiner Version 2.9.0 - October 28, 2012\n\n- modminer: Remove dead code\n- Bugfix: Include headers in order needed for Mingw build\n- Bugfix: Save pool pointer to avoid dereferencing work after it might\npotentially be freed\n- Bugfix: Cleanup some harmless warnings\n- Bugfix: TUI: Avoid clearing the whole screen when we just want to clear the\nlog window\n- Wishlist #130 implemented by \"blinkier\":\n- - Add all-at-once pool priority reassignment to curses TUI interface\n- - Save/restore pool priorities in config file\n- - Allow setting initial pool priorities via command line\n- Bugfix: Replace reportin hack with a reset back to LIFE_INIT for bitstream\nupload\n- Bugfix: SI kilo prefix is a lowercase \"k\"\n- Bugfix: If userpass is missing a password, treat it as a null password\n(regression fix)\n- Upgrade libblkmaker to 0.2.0\n- Bugfix: Build correct pay-to-scripthash script\n- Implement --coinbase-addr for solo mining\n- x6500: Since we program in about a minute now, only report status verbosely\nevery 25%\n- x6500: Poll nonce less often since USB latency slows us down anyway\n- jtag: Avoid writing an extra readback byte when we are ignoring tdo anyway\n- ft232r: Set output buffer size to 4096 bytes\n- x6500: Adjust dynclock so it works more reasonably\n- x6500: Dynclock support\n- Provide a simple/dummy libusb_error_name when it is missing (libusb < 1.0.9)\n- x6500: Stop abusing pointer type to store bitstream upload progress\n- Bugfix: ft232r: Avoid reuse of USB device count variable\n- x6500: Implement basic hashrate prediction and efficient job completion\n- jtag: Optimized implementation of JTAG reads to workaround ft232r slowness\n- x6500: Try nonce with previous work if it is wrong for current\n- x6500: Ensure ft232r buffer is flushed to change registers\n- x6500: Start clock speed off at 180, and extra debugging for\nx6500_set_register\n- x6500: When programming, poll each FPGA status individually since they might\nnot be ready at the same time\n- x6500: Various tweaks and hacks to get mining working\n- Bugfix: x6500: Remove erroneous bitendianflip\n- Bugfix: jtag: Handle ftdi-common environmental stuff properly\n- jtag: Defer ignored reads a bit to avoid USB latency\n- Bugfix: ft232r: First 2 bytes of every 0x40 are FTDI status or something\n- x6500: Implement mining protocols (doesn't work yet)\n- x6500: Cleanup dead code and implement bailout2\n- x6500: Clean up and finish FPGA initialization\n- x6500: Comment bitstream upload function better\n- fpgautils: Abstract open_xilinx_bitstream out from modminer and x6500 drivers\n- x6500: Get bitstream upload working\n- Bugfix: jtag: Use the correct bit for reading/writing data streams\n- ft232r: Buffer writes to improve performance\n- x6500: Get FPGA probe working\n- jtag: JTAG implementation for X6500 (over ft232r)\n- ft232r: ft232r_read_all function to simplify exact-length reads\n- ft232r: Implement read buffer so ft232r_read always works like read(2)\n- ft232r: Complete necessary interfaces for X6500\n- x6500: Bare minimum detection-only X6500 support via libusb\n- Minor debian packaging fixes.\n- Only add stratum share to database if we succeeded in submitting it, with a\ndebug output saying it succeeded.\n- Use keepalive with stratum sockets to improve its ability to detect broken\nconnections.\n- Show only the URL in the status bar to avoid long prefixes making for extra\nlong lines.\n- Display compact status in menu and update README to reflect current menu\nentries.\n- Add a compact display mode that does not list per device statistics in the\nstatus window.\n- Add blank spaces after best share displayed.\n- Round a few static string arrays up to 4 byte boundaries for ARM.\n- Display best share diff for scrypt as well.\n- Show the best diff share as \"best share\" and add info to the README.\n- Display the best diff share submitted so far.\n- Redundant check.\n- The work struct pointer in struct pc_data in findnonce is never freed yet\nthere is no need to allocate it separately so make struct work a static part of\nthe struct pc_data. s\n- No longer should hide --no-restart option if OpenCL support is missing\n- Handle crash exceptions by trying to restart cgminer unless the --no-restart\noption is used.\n- Switch queued count when choosing a different pool from a failed stratum pool\nin getwork thread.\n- Put a mandatory 5s wait between reattempting a getwork on failure to avoid\nhammering requests.\n- Make sure to check pool stratum curl exists under lock before attempting any\nrecv to not risk dereferencing upon attempting to reinitiate stratum.\n- Avoid redefining macros and align to 4 byte boundaries.\n- API - add Stratum information to pools\n- update FPGA-README for MMQ\n- Time for dynamic is in microseconds, not ms.\n- x86_64 builds of mingw32 are not supported directly and should just configure\nas generic mingw32 builds since they're NOT 64 bit.\n- Use 3 significant digits when suffix string is used and values are >1000.\n- Get rid of unused warning for !scrypt.\n- Use select on stratum send to make sure the socket is writeable.\n- Cope with dval being zero in suffix_string and display a single decimal place\nwhen significant digits is not specified but the value is greater than 1000.\n- Pad out the suffix string function with zeroes on the right.\n- Failure to calloc in bin2hex is a fatal failure always so just check for that\nfailure within the function and abort, simplifying the rest of the code.\n- Provide locking around the change of the stratum curl structures to avoid\npossible races.\n- Bump opencl kernel version numbers.\n- Remove atomic ops from opencl kernels given rarity of more than once nonce on\nthe same wavefront and the potential increased ramspeed requirements to use the\natomics.\n- Clear the pool idle flag in stratum when it comes back to life.\n- Display correct share hash and share difficulty with scrypt mining.\n- Show work target diff for scrypt mining.\n- Watch for buffer overflows on receiving data into the socket buffer.\n- Dramatically simplify the dynamic intensity calculation by oversampling many\nruns through the opencl kernel till we're likely well within the timer\nresolution on windows.\n- Align static arrays to 4 byte boundaries to appease ARM builds for stratum.\n- Update documentation.\n- Left align values that are suffix_string generated.\n- Share_diff should not be converting the work data to hex.\n- Update readme describing difficulty displayed on log lines.\n- Off by one error.\n- Prevent overflows of the port char array in extract_sockaddr.\n- Disable stratum detection with scrypt.\n- Display the actual share diff next to the pool required diff, using a suffix\ncreation function to prevent values of >1000 being shown in their entirety.\n- Fix 4 * 0 being 0 that would break dynamic intensity mode.\n- Supplement other 64-bit endian swap macros\n- Bugfix: Fix htobe64 on big endian platforms that don't define it\n- Fix lack of htobe64 on mingw32.\n- Reinstate the history on dynamic intensity mode to damp fluctuations in\nintensity but use an upper limit on how much the value can increase at any time\nto cope with rare overflows.\n- Update to cgminer's newer dynamic intensity algorithm\n- Support for the stratum mining protocol.\n- Simplify target generation code.\n- Add support for client.get_version for stratum.\n- Use a 64 bit unsigned integer on the diff target to generate the hex target.\n- Update reconnect message to show whole address including port.\n- Look for null values and parse correct separate array entries for url and port\nwith client reconnect commands for stratum.\n- The command for stratum is client.reconnect, not mining.reconnect.\n- Only copy the stratum url to the rpc url if an rpc url does not exist.\n- Implement rudimentary mining.reconnect support for stratum.\n- Ignore the value of stratum_active on calling initiate_stratum and assume\nwe're always trying to reinitiate it, and set the active flag to false in that\nfunction.\n- stratum auth can be unset if we fail to authorise on subsequent calls to\nauth_stratum which undoes the requirement of setting it in one place so set it\nin pool_active.\n- Format Stratum submission-start debug the same way as other submissions\n- Bugfix: Set work_restart_id in gen_stratum_work for when work is reused to\navoid thinking it's all stale.\n- Only auto-switch to Stratum internally, but save HTTP URI in case pool stops\nusing Stratum; also always shows original pool URI on RPC\n- SHUT_RDWR is now always defined for us, so no need to check ifdef on LP hang\n- Implement --no-stratum option to disable autodetection\n- Show Stratum pools as \"Strtm\" protocol in \"Pool management\" TUI\n- Bugfix: BFGMiner doesn't use rpc_proxytype\n- Remove free that could segfault.\n- Use the stratum url as the rpc url advertised if we switch to it.\n- Count an invalid nonce count as a hardware error on opencl.\n- Count each stratum work item as local work.\n- Cope with one stratum pool being the only active pool when it dies by sleeping\nfor 5 seconds before retrying to get work from it instead of getting work\nindefinitely.\n- Detect stratum outage based on either select timing out or receiving an empty\nbuffer and properly re-establish connection by disabling the stratum_active\nflag, coping with empty buffers in parse_stratum.\n- Fix various modminer warnings on mingw.\n- Fix sign warning on windows build for bitforce.\n- Cast socketfail to integer since SOCKET is an unsigned int on windows.\n- Use the stratum thread to detect when a stratum pool has died based on no\nmessage for 2 minutes.\n- Only set the stratum auth flag once and once the stratum thread is started,\nuse that to set/unset the stratum active flag.\n- Only hand off to stratum from getwork if we succeed in initiating the\nprotocol.\n- Target should only be 32 bytes copied.\n- Use a static array for work submission data instead of stack memory.\n- Clear the buffer data before sprinting to it.\n- Clear work stratum strings before setting them and add them to debug output.\n- Drop stratum connect failed message to verbose level only since it's a regular\nprobing message.\n- TCP Keepalive in curl is only in very recent versions and not required with\nregular messages on stratum anyway.\n- Move stratum sockets to curl infrastructure with locking around send+recv to\nbegin support for proxies and ssl.\n- Make detect stratum fail if a proxy has been set up.\n- Stratum does not currently have any proxy support so do not try to switch to\nstratum if a proxy has been specified.\n- Windows doesn't work with MSG_PEEK on recv so move to a continuously updating\nbuffer for incoming messages.\n- Alloca is unreliable on windows so use static arrays in util.c stratum code.\n- Begin support for mingw stratum build.\n- Add space to reject reason.\n- Parse the reject reason where possible from stratum share submission.\n- Pass json error value to share result function to be able to parse reject\nreason in stratum.\n- Don't try to parse unneeded parameters in response to mining.subscribe.\n- Remove the sshare hash entry if we failed to send it.\n- Change notify message to info level to avoid spamming repeatedly when a pool\nis down.\n- Check the stratum pool difference has not changed compared to the work diff\nwhen testing whether a share meets the target or not and retarget if necessary.\n- Bit error in target calculation for stratum.\n- Offset the current block detection to the prev block hash.\n- We should be testing for id_val, not id in parse stratum response.\n- Make target on stratum scale to any size by clearing sequential bits according\nto diff.\n- Correct target calculation in gen_stratum_work.\n- If a share result has an error code but still has an id, it is likely a\nreject, not an error.\n- Initiate stratum the first time in pool_active only, allowing us to switch to\nit on getting a failed getwork and detecting the presence of stratum on the url\nat that time.\n- Use 5 second timeout on sock full for now as a temporary workaround.\n- If no stratum url is set by the end of the detect stratum routine, copy the\nsockaddr url.\n- Make all buffers slightly larger to prevent overflow.\n- Make the stratum recv buffer larger than the recvsize.\n- Userpass needs to be copied to user and pass earlier to allow stratum\nauthorisation to work with it.\n- Store a sockaddr url of the stripped url used in determining sockaddr to not\nconfuse it with the stratum url and fix build warnings.\n- Decrease the queued count with stratum work once it's staged as well.\n- Allow the stratum retry to initiate and auth stratum in pool_alive to make\nsure the stratum thread is started.\n- Avoid duplicating pool->rpc_url and setting pool->stratum_url twice to itself.\n- Detect if a getwork based pool has the X-Stratum header on startup, and if so,\nswitch to the stratum based pool.\n- Comment update.\n- Minor message change.\n- Create a work item from a \"clean\" request from stratum allowing the new block\nto be detected and the appropriate block change message to be given.\n- Use statically allocated stratum strings in struct work to cope with the\ninability to safely deallocate dynamically allocated ram.\n- Use the current pool when deciding whether to reuse work from a stratum source\nrather than the work's previous pool.\n- Copy the stratum url to the rpc url to avoid none being set.\n- Provide locking around stratum send operations to avoid races.\n- Submit shares from stratum through the abstracted submit share function\ndetecting what message they belong to and showing the data from the associated\nwork, and then deleting it from the hash.\n- Use a more robust mechanism to obtain a \\n terminated string over a socket.\n- Abstract out share submit as a function to be useable by stratum.\n- Rename parse_stratum to parse_method as it is only for stratum messages that\ncontain methods.\n- Display stratum as mechanism in status line when current pool is running it.\n- Count each stratum notify as a getwork equivalent.\n- Correct nonce submitted with share.\n- Extranonce2 should be added before coinbase2.\n- We should be hashing the binary coinbase, not the hex one.\n- Fix endianness of nonce submitted for stratum.\n- Check that stratum is already active in initiate_stratum to avoid\nde-authorising ourselves by subscribing again.\n- Begin implementing a hash database of submissions and attempt sending results.\n- Copy parameters from stratum work required for share submission.\n- Set lagging flag on first adding a pool to prevent pool slow warning at\nstartup.\n- Fix work->target being a 32 byte binary in gen_stratum_work.\n- Store and display stripped url in its own variable.\n- Create machinery to divert work requests to stratum.\n- Generate the work target in gen_stratum_work, setting default diff to 1 in\ncase it is not yet set.\n- Generate work data, midstate and hash1 in gen_stratum_work.\n- Generate header created from stratum structures in gen_stratum_work.\n- Generate merkle root hash in gen_stratum_work.\n- Generate the coinbase for generation of stratum based work.\n- The number of transactions is variable so make merkle a variable length\ndynamically allocated array and track how many there are for stratum.\n- Rename nonce2 to n2size reflecting that it's a size variable and not the\nactual nonce.\n- Provide rudimentary support for stratum clean work command in the stratum\nthread.\n- Cope with pools being removed in the stratum thread.\n- Use the pool sock value directly in the stratum thread in case it changes\nafter reconnecting.\n- Create a stratum thread per pool that has stratum that monitors the socket and\nserves received data.\n- Check return value of stratum_parse.\n- Complete authorisation in stratum.\n- Implement stratum parsing of notify parameters and storing them in the pool\nstratum work structure.\n- Create helper functions for duplicating json strings to avoid keeping json\nreferences in use.\n- Append \\n in the sock_send function instead of adding it when constructing\njson in stratum.\n- Don't keep any json references around with stratum structures.\n- Create parse_stratum function that hands off stratum parameters to other\nfunctions to manage pool stratum work struct variables. Implement mining\ndifficulty setting.\n- Create helper functions for checking when a socket is ready to read on and\nreceive a single line at a time. Begin stratum authorisation process.\n- Provide a helper function for reading a single \\n terminated string from a\nsocket.\n- Create a stratum work structure to store current work variables.\n- Test specifically for stratum being active in pool_active.\n- Detect stratum in common place when adding urls, and use a bool to tell us\nwhen it's active.\n- Remove unused add_pool_details5\n- Fix warnings.\n- Extract and store various parameters on stratum init confirming successful\nmining notify.\n- Use existing socket macros and close the socket on failure in init stratum.\n- Initiate stratum and grab first json result.\n- Get detailed addressinfo from the parsed URL for future raw socket usage when\npossible. IPV4 only for now.\n- Prepare for getaddrinfo call.\n- Add data structures to pool struct for socket communications.\n- Put all socket definitions in util.h to allow reusing by added socket\nfunctions to be used in util.c.\n\n\nBFGMiner Version 2.8.3 - October 18, 2012\n\n- Update to libblkmaker 0.1.3\n- Use explicit host to BE functions in scrypt code instead of hard coding\nbyteswap everywhere.\n- Ease the checking on allocation of padbuffer8 in the hope it works partially\nanyway on an apparently failed call.\n- Round target difficulties down to be in keeping with the rounding of detected\nshare difficulties.\n- String alignment to 4 byte boundaries and optimisations for bin<->hex\nconversions.\n- Fix GPU memory allocation size for scrypt\n- Fix access violation with scrypt mining\n- Bugfix: Only free rpc_req after using it, not before\n- Bugfix: Increment work->pool->staged inside of mutex to avoid work being\nfreed (and staged decremented) before we dereference it\n- Revert \"No need for extra variable in hash_push.\": The extra variable is\nneeded to avoid a rare dereference-after-free error.\n- In opencl_free_work, make sure to still flush results in dynamic mode.\n- Workaround: Debug log only after dec_queued, to make a free/use race more\nrare\n- Bugfix: Remove redundant \\n in debug messages\n- Bugfix: Free rpc_req in pool_active and longpolls\n- README: Explicitly provide Ubuntu package name for libjansson-dev\n- Bugfix: Include flash_led bool in cgpu_info for Icarus-but-not-BitForce\nbuilds, since Cairnsmore uses it\n- Only check work block id against pool's if the pool has a known block id\n- Avoid clearing pool->block_id unless we really are changing pools\n\n\nBFGMiner Version 2.8.2 - October 8, 2012\n\n- Update to libblkmaker 0.1.2\n- Bugfix: --temp-target no longer has a simple default (fixes build without\nOpenCL support)\n- Bugfix: icarus: Silence false epoll error\n- Bugfix: icarus: Set firstrun for errors starting next job, so the current\none finishes properly\n- Bugfix: icarus: Restore generic failure management for write errors\n- Use strtod not strtol for bitforce temp backup.\n- Cope with broken drivers returning nonsense values for bitforce temperatures.\n- Minor warning fixes.\n- Fix unused warnings on ming build.\n- Fix sign warning in ocl.c\n- fds need to be zeroed before set in modminer.\n- Put scrypt warning on separate line to avoid 0 being shown on windows as\nbufsize.\n- Prevent corrupt values returned from the opencl code from trying to read\nbeyond the end of the buffer by masking the value to a max of 15.\n- Icarus USB write failure is also a comms error\n- api.c DEBUG message has no paramter\n- Icarus catch more USB errors and close/reopen the port\n- API-README update cgminer verison number\n- hashmeter fix stats kh/s on 32bit windows\n- cairnsmore: Increase maximum clock frequency to 210 Mhz\n- icarus: Hashrate estimates really don't need the attention of a warning,\ndemote them to debug\n- cairnsmore: Automatically \"downgrade\" default FPGA-per-device to 1 for\ndynclock devices\n- Bugfix: cairnsmore: Get autodetection of dynclock to work consistently\n- cairnsmore: Adjust dynclock usage to react in proper time\n- dynclock: Document function usage\n- cairnsmore: Fix race on dynclock detection\n- icarus: Detect attempts to send commands via work and neuter them\n- cairnsmore: Glasswalker has a minimum multiplier of 20 :(\n- cairnsmore: Detect frequency changing support despite hashing of commands\n- modminer: Allow clocks down to 2 Mhz just in case\n- Allow device drivers and users to properly change target temperatures for\nnon-GPUs\n- Check that ncurses*-config installs actually work before deciding to use\nthem\n- Bugfix: Fix multiple bugs in autogen.sh\n- - Don't use readlink -f unneccesarily (it's not portable)\n- - Always run autoreconf within the real source directory\n- - Run configure from PWD, *not* the real source directory\n- Bugfix: Include nonce in data buffer for debugging\n- Bugfix: swap32* wants count of 32-bit blocks, not bytes\n- Initial Cygwin port\n- Revert \"Remove needless roundl define.\", since it is needed for Cygwin and\nOpenWRT\n- Bugfix: Deal with various compiler warnings\n- modminer: Implement --temp-hysteresis logic\n- Support for maximum frequency being below the default, eg when the maximum\nis temporarily reduced to deal with temperature\n- Bugfix: modminer: Reduce dynclock max frequency as needed to keep\ntemperature below cutoff\n- Bugfix: Restore disabled label, needed to skip over hashrate calculations\n(which mess up otherwise)\n- Bugfix: bitforce: Count actual throttling as hardware errors\n- icarus: Allow failure in case of reopen failure, now that the miner core\nwill retry on its own\n- If a device dies, attempt to reinitialize it occasionally\n- Bugfix: The REST flag is now preferred over WAIT, since the former might\ntrigger the latter\n- Bugfix: modminer: Update temperature readings when disabled (fixes thermal\ncutoff recovery)\n- Bugfix: Move thermal cutoff to general watchdog code (fixes bitforce\nrecovery)\n- Rename enable_device to register_device, since it only works for setting it\nup at startup\n- Move targettemp from ADL to cgpu_info, so all devices can readily use it\n- Bugfix: \"REST\" flag had too much padding\n- Bugfix: adl: Only warn and disable GPU due to thermal cutoff, if it's\nactually enabled\n- Bugfix: bitforce: Only warn and disable bitforce due to thermal cutoff, if\nit's actually enabled\n\n\nBFGMiner Version 2.8.1 - September 27, 2012\n\n- Avoid strndup for Windows compatibility\n- Bugfix: cairnsmore: Add missing compat.h include (for sleep)\n- cairnsmore: Implement \"identify\" for supported firmware\n- Adjust identify_device API to return a bool whether supported or not, for\nruntime capability detection\n- Bugfix: cairnsmore: Fix invalid share detection on LE\n- Bugfix: icarus: Fix logging message to not assume \"Icarus\" always, and use\ndevice driver name\n- Bugfix: cairnsmore: Correct frequency scaling detection logic\n- cairnsmore: When changing frequency, adjust Hs expectations accordingly\n- cairnsmore: Detect availability of frequency scaling, and only enable it\nwhen supported\n- cairnsmore: Implement dynamic clocking support for Glasswalker's bitstream\n- Update libblkmaker to 0.1.1\n- Advertise BFGMiner in blocks found by default (without --coinbase-sig)\n- RPC: Add \"Coinbase-Sig\" to config/setconfig\n- New --coinbase-sig option to add arbitrary data to blocks you generate (GBT\nonly)\n- opencl: Defer nonce validity checking to submit_nonce\n- scrypt: Implement test_nonce2 and submit_nonce hw error check\n- Bugfix: modminer: Convert nonce to native endian\n- Interpret any attempts to submit a H-not-zero nonce as a hardware error\n- make-release: Strip DLLs and EXE in Windows binary\n- dynclock: Use consistent messages for frequency changes\n- modminer: Port to dynclock\n- dynclock: Split dynamic clocking algorithm out of Ztex driver\n- Bugfix: When changing GPU memclock, adjust internal variable so it is\ncorrectly saved to config file\n- Bugfix: Re-probe longpoll header for each pool alive check, including\nretries when a preferred protocol fails\n- Bugfix: modminer: Bitstream binary filenames are *.bit\n- modminer: Start frequency off at 200 Mhz\n- Reorder libztex header include order to fix missing struct definition.\n- Display share difficulty on log with a shortened hash display on submission.\n- API stats add some pool getwork difficulty stats\n- Ignore any pings pushed to the worker threads if the thread is still paused to\nprevent it being enabled and disabled repeatedly.\n- Test for sequential getwork failures on a pool that might actually be up but\nfailing to deliver work as we may end up hammering it repeatedly by mistake.\n- reduce windows compile warnings\n- util.c - bug - proxy - no data end condition\n- API don't change 'Diff1 Shares' - backward compatability FTW\n- miner.php highlighting correctly handling difficulty\n- API - Add last share difficulty for devices and pool\n- Store and report Accepted,Rejected,Stale difficulty in the summary and API\n- WorkTime - display prevblock for scrypt\n- api.c remove compile warnings\n- Calculate work difficulty for each getwork and display with WorkTime debug\n- FPGA - allow long or short device names in detect code + style police\n- WorkTime - multiple nonce per work and identify the work source\n- Optional WorkTime details with each Accepted/Rejected work item\n- Icarus - ignore hardware errors in timing mode\n- miner.php oops - mistype\n- API pgaidentify - unsupported message should be a warning\n- API/BFL identify a device - currently only BFL to flash the led\n- BFL add throttle count to internal stats + API\n- BFL: missing device id in log message\n- Bugfix: ztex: Clear device_ztex before freeing it\n- Bugfix: ztex: statline existence depends on whether the libztex structure\nexists, not whether the cgpu is enabled\n- Bugfix: README: Make usermod commands consistent, including important -a\noption\n- Bugfix: Address a couple of rare TQ leaks, and improve logging a bit\n- Bugfix: Properly quote configure options\n\n\nBFGMiner Version 2.8.0 - September 15, 2012\n\n- Be specific about jansson version requirement\n- Replace \"Alive\" in pool status with protocol in use (GBT or GWork)\n- Remove copy of old jansson from source repository\n- Honour block template expiry (BIP 23 Basic Pool Extensions \"expires\")\n- Add --no-gbt option so getblocktemplate can be disabled if it causes\nproblems\n- BIP 22 long polling\n- Properly detect pool protocol\n- Bugfix: Sort out work template refcounting by properly using work_free and\nnew workcpy\n- Support for rolling extranonce in templates\n- Initial libblkmaker integration, using a git submodule\n- cairnsmore: There's no set hashrate like Icarus, so always use short timing\nmode by default\n- Bugfix: Include unistd.h needed for ssize_t type\n- fpgautils: Don't try to scan serial at all anymore, if a device is claimed\n- fpgautils: serial_claim function to politely ask other drivers not to try to\nuse device\n- RPC: Update to work with Cairnsmore\n- cairnsmore: Windows autodetect using FTDI library\n- cairnsmore: Beginnings of new driver, with automatic upgrade from Icarus\ndetection\n- icarus: Support disabling reopen quirk via --icarus-options\n- proxy: Replace mess of encoding proxy into pool URI with a --pool-proxy\noption, and use cURL's builtin proxy URI support\n- save individual pool proxy settings to config\n- API-README update for pools proxy info\n- CURL support for individual proxy per pool and all proxy types\n- Bugfix: Update current_block_id for fixed set_curblock\n- miner.php by default don't display IP/Port numbers in error messages\n- api.c all STATUS messages automatically escaped\n- API add display of and setting queue,scantime,expiry\n- README - FPGA device FAQ\n- API add device diff1 work\n- count device diff1 shares\n- API-README update\n- api.c Correct diff1 field name\n- Bugfix: Sanitize block hash handling (including fixing on big endian)\n- Bugfix: Print the (full) correct block hash when warning about work issued\nagainst old blocks\n- Bugfix: When comparing current block, only pay attention to the prevblock\nheader\n- Allow mixing user+pass and userpass, so long as user+pass are balanced\nbefore userpass options\n- ztex: Include device serial number and FPGA number in cgpu name field\n- ztex: Abstract common cgpu_info creation code\n- ztex: Do thread initialization in thread_init rather than thread_prepare\n- Bugfix: Tolerate working on old blocks when there is only one pool enabled\n- Bugfix: ztex: Detect through fpgautils so -S noauto correctly inhibits\nautodetection\n- ztex: Workaround duplicate share submissions by doubling \"backlog\" size\n- ztex: Use consistent device ids for logging\n- Bugfix: ztex: Increment global hw_errors too\n- Bugfix: free adhoc string elist element when removing it from list\n- Bugfix: icarus: Initialize lret variable after work restart reentry\n- Bugfix: ztex: Free lastnonce heap memory if backlog allocation fails\n- icarus: Initialize epoll event structure in a way Valgrind is happier with\n- Bugfix: Use strtok_r for parse_config since some options use strtok\nthemselves\n- Import strtok_r from gnulib for Windows portability\n- Bugfix: ztex: Don't try to destroy a mutex that was never created (single\nFPGA Ztex devices)\n- ztex: Clean up redundant dereferencing in ztex_shutdown\n- API-README more debug parameter information\n- API allow full debug settings control\n- Sort the blocks database in reverse order, allowing us to remove the first\nblock without iterating over them. Output the block number to debug.\n- Adjust opencl intensity when adjusting thread count to prevent it getting\npegged at a value below the minimum threads possible.\n- miner.h max_hashes -> int64_t\n- Keep the local block number in the blocks structs stored and sort them by\nnumber to guarantee we delete the oldest when ageing the block struct entries.\n- Use correct sdk version detection for SDK 2.7\n- Bugfix: Align Ztex statline properly by removing redundant frequency\n- make-release: Convert text files to DOS format for Windows ZIP\n\n\nBFGMiner Version 2.7.5 - August 27, 2012\n\n- Revert \"Do a complete cgminer restart if the ATI Display Library fails, as\nit does on windows after running for some time, when fanspeed reporting\nfails.\"\n- Stop special-casing worksize default to 256 for Cypress, since it incurs a 5\nMH/s hit with stock config\n- New \"--scan-serial all\" feature to probe all enumerated serial ports\n- modminer: Revamp dynamic clocking algorithm per request from cablepair\n- Test for lagging once more in queue_request to enable work to leak to backup\npools.\n- There is no need to try to switch pools in select_pool since the current pool\nis actually not affected by the choice of pool to get work from.\n- Only clear the pool lagging flag if we're staging work faster than we're using\nit.\n- needed flag is currently always false in queue_request. Remove it for now.\n- thr is always NULL going into queue_request now.\n- Fix for non-ADL OpenCL device formatting issue\n\n\nBFGMiner Version 2.7.4 - August 23, 2012\n\n- Perform select_pool even when not lagging to allow it to switch back if needed\nto the primary.\n- Simplify macros in output kernels avoiding apparent loops and local variables.\n- Carry the needed bool over the work command queue.\n- Move the decision to queue further work upstream before threads are spawned\nbased on fine grained per-pool stats and increment the queued count immediately.\n- Track queued and staged per pool once again for future use.\n- OpenCL 1.0 does not have native atomic_add and extremely slow support with\natom_add so detect opencl1.0 and use a non-atomic workaround.\n- Pools: add RollTime info to API 'stats' and 'Stats' button in miner.php\n\n\nBFGMiner Version 2.7.3 - August 23, 2012\n\n- Minimise the number of getwork threads we generate.\n- Pick worksize 256 with Cypress if none is specified.\n- Give warning with sdk2.7 and phatk as well.\n- Whitelist sdk2.7 for diablo kernel as well.\n- Only keep the last 6 blocks in the uthash database to keep memory usage\nconstant. Storing more is unhelpful anyway.\n- Increase kernel versions signifying changed APIs.\n- BFL flash - more FPGA-README\n- Check we haven't staged work while waiting for a curl entry before proceeding.\n- Use atomic ops to never miss a nonce on opencl kernels, including nonce==0,\nalso allowing us to make the output buffer smaller.\n- Remove compile errors/warnings and document compile/usage in FPGA-README\n- Ignore the submit_fail flag when deciding whether to recruit more curls or not\nsince we have upper bounds on how many curls can be recruited, this test is\nredundant and can lead to problems.\n- API-README update cgminer version number\n- API-README fix groups P: example mistake\n- API-README add COIN and other edits\n- miner.php allow 'coin' is custom pages\n\n\nBFGMiner Version 2.7.1 - August 22, 2012\n\n- Update windows build instructions courtesy of sharky.\n- Increase max curls to number of mining threads + queue * 2, accounting for up\nand downstream comms.\n- Queue enough requests to get started.\n- There is no point trying to clone_work in get_work() any more since we clone\non every get_work_thread where possible.\n- There is no point subtracting 1 from maxq in get_work_thread.\n- miner.php allow page title to be defined in myminer.php\n- Only set lagging flag once there are no staged work items.\n- select_pool does not switch back to the primary once lagging is disabled.\n- Increment total work counter under mutex lock.\n- Increment the queued count after the curl is popped in case there's a delay\nwaiting on curls and we think we've queued work when in fact we're waiting on\ncurls.\n- Do the dynamic timing in opencl code over a single pass through scanhash to\nmake sure we're only getting opencl times contributing to the measured\nintervals.\n- Increase curl reaping time to 5 minutes since comms between  curl requests can\nbe 2 mins apart with lots of rolltime.\n- No need for extra variable in hash_push.\n- Remove short options -r and -R to allow them to be reused and remove readme\nentries for deprecated options.\n- Deprecate the opt_fail_pause parameter, leaving a null placeholder for\nexisting configurations.\n- Free work before retrying in get_work_thread.\n- Don't pause after failed getwork, set lagging flag and reassess.\n- We should not be pausing in trying to resubmit shares.\n- Get rid of the extending fail pause on failed connects since we discard work\nafter a period.\n- get_work always returns true so turn it into a void function.\n- get_work never returns false so get rid of fail pause loop.\n- Get rid of pause and retry from get_upstream_work so we only do it from one\nplace.\n- Remove all cases where --retries aborts BFGMiner, making it for submission\nretries only, where it makes sense.\n\n\nBFGMiner Version 2.7.0 - August 21, 2012\n\n- Implement a new pool strategy, BALANCE, which monitors work performed per pool\nas a rolling average every 10 minutes to try and distribute work evenly over all\nthe pools. Do this by monitoring diff1 solutions to allow different difficulty\ntarget pools to be treated equally, along with solo mining. Update the\ndocumentation to describe this strategy and more accurately describe the\nload-balance one.\n- fpga serial I/O extra debug (disabled by default)\n- Getwork fail was not being detected. Remove a vast amount of unused variables\nand functions used in the old queue request mechanism and redefine the getfail\ntesting.\n- Consider us lagging only once our queue is almost full and no staged work.\n- Simplify the enough work algorithm dramatically.\n- Only queue from backup pools once we have nothing staged.\n- Don't keep queueing work indefinitely if we're in opt failover mode.\n- Make sure we don't opt out of queueing more work if all the queued work is\nfrom one pool.\n- Set lagging flag if we're on the last of our staged items.\n- Reinstate clone on grabbing work.\n- Grab clones from hashlist wherever possible first.\n- Cull all the early queue requests since we request every time work is popped\nnow.\n- Keep track of staged rollable work item counts to speed up clone_available.\n- Make expiry on should_roll to 2/3 time instead of share duration since some\nhardware will have very fast share times.\n- Check that we'll get 1 shares' worth of work time by rolling before saying we\nshould roll the work.\n- Simplify all those total_secs usages by initialising it to 1 second.\n- Overlap queued decrementing with staged incrementing.\n- Artificially set the pool lagging flag on pool switch in failover only mode as\nwell.\n- Artificially set the pool lagging flag on work restart to avoid messages about\nslow pools after every longpoll.\n- Factor in opt_queue value into enough work queued or staged.\n- Roll work whenever we can on getwork.\n- Queue requests for getwork regardless and test whether we should send for a\ngetwork from the getwork thread itself.\n- Get rid of age_work().\n- Don't try to get bitforce temperature if we're polling for a result to\nminimise the chance of interleaved responses.\n- Fix harmless unused warnings in scrypt.h.\n- Check we are not lagging as well as there is enough work in getwork.\n\n\nBFGMiner Version 2.6.5 - August 20, 2012\n\n- API new command 'coin' with mining information\n- Add message to share if it's a resubmit.\n- Add virtual adl mapping for when none is specified on the command line to\nnot crash without a map specified.\n- Fix ADL gpu-map not working when there are more ADL devices than openCL.\nPatch supplied and tested by Nite69.\n- bitforce: Initial import of Linux-only bitforce-firmware-flash utility\n- Revert stale-on-arrival failsafe, since it ends up needing exceptions for\neverything\n- Bugfix: opencl: Declare opencl_dynamic_cleanup in header\n- Even if we want to submit stale shares, give up if we have more submissions\nwaiting on threads (even before failing)\n- Even if we want to submit stale shares, give up if they've failed and we\nhave more submissions waiting on threads\n- opencl: Use timeBeginPeriod on Windows to ensure gettimeofday has sufficient\nprecision for dynamic intensity\n- Bugfix: opencl: Move ADL fanspeed warning messages to a new thread to get\naround summary-update deadlocking\n- README: Note that user groups don't get updated until re-login\n- Initialise cnt in libztex.c\n- Don't try to start devices that don't support scrypt when scrypt mining.\n- Repeating on timeout in ztex could make the code never return.\n- Offset libusb reads/writes by length written as well in ztex.\n- Cope with timeouts and partial reads in ztex code.\n- If there are more devices than nDevs, don't iterate over them as they may\noverwrite devices mapped below that with the mapping option.\n- Fix README faq on bfl auto-detect.\n- Set memory clock based on memdiff if present from with engine changes,\nallowing it to parallel manual changes from the menu as well.\n- api.c typo\n- API allow display/change failover-only setting\n- API-README corrections\n- miner.php documentation (in API-README) v0.1\n- Bugfix: opencl: Show blank device-info statline area if GPU doesn't have\nADL, to fix column alignment\n- README: Document usage of 0 to indicate \"leave at default\" for comma-\ndelimited GPU options\n- Correct API-README versions to match when BFGMiner included them\n- API-README update changelog\n- Minimise locking and unlocking when getting counts by reusing shared mutex\nlock functions.\n- Avoid getting more work if by the time the getwork thread is spawned we find\nourselves with enough work.\n- The bitforce buffer is cleared and hw error count incremented on return from a\nfailed send_work already so no need to do it within the send_work function.\n- Don't make mandatory work and its clones last forever.\n- modminer: Log debug info for nonces found\n\n\nBFGMiner Version 2.6.4 - August 11, 2012\n\n- Bugfix: Define my_cancellable_getch in miner.h\n- Escape \" and \\ when writing json config file\n- miner.php allow a custom page section to select all fields with '*' - e.g. to\ncreate a STATS section on a custom page\n- miner.php optional single rig totals (on by default)\n- Bugfix: Initialize submitting mutex\n- Bugfix: bitforce: Allocate enough space for FTDI description pointers\n- Queue one request for each staged request removed, keeping the staged\nrequest count optimal at all times.\n- Bugfix: Avoid cancelling threads while locks are held\n- Set recognizable names on threads for debugging\n- Bugfix: Don't keep making new get_work threads if all pools are dead\n- Enable configuring submission thread limit with --submit-threads option\n- Bugfix: Limit active submission threads to 0x40 so we don't overflow\n- Bugfix: Properly handle switching to pools that aren't on the latest block,\nand warn if a pool actively switches to an old block\n- Log more details of reasons in stale_work debug messages\n- Failsafe against stale-on-arrival work: disable the pool\n- Bugfix: Debug message should show \"Work stale due to work restart\" when it's\nnot a share\n- windows-build: Remove APP SDK section since it is no longer needed\n- modminer: HACK: Let last_work handle the end of the work, and start the next\none immediately\n- Bugfix: modminer: Remove erroneous \"else\" statement, to fix hashrate\nreporting\n- README: Document user group required for FPGAs on Gentoo and Ubuntu\n- BFGMiner-specific README adjustments\n- Bugfix: opencl: Ignore error getting device ids from platforms unless they\nare explicitly chosen\n- New --debuglog option to include debug info in stderr logfile even if not in\nthe console\n- Bumped down debhelper compatibility reqs so that this will build on Lucid.\n- Updated to match packaging changes.\n- Switched to native packages so we don't have to muck around creating fake\nupstream tarballs, and can easily generate minor versions for upload to\nLaunchpad.\n- Removed accidentally included debugging line.\n- Minor version bump again because of launchpad. Will sort this out for next\nrelease.\n- Updated to patch bitforce module issue on Debian/Ubuntu.\n- Added local quilt config dir to ignore.\n- modminer: Check nonce against previous work, in case of race\n- Bugfix: Enable --kernel-path option if ModMiner or Ztex is enabled (even if\nno OpenCL)\n- Bugfix: Escape backslashes and double-quotes in strings that rightfully may\nhave them, when writing JSON config file\n- Clean object (.o) and dependency (.d) files out of source tree\n- Bugfix: bitforce: Don't count hashes that never happened due to throttling\n- Bugfix: Deal with serial_open timeout maximum (25.5s)\n- - fpgautils: Linux only supports uint8_t decisecond values for timeouts, so\nuse uint8_t for timeout value; this gets smart compilers to throw warnings\nwhen overflowed in some cases\n- - bitforce: Reduce serial timeout to 25 seconds (was 30) and increase job\nlong timeout to 25 seconds (was 15) to handle throttling gracefully\n- modminer: Add debug info to API extra device stats\n- modminer: Raise clock speed when there's only good nonces for a while\n- modminer: Only print clock speed adjustments when they actually change\n- modminer: Increase tolerance for bad nonces to 2%\n- modminer: Reset bad-nonce ratio measurement when the clock speed changes\n- Bugfix: bitforce: Include the correct device id in \"garbled response\" warning\n- ADL: Add attribution and disclaimer to interfaces\n- Cleaned out refs to AMD SDKs.\n- Updated README about debian packaging, changelog with minor version bump to\nwork around Launchpad reqs.\n- Updated changelog with Ubuntu release specific version, needed to build for\nmultiple releases. Also stripped out ADL SDK stuff in the build rules.\n- Initial work to adjust debian packaging from cgminer. Should build correctly\nnow with pbuilder/pdebuild, and include docs.\n- Adapt miner code to free ADL structures\n- Import free ADL interfaces\n- Include scrypt.h in Makefile.\n- Fix windows bitforce build.\n- Convert the serial autodetect functions to use int instead of char to\nenumerate devices.\n- Uglify windows autodetect code for BFL.\n- There is no point zeroing temperature in BFL if we fail to get a response, and\nwe should register it as a HW error, suggesting throttling.\n- Update SCRYPT README with information about HW errors.\n- Use the scrypt CPU code to confirm results from OCL code, and mark failures as\nHW errors, making it easier to tune scrypt parameters.\n- We may as well leave one curl still available per pool instead of reaping the\nlast one.\n- Display reaped debug message outside mutex lock to avoid recursive locking.\n- api.c update API start message and include port number\n- miner.php ignore arg when readonly\n- miner.php allow pool inputs: delete, addpool, poolpriority\n- bitforce: Reopen on communication error\n- Bugfix: Calculate hw err percent for the affected FPGA only\n- make-release: Adapt to new autogen by using NOCONFIGURE var\n\n\nBFGMiner Version 2.6.3 - August 6, 2012\n\n- modminer: Relax no-nonces downclocking condition to be more reasonable\n- README: Update scrypt configure option\n- README: Update configure options\n- Bugfix: Display --disable-modminer in configure --help now that it is\nenabled by default\n- Add specific information when ADL detects error -10 saying the device is not\nenabled.\n- modminer: Shorten upload warning message to fit better\n- modminer: Sending a \"ping\" first, to workaround bug in new firmware betas\n- modminer: Include Hardware Errors and Valid Nonces in extra device status\n- Bugfix: modminer: Calculate bad-nonce percentage based only on the same\nFPGA's hardware errors, accurately\n- modminer: Show bitstream upload progress in statline, and only report to log\nevery 10%\n- modminer: Be more verbose about why the clock is getting reduced\n- Document how Icarus golden nonce is handled by other FPGAs\n- Rewrite should_run for sched, to properly handle one-shot schedules spanning\nmidnight\n- Bugfix: Check list_empty in pop_curl_entry after condition wait\n- Bugfix: Only add new pools to array after completing basic structure\ninitialization\n- If __BFGMINER_SEGFAULT_ERRQUIT is set in the environment, segfault on\nnon-zero quit()s\n- Check against NULL pointers getting into curlring\n- modminer: Finish a process results run with a nonce poll, rather than sleep\n- modminer: Workaround Windows driver failures\n- Count likely throttling episodes on bitforce devices as hardware errors.\n- Bugfix: bitforce: Increase serial read timeout to 30 seconds during actual\nmining, to tolerate more throttling\n- Style cleanups.\n- Make pool_disabled the first in the enums == 0, fixing the pool enabled count\nwhich compares if value is not enabled before enabling it.\n- Correct writing of scrypt parameters to config file based on command line\nparameters only.\n- Add scrypt support while writing conf\n- Use different variables for command line specified lookup gap and thread\nconcurrency to differentiate user defined versus auto chosen values.\n- Queue a request on pool switch in case we have no work from the new pool yet.\n- API remove unused warning in non-GPU compile\n- api.c in linux allow to open a closed socket in TIME_WAIT\n- Display failover only mode in pool menu and allow it to be toggled live.\n- Reinstate check for system queueing lag when the current pool's queue is maxed\nout, there is no staged work, and the work is needed now.\n- Fix harmless warnings.\n- Check the current staged and global queued as well before queueing requests.\nDiscard stales before ageing work in the watchdog thread. Queue requests after\ndiscarding and ageing work in watchdog thread. Display accurate global queued in\ncurses output. Reuse variable in age_work().\n- The queueing mechanism has become a complex state machine that is no longer\npredictable. Rewrite it from scratch watching only current queues in flight and\nstaged work available on a pool by pool basis.\n- Update debian package configs to v2.6.2\n- Queue an extra request whenever staged work drops below mining thread count in\nhash_pop.\n- Bugfix: Initialize logwin to 1 line high temporarily, to avert PDCurses crash\n- Enable FPGA support by default, as long as their dependencies are met\n- Bugfix: modminer: Search for *ModMiner* in udev ID_MODEL\n- make-release: build with --enable-scrypt\n- miner.php support custom report section joins\n- ICA default fpga_count to work_division if specified\n- FPGA-README document new hidden --icarus-options\n- ICA support 57600 baud rate, up to 8 FPGA and partial working FPGA boards\n- Scrypt mining does not support block testing yet so don't try to print it.\n- Clear the bitforce buffer whenever we get an unexpected result as it has\nlikely throttled and we are getting cached responses out of order, and use the\ntemperature monitoring as a kind of watchdog to flush unexpected results.\n- It is not critical getting the temperature response in bitforce so don't\nmandatorily wait on the mutex lock.\n- Check there is a cutoff temp actually set in bitforce before using it as a cut\noff value otherwise it may think it's set to zero degrees.\n- We dropped the temporary stopping of curl recruiting on submit_fail by\nmistake, reinstate it.\n- Make threads report in either side of the scanhash function in case we miss\nreporting in when restarting work.\n- Add debugging output when work is found stale as to why.\n- Print the 3 parameters that are passed to applog for a debug line in\nbitforce.c\n- Clear bitforce buffer on init as previously.\n- Add some headroom to the number of curls available per pool to allow for\nlongpoll and sendwork curls.\n- Show the correct base units on GPU summary.\n- Bugfix: bitforce: 1 decisecond timeout is unreasonably short, give it a\nsecond\n- Bugfix: Don't try to log abandon time, since we aren't keeping track\nreasonably\n- Import uthash 1.9.6\n- Bugfix: bitforce: Pause after send_work failures\n- Fix comm error handling to not consider work restarts an error condition\n- comm error bug fix\n- Bugfix: No endian.h on Windows\n- Remove unused mkinstalldirs\n- Display scrypt as being built in as well.\n- Fix build warning about KL_SCRYPT when built without scrypt support.\n- News update.\n- More scrypt intensity information.\n- Minor readme updates.\n- Update README with more build instructions.\n- Remove the low hash count determinant of hardware being sick. A low hash rate\ncan be for poor network connectivity or scrypt mining, neither of which are due\nto sick hardware.\n- Style\n- API-README poolpriority changes\n- api.c verify poolpriority parameters before changing pools\n- api.c poolpriority changes\n- Implement shared swap32(yes|tole|tobe) function to handle endian flipping\n32-bit chunks in blocks\n- Use correct macros for endian handling code\n\n\nBFGMiner Version 2.6.1 - July 29, 2012\n\n- Autoselect --scrypt iff all pools send scrypt work\n- Adapt SCRYPT-README to BFGMiner (directing Bitcoin donations the correct\ndirection to reach Con)\n- Remove mentions of Litecoin specifically\n- Bugfix: Fix build without OpenCL but with scrypt\n- make-release: Add SCRYPT-README\n- Bump version 2.6.0, adding SCRYPT README to makefile.\n- Smarter autogen.sh script.\n- Sleeping on intensity decrease is broken, remove it.\n- Sleep only the extra amount of time we overran the dynamic interval in dynamic\nmode.\n- Add scrypt documentation in the form of a separate readme.\n- Fix build error without scrypt enabled.\n- Limit thread concurrency for scrypt to 5xshaders if shaders is specified.\n- Simplify repeated use of gpus[gpu]. in ocl.c\n- Find the nearest power of 2 maximum alloc size for the scrypt buffer that can\nsuccessfully be allocated and is large enough to accomodate the thread\nconcurrency chosen, thus mapping it to an intensity.\n- Don't make opt_scrypt mandatory blocking with opencl code.\n- Update kernel versions reflecting changes in the API.\n- Make the thread concurrency and lookup gap options hidden on the command line\nand autotune parameters with a newly parsed --shaders option.\n- Fix target testing with scrypt kernel as it would have been missing shares\nbelow target.\n- Always create the largest possible padbuffer for scrypt kernels even if not\nneeded for thread_concurrency, giving us some headroom for intensity levels.\n- Use the detected maximum allocable memory on a GPU to determine the optimal\nscrypt settings when lookup_gap and thread_concurrency parameters are not given.\n- Check the maximum allocable memory size per opencl device.\n- Add debugging output if buffer allocation fails for scrypt and round up\nbufsize to a multiple of 256.\n- Nonce testing for btc got screwed up, leading to no accepted shares. Fix it.\n- Display size of scrypt buffer used in debug.\n- Allow intensities up to 20 if scrypt is compiled in.\n- Add name to scrypt kernel copyright.\n- Allow lookup gap and thread concurrency to be passed per device and store\ndetails in kernel binary filename.\n- Ignore negative intensities for scrypt.\n- Change the scale of intensity for scrypt kernel and fix a build warning.\n- Correct target value passed to scrypt kernel.\n- Use 256 output slots for kernels to allow 1 for each worksize.\n- Test the target in the actual scrypt kernel itself saving further\ncalculations.\n- Reinstate GPU only opencl device detection.\n- Decrease lookup gap to 1. Does not seem to help in any way being 2.\n- Fix build.\n- Make pad0 and pad1 local variable in scrypt kernel.\n- Constify input variable in scrypt kernel.\n- Send correct values to scrypt kernel to get it finally working.\n- Create command queue before compiling program in opencl.\n- Fix external scrypt algo missing.\n- Limit scrypt to 1 vector.\n- Handle KL_SCRYPT in config write.\n- Get rid of stuff.\n- Don't enqueuewrite buffer at all for pad8 and pass work details around for\nscrypt in dev_blk.\n- Set the correct data for cldata and prepare for pad8 fixes.\n- Get rid of spaces in arrays in scrypt kernel.\n- Start with smaller amount of hashes in cpu mining to enable scrypt to return\ntoday sometime.\n- Free the scratchbuf memory allocated in scrypt and don't check if CPUs are\nsick since they can't be. Prepare for khash hash rates in display.\n- Add cpumining capability for scrypt.\n- Set scrypt settings and buffer size in ocl.c code to be future modifiable.\n- Cope with when we cannot set intensity low enough to meet dynamic interval by\ninducing a forced sleep.\n- Make dynamic and scrypt opencl calls blocking.\n- Fix nonce submission code for scrypt.\n- Make sure goffset is set for scrypt and drop padbuffer8 to something\nmanageable for now.\n- Set up buffer8 for scrypt.\n- Build fix for opt scrypt.\n- Don't check postcalc nonce with sha256 in scrypt.\n- Don't test nonce with sha and various fixes for scrypt.\n- Make scrypt buffers and midstate compatible.\n- Use specific output array entries in scrypt kernel.\n- Provide initial support for the scrypt kernel to compile with and mine scrypt\nwith the --scrypt option.\n- Enable completely compiling scrypt out.\n- Begin import of scrypt opencl kernel from reaper.\n\n\nBFGMiner Version 2.5.3 - July 29, 2012\n\n- Bugfix: Add zlib1.dll to Win32 release archive\n- Bugfix: SICK low-hashrate is now determined by being under 1/3 the runtime\naverage hashrate\n- Bugfix: cpu_set_t is never #defined, so use CPU_ZERO which is a macro\n\n\nBFGMiner Version 2.5.2 - July 29, 2012\n\n- Limit total number of curls recruited per pool to the number of mining threads\nto prevent blasting the network when we only have one pool to talk to.\n- Bugfix: Skip writing configuration of range-limited int options with negative\nvalues\n- Bugfix: Correctly attempt to load ~/.bfgminer/bfgminer.conf or\n~/.cgminer/cgminer.conf as defaults\n- Send X-Minimum-Wait header on longpolls, to explicitly inform pools we will\nhandle a response with no delay\n- bitforce: Abandon (only) stale searches for work restarts\n- Keep a counter of enabled pools and use that instead of iterating over the\npool list. Use that value to ensure we don't set the last remaining active pool\nto the rejecting state.\n- bitforce: Skip out of sending work if work restart requested\n- RPC: Writeup on poolpriority command usage\n- Bugfix: API: Report errors from poolpriority command\n- RPC: New \"poolpriority\" command to set the order of pool priorities\n- strtok_ts: Thread-safe strtok that work on POSIX or Windows\n- Bugfix: Supress \"caught up\" event when first switching to a pool\n- Announce and restart work immediately when current pool has caught up to the\ncurrent block\n- Bugfix: Don't consider work stale due to other pools' longpolls, if\n--failover-only is active\n- Refactor stale_work function to only flag actual stale shares\n- stale_work: Don't factor getwork delay into expiry for shares (only for work\nitself)\n- Bugfix: Use pool number rather than numeric pointer to strict pool, in block\nfound notice\n- Accept JSON Numbers in config file parameters\n- Improve readability of OPT_HASARG in parse_config\n- Allow JSON false as a valid value for strictly boolean options\n- Include scan-serial in example configuration file\n- fpgautils: add support for 57.6 kBd serial\n- miner.php add a socket RCV timeout for if cgminer is hung and the API thread\nis still running\n- BFL force all code to timeout to avoid hanging\n- Initialise mdplatform.\n- Find the gpu platform with the most devices and use that if no platform option\nis passed.\n- Bugfix: It is not a hardware error if nonces returned from modminer don't\nmeet the pool target\n- bitforce & icarus: Log detection failures at debug log level, so we don't\nconfuse users who have different devices (which is why these drivers are\nfailing detection!)\n- Show \"WAIT\" (LIFE_WAIT status) if a cgpu is idle waiting for work (pool\nslow/dead)\n- Instead of quitting on failing N retries, just discard the share\n- Bugfix: Don't discard stale shares after submission failure, if user or pool\nwants stales submitted\n- Bugfix: Record discard-during-retry shares in the sharelog\n- Bugfix: Only show Algorithm in RPC summary if CPU mining is actually active\n- OpenCL: Remove intensity from statline, since it overflowed\n- Move \"Q\" (requested getworks) to second status line as \"GW\" to balance out\nbetter\n- Bugfix: Use a mutex to control non-curses output\n- Simplify code to a single vprintf path for curses-less printing\n- Move opt_quiet check to my_log_curses, so it works for curses-less builds\n- Use log_generic for vapplog to cut down on code duplication\n- Bugfix: Copy argv[0] given to dirname()\n- Find the gpu platform with the most devices and use that if no platform\noption is passed.\n- Allow more platforms to be probed if first does not return GPUs.\n- Detach pthread from within the api thread in case it is terminated due to not\nbeing instantiated before pthread_cancel is called from main, leading to a\nsegfault.\n- Debug output per thread hashrate is out by a factor of 1000.\n- Don't check if CPUs are sick since they can't be.\n- Calculate midstate in separate function and remove likely/unlikely macros\nsince they're dependent on pools, not code design.\n- Display in debug mode when we're making the midstate locally.\n- Bugfix: Document --no-adl and --gpu-platform\n- Bugfix: Remove redundant documentation of --auto-fan and --auto-gpu (they\nare in GPU-specific options)\n- CPU mining may not be included in binaries, but it's not deprecated for\nBFGMiner either\n- Bugfix: Restore case-insensitivity to input\n- Scroll the device list with up/down arrow keys, if it is overflowed\n- Use select statement to handle input\n- Bugfix: Actually check that the device fits in the individual summary window\nbefore trying to print it\n- Bugfix: Fix build without curses but with OpenCL\n- Bugfix: Don't show a Temperature key if it isn't known\n- BFGMiner-specific NEWS fix\n\n\nBFGMiner Version 2.5.1 - July 13, 2012\n\n- Replace CPU Algo in header with runtime\n- Bugfix: Calculate diff-1 utility to fix utility-hashrate on pools with\ndiff!=1\n- Add utility hashrate to curses display\n- Show units in kh, Gh, Th, etc as needed to use at most 3 integer digits\n- Use FTD2XX.DLL on Windows to autodetect BitFORCE SHA256 devices\n- bitforce_get_result returns -1 on error now.\n- Check return value of read in BFgets\n- Bugfix: modminer: Count hashes done before work restart\n- Bugfix: modminer: Adapt \"get nonce\" error condition to new scanhash=>-1\nerror API\n- Bugfix: Make our Windows nanosleep/sleep replacements standards-compliant\n(which fixes nmsleep) and include compat.h for bitforce (for sleep)\n- miner.php fix rig # when miners fail\n- Fix whitespace mangling.\n- bitforce: Use \"full work\" vs \"nonce range\" for kernel name\n- Abbrv. correction\n- Remove superfluous ave_wait\n- Put kname change for broken nonce-range back in\n- Add average wait time to api stats\n- Revert \"Merge branch 'ave_time' of https://github.com/pshep/cgminer.git\"\n- Add average return time to api stats\n- Missed one nonce-range disabling.\n- Change timeouts to time-vals for accuracy.\n- More BFL tweaks. Add delay between closing and reopening port. Remove buffer\nclear in re-init Add kernel type (mini-rig or single)\n- Revert \"Change BFL driver thread initialising to a constant 100ms delay\nbetween devices instead of a random arrangement.\"\n- Only try to shut down work cleanly if we've successfully connected and started\nmining.\n- Fix spelling.\n- modminer: Firmware returns 0xffffff00 immediately if we set clockspeed too\nhigh\n- Bugfix: modminer: Actually count good shares\n- Bugfix: Adapt OpenCL scanhash errors to driver API change (errors are now -1,\nnot 0)\n- Remove bitforce_thread_init The delay thing does nothing useful... when long\npoll comes around, all threads restart at the same time anyway.\n- fix API support for big endian machines\n- Bugfix: Use const struct device_api* for mt_disable\n- modminer: Show progress of bitstream upload\n- Bugfix: Don't declare devices SICK if they're just busy initializing\n- Bugfix: Calculate nsec in nmsleep correctly\n- miner.php allow rig names in number buttons\n- Change BFL driver thread initialising to a constant 100ms delay between\ndevices instead of a random arrangement.\n- Spelling typo.\n- Time opencl work from start of queueing a kernel till it's flushed when\ncalculating dynamic intensity.\n- Modify te scanhash API to use an int64_t and return -1 on error, allowing zero\nto be a valid return value.\n- Check for work restart after the hashmeter is invoked for we lose the hashes\notherwise contributed in the count.\n- Remove disabled: label from mining thread function, using a separate\nmt_disable function.\n- Style changes.\n- Cope with signals interrupting the nanosleep of nmsleep.\n- Use standard cfsetispeed/cfsetospeed to set baud rate on *nix\n- miner.php split() flagged deprecated in PHP 5.3.0\n- Bugfix: Use nmsleep instead of restart_wait, so we always wait the full time\n- Make long timeout 10seconds on bitforce for when usleep or nanosleep just\ncan't be accurate...\n\n\nBFGMiner Version 2.5.0 - July 7, 2012\n\n- Fix BitFORCE driver to not silenty discard valid shares (bug introduced by\nCGMiner merges)\n- Fix --benchmark not working since the dynamic addition of pools and pool\nstats.\n- Make disabling BFL nonce range support a warning since it has to be explicitly\nenabled on the command line now.\n- miner.php allow renaming table headers\n- Make bitforce nonce range support a command line option --bfl-range since\nenabling it decrease hashrate by 1%.\n- Add sanity checking to make sure we don't make sleep_ms less than 0 in\nbitforce.\n- The fastest minirig devices need a significantly smaller starting sleep time.\n- Use a much shorter initial sleep time to account for faster devices and nonce\nrange working, and increase it if nonce range fails to work.\n- Use nmsleep instead of usleep in bitforce.\n- Provide a ms based sleep function that uses nanosleep to avoid the inaccuracy\nof usleep on SMP systems.\n- delay_time_ms is always set so need not be initialised in bitforce.\n- Increase bitforce timeout to 10 seconds.\n- Add more hysteresis and poll ~5 times to allow for timer delays in bitforce\ndevices.\n- miner.php allow alternating line colours (off by default)\n- Display the actual duration of wait when it is greater than the cutoff.\n- Set nonce to maximum once we determine nonce range support is broken.\n- Initial wait time is always known so no need to zero it beforehand in\nbitforce.\n- No point counting wait time until the work is actually sent to bitforce\ndevices.\n- Use string comparison functions instead of explicit comparisons.\n- Account for wait_ms time when nonce_range is in use on BFL.\n- Split nonces up into 1/5 chunks when nonce range is supported.\n- limit clear buffer iterations.\n- Ad fd check to clear buffer.\n- miner.php remove incorrect 'DATE' error message\n- miner.php allow summary header in custom pages\n- Disable nonce range support in BFL when broken support is detected.\n- Restart_wait is only called with a ms value so incorporate that into the\nfunction.\n- Only try to adjust dev width when curses is built in.\n- miner.php define custom sum fields as a simple array\n- Fix off-by-one error in nonce increment in bfl.\n- Use BE when setting nonce in bitforce nonce range work.\n- Enable nonce range in the normal init sequence for bfl.\n- Queue extra work at 2/3 differently depending on whether we're using nonce\nrange or not.\n- Initially enable support for nonce range support on bfl, splitting nonces up\ninto 3/4 size and only disable it if it fails on work submit.\n- Attempt to detect nonce range support in BFL by sending work requring its\nsupport.\n- Limit retrying on busy for up to BITFORCE_TIMEOUT_MS\n- Attempt to initialise while bitforce device returns BUSY.\n- Extend length of string that can be passed to BFL devices.\n- Fix signedness warning.\n- Adjust device width column to be consistent.\n- Use cgpu-> not gpus[] in watchdog thread.\n- Add api stats (sleep time)\n- Timing tweaks Added long and short timeouts, short for detecting throttling,\nlong to give up totally. Reset sleep time when device re-initialised Still check\nresults after timeout Back up a larger time if result on first poll.\n- Add API Notify counter 'Comms Error'\n- Style police on api.c\n- Do all logging outside of the bitforce mutex locking to avoid deadlocks.\n- Remove applog call from bfwrite to prevent grabbing nested mutexes.\n- Bitforce style changes.\n- Minor style changes.\n- Remove needless roundl define.\n- Made JSON error message verbose.\n- Fine-tune timing adjustment. Also remove old work_restart timing.\n- Check for gpu return times of >= 0, not just 0, to fix intensity dropping to\n-10.\n- Restart is zeroed in the mining thread so no need to do it inside the bitforce\ncode.\n- More improvements to comms. BFL return nothing when throttling, so should not\nbe considered an error. Instead repeat with a longer delay.\n- Polling every 10ms there's not much point checking the pthread_cond_timedwait\nas it just adds overhead. Simply check the value of work_restart in the bfl main\npolling loop.\n- Use a pthread conditional that is broadcast whenever work restarts are\nrequired. Create a generic wait function waiting a specified time on that\nconditional that returns if the condition is met or a specified time passed to\nit has elapsed. Use this to do smarter polling in bitforce to abort work, queue\nmore work, and check for results to minimise time spent working needlessly.\n- Add busy time to wait time.\n- api.c put version up to 1.14\n- Add tiny delay after writing to BFL Change BFL errors to something more human\nreadable Send work busy re-tries after 10ms delay\n- Fix race condition in thread creation that could under some conditions crash\nBFGMiner at startup\n\n\nBFGMiner Version 2.4.4 - July 1, 2012\n\n- Fix builds on non gnu platforms.\n- api.c ensure old mode is always available when not using --api-groups + quit()\non param errors\n- Implement rudimentary X-Mining-Hashrate support.\n- Detect large swings in temperature when below the target temperature range and\nchange fan by amounts dependant on the value of tdiff.\n- Adjust the fanspeed by the magnitude of the temperature difference when in the\noptimal range.\n- Revert \"Restarting cgminer from within after ADL has been corrupted only leads\nto a crash. Display a warning only and disable fanspeed monitoring.\"\n- api.c fix json already closed\n- implement and document API option --api-groups\n- Put upper bounds to under 2 hours that work can be rolled into the future for\nbitcoind will deem it invalid beyond that.\n- define API option --api-groups\n- api.c allow unwell devices to be enabled so they can be cured\n- miner.php - fix/enable autorefresh for custom pages\n- miner.php allow custom summary pages - new 'Mobile' summary\n- Work around pools that advertise very low expire= time inappropriately as this\nleads to many false positives for stale shares detected.\n- Only show ztex board count if any exist.\n- There is no need for work to be a union in struct workio_cmd\n- fpgautils.c include a debug message for all unknown open errors\n- Don't keep rolling work right up to the expire= cut off. Use 2/3 of the time\nbetween the scantime and the expiry as cutoff for reusing work.\n- Log a specific error when serial opens fail due to lack of user permissions\n- Increase GPU timing resolution to microsecond and add sanity check to ensure\ntimes are positive.\n- Opencl code may start executing before the clfinish order is given to it so\nget the start timing used for dynamic intensity from before the kernel is\nqueued.\n- fpgautils.c - set BAUD rate according to termio spec\n- fpgautils.c - linux ordering back to the correct way\n- miner.php remove unneeded '.'s\n- miner.php add auto refresh options\n- miner.php add 'restart' next to 'quit'\n- miner.php make fontname/size configurable with myminer.php\n- Make the pools array a dynamically allocated array to allow unlimited pools to\nbe added.\n- Make the devices array a dynamically allocated array of pointers to allow\nunlimited devices.\n- Dynamic intensity for GPUs should be calculated on a per device basis. Clean\nup the code to only calculate it if required as well.\n- Bugfix: Provide alternative to JSON_ENCODE_ANY for Jansson 1.x\n- Use a queueing bool set under control_lock to prevent multiple calls to\nqueue_request racing.\n- Use the work clone flag to determine if we should subtract it from the total\nqueued variable and provide a subtract queued function to prevent looping over\nlocked code.\n- Don't decrement staged extras count from longpoll work.\n- Count longpoll's contribution to the queue.\n- Increase queued count before pushing message.\n- Test we have enough work queued for pools with and without rolltime\ncapability.\n- As work is sorted by age, we can discard the oldest work at regular intervals\nto keep only 1 of the newest work items per mining thread.\n- Roll work again after duplicating it to prevent duplicates on return to the\nclone function.\n- Abstract out work cloning and clone $mining_threads copies whenever a rollable\nwork item is found and return a clone instead.\n- api.c display Pool Av in json\n- Take into account average getwork delay as a marker of pool communications\nwhen considering work stale.\n- Work out a rolling average getwork delay stored in pool_stats.\n- Getwork delay in stats should include retries for each getwork call.\n- Walk through the thread list instead of searching for them when disabling\nthreads for dynamic mode.\n- Extend nrolltime to support the expiry= parameter. Do this by turning the\nrolltime bool into an integer set to the expiry time. If the pool supports\nrolltime but not expiry= then set the expiry time to the standard scantime.\n- When disabling fanspeed monitoring on adl failure, remove any twin GPU\nassociation. This could have been leading to hangs on machines with dual GPU\ncards when ADL failed.\n- modminer: Don't delay 2nd+ FPGAs during work restart\n- Disable OpenCL code when not available.\n- Fix openwrt crashing on regeneratehash() by making check_solve a noop.\n- Fix sign warning.\n- Bugfix: icarus: properly store/restore info and work end times across longpoll\nrestarts\n- Enable modminer for release builds\n\n\nBFGMiner Version 2.4.3 - June 14, 2012\n\n- Change device API \"name\" to reflect driver name abbreviation instead of device type name\n- miner.php allow a separate user settings file\n- modminer: Implement extended device stats to expose each Board to the RPC API\n- Bugfix: Use new cgpu->thr for longpoll waking\n- bitforce: Remove 4.5s delay before polling starts, since MiniRig finishes sooner\n- FPGA - allow device detect override without an open failure\n- Bugfix: Missing printf value in merge from cgminer\n- Ensure C compiler is in C99 mode\n- Add CPU core count detection for BSD/Mac\n- Set CPU mining idle priority on Windows\n- can_roll and should_roll should have no bearing on the cycle period within the\nminer_thread so remove it.\n- Check for strategy being changed to load balance when enabling LPs.\n- Check that all threads on the device that called get_work are waiting on\ngetwork before considering the pool lagging.\n- Iterate over each thread belonging to each device in the hashmeter instead of\nsearching for them now that they're a list.\n- When using rotate pool strategy, ensure we only select from alive enabled\npools.\n- Start longpoll from every pool when load balance strategy is in use.\n- Add mandatory and block fields to the work struct. Flag any shares that are\ndetected as blocks as mandatory to submit, along with longpoll work from a\npreviously rejecting pool.\n- Consider the fan optimal if fanspeed is dropping but within the optimal speed\nwindow.\n- Fix typo in some API messages (succeess/success)\n- api.c MMQ stat bugs\n- Bugfix: Fix warnings when built without libudev support\n- Bugfix: slay a variety of warnings\n- Bugfix: modminer: Fix unsigned/signed comparison and similar warnings\n- API add ModMinerQuad support\n- Bugfix: Honour forceauto parameter in serial_detect functions\n- modminer: Temperature sensor improvements\n- modminer: Make log messages more consistent in format\n- Only adjust GPU speed up if the fanspeed is within the normal fanrange and\nhasn't been turned to maximum speed under overheat conditions.\n- ModMiner use valid .name\n- New driver: BTCFPGA ModMiner\n- Abstract generally useful FPGA code into fpgautils.c\n- API add stats for pool getworks\n- miner.php option to hide specific fields from the display\n- miner.php add version numbers to the summary page\n- Update debian configs to v2.4.2\n- Add API and FPGA READMEs into Makefile to be included in source distribution.\n- Icarus - fix unit64_t printf warnings\n\n\nBFGMiner Version 2.4.2 - June 2, 2012\n\n- Use epoll to immediately interrupt Icarus with new work on longpolls (Linux)\n- API.class compiled with Java SE 6.0_03 - works with Win7x64\n- miner.php highlight devs too slow finding shares (possibly failing)\n- API update version to V1.11 and document changes\n- API save default config file if none specified\n- api.c save success incorrectly returns error\n- api.c replace BUFSIZ (linux/windows have different values)\n- Move RPC API content out of README to API-README\n- Open a longpoll connection if a pool is in the REJECTING state as it's the\nonly way to re-enable it automatically.\n- Use only one longpoll as much as possible by using a pthread conditional\nbroadcast that each longpoll thread waits on and checks if it's the current pool\nbefore\n- If shares are known stale, don't use them to decide to disable a pool for\nsequential rejects.\n- Restarting cgminer from within after ADL has been corrupted only leads to a\ncrash. Display a warning only and disable fanspeed monitoring.\n- Icarus: fix abort calculation/allow user specified abort\n- Icarus: make --icarus-timing hidden and document it in FPGA-README\n- Icarus: high accuracy timing and other bitstream speed support\n- add-MIPSEB-to-icarus-for-BIG_ENDIAN\n- work_decode only needs swab32 on midstate under BIG ENDIAN\n- add compile command to api-example.c\n- save config bugfix: writing an extra ',' when no gpus\n- Add dpkg-source commits\n\n\nBFGMiner Version 2.4.1 - May 6, 2012\n\n- Icarus: Calibrate hashrate yet even more accurately\n- In the unlikely event of finding a block, display the block solved count with\nthe pool it came from for auditing.\n- Display the device summary on exit even if a device has been disabled.\n- Use correct pool enabled enums in api.c.\n- Import Debian packaging configs\n- Ensure we test for a pool recovering from idle so long as it's not set to\ndisabled.\n- Fix pool number display.\n- Give BFGMiner -T message only if curses is in use.\n- Reinit_adl is no longer used.\n- API 'stats' allow devices to add their own stats also for testing/debug\n- API add getwork stats to BFGMiner - accesable from API 'stats'\n- Don't initialise variables to zero when in global scope since they're already\ninitialised.\n- Get rid of unitialised variable warning when it's false.\n- Move a pool to POOL_REJECTING to be disabled only after 3 minutes of\ncontinuous rejected shares.\n- Some tweaks to reporting and logging.\n- API support new pool status\n- Add a temporarily disabled state for enabled pools called POOL_REJECTING and\nuse the work from each longpoll to help determine when a rejecting pool has\nstarted working again. Switch pools based on the multipool strategy once a pool\nis re-enabled.\n- Removing extra debug\n- Fix the benchmark feature by bypassing the new networking code.\n- Reset sequential reject counter after a pool is disabled for when it is\nre-enabled.\n- ztex updateFreq was always reporting on fpga 0\n- Trying harder to get 1.15y working\n- Specifying threads on multi fpga boards extra cgpu\n- Missing the add cgpu per extra fpga on 1.15y boards\n- API add last share time to each pool\n- Don't try to reap curls if benchmarking is enabled.\n\n\nBFGMiner Version 2.4.0 - May 3, 2012\n\n- Only show longpoll warning once when it has failed.\n- Convert hashes to an unsigned long long as well.\n- Detect pools that have issues represented by endless rejected shares and\ndisable them, with a parameter to optionally disable this feature.\n- Bugfix: Use a 64-bit type for hashes_done (miner_thread) since it can overflow\n32-bit on some FPGAs\n- Implement an older header fix for a label existing before the pthread_cleanup\nmacro.\n- Limit the number of curls we recruit on communication failures and with\ndelaynet enabled to 5 by maintaining a per-pool curl count, and using a pthread\nconditional that wakes up when one is returned to the ring buffer.\n- Generalise add_pool() functions since they're repeated in add_pool_details.\n- Bugfix: Return failure, rather than quit, if BFwrite fails\n- Disable failing devices such that the user can attempt to re-enable them\n- Bugfix: thread_shutdown shouldn't try to free the device, since it's needed\nafterward\n- API bool's and 1TBS fixes\n- Icarus - minimise code delays and name timer variables\n- api.c V1.9 add 'restart' + redesign 'quit' so thread exits cleanly\n- api.c bug - remove extra ']'s in notify command\n- Increase pool watch interval to 30 seconds.\n- Reap curls that are unused for over a minute. This allows connections to be\nclosed, thereby allowing the number of curl handles to always be the minimum\nnecessary to not delay networking.\n- Use the ringbuffer of curls from the same pool for submit as well as getwork\nthreads. Since the curl handles were already connected to the same pool and are\nimmediately available, share submission will not be delayed by getworks.\n- Implement a scaleable networking framework designed to cope with any sized\nnetwork requirements, yet minimise the number of connections being reopened. Do\nthis by create a ring buffer linked list of curl handles to be used by getwork,\nrecruiting extra handles when none is immediately available.\n- There is no need for the submit and getwork curls to be tied to the pool\nstruct.\n- Do not recruit extra connection threads if there have been connection errors\nto the pool in question.\n- We should not retry submitting shares indefinitely or we may end up with a\nhuge backlog during network outages, so discard stale shares if we failed to\nsubmit them and they've become stale in the interim.\n\n\nBFGMiner Version 2.3.6 - April 29, 2012\n\n- Shorten stale share messages slightly.\n- Protect the freeing of current_hash under mutex_lock to prevent racing on it\nwhen set_curblock is hit concurrently.\n- Change default behaviour to submitting stale, removing the --submit-stale\noption and adding a --no-submit-stale option.\n- Make sure to start the getwork and submit threads when a pool is added on the\nfly. This fixes a crash when a pool is added to running BFGMiner and then\nswitched to.\n- Faster hardware can easily outstrip the speed we can get work and submit\nshares when using only one connection per pool.\n- Test the queued list to see if any get/submits are already queued and if they\nare, start recruiting extra connections by generating new threads.\n- This allows us to reuse network connections at low loads but recuit new open\nconnections as they're needed, so that BFGMiner can scale to hardware of any\nsize.\n\n\nBFGMiner Version 2.3.5 - April 28, 2012\n\n- Restarting BFGMiner leads to a socket that can't be bound for 60 seconds, so\nincrease the interval that API binding waits to 30 seconds to minimise the\nnumber of times it will retry, spamming the logs.\n- Give a longpoll message for any longpoll that detects a block change, primary\nor backup, and also display which pool it was.\n- Decrease utility display to one decimal place.\n- Small cosmetic output alignment.\n- Add pool number to stale share message.\n- Add space to log output now that there is more screen real estate available.\n- Indentation clean up.\n- Remove thread id display from rejected shares as well.\n- Merge pull request #185 from Diapolo/diakgcn\n- add goffset support for diakgcn with -v 1 and update kernel version\n- Set have_longpoll to true when there is at least one pool with longpoll.\n- Don't display the thread ID since it adds no useful information over the\ndevice number.\n- Don't display the first 8 bytes of a share since they will always be zero at\n>= 1 difficulty.\n- work->longpoll is reset across test_work_current so we need to recheck what\npool it belongs to.\n- Use longpolls from backup pools with failover-only enabled just to check for\nblock changes, but don't use them as work.\n- Start longpoll only after we have tried to extract the longpoll URL.\n- Check for submitold flag on resubmit of shares, and give different message for\nstale shares on retry.\n- Check for submitold before submitstale.\n- Don't force fresh curl connections on anything but longpoll threads.\n- Create one longpoll thread per pool, using backup pools for those pools that\ndon't have longpoll.\n- Use the work created from the longpoll return only if we don't have\nfailover-enabled, and only flag the work as a longpoll if it is the current\npool.\n- This will work around the problem of trying to restart the single longpoll\nthread on pool changes that was leading to race conditions.\n- It will also have less work restarts from the multiple longpolls received from\ndifferent pools.\n- Remove the invalid entries from the example configuration file.\n- Add support for latest ATI SDK on windows.\n- Export missing function from libztex.\n- miner.php change socktimeoutsec = 10 (it only waits once)\n- Bugfix: Make initial_args a const char** to satisfy exec argument type warning\n(on Windows only)\n- miner.php add a timeout so you don't sit and wait ... forever\n- Create discrete persistent submit and get work threads per pool, thus allowing\nall submitworks belonging to the same pool to reuse the same curl handle, and\nall getworks to reuse their own handle.\n- Use separate handles for submission to not make getwork potentially delay\nshare submission which is time critical.\n- This will allow much more reusing of persistent connections instead of opening\nnew ones which can flood routers.\n- This mandated a rework of the extra longpoll support (for when pools are\nswitched) and this is managed by restarting longpoll cleanly and waiting for a\nthread join.\n- miner.php only show the current date header once\n- miner.php also add current time like single rig page\n- miner.php display rig 'when' table at top of the multi-rig summary page\n- README - add some Ztex details\n- api.c include zTex in the FPGA support list\n- api.c ensure 'devs' shows PGA's when only PGA code is compiled\n- miner.c sharelog code consistency and compile warning fix\n- README correct API version number\n- README spelling error\n- api.c combine all pairs of sprintfs()\n- api.c uncomment and use BLANK (and COMMA)\n- Code style cleanup\n- Annotating frequency changes with the changed from value\n- README clarification of 'notify' command\n- README update for API RPC 'devdetails'\n- api.c 'devdetails' list static details of devices\n- Using less heap space as my TP-Link seems to not handle this much\n\n\nBFGMiner Version 2.3.4 - April 26, 2012\n\n- New maintainership of code with modular FPGA/GPU focus, under BFGMiner name\n- Complete working support for cross-compiling Windows builds on Linux.\n- Fix usage of low --scan-time settings so it doesn't busy-loop\n- JSON API: Add new 'devdetail' command to get fixed device information\n- JSON API: Implement driver abstraction for extra device status\n- Icarus: Use epoll to wait for serial port input properly, when available\n- Icarus: Workaround buggy USB-UART that causes Icarus to stop mining rarely\n- Icarus: Estimate mining hashrate correctly, calibrated from real-world data\n- Icarus: Parallelize work setup with Icarus hash search improving performance\n- Icarus: More reliable detection and runtime\n- OpenCL: Move GPU-specific data fetching from JSON API to OpenCL driver\n- OpenCL: Dynamically load OpenCL library, to be more vendor-independent and\nallow use without actually having OpenCL (i.e. FPGA-only rigs).\n\n\nCGMiner Version 2.3.4 - April 25, 2012\n\n- Extensively document the cause of GPU device issues and the use of --gpu-map.\n- Support for share logging\n- Detect poorly performing combination of SDK and phatk kernel and add verbose\nwarning at startup.\n- Icarus update to new add_cgpu()\n- Icarus driver working with Linux and Windows\n- api.c fix unused variable compile warning\n- Display all OpenCL devices when -n is called as well to allow debugging of\ndifferential mapping of OpenCL to ADL.\n- Add a --gpu-map option which will allow arbitrarily mapping ADL devices to\nOpenCL devices for instances where association by enumeration alone fails.\n- Increase upper limit on number of extra items to queue as some FPGA code can't\nyet reliably keep many devices busy.\n- Display configuration file information when -c option is passed and only when\nfile exists on loading default config file.\n- Display configuration file loaded, if any, and debug output if configuration\nfile parsing failed.\n- Add missing ztex header to Makefile for distribution.\n- Document long-form COM port device names on Windows, required to specify\nserial ports above 9\n- Include ztex bitstreams firmware in distribution and install if configured in.\n- Style police on driver-ztex.c\n- work_restart should only be changed by cgminer.c now\n- Shut down the api cleanly when the api thread is cancelled. This should allow\nthe api socket to be closed successfully to next be reopened with app_restart.\n- Make a union for cgpu device handles, and rename \"device\" to \"device_ztex\"\nsince it's Ztex-specific\n- Initialise name variable.\n- Remove unnecessary check for variable that always has memory allocated.\n- Bugfix: Missing \"break\" no-op in default case\n- Make the status window and log window as large as can fit on startup,\nrechecking to see if it can be enlarged after the fact. This allows any number\nof devices to be displayed provided the window is made long enough without\ncorrupting the output.\n- Style police on libztex.c.\n- API add removepool like the screen interface\n- api.c escape required characters in return strings + pools returns the\nusername\n- Set lp_path to NULL after free for consistency.\n- Removing dmalloc import left behind by mistake\n- Fixing leak in resp_hdr_cb\n- miner.php warning highlight GPU stats if they are zero (e.g. ADL not enabled)\n- miner.php highlight any device that isn't 'Enabled'\n- miner.php highlight any Status that isn't 'Alive'\n- miner.php optionally support multiple rigs\n- Initial Ztex support 1.15x board.\n\n\nCGMiner Version 2.3.3 - April 15, 2012\n\n- Don't even display that cpumining is disabled on ./configure to discourage\npeople from enabling it.\n- Do a complete cgminer restart if the ATI Display Library fails, as it does on\nwindows after running for some time, when fanspeed reporting fails.\n- Cache the initial arguments passed to cgminer and implement an attempted\nrestart option from the settings menu.\n- Disable per-device status lines when there are more than 8 devices since\nscreen output will be corrupted, enumerating them to the log output instead at\nstartup.\n- Reuse Vals[] array more than W[] till they're re-initialised on the second\nsha256 cycle in poclbm kernel.\n- Minor variable alignment in poclbm kernel.\n- Make sure to disable devices with any status not being DEV_ENABLED to ensure\nthat thermal cutoff code works as it was setting the status to DEV_RECOVER.\n- Re-initialising ADL simply made the driver fail since it is corruption over\ntime within the windows driver that's responsible. Revert \"Attempt to\nre-initialise ADL should a device that previously reported fanspeed stops\nreporting it.\"\n- Microoptimise poclbm kernel by ordering Val variables according to usage\nfrequency.\n\n\nCGMiner Version 2.3.2 - March 31, 2012\n\n- Damping small changes in hashrate so dramatically has the tendency to always\nmake the hashrate underread so go back to gentle damping instead.\n- Revert the crossover of variables from Vals to W in poclbm kernel now that\nVals are the first declared variables so they're used more frequently.\n- Vals variables appearing first in the array in poclbm is faster.\n- Change the preferred vector width to 1 for Tahiti only, not all poclbm\nkernels.\n- Use a time constant 0.63 for when large changes in hashrate are detected to\ndamp change in case the large change is an aliasing artefact instead of a real\nchang\n- Only increment stale counter if the detected stales are discarded.\n- Attempt to re-initialise ADL should a device that previously reported fanspeed\nstops reporting it.\n- Move the ADL setup and clearing to separate functions and provide a reinit_adl\nfunction to be used when adl fails while running.\n- Use slightly more damping on the decay time function in the never-ending quest\nto smooth off the hashmeter.\n- Set the starting fanspeed to a safe and fairly neutral 50% when autofan is\nenabled.\n- Provide locking around updates of cgpu hashrates as well to prevent multiple\nthreads accessing data fields on the same device.\n- Display the beginning of the new block in verbose mode in the logs.\n- Reinstate old diablo kernel variable ordering from 120222, adding only goffset\nand vector size hint. The massive variable ordering change only helped one SDK\non\n- Change the version number on the correct kernels.\n- api.c devicecode/osinfo incorrectly swapped for json\n- Add extensive instructions on how to make a native windows build.\n- Update version numbers of poclbm and diablo kernels as their APIs have also\nchanged.\n- Use global offset parameter to diablo and poclbm kernel ONLY for 1 vector\nkernels.\n- Use poclbm preferentially on Tahiti now regardless of SDK.\n- Remove unused constant passed to poclbm.\n- Clean up use of macros in poclbm and use bitselect everywhere possible.\n- Add vector type hint to diablo kernel.\n- Add worksize and vector attribute hints to the poclbm kernel.\n- Spaces for non-aligned variables in poclbm.\n- Swap Vals and W variables where they can overlap in poclbm.\n- More tidying of poclbm.\n- Tidy up first half of poclbm.\n- Clean up use of any() by diablo and poclbm kernels.\n- Minor variable symmetry changes in poclbm.\n- Put additions on separate lines for consistency in poclbm.\n- Consolidate last use of W11 into Vals4 in poclbm.\n- Change email due to SPAM\n- api.c miner.php add a '*' to the front of all notify counters - simplifies\nfuture support of new counters\n- miner.php add display 'notify' command\n- Small change to help arch's without processor affinity\n- Fix bitforce compile error\n- api.c notify should report disabled devices also - of course\n- API returns the simple device history with the 'notify' command\n- code changes for supporting a simple device history\n- api.c Report an OS string in config to help with device issues\n- api.c fix Log Interval - integer in JSON\n- api.c config 'Device Code' to show list of compiled devices + README\n- api.c increase buffer size close to current code allowable limit\n- removed 8-component vector support from kernel, as this is not supported in\nCGMINER anyway\n- forgot to update kernel modification date, fixed ;)\n- reordered an addition in the kernel, which results in less instructions used\nin the GPU ISA code for GCN\n- miner.php: option for readonly or check privileged access\n- Ignore reduntant-with-build options --disable-gpu, --no-adl, and --no-restart\n- miner.php: ereg_replace is DEPRECATED so use preg_replace instead\n- Make curses TUI support optional at compile-time.\n- Bugfix: AC_ARG_WITH provides withval instead of enableval\n- miner.php split devs output for different devices\n- api.c: correct error messages\n- icarus.c modify (regular) timeout warning to only be debug\n- icarus.c set the windows TODO timeout\n- Allow specifying a specific driver for --scan-serial\n- optimized nonce-check and output code for -v 2 and -v 4\n- Bugfix: Check for libudev header (not just library) in configure, and document\noptional dependency\n- Add API support for Icarus and Bitforce\n- Next API version is 1.4 (1.3 is current)\n- README/api.c add \"When\" the request was processed to STATUS\n- Bugfix: ZLX to read BitFORCE temp, not ZKX -.-\n- Use libudev to autodetect BitFORCE GPUs, if available\n- Use the return value of fan_autotune to set fan_optimal instead of passing it\nas a pointer.\n- Pass the lasttemp from the device we're using to adjust fanspeed in twin\ndevices.\n- fix the name to 3 chars, fix the multi-icarus support\n- Bugfix: \"-S auto\" is the default if no -S is specified, and there is no such\ndelay in using it\n- README add information missing from --scan-serial\n- Update README RPC API Version comment\n- Bugfix: Allow enabling CPU even without OpenCL support\n- Change failed-to-mine number of requested shares messge to avoid segfault on\nrecursive calling of quit().\n- Get rid of extra char which is just truncated in poclbm kernel.\n- only small code formating changes\n- removed vec_step() as this could lead to errors on older SDKs\n- unified code for generating nonce in kernel and moved addition of base to the\nend -> faster\n\nCGMiner Version 2.3.1 - February 24, 2012\n\n- Revert input and output code on diakgcn and phatk kernels to old style which\nworked better for older hardware and SDKs.\n- Add a vector*worksize parameter passed to those kernels to avoid one op.\n- Increase the speed of hashrate adaptation.\n- Only send out extra longpoll requests if we want longpolls.\n- API implement addpool command\n- API return the untouched Total MH also (API now version 1.3)\n- Add enable/disablepool to miner.php example and reduce font size 1pt\n\n\nCGMiner Version 2.3.0 - February 23, 2012\n\n- Consider extra longpoll work items as staged_extra so as to make sure we queue\nmore work if queueing regular work items as longpolls.\n- Use diablo kernel on all future SDKs for Tahiti and set preferred vector width\nto 1 on poclbm kernel only.\n- Explicitly type the constants in diakgcn kernel as uint, to be in line with\npoclbm kernel.\n- Reset all hash counters at the same time as resetting start times to get\naccurate hashrates on exiting which is mandatory for benchmarking.\n- Report thread out before it starts to avoid being flagged as sick when waiting\nfor the first work item.\n- Don't disable and re-enable devices as they may recover and in the meantime\nhave their status set to OFF.\n- API new commands enablepool and disablepool (version already incremented)\n- Tolerate new-format temperature readings for bitforce\n- Modify cgminer.c pool control to allow API to call it\n- Bugfix: Fix BitFORCE driver memory leak in debug logging\n- Extra byte was being unused in poclbm leading to failure on some platforms.\n- Explicitly type the constants in poclbm kernel as uint.\n- Don't save 'include' when saving the configuration\n- Allow configuration file to include another recursively\n- Use the SDK and hardware information to choose good performing default\nkernels.\n- Move phatk kernel to offset vector based nonce bases as well.\n- Add a --benchmark feature which works on a fake item indefinitely to compare\ndevice performance without any server or networking influence.\n- Allow writing of multiple worksizes to the configuration file.\n- Allow writing of multiple vector sizes to the configuration file.\n- Allow writing of multiple kernels to the configuration file.\n- Allow multiple different kernels to be chosen per device.\n- Allow the worksize to be set per-device.\n- Allow different vectors to be set per device.\n- If we're well below the target temperature, increase gpu engine speed back to\nmaximum in case we have gotten lost between profiles during an idle period.\n- We should be setting the value of fan_optimal, not its address.\n- As all kernels will be new versions it's an opportunity to change the .bin\nformat and make it simpler. Specifying bitalign is redundant and long can be l.\n- Use any() in kernel output code.\n- Put the nonce for each vector offset in advance, avoiding one extra addition\nin the kernel.\n- Reset times after all mining threads are started to make estimating hashrates\neasier at startup.\n- Bugfix: allow no-exec (NX) stack\n- Fix minor warning.\n- fix the bitforce.c code style follow 1TBS\n- fix icarus.c compile warning\n- small changes to speedup no vec for AMD 898.1 OCL runtime\n- Update licensing to GPL V3.\n- Reset the longpoll flag after it's been used once to prevent it restarting\nwork again.\n- Begin import of DiabloMiner kernel.\n- Modify API debug messages to say API instead of DBG\n- When API shuts down cgminer don't kill itself\n- Don't make rolled work from the longpoll be seen as other longpoll work items.\n- API add 'privileged' command so can verify access level\n- Set the lp_sent variable under lock since there will almost always be a race\non setting this variable, potentially leading to multiple LPs being sent out.\n- API restrict access to all non display commands by default\n- Update API version to 1.2 for new 'Log Interval'\n- API add --log Interval to 'config' reply\n- --api-allow special case 0/0 means all\n\n\nCGMiner Version 2.2.7 - February 20, 2012\n\n- Send out extra longpolls when we have switched pools and the longpoll thread\nis still bound to the old one. This is particularly useful with p2pool where\nlongpolls do not correlate with main bitcoin block change and would have led to\nhigh reject rates on failover.\n- Store whether a work item is the result of a longpoll or not in struct work\nand use it to help determine block changes directly from the work longpoll bool.\n- Keep track of when a longpoll has been sent for a pool and if the current pool\nis requesting work but has not sent a longpoll request, convert one of the work\nitems to a longpoll.\n- Store the longpoll url in the pool struct and update it from the pool_active\ntest in case it changes. This is to allow further changes to longpoll management\non switching pools.\n- Re-check for a longpoll supporting pool every 30 seconds if none is found\ninitially.\n- Report threads as busy waiting on getwork on startup to avoid them being\nflagged sick on startup during slow networking.\n- Allow devices that are disabled due to overheating to be flagged as recovering\ninstead of disabling them and re-enable them if they're below ideal temperatures\n- Tahiti prefers worksize 64 with poclbm.\n- No need to expressly retain the opencl program now that the zero binary issue\nis fixed. This actually fixes cgminer to work with the latest SDK included with\nthe ATI catalyst driver 12.2.\n- Show error code on any opencl failure status.\n- Add detection for version 898.1 SDK as well but only give SDK 2.6 warning once\non startup instead of with each device initialisation.\n- Always use a fresh connection for longpoll as prolonged persistent connections\ncan fail for many reasons.\n- Keep track of intended engine clock speed and only adjust up if it's higher\nthan the last intended speed. This avoids setting the clock speed to one\nrelative to a lower profile one by mistake.\n- Use gpu-memdiff on startup if an engine clockspeed is set and a memdiff value\nis set.\n- Revert \"Adjust engine speed up according to performance level engine setting,\nnot the current engine speed.\" - ineffectual.\n- Freeze the queues on all threads that are sent the pause message to prevent\nthem trying to start up again with saved pings in their queues.\n- Updates to diakgcn kernel/\n- Consolidate all screen updates to the watchdog thread and touch both windows\nbefore refresh.\n- Curses will be disabled in clean_up so don't do it early in kill_work, and\ndisable_adl so that GPU settings may be restored to normal in case shutting down\ncurses leads to instability on windows.\n- Stop the mining threads before trying to kill them.\n- Plain refresh() does not give reliably screen updates so get rid of all uses\nof it.\n- First release with working diakgcn kernel.\n\nCGMiner Version 2.2.6 - February 16, 2012\n\n- Provide warning on each startup about sdk 2.6\n- Fix unused warnings on win32.\n- bitforce: Simplify BFopen WIN32 ifdef/else\n- Fix initialization warning with jansson 1.3\n- bitforce: Cleanup extraneous TODO that isn't needed\n- Move tcsetattr (and new tcflush) into *nix BFopen to simplify things a bit\n- Add message explaining 2nd thread disabling for dynamic mode and how to tune\nit.\n- Move logwindow down once number of devices is known.\n- Automatically choose phatk kernel for bitalign non-gcn ATI cards, and then\nonly select poclbm if SDK2.6 is detected.\n- Allow the refresh interval to be adjusted in dynamic intensity with a\n--gpu-dyninterval parameter.\n- Make curses display visible right from the beginning and fix the window sizes\nso the initial messages don't get lost once the status window is drawn.\n- The amount of work scanned can fluctuate when intensity changes and since we\ndo this one cycle behind, we increment the work more than enough to prevent\nrepeati\n- bitforce: Set a 30 second timeout for serial port on Windows, since the\ndefault is undefined\n- Use PreVal4addT1 instead of PreVal4 in poclbm kernel.\n- Import PreVal4 and PreVal0 into poclbm kernel.\n- Import more prepared constants into poclbm kernel.\n- Keep variables in one array but use Vals[] name for consistency with other\nkernel designs.\n- Replace constants that are mandatorily added in poclbm kernel with one value.\n- Remove addition of final constant before testing for result in poclbm kernel.\n- Hand optimise variable addition order.\n- Hand optimise first variable declaration order in poclbm kernel.\n- Radical reordering machine based first pass to change variables as late as\npossible, bringing their usage close together.\n- fix strcpy NULL pointer if env HOME unset.\n- bitforce: Disable automatic scanning when at least one device is specified\nmanually\n- Unroll all poclbm additions to enable further optimisations.\n\n\nCGMiner Version 2.2.5 - February 13, 2012\n\n- Make output buffer write only as per Diapolo's suggestion.\n- Constify nonce in poclbm.\n- Use local and group id on poclbm kernel as well.\n- Microoptimise phatk kernel on return code.\n- Adjust engine speed up according to performance level engine setting, not the\ncurrent engine speed.\n- Try to load a binary if we've defaulted to the poclbm kernel on SDK2.6\n- Use the poclbm kernel on SDK2.6 with bitalign devices only if there is no\nbinary available.\n- Further generic microoptimisations to poclbm kernel.\n- The longstanding generation of a zero sized binary appears to be due to the\nOpenCL library putting the binary in a RANDOM SLOT amongst 4 possible binary\nlocations. Iterate over each of them after building from source till the real\nbinary is found and use that.\n- Fix harmless warnings with -Wsign-compare to allow cgminer to build with -W.\n- Fix missing field initialisers warnings.\n- Put win32 equivalents of nanosleep and sleep into compat.h fixing sleep() for\nadl.c.\n- Restore compatibility with Jansson 1.3 and 2.0 (api.c required 2.1)\n- Modularized logging, support for priority based logging\n- Move CPU chipset specific optimization into device-cpu\n\n\nCGMiner Version 2.2.4 - February 11, 2012\n\n- Fix double definition of A0 B0 to zeroA zeroB.\n- Retain cl program after successfully loading a binary image. May decrease\nfailures to build kernels at startup.\n- Variable unused after this so remove setting it.\n- BFI INT patching is not necessarily true on binary loading of files and not\ntrue on ATI SDK2.6+. Report bitalign instead.\n- Various string fixes for reject reason.\n- Generalize --temp-cutoff and implement support for reading temperature from\nBitFORCE FPGAs\n- Change message from recovered to alive since it is used on startup as well as\nwhen a pool has recovered.\n- Start mining as soon as any pool is found active and rely on the watchpool\nthread to bring up other pools.\n- Delayed responses from testing pools that are down can hold up the watchdog\nthread from getting to its device testing code, leading to false detection of\nthe GPU not checking in, and can substantially delay auto gpu/auto fan\nmanagement leading to overheating. Move pool watching to its own thread.\n- Bugfix: BitFORCE index needs to be static to count correctly\n- Space out retrieval of extra work according to the number of mining threads.\n- Make shutdown more robust. Enable the input thread only after the other\nthreads exist. Don't kill off the workio thread and use it to exit main() only\nif there is an unexpected problem. Use kill_work() for all anticipated shutdowns\nwhere possible. Remove unused thread entry.\n- Change poclbm version number.\n- One array is faster than 2 separate arrays so change to that in poclbm kernel.\n- Microoptimisations to poclbm kernel which increase throughput slightly.\n- Import diablominer kernel. Currently disabled as not working.\n- Import diapolo kernel. Currently disabled as not working.\n- Conflicting entries of cl_kernel may have been causing problems, and\nautomatically chosen kernel type was not being passed on. Rename the enum to\ncl_kernels and store the chosen kernel in each clState.\n- Set cl_amd_media_ops with the BITALIGN flag and allow non-bitselect devices to\nbuild.\n- ALlow much longer filenames for kernels to load properly.\n- Allow different kernels to be used by different devices and fix the logic fail\nof overcorrecting on last commit with !strstr.\n- Fix kernel selection process and build error.\n- queue_phatk_kernel now uses CL_SET_VARG() for base-nonce(s), too\n- added OpenCL >= 1.1 detection code, in preparation of OpenCL 1.1 global offset\nparameter support\n- Use K array explicitly to make it clear what is being added.\n- Work items have a tendency to expire at exactly the same time and we don't\nqueue extra items when there are plenty in the queue, regardless of age. Allow\nextra work items to be queued if adequate time has passed since we last\nrequested work even if over the limit.\n- Discard work when failover-only is enabled and the work has come from a\ndifferent pool.\n- Missing include to build on newer mingw32.\n- Move from the thread safe localtime_r to regular localtime which is the only\none supported on newer pthread libraries on mingw32 to make it compile with the\nnewer ming. Thread safety is of no importance where localtime is used in this\ncode.\n- Define in_addr_t in windows if required\n- sys/wait.h not required in windows\n- Allow API to restrict access by IP address\n- Add pool switching to example miner.php\n- Display X-Reject-Reason, when provided\n- Remove the test for whether the device is on the highest profil level before\nraising the GPU speed as it is ineffectual and may prevent raising the GPU\nspeed.\n- Remove unnecessary check for opt_debug one every invocation of applog at\nLOG_DEBUG level and place the check in applog().\n\n\nCGMiner Version 2.2.3 - February 6, 2012\n\n- Revert \"Rewrite the convoluted get_work() function to be much simpler and roll\nwork as much as possible with each new work item.\" This seems to cause a race on\nwork in free_work(). Presumably other threads are still accessing the structure.\n\n\nCGMiner Version 2.2.2 - February 6, 2012\n\n- Provide support for the submitold extension on a per-pool basis based on the\nvalue being detected in a longpoll.\n- Don't send a ping to a dynamic device if it's not enabled as that will just\nenable it for one pass and then disable it again.\n- Rewrite the convoluted get_work() function to be much simpler and roll work as\nmuch as possible with each new work item.\n- Roll as much work as possible from the work returned from a longpoll.\n- Rolling work on each loop through the mining thread serves no purpose.\n- Allow to stage more than necessary work items if we're just rolling work.\n- Replace divide_work with reuse_work function used twice.\n- Give rolled work a new ID to make sure there is no confusion in the hashtable\nlookups.\n- Remove now-defunct hash_div variables.\n- Remove unused get_dondata function.\n- Silence ADL warnings.\n- Silence unused parameter warnings.\n- Stagger the restart of every next thread per device to keep devices busy ahead\nof accessory threads per device.\n- Deprecate the --donation feature. Needlessly complex, questionable usefulness,\ndepends on author's server and a central pool of some kind, and was not heavily\nadopted.\n- It's devices that report back now, not threads, update message.\n- Continue auto-management of fan and engine speeds even if a device is disabled\nfor safety reasons.\n- No need to check we're highest performance level when throttling GPU engine\nspeed.\n- Abstract out tests for whether work has come from a block that has been seen\nbefore and whether a string is from a previously seen block.\n- Probe but don't set the timeout to 15 seconds as some networks take a long\ntime to timeout.\n- Remove most compiler warnings from api.c\n- Add last share's pool info in cgpu_info\n- Allow the OpenCL platform ID to be chosen with --gpu-platform.\n- Iterate over all platforms displaying their information and number of devices\nwhen --ndevs is called.\n- Deprecate main.c\n- Some networks can take a long time to resolve so go back to 60 second timeouts\ninstead of 15.\n- Only enable curses on failure if curses is desired.\n- Fix warnings in bitforce.c\n- Bugfix: Need to open BitForce tty for read-write\n- Fix various build issues.\n- Modularize code: main.c -> device-cpu + device-gpu\n- Fix phatk kernel not working on non-bitalign capable devices (Nvidia, older\nATI).\n- Update poclbm kernel for better performance on GCN and new SDKs with bitalign\nsupport when not BFI INT patching. Update phatk kernel to work properly for non\nBFI INT patched kernels, providing support for phatk to run on GCN and non-ATI\ncards.\n- Return last accepted share pool/time for devices\n- Display accepted share pool/time for CPUs\n- Bug intensity always shows GPU 0\n- Update example web miner.php to use new API commands\n\n\nCGMiner Version 2.2.1 - January 30, 2012\n\nNOTE - The GPU Device reordering in 2.2.0 by default was considered a bad idea\nso the original GPU ordering is used by default again unless reordering is\nexplicitly requested.\n\n- Fix bitforce failing to build into cgminer.\n- Add missing options to write config function.\n- Add a --gpu-reorder option to only reorder devices according to PCI Bus ID\nwhen requested.\n- Fix for midstate support being broken on pools that supported no-midstate\nwork by ensuring numbers are 32 bits in sha2.c\n- Set virtual GPUs to work when ADL is disabled or all mining will occur on GPU\n0.\n- Add information about paused threads in the menu status.\n- Disable all but the first thread on GPUs in dynamic mode for better\ninteractivity.\n- Set the latest network access time on share submission for --net-delay even if\nwe're not delaying that submission for further network access.\n- Clear adl on exiting after probing values since it may attempt to overclock.\n- As share submission is usually staggered, and delays can be costly, submit\nshares without delay even when --net-delay is enabled.\n- Display GPU number and device name when ADL is successfully enabled on it.\n- Display GPU ordering remapping in verbose mode.\n- Don't fail in the case the number of ADL and OpenCL devices do not match, and\ndo not attempt to reorder devices unless they match. Instead give a warning\nabout\n- Display error codes should ADL not return ADL_OK in the more critical function\ncalls.\n- Fix unused warning.\n- Fix compile warnings in api.c\n- Add extensive ADL based device info in debug mode.\n- Make --ndevs display verbose opencl information as well to make debugging\nversion information easier.\n- Display information about the opencl platform with verbose enabled.\n- Explicitly check for nvidia in opencl platform strings as well.\n\n\nCGMiner Version 2.2.0 - January 29, 2012\n\nNOTE: GPU Device order will change with this release with ATI GPUs as cgminer\nnow can enumerate them according to their Bus ID which means the values should\nnow correlate with their physical position on the motherboard.\n\n- Default to poclbm kernel on Tahiti (7970) since phatk does not work, even\nthough performance is sub-standard so that at least it will mine successfully by\ndefau\n- Retain cl program after every possible place we might build the program.\n- Update ADL SDK URL.\n- Fix potential overflow.\n- Map GPU devices to virtual devices in their true physical order based on\nBusNumber.\n- Change the warning that comes with failure to init cl on a device to be more\ngeneric and accurate.\n- Advertise longpoll support in X-Mining-Extensions\n- Detect dual GPU cards by iterating through all GPUs, finding ones without\nfanspeed and matching twins with fanspeed one bus ID apart.\n- Do not attempt to build the program that becomes the kernel twice. This could\nhave been leading to failures on initialising cl.\n- Some opencl compilers have issues with no spaces after -D in the compiler\noptions.\n- Allow intensity up to 14.\n- Use calloced stack memory for CompilerOptions to ensure sprintf writes to the\nbeginning of the char.\n- Whitelist 79x0 cards to prefer no vectors as they perform better without.\n- Adjust fan speed gently while in the optimal range when temperature is\ndrifting to minimise overshoot in either direction.\n- Detect dual GPU cards via the indirect information of - 1st card has a fan\ncontroller. 2nd card does not have a fan controller, cards share the same device\nname\n- Instead of using the BFI_INT patching hack on any device reporting\ncl_amd_media_ops, create a whitelist of devices that need it. This should enable\nGCN architec\n- Fixed API compiling issue on OS X\n- Add more explanation of JSON format and the 'save' command\n- Return an error if using ADL API commands when it's not available\n- Read off lpThermalControllerInfo from each ADL device.\n- Add ADL_Overdrive5_ThermalDevices_Enum interface.\n- Add API commands: config, switchpool, gpu settings, save\n- Implement socks4 proxy support.\n- Fix send() for JSON strings\n- Introduce a --net-delay option which guarantees at least 250ms between any\nnetworking requests to not overload slow routers.\n- Generalise locking init code.\n- Allow invalid values to be in the configuration file, just skipping over them\nprovided the rest of the file is valid JSON. This will allow older configurat\n- Allow CPU mining explicitly enable only if other mining support is built in.\n- BitForce FPGA support\n- Configure out building and support of all CPU mining code unless\n--enable-cpumining is enabled.\n- Allow parsed values to be zero which will allow 0 values in the config file to\nwork.\n- Advertise that we can make our own midstate, so the pool can skip generating\nit for us\n- Refactor the CPU scanhash_* functions to use a common API. Fixes bugs.\n- Don't consider a pool lagging if a request has only just been filed. This\nshould decrease the false positives for \"pool not providing work fast enough\".\n- Invalidating work after longpoll made hash_pop return no work giving a false\npositive for dead pool. Rework hash_pop to retry while finds no staged work u\n- Remove TCP_NODELAY from curl options as many small packets may be contributing\nto network overload, when --net-delay is enabled.\n- Refactor miner_thread to be common code for any kind of device\n- Simplify submit_nonce loop and avoid potentially missing FOUND - 1 entry.\nReported by Luke-Jr.\n- Micro-optimisation in sha256_sse2 code courtesy of Guido Ascioti\nguido.ascioti@gmail.com\n- Refactor to abstract device-specific code\n\n\nCGMiner Version 2.1.2 - January 6, 2012\n\n- If api-description is specified, save it when writing the config file\n- Adjust utility width to be constant maximum as well.\n- Add percent signs to reject ratio outputs\n- Should the donation pool fail, don't make the fallover pool behave as though\nthe primary pool is lagging.\n- Use an alternative pool should the donation getwork fail.\n\n\nCGMiner Version 2.1.1 - January 1, 2012\n\n- Include API examples in distribution tarball.\n- Don't attempt to pthread_join when cancelling threads as they're already\ndetached and doing so can lead to a segfault.\n- Give more generic message if slow pool at startup is the donation pool.\n- Continue to attempt restarting GPU threads if they're flagged dead at 1 min.\nintervals.\n- Don't attempt to restart sick flagged GPUs while they're still registering\nactivity.\n- Make curl use fresh connections whenever there is any communication issue\nin case there are dead persistent connections preventing further comms from\nworking.\n- Display pool in summary if only 1 pool.\n- Adjust column width of A/R/HW to be the maximum of any device and align them.\n\n\nCGMiner Version 2.1.0 - December 27, 2011\n\n- Major infrastructure upgrade with RPC interface for controlling via sockets\nencoded with/without JSON courtesy of Andrew Smith. Added documentation for\nuse of the API and sample code to use with it.\n- Updated linux-usb-cgminer document.\n- Rewrite of longpoll mechanism to choose the current pool wherever possible to\nuse for the longpoll, or any pool that supports longpoll if the current one\ndoes not.\n- Display information about longpoll when the chosen server has changed.\n- Fix the bug where longpoll generated work may have been sent back to the\nwrong pool, causing rejects.\n- Fix a few race conditions on closing cgminer which caused some of the crashes\non exit.\n- Only adjust gpu engine speed in autotune mode if the gpu is currently at the\nperformance level of that being adjusted.\n- Various fixes for parsing/writing of configuration files.\n- Do not add blank lines for threads of unused CPUs.\n- Show which pool is unresponsive on startup.\n- Only show GPU management menu item if GPUs are in use.\n- Align most device columns in the curses display.\n\n\nCGMiner Version 2.0.8 - November 11, 2011\n\n- Make longpoll do a mandatory flushing of all work even if the block hasn't\nchanged, thus supporting longpoll initiated work change of any sort and merged\nmining.\n- Byteswap computed hash in hashtest so it can be correctly checked. This fixes\nthe very rare possibility that a block solve on solo mining was missed.\n- Add x86_64 w64 mingw32 target\n- Allow a fixed speed difference between memory and GPU clock speed with\n--gpu-memdiff that will change memory speed when GPU speed is changed in\nautotune mode.\n- Don't load the default config if a config file is specified on the command\nline.\n- Don't build VIA on apple since -a auto bombs instead of gracefully ignoring\nVIA failing.\n- Build fix for dlopen/dlclose errors in glibc.\n\n\nCGMiner Version 2.0.7 - October 17, 2011\n\n- Support work without midstate or hash1, which are deprecated in bitcoind 0.5+\n- Go to kernel build should we fail to clCreateProgramWithBinary instead of\nfailing on that device. This should fix the windows problems with devices not\ninitialising.\n- Support new configuration file format courtesy of Chris Savery which can write\nthe config file from the menu and will load it on startup.\n- Write unix configuration to .cgminer/cgminer.conf by default and prompt to\noverwrite if given a filename from the menu that exists.\n\n\nCGMiner Version 2.0.6 - October 9, 2011\n\n- Must initialise the donorpool mutex or it fails on windows.\n- Don't make donation work interfere with block change detection allowing\ndonation to work regardless of the block chain we're mining on.\n- Expire shares as stale with a separate timeout from the scantime, defaulting\nto 120 seconds.\n- Retry pools after a delay of 15 seconds if none can be contacted on startup\nunless a key is pressed.\n- Don't try to build adl features without having adl.\n- Properly check shares against target difficulty - This will no longer show\nshares when solo mining at all unless they're considered to be a block solve.\n- Add altivec 4 way (cpu mining) support courtesy of Gilles Risch.\n- Try to use SSL if the server supports it.\n- Display the total solved blocks on exit (LOL if you're lucky).\n- Use ADL activity report to tell us if a sick GPU is still busy suggesting it\nis hard hung and do not attempt to restart it.\n\n\nCGMiner Version 2.0.5 - September 27, 2011\n\n- Intensity can now be set to dynamic or static values per-device.\n- New donation feature --donation sends a proportion of shares to author's\naccount of choice, but is disabled by default!\n- The hash being displayed and block detection has been fixed.\n- Devices not being mined on will not attempt to be ADL managed.\n- Intensity is now displayed per GPU device.\n- Make longpoll attempt to restart as often as opt_retries specifies.\n- We weren't rolling work as often as we could.\n- Correct some memory management issues.\n- Build fixes.\n- Don't mess with GPUs if we don't have them.\n\n\nCGMiner Version 2.0.4 - September 23, 2011\n\n- Confused Longpoll messages should be finally fixed with cgminer knowing for\nsure who found the new block and possibly avoiding a rare crash.\n- Display now shows the actual hash and will say BLOCK! if a block is deemed\nsolved.\n- Extra spaces, which would double space lines on small terminals, have been\nremoved.\n- Fan speed change is now damped if it is already heading in the correct\ndirection to minimise overshoot.\n- Building without opencl libraries is fixed.\n- GPUs are autoselected if there is only one when in the GPU management menu.\n- GPU menu is refreshed instead of returning to status after a GPU change.\n\n\nCGMiner Version 2.0.3 - September 17, 2011\n\n- Various modes of failure to set fanspeeds and adl values have been addressed\nand auto-fan should work now on most hardware, and possibly other values\nwhich previously would not have worked.\n- Fixed a crash that can occur on switching pools due to longpoll thread races.\n- Use ATISTREAMSDKROOT if available at build time.\n- Fanspeed management is returned to the driver default on exit instead of\nwhatever it was when cgminer was started.\n- Logging of events deemed WARNING or ERR now will display even during\nperiods where menu input is being awaited on.\n\n\nCGMiner Version 2.0.2 - September 11, 2011\n\n- Exit cleanly if we abort before various threads are set up or if they no\nlonger exist.\n- Fix a rare crash in HASH_DEL due to using different mutexes to protect the\ndata.\n- Flag devices that have never started and don't allow enabling of devices\nwithout restarting them.\n- Only force the adapter speed to high if we've flagged this device as being\nmanaged.\n- Flag any devices with autofan or autogpu as being managed.\n- Use a re-entrant value to store what fanspeed we're trying to set in case the\ncard doesn't support small changes.     Force it to a multiple of 10% if it\nfails on trying to speed up the fan.\n- Do not bother resetting values to old ones if changes to GPU parameters report\nfailure, instead returning a failure code only if the return value from get()\ndiffers.\n- Remove redundant check.\n- Only display supported values from fanspeed on change settings.\n- Missing bracket from output.\n- Display fan percentage on devices that only support reporting percent and not\nRPM.\n- Properly substitute DLOPEN flags to build with ADL support when -ldl is needed\nand not when opencl is not found.\n\n\nCGMiner Version 2.0.1 - September 9, 2011\n\n- Fix building on 32bit glibc with dlopen with -lpthread and -ldl\n- ByteReverse is not used and the bswap opcode breaks big endian builds. Remove\nit.\n- Ignore whether the display is active or not since only display enabled devices\nwork this way, and we skip over repeat entries anwyay.\n- Only reset values on exiting if we've ever modified them.\n- Flag adl as active if any card is successfully activated.\n- Add a thermal cutoff option as well and set it to 95 degrees by default.\n- Change the fan speed by only 5% if it's over the target temperature but less\nthan the hysteresis value to minimise overshoot down in temperature.\n- Add a --no-adl option to disable ADL monitoring and GPU settings.\n- Only show longpoll received delayed message at verbose level.\n- Allow temperatures greater than 100 degrees.\n- We should be passing a float for the remainder of the vddc values.\n- Implement accepting a range of engine speeds as well to allow a lower limit to\nbe specified on the command line.\n- Allow per-device fan ranges to be set and use them in auto-fan mode.\n- Display which GPU has overheated in warning message.\n- Allow temperature targets to be set on a per-card basis on the command line.\n- Display fan range in autofan status.\n- Setting the hysteresis is unlikely to be useful on the fly and doesn't belong\nin the per-gpu submenu.\n- With many cards, the GPU summaries can be quite long so use a terse output\nline when showing them all.\n- Use a terser device status line to show fan RPM as well when available.\n- Define max gpudevices in one macro.\n- Allow adapterid 0 cards to enumerate as a device as they will be non-AMD\ncards, and enable ADL on any AMD card.\n- Do away with the increasingly confusing and irrelevant total queued and\nefficiency measures per device.\n- Only display values in the log if they're supported and standardise device log\nline printing.\n\n\nCGMiner Version 2.0.0 - September 6, 2011\n\nMajor feature upgrade - GPU monitoring, (over)clocking and fan control for ATI\nGPUs.\n\nNew command line switches:\n--auto-fan-     Automatically adjust all GPU fan speeds to maintain a target\ntemperature\n--auto-gpu-     Automatically adjust all GPU engine clock speeds to maintain\na target temperature\n--gpu-engine <arg>  Set the GPU engine (over)clock in Mhz - one value for all or\nseparate by commas for per card.\n--gpu-fan <arg>     Set the GPU fan percentage - one value for all or separate\nby commas for per card.\n--gpu-memclock <arg> Set the GPU memory (over)clock in Mhz - one value for all\nor separate by commas for per card.\n--gpu-powertune <arg> Set the GPU powertune percentage - one value for all or\nseparate by commas for per card.\n--gpu-vddc <arg>    Set the GPU voltage in Volts - one value for all or separate\nby commas for per card.\n--temp-hysteresis <arg> Set how much the temperature can fluctuate outside\nlimits when automanaging speeds (default: 3)\n--temp-overheat <arg> Set the overheat temperature when automatically managing\nfan and GPU speeds (default: 85)\n--temp-target <arg> Set the target temperature when automatically managing fan\nand GPU speeds (default: 75)\n\n- Implement ATI ADL support for GPU parameter monitoring now and setting later\n(temp, fan, clocks etc.).\n- Check for the presence of the ADL header files in ADL_SDK.\n- Import adl_functions.h from amd overdrive ctrl.\n- Implement a setup function that tries to detect GPUs that support the ADL and\nlink in the parameters into the gpus struct.\n- Put a summary of monitoring information from the GPU menu.\n- Implement changing memory speed and voltage on the fly.\n- Implement fan speed setting.\n- Minor corrections to set fan speed by percentage.\n- Make sure to read off the value in RPM only.\n- Implement auto fanspeed adjustment to maintain a target temperature and\nfanspeed below 85%, with an overheat check that will speed the fan up to 100%.\n- Add an --auto-fan command line option to allow all GPUs to have autofan\nenabled from startup.\n- Add a gpu autotune option which adjusts GPU speed to maintain a target\ntemperature within the bounds of the default GPU speed and any overclocking set.\n- Avoid a dereference if the longpoll thread doesn't exist.\n- Clean up by setting performance profiles and fan settings to startup levels on\nexit.\n- Add a small amount of hysteresis before lowering clock speed.\n- Allow target, overheat and hysteresis temperatures to be set from command\nline.\n- Combine all stats collating into one function to avoid repeating function\ncalls on each variable.\n- Add gpu statistics to debugging output via the watchdog thread.\n- Implement menus to change temperature limits.\n- Implement setting the GPU engine clock speed of all devices or each device as\na comma separated value.\n- Implement setting the GPU memory clock speed of all devices or each device as\na comma separated value.\n- Implement setting the GPU voltage of all devices or each device as a comma\nseparated value.\n- Implement setting the GPU fan speed of all devices or each device as a comma\nseparated value.\n- Add support for monitoring powertune setting.\n- Implement changing of powertune value from the GPU change settings menu.\n- Get the value of powertune in get_stats.\n- Implement setting the GPU powertune value of all devices or each device as a\ncomma separated value.\n- Remove the safety checks in speed setting since confirmation is done first in\nthe menu, then show the new current values after a short pause.\n- Force the speed to high on startup and restore it to whatever the setting was\non exit.\n- Add temperature to standard output where possible and use more compact output.\n- Move and print at the same time in curses to avoid random trampling display\nerrors.\n- Update the status window only from the watchdog thread, do not rewrite the top\nstatus messages and only refresh once all the status window is complete,\nclearing the window each time to avoid corruption.\n- Set a safe starting fan speed if we're automanaging the speeds.\n- Provide locking around all adl calls to prevent races.\n- Lower profile settings cannot be higher than higher profile ones so link any\ndrops in settings.\n- Add new needed text files to distribution.\n- Queue requests ignoring the number of staged clones since they get discarded\nvery easily leading to false positives for pool not providing work fast enough.\n- Include libgen.h in opt.c to fix win32 compilation warnings.\n- Fix compilation warning on win32.\n- Add the directory name from the arguments cgminer was called from as well to\nallow it running from a relative pathname.\n- Add a --disable-adl option to configure and only enable it if opencl support\nexists.\n- Retry before returning a failure to get upstream work as a failure to avoid\nfalse positives for pool dead.\n- Retry also if the decoding of work fails.\n- Use the presence of X-Roll-Ntime in the header as a bool for exists unless N\nis found in the response.\n\n\nCGMiner Version 1.6.2 - September 2, 2011\n\n- Add --failover-only option to not leak work to backup pools when the primary\npool is lagging.\n- Change recommendation to intensity 9 for dedicated miners.\n- Fix the bouncing short term value by allowing it to change dynamically when\nthe latest value is very different from the rolling value, but damp the change\nwhen it gets close.\n- Use the curses_lock to protect the curses_active variable and test it under\nlock.\n- Go back to requesting work 2/3 of the way through the current scantime with\nCPU mining as reports of mining threads running out of work have occurred with\nonly 5 seconds to retrieve work.\n- Add start and stop time scheduling for regular time of day running or once off\nstart/stop options.\n- Print summary on quit modes.\n- Put some sanity checks on the times that can be input.\n- Give a verbose message when no active pools are found and pause before\nexiting.\n- Add verbose message when a GPU fails to initialise, and disable the correct\nGPU.\n- Cryptopp asm32 was not correctly updated to the incremental nonce code so the\nhash counter was bogus.\n- Get rid of poorly executed curl check.\n- If curl does not have sockopts, do not try to compile the\njson_rpc_call_sockopt_cb function, making it possible to build against older\ncurl libraries.\n- Most people expect /usr/local when an unspecified prefix is used so change to\nthat.\n- Rename localgen occasions to getwork fail occasions since localgen is\nunrelated now.\n\n\nCGMiner Version 1.6.1 - August 29, 2011\n\n- Copy cgminer path, not cat it.\n- Switching between redrawing windows does not fix the crash with old\nlibncurses, so redraw both windows, but only when the window size hasn't\nchanged.\n- Reinstate minimum 1 extra in queue to make it extremely unlikely to ever have\n0 staged work items and any idle time.\n- Return -1 if no input is detected from the menu to prevent it being\ninterpreted as a 0.\n- Make pthread, libcurl and libcurses library checks mandatory or fail.\n- Add a --disable-opencl configure option to make it possible to override\ndetection of opencl and build without GPU mining support.\n- Confusion over the variable name for number of devices was passing a bogus\nvalue which likely was causing the zero sized binary issue.\n- cgminer no longer supports default url user and pass so remove them.\n- Don't show value of intensity since it's dynamic by default.\n- Add options to explicitly enable CPU mining or disable GPU mining.\n- Convert the opt queue into a minimum number of work items to have queued\ninstead of an extra number to decrease risk of getting idle devices without\nincreasing risk of higher rejects.\n- Statify tv_sort.\n- Check for SSE2 before trying to build 32 bit SSE2 assembly version. Prevents\nbuild failure when yasm is installed but -msse2 is not specified.\n- Add some defines to configure.ac to enable exporting of values and packaging,\nand clean up output.\n- Give convenient summary at end of ./configure.\n- Display version information and add --version command line option, and make\nsure we flush stdout.\n- Enable curses after the mining threads are set up so that failure messages\nwon't be lost in the curses interface.\n- Disable curses after inputting a pool if we requested no curses interface.\n- Add an option to break out after successfully mining a number of accepted\nshares.\n- Exit with a failed return code if we did not reach opt_shares.\n- The cpu mining work data can get modified before we copy it if we submit it\nasync, and the sync submission is not truly sync anyway, so just submit it sync.\n\n\nCGMiner Version 1.6.0 - August 26, 2011\n\n- Make restarting of GPUs optional for systems that hang on any attempt to\nrestart them.     Fix DEAD status by comparing it to last live time rather than\nlast attempted restart time since that happens every minute.\n- Move staged threads to hashes so we can sort them by time.\n- Create a hash list of all the blocks created and search them to detect when a\nnew block has definitely appeared, using that information to detect stale work\nand discard it.\n- Update configure.ac for newer autoconf tools.\n- Use the new hashes directly for counts instead of the fragile counters\ncurrently in use.\n- Update to latest sse2 code from cpuminer-ng.\n- Allow LP to reset block detect and block detect lp flags to know who really\ncame first.\n- Get start times just before mining begins to not have very slow rise in\naverage.\n- Add message about needing one server.\n- We can queue all the necessary work without hitting frequent stales now with\nthe time and string stale protection active all the time.     This prevents a\npool being falsely labelled as not providing work fast enough.\n- Include uthash.h in distro.\n- Implement SSE2 32 bit assembly algorithm as well.\n- Fail gracefully if unable to open the opencl files.\n- Make cgminer look in the install directory for the .cl files making make\ninstall work correctly.\n- Allow a custom kernel path to be entered on the command line.\n- Bump threshhold for lag up to maximum queued but no staged work.\n- Remove fragile source patching for bitalign, vectors et. al and simply pass it\nwith the compiler options.\n- Actually check the value returned for the x-roll-ntime extension to make sure\nit isn't saying N.\n- Prevent segfault on exit for when accessory threads don't exist.\n- Disable curl debugging with opt protocol since it spews to stderr.\n\n\nCGMiner Version 1.5.8 - August 23, 2011\n\n- Minimise how much more work can be given in cpu mining threads each interval.\n- Make the fail-pause progressively longer each time it fails until the network\nrecovers.\n- Only display the lagging message if we've requested the work earlier.\n- Clean up the pool switching to not be dependent on whether the work can roll\nor not by setting a lagging flag and then the idle flag.\n- Only use one thread to determine if a GPU is sick or well, and make sure to\nreset the sick restart attempt time.\n- The worksize was unintentionally changed back to 4k by mistake, this caused a\nslowdown.\n\n\nCGMiner Version 1.5.7 - August 22, 2011\n\n- Fix a crash with --algo auto\n- Test at appropriate target difficulty now.\n- Add per-device statics log output with --per-device-stats\n- Fix breakage that occurs when 1 or 4 vectors are chosen on new phatk.\n- Make rolltime report debug level only now since we check it every work\nitem.\n- Add the ability to enable/disable per-device stats on the fly and match\nlogging on/off.\n- Explicitly tell the compiler to retain the program to minimise the chance of\nthe zero sized binary errors.\n- Add one more instruction to avoid one branch point in the common path in the\ncl return code. Although this adds more ALUs overall and more branch points, the\ncommon path code has the same number of ALUs and one less jmp, jmps being more\nexpensive.\n- Explicitly link in ws2_32 on the windows build and update README file on how\nto compile successfully on windows.\n- Release cl resources should the gpu mining thread abort.\n- Attempt to restart a GPU once every minute while it's sick.\n- Don't kill off the reinit thread if it fails to init a GPU but returns safely.\n- Only declare a GPU dead if there's been no sign of activity from the reinit\nthread for 10 mins.\n- Never automatically disable any pools but just specify them as idle if they're\nunresponsive at startup.\n- Use any longpoll available, and don't disable it if switching to a server that\ndoesn't have it. This allows you to mine solo, yet use the longpoll from a pool\neven if the pool is the backup server.\n- Display which longpoll failed and don't free the ram for lp_url since it\nbelongs to the pool hdr path.\n- Make the tcp setsockopts unique to linux in the hope it allows freebsd et. al\nto compile.\n\n\nCGMiner Version 1.5.6 - August 17, 2011\n\n- New phatk and poclbm kernels. Updated phatk to be in sync with latest 2.2\ncourtesy of phateus. Custom modified to work best with cgminer.\n- Updated output buffer code to use a smaller buffer with the kernels.\n- Clean up the longpoll management to ensure the right paths go to the right\npool and display whether we're connected to LP or not in the status line.\n\n\nCGMiner Version 1.5.5 - August 16, 2011\n\n- Rework entirely the GPU restart code. Strike a balance between code that\nre-initialises the GPU entirely so that soft hangs in the code are properly\nmanaged, but if a GPU is completely hung, the thread restart code fails\ngracefully, so that it does not take out any other code or devices. This will\nallow cgminer to keep restarting GPUs that can be restarted, but continue\nmining even if one or more GPUs hangs which would normally require a reboot.\n- Add --submit-stale option which submits all shares, regardless of whether they\nwould normally be considered stale.\n- Keep options in alphabetical order.\n- Probe for slightly longer for when network conditions are lagging.\n- Only display the CPU algo when we're CPU mining.\n- As we have keepalives now, blaming network flakiness on timeouts appears to\nhave been wrong.     Set a timeout for longpoll to 1 hour, and most other\nnetwork connectivity to 1 minute.\n- Simplify output code and remove HW errors from CPU stats.\n- Simplify code and tidy output.\n- Only show cpu algo in summary if cpu mining.\n- Log summary at the end as per any other output.\n- Flush output.\n- Add a linux-usb-cgminer guide courtesy of Kano.\n\n\nCGMiner Version 1.5.4 - August 14, 2011\n\n- Add new option: --monitor <cmd> Option lets user specify a command <cmd> that\nwill get forked by cgminer on startup. cgminer's stderr output subsequently gets\npiped directly to this command.\n- Allocate work from one function to be able to initialise variables added\nlater.\n- Add missing fflush(stdout) for --ndevs and conclusion summary.\n- Preinitialise the devices only once on startup.\n- Move the non cl_ variables into the cgpu info struct to allow creating a new\ncl state on reinit, preserving known GPU variables.\n- Create a new context from scratch in initCQ in case something was corrupted to\nmaximise our chance of succesfully creating a new worker thread. Hopefully this\nmakes thread restart on GPU failure more reliable, without hanging everything\nin the case of a completely wedged GPU.\n- Display last initialised time in gpu management info, to know if a GPU has\nbeen re-initialised.\n- When pinging a sick cpu, flush finish and then ping it in a separate thread in\nthe hope it recovers without needing a restart, but without blocking code\nelsewhere.\n- Only consider a pool lagging if we actually need the work and we have none\nstaged despite queue requests stacking up. This decreases significantly the\namount of work that leaks to the backup pools.\n- The can_roll function fails inappropriately in stale_work.\n- Only put the message that a pool is down if not pinging it every minute. This\nprevents cgminer from saying pool down at 1 minute intervals unless in debug\nmode.\n- Free all work in one place allowing us to perform actions on it in the future.\n- Remove the extra shift in the output code which was of dubious benefit. In\nfact in cgminer's implementation, removing this caused a miniscule speedup.\n- Test each work item to see if it can be rolled instead of per-pool and roll\nwhenever possible, adhering to the 60 second timeout. This makes the period\nafter a longpoll have smaller dips in throughput, as well as requiring less\ngetworks overall thus increasing efficiency.\n- Stick to rolling only work from the current pool unless we're in load balance\nmode or lagging to avoid aggressive rolling imitating load balancing.\n- If a work item has had any mining done on it, don't consider it discarded\nwork.\n\n\nCGMiner Version 1.5.3 - July 30, 2011\n\n- Significant work went into attempting to make the thread restart code robust\nto identify sick threads, tag them SICK after 1 minute, then DEAD after 5\nminutes of inactivity and try to restart them. Instead of re-initialising the\nGPU completely, only a new cl context is created to avoid hanging the rest of\nthe GPUs should the dead GPU be hung irrevocably.\n- Use correct application name in syslog.\n- Get rid of extra line feeds.\n- Use pkg-config to check for libcurl version\n- Implement per-thread getwork count with proper accounting to not over-account\nqueued items when local work replaces it.\n- Create a command queue from the program created from source which allows us\nto flush the command queue in the hope it will not generate a zero sized binary\nany more.\n- Be more willing to get work from the backup pools if the work is simply being\nqueued faster than it is being retrieved.\n\n\nCGMiner Version 1.5.2 - July 28, 2011\n\n- Restarting a hung GPU can hang the rest of the GPUs so just declare it dead\nand provide the information in the status.\n- The work length in the miner thread gets smaller but doesn't get bigger if\nit's under 1 second.     This could end up leading to CPU under-utilisation and\nlower and lower hash rates.     Fix it by increasing work length if it drops\nunder 1 second.\n- Make the \"quiet\" mode still update the status and display errors, and add a\nnew --real-quiet option which disables all output and can be set once while\nrunning.\n- Update utility and efficiency figures when displaying them.\n- Some Intel HD graphics support the opencl commands but return errors since\nthey don't support opencl. Don't fail with them, just provide a warning and\ndisable GPU mining.\n- Add http:// if it's not explicitly set for URL entries.\n- Log to the output file at any time with warnings and errors, instead of just\nwhen verbose mode is on.\n- Display the correct current hash as per blockexplorer, truncated to 16\ncharacters, with just the time.\n\n\nCGMiner Version 1.5.1 - July 27, 2011\n\n- Two redraws in a row cause a crash in old libncurses so just do one redraw\nusing the main window.\n- Don't adjust hash_div only up for GPUs. Disable hash_div adjustment for GPUs.\n- Only free the thread structures if the thread still exists.\n- Update both windows separately, but not at the same time to prevent the double\nrefresh crash that old libncurses has.     Do the window resize check only when\nabout to redraw the log window to minimise ncurses cpu usage.\n- Abstract out the decay time function and use it to make hash_div a rolling\naverage so it doesn't change too abruptly and divide work in chunks large enough\nto guarantee they won't overlap.\n- Sanity check to prove locking.\n- Don't take more than one lock at a time.\n- Make threads report out when they're queueing a request and report if they've\nfailed.\n- Make cpu mining work submission asynchronous as well.\n- Properly detect stale work based on time from staging and discard instead of\nhanding on, but be more lax about how long work can be divided for up to the\nscantime.\n- Do away with queueing work separately at the start and let each thread grab\nits own work as soon as it's ready.\n- Don't put an extra work item in the queue as each new device thread will do so\nitself.\n- Make sure to decrease queued count if we discard the work.\n- Attribute split work as local work generation.\n- If work has been cloned it is already at the head of the list and when being\nreinserted into the queue it should be placed back at the head of the list.\n- Dividing work is like the work is never removed at all so treat it as such.\nHowever the queued bool needs to be reset to ensure we *can* request more work\neven if we didn't initially.\n- Make the display options clearer.\n- Add debugging output to tq_push calls.\n- Add debugging output to all tq_pop calls.\n\n\nCGMiner Version 1.5.0 - July 26, 2011\n\n- Increase efficiency of slow mining threads such as CPU miners dramatically. Do\nthis by detecting which threads cannot complete searching a work item within the\nscantime and then divide up a work item into multiple smaller work items.\nDetect the age of the work items and if they've been cloned before to prevent\ndoing the same work over. If the work is too old to be divided, then see if it\ncan be time rolled and do that to generate work. This dramatically decreases the\nnumber of queued work items from a pool leading to higher overall efficiency\n(but the same hashrate and share submission rate).\n- Don't request work too early for CPUs as CPUs will scan for the full\nopt_scantime anyway.\n- Simplify gpu management enable/disable/restart code.\n- Implement much more accurate rolling statistics per thread and per gpu and\nimprove accuracy of rolling displayed values.\n- Make the rolling log-second average more accurate.\n- Add a menu to manage GPUs on the fly allowing you to enable/disable GPUs or\ntry restarting them.\n- Keep track of which GPUs are alive versus enabled.\n- Start threads for devices that are even disabled, but don't allow them to\nstart working.\n- The last pool is when we are low in total_pools, not active_pools.\n- Make the thread restart do a pthread_join after disabling the device, only\nre-enabling it if we succeed in restarting the thread. Do this from a separate\nthread so as to not block any other code.This will allow cgminer to continue\neven if one GPU hangs.\n- Try to do every curses manipulation under the curses lock.\n- Only use the sockoptfunction if the version of curl is recent enough.\n\n\nCGMiner Version 1.4.1 - July 24, 2011\n\n- Do away with GET for dealing with longpoll forever. POST is the one that works\neverywhere, not the other way around.\n- Detect when the primary pool is lagging and start queueing requests on backup\npools if possible before needing to roll work.\n- Load balancing puts more into the current pool if there are disabled pools.\nFix.\n- Disable a GPU device should the thread fail to init.\n- Out of order command queue may fail on osx. Try without if it fails.\n- Fix possible dereference on blank inputs during input_pool.\n- Defines missing would segfault on --help when no sse mining is built in.\n- Revert \"Free up resources/stale compilers.\" - didn't help.\n- Only try to print the status of active devices or it would crash.\n- Some hardware might benefit from the less OPS so there's no harm in leaving\nkernel changes that do that apart from readability of the code.\n\nCGMiner Version 1.4.0 - July 23, 2011\n\n- Feature upgrade: Add keyboard input during runtime to allow modification of\nand viewing of numerous settings such as adding/removing pools, changing\nmultipool management strategy, switching pools, changing intensiy, verbosity,\netc. with a simple keypress menu system.\n- Free up resources/stale compilers.\n- Kernels are safely flushed in a way that allows out of order execution to\nwork.\n- Sometimes the cl compiler generates zero sized binaries and only a reboot\nseems to fix it.\n- Don't try to stop/cancel threads that don't exist.\n- Only set option to show devices and exit if built with opencl support.\n- Enable curses earlier and exit with message in main for messages to not be\nlost in curses windows.\n- Make it possible to enter server credentials with curses input if none are\nspecified on the command line.\n- Abstract out a curses input function and separate input pool function to allow\nfor live adding of pools later.\n- Remove the nil arguments check to allow starting without parameters.\n- Disable/enable echo & cbreak modes.\n- Add a thread that takes keyboard input and allow for quit, silent, debug,\nverbose, normal, rpc protocol debugging and clear screen options.\n- Add pool option to input and display current pool status, pending code to\nallow live changes.\n- Add a bool for explicit enabling/disabling of pools.\n- Make input pool capable of bringing up pools while running.\n- Do one last check of the work before submitting it.\n- Implement the ability to live add, enable, disable, and switch to pools.\n- Only internally test for block changes when the work matches the current pool\nto prevent interleaved block change timing on multipools.\n- Display current pool management strategy to enable changing it on the fly.\n- The longpoll blanking of the current_block data may not be happening before\nthe work is converted and appears to be a detected block change.     Blank the\ncurrent block be\n- Make --no-longpoll work again.\n- Abstract out active pools count.\n- Allow the pool strategy to be modified on the fly.\n- Display pool information on the fly as well.\n- Add a menu and separate out display options.\n- Clean up the messy way the staging thread communicates with the longpoll\nthread to determine who found the block first.\n- Make the input windows update immediately instead of needing a refresh.\n- Allow log interval to be set in the menu.\n- Allow scan settings to be modified at runtime.\n- Abstract out the longpoll start and explicitly restart it on pool change.\n- Make it possible to enable/disable longpoll.\n- Set priority correctly on multipools.     Display priority and alive/dead\ninformation in display_pools.\n- Implement pool removal.\n- Limit rolltime work generation to 10 iterations only.\n- Decrease testing log to info level.\n- Extra refresh not required.\n- With huge variation in GPU performance, allow intensity to go from -10 to +10.\n- Tell getwork how much of a work item we're likely to complete for future\nsplitting up of work.\n- Remove the mandatory work requirement at startup by testing for invalid work\nbeing passed which allows for work to be queued immediately.     This also\nremoves the requirem\n- Make sure intensity is carried over to thread count and is at least the\nminimum necessary to work.\n- Unlocking error on retry. Locking unnecessary anyway so remove it.\n- Clear log window from consistent place. No need for locking since logging is\ndisabled during input.\n- Cannot print the status of threads that don't exist so just queue enough work\nfor the number of mining threads to prevent crash with -Q N.\n- Update phatk kernel to one with new parameters for slightly less overhead\nagain.     Make the queue kernel parameters call a function pointer to select\nphatk or poclbm.\n- Make it possible to select the choice of kernel on the command line.\n- Simplify the output part of the kernel. There's no demonstrable advantage from\nmore complexity.\n- Merge pull request #18 from ycros/cgminer\n- No need to make leaveok changes win32 only.\n- Build support in for all SSE if possible and only set the default according to\nmachine capabilities.\n- Win32 threading and longpoll keepalive fixes.\n- Win32: Fix for mangled output on the terminal on exit.\n\n\nCGMiner Version 1.3.1 - July 20, 2011\n\n- Feature upgrade; Multiple strategies for failover. Choose from default which\nnow falls back to a priority order from 1st to last, round robin which only\nchanges pools when one is idle, rotate which changes pools at user-defined\nintervals, and load-balance which spreads the work evenly amongst all pools.\n- Implement pool rotation strategy.\n- Implement load balancing algorithm by rotating requests to each pool.\n- Timeout on failed discarding of staged requests.\n- Implement proper flagging of idle pools, test them with the watchdog thread,\nand failover correctly.\n- Move pool active test to own function.\n- Allow multiple strategies to be set for multipool management.\n- Track pool number.\n- Don't waste the work items queued on testing the pools at startup.\n- Reinstate the mining thread watchdog restart.\n- Add a getpoll bool into the thread information and don't restart threads stuck\nwaiting on work.\n- Rename the idlenet bool for the pool for later use.\n- Allow the user/pass userpass urls to be input in any order.\n- When json rpc errors occur they occur in spits and starts, so trying to limit\nthem with the comms error bool doesn't stop a flood of them appearing.\n- Reset the queued count to allow more work to be queued for the new pool on\npool switch.\n\nCGMiner Version 1.3.0 - July 19, 2011\n\n- Massive infrastructure update to support pool failover.\n- Accept multiple parameters for url, user and pass and set up structures of\npool data accordingly.\n- Probe each pool for what it supports.\n- Implement per pool feature support according to rolltime support as\nadvertised by server.\n- Do switching automatically based on a 300 second timeout of locally generated\nwork or 60 seconds of no response from a server that doesn't support rolltime.\n- Implement longpoll server switching.\n- Keep per-pool data and display accordingly.\n- Make sure cgminer knows how long the pool has actually been out for before\ndeeming it a prolonged outage.\n- Fix bug with ever increasing staged work in 1.2.8 that eventually caused\ninfinite rejects.\n- Make warning about empty http requests not show by default since many\nservers do this regularly.\n\n\nCGMiner Version 1.2.8 - July 18, 2011\n\n- More OSX build fixes.\n- Add an sse4 algorithm to CPU mining.\n- Fix CPU mining with other algorithms not working.\n- Rename the poclbm file to ensure a new binary is built since.\n- We now are guaranteed to have one fresh work item after a block change and we\nshould only discard staged requests.\n- Don't waste the work we retrieve from a longpoll.\n- Provide a control lock around global bools to avoid racing on them.\n- Iterating over 1026 nonces when confirming data from the GPU is old code\nand unnecessary and can lead to repeats/stales.\n- The poclbm kernel needs to be updated to work with the change to 4k sized\noutput buffers.\n- longpoll seems to work either way with post or get but some servers prefer\nget so change to httpget.\n\n\nCGMiner Version 1.2.7 - July 16, 2011\n\n- Show last 8 characters of share submitted in log.\n- Display URL connected to and user logged in as in status.\n- Display current block and when it was started in the status line.\n- Only pthread_join the mining threads if they exist as determined by\npthread_cancel and don't fail on pthread_cancel.\n- Create a unique work queue for all getworks instead of binding it to thread 0\nto avoid any conflict over thread 0's queue.\n- Clean up the code to make it clear it's watchdog thread being messaged to\nrestart the threads.\n- Check the current block description hasn't been blanked pending the real\nnew current block data.\n- Re-enable signal handlers once the signal has been received to make it\npossible to kill cgminer if it fails to shut down.\n- Disable restarting of CPU mining threads pending further investigation.\n- Update longpoll messages.\n- Add new block data to status line.\n- Fix opencl tests for osx.\n- Only do local generation of work if the work item is not stale itself.\n- Check for stale work within the mining threads and grab new work if\npositive.\n- Test for idle network conditions and prevent threads from being restarted\nby the watchdog thread under those circumstances.\n- Make sure that local work generation does not continue indefinitely by\nstopping it after 10 minutes.\n- Tweak the kernel to have a shorter path using a 4k buffer and a mask on the\nnonce value instead of a compare and loop for a shorter code path.\n- Allow queue of zero and make that default again now that we can track how\nwork is being queued versus staged. This can decrease reject rates.\n- Queue precisely the number of mining threads as longpoll_staged after a\nnew block to not generate local work.\n\n\nCGMiner Version 1.2.6 - July 15, 2011\n\n- Put a current system status line beneath the total work status line\n- Fix a counting error that would prevent cgminer from correctly detecting\nsituations where getwork was failing - this would cause stalls sometimes\nunrecoverably.\n- Limit the maximum number of requests that can be put into the queue which\notherwise could get arbitrarily long during a network outage.\n- Only count getworks that are real queue requests.\n\n\nCGMiner Version 1.2.5 - July 15, 2011\n\n- Conflicting -n options corrected\n- Setting an intensity with -I disables dynamic intensity setting\n- Removed option to manually disable dynamic intensity\n- Improve display output\n- Implement signal handler and attempt to clean up properly on exit\n- Only restart threads that are not stuck waiting on mandatory getworks\n- Compatibility changes courtesy of Ycros to build on mingw32 and osx\n- Explicitly grab first work item to prevent false positive hardware errors\ndue to working on uninitialised work structs\n- Add option for non curses --text-only output\n- Ensure we connect at least once successfully before continuing to retry to\nconnect in case url/login parameters were wrong\n- Print an executive summary when cgminer is terminated\n- Make sure to refresh the status window\n\nCGMiner Versions -> 1.2.4\n\n- Con Kolivas - July 2011. New maintainership of code under cgminer name.\n- Massive rewrite to incorporate GPU mining.\n- Incorporate original oclminer c code.\n- Rewrite gpu mining code to efficient work loops.\n- Implement per-card detection and settings.\n- Implement vector code.\n- Implement bfi int patching.\n- Import poclbm and phatk ocl kernels and use according to hardware type.\n- Implement customised optimised versions of opencl kernels.\n- Implement binary kernel generation and loading.\n- Implement preemptive asynchronous threaded work gathering and pushing.\n- Implement variable length extra work queues.\n- Optimise workloads to be efficient miners instead of getting lots of extra\n  work.\n- Implement total hash throughput counters, per-card accepted, rejected and\n  hw error count.\n- Staging and watchdog threads to prevent fallover.\n- Stale and reject share guarding.\n- Autodetection of new blocks without longpoll.\n- Dynamic setting of intensity to maintain desktop interactivity.\n- Curses interface with generous statistics and information.\n- Local generation of work (xroll ntime) when detecting poor network\nconnectivity.\n\ncpuminer Version 1.0.2\n\n- Linux x86_64 optimisations - Con Kolivas\n- Optimise for x86_64 by default by using sse2_64 algo\n- Detects CPUs and sets number of threads accordingly\n- Uses CPU affinity for each thread where appropriate\n- Sets scheduling policy to lowest possible\n- Minor performance tweaks\n\ncpuminer Version 1.0.1 - May 14, 2011\n\n- OSX support\n\ncpuminer Version 1.0 - May 9, 2011\n\n- jansson 2.0 compatibility\n- correct off-by-one in date (month) display output\n- fix platform detection\n- improve yasm configure bits\n- support full URL, in X-Long-Polling header\n\ncpuminer Version 0.8.1 - March 22, 2011\n\n- Make --user, --pass actually work\n\n- Add User-Agent HTTP header to requests, so that server operators may\n  more easily identify the miner client.\n\n- Fix minor bug in example JSON config file\n\ncpuminer Version 0.8 - March 21, 2011\n\n- Support long polling: http://deepbit.net/longpolling.php\n\n- Adjust max workload based on scantime (default 5 seconds,\n  or 60 seconds for longpoll)\n\n- Standardize program output, and support syslog on Unix platforms\n\n- Suport --user/--pass options (and \"user\" and \"pass\" in config file),\n  as an alternative to the current --userpass\n\ncpuminer Version 0.7.2 - March 14, 2011\n\n- Add port of ufasoft's sse2 assembly implementation (Linux only)\n  This is a substantial speed improvement on Intel CPUs.\n\n- Move all JSON-RPC I/O to separate thread.  This reduces the\n  number of HTTP connections from one-per-thread to one, reducing resource\n  usage on upstream bitcoind / pool server.\n\ncpuminer Version 0.7.1 - March 2, 2011\n\n- Add support for JSON-format configuration file.  See example\n  file example-cfg.json.  Any long argument on the command line\n  may be stored in the config file.\n- Timestamp each solution found\n- Improve sha256_4way performance.  NOTE: This optimization makes\n  the 'hash' debug-print output for sha256_way incorrect.\n- Use __builtin_expect() intrinsic as compiler micro-optimization\n- Build on Intel compiler\n- HTTP library now follows HTTP redirects\n\ncpuminer Version 0.7 - February 12, 2011\n\n- Re-use CURL object, thereby reuseing DNS cache and HTTP connections\n- Use bswap_32, if compiler intrinsic is not available\n- Disable full target validation (as opposed to simply H==0) for now\n\ncpuminer Version 0.6.1 - February 4, 2011\n\n- Fully validate \"hash < target\", rather than simply stopping our scan\n  if the high 32 bits are 00000000.\n- Add --retry-pause, to set length of pause time between failure retries\n- Display proof-of-work hash and target, if -D (debug mode) enabled\n- Fix max-nonce auto-adjustment to actually work.  This means if your\n  scan takes longer than 5 seconds (--scantime), the miner will slowly\n  reduce the number of hashes you work on, before fetching a new work unit.\n\ncpuminer Version 0.6 - January 29, 2011\n\n- Fetch new work unit, if scanhash takes longer than 5 seconds (--scantime)\n- BeeCee1's sha256 4way optimizations\n- lfm's byte swap optimization (improves via, cryptopp)\n- Fix non-working short options -q, -r\n\ncpuminer Version 0.5 - December 28, 2010\n\n- Exit program, when all threads have exited\n- Improve JSON-RPC failure diagnostics and resilience\n- Add --quiet option, to disable hashmeter output.\n\ncpuminer Version 0.3.3 - December 27, 2010\n\n- Critical fix for sha256_cryptopp 'cryptopp_asm' algo\n\ncpuminer Version 0.3.2 - December 23, 2010\n\n- Critical fix for sha256_via\n\ncpuminer Version 0.3.1 - December 19, 2010\n\n- Critical fix for sha256_via\n- Retry JSON-RPC failures (see --retry, under \"minerd --help\" output)\n\ncpuminer Version 0.3 - December 18, 2010\n\n- Add crypto++ 32bit assembly implementation\n- show version upon 'minerd --help'\n- work around gcc 4.5.x bug that killed 4way performance\n\ncpuminer Version 0.2.2 - December 6, 2010\n\n- VIA padlock implementation works now\n- Minor build and runtime fixes\n\ncpuminer Version 0.2.1 - November 29, 2010\n\n- avoid buffer overflow when submitting solutions\n- add Crypto++ sha256 implementation (C only, ASM elided for now)\n- minor internal optimizations and cleanups\n\ncpuminer Version 0.2 - November 27, 2010\n\n- Add script for building a Windows installer\n- improve hash performance (hashmeter) statistics\n- add tcatm 4way sha256 implementation\n- Add experimental VIA Padlock sha256 implementation\n\ncpuminer Version 0.1.2 - November 26, 2010\n\n- many small cleanups and micro-optimizations\n- build win32 exe using mingw\n- RPC URL, username/password become command line arguments\n- remove unused OpenSSL dependency\n\ncpuminer Version 0.1.1 - November 24, 2010\n\n- Do not build sha256_generic module separately from cpuminer.\n\ncpuminer Version 0.1 - November 24, 2010\n\n- Initial release.\n\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 44.7236328125,
          "content": "BFGMiner:\nSt. Barbara's Faithfully Glorified Mining Initiative Naturally Exceeding Rivals\nor Basically a Freaking Good Miner\n\nThis is a multi-threaded, multi-blockchain, multi-pool ASIC, FPGA, GPU and CPU\nminer with dynamic clocking, monitoring, and fanspeed support for bitcoin.\n\nThis code is provided entirely free of charge by the programmer in his spare\ntime so donations would be greatly appreciated. Please consider donating to the\naddress below.\n\nLuke-Jr <luke-jr+bfgminer@utopios.org>\n1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh\n\nDOWNLOADS:\n\nhttp://luke.dashjr.org/programs/bitcoin/files/bfgminer\n\nGIT TREE:\n\nhttps://github.com/luke-jr/bfgminer\n\nBug reports:\n\nhttps://github.com/luke-jr/bfgminer/issues\n\nIRC Channel:\n\nirc://irc.freenode.net/eligius\n\nLicense: GPLv3.  See COPYING for details.\n\nSEE ALSO README.ASIC, README.FPGA, README.GPU, README.RPC, AND README.scrypt FOR\nMORE INFORMATION ON EACH.\n\n---\n\nEXECUTIVE SUMMARY ON USAGE:\n\nSingle pool:\n\nbfgminer -o http://pool:port -u username -p password\n\nMultiple pools:\n\nbfgminer -o http://pool1:port -u pool1username -p pool1password -o http://pool2:port -u pool2usernmae -p pool2password\n\nMultiple blockchains:\n\nbfgminer -o http://pool1:port -u pool1username -p pool1password --pool-goal default -o http://pool2:port -u pool2usernmae -p pool2password --pool-goal freicoin\n\nSingle pool with a standard http proxy:\n\nbfgminer -o http://pool:port -x http://proxy:port -u username -p password\n\nSingle pool with a socks5 proxy:\n\nbfgminer -o http://pool:port -x socks5://proxy:port -u username -p password\n\nThe list of proxy types are:\n http:    standard http 1.1 proxy\n socks4:  socks4 proxy\n socks5:  socks5 proxy\n socks4a: socks4a proxy\n socks5h: socks5 proxy using a hostname\n\nProxy support requires cURL version 7.21.7 or newer.\n\nIf you specify the --socks-proxy option to BFGMiner, it will only be applied to\nall pools that don't specify their own proxy setting like above\n\n\nAfter saving configuration from the menu ([S],[W]) you do not need to give\nBFGMiner any arguments, it will load your configuration instead.\n\nAny configuration file may also contain a single\n\t\"include\" : \"filename\"\nto recursively include another configuration file.\nWriting the configuration will save all settings from all files to the output\nconfiguration file.\n\n\n---\nBUILDING BFGMINER\n\nEverything you probably want, condensed:\n\tbuild-essential autoconf automake libtool pkg-config libcurl4-gnutls-dev\n\tlibjansson-dev uthash-dev libncursesw5-dev libudev-dev libusb-1.0-0-dev\n\tlibevent-dev libmicrohttpd-dev libhidapi-dev\n\nDependencies:\n\tautoconf             http://www.gnu.org/software/autoconf/\n\tautomake             http://www.gnu.org/software/automake/\n\tlibtool              http://www.gnu.org/software/libtool/\n\tpkg-config           http://www.freedesktop.org/wiki/Software/pkg-config\n\t...or pkgconf        https://github.com/pkgconf/pkgconf\n\n\tlibcurl4-gnutls-dev  http://curl.haxx.se/libcurl/\n\n\tlibjansson-dev 2.0+  http://www.digip.org/jansson/\n\t\n\tuthash-dev 1.9.4+    http://troydhanson.github.io/uthash/\n\nOptional Dependencies:\n\tText-User-Interface (TUI): curses dev library; any one of:\n\t  libncurses5-dev    http://www.gnu.org/software/ncurses/ (Linux and Mac)\n\t  libncursesw5-dev       ^ same\n\t  libpdcurses        http://pdcurses.sourceforge.net/ (Linux/Mac/Windows)\n\n\tMultiple ASIC/FPGA autodetection: any one of:\n\t  sysfs              (built-in to most Linux kernels, just mount on /sys)\n\t  libudev-dev        http://www.freedesktop.org/software/systemd/libudev/\n\t\n\tHashBuster Nano & NanoFury USB devices:\n\t  libhidapi-dev      https://github.com/signal11/hidapi\n\t\n\tgetwork server for Block Erupter Blades:\n\t  libmicrohttpd-dev 0.9.5+  http://www.gnu.org/software/libmicrohttpd/\n\t\n\tStratum proxy:\n\t  libevent 2.0.3+    http://libevent.org/\n\n\tKnCMiner SHA2 miners:\n\t  libi2c-dev         https://i2c.wiki.kernel.org/index.php/I2C_Tools\n\t\n\tHashBuster Micro, Klondike, X6500 and ZTEX FPGA boards:\n\t  libusb-1.0-0-dev   http://www.libusb.org/\n\n\tVideo card GPU mining (free):\n\t  llvm 3.3+          http://llvm.org/\n\t  clang 3.3+         http://clang.llvm.org/\n\t  libclc             http://libclc.llvm.org/\n\t  Mesa 9.2.0+        http://www.mesa3d.org/\n\t  libsensors4-dev    https://github.com/groeck/lm-sensors\n\t\n\tATi/AMD video card GPU mining (non-free):\n\t  AMD APP SDK        http://developer.amd.com/tools/heterogeneous-computing/amd-accelerated-parallel-processing-app-sdk/\n\n\tCPU mining optimized assembly algorithms:\n\t  yasm 1.0.1+        http://yasm.tortall.net/\n\n\nBFGMiner driver configuration options:\n\t--disable-other-drivers Build without drivers by default unless explicitly\n\t                        enabled\n\t--enable-broad-udevrules\n\t                        Include udev rules for ambiguous devices which may\n\t                        not be miners\n\t--enable-alchemist      Compile support for AlcheMist (default disabled)\n\t--disable-avalon        Compile support for Avalon (default enabled)\n\t--disable-avalonmm      Compile support for Avalon2/3 (default enabled)\n\t--enable-bfsb           Compile support for BFSB (default disabled)\n\t--disable-bfx           Compile support for BFx2 (default enabled)\n\t--disable-bifury        Compile support for Bi*Fury (default enabled)\n\t--disable-bigpic        Compile support for Big Picture Mining USB (default\n\t                        enabled)\n\t--disable-bitforce      Compile support for BitForce (default enabled)\n\t--disable-bitfury       Compile support for Bitfury (default enabled)\n\t--enable-bitmain        Compile support for Bitmain Antminer S* series\n\t                        (default disabled)\n\t--disable-cointerra     Compile support for CoinTerra (default enabled)\n\t--enable-cpumining      Compile support for CPU mining (default disabled)\n\t--disable-drillbit      Compile support for DrillBit (default enabled)\n\t--disable-dualminer     Compile support for DualMiner (default enabled)\n\t--disable-gridseed      Compile support for GridSeed (default enabled)\n\t--disable-hashbuster    Compile support for HashBuster Nano (default\n\t                        enabled)\n\t--disable-hashbusterusb Compile support for HashBuster Micro (default\n\t                        enabled)\n\t--disable-hashfast      Compile support for HashFast (default enabled)\n\t--disable-icarus        Compile support for Icarus (default enabled)\n\t--enable-jingtian       Compile support for JingTian (default disabled)\n\t--disable-klondike      Compile support for Klondike (default enabled)\n\t--enable-knc            Compile support for KnC (default disabled)\n\t--enable-kncasic        Compile support for KnC gen 2 (default disabled)\n\t--disable-littlefury    Compile support for LittleFury (default enabled)\n\t--enable-metabank       Compile support for Metabank (default disabled)\n\t--enable-minergate      Compile support for Spondoolies minergate interface\n\t                        (default disabled)\n\t--enable-minion         Compile support for Minion (default disabled)\n\t--disable-modminer      Compile support for ModMiner (default enabled)\n\t--disable-nanofury      Compile support for NanoFury (default enabled)\n\t--enable-opencl         Compile support for OpenCL (default disabled)\n\t--disable-adl           Build without ADL monitoring (default enabled)\n\t--disable-rockminer     Compile support for RockMiner (default enabled)\n\t--enable-titan          Compile support for KnC Titan (default disabled)\n\t--disable-twinfury      Compile support for Twinfury (default enabled)\n\t--disable-x6500         Compile support for X6500 (default enabled)\n\t--disable-zeusminer     Compile support for ZeusMiner (default enabled)\n\t--disable-ztex          Compile support for ZTEX (default enabled)\n\nBFGMiner algorithm configuration option:\n\t--enable-keccak         Compile support for Keccak (default disabled)\n\t--disable-sha256d       Compile support for SHA256d (default enabled)\n\t--enable-scrypt         Compile support for scrypt (default disabled)\n\nBFGMiner dependency configuration options:\n\t--without-curses        Compile support for curses TUI (default enabled)\n\t--without-libevent      Compile support for libevent stratum server (default\n\t                        enabled)\n\t--without-libmicrohttpd Compile support for libmicrohttpd getwork server\n\t                        (default enabled)\n\t--without-libudev       Autodetect FPGAs using libudev (default enabled)\n\t--without-libusb        Compile using libusb (default enabled)\n\t--without-sensors       Build with libsensors monitoring (default enabled)\n\t--without-system-libbase58\n\t                        Use bundled libbase58 rather than system one\n\t--with-system-libblkmaker\n\t                        Use system libblkmaker rather than bundled one\n\t                        (default disabled)\n\t--with-udevrulesdir=DIR Install udev rules into this directory\n\t--with-udevrules-group=groupname\n\t                        Configure mining devices to be owned by a specific\n\t                        group (default `video')\n\t--without-uio           Compile support for PCI devices via Linux UIO\n\t                        interface (default enabled)\n\t--without-vfio          Compile support for PCI devices via Linux VFIO\n\t                        interface (default enabled)\n\nBasic *nix build instructions:\n\n./autogen.sh    # only needed if building from git repo\n./configure  # list configuration options here\nmake\n\nNo installation is necessary. You may run BFGMiner from the build directory\ndirectly.\n\nOn Mac OS X, you can use Homebrew to install the dependency libraries. When you\nare ready to build BFGMiner, you may need to point the configure script at one\nor more pkg-config paths. For example:\n\t./configure PKG_CONFIG_PATH=/usr/local/opt/curl/lib/pkgconfig:/usr/local/opt/jansson/lib/pkgconfig\n\nNative WIN32 build instructions: see windows-build.txt\n\nIf you build BFGMiner from source, it is recommended that you run it from the\nbuild directory. On *nix, you will usually need to prepend your command with a\npath like this (if you are in the bfgminer directory already): ./bfgminer\nTo install system wide run 'sudo make install' or 'make install' as root. You\ncan then run from any terminal.\n\n---\n\nUsage instructions:  Run \"bfgminer --help\" to see options:\n\nUsage: bfgminer [-DdElmpPQqUsTouOchnV]\n\nOptions for both config file and command line:\n--api-allow         Allow API access (if enabled) only to the given list of [W:]IP[/Prefix] address[/subnets]\n                    This overrides --api-network and you must specify 127.0.0.1 if it is required\n                    W: in front of the IP address gives that address privileged access to all api commands\n--api-description   Description placed in the API status header (default: BFGMiner version)\n--api-groups        API one letter groups G:cmd:cmd[,P:cmd:*...]\n                    See README.RPC for usage\n--api-listen        Listen for API requests (default: disabled)\n                    By default any command that does not just display data returns access denied\n                    See --api-allow to overcome this\n--api-mcast         Enable API Multicast listener, default: disabled\n--api-mcast-addr <arg> API Multicast listen address (default: \"224.0.0.75\")\n--api-mcast-code <arg> Code expected in the API Multicast message, don't use '-' (default: \"FTW\")\n--api-mcast-des <arg>  Description appended to the API Multicast reply, default: ''\n--api-mcast-port <arg> API Multicast listen port (default: 4028)\n--api-network       Allow API (if enabled) to listen on/for any address (default: only 127.0.0.1)\n--api-port          Port number of miner API (default: 4028)\n--balance           Change multipool strategy from failover to even share balance\n--benchmark         Run BFGMiner in benchmark mode - produces no shares\n--benchmark-intense Run BFGMiner in intensive benchmark mode - produces no shares\n--chroot-dir <arg>  Chroot to a directory right after startup\n--cmd-idle <arg>    Execute a command when a device is allowed to be idle (rest or wait)\n--cmd-sick <arg>    Execute a command when a device is declared sick\n--cmd-dead <arg>    Execute a command when a device is declared dead\n--coinbase-check-addr <arg> A list of address to check against in coinbase payout list received from the previous-defined pool, separated by ','\n--coinbase-check-total <arg> The least total payout amount expected in coinbase received from the previous-defined pool\n--coinbase-check-percent <arg> The least benefit percentage expected for the sum of addr(s) listed in --cbaddr argument for previous-defined pool\n--coinbase-sig <arg> Set coinbase signature when possible\n--compact           Use compact display without per device statistics\n--debug|-D          Enable debug output\n--debuglog          Enable debug logging\n--device-protocol-dump Verbose dump of device protocol-level activities\n--device|-d <arg>   Enable only devices matching pattern (default: all)\n--disable-rejecting Automatically disable pools that continually reject shares\n--http-port <arg>   Port number to listen on for HTTP getwork miners (-1 means disabled) (default: -1)\n--expiry <arg>      Upper bound on how many seconds after getting work we consider a share from it stale (w/o longpoll active) (default: 120)\n--expiry-lp <arg>   Upper bound on how many seconds after getting work we consider a share from it stale (with longpoll active) (default: 3600)\n--failover-only     Don't leak work to backup pools when primary pool is lagging\n--failover-switch-delay <arg> Delay in seconds before switching back to a failed pool (default: 300)\n--generate-to <arg> Set an address to generate to for solo mining\n--force-dev-init    Always initialize devices when possible (such as bitstream uploads to some FPGAs)\n--kernel-path <arg> Specify a path to where bitstream and kernel files are\n--load-balance      Change multipool strategy from failover to quota based balance\n--log|-l <arg>      Interval in seconds between log output (default: 20)\n--log-file|-L <arg> Append log file for output messages\n--log-microseconds  Include microseconds in log output\n--monitor|-m <arg>  Use custom pipe cmd for output messages\n--net-delay         Impose small delays in networking to avoid overloading slow routers\n--no-gbt            Disable getblocktemplate support\n--no-getwork        Disable getwork support\n--no-hotplug        Disable hotplug detection\n--no-local-bitcoin  Disable adding pools for local bitcoin RPC servers\n--no-longpoll       Disable X-Long-Polling support\n--no-pool-redirect  Ignore pool requests to redirect to another server\n--no-restart        Do not attempt to restart devices that hang\n--no-stratum        Disable Stratum detection\n--no-submit-stale   Don't submit shares if they are detected as stale\n--no-unicode        Don't use Unicode characters in TUI\n--noncelog <arg>    Create log of all nonces found\n--pass|-p <arg>     Password for bitcoin JSON-RPC server\n--per-device-stats  Force verbose mode and output per-device statistics\n--pool-goal <arg>   Named goal for the previous-defined pool\n--pool-priority <arg> Priority for just the previous-defined pool\n--pool-proxy|-x     Proxy URI to use for connecting to just the previous-defined pool\n--protocol-dump|-P  Verbose dump of protocol-level activities\n--queue|-Q <arg>    Minimum number of work items to have queued (0 - 10) (default: 1)\n--quiet|-q          Disable logging output, display status and errors\n--quit-summary <arg> Summary printed when you quit: none/devs/procs/detailed\n--quota|-U <arg>    quota;URL combination for server with load-balance strategy quotas\n--real-quiet        Disable all output\n--request-diff <arg> Request a specific difficulty from pools (default: 1.0)\n--retries <arg>     Number of times to retry failed submissions before giving up (-1 means never) (default: -1)\n--rotate <arg>      Change multipool strategy from failover to regularly rotate at N minutes (default: 0)\n--round-robin       Change multipool strategy from failover to round robin on failure\n--scan|-S <arg>     Configure how to scan for mining devices\n--scan-time <arg>   Upper bound on time spent scanning current work, in seconds (default: 60)\n--sched-start <arg> Set a time of day in HH:MM to start mining (a once off without a stop time)\n--sched-stop <arg>  Set a time of day in HH:MM to stop mining (will quit without a start time)\n--scrypt            Use the scrypt algorithm for mining (non-bitcoin)\n--set-device|--set <arg> Set default parameters on devices; eg, NFY:osc6_bits=50, bfl:voltage=<value>, compac:clock=<value>\n--setuid <arg>      Username of an unprivileged user to run as\n--sharelog <arg>    Append share log to file\n--shares <arg>      Quit after mining 2^32 * N hashes worth of shares (default: unlimited)\n--show-processors   Show per processor statistics in summary\n--skip-security-checks <arg> Skip security checks sometimes to save bandwidth; only check 1/<arg>th of the time (default: never skip)\n--socks-proxy <arg> Set socks proxy (host:port) for all pools without a proxy specified\n--stratum-port <arg> Port number to listen on for stratum miners (-1 means disabled) (default: -1)\n--submit-threads    Minimum number of concurrent share submissions (default: 64)\n--syslog            Use system log for output messages (default: standard error)\n--temp-hysteresis <arg> Set how much the temperature can fluctuate outside limits when automanaging speeds (default: 3)\n--text-only|-T      Disable ncurses formatted screen output\n--unicode           Use Unicode characters in TUI\n--url|-o <arg>      URL for bitcoin JSON-RPC server\n--user|-u <arg>     Username for bitcoin JSON-RPC server\n--verbose           Log verbose output to stderr as well as status output\n--weighed-stats     Display statistics weighed to difficulty 1\n--userpass|-O <arg> Username:Password pair for bitcoin JSON-RPC server\n--worktime                     Display extra work time debug information\nOptions for command line only:\n--config|-c <arg>   Load a JSON-format configuration file\nSee example.conf for an example configuration.\n--no-default-config Inhibit loading default config file\n--default-config    Always load the default config file\n--help|-h           Print this message\n--version|-V        Display version and exit\n\n\nGPU only options:\n\n--gpu-map <arg>     Map OpenCL to ADL device order manually, paired CSV (e.g. 1:0,2:1 maps OpenCL 1 to ADL 0, 2 to 1)\n--gpu-platform <arg> Select OpenCL platform ID to use for GPU mining\n--gpu-reorder       Attempt to reorder GPU devices according to PCI Bus ID\n--no-adl            Disable the ATI display library used for monitoring and setting GPU parameters\n\nGPU mining is disabled by default for SHA256d if you have any dedicated mining\ndevices, but can be enabled explicitly specifying the -S opencl:auto option.\n\nSee README.GPU for more information regarding GPU mining.\nSee README.scrypt for more information regarding (non-bitcoin) scrypt mining.\n\n\nTo use ASICs or FPGAs, you will need to be sure the user BFGMiner is running as\nhas appropriate permissions. This varies by operating system.\nOn Linux, with BFGMiner's udev rules: sudo usermod <username> -a -G video\nNote that on GNU/Linux systems, you will usually need to login again before\ngroup changes take effect.\n\nBy default, BFGMiner will scan for autodetected devices. If you want to prevent\nBFGMiner from doing this, you can use \"-S noauto\". If you want to probe all\nserial ports, you can use \"-S all\"; note that this may write data to non-mining\ndevices which may then behave in unexpected ways!\n\nOn Linux, <arg> is usually of the format /dev/ttyUSBn\nOn Mac OS X, <arg> is usually of the format /dev/cu.usb*\nOn Windows, <arg> is usually of the format \\\\.\\COMn\n(where n = the correct device number for the device)\n\nThe official supplied binaries are compiled with support for all ASICs/FPGAs.\nTo force the code to only attempt detection with a specific driver,\nprepend the argument with the driver name followed by an \"at\" symbol.\nFor example, \"icarus@/dev/ttyUSB0\" or \"bitforce@\\\\.\\COM5\"\nor using the short name: \"ica@/dev/ttyUSB0\" or \"bfl@\\\\.\\COM5\"\n\nSome FPGAs do not have non-volatile storage for their bitstreams and must be\nprogrammed every power cycle, including first use. To use these devices, you\nmust download the proper bitstream from the vendor's website and copy it to the\n\"bitstreams\" directory into your BFGMiner application directory.\n\nSee README.ASIC and README.FPGA for more information regarding these.\n\nSee README.CPU for information regarding CPU mining.\n\n---\n\nWHILE RUNNING:\n\nThe following options are available while running with a single keypress:\n\n[M]anage devices [P]ool management [S]ettings [D]isplay options  [H]elp [Q]uit\n\nM gives you something like:\n\nSelect processor to manage using up/down arrow keys\n BFL 0a: 78.0C |  3.64/ 3.70/ 2.91Gh/s | A:46 R:0+0(none) HW:  2/none\n  BitFORCE SHA256 SC from Butterfly Labs\nSerial: FTWN6T67\n\n[D]isable\nOr press Enter when done\n\n\nP gives you:\n\nCurrent pool management strategy: Failover\n[F]ailover only disabled\n[A]dd pool [R]emove pool [D]isable pool [E]nable pool\n[C]hange management strategy [S]witch pool [I]nformation\n\n\nS gives you:\n\n[L]ongpoll: On\n[Q]ueue: 1\n[S]cantime: 60\n[E]xpiry: 120\n[R]etries: -1\n[W]rite config file\n[B]FGMiner restart\n\n\nD gives you:\n\n[N]ormal [C]lear [S]ilent mode (disable all output)\n[D]ebug:off\n[P]er-device:off\n[Q]uiet:off\n[V]erbose:off\n[R]PC debug:off\n[W]orkTime details:off\nco[M]pact: off\n[L]og interval:5\n\n\nQ quits the application.\n\n\nThe running log shows output similar to that below:\n\n [2013-02-13 00:26:30] Accepted 1758e8df BFL 0  pool 0 Diff 10/1\n [2013-02-13 00:26:32] Accepted 1d9a2199 MMQ 0a pool 0 Diff 8/1\n [2013-02-13 00:26:33] Accepted b1304924 ZTX 0  pool 0 Diff 1/1\n [2013-02-13 00:26:33] Accepted c3ad22f4 XBS 0b pool 0 Diff 1/1\n\nThe 8 byte hex value are the 2nd set of 32 bits from the share submitted to the\npool. The 2 diff values are the actual difficulty target that share reached\nfollowed by the difficulty target the pool is currently asking for.\n\n---\nAlso many issues and FAQs are covered in the forum threads\ndedicated to this program,\n\thttps://bitcointalk.org/?topic=78192\n\thttps://bitcointalk.org/?topic=168174\n\nIf you are mining on a single pool, the pool display shows:\n Pool 0: ...s.m.eligius.st   Diff:16  +Strtm  LU:[03:26:16]  User:1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh\n\nThis tells you which pool you're using, as well as its current share difficulty,\nprotocol, and last explicit work update. If BFGMiner has a working block\nnotification source, the protocol will be prefixed by a plus sign. If not, a\nminus sign.\n\nIf you are mining on multiple pools at once, the pool display instead shows:\n Pools: 2 (0,1)              Diff:4-16  +  LU:[03:25:30]\n\nYou get the total number of working pools, the pool numbers for each of those,\nthe range of current share difficulties, whether block notification is working\n(plus/minus), and the oldest explicit work update currently being used for new\nwork.\n\nThe block display shows:\nBlock #217364: ...1b89f8d3  Diff:7.67M (54.93T)  Started: [17:17:22]  I:12.99mBTC/hr\n\nThis shows a short stretch of the next block's height, the current block,\ndifficulty (including the network hashrate that difficulty represents), when the\nsearch for the new block started, and finally expected Income, calculated by\nactual shares submitted in 100% PPS value (assumes Bitcoin, does not account for\naltcoin conversions!).\n\nThe BFGMiner status line shows:\n ST:1  F:0  NB:1  AS:0  BW:[ 75/241 B/s]  E:2.42  BS:2.71k\n\nST is STaged work items (ready to use).\nF  is network Failure occasions (server down or slow to provide work)\nNB is New Blocks detected on the network\nAS is Active Submissions (shares in the process of submitting)\nBW is BandWidth usage on the network (received/sent)\nE  is Efficiency defined as number of shares accepted (multiplied by their\n          difficulty) per 2 KB of bandwidth\nBS is the all time Best Share difficulty you've found\n\nThe totals line shows the following:\n 6/32   75.0C | 171.3/170.8/171.2Gh/s | A:729 R:8+0(.01%) HW:0/.81%\n\nEach column is as follows:\n  The number of devices and processors currently mining\n  Hottest temperature reported by any processor\n  20 second exponentially decaying average hash rate (configurable with --log\n      option)\n  An all time average hash rate\n  An all time average hash rate based on actual nonces found, adjusted for pool\n      reject and stale rate\n  The number of Accepted shares\n  The number of Rejected shares and stale shares discarded (never submitted),\n      and the percentage these are of total found.\n  The number of HardWare errors, and percentage invalid of nonces returned\n\nEach device shows:\n BFL 2: 74.0C | 51.97/58.90/57.17Gh/s | A:847 R:15+0(.54%) HW:496/.91%\n\nColumns are the same as in the totals line.\n\n\n---\nMULTIPOOL\n\nFAILOVER STRATEGIES WITH MULTIPOOL:\nA number of different strategies for dealing with multipool setups are\navailable. Each has their advantages and disadvantages so multiple strategies\nare available by user choice, as per the following list:\n\nFAILOVER:\nThe default strategy is failover. This means that if you input a number of\npools, it will try to use them as a priority list, moving away from the 1st\nto the 2nd, 2nd to 3rd and so on. If any of the earlier pools recover, it will\nmove back to the higher priority ones.\n\nROUND ROBIN:\nThis strategy only moves from one pool to the next when the current one falls\nidle and makes no attempt to move otherwise.\n\nROTATE:\nThis strategy moves at user-defined intervals from one active pool to the next,\nskipping pools that are idle.\n\nLOAD BALANCE:\nThis strategy sends work to all the pools on a quota basis. By default, all\npools are allocated equal quotas unless specified with --quota. This\napportioning of work is based on work handed out, not shares returned so is\nindependent of difficulty targets or rejected shares. While a pool is disabled\nor dead, its quota is dropped until it is re-enabled. Quotas are forward\nlooking, so if the quota is changed on the fly, it only affects future work.\nIf all pools are set to zero quota or all pools with quota are dead, it will\nfall back to a failover mode. See quota below for more information.\n\nThe failover-only flag has special meaning in combination with load-balance\nmode and it will distribute quota back to priority pool 0 from any pools that\nare unable to provide work for any reason so as to maintain quota ratios\nbetween the rest of the pools.\n\nBALANCE:\nThis strategy monitors the amount of difficulty 1 shares solved for each pool\nand uses it as a basis for trying to doing the same amount of work for each\npool.\n\n\n---\nSOLO MINING\n\nBFGMiner supports solo mining with any GBT-compatible bitcoin node (such as\nbitcoind). To use this mode, you need to specify the URL of your bitcoind node\nusing the usual pool options (--url, --userpass, etc), and the --generate-to\noption to specify the Bitcoin address you wish to receive the block rewards\nmined. When you run Bitcoin Core on the same computer as your miner, the pool\nitself will be automatically configured for you (on the default goal). Please be\naware that solo mining via GBT is at this time only supported for Bitcoin.\n\nIMPORTANT: If you are solo mining with more than one instance of BFGMiner (or\nany other software) per payout address, you must also specify data using the\n--coinbase-sig option to ensure each miner is working on unique work. Note\nthat this data will be publicly seen if your miner finds a block using any\nGBT-enabled pool, even when not solo mining (such as failover).\n\nIf your bitcoin node does not support longpolling (for example, bitcoind 0.8.x),\nyou should consider setting up a failover pool to provide you with block\nnotifications. Note that solo mining does not use shares, so BFGMiner's adjusted\nhashrate (third column) may suddenly drop to zero if a block you submit is\nrejected; this does not indicate that it has stopped mining.\n\nExample solo mining usage:\n\nbfgminer -o http://localhost:8332 -u username -p password \\\n    --generate-to 1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh \\\n    --coinbase-sig \"rig1: This is Joe's block!\"\n\nIf you want to solo mine on multiple GBT-compatible Bitcoin blockchains, you can\nspecify --generate-to multiple times with a goal name prefix followed by a\ncolon. Note that at this time, the coinbase sig is always shared across all\ngoals/pools.\n\nExample multi-blockchain solo mining usage:\n\nbfgminer -o http://localhost:8332 -u username -p password \\\n    --generate-to 1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh \\\n    -o http://localhost:7221 -u user2 -p password --pool-goal mychain \\\n    --generate-to mychain:1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh \\\n    --coinbase-sig \"rig1: This is Joe's block!\"\n\n\n---\nQUOTAS\n\nThe load-balance multipool strategy works off a quota based scheduler. The\nquotas handed out by default are equal, but the user is allowed to specify any\narbitrary ratio of quotas. For example, if all the quota values add up to 100,\neach quota value will be a percentage, but if 2 pools are specified and pool0\nis given a quota of 1 and pool1 is given a quota of 9, pool0 will get 10% of\nthe work and pool1 will get 90%. Quotas can be changed on the fly with RPC,\nand do not act retrospectively. Setting a quota to zero will effectively\ndisable that pool unless all other pools are disabled or dead. In that\nscenario, load-balance falls back to regular failover priority-based strategy.\nWhile a pool is dead, it loses its quota and no attempt is made to catch up\nwhen it comes back to life.\n\nTo specify quotas on the command line, pools should be specified with a\nsemicolon separated --quota(or -U) entry instead of --url. Pools specified with\n--url are given a nominal quota value of 1 and entries can be mixed.\n\nFor example:\n--url poolA:portA -u usernameA -p passA --quota \"2;poolB:portB\" -u usernameB -p passB\nWill give poolA 1/3 of the work and poolB 2/3 of the work.\n\nWriting configuration files with quotas is likewise supported. To use the above\nquotas in a configuration file they would be specified thus:\n\n\"pools\" : [\n        {\n                \"url\" : \"poolA:portA\",\n                \"user\" : \"usernameA\",\n                \"pass\" : \"passA\"\n        },\n        {\n                \"quota\" : \"2;poolB:portB\",\n                \"user\" : \"usernameB\",\n                \"pass\" : \"passB\"\n        }\n]\n\n\n---\nLOGGING\n\nBFGMiner will log to stderr if it detects stderr is being redirected to a file.\nTo enable logging simply add 2>logfile.txt to your command line and logfile.txt\nwill contain the logged output at the log level you specify (normal, verbose,\ndebug etc.)\n\nIn other words if you would normally use:\n./bfgminer -o xxx -u yyy -p zzz\nif you use\n./bfgminer -o xxx -u yyy -p zzz 2>logfile.txt\nit will log to a file called logfile.txt and otherwise work the same.\n\nThere is also the -m option on linux which will spawn a command of your choice\nand pipe the output directly to that command.\n\nThe WorkTime details 'debug' option adds details on the end of each line\ndisplayed for Accepted or Rejected work done. An example would be:\n\n <-00000059.ed4834a3 M:X D:1.0 G:17:02:38:0.405 C:1.855 (2.995) W:3.440 (0.000) S:0.461 R:17:02:47\n\nThe first 2 hex codes are the previous block hash, the rest are reported in\nseconds unless stated otherwise:\nThe previous hash is followed by the getwork mode used M:X where X is one of\nP:Pool, T:Test Pool, L:LP or B:Benchmark,\nthen D:d.ddd is the difficulty required to get a share from the work,\nthen G:hh:mm:ss:n.nnn, which is when the getwork or LP was sent to the pool and\nthe n.nnn is how long it took to reply,\nfollowed by 'O' on its own if it is an original getwork, or 'C:n.nnn' if it was\na clone with n.nnn stating how long after the work was recieved that it was\ncloned, (m.mmm) is how long from when the original work was received until work\nstarted,\nW:n.nnn is how long the work took to process until it was ready to submit,\n(m.mmm) is how long from ready to submit to actually doing the submit, this is\nusually 0.000 unless there was a problem with submitting the work,\nS:n.nnn is how long it took to submit the completed work and await the reply,\nR:hh:mm:ss is the actual time the work submit reply was received\n\nIf you start BFGMiner with the --sharelog option, you can get detailed\ninformation for each share found. The argument to the option may be \"-\" for\nstandard output (not advisable with the ncurses UI), any valid positive number\nfor that file descriptor, or a filename.\n\nTo log share data to a file named \"share.log\", you can use either:\n./bfgminer --sharelog 50 -o xxx -u yyy -p zzz 50>share.log\n./bfgminer --sharelog share.log -o xxx -u yyy -p zzz\n\nFor every share found, data will be logged in a CSV (Comma Separated Value)\nformat:\n    timestamp,disposition,target,pool,dev,thr,sharehash,sharedata\nFor example (this is wrapped, but it's all on one line for real):\n    1335313090,reject,\n    ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000,\n    http://localhost:8337,GPU0,0,\n    6f983c918f3299b58febf95ec4d0c7094ed634bc13754553ec34fc3800000000,\n    00000001a0980aff4ce4a96d53f4b89a2d5f0e765c978640fe24372a000001c5\n    000000004a4366808f81d44f26df3d69d7dc4b3473385930462d9ab707b50498\n    f681634a4f1f63d01a0cd43fb338000000000080000000000000000000000000\n    0000000000000000000000000000000000000000000000000000000080020000\n\n---\n\nRPC API\n\nFor RPC API details see the README.RPC file\n\n---\n\nFAQ\n\nQ: Why can't BFGMiner find lib<something> even after I installed it from source\ncode?\nA: On UNIX-like operating systems, you often need to run one or more commands to\nreload library caches, such as \"ldconfig\" or similar. A couple of systems (such\nas Fedora) ship with /usr/local/lib missing from their library search path. In\nthis case, you can usually add it like this:\n    echo /usr/local/lib >/etc/ld.so.conf.d/local.conf\nPlease note that if your libraries installed into lib64 instead of lib, you\nshould use that in the ld.so config file above instead.\n\nQ: BFGMiner segfaults when I change my shell window size.\nA: Older versions of libncurses have a bug to do with refreshing a window\nafter a size change. Upgrading to a new version of curses will fix it.\n\nQ: I have multiple USB stick devices but I can't get them all to work at once?\nA: Very few USB hubs deliver the promised power required to run as many devices\nas they fit if all of them draw power from USB. Devices may use up to 2.5 watts\nof power (or 4.5 watts for USB 3 devices), and mining USB sticks usually need it\nall. You can estimate how much power your USB hub can provide by multiplying its\npower supply's output amps by volts (so, if it says 12V 2.5A, you have 12*2.5=\n30 watts).\n\nQ: I've confirmed my USB miners are powered sufficiently, but BFGMiner still\nis having problems running more than a few at once?\nA: Some USB hosts cannot deal with polling as often as miners may need for quick\ndelivery of shares. On Linux, you can request putting VCOM devices in \"high\nlatency\" mode (or rather, disabling the default \"low latency\" mode) using the\nsetserial command:\n    setserial /dev/ttyUSB0 '^low_latency'\nYou can further tweak device latency by finding the latency_timer attribute in\nsysfs.\n\nQ: I've plugged my devices into my USB hub but nothing shows up?\nA: RPis and Windows have incomplete or non-standard USB3 support so they may\nnever work. It may be possible to get a USB3 hub to work by plugging it into a\nUSB2 hub.\n\nQ: Can I mine on servers from different networks (eg smartcoin and bitcoin) at\nthe same time?\nA: No, BFGMiner keeps a database of the block it's working on to ensure it does\nnot work on stale blocks, and having different blocks from two networks would\nmake it invalidate the work from each other.\n\nQ: Can I configure BFGMiner to mine with different login credentials or pools\nfor each separate device?\nA: No such feature has been implemented to support this.\n\nQ: Can I put multiple pools in the config file?\nA: Yes, check the example.conf file. Alternatively, set up everything either on\nthe command line or via the menu after startup and choose [S]ettings->[W]rite\nconfig file and the file will be loaded one each startup.\n\nQ: The build fails with gcc is unable to build a binary.\nA: Remove the \"-march=native\" component of your CFLAGS as your version of GCC\ndoes not support it.\n\nQ: Can you implement feature X?\nA: I can, but time is limited, and people who donate are more likely to get\ntheir feature requests implemented.\n\nQ: Work keeps going to my backup pool even though my primary pool hasn't\nfailed?\nA: BFGMiner checks for conditions where the primary pool is lagging and will\npass some work to the backup servers under those conditions. The reason for\ndoing this is to try its absolute best to keep the devices working on something\nuseful and not risk idle periods. You can disable this behaviour with the\noption --failover-only.\n\nQ: Is this a virus?\nA: As BFGMiner is being packaged with other trojan scripts, some antivirus\nsoftware is falsely accusing bfgminer.exe as being the actual virus, rather than\nwhatever it is being packaged with. If you installed BFGMiner yourself from a\nreputable source then you do not have a virus on your computer. Complain to your\nantivirus software company. They seem to be flagging even source code from\nBFGMiner as malicious now, even though text source files can't do anything by\nthemselves.\n\nQ: Can you modify the display to include more of one thing in the output and\nless of another, or can you change the quiet mode or can you add yet another\noutput mode?\nA: Everyone will always have their own view of what is important to monitor.\nThe defaults are very sane and I have very little interest in changing this\nany further.\n\nQ: Why is my efficiency above/below 1.00?\nA: Efficiency simply means how many shares you return for the amount of\nbandwidth used. It does not correlate with efficient use of your hardware, and\nis a measure of a combination of hardware speed, block luck, pool design and\nmany other factors.\n\nQ: What are the best parameters to pass for X pool/hardware/device.\nA: Virtually always, the DEFAULT parameters give the best results. Most user\ndefined settings lead to worse performance.\n\nQ: What happened to CPU mining?\nA: See README.CPU for more information.\n\nQ: Is there a GUI version?\nA: Yes, there are a number of GUI interfaces for BFGMiner:\nName        Website                                Operating system(s)\n----        -------                                -------------------\nEasyMiner   http://www.butterflylabs.com/drivers/  Android, Linux, Windows\nMacMiner    http://fabulouspanda.co.uk/macminer/   Mac\nMultiMiner  http://www.multiminerapp.com/          Linux, Mac, Windows (.NET)\n\nQ: Is there a \"bare-metal\" version?\nA: Yes, there are a few dedicated mining operating systems built on BFGMiner:\nName        Website                              Hardware\n----        -------                              --------\nControla    http://hashra.com/support            Raspberry Pi\nMinePeon    http://mineforeman.com/minepeon/     BeagleBone Black, Raspberry Pi\nMinera      http://getminera.com/                Raspberry Pi\nPiMP        http://getpimp.org/                  x86\n\nQ: I'm having an issue. What debugging information should I provide?\nA: Start BFGMiner with your regular commands and add -D -T --verbose and provide\nthe full startup output and a summary of your hardware, operating system, and if\napplicable, ATI driver version and ATI stream version.\n\nQ: Why isn't BFGMiner performing well or working on my Raspberry Pi?\nA: Raspberry Pis have hardware defect(s) which affect USB devices to varying\ndegrees. Some devices will never be able to work on them, some work fine, and\nsome require hacks to workaround the problem. One common workaround is to add\nthe dwc_otg.speed=1 parameter to /boot/cmdline.txt. Note that this will slow\ndown the USB bus to USB 1.1 speeds, which also affects network bandwidth since\nthe Raspberry Pi uses a USB network interface. You may wish to consider\nupgrading to a BeagleBone or UDOO controller.\n\nQ: Can I mine with BFGMiner on a Mac?\nA: BFGMiner will compile on OS X, but the performance of GPU mining is\ncompromised due to the OpenCL implementation on OS X, there is no temperature or\nfanspeed monitoring and the cooling design of most Macs, despite having\npowerful GPUs, will usually not cope with constant usage leading to a high risk\nof thermal damage. It is highly recommended not to mine on a Mac unless it is\nwith an external USB device.\n\nQ: My network gets slower and slower and then dies for a minute?\nA; Try the --net-delay option if you are on a getwork or GBT server.\n\nQ: How do I tune for P2Pool?\nA: P2Pool has very rapid expiration of work and new blocks, it is suggested you\ndecrease intensity by 1 from your optimal value, and decrease GPU threads to 1\nwith --set-device OCL:threads=1. It is also recommended to use --failover-only\nsince the work is effectively like a different block chain. If mining with a\nMini Rig, it is worth adding the --bfl-range option.\n\nQ: I run PHP on windows to access the API with the example miner.php. Why does\nit fail when php is installed properly but I only get errors about Sockets not\nworking in the logs?\nA: Please check http://us.php.net/manual/en/sockets.installation.php\n\nQ: What is a PGA?\nA: At the moment, BFGMiner supports 5 FPGAs: BitForce, Icarus, ModMiner, X6500,\nand ZTEX.\nThey are Field-Programmable Gate Arrays that have been programmed to do Bitcoin\nmining. Since the acronym needs to be only 3 characters, the \"Field-\" part has\nbeen skipped. \"PGA\" is also used for devices built with Application-Specific\nIntegrated Circuits (ASICs).\n\nQ: What is an ASIC?\nA: They are Application Specific Integrated Circuit devices and provide the\nhighest performance per unit power due to being dedicated to only one purpose.\n\nQ: How do I get my BFL/Icarus/Lancelot/Cairnsmore device to auto-recognise?\nA: On Linux, if the /dev/ttyUSB* devices don't automatically appear, the only\nthing that needs to be done is to load the driver for them:\n  BitForce:   sudo modprobe ftdi_sio vendor=0x0403 product=0x6014\n  Erupter:    sudo modprobe cp210x   vendor=0x10c4 product=0xea60\n  Icarus:     sudo modprobe pl2303   vendor=0x067b product=0x0230\n  Lancelot:   sudo modprobe ftdi_sio vendor=0x0403 product=0x6001\n  Cairnsmore: sudo modprobe ftdi_sio vendor=0x0403 product=0x8350\nOn some systems you must manally install the driver required for the device.\nOpenWrt drivers (install with opkg):\n  FTDI:       kmod-usb-serial-ftdi\n  Erupter:    kmod-usb-serial-cp210x\n  Icarus:     kmod-usb-serial-pl2303\nWindows drivers:\n  FTDI:       http://www.ftdichip.com/Drivers/VCP.htm\n  Erupter:    http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx\n  Icarus:     http://prolificusa.com/pl-2303hx-drivers/\n\nQ: I ran cgminer, and now BFGMiner doesn't work!\nA: cgminer has its own non-standard implementations of the drivers for most USB\ndevices, and requires you to replace the official drivers with WinUSB on Windows\n(usually using Zadig). Before you can use BFGMiner, you will need to restore the\noriginal driver. Uninstalling the device (and WinUSB driver) from Device Manager\nand re-plugging it will usually trigger driver re-installation to the default\ndrivers.\n\nQ: On Linux I can see the /dev/ttyUSB* devices, but BFGMiner can't mine on them?\nA: Make sure you have the required privileges to access the /dev/ttyUSB*\ndevices:\n sudo ls -las /dev/ttyUSB*\nwill give output like:\n 0 crw-rw---- 1 root video   188, 0 2012-09-11 13:49 /dev/ttyUSB0\nThis means your account must have the group 'video' or root privileges.\nTo permanently give your account the 'video' group:\n sudo usermod -G video -a `whoami`\nThen logout and back in again.\n\nQ: Can I mine scrypt with FPGAs or ASICs?\nA: BFGMiner supports scrypt mining with GridSeed GC3355 ASICs, using either\nDualMiner USB sticks or the 5-chip orb.\n\nQ: Why does BFGMiner show a fractional difficulty when mining scrypt?\nA: BFGMiner consistently uses pdiff measurement for difficulty everywhere,\nrather than other measurements that may exist. For scrypt, pdiff 1 is very\ndifficult, and higher get exponentially harder. It is unlikely you will want to\nuse pdiff 1+ with scrypt any time soon.\n\nQ: What is stratum and how do I use it?\nA: Stratum is a protocol designed to reduce resources for mining pools at the\ncost of keeping the miner in the dark and blindly transferring his mining\nauthority to the pool. It is a return to the problems of the old centralized\n\"getwork\" protocol, but capable of scaling to hardware of any speed like the\nstandard GBT protocol. If a pool uses stratum instead of GBT, BFGMiner will\nautomatically detect it and switch to the support as advertised if it can.\nStratum uses direct TCP connections to the pool and thus it will NOT currently\nwork through a http proxy but will work via a socks proxy if you need to use\none. If you input the stratum port directly into your configuration, or use the\nspecial prefix \"stratum+tcp://\" instead of \"http://\", BFGMiner will ONLY try to\nuse stratum protocol mining.\n\nQ: Why don't the statistics add up: Accepted, Rejected, Stale, Hardware Errors,\nDiff1 Work, etc. when mining greater than 1 difficulty shares?\nA: As an example, if you look at 'Difficulty Accepted' in the RPC API, the number\nof difficulty shares accepted does not usually exactly equal the amount of work\ndone to find them. If you are mining at 8 difficulty, then you would expect on\naverage to find one 8 difficulty share, per 8 single difficulty shares found.\nHowever, the number is actually random and converges over time as it is an\naverage, not an exact value, thus you may find more or less than the expected\naverage.\n\n---\n\nThis code is provided entirely free of charge by the programmer in his spare\ntime so donations would be greatly appreciated. Please consider donating to the\naddress below.\n\nLuke-Jr <luke-jr+bfgminer@utopios.org>\n1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh\n"
        },
        {
          "name": "README.ASIC",
          "type": "blob",
          "size": 18.6123046875,
          "content": "SUPPORTED DEVICES\n\nCurrently supported ASIC devices include Avalon, Bitfountain's Block Erupter\nseries (both USB and blades), a large variety of Bitfury-based miners,\nBitmain's Antminer S5 and U1-3, Butterfly Labs' SC range of devices, HashBuster\nboards, GekkoScience's Compac USB stick, Klondike modules, and KnCMiner's\nMercury, Jupiter and Saturn.\n\n\nANTMINER S1-S5\n--------------\n\nBFGMiner must be compiled for and run on the embedded controller. When\nconfiguring, use the --enable-bitmain option to build the 'bitmain' driver used\nto interface with this hardware. None of the device attributes are autodetected\nat this time, so you must also tell BFGMiner this at runtime with a series of\n--set options. For example:\n\n-S bitmain:auto --set btm:model=S5 --set btm:layout=32:8 --set btm:timeout=3\n--set btm:clock=350 --set btm:reg_data=0d82 --set btm:voltage=x0725\n\nNote that reg_data is optional for S4 and S5 and will be calculated from clock\nif not provided.\n\nThe meaning of each of these options are not documented individually at this\ntime, but can be determined from the stock cgminer's options. You want to look\nat the \"bitmain-options\" from the command line, and the \"bitmain-freq\" and\n\"bitmain-voltage\" in the /config/cgminer.conf file.\nIn this case, they were:\n\nNOTE: These are NOT valid BFGMiner options!\n    --bitmain-options 115200:32:8:7:200:0782:0725\n                             |    | |   |    ^^^^ voltage\n                             |    | |   ^^^^ reg_data\n                             |    | ^^^ clock\n                             |    ^ timeout\n                             ^^^^ layout\n    \"bitmain-freq\" : \"3:350:0d82\",\n                      | |   ^^^^ reg_data\n                      | ^^^ clock\n                      ^ timeout\n    \"bitmain-voltage\" : \"0725\"\n                         ^^^^ voltage\n\nNotice how there are duplicate settings for timeout, clock, reg_data, and\nvoltage. You can probably use either one, but the 350 MHz clock performs\nbetter than the 200 MHz clock. You shouldn't mix and match the\ntimeout/clock/reg_data combinations, however!\n\nAdditionally, since the controllers are underpowered for these devices, you may\nneed to experiment with a good queue setting to control how much work BFGMiner\ntries to pre-prepare for it. A reasonable starting place is:\n\n--queue 8192\n\n\nALCHEMIST\n---------\nThis driver requires the latest FPGA firmware flashed on the blades (stock\nfirmware has major bug and won't run properly with this driver). For\ninstructions, please visit: https://litecointalk.org/?topic=27370\nThe driver has been designed to run each of the 8 blades inside an AlcheMist\n256 as a separate miner. To detect all the blades you need to manually probe it\nwith the following serial ports:\n\n-S ALC:all -S ALC:/dev/ttyO1 -S ALC:/dev/ttyO2 -S ALC:/dev/ttyO3\n-S ALC:/dev/ttyO4\n\n(the four ttyUSB ports are auto detected by all)\n\nThe driver supports custom frequency settings in the range of 200-400 MHz in 16\nMHz increments (driver will default to 352 MHz if these conditions are not met).\nFrequency is set with the following --set option:\n\n--set ALC:clock=336\n\nYou can also set the frequency per board by specifying the tty port:\n\n--set ALC@/dev/ttyO3:clock=352\n\nDriver also supports running blades off a Raspberry Pi directly or with USB Dongles. For a single blade off a raspberry Pi make sure you have configured GPIO pin 25 correctly (see below) and scan via\n-S ALC:/dev/ttyAMA0\n\necho 25 > /sys/class/gpio/export\necho out > /sys/class/gpio/gpio25/direction\n\nfor multiple blades using USB Dongles connected to a pi make sure the reset pin on the alcheminer board is connected to the RTS/DTR pin on the dongle board, and option --set\nALC:mode=1 added to startup command line.\n\n\nANTMINER U3\n-----------\n\nThe U3 does not support autodetection, so you will want to use --scan-serial to\nmanually probe it. For example, to scan all devices, you can use:\n\n-S antminer:all --set antminer:chip=BM1382\n\nAdditionally, for optimal performance you will need to set voltage, clock, and\ntiming. Voltage format for the U3 is not documented by the manufacturer, thus\nmust be provided as hexadecimal configuration codes. Timing is provided in the\nnumber of nanoseconds each hash takes at the given configuration. A\nknown-working configuration is:\n\n--set antminer:voltage=x800 --set antminer:clock=237.5\n--set antminer:timing=0.022421\n\nTo set different frequency and voltage settings for multiple U3 miners on a\nsingle BFGMiner process use:\n\n--set antminer@\\\\.\\COM10:voltage=xNNNN\n\nor\n\n--set antminer@/dev/ttyUSB1:voltage=xNNNN\n\nAnother option is to program the CP2102 chip so they have unique serial numbers;\nthis method would avoid problems with the device showing up on different tty/COM\nlocations after reboot/hotplug:\n\n/cp210x-program -w -F eeprom-content.AntU3-custom.hex --set-product-string='Antminer U3' --set-serial-number=myveryown0001\n\nThen you can use --set antminer@myveryown0001:voltage=xNNNN\n\n\nAVALON 1\n--------\n\nCurrently, Avalon boards are best supported by connecting them directly (or via\na hub) to a regular PC running BFGMiner. It is also possible to install the\nOpenWrt packages of BFGMiner to the Avalon's embedded controller, but this is\nnot a simple task due to its lack of available flash space.\n\nTo use the Avalon from a regular PC, you will need to specify two options:\nFirst, add the -S option specifying the avalon driver specifically. For example,\n\n-S avalon:\\\\.\\COM9\n\nNext, use the --set-device option to provide the device configuration.\nIf you are translating options from --avalon-options (cgminer and older versions\nof BFGMiner), note the values are baud:miner_count:asic_count:timeout:clock.\n\n    baud=N         The device is essentially hard coded to emulate 115200 baud,\n                   so you shouldn't change this.\n    miner_count=N  Most Avalons are 3 module devices, which come to 24 miners.\n                   4 module devices would use 32 here.\n    asic_count=N   Virtually all have 10, so don't change this.\n    timeout=N      This defines how long the device will work on a work item\n                   before accepting new work to replace it. It should be changed\n                   according to the frequency (last setting). It is possible to\n                   set this a little lower if you are trying to tune for short\n                   block mining (eg p2pool) but much lower and the device will\n                   start creating duplicate shares.\n    clock=N        This is the clock speed of the devices. Only specific values\n                   work: 256, 270, 282 (default), 300, 325, 350 and 375.\n\nSample settings for valid different frequencies (last 2 values):\n34:375\n36:350\n39:325\n43:300\n45:282\n47:270\n50:256\n\n\nAVALON 2/3\n----------\n\nAvalon 2/3 units communicate with a UART, usually attached to your host via a\ngeneric USB UART adapter. Therefore, you will need to manually probe the correct\nUART device with the -S option:\n\n-S avalonmm:\\\\.\\COM22\n\nNext, use the --set option to configure at least your desired clock frequency\nand voltage.\n\nAvalon 2: --set avalonmm:clock=1500 --set avalonmm:voltage=1\nAvalon 3: --set avalonmm:clock=450 --set avalonmm:voltage=0.6625\n\nYou may also want to set the fan speed, which is specified as a percentage:\n\n--set avalonmm:fan=95\n\n\nBFSB, MEGABIGPOWER, AND METABANK BITFURY BOARDS\n-----------------------------------------------\n\nBoth BFSB and MegaBigPower (V2 only at this time) boards are supported with the\n\"bfsb\" driver. Metabank boards are supported with the \"metabank\" driver. These\ndrivers are not enabled by default, since they must be run on a Raspberry Pi in\na specific hardware configuration with the boards. To enable them, you must\nbuild with --enable-bfsb or --enable-metabank. Do not try to use these drivers\nwithout the manufacturer-supported hardware configuration! Also note that these\ndrivers do not properly support thermal shutdown at this time, and without\nsufficient cooling you may destroy your board or chips!\n\nTo start BFGMiner, ensure your Raspberry Pi's SPI is enabled (you can run the\nraspi-config utility for this). For Metabank boards, you must also load the I2C\ndrivers (do not try to modprobe both with a single command; it won't work):\n    modprobe i2c-bcm2708\n    modprobe i2c-dev\nThen you must run BFGMiner as root, with the proper driver selected.\nFor example:\n    sudo bfgminer -S bfsb:auto\n\n\nBFx2\n----\n\nYou will need to install the WinUSB driver instead of the default FTDI serial\ndriver. The easiest way to do this is using Zadig: http://zadig.akeo.ie/\n\nNote that since it's impossible to tell the BFx2 apart from various other\ndevices (including BFL/Cairnsmore1 miners and even many non-mining devices!),\nyou must run with the -S bfx:all option (or 'bfx:all' at the M+ menu).\n\nI do not know what this will do with other devices; it may start fires,\nlaunch nuclear missiles (please don't run BFGMiner on computers with\nmissile controls), etc.\n\n\nBI*FURY\n-------\n\nBi*Fury should just work; you may need to use -S bifury:<path>\n\nOn Windows, you will need to install the standard USB CDC driver for it.\n    http://store.bitcoin.org.pl/support\n\nIf you want to upgrade the firmware, unplug your device. You will need to\ntemporarily short a circuit. With the USB connector pointing forward, and the\nheatsink down, look to the forward-right; you will see two tiny lights, a set of\n2 terminals, and a set of 3 terminals. The ones you need to short are the set of\n2. With them shorted, plug the device back into your computer. It will then\npretend to be a mass storage disk drive. If you use Windows, you can play along\nand just overwrite the firmware.bin file. If you use Linux, you must use mcopy:\n    mcopy -i /dev/disk/by-id/usb-NXP_LPC1XXX_IFLASH_ISP-0:0 firmware.bin \\\n        ::/firmware.bin\nAfter this is complete, unplug the device again and un-short the 2 terminals.\nThis completes the upgrade and you can now plug it back in and start mining.\n\n\nBIG PICTURE MINING BITFURY USB\n------------------------------\n\nThese miners are sensitive to unexpected data. Usually you can re-plug them to\nreset to a known-good initialisation state. To ensure they are properly detected\nand used with BFGMiner, you must specify -S bigpic:all (or equivalent) options\nprior to any other -S options (which might probe the device and confuse it).\n\n\nBLOCK ERUPTER BLADE\n-------------------\n\nBlades communicate over Ethernet using the old but simple getwork mining\nprotocol. If you build BFGMiner with libmicrohttpd, you can have it work with\none or more blades. First, start BFGMiner with the --http-port option. For\nexample:\n    bfgminer --http-port 8330\nThen configure your blade to connect to your BFGMiner instance on the same port,\nwith a unique username per blade. It will then show up as a PXY device and\nshould work more or less like any other miner.\n\n\nBLOCK ERUPTER USB\n-----------------\n\nThese will autodetect if supported by the device; otherwise, you need to use\nthe '--scan-serial erupter:<device>' option to tell BFGMiner what device to\nprobe; if you know you have no other serial devices, or only ones that can\ntolerate garbage, you can use '--scan-serial erupter:all' to probe all serial\nports. They communicate with the Icarus protocol, which has some additional\noptions in README.FPGA\n\n\nCOMPAC\n------\n\nThese USB sticks are based on Bitmain's BM1384 chip, and use the antminer\ndriver. You can set the clock frequency with\n\n--set compac:clock=200\n\nYou can also adjust the clock real-time while the stick is hashing using RPC's pgaset:\n\nbfgminer-rpc \"pgaset|0,clock,x0982\"\n                     |       ^^^^^ hex frequency\n                     ^ device number\n\n\nHEX*FURY\n--------\n\nHex*Fury uses the bifury driver. Miners using earlier boards may need to\nworkaround bugs in the firmware:\n    bfgminer --set bifury:chips=6 --set bifury:free_after_job=no\nThis may cause poor behaviour or performance from other bifury-based devices.\nIf you encounter this, you can set the workarounds per-device by using their\nserial number (which can be seen in the TUI device manager; in this example,\n141407160211cdf):\n    bfgminer --set bifury@141407160211cdf:chips=15 ...\n\n\nKLONDIKE\n--------\n\n--klondike-options <arg> Set klondike options clock:temptarget\n\n\nKNCMINER (Jupiter)\n--------\n\nKnCMiner rigs use a BeagleBone Black (BBB) as the host; this is pluged into a\n\"cape\" with a FPGA and connections for 4-6 ASIC modules (depending on the cape\nversion). Note that in addition to the usual dependencies, this driver also\nrequires i2c-tools (aka libi2c-dev on some systems). The BBB comes with the\nÅngström Distribution by default. The following is a step by step install for\nBFGMiner on this system;\n\n-----------------Start------------\ncat >/etc/opkg/feeds.conf <<\\EOF\nsrc/gz noarch http://feeds.angstrom-distribution.org/feeds/v2013.06/ipk/eglibc/all/\nsrc/gz base http://feeds.angstrom-distribution.org/feeds/v2013.06/ipk/eglibc/armv7ahf-vfp-neon/base/\nsrc/gz beaglebone http://feeds.angstrom-distribution.org/feeds/v2013.06/ipk/eglibc/armv7ahf-vfp-neon/machine/beaglebone/\nEOF\n\nopkg update\nopkg install angstrom-feed-configs\nrm /etc/opkg/feeds.conf\nopkg update\n\nopkg install update-alternatives\nopkg install automake autoconf make gcc cpp binutils git less pkgconfig-dev ncurses-dev libtool nano bash i2c-tools-dev\nwhile ! opkg install libcurl-dev; do true; done\n\ncurl http://www.digip.org/jansson/releases/jansson-2.0.1.tar.bz2 | tar -xjvp\ncd jansson-2.0.1\n./configure --prefix=/usr CC=arm-angstrom-linux-gnueabi-gcc --disable-static NM=arm-angstrom-linux-gnueabi-nm\nmake install && ldconfig\ncd ..\n\ngit clone git://github.com/luke-jr/bfgminer\ncd bfgminer\n./autogen.sh\ngit clone git://github.com/troydhanson/uthash\n./configure --host=arm-angstrom-linux-gnueabi --enable-knc --disable-other-drivers CFLAGS=\"-I$PWD/uthash/src\"\nmake AR=arm-angstrom-linux-gnueabi-ar\n\n/etc/init.d/cgminer.sh stop\n./bfgminer -S knc:auto -c /config/cgminer.conf\n\n---------------END-------------\n\nKNCMINER (Titan)\n--------\n\nTitan uses RaspberryPi as a controller.\n\nBuild instructions:\n-----------------Start------------\n\ngit clone git@github.com:KnCMiner/bfgminer.git\ncd bfgminer\n./autogen.sh\n./configure --enable-scrypt --disable-sha256d --enable-titan --disable-other-drivers\nmake\nsudo /etc/init.d/bfgminer.sh restart\nscreen -r\n\n---------------END-------------\n\nMONARCH\n-------\n\nThe Butterfly Labs Monarch devices can be used as either USB devices, or in a\nPCI-Express slot. As USB devices, they are essentially plug-and-play. If you\nwish to use them via PCI-Express, however, you must first load the proper\ndriver. BFGMiner can work with either Linux uio (2.6.23+, requires root access)\nor Linux vfio (3.6+, requires IOMMU support).\n\nTo enable uio on your cards, you may need to do:\n    sudo modprobe uio_pci_generic\n    echo 1cf9 0001 | sudo tee /sys/bus/pci/drivers/uio_pci_generic/new_id\n\nEnabling vfio is similar, but allows you to run BFGMiner without root\nprivileges. Since setting this up is more complicated, BFGMiner includes a\nsetup-vfio script (which must be run with root permissions). Simply run:\n    sudo setup-vfio --unsafe --user $(whoami) 1cf9 0001\nYou will be asked about each Monarch found, and must answer 'yes' to each one.\n\nIf you wish to manually setup VFIO, follow these steps:\nFirst, load the kernel module:\n    sudo modprobe vfio-pci\nNext, identify what the device ids are for your card(s):\n    lspci -D | grep 1cf9  # the first number of each line is the device id\nFrom that, you can identify its IOMMU group, and list all devices sharing that\ngroup:\n    readlink \"/sys/bus/pci/devices/$DEVICE_ID/iommu_group\"\n    ls \"/sys/kernel/iommu_groups/$IOMMU_GROUP_ID/devices/\"\nAll of the devices listed (other than the Monarch), if any, will need to be\ndisabled and unbound! To do that, use:\n    echo \"$DEVICE_ID\" | sudo tee \"/sys/bus/pci/devices/$DEVICE_ID/driver/unbind\"\n    echo \"$DEVICE_CODE\" | sudo tee /sys/bus/pci/drivers/vfio-pci/new_id\nNote that $DEVICE_ID should be something like \"0000:01:00.0\" and $DEVICE_CODE is\nsomething like \"1cf9 0001\" (this example is the Monarch itself).\nIf you want to run BFGMiner as a normal user:\n    chown \"$USERNAME\" \"/dev/vfio/$IOMMU_GROUP_ID\"\nDepending on your system, you may also need to do:\n    echo 1 | sudo tee /sys/module/vfio_iommu_type1/parameters/allow_unsafe_interrupts\n\n\nONESTRINGMINER\n--------------\n\nOneStringMiner boards use the bifury driver. Miners using earlier boards may\nneed to workaround bugs in the firmware:\n    bfgminer --set bifury:chips=15 --set bifury:free_after_job=no\nIf you have different devices using the bifury driver, see the section on\nHex*Fury for applying workarounds per-device.\n\n\nGRIDSEED\n--------\n\nGridseed units, at the present time, come in two versions: Blade - a 40 chip\nunit and Orb - a 5 chip unit. Orb units can be used to mine both SHA256d and\nscrypt based coins whereas the Blade is scrypt only, although BFGMiner only\nsupports scrypt mode at this time.\n\nBFGMiner allows a miner to connect both types of units to a single miner\ninstance and provides for granular control of the clock frequencies for each\ndevice and each chip on each device. The basic use of this feature is to use the\n--set option on from the command line:\n\nbfgminer --scrypt -S gridseed:all --set gridseed@<serial_number>:clock=825\n\nfor multiple devices, add multiple --set arguments.\n\nAdditionally, these can be added to the bfgminer.conf file for persistence like\nthis:\n\n\"set\" : [\n        \"gridseed@<serial_number>:clock=825\",\n        \"gridseed@<serial_number>:clock=850\",\n        \"gridseed@<serial_number>:clock=875\"\n]\n\nTo find the device serial number, start bfgminer and press <M> to manage\ndevices, then <Page Down> or <down arrow> through the list of devices and take\nnote of the device serial number in the device information shown.\n\n...\nSelect processor to manage using up/down arrow keys\n GSD 0a:       |  74.4/ 72.9/ 10.2kh/s | A:  1 R:0+0(none) HW:0/none\n  STM32 Virtual COM Port from STMicroelectronics\nSerial: 6D85278F5650\nClock speed: 875\n...\n\nSo for example, an entry would look like this:\n        gridseed@6D85278F5650:clock=875\n\n\nZEUSMINER\n---------\n\nZeusminers do not support autodetection, so you will need to use --scan to probe\nfor them:\n\n-S zeusminer:\\\\.\\COM3\n\nYou should also configure the driver for your specific device:\n\n    --set zeusminer:clock=N        Clock frequency (default: 328)\n    --set zeusminer:chips=N        Number of chips per device\n        Blizzard    :  6          Cyclone     :  96\n        Hurricane X2: 48 (2*24)   Hurricane X3:  64 (2*32)\n        Thunder   X2: 96 (4*24)   Thunder   X3: 128 (4*32)\nNote: if you set this option incorrectly, the device may underperform and/or\n      misreport hashrate.\n\nFor example:\n\nbfgminer --scrypt -o stratum+tcp://pool:port -u user -p pass -S zeusminer:\\\\.\\COM3 --set zeusminer:clock=328 --set zeusminer:chips=128\n\n---\n\nThis code is provided entirely free of charge by the programmer in his spare\ntime so donations would be greatly appreciated. Please consider donating to the\naddress below.\n\nLuke-Jr <luke-jr+bfgminer@utopios.org>\n1QATWksNFGeUJCWBrN4g6hGM178Lovm7Wh\n"
        },
        {
          "name": "README.CPU",
          "type": "blob",
          "size": 2.4482421875,
          "content": "EXECUTIVE SUMMARY ON CPU USAGE:\n\nBy default, BFGMiner will NOT mine on CPUs unless it is explicitly compiled with\nsupport and told to do so. CPU mining for bitcoin is generally considered to be\nobsolete as it requires considerably more power per hash computed than either\nGPU, FPGA or ASIC based mining. If you still wish to mine using CPUs you will\nneed to build a custom binary with support enabled (refer to the build notes in\nREADME for further information).\n\nThe following CPU mining options are available:\n\n--algo <arg>        Specify sha256 implementation for CPU mining:\n        fastauto*       Quick benchmark at startup to pick a working algorithm\n        auto            Benchmark at startup and pick fastest algorithm\n        c               Linux kernel sha256, implemented in C\n        4way            tcatm's 4-way SSE2 implementation\n        via             VIA padlock implementation\n        cryptopp        Crypto++ C/C++ implementation\n        cryptopp_asm32  Crypto++ 32-bit assembler implementation\n        sse2_32         SSE2 32 bit implementation for i386 machines\n        sse2_64         SSE2 64 bit implementation for x86_64 machines\n        sse4_64         SSE4.1 64 bit implementation for x86_64 machines\n        altivec_4way    Altivec implementation for PowerPC G4 and G5 machines\n--cpu-threads <arg> Number of miner CPU threads (default: -1)\n\nCPU FAQ:\n\nQ: What happened to CPU mining?\nA: Being increasingly irrelevant for most users, and a maintenance issue, it is\nno longer under active development and will not be supported unless someone\nsteps up to help maintain it. No binary builds supporting CPU mining will be\nreleased for Windows but CPU mining can be built into BFGMiner when it is\ncompiled. For builds which do support CPU mining, it is still disabled by\ndefault, and must be enabled using the -S cpu:auto option.\n\nQ: So, should I even try CPU mining?\nA: No, it honestly will waste more power and time than it is worth at this stage.\nIf you really wish to mine, you are better off getting a suitable ASIC instead.\n\nQ: But, if the computers aren't mine and I'm not paying for the power?\nA: If you are trying to use computers that aren't yours, you really should\nreconsider. Attempting to mine with a large number of devices will often impact\nnegatively on many pools and will likely pay almost nothing due to the small\nnumber of successful shares submitted. Apart from that, you will probably get\ninto trouble with someone down the track for misusing the computers.\n"
        },
        {
          "name": "README.FPGA",
          "type": "blob",
          "size": 13.3193359375,
          "content": "\nThis README contains extended details about FPGA mining with BFGMiner\n\n\nModMiner (MMQ)\n--------------\n\nModMiner does not have any persistent storage for bitstreams, so BFGMiner must\nupload it after power on. For this to work, you must first download the\nnecessary bitstream file to BFGMiner's \"bitstreams\" directory, and give it the\nname \"fpgaminer_x6500-overclocker-0402.bit\". You can download this bitstream\nfrom FPGA Mining LLC's website:\n    http://www.fpgamining.com/documentation/firmware\n\n-\n\nIf the MMQ doesn't respond to BFGMiner at all, or the red LED isn't flashing\nthen you will need to reset the MMQ.\n\nThe red LED should always be flashing when it is mining or ready to mine.\n\nTo reset the MMQ, you are best to press the left \"RESET\" button on the\nbackplane, then unplug and replug the USB cable.\n\nIf your MMQ doesn't have a button on the \"RESET\" pad, you need to join the two\nleft pads of the \"RESET\" pad with conductive wire to reset it. Cutting a small\n(metal) paper-clip in half works well for this.\n\nThen unplug the USB cable, wait for 5 seconds, then plug it back in.\n\nAfter you press reset, the red LED near the USB port should blink continuously.\n\nIf it still wont work, power off, wait for 5 seconds, then power on the MMQ\nThis of course means it will upload the bitstream again when you start BFGMiner.\n\n-\n\nDevice 0 is on the power end of the board.\n\n-\n\nYou must make sure you have an appropriate firmware in your MMQ\nRead here for official details of changing the firmware:\n http://wiki.btcfpga.com/index.php?title=Firmware\n\nThe basics of changing the firmware are:\n You need two short pieces of conductive wire if your MMQ doesn't have buttons\n on the \"RESET\" and \"ISP\" pads on the backplane board.\n Cutting a small (metal) paper-clip in half works well for this.\n\n Join the 2 left pads of the \"RESET\" pad with wire and the led will dim.\n Without disconnecting the \"RESET\", join the 2 left pads of the \"ISP\" pad with\n a wire and it will stay dim.\n Release \"RESET\" then release \"ISP\" and is should still be dim.\n Unplug the USB and when you plug it back in it will show up as a mass storage\n device.\n  Linux: (as one single line):\n   mcopy -i /dev/disk/by-id/usb-NXP_LPC134X_IFLASH_ISP000000000-0:0\n      modminer091012.bin ::/firmware.bin\n  Windows: delete the MSD device file firmware.bin and copy in the new one\n   rename the new file and put it under the same name 'firmware.bin'\n Disconnect the USB correctly (so writes are flushed first)\n Join and then disconnect \"RESET\" and then plug the USB back in and it's done.\n\nBest to update to one of the latest 2 listed below if you don't already\nhave one of them in your MMQ.\n\nThe current latest different firmware are:\n\n Latest for support of normal or TLM bitstream:\n  http://btcfpga.com/files/firmware/modminer092612-TLM.bin\n\n Latest with only normal bitstream support (Temps/HW Fix):\n  http://btcfpga.com/files/firmware/modminer091012.bin\n\nThe code is currently tested on the modminer091012.bin firmware.\nThis comment will be updated when others have been tested.\n\n-\n\nOn many Linux distributions there is an app called modem-manager that may cause\nproblems when it is enabled, due to opening the MMQ device and writing to it.\n\nThe problem will typically present itself by the flashing led on the backplane\ngoing out (no longer flashing) and it takes a power cycle to re-enable the MMQ\nfirmware - which then can lead to the problem reoccurring.\n\nYou can either disable/uninstall modem-manager if you don't need it or:\na (hack) solution to this is to blacklist the MMQ USB device in\n/lib/udev/rules.d/77-mm-usb-device-blacklist.rules\n\nAdding 2 lines like this (just above APC) should help.\n# MMQ\nATTRS{idVendor}==\"1fc9\", ATTRS{idProduct}==\"0003\", ENV{ID_MM_DEVICE_IGNORE}=\"1\"\n\nThe change will be lost and need to be re-done, next time you update the\nmodem-manager software.\n\n\nBitForce (BFL)\n--------------\n\n--bfl-range         Use nonce range on BitForce devices if supported\n\nThis option is only for BitForce devices. Earlier devices such as the single\ndid not have any way of doing small amounts of work which meant that a lot of\nwork could be lost across block changes. Some of the Mini Rigs have support\nfor doing this, so less work is lost across a longpoll. However, it comes at\na cost of 1% in overall hashrate so this feature is disabled by default. It\nis only recommended you enable this if you are mining with a Mini Rig on\nP2Pool.\n\nBitFORCE FPGA Single units can have their bitstream modified using the\nbitforce-firmware-flash utility on Linux, which can be obtained from:\n    https://github.com/luke-jr/bitforce-fpga-firmware-flash\nIt is untested with other devices. Use at your own risk! Windows users may use\nButterfly Labs EasyMiner to change firmware.\n\nTo compile:\n make bitforce-firmware-flash\nTo flash your BFL, specify the BFL port and the flash file e.g.:\n sudo ./bitforce-firmware-flash /dev/ttyUSB0 alphaminer_832.bfl\nIt takes a bit under 3 minutes to flash a BFL and shows a progress % counter\nOnce it completes, you may also need to wait about 15 seconds, then power the\nBFL off and on again.\n\nIf you get an error at the end of the BFL flash process stating:\n \"Error reading response from ZBX\"\nit may have worked successfully anyway.\nTest mining on it to be sure if it worked or not.\n\nYou need to give BFGMiner about 10 minutes mining with the BFL to be sure of\nthe Mh/s value reported with the changed firmware - and the Mh/s reported will\nbe less than the firmware speed since you lose work on every block change.\n\n\nIcarus (ICA)\n------------\n\nThere are a number of options for Icarus-compatible devices which can be used\nwith --set-devices (or the RPC pgaset method):\n\n    baud=N           The serial baud rate (default 115200)\n    work_division=N  The fraction of work divided up for each processor: 1, 2,\n                     4, or 8. e.g. 2 means each does half the nonce range\n                     (default 2)\n    fpga_count=N     The actual number of processors working; this would\n                     normally be the same as work_division. Range is from 1 up\n                     to <work_division>. It defaults to the value of\n                     work_division, or 2 if you don't specify work_division.\n    reopen=MODE      Controls how often the driver reopens the device to\n                     workaround issues. Choices are 'never', on 'timeout' only\n                     (default), or every 'cycle'.\n    timing=MODE      Set how the timing is calculated:\n                         default[=N]   Use the default hash time\n                         short[=N]     Calculate the hash time and stop\n                                       adjusting it at ~315 difficulty 1 shares\n                                       (~1hr)\n                         long=[N]      Re-calculate the hash time continuously\n                         value[=N]     Specify the hash time in nanoseconds\n                                       (e.g. 2.6316) and abort time (e.g.\n                                       2.6316=80).\n\nAn example would be: --set-device ECM:baud=57600 --set-device\nECM:work_division=2 --set-device DCM:fpga_count=1 --set-device ECM:reopen=never\nThis would mean: use 57600 baud, the FPGA board divides the work in half however\nonly 1 FPGA actually runs on the board, and don't reopen the device (e.g. like\nan early CM1 Icarus copy bitstream).\n\nIcarus timing is used to determine the number of hashes that have been checked\nwhen it aborts a nonce range (including on a longpoll).\nIt is also used to determine the elapsed time when it should abort a nonce\nrange to avoid letting the Icarus go idle, but also to safely maximise that\ntime.\n\n'short' or 'long' mode should only be used on a computer that has enough CPU\navailable to run BFGMiner without any CPU delays.\nAny CPU delays while calculating the hash time will affect the result\n'short' mode only requires the computer to be stable until it has completed\n~315 difficulty 1 shares, 'long' mode requires it to always be stable to ensure\naccuracy, however, over time it continually corrects itself.\nThe optional additional =N for 'short' or 'long' specifies the limit to set the\ntimeout to in deciseconds; thus if the timing code calculation is higher while\nrunning, it will instead use the limit.\nThis can be set to the appropriate value to ensure the device never goes idle\neven if the calculation is negatively affected by system performance.\n\nWhen in 'short' or 'long' mode, it will report the hash time value each time it\nis re-calculated.\nIn 'short' or 'long' mode, the scan abort time starts at 5 seconds and uses the\ndefault 2.6316ns scan hash time, for the first 5 nonces or one minute\n(whichever is longer).\n\nIn 'default' or 'value' mode the 'constants' are calculated once at the start,\nbased on the default value or the value specified.\nThe optional additional =N specifies to set the default abort at N 1/10ths of a\nsecond, not the calculated value, which is 112 for 2.6316ns\n\nTo determine the hash time value for a non Icarus Rev3 device or an Icarus Rev3\nwith a different bitstream to the default one, use 'long' mode and give it at\nleast a few hundred shares, or use 'short' mode and take note of the final hash\ntime value (Hs) calculated.\nYou can also use the RPC API 'stats' command to see the current hash time (Hs)\nat any time.\n\nThe Icarus code currently only works with devices that support the same commands\nas Icarus Rev3 requires and also is less than ~840Mh/s and greater than 2Mh/s.\nIf your device does hash faster than ~840Mh/s it should work correctly if you\nsupply the correct hash time nanoseconds value.\n\nThe timing code itself will affect the Icarus performance since it increases\nthe delay after work is completed or aborted until it starts again.\nThe increase is, however, extremely small and the actual increase is reported\nwith the RPC API 'stats' command (a very slow CPU will make it more noticeable).\nUsing the 'short' mode will remove this delay after 'short' mode completes.\nThe delay doesn't affect the calculation of the correct hash time.\n\n\nX6500\n-----\n\nSince X6500 FPGAs do not use serial ports for communication, the --scan-serial\noption instead works with product serial numbers. By default, any devices with\nthe X6500 USB product id will be used, but some X6500s may have shipped without\nthis product id being configured. If you have any of these, you will need to\nspecify their serial numbers explicitly, and also add -S x6500:auto if you\nstill want to use the autodetection for other properly-configured FPGAs.\nThe serial number of X6500s is usually found on a label applied to the ATX\npower connector slot. If yours is missing, devices seen by the system can be\ndisplayed by starting bfgminer in debug mode. To get a simple list of devices,\nwith the debug output shown, you can use: bfgminer -D -d? -T\n\nX6500 does not have any persistent storage for bitstreams, so BFGMiner must\nupload it after power on. For this to work, you must first download the\nnecessary bitstream file to BFGMiner's \"bitstreams\" directory, and give it the\nname \"fpgaminer_x6500-overclocker-0402.bit\". You can download this bitstream\nfrom FPGA Mining LLC's website:\n    http://www.fpgamining.com/documentation/firmware\n\n\nZTEX FPGA Boards\n----------------\n\nhttp://www.ztex.de sells two boards suitable for mining: the 1.15x with 1 FPGA\nand the 1.15y with 4 FPGAs. ZTEX distributes their own mining software and\ndrivers. BFGMiner has full support for these boards, as long as they have at\nleast the \"dummy\" mining bitstreams installed on them.\n\nIf your boards do not have a mining bitstream yet, you must first, install\nZTEX's BTCMiner (requires Java JDK version 6 or later) and install one.\n\n=== WINDOWS NOTE ===\nUpon first powering up and connecting the board via USB, windows will attempt\nand fail to find the appropriate drivers.  To load the initial firmware on the\nboard, you'll need the EZ-USB FX2 SDK from here:\n    http://www.ztex.de/downloads/#firmware_kit\nExtract the firmware kit and use the driver within libusb-win32/ztex.inf.\nWindows should now recognize the board and you're ready to program it.\n=== END OF WINDOWS ===\n\nGrab the latest miner jar from http://www.ztex.de/btcminer/#download and program\nthe appropriate dummy firmware for your board.  The command should look\nsomething like (for a single FPGA board):\n    java -cp ZtexBTCMiner-120417.jar BTCMiner -m p -f **FILENAME** -s 01-02-01\nFor ZTEX 1.15x boards, the dummy bitstream filename is ztex_ufm1_15d.ihx\nFor ZTEX 1.15y boards, the dummy bitstream filename is ztex_ufm1_15y.ihx\n\n=== WINDOWS NOTE ===\nTo mine using BFGMiner, you'll have to swap the USB drivers. The BFGMiner-\ncompatible WinUSB drivers for the board can be generated with this tool:\n    http://sourceforge.net/projects/libwdi/files/zadig/\nBasic usage instructions for Zadig can be found here:\n    https://github.com/pbatard/libwdi/wiki/Zadig\nOnce Zadig generates and installs a WinUSB driver, ensure everything is working\nby running:\n    bfgminer -D -d? -T\nYou should see something like this in the output:\n    [2013-01-22 20:19:11] Found 1 ztex board\n    [2013-01-22 20:19:11] ZTX 0: Found Ztex (ZTEX 0001-02-01-1)\n=== END OF WINDOWS ===\n\nIf you have installed a dummy bitstream, you will now need to copy the main\nmining bitstream where BFGMiner can find it. This are usually the same as the\ndummy bitstream filename, but with a number added to the end. Extract the\nZtexBTCMiner-120417.jar file using any unzip utility, and look for the proper\n*.ihx and *.bit files (the latter will be inside the 'fpga' directory of the\njar). Copy them to BFGMiner's \"bitstreams\" directory, and you're ready to start\nmining.\n"
        },
        {
          "name": "README.GPU",
          "type": "blob",
          "size": 24.0478515625,
          "content": "EXECUTIVE SUMMARY ON GPU USAGE (SEE ALSO README.scrypt FOR SCRYPT MINING):\n\nBy default, BFGMiner will NOT mine on any GPUs unless in scrypt mode. If you\nwish to use your GPU to mine SHA256d (generally not a good idea), you can\nexplicitly enable it with the -S opencl:auto option.\n\nSingle pool, regular desktop:\n\nbfgminer -S opencl:auto -o http://pool:port -u username -p password\n\nIf you have configured your system properly, BFGMiner will mine on all GPUs in\n\"dynamic\" mode which is designed to keep your system usable and sacrifice some\nmining performance.\n\nSingle pool, dedicated miner:\n\nbfgminer -S opencl:auto -o http://pool:port -u username -p password --set-device intensity=9\n\nSingle pool, first card regular desktop, 3 other dedicated cards:\n\nbfgminer -S opencl:auto -o http://pool:port -u username -p password --set-device intensity=9 --set-device OCL0:intensity=d\n\nMultiple pool, dedicated miner:\n\nbfgminer -S opencl:auto -o http://pool1:port -u pool1username -p pool1password -o http://pool2:port -u pool2usernmae -p pool2password --set-device intensity=9\n\nAdd overclocking settings, GPU and fan control for all cards:\n\nbfgminer -S opencl:auto -o http://pool:port -u username -p password --set-device intensity=9 --auto-fan --auto-gpu --set-device OCL:clock=750-950 --set-device OCL:memclock=300\n\nAdd overclocking settings, GPU and fan control with different engine settings for 4 cards:\n\nbfgminer -S opencl:auto -o http://pool:port -u username -p password --set-device intensity=9 --auto-fan --auto-gpu --set-device OCL0:clock=750-950 --set-device OCL1:clock=945 --set-device OCL2:clock=700-930 --set-device OCL3:clock=960 --set-device OCL:memclock=300\n\nREAD WARNINGS AND DOCUMENTATION BELOW ABOUT OVERCLOCKING\n\nTo configure multiple displays on linux you need to configure your Xorg cleanly\nto use them all:\n\nsudo aticonfig --adapter=all -f --initial\n\nOn Linux you virtually always need to export your display settings before\nstarting to get all the cards recognised and/or temperature+clocking working:\n\nexport DISPLAY=:0\n\n---\nSETUP FOR GPU SUPPORT:\n\nTo setup GPU mining support:\n\nInstall the AMD APP sdk, ideal version (see FAQ!) - put it into a system\nlocation.\nDownload the correct version for either 32 bit or 64 bit from here:\n\thttp://developer.amd.com/tools/heterogeneous-computing/amd-accelerated-parallel-processing-app-sdk/downloads/\n\nThe best version for Radeon 5xxx and 6xxx is v2.5, while 7xxx cards need v2.6 or\nlater, 2.7 seems the best.\n\nFor versions 2.4 or earlier you will need to manually install them:\nThis will give you a file with a name like:\n AMD-APP-SDK-v2.4-lnx64.tgz (64-bit)\nor\n AMD-APP-SDK-v2.4-lnx32.tgz (32-bit)\n\nThen:\n\nsudo -i\ncd /opt\ntar xf /path/to/AMD-APP-SDK-v2.4-lnx##.tgz\ncd /\ntar xf /opt/AMD-APP-SDK-v2.4-lnx##/icd-registration.tgz\nln -s /opt/AMD-APP-SDK-v2.4-lnx##/include/CL /usr/include\nln -s /opt/AMD-APP-SDK-v2.4-lnx##/lib/x86_64/* /usr/lib/\nldconfig\n\nWhere ## is 32 or 64, depending on the bitness of the SDK you downloaded.\nIf you are on 32 bit, x86_64 in the 2nd last line should be x86\n\n\n---\nINTENSITY INFORMATION:\n\nIntensity correlates with the size of work being submitted at any one time to\na GPU. The higher the number the larger the size of work. Generally speaking\nfinding an optimal value rather than the highest value is the correct approach\nas hash rate rises up to a point with higher intensities but above that, the\ndevice may be very slow to return responses, or produce errors.\n\nNOTE: Running intensities above 9 with current hardware is likely to only\ndiminish return performance even if the hash rate might appear better. A good\nstarting baseline intensity to try on dedicated miners is 9. 11 is the upper\nlimit for intensity while Bitcoin mining, if the GPU_USE_SYNC_OBJECTS variable\nis set (see FAQ). The upper limit for SHA256d mining is 14 and 20 for scrypt.\n\n\n---\nOVERCLOCKING WARNING AND INFORMATION\n\nAS WITH ALL OVERCLOCKING TOOLS YOU ARE ENTIRELY RESPONSIBLE FOR ANY HARM YOU\nMAY CAUSE TO YOUR HARDWARE. OVERCLOCKING CAN INVALIDATE WARRANTIES, DAMAGE\nHARDWARE AND EVEN CAUSE FIRES. THE AUTHOR ASSUMES NO RESPONSIBILITY FOR ANY\nDAMAGE YOU MAY CAUSE OR UNPLANNED CHILDREN THAT MAY OCCUR AS A RESULT.\n\nThe GPU monitoring, clocking and fanspeed control incorporated into BFGMiner\ncomes through use of the ATI Display Library. As such, it only supports ATI\nGPUs. Even if ADL support is successfully built into BFGMiner, unless the card\nand driver supports it, no GPU monitoring/settings will be available.\n\nBFGMiner supports initial setting of GPU engine clock speed, memory clock\nspeed, voltage, fanspeed, and the undocumented powertune feature of 69x0+ GPUs.\nThe setting passed to BFGMiner is used by all GPUs unless separate values are\nspecified. All settings can all be changed within the menu on the fly on a\nper-GPU basis.\n\nFor example:\n--set-device OCL:clock=950 --set-device OCL:memclock=825\n\nwill try to set all GPU engine clocks to 950 and all memory clocks to 825,\nwhile:\n--set-device OCL0:clock=950 --set-device OCL1:clock=945 --set-device OCL2:clock=930 --set-device OCL3:clock=960 --set-device OCL:memclock=300\n\nwill try to set the engine clock of card 0 to 950, 1 to 945, 2 to 930, 3 to\n960 and all memory clocks to 300.\n\nAUTO MODES:\nThere are two \"auto\" modes in BFGMiner, --auto-fan and --auto-gpu. These can be\nused independently of each other and are complementary. Both auto modes are\ndesigned to safely change settings while trying to maintain a target\ntemperature. By default this is set to 75 degrees C but can be changed with the\n--set-device option. For example:\n\n--set-device OCL:temp-target=80\nSets all cards' target temperature to 80 degrees.\n\n--set-device OCL0:temp-target=75 --set-device OCL1:temp-target=85\nSets card 0 target temperature to 75, and card 1 to 85 degrees.\n\nAUTO FAN:\ne.g.\n--auto-fan (implies 85% upper limit)\n--set-device OCL0:fan=25-85 --set-device OCL1:fan=65 --auto-fan\n\nFan control in auto fan works off the theory that the minimum possible fan\nrequired to maintain an optimal temperature will use less power, make less\nnoise, and prolong the life of the fan. In auto-fan mode, the fan speed is\nlimited to 85% if the temperature is below \"overheat\" intentionally, as higher\nfanspeeds on GPUs do not produce signficantly more cooling, yet significantly\nshorten the lifespan of the fans. If temperature reaches the overheat value,\nfanspeed will still be increased to 100%. The overheat value is set to 85\ndegrees by default and can be changed with the temp_overheat setting:\n\ne.g.\n--set-device OCL0:temp_overheat=75 --set-device OCL1:temp_overheat=85\nSets card 0 overheat threshold to 75 degrees and card 1 to 85.\n\nAUTO GPU:\ne.g.\n--auto-gpu --set-device OCL:clock=750-950\n--auto-gpu --set-device OCL0:clock=750-950 --set-device OCL1:clock=945 --set-device OCL2:clock=700-930 --set-device OCL3:clock=960\n\nGPU control in auto gpu tries to maintain as high a clock speed as possible\nwhile not reaching overheat temperatures. As a lower clock speed limit, the\nauto-gpu mode checks the GPU card's \"normal\" clock speed and will not go below\nthis unless you have manually set a lower speed in the range. Also, unless a\nhigher clock speed was specified at startup, it will not raise the clockspeed.\nIf the temperature climbs, fanspeed is adjusted and optimised before GPU engine\nclockspeed is adjusted. If fan speed control is not available or already\noptimal, then GPU clock speed is only decreased if it goes over the target\ntemperature by the hysteresis amount, which is set to 3 by default and can be\nchanged with:\n--temp-hysteresis\nIf the temperature drops below the target temperature, and engine clock speed\nis not at the highest level set at startup, BFGMiner will raise the clock speed.\nIf at any time you manually set an even higher clock speed successfully in\nBFGMiner, it will record this value and use it as its new upper limit (and the\nsame for low clock speeds and lower limits). If the temperature goes over the\ncutoff limit (95 degrees by default), BFGMiner will completely disable the GPU\nfrom mining and it will not be re-enabled unless manually done so. The cutoff\ntemperature can be changed with:\n\n--set-device OCL0:temp-cutoff=95 --set-device OCL1:temp-cutoff=105\nSets card 0 cutoff temperature to 95 and card 1 to 105.\n\n--set-device OCL:memdiff=-125\nThis setting will modify the memory speed whenever the GPU clock speed is\nmodified by --auto-gpu. In this example, it will set the memory speed to be 125\nMHz lower than the GPU speed. This is useful for some cards like the 6970 which\nnormally don't allow a bigger clock speed difference. The 6970 is known to only\nallow -125, while the 7970 only allows -150.\n\n\nCHANGING SETTINGS:\nWhen setting values, it is important to realise that even though the driver\nmay report the value was changed successfully, and the new card power profile\ninformation contains the values you set it to, that the card itself may\nrefuse to use those settings. As the performance profile changes dynamically,\nquerying the \"current\" value on the card can be wrong as well. So when changing\nvalues in BFGMiner, after a pause of 1 second, it will report to you the current\nvalues where you should check that your change has taken. An example is that\n6970 reference cards will accept low memory values but refuse to actually run\nthose lower memory values unless they're within 125 of the engine clock speed.\nIn that scenario, they usually set their real speed back to their default.\n\nBFGMiner reports the so-called \"safe\" range of whatever it is you are modifying\nwhen you ask to modify it on the fly. However, you can change settings to values\noutside this range. Despite this, the card can easily refuse to accept your\nchanges, or worse, to accept your changes and then silently ignore them. So\nthere is absolutely to know how far to/from where/to it can set things safely or\notherwise, and there is nothing stopping you from at least trying to set them\noutside this range. Being very conscious of these possible failures is why\nBFGMiner will report back the current values for you to examine how exactly the\ncard has responded. Even within the reported range of accepted values by the\ncard, it is very easy to crash just about any card, so it cannot use those\nvalues to determine what range to set. You have to provide something meaningful\nmanually for BFGMiner to work with through experimentation.\n\nSTARTUP / SHUTDOWN:\nWhen BFGMiner starts up, it tries to read off the current profile information\nfor clock and fan speeds and stores these values. When quitting BFGMiner, it\nwill then try to restore the original values. Changing settings outside of\nBFGMiner while it's running may be reset to the startup BFGMiner values when\nBFGMiner shuts down because of this.\n\n---\n\nGPU DEVICE ISSUES and use of --gpu-map\n\nGPUs mine with OpenCL software via the GPU device driver. This means you need\nto have both an OpenCL SDK installed, and the GPU device driver RUNNING (i.e.\nXorg up and running configured for all devices that will mine on linux etc.)\nMeanwhile, the hardware monitoring that BFGMiner offers for AMD devices relies\non the ATI Display Library (ADL) software to work. OpenCL DOES NOT TALK TO THE\nADL. There is no 100% reliable way to know that OpenCL devices are identical\nto the ADL devices, as neither give off the same information. BFGMiner does its\nbest to correlate these devices based on the order that OpenCL and ADL numbers\nthem. It is possible that this will fail for the following reasons:\n\n1. The device order is listed differently by OpenCL and ADL (rare), even if the\nnumber of devices is the same.\n2. There are more OpenCL devices than ADL. OpenCL stupidly sees one GPU as two\ndevices if you have two monitors connected to the one GPU.\n3. There are more ADL devices than OpenCL. ADL devices include any ATI GPUs,\nincluding ones that can't mine, like some older R4xxx cards.\n\nTo cope with this, the ADVANCED option for --gpu-map is provided with BFGMiner.\nDO NOT USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING. The default will work the\nvast majority of the time unless you know you have a problem already.\n\nTo get useful information, start BFGMiner with just the -n option. You will get\noutput that looks like this:\n\n[2012-04-25 13:17:34] CL Platform 0 vendor: Advanced Micro Devices, Inc.\n[2012-04-25 13:17:34] CL Platform 0 name: AMD Accelerated Parallel Processing\n[2012-04-25 13:17:34] CL Platform 0 version: OpenCL 1.1 AMD-APP (844.4)\n[2012-04-25 13:17:34] Platform 0 devices: 3\n[2012-04-25 13:17:34]   0       Tahiti\n[2012-04-25 13:17:34]   1       Tahiti\n[2012-04-25 13:17:34]   2       Cayman\n[2012-04-25 13:17:34] GPU 0 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 1 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 2 AMD Radeon HD 6900 Series hardware monitoring enabled\n[2012-04-25 13:17:34] 3 GPU devices max detected\n\nNote the number of devices here match, and the order is the same. If devices 1\nand 2 were different between Tahiti and Cayman, you could run BFGMiner with:\n--gpu-map 2:1,1:2\nAnd it would swap the monitoring it received from ADL device 1 and put it to\nOpenCL device 2 and vice versa.\n\nIf you have 2 monitors connected to the first device it would look like this:\n\n[2012-04-25 13:17:34] Platform 0 devices: 4\n[2012-04-25 13:17:34]   0       Tahiti\n[2012-04-25 13:17:34]   1       Tahiti\n[2012-04-25 13:17:34]   2       Tahiti\n[2012-04-25 13:17:34]   3       Cayman\n[2012-04-25 13:17:34] GPU 0 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 1 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 2 AMD Radeon HD 6900 Series hardware monitoring enabled\n\nTo work around this, you would use:\n-d 0 -d 2 -d 3 --gpu-map 2:1,3:2\n\nIf you have an older card as well as the rest it would look like this:\n\n[2012-04-25 13:17:34] Platform 0 devices: 3\n[2012-04-25 13:17:34]   0       Tahiti\n[2012-04-25 13:17:34]   1       Tahiti\n[2012-04-25 13:17:34]   2       Cayman\n[2012-04-25 13:17:34] GPU 0 AMD Radeon HD 4500 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 1 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 2 AMD Radeon HD 7900 Series  hardware monitoring enabled\n[2012-04-25 13:17:34] GPU 3 AMD Radeon HD 6900 Series hardware monitoring enabled\n\nTo work around this you would use:\n--gpu-map 0:1,1:2,2:3\n\n\n---\nGPU FAQ:\n\nQ: Can I change the intensity settings individually for each GPU?\nA: Yes, specify the devices by identifier: --set-device intensity=9 --set-device\nOCL0:intensity=d --set-device OCL1:intensity=4 (be sure you set the catch-all\nfirst!)\n\nQ: The CPU usage is high.\nA: The ATI drivers after 11.6 have a bug that makes them consume 100% of one\nCPU core unnecessarily, so downgrade to 11.6. Binding BFGMiner to one CPU core\non windows can minimise it to 100% (instead of more than one core). Driver\nversion 11.11 on linux and 11.12 on windows appear to have fixed this issue.\nNote that later drivers may have an apparent return of high CPU usage. Try\n'export GPU_USE_SYNC_OBJECTS=1' on Linux before starting BFGMiner. You can also\nset this variable in windows via a batch file or on the command line before\nstarting BFGMiner with 'setx GPU_USE_SYNC_OBJECTS 1'\n\nQ: My GPU hangs and I have to reboot it to get it going again?\nA: The more aggressively the mining software uses your GPU, the less overclock\nyou will be able to run. You are more likely to hit your limits with BFGMiner\nand you will find you may need to overclock your GPU less aggressively. The\nsoftware cannot be responsible and make your GPU hang directly. If you simply\ncannot get it to ever stop hanging, try decreasing the intensity, and if even\nthat fails, try changing to the poclbm kernel with --set-device\nOCL:kernel=poclbm, though you will sacrifice performance. BFGMiner is designed\nto try and safely restart GPUs as much as possible, but NOT if that restart\nmight actually crash the rest of the GPUs mining, or even the machine. It tries\nto restart them with a separate thread and if that separate thread dies, it\ngives up trying to restart any more GPUs.\n\nQ: Can you change the autofan/autogpu to change speeds in a different manner?\nA: The defaults are sane and safe. I'm not interested in changing them further.\nThe starting fan speed is set to 50% in auto-fan mode as a safety precaution.\n\nQ: I upgraded BFGMiner version and my hashrate suddenly dropped!\nA: No, you upgraded your SDK version unwittingly between upgrades of BFGMiner\nand that caused your hashrate to drop. Please see the next question.\n\nQ: I upgraded my ATI driver/SDK/BFGMiner and my hashrate suddenly dropped!\nA: The hashrate performance in BFGMiner is tied to the version of the ATI SDK\nthat is installed only for the very first time BFGMiner is run. This generates\nbinaries that are used by the GPU every time after that. Any upgrades to the\nSDK after that time will have no effect on the binaries. However, if you\ninstall a fresh version of BFGMiner, and have since upgraded your SDK, new\nbinaries will be built. It is known that the 2.6 ATI SDK has a huge hashrate\npenalty on generating new binaries. It is recommended to not use this SDK at\nthis time unless you are using an ATI 7xxx card that needs it.\n\nQ: Which AMD SDK is the best for BFGMiner?\nA: At the moment, versions 2.4 and 2.5 work the best for 5xxx and 6xxx GPUs. SDK\n2.6 or 2.7 works best for 7xxx. SDK 2.8 is known to have many problems. If you\nneed to use the 2.6+ SDK (7xxx and later), the phatk kernel will perform poorly,\nwhile the diablo or (modified) poclbm kernel are optimised for it.\n\nQ: Which AMD driver is the best?\nA: Unfortunately AMD has a history of having quite a few releases with issues\nwhen it comes to mining, either in terms of breaking mining, increasing CPU\nusage or very low hashrates. Only experimentation can tell you for sure, but\nsome good releases were 11.6, 11.12, 12.4 and 12.8. Note that older cards may\nnot work with the newer drivers.\n\nQ: I have multiple SDKs installed, can I choose which one it uses?\nA: Run bfgminer with the -n option and it will list all the platforms currently\ninstalled. Then you can tell BFGMiner which platform to use with --gpu-platform.\n\nQ: BFGMiner reports no devices or only one device on startup on Linux although\nI have multiple devices and drivers+SDK installed properly?\nA: Try \"export DISPLAY=:0\" before running BFGMiner.\n\nQ: BFGMiner crashes immediately on startup.\nA: One of the common reasons for this is that you have mixed files on your\nmachine for the driver or SDK. Windows has a nasty history of not cleanly\nuninstalling files so you may have to use third party tools like driversweeper\nto remove old versions. The other common reason for this is windows antivirus\nsoftware is disabling one of the DLLs from working. If BFGMiner starts with the\n-T option but never starts without it, this is a sure fire sign you have this\nproblem and will have to disable your antivirus or set up some exceptions in it\nif possible.\n\nQ: Is it faster to mine on Windows or Linux?\nA: It makes no difference. It comes down to choice of operating system for their\nvarious features. Linux offers much better long term stability and remote\nmonitoring and security, while Windows offers you overclocking tools that can\nachieve much more than BFGMiner can do on Linux.\n\nQ: BFGMiner cannot see any of my GPUs even though I have configured them all to\nbe enabled and installed OpenCL (+/- Xorg is running and the DISPLAY variable is\nexported on Linux)?\nA: Check the output of 'bfgminer -S opencl:auto -d?', it will list what OpenCL\ndevices your installed SDK recognises. If it lists none, you have a problem with\nyour version or installation of the SDK.\n\nQ: BFGMiner is mining on the wrong GPU, I want it on the AMD but it's mining on\nmy on board GPU?\nA: Make sure the AMD OpenCL SDK is installed, check the output of 'bfgminer -S\nopencl:auto -d?' and use the appropriate parameter with --gpu-platform.\n\nQ: I'm getting much lower hashrates than I should be for my GPU?\nA: Look at your driver/SDK combination and disable power saving options for your\nGPU. Specifically look to disable ULPS. Make sure not to set intensity above 11\nfor Bitcoin mining.\n\nQ: Can I mine with AMD while running Nvidia or Intel GPUs at the same time?\nA: If you can install both drivers successfully (easier on windows) then yes,\nusing the --gpu-platform option.\n\nQ: Can I mine with Nvidia or Intel GPUs?\nA: Yes, but the hashrate on these is very poor and it is likely you'll be using\nmuch more energy than you'll be earning in coins.\n\nQ: Can I mine on both Nvidia and AMD GPUs at the same time?\nA: No, you must run one instance of BFGMiner with the --gpu-platform option for\neach.\n\nQ: Can I mine on Linux without running Xorg?\nA: With Nvidia you can, but with AMD you cannot.\n\nQ: I'm trying to mine a scrypt cryptocurrency but BFGMiner shows MH values\ninstead of kH and submits no shares?\nA: Add the --scrypt parameter to your BFGMiner startup command.\n\nQ: I can't get anywhere near enough hashrate for scrypt compared to other\npeople?\nA: You may not have enough system RAM, as this is also required.\n\nQ: My scrypt hashrate is high but the pool reports only a tiny proportion of my\nhashrate?\nA: You are generating garbage hashes due to your choice of settings. Try\ndecreasing your intensity, do not increase the number of gpu-threads, and\nconsider adding system RAM to match your GPU ram. You may also be using a bad\ncombination of driver and/or SDK.\n\nQ: Scrypt fails to initialise the kernel every time?\nA: Your parameters are too high. Don't add GPU threads, don't set intensity too\nhigh, decrease thread concurrency. See the README.scrypt for a lot more help.\n\nQ: Are OpenCL kernels from other mining software useable in BFGMiner?\nA: The interfaces are often slightly different between the different software,\nso in most cases they will not work without modifying BFGMiner itself. However,\nif the kernel is compatible with one BFGMiner supports, you can edit it in a\ntext editor and add a line that looks like this to the top:\n    // kernel-interface: poclbm\nThis will instruct BFGMiner to use the poclbm kernel interface. Then to use the\nkernel, just use --set OCL:kernel=mykernel where the filename is mykernel.cl.\n\nQ: BFGMiner stops mining (or my GPUs go DEAD) and I can't close it?\nA: Once the driver has crashed, there is no way for BFGMiner to close cleanly.\nYou will have to kill it, and depending on how corrupted your driver state has\ngotten, you may even need to reboot. Windows is known to reset drivers when they\nfail and BFGMiner will be stuck trying to use the old driver instance.\n\nQ: I can't get any monitoring of temperatures or fanspeed with BFGMiner when I\nstart it remotely?\nA: With Linux, make sure to export the DISPLAY variable. On Windows, you cannot\naccess these monitoring values via RDP. This should work with TightVNC or\nTeamViewer, though.\n\nQ: I change my GPU engine/memory/voltage and BFGMiner reports back no change?\nA: BFGMiner asks the GPU using the ATI Display Library to change settings, but\nthe driver and hardware are free to do what it wants with that query, including\nignoring it. Some GPUs are locked with one or more of those properties as well.\nThe most common of these is that many GPUs only allow a fixed difference\nbetween the engine clock speed and the memory clock speed (such as the memory\nbeing no lower than the engine - 150). Other 3rd party tools have unofficial\ndata on these devices on windows and can get the memory clock speed down\nfurther but BFGMiner does not have access to these means.\n\nQ: I have multiple GPUs and although many devices show up, it appears to be\nworking only on one GPU splitting it up.\nA: Your driver setup is failing to properly use the accessory GPUs. Your driver\nmay be misconfigured or you have a driver version that needs a dummy plug on all\nthe GPUs that aren't connected to a monitor.\n\nQ: I have some random GPU performance related problem not addressed above.\nA: Seriously, it's the driver and/or SDK. Uninstall them and start again,\nalso noting there is no clean way to uninstall them so you will likely have to\nuse extra tools or do it manually.\n\nQ: Do I need to recompile after updating my driver/SDK?\nA: No. The software is unchanged regardless of which driver/SDK/ADL version you\nare running.\n\nQ: I do not want BFGMiner to modify my engine/clock/fanspeed?\nA: BFGMiner only modifies values if you tell it to via the parameters.\nOtherwise it will just monitor the values.\n\nQ: Should I use crossfire/SLI?\nA: It does not benefit mining at all and depending on the GPU may actually\nworsen performance.\n"
        },
        {
          "name": "README.OpenWrt",
          "type": "blob",
          "size": 1.369140625,
          "content": "First, look at /etc/openwrt_release (on your router). You will see a bunch of\nattributes for the OpenWrt system. The DISTRIB_RELEASE attribute is your\nOpenWrt version, the first part of DISTRIB_TARGET (before the slash) is the\nrouter's platform, and (only on newer versions) DISTRIB_ARCH is the package\narchitecture. Older versions of OpenWrt (up to 15.05) use the router's\nplatform for packages instead of the package architecture.\n\nNow, open up /etc/opkg.conf (again, on your router) in your favourite editor.\nAdd a new line at the bottom, similar to this:\n\tsrc/gz bfgminer http://luke.dashjr.org/programs/bitcoin/files/bfgminer/latest/openwrt/17.01/mips_24kc\nIn this example, 17.01 is the version of OpenWrt, and mips_24kc is the package\narchitecture. Be sure to change those to match your router! You can also change\n\"latest\" to \"stable\" or \"testing\" to get better-tested versions.\n\nNext, save the file and exit your editor. Tell opkg to reload its package lists\nby running the command:\n\topkg update\nIf you get a \"404 Not Found\" error, then your router may not be supported. If\nyou open an issue for your router's platform, it may be possible to add\nsupport.\n\nIf all went well updating your package list, you can now install BFGMiner and\nany drivers you might need:\n\topkg install bfgminer\n\topkg install kmod-usb-serial-ftdi\n\topkg install kmod-usb-serial-cp210x\n\topkg install kmod-usb-serial-pl2303\n"
        },
        {
          "name": "README.RPC",
          "type": "blob",
          "size": 56.787109375,
          "content": "\nThis README contains details about the BFGMiner RPC API\n\nIt also includes some detailed information at the end,\nabout using miner.php\n\n\nIf you start BFGMiner with the \"--api-listen\" option, it will listen on a\nsimple TCP/IP socket for single string API requests from the same machine\nrunning BFGMiner and reply with a string and then close the socket each time\nIf you add the \"--api-network\" option, it will accept API requests from any\nnetwork attached computer.\n\nYou can only access the commands that reply with data in this mode.\nBy default, you cannot access any privileged command that affects the miner -\nyou will receive an access denied status message instead. See --api-allow below\nfor more details.\n\nYou can specify IP addresses/prefixes that are only allowed to access the API\nwith the \"--api-allow\" option, e.g. --api-allow W:192.168.0.1,10.0.0/24\nwill allow 192.168.0.1 or any address matching 10.0.0.*, but nothing else.\nIP addresses are automatically padded with extra '.0's as needed\nWithout a /prefix is the same as specifying /32.\n0/0 means all IP addresses.\nThe 'W:' on the front gives that address/subnet privileged access to commands\nthat modify BFGMiner (thus all API commands).\nWithout it those commands return an access denied status.\nSee --api-groups below to define other groups like W:\nPrivileged access is checked in the order the IP addresses were supplied to\n\"--api-allow\"\nThe first match determines the privilege level.\nUsing the \"--api-allow\" option overrides the \"--api-network\" option if they\nare both specified\nWith \"--api-allow\", 127.0.0.1 is not by default given access unless specified\n\nIf you start BFGMiner also with the \"--api-mcast\" option, it will listen for\na multicast message and reply to it with a message containing it's API port\nnumber, but only if the IP address of the sender is allowed API access.\n\nMore groups (like the privileged group W:) can be defined using the\n--api-groups command\nValid groups are only the letters A-Z (except R & W are predefined) and are\nnot case sensitive.\nThe R: group is the same as not privileged access.\nThe W: group is (as stated) privileged access (thus all API commands).\nTo give an IP address/subnet access to a group you use the group letter\nin front of the IP address instead of W: e.g. P:192.168.0/32\nAn IP address/subnet can only be a member of one group.\nA sample API group would be:\n --api-groups\n        P:switchpool:enablepool:addpool:disablepool:removepool:poolpriority:*\nThis would create a group 'P' that can do all current pool commands and all\nnon-privileged commands - the '*' means all non-privileged commands.\nWithout the '*' the group would only have access to the pool commands.\nDefining multiple groups example:\n --api-groups Q:quit:restart:*,S:save\nThis would define 2 groups:\n Q: that can 'quit' and 'restart' as well as all non-privileged commands.\n S: that can only 'save' and no other commands.\n\nThe RPC API request can be either simple text or JSON.\n\nIf the request is JSON (starts with '{'), it will reply with a JSON formatted\nresponse, otherwise it replies with text formatted as described further below.\n\nThe JSON request format required is '{\"command\":\"CMD\",\"parameter\":\"PARAM\"}'\n(though of course parameter is not required for all requests)\nwhere \"CMD\" is from the \"Request\" column below and \"PARAM\" would be e.g.\nthe device number if required.\n\nAn example request in both formats to set device 0 fan to 80%:\n  pgaset|0,fan,80\n  {\"command\":\"pgaset\",\"parameter\":\"0,fan,80\"}\n\nThe format of each reply (unless stated otherwise) is a STATUS section\nfollowed by an optional detail section.\n\nFrom API version 1.7 onwards, reply strings in JSON and Text have the\nnecessary escaping as required to avoid ambiguity - they didn't before 1.7.\nFor JSON the 2 characters '\"' and '\\' are escaped with a '\\' before them.\nFor Text the 4 characters '|' ',' '=' and '\\' are escaped the same way.\n\nOnly user entered information will contain characters that require being\nescaped, such as Pool URL, User and Password or the Config save filename,\nwhen they are returned in messages or as their values by the API.\n\nFor API version 1.4 and later:\n\nThe STATUS section is:\n\n STATUS=X,When=NNN,Code=N,Msg=string,Description=string|\n\n  STATUS=X Where X is one of:\n   W - Warning\n   I - Informational\n   S - Success\n   E - Error\n   F - Fatal (code bug)\n\n  When=NNN\n   Standard long time of request in seconds.\n\n  Code=N\n   Each unique reply has a unique Code (See api.c - #define MSG_NNNNNN).\n\n  Msg=string\n   Message matching the Code value N.\n\n  Description=string\n   This defaults to the BFGMiner version but is the value of --api-description\n   if it was specified at runtime.\n\nWith API V3.1 you can also request multiple report replies in a single command\nrequest\ne.g. to request both summary and devs, the command would be summary+devs\n\nThis is only available for report commands that don't need parameters,\nand is not available for commands that change anything\nAny parameters supplied will be ignored\n\nThe extra formatting of the result is to have a section for each command\ne.g. CMD=summary|STATUS=....|CMD=devs|STATUS=...\nWith JSON, each result is within a section of the command name\ne.g. {\"summary\":{\"STATUS\":[{\"STATUS\":\"S\"...}],\"SUMMARY\":[...],\"id\":1},\n      \"devs\":{\"STATUS\":[{\"STATUS:\"S\"...}],\"DEVS\":[...],\"id\":1},\"id\":1}\n\nAs before, if you supply bad JSON you'll just get a single 'E' STATUS section\nin the old format, since it doesn't switch to using the new format until it\ncorrectly processes the JSON and can match a '+' in the command\n\nIf you request a command multiple times, e.g. devs+devs\nyou'll just get it once\nIf this results in only one command, it will still use the new layout\nwith just the one command\n\nIf you request a command that can't be used due to requiring parameters,\na command that isn't a report, or an invalid command, you'll get an 'E' STATUS\nfor that one but it will still attempt to process all other commands supplied\n\nBlank/missing commands are ignore e.g. +devs++\nwill just show 'devs' using the new layout\n\nFor API version 1.10 and later:\n\nThe list of requests - a (*) means it requires privileged access - and replies:\n\n Request       Reply Section  Details\n -------       -------------  -------\n version       VERSION        Miner=\"BFGMiner \" BFGMiner version\n                              CGMiner=BFGMiner version\n                              API=API version\n\n config        CONFIG         Some miner configuration information:\n                              PGA Count=N, <- the number of PGAs\n                              Pool Count=N, <- the number of Pools\n                              ADL=X, <- Y or N if ADL is compiled in the code\n                              ADL in use=X, <- Y or N if any GPU has ADL\n                              Strategy=Name, <- the current pool strategy\n                              Rotate Period=N, <- rotate strategy period\n                              Log Interval=N, <- log interval (--log N)\n                              Device Code=GPU ICA , <- spaced list of compiled\n                                                       device drivers\n                              OS=Linux/Apple/..., <- operating System\n                              Failover-Only=true/false, <- failover-only setting\n                              ScanTime=N, <- --scan-time setting\n                              Queue=N, <- --queue setting\n                              Expiry=N, <- --expiry setting\n                              Coinbase-Sig=X, <- extra coinbase data in blocks\n                              ConfigFileN=X| <- filename of configs loaded\n\n summary       SUMMARY        The status summary of the miner\n                              e.g. Elapsed=NNN,Found Blocks=N,Getworks=N,...|\n\n pools         POOLS          The status of each pool e.g.\n                              Pool=0,URL=http://pool.com:6311,Status=Alive,...|\n\n devs          DEVS           Each available device with their status\n                              e.g. PGA=0,Accepted=NN,MHS av=NNN,...,Intensity=D|\n                              Last Share Time=NNN, <- standard long time in sec\n                               (or 0 if none) of last accepted share\n                              Last Share Pool=N, <- pool number (or -1 if none)\n                              Last Valid Work=NNN, <- standand long time in sec\n                               of last work returned that wasn't an HW:\n\n procs         DEVS           The details of each processor in the same format\n                              and details as for DEVS\n\n devscan|info  DEVS           Probes for a device specified by info, which is\n                              the same format as the --scan-serial command line\n                              option\n\n pga|N         PGA            The details of a single PGA number N in the same\n                              format and details as for DEVS\n                              This is only available if PGA mining is enabled\n                              Use 'pgacount' or 'config' first to see if there\n                              are any\n\n proc|N        PGA            The details of a single processor number N in the\n                              same format and details as for DEVS\n\n pgacount      PGAS           Count=N| <- the number of PGAs\n                              Always returns 0 if PGA mining is disabled\n\n proccount     PGAS           Count=N| <- the number of processors\n\n switchpool|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of switching pool N to the\n                              highest priority (the pool is also enabled)\n                              The Msg includes the pool URL\n\n enablepool|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of enabling pool N\n                              The Msg includes the pool URL\n\n addpool|URL,USR,PASS[,GOAL] (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of attempting to add pool N\n                              The Msg includes the pool URL\n                              Use '\\\\' to get a '\\' and '\\,' to include a comma\n                              inside URL, USR, PASS, or GOAL\n\n poolpriority|N,... (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of changing pool priorities\n                              See usage below\n\n poolquota|N,Q (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of changing pool quota to Q\n\n disablepool|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of disabling pool N\n                              The Msg includes the pool URL\n\n removepool|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of removing pool N\n                              The Msg includes the pool URL\n                              N.B. all details for the pool will be lost\n\n save|filename (*)\n               none           There is no reply section just the STATUS section\n                              stating success or failure saving the BFGMiner\n                              config to filename\n                              The filename is optional and will use the BFGMiner\n                              default if not specified\n\n quit (*)      none           There is no reply section just the STATUS section\n                              before BFGMiner quits\n\n notify        NOTIFY         The last status and history count of each devices\n                              problem\n                              e.g. NOTIFY=0,Name=PGA,ID=0,ProcID=0,Last Well=1332432290,...|\n\n privileged (*)\n               none           There is no reply section just the STATUS section\n                              stating an error if you do not have privileged\n                              access to the API and success if you do have\n                              privilege\n                              The command doesn't change anything in BFGMiner\n\n pgaenable|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the enable request\n                              You cannot enable a PGA if its status is not WELL\n                              This is only available if PGA mining is enabled\n\n pgadisable|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the disable request\n                              This is only available if PGA mining is enabled\n\n pgarestart|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the restart request\n\n pgaidentify|N (*)\n               none           This is equivalent to PROCIDENTIFY on the first\n                              processor of any given device\n                              This is only available if PGA mining is enabled\n\n procenable|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the enable request\n\n procdisable|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the disable request\n\n procidentify|N (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of the identify request\n                              On most supported devices, it will flash the led\n                              for approximately 4s\n                              All unsupported devices, it will return a warning\n                              status message stating that they don't support it\n                              For BFL, this adds a 4s delay to the share being\n                              processed so you may get a message stating that\n                              processing took longer than 7000ms if the request\n                              was sent towards the end of the timing of any work\n                              being worked on\n                              e.g.: BFL0: took 8438ms - longer than 7000ms\n                              You should ignore this\n\n devdetails    DEVDETAILS     Each device with a list of their static details\n                              This lists all devices including those not\n                              supported by the 'devs' command\n                              e.g. DEVDETAILS=0,Name=BFL,ID=0,ProcID=0,Driver=bitforce,...|\n\n restart (*)   none           There is no reply section just the STATUS section\n                              before BFGMiner restarts\n\n stats         STATS          Each device or pool that has 1 or more getworks\n                              with a list of stats regarding getwork times\n                              The values returned by stats may change in future\n                              versions thus would not normally be displayed\n                              Device drivers are also able to add stats to the\n                              end of the details returned\n\n check|cmd     COMMAND        Exists=Y/N, <- 'cmd' exists in this version\n                              Access=Y/N| <- you have access to use 'cmd'\n\n failover-only|true/false (*)\n               none           There is no reply section just the STATUS section\n                              stating what failover-only was set to\n\n coin          COIN           Coin mining information:\n                              Hash Method=sha256/scrypt,\n                              Current Block Time=N.N, <- 0 means none\n                              Current Block Hash=XXXX..., <- blank if none\n                              LP=true/false, <- LP is in use on at least 1 pool\n                              Network Difficulty=NN.NN|\n\n debug|setting (*)\n               DEBUG          Debug settings\n                              The optional commands for 'setting' are the same\n                              as the screen curses debug settings\n                              You can only specify one setting\n                              Only the first character is checked - case\n                              insensitive:\n                              Silent, Quiet, Verbose, Debug, RPCProto,\n                              PerDevice, WorkTime, Normal\n                              The output fields are (as above):\n                              Silent=true/false,\n                              Quiet=true/false,\n                              Verbose=true/false,\n                              Debug=true/false,\n                              RPCProto=true/false,\n                              PerDevice=true/false,\n                              WorkTime=true/false|\n\n setconfig|name,value (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of setting 'name'\n                              The valid values for name are currently:\n                              queue, scantime, expiry (integer in the range\n                                                       0 to 9999)\n                              coinbase-sig (string)\n                              http-port (valid port number)\n                              strategy (name of valid strategy, and optional\n                                        number of minutes if rotate)\n                              stratum-port (valid port number)\n\n pgaset|N,opt[,val] (*)\n               none           This is equivalent to PROCSET on the first\n                              processor of any given device\n                              This is only available if PGA mining is enabled\n\n procset|N,opt[,val] (*)\n               none           There is no reply section just the STATUS section\n                              stating the results of setting processor N with\n                              opt[,val]\n\n                              If the processor does not support any set options,\n                              it will always return a WARN stating pgaset isn't\n                              supported\n\n                              If opt=help it will return an INFO status with a\n                              help message about the options available\n\n                              The current options are:\n                               MMQ opt=clock val=2 to 250 (a multiple of 2)\n                               XBS opt=clock val=2 to 250 (a multiple of 2)\n\n zero|Which,true/false (*)\n               none           There is no reply section just the STATUS section\n                              stating that the zero, and optional summary, was\n                              done\n                              If Which='all', all normal BFGMiner and API\n                              statistics will be zeroed other than the numbers\n                              displayed by the stats command\n                              If Which='bestshare', only the 'Best Share' values\n                              are zeroed for each pool and the global\n                              'Best Share'\n                              The true/false option determines if a full summary\n                              is shown on the BFGMiner display like is normally\n                              displayed on exit.\n\nWhen you enable, disable or restart a device, you will also get Thread messages\nin the BFGMiner status window.\n\nThe 'poolpriority' command can be used to reset the priority order of multiple\npools with a single command - 'switchpool' only sets a single pool to first\npriority. Each pool should be listed by id number in order of preference (first\n= most preferred). Any pools not listed will be prioritised after the ones that\nare listed, in the priority order they were originally If the priority change\naffects the miner's preference for mining, it may switch immediately.\n\nWhen you switch to a different pool to the current one (including by priority\nchange), you will get a 'Switching to URL' message in the BFGMiner status\nwindows.\n\nObviously, the JSON format is simply just the names as given before the '='\nwith the values after the '='.\n\nIf you enable BFGMiner debug (--debug or using RPC), you will also get messages\nshowing some details of the requests received and the replies.\n\nThere are included 5 program examples for accessing the API:\n\napi-example.php - a PHP script to access the API.\n  usage: php api-example.php command\n by default it sends a 'summary' request to the miner at 127.0.0.1:4028\n If you specify a command it will send that request instead.\n You must modify the line \"$socket = getsock('127.0.0.1', 4028);\" at the\n beginning of \"function request($cmd)\" to change where it looks for BFGMiner.\n\napi-example.c - a 'C' program to access the API (with source code).\n  usage: api-example [command [ip/host [port]]]\n again, as above, missing or blank parameters are replaced as if you entered:\n  api-example summary 127.0.0.1 4028\n\nminer.php - an example web page to access the API.\n This includes buttons and inputs to attempt access to the privileged commands.\n See the end of this README.RPC for details of how to tune the display\n and also to use the option to display a multi-rig summary.\n\napi-example.py - a Python script to access the API.\n  usage: python api-example.py [--host HOST] [--port PORT] [command] [parameter]\n by default it sends a 'summary' request to the miner at 127.0.0.1:4028\n If you specify a command it will send that request instead.\n\napi-example.rb - a Ruby script to access the API.\n  usage: ruby api-example.rb command[:parameter] [HOST [PORT]]\n\nIf you are using Node.js, you can also use the miner-rpc package and script:\nhttps://www.npmjs.org/package/miner-rpc\n\n----------\n\nFeature Changelog for external applications using the API:\n\n\nAPI V3.4 (BFGMiner v5.4.0)\n\nModified API commands:\n 'config' - add 'Rotate Period'\n 'setconfig' - add 'strategy'\n\n---------\n\nAPI V3.3 (BFGMiner v5.0.0)\n\nModified API command:\n 'addpool' - accept an additional argument to indicate mining goal by name\n 'coin' - return multiple elements, when there are multiple mining goals\n          defined; add 'Difficulty Accepted'\n 'pools' - add 'Mining Goal'\n\n---------\n\nAPI V3.2 (BFGMiner v4.1.0)\n\nModified API command:\n 'config' - add 'ConfigFile'N\n\n---------\n\nAPI V3.1 (BFGMiner v4.0.0)\n\nMultiple report request command with '+' e.g. summary+devs\n\nCPU and OpenCL devices are now included as \"PGAs\", to enable migration to a simpler interface.\n\nAdded API commands:\n 'pgarestart'\n\nModified API commands:\n 'devs' - remove 'GPU Count' and 'CPU Count'\n 'quit' - expand reply to include a complete STATUS section\n 'restart' - expand reply to include a complete STATUS section\n 'summary' - add 'MHS rolling'\n 'version' - add 'Miner'\n\nDeprecated API commands:\n 'cpu'\n 'cpucount'\n 'cpuenable'\n 'cpudisable'\n 'cpurestart'\n 'gpu'\n 'gpucount'\n 'gpuenable'\n 'gpudisable'\n 'gpurestart'\n 'gpuintensity'\n 'gpumem'\n 'gpuengine'\n 'gpufan'\n 'gpuvddc'\n\n---------\n\nAPI V2.3 (BFGMiner v3.7.0)\n\nModified API command:\n 'devdetails' - Add 'Processors', 'Manufacturer', 'Product', 'Serial',\n                    'Target Temperature', 'Cutoff Temperature'\n 'procdetails' - Add 'Manufacturer', 'Product', 'Serial', 'Target Temperature',\n                     'Cutoff Temperature'\n\n---------\n\nAPI V2.2 (BFGMiner v3.6.0)\n\nModified API command:\n 'pools' - add 'Works'\n\n---------\n\nAPI V2.1 (BFGMiner v3.4.0)\n\nAdded API command:\n 'poolquota' - Set pool quota for load-balance strategy.\n\nModified API command:\n 'devs', 'gpu', 'pga', 'procs' and 'asc' - add 'Device Elapsed', 'Stale',\n                                             'Work Utility', 'Difficulty Stale'\n 'pools' - add 'Quota'\n 'summary' - add 'Diff1 Work', 'MHS %ds' (where %d is the log interval)\n\n---------\n\nAPI V2.0 (BFGMiner v3.3.0)\n\nRemoved API commands:\n 'devdetail' - Use newer 'devdetails' for same information.\n\nModified API commands:\n 'devs' - display status of each full device only (not processors)\n 'pga' - lookup and display device by device (not processor) number\n 'pgacount' - count only full devices (not processors)\n 'pgaenable' - enable all processors for a numbered full device\n 'pgadisable' - disable all processors for a numbered full device\n 'pgaidentify' - choose first processor of numbered full device\n 'pgaset' - choose first processor of numbered full device\n 'setconfig' - add 'stratum-port' number\n\nAdded API commands:\n 'procs'\n 'proc'\n 'proccount'\n 'procenable'\n 'procdisable'\n 'procidentify'\n 'procset'\n\n----------\n\nAPI V1.25.3 (BFGMiner v3.2.0)\n\nModified API commands:\n 'devs', 'pga', 'gpu' - add 'Device Hardware%' and 'Device Rejected%'\n 'pools' - add 'Pool Rejected%' and 'Pool Stale%'\n 'setconfig' - add 'http-port' number\n 'summary' - add 'Device Hardware%', 'Device Rejected%', 'Pool Rejected%',\n                 'Pool Stale%'\n\nRemoved output limitation:\n All replies can now be longer than the previous limitation of 64k, and will\n  only be truncated on a 50ms timeout sending.\n\nBasic support for cgminer-compatible multicast RPC detection added.\n\n----------\n\nAPI V1.25.2 (BFGMiner v3.1.4)\n\nModified API commands:\n 'pgaset' - added: XBS opt=clock val=2 to 250 (and a multiple of 2)\n\n----------\n\nAPI V1.25.1 (BFGMiner v3.1.2)\n\nAdded API commands:\n 'devscan'\n\n----------\n\nAPI V1.25 (BFGMiner v3.0.1)\n\nModified API commands:\n 'devs' 'gpu' and 'pga' - add 'Last Valid Work'\n\n----------\n\nAPI V1.24.1 (BFGMiner v3.0.0)\n\nModified API commands:\n 'cpustatus' - add 'ProcID'\n 'gpustatus' - add 'ProcID'\n 'pgastatus' - add 'ProcID'\n 'devstatus' - add 'ProcID'\n 'notify' - add 'ProcID'\n 'devdetails' - add 'ProcID'\n 'devdetail' - add 'Name', 'ID', and 'ProcID'\n 'pools' - add 'Message'\n 'coin' - add 'Network Difficulty'\n\nPretty much updated every method returning 'Name' and 'ID' to also return\n'ProcID'. This is a number starting with 0 for 'a', 1 for 'b', etc.\n\n----------\n\nAPI V1.24 (BFGMiner v2.10.3)\n\nAdded API commands:\n 'zero'\n\nModified API commands:\n 'pools' - add 'Best Share'\n 'stats' - rename 'Bytes Sent' and 'Bytes Recv' to 'Net Bytes Sent' and\n                  'Net Bytes Recv'\n\n----------\n\nAPI V1.23 (BFGMiner v2.10.1)\n\nAdded API commands:\n 'pgaset' - with: MMQ opt=clock val=2 to 230 (and a multiple of 2)\n\n----------\n\nAPI V1.22 (not released)\n\nEnforced output limitation:\n all extra records beyond the output limit of the API (~64k) are ignored and\n  chopped off at the record boundary before the limit is reached however, JSON\n  brackets will be correctly closed and the JSON id will be set to 0 (instead\n  of 1) if any data was truncated.\n\nModified API commands:\n 'stats' - add 'Times Sent', 'Bytes Sent', 'Times Recv', 'Bytes Recv'\n\n----------\n\nAPI V1.21 (BFGMiner v2.10.0)\n\nModified API commands:\n 'summary' - add 'Best Share'\n\n----------\n\nAPI V1.20b (BFGMiner v2.9.1)\n\nSupport for the X6500 FPGA was added.\n\n----------\n\nAPI V1.20 (BFGMiner v2.9.0)\n\nModified API commands:\n 'pools' - add 'Has Stratum', 'Stratum Active', 'Stratum URL'\n\n----------\n\nAPI V1.19b (BFGMiner v2.8.1)\n\nAdded API commands:\n 'pgaidentify|N' (only works for BitForce Singles so far)\n\nModified API commands:\n Change pool field name back from 'Diff1 Work' to 'Diff1 Shares'\n 'devs' - add 'Difficulty Accepted', 'Difficulty Rejected',\n              'Last Share Difficulty' to all devices\n 'gpu|N' - add 'Difficulty Accepted', 'Difficulty Rejected',\n              'Last Share Difficulty'\n 'pga|N' - add 'Difficulty Accepted', 'Difficulty Rejected',\n              'Last Share Difficulty'\n 'notify' - add '*Dev Throttle' (for BitForce Singles)\n 'pools' - add 'Difficulty Accepted', 'Difficulty Rejected',\n               'Difficulty Stale', 'Last Share Difficulty'\n 'stats' - add 'Work Diff', 'Min Diff', 'Max Diff', 'Min Diff Count',\n               'Max Diff Count' to the pool stats\n 'setconfig|name,value' - add 'Coinbase-Sig' string\n\n----------\n\nAPI V1.19 (BFGMiner v2.8.0)\n\nAdded API commands:\n 'debug'\n 'setconfig|name,N'\n\nModified API commands:\n Change pool field name 'Diff1 Shares' to 'Diff1 Work'\n 'devs' - add 'Diff1 Work' to all devices\n 'gpu|N' - add 'Diff1 Work'\n 'pga|N' - add 'Diff1 Work'\n 'pools' - add 'Proxy'\n 'config' - add 'Queue', 'Expiry'\n\n----------\n\nAPI V1.18 (BFGMiner v2.7.4)\n\nModified API commands:\n 'stats' - add 'Work Had Roll Time', 'Work Can Roll', 'Work Had Expire',\n           and 'Work Roll Time' to the pool stats\n 'config' - include 'ScanTime'\n\n----------\n\nAPI V1.17b (BFGMiner v2.7.1)\n\nModified API commands:\n 'summary' - add 'Work Utility'\n 'pools' - add 'Diff1 Shares'\n\n----------\n\nAPI V1.17 (BFGMiner v2.6.5)\n\nAdded API commands:\n 'coin'\n\n----------\n\nAPI V1.16 (BFGMiner v2.6.5)\n\nAdded API commands:\n 'failover-only'\n\nModified API commands:\n 'config' - include failover-only state\n\n----------\n\nAPI V1.15 (BFGMiner v2.5.2)\n\nAdded API commands:\n 'poolpriority'\n\n----------\n\nAPI V1.14 (BFGMiner v2.5.0)\n\nModified API commands:\n 'stats' - more Icarus timing stats added\n 'notify' - include new device comms error counter\n\nThe internal code for handling data was rewritten (~25% of the code)\nCompletely backward compatible\n\n----------\n\nAPI V1.13 (BFGMiner v2.4.4)\n\nAdded API commands:\n 'check'\n\nSupport was added to BFGMiner for API access groups with the --api-groups option\nIt's 100% backward compatible with previous --api-access commands\n\n----------\n\nAPI V1.12 (BFGMiner v2.4.3)\n\nModified API commands:\n 'stats' - more pool stats added\n\nSupport for the ModMiner FPGA was added\n\n----------\n\nAPI V1.11 (BFGMiner v2.4.2)\n\nModified API commands:\n 'save' no longer requires a filename (use default if not specified)\n\n'save' incorrectly returned status E (error) on success before.\nIt now correctly returns S (success)\n\n----------\n\nAPI V1.10 (BFGMiner v2.4.1)\n\nAdded API commands:\n 'stats'\n\nN.B. the 'stats' command can change at any time so any specific content\npresent should not be relied upon.\nThe data content is mainly used for debugging purposes or hidden options\nin BFGMiner and can change as development work requires.\n\nModified API commands:\n 'pools' added \"Last Share Time\"\n\n----------\n\nAPI V1.9 (BFGMiner v2.4.0)\n\nAdded API commands:\n 'restart'\n\nModified API commands:\n 'notify' corrected invalid JSON\n\n----------\n\nAPI V1.8 (BFGMiner v2.3.5)\n\nAdded API commands:\n 'devdetails'\n\nSupport for the ZTEX FPGA was added.\n\n----------\n\nAPI V1.8-pre (BFGMiner v2.3.4)\n\nAdded API commands:\n 'devdetail'\n\n----------\n\nAPI V1.7 (BFGMiner v2.3.4)\n\nAdded API commands:\n 'removepool'\n\nModified API commands:\n 'pools' added \"User\"\n\nFrom API version 1.7 onwards, reply strings in JSON and Text have the\nnecessary escaping as required to avoid ambiguity.\nFor JSON the 2 characters '\"' and '\\' are escaped with a '\\' before them.\nFor Text the 4 characters '|' ',' '=' and '\\' are escaped the same way.\n\n----------\n\nAPI V1.6 (cgminer v2.3.2)\n\nAdded API commands:\n 'pga'\n 'pgaenable'\n 'pgadisable'\n 'pgacount'\n\nModified API commands:\n 'devs' now includes Icarus and BitForce FPGA devices.\n 'notify' added \"*\" to the front of the name of all numeric error fields.\n 'config' correct \"Log Interval\" to use numeric (not text) type for JSON.\n\nSupport for Icarus and BitForce FPGAs was added.\n\n----------\n\nAPI V1.5 was not released\n\n----------\n\nAPI V1.4 (Kano's interim release of cgminer v2.3.1)\n\nAdded API commands:\n 'notify'\n\nModified API commands:\n 'config' added \"Device Code\" and \"OS\"\n\nAdded \"When\" to the STATUS reply section of all commands.\n\n----------\n\nAPI V1.3 (cgminer v2.3.1-2)\n\nAdded API commands:\n 'addpool'\n\nModified API commands:\n 'devs'/'gpu' added \"Total MH\" for each device\n 'summary' added \"Total MH\"\n\n----------\n\nAPI V1.2 (cgminer v2.3.0)\n\nAdded API commands:\n 'enablepool'\n 'disablepool'\n 'privileged'\n\nModified API commands:\n 'config' added \"Log Interval\"\n\nStarting with API V1.2, any attempt to access a command that requires\nprivileged security, from an IP address that does not have privileged\nsecurity, will return an \"Access denied\" Error Status.\n\n----------\n\nAPI V1.1 (cgminer v2.2.4)\n\nThere were no changes to the API commands in cgminer v2.2.4,\nhowever support was added to cgminer for IP address restrictions\nwith the --api-allow option.\n\n----------\n\nAPI V1.1 (cgminer v2.2.2)\n\nPrior to V1.1, devs/gpu incorrectly reported GPU0 Intensity for all GPUs.\n\nModified API commands:\n 'devs'/'gpu' added \"Last Share Pool\" and \"Last Share Time\" for each device\n\n----------\n\nAPI V1.0 (cgminer v2.2.0)\n\nRemove default CPU support.\n\nAdded API commands:\n 'config'\n 'gpucount'\n 'cpucount'\n 'switchpool'\n 'gpuintensity'\n 'gpumem'\n 'gpuengine'\n 'gpufan'\n 'gpuvddc'\n 'save'\n\n----------\n\nAPI V0.7 (cgminer v2.1.0)\n\nInitial release of the API in the main cgminer git\n\nCommands:\n 'version'\n 'devs'\n 'pools'\n 'summary'\n 'gpuenable'\n 'gpudisable'\n 'gpurestart'\n 'gpu'\n 'cpu'\n 'gpucount'\n 'cpucount'\n 'quit'\n\n----------------------------------------\n\nminer.php\n=========\n\nminer.php is a PHP based interface to the BFGMiner RPC API\n(referred to simply as the API below).\n\nIt can show rig details, summaries and input fields to allow you to change\nBFGMiner.\nYou can also create custom summary pages with it\n\nIt has two levels to the security:\n1) BFGMiner can be configured to allow or disallow API access and access level\n   security for miner.php\n2) miner.php can be configured to allow or disallow privileged BFGMiner\n   access, if BFGMiner is configured to allow privileged access for miner.php\n\n---------\n\nTo use miner.php requires a web server with PHP.\n\nBasics: On Xubuntu 11.04, to install Apache and PHP, the commands are:\n sudo apt-get install apache2\n sudo apt-get install php5\n sudo /etc/init.d/apache2 reload\n\nOn Fedora 17:\n yum install httpd php\n systemctl restart httpd.service\n systemctl enable httpd.service --system\n\nOn windows there are a few options.\nTry one of these (apparently the first one is easiest - thanks jborkl)\n http://www.easyphp.org/\n http://www.apachefriends.org/en/xampp.html\n http://www.wampserver.com/en/\n\n---------\n\nThe basic BFGMiner option to enable the API is:\n\n --api-listen\n\nor in your bfgminer.conf:\n\n \"api-listen\" : true,\n\n(without the ',' on the end if it is the last item.)\n\nIf the web server is running on the BFGMiner computer, the above\nis the only change required to give miner.php basic access to\nthe BFGMiner API.\n\n-\n\nIf the web server runs on a different computer to BFGMiner,\nyou will also need to tell BFGMiner to allow the web server\nto access BFGMiner's API and tell miner.php where BFGMiner is.\n\nAssuming a.b.c.d is the IP address of the web server, you\nwould add the following to BFGMiner:\n\n --api-listen --api-allow a.b.c.d\n\nor in your bfgminer.conf:\n\n \"api-listen\" : true,\n \"api-allow\" : \"a.b.c.d\",\n\nto tell BFGMiner to give the web server read access to the API.\n\nYou also need to tell miner.php where BFGMiner is.\nAssuming BFGMiner is at IP address e.f.g.h, then you would\nedit miner.php and change the line:\n\n $rigs = array('127.0.0.1:4028');\n\nto\n\n $rigs = array('e.f.g.h:4028');\n\nSee --api-network or --api-allow for more access details\nand how to give write access.\n\nYou can however, also tell miner.php to find your mining rigs automatically\non the local subnet.\n\nAdd the following to each BFGMiner:\n\n --api-mcast\n\nor in your bfgminer.conf:\n\n \"api-mcast\" : true,\n\nAnd in miner.php set $mcast = true;\n\nThis will ignore the value of $rigs and overwrite it with the list of zero or\nmore rigs found on the network in the timeout specified.\nA rig will not reply if the API settings would mean it would also ignore an\nAPI request from the web server running miner.php\n\n---------\n\nOnce you have a web server with PHP running:\n\n copy your miner.php to the main web folder\n\nOn Xubuntu 11.04:\n /var/www/\n\nOn Fedora 17:\n /var/www/html/\n\nOn Windows:\n Please check your windows Web/PHP documentation.\n\nAssuming the IP address of the web server is a.b.c.d\nThen in your web browser go to:\n\n http://a.b.c.d/miner.php\n\nDone :)\n\n---------\n\nThe rest of this documentation deals with the more complex\nfunctions of miner.php, using myminer.php, creating custom\nsummaries and displaying multiple BFGMiner rigs.\n\n---------\n\nIf you create a file called myminer.php in the same web folder\nwhere you put miner.php, miner.php will load it when it runs.\n\nThis is useful, to put any changes you need to make to miner.php\ninstead of changing miner.php.\nThus if you update/get a new miner.php, you won't lose the changes\nyou have made if you put all your changes in myminer.php\n(and haven't changed miner.php at all)\n\nA simple example myminer.php that defines 2 rigs\n(that I will keep referring to further below) is:\n\n<?php\n#\n$rigs = array('192.168.0.100:4028:A', '192.168.0.102:4028:B');\n#\n?>\n\nChanges in myminer.php supersede what is in miner.php\nHowever, this is only valid for variables in miner.php before the\n2 lines where myminer.php is included by miner.php:\n\n if (file_exists('myminer.php'))\n  include_once('myminer.php');\n \nEvery variable in miner.php above those 2 lines, can be changed by\nsimply defining them in your myminer.php\n\nSo although miner.php originally contains the line:\n\n $rigs = array('127.0.0.1:4028');\n\nif you created the example myminer.php given above, it would actually\nchange the value of $rigs that is used when miner.php is running.\ni.e. you don't have to remove or comment out the $rigs line in miner.php\nIt will be superseded by myminer.php\n\n---------\n\nThe example myminer.php above also shows how to define more that one rig\nto be shown my miner.php:\n\nEach rig string is 2 or 3 values separated by colons ':'\nThey are simply an IP address or hostname, followed by the\nport number (usually 4028) and an optional Name string.\n\nminer.php displays rig buttons that will show the details of a single\nrig when you click on it - the button shows either the rig number,\nor the 'Name' string if you provide it.\n\nPHP arrays contain each string separated by a comma, but no comma after\nthe last one.\n\nSo an example for 3 rigs would be:\n\n $rigs = array('192.168.0.100:4028:A', '192.168.0.102:4028:B',\n               '192.168.0.110:4028:C');\n\nOf course each of the rigs listed would also have to have the API\nrunning and be set to allow the web server to access the API - as\ncovered earlier in this document.\n\n---------\n\nSo basically, any variable explained below can be put in myminer.php if you want\nto set it to something different to its default value and did not want to change\nminer.php itself every time you update it.\n\nBelow is a list of the variables that can be changed and an explanation of each.\n\n---------\n\nDefault:\n $dfmt = 'H:i:s j-M-Y \\U\\T\\CP';\n\nDefine the date format used to print full length dates.\nIf you get the string 'UTCP' on the end of your dates shown, that\nmeans you are using an older version of PHP and you can instead use:\n $dfmt = 'H:i:s j-M-Y \\U\\T\\CO';\n\nThe PHP documentation on the date format is here:\n http://us.php.net/manual/en/function.date.php\n\n---------\n\nDefault:\n $title = 'Mine';\n\nWeb page title.\nIf you know PHP you can of course use code to define it e.g.\n $title = 'My Rig at: '.date($dfmt);\n\nWhich would set the web page title to something like:\n My Rig at: 10:34:00 22-Aug-2012 UTC+10:00\n\n---------\n\nDefault:\n $readonly = false;\n\nSet $readonly to true to force miner.php to be readonly.\nThis means it won't allow you to change BFGMiner even if the RPC API\noptions allow it to.\n\nIf you set $readonly to false then it will check BFGMiner 'privileged'\nand will show input fields and buttons on the single rig page,\nallowing you to change devices, pools and even quit or restart\nBFGMiner.\n\nHowever, if the 'privileged' test fails, the code will set $readonly to\ntrue.\n\n---------\n\nDefault:\n $userlist = null;\n\nDefine password checking and default access null means there is no password\nchecking.\n\n$userlist is an array of 3 arrays, e.g.\n$userlist = array('sys' => array('boss' => 'bpass'),\n                  'usr' => array('user' => 'upass', 'pleb' => 'ppass'),\n                  'def' => array('Pools'));\n\n'sys' is an array of system users and passwords (full access).\n'usr' is an array of user level users and passwords (readonly access).\n'def' is an array of custompages that anyone not logged in can view.\n\nAny of the 3 can be null, meaning there are none of that item.\n\nAll validated 'usr' users are given $readonly = true; access.\nAll validated 'sys' users are given the $readonly access you defined.\n\nIf 'def' has one or more values, and allowcustompages is true, then anyone\nwithout a password can see the list of custompage buttons given in 'def' and\nwill see the first one when they go to the web page, with a login button at the\ntop right.\n\nFrom the login page, if you login with no username or password, it will show\nthe first 'def' custompage (if there are any).\n\nIf you are logged in, it will show a logout button at the top right.\n\n---------\n\nDefault:\n $notify = true;\n\nSet $notify to false to NOT attempt to display the notify command table of data\n\nSet $notify to true to attempt to display the notify command on the single rig\npage.\nIf your older version of BFGMiner returns an 'Invalid command' because it\ndoesn't have notify - it just shows the error status table.\n\n---------\n\nDefault:\n $checklastshare = true;\n\nSet $checklastshare to true to do the following checks:\nIf a device's last share is 12x expected ago then display as an error.\nIf a device's last share is 8x expected ago then display as a warning.\nIf either of the above is true, also display the whole line highlighted\nThis assumes shares are 1 difficulty shares.\n\nSet $checklastshare to false to not do the above checks.\n\n'expected' is calculated from the device Mh/s value.\nSo for example, a device that hashes at 380Mh/s should (on average) find a\nshare every 11.3s.\nIf the last share was found more than 11.3 x 12 seconds (135.6s) ago, it is\nconsidered an error and highlighted.\nIf the last share was found more than 11.3 x 8 seconds (90.4s) ago, it is\nconsidered a warning and highlighted.\n\nThe default highlighting is very subtle, so change it if you want it to be more\nobvious.\n\n---------\n\nDefault:\n $poolinputs = false;\n\nSet $poolinputs to true to show the input fields for adding a pool and changing\nthe pool priorities on a single rig page.\nHowever, if $readonly is true, it will not display them.\n\n---------\n\nDefault:\n $rigport = 4028;\n\nDefault port to use if any $rigs entries don't specify the port number\n\n---------\n\nDefault:\n $rigs = array('127.0.0.1:4028');\n\nSet $rigs to an array of your BFGMiner rigs that are running format: 'IP' or\n 'Host' or 'IP:Port' or 'Host:Port' or 'Host:Port:Name'.\nIf you only have one rig, it will just show the detail of that rig.\nIf you have more than one rig it will show a summary of all the rigs with\n buttons to show the details of each rig - the button contents will be 'Name'\n rather than rig number, if you specify 'Name'.\nIf Port is missing or blank, it will try $rigport\ne.g. $rigs = array('127.0.0.1:4028','myrig.com:4028:Sugoi');\n\n---------\n\nDefault:\n $rignames = false;\n\nSet $rignames to false to not affect the display.\nSet $rignames to one of 'ip' or 'ipx' to alter the name displayed\nif the rig doesn't have a 'name' in $rigs\nCurrently:\n 'ip' means use the 4th byte of the rig IP address as an integer\n 'ipx' means use the 4th byte of the rig IP address as 2 hex bytes\n\n---------\n\nDefault:\n $rigbuttons = true;\n\nSet $rigbuttons to false to display a link rather than a button on\nthe left of any summary table with rig buttons, in order to reduce\nthe height of the table cells\n\n---------\n\nDefault:\n $mcast = false;\n\nSet $mcast to true to look for your rigs and ignore $rigs.\n\n---------\n\nDefault:\n $mcastexpect = 0;\n\nThe minimum number of rigs expected to be found when $mcast is true.\nIf fewer are found, an error will be included at the top of the page.\n\n---------\n\nDefault:\n $mcastaddr = '224.0.0.75';\n\nAPI Multicast address all miners are listening on.\n\n---------\n\nDefault:\n $mcastport = 4028;\n\nAPI Multicast UDP port all miners are listening on.\n\n---------\n\nDefault:\n $mcastcode = 'FTW';\n\nThe code all miners expect in the Multicast message sent.\nThe message sent is \"cgm-code-listport\".\nDon't use the '-' character if you change it.\n\n---------\n\nDefault:\n $mcastlistport = 4027;\n\nUDP port number that is added to the broadcast message sent\nthat specifies to the miners the port to reply on.\n\n---------\n\nDefault:\n $mcasttimeout = 1.5;\n\nSet $mcasttimeout to the number of seconds (floating point)\nto wait for replies to the Multicast message.\nN.B. the accuracy of the timing used to wait for the replies is\n~0.1s so there's no point making it more than one decimal place.\n\n---------\n\nDefault:\n $mcastretries = 0;\n\nSet $mcastretries to the number of times to retry the multicast.\n\nIf $mcastexpect is 0, this is simply the number of extra times\nthat it will send the multicast request.\nN.B. BFGMiner doesn't listen for multicast requests for 1000ms after\neach one it hears.\n\nIf $mcastexpect is > 0, it will stop looking for replies once it\nhas found at least $mcastexpect rigs, but it only checks this rig\nlimit each time it reaches the $mcasttimeout limit, thus it can find\nmore than $mcastexpect rigs if more exist.\nIt will send the multicast message up to $mcastretries extra times or\nuntil it has found at least $mcastexpect rigs.\nWhen using $mcastretries, it is however possible for it to sometimes\nignore some rigs on the network if $mcastexpect is less than the\nnumber of rigs on the network and some rigs are too slow to reply.\n\n---------\n\nDefault:\n $allowgen = false;\n\nSet $allowgen to true to allow customsummarypages to use 'gen',\nfalse means ignore any 'gen' options.\nThis is disabled by default due to the possible security risk\nof using it, please see the end of this document for an explanation.\n\n---------\n\nDefault:\n $rigipsecurity = true;\n\nSet $rigipsecurity to false to show the IP/Port of the rig in the socket error\n messages and also show the full socket message.\n\n---------\n\nDefault:\n $rigtotals = true;\n $forcerigtotals = false;\n\nSet $rigtotals to true to display totals on the single rig page, 'false' means\n no totals (and ignores $forcerigtotals).\n\nIf $rigtotals is true, all data is also right aligned.\nWith false, it's as before, left aligned.\n\nThis option is just here to allow people to set it to false if they prefer the\n old non-total display when viewing a single rig.\n\nAlso, if there is only one line shown in any section, then no total will be\n shown (to save screen space).\nYou can force it to always show rig totals on the single rig page, even if\n there is only one line, by setting $forcerigtotals = true;\n\n---------\n\nDefault:\n $socksndtimeoutsec = 10;\n $sockrcvtimeoutsec = 40;\n\nThe numbers are integer seconds.\n\nThe defaults should be OK for most cases.\nHowever, the longer SND is, the longer you have to wait while PHP hangs if the\ntarget BFGMiner isn't running or listening.\n\nRCV should only ever be relevant if BFGMiner has hung but the API thread is\nstill running, RCV would normally be >= SND.\n\nFeel free to increase SND if your network is very slow or decrease RCV if that\nhappens often to you.\n\nAlso, on some windows PHP, apparently the $usec is ignored (so usec can't be\nspecified).\n\n---------\n\nDefault:\n $hidefields = array();\n\nList of fields NOT to be displayed.\nYou can use this to hide data you don't want to see or don't want shown on a\npublic web page.\nThe list of sections are:\n SUMMARY, POOL, PGA, GPU, NOTIFY, CONFIG, DEVDETAILS, DEVS\nSee the web page for the list of field names (the table headers).\nIt is an array of 'SECTION.Field Name' => 1\n\nThis example would hide the slightly more sensitive pool information:\nPool URL and pool username:\n $hidefields = array('POOL.URL' => 1, 'POOL.User' => 1);\n\nIf you just want to hide the pool username:\n $hidefields = array('POOL.User' => 1);\n\n---------\n\nDefault:\n $ignorerefresh = false;\n $changerefresh = true;\n $autorefresh = 0;\n\nAuto-refresh of the page (in seconds) - integers only.\n\n$ignorerefresh = true/false always ignore refresh parameters.\n$changerefresh = true/false show buttons to change the value.\n$autorefresh = default value, 0 means don't auto-refresh.\n\n---------\n\nDefault:\n $placebuttons = 'top';\n\nWhere to place the Refresh, Summary, Custom Pages, Quit, etc. buttons.\n\nValid values are: 'top' 'bot' 'both'\n Anything else means don't show them. (case sensitive)\n\n---------\n\nDefault:\n $miner_font_family = 'verdana,arial,sans';\n $miner_font_size = '13pt';\n\nChange these to set the font and font size used on the web page.\n\n---------\n\nDefault:\n $colouroverride = array();\n\nUse this to change the web page colour scheme.\n\nSee $colourtable in miner.php for the list of possible names to change.\n\nSimply put in $colouroverride, just the colours you wish to change.\n\ne.g. to change the colour of the header font and background\nyou could do the following:\n\n $colouroverride = array(\n\t'td.h color'\t\t=> 'green',\n\t'td.h background'\t=> 'blue'\n );\n\n---------\n\nDefault:\n $allowcustompages = true;\n\nShould we allow custom pages?\n(or just completely ignore them and don't display the buttons.)\n\n---------\n\nOK this part is more complex: Custom Summary Pages.\n\nA custom summary page in an array of 'section' => array('FieldA','FieldB'...)\n\nThe section defines what data you want in the summary table and the Fields\ndefine what data you want shown from that section.\n\nStandard sections are:\n SUMMARY, POOL, PGA, GPU, NOTIFY, CONFIG, DEVDETAILS, DEVS, STATS, COIN\n\nFields are the names as shown on the headers on the normal pages.\n\nFields can be 'name=new name' to display 'name' with a different heading\n'new name'.\n\nThere are also now joined sections:\n SUMMARY+POOL, SUMMARY+DEVS, SUMMARY+CONFIG, DEVS+NOTIFY, DEVS+DEVDETAILS\n SUMMARY+COIN\n\nThese sections are an SQL join of the two sections and the fields in them\nare named section.field where 'section.' is the section the field comes from\nSee the example further down.\n\nAlso note:\n- empty tables are not shown.\n- empty columns (e.g. an unknown field) are not shown.\n- missing field data shows as blank.\n- the field name '*' matches all fields except in joined sections\n  (useful for STATS and COIN).\n\nThere are 2 hard coded sections:\n DATE - displays a date table like at the start of 'Summary'.\n RIGS - displays a rig table like at the start of 'Summary'.\n\nEach custom summary requires a second array, that can be empty, listing fields\nto be totalled for each section.\nIf there is no matching total data, no total will show.\n\n---------\n\nLooking at the Mobile example:\n\n $mobilepage = array(\n  'DATE' => null,\n  'RIGS' => null,\n  'SUMMARY' => array('Elapsed', 'MHS av', 'Found Blocks=Blks', \n\t\t\tAccepted', 'Rejected=Rej', 'Utility'),\n  'DEVS+NOTIFY' => array('DEVS.Name=Name', 'DEVS.ID=ID', 'DEVS.ProcID=Proc',\n\t\t\t'DEVS.Status=Status',\n\t\t\t'DEVS.Temperature=Temp', 'DEVS.MHS av=MHS av',\n\t\t\t'DEVS.Accepted=Accept', 'DEVS.Rejected=Rej',\n\t\t\t'DEVS.Utility=Utility', 'NOTIFY.Last Not Well=Not Well'),\n  'POOL' => array('POOL', 'Status', 'Accepted', 'Rejected=Rej',\n                  'Last Share Time'));\n\n $mobilesum = array(\n  'SUMMARY' => array('MHS av', 'Found Blocks', 'Accepted', 'Rejected',\n                     'Utility'),\n  'DEVS+NOTIFY' => array('DEVS.MHS av', 'DEVS.Accepted', 'DEVS.Rejected',\n                         'DEVS.Utility'),\n  'POOL' => array('Accepted', 'Rejected'));\n\n $customsummarypages = array('Mobile' => array($mobilepage, $mobilesum));\n\nThis will show 5 tables (according to $mobilepage).\nEach table will have the chosen details for all the rigs specified in $rigs\n\n DATE\n\tA single box with the web server's current date and time.\n\n RIGS\n\tA table of the rigs: description, time, versions etc.\n\n SUMMARY\n\n\tThis will use the API 'summary' command and show the selected fields:\n\t\tElapsed, MHS av, Found Blocks, Accepted, Rejected and Utility\n\tHowever, 'Rejected=Rej' means that the header displayed for the 'Rejected'\n\tfield will be 'Rej', instead of 'Rejected' (to save space).\n\tSame for 'Found Blocks=Blks' - to save space.\n\n DEVS+NOTIFY\n\n\tThis will list each of the devices on each rig and display the list of\n\tfields as shown.\n\tIt will also include the 'Last Not Well' field from the 'notify' command\n\tso you know when the device was last not well.\n\n\tYou will notice that you need to rename each field e.g. 'DEVS.Name=Name'\n\tsince each field name in the join between DEVS and NOTIFY is actually\n\tsection.fieldname, not just fieldname.\n\n\tThe join code automatically adds 2 fields to each GPU device: 'Name', 'ID',\n\tand 'ProcID'. They don't exist in the API 'devs' output but we can correctly\n\tcalculate them from the GPU device data. These two fields are used to join\n\tDEVS to NOTIFY: i.e. find the NOTIFY record that has the same Name/ID/ProcID\n\tas the DEVS record and join them.\n\n POOL\n\n\tThis will use the API 'pools' command and show the selected fields:\n\t\tPOOL, Status, Accepted, Rejected, Last Share Time\n\tAgain, I renamed the 'Rejected' field using 'Rejected=Rej', to save space.\n\n$mobilesum lists the sections and fields that should have a total.\nYou can't define them for 'DATE' or 'RIGS' since they are hard coded tables.\nThe example given:\n\n SUMMARY\n\tShow a total at the bottom of the columns for:\n\t\tMHS av, Found Blocks, Accepted, Rejected, Utility\n\n\tFirstly note that you use the original name i.e. for 'Rejected=Rej'\n\tyou use 'Rejected', not 'Rej' and not 'Rejected=Rej'.\n\n\tSecondly note that it simply adds up the fields.\n\tIf you ask for a total of a string field you will get the numerical\n\tsum of the string data.\n\n DEVS+NOTIFY\n\n\tSimply note in this join example that you must use the original field\n\tnames which are section.fieldname, not just fieldname.\n\n POOL\n\tShow a total at the bottom of the columns for:\n\t\tAccepted and Rejected\n\n\tAgain remember to use the original field name 'Rejected'.\n\n---------\n\nWith BFGMiner 2.10.1 and later, miner.php includes an extension to the custom\npages that allows you to apply SQL style commands to the data: where, group,\nand having\nBFGMiner 3.4.0 also includes another option 'gen'.\n\nAs an example, miner.php includes a more complex custom page called 'Pools'\nwhich includes the extension:\n\n$poolsext = array(\n 'POOL+STATS' => array(\n        'where' => null,\n        'group' => array('POOL.URL', 'POOL.Has Stratum',\n                         'POOL.Stratum Active'),\n        'calc' => array('STATS.Bytes Sent' => 'sum',\n                        'STATS.Bytes Recv' => 'sum'),\n        'gen' => array('AvShr', 'POOL.Difficulty Accepted/max(POOL.Accepted,1)),\n        'having' => array(array('STATS.Bytes Recv', '>', 0)))\n);\n\nThis allows you to group records together from one or more rigs.\nIn the example, you'll get each Pool (with the same URL+Stratum info) listed\nonce for all rigs and a sum of each of the fields listed in 'calc'.\n\n\n'where' and 'having' are an array of fields and restrictions to apply.\n\nIn the above example, it will only display the rows where it contains the\n'STATS.Bytes Recv' field with a value greater than zero.\nIf the row doesn't have the field, it will always be included.\nAll restrictions must be true in order for the row to be included.\nAny restiction that is invalid or unknown is true.\nAn empty array, or null, means there are no restrictions.\n\nA restriction is formatted as: array('Field', 'restriction', 'value')\nField is the simple field name as normally displayed, or SECTION.Field if it is\na joined section (as in this case 'POOL+STATS').\nThe list of restrictions are:\n'set' - true if the row contains the 'Field' ('value' is not required or used)\n'=', '<', '<=', '>', '>' - a numerical comparison.\n'eq', 'lt', 'le', 'gt', 'ge' - a case insensitive string comparison.\n\nYou can have multiple restrictions on a 'Field' - but all must be true to\ninclude the row containing the 'Field'.\ne.g. a number range between 0 and 10 would be:\narray('STATS.Bytes Recv', '>', 0), array('STATS.Bytes Recv', '<', 10)\n\nThe difference between 'where' and 'having' is that 'where' is applied to the\ndata before grouping it and 'having' is applied to the data after grouping it\n- otherwise they work the same.\n\n\n'group' lists the fields to group over and 'calc' lists the function to apply\nto other fields that are not part of 'group'.\n\nYou can only see fields listed in 'group' and 'calc'.\n\nA 'calc' is formatted as: 'Field' => 'function'\nThe current list of operations available for 'calc' are:\n'sum', 'avg', 'min', 'max', 'lo', 'hi', 'count', 'any'\nThe first 4 are as expected - the numerical sum, average, minimum or maximum.\n'lo' is the first string of the list, sorted ignoring case.\n'hi' is the last string of the list, sorted ignoring case.\n'count' is the number of rows in the section specified in the calc e.g.\n ('DEVS.Name' => 'count') would be the number of DEVS selected in the 'where'\n of course any valid 'DEVS.Xyz' would give the same 'count' value.\n'any' is effectively random: the field value in the 1st row of the grouped data.\nAn unrecognised 'function' uses 'any'.\n\nA 'gen' allows you to generate new fields from any php valid function of any\nof the other fields.\n e.g. 'gen' => array('AvShr', 'POOL.Difficulty Accepted/max(POOL.Accepted,1)),\nwill generate a new field called GEN.AvShr that is the function shown, which\nin this case is the average difficulty of each share submitted.\n\nTHERE IS A SECURITY RISK WITH HOW GEN WORKS!\nIt simply replaces all the variables with their values and then requests PHP\nto execute the formula - thus if a field value returned from a BFGMiner API\nrequest contained PHP code, it could be executed by your web server.\nOf course BFGMiner doesn't do this, but if you do not control the BFGMiner that\nreturns the data in the API calls, someone could modify BFGMiner to return a\nPHP string in a field you use in 'gen'.\nThus use 'gen' at your own risk.\nIf someone feels the urge to write a mathematical interpreter in PHP to get\naround this risk, feel free to write one and submit it to the API author for\nconsideration.\n"
        },
        {
          "name": "README.scrypt",
          "type": "blob",
          "size": 9.6142578125,
          "content": "If you wish to donate to the author of scrypt support, Con Kolivas, for his past\nwork (he no longer maintains this), please send your donations to:\n15qSxP1SQcUX3o4nhkfdbgyoWEFMomJ4rZ\n\n---\n\nScrypt mining for GPU is completely different to sha256 used for bitcoin\nmining. It has very different requirements to bitcoin mining and is a\nlot more complicated to get working well. Note that it is a ram dependent\nworkload, and requires you to have enough system ram as well as fast enough\nGPU ram.\n\nSince scrypt ASICs are widely available, GPUs are not used by default. If you\nwant to use them, use the -S opencl:auto option. Note that scrypt ASICs are\ndocumented in README.ASIC rather than this file, which only deals with GPU\nmining.\n\nThere are 5 main parameters to tuning scrypt, all of which are optional for\nfurther fine tuning. When you start scrypt mining with the --scrypt option,\nBFGMiner will fail IN RANDOM WAYS. They are all due to parameters being outside\nwhat the GPU can cope with.\n\nNOTE that if it does not fail at startup, the presence of hardware errors (HW)\nare a sure sign that you have set the parameters too high.\n\n\nDRIVERS AND OPENCL SDK\n\nThe choice of driver version for your GPU is critical, as some are known to\nbreak scrypt mining entirely while others give poor hashrates. As for the\nOpenCL SDK installed, for AMD it must be version 2.6 or later.\n\n\nStep 1 on Linux:\nexport GPU_MAX_ALLOC_PERCENT=100\nIf you do not do this, you may find it impossible to scrypt mine. You may find\na value of 40 is enough and increasing this further has little effect.\n\nexport GPU_USE_SYNC_OBJECTS=1\nmay help CPU usage a little as well.\n\nOn windows the same commands can be passed via a batch file if the following\nlines are in the .bat before starting BFGMiner:\nsetx GPU_MAX_ALLOC_PERCENT 100\nsetx GPU_USE_SYNC_OBJECTS 1\n\nintensity=XX\n\nJust like in Bitcoin mining, scrypt mining takes an intensity, however the\nscale goes from 0 to 31. \nThe reason this is crucial is that too high an intensity can actually be\ndisastrous with scrypt because it CAN run out of ram. High intensities\nstart writing over the same ram and it is highly dependent on the GPU, but they\ncan start actually DECREASING your hashrate, or even worse, start producing\ngarbage with HW errors skyrocketing. Note that if you do NOT specify an\nintensity, BFGMiner uses dynamic mode which is designed to minimise the harm\nto a running desktop and performance WILL be poor. The lower limit to intensity\nwith scrypt is usually 8 and BFGMiner will prevent it going too low.\nSUMMARY: Setting this for reasonable hashrates is mandatory.\n\nshaders=XXX\n\nis a new option where you tell BFGMiner how many shaders your GPU has. This\nhelps BFGMiner try to choose some meaningful baseline parameters. Use this table\nbelow to determine how many shaders your GPU has, and note that there are some\nvariants of these cards, and Nvidia shaders are much much lower and virtually\npointless trying to mine on. If this is not set, BFGMiner will query the\ndevice for how much memory it supports and will try to set a value based on\nthat instead.\nSUMMARY: This will get you started but fine tuning for optimal performance is\nrequired.\n\nGPU  Shaders\n7750 512\n7770 640\n7850 1024\n7870 1280\n7950 1792\n7970 2048\n\n6850 960\n6870 1120\n6950 1408\n6970 1536\n6990 (6970x2)\n\n6570 480\n6670 480\n6790 800\n\n6450 160\n\n5670 400\n5750 720\n5770 800\n5830 1120\n5850 1440\n5870 1600\n5970 (5870x2)\n\nThese are only used as a rough guide for BFGMiner, and it is rare that this is\nall you will need to set.\n\n\nOptional parameters to tune:\nkernel, threads, thread-concurrency, lookup-gap\n\nkernel:\nThis selects the OpenCL code to use. By default, the kernel named \"scrypt\" will\nbe used. BFGMiner also includes optimised versions from Zuikkis and Pavel\nSemjanov, which you can specify by filename:\n    --set-device OCL:kernel=zuikkis\n    --set-device OCL:kernel=psw\nNote that Zuikkis' version requires the default lookup-gap of 2.\n\nthread-concurrency:\nThis tunes the optimal size of work that scrypt can do. It is internally tuned\nby BFGMiner to be the highest reasonable multiple of shaders that it can\nallocate on your GPU. Ideally it should be a multiple of your shader count.\nvliw5 architecture (R5XXX) would be best at 5x shaders, while VLIW4 (R6xxx and\nR7xxx) are best at 4x. Setting thread concurrency overrides anything you put\ninto the shaders config and is ultimately a BETTER way to tune performance.\nSUMMARY: Spend lots of time finding the highest value that your device likes\nand increases hashrate.\n\nthreads:\nOnce you have found the optimal shaders and intensity, you can start increasing\nthe threads value till BFGMiner fails to start. This is really only of value if\nyou want to run low intensities as you will be unable to run more than 1.\nSUMMARY: Don't touch this.\n\nlookup-gap:\nThis tunes a compromise between ram usage and performance. Performance peaks\nat a gap of 2, but increasing the gap can save you some GPU ram, but almost\nalways at the cost of significant loss of hashrate. Setting lookup gap\noverrides the default of 2, but BFGMiner will use the provided shaders value to\nchoose a thread-concurrency if you haven't chosen one.\nSUMMARY: Don't touch this.\n\n\nRelated parameters:\nwork_size=XX\nHas a minor effect, should be a multiple of 64 up to 256 maximum.\nSUMMARY: Worth playing with once everything else has been tried but will\nprobably do nothing.\n\nvectors=XX\nVectors are NOT used by scrypt mining kernels.\nSUMMARY: Does nothing.\n\n\nOverclocking for scrypt mining:\nFirst of all, do not underclock your memory initially. Scrypt mining requires\nmemory speed and on most, but not all, GPUs, lowering memory speed lowers\nmining performance.\n\nSecond, absolute engine clock speeds do NOT correlate with hashrate. The ratio\nof engine clock speed to memory matters, so if you set your memory to the\ndefault value, and then start overclocking as you are running it, you should\nfind a sweet spot where the hashrate peaks and then it might actually drop if\nyou increase the engine clock speed further.\n\nThird, the combination of motherboard, CPU and system ram ALSO makes a\ndifference, so values that work for a GPU on one system may not work for the\nsame GPU on a different system. A decent amount of system ram is actually\nrequired for scrypt mining, and 4GB is suggested.\n\nFinally, the power consumption while mining at high engine clocks, very high\nmemory clocks can be far in excess of what you might imagine.\nFor example, a 7970 running with the following settings:\n--set-device OCL:thread-concurrency=22392 --set-device OCL:clock=1135\n--set-device OCL:memclock=1890\nwas using 305W!\n\n---\nTUNING AN AMD RADEON 7970\nExample tuning a 7970 for Scrypt mining:\n\nOn Linux run this command:\nexport GPU_MAX_ALLOC_PERCENT=100\nor on Windows this:\nsetx GPU_MAX_ALLOC_PERCENT 100\nin the same console/bash/dos prompt/bat file/whatever you want to call it,\nbefore running BFGMiner.\n\nFirst, find the highest thread concurrency that you can start it at. They should\nall start at 8192 but some will go up to 3 times that. Don't go too high on the\nintensity while testing and don't change gpu threads. If you cannot go above\n8192, don't fret as you can still get a high hashrate.\n\nDelete any .bin files so you're starting from scratch and see what bins get\ngenerated.\n\nFirst try without any thread concurrency or even shaders, as BFGMiner will try to\nfind an optimal value:\nbfgminer --set-device OCL:intensity=13\n\nIf that starts mining, see what bin was generated, it is likely the largest\nmeaningful TC you can set.\nStarting it on mine I get:\nscrypt130302Tahitiglg2tc22392w64l8.bin\n\nNote that tc22392 tells you what thread concurrency it was. It should start\nwithout TC parameters, but you never know. So if it doesn't, start with\n--set-device OCL:thread-concurrency=8192 and add 2048 to it at a time till you\nfind the highest value it will start successfully at.\n\nIf you wish to get a little extra from your hardware, you may also try\noverclocking. Do note that this will damage your GPUs and void your warranty,\nso unless you are willing to take that risk, skip the clock and memclock\nparameters!\n\nThen start overclocking the eyeballs off your memory, as 7970s are exquisitely\nsensitive to memory speed and amazingly overclockable but please make sure it\nkeeps adequately cooled with --auto-fan! Do it while it's running from the GPU\nmenu. Go up by 25 at a time every 30 seconds or so until your GPU crashes. Then\nreboot and start it 25 lower as a rough start. One example runs stable at 1900\nmemory without overvolting.\n\nThen once you find the maximum memory clock speed, you need to find the sweet\nspot engine clock speed that matches it. It's a fine line where one more MHz\nwill make the hashrate drop by 20%. It's somewhere in the .57 - 0.6 ratio range.\nStart your engine clock speed at half your memory clock speed and then increase\nit by 5 at a time. The hashrate should climb a little each rise in engine speed\nand then suddenly drop above a certain value. Decrease it by 1 then until you\nfind it climbs dramatically. If your engine clock speed cannot get that high\nwithout crashing the GPU, you will have to use a lower memclock.\n\nThen, and only then, bother trying to increase intensity further.\n\nMy final settings were:\n--set-device OCL:clock=1141 --set-device OCL:memclock=1875 --set-device OCL:intensity=20\nfor a hashrate of 745kH.\n\nNote I did not bother setting a thread concurrency. Once you have the magic\nendpoint, look at what tc was chosen by the bin file generated and then hard\ncode that in next time (eg --set-device OCL:thread-concurrency=22392) as slight\nchanges in thread concurrency will happen every time if you don't specify one,\nand the tc to clock ratios are critical!\n\nYour numbers will be your numbers depending on your hardware combination and OS,\nso don't expect to get exactly the same results!\n"
        },
        {
          "name": "adl.c",
          "type": "blob",
          "size": 46.11328125,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2012-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifdef HAVE_ADL\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#ifdef HAVE_CURSES\n// Must be before stdbool, since pdcurses typedefs bool :/\n#include <curses.h>\n#endif\n\n#include <stdbool.h>\n\n#include \"driver-opencl.h\"\n#include \"miner.h\"\n#include \"ADL/adl_sdk.h\"\n#include \"compat.h\"\n\n#ifndef WIN32\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <unistd.h>\n#else /* WIN32 */\n#include <windows.h>\n#include <tchar.h>\n#endif\n#include \"adl_functions.h\"\n\n#ifndef __stdcall\n#define __stdcall\n#endif\n\n#ifndef HAVE_CURSES\n#define wlogprint(...)  applog(LOG_WARNING, __VA_ARGS__)\n#endif\n\nbool adl_active;\nbool opt_reorder = false;\n\nstatic\nconst int opt_targettemp = 75;\nconst int opt_overheattemp = 85;\nstatic pthread_mutex_t adl_lock;\n\nstruct gpu_adapters {\n\tint iAdapterIndex;\n\tint iBusNumber;\n\tint virtual_gpu;\n\tint id;\n};\n\n// Memory allocation function\nstatic void * __stdcall ADL_Main_Memory_Alloc(int iSize)\n{\n\tvoid *lpBuffer = malloc(iSize);\n\n\treturn lpBuffer;\n}\n\n// Optional Memory de-allocation function\nstatic void __stdcall ADL_Main_Memory_Free (void **lpBuffer)\n{\n\tif (*lpBuffer) {\n\t\tfree (*lpBuffer);\n\t\t*lpBuffer = NULL;\n\t}\n}\n\n#ifndef WIN32\n// equivalent functions in linux\nstatic void *GetProcAddress(void *pLibrary, const char *name)\n{\n\treturn dlsym( pLibrary, name);\n}\n#endif\n\nstatic\tADL_MAIN_CONTROL_CREATE\t\tADL_Main_Control_Create;\nstatic\tADL_MAIN_CONTROL_DESTROY\tADL_Main_Control_Destroy;\nstatic\tADL_ADAPTER_NUMBEROFADAPTERS_GET\tADL_Adapter_NumberOfAdapters_Get;\nstatic\tADL_ADAPTER_ADAPTERINFO_GET\tADL_Adapter_AdapterInfo_Get;\nstatic\tADL_ADAPTER_ID_GET\t\tADL_Adapter_ID_Get;\nstatic\tADL_OVERDRIVE5_TEMPERATURE_GET\tADL_Overdrive5_Temperature_Get;\nstatic\tADL_OVERDRIVE5_CURRENTACTIVITY_GET\tADL_Overdrive5_CurrentActivity_Get;\nstatic\tADL_OVERDRIVE5_ODPARAMETERS_GET\tADL_Overdrive5_ODParameters_Get;\nstatic\tADL_OVERDRIVE5_FANSPEEDINFO_GET\tADL_Overdrive5_FanSpeedInfo_Get;\nstatic\tADL_OVERDRIVE5_FANSPEED_GET\tADL_Overdrive5_FanSpeed_Get;\nstatic\tADL_OVERDRIVE5_FANSPEED_SET\tADL_Overdrive5_FanSpeed_Set;\nstatic\tADL_OVERDRIVE5_ODPERFORMANCELEVELS_GET\tADL_Overdrive5_ODPerformanceLevels_Get;\nstatic\tADL_OVERDRIVE5_ODPERFORMANCELEVELS_SET\tADL_Overdrive5_ODPerformanceLevels_Set;\nstatic\tADL_MAIN_CONTROL_REFRESH\tADL_Main_Control_Refresh;\nstatic\tADL_OVERDRIVE5_POWERCONTROL_GET\tADL_Overdrive5_PowerControl_Get;\nstatic\tADL_OVERDRIVE5_POWERCONTROL_SET\tADL_Overdrive5_PowerControl_Set;\nstatic\tADL_OVERDRIVE5_FANSPEEDTODEFAULT_SET\tADL_Overdrive5_FanSpeedToDefault_Set;\n\n#ifndef WIN32\n\tstatic void *hDLL;\t// Handle to .so library\n#else /* WIN32 */\n\tHINSTANCE hDLL;\t\t// Handle to DLL\n#endif\nstatic int iNumberAdapters;\nstatic LPAdapterInfo lpInfo = NULL;\n\nint set_fanspeed(int gpu, int iFanSpeed);\nstatic float __gpu_temp(struct gpu_adl *ga);\n\nstatic inline void lock_adl(void)\n{\n\tmutex_lock(&adl_lock);\n}\n\nstatic inline void unlock_adl(void)\n{\n\tmutex_unlock(&adl_lock);\n}\n\n/* This looks for the twin GPU that has the fanspeed control of a non fanspeed\n * control GPU on dual GPU cards */\nstatic bool fanspeed_twin(struct gpu_adl *ga, struct gpu_adl *other_ga)\n{\n\tif (!other_ga->has_fanspeed)\n\t\treturn false;\n\tif (abs(ga->iBusNumber - other_ga->iBusNumber) != 1)\n\t\treturn false;\n\tif (strcmp(ga->strAdapterName, other_ga->strAdapterName))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool prepare_adl(void)\n{\n\tint result;\n\n#if defined(WIN32) || defined(__CYGWIN__)\n#\tifdef __CYGWIN__\n#\t\tdefine LoadLibrary(x) dlopen(x, RTLD_LAZY|RTLD_GLOBAL);\n#\tendif\n\thDLL = LoadLibrary(\"atiadlxx.dll\");\n\tif (hDLL == NULL)\n\t\t// A 32 bit calling application on 64 bit OS will fail to LoadLIbrary.\n\t\t// Try to load the 32 bit library (atiadlxy.dll) instead\n\t\thDLL = LoadLibrary(\"atiadlxy.dll\");\n#else\n\thDLL = dlopen( \"libatiadlxx.so\", RTLD_LAZY|RTLD_GLOBAL);\n#endif\n\tif (hDLL == NULL) {\n\t\tapplog(LOG_INFO, \"Unable to load ati adl library\");\n\t\treturn false;\n\t}\n\tADL_Main_Control_Create = (ADL_MAIN_CONTROL_CREATE) GetProcAddress(hDLL,\"ADL_Main_Control_Create\");\n\tADL_Main_Control_Destroy = (ADL_MAIN_CONTROL_DESTROY) GetProcAddress(hDLL,\"ADL_Main_Control_Destroy\");\n\tADL_Adapter_NumberOfAdapters_Get = (ADL_ADAPTER_NUMBEROFADAPTERS_GET) GetProcAddress(hDLL,\"ADL_Adapter_NumberOfAdapters_Get\");\n\tADL_Adapter_AdapterInfo_Get = (ADL_ADAPTER_ADAPTERINFO_GET) GetProcAddress(hDLL,\"ADL_Adapter_AdapterInfo_Get\");\n\tADL_Adapter_ID_Get = (ADL_ADAPTER_ID_GET) GetProcAddress(hDLL,\"ADL_Adapter_ID_Get\");\n\tADL_Overdrive5_Temperature_Get = (ADL_OVERDRIVE5_TEMPERATURE_GET) GetProcAddress(hDLL,\"ADL_Overdrive5_Temperature_Get\");\n\tADL_Overdrive5_CurrentActivity_Get = (ADL_OVERDRIVE5_CURRENTACTIVITY_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_CurrentActivity_Get\");\n\tADL_Overdrive5_ODParameters_Get = (ADL_OVERDRIVE5_ODPARAMETERS_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_ODParameters_Get\");\n\tADL_Overdrive5_FanSpeedInfo_Get = (ADL_OVERDRIVE5_FANSPEEDINFO_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_FanSpeedInfo_Get\");\n\tADL_Overdrive5_FanSpeed_Get = (ADL_OVERDRIVE5_FANSPEED_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_FanSpeed_Get\");\n\tADL_Overdrive5_FanSpeed_Set = (ADL_OVERDRIVE5_FANSPEED_SET) GetProcAddress(hDLL, \"ADL_Overdrive5_FanSpeed_Set\");\n\tADL_Overdrive5_ODPerformanceLevels_Get = (ADL_OVERDRIVE5_ODPERFORMANCELEVELS_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_ODPerformanceLevels_Get\");\n\tADL_Overdrive5_ODPerformanceLevels_Set = (ADL_OVERDRIVE5_ODPERFORMANCELEVELS_SET) GetProcAddress(hDLL, \"ADL_Overdrive5_ODPerformanceLevels_Set\");\n\tADL_Main_Control_Refresh = (ADL_MAIN_CONTROL_REFRESH) GetProcAddress(hDLL, \"ADL_Main_Control_Refresh\");\n\tADL_Overdrive5_PowerControl_Get = (ADL_OVERDRIVE5_POWERCONTROL_GET) GetProcAddress(hDLL, \"ADL_Overdrive5_PowerControl_Get\");\n\tADL_Overdrive5_PowerControl_Set = (ADL_OVERDRIVE5_POWERCONTROL_SET) GetProcAddress(hDLL, \"ADL_Overdrive5_PowerControl_Set\");\n\tADL_Overdrive5_FanSpeedToDefault_Set = (ADL_OVERDRIVE5_FANSPEEDTODEFAULT_SET) GetProcAddress(hDLL, \"ADL_Overdrive5_FanSpeedToDefault_Set\");\n\n\tif (!ADL_Main_Control_Create || !ADL_Main_Control_Destroy ||\n\t\t!ADL_Adapter_NumberOfAdapters_Get || !ADL_Adapter_AdapterInfo_Get ||\n\t\t!ADL_Adapter_ID_Get || !ADL_Overdrive5_Temperature_Get ||\n\t\t!ADL_Overdrive5_CurrentActivity_Get ||\n\t\t!ADL_Overdrive5_ODParameters_Get || !ADL_Overdrive5_FanSpeedInfo_Get ||\n\t\t!ADL_Overdrive5_FanSpeed_Get || !ADL_Overdrive5_FanSpeed_Set ||\n\t\t!ADL_Overdrive5_ODPerformanceLevels_Get || !ADL_Overdrive5_ODPerformanceLevels_Set ||\n\t\t!ADL_Main_Control_Refresh || !ADL_Overdrive5_PowerControl_Get ||\n\t\t!ADL_Overdrive5_PowerControl_Set || !ADL_Overdrive5_FanSpeedToDefault_Set) {\n\t\t\tapplog(LOG_WARNING, \"ATI ADL's API is missing\");\n\t\treturn false;\n\t}\n\n\t// Initialise ADL. The second parameter is 1, which means:\n\t// retrieve adapter information only for adapters that are physically present and enabled in the system\n\tresult = ADL_Main_Control_Create (ADL_Main_Memory_Alloc, 1);\n\tif (result != ADL_OK) {\n\t\tapplog(LOG_INFO, \"ADL Initialisation Error! Error %d!\", result);\n\t\treturn false;\n\t}\n\n\tresult = ADL_Main_Control_Refresh();\n\tif (result != ADL_OK) {\n\t\tapplog(LOG_INFO, \"ADL Refresh Error! Error %d!\", result);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid init_adl(int nDevs)\n{\n\tint result, i, j, devices = 0, last_adapter = -1, gpu = 0, dummy = 0;\n\tstruct gpu_adapters adapters[MAX_GPUDEVICES], vadapters[MAX_GPUDEVICES];\n\tbool devs_match = true;\n\n\tif (unlikely(pthread_mutex_init(&adl_lock, NULL))) {\n\t\tapplog(LOG_ERR, \"Failed to init adl_lock in init_adl\");\n\t\treturn;\n\t}\n\n\tif (!prepare_adl())\n\t\treturn;\n\n\t// Obtain the number of adapters for the system\n\tresult = ADL_Adapter_NumberOfAdapters_Get (&iNumberAdapters);\n\tif (result != ADL_OK) {\n\t\tapplog(LOG_INFO, \"Cannot get the number of adapters! Error %d!\", result);\n\t\treturn ;\n\t}\n\n\tif (iNumberAdapters > 0) {\n\t\tlpInfo = malloc ( sizeof (AdapterInfo) * iNumberAdapters );\n\t\tmemset ( lpInfo,'\\0', sizeof (AdapterInfo) * iNumberAdapters );\n\n\t\tlpInfo->iSize = sizeof(lpInfo);\n\t\t// Get the AdapterInfo structure for all adapters in the system\n\t\tresult = ADL_Adapter_AdapterInfo_Get (lpInfo, sizeof (AdapterInfo) * iNumberAdapters);\n\t\tif (result != ADL_OK) {\n\t\t\tapplog(LOG_INFO, \"ADL_Adapter_AdapterInfo_Get Error! Error %d\", result);\n\t\t\treturn ;\n\t\t}\n\t} else {\n\t\tapplog(LOG_INFO, \"No adapters found\");\n\t\treturn;\n\t}\n\n\t/* Iterate over iNumberAdapters and find the lpAdapterID of real devices */\n\tfor (i = 0; i < iNumberAdapters; i++) {\n\t\tint iAdapterIndex;\n\t\tint lpAdapterID;\n\n\t\tiAdapterIndex = lpInfo[i].iAdapterIndex;\n\t\t/* Get unique identifier of the adapter, 0 means not AMD */\n\t\tresult = ADL_Adapter_ID_Get(iAdapterIndex, &lpAdapterID);\n\t\tif (result != ADL_OK) {\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Adapter_ID_Get. Error %d\", result);\n\t\t\tif (result == -10)\n\t\t\t\tapplog(LOG_INFO, \"This error says the device is not enabled\");\n\t\t}\n\t\telse\n\t\t/* Each adapter may have multiple entries */\n\t\tif (lpAdapterID == last_adapter)\n\t\t\tcontinue;\n\t\telse\n\t\tif (!lpAdapterID)\n\t\t\tapplog(LOG_INFO, \"Adapter returns ID 0 meaning not AMD. Card order might be confused\");\n\t\telse\n\t\t\tlast_adapter = lpAdapterID;\n\n\t\tapplog(LOG_DEBUG, \"GPU %d \"\n\t\t       \"iAdapterIndex %d \"\n\t\t       \"strUDID %s \"\n\t\t       \"iBusNumber %d \"\n\t\t       \"iDeviceNumber %d \"\n\t\t       \"iFunctionNumber %d \"\n\t\t       \"iVendorID %d \"\n\t\t       \"strAdapterName  %s \",\n\t\t       devices,\n\t\t       iAdapterIndex,\n\t\t       lpInfo[i].strUDID,\n\t\t       lpInfo[i].iBusNumber,\n\t\t       lpInfo[i].iDeviceNumber,\n\t\t       lpInfo[i].iFunctionNumber,\n\t\t       lpInfo[i].iVendorID,\n\t\t       lpInfo[i].strAdapterName);\n\n\t\tadapters[devices].iAdapterIndex = iAdapterIndex;\n\t\tadapters[devices].iBusNumber = lpInfo[i].iBusNumber;\n\t\tadapters[devices].id = i;\n\n\t\t/* We found a truly new adapter instead of a logical\n\t\t * one. Now since there's no way of correlating the\n\t\t * opencl enumerated devices and the ADL enumerated\n\t\t * ones, we have to assume they're in the same order.*/\n\t\tif (++devices > nDevs && devs_match) {\n\t\t\tapplog(LOG_ERR, \"ADL found more devices than opencl!\");\n\t\t\tapplog(LOG_ERR, \"There is possibly at least one GPU that doesn't support OpenCL\");\n\t\t\tapplog(LOG_ERR, \"Use the gpu map feature to reliably map OpenCL to ADL\");\n\t\t\tdevs_match = false;\n\t\t}\n\t}\n\n\tif (devices < nDevs) {\n\t\tapplog(LOG_ERR, \"ADL found less devices than opencl!\");\n\t\tapplog(LOG_ERR, \"There is possibly more than one display attached to a GPU\");\n\t\tapplog(LOG_ERR, \"Use the gpu map feature to reliably map OpenCL to ADL\");\n\t\tdevs_match = false;\n\t}\n\n\tfor (i = 0; i < devices; i++) {\n\t\tvadapters[i].virtual_gpu = i;\n\t\tvadapters[i].id = adapters[i].id;\n\t}\n\n\t/* Apply manually provided OpenCL to ADL mapping, if any */\n\tfor (i = 0; i < nDevs; i++) {\n\t\tstruct opencl_device_data * const data = gpus[i].device_data;\n\t\tif (data->mapped) {\n\t\t\tvadapters[data->virtual_adl].virtual_gpu = i;\n\t\t\tapplog(LOG_INFO, \"Mapping OpenCL device %d to ADL device %d\", i, data->virtual_adl);\n\t\t} else\n\t\t\tdata->virtual_adl = i;\n\t}\n\n\tif (!devs_match) {\n\t\tapplog(LOG_ERR, \"WARNING: Number of OpenCL and ADL devices did not match!\");\n\t\tapplog(LOG_ERR, \"Hardware monitoring may NOT match up with devices!\");\n\t} else if (opt_reorder) {\n\t\t/* Windows has some kind of random ordering for bus number IDs and\n\t\t * ordering the GPUs according to ascending order fixes it. Linux\n\t\t * has usually sequential but decreasing order instead! */\n\t\tfor (i = 0; i < devices; i++) {\n\t\t\tint j, virtual_gpu;\n\n\t\t\tvirtual_gpu = 0;\n\t\t\tfor (j = 0; j < devices; j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n#ifdef WIN32\n\t\t\t\tif (adapters[j].iBusNumber < adapters[i].iBusNumber)\n#else\n\t\t\t\tif (adapters[j].iBusNumber > adapters[i].iBusNumber)\n#endif\n\t\t\t\t\tvirtual_gpu++;\n\t\t\t}\n\t\t\tif (virtual_gpu != i) {\n\t\t\t\tapplog(LOG_INFO, \"Mapping device %d to GPU %d according to Bus Number order\",\n\t\t\t\t       i, virtual_gpu);\n\t\t\t\tvadapters[virtual_gpu].virtual_gpu = i;\n\t\t\t\tvadapters[virtual_gpu].id = adapters[i].id;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (devices > nDevs)\n\t\tdevices = nDevs;\n\n\tfor (gpu = 0; gpu < devices; gpu++) {\n\t\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\t\tstruct opencl_device_data * const data = cgpu->device_data;\n\t\tstruct gpu_adl *ga;\n\t\tint iAdapterIndex;\n\t\tint lpAdapterID;\n\t\tADLODPerformanceLevels *lpOdPerformanceLevels;\n\t\tint lev, adlGpu;\n\n\t\tadlGpu = data->virtual_adl;\n\t\ti = vadapters[adlGpu].id;\n\t\tiAdapterIndex = lpInfo[i].iAdapterIndex;\n\t\tdata->virtual_gpu = vadapters[adlGpu].virtual_gpu;\n\n\t\t/* Get unique identifier of the adapter, 0 means not AMD */\n\t\tresult = ADL_Adapter_ID_Get(iAdapterIndex, &lpAdapterID);\n\t\tif (result != ADL_OK) {\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Adapter_ID_Get. Error %d\", result);\n\t\t\tlpAdapterID = -1;\n\t\t}\n\n\t\tif (gpus[gpu].deven == DEV_DISABLED) {\n\t\t\tdata->gpu_engine =\n\t\t\tdata->gpu_memclock =\n\t\t\tdata->gpu_vddc =\n\t\t\tdata->gpu_fan =\n\t\t\tdata->gpu_powertune = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tapplog(LOG_INFO, \"GPU %d %s hardware monitoring enabled\", gpu, lpInfo[i].strAdapterName);\n\t\tif (gpus[gpu].name) {\n\t\t\tfree((void*)gpus[gpu].name);\n\t\t\tgpus[gpu].name = NULL;\n\t\t}\n\t\tif (lpInfo[i].strAdapterName[0])\n\t\t\tgpus[gpu].name = trimmed_strdup(lpInfo[i].strAdapterName);\n\t\tdata->has_adl = true;\n\t\t/* Flag adl as active if any card is successfully activated */\n\t\tadl_active = true;\n\n\t\t/* From here on we know this device is a discrete device and\n\t\t * should support ADL */\n\t\tga = &data->adl;\n\t\tga->gpu = gpu;\n\t\tga->iAdapterIndex = iAdapterIndex;\n\t\tga->lpAdapterID = lpAdapterID;\n\t\tstrcpy(ga->strAdapterName, lpInfo[i].strAdapterName);\n\t\tga->DefPerfLev = NULL;\n\t\tga->twin = NULL;\n\n\t\tga->lpOdParameters.iSize = sizeof(ADLODParameters);\n\t\tif (ADL_Overdrive5_ODParameters_Get(iAdapterIndex, &ga->lpOdParameters) != ADL_OK)\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Overdrive5_ODParameters_Get\");\n\n\t\tlev = ga->lpOdParameters.iNumberOfPerformanceLevels - 1;\n\t\t/* We're only interested in the top performance level */\n\t\tlpOdPerformanceLevels = malloc(sizeof(ADLODPerformanceLevels) + (lev * sizeof(ADLODPerformanceLevel)));\n\t\tlpOdPerformanceLevels->iSize = sizeof(ADLODPerformanceLevels) + sizeof(ADLODPerformanceLevel) * lev;\n\n\t\t/* Get default performance levels first */\n\t\tif (ADL_Overdrive5_ODPerformanceLevels_Get(iAdapterIndex, 1, lpOdPerformanceLevels) != ADL_OK)\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Overdrive5_ODPerformanceLevels_Get\");\n\t\t/* Set the limits we'd use based on default gpu speeds */\n\t\tga->maxspeed = ga->minspeed = lpOdPerformanceLevels->aLevels[lev].iEngineClock;\n\n\t\tga->lpTemperature.iSize = sizeof(ADLTemperature);\n\t\tga->lpFanSpeedInfo.iSize = sizeof(ADLFanSpeedInfo);\n\t\tga->lpFanSpeedValue.iSize = ga->DefFanSpeedValue.iSize = sizeof(ADLFanSpeedValue);\n\t\t/* Now get the current performance levels for any existing overclock */\n\t\tADL_Overdrive5_ODPerformanceLevels_Get(iAdapterIndex, 0, lpOdPerformanceLevels);\n\t\t/* Save these values as the defaults in case we wish to reset to defaults */\n\t\tga->DefPerfLev = lpOdPerformanceLevels;\n\n\t\tif (data->gpu_engine) {\n\t\t\tint setengine = data->gpu_engine * 100;\n\n\t\t\t/* Lower profiles can't have a higher setting */\n\t\t\tfor (j = 0; j < lev; j++) {\n\t\t\t\tif (lpOdPerformanceLevels->aLevels[j].iEngineClock > setengine)\n\t\t\t\t\tlpOdPerformanceLevels->aLevels[j].iEngineClock = setengine;\n\t\t\t}\n\t\t\tlpOdPerformanceLevels->aLevels[lev].iEngineClock = setengine;\n\t\t\tapplog(LOG_INFO, \"Setting GPU %d engine clock to %d\", gpu, data->gpu_engine);\n\t\t\tADL_Overdrive5_ODPerformanceLevels_Set(iAdapterIndex, lpOdPerformanceLevels);\n\t\t\tga->maxspeed = setengine;\n\t\t\tif (data->min_engine)\n\t\t\t\tga->minspeed = data->min_engine * 100;\n\t\t\tga->managed = true;\n\t\t\tif (data->gpu_memdiff)\n\t\t\t\tset_memoryclock(gpu, data->gpu_engine + data->gpu_memdiff);\n\t\t}\n\n\t\tif (data->gpu_memclock) {\n\t\t\tint setmem = data->gpu_memclock * 100;\n\n\t\t\tfor (j = 0; j < lev; j++) {\n\t\t\t\tif (lpOdPerformanceLevels->aLevels[j].iMemoryClock > setmem)\n\t\t\t\t\tlpOdPerformanceLevels->aLevels[j].iMemoryClock = setmem;\n\t\t\t}\n\t\t\tlpOdPerformanceLevels->aLevels[lev].iMemoryClock = setmem;\n\t\t\tapplog(LOG_INFO, \"Setting GPU %d memory clock to %d\", gpu, data->gpu_memclock);\n\t\t\tADL_Overdrive5_ODPerformanceLevels_Set(iAdapterIndex, lpOdPerformanceLevels);\n\t\t\tga->managed = true;\n\t\t}\n\n\t\tif (data->gpu_vddc) {\n\t\t\tint setv = data->gpu_vddc * 1000;\n\n\t\t\tfor (j = 0; j < lev; j++) {\n\t\t\t\tif (lpOdPerformanceLevels->aLevels[j].iVddc > setv)\n\t\t\t\t\tlpOdPerformanceLevels->aLevels[j].iVddc = setv;\n\t\t\t}\n\t\t\tlpOdPerformanceLevels->aLevels[lev].iVddc = setv;\n\t\t\tapplog(LOG_INFO, \"Setting GPU %d voltage to %.3f\", gpu, data->gpu_vddc);\n\t\t\tADL_Overdrive5_ODPerformanceLevels_Set(iAdapterIndex, lpOdPerformanceLevels);\n\t\t\tga->managed = true;\n\t\t}\n\n\t\tADL_Overdrive5_ODPerformanceLevels_Get(iAdapterIndex, 0, lpOdPerformanceLevels);\n\t\tga->iEngineClock = lpOdPerformanceLevels->aLevels[lev].iEngineClock;\n\t\tga->iMemoryClock = lpOdPerformanceLevels->aLevels[lev].iMemoryClock;\n\t\tga->iVddc = lpOdPerformanceLevels->aLevels[lev].iVddc;\n\t\tga->iBusNumber = lpInfo[i].iBusNumber;\n\n\t\tif (ADL_Overdrive5_FanSpeedInfo_Get(iAdapterIndex, 0, &ga->lpFanSpeedInfo) != ADL_OK)\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Overdrive5_FanSpeedInfo_Get\");\n\t\telse\n\t\t\tga->has_fanspeed = true;\n\n\t\t/* Save the fanspeed values as defaults in case we reset later */\n\t\tga->DefFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_RPM;\n\t\tADL_Overdrive5_FanSpeed_Get(ga->iAdapterIndex, 0, &ga->DefFanSpeedValue);\n\t\tif (data->gpu_fan)\n\t\t\tset_fanspeed(gpu, data->gpu_fan);\n\t\telse\n\t\t\tdata->gpu_fan = 85; /* Set a nominal upper limit of 85% */\n\n\t\t/* Not fatal if powercontrol get fails */\n\t\tif (ADL_Overdrive5_PowerControl_Get(ga->iAdapterIndex, &ga->iPercentage, &dummy) != ADL_OK)\n\t\t\tapplog(LOG_INFO, \"Failed to ADL_Overdrive5_PowerControl_get\");\n\n\t\tif (data->gpu_powertune) {\n\t\t\tADL_Overdrive5_PowerControl_Set(ga->iAdapterIndex, data->gpu_powertune);\n\t\t\tADL_Overdrive5_PowerControl_Get(ga->iAdapterIndex, &ga->iPercentage, &dummy);\n\t\t\tga->managed = true;\n\t\t}\n\n\t\t/* Set some default temperatures for autotune when enabled */\n\t\tif (!gpus[gpu].targettemp)\n\t\t\tgpus[gpu].targettemp = opt_targettemp;\n\t\tif (!ga->overtemp)\n\t\t\tga->overtemp = opt_overheattemp;\n\t\tif (!gpus[gpu].cutofftemp)\n\t\t\tgpus[gpu].cutofftemp = opt_cutofftemp;\n\t\tif (opt_autofan) {\n\t\t\t/* Set a safe starting default if we're automanaging fan speeds */\n\t\t\tint nominal = 50;\n\n\t\t\tga->autofan = true;\n\t\t\t/* Clamp fanspeed values to range provided */\n\t\t\tif (nominal > data->gpu_fan)\n\t\t\t\tnominal = data->gpu_fan;\n\t\t\tif (nominal < data->min_fan)\n\t\t\t\tnominal = data->min_fan;\n\t\t\tset_fanspeed(gpu, nominal);\n\t\t}\n\t\tif (opt_autoengine) {\n\t\t\tga->autoengine = true;\n\t\t\tga->managed = true;\n\t\t}\n\t\tgpus[gpu].temp =\n\t\tga->lasttemp = __gpu_temp(ga);\n\t}\n\n\tfor (gpu = 0; gpu < devices; gpu++) {\n\t\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\t\tstruct opencl_device_data * const data = cgpu->device_data;\n\t\tstruct gpu_adl *ga = &data->adl;\n\t\tint j;\n\n\t\tfor (j = 0; j < devices; j++) {\n\t\t\tstruct cgpu_info * const other_cgpu = &gpus[j];\n\t\t\tstruct opencl_device_data * const other_data = other_cgpu->device_data;\n\t\t\tstruct gpu_adl *other_ga;\n\n\t\t\tif (j == gpu)\n\t\t\t\tcontinue;\n\n\t\t\tother_ga = &other_data->adl;\n\n\t\t\t/* Search for twin GPUs on a single card. They will be\n\t\t\t * separated by one bus id and one will have fanspeed\n\t\t\t * while the other won't. */\n\t\t\tif (!ga->has_fanspeed) {\n\t\t\t\tif (fanspeed_twin(ga, other_ga)) {\n\t\t\t\t\tapplog(LOG_INFO, \"Dual GPUs detected: %d and %d\",\n\t\t\t\t\t\tga->gpu, other_ga->gpu);\n\t\t\t\t\tga->twin = other_ga;\n\t\t\t\t\tother_ga->twin = ga;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic float __gpu_temp(struct gpu_adl *ga)\n{\n\tif (ADL_Overdrive5_Temperature_Get(ga->iAdapterIndex, 0, &ga->lpTemperature) != ADL_OK)\n\t\treturn -1;\n\treturn (float)ga->lpTemperature.iTemperature / 1000;\n}\n\nfloat gpu_temp(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tfloat ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tret = __gpu_temp(ga);\n\tunlock_adl();\n\tgpus[gpu].temp = ret;\n\treturn ret;\n}\n\nstatic inline int __gpu_engineclock(struct gpu_adl *ga)\n{\n\treturn ga->lpActivity.iEngineClock / 100;\n}\n\nint gpu_engineclock(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tif (ADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity) != ADL_OK)\n\t\tgoto out;\n\tret = __gpu_engineclock(ga);\nout:\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic inline int __gpu_memclock(struct gpu_adl *ga)\n{\n\treturn ga->lpActivity.iMemoryClock / 100;\n}\n\nint gpu_memclock(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tif (ADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity) != ADL_OK)\n\t\tgoto out;\n\tret = __gpu_memclock(ga);\nout:\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic inline float __gpu_vddc(struct gpu_adl *ga)\n{\n\treturn (float)ga->lpActivity.iVddc / 1000;\n}\n\nfloat gpu_vddc(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tfloat ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tif (ADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity) != ADL_OK)\n\t\tgoto out;\n\tret = __gpu_vddc(ga);\nout:\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic inline int __gpu_activity(struct gpu_adl *ga)\n{\n\tif (!ga->lpOdParameters.iActivityReportingSupported)\n\t\treturn -1;\n\treturn ga->lpActivity.iActivityPercent;\n}\n\nint gpu_activity(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tret = ADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity);\n\tunlock_adl();\n\tif (ret != ADL_OK)\n\t\treturn ret;\n\tif (!ga->lpOdParameters.iActivityReportingSupported)\n\t\treturn ret;\n\treturn ga->lpActivity.iActivityPercent;\n}\n\nstatic inline int __gpu_fanspeed(struct gpu_adl *ga)\n{\n\tif (!ga->has_fanspeed && ga->twin)\n\t\treturn __gpu_fanspeed(ga->twin);\n\n\tif (!(ga->lpFanSpeedInfo.iFlags & ADL_DL_FANCTRL_SUPPORTS_RPM_READ))\n\t\treturn -1;\n\tga->lpFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_RPM;\n\tif (ADL_Overdrive5_FanSpeed_Get(ga->iAdapterIndex, 0, &ga->lpFanSpeedValue) != ADL_OK)\n\t\treturn -1;\n\treturn ga->lpFanSpeedValue.iFanSpeed;\n}\n\nint gpu_fanspeed(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tret = __gpu_fanspeed(ga);\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic int __gpu_fanpercent(struct gpu_adl *ga)\n{\n\tif (!ga->has_fanspeed && ga->twin)\n\t\treturn __gpu_fanpercent(ga->twin);\n\n\tif (!(ga->lpFanSpeedInfo.iFlags & ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ ))\n\t\treturn -1;\n\tga->lpFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_PERCENT;\n\tif (ADL_Overdrive5_FanSpeed_Get(ga->iAdapterIndex, 0, &ga->lpFanSpeedValue) != ADL_OK)\n\t\treturn -1;\n\treturn ga->lpFanSpeedValue.iFanSpeed;\n}\n\nint gpu_fanpercent(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tret = __gpu_fanpercent(ga);\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic inline int __gpu_powertune(struct gpu_adl *ga)\n{\n\tint dummy = 0;\n\n\tif (ADL_Overdrive5_PowerControl_Get(ga->iAdapterIndex, &ga->iPercentage, &dummy) != ADL_OK)\n\t\treturn -1;\n\treturn ga->iPercentage;\n}\n\nint gpu_powertune(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = -1;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn ret;\n\n\tga = &data->adl;\n\tlock_adl();\n\tret = __gpu_powertune(ga);\n\tunlock_adl();\n\treturn ret;\n}\n\nbool gpu_stats(int gpu, float *temp, int *engineclock, int *memclock, float *vddc,\n\t       int *activity, int *fanspeed, int *fanpercent, int *powertune)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active)\n\t\treturn false;\n\n\tga = &data->adl;\n\n\tlock_adl();\n\tgpus[gpu].temp =\n\t*temp = __gpu_temp(ga);\n\tif (ADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity) != ADL_OK) {\n\t\t*engineclock = 0;\n\t\t*memclock = 0;\n\t\t*vddc = 0;\n\t\t*activity = 0;\n\t} else {\n\t\t*engineclock = __gpu_engineclock(ga);\n\t\t*memclock = __gpu_memclock(ga);\n\t\t*vddc = __gpu_vddc(ga);\n\t\t*activity = __gpu_activity(ga);\n\t}\n\t*fanspeed = __gpu_fanspeed(ga);\n\t*fanpercent = __gpu_fanpercent(ga);\n\t*powertune = __gpu_powertune(ga);\n\tunlock_adl();\n\n\treturn true;\n}\n\n#ifdef HAVE_CURSES\nstatic void get_enginerange(int gpu, int *imin, int *imax)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Get enginerange not supported\\n\");\n\t\treturn;\n\t}\n\tga = &data->adl;\n\t*imin = ga->lpOdParameters.sEngineClock.iMin / 100;\n\t*imax = ga->lpOdParameters.sEngineClock.iMax / 100;\n}\n#endif\n\nint set_engineclock(int gpu, int iEngineClock)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tADLODPerformanceLevels *lpOdPerformanceLevels;\n\tint i, lev, ret = 1;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Set engineclock not supported\\n\");\n\t\treturn ret;\n\t}\n\n\tiEngineClock *= 100;\n\tga = &data->adl;\n\n\t/* Keep track of intended engine clock in case the device changes\n\t * profile and drops while idle, not taking the new engine clock */\n\tga->lastengine = iEngineClock;\n\n\tlev = ga->lpOdParameters.iNumberOfPerformanceLevels - 1;\n\tlpOdPerformanceLevels = alloca(sizeof(ADLODPerformanceLevels) + (lev * sizeof(ADLODPerformanceLevel)));\n\tlpOdPerformanceLevels->iSize = sizeof(ADLODPerformanceLevels) + sizeof(ADLODPerformanceLevel) * lev;\n\n\tlock_adl();\n\tif (ADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels) != ADL_OK)\n\t\tgoto out;\n\tfor (i = 0; i < lev; i++) {\n\t\tif (lpOdPerformanceLevels->aLevels[i].iEngineClock > iEngineClock)\n\t\t\tlpOdPerformanceLevels->aLevels[i].iEngineClock = iEngineClock;\n\t}\n\tlpOdPerformanceLevels->aLevels[lev].iEngineClock = iEngineClock;\n\tADL_Overdrive5_ODPerformanceLevels_Set(ga->iAdapterIndex, lpOdPerformanceLevels);\n\tADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels);\n\tif (lpOdPerformanceLevels->aLevels[lev].iEngineClock == iEngineClock)\n\t\tret = 0;\n\tga->iEngineClock = lpOdPerformanceLevels->aLevels[lev].iEngineClock;\n\tif (ga->iEngineClock > ga->maxspeed)\n\t\tga->maxspeed = ga->iEngineClock;\n\tif (ga->iEngineClock < ga->minspeed)\n\t\tga->minspeed = ga->iEngineClock;\n\tga->iMemoryClock = lpOdPerformanceLevels->aLevels[lev].iMemoryClock;\n\tga->iVddc = lpOdPerformanceLevels->aLevels[lev].iVddc;\n\tga->managed = true;\nout:\n\tunlock_adl();\n\n\tif (data->gpu_memdiff)\n\t\tset_memoryclock(gpu, iEngineClock / 100 + data->gpu_memdiff);\n\n\treturn ret;\n}\n\n#ifdef HAVE_CURSES\nstatic void get_memoryrange(int gpu, int *imin, int *imax)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Get memoryrange not supported\\n\");\n\t\treturn;\n\t}\n\tga = &data->adl;\n\t*imin = ga->lpOdParameters.sMemoryClock.iMin / 100;\n\t*imax = ga->lpOdParameters.sMemoryClock.iMax / 100;\n}\n#endif\n\nint set_memoryclock(int gpu, int iMemoryClock)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tADLODPerformanceLevels *lpOdPerformanceLevels;\n\tint i, lev, ret = 1;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Set memoryclock not supported\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->gpu_memclock = iMemoryClock;\n\n\tiMemoryClock *= 100;\n\tga = &data->adl;\n\n\tlev = ga->lpOdParameters.iNumberOfPerformanceLevels - 1;\n\tlpOdPerformanceLevels = alloca(sizeof(ADLODPerformanceLevels) + (lev * sizeof(ADLODPerformanceLevel)));\n\tlpOdPerformanceLevels->iSize = sizeof(ADLODPerformanceLevels) + sizeof(ADLODPerformanceLevel) * lev;\n\n\tlock_adl();\n\tif (ADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels) != ADL_OK)\n\t\tgoto out;\n\tlpOdPerformanceLevels->aLevels[lev].iMemoryClock = iMemoryClock;\n\tfor (i = 0; i < lev; i++) {\n\t\tif (lpOdPerformanceLevels->aLevels[i].iMemoryClock > iMemoryClock)\n\t\t\tlpOdPerformanceLevels->aLevels[i].iMemoryClock = iMemoryClock;\n\t}\n\tADL_Overdrive5_ODPerformanceLevels_Set(ga->iAdapterIndex, lpOdPerformanceLevels);\n\tADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels);\n\tif (lpOdPerformanceLevels->aLevels[lev].iMemoryClock == iMemoryClock)\n\t\tret = 0;\n\tga->iEngineClock = lpOdPerformanceLevels->aLevels[lev].iEngineClock;\n\tga->iMemoryClock = lpOdPerformanceLevels->aLevels[lev].iMemoryClock;\n\tga->iVddc = lpOdPerformanceLevels->aLevels[lev].iVddc;\n\tga->managed = true;\nout:\n\tunlock_adl();\n\treturn ret;\n}\n\n#ifdef HAVE_CURSES\nstatic void get_vddcrange(int gpu, float *imin, float *imax)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Get vddcrange not supported\\n\");\n\t\treturn;\n\t}\n\tga = &data->adl;\n\t*imin = (float)ga->lpOdParameters.sVddc.iMin / 1000;\n\t*imax = (float)ga->lpOdParameters.sVddc.iMax / 1000;\n}\n\nstatic float curses_float(const char *query)\n{\n\tfloat ret;\n\tchar *cvar;\n\n\tcvar = curses_input(query);\n\tif (unlikely(!cvar))\n\t\treturn -1;\n\tret = atof(cvar);\n\tfree(cvar);\n\treturn ret;\n}\n#endif\n\nint set_vddc(int gpu, float fVddc)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tADLODPerformanceLevels *lpOdPerformanceLevels;\n\tint i, iVddc, lev, ret = 1;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Set vddc not supported\\n\");\n\t\treturn ret;\n\t}\n\n\tiVddc = 1000 * fVddc;\n\tga = &data->adl;\n\n\tlev = ga->lpOdParameters.iNumberOfPerformanceLevels - 1;\n\tlpOdPerformanceLevels = alloca(sizeof(ADLODPerformanceLevels) + (lev * sizeof(ADLODPerformanceLevel)));\n\tlpOdPerformanceLevels->iSize = sizeof(ADLODPerformanceLevels) + sizeof(ADLODPerformanceLevel) * lev;\n\n\tlock_adl();\n\tif (ADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels) != ADL_OK)\n\t\tgoto out;\n\tfor (i = 0; i < lev; i++) {\n\t\tif (lpOdPerformanceLevels->aLevels[i].iVddc > iVddc)\n\t\t\tlpOdPerformanceLevels->aLevels[i].iVddc = iVddc;\n\t}\n\tlpOdPerformanceLevels->aLevels[lev].iVddc = iVddc;\n\tADL_Overdrive5_ODPerformanceLevels_Set(ga->iAdapterIndex, lpOdPerformanceLevels);\n\tADL_Overdrive5_ODPerformanceLevels_Get(ga->iAdapterIndex, 0, lpOdPerformanceLevels);\n\tif (lpOdPerformanceLevels->aLevels[lev].iVddc == iVddc)\n\t\tret = 0;\n\tga->iEngineClock = lpOdPerformanceLevels->aLevels[lev].iEngineClock;\n\tga->iMemoryClock = lpOdPerformanceLevels->aLevels[lev].iMemoryClock;\n\tga->iVddc = lpOdPerformanceLevels->aLevels[lev].iVddc;\n\tga->managed = true;\nout:\n\tunlock_adl();\n\treturn ret;\n}\n\nstatic void get_fanrange(int gpu, int *imin, int *imax)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Get fanrange not supported\\n\");\n\t\treturn;\n\t}\n\tga = &data->adl;\n\t*imin = ga->lpFanSpeedInfo.iMinPercent;\n\t*imax = ga->lpFanSpeedInfo.iMaxPercent;\n}\n\nint set_fanspeed(int gpu, int iFanSpeed)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint ret = 1;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Set fanspeed not supported\\n\");\n\t\treturn ret;\n\t}\n\n\tga = &data->adl;\n\tif (!(ga->lpFanSpeedInfo.iFlags & (ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE | ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE ))) {\n\t\tapplog(LOG_DEBUG, \"GPU %d doesn't support rpm or percent write\", gpu);\n\t\treturn ret;\n\t}\n\n\t/* Store what fanspeed we're actually aiming for for re-entrant changes\n\t * in case this device does not support fine setting changes */\n\tga->targetfan = iFanSpeed;\n\n\tlock_adl();\n\tga->lpFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_RPM;\n\tif (ADL_Overdrive5_FanSpeed_Get(ga->iAdapterIndex, 0, &ga->lpFanSpeedValue) != ADL_OK) {\n\t\tapplog(LOG_DEBUG, \"GPU %d call to fanspeed get failed\", gpu);\n\t}\n\tif (!(ga->lpFanSpeedValue.iFlags & ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED)) {\n\t\t/* If user defined is not already specified, set it first */\n\t\tga->lpFanSpeedValue.iFlags |= ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED;\n\t\tADL_Overdrive5_FanSpeed_Set(ga->iAdapterIndex, 0, &ga->lpFanSpeedValue);\n\t}\n\tif (!(ga->lpFanSpeedInfo.iFlags & ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE)) {\n\t\t/* Must convert speed to an RPM */\n\t\tiFanSpeed = ga->lpFanSpeedInfo.iMaxRPM * iFanSpeed / 100;\n\t\tga->lpFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_RPM;\n\t} else\n\t\tga->lpFanSpeedValue.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_PERCENT;\n\tga->lpFanSpeedValue.iFanSpeed = iFanSpeed;\n\tret = ADL_Overdrive5_FanSpeed_Set(ga->iAdapterIndex, 0, &ga->lpFanSpeedValue);\n\tga->managed = true;\n\tunlock_adl();\n\n\treturn ret;\n}\n\n#ifdef HAVE_CURSES\nstatic int set_powertune(int gpu, int iPercentage)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tint dummy, ret = 1;\n\n\tif (!data->has_adl || !adl_active) {\n\t\twlogprint(\"Set powertune not supported\\n\");\n\t\treturn ret;\n\t}\n\n\tga = &data->adl;\n\n\tlock_adl();\n\tADL_Overdrive5_PowerControl_Set(ga->iAdapterIndex, iPercentage);\n\tADL_Overdrive5_PowerControl_Get(ga->iAdapterIndex, &ga->iPercentage, &dummy);\n\tif (ga->iPercentage == iPercentage)\n\t\tret = 0;\n\tga->managed = true;\n\tunlock_adl();\n\treturn ret;\n}\n#endif\n\n/* Returns whether the fanspeed is optimal already or not. The fan_window bool\n * tells us whether the current fanspeed is in the target range for fanspeeds.\n */\nstatic bool fan_autotune(int gpu, int temp, int fanpercent, int lasttemp, bool *fan_window)\n{\n\tstruct cgpu_info *cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tint tdiff = round(temp - lasttemp);\n\tstruct gpu_adl *ga = &data->adl;\n\tconst int top = data->gpu_fan;\n\tconst int bot = data->min_fan;\n\tint newpercent = fanpercent;\n\tint iMin = 0, iMax = 100;\n\n\tget_fanrange(gpu, &iMin, &iMax);\n\tif (temp > ga->overtemp && fanpercent < iMax) {\n\t\tapplog(LOG_WARNING, \"Overheat detected on GPU %d, increasing fan to 100%%\", gpu);\n\t\tnewpercent = iMax;\n\n\t\tdev_error(cgpu, REASON_DEV_OVER_HEAT);\n\t} else if (temp > gpus[gpu].targettemp && fanpercent < top && tdiff >= 0) {\n\t\tapplog(LOG_DEBUG, \"Temperature over target, increasing fanspeed\");\n\t\tif (temp > gpus[gpu].targettemp + opt_hysteresis)\n\t\t\tnewpercent = ga->targetfan + 10;\n\t\telse\n\t\t\tnewpercent = ga->targetfan + 5;\n\t\tif (newpercent > top)\n\t\t\tnewpercent = top;\n\t} else if (fanpercent > bot && temp < gpus[gpu].targettemp - opt_hysteresis) {\n\t\t/* Detect large swings of 5 degrees or more and change fan by\n\t\t * a proportion more */\n\t\tif (tdiff <= 0) {\n\t\t\tapplog(LOG_DEBUG, \"Temperature %d degrees below target, decreasing fanspeed\", opt_hysteresis);\n\t\t\tnewpercent = ga->targetfan - 1 + tdiff / 5;\n\t\t} else if (tdiff >= 5) {\n\t\t\tapplog(LOG_DEBUG, \"Temperature climbed %d while below target, increasing fanspeed\", tdiff);\n\t\t\tnewpercent = ga->targetfan + tdiff / 5;\n\t\t}\n\t} else {\n\n\t\t/* We're in the optimal range, make minor adjustments if the\n\t\t * temp is still drifting */\n\t\tif (fanpercent > bot && tdiff < 0 && lasttemp < gpus[gpu].targettemp) {\n\t\t\tapplog(LOG_DEBUG, \"Temperature dropping while in target range, decreasing fanspeed\");\n\t\t\tnewpercent = ga->targetfan + tdiff;\n\t\t} else if (fanpercent < top && tdiff > 0 && temp > gpus[gpu].targettemp - opt_hysteresis) {\n\t\t\tapplog(LOG_DEBUG, \"Temperature rising while in target range, increasing fanspeed\");\n\t\t\tnewpercent = ga->targetfan + tdiff;\n\t\t}\n\t}\n\n\tif (newpercent > iMax)\n\t\tnewpercent = iMax;\n\telse if (newpercent < iMin)\n\t\tnewpercent = iMin;\n\n\tif (newpercent <= top)\n\t\t*fan_window = true;\n\telse\n\t\t*fan_window = false;\n\n\tif (newpercent != fanpercent) {\n\t\tapplog(LOG_INFO, \"Setting GPU %d fan percentage to %d\", gpu, newpercent);\n\t\tset_fanspeed(gpu, newpercent);\n\t\t/* If the fanspeed is going down and we're below the top speed,\n\t\t * consider the fan optimal to prevent minute changes in\n\t\t * fanspeed delaying GPU engine speed changes */\n\t\tif (newpercent < fanpercent && *fan_window)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid gpu_autotune(int gpu, enum dev_enable *denable)\n{\n\tint temp, fanpercent, engine, newengine, twintemp = 0;\n\tbool fan_optimal = true, fan_window = true;\n\tstruct cgpu_info *cgpu;\n\tstruct gpu_adl *ga;\n\n\tcgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tga = &data->adl;\n\n\tlock_adl();\n\tADL_Overdrive5_CurrentActivity_Get(ga->iAdapterIndex, &ga->lpActivity);\n\tgpus[gpu].temp =\n\ttemp = __gpu_temp(ga);\n\tif (ga->twin)\n\t\ttwintemp = __gpu_temp(ga->twin);\n\tfanpercent = __gpu_fanpercent(ga);\n\tunlock_adl();\n\n\tnewengine = engine = gpu_engineclock(gpu) * 100;\n\n\tif (temp && fanpercent >= 0 && ga->autofan) {\n\t\tif (!ga->twin)\n\t\t\tfan_optimal = fan_autotune(gpu, temp, fanpercent, ga->lasttemp, &fan_window);\n\t\telse if (ga->autofan && (ga->has_fanspeed || !ga->twin->autofan)) {\n\t\t\t/* On linked GPUs, we autotune the fan only once, based\n\t\t\t * on the highest temperature from either GPUs */\n\t\t\tint hightemp, fan_gpu;\n\t\t\tint lasttemp;\n\n\t\t\tif (twintemp > temp) {\n\t\t\t\tlasttemp = ga->twin->lasttemp;\n\t\t\t\thightemp = twintemp;\n\t\t\t} else {\n\t\t\t\tlasttemp = ga->lasttemp;\n\t\t\t\thightemp = temp;\n\t\t\t}\n\t\t\tif (ga->has_fanspeed)\n\t\t\t\tfan_gpu = gpu;\n\t\t\telse\n\t\t\t\tfan_gpu = ga->twin->gpu;\n\t\t\tfan_optimal = fan_autotune(fan_gpu, hightemp, fanpercent, lasttemp, &fan_window);\n\t\t}\n\t}\n\n\tif (engine && ga->autoengine) {\n\t\tif (temp > cgpu->cutofftemp) {\n\t\t\t// Shutoff and recovery happens back in watchdog_thread\n\t\t\tnewengine = ga->minspeed;\n\t\t} else if (temp > ga->overtemp && engine > ga->minspeed) {\n\t\t\tapplog(LOG_WARNING, \"Overheat detected, decreasing GPU %d clock speed\", gpu);\n\t\t\tnewengine = ga->minspeed;\n\n\t\t\tdev_error(cgpu, REASON_DEV_OVER_HEAT);\n\t\t} else if (temp > gpus[gpu].targettemp + opt_hysteresis && engine > ga->minspeed && fan_optimal) {\n\t\t\tapplog(LOG_DEBUG, \"Temperature %d degrees over target, decreasing clock speed\", opt_hysteresis);\n\t\t\tnewengine = engine - ga->lpOdParameters.sEngineClock.iStep;\n\t\t\t/* Only try to tune engine speed up if this GPU is not disabled */\n\t\t} else if (temp < gpus[gpu].targettemp && engine < ga->maxspeed && fan_window && *denable == DEV_ENABLED) {\n\t\t\tint iStep = ga->lpOdParameters.sEngineClock.iStep;\n\n\t\t\tapplog(LOG_DEBUG, \"Temperature below target, increasing clock speed\");\n\t\t\tif (temp < gpus[gpu].targettemp - opt_hysteresis)\n\t\t\t\tiStep *= 2;\n\t\t\tnewengine = engine + iStep;\n\t\t}\n\n\t\tif (newengine > ga->maxspeed)\n\t\t\tnewengine = ga->maxspeed;\n\t\telse if (newengine < ga->minspeed)\n\t\t\tnewengine = ga->minspeed;\n\n\t\t/* Adjust engine clock speed if it's lower, or if it's higher\n\t\t * but higher than the last intended value as well as the\n\t\t * current speed, to avoid setting the engine clock speed to\n\t\t * a speed relateive to a lower profile during idle periods. */\n\t\tif (newengine < engine || (newengine > engine && newengine > ga->lastengine)) {\n\t\t\tnewengine /= 100;\n\t\t\tapplog(LOG_INFO, \"Setting GPU %d engine clock to %d\", gpu, newengine);\n\t\t\tset_engineclock(gpu, newengine);\n\t\t}\n\t}\n\tga->lasttemp = temp;\n}\n\nvoid set_defaultfan(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tif (!data->has_adl || !adl_active)\n\t\treturn;\n\n\tga = &data->adl;\n\tlock_adl();\n\tADL_Overdrive5_FanSpeed_Set(ga->iAdapterIndex, 0, &ga->DefFanSpeedValue);\n\tunlock_adl();\n}\n\nvoid set_defaultengine(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga;\n\tif (!data->has_adl || !adl_active)\n\t\treturn;\n\n\tga = &data->adl;\n\tlock_adl();\n\tADL_Overdrive5_ODPerformanceLevels_Set(ga->iAdapterIndex, ga->DefPerfLev);\n\tunlock_adl();\n}\n\n#ifdef HAVE_CURSES\nvoid change_autosettings(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga = &data->adl;\n\tchar input;\n\tint val;\n\n\twlogprint(\"Target temperature: %d\\n\", gpus[gpu].targettemp);\n\twlogprint(\"Overheat temperature: %d\\n\", ga->overtemp);\n\twlogprint(\"Cutoff temperature: %d\\n\", gpus[gpu].cutofftemp);\n\twlogprint(\"Toggle [F]an auto [G]PU auto\\nChange [T]arget [O]verheat [C]utoff\\n\");\n\twlogprint(\"Or press any other key to continue\\n\");\n\tinput = getch();\n\tif (!strncasecmp(&input, \"f\", 1)) {\n\t\tga->autofan ^= true;\n\t\twlogprint(\"Fan autotune is now %s\\n\", ga->autofan ? \"enabled\" : \"disabled\");\n\t\tif (!ga->autofan) {\n\t\t\twlogprint(\"Resetting fan to startup settings\\n\");\n\t\t\tset_defaultfan(gpu);\n\t\t}\n\t} else if (!strncasecmp(&input, \"g\", 1)) {\n\t\tga->autoengine ^= true;\n\t\twlogprint(\"GPU engine clock autotune is now %s\\n\", ga->autoengine ? \"enabled\" : \"disabled\");\n\t\tif (!ga->autoengine) {\n\t\t\twlogprint(\"Resetting GPU engine clock to startup settings\\n\");\n\t\t\tset_defaultengine(gpu);\n\t\t}\n\t} else if (!strncasecmp(&input, \"t\", 1)) {\n\t\tval = curses_int(\"Enter target temperature for this GPU in C (0-200)\");\n\t\tif (val < 0 || val > 200)\n\t\t\twlogprint(\"Invalid temperature\");\n\t\telse\n\t\t\tgpus[gpu].targettemp = val;\n\t} else if (!strncasecmp(&input, \"o\", 1)) {\n\t\twlogprint(\"Enter overheat temperature for this GPU in C (%d+)\", gpus[gpu].targettemp);\n\t\tval = curses_int(\"\");\n\t\tif (val <= gpus[gpu].targettemp || val > 200)\n\t\t\twlogprint(\"Invalid temperature\");\n\t\telse\n\t\t\tga->overtemp = val;\n\t} else if (!strncasecmp(&input, \"c\", 1)) {\n\t\twlogprint(\"Enter cutoff temperature for this GPU in C (%d+)\", ga->overtemp);\n\t\tval = curses_int(\"\");\n\t\tif (val <= ga->overtemp || val > 200)\n\t\t\twlogprint(\"Invalid temperature\");\n\t\telse\n\t\t\tgpus[gpu].cutofftemp = val;\n\t}\n}\n\nvoid change_gpusettings(int gpu)\n{\n\tstruct cgpu_info * const cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl *ga = &data->adl;\n\tfloat fval, fmin = 0, fmax = 0;\n\tint val, imin = 0, imax = 0;\n\tchar input;\n\tint engineclock = 0, memclock = 0, activity = 0, fanspeed = 0, fanpercent = 0, powertune = 0;\n\tfloat temp = 0, vddc = 0;\n\nupdated:\n\tif (gpu_stats(gpu, &temp, &engineclock, &memclock, &vddc, &activity, &fanspeed, &fanpercent, &powertune))\n\twlogprint(\"Temp: %.1f C\\n\", temp);\n\tif (fanpercent >= 0 || fanspeed >= 0) {\n\t\twlogprint(\"Fan Speed: \");\n\t\tif (fanpercent >= 0)\n\t\t\twlogprint(\"%d%% \", fanpercent);\n\t\tif (fanspeed >= 0)\n\t\t\twlogprint(\"(%d RPM)\", fanspeed);\n\t\twlogprint(\"\\n\");\n\t}\n\twlogprint(\"Engine Clock: %d MHz\\nMemory Clock: %d MHz\\nVddc: %.3f V\\nActivity: %d%%\\nPowertune: %d%%\\n\",\n\t\tengineclock, memclock, vddc, activity, powertune);\n\twlogprint(\"Fan autotune is %s (%d-%d)\\n\", ga->autofan ? \"enabled\" : \"disabled\",\n\t\t  data->min_fan, data->gpu_fan);\n\twlogprint(\"GPU engine clock autotune is %s (%d-%d)\\n\", ga->autoengine ? \"enabled\" : \"disabled\",\n\t\tga->minspeed / 100, ga->maxspeed / 100);\n\twlogprint(\"Change [A]utomatic [E]ngine [F]an [M]emory [V]oltage [P]owertune\\n\");\n\twlogprint(\"Or press any other key to continue\\n\");\n\tinput = getch();\n\n\tif (!strncasecmp(&input, \"a\", 1)) {\n\t\tchange_autosettings(gpu);\n\t} else if (!strncasecmp(&input, \"e\", 1)) {\n\t\tget_enginerange(gpu, &imin, &imax);\n\t\twlogprint(\"Enter GPU engine clock speed (%d - %d MHz)\", imin, imax);\n\t\tval = curses_int(\"\");\n\t\tif (val < imin || val > imax) {\n\t\t\twlogprint(\"Value is outside safe range, are you sure?\\n\");\n\t\t\tinput = getch();\n\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\treturn;\n\t\t}\n\t\tif (!set_engineclock(gpu, val))\n\t\t\twlogprint(\"Driver reports success but check values below\\n\");\n\t\telse\n\t\t\twlogprint(\"Failed to modify engine clock speed\\n\");\n\t} else if (!strncasecmp(&input, \"f\", 1)) {\n\t\tget_fanrange(gpu, &imin, &imax);\n\t\twlogprint(\"Enter fan percentage (%d - %d %%)\", imin, imax);\n\t\tval = curses_int(\"\");\n\t\tif (val < imin || val > imax) {\n\t\t\twlogprint(\"Value is outside safe range, are you sure?\\n\");\n\t\t\tinput = getch();\n\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\treturn;\n\t\t}\n\t\tif (!set_fanspeed(gpu, val))\n\t\t\twlogprint(\"Driver reports success but check values below\\n\");\n\t\telse\n\t\t\twlogprint(\"Failed to modify fan speed\\n\");\n\t} else if (!strncasecmp(&input, \"m\", 1)) {\n\t\tget_memoryrange(gpu, &imin, &imax);\n\t\twlogprint(\"Enter GPU memory clock speed (%d - %d MHz)\", imin, imax);\n\t\tval = curses_int(\"\");\n\t\tif (val < imin || val > imax) {\n\t\t\twlogprint(\"Value is outside safe range, are you sure?\\n\");\n\t\t\tinput = getch();\n\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\treturn;\n\t\t}\n\t\tif (!set_memoryclock(gpu, val))\n\t\t\twlogprint(\"Driver reports success but check values below\\n\");\n\t\telse\n\t\t\twlogprint(\"Failed to modify memory clock speed\\n\");\n\t} else if (!strncasecmp(&input, \"v\", 1)) {\n\t\tget_vddcrange(gpu, &fmin, &fmax);\n\t\twlogprint(\"Enter GPU voltage (%.3f - %.3f V)\", fmin, fmax);\n\t\tfval = curses_float(\"\");\n\t\tif (fval < fmin || fval > fmax) {\n\t\t\twlogprint(\"Value is outside safe range, are you sure?\\n\");\n\t\t\tinput = getch();\n\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\treturn;\n\t\t}\n\t\tif (!set_vddc(gpu, fval))\n\t\t\twlogprint(\"Driver reports success but check values below\\n\");\n\t\telse\n\t\t\twlogprint(\"Failed to modify voltage\\n\");\n\t} else if (!strncasecmp(&input, \"p\", 1)) {\n\t\tval = curses_int(\"Enter powertune value (-20 - 20)\");\n\t\tif (val < -20 || val > 20) {\n\t\t\twlogprint(\"Value is outside safe range, are you sure?\\n\");\n\t\t\tinput = getch();\n\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\treturn;\n\t\t}\n\t\tif (!set_powertune(gpu, val))\n\t\t\twlogprint(\"Driver reports success but check values below\\n\");\n\t\telse\n\t\t\twlogprint(\"Failed to modify powertune value\\n\");\n\t} else {\n\t\tclear_logwin();\n\t\treturn;\n\t}\n\tcgsleep_ms(1000);\n\tgoto updated;\n}\n#endif\n\nstatic void free_adl(void)\n{\n\tADL_Main_Memory_Free ((void **)&lpInfo);\n\tADL_Main_Control_Destroy ();\n#ifndef WIN32\n\tdlclose(hDLL);\n#else\n\tFreeLibrary(hDLL);\n#endif\n}\n\nvoid clear_adl(int nDevs)\n{\n\tstruct gpu_adl *ga;\n\tint i;\n\n\tif (!adl_active)\n\t\treturn;\n\n\tlock_adl();\n\t/* Try to reset values to their defaults */\n\tfor (i = 0; i < nDevs; i++) {\n\t\tstruct cgpu_info * const cgpu = &gpus[i];\n\t\tstruct opencl_device_data * const data = cgpu->device_data;\n\t\tga = &data->adl;\n\t\t/*  Only reset the values if we've changed them at any time */\n\t\tif (!data->has_adl || !ga->managed)\n\t\t\tcontinue;\n\t\tADL_Overdrive5_ODPerformanceLevels_Set(ga->iAdapterIndex, ga->DefPerfLev);\n\t\tfree(ga->DefPerfLev);\n\t\tADL_Overdrive5_FanSpeed_Set(ga->iAdapterIndex, 0, &ga->DefFanSpeedValue);\n\t\tADL_Overdrive5_FanSpeedToDefault_Set(ga->iAdapterIndex, 0);\n\t}\n\tadl_active = false;\n\tunlock_adl();\n\tfree_adl();\n}\n#endif /* HAVE_ADL */\n"
        },
        {
          "name": "adl.h",
          "type": "blob",
          "size": 0.8955078125,
          "content": "#ifndef BFG_ADL_H\n#define BFG_ADL_H\n#ifdef HAVE_ADL\n\n#include <stdbool.h>\n\nextern bool adl_active;\nextern bool opt_reorder;\nextern const int opt_targettemp;\nextern const int opt_overheattemp;\nvoid init_adl(int nDevs);\nfloat gpu_temp(int gpu);\nint gpu_engineclock(int gpu);\nint gpu_memclock(int gpu);\nfloat gpu_vddc(int gpu);\nint gpu_activity(int gpu);\nint gpu_fanspeed(int gpu);\nint gpu_fanpercent(int gpu);\nbool gpu_stats(int gpu, float *temp, int *engineclock, int *memclock, float *vddc,\n\t       int *activity, int *fanspeed, int *fanpercent, int *powertune);\nvoid change_gpusettings(int gpu);\nvoid gpu_autotune(int gpu, enum dev_enable *denable);\nvoid clear_adl(int nDevs);\n#else /* HAVE_ADL */\n#define adl_active (0)\nstatic inline void init_adl(__maybe_unused int nDevs) {}\nstatic inline void change_gpusettings(__maybe_unused int gpu) { }\nstatic inline void clear_adl(__maybe_unused int nDevs) {}\n#endif\n#endif\n"
        },
        {
          "name": "adl_functions.h",
          "type": "blob",
          "size": 24.37890625,
          "content": "/*******************************************************************************\r\n\r\n * This program reads HW information from your ATI Radeon card and displays them\r\n * You can also change frequencies and voltages.\r\n\r\n * THIS PROGRAM MAY DAMAGE YOUR VIDEO CARD, IF YOU APPLY NONSENSIAL VALUES.\r\n * e.g. INCREASING THE VOLTAGES AND FREQUENCIES IN CONJUNCTION WITH LOWERING THE\r\n *      FAN SPEED IS NOT ADVISABLE!\r\n\r\n * Copyright 2010-2011 Thorsten Gilling\r\n\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\r\n\r\n*******************************************************************************/\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n// AMD ADL function types from Version 3.0\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n#ifndef WIN32\r\n #include <dlfcn.h>\t//dyopen, dlsym, dlclose\r\n #include <stdlib.h>\r\n #include <string.h>\t//memeset\r\n#else\r\n #include <windows.h>\r\n #include <tchar.h>\r\n#endif\r\n\r\n#include \"ADL/adl_sdk.h\"\r\n\r\n// Definitions of the used function pointers. Add more if you use other ADL APIs\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL Main\r\ntypedef int ( *ADL_MAIN_CONTROL_CREATE ) (ADL_MAIN_MALLOC_CALLBACK callback, int iEnumConnectedAdapters);\r\ntypedef int ( *ADL_MAIN_CONTROL_REFRESH ) ();\r\ntypedef int ( *ADL_MAIN_CONTROL_DESTROY ) ();\r\ntypedef int ( *ADL_GRAPHICS_PLATFORM_GET ) (int *lpPlatForm);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL Adapter/General\r\ntypedef int ( *ADL_ADAPTER_ACTIVE_GET ) (int iAdapterIndex, int *lpStatus);\r\ntypedef int ( *ADL_ADAPTER_NUMBEROFADAPTERS_GET ) (int *lpNumAdapters);\r\ntypedef int ( *ADL_ADAPTER_ADAPTERINFO_GET ) (LPAdapterInfo lpInfo, int iInputSize);\r\ntypedef int ( *ADL_ADAPTER_ASICFAMILYTYPE_GET ) (int iAdapterIndex, int *lpAsicTypes, int *lpValids);\r\ntypedef int ( *ADL_ADAPTER_SPEED_CAPS )\t(int iAdapterIndex, int *lpCaps, int *lpValid);\r\ntypedef int ( *ADL_ADAPTER_SPEED_GET ) (int iAdapterIndex, int *lpCurrent, int *lpDefault);\r\ntypedef int ( *ADL_ADAPTER_SPEED_SET ) (int iAdapterIndex, int iSpeed);\r\ntypedef int ( *ADL_ADAPTER_ACCESSIBILITY_GET ) (int iAdapterIndex, int *lpAccessibility);\r\ntypedef int ( *ADL_ADAPTER_VIDEOBIOSINFO_GET ) (int iAdapterIndex, ADLBiosInfo *lpBiosInfo);\r\ntypedef int ( *ADL_ADAPTER_ID_GET ) (int iAdapterIndex, int *lpAdapterID);\r\n\r\n// ADL Adapter/CrossDisplay\r\ntypedef int ( *ADL_ADAPTER_CROSSDISPLAYADAPTERROLE_CAPS ) (int iAdapterIndex, int *lpCrossDisplaySupport, int *lpAdapterRole, int *lpNumPossDisplayAdapters, int **lppPossDisplayAdapters, int *lpNnumPosRenderingAdapters, int **lppPosRenderingAdapters, int *lpErrorStatus);\r\ntypedef int ( *ADL_ADAPTER_CROSSDISPLAYINFO_GET ) (int iAdapterIndex, int *lpAdapterRole, int *lpCrossdisplayMode, int *lpNumDisplayAdapters, int **lppDisplayAdapters, int *lpNumRenderingAdapters, int **lppRenderingAdapters, int *lpErrorCodeStatus);\r\ntypedef int ( *ADL_ADAPTER_CROSSDISPLAYINFO_SET ) (int iAdapterIndex, int iDisplayAdapterIndex, int iRenderingAdapterIndex, int crossdisplayMode, int *lpErrorCode);\r\n\r\n// ADL Adapter/CrossFire\r\ntypedef int ( *ADL_ADAPTER_CROSSFIRE_CAPS ) (int iAdapterIndex, int *lpPreferred, int *lpNumComb, ADLCrossfireComb **ppCrossfireComb);\r\ntypedef int ( *ADL_ADAPTER_CROSSFIRE_GET ) (int iAdapterIndex, ADLCrossfireComb *lpCrossfireComb, ADLCrossfireInfo *lpCrossfireInfo);\r\ntypedef int ( *ADL_ADAPTER_CROSSFIRE_SET ) (int iAdapterIndex, ADLCrossfireComb *lpCrossfireComb);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL Display/Misc\r\n\r\ntypedef int ( *ADL_DISPLAY_DISPLAYINFO_GET ) (int iAdapterIndex, int *lpNumDisplays, ADLDisplayInfo **lppInfo, int iForceDetect);\r\ntypedef int ( *ADL_DISPLAY_NUMBEROFDISPLAYS_GET ) (int iAdapterIndex, int *lpNumDisplays);\r\ntypedef int ( *ADL_DISPLAY_PRESERVEDASPECTRATIO_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport, int *lpCurrent, int *lpDefault);\r\ntypedef int ( *ADL_DISPLAY_PRESERVEDASPECTRATIO_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_DISPLAY_IMAGEEXPANSION_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport, int *lpCurrent, int *lpDefault);\r\ntypedef int ( *ADL_DISPLAY_IMAGEEXPANSION_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_DISPLAY_POSITION_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpX, int *lpY, int *lpXDefault, int *lpYDefault, int *lpMinX, int *lpMinY, int *lpMaxX, int *lpMaxY, int *lpStepX, int *lpStepY);\r\ntypedef int ( *ADL_DISPLAY_POSITION_SET ) (int iAdapterIndex, int iDisplayIndex, int iX, int iY);\r\ntypedef int ( *ADL_DISPLAY_SIZE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpWidth, int *lpHeight, int *lpDefaultWidth, int *lpDefaultHeight, int *lpMinWidth, int *lpMinHeight, int *lpMaxWidth, int *lpMaxHeight, int *lpStepWidth, int *lpStepHeight);\r\ntypedef int ( *ADL_DISPLAY_SIZE_SET ) (int iAdapterIndex, int iDisplayIndex, int iWidth, int iHeight);\r\ntypedef int ( *ADL_DISPLAY_ADJUSTCAPS_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpInfo);\r\ntypedef int ( *ADL_DISPLAY_CAPABILITIES_GET ) (int iAdapterIndex, int *lpNumberOfControlers, int *lpNumberOfDisplays);\r\ntypedef int ( *ADL_DISPLAY_CONNECTEDDISPLAYS_GET ) (int iAdapterIndex, int *lpConnections);\r\ntypedef int ( *ADL_DISPLAY_DEVICECONFIG_GET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayConfig *lpDisplayConfig);\r\ntypedef int ( *ADL_DISPLAY_PROPERTY_GET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayProperty *lpDisplayProperty);\r\ntypedef int ( *ADL_DISPLAY_PROPERTY_SET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayProperty *lpDisplayProperty);\r\ntypedef int ( *ADL_DISPLAY_SWITCHINGCAPABILITY_GET ) (int iAdapterIndex, int *lpResult);\r\ntypedef int ( *ADL_DISPLAY_DITHERSTATE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpDitherState);\r\ntypedef int ( *ADL_DISPLAY_DITHERSTATE_SET ) (int iAdapterIndex, int iDisplayIndex, int iDitherState);\r\ntypedef int ( *ADL_DISPLAY_SUPPORTEDPIXELFORMAT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpPixelFormat);\r\ntypedef int ( *ADL_DISPLAY_PIXELFORMAT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpPixelFormat);\r\ntypedef int ( *ADL_DISPLAY_PIXELFORMAT_SET ) (int iAdapterIndex, int iDisplayIndex, int iPixelFormat);\r\ntypedef int ( *ADL_DISPLAY_ODCLOCKINFO_GET ) (int iAdapterIndex, ADLAdapterODClockInfo *lpOdClockInfo);\r\ntypedef int ( *ADL_DISPLAY_ODCLOCKCONFIG_SET ) (int iAdapterIndex, ADLAdapterODClockConfig *lpOdClockConfig);\r\ntypedef int ( *ADL_DISPLAY_ADJUSTMENTCOHERENT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpAdjustmentCoherentCurrent, int *lpAdjustmentCoherentDefault);\r\ntypedef int ( *ADL_DISPLAY_ADJUSTMENTCOHERENT_SET ) (int iAdapterIndex, int iDisplayIndex, int iAdjustmentCoherent);\r\ntypedef int ( *ADL_DISPLAY_REDUCEDBLANKING_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpReducedBlankingCurrent, int *lpReducedBlankingDefault);\r\ntypedef int ( *ADL_DISPLAY_REDUCEDBLANKING_SET ) (int iAdapterIndex, int iDisplayIndex, int iReducedBlanking);\r\ntypedef int ( *ADL_DISPLAY_FORMATSOVERRIDE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSettingsSupported, int *lpSettingsSupportedEx, int *lpCurSettings);\r\ntypedef int ( *ADL_DISPLAY_FORMATSOVERRIDE_SET ) (int iAdapterIndex, int iDisplayIndex, int iOverrideSettings);\r\ntypedef int ( *ADL_DISPLAY_MVPUCAPS_GET ) (int iAdapterIndex, ADLMVPUCaps *lpMvpuCaps);\r\ntypedef int ( *ADL_DISPLAY_MVPUSTATUS_GET ) (int iAdapterIndex, ADLMVPUStatus *lpMvpuStatus);\r\n\r\n// ADL Display/Eyefinity\r\ntypedef int ( *ADL_ADAPTER_ACTIVE_SET ) (int iAdapterIndex, int iStatus, int *lpNewlyActivate);\r\ntypedef int ( *ADL_ADAPTER_ACTIVE_SETPREFER ) (int iAdapterIndex, int iStatus, int iNumPreferTarget, ADLDisplayTarget *lpPreferTarget, int *lpNewlyActivate);\r\ntypedef int ( *ADL_ADAPTER_PRIMARY_GET ) (int *lpPrimaryAdapterIndex);\r\ntypedef int ( *ADL_ADAPTER_PRIMARY_SET ) (int iAdapterIndex);\r\ntypedef int ( *ADL_ADAPTER_MODESWITCH ) (int iAdapterIndex);\r\ntypedef int ( *ADL_DISPLAY_MODES_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpNumModes, ADLMode **lppModes);\r\ntypedef int ( *ADL_DISPLAY_MODES_SET ) (int iAdapterIndex, int iDisplayIndex, int iNumModes, ADLMode *lpModes);\r\ntypedef int ( *ADL_DISPLAY_POSSIBLEMODE_GET ) (int iAdapterIndex, int *lpNumModes, ADLMode **lppModes);\r\ntypedef int ( *ADL_DISPLAY_FORCIBLEDISPLAY_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpStatus);\r\ntypedef int ( *ADL_DISPLAY_FORCIBLEDISPLAY_SET ) (int iAdapterIndex, int iDisplayIndex, int iStatus);\r\ntypedef int ( *ADL_ADAPTER_NUMBEROFACTIVATABLESOURCES_GET ) (int iAdapterIndex, int *lpNumSources, ADLActivatableSource **lppSources);\r\ntypedef int ( *ADL_ADAPTER_DISPLAY_CAPS ) (int iAdapterIndex, int *lpNumDisplayCaps, ADLAdapterDisplayCap **lppAdapterDisplayCaps);\r\ntypedef int ( *ADL_DISPLAY_DISPLAYMAPCONFIG_GET ) (int iAdapterIndex, int *lpNumDisplayMap, ADLDisplayMap **lppDisplayMap, int *lpNumDisplayTarget, ADLDisplayTarget **lppDisplayTarget, int iOptions);\r\ntypedef int ( *ADL_DISPLAY_DISPLAYMAPCONFIG_SET ) (int iAdapterIndex, int iNumDisplayMap, ADLDisplayMap *lpDisplayMap, int iNumDisplayTarget, ADLDisplayTarget *lpDisplayTarget);\r\ntypedef int ( *ADL_DISPLAY_POSSIBLEMAPPING_GET ) (int iAdapterIndex, int iNumberOfPresetMapping, ADLPossibleMapping *lpPresetMappings, int iEnquiryControllerIndex, int *lpNumberOfEnquiryPossibleMappings, ADLPossibleMapping **lppEnquiryPossibleMappings);\r\ntypedef int ( *ADL_DISPLAY_DISPLAYMAPCONFIG_VALIDATE ) (int iAdapterIndex, int iNumPossibleMap, ADLPossibleMap *lpPossibleMaps, int *lpNumPossibleMapResult, ADLPossibleMapResult **lppPossibleMapResult);\r\ntypedef int ( *ADL_DISPLAY_DISPLAYMAPCONFIG_POSSIBLEADDANDREMOVE ) (int iAdapterIndex, int iNumDisplayMap, ADLDisplayMap *lpDisplayMap, int iNumDisplayTarget, ADLDisplayTarget *lpDisplayTarget, int *lpNumPossibleAddTarget, ADLDisplayTarget **lppPossibleAddTarget, int *lpNumPossibleRemoveTarget, ADLDisplayTarget **lppPossibleRemoveTarget);\r\ntypedef int ( *ADL_DISPLAY_SLSGRID_CAPS ) (int iAdapterIndex, int *lpNumSLSGrid, ADLSLSGrid **lppSLSGrid, int iOption);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPINDEXLIST_GET ) (int iAdapterIndex, int *lpNumSLSMapIndexList, int **lppSLSMapIndexList, int iOptions);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPINDEX_GET ) (int iAdapterIndex, int iADLNumDisplayTarget, ADLDisplayTarget *lpDisplayTarget, int *lpSLSMapIndex);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPCONFIG_GET ) (int iAdapterIndex, int iSLSMapIndex, ADLSLSMap *lpSLSMap, int *lpNumSLSTarget, ADLSLSTarget **lppSLSTarget, int *lpNumNativeMode, ADLSLSMode **lppNativeMode, int *lpNumBezelMode, ADLBezelTransientMode **lppBezelMode, int *lpNumTransientMode, ADLBezelTransientMode **lppTransientMode, int *lpNumSLSOffset, ADLSLSOffset **lppSLSOffset, int iOption);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPCONFIG_CREATE ) (int iAdapterIndex, ADLSLSMap SLSMap, int iNumTargetTarget, ADLSLSTarget *lpSLSTarget, int iBezelModePercent, int *lpSLSMapIndex, int iOption);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPCONFIG_DELETE ) (int iAdapterIndex, int iSLSMapIndex);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPCONFIG_SETSTATE ) (int iAdapterIndex, int iSLSMapIndex, int iState);\r\ntypedef int ( *ADL_DISPLAY_SLSMAPCONFIG_REARRANGE ) (int iAdapterIndex, int iSLSMapIndex, int iNumDisplayTarget, ADLSLSTarget *lpSLSTarget, ADLSLSMap slsMap, int iOption);\r\ntypedef int ( *ADL_DISPLAY_POSSIBLEMODE_WINXP_GET ) (int iAdapterIndex, int iNumDisplayTargets, ADLDisplayTarget *lpDisplayTargets, int iLargeDesktopSupportedType, int iDevicePanningControl, int *lpNumModes, ADLMode **lppModes);\r\ntypedef int ( *ADL_DISPLAY_BEZELOFFSETSTEPPINGSIZE_GET ) (int iAdapterIndex, int *lpNumBezelOffsetSteppingSize, ADLBezelOffsetSteppingSize **lppBezelOffsetSteppingSize);\r\ntypedef int ( *ADL_DISPLAY_BEZELOFFSET_SET ) (int iAdapterIndex, int iSLSMapIndex, int iNumBezelOffset, LPADLSLSOffset lpBezelOffset, ADLSLSMap SLSMap, int iOption);\r\ntypedef int ( *ADL_DISPLAY_BEZELSUPPORTED_VALIDATE ) (int iAdapterIndex, int iNumPossibleSLSMap, LPADLPossibleSLSMap lpPossibleSLSMaps, int *lpNumPossibleSLSMapResult, LPADLPossibleMapResult *lppPossibleMapResult);\r\n\r\n// ADL Display/Color\r\ntypedef int ( *ADL_DISPLAY_COLORCAPS_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCaps, int *lpValids);\r\ntypedef int ( *ADL_DISPLAY_COLOR_SET ) (int iAdapterIndex, int iDisplayIndex, int iColorType, int iCurrent);\r\ntypedef int ( *ADL_DISPLAY_COLOR_GET ) (int iAdapterIndex, int iDisplayIndex, int iColorType, int *lpCurrent, int *lpDefault, int *lpMin, int *lpMax, int *lpStep);\r\ntypedef int ( *ADL_DISPLAY_COLORTEMPERATURESOURCE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpTempSource);\r\ntypedef int ( *ADL_DISPLAY_COLORTEMPERATURESOURCE_SET ) (int iAdapterIndex, int iDisplayIndex, int iTempSource);\r\n\r\n// ADL Display/Timing\r\ntypedef int ( *ADL_DISPLAY_MODETIMINGOVERRIDE_GET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayMode *lpModeIn, ADLDisplayModeInfo *lpModeInfoOut);\r\ntypedef int ( *ADL_DISPLAY_MODETIMINGOVERRIDE_SET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayModeInfo *lpMode, int iForceUpdate);\r\ntypedef int ( *ADL_DISPLAY_MODETIMINGOVERRIDELIST_GET ) (int iAdapterIndex, int iDisplayIndex, int iMaxNumOfOverrides, ADLDisplayModeInfo *lpModeInfoList, int *lpNumOfOverrides);\r\n\r\n// ADL Display/Customize\r\ntypedef int ( *ADL_DISPLAY_CUSTOMIZEDMODELISTNUM_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpListNum);\r\ntypedef int ( *ADL_DISPLAY_CUSTOMIZEDMODELIST_GET ) (int iAdapterIndex, int iDisplayIndex, ADLCustomMode *lpCustomModeList, int iBuffSize);\r\ntypedef int ( *ADL_DISPLAY_CUSTOMIZEDMODE_ADD ) (int iAdapterIndex, int iDisplayIndex, ADLCustomMode customMode);\r\ntypedef int ( *ADL_DISPLAY_CUSTOMIZEDMODE_DELETE ) (int iAdapterIndex, int iDisplayIndex, int iIndex);\r\ntypedef int ( *ADL_DISPLAY_CUSTOMIZEDMODE_VALIDATE ) (int iAdapterIndex, int iDisplayIndex, ADLCustomMode customMode, int *lpValid);\r\n\r\n// ADL Display/Over-Underscan\r\ntypedef int ( *ADL_DISPLAY_UNDERSCAN_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_DISPLAY_UNDERSCAN_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCurrent, int *lpDefault, int *lpMin, int *lpMax, int *lpStep);\r\ntypedef int ( *ADL_DISPLAY_OVERSCAN_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_DISPLAY_OVERSCAN_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCurrent, int *lpDefualt, int *lpMin, int *lpMax, int *lpStep);\r\n\r\n// ADL Display/Overlay\r\ntypedef int ( *ADL_DISPLAY_CONTROLLEROVERLAYADJUSTMENTCAPS_GET ) (int iAdapterIndex, ADLControllerOverlayInput *lpOverlayInput, ADLControllerOverlayInfo *lpCapsInfo);\r\ntypedef int ( *ADL_DISPLAY_CONTROLLEROVERLAYADJUSTMENTDATA_GET ) (int iAdapterIndex, ADLControllerOverlayInput *lpOverlay);\r\ntypedef int ( *ADL_DISPLAY_CONTROLLEROVERLAYADJUSTMENTDATA_SET ) (int iAdapterIndex, ADLControllerOverlayInput *lpOverlay);\r\n\r\n// ADL Display/PowerXpress\r\ntypedef int ( *ADL_DISPLAY_POWERXPRESSVERSION_GET ) (int iAdapterIndex, int *lpVersion);\r\ntypedef int ( *ADL_DISPLAY_POWERXPRESSACTIVEGPU_GET ) (int iAdapterIndex, int *lpActiveGPU);\r\ntypedef int ( *ADL_DISPLAY_POWERXPRESSACTIVEGPU_SET ) (int iAdapterIndex, int iActiveGPU, int *lpOperationResult);\r\ntypedef int ( *ADL_DISPLAY_POWERXPRESS_AUTOSWITCHCONFIG_GET ) (int iAdapterIndex, int *lpAutoSwitchOnACDCEvent, int *lpAutoSwitchOnDCACEvent);\r\ntypedef int ( *ADL_DISPLAY_POWERXPRESS_AUTOSWITCHCONFIG_SET ) (int iAdapterIndex, int iAutoSwitchOnACDCEvent, int iAutoSwitchOnDCACEvent);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL DFP\r\ntypedef int ( *ADL_DFP_BASEAUDIOSUPPORT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport);\r\ntypedef int ( *ADL_DFP_HDMISUPPORT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport);\r\ntypedef int ( *ADL_DFP_MVPUANALOGSUPPORT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport);\r\ntypedef int ( *ADL_DFP_PIXELFORMAT_CAPS ) (int iAdapterIndex, int iDisplayIndex, int *lpValidBits, int *lpValidCaps);\r\ntypedef int ( *ADL_DFP_PIXELFORMAT_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCurState, int *lpDefault);\r\ntypedef int ( *ADL_DFP_PIXELFORMAT_SET ) (int iAdapterIndex, int iDisplayIndex, int iState);\r\ntypedef int ( *ADL_DFP_GPUSCALINGENABLE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport, int *lpCurrent, int *lpDefault);\r\ntypedef int ( *ADL_DFP_GPUSCALINGENABLE_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_DFP_ALLOWONLYCETIMINGS_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpSupport, int *lpCurrent, int *lpDefault);\r\ntypedef int ( *ADL_DFP_ALLOWONLYCETIMINGS_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\n\r\n// ADl TV\r\ntypedef int ( *ADL_DISPLAY_TVCAPS_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpcaps);\r\ntypedef int ( *ADL_TV_STANDARD_SET ) (int iAdapterIndex, int iDisplayIndex, int iCurrent);\r\ntypedef int ( *ADL_TV_STANDARD_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCurrent, int *lpDefault, int *lpSupportedStandards);\r\n\r\n// ADL Component Video\r\ntypedef int ( *ADL_CV_DONGLESETTINGS_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpDongleSetting, int *lpOverrideSettingsSupported, int *lpCurOverrideSettings);\r\ntypedef int ( *ADL_CV_DONGLESETTINGS_SET ) (int iAdapterIndex, int iDisplayIndex, int iOverrideSettings);\r\ntypedef int ( *ADL_CV_DONGLESETTINGS_RESET ) (int iAdapterIndex, int iDisplayIndex);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL Overdrive 5\r\ntypedef int ( *ADL_OVERDRIVE5_CURRENTACTIVITY_GET ) (int iAdapterIndex, ADLPMActivity *lpActivity);\r\ntypedef int ( *ADL_OVERDRIVE5_THERMALDEVICES_ENUM ) (int iAdapterIndex, int iThermalControllerIndex, ADLThermalControllerInfo *lpThermalControllerInfo);\r\ntypedef int ( *ADL_OVERDRIVE5_TEMPERATURE_GET ) (int iAdapterIndex, int iThermalControllerIndex, ADLTemperature *lpTemperature);\r\ntypedef int ( *ADL_OVERDRIVE5_FANSPEEDINFO_GET ) (int iAdapterIndex, int iThermalControllerIndex, ADLFanSpeedInfo *lpFanSpeedInfo);\r\ntypedef int ( *ADL_OVERDRIVE5_FANSPEED_GET ) (int iAdapterIndex, int iThermalControllerIndex, ADLFanSpeedValue *lpFanSpeedValue);\r\ntypedef int ( *ADL_OVERDRIVE5_FANSPEED_SET ) (int iAdapterIndex, int iThermalControllerIndex, ADLFanSpeedValue *lpFanSpeedValue);\r\ntypedef int ( *ADL_OVERDRIVE5_FANSPEEDTODEFAULT_SET ) (int iAdapterIndex, int iThermalControllerIndex);\r\ntypedef int ( *ADL_OVERDRIVE5_ODPARAMETERS_GET ) (int iAdapterIndex, ADLODParameters *lpOdParameters);\r\ntypedef int ( *ADL_OVERDRIVE5_ODPERFORMANCELEVELS_GET ) (int iAdapterIndex, int iDefault, ADLODPerformanceLevels *lpOdPerformanceLevels);\r\ntypedef int ( *ADL_OVERDRIVE5_ODPERFORMANCELEVELS_SET ) (int iAdapterIndex, ADLODPerformanceLevels *lpOdPerformanceLevels);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL I2C\r\ntypedef int ( *ADL_DISPLAY_WRITEANDREADI2CREV_GET ) (int iAdapterIndex, int *lpMajor, int *lpMinor);\r\ntypedef int ( *ADL_DISPLAY_WRITEANDREADI2C ) (int iAdapterIndex, ADLI2C *plI2C);\r\ntypedef int ( *ADL_DISPLAY_DDCBLOCKACCESS_GET ) (int iAdapterIndex, int iDisplayIndex, int iOption, int iCommandIndex, int iSendMsgLen, char *lpucSendMsgBuf, int *lpulRecvMsgLen, char *lpucRecvMsgBuf);\r\ntypedef int ( *ADL_DISPLAY_DDCINFO_GET ) (int iAdapterIndex, int iDisplayIndex, ADLDDCInfo *lpInfo);\r\ntypedef int ( *ADL_DISPLAY_EDIDDATA_GET ) (int iAdapterIndex, int iDisplayIndex, ADLDisplayEDIDData *lpEDIDData);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n// ADL Workstation\r\ntypedef int ( *ADL_WORKSTATION_CAPS ) (int iAdapterIndex, int *lpValidBits, int *lpCaps);\r\ntypedef int ( *ADL_WORKSTATION_STEREO_GET ) (int iAdapterIndex, int *lpDefState, int *lpCurState);\r\ntypedef int ( *ADL_WORKSTATION_STEREO_SET ) (int iAdapterIndex, int iCurState);\r\ntypedef int ( *ADL_WORKSTATION_ADAPTERNUMOFGLSYNCCONNECTORS_GET ) (int iAdapterIndex, int *lpNumOfGLSyncConnectors);\r\ntypedef int ( *ADL_WORKSTATION_DISPLAYGENLOCKCAPABLE_GET ) (int iAdapterIndex, int iDisplayIndex, int *lpCanGenlock);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCMODULEDETECT_GET ) (int iAdapterIndex, int iGlSyncConnector, ADLGLSyncModuleID *lpGlSyncModuleID);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCMODULEINFO_GET ) (int iAdapterIndex, int iGlSyncConnector, int *lpNumGLSyncGPUPorts, int *lpNumGlSyncPorts, int *lpMaxSyncDelay, int *lpMaxSampleRate, ADLGLSyncPortCaps **ppGlSyncPorts);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCGENLOCKCONFIGURATION_GET ) (int iAdapterIndex, int iGlSyncConnector, int iGlValidMask, ADLGLSyncGenlockConfig *lpGlSyncGenlockConfig);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCGENLOCKCONFIGURATION_SET ) (int iAdapterIndex, int iGlSyncConnector, ADLGLSyncGenlockConfig glSyncGenlockConfig);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCPORTSTATE_GET ) (int iAdapterIndex, int iGlSyncConnector, int iGlSyncPortType, int iNumLEDs, ADLGlSyncPortInfo *lpGlSyncPortInfo, int **ppGlSyncLEDs);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCPORTSTATE_SET ) (int iAdapterIndex, int iGlSyncConnector, ADLGlSyncPortControl glSyncPortControl);\r\ntypedef int ( *ADL_WORKSTATION_DISPLAYGLSYNCMODE_GET ) (int iAdapterIndex, int iDisplayIndex, ADLGlSyncMode *lpGlSyncMode);\r\ntypedef int ( *ADL_WORKSTATION_DISPLAYGLSYNCMODE_SET ) (int iAdapterIndex, int iDisplayIndex, ADLGlSyncMode glSyncMode);\r\ntypedef int ( *ADL_WORKSTATION_GLSYNCSUPPORTEDTOPOLOGY_GET ) (int iAdapterIndex, int iNumSyncModes, ADLGlSyncMode2 *glSyncModes, int *iNumSugSyncModes, ADLGlSyncMode2 **glSugSyncModes);\r\ntypedef int ( *ADL_WORKSTATION_LOADBALANCING_GET ) (int *lpResultMask, int *lpCurResultValue, int *lpDefResultValue);\r\ntypedef int ( *ADL_WORKSTATION_LOADBALANCING_SET ) (int iCurState);\r\ntypedef int ( *ADL_WORKSTATION_LOADBALANCING_CAPS ) (int iAdapterIndex, int *lpResultMask, int *lpResultValue);\r\n\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n#ifdef LINUX\r\n// ADL Linux\r\ntypedef int ( *ADL_ADAPTER_MEMORYINFO_GET ) (int iAdapterIndex, ADLMemoryInfo *lpMemoryInfo);\r\ntypedef int ( *ADL_CONTROLLER_COLOR_SET ) (int iAdapterIndex, int iControllerIndex, ADLGamma adlGamma);\r\ntypedef int ( *ADL_CONTROLLER_COLOR_GET ) (int iAdapterIndex, int iControllerIndex, ADLGamma *lpGammaCurrent, ADLGamma *lpGammaDefault, ADLGamma *lpGammaMin, ADLGamma *lpGammaMax);\r\ntypedef int ( *ADL_DESKTOPCONFIG_GET ) (int iAdapterIndex, int *lpDesktopConfig);\r\ntypedef int ( *ADL_DESKTOPCONFIG_SET ) (int iAdapterIndex, int iDesktopConfig);\r\ntypedef int ( *ADL_NUMBEROFDISPLAYENABLE_GET ) (int iAdapterIndex, int *lpNumberOfDisplays);\r\ntypedef int ( *ADL_DISPLAYENABLE_SET ) (int iAdapterIndex, int *lpDisplayIndexList, int iDisplayListSize, int bPersistOnly);\r\ntypedef int ( *ADL_DISPLAY_IDENTIFYDISPLAY ) (int iAdapterIndex, int iDisplayIndex, int iDisplayControllerIndex, int iShow, int iDisplayNum, int iPosX, int iPosY);\r\ntypedef int ( *ADL_DISPLAY_LUTCOLOR_SET ) (int iAdapterIndex, int iDisplayIndex, ADLGamma adlGamma);\r\ntypedef int ( *ADL_DISPLAY_LUTCOLOR_GET ) (int iAdapterIndex, int iDisplayIndex, ADLGamma *lpGammaCurrent, ADLGamma *lpGammaDefault, ADLGamma *lpGammaMin, ADLGamma *lpGammaMax);\r\ntypedef int ( *ADL_ADAPTER_XSCREENINFO_GET ) (LPXScreenInfo lpXScreenInfo, int iInputSize);\r\ntypedef int ( *ADL_DISPLAY_XRANDRDISPLAYNAME_GET ) (int iAdapterIndex, int iDisplayIndex, char *lpXrandrDisplayName, int iBuffSize);\r\n#endif\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n// experimental undocumented\r\ntypedef int ( *ADL_OVERDRIVE5_POWERCONTROL_GET ) (int iAdapterIndex, int* iPercentage, int* whatever);\r\ntypedef int ( *ADL_OVERDRIVE5_POWERCONTROL_SET ) (int iAdapterIndex, int iPercentage);\r\n//typedef int ( *ADL_OVERDRIVE5_POWERCONTROL_CAPS ) (int iAdapterIndex, int* lpCaps, int* lpValid);\r\n//typedef int ( *ADL_OVERDRIVE5_POWERCONTROLINFO_GET) (int iAdapterIndex, ...)"
        },
        {
          "name": "api-example.c",
          "type": "blob",
          "size": 7.2490234375,
          "content": "/*\n * Copyright 2011-2012 Andrew Smith\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#include \"compat.h\"\n\n#ifndef WIN32\n\t#include <errno.h>\n\t#include <sys/socket.h>\n\t#include <netinet/in.h>\n\t#include <arpa/inet.h>\n\t#include <netdb.h>\n\n\t#define SOCKETTYPE int\n\t#define SOCKETFAIL(a) ((a) < 0)\n\t#define INVSOCK -1\n\t#define CLOSESOCKET close\n\n\t#define SOCKETINIT do{}while(0)\n\n\t#define SOCKERRMSG strerror(errno)\n#else\n\t#include <winsock2.h>\n\n\t#define SOCKETTYPE SOCKET\n\t#define SOCKETFAIL(a) ((a) == SOCKET_ERROR)\n\t#define INVSOCK INVALID_SOCKET\n\t#define CLOSESOCKET closesocket\n\n\tstatic char WSAbuf[1024];\n\n\tstruct WSAERRORS {\n\t\tint id;\n\t\tchar *code;\n\t} WSAErrors[] = {\n\t\t{ 0,\t\t\t\"No error\" },\n\t\t{ WSAEINTR,\t\t\"Interrupted system call\" },\n\t\t{ WSAEBADF,\t\t\"Bad file number\" },\n\t\t{ WSAEACCES,\t\t\"Permission denied\" },\n\t\t{ WSAEFAULT,\t\t\"Bad address\" },\n\t\t{ WSAEINVAL,\t\t\"Invalid argument\" },\n\t\t{ WSAEMFILE,\t\t\"Too many open sockets\" },\n\t\t{ WSAEWOULDBLOCK,\t\"Operation would block\" },\n\t\t{ WSAEINPROGRESS,\t\"Operation now in progress\" },\n\t\t{ WSAEALREADY,\t\t\"Operation already in progress\" },\n\t\t{ WSAENOTSOCK,\t\t\"Socket operation on non-socket\" },\n\t\t{ WSAEDESTADDRREQ,\t\"Destination address required\" },\n\t\t{ WSAEMSGSIZE,\t\t\"Message too long\" },\n\t\t{ WSAEPROTOTYPE,\t\"Protocol wrong type for socket\" },\n\t\t{ WSAENOPROTOOPT,\t\"Bad protocol option\" },\n\t\t{ WSAEPROTONOSUPPORT,\t\"Protocol not supported\" },\n\t\t{ WSAESOCKTNOSUPPORT,\t\"Socket type not supported\" },\n\t\t{ WSAEOPNOTSUPP,\t\"Operation not supported on socket\" },\n\t\t{ WSAEPFNOSUPPORT,\t\"Protocol family not supported\" },\n\t\t{ WSAEAFNOSUPPORT,\t\"Address family not supported\" },\n\t\t{ WSAEADDRINUSE,\t\"Address already in use\" },\n\t\t{ WSAEADDRNOTAVAIL,\t\"Can't assign requested address\" },\n\t\t{ WSAENETDOWN,\t\t\"Network is down\" },\n\t\t{ WSAENETUNREACH,\t\"Network is unreachable\" },\n\t\t{ WSAENETRESET,\t\t\"Net connection reset\" },\n\t\t{ WSAECONNABORTED,\t\"Software caused connection abort\" },\n\t\t{ WSAECONNRESET,\t\"Connection reset by peer\" },\n\t\t{ WSAENOBUFS,\t\t\"No buffer space available\" },\n\t\t{ WSAEISCONN,\t\t\"Socket is already connected\" },\n\t\t{ WSAENOTCONN,\t\t\"Socket is not connected\" },\n\t\t{ WSAESHUTDOWN,\t\t\"Can't send after socket shutdown\" },\n\t\t{ WSAETOOMANYREFS,\t\"Too many references, can't splice\" },\n\t\t{ WSAETIMEDOUT,\t\t\"Connection timed out\" },\n\t\t{ WSAECONNREFUSED,\t\"Connection refused\" },\n\t\t{ WSAELOOP,\t\t\"Too many levels of symbolic links\" },\n\t\t{ WSAENAMETOOLONG,\t\"File name too long\" },\n\t\t{ WSAEHOSTDOWN,\t\t\"Host is down\" },\n\t\t{ WSAEHOSTUNREACH,\t\"No route to host\" },\n\t\t{ WSAENOTEMPTY,\t\t\"Directory not empty\" },\n\t\t{ WSAEPROCLIM,\t\t\"Too many processes\" },\n\t\t{ WSAEUSERS,\t\t\"Too many users\" },\n\t\t{ WSAEDQUOT,\t\t\"Disc quota exceeded\" },\n\t\t{ WSAESTALE,\t\t\"Stale NFS file handle\" },\n\t\t{ WSAEREMOTE,\t\t\"Too many levels of remote in path\" },\n\t\t{ WSASYSNOTREADY,\t\"Network system is unavailable\" },\n\t\t{ WSAVERNOTSUPPORTED,\t\"Winsock version out of range\" },\n\t\t{ WSANOTINITIALISED,\t\"WSAStartup not yet called\" },\n\t\t{ WSAEDISCON,\t\t\"Graceful shutdown in progress\" },\n\t\t{ WSAHOST_NOT_FOUND,\t\"Host not found\" },\n\t\t{ WSANO_DATA,\t\t\"No host data of that type was found\" },\n\t\t{ -1,\t\t\t\"Unknown error code\" }\n\t};\n\n\tstatic char *WSAErrorMsg()\n\t{\n\t\tint i;\n\t\tint id = WSAGetLastError();\n\n\t\t/* Assume none of them are actually -1 */\n\t\tfor (i = 0; WSAErrors[i].id != -1; i++)\n\t\t\tif (WSAErrors[i].id == id)\n\t\t\t\tbreak;\n\n\t\tsprintf(WSAbuf, \"Socket Error: (%d) %s\", id, WSAErrors[i].code);\n\n\t\treturn &(WSAbuf[0]);\n\t}\n\n\t#define SOCKERRMSG WSAErrorMsg()\n\n\tstatic WSADATA WSA_Data;\n\n\t#define SOCKETINIT\tdo {  \\\n\t\tint wsa; \\\n\t\t\t\tif ( (wsa = WSAStartup(0x0202, &WSA_Data)) ) { \\\n\t\t\t\t\tprintf(\"Socket startup failed: %d\\n\", wsa); \\\n\t\t\t\t\treturn 1; \\\n\t\t}  \\\n\t} while (0)\n\n\t#ifndef SHUT_RDWR\n\t#define SHUT_RDWR SD_BOTH\n\t#endif\n#endif\n\n#define RECVSIZE 65500\n\nstatic const char SEPARATOR = '|';\nstatic const char COMMA = ',';\nstatic const char EQ = '=';\nstatic int ONLY;\n\nvoid display(char *buf)\n{\n\tchar *nextobj, *item, *nextitem, *eq;\n\tint itemcount;\n\n\twhile (buf != NULL) {\n\t\tnextobj = strchr(buf, SEPARATOR);\n\t\tif (nextobj != NULL)\n\t\t\t*(nextobj++) = '\\0';\n\n\t\tif (*buf) {\n\t\t\titem = buf;\n\t\t\titemcount = 0;\n\t\t\twhile (item != NULL) {\n\t\t\t\tnextitem = strchr(item, COMMA);\n\t\t\t\tif (nextitem != NULL)\n\t\t\t\t\t*(nextitem++) = '\\0';\n\n\t\t\t\tif (*item) {\n\t\t\t\t\teq = strchr(item, EQ);\n\t\t\t\t\tif (eq != NULL)\n\t\t\t\t\t\t*(eq++) = '\\0';\n\n\t\t\t\t\tif (itemcount == 0)\n\t\t\t\t\t\tprintf(\"[%s%s] =>\\n(\\n\", item, (eq != NULL && isdigit(*eq)) ? eq : \"\");\n\n\t\t\t\t\tif (eq != NULL)\n\t\t\t\t\t\tprintf(\"   [%s] => %s\\n\", item, eq);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"   [%d] => %s\\n\", itemcount, item);\n\t\t\t\t}\n\n\t\t\t\titem = nextitem;\n\t\t\t\titemcount++;\n\t\t\t}\n\t\t\tif (itemcount > 0)\n\t\t\t\tputs(\")\");\n\t\t}\n\n\t\tbuf = nextobj;\n\t}\n}\n\nint callapi(char *command, char *host, short int port)\n{\n\tsize_t bufsz = RECVSIZE;\n\tchar *buf = malloc(bufsz+1);\n\tstruct hostent *ip;\n\tstruct sockaddr_in serv;\n\tSOCKETTYPE sock;\n\tint ret = 0;\n\tint n, p;\n\n\tassert(buf);\n\tSOCKETINIT;\n\n\tip = gethostbyname(host);\n\tif (!ip)\n\t{\n\t\tprintf(\"Failed to resolve host %s\\n\", host);\n\t\treturn 1;\n\t}\n\n\tsock = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sock == INVSOCK) {\n\t\tprintf(\"Socket initialisation failed: %s\\n\", SOCKERRMSG);\n\t\treturn 1;\n\t}\n\n\tmemset(&serv, 0, sizeof(serv));\n\tserv.sin_family = AF_INET;\n\tserv.sin_addr = *((struct in_addr *)ip->h_addr);\n\tserv.sin_port = htons(port);\n\n\tif (SOCKETFAIL(connect(sock, (struct sockaddr *)&serv, sizeof(struct sockaddr)))) {\n\t\tprintf(\"Socket connect failed: %s\\n\", SOCKERRMSG);\n\t\treturn 1;\n\t}\n\n\tn = send(sock, command, strlen(command), 0);\n\tif (SOCKETFAIL(n)) {\n\t\tprintf(\"Send failed: %s\\n\", SOCKERRMSG);\n\t\tret = 1;\n\t}\n\telse {\n\t\tp = 0;\n\t\tbuf[0] = '\\0';\n\t\twhile (true)\n\t\t{\n\t\t\tif (bufsz < RECVSIZE + p)\n\t\t\t{\n\t\t\t\tbufsz *= 2;\n\t\t\t\tbuf = realloc(buf, bufsz);\n\t\t\t\tassert(buf);\n\t\t\t}\n\t\t\t\n\t\t\tn = recv(sock, &buf[p], RECVSIZE, 0);\n\n\t\t\tif (SOCKETFAIL(n)) {\n\t\t\t\tprintf(\"Recv failed: %s\\n\", SOCKERRMSG);\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tp += n;\n\t\t\tbuf[p] = '\\0';\n\t\t}\n\n\t\tif (!ONLY)\n\t\t\tprintf(\"Reply was '%s'\\n\", buf);\n\t\telse\n\t\t\tprintf(\"%s\\n\", buf);\n\n\t\tif (!ONLY)\n\t\t\tdisplay(buf);\n\t}\n\n\tCLOSESOCKET(sock);\n\n\treturn ret;\n}\n\nstatic char *trim(char *str)\n{\n\tchar *ptr;\n\n\twhile (isspace(*str))\n\t\tstr++;\n\n\tptr = strchr(str, '\\0');\n\twhile (ptr-- > str) {\n\t\tif (isspace(*ptr))\n\t\t\t*ptr = '\\0';\n\t}\n\n\treturn str;\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *command = \"summary\";\n\tchar *host = \"127.0.0.1\";\n\tshort int port = 4028;\n\tchar *ptr;\n\tint i = 1;\n\n\tif (argc > 1)\n\t\tif (strcmp(argv[1], \"-?\") == 0\n\t\t||  strcmp(argv[1], \"-h\") == 0\n\t\t||  strcmp(argv[1], \"--help\") == 0) {\n\t\t\tfprintf(stderr, \"Usage: %s [command [ip/host [port]]]\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\n\tif (argc > 1)\n\t\tif (strcmp(argv[1], \"-o\") == 0) {\n\t\t\tONLY = 1;\n\t\t\ti = 2;\n\t\t}\n\n\tif (argc > i) {\n\t\tptr = trim(argv[i++]);\n\t\tif (strlen(ptr) > 0)\n\t\t\tcommand = ptr;\n\t}\n\n\tif (argc > i) {\n\t\tptr = trim(argv[i++]);\n\t\tif (strlen(ptr) > 0)\n\t\t\thost = ptr;\n\t}\n\n\tif (argc > i) {\n\t\tptr = trim(argv[i]);\n\t\tif (strlen(ptr) > 0)\n\t\t\tport = atoi(ptr);\n\t}\n\n\treturn callapi(command, host, port);\n}\n"
        },
        {
          "name": "api-example.php",
          "type": "blob",
          "size": 2.0087890625,
          "content": "<?php\n#\n# Sample Socket I/O to BFGMiner API\n#\nfunction getsock($addr, $port)\n{\n $socket = null;\n $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n if ($socket === false || $socket === null)\n {\n\t$error = socket_strerror(socket_last_error());\n\t$msg = \"socket create(TCP) failed\";\n\techo \"ERR: $msg '$error'\\n\";\n\treturn null;\n }\n\n $res = socket_connect($socket, $addr, $port);\n if ($res === false)\n {\n\t$error = socket_strerror(socket_last_error());\n\t$msg = \"socket connect($addr,$port) failed\";\n\techo \"ERR: $msg '$error'\\n\";\n\tsocket_close($socket);\n\treturn null;\n }\n return $socket;\n}\n#\n# Slow ...\nfunction readsockline($socket)\n{\n $line = '';\n while (true)\n {\n\t$byte = socket_read($socket, 1);\n\tif ($byte === false || $byte === '')\n\t\tbreak;\n\tif ($byte === \"\\0\")\n\t\tbreak;\n\t$line .= $byte;\n }\n return $line;\n}\n#\nfunction request($cmd)\n{\n $socket = getsock('127.0.0.1', 4028);\n if ($socket != null)\n {\n\tsocket_write($socket, $cmd, strlen($cmd));\n\t$line = readsockline($socket);\n\tsocket_close($socket);\n\n\tif (strlen($line) == 0)\n\t{\n\t\techo \"WARN: '$cmd' returned nothing\\n\";\n\t\treturn $line;\n\t}\n\n\tprint \"$cmd returned '$line'\\n\";\n\n\tif (substr($line,0,1) == '{')\n\t\treturn json_decode($line, true);\n\n\t$data = array();\n\n\t$objs = explode('|', $line);\n\tforeach ($objs as $obj)\n\t{\n\t\tif (strlen($obj) > 0)\n\t\t{\n\t\t\t$items = explode(',', $obj);\n\t\t\t$item = $items[0];\n\t\t\t$id = explode('=', $items[0], 2);\n\t\t\tif (count($id) == 1 or !ctype_digit($id[1]))\n\t\t\t\t$name = $id[0];\n\t\t\telse\n\t\t\t\t$name = $id[0].$id[1];\n\n\t\t\tif (strlen($name) == 0)\n\t\t\t\t$name = 'null';\n\n\t\t\tif (isset($data[$name]))\n\t\t\t{\n\t\t\t\t$num = 1;\n\t\t\t\twhile (isset($data[$name.$num]))\n\t\t\t\t\t$num++;\n\t\t\t\t$name .= $num;\n\t\t\t}\n\n\t\t\t$counter = 0;\n\t\t\tforeach ($items as $item)\n\t\t\t{\n\t\t\t\t$id = explode('=', $item, 2);\n\t\t\t\tif (count($id) == 2)\n\t\t\t\t\t$data[$name][$id[0]] = $id[1];\n\t\t\t\telse\n\t\t\t\t\t$data[$name][$counter] = $id[0];\n\n\t\t\t\t$counter++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn $data;\n }\n\n return null;\n}\n#\nif (isset($argv) and count($argv) > 1)\n $r = request($argv[1]);\nelse\n $r = request('summary');\n#\necho print_r($r, true).\"\\n\";\n#\n?>\n"
        },
        {
          "name": "api-example.py",
          "type": "blob",
          "size": 1.474609375,
          "content": "#!/usr/bin/python\n# Copyright 2013 Christian Berendt\n# Copyright 2013 Luke Dashjr\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option) any later\n# version.  See COPYING for more details.\n\nimport argparse\nimport json\nimport logging\nimport pprint\nimport socket\n\nlogging.basicConfig(\n         format='%(asctime)s %(levelname)s %(message)s',\n         level=logging.DEBUG\n)\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"command\", default=\"summary\", nargs='?')\nparser.add_argument(\"parameter\", default=\"\", nargs='?')\nparser.add_argument(\"--hostname\", default=\"localhost\")\nparser.add_argument(\"--port\", type=int, default=4028)\nargs = parser.parse_args()\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n    s.connect((args.hostname, args.port))\nexcept socket.error, e:\n    logging.error(e)\n\ntry:\n    s.send(\"{\\\"command\\\" : \\\"%s\\\", \\\"parameter\\\" : \\\"%s\\\"}\"\n            % (args.command, args.parameter)\n          )\nexcept socket.error, e:\n    logging.error(e)\n\n\ndata = ''\nwhile True:\n    try:\n        newdata = s.recv(1024)\n        if newdata:\n            data += newdata\n        else:\n            break\n    except socket.error, e:\n        break\n\ntry:\n    s.close()\nexcept socket.error,e:\n    logging.error(e)\n\nif data:\n    data = json.loads(data.replace('\\x00', ''))\n    pp = pprint.PrettyPrinter()\n    pp.pprint(data)\n"
        },
        {
          "name": "api-example.rb",
          "type": "blob",
          "size": 0.826171875,
          "content": "#!/usr/bin/env ruby\n\n# Copyright 2014 James Hilliard\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option) any later\n# version.  See COPYING for more details.\n\nrequire 'socket'\nrequire 'json'\n\napi_command = ARGV[0].split(\":\")\n\nif ARGV.length == 3\n\tapi_ip = ARGV[1]\n\tapi_port = ARGV[2]\nelsif ARGV.length == 2\n\tapi_ip = ARGV[1]\n\tapi_port = 4028\nelse\n\tapi_ip = \"127.0.0.1\"\n\tapi_port = 4028\nend\n\ns = TCPSocket.open(api_ip, api_port)\n\nif api_command.count == 2\n\ts.write({ :command => api_command[0], :parameter => api_command[1]}.to_json)\nelse\n\ts.write({ :command => api_command[0]}.to_json)\nend\n\nresponse = s.read.strip\nresponse = JSON.parse(response)\n\nputs response\ns.close\n"
        },
        {
          "name": "api.c",
          "type": "blob",
          "size": 116.732421875,
          "content": "/*\n * Copyright 2011-2014 Andrew Smith\n * Copyright 2011-2014 Con Kolivas\n * Copyright 2012-2017 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n *\n * Note: the code always includes GPU support even if there are no GPUs\n *\tthis simplifies handling multiple other device code being included\n *\tdepending on compile options\n */\n#define _MEMORY_DEBUG_MASTER 1\n\n#include \"config.h\"\n\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <sys/types.h>\n\n#include <uthash.h>\n#include <utlist.h>\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#ifdef USE_LIBMICROHTTPD\n#include \"httpsrv.h\"\n#endif\n#include \"miner.h\"\n#include \"util.h\"\n#include \"driver-cpu.h\" /* for algo_names[], TODO: re-factor dependency */\n#include \"driver-opencl.h\"\n\n#define HAVE_AN_FPGA 1\n\n// Max amount of data to buffer before sending on the socket\n#define RPC_SOCKBUFSIZ     0x10000\n\n// BUFSIZ varies on Windows and Linux\n#define TMPBUFSIZ\t8192\n\n// Number of requests to queue - normally would be small\n// However lots of PGA's may mean more\n#define QUEUE\t100\n\nstatic const char *UNAVAILABLE = \" - API will not be available\";\nstatic const char *MUNAVAILABLE = \" - API multicast listener will not be available\";\n\nstatic const char *BLANK = \"\";\nstatic const char *COMMA = \",\";\n#define COMSTR \",\"\nstatic const char SEPARATOR = '|';\n#define SEPSTR \"|\"\nstatic const char GPUSEP = ',';\n#define CMDJOIN '+'\n#define JOIN_CMD \"CMD=\"\n#define BETWEEN_JOIN SEPSTR\n\nstatic const char *APIVERSION = \"3.1\";\nstatic const char *DEAD = \"Dead\";\nstatic const char *SICK = \"Sick\";\nstatic const char *NOSTART = \"NoStart\";\nstatic const char *INIT = \"Initialising\";\nstatic const char *WAIT = \"Waiting\";\nstatic const char *DISABLED = \"Disabled\";\nstatic const char *ALIVE = \"Alive\";\nstatic const char *REJECTING = \"Rejecting\";\nstatic const char *UNKNOWN = \"Unknown\";\n#define _DYNAMIC \"D\"\n#ifdef USE_OPENCL\nstatic const char *DYNAMIC = _DYNAMIC;\n#endif\n\nstatic const char *YES = \"Y\";\nstatic const char *NO = \"N\";\nstatic const char *NULLSTR = \"(null)\";\n\nstatic const char *TRUESTR = \"true\";\nstatic const char *FALSESTR = \"false\";\n\n#ifdef USE_SCRYPT\nstatic const char *SCRYPTSTR = \"scrypt\";\n#endif\n#ifdef USE_SHA256D\nstatic const char *SHA256STR = \"sha256\";\n#endif\n\nstatic const char *OSINFO =\n#if defined(__linux)\n\t\t\t\"Linux\";\n#else\n#if defined(__APPLE__)\n\t\t\t\"Apple\";\n#else\n#if defined (__CYGWIN__)\n\t\t\t\"Cygwin\";\n#elif defined (WIN32)\n\t\t\t\"Windows\";\n#else\n#if defined(unix)\n\t\t\t\"Unix\";\n#else\n\t\t\t\"Unknown\";\n#endif\n#endif\n#endif\n#endif\n\n#define _DEVS\t\t\"DEVS\"\n#define _POOLS\t\t\"POOLS\"\n#define _SUMMARY\t\"SUMMARY\"\n#define _STATUS\t\t\"STATUS\"\n#define _VERSION\t\"VERSION\"\n#define _MINECONFIG\t\"CONFIG\"\n#define _GPU\t\t\"GPU\"\n\n#ifdef HAVE_AN_FPGA\n#define _PGA\t\t\"PGA\"\n#endif\n\n#ifdef USE_CPUMINING\n#define _CPU\t\t\"CPU\"\n#endif\n\n#define _GPUS\t\t\"GPUS\"\n#define _PGAS\t\t\"PGAS\"\n#define _CPUS\t\t\"CPUS\"\n#define _NOTIFY\t\t\"NOTIFY\"\n#define _DEVDETAILS\t\"DEVDETAILS\"\n#define _BYE\t\t\"BYE\"\n#define _RESTART\t\"RESTART\"\n#define _MINESTATS\t\"STATS\"\n#define _CHECK\t\t\"CHECK\"\n#define _MINECOIN\t\"COIN\"\n#define _DEBUGSET\t\"DEBUG\"\n#define _SETCONFIG\t\"SETCONFIG\"\n\nstatic const char ISJSON = '{';\n#define JSON0\t\t\"{\"\n#define JSON1\t\t\"\\\"\"\n#define JSON2\t\t\"\\\":[\"\n#define JSON3\t\t\"]\"\n#define JSON4\t\t\",\\\"id\\\":1\"\n// If anyone cares, id=0 for truncated output\n#define JSON4_TRUNCATED\t\",\\\"id\\\":0\"\n#define JSON5\t\t\"}\"\n\n#define JSON_START\tJSON0\n#define JSON_DEVS\tJSON1 _DEVS JSON2\n#define JSON_POOLS\tJSON1 _POOLS JSON2\n#define JSON_SUMMARY\tJSON1 _SUMMARY JSON2\n#define JSON_STATUS\tJSON1 _STATUS JSON2\n#define JSON_VERSION\tJSON1 _VERSION JSON2\n#define JSON_MINECONFIG\tJSON1 _MINECONFIG JSON2\n#define JSON_GPU\tJSON1 _GPU JSON2\n\n#ifdef HAVE_AN_FPGA\n#define JSON_PGA\tJSON1 _PGA JSON2\n#endif\n\n#ifdef USE_CPUMINING\n#define JSON_CPU\tJSON1 _CPU JSON2\n#endif\n\n#define JSON_GPUS\tJSON1 _GPUS JSON2\n#define JSON_PGAS\tJSON1 _PGAS JSON2\n#define JSON_CPUS\tJSON1 _CPUS JSON2\n#define JSON_NOTIFY\tJSON1 _NOTIFY JSON2\n#define JSON_CLOSE\tJSON3\n#define JSON_MINESTATS\tJSON1 _MINESTATS JSON2\n#define JSON_CHECK\tJSON1 _CHECK JSON2\n#define JSON_DEBUGSET\tJSON1 _DEBUGSET JSON2\n#define JSON_SETCONFIG\tJSON1 _SETCONFIG JSON2\n#define JSON_END\tJSON4 JSON5\n#define JSON_END_TRUNCATED\tJSON4_TRUNCATED JSON5\n#define JSON_BETWEEN_JOIN\t\",\"\n\nstatic const char *JSON_COMMAND = \"command\";\nstatic const char *JSON_PARAMETER = \"parameter\";\n\n#define MSG_INVGPU 1\n#define MSG_ALRENA 2\n#define MSG_ALRDIS 3\n#define MSG_GPUMRE 4\n#define MSG_GPUREN 5\n#define MSG_GPUNON 6\n#define MSG_POOL 7\n#define MSG_NOPOOL 8\n#define MSG_DEVS 9\n#define MSG_NODEVS 10\n#define MSG_SUMM 11\n#define MSG_GPUDIS 12\n#define MSG_GPUREI 13\n#define MSG_INVCMD 14\n#define MSG_MISID 15\n#define MSG_GPUDEV 17\n\n#ifdef USE_CPUMINING\n#define MSG_CPUNON 16\n#define MSG_CPUDEV 18\n#define MSG_INVCPU 19\n#define MSG_ALRENAC 98\n#define MSG_ALRDISC 99\n#define MSG_CPUMRE 100\n#define MSG_CPUREN 101\n#define MSG_CPUDIS 102\n#define MSG_CPUREI 103\n#endif\n\n#define MSG_NUMGPU 20\n#define MSG_NUMCPU 21\n#define MSG_VERSION 22\n#define MSG_INVJSON 23\n#define MSG_MISCMD 24\n#define MSG_MISPID 25\n#define MSG_INVPID 26\n#define MSG_SWITCHP 27\n#define MSG_MISVAL 28\n#define MSG_NOADL 29\n#define MSG_NOGPUADL 30\n#define MSG_INVINT 31\n#define MSG_GPUINT 32\n#define MSG_MINECONFIG 33\n#define MSG_GPUMERR 34\n#define MSG_GPUMEM 35\n#define MSG_GPUEERR 36\n#define MSG_GPUENG 37\n#define MSG_GPUVERR 38\n#define MSG_GPUVDDC 39\n#define MSG_GPUFERR 40\n#define MSG_GPUFAN 41\n#define MSG_MISFN 42\n#define MSG_BADFN 43\n#define MSG_SAVED 44\n#define MSG_ACCDENY 45\n#define MSG_ACCOK 46\n#define MSG_ENAPOOL 47\n#define MSG_DISPOOL 48\n#define MSG_ALRENAP 49\n#define MSG_ALRDISP 50\n#define MSG_DISLASTP 51\n#define MSG_MISPDP 52\n#define MSG_INVPDP 53\n#define MSG_TOOMANYP 54\n#define MSG_ADDPOOL 55\n\n#ifdef HAVE_AN_FPGA\n#define MSG_PGANON 56\n#define MSG_PGADEV 57\n#define MSG_INVPGA 58\n#endif\n\n#define MSG_NUMPGA 59\n#define MSG_NOTIFY 60\n\n#ifdef HAVE_AN_FPGA\n#define MSG_PGALRENA 61\n#define MSG_PGALRDIS 62\n#define MSG_PGAENA 63\n#define MSG_PGADIS 64\n#define MSG_PGAREI 0x101\n#define MSG_PGAUNW 65\n#endif\n\n#define MSG_REMLASTP 66\n#define MSG_ACTPOOL 67\n#define MSG_REMPOOL 68\n#define MSG_DEVDETAILS 69\n#define MSG_MINESTATS 70\n#define MSG_MISCHK 71\n#define MSG_CHECK 72\n#define MSG_POOLPRIO 73\n#define MSG_DUPPID 74\n#define MSG_MISBOOL 75\n#define MSG_INVBOOL 76\n#define MSG_FOO 77\n#define MSG_MINECOIN 78\n#define MSG_DEBUGSET 79\n#define MSG_PGAIDENT 80\n#define MSG_PGANOID 81\n\n#define MSG_SETCONFIG 82\n#define MSG_UNKCON 83\n#define MSG_INVNUM 84\n#define MSG_CONPAR 85\n#define MSG_CONVAL 86\n\n#ifdef HAVE_AN_FPGA\n#define MSG_MISPGAOPT 89\n#define MSG_PGANOSET 90\n#define MSG_PGAHELP 91\n#define MSG_PGASETOK 92\n#define MSG_PGASETERR 93\n#endif\n\n#define MSG_ZERMIS 94\n#define MSG_ZERINV 95\n#define MSG_ZERSUM 96\n#define MSG_ZERNOSUM 97\n\n#define MSG_DEVSCAN 0x100\n#define MSG_BYE 0x101\n\n#define MSG_INVNEG 121\n#define MSG_SETQUOTA 122\n\n#define MSG_INVSTRATEGY 0x102\n#define MSG_FAILPORT 0x103\n\n#define USE_ALTMSG 0x4000\n\nenum code_severity {\n\tSEVERITY_ERR,\n\tSEVERITY_WARN,\n\tSEVERITY_INFO,\n\tSEVERITY_SUCC,\n\tSEVERITY_FAIL\n};\n\nenum code_parameters {\n\tPARAM_COUNT,\n\tPARAM_GPU,\n\tPARAM_PGA,\n\tPARAM_CPU,\n\tPARAM_PID,\n\tPARAM_GPUMAX,\n\tPARAM_PGAMAX,\n\tPARAM_CPUMAX,\n\tPARAM_PMAX,\n\tPARAM_POOLMAX,\n\n// Single generic case: have the code resolve it - see below\n\tPARAM_DMAX,\n\n\tPARAM_CMD,\n\tPARAM_POOL,\n\tPARAM_STR,\n\tPARAM_BOTH,\n\tPARAM_BOOL,\n\tPARAM_SET,\n\tPARAM_NONE\n};\n\nstruct CODES {\n\tconst enum code_severity severity;\n\tconst int code;\n\tconst enum code_parameters params;\n\tconst char *description;\n} codes[] = {\n#ifdef USE_OPENCL\n { SEVERITY_ERR,   MSG_INVGPU,\tPARAM_GPUMAX,\t\"Invalid GPU id %d - range is 0 - %d\" },\n { SEVERITY_INFO,  MSG_ALRENA,\tPARAM_GPU,\t\"GPU %d already enabled\" },\n { SEVERITY_INFO,  MSG_ALRDIS,\tPARAM_GPU,\t\"GPU %d already disabled\" },\n { SEVERITY_WARN,  MSG_GPUMRE,\tPARAM_GPU,\t\"GPU %d must be restarted first\" },\n { SEVERITY_INFO,  MSG_GPUREN,\tPARAM_GPU,\t\"GPU %d sent enable message\" },\n#endif\n { SEVERITY_ERR,   MSG_GPUNON,\tPARAM_NONE,\t\"No GPUs\" },\n { SEVERITY_SUCC,  MSG_POOL,\tPARAM_PMAX,\t\"%d Pool(s)\" },\n { SEVERITY_ERR,   MSG_NOPOOL,\tPARAM_NONE,\t\"No pools\" },\n\n { SEVERITY_SUCC,  MSG_DEVS,\tPARAM_DMAX,\n\t\t\t\t\t\t\"%d PGA(s)\"\n },\n\n { SEVERITY_ERR,   MSG_NODEVS,\tPARAM_NONE,\t\"No PGAs\"\n },\n\n { SEVERITY_SUCC,  MSG_SUMM,\tPARAM_NONE,\t\"Summary\" },\n#ifdef USE_OPENCL\n { SEVERITY_INFO,  MSG_GPUDIS,\tPARAM_GPU,\t\"GPU %d set disable flag\" },\n { SEVERITY_INFO,  MSG_GPUREI,\tPARAM_GPU,\t\"GPU %d restart attempted\" },\n#endif\n { SEVERITY_ERR,   MSG_INVCMD,\tPARAM_NONE,\t\"Invalid command\" },\n { SEVERITY_ERR,   MSG_MISID,\tPARAM_NONE,\t\"Missing device id parameter\" },\n#ifdef USE_OPENCL\n { SEVERITY_SUCC,  MSG_GPUDEV,\tPARAM_GPU,\t\"GPU%d\" },\n#endif\n#ifdef HAVE_AN_FPGA\n { SEVERITY_ERR,   MSG_PGANON,\tPARAM_NONE,\t\"No PGAs\" },\n { SEVERITY_SUCC,  MSG_PGADEV,\tPARAM_PGA,\t\"PGA%d\" },\n { SEVERITY_ERR,   MSG_INVPGA,\tPARAM_PGAMAX,\t\"Invalid PGA id %d - range is 0 - %d\" },\n { SEVERITY_INFO,  MSG_PGALRENA,PARAM_PGA,\t\"PGA %d already enabled\" },\n { SEVERITY_INFO,  MSG_PGALRDIS,PARAM_PGA,\t\"PGA %d already disabled\" },\n { SEVERITY_INFO,  MSG_PGAENA,\tPARAM_PGA,\t\"PGA %d sent enable message\" },\n { SEVERITY_INFO,  MSG_PGADIS,\tPARAM_PGA,\t\"PGA %d set disable flag\" },\n { SEVERITY_ERR,   MSG_PGAUNW,\tPARAM_PGA,\t\"PGA %d is not flagged WELL, cannot enable\" },\n#endif\n#ifdef USE_CPUMINING\n { SEVERITY_ERR,   MSG_CPUNON,\tPARAM_NONE,\t\"No CPUs\" },\n { SEVERITY_SUCC,  MSG_CPUDEV,\tPARAM_CPU,\t\"CPU%d\" },\n { SEVERITY_ERR,   MSG_INVCPU,\tPARAM_CPUMAX,\t\"Invalid CPU id %d - range is 0 - %d\" },\n { SEVERITY_INFO,  MSG_ALRENAC,\tPARAM_CPU,\t\"CPU %d already enabled\" },\n { SEVERITY_INFO,  MSG_ALRDISC,\tPARAM_CPU,\t\"CPU %d already disabled\" },\n { SEVERITY_WARN,  MSG_CPUMRE,\tPARAM_CPU,\t\"CPU %d must be restarted first\" },\n { SEVERITY_INFO,  MSG_CPUREN,\tPARAM_CPU,\t\"CPU %d sent enable message\" },\n { SEVERITY_INFO,  MSG_CPUDIS,\tPARAM_CPU,\t\"CPU %d set disable flag\" },\n { SEVERITY_INFO,  MSG_CPUREI,\tPARAM_CPU,\t\"CPU %d restart attempted\" },\n#endif\n { SEVERITY_SUCC,  MSG_NUMGPU,\tPARAM_NONE,\t\"GPU count\" },\n { SEVERITY_SUCC,  MSG_NUMPGA,\tPARAM_NONE,\t\"PGA count\" },\n { SEVERITY_SUCC,  MSG_NUMCPU,\tPARAM_NONE,\t\"CPU count\" },\n { SEVERITY_SUCC,  MSG_VERSION,\tPARAM_NONE,\t\"BFGMiner versions\" },\n { SEVERITY_ERR,   MSG_INVJSON,\tPARAM_NONE,\t\"Invalid JSON\" },\n { SEVERITY_ERR,   MSG_MISCMD,\tPARAM_CMD,\t\"Missing JSON '%s'\" },\n { SEVERITY_ERR,   MSG_MISPID,\tPARAM_NONE,\t\"Missing pool id parameter\" },\n { SEVERITY_ERR,   MSG_INVPID,\tPARAM_POOLMAX,\t\"Invalid pool id %d - range is 0 - %d\" },\n { SEVERITY_SUCC,  MSG_SWITCHP,\tPARAM_POOL,\t\"Switching to pool %d:'%s'\" },\n { SEVERITY_ERR,   MSG_MISVAL,\tPARAM_NONE,\t\"Missing comma after GPU number\" },\n { SEVERITY_ERR,   MSG_NOADL,\tPARAM_NONE,\t\"ADL is not available\" },\n { SEVERITY_ERR,   MSG_NOGPUADL,PARAM_GPU,\t\"GPU %d does not have ADL\" },\n { SEVERITY_ERR,   MSG_INVINT,\tPARAM_STR,\t\"Invalid intensity (%s) - must be '\" _DYNAMIC  \"' or range -10 - 31\" },\n { SEVERITY_INFO,  MSG_GPUINT,\tPARAM_BOTH,\t\"GPU %d set new intensity to %s\" },\n { SEVERITY_SUCC,  MSG_MINECONFIG,PARAM_NONE,\t\"BFGMiner config\" },\n#ifdef USE_OPENCL\n { SEVERITY_ERR,   MSG_GPUMERR,\tPARAM_BOTH,\t\"Setting GPU %d memoryclock to (%s) reported failure\" },\n { SEVERITY_SUCC,  MSG_GPUMEM,\tPARAM_BOTH,\t\"Setting GPU %d memoryclock to (%s) reported success\" },\n { SEVERITY_ERR,   MSG_GPUEERR,\tPARAM_BOTH,\t\"Setting GPU %d clock to (%s) reported failure\" },\n { SEVERITY_SUCC,  MSG_GPUENG,\tPARAM_BOTH,\t\"Setting GPU %d clock to (%s) reported success\" },\n { SEVERITY_ERR,   MSG_GPUVERR,\tPARAM_BOTH,\t\"Setting GPU %d vddc to (%s) reported failure\" },\n { SEVERITY_SUCC,  MSG_GPUVDDC,\tPARAM_BOTH,\t\"Setting GPU %d vddc to (%s) reported success\" },\n { SEVERITY_ERR,   MSG_GPUFERR,\tPARAM_BOTH,\t\"Setting GPU %d fan to (%s) reported failure\" },\n { SEVERITY_SUCC,  MSG_GPUFAN,\tPARAM_BOTH,\t\"Setting GPU %d fan to (%s) reported success\" },\n#endif\n { SEVERITY_ERR,   MSG_MISFN,\tPARAM_NONE,\t\"Missing save filename parameter\" },\n { SEVERITY_ERR,   MSG_BADFN,\tPARAM_STR,\t\"Can't open or create save file '%s'\" },\n { SEVERITY_SUCC,  MSG_SAVED,\tPARAM_STR,\t\"Configuration saved to file '%s'\" },\n { SEVERITY_ERR,   MSG_ACCDENY,\tPARAM_STR,\t\"Access denied to '%s' command\" },\n { SEVERITY_SUCC,  MSG_ACCOK,\tPARAM_NONE,\t\"Privileged access OK\" },\n { SEVERITY_SUCC,  MSG_ENAPOOL,\tPARAM_POOL,\t\"Enabling pool %d:'%s'\" },\n { SEVERITY_SUCC,  MSG_POOLPRIO,PARAM_NONE,\t\"Changed pool priorities\" },\n { SEVERITY_ERR,   MSG_DUPPID,\tPARAM_PID,\t\"Duplicate pool specified %d\" },\n { SEVERITY_SUCC,  MSG_DISPOOL,\tPARAM_POOL,\t\"Disabling pool %d:'%s'\" },\n { SEVERITY_INFO,  MSG_ALRENAP,\tPARAM_POOL,\t\"Pool %d:'%s' already enabled\" },\n { SEVERITY_INFO,  MSG_ALRDISP,\tPARAM_POOL,\t\"Pool %d:'%s' already disabled\" },\n { SEVERITY_ERR,   MSG_DISLASTP,PARAM_POOL,\t\"Cannot disable last active pool %d:'%s'\" },\n { SEVERITY_ERR,   MSG_MISPDP,\tPARAM_NONE,\t\"Missing addpool details\" },\n { SEVERITY_ERR,   MSG_INVPDP,\tPARAM_STR,\t\"Invalid addpool details '%s'\" },\n { SEVERITY_ERR,   MSG_TOOMANYP,PARAM_NONE,\t\"Reached maximum number of pools (%d)\" },\n { SEVERITY_SUCC,  MSG_ADDPOOL,\tPARAM_STR,\t\"Added pool '%s'\" },\n { SEVERITY_ERR,   MSG_REMLASTP,PARAM_POOL,\t\"Cannot remove last pool %d:'%s'\" },\n { SEVERITY_ERR,   MSG_ACTPOOL, PARAM_POOL,\t\"Cannot remove active pool %d:'%s'\" },\n { SEVERITY_SUCC,  MSG_REMPOOL, PARAM_BOTH,\t\"Removed pool %d:'%s'\" },\n { SEVERITY_SUCC,  MSG_NOTIFY,\tPARAM_NONE,\t\"Notify\" },\n { SEVERITY_SUCC,  MSG_DEVDETAILS,PARAM_NONE,\t\"Device Details\" },\n { SEVERITY_SUCC,  MSG_MINESTATS,PARAM_NONE,\t\"BFGMiner stats\" },\n { SEVERITY_ERR,   MSG_MISCHK,\tPARAM_NONE,\t\"Missing check cmd\" },\n { SEVERITY_SUCC,  MSG_CHECK,\tPARAM_NONE,\t\"Check command\" },\n { SEVERITY_ERR,   MSG_MISBOOL,\tPARAM_NONE,\t\"Missing parameter: true/false\" },\n { SEVERITY_ERR,   MSG_INVBOOL,\tPARAM_NONE,\t\"Invalid parameter should be true or false\" },\n { SEVERITY_SUCC,  MSG_FOO,\tPARAM_BOOL,\t\"Failover-Only set to %s\" },\n { SEVERITY_SUCC,  MSG_MINECOIN,PARAM_NONE,\t\"BFGMiner coin\" },\n { SEVERITY_SUCC,  MSG_DEBUGSET,PARAM_NONE,\t\"Debug settings\" },\n#ifdef HAVE_AN_FPGA\n { SEVERITY_SUCC,  MSG_PGAIDENT,PARAM_PGA,\t\"Identify command sent to PGA%d\" },\n { SEVERITY_WARN,  MSG_PGANOID,\tPARAM_PGA,\t\"PGA%d does not support identify\" },\n#endif\n { SEVERITY_SUCC,  MSG_SETCONFIG,PARAM_SET,\t\"Set config '%s' to %d\" },\n { SEVERITY_ERR,   MSG_UNKCON,\tPARAM_STR,\t\"Unknown config '%s'\" },\n { SEVERITY_ERR,   MSG_INVNUM,\tPARAM_BOTH,\t\"Invalid number (%d) for '%s' range is 0-9999\" },\n { SEVERITY_ERR,   MSG_INVNEG,\tPARAM_BOTH,\t\"Invalid negative number (%d) for '%s'\" },\n { SEVERITY_ERR,   MSG_INVSTRATEGY,\tPARAM_STR,\t\"Invalid strategy for '%s'\" },\n { SEVERITY_ERR,   MSG_FAILPORT,\tPARAM_BOTH,\t\"Failed to set port (%d) for '%s'\" },\n { SEVERITY_SUCC,  MSG_SETQUOTA,PARAM_SET,\t\"Set pool '%s' to quota %d'\" },\n { SEVERITY_ERR,   MSG_CONPAR,\tPARAM_NONE,\t\"Missing config parameters 'name,N'\" },\n { SEVERITY_ERR,   MSG_CONVAL,\tPARAM_STR,\t\"Missing config value N for '%s,N'\" },\n#ifdef HAVE_AN_FPGA\n { SEVERITY_ERR,   MSG_MISPGAOPT, PARAM_NONE,\t\"Missing option after PGA number\" },\n { SEVERITY_WARN,  MSG_PGANOSET, PARAM_PGA,\t\"PGA %d does not support pgaset\" },\n { SEVERITY_INFO,  MSG_PGAHELP, PARAM_BOTH,\t\"PGA %d set help: %s\" },\n { SEVERITY_SUCC,  MSG_PGASETOK, PARAM_PGA,\t\"PGA %d set OK\" },\n { SEVERITY_SUCC,  MSG_PGASETOK | USE_ALTMSG, PARAM_BOTH,\t\"PGA %d set OK: %s\" },\n { SEVERITY_ERR,   MSG_PGASETERR, PARAM_BOTH,\t\"PGA %d set failed: %s\" },\n#endif\n { SEVERITY_ERR,   MSG_ZERMIS,\tPARAM_NONE,\t\"Missing zero parameters\" },\n { SEVERITY_ERR,   MSG_ZERINV,\tPARAM_STR,\t\"Invalid zero parameter '%s'\" },\n { SEVERITY_SUCC,  MSG_ZERSUM,\tPARAM_STR,\t\"Zeroed %s stats with summary\" },\n { SEVERITY_SUCC,  MSG_ZERNOSUM, PARAM_STR,\t\"Zeroed %s stats without summary\" },\n { SEVERITY_SUCC,  MSG_DEVSCAN, PARAM_COUNT,\t\"Added %d new device(s)\" },\n { SEVERITY_SUCC,  MSG_BYE,\t\tPARAM_STR,\t\"%s\" },\n { SEVERITY_FAIL, 0, 0, NULL }\n};\n\nstatic const char *localaddr = \"127.0.0.1\";\n\nstatic int my_thr_id = 0;\nstatic bool bye;\n\n// Used to control quit restart access to shutdown variables\nstatic pthread_mutex_t quit_restart_lock;\n\nstatic bool do_a_quit;\nstatic bool do_a_restart;\n\nstatic time_t when = 0;\t// when the request occurred\nstatic bool per_proc;\n\nstruct IP4ACCESS {\n\tin_addr_t ip;\n\tin_addr_t mask;\n\tchar group;\n};\n\n#define GROUP(g) (toupper(g))\n#define PRIVGROUP GROUP('W')\n#define NOPRIVGROUP GROUP('R')\n#define ISPRIVGROUP(g) (GROUP(g) == PRIVGROUP)\n#define GROUPOFFSET(g) (GROUP(g) - GROUP('A'))\n#define VALIDGROUP(g) (GROUP(g) >= GROUP('A') && GROUP(g) <= GROUP('Z'))\n#define COMMANDS(g) (apigroups[GROUPOFFSET(g)].commands)\n#define DEFINEDGROUP(g) (ISPRIVGROUP(g) || COMMANDS(g) != NULL)\n\nstruct APIGROUPS {\n\t// This becomes a string like: \"|cmd1|cmd2|cmd3|\" so it's quick to search\n\tchar *commands;\n} apigroups['Z' - 'A' + 1]; // only A=0 to Z=25 (R: noprivs, W: allprivs)\n\nstatic struct IP4ACCESS *ipaccess = NULL;\nstatic int ips = 0;\n\nstruct io_data {\n\tbytes_t data;\n\tSOCKETTYPE sock;\n\t\n\t// Whether to add various things\n\tbool close;\n};\nstatic struct io_data *rpc_io_data;\n\nstatic void io_reinit(struct io_data *io_data)\n{\n\tbytes_reset(&io_data->data);\n\tio_data->close = false;\n}\n\nstatic\nstruct io_data *sock_io_new()\n{\n\tstruct io_data *io_data = malloc(sizeof(struct io_data));\n\tbytes_init(&io_data->data);\n\tio_data->sock = INVSOCK;\n\tio_reinit(io_data);\n\treturn io_data;\n}\n\nstatic\nsize_t io_flush(struct io_data *io_data, bool complete)\n{\n\tsize_t sent = 0, tosend = bytes_len(&io_data->data);\n\tssize_t n;\n\tstruct timeval timeout = {0, complete ? 50000: 0}, tv;\n\tfd_set wd;\n\tint count = 0;\n\t\n\twhile (tosend)\n\t{\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(io_data->sock, &wd);\n\t\ttv = timeout;\n\t\tif (select(io_data->sock + 1, NULL, &wd, NULL, &tv) < 1)\n\t\t\tbreak;\n\t\t\n\t\tn = send(io_data->sock, (void*)&bytes_buf(&io_data->data)[sent], tosend, 0);\n\t\tif (SOCKETFAIL(n))\n\t\t{\n\t\t\tif (!sock_blocks())\n\t\t\t\tapplog(LOG_WARNING, \"API: send (%lu) failed: %s\", (unsigned long)tosend, SOCKERRMSG);\n\t\t\tbreak;\n\t\t}\n\t\tif (count <= 1)\n\t\t{\n\t\t\tif (n == tosend)\n\t\t\t\tapplog(LOG_DEBUG, \"API: sent all of %lu first go\", (unsigned long)tosend);\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"API: sent %ld of %lu first go\", (long)n, (unsigned long)tosend);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (n == tosend)\n\t\t\t\tapplog(LOG_DEBUG, \"API: sent all of remaining %lu (count=%d)\", (unsigned long)tosend, count);\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"API: sent %ld of remaining %lu (count=%d)\", (long)n, (unsigned long)tosend, count);\n\t\t}\n\t\tsent += n;\n\t\ttosend -= n;\n\t}\n\t\n\tbytes_shift(&io_data->data, sent);\n\t\n\treturn sent;\n}\n\nstatic bool io_add(struct io_data *io_data, char *buf)\n{\n\tsize_t len = strlen(buf);\n\tif (bytes_len(&io_data->data) + len > RPC_SOCKBUFSIZ)\n\t\tio_flush(io_data, false);\n\tbytes_append(&io_data->data, buf, len);\n\treturn true;\n}\n\nstatic void io_close(struct io_data *io_data)\n{\n\tio_data->close = true;\n}\n\nstatic void io_free()\n{\n\tbytes_free(&rpc_io_data->data);\n\tfree(rpc_io_data);\n\trpc_io_data = NULL;\n}\n\n// This is only called when expected to be needed (rarely)\n// i.e. strings outside of the codes control (input from the user)\nstatic char *escape_string(char *str, bool isjson)\n{\n\tchar *buf, *ptr;\n\tint count;\n\n\tcount = 0;\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tswitch (*ptr) {\n\t\t\tcase ',':\n\t\t\tcase '|':\n\t\t\tcase '=':\n\t\t\t\tif (!isjson)\n\t\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tif (isjson)\n\t\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn str;\n\n\tbuf = malloc(strlen(str) + count + 1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc escape buf\");\n\n\tptr = buf;\n\twhile (*str)\n\t\tswitch (*str) {\n\t\t\tcase ',':\n\t\t\tcase '|':\n\t\t\tcase '=':\n\t\t\t\tif (!isjson)\n\t\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tif (isjson)\n\t\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t}\n\n\t*ptr = '\\0';\n\n\treturn buf;\n}\n\nstatic struct api_data *api_add_extra(struct api_data *root, struct api_data *extra)\n{\n\tstruct api_data *tmp;\n\n\tif (root) {\n\t\tif (extra) {\n\t\t\t// extra tail\n\t\t\ttmp = extra->prev;\n\n\t\t\t// extra prev = root tail\n\t\t\textra->prev = root->prev;\n\n\t\t\t// root tail next = extra\n\t\t\troot->prev->next = extra;\n\n\t\t\t// extra tail next = root\n\t\t\ttmp->next = root;\n\n\t\t\t// root prev = extra tail\n\t\t\troot->prev = tmp;\n\t\t}\n\t} else\n\t\troot = extra;\n\n\treturn root;\n}\n\nstatic\nstruct api_data *api_add_data_full(struct api_data *root, const char * const name, enum api_data_type type, const void *data, bool copy_data)\n{\n\tstruct api_data *api_data;\n\n\tapi_data = (struct api_data *)malloc(sizeof(struct api_data));\n\n\tapi_data->name = strdup(name);\n\tapi_data->type = type;\n\n\tif (root == NULL) {\n\t\troot = api_data;\n\t\troot->prev = root;\n\t\troot->next = root;\n\t}\n\telse {\n\t\tapi_data->prev = root->prev;\n\t\troot->prev = api_data;\n\t\tapi_data->next = root;\n\t\tapi_data->prev->next = api_data;\n\t}\n\n\tapi_data->data_was_malloc = copy_data;\n\n\t// Avoid crashing on bad data\n\tif (data == NULL) {\n\t\tapi_data->type = type = API_CONST;\n\t\tdata = NULLSTR;\n\t\tapi_data->data_was_malloc = copy_data = false;\n\t}\n\n\tif (!copy_data)\n\t{\n\t\tapi_data->data = data;\n\t\tif (type == API_JSON)\n\t\t\tjson_incref((json_t *)data);\n\t}\n\telse\n\t{\n\t\tsize_t datalen = 0;\n\t\tswitch(type) {\n\t\t\tcase API_ESCAPE:\n\t\t\tcase API_STRING:\n\t\t\tcase API_CONST:\n\t\t\t\tdatalen = strlen(data) + 1;\n\t\t\t\tbreak;\n\t\t\tcase API_UINT8:\n\t\t\t\tdatalen = sizeof(uint8_t);\n\t\t\t\tbreak;\n\t\t\tcase API_INT16:\n\t\t\t\tdatalen = sizeof(int16_t);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT16:\n\t\t\t\tdatalen = sizeof(uint16_t);\n\t\t\t\tbreak;\n\t\t\tcase API_INT:\n\t\t\t\tdatalen = sizeof(int);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT:\n\t\t\t\tdatalen = sizeof(unsigned int);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT32:\n\t\t\t\tdatalen = sizeof(uint32_t);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT64:\n\t\t\t\tdatalen = sizeof(uint64_t);\n\t\t\t\tbreak;\n\t\t\tcase API_DOUBLE:\n\t\t\tcase API_ELAPSED:\n\t\t\tcase API_MHS:\n\t\t\tcase API_MHTOTAL:\n\t\t\tcase API_UTILITY:\n\t\t\tcase API_FREQ:\n\t\t\tcase API_HS:\n\t\t\tcase API_DIFF:\n\t\t\tcase API_PERCENT:\n\t\t\t\tdatalen = sizeof(double);\n\t\t\t\tbreak;\n\t\t\tcase API_BOOL:\n\t\t\t\tdatalen = sizeof(bool);\n\t\t\t\tbreak;\n\t\t\tcase API_TIMEVAL:\n\t\t\t\tdatalen = sizeof(struct timeval);\n\t\t\t\tbreak;\n\t\t\tcase API_TIME:\n\t\t\t\tdatalen = sizeof(time_t);\n\t\t\t\tbreak;\n\t\t\tcase API_VOLTS:\n\t\t\tcase API_TEMP:\n\t\t\t\tdatalen = sizeof(float);\n\t\t\t\tbreak;\n\t\t\tcase API_JSON:\n\t\t\t\tapi_data->data_was_malloc = false;\n\t\t\t\tapi_data->data = json_deep_copy((json_t *)data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_ERR, \"API: unknown1 data type %d ignored\", type);\n\t\t\t\tapi_data->type = API_STRING;\n\t\t\t\tapi_data->data_was_malloc = false;\n\t\t\t\tapi_data->data = UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (datalen)\n\t\t{\n\t\t\tvoid * const copied_data = malloc(datalen);\n\t\t\tmemcpy(copied_data, data, datalen);\n\t\t\tapi_data->data = copied_data;\n\t\t}\n\t}\n\n\treturn root;\n}\n\nstruct api_data *api_add_escape(struct api_data * const root, const char * const name, const char * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_ESCAPE, data, copy_data);\n}\n\nstruct api_data *api_add_string(struct api_data * const root, const char * const name, const char * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_STRING, data, copy_data);\n}\n\nstruct api_data *api_add_const(struct api_data * const root, const char * const name, const char * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_CONST, data, copy_data);\n}\n\nstruct api_data *api_add_uint8(struct api_data * const root, const char * const name, const uint8_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UINT8, data, copy_data);\n}\n\nstruct api_data *api_add_int16(struct api_data * const root, const char * const name, const uint16_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_INT16, data, copy_data);\n}\n\nstruct api_data *api_add_uint16(struct api_data * const root, const char * const name, const uint16_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UINT16, data, copy_data);\n}\n\nstruct api_data *api_add_int(struct api_data * const root, const char * const name, const int * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_INT, data, copy_data);\n}\n\nstruct api_data *api_add_uint(struct api_data * const root, const char * const name, const unsigned int * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UINT, data, copy_data);\n}\n\nstruct api_data *api_add_uint32(struct api_data * const root, const char * const name, const uint32_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UINT32, data, copy_data);\n}\n\nstruct api_data *api_add_uint64(struct api_data * const root, const char * const name, const uint64_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UINT64, data, copy_data);\n}\n\nstruct api_data *api_add_double(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_DOUBLE, data, copy_data);\n}\n\nstruct api_data *api_add_elapsed(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_ELAPSED, data, copy_data);\n}\n\nstruct api_data *api_add_bool(struct api_data * const root, const char * const name, const bool * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_BOOL, data, copy_data);\n}\n\nstruct api_data *api_add_timeval(struct api_data * const root, const char * const name, const struct timeval * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_TIMEVAL, data, copy_data);\n}\n\nstruct api_data *api_add_time(struct api_data * const root, const char * const name, const time_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_TIME, data, copy_data);\n}\n\nstruct api_data *api_add_mhs(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_MHS, data, copy_data);\n}\n\nstruct api_data *api_add_mhtotal(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_MHTOTAL, data, copy_data);\n}\n\nstruct api_data *api_add_temp(struct api_data * const root, const char * const name, const float * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_TEMP, data, copy_data);\n}\n\nstruct api_data *api_add_utility(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_UTILITY, data, copy_data);\n}\n\nstruct api_data *api_add_freq(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_FREQ, data, copy_data);\n}\n\nstruct api_data *api_add_volts(struct api_data * const root, const char * const name, const float * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_VOLTS, data, copy_data);\n}\n\nstruct api_data *api_add_hs(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_HS, data, copy_data);\n}\n\nstruct api_data *api_add_diff(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_DIFF, data, copy_data);\n}\n\n// json_t is not const since we generally increase the refcount\nstruct api_data *api_add_json(struct api_data * const root, const char * const name, json_t * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_JSON, data, copy_data);\n}\n\nstruct api_data *api_add_percent(struct api_data * const root, const char * const name, const double * const data, const bool copy_data)\n{\n\treturn api_add_data_full(root, name, API_PERCENT, data, copy_data);\n}\n\nstatic struct api_data *print_data(struct api_data *root, char *buf, bool isjson, bool precom)\n{\n\tstruct api_data *tmp;\n\tbool first = true;\n\tchar *original, *escape;\n\tchar *quote;\n\n\t*buf = '\\0';\n\n\tif (precom) {\n\t\t*(buf++) = *COMMA;\n\t\t*buf = '\\0';\n\t}\n\n\tif (isjson) {\n\t\tstrcpy(buf, JSON0);\n\t\tbuf = strchr(buf, '\\0');\n\t\tquote = JSON1;\n\t} else\n\t\tquote = (char *)BLANK;\n\n\twhile (root) {\n\t\tif (!first)\n\t\t\t*(buf++) = *COMMA;\n\t\telse\n\t\t\tfirst = false;\n\n\t\tsprintf(buf, \"%s%s%s%s\", quote, root->name, quote, isjson ? \":\" : \"=\");\n\n\t\tbuf = strchr(buf, '\\0');\n\n\t\tswitch(root->type) {\n\t\t\tcase API_STRING:\n\t\t\tcase API_CONST:\n\t\t\t\tsprintf(buf, \"%s%s%s\", quote, (char *)(root->data), quote);\n\t\t\t\tbreak;\n\t\t\tcase API_ESCAPE:\n\t\t\t\toriginal = (char *)(root->data);\n\t\t\t\tescape = escape_string((char *)(root->data), isjson);\n\t\t\t\tsprintf(buf, \"%s%s%s\", quote, escape, quote);\n\t\t\t\tif (escape != original)\n\t\t\t\t\tfree(escape);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT8:\n\t\t\t\tsprintf(buf, \"%u\", *(uint8_t *)root->data);\n\t\t\t\tbreak;\n\t\t\tcase API_INT16:\n\t\t\t\tsprintf(buf, \"%d\", *(int16_t *)root->data);\n\t\t\t\tbreak;\n\t\t\tcase API_UINT16:\n\t\t\t\tsprintf(buf, \"%u\", *(uint16_t *)root->data);\n\t\t\t\tbreak;\n\t\t\tcase API_INT:\n\t\t\t\tsprintf(buf, \"%d\", *((int *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_UINT:\n\t\t\t\tsprintf(buf, \"%u\", *((unsigned int *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_UINT32:\n\t\t\t\tsprintf(buf, \"%\"PRIu32, *((uint32_t *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_UINT64:\n\t\t\t\tsprintf(buf, \"%\"PRIu64, *((uint64_t *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_TIME:\n\t\t\t\tsprintf(buf, \"%lu\", *((unsigned long *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_DOUBLE:\n\t\t\t\tsprintf(buf, \"%f\", *((double *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_ELAPSED:\n\t\t\t\tsprintf(buf, \"%.0f\", *((double *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_UTILITY:\n\t\t\tcase API_FREQ:\n\t\t\tcase API_MHS:\n\t\t\t\tsprintf(buf, \"%.3f\", *((double *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_VOLTS:\n\t\t\t\tsprintf(buf, \"%.3f\", *((float *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_MHTOTAL:\n\t\t\t\tsprintf(buf, \"%.4f\", *((double *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_HS:\n\t\t\t\tsprintf(buf, \"%.15f\", *((double *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_DIFF:\n\t\t\t{\n\t\t\t\tconst double *fp = root->data;\n\t\t\t\tif (fmod(*fp, 1.))\n\t\t\t\t\tsprintf(buf, \"%.8f\", *fp);\n\t\t\t\telse\n\t\t\t\t\tsprintf(buf, \"%.0f\", *fp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase API_BOOL:\n\t\t\t\tsprintf(buf, \"%s\", *((bool *)(root->data)) ? TRUESTR : FALSESTR);\n\t\t\t\tbreak;\n\t\t\tcase API_TIMEVAL:\n\t\t\t\tsprintf(buf, \"%\"PRIu64\".%06lu\",\n\t\t\t\t\t(uint64_t)((struct timeval *)(root->data))->tv_sec,\n\t\t\t\t\t(unsigned long)((struct timeval *)(root->data))->tv_usec);\n\t\t\t\tbreak;\n\t\t\tcase API_TEMP:\n\t\t\t\tsprintf(buf, \"%.2f\", *((float *)(root->data)));\n\t\t\t\tbreak;\n\t\t\tcase API_JSON:\n\t\t\t\tescape = json_dumps((json_t *)(root->data), JSON_COMPACT);\n\t\t\t\tstrcpy(buf, escape);\n\t\t\t\tfree(escape);\n\t\t\t\tbreak;\n\t\t\tcase API_PERCENT:\n\t\t\t\tsprintf(buf, \"%.4f\", *((double *)(root->data)) * 100.0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_ERR, \"API: unknown2 data type %d ignored\", root->type);\n\t\t\t\tsprintf(buf, \"%s%s%s\", quote, UNKNOWN, quote);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbuf = strchr(buf, '\\0');\n\n\t\tfree(root->name);\n\t\tif (root->type == API_JSON)\n\t\t\tjson_decref((json_t *)root->data);\n\t\tif (root->data_was_malloc)\n\t\t\tfree((void*)root->data);\n\n\t\tif (root->next == root) {\n\t\t\tfree(root);\n\t\t\troot = NULL;\n\t\t} else {\n\t\t\ttmp = root;\n\t\t\troot = tmp->next;\n\t\t\troot->prev = tmp->prev;\n\t\t\troot->prev->next = root;\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tstrcpy(buf, isjson ? JSON5 : SEPSTR);\n\n\treturn root;\n}\n\n#ifdef HAVE_AN_FPGA\nstatic int numpgas()\n{\n\tint count = 0;\n\tint i;\n\n\trd_lock(&devices_lock);\n\tfor (i = 0; i < total_devices; i++) {\n\t\tif (devices[i]->device != devices[i] && !per_proc)\n\t\t\tcontinue;\n\t\t++count;\n\t}\n\trd_unlock(&devices_lock);\n\treturn count;\n}\n\nstatic int pgadevice(int pgaid)\n{\n\tint count = 0;\n\tint i;\n\n\trd_lock(&devices_lock);\n\tfor (i = 0; i < total_devices; i++) {\n\t\tif (devices[i]->device != devices[i] && !per_proc)\n\t\t\tcontinue;\n\t\t++count;\n\t\tif (count == (pgaid + 1))\n\t\t\tgoto foundit;\n\t}\n\n\trd_unlock(&devices_lock);\n\treturn -1;\n\nfoundit:\n\n\trd_unlock(&devices_lock);\n\treturn i;\n}\n#endif\n\n// All replies (except BYE and RESTART) start with a message\n//  thus for JSON, message() inserts JSON_START at the front\n//  and send_result() adds JSON_END at the end\nstatic void message(struct io_data * const io_data, const int messageid2, const int paramid, const char * const param2, const bool isjson)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tchar buf2[TMPBUFSIZ];\n\tchar severity[2];\n#ifdef HAVE_AN_FPGA\n\tint pga;\n#endif\n#ifdef USE_CPUMINING\n\tint cpu;\n#endif\n\tint i;\n\tint messageid = messageid2 & ~USE_ALTMSG;\n\n\tif (isjson)\n\t\tio_add(io_data, JSON_START JSON_STATUS);\n\n\tfor (i = 0; codes[i].severity != SEVERITY_FAIL; i++) {\n\t\tif (codes[i].code == messageid2) {\n\t\t\tswitch (codes[i].severity) {\n\t\t\t\tcase SEVERITY_WARN:\n\t\t\t\t\tseverity[0] = 'W';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_INFO:\n\t\t\t\t\tseverity[0] = 'I';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_SUCC:\n\t\t\t\t\tseverity[0] = 'S';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_ERR:\n\t\t\t\tdefault:\n\t\t\t\t\tseverity[0] = 'E';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseverity[1] = '\\0';\n\n\t\t\tswitch(codes[i].params) {\n\t\t\t\tcase PARAM_COUNT:\n\t\t\t\tcase PARAM_GPU:\n\t\t\t\tcase PARAM_PGA:\n\t\t\t\tcase PARAM_CPU:\n\t\t\t\tcase PARAM_PID:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_POOL:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, pools[paramid]->rpc_url);\n\t\t\t\t\tbreak;\n#ifdef USE_OPENCL\n\t\t\t\tcase PARAM_GPUMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, nDevs - 1);\n\t\t\t\t\tbreak;\n#endif\n#ifdef HAVE_AN_FPGA\n\t\t\t\tcase PARAM_PGAMAX:\n\t\t\t\t\tpga = numpgas();\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, pga - 1);\n\t\t\t\t\tbreak;\n#endif\n#ifdef USE_CPUMINING\n\t\t\t\tcase PARAM_CPUMAX:\n\t\t\t\t\tif (opt_n_threads > 0)\n\t\t\t\t\t\tcpu = num_processors;\n\t\t\t\t\telse\n\t\t\t\t\t\tcpu = 0;\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, cpu - 1);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase PARAM_PMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, total_pools);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_POOLMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, total_pools - 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_DMAX:\n\t\t\t\t\tpga = numpgas();\n\n\t\t\t\t\tsprintf(buf, codes[i].description\n\t\t\t\t\t\t, pga\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_CMD:\n\t\t\t\t\tsprintf(buf, codes[i].description, JSON_COMMAND);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_STR:\n\t\t\t\t\tsprintf(buf, codes[i].description, param2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOTH:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, param2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOOL:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid ? TRUESTR : FALSESTR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_SET:\n\t\t\t\t\tsprintf(buf, codes[i].description, param2, paramid);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(buf, codes[i].description);\n\t\t\t}\n\n\t\t\troot = api_add_string(root, _STATUS, severity, false);\n\t\t\troot = api_add_time(root, \"When\", &when, false);\n\t\t\troot = api_add_int(root, \"Code\", &messageid, false);\n\t\t\troot = api_add_escape(root, \"Msg\", buf, false);\n\t\t\troot = api_add_escape(root, \"Description\", opt_api_description, false);\n\n\t\t\troot = print_data(root, buf2, isjson, false);\n\t\t\tio_add(io_data, buf2);\n\t\t\tif (isjson)\n\t\t\t\tio_add(io_data, JSON_CLOSE);\n\t\t\treturn;\n\t\t}\n\t}\n\n\troot = api_add_string(root, _STATUS, \"F\", false);\n\troot = api_add_time(root, \"When\", &when, false);\n\tint id = -1;\n\troot = api_add_int(root, \"Code\", &id, false);\n\tsprintf(buf, \"%d\", messageid);\n\troot = api_add_escape(root, \"Msg\", buf, false);\n\troot = api_add_escape(root, \"Description\", opt_api_description, false);\n\n\troot = print_data(root, buf2, isjson, false);\n\tio_add(io_data, buf2);\n\tif (isjson)\n\t\tio_add(io_data, JSON_CLOSE);\n}\n\nstatic void apiversion(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\n\tmessage(io_data, MSG_VERSION, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_VERSION : _VERSION COMSTR);\n\n\troot = api_add_string(root, \"Miner\", bfgminer_name_space_ver, false);\n\troot = api_add_string(root, \"CGMiner\", bfgminer_ver, false);\n\troot = api_add_const(root, \"API\", APIVERSION, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void minerconfig(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tstruct driver_registration *reg;\n\tint pgacount = 0;\n\tchar *adlinuse = (char *)NO;\n\tint i;\n#ifdef HAVE_ADL\n\tconst char *adl = YES;\n\n\tfor (i = 0; i < nDevs; i++) {\n\t\tstruct opencl_device_data * const data = gpus[i].device_data;\n\t\tif (data->has_adl) {\n\t\t\tadlinuse = (char *)YES;\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\tconst char *adl = NO;\n#endif\n\n#ifdef HAVE_AN_FPGA\n\tpgacount = numpgas();\n#endif\n\n\tmessage(io_data, MSG_MINECONFIG, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_MINECONFIG : _MINECONFIG COMSTR);\n\n\troot = api_add_int(root, \"PGA Count\", &pgacount, false);\n\troot = api_add_int(root, \"Pool Count\", &total_pools, false);\n\troot = api_add_const(root, \"ADL\", (char *)adl, false);\n\troot = api_add_string(root, \"ADL in use\", adlinuse, false);\n\troot = api_add_const(root, \"Strategy\", strategies[pool_strategy].s, false);\n\tif (pool_strategy == POOL_ROTATE)\n\t\troot = api_add_int(root, \"Rotate Period\", &opt_rotate_period, false);\n\troot = api_add_int(root, \"Log Interval\", &opt_log_interval, false);\n\t\n\tstrcpy(buf, \"\"\n#ifdef USE_LIBMICROHTTPD\n\t\t\t\" SGW\"\n#endif\n#ifdef USE_LIBEVENT\n\t\t\t\" SSM\"\n#endif\n\t);\n\n\tBFG_FOREACH_DRIVER_BY_DNAME(reg)\n\t{\n\t\tconst struct device_drv * const drv = reg->drv;\n\t\ttailsprintf(buf, sizeof(buf), \" %s\", drv->name);\n\t}\n\troot = api_add_const(root, \"Device Code\", &buf[1], true);\n\t\n\troot = api_add_const(root, \"OS\", OSINFO, false);\n\troot = api_add_bool(root, \"Failover-Only\", &opt_fail_only, false);\n\troot = api_add_int(root, \"ScanTime\", &opt_scantime, false);\n\troot = api_add_int(root, \"Queue\", &opt_queue, false);\n\troot = api_add_int(root, \"Expiry\", &opt_expiry, false);\n#if BLKMAKER_VERSION > 0\n\troot = api_add_string(root, \"Coinbase-Sig\", opt_coinbase_sig, true);\n#endif\n\t\n\tstruct bfg_loaded_configfile *configfile;\n\ti = 0;\n\tLL_FOREACH(bfg_loaded_configfiles, configfile)\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"ConfigFile%d\", i++);\n\t\troot = api_add_string(root, buf, configfile->filename, false);\n\t}\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic const char*\nbool2str(bool b)\n{\n\treturn b ? YES : NO;\n}\n\nstatic const char *status2str(enum alive status)\n{\n\tswitch (status) {\n\t\tcase LIFE_WELL:\n\t\t\treturn ALIVE;\n\t\tcase LIFE_SICK:\n\t\t\treturn SICK;\n\t\tcase LIFE_DEAD:\n\t\tcase LIFE_DEAD2:\n\t\t\treturn DEAD;\n\t\tcase LIFE_NOSTART:\n\t\t\treturn NOSTART;\n\t\tcase LIFE_INIT:\n\t\tcase LIFE_INIT2:\n\t\t\treturn INIT;\n\t\tcase LIFE_WAIT:\n\t\t\treturn WAIT;\n\t\tcase LIFE_MIXED:\n\t\t\treturn \"Mixed\";\n\t\tdefault:\n\t\t\treturn UNKNOWN;\n\t}\n}\n\nstatic\nstruct api_data *api_add_device_identifier(struct api_data *root, struct cgpu_info *cgpu)\n{\n\troot = api_add_string(root, \"Name\", cgpu->drv->name, false);\n\troot = api_add_int(root, \"ID\", &(cgpu->device_id), false);\n\tif (per_proc)\n\t\troot = api_add_int(root, \"ProcID\", &(cgpu->proc_id), false);\n\treturn root;\n}\n\nstatic\nint find_index_by_cgpu(struct cgpu_info *cgpu)\n{\n\tif (per_proc)\n\t\treturn cgpu->cgminer_id;\n\t\n\tint n = 0, i;\n\t\n\t// Quickly traverse the devices array backward until we reach the 0th device, counting as we go\n\trd_lock(&devices_lock);\n\twhile (true)\n\t{\n\t\ti = cgpu->device->cgminer_id;\n\t\tif (!i)\n\t\t\tbreak;\n\t\tcgpu = devices[--i];\n\t\t++n;\n\t}\n\trd_unlock(&devices_lock);\n\treturn n;\n}\n\nstatic void devdetail_an(struct io_data *io_data, struct cgpu_info *cgpu, bool isjson, bool precom)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tint n;\n\n\tcgpu_utility(cgpu);\n\n\tn = find_index_by_cgpu(cgpu);\n\n\troot = api_add_int(root, \"DEVDETAILS\", &n, true);\n\troot = api_add_device_identifier(root, cgpu);\n\tif (!per_proc)\n\t\troot = api_add_int(root, \"Processors\", &cgpu->procs, false);\n\troot = api_add_string(root, \"Driver\", cgpu->drv->dname, false);\n\tif (cgpu->kname)\n\t\troot = api_add_string(root, \"Kernel\", cgpu->kname, false);\n\tif (cgpu->name)\n\t\troot = api_add_string(root, \"Model\", cgpu->name, false);\n\tif (cgpu->dev_manufacturer)\n\t\troot = api_add_string(root, \"Manufacturer\", cgpu->dev_manufacturer, false);\n\tif (cgpu->dev_product)\n\t\troot = api_add_string(root, \"Product\", cgpu->dev_product, false);\n\tif (cgpu->dev_serial)\n\t\troot = api_add_string(root, \"Serial\", cgpu->dev_serial, false);\n\tif (cgpu->device_path)\n\t\troot = api_add_string(root, \"Device Path\", cgpu->device_path, false);\n\t\n\troot = api_add_int(root, \"Target Temperature\", &cgpu->targettemp, false);\n\troot = api_add_int(root, \"Cutoff Temperature\", &cgpu->cutofftemp, false);\n\n\tif ((per_proc || cgpu->procs <= 1) && cgpu->drv->get_api_extra_device_detail)\n\t\troot = api_add_extra(root, cgpu->drv->get_api_extra_device_detail(cgpu));\n\n\troot = print_data(root, buf, isjson, precom);\n\tio_add(io_data, buf);\n}\n\nstatic\nvoid devstatus_an(struct io_data *io_data, struct cgpu_info *cgpu, bool isjson, bool precom)\n{\n\tstruct cgpu_info *proc;\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tint n;\n\n\tn = find_index_by_cgpu(cgpu);\n\n\tdouble runtime = cgpu_runtime(cgpu);\n\tbool enabled = false;\n\tdouble total_mhashes = 0, rolling = 0, utility = 0;\n\tenum alive status = cgpu->status;\n\tfloat temp = -1;\n\tint accepted = 0, rejected = 0, stale = 0, hw_errors = 0;\n\tdouble diff1 = 0, bad_diff1 = 0;\n\tdouble diff_accepted = 0, diff_rejected = 0, diff_stale = 0;\n\tint last_share_pool = -1;\n\ttime_t last_share_pool_time = -1, last_device_valid_work = -1;\n\tdouble last_share_diff = -1;\n\tint procs = per_proc ? 1 : cgpu->procs, i;\n\tfor (i = 0, proc = cgpu; i < procs; ++i, proc = proc->next_proc)\n\t{\n\t\tcgpu_utility(proc);\n\t\tif (proc->deven != DEV_DISABLED)\n\t\t\tenabled = true;\n\t\ttotal_mhashes += proc->total_mhashes;\n\t\trolling += proc->drv->get_proc_rolling_hashrate ? proc->drv->get_proc_rolling_hashrate(proc) : proc->rolling;\n\t\tutility += proc->utility;\n\t\taccepted += proc->accepted;\n\t\trejected += proc->rejected;\n\t\tstale += proc->stale;\n\t\thw_errors += proc->hw_errors;\n\t\tdiff1 += proc->diff1;\n\t\tdiff_accepted += proc->diff_accepted;\n\t\tdiff_rejected += proc->diff_rejected;\n\t\tdiff_stale += proc->diff_stale;\n\t\tbad_diff1 += proc->bad_diff1;\n\t\tif (status != proc->status)\n\t\t\tstatus = LIFE_MIXED;\n\t\tif (proc->temp > temp)\n\t\t\ttemp = proc->temp;\n\t\tif (proc->last_share_pool_time > last_share_pool_time)\n\t\t{\n\t\t\tlast_share_pool_time = proc->last_share_pool_time;\n\t\t\tlast_share_pool = proc->last_share_pool;\n\t\t\tlast_share_diff = proc->last_share_diff;\n\t\t}\n\t\tif (proc->last_device_valid_work > last_device_valid_work)\n\t\t\tlast_device_valid_work = proc->last_device_valid_work;\n\t\tif (per_proc)\n\t\t\tbreak;\n\t}\n\n\troot = api_add_int(root, \"PGA\", &n, true);\n\troot = api_add_device_identifier(root, cgpu);\n\troot = api_add_string(root, \"Enabled\", bool2str(enabled), false);\n\troot = api_add_string(root, \"Status\", status2str(status), false);\n\tif (temp > 0)\n\t\troot = api_add_temp(root, \"Temperature\", &temp, false);\n\t\n\troot = api_add_elapsed(root, \"Device Elapsed\", &runtime, false);\n\tdouble mhs = total_mhashes / runtime;\n\troot = api_add_mhs(root, \"MHS av\", &mhs, false);\n\tchar mhsname[27];\n\tsprintf(mhsname, \"MHS %ds\", opt_log_interval);\n\troot = api_add_mhs(root, mhsname, &rolling, false);\n\troot = api_add_mhs(root, \"MHS rolling\", &rolling, false);\n\troot = api_add_int(root, \"Accepted\", &accepted, false);\n\troot = api_add_int(root, \"Rejected\", &rejected, false);\n\troot = api_add_int(root, \"Hardware Errors\", &hw_errors, false);\n\troot = api_add_utility(root, \"Utility\", &utility, false);\n\troot = api_add_int(root, \"Stale\", &stale, false);\n\tif (last_share_pool != -1)\n\t{\n\t\troot = api_add_int(root, \"Last Share Pool\", &last_share_pool, false);\n\t\troot = api_add_time(root, \"Last Share Time\", &last_share_pool_time, false);\n\t}\n\troot = api_add_mhtotal(root, \"Total MH\", &total_mhashes, false);\n\tdouble work_utility = diff1 / runtime * 60;\n\troot = api_add_diff(root, \"Diff1 Work\", &diff1, false);\n\troot = api_add_utility(root, \"Work Utility\", &work_utility, false);\n\troot = api_add_diff(root, \"Difficulty Accepted\", &diff_accepted, false);\n\troot = api_add_diff(root, \"Difficulty Rejected\", &diff_rejected, false);\n\troot = api_add_diff(root, \"Difficulty Stale\", &diff_stale, false);\n\tif (last_share_diff > 0)\n\t\troot = api_add_diff(root, \"Last Share Difficulty\", &last_share_diff, false);\n\tif (last_device_valid_work != -1)\n\t\troot = api_add_time(root, \"Last Valid Work\", &last_device_valid_work, false);\n\tdouble hwp = (bad_diff1 + diff1) ?\n\t\t\t(double)(bad_diff1) / (double)(bad_diff1 + diff1) : 0;\n\troot = api_add_percent(root, \"Device Hardware%\", &hwp, false);\n\tdouble rejp = diff1 ?\n\t\t\t(double)(diff_rejected) / (double)(diff1) : 0;\n\troot = api_add_percent(root, \"Device Rejected%\", &rejp, false);\n\n\tif ((per_proc || cgpu->procs <= 1) && cgpu->drv->get_api_extra_device_status)\n\t\troot = api_add_extra(root, cgpu->drv->get_api_extra_device_status(cgpu));\n\n\troot = print_data(root, buf, isjson, precom);\n\tio_add(io_data, buf);\n}\n\n#ifdef USE_OPENCL\nstatic void gpustatus(struct io_data *io_data, int gpu, bool isjson, bool precom)\n{\n        if (gpu < 0 || gpu >= nDevs)\n                return;\n        devstatus_an(io_data, &gpus[gpu], isjson, precom);\n}\n#endif\n\n#ifdef HAVE_AN_FPGA\nstatic void pgastatus(struct io_data *io_data, int pga, bool isjson, bool precom)\n{\n        int dev = pgadevice(pga);\n        if (dev < 0) // Should never happen\n                return;\n        devstatus_an(io_data, get_devices(dev), isjson, precom);\n}\n#endif\n\n#ifdef USE_CPUMINING\nstatic void cpustatus(struct io_data *io_data, int cpu, bool isjson, bool precom)\n{\n        if (opt_n_threads <= 0 || cpu < 0 || cpu >= num_processors)\n                return;\n        devstatus_an(io_data, &cpus[cpu], isjson, precom);\n}\n#endif\n\nstatic void\ndevinfo_internal(void (*func)(struct io_data *, struct cgpu_info*, bool, bool), int msg, struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu;\n\tbool io_open = false;\n\tint i;\n\n\tif (total_devices == 0) {\n\t\tmessage(io_data, MSG_NODEVS, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\n\tmessage(io_data, msg, 0, NULL, isjson);\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_DEVS);\n\n\tfor (i = 0; i < total_devices; ++i) {\n\t\tcgpu = get_devices(i);\n\t\tif (per_proc || cgpu->device == cgpu)\n\t\t\tfunc(io_data, cgpu, isjson, isjson && i > 0);\n\t}\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void devdetail(struct io_data *io_data, SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\treturn devinfo_internal(devdetail_an, MSG_DEVDETAILS, io_data, c, param, isjson, group);\n}\n\nstatic void devstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\treturn devinfo_internal(devstatus_an, MSG_DEVS, io_data, c, param, isjson, group);\n}\n\n#ifdef USE_OPENCL\nstatic void gpudev(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tbool io_open = false;\n\tint id;\n\n\tif (nDevs == 0) {\n\t\tmessage(io_data, MSG_GPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= nDevs) {\n\t\tmessage(io_data, MSG_INVGPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_GPUDEV, id, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_GPU);\n\n\tgpustatus(io_data, id, isjson, false);\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n#endif\n\nstatic void devscan(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tint n;\n\tbool io_open = false;\n\t\n\tapplog(LOG_DEBUG, \"RPC: request to scan %s for devices\",\n\t       param);\n\t\n\tif (param && !param[0])\n\t\tparam = NULL;\n\t\n\tn = scan_serial(param);\n\t\n\tmessage(io_data, MSG_DEVSCAN, n, NULL, isjson);\n\t\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_DEVS : _DEVS COMSTR);\n\n\tn = total_devices - n;\n\tfor (int i = n; i < total_devices; ++i)\n\t\tdevdetail_an(io_data, get_devices(i), isjson, i > n);\n\t\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\n#ifdef HAVE_AN_FPGA\nstatic\nstruct cgpu_info *get_pga_cgpu(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group, int *id_p, int *dev_p)\n{\n\tint numpga = numpgas();\n\t\n\tif (numpga == 0) {\n\t\tmessage(io_data, MSG_PGANON, 0, NULL, isjson);\n\t\treturn NULL;\n\t}\n\t\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn NULL;\n\t}\n\t\n\t*id_p = atoi(param);\n\tif (*id_p < 0 || *id_p >= numpga) {\n\t\tmessage(io_data, MSG_INVPGA, *id_p, NULL, isjson);\n\t\treturn NULL;\n\t}\n\t\n\t*dev_p = pgadevice(*id_p);\n\tif (*dev_p < 0) { // Should never happen\n\t\tmessage(io_data, MSG_INVPGA, *id_p, NULL, isjson);\n\t\treturn NULL;\n\t}\n\t\n\treturn get_devices(*dev_p);\n}\n\nstatic void pgadev(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tbool io_open = false;\n\tint id, dev;\n\n\tif (!get_pga_cgpu(io_data, c, param, isjson, group, &id, &dev))\n\t\treturn;\n\t\n\tmessage(io_data, MSG_PGADEV, id, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_PGA);\n\n\tpgastatus(io_data, id, isjson, false);\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void pgaenable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu, *proc;\n\tint id, dev;\n\tbool already;\n\n\tcgpu = get_pga_cgpu(io_data, c, param, isjson, group, &id, &dev);\n\tif (!cgpu)\n\t\treturn;\n\t\n\tapplog(LOG_DEBUG, \"API: request to pgaenable %s id %d device %d %s\",\n\t\t\tper_proc ? \"proc\" : \"dev\", id, dev, cgpu->proc_repr_ns);\n\n\talready = true;\n\tint procs = per_proc ? 1 : cgpu->procs, i;\n\tfor (i = 0, proc = cgpu; i < procs; ++i, proc = proc->next_proc)\n\t{\n\t\tif (proc->deven == DEV_DISABLED)\n\t\t{\n\t\t\tproc_enable(proc);\n\t\t\talready = false;\n\t\t}\n\t}\n\t\n\tif (already)\n\t{\n\t\tmessage(io_data, MSG_PGALRENA, id, NULL, isjson);\n\t\treturn;\n\t}\n\n#if 0 /* A DISABLED device wont change status FIXME: should disabling make it WELL? */\n\tif (cgpu->status != LIFE_WELL) {\n\t\tmessage(io_data, MSG_PGAUNW, id, NULL, isjson);\n\t\treturn;\n\t}\n#endif\n\n\tmessage(io_data, MSG_PGAENA, id, NULL, isjson);\n}\n\nstatic void pgadisable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu, *proc;\n\tint id, dev;\n\tbool already;\n\n\tcgpu = get_pga_cgpu(io_data, c, param, isjson, group, &id, &dev);\n\tif (!cgpu)\n\t\treturn;\n\t\n\tapplog(LOG_DEBUG, \"API: request to pgadisable %s id %d device %d %s\",\n\t\t\tper_proc ? \"proc\" : \"dev\", id, dev, cgpu->proc_repr_ns);\n\n\talready = true;\n\tint procs = per_proc ? 1 : cgpu->procs, i;\n\tfor (i = 0, proc = cgpu; i < procs; ++i, proc = proc->next_proc)\n\t{\n\t\tif (proc->deven != DEV_DISABLED)\n\t\t{\n\t\t\tcgpu->deven = DEV_DISABLED;\n\t\t\talready = false;\n\t\t}\n\t}\n\t\n\tif (already)\n\t{\n\t\tmessage(io_data, MSG_PGALRDIS, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_PGADIS, id, NULL, isjson);\n}\n\nstatic void pgarestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu;\n\tint id, dev;\n\t\n\tcgpu = get_pga_cgpu(io_data, c, param, isjson, group, &id, &dev);\n\tif (!cgpu)\n\t\treturn;\n\t\n\tapplog(LOG_DEBUG, \"API: request to pgarestart dev id %d device %d %s\",\n\t\t\tid, dev, cgpu->dev_repr);\n\t\n\treinit_device(cgpu);\n\t\n\tmessage(io_data, MSG_PGAREI, id, NULL, isjson);\n}\n\nstatic void pgaidentify(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu;\n\tstruct device_drv *drv;\n\tint id, dev;\n\n\tcgpu = get_pga_cgpu(io_data, c, param, isjson, group, &id, &dev);\n\tif (!cgpu)\n\t\treturn;\n\t\n\tdrv = cgpu->drv;\n\n\tif (drv->identify_device && drv->identify_device(cgpu))\n\t\tmessage(io_data, MSG_PGAIDENT, id, NULL, isjson);\n\telse\n\t\tmessage(io_data, MSG_PGANOID, id, NULL, isjson);\n}\n#endif\n\n#ifdef USE_CPUMINING\nstatic void cpudev(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tbool io_open = false;\n\tint id;\n\n\tif (opt_n_threads <= 0)\n\t{\n\t\tmessage(io_data, MSG_CPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= num_processors) {\n\t\tmessage(io_data, MSG_INVCPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_CPUDEV, id, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_CPU);\n\n\tcpustatus(io_data, id, isjson, false);\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n#endif\n\nstatic void poolstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open = false;\n\tchar *status, *lp;\n\tint i;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_POOL, 0, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_POOLS);\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tif (pool->removed)\n\t\t\tcontinue;\n\n\t\tswitch (pool->enabled) {\n\t\t\tcase POOL_DISABLED:\n\t\t\t\tstatus = (char *)DISABLED;\n\t\t\t\tbreak;\n\t\t\tcase POOL_REJECTING:\n\t\t\t\tstatus = (char *)REJECTING;\n\t\t\t\tbreak;\n\t\t\tcase POOL_ENABLED:\n\t\t\t\tif (pool->idle)\n\t\t\t\t\tstatus = (char *)DEAD;\n\t\t\t\telse\n\t\t\t\tif (pool->failover_only)\n\t\t\t\t\tstatus = \"Failover\";\n\t\t\t\telse\n\t\t\t\t\tstatus = (char *)ALIVE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstatus = (char *)UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (pool->hdr_path)\n\t\t\tlp = (char *)YES;\n\t\telse\n\t\t\tlp = (char *)NO;\n\n\t\troot = api_add_int(root, \"POOL\", &i, false);\n\t\troot = api_add_escape(root, \"URL\", pool->rpc_url, false);\n\t\troot = api_add_string(root, \"Status\", status, false);\n\t\troot = api_add_int(root, \"Priority\", &(pool->prio), false);\n\t\troot = api_add_int(root, \"Quota\", &pool->quota, false);\n\t\troot = api_add_string(root, \"Mining Goal\", pool->goal->name, false);\n\t\troot = api_add_string(root, \"Long Poll\", lp, false);\n\t\troot = api_add_uint(root, \"Getworks\", &(pool->getwork_requested), false);\n\t\troot = api_add_int(root, \"Accepted\", &(pool->accepted), false);\n\t\troot = api_add_int(root, \"Rejected\", &(pool->rejected), false);\n\t\troot = api_add_int(root, \"Works\", &pool->works, false);\n\t\troot = api_add_uint(root, \"Discarded\", &(pool->discarded_work), false);\n\t\troot = api_add_uint(root, \"Stale\", &(pool->stale_shares), false);\n\t\troot = api_add_uint(root, \"Get Failures\", &(pool->getfail_occasions), false);\n\t\troot = api_add_uint(root, \"Remote Failures\", &(pool->remotefail_occasions), false);\n\t\troot = api_add_escape(root, \"User\", pool->rpc_user, false);\n\t\troot = api_add_time(root, \"Last Share Time\", &(pool->last_share_time), false);\n\t\troot = api_add_diff(root, \"Diff1 Shares\", &(pool->diff1), false);\n\t\tif (pool->rpc_proxy) {\n\t\t\troot = api_add_escape(root, \"Proxy\", pool->rpc_proxy, false);\n\t\t} else {\n\t\t\troot = api_add_const(root, \"Proxy\", BLANK, false);\n\t\t}\n\t\troot = api_add_diff(root, \"Difficulty Accepted\", &(pool->diff_accepted), false);\n\t\troot = api_add_diff(root, \"Difficulty Rejected\", &(pool->diff_rejected), false);\n\t\troot = api_add_diff(root, \"Difficulty Stale\", &(pool->diff_stale), false);\n\t\troot = api_add_diff(root, \"Last Share Difficulty\", &(pool->last_share_diff), false);\n\t\troot = api_add_bool(root, \"Has Stratum\", &(pool->has_stratum), false);\n\t\troot = api_add_bool(root, \"Stratum Active\", &(pool->stratum_active), false);\n\t\tif (pool->stratum_active)\n\t\t\troot = api_add_escape(root, \"Stratum URL\", pool->stratum_url, false);\n\t\telse\n\t\t\troot = api_add_const(root, \"Stratum URL\", BLANK, false);\n\t\troot = api_add_diff(root, \"Best Share\", &(pool->best_diff), true);\n\t\tif (pool->admin_msg)\n\t\t\troot = api_add_escape(root, \"Message\", pool->admin_msg, true);\n\t\tdouble rejp = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?\n\t\t\t\t(double)(pool->diff_rejected) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;\n\t\troot = api_add_percent(root, \"Pool Rejected%\", &rejp, false);\n\t\tdouble stalep = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?\n\t\t\t\t(double)(pool->diff_stale) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;\n\t\troot = api_add_percent(root, \"Pool Stale%\", &stalep, false);\n\n\t\troot = print_data(root, buf, isjson, isjson && (i > 0));\n\t\tio_add(io_data, buf);\n\t}\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void summary(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tdouble utility, mhs, work_utility;\n\n\tmessage(io_data, MSG_SUMM, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_SUMMARY : _SUMMARY COMSTR);\n\n\t// stop hashmeter() changing some while copying\n\tmutex_lock(&hash_lock);\n\n\tutility = total_accepted / ( total_secs ? total_secs : 1 ) * 60;\n\tmhs = total_mhashes_done / total_secs;\n\twork_utility = total_diff1 / ( total_secs ? total_secs : 1 ) * 60;\n\n\troot = api_add_elapsed(root, \"Elapsed\", &(total_secs), true);\n#if defined(USE_CPUMINING) && defined(USE_SHA256D)\n\tif (opt_n_threads > 0)\n\t\troot = api_add_string(root, \"Algorithm\", (algo_names[opt_algo] ?: NULLSTR), false);\n#endif\n\troot = api_add_mhs(root, \"MHS av\", &(mhs), false);\n\tchar mhsname[27];\n\tsprintf(mhsname, \"MHS %ds\", opt_log_interval);\n\troot = api_add_mhs(root, mhsname, &(total_rolling), false);\n\troot = api_add_uint(root, \"Found Blocks\", &(found_blocks), true);\n\troot = api_add_int(root, \"Getworks\", &(total_getworks), true);\n\troot = api_add_int(root, \"Accepted\", &(total_accepted), true);\n\troot = api_add_int(root, \"Rejected\", &(total_rejected), true);\n\troot = api_add_int(root, \"Hardware Errors\", &(hw_errors), true);\n\troot = api_add_utility(root, \"Utility\", &(utility), false);\n\troot = api_add_int(root, \"Discarded\", &(total_discarded), true);\n\troot = api_add_int(root, \"Stale\", &(total_stale), true);\n\troot = api_add_uint(root, \"Get Failures\", &(total_go), true);\n\troot = api_add_uint(root, \"Local Work\", &(local_work), true);\n\troot = api_add_uint(root, \"Remote Failures\", &(total_ro), true);\n\troot = api_add_uint(root, \"Network Blocks\", &(new_blocks), true);\n\troot = api_add_mhtotal(root, \"Total MH\", &(total_mhashes_done), true);\n\troot = api_add_diff(root, \"Diff1 Work\", &total_diff1, true);\n\troot = api_add_utility(root, \"Work Utility\", &(work_utility), false);\n\troot = api_add_diff(root, \"Difficulty Accepted\", &(total_diff_accepted), true);\n\troot = api_add_diff(root, \"Difficulty Rejected\", &(total_diff_rejected), true);\n\troot = api_add_diff(root, \"Difficulty Stale\", &(total_diff_stale), true);\n\troot = api_add_diff(root, \"Best Share\", &(best_diff), true);\n\tdouble hwp = (total_bad_diff1 + total_diff1) ?\n\t\t\t(double)(total_bad_diff1) / (double)(total_bad_diff1 + total_diff1) : 0;\n\troot = api_add_percent(root, \"Device Hardware%\", &hwp, false);\n\tdouble rejp = total_diff1 ?\n\t\t\t(double)(total_diff_rejected) / (double)(total_diff1) : 0;\n\troot = api_add_percent(root, \"Device Rejected%\", &rejp, false);\n\tdouble prejp = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?\n\t\t\t(double)(total_diff_rejected) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;\n\troot = api_add_percent(root, \"Pool Rejected%\", &prejp, false);\n\tdouble stalep = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?\n\t\t\t(double)(total_diff_stale) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;\n\troot = api_add_percent(root, \"Pool Stale%\", &stalep, false);\n\troot = api_add_time(root, \"Last getwork\", &last_getwork, false);\n\n\tmutex_unlock(&hash_lock);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\n#ifdef USE_OPENCL\nstatic void gpuenable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (!nDevs) {\n\t\tmessage(io_data, MSG_GPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= nDevs) {\n\t\tmessage(io_data, MSG_INVGPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tapplog(LOG_DEBUG, \"API: request to gpuenable gpuid %d %s\",\n\t\t\tid, gpus[id].proc_repr_ns);\n\n\tif (gpus[id].deven != DEV_DISABLED) {\n\t\tmessage(io_data, MSG_ALRENA, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (gpus[id].status != LIFE_WELL)\n\t{\n\t\tmessage(io_data, MSG_GPUMRE, id, NULL, isjson);\n\t\treturn;\n\t}\n\tproc_enable(&gpus[id]);\n\n\tmessage(io_data, MSG_GPUREN, id, NULL, isjson);\n}\n\nstatic void gpudisable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (nDevs == 0) {\n\t\tmessage(io_data, MSG_GPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= nDevs) {\n\t\tmessage(io_data, MSG_INVGPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tapplog(LOG_DEBUG, \"API: request to gpudisable gpuid %d %s\",\n\t\t\tid, gpus[id].proc_repr_ns);\n\n\tif (gpus[id].deven == DEV_DISABLED) {\n\t\tmessage(io_data, MSG_ALRDIS, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tgpus[id].deven = DEV_DISABLED;\n\n\tmessage(io_data, MSG_GPUDIS, id, NULL, isjson);\n}\n\nstatic void gpurestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (nDevs == 0) {\n\t\tmessage(io_data, MSG_GPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= nDevs) {\n\t\tmessage(io_data, MSG_INVGPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\treinit_device(&gpus[id]);\n\n\tmessage(io_data, MSG_GPUREI, id, NULL, isjson);\n}\n#endif\n\nstatic void gpucount(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tint numgpu = 0;\n\n#ifdef USE_OPENCL\n\tnumgpu = nDevs;\n#endif\n\n\tmessage(io_data, MSG_NUMGPU, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_GPUS : _GPUS COMSTR);\n\n\troot = api_add_int(root, \"Count\", &numgpu, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void pgacount(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tint count = 0;\n\n#ifdef HAVE_AN_FPGA\n\tcount = numpgas();\n#endif\n\n\tmessage(io_data, MSG_NUMPGA, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_PGAS : _PGAS COMSTR);\n\n\troot = api_add_int(root, \"Count\", &count, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\n#ifdef USE_CPUMINING\nstatic void cpuenable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (opt_n_threads <= 0)\n\t{\n\t\tmessage(io_data, MSG_CPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= opt_n_threads) {\n\t\tmessage(io_data, MSG_INVCPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tapplog(LOG_DEBUG, \"API: request to cpuenable cpuid %d %s\",\n\t\t\tid, cpus[id].proc_repr_ns);\n\n\tif (cpus[id].deven != DEV_DISABLED) {\n\t\tmessage(io_data, MSG_ALRENAC, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (cpus[id].status != LIFE_WELL)\n\t{\n\t\tmessage(io_data, MSG_CPUMRE, id, NULL, isjson);\n\t\treturn;\n\t}\n\tproc_enable(&cpus[id]);\n\n\tmessage(io_data, MSG_CPUREN, id, NULL, isjson);\n}\n\nstatic void cpudisable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (opt_n_threads <= 0)\n\t{\n\t\tmessage(io_data, MSG_CPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= opt_n_threads) {\n\t\tmessage(io_data, MSG_INVCPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tapplog(LOG_DEBUG, \"API: request to cpudisable cpuid %d %s\",\n\t\t\tid, cpus[id].proc_repr_ns);\n\n\tif (cpus[id].deven == DEV_DISABLED) {\n\t\tmessage(io_data, MSG_ALRDISC, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tcpus[id].deven = DEV_DISABLED;\n\n\tmessage(io_data, MSG_CPUDIS, id, NULL, isjson);\n}\n\nstatic void cpurestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\n\tif (opt_n_threads <= 0)\n\t{\n\t\tmessage(io_data, MSG_CPUNON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= opt_n_threads) {\n\t\tmessage(io_data, MSG_INVCPU, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\treinit_device(&cpus[id]);\n\n\tmessage(io_data, MSG_CPUREI, id, NULL, isjson);\n}\n#endif\n\nstatic void cpucount(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tint count = 0;\n\n#ifdef USE_CPUMINING\n\tcount = opt_n_threads > 0 ? num_processors : 0;\n#endif\n\n\tmessage(io_data, MSG_NUMCPU, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_CPUS : _CPUS COMSTR);\n\n\troot = api_add_int(root, \"Count\", &count, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void switchpool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct pool *pool;\n\tint id;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tcg_rlock(&control_lock);\n\tif (id < 0 || id >= total_pools) {\n\t\tcg_runlock(&control_lock);\n\t\tmessage(io_data, MSG_INVPID, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tpool = pools[id];\n\tmanual_enable_pool(pool);\n\tcg_runlock(&control_lock);\n\tswitch_pools(pool);\n\n\tmessage(io_data, MSG_SWITCHP, id, NULL, isjson);\n}\n\nstatic void copyadvanceafter(char ch, char **param, char **buf)\n{\n#define src_p (*param)\n#define dst_b (*buf)\n\n\twhile (*src_p && *src_p != ch) {\n\t\tif (*src_p == '\\\\' && *(src_p+1) != '\\0')\n\t\t\tsrc_p++;\n\n\t\t*(dst_b++) = *(src_p++);\n\t}\n\tif (*src_p)\n\t\tsrc_p++;\n\n\t*(dst_b++) = '\\0';\n}\n\nstatic bool pooldetails(char *param, char **url, char **user, char **pass, char **goalname)\n{\n\tchar *ptr, *buf;\n\n\tptr = buf = malloc(strlen(param)+1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc pooldetails buf\");\n\n\t*url = buf;\n\n\t// copy url\n\tcopyadvanceafter(',', &param, &buf);\n\n\tif (!(*param)) // missing user\n\t\tgoto exitsama;\n\n\t*user = buf;\n\n\t// copy user\n\tcopyadvanceafter(',', &param, &buf);\n\n\tif (!*param) // missing pass\n\t\tgoto exitsama;\n\n\t*pass = buf;\n\n\t// copy pass\n\tcopyadvanceafter(',', &param, &buf);\n\t\n\tif (*param)\n\t\t*goalname = buf;\n\t\n\t// copy goalname\n\tcopyadvanceafter(',', &param, &buf);\n\n\treturn true;\n\nexitsama:\n\tfree(ptr);\n\treturn false;\n}\n\nstatic void addpool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tchar *url, *user, *pass, *goalname = \"default\";\n\tstruct pool *pool;\n\tchar *ptr;\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPDP, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (!pooldetails(param, &url, &user, &pass, &goalname))\n\t{\n\t\tptr = escape_string(param, isjson);\n\t\tmessage(io_data, MSG_INVPDP, 0, ptr, isjson);\n\t\tif (ptr != param)\n\t\t\tfree(ptr);\n\t\tptr = NULL;\n\t\treturn;\n\t}\n\n\tstruct mining_goal_info * const goal = get_mining_goal(goalname);\n\tpool = add_pool2(goal);\n\tdetect_stratum(pool, url);\n\tadd_pool_details(pool, true, url, user, pass);\n\n\tptr = escape_string(url, isjson);\n\tmessage(io_data, MSG_ADDPOOL, 0, ptr, isjson);\n\tif (ptr != url)\n\t\tfree(ptr);\n\tptr = NULL;\n}\n\nstatic void enablepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct pool *pool;\n\tint id;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= total_pools) {\n\t\tmessage(io_data, MSG_INVPID, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tpool = pools[id];\n\tif (pool->enabled == POOL_ENABLED && !pool->failover_only) {\n\t\tmessage(io_data, MSG_ALRENAP, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmanual_enable_pool(pool);\n\n\tmessage(io_data, MSG_ENAPOOL, id, NULL, isjson);\n}\n\nstatic void poolpriority(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint i;\n\n\tswitch (prioritize_pools(param, &i)) {\n\t\tcase MSG_NOPOOL:\n\t\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\t\treturn;\n\t\tcase MSG_MISPID:\n\t\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\t\treturn;\n\t\tcase MSG_INVPID:\n\t\t\tmessage(io_data, MSG_INVPID, i, NULL, isjson);\n\t\t\treturn;\n\t\tcase MSG_DUPPID:\n\t\t\tmessage(io_data, MSG_DUPPID, i, NULL, isjson);\n\t\t\treturn;\n\t\tcase MSG_POOLPRIO:\n\t\tdefault:\n\t\t\tmessage(io_data, MSG_POOLPRIO, 0, NULL, isjson);\n\t\t\treturn;\n\t}\n}\n\nstatic void poolquota(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct pool *pool;\n\tint quota, id;\n\tchar *comma;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tcomma = strchr(param, ',');\n\tif (!comma) {\n\t\tmessage(io_data, MSG_CONVAL, 0, param, isjson);\n\t\treturn;\n\t}\n\n\t*(comma++) = '\\0';\n\n\tid = atoi(param);\n\tif (id < 0 || id >= total_pools) {\n\t\tmessage(io_data, MSG_INVPID, id, NULL, isjson);\n\t\treturn;\n\t}\n\tpool = pools[id];\n\n\tquota = atoi(comma);\n\tif (quota < 0) {\n\t\tmessage(io_data, MSG_INVNEG, quota, pool->rpc_url, isjson);\n\t\treturn;\n\t}\n\n\tpool->quota = quota;\n\tadjust_quota_gcd();\n\tmessage(io_data, MSG_SETQUOTA, quota, pool->rpc_url, isjson);\n}\n\nstatic void disablepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct pool *pool;\n\tint id;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= total_pools) {\n\t\tmessage(io_data, MSG_INVPID, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tpool = pools[id];\n\tif (pool->enabled == POOL_DISABLED) {\n\t\tmessage(io_data, MSG_ALRDISP, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (enabled_pools <= 1) {\n\t\tmessage(io_data, MSG_DISLASTP, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tdisable_pool(pool, POOL_DISABLED);\n\n\tmessage(io_data, MSG_DISPOOL, id, NULL, isjson);\n}\n\nstatic void removepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct pool *pool;\n\tchar *rpc_url;\n\tbool dofree = false;\n\tint id;\n\n\tif (total_pools == 0) {\n\t\tmessage(io_data, MSG_NOPOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISPID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tid = atoi(param);\n\tif (id < 0 || id >= total_pools) {\n\t\tmessage(io_data, MSG_INVPID, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (total_pools <= 1) {\n\t\tmessage(io_data, MSG_REMLASTP, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tpool = pools[id];\n\tif (pool == current_pool())\n\t\tswitch_pools(NULL);\n\n\tif (pool == current_pool()) {\n\t\tmessage(io_data, MSG_ACTPOOL, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\trpc_url = escape_string(pool->rpc_url, isjson);\n\tif (rpc_url != pool->rpc_url)\n\t\tdofree = true;\n\n\tremove_pool(pool);\n\n\tmessage(io_data, MSG_REMPOOL, id, rpc_url, isjson);\n\n\tif (dofree)\n\t\tfree(rpc_url);\n\trpc_url = NULL;\n}\n\n#ifdef USE_OPENCL\nstatic bool splitgpuvalue(struct io_data *io_data, char *param, int *gpu, char **value, bool isjson)\n{\n\tint id;\n\tchar *gpusep;\n\n\tif (nDevs == 0) {\n\t\tmessage(io_data, MSG_GPUNON, 0, NULL, isjson);\n\t\treturn false;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn false;\n\t}\n\n\tgpusep = strchr(param, GPUSEP);\n\tif (gpusep == NULL) {\n\t\tmessage(io_data, MSG_MISVAL, 0, NULL, isjson);\n\t\treturn false;\n\t}\n\n\t*(gpusep++) = '\\0';\n\n\tid = atoi(param);\n\tif (id < 0 || id >= nDevs) {\n\t\tmessage(io_data, MSG_INVGPU, id, NULL, isjson);\n\t\treturn false;\n\t}\n\n\t*gpu = id;\n\t*value = gpusep;\n\n\treturn true;\n}\n\nstatic void gpuintensity(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tint id;\n\tchar *value;\n\tchar intensitystr[7];\n\tchar buf[TMPBUFSIZ];\n\n\tif (!splitgpuvalue(io_data, param, &id, &value, isjson))\n\t\treturn;\n\n\tstruct cgpu_info * const cgpu = &gpus[id];\n\tstruct opencl_device_data * const data = gpus[id].device_data;\n\t\n\tenum bfg_set_device_replytype success;\n\tproc_set_device(cgpu, \"intensity\", value, buf, &success);\n\tif (success == SDR_OK)\n\t{\n\t\tif (data->dynamic)\n\t\t\tstrcpy(intensitystr, DYNAMIC);\n\t\telse\n\t\t{\n\t\t\tconst char *iunit;\n\t\t\tfloat intensity = opencl_proc_get_intensity(cgpu, &iunit);\n\t\t\tsnprintf(intensitystr, sizeof(intensitystr), \"%s%g\", iunit, intensity);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmessage(io_data, MSG_INVINT, 0, value, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_GPUINT, id, intensitystr, isjson);\n}\n\nstatic void gpumem(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n#ifdef HAVE_ADL\n\tint id;\n\tchar *value;\n\tchar buf[TMPBUFSIZ];\n\n\tif (!splitgpuvalue(io_data, param, &id, &value, isjson))\n\t\treturn;\n\n\tstruct cgpu_info * const cgpu = &gpus[id];\n\t\n\tenum bfg_set_device_replytype success;\n\tproc_set_device(cgpu, \"memclock\", value, buf, &success);\n\tif (success != SDR_OK)\n\t\tmessage(io_data, MSG_GPUMERR, id, value, isjson);\n\telse\n\t\tmessage(io_data, MSG_GPUMEM, id, value, isjson);\n#else\n\tmessage(io_data, MSG_NOADL, 0, NULL, isjson);\n#endif\n}\n\nstatic void gpuengine(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n#ifdef HAVE_ADL\n\tint id;\n\tchar *value;\n\tchar buf[TMPBUFSIZ];\n\n\tif (!splitgpuvalue(io_data, param, &id, &value, isjson))\n\t\treturn;\n\n\tstruct cgpu_info * const cgpu = &gpus[id];\n\t\n\tenum bfg_set_device_replytype success;\n\tproc_set_device(cgpu, \"clock\", value, buf, &success);\n\tif (success != SDR_OK)\n\t\tmessage(io_data, MSG_GPUEERR, id, value, isjson);\n\telse\n\t\tmessage(io_data, MSG_GPUENG, id, value, isjson);\n#else\n\tmessage(io_data, MSG_NOADL, 0, NULL, isjson);\n#endif\n}\n\nstatic void gpufan(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n#ifdef HAVE_ADL\n\tint id;\n\tchar *value;\n\tchar buf[TMPBUFSIZ];\n\n\tif (!splitgpuvalue(io_data, param, &id, &value, isjson))\n\t\treturn;\n\n\tstruct cgpu_info * const cgpu = &gpus[id];\n\t\n\tenum bfg_set_device_replytype success;\n\tproc_set_device(cgpu, \"fan\", value, buf, &success);\n\tif (success != SDR_OK)\n\t\tmessage(io_data, MSG_GPUFERR, id, value, isjson);\n\telse\n\t\tmessage(io_data, MSG_GPUFAN, id, value, isjson);\n#else\n\tmessage(io_data, MSG_NOADL, 0, NULL, isjson);\n#endif\n}\n\nstatic void gpuvddc(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n#ifdef HAVE_ADL\n\tint id;\n\tchar *value;\n\tchar buf[TMPBUFSIZ];\n\n\tif (!splitgpuvalue(io_data, param, &id, &value, isjson))\n\t\treturn;\n\n\tstruct cgpu_info * const cgpu = &gpus[id];\n\t\n\tenum bfg_set_device_replytype success;\n\tproc_set_device(cgpu, \"voltage\", value, buf, &success);\n\tif (success != SDR_OK)\n\t\tmessage(io_data, MSG_GPUVERR, id, value, isjson);\n\telse\n\t\tmessage(io_data, MSG_GPUVDDC, id, value, isjson);\n#else\n\tmessage(io_data, MSG_NOADL, 0, NULL, isjson);\n#endif\n}\n#endif\n\nvoid doquit(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tmessage(io_data, MSG_BYE, 0, _BYE, isjson);\n\n\tbye = true;\n\tdo_a_quit = true;\n}\n\nvoid dorestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tmessage(io_data, MSG_BYE, 0, _RESTART, isjson);\n\n\tbye = true;\n\tdo_a_restart = true;\n}\n\nvoid privileged(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tmessage(io_data, MSG_ACCOK, 0, NULL, isjson);\n}\n\nvoid notifystatus(struct io_data *io_data, int device, struct cgpu_info *cgpu, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *proc;\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tchar *reason;\n\t\n\ttime_t last_not_well = 0;\n\tenum dev_reason uninitialised_var(enum_reason);\n\tint thread_fail_init_count = 0, thread_zero_hash_count = 0, thread_fail_queue_count = 0;\n\tint dev_sick_idle_60_count = 0, dev_dead_idle_600_count = 0;\n\tint dev_nostart_count = 0, dev_over_heat_count = 0, dev_thermal_cutoff_count = 0, dev_comms_error_count = 0, dev_throttle_count = 0;\n\n\tint procs = per_proc ? 1 : cgpu->procs, i;\n\tfor (i = 0, proc = cgpu; i < procs; ++i, proc = proc->next_proc)\n\t{\n\t\tif (proc->device_last_not_well > last_not_well)\n\t\t{\n\t\t\tlast_not_well = proc->device_last_not_well;\n\t\t\tenum_reason = proc->device_not_well_reason;\n\t\t\tthread_fail_init_count   += proc->thread_fail_init_count;\n\t\t\tthread_zero_hash_count   += proc->thread_zero_hash_count;\n\t\t\tthread_fail_queue_count  += proc->thread_fail_queue_count;\n\t\t\tdev_sick_idle_60_count   += proc->dev_sick_idle_60_count;\n\t\t\tdev_dead_idle_600_count  += proc->dev_dead_idle_600_count;\n\t\t\tdev_nostart_count        += proc->dev_nostart_count;\n\t\t\tdev_over_heat_count      += proc->dev_over_heat_count;\n\t\t\tdev_thermal_cutoff_count += proc->dev_thermal_cutoff_count;\n\t\t\tdev_comms_error_count    += proc->dev_comms_error_count;\n\t\t\tdev_throttle_count       += proc->dev_throttle_count;\n\t\t}\n\t\tif (per_proc)\n\t\t\tbreak;\n\t}\n\t\n\tif (last_not_well == 0)\n\t\treason = REASON_NONE;\n\telse\n\t\tswitch (enum_reason)\n\t\t{\n\t\t\tcase REASON_THREAD_FAIL_INIT:\n\t\t\t\treason = REASON_THREAD_FAIL_INIT_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_THREAD_ZERO_HASH:\n\t\t\t\treason = REASON_THREAD_ZERO_HASH_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_THREAD_FAIL_QUEUE:\n\t\t\t\treason = REASON_THREAD_FAIL_QUEUE_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_SICK_IDLE_60:\n\t\t\t\treason = REASON_DEV_SICK_IDLE_60_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_DEAD_IDLE_600:\n\t\t\t\treason = REASON_DEV_DEAD_IDLE_600_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_NOSTART:\n\t\t\t\treason = REASON_DEV_NOSTART_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_OVER_HEAT:\n\t\t\t\treason = REASON_DEV_OVER_HEAT_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_THERMAL_CUTOFF:\n\t\t\t\treason = REASON_DEV_THERMAL_CUTOFF_STR;\n\t\t\t\tbreak;\n\t\t\tcase REASON_DEV_COMMS_ERROR:\n\t\t\t\treason = REASON_DEV_COMMS_ERROR_STR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treason = REASON_UNKNOWN_STR;\n\t\t\t\tbreak;\n\t\t}\n\n\t// ALL counters (and only counters) must start the name with a '*'\n\t// Simplifies future external support for identifying new counters\n\troot = api_add_int(root, \"NOTIFY\", &device, false);\n\troot = api_add_device_identifier(root, cgpu);\n\tif (per_proc)\n\t\troot = api_add_time(root, \"Last Well\", &(cgpu->device_last_well), false);\n\troot = api_add_time(root, \"Last Not Well\", &last_not_well, false);\n\troot = api_add_string(root, \"Reason Not Well\", reason, false);\n\troot = api_add_int(root, \"*Thread Fail Init\", &thread_fail_init_count, false);\n\troot = api_add_int(root, \"*Thread Zero Hash\", &thread_zero_hash_count, false);\n\troot = api_add_int(root, \"*Thread Fail Queue\", &thread_fail_queue_count, false);\n\troot = api_add_int(root, \"*Dev Sick Idle 60s\", &dev_sick_idle_60_count, false);\n\troot = api_add_int(root, \"*Dev Dead Idle 600s\", &dev_dead_idle_600_count, false);\n\troot = api_add_int(root, \"*Dev Nostart\", &dev_nostart_count, false);\n\troot = api_add_int(root, \"*Dev Over Heat\", &dev_over_heat_count, false);\n\troot = api_add_int(root, \"*Dev Thermal Cutoff\", &dev_thermal_cutoff_count, false);\n\troot = api_add_int(root, \"*Dev Comms Error\", &dev_comms_error_count, false);\n\troot = api_add_int(root, \"*Dev Throttle\", &dev_throttle_count, false);\n\n\troot = print_data(root, buf, isjson, isjson && (device > 0));\n\tio_add(io_data, buf);\n}\n\nstatic\nvoid notify(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, char group)\n{\n\tstruct cgpu_info *cgpu;\n\tbool io_open = false;\n\tint i, n = 0;\n\n\tif (total_devices == 0) {\n\t\tmessage(io_data, MSG_NODEVS, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_NOTIFY, 0, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_NOTIFY);\n\n\tfor (i = 0; i < total_devices; i++) {\n\t\tcgpu = get_devices(i);\n\t\tif (cgpu->device == cgpu || per_proc)\n\t\t\tnotifystatus(io_data, n++, cgpu, isjson, group);\n\t}\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nvoid dosave(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tchar filename[PATH_MAX];\n\tFILE *fcfg;\n\tchar *ptr;\n\n\tif (param == NULL || *param == '\\0') {\n\t\tdefault_save_file(filename);\n\t\tparam = filename;\n\t}\n\n\tfcfg = fopen(param, \"w\");\n\tif (!fcfg) {\n\t\tptr = escape_string(param, isjson);\n\t\tmessage(io_data, MSG_BADFN, 0, ptr, isjson);\n\t\tif (ptr != param)\n\t\t\tfree(ptr);\n\t\tptr = NULL;\n\t\treturn;\n\t}\n\n\twrite_config(fcfg);\n\tfclose(fcfg);\n\n\tptr = escape_string(param, isjson);\n\tmessage(io_data, MSG_SAVED, 0, ptr, isjson);\n\tif (ptr != param)\n\t\tfree(ptr);\n\tptr = NULL;\n}\n\nstatic int itemstats(struct io_data *io_data, int i, char *id, struct cgminer_stats *stats, struct cgminer_pool_stats *pool_stats, struct api_data *extra, bool isjson)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tdouble elapsed;\n\n\troot = api_add_int(root, \"STATS\", &i, false);\n\troot = api_add_string(root, \"ID\", id, false);\n\telapsed = stats_elapsed(stats);\n\troot = api_add_elapsed(root, \"Elapsed\", &elapsed, false);\n\troot = api_add_uint32(root, \"Calls\", &(stats->getwork_calls), false);\n\troot = api_add_timeval(root, \"Wait\", &(stats->getwork_wait), false);\n\troot = api_add_timeval(root, \"Max\", &(stats->getwork_wait_max), false);\n\troot = api_add_timeval(root, \"Min\", &(stats->getwork_wait_min), false);\n\n\tif (pool_stats) {\n\t\troot = api_add_uint32(root, \"Pool Calls\", &(pool_stats->getwork_calls), false);\n\t\troot = api_add_uint32(root, \"Pool Attempts\", &(pool_stats->getwork_attempts), false);\n\t\troot = api_add_timeval(root, \"Pool Wait\", &(pool_stats->getwork_wait), false);\n\t\troot = api_add_timeval(root, \"Pool Max\", &(pool_stats->getwork_wait_max), false);\n\t\troot = api_add_timeval(root, \"Pool Min\", &(pool_stats->getwork_wait_min), false);\n\t\troot = api_add_double(root, \"Pool Av\", &(pool_stats->getwork_wait_rolling), false);\n\t\troot = api_add_bool(root, \"Work Had Roll Time\", &(pool_stats->hadrolltime), false);\n\t\troot = api_add_bool(root, \"Work Can Roll\", &(pool_stats->canroll), false);\n\t\troot = api_add_bool(root, \"Work Had Expire\", &(pool_stats->hadexpire), false);\n\t\troot = api_add_uint32(root, \"Work Roll Time\", &(pool_stats->rolltime), false);\n\t\troot = api_add_diff(root, \"Work Diff\", &(pool_stats->last_diff), false);\n\t\troot = api_add_diff(root, \"Min Diff\", &(pool_stats->min_diff), false);\n\t\troot = api_add_diff(root, \"Max Diff\", &(pool_stats->max_diff), false);\n\t\troot = api_add_uint32(root, \"Min Diff Count\", &(pool_stats->min_diff_count), false);\n\t\troot = api_add_uint32(root, \"Max Diff Count\", &(pool_stats->max_diff_count), false);\n\t\troot = api_add_uint64(root, \"Times Sent\", &(pool_stats->times_sent), false);\n\t\troot = api_add_uint64(root, \"Bytes Sent\", &(pool_stats->bytes_sent), false);\n\t\troot = api_add_uint64(root, \"Times Recv\", &(pool_stats->times_received), false);\n\t\troot = api_add_uint64(root, \"Bytes Recv\", &(pool_stats->bytes_received), false);\n\t\troot = api_add_uint64(root, \"Net Bytes Sent\", &(pool_stats->net_bytes_sent), false);\n\t\troot = api_add_uint64(root, \"Net Bytes Recv\", &(pool_stats->net_bytes_received), false);\n\t}\n\n\tif (extra)\n\t\troot = api_add_extra(root, extra);\n\n\troot = print_data(root, buf, isjson, isjson && (i > 0));\n\tio_add(io_data, buf);\n\n\treturn ++i;\n}\n\nstatic void minerstats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu;\n\tbool io_open = false;\n\tstruct api_data *extra;\n\tchar id[20];\n\tint i, j;\n\n\tmessage(io_data, MSG_MINESTATS, 0, NULL, isjson);\n\n\tif (isjson)\n\t\tio_open = io_add(io_data, COMSTR JSON_MINESTATS);\n\n\ti = 0;\n\tfor (j = 0; j < total_devices; j++) {\n\t\tcgpu = get_devices(j);\n\n\t\tif (cgpu && cgpu->drv) {\n\t\t\tif (cgpu->drv->get_api_stats)\n\t\t\t\textra = cgpu->drv->get_api_stats(cgpu);\n\t\t\telse\n\t\t\t\textra = NULL;\n\n\t\t\ti = itemstats(io_data, i, cgpu->proc_repr_ns, &(cgpu->cgminer_stats), NULL, extra, isjson);\n\t\t}\n\t}\n\n\tfor (j = 0; j < total_pools; j++) {\n\t\tstruct pool *pool = pools[j];\n\n\t\tsprintf(id, \"POOL%d\", j);\n\t\ti = itemstats(io_data, i, id, &(pool->cgminer_stats), &(pool->cgminer_pool_stats), NULL, isjson);\n\t}\n\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void failoveronly(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISBOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\t*param = tolower(*param);\n\n\tif (*param != 't' && *param != 'f') {\n\t\tmessage(io_data, MSG_INVBOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tbool tf = (*param == 't');\n\n\topt_fail_only = tf;\n\n\tmessage(io_data, MSG_FOO, tf, NULL, isjson);\n}\n\nstatic void minecoin(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\n\tmessage(io_data, MSG_MINECOIN, 0, NULL, isjson);\n\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tbool precom = false;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tif (goal->is_default)\n\t\t\tio_add(io_data, isjson ? COMSTR JSON1 _MINECOIN JSON2 : _MINECOIN COMSTR);\n\t\telse\n\t\t{\n\t\t\tsprintf(buf, isjson ? COMSTR JSON1 _MINECOIN \"%u\" JSON2 : _MINECOIN \"%u\" COMSTR, goal->id);\n\t\t\tio_add(io_data, buf);\n\t\t}\n\t\t\n\t\tswitch (goal->malgo->algo)\n\t\t{\n#ifdef USE_SCRYPT\n\t\t\tcase POW_SCRYPT:\n\t\t\t\troot = api_add_const(root, \"Hash Method\", SCRYPTSTR, false);\n\t\t\t\tbreak;\n#endif\n#ifdef USE_SHA256D\n\t\t\tcase POW_SHA256D:\n\t\t\t\troot = api_add_const(root, \"Hash Method\", SHA256STR, false);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\troot = api_add_const(root, \"Hash Method\", goal->malgo->name, false);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcg_rlock(&ch_lock);\n\t\tstruct blockchain_info * const blkchain = goal->blkchain;\n\t\tstruct block_info * const blkinfo = blkchain->currentblk;\n\t\troot = api_add_time(root, \"Current Block Time\", &blkinfo->first_seen_time, true);\n\t\tchar fullhash[(sizeof(blkinfo->prevblkhash) * 2) + 1];\n\t\tblkhashstr(fullhash, blkinfo->prevblkhash);\n\t\troot = api_add_string(root, \"Current Block Hash\", fullhash, true);\n\t\tcg_runlock(&ch_lock);\n\n\t\troot = api_add_bool(root, \"LP\", &goal->have_longpoll, false);\n\t\troot = api_add_diff(root, \"Network Difficulty\", &goal->current_diff, true);\n\t\t\n\t\troot = api_add_diff(root, \"Difficulty Accepted\", &goal->diff_accepted, false);\n\t\t\n\t\troot = print_data(root, buf, isjson, precom);\n\t\tio_add(io_data, buf);\n\t\tif (isjson)\n\t\t\tio_add(io_data, JSON_CLOSE);\n\t}\n}\n\nstatic void debugstate(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\n\tif (param == NULL)\n\t\tparam = (char *)BLANK;\n\telse\n\t\t*param = tolower(*param);\n\n\tswitch(*param) {\n\tcase 's':\n\t\topt_realquiet = true;\n\t\tbreak;\n\tcase 'q':\n\t\topt_quiet ^= true;\n\t\tbreak;\n\tcase 'v':\n\t\topt_log_output ^= true;\n\t\tif (opt_log_output)\n\t\t\topt_quiet = false;\n\t\tbreak;\n\tcase 'd':\n\t\topt_debug ^= true;\n\t\topt_log_output = opt_debug;\n\t\tif (opt_debug)\n\t\t\topt_quiet = false;\n\t\tbreak;\n\tcase 'r':\n\t\topt_protocol ^= true;\n\t\tif (opt_protocol)\n\t\t\topt_quiet = false;\n\t\tbreak;\n\tcase 'p':\n\t\twant_per_device_stats ^= true;\n\t\topt_log_output = want_per_device_stats;\n\t\tbreak;\n\tcase 'n':\n\t\topt_log_output = false;\n\t\topt_debug = false;\n\t\topt_quiet = false;\n\t\topt_protocol = false;\n\t\twant_per_device_stats = false;\n\t\topt_worktime = false;\n\t\tbreak;\n\tcase 'w':\n\t\topt_worktime ^= true;\n\t\tbreak;\n#ifdef _MEMORY_DEBUG\n\tcase 'y':\n\t\tcgmemspeedup();\n\t\tbreak;\n\tcase 'z':\n\t\tcgmemrpt();\n\t\tbreak;\n#endif\n\tdefault:\n\t\t// anything else just reports the settings\n\t\tbreak;\n\t}\n\n\tmessage(io_data, MSG_DEBUGSET, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_DEBUGSET : _DEBUGSET COMSTR);\n\n\troot = api_add_bool(root, \"Silent\", &opt_realquiet, false);\n\troot = api_add_bool(root, \"Quiet\", &opt_quiet, false);\n\troot = api_add_bool(root, \"Verbose\", &opt_log_output, false);\n\troot = api_add_bool(root, \"Debug\", &opt_debug, false);\n\troot = api_add_bool(root, \"RPCProto\", &opt_protocol, false);\n\troot = api_add_bool(root, \"PerDevice\", &want_per_device_stats, false);\n\troot = api_add_bool(root, \"WorkTime\", &opt_worktime, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nextern bool stratumsrv_change_port(unsigned);\n\nstatic void setconfig(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tchar *comma;\n\tlong value;\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_CONPAR, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tcomma = strchr(param, ',');\n\tif (!comma) {\n\t\tmessage(io_data, MSG_CONVAL, 0, param, isjson);\n\t\treturn;\n\t}\n\n\t*(comma++) = '\\0';\n\n#if BLKMAKER_VERSION > 0\n\tif (strcasecmp(param, \"coinbase-sig\") == 0) {\n\t\tfree(opt_coinbase_sig);\n\t\topt_coinbase_sig = strdup(comma);\n\t\tmessage(io_data, MSG_SETCONFIG, 1, param, isjson);\n\t\treturn;\n\t}\n\telse\n#endif\n\tif (strcasecmp(param, \"strategy\") == 0) {\n\t\tchar * const strategy_name = comma;\n\t\tcomma = strchr(strategy_name, ',');\n\t\tif (comma) {\n\t\t\t*(comma++) = '\\0';\n\t\t}\n\t\tvalue = bfg_strategy_parse(strategy_name);\n\t\tif (value < 0) {\n\t\t\tmessage(io_data, MSG_INVSTRATEGY, 0, param, isjson);\n\t\t\treturn;\n\t\t}\n\t\tif (!bfg_strategy_change(value, comma)) {\n\t\t\tmessage(io_data, MSG_INVNUM, atoi(comma), param, isjson);\n\t\t\treturn;\n\t\t}\n\t\tmessage(io_data, MSG_SETCONFIG, value, param, isjson);\n\t\treturn;\n\t}\n\n\tvalue = atol(comma);\n\tif (value < 0 || value > 9999) {\n\t\tmessage(io_data, MSG_INVNUM, value, param, isjson);\n\t\treturn;\n\t}\n\n\tif (strcasecmp(param, \"queue\") == 0)\n\t\topt_queue = value;\n\telse if (strcasecmp(param, \"scantime\") == 0)\n\t\topt_scantime = value;\n\telse if (strcasecmp(param, \"expiry\") == 0)\n\t\topt_expiry = value;\n#ifdef USE_LIBMICROHTTPD\n\telse if (strcasecmp(param, \"http-port\") == 0)\n\t{\n\t\thttpsrv_stop();\n\t\thttpsrv_port = value;\n\t\tif (httpsrv_port != -1)\n\t\t\thttpsrv_start(httpsrv_port);\n\t}\n#endif\n#ifdef USE_LIBEVENT\n\telse if (strcasecmp(param, \"stratum-port\") == 0)\n\t{\n\t\tif (!stratumsrv_change_port(value)) {\n\t\t\tmessage(io_data, MSG_FAILPORT, value, param, isjson);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\telse {\n\t\tmessage(io_data, MSG_UNKCON, 0, param, isjson);\n\t\treturn;\n\t}\n\n\tmessage(io_data, MSG_SETCONFIG, value, param, isjson);\n}\n\n#ifdef HAVE_AN_FPGA\nstatic void pgaset(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)\n{\n\tstruct cgpu_info *cgpu;\n\tchar buf[TMPBUFSIZ];\n\tint numpga = numpgas();\n\n\tif (numpga == 0) {\n\t\tmessage(io_data, MSG_PGANON, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISID, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tchar *opt = strchr(param, ',');\n\tif (opt)\n\t\t*(opt++) = '\\0';\n\tif (!opt || !*opt) {\n\t\tmessage(io_data, MSG_MISPGAOPT, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tint id = atoi(param);\n\tif (id < 0 || id >= numpga) {\n\t\tmessage(io_data, MSG_INVPGA, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tint dev = pgadevice(id);\n\tif (dev < 0) { // Should never happen\n\t\tmessage(io_data, MSG_INVPGA, id, NULL, isjson);\n\t\treturn;\n\t}\n\n\tcgpu = get_devices(dev);\n\n\tchar *set = strchr(opt, ',');\n\tif (set)\n\t\t*(set++) = '\\0';\n\n\tenum bfg_set_device_replytype success;\n\tconst char *ret = proc_set_device(cgpu, opt, set, buf, &success);\n\tswitch (success)\n\t{\n\t\tcase SDR_HELP:\n\t\t\tmessage(io_data, MSG_PGAHELP, id, ret, isjson);\n\t\t\tbreak;\n\t\tcase SDR_OK:\n\t\t\tif (ret)\n\t\t\t\tmessage(io_data, MSG_PGASETOK | USE_ALTMSG, id, ret, isjson);\n\t\t\telse\n\t\t\t\tmessage(io_data, MSG_PGASETOK, id, NULL, isjson);\n\t\t\tbreak;\n\t\tcase SDR_UNKNOWN:\n\t\tcase SDR_ERR:\n\t\t\tmessage(io_data, MSG_PGASETERR, id, ret, isjson);\n\t\t\tbreak;\n\t\tcase SDR_AUTO:\n\t\tcase SDR_NOSUPP:\n\t\t\tmessage(io_data, MSG_PGANOSET, id, NULL, isjson);\n\t}\n}\n#endif\n\nstatic void dozero(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)\n{\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_ZERMIS, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tchar *sum = strchr(param, ',');\n\tif (sum)\n\t\t*(sum++) = '\\0';\n\tif (!sum || !*sum) {\n\t\tmessage(io_data, MSG_MISBOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tbool all = false;\n\tbool bs = false;\n\tif (strcasecmp(param, \"all\") == 0)\n\t\tall = true;\n\telse if (strcasecmp(param, \"bestshare\") == 0)\n\t\tbs = true;\n\n\tif (all == false && bs == false) {\n\t\tmessage(io_data, MSG_ZERINV, 0, param, isjson);\n\t\treturn;\n\t}\n\n\t*sum = tolower(*sum);\n\tif (*sum != 't' && *sum != 'f') {\n\t\tmessage(io_data, MSG_INVBOOL, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tbool dosum = (*sum == 't');\n\tif (dosum)\n\t\tprint_summary();\n\n\tif (all)\n\t\tzero_stats();\n\tif (bs)\n\t\tzero_bestshare();\n\n\tif (dosum)\n\t\tmessage(io_data, MSG_ZERSUM, 0, all ? \"All\" : \"BestShare\", isjson);\n\telse\n\t\tmessage(io_data, MSG_ZERNOSUM, 0, all ? \"All\" : \"BestShare\", isjson);\n}\n\nstatic void checkcommand(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, char group);\n\nstruct CMDS {\n\tchar *name;\n\tvoid (*func)(struct io_data *, SOCKETTYPE, char *, bool, char);\n\tbool iswritemode;\n\tbool joinable;\n} cmds[] = {\n\t{ \"version\",\t\tapiversion,\tfalse,\ttrue },\n\t{ \"config\",\t\tminerconfig,\tfalse,\ttrue },\n\t{ \"devscan\",\t\tdevscan,\ttrue,\tfalse },\n\t{ \"devs\",\t\tdevstatus,\tfalse,\ttrue },\n\t{ \"procs\",\t\tdevstatus,\tfalse,\ttrue },\n\t{ \"pools\",\t\tpoolstatus,\tfalse,\ttrue },\n\t{ \"summary\",\t\tsummary,\tfalse,\ttrue },\n#ifdef USE_OPENCL\n\t{ \"gpuenable\",\t\tgpuenable,\ttrue,\tfalse },\n\t{ \"gpudisable\",\t\tgpudisable,\ttrue,\tfalse },\n\t{ \"gpurestart\",\t\tgpurestart,\ttrue,\tfalse },\n\t{ \"gpu\",\t\tgpudev,\t\tfalse,\tfalse },\n#endif\n#ifdef HAVE_AN_FPGA\n\t{ \"pga\",\t\tpgadev,\t\tfalse,\tfalse },\n\t{ \"pgaenable\",\t\tpgaenable,\ttrue,\tfalse },\n\t{ \"pgadisable\",\t\tpgadisable,\ttrue,\tfalse },\n\t{ \"pgarestart\",\t\tpgarestart,\ttrue,\tfalse },\n\t{ \"pgaidentify\",\tpgaidentify,\ttrue,\tfalse },\n\t{ \"proc\",\t\tpgadev,\t\tfalse,\tfalse },\n\t{ \"procenable\",\t\tpgaenable,\ttrue,\tfalse },\n\t{ \"procdisable\",\t\tpgadisable,\ttrue,\tfalse },\n\t{ \"procidentify\",\tpgaidentify,\ttrue,\tfalse },\n#endif\n#ifdef USE_CPUMINING\n\t{ \"cpuenable\",\t\tcpuenable,\ttrue,\tfalse },\n\t{ \"cpudisable\",\t\tcpudisable,\ttrue,\tfalse },\n\t{ \"cpurestart\",\t\tcpurestart,\ttrue,\tfalse },\n\t{ \"cpu\",\t\tcpudev,\t\tfalse,\tfalse },\n#endif\n\t{ \"gpucount\",\t\tgpucount,\tfalse,\ttrue },\n\t{ \"pgacount\",\t\tpgacount,\tfalse,\ttrue },\n\t{ \"proccount\",\t\tpgacount,\tfalse,\ttrue },\n\t{ \"cpucount\",\t\tcpucount,\tfalse,\ttrue },\n\t{ \"switchpool\",\t\tswitchpool,\ttrue,\tfalse },\n\t{ \"addpool\",\t\taddpool,\ttrue,\tfalse },\n\t{ \"poolpriority\",\tpoolpriority,\ttrue,\tfalse },\n\t{ \"poolquota\",\t\tpoolquota,\ttrue,\tfalse },\n\t{ \"enablepool\",\t\tenablepool,\ttrue,\tfalse },\n\t{ \"disablepool\",\tdisablepool,\ttrue,\tfalse },\n\t{ \"removepool\",\t\tremovepool,\ttrue,\tfalse },\n#ifdef USE_OPENCL\n\t{ \"gpuintensity\",\tgpuintensity,\ttrue,\tfalse },\n\t{ \"gpumem\",\t\tgpumem,\t\ttrue,\tfalse },\n\t{ \"gpuengine\",\t\tgpuengine,\ttrue,\tfalse },\n\t{ \"gpufan\",\t\tgpufan,\t\ttrue,\tfalse },\n\t{ \"gpuvddc\",\t\tgpuvddc,\ttrue,\tfalse },\n#endif\n\t{ \"save\",\t\tdosave,\t\ttrue,\tfalse },\n\t{ \"quit\",\t\tdoquit,\t\ttrue,\tfalse },\n\t{ \"privileged\",\t\tprivileged,\ttrue,\tfalse },\n\t{ \"notify\",\t\tnotify,\t\tfalse,\ttrue },\n\t{ \"procnotify\",\t\tnotify,\t\tfalse,\ttrue },\n\t{ \"devdetails\",\t\tdevdetail,\tfalse,\ttrue },\n\t{ \"procdetails\",\t\tdevdetail,\tfalse,\ttrue },\n\t{ \"restart\",\t\tdorestart,\ttrue,\tfalse },\n\t{ \"stats\",\t\tminerstats,\tfalse,\ttrue },\n\t{ \"check\",\t\tcheckcommand,\tfalse,\tfalse },\n\t{ \"failover-only\",\tfailoveronly,\ttrue,\tfalse },\n\t{ \"coin\",\t\tminecoin,\tfalse,\ttrue },\n\t{ \"debug\",\t\tdebugstate,\ttrue,\tfalse },\n\t{ \"setconfig\",\t\tsetconfig,\ttrue,\tfalse },\n#ifdef HAVE_AN_FPGA\n\t{ \"pgaset\",\t\tpgaset,\t\ttrue,\tfalse },\n\t{ \"procset\",\t\tpgaset,\t\ttrue,\tfalse },\n#endif\n\t{ \"zero\",\t\tdozero,\t\ttrue,\tfalse },\n\t{ NULL,\t\t\tNULL,\t\tfalse,\tfalse }\n};\n\nstatic void checkcommand(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, char group)\n{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tbool io_open;\n\tchar cmdbuf[100];\n\tbool found, access;\n\tint i;\n\n\tif (param == NULL || *param == '\\0') {\n\t\tmessage(io_data, MSG_MISCHK, 0, NULL, isjson);\n\t\treturn;\n\t}\n\n\tfound = false;\n\taccess = false;\n\tfor (i = 0; cmds[i].name != NULL; i++) {\n\t\tif (strcmp(cmds[i].name, param) == 0) {\n\t\t\tfound = true;\n\n\t\t\tsprintf(cmdbuf, \"|%s|\", param);\n\t\t\tif (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))\n\t\t\t\taccess = true;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmessage(io_data, MSG_CHECK, 0, NULL, isjson);\n\tio_open = io_add(io_data, isjson ? COMSTR JSON_CHECK : _CHECK COMSTR);\n\n\troot = api_add_const(root, \"Exists\", found ? YES : NO, false);\n\troot = api_add_const(root, \"Access\", access ? YES : NO, false);\n\n\troot = print_data(root, buf, isjson, false);\n\tio_add(io_data, buf);\n\tif (isjson && io_open)\n\t\tio_close(io_data);\n}\n\nstatic void head_join(struct io_data *io_data, char *cmdptr, bool isjson, bool *firstjoin)\n{\n\tchar *ptr;\n\n\tif (*firstjoin) {\n\t\tif (isjson)\n\t\t\tio_add(io_data, JSON0);\n\t\t*firstjoin = false;\n\t} else {\n\t\tif (isjson)\n\t\t\tio_add(io_data, JSON_BETWEEN_JOIN);\n\t}\n\n\t// External supplied string\n\tptr = escape_string(cmdptr, isjson);\n\n\tif (isjson) {\n\t\tio_add(io_data, JSON1);\n\t\tio_add(io_data, ptr);\n\t\tio_add(io_data, JSON2);\n\t} else {\n\t\tio_add(io_data, JOIN_CMD);\n\t\tio_add(io_data, ptr);\n\t\tio_add(io_data, BETWEEN_JOIN);\n\t}\n\n\tif (ptr != cmdptr)\n\t\tfree(ptr);\n}\n\nstatic void tail_join(struct io_data *io_data, bool isjson)\n{\n\tif (io_data->close) {\n\t\tio_add(io_data, JSON_CLOSE);\n\t\tio_data->close = false;\n\t}\n\n\tif (isjson) {\n\t\tio_add(io_data, JSON_END);\n\t\tio_add(io_data, JSON3);\n\t}\n}\n\nstatic void send_result(struct io_data *io_data, SOCKETTYPE c, bool isjson)\n{\n\tif (io_data->close)\n\t\tio_add(io_data, JSON_CLOSE);\n\t\n\tif (isjson)\n\t\tio_add(io_data, JSON_END);\n\t\n\t// Null-terminate reply, including sending the \\0 on the socket\n\tbytes_append(&io_data->data, \"\", 1);\n\t\n\tapplog(LOG_DEBUG, \"API: send reply: (%ld) '%.10s%s'\",\n\t       (long)bytes_len(&io_data->data),\n\t       bytes_buf(&io_data->data),\n\t       bytes_len(&io_data->data) > 10 ? \"...\" : BLANK);\n\t\n\tio_flush(io_data, true);\n\t\n\tif (bytes_len(&io_data->data))\n\t\tapplog(LOG_WARNING, \"RPC: Timed out with %ld bytes left to send\",\n\t\t       (long)bytes_len(&io_data->data));\n}\n\nstatic\nvoid _tidyup_socket(SOCKETTYPE * const sockp)\n{\n\tif (*sockp != INVSOCK) {\n\t\tshutdown(*sockp, SHUT_RDWR);\n\t\tCLOSESOCKET(*sockp);\n\t\t*sockp = INVSOCK;\n\t\tfree(sockp);\n\t}\n}\n\nstatic\nvoid tidyup_socket(void * const arg)\n{\n\tmutex_lock(&quit_restart_lock);\n\t_tidyup_socket(arg);\n\tmutex_unlock(&quit_restart_lock);\n}\n\nstatic void tidyup(__maybe_unused void *arg)\n{\n\tmutex_lock(&quit_restart_lock);\n\n\tSOCKETTYPE *apisock = (SOCKETTYPE *)arg;\n\n\tbye = true;\n\n\t_tidyup_socket(apisock);\n\n\tif (ipaccess != NULL) {\n\t\tfree(ipaccess);\n\t\tipaccess = NULL;\n\t}\n\n\tio_free();\n\n\tmutex_unlock(&quit_restart_lock);\n}\n\n/*\n * Interpret --api-groups G:cmd1:cmd2:cmd3,P:cmd4,*,...\n */\nstatic void setup_groups()\n{\n\tchar *api_groups = opt_api_groups ? opt_api_groups : (char *)BLANK;\n\tchar *buf, *ptr, *next, *colon;\n\tchar group;\n\tchar commands[TMPBUFSIZ];\n\tchar cmdbuf[100];\n\tchar *cmd;\n\tbool addstar, did;\n\tint i;\n\n\tbuf = malloc(strlen(api_groups) + 1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc ipgroups buf\");\n\n\tstrcpy(buf, api_groups);\n\n\tnext = buf;\n\t// for each group defined\n\twhile (next && *next) {\n\t\tptr = next;\n\t\tnext = strchr(ptr, ',');\n\t\tif (next)\n\t\t\t*(next++) = '\\0';\n\n\t\t// Validate the group\n\t\tif (*(ptr+1) != ':') {\n\t\t\tcolon = strchr(ptr, ':');\n\t\t\tif (colon)\n\t\t\t\t*colon = '\\0';\n\t\t\tquit(1, \"API invalid group name '%s'\", ptr);\n\t\t}\n\n\t\tgroup = GROUP(*ptr);\n\t\tif (!VALIDGROUP(group))\n\t\t\tquit(1, \"API invalid group name '%c'\", *ptr);\n\n\t\tif (group == PRIVGROUP)\n\t\t\tquit(1, \"API group name can't be '%c'\", PRIVGROUP);\n\n\t\tif (group == NOPRIVGROUP)\n\t\t\tquit(1, \"API group name can't be '%c'\", NOPRIVGROUP);\n\n\t\tif (apigroups[GROUPOFFSET(group)].commands != NULL)\n\t\t\tquit(1, \"API duplicate group name '%c'\", *ptr);\n\n\t\tptr += 2;\n\n\t\t// Validate the command list (and handle '*')\n\t\tcmd = &(commands[0]);\n\t\t*(cmd++) = SEPARATOR;\n\t\t*cmd = '\\0';\n\t\taddstar = false;\n\t\twhile (ptr && *ptr) {\n\t\t\tcolon = strchr(ptr, ':');\n\t\t\tif (colon)\n\t\t\t\t*(colon++) = '\\0';\n\n\t\t\tif (strcmp(ptr, \"*\") == 0)\n\t\t\t\taddstar = true;\n\t\t\telse {\n\t\t\t\tdid = false;\n\t\t\t\tfor (i = 0; cmds[i].name != NULL; i++) {\n\t\t\t\t\tif (strcasecmp(ptr, cmds[i].name) == 0) {\n\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (did) {\n\t\t\t\t\t// skip duplicates\n\t\t\t\t\tsprintf(cmdbuf, \"|%s|\", cmds[i].name);\n\t\t\t\t\tif (strstr(commands, cmdbuf) == NULL) {\n\t\t\t\t\t\tstrcpy(cmd, cmds[i].name);\n\t\t\t\t\t\tcmd += strlen(cmds[i].name);\n\t\t\t\t\t\t*(cmd++) = SEPARATOR;\n\t\t\t\t\t\t*cmd = '\\0';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tquit(1, \"API unknown command '%s' in group '%c'\", ptr, group);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr = colon;\n\t\t}\n\n\t\t// * = allow all non-iswritemode commands\n\t\tif (addstar) {\n\t\t\tfor (i = 0; cmds[i].name != NULL; i++) {\n\t\t\t\tif (cmds[i].iswritemode == false) {\n\t\t\t\t\t// skip duplicates\n\t\t\t\t\tsprintf(cmdbuf, \"|%s|\", cmds[i].name);\n\t\t\t\t\tif (strstr(commands, cmdbuf) == NULL) {\n\t\t\t\t\t\tstrcpy(cmd, cmds[i].name);\n\t\t\t\t\t\tcmd += strlen(cmds[i].name);\n\t\t\t\t\t\t*(cmd++) = SEPARATOR;\n\t\t\t\t\t\t*cmd = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tptr = apigroups[GROUPOFFSET(group)].commands = malloc(strlen(commands) + 1);\n\t\tif (unlikely(!ptr))\n\t\t\tquit(1, \"Failed to malloc group commands buf\");\n\n\t\tstrcpy(ptr, commands);\n\t}\n\n\t// Now define R (NOPRIVGROUP) as all non-iswritemode commands\n\tcmd = &(commands[0]);\n\t*(cmd++) = SEPARATOR;\n\t*cmd = '\\0';\n\tfor (i = 0; cmds[i].name != NULL; i++) {\n\t\tif (cmds[i].iswritemode == false) {\n\t\t\tstrcpy(cmd, cmds[i].name);\n\t\t\tcmd += strlen(cmds[i].name);\n\t\t\t*(cmd++) = SEPARATOR;\n\t\t\t*cmd = '\\0';\n\t\t}\n\t}\n\n\tptr = apigroups[GROUPOFFSET(NOPRIVGROUP)].commands = malloc(strlen(commands) + 1);\n\tif (unlikely(!ptr))\n\t\tquit(1, \"Failed to malloc noprivgroup commands buf\");\n\n\tstrcpy(ptr, commands);\n\n\t// W (PRIVGROUP) is handled as a special case since it simply means all commands\n\n\tfree(buf);\n\treturn;\n}\n\n/*\n * Interpret [W:]IP[/Prefix][,[R|W:]IP2[/Prefix2][,...]] --api-allow option\n *\tspecial case of 0/0 allows /0 (means all IP addresses)\n */\n#define ALLIP4 \"0/0\"\n/*\n * N.B. IP4 addresses are by Definition 32bit big endian on all platforms\n */\nstatic void setup_ipaccess()\n{\n\tchar *buf, *ptr, *comma, *slash, *dot;\n\tint ipcount, mask, octet, i;\n\tchar group;\n\n\tbuf = malloc(strlen(opt_api_allow) + 1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc ipaccess buf\");\n\n\tstrcpy(buf, opt_api_allow);\n\n\tipcount = 1;\n\tptr = buf;\n\twhile (*ptr)\n\t\tif (*(ptr++) == ',')\n\t\t\tipcount++;\n\n\t// possibly more than needed, but never less\n\tipaccess = calloc(ipcount, sizeof(struct IP4ACCESS));\n\tif (unlikely(!ipaccess))\n\t\tquit(1, \"Failed to calloc ipaccess\");\n\n\tips = 0;\n\tptr = buf;\n\twhile (ptr && *ptr) {\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (*ptr == ',') {\n\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomma = strchr(ptr, ',');\n\t\tif (comma)\n\t\t\t*(comma++) = '\\0';\n\n\t\tgroup = NOPRIVGROUP;\n\n\t\tif (VALIDGROUP(*ptr) && *(ptr+1) == ':') {\n\t\t\tif (DEFINEDGROUP(*ptr))\n\t\t\t\tgroup = GROUP(*ptr);\n\n\t\t\tptr += 2;\n\t\t}\n\n\t\tipaccess[ips].group = group;\n\n\t\tif (strcmp(ptr, ALLIP4) == 0)\n\t\t\tipaccess[ips].ip = ipaccess[ips].mask = 0;\n\t\telse {\n\t\t\tslash = strchr(ptr, '/');\n\t\t\tif (!slash)\n\t\t\t\tipaccess[ips].mask = 0xffffffff;\n\t\t\telse {\n\t\t\t\t*(slash++) = '\\0';\n\t\t\t\tmask = atoi(slash);\n\t\t\t\tif (mask < 1 || mask > 32)\n\t\t\t\t\tgoto popipo; // skip invalid/zero\n\n\t\t\t\tipaccess[ips].mask = 0;\n\t\t\t\twhile (mask-- >= 0) {\n\t\t\t\t\toctet = 1 << (mask % 8);\n\t\t\t\t\tipaccess[ips].mask |= (octet << (24 - (8 * (mask >> 3))));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tipaccess[ips].ip = 0; // missing default to '.0'\n\t\t\tfor (i = 0; ptr && (i < 4); i++) {\n\t\t\t\tdot = strchr(ptr, '.');\n\t\t\t\tif (dot)\n\t\t\t\t\t*(dot++) = '\\0';\n\n\t\t\t\toctet = atoi(ptr);\n\t\t\t\tif (octet < 0 || octet > 0xff)\n\t\t\t\t\tgoto popipo; // skip invalid\n\n\t\t\t\tipaccess[ips].ip |= (octet << (24 - (i * 8)));\n\n\t\t\t\tptr = dot;\n\t\t\t}\n\n\t\t\tipaccess[ips].ip &= ipaccess[ips].mask;\n\t\t}\n\n\t\tips++;\npopipo:\n\t\tptr = comma;\n\t}\n\n\tfree(buf);\n}\n\nstatic void *quit_thread(__maybe_unused void *userdata)\n{\n\tRenameThread(\"rpc_quit\");\n\n\t// allow thread creator to finish whatever it's doing\n\tmutex_lock(&quit_restart_lock);\n\tmutex_unlock(&quit_restart_lock);\n\n\tif (opt_debug)\n\t\tapplog(LOG_DEBUG, \"API: killing BFGMiner\");\n\n\tkill_work();\n\n\treturn NULL;\n}\n\nstatic void *restart_thread(__maybe_unused void *userdata)\n{\n\tRenameThread(\"rpc_restart\");\n\n\t// allow thread creator to finish whatever it's doing\n\tmutex_lock(&quit_restart_lock);\n\tmutex_unlock(&quit_restart_lock);\n\n\tif (opt_debug)\n\t\tapplog(LOG_DEBUG, \"API: restarting BFGMiner\");\n\n\tapp_restart();\n\n\treturn NULL;\n}\n\nstatic bool check_connect(struct sockaddr_in *cli, char **connectaddr, char *group)\n{\n\tbool addrok = false;\n\tint i;\n\n\t*connectaddr = inet_ntoa(cli->sin_addr);\n\n\t*group = NOPRIVGROUP;\n\tif (opt_api_allow) {\n\t\tint client_ip = htonl(cli->sin_addr.s_addr);\n\t\tfor (i = 0; i < ips; i++) {\n\t\t\tif ((client_ip & ipaccess[i].mask) == ipaccess[i].ip) {\n\t\t\t\taddrok = true;\n\t\t\t\t*group = ipaccess[i].group;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (opt_api_network)\n\t\t\taddrok = true;\n\t\telse\n\t\t\taddrok = (strcmp(*connectaddr, localaddr) == 0);\n\t}\n\n\treturn addrok;\n}\n\nstatic void mcast()\n{\n\tstruct sockaddr_in listen;\n\tstruct ip_mreq grp;\n\tstruct sockaddr_in came_from;\n\tstruct timeval bindstart;\n\tconst char *binderror;\n\tSOCKETTYPE *mcastsock;\n\tSOCKETTYPE reply_sock;\n\tsocklen_t came_from_siz;\n\tchar *connectaddr;\n\tssize_t rep;\n\tint bound;\n\tint count;\n\tint reply_port;\n\tbool addrok;\n\tchar group;\n\n\tchar expect[] = \"cgminer-\"; // first 8 bytes constant\n\tchar *expect_code;\n\tsize_t expect_code_len;\n\tchar buf[1024];\n\tchar replybuf[1024];\n\n\tmemset(&grp, 0, sizeof(grp));\n\tgrp.imr_multiaddr.s_addr = inet_addr(opt_api_mcast_addr);\n\tif (grp.imr_multiaddr.s_addr == INADDR_NONE)\n\t\tquit(1, \"Invalid Multicast Address\");\n\tgrp.imr_interface.s_addr = INADDR_ANY;\n\n\tmcastsock = malloc(sizeof(*mcastsock));\n\t*mcastsock = INVSOCK;\n\tpthread_cleanup_push(tidyup_socket, mcastsock);\n\t\n\t*mcastsock = bfg_socket(AF_INET, SOCK_DGRAM, 0);\n\t\n\tint optval = 1;\n\tif (SOCKETFAIL(setsockopt(*mcastsock, SOL_SOCKET, SO_REUSEADDR, (void *)(&optval), sizeof(optval)))) {\n\t\tapplog(LOG_ERR, \"API mcast setsockopt SO_REUSEADDR failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);\n\t\tgoto die;\n\t}\n\n\tmemset(&listen, 0, sizeof(listen));\n\tlisten.sin_family = AF_INET;\n\tlisten.sin_addr.s_addr = INADDR_ANY;\n\tlisten.sin_port = htons(opt_api_mcast_port);\n\n\t// try for more than 1 minute ... in case the old one hasn't completely gone yet\n\tbound = 0;\n\ttimer_set_now(&bindstart);\n\twhile (bound == 0) {\n\t\tif (SOCKETFAIL(bind(*mcastsock, (struct sockaddr *)(&listen), sizeof(listen)))) {\n\t\t\tbinderror = SOCKERRMSG;\n\t\t\tif (timer_elapsed(&bindstart, NULL) > 61)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcgsleep_ms(30000);\n\t\t} else\n\t\t\tbound = 1;\n\t}\n\n\tif (bound == 0) {\n\t\tapplog(LOG_ERR, \"API mcast bind to port %d failed (%s)%s\", opt_api_port, binderror, MUNAVAILABLE);\n\t\tgoto die;\n\t}\n\n\tif (SOCKETFAIL(setsockopt(*mcastsock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void *)(&grp), sizeof(grp)))) {\n\t\tapplog(LOG_ERR, \"API mcast join failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);\n\t\tgoto die;\n\t}\n\n\texpect_code_len = sizeof(expect) + strlen(opt_api_mcast_code);\n\texpect_code = malloc(expect_code_len+1);\n\tif (!expect_code)\n\t\tquit(1, \"Failed to malloc mcast expect_code\");\n\tsnprintf(expect_code, expect_code_len+1, \"%s%s-\", expect, opt_api_mcast_code);\n\n\tcount = 0;\n\twhile (80085) {\n\t\tcgsleep_ms(1000);\n\n\t\tcount++;\n\t\tcame_from_siz = sizeof(came_from);\n\t\tif (SOCKETFAIL(rep = recvfrom(*mcastsock, buf, sizeof(buf) - 1,\n\t\t\t\t\t\t0, (struct sockaddr *)(&came_from), &came_from_siz))) {\n\t\t\tapplog(LOG_DEBUG, \"API mcast failed count=%d (%s) (%d)\",\n\t\t\t\t\tcount, SOCKERRMSG, (int)*mcastsock);\n\t\t\tcontinue;\n\t\t}\n\n\t\taddrok = check_connect(&came_from, &connectaddr, &group);\n\t\tapplog(LOG_DEBUG, \"API mcast from %s - %s\",\n\t\t\t\t\tconnectaddr, addrok ? \"Accepted\" : \"Ignored\");\n\t\tif (!addrok)\n\t\t\tcontinue;\n\n\t\tbuf[rep] = '\\0';\n\t\tif (rep > 0 && buf[rep-1] == '\\n')\n\t\t\tbuf[--rep] = '\\0';\n\n\t\tapplog(LOG_DEBUG, \"API mcast request rep=%d (%s) from %s:%d\",\n\t\t\t\t\t(int)rep, buf,\n\t\t\t\t\tinet_ntoa(came_from.sin_addr),\n\t\t\t\t\tntohs(came_from.sin_port));\n\n\t\tif ((size_t)rep > expect_code_len && memcmp(buf, expect_code, expect_code_len) == 0) {\n\t\t\treply_port = atoi(&buf[expect_code_len]);\n\t\t\tif (reply_port < 1 || reply_port > 65535) {\n\t\t\t\tapplog(LOG_DEBUG, \"API mcast request ignored - invalid port (%s)\",\n\t\t\t\t\t\t\t&buf[expect_code_len]);\n\t\t\t} else {\n\t\t\t\tapplog(LOG_DEBUG, \"API mcast request OK port %s=%d\",\n\t\t\t\t\t\t\t&buf[expect_code_len], reply_port);\n\n\t\t\t\tcame_from.sin_port = htons(reply_port);\n\t\t\t\treply_sock = bfg_socket(AF_INET, SOCK_DGRAM, 0);\n\n\t\t\t\tsnprintf(replybuf, sizeof(replybuf),\n\t\t\t\t\t\t\t\"cgm-%s-%d-%s\",\n\t\t\t\t\t\t\topt_api_mcast_code,\n\t\t\t\t\t\t\topt_api_port, opt_api_mcast_des);\n\n\t\t\t\trep = sendto(reply_sock, replybuf, strlen(replybuf)+1,\n\t\t\t\t\t\t0, (struct sockaddr *)(&came_from),\n\t\t\t\t\t\tsizeof(came_from));\n\t\t\t\tif (SOCKETFAIL(rep)) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"API mcast send reply failed (%s) (%d)\",\n\t\t\t\t\t\t\t\tSOCKERRMSG, (int)reply_sock);\n\t\t\t\t} else {\n\t\t\t\t\tapplog(LOG_DEBUG, \"API mcast send reply (%s) succeeded (%d) (%d)\",\n\t\t\t\t\t\t\t\treplybuf, (int)rep, (int)reply_sock);\n\t\t\t\t}\n\n\t\t\t\tshutdown(reply_sock, SHUT_RDWR);\n\t\t\t\tCLOSESOCKET(reply_sock);\n\t\t\t}\n\t\t} else\n\t\t\tapplog(LOG_DEBUG, \"API mcast request was no good\");\n\t}\n\ndie:\n\t;  // statement in case pthread_cleanup_pop doesn't start with one\n\tpthread_cleanup_pop(true);\n}\n\nstatic void *mcast_thread(void *userdata)\n{\n\tpthread_detach(pthread_self());\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\n\tRenameThread(\"api_mcast\");\n\n\tmcast();\n\n\treturn NULL;\n}\n\nvoid mcast_init()\n{\n\tstruct thr_info *thr;\n\n\tthr = calloc(1, sizeof(*thr));\n\tif (!thr)\n\t\tquit(1, \"Failed to calloc mcast thr\");\n\n\tif (thr_info_create(thr, NULL, mcast_thread, thr))\n\t\tquit(1, \"API mcast thread create failed\");\n}\n\nvoid api(int api_thr_id)\n{\n\tstruct io_data *io_data;\n\tstruct thr_info bye_thr;\n\tchar buf[TMPBUFSIZ];\n\tchar param_buf[TMPBUFSIZ];\n\tSOCKETTYPE c;\n\tint n, bound;\n\tchar *connectaddr;\n\tconst char *binderror;\n\tstruct timeval bindstart;\n\tshort int port = opt_api_port;\n\tstruct sockaddr_in serv;\n\tstruct sockaddr_in cli;\n\tsocklen_t clisiz;\n\tchar cmdbuf[100];\n\tchar *cmd = NULL, *cmdptr, *cmdsbuf;\n\tchar *param;\n\tbool addrok;\n\tchar group;\n\tjson_error_t json_err;\n\tjson_t *json_config = NULL;\n\tjson_t *json_val;\n\tbool isjson;\n\tbool did, isjoin, firstjoin;\n\tint i;\n\n\tSOCKETTYPE *apisock;\n\n\tif (!opt_api_listen) {\n\t\tapplog(LOG_DEBUG, \"API not running%s\", UNAVAILABLE);\n\t\treturn;\n\t}\n\n\tapisock = malloc(sizeof(*apisock));\n\t*apisock = INVSOCK;\n\n\trpc_io_data =\n\tio_data = sock_io_new();\n\n\tmutex_init(&quit_restart_lock);\n\n\tpthread_cleanup_push(tidyup, (void *)apisock);\n\tmy_thr_id = api_thr_id;\n\n\tsetup_groups();\n\n\tif (opt_api_allow) {\n\t\tsetup_ipaccess();\n\n\t\tif (ips == 0) {\n\t\t\tapplog(LOG_WARNING, \"API not running (no valid IPs specified)%s\", UNAVAILABLE);\n\t\t\tpthread_exit(NULL);\n\t\t}\n\t}\n\n\t*apisock = bfg_socket(AF_INET, SOCK_STREAM, 0);\n\tif (*apisock == INVSOCK) {\n\t\tapplog(LOG_ERR, \"API1 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);\n\t\tpthread_exit(NULL);\n\t}\n\t\n\tmemset(&serv, 0, sizeof(serv));\n\n\tserv.sin_family = AF_INET;\n\n\tif (!opt_api_allow && !opt_api_network) {\n\t\tserv.sin_addr.s_addr = inet_addr(localaddr);\n\t\tif (serv.sin_addr.s_addr == (in_addr_t)INVINETADDR) {\n\t\t\tapplog(LOG_ERR, \"API2 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);\n\t\t\tpthread_exit(NULL);\n\t\t}\n\t}\n\n\tserv.sin_port = htons(port);\n\n#ifndef WIN32\n\t// On linux with SO_REUSEADDR, bind will get the port if the previous\n\t// socket is closed (even if it is still in TIME_WAIT) but fail if\n\t// another program has it open - which is what we want\n\tint optval = 1;\n\t// If it doesn't work, we don't really care - just show a debug message\n\tif (SOCKETFAIL(setsockopt(*apisock, SOL_SOCKET, SO_REUSEADDR, (void *)(&optval), sizeof(optval))))\n\t\tapplog(LOG_DEBUG, \"API setsockopt SO_REUSEADDR failed (ignored): %s\", SOCKERRMSG);\n#else\n\t// On windows a 2nd program can bind to a port>1024 already in use unless\n\t// SO_EXCLUSIVEADDRUSE is used - however then the bind to a closed port\n\t// in TIME_WAIT will fail until the timeout - so we leave the options alone\n#endif\n\n\t// try for more than 1 minute ... in case the old one hasn't completely gone yet\n\tbound = 0;\n\tcgtime(&bindstart);\n\twhile (bound == 0) {\n\t\tif (SOCKETFAIL(bind(*apisock, (struct sockaddr *)(&serv), sizeof(serv)))) {\n\t\t\tbinderror = SOCKERRMSG;\n\t\t\tif (timer_elapsed(&bindstart, NULL) > 61)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tapplog(LOG_WARNING, \"API bind to port %d failed - trying again in 30sec\", port);\n\t\t\t\tcgsleep_ms(30000);\n\t\t\t}\n\t\t} else\n\t\t\tbound = 1;\n\t}\n\n\tif (bound == 0) {\n\t\tapplog(LOG_ERR, \"API bind to port %d failed (%s)%s\", port, binderror, UNAVAILABLE);\n\t\tpthread_exit(NULL);\n\t}\n\n\tif (SOCKETFAIL(listen(*apisock, QUEUE))) {\n\t\tapplog(LOG_ERR, \"API3 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);\n\t\tpthread_exit(NULL);\n\t}\n\n\tif (opt_api_allow)\n\t\tapplog(LOG_WARNING, \"API running in IP access mode on port %d\", port);\n\telse {\n\t\tif (opt_api_network)\n\t\t\tapplog(LOG_WARNING, \"API running in UNRESTRICTED read access mode on port %d\", port);\n\t\telse\n\t\t\tapplog(LOG_WARNING, \"API running in local read access mode on port %d\", port);\n\t}\n\n\tif (opt_api_mcast)\n\t\tmcast_init();\n\n\twhile (!bye) {\n\t\tclisiz = sizeof(cli);\n\t\tif (SOCKETFAIL(c = accept(*apisock, (struct sockaddr *)(&cli), &clisiz))) {\n\t\t\tapplog(LOG_ERR, \"API failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);\n\t\t\tgoto die;\n\t\t}\n\n\t\taddrok = check_connect(&cli, &connectaddr, &group);\n\t\tapplog(LOG_DEBUG, \"API: connection from %s - %s\",\n\t\t\t\t\tconnectaddr, addrok ? \"Accepted\" : \"Ignored\");\n\n\t\tif (addrok) {\n\t\t\tn = recv(c, &buf[0], TMPBUFSIZ-1, 0);\n\t\t\tif (SOCKETFAIL(n))\n\t\t\t\tbuf[0] = '\\0';\n\t\t\telse\n\t\t\t\tbuf[n] = '\\0';\n\n\t\t\tif (opt_debug) {\n\t\t\t\tif (SOCKETFAIL(n))\n\t\t\t\t\tapplog(LOG_DEBUG, \"API: recv failed: %s\", SOCKERRMSG);\n\t\t\t\telse\n\t\t\t\t\tapplog(LOG_DEBUG, \"API: recv command: (%d) '%s'\", n, buf);\n\t\t\t}\n\n\t\t\tfirstjoin = isjoin = false;\n\t\t\tif (!SOCKETFAIL(n)) {\n\t\t\t\t// the time of the request in now\n\t\t\t\twhen = time(NULL);\n\t\t\t\tio_reinit(io_data);\n\t\t\t\tio_data->sock = c;\n\n\t\t\t\tdid = false;\n\n\t\t\t\tif (*buf != ISJSON) {\n\t\t\t\t\tisjson = false;\n\n\t\t\t\t\tparam = strchr(buf, SEPARATOR);\n\t\t\t\t\tif (param != NULL)\n\t\t\t\t\t\t*(param++) = '\\0';\n\n\t\t\t\t\tcmd = buf;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisjson = true;\n\n\t\t\t\t\tparam = NULL;\n\n#if JANSSON_MAJOR_VERSION > 2 || (JANSSON_MAJOR_VERSION == 2 && JANSSON_MINOR_VERSION > 0)\n\t\t\t\t\tjson_config = json_loadb(buf, n, 0, &json_err);\n#elif JANSSON_MAJOR_VERSION > 1\n\t\t\t\t\tjson_config = json_loads(buf, 0, &json_err);\n#else\n\t\t\t\t\tjson_config = json_loads(buf, &json_err);\n#endif\n\n\t\t\t\t\tif (!json_is_object(json_config)) {\n\t\t\t\t\t\tmessage(io_data, MSG_INVJSON, 0, NULL, isjson);\n\t\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t\t\t\tdid = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tjson_val = json_object_get(json_config, JSON_COMMAND);\n\t\t\t\t\t\tif (json_val == NULL) {\n\t\t\t\t\t\t\tmessage(io_data, MSG_MISCMD, 0, NULL, isjson);\n\t\t\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (!json_is_string(json_val)) {\n\t\t\t\t\t\t\t\tmessage(io_data, MSG_INVCMD, 0, NULL, isjson);\n\t\t\t\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcmd = (char *)json_string_value(json_val);\n\t\t\t\t\t\t\t\tjson_val = json_object_get(json_config, JSON_PARAMETER);\n\t\t\t\t\t\t\t\tif (json_is_string(json_val))\n\t\t\t\t\t\t\t\t\tparam = (char *)json_string_value(json_val);\n\t\t\t\t\t\t\t\telse if (json_is_integer(json_val)) {\n\t\t\t\t\t\t\t\t\tsprintf(param_buf, \"%d\", (int)json_integer_value(json_val));\n\t\t\t\t\t\t\t\t\tparam = param_buf;\n\t\t\t\t\t\t\t\t} else if (json_is_real(json_val)) {\n\t\t\t\t\t\t\t\t\tsprintf(param_buf, \"%f\", (double)json_real_value(json_val));\n\t\t\t\t\t\t\t\t\tparam = param_buf;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!did) {\n\t\t\t\t\tif (strchr(cmd, CMDJOIN)) {\n\t\t\t\t\t\tfirstjoin = isjoin = true;\n\t\t\t\t\t\t// cmd + leading+tailing '|' + '\\0'\n\t\t\t\t\t\tcmdsbuf = malloc(strlen(cmd) + 3);\n\t\t\t\t\t\tif (!cmdsbuf)\n\t\t\t\t\t\t\tquithere(1, \"OOM cmdsbuf\");\n\t\t\t\t\t\tstrcpy(cmdsbuf, \"|\");\n\t\t\t\t\t\tparam = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tcmdptr = cmd;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tdid = false;\n\t\t\t\t\t\tif (isjoin) {\n\t\t\t\t\t\t\tcmd = strchr(cmdptr, CMDJOIN);\n\t\t\t\t\t\t\tif (cmd)\n\t\t\t\t\t\t\t\t*(cmd++) = '\\0';\n\t\t\t\t\t\t\tif (!*cmdptr)\n\t\t\t\t\t\t\t\tgoto inochi;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 0; cmds[i].name != NULL; i++) {\n\t\t\t\t\t\t\tif (strcmp(cmdptr, cmds[i].name) == 0) {\n\t\t\t\t\t\t\t\tsprintf(cmdbuf, \"|%s|\", cmdptr);\n\t\t\t\t\t\t\t\tif (isjoin) {\n\t\t\t\t\t\t\t\t\tif (strstr(cmdsbuf, cmdbuf)) {\n\t\t\t\t\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstrcat(cmdsbuf, cmdptr);\n\t\t\t\t\t\t\t\t\tstrcat(cmdsbuf, \"|\");\n\t\t\t\t\t\t\t\t\thead_join(io_data, cmdptr, isjson, &firstjoin);\n\t\t\t\t\t\t\t\t\tif (!cmds[i].joinable) {\n\t\t\t\t\t\t\t\t\t\tmessage(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);\n\t\t\t\t\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\t\t\t\t\ttail_join(io_data, isjson);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tper_proc = !strncmp(cmds[i].name, \"proc\", 4);\n\t\t\t\t\t\t\t\t\t(cmds[i].func)(io_data, c, param, isjson, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tmessage(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);\n\t\t\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"API: access denied to '%s' for '%s' command\", connectaddr, cmds[i].name);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdid = true;\n\t\t\t\t\t\t\t\tif (!isjoin)\n\t\t\t\t\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\ttail_join(io_data, isjson);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!did) {\n\t\t\t\t\t\t\tif (isjoin)\n\t\t\t\t\t\t\t\thead_join(io_data, cmdptr, isjson, &firstjoin);\n\t\t\t\t\t\t\tmessage(io_data, MSG_INVCMD, 0, NULL, isjson);\n\t\t\t\t\t\t\tif (isjoin)\n\t\t\t\t\t\t\t\ttail_join(io_data, isjson);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t\t\t\t}\ninochi:\n\t\t\t\t\t\tif (isjoin)\n\t\t\t\t\t\t\tcmdptr = cmd;\n\t\t\t\t\t} while (isjoin && cmdptr);\n\t\t\t\t}\n\n\t\t\t\tif (isjson)\n\t\t\t\t\tjson_decref(json_config);\n\n\t\t\t\tif (isjoin)\n\t\t\t\t\tsend_result(io_data, c, isjson);\n\t\t\t}\n\t\t}\n\t\tshutdown(c, SHUT_RDWR);\n\t\tCLOSESOCKET(c);\n\t}\ndie:\n\t/* Blank line fix for older compilers since pthread_cleanup_pop is a\n\t * macro that gets confused by a label existing immediately before it\n\t */\n\t;\n\tpthread_cleanup_pop(true);\n\n\tif (opt_debug)\n\t\tapplog(LOG_DEBUG, \"API: terminating due to: %s\",\n\t\t\t\tdo_a_quit ? \"QUIT\" : (do_a_restart ? \"RESTART\" : (bye ? \"BYE\" : \"UNKNOWN!\")));\n\n\tmutex_lock(&quit_restart_lock);\n\n\tif (do_a_restart) {\n\t\tif (thr_info_create(&bye_thr, NULL, restart_thread, &bye_thr)) {\n\t\t\tmutex_unlock(&quit_restart_lock);\n\t\t\tquit(1, \"API failed to initiate a restart - aborting\");\n\t\t}\n\t\tpthread_detach(bye_thr.pth);\n\t} else if (do_a_quit) {\n\t\tif (thr_info_create(&bye_thr, NULL, quit_thread, &bye_thr)) {\n\t\t\tmutex_unlock(&quit_restart_lock);\n\t\t\tquit(1, \"API failed to initiate a clean quit - aborting\");\n\t\t}\n\t\tpthread_detach(bye_thr.pth);\n\t}\n\n\tmutex_unlock(&quit_restart_lock);\n}\n"
        },
        {
          "name": "arg-nonnull.h",
          "type": "blob",
          "size": 1.1875,
          "content": "/* A C macro for declaring that specific arguments must not be NULL.\n   Copyright (C) 2009-2011 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published\n   by the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools\n   that the values passed as arguments n, ..., m must be non-NULL pointers.\n   n = 1 stands for the first argument, n = 2 for the second argument etc.  */\n#ifndef _GL_ARG_NONNULL\n# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3\n#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))\n# else\n#  define _GL_ARG_NONNULL(params)\n# endif\n#endif\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.6923828125,
          "content": "#!/bin/sh -e\n# Written by Luke Dashjr in 2012-2014\n# This program is released under the terms of the Creative Commons \"CC0 1.0 Universal\" license and/or copyright waiver.\n\nbs_dir=\"$(dirname \"$0\")\"\n\nif test -z \"$NOSUBMODULES\" ; then\n\techo 'Getting submodules...'\n\t\n\t# Older versions had INSTALL in git; remove it so git can update cleanly\n\trm -f libblkmaker/INSTALL\n\t\n\t(\n\t\tcd \"${bs_dir}\"\n\t\tgit submodule update --init\n\t)\nfi\n\necho 'Running autoreconf -if...'\n(\n\tcd \"${bs_dir}\"\n\trm -rf autom4te.cache\n\trm -f aclocal.m4 ltmain.sh\n\tautoreconf -if ${AC_FLAGS}\n)\n\necho 'Updating version.h...'\nif ./gen-version.sh >version.h.new; then\n\tcmp version.h version.h.new && rm version.h.new || mv version.h.new version.h\nfi\n"
        },
        {
          "name": "avalonhost-raminst",
          "type": "blob",
          "size": 1.6728515625,
          "content": "#!/bin/sh\n# Copyright 2013 Luke Dashjr\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option) any later\n# version.  See COPYING for more details.\n\nset -e\nif test \"$#\" -lt 2; then\n\techo \"Usage: $0 <bfgminer-version> <temporary-packages...>\"\n\techo \"Example: $0 testing bfgminer screen\"\n\techo \"Installs <temporary-packages> to RAM, on an Avalon-host router\"\n\techo \"Version can be 'stable', 'testing', or any 3-digit version; eg '3.1.0'\"\n\techo \"Do NOT attempt to reverse (uninstall) except by rebooting\"\n\techo \"Do NOT attempt to use this script more than once per boot\"\n\texit 1\nfi\ndie() {\n\techo \"$@\"\n\techo 'ABORTING'\n\texit 1\n}\nif ! grep TL-WR703N /proc/cpuinfo; then\n\tdie 'This doesn'\\''t seem to be an Avalon host system'\nfi\nif test \"$USER\" != \"root\"; then\n\tdie \"Must be run as root\"\nfi\necho \"WARNING: If anything fails other than opkg and crontab, reboot ASAP\"\nsource /lib/functions.sh\nmkdir -p /tmp/root/.oldroot\nmount -o noatime,lowerdir=/rom,upperdir=/tmp/root -t overlayfs \"overlayfs:/tmp/root\" /mnt\npivot /mnt /.oldroot\nmount -o noatime,move /.oldroot/rom /rom\nsed -i 's/\\(^option[[:space:]]\\+overlay_root[[:space:]]\\+\\).*//;T;d' /etc/opkg.conf\n{\n\techo 'option overlay_root /'\n\techo \"src/gz bfgminer http://luke.dashjr.org/programs/bitcoin/files/bfgminer/$1/openwrt/12.09/ar71xx\"\n} >> /etc/opkg.conf\nshift\nset +e\nopkg update\nopkg install \"$@\"\ncrontab -r  # disabled cgminer-monitor\nset -e\nmount -o noatime,lowerdir=/,upperdir=/overlay -t overlayfs \"overlayfs:/overlay\" /mnt\npivot /mnt /.oldroot\nmount -o noatime,move /.oldroot/rom /rom\n"
        },
        {
          "name": "binloader.c",
          "type": "blob",
          "size": 5.2392578125,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#define bailout(...)  do {  \\\n\tapplog(__VA_ARGS__);  \\\n\treturn NULL;  \\\n} while(0)\n\n#define check_magic(L)  do {  \\\n\tif (1 != fread(buf, 1, 1, f))  \\\n\t\tbailout(LOG_ERR, \"%s: Error reading bitstream ('%c')\",  \\\n\t\t        repr, L);  \\\n\tif (buf[0] != L)  \\\n\t\tbailout(LOG_ERR, \"%s: Firmware has wrong magic ('%c')\",  \\\n\t\t        repr, L);  \\\n} while(0)\n\n#define read_str(eng)  do {  \\\n\tif (1 != fread(buf, 2, 1, f))  \\\n\t\tbailout(LOG_ERR, \"%s: Error reading bitstream (\" eng \" len)\",  \\\n\t\t        repr);  \\\n\tlen = (ubuf[0] << 8) | ubuf[1];  \\\n\tif (len >= sizeof(buf))  \\\n\t\tbailout(LOG_ERR, \"%s: Firmware \" eng \" too long\",  \\\n\t\t        repr);  \\\n\tif (1 != fread(buf, len, 1, f))  \\\n\t\tbailout(LOG_ERR, \"%s: Error reading bitstream (\" eng \")\",  \\\n\t\t        repr);  \\\n\tbuf[len] = '\\0';  \\\n} while(0)\n\nvoid _bitstream_not_found(const char *repr, const char *fn)\n{\n\tapplog(LOG_ERR, \"ERROR: Unable to load '%s', required for %s to work!\", fn, repr);\n\tapplog(LOG_ERR, \"ERROR: Please read README.FPGA for instructions\");\n}\n\nFILE *open_xilinx_bitstream(const char *dname, const char *repr, const char *fwfile, unsigned long *out_len)\n{\n\tchar buf[0x100];\n\tunsigned char *ubuf = (unsigned char*)buf;\n\tunsigned long len;\n\tchar *p;\n\n\tFILE *f = open_bitstream(dname, fwfile);\n\tif (!f)\n\t{\n\t\t_bitstream_not_found(repr, fwfile);\n\t\treturn NULL;\n\t}\n\tif (1 != fread(buf, 2, 1, f))\n\t\tbailout(LOG_ERR, \"%s: Error reading bitstream (magic)\",\n\t\t        repr);\n\tif (buf[0] || buf[1] != 9)\n\t\tbailout(LOG_ERR, \"%s: Firmware has wrong magic (9)\",\n\t\t        repr);\n\tif (-1 == fseek(f, 11, SEEK_CUR))\n\t\tbailout(LOG_ERR, \"%s: Firmware seek failed\",\n\t\t        repr);\n\tcheck_magic('a');\n\tread_str(\"design name\");\n\tapplog(LOG_DEBUG, \"%s: Firmware file %s info:\",\n\t       repr, fwfile);\n\tapplog(LOG_DEBUG, \"  Design name: %s\", buf);\n\tp = strrchr(buf, ';') ?: buf;\n\tp = strrchr(buf, '=') ?: p;\n\tif (p[0] == '=')\n\t\t++p;\n\tunsigned long fwusercode = (unsigned long)strtoll(p, &p, 16);\n\tif (p[0] != '\\0')\n\t\tbailout(LOG_ERR, \"%s: Bad usercode in bitstream file\",\n\t\t        repr);\n\tif (fwusercode == 0xffffffff)\n\t\tbailout(LOG_ERR, \"%s: Firmware doesn't support user code\",\n\t\t        repr);\n\tapplog(LOG_DEBUG, \"  Version: %u, build %u\", (unsigned)((fwusercode >> 8) & 0xff), (unsigned)(fwusercode & 0xff));\n\tcheck_magic('b');\n\tread_str(\"part number\");\n\tapplog(LOG_DEBUG, \"  Part number: %s\", buf);\n\tcheck_magic('c');\n\tread_str(\"build date\");\n\tapplog(LOG_DEBUG, \"  Build date: %s\", buf);\n\tcheck_magic('d');\n\tread_str(\"build time\");\n\tapplog(LOG_DEBUG, \"  Build time: %s\", buf);\n\tcheck_magic('e');\n\tif (1 != fread(buf, 4, 1, f))\n\t\tbailout(LOG_ERR, \"%s: Error reading bitstream (data len)\",\n\t\t        repr);\n\tlen = ((unsigned long)ubuf[0] << 24) | ((unsigned long)ubuf[1] << 16) | (ubuf[2] << 8) | ubuf[3];\n\tapplog(LOG_DEBUG, \"  Bitstream size: %lu\", len);\n\n\t*out_len = len;\n\treturn f;\n}\n\nbool load_bitstream_intelhex(bytes_t *rv, const char *dname, const char *repr, const char *fn)\n{\n\tchar buf[0x100];\n\tsize_t sz;\n\tuint8_t xsz, xrt;\n\tuint16_t xaddr;\n\tFILE *F = open_bitstream(dname, fn);\n\tif (!F)\n\t\treturn false;\n\twhile (!feof(F))\n\t{\n\t\tif (unlikely(ferror(F)))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Error reading '%s'\", fn);\n\t\t\tgoto ihxerr;\n\t\t}\n\t\tif (!fgets(buf, sizeof(buf), F))\n\t\t\tgoto ihxerr;\n\t\tif (unlikely(buf[0] != ':'))\n\t\t\tgoto ihxerr;\n\t\tif (unlikely(!(\n\t\t\thex2bin(&xsz, &buf[1], 1)\n\t\t && hex2bin((unsigned char*)&xaddr, &buf[3], 2)\n\t\t && hex2bin(&xrt, &buf[7], 1)\n\t\t)))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Error parsing in '%s'\", fn);\n\t\t\tgoto ihxerr;\n\t\t}\n\t\tswitch (xrt)\n\t\t{\n\t\t\tcase 0:  // data\n\t\t\t\tbreak;\n\t\t\tcase 1:  // EOF\n\t\t\t\tfclose(F);\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_ERR, \"Unsupported record type in '%s'\", fn);\n\t\t\t\tgoto ihxerr;\n\t\t}\n\t\txaddr = be16toh(xaddr);\n\t\tsz = bytes_len(rv);\n\t\tbytes_resize(rv, xaddr + xsz);\n\t\tif (sz < xaddr)\n\t\t\tmemset(&bytes_buf(rv)[sz], 0xff, xaddr - sz);\n\t\tif (unlikely(!(hex2bin(&bytes_buf(rv)[xaddr], &buf[9], xsz))))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Error parsing data in '%s'\", fn);\n\t\t\tgoto ihxerr;\n\t\t}\n\t\t// TODO: checksum\n\t}\n\t\nihxerr:\n\tfclose(F);\n\tbytes_reset(rv);\n\treturn false;\n}\n\nbool load_bitstream_bytes(bytes_t *rv, const char *dname, const char *repr, const char *fileprefix)\n{\n\tFILE *F;\n\tsize_t fplen = strlen(fileprefix);\n\tchar fnbuf[fplen + 4 + 1];\n\tint e;\n\t\n\tbytes_reset(rv);\n\tmemcpy(fnbuf, fileprefix, fplen);\n\t\n\tstrcpy(&fnbuf[fplen], \".bin\");\n\tF = open_bitstream(dname, fnbuf);\n\tif (F)\n\t{\n\t\tchar buf[0x100];\n\t\tsize_t sz;\n\t\twhile ( (sz = fread(buf, 1, sizeof(buf), F)) )\n\t\t\tbytes_append(rv, buf, sz);\n\t\te = ferror(F);\n\t\tfclose(F);\n\t\tif (unlikely(e))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Error reading '%s'\", fnbuf);\n\t\t\tbytes_reset(rv);\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n\t\n\tstrcpy(&fnbuf[fplen], \".ihx\");\n\tif (load_bitstream_intelhex(rv, dname, repr, fnbuf))\n\t\treturn true;\n\t\n\t// TODO: Xilinx\n\t\n\t_bitstream_not_found(repr, fnbuf);\n\treturn false;\n}\n"
        },
        {
          "name": "binloader.h",
          "type": "blob",
          "size": 0.5029296875,
          "content": "#ifndef BFG_BINLOADER_H\n#define BFG_BINLOADER_H\n\n#include <stdbool.h>\n#include <stdio.h>\n\n#include \"util.h\"\n\nextern void _bitstream_not_found(const char *repr, const char *fn);\nextern FILE *open_xilinx_bitstream(const char *dname, const char *repr, const char *fwfile, unsigned long *out_len);\nextern bool load_bitstream_intelhex(bytes_t *out, const char *dname, const char *repr, const char *fn);\nextern bool load_bitstream_bytes(bytes_t *out, const char *dname, const char *repr, const char *fileprefix);\n\n#endif\n"
        },
        {
          "name": "bitstreams",
          "type": "tree",
          "content": null
        },
        {
          "name": "c++defs.h",
          "type": "blob",
          "size": 11.4794921875,
          "content": "/* C++ compatible function declaration macros.\n   Copyright (C) 2010-2011 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published\n   by the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n#ifndef _GL_CXXDEFS_H\n#define _GL_CXXDEFS_H\n\n/* The three most frequent use cases of these macros are:\n\n   * For providing a substitute for a function that is missing on some\n     platforms, but is declared and works fine on the platforms on which\n     it exists:\n\n       #if @GNULIB_FOO@\n       # if !@HAVE_FOO@\n       _GL_FUNCDECL_SYS (foo, ...);\n       # endif\n       _GL_CXXALIAS_SYS (foo, ...);\n       _GL_CXXALIASWARN (foo);\n       #elif defined GNULIB_POSIXCHECK\n       ...\n       #endif\n\n   * For providing a replacement for a function that exists on all platforms,\n     but is broken/insufficient and needs to be replaced on some platforms:\n\n       #if @GNULIB_FOO@\n       # if @REPLACE_FOO@\n       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n       #   undef foo\n       #   define foo rpl_foo\n       #  endif\n       _GL_FUNCDECL_RPL (foo, ...);\n       _GL_CXXALIAS_RPL (foo, ...);\n       # else\n       _GL_CXXALIAS_SYS (foo, ...);\n       # endif\n       _GL_CXXALIASWARN (foo);\n       #elif defined GNULIB_POSIXCHECK\n       ...\n       #endif\n\n   * For providing a replacement for a function that exists on some platforms\n     but is broken/insufficient and needs to be replaced on some of them and\n     is additionally either missing or undeclared on some other platforms:\n\n       #if @GNULIB_FOO@\n       # if @REPLACE_FOO@\n       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n       #   undef foo\n       #   define foo rpl_foo\n       #  endif\n       _GL_FUNCDECL_RPL (foo, ...);\n       _GL_CXXALIAS_RPL (foo, ...);\n       # else\n       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@\n       _GL_FUNCDECL_SYS (foo, ...);\n       #  endif\n       _GL_CXXALIAS_SYS (foo, ...);\n       # endif\n       _GL_CXXALIASWARN (foo);\n       #elif defined GNULIB_POSIXCHECK\n       ...\n       #endif\n*/\n\n/* _GL_EXTERN_C declaration;\n   performs the declaration with C linkage.  */\n#if defined __cplusplus\n# define _GL_EXTERN_C extern \"C\"\n#else\n# define _GL_EXTERN_C extern\n#endif\n\n/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);\n   declares a replacement function, named rpl_func, with the given prototype,\n   consisting of return type, parameters, and attributes.\n   Example:\n     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)\n                                  _GL_ARG_NONNULL ((1)));\n */\n#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \\\n  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)\n#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \\\n  _GL_EXTERN_C rettype rpl_func parameters_and_attributes\n\n/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);\n   declares the system function, named func, with the given prototype,\n   consisting of return type, parameters, and attributes.\n   Example:\n     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)\n                                  _GL_ARG_NONNULL ((1)));\n */\n#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \\\n  _GL_EXTERN_C rettype func parameters_and_attributes\n\n/* _GL_CXXALIAS_RPL (func, rettype, parameters);\n   declares a C++ alias called GNULIB_NAMESPACE::func\n   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.\n   Example:\n     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));\n */\n#define _GL_CXXALIAS_RPL(func,rettype,parameters) \\\n  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \\\n    namespace GNULIB_NAMESPACE                                \\\n    {                                                         \\\n      rettype (*const func) parameters = ::rpl_func;          \\\n    }                                                         \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#else\n# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);\n   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);\n   except that the C function rpl_func may have a slightly different\n   declaration.  A cast is used to silence the \"invalid conversion\" error\n   that would otherwise occur.  */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \\\n    namespace GNULIB_NAMESPACE                                     \\\n    {                                                              \\\n      rettype (*const func) parameters =                           \\\n        reinterpret_cast<rettype(*)parameters>(::rpl_func);        \\\n    }                                                              \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#else\n# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIAS_SYS (func, rettype, parameters);\n   declares a C++ alias called GNULIB_NAMESPACE::func\n   that redirects to the system provided function func, if GNULIB_NAMESPACE\n   is defined.\n   Example:\n     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));\n */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n  /* If we were to write\n       rettype (*const func) parameters = ::func;\n     like above in _GL_CXXALIAS_RPL_1, the compiler could optimize calls\n     better (remove an indirection through a 'static' pointer variable),\n     but then the _GL_CXXALIASWARN macro below would cause a warning not only\n     for uses of ::func but also for uses of GNULIB_NAMESPACE::func.  */\n# define _GL_CXXALIAS_SYS(func,rettype,parameters) \\\n    namespace GNULIB_NAMESPACE                     \\\n    {                                              \\\n      static rettype (*func) parameters = ::func;  \\\n    }                                              \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#else\n# define _GL_CXXALIAS_SYS(func,rettype,parameters) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);\n   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);\n   except that the C function func may have a slightly different declaration.\n   A cast is used to silence the \"invalid conversion\" error that would\n   otherwise occur.  */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \\\n    namespace GNULIB_NAMESPACE                          \\\n    {                                                   \\\n      static rettype (*func) parameters =               \\\n        reinterpret_cast<rettype(*)parameters>(::func); \\\n    }                                                   \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#else\n# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);\n   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);\n   except that the C function is picked among a set of overloaded functions,\n   namely the one with rettype2 and parameters2.  Two consecutive casts\n   are used to silence the \"cannot find a match\" and \"invalid conversion\"\n   errors that would otherwise occur.  */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n  /* The outer cast must be a reinterpret_cast.\n     The inner cast: When the function is defined as a set of overloaded\n     functions, it works as a static_cast<>, choosing the designated variant.\n     When the function is defined as a single variant, it works as a\n     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */\n# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \\\n    namespace GNULIB_NAMESPACE                                                \\\n    {                                                                         \\\n      static rettype (*func) parameters =                                     \\\n        reinterpret_cast<rettype(*)parameters>(                               \\\n          (rettype2(*)parameters2)(::func));                                  \\\n    }                                                                         \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#else\n# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIASWARN (func);\n   causes a warning to be emitted when ::func is used but not when\n   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded\n   variants.  */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n# define _GL_CXXALIASWARN(func) \\\n   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)\n# define _GL_CXXALIASWARN_1(func,namespace) \\\n   _GL_CXXALIASWARN_2 (func, namespace)\n/* To work around GCC bug <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,\n   we enable the warning only when not optimizing.  */\n# if !__OPTIMIZE__\n#  define _GL_CXXALIASWARN_2(func,namespace) \\\n    _GL_WARN_ON_USE (func, \\\n                     \"The symbol ::\" #func \" refers to the system function. \" \\\n                     \"Use \" #namespace \"::\" #func \" instead.\")\n# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING\n#  define _GL_CXXALIASWARN_2(func,namespace) \\\n     extern __typeof__ (func) func\n# else\n#  define _GL_CXXALIASWARN_2(func,namespace) \\\n     _GL_EXTERN_C int _gl_cxxalias_dummy\n# endif\n#else\n# define _GL_CXXALIASWARN(func) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);\n   causes a warning to be emitted when the given overloaded variant of ::func\n   is used but not when GNULIB_NAMESPACE::func is used.  */\n#if defined __cplusplus && defined GNULIB_NAMESPACE\n# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \\\n   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \\\n                        GNULIB_NAMESPACE)\n# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \\\n   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)\n/* To work around GCC bug <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,\n   we enable the warning only when not optimizing.  */\n# if !__OPTIMIZE__\n#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \\\n    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \\\n                         \"The symbol ::\" #func \" refers to the system function. \" \\\n                         \"Use \" #namespace \"::\" #func \" instead.\")\n# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING\n#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \\\n     extern __typeof__ (func) func\n# else\n#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \\\n     _GL_EXTERN_C int _gl_cxxalias_dummy\n# endif\n#else\n# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \\\n    _GL_EXTERN_C int _gl_cxxalias_dummy\n#endif\n\n#endif /* _GL_CXXDEFS_H */\n"
        },
        {
          "name": "ccan-upstream",
          "type": "commit",
          "content": null
        },
        {
          "name": "ccan.bfg",
          "type": "tree",
          "content": null
        },
        {
          "name": "compat.h",
          "type": "blob",
          "size": 6.4208984375,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_COMPAT_H\n#define BFG_COMPAT_H\n\n#include \"config.h\"\n\n#include <stdbool.h>\n\n#if !(defined(WIN32) || defined(unix))\n#define unix\n#endif\n\n#if defined(LL_FOREACH) && !defined(LL_FOREACH2)\n\n// Missing from uthash before 1.9.7\n\n#define LL_DELETE2(head,del,next)                                                              \\\ndo {                                                                                           \\\n  LDECLTYPE(head) _tmp;                                                                        \\\n  if ((head) == (del)) {                                                                       \\\n    (head)=(head)->next;                                                                       \\\n  } else {                                                                                     \\\n    _tmp = head;                                                                               \\\n    while (_tmp->next && (_tmp->next != (del))) {                                              \\\n      _tmp = _tmp->next;                                                                       \\\n    }                                                                                          \\\n    if (_tmp->next) {                                                                          \\\n      _tmp->next = ((del)->next);                                                              \\\n    }                                                                                          \\\n  }                                                                                            \\\n} while (0)\n\n#define LL_FOREACH2(head,el,next)                                                              \\\n    for(el=head;el;el=(el)->next)\n\n#define LL_FOREACH_SAFE2(head,el,tmp,next)                                                     \\\n  for((el)=(head);(el) && (tmp = (el)->next, 1); (el) = tmp)\n\n#define LL_PREPEND2(head,add,next)                                                             \\\ndo {                                                                                           \\\n  (add)->next = head;                                                                          \\\n  head = add;                                                                                  \\\n} while (0)\n\n#endif\n\n#ifdef WIN32\n#include <errno.h>\n#include <fcntl.h>\n#include <time.h>\n#include <pthread.h>\n#include <sys/time.h>\n\n#include <windows.h>\n\n#ifndef __maybe_unused\n#define __maybe_unused\t\t__attribute__((unused))\n#endif\n\n  #ifndef timersub\n    #define timersub(a, b, result)                     \\\n    do {                                               \\\n      (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;    \\\n      (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \\\n      if ((result)->tv_usec < 0) {                     \\\n        --(result)->tv_sec;                            \\\n        (result)->tv_usec += 1000000;                  \\\n      }                                                \\\n    } while (0)\n  #endif\n #ifndef timeradd\n # define timeradd(a, b, result)\t\t\t      \\\n   do {\t\t\t\t\t\t\t      \\\n    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;\t      \\\n    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;\t      \\\n    if ((result)->tv_usec >= 1000000)\t\t\t      \\\n      {\t\t\t\t\t\t\t      \\\n\t++(result)->tv_sec;\t\t\t\t      \\\n\t(result)->tv_usec -= 1000000;\t\t\t      \\\n      }\t\t\t\t\t\t\t      \\\n   } while (0)\n #endif\n\n// Some versions of MingW define this, but don't handle the timeval.tv_sec case that we use\n#ifdef localtime_r\n#undef localtime_r\n#endif\n// localtime is thread-safe on Windows\n// We also use this with timeval.tv_sec, which is incorrectly smaller than time_t on Windows\n// Need to cast to time_t* to suppress warning - actual problem shouldn't be possible in practice\n#define localtime_r(timep, result)  (  \\\n\tmemcpy(result,  \\\n\t\t(  \\\n\t\t\t(sizeof(*timep) == sizeof(time_t))  \\\n\t\t\t? localtime((time_t*)timep)  \\\n\t\t\t: localtime_convert(*timep)  \\\n\t\t),  \\\n\t\tsizeof(*result)  \\\n\t)  \\\n)\n\nstatic inline\nstruct tm *localtime_convert(time_t t)\n{\n\treturn localtime(&t);\n}\n#endif\n\n#ifndef HAVE_NANOSLEEP\nextern void (*timer_set_now)(struct timeval *);\n#define cgtime(tvp)  timer_set_now(tvp)\n\nstatic inline int nanosleep(const struct timespec *req, struct timespec *rem)\n{\n\tstruct timeval tstart;\n\tDWORD msecs;\n\n\tcgtime(&tstart);\n\tmsecs = (req->tv_sec * 1000) + ((999999 + req->tv_nsec) / 1000000);\n\n\tif (SleepEx(msecs, true) == WAIT_IO_COMPLETION) {\n\t\tif (rem) {\n\t\t\tstruct timeval tdone, tnow, tleft;\n\t\t\ttdone.tv_sec = tstart.tv_sec + req->tv_sec;\n\t\t\ttdone.tv_usec = tstart.tv_usec + ((999 + req->tv_nsec) / 1000);\n\t\t\tif (tdone.tv_usec > 1000000) {\n\t\t\t\ttdone.tv_usec -= 1000000;\n\t\t\t\t++tdone.tv_sec;\n\t\t\t}\n\n\t\t\tcgtime(&tnow);\n\t\t\tif (timercmp(&tnow, &tdone, >))\n\t\t\t\treturn 0;\n\t\t\ttimersub(&tdone, &tnow, &tleft);\n\n\t\t\trem->tv_sec = tleft.tv_sec;\n\t\t\trem->tv_nsec = tleft.tv_usec * 1000;\n\t\t}\n\t\terrno = EINTR;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#undef cgtime\n#endif\n\n#ifndef HAVE_SLEEP\nstatic inline int sleep(unsigned int secs)\n{\n\tstruct timespec req, rem;\n\treq.tv_sec = secs;\n\treq.tv_nsec = 0;\n\tif (!nanosleep(&req, &rem))\n\t\treturn 0;\n\treturn rem.tv_sec + (rem.tv_nsec ? 1 : 0);\n}\n#endif\n\n#ifdef WIN32\nenum {\n\tPRIO_PROCESS\t\t= 0,\n};\n\nstatic inline int setpriority(__maybe_unused int which, __maybe_unused int who, __maybe_unused int prio)\n{\n\treturn -!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_IDLE);\n}\n\ntypedef unsigned long int ulong;\ntypedef unsigned short int ushort;\ntypedef unsigned int uint;\n\n#ifndef __SUSECONDS_T_TYPE\ntypedef long suseconds_t;\n#endif\n\n#endif /* WIN32 */\n\n#ifndef HAVE_LOG2\n#\tdefine log2(n)  (log(n) / log(2))\n#endif\n\n#ifndef HAVE_PTHREAD_CANCEL\n\n// Bionic (Android) is intentionally missing pthread_cancel, so it is implemented using pthread_kill (handled in util.c)\n#include <pthread.h>\n#include <signal.h>\n#define pthread_cancel(pth)  pthread_kill(pth, SIGTERM)\nextern void pthread_testcancel(void);\n#ifndef PTHREAD_CANCEL_ENABLE\n#define PTHREAD_CANCEL_ENABLE  0\n#define PTHREAD_CANCEL_DISABLE 1\n#endif\n#ifndef PTHREAD_CANCEL_DEFERRED\n#define PTHREAD_CANCEL_DEFERRED     0\n#define PTHREAD_CANCEL_ASYNCHRONOUS 1\n#endif\n#ifndef PTHREAD_CANCELED\n#define PTHREAD_CANCELED ((void*)-1)\n#endif\n\n#endif\n\n#endif /* __COMPAT_H__ */\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 43.6357421875,
          "content": "dnl * Copyright 2011-2016 Luke Dashjr\ndnl * Copyright 2011-2013 Con Kolivas\ndnl * Copyright 2010-2011 Jeff Garzik\ndnl * Copyright 2012 Xiangfu\ndnl * Copyright 2011 Rusty Russell\ndnl * Copyright 2011 Mark Crichton\ndnl * Copyright 2013-2014 Nate Woolls\ndnl *\ndnl * This program is free software; you can redistribute it and/or modify it\ndnl * under the terms of the GNU General Public License as published by the Free\ndnl * Software Foundation; either version 3 of the License, or (at your option)\ndnl * any later version.  See COPYING for more details.\n\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\nm4_define([v_maj], [5])\nm4_define([v_min], [5])\nm4_define([v_mic], [0])\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\nm4_define([v_ver], [v_maj.v_min.v_mic])\nm4_define([lt_rev], m4_eval(v_maj + v_min))\nm4_define([lt_cur], v_mic)\nm4_define([lt_age], v_min)\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\n\nAC_INIT([bfgminer], [v_ver], [luke-jr+bfgminer@utopios.org])\n\nAC_PREREQ([2.59c])\nAC_CANONICAL_SYSTEM\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR([miner.c])\nAC_CONFIG_HEADERS([config.h])\n\nAH_BOTTOM([\n#ifdef WIN32\n#include \"winhacks.h\"\n#endif\n])\n\nAM_INIT_AUTOMAKE([foreign subdir-objects])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nAC_USE_SYSTEM_EXTENSIONS\n\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\nm4_ifdef([v_rev], , [m4_define([v_rev], [0])])\nm4_ifdef([v_rel], , [m4_define([v_rel], [])])\nAC_DEFINE_UNQUOTED(CGMINER_MAJOR_VERSION, [v_maj], [Major version])\nAC_DEFINE_UNQUOTED(CGMINER_MINOR_VERSION, [v_min], [Minor version])\nAC_DEFINE_UNQUOTED(CGMINER_MINOR_SUBVERSION, [v_mic], [Micro version])\nversion_info=\"lt_rev:lt_cur:lt_age\"\nrelease_info=\"v_rel\"\nAC_SUBST(version_info)\nAC_SUBST(release_info)\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\n##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##\nVMAJ=v_maj\nAC_SUBST(VMAJ)\n\nAC_CANONICAL_BUILD\nAC_CANONICAL_HOST\n\ndnl Make sure anyone changing configure.ac/Makefile.am has a clue\nAM_MAINTAINER_MODE([enable])\n\ndnl Checks for programs\nAC_PROG_CC_C99\ngl_EARLY\nAC_PROG_GCC_TRADITIONAL\nAM_PROG_CC_C_O\nAC_PROG_RANLIB\nAC_PROG_CPP\nAC_PROG_SED\n\ngl_INIT\n\nAC_SYS_LARGEFILE\n\ndnl Checks for header files.\nAC_HEADER_STDC\nAC_CHECK_HEADERS(syslog.h)\nAC_CHECK_HEADERS([sys/epoll.h])\nAC_CHECK_HEADERS([sys/mman.h])\nAC_CHECK_HEADERS([sys/prctl.h])\nAC_CHECK_HEADERS([sys/file.h])\nAC_CHECK_HEADERS([sys/termios.h])\nAC_CHECK_HEADERS([sys/unistd.h])\nAC_CHECK_HEADERS([linux/spi/spidev.h])\n\nAC_CHECK_MEMBER([struct i2c_msg.buf],[\n\ttrue\n],[\n\tdnl Note the member is different here to avoid caching screwing things up\n\tAC_CHECK_MEMBER([struct i2c_msg.len],[\n\t\tAC_DEFINE([NEED_LINUX_I2C_H],[1],[Defined if linux/i2c.h is needed to supplement linux/i2c-dev.h])\n\t],[\n\t\ttrue\n\t],[\n\t\tAC_INCLUDES_DEFAULT\n\t\t#include <linux/i2c.h>\n\t\t#include <linux/i2c-dev.h>\n\t])\n],[\n\tAC_INCLUDES_DEFAULT\n\t#include <linux/i2c-dev.h>\n])\n\n# Setuid\nAC_CHECK_HEADERS([pwd.h])\n\n# Check for chroot support\nAC_CHECK_FUNCS([chroot])\n\nAC_CHECK_FUNCS([sleep])\n\nAC_FUNC_ALLOCA\n\nlowllist=\ndriverlist=\nalgolist=\noptlist=\n\nhas_fpga=no\nhas_asic=no\nneed_binloader=no\nneed_dynclock=no\nneed_gc3355=no\nneed_linux_i2c_dev=no\nneed_lowl_vcom=no\nneed_lowlevel=no\nneed_lowl_ftdi=no\nneed_lowl_hid=no\nneed_lowl_mswin=no\nneed_lowl_pci=no\nneed_lowl_spi=no\nneed_lowl_usb=no\nneed_knc_asic=no\nneed_work2d=no\nhave_cygwin=false\nhave_win32=false\nhave_macho=false\nuse_udevrules=true\nhave_udevrules=false\nAUTOSCAN_CPPFLAGS=\"\"\nAUTOSCAN_LIBS=\"\"\nDLOPEN_FLAGS=\"-ldl\"\nWS2_LIBS=\"\"\nMM_LIBS=\"\"\nMATH_LIBS=\"-lm\"\nRT_LIBS=\"\"\n\ncase $target in\n  amd64-* | x86_64-*)\n    have_x86_32=false\n    have_x86_64=true\n    bitness=\"64\"\n    ;;\n  i386-* | i486-* | i586-* | i686-* | x86-*)\n    have_x86_32=true\n    have_x86_64=false\n    bitness=\"32\"\n    ;;\n  *)\n    have_x86_32=false\n    have_x86_64=false\n    ;;\nesac\n\ncase $target in\n  *-*-mingw*)\n    have_win32=true\n    use_udevrules=false\n    DLOPEN_FLAGS=\"\"\n    WS2_LIBS=\"-lws2_32\"\n    MM_LIBS=\"-lwinmm\"\n    AC_DEFINE([_WIN32_WINNT], [0x0501], \"WinNT version for XP+ support\")\n    AC_DEFINE([FD_SETSIZE], [4096], [Maximum sockets before fd_set overflows])\n    ;;\n  *-*-cygwin*)\n\thave_cygwin=true\n    use_udevrules=false\n\t;;\n  powerpc-*-darwin*)\n    CFLAGS=\"$CFLAGS -faltivec\"\n\t\thave_macho=true\n    use_udevrules=false\n    ;;\n\t*-*-darwin*)\n\t\tLDFLAGS=\"$LDFLAGS -framework IOKit -framework CoreFoundation\"\n\t\thave_macho=true\n    use_udevrules=false\n\t\t;;\nesac\n\n\nm4_define([BFG_INCLUDE],\n\tif test \"x$2\" = \"x\"; then\n\t\t$1=''\n\telse\n\t\t$1=\"[#]include <$2>\"\n\tfi\n)\n\nm4_define([BFG_PREPROC_IFELSE],\n\tBFG_INCLUDE([headerinclude], $2)\n\tAC_COMPILE_IFELSE([\n\t\tAC_LANG_PROGRAM([\n\t\t\t${headerinclude}\n\t\t], [\n\t\t\t#if !( $1 )\n\t\t\t#error \"$1 false in preprocessor\"\n\t\t\t#endif\n\t\t])\n\t],[$3],[$4])\n)\n\nm4_define([BFG_FIND_INCLUDE_PATH],[\n\tm4_pushdef([_rel_path],[$1])\n\tm4_pushdef([_header_file],[$2])\n\tm4_pushdef([_iffound],[$3])\n\tm4_pushdef([_ifnotfound],[$4])\n\tm4_pushdef([_includes],[$5])\n\tm4_pushdef([_result_var],[inclpath_[]patsubst(_header_file,[[./]],[_])])\n\tAC_CHECK_HEADER([_rel_path/_header_file],[\n\t\tAC_MSG_CHECKING([_header_file path])\n\t\t_result_var=`echo '[#]include <'\"_rel_path\"'/_header_file>' | ${CPP} -M - 2>/dev/null | ${SED} [-E -e ':a' -e '/\\\\$/!b b' -e N -e 's/\\\\\\n/ /' -e 't a' -e ':b' -e 's/^[^:]*:[[:space:]]*(([^[:space:]\\]|\\\\.)*[[:space:]])*(([^[:space:]\\]|\\\\.)*)(\\\\|\\\\\\\\|\\/)?]patsubst([_header_file],[\\.],[\\\\.])[([[:space:]].*)?$/\\3/' -e 't' -e d]`\n\t\tif test \"x$_result_var\" = \"x\"; then\n\t\t\tAC_MSG_RESULT([failed])\n\t\t\tAC_MSG_ERROR([Couldn't determine include path for _header_file])\n\t\telse\n\t\t\tAC_MSG_RESULT([$_result_var])\n\t\t\t_iffound\n\t\tfi\n\t],[\n\t\ttrue\n\t\t_ifnotfound\n\t],[\n\t\t_includes\n\t])\n\tm4_popdef([_rel_path],[_header_file],[_iffound],[_ifnotfound],[_result_var])\n])\n\nbfg_enableaction() {\n\t_var=$1\n\teval \"_missingdeps=\\\"\\$${_var}_missingdeps\\\"\"\n\tif test -n \"$_missingdeps\"; then\n\t\t_enableaction=\n\t\tfor _missingdep in $_missingdeps; do\n\t\t\teval \"_howto=\\\"\\$howto_${_missingdep}\\\"\"\n\t\t\tif test \"x$_howto\" = \"x\"; then\n\t\t\t\teval \"_label=\\\"\\${label_${_missingdep}-${_missingdep}}\\\"\"\n\t\t\t\t_howto=\"enable $_label\"\n\t\t\tfi\n\t\t\tif test \"$_howto\" != \"x\"; then\n\t\t\t\t_enableaction=\"$_enableaction; $_howto\"\n\t\t\tfi\n\t\tdone\n\t\t_enableaction=\"${_enableaction:2}\"\n\telse\n\t\teval \"_enableaction=\\\"\\$${_var}_enableaction\\\"\"\n\tfi\n\techo \"$_enableaction\"\n}\n\ndnl _BFG_AUTOITEM(list,driver,DriverName,dependency list,default:no/auto,CodeIfEnabled)\nm4_define([_BFG_AUTOITEM],[\n\tm4_pushdef([_list],[$1])\n\tm4_pushdef([_this_drv],m4_default([$2],m4_tolower([$3])))\n\tm4_pushdef([_this_drvuc],m4_toupper(_this_drv))\n\tm4_pushdef([_this_USE],USE_[]_this_drvuc)\n\tm4_pushdef([_this_name],[$3])\n\tm4_pushdef([_deplist],[$4])\n\tm4_pushdef([_this_default],[$5])\n\tm4_pushdef([_this_enablecode],[$6])\n\tm4_case(_list,\n\t\t[algo],[algolist=\"$algolist []_this_name/[]_this_USE\"],\n\t\t[driver],[driverlist=\"$driverlist []_this_drv/[]_this_USE\"],\n\t\t[]\n\t)\n\tlabel_[]_this_drvuc=\"[]_this_name\"\n\tAC_ARG_ENABLE([]_this_drv,\n\t\tm4_bmatch(_this_default,[.*no$],\n\t\t\tAC_HELP_STRING([--enable-[]_this_drv],[Compile support for ]_this_name[ (default disabled)]),\n\t\t\tAC_HELP_STRING([--disable-[]_this_drv],[Compile support for ]_this_name[ (default enabled)])),\n\t\t[[]_this_USE=$enableval],\n\t\t[[]_this_USE=[]_this_default]\n\t\t)\n\t[]_this_drv[]_opt=\n\tif test \"x$[]_this_USE\" = \"xno\"; then\n\t\ttrue\n\telse\n\t\tif test \"x$[]_this_USE\" = xauto; then\n\t\t\t_wasauto=yes\n\t\telse\n\t\t\t_wasauto=no\n\t\tfi\n\t\tif test \"x$[]_this_USE\" != xyes; then\n\t\t\tif test \"x$[]_this_USE\" != xauto; then\n\t\t\t\t[]_this_drv[]_opt=\"$[]_this_USE\"\n\t\t\tfi\n\t\t\t[]_this_USE=yes\n\t\tfi\n\t\tfor __drvdep in []m4_toupper(_deplist); do\n\t\t\teval \"_drvdep=\\\"\\$USE_$__drvdep\\\"\"\n\t\t\tif test \"x$_drvdep\" != \"xyes\"; then\n\t\t\t\t[]_this_USE[]_missingdeps=\"$[]_this_USE[]_missingdeps $__drvdep\"\n\t\t\t\t[]_this_USE=no\n\t\t\tfi\n\t\tdone\n\t\tif test \"x$[]_this_USE[]$_wasauto\" = xnono; then\n\t\t\t_enableaction=`bfg_enableaction []_this_USE`\n\t\t\tAC_MSG_ERROR([To enable []_this_name: $_enableaction])\n\t\tfi\n\tfi\n\tif test \"x$[]_this_USE\" = \"xyes\"; then\n\t\tAC_DEFINE([]_this_USE,[1],[Defined to 1 if []_this_name support is wanted])\n\t\t[]_this_enablecode\n\tfi\n\tAM_CONDITIONAL([]_this_USE,[test x$[]_this_USE = xyes])\n\tm4_popdef([_this_drv],[_this_drvuc],[_this_USE],[_this_name],[_deplist],[_this_default],[_this_enablecode])\n])\n\ndnl BFG_ALGO(AlgoName,default:no/yes,CodeIfEnabled)\nm4_define([BFG_ALGO],[\n\t_BFG_AUTOITEM([algo],,[$1],,[$2],[$3])\n])\n\ndnl BFG_DRIVER(driver,DriverName,dependency list,default:no/auto,CodeIfEnabled)\nm4_define([BFG_DRIVER],[\n\t_BFG_AUTOITEM([driver],[$1],[$2],[$3],$dd[$4],[$5])\n])\n\n\nAC_CHECK_DECL([HASH_ITER],[\n\tAC_CHECK_DECL([DL_CONCAT],[\n\t\ttrue\n\t],[\n\t\tAC_MSG_ERROR([Could not find DL_FOREACH_SAFE - install uthash-dev 1.9.4+])\n\t],[\n\t\t#include <utlist.h>\n\t])\n],[\n\tAC_MSG_ERROR([Could not find HASH_ITER - please install uthash-dev 1.9.4+])\n],[\n\t#include <uthash.h>\n])\n\n\nddyes=yes\nddauto=auto\nddno=no\nAC_ARG_ENABLE([other-drivers],\n\t[AC_HELP_STRING([--disable-other-drivers],[Build without drivers by default unless explicitly enabled])],\n\t[\n\t\tif test x$enableval = xyes; then\n\t\t\tddno=yes\n\t\telse\n\t\t\tddyes=no\n\t\t\tddauto=no\n\t\tfi\n\t]\n)\n\n\nbroad_udevrules=false\nAC_ARG_ENABLE([broad-udevrules],\n\t[AC_HELP_STRING([--enable-broad-udevrules],[Include udev rules for ambiguous devices which may not be miners])],\n\t[\n\t\tif test \"x$enableval\" = \"xyes\"; then\n\t\t\tbroad_udevrules=true\n\t\tfi\n\t]\n)\n\nuse_udevrules_group=true\nudevrules_group=\"video\"\nAC_ARG_WITH([udevrules-group],\n\t[AC_HELP_STRING([--with-udevrules-group=groupname],[Configure mining devices to be owned by a specific group (default `video')])],\n\t[\n\t\tif test \"x$withval\" = \"xno\"; then\n\t\t\tuse_udevrules_group=false\n\t\telse\n\t\t\tudevrules_group=\"$withval\"\n\t\tfi\n\t]\n)\nAM_CONDITIONAL([USE_UDEVRULES_GROUP], [$use_udevrules_group])\nAC_SUBST([UDEVRULES_GROUP], [$udevrules_group])\n\n\nBFG_ALGO(Keccak,no)\nBFG_ALGO(SHA256d,yes)\nBFG_ALGO(scrypt,no)\n\nlowl_pci=no\nif test \"x$ac_cv_header_sys_mman_h\" = \"xyes\"; then\n\tAC_ARG_WITH([uio],\n\t\t[AC_HELP_STRING([--without-uio],[Compile support for PCI devices via Linux UIO interface (default enabled)])],\n\t\t[uio=$withval],\n\t\t[uio=yes])\n\tAC_ARG_WITH([vfio],\n\t\t[AC_HELP_STRING([--without-vfio],[Compile support for PCI devices via Linux VFIO interface (default enabled)])],\n\t\t[vfio=$withval],\n\t\t[vfio=auto])\n\tif test \"x$vfio\" != \"xno\"; then\n\t\tAC_CHECK_HEADER([linux/vfio.h],[\n\t\t\tvfio=yes\n\t\t],[\n\t\t\tif test \"x$vfio\" = \"xyes\"; then\n\t\t\t\tAC_MSG_ERROR([Unable to find linux/vfio.h])\n\t\t\telif test \"x$uio\" = \"xyes\"; then\n\t\t\t\tAC_MSG_WARN([linux/vfio.h not found; PCI device support will require UIO (and root access)])\n\t\t\telse\n\t\t\t\tAC_MSG_WARN([linux/vfio.h not found; PCI device support will not be available])\n\t\t\tfi\n\t\t\tvfio=no\n\t\t])\n\tfi\n\tif test \"x$vfio$uio\" != xnono; then\n\t\tlowl_pci=yes\n\tfi\nfi\n\n\nBFG_DRIVER(cpumining,CPU mining,,no,[\n\tdriverlist=\"$driverlist cpu:asm/has_yasm\"\n\tdriverlist=\"$driverlist cpu:sse2/have_sse2\"\n])\ndriverlist=`echo \"${driverlist}\" | ${SED} -e 's/ cpumining/ cpu/'`\n\nBFG_DRIVER(,OpenCL,,no)\n\nm4_define([BFG_PTHREAD_FLAG_CHECK],\n\tAC_MSG_CHECKING([for $1])\n\tfor cflag in ' -pthread' ''; do\n\t\tfor lib in ' -lpthread' ' -lwinpthread' ''; do\n\t\t\tCFLAGS=\"${save_CFLAGS}${cflag}\"\n\t\t\tLIBS=\"${save_LIBS}${lib}\"\n\t\t\tAC_LINK_IFELSE([\n\t\t\t\tAC_LANG_PROGRAM([\n\t\t\t\t\t#include <pthread.h>\n\t\t\t\t], [\n\t\t\t\t\tvoid *f = $1;\n\t\t\t\t])\n\t\t\t], [\n\t\t\t\tfound_pthread=true\n\t\t\t\tPTHREAD_FLAGS=\"${cflag}\"\n\t\t\t\tPTHREAD_LIBS=\"${lib}\"\n\t\t\t\tif test \"x${cflag}${lib}\" = \"x\"; then\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\telse\n\t\t\t\t\tAC_MSG_RESULT([with${cflag}${lib}])\n\t\t\t\tfi\n\t\t\t\t$2\n\t\t\t\tbreak 2\n\t\t\t])\n\t\tdone\n\tdone\n\tif test \"x${found_pthread}\" = \"xfalse\"; then\n\t\tAC_MSG_RESULT([no])\n\tfi\n)\n\nsave_CFLAGS=\"${CFLAGS}\"\nsave_LIBS=\"${LIBS}\"\nfound_pthread=false\nBFG_PTHREAD_FLAG_CHECK([pthread_cancel],[\n\tAC_DEFINE([HAVE_PTHREAD_CANCEL], [1], [Define if you have a native pthread_cancel])\n])\nif test \"x${found_pthread}\" = \"xfalse\"; then\n\tBFG_PTHREAD_FLAG_CHECK([pthread_create])\n\tif test \"x${found_pthread}\" = \"xfalse\"; then\n\t\tAC_MSG_ERROR([Could not find pthread library - please install libpthread])\n\tfi\nfi\n# check for nanosleep here, since it is provided by winpthread\nAC_CHECK_FUNCS([nanosleep])\nCFLAGS=\"${save_CFLAGS}\"\nLIBS=\"${save_LIBS}\"\n\nPKG_CHECK_MODULES([JANSSON],[jansson],[\n\ttrue\n],[\n\tAC_MSG_CHECKING([for jansson in system-default locations])\n\tLIBS=\"$LIBS -ljansson\"\n\tAC_TRY_LINK([\n\t\t#include <jansson.h>\n\t],[\n\t\tjson_object();\n\t],[\n\t\tAC_MSG_RESULT([found])\n\t\tJANSSON_LIBS=-ljansson\n\t],[\n\t\tAC_MSG_RESULT([not found])\n\t\tAC_MSG_ERROR([Could not find jansson library])\n\t])\n\tLIBS=\"${save_LIBS}\"\n])\nAC_SUBST(JANSSON_CFLAGS)\nAC_SUBST(JANSSON_LIBS)\n\nif test \"x$USE_OPENCL\" = xyes; then\n\tadl=\"yes\"\n\t\n\tif test \"x$USE_KECCAK\" = xyes; then\n\t\tAC_DEFINE([USE_OPENCL_FULLHEADER],[1],[Defined to 1 if OpenCL fullheader kernel interface is wanted])\n\tfi\n\t\ndriverlist=\"$driverlist opencl:sensors/with_sensors\"\nAC_ARG_WITH([sensors],\n\t[AC_HELP_STRING([--without-sensors],[Build with libsensors monitoring (default enabled)])],\n\t[true],[with_sensors=auto])\nif test \"x$USE_OPENCL\" != xyes; then\n\twith_sensors=no\nfi\nif test \"x$with_sensors\" != xno; then\n\tAC_MSG_CHECKING([for libsensors])\n\tsave_LIBS=\"${LIBS}\"\n\tLIBS=\"$LIBS -lsensors\"\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([\n\t\t#include <stddef.h>\n\t\t#include <sensors/sensors.h>\n\t],[\n\t\tconst sensors_chip_name *cn;\n\t\tcn = sensors_get_detected_chips(NULL, NULL);\n\t])],[\n\t\twith_sensors=yes\n\t\tsensors_LIBS=\"-lsensors\"\n\t\tAC_DEFINE([HAVE_SENSORS], [1], [Defined if libsensors was found])\n\t\tAC_MSG_RESULT([yes])\n\t],[\n\t\twith_sensors=no\n\t\tAC_MSG_RESULT([no])\n\t\tif ! $have_win32; then\n\t\t\twith_sensors_enableaction=\"install libsensors\"\n\t\tfi\n\t])\n\tLIBS=\"$save_LIBS\"\nfi\nAC_SUBST(sensors_LIBS)\n\ndriverlist=\"$driverlist opencl:adl/adl\"\nAC_ARG_ENABLE([adl],\n\t[AC_HELP_STRING([--disable-adl],[Build without ADL monitoring (default enabled)])],\n\t[adl=$enableval]\n\t)\n\n\tif test x$adl = xyes\n\t\tthen\n\t\t\tAC_DEFINE([HAVE_ADL], [1], [Defined if ADL headers were found])\n\t\tfi\nelse\n\tadl=\"no\"\nfi\n\nBFG_DRIVER(,AlcheMist,scrypt,no,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n])\n\nBFG_DRIVER(,BitForce,SHA256d,auto,[\n\tdriverlist=\"$driverlist bitforce:pci/need_lowl_pci\"\n\tif test \"x$lowl_pci\" = \"xyes\"; then\n\t\tneed_lowl_pci=yes\n\tfi\n\tneed_lowl_vcom=yes\n\tdriverlist=\"$driverlist bitforce:mswin/need_lowl_mswin\"\n\tif test x$have_win32 = xtrue; then\n\t\tneed_lowl_mswin=yes\n\tfi\n\thas_fpga=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(bitmain,Bitmain Antminer S* series,SHA256d,no,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n])\n\nBFG_DRIVER(,Icarus,SHA256d,auto,[\n\tneed_dynclock=yes\n\tneed_lowl_vcom=yes\n\thas_fpga=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\ndriverlist=\"$driverlist cairnsmore/USE_ICARUS erupter/USE_ICARUS antminer/USE_ICARUS compac/USE_ICARUS\"\n\nBFG_DRIVER(,DualMiner,Icarus,auto,[\n\tneed_gc3355=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(,ZeusMiner,scrypt Icarus,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(,GridSeed,scrypt,auto,[\n\tneed_gc3355=yes\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(,Avalon,SHA256d,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(avalonmm,Avalon2/3,SHA256d,auto,[\n\tneed_lowl_vcom=yes\n\tneed_work2d=yes\n\thas_asic=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(,KnC,SHA256d,no,[\n\tneed_linux_i2c_dev=yes\n\tneed_lowl_spi=yes\n])\n\nBFG_DRIVER(kncasic,KnC gen 2,SHA256d,no,[\n\tkncasic_controller=\"$kncasic_opt\"\n\tif test \"x$kncasic_opt\" = \"x\"; then\n\t\tkncasic_controller=BBB\n\tfi\n\tneed_knc_asic=yes\n\tAC_DEFINE_UNQUOTED([CONTROLLER_BOARD_$kncasic_controller],[1])\n])\n\nAC_ARG_WITH([libmicrohttpd],\n\t[AC_HELP_STRING([--without-libmicrohttpd],[Compile support for libmicrohttpd getwork server (default enabled)])],\n\t[httpsrv=$withval],\n\t[httpsrv=$ddauto]\n)\nif test \"x$httpsrv\" != \"xno\"; then\n\tPKG_CHECK_MODULES([libmicrohttpd],[libmicrohttpd >= 0.9.5],[\n\t\tAC_DEFINE([USE_LIBMICROHTTPD],[1],[Defined to 1 if libmicrohttpd support is wanted])\n\t\thttpsrv=yes\n\t],[\n\t\thttpsrv=no\n\t\thttpsrv_enableaction=\"install libmicrohttpd 0.9.5+\"\n\t\tneed_bfg_driver_proxy_enableaction=\"install libmicrohttpd 0.9.5+\"\n\t\tif test \"x$httpsrv\" = \"xyes\"; then\n\t\t\tAC_MSG_ERROR([Unable to find libmicrohttpd 0.9.5+])\n\t\telse\n\t\t\tAC_MSG_WARN([libmicrohttpd 0.9.5+ not found; getwork proxy will be unavailable])\n\t\tfi\n\t])\nfi\nAM_CONDITIONAL([USE_LIBMICROHTTPD], [test x$httpsrv = xyes])\n\nAC_ARG_WITH([libevent],\n\t[AC_HELP_STRING([--without-libevent],[Compile support for libevent stratum server (default enabled)])],\n\t[libevent=$withval],\n\t[libevent=$ddauto]\n)\nif test \"x$libevent\" != \"xno\"; then\n\tPKG_CHECK_MODULES([libevent],[libevent >= 2.0.3],[\n\t\tPKG_CHECK_MODULES([libevent_pthreads],[libevent_pthreads],[\n\t\t\tlibevent_CFLAGS=\"${libevent_CFLAGS} ${libevent_pthreads_CFLAGS}\"\n\t\t\tlibevent_LIBS=\"${libevent_LIBS} ${libevent_pthreads_LIBS}\"\n\t\t],[true])\n\t\tAC_MSG_CHECKING([if libevent supports threading])\n\t\tBFG_PREPROC_IFELSE([EVTHREAD_USE_PTHREADS_IMPLEMENTED || EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED],[event2/thread.h],[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\thave_libevent=yes\n\t\t],[\n\t\t\tAC_MSG_RESULT([no])\n\t\t])\n\t])\n\tif test \"x$have_libevent\" = \"xyes\"; then\n\t\tlibevent=yes\n\t\tneed_work2d=yes\n\t\tAC_DEFINE([USE_LIBEVENT],[1],[Defined to 1 if libevent support is wanted])\n\telse\n\t\tlibevent_enableaction=\"install libevent 2.0.3+\"\n\t\tif test -n \"$need_bfg_driver_proxy_enableaction\"; then\n\t\t\tneed_bfg_driver_proxy_enableaction=\"${need_bfg_driver_proxy_enableaction} (getwork) or libevent 2.0.3+ (stratum)\"\n\t\telse\n\t\t\tneed_bfg_driver_proxy_enableaction=\"install libevent 2.0.3+\"\n\t\tfi\n\t\tif test \"x$libevent\" = \"xyes\"; then\n\t\t\tAC_MSG_ERROR([Unable to find libevent 2.0.3+])\n\t\telse\n\t\t\tAC_MSG_WARN([libevent 2.0.3+ not found; stratum proxy will be unavailable])\n\t\tfi\n\t\tlibevent=no\n\tfi\nfi\nAM_CONDITIONAL([USE_LIBEVENT], [test x$libevent = xyes])\n\ndriverlist=\"$driverlist proxy/need_bfg_driver_proxy\"\nif test x$libevent$httpsrv = xnono; then\n\tneed_bfg_driver_proxy=no\nelse\n\tneed_bfg_driver_proxy=yes\n\tdriverlist=\"$driverlist proxy:getwork/httpsrv proxy:stratum/libevent\"\nfi\nAM_CONDITIONAL([NEED_BFG_DRIVER_PROXY], [test x$libevent$httpsrv != xnono])\n\nBFG_DRIVER(,ModMiner,SHA256d,auto,[\n\tneed_dynclock=yes\n\tneed_lowl_vcom=yes\n\tneed_binloader=yes\n\thas_fpga=yes\n\thave_udevrules=true\n])\n\nPKG_PROG_PKG_CONFIG()\n\nlabel_LIBUSB=libusb\nUSE_LIBUSB=no\nlibusb_include_path=\"\"\nAC_ARG_WITH([libusb],\n\t[AC_HELP_STRING([--without-libusb],[Compile using libusb (default enabled)])],\n\t[want_libusb=$withval],\n\t[want_libusb=auto]\n\t)\nif test \"x$want_libusb\" != \"xno\"; then\n\thowto_LIBUSB=\"install libusb 1.0+\"\nPKG_CHECK_MODULES([LIBUSB], [libusb-1.0],[\n\tUSE_LIBUSB=yes\n],[\n\tfor usb_lib in usb-1.0 usb; do\n\t\tAC_CHECK_LIB($usb_lib, libusb_init, [\n\t\t\tUSE_LIBUSB=yes\n\t\t\tbreak\n\t\t])\n\tdone\n\tif test \"x$USE_LIBUSB\" = xyes; then\n\t\t\tAC_CHECK_DECL([libusb_init],[\n\t\t\t\tLIBUSB_LIBS=\"-l$usb_lib\"\n\t\t\t],[\n\t\t\t\tBFG_FIND_INCLUDE_PATH([libusb-1.0],[libusb.h],[\n\t\t\t\t\tLIBUSB_LIBS=\"-l$usb_lib\"\n\t\t\t\t\tLIBUSB_CFLAGS=\"-I${inclpath_libusb_h}\"\n\t\t\t\t],[\n\t\t\t\t\tUSE_LIBUSB=no\n\t\t\t\t])\n\t\t\t],[#include <libusb.h>])\n\tfi\n])\nfi\n\nBFG_DRIVER(,CoinTerra,SHA256d libusb,auto,[\n\tneed_lowl_usb=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,Klondike,SHA256d libusb,auto,[\n\tneed_lowl_usb=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(titan,KnC Titan,scrypt,no,[\n\tif test \"x$titan_opt\" = \"x\"; then\n\t\tif test \"x$USE_KNCASIC\" = \"xyes\"; then\n\t\t\ttitan_controller=\"$kncasic_controller\"\n\t\telse\n\t\t\ttitan_controller=RPI\n\t\tfi\n\telse\n\t\ttitan_controller=$titan_opt\n\t\tif test \"x$USE_KNCASIC\" = \"xyes\"; then\n\t\t\tif test \"x$kncasic_controller\" != \"$titan_controller\"; then\n\t\t\t\tAC_MSG_ERROR([Can only build kncasic and titan drivers together for the same controller (kncasic=$kncasic_controller vs titan=$titan_controller)])\n\t\t\tfi\n\t\tfi\n\tfi\n\tneed_knc_asic=yes\n\tAC_DEFINE_UNQUOTED([CONTROLLER_BOARD_$titan_controller],[1])\n\tAH_TEMPLATE([CONTROLLER_BOARD_BACKPLANE])\n\tAH_TEMPLATE([CONTROLLER_BOARD_BBB])\n\tAH_TEMPLATE([CONTROLLER_BOARD_RPI])\n])\n\nBFG_DRIVER(,X6500,SHA256d libusb,auto,[\n\tneed_dynclock=yes\n\tneed_lowl_ftdi=yes\n\tneed_binloader=yes\n\thas_fpga=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,ZTEX,SHA256d libusb,auto,[\n\tneed_dynclock=yes\n\tneed_lowl_usb=yes\n\tneed_binloader=yes\n\thas_fpga=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(bifury,Bi*Fury,SHA256d,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,Bitfury,SHA256d,auto,[\n\tneed_lowl_spi=yes\n])\n\nBFG_DRIVER(,BFSB,SHA256d Bitfury,no)\n\nBFG_DRIVER(bigpic,Big Picture Mining USB,SHA256d Bitfury,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(bfx,BFx2,SHA256d libusb Bitfury,auto,[\n\tneed_lowl_ftdi=yes\n\thas_asic=yes\n\t$broad_udevrules && have_udevrules=true\n])\n\nBFG_DRIVER(,DrillBit,SHA256d Bitfury,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,Twinfury,SHA256d Bitfury,auto,[\n    need_lowl_vcom=yes\n    has_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,LittleFury,SHA256d Bitfury,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\n\nlabel_HIDAPI=hidapi\nhowto_HIDAPI=\"install hidapi\"\nUSE_HIDAPI=no\nfor _hidapi_lib in hidapi hidapi-hidraw hidapi-libusb; do\n\tPKG_CHECK_MODULES([hidapi],[$_hidapi_lib],[\n\t\tUSE_HIDAPI=yes\n\t\tbreak\n\t],[\n\t\ttrue\n\t])\ndone\n\n\nBFG_DRIVER(,NanoFury,SHA256d hidapi Bitfury,auto,[\n\tneed_lowl_hid=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(hashbuster,HashBuster Nano,SHA256d hidapi Bitfury,auto,[\n\tneed_lowl_hid=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(hashbusterusb,HashBuster Micro,SHA256d libusb Bitfury,auto,[\n\tneed_lowl_usb=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,HashFast,SHA256d,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\nBFG_DRIVER(,JingTian,SHA256d,no,[\n\tneed_lowl_spi=yes\n\thas_asic=yes\n])\n\nBFG_DRIVER(,Metabank,SHA256d Bitfury,no)\n\nBFG_DRIVER(minergate,Spondoolies minergate interface,SHA256d,no,[\n\tneed_lowlevel=yes\n\thas_asic=yes\n])\n\nBFG_DRIVER(,Minion,SHA256d,no,[\n\tneed_lowl_spi=yes\n\thas_asic=yes\n])\n\nBFG_DRIVER(,RockMiner,SHA256d,auto,[\n\tneed_lowl_vcom=yes\n\thas_asic=yes\n\thave_udevrules=true\n])\n\n\nif test \"x$need_lowl_vcom\" != \"xno\"; then\n\t# Lowlevel VCOM doesn't need libusb, but it can take advantage of it to reattach drivers\n\tif test \"x$USE_LIBUSB\" != xno; then\n\t\tneed_lowl_usb=yes\n\telif test \"x$USE_LIBUSB$want_libusb\" = xnoyes; then\n\t\tAC_MSG_ERROR([Could not find libusb, which you specifically requested])\n\tfi\nfi\n\nlowllist=\"$lowllist ftdi/need_lowl_ftdi\"\nif test x$need_lowl_ftdi = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_FTDI], [1], [Defined to 1 if lowlevel ftdi drivers are being used])\n\tneed_lowl_usb=yes\nfi\n\nlowllist=\"$lowllist spi/need_lowl_spi\"\nif test x$need_lowl_spi = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_SPI], [1], [Defined to 1 if lowlevel SPI drivers are being used])\nfi\n\nif test \"x$need_lowl_usb\" = \"xno\"; then\n\tUSE_LIBUSB=no\n\tLIBUSB_LIBS=''\n\tLIBUSB_CFLAGS=''\nfi\nif test \"x$USE_LIBUSB\" = xyes; then\n\tAC_DEFINE([HAVE_LIBUSB], [1], [Define if you have libusb-1.0])\n\tsave_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$LIBUSB_CFLAGS $CFLAGS\"\n\tAC_CHECK_DECLS([libusb_error_name],[true],[true],[#include <libusb.h>])\n\tCFLAGS=\"$save_CFLAGS\"\nfi\n\n\nif test x$need_lowl_vcom = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_VCOM], [1], [Defined to 1 if lowlevel VCOM drivers are being used])\n\tneed_lowlevel=yes\n\t\n\tif $have_win32; then\n\t\techo '#include <iospeeds.h>' >iospeeds_local.h\n\t\t\n\t\tfound_ddkusb=false\n\t\tAC_CHECK_HEADER([usbiodef.h],[\n\t\t\tfound_ddkusb=true\n\t\t],[\n\t\t\tBFG_FIND_INCLUDE_PATH([ddk],[usbiodef.h],[\n\t\t\t\tfound_ddkusb=true\n\t\t\t\tAUTOSCAN_CPPFLAGS=\"-I${inclpath_usbiodef_h}\"\n\t\t\t],[],[\n\t\t\t\t#include <windows.h>\n\t\t\t\t#include <ddk/usbioctl.h>\n\t\t\t\tAC_INCLUDES_DEFAULT\n\t\t\t])\n\t\t],[\n\t\t\t#include <windows.h>\n\t\t\t#include <usbioctl.h>\n\t\t\tAC_INCLUDES_DEFAULT\n\t\t])\n\t\tif $found_ddkusb; then\n\t\t\tAUTOSCAN_LIBS=\"-lsetupapi\"\n\t\t\tAC_DEFINE([HAVE_WIN_DDKUSB],[1],[Defined to 1 if Windows DDK USB headers are being used])\n\t\tfi\n\telse\n\t\tAC_MSG_CHECKING([what baud rates your system supports])\n\t\techo '#include <termios.h>' | ${CPP} -dM - 2>/dev/null | ${SED} 's/.*[ \t]B\\([0-9][0-9]*\\)[ \t].*/IOSPEED(\\1)/' | grep IOSPEED >iospeeds_local.h\n\t\tif grep -q IOSPEED iospeeds_local.h; then\n\t\t\tAC_MSG_RESULT([done])\n\t\telse\n\t\t\tAC_MSG_RESULT([failed, using standard POSIX])\n\t\t\techo '#include <iospeeds_posix.h>' >iospeeds_local.h\n\t\tfi\n\tfi\nfi\n\nif test \"x$USE_OPENCL$need_lowl_hid\" = xnono; then\n\tDLOPEN_FLAGS=\"\"\nfi\n\nlowllist=\"$lowllist hid/need_lowl_hid\"\nif test x$need_lowl_hid = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_HID], [1], [Defined to 1 if lowlevel hid drivers are being used])\n\tneed_lowlevel=yes\nfi\n\nlowllist=\"$lowllist mswin/need_lowl_mswin\"\nif test x$need_lowl_mswin = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_MSWIN], [1], [Defined to 1 if lowlevel mswin drivers are being used])\n\tneed_lowlevel=yes\nfi\n\nlowllist=\"$lowllist pci/need_lowl_pci\"\nif test x$need_lowl_pci = xyes; then\n\tAC_DEFINE([NEED_BFG_LOWL_PCI], [1], [Defined to 1 if lowlevel PCI drivers are being used])\n\tneed_lowlevel=yes\n\tlowllist=\"$lowllist pci:uio/uio\"\n\tif test x$uio = xyes; then\n\t\tAC_DEFINE([USE_UIO], [1], [Defined to 1 if lowlevel PCI drivers should support UIO])\n\tfi\n\tlowllist=\"$lowllist pci:vfio/vfio\"\n\tif test x$vfio = xyes; then\n\t\tAC_DEFINE([USE_VFIO], [1], [Defined to 1 if lowlevel PCI drivers should support VFIO])\n\tfi\nfi\nAM_CONDITIONAL([USE_VFIO], [test x$need_lowl_pci$vfio = xyesyes])\n\nlowllist=\"$lowllist usb/need_lowl_usb\"\nif test x$need_lowl_usb = xyes; then\n\tneed_lowlevel=yes\nfi\n\nlowllist=\"$lowllist vcom/need_lowl_vcom\"\nif test x$need_lowl_vcom = xyes; then\n\tneed_lowlevel=yes\nfi\n\nif test x$need_lowlevel = xyes; then\n\tAC_DEFINE([HAVE_BFG_LOWLEVEL], [1], [Defined to 1 if lowlevel drivers are being used])\nfi\n\nif test x$need_linux_i2c_dev = xyes; then\n\tAC_CHECK_HEADERS([linux/i2c-dev-user.h])\n\tAC_CHECK_DECL([i2c_smbus_read_word_data],[true],[\n\t\tAC_MSG_ERROR([linux/i2c-dev.h header from i2c-tools/libi2c-dev (NOT linux headers) is required for KnCMiner drivers])\n\t],[\n\t\t#include <stddef.h>\n\t\t#ifdef HAVE_LINUX_I2C_DEV_USER_H\n\t\t#include <linux/i2c-dev-user.h>\n\t\t#else\n\t\t#ifdef NEED_LINUX_I2C_H\n\t\t#include <linux/i2c.h>\n\t\t#endif\n\t\t#include <linux/i2c-dev.h>\n\t\t#endif\n\t])\nfi\n\n\ncurses=\"auto\"\n\nAC_ARG_WITH([curses],\n\t[AC_HELP_STRING([--without-curses],[Compile support for curses TUI (default enabled)])],\n\t[curses=$withval]\n\t)\nif test \"x$curses\" = \"xno\"; then\n\toptlist=\"$optlist curses\"\nelse\n\tcurses_enableaction=\"install a curses library\"\n\torig_libs=\"$LIBS\"\n\tif test \"x${curses}\" = \"xyes\"; then\n\t\tpreferl=''\n\telse\n\t\tpreferl=\"${curses} ${curses}6 ${curses}5\"\n\tfi\n\tfor wideornot in w u ''; do\n\t\tfor ncursesver in '' 6 5; do\n\t\t\tpreferl=\"${preferl} ncurses${wideornot}${ncursesver}\"\n\t\tdone\n\t\tpreferl=\"${preferl} pdcurses${wideornot}\"\n\tdone\n\tif test \"x$cross_compiling\" != \"xyes\"; then\n\t\tAC_MSG_CHECKING([for best native curses library])\n\t\torig_cflags=\"$CFLAGS\"\n\t\tfor curses_lib in ${preferl}; do\n\t\t\tif ! ${curses_lib}-config --cflags >/dev/null 2>/dev/null; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\tCFLAGS=\"$orig_cflags $(${curses_lib}-config --cflags)\"\n\t\t\tLIBS=\"$orig_libs $(${curses_lib}-config --libs)\"\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n\t\t\t\t#include <curses.h>\n\t\t\t]], [[\n\t\t\t\tWINDOW *w = NULL;\n\t\t\t\tmvwprintw(w, 2, 2, \"Testing %s\", \"o hai\");\n\t\t\t]])], [\n\t\t\t\tcurses=yes\n\t\t\t\toptlist=\"$optlist ${curses_lib}/curses\"\n\t\t\t\tAC_MSG_RESULT([$curses_lib])\n\t\t\t\tNCURSES_LIBS=`${curses_lib}-config --libs`\n\t\t\t\tNCURSES_CPPFLAGS=`${curses_lib}-config --cflags`\n\t\t\t\tbreak\n\t\t\t], [\n\t\t\t\tAC_MSG_WARN([${curses_lib} doesn't seem to be installed properly])\n\t\t\t])\n\t\tdone\n\t\tCFLAGS=\"$orig_cflags\"\n\t\tif test \"x$curses\" != \"xyes\"; then\n\t\t\tAC_MSG_RESULT([none?])\n\t\tfi\n\tfi\n\tif test \"x$curses\" != \"xyes\"; then\n\t\tsym=addstr\n\t\t\tAC_SEARCH_LIBS(${sym}, ${preferl}, [\n\t\t\t\tcurses=yes\n\t\t\t\teval \"curseslib=\\\"\\${ac_cv_search_${sym}}\\\"\"\n\t\t\t\tbarelib=`echo \"${curseslib}\" | ${SED} -e 's/-l//'`\n\t\t\t\toptlist=\"$optlist ${barelib}/curses\"\n\t\t\t\tif test \"x${curseslib}\" != \"xnone required\"; then\n\t\t\t\t\tNCURSES_LIBS=\"${curseslib}\"\n\t\t\t\tfi\n\t\t\t\t\n\t\t\t\t# Need to check for headers in subdirectories, to ensure we get wide stuff\n\t\t\t\tbarelib=`echo \"${barelib}\" | ${SED} -e 's/6//'`\n\t\t\t\tbarelib=`echo \"${barelib}\" | ${SED} -e 's/5//'`\n\t\t\t\tBFG_FIND_INCLUDE_PATH([${barelib}],[curses.h],[\n\t\t\t\t\tNCURSES_CPPFLAGS=\"-I${inclpath_curses_h}\"\n\t\t\t\t])\n\t\t\t\t\n\t\t\t\tbreak\n\t\t\t], [\n\t\t\t\tif test \"x$curses\" = \"xyes\"; then\n\t\t\t\t\tAC_MSG_ERROR([Could not find curses library - please install libncurses-dev or pdcurses-dev (or configure --without-curses)])\n\t\t\t\telse\n\t\t\t\t\tAC_MSG_WARN([Could not find curses library - if you want a TUI, install libncurses-dev or pdcurses-dev])\n\t\t\t\t\tcurses=no\n\t\t\t\t\toptlist=\"$optlist curses\"\n\t\t\t\tfi\n\t\t\t])\n\tfi\n\tif test \"x$curses\" = \"xyes\"; then\n\t\tAC_DEFINE([HAVE_CURSES], [1], [Defined to 1 if curses TUI support is wanted])\n\t\tAC_MSG_CHECKING([whether curses library supports wide characters])\n\t\torig_cflags=\"$CFLAGS\"\n\t\tCFLAGS=\"$orig_cflags $NCURSES_CPPFLAGS\"\n\t\tLIBS=\"$orig_libs $NCURSES_LIBS\"\n\t\tAC_LINK_IFELSE([\n\t\t\tAC_LANG_PROGRAM([\n\t\t\t\t#define PDC_WIDE\n\t\t\t\t#include <curses.h>\n\t\t\t],[\n\t\t\t\taddwstr(L\"test\");\n\t\t\t\tadd_wch(WACS_VLINE);\n\t\t\t])\n\t\t],[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([USE_UNICODE],[1],[Defined to 1 if curses supports wide characters])\n\t\t],[\n\t\t\tAC_MSG_RESULT([no])\n\t\t])\n\t\tCFLAGS=\"$orig_cflags\"\n\tfi\n\tLIBS=\"$orig_libs\"\nfi\n\n\nBFG_BUNDLED_LIB([libbase58],[libbase58],[auto],[libbase58],[base58],[],[--disable-tool --disable-static --enable-shared])\nBFG_BUNDLED_LIB([libblkmaker],[libblkmaker_jansson-0.1],[no],[libblkmaker],[blkmaker_jansson-0.1 blkmaker-0.1],[libbase58])\n\n\n$have_udevrules || use_udevrules=false\nif $use_udevrules; then\n\tAC_ARG_WITH([udevrulesdir],\n\t\tAS_HELP_STRING([--with-udevrulesdir=DIR], [Install udev rules into this directory]),\n\t\t[], [\n\t\t\tif test -d /lib/udev/rules.d; then\n\t\t\t\twith_udevrulesdir=/lib/udev/rules.d\n\t\t\telse\n\t\t\t\twith_udevrulesdir=no\n\t\t\tfi\n\t\t]\n\t)\n\tif test \"x$with_udevrulesdir\" = \"xno\"; then\n\t\tuse_udevrules=false\n\tfi\n\tif $use_udevrules; then\n\t\tAC_SUBST([udevrulesdir], [$with_udevrulesdir])\n\tfi\nfi\n\n\nAM_CONDITIONAL([NEED_BFG_BINLOADER], [test x$need_binloader = xyes])\nAM_CONDITIONAL([NEED_DYNCLOCK], [test x$need_dynclock = xyes])\nAM_CONDITIONAL([USE_GC3355], [test x$need_gc3355 = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_VCOM], [test x$need_lowl_vcom = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_FTDI], [test x$need_lowl_ftdi = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_HID], [test x$need_lowl_hid = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_MSWIN], [test x$need_lowl_mswin = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_PCI], [test x$need_lowl_pci = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWL_SPI], [test x$need_lowl_spi = xyes])\nAM_CONDITIONAL([NEED_BFG_LOWLEVEL], [test x$need_lowlevel = xyes])\nAM_CONDITIONAL([NEED_BFG_WORK2D], [test x$need_work2d = xyes])\nAM_CONDITIONAL([NEED_KNC_ASIC], [test x$need_knc_asic = xyes])\nAM_CONDITIONAL([HAVE_CURSES], [test x$curses = xyes])\nAM_CONDITIONAL([HAVE_SENSORS], [test x$with_sensors = xyes])\nAM_CONDITIONAL([HAVE_CYGWIN], [test x$have_cygwin = xtrue])\nAM_CONDITIONAL([HAVE_LIBUSB], [test x$USE_LIBUSB = xyes])\nAM_CONDITIONAL([HAVE_WINDOWS], [test x$have_win32 = xtrue])\nAM_CONDITIONAL([HAVE_x86_64], [test x$have_x86_64 = xtrue])\nAM_CONDITIONAL([HAVE_WIN_DDKUSB], [test x$found_ddkusb = xtrue])\nAM_CONDITIONAL([HAS_FPGA], [test x$has_fpga != xno])\nAM_CONDITIONAL([HAS_ASIC], [test x$has_asic != xno])\nAM_CONDITIONAL([USE_UDEVRULES], [$use_udevrules])\nAM_CONDITIONAL([BROAD_UDEVRULES], [$broad_udevrules])\n\ndnl Find YASM\nhas_yasm=false\nif test \"x$have_x86_32$have_x86_64\" != \"xfalsefalse\"; then\nAC_PATH_PROG([YASM],[yasm],[false])\nif test \"x$YASM\" != \"xfalse\" ; then\n  has_yasm_enableaction=\"install yasm 1.0.1+\"\n  AC_MSG_CHECKING([if yasm version is greater than 1.0.1])\n  yasmver=`\"$YASM\" --version | head -1 | cut -d\\  -f2`\n  yamajor=`echo $yasmver | cut -d. -f1`\n  yaminor=`echo $yasmver | cut -d. -f2`\n  yamini=`echo $yasmver | cut -d. -f3`\n  if test \"$yamajor\" -ge \"1\" ; then\n    if test \"$yamajor\" -eq \"1\" ; then\n      if test \"$yaminor\" -ge \"0\" ; then\n        if test \"$yaminor\" -eq \"0\"; then\n          if test \"$yamini\" -ge \"1\"; then\n            has_yasm=true\n          fi\n        else\n          has_yasm=true\n        fi\n      fi\n    fi\n  else\n    has_yasm=false\n  fi\n  if test \"x$has_yasm\" = \"xtrue\" ; then\n    AC_MSG_RESULT([yes])\n  else\n    AC_MSG_RESULT([no])\n  fi\nfi\nif test \"x$has_yasm\" = \"xfalse\" ; then\n  AC_MSG_NOTICE([yasm is required for the assembly algorithms. They will be skipped.])\nelse\n\tAC_DEFINE([HAVE_YASM], [1], [Defined to 1 if yasm is being used])\n\tif test \"x$have_win32$have_cygwin\" != \"xfalsefalse\"; then\n\t\tif test \"x$have_x86_64\" = xtrue; then\n\t\t\tYASM_FMT=\"win64\"\n\t\telse\n\t\t\tYASM_FMT=\"coff\"\n\t\tfi\n\telif test \"x$have_macho\" = \"xtrue\"; then\n\t\tYASM_FMT=\"macho$bitness\"\n\telse\n\t\tYASM_FMT=\"elf$bitness\"\n\tfi\nfi\n\nfi\n\nAM_CONDITIONAL([HAS_YASM], [test x$has_yasm = xtrue])\n\nhave_sse2=no\nif test \"x$USE_CPUMINING$have_x86_32\" = \"xyestrue\"; then\n\tAC_MSG_CHECKING([if SSE2 code compiles])\n\tsave_CFLAGS=\"$CFLAGS\"\n\tfor flags in '' '-msse2'; do\n\t\tCFLAGS=\"$CFLAGS $flags\"\n\t\tAC_TRY_LINK([\n\t\t\t#include <xmmintrin.h>\n\t\t],[\n\t\t\tint *i = (int *)0xdeadbeef;\n\t\t\t__m128i a, b;\n\t\t\ta = _mm_set1_epi32(i[0]);\n\t\t\tb = _mm_set_epi32(i[0], i[1], i[2], i[3]);\n\t\t\ta = _mm_add_epi32(a, b);\n\t\t\ta = _mm_andnot_si128(a, b);\n\t\t\ta = _mm_or_si128(a, b);\n\t\t\ta = _mm_slli_epi32(a, i[4]);\n\t\t\ta = _mm_and_si128(a, b);\n\t\t\ta = _mm_xor_si128(a, b);\n\t\t],[\n\t\t\tif test \"x$flags\" = \"x\"; then\n\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([with $flags])\n\t\t\tfi\n\t\t\tSSE2_CFLAGS=\"$flags\"\n\t\t\thave_sse2=yes\n\t\t\tbreak\n\t\t],[\n\t\t\ttrue\n\t\t])\n\tdone\n\tCFLAGS=\"${save_CFLAGS}\"\n\tif test \"x$have_sse2\" = \"xyes\"; then\n\t\tAC_DEFINE([HAVE_SSE2], [1], [Defined to 1 if yasm is being used])\n\telse\n\t\tAC_MSG_RESULT([no])\n\tfi\nfi\nAM_CONDITIONAL([HAVE_SSE2], [test \"x$have_sse2\" = \"xyes\"])\n\nif test \"x$need_lowl_vcom\" = \"xyes\"; then\n\tAC_ARG_WITH([libudev], [AC_HELP_STRING([--without-libudev], [Autodetect FPGAs using libudev (default enabled)])],\n\t\t[libudev=$withval],\n\t\t[libudev=auto]\n\t\t)\n\tif test \"x$libudev\" != \"xno\"; then\n\t\tAC_CHECK_HEADER([libudev.h],[\n\t\t\tlibudev=yes\n\t\t\tUDEV_LIBS=-ludev\n\t\t\tAC_DEFINE([HAVE_LIBUDEV], [1], [Defined to 1 if libudev is wanted])\n\t\t], [\n\t\t\tif test \"x$libudev\" = \"xyes\"; then\n\t\t\t\tAC_MSG_ERROR([libudev not found])\n\t\t\tfi\n\t\t\tlibudev=no\n\t\t])\n\tfi\nfi\nAM_CONDITIONAL([HAVE_LIBUDEV], [test x$libudev != xno])\n\nAC_SUBST(LIBUSB_LIBS)\nAC_SUBST(LIBUSB_CFLAGS)\n\nPKG_CHECK_MODULES([LIBCURL], [libcurl >= 7.18.2], ,[AC_MSG_ERROR([Missing required libcurl dev >= 7.18.2])])\nif echo \"$LIBCURL_CFLAGS\" | grep '@CPPFLAG_CURL_STATICLIB@' >/dev/null 2>&1; then\n\tAC_MSG_WARN([Your libcurl pkgconfig file is broken, applying workaround])\n\tLIBCURL_CFLAGS=`echo \"$LIBCURL_CFLAGS\" | ${SED} 's/@CPPFLAG_CURL_STATICLIB@//'`\nfi\nAC_SUBST(LIBCURL_LIBS)\n\nAC_CHECK_FUNCS([setrlimit])\n\ndnl CCAN wants to know a lot of vars.\n# All the configuration checks.  Regrettably, the __attribute__ checks will\n# give false positives on old GCCs, since they just cause warnings.  But that's\n# fairly harmless.\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((cold)) cleanup(void) { }])],\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_COLD], [1],\n                                    [Define if __attribute__((cold))]))\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((const)) cleanup(void) { }])],\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_CONST], [1],\n                                    [Define if __attribute__((const))]))\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((noreturn)) cleanup(void) { exit(1); }])],\n\t[\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_NORETURN], [1],\n                                    [Define if __attribute__((noreturn))])\n\t\tAC_DEFINE_UNQUOTED([NORETURN], [__attribute__((noreturn))], [Syntax of noreturn attribute])\n\t], [\n\t\tAC_DEFINE_UNQUOTED([NORETURN], [])\n\t]\n)\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((format(__printf__, 1, 2))) cleanup(const char *fmt, ...) { }])],\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_PRINTF], [1],\n                                    [Define if __attribute__((format(__printf__)))]))\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((unused)) cleanup(void) { }])],\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_UNUSED], [1],\n                                    [Define if __attribute__((unused))]))\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static void __attribute__((used)) cleanup(void) { }])],\n\t\t\t  AC_DEFINE([HAVE_ATTRIBUTE_USED], [1],\n                                    [Define if __attribute__((used))]))\nAC_LINK_IFELSE([AC_LANG_SOURCE([int main(void) { return __builtin_constant_p(1) ? 0 : 1; }])],\n\t\t\t  AC_DEFINE([HAVE_BUILTIN_CONSTANT_P], [1],\n                                    [Define if have __builtin_constant_p]))\nAC_LINK_IFELSE([AC_LANG_SOURCE([int main(void) { return __builtin_types_compatible_p(char *, int) ? 1 : 0; }])],\n\t\t\t  AC_DEFINE([HAVE_BUILTIN_TYPES_COMPATIBLE_P], [1],\n                                    [Define if have __builtin_types_compatible_p]))\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([static int __attribute__((warn_unused_result)) func(int x) { return x; }])],\n\t\t\t  AC_DEFINE([HAVE_WARN_UNUSED_RESULT], [1],\n                                    [Define if __attribute__((warn_unused_result))]))\n\n\n# byteswap functions\nAH_TEMPLATE([HAVE_BYTESWAP_H], [Define to use byteswap macros from byteswap.h])\nAH_TEMPLATE([HAVE_ENDIAN_H], [Define to use byteswap macros from endian.h])\nAH_TEMPLATE([HAVE_SYS_ENDIAN_H], [Define to use byteswap macros from sys/endian.h])\nAH_TEMPLATE([HAVE_LIBKERN_OSBYTEORDER_H], [Define to use byteswap macros from libkern/OSByteOrder.h])\nBSWAP=''\nfor sym in bswap_ __builtin_bswap __bswap_ __swap swap OSSwapInt; do\n\tAC_MSG_CHECKING([for ${sym}* functions])\n\tfor headerfile in '' byteswap.h endian.h sys/endian.h libkern/OSByteOrder.h; do\n\t\tBFG_INCLUDE([headerinclude], [${headerfile}])\n\t\tAC_LINK_IFELSE([\n\t\t\tAC_LANG_PROGRAM([\n\t\t\t\t${headerinclude}\n\t\t\t], [\n\t\t\t\t(void) ${sym}16(0);\n\t\t\t\t(void) ${sym}32(0);\n\t\t\t\t(void) ${sym}64(0);\n\t\t\t])\n\t\t], [\n\t\t\tBSWAP=\"${sym}\"\n\t\t\tif test \"x${headerfile}\" = \"x\"; then\n\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([found in ${headerfile}])\n\t\t\t\tAC_DEFINE_UNQUOTED(AS_TR_CPP([HAVE_$headerfile]), 1)\n\t\t\tfi\n\t\t\tbreak 2\n\t\t])\n\tdone\n\tAC_MSG_RESULT([no])\ndone\nif test \"x$BSWAP\" = \"x\"; then\n\ttrue  # Substitutes are provided in miner.h\nelif test \"x$BSWAP\" = \"xbswap_\"; then\n\tAC_MSG_CHECKING([if bswap_16 is already a macro])\n\tBFG_PREPROC_IFELSE([defined(bswap_16)], $headerfile, [\n\t\tAC_MSG_RESULT([yes])\n\t\tBSWAP=\"\"\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\nfi\nif test \"x$BSWAP\" != \"x\"; then\n\tAC_DEFINE_UNQUOTED([bswap_16], ${BSWAP}16, [Define to 16-bit byteswap macro])\n\tAC_DEFINE_UNQUOTED([bswap_32], ${BSWAP}32, [Define to 16-bit byteswap macro])\n\tAC_DEFINE_UNQUOTED([bswap_64], ${BSWAP}64, [Define to 16-bit byteswap macro])\nfi\n\n# endian definition macros\nAC_MSG_CHECKING([for platform endian])\nfound_endian=no\nfor headerfile in '' endian.h sys/endian.h sys/param.h; do\n\tfor pfx in '' '__'; do\n\t\tBFG_PREPROC_IFELSE([defined(${pfx}BYTE_ORDER) && defined(${pfx}BIG_ENDIAN) && defined(${pfx}LITTLE_ENDIAN) && (${pfx}BYTE_ORDER == ${pfx}BIG_ENDIAN || ${pfx}BYTE_ORDER == ${pfx}LITTLE_ENDIAN)], ${headerfile}, [\n\t\t\tif test \"x$headerfile\" = \"x\"; then\n\t\t\t\theaderfilec=''\n\t\t\telse\n\t\t\t\theaderfilec=\" (${headerfile})\"\n\t\t\tfi\n\t\t\tBFG_PREPROC_IFELSE([${pfx}BYTE_ORDER == ${pfx}BIG_ENDIAN], ${headerfile}, [\n\t\t\t\tAC_MSG_RESULT([big endian${headerfilec}])\n\t\t\t\tAC_DEFINE(WORDS_BIGENDIAN, 1, [Define if your platform is big endian])\n\t\t\t], [\n\t\t\t\tAC_MSG_RESULT([little endian${headerfilec}])\n\t\t\t])\n\t\t\tfound_endian=yes\n\t\t\tbreak 2\n\t\t],[true])\n\tdone\ndone\nif test \"x$found_endian\" = \"xno\"; then\n\tif $have_win32 || $have_cygwin; then\n\t\tAC_MSG_RESULT([assuming little endian (Windows)])\n\telse\n\t\t# AC_C_BIGENDIAN is reported to have problems, and invasive even if buried in a conditional, so don't use it\n\t\tAC_MSG_RESULT([unknown])\n\t\tAC_MSG_ERROR([Unable to identify platform endian])\n\tfi\nfi\n\n\nAC_MSG_CHECKING([if good static asserts compile])\nAC_TRY_LINK([\n\t#include <stddef.h>\n], [\n\t_Static_assert(1, \":)\");\n], [\n\tAC_MSG_RESULT([yes])\n], [\n\tAC_MSG_RESULT([no])\n\tAC_DEFINE_UNQUOTED([_Static_assert(...)], [], [Turns _Static_assert into noop for compilers that don't support it])\n])\n\n\nAC_MSG_CHECKING([if GNU format attribute compiles])\nAC_TRY_COMPILE([\n\t#define FORMAT_SYNTAX_CHECK(...) __attribute__(( format(__VA_ARGS__) ))\n\tint myfunc(char *fmt, ...) FORMAT_SYNTAX_CHECK(printf, 1, 2);\n\tint myfunc(char *fmt, ...) {\n\t\treturn 42;\n\t}\n], [\n\tmyfunc(\"abc%d\", 42);\n], [\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE_UNQUOTED([FORMAT_SYNTAX_CHECK(...)], [__attribute__(( format(__VA_ARGS__) ))], [Syntax of format-checking attribute])\n], [\n\tAC_MSG_RESULT([no])\n\tAC_DEFINE_UNQUOTED([FORMAT_SYNTAX_CHECK(...)], [])\n])\n\n\nAC_MSG_CHECKING([for clock_gettime(CLOCK_MONOTONIC)])\nAC_TRY_COMPILE([\n\t#define _GNU_SOURCE\n\t#include <time.h>\n],[\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n],[\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE([HAVE_CLOCK_GETTIME_MONOTONIC], [1], [Defined to 1 if clock_gettime(CLOCK_MONOTONIC) is defined])\n\tsave_LIBS=\"${LIBS}\"\n\tAC_SEARCH_LIBS([clock_gettime],[rt posix4],[\n\t\tif test \"x${ac_cv_search_clock_gettime}\" != \"xnone required\"; then\n\t\t\tRT_LIBS=\"${ac_cv_search_clock_gettime}\"\n\t\tfi\n\t])\n\tLIBS=\"${save_LIBS}\"\n\tAC_CHECK_FUNCS([clock_nanosleep])\n\tAC_MSG_CHECKING([for clock_gettime(CLOCK_MONOTONIC_RAW)])\n\tAC_TRY_COMPILE([\n\t\t#define _GNU_SOURCE\n\t\t#include <time.h>\n\t],[\n\t\tstruct timespec ts;\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n\t],[\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAVE_CLOCK_GETTIME_MONOTONIC_RAW], [1], [Defined to 1 if clock_gettime(CLOCK_MONOTONIC_RAW) is defined])\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\n],[\n\tAC_MSG_RESULT([no])\n])\n\n\nsave_LIBS=\"$LIBS\"\nLIBS=\"$LIBS $MATH_LIBS\"\nAC_CHECK_FUNCS([log2])\nLIBS=\"$save_LIBS\"\n\n\nif test \"x$prefix\" = xNONE; then\n\tprefix=/usr/local\nfi\n\nAM_CONDITIONAL([NEED_BITSTREAM_FPGAMINER], [test x$USE_MODMINER$USE_X6500 != xnono])\n\ndnl Hide unnecessary explanations, only after any fatal errors\nhowto_SHA256D=x\nif test \"x$USE_SHA256D\" = xno; then\n\thowto_BITFURY=x\nfi\nif test \"x$want_libusb\" = xno; then\n\thowto_LIBUSB=x\nfi\n\nm4_define([BFG_PRINT_LIST],[\n\teval _mylist=\"\\$$2\"\n\t_yeslist=\n\t_nolist=\n\t_enableactions=\n\tfoundone=no\n\tfor _opt in $_mylist; do\n\t\tIFS=/ read _opt _var <<EOF\n$_opt\nEOF\n\t\ttest -n \"$_var\" || _var=\"$_opt\"\n\t\teval \"_val=\\\"\\$${_var}\\\"\"\n\t\tif test \"x$_val\" = \"xno\" || test \"x$_val\" = \"xfalse\"; then\n\t\t\t_nolist=\"$_nolist $_opt\"\n\t\t\t_enableaction=`bfg_enableaction $_var`\n\t\t\tif test -n \"$_enableaction\"; then\n\t\t\t\t_enableactions=\"${_enableactions}~    To enable ${_opt}: ${_enableaction}\"\n\t\t\tfi\n\t\telse\n\t\t\t_yeslist=\"$_yeslist $_opt\"\n\t\t\tfoundone=yes\n\t\tfi\n\tdone\n\t_yeslist=`echo \"$_yeslist\" | tr ' ' '\\n' | sort | tr '\\n' ' '`\n\t_nolist=`echo \"$_nolist\" | tr ' ' '\\n' | sort | tr '\\n' ' '`\n\tAC_DEFINE_UNQUOTED(AS_TR_CPP([BFG_$2]),[\"$_yeslist\"],[List of drivers being built])\n\t$2_print=\"  Enabled..$1..:${_yeslist}~  Disabled.$1..:${_nolist}${_enableactions}\"\n])\nBFG_PRINT_LIST([Lowlevel..],[lowllist])\nBFG_PRINT_LIST([Drivers...],[driverlist])\nBFG_PRINT_LIST([Algorithms],[algolist])\nif test \"x$foundone\" = \"xno\"; then\n\tAC_MSG_ERROR([No mining algorithms configured!])\nfi\nBFG_PRINT_LIST([Options...],[optlist])\n\n\nAC_SUBST(AUTOSCAN_CPPFLAGS)\nAC_SUBST(AUTOSCAN_LIBS)\nAC_SUBST(PTHREAD_FLAGS)\nAC_SUBST(DLOPEN_FLAGS)\nAC_SUBST(PTHREAD_LIBS)\nAC_SUBST(NCURSES_CPPFLAGS)\nAC_SUBST(NCURSES_LIBS)\nAC_SUBST(PDCURSES_LIBS)\nAC_SUBST(WS2_LIBS)\nAC_SUBST(MM_LIBS)\nAC_SUBST(MATH_LIBS)\nAC_SUBST(RT_LIBS)\nAC_SUBST(UDEV_LIBS)\nAC_SUBST(SSE2_CFLAGS)\nAC_SUBST(YASM_FMT)\n\nAC_CONFIG_FILES([\n\tMakefile\n\tx86_64/Makefile\n\tx86_32/Makefile\n\tccan.bfg/Makefile\n\tlib/Makefile\n\t])\n\nif $use_udevrules; then\n\tAC_CONFIG_FILES([70-bfgminer.rules])\nfi\n\nAC_OUTPUT\nBFG_CUSTOM_SUBDIRS_OUTPUT\n\n\nwordfilter ()\n{\n  echo \"$1\" | ${SED} 's/ \\+/ /g;s/^ *//;s/ *$//'\n}\n\necho\necho \"------------------------------------------------------------------------\"\necho \"$PACKAGE $VERSION configuration options summary\"\necho \"------------------------------------------------------------------------\"\necho\necho \"  CFLAGS...............: \"`wordfilter \"$CPPFLAGS $AUTOSCAN_CPPFLAGS $NCURSES_CPPFLAGS $PTHREAD_FLAGS $CFLAGS $LIBUSB_CFLAGS $JANSSON_CFLAGS $PTHREAD_FLAGS $libbase58_CFLAGS $libblkmaker_CFLAGS $hidapi_CFLAGS\"`\necho \"  LDFLAGS..............: \"`wordfilter \"$LDFLAGS $AUTOSCAN_LIBS $PTHREAD_FLAGS $PTHREAD_LIBS $LIBS $DLOPEN_FLAGS $LIBCURL_LIBS $JANSSON_LIBS $NCURSES_LIBS $PDCURSES_LIBS $WS2_LIBS $MATH_LIBS $UDEV_LIBS $LIBUSB_LIBS $RT_LIBS $sensors_LIBS $libbase58_LIBS $libblkmaker_LIBS\"`\necho \"  Installation.prefix..: $prefix\"\necho\necho \"${lowllist_print}\" | tr '~' '\\n'\necho \"${driverlist_print}\" | tr '~' '\\n'\necho \"${algolist_print}\" | tr '~' '\\n'\necho \"${optlist_print}\" | tr '~' '\\n'\necho\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "deviceapi.c",
          "type": "blob",
          "size": 29.591796875,
          "content": "/*\n * Copyright 2011-2014 Luke Dashjr\n * Copyright 2011-2012 Con Kolivas\n * Copyright 2012-2013 Andrew Smith\n * Copyright 2010 Jeff Garzik\n * Copyright 2014 Nate Woolls\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#ifdef WIN32\n#include <winsock2.h>\n#else\n#include <sys/select.h>\n#endif\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <utlist.h>\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#ifdef NEED_BFG_LOWL_VCOM\n#include \"lowl-vcom.h\"\n#endif\n#include \"miner.h\"\n#include \"util.h\"\n\nstruct driver_registration *_bfg_drvreg1;\nstruct driver_registration *_bfg_drvreg2;\n\nvoid _bfg_register_driver(const struct device_drv *drv)\n{\n\tstruct driver_registration *ndr;\n\t\n\tif (!drv)\n\t{\n\t\t// NOTE: Not sorted at this point (dname and priority may be unassigned until drv_init!)\n\t\tLL_FOREACH2(_bfg_drvreg1, ndr, next_dname)\n\t\t{\n\t\t\tdrv = ndr->drv;\n\t\t\tif (drv->drv_init)\n\t\t\t\tdrv->drv_init();\n\t\t}\n\t\treturn;\n\t}\n\t\n\tndr = malloc(sizeof(*ndr));\n\t*ndr = (struct driver_registration){\n\t\t.drv = drv,\n\t};\n\tLL_PREPEND2(_bfg_drvreg1, ndr, next_dname);\n\tLL_PREPEND2(_bfg_drvreg2, ndr, next_prio);\n}\n\nstatic\nint sort_drv_by_dname(struct driver_registration * const a, struct driver_registration * const b)\n{\n\treturn strcmp(a->drv->dname, b->drv->dname);\n};\n\nstatic\nint sort_drv_by_priority(struct driver_registration * const a, struct driver_registration * const b)\n{\n\treturn a->drv->probe_priority - b->drv->probe_priority;\n};\n\nvoid bfg_devapi_init()\n{\n\t_bfg_register_driver(NULL);\n#ifdef LL_SORT2\n\tLL_SORT2(_bfg_drvreg1, sort_drv_by_dname, next_dname);\n\tLL_SORT2(_bfg_drvreg2, sort_drv_by_priority, next_prio);\n#else\n\t#define next next_dname\n\tLL_SORT(_bfg_drvreg1, sort_drv_by_dname);\n\t#undef next\n\t#define next next_prio\n\tLL_SORT(_bfg_drvreg2, sort_drv_by_priority);\n\t#undef next\n#endif\n}\n\n\nfloat common_sha256d_and_scrypt_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\tswitch (malgo->algo)\n\t{\n#ifdef USE_SCRYPT\n\t\tcase POW_SCRYPT:\n\t\t\treturn 1./0x10000;\n#endif\n#ifdef USE_SHA256D\n\t\tcase POW_SHA256D:\n\t\t\treturn 1.;\n#endif\n\t\tdefault:\n\t\t\treturn -1.;\n\t}\n}\n\n#ifdef USE_SCRYPT\nfloat common_scrypt_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\treturn (malgo->algo == POW_SCRYPT) ? (1./0x10000) : -1.;\n}\n#endif\n\nbool hashes_done(struct thr_info *thr, int64_t hashes, struct timeval *tvp_hashes, uint32_t *max_nonce)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tconst long cycle = opt_log_interval / 5 ? : 1;\n\t\n\tif (unlikely(hashes == -1)) {\n\t\tif (timer_elapsed(&cgpu->tv_device_last_not_well, NULL) > 0)\n\t\t\tdev_error(cgpu, REASON_THREAD_ZERO_HASH);\n\t\t\n\t\tif (thr->scanhash_working && opt_restart) {\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\" failure, attempting to reinitialize\", cgpu->proc_repr);\n\t\t\tthr->scanhash_working = false;\n\t\t\tcgpu->reinit_backoff = 5.2734375;\n\t\t\thashes = 0;\n\t\t} else {\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\" failure, disabling!\", cgpu->proc_repr);\n\t\t\tcgpu->deven = DEV_RECOVER_ERR;\n\t\t\trun_cmd(cmd_idle);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tthr->scanhash_working = true;\n\t\n\tthr->hashes_done += hashes;\n\tif (hashes > cgpu->max_hashes)\n\t\tcgpu->max_hashes = hashes;\n\t\n\ttimeradd(&thr->tv_hashes_done, tvp_hashes, &thr->tv_hashes_done);\n\t\n\t// max_nonce management (optional)\n\tif (max_nonce)\n\t{\n\t\tuint64_t new_max_nonce = *max_nonce;\n\t\tnew_max_nonce *= cycle;\n\t\tnew_max_nonce *= 1000000;\n\t\tnew_max_nonce /= ((uint64_t)thr->tv_hashes_done.tv_sec * 1000000) + thr->tv_hashes_done.tv_usec;\n\t\t\n\t\tif (new_max_nonce > 0xffffffff)\n\t\t\tnew_max_nonce = 0xffffffff;\n\t\t\n\t\t*max_nonce = new_max_nonce;\n\t}\n\t\n\thashmeter2(thr);\n\t\n\treturn true;\n}\n\nbool hashes_done2(struct thr_info *thr, int64_t hashes, uint32_t *max_nonce)\n{\n\tstruct timeval tv_now, tv_delta;\n\ttimer_set_now(&tv_now);\n\ttimersub(&tv_now, &thr->_tv_last_hashes_done_call, &tv_delta);\n\tthr->_tv_last_hashes_done_call = tv_now;\n\treturn hashes_done(thr, hashes, &tv_delta, max_nonce);\n}\n\n/* A generic wait function for threads that poll that will wait a specified\n * time tdiff waiting on a work restart request. Returns zero if the condition\n * was met (work restart requested) or ETIMEDOUT if not.\n */\nint restart_wait(struct thr_info *thr, unsigned int mstime)\n{\n\tstruct timeval tv_timer, tv_now, tv_timeout;\n\tfd_set rfds;\n\tSOCKETTYPE wrn = thr->work_restart_notifier[0];\n\tint rv;\n\t\n\tif (unlikely(thr->work_restart_notifier[1] == INVSOCK))\n\t{\n\t\t// This is a bug!\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": restart_wait called without a work_restart_notifier\", thr->cgpu->proc_repr);\n\t\tcgsleep_ms(mstime);\n\t\treturn (thr->work_restart ? 0 : ETIMEDOUT);\n\t}\n\t\n\ttimer_set_now(&tv_now);\n\ttimer_set_delay(&tv_timer, &tv_now, mstime * 1000);\n\twhile (true)\n\t{\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(wrn, &rfds);\n\t\ttv_timeout = tv_timer;\n\t\trv = select(wrn + 1, &rfds, NULL, NULL, select_timeout(&tv_timeout, &tv_now));\n\t\tif (rv == 0)\n\t\t\treturn ETIMEDOUT;\n\t\tif (rv > 0)\n\t\t{\n\t\t\tif (thr->work_restart)\n\t\t\t\treturn 0;\n\t\t\tnotifier_read(thr->work_restart_notifier);\n\t\t}\n\t\ttimer_set_now(&tv_now);\n\t}\n}\n\nstatic\nstruct work *get_and_prepare_work(struct thr_info *thr)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\tstruct work *work;\n\t\n\twork = get_work(thr);\n\tif (!work)\n\t\treturn NULL;\n\tif (api->prepare_work && !api->prepare_work(thr, work)) {\n\t\tfree_work(work);\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Work prepare failed, disabling!\", proc->proc_repr);\n\t\tproc->deven = DEV_RECOVER_ERR;\n\t\trun_cmd(cmd_idle);\n\t\treturn NULL;\n\t}\n\treturn work;\n}\n\n// Miner loop to manage a single processor (with possibly multiple threads per processor)\nvoid minerloop_scanhash(struct thr_info *mythr)\n{\n\tstruct cgpu_info *cgpu = mythr->cgpu;\n\tstruct device_drv *api = cgpu->drv;\n\tstruct timeval tv_start, tv_end;\n\tstruct timeval tv_hashes, tv_worktime;\n\tuint32_t max_nonce = api->can_limit_work ? api->can_limit_work(mythr) : 0xffffffff;\n\tint64_t hashes;\n\tstruct work *work;\n\tconst bool primary = (!mythr->device_thread) || mythr->primary_thread;\n\t\n#ifdef HAVE_PTHREAD_CANCEL\n\tpthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);\n#endif\n\t\n\tif (cgpu->deven != DEV_ENABLED)\n\t\tmt_disable(mythr);\n\t\n\twhile (likely(!cgpu->shutdown)) {\n\t\tmythr->work_restart = false;\n\t\trequest_work(mythr);\n\t\twork = get_and_prepare_work(mythr);\n\t\tif (!work)\n\t\t\tbreak;\n\t\ttimer_set_now(&work->tv_work_start);\n\t\t\n\t\tdo {\n\t\t\tthread_reportin(mythr);\n\t\t\t/* Only allow the mining thread to be cancelled when\n\t\t\t* it is not in the driver code. */\n\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\t\t\ttimer_set_now(&tv_start);\n\n\t\t\t/* api->scanhash should scan the work for valid nonces\n\t\t\t * until max_nonce is reached or thr_info->work_restart */\n\t\t\thashes = api->scanhash(mythr, work, work->blk.nonce + max_nonce);\n\n\t\t\ttimer_set_now(&tv_end);\n\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\t\t\tpthread_testcancel();\n\t\t\tthread_reportin(mythr);\n\t\t\t\n\t\t\ttimersub(&tv_end, &tv_start, &tv_hashes);\n\t\t\tif (!hashes_done(mythr, hashes, &tv_hashes, api->can_limit_work ? &max_nonce : NULL))\n\t\t\t\tgoto disabled;\n\t\t\t\n\t\t\tif (unlikely(mythr->work_restart)) {\n\t\t\t\t/* Apart from device_thread 0, we stagger the\n\t\t\t\t * starting of every next thread to try and get\n\t\t\t\t * all devices busy before worrying about\n\t\t\t\t * getting work for their extra threads */\n\t\t\t\tif (!primary) {\n\t\t\t\t\tstruct timespec rgtp;\n\n\t\t\t\t\trgtp.tv_sec = 0;\n\t\t\t\t\trgtp.tv_nsec = 250 * mythr->device_thread * 1000000;\n\t\t\t\t\tnanosleep(&rgtp, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))\ndisabled:\n\t\t\t\tmt_disable(mythr);\n\t\t\t\n\t\t\ttimersub(&tv_end, &work->tv_work_start, &tv_worktime);\n\n\t\t/* The inner do-while loop will exit unless the device is capable of\n\t\t * scanning a specific nonce range (currently CPU and GPU drivers)\n\t\t * See abandon_work comments for more details */\n\t\t} while (!abandon_work(work, &tv_worktime, cgpu->max_hashes));\n\t\tfree_work(work);\n\t}\n}\n\nvoid mt_disable_start__async(struct thr_info * const mythr)\n{\n\tmt_disable_start(mythr);\n\tif (mythr->prev_work)\n\t\tfree_work(mythr->prev_work);\n\tmythr->prev_work = mythr->work;\n\tmythr->work = NULL;\n\tmythr->_job_transition_in_progress = false;\n}\n\nbool do_job_prepare(struct thr_info *mythr, struct timeval *tvp_now)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\tstruct timeval tv_worktime;\n\t\n\tmythr->tv_morework.tv_sec = -1;\n\tmythr->_job_transition_in_progress = true;\n\tif (mythr->work)\n\t\ttimersub(tvp_now, &mythr->work->tv_work_start, &tv_worktime);\n\tif ((!mythr->work) || abandon_work(mythr->work, &tv_worktime, proc->max_hashes))\n\t{\n\t\tmythr->work_restart = false;\n\t\trequest_work(mythr);\n\t\t// FIXME: Allow get_work to return NULL to retry on notification\n\t\tif (mythr->next_work)\n\t\t\tfree_work(mythr->next_work);\n\t\tmythr->next_work = get_and_prepare_work(mythr);\n\t\tif (!mythr->next_work)\n\t\t\treturn false;\n\t\tmythr->starting_next_work = true;\n\t\tapi->job_prepare(mythr, mythr->next_work, mythr->_max_nonce);\n\t}\n\telse\n\t{\n\t\tmythr->starting_next_work = false;\n\t\tapi->job_prepare(mythr, mythr->work, mythr->_max_nonce);\n\t}\n\tjob_prepare_complete(mythr);\n\treturn true;\n}\n\nvoid job_prepare_complete(struct thr_info *mythr)\n{\n\tif (unlikely(mythr->busy_state == TBS_GETTING_RESULTS))\n\t\treturn;\n\tif (mythr->work)\n\t{\n\t\tif (true /* TODO: job is near complete */ || unlikely(mythr->work_restart))\n\t\t\tdo_get_results(mythr, true);\n\t\telse\n\t\t{}  // TODO: Set a timer to call do_get_results when job is near complete\n\t}\n\telse  // no job currently running\n\t\tdo_job_start(mythr);\n}\n\nvoid do_get_results(struct thr_info *mythr, bool proceed_with_new_job)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\tstruct work *work = mythr->work;\n\t\n\tmythr->_job_transition_in_progress = true;\n\tmythr->tv_results_jobstart = mythr->tv_jobstart;\n\tmythr->_proceed_with_new_job = proceed_with_new_job;\n\tif (api->job_get_results)\n\t\tapi->job_get_results(mythr, work);\n\telse\n\t\tjob_results_fetched(mythr);\n}\n\nvoid job_results_fetched(struct thr_info *mythr)\n{\n\tif (mythr->_proceed_with_new_job)\n\t\tdo_job_start(mythr);\n\telse\n\t{\n\t\tif (likely(mythr->prev_work))\n\t\t{\n\t\t\tstruct timeval tv_now;\n\t\t\t\n\t\t\ttimer_set_now(&tv_now);\n\t\t\t\n\t\t\tdo_process_results(mythr, &tv_now, mythr->prev_work, true);\n\t\t}\n\t\tmt_disable_start__async(mythr);\n\t}\n}\n\nvoid do_job_start(struct thr_info *mythr)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\t\n\tthread_reportin(mythr);\n\tapi->job_start(mythr);\n}\n\nvoid mt_job_transition(struct thr_info *mythr)\n{\n\tstruct timeval tv_now;\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tif (mythr->starting_next_work)\n\t{\n\t\tmythr->next_work->tv_work_start = tv_now;\n\t\tif (mythr->prev_work)\n\t\t\tfree_work(mythr->prev_work);\n\t\tmythr->prev_work = mythr->work;\n\t\tmythr->work = mythr->next_work;\n\t\tmythr->next_work = NULL;\n\t}\n\tmythr->tv_jobstart = tv_now;\n\tmythr->_job_transition_in_progress = false;\n}\n\nvoid job_start_complete(struct thr_info *mythr)\n{\n\tstruct timeval tv_now;\n\t\n\tif (unlikely(!mythr->prev_work))\n\t\treturn;\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tdo_process_results(mythr, &tv_now, mythr->prev_work, false);\n}\n\nvoid job_start_abort(struct thr_info *mythr, bool failure)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\t\n\tif (failure)\n\t{\n\t\tproc->deven = DEV_RECOVER_ERR;\n\t\trun_cmd(cmd_idle);\n\t}\n\tmythr->work = NULL;\n\tmythr->_job_transition_in_progress = false;\n}\n\nbool do_process_results(struct thr_info *mythr, struct timeval *tvp_now, struct work *work, bool stopping)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\tstruct timeval tv_hashes;\n\tint64_t hashes = 0;\n\t\n\tif (api->job_process_results)\n\t\thashes = api->job_process_results(mythr, work, stopping);\n\tthread_reportin(mythr);\n\t\n\tif (hashes)\n\t{\n\t\ttimersub(tvp_now, &mythr->tv_results_jobstart, &tv_hashes);\n\t\tif (!hashes_done(mythr, hashes, &tv_hashes, api->can_limit_work ? &mythr->_max_nonce : NULL))\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nvoid do_notifier_select(struct thr_info *thr, struct timeval *tvp_timeout)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct timeval tv_now;\n\tint maxfd;\n\tfd_set rfds;\n\t\n\ttimer_set_now(&tv_now);\n\tFD_ZERO(&rfds);\n\tFD_SET(thr->notifier[0], &rfds);\n\tmaxfd = thr->notifier[0];\n\tFD_SET(thr->work_restart_notifier[0], &rfds);\n\tset_maxfd(&maxfd, thr->work_restart_notifier[0]);\n\tif (thr->mutex_request[1] != INVSOCK)\n\t{\n\t\tFD_SET(thr->mutex_request[0], &rfds);\n\t\tset_maxfd(&maxfd, thr->mutex_request[0]);\n\t}\n\tif (select(maxfd + 1, &rfds, NULL, NULL, select_timeout(tvp_timeout, &tv_now)) < 0)\n\t\treturn;\n\tif (thr->mutex_request[1] != INVSOCK && FD_ISSET(thr->mutex_request[0], &rfds))\n\t{\n\t\t// FIXME: This can only handle one request at a time!\n\t\tpthread_mutex_t *mutexp = &cgpu->device_mutex;\n\t\tnotifier_read(thr->mutex_request);\n\t\tmutex_lock(mutexp);\n\t\tpthread_cond_signal(&cgpu->device_cond);\n\t\tpthread_cond_wait(&cgpu->device_cond, mutexp);\n\t\tmutex_unlock(mutexp);\n\t}\n\tif (FD_ISSET(thr->notifier[0], &rfds)) {\n\t\tnotifier_read(thr->notifier);\n\t}\n\tif (FD_ISSET(thr->work_restart_notifier[0], &rfds))\n\t\tnotifier_read(thr->work_restart_notifier);\n}\n\nvoid cgpu_setup_control_requests(struct cgpu_info * const cgpu)\n{\n\tmutex_init(&cgpu->device_mutex);\n\tnotifier_init(cgpu->thr[0]->mutex_request);\n\tpthread_cond_init(&cgpu->device_cond, bfg_condattr);\n}\n\nvoid cgpu_request_control(struct cgpu_info * const cgpu)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tif (pthread_equal(pthread_self(), thr->pth))\n\t\treturn;\n\tmutex_lock(&cgpu->device_mutex);\n\tnotifier_wake(thr->mutex_request);\n\tpthread_cond_wait(&cgpu->device_cond, &cgpu->device_mutex);\n}\n\nvoid cgpu_release_control(struct cgpu_info * const cgpu)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tif (pthread_equal(pthread_self(), thr->pth))\n\t\treturn;\n\tpthread_cond_signal(&cgpu->device_cond);\n\tmutex_unlock(&cgpu->device_mutex);\n}\n\nstatic\nvoid _minerloop_setup(struct thr_info *mythr)\n{\n\tstruct cgpu_info * const cgpu = mythr->cgpu, *proc;\n\t\n\tif (mythr->work_restart_notifier[1] == -1)\n\t\tnotifier_init(mythr->work_restart_notifier);\n\t\n\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tmythr = proc->thr[0];\n\t\ttimer_set_now(&mythr->tv_watchdog);\n\t\tproc->disable_watchdog = true;\n\t}\n}\n\nvoid minerloop_async(struct thr_info *mythr)\n{\n\tstruct thr_info *thr = mythr;\n\tstruct cgpu_info *cgpu = mythr->cgpu;\n\tstruct device_drv *api = cgpu->drv;\n\tstruct timeval tv_now;\n\tstruct timeval tv_timeout;\n\tstruct cgpu_info *proc;\n\tbool is_running, should_be_running;\n\t\n\t_minerloop_setup(mythr);\n\t\n\twhile (likely(!cgpu->shutdown)) {\n\t\ttv_timeout.tv_sec = -1;\n\t\ttimer_set_now(&tv_now);\n\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t{\n\t\t\tmythr = proc->thr[0];\n\t\t\t\n\t\t\t// Nothing should happen while we're starting a job\n\t\t\tif (unlikely(mythr->busy_state == TBS_STARTING_JOB))\n\t\t\t\tgoto defer_events;\n\t\t\t\n\t\t\tis_running = mythr->work;\n\t\t\tshould_be_running = (proc->deven == DEV_ENABLED && !mythr->pause);\n\t\t\t\n\t\t\tif (should_be_running)\n\t\t\t{\n\t\t\t\tif (unlikely(!(is_running || mythr->_job_transition_in_progress)))\n\t\t\t\t{\n\t\t\t\t\tmt_disable_finish(mythr);\n\t\t\t\t\tgoto djp;\n\t\t\t\t}\n\t\t\t\tif (unlikely(mythr->work_restart))\n\t\t\t\t\tgoto djp;\n\t\t\t}\n\t\t\telse  // ! should_be_running\n\t\t\t{\n\t\t\t\tif (unlikely(mythr->_job_transition_in_progress && timer_isset(&mythr->tv_morework)))\n\t\t\t\t{\n\t\t\t\t\t// Really only happens at startup\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Job transition in progress, with morework timer enabled: unsetting in-progress flag\", proc->proc_repr);\n\t\t\t\t\tmythr->_job_transition_in_progress = false;\n\t\t\t\t}\n\t\t\t\tif (unlikely((is_running || !mythr->_mt_disable_called) && !mythr->_job_transition_in_progress))\n\t\t\t\t{\ndisabled: ;\n\t\t\t\t\tif (is_running)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mythr->busy_state != TBS_GETTING_RESULTS)\n\t\t\t\t\t\t\tdo_get_results(mythr, false);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// Avoid starting job when pending result fetch completes\n\t\t\t\t\t\t\tmythr->_proceed_with_new_job = false;\n\t\t\t\t\t}\n\t\t\t\t\telse  // !mythr->_mt_disable_called\n\t\t\t\t\t\tmt_disable_start__async(mythr);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttimer_unset(&mythr->tv_morework);\n\t\t\t}\n\t\t\t\n\t\t\tif (timer_passed(&mythr->tv_morework, &tv_now))\n\t\t\t{\ndjp: ;\n\t\t\t\tif (!do_job_prepare(mythr, &tv_now))\n\t\t\t\t\tgoto disabled;\n\t\t\t}\n\t\t\t\ndefer_events:\n\t\t\tif (timer_passed(&mythr->tv_poll, &tv_now))\n\t\t\t\tapi->poll(mythr);\n\t\t\t\n\t\t\tif (timer_passed(&mythr->tv_watchdog, &tv_now))\n\t\t\t{\n\t\t\t\ttimer_set_delay(&mythr->tv_watchdog, &tv_now, WATCHDOG_INTERVAL * 1000000);\n\t\t\t\tbfg_watchdog(proc, &tv_now);\n\t\t\t}\n\t\t\t\n\t\t\treduce_timeout_to(&tv_timeout, &mythr->tv_morework);\n\t\t\treduce_timeout_to(&tv_timeout, &mythr->tv_poll);\n\t\t\treduce_timeout_to(&tv_timeout, &mythr->tv_watchdog);\n\t\t}\n\t\t\n\t\tdo_notifier_select(thr, &tv_timeout);\n\t}\n}\n\nstatic\nvoid do_queue_flush(struct thr_info *mythr)\n{\n\tstruct cgpu_info *proc = mythr->cgpu;\n\tstruct device_drv *api = proc->drv;\n\t\n\tapi->queue_flush(mythr);\n\tif (mythr->next_work)\n\t{\n\t\tfree_work(mythr->next_work);\n\t\tmythr->next_work = NULL;\n\t}\n}\n\nvoid minerloop_queue(struct thr_info *thr)\n{\n\tstruct thr_info *mythr;\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct device_drv *api = cgpu->drv;\n\tstruct timeval tv_now;\n\tstruct timeval tv_timeout;\n\tstruct cgpu_info *proc;\n\tbool should_be_running;\n\tstruct work *work;\n\t\n\t_minerloop_setup(thr);\n\t\n\twhile (likely(!cgpu->shutdown)) {\n\t\ttv_timeout.tv_sec = -1;\n\t\ttimer_set_now(&tv_now);\n\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t{\n\t\t\tmythr = proc->thr[0];\n\t\t\t\n\t\t\tshould_be_running = (proc->deven == DEV_ENABLED && !mythr->pause);\nredo:\n\t\t\tif (should_be_running)\n\t\t\t{\n\t\t\t\tif (unlikely(mythr->_mt_disable_called))\n\t\t\t\t\tmt_disable_finish(mythr);\n\t\t\t\t\n\t\t\t\tif (unlikely(mythr->work_restart))\n\t\t\t\t{\n\t\t\t\t\tmythr->work_restart = false;\n\t\t\t\t\tdo_queue_flush(mythr);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (!mythr->queue_full)\n\t\t\t\t{\n\t\t\t\t\tif (mythr->next_work)\n\t\t\t\t\t{\n\t\t\t\t\t\twork = mythr->next_work;\n\t\t\t\t\t\tmythr->next_work = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trequest_work(mythr);\n\t\t\t\t\t\t// FIXME: Allow get_work to return NULL to retry on notification\n\t\t\t\t\t\twork = get_and_prepare_work(mythr);\n\t\t\t\t\t}\n\t\t\t\t\tif (!work)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!api->queue_append(mythr, work))\n\t\t\t\t\t\tmythr->next_work = work;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (unlikely(!mythr->_mt_disable_called))\n\t\t\t{\n\t\t\t\tdo_queue_flush(mythr);\n\t\t\t\tmt_disable_start(mythr);\n\t\t\t}\n\t\t\t\n\t\t\tif (timer_passed(&mythr->tv_poll, &tv_now))\n\t\t\t\tapi->poll(mythr);\n\t\t\t\n\t\t\tif (timer_passed(&mythr->tv_watchdog, &tv_now))\n\t\t\t{\n\t\t\t\ttimer_set_delay(&mythr->tv_watchdog, &tv_now, WATCHDOG_INTERVAL * 1000000);\n\t\t\t\tbfg_watchdog(proc, &tv_now);\n\t\t\t}\n\t\t\t\n\t\t\tshould_be_running = (proc->deven == DEV_ENABLED && !mythr->pause);\n\t\t\tif (should_be_running && !mythr->queue_full)\n\t\t\t\tgoto redo;\n\t\t\t\n\t\t\treduce_timeout_to(&tv_timeout, &mythr->tv_poll);\n\t\t\treduce_timeout_to(&tv_timeout, &mythr->tv_watchdog);\n\t\t}\n\t\t\n\t\t// HACK: Some designs set the main thr tv_poll from secondary thrs\n\t\treduce_timeout_to(&tv_timeout, &cgpu->thr[0]->tv_poll);\n\t\t\n\t\tdo_notifier_select(thr, &tv_timeout);\n\t}\n}\n\nvoid *miner_thread(void *userdata)\n{\n\tstruct thr_info *mythr = userdata;\n\tstruct cgpu_info *cgpu = mythr->cgpu;\n\tstruct device_drv *drv = cgpu->drv;\n\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\n\tchar threadname[20];\n\tsnprintf(threadname, 20, \"miner_%s\", cgpu->proc_repr_ns);\n\tRenameThread(threadname);\n\n\tif (drv->thread_init && !drv->thread_init(mythr)) {\n\t\tdev_error(cgpu, REASON_THREAD_FAIL_INIT);\n\t\tfor (struct cgpu_info *slave = cgpu->next_proc; slave && !slave->threads; slave = slave->next_proc)\n\t\t\tdev_error(slave, REASON_THREAD_FAIL_INIT);\n\t\t__thr_being_msg(LOG_ERR, mythr, \"failure, exiting\");\n\t\tgoto out;\n\t}\n\n\tif (drv_ready(cgpu) && !cgpu->already_set_defaults)\n\t\tcgpu_set_defaults(cgpu);\n\t\n\tthread_reportout(mythr);\n\tapplog(LOG_DEBUG, \"Popping ping in miner thread\");\n\tnotifier_read(mythr->notifier);  // Wait for a notification to start\n\t\n\tcgtime(&cgpu->cgminer_stats.start_tv);\n\tif (drv->minerloop)\n\t\tdrv->minerloop(mythr);\n\telse\n\t\tminerloop_scanhash(mythr);\n\t__thr_being_msg(LOG_NOTICE, mythr, \"shutting down\");\n\nout: ;\n\tstruct cgpu_info *proc = cgpu;\n\tdo\n\t{\n\t\tproc->deven = DEV_DISABLED;\n\t\tproc->status = LIFE_DEAD2;\n\t}\n\twhile ( (proc = proc->next_proc) && !proc->threads);\n\tmythr->getwork = 0;\n\tmythr->has_pth = false;\n\tcgsleep_ms(1);\n\t\n\tif (drv->thread_shutdown)\n\t\tdrv->thread_shutdown(mythr);\n\n\tnotifier_destroy(mythr->notifier);\n\n\treturn NULL;\n}\n\nstatic pthread_mutex_t _add_cgpu_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic\nbool _add_cgpu(struct cgpu_info *cgpu)\n{\n\tint lpcount;\n\t\n\tif (!cgpu->procs)\n\t\tcgpu->procs = 1;\n\tlpcount = cgpu->procs;\n\tcgpu->device = cgpu;\n\t\n\tcgpu->dev_repr = malloc(6);\n\tcgpu->dev_repr_ns = malloc(6);\n\t\n#ifdef NEED_BFG_LOWL_VCOM\n\tmaybe_strdup_if_null(&cgpu->dev_manufacturer, detectone_meta_info.manufacturer);\n\tmaybe_strdup_if_null(&cgpu->dev_product,      detectone_meta_info.product);\n\tmaybe_strdup_if_null(&cgpu->dev_serial,       detectone_meta_info.serial);\n#endif\n\t\n\tdevices_new = realloc(devices_new, sizeof(struct cgpu_info *) * (total_devices_new + lpcount + 1));\n\tdevices_new[total_devices_new++] = cgpu;\n\t\n\tif (lpcount > 1)\n\t{\n\t\tint tpp = cgpu->threads / lpcount;\n\t\tstruct cgpu_info **nlp_p, *slave;\n\t\t\n\t\tnlp_p = &cgpu->next_proc;\n\t\tfor (int i = 1; i < lpcount; ++i)\n\t\t{\n\t\t\tslave = malloc(sizeof(*slave));\n\t\t\t*slave = *cgpu;\n\t\t\tslave->proc_id = i;\n\t\t\tslave->threads = tpp;\n\t\t\tdevices_new[total_devices_new++] = slave;\n\t\t\t*nlp_p = slave;\n\t\t\tnlp_p = &slave->next_proc;\n\t\t}\n\t\t*nlp_p = NULL;\n\t\tcgpu->proc_id = 0;\n\t\tcgpu->threads -= (tpp * (lpcount - 1));\n\t}\n\n\trenumber_cgpu(cgpu);\n\tcgpu->last_device_valid_work = time(NULL);\n\t\n\treturn true;\n}\n\nbool add_cgpu(struct cgpu_info *cgpu)\n{\n\tmutex_lock(&_add_cgpu_mutex);\n\tconst bool rv = _add_cgpu(cgpu);\n\tmutex_unlock(&_add_cgpu_mutex);\n\treturn rv;\n}\n\nvoid add_cgpu_live(void *p)\n{\n\tadd_cgpu(p);\n}\n\nbool add_cgpu_slave(struct cgpu_info *cgpu, struct cgpu_info *prev_cgpu)\n{\n\tif (!prev_cgpu)\n\t\treturn add_cgpu(cgpu);\n\t\n\twhile (prev_cgpu->next_proc)\n\t\tprev_cgpu = prev_cgpu->next_proc;\n\t\n\tmutex_lock(&_add_cgpu_mutex);\n\t\n\tint old_total_devices = total_devices_new;\n\tif (!_add_cgpu(cgpu))\n\t{\n\t\tmutex_unlock(&_add_cgpu_mutex);\n\t\treturn false;\n\t}\n\tprev_cgpu->next_proc = devices_new[old_total_devices];\n\t\n\tmutex_unlock(&_add_cgpu_mutex);\n\t\n\treturn true;\n}\n\nconst char *proc_set_device_help(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tconst struct bfg_set_device_definition *sdf;\n\tchar *p = replybuf;\n\tbool first = true;\n\t\n\t*out_success = SDR_HELP;\n\tsdf = proc->set_device_funcs;\n\tif (!sdf)\nnohelp:\n\t\treturn \"No help available\";\n\t\n\tsize_t matchlen = 0;\n\tif (newvalue)\n\t\twhile (newvalue[matchlen] && !isspace(newvalue[matchlen]))\n\t\t\t++matchlen;\n\t\n\tfor ( ; sdf->optname; ++sdf)\n\t{\n\t\tif (!sdf->description)\n\t\t\tcontinue;\n\t\tif (matchlen && (strncasecmp(optname, sdf->optname, matchlen) || optname[matchlen]))\n\t\t\tcontinue;\n\t\tif (first)\n\t\t\tfirst = false;\n\t\telse\n\t\t\tp++[0] = '\\n';\n\t\tp += sprintf(p, \"%s: %s\", sdf->optname, sdf->description);\n\t}\n\tif (replybuf == p)\n\t\tgoto nohelp;\n\treturn replybuf;\n}\n\nconst char *proc_set_device_temp_cutoff(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tint target_diff = proc->cutofftemp - proc->targettemp;\n\tproc->cutofftemp = atoi(newvalue);\n\tif (!proc->targettemp_user)\n\t\tproc->targettemp = proc->cutofftemp - target_diff;\n\treturn NULL;\n}\n\nconst char *proc_set_device_temp_target(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tproc->targettemp = atoi(newvalue);\n\tproc->targettemp_user = true;\n\treturn NULL;\n}\n\nstatic inline\nvoid _set_auto_sdr(enum bfg_set_device_replytype * const out_success, const char * const rv, const char * const optname)\n{\n\tif (!rv)\n\t\t*out_success = SDR_OK;\n\telse\n\tif (!strcasecmp(optname, \"help\"))\n\t\t*out_success = SDR_HELP;\n\telse\n\t\t*out_success = SDR_ERR;\n}\n\nstatic\nconst char *_proc_set_device(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tconst struct bfg_set_device_definition *sdf;\n\t\n\tsdf = proc->set_device_funcs;\n\tif (!sdf)\n\t{\n\t\t*out_success = SDR_NOSUPP;\n\t\treturn \"Device does not support setting parameters.\";\n\t}\n\tfor ( ; sdf->optname; ++sdf)\n\t\tif (!strcasecmp(optname, sdf->optname))\n\t\t{\n\t\t\t*out_success = SDR_AUTO;\n\t\t\tconst char * const rv = sdf->func(proc, optname, newvalue, replybuf, out_success);\n\t\t\tif (SDR_AUTO == *out_success)\n\t\t\t\t_set_auto_sdr(out_success, rv, optname);\n\t\t\treturn rv;\n\t\t}\n\t\n\tif (!strcasecmp(optname, \"help\"))\n\t\treturn proc_set_device_help(proc, optname, newvalue, replybuf, out_success);\n\t\n\t*out_success = SDR_UNKNOWN;\n\tsprintf(replybuf, \"Unknown option: %s\", optname);\n\treturn replybuf;\n}\n\nstatic\nconst char *__proc_set_device(struct cgpu_info * const proc, char * const optname, char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tif (proc->drv->set_device)\n\t{\n\t\tconst char * const rv = proc->drv->set_device(proc, optname, newvalue, replybuf);\n\t\t_set_auto_sdr(out_success, rv, optname);\n\t\treturn rv;\n\t}\n\t\n\treturn _proc_set_device(proc, optname, newvalue, replybuf, out_success);\n}\n\nconst char *proc_set_device(struct cgpu_info * const proc, char * const optname, char *newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tif (!newvalue)\n\t\tnewvalue = \"\";\n\tconst char * const rv = __proc_set_device(proc, optname, newvalue, replybuf, out_success);\n\tswitch (*out_success)\n\t{\n\t\tcase SDR_NOSUPP:\n\t\tcase SDR_UNKNOWN:\n\t\t\tif (!strcasecmp(optname, \"temp-cutoff\") || !strcasecmp(optname, \"temp_cutoff\"))\n\t\t\t\treturn proc_set_device_temp_cutoff(proc, optname, newvalue, replybuf, out_success);\n\t\t\telse\n\t\t\tif (!strcasecmp(optname, \"temp-target\") || !strcasecmp(optname, \"temp_target\"))\n\t\t\t\treturn proc_set_device_temp_target(proc, optname, newvalue, replybuf, out_success);\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn rv;\n}\n\n#ifdef HAVE_CURSES\nconst char *proc_set_device_tui_wrapper(struct cgpu_info * const proc, char * const optname, const bfg_set_device_func_t func, const char * const prompt, const char * const success_msg)\n{\n\tstatic char replybuf[0x2001];\n\tchar * const cvar = curses_input(prompt);\n\tif (!cvar)\n\t\treturn \"Cancelled\\n\";\n\t\n\tenum bfg_set_device_replytype success;\n\tconst char * const reply = func(proc, optname, cvar, replybuf, &success);\n\tfree(cvar);\n\t\n\tif (reply)\n\t{\n\t\tif (reply != replybuf)\n\t\t\tsnprintf(replybuf, sizeof(replybuf), \"%s\\n\", reply);\n\t\telse\n\t\t\ttailsprintf(replybuf, sizeof(replybuf), \"\\n\");\n\t\treturn replybuf;\n\t}\n\t\n\treturn success_msg ?: \"Successful\\n\";\n}\n#endif\n\n#ifdef NEED_BFG_LOWL_VCOM\nbool _serial_detect_all(struct lowlevel_device_info * const info, void * const userp)\n{\n\tdetectone_func_t detectone = userp;\n\t\n\tif (serial_claim(info->path, NULL))\n\t\tapplogr(false, LOG_DEBUG, \"%s is already claimed... skipping probes\", info->path);\n\t\n\treturn detectone(info->path);\n}\n#endif\n\n// NOTE: This is never used for any actual VCOM devices, which should use the new lowlevel interface\nint _serial_detect(struct device_drv *api, detectone_func_t detectone, autoscan_func_t autoscan, int flags)\n{\n\tstruct string_elist *iter, *tmp;\n\tconst char *dev, *colon;\n\tbool inhibitauto = flags & 4;\n\tchar found = 0;\n\tbool forceauto = flags & 1;\n\tbool hasname;\n\tsize_t namel = strlen(api->name);\n\tsize_t dnamel = strlen(api->dname);\n\n#ifdef NEED_BFG_LOWL_VCOM\n\tclear_detectone_meta_info();\n#endif\n\tDL_FOREACH_SAFE(scan_devices, iter, tmp) {\n\t\tdev = iter->string;\n\t\tif ((colon = strchr(dev, ':')) && colon[1] != '\\0') {\n\t\t\tsize_t idlen = colon - dev;\n\n\t\t\t// allow either name:device or dname:device\n\t\t\tif ((idlen != namel || strncasecmp(dev, api->name, idlen))\n\t\t\t&&  (idlen != dnamel || strncasecmp(dev, api->dname, idlen)))\n\t\t\t\tcontinue;\n\n\t\t\tdev = colon + 1;\n\t\t\thasname = true;\n\t\t}\n\t\telse\n\t\t\thasname = false;\n\t\tif (!strcmp(dev, \"auto\"))\n\t\t\tforceauto = true;\n\t\telse if (!strcmp(dev, \"noauto\"))\n\t\t\tinhibitauto = true;\n\t\telse\n\t\tif ((flags & 2) && !hasname)\n\t\t\tcontinue;\n\t\telse\n\t\tif (!detectone)\n\t\t{}  // do nothing\n\t\telse\n\t\tif (!strcmp(dev, \"all\"))\n\t\t{}  // n/a\n\t\telse if (detectone(dev)) {\n\t\t\tstring_elist_del(&scan_devices, iter);\n\t\t\t++found;\n\t\t}\n\t}\n\t\n\tif ((forceauto || !(inhibitauto || found)) && autoscan)\n\t\tfound += autoscan();\n\n\treturn found;\n}\n\nstatic\nFILE *_open_bitstream(const char *path, const char *subdir, const char *sub2, const char *filename)\n{\n\tchar fullpath[PATH_MAX];\n\tstrcpy(fullpath, path);\n\tstrcat(fullpath, \"/\");\n\tif (subdir) {\n\t\tstrcat(fullpath, subdir);\n\t\tstrcat(fullpath, \"/\");\n\t}\n\tif (sub2) {\n\t\tstrcat(fullpath, sub2);\n\t\tstrcat(fullpath, \"/\");\n\t}\n\tstrcat(fullpath, filename);\n\treturn fopen(fullpath, \"rb\");\n}\n#define _open_bitstream(path, subdir, sub2)  do {  \\\n\tf = _open_bitstream(path, subdir, sub2, filename);  \\\n\tif (f)  \\\n\t\treturn f;  \\\n} while(0)\n\n#define _open_bitstream2(path, path3)  do {  \\\n\t_open_bitstream(path, NULL, path3);  \\\n\t_open_bitstream(path, \"../share/\" PACKAGE, path3);  \\\n\t_open_bitstream(path, \"../\" PACKAGE, path3);  \\\n} while(0)\n\n#define _open_bitstream3(path)  do {  \\\n\t_open_bitstream2(path, dname);  \\\n\t_open_bitstream2(path, \"bitstreams\");  \\\n\t_open_bitstream2(path, NULL);  \\\n} while(0)\n\nFILE *open_bitstream(const char *dname, const char *filename)\n{\n\tFILE *f;\n\n\t_open_bitstream3(opt_kernel_path);\n\t_open_bitstream3(cgminer_path);\n\t_open_bitstream3(\".\");\n\n\treturn NULL;\n}\n\nvoid close_device_fd(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tconst int fd = proc->device_fd;\n\t\n\tif (fd == -1)\n\t\treturn;\n\t\n\tif (close(fd))\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Error closing device fd\", proc->proc_repr);\n\telse\n\t{\n\t\tproc->device_fd = -1;\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Closed device fd\", proc->proc_repr);\n\t}\n}\n\n\nstruct cgpu_info *device_proc_by_id(const struct cgpu_info * const dev, const int procid)\n{\n\tstruct cgpu_info *proc = (void*)dev;\n\tfor (int i = 0; i < procid; ++i)\n\t{\n\t\tproc = proc->next_proc;\n\t\tif (unlikely((!proc) || proc->device != dev))\n\t\t\treturn NULL;\n\t}\n\treturn proc;\n}\n"
        },
        {
          "name": "deviceapi.h",
          "type": "blob",
          "size": 4.5517578125,
          "content": "#ifndef BFG_DEVICEAPI_H\n#define BFG_DEVICEAPI_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#include <utlist.h>\n\n#include \"miner.h\"\n\nstruct driver_registration;\nstruct driver_registration {\n\tconst struct device_drv *drv;\n\t\n\tstruct driver_registration *next_dname;\n\tstruct driver_registration *next_prio;\n\tstruct driver_registration *next;  // DO NOT USE\n};\n\nextern struct driver_registration *_bfg_drvreg1;\nextern struct driver_registration *_bfg_drvreg2;\nextern void bfg_devapi_init();\n\n#define BFG_FOREACH_DRIVER_BY_DNAME(reg)  \\\n\tLL_FOREACH2(_bfg_drvreg1, reg, next_dname)\n#define BFG_FOREACH_DRIVER_BY_PRIORITY(reg)  \\\n\tLL_FOREACH2(_bfg_drvreg2, reg, next_prio)\n\nextern void _bfg_register_driver(const struct device_drv *);\n#define BFG_REGISTER_DRIVER(drv)                \\\n\tstruct device_drv drv;                      \\\n\t__attribute__((constructor))                \\\n\tstatic void __bfg_register_drv_ ## drv() {  \\\n\t\t_bfg_register_driver(&drv);             \\\n\t}                                           \\\n// END BFG_REGISTER_DRIVER\n\nextern bool bfg_need_detect_rescan;\n\nextern float common_sha256d_and_scrypt_min_nonce_diff(struct cgpu_info *, const struct mining_algorithm *);\nextern float common_scrypt_min_nonce_diff(struct cgpu_info *, const struct mining_algorithm *);\n\nextern void request_work(struct thr_info *);\nextern struct work *get_work(struct thr_info *);\nextern bool hashes_done(struct thr_info *, int64_t hashes, struct timeval *tvp_hashes, uint32_t *max_nonce);\nextern bool hashes_done2(struct thr_info *, int64_t hashes, uint32_t *max_nonce);\nextern void mt_disable_start(struct thr_info *);\nextern void mt_disable_finish(struct thr_info *);\nextern void mt_disable(struct thr_info *);  // blocks until reenabled\n\nextern int restart_wait(struct thr_info *, unsigned int ms);\nextern void minerloop_scanhash(struct thr_info *);\n\nextern void mt_disable_start__async(struct thr_info *);\nextern bool do_job_prepare(struct thr_info *, struct timeval *tvp_now);\nextern void job_prepare_complete(struct thr_info *);\nextern void do_get_results(struct thr_info *, bool proceed_with_new_job);\nextern void job_results_fetched(struct thr_info *);\nextern void do_job_start(struct thr_info *);\nextern void mt_job_transition(struct thr_info *);\nextern void job_start_complete(struct thr_info *);\nextern void job_start_abort(struct thr_info *, bool failure);\nextern bool do_process_results(struct thr_info *, struct timeval *tvp_now, struct work *, bool stopping);\nextern void minerloop_async(struct thr_info *);\n\nextern void minerloop_queue(struct thr_info *);\n\n// Establishes a simple way for external threads to directly communicate with device\nextern void cgpu_setup_control_requests(struct cgpu_info *);\nextern void cgpu_request_control(struct cgpu_info *);\nextern void cgpu_release_control(struct cgpu_info *);\n\nextern void *miner_thread(void *);\n\nextern void add_cgpu_live(void*);\nextern bool add_cgpu_slave(struct cgpu_info *, struct cgpu_info *master);\n\nenum bfg_set_device_replytype {\n\tSDR_AUTO,\n\tSDR_OK,\n\tSDR_ERR,\n\tSDR_HELP,\n\tSDR_UNKNOWN,\n\tSDR_NOSUPP,\n};\ntypedef const char *(*bfg_set_device_func_t)(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\nstruct bfg_set_device_definition {\n\tconst char *optname;\n\tbfg_set_device_func_t func;\n\tconst char *description;\n};\nextern const char *proc_set_device(struct cgpu_info *proc, char *optname, char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\n#ifdef HAVE_CURSES\nextern const char *proc_set_device_tui_wrapper(struct cgpu_info *proc, char *optname, bfg_set_device_func_t, const char *prompt, const char *success_msg);\n#endif\n\ntypedef bool(*detectone_func_t)(const char*);\ntypedef int(*autoscan_func_t)();\n\nenum generic_detect_flags {\n\tGDF_REQUIRE_DNAME = 2,\n\tGDF_DEFAULT_NOAUTO = 4,\n};\n\nextern int _serial_detect(struct device_drv *api, detectone_func_t, autoscan_func_t, int flags);\n#define noserial_detect_manual(api, autoscan)  \\\n\t_serial_detect(api, NULL     , autoscan, 4)\n#define generic_detect(drv, detectone, autoscan, flags)  _serial_detect(drv, detectone, autoscan, flags)\n\nextern FILE *open_bitstream(const char *dname, const char *filename);\n\nextern void close_device_fd(struct thr_info *);\n\n#define for_each_managed_proc(procvar, dev)  \\\n\tfor (struct cgpu_info *procvar = dev; procvar; procvar = procvar->next_proc)\n#define for_each_logical_proc(procvar, dev)  \\\n\tfor (struct cgpu_info *procvar = dev; procvar && procvar->device == (dev); procvar = procvar->next_proc)\nextern struct cgpu_info *device_proc_by_id(const struct cgpu_info *dev, int procid);\n\n#endif\n"
        },
        {
          "name": "driver-aan.c",
          "type": "blob",
          "size": 17.8505859375,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n * Copyright 2013 Zefir Kurtisi\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"deviceapi.h\"\n#include \"driver-aan.h\"\n#include \"logging.h\"\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#define AAN_DEFAULT_NONCE_PDIFF  8\n\n// WARNING: Do not just change this without fixing aan_freq2pll!\n#define AAN_MAX_FREQ  6132\n\n#define AAN_PROBE_TIMEOUT_US  3750000\n#define AAN_INIT_TIMEOUT_US   5000000\n#define AAN_READ_INTERVAL_US   100000\n\n#define AAN_REGISTER_SIZE  6\n\nenum aan_cmd {\n\tAAN_BIST_START           = 0x01,\n\tAAN_BIST_FIX             = 0x03,\n\tAAN_RESET                = 0x04,\n\tAAN_WRITE_JOB            = 0x07,\n\tAAN_READ_RESULT          = 0x08,\n\tAAN_WRITE_REG            = 0x09,\n\tAAN_READ_REG             = 0x0a,\n\tAAN_READ_REG_RESP        = 0x1a,\n};\n\nstatic\nunsigned aan_pll2freq(const uint16_t pll)\n{\n\tconst uint8_t pll_postdiv = (pll >> 0xe);\n\tconst uint8_t pll_prediv = (pll >> 9) & 0x1f;\n\tconst uint16_t pll_fbdiv = pll & 0x1ff;\n\treturn (12 * pll_fbdiv) / pll_prediv / (1 << (pll_postdiv - 1));\n}\n\nstatic\nuint16_t aan_freq2pll(unsigned freq)\n{\nretry: ;\n\tuint8_t postdiv = 3, prediv = 3;\n\tuint16_t fbdiv = freq / 3;\n\tif (fbdiv * 3 == freq)\n\t\tprediv = 1;\n\telse\n\t\tfbdiv = freq;\n\tif (!(fbdiv & 3))\n\t{\n\t\tfbdiv >>= 2;\n\t\tpostdiv = 1;\n\t}\n\telse\n\tif (!(fbdiv & 1))\n\t{\n\t\tfbdiv >>= 1;\n\t\tpostdiv = 2;\n\t}\n\tif (fbdiv > 0x1ff)\n\t{\n\t\t--freq;\n\t\tgoto retry;\n\t}\n\tconst uint16_t pll = (((postdiv << 5) | prediv) << 9) | fbdiv;\n\treturn pll;\n}\n\nstatic\nvoid _test_aan_pll(const unsigned expect, const uint8_t postdiv, const uint8_t prediv, const uint16_t fbdiv)\n{\n\tconst uint16_t pll = (((postdiv << 5) | prediv) << 9) | fbdiv;\n\tconst unsigned got = aan_pll2freq(pll);\n\tif (got != expect)\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_WARNING, \"%s test failed for %4u(%x,%02x,%3d): got %4u\", \"aan_pll2freq\", expect, postdiv, prediv, fbdiv, got);\n\t}\n}\n\nstatic\nvoid _test_aan_pll2(const unsigned freq)\n{\n\tconst uint16_t pll = aan_freq2pll(freq);\n\tconst unsigned got = aan_pll2freq(pll);\n\tif (got / 12 != freq / 12)\n\t{\n\t\t++unittest_failures;\n\t\tconst uint8_t postdiv = (pll >> 0xe);\n\t\tconst uint8_t prediv = (pll >> 9) & 0x1f;\n\t\tconst uint16_t fbdiv = pll & 0x1ff;\n\t\tapplog(LOG_WARNING, \"%s test failed for %4u: got %4u(%x,%02x,%3d)\", \"aan_freq2pll\", freq, got, postdiv, prediv, fbdiv);\n\t}\n}\n\nvoid test_aan_pll(void)\n{\n\t_test_aan_pll(1000, 0b01,0b00011,0b011111010);\n\t_test_aan_pll( 950, 0b10,0b00011,0b111011011);\n\t_test_aan_pll( 900, 0b01,0b00001,0b001001011);\n\t_test_aan_pll( 850, 0b10,0b00011,0b110101001);\n\t_test_aan_pll( 800, 0b01,0b00011,0b011001000);\n\t_test_aan_pll( 750, 0b10,0b00001,0b001111101);\n\t_test_aan_pll( 700, 0b01,0b00011,0b010101111);\n\t_test_aan_pll( 650, 0b10,0b00011,0b101000101);\n\t_test_aan_pll( 600, 0b01,0b00001,0b000110010);\n\t_test_aan_pll( 550, 0b10,0b00011,0b100010011);\n\t_test_aan_pll( 500, 0b10,0b00011,0b011111010);\n\t_test_aan_pll( 100, 0b11,0b00011,0b001100100);\n\tfor (unsigned i = 1; i <= AAN_MAX_FREQ; ++i)\n\t\t_test_aan_pll2(i);\n}\n\nstatic void aan_spi_parse_rx(struct spi_port *);\n\nstatic\nvoid aan_spi_cmd_queue(struct spi_port * const spi, const uint8_t cmd, const uint8_t chip, const void * const data, const size_t datalen)\n{\n\tconst struct aan_hooks * const hooks = spi->userp;\n\tconst uint8_t cmdbuf[2] = {cmd, chip};\n\thooks->precmd(spi);\n\tspi_emit_buf(spi, cmdbuf, sizeof(cmdbuf));\n\tif (datalen)\n\t\tspi_emit_buf(spi, data, datalen);\n}\n\nstatic\nbool aan_spi_txrx(struct spi_port * const spi)\n{\n\tif (unlikely(!spi_txrx(spi)))\n\t\treturn false;\n\t\n\taan_spi_parse_rx(spi);\n\treturn true;\n}\n\nstatic\nbool aan_spi_cmd_send(struct spi_port * const spi, const uint8_t cmd, const uint8_t chip, const void * const data, const size_t datalen)\n{\n\taan_spi_cmd_queue(spi, cmd, chip, data, datalen);\n\treturn aan_spi_txrx(spi);\n}\n\nstatic\nbool aan_spi_cmd_resp(struct spi_port * const spi, const uint8_t cmd, const uint8_t chip, const struct timeval * const tvp_timeout)\n{\n\tconst uint8_t cmdbuf[2] = {cmd, chip};\n\t\n\tuint8_t * const rx = spi_getrxbuf(spi);\n\twhile (true)\n\t{\n\t\tspi_emit_nop(spi, 2);\n\t\tif (unlikely(!spi_txrx(spi)))\n\t\t\treturn false;\n\t\tif (!memcmp(rx, cmdbuf, 2))\n\t\t\tbreak;\n\t\taan_spi_parse_rx(spi);\n\t\tif (unlikely(tvp_timeout && timer_passed(tvp_timeout, NULL)))\n\t\t\treturn false;\n\t}\n\tspi_clear_buf(spi);\n\t\n\treturn true;\n}\n\nstatic\nbool aan_spi_cmd(struct spi_port * const spi, const uint8_t cmd, const uint8_t chip, const void * const data, const size_t datalen, const struct timeval * const tvp_timeout)\n{\n\tif (!aan_spi_cmd_send(spi, cmd, chip, data, datalen))\n\t\treturn false;\n\tif (!aan_spi_cmd_resp(spi, cmd, chip, tvp_timeout))\n\t\treturn false;\n\treturn true;\n}\n\nbool aan_read_reg_direct(struct spi_port * const spi, const uint8_t chip, void * const out_buf, const struct timeval * const tvp_timeout)\n{\n\tif (!aan_spi_cmd_send(spi, AAN_READ_REG, chip, NULL, 0))\n\t\treturn false;\n\tif (!aan_spi_cmd_resp(spi, AAN_READ_REG_RESP, chip, tvp_timeout))\n\t\treturn false;\n\t\n\tspi_emit_nop(spi, AAN_REGISTER_SIZE);\n\tif (!spi_txrx(spi))\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s failed\", __func__, \"spi_txrx\");\n\t\n\tuint8_t * const rx = spi_getrxbuf(spi);\n\tmemcpy(out_buf, rx, AAN_REGISTER_SIZE);\n\t\n\treturn true;\n}\n\nstatic inline\nbool aan_read_reg(struct spi_port * const spi, const uint8_t chip, void * const out_buf, const struct timeval * const tvp_timeout)\n{\n\tconst struct aan_hooks * const hooks = spi->userp;\n\treturn hooks->read_reg(spi, chip, out_buf, tvp_timeout);\n}\n\nint aan_detect_spi(int * const out_chipcount, struct spi_port * const * const spi_a, const int spi_n)\n{\n\tstruct timeval tv_timeout;\n\ttimer_set_delay_from_now(&tv_timeout, AAN_PROBE_TIMEOUT_US);\n\t\n\tint state[spi_n];\n\tint completed = 0;\n\t\n\tfor (int i = 0; i < spi_n; ++i)\n\t{\n\t\tstruct spi_port * const spi = spi_a[i];\n\t\taan_spi_cmd_send(spi, state[i] = AAN_RESET, AAN_ALL_CHIPS, NULL, 0);\n\t\tout_chipcount[i] = -1;\n\t}\n\t\n\tdo {\n\t\tfor (int i = 0; i < spi_n; ++i)\n\t\t{\n\t\t\tif (state[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tstruct spi_port * const spi = spi_a[i];\n\t\t\tspi_emit_nop(spi, 2);\n\t\t\tif (unlikely(!spi_txrx(spi)))\n\t\t\t{\nspifail:\n\t\t\t\tstate[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuint8_t * const rx = spi_getrxbuf(spi);\n\t\t\tif (rx[0] == state[i] && rx[1] == AAN_ALL_CHIPS)\n\t\t\t{\n\t\t\t\tswitch (state[i])\n\t\t\t\t{\n\t\t\t\t\tcase AAN_RESET:\n\t\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Reset complete\", spi->repr);\n\t\t\t\t\t\tspi_clear_buf(spi);\n\t\t\t\t\t\taan_spi_cmd_send(spi, state[i] = AAN_BIST_START, AAN_ALL_CHIPS, NULL, 0);\n\t\t\t\t\t\tspi_emit_nop(spi, 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AAN_BIST_START:\n\t\t\t\t\t\tif (unlikely(!spi_txrx(spi)))\n\t\t\t\t\t\t\tgoto spifail;\n\t\t\t\t\t\tout_chipcount[i] = rx[1];\n\t\t\t\t\t\tstate[i] = -1;\n\t\t\t\t\t\t++completed;\n\t\t\t\t\t\tapplog(LOG_DEBUG, \"%s: BIST_START complete (%d chips)\", spi->repr, rx[1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspi_clear_buf(spi);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taan_spi_parse_rx(spi);\n\t\t}\n\t} while (completed < spi_n && likely(!timer_passed(&tv_timeout, NULL)));\n\t\n\tapplog(LOG_DEBUG, \"%s completed for %d out of %d SPI ports\", __func__, completed, spi_n);\n\t\n\treturn completed;\n}\n\nbool aan_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const master_dev = master_thr->cgpu, *dev = NULL;\n\tstruct aan_board_data *board = NULL;\n\tstruct timeval tv_timeout, tv_now;\n\tint chipid = 0;\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tstruct spi_port * const spi = proc->device_data;\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\n\t\tif (dev != proc->device)\n\t\t{\n\t\t\tdev = proc->device;\n\t\t\tchipid = 0;\n\t\t\ttimer_set_now(&tv_now);\n\t\t\tboard = malloc(sizeof(*board));\n\t\t\t*board = (struct aan_board_data){\n\t\t\t\t.master_dev = master_dev,\n\t\t\t\t.spi = spi,\n\t\t\t\t.tv_next_poll = tv_now,\n\t\t\t};\n\t\t\tspi->cgpu = dev;\n\t\t\t\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\ttimer_set_delay(&tv_timeout, &tv_now, AAN_INIT_TIMEOUT_US);\n\t\t\t\tif (aan_spi_cmd(spi, AAN_BIST_FIX, AAN_ALL_CHIPS, NULL, 0, &tv_timeout))\n\t\t\t\t\tbreak;\n\t\t\t\tapplog(LOG_ERR, \"%s: Failed to %s\", proc->dev_repr, \"BIST_FIX\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tproc->device_data = board;\n\t\tstruct aan_chip_data * const chip = malloc(sizeof(*chip));\n\t\tthr->cgpu_data = chip;\n\t\tthr->queue_full = true;\n\t\t*chip = (struct aan_chip_data){\n\t\t\t.chipid = ++chipid,\n\t\t\t.desired_nonce_pdiff = AAN_DEFAULT_NONCE_PDIFF,\n\t\t\t.desired_pllreg = 0x87a9,  // 850 MHz\n\t\t};\n\t\t\n\t\tcgpu_set_defaults(proc);\n\t}\n\tmaster_thr->tv_poll = tv_now;\n\t\n\treturn true;\n}\n\nstatic\nbool aan_spi_send_work(struct spi_port * const spi, const uint8_t chipid, const uint8_t jobid, const struct work * const work)\n{\n\tuint8_t buf[0x38];\n\t\n\tswab256(&buf[0], work->midstate);\n\tswap32yes(&buf[0x20], &work->data[0x40], 3);\n\tmemset(&buf[0x2c], 0, 4);         // start nonce\n\tuint32_t compressed_target = (uint32_t)(0x10000 / work->nonce_diff) | (/*exponent*/ 0x1d << 24);\n\tpk_u32le(buf, 0x30, compressed_target);\n\tmemset(&buf[0x34], 0xff, 4);      // end nonce\n\t\n\treturn aan_spi_cmd_send(spi, AAN_WRITE_JOB | (jobid << 4), chipid, buf, sizeof(buf));\n}\n\nstatic bool set_work(struct cgpu_info *, uint8_t, struct work *);\n\nbool aan_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\tstruct cgpu_info *dev = proc->device;\n\tstruct aan_board_data *board = dev->device_data;\n\tstruct cgpu_info * const master_dev = board->master_dev;\n\tstruct aan_board_data * const master_board = master_dev->device_data;\n\t\n\tapplog(LOG_DEBUG, \"%s: queue_append queues_empty=%d\", proc->proc_repr, master_board->queues_empty-1);\n\t\n\twork->nonce_diff = work->work_difficulty;\n\tif (work->nonce_diff > chip->desired_nonce_pdiff)\n\t\twork->nonce_diff = chip->desired_nonce_pdiff;\n\tchip->current_nonce_pdiff = work->nonce_diff;\n\t\n\tif (set_work(dev, proc->proc_id + 1, work))\n\t\thashes_done2(thr, 0x100000000, NULL);\n\t\n\tthr->queue_full = true;\n\tif (!--master_board->queues_empty)\n\t{\n\t\tstruct thr_info * const master_thr = master_dev->thr[0];\n\t\t\n\t\t// Reactivate polling\n\t\tdev = NULL;\n\t\tfor_each_managed_proc(proc, master_dev)\n\t\t{\n\t\t\tif (dev == proc->device)\n\t\t\t\tcontinue;\n\t\t\tdev = proc->device;\n\t\t\tboard = dev->device_data;\n\t\t\t\n\t\t\treduce_timeout_to(&master_thr->tv_poll, &board->tv_next_poll);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid aan_queue_flush(struct thr_info * const thr)\n{\n\t// TODO\n}\n\nstruct cgpu_info *aan_proc_for_chipid(struct cgpu_info * const dev, const int chipid)\n{\n\tstruct cgpu_info *proc = dev;\n\tfor (int i = 1; i < chipid; ++i)\n\t{\n\t\tproc = proc->next_proc;\n\t\tif (unlikely((!proc) || proc->device != dev))\n\t\t{\nbadchipid:\n\t\t\tinc_hw_errors_only(dev->thr[0]);\n\t\t\tapplogr(NULL, LOG_ERR, \"%s: Chip number %d out of range\", dev->dev_repr, chipid);\n\t\t}\n\t}\n\tif (unlikely(!chipid))\n\t\tgoto badchipid;\n\treturn proc;\n}\n\nstatic\nvoid aan_spi_parse_rx(struct spi_port * const spi)\n{\n\tspi_clear_buf(spi);\n}\n\n#define MAX_POLL_NUM   20\n\n/* set work for given chip, returns true if a nonce range was finished */\nstatic\nbool set_work(struct cgpu_info * const dev, const uint8_t chip_id, struct work * const work)\n{\n\tstruct aan_board_data * const board = dev->device_data;\n\tstruct spi_port * const spi = board->spi;\n\t\n\tstruct cgpu_info * const proc = aan_proc_for_chipid(dev, chip_id);\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\tbool retval = false;\n\t\n\t++chip->last_jobid;\n\tchip->last_jobid &= 3;\n\n\tif (chip->works[chip->last_jobid] != NULL)\n\t{\n\t\tfree_work(chip->works[chip->last_jobid]);\n\t\tchip->works[chip->last_jobid] = NULL;\n\t\tretval = true;\n\t}\n\t\n\tif (!aan_spi_send_work(spi, chip_id, chip->last_jobid + 1, work))\n\t{\n\t\tfree_work(work);\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to set work %d\", proc->proc_repr, chip->last_jobid + 1);\n\t}\n\telse\n\t\tchip->works[chip->last_jobid] = work;\n\tspi_clear_buf(spi);\n\t\n\treturn retval;\n}\n\n/* check for pending results in a chain, returns false if output queue empty */\nstatic\nbool get_nonce(struct cgpu_info * const dev, uint8_t * const nonce, uint8_t * const chip, uint8_t * const job_id)\n{\n\tstruct aan_board_data * const board = dev->device_data;\n\tstruct spi_port * const spi = board->spi;\n\t\n\tint pollLen = MAX_POLL_NUM * dev->procs;\n\tif (pollLen <= 0)\n\t\tpollLen = MAX_POLL_NUM;\n\t\n\tif (!aan_spi_cmd_send(spi, AAN_READ_RESULT, AAN_ALL_CHIPS, NULL, 0))\n\t\treturn false;\n\t\n\tfor (int i = 0; i < pollLen; ++i)\n\t{\n\t\tspi_clear_buf(spi);\n\t\tspi_emit_nop(spi, 2);\n\t\tif (!spi_txrx(spi))\n\t\t\tapplogr(false, LOG_ERR, \"%s: SPI error in get_nonce\", dev->dev_repr);\n\t\tuint8_t * const spi_rx = spi_getrxbuf(spi);\n\t\tif (spi_rx[0] == AAN_READ_RESULT && spi_rx[1] == 0x00)\n\t\t\tapplogr(false, LOG_DEBUG, \"%s: Output queue empty\", dev->dev_repr);\n\t\tif ((spi_rx[0] & 0x0f) == AAN_READ_RESULT && spi_rx[1] != 0)\n\t\t{\n\t\t\t*job_id = spi_rx[0] >> 4;\n\t\t\t*chip = spi_rx[1];\n\t\t\t\n\t\t\tspi_emit_nop(spi, 2);\n\t\t\tif (!spi_txrx(spi))\n\t\t\t\tapplogr(false, LOG_ERR, \"SPI Err(%s):get_nonce\", dev->dev_repr);\n\t\t\tmemcpy(nonce, spi_rx, 4);\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"%s: Got nonce for chip %d / job_id %d\", dev->dev_repr, *chip, *job_id);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nstatic\nvoid aan_scanwork(struct cgpu_info * const dev, struct thr_info * const master_thr)\n{\n\tstruct aan_board_data * const board = dev->device_data;\n\tstruct spi_port * const spi = board->spi;\n\t\n\tuint32_t nonce;\n\tuint8_t chip_id;\n\tuint8_t job_id;\n\tbool work_updated = false;\n\t\n\tif (!timer_passed(&board->tv_next_poll, NULL))\n\t\tgoto out;\n\t\n\twhile (get_nonce(dev, (uint8_t*)&nonce, &chip_id, &job_id))\n\t{\n\t\tnonce = bswap_32(nonce);\n\t\twork_updated = true;\n\t\tstruct cgpu_info * const proc = aan_proc_for_chipid(dev, chip_id);\n\t\tif (!proc)\n\t\t\tcontinue;\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\t\tif (job_id < 1 || job_id > 4)\n\t\t{\nbadjob:\n\t\t\tinc_hw_errors3(thr, NULL, &nonce, chip->current_nonce_pdiff);\n\t\t\tcontinue;\n\t\t}\n\t\tstruct work * const work = chip->works[job_id - 1];\n\t\tif (!work)\n\t\t\tgoto badjob;\n\t\tsubmit_nonce(thr, work, nonce);\n\t}\n\t\n\t/* check for completed works */\n\tfor_each_logical_proc(proc, dev)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\t\tconst int i = proc->proc_id;\n\t\tuint8_t reg[AAN_REGISTER_SIZE];\n\t\t\n\t\tif (!aan_read_reg(spi, i + 1, reg, NULL))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to read reg\", proc->proc_repr);\n\t\t\tcontinue;\n\t\t}\n\t\tconst uint16_t pllreg = upk_u16be(reg, 0);\n\t\tchip->current_pllreg = pllreg;\n\t\tif (pllreg != chip->desired_pllreg)\n\t\t{\n\t\t\t// Wait for chip to idle before changing register\n\t\t\tif (!(reg[3] & 3))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Asserting PLL change: %04x->%04x\", proc->proc_repr, pllreg, chip->desired_pllreg);\n\t\t\t\tuint8_t regset[AAN_REGISTER_SIZE];\n\t\t\t\tmemcpy(&regset[2], &reg[2], AAN_REGISTER_SIZE - 2);\n\t\t\t\tpk_u16be(regset, 0, chip->desired_pllreg);\n\t\t\t\taan_spi_cmd_send(spi, AAN_WRITE_REG, chip->chipid, regset, AAN_REGISTER_SIZE);\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif ((reg[3] & 2) != 2)\n\t\t{\n\t\t\tstruct cgpu_info * const master_dev = board->master_dev;\n\t\t\tstruct aan_board_data * const master_board = master_dev->device_data;\n\t\t\t\n\t\t\twork_updated = true;\n\t\t\tthr->queue_full = false;\n\t\t\t++master_board->queues_empty;\n\t\t\tapplog(LOG_DEBUG, \"%s: queue_full=false queues_empty=%d\", proc->proc_repr, master_board->queues_empty);\n\t\t}\n\t}\n\t\n\tif (!work_updated)\n\t\ttimer_set_delay_from_now(&board->tv_next_poll, AAN_READ_INTERVAL_US);\n\nout:\n\treduce_timeout_to(&master_thr->tv_poll, &board->tv_next_poll);\n}\n\nvoid aan_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const master_dev = master_thr->cgpu, *dev = NULL;\n\tstruct aan_board_data * const master_board = master_dev->device_data;\n\t\n\ttimer_unset(&master_thr->tv_poll);\n\t\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tif (dev == proc->device)\n\t\t\tcontinue;\n\t\tdev = proc->device;\n\t\t\n\t\taan_scanwork(dev, master_thr);\n\t}\n\t\n\tif (master_board->queues_empty)\n\t\t// Avoid polling when we have queues to fill\n\t\ttimer_unset(&master_thr->tv_poll);\n}\n\nconst char *aan_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\t\n\tif (newvalue[0] == 'x')\n\t{\n\t\tchar *p;\n\t\tchip->desired_pllreg = strtol(&newvalue[1], &p, 0x10);\n\t\tif (p != &newvalue[5])\n\t\t\treturn \"Invalid hex PLL data\";\n\t}\n\telse\n\t{\n\t\tconst int nv = atoi(newvalue);\n\t\tif (nv <= 0 || nv > AAN_MAX_FREQ)\n\t\t\treturn \"Invalid clock frequency\";\n\t\tchip->desired_pllreg = aan_freq2pll(nv);\n\t}\n\t\n\treturn NULL;\n}\n\nconst char *aan_set_diff(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\t\n\tconst double nv = atof(newvalue);\n\tif (nv <= 0)\n\t\treturn \"Invalid difficulty\";\n\t\n\tchip->desired_nonce_pdiff = nv;\n\t\n\treturn NULL;\n}\n\nstruct api_data *aan_api_device_status(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\t\n\tdouble mhz = aan_pll2freq(chip->current_pllreg);\n\troot = api_add_freq(root, \"Frequency\", &mhz, true);\n\t\n\treturn root;\n}\n\nconst struct bfg_set_device_definition aan_set_device_funcs[] = {\n\t{\"clock\", aan_set_clock, \"clock frequency (MHz)\"},\n\t{\"diff\", aan_set_diff, \"desired nonce difficulty\"},\n\t{NULL},\n};\n\n#ifdef HAVE_CURSES\nvoid aan_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\t\n\tconst double mhz = aan_pll2freq(chip->current_pllreg);\n\twlogprint(\"Clock speed: %lu\\n\", (unsigned long)mhz);\n}\n\nvoid aan_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nconst char *aan_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tchar prompt[0x80];\n\t\t\tsnprintf(prompt, sizeof(prompt), \"Set clock speed (%u-%lu)\", 1, (unsigned long)AAN_MAX_FREQ);\n\t\t\treturn proc_set_device_tui_wrapper(proc, NULL, aan_set_clock, prompt, NULL);\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n"
        },
        {
          "name": "driver-aan.h",
          "type": "blob",
          "size": 1.6357421875,
          "content": "#ifndef BFG_DRIVER_AAN\n#define BFG_DRIVER_AAN\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n\n#define AAN_ALL_CHIPS  0\n#define AAN_MAX_JOBID  4\n\nstruct aan_hooks {\n\tvoid (*precmd)(struct spi_port *);\n\tbool (*read_reg)(struct spi_port *, uint8_t chip, void *out_buf, const struct timeval *tvp_timeout);\n};\n\nstruct aan_board_data {\n\tstruct spi_port *spi;\n\tstruct timeval tv_next_poll;\n\tstruct cgpu_info *master_dev;\n\t\n\t// Master board only\n\tint queues_empty;\n};\n\nstruct aan_chip_data {\n\tuint8_t chipid;\n\tint8_t last_jobid;\n\tstruct work *works[AAN_MAX_JOBID];\n\tfloat desired_nonce_pdiff;\n\tfloat current_nonce_pdiff;\n\tuint16_t desired_pllreg;\n\tuint16_t current_pllreg;\n};\n\nextern int aan_detect_spi(int *out_chipcount, struct spi_port * const *spi_a, int spi_n);\nextern bool aan_read_reg_direct(struct spi_port *, uint8_t chip, void *out_buf, const struct timeval *tvp_timeout);\nextern bool aan_init(struct thr_info *);\nextern bool aan_queue_append(struct thr_info *, struct work *);\nextern void aan_queue_flush(struct thr_info *);\nextern struct cgpu_info *aan_proc_for_chipid(struct cgpu_info *, int chipid);\nextern void aan_poll(struct thr_info *);\n\nextern const char *aan_set_diff(struct cgpu_info *, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *);\nextern const struct bfg_set_device_definition aan_set_device_funcs[];\n\nextern struct api_data *aan_api_device_status(struct cgpu_info *);\n\nextern void aan_wlogprint_status(struct cgpu_info *proc);\nextern void aan_tui_wlogprint_choices(struct cgpu_info *proc);\nextern const char *aan_tui_handle_choice(struct cgpu_info *proc, int input);\n\n#endif\n"
        },
        {
          "name": "driver-alchemist.c",
          "type": "blob",
          "size": 16.794921875,
          "content": "/*\n * Copyright 2015-2016 John Stefanopoulos\n * Copyright 2014-2015 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n// THIS DRIVER REQUIRES THE LATEST FIRMWARE FOR AlCHEMINERS DEVELOPED BY JSTEFANOP\n// IT WILL NOT WORK WITH THE STOCK FACTORY FIRMWARE ON THE BOARDS\n// PLEASE CONTACT JSTEFANOP AT MAC DOT COM OR JSTEFANOP ON LITECOINTALK DOT ORG FOR MORE INFO\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\nstatic const uint8_t alchemist_max_chips = 0x20;\n#define ALCHEMIST_DEFAULT_FREQUENCY  352\n#define ALCHEMIST_MIN_CLOCK          200\n#define ALCHEMIST_MAX_CLOCK          400\n// Number of seconds full board of 1728 cores @ 352mhz takes to scan full range\n#define ALCHEMIST_HASH_SPEED         134.0\n#define ALCHEMIST_MAX_NONCE          0xffffffff\n#define ALCHEMIST_READ_SIZE            9\n#define alchemist_max_clusters_per_chip  6\n#define alchemist_max_cores_per_cluster  9\nstatic const uint8_t alchemist_g_head[] = {\n\t0xd4, 0x59, 0x2d, 0x01, 0x1d, 0x01, 0x8e, 0xa7, 0x4e, 0xbb, 0x17, 0xb8, 0x06, 0x6b, 0x2a, 0x75,\n\t0x83, 0x99, 0xd5, 0xf1, 0x9b, 0x5c, 0x60, 0x73, 0xd0, 0x9b, 0x50, 0x0d, 0x92, 0x59, 0x82, 0xad,\n\t0xc4, 0xb3, 0xed, 0xd3, 0x52, 0xef, 0xe1, 0x46, 0x67, 0xa8, 0xca, 0x9f, 0x27, 0x9f, 0x63, 0x30,\n\t0xcc, 0xbb, 0xb9, 0x10, 0x3b, 0x9e, 0x3a, 0x53, 0x50, 0x76, 0x50, 0x52, 0x08, 0x1d, 0xdb, 0xae,\n\t0x89, 0x8f, 0x1e, 0xf6, 0xb8, 0xc6, 0x4f, 0x3b, 0xce, 0xf7, 0x15, 0xf6,    0,    0,    0,    1,\n\t   0,    0,    0,    1, 0x8e, 0xa7,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n\t   0,    0,    0,    0,    0,    0,    0\n};\n\nBFG_REGISTER_DRIVER(alchemist_drv)\n\nstatic const struct bfg_set_device_definition alchemist_set_device_funcs_probe[];\n\nstruct alchemist_chip {\n\tuint8_t chipid;\n\tuint8_t global_reg[8];\n\tuint16_t chip_mask[alchemist_max_clusters_per_chip];\n\tuint32_t clst_offset[alchemist_max_clusters_per_chip];\n\tunsigned active_cores;\n\tunsigned freq;\n\tunsigned reset_mode;\n};\n\nstatic\nvoid alchemist_chip_init(struct alchemist_chip * const chip, const uint8_t chipid)\n{\n\t*chip = (struct alchemist_chip){\n\t\t.chipid = chipid,\n\t\t.global_reg = {0, 4, 0x40, 0, 0, 0, 0, 1},\n\t\t.chip_mask = {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t.clst_offset = {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\n\t\t.active_cores = 1728,\n\t\t.freq = ALCHEMIST_DEFAULT_FREQUENCY,\n\t\t.reset_mode = 0,\n\t};\n}\n\nstatic\nvoid alchemist_reset_board(const char * const devpath, struct alchemist_chip * const chip, const int fd)\n{\n\tif (chip->reset_mode == 0) {\n\t\tchar gpio[8];\n\t\tint fd;\n\t\tchar buf[50];\n\t\t\n\t\t// TODO: allow custom reset pin through --set for non-stock controller\n\t\tif (strcmp(devpath, \"/dev/ttyO1\") == 0)\n\t\t\tstrcpy(gpio, \"gpio117\");\n\t\telse if (strcmp(devpath, \"/dev/ttyO2\") == 0)\n\t\t\tstrcpy(gpio, \"gpio110\");\n\t\telse if (strcmp(devpath, \"/dev/ttyO3\") == 0)\n\t\t\tstrcpy(gpio, \"gpio111\");\n\t\telse if (strcmp(devpath, \"/dev/ttyO4\") == 0)\n\t\t\tstrcpy(gpio, \"gpio112\");\n\t\telse if (strcmp(devpath, \"/dev/ttyUSB0\") == 0)\n\t\t\tstrcpy(gpio, \"gpio113\");\n\t\telse if (strcmp(devpath, \"/dev/ttyUSB1\") == 0)\n\t\t\tstrcpy(gpio, \"gpio114\");\n\t\telse if (strcmp(devpath, \"/dev/ttyUSB2\") == 0)\n\t\t\tstrcpy(gpio, \"gpio115\");\n\t\telse if (strcmp(devpath, \"/dev/ttyUSB3\") == 0)\n\t\t\tstrcpy(gpio, \"gpio116\");\n\t\telse if (strcmp(devpath, \"/dev/ttyAMA0\") == 0)\n\t\t\tstrcpy(gpio, \"gpio25\");\n\t\telse\n\t\t\treturn;\n\t\t\n\t\tsprintf(buf, \"/sys/class/gpio/%s/value\", gpio);\n\t\t\n\t\tfd = open(buf, O_WRONLY);\n\t\t\n\t\tif (write(fd, \"0\", 1) != 1)\n\t\t\tapplog(LOG_DEBUG, \"%s: %s %s\", alchemist_drv.dname, \"GPIO write error\", devpath);\n\t\tcgsleep_ms(100);\n\t\tif (write(fd, \"1\", 1) != 1)\n\t\t\tapplog(LOG_DEBUG, \"%s: %s %s\", alchemist_drv.dname, \"GPIO write error\", devpath);\n\t\t\n\t\tclose(fd);\n\t} else {\n\t\tapplog(LOG_DEBUG, \"START IOCTL RTS RESET\");\n\t\t\n\t\tif (set_serial_rts(fd, BGV_HIGH) == BGV_ERROR) {\n\t\t\tapplog(LOG_DEBUG, \"IOCTL RTS RESET FAILED\");\n\t\t}\n\t\t\n\t\tif (set_serial_dtr(fd, BGV_HIGH) == BGV_ERROR) {\n\t\t\tapplog(LOG_DEBUG, \"IOCTL DTR RESET FAILED\");\n\t\t}\n\t\t\n\t\tcgsleep_ms(100);\n\t\t\n\t\tif (set_serial_rts(fd, BGV_LOW) == BGV_ERROR) {\n\t\t\tapplog(LOG_DEBUG, \"IOCTL RTS RESET FAILED\");\n\t\t}\n\t\t\n\t\tif (set_serial_dtr(fd, BGV_LOW) == BGV_ERROR) {\n\t\t\tapplog(LOG_DEBUG, \"IOCTL DTR RESET FAILED\");\n\t\t}\n\t}\n}\n\nstatic\nvoid alchemist_set_diag_mode(struct alchemist_chip * const chip, bool diag_enable)\n{\n\tif (diag_enable)\n\t\tchip->global_reg[1] |= 1;\n\telse\n\t\tchip->global_reg[1] &= ~1;\n}\n\nstatic\nbool alchemist_write_global_reg(const int fd, const struct alchemist_chip * const chip)\n{\n\tuint8_t buf[113];\n\tmemset(&buf, 0, 102);\n\tmemcpy(&buf[102], &chip->global_reg[0], 8);\n\tbuf[110] = 0;\n\tbuf[111] = 0xff;\n\tbuf[112] = chip->chipid;\n\t\n\t//char output[(sizeof(chip->global_reg) * 2) + 1];\n\t//bin2hex(output, chip->global_reg, sizeof(chip->global_reg));\n\t//applog(LOG_DEBUG, \"GLOBAL REG %s\", output);\n\t\n\tif (write(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn false;\n\treturn true;\n}\n\nstatic\nbool alchemist_write_cluster_reg(const int fd, const struct alchemist_chip * const chip, const uint16_t cores_active, const uint32_t offset, const uint8_t clstid)\n{\n\tuint8_t buf[113];\n\tmemset(&buf, 0, 104);\n\tpk_u16be(buf, 104, cores_active);\n\tpk_u32be(buf, 106, offset);\n\tbuf[110] = clstid;\n\tbuf[111] = 0xfe;\n\tbuf[112] = chip->chipid;\n\t//applog(LOG_DEBUG, \" %u: %u: %u : %u\", buf[106], buf[107], buf[108], buf[109]);\n\tif (write(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn false;\n\treturn true;\n}\n\n\nstatic\nbool alchemist_init_pll(const int fd, struct alchemist_chip * const chip)\n{\n\tunsigned freq = chip->freq;\n\tuint8_t divider = (freq - 16)/16;\n\t\n\tdivider <<= 1;\n\t\n\tuint8_t bytes1 = 0x60 | ((divider & 0xf0) >> 4);\n\tuint8_t bytes2 = 0x20 | ((divider & 0xf0) >> 4);\n\tuint8_t bytes3 = 0x00 | ((divider & 0x0f) << 4);\n\t\n\tpk_u16be(chip->global_reg, 2, 0x4000);\n\tchip->global_reg[1] |= 0xc;\n\tif (!alchemist_write_global_reg(fd, chip))\n\t\treturn false;\n\t\n\tchip->global_reg[2] = bytes1;\n\tchip->global_reg[3] = bytes3;\n\tcgsleep_ms(20);\n\tif (!alchemist_write_global_reg(fd, chip))\n\t\treturn false;\n\t\n\tchip->global_reg[2] = bytes2;\n\tchip->global_reg[1] &= ~8;\n\tcgsleep_ms(20);\n\tif (!alchemist_write_global_reg(fd, chip))\n\t\treturn false;\n\t\n\tchip->global_reg[1] &= ~4;\n\tcgsleep_ms(20);\n\tif (!alchemist_write_global_reg(fd, chip))\n\t\treturn false;\n\t\n\treturn true;\n}\n\nstatic\nbool alchemist_send_golden(const int fd, const struct alchemist_chip * const chip, const bool diag, const void * const data, const void * const target_p)\n{\n\tuint8_t buf[113];\n\tconst uint8_t * const target = target_p;\n\t\n\tmemcpy(buf, data, 80);\n\tif (target && !target[0x1f])\n\t\tmemcpy(&buf[80], target, 0x20);\n\telse\n\t{\n\t\tmemset(&buf[80], 0xff, 0x1f);\n\t\tbuf[111] = 0;\n\t}\n\tbuf[112] = chip->chipid;\n\tif (diag)\n\t\tbuf[112] |= 0x80;\n\tif (write(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn false;\n\treturn true;\n}\n\nstatic\nbool alchemist_send_work(const struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tuint8_t buf[113];\n\tuint8_t cmd[113];\n\tconst uint8_t * const target = work->target;\n\t\n\tunsigned char swpdata[80];\n\t\n\tbuf[0] = 0xff;\n\t\n\tmemset(&buf[1], 0, 0x18);\n\tmemcpy(&buf[25], &target[24], 0x8);\n\t//pk_u64be(buf, 25, 0x0000feff01000000);\n\t\n\tswap32tobe(swpdata, work->data, 80/4);\n\tmemcpy(&buf[33], swpdata, 80);\n\t\n\tfor (int i = 0; i<113; i++) {\n\t\tcmd[i] = buf[112 - i];\n\t}\n\t\n\t//char output[(sizeof(cmd) * 2) + 1];\n\t//bin2hex(output, cmd, sizeof(cmd));\n\t//applog(LOG_DEBUG, \"OUTPUT %s\", output);\n\t\n\tif (write(device->device_fd, cmd, sizeof(cmd)) != sizeof(cmd))\n\t\treturn false;\n\t\n\twork->blk.nonce = ALCHEMIST_MAX_NONCE;\n\t\n\treturn true;\n}\n\nstatic\nbool alchemist_detect_one(const char * const devpath)\n{\n\tstruct alchemist_chip *chips = NULL;\n\tconst int fd = serial_open(devpath, 115200, 1, true);\n\tif (fd < 0)\n\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: %s %s\", alchemist_drv.dname, \"Failed to open\", devpath);\n\t\n\tapplog(LOG_DEBUG, \"%s: %s %s\", alchemist_drv.dname, \"Successfully opened\", devpath);\n\t\n\t\n\t// Init chips, setup PLL, and scan for good cores\n\tchips = malloc(alchemist_max_chips * sizeof(*chips));\n\t\n\tstruct alchemist_chip * const dummy_chip = &chips[0];\n\talchemist_chip_init(dummy_chip, 0);\n\t\n\t// pick up any user-defined settings passed in via --set\n\tdrv_set_defaults(&alchemist_drv, alchemist_set_device_funcs_probe, dummy_chip, devpath, detectone_meta_info.serial, 1);\n\t\n\tunsigned freq = dummy_chip->freq;\n\tunsigned mode = dummy_chip->reset_mode;\n\t\n\tunsigned total_cores = 0;\n\t\n\talchemist_reset_board(devpath, dummy_chip, fd);\n\t\n\t{\n\t\tuint8_t buf[9];\n\t\tfor (unsigned i = 0; i < alchemist_max_chips; ++i)\n\t\t{\n\t\t\tstruct alchemist_chip * const chip = &chips[i];\n\t\t\talchemist_chip_init(chip, i);\n\t\t\tchip->freq = freq;\n\t\t\tchip->reset_mode = mode;\n\t\t\talchemist_set_diag_mode(chip, true);\n\t\t\tif (!alchemist_init_pll(fd, chip))\n\t\t\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: Failed to (%s) %s\", alchemist_drv.dname, \"init PLL\", devpath);\n\t\t\tif (!alchemist_send_golden(fd, chip, true, alchemist_g_head, NULL))\n\t\t\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: Failed to (%s) %s\", alchemist_drv.dname, \"send scan job\", devpath);\n\t\t\t\n\t\t\twhile (serial_read(fd, buf, 9) == 9)\n\t\t\t{\n\t\t\t\tconst uint8_t chipid = buf[8];\n\t\t\t\tif (chipid >= alchemist_max_chips)\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Bad %s id (%u) during scan of %s chip %u\", alchemist_drv.dname, \"chip\", chipid, devpath, i);\n\t\t\t\tconst uint8_t clsid = buf[7];\n\t\t\t\tif (clsid >= alchemist_max_clusters_per_chip)\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Bad %s id (%u) during scan of %s chip %u\", alchemist_drv.dname, \"cluster\", clsid, devpath, i);\n\t\t\t\tconst uint8_t coreid = buf[6];\n\t\t\t\tif (coreid >= alchemist_max_cores_per_cluster)\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Bad %s id (%u) during scan of %s chip %u\", alchemist_drv.dname, \"core\", coreid, devpath, i);\n\t\t\t\t\n\t\t\t\tif (buf[0] != 0xd9 || buf[1] != 0xeb || buf[2] != 0x86 || buf[3] != 0x63) {\n\t\t\t\t\t//chips[i].chip_good[clsid][coreid] = false;\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Bad %s at core (%u) during scan of %s chip %u cluster %u\", alchemist_drv.dname, \"nonce\", coreid, devpath, i, clsid);\n\t\t\t\t} else {\n\t\t\t\t\t++total_cores;\n\t\t\t\t\tchips[i].chip_mask[clsid] |= (1 << coreid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%s: Identified %d cores on %s\", alchemist_drv.dname, total_cores, devpath);\n\tif (!total_cores)\n\t\tgoto err;\n\t\n\talchemist_reset_board(devpath, dummy_chip, fd);\n\t\n\t// config nonce ranges per cluster based on core responses\n\tunsigned mutiple = ALCHEMIST_MAX_NONCE / total_cores;\n\tuint32_t n_offset = 0x00000000;\n\t\n\tfor (unsigned i = 0; i < alchemist_max_chips; ++i)\n\t{\n\t\tstruct alchemist_chip * const chip = &chips[i];\n\t\t\n\t\tchips[i].active_cores = total_cores;\n\t\t\n\t\talchemist_set_diag_mode(chip, false);\n\t\tif (!alchemist_init_pll(fd, chip))\n\t\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: Failed to (%s) %s\", alchemist_drv.dname, \"init PLL\", devpath);\n\t\t\n\t\tcgsleep_ms(10);\n\t\t\n\t\tfor (unsigned x = 0; x < alchemist_max_clusters_per_chip; ++x) {\n\t\t\tunsigned gc = 0;\n\t\t\t\n\t\t\tuint16_t core_mask = chips[i].chip_mask[x];\n\t\t\tchips[i].clst_offset[x] = n_offset;\n\t\t\t\n\t\t\t//applog(LOG_DEBUG, \"OFFSET %u CHIP %u CLUSTER %u\", n_offset, i, x);\n\t\t\t\n\t\t\tif (!alchemist_write_cluster_reg(fd, chip, core_mask, n_offset, x))\n\t\t\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: Failed to (%s) %s\", alchemist_drv.dname, \"send config register\", devpath);\n\t\t\t\n\t\t\tfor (unsigned z = 0; z < 15; ++z) {\n\t\t\t\tif (core_mask & 0x0001)\n\t\t\t\t\tgc += 1;\n\t\t\t\tcore_mask >>= 1;\n\t\t\t}\n\t\t\t\n\t\t\tn_offset += mutiple * gc;\n\t\t}\n\t}\n\t\n\tif (serial_claim_v(devpath, &alchemist_drv))\n\t\tgoto err;\n\t\n\t//serial_close(fd);\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &alchemist_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = 1,\n\t\t.threads = 1,\n\t\t.device_data = chips,\n\t};\n\t// NOTE: Xcode's clang has a bug where it cannot find fields inside anonymous unions (more details in fpgautils)\n\tcgpu->device_fd = fd;\n\t\n\treturn add_cgpu(cgpu);\n\nerr:\n\tif (fd >= 0)\n\t\tserial_close(fd);\n\tfree(chips);\n\treturn false;\n}\n\n/*\n * scanhash mining loop\n */\n\nstatic\nvoid alchemist_submit_nonce(struct thr_info * const thr, const uint8_t buf[9], struct work * const work)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tstruct alchemist_chip *chips = device->device_data;\n\t\n\tuint32_t nonce = *(uint32_t *)buf;\n\tnonce = bswap_32(nonce);\n\t\n\tsubmit_nonce(thr, work, nonce);\n\t\n\t// hashrate calc\n\t\n\tconst uint8_t chipid = buf[8];\n\tconst uint8_t clstid = buf[7];\n\tuint32_t range = chips[chipid].clst_offset[clstid];\n\tuint32_t mutiple = ALCHEMIST_MAX_NONCE / chips[chipid].active_cores;\n\t\n\tdouble diff_mutiple = .5/work->work_difficulty;\n\t\n\tfor (unsigned x = 0; x < alchemist_max_cores_per_cluster; ++x) {\n\t\tif (nonce > range && nonce < (range + mutiple)) {\n\t\t\tuint64_t hashes = (nonce - range) * chips[chipid].active_cores * diff_mutiple;\n\t\t\t\n\t\t\tif (hashes > ALCHEMIST_MAX_NONCE)\n\t\t\t\thashes = 1;\n\t\t\t\n\t\t\thashes_done2(thr, hashes, NULL);\n\t\t}\n\t\t\n\t\trange += mutiple;\n\t}\n}\n\n// send work to the device\nstatic\nint64_t alchemist_scanhash(struct thr_info *thr, struct work *work, int64_t __maybe_unused max_nonce)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tint fd = device->device_fd;\n\tstruct alchemist_chip *chips = device->device_data;\n\tstruct timeval start_tv, nonce_range_tv;\n\t\n\t// amount of time it takes this device to scan a nonce range:\n\tuint32_t nonce_full_range_sec = ALCHEMIST_HASH_SPEED * 352.0 / ALCHEMIST_DEFAULT_FREQUENCY * 1728.0 / chips[0].active_cores;\n\t// timer to break out of scanning should we close in on an entire nonce range\n\t// should break out before the range is scanned, so we are doing 95% of the range\n\tuint64_t nonce_near_range_usec = (nonce_full_range_sec * 1000000. * 0.95);\n\ttimer_set_delay_from_now(&nonce_range_tv, nonce_near_range_usec);\n\t\n\t// start the job\n\ttimer_set_now(&start_tv);\n\t\n\tif (!alchemist_send_work(thr, work)) {\n\t\tapplog(LOG_DEBUG, \"Failed to start job\");\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t}\n\t\n\tuint8_t buf[9];\n\tint read = 0;\n\tbool range_nearly_scanned = false;\n\t\n\twhile (!thr->work_restart                                              // true when new work is available (miner.c)\n\t    && ((read = serial_read(fd, buf, 9)) >= 0)                         // only check for failure - allow 0 bytes\n\t    && !(range_nearly_scanned = timer_passed(&nonce_range_tv, NULL)))  // true when we've nearly scanned a nonce range\n\t{\n\t\tif (read == 0)\n\t\t\tcontinue;\n\t\t\n\t\tif (read == 9) {\n\t\t\talchemist_submit_nonce(thr, buf, work);\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Unrecognized response\", device->proc_repr);\n\t}\n\t\n\tif (read == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to read result\", device->dev_repr);\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t}\n\t\n\treturn 0;\n}\n\n/*\n * setup & shutdown\n */\n\nstatic\nbool alchemist_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, alchemist_detect_one);\n}\n\nstatic\nvoid alchemist_thread_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tstruct alchemist_chip *chips = device->device_data;\n\t\n\talchemist_reset_board(device->device_path, &chips[0], device->device_fd);\n\t\n\tserial_close(device->device_fd);\n}\n\n/*\n * specify settings / options via RPC or command line\n */\n\n// support for --set\n// must be set before probing the device\n\n// for setting clock and chips during probe / detect\n\nstatic\nconst char *alchemist_set_clock(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct alchemist_chip * const chip = device->device_data;\n\tint val = atoi(setting);\n\t\n\tif (val < ALCHEMIST_MIN_CLOCK || val > ALCHEMIST_MAX_CLOCK || (val%16)) {\n\t\tsprintf(replybuf, \"invalid clock: '%s' valid range %d-%d and a mutiple of 16\",\n\t\t        setting, ALCHEMIST_MIN_CLOCK, ALCHEMIST_MAX_CLOCK);\n\t\treturn replybuf;\n\t} else\n\t\tchip->freq = val;\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *alchemist_set_mode(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct alchemist_chip * const chip = device->device_data;\n\tint val = atoi(setting);\n\t\n\tif (val == 1) {\n\t\tchip->reset_mode = val;\n\t\tsprintf(replybuf, \"Driver mode set to raspery pi controller using USB->UART Dongles\");\n\t\treturn replybuf;\n\t}\n\t\n\treturn NULL;\n}\n\nstatic\nconst struct bfg_set_device_definition alchemist_set_device_funcs_probe[] = {\n\t{ \"clock\", alchemist_set_clock, NULL },\n\t{ \"mode\", alchemist_set_mode, NULL },\n\t{ NULL },\n};\n\nstruct device_drv alchemist_drv = {\n\t.dname = \"alchemist\",\n\t.name = \"ALC\",\n\t.drv_min_nonce_diff = common_scrypt_min_nonce_diff,\n\t// detect device\n\t.lowl_probe = alchemist_lowl_probe,\n\t// specify mining type - scanhash\n\t.minerloop = minerloop_scanhash,\n\t\n\t// scanhash mining hooks\n\t.scanhash = alchemist_scanhash,\n\t\n\t// teardown device\n\t.thread_shutdown = alchemist_thread_shutdown,\n};\n"
        },
        {
          "name": "driver-antminer.c",
          "type": "blob",
          "size": 10.2099609375,
          "content": "/*\n * Copyright 2013-2015 Luke Dashjr\n * Copyright 2013-2014 Nate Woolls\n * Copyright 2013 Lingchao Xu\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#include \"miner.h\"\n#include \"driver-icarus.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"util.h\"\n\n#define ANTMINER_IO_SPEED 115200\n// ANTMINER_HASH_TIME is for U1/U2 only\n#define ANTMINER_HASH_TIME 0.0000000004761\n\n#define ANTMINER_STATUS_LEN 5\n\n#define ANTMINER_COMMAND_PREFIX 128\n#define ANTMINER_COMMAND_LED 1\n#define ANTMINER_COMMAND_ON 1\n#define ANTMINER_COMMAND_OFFSET 32\n\nBFG_REGISTER_DRIVER(antminer_drv)\nBFG_REGISTER_DRIVER(compac_drv)\nstatic\nconst struct bfg_set_device_definition antminer_set_device_funcs[];\n\nstatic const char *bm1382_chips[] = {\n\t\"BM1382\",\n\t\"BM1384\",\n\tNULL\n};\n\nstatic bool antminer_chip_has_bm1382_freq_register(const char * const prodstr)\n{\n\tif (!prodstr)\n\t\treturn false;\n\tfor (const char **chipname = bm1382_chips; *chipname; ++chipname) {\n\t\tif (strstr(prodstr, *chipname)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic\nbool antminer_detect_one_with_drv(const char * const devpath, struct device_drv * const drv)\n{\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\t\n\t*info = (struct ICARUS_INFO){\n\t\t.baud = ANTMINER_IO_SPEED,\n\t\t.Hs = ANTMINER_HASH_TIME,\n\t\t.timing_mode = MODE_LONG,\n\t\t.do_icarus_timing = true,\n\t\t.read_size = 5,\n\t\t.reopen_mode = IRM_NEVER,\n\t\t\n\t\t.has_bm1382_freq_register = antminer_chip_has_bm1382_freq_register(detectone_meta_info.product),\n\t};\n\t\n\tstruct cgpu_info * const dev = icarus_detect_custom(devpath, drv, info);\n\tif (!dev)\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\t\n\tdev->set_device_funcs = antminer_set_device_funcs;\n\tinfo->read_timeout_ms = 75;\n\t\n\treturn true;\n}\n\nstatic bool antminer_detect_one(const char * const devpath)\n{\n\treturn antminer_detect_one_with_drv(devpath, &antminer_drv);\n}\n\nstatic\nbool antminer_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_vcom, \"Antminer\");\n}\n\nstatic\nbool antminer_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, antminer_detect_one);\n}\n\n// Not used for anything, and needs to read a result for every chip\n#if 0\nstatic\nchar *antminer_get_clock(struct cgpu_info *cgpu, char *replybuf)\n{\n\tuint8_t rdreg_buf[4] = {0};\n\tunsigned char rebuf[ANTMINER_STATUS_LEN] = {0};\n\t\n\tstruct timeval tv_now;\n\tstruct timeval tv_timeout, tv_finish;\n\t\n\trdreg_buf[0] = 4;\n\trdreg_buf[0] |= 0x80;\n\trdreg_buf[1] = 0;    //16-23\n\trdreg_buf[2] = 0x04; // 8-15\n\trdreg_buf[3] = crc5usb(rdreg_buf, 27);\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Get clock: %02x%02x%02x%02x\", cgpu->proc_repr, rdreg_buf[0], rdreg_buf[1], rdreg_buf[2], rdreg_buf[3]);\n\t\n\ttimer_set_now(&tv_now);\n\tint err = icarus_write(cgpu->proc_repr, cgpu->device_fd, rdreg_buf, sizeof(rdreg_buf));\n\t\n\tif (err != 0)\n\t{\n\t\tsprintf(replybuf, \"invalid send get clock: comms error (err=%d)\", err);\n\t\treturn replybuf;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Get clock: OK\", cgpu->proc_repr);\n\t\n\tmemset(rebuf, 0, sizeof(rebuf));\n\ttimer_set_delay(&tv_timeout, &tv_now, 1000000);\n\terr = icarus_read(cgpu->proc_repr, rebuf, cgpu->device_fd, &tv_finish, NULL, &tv_timeout, &tv_now, ANTMINER_STATUS_LEN);\n\t\n\t// Timeout is ok - checking specifically for an error here\n\tif (err == ICA_GETS_ERROR)\n\t{\n\t\tsprintf(replybuf, \"invalid recv get clock: comms error (err=%d)\", err);\n\t\treturn replybuf;\n\t}\n\t\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Get clock: %02x%02x%02x%02x%02x\", cgpu->proc_repr, rebuf[0], rebuf[1], rebuf[2], rebuf[3], rebuf[4]);\n\t\n\treturn NULL;\n}\n#endif\n\nstatic\nconst char *antminer_set_clock(struct cgpu_info * const cgpu, const char * const optname, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = cgpu->device_data;\n\t\n\tif (!setting || !*setting)\n\t\treturn \"missing clock setting\";\n\t\n\tuint8_t reg_data[2];\n\t\n\tif (setting[0] == 'x')\n\t{\n\t\t// remove leading character\n\t\tconst char * const hex_setting = &setting[1];\n\t\t\n\t\tif (!hex2bin(reg_data, hex_setting, sizeof(reg_data)))\n\t\t{\n\t\t\tsprintf(replybuf, \"invalid clock: '%s' data must be a hexadecimal value\", hex_setting);\n\t\t\treturn replybuf;\n\t\t}\n\t}\n\telse\n\tif (info->has_bm1382_freq_register)\n\t{\n\t\tconst double mhz = atof(setting);\n\t\tif (!bm1382_freq_to_reg_data(reg_data, mhz)) {\n\t\t\treturn \"invalid clock\";\n\t\t}\n\t}\n\telse\n\t{\n\t\tsprintf(replybuf, \"invalid clock: '%s' data must be prefixed with an x\", setting);\n\t\treturn replybuf;\n\t}\n\t\n\tuint8_t cmd_buf[4] = {0};\n\t\n\tcmd_buf[0] = 2;\n\tcmd_buf[0] |= 0x80;\n\tcmd_buf[1] = reg_data[0]; //16-23\n\tcmd_buf[2] = reg_data[1]; // 8-15\n\tcmd_buf[3] = crc5usb(cmd_buf, 27);\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Set clock: %02x%02x%02x%02x\", cgpu->proc_repr, cmd_buf[0], cmd_buf[1], cmd_buf[2], cmd_buf[3]);\n\t\n\tint err = icarus_write(cgpu->proc_repr, cgpu->device_fd, cmd_buf, sizeof(cmd_buf));\n\t\t\n\tif (err != 0)\n\t{\n\t\tsprintf(replybuf, \"invalid send clock: '%s' comms error (err=%d)\", setting, err);\n\t\treturn replybuf;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Set clock: OK\", cgpu->proc_repr);\n\t\n\t// This is confirmed required in order for the clock change to \"take\"\n\tcgsleep_ms(500);\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *antminer_set_voltage(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tif (!(newvalue && *newvalue))\n\t\treturn \"Missing voltage value\";\n\t\n\t// For now we only allow hex values that use BITMAINtech's lookup table\n\t// This means values should be prefixed with an x so that later we can\n\t// accept and distinguish decimal values\n\tif (newvalue[0] != 'x' || strlen(newvalue) != 4)\ninvalid_voltage:\n\t\treturn \"Only raw voltage configurations are currently supported using 'x' followed by 3 hexadecimal digits\";\n\t\n\tchar voltagecfg_hex[5];\n\tvoltagecfg_hex[0] = '0';\n\tmemcpy(&voltagecfg_hex[1], &newvalue[1], 3);\n\tvoltagecfg_hex[4] = '\\0';\n\t\n\tuint8_t cmd[4];\n\tif (!hex2bin(&cmd[1], voltagecfg_hex, 2))\n\t\tgoto invalid_voltage;\n\tcmd[0] = 0xaa;\n\tcmd[1] |= 0xb0;\n\tcmd[3] = 0;\n\tcmd[3] = crc5usb(cmd, (4 * 8) - 5);\n\tcmd[3] |= 0xc0;\n\t\n\tif (opt_debug)\n\t{\n\t\tchar hex[(4 * 2) + 1];\n\t\tbin2hex(hex, cmd, 4);\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Set voltage: %s\", proc->proc_repr, hex);\n\t}\n\t\n\tconst int err = icarus_write(proc->proc_repr, proc->device_fd, cmd, sizeof(cmd));\n\t\n\tif (err)\n\t{\n\t\tsprintf(replybuf, \"Error sending set voltage (err=%d)\", err);\n\t\treturn replybuf;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Set voltage: OK\", proc->proc_repr);\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *antminer_set_chip(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\t\n\tinfo->has_bm1382_freq_register = antminer_chip_has_bm1382_freq_register(newvalue);\n\t\n\treturn NULL;\n}\n\nstatic\nvoid antminer_flash_led(const struct cgpu_info *antminer)\n{\n\tconst int offset = ANTMINER_COMMAND_OFFSET;\n\n\tuint8_t cmd_buf[4 + offset];\n\tmemset(cmd_buf, 0, sizeof(cmd_buf));\n\n\tcmd_buf[offset + 0] = ANTMINER_COMMAND_PREFIX;\n\tcmd_buf[offset + 1] = ANTMINER_COMMAND_LED;\n\tcmd_buf[offset + 2] = ANTMINER_COMMAND_ON;\n\tcmd_buf[offset + 3] = crc5usb(cmd_buf, sizeof(cmd_buf));\n\n\tconst int fd = antminer->device_fd;\n\ticarus_write(antminer->proc_repr, fd, (char *)(&cmd_buf), sizeof(cmd_buf));\n}\n\nstatic\nbool antminer_identify(struct cgpu_info *antminer)\n{\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tantminer_flash_led(antminer);\n\t\tcgsleep_ms(250);\n\t}\n\n\treturn true;\n}\n\nstatic\nconst struct bfg_set_device_definition antminer_set_device_funcs[] = {\n\t{\"chip\", antminer_set_chip, \"chip unit is based on (BM1380, BM1382, etc)\"},\n\t{\"baud\"         , icarus_set_baud         , \"serial baud rate\"},\n\t{\"work_division\", icarus_set_work_division, \"number of pieces work is split into\"},\n\t{\"reopen\"       , icarus_set_reopen       , \"how often to reopen device: never, timeout, cycle, (or now for a one-shot reopen)\"},\n\t{\"timing\"       , icarus_set_timing       , \"timing of device; see README.FPGA\"},\n\t{\"clock\", antminer_set_clock, \"clock frequency\"},\n\t{\"voltage\", antminer_set_voltage, \"voltage ('x' followed by 3 digit hex code)\"},\n\t{NULL},\n};\n\n#ifdef HAVE_CURSES\nstatic\nvoid antminer_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\t\n\tif (info->has_bm1382_freq_register)\n\t\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *antminer_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t\treturn proc_set_device_tui_wrapper(proc, NULL, antminer_set_clock, \"Set clock speed\", NULL);\n\t}\n\treturn NULL;\n}\n#endif\n\nstatic\nbool compac_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_vcom, \"Compac\", \"Bitcoin\");\n}\n\nstatic bool compac_detect_one(const char * const devpath)\n{\n\treturn antminer_detect_one_with_drv(devpath, &compac_drv);\n}\n\nstatic\nbool compac_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, compac_detect_one);\n}\n\nstatic\nvoid antminer_drv_init()\n{\n\tantminer_drv = icarus_drv;\n\tantminer_drv.dname = \"antminer\";\n\tantminer_drv.name = \"AMU\";\n\tantminer_drv.lowl_match = antminer_lowl_match;\n\tantminer_drv.lowl_probe = antminer_lowl_probe;\n\tantminer_drv.identify_device = antminer_identify;\n#ifdef HAVE_CURSES\n\tantminer_drv.proc_tui_wlogprint_choices = antminer_tui_wlogprint_choices;\n\tantminer_drv.proc_tui_handle_choice = antminer_tui_handle_choice;\n#endif\n\t++antminer_drv.probe_priority;\n\t\n\tcompac_drv = antminer_drv;\n\tcompac_drv.dname = \"compac\";\n\tcompac_drv.name = \"CBM\";\n\tcompac_drv.lowl_match = compac_lowl_match;\n\tcompac_drv.lowl_probe = compac_lowl_probe;\n\t++compac_drv.probe_priority;\n}\n\nstruct device_drv antminer_drv = {\n\t.drv_init = antminer_drv_init,\n};\n\nstruct device_drv compac_drv = {\n\t.drv_init = antminer_drv_init,\n};\n"
        },
        {
          "name": "driver-avalon.c",
          "type": "blob",
          "size": 26.63671875,
          "content": "/*\n * Copyright 2012-2013 Xiangfu\n * Copyright 2013 Con Kolivas <kernel@kolivas.org>\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2012-2013 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#ifndef WIN32\n  #include <sys/select.h>\n  #include <termios.h>\n  #include <sys/stat.h>\n  #include <fcntl.h>\n  #ifndef O_CLOEXEC\n    #define O_CLOEXEC 0\n  #endif\n#else\n  #include \"compat.h\"\n  #include <windows.h>\n  #include <io.h>\n#endif\n\n#include \"deviceapi.h\"\n#include \"miner.h\"\n#include \"driver-avalon.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\nBFG_REGISTER_DRIVER(avalon_drv)\n\nstatic int avalon_init_task(struct avalon_task *at,\n\t\t\t    uint8_t reset, uint8_t ff, uint8_t fan,\n\t\t\t    uint8_t timeout, uint8_t asic_num,\n\t\t\t    uint8_t miner_num, uint8_t nonce_elf,\n\t\t\t    uint8_t gate_miner, int frequency)\n{\n\tuint8_t *buf;\n\tstatic bool first = true;\n\n\tif (unlikely(!at))\n\t\treturn -1;\n\n\tif (unlikely(timeout <= 0 || asic_num <= 0 || miner_num <= 0))\n\t\treturn -1;\n\n\tmemset(at, 0, sizeof(struct avalon_task));\n\n\tif (unlikely(reset)) {\n\t\tat->reset = 1;\n\t\tat->fan_eft = 1;\n\t\tat->timer_eft = 1;\n\t\tfirst = true;\n\t}\n\n\tat->flush_fifo = (ff ? 1 : 0);\n\tat->fan_eft = (fan ? 1 : 0);\n\n\tif (unlikely(first && !at->reset)) {\n\t\tat->fan_eft = 1;\n\t\tat->timer_eft = 1;\n\t\tfirst = false;\n\t}\n\n\tat->fan_pwm_data = (fan ? fan : AVALON_DEFAULT_FAN_MAX_PWM);\n\tat->timeout_data = timeout;\n\tat->asic_num = asic_num;\n\tat->miner_num = miner_num;\n\tat->nonce_elf = nonce_elf;\n\n\tat->gate_miner_elf = 1;\n\tat->asic_pll = 1;\n\n\tif (unlikely(gate_miner)) {\n\t\tat-> gate_miner = 1;\n\t\tat->asic_pll = 0;\n\t}\n\n\tbuf = (uint8_t *)at;\n\tbuf[5] = 0x00;\n\tbuf[8] = 0x74;\n\tbuf[9] = 0x01;\n\tbuf[10] = 0x00;\n\tbuf[11] = 0x00;\n\tswitch (frequency) {\n\t\tcase 256:\n\t\t\tbuf[6] = 0x03;\n\t\t\tbuf[7] = 0x08;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 270:\n\t\t\tbuf[6] = 0x73;\n\t\t\tbuf[7] = 0x08;\n\t\t\tbreak;\n\t\tcase 282:\n\t\t\tbuf[6] = 0xd3;\n\t\t\tbuf[7] = 0x08;\n\t\t\tbreak;\n\t\tcase 300:\n\t\t\tbuf[6] = 0x63;\n\t\t\tbuf[7] = 0x09;\n\t\t\tbreak;\n\t\tcase 325:\n\t\t\tbuf[6] = 0x28;\n\t\t\tbuf[7] = 0x0a;\n\t\t\tbreak;\n\t\tcase 350:\n\t\t\tbuf[6] = 0xf0;\n\t\t\tbuf[7] = 0x0a;\n\t\t\tbreak;\n\t\tcase 375:\n\t\t\tbuf[6] = 0xb8;\n\t\t\tbuf[7] = 0x0b;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void avalon_create_task(struct avalon_task *at,\n\t\t\t\t      struct work *work)\n{\n\tmemcpy(at->midstate, work->midstate, 32);\n\tmemcpy(at->data, work->data + 64, 12);\n}\n\nstatic int avalon_send_task(int fd, const struct avalon_task *at,\n\t\t\t    struct cgpu_info *avalon)\n\n{\n\tsize_t ret;\n\tint full;\n\tstruct timespec p;\n\tuint8_t buf[AVALON_WRITE_SIZE + 4 * AVALON_DEFAULT_ASIC_NUM];\n\tsize_t nr_len;\n\tstruct avalon_info *info;\n\tuint64_t delay = 32000000; /* Default 32ms for B19200 */\n\tuint32_t nonce_range;\n\tint i;\n\n\tif (at->nonce_elf)\n\t\tnr_len = AVALON_WRITE_SIZE + 4 * at->asic_num;\n\telse\n\t\tnr_len = AVALON_WRITE_SIZE;\n\n\tmemcpy(buf, at, AVALON_WRITE_SIZE);\n\n\tif (at->nonce_elf) {\n\t\tnonce_range = (uint32_t)0xffffffff / at->asic_num;\n\t\tfor (i = 0; i < at->asic_num; i++) {\n\t\t\tbuf[AVALON_WRITE_SIZE + (i * 4) + 3] =\n\t\t\t\t(i * nonce_range & 0xff000000) >> 24;\n\t\t\tbuf[AVALON_WRITE_SIZE + (i * 4) + 2] =\n\t\t\t\t(i * nonce_range & 0x00ff0000) >> 16;\n\t\t\tbuf[AVALON_WRITE_SIZE + (i * 4) + 1] =\n\t\t\t\t(i * nonce_range & 0x0000ff00) >> 8;\n\t\t\tbuf[AVALON_WRITE_SIZE + (i * 4) + 0] =\n\t\t\t\t(i * nonce_range & 0x000000ff) >> 0;\n\t\t}\n\t}\n#if defined(__BIG_ENDIAN__) || defined(MIPSEB)\n\tuint8_t tt = 0;\n\n\ttt = (buf[0] & 0x0f) << 4;\n\ttt |= ((buf[0] & 0x10) ? (1 << 3) : 0);\n\ttt |= ((buf[0] & 0x20) ? (1 << 2) : 0);\n\ttt |= ((buf[0] & 0x40) ? (1 << 1) : 0);\n\ttt |= ((buf[0] & 0x80) ? (1 << 0) : 0);\n\tbuf[0] = tt;\n\n\ttt = (buf[4] & 0x0f) << 4;\n\ttt |= ((buf[4] & 0x10) ? (1 << 3) : 0);\n\ttt |= ((buf[4] & 0x20) ? (1 << 2) : 0);\n\ttt |= ((buf[4] & 0x40) ? (1 << 1) : 0);\n\ttt |= ((buf[4] & 0x80) ? (1 << 0) : 0);\n\tbuf[4] = tt;\n#endif\n\tif (likely(avalon)) {\n\t\tinfo = avalon->device_data;\n\t\tdelay = nr_len * 10 * 1000000000ULL;\n\t\tdelay = delay / info->baud;\n\t}\n\n\tif (at->reset)\n\t\tnr_len = 1;\n\tif (opt_debug) {\n\t\tchar x[(nr_len * 2) + 1];\n\t\tbin2hex(x, buf, nr_len);\n\t\tapplog(LOG_DEBUG, \"Avalon: Sent(%u): %s\", (unsigned int)nr_len, x);\n\t}\n\tret = write(fd, buf, nr_len);\n\tif (unlikely(ret != nr_len))\n\t\treturn AVA_SEND_ERROR;\n\n\tp.tv_sec = 0;\n\tp.tv_nsec = (long)delay + 4000000;\n\tnanosleep(&p, NULL);\n\tapplog(LOG_DEBUG, \"Avalon: Sent: Buffer delay: %ld\", p.tv_nsec);\n\n\tfull = avalon_buffer_full(fd);\n\tapplog(LOG_DEBUG, \"Avalon: Sent: Buffer full: %s\",\n\t       ((full == AVA_BUFFER_FULL) ? \"Yes\" : \"No\"));\n\n\tif (unlikely(full == AVA_BUFFER_FULL))\n\t\treturn AVA_SEND_BUFFER_FULL;\n\n\treturn AVA_SEND_BUFFER_EMPTY;\n}\n\nstatic inline int avalon_gets(int fd, uint8_t *buf, int read_count,\n\t\t       struct thr_info *thr, struct timeval *tv_finish)\n{\n\tssize_t ret = 0;\n\tint rc = 0;\n\tint read_amount = AVALON_READ_SIZE;\n\tbool first = true;\n\n\t/* Read reply 1 byte at a time to get earliest tv_finish */\n\twhile (true) {\n\t\tret = read(fd, buf, 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Avalon: Error on read in avalon_gets: %s\", bfg_strerror(errno, BST_ERRNO));\n\t\t\treturn AVA_GETS_ERROR;\n\t\t}\n\n\t\tif (first && likely(tv_finish))\n\t\t\tcgtime(tv_finish);\n\n\t\tif (ret >= read_amount)\n\t\t\treturn AVA_GETS_OK;\n\n\t\tif (ret > 0) {\n\t\t\tbuf += ret;\n\t\t\tread_amount -= ret;\n\t\t\tfirst = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (thr && thr->work_restart) {\n\t\t\tif (opt_debug) {\n\t\t\t\tapplog(LOG_WARNING,\n\t\t\t\t       \"Avalon: Work restart at %.2f seconds\",\n\t\t\t\t       (float)(rc)/(float)AVALON_TIME_FACTOR);\n\t\t\t}\n\t\t\treturn AVA_GETS_RESTART;\n\t\t}\n\n\t\trc++;\n\t\tif (rc >= read_count) {\n\t\t\tif (opt_debug) {\n\t\t\t\tapplog(LOG_WARNING,\n\t\t\t\t       \"Avalon: No data in %.2f seconds\",\n\t\t\t\t       (float)rc/(float)AVALON_TIME_FACTOR);\n\t\t\t}\n\t\t\treturn AVA_GETS_TIMEOUT;\n\t\t}\n\t}\n}\n\nstatic int avalon_get_result(int fd, struct avalon_result *ar,\n\t\t\t     struct thr_info *thr, struct timeval *tv_finish)\n{\n\tstruct cgpu_info *avalon;\n\tstruct avalon_info *info;\n\tuint8_t result[AVALON_READ_SIZE];\n\tint ret, read_count;\n\n\tavalon = thr->cgpu;\n\tinfo = avalon->device_data;\n\tread_count = info->read_count;\n\n\tmemset(result, 0, AVALON_READ_SIZE);\n\tret = avalon_gets(fd, result, read_count, thr, tv_finish);\n\n\tif (ret == AVA_GETS_OK) {\n\t\tif (opt_debug) {\n\t\t\tchar x[(AVALON_READ_SIZE * 2) + 1];\n\t\t\tbin2hex(x, result, AVALON_READ_SIZE);\n\t\t\tapplog(LOG_DEBUG, \"Avalon: get: %s\", x);\n\t\t}\n\t\tmemcpy((uint8_t *)ar, result, AVALON_READ_SIZE);\n\t}\n\n\treturn ret;\n}\n\nstatic bool avalon_decode_nonce(struct thr_info *thr, struct avalon_result *ar,\n\t\t\t\tuint32_t *nonce)\n{\n\tstruct cgpu_info *avalon;\n\tstruct avalon_info *info;\n\tstruct work *work;\n\n\tavalon = thr->cgpu;\n\tif (unlikely(!avalon->works))\n\t\treturn false;\n\n\twork = clone_queued_work_bymidstate(avalon, (char *)ar->midstate, 32,\n\t\t\t\t\t   (char *)ar->data, 64, 12);\n\tif (!work)\n\t\treturn false;\n\n\tinfo = avalon->device_data;\n\tinfo->matching_work[work->subid]++;\n\t*nonce = htole32(ar->nonce);\n\tsubmit_nonce(thr, work, *nonce);\n\t\n\tfree_work(work);\n\n\treturn true;\n}\n\nstatic void avalon_get_reset(int fd, struct avalon_result *ar)\n{\n\tint ret;\n\tconst int read_count = AVALON_RESET_FAULT_DECISECONDS * AVALON_TIME_FACTOR;\n\t\n\tmemset(ar, 0, AVALON_READ_SIZE);\n\tret = avalon_gets(fd, (uint8_t*)ar, read_count, NULL, NULL);\n\t\n\tif (ret == AVA_GETS_OK && opt_debug) {\n\t\tchar x[(AVALON_READ_SIZE * 2) + 1];\n\t\tbin2hex(x, ar, AVALON_READ_SIZE);\n\t\tapplog(LOG_DEBUG, \"Avalon: get: %s\", x);\n\t}\n}\n\nstatic int avalon_reset(int fd, struct avalon_result *ar)\n{\n\tstruct avalon_task at;\n\tuint8_t *buf;\n\tint ret, i = 0;\n\tstruct timespec p;\n\n\tavalon_init_task(&at, 1, 0,\n\t\t\t AVALON_DEFAULT_FAN_MAX_PWM,\n\t\t\t AVALON_DEFAULT_TIMEOUT,\n\t\t\t AVALON_DEFAULT_ASIC_NUM,\n\t\t\t AVALON_DEFAULT_MINER_NUM,\n\t\t\t 0, 0,\n\t\t\t AVALON_DEFAULT_FREQUENCY);\n\tret = avalon_send_task(fd, &at, NULL);\n\tif (ret == AVA_SEND_ERROR)\n\t\treturn 1;\n\n\tavalon_get_reset(fd, ar);\n\n\tbuf = (uint8_t *)ar;\n\t/* Sometimes there is one extra 0 byte for some reason in the buffer,\n\t * so work around it. */\n\tif (buf[0] == 0)\n\t\tbuf = (uint8_t  *)(ar + 1);\n\tif (buf[0] == 0xAA && buf[1] == 0x55 &&\n\t    buf[2] == 0xAA && buf[3] == 0x55) {\n\t\tfor (i = 4; i < 11; i++)\n\t\t\tif (buf[i] != 0)\n\t\t\t\tbreak;\n\t}\n\n\tp.tv_sec = 0;\n\tp.tv_nsec = AVALON_RESET_PITCH;\n\tnanosleep(&p, NULL);\n\n\tif (i != 11) {\n\t\tapplog(LOG_ERR, \"Avalon: Reset failed! not an Avalon?\"\n\t\t       \" (%d: %02x %02x %02x %02x)\",\n\t\t       i, buf[0], buf[1], buf[2], buf[3]);\n\t\t/* FIXME: return 1; */\n\t} else\n\t\tapplog(LOG_WARNING, \"Avalon: Reset succeeded\");\n\treturn 0;\n}\n\nstatic void avalon_idle(struct cgpu_info *avalon)\n{\n\tint i, ret;\n\tstruct avalon_task at;\n\n\tint fd = avalon->device_fd;\n\tstruct avalon_info *info = avalon->device_data;\n\tint avalon_get_work_count = info->miner_count;\n\n\ti = 0;\n\twhile (true) {\n\t\tavalon_init_task(&at, 0, 0, info->fan_pwm,\n\t\t\t\t info->timeout, info->asic_count,\n\t\t\t\t info->miner_count, 1, 1, info->frequency);\n\t\tret = avalon_send_task(fd, &at, avalon);\n\t\tif (unlikely(ret == AVA_SEND_ERROR ||\n\t\t\t     (ret == AVA_SEND_BUFFER_EMPTY &&\n\t\t\t      (i + 1 == avalon_get_work_count * 2)))) {\n\t\t\tapplog(LOG_ERR, \"AVA%i: Comms error\", avalon->device_id);\n\t\t\treturn;\n\t\t}\n\t\tif (i + 1 == avalon_get_work_count * 2)\n\t\t\tbreak;\n\n\t\tif (ret == AVA_SEND_BUFFER_FULL)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\tapplog(LOG_ERR, \"Avalon: Goto idle mode\");\n}\n\nstatic\nconst char *avalon_set_baud(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct avalon_info * const info = proc->device_data;\n\tconst int baud = atoi(newvalue);\n\tif (!valid_baud(baud))\n\t\treturn \"Invalid baud setting\";\n\tinfo->baud = baud;\n\treturn NULL;\n}\n\nstatic\nconst char *avalon_set_miner_count(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct avalon_info * const info = proc->device_data;\n\tconst int miner_count = atoi(newvalue);\n\tif (miner_count <= 0 || miner_count > AVALON_DEFAULT_MINER_NUM)\n\t\treturn \"Invalid miner_count: must be 1 ~ \" AVALON_DEFAULT_MINER_NUM_S;\n\tinfo->miner_count = miner_count;\n\treturn NULL;\n}\n\nstatic\nconst char *avalon_set_asic_count(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct avalon_info * const info = proc->device_data;\n\tconst int asic_count = atoi(newvalue);\n\tif (asic_count <= 0 || asic_count > AVALON_DEFAULT_ASIC_NUM)\n\t\treturn \"Invalid asic_count: must be 1 ~ \" AVALON_DEFAULT_ASIC_NUM_S;\n\tinfo->asic_count = asic_count;\n\treturn NULL;\n}\n\nstatic\nconst char *avalon_set_timeout(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct avalon_info * const info = proc->device_data;\n\tconst int timeout = atoi(newvalue);\n\tif (timeout <= 0 || timeout > 0xff)\n\t\treturn \"Invalid timeout: must be 1 ~ 255\";\n\tinfo->timeout = timeout;\n\treturn NULL;\n}\n\nstatic\nconst char *avalon_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct avalon_info * const info = proc->device_data;\n\tconst int clock = atoi(newvalue);\n\tswitch (clock) {\n\t\tdefault:\n\t\t\treturn \"Invalid clock: must be 256/270/282/300/325/350/375\";\n\t\tcase 256:\n\t\tcase 270:\n\t\tcase 282:\n\t\tcase 300:\n\t\tcase 325:\n\t\tcase 350:\n\t\tcase 375:\n\t\t\tinfo->frequency = clock;\n\t}\n\treturn NULL;\n}\n\nconst struct bfg_set_device_definition avalon_set_device_funcs[] = {\n\t// NOTE: Order of parameters below is important for --avalon-options\n\t{\"baud\"       , avalon_set_baud       , \"serial baud rate\"},\n\t{\"miner_count\", avalon_set_miner_count, \"\"},\n\t{\"asic_count\" , avalon_set_asic_count , \"\"},\n\t{\"timeout\"    , avalon_set_timeout    , \"how long the device will work on a work item before accepting new work\"},\n\t{\"clock\"      , avalon_set_clock      , \"clock speed: 256, 270, 282, 300, 325, 350, or 375\"},\n\t{NULL},\n};\n\n#ifdef HAVE_CURSES\nstatic\nvoid avalon_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct avalon_info *info = proc->device_data;\n\t\n\tif (((info->temp0?1:0) + (info->temp1?1:0) + (info->temp2?1:0)) > 1)\n\t{\n\t\twlogprint(\"Temperatures:\");\n\t\tif (info->temp0)  wlogprint(\" %uC\", (unsigned)info->temp0);\n\t\tif (info->temp1)  wlogprint(\" %uC\", (unsigned)info->temp1);\n\t\tif (info->temp2)  wlogprint(\" %uC\", (unsigned)info->temp2);\n\t}\n\twlogprint(\"\\n\");\n\t\n\twlogprint(\"Clock speed: %d\\n\", info->frequency);\n}\n\nstatic\nvoid avalon_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *avalon_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t\treturn proc_set_device_tui_wrapper(proc, NULL, avalon_set_clock, \"Set clock speed (256, 270, 282, 300, 325, 350, or 375)\", NULL);\n\t}\n\treturn NULL;\n}\n#endif\n\n/* Non blocking clearing of anything in the buffer */\nstatic void avalon_clear_readbuf(int fd)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tchar buf[AVALON_FTDI_READSIZE];\n#ifndef WIN32\n\t\tstruct timeval timeout;\n\t\tfd_set rd;\n\n\t\ttimeout.tv_sec = timeout.tv_usec = 0;\n\t\tFD_ZERO(&rd);\n\t\tFD_SET((SOCKETTYPE)fd, &rd);\n\t\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\t\tif (ret > 0)\n#endif\n\t\t\t// Relies on serial timeout for Windows\n\t\t\tret = read(fd, buf, AVALON_FTDI_READSIZE);\n\t} while (ret > 0);\n}\n\nstatic\nvoid avalon_zero_stats(struct cgpu_info * const cgpu)\n{\n\tstruct avalon_info *info = cgpu->device_data;\n\t\n\tinfo->temp_max = 0;\n\tinfo->no_matching_work = 0;\n\t\n\tfor (int i = 0; i < info->miner_count; ++i)\n\t\tinfo->matching_work[i] = 0;\n}\n\nstatic bool avalon_detect_one(const char *devpath)\n{\n\tstruct avalon_info *info;\n\tstruct avalon_result ar;\n\tint fd, ret;\n\tstruct cgpu_info *avalon;\n\n\tif (serial_claim(devpath, &avalon_drv))\n\t\treturn false;\n\t\n\tinfo = malloc(sizeof(*info));\n\tif (unlikely(!info))\n\t\tapplogr(false, LOG_ERR, \"Failed to malloc avalon_info data\");\n\t*info = (struct avalon_info){\n\t\t.baud = AVALON_IO_SPEED,\n\t\t.miner_count = AVALON_DEFAULT_MINER_NUM - 8,\n\t\t.asic_count = AVALON_DEFAULT_ASIC_NUM,\n\t\t.timeout = AVALON_DEFAULT_TIMEOUT,\n\t\t.frequency = AVALON_DEFAULT_FREQUENCY,\n\t};\n\tdrv_set_defaults(&avalon_drv, avalon_set_device_funcs, info, devpath, detectone_meta_info.serial, 1);\n\n\tapplog(LOG_DEBUG, \"Avalon Detect: Attempting to open %s \"\n\t       \"(baud=%d miner_count=%d asic_count=%d timeout=%d frequency=%d)\",\n\t       devpath, info->baud, info->miner_count, info->asic_count, info->timeout, info->frequency);\n\n\tfd = avalon_open2(devpath, info->baud, true);\n\tif (unlikely(fd == -1)) {\n\t\tapplog(LOG_ERR, \"Avalon Detect: Failed to open %s\", devpath);\n\t\tfree(info);\n\t\treturn false;\n\t}\n\tavalon_clear_readbuf(fd);\n\n\t/* We have a real Avalon! */\n\tavalon = calloc(1, sizeof(struct cgpu_info));\n\tavalon->drv = &avalon_drv;\n\tavalon->device_path = strdup(devpath);\n\tavalon->device_fd = fd;\n\tavalon->threads = AVALON_MINER_THREADS;\n\tavalon->set_device_funcs = avalon_set_device_funcs;\n\tadd_cgpu(avalon);\n\n\tret = avalon_reset(fd, &ar);\n\tif (ret) {\n\t\t; /* FIXME: I think IT IS avalon and wait on reset;\n\t\t   * avalon_close(fd);\n\t\t   * free(info);\n\t\t   * return false; */\n\t}\n\t\n\tapplog(LOG_INFO, \"Avalon Detect: Found at %s, mark as %d\",\n\t       devpath, avalon->device_id);\n\n\tavalon->device_data = info;\n\n\tinfo->read_count = ((float)info->timeout * AVALON_HASH_TIME_FACTOR *\n\t\t\t    AVALON_TIME_FACTOR) / (float)info->miner_count;\n\n\tinfo->fan_pwm = AVALON_DEFAULT_FAN_MIN_PWM;\n\tavalon_zero_stats(avalon);\n\t/* This is for check the temp/fan every 3~4s */\n\tinfo->temp_history_count = (4 / (float)((float)info->timeout * ((float)1.67/0x32))) + 1;\n\tif (info->temp_history_count <= 0)\n\t\tinfo->temp_history_count = 1;\n\n\tinfo->temp_history_index = 0;\n\tinfo->temp_sum = 0;\n\tinfo->temp_old = 0;\n\n\t/* Set asic to idle mode after detect */\n\tavalon_idle(avalon);\n\tavalon->device_fd = -1;\n\n\tavalon_close(fd);\n\treturn true;\n}\n\nstatic\nbool avalon_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, avalon_detect_one);\n}\n\nstatic void __avalon_init(struct cgpu_info *avalon)\n{\n\tapplog(LOG_INFO, \"Avalon: Opened on %s\", avalon->device_path);\n}\n\nstatic void avalon_init(struct cgpu_info *avalon)\n{\n\tstruct avalon_info *info = avalon->device_data;\n\tstruct avalon_result ar;\n\tint fd, ret;\n\t\n\tcgpu_set_defaults(avalon);\n\tavalon->set_device_funcs = NULL;\n\n\tavalon->device_fd = -1;\n\tfd = avalon_open(avalon->device_path, info->baud);\n\tif (unlikely(fd == -1)) {\n\t\tapplog(LOG_ERR, \"Avalon: Failed to open on %s\",\n\t\t       avalon->device_path);\n\t\treturn;\n\t}\n\n\tret = avalon_reset(fd, &ar);\n\tif (ret) {\n\t\tavalon_close(fd);\n\t\treturn;\n\t}\n\n\tavalon->device_fd = fd;\n\t__avalon_init(avalon);\n}\n\nstatic bool avalon_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *avalon = thr->cgpu;\n\tstruct avalon_info *info = avalon->device_data;\n\n\tfree(avalon->works);\n\tavalon->works = calloc(info->miner_count * sizeof(struct work *),\n\t\t\t       AVALON_ARRAY_SIZE);\n\tif (!avalon->works)\n\t\tquithere(1, \"Failed to calloc avalon works\");\n\tif (avalon->device_fd == -1)\n\t\tavalon_init(avalon);\n\telse\n\t\t__avalon_init(avalon);\n\n\tavalon->status = LIFE_INIT2;\n\treturn true;\n}\n\nstatic void avalon_free_work(struct thr_info *thr)\n{\n\tstruct cgpu_info *avalon;\n\tstruct avalon_info *info;\n\tstruct work **works;\n\tint i;\n\n\tavalon = thr->cgpu;\n\tavalon->queued = 0;\n\tif (unlikely(!avalon->works))\n\t\treturn;\n\tworks = avalon->works;\n\tinfo = avalon->device_data;\n\n\tfor (i = 0; i < info->miner_count * 4; i++) {\n\t\tif (works[i]) {\n\t\t\twork_completed(avalon, works[i]);\n\t\t\tworks[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic void do_avalon_close(struct thr_info *thr)\n{\n\tstruct avalon_result ar;\n\tstruct cgpu_info *avalon = thr->cgpu;\n\tstruct avalon_info *info = avalon->device_data;\n\n\tavalon_free_work(thr);\n\tcgsleep_ms(1000);\n\tavalon_reset(avalon->device_fd, &ar);\n\tavalon_idle(avalon);\n\tavalon_close(avalon->device_fd);\n\tavalon->device_fd = -1;\n\n\tinfo->no_matching_work = 0;\n}\n\nstatic inline void record_temp_fan(struct avalon_info *info, struct avalon_result *ar, float *temp_avg)\n{\n\tinfo->fan0 = ar->fan0 * AVALON_FAN_FACTOR;\n\tinfo->fan1 = ar->fan1 * AVALON_FAN_FACTOR;\n\tinfo->fan2 = ar->fan2 * AVALON_FAN_FACTOR;\n\n\tinfo->temp0 = ar->temp0;\n\tinfo->temp1 = ar->temp1;\n\tinfo->temp2 = ar->temp2;\n\tif (ar->temp0 & 0x80) {\n\t\tar->temp0 &= 0x7f;\n\t\tinfo->temp0 = 0 - ((~ar->temp0 & 0x7f) + 1);\n\t}\n\tif (ar->temp1 & 0x80) {\n\t\tar->temp1 &= 0x7f;\n\t\tinfo->temp1 = 0 - ((~ar->temp1 & 0x7f) + 1);\n\t}\n\tif (ar->temp2 & 0x80) {\n\t\tar->temp2 &= 0x7f;\n\t\tinfo->temp2 = 0 - ((~ar->temp2 & 0x7f) + 1);\n\t}\n\n\t*temp_avg = info->temp2 > info->temp1 ? info->temp2 : info->temp1;\n\n\tif (info->temp0 > info->temp_max)\n\t\tinfo->temp_max = info->temp0;\n\tif (info->temp1 > info->temp_max)\n\t\tinfo->temp_max = info->temp1;\n\tif (info->temp2 > info->temp_max)\n\t\tinfo->temp_max = info->temp2;\n}\n\nstatic inline void adjust_fan(struct avalon_info *info)\n{\n\tint temp_new;\n\n\ttemp_new = info->temp_sum / info->temp_history_count;\n\n\tif (temp_new < 35) {\n\t\tinfo->fan_pwm = AVALON_DEFAULT_FAN_MIN_PWM;\n\t\tinfo->temp_old = temp_new;\n\t} else if (temp_new > 55) {\n\t\tinfo->fan_pwm = AVALON_DEFAULT_FAN_MAX_PWM;\n\t\tinfo->temp_old = temp_new;\n\t} else if (abs(temp_new - info->temp_old) >= 2) {\n\t\tinfo->fan_pwm = AVALON_DEFAULT_FAN_MIN_PWM + (temp_new - 35) * 6.4;\n\t\tinfo->temp_old = temp_new;\n\t}\n}\n\n/* We use a replacement algorithm to only remove references to work done from\n * the buffer when we need the extra space for new work. */\nstatic bool avalon_fill(struct cgpu_info *avalon)\n{\n\tstruct avalon_info *info = avalon->device_data;\n\tint subid, slot, mc;\n\tstruct work *work;\n\n\tmc = info->miner_count;\n\tif (avalon->queued >= mc)\n\t\treturn true;\n\twork = get_queued(avalon);\n\tif (unlikely(!work))\n\t\treturn false;\n\tsubid = avalon->queued++;\n\twork->subid = subid;\n\tslot = avalon->work_array * mc + subid;\n\tif (likely(avalon->works[slot]))\n\t\twork_completed(avalon, avalon->works[slot]);\n\tavalon->works[slot] = work;\n\tif (avalon->queued >= mc)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void avalon_rotate_array(struct cgpu_info *avalon)\n{\n\tavalon->queued = 0;\n\tif (++avalon->work_array >= AVALON_ARRAY_SIZE)\n\t\tavalon->work_array = 0;\n}\n\nstatic int64_t avalon_scanhash(struct thr_info *thr)\n{\n\tstruct cgpu_info *avalon;\n\tstruct work **works;\n\tint fd, ret = AVA_GETS_OK, full;\n\n\tstruct avalon_info *info;\n\tstruct avalon_task at;\n\tstruct avalon_result ar;\n\tint i;\n\tint avalon_get_work_count;\n\tint start_count, end_count;\n\n\tstruct timeval tv_start, tv_finish, elapsed;\n\tuint32_t nonce;\n\tint64_t hash_count;\n\tstatic int first_try = 0;\n\tint result_wrong;\n\n\tavalon = thr->cgpu;\n\tworks = avalon->works;\n\tinfo = avalon->device_data;\n\tavalon_get_work_count = info->miner_count;\n\n\tif (unlikely(avalon->device_fd == -1)) {\n\t\tif (!avalon_prepare(thr)) {\n\t\t\tapplog(LOG_ERR, \"AVA%i: Comms error(open)\",\n\t\t\t       avalon->device_id);\n\t\t\tdev_error(avalon, REASON_DEV_COMMS_ERROR);\n\t\t\t/* fail the device if the reopen attempt fails */\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfd = avalon->device_fd;\n#ifndef WIN32\n\ttcflush(fd, TCOFLUSH);\n#endif\n\n\tstart_count = avalon->work_array * avalon_get_work_count;\n\tend_count = start_count + avalon_get_work_count;\n\ti = start_count;\n\twhile (true) {\n\t\tavalon_init_task(&at, 0, 0, info->fan_pwm,\n\t\t\t\t info->timeout, info->asic_count,\n\t\t\t\t info->miner_count, 1, 0, info->frequency);\n\t\tavalon_create_task(&at, works[i]);\n\t\tret = avalon_send_task(fd, &at, avalon);\n\t\tif (unlikely(ret == AVA_SEND_ERROR ||\n\t\t\t     (ret == AVA_SEND_BUFFER_EMPTY &&\n\t\t\t      (i + 1 == end_count) &&\n\t\t\t      first_try))) {\n\t\t\tdo_avalon_close(thr);\n\t\t\tapplog(LOG_ERR, \"AVA%i: Comms error(buffer)\",\n\t\t\t       avalon->device_id);\n\t\t\tdev_error(avalon, REASON_DEV_COMMS_ERROR);\n\t\t\tfirst_try = 0;\n\t\t\tcgsleep_ms(1000);\n\t\t\tavalon_init(avalon);\n\t\t\treturn 0;\t/* This should never happen */\n\t\t}\n\t\tif (ret == AVA_SEND_BUFFER_EMPTY && (i + 1 == end_count)) {\n\t\t\tfirst_try = 1;\n\t\t\tavalon_rotate_array(avalon);\n\t\t\treturn 0xffffffff;\n\t\t}\n\n\t\tworks[i]->blk.nonce = 0xffffffff;\n\n\t\tif (ret == AVA_SEND_BUFFER_FULL)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\tif (unlikely(first_try))\n\t\tfirst_try = 0;\n\n\telapsed.tv_sec = elapsed.tv_usec = 0;\n\tcgtime(&tv_start);\n\n\tresult_wrong = 0;\n\thash_count = 0;\n\twhile (true) {\n\t\tfull = avalon_buffer_full(fd);\n\t\tapplog(LOG_DEBUG, \"Avalon: Buffer full: %s\",\n\t\t       ((full == AVA_BUFFER_FULL) ? \"Yes\" : \"No\"));\n\t\tif (unlikely(full == AVA_BUFFER_EMPTY))\n\t\t\tbreak;\n\n\t\tret = avalon_get_result(fd, &ar, thr, &tv_finish);\n\t\tif (unlikely(ret == AVA_GETS_ERROR)) {\n\t\t\tdo_avalon_close(thr);\n\t\t\tapplog(LOG_ERR,\n\t\t\t       \"AVA%i: Comms error(read)\", avalon->device_id);\n\t\t\tdev_error(avalon, REASON_DEV_COMMS_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(ret == AVA_GETS_RESTART))\n\t\t\tbreak;\n\t\tif (unlikely(ret == AVA_GETS_TIMEOUT)) {\n\t\t\ttimersub(&tv_finish, &tv_start, &elapsed);\n\t\t\tapplog(LOG_DEBUG, \"Avalon: no nonce in (%ld.%06lds)\",\n\t\t\t       (long)elapsed.tv_sec, (long)elapsed.tv_usec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!avalon_decode_nonce(thr, &ar, &nonce)) {\n\t\t\tinfo->no_matching_work++;\n\t\t\tresult_wrong++;\n\n\t\t\tif (unlikely(result_wrong >= avalon_get_work_count))\n\t\t\t\tbreak;\n\n\t\t\tif (opt_debug) {\n\t\t\t\ttimersub(&tv_finish, &tv_start, &elapsed);\n\t\t\t\tapplog(LOG_DEBUG,\"Avalon: no matching work: %d\"\n\t\t\t\t\" (%ld.%06lds)\", info->no_matching_work,\n\t\t\t\t(long)elapsed.tv_sec, (long)elapsed.tv_usec);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\thash_count += 0xffffffff;\n\t\tif (opt_debug) {\n\t\t\ttimersub(&tv_finish, &tv_start, &elapsed);\n\t\t\tapplog(LOG_DEBUG,\n\t\t\t       \"Avalon: nonce = 0x%08\"PRIx32\" = 0x%08\"PRIx64\" hashes \"\n\t\t\t       \"(%ld.%06lds)\", nonce, (uint64_t)hash_count,\n\t\t\t       (long)elapsed.tv_sec, (long)elapsed.tv_usec);\n\t\t}\n\t}\n\tif (hash_count && avalon->results < AVALON_ARRAY_SIZE)\n\t\tavalon->results++;\n\tif (unlikely((result_wrong >= avalon_get_work_count) ||\n\t    (!hash_count && ret != AVA_GETS_RESTART && --avalon->results < 0))) {\n\t\t/* Look for all invalid results, or consecutive failure\n\t\t * to generate any results suggesting the FPGA\n\t\t * controller has screwed up. */\n\t\tdo_avalon_close(thr);\n\t\tapplog(LOG_ERR,\n\t\t\t\"AVA%i: FPGA controller messed up, %d wrong results\",\n\t\t\tavalon->device_id, result_wrong);\n\t\tdev_error(avalon, REASON_DEV_COMMS_ERROR);\n\t\tcgsleep_ms(1000);\n\t\tavalon_init(avalon);\n\t\treturn 0;\n\t}\n\n\tavalon_rotate_array(avalon);\n\n\tif (hash_count) {\n\t\trecord_temp_fan(info, &ar, &(avalon->temp));\n\t\tavalon->temp = info->temp_max;\n\t\tapplog(LOG_INFO,\n\t\t       \"Avalon: Fan1: %d/m, Fan2: %d/m, Fan3: %d/m\\t\"\n\t\t       \"Temp1: %dC, Temp2: %dC, Temp3: %dC, TempMAX: %dC\",\n\t\t       info->fan0, info->fan1, info->fan2,\n\t\t       info->temp0, info->temp1, info->temp2, info->temp_max);\n\t\tinfo->temp_history_index++;\n\t\tinfo->temp_sum += avalon->temp;\n\t\tapplog(LOG_DEBUG, \"Avalon: temp_index: %d, temp_count: %d, temp_old: %d\",\n\t\t       info->temp_history_index, info->temp_history_count, info->temp_old);\n\t\tif (info->temp_history_index == info->temp_history_count) {\n\t\t\tadjust_fan(info);\n\t\t\tinfo->temp_history_index = 0;\n\t\t\tinfo->temp_sum = 0;\n\t\t}\n\t}\n\n\t/* This hashmeter is just a utility counter based on returned shares */\n\treturn hash_count;\n}\n\nstatic struct api_data *avalon_api_stats(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\tstruct avalon_info *info = cgpu->device_data;\n\tint i;\n\n\troot = api_add_int(root, \"baud\", &(info->baud), false);\n\troot = api_add_int(root, \"miner_count\", &(info->miner_count),false);\n\troot = api_add_int(root, \"asic_count\", &(info->asic_count), false);\n\troot = api_add_int(root, \"read_count\", &(info->read_count), false);\n\troot = api_add_int(root, \"timeout\", &(info->timeout), false);\n\troot = api_add_int(root, \"frequency\", &(info->frequency), false);\n\n\troot = api_add_int(root, \"fan1\", &(info->fan0), false);\n\troot = api_add_int(root, \"fan2\", &(info->fan1), false);\n\troot = api_add_int(root, \"fan3\", &(info->fan2), false);\n\n\troot = api_add_int(root, \"temp1\", &(info->temp0), false);\n\troot = api_add_int(root, \"temp2\", &(info->temp1), false);\n\troot = api_add_int(root, \"temp3\", &(info->temp2), false);\n\troot = api_add_int(root, \"temp_max\", &(info->temp_max), false);\n\n\troot = api_add_int(root, \"no_matching_work\", &(info->no_matching_work), false);\n\tfor (i = 0; i < info->miner_count; i++) {\n\t\tchar mcw[24];\n\n\t\tsprintf(mcw, \"match_work_count%d\", i + 1);\n\t\troot = api_add_int(root, mcw, &(info->matching_work[i]), false);\n\t}\n\n\treturn root;\n}\n\nstatic void avalon_shutdown(struct thr_info *thr)\n{\n\tdo_avalon_close(thr);\n}\n\nstruct device_drv avalon_drv = {\n\t.dname = \"avalon\",\n\t.name = \"AVA\",\n\t.lowl_probe_by_name_only = true,\n\t.lowl_probe = avalon_lowl_probe,\n\t.thread_prepare = avalon_prepare,\n\t.minerloop = hash_queued_work,\n\t.queue_full = avalon_fill,\n\t.scanwork = avalon_scanhash,\n\t.zero_stats = avalon_zero_stats,\n\t.get_api_stats = avalon_api_stats,\n\t.reinit_device = avalon_init,\n\t.thread_shutdown = avalon_shutdown,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = avalon_wlogprint_status,\n\t.proc_tui_wlogprint_choices = avalon_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = avalon_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-avalon.h",
          "type": "blob",
          "size": 3.1669921875,
          "content": "/*\n * Copyright 2013 Avalon project\n * Copyright 2013 Con Kolivas\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef AVALON_H\n#define AVALON_H\n\n#ifdef USE_AVALON\n\n#include <stdint.h>\n\n#define AVALON_TIME_FACTOR 10\n#define AVALON_RESET_FAULT_DECISECONDS 1\n#define AVALON_MINER_THREADS 1\n\n#define AVALON_IO_SPEED\t\t115200\n#define AVALON_HASH_TIME_FACTOR\t((float)1.67/0x32)\n#define AVALON_RESET_PITCH\t(300*1000*1000)\n\n#define AVALON_FAN_FACTOR 120\n#define AVALON_DEFAULT_FAN_MAX_PWM 0xA0 /* 100% */\n#define AVALON_DEFAULT_FAN_MIN_PWM 0x20 /*  20% */\n\n#define AVALON_DEFAULT_TIMEOUT 0x32\n#define AVALON_DEFAULT_FREQUENCY 256\n#define AVALON_DEFAULT_MINER_NUM 0x20\n#define AVALON_DEFAULT_MINER_NUM_S \"32\"\n#define AVALON_DEFAULT_ASIC_NUM 0xA\n#define AVALON_DEFAULT_ASIC_NUM_S \"10\"\n\n#define AVALON_FTDI_READSIZE 512\n\nstruct avalon_task {\n\tuint8_t reset\t\t:1;\n\tuint8_t flush_fifo\t:1;\n\tuint8_t fan_eft\t\t:1;\n\tuint8_t timer_eft\t:1;\n\tuint8_t asic_num\t:4;\n\tuint8_t fan_pwm_data;\n\tuint8_t timeout_data;\n\tuint8_t miner_num;\n\n\tuint8_t nonce_elf\t\t:1;\n\tuint8_t gate_miner_elf\t\t:1;\n\tuint8_t asic_pll\t\t:1;\n\tuint8_t gate_miner\t\t:1;\n\tuint8_t _pad0\t\t\t:4;\n\tuint8_t _pad1[3];\n\tuint32_t _pad2;\n\n\tuint8_t midstate[32];\n\tuint8_t data[12];\n} __attribute__((packed, aligned(4)));\n\nstruct avalon_result {\n\tuint32_t nonce;\n\tuint8_t data[12];\n\tuint8_t midstate[32];\n\n\tuint8_t fan0;\n\tuint8_t fan1;\n\tuint8_t fan2;\n\tuint8_t temp0;\n\tuint8_t temp1;\n\tuint8_t temp2;\n\tuint8_t _pad0[2];\n\n\tuint16_t fifo_wp;\n\tuint16_t fifo_rp;\n\tuint8_t chip_num;\n\tuint8_t pwm_data;\n\tuint8_t timeout;\n\tuint8_t miner_num;\n} __attribute__((packed, aligned(4)));\n\nstruct avalon_info {\n\tint read_count;\n\n\tint baud;\n\tint miner_count;\n\tint asic_count;\n\tint timeout;\n\n\tint fan0;\n\tint fan1;\n\tint fan2;\n\n\tint temp0;\n\tint temp1;\n\tint temp2;\n\tint temp_max;\n\tint temp_history_count;\n\tint temp_history_index;\n\tint temp_sum;\n\tint temp_old;\n\tint fan_pwm;\n\n\tint no_matching_work;\n\tint matching_work[AVALON_DEFAULT_MINER_NUM];\n\n\tint frequency;\n};\n\n#define AVALON_WRITE_SIZE (sizeof(struct avalon_task))\n#define AVALON_READ_SIZE (sizeof(struct avalon_result))\n#define AVALON_ARRAY_SIZE 4\n\n#define AVA_GETS_ERROR -1\n#define AVA_GETS_OK 0\n#define AVA_GETS_RESTART 1\n#define AVA_GETS_TIMEOUT 2\n\n#define AVA_SEND_ERROR -1\n#define AVA_SEND_OK 0\n#define AVA_SEND_BUFFER_EMPTY 1\n#define AVA_SEND_BUFFER_FULL 2\n\n#define AVA_BUFFER_FULL 0\n#define AVA_BUFFER_EMPTY 1\n\n#define avalon_open2(devpath, baud, purge)  serial_open(devpath, baud, AVALON_RESET_FAULT_DECISECONDS, purge)\n#define avalon_open(devpath, baud)  avalon_open2(devpath, baud, true)\n#define avalon_close(fd) close(fd)\n\n#define avalon_buffer_full(fd)\t(get_serial_cts(fd) != BGV_LOW)\n\n#define AVALON_READ_TIME(baud) ((double)AVALON_READ_SIZE * (double)8.0 / (double)(baud))\n#define ASSERT1(condition) __maybe_unused static char sizeof_uint32_t_must_be_4[(condition)?1:-1]\nASSERT1(sizeof(uint32_t) == 4);\n\nextern struct avalon_info **avalon_info;\n\n#endif /* USE_AVALON */\n#endif\t/* AVALON_H */\n"
        },
        {
          "name": "driver-avalonmm.c",
          "type": "blob",
          "size": 25.423828125,
          "content": "/*\n * Copyright 2014-2016 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <utlist.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"miner.h\"\n#include \"util.h\"\n#include \"work2d.h\"\n\n#define AVALONMM_MAX_MODULES  4\n#define AVALONMM_MAX_COINBASE_SIZE  (6 * 1024)\n#define AVALONMM_MAX_MERKLES  20\n#define AVALONMM_MAX_NONCE_DIFF  0x20\n\n// Must be a power of two\n#define AVALONMM_CACHED_JOBS  2\n\n#define AVALONMM_NONCE_OFFSET  0x180\n\nBFG_REGISTER_DRIVER(avalonmm_drv)\nstatic const struct bfg_set_device_definition avalonmm_set_device_funcs[];\n\n#define AVALONMM_PKT_DATA_SIZE  0x20\n#define AVALONMM_PKT_SIZE  (AVALONMM_PKT_DATA_SIZE + 7)\n\nenum avalonmm_cmd {\n\tAMC_DETECT     = 0x0a,\n\tAMC_NEW_JOB    = 0x0b,\n\tAMC_JOB_ID     = 0x0c,\n\tAMC_COINBASE   = 0x0d,\n\tAMC_MERKLES    = 0x0e,\n\tAMC_BLKHDR     = 0x0f,\n\tAMC_POLL       = 0x10,\n\tAMC_TARGET     = 0x11,\n\tAMC_START      = 0x13,\n};\n\nenum avalonmm_reply {\n\tAMR_NONCE      = 0x17,\n\tAMR_STATUS     = 0x18,\n\tAMR_DETECT_ACK = 0x19,\n};\n\nstatic\nbool avalonmm_write_cmd(const int fd, const enum avalonmm_cmd cmd, const void *data, size_t datasz)\n{\n\tuint8_t packets = ((datasz + AVALONMM_PKT_DATA_SIZE - 1) / AVALONMM_PKT_DATA_SIZE) ?: 1;\n\tuint8_t pkt[AVALONMM_PKT_SIZE] = {'A', 'V', cmd, 1, packets};\n\tuint16_t crc;\n\tssize_t r;\n\twhile (true)\n\t{\n\t\tsize_t copysz = AVALONMM_PKT_DATA_SIZE;\n\t\tif (datasz < copysz)\n\t\t{\n\t\t\tcopysz = datasz;\n\t\t\tmemset(&pkt[5 + copysz], '\\0', AVALONMM_PKT_DATA_SIZE - copysz);\n\t\t}\n\t\tif (copysz)\n\t\t\tmemcpy(&pkt[5], data, copysz);\n\t\tcrc = crc16xmodem(&pkt[5], AVALONMM_PKT_DATA_SIZE);\n\t\tpk_u16be(pkt, 5 + AVALONMM_PKT_DATA_SIZE, crc);\n\t\tr = write(fd, pkt, sizeof(pkt));\n\t\tif (opt_dev_protocol)\n\t\t{\n\t\t\tchar hex[(sizeof(pkt) * 2) + 1];\n\t\t\tbin2hex(hex, pkt, sizeof(pkt));\n\t\t\tapplog(LOG_DEBUG, \"DEVPROTO fd=%d SEND: %s => %d\", fd, hex, (int)r);\n\t\t}\n\t\tif (sizeof(pkt) != r)\n\t\t\treturn false;\n\t\tdatasz -= copysz;\n\t\tif (!datasz)\n\t\t\tbreak;\n\t\tdata += copysz;\n\t\t++pkt[3];\n\t}\n\treturn true;\n}\n\nstatic\nssize_t avalonmm_read(const int fd, const int logprio, enum avalonmm_reply *out_reply, void * const bufp, size_t bufsz)\n{\n\tuint8_t *buf = bufp;\n\tuint8_t pkt[AVALONMM_PKT_SIZE];\n\tuint8_t packets = 0, got = 0;\n\tuint16_t good_crc, actual_crc;\n\tssize_t r;\n\twhile (true)\n\t{\n\t\tr = serial_read(fd, pkt, sizeof(pkt));\n\t\tif (opt_dev_protocol)\n\t\t{\n\t\t\tif (r >= 0)\n\t\t\t{\n\t\t\t\tchar hex[(r * 2) + 1];\n\t\t\t\tbin2hex(hex, pkt, r);\n\t\t\t\tapplog(LOG_DEBUG, \"DEVPROTO fd=%d RECV: %s\", fd, hex);\n\t\t\t}\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"DEVPROTO fd=%d RECV (%d)\", fd, (int)r);\n\t\t}\n\t\tif (r != sizeof(pkt))\n\t\t\treturn -1;\n\t\tif (memcmp(pkt, \"AV\", 2))\n\t\t\tapplogr(-1, logprio, \"%s: bad header\", __func__);\n\t\tgood_crc = crc16xmodem(&pkt[5], AVALONMM_PKT_DATA_SIZE);\n\t\tactual_crc = upk_u16le(pkt, 5 + AVALONMM_PKT_DATA_SIZE);\n\t\tif (good_crc != actual_crc)\n\t\t\tapplogr(-1, logprio, \"%s: bad CRC (good=%04x actual=%04x)\", __func__, good_crc, actual_crc);\n\t\t*out_reply = pkt[2];\n\t\tif (!got)\n\t\t{\n\t\t\tif (pkt[3] != 1)\n\t\t\t\tapplogr(-1, logprio, \"%s: first packet is not index 1\", __func__);\n\t\t\t++got;\n\t\t\tpackets = pkt[4];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pkt[3] != ++got)\n\t\t\t\tapplogr(-1, logprio, \"%s: packet %d is not index %d\", __func__, got, got);\n\t\t\tif (pkt[4] != packets)\n\t\t\t\tapplogr(-1, logprio, \"%s: packet %d total packet count is %d rather than original value of %d\", __func__, got, pkt[4], packets);\n\t\t}\n\t\tif (bufsz)\n\t\t{\n\t\t\tif (likely(bufsz > AVALONMM_PKT_DATA_SIZE))\n\t\t\t{\n\t\t\t\tmemcpy(buf, &pkt[5], AVALONMM_PKT_DATA_SIZE);\n\t\t\t\tbufsz -= AVALONMM_PKT_DATA_SIZE;\n\t\t\t\tbuf += AVALONMM_PKT_DATA_SIZE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(buf, &pkt[5], bufsz);\n\t\t\t\tbufsz = 0;\n\t\t\t}\n\t\t}\n\t\tif (got == packets)\n\t\t\tbreak;\n\t}\n\treturn (((ssize_t)got) * AVALONMM_PKT_DATA_SIZE);\n}\n\nstruct avalonmm_init_data {\n\tint module_id;\n\tuint32_t mmversion;\n};\n\nstatic\nbool avalonmm_detect_one(const char * const devpath)\n{\n\tuint8_t buf[AVALONMM_PKT_DATA_SIZE] = {0};\n\tenum avalonmm_reply reply;\n\tconst int fd = serial_open(devpath, 115200, 1, true);\n\tstruct cgpu_info *prev_cgpu = NULL;\n\tif (fd == -1)\n\t\tapplogr(false, LOG_DEBUG, \"%s: Failed to open %s\", __func__, devpath);\n\t\n\tfor (int i = 0; i < AVALONMM_MAX_MODULES; ++i)\n\t{\n\t\tpk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4, i);\n\t\tavalonmm_write_cmd(fd, AMC_DETECT, buf, AVALONMM_PKT_DATA_SIZE);\n\t}\n\t\n\twhile (avalonmm_read(fd, LOG_DEBUG, &reply, buf, AVALONMM_PKT_DATA_SIZE) > 0)\n\t{\n\t\tif (reply != AMR_DETECT_ACK)\n\t\t\tcontinue;\n\t\t\n\t\tint moduleno = upk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4);\n\t\tuint32_t mmversion;\n\t\t{\n\t\t\tchar mmver[5];\n\t\t\tmemcpy(mmver, buf, 4);\n\t\t\tmmver[4] = '\\0';\n\t\t\tmmversion = atol(mmver);\n\t\t}\n\t\t\n\t\tif (!prev_cgpu)\n\t\t{\n\t\t\tif (serial_claim_v(devpath, &avalonmm_drv))\n\t\t\t{\n\t\t\t\tserial_close(fd);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstruct avalonmm_init_data * const initdata = malloc(sizeof(*initdata));\n\t\t*initdata = (struct avalonmm_init_data){\n\t\t\t.module_id = moduleno,\n\t\t\t.mmversion = mmversion,\n\t\t};\n\t\t\n\t\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t\t*cgpu = (struct cgpu_info){\n\t\t\t.drv = &avalonmm_drv,\n\t\t\t.device_path = prev_cgpu ? prev_cgpu->device_path : strdup(devpath),\n\t\t\t.device_data = initdata,\n\t\t\t.set_device_funcs = avalonmm_set_device_funcs,\n\t\t\t.deven = DEV_ENABLED,\n\t\t\t.procs = 1,\n\t\t\t.threads = prev_cgpu ? 0 : 1,\n\t\t};\n\t\t\n\t\tadd_cgpu_slave(cgpu, prev_cgpu);\n\t\tprev_cgpu = cgpu;\n\t}\n\t\n\tserial_close(fd);\n\t\n\treturn prev_cgpu;\n}\n\nstatic\nbool avalonmm_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, avalonmm_detect_one);\n}\n\nstruct avalonmm_job {\n\tstruct stratum_work swork;\n\tuint32_t jobid;\n\tstruct timeval tv_prepared;\n\tdouble nonce_diff;\n};\n\nstruct avalonmm_chain_state {\n\tuint32_t xnonce1;\n\tstruct avalonmm_job *jobs[AVALONMM_CACHED_JOBS];\n\tuint32_t next_jobid;\n\t\n\tuint32_t fan_desired;\n\tuint32_t clock_desired;\n\tuint32_t voltcfg_desired;\n};\n\nstruct avalonmm_module_state {\n\tuint32_t module_id;\n\tuint32_t mmversion;\n\tuint16_t temp[2];\n\tuint16_t fan[2];\n\tuint32_t clock_actual;\n\tuint32_t voltcfg_actual;\n};\n\nstatic\nuint16_t avalonmm_voltage_config_from_dmvolts(uint32_t dmvolts)\n{\n\treturn ((uint16_t)bitflip8((0x78 - dmvolts / 125) << 1 | 1)) << 8;\n}\n\n// Potentially lossy!\nstatic\nuint32_t avalonmm_dmvolts_from_voltage_config(uint32_t voltcfg)\n{\n\treturn (0x78 - (bitflip8(voltcfg >> 8) >> 1)) * 125;\n}\n\nstatic\nuint32_t avalonmm_fan_config_from_percent(uint8_t percent)\n{\n\treturn (0x3ff - percent * 0x3ff / 100);\n}\n\nstatic\nuint8_t avalonmm_fan_percent_from_config(uint32_t cfg)\n{\n\treturn (0x3ff - cfg) * 100 / 0x3ff;\n}\n\nstatic struct cgpu_info *avalonmm_dev_for_module_id(struct cgpu_info *, uint32_t);\nstatic bool avalonmm_poll_once(struct cgpu_info *, int64_t *);\n\nstatic\nbool avalonmm_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const master_dev = master_thr->cgpu, *dev = NULL;\n\tstruct avalonmm_init_data * const master_initdata = master_dev->device_data;\n\tconst char * const devpath = master_dev->device_path;\n\tconst int fd = serial_open(devpath, 115200, 1, true);\n\tuint8_t buf[AVALONMM_PKT_DATA_SIZE] = {0};\n\tint64_t module_id;\n\t\n\tmaster_dev->device_fd = fd;\n\tif (unlikely(fd == -1))\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to initialise\", master_dev->dev_repr);\n\t\n\tstruct avalonmm_chain_state * const chain = malloc(sizeof(*chain));\n\t*chain = (struct avalonmm_chain_state){\n\t\t.fan_desired = avalonmm_fan_config_from_percent(90),\n\t};\n\t\n\tswitch (master_initdata->mmversion)\n\t{\n\t\tcase 2014:\n\t\t\tchain->voltcfg_desired = avalonmm_voltage_config_from_dmvolts(10000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchain->voltcfg_desired = avalonmm_voltage_config_from_dmvolts(6625);\n\t}\n\t\n\twork2d_init();\n\tif (!reserve_work2d_(&chain->xnonce1))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to reserve 2D work\", master_dev->dev_repr);\n\t\tfree(chain);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\t\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tif (dev == proc->device)\n\t\t\tcontinue;\n\t\tdev = proc->device;\n\t\t\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct avalonmm_init_data * const initdata = dev->device_data;\n\t\t\n\t\tstruct avalonmm_module_state * const module = malloc(sizeof(*module));\n\t\t*module = (struct avalonmm_module_state){\n\t\t\t.module_id = initdata->module_id,\n\t\t\t.mmversion = initdata->mmversion,\n\t\t};\n\t\t\n\t\tfree(initdata);\n\t\tproc->device_data = chain;\n\t\tthr->cgpu_data = module;\n\t}\n\t\n\tdev = NULL;\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tcgpu_set_defaults(proc);\n\t\tproc->status = LIFE_INIT2;\n\t}\n\t\n\tif (!chain->clock_desired)\n\t{\n\t\t// Get a reasonable default frequency\n\t\tdev = master_dev;\n\t\tstruct thr_info * const thr = dev->thr[0];\n\t\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\t\t\nresend:\n\t\tpk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4, module->module_id);\n\t\tavalonmm_write_cmd(fd, AMC_POLL, buf, AVALONMM_PKT_DATA_SIZE);\n\t\t\n\t\twhile (avalonmm_poll_once(master_dev, &module_id))\n\t\t{\n\t\t\tif (module_id != module->module_id)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (module->clock_actual)\n\t\t\t{\n\t\t\t\tchain->clock_desired = module->clock_actual;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto resend;\n\t\t}\n\t\t\n\t\tif (!chain->clock_desired)\n\t\t{\n\t\t\tswitch (module->mmversion)\n\t\t\t{\n\t\t\t\tcase 2014:\n\t\t\t\t\tchain->clock_desired = 1500;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3314:\n\t\t\t\t\tchain->clock_desired = 450;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (likely(chain->clock_desired))\n\t\tapplog(LOG_DEBUG, \"%s: Frequency is initialised with %d MHz\", master_dev->dev_repr, chain->clock_desired);\n\telse\n\t\tapplogr(false, LOG_ERR, \"%s: No frequency detected, please use --set %s@%s:clock=MHZ\", master_dev->dev_repr, master_dev->drv->dname, devpath);\n\t\n\treturn true;\n}\n\nstatic\nbool avalonmm_send_swork(const int fd, struct avalonmm_chain_state * const chain, const struct stratum_work * const swork, uint32_t jobid, double *out_nonce_diff)\n{\n\tuint8_t buf[AVALONMM_PKT_DATA_SIZE];\n\tbytes_t coinbase = BYTES_INIT;\n\t\n\tint coinbase_len = bytes_len(&swork->coinbase);\n\tif (coinbase_len > AVALONMM_MAX_COINBASE_SIZE)\n\t\treturn false;\n\t\n\tif (swork->merkles > AVALONMM_MAX_MERKLES)\n\t\treturn false;\n\t\n\tpk_u32be(buf,    0, coinbase_len);\n\t\n\tconst size_t xnonce2_offset = swork->nonce2_offset + work2d_pad_xnonce_size(swork) + work2d_xnonce1sz;\n\tpk_u32be(buf,    4, xnonce2_offset);\n\t\n\tpk_u32be(buf,    8, 4);  // extranonce2 size, but only 4 is supported - smaller sizes are handled by limiting the range\n\tpk_u32be(buf, 0x0c, 0x24);  // merkle_offset, always 0x24 for Bitcoin\n\tpk_u32be(buf, 0x10, swork->merkles);\n\tpk_u32be(buf, 0x14, 1);  // diff? poorly defined\n\tpk_u32be(buf, 0x18, 0);  // pool number - none of its business\n\tif (!avalonmm_write_cmd(fd, AMC_NEW_JOB, buf, 0x1c))\n\t\treturn false;\n\t\n\tdouble nonce_diff = target_diff(swork->target);\n\tif (nonce_diff >= AVALONMM_MAX_NONCE_DIFF)\n\t\tset_target_to_pdiff(buf, nonce_diff = AVALONMM_MAX_NONCE_DIFF);\n\telse\n\t\tmemcpy(buf, swork->target, 0x20);\n\t*out_nonce_diff = nonce_diff;\n\tif (!avalonmm_write_cmd(fd, AMC_TARGET, buf, 0x20))\n\t\treturn false;\n\t\n\tpk_u32be(buf, 0, jobid);\n\tif (!avalonmm_write_cmd(fd, AMC_JOB_ID, buf, 4))\n\t\treturn false;\n\t\n\t// Need to add extranonce padding and extranonce2\n\tbytes_cpy(&coinbase, &swork->coinbase);\n\tuint8_t *cbp = bytes_buf(&coinbase);\n\tcbp += swork->nonce2_offset;\n\twork2d_pad_xnonce(cbp, swork, false);\n\tcbp += work2d_pad_xnonce_size(swork);\n\tmemcpy(cbp, &chain->xnonce1, work2d_xnonce1sz);\n\tcbp += work2d_xnonce1sz;\n\tif (!avalonmm_write_cmd(fd, AMC_COINBASE, bytes_buf(&coinbase), bytes_len(&coinbase)))\n\t\treturn false;\n\t\n\tif (!avalonmm_write_cmd(fd, AMC_MERKLES, bytes_buf(&swork->merkle_bin), bytes_len(&swork->merkle_bin)))\n\t\treturn false;\n\t\n\tuint8_t header_bin[0x80];\n\tmemcpy(&header_bin[   0], swork->header1, 0x24);\n\tmemset(&header_bin[0x24], '\\0', 0x20);  // merkle root\n\tpk_u32be(header_bin, 0x44, swork->ntime);\n\tmemcpy(&header_bin[0x48], swork->diffbits, 4);\n\tmemset(&header_bin[0x4c], '\\0', 4);  // nonce\n\tmemcpy(&header_bin[0x50], bfg_workpadding_bin, 0x30);\n\tif (!avalonmm_write_cmd(fd, AMC_BLKHDR, header_bin, sizeof(header_bin)))\n\t\treturn false;\n\t\n\t// Avalon MM cannot handle xnonce2_size other than 4, and works in big endian, so we use a range to ensure the following bytes match\n\tconst int fixed_mm_xnonce2_bytes = (work2d_xnonce2sz >= 4) ? 0 : (4 - work2d_xnonce2sz);\n\tuint8_t mm_xnonce2_start[4];\n\tuint32_t xnonce2_range;\n\tmemset(mm_xnonce2_start, '\\0', 4);\n\tcbp += work2d_xnonce2sz;\n\tfor (int i = 1; i <= fixed_mm_xnonce2_bytes; ++i)\n\t\tmm_xnonce2_start[fixed_mm_xnonce2_bytes - i] = cbp++[0];\n\tif (fixed_mm_xnonce2_bytes > 0)\n\t\txnonce2_range = (1 << (8 * work2d_xnonce2sz)) - 1;\n\telse\n\t\txnonce2_range = 0xffffffff;\n\t\n\tpk_u32be(buf, 0, chain->fan_desired);\n\tpk_u32be(buf, 4, chain->voltcfg_desired);\n\tpk_u32be(buf, 8, chain->clock_desired);\n\tmemcpy(&buf[0xc], mm_xnonce2_start, 4);\n\tpk_u32be(buf, 0x10, xnonce2_range);\n\tif (!avalonmm_write_cmd(fd, AMC_START, buf, 0x14))\n\t\treturn false;\n\t\n\treturn true;\n}\n\nstatic\nvoid avalonmm_free_job(struct avalonmm_job * const mmjob)\n{\n\tstratum_work_clean(&mmjob->swork);\n\tfree(mmjob);\n}\n\nstatic\nbool avalonmm_update_swork_from_pool(struct cgpu_info * const master_dev, struct pool * const pool)\n{\n\tstruct avalonmm_chain_state * const chain = master_dev->device_data;\n\tconst int fd = master_dev->device_fd;\n\tstruct avalonmm_job *mmjob = malloc(sizeof(*mmjob));\n\t*mmjob = (struct avalonmm_job){\n\t\t.jobid = chain->next_jobid,\n\t};\n\tcg_rlock(&pool->data_lock);\n\tstratum_work_cpy(&mmjob->swork, &pool->swork);\n\tcg_runlock(&pool->data_lock);\n\ttimer_set_now(&mmjob->tv_prepared);\n\tif (!avalonmm_send_swork(fd, chain, &mmjob->swork, mmjob->jobid, &mmjob->nonce_diff))\n\t{\n\t\tavalonmm_free_job(mmjob);\n\t\treturn false;\n\t}\n\tapplog(LOG_DEBUG, \"%s: Upload of job id %08lx complete\", master_dev->dev_repr, (unsigned long)mmjob->jobid);\n\t++chain->next_jobid;\n\t\n\tstruct avalonmm_job **jobentry = &chain->jobs[mmjob->jobid % AVALONMM_CACHED_JOBS];\n\tif (*jobentry)\n\t\tavalonmm_free_job(*jobentry);\n\t*jobentry = mmjob;\n\t\n\treturn true;\n}\n\nstatic\nstruct cgpu_info *avalonmm_dev_for_module_id(struct cgpu_info * const master_dev, const uint32_t module_id)\n{\n\tstruct cgpu_info *dev = NULL;\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tif (dev == proc->device)\n\t\t\tcontinue;\n\t\tdev = proc->device;\n\t\t\n\t\tstruct thr_info * const thr = dev->thr[0];\n\t\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\t\t\n\t\tif (module->module_id == module_id)\n\t\t\treturn dev;\n\t}\n\treturn NULL;\n}\n\nstatic\nbool avalonmm_poll_once(struct cgpu_info * const master_dev, int64_t *out_module_id)\n{\n\tstruct avalonmm_chain_state * const chain = master_dev->device_data;\n\tconst int fd = master_dev->device_fd;\n\tuint8_t buf[AVALONMM_PKT_DATA_SIZE];\n\tenum avalonmm_reply reply;\n\t\n\t*out_module_id = -1;\n\t\n\tif (avalonmm_read(fd, LOG_ERR, &reply, buf, sizeof(buf)) < 0)\n\t\treturn false;\n\t\n\tswitch (reply)\n\t{\n\t\tcase AMR_DETECT_ACK:\n\t\t\tbreak;\n\t\t\n\t\tcase AMR_STATUS:\n\t\t{\n\t\t\tconst uint32_t module_id = upk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4);\n\t\t\tstruct cgpu_info * const dev = avalonmm_dev_for_module_id(master_dev, module_id);\n\t\t\t\n\t\t\tif (unlikely(!dev))\n\t\t\t{\n\t\t\t\tstruct thr_info * const master_thr = master_dev->thr[0];\n\t\t\t\tapplog(LOG_ERR, \"%s: %s for unknown module id %lu\", master_dev->dev_repr, \"Status\", (unsigned long)module_id);\n\t\t\t\tinc_hw_errors_only(master_thr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t*out_module_id = module_id;\n\t\t\t\n\t\t\tstruct thr_info * const thr = dev->thr[0];\n\t\t\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\t\t\t\n\t\t\tmodule->temp[0] = upk_u16be(buf,    0);\n\t\t\tmodule->temp[1] = upk_u16be(buf,    2);\n\t\t\tmodule->fan [0] = upk_u16be(buf,    4);\n\t\t\tmodule->fan [1] = upk_u16be(buf,    6);\n\t\t\tmodule->clock_actual = upk_u32be(buf, 8);\n\t\t\tmodule->voltcfg_actual = upk_u32be(buf, 0x0c);\n\t\t\t\n\t\t\tdev->temp = max(module->temp[0], module->temp[1]);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase AMR_NONCE:\n\t\t{\n\t\t\tconst int fixed_mm_xnonce2_bytes = (work2d_xnonce2sz >= 4) ? 0 : (4 - work2d_xnonce2sz);\n\t\t\tconst uint8_t * const backward_xnonce2 = &buf[8 + fixed_mm_xnonce2_bytes];\n\t\t\tconst uint32_t nonce = upk_u32be(buf, 0x10) - AVALONMM_NONCE_OFFSET;\n\t\t\tconst uint32_t jobid = upk_u32be(buf, 0x14);\n\t\t\tconst uint32_t module_id = upk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4);\n\t\t\tstruct cgpu_info * const dev = avalonmm_dev_for_module_id(master_dev, module_id);\n\t\t\t\n\t\t\tif (unlikely(!dev))\n\t\t\t{\n\t\t\t\tstruct thr_info * const master_thr = master_dev->thr[0];\n\t\t\t\tapplog(LOG_ERR, \"%s: %s for unknown module id %lu\", master_dev->dev_repr, \"Nonce\", (unsigned long)module_id);\n\t\t\t\tinc_hw_errors_only(master_thr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t*out_module_id = module_id;\n\t\t\t\n\t\t\tstruct thr_info * const thr = dev->thr[0];\n\t\t\t\n\t\t\tbool invalid_jobid = false;\n\t\t\tif (unlikely((uint32_t)(chain->next_jobid - AVALONMM_CACHED_JOBS) > chain->next_jobid))\n\t\t\t\t// Jobs wrap around\n\t\t\t\tinvalid_jobid = (jobid < chain->next_jobid - AVALONMM_CACHED_JOBS && jobid >= chain->next_jobid);\n\t\t\telse\n\t\t\t\tinvalid_jobid = (jobid < chain->next_jobid - AVALONMM_CACHED_JOBS || jobid >= chain->next_jobid);\n\t\t\tstruct avalonmm_job * const mmjob = chain->jobs[jobid % AVALONMM_CACHED_JOBS];\n\t\t\tif (unlikely(invalid_jobid || !mmjob))\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%s: Bad job id %08lx\", dev->dev_repr, (unsigned long)jobid);\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tuint8_t xnonce2[work2d_xnonce2sz];\n\t\t\tfor (int i = 0; i < work2d_xnonce2sz; ++i)\n\t\t\t\txnonce2[i] = backward_xnonce2[(work2d_xnonce2sz - 1) - i];\n\t\t\t\n\t\t\twork2d_submit_nonce(thr, &mmjob->swork, &mmjob->tv_prepared, xnonce2, chain->xnonce1, nonce, mmjob->swork.ntime, NULL, mmjob->nonce_diff);\n\t\t\thashes_done2(thr, mmjob->nonce_diff * 0x100000000, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nstatic\nvoid avalonmm_poll(struct cgpu_info * const master_dev, int n)\n{\n\tint64_t dummy;\n\twhile (n > 0)\n\t{\n\t\tif (avalonmm_poll_once(master_dev, &dummy))\n\t\t\t--n;\n\t}\n}\n\nstatic\nstruct thr_info *avalonmm_should_disable(struct cgpu_info * const master_dev)\n{\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tif (thr->pause || proc->deven != DEV_ENABLED)\n\t\t\treturn thr;\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid avalonmm_minerloop(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const master_dev = master_thr->cgpu;\n\tconst int fd = master_dev->device_fd;\n\tstruct pool *nextpool = current_pool(), *pool = NULL;\n\tuint8_t buf[AVALONMM_PKT_DATA_SIZE] = {0};\n\t\n\twhile (likely(!master_dev->shutdown))\n\t{\n\t\tif (avalonmm_should_disable(master_dev))\n\t\t{\n\t\t\tstruct thr_info *thr;\n\t\t\twhile ( (thr = avalonmm_should_disable(master_dev)) )\n\t\t\t{\n\t\t\t\tif (!thr->_mt_disable_called)\n\t\t\t\t\tif (avalonmm_write_cmd(fd, AMC_NEW_JOB, NULL, 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tfor_each_managed_proc(proc, master_dev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\t\t\t\tmt_disable_start(thr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tnotifier_read(thr->notifier);\n\t\t\t}\n\t\t\tfor_each_managed_proc(proc, master_dev)\n\t\t\t{\n\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\tmt_disable_finish(thr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmaster_thr->work_restart = false;\n\t\tif (!pool_has_usable_swork(nextpool))\n\t\t\t; // FIXME\n\t\telse\n\t\tif (avalonmm_update_swork_from_pool(master_dev, nextpool))\n\t\t\tpool = nextpool;\n\t\t\n\t\twhile (likely(!(master_thr->work_restart || ((nextpool = current_pool()) != pool && pool_has_usable_swork(nextpool)) || avalonmm_should_disable(master_dev))))\n\t\t{\n\t\t\tcgsleep_ms(10);\n\t\t\t\n\t\t\tstruct cgpu_info *dev = NULL;\n\t\t\tfor_each_managed_proc(proc, master_dev)\n\t\t\t{\n\t\t\t\tif (dev == proc->device)\n\t\t\t\t\tcontinue;\n\t\t\t\tdev = proc->device;\n\t\t\t\t\n\t\t\t\tstruct thr_info * const thr = dev->thr[0];\n\t\t\t\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\t\t\t\t\n\t\t\t\tpk_u32be(buf, AVALONMM_PKT_DATA_SIZE - 4, module->module_id);\n\t\t\t\t\n\t\t\t\tavalonmm_write_cmd(fd, AMC_POLL, buf, AVALONMM_PKT_DATA_SIZE);\n\t\t\t\tavalonmm_poll(master_dev, 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic\nconst char *avalonmm_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\t\n\tconst int nv = atoi(newvalue);\n\tif (nv < 0)\n\t\treturn \"Invalid clock\";\n\t\n\tchain->clock_desired = nv;\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *avalonmm_set_fan(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\t\n\tconst int nv = atoi(newvalue);\n\tif (nv < 0 || nv > 100)\n\t\treturn \"Invalid fan speed\";\n\t\n\tchain->fan_desired = avalonmm_fan_config_from_percent(nv);\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *avalonmm_set_voltage(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\t\n\tconst long val = atof(newvalue) * 10000;\n\tif (val < 0 || val > 15000)\n\t\treturn \"Invalid voltage value\";\n\t\n\tchain->voltcfg_desired = avalonmm_voltage_config_from_dmvolts(val);\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition avalonmm_set_device_funcs[] = {\n\t{\"clock\", avalonmm_set_clock, \"clock frequency\"},\n\t{\"fan\", avalonmm_set_fan, \"fan speed (0-100 percent)\"},\n\t{\"voltage\", avalonmm_set_voltage, \"voltage (0 to 1.5 volts)\"},\n\t{NULL},\n};\n\nstatic\nstruct api_data *avalonmm_api_extra_device_detail(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\tstruct thr_info * const thr = dev->thr[0];\n\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\t\n\troot = api_add_uint32(root, \"Module Id\", &module->module_id, false);\n\troot = api_add_uint32(root, \"ExtraNonce1\", &chain->xnonce1, false);\n\t\n\treturn root;\n}\n\nstatic\nstruct api_data *avalonmm_api_extra_device_status(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\tstruct thr_info * const thr = dev->thr[0];\n\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\tchar buf[0x10];\n\t\n\tstrcpy(buf, \"Temperature\");\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tif (module->temp[i])\n\t\t{\n\t\t\tfloat temp = module->temp[i];\n\t\t\tbuf[0xb] = '0' + i;\n\t\t\troot = api_add_temp(root, buf, &temp, true);\n\t\t}\n\t}\n\t\n\t{\n\t\tuint8_t fan_percent = avalonmm_fan_percent_from_config(chain->fan_desired);\n\t\troot = api_add_uint8(root, \"Fan Percent\", &fan_percent, true);\n\t}\n\t\n\tstrcpy(buf, \"Fan RPM \");\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tif (module->fan[i])\n\t\t{\n\t\t\tbuf[8] = '0' + i;\n\t\t\troot = api_add_uint16(root, buf, &module->fan[i], false);\n\t\t}\n\t}\n\t\n\tif (module->clock_actual)\n\t{\n\t\tdouble freq = module->clock_actual;\n\t\troot = api_add_freq(root, \"Frequency\", &freq, true);\n\t}\n\t\n\tif (module->voltcfg_actual)\n\t{\n\t\tfloat volts = avalonmm_dmvolts_from_voltage_config(module->voltcfg_actual);\n\t\tvolts /= 10000;\n\t\troot = api_add_volts(root, \"Voltage\", &volts, true);\n\t}\n\t\n\treturn root;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid avalonmm_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct avalonmm_chain_state * const chain = dev->device_data;\n\tstruct thr_info * const thr = dev->thr[0];\n\tstruct avalonmm_module_state * const module = thr->cgpu_data;\n\t\n\twlogprint(\"ExtraNonce1:%0*lx  ModuleId:%lu\\n\", work2d_xnonce1sz * 2, (unsigned long)chain->xnonce1, (unsigned long)module->module_id);\n\t\n\tif (module->temp[0] && module->temp[1])\n\t{\n\t\twlogprint(\"Temperatures: %uC %uC\", (unsigned)module->temp[0], (unsigned)module->temp[1]);\n\t\tif (module->fan[0] || module->fan[1])\n\t\t\twlogprint(\"  \");\n\t}\n\tunsigned fan_percent = avalonmm_fan_percent_from_config(chain->fan_desired);\n\tif (module->fan[0])\n\t{\n\t\tif (module->fan[1])\n\t\t\twlogprint(\"Fans: %u RPM, %u RPM (%u%%)\", (unsigned)module->fan[0], (unsigned)module->fan[1], fan_percent);\n\t\telse\n\t\t\twlogprint(\"Fan: %u RPM (%u%%)\", (unsigned)module->fan[0], fan_percent);\n\t}\n\telse\n\tif (module->fan[1])\n\t\twlogprint(\"Fan: %u RPM (%u%%)\", (unsigned)module->fan[1], fan_percent);\n\telse\n\t\twlogprint(\"Fan: %u%%\", fan_percent);\n\twlogprint(\"\\n\");\n\t\n\tif (module->clock_actual)\n\t\twlogprint(\"Clock speed: %lu\\n\", (unsigned long)module->clock_actual);\n\t\n\tif (module->voltcfg_actual)\n\t{\n\t\tconst uint32_t dmvolts = avalonmm_dmvolts_from_voltage_config(module->voltcfg_actual);\n\t\twlogprint(\"Voltage: %u.%04u V\\n\", (unsigned)(dmvolts / 10000), (unsigned)(dmvolts % 10000));\n\t}\n}\n\nstatic\nvoid avalonmm_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n\twlogprint(\"[F]an speed \");\n\twlogprint(\"[V]oltage \");\n}\n\n#define avalonmm_tui_wrapper(proc, func, prompt) \\\n\tproc_set_device_tui_wrapper(proc, NULL, func, prompt, NULL)\n\nstatic\nconst char *avalonmm_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t\treturn avalonmm_tui_wrapper(proc, avalonmm_set_clock  , \"Set clock speed (Avalon2: 1500; Avalon3: 450)\");\n\t\t\n\t\tcase 'f': case 'F':\n\t\t\treturn avalonmm_tui_wrapper(proc, avalonmm_set_fan    , \"Set fan speed (0-100 percent)\");\n\t\t\n\t\tcase 'v': case 'V':\n\t\t\treturn avalonmm_tui_wrapper(proc, avalonmm_set_voltage, \"Set voltage (Avalon2: 1.0; Avalon3: 0.6625)\");\n\t}\n\treturn NULL;\n}\n#endif\n\nstruct device_drv avalonmm_drv = {\n\t.dname = \"avalonmm\",\n\t.name = \"AVM\",\n\t\n\t.lowl_probe = avalonmm_lowl_probe,\n\t\n\t.thread_init = avalonmm_init,\n\t.minerloop = avalonmm_minerloop,\n\t\n\t.get_api_extra_device_detail = avalonmm_api_extra_device_detail,\n\t.get_api_extra_device_status = avalonmm_api_extra_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = avalonmm_wlogprint_status,\n\t.proc_tui_wlogprint_choices = avalonmm_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = avalonmm_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-bfsb.c",
          "type": "blob",
          "size": 4.7783203125,
          "content": "/*\n * Copyright 2013 bitfury\n * Copyright 2013 Anatoly Legkodymov\n * Copyright 2013 Luke Dashjr\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n\n#include \"deviceapi.h\"\n#include \"libbitfury.h\"\n#include \"driver-bitfury.h\"\n#include \"lowl-spi.h\"\n\nBFG_REGISTER_DRIVER(bfsb_drv)\n\nstatic\nbool bfsb_spi_txrx(struct spi_port *port)\n{\n\tstruct cgpu_info * const proc = port->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tspi_bfsb_select_bank(bitfury->slot);\n\tconst bool rv = sys_spi_txrx(port);\n\n\treturn rv;\n}\n\nstatic\nint bfsb_autodetect()\n{\n\tRUNONCE(0);\n\t\n\tstruct cgpu_info *cgpu = NULL, *proc1 = NULL, *prev_cgpu = NULL;\n\tint proc_count = 0;\n\t\n\tapplog(LOG_INFO, \"INFO: bitfury_detect\");\n\tspi_init();\n\tif (!sys_spi)\n\t\treturn 0;\n\t\n\t\n\tstruct bitfury_device **devicelist, *bitfury;\n\tstruct spi_port *port;\n\tint i, j;\n\tstruct bitfury_device dummy_bitfury;\n\tstruct cgpu_info dummy_cgpu;\n\n\tdummy_cgpu.device_data = &dummy_bitfury;\n\t\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t\tint chip_n;\n\t\t\t\n\t\t\tport = malloc(sizeof(*port));\n\t\t\t*port = *sys_spi;\n\t\t\tport->cgpu = &dummy_cgpu;\n\t\t\tport->txrx = bfsb_spi_txrx;\n\t\t\tport->speed = 625000;\n\t\t\tdummy_bitfury.slot = i;\n\t\t\t\n\t\t\tchip_n = libbitfury_detectChips1(port);\n\t\t\tif (chip_n)\n\t\t\t{\n\t\t\t\tapplog(LOG_WARNING, \"BITFURY slot %d: %d chips detected\", i, chip_n);\n\t\t\t\t\n\t\t\t\tdevicelist = malloc(sizeof(*devicelist) * chip_n);\n\t\t\t\tfor (j = 0; j < chip_n; ++j)\n\t\t\t\t{\n\t\t\t\t\tdevicelist[j] = bitfury = malloc(sizeof(*bitfury));\n\t\t\t\t\t*bitfury = (struct bitfury_device){\n\t\t\t\t\t\t.spi = port,\n\t\t\t\t\t\t.slot = i,\n\t\t\t\t\t\t.fasync = j,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcgpu = malloc(sizeof(*cgpu));\n\t\t\t\t*cgpu = (struct cgpu_info){\n\t\t\t\t\t.drv = &bfsb_drv,\n\t\t\t\t\t.set_device_funcs = bitfury_set_device_funcs,\n\t\t\t\t\t.procs = chip_n,\n\t\t\t\t\t.device_data = devicelist,\n\t\t\t\t};\n\t\t\t\tadd_cgpu_slave(cgpu, prev_cgpu);\n\t\t\t\t\n\t\t\t\tproc_count += chip_n;\n\t\t\t\tif (!proc1)\n\t\t\t\t\tproc1 = cgpu;\n\t\t\t\tprev_cgpu = cgpu;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(port);\n\t}\n\t\n\tif (proc1)\n\t\tproc1->threads = 1;\n\t\n\treturn proc_count;\n}\n\nstatic void bfsb_detect(void)\n{\n\tnoserial_detect_manual(&bfsb_drv, bfsb_autodetect);\n}\n\nstatic\nbool bfsb_init(struct thr_info *thr)\n{\n\tstruct bitfury_device **devicelist;\n\tstruct cgpu_info *proc;\n\tstruct bitfury_device *bitfury;\n\t\n\tfor (proc = thr->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tdevicelist = proc->device_data;\n\t\tbitfury = devicelist[proc->proc_id];\n\t\tproc->device_data = bitfury;\n\t\tbitfury->spi->cgpu = proc;\n\t\tbitfury_init_chip(proc);\n\t\tbitfury->osc6_bits = 53;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);\n\t\t\n\t\tif (proc->proc_id == proc->procs - 1)\n\t\t\tfree(devicelist);\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\t\n\treturn true;\n}\n\nstatic void bfsb_shutdown(struct thr_info *thr)\n{\n\tbitfury_shutdown(thr);\n\tspi_bfsb_select_bank(-1);\n}\n\nstatic struct api_data *bfsb_api_device_detail(struct cgpu_info *cgpu)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct api_data *root = bitfury_api_device_detail(cgpu);\n\t\n\troot = api_add_uint(root, \"Slot\", &(bitfury->slot), false);\n\t\n\treturn root;\n}\n\nstruct device_drv bfsb_drv = {\n\t.dname = \"bfsb\",\n\t.name = \"BSB\",\n\t.drv_detect = bfsb_detect,\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.thread_init = bfsb_init,\n\t.poll = bitfury_do_io,\n\t.job_start = bitfury_noop_job_start,\n\t.job_process_results = bitfury_job_process_results,\n\t.get_api_extra_device_detail = bfsb_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t.thread_disable = bitfury_disable,\n\t.thread_enable = bitfury_enable,\n\t.thread_shutdown = bfsb_shutdown,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-bfx.c",
          "type": "blob",
          "size": 7.578125,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-ftdi.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#define BFX_ADBUS_DIRECTIONS  0xfb\n#define BFX_ACBUS_DIRECTIONS  0xff\n\nBFG_REGISTER_DRIVER(bfx_drv)\nstatic const struct bfg_set_device_definition bfx_set_device_funcs[];\n\nstruct bfx_state {\n\tstruct lowlevel_device_info *lowl_info;\n\tstruct ft232r_device_handle *ftdi;\n};\n\nstatic\nstruct ft232r_device_handle *bfx_open(const struct lowlevel_device_info * const info)\n{\n\tstruct ft232r_device_handle * const ftdi = ft232h_open_mpsse(info);\n\tif (!ftdi)\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to open\", __func__);\n\tif (!ft232h_mpsse_set_adbus(ftdi, 8, BFX_ADBUS_DIRECTIONS))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to set A%cBUS pins\", __func__, 'D');\n\t\tgoto err;\n\t}\n\tif (!ft232h_mpsse_set_acbus(ftdi, 0, BFX_ACBUS_DIRECTIONS))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to set A%cBUS pins\", __func__, 'C');\n\t\tgoto err;\n\t}\n\tif (!ft232r_purge_buffers(ftdi, FTDI_PURGE_BOTH))\n\t\tapplog(LOG_WARNING, \"%s: Failed to purge buffers\", __func__);\n\t\n\treturn ftdi;\n\nerr:\n\tft232h_mpsse_set_adbus(ftdi, 0, 0);\n\tft232h_mpsse_set_acbus(ftdi, 0, 0);\n\tft232r_close(ftdi);\n\treturn NULL;\n}\n\nstatic\nvoid bfx_device_off(struct ft232r_device_handle * const ftdi)\n{\n\t// Try to reset everything back to input\n\tft232h_mpsse_set_adbus(ftdi, 0, 0);\n\tft232h_mpsse_set_acbus(ftdi, 0, 0);\n}\n\nstatic\nbool bfx_set_cs(struct ft232r_device_handle * const ftdi, bool high)\n{\n\tconst uint8_t val = high ? 8 : 0;\n\treturn ft232h_mpsse_set_adbus(ftdi, val, BFX_ADBUS_DIRECTIONS);\n}\n\nstatic\nbool bfx_spi_reset(struct ft232r_device_handle * const ftdi)\n{\n\tuint8_t buf[0x10] = { 0xff };\n\tfor (int i = 1; i < sizeof(buf); ++i)\n\t\tbuf[i] = ~buf[i - 1];\n\t\n\tbfx_set_cs(ftdi, true);\n\tft232r_write_all(ftdi, buf, sizeof(buf));\n\tbfx_set_cs(ftdi, false);\n\tft232r_purge_buffers(ftdi, FTDI_PURGE_BOTH);\n\t\n\treturn true;\n}\n\nstatic\nbool bfx_spi_txrx(struct spi_port * const port)\n{\n\tstruct cgpu_info * const cgpu = port->cgpu;\n\tstruct bfx_state * const state = port->userp;\n\tstruct ft232r_device_handle * const ftdi = state->ftdi;\n\tconst void *wrbuf = spi_gettxbuf(port);\n\tvoid *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\t\n\tbfx_spi_reset(ftdi);\n\tif (ft232h_mpsse_readwrite_all(ftdi, rdbuf, wrbuf, bufsz) != bufsz)\n\t\tgoto err;\n\t\n\treturn true;\n\nerr:\n\tbfx_device_off(ftdi);\n\tif (cgpu)\n\t{\n\t\tstruct thr_info * const thr = cgpu->thr[0];\n\t\thashes_done2(thr, -1, NULL);\n\t}\n\treturn false;\n}\n\nstatic\nbool bfx_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tconst char * const product = info->product;\n\tconst char * const serial = info->serial;\n\tstruct ft232r_device_handle *ftdi;\n\tstruct spi_port *port;\n\tstruct bfx_state *state;\n\tint chips;\n\t\n\tif (info->lowl != &lowl_ft232r)\n\t{\n\t\tif (info->lowl != &lowl_usb)\n\t\t\tapplog(LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not ft232r!\",\n\t\t\t       __func__, product, serial);\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\treturn false;\n\t}\n\t\n\tftdi = bfx_open(info);\n\tif (!ftdi)\n\t\treturn false;\n\t\n\tstate = malloc(sizeof(*state));\n\t*state = (struct bfx_state){\n\t\t.ftdi = ftdi,\n\t};\n\tport = calloc(1, sizeof(*port));\n\tport->userp = state;\n\tport->txrx = bfx_spi_txrx;\n\tport->repr = bfx_drv.dname;\n\tport->logprio = LOG_DEBUG;\n\t\n\t{\n\t\tstruct bitfury_device dummy_bitfury = {\n\t\t\t.spi = port,\n\t\t};\n\t\tdrv_set_defaults(&bfx_drv, bitfury_set_device_funcs_probe, &dummy_bitfury, NULL, NULL, 1);\n\t}\n\t\n\tchips = libbitfury_detectChips1(port);\n\tfree(port);\n\t\n\tbfx_device_off(ftdi);\n\tft232r_close(ftdi);\n\t\n\tif (!chips)\n\t{\n\t\tfree(state);\n\t\tapplog(LOG_DEBUG, \"%s: 0 chips detected\", __func__);\n\t\treturn false;\n\t}\n\t\n\tif (lowlevel_claim(&bfx_drv, true, info))\n\t{\n\t\tfree(state);\n\t\treturn false;\n\t}\n\t\n\tstate->lowl_info = lowlevel_ref(info);\n\t\n\tstruct cgpu_info *cgpu;\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &bfx_drv,\n\t\t.set_device_funcs = bfx_set_device_funcs,\n\t\t.device_data = state,\n\t\t.threads = 1,\n\t\t.procs = chips,\n\t\t// TODO: .name\n\t\t.dev_manufacturer = maybe_strdup(info->manufacturer),\n\t\t.dev_product = maybe_strdup(product),\n\t\t.dev_serial = maybe_strdup(serial),\n\t\t.deven = DEV_ENABLED,\n\t\t// TODO: .cutofftemp\n\t};\n\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nbool bfx_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct bfx_state * const state = cgpu->device_data;\n\tstruct lowlevel_device_info * const info = state->lowl_info;\n\tstruct spi_port *port;\n\tstruct bitfury_device *bitfury;\n\tstruct ft232r_device_handle *ftdi;\n\t\n\tftdi = bfx_open(info);\n\tlowlevel_devinfo_free(info);\n\tif (!ftdi)\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to open ft232r device\", cgpu->proc_repr);\n\t\treturn false;\n\t}\n\t\n\tport = malloc(sizeof(*port));\n\tbitfury = malloc(sizeof(*bitfury) * cgpu->procs);\n\t\n\tif (!(port && bitfury && state))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to allocate structures\", cgpu->proc_repr);\n\t\tfree(port);\n\t\tfree(bitfury);\n\t\tfree(state);\n\t\tft232r_close(ftdi);\n\t\treturn false;\n\t}\n\t\n\t/* Be careful, read lowl-spi.h comments for warnings */\n\tmemset(port, 0, sizeof(*port));\n\tport->txrx = bfx_spi_txrx;\n\tport->cgpu = cgpu;\n\tport->repr = cgpu->proc_repr;\n\tport->logprio = LOG_ERR;\n\t\n\tstate->ftdi = ftdi;\n\tport->userp = state;\n\tfor (proc = cgpu; proc; (proc = proc->next_proc), ++bitfury)\n\t{\n\t\tstruct thr_info * const mythr = proc->thr[0];\n\t\t*bitfury = (struct bitfury_device){\n\t\t\t.spi = port,\n\t\t\t.fasync = proc->proc_id,\n\t\t};\n\t\tproc->device_data = bitfury;\n\t\tmythr->cgpu_data = state;\n\t\tbitfury->osc6_bits = 50;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_chip(proc);\n\t\tproc->status = LIFE_INIT2;\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\treturn true;\n}\n\nstatic\nvoid bfx_disable(struct thr_info * const thr)\n{\n\tstruct bfx_state * const state = thr->cgpu_data;\n\tstruct ft232r_device_handle * const ftdi = state->ftdi;\n\t\n\tbitfury_disable(thr);\n\tbfx_device_off(ftdi);\n}\n\nstatic\nvoid bfx_reinit(struct cgpu_info * const cgpu)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct bfx_state * const state = thr->cgpu_data;\n\tstruct ft232r_device_handle * const ftdi = state->ftdi;\n\t\n\tbfx_device_off(ftdi);\n\tcgsleep_ms(1);\n\tbitfury_enable(thr);\n}\n\nstatic\nvoid bfx_shutdown(struct thr_info * const thr)\n{\n\tstruct bfx_state * const state = thr->cgpu_data;\n\tstruct ft232r_device_handle * const ftdi = state->ftdi;\n\t\n\tif (ftdi)\n\t\tbfx_device_off(ftdi);\n}\n\nstatic const struct bfg_set_device_definition bfx_set_device_funcs[] = {\n\t{\"osc6_bits\", bitfury_set_osc6_bits, \"range 1-\"BITFURY_MAX_OSC6_BITS_S\" (slow to fast)\"},\n\t{NULL},\n};\n\nstruct device_drv bfx_drv = {\n\t.dname = \"bfx\",\n\t.name = \"BFX\",\n\t.lowl_probe = bfx_lowl_probe,\n\t\n\t.thread_init = bfx_init,\n\t.thread_disable = bfx_disable,\n\t.thread_enable = bitfury_enable,\n\t.reinit_device = bfx_reinit,\n\t.thread_shutdown = bfx_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = bitfury_do_io,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-bifury.c",
          "type": "blob",
          "size": 16.1513671875,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <uthash.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nBFG_REGISTER_DRIVER(bifury_drv)\nstatic const struct bfg_set_device_definition bifury_set_device_funcs[];\n\nconst char bifury_init_cmds[] = \"flush\\ntarget ffffffff\\nmaxroll 0\\n\";\n\nstatic\nssize_t bifury_write(const struct cgpu_info * const dev, const void * const buf, const size_t count)\n{\n\tconst int fd = dev->device_fd;\n\tif (opt_dev_protocol)\n\t{\n\t\tconst int psz = (((const char*)buf)[count-1] == '\\n') ? (count - 1) : count;\n\t\tapplog(LOG_DEBUG, \"%s: DEVPROTO: SEND %.*s\", dev->dev_repr, psz, (const char*)buf);\n\t}\n\treturn write(fd, buf, count);\n}\n\nstatic\nvoid *bifury_readln(int fd, bytes_t *leftover)\n{\n\tuint8_t buf[0x40];\n\tssize_t r;\n\t\nparse:\n\tif ( (r = bytes_find(leftover, '\\n')) >= 0)\n\t{\n\t\tuint8_t *ret = malloc(r+1);\n\t\tif (r)\n\t\t\tmemcpy(ret, bytes_buf(leftover), r);\n\t\tret[r] = '\\0';\n\t\tbytes_shift(leftover, r + 1);\n\t\treturn ret;\n\t}\n\tif ( (r = read(fd, buf, sizeof(buf))) > 0)\n\t{\n\t\tbytes_append(leftover, buf, r);\n\t\tgoto parse;\n\t}\n\treturn NULL;\n}\n\nstruct bifury_state {\n\tbytes_t buf;\n\twork_device_id_t last_work_id;\n\tint needwork;\n\tbool has_needwork;\n\tuint8_t *osc6_bits;\n\tbool send_clock;\n\tunsigned max_queued;\n\tbool free_after_job;\n};\n\nstatic\nbool bifury_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"bi\\xe2\\x80\\xa2\"\"fury\");\n}\n\nconst char *bifury_init_chips(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tint *procs_p = proc->device_data;\n\t\n\tif (!setting || !*setting)\n\t\treturn \"missing setting\";\n\t\n\tconst int val = atoi(setting);\n\tif (val < 1)\n\t\treturn \"invalid setting\";\n\t\n\t*procs_p = val;\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition bifury_set_device_funcs_probe[] = {\n\t{\"chips\", bifury_init_chips, NULL},\n\t{NULL},\n};\n\nstatic\nbool bifury_detect_one(const char * const devpath)\n{\n\tchar buf[0x40], *p, *q, *s;\n\tbytes_t reply = BYTES_INIT;\n\tint major, minor, hwrev, chips;\n\tstruct cgpu_info *cgpu;\n\tstruct timeval tv_timeout;\n\tconst int fd = serial_open(devpath, 0, 10, true);\n\tapplog(LOG_DEBUG, \"%s: %s %s\",\n\t       bifury_drv.dname,\n\t       ((fd == -1) ? \"Failed to open\" : \"Successfully opened\"),\n\t       devpath);\n\t\n\tif (unlikely(fd == -1))\n\t\treturn false;\n\t\n\twhile (read(fd, buf, sizeof(buf)) == sizeof(buf))\n\t{}\n\t\n\tif (opt_dev_protocol)\n\t\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: SEND %s\", bifury_drv.dname, fd, \"version\");\n\tif (8 != write(fd, \"version\\n\", 8))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Error sending version request\", bifury_drv.dname);\n\t\tgoto err;\n\t}\n\t\n\ttimer_set_delay_from_now(&tv_timeout, 1000000);\n\twhile (true)\n\t{\n\t\tp = bifury_readln(fd, &reply);\n\t\tif (p)\n\t\t{\n\t\t\tif (opt_dev_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: RECV %s\",\n\t\t\t\t       bifury_drv.dname, fd, p);\n\t\t\tif (!strncmp(\"version \", p, 8))\n\t\t\t\tbreak;\n\t\t\tfree(p);\n\t\t}\n\t\tif (timer_passed(&tv_timeout, NULL))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s: Timed out waiting for response to version request\",\n\t\t\t       bifury_drv.dname);\n\t\t\tgoto err;\n\t\t}\n\t}\n\t\n\tbytes_free(&reply);\n\tserial_close(fd);\n\t\n\ts = p;\n\tmajor = strtol(&p[8], &p, 10);\n\tif (p == &buf[8] || p[0] != '.')\n\t\tgoto parseerr;\n\tminor = strtol(&p[1], &q, 10);\n\tif (p == q || strncmp(\" rev \", q, 5))\n\t\tgoto parseerr;\n\thwrev = strtol(&q[5], &p, 10);\n\tif (p == q || strncmp(\" chips \", p, 7))\n\t\tgoto parseerr;\n\tchips = strtol(&p[7], &q, 10);\n\tif (p == q || chips < 1)\n\t\tgoto parseerr;\n\tfree(s);\n\t\n\tapplog(LOG_DEBUG, \"%s: Found firmware %d.%d on hardware rev %d with %d chips\",\n\t       bifury_drv.dname, major, minor, hwrev, chips);\n\t\n\tif (serial_claim_v(devpath, &bifury_drv))\n\t\treturn false;\n\t\n\tdrv_set_defaults(&bifury_drv, bifury_set_device_funcs_probe, &chips, devpath, detectone_meta_info.serial, 1);\n\t\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &bifury_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.set_device_funcs = bifury_set_device_funcs,\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = chips,\n\t\t.threads = 1,\n\t\t.cutofftemp = 75,\n\t};\n\t// NOTE: Xcode's clang has a bug where it cannot find fields inside anonymous unions (more details in fpgautils)\n\tcgpu->device_fd = -1;\n\t\n\treturn add_cgpu(cgpu);\n\nparseerr:\n\tapplog(LOG_DEBUG, \"%s: Error parsing version response\", bifury_drv.dname);\n\tfree(s);\n\treturn false;\n\nerr:\n\tbytes_free(&reply);\n\tserial_close(fd);\n\treturn false;\n}\n\nstatic\nbool bifury_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, bifury_detect_one);\n}\n\nstatic\nbool bifury_set_queue_full(const struct cgpu_info * const dev, int needwork)\n{\n\tstruct bifury_state * const state = dev->device_data;\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tconst int fd = dev->device_fd;\n\tif (needwork != -1)\n\t\tstate->needwork = needwork;\n\tconst bool full = (fd == -1 || !state->needwork);\n\tif (full == master_thr->queue_full)\n\t\treturn full;\n\tfor (const struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tthr->queue_full = full;\n\t}\n\treturn full;\n}\n\nvoid bifury_send_clock(const struct cgpu_info * const dev)\n{\n\tstruct bifury_state * const state = dev->device_data;\n\tconst struct cgpu_info *proc;\n\tsize_t clockbufsz = 5 + (3 * dev->procs) + 1 + 1;\n\tchar clockbuf[clockbufsz];\n\tstrcpy(clockbuf, \"clock\");\n\tproc = dev;\n\tfor (int i = 0; i < dev->procs; ++i, (proc = proc->next_proc))\n\t{\n\t\tconst struct thr_info * const thr = proc->thr[0];\n\t\tint clk;\n\t\tif (proc->deven == DEV_ENABLED && !thr->pause)\n\t\t\tclk = state->osc6_bits[i];\n\t\telse\n\t\t\tclk = 0;\n\t\ttailsprintf(clockbuf, clockbufsz, \" %d\", clk);\n\t}\n\ttailsprintf(clockbuf, clockbufsz, \"\\n\");\n\t--clockbufsz;\n\tif (clockbufsz != bifury_write(dev, clockbuf, clockbufsz))\n\t{\n\t\tstate->send_clock = true;\n\t\tapplog(LOG_ERR, \"%s: Failed to send clock assignments\",\n\t\t       dev->dev_repr);\n\t}\n\telse\n\t\tstate->send_clock = false;\n}\n\nstatic\nbool bifury_thread_init(struct thr_info *master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu, *proc;\n\tstruct bifury_state * const state = malloc(sizeof(*state));\n\tif (!state)\n\t\treturn false;\n\t*state = (struct bifury_state){\n\t\t.buf = BYTES_INIT,\n\t\t.osc6_bits = malloc(sizeof(*state->osc6_bits) * dev->procs),\n\t\t.max_queued = dev->procs * 5 + 6,\n\t\t.free_after_job = true,\n\t};\n\tfor (int i = 0; i < dev->procs; ++i)\n\t\tstate->osc6_bits[i] = 54;\n\tfor (proc = dev; proc; proc = proc->next_proc)\n\t{\n\t\tproc->device_data = state;\n\t\tproc->status = LIFE_INIT2;\n\t}\n\tbifury_set_queue_full(dev, 0);\n\ttimer_set_now(&master_thr->tv_poll);\n\treturn true;\n}\n\nstatic\nvoid bifury_reinit(struct cgpu_info * const proc)\n{\n\ttimer_set_now(&proc->thr[0]->tv_poll);\n}\n\nvoid bifury_trigger_send_clock(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct bifury_state * const state = proc->device_data;\n\t\n\tstate->send_clock = true;\n}\n\nstatic\nvoid bifury_common_error(struct cgpu_info * const dev, const enum dev_reason reason)\n{\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tdev_error(proc, reason);\n\t\tinc_hw_errors_only(thr);\n\t}\n}\n\nstatic\nbool bifury_queue_append(struct thr_info * const thr, struct work *work)\n{\n\tconst struct cgpu_info * const dev = thr->cgpu->device;\n\tstruct bifury_state * const state = dev->device_data;\n\tif (bifury_set_queue_full(dev, -1))\n\t\treturn false;\n\t\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tchar buf[5 + 0x98 + 1 + 8 + 1];\n\tmemcpy(buf, \"work \", 5);\n\tbin2hex(&buf[5], work->data, 0x4c);\n\twork->device_id = ++state->last_work_id;\n\tsprintf(&buf[5 + 0x98], \" %08x\", work->device_id);\n\tbuf[5 + 0x98 + 1 + 8] = '\\n';\n\tif (sizeof(buf) != bifury_write(dev, buf, sizeof(buf)))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to send work\", dev->dev_repr);\n\t\treturn false;\n\t}\n\tHASH_ADD(hh, master_thr->work_list, device_id, sizeof(work->device_id), work);\n\tint prunequeue = HASH_COUNT(master_thr->work_list) - state->max_queued;\n\tif (prunequeue > 0)\n\t{\n\t\tstruct work *tmp;\n\t\tapplog(LOG_DEBUG, \"%s: Pruning %d old work item%s\",\n\t\t       dev->dev_repr, prunequeue, prunequeue == 1 ? \"\" : \"s\");\n\t\tHASH_ITER(hh, master_thr->work_list, work, tmp)\n\t\t{\n\t\t\tHASH_DEL(master_thr->work_list, work);\n\t\t\tfree_work(work);\n\t\t\tif (--prunequeue < 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbifury_set_queue_full(dev, state->needwork - 1);\n\treturn true;\n}\n\nstatic\nvoid bifury_queue_flush(struct thr_info * const thr)\n{\n\tconst struct cgpu_info *dev = thr->cgpu;\n\tif (dev != dev->device)\n\t\treturn;\n\tconst int fd = dev->device_fd;\n\tif (fd != -1)\n\t\tbifury_write(dev, \"flush\\n\", 6);\n\tbifury_set_queue_full(dev, dev->procs);\n}\n\nstatic\nvoid bifury_handle_cmd(struct cgpu_info * const dev, const char * const cmd)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct bifury_state * const state = dev->device_data;\n\tstruct thr_info *thr;\n\tstruct work *work;\n\tchar *p;\n\t\n\tif (!strncmp(cmd, \"submit \", 7))\n\t{\n\t\t// submit <nonce> <jobid> <timestamp> <chip>\n\t\tuint32_t nonce = strtoll(&cmd[7], &p, 0x10);\n\t\tconst uint32_t jobid = strtoll(&p[1], &p, 0x10);\n\t\tconst uint32_t ntime = strtoll(&p[1], &p, 0x10);\n\t\tconst int chip = atoi(&p[1]);\n\t\tconst struct cgpu_info *proc = device_proc_by_id(dev, chip);\n\t\tif (unlikely(!proc))\n\t\t\tproc = dev;\n\t\tthr = proc->thr[0];\n\t\t\n\t\tHASH_FIND(hh, master_thr->work_list, &jobid, sizeof(jobid), work);\n\t\tif (work)\n\t\t{\n\t\t\tconst uint32_t work_ntime = be32toh(*(uint32_t*)&work->data[68]);\n\t\t\tsubmit_noffset_nonce(thr, work, nonce, ntime - work_ntime);\n\t\t\thashes_done2(thr, 0x100000000, NULL);\n\t\t}\n\t\telse\n\t\tif (!jobid)\n\t\t\tapplog(LOG_DEBUG, \"%s: Dummy submit ignored\", dev->dev_repr);\n\t\telse\n\t\t\tinc_hw_errors2(thr, NULL, &nonce);\n\t\tif (!state->has_needwork)\n\t\t\tbifury_set_queue_full(dev, state->needwork + 2);\n\t}\n\telse\n\tif (!strncmp(cmd, \"temp \", 5))\n\t{\n\t\tstruct cgpu_info *proc;\n\t\tconst int decicelsius = atoi(&cmd[5]);\n\t\tif (decicelsius)\n\t\t{\n\t\t\tconst float celsius = 0.1 * (float)decicelsius;\n\t\t\tfor (proc = dev; proc; proc = proc->next_proc)\n\t\t\t\tproc->temp = celsius;\n\t\t\tif (decicelsius >= 800)\n\t\t\t\t// Thermal overheat causes restart losing the clock, so resend it while temperature is over 80 C\n\t\t\t\tstate->send_clock = true;\n\t\t}\n\t}\n\telse\n\tif (!strncmp(cmd, \"job \", 4))\n\t{\n\t\t// job <jobid> <timestamp> <chip>\n\t\tconst uint32_t jobid = strtoll(&cmd[4], &p, 0x10);\n\t\tstrtoll(&p[1], &p, 0x10);\n\t\tconst int chip = atoi(&p[1]);\n\t\tconst struct cgpu_info * const proc = device_proc_by_id(dev, chip);\n\t\t\n\t\tHASH_FIND(hh, master_thr->work_list, &jobid, sizeof(jobid), work);\n\t\tif (likely(work))\n\t\t{\n\t\t\tif (unlikely(!proc))\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Unknown chip id: %s\",\n\t\t\t\t       dev->dev_repr, cmd);\n\t\t\tif (state->free_after_job)\n\t\t\t{\n\t\t\t\tHASH_DEL(master_thr->work_list, work);\n\t\t\t\tfree_work(work);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_WARNING, \"%s: Unknown job id: %s\",\n\t\t\t       dev->dev_repr, cmd);\n\t}\n\telse\n\tif (!strncmp(cmd, \"hwerror \", 8))\n\t{\n\t\tconst int chip = atoi(&cmd[8]);\n\t\tconst struct cgpu_info * const proc = device_proc_by_id(dev, chip);\n\t\tif (unlikely(!proc))\n\t\t\tapplogr(, LOG_DEBUG, \"%s: Unknown chip id: %s\",\n\t\t\t        dev->dev_repr, cmd);\n\t\tthr = proc->thr[0];\n\t\tinc_hw_errors2(thr, NULL, UNKNOWN_NONCE);\n\t}\n\telse\n\tif (!strncmp(cmd, \"needwork \", 9))\n\t{\n\t\tconst int needwork = atoi(&cmd[9]);\n\t\tstate->has_needwork = true;\n\t\tbifury_set_queue_full(dev, needwork);\n\t\tapplog(LOG_DEBUG, \"%s: needwork=%d\", dev->dev_repr, state->needwork);\n\t}\n}\n\nstatic\nvoid bifury_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\tstruct bifury_state * const state = dev->device_data;\n\tint fd = dev->device_fd;\n\tchar *cmd;\n\t\n\tif (unlikely(fd == -1))\n\t{\n\t\tfd = serial_open(dev->device_path, 0, 1, true);\n\t\tif (unlikely(fd == -1))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Failed to open %s\",\n\t\t\t       dev->dev_repr, dev->device_path);\n\t\t\tbifury_common_error(dev, REASON_THREAD_FAIL_INIT);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdev->device_fd = fd;\n\t\tif (sizeof(bifury_init_cmds)-1 != bifury_write(dev, bifury_init_cmds, sizeof(bifury_init_cmds)-1))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Failed to send configuration\", dev->dev_repr);\n\t\t\tbifury_common_error(dev, REASON_THREAD_FAIL_INIT);\n\t\t\tserial_close(fd);\n\t\t\tdev->device_fd = -1;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbifury_set_queue_full(dev, dev->procs * 2);\n\t\tstate->send_clock = true;\n\t}\n\t\n\tif (state->send_clock)\n\t\tbifury_send_clock(dev);\n\t\n\twhile ( (cmd = bifury_readln(fd, &state->buf)) )\n\t{\n\t\tif (opt_dev_protocol)\n\t\t\tapplog(LOG_DEBUG, \"%s: DEVPROTO: RECV %s\", dev->dev_repr, cmd);\n\t\tbifury_handle_cmd(dev, cmd);\n\t\tfree(cmd);\n\t}\n}\n\nstatic\nstruct api_data *bifury_api_device_status(struct cgpu_info * const proc)\n{\n\tstruct bifury_state * const state = proc->device_data;\n\tstruct api_data *root = NULL;\n\tint osc6_bits = state->osc6_bits[proc->proc_id];\n\t\n\troot = api_add_int(root, \"Clock Bits\", &osc6_bits, true);\n\t\n\treturn root;\n}\n\nconst char *bifury_set_osc6_bits(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bifury_state * const state = proc->device_data;\n\t\n\tif (!setting || !*setting)\n\t\treturn \"missing setting\";\n\t\n\tconst int val = atoi(setting);\n\tif (val < 33 || val > 63)\n\t\treturn \"invalid setting\";\n\t\n\tstate->osc6_bits[proc->proc_id] = val;\n\tstate->send_clock = true;\n\t\n\treturn NULL;\n}\n\nconst char *bifury_set_max_queued(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bifury_state * const state = proc->device_data;\n\t\n\tif (!setting || !*setting)\n\t\treturn \"missing setting\";\n\t\n\tconst long val = strtol(setting, NULL, 0);\n\tif (val < 1 || val > UINT_MAX)\n\t\treturn \"invalid setting\";\n\t\n\tstate->max_queued = val;\n\t\n\treturn NULL;\n}\n\nconst char *bifury_set_free_after_job(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bifury_state * const state = proc->device_data;\n\t\n\tif (!setting || !*setting)\n\t\treturn \"missing setting\";\n\t\n\tchar *end;\n\tconst bool val = bfg_strtobool(setting, &end, 0);\n\tif (end[0] && !isspace(end[0]))\n\t\treturn \"invalid setting\";\n\t\n\tstate->free_after_job = val;\n\t\n\treturn NULL;\n}\n\n#ifdef HAVE_CURSES\nvoid bifury_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[O]scillator bits \");\n}\n\nconst char *bifury_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstruct bifury_state * const state = proc->device_data;\n\t\n\tswitch (input)\n\t{\n\t\tcase 'o': case 'O':\n\t\t{\n\t\t\tconst int val = curses_int(\"Set oscillator bits (range 33-63; slow to fast)\");\n\t\t\tif (val < 33 || val > 63)\n\t\t\t\treturn \"Invalid oscillator bits\\n\";\n\t\t\t\n\t\t\tstate->osc6_bits[proc->proc_id] = val;\n\t\t\tstate->send_clock = true;\n\t\t\t\n\t\t\treturn \"Oscillator bits changing\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid bifury_wlogprint_status(struct cgpu_info * const proc)\n{\n\tconst struct bifury_state * const state = proc->device_data;\n\tconst int osc6_bits = state->osc6_bits[proc->proc_id];\n\twlogprint(\"Oscillator bits: %d\\n\", osc6_bits);\n}\n#endif\n\nstatic const struct bfg_set_device_definition bifury_set_device_funcs[] = {\n\t{\"max_queued\", bifury_set_max_queued, NULL},\n\t{\"free_after_job\", bifury_set_free_after_job, NULL},\n\t{\"osc6_bits\", bifury_set_osc6_bits, \"range 33-63 (slow to fast)\"},\n\t{NULL},\n};\n\nstruct device_drv bifury_drv = {\n\t.dname = \"bifury\",\n\t.name = \"BIF\",\n\t.lowl_match = bifury_lowl_match,\n\t.lowl_probe = bifury_lowl_probe,\n\t\n\t.thread_init = bifury_thread_init,\n\t.reinit_device = bifury_reinit,\n\t.thread_disable = bifury_trigger_send_clock,\n\t.thread_enable = bifury_trigger_send_clock,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = bifury_queue_append,\n\t.queue_flush = bifury_queue_flush,\n\t.poll = bifury_poll,\n\t\n\t.get_api_extra_device_status = bifury_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bifury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bifury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bifury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-bigpic.c",
          "type": "blob",
          "size": 8.1005859375,
          "content": "/*\n * Copyright 2013 Andreas Auer\n * Copyright 2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n/*\n * Big Picture Mining USB miner with Bitfury ASIC\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"miner.h\"\n#include \"logging.h\"\n\n#include \"libbitfury.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"deviceapi.h\"\n#include \"sha2.h\"\n\n#include \"driver-bigpic.h\"\n\n#include <stdio.h>\n\nBFG_REGISTER_DRIVER(bigpic_drv)\n\nstatic\nbool bigpic_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"Bitfury\", \"BF1\");\n}\n\n//------------------------------------------------------------------------------\nstatic bool bigpic_detect_custom(const char *devpath, struct device_drv *api, struct bigpic_info *info)\n{\n\tint fd = serial_open(devpath, info->baud, 1, true);\n\n\tif(fd < 0)\n\t{\n\t\treturn false;\n\t}\n\n\tchar buf[sizeof(struct bigpic_identity)+1];\n\tint len;\n\n\tif (1 != write(fd, \"I\", 1))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed writing id request to %s\",\n\t\t       bigpic_drv.dname, devpath);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\tlen = serial_read(fd, buf, sizeof(buf));\n\tif(len != 14)\n\t{\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\n\tinfo->id.version = buf[1];\n\tmemcpy(info->id.product, buf+2, 8);\n\tmemcpy(&info->id.serial, buf+10, 4);\n\tinfo->id.serial = le32toh(info->id.serial);\n\tapplog(LOG_DEBUG, \"%s: %s: %d, %s %08x\",\n\t       bigpic_drv.dname,\n\t       devpath,\n\t       info->id.version, info->id.product, info->id.serial);\n\n\tchar buf_state[sizeof(struct bigpic_state)+1];\n\tlen = 0;\n\tif (1 != write(fd, \"R\", 1))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed writing reset request to %s\",\n\t\t       bigpic_drv.dname, devpath);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\n\tint limit = 50;\n\twhile (len == 0 && --limit)\n\t{\n\t\tlen = serial_read(fd, buf, sizeof(buf_state));\n\t\tcgsleep_ms(100);\n\t}\n\tserial_close(fd);\n\n\tif(len != 7)\n\t{\n\t\tapplog(LOG_ERR, \"%s: %s not responding to reset: %d\",\n\t\t       bigpic_drv.dname,\n\t\t       devpath, len);\n\t\treturn false;\n\t}\n\n\tif (serial_claim_v(devpath, api))\n\t\treturn false;\n\n\tstruct cgpu_info *bigpic;\n\tbigpic = calloc(1, sizeof(struct cgpu_info));\n\tbigpic->drv = api;\n\tbigpic->device_path = strdup(devpath);\n\tbigpic->device_fd = -1;\n\tbigpic->threads = 1;\n\tadd_cgpu(bigpic);\n\n\tapplog(LOG_INFO, \"Found %\"PRIpreprv\" at %s\", bigpic->proc_repr, devpath);\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Init: baud=%d\",\n\t\tbigpic->proc_repr, info->baud);\n\n\tbigpic->device_data = info;\n\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic bool bigpic_detect_one(const char *devpath)\n{\n\tstruct bigpic_info *info = calloc(1, sizeof(struct bigpic_info));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc bigpicInfo\");\n\n\tinfo->baud = BPM_BAUD;\n\n\tif (!bigpic_detect_custom(devpath, &bigpic_drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool bigpic_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, bigpic_detect_one);\n}\n\n//------------------------------------------------------------------------------\nstatic bool bigpic_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *bigpic = thr->cgpu;\n\tstruct bigpic_info *info = (struct bigpic_info *)bigpic->device_data;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": init\", bigpic->proc_repr);\n\n\tint fd = serial_open(bigpic->device_path, info->baud, 1, true);\n\tif (unlikely(-1 == fd))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to open %s\",\n\t\t       bigpic->proc_repr, bigpic->device_path);\n\t\treturn false;\n\t}\n\n\tbigpic->device_fd = fd;\n\n\tapplog(LOG_INFO, \"%\"PRIpreprv\": Opened %s\", bigpic->proc_repr, bigpic->device_path);\n\n\tinfo->tx_buffer[0] = 'W';\n\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic bool duplicate(uint32_t *results, uint32_t size, uint32_t test_nonce)\n{\n\tfor(uint32_t i=0; i<size; i++)\n\t{\n\t\tif(results[i] == test_nonce)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//------------------------------------------------------------------------------\nstatic void bigpic_process_results(struct thr_info *thr, struct work *work)\n{\n\tstruct cgpu_info *board = thr->cgpu;\n\tstruct bigpic_info *info = (struct bigpic_info *)board->device_data;\n\n\tuint32_t results[16*6];\n\tuint32_t num_results;\n\tint hwe = 0;\n\n\tuint32_t m7    = *((uint32_t *)&work->data[64]);\n\tuint32_t ntime = *((uint32_t *)&work->data[68]);\n\tuint32_t nbits = *((uint32_t *)&work->data[72]);\n\n\tnum_results = 0;\n\tfor(int i=0; i<info->rx_len; i+=7)\n\t{\n\t\tstruct bigpic_state state;\n\t\tstate.state = info->rx_buffer[i + 1];\n\t\tstate.switched = info->rx_buffer[i + 2];\n\t\tmemcpy(&state.nonce, info->rx_buffer + i + 3, 4);\n\n\t\tif(duplicate(results, num_results, state.nonce))\n\t\t\tcontinue;\n\n\t\tstate.nonce = le32toh(state.nonce);\n\t\tuint32_t nonce = bitfury_decnonce(state.nonce);\n\t\tresults[num_results++] = state.nonce;\n\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Len: %lu Cmd: %c State: %c Switched: %d Nonce: %08lx\",\n\t\t       board->proc_repr,\n\t\t       (unsigned long)info->rx_len, info->rx_buffer[i], state.state, state.switched, (unsigned long)nonce);\n\t\tif (bitfury_fudge_nonce(work->midstate, m7, ntime, nbits, &nonce))\n\t\t\tsubmit_nonce(thr, work, nonce);\n\t\telse\n\t\tif (info->rx_buffer[i + 3] != '\\xe0' || hwe++)\n\t\t\tinc_hw_errors(thr, work, nonce);\n\t}\n}\n\nstatic\nbool bigpic_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info *board = thr->cgpu;\n\tstruct bigpic_info *info = (struct bigpic_info *)board->device_data;\n\t\n\tmemcpy(&info->tx_buffer[ 1], work->midstate, 32);\n\tmemcpy(&info->tx_buffer[33], &work->data[64], 12);\n\t\n\twork->blk.nonce = 0xffffffff;\n\treturn true;\n}\n\nstatic\nvoid bigpic_job_start(struct thr_info *thr)\n{\n\tstruct cgpu_info *board = thr->cgpu;\n\tstruct bigpic_info *info = (struct bigpic_info *)board->device_data;\n\t\n\tif (opt_dev_protocol && opt_debug)\n\t{\n\t\tchar hex[91];\n\t\tbin2hex(hex, info->tx_buffer, 45);\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": SEND: %s\",\n\t\t       board->proc_repr, hex);\n\t}\n\t\n\tif (45 != write(board->device_fd, info->tx_buffer, 45))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed writing work task\", board->proc_repr);\n\t\tdev_error(board, REASON_DEV_COMMS_ERROR);\n\t\tjob_start_abort(thr, true);\n\t\treturn;\n\t}\n\t\n\twhile(1)\n\t{\n\t\tuint8_t buffer[7];\n\t\tint len;\n\t\tlen = serial_read(board->device_fd, buffer, 7);\n\t\tif(len > 0)\n\t\t\tbreak;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Work Task sent\", board->proc_repr);\n\t\n\twhile(1)\n\t{\n\t\tinfo->rx_len = serial_read(board->device_fd, info->rx_buffer, sizeof(info->rx_buffer));\n\t\tif(info->rx_len > 0)\n\t\t\tbreak;\n\t}\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Work Task accepted\", board->proc_repr);\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Nonces sent back: %d\",\n\t       board->proc_repr, info->rx_len / 7);\n\t\n\tmt_job_transition(thr);\n\t// TODO: Delay morework until right before it's needed\n\ttimer_set_now(&thr->tv_morework);\n\tjob_start_complete(thr);\n}\n\nstatic\nint64_t bigpic_job_process_results(struct thr_info *thr, struct work *work, bool stopping)\n{\n\t// FIXME: not sure how to handle stopping\n\tbigpic_process_results(thr, work);\n\t\n\treturn 0xBD000000;\n}\n\n//------------------------------------------------------------------------------\nstatic void bigpic_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\n\tserial_close(cgpu->device_fd);\n}\n\n//------------------------------------------------------------------------------\nstatic bool bigpic_identify(struct cgpu_info *cgpu)\n{\n\tchar buf[] = \"L\";\n\tif (sizeof(buf) != write(cgpu->device_fd, buf, sizeof(buf)))\n\t\treturn false;\n\t\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstruct device_drv bigpic_drv = {\n\t.dname = \"bigpic\",\n\t.name = \"BPM\",\n\t.probe_priority = -110,\n\n\t.lowl_match = bigpic_lowl_match,\n\t.lowl_probe = bigpic_lowl_probe,\n\n\t.identify_device = bigpic_identify,\n\n\t.thread_init = bigpic_init,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bigpic_job_prepare,\n\t.job_start = bigpic_job_start,\n\t.job_process_results = bigpic_job_process_results,\n\t\n\t.thread_shutdown = bigpic_shutdown,\n};\n"
        },
        {
          "name": "driver-bigpic.h",
          "type": "blob",
          "size": 0.453125,
          "content": "#ifndef BFG_DRIVER_BIGPIC_H\n#define BFG_DRIVER_BIGPIC_H\n\n#include <stdint.h>\n\n#define BPM_BAUD\t115200\n\nstruct bigpic_identity\n{\n\tuint8_t version;\n\tchar    product[8];\n\tuint32_t serial;\n} __attribute__((packed));\n\nstruct bigpic_state\n{\n    uint8_t state;\n    uint8_t switched;\n    uint32_t nonce;\n} __attribute__((packed));\n\nstruct bigpic_info\n{\n\tuint32_t baud;\n\n\tstruct bigpic_identity id;\n\n\tchar tx_buffer[45];\n\tchar rx_buffer[1024];\n\tuint32_t rx_len;\n};\n\n#endif\n"
        },
        {
          "name": "driver-bitforce.c",
          "type": "blob",
          "size": 74.2177734375,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2012-2013 Con Kolivas\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"miner.h\"\n#include \"lowlevel.h\"\n#ifdef NEED_BFG_LOWL_MSWIN\n#include \"lowl-mswin.h\"\n#endif\n#include \"lowl-pci.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\n#define BFL_PCI_VENDOR_ID 0x1cf9\n\n#define BITFORCE_SLEEP_MS 500\n#define BITFORCE_VCOM_TIMEOUT_DSEC     250\n#define BITFORCE_VCOM_TIMEOUT_DSEC_ZCX  10\n#define BITFORCE_TIMEOUT_S 7\n#define BITFORCE_TIMEOUT_MS (BITFORCE_TIMEOUT_S * 1000)\n#define BITFORCE_LONG_TIMEOUT_S 25\n#define BITFORCE_LONG_TIMEOUT_MS (BITFORCE_LONG_TIMEOUT_S * 1000)\n#define BITFORCE_CHECK_INTERVAL_MS 10\n#define WORK_CHECK_INTERVAL_MS 50\n#define tv_to_ms(tval) ((unsigned long)(tval.tv_sec * 1000 + tval.tv_usec / 1000))\n#define TIME_AVG_CONSTANT 8\n#define BITFORCE_QRESULT_LINE_LEN 165\n#define BITFORCE_MAX_QUEUED_MAX 40\n#define BITFORCE_MIN_QUEUED_MAX 10\n#define BITFORCE_MAX_QRESULTS 16\n#define BITFORCE_GOAL_QRESULTS 5\n#define BITFORCE_MIN_QRESULT_WAIT BITFORCE_CHECK_INTERVAL_MS\n#define BITFORCE_MAX_QRESULT_WAIT 1000\n#define BITFORCE_MAX_BQUEUE_AT_ONCE_65NM 5\n#define BITFORCE_MAX_BQUEUE_AT_ONCE_28NM 20\n\nenum bitforce_proto {\n\tBFP_WORK   = 0,\n\tBFP_RANGE  = 1,\n\tBFP_BQUEUE = 3,\n\tBFP_PQUEUE = 4,\n};\n\nstatic const char *protonames[] = {\n\t\"full work\",\n\t\"nonce range\",\n\tNULL,\n\t\"bulk queue\",\n\t\"parallel queue\",\n};\n\nBFG_REGISTER_DRIVER(bitforce_drv)\nBFG_REGISTER_DRIVER(bitforce_queue_api)\nstatic const struct bfg_set_device_definition bitforce_set_device_funcs[];\n\nenum bitforce_style {\n\tBFS_FPGA,\n\tBFS_65NM,\n\tBFS_28NM,\n};\n\nstruct bitforce_lowl_interface {\n\tbool (*open)(struct cgpu_info *);\n\tvoid (*close)(struct cgpu_info *);\n\tssize_t (*read)(void *, size_t, struct cgpu_info *);\n\tvoid (*gets)(char *, size_t, struct cgpu_info *);\n\tssize_t (*write)(struct cgpu_info *, const void *, ssize_t);\n\tbool (*set_timeout)(struct cgpu_info* , uint8_t);\n};\n\nstruct bitforce_data {\n\tstruct bitforce_lowl_interface *lowlif;\n\tbool is_open;\n\tstruct lowl_pci_handle *lph;\n\tuint8_t lasttag;\n\tuint8_t lasttag_read;\n\tbytes_t getsbuf;\n\tint xlink_id;\n\tunsigned char next_work_ob[70];  // Data aligned for 32-bit access\n\tunsigned char *next_work_obs;    // Start of data to send\n\tunsigned char next_work_obsz;\n\tconst char *next_work_cmd;\n\tchar noncebuf[14 + ((BITFORCE_MAX_QRESULTS+1) * BITFORCE_QRESULT_LINE_LEN)];\n\tint poll_func;\n\tenum bitforce_proto proto;\n\tenum bitforce_style style;\n\tint queued;\n\tint queued_max;\n\tint parallel;\n\tbool parallel_protocol;\n\tbool missing_zwx;\n\tbool already_have_results;\n\tbool just_flushed;\n\tint max_queue_at_once;\n\tint ready_to_queue;\n\tbool want_to_send_queue;\n\tunsigned result_busy_polled;\n\tunsigned sleep_ms_default;\n\tstruct timeval tv_hashmeter_start;\n\tfloat temp[2];\n\tlong *volts;\n\tint volts_count;\n\tunsigned max_queueid;\n\t\n\tbool probed;\n\tbool supports_fanspeed;\n};\n\n// Code must deal with a timeout\nstatic\nbool bitforce_vcom_open(struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tconst char * const devpath = dev->device_path;\n\tdev->device_fd = serial_open(devpath, 0, BITFORCE_VCOM_TIMEOUT_DSEC, true);\n\tdevdata->is_open = (dev->device_fd != -1);\n\treturn devdata->is_open;\n}\n\nstatic\nvoid bitforce_vcom_close(struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tif (devdata->is_open)\n\t{\n\t\tserial_close(dev->device_fd);\n\t\tdev->device_fd = -1;\n\t\tdevdata->is_open = false;\n\t}\n}\n\nstatic\nssize_t bitforce_vcom_read(void * const buf_p, size_t bufLen, struct cgpu_info * const dev)\n{\n\tuint8_t *buf = buf_p;\n\tconst int fd = dev->device_fd;\n\tssize_t rv, ret = 0;\n\twhile (bufLen > 0)\n\t{\n\t\trv = read(fd, buf, bufLen);\n\t\tif (rv <= 0)\n\t\t{\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\t\t\treturn rv;\n\t\t}\n\t\tbuf += rv;\n\t\tbufLen -= rv;\n\t\tret += rv;\n\t}\n\treturn ret;\n}\n\nstatic\nvoid bitforce_vcom_gets(char *buf, size_t bufLen, struct cgpu_info * const dev)\n{\n\tconst int fd = dev->device_fd;\n\twhile (likely(bufLen > 1 && read(fd, buf, 1) == 1 && (buf++)[0] != '\\n'))\n\t{}\n\n\tbuf[0] = '\\0';\n}\n\nstatic\nssize_t bitforce_vcom_write(struct cgpu_info * const dev, const void *buf, ssize_t bufLen)\n{\n\tconst int fd = dev->device_fd;\n\tif ((bufLen) != write(fd, buf, bufLen))\n\t\treturn 0;\n\telse\n\t\treturn bufLen;\n}\n\nstatic\nbool bitforce_vcom_set_timeout(struct cgpu_info * const dev, const uint8_t timeout)\n{\n\tconst int fd = dev->device_fd;\n\treturn vcom_set_timeout(fd, timeout);\n}\n\nstatic struct bitforce_lowl_interface bfllif_vcom = {\n\t.open = bitforce_vcom_open,\n\t.close = bitforce_vcom_close,\n\t.read = bitforce_vcom_read,\n\t.gets = bitforce_vcom_gets,\n\t.write = bitforce_vcom_write,\n\t.set_timeout = bitforce_vcom_set_timeout,\n};\n\n#ifdef NEED_BFG_LOWL_PCI\nstatic\nbool bitforce_pci_open(struct cgpu_info * const dev)\n{\n\tconst char * const devpath = dev->device_path;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tdevdata->lph = lowl_pci_open(devpath, LP_BARINFO(\n\t\tLP_BAR(0, 0x1000, O_WRONLY),\n\t\tLP_BAR(1, 0x1000, O_RDONLY),\n\t\tLP_BAR(2,   0x80, O_RDWR),\n\t));\n\tif (!devdata->lph)\n\t\treturn false;\n\tdevdata->lasttag = (lowl_pci_get_word(devdata->lph, 2, 2) >> 16) & 0xff;\n\tdevdata->lasttag_read = 0;\n\tbytes_reset(&devdata->getsbuf);\n\tdevdata->is_open = true;\n\treturn devdata->is_open;\n}\n\nstatic\nvoid bitforce_pci_close(struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tif (devdata->is_open)\n\t{\n\t\tlowl_pci_close(devdata->lph);\n\t\tdevdata->is_open = false;\n\t}\n}\n\nstatic\nvoid _bitforce_pci_read(struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tconst uint32_t looking_for = (uint32_t)devdata->lasttag << 0x10;\n\tuint32_t resp;\n\tbytes_t *b = &devdata->getsbuf;\n\t\n\tif (devdata->lasttag != devdata->lasttag_read)\n\t{\n\t\tif (unlikely(bytes_len(b)))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%s: %ld bytes remaining in read buffer at new command\", dev->dev_repr, (long)bytes_len(&devdata->getsbuf));\n\t\t\tbytes_reset(b);\n\t\t}\n\t\t\n\t\twhile (((resp = lowl_pci_get_word(devdata->lph, 2, 2)) & 0xff0000) != looking_for)\n\t\t\tcgsleep_ms(1);\n\t\t\n\t\tresp &= 0xffff;\n\t\tif (unlikely(resp > 0x1000))\n\t\t\tresp = 0x1000;\n\t\t\n\t\tvoid * const buf = bytes_preappend(b, resp + LOWL_PCI_GET_DATA_PADDING);\n\t\tif (lowl_pci_read_data(devdata->lph, buf, resp, 1, 0))\n\t\t\tbytes_postappend(b, resp);\n\t\t\n\t\tdevdata->lasttag_read = devdata->lasttag;\n\t}\n}\n\nstatic\nssize_t bitforce_pci_read(void * const buf, const size_t bufLen, struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tbytes_t *b = &devdata->getsbuf;\n\t\n\t_bitforce_pci_read(dev);\n\tssize_t datalen = bytes_len(b);\n\tif (datalen <= 0)\n\t\treturn datalen;\n\t\n\tif (datalen > bufLen)\n\t\tdatalen = bufLen;\n\t\n\tmemcpy(buf, bytes_buf(b), datalen);\n\tbytes_shift(b, datalen);\n\t\n\treturn datalen;\n}\n\nstatic\nvoid bitforce_pci_gets(char * const buf, size_t bufLen, struct cgpu_info * const dev)\n{\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tbytes_t *b = &devdata->getsbuf;\n\t\n\t_bitforce_pci_read(dev);\n\tssize_t linelen = (bytes_find(b, '\\n') + 1) ?: bytes_len(b);\n\tif (linelen > --bufLen)\n\t\tlinelen = bufLen;\n\t\n\tmemcpy(buf, bytes_buf(b), linelen);\n\tbytes_shift(b, linelen);\n\tbuf[linelen] = '\\0';\n}\n\nstatic\nssize_t bitforce_pci_write(struct cgpu_info * const dev, const void * const bufp, ssize_t bufLen)\n{\n\tconst uint8_t *buf = bufp;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tif (unlikely(bufLen > 0x1000))\n\t\treturn 0;\n\t\n\tif (!lowl_pci_set_data(devdata->lph, buf, bufLen, 0, 0))\n\t\treturn 0;\n\tif (++devdata->lasttag == 0)\n\t\t++devdata->lasttag;\n\tif (!lowl_pci_set_word(devdata->lph, 2, 0, ((uint32_t)devdata->lasttag << 0x10) | bufLen))\n\t\treturn 0;\n\t\n\treturn bufLen;\n}\n\nstatic struct bitforce_lowl_interface bfllif_pci = {\n\t.open = bitforce_pci_open,\n\t.close = bitforce_pci_close,\n\t.read = bitforce_pci_read,\n\t.gets = bitforce_pci_gets,\n\t.write = bitforce_pci_write,\n};\n#endif\n\nstatic\nvoid bitforce_close(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tif (devdata->is_open)\n\t\tdevdata->lowlif->close(dev);\n}\n\nstatic\nbool bitforce_open(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tbitforce_close(proc);\n\treturn devdata->lowlif->open(dev);\n}\n\nstatic\nssize_t bitforce_read(struct cgpu_info * const proc, void * const buf, const size_t bufLen)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tssize_t rv;\n\t\n\tif (likely(devdata->is_open))\n\t{\n\t\tif (bufLen == 0)\n\t\t\trv = 0;\n\t\telse\n\t\t\trv = devdata->lowlif->read(buf, bufLen, dev);\n\t}\n\telse\n\t\trv = -1;\n\t\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tsize_t datalen = (rv > 0) ? rv : 0;\n\t\tchar hex[(rv * 2) + 1];\n\t\tbin2hex(hex, buf, datalen);\n\t\tapplog(LOG_DEBUG, \"DEVPROTO: %s: READ(%lu): %s\",\n\t\t       dev->dev_repr, (unsigned long)bufLen, hex);\n\t}\n\t\n\treturn rv;\n}\n\nstatic\nvoid bitforce_gets(char * const buf, const size_t bufLen, struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tif (likely(devdata->is_open))\n\t\tdevdata->lowlif->gets(buf, bufLen, dev);\n\telse\n\t\tbuf[0] = '\\0';\n\t\n\tif (unlikely(opt_dev_protocol))\n\t\tapplog(LOG_DEBUG, \"DEVPROTO: %s: GETS: %s\", dev->dev_repr, buf);\n}\n\nstatic\nssize_t bitforce_write(struct cgpu_info * const proc, const void * const buf, const ssize_t bufLen)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tif (unlikely(!devdata->is_open))\n\t\treturn 0;\n\t\n\treturn devdata->lowlif->write(dev, buf, bufLen);\n}\n\nstatic ssize_t bitforce_send(struct cgpu_info * const proc, const void *buf, ssize_t bufLen)\n{\n\tstruct bitforce_data * const data = proc->device_data;\n\tconst int procid = data->xlink_id;\n\tif (!procid)\n\t\treturn bitforce_write(proc, buf, bufLen);\n\t\n\tif (bufLen > 255)\n\t\treturn -1;\n\t\n\tsize_t bufLeft = bufLen + 3;\n\tchar realbuf[bufLeft], *bufp;\n\tssize_t rv;\n\tmemcpy(&realbuf[3], buf, bufLen);\n\trealbuf[0] = '@';\n\trealbuf[1] = bufLen;\n\trealbuf[2] = procid;\n\tbufp = realbuf;\n\tdo\n\t{\n\t\trv = bitforce_write(proc, bufp, bufLeft);\n\t\tif (rv <= 0)\n\t\t\treturn rv;\n\t\tbufLeft -= rv;\n\t}\n\twhile (bufLeft > 0);\n\treturn bufLen;\n}\n\nstatic\nvoid bitforce_cmd1b(struct cgpu_info * const proc, void *buf, size_t bufsz, const char *cmd, size_t cmdsz)\n{\n\tif (unlikely(opt_dev_protocol))\n\t\tapplog(LOG_DEBUG, \"DEVPROTO: %\"PRIpreprv\": CMD1: %s\",\n\t\t       proc->proc_repr, cmd);\n\t\n\tbitforce_send(proc, cmd, cmdsz);\n\tbitforce_gets(buf, bufsz, proc);\n}\n\nstatic\nvoid bitforce_cmd1c(struct cgpu_info * const proc, void *buf, size_t bufsz, void *cmd, size_t cmdsz)\n{\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tchar hex[(cmdsz * 2) + 1];\n\t\tbin2hex(hex, cmd, cmdsz);\n\t\tapplog(LOG_DEBUG, \"DEVPROTO: %\"PRIpreprv\": CMD1 HEX: %s\",\n\t\t       proc->proc_repr, hex);\n\t}\n\t\n\tbitforce_send(proc, cmd, cmdsz);\n\tbitforce_gets(buf, bufsz, proc);\n}\n\nstatic\nvoid bitforce_cmd2(struct cgpu_info * const proc, void *buf, size_t bufsz, const char *cmd, void *data, size_t datasz)\n{\n\tbitforce_cmd1b(proc, buf, bufsz, cmd, 3);\n\tif (strncasecmp(buf, \"OK\", 2))\n\t\treturn;\n\t\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tchar hex[(datasz * 2) + 1];\n\t\tbin2hex(hex, data, datasz);\n\t\tapplog(LOG_DEBUG, \"DEVPROTO: %\"PRIpreprv\": CMD2: %s\",\n\t\t       proc->proc_repr, hex);\n\t}\n\t\n\tbitforce_send(proc, data, datasz);\n\tbitforce_gets(buf, bufsz, proc);\n}\n\nstatic\nvoid bitforce_zgx(struct cgpu_info * const proc, void *buf, size_t bufsz)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\t\n\tif (devdata->is_open && devdata->lowlif->set_timeout)\n\t{\n\t\tdevdata->lowlif->set_timeout(dev, BITFORCE_VCOM_TIMEOUT_DSEC_ZCX);\n\t\tbitforce_cmd1b(proc, buf, bufsz, \"ZGX\", 3);\n\t\tdevdata->lowlif->set_timeout(dev, BITFORCE_VCOM_TIMEOUT_DSEC);\n\t}\n\telse\n\t\tbitforce_cmd1b(proc, buf, bufsz, \"ZGX\", 3);\n}\n\nstruct bitforce_init_data {\n\tstruct bitforce_lowl_interface *lowlif;\n\tenum bitforce_style style;\n\tlong devmask;\n\tint *parallels;\n\tunsigned queue_depth;\n\tunsigned long scan_interval_ms;\n\tunsigned max_queueid;\n};\n\nstatic\nint bitforce_chips_to_plan_for(int parallel, int chipcount) {\n\tif (parallel < 1)\n\t\treturn parallel;\n\treturn upper_power_of_two_u32(chipcount);\n}\n\nstatic\nbool bitforce_lowl_match(const struct lowlevel_device_info * const info)\n{\n#ifdef NEED_BFG_LOWL_PCI\n\tif (info->lowl == &lowl_pci)\n\t\treturn info->vid == BFL_PCI_VENDOR_ID;\n#endif\n#ifdef NEED_BFG_LOWL_MSWIN\n\tif (lowl_mswin_match_guid(info, &WIN_GUID_DEVINTERFACE_MonarchKMDF))\n\t\treturn true;\n#endif\n\treturn lowlevel_match_product(info, \"BitFORCE\", \"SHA256\");\n}\n\nchar *bitforce_copy_name(char * const pdevbuf)\n{\n\tchar *s;\n\tif (likely((!memcmp(pdevbuf, \">>>ID: \", 7)) && (s = strstr(pdevbuf + 3, \">>>\"))))\n\t{\n\t\ts[0] = '\\0';\n\t\ts = strdup(&pdevbuf[7]);\n\t}\n\telse\n\t{\n\t\tfor (s = &pdevbuf[strlen(pdevbuf)]; isspace(*--s); )\n\t\t\t*s = '\\0';\n\t\ts = strdup(pdevbuf);\n\t}\n\treturn s;\n}\n\nstatic\nbool bitforce_detect_oneof(const char * const devpath, struct bitforce_lowl_interface * const lowlif)\n{\n\tstruct cgpu_info *bitforce;\n\tchar pdevbuf[0x100];\n\tsize_t pdevbuf_len;\n\tchar *s = NULL;\n\tint procs = 1, parallel = -1;\n\tlong maxchipno = 0;\n\tstruct bitforce_init_data *initdata;\n\tchar *manuf = NULL;\n\tstruct bitforce_data dummy_bfdata = {\n\t\t.lowlif = lowlif,\n\t\t.xlink_id = 0,\n\t};\n\tstruct cgpu_info dummy_cgpu = {\n\t\t.device = &dummy_cgpu,\n\t\t.dev_repr = \"BFL\",\n\t\t.proc_repr = \"BFL\",\n\t\t.device_path = devpath,\n\t\t.device_data = &dummy_bfdata,\n\t};\n\tdummy_cgpu.device_fd = -1;\n\n\tapplog(LOG_DEBUG, \"BFL: Attempting to open %s\", devpath);\n\tbitforce_open(&dummy_cgpu);\n\n\tif (unlikely(!dummy_bfdata.is_open)) {\n\t\tapplog(LOG_DEBUG, \"BFL: Failed to open %s\", devpath);\n\t\treturn false;\n\t}\n\n\tbitforce_zgx(&dummy_cgpu, pdevbuf, sizeof(pdevbuf));\n\tif (unlikely(!pdevbuf[0])) {\n\t\tapplog(LOG_DEBUG, \"BFL: Error reading/timeout (ZGX)\");\n\t\tbitforce_close(&dummy_cgpu);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!strstr(pdevbuf, \"SHA256\"))) {\n\t\tapplog(LOG_DEBUG, \"BFL: Didn't recognise BitForce on %s\", devpath);\n\t\tbitforce_close(&dummy_cgpu);\n\t\treturn false;\n\t}\n\n\tif (serial_claim_v(devpath, &bitforce_drv))\n\t{\n\t\tbitforce_close(&dummy_cgpu);\n\t\treturn false;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"Found BitForce device on %s\", devpath);\n\t\n\ts = bitforce_copy_name(pdevbuf);\n\t\n\tinitdata = malloc(sizeof(*initdata));\n\t*initdata = (struct bitforce_init_data){\n\t\t.lowlif = lowlif,\n\t\t.style = BFS_FPGA,\n\t\t.queue_depth = BITFORCE_MAX_QUEUED_MAX,\n\t};\n\tbitforce_cmd1b(&dummy_cgpu, pdevbuf, sizeof(pdevbuf), \"ZCX\", 3);\n\tfor (int i = 0; (!pdevbuf[0]) && i < 4; ++i)\n\t\tbitforce_gets(pdevbuf, sizeof(pdevbuf), &dummy_cgpu);\n\tfor ( ;\n\t      strncasecmp(pdevbuf, \"OK\", 2);\n\t      bitforce_gets(pdevbuf, sizeof(pdevbuf), &dummy_cgpu) )\n\t{\n\t\tpdevbuf_len = strlen(pdevbuf);\n\t\tif (unlikely(!pdevbuf_len))\n\t\t\tcontinue;\n\t\tpdevbuf[pdevbuf_len-1] = '\\0';  // trim newline\n\t\t\n\t\tapplog(LOG_DEBUG, \"  %s\", pdevbuf);\n\t\t\n\t\tif (!strncasecmp(pdevbuf, \"PROCESSOR \", 10))\n\t\t\tmaxchipno = max(maxchipno, atoi(&pdevbuf[10]));\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"CHANNEL\", 7))\n\t\t\tmaxchipno = max(maxchipno, atoi(&pdevbuf[7]));\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"CORTEX-\", 7))\n\t\t\tmaxchipno = max(maxchipno, strtol(&pdevbuf[7], NULL, 0x10));\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"DEVICES IN CHAIN:\", 17))\n\t\t\tprocs = atoi(&pdevbuf[17]);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"CHAIN PRESENCE MASK:\", 20))\n\t\t\tinitdata->devmask = strtol(&pdevbuf[20], NULL, 16);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"DEVICE:\", 7) && strstr(pdevbuf, \"SC\") && initdata->style == BFS_FPGA)\n\t\t\tinitdata->style = BFS_65NM;\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"CHIP PARALLELIZATION: YES @\", 27))\n\t\t\tparallel = atoi(&pdevbuf[27]);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"ASIC CHANNELS:\", 14))\n\t\t{\n\t\t\tparallel = atoi(&pdevbuf[14]);\n\t\t\tinitdata->style = BFS_28NM;\n\t\t}\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"Queue Depth:\", 12))\n\t\t\tinitdata->queue_depth = atoi(&pdevbuf[12]);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"Scan Interval:\", 14))\n\t\t\tinitdata->scan_interval_ms = atoi(&pdevbuf[14]);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"Max Queue ID:\", 13))\n\t\t\tinitdata->max_queueid = strtol(&pdevbuf[13], NULL, 0x10);\n\t\telse\n\t\tif (!strncasecmp(pdevbuf, \"MANUFACTURER:\", 13))\n\t\t{\n\t\t\tmanuf = &pdevbuf[13];\n\t\t\twhile (manuf[0] && isspace(manuf[0]))\n\t\t\t\t++manuf;\n\t\t\tif (manuf[0])\n\t\t\t\tmanuf = strdup(manuf);\n\t\t\telse\n\t\t\t\tmanuf = NULL;\n\t\t}\n\t}\n\tparallel = bitforce_chips_to_plan_for(parallel, maxchipno);\n\tinitdata->parallels = malloc(sizeof(initdata->parallels[0]) * procs);\n\tinitdata->parallels[0] = parallel;\n\tparallel = abs(parallel);\n\tfor (int proc = 1; proc < procs; ++proc)\n\t{\n\t\tapplog(LOG_DEBUG, \"Slave board %d:\", proc);\n\t\tinitdata->parallels[proc] = -1;\n\t\tmaxchipno = 0;\n\t\tbitforce_cmd1b(&dummy_cgpu, pdevbuf, sizeof(pdevbuf), \"ZCX\", 3);\n\t\tfor (int i = 0; (!pdevbuf[0]) && i < 4; ++i)\n\t\t\tbitforce_gets(pdevbuf, sizeof(pdevbuf), &dummy_cgpu);\n\t\tfor ( ;\n\t\t      strncasecmp(pdevbuf, \"OK\", 2);\n\t\t      bitforce_gets(pdevbuf, sizeof(pdevbuf), &dummy_cgpu) )\n\t\t{\n\t\t\tpdevbuf_len = strlen(pdevbuf);\n\t\t\tif (unlikely(!pdevbuf_len))\n\t\t\t\tcontinue;\n\t\t\tpdevbuf[pdevbuf_len-1] = '\\0';  // trim newline\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"  %s\", pdevbuf);\n\t\t\t\n\t\t\tif (!strncasecmp(pdevbuf, \"PROCESSOR \", 10))\n\t\t\t\tmaxchipno = max(maxchipno, atoi(&pdevbuf[10]));\n\t\t\telse\n\t\t\tif (!strncasecmp(pdevbuf, \"CHIP PARALLELIZATION: YES @\", 27))\n\t\t\t\tinitdata->parallels[proc] = atoi(&pdevbuf[27]);\n\t\t}\n\t\tinitdata->parallels[proc] = bitforce_chips_to_plan_for(initdata->parallels[proc], maxchipno);\n\t\tparallel += abs(initdata->parallels[proc]);\n\t}\n\tbitforce_close(&dummy_cgpu);\n\t\n\tif (unlikely((procs != 1 || parallel != 1) && initdata->style == BFS_FPGA))\n\t{\n\t\t// Only bitforce_queue supports parallelization and XLINK, so force SC mode and hope for the best\n\t\tapplog(LOG_WARNING, \"SC features detected with non-SC device; this is not supported!\");\n\t\tinitdata->style = BFS_65NM;\n\t}\n\t\n\t// We have a real BitForce!\n\tbitforce = calloc(1, sizeof(*bitforce));\n\tbitforce->drv = &bitforce_drv;\n\tif (initdata->style != BFS_FPGA)\n\t\tbitforce->drv = &bitforce_queue_api;\n\tbitforce->device_path = strdup(devpath);\n\tif (manuf)\n\t\tbitforce->dev_manufacturer = manuf;\n\tbitforce->deven = DEV_ENABLED;\n\tbitforce->procs = parallel;\n\tbitforce->threads = 1;\n\tif (initdata->style != BFS_FPGA)\n\t\tbitforce->cutofftemp = 85;\n\n\tif (s)\n\t\tbitforce->name = s;\n\tbitforce->device_data = initdata;\n\t\n\t// Skip fanspeed until we probe support for it\n\tbitforce->set_device_funcs = &bitforce_set_device_funcs[1];\n\n\tmutex_init(&bitforce->device_mutex);\n\n\treturn add_cgpu(bitforce);\n}\n\nstatic\nbool bitforce_detect_one(const char * const devpath)\n{\n\treturn bitforce_detect_oneof(devpath, &bfllif_vcom);\n}\n\nstatic\nbool bitforce_lowl_probe(const struct lowlevel_device_info * const info)\n{\n#ifdef NEED_BFG_LOWL_PCI\n\tif (info->lowl == &lowl_pci)\n\t\treturn bitforce_detect_oneof(info->path, &bfllif_pci);\n#endif\n#ifdef NEED_BFG_LOWL_MSWIN\n\tif (lowl_mswin_match_guid(info, &WIN_GUID_DEVINTERFACE_MonarchKMDF))\n\t\treturn bitforce_detect_oneof(info->path, &bfllif_vcom);\n#endif\n\treturn vcom_lowl_probe_wrapper(info, bitforce_detect_one);\n}\n\nstruct bitforce_proc_data {\n\tstruct cgpu_info *cgpu;\n\tbool handles_board;  // The first processor handles the queue for the entire board\n};\n\nstatic void bitforce_clear_buffer(struct cgpu_info *);\n\nstatic\nvoid bitforce_comm_error(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\t\n\tdata->noncebuf[0] = '\\0';\n\tapplog(LOG_ERR, \"%\"PRIpreprv\": Comms error\", bitforce->proc_repr);\n\tdev_error(bitforce, REASON_DEV_COMMS_ERROR);\n\tinc_hw_errors_only(thr);\n\tif (!bitforce_open(bitforce))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error reopening %s\", bitforce->dev_repr, bitforce->device_path);\n\t\treturn;\n\t}\n\t/* empty read buffer */\n\tbitforce_clear_buffer(bitforce);\n}\n\nstatic\nvoid __bitforce_clear_buffer(struct cgpu_info * const dev)\n{\n\tchar pdevbuf[0x100];\n\tint count = 0;\n\n\tdo {\n\t\tpdevbuf[0] = '\\0';\n\t\tbitforce_gets(pdevbuf, sizeof(pdevbuf), dev);\n\t} while (pdevbuf[0] && (++count < 10));\n}\n\nstatic void bitforce_clear_buffer(struct cgpu_info *bitforce)\n{\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\t\n\tmutex_lock(mutexp);\n\tif (devdata->is_open)\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Clearing read buffer\", bitforce->proc_repr);\n\t\t__bitforce_clear_buffer(bitforce);\n\t}\n\tmutex_unlock(mutexp);\n}\n\nvoid work_list_del(struct work **head, struct work *);\n\nvoid bitforce_reinit(struct cgpu_info *bitforce)\n{\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tstruct thr_info *thr = bitforce->thr[0];\n\tstruct bitforce_proc_data *procdata = thr->cgpu_data;\n\tconst char *devpath = bitforce->device_path;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\tint retries = 0;\n\tchar pdevbuf[0x100];\n\t\n\tif (!procdata->handles_board)\n\t\treturn;\n\n\tmutex_lock(mutexp);\n\t\n\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Re-initialising\", bitforce->proc_repr);\n\n\tif (devdata->is_open)\n\t{\n\t\tbitforce_close(bitforce);\n\t\tcgsleep_ms(5000);\n\t}\n\n\tbitforce_open(bitforce);\n\tif (unlikely(!devdata->is_open)) {\n\t\tmutex_unlock(mutexp);\n\t\tapplog(LOG_ERR, \"%s: Failed to open %s\", bitforce->dev_repr, devpath);\n\t\treturn;\n\t}\n\n\t__bitforce_clear_buffer(bitforce);\n\t\n\tdo {\n\t\tbitforce_zgx(bitforce, pdevbuf, sizeof(pdevbuf));\n\t\tif (unlikely(!pdevbuf[0])) {\n\t\t\tmutex_unlock(mutexp);\n\t\t\tbitforce_close(bitforce);\n\t\t\tapplog(LOG_ERR, \"%s: Error reading/timeout (ZGX)\", bitforce->dev_repr);\n\t\t\treturn;\n\t\t}\n\n\t\tif (retries++)\n\t\t\tcgsleep_ms(10);\n\t} while (strstr(pdevbuf, \"BUSY\") && (retries * 10 < BITFORCE_TIMEOUT_MS));\n\n\tif (unlikely(!strstr(pdevbuf, \"SHA256\"))) {\n\t\tmutex_unlock(mutexp);\n\t\tbitforce_close(bitforce);\n\t\tapplog(LOG_ERR, \"%s: Didn't recognise BitForce on %s returned: %s\", bitforce->dev_repr, devpath, pdevbuf);\n\t\treturn;\n\t}\n\t\n\tfree((void*)bitforce->name);\n\tbitforce->name = bitforce_copy_name(pdevbuf);\n\n\tbitforce->sleep_ms = data->sleep_ms_default;\n\t\n\tif (bitforce->drv == &bitforce_queue_api)\n\t{\n\t\tstruct work *work, *tmp;\n\t\t\n\t\ttimer_set_delay_from_now(&thr->tv_poll, 0);\n\t\tnotifier_wake(thr->notifier);\n\t\t\n\t\tbitforce_cmd1b(bitforce, pdevbuf, sizeof(pdevbuf), \"ZQX\", 3);\n\t\tDL_FOREACH_SAFE(thr->work_list, work, tmp)\n\t\t\twork_list_del(&thr->work_list, work);\n\t\tdata->queued = 0;\n\t\tdata->ready_to_queue = 0;\n\t\tdata->already_have_results = false;\n\t\tdata->just_flushed = true;\n\t\tthr->queue_full = false;\n\t}\n\n\tmutex_unlock(mutexp);\n\n}\n\nstatic void bitforce_flash_led(struct cgpu_info *bitforce)\n{\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\n\tif (unlikely(!devdata->is_open))\n\t\treturn;\n\n\t/* Do not try to flash the led if we're polling for a result to\n\t * minimise the chance of interleaved results */\n\tif (bitforce->polling)\n\t\treturn;\n\n\t/* It is not critical flashing the led so don't get stuck if we\n\t * can't grab the mutex here */\n\tif (mutex_trylock(mutexp))\n\t\treturn;\n\n\tchar pdevbuf[0x100];\n\tbitforce_cmd1b(bitforce, pdevbuf, sizeof(pdevbuf), \"ZMX\", 3);\n\n\t/* Once we've tried - don't do it until told to again */\n\tbitforce->flash_led = false;\n\n\t/* However, this stops anything else getting a reply\n\t * So best to delay any other access to the BFL */\n\tcgsleep_ms(4000);\n\n\tmutex_unlock(mutexp);\n\n\treturn; // nothing is returned by the BFL\n}\n\nstatic\nfloat my_strtof(const char *nptr, char **endptr)\n{\n\tfloat f = strtof(nptr, endptr);\n\t\n\t/* Cope with older software  that breaks and reads nonsense\n\t * values */\n\tif (f > 100)\n\t\tf = strtod(nptr, endptr);\n\t\n\treturn f;\n}\n\nstatic\nvoid set_float_if_gt_zero(float *var, float value)\n{\n\tif (value > 0)\n\t\t*var = value;\n}\n\nstatic bool bitforce_get_temp(struct cgpu_info *bitforce)\n{\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\tchar pdevbuf[0x40];\n\tchar voltbuf[0x40];\n\tchar *s;\n\tstruct cgpu_info *chip_cgpu;\n\n\tif (unlikely(!devdata->is_open))\n\t\treturn false;\n\n\t/* Do not try to get the temperature if we're polling for a result to\n\t * minimise the chance of interleaved results */\n\tif (bitforce->polling)\n\t\treturn true;\n\n\t// Flash instead of Temp - doing both can be too slow\n\tif (bitforce->flash_led) {\n\t\tbitforce_flash_led(bitforce);\n \t\treturn true;\n\t}\n\n\t/* It is not critical getting temperature so don't get stuck if we\n\t * can't grab the mutex here */\n\tif (mutex_trylock(mutexp))\n\t\treturn false;\n\n\tif (data->style != BFS_FPGA)\n\t{\n\t\tif (unlikely(!data->probed))\n\t\t{\n\t\t\tbitforce_cmd1b(bitforce, voltbuf, sizeof(voltbuf), \"Z9X\", 3);\n\t\t\tif (strncasecmp(voltbuf, \"ERR\", 3))\n\t\t\t{\n\t\t\t\tdata->supports_fanspeed = true;\n\t\t\t\tbitforce->set_device_funcs = bitforce_set_device_funcs;\n\t\t\t}\n\t\t\tdata->probed = true;\n\t\t}\n\t\tbitforce_cmd1b(bitforce, voltbuf, sizeof(voltbuf), \"ZTX\", 3);\n\t}\n\tbitforce_cmd1b(bitforce, pdevbuf, sizeof(pdevbuf), \"ZLX\", 3);\n\tmutex_unlock(mutexp);\n\t\n\tif (data->style != BFS_FPGA && likely(voltbuf[0]))\n\t{\n\t\t// Process voltage info\n\t\t// \"NNNxxx,NNNxxx,NNNxxx\"\n\t\tint n = 1;\n\t\tfor (char *p = voltbuf; p[0]; ++p)\n\t\t\tif (p[0] == ',')\n\t\t\t\t++n;\n\t\t\n\t\tlong *out = malloc(sizeof(long) * n);\n\t\tif (!out)\n\t\t\tgoto skipvolts;\n\t\t\n\t\tn = 0;\n\t\tchar *saveptr, *v;\n\t\tfor (v = strtok_r(voltbuf, \",\", &saveptr); v; v = strtok_r(NULL, \",\", &saveptr))\n\t\t\tout[n++] = strtol(v, NULL, 10);\n\t\t\n\t\tdata->volts_count = 0;\n\t\tfree(data->volts);\n\t\tdata->volts = out;\n\t\tdata->volts_count = n;\n\t}\n\t\nskipvolts:\n\tif (unlikely(!pdevbuf[0])) {\n\t\tstruct thr_info *thr = bitforce->thr[0];\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Error: Get temp returned empty string/timed out\", bitforce->proc_repr);\n\t\tinc_hw_errors_only(thr);\n\t\treturn false;\n\t}\n\n\tif ((!strncasecmp(pdevbuf, \"TEMP\", 4)) && (s = strchr(pdevbuf + 4, ':'))) {\n\t\tfloat temp = my_strtof(s + 1, &s);\n\t\t\n\t\tset_float_if_gt_zero(&data->temp[0], temp);\n\t\tfor ( ; s[0]; ++s)\n\t\t{\n\t\t\tif (!strncasecmp(s, \"TEMP\", 4) && (s = strchr(&s[4], ':')))\n\t\t\t{\n\t\t\t\tfloat temp2 = my_strtof(s + 1, &s);\n\t\t\t\tset_float_if_gt_zero(&data->temp[1], temp2);\n\t\t\t\tif (temp2 > temp)\n\t\t\t\t\ttemp = temp2;\n\t\t\t}\n\t\t}\n\n\t\tif (temp > 0)\n\t\t{\n\t\t\tchip_cgpu = bitforce;\n\t\t\tfor (int i = 0; i < data->parallel; ++i, (chip_cgpu = chip_cgpu->next_proc))\n\t\t\t\tchip_cgpu->temp = temp;\n\t\t}\n\t} else {\n\t\tstruct thr_info *thr = bitforce->thr[0];\n\t\t/* Use the temperature monitor as a kind of watchdog for when\n\t\t * our responses are out of sync and flush the buffer to\n\t\t * hopefully recover */\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Garbled response probably throttling, clearing buffer\", bitforce->proc_repr);\n\t\tdev_error(bitforce, REASON_DEV_THROTTLE);\n\t\t/* Count throttling episodes as hardware errors */\n\t\tinc_hw_errors_only(thr);\n\t\tbitforce_clear_buffer(bitforce);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline\nvoid dbg_block_data(struct cgpu_info *bitforce)\n{\n\tif (!opt_debug)\n\t\treturn;\n\t\n\tstruct bitforce_data *data = bitforce->device_data;\n\tchar s[89];\n\tbin2hex(s, &data->next_work_ob[8], 44);\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": block data: %s\", bitforce->proc_repr, s);\n}\n\nstatic void bitforce_change_mode(struct cgpu_info *, enum bitforce_proto);\n\nstatic\nbool bitforce_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tunsigned char *ob_ms = &data->next_work_ob[8];\n\tunsigned char *ob_dt = &ob_ms[32];\n\t\n\t// If polling job_start, cancel it\n\tif (data->poll_func == 1)\n\t{\n\t\tthr->tv_poll.tv_sec = -1;\n\t\tdata->poll_func = 0;\n\t}\n\t\n\tmemcpy(ob_ms, work->midstate, 32);\n\tmemcpy(ob_dt, work->data + 64, 12);\n\tswitch (data->proto)\n\t{\n\t\tcase BFP_BQUEUE:\n\t\t\tquithere(1, \"%\"PRIpreprv\": Impossible BFP_BQUEUE\", bitforce->proc_repr);\n\t\tcase BFP_PQUEUE:\n\t\t\tquithere(1, \"%\"PRIpreprv\": Impossible BFP_PQUEUE\", bitforce->proc_repr);\n\t\tcase BFP_RANGE:\n\t\t{\n\t\t\tuint32_t *ob_nonce = (uint32_t*)&(ob_dt[32]);\n\t\t\tob_nonce[0] = htobe32(work->blk.nonce);\n\t\t\tob_nonce[1] = htobe32(work->blk.nonce + bitforce->nonces);\n\t\t\t// FIXME: if nonce range fails... we didn't increment enough\n\t\t\twork->blk.nonce += bitforce->nonces + 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase BFP_WORK:\n\t\t\twork->blk.nonce = 0xffffffff;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nvoid bitforce_change_mode(struct cgpu_info *bitforce, enum bitforce_proto proto)\n{\n\tstruct bitforce_data *data = bitforce->device_data;\n\t\n\tif (data->proto == proto)\n\t\treturn;\n\tif (data->proto == BFP_RANGE)\n\t{\n\t\tbitforce->nonces = 0xffffffff;\n\t\tbitforce->sleep_ms *= 5;\n\t\tdata->sleep_ms_default *= 5;\n\t\tswitch (proto)\n\t\t{\n\t\t\tcase BFP_WORK:\n\t\t\t\tdata->next_work_cmd = \"ZDX\";\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\tif (data->style != BFS_FPGA)\n\t\t{\n\t\t\t// \"S|---------- MidState ----------||-DataTail-|E\"\n\t\t\tdata->next_work_ob[7] = 45;\n\t\t\tdata->next_work_ob[8+32+12] = '\\xAA';\n\t\t\tdata->next_work_obsz = 46;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// \">>>>>>>>|---------- MidState ----------||-DataTail-|>>>>>>>>\"\n\t\t\tmemset(&data->next_work_ob[8+32+12], '>', 8);\n\t\t\tdata->next_work_obsz = 60;\n\t\t}\n\t}\n\telse\n\tif (proto == BFP_RANGE)\n\t{\n\t\t/* Split work up into 1/5th nonce ranges */\n\t\tbitforce->nonces = 0x33333332;\n\t\tbitforce->sleep_ms /= 5;\n\t\tdata->sleep_ms_default /= 5;\n\t\tdata->next_work_cmd = \"ZPX\";\n\t\tif (data->style != BFS_FPGA)\n\t\t{\n\t\t\tdata->next_work_ob[7] = 53;\n\t\t\tdata->next_work_obsz = 54;\n\t\t}\n\t\telse\n\t\t\tdata->next_work_obsz = 68;\n\t}\n\tdata->proto = proto;\n\tbitforce->kname = protonames[proto];\n}\n\nstatic\nvoid bitforce_job_start(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\tunsigned char *ob = data->next_work_obs;\n\tchar pdevbuf[0x100];\n\tstruct timeval tv_now;\n\n\tdata->result_busy_polled = 0;\n\t\n\tif (data->queued)\n\t{\n\t\tuint32_t delay;\n\t\t\n\t\t// get_results collected more accurate job start time\n\t\tmt_job_transition(thr);\n\t\tjob_start_complete(thr);\n\t\tdata->queued = 0;\n\t\tdelay = (uint32_t)bitforce->sleep_ms * 1000;\n\t\tif (unlikely(data->already_have_results))\n\t\t\tdelay = 0;\n\t\ttimer_set_delay(&thr->tv_morework, &bitforce->work_start_tv, delay);\n\t\treturn;\n\t}\n\n\tif (unlikely(!devdata->is_open))\n\t\tgoto commerr;\nre_send:\n\tmutex_lock(mutexp);\n\tbitforce_cmd2(bitforce, pdevbuf, sizeof(pdevbuf), data->next_work_cmd, ob, data->next_work_obsz);\n\tif (!pdevbuf[0] || !strncasecmp(pdevbuf, \"B\", 1)) {\n\t\tmutex_unlock(mutexp);\n\t\tcgtime(&tv_now);\n\t\ttimer_set_delay(&thr->tv_poll, &tv_now, WORK_CHECK_INTERVAL_MS * 1000);\n\t\tdata->poll_func = 1;\n\t\treturn;\n\t} else if (unlikely(strncasecmp(pdevbuf, \"OK\", 2))) {\n\t\tmutex_unlock(mutexp);\n\t\tswitch (data->proto)\n\t\t{\n\t\t\tcase BFP_RANGE:\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Does not support nonce range, disabling\", bitforce->proc_repr);\n\t\t\t\tbitforce_change_mode(bitforce, BFP_WORK);\n\t\t\t\tgoto re_send;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Error: Send work reports: %s\", bitforce->proc_repr, pdevbuf);\n\t\tgoto commerr;\n\t}\n\n\tmt_job_transition(thr);\n\tmutex_unlock(mutexp);\n\n\tdbg_block_data(bitforce);\n\n\tcgtime(&tv_now);\n\tbitforce->work_start_tv = tv_now;\n\t\n\ttimer_set_delay(&thr->tv_morework, &tv_now, bitforce->sleep_ms * 1000);\n\t\n\tjob_start_complete(thr);\n\treturn;\n\ncommerr:\n\tbitforce_comm_error(thr);\n\tjob_start_abort(thr, true);\n}\n\nstatic char _discardedbuf[0x10];\n\nstatic\nint bitforce_zox(struct thr_info *thr, const char *cmd, int * const out_inprog)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\tchar *pdevbuf = &data->noncebuf[0];\n\tint count;\n\t\n\tmutex_lock(mutexp);\n\tbitforce_cmd1b(bitforce, pdevbuf, sizeof(data->noncebuf), cmd, 3);\n\tif (!strncasecmp(pdevbuf, \"INPROCESS:\", 10))\n\t{\n\t\tif (out_inprog)\n\t\t\t*out_inprog = atoi(&pdevbuf[10]);\n\t\tbitforce_gets(pdevbuf, sizeof(data->noncebuf), bitforce);\n\t}\n\telse\n\tif (out_inprog)\n\t\t*out_inprog = -1;\n\tif (!strncasecmp(pdevbuf, \"COUNT:\", 6))\n\t{\n\t\tcount = atoi(&pdevbuf[6]);\n\t\tsize_t cls = strlen(pdevbuf);\n\t\tchar *pmorebuf = &pdevbuf[cls];\n\t\tsize_t szleft = sizeof(data->noncebuf) - cls, sz;\n\t\t\n\t\tif (count && data->queued)\n\t\t\tcgtime(&bitforce->work_start_tv);\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tbitforce_gets(pmorebuf, szleft, bitforce);\n\t\t\tif (!strncasecmp(pmorebuf, \"OK\", 2))\n\t\t\t{\n\t\t\t\tpmorebuf[0] = '\\0';  // process expects only results\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = strlen(pmorebuf);\n\t\t\tif (!sz)\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Timeout during %s\", bitforce->proc_repr, cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tszleft -= sz;\n\t\t\tpmorebuf += sz;\n\t\t\tif (unlikely(szleft < BITFORCE_QRESULT_LINE_LEN))\n\t\t\t{\n\t\t\t\t// Out of buffer space somehow :(\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Ran out of buffer space for results, discarding extra data\", bitforce->proc_repr);\n\t\t\t\tpmorebuf = _discardedbuf;\n\t\t\t\tszleft = sizeof(_discardedbuf);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcount = -1;\n\tmutex_unlock(mutexp);\n\t\n\treturn count;\n}\n\nstatic inline char *next_line(char *);\n\nstatic\nvoid bitforce_job_get_results(struct thr_info *thr, struct work *work)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tunsigned int delay_time_ms;\n\tstruct timeval elapsed;\n\tstruct timeval now;\n\tchar *pdevbuf = &data->noncebuf[0];\n\tbool stale;\n\tint count;\n\n\tcgtime(&now);\n\ttimersub(&now, &bitforce->work_start_tv, &elapsed);\n\tbitforce->wait_ms = tv_to_ms(elapsed);\n\tbitforce->polling = true;\n\t\n\tif (unlikely(!devdata->is_open))\n\t\tgoto commerr;\n\n\tstale = stale_work(work, true);\n\t\n\tif (unlikely(bitforce->wait_ms < bitforce->sleep_ms))\n\t{\n\t\t// We're likely here because of a work restart\n\t\t// Since Bitforce cannot stop a work without losing results, only do it if the current job is finding stale shares\n\t\tif (!stale)\n\t\t{\n\t\t\tdelay_time_ms = bitforce->sleep_ms - bitforce->wait_ms;\n\t\t\ttimer_set_delay(&thr->tv_poll, &now, delay_time_ms * 1000);\n\t\t\tdata->poll_func = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tif (data->already_have_results)\n\t\t{\n\t\t\tdata->already_have_results = false;\n\t\t\tstrcpy(pdevbuf, \"COUNT:0\");\n\t\t\tcount = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tconst char * const cmd = \"ZFX\";\n\t\tcount = bitforce_zox(thr, cmd, NULL);\n\n\t\tcgtime(&now);\n\t\ttimersub(&now, &bitforce->work_start_tv, &elapsed);\n\n\t\tif (elapsed.tv_sec >= BITFORCE_LONG_TIMEOUT_S) {\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": took %lums - longer than %lums\", bitforce->proc_repr,\n\t\t\t\ttv_to_ms(elapsed), (unsigned long)BITFORCE_LONG_TIMEOUT_MS);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (count > 0)\n\t\t{\n\t\t\t// Check that queue results match the current work\n\t\t\t// Also, if there are results from the next work, short-circuit this wait\n\t\t\tunsigned char midstate[32], datatail[12];\n\t\t\tchar *p;\n\t\t\tint i;\n\t\t\t\n\t\t\tp = pdevbuf;\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t\tp = next_line(p);\n\t\t\t\thex2bin(midstate, p, 32);\n\t\t\t\thex2bin(datatail, &p[65], 12);\n\t\t\t\tif (!(memcmp(work->midstate, midstate, 32) || memcmp(&work->data[64], datatail, 12)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == count)\n\t\t\t{\n\t\t\t\t// Didn't find the one we're waiting on\n\t\t\t\t// Must be extra stuff in the queue results\n\t\t\t\tchar xmid[65];\n\t\t\t\tchar xdt[25];\n\t\t\t\tbin2hex(xmid, work->midstate, 32);\n\t\t\t\tbin2hex(xdt, &work->data[64], 12);\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Found extra garbage in queue results: %s\",\n\t\t\t\t       bitforce->proc_repr, pdevbuf);\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": ...while waiting on: %s,%s\",\n\t\t\t\t       bitforce->proc_repr, xmid, xdt);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse\n\t\t\tif (i == count - 1)\n\t\t\t\t// Last one found is what we're looking for\n\t\t\t{}\n\t\t\telse\n\t\t\t\t// We finished the next job too!\n\t\t\t\tdata->already_have_results = true;\n\t\t}\n\t\t\n\t\tif (!count)\n\t\t\tgoto noqr;\n\t\tif (pdevbuf[0] && strncasecmp(pdevbuf, \"B\", 1)) /* BFL does not respond during throttling */\n\t\t\tbreak;\n\n\t\tdata->result_busy_polled = bitforce->wait_ms;\n\t\t\n\t\tif (stale)\n\t\t{\n\t\t\tapplog(LOG_NOTICE, \"%\"PRIpreprv\": Abandoning stale search to restart\",\n\t\t\t       bitforce->proc_repr);\n\t\t\tgoto out;\n\t\t}\n\nnoqr:\n\t\tdata->result_busy_polled = bitforce->wait_ms;\n\t\t\n\t\t/* if BFL is throttling, no point checking so quickly */\n\t\tdelay_time_ms = (pdevbuf[0] ? BITFORCE_CHECK_INTERVAL_MS : 2 * WORK_CHECK_INTERVAL_MS);\n\t\ttimer_set_delay(&thr->tv_poll, &now, delay_time_ms * 1000);\n\t\tdata->poll_func = 2;\n\t\treturn;\n\t}\n\n\tif (count < 0 && pdevbuf[0] == 'N')\n\t\tcount = strncasecmp(pdevbuf, \"NONCE-FOUND\", 11) ? 1 : 0;\n\t// At this point, 'count' is:\n\t//   negative, in case of some kind of error\n\t//   zero, if NO-NONCE (FPGA either completed with no results, or rebooted)\n\t//   positive, if at least one job completed successfully\n\n\tif (elapsed.tv_sec > BITFORCE_TIMEOUT_S) {\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": took %lums - longer than %lums\", bitforce->proc_repr,\n\t\t\ttv_to_ms(elapsed), (unsigned long)BITFORCE_TIMEOUT_MS);\n\t\tdev_error(bitforce, REASON_DEV_OVER_HEAT);\n\t\tinc_hw_errors_only(thr);\n\n\t\t/* If the device truly throttled, it didn't process the job and there\n\t\t * are no results. But check first, just in case we're wrong about it\n\t\t * throttling.\n\t\t */\n\t\tif (count > 0)\n\t\t\tgoto out;\n\t} else if (count >= 0) {/* Hashing complete (NONCE-FOUND or NO-NONCE) */\n\t\t/* Simple timing adjustment. Allow a few polls to cope with\n\t\t * OS timer delays being variably reliable. wait_ms will\n\t\t * always equal sleep_ms when we've waited greater than or\n\t\t * equal to the result return time.*/\n\t\tdelay_time_ms = bitforce->sleep_ms;\n\n\t\tif (!data->result_busy_polled)\n\t\t{\n\t\t\t// No busy polls before results received\n\t\t\tif (bitforce->wait_ms > delay_time_ms + (WORK_CHECK_INTERVAL_MS * 8))\n\t\t\t\t// ... due to poll being rather late; ignore it as an anomaly\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got results on first poll after %ums, later than scheduled %ums (ignoring)\",\n\t\t\t\t       bitforce->proc_repr, bitforce->wait_ms, delay_time_ms);\n\t\t\telse\n\t\t\tif (bitforce->sleep_ms > data->sleep_ms_default + (BITFORCE_CHECK_INTERVAL_MS * 0x20))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got results on first poll after %ums, on delayed schedule %ums; Wait time changed to: %ums (default sch)\",\n\t\t\t\t       bitforce->proc_repr, bitforce->wait_ms, delay_time_ms, data->sleep_ms_default);\n\t\t\t\tbitforce->sleep_ms = data->sleep_ms_default;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got results on first poll after %ums, on default schedule %ums; Wait time changed to: %ums (check interval)\",\n\t\t\t\t       bitforce->proc_repr, bitforce->wait_ms, delay_time_ms, BITFORCE_CHECK_INTERVAL_MS);\n\t\t\t\tbitforce->sleep_ms = BITFORCE_CHECK_INTERVAL_MS;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (data->result_busy_polled - bitforce->sleep_ms > WORK_CHECK_INTERVAL_MS)\n\t\t\t{\n\t\t\t\tbitforce->sleep_ms = data->result_busy_polled - (WORK_CHECK_INTERVAL_MS / 2);\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got results on Nth poll after %ums (busy poll at %ums, sch'd %ums); Wait time changed to: %ums\",\n\t\t\t\t       bitforce->proc_repr, bitforce->wait_ms, data->result_busy_polled, delay_time_ms, bitforce->sleep_ms);\n\t\t\t}\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got results on Nth poll after %ums (busy poll at %ums, sch'd %ums); Wait time unchanged\",\n\t\t\t\t       bitforce->proc_repr, bitforce->wait_ms, data->result_busy_polled, delay_time_ms);\n\t\t}\n\n\t\t/* Work out the average time taken. Float for calculation, uint for display */\n\t\tbitforce->avg_wait_f += (tv_to_ms(elapsed) - bitforce->avg_wait_f) / TIME_AVG_CONSTANT;\n\t\tbitforce->avg_wait_d = (unsigned int) (bitforce->avg_wait_f + 0.5);\n\t}\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": waited %dms until %s\", bitforce->proc_repr, bitforce->wait_ms, pdevbuf);\n\tif (count < 0 && strncasecmp(pdevbuf, \"I\", 1)) {\n\t\tinc_hw_errors_only(thr);\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Error: Get result reports: %s\", bitforce->proc_repr, pdevbuf);\n\t\tbitforce_clear_buffer(bitforce);\n\t}\nout:\n\tbitforce->polling = false;\n\tjob_results_fetched(thr);\n\treturn;\n\ncommerr:\n\tbitforce_comm_error(thr);\n\tgoto out;\n}\n\nstatic\nvoid bitforce_process_result_nonces(struct thr_info *thr, struct work *work, char *pnoncebuf)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tuint32_t nonce;\n\t\n\twhile (1) {\n\t\thex2bin((void*)&nonce, pnoncebuf, 4);\n\t\tnonce = be32toh(nonce);\n\t\tif (unlikely(data->proto == BFP_RANGE && (nonce >= work->blk.nonce ||\n\t\t\t/* FIXME: blk.nonce is probably moved on quite a bit now! */\n\t\t\t(work->blk.nonce > 0 && nonce < work->blk.nonce - bitforce->nonces - 1)))) {\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Disabling broken nonce range support\", bitforce->proc_repr);\n\t\t\t\tbitforce_change_mode(bitforce, BFP_WORK);\n\t\t}\n\t\t\t\n\t\tsubmit_nonce(thr, work, nonce);\n\t\tif (strncmp(&pnoncebuf[8], \",\", 1))\n\t\t\tbreak;\n\t\tpnoncebuf += 9;\n\t}\n}\n\nstatic\nbool bitforce_process_qresult_line_i(struct thr_info *thr, char *midstate, char *datatail, char *buf, struct work *work)\n{\n\tif (!work)\n\t\treturn false;\n\tif (memcmp(work->midstate, midstate, 32))\n\t\treturn false;\n\tif (memcmp(&work->data[64], datatail, 12))\n\t\treturn false;\n\t\n\tchar *end;\n\tif (strtol(&buf[90], &end, 10))\n\t\tbitforce_process_result_nonces(thr, work, &end[1]);\n\t\n\treturn true;\n}\n\nstatic\nvoid bitforce_process_qresult_line(struct thr_info *thr, char *buf, struct work *work)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tchar midstate[32], datatail[12];\n\t\n\thex2bin((void*)midstate, buf, 32);\n\thex2bin((void*)datatail, &buf[65], 12);\n\t\n\tif (!( bitforce_process_qresult_line_i(thr, midstate, datatail, buf, work)\n\t    || bitforce_process_qresult_line_i(thr, midstate, datatail, buf, thr->work)\n\t    || bitforce_process_qresult_line_i(thr, midstate, datatail, buf, thr->prev_work)\n\t    || bitforce_process_qresult_line_i(thr, midstate, datatail, buf, thr->next_work) ))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to find work for queued results\", bitforce->proc_repr);\n\t\tinc_hw_errors_only(thr);\n\t}\n}\n\nstatic inline\nchar *next_line(char *in)\n{\n\twhile (in[0] && (in++)[0] != '\\n')\n\t{}\n\treturn in;\n}\n\nstatic\nint64_t bitforce_job_process_results(struct thr_info *thr, struct work *work, __maybe_unused bool stopping)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tchar *pnoncebuf = &data->noncebuf[0];\n\tint count;\n\t\n\tif (!strncasecmp(pnoncebuf, \"NO-\", 3))\n\t\treturn bitforce->nonces;   /* No valid nonce found */\n\t\n\tif (!strncasecmp(pnoncebuf, \"NONCE-FOUND\", 11))\n\t{\n\t\tbitforce_process_result_nonces(thr, work, &pnoncebuf[12]);\n\t\tcount = 1;\n\t}\n\telse\n\tif (!strncasecmp(pnoncebuf, \"COUNT:\", 6))\n\t{\n\t\tcount = 0;\n\t\tpnoncebuf = next_line(pnoncebuf);\n\t\twhile (pnoncebuf[0])\n\t\t{\n\t\t\tbitforce_process_qresult_line(thr, pnoncebuf, work);\n\t\t\t++count;\n\t\t\tpnoncebuf = next_line(pnoncebuf);\n\t\t}\n\t}\n\telse\n\t\treturn 0;\n\n\t// FIXME: This might have changed in the meantime (new job start, or broken)\n\treturn bitforce->nonces * count;\n}\n\nstatic void bitforce_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tbitforce_close(bitforce);\n}\n\nstatic void biforce_thread_enable(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\n\tbitforce_reinit(bitforce);\n}\n\nstatic bool bitforce_get_stats(struct cgpu_info *bitforce)\n{\n\tstruct bitforce_proc_data *procdata = bitforce->thr[0]->cgpu_data;\n\t\n\tif (!procdata->handles_board)\n\t\treturn true;\n\treturn bitforce_get_temp(bitforce);\n}\n\nstatic bool bitforce_identify(struct cgpu_info *bitforce)\n{\n\tbitforce->flash_led = true;\n\treturn true;\n}\n\nstatic\nvoid bitforce_zero_stats(struct cgpu_info * const proc)\n{\n\tstruct bitforce_data *data = proc->device_data;\n\t\n\t// These don't get cleared when not-read, so we clear them here\n\tdata->volts_count = 0;\n\tdata->temp[0] = data->temp[1] = 0;\n\tfree(data->volts);\n\tdata->volts = NULL;\n\t\n\tproc->avg_wait_f = 0;\n}\n\nstatic bool bitforce_thread_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data;\n\tstruct bitforce_proc_data *procdata;\n\tstruct bitforce_init_data *initdata = bitforce->device_data;\n\tconst enum bitforce_style style = initdata->style;\n\tint xlink_id = 0, boardno = 0;\n\tstruct bitforce_proc_data *first_on_this_board;\n\tchar buf[100];\n\t\n\tfor ( ; bitforce; bitforce = bitforce->next_proc)\n\t{\n\t\tthr = bitforce->thr[0];\n\t\t\n\t\tif (unlikely(xlink_id > 30))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to find XLINK address\", bitforce->proc_repr);\n\t\t\tdev_error(bitforce, REASON_THREAD_FAIL_INIT);\n\t\t\tbitforce->reinit_backoff = 1e10;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbitforce->sleep_ms = BITFORCE_SLEEP_MS;\n\t\tbitforce->device_data = data = malloc(sizeof(*data));\n\t\t*data = (struct bitforce_data){\n\t\t\t.lowlif = initdata->lowlif,\n\t\t\t.xlink_id = xlink_id,\n\t\t\t.next_work_ob = \">>>>>>>>|---------- MidState ----------||-DataTail-||Nonces|>>>>>>>>\",\n\t\t\t.proto = BFP_RANGE,\n\t\t\t.style = style,\n\t\t\t.sleep_ms_default = BITFORCE_SLEEP_MS,\n\t\t\t.parallel = abs(initdata->parallels[boardno]),\n\t\t\t.parallel_protocol = (initdata->parallels[boardno] != -1),\n\t\t\t.max_queueid = initdata->max_queueid,\n\t\t};\n\t\tthr->cgpu_data = procdata = malloc(sizeof(*procdata));\n\t\t*procdata = (struct bitforce_proc_data){\n\t\t\t.handles_board = true,\n\t\t\t.cgpu = bitforce,\n\t\t};\n\t\tif (style != BFS_FPGA)\n\t\t{\n\t\t\t// \".......S|---------- MidState ----------||-DataTail-||Nonces|E\"\n\t\t\tdata->next_work_ob[8+32+12+8] = '\\xAA';\n\t\t\tdata->next_work_obs = &data->next_work_ob[7];\n\t\t\t\n\t\t\tswitch (style)\n\t\t\t{\n\t\t\t\tcase BFS_FPGA:  // impossible\n\t\t\t\tcase BFS_65NM:\n\t\t\t\t\tdata->max_queue_at_once = BITFORCE_MAX_BQUEUE_AT_ONCE_65NM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BFS_28NM:\n\t\t\t\t\tdata->max_queue_at_once = BITFORCE_MAX_BQUEUE_AT_ONCE_28NM;\n\t\t\t}\n\t\t\t\n\t\t\tif (bitforce->drv == &bitforce_queue_api)\n\t\t\t{\n\t\t\t\tbitforce_change_mode(bitforce, data->parallel_protocol ? BFP_PQUEUE : BFP_BQUEUE);\n\t\t\t\tbitforce->sleep_ms = data->sleep_ms_default = 100;\n\t\t\t\ttimer_set_delay_from_now(&thr->tv_poll, 0);\n\t\t\t\tdata->queued_max = data->parallel * 2;\n\t\t\t\tif (data->queued_max < BITFORCE_MIN_QUEUED_MAX)\n\t\t\t\t\tdata->queued_max = BITFORCE_MIN_QUEUED_MAX;\n\t\t\t\tif (data->queued_max > initdata->queue_depth)\n\t\t\t\t\tdata->queued_max = initdata->queue_depth;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbitforce_change_mode(bitforce, BFP_WORK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata->next_work_obs = &data->next_work_ob[0];\n\t\t\t\n\t\t\t// Unconditionally change away from cold-initialized BFP_RANGE, to allow for setting up other variables\n\t\t\tbitforce_change_mode(bitforce, BFP_WORK);\n\t\t\t/* Initially enable support for nonce range and disable it later if it\n\t\t\t * fails */\n\t\t\tif (opt_bfl_noncerange)\n\t\t\t\tbitforce_change_mode(bitforce, BFP_RANGE);\n\t\t}\n\t\t\n\t\tif (initdata->scan_interval_ms)\n\t\t\tbitforce->sleep_ms = initdata->scan_interval_ms;\n\t\t\n\t\tbitforce->status = LIFE_INIT2;\n\t\t\n\t\tfirst_on_this_board = procdata;\n\t\tfor (int proc = 1; proc < data->parallel; ++proc)\n\t\t{\n\t\t\tbitforce = bitforce->next_proc;\n\t\t\tassert(bitforce);\n\t\t\tthr = bitforce->thr[0];\n\t\t\t\n\t\t\tthr->queue_full = true;\n\t\t\tthr->cgpu_data = procdata = malloc(sizeof(*procdata));\n\t\t\t*procdata = *first_on_this_board;\n\t\t\tprocdata->handles_board = false;\n\t\t\tprocdata->cgpu = bitforce;\n\t\t\tbitforce->device_data = data;\n\t\t\tbitforce->status = LIFE_INIT2;\n\t\t\tbitforce->kname = first_on_this_board->cgpu->kname;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"%s: Board %d: %\"PRIpreprv\"-%\"PRIpreprv, bitforce->dev_repr, boardno, first_on_this_board->cgpu->proc_repr, bitforce->proc_repr);\n\t\t\n\t\t++boardno;\n\t\twhile (xlink_id < 31 && !(initdata->devmask & (1 << ++xlink_id)))\n\t\t{}\n\t}\n\t\n\tbitforce = thr->cgpu->device;\n\n\tfree(initdata->parallels);\n\tfree(initdata);\n\n\tif (unlikely(!bitforce_open(bitforce)))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to open %s\", bitforce->dev_repr, bitforce->device_path);\n\t\treturn false;\n\t}\n\tapplog(LOG_INFO, \"%s: Opened %s\", bitforce->dev_repr, bitforce->device_path);\n\t\n\tif (style != BFS_FPGA)\n\t{\n\t\t// Clear job and results queue, to start fresh; ignore response\n\t\tfor (int pass = 0, inprog = 1, tmp_inprog; pass < 500 && inprog; ++pass)\n\t\t{\n\t\t\tif (pass)\n\t\t\t\tcgsleep_ms(10);\n\t\t\tapplog(LOG_DEBUG, \"%s: Flushing job and results queue... pass %d\", bitforce->dev_repr, pass);\n\t\t\t\n\t\t\tint last_xlink_id = -1;\n\t\t\tinprog = 0;\n\t\t\tfor ( ; bitforce; bitforce = bitforce->next_proc)\n\t\t\t{\n\t\t\t\tstruct bitforce_data * const data = bitforce->device_data;\n\t\t\t\tif (data->xlink_id == last_xlink_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tlast_xlink_id = data->xlink_id;\n\t\t\t\tthr = bitforce->thr[0];\n\t\t\t\tif (!pass)\n\t\t\t\t\tbitforce_cmd1b(bitforce, buf, sizeof(buf), \"ZQX\", 3);\n\t\t\t\tbitforce_zox(thr, \"ZOX\", &tmp_inprog);\n\t\t\t\tif (tmp_inprog == 1)\n\t\t\t\t\tinprog = 1;\n\t\t\t}\n\t\t\tbitforce = thr->cgpu->device;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"%s: Flushing job and results queue DONE\", bitforce->dev_repr);\n\t}\n\t\n\treturn true;\n}\n\nstatic\nconst char *bitforce_set_voltage(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success)\n{\n\tpthread_mutex_t *mutexp = &proc->device->device_mutex;\n\tchar cmd[3] = \"VFX\";\n\t\n\tconst unsigned mV = round(atof(newvalue) * 1000);\n\tstatic const unsigned n[] = {750, 730, 720, 700, 680, 670, 662, 650, 643, 630, 620, 600, 580, 560, 550, 540};\n\tfor (int i = 0; ; ++i)\n\t{\n\t\tif (i >= 0x10)\n\t\t\treturn \"Voltage must be from 0.54 to 0.75\";\n\t\tif (mV >= n[i])\n\t\t{\n\t\t\tcmd[1] -= i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tmutex_lock(mutexp);\n\tbitforce_cmd1b(proc, replybuf, 8000, cmd, 3);\n\tmutex_unlock(mutexp);\n\t\n\tif (!strncasecmp(replybuf, \"OK\", 2))\n\t\treturn NULL;\n\t\n\treturn replybuf;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid bitforce_tui_wlogprint_choices(struct cgpu_info *cgpu)\n{\n\tstruct bitforce_data *data = cgpu->device_data;\n\tif (data->supports_fanspeed)\n\t\twlogprint(\"[F]an control \");\n\twlogprint(\"[V]oltage \");\n}\n\nstatic\nconst char *bitforce_tui_handle_choice(struct cgpu_info *cgpu, int input)\n{\n\tstruct bitforce_data *data = cgpu->device_data;\n\tpthread_mutex_t *mutexp;\n\tstatic char replybuf[0x100];\n\t\n\tif (!data->supports_fanspeed)\n\t\treturn NULL;\n\tswitch (input)\n\t{\n\t\tcase 'f': case 'F':\n\t\t{\n\t\t\tint fanspeed;\n\t\t\tchar *intvar;\n\n\t\t\tintvar = curses_input(\"Set fan speed (range 0-5 for low to fast or 9 for auto)\");\n\t\t\tif (!intvar)\n\t\t\t\treturn \"Invalid fan speed\\n\";\n\t\t\tfanspeed = atoi(intvar);\n\t\t\tfree(intvar);\n\t\t\tif ((fanspeed < 0 || fanspeed > 5) && fanspeed != 9)\n\t\t\t\treturn \"Invalid fan speed\\n\";\n\t\t\t\n\t\t\tchar cmd[4] = \"Z0X\";\n\t\t\tcmd[1] += fanspeed;\n\t\t\tmutexp = &cgpu->device->device_mutex;\n\t\t\tmutex_lock(mutexp);\n\t\t\tbitforce_cmd1b(cgpu, replybuf, sizeof(replybuf), cmd, 3);\n\t\t\tmutex_unlock(mutexp);\n\t\t\treturn replybuf;\n\t\t}\n\t\tcase 'v': case 'V':\n\t\t\treturn proc_set_device_tui_wrapper(cgpu, NULL, bitforce_set_voltage, \"Set voltage (0.54-0.75 V)\", \"Requested voltage change\");\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid bitforce_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct bitforce_data *data = cgpu->device_data;\n\tif (data->temp[0] > 0 && data->temp[1] > 0)\n\t\twlogprint(\"Temperatures: %4.1fC %4.1fC\\n\", data->temp[0], data->temp[1]);\n\tif (data->volts_count)\n\t{\n\t\t// -> \"NNN.xxx / NNN.xxx / NNN.xxx\"\n\t\tsize_t sz = (data->volts_count * 10) + 1;\n\t\tchar buf[sz];\n\t\tchar *s = buf;\n\t\tint rv = 0;\n\t\tfor (int i = 0; i < data->volts_count; ++i)\n\t\t{\n\t\t\tlong v = data->volts[i];\n\t\t\t_SNP(\"%ld.%03d / \", v / 1000, (int)(v % 1000));\n\t\t}\n\t\tif (rv >= 3 && s[-2] == '/')\n\t\t\ts[-3] = '\\0';\n\t\twlogprint(\"Voltages: %s\\n\", buf);\n\t}\n}\n#endif\n\nstatic struct api_data *bitforce_drv_stats(struct cgpu_info *cgpu)\n{\n\tstruct bitforce_data *data = cgpu->device_data;\n\tstruct api_data *root = NULL;\n\n\t// Warning, access to these is not locked - but we don't really\n\t// care since hashing performance is way more important than\n\t// locking access to displaying API debug 'stats'\n\t// If locking becomes an issue for any of them, use copy_data=true also\n\troot = api_add_uint(root, \"Sleep Time\", &(cgpu->sleep_ms), false);\n\tif (data->proto != BFP_BQUEUE && data->proto != BFP_PQUEUE)\n\t\troot = api_add_uint(root, \"Avg Wait\", &(cgpu->avg_wait_d), false);\n\tif (data->temp[0] > 0 && data->temp[1] > 0)\n\t{\n\t\troot = api_add_temp(root, \"Temperature0\", &(data->temp[0]), false);\n\t\troot = api_add_temp(root, \"Temperature1\", &(data->temp[1]), false);\n\t}\n\t\n\tfor (int i = 0; i < data->volts_count; ++i)\n\t{\n\t\tfloat voltage = data->volts[i];\n\t\tchar key[] = \"VoltageNN\";\n\t\tsnprintf(&key[7], 3, \"%d\", i);\n\t\tvoltage /= 1e3;\n\t\troot = api_add_volts(root, key, &voltage, true);\n\t}\n\n\treturn root;\n}\n\nvoid bitforce_poll(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tint poll = data->poll_func;\n\tthr->tv_poll.tv_sec = -1;\n\tdata->poll_func = 0;\n\tswitch (poll)\n\t{\n\t\tcase 1:\n\t\t\tbitforce_job_start(thr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbitforce_job_get_results(thr, thr->work);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Unexpected poll from device API!\", thr->cgpu->proc_repr);\n\t}\n}\n\nstatic\nconst char *bitforce_set_fanmode(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bitforce_data *data = proc->device_data;\n\tpthread_mutex_t *mutexp = &proc->device->device_mutex;\n\t\n\t{\n\t\tif (!data->supports_fanspeed)\n\t\t{\n\t\t\tsprintf(replybuf, \"fanmode not supported\");\n\t\t\treturn replybuf;\n\t\t}\n\t\tif (!setting || !*setting)\n\t\t{\n\t\t\tsprintf(replybuf, \"missing fanmode setting\");\n\t\t\treturn replybuf;\n\t\t}\n\t\tif (setting[1] || ((setting[0] < '0' || setting[0] > '5') && setting[0] != '9'))\n\t\t{\n\t\t\tsprintf(replybuf, \"invalid fanmode setting\");\n\t\t\treturn replybuf;\n\t\t}\n\t\t\n\t\tchar cmd[4] = \"Z5X\";\n\t\tcmd[1] = setting[0];\n\t\tmutex_lock(mutexp);\n\t\tbitforce_cmd1b(proc, replybuf, 256, cmd, 3);\n\t\tmutex_unlock(mutexp);\n\t\treturn replybuf;\n\t}\n}\n\nstatic\nconst char *bitforce_rpc_send_cmd1(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tpthread_mutex_t *mutexp = &proc->device->device_mutex;\n\t\n\t{\n\t\tmutex_lock(mutexp);\n\t\tbitforce_cmd1b(proc, replybuf, 8000, setting, strlen(setting));\n\t\tmutex_unlock(mutexp);\n\t\t*success = SDR_OK;\n\t\treturn replybuf;\n\t}\n}\n\nstatic const struct bfg_set_device_definition bitforce_set_device_funcs[] = {\n\t{\"fanmode\", bitforce_set_fanmode, \"range 0-5 (low to fast) or 9 (auto)\"},\n\t{\"voltage\", bitforce_set_voltage, \"range 0.54-0.75 V\"},\n\t{\"_cmd1\", bitforce_rpc_send_cmd1, NULL},\n\t{NULL},\n};\n\nstruct device_drv bitforce_drv = {\n\t.dname = \"bitforce\",\n\t.name = \"BFL\",\n\t.lowl_match = bitforce_lowl_match,\n\t.lowl_probe = bitforce_lowl_probe,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitforce_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitforce_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitforce_tui_handle_choice,\n#endif\n\t.get_api_stats = bitforce_drv_stats,\n\t.minerloop = minerloop_async,\n\t.reinit_device = bitforce_reinit,\n\t.get_stats = bitforce_get_stats,\n\t.identify_device = bitforce_identify,\n\t.thread_init = bitforce_thread_init,\n\t.job_prepare = bitforce_job_prepare,\n\t.job_start = bitforce_job_start,\n\t.job_get_results = bitforce_job_get_results,\n\t.poll = bitforce_poll,\n\t.job_process_results = bitforce_job_process_results,\n\t.thread_shutdown = bitforce_shutdown,\n\t.thread_enable = biforce_thread_enable\n};\n\n\nstatic inline\nvoid bitforce_set_queue_full(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\t\n\tthr->queue_full = (data->queued + data->ready_to_queue >= data->queued_max) || (data->ready_to_queue >= data->max_queue_at_once);\n}\n\nstatic\nbool bitforce_send_queue(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tpthread_mutex_t *mutexp = &bitforce->device->device_mutex;\n\tstruct work *work;\n\t\n\tif (unlikely(!(devdata->is_open && data->ready_to_queue)))\n\t\treturn false;\n\t\n\tchar buf[0x100];\n\tint queued_ok;\n\tsize_t qjs_sz = (32 + 12 + 1);\n\tif (data->style == BFS_65NM)\n\t\t++qjs_sz;\n\tsize_t qjp_sz = 7 + (qjs_sz * data->ready_to_queue);\n\tif (data->style == BFS_65NM)\n\t\tqjp_sz -= 3;\n\tuint8_t qjp[qjp_sz], *qjs;\n\tqjs = &qjp[qjp_sz];\n\t// NOTE: qjp is build backwards here\n\t\n\t*(--qjs) = 0xfe;\n\t\n\twork = thr->work_list->prev;\n\tfor (int i = data->ready_to_queue; i > 0; --i, work = work->prev)\n\t{\n\t\t*(--qjs) = 0xaa;\n\t\tmemcpy(qjs -= 12, work->data + 64, 12);\n\t\tmemcpy(qjs -= 32, work->midstate, 32);\n\t\tif (data->style == BFS_65NM)\n\t\t\t*(--qjs) = 45;\n\t}\n\t\n\t*(--qjs) = data->ready_to_queue;\n\t*(--qjs) = 0xc1;\n\tif (data->style == BFS_65NM)\n\t\t*(--qjs) = qjp_sz - 1;\n\telse\n\t{\n\t\t*(--qjs) = qjp_sz >> 8;\n\t\t*(--qjs) = qjp_sz & 0xff;\n\t\t*(--qjs) = 'X';\n\t\t*(--qjs) = 'W';\n\t}\n\t\nretry:\n\tmutex_lock(mutexp);\n\tif (data->style != BFS_65NM)\n\t\tbitforce_cmd1c(bitforce, buf, sizeof(buf), qjp, qjp_sz);\n\telse\n\tif (data->missing_zwx)\n\t\tbitforce_cmd2(bitforce, buf, sizeof(buf), \"ZNX\", &qjp[3], qjp_sz - 4);\n\telse\n\t\tbitforce_cmd2(bitforce, buf, sizeof(buf), \"ZWX\", qjp, qjp_sz);\n\tmutex_unlock(mutexp);\n\t\n\tif (!strncasecmp(buf, \"ERR:QUEUE\", 9))\n\t{\n\t\t// Queue full :(\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Device queue full while attempting to append %d jobs (queued<=%d)\",\n\t           bitforce->proc_repr,\n\t           data->ready_to_queue, data->queued);\n\t\tthr->queue_full = true;\n\t\treturn false;\n\t}\n\tif (strncasecmp(buf, \"OK:QUEUED\", 9))\n\t{\n\t\tif ((!strncasecmp(buf, \"ERROR: UNKNOWN\", 11)) && !data->missing_zwx)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Missing ZWX command, trying ZNX\",\n\t\t\t       bitforce->proc_repr);\n\t\t\tdata->missing_zwx = true;\n\t\t\tgoto retry;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Unexpected error attempting to append %d jobs (queued<=%d): %s\",\n\t           bitforce->proc_repr,\n\t           data->ready_to_queue, data->queued, buf);\n\t\treturn false;\n\t}\n\t\n\tif (!data->queued)\n\t\tcgtime(&data->tv_hashmeter_start);\n\t\n\tif (data->missing_zwx)\n\t\tqueued_ok = 1;\n\telse\n\t{\n\t\tchar *p;\n\t\tqueued_ok = strtol(&buf[9], &p, 0);\n\t\tif (data->max_queueid)\n\t\t{\n\t\t\tif (unlikely(p[0] != ':'))\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Successfully queued %d/%d jobs, but no queue ids returned (queued<=%d)\", bitforce->proc_repr, queued_ok, data->ready_to_queue, data->queued + queued_ok);\n\t\t\telse\n\t\t\t{\n\t\t\t\t// NOTE: work is set to just-before the first item from the build-command loop earlier\n\t\t\t\t// NOTE: This ugly statement ends up with the first work item queued\n\t\t\t\twork = work ? (work->next ?: work) : thr->work_list;\n\t\t\t\tfor (int i = data->ready_to_queue; i > 0; --i, (work = work->next))\n\t\t\t\t{\n\t\t\t\t\twork->device_id = strtol(&p[1], &p, 0x10);\n\t\t\t\t\tif (unlikely(!p[0]))\n\t\t\t\t\t\t--p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdata->queued += queued_ok;\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Successfully queued %d/%d jobs on device (queued<=%d)\",\n\t       bitforce->proc_repr,\n\t       queued_ok, data->ready_to_queue, data->queued);\n\tdata->ready_to_queue -= queued_ok;\n\tif (!data->missing_zwx)\n\t\tthr->queue_full = data->ready_to_queue;\n\tdata->just_flushed = false;\n\tdata->want_to_send_queue = false;\n\t\n\treturn true;\n}\n\nvoid work_list_del(struct work **head, struct work *work)\n{\n\tDL_DELETE(*head, work);\n\tfree_work(work);\n}\n\nstatic\nbool bitforce_queue_do_results(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct cgpu_info * const dev = bitforce->device;\n\tstruct bitforce_data * const devdata = dev->device_data;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tint count;\n\tint fcount;\n\tchar *noncebuf, *buf, *end;\n\tunsigned char midstate[32], datatail[12];\n\tstruct work *work, *tmpwork, *thiswork;\n\tstruct timeval tv_now, tv_elapsed;\n\tlong chipno = 0;  // Initialized value is used for non-parallelized boards\n\tstruct cgpu_info *chip_cgpu;\n\tstruct thr_info *chip_thr;\n\tint counts[data->parallel];\n\tbool ret = true;\n\t\n\tif (unlikely(!devdata->is_open))\n\t\treturn false;\n\t\n\tfcount = 0;\n\tfor (int i = 0; i < data->parallel; ++i)\n\t\tcounts[i] = 0;\n\t\nagain:\n\tnoncebuf = &data->noncebuf[0];\n\tcount = bitforce_zox(thr, \"ZOX\", NULL);\n\t\n\tif (unlikely(count < 0))\n\t{\n\t\tinc_hw_errors_only(thr);\n\t\treturn_via_applog(out, ret = false, LOG_ERR, \"%\"PRIpreprv\": Received unexpected queue result response: %s\", bitforce->proc_repr, noncebuf);\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Received %d queue results on poll (max=%d)\", bitforce->proc_repr, count, (int)BITFORCE_MAX_QRESULTS);\n\tif (!count)\n\t\tgoto done;\n\t\n\tnoncebuf = next_line(noncebuf);\n\twhile ((buf = noncebuf)[0])\n\t{\n\t\tif ( (noncebuf = next_line(buf)) )\n\t\t\tnoncebuf[-1] = '\\0';\n\t\t\n\t\tif (data->max_queueid)\n\t\t{\n\t\t\tconst work_device_id_t queueid = strtol(buf, &end, 0x10);\n\t\t\tif (unlikely(!end[0]))\n\t\t\t\tgoto gibberish;\n\t\t\tDL_SEARCH_SCALAR(thr->work_list, thiswork, device_id, queueid);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (strlen(buf) <= 90)\n\t\t\t{\ngibberish:\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Gibberish within queue results: %s\", bitforce->proc_repr, buf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\thex2bin(midstate, buf, 32);\n\t\t\thex2bin(datatail, &buf[65], 12);\n\t\t\t\n\t\t\tthiswork = NULL;\n\t\t\tDL_FOREACH(thr->work_list, work)\n\t\t\t{\n\t\t\t\tif (unlikely(memcmp(work->midstate, midstate, 32)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (unlikely(memcmp(&work->data[64], datatail, 12)))\n\t\t\t\t\tcontinue;\n\t\t\t\tthiswork = work;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tend = &buf[89];\n\t\t}\n\t\t\n\t\tchip_cgpu = bitforce;\n\t\tif (data->parallel_protocol)\n\t\t{\n\t\t\tchipno = strtol(&end[1], &end, 16);\n\t\t\tif (chipno >= data->parallel)\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Chip number out of range for queue result: %s\", chip_cgpu->proc_repr, buf);\n\t\t\t\tchipno = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < chipno; ++i)\n\t\t\t\tchip_cgpu = chip_cgpu->next_proc;\n\t\t}\n\t\tchip_thr = chip_cgpu->thr[0];\n\t\t\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Queue result: %s\", chip_cgpu->proc_repr, buf);\n\t\t\n\t\tif (unlikely(!thiswork))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to find work for queue results: %s\", chip_cgpu->proc_repr, buf);\n\t\t\tinc_hw_errors_only(chip_thr);\n\t\t\tgoto next_qline;\n\t\t}\n\t\t\n\t\tif (unlikely(!end[0]))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Missing nonce count in queue results: %s\", chip_cgpu->proc_repr, buf);\n\t\t\tgoto finishresult;\n\t\t}\n\t\tif (strtol(&end[1], &end, 10))\n\t\t{\n\t\t\tif (unlikely(!end[0]))\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Missing nonces in queue results: %s\", chip_cgpu->proc_repr, buf);\n\t\t\t\tgoto finishresult;\n\t\t\t}\n\t\t\tbitforce_process_result_nonces(chip_thr, thiswork, &end[1]);\n\t\t}\n\t\t++fcount;\n\t\t++counts[chipno];\n\t\t\nfinishresult:\n\t\tif (data->parallel == 1)\n\t\t{\n\n\t\t// Queue results are in order, so anything queued prior this is lost\n\t\t// Delete all queued work up to, and including, this one\n\t\tDL_FOREACH_SAFE(thr->work_list, work, tmpwork)\n\t\t{\n\t\t\twork_list_del(&thr->work_list, work);\n\t\t\t--data->queued;\n\t\t\tif (work == thiswork)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Parallel processors means the results might not be in order\n\t\t\t// This could leak if jobs get lost, hence the sanity checks using \"ZqX\"\n\t\t\twork_list_del(&thr->work_list, thiswork);\n\t\t\t--data->queued;\n\t\t}\nnext_qline: (void)0;\n\t}\n\t\n\tbitforce_set_queue_full(thr);\n\t\n\tif (count >= BITFORCE_MAX_QRESULTS)\n\t\tgoto again;\n\t\ndone:\n\tif (data->parallel == 1 && (\n\t        (fcount < BITFORCE_GOAL_QRESULTS && bitforce->sleep_ms < BITFORCE_MAX_QRESULT_WAIT && data->queued > 1)\n\t     || (fcount > BITFORCE_GOAL_QRESULTS && bitforce->sleep_ms > BITFORCE_MIN_QRESULT_WAIT)  ))\n\t{\n\t\tunsigned int old_sleep_ms = bitforce->sleep_ms;\n\t\tbitforce->sleep_ms = (uint32_t)bitforce->sleep_ms * BITFORCE_GOAL_QRESULTS / (fcount ?: 1);\n\t\tif (bitforce->sleep_ms > BITFORCE_MAX_QRESULT_WAIT)\n\t\t\tbitforce->sleep_ms = BITFORCE_MAX_QRESULT_WAIT;\n\t\tif (bitforce->sleep_ms < BITFORCE_MIN_QRESULT_WAIT)\n\t\t\tbitforce->sleep_ms = BITFORCE_MIN_QRESULT_WAIT;\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Received %d queue results after %ums; Wait time changed to: %ums (queued<=%d)\",\n\t\t       bitforce->proc_repr, fcount, old_sleep_ms, bitforce->sleep_ms, data->queued);\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Received %d queue results after %ums; Wait time unchanged (queued<=%d)\",\n\t\t       bitforce->proc_repr, fcount, bitforce->sleep_ms, data->queued);\n\t\nout:\n\tcgtime(&tv_now);\n\ttimersub(&tv_now, &data->tv_hashmeter_start, &tv_elapsed);\n\tchip_cgpu = bitforce;\n\tfor (int i = 0; i < data->parallel; ++i, (chip_cgpu = chip_cgpu->next_proc))\n\t{\n\t\tchip_thr = chip_cgpu->thr[0];\n\t\thashes_done(chip_thr, (uint64_t)bitforce->nonces * counts[i], &tv_elapsed, NULL);\n\t}\n\tdata->tv_hashmeter_start = tv_now;\n\t\n\treturn ret;\n}\n\nstatic\nbool bitforce_queue_append(struct thr_info *thr, struct work *work)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tbool rv, ndq;\n\t\n\tbitforce_set_queue_full(thr);\n\trv = !thr->queue_full;\n\tif (rv)\n\t{\n\t\tDL_APPEND(thr->work_list, work);\n\t\t++data->ready_to_queue;\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Appending to driver queue (max=%u, ready=%d, queued<=%d)\",\n\t\t       bitforce->proc_repr,\n\t\t       (unsigned)data->queued_max, data->ready_to_queue, data->queued);\n\t\tbitforce_set_queue_full(thr);\n\t}\n\telse\n\tif (!data->ready_to_queue)\n\t\treturn rv;\n\t\n\tndq = !data->queued;\n\tif ((ndq)              // Device is idle\n\t || (data->ready_to_queue >= data->max_queue_at_once)  // ...or 5 items ready to go\n\t || (thr->queue_full)            // ...or done filling queue\n\t || (data->just_flushed)         // ...or queue was just flushed (only remaining job is partly done already)\n\t || (data->missing_zwx)          // ...or device can only queue one at a time\n\t)\n\t{\n\t\tif (!bitforce_send_queue(thr))\n\t\t{\n\t\t\t// Problem sending queue, retry again in a few seconds\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to send queue\", bitforce->proc_repr);\n\t\t\tinc_hw_errors_only(thr);\n\t\t\tdata->want_to_send_queue = true;\n\t\t}\n\t}\n\t\n\treturn rv;\n}\n\nstruct _jobinfo {\n\tuint8_t key[32+12];\n\tint instances;\n\tint flushed_instances;\n\tUT_hash_handle hh;\n};\n\nstatic\nvoid _bitforce_queue_flush_add_to_processing(struct _jobinfo ** const processing_p, struct _jobinfo * const this, const size_t keysz, const bool was_flushed)\n{\n\tstruct _jobinfo *item;\n\tHASH_FIND(hh, *processing_p, &this->key[0], keysz, item);\n\tif (likely(!item))\n\t{\n\t\titem = this;\n\t\tthis->flushed_instances = this->instances = 0;\n\t\tHASH_ADD(hh, *processing_p, key, keysz, this);\n\t}\n\telse\n\t{\n\t\t// This should really only happen in testing/benchmarking...\n\t\tfree(this);\n\t}\n\tif (was_flushed)\n\t\t++item->flushed_instances;\n\telse\n\t\t++item->instances;\n}\n\nstatic\nvoid bitforce_delete_last_n_work(struct thr_info * const thr, int n)\n{\n\twhile (n--)\n\t\twork_list_del(&thr->work_list, thr->work_list->prev);\n}\n\nstatic\nvoid bitforce_queue_flush_sanity_check(struct thr_info * const thr, struct _jobinfo ** const processing_p, const size_t keysz, const bool ignore_race)\n{\n\tstruct cgpu_info * const bitforce = thr->cgpu;\n\tstruct bitforce_data * const data = bitforce->device_data;\n\tstruct work *work, *tmp;\n\tstruct _jobinfo *item, *this;\n\tuint8_t key[keysz];\n\tchar hex[(keysz * 2) + 1];\n\t\n\t// Iterate over the work_list and delete anything not in the hash\n\tDL_FOREACH_SAFE(thr->work_list, work, tmp)\n\t{\n\t\tif (data->max_queueid)\n\t\t{\n\t\t\tmemcpy(&key[0], &work->device_id, sizeof(work->device_id));\n\t\t\tsnprintf(hex, sizeof(hex), \"%04x\", work->device_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&key[ 0],  work->midstate, 32);\n\t\t\tmemcpy(&key[32], &work->data[64], 12);\n\t\t\tbin2hex(hex, key, keysz);\n\t\t}\n\t\tHASH_FIND(hh, *processing_p, &key[0], keysz, item);\n\t\tif (unlikely(!item))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Sanity check: Device is missing queued job! %s\", bitforce->proc_repr, hex);\n\t\t\twork_list_del(&thr->work_list, work);\n\t\t\t--data->queued;\n\t\t\tcontinue;\n\t\t}\n\t\tif (item->instances)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Queue flush: %s inprogress\", bitforce->proc_repr, hex);\n\t\t\t--item->instances;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t--item->flushed_instances;\n\t\t\twork_list_del(&thr->work_list, work);\n\t\t\t// NOTE: data->queued is decremented later via bitforce_finish_flush\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Queue flush: %s flushed\", bitforce->proc_repr, hex);\n\t\t}\n\t\tif (likely(!(item->instances + item->flushed_instances)))\n\t\t{\n\t\t\tHASH_DEL(*processing_p, item);\n\t\t\tfree(item);\n\t\t}\n\t}\n\tif (unlikely(*processing_p))\n\t{\n\t\tHASH_ITER(hh, *processing_p, item, this)\n\t\t{\n\t\t\tbin2hex(hex, &item->key[0], keysz);\n\t\t\tif (item->instances && !ignore_race)\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Sanity check: Device %s unknown work %s (%d)\", bitforce->proc_repr, \"is processing\", hex, item->instances);\n\t\t\tif (item->flushed_instances)\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Sanity check: Device %s unknown work %s (%d)\", bitforce->proc_repr, \"flushed\", hex, item->flushed_instances);\n\t\t\t\n\t\t\tHASH_DEL(*processing_p, item);\n\t\t\tfree(item);\n\t\t}\n\t}\n}\n\nstatic\nvoid bitforce_finish_flush(struct thr_info * const thr, const int flushed)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data * const data = bitforce->device_data;\n\t\n\tdata->queued -= flushed;\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Flushed %u jobs from device and %d from driver (queued<=%d)\",\n\t       bitforce->proc_repr, flushed, data->ready_to_queue, data->queued);\n\t\n\tbitforce_set_queue_full(thr);\n\tdata->just_flushed = true;\n\tdata->want_to_send_queue = false;\n\tdata->ready_to_queue = 0;\n}\n\nstatic\nvoid bitforce_process_flb_result(struct thr_info * const thr, int inproc, int flushed)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\t\n\tsize_t total = inproc + flushed, readsz;\n\tuint16_t buf[total];\n\treadsz = bitforce_read(bitforce, buf, total * 2) / 2;\n\tif (unlikely(readsz != total))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Short read for FLB result\", bitforce->proc_repr);\n\t\tif (readsz < inproc)\n\t\t{\n\t\t\tinproc = readsz;\n\t\t\tflushed = 0;\n\t\t}\n\t\telse\n\t\t\tflushed = readsz - inproc;\n\t}\n\t\n\tconst int keysz = sizeof(work_device_id_t);\n\tstruct _jobinfo *processing = NULL, *this;\n\tfor (int i = inproc + flushed; i--; )\n\t{\n\t\tthis = malloc(sizeof(*this));\n\t\tconst work_device_id_t queueid = be16toh(buf[i]);\n\t\tmemcpy(&this->key[0], &queueid, sizeof(queueid));\n\t\t_bitforce_queue_flush_add_to_processing(&processing, this, keysz, !(i < inproc));\n\t}\n\t\n\tbitforce_queue_flush_sanity_check(thr, &processing, keysz, false);\n\t\n\tbitforce_finish_flush(thr, flushed);\n}\n\nstatic\nvoid bitforce_queue_flush(struct thr_info *thr)\n{\n\tstruct bitforce_proc_data *procdata = thr->cgpu_data;\n\tif (!procdata->handles_board)\n\t\treturn;\n\t\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tchar *buf = &data->noncebuf[0], *buf2 = NULL;\n\tconst char *cmd = \"ZqX\";\n\tint inproc = -1;\n\tunsigned flushed;\n\tstruct _jobinfo *processing = NULL, *this;\n\t\n\t// First, eliminate all unsent works\n\tbitforce_delete_last_n_work(thr, data->ready_to_queue);\n\t\n\tif (data->parallel == 1)\n\t\t// Pre-parallelization neither needs nor supports \"ZqX\"\n\t\tcmd = \"ZQX\";\n\telse\n\tif (data->max_queueid)\n\t\tcmd = \"FLB\";\n\tbitforce_zox(thr, cmd, NULL);\n\tif (!strncasecmp(buf, \"OK:FLUSHED\", 10))\n\t\tflushed = atoi(&buf[10]);\n\telse\n\tif ((!strncasecmp(buf, \"COUNT:\", 6)) && (buf2 = strstr(buf, \"FLUSHED:\")) )\n\t{\n\t\tinproc = atoi(&buf[6]);\n\t\tflushed = atoi(&buf2[8]);\n\t\tbuf2 = next_line(buf2);\n\t}\n\telse\n\tif ((!strncasecmp(buf, \"BIN-InP:\", 8)) && (buf2 = strstr(buf, \"FLUSHED:\")) )\n\t{\n\t\tinproc = atoi(&buf[8]);\n\t\tflushed = atoi(&buf2[8]);\n\t\tif (unlikely(data->queued != inproc + flushed))\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Sanity check: Device work count mismatch (dev inproc=%d, dev flushed=%u, queued=%d)\", bitforce->proc_repr, inproc, flushed, data->queued);\n\t\tbitforce_process_flb_result(thr, inproc, flushed);\n\t\tgoto final;\n\t}\n\telse\n\tif (!strncasecmp(buf, \"OK\", 2))\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Didn't report flush count\", bitforce->proc_repr);\n\t\tthr->queue_full = false;\n\t\tflushed = 0;\n\t}\n\telse\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Failed to flush device queue: %s\", bitforce->proc_repr, buf);\n\t\tflushed = 0;\n\t}\n\t\n\tif (flushed > data->queued)\n\t{\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Flushed %u jobs from device, but only %u were queued\",\n\t\t       bitforce->proc_repr, flushed, data->queued);\n\t\tinc_hw_errors_only(thr);\n\t\t// We need to avoid trying to delete more items than we've sent, or a segfault is upcoming...\n\t\tflushed = data->queued;\n\t}\n\t\n\tbitforce_delete_last_n_work(thr, flushed);\n\tbitforce_finish_flush(thr, flushed);\n\t\n\t// \"ZqX\" returns jobs in progress, allowing us to sanity check\n\t// NOTE: Must process buffer into hash table BEFORE calling bitforce_queue_do_results, which clobbers it\n\t// NOTE: Must do actual sanity check AFTER calling bitforce_queue_do_results, to ensure we don't delete completed jobs\n\t\n\tconst size_t keysz = data->max_queueid ? sizeof(work_device_id_t) : sizeof(this->key);\n\t\n\tif (buf2)\n\t{\n\t\t// First, turn buf2 into a hash\n\t\tfor ( ; buf2[0]; buf2 = next_line(buf2))\n\t\t{\n\t\t\tthis = malloc(sizeof(*this));\n\t\t\tif (data->max_queueid)\n\t\t\t{\n\t\t\t\tconst work_device_id_t queueid = strtol(buf2, NULL, 0x10);\n\t\t\t\tmemcpy(&this->key[0], &queueid, sizeof(queueid));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thex2bin(&this->key[ 0], &buf2[ 0], 32);\n\t\t\t\thex2bin(&this->key[32], &buf2[65], 12);\n\t\t\t}\n\t\t\t_bitforce_queue_flush_add_to_processing(&processing, this, keysz, false);\n\t\t}\n\t}\n\t\n\tbitforce_queue_do_results(thr);\n\t\n\tif (buf2)\n\t\t// There is a race condition where the flush may have reported a job as in progress even though we completed and processed its results just now - so we just silence the sanity check\n\t\tbitforce_queue_flush_sanity_check(thr, &processing, keysz, true);\n\t\nfinal: ;\n\tif (data->style == BFS_28NM)\n\t{\n\t\tif (unlikely(inproc != -1 && inproc != data->queued))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Sanity check: Device work inprogress count mismatch (dev inproc=%d, queued=%d)\", bitforce->proc_repr, inproc, data->queued);\n\t\t\tdata->queued = inproc;\n\t\t}\n\t}\n}\n\nstatic\nvoid bitforce_queue_poll(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tunsigned long sleep_us;\n\t\n\tif (data->queued)\n\t\tbitforce_queue_do_results(thr);\n\tsleep_us = (unsigned long)bitforce->sleep_ms * 1000;\n\t\n\tif (data->want_to_send_queue)\n\t\tif (!bitforce_send_queue(thr))\n\t\t\tif (!data->queued)\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to send queue, and queue empty; retrying after 1 second\", bitforce->proc_repr);\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\tsleep_us = 1000000;\n\t\t\t}\n\t\n\ttimer_set_delay_from_now(&thr->tv_poll, sleep_us);\n}\n\nstatic void bitforce_queue_thread_deven(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitforce = thr->cgpu, *thisbf;\n\tstruct bitforce_data *data = bitforce->device_data;\n\tstruct thr_info *thisthr;\n\t\n\tfor (thisbf = bitforce->device; thisbf && thisbf->device_data != data; thisbf = thisbf->next_proc)\n\t{}\n\tfor ( ; thisbf && thisbf->device_data == data; thisbf = thisbf->next_proc)\n\t{\n\t\tthisthr = bitforce->thr[0];\n\t\t\n\t\tthisthr->pause = thr->pause;\n\t\tthisbf->deven = bitforce->deven;\n\t}\n}\n\nstatic void bitforce_queue_thread_disable(struct thr_info *thr)\n{\n\t// Disable other threads sharing the same queue\n\tbitforce_queue_thread_deven(thr);\n}\n\nstatic void bitforce_queue_thread_enable(struct thr_info *thr)\n{\n\t// TODO: Maybe reinit?\n\t\n\t// Enable other threads sharing the same queue\n\tbitforce_queue_thread_deven(thr);\n}\n\nstruct device_drv bitforce_queue_api = {\n\t.dname = \"bitforce_queue\",\n\t.name = \"BFL\",\n\t.lowl_probe_by_name_only = true,\n\t.lowl_match = bitforce_lowl_match,\n\t.lowl_probe = bitforce_lowl_probe,\n\t.minerloop = minerloop_queue,\n\t.reinit_device = bitforce_reinit,\n\t.zero_stats = bitforce_zero_stats,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitforce_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitforce_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitforce_tui_handle_choice,\n#endif\n\t.get_api_stats = bitforce_drv_stats,\n\t.get_stats = bitforce_get_stats,\n\t.identify_device = bitforce_identify,\n\t.thread_init = bitforce_thread_init,\n\t.queue_append = bitforce_queue_append,\n\t.queue_flush = bitforce_queue_flush,\n\t.poll = bitforce_queue_poll,\n\t.thread_shutdown = bitforce_shutdown,\n\t.thread_disable = bitforce_queue_thread_disable,\n\t.thread_enable = bitforce_queue_thread_enable,\n};\n"
        },
        {
          "name": "driver-bitfury.c",
          "type": "blob",
          "size": 23.2275390625,
          "content": "/*\n * Copyright 2013 bitfury\n * Copyright 2013 Anatoly Legkodymov\n * Copyright 2013-2014 Luke Dashjr\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n#include \"miner.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sha2.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"lowl-spi.h\"\n#include \"util.h\"\n\nstatic const int chipgen_timeout_secs = 30;\n\nBFG_REGISTER_DRIVER(bitfury_drv)\nconst struct bfg_set_device_definition bitfury_set_device_funcs[];\n\nstatic\nint bitfury_autodetect()\n{\n\tRUNONCE(0);\n\t\n\tint chip_n;\n\tstruct cgpu_info *bitfury_info;\n\n\tapplog(LOG_INFO, \"INFO: bitfury_detect\");\n\tspi_init();\n\tif (!sys_spi)\n\t\treturn 0;\n\t\n\tbitfury_info = calloc(1, sizeof(struct cgpu_info));\n\tbitfury_info->drv = &bitfury_drv;\n\tbitfury_info->threads = 1;\n\t\n\t{\n\t\tstruct bitfury_device dummy_bitfury = {\n\t\t\t.spi = sys_spi,\n\t\t};\n\t\tdrv_set_defaults(&bitfury_drv, bitfury_set_device_funcs_probe, &dummy_bitfury, NULL, NULL, 1);\n\t}\n\t\n\tchip_n = libbitfury_detectChips1(sys_spi);\n\tif (!chip_n) {\n\t\tapplog(LOG_WARNING, \"No Bitfury chips detected!\");\n\t\tfree(bitfury_info);\n\t\treturn 0;\n\t} else {\n\t\tapplog(LOG_WARNING, \"BITFURY: %d chips detected!\", chip_n);\n\t}\n\n\tbitfury_info->procs = chip_n;\n\tbitfury_info->set_device_funcs = bitfury_set_device_funcs;\n\tadd_cgpu(bitfury_info);\n\t\n\treturn 1;\n}\n\nstatic void bitfury_detect(void)\n{\n\tnoserial_detect_manual(&bitfury_drv, bitfury_autodetect);\n}\n\n\nstatic\nvoid *bitfury_just_io(struct bitfury_device * const bitfury)\n{\n\tstruct spi_port * const spi = bitfury->spi;\n\tconst int chip = bitfury->fasync;\n\tvoid *rv;\n\t\n\tspi_clear_buf(spi);\n\tspi_emit_break(spi);\n\tspi_emit_fasync(spi, chip);\n\trv = spi_emit_data(spi, 0x3000, &bitfury->atrvec[0], 19 * 4);\n\tspi_txrx(spi);\n\treturn rv;\n}\n\nstatic\nvoid bitfury_debug_nonce_array(const struct cgpu_info * const proc, const char *msg, const uint32_t * const inp)\n{\n\tconst struct bitfury_device * const bitfury = proc->device_data;\n\tconst int active = bitfury->active;\n\tchar s[((1 + 8) * 0x10) + 1];\n\tchar *sp = s;\n\tfor (int i = 0; i < 0x10; ++i)\n\t\tsp += sprintf(sp, \"%c%08lx\",\n\t\t              (active == i) ? '>' : ' ',\n\t\t              (unsigned long)bitfury_decnonce(inp[i]));\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s%s (job=%08lx)\",\n\t       proc->proc_repr, msg, s, (unsigned long)inp[0x10]);\n}\n\nstatic\nbool bitfury_init_oldbuf(struct cgpu_info * const proc, const uint32_t *inp)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tuint32_t * const oldbuf = &bitfury->oldbuf[0];\n\tuint32_t * const buf = &bitfury->newbuf[0];\n\tuint32_t *inp_new;\n\tint i, differ, tried = 0;\n\t\n\tif (!inp)\n\t\tinp = bitfury_just_io(bitfury);\ntryagain:\n\tif (tried > 3)\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": %s: Giving up after %d tries\",\n\t\t       proc->proc_repr, __func__, tried);\n\t\tbitfury->desync_counter = 99;\n\t\treturn false;\n\t}\n\t++tried;\n\tswap32tole(buf, inp, 0x10);\n\tinp_new = bitfury_just_io(bitfury);\n\tswap32tole(inp_new, inp_new, 0x10);\n\tinp = inp_new;\n\tdiffer = -1;\n\tfor (i = 0; i < 0x10; ++i)\n\t{\n\t\tif (inp[i] != buf[i])\n\t\t{\n\t\t\tif (differ != -1)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s: Second differ at %d; trying again\",\n\t\t\t\t       proc->proc_repr, __func__, i);\n\t\t\t\tgoto tryagain;\n\t\t\t}\n\t\t\tdiffer = i;\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s: Differ at %d\",\n\t\t\t       proc->proc_repr, __func__, i);\n\t\t\tif (tried > 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (-1 == differ)\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s: No differ found; trying again\",\n\t\t       proc->proc_repr, __func__);\n\t\tgoto tryagain;\n\t}\n\t\n\tbitfury->active = differ;\n\tmemcpy(&oldbuf[0], &inp[bitfury->active], 4 * (0x10 - bitfury->active));\n\tmemcpy(&oldbuf[0x10 - bitfury->active], &inp[0], 4 * bitfury->active);\n\tbitfury->oldjob = inp[0x10];\n\tbitfury->desync_counter = 0;\n\t\n\tif (opt_dev_protocol)\n\t\tbitfury_debug_nonce_array(proc, \"Init\", inp);\n\t\n\treturn true;\n}\n\nbool bitfury_init_chip(struct cgpu_info * const proc)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tstruct bitfury_payload payload = {\n\t\t.midstate = \"\\x33\\xfb\\x46\\xdc\\x61\\x2a\\x7a\\x23\\xf0\\xa2\\x2d\\x63\\x31\\x54\\x21\\xdc\"\n\t\t            \"\\xae\\x86\\xfe\\xc3\\x88\\xc1\\x9c\\x8c\\x20\\x18\\x10\\x68\\xfc\\x95\\x3f\\xf7\",\n\t\t.m7    = htole32(0xc3baafef),\n\t\t.ntime = htole32(0x326fa351),\n\t\t.nbits = htole32(0x6461011a),\n\t};\n\tbitfury_payload_to_atrvec(bitfury->atrvec, &payload);\n\treturn bitfury_init_oldbuf(proc, NULL);\n}\n\nstatic\nbool bitfury_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *proc;\n\tstruct bitfury_device *bitfury;\n\t\n\tfor (proc = thr->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tbitfury = proc->device_data = malloc(sizeof(struct bitfury_device));\n\t\t*bitfury = (struct bitfury_device){\n\t\t\t.spi = sys_spi,\n\t\t\t.fasync = proc->proc_id,\n\t\t};\n\t\tbitfury_init_chip(proc);\n\t\tbitfury->osc6_bits = 50;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\t\n\treturn true;\n}\n\nvoid bitfury_disable(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Shutting down chip (disable)\", proc->proc_repr);\n\tbitfury_send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);\n}\n\nvoid bitfury_enable(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct thr_info * const master_thr = dev->thr[0];\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Reinitialising chip (enable)\", proc->proc_repr);\n\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\tbitfury_init_chip(proc);\n\t\n\tif (!timer_isset(&master_thr->tv_poll))\n\t\ttimer_set_now(&master_thr->tv_poll);\n}\n\nvoid bitfury_shutdown(struct thr_info *thr) {\n\tstruct cgpu_info *cgpu = thr->cgpu, *proc;\n\tstruct bitfury_device *bitfury;\n\t\n\tapplog(LOG_INFO, \"INFO bitfury_shutdown\");\n\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tbitfury = proc->device_data;\n\t\tbitfury_send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);\n\t}\n}\n\nbool bitfury_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\t\n\tif (opt_debug)\n\t{\n\t\tchar hex[153];\n\t\tbin2hex(hex, &work->data[0], 76);\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Preparing work %s\",\n\t\t       proc->proc_repr, hex);\n\t}\n\twork_to_bitfury_payload(&bitfury->payload, work);\n\tif (bitfury->chipgen)\n\t\tbitfury_payload_to_atrvec(bitfury->atrvec, &bitfury->payload);\n\t\n\twork->blk.nonce = 0xffffffff;\n\treturn true;\n}\n\nstatic\nbool fudge_nonce(struct work * const work, uint32_t *nonce_p) {\n\tstatic const uint32_t offsets[] = {0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000, 0x00400000};\n\tuint32_t nonce;\n\tint i;\n\t\n\tif (unlikely(!work))\n\t\treturn false;\n\t\n\tfor (i = 0; i < 6; ++i)\n\t{\n\t\tnonce = *nonce_p + offsets[i];\n\t\tif (test_nonce(work, nonce, false))\n\t\t{\n\t\t\t*nonce_p = nonce;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bitfury_noop_job_start(struct thr_info __maybe_unused * const thr)\n{\n}\n\n// freq_stat->{mh,s} are allocated such that [osc6_min] is the first valid index and [0] falls outside the allocation\n\nvoid bitfury_init_freq_stat(struct freq_stat * const c, const int osc6_min, const int osc6_max)\n{\n\tconst int osc6_values = (osc6_max + 1 - osc6_min);\n\tvoid * const p = calloc(osc6_values, (sizeof(*c->mh) + sizeof(*c->s)));\n\tc->mh = p - (sizeof(*c->mh) * osc6_min);\n\tc->s = p + (sizeof(*c->mh) * osc6_values) - (sizeof(*c->s) * osc6_min);\n\tc->osc6_min = osc6_min;\n\tc->osc6_max = osc6_max;\n}\n\nvoid bitfury_clean_freq_stat(struct freq_stat * const c)\n{\n\tfree(&c->mh[c->osc6_min]);\n}\n\n#define HOP_DONE 600\n\ntypedef uint32_t bitfury_inp_t[0x11];\n\nstatic\nint bitfury_select_freq(struct bitfury_device *bitfury, struct cgpu_info *proc) {\n\tint freq;\n\tint random;\n\tint i;\n\tbool all_done;\n\tstruct freq_stat *c;\n\t\n\tc = &bitfury->chip_stat;\n\t\n\tif (c->best_done) {\n\t\tfreq = c->best_osc;\n\t} else {\n\t\trandom = (int)(bitfury->mhz * 1000.0) & 1;\n\t\tfreq = (bitfury->osc6_bits == c->osc6_max) ? c->osc6_min : bitfury->osc6_bits + random;\n\t\tall_done = true;\n\t\tfor (i = c->osc6_min; i <= c->osc6_max; ++i)\n\t\t\tif (c->s[i] <= HOP_DONE)\n\t\t\t{\n\t\t\t\tall_done = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (all_done)\n\t\t{\n\t\t\tdouble mh_max = 0.0;\n\t\t\t\n\t\t\tfor (i = c->osc6_min; i <= c->osc6_max; ++i)\n\t\t\t{\n\t\t\t\tconst double mh_actual = c->mh[i] / c->s[i];\n\t\t\t\tif (mh_max >= mh_actual)\n\t\t\t\t\tcontinue;\n\t\t\t\tmh_max = mh_actual;\n\t\t\t\tfreq = i;\n\t\t\t}\n\t\t\tc->best_done = 1;\n\t\t\tc->best_osc = freq;\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": best_osc = %d\",\n\t\t\t       proc->proc_repr, freq);\n\t\t}\n\t}\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Changing osc6_bits to %d\",\n\t       proc->proc_repr, freq);\n\tbitfury->osc6_bits = freq;\n\tbitfury_send_freq(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\treturn 0;\n}\n\nvoid bitfury_do_io(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info *proc;\n\tstruct thr_info *thr;\n\tstruct bitfury_device *bitfury;\n\tstruct freq_stat *c;\n\tconst uint32_t *inp;\n\tint n, i, j;\n\tbool newjob;\n\tuint32_t nonce;\n\tint n_chips = 0, lastchip = 0;\n\tstruct spi_port *spi = NULL;\n\tbool should_be_running;\n\tstruct timeval tv_now;\n\tuint32_t counter;\n\tstruct timeval *tvp_stat;\n\t\n\tfor (proc = master_thr->cgpu; proc; proc = proc->next_proc)\n\t\t++n_chips;\n\t\n\tstruct cgpu_info *procs[n_chips];\n\tvoid *rxbuf[n_chips];\n\tbitfury_inp_t rxbuf_copy[n_chips];\n\t\n\t// NOTE: This code assumes:\n\t// 1) that chips on the same SPI bus are grouped together\n\t// 2) that chips are in sequential fasync order\n\tn_chips = 0;\n\tfor (proc = master_thr->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tthr = proc->thr[0];\n\t\tbitfury = proc->device_data;\n\t\t\n\t\tshould_be_running = (proc->deven == DEV_ENABLED && !thr->pause);\n\t\t\n\t\tif (should_be_running || thr->_job_transition_in_progress)\n\t\t{\n\t\t\tif (spi != bitfury->spi)\n\t\t\t{\n\t\t\t\tif (spi)\n\t\t\t\t\tspi_txrx(spi);\n\t\t\t\tspi = bitfury->spi;\n\t\t\t\tspi_clear_buf(spi);\n\t\t\t\tspi_emit_break(spi);\n\t\t\t\tlastchip = 0;\n\t\t\t}\n\t\t\tprocs[n_chips] = proc;\n\t\t\tspi_emit_fasync(spi, bitfury->fasync - lastchip);\n\t\t\tlastchip = bitfury->fasync;\n\t\t\trxbuf[n_chips] = spi_emit_data(spi, 0x3000, &bitfury->atrvec[0], 19 * 4);\n\t\t\t++n_chips;\n\t\t}\n\t\telse\n\t\tif (thr->work /* is currently running */ && thr->busy_state != TBS_STARTING_JOB)\n\t\t\t;//FIXME: shutdown chip\n\t}\n\tif (!spi)\n\t{\n\t\ttimer_unset(&master_thr->tv_poll);\n\t\treturn;\n\t}\n\ttimer_set_now(&tv_now);\n\tspi_txrx(spi);\n\t\n\tfor (j = 0; j < n_chips; ++j)\n\t{\n\t\tswap32tole(rxbuf_copy[j], rxbuf[j], 0x11);\n\t\trxbuf[j] = rxbuf_copy[j];\n\t}\n\t\n\tfor (j = 0; j < n_chips; ++j)\n\t{\n\t\tproc = procs[j];\n\t\tthr = proc->thr[0];\n\t\tbitfury = proc->device_data;\n\t\ttvp_stat = &bitfury->tv_stat;\n\t\tc = &bitfury->chip_stat;\n\t\tuint32_t * const newbuf = &bitfury->newbuf[0];\n\t\tuint32_t * const oldbuf = &bitfury->oldbuf[0];\n\t\t\n\t\tif (tvp_stat->tv_sec == 0 && tvp_stat->tv_usec == 0) {\n\t\t\tcopy_time(tvp_stat, &tv_now);\n\t\t}\n\t\t\n\t\tint stat_elapsed_secs = timer_elapsed(tvp_stat, &tv_now);\n\t\t\n\t\tinp = rxbuf[j];\n\t\t\n\t\tif (unlikely(bitfury->desync_counter == 99))\n\t\t{\n\t\t\tbitfury_init_oldbuf(proc, inp);\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tif (opt_dev_protocol)\n\t\t\tbitfury_debug_nonce_array(proc, \"Read\", inp);\n\t\t\n\t\t// To avoid dealing with wrap-around entirely, we rotate array so previous active uint32_t is at index 0\n\t\tmemcpy(&newbuf[0], &inp[bitfury->active], 4 * (0x10 - bitfury->active));\n\t\tmemcpy(&newbuf[0x10 - bitfury->active], &inp[0], 4 * bitfury->active);\n\t\tnewjob = inp[0x10];\n\t\t\n\t\tif (newbuf[0xf] != oldbuf[0xf])\n\t\t{\n\t\t\tinc_hw_errors2(thr, NULL, NULL);\n\t\t\tif (unlikely(++bitfury->desync_counter >= 4))\n\t\t\t{\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Previous nonce mismatch (4th try), recalibrating\",\n\t\t\t\t       proc->proc_repr);\n\t\t\t\tbitfury_init_oldbuf(proc, inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Previous nonce mismatch, ignoring response\",\n\t\t\t       proc->proc_repr);\n\t\t\tgoto out;\n\t\t}\n\t\telse\n\t\t\tbitfury->desync_counter = 0;\n\t\t\n\t\tif (bitfury->oldjob != newjob && thr->next_work && bitfury->chipgen)\n\t\t{\n\t\t\tmt_job_transition(thr);\n\t\t\t// TODO: Delay morework until right before it's needed\n\t\t\ttimer_set_now(&thr->tv_morework);\n\t\t\tjob_start_complete(thr);\n\t\t}\n\t\t\n\t\tfor (n = 0; newbuf[n] == oldbuf[n]; ++n)\n\t\t{\n\t\t\tif (unlikely(n >= 0xf))\n\t\t\t{\n\t\t\t\tinc_hw_errors2(thr, NULL, NULL);\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Full result match, reinitialising\",\n\t\t\t\t       proc->proc_repr);\n\t\t\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\t\t\tbitfury->desync_counter = 99;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcounter = bitfury_decnonce(newbuf[n]);\n\t\tif ((counter & 0xFFC00000) == 0xdf800000)\n\t\t{\n\t\t\tcounter &= 0x003fffff;\n\t\t\tint32_t cycles = counter - bitfury->counter1;\n\t\t\tif (cycles < 0)\n\t\t\t\tcycles += 0x00400000;\n\t\t\t\n\t\t\tif (cycles & 0x00200000)\n\t\t\t{\n\t\t\t\tlong long unsigned int period;\n\t\t\t\tdouble ns;\n\t\t\t\tstruct timeval d_time;\n\t\t\t\t\n\t\t\t\ttimersub(&(tv_now), &(bitfury->timer1), &d_time);\n\t\t\t\tperiod = timeval_to_us(&d_time) * 1000ULL;\n\t\t\t\tns = (double)period / (double)(cycles);\n\t\t\t\tbitfury->mhz = 1.0 / ns * 65.0 * 1000.0;\n\t\t\t\t\n\t\t\t\tif (bitfury->mhz_best)\n\t\t\t\t{\n\t\t\t\t\tconst double mhz_half_best = bitfury->mhz_best / 2;\n\t\t\t\t\tif (bitfury->mhz < mhz_half_best && bitfury->mhz_last < mhz_half_best)\n\t\t\t\t\t{\n\t\t\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Frequency drop over 50%% detected, reinitialising\",\n\t\t\t\t\t\t       proc->proc_repr);\n\t\t\t\t\t\tbitfury->force_reinit = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((int)bitfury->mhz > bitfury->mhz_best && bitfury->mhz_last > bitfury->mhz_best)\n\t\t\t\t{\n\t\t\t\t\t// mhz_best is the lowest of two sequential readings over the previous best\n\t\t\t\t\tif ((int)bitfury->mhz > bitfury->mhz_last)\n\t\t\t\t\t\tbitfury->mhz_best = bitfury->mhz_last;\n\t\t\t\t\telse\n\t\t\t\t\t\tbitfury->mhz_best = bitfury->mhz;\n\t\t\t\t}\n\t\t\t\tbitfury->mhz_last = bitfury->mhz;\n\t\t\t\t\n\t\t\t\tbitfury->counter1 = counter;\n\t\t\t\tcopy_time(&(bitfury->timer1), &tv_now);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (c->osc6_max)\n\t\t{\n\t\t\tif (stat_elapsed_secs >= 60)\n\t\t\t{\n\t\t\t\tdouble mh_diff, s_diff;\n\t\t\t\tconst int osc = bitfury->osc6_bits;\n\t\t\t\t\n\t\t\t\t// Copy current statistics\n\t\t\t\tmh_diff = bitfury->counter2 - c->omh;\n\t\t\t\ts_diff = total_secs - c->os;\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %.0f completed in %f seconds\",\n\t\t\t\t       proc->proc_repr, mh_diff, s_diff);\n\t\t\t\tif (osc >= c->osc6_min && osc <= c->osc6_max)\n\t\t\t\t{\n\t\t\t\t\tc->mh[osc] += mh_diff;\n\t\t\t\t\tc->s[osc] += s_diff;\n\t\t\t\t}\n\t\t\t\tc->omh = bitfury->counter2;\n\t\t\t\tc->os = total_secs;\n\t\t\t\tif (opt_debug && !c->best_done)\n\t\t\t\t{\n\t\t\t\t\tchar logbuf[0x100];\n\t\t\t\t\tlogbuf[0] = '\\0';\n\t\t\t\t\tfor (i = c->osc6_min; i <= c->osc6_max; ++i)\n\t\t\t\t\t\ttailsprintf(logbuf, sizeof(logbuf), \" %d=%.3f/%3.0fs\",\n\t\t\t\t\t\t            i, c->mh[i] / c->s[i], c->s[i]);\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\":%s\",\n\t\t\t\t\t       proc->proc_repr, logbuf);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Change freq;\n\t\t\t\tif (!c->best_done) {\n\t\t\t\t\tbitfury_select_freq(bitfury, proc);\n\t\t\t\t} else {\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Stable freq, osc6_bits: %d\",\n\t\t\t\t\t       proc->proc_repr, bitfury->osc6_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (n)\n\t\t{\n\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tnonce = bitfury_decnonce(newbuf[i]);\n\t\t\t\tif (unlikely(!bitfury->chipgen))\n\t\t\t\t{\n\t\t\t\t\tswitch (nonce & 0xe03fffff)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0x40060f87:\n\t\t\t\t\t\tcase 0x600054e0:\n\t\t\t\t\t\tcase 0x80156423:\n\t\t\t\t\t\tcase 0x991abced:\n\t\t\t\t\t\tcase 0xa004b2a0:\n\t\t\t\t\t\t\tif (++bitfury->chipgen_probe > 0x10)\n\t\t\t\t\t\t\t\tbitfury->chipgen = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xe03081a3:\n\t\t\t\t\t\tcase 0xe003df88:\n\t\t\t\t\t\t\tbitfury->chipgen = 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (bitfury->chipgen)\n\t\t\t\t\t\tgoto chipgen_detected;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (fudge_nonce(thr->work, &nonce))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": nonce %x = %08lx (work=%p)\",\n\t\t\t\t\t       proc->proc_repr, i, (unsigned long)nonce, thr->work);\n\t\t\t\t\tsubmit_nonce(thr, thr->work, nonce);\n\t\t\t\t\tbitfury->counter2 += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (!thr->prev_work)\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Ignoring unrecognised nonce %08lx (no prev work)\",\n\t\t\t\t\t       proc->proc_repr, (unsigned long)be32toh(nonce));\n\t\t\t\telse\n\t\t\t\tif (fudge_nonce(thr->prev_work, &nonce))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": nonce %x = %08lx (prev work=%p)\",\n\t\t\t\t\t       proc->proc_repr, i, (unsigned long)nonce, thr->prev_work);\n\t\t\t\t\tsubmit_nonce(thr, thr->prev_work, nonce);\n\t\t\t\t\tbitfury->counter2 += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinc_hw_errors(thr, thr->work, nonce);\n\t\t\t\t\t++bitfury->sample_hwe;\n\t\t\t\t\tbitfury->strange_counter += 1;\n\t\t\t\t}\n\t\t\t\tif (++bitfury->sample_tot >= 0x40 || bitfury->sample_hwe >= 8)\n\t\t\t\t{\n\t\t\t\t\tif (bitfury->sample_hwe >= 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": %d of the last %d results were bad, reinitialising\",\n\t\t\t\t\t\t       proc->proc_repr, bitfury->sample_hwe, bitfury->sample_tot);\n\t\t\t\t\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\t\t\t\t\tbitfury->desync_counter = 99;\n\t\t\t\t\t}\n\t\t\t\t\tbitfury->sample_tot = bitfury->sample_hwe = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((!bitfury->chipgen) && stat_elapsed_secs >= chipgen_timeout_secs)\n\t\t\t{\n\t\t\t\tbitfury->chipgen = 1;\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Failed to detect chip generation in %d seconds, falling back to gen%d assumption\",\n\t\t\t\t       proc->proc_repr, chipgen_timeout_secs, bitfury->chipgen);\nchipgen_detected:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Detected bitfury gen%d chip\",\n\t\t\t\t       proc->proc_repr, bitfury->chipgen);\n\t\t\t\tbitfury_payload_to_atrvec(bitfury->atrvec, &bitfury->payload);\n\t\t\t}\n\t\t\tbitfury->active = (bitfury->active + n) % 0x10;\n\t\t}\n\t\t\n\t\tmemcpy(&oldbuf[0], &newbuf[n], 4 * (0x10 - n));\n\t\tmemcpy(&oldbuf[0x10 - n], &newbuf[0], 4 * n);\n\t\tbitfury->oldjob = newjob;\n\t\t\nout:\n\t\tif (unlikely(bitfury->force_reinit))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Forcing reinitialisation\",\n\t\t\t       proc->proc_repr);\n\t\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\t\tbitfury->desync_counter = 99;\n\t\t\tbitfury->mhz_last = 0;\n\t\t\tbitfury->mhz_best = 0;\n\t\t\tbitfury->force_reinit = false;\n\t\t}\n\t\tif (stat_elapsed_secs >= 60)\n\t\t\tcopy_time(tvp_stat, &tv_now);\n\t}\n\t\n\ttimer_set_delay(&master_thr->tv_poll, &tv_now, 10000);\n}\n\nint64_t bitfury_job_process_results(struct thr_info *thr, struct work *work, bool stopping)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tswitch (bitfury->chipgen)\n\t{\n\t\tdefault:\n\t\tcase 1:\n\t\t\t// Bitfury gen1 chips process only 756/1024 of the nonce range\n\t\t\treturn 0xbd000000;\n\t\tcase 2:\n\t\t\t// Bitfury gen2 chips process only 864/1024 of the nonce range\n\t\t\treturn 0xd8000000;\n\t}\n}\n\nstruct api_data *bitfury_api_device_detail(struct cgpu_info * const cgpu)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct api_data *root = NULL;\n\t\n\troot = api_add_uint(root, \"fasync\", &bitfury->fasync, false);\n\tif (bitfury->chipgen)\n\t\troot = api_add_int(root, \"Chip Generation\", &bitfury->chipgen, false);\n\t\n\treturn root;\n}\n\nstruct api_data *bitfury_api_device_status(struct cgpu_info * const cgpu)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct api_data *root = NULL;\n\tint clock_bits = bitfury->osc6_bits;\n\t\n\troot = api_add_int(root, \"Clock Bits\", &clock_bits, true);\n\troot = api_add_freq(root, \"Frequency\", &bitfury->mhz, false);\n\t\n\treturn root;\n}\n\nstatic\nbool _bitfury_set_device_parse_setting(uint32_t * const rv, const char * const setting, char * const replybuf, const int maxval)\n{\n\tchar *p;\n\tlong int nv;\n\t\n\tif (!setting || !*setting)\n\t{\n\t\tsprintf(replybuf, \"missing setting\");\n\t\treturn false;\n\t}\n\tnv = strtol(setting, &p, 0);\n\tif (nv > maxval || nv < 1)\n\t{\n\t\tsprintf(replybuf, \"invalid setting\");\n\t\treturn false;\n\t}\n\t*rv = nv;\n\treturn true;\n}\n\nconst char *bitfury_set_baud(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tif (!_bitfury_set_device_parse_setting(&bitfury->spi->speed, setting, replybuf, INT_MAX))\n\t\treturn replybuf;\n\t\n\treturn NULL;\n}\n\nconst char *bitfury_set_osc6_bits(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tuint32_t newval;\n\tstruct freq_stat * const c = &bitfury->chip_stat;\n\t\n\tnewval = bitfury->osc6_bits;\n\tif (!_bitfury_set_device_parse_setting(&newval, setting, replybuf, BITFURY_MAX_OSC6_BITS))\n\t\treturn replybuf;\n\t\n\tbitfury->osc6_bits = newval;\n\tbitfury->force_reinit = true;\n\tc->osc6_max = 0;\n\t\n\treturn NULL;\n}\n\nconst struct bfg_set_device_definition bitfury_set_device_funcs[] = {\n\t{\"osc6_bits\", bitfury_set_osc6_bits, \"range 1-\"BITFURY_MAX_OSC6_BITS_S\" (slow to fast)\"},\n\t// NOTE: bitfury_set_device_funcs_probe should begin here:\n\t{\"baud\", bitfury_set_baud, \"SPI baud rate\"},\n\t{NULL},\n};\nconst struct bfg_set_device_definition *bitfury_set_device_funcs_probe = &bitfury_set_device_funcs[1];\n\n#ifdef HAVE_CURSES\nvoid bitfury_tui_wlogprint_choices(struct cgpu_info *cgpu)\n{\n\twlogprint(\"[O]scillator bits \");\n}\n\nconst char *bitfury_tui_handle_choice(struct cgpu_info *cgpu, int input)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tchar buf[0x100];\n\t\n\tswitch (input)\n\t{\n\t\tcase 'o': case 'O':\n\t\t{\n\t\t\tstruct freq_stat * const c = &bitfury->chip_stat;\n\t\t\tint val;\n\t\t\tchar *intvar;\n\t\t\t\n\t\t\tsprintf(buf, \"Set oscillator bits (range 1-%d; slow to fast)\", BITFURY_MAX_OSC6_BITS);\n\t\t\tintvar = curses_input(buf);\n\t\t\tif (!intvar)\n\t\t\t\treturn \"Invalid oscillator bits\\n\";\n\t\t\tval = atoi(intvar);\n\t\t\tfree(intvar);\n\t\t\tif (val < 1 || val > BITFURY_MAX_OSC6_BITS)\n\t\t\t\treturn \"Invalid oscillator bits\\n\";\n\t\t\t\n\t\t\tbitfury->osc6_bits = val;\n\t\t\tbitfury->force_reinit = true;\n\t\t\tc->osc6_max = 0;\n\t\t\t\n\t\t\treturn \"Oscillator bits changing\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid bitfury_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\twlogprint(\"Oscillator bits: %d\", bitfury->osc6_bits);\n\tif (bitfury->chipgen)\n\t\twlogprint(\"  Chip generation: %d\", bitfury->chipgen);\n\twlogprint(\"\\n\");\n}\n#endif\n\nstruct device_drv bitfury_drv = {\n\t.dname = \"bitfury_gpio\",\n\t.name = \"BFY\",\n\t.drv_detect = bitfury_detect,\n\t\n\t.thread_init = bitfury_init,\n\t.thread_disable = bitfury_disable,\n\t.thread_enable = bitfury_enable,\n\t.thread_shutdown = bitfury_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = bitfury_do_io,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n\n"
        },
        {
          "name": "driver-bitfury.h",
          "type": "blob",
          "size": 1.58203125,
          "content": "#ifndef BFG_DRIVER_BITFURY_H\n#define BFG_DRIVER_BITFURY_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"miner.h\"\n\n#define BITFURY_MAX_OSC6_BITS  60\n#define BITFURY_MAX_OSC6_BITS_S  \"60\"\n\nextern const struct bfg_set_device_definition bitfury_set_device_funcs[];\nextern const struct bfg_set_device_definition *bitfury_set_device_funcs_probe;\nextern const char *bitfury_set_baud(struct cgpu_info *, const char *, const char *, char *, enum bfg_set_device_replytype *);\nextern const char *bitfury_set_osc6_bits(struct cgpu_info *, const char *, const char *, char *, enum bfg_set_device_replytype *);\n\nextern bool bitfury_prepare(struct thr_info *);\nextern bool bitfury_init_chip(struct cgpu_info *);\nextern void bitfury_init_freq_stat(struct freq_stat *, int osc6_min, int osc6_max);\nextern void bitfury_clean_freq_stat(struct freq_stat *);\n\nextern bool bitfury_job_prepare(struct thr_info *, struct work *, uint64_t max_nonce);\nextern void bitfury_noop_job_start(struct thr_info *);\nextern void bitfury_do_io(struct thr_info *);\nextern int64_t bitfury_job_process_results(struct thr_info *, struct work *, bool stopping);\nextern struct api_data *bitfury_api_device_detail(struct cgpu_info *);\nextern struct api_data *bitfury_api_device_status(struct cgpu_info *);\nextern void bitfury_tui_wlogprint_choices(struct cgpu_info *);\nextern const char *bitfury_tui_handle_choice(struct cgpu_info *, int input);\nextern void bitfury_wlogprint_status(struct cgpu_info *);\n\nextern void bitfury_disable(struct thr_info *);\nextern void bitfury_enable(struct thr_info *);\nextern void bitfury_shutdown(struct thr_info *);\n\n#endif\n"
        },
        {
          "name": "driver-bitmain.c",
          "type": "blob",
          "size": 68.11328125,
          "content": "/*\n * Copyright 2012-2014 Lingchao Xu\n * Copyright 2015 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#ifndef WIN32\n  #include <sys/select.h>\n  #include <termios.h>\n  #include <sys/stat.h>\n  #include <fcntl.h>\n  #ifndef O_CLOEXEC\n    #define O_CLOEXEC 0\n  #endif\n#else\n  #include \"compat.h\"\n  #include <windows.h>\n  #include <io.h>\n#endif\n\n#include <curl/curl.h>\n#include <uthash.h>\n\n#include \"deviceapi.h\"\n#include \"miner.h\"\n#include \"driver-bitmain.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\nconst bool opt_bitmain_hwerror = true;\nconst unsigned bitmain_poll_interval_us = 10000;\n\nBFG_REGISTER_DRIVER(bitmain_drv)\nstatic const struct bfg_set_device_definition bitmain_set_device_funcs_init[];\n\n#define htole8(x) (x)\n\n#define BITMAIN_USING_CURL  -2\n\nstatic\nstruct cgpu_info *btm_alloc_cgpu(struct device_drv *drv, int threads)\n{\n\tstruct cgpu_info *cgpu = calloc(1, sizeof(*cgpu));\n\n\tif (unlikely(!cgpu))\n\t\tquit(1, \"Failed to calloc cgpu for %s in usb_alloc_cgpu\", drv->dname);\n\n\tcgpu->drv = drv;\n\tcgpu->deven = DEV_ENABLED;\n\tcgpu->threads = threads;\n\n\tcgpu->device_fd = -1;\n\n\tstruct bitmain_info *info = malloc(sizeof(*info));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to calloc bitmain_info data\");\n\tcgpu->device_data = info;\n\t\n\t*info = (struct bitmain_info){\n\t\t.chain_num = BITMAIN_DEFAULT_CHAIN_NUM,\n\t\t.asic_num = BITMAIN_DEFAULT_ASIC_NUM,\n\t\t.timeout = BITMAIN_DEFAULT_TIMEOUT,\n\t\t.frequency = BITMAIN_DEFAULT_FREQUENCY,\n\t\t.voltage[0] = BITMAIN_DEFAULT_VOLTAGE0,\n\t\t.voltage[1] = BITMAIN_DEFAULT_VOLTAGE1,\n\t\t\n\t\t.packet_max_nonce = BITMAIN_MAX_PACKET_MAX_NONCE,\n\t\t\n\t\t.diff = 255,\n\t\t.lowest_goal_diff = 255,\n\t\t.work_restart = true,\n\t};\n\tsprintf(info->frequency_t, \"%d\", BITMAIN_DEFAULT_FREQUENCY),\n\tstrcpy(info->voltage_t, BITMAIN_DEFAULT_VOLTAGE_T);\n\t\n\treturn cgpu;\n}\n\nstatic curl_socket_t bitmain_grab_socket_opensocket_cb(void *clientp, __maybe_unused curlsocktype purpose, struct curl_sockaddr *addr)\n{\n\tstruct bitmain_info * const info = clientp;\n\tcurl_socket_t sck = bfg_socket(addr->family, addr->socktype, addr->protocol);\n\tinfo->curl_sock = sck;\n\treturn sck;\n}\n\nstatic\nbool btm_init(struct cgpu_info *cgpu, const char * devpath)\n{\n\tapplog(LOG_DEBUG, \"btm_init cgpu->device_fd=%d\", cgpu->device_fd);\n\tint fd = -1;\n\tif(cgpu->device_fd >= 0) {\n\t\treturn false;\n\t}\n\tstruct bitmain_info *info = cgpu->device_data;\n\tif (!strncmp(devpath, \"ip:\", 3)) {\n\t\tCURL *curl = curl_easy_init();\n\t\tif (!curl)\n\t\t\tapplogr(false, LOG_ERR, \"%s: curl_easy_init failed\", cgpu->drv->dname);\n\t\t\n\t\t// CURLINFO_LASTSOCKET is broken on Win64 (which has a wider SOCKET type than curl_easy_getinfo returns), so we use this hack for now\n\t\tinfo->curl_sock = -1;\n\t\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETFUNCTION, bitmain_grab_socket_opensocket_cb);\n\t\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETDATA, info);\n\t\t\n\t\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5);\n\t\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_URL, &devpath[3]);\n\t\tif (curl_easy_perform(curl)) {\n\t\t\tcurl_easy_cleanup(curl);\n\t\t\tapplogr(false, LOG_ERR, \"%s: curl_easy_perform failed for %s\", cgpu->drv->dname, &devpath[3]);\n\t\t}\n\t\tcgpu->device_path = strdup(devpath);\n\t\tcgpu->device_fd = BITMAIN_USING_CURL;\n\t\tinfo->device_curl = curl;\n\t\treturn true;\n\t}\n\tfd = serial_open(devpath, 0, 1, false);\n\tif(fd == -1) {\n\t\tapplog(LOG_DEBUG, \"%s open %s error %d\",\n\t\t\t\tcgpu->drv->dname, devpath, errno);\n\t\treturn false;\n\t}\n\tcgpu->device_path = strdup(devpath);\n\tcgpu->device_fd = fd;\n\tapplog(LOG_DEBUG, \"btm_init open device fd = %d\", cgpu->device_fd);\n\treturn true;\n}\n\nstatic\nvoid btm_uninit(struct cgpu_info *cgpu)\n{\n\tstruct bitmain_info * const info = cgpu->device_data;\n\t\n\tapplog(LOG_DEBUG, \"BTM uninit %s%i\", cgpu->drv->name, cgpu->device_fd);\n\n\t// May have happened already during a failed initialisation\n\t//  if release_cgpu() was called due to a USB NODEV(err)\n\tif (cgpu->device_fd >= 0) {\n\t\tserial_close(cgpu->device_fd);\n\t\tcgpu->device_fd = -1;\n\t}\n\tif (info->device_curl) {\n\t\tcurl_easy_cleanup(info->device_curl);\n\t\tinfo->device_curl = NULL;\n\t}\n\tif(cgpu->device_path) {\n\t\tfree((char*)cgpu->device_path);\n\t\tcgpu->device_path = NULL;\n\t}\n}\n\nbool bitmain_curl_all(const bool is_recv, const int fd, CURL * const curl, void *p, size_t remsz)\n{\n\tCURLcode (* const func)(CURL *, void *, size_t, size_t *) = is_recv ? (void*)curl_easy_recv : (void*)curl_easy_send;\n\tCURLcode r;\n\tsize_t sz;\n\twhile (remsz) {\n\t\tfd_set otherfds, thisfds;\n\t\tFD_ZERO(&otherfds);\n\t\tFD_ZERO(&thisfds);\n\t\tFD_SET(fd, &thisfds);\n\t\tselect(fd + 1, is_recv ? &thisfds : &otherfds, is_recv ? &otherfds : &thisfds, &thisfds, NULL);\n\t\tr = func(curl, p, remsz, &sz);\n\t\tswitch (r) {\n\t\t\tcase CURLE_OK:\n\t\t\t\tremsz -= sz;\n\t\t\t\tp += sz;\n\t\t\t\tbreak;\n\t\t\tcase CURLE_AGAIN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic\nint btm_read(struct cgpu_info * const cgpu, void * const buf, const size_t bufsize)\n{\n\tint err = 0;\n\t//applog(LOG_DEBUG, \"btm_read ----- %d -----\", bufsize);\n\tif (unlikely(cgpu->device_fd == BITMAIN_USING_CURL)) {\n\t\tstruct bitmain_info * const info = cgpu->device_data;\n\t\tuint8_t headbuf[5];\n\t\theadbuf[0] = 0;\n\t\tpk_u32be(headbuf, 1, bufsize);\n\t\tif (!bitmain_curl_all(false, info->curl_sock, info->device_curl, headbuf, sizeof(headbuf)))\n\t\t\treturn -1;\n\t\tif (!bitmain_curl_all( true, info->curl_sock, info->device_curl, headbuf, 4))\n\t\t\treturn -1;\n\t\tif (headbuf[0] == 0xff && headbuf[1] == 0xff && headbuf[2] == 0xff && headbuf[3] == 0xff)\n\t\t\treturn -1;\n\t\tsize_t sz = upk_u32be(headbuf, 0);\n\t\tif (!bitmain_curl_all( true, info->curl_sock, info->device_curl, buf, sz))\n\t\t\treturn -1;\n\t\treturn sz;\n\t}\n\terr = read(cgpu->device_fd, buf, bufsize);\n\treturn err;\n}\n\nstatic\nint btm_write(struct cgpu_info * const cgpu, void * const buf, const size_t bufsize)\n{\n\tint err = 0;\n\t//applog(LOG_DEBUG, \"btm_write ----- %d -----\", bufsize);\n\tif (unlikely(cgpu->device_fd == BITMAIN_USING_CURL)) {\n\t\tstruct bitmain_info * const info = cgpu->device_data;\n\t\tuint8_t headbuf[5];\n\t\theadbuf[0] = 1;\n\t\tpk_u32be(headbuf, 1, bufsize);\n\t\tif (!bitmain_curl_all(false, info->curl_sock, info->device_curl, headbuf, sizeof(headbuf)))\n\t\t\treturn -1;\n\t\tif (!bitmain_curl_all(false, info->curl_sock, info->device_curl, buf, bufsize))\n\t\t\treturn -1;\n\t\tif (!bitmain_curl_all( true, info->curl_sock, info->device_curl, headbuf, 4))\n\t\t\treturn -1;\n\t\tif (headbuf[0] == 0xff && headbuf[1] == 0xff && headbuf[2] == 0xff && headbuf[3] == 0xff)\n\t\t\treturn -1;\n\t\treturn upk_u32be(headbuf, 0);\n\t}\n\terr = write(cgpu->device_fd, buf, bufsize);\n\treturn err;\n}\n\n#ifdef WIN32\n#define BITMAIN_TEST\n#endif\n\n#define BITMAIN_TEST_PRINT_WORK 0\n#ifdef BITMAIN_TEST\n#define BITMAIN_TEST_NUM 19\n#define BITMAIN_TEST_USENUM 1\nint g_test_index = 0;\nconst char btm_work_test_data[BITMAIN_TEST_NUM][256] = {\n\t\t\"00000002ddc1ce5579dbec17f17fbb8f31ae218a814b2a0c1900f0d90000000100000000b58aa6ca86546b07a5a46698f736c7ca9c0eedc756d8f28ac33c20cc24d792675276f879190afc85b6888022000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000eb2d45233c5b02de50ddcb9049ba16040e0ba00e9750a474eec75891571d925b52dfda4a190266667145b02f000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b19000000000000000090c7d3743e0b0562e4f56d3dd35cece3c5e8275d0abb21bf7e503cb72bd7ed3b52dfda4a190266667bbb58d7000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b1900000000000000006e0561da06022bfbb42c5ecd74a46bfd91934f201b777e9155cc6c3674724ec652dfda4a19026666a0cd827b000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b1900000000000000000312f42ce4964cc23f2d8c039f106f25ddd58e10a1faed21b3bba4b0e621807b52dfda4a1902666629c9497d000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b19000000000000000033093a6540dbe8f7f3d19e3d2af05585ac58dafad890fa9a942e977334a23d6e52dfda4a190266665ae95079000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000bd7893057d06e69705bddf9a89c7bac6b40c5b32f15e2295fc8c5edf491ea24952dfda4a190266664b89b4d3000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b19000000000000000075e66f533e53837d14236a793ee4e493985642bc39e016b9e63adf14a584a2aa52dfda4a19026666ab5d638d000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000d936f90c5db5f0fe1d017344443854fbf9e40a07a9b7e74fedc8661c23162bff52dfda4a19026666338e79cb000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000d2c1a7d279a4355b017bc0a4b0a9425707786729f21ee18add3fda4252a31a4152dfda4a190266669bc90806000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000ad36d19f33d04ca779942843890bc3b083cec83a4b60b6c45cf7d21fc187746552dfda4a1902666675d81ab7000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b19000000000000000093b809cf82b76082eacb55bc35b79f31882ed0976fd102ef54783cd24341319b52dfda4a1902666642ab4e42000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b1900000000000000007411ff315430a7bbf41de8a685d457e82d5177c05640d6a4436a40f39e99667852dfda4a190266662affa4b5000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b1900000000000000001ad0db5b9e1e2b57c8d3654c160f5a51067521eab7e340a270639d97f00a3fa252dfda4a1902666601a47bb6000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b19000000000000000022e055c442c46bbe16df68603a26891f6e4cf85b90102b39fd7cadb602b4e34552dfda4a1902666695d33cea000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b1900000000000000009c8baf5a8a1e16de2d6ae949d5fec3ed751f10dcd4c99810f2ce08040fb9e31d52dfda4a19026666fe78849d000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000e5655532b414887f35eb4652bc7b11ebac12891f65bc08cbe0ce5b277b9e795152dfda4a19026666fcc0d1d1000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000f272c5508704e2b62dd1c30ea970372c40bf00f9203f9bf69d456b4a7fbfffe352dfda4a19026666c03d4399000000800000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\"0000000256ccc4c8aeae2b1e41490bc352893605f284e4be043f7b190000000000000000fca3b4531ba627ad9b0e23cdd84c888952c23810df196e9c6db0bcecba6a830952dfda4a19026666c14009cb000000800000000000000000000000000000000000000000000000000000000000000000\"\n};\nconst char btm_work_test_midstate[BITMAIN_TEST_NUM][256] = {\n\t\t\"2d8738e7f5bcf76dcb8316fec772e20e240cd58c88d47f2d3f5a6a9547ed0a35\",\n\t\t\"d31b6ce09c0bfc2af6f3fe3a03475ebefa5aa191fa70a327a354b2c22f9692f1\",\n\t\t\"84a8c8224b80d36caeb42eff2a100f634e1ff873e83fd02ef1306a34abef9dbe\",\n\t\t\"059882159439b9b32968c79a93c5521e769dbea9d840f56c2a17b9ad87e530b8\",\n\t\t\"17fa435d05012574f8f1da26994cc87b6cb9660b5e82072dc6a0881cec150a0d\",\n\t\t\"92a28cc5ec4ba6a2688471dfe2032b5fe97c805ca286c503e447d6749796c6af\",\n\t\t\"1677a03516d6e9509ac37e273d2482da9af6e077abe8392cdca6a30e916a7ae9\",\n\t\t\"50bbe09f1b8ac18c97aeb745d5d2c3b5d669b6ac7803e646f65ac7b763a392d1\",\n\t\t\"e46a0022ebdc303a7fb1a0ebfa82b523946c312e745e5b8a116b17ae6b4ce981\",\n\t\t\"8f2f61e7f5b4d76d854e6d266acfff4d40347548216838ccc4ef3b9e43d3c9ea\",\n\t\t\"0a450588ae99f75d676a08d0326e1ea874a3497f696722c78a80c7b6ee961ea6\",\n\t\t\"3c4c0fc2cf040b806c51b46de9ec0dcc678a7cc5cf3eff11c6c03de3bc7818cc\",\n\t\t\"f6c7c785ab5daddb8f98e5f854f2cb41879fcaf47289eb2b4196fefc1b28316f\",\n\t\t\"005312351ccb0d0794779f5023e4335b5cad221accf0dfa3da7b881266fa9f5a\",\n\t\t\"7b26d189c6bba7add54143179aadbba7ccaeff6887bd8d5bec9597d5716126e6\",\n\t\t\"a4718f4c801e7ddf913a9474eb71774993525684ffea1915f767ab16e05e6889\",\n\t\t\"6b6226a8c18919d0e55684638d33a6892a00d22492cc2f5906ca7a4ac21c74a7\",\n\t\t\"383114dccd1cb824b869158aa2984d157fcb02f46234ceca65943e919329e697\",\n\t\t\"d4d478df3016852b27cb1ae9e1e98d98617f8d0943bf9dc1217f47f817236222\"\n};\n#endif\n\nbool opt_bitmain_checkall = false;\nbool opt_bitmain_nobeeper = false;\nbool opt_bitmain_notempoverctrl = false;\nbool opt_bitmain_homemode = false;\nbool opt_bitmain_auto;\n\n// --------------------------------------------------------------\n//      CRC16 check table\n// --------------------------------------------------------------\nstatic\nconst uint8_t chCRCHTalbe[] =                                 // CRC high byte table\n{\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n 0x00, 0xC1, 0x81, 0x40\n};\n\nstatic\nconst uint8_t chCRCLTalbe[] =                                 // CRC low byte table\n{\n 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,\n 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,\n 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,\n 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,\n 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,\n 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,\n 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,\n 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,\n 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,\n 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,\n 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,\n 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,\n 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,\n 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,\n 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,\n 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,\n 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,\n 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,\n 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,\n 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,\n 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,\n 0x41, 0x81, 0x80, 0x40\n};\n\nstatic uint16_t CRC16(const uint8_t* p_data, uint16_t w_len)\n{\n\tuint8_t chCRCHi = 0xFF; // CRC high byte initialize\n\tuint8_t chCRCLo = 0xFF; // CRC low byte initialize\n\tuint16_t wIndex = 0;    // CRC cycling index\n\n\twhile (w_len--) {\n\t\twIndex = chCRCLo ^ *p_data++;\n\t\tchCRCLo = chCRCHi ^ chCRCHTalbe[wIndex];\n\t\tchCRCHi = chCRCLTalbe[wIndex];\n\t}\n\treturn ((chCRCHi << 8) | chCRCLo);\n}\n\nstatic uint32_t num2bit(int num) {\n\treturn 1L << (31 - num);\n}\n\nstatic int bitmain_set_txconfig(struct bitmain_txconfig_token *bm,\n\t\t\t    uint8_t reset, uint8_t fan_eft, uint8_t timeout_eft, uint8_t frequency_eft,\n\t\t\t    uint8_t voltage_eft, uint8_t chain_check_time_eft, uint8_t chip_config_eft, uint8_t hw_error_eft,\n\t\t\t    uint8_t beeper_ctrl, uint8_t temp_over_ctrl,uint8_t fan_home_mode,\n\t\t\t    uint8_t chain_num, uint8_t asic_num, uint8_t fan_pwm_data, uint8_t timeout_data,\n\t\t\t    uint16_t frequency, uint8_t * voltage, uint8_t chain_check_time,\n\t\t\t    uint8_t chip_address, uint8_t reg_address, uint8_t * reg_data)\n{\n\tuint16_t crc = 0;\n\tint datalen = 0;\n\tuint8_t version = 0;\n\tuint8_t * sendbuf = (uint8_t *)bm;\n\tif (unlikely(!bm)) {\n\t\tapplog(LOG_WARNING, \"bitmain_set_txconfig bitmain_txconfig_token is null\");\n\t\treturn -1;\n\t}\n\n\tif (unlikely(timeout_data <= 0 || asic_num <= 0 || chain_num <= 0)) {\n\t\tapplog(LOG_WARNING, \"bitmain_set_txconfig parameter invalid timeout_data(%d) asic_num(%d) chain_num(%d)\",\n\t\t\t\ttimeout_data, asic_num, chain_num);\n\t\treturn -1;\n\t}\n\n\tdatalen = sizeof(struct bitmain_txconfig_token);\n\tmemset(bm, 0, datalen);\n\n\tbm->token_type = BITMAIN_TOKEN_TYPE_TXCONFIG;\n\tbm->version = version;\n\tbm->length = datalen-4;\n\tbm->length = htole16(bm->length);\n\n\tbm->reset = reset;\n\tbm->fan_eft = fan_eft;\n\tbm->timeout_eft = timeout_eft;\n\tbm->frequency_eft = frequency_eft;\n\tbm->voltage_eft = voltage_eft;\n\tbm->chain_check_time_eft = chain_check_time_eft;\n\tbm->chip_config_eft = chip_config_eft;\n\tbm->hw_error_eft = hw_error_eft;\n\tbm->beeper_ctrl = beeper_ctrl;\n\tbm->temp_over_ctrl = temp_over_ctrl;\n\tbm->fan_home_mode = fan_home_mode;\n\n\tsendbuf[4] = htole8(sendbuf[4]);\n\tsendbuf[5] = htole8(sendbuf[5]);\n\n\tbm->chain_num = chain_num;\n\tbm->asic_num = asic_num;\n\tbm->fan_pwm_data = fan_pwm_data;\n\tbm->timeout_data = timeout_data;\n\n\tbm->frequency = htole16(frequency);\n\tmemcpy(bm->voltage, voltage, 2);\n\tbm->chain_check_time = chain_check_time;\n\n\tmemcpy(bm->reg_data, reg_data, 4);\n\tbm->chip_address = chip_address;\n\tbm->reg_address = reg_address;\n\n\tcrc = CRC16((uint8_t *)bm, datalen-2);\n\tbm->crc = htole16(crc);\n\n\tapplog(LOG_ERR, \"BTM TxConfigToken:v(%d) reset(%d) fan_e(%d) tout_e(%d) fq_e(%d) vt_e(%d) chainc_e(%d) chipc_e(%d) hw_e(%d) b_c(%d) t_c(%d) f_m(%d) mnum(%d) anum(%d) fanpwmdata(%d) toutdata(%d) freq(%d) volt(%02x%02x) chainctime(%d) regdata(%02x%02x%02x%02x) chipaddr(%02x) regaddr(%02x) crc(%04x)\",\n\t\t\t\t\tversion, reset, fan_eft, timeout_eft, frequency_eft, voltage_eft,\n\t\t\t\t\tchain_check_time_eft, chip_config_eft, hw_error_eft, beeper_ctrl, temp_over_ctrl,fan_home_mode,chain_num, asic_num,\n\t\t\t\t\tfan_pwm_data, timeout_data, frequency, voltage[0], voltage[1],\n\t\t\t\t\tchain_check_time, reg_data[0], reg_data[1], reg_data[2], reg_data[3], chip_address, reg_address, crc);\n\n\treturn datalen;\n}\n\nstatic int bitmain_set_rxstatus(struct bitmain_rxstatus_token *bm,\n\t\tuint8_t chip_status_eft, uint8_t detect_get, uint8_t chip_address, uint8_t reg_address)\n{\n\tuint16_t crc = 0;\n\tuint8_t version = 0;\n\tint datalen = 0;\n\tuint8_t * sendbuf = (uint8_t *)bm;\n\n\tif (unlikely(!bm)) {\n\t\tapplog(LOG_WARNING, \"bitmain_set_rxstatus bitmain_rxstatus_token is null\");\n\t\treturn -1;\n\t}\n\n\tdatalen = sizeof(struct bitmain_rxstatus_token);\n\tmemset(bm, 0, datalen);\n\n\tbm->token_type = BITMAIN_TOKEN_TYPE_RXSTATUS;\n\tbm->version = version;\n\tbm->length = datalen-4;\n\tbm->length = htole16(bm->length);\n\n\tbm->chip_status_eft = chip_status_eft;\n\tbm->detect_get = detect_get;\n\n\tsendbuf[4] = htole8(sendbuf[4]);\n\n\tbm->chip_address = chip_address;\n\tbm->reg_address = reg_address;\n\n\tcrc = CRC16((uint8_t *)bm, datalen-2);\n\tbm->crc = htole16(crc);\n\n\tapplog(LOG_ERR, \"BitMain RxStatus Token: v(%d) chip_status_eft(%d) detect_get(%d) chip_address(%02x) reg_address(%02x) crc(%04x)\",\n\t\t\t\tversion, chip_status_eft, detect_get, chip_address, reg_address, crc);\n\n\treturn datalen;\n}\n\nstatic int bitmain_parse_rxstatus(const uint8_t * data, int datalen, struct bitmain_rxstatus_data *bm)\n{\n\tuint16_t crc = 0;\n\tuint8_t version = 0;\n\tint i = 0, j = 0;\n\tint asic_num = 0;\n\tint dataindex = 0;\n\tuint8_t tmp = 0x01;\n\tif (unlikely(!bm)) {\n\t\tapplog(LOG_WARNING, \"bitmain_parse_rxstatus bitmain_rxstatus_data is null\");\n\t\treturn -1;\n\t}\n\tif (unlikely(!data || datalen <= 0)) {\n\t\tapplog(LOG_WARNING, \"bitmain_parse_rxstatus parameter invalid data is null or datalen(%d) error\", datalen);\n\t\treturn -1;\n\t}\n\tmemset(bm, 0, sizeof(struct bitmain_rxstatus_data));\n\tmemcpy(bm, data, 28);\n\tif (bm->data_type != BITMAIN_DATA_TYPE_RXSTATUS) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus datatype(%02x) error\", bm->data_type);\n\t\treturn -1;\n\t}\n\tif (bm->version != version) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus version(%02x) error\", bm->version);\n\t\treturn -1;\n\t}\n\tbm->length = htole16(bm->length);\n\tif (bm->length+4 != datalen) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus length(%d) datalen(%d) error\", bm->length, datalen);\n\t\treturn -1;\n\t}\n\tcrc = CRC16(data, datalen-2);\n\tmemcpy(&(bm->crc), data+datalen-2, 2);\n\tbm->crc = htole16(bm->crc);\n\tif(crc != bm->crc) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus check crc(%d) != bm crc(%d) datalen(%d)\", crc, bm->crc, datalen);\n\t\treturn -1;\n\t}\n\tbm->fifo_space = htole16(bm->fifo_space);\n\tbm->fan_exist = htole16(bm->fan_exist);\n\tbm->temp_exist = htole32(bm->temp_exist);\n\tbm->nonce_error = htole32(bm->nonce_error);\n\tif(bm->chain_num > BITMAIN_MAX_CHAIN_NUM) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus chain_num=%d error\", bm->chain_num);\n\t\treturn -1;\n\t}\n\tdataindex = 28;\n\tif(bm->chain_num > 0) {\n\t\tmemcpy(bm->chain_asic_num, data+datalen-2-bm->chain_num-bm->temp_num-bm->fan_num, bm->chain_num);\n\t}\n\tfor(i = 0; i < bm->chain_num; i++) {\n\t\tasic_num = bm->chain_asic_num[i];\n\t\tif(asic_num <= 0) {\n\t\t\tasic_num = 1;\n\t\t} else {\n\t\t\tif(asic_num % 32 == 0) {\n\t\t\t\tasic_num = asic_num / 32;\n\t\t\t} else {\n\t\t\t\tasic_num = asic_num / 32 + 1;\n\t\t\t}\n\t\t}\n\t\tmemcpy((uint8_t *)bm->chain_asic_exist+i*32, data+dataindex, asic_num*4);\n\t\tdataindex += asic_num*4;\n\t}\n\tfor(i = 0; i < bm->chain_num; i++) {\n\t\tasic_num = bm->chain_asic_num[i];\n\t\tif(asic_num <= 0) {\n\t\t\tasic_num = 1;\n\t\t} else {\n\t\t\tif(asic_num % 32 == 0) {\n\t\t\t\tasic_num = asic_num / 32;\n\t\t\t} else {\n\t\t\t\tasic_num = asic_num / 32 + 1;\n\t\t\t}\n\t\t}\n\t\tmemcpy((uint8_t *)bm->chain_asic_status+i*32, data+dataindex, asic_num*4);\n\t\tdataindex += asic_num*4;\n\t}\n\tdataindex += bm->chain_num;\n\tif(dataindex + bm->temp_num + bm->fan_num + 2 != datalen) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxstatus dataindex(%d) chain_num(%d) temp_num(%d) fan_num(%d) not match datalen(%d)\",\n\t\t\t\tdataindex, bm->chain_num, bm->temp_num, bm->fan_num, datalen);\n\t\treturn -1;\n\t}\n\tfor(i = 0; i < bm->chain_num; i++) {\n\t\t//bm->chain_asic_status[i] = swab32(bm->chain_asic_status[i]);\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tbm->chain_asic_exist[i*8+j] = htole32(bm->chain_asic_exist[i*8+j]);\n\t\t\tbm->chain_asic_status[i*8+j] = htole32(bm->chain_asic_status[i*8+j]);\n\t\t}\n\t}\n\tif(bm->temp_num > 0) {\n\t\tmemcpy(bm->temp, data+dataindex, bm->temp_num);\n\t\tdataindex += bm->temp_num;\n\t}\n\tif(bm->fan_num > 0) {\n\t\tmemcpy(bm->fan, data+dataindex, bm->fan_num);\n\t\tdataindex += bm->fan_num;\n\t}\n\tif(!opt_bitmain_checkall){\n\t\tif(tmp != htole8(tmp)){\n\t\t\tapplog(LOG_ERR, \"BitMain RxStatus   byte4 0x%02x chip_value_eft %d reserved %d get_blk_num %d \",*((uint8_t* )bm +4),bm->chip_value_eft,bm->reserved1,bm->get_blk_num);\n\t\t\tmemcpy(&tmp,data+4,1);\n\t\t\tbm->chip_value_eft = tmp >>7;\n\t\t\tbm->get_blk_num = tmp >> 4;\n\t\t\tbm->reserved1 = ((tmp << 4) & 0xff) >> 5;\n\t\t}\t\n\t\tfound_blocks = bm->get_blk_num;\t\n\t\tapplog(LOG_ERR, \"BitMain RxStatus tmp :0x%02x  byte4 0x%02x chip_value_eft %d reserved %d get_blk_num %d \",tmp,*((uint8_t* )bm +4),bm->chip_value_eft,bm->reserved1,bm->get_blk_num);\n\t}\n\tapplog(LOG_DEBUG, \"BitMain RxStatusData: chipv_e(%d) chainnum(%d) fifos(%d) v1(%d) v2(%d) v3(%d) v4(%d) fann(%d) tempn(%d) fanet(%04x) tempet(%08x) ne(%d) regvalue(%d) crc(%04x)\",\n\t\t\tbm->chip_value_eft, bm->chain_num, bm->fifo_space, bm->hw_version[0], bm->hw_version[1], bm->hw_version[2], bm->hw_version[3], bm->fan_num, bm->temp_num, bm->fan_exist, bm->temp_exist, bm->nonce_error, bm->reg_value, bm->crc);\n\tapplog(LOG_DEBUG, \"BitMain RxStatus Data chain info:\");\n\tfor(i = 0; i < bm->chain_num; i++) {\n\t\tapplog(LOG_DEBUG, \"BitMain RxStatus Data chain(%d) asic num=%d asic_exist=%08x asic_status=%08x\", i+1, bm->chain_asic_num[i], bm->chain_asic_exist[i*8], bm->chain_asic_status[i*8]);\n\t}\n\tapplog(LOG_DEBUG, \"BitMain RxStatus Data temp info:\");\n\tfor(i = 0; i < bm->temp_num; i++) {\n\t\tapplog(LOG_DEBUG, \"BitMain RxStatus Data temp(%d) temp=%d\", i+1, bm->temp[i]);\n\t}\n\tapplog(LOG_DEBUG, \"BitMain RxStatus Data fan info:\");\n\tfor(i = 0; i < bm->fan_num; i++) {\n\t\tapplog(LOG_DEBUG, \"BitMain RxStatus Data fan(%d) fan=%d\", i+1, bm->fan[i]);\n\t}\n\treturn 0;\n}\n\nstatic int bitmain_parse_rxnonce(const uint8_t * data, int datalen, struct bitmain_rxnonce_data *bm, int * nonce_num)\n{\n\tint i = 0;\n\tuint16_t crc = 0;\n\tuint8_t version = 0;\n\tint curnoncenum = 0;\n\tif (unlikely(!bm)) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce bitmain_rxstatus_data null\");\n\t\treturn -1;\n\t}\n\tif (unlikely(!data || datalen <= 0)) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce data null or datalen(%d) error\", datalen);\n\t\treturn -1;\n\t}\n\tmemcpy(bm, data, sizeof(struct bitmain_rxnonce_data));\n\tif (bm->data_type != BITMAIN_DATA_TYPE_RXNONCE) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce datatype(%02x) error\", bm->data_type);\n\t\treturn -1;\n\t}\n\tif (bm->version != version) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce version(%02x) error\", bm->version);\n\t\treturn -1;\n\t}\n\tbm->length = htole16(bm->length);\n\tif (bm->length+4 != datalen) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce length(%d) error\", bm->length);\n\t\treturn -1;\n\t}\n\tcrc = CRC16(data, datalen-2);\n\tmemcpy(&(bm->crc), data+datalen-2, 2);\n\tbm->crc = htole16(bm->crc);\n\tif(crc != bm->crc) {\n\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce check crc(%d) != bm crc(%d) datalen(%d)\", crc, bm->crc, datalen);\n\t\treturn -1;\n\t}\n\tbm->fifo_space = htole16(bm->fifo_space);\n\tbm->diff = htole16(bm->diff);\n\tbm->total_nonce_num = htole64(bm->total_nonce_num);\n\tcurnoncenum = (datalen-14)/8;\n\tapplog(LOG_DEBUG, \"BitMain RxNonce Data: nonce_num(%d) fifo_space(%d) diff(%d) tnn(%\"PRIu64\")\", curnoncenum, bm->fifo_space, bm->diff, bm->total_nonce_num);\n\tfor(i = 0; i < curnoncenum; i++) {\n\t\tbm->nonces[i].work_id = htole32(bm->nonces[i].work_id);\n\t\tbm->nonces[i].nonce = htole32(bm->nonces[i].nonce);\n\n\t\tapplog(LOG_DEBUG, \"BitMain RxNonce Data %d: work_id(%d) nonce(%08x)(%d)\",\n\t\t\t\ti, bm->nonces[i].work_id, bm->nonces[i].nonce, bm->nonces[i].nonce);\n\t}\n\t*nonce_num = curnoncenum;\n\treturn 0;\n}\n\nstatic int bitmain_read(struct cgpu_info *bitmain, unsigned char *buf,\n\t\t       size_t bufsize, int timeout)\n{\n\tint err = 0;\n\tsize_t total = 0;\n\n\tif(bitmain == NULL || buf == NULL || bufsize <= 0) {\n\t\tapplog(LOG_WARNING, \"bitmain_read parameter error bufsize(%\"PRIu64\")\", (uint64_t)bufsize);\n\t\treturn -1;\n\t}\n\t{\n\t\terr = btm_read(bitmain, buf, bufsize);\n\t\ttotal = err;\n\t}\n\treturn total;\n}\n\nstatic int bitmain_write(struct cgpu_info *bitmain, char *buf, ssize_t len)\n{\n\tint err;\n\t{\n\t\tint havelen = 0;\n\t\twhile(havelen < len) {\n\t\t\terr = btm_write(bitmain, buf+havelen, len-havelen);\n\t\t\tif(err < 0) {\n\t\t\t\tapplog(LOG_DEBUG, \"%s%i: btm_write got err %d\", bitmain->drv->name,\n\t\t\t\t\t\tbitmain->device_id, err);\n\t\t\t\tapplog(LOG_WARNING, \"usb_write error on bitmain_write\");\n\t\t\t\treturn BTM_SEND_ERROR;\n\t\t\t} else {\n\t\t\t\thavelen += err;\n\t\t\t}\n\t\t}\n\t}\n\treturn BTM_SEND_OK;\n}\n\nstatic int bitmain_send_data(const uint8_t * data, int datalen, struct cgpu_info *bitmain)\n{\n\tint ret;\n\n\tif(datalen <= 0) {\n\t\treturn 0;\n\t}\n\n\t//struct bitmain_info *info = bitmain->device_data;\n\t//int delay;\n\t//delay = datalen * 10 * 1000000;\n\t//delay = delay / info->baud;\n\t//delay += 4000;\n\n\tif(opt_debug) {\n\t\tchar hex[(datalen * 2) + 1];\n\t\tbin2hex(hex, data, datalen);\n\t\tapplog(LOG_DEBUG, \"BitMain: Sent(%d): %s\", datalen, hex);\n\t}\n\n\t//cgtimer_t ts_start;\n\t//cgsleep_prepare_r(&ts_start);\n\t//applog(LOG_DEBUG, \"----bitmain_send_data  start\");\n\tret = bitmain_write(bitmain, (char *)data, datalen);\n\tapplog(LOG_DEBUG, \"----bitmain_send_data  stop ret=%d datalen=%d\", ret, datalen);\n\t//cgsleep_us_r(&ts_start, delay);\n\n\t//applog(LOG_DEBUG, \"BitMain: Sent: Buffer delay: %dus\", delay);\n\n\treturn ret;\n}\n\nstatic void bitmain_inc_nvw(struct bitmain_info *info, struct thr_info *thr)\n{\n\tapplog(LOG_INFO, \"%s%d: No matching work - HW error\",\n\t       thr->cgpu->drv->name, thr->cgpu->device_id);\n\n\tinc_hw_errors_only(thr);\n\tinfo->no_matching_work++;\n}\n\nstatic inline void record_temp_fan(struct bitmain_info *info, struct bitmain_rxstatus_data *bm, float *temp)\n{\n\tint i = 0;\n\tint maxfan = 0, maxtemp = 0;\n\tint temp_avg = 0;\n\n\tinfo->fan_num = bm->fan_num;\n\tfor(i = 0; i < bm->fan_num; i++) {\n\t\tinfo->fan[i] = bm->fan[i] * BITMAIN_FAN_FACTOR;\n\n\t\tif(info->fan[i] > maxfan)\n\t\t\tmaxfan = info->fan[i];\n\t}\n\tinfo->temp_num = bm->temp_num;\n\tfor(i = 0; i < bm->temp_num; i++) {\n\t\tinfo->temp[i] = bm->temp[i];\n\t\t/*\n\t\tif(bm->temp[i] & 0x80) {\n\t\t\tbm->temp[i] &= 0x7f;\n\t\t\tinfo->temp[i] = 0 - ((~bm->temp[i] & 0x7f) + 1);\n\t\t}*/\n\t\ttemp_avg += info->temp[i];\n\n\t\tif(info->temp[i] > info->temp_max) {\n\t\t\tinfo->temp_max = info->temp[i];\n\t\t}\n\t\tif(info->temp[i] > maxtemp)\n\t\t\tmaxtemp = info->temp[i];\n\t}\n\n\tif(bm->temp_num > 0) {\n\t\ttemp_avg /= bm->temp_num;\n\t\tinfo->temp_avg = temp_avg;\n\t}\n\n\t*temp = maxtemp;\n}\n\nstatic void bitmain_update_temps(struct cgpu_info *bitmain, struct bitmain_info *info,\n\t\t\t\tstruct bitmain_rxstatus_data *bm)\n{\n\tchar tmp[64] = {0};\n\tchar msg[10240] = {0};\n\tint i = 0;\n\trecord_temp_fan(info, bm, &(bitmain->temp));\n\n\tstrcpy(msg, \"BitMain: \");\n\tfor(i = 0; i < bm->fan_num; i++) {\n\t\tif(i != 0) {\n\t\t\tstrcat(msg, \", \");\n\t\t}\n\t\tsprintf(tmp, \"Fan%d: %d/m\", i+1, info->fan[i]);\n\t\tstrcat(msg, tmp);\n\t}\n\tstrcat(msg, \"\\t\");\n\tfor(i = 0; i < bm->temp_num; i++) {\n\t\tif(i != 0) {\n\t\t\tstrcat(msg, \", \");\n\t\t}\n\t\tsprintf(tmp, \"Temp%d: %dC\", i+1, info->temp[i]);\n\t\tstrcat(msg, tmp);\n\t}\n\tsprintf(tmp, \", TempMAX: %dC\", info->temp_max);\n\tstrcat(msg, tmp);\n\tapplog(LOG_INFO, \"%s\", msg);\n\tinfo->temp_history_index++;\n\tinfo->temp_sum += bitmain->temp;\n\tapplog(LOG_DEBUG, \"BitMain: temp_index: %d, temp_count: %d, temp_old: %d\",\n\t\tinfo->temp_history_index, info->temp_history_count, info->temp_old);\n\tif (info->temp_history_index == info->temp_history_count) {\n\t\tinfo->temp_history_index = 0;\n\t\tinfo->temp_sum = 0;\n\t}\n}\n\nstatic void bitmain_set_fifo_space(struct cgpu_info * const dev, const int fifo_space)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct bitmain_info * const info = dev->device_data;\n\t\n\tif (unlikely(fifo_space > info->max_fifo_space))\n\t\tinfo->max_fifo_space = fifo_space;\n\t\n\tinfo->fifo_space = fifo_space;\n\tmaster_thr->queue_full = !fifo_space;\n}\n\nstatic void bitmain_parse_results(struct cgpu_info *bitmain, struct bitmain_info *info,\n\t\t\t\t struct thr_info *thr, uint8_t *buf, int *offset)\n{\n\tint i, j, n, m, r, errordiff, spare = BITMAIN_READ_SIZE;\n\tuint32_t checkbit = 0x00000000;\n\tbool found = false;\n\tstruct work *work = NULL;\n\tstruct bitmain_packet_head packethead;\n\tint asicnum = 0;\n\tint mod = 0,tmp = 0;\n\n\tfor (i = 0; i <= spare; i++) {\n\t\tif(buf[i] == 0xa1) {\n\t\t\tstruct bitmain_rxstatus_data rxstatusdata;\n\t\t\tapplog(LOG_DEBUG, \"bitmain_parse_results RxStatus Data\");\n\t\t\tif(*offset < 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(&packethead, buf+i, sizeof(struct bitmain_packet_head));\n\t\t\tpackethead.length = htole16(packethead.length);\n\t\t\tif(packethead.length > 1130) {\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results bitmain_parse_rxstatus datalen=%d error\", packethead.length+4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(*offset < packethead.length + 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bitmain_parse_rxstatus(buf+i, packethead.length+4, &rxstatusdata) != 0) {\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results bitmain_parse_rxstatus error len=%d\", packethead.length+4);\n\t\t\t} else {\n\t\t\t\tmutex_lock(&info->qlock);\n\t\t\t\tinfo->chain_num = rxstatusdata.chain_num;\n\t\t\t\tbitmain_set_fifo_space(bitmain, rxstatusdata.fifo_space);\n\t\t\t\tinfo->hw_version[0] = rxstatusdata.hw_version[0];\n\t\t\t\tinfo->hw_version[1] = rxstatusdata.hw_version[1];\n\t\t\t\tinfo->hw_version[2] = rxstatusdata.hw_version[2];\n\t\t\t\tinfo->hw_version[3] = rxstatusdata.hw_version[3];\n\t\t\t\tinfo->nonce_error = rxstatusdata.nonce_error;\n\t\t\t\terrordiff = info->nonce_error-info->last_nonce_error;\n\t\t\t\t//sprintf(g_miner_version, \"%d.%d.%d.%d\", info->hw_version[0], info->hw_version[1], info->hw_version[2], info->hw_version[3]);\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results v=%d chain=%d fifo=%d hwv1=%d hwv2=%d hwv3=%d hwv4=%d nerr=%d-%d freq=%d chain info:\",\n\t\t\t\t\t\trxstatusdata.version, info->chain_num, info->fifo_space, info->hw_version[0], info->hw_version[1], info->hw_version[2], info->hw_version[3],\n\t\t\t\t\t\tinfo->last_nonce_error, info->nonce_error, info->frequency);\n\t\t\t\tmemcpy(info->chain_asic_exist, rxstatusdata.chain_asic_exist, BITMAIN_MAX_CHAIN_NUM*32);\n\t\t\t\tmemcpy(info->chain_asic_status, rxstatusdata.chain_asic_status, BITMAIN_MAX_CHAIN_NUM*32);\n\t\t\t\tfor(n = 0; n < rxstatusdata.chain_num; n++) {\n\t\t\t\t\tinfo->chain_asic_num[n] = rxstatusdata.chain_asic_num[n];\n\t\t\t\t\tmemset(info->chain_asic_status_t[n], 0, 320);\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\tmod = 0;\n\t\t\t\t\tif(info->chain_asic_num[n] <= 0) {\n\t\t\t\t\t\tasicnum = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod = info->chain_asic_num[n] % 32;\n\t\t\t\t\t\tif(mod == 0) {\n\t\t\t\t\t\t\tasicnum = info->chain_asic_num[n] / 32;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tasicnum = info->chain_asic_num[n] / 32 + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(asicnum > 0) {\n\t\t\t\t\t\t\tfor(m = asicnum-1; m >= 0; m--) {\n\t\t\t\t\t\t\ttmp = mod ? (32-mod): 0;\n\t\t\t\t\t\t\tfor(r = tmp;r < 32;r++){\n\t\t\t\t\t\t\t\tif((r-tmp)%8 == 0 && (r-tmp) !=0){\n\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[n][j] = ' ';\n\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcheckbit = num2bit(r);\n\t\t\t\t\t\t\t\t\t\tif(rxstatusdata.chain_asic_exist[n*8+m] & checkbit) {\n\t\t\t\t\t\t\t\t\t\t\tif(rxstatusdata.chain_asic_status[n*8+m] & checkbit) {\n\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[n][j] = 'o';\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[n][j] = 'x';\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[n][j] = '-';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[n][j] = ' ';\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\tmod = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tapplog(LOG_DEBUG, \"bitmain_parse_results chain(%d) asic_num=%d asic_exist=%08x%08x%08x%08x%08x%08x%08x%08x asic_status=%08x%08x%08x%08x%08x%08x%08x%08x\",\n\t\t\t\t\t\tn, info->chain_asic_num[n],\n\t\t\t\t\t\tinfo->chain_asic_exist[n*8+0], info->chain_asic_exist[n*8+1], info->chain_asic_exist[n*8+2], info->chain_asic_exist[n*8+3], info->chain_asic_exist[n*8+4], info->chain_asic_exist[n*8+5], info->chain_asic_exist[n*8+6], info->chain_asic_exist[n*8+7],\n\t\t\t\t\t\tinfo->chain_asic_status[n*8+0], info->chain_asic_status[n*8+1], info->chain_asic_status[n*8+2], info->chain_asic_status[n*8+3], info->chain_asic_status[n*8+4], info->chain_asic_status[n*8+5], info->chain_asic_status[n*8+6], info->chain_asic_status[n*8+7]);\n\t\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results chain(%d) asic_num=%d asic_status=%s\", n, info->chain_asic_num[n], info->chain_asic_status_t[n]);\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&info->qlock);\n\n\t\t\t\tif(errordiff > 0) {\n\t\t\t\t\tfor(j = 0; j < errordiff; j++) {\n\t\t\t\t\t\tbitmain_inc_nvw(info, thr);\n\t\t\t\t\t}\n\t\t\t\t\tmutex_lock(&info->qlock);\n\t\t\t\t\tinfo->last_nonce_error += errordiff;\n\t\t\t\t\tmutex_unlock(&info->qlock);\n\t\t\t\t}\n\t\t\t\tbitmain_update_temps(bitmain, info, &rxstatusdata);\n\t\t\t}\n\n\t\t\tfound = true;\n\t\t\tspare = packethead.length + 4 + i;\n\t\t\tif(spare > *offset) {\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_rxresults space(%d) > offset(%d)\", spare, *offset);\n\t\t\t\tspare = *offset;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if(buf[i] == 0xa2) {\n\t\t\tstruct bitmain_rxnonce_data rxnoncedata;\n\t\t\tint nonce_num = 0;\n\t\t\tapplog(LOG_DEBUG, \"bitmain_parse_results RxNonce Data\");\n\t\t\tif(*offset < 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(&packethead, buf+i, sizeof(struct bitmain_packet_head));\n\t\t\tpackethead.length = htole16(packethead.length);\n\t\t\tif(packethead.length > 1038) {\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results bitmain_parse_rxnonce datalen=%d error\", packethead.length+4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(*offset < packethead.length + 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bitmain_parse_rxnonce(buf+i, packethead.length+4, &rxnoncedata, &nonce_num) != 0) {\n\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results bitmain_parse_rxnonce error len=%d\", packethead.length+4);\n\t\t\t} else {\n\t\t\t\tconst float nonce_diff = 1 << rxnoncedata.diff;\n\t\t\t\tfor(j = 0; j < nonce_num; j++) {\n\t\t\t\t\tconst work_device_id_t work_id = rxnoncedata.nonces[j].work_id;\n\t\t\t\t\tHASH_FIND(hh, thr->work_list, &work_id, sizeof(work_id), work);\n\t\t\t\t\tif(work) {\n\t\t\t\t\t\tif(BITMAIN_TEST_PRINT_WORK) {\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_parse_results nonce find work(%d-%d)(%08x)\", work->id, rxnoncedata.nonces[j].work_id, rxnoncedata.nonces[j].nonce);\n\n\t\t\t\t\t\t\tchar ob_hex[(32 * 2) + 1];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbin2hex(ob_hex, work->midstate, 32);\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"work %d midstate: %s\", work->id, ob_hex);\n\n\t\t\t\t\t\t\tbin2hex(ob_hex, &work->data[64], 12);\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"work %d data2: %s\", work->id, ob_hex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst uint32_t nonce = rxnoncedata.nonces[j].nonce;\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"BitMain: submit nonce = %08lx\", (unsigned long)nonce);\n\t\t\t\t\t\t\twork->nonce_diff = nonce_diff;\n\t\t\t\t\t\t\tif (submit_nonce(thr, work, nonce)) {\n\t\t\t\t\t\t\t\tmutex_lock(&info->qlock);\n\t\t\t\t\t\t\t\thashes_done2(thr, 0x100000000 * work->nonce_diff, NULL);\n\t\t\t\t\t\t\t\tmutex_unlock(&info->qlock);\n\t\t\t\t\t\t \t} else {\n\t\t\t\t\t\t \t\tapplog(LOG_ERR, \"BitMain: bitmain_decode_nonce error work(%d)\", rxnoncedata.nonces[j].work_id);\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbitmain_inc_nvw(info, thr);\n\t\t\t\t\t\tapplog(LOG_ERR, \"BitMain: Nonce not find work(%d)\", rxnoncedata.nonces[j].work_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmutex_lock(&info->qlock);\n\t\t\t\tbitmain_set_fifo_space(bitmain, rxnoncedata.fifo_space);\n\t\t\t\tmutex_unlock(&info->qlock);\n\t\t\t\tapplog(LOG_DEBUG, \"bitmain_parse_rxnonce fifo space=%d\", info->fifo_space);\n\n#ifndef WIN32\n\t\t\t\tif(nonce_num < info->packet_max_nonce)\n\t\t\t\t\tcgsleep_ms(5);\n#endif\n\t\t\t}\n\n \t\t\tfound = true;\n \t\t\tspare = packethead.length + 4 + i;\n \t\t\tif(spare > *offset) {\n \t\t\t\tapplog(LOG_ERR, \"bitmain_parse_rxnonce space(%d) > offset(%d)\", spare, *offset);\n \t\t\t\tspare = *offset;\n \t\t\t}\n \t\t\tbreak;\n\t\t} else {\n\t\t\tapplog(LOG_ERR, \"bitmain_parse_results data type error=%02x\", buf[i]);\n\t\t}\n\t}\n\tif (!found) {\n\t\tspare = *offset - BITMAIN_READ_SIZE;\n\t\t/* We are buffering and haven't accumulated one more corrupt\n\t\t * work result. */\n\t\tif (spare < (int)BITMAIN_READ_SIZE)\n\t\t\treturn;\n\t\tbitmain_inc_nvw(info, thr);\n\t}\n\n\t*offset -= spare;\n\tmemmove(buf, buf + spare, *offset);\n}\n\nstatic void bitmain_running_reset(struct cgpu_info *bitmain, struct bitmain_info *info)\n{\n\tinfo->reset = false;\n}\n\nstatic void bitmain_prune_old_work(struct cgpu_info * const dev)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct bitmain_info * const info = dev->device_data;\n\t\n\tconst size_t retain_work_items = info->max_fifo_space * 2;\n\tconst size_t queued_work_items = HASH_COUNT(master_thr->work_list);\n\tif (queued_work_items > retain_work_items) {\n\t\tsize_t remove_work_items = queued_work_items - retain_work_items;\n\t\twhile (remove_work_items--) {\n\t\t\t// Deletes the first item insertion-order\n\t\t\tstruct work * const work = master_thr->work_list;\n\t\t\tHASH_DEL(master_thr->work_list, work);\n\t\t\tfree_work(work);\n\t\t}\n\t}\n}\n\nstatic void bitmain_poll(struct thr_info * const thr)\n{\n\tstruct cgpu_info *bitmain = thr->cgpu;\n\tstruct bitmain_info *info = bitmain->device_data;\n\tint offset = info->readbuf_offset, ret = 0;\n\tconst int rsize = BITMAIN_FTDI_READSIZE;\n\tuint8_t * const readbuf = info->readbuf;\n\n\t{\n\t\tunsigned char buf[rsize];\n\n\t\tif (unlikely(info->reset)) {\n\t\t\tbitmain_running_reset(bitmain, info);\n\t\t\t/* Discard anything in the buffer */\n\t\t\toffset = 0;\n\t\t}\n\n\t\t//cgsleep_prepare_r(&ts_start);\n\t\t//applog(LOG_DEBUG, \"======start bitmain_get_results bitmain_read\");\n\t\tret = bitmain_read(bitmain, buf, rsize, BITMAIN_READ_TIMEOUT);\n\t\t//applog(LOG_DEBUG, \"======stop bitmain_get_results bitmain_read=%d\", ret);\n\n\t\tif ((ret < 1) || (ret == 18)) {\n\t\t\t++info->errorcount2;\n#ifdef WIN32\n\t\t\tif(info->errorcount2 > 200) {\n\t\t\t\t//applog(LOG_ERR, \"bitmain_read errorcount ret=%d\", ret);\n\t\t\t\tcgsleep_ms(20);\n\t\t\t\tinfo->errorcount2 = 0;\n\t\t\t}\n#else\n\t\t\tif(info->errorcount2 > 3) {\n\t\t\t\t//applog(LOG_ERR, \"bitmain_read errorcount ret=%d\", ret);\n\t\t\t\tcgsleep_ms(20);\n\t\t\t\tinfo->errorcount2 = 0;\n\t\t\t}\n#endif\n\t\t\tif(ret < 1)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (opt_debug) {\n\t\t\tchar hex[(ret * 2) + 1];\n\t\t\tbin2hex(hex, buf, ret);\n\t\t\tapplog(LOG_DEBUG, \"BitMain: get: %s\", hex);\n\t\t}\n\n\t\tmemcpy(readbuf+offset, buf, ret);\n\t\toffset += ret;\n\n\t\t//applog(LOG_DEBUG, \"+++++++bitmain_get_results offset=%d\", offset);\n\n\t\tif (offset >= (int)BITMAIN_READ_SIZE) {\n\t\t\t//applog(LOG_DEBUG, \"======start bitmain_get_results \");\n\t\t\tbitmain_parse_results(bitmain, info, thr, readbuf, &offset);\n\t\t\t//applog(LOG_DEBUG, \"======stop bitmain_get_results \");\n\t\t}\n\n\t\tif (unlikely(offset + rsize >= BITMAIN_READBUF_SIZE)) {\n\t\t\t/* This should never happen */\n\t\t\tapplog(LOG_DEBUG, \"BitMain readbuf overflow, resetting buffer\");\n\t\t\toffset = 0;\n\t\t}\n\n\t\t/* As the usb read returns after just 1ms, sleep long enough\n\t\t * to leave the interface idle for writes to occur, but do not\n\t\t * sleep if we have been receiving data as more may be coming. */\n\t\t//if (offset == 0) {\n\t\t//\tcgsleep_ms_r(&ts_start, BITMAIN_READ_TIMEOUT);\n\t\t//}\n\t}\n\t\n\tinfo->readbuf_offset = offset;\n\t\n\tbitmain_prune_old_work(bitmain);\n\t\n\ttimer_set_delay_from_now(&thr->tv_poll, bitmain_poll_interval_us);\n}\n\nstatic void bitmain_init(struct cgpu_info *bitmain)\n{\n\tapplog(LOG_INFO, \"BitMain: Opened on %s\", bitmain->device_path);\n}\n\nstatic bool bitmain_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitmain = thr->cgpu;\n\tstruct bitmain_info *info = bitmain->device_data;\n\n\tmutex_init(&info->qlock);\n\n\t// To initialise queue_full\n\tbitmain_set_fifo_space(bitmain, info->fifo_space);\n\t\n\tbitmain_init(bitmain);\n\n\ttimer_set_now(&thr->tv_poll);\n\t\n\treturn true;\n}\n\nstatic int bitmain_initialize(struct cgpu_info *bitmain)\n{\n\tuint8_t data[BITMAIN_READBUF_SIZE];\n\tstruct bitmain_info *info = NULL;\n\tint ret = 0;\n\tuint8_t sendbuf[BITMAIN_SENDBUF_SIZE];\n\tint readlen = 0;\n\tint sendlen = 0;\n\tint trycount = 3;\n\tstruct timespec p;\n\tstruct bitmain_rxstatus_data rxstatusdata;\n\tint i = 0, j = 0, m = 0, r = 0, statusok = 0;\n\tuint32_t checkbit = 0x00000000;\n\tint hwerror_eft = 0;\n\tint beeper_ctrl = 1;\n\tint tempover_ctrl = 1;\n\tint home_mode = 0;\n\tstruct bitmain_packet_head packethead;\n\tint asicnum = 0;\n\tint mod = 0,tmp = 0;\n\n\t/* Send reset, then check for result */\n\tif(!bitmain) {\n\t\tapplog(LOG_WARNING, \"bitmain_initialize cgpu_info is null\");\n\t\treturn -1;\n\t}\n\tinfo = bitmain->device_data;\n\n\t/* clear read buf */\n\tret = bitmain_read(bitmain, data, BITMAIN_READBUF_SIZE,\n\t\t\t\t  BITMAIN_RESET_TIMEOUT);\n\tif(ret > 0) {\n\t\tif (opt_debug) {\n\t\t\tchar hex[(ret * 2) + 1];\n\t\t\tbin2hex(hex, data, ret);\n\t\t\tapplog(LOG_DEBUG, \"BTM%d Clear Read(%d): %s\", bitmain->device_id, ret, hex);\n\t\t}\n\t}\n\n\tsendlen = bitmain_set_rxstatus((struct bitmain_rxstatus_token *)sendbuf, 0, 1, 0, 0);\n\tif(sendlen <= 0) {\n\t\tapplog(LOG_ERR, \"bitmain_initialize bitmain_set_rxstatus error(%d)\", sendlen);\n\t\treturn -1;\n\t}\n\n\tret = bitmain_send_data(sendbuf, sendlen, bitmain);\n\tif (unlikely(ret == BTM_SEND_ERROR)) {\n\t\tapplog(LOG_ERR, \"bitmain_initialize bitmain_send_data error\");\n\t\treturn -1;\n\t}\n\twhile(trycount >= 0) {\n\t\tret = bitmain_read(bitmain, data+readlen, BITMAIN_READBUF_SIZE, BITMAIN_RESET_TIMEOUT);\n\t\tif(ret > 0) {\n\t\t\treadlen += ret;\n\t\t\tif(readlen > BITMAIN_READ_SIZE) {\n\t\t\t\tfor(i = 0; i < readlen; i++) {\n\t\t\t\t\tif(data[i] == 0xa1) {\n\t\t\t\t\t\tif (opt_debug) {\n\t\t\t\t\t\t\tchar hex[(readlen * 2) + 1];\n\t\t\t\t\t\t\tbin2hex(hex, data, readlen);\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"%s%d initset: get: %s\", bitmain->drv->name, bitmain->device_id, hex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(&packethead, data+i, sizeof(struct bitmain_packet_head));\n\t\t\t\t\t\tpackethead.length = htole16(packethead.length);\n\n\t\t\t\t\t\tif(packethead.length > 1130) {\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_initialize rxstatus datalen=%d error\", packethead.length+4);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(readlen-i < packethead.length+4) {\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_initialize rxstatus datalen=%d<%d low\", readlen-i, packethead.length+4);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bitmain_parse_rxstatus(data+i, packethead.length+4, &rxstatusdata) != 0) {\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_initialize bitmain_parse_rxstatus error\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->chain_num = rxstatusdata.chain_num;\n\t\t\t\t\t\t// NOTE: This is before thr_info is allocated, so we cannot use bitmain_set_fifo_space (bitmain_prepare will re-set it for us)\n\t\t\t\t\t\tinfo->fifo_space = rxstatusdata.fifo_space;\n\t\t\t\t\t\tinfo->hw_version[0] = rxstatusdata.hw_version[0];\n\t\t\t\t\t\tinfo->hw_version[1] = rxstatusdata.hw_version[1];\n\t\t\t\t\t\tinfo->hw_version[2] = rxstatusdata.hw_version[2];\n\t\t\t\t\t\tinfo->hw_version[3] = rxstatusdata.hw_version[3];\n\t\t\t\t\t\tinfo->nonce_error = 0;\n\t\t\t\t\t\tinfo->last_nonce_error = 0;\n\t\t\t\t\t\tsprintf(info->g_miner_version, \"%d.%d.%d.%d\", info->hw_version[0], info->hw_version[1], info->hw_version[2], info->hw_version[3]);\n\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_initialize rxstatus v(%d) chain(%d) fifo(%d) hwv1(%d) hwv2(%d) hwv3(%d) hwv4(%d) nerr(%d) freq=%d\",\n\t\t\t\t\t\t\t\trxstatusdata.version, info->chain_num, info->fifo_space, info->hw_version[0], info->hw_version[1], info->hw_version[2], info->hw_version[3],\n\t\t\t\t\t\t\t\trxstatusdata.nonce_error, info->frequency);\n\n\t\t\t\t\t\tmemcpy(info->chain_asic_exist, rxstatusdata.chain_asic_exist, BITMAIN_MAX_CHAIN_NUM*32);\n\t\t\t\t\t\tmemcpy(info->chain_asic_status, rxstatusdata.chain_asic_status, BITMAIN_MAX_CHAIN_NUM*32);\n\t\t\t\t\t\tfor(i = 0; i < rxstatusdata.chain_num; i++) {\n\t\t\t\t\t\t\tinfo->chain_asic_num[i] = rxstatusdata.chain_asic_num[i];\n\t\t\t\t\t\t\tmemset(info->chain_asic_status_t[i], 0, 320);\n\t\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\t\tmod = 0;\n\n\t\t\t\t\t\t\tif(info->chain_asic_num[i] <= 0) {\n\t\t\t\t\t\t\t\tasicnum = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmod = info->chain_asic_num[i] % 32;\n\t\t\t\t\t\t\t\tif(mod == 0) {\n\t\t\t\t\t\t\t\t\tasicnum = info->chain_asic_num[i] / 32;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tasicnum = info->chain_asic_num[i] / 32 + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(asicnum > 0) {\n\t\t\t\t\t\t\t\t\tfor(m = asicnum-1; m >= 0; m--) {\n\t\t\t\t\t\t\t\t\ttmp = mod ? (32-mod):0;\n\t\t\t\t\t\t\t\t\tfor(r = tmp;r < 32;r++){\n\t\t\t\t\t\t\t\t\t\tif((r-tmp)%8 == 0 && (r-tmp) !=0){\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[i][j] = ' ';\n\t\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcheckbit = num2bit(r);\n\t\t\t\t\t\t\t\t\t\t\t\tif(rxstatusdata.chain_asic_exist[i*8+m] & checkbit) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(rxstatusdata.chain_asic_status[i*8+m] & checkbit) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[i][j] = 'o';\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[i][j] = 'x';\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[i][j] = '-';\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tinfo->chain_asic_status_t[i][j] = ' ';\n\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\tmod = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"bitmain_initialize chain(%d) asic_num=%d asic_exist=%08x%08x%08x%08x%08x%08x%08x%08x asic_status=%08x%08x%08x%08x%08x%08x%08x%08x\",\n\t\t\t\t\t\t\t\t\ti, info->chain_asic_num[i],\n\t\t\t\t\t\t\t\t\tinfo->chain_asic_exist[i*8+0], info->chain_asic_exist[i*8+1], info->chain_asic_exist[i*8+2], info->chain_asic_exist[i*8+3], info->chain_asic_exist[i*8+4], info->chain_asic_exist[i*8+5], info->chain_asic_exist[i*8+6], info->chain_asic_exist[i*8+7],\n\t\t\t\t\t\t\t\t\tinfo->chain_asic_status[i*8+0], info->chain_asic_status[i*8+1], info->chain_asic_status[i*8+2], info->chain_asic_status[i*8+3], info->chain_asic_status[i*8+4], info->chain_asic_status[i*8+5], info->chain_asic_status[i*8+6], info->chain_asic_status[i*8+7]);\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"bitmain_initialize chain(%d) asic_num=%d asic_status=%s\", i, info->chain_asic_num[i], info->chain_asic_status_t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbitmain_update_temps(bitmain, info, &rxstatusdata);\n\t\t\t\t\t\tstatusok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(statusok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrycount--;\n\t\tp.tv_sec = 0;\n\t\tp.tv_nsec = BITMAIN_RESET_PITCH;\n\t\tnanosleep(&p, NULL);\n\t}\n\n\tp.tv_sec = 0;\n\tp.tv_nsec = BITMAIN_RESET_PITCH;\n\tnanosleep(&p, NULL);\n\n\tif(statusok) {\n\t\tapplog(LOG_ERR, \"bitmain_initialize start send txconfig\");\n\t\tif(opt_bitmain_hwerror)\n\t\t\thwerror_eft = 1;\n\t\telse\n\t\t\thwerror_eft = 0;\n\t\tif(opt_bitmain_nobeeper)\n\t\t\tbeeper_ctrl = 0;\n\t\telse\n\t\t\tbeeper_ctrl = 1;\n\t\tif(opt_bitmain_notempoverctrl)\n\t\t\ttempover_ctrl = 0;\n\t\telse\n\t\t\ttempover_ctrl = 1;\n\t\tif(opt_bitmain_homemode)\n\t\t\thome_mode= 1;\n\t\telse\n\t\t\thome_mode= 0;\n\t\tsendlen = bitmain_set_txconfig((struct bitmain_txconfig_token *)sendbuf, 1, 1, 1, 1, 1, 0, 1, hwerror_eft, beeper_ctrl, tempover_ctrl,home_mode,\n\t\t\t\tinfo->chain_num, info->asic_num, BITMAIN_DEFAULT_FAN_MAX_PWM, info->timeout,\n\t\t\t\tinfo->frequency, info->voltage, 0, 0, 0x04, info->reg_data);\n\t\tif(sendlen <= 0) {\n\t\t\tapplog(LOG_ERR, \"bitmain_initialize bitmain_set_txconfig error(%d)\", sendlen);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = bitmain_send_data(sendbuf, sendlen, bitmain);\n\t\tif (unlikely(ret == BTM_SEND_ERROR)) {\n\t\t\tapplog(LOG_ERR, \"bitmain_initialize bitmain_send_data error\");\n\t\t\treturn -1;\n\t\t}\n\t\tapplog(LOG_WARNING, \"BMM%d: InitSet succeeded\", bitmain->device_id);\n\t} else {\n\t\tapplog(LOG_WARNING, \"BMS%d: InitSet error\", bitmain->device_id);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic bool bitmain_detect_one(const char * devpath)\n{\n\tstruct bitmain_info *info;\n\tstruct cgpu_info *bitmain;\n\tint ret;\n\n\tbitmain = btm_alloc_cgpu(&bitmain_drv, BITMAIN_MINER_THREADS);\n\tinfo = bitmain->device_data;\n\n\tdrv_set_defaults(&bitmain_drv, bitmain_set_device_funcs_init, info, devpath, NULL, 1);\n\t\n\tif (!info->packet_max_work)\n\t\treturn_via_applog(shin, , LOG_ERR, \"%s: Device not configured (did you forget --set bitmain:model=S5 ?)\", bitmain_drv.dname);\n\t\n\tif (!(upk_u32be(info->reg_data, 0))) {\n\t\tswitch (info->chip_type) {\n\t\t\tcase BMC_BM1382:\n\t\t\tcase BMC_BM1384:\n\t\t\t\tif (bm1382_freq_to_reg_data(info->reg_data, info->frequency))\n\t\t\t\t\tbreak;\n\t\t\t\t// fall thru if it failed\n\t\t\tdefault:\n\t\t\t\treturn_via_applog(shin, , LOG_ERR, \"%s: Device not configured (did you forget --set bitmain:reg_data=x???? ?)\", bitmain_drv.dname);\n\t\t}\n\t}\n\n\tif (!btm_init(bitmain, devpath))\n\t\tgoto shin;\n\tapplog(LOG_ERR, \"bitmain_detect_one btm init ok\");\n\n\tinfo->fan_pwm = BITMAIN_DEFAULT_FAN_MIN_PWM;\n\tinfo->temp_max = 0;\n\t/* This is for check the temp/fan every 3~4s */\n\tinfo->temp_history_count = (4 / (float)((float)info->timeout * ((float)1.67/0x32))) + 1;\n\tif (info->temp_history_count <= 0)\n\t\tinfo->temp_history_count = 1;\n\n\tinfo->temp_history_index = 0;\n\tinfo->temp_sum = 0;\n\tinfo->temp_old = 0;\n\n\tif (!add_cgpu(bitmain))\n\t\tgoto unshin;\n\n\tret = bitmain_initialize(bitmain);\n\tapplog(LOG_ERR, \"bitmain_detect_one stop bitmain_initialize %d\", ret);\n\tif (ret)\n\t\tgoto unshin;\n\n\tinfo->errorcount = 0;\n\n\tapplog(LOG_ERR, \"BitMain Detected: %s \"\n\t       \"(chain_num=%d asic_num=%d timeout=%d freq=%d-%s volt=%02x%02x-%s)\",\n\t       bitmain->device_path, info->chain_num, info->asic_num, info->timeout,\n\t       info->frequency, info->frequency_t, info->voltage[0], info->voltage[1], info->voltage_t);\n\n\treturn true;\n\nunshin:\n\tbtm_uninit(bitmain);\n\nshin:\n\tfree(bitmain->device_data);\n\tbitmain->device_data = NULL;\n\n\tfree(bitmain);\n\n\treturn false;\n}\n\nstatic int bitmain_detect_auto(void)\n{\n\tconst char * const auto_bitmain_dev = \"/dev/bitmain-asic\";\n\tapplog(LOG_DEBUG, \"BTM detect dev: %s\", auto_bitmain_dev);\n\treturn bitmain_detect_one(auto_bitmain_dev) ? 1 : 0;\n}\n\nstatic void bitmain_detect()\n{\n\tgeneric_detect(&bitmain_drv, bitmain_detect_one, bitmain_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\nstatic void do_bitmain_close(struct thr_info *thr)\n{\n\tstruct cgpu_info *bitmain = thr->cgpu;\n\tstruct bitmain_info *info = bitmain->device_data;\n\n\tbitmain_running_reset(bitmain, info);\n\n\tinfo->no_matching_work = 0;\n}\n\nstatic uint8_t diff_to_bitmain(float diff)\n{\n\tuint8_t res = 0;\n\tif (diff > UINT64_MAX)\n\t\tdiff = UINT64_MAX;\n\tfor (uint64_t tmp = diff; tmp >>= 1; ) {\n\t\tif (++res == UINT8_MAX)\n\t\t\tbreak;\n\t}\n\treturn res;\n}\n\nstatic bool bitmain_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct bitmain_info * const info = dev->device_data;\n\tconst struct pool * const pool = work->pool;\n\tconst struct mining_goal_info * const goal = pool->goal;\n\t\n\tapplog(LOG_DEBUG, \"%s: %s with fifo_space=%d (max=%d) work_restart=%d\", dev->dev_repr, __func__, info->fifo_space, info->max_fifo_space, (int)info->work_restart);\n\t\n\tif (info->work_restart) {\n\t\tinfo->work_restart = false;\n\t\tinfo->ready_to_queue = 0;\n\t\tbitmain_set_fifo_space(dev, info->max_fifo_space);\n\t\tinfo->queuebuf[4] = 1;  // clear work queues\n\t}\n\t\n\tif (!info->fifo_space) {\n\t\tthr->queue_full = true;\n\t\treturn false;\n\t}\n\t\n\tuint8_t * const wbuf = &info->queuebuf[BITMAIN_TASK_HEADER_SIZE + (BITMAIN_WORK_SIZE * info->ready_to_queue)];\n\tconst int work_nonce_bmdiff = diff_to_bitmain(work->nonce_diff);\n\tif (work_nonce_bmdiff < info->diff)\n\t\tinfo->diff = work_nonce_bmdiff;\n\tif (goal->current_diff < info->lowest_goal_diff)\n\t\tinfo->lowest_goal_diff = goal->current_diff;\n\t\n\twork->device_id = info->next_work_id++;\n\tpk_u32le(wbuf, 0, work->device_id);\n\tmemcpy(&wbuf[4], work->midstate, 0x20);\n\tmemcpy(&wbuf[0x24], &work->data[0x40], 0xc);\n\t\n\tHASH_ADD(hh, master_thr->work_list, device_id, sizeof(work->device_id), work);\n\t++info->ready_to_queue;\n\t\n\tif (!(info->ready_to_queue >= info->packet_max_work || info->fifo_space == info->ready_to_queue || info->fifo_space == info->max_fifo_space)) {\n\t\tapplog(LOG_DEBUG, \"%s: %s now has ready_to_queue=%d; deferring send\", dev->dev_repr, __func__, info->ready_to_queue);\n\t\treturn true;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%s: %s now has ready_to_queue=%d; sending to device\", dev->dev_repr, __func__, info->ready_to_queue);\n\t\n\tuint8_t * const buf = info->queuebuf;\n\tconst size_t buflen = BITMAIN_TASK_HEADER_SIZE + (info->ready_to_queue * BITMAIN_WORK_SIZE) + BITMAIN_TASK_FOOTER_SIZE;\n\t\n\tbuf[0] = BITMAIN_TOKEN_TYPE_TXTASK;\n\tbuf[1] = 0;  // packet version\n\tpk_u16le(buf, 2, buflen - 4);  // length of data after this field (including CRC)\n\t// buf[4] is set to 1 to clear work queues, when the first work item is added, and reset to 0 after we send\n\tbuf[5] = info->diff;\n\tpk_u16le(buf, 6, diff_to_bitmain(info->lowest_goal_diff));\n\t\n\tpk_u16le(buf, buflen - 2, CRC16(buf, buflen - 2));\n\t\n\tint sendret = bitmain_send_data(buf, buflen, proc);\n\tif (unlikely(sendret == BTM_SEND_ERROR)) {\n\t\tapplog(LOG_ERR, \"%s: Comms error(buffer)\", dev->dev_repr);\n\t\t//dev_error(bitmain, REASON_DEV_COMMS_ERROR);\n\t\tinfo->reset = true;\n\t\tinfo->errorcount++;\n\t\tif (info->errorcount > 1000) {\n\t\t\tinfo->errorcount = 0;\n\t\t\tapplog(LOG_ERR, \"%s: Device disappeared, shutting down thread\", dev->dev_repr);\n\t\t\tdev->shutdown = true;\n\t\t}\n\t\t// The work is in the queuebuf already, so we're okay-ish for that...\n\t\treturn true;\n\t} else {\n\t\tapplog(LOG_DEBUG, \"bitmain_send_data send ret=%d\", sendret);\n\t\tinfo->errorcount = 0;\n\t}\n\tbuf[4] = 0;\n\tinfo->fifo_space -= info->ready_to_queue;\n\tinfo->ready_to_queue = 0;\n\t\n\tstruct timeval tv_now;\n\ttimer_set_now(&tv_now);\n\tif (timer_passed(&master_thr->tv_poll, &tv_now)) {\n\t\tbitmain_poll(master_thr);\n\t}\n\t\n\treturn true;\n}\n\nstatic void bitmain_queue_flush(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitmain_info * const info = dev->device_data;\n\t\n\t// Can't use thr->work_restart as that merely triggers this function in minerloop_queue\n\tinfo->work_restart = true;\n\tthr->queue_full = false;\n}\n\nstatic struct api_data *bitmain_api_stats(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\tstruct bitmain_info *info = cgpu->device_data;\n\tdouble hwp = (cgpu->hw_errors + cgpu->diff1) ?\n\t\t\t(double)(cgpu->hw_errors) / (double)(cgpu->hw_errors + cgpu->diff1) : 0;\n\n\troot = api_add_int(root, \"miner_count\", &(info->chain_num), false);\n\troot = api_add_int(root, \"asic_count\", &(info->asic_num), false);\n\troot = api_add_int(root, \"timeout\", &(info->timeout), false);\n\troot = api_add_string(root, \"frequency\", info->frequency_t, false);\n\troot = api_add_string(root, \"voltage\", info->voltage_t, false);\n\troot = api_add_int(root, \"hwv1\", &(info->hw_version[0]), false);\n\troot = api_add_int(root, \"hwv2\", &(info->hw_version[1]), false);\n\troot = api_add_int(root, \"hwv3\", &(info->hw_version[2]), false);\n\troot = api_add_int(root, \"hwv4\", &(info->hw_version[3]), false);\n\n\troot = api_add_int(root, \"fan_num\", &(info->fan_num), false);\n\troot = api_add_int(root, \"fan1\", &(info->fan[0]), false);\n\troot = api_add_int(root, \"fan2\", &(info->fan[1]), false);\n\troot = api_add_int(root, \"fan3\", &(info->fan[2]), false);\n\troot = api_add_int(root, \"fan4\", &(info->fan[3]), false);\n\troot = api_add_int(root, \"fan5\", &(info->fan[4]), false);\n\troot = api_add_int(root, \"fan6\", &(info->fan[5]), false);\n\troot = api_add_int(root, \"fan7\", &(info->fan[6]), false);\n\troot = api_add_int(root, \"fan8\", &(info->fan[7]), false);\n\troot = api_add_int(root, \"fan9\", &(info->fan[8]), false);\n\troot = api_add_int(root, \"fan10\", &(info->fan[9]), false);\n\troot = api_add_int(root, \"fan11\", &(info->fan[10]), false);\n\troot = api_add_int(root, \"fan12\", &(info->fan[11]), false);\n\troot = api_add_int(root, \"fan13\", &(info->fan[12]), false);\n\troot = api_add_int(root, \"fan14\", &(info->fan[13]), false);\n\troot = api_add_int(root, \"fan15\", &(info->fan[14]), false);\n\troot = api_add_int(root, \"fan16\", &(info->fan[15]), false);\n\n\troot = api_add_int(root, \"temp_num\", &(info->temp_num), false);\n\troot = api_add_int(root, \"temp1\", &(info->temp[0]), false);\n\troot = api_add_int(root, \"temp2\", &(info->temp[1]), false);\n\troot = api_add_int(root, \"temp3\", &(info->temp[2]), false);\n\troot = api_add_int(root, \"temp4\", &(info->temp[3]), false);\n\troot = api_add_int(root, \"temp5\", &(info->temp[4]), false);\n\troot = api_add_int(root, \"temp6\", &(info->temp[5]), false);\n\troot = api_add_int(root, \"temp7\", &(info->temp[6]), false);\n\troot = api_add_int(root, \"temp8\", &(info->temp[7]), false);\n\troot = api_add_int(root, \"temp9\", &(info->temp[8]), false);\n\troot = api_add_int(root, \"temp10\", &(info->temp[9]), false);\n\troot = api_add_int(root, \"temp11\", &(info->temp[10]), false);\n\troot = api_add_int(root, \"temp12\", &(info->temp[11]), false);\n\troot = api_add_int(root, \"temp13\", &(info->temp[12]), false);\n\troot = api_add_int(root, \"temp14\", &(info->temp[13]), false);\n\troot = api_add_int(root, \"temp15\", &(info->temp[14]), false);\n\troot = api_add_int(root, \"temp16\", &(info->temp[15]), false);\n\troot = api_add_int(root, \"temp_avg\", &(info->temp_avg), false);\n\troot = api_add_int(root, \"temp_max\", &(info->temp_max), false);\n\troot = api_add_percent(root, \"Device Hardware%\", &hwp, true);\n\troot = api_add_int(root, \"no_matching_work\", &(info->no_matching_work), false);\n\t/*\n\tfor (int i = 0; i < info->chain_num; ++i) {\n\t\tchar mcw[24];\n\n\t\tsprintf(mcw, \"match_work_count%d\", i + 1);\n\t\troot = api_add_int(root, mcw, &(info->matching_work[i]), false);\n\t}*/\n\n\troot = api_add_int(root, \"chain_acn1\", &(info->chain_asic_num[0]), false);\n\troot = api_add_int(root, \"chain_acn2\", &(info->chain_asic_num[1]), false);\n\troot = api_add_int(root, \"chain_acn3\", &(info->chain_asic_num[2]), false);\n\troot = api_add_int(root, \"chain_acn4\", &(info->chain_asic_num[3]), false);\n\troot = api_add_int(root, \"chain_acn5\", &(info->chain_asic_num[4]), false);\n\troot = api_add_int(root, \"chain_acn6\", &(info->chain_asic_num[5]), false);\n\troot = api_add_int(root, \"chain_acn7\", &(info->chain_asic_num[6]), false);\n\troot = api_add_int(root, \"chain_acn8\", &(info->chain_asic_num[7]), false);\n\troot = api_add_int(root, \"chain_acn9\", &(info->chain_asic_num[8]), false);\n\troot = api_add_int(root, \"chain_acn10\", &(info->chain_asic_num[9]), false);\n\troot = api_add_int(root, \"chain_acn11\", &(info->chain_asic_num[10]), false);\n\troot = api_add_int(root, \"chain_acn12\", &(info->chain_asic_num[11]), false);\n\troot = api_add_int(root, \"chain_acn13\", &(info->chain_asic_num[12]), false);\n\troot = api_add_int(root, \"chain_acn14\", &(info->chain_asic_num[13]), false);\n\troot = api_add_int(root, \"chain_acn15\", &(info->chain_asic_num[14]), false);\n\troot = api_add_int(root, \"chain_acn16\", &(info->chain_asic_num[15]), false);\n\n\t//applog(LOG_ERR, \"chain asic status:%s\", info->chain_asic_status_t[0]);\n\troot = api_add_string(root, \"chain_acs1\", info->chain_asic_status_t[0], false);\n\troot = api_add_string(root, \"chain_acs2\", info->chain_asic_status_t[1], false);\n\troot = api_add_string(root, \"chain_acs3\", info->chain_asic_status_t[2], false);\n\troot = api_add_string(root, \"chain_acs4\", info->chain_asic_status_t[3], false);\n\troot = api_add_string(root, \"chain_acs5\", info->chain_asic_status_t[4], false);\n\troot = api_add_string(root, \"chain_acs6\", info->chain_asic_status_t[5], false);\n\troot = api_add_string(root, \"chain_acs7\", info->chain_asic_status_t[6], false);\n\troot = api_add_string(root, \"chain_acs8\", info->chain_asic_status_t[7], false);\n\troot = api_add_string(root, \"chain_acs9\", info->chain_asic_status_t[8], false);\n\troot = api_add_string(root, \"chain_acs10\", info->chain_asic_status_t[9], false);\n\troot = api_add_string(root, \"chain_acs11\", info->chain_asic_status_t[10], false);\n\troot = api_add_string(root, \"chain_acs12\", info->chain_asic_status_t[11], false);\n\troot = api_add_string(root, \"chain_acs13\", info->chain_asic_status_t[12], false);\n\troot = api_add_string(root, \"chain_acs14\", info->chain_asic_status_t[13], false);\n\troot = api_add_string(root, \"chain_acs15\", info->chain_asic_status_t[14], false);\n\troot = api_add_string(root, \"chain_acs16\", info->chain_asic_status_t[15], false);\n\n\t//root = api_add_int(root, \"chain_acs1\", &(info->chain_asic_status[0]), false);\n\t//root = api_add_int(root, \"chain_acs2\", &(info->chain_asic_status[1]), false);\n\t//root = api_add_int(root, \"chain_acs3\", &(info->chain_asic_status[2]), false);\n\t//root = api_add_int(root, \"chain_acs4\", &(info->chain_asic_status[3]), false);\n\n\treturn root;\n}\n\nstatic void bitmain_shutdown(struct thr_info *thr)\n{\n\tdo_bitmain_close(thr);\n}\n\nstatic\nconst char *bitmain_set_layout(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tchar *endptr, *next_field;\n\tconst long int n_chains = strtol(newvalue, &endptr, 0);\n\tif (endptr == newvalue || n_chains < 1)\n\t\treturn \"Missing chain count\";\n\tlong int n_asics = 0;\n\tif (endptr[0] == ':' || endptr[1] == ',')\n\t{\n\t\tnext_field = &endptr[1];\n\t\tn_asics = strtol(next_field, &endptr, 0);\n\t}\n\tif (n_asics < 1)\n\t\treturn \"Missing ASIC count\";\n\tif (n_asics > BITMAIN_DEFAULT_ASIC_NUM)\n\t\treturn \"ASIC count too high\";\n\tinfo->chain_num = n_chains;\n\tinfo->asic_num = n_asics;\n\treturn NULL;\n}\n\nstatic\nconst char *bitmain_set_timeout(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tconst int timeout = atoi(newvalue);\n\tif (timeout < 0 || timeout > 0xff)\n\t\treturn \"Invalid timeout setting\";\n\tinfo->timeout = timeout;\n\treturn NULL;\n}\n\nstatic\nconst char *bitmain_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tconst int freq = atoi(newvalue);\n\tif (freq < BITMAIN_MIN_FREQUENCY || freq > BITMAIN_MAX_FREQUENCY)\n\t\treturn \"Invalid clock frequency\";\n\tinfo->frequency = freq;\n\tsprintf(info->frequency_t, \"%d\", freq);\n\treturn NULL;\n}\n\nstatic\nconst char *bitmain_set_reg_data(struct cgpu_info * const proc, const char * const optname, const char *newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tuint8_t reg_data[4] = {0};\n\t\n\tif (newvalue[0] == 'x')\n\t\t++newvalue;\n\t\n\tsize_t nvlen = strlen(newvalue);\n\tif (nvlen > (sizeof(reg_data) * 2) || !nvlen || nvlen % 2)\n\t\treturn \"reg_data must be a hex string of 2-8 digits (1-4 bytes)\";\n\t\n\tif (!hex2bin(reg_data, newvalue, nvlen / 2))\n\t\treturn \"Invalid reg data hex\";\n\t\n\tmemcpy(info->reg_data, reg_data, sizeof(reg_data));\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *bitmain_set_voltage(struct cgpu_info * const proc, const char * const optname, const char *newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tuint8_t voltage_data[2] = {0};\n\t\n\tif (newvalue[0] == 'x')\n\t\t++newvalue;\n\telse\nvoltage_usage:\n\t\treturn \"voltage must be 'x' followed by a hex string of 1-4 digits (1-2 bytes)\";\n\t\n\tsize_t nvlen = strlen(newvalue);\n\tif (nvlen > (sizeof(voltage_data) * 2) || !nvlen || nvlen % 2)\n\t\tgoto voltage_usage;\n\t\n\tif (!hex2bin(voltage_data, newvalue, nvlen / 2))\n\t\treturn \"Invalid voltage data hex\";\n\t\n\tmemcpy(info->voltage, voltage_data, sizeof(voltage_data));\n\tbin2hex(info->voltage_t, voltage_data, 2);\n\tinfo->voltage_t[5] = 0;\n\tinfo->voltage_t[4] = info->voltage_t[3];\n\tinfo->voltage_t[3] = info->voltage_t[2];\n\tinfo->voltage_t[2] = info->voltage_t[1];\n\tinfo->voltage_t[1] = '.';\n\t\n\treturn NULL;\n}\n\nstatic bool bitmain_set_packet_max_work(struct cgpu_info * const dev, const unsigned i)\n{\n\tstruct bitmain_info * const info = dev->device_data;\n\tuint8_t * const new_queuebuf = realloc(info->queuebuf, BITMAIN_TASK_HEADER_SIZE + (i * BITMAIN_WORK_SIZE) + BITMAIN_TASK_FOOTER_SIZE);\n\tif (!new_queuebuf)\n\t\treturn false;\n\tinfo->packet_max_work = i;\n\tinfo->queuebuf = new_queuebuf;\n\treturn true;\n}\n\nstatic const char *bitmain_set_packet_max_work_opt(struct cgpu_info * const proc, const char * const optname, const char *newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tconst int i = atoi(newvalue);\n\tif (i < 1)\n\t\treturn \"Invalid setting\";\n\tif (!bitmain_set_packet_max_work(proc->device, i))\n\t\treturn \"realloc failure\";\n\treturn NULL;\n}\n\nstatic\nconst char *bitmain_set_packet_max_nonce_opt(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct bitmain_info *info = proc->device_data;\n\tconst int i = atoi(newvalue);\n\tif (i < 0 || i > BITMAIN_MAX_PACKET_MAX_NONCE)\n\t\treturn \"Invalid setting\";\n\tinfo->packet_max_nonce = i;\n\treturn NULL;\n}\n\nstatic const char *bitmain_set_model(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct bitmain_info * const info = dev->device_data;\n\t\n\tif (toupper(newvalue[0]) != 'S') {\nunknown_model:\n\t\treturn \"Unknown model\";\n\t}\n\tchar *endptr;\n\tlong Sn = strtol(&newvalue[1], &endptr, 10);\n\tif (Sn < 1 || Sn > 5)\n\t\tgoto unknown_model;\n\tif (Sn == 5 && endptr[0] == '+')\n\t\t++endptr;\n\tif (endptr[0] && !isspace(endptr[0]))\n\t\tgoto unknown_model;\n\t\n\tinfo->chip_type = BMC_UNKNOWN;\n\tswitch (Sn) {\n\t\tcase 1:\n\t\t\tinfo->chip_type = BMC_BM1380;\n\t\t\tbitmain_set_packet_max_work(dev, 8);\n\t\t\tinfo->packet_max_nonce = 8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinfo->chip_type = BMC_BM1380;\n\t\t\tbitmain_set_packet_max_work(dev, 0x40);\n\t\t\tinfo->packet_max_nonce = 0x80;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tinfo->chip_type = BMC_BM1382;\n\t\t\tbitmain_set_packet_max_work(dev, 8);\n\t\t\tinfo->packet_max_nonce = 0x80;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tinfo->chip_type = BMC_BM1382;\n\t\t\tbitmain_set_packet_max_work(dev, 0x40);\n\t\t\tinfo->packet_max_nonce = 0x80;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinfo->chip_type = BMC_BM1384;\n\t\t\tbitmain_set_packet_max_work(dev, 0x40);\n\t\t\tinfo->packet_max_nonce = 0x80;\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition bitmain_set_device_funcs_init[] = {\n\t{\"model\", bitmain_set_model, \"model of unit (S1-S5)\"},\n\t{\"layout\", bitmain_set_layout, \"number of chains ':' number of ASICs per chain (eg: 32:8)\"},\n\t{\"timeout\", bitmain_set_timeout, \"timeout\"},\n\t{\"clock\", bitmain_set_clock, \"clock frequency\"},\n\t{\"reg_data\", bitmain_set_reg_data, \"reg_data (eg: x0d82)\"},\n\t{\"voltage\", bitmain_set_voltage, \"voltage (must be specified as 'x' and hex data; eg: x0725)\"},\n\t{\"packet_max_work\", bitmain_set_packet_max_work_opt, NULL},\n\t{\"packet_max_nonce\", bitmain_set_packet_max_nonce_opt, NULL},\n\t{NULL},\n};\n\nstruct device_drv bitmain_drv = {\n\t.dname = \"bitmain\",\n\t.name = \"BTM\",\n\t.drv_detect = bitmain_detect,\n\t.thread_prepare = bitmain_prepare,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = bitmain_queue_append,\n\t.queue_flush = bitmain_queue_flush,\n\t.poll = bitmain_poll,\n\t\n\t.get_api_stats = bitmain_api_stats,\n\t.reinit_device = bitmain_init,\n\t.thread_shutdown = bitmain_shutdown,\n};\n"
        },
        {
          "name": "driver-bitmain.h",
          "type": "blob",
          "size": 5.982421875,
          "content": "/*\n * Copyright 2013 BitMain project\n * Copyright 2013 BitMain <xlc1985@126.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BITMAIN_H\n#define BITMAIN_H\n\n#ifdef USE_BITMAIN\n\n#include <curl/curl.h>\n\n#include \"util.h\"\n\n//#define BITMAIN_TYPE_S1\n//#define BITMAIN_TYPE_S2\n//#define BITMAIN_TYPE_S3\n#define BITMAIN_TYPE_S4\n\n#define BITMAIN_MINER_THREADS 1\n\n#define BITMAIN_RESET_PITCH\t(300*1000*1000)\n\n#define BITMAIN_TOKEN_TYPE_TXCONFIG 0x51\n#define BITMAIN_TOKEN_TYPE_TXTASK   0x52\n#define BITMAIN_TOKEN_TYPE_RXSTATUS 0x53\n\n#define BITMAIN_DATA_TYPE_RXSTATUS  0xa1\n#define BITMAIN_DATA_TYPE_RXNONCE   0xa2\n\n#define BITMAIN_FAN_FACTOR 60\n#define BITMAIN_PWM_MAX 0xA0\n#define BITMAIN_DEFAULT_FAN_MIN 20\n#define BITMAIN_DEFAULT_FAN_MAX 100\n#define BITMAIN_DEFAULT_FAN_MAX_PWM 0xA0 /* 100% */\n#define BITMAIN_DEFAULT_FAN_MIN_PWM 0x20 /*  20% */\n\n#define BITMAIN_DEFAULT_TIMEOUT 0x2D\n#define BITMAIN_MIN_FREQUENCY 10\n#define BITMAIN_MAX_FREQUENCY 1000000\n#define BITMAIN_TIMEOUT_FACTOR 12690\n#define BITMAIN_DEFAULT_FREQUENCY 282\n#define BITMAIN_DEFAULT_VOLTAGE_T \"0725\"\n#define BITMAIN_DEFAULT_VOLTAGE0 0x07\n#define BITMAIN_DEFAULT_VOLTAGE1 0x25\n#define BITMAIN_DEFAULT_CHAIN_NUM 8\n#define BITMAIN_DEFAULT_ASIC_NUM 32\n#define BITMAIN_DEFAULT_REG_DATA 0\n\n#define BITMAIN_AUTO_CYCLE 1024\n\n#define BITMAIN_FTDI_READSIZE 2048\n#define BITMAIN_USB_PACKETSIZE 512\n#define BITMAIN_SENDBUF_SIZE 8192\n#define BITMAIN_READBUF_SIZE 8192\n#define BITMAIN_RESET_TIMEOUT 100\n#define BITMAIN_READ_TIMEOUT 18 /* Enough to only half fill the buffer */\n#define BITMAIN_LATENCY 1\n\n#define BITMAIN_MAX_CHAIN_NUM      16\n\n#define BITMAIN_TASK_HEADER_SIZE   8\n#define BITMAIN_TASK_FOOTER_SIZE   2\n#define BITMAIN_WORK_SIZE          0x30\n\n#define BITMAIN_MAX_PACKET_MAX_NONCE  0x80\n#define BITMAIN_MAX_TEMP_NUM       32\n#define BITMAIN_MAX_FAN_NUM        32\n\nstruct bitmain_packet_head {\n\tuint8_t token_type;\n\tuint8_t version;\n\tuint16_t length;\n} __attribute__((packed, aligned(4)));\n\nstruct bitmain_txconfig_token {\n\tuint8_t token_type;\n\tuint8_t version;\n\tuint16_t length;\n\tuint8_t reset                :1;\n\tuint8_t fan_eft              :1;\n\tuint8_t timeout_eft          :1;\n\tuint8_t frequency_eft        :1;\n\tuint8_t voltage_eft          :1;\n\tuint8_t chain_check_time_eft :1;\n\tuint8_t chip_config_eft      :1;\n\tuint8_t hw_error_eft         :1;\n\tuint8_t beeper_ctrl          :1;\n\tuint8_t temp_over_ctrl       :1;\n\tuint8_t fan_home_mode        :1;\n\tuint8_t reserved1            :5;\n\tuint8_t chain_check_time;\n\tuint8_t reserved2;\n\n\tuint8_t chain_num;\n\tuint8_t asic_num;\n\tuint8_t fan_pwm_data;\n\tuint8_t timeout_data;\n\n\tuint16_t frequency;\n\tuint8_t voltage[2];\n\n\tuint8_t reg_data[4];\n\tuint8_t chip_address;\n\tuint8_t reg_address;\n\tuint16_t crc;\n} __attribute__((packed, aligned(4)));\n\nstruct bitmain_rxstatus_token {\n\tuint8_t token_type;\n\tuint8_t version;\n\tuint16_t length;\n\tuint8_t chip_status_eft      :1;\n\tuint8_t detect_get           :1;\n\tuint8_t reserved1            :6;\n\tuint8_t reserved2[3];\n\n\tuint8_t chip_address;\n\tuint8_t reg_address;\n\tuint16_t crc;\n} __attribute__((packed, aligned(4)));\n\nstruct bitmain_rxstatus_data {\n\tuint8_t data_type;\n\tuint8_t version;\n\tuint16_t length;\n\tuint8_t chip_value_eft       :1;\n\tuint8_t reserved1            :3;\n\tuint8_t get_blk_num          :4;\n\tuint8_t chain_num;\n\tuint16_t fifo_space;\n\tuint8_t hw_version[4];\n\tuint8_t fan_num;\n\tuint8_t temp_num;\n\tuint16_t fan_exist;\n\tuint32_t temp_exist;\n\tuint32_t nonce_error;\n\tuint32_t reg_value;\n\tuint32_t chain_asic_exist[BITMAIN_MAX_CHAIN_NUM*8];\n\tuint32_t chain_asic_status[BITMAIN_MAX_CHAIN_NUM*8];\n\tuint8_t chain_asic_num[BITMAIN_MAX_CHAIN_NUM];\n\tuint8_t temp[BITMAIN_MAX_TEMP_NUM];\n\tuint8_t fan[BITMAIN_MAX_FAN_NUM];\n\tuint16_t crc;\n} __attribute__((packed, aligned(4)));\n\nstruct bitmain_rxnonce_nonce {\n\tuint32_t work_id;\n\tuint32_t nonce;\n} __attribute__((packed, aligned(4)));\n\nstruct bitmain_rxnonce_data {\n\tuint8_t data_type;\n\tuint8_t version;\n\tuint16_t length;\n\tuint16_t fifo_space;\n\tuint16_t diff;\n\tuint64_t total_nonce_num;\n\tstruct bitmain_rxnonce_nonce nonces[BITMAIN_MAX_PACKET_MAX_NONCE];\n\tuint16_t crc;\n} __attribute__((packed, aligned(4)));\n\nenum bitmain_chip {\n\tBMC_UNKNOWN,\n\tBMC_BM1380,\n\tBMC_BM1382,\n\tBMC_BM1384,\n};\n\nstruct bitmain_info {\n\tvoid *device_curl;\n\tSOCKETTYPE curl_sock;\n\t\n\tenum bitmain_chip chip_type;\n\tint chain_num;\n\tint asic_num;\n\tint chain_asic_num[BITMAIN_MAX_CHAIN_NUM];\n\tuint32_t chain_asic_exist[BITMAIN_MAX_CHAIN_NUM*8];\n\tuint32_t chain_asic_status[BITMAIN_MAX_CHAIN_NUM*8];\n\tchar chain_asic_status_t[BITMAIN_MAX_CHAIN_NUM][320];\n\tint timeout;\n\tint errorcount;\n\tint errorcount2;\n\tuint32_t nonce_error;\n\tuint32_t last_nonce_error;\n\tuint8_t reg_data[4];\n\t\n\tunsigned packet_max_work;  // BITMAIN_MAX_WORK_NUM\n\tunsigned poll_prio_threshold;  // BITMAIN_MAX_WORK_QUEUE_NUM\n\tunsigned packet_max_nonce;     // BITMAIN_MAX_NONCE_NUM\n\n\tint fan_num;\n\tint fan[BITMAIN_MAX_FAN_NUM];\n\tint temp_num;\n\tint temp[BITMAIN_MAX_TEMP_NUM];\n\n\tint temp_max;\n\tint temp_avg;\n\tint temp_history_count;\n\tint temp_history_index;\n\tint temp_sum;\n\tint temp_old;\n\tint fan_pwm;\n\n\tint frequency;\n\tchar frequency_t[256];\n\tuint8_t voltage[2];\n\tchar voltage_t[8];\n\n\tint diff;\n\tfloat lowest_goal_diff;\n\tuint32_t next_work_id;\n\n\tint no_matching_work;\n\t//int matching_work[BITMAIN_DEFAULT_CHAIN_NUM];\n\n\tpthread_mutex_t qlock;\n\tint fifo_space;\n\tint max_fifo_space;\n\tint hw_version[4];\n\n\tint ready_to_queue;\n\tuint8_t *queuebuf;\n\t\n\tbool reset;\n\tbool work_restart;\n\t\n\tchar g_miner_version[256];\n\t\n\tuint8_t readbuf[BITMAIN_READBUF_SIZE];\n\tint readbuf_offset;\n};\n\n#define BITMAIN_READ_SIZE 12\n\n#define BTM_GETS_ERROR -1\n#define BTM_GETS_OK 0\n\n#define BTM_SEND_ERROR -1\n#define BTM_SEND_OK 0\n\n#define BITMAIN_READ_TIME(baud) ((double)BITMAIN_READ_SIZE * (double)8.0 / (double)(baud))\n#define ASSERT1(condition) __maybe_unused static char sizeof_uint32_t_must_be_4[(condition)?1:-1]\n\n#endif /* USE_BITMAIN */\n#endif\t/* BITMAIN_H */\n"
        },
        {
          "name": "driver-cairnsmore.c",
          "type": "blob",
          "size": 6.0380859375,
          "content": "/*\n * Copyright 2012-2015 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"compat.h\"\n#include \"dynclock.h\"\n#include \"driver-icarus.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"miner.h\"\n\n#define CAIRNSMORE1_IO_SPEED 115200\n\n// This is a general ballpark\n#define CAIRNSMORE1_HASH_TIME 0.0000000024484\n\n#define CAIRNSMORE1_MINIMUM_CLOCK  50\n#define CAIRNSMORE1_DEFAULT_CLOCK  200\n#define CAIRNSMORE1_MAXIMUM_CLOCK  210\n\nBFG_REGISTER_DRIVER(cairnsmore_drv)\n\nstatic\nbool cairnsmore_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"Cairnsmore1\");\n}\n\nstatic bool cairnsmore_detect_one(const char *devpath)\n{\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\n\tinfo->baud = CAIRNSMORE1_IO_SPEED;\n\tinfo->work_division = 2;\n\tinfo->fpga_count = 2;\n\tinfo->reopen_mode = IRM_NEVER;\n\tinfo->Hs = CAIRNSMORE1_HASH_TIME;\n\tinfo->timing_mode = MODE_LONG;\n\tinfo->do_icarus_timing = true;\n\n\tif (!icarus_detect_custom(devpath, &cairnsmore_drv, info)) {\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool cairnsmore_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, cairnsmore_detect_one);\n}\n\nstatic bool cairnsmore_send_cmd(int fd, uint8_t cmd, uint8_t data, bool probe)\n{\n\tunsigned char pkt[64] =\n\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\"vdi\\xb7\"\n\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\"bfg0\" \"\\xff\\xff\\xff\\xff\" \"\\xb5\\0\\0\\0\";\n\tif (unlikely(probe))\n\t\tpkt[61] = '\\x01';\n\tpkt[32] = 0xda ^ cmd ^ data;\n\tpkt[33] = data;\n\tpkt[34] = cmd;\n\treturn write(fd, pkt, sizeof(pkt)) == sizeof(pkt);\n}\n\nbool cairnsmore_supports_dynclock(const char * const repr, const int fd)\n{\n\tif (!cairnsmore_send_cmd(fd, 0, 1, true))\n\t\treturn false;\n\tif (!cairnsmore_send_cmd(fd, 0, 1, true))\n\t\treturn false;\n\n\tuint32_t nonce = 0;\n\t{\n\t\tstruct timeval tv_now, tv_timeout;\n\t\tstruct timeval tv_finish;\n\t\ttimer_set_now(&tv_now);\n\t\ttimer_set_delay(&tv_timeout, &tv_now, 100000);\n\t\ticarus_read(repr, (uint8_t *)&nonce, fd, &tv_finish, NULL, &tv_timeout, &tv_now, ICARUS_DEFAULT_READ_SIZE);\n\t}\n\tapplog(LOG_DEBUG, \"Cairnsmore dynclock detection... Got %08x\", nonce);\n\tswitch (nonce) {\n\t\tcase 0x00949a6f:  // big    endian\n\t\tcase 0x6f9a9400:  // little endian\n\t\t\t// Hashed the command, so it's not supported\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tapplog(LOG_WARNING, \"Unexpected nonce from dynclock probe: %08x\", (uint32_t)be32toh(nonce));\n\t\t\treturn false;\n\t\tcase 0:\n\t\t\treturn true;\n\t}\n}\n\n#define cairnsmore_send_cmd(fd, cmd, data) cairnsmore_send_cmd(fd, cmd, data, false)\n\nstatic bool cairnsmore_change_clock_func(struct thr_info *thr, int bestM)\n{\n\tstruct cgpu_info *cm1 = thr->cgpu;\n\tstruct ICARUS_INFO *info = cm1->device_data;\n\n\tif (unlikely(!cairnsmore_send_cmd(cm1->device_fd, 0, bestM)))\n\t\treturn false;\n\n\t// Adjust Hs expectations for frequency change\n\tinfo->Hs = info->Hs * (double)bestM / (double)info->dclk.freqM;\n\n\tdclk_msg_freqchange(cm1->proc_repr, 2.5 * (double)info->dclk.freqM, 2.5 * (double)bestM, NULL);\n\tinfo->dclk.freqM = bestM;\n\n\treturn true;\n}\n\nstatic bool cairnsmore_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *cm1 = thr->cgpu;\n\tstruct ICARUS_INFO *info = cm1->device_data;\n\tstruct icarus_state *state = thr->cgpu_data;\n\n\tif (cairnsmore_supports_dynclock(cm1->proc_repr, cm1->device_fd)) {\n\t\tinfo->dclk_change_clock_func = cairnsmore_change_clock_func;\n\n\t\tdclk_prepare(&info->dclk);\n\t\tinfo->dclk.freqMinM = CAIRNSMORE1_MINIMUM_CLOCK / 2.5;\n\t\tinfo->dclk.freqMaxM = CAIRNSMORE1_MAXIMUM_CLOCK / 2.5;\n\t\tinfo->dclk.freqM =\n\t\tinfo->dclk.freqMDefault = CAIRNSMORE1_DEFAULT_CLOCK / 2.5;\n\t\tcairnsmore_send_cmd(cm1->device_fd, 0, info->dclk.freqM);\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Frequency set to %u MHz (range: %u-%u)\",\n\t\t       cm1->proc_repr,\n\t\t       CAIRNSMORE1_DEFAULT_CLOCK, CAIRNSMORE1_MINIMUM_CLOCK, CAIRNSMORE1_MAXIMUM_CLOCK\n\t\t);\n\t\t// The dynamic-clocking firmware connects each FPGA as its own device\n\t\tif (!(info->user_set & IUS_WORK_DIVISION)) {\n\t\t\tinfo->work_division = 1;\n\t\t\tif (!(info->user_set & IUS_FPGA_COUNT))\n\t\t\t\tinfo->fpga_count = 1;\n\t\t}\n\t} else {\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Frequency scaling not supported\",\n\t\t\tcm1->proc_repr\n\t\t);\n\t}\n\t// Commands corrupt the hash state, so next scanhash is a firstrun\n\tstate->firstrun = true;\n\n\treturn true;\n}\n\nvoid convert_icarus_to_cairnsmore(struct cgpu_info *cm1)\n{\n\tstruct ICARUS_INFO *info = cm1->device_data;\n\tinfo->Hs = CAIRNSMORE1_HASH_TIME;\n\tinfo->fullnonce = info->Hs * (((double)0xffffffff) + 1);\n\tinfo->timing_mode = MODE_LONG;\n\tinfo->do_icarus_timing = true;\n\tcm1->drv = &cairnsmore_drv;\n\trenumber_cgpu(cm1);\n\tcairnsmore_init(cm1->thr[0]);\n}\n\nstatic struct api_data *cairnsmore_drv_extra_device_status(struct cgpu_info *cm1)\n{\n\tstruct ICARUS_INFO *info = cm1->device_data;\n\tstruct api_data*root = NULL;\n\n\tif (info->dclk.freqM) {\n\t\tdouble frequency = 2.5 * info->dclk.freqM;\n\t\troot = api_add_freq(root, \"Frequency\", &frequency, true);\n\t}\n\n\treturn root;\n}\n\nstatic bool cairnsmore_identify(struct cgpu_info *cm1)\n{\n\tstruct ICARUS_INFO *info = cm1->device_data;\n\tif (!info->dclk.freqM)\n\t\treturn false;\n\t\n\tcairnsmore_send_cmd(cm1->device_fd, 1, 1);\n\tcgsleep_ms(5000);\n\tcairnsmore_send_cmd(cm1->device_fd, 1, 0);\n\tcm1->flash_led = true;\n\treturn true;\n}\n\nstatic void cairnsmore_drv_init()\n{\n\tcairnsmore_drv = icarus_drv;\n\tcairnsmore_drv.dname = \"cairnsmore\";\n\tcairnsmore_drv.name = \"ECM\";\n\tcairnsmore_drv.lowl_match = cairnsmore_lowl_match;\n\tcairnsmore_drv.lowl_probe = cairnsmore_lowl_probe;\n\tcairnsmore_drv.thread_init = cairnsmore_init;\n\tcairnsmore_drv.identify_device = cairnsmore_identify;\n\tcairnsmore_drv.get_api_extra_device_status = cairnsmore_drv_extra_device_status;\n\t++cairnsmore_drv.probe_priority;\n}\n\nstruct device_drv cairnsmore_drv = {\n\t.drv_init = cairnsmore_drv_init,\n};\n"
        },
        {
          "name": "driver-cointerra.c",
          "type": "blob",
          "size": 41.0234375,
          "content": "/*\n * Copyright 2013-2014 Con Kolivas\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <string.h>\n\n#include \"miner.h\"\n#include \"deviceapi.h\"\n#include \"driver-cointerra.h\"\n#include \"lowlevel.h\"\n#include \"lowl-usb.h\"\n#include <math.h>\n\nstatic const unsigned cointerra_desired_roll = 60;\nstatic const unsigned long cointerra_latest_result_usecs = (10 * 1000000);\nstatic const unsigned cointerra_max_nonce_diff = 0x20;\n\n#define COINTERRA_USB_TIMEOUT  500\n#define COINTERRA_PACKET_SIZE  0x40\n#define COINTERRA_START_SEQ  0x5a,0x5a\n#define COINTERRA_MSG_SIZE  (COINTERRA_PACKET_SIZE - sizeof(cointerra_startseq))\n#define COINTERRA_MSGBODY_SIZE  (COINTERRA_MSG_SIZE - 1)\n\nBFG_REGISTER_DRIVER(cointerra_drv)\nstatic const struct bfg_set_device_definition cointerra_set_device_funcs[];\n\nenum cointerra_msg_type_out {\n\tCMTO_RESET     = 1,\n\tCMTO_WORK      = 2,\n\tCMTO_REQUEST   = 4,\n\tCMTO_HWERR     = 5,\n\tCMTO_LEDCTL    = 6,\n\tCMTO_HASHRATE  = 7,\n\tCMTO_GET_INFO  = 0x21,\n};\n\nstatic const uint8_t cointerra_startseq[] = {COINTERRA_START_SEQ};\nstatic const char *cointerra_hdr = \"ZZ\";\n\nstatic void cta_gen_message(char *msg, char type)\n{\n\tmemset(msg, 0, CTA_MSG_SIZE);\n\tmemcpy(msg, cointerra_hdr, 2);\n\tmsg[CTA_MSG_TYPE] = type;\n}\n\n/* Find the number of leading zero bits in diff */\nstatic uint8_t diff_to_bits(double diff)\n{\n\tuint64_t diff64;\n\tuint8_t i;\n\n\tdiff *= (double)2147483648.0;\n\tif (diff > 0x8000000000000000ULL)\n\t\tdiff = 0x8000000000000000ULL;\n\t/* Convert it to an integer */\n\tdiff64 = diff;\n\tfor (i = 0; diff64; i++, diff64 >>= 1);\n\n\treturn i;\n}\n\nstatic double bits_to_diff(uint8_t bits)\n{\n\tdouble ret = 1.0;\n\n\tif (likely(bits > 32))\n\t\tret *= 1ull << (bits - 32);\n\telse if (unlikely(bits < 32))\n\t\tret /= 1ull << (32 - bits);\n\treturn ret;\n}\n\nstatic bool cta_reset_init(char *buf)\n{\n\treturn ((buf[CTA_MSG_TYPE] == CTA_RECV_RDONE) && ((buf[CTA_RESET_TYPE]&0x3) == CTA_RESET_INIT));\n}\n\nstatic char *mystrstr(char *haystack, int size, const char *needle)\n{\n\tint loop = 0;\n\n\twhile (loop < (size-1)) {\n\t\tif ((haystack[loop] == needle[0])&&\n\t\t    (haystack[loop+1] == needle[1]))\n\t\t\treturn &haystack[loop];\n\t\tloop++;\n\t}\n\treturn NULL;\n}\n\nstatic\nbool cta_open(struct lowl_usb_endpoint * const ep, const char * const repr, struct cointerra_info * const devstate)\n{\n\tint amount, offset = 0;\n\tchar buf[CTA_MSG_SIZE];\n\tcgtimer_t ts_start;\n\tbool ret = false;\n\n\tapplog(LOG_INFO, \"CTA_OPEN\");\n\n\tcta_gen_message(buf, CTA_SEND_RESET);\n\t// set the initial difficulty\n\tbuf[CTA_RESET_TYPE] = CTA_RESET_INIT | CTA_RESET_DIFF;\n\tbuf[CTA_RESET_DIFF] = diff_to_bits(CTA_INIT_DIFF);\n\tbuf[CTA_RESET_LOAD] = devstate->set_load ?: 255;\n\tbuf[CTA_RESET_PSLOAD] = 0;\n\n\tamount = usb_write(ep, buf, CTA_MSG_SIZE);\n\tif (amount != CTA_MSG_SIZE) {\n\t\tapplog(LOG_INFO, \"Write error %s, wrote %d of %d\",\n\t\t       bfg_strerror(errno, BST_ERRNO),\n\t\t       amount, CTA_MSG_SIZE);\n\t\treturn ret;\n\t}\n\n\tcgtimer_time(&ts_start);\n\n\t/* Read from the device for up to 2 seconds discarding any data that\n\t * doesn't match a reset complete acknowledgement. */\n\twhile (42) {\n\t\tcgtimer_t ts_now, ts_diff;\n\t\tchar *msg;\n\n\t\tcgtimer_time(&ts_now);\n\t\tcgtimer_sub(&ts_now, &ts_start, &ts_diff);\n\t\tif (cgtimer_to_ms(&ts_diff) > 2000) {\n\t\t\tapplog(LOG_DEBUG, \"%s: Timed out waiting for response to reset init\", repr);\n\t\t\tbreak;\n\t\t}\n\n\t\tamount = usb_read(ep, buf + offset, CTA_MSG_SIZE - offset);\n\t\tif (amount != (CTA_MSG_SIZE - offset) && amount != 0) {\n\t\t\tapplog(LOG_INFO, \"%s: Read error %s, read %d\",\n\t\t\t       repr, bfg_strerror(errno, BST_ERRNO), amount);\n\t\t\tbreak;\n\t\t}\n\t\tif (!amount)\n\t\t\tcontinue;\n\n\t\tmsg = mystrstr(buf, amount, cointerra_hdr);\n\t\tif (!msg) {\n\t\t\t/* Keep the last byte in case it's the first byte of\n\t\t\t * the 2 byte header. */\n\t\t\toffset = 1;\n\t\t\tmemmove(buf, buf + amount - 1, offset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (msg > buf) {\n\t\t\t/* length of message = offset for next usb_read after moving */\n\t\t\toffset = CTA_MSG_SIZE - (msg - buf);\n\t\t\tmemmove(buf, msg, offset);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a full sized message starting with the header now */\n\t\tif (cta_reset_init(buf)) {\n\t\t\t/* We can't store any other data returned with this\n\t\t\t * reset since we have not allocated any memory for\n\t\t\t * a cointerra_info structure yet. */\n\t\t\tapplog(LOG_INFO, \"%s: Successful reset init received\", repr);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic\nbool cointerra_open(const struct lowlevel_device_info * const info, const char * const repr, struct libusb_device_handle ** const usbh_p, struct lowl_usb_endpoint ** const ep_p, struct cointerra_info * const devstate)\n{\n\tint e;\n\tif (libusb_open(info->lowl_data, usbh_p))\n\t\tapplogr(false, LOG_DEBUG, \"%s: USB open failed on %s\",\n\t\t        cointerra_drv.dname, info->devid);\n\tif ( (e = libusb_set_configuration(*usbh_p, 1)) )\n\t\treturn_via_applog(fail, , LOG_ERR, \"%s: Failed to %s on %s: %s\", repr, \"set configuration 1\", info->devid, bfg_strerror(e, BST_LIBUSB));\n\tif ( (e = libusb_claim_interface(*usbh_p, 0)) )\n\t\treturn_via_applog(fail, , LOG_ERR, \"%s: Failed to %s on %s: %s\", repr, \"claim interface 0\", info->devid, bfg_strerror(e, BST_LIBUSB));\n\t*ep_p = usb_open_ep_pair(*usbh_p, LIBUSB_ENDPOINT_IN | 1, 64, LIBUSB_ENDPOINT_OUT | 1, 64);\n\tif (!*ep_p)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Endpoint open failed on %s\",\n\t\t       cointerra_drv.dname, info->devid);\nfail:\n\t\tlibusb_close(*usbh_p);\n\t\t*usbh_p = NULL;\n\t\treturn false;\n\t}\n\t\n\tif (!cta_open(*ep_p, repr, devstate))\n\t{\n\t\tusb_close_ep(*ep_p);\n\t\t*ep_p = NULL;\n\t\tgoto fail;\n\t}\n\t\n\treturn true;\n}\n\nstatic void cta_clear_work(struct cgpu_info *cgpu)\n{\n\tstruct work *work, *tmp;\n\n\twr_lock(&cgpu->qlock);\n\tHASH_ITER(hh, cgpu->queued_work, work, tmp) {\n\t\t__work_completed(cgpu, work);\n\t\tfree_work(work);\n\t}\n\twr_unlock(&cgpu->qlock);\n}\n\nstatic void cta_close(struct cgpu_info *cointerra)\n{\n\tstruct cointerra_info *info = cointerra->device_data;\n\n\tif (info->ep)\n\t{\n\t\t/* Open does the same reset init followed by response as is required to\n\t\t * close the device. */\n\t\tif (!cta_open(info->ep, cointerra->dev_repr, info)) {\n\t\t\tapplog(LOG_INFO, \"%s %d: Reset on close failed\", cointerra->drv->name,\n\t\t\t\tcointerra->device_id);\n\t\t}\n\t}\n\n\tmutex_destroy(&info->lock);\n\tmutex_destroy(&info->sendlock);\n\t/* Don't free info here to avoid trying to access dereferenced members\n\t * once a device is unplugged. */\n\tcta_clear_work(cointerra);\n}\n\nstatic void cta_parse_info(struct cgpu_info *, struct cointerra_info *, char *);\nstatic void msg_from_hu16(char *, int, uint16_t);\n\nstatic\nbool cointerra_wait_for_info(struct cointerra_info * const ctainfo, struct lowl_usb_endpoint * const ep)\n{\n\tchar buf[CTA_MSG_SIZE];\n\tint amount;\n\t\n\tcta_gen_message(buf, CTA_SEND_REQUEST);\n\tmsg_from_hu16(buf, CTA_REQ_MSGTYPE, CTA_RECV_INFO);\n\tmsg_from_hu16(buf, CTA_REQ_INTERVAL, 0);\n\tamount = usb_write(ep, buf, CTA_MSG_SIZE);\n\tif (amount != CTA_MSG_SIZE)\n\t\treturn false;\n\t\n\tdo {\n\t\tamount = usb_read(ep, buf, CTA_MSG_SIZE);\n\t\tif (amount != CTA_MSG_SIZE)\n\t\t\tapplogr(false, LOG_ERR, \"%s: Read error %s, read %d\",\n\t\t\t        __func__, bfg_strerror(errno, BST_ERRNO), amount);\n\t\t\n\t\tif (memcmp(buf, cointerra_hdr, 2))\n\t\t\tapplogr(false, LOG_ERR, \"%s: Packet header mismatch\", __func__);\n\t} while (buf[CTA_MSG_TYPE] != CTA_RECV_INFO);\n\t\n\tcta_parse_info(NULL, ctainfo, buf);\n\t\n\treturn true;\n}\n\nstatic\nbool cointerra_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tstruct cointerra_info ctainfo = { .set_load = 0, };\n\tstruct libusb_device_handle *usbh;\n\tstruct lowl_usb_endpoint *ep;\n\tbool b;\n\t\n\tif (info->lowl != &lowl_usb)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\treturn false;\n\t}\n\t\n\tif (!cointerra_open(info, cointerra_drv.dname, &usbh, &ep, &ctainfo))\n\t\treturn false;\n\tmutex_init(&ctainfo.lock);\n\tb = cointerra_wait_for_info(&ctainfo, ep);\n\tmutex_destroy(&ctainfo.lock);\n\tusb_close_ep(ep);\n\tlibusb_close(usbh);\n\t\n\tif (!b)\n\t\treturn false;\n\t\n\tapplog(LOG_DEBUG, \"%s: Found %lu cores on %s\",\n\t       __func__, (unsigned long)ctainfo.cores, info->devid);\n\n\tlibusb_device * const usbdev = info->lowl_data;\n\tif (bfg_claim_libusb(&cointerra_drv, true, usbdev))\n\t\treturn false;\n\t\n\tstruct cgpu_info * const dev = malloc(sizeof(*dev));\n\t*dev = (struct cgpu_info){\n\t\t.drv = &cointerra_drv,\n\t\t.set_device_funcs = cointerra_set_device_funcs,\n\t\t.procs = ctainfo.cores,\n\t\t.device_data = lowlevel_ref(info),\n\t\t.threads = 1,\n\t\t.device_path = strdup(info->devid),\n\t\t.dev_manufacturer = maybe_strdup(info->manufacturer),\n\t\t.dev_product = maybe_strdup(info->product),\n\t\t.dev_serial = maybe_strdup(info->serial),\n\t\t.deven = DEV_ENABLED,\n\t};\n\tconst bool rv = add_cgpu(dev);\n\tapplog(LOG_INFO, \"%s: Successfully set up %s\",\n\t       cointerra_drv.dname, dev->dev_repr);\n\treturn rv;\n}\n\nstatic\nvoid cointerra_set_queue_full(struct cgpu_info * const dev, const bool nv)\n{\n\tif (dev->thr[0]->queue_full == nv)\n\t\treturn;\n\tfor_each_managed_proc(proc, dev)\n\t\tproc->thr[0]->queue_full = nv;\n}\n\nstatic\nbool cointerra_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_usb, \"GoldStrike\");\n}\n\n/* This function will remove a work item from the hashtable if it matches the\n * id in work->subid and return a pointer to the work but it will not free the\n * work. It may return NULL if it cannot find matching work. */\nstatic struct work *take_work_by_id(struct cgpu_info *cgpu, uint16_t id)\n{\n\tstruct work *work, *tmp, *ret = NULL;\n\n\twr_lock(&cgpu->qlock);\n\tHASH_ITER(hh, cgpu->queued_work, work, tmp) {\n\t\tif (work->subid == id) {\n\t\t\tret = work;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret)\n\t\t__work_completed(cgpu, ret);\n\twr_unlock(&cgpu->qlock);\n\n\treturn ret;\n}\n\n/* This function will look up a work item in the hashtable if it matches the\n * id in work->subid and return a cloned work item if it matches. It may return\n * NULL if it cannot find matching work. */\nstatic struct work *clone_work_by_id(struct cgpu_info *cgpu, uint16_t id)\n{\n\tstruct work *work, *tmp, *ret = NULL;\n\n\trd_lock(&cgpu->qlock);\n\tHASH_ITER(hh, cgpu->queued_work, work, tmp) {\n\t\tif (work->subid == id) {\n\t\t\tret = work;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret)\n\t\tret = copy_work(ret);\n\trd_unlock(&cgpu->qlock);\n\n\treturn ret;\n}\n\nstatic bool cta_send_msg(struct cgpu_info *cointerra, char *buf);\n\nstatic uint16_t hu16_from_msg(char *buf, int msg)\n{\n\treturn le16toh(*(uint16_t *)&buf[msg]);\n}\n\nstatic uint32_t hu32_from_msg(char *buf, int msg)\n{\n\treturn le32toh(*(uint32_t *)&buf[msg]);\n}\n\nstatic uint64_t hu64_from_msg(char *buf, int msg)\n{\n\treturn le64toh(*(uint64_t *)&buf[msg]);\n}\n\nstatic uint8_t u8_from_msg(char *buf, int msg)\n{\n\treturn *(uint8_t *)&buf[msg];\n}\n\nstatic void msg_from_hu16(char *buf, int msg, uint16_t val)\n{\n\t*(uint16_t *)&buf[msg] = htole16(val);\n}\n\nstatic void cta_parse_reqwork(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t      char *buf)\n{\n\tuint16_t retwork;\n\n\tretwork = hu16_from_msg(buf, CTA_REQWORK_REQUESTS);\n\tapplog(LOG_DEBUG, \"%s %d: Request work message for %u items received\",\n\t       cointerra->drv->name, cointerra->device_id, retwork);\n\n\tmutex_lock(&info->lock);\n\tinfo->requested = retwork;\n\tcointerra_set_queue_full(cointerra, !retwork);\n\tmutex_unlock(&info->lock);\n}\n\nstatic void cta_parse_recvmatch(struct thr_info *thr, struct cgpu_info *cointerra,\n\t\t\t\tstruct cointerra_info *info, char *buf)\n{\n\tstruct cgpu_info *corecgpu;\n\tstruct thr_info *corethr;\n\tuint32_t timestamp_offset, mcu_tag;\n\tuint16_t retwork;\n\tstruct work *work;\n\tuint8_t asic, core, pipe, coreno;\n\tint pipeno, bitchar, bitbit;\n\n\t/* No endian switch needs doing here since it's sent and returned as\n\t * the same 4 bytes */\n\tretwork = *(uint16_t *)(&buf[CTA_DRIVER_TAG]);\n\tmcu_tag = hu32_from_msg(buf, CTA_MCU_TAG);\n\tconst uint8_t wdiffbits = u8_from_msg(buf, CTA_WORK_DIFFBITS);\n\tconst uint32_t nonce = hu32_from_msg(buf, CTA_MATCH_NONCE);\n\t\n\tasic = u8_from_msg(buf, CTA_MCU_ASIC);\n\tcore = u8_from_msg(buf, CTA_MCU_CORE);\n\tpipe = u8_from_msg(buf, CTA_MCU_PIPE);\n\tpipeno = asic * 512 + core * 128 + pipe;\n\t\n\t// For some reason, pipe numbers skip 0x?f\n\tconst int bfg_pipeno = ((pipe >> 4) * 0xf) + (pipe & 0xf);\n\tconst unsigned procno = (asic * 480) + (core * 120) + bfg_pipeno;\n\t\n\tcorecgpu = device_proc_by_id(cointerra, procno) ?: cointerra;\n\tcorethr = corecgpu->thr[0];\n\t\n\tapplog(LOG_DEBUG, \"%s %d: Match message for id 0x%04x MCU id 0x%08x received\",\n\t       cointerra->drv->name, cointerra->device_id, retwork, mcu_tag);\n\n\twork = clone_work_by_id(cointerra, retwork);\n\tif (likely(work)) {\n\t\tunsigned char rhash[32];\n\t\tchar outhash[16];\n\t\tdouble wdiff;\n\t\tuint64_t hashes;\n\t\tbool ret;\n\n\t\ttimestamp_offset = hu32_from_msg(buf, CTA_MATCH_NOFFSET);\n\t\tif (timestamp_offset) {\n\t\t\tstruct work *base_work = work;\n\n\t\t\twork = copy_work_noffset(base_work, timestamp_offset);\n\t\t\tfree_work(base_work);\n\t\t}\n\n\t\t/* Test against the difficulty we asked for along with the work */\n\t\twdiff = bits_to_diff(wdiffbits);\n\t\thashes = (uint64_t)wdiff * 0x100000000ull;\n\t\tret = true; // TODO: test_nonce_diff(work, nonce, wdiff);\n\n\t\tif (opt_debug) {\n\t\t\t/* Debugging, remove me */\n\t\t\tswab256(rhash, work->hash);\n\t\t\tbin2hex(outhash, rhash, 8);\n\t\t\tapplog(LOG_DEBUG, \"submit work %s 0x%04x 0x%08x %d 0x%08x\",\n\t\t\t       outhash, retwork, mcu_tag, timestamp_offset, nonce);\n\t\t}\n\t\t\n\t\thashes_done2(corethr, hashes, NULL);\n\n\t\tif (likely(ret)) {\n\t\t\tcoreno = asic * 4 + core;\n\t\t\tif (unlikely(asic > 1 || core > 3 || pipe > 127 || pipeno > 1023)) {\n\t\t\t\tapplog(LOG_WARNING, \"%s %d: MCU invalid pipe asic %d core %d pipe %d\",\n\t\t\t\t       cointerra->drv->name, cointerra->device_id, asic, core, pipe);\n\t\t\t\tcoreno = 0;\n\t\t\t} else {\n\t\t\t\tinfo->last_pipe_nonce[pipeno] = time(NULL);\n\t\t\t\tbitchar = pipeno / 8;\n\t\t\t\tbitbit = pipeno % 8;\n\t\t\t\tinfo->pipe_bitmap[bitchar] |= 0x80 >> bitbit;\n\t\t\t}\n\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Submitting tested work job_id %s work_id %u\",\n\t\t\t       corecgpu->proc_repr, work->job_id, work->subid);\n\t\t\tret = submit_nonce(corethr, work, nonce);\n\n\t\t\tmutex_lock(&info->lock);\n\t\t\tinfo->share_hashes += hashes;\n\t\t\tinfo->tot_core_hashes[coreno] += hashes;\n\t\t\tinfo->hashes += nonce;\n\t\t\tmutex_unlock(&info->lock);\n\t\t} else {\n\t\t\tchar sendbuf[CTA_MSG_SIZE];\n\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Notify bad match work\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tif (opt_debug) {\n\t\t\t\tunsigned char midstate[32], wdata[12];\n\t\t\t\tchar hexmidstate[68], hexwdata[28];\n\t\t\t\tuint16_t wid;\n\n\t\t\t\tmemcpy(&wid, &info->work_id, 2);\n\t\t\t\tflip32(midstate, work->midstate);\n\t\t\t\tbin2hex(hexmidstate, midstate, 32);\n\t\t\t\tflip12(wdata, &work->data[64]);\n\t\t\t\tbin2hex(hexwdata, wdata, 12);\n\t\t\t\tapplog(LOG_DEBUG, \"False match sent: work id %u midstate %s  blkhdr %s\",\n\t\t\t\t       wid, hexmidstate, hexwdata);\n\t\t\t\tapplog(LOG_DEBUG, \"False match reports: work id 0x%04x MCU id 0x%08x work diff %.1f\",\n\t\t\t\t       retwork, mcu_tag, wdiff);\n\t\t\t\tapplog(LOG_DEBUG, \"False match tested: nonce 0x%08x noffset %d %s\",\n\t\t\t\t       nonce, timestamp_offset, outhash);\n\t\t\t}\n\n\t\t\t/* Tell the device we got a false match */\n\t\t\tcta_gen_message(sendbuf, CTA_SEND_FMATCH);\n\t\t\tmemcpy(sendbuf + 3, buf, CTA_MSG_SIZE - 3);\n\t\t\tcta_send_msg(cointerra, sendbuf);\n\t\t}\n\t\tfree_work(work);\n\t} else {\n\t\tapplog(LOG_INFO, \"%s %d: Matching work id 0x%X %d not found\", cointerra->drv->name,\n\t\t       cointerra->device_id, retwork, __LINE__);\n\t\tinc_hw_errors3(corethr, NULL, &nonce, bits_to_diff(wdiffbits));\n\n\t\tmutex_lock(&info->lock);\n\t\tinfo->no_matching_work++;\n\t\tmutex_unlock(&info->lock);\n\t}\n}\n\nstatic void cta_parse_wdone(struct thr_info *thr, struct cgpu_info *cointerra,\n\t\t\t    struct cointerra_info *info, char *buf)\n{\n\tuint16_t retwork = *(uint16_t *)(&buf[CTA_DRIVER_TAG]);\n\tstruct work *work = take_work_by_id(cointerra, retwork);\n\tuint64_t hashes;\n\n\tif (likely(work))\n\t\tfree_work(work);\n\telse {\n\t\tapplog(LOG_INFO, \"%s %d: Done work not found id 0x%X %d\",\n\t\t       cointerra->drv->name, cointerra->device_id, retwork, __LINE__);\n\t\tinc_hw_errors_only(thr);\n\t}\n\n\t/* Removing hashes from work done message */\n\thashes = hu64_from_msg(buf, CTA_WDONE_NONCES);\n\tif (unlikely(hashes > (61 * 0x100000000ull))) {\n\t\tapplog(LOG_INFO, \"%s Invalid hash returned %\"PRIu64\"x %\"PRIu64\"x %\"PRIu64\"X\",\n\t\t       __func__, info->hashes, hashes, hashes);\n\t\thashes = 0;\n\t}\n\n\tmutex_lock(&info->lock);\n\tinfo->hashes += hashes;\n\tmutex_unlock(&info->lock);\n}\n\nstatic void u16array_from_msg(uint16_t *u16, int entries, int var, char *buf)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < entries; i++, j += sizeof(uint16_t))\n\t\tu16[i] = hu16_from_msg(buf, var + j);\n}\n\nstatic void cta_parse_statread(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t       char *buf)\n{\n\tint i;\n\n\tmutex_lock(&info->lock);\n\tu16array_from_msg(info->coretemp, CTA_CORES, CTA_STAT_CORETEMPS, buf);\n\tinfo->ambtemp_low = hu16_from_msg(buf, CTA_STAT_AMBTEMP_LOW);\n\tinfo->ambtemp_avg = hu16_from_msg(buf, CTA_STAT_AMBTEMP_AVG);\n\tinfo->ambtemp_high = hu16_from_msg(buf, CTA_STAT_AMBTEMP_HIGH);\n\tu16array_from_msg(info->pump_tachs, CTA_PUMPS, CTA_STAT_PUMP_TACHS, buf);\n\tu16array_from_msg(info->fan_tachs, CTA_FANS, CTA_STAT_FAN_TACHS, buf);\n\tu16array_from_msg(info->corevolts, CTA_CORES, CTA_STAT_CORE_VOLTS, buf);\n\tinfo->volts33 = hu16_from_msg(buf, CTA_STAT_VOLTS33);\n\tinfo->volts12 = hu16_from_msg(buf, CTA_STAT_VOLTS12);\n\tinfo->inactive = hu16_from_msg(buf, CTA_STAT_INACTIVE);\n\tinfo->active = hu16_from_msg(buf, CTA_STAT_ACTIVE);\n\tmutex_unlock(&info->lock);\n\n\tstruct cgpu_info *proc = cointerra;\n\tfor (i = 0; i < CTA_CORES; i++) {\n\t\tfloat temp = info->coretemp[i] / 100.;\n\t\tfor (int j = 0; j < 120; (++j), (proc = proc->next_proc))\n\t\t\tproc->temp = temp;\n\t}\n}\n\nstatic void u8array_from_msg(uint8_t *u8, int entries, int var, char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < entries; i++)\n\t\tu8[i] = u8_from_msg(buf, var + i);\n}\n\nstatic void cta_parse_statset(struct cointerra_info *info, char *buf)\n{\n\tmutex_lock(&info->lock);\n\tu8array_from_msg(info->coreperf, CTA_CORES, CTA_STAT_PERFMODE, buf);\n\tu8array_from_msg(info->fanspeed, CTA_FANS, CTA_STAT_FANSPEEDS, buf);\n\tinfo->dies_active = u8_from_msg(buf, CTA_STAT_DIES_ACTIVE);\n\tu8array_from_msg(info->pipes_enabled, CTA_CORES, CTA_STAT_PIPES_ENABLED, buf);\n\tu16array_from_msg(info->corefreqs, CTA_CORES, CTA_STAT_CORE_FREQS, buf);\n\tinfo->uptime = hu32_from_msg(buf,CTA_STAT_UPTIME);\n\tmutex_unlock(&info->lock);\n}\n\nstatic void cta_parse_info(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t   char *buf)\n{\n\tmutex_lock(&info->lock);\n\tinfo->hwrev = hu64_from_msg(buf, CTA_INFO_HWREV);\n\tinfo->serial = hu32_from_msg(buf, CTA_INFO_SERNO);\n\tinfo->asics = u8_from_msg(buf, CTA_INFO_NUMASICS);\n\tinfo->dies = u8_from_msg(buf, CTA_INFO_NUMDIES);\n\tinfo->cores = hu16_from_msg(buf, CTA_INFO_NUMCORES);\n\tinfo->board_number = u8_from_msg(buf, CTA_INFO_BOARDNUMBER);\n\tinfo->fwrev[0] = u8_from_msg(buf, CTA_INFO_FWREV_MAJ);\n\tinfo->fwrev[1] = u8_from_msg(buf, CTA_INFO_FWREV_MIN);\n\tinfo->fwrev[2] = u8_from_msg(buf, CTA_INFO_FWREV_MIC);\n\tinfo->fw_year = hu16_from_msg(buf, CTA_INFO_FWDATE_YEAR);\n\tinfo->fw_month = u8_from_msg(buf, CTA_INFO_FWDATE_MONTH);\n\tinfo->fw_day = u8_from_msg(buf, CTA_INFO_FWDATE_DAY);\n\tinfo->init_diffbits = u8_from_msg(buf, CTA_INFO_INITDIFFBITS);\n\tinfo->min_diffbits = u8_from_msg(buf, CTA_INFO_MINDIFFBITS);\n\tinfo->max_diffbits = u8_from_msg(buf, CTA_INFO_MAXDIFFBITS);\n\tmutex_unlock(&info->lock);\n\n#if 0\n\tif (!cointerra->unique_id) {\n\t\tuint32_t b32 = htobe32(info->serial);\n\n\t\tcointerra->unique_id = malloc((4 * 2) + 1);\n\t\tbin2hex(cointerra->unique_id, &b32, 4);\n\t}\n#endif\n}\n\nstatic void cta_parse_rdone(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t    char *buf)\n{\n\tuint8_t reset_type, diffbits;\n\tuint64_t wdone;\n\n\treset_type = buf[CTA_RESET_TYPE];\n\tdiffbits = buf[CTA_RESET_DIFF];\n\twdone = hu64_from_msg(buf, CTA_WDONE_NONCES);\n\n\tapplog(LOG_INFO, \"%s %d: Reset done type %u message %u diffbits %\"PRIu64\" done received\",\n\t       cointerra->drv->name, cointerra->device_id, reset_type, diffbits, wdone);\n\tif (wdone) {\n\t\tapplog(LOG_INFO, \"%s %d: Reset done type %u message %u diffbits %\"PRIu64\" done received\",\n\t\t\tcointerra->drv->name, cointerra->device_id, reset_type, diffbits, wdone);\n\n\t\tmutex_lock(&info->lock);\n\t\tinfo->hashes += wdone;\n\t\tmutex_unlock(&info->lock);\n\t}\n\n\t/* Note that the cgsem that is posted here must not be waited on while\n\t * holding the info->lock to not get into a livelock since this\n\t * function also grabs the lock first and it's always best to not sleep\n\t * while holding a lock. */\n\tif (reset_type == CTA_RESET_NEW) {\n\t\tcta_clear_work(cointerra);\n\t\t/* Tell reset sender that the reset is complete\n\t\t\t* and it may resume. */\n\t\tnotifier_wake(info->reset_notifier);\n\t}\n}\n\nstatic void cta_zero_stats(struct cgpu_info *cointerra);\n\nstatic void cta_parse_debug(struct cointerra_info *info, char *buf)\n{\n\tmutex_lock(&info->lock);\n\n\tinfo->tot_underruns = hu16_from_msg(buf, CTA_STAT_UNDERRUNS);\n\tu16array_from_msg(info->tot_hw_errors, CTA_CORES, CTA_STAT_HW_ERRORS, buf);\n\tinfo->tot_hashes = hu64_from_msg(buf, CTA_STAT_HASHES);\n\tinfo->tot_flushed_hashes = hu64_from_msg(buf, CTA_STAT_FLUSHED_HASHES);\n\tinfo->autovoltage = u8_from_msg(buf, CTA_STAT_AUTOVOLTAGE);\n\tinfo->current_ps_percent = u8_from_msg(buf, CTA_STAT_POWER_PERCENT);\n\tinfo->power_used = hu16_from_msg(buf,CTA_STAT_POWER_USED);\n\tinfo->power_voltage = hu16_from_msg(buf,CTA_STAT_VOLTAGE);\n\tinfo->ipower_used = hu16_from_msg(buf,CTA_STAT_IPOWER_USED);\n\tinfo->ipower_voltage = hu16_from_msg(buf,CTA_STAT_IVOLTAGE);\n\tinfo->power_temps[0] = hu16_from_msg(buf,CTA_STAT_PS_TEMP1);\n\tinfo->power_temps[1] = hu16_from_msg(buf,CTA_STAT_PS_TEMP2);\n\n\tmutex_unlock(&info->lock);\n\n#if 0\n\t/* Autovoltage is positive only once at startup and eventually drops\n\t * to zero. After that time we reset the stats since they're unreliable\n\t * till then. */\n\tif (unlikely(!info->autovoltage_complete && !info->autovoltage)) {\n\t\tstruct cgpu_info *cointerra = info->thr->cgpu;\n\n\t\tinfo->autovoltage_complete = true;\n\t\tcgtime(&cointerra->dev_start_tv);\n\t\tcta_zero_stats(cointerra);\n\t\tcointerra->total_mhashes = 0;\n\t\tcointerra->accepted = 0;\n\t\tcointerra->rejected = 0;\n\t\tcointerra->hw_errors = 0;\n\t\tcointerra->utility = 0.0;\n\t\tcointerra->last_share_pool_time = 0;\n\t\tcointerra->diff1 = 0;\n\t\tcointerra->diff_accepted = 0;\n\t\tcointerra->diff_rejected = 0;\n\t\tcointerra->last_share_diff = 0;\n\t}\n#endif\n}\n\nstatic void cta_parse_msg(struct thr_info *thr, struct cgpu_info *cointerra,\n\t\t\t  struct cointerra_info *info, char *buf)\n{\n\tswitch (buf[CTA_MSG_TYPE]) {\n\t\tdefault:\n\t\tcase CTA_RECV_UNUSED:\n\t\t\tapplog(LOG_INFO, \"%s %d: Unidentified message type %u\",\n\t\t\t       cointerra->drv->name, cointerra->device_id, buf[CTA_MSG_TYPE]);\n\t\t\tbreak;\n\t\tcase CTA_RECV_REQWORK:\n\t\t\tcta_parse_reqwork(cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_MATCH:\n\t\t\tcta_parse_recvmatch(thr, cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_WDONE:\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Work done message received\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tcta_parse_wdone(thr, cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_STATREAD:\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Status readings message received\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tcta_parse_statread(cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_STATSET:\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Status settings message received\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tcta_parse_statset(info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_INFO:\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Info message received\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tcta_parse_info(cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_MSG:\n\t\t\tapplog(LOG_NOTICE, \"%s: Devlog: %.*s\", cointerra->dev_repr, (int)COINTERRA_MSGBODY_SIZE, &buf[CTA_MSG_RECVD]);\n\t\t\tbreak;\n\t\tcase CTA_RECV_RDONE:\n\t\t\tcta_parse_rdone(cointerra, info, buf);\n\t\t\tbreak;\n\t\tcase CTA_RECV_STATDEBUG:\n\t\t\tcta_parse_debug(info, buf);\n\t\t\tbreak;\n\t}\n}\n\nstatic\nvoid cta_recv_thread(void *arg)\n{\n\tstruct thr_info *thr = (struct thr_info *)arg;\n\tstruct cgpu_info *cointerra = thr->cgpu;\n\tstruct cointerra_info *info = cointerra->device_data;\n\tint offset = 0;\n\n\twhile (likely(!cointerra->shutdown)) {\n\t\tchar buf[CTA_READBUF_SIZE];\n\t\tint amount;\n\n\t\tif (unlikely(0))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s %d: Device disappeared, disabling recv thread\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\tbreak;\n\t\t}\n\n\t\tamount = usb_read(info->ep, buf + offset, CTA_MSG_SIZE);\n\t\tif (amount != CTA_MSG_SIZE && amount != 0) {\n\t\t\tapplog(LOG_ERR, \"%s: Read error %s, read %d\",\n\t\t\t       cointerra->dev_repr, bfg_strerror(errno, BST_ERRNO), amount);\n\t\t\tbreak;\n\t\t}\n\t\toffset += amount;\n\n\t\twhile (offset >= CTA_MSG_SIZE) {\n\t\t\tchar *msg = mystrstr(buf, offset, cointerra_hdr);\n\t\t\tint begin;\n\n\t\t\tif (unlikely(!msg)) {\n\t\t\t\tapplog(LOG_WARNING, \"%s %d: No message header found, discarding buffer\",\n\t\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\t/* Save the last byte in case it's the fist\n\t\t\t\t * byte of a header. */\n\t\t\t\tbegin = CTA_MSG_SIZE - 1;\n\t\t\t\toffset -= begin;\n\t\t\t\tmemmove(buf, buf + begin, offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unlikely(msg != buf)) {\n\t\t\t\tbegin = msg - buf;\n\t\t\t\tapplog(LOG_WARNING, \"%s %d: Reads out of sync, discarding %d bytes\",\n\t\t\t\t       cointerra->drv->name, cointerra->device_id, begin);\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\toffset -= begin;\n\t\t\t\tmemmove(buf, msg, offset);\n\t\t\t\tif (offset < CTA_MSG_SIZE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* We have enough buffer for a full message, parse now */\n\t\t\tcta_parse_msg(thr, cointerra, info, msg);\n\t\t\toffset -= CTA_MSG_SIZE;\n\t\t\tif (offset > 0)\n\t\t\t\tmemmove(buf, buf + CTA_MSG_SIZE, offset);\n\t\t}\n\t\t\n\t\tbreak;\n\t}\n}\n\nstatic\nbool cointerra_write_msg(struct lowl_usb_endpoint * const ep, const char * const repr, const uint8_t msgtype, const void * const msgbody)\n{\n\tuint8_t buf[COINTERRA_PACKET_SIZE], *p;\n\tmemcpy(buf, cointerra_startseq, sizeof(cointerra_startseq));\n\tp = &buf[sizeof(cointerra_startseq)];\n\tpk_u8(p, 0, msgtype);\n\tmemcpy(&p[1], msgbody, COINTERRA_MSGBODY_SIZE);\n\t\n\tif (usb_write(ep, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn false;\n\t\n\treturn true;\n}\n\nstatic bool cta_send_msg(struct cgpu_info *cointerra, char *buf)\n{\n\tstruct cointerra_info *info = cointerra->device_data;\n\tint amount;\n\n\t/* Serialise usb writes to prevent overlap in case multiple threads\n\t * send messages */\n\tmutex_lock(&info->sendlock);\n\tamount = usb_write(info->ep, buf, CTA_MSG_SIZE);\n\tmutex_unlock(&info->sendlock);\n\n\tif (unlikely(amount != CTA_MSG_SIZE)) {\n\t\tapplog(LOG_ERR, \"%s: Write error %s, wrote %d of %d\",\n\t\t       cointerra->dev_repr, bfg_strerror(errno, BST_ERRNO), amount, CTA_MSG_SIZE);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool cta_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *cointerra = thr->cgpu;\n\tstruct lowlevel_device_info * const llinfo = cointerra->device_data;\n\tstruct cointerra_info *info = calloc(sizeof(struct cointerra_info), 1);\n\tchar buf[CTA_MSG_SIZE];\n\n\tsleep(1);\n\t\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to calloc info in cta_detect_one\");\n\tfor_each_managed_proc(proc, cointerra)\n\t\tproc->device_data = info;\n\t/* Nominally set a requested value when starting, preempting the need\n\t * for a req-work message. */\n\tinfo->requested = CTA_MAX_QUEUE;\n\tcointerra_set_queue_full(cointerra, false);\n\t\n\tcgpu_set_defaults(cointerra);\n\n\tbool open_rv = cointerra_open(llinfo, cointerra->dev_repr, &info->usbh, &info->ep, info);\n\tlowlevel_devinfo_free(llinfo);\n\tif (!open_rv)\n\t\treturn false;\n\t\n\tinfo->thr = thr;\n\tmutex_init(&info->lock);\n\tmutex_init(&info->sendlock);\n\tnotifier_init(info->reset_notifier);\n\n\t/* Request a single status setting message */\n\tcta_gen_message(buf, CTA_SEND_REQUEST);\n\tmsg_from_hu16(buf, CTA_REQ_MSGTYPE, CTA_RECV_STATSET);\n\tmsg_from_hu16(buf, CTA_REQ_INTERVAL, 0);\n\tif (!cta_send_msg(cointerra, buf))\n\t\treturn false;\n\n\t/* Request status debug messages every 60 seconds */\n\tcta_gen_message(buf, CTA_SEND_REQUEST);\n\tmsg_from_hu16(buf, CTA_REQ_MSGTYPE, CTA_RECV_STATDEBUG);\n\tmsg_from_hu16(buf, CTA_REQ_INTERVAL, 6000);\n\tif (!cta_send_msg(cointerra, buf))\n\t\treturn false;\n\n\tcgtime(&info->core_hash_start);\n\t\n\tusb_ep_set_timeouts_ms(info->ep, COINTERRA_USB_TIMEOUT, COINTERRA_USB_TIMEOUT);\n\ttimer_set_now(&thr->tv_poll);\n\n\treturn true;\n}\n\nstatic void cta_send_reset(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t   uint8_t reset_type, uint8_t diffbits);\nstatic void cta_flush_work(struct cgpu_info *cointerra);\n\nstatic\nbool cointerra_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const dev = thr->cgpu->device;\n// \tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct cointerra_info * const devstate = dev->device_data;\n\tstruct timeval tv_now, tv_latest;\n\tuint8_t buf[COINTERRA_MSGBODY_SIZE] = {0};\n\tuint16_t ntimeroll, zerobits;\n\t\n\tif (unlikely(!devstate->requested))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Attempt to queue work while none requested; rejecting\", dev->dev_repr);\n\t\tcointerra_set_queue_full(dev, true);\n\t\treturn false;\n\t}\n\t\n\ttimer_set_now(&tv_now);\n\ttimer_set_delay(&tv_latest, &tv_now, cointerra_latest_result_usecs);\n\tntimeroll = max(0, work_ntime_range(work, &tv_now, &tv_latest, cointerra_desired_roll));\n\t\n\tif (unlikely(!devstate->work_id))\n\t\t++devstate->work_id;\n\twork->device_id = devstate->work_id;\n\t\n\tpk_u16be(buf, 0, work->device_id);\n\twork->subid = htobe16(work->device_id);\n\tswap32yes(&buf[   6],  work->midstate  , 0x20 / 4);\n\tswap32yes(&buf[0x26], &work->data[0x40],  0xc / 4);\n\t\n\tpk_u16le(buf, 50, ntimeroll);\n\t\n\t// Use the real share difficulty up to cointerra_max_nonce_diff\n\tif (work->work_difficulty >= cointerra_max_nonce_diff)\n\t\twork->nonce_diff = cointerra_max_nonce_diff;\n\telse\n\t\twork->nonce_diff = work->work_difficulty;\n\tzerobits = log2(floor(work->nonce_diff));\n\twork->nonce_diff = pow(2, zerobits);\n\tzerobits += 0x20;\n\tpk_u16le(buf, 52, zerobits);\n\t\n\tif (!cointerra_write_msg(devstate->ep, cointerra_drv.dname, CMTO_WORK, buf))\n\t\treturn false;\n\t\n// \tHASH_ADD_INT(master_thr->work, device_id, work);\n\t{\n\t\t++dev->queued_count;\n\t\ttimer_set_now(&work->tv_work_start);\n\t\tHASH_ADD_INT(dev->queued_work, id, work);\n\t}\n\t++devstate->work_id;\n\tif (!--devstate->requested)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Sent all requested works, queue full\", dev->dev_repr);\n\t\tcointerra_set_queue_full(dev, true);\n\t}\n\t\n\treturn true;\n}\n\nstatic\nvoid cointerra_queue_flush(struct thr_info * const thr)\n{\n}\n\nstatic void cta_send_reset(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t   uint8_t reset_type, uint8_t diffbits)\n{\n\tchar buf[CTA_MSG_SIZE];\n\tint ret, retries = 0;\n\n\t/* Clear any accumulated messages in case we've gotten out of sync. */\n\tnotifier_reset(info->reset_notifier);\nresend:\n\tcta_gen_message(buf, CTA_SEND_RESET);\n\n\tbuf[CTA_RESET_TYPE] = reset_type;\n\tbuf[CTA_RESET_LOAD] = info->set_load ?: 255;\n\tbuf[CTA_RESET_PSLOAD] = 0;\n\n\tapplog(LOG_INFO, \"%s %d: Sending Reset type %u with diffbits %u\", cointerra->drv->name,\n\t       cointerra->device_id, reset_type, diffbits);\n\tcta_send_msg(cointerra, buf);\n\n\t/* Wait for read thread to parse a reset message and signal us we may\n\t * return to submitting other messages. Use a timeout in case we have\n\t * a problem and the reset done message never returns. */\n\tif (reset_type == CTA_RESET_NEW) {\n\t\tret = notifier_wait_us(info->reset_notifier, CTA_RESET_TIMEOUT * 1000);\n\t\tif (ret) {\n\t\t\tif (++retries < 3) {\n\t\t\t\tapplog(LOG_INFO, \"%s %d: Timed out waiting for reset done msg, retrying\",\n\t\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t\t\tgoto resend;\n\t\t\t}\n\t\t\tapplog(LOG_WARNING, \"%s %d: Timed out waiting for reset done msg\",\n\t\t\t       cointerra->drv->name, cointerra->device_id);\n\t\t}\n\t\t/* Good place to flush any work we have */\n\t\tflush_queue(cointerra);\n\t}\n}\n\nstatic void cta_update_work(struct cgpu_info *);\n\nstatic void cta_flush_work(struct cgpu_info *cointerra)\n{\n\tstruct cointerra_info *info = cointerra->device_data;\n\n\tif (1)\n\t\tcta_update_work(cointerra);\n\telse\n\t{\n\tapplog(LOG_INFO, \"%s %d: cta_flush_work %d\", cointerra->drv->name, cointerra->device_id,\n\t       __LINE__);\n\tcta_send_reset(cointerra, info, CTA_RESET_NEW, 0);\n\t}\n\tinfo->thr->work_restart = false;\n}\n\nstatic void cta_update_work(struct cgpu_info *cointerra)\n{\n\tstruct cointerra_info *info = cointerra->device_data;\n\n\tapplog(LOG_INFO, \"%s %d: Update work\", cointerra->drv->name, cointerra->device_id);\n\tcta_send_reset(cointerra, info, CTA_RESET_UPDATE, 0);\n}\n\nstatic void cta_zero_corehashes(struct cointerra_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < CTA_CORES; i++)\n\t\tinfo->tot_core_hashes[i] = 0;\n\tcgtime(&info->core_hash_start);\n}\n\n/* Send per core hashrate calculations at regular intervals ~every 5 minutes */\nstatic void cta_send_corehashes(struct cgpu_info *cointerra, struct cointerra_info *info,\n\t\t\t\tdouble corehash_time)\n{\n\tuint16_t core_ghs[CTA_CORES];\n\tdouble k[CTA_CORES];\n\tchar buf[CTA_MSG_SIZE];\n\tint i, offset;\n\n\tfor (i = 0; i < CTA_CORES; i++) {\n\t\tk[i] = (double)info->tot_core_hashes[i] / ((double)32 * (double)0x100000000ull);\n\t\tk[i] = sqrt(k[i]) + 1;\n\t\tk[i] *= k[i];\n\t\tk[i] = k[i] * 32 * ((double)0x100000000ull / (double)1000000000) / corehash_time;\n\t\tcore_ghs[i] = k[i];\n\t}\n\tcta_gen_message(buf, CTA_SEND_COREHASHRATE);\n\toffset = CTA_CORE_HASHRATES;\n\tfor (i = 0; i < CTA_CORES; i++) {\n\t\tmsg_from_hu16(buf, offset, core_ghs[i]);\n\t\toffset += 2; // uint16_t\n\t}\n\tcta_send_msg(cointerra, buf);\n}\n\nstatic void cta_scanwork(struct thr_info *thr)\n{\n\tstruct cgpu_info *cointerra = thr->cgpu;\n\tstruct cointerra_info *info = cointerra->device_data;\n\tdouble corehash_time;\n\tstruct timeval now;\n\n\tcgtime(&now);\n\n\tif (unlikely(thr->work_restart)) {\n\t\tapplog(LOG_INFO, \"%s %d: Flush work line %d\",\n\t\t     cointerra->drv->name, cointerra->device_id,__LINE__);\n\t\tcta_flush_work(cointerra);\n\t} else {\n\t\ttime_t now_t;\n\t\tint i;\n\n\t\t/* Discard work that was started more than 5 minutes ago as\n\t\t * a safety precaution backup in case the hardware failed to\n\t\t * return a work done message for some work items. */\n\t\tage_queued_work(cointerra, 300.0);\n\n\t\t/* Each core should be 1.7MH so at max diff of 32 should\n\t\t * average a share every ~80 seconds.Use this opportunity to\n\t\t * unset the bits in any pipes that have not returned a valid\n\t\t * nonce for over 30 full nonce ranges or 2400s. */\n\t\tnow_t = time(NULL);\n\t\tfor (i = 0; i < 1024; i++) {\n\t\t\tif (unlikely(now_t > info->last_pipe_nonce[i] + 2400)) {\n\t\t\t\tint bitchar = i / 8, bitbit = i % 8;\n\n\t\t\t\tinfo->pipe_bitmap[bitchar] &= ~(0x80 >> bitbit);\n\t\t\t}\n\t\t}\n\n\t\t/* Sleep for up to 0.5 seconds, waking if we need work or\n\t\t * have received a restart message. */\n\t\tcta_recv_thread(thr);\n\n\t\tif (thr->work_restart) {\n\t\t\tapplog(LOG_INFO, \"%s %d: Flush work line %d\",\n\t\t\t       cointerra->drv->name, cointerra->device_id,__LINE__);\n\t\t\tcta_flush_work(cointerra);\n\t\t}\n\t}\n\n\tcorehash_time = tdiff(&now, &info->core_hash_start);\n\tif (corehash_time > 300) {\n\t\tcta_send_corehashes(cointerra, info, corehash_time);\n\t\tcta_zero_corehashes(info);\n\t}\n\n\tmutex_lock(&info->lock);\n\tinfo->tot_share_hashes += info->share_hashes;\n\tinfo->tot_calc_hashes += info->hashes;\n\tinfo->hashes = info->share_hashes = 0;\n\tmutex_unlock(&info->lock);\n}\n\nstatic void cta_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *cointerra = thr->cgpu;\n\n\tcta_close(cointerra);\n}\n\nstatic void cta_zero_stats(struct cgpu_info *cointerra)\n{\n\tstruct cointerra_info *info = cointerra->device_data;\n\n\tinfo->tot_calc_hashes = 0;\n\tinfo->tot_reset_hashes = info->tot_hashes;\n\tinfo->tot_share_hashes = 0;\n\tcta_zero_corehashes(info);\n}\n\nstatic int bits_set(char v)\n{\n\tint c;\n\n\tfor (c = 0; v; c++)\n\t\tv &= v - 1;\n\treturn c;\n}\n\nstatic struct api_data *cta_api_stats(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\tstruct cointerra_info *info = cgpu->device_data;\n\tdouble dev_runtime = cgpu_runtime(cgpu);\n\tint i, asic, core, coreno = 0;\n\tstruct timeval now;\n\tchar bitmaphex[36];\n\tuint64_t ghs, val;\n\tchar buf[64];\n\n\tasic = cgpu->proc_id / 480;\n\tint coreabs = cgpu->proc_id / 120;\n\tcore = coreabs % 4;\n\t\n\t/* Info data */\n\troot = api_add_uint16(root, \"HW Revision\", &info->hwrev, false);\n\troot = api_add_uint32(root, \"Serial\", &info->serial, false);\n\troot = api_add_uint8(root, \"Asics\", &info->asics, false);\n\troot = api_add_uint8(root, \"Dies\", &info->dies, false);\n\troot = api_add_uint16(root, \"Cores\", &info->cores, false);\n\troot = api_add_uint8(root, \"Board number\", &info->board_number, false);\n\tsprintf(buf, \"%u.%u.%u\", info->fwrev[0], info->fwrev[1], info->fwrev[2]);\n\troot = api_add_string(root, \"FW Revision\", buf, true);\n\tsprintf(buf, \"%04u-%02u-%02u\", info->fw_year, info->fw_month, info->fw_day);\n\troot = api_add_string(root, \"FW Date\", buf, true);\n\troot = api_add_uint8(root, \"Init diffbits\", &info->init_diffbits, false);\n\troot = api_add_uint8(root, \"Min diffbits\", &info->min_diffbits, false);\n\troot = api_add_uint8(root, \"Max diffbits\", &info->max_diffbits, false);\n\n\t/* Status readings */\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"CoreTemp%d\", i);\n\t\troot = api_add_int16(root, buf, &info->coretemp[i], false);\n\t}\n\troot = api_add_int16(root, \"Ambient Low\", &info->ambtemp_low, false);\n\troot = api_add_int16(root, \"Ambient Avg\", &info->ambtemp_avg, false);\n\troot = api_add_int16(root, \"Ambient High\", &info->ambtemp_high, false);\n\tfor (i = 0; i < CTA_PUMPS; i++) {\n\t\tsprintf(buf, \"PumpRPM%d\", i);\n\t\troot = api_add_uint16(root, buf, &info->pump_tachs[i], false);\n\t}\n\tfor (i = 0; i < CTA_FANS; i++) {\n\t\tsprintf(buf, \"FanRPM%d\", i);\n\t\troot = api_add_uint16(root, buf, &info->fan_tachs[i], false);\n\t}\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"CoreFreqs%d\", i);\n\t\troot = api_add_uint16(root, buf, &info->corefreqs[i], false);\n\t}\n\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"CoreVolts%d\", i);\n\t\troot = api_add_uint16(root, buf, &info->corevolts[i], false);\n\t}\n\troot = api_add_uint16(root, \"Volts3.3\", &info->volts33, false);\n\troot = api_add_uint16(root, \"Volts12\", &info->volts12, false);\n\troot = api_add_uint16(root, \"Inactive\", &info->inactive, false);\n\troot = api_add_uint16(root, \"Active\", &info->active, false);\n\n\t/* Status settings */\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"CorePerfMode%d\", i);\n\t\troot = api_add_uint8(root, buf, &info->coreperf[i], false);\n\t}\n\tfor (i = 0; i < CTA_FANS; i++) {\n\t\tsprintf(buf, \"FanSpeed%d\", i);\n\t\troot = api_add_uint8(root, buf, &info->fanspeed[i], false);\n\t}\n\troot = api_add_uint8(root, \"DiesActive\", &info->dies_active, false);\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"PipesEnabled%d\", i);\n\t\troot = api_add_uint8(root, buf, &info->pipes_enabled[i], false);\n\t}\n\n\t/* Status debug */\n\troot = api_add_int(root, \"Underruns\", &info->tot_underruns, false);\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"HWErrors%d\", i);\n\t\troot = api_add_uint16(root, buf, &info->tot_hw_errors[i], false);\n\t}\n\tghs = info->tot_calc_hashes / dev_runtime;\n\troot = api_add_uint64(root, \"Calc hashrate\", &ghs, true);\n\tghs = (info->tot_hashes - info->tot_reset_hashes) / dev_runtime;\n\troot = api_add_uint64(root, \"Hashrate\", &ghs, true);\n\tghs = info->tot_share_hashes / dev_runtime;\n\troot = api_add_uint64(root, \"Share hashrate\", &ghs, true);\n\troot = api_add_uint64(root, \"Total calc hashes\", &info->tot_calc_hashes, false);\n\tghs = info->tot_hashes - info->tot_reset_hashes;\n\troot = api_add_uint64(root, \"Total hashes\", &ghs, true);\n\troot = api_add_uint64(root, \"Total raw hashes\", &info->tot_hashes, false);\n\troot = api_add_uint64(root, \"Total share hashes\", &info->tot_share_hashes, false);\n\troot = api_add_uint64(root, \"Total flushed hashes\", &info->tot_flushed_hashes, false);\n\tval = cgpu->diff_accepted * 0x100000000ull;\n\troot = api_add_uint64(root, \"Accepted hashes\", &val, true);\n\tghs = val / dev_runtime;\n\troot = api_add_uint64(root, \"Accepted hashrate\", &ghs, true);\n\tval = cgpu->diff_rejected * 0x100000000ull;\n\troot = api_add_uint64(root, \"Rejected hashes\", &val, true);\n\tghs = val / dev_runtime;\n\troot = api_add_uint64(root, \"Rejected hashrate\", &ghs, true);\n\n\tcgtime(&now);\n\tdev_runtime = tdiff(&now, &info->core_hash_start);\n\tif (dev_runtime < 1)\n\t\tdev_runtime = 1;\n\t{\n\t\ti = coreabs;\n\t\tsprintf(buf, \"Core%d hashrate\", i);\n\t\tghs = info->tot_core_hashes[i] / dev_runtime;\n\t\troot = api_add_uint64(root, buf, &ghs, true);\n\t}\n\troot = api_add_uint32(root, \"Uptime\",&info->uptime,false);\n\t{\n\t\t\tchar bitmapcount[40], asiccore[12];\n\t\t\tint count = 0;\n\n\t\t\tsprintf(asiccore, \"Asic%dCore%d\", asic, core);\n\t\t\tbin2hex(bitmaphex, &info->pipe_bitmap[coreno], 16);\n\t\t\tfor (i = coreno; i < coreno + 16; i++)\n\t\t\t\tcount += bits_set(info->pipe_bitmap[i]);\n\t\t\tsnprintf(bitmapcount, 40, \"%d:%s\", count, bitmaphex);\n\t\t\troot = api_add_string(root, asiccore, bitmapcount, true);\n\t\t\tcoreno += 16;\n\t}\n\troot = api_add_uint8(root, \"AV\", &info->autovoltage, false);\n\troot = api_add_uint8(root, \"Power Supply Percent\", &info->current_ps_percent, false);\n\troot = api_add_uint16(root, \"Power Used\", &info->power_used, false);\n\troot = api_add_uint16(root, \"IOUT\", &info->power_used, false);\n\troot = api_add_uint16(root, \"VOUT\", &info->power_voltage, false);\n\troot = api_add_uint16(root, \"IIN\", &info->ipower_used, false);\n\troot = api_add_uint16(root, \"VIN\", &info->ipower_voltage, false);\n\troot = api_add_uint16(root, \"PSTemp1\", &info->power_temps[0], false);\n\troot = api_add_uint16(root, \"PSTemp2\", &info->power_temps[1], false);\n\n\treturn root;\n}\n\nstatic\nconst char *cointerra_set_load(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success)\n{\n\tstruct cointerra_info * const devstate = proc->device_data;\n\t\n\tconst int nv = atoi(newvalue);\n\tif (nv <= 0 || nv > 0xff)\n\t\treturn \"Invalid power stepping value\";\n\t\n\tdevstate->set_load = nv;\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition cointerra_set_device_funcs[] = {\n\t{\"load\", cointerra_set_load, \"power stepping (1-255)\"},\n\t{NULL},\n};\n\nstruct device_drv cointerra_drv = {\n\t.dname = \"cointerra\",\n\t.name = \"CTA\",\n\t.lowl_match = cointerra_lowl_match,\n\t.lowl_probe = cointerra_lowl_probe,\n\t.thread_init = cta_prepare,\n\t.minerloop = minerloop_queue,\n\t.queue_append = cointerra_queue_append,\n\t.queue_flush = cointerra_queue_flush,\n\t// TODO .update_work = cta_update_work,\n\t.poll = cta_scanwork,\n\t.get_api_stats = cta_api_stats,\n\t.thread_shutdown = cta_shutdown,\n\t.zero_stats = cta_zero_stats,\n};\n"
        },
        {
          "name": "driver-cointerra.h",
          "type": "blob",
          "size": 5.271484375,
          "content": "/*\n * Copyright 2013-2014 Con Kolivas\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef COINTERRA_H\n#define COINTERRA_H\n\n#define CTA_READBUF_SIZE 8192\n#define CTA_MSG_SIZE 64\n#define CTA_READ_TIMEOUT 1\n#define CTA_READ_INTERVAL 100\n#define CTA_SCAN_INTERVAL 500\n#define CTA_RESET_TIMEOUT 1000\n\n#define CTA_INIT_DIFF\t\t32\n\n#if 0\n/* FIXME: how big should this be? */\n#define CTA_MAX_QUEUE 2300\n#else\n#define CTA_MAX_QUEUE (32 / CTA_NROLL_TIME)\n#endif\n\n#define CTA_NROLL_TIME 2\n\n/* Offsets into buffer */\n#define CTA_MSG_TYPE\t\t2\n#define CTA_RESET_TYPE\t\t3\n#define CTA_RESET_DIFF\t\t4\n#define CTA_RESET_LOAD\t\t5\n#define CTA_RESET_PSLOAD\t6\n#define CTA_DRIVER_TAG\t\t3\n#define CTA_MCU_TAG\t\t5\n#define CTA_MCU_CORE\t\t5\n#define CTA_MCU_ASIC\t\t6\n#define CTA_MCU_PIPE\t\t8\n#define CTA_MATCH_NOFFSET\t45\n#define CTA_MATCH_NONCE\t\t60\n#define CTA_WDONE_NONCES\t11\n#define CTA_MSG_RECVD\t\t3\n#define CTA_WORK_MIDSTATE\t9\n#define CTA_WORK_DATA\t\t41\n#define CTA_WORK_NROLL\t\t53\n#define CTA_WORK_DIFFBITS\t55\n#define CTA_REQWORK_REQUESTS\t3\n#define CTA_CORE_HASHRATES\t3\n\n/* Received message types */\n#define CTA_RECV_UNUSED\t\t0\n#define CTA_RECV_REQWORK\t1\n#define CTA_RECV_MATCH\t\t2\n#define CTA_RECV_WDONE\t\t3\n#define CTA_RECV_STATREAD\t4\n#define CTA_RECV_STATSET\t5\n#define CTA_RECV_INFO\t\t6\n#define CTA_RECV_MSG            7\n#define CTA_RECV_RDONE\t\t8\n#define CTA_RECV_STATDEBUG\t10\n\n/* Sent message types */\n#define CTA_SEND_UNUSED\t\t0\n#define CTA_SEND_RESET\t\t1\n#define CTA_SEND_WORK\t\t2\n#define CTA_SEND_SETPERF\t3\n#define CTA_SEND_REQUEST\t4\n#define CTA_SEND_FMATCH\t\t5\n#define CTA_SEND_IDENTIFY\t6\n#define CTA_SEND_COREHASHRATE\t7\n\n/* Types of reset in CTA_RESET_TYPE */\n#define CTA_RESET_NONE\t\t0\n#define CTA_RESET_UPDATE\t1\n#define CTA_RESET_NEW\t\t2\n#define CTA_RESET_INIT\t\t3\n\n#define CTA_INFO_HWREV\t\t3\n#define CTA_INFO_SERNO\t\t5\n#define CTA_INFO_NUMASICS\t9\n#define CTA_INFO_NUMDIES\t10\n#define CTA_INFO_NUMCORES\t11\n#define CTA_INFO_BOARDNUMBER\t13\n#define CTA_INFO_FWREV_MAJ\t19\n#define CTA_INFO_FWREV_MIN\t20\n#define CTA_INFO_FWREV_MIC\t21\n#define CTA_INFO_FWDATE_YEAR\t23\n#define CTA_INFO_FWDATE_MONTH\t25\n#define CTA_INFO_FWDATE_DAY\t26\n#define CTA_INFO_INITDIFFBITS\t27\n#define CTA_INFO_MINDIFFBITS\t28\n#define CTA_INFO_MAXDIFFBITS\t29\n\n#define CTA_STAT_CORETEMPS\t3\n#define CTA_STAT_AMBTEMP_LOW\t19\n#define CTA_STAT_AMBTEMP_AVG\t21\n#define CTA_STAT_AMBTEMP_HIGH\t23\n#define CTA_STAT_PUMP_TACHS\t25\n#define CTA_STAT_FAN_TACHS\t29\n#define CTA_STAT_CORE_VOLTS\t37\n#define CTA_STAT_VOLTS33\t53\n#define CTA_STAT_VOLTS12\t55\n#define CTA_STAT_INACTIVE\t57\n#define CTA_STAT_ACTIVE\t\t59\n\n#define CTA_STAT_PERFMODE\t3\n#define CTA_STAT_FANSPEEDS\t11\n#define CTA_STAT_DIES_ACTIVE\t15\n#define CTA_STAT_PIPES_ENABLED\t16\n#define CTA_STAT_MIN_FAN_SPEED \t24\n#define CTA_STAT_UPTIME\t\t25\n#define CTA_STAT_HEARTBEATS\t29\n#define CTA_STAT_CORE_FREQS\t45\n\n#define CTA_STAT_UNDERRUNS\t3\n#define CTA_STAT_HW_ERRORS\t5\n#define CTA_STAT_UPTIME_MS\t21\n#define CTA_STAT_HASHES\t\t25\n#define CTA_STAT_FLUSHED_HASHES 33\n#define CTA_STAT_AUTOVOLTAGE\t41\n#define CTA_STAT_POWER_PERCENT\t42\n#define CTA_STAT_POWER_USED\t43\n#define CTA_STAT_VOLTAGE\t45\n#define CTA_STAT_IPOWER_USED\t47\n#define CTA_STAT_IVOLTAGE\t49\n#define CTA_STAT_PS_TEMP1\t51\n#define CTA_STAT_PS_TEMP2\t53\n\n\n#define CTA_CORES\t\t8\n#define CTA_PUMPS\t\t2\n#define CTA_FANS\t\t4\n\n#define CTA_REQ_MSGTYPE\t\t3\n#define CTA_REQ_INTERVAL\t5\n\n\nstruct cointerra_info {\n\tstruct libusb_device_handle *usbh;\n\tstruct lowl_usb_endpoint *ep;\n\tuint8_t set_load;\n\t\n\t/* Info data */\n\tuint16_t hwrev;\n\tuint32_t serial;\n\tuint8_t asics;\n\tuint8_t dies;\n\tuint16_t cores;\n\tuint8_t board_number;\n\tuint8_t fwrev[3];\n\tuint16_t fw_year;\n\tuint8_t fw_month;\n\tuint8_t fw_day;\n\tuint8_t init_diffbits;\n\tuint8_t min_diffbits;\n\tuint8_t max_diffbits;\n\n\t/* Status readings data */\n\tuint16_t coretemp[CTA_CORES];\n\tuint16_t ambtemp_low;\n\tuint16_t ambtemp_avg;\n\tuint16_t ambtemp_high;\n\tuint16_t pump_tachs[CTA_PUMPS];\n\tuint16_t fan_tachs[CTA_FANS];\n\tuint16_t corevolts[CTA_CORES];\n\tuint16_t volts33;\n\tuint16_t volts12;\n\tuint16_t inactive;\n\tuint16_t active;\n\tuint16_t corefreqs[CTA_CORES];\n\tuint32_t uptime;\n\n\t/* Status settings data */\n\tuint8_t coreperf[CTA_CORES];\n\tuint8_t fanspeed[CTA_FANS];\n\tuint8_t dies_active;\n\tuint8_t pipes_enabled[CTA_CORES];\n\n\t/* Status debug data */\n\tuint16_t underruns;\n\tuint16_t hw_errors[CTA_CORES];\n\n\t/* Running total from debug messages */\n\tint tot_underruns;\n\tuint16_t tot_hw_errors[CTA_CORES];\n\tuint64_t tot_hashes;\n\tuint64_t tot_reset_hashes;\n\tuint64_t tot_flushed_hashes;\n\tuint8_t  autovoltage;\n\tuint8_t  current_ps_percent;\n\tuint16_t power_used;\n\tuint16_t power_voltage;\n\tuint16_t ipower_used;\n\tuint16_t ipower_voltage;\n\tuint16_t power_temps[2];\n\n\tbool autovoltage_complete;\n\n\t/* Calculated totals based on work done and nonces found */\n\tuint64_t hashes;\n\tuint64_t tot_calc_hashes;\n\n\t/* Calculated totals based on shares returned */\n\tuint64_t share_hashes;\n\tuint64_t tot_core_hashes[CTA_CORES];\n\tuint64_t tot_share_hashes;\n\tstruct timeval core_hash_start;\n\tint requested;\n\tuint16_t work_id;\n\tint no_matching_work;\n\ttime_t last_pipe_nonce[1024];\n\tunsigned char pipe_bitmap[128];\n\n\tstruct thr_info *thr;\n\tpthread_mutex_t lock;\n\tpthread_mutex_t sendlock;\n\tnotifier_t reset_notifier;\n};\n\n#endif /* COINTERRA_H */\n"
        },
        {
          "name": "driver-cpu.c",
          "type": "blob",
          "size": 20.6953125,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2011-2014 Luke Dashjr\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <signal.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#ifndef WIN32\n#include <sys/wait.h>\n#include <sys/resource.h>\n#endif\n#include <libgen.h>\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"miner.h\"\n#include \"logging.h\"\n#include \"util.h\"\n#include \"driver-cpu.h\"\n\n#if defined(unix)\n\t#include <errno.h>\n\t#include <fcntl.h>\n#endif\n\nBFG_REGISTER_DRIVER(cpu_drv)\n\nstruct cgpu_info *cpus;\n\n#if defined(__linux) && defined(CPU_ZERO)  /* Linux specific policy and affinity management */\n#include <sched.h>\nstatic inline void drop_policy(void)\n{\n\tstruct sched_param param;\n\tparam.sched_priority = 0;\n\n#ifdef SCHED_BATCH\n#ifdef SCHED_IDLE\n\tif (unlikely(sched_setscheduler(0, SCHED_IDLE, &param) == -1))\n#endif\n\t\tsched_setscheduler(0, SCHED_BATCH, &param);\n#endif\n}\n\nstatic inline void affine_to_cpu(int id, int cpu)\n{\n\tcpu_set_t set;\n\n\tCPU_ZERO(&set);\n\tCPU_SET(cpu, &set);\n\tsched_setaffinity(0, sizeof(set), &set);\n\tapplog(LOG_INFO, \"Binding cpu mining thread %d to cpu %d\", id, cpu);\n}\n#else\nstatic inline void drop_policy(void)\n{\n}\n\nstatic inline void affine_to_cpu(int __maybe_unused id, int __maybe_unused cpu)\n{\n}\n#endif\n\n\n\n/* TODO: resolve externals */\nextern char *set_int_range(const char *arg, int *i, int min, int max);\nextern int dev_from_id(int thr_id);\n\n\n/* chipset-optimized hash functions */\ntypedef bool (*sha256_func)(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\n\nextern bool ScanHash_4WaySSE2(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool ScanHash_altivec_4way(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_via(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_c(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_cryptopp(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_asm32(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_sse2_64(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_sse4_64(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_sse2_32(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\nextern bool scanhash_scrypt(struct thr_info *, struct work *, uint32_t max_nonce, uint32_t *last_nonce, uint32_t nonce);\n\n\n#ifdef USE_SHA256D\nstatic size_t max_name_len = 0;\nstatic char *name_spaces_pad = NULL;\n#endif\n\nconst char *algo_names[] = {\n#ifdef USE_SHA256D\n\t[ALGO_C]\t\t= \"c\",\n#ifdef WANT_SSE2_4WAY\n\t[ALGO_4WAY]\t\t= \"4way\",\n#endif\n#ifdef WANT_VIA_PADLOCK\n\t[ALGO_VIA]\t\t= \"via\",\n#endif\n\t[ALGO_CRYPTOPP]\t\t= \"cryptopp\",\n#ifdef WANT_CRYPTOPP_ASM32\n\t[ALGO_CRYPTOPP_ASM32]\t= \"cryptopp_asm32\",\n#endif\n#ifdef WANT_X8632_SSE2\n\t[ALGO_SSE2_32]\t\t= \"sse2_32\",\n#endif\n#ifdef WANT_X8664_SSE2\n\t[ALGO_SSE2_64]\t\t= \"sse2_64\",\n#endif\n#ifdef WANT_X8664_SSE4\n\t[ALGO_SSE4_64]\t\t= \"sse4_64\",\n#endif\n#ifdef WANT_ALTIVEC_4WAY\n    [ALGO_ALTIVEC_4WAY] = \"altivec_4way\",\n#endif\n#endif\n#ifdef WANT_SCRYPT\n    [ALGO_SCRYPT] = \"scrypt\",\n#endif\n#ifdef USE_SHA256D\n\t[ALGO_FASTAUTO] = \"fastauto\",\n\t[ALGO_AUTO] = \"auto\",\n#endif\n};\n\n#ifdef USE_SHA256D\nstatic const sha256_func sha256_funcs[] = {\n\t[ALGO_C]\t\t= (sha256_func)scanhash_c,\n#ifdef WANT_SSE2_4WAY\n\t[ALGO_4WAY]\t\t= (sha256_func)ScanHash_4WaySSE2,\n#endif\n#ifdef WANT_ALTIVEC_4WAY\n    [ALGO_ALTIVEC_4WAY] = (sha256_func) ScanHash_altivec_4way,\n#endif\n#ifdef WANT_VIA_PADLOCK\n\t[ALGO_VIA]\t\t= (sha256_func)scanhash_via,\n#endif\n\t[ALGO_CRYPTOPP]\t\t=  (sha256_func)scanhash_cryptopp,\n#ifdef WANT_CRYPTOPP_ASM32\n\t[ALGO_CRYPTOPP_ASM32]\t= (sha256_func)scanhash_asm32,\n#endif\n#ifdef WANT_X8632_SSE2\n\t[ALGO_SSE2_32]\t\t= (sha256_func)scanhash_sse2_32,\n#endif\n#ifdef WANT_X8664_SSE2\n\t[ALGO_SSE2_64]\t\t= (sha256_func)scanhash_sse2_64,\n#endif\n#ifdef WANT_X8664_SSE4\n\t[ALGO_SSE4_64]\t\t= (sha256_func)scanhash_sse4_64,\n#endif\n};\n#endif\n\n#ifdef USE_SHA256D\nenum sha256_algos opt_algo = ALGO_FASTAUTO;\n#endif\n\nstatic bool forced_n_threads;\n\n#ifdef USE_SHA256D\nconst uint32_t hash1_init[] = {\n\t0,0,0,0,0,0,0,0,\n\t0x80000000,\n\t  0,0,0,0,0,0,\n\t          0x100,\n};\n\n\n// Algo benchmark, crash-prone, system independent stage\ndouble bench_algo_stage3(\n\tenum sha256_algos algo\n)\n{\n\tstruct work work __attribute__((aligned(128)));\n\n\tget_benchmark_work(&work, false);\n\n\tstatic struct thr_info dummy;\n\n\tstruct timeval end;\n\tstruct timeval start;\n\tuint32_t max_nonce = opt_algo == ALGO_FASTAUTO ? (1<<8) : (1<<22);\n\tuint32_t last_nonce = 0;\n\n\ttimer_set_now(&start);\n\t\t\t{\n\t\t\t\tsha256_func func = sha256_funcs[algo];\n\t\t\t\t(*func)(\n\t\t\t\t\t&dummy,\n\t\t\t\t\t&work,\n\t\t\t\t\tmax_nonce,\n\t\t\t\t\t&last_nonce,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t}\n\ttimer_set_now(&end);\n\n\tuint64_t usec_end = ((uint64_t)end.tv_sec)*1000*1000 + end.tv_usec;\n\tuint64_t usec_start = ((uint64_t)start.tv_sec)*1000*1000 + start.tv_usec;\n\tuint64_t usec_elapsed = usec_end - usec_start;\n\n\tdouble rate = -1.0;\n\tif (0<usec_elapsed) {\n\t\trate = (1.0*(last_nonce+1))/usec_elapsed;\n\t}\n\treturn rate;\n}\n\n#if defined(unix)\n\n\t// Change non-blocking status on a file descriptor\n\tstatic void set_non_blocking(\n\t\tint fd,\n\t\tint yes\n\t)\n\t{\n\t\tint flags = fcntl(fd, F_GETFL, 0);\n\t\tif (flags<0) {\n\t\t\tperror(\"fcntl(GET) failed\");\n\t\t\texit(1);\n\t\t}\n\t\tflags = yes ? (flags|O_NONBLOCK) : (flags&~O_NONBLOCK);\n\n\t\tint r = fcntl(fd, F_SETFL, flags);\n\t\tif (r<0) {\n\t\t\tperror(\"fcntl(SET) failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n#endif // defined(unix)\n\n// Algo benchmark, crash-safe, system-dependent stage\nstatic double bench_algo_stage2(\n\tenum sha256_algos algo\n)\n{\n\t// Here, the gig is to safely run a piece of code that potentially\n\t// crashes. Unfortunately, the Right Way (tm) to do this is rather\n\t// heavily platform dependent :(\n\n\tdouble rate = -1.23457;\n\n\t#if defined(unix)\n\n\t\t// Make a pipe: [readFD, writeFD]\n\t\tint pfd[2];\n\t\tint r = pipe(pfd);\n\t\tif (r<0) {\n\t\t\tperror(\"pipe - failed to create pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Make pipe non blocking\n\t\tset_non_blocking(pfd[0], 1);\n\t\tset_non_blocking(pfd[1], 1);\n\n\t\t// Don't allow a crashing child to kill the main process\n\t\tsighandler_t sr0 = signal(SIGPIPE, SIG_IGN);\n\t\tsighandler_t sr1 = signal(SIGPIPE, SIG_IGN);\n\t\tif (SIG_ERR==sr0 || SIG_ERR==sr1) {\n\t\t\tperror(\"signal - failed to edit signal mask for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Fork a child to do the actual benchmarking\n\t\tpid_t child_pid = fork();\n\t\tif (child_pid<0) {\n\t\t\tperror(\"fork - failed to create a child process for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Do the dangerous work in the child, knowing we might crash\n\t\tif (0==child_pid) {\n\n\t\t\t// TODO: some umask trickery to prevent coredumps\n\n\t\t\t// Benchmark this algorithm\n\t\t\tdouble r = bench_algo_stage3(algo);\n\n\t\t\t// We survived, send result to parent and bail\n\t\t\tint loop_count = 0;\n\t\t\twhile (1) {\n\t\t\t\tssize_t bytes_written = write(pfd[1], &r, sizeof(r));\n\t\t\t\tint try_again = (0==bytes_written || (bytes_written<0 && EAGAIN==errno));\n\t\t\t\tint success = (sizeof(r)==(size_t)bytes_written);\n\n\t\t\t\tif (success)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!try_again) {\n\t\t\t\t\tperror(\"write - child failed to write benchmark result to pipe\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (5<loop_count) {\n\t\t\t\t\tapplog(LOG_ERR, \"child tried %d times to communicate with parent, giving up\", loop_count);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t++loop_count;\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t// Parent waits for a result from child\n\t\tint loop_count = 0;\n\t\twhile (1) {\n\n\t\t\t// Wait for child to die\n\t\t\tint status;\n\t\t\tint r = waitpid(child_pid, &status, WNOHANG);\n\t\t\tif ((child_pid==r) || (r<0 && ECHILD==errno)) {\n\n\t\t\t\t// Child died somehow. Grab result and bail\n\t\t\t\tdouble tmp;\n\t\t\t\tssize_t bytes_read = read(pfd[0], &tmp, sizeof(tmp));\n\t\t\t\tif (sizeof(tmp)==(size_t)bytes_read)\n\t\t\t\t\trate = tmp;\n\t\t\t\tbreak;\n\n\t\t\t} else if (r<0) {\n\t\t\t\tperror(\"bench_algo: waitpid failed. giving up.\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// Give up on child after a ~60s\n\t\t\tif (60<loop_count) {\n\t\t\t\tkill(child_pid, SIGKILL);\n\t\t\t\twaitpid(child_pid, &status, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Wait a bit longer\n\t\t\t++loop_count;\n\t\t\tsleep(1);\n\t\t}\n\n\t\t// Close pipe\n\t\tr = close(pfd[0]);\n\t\tif (r<0) {\n\t\t\tperror(\"close - failed to close read end of pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\t\tr = close(pfd[1]);\n\t\tif (r<0) {\n\t\t\tperror(\"close - failed to close read end of pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t#elif defined(WIN32)\n\n\t\t// Get handle to current exe\n\t\tHINSTANCE module = GetModuleHandle(0);\n\t\tif (!module) {\n\t\t\tapplog(LOG_ERR, \"failed to retrieve module handle\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Create a unique name\n\t\tchar unique_name[33];\n\t\tsnprintf(\n\t\t\tunique_name,\n\t\t\tsizeof(unique_name)-1,\n\t\t\t\"bfgminer-%p\",\n\t\t\t(void*)module\n\t\t);\n\n\t\t// Create and init a chunked of shared memory\n\t\tHANDLE map_handle = CreateFileMapping(\n\t\t\tINVALID_HANDLE_VALUE,   // use paging file\n\t\t\tNULL,                   // default security attributes\n\t\t\tPAGE_READWRITE,         // read/write access\n\t\t\t0,                      // size: high 32-bits\n\t\t\t4096,\t\t\t// size: low 32-bits\n\t\t\tunique_name\t\t// name of map object\n\t\t);\n\t\tif (NULL==map_handle) {\n\t\t\tapplog(LOG_ERR, \"could not create shared memory\");\n\t\t\texit(1);\n\t\t}\n\n\t\tvoid *shared_mem = MapViewOfFile(\n\t\t\tmap_handle,\t// object to map view of\n\t\t\tFILE_MAP_WRITE, // read/write access\n\t\t\t0,              // high offset:  map from\n\t\t\t0,              // low offset:   beginning\n\t\t\t0\t\t// default: map entire file\n\t\t);\n\t\tif (NULL==shared_mem) {\n\t\t\tapplog(LOG_ERR, \"could not map shared memory\");\n\t\t\texit(1);\n\t\t}\n\t\tSetEnvironmentVariable(\"BFGMINER_SHARED_MEM\", unique_name);\n\t\tCopyMemory(shared_mem, &rate, sizeof(rate));\n\n\t\t// Get path to current exe\n\t\tchar cmd_line[256 + MAX_PATH];\n\t\tconst size_t n = sizeof(cmd_line)-200;\n\t\tDWORD size = GetModuleFileName(module, cmd_line, n);\n\t\tif (0==size) {\n\t\t\tapplog(LOG_ERR, \"failed to retrieve module path\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Construct new command line based on that\n\t\tchar buf[0x20];\n\t\tsnprintf(buf, sizeof(buf), \"%d\", algo);\n\t\tSetEnvironmentVariable(\"BFGMINER_BENCH_ALGO\", buf);\n\n\t\t// Launch a debug copy of BFGMiner\n\t\tSTARTUPINFO startup_info;\n\t\tPROCESS_INFORMATION process_info;\n\t\tZeroMemory(&startup_info, sizeof(startup_info));\n\t\tZeroMemory(&process_info, sizeof(process_info));\n\t\tstartup_info.cb = sizeof(startup_info);\n\n\t\tBOOL ok = CreateProcess(\n\t\t\tNULL,\t\t\t// No module name (use command line)\n\t\t\tcmd_line,\t\t// Command line\n\t\t\tNULL,\t\t\t// Process handle not inheritable\n\t\t\tNULL,\t\t\t// Thread handle not inheritable\n\t\t\tFALSE,\t\t\t// Set handle inheritance to FALSE\n\t\t\tDEBUG_ONLY_THIS_PROCESS,// We're going to debug the child\n\t\t\tNULL,\t\t\t// Use parent's environment block\n\t\t\tNULL,\t\t\t// Use parent's starting directory\n\t\t\t&startup_info,\t\t// Pointer to STARTUPINFO structure\n\t\t\t&process_info\t\t// Pointer to PROCESS_INFORMATION structure\n\t\t);\n\t\tif (!ok) {\n\t\t\tapplog(LOG_ERR, \"CreateProcess failed with error %ld\\n\", (long)GetLastError() );\n\t\t\texit(1);\n\t\t}\n\n\t\t// Debug the child (only clean way to catch exceptions)\n\t\twhile (1) {\n\n\t\t\t// Wait for child to do something\n\t\t\tDEBUG_EVENT debug_event;\n\t\t\tZeroMemory(&debug_event, sizeof(debug_event));\n\n\t\t\tBOOL ok = WaitForDebugEvent(&debug_event, 60 * 1000);\n\t\t\tif (!ok)\n\t\t\t\tbreak;\n\n\t\t\t// Decide if event is \"normal\"\n\t\t\tint go_on =\n\t\t\t\tCREATE_PROCESS_DEBUG_EVENT== debug_event.dwDebugEventCode\t||\n\t\t\t\tCREATE_THREAD_DEBUG_EVENT == debug_event.dwDebugEventCode\t||\n\t\t\t\tEXIT_THREAD_DEBUG_EVENT   == debug_event.dwDebugEventCode\t||\n\t\t\t\tEXCEPTION_DEBUG_EVENT     == debug_event.dwDebugEventCode\t||\n\t\t\t\tLOAD_DLL_DEBUG_EVENT      == debug_event.dwDebugEventCode\t||\n\t\t\t\tOUTPUT_DEBUG_STRING_EVENT == debug_event.dwDebugEventCode\t||\n\t\t\t\tUNLOAD_DLL_DEBUG_EVENT    == debug_event.dwDebugEventCode;\n\t\t\tif (!go_on)\n\t\t\t\tbreak;\n\n\t\t\t// Some exceptions are also \"normal\", apparently.\n\t\t\tif (EXCEPTION_DEBUG_EVENT== debug_event.dwDebugEventCode) {\n\n\t\t\t\tint go_on =\n\t\t\t\t\tEXCEPTION_BREAKPOINT== debug_event.u.Exception.ExceptionRecord.ExceptionCode;\n\t\t\t\tif (!go_on)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If nothing unexpected happened, let child proceed\n\t\t\tContinueDebugEvent(\n\t\t\t\tdebug_event.dwProcessId,\n\t\t\t\tdebug_event.dwThreadId,\n\t\t\t\tDBG_CONTINUE\n\t\t\t);\n\t\t}\n\n\t\t// Clean up child process\n\t\tTerminateProcess(process_info.hProcess, 1);\n\t\tCloseHandle(process_info.hProcess);\n\t\tCloseHandle(process_info.hThread);\n\n\t\t// Reap return value and cleanup\n\t\tCopyMemory(&rate, shared_mem, sizeof(rate));\n\t\t(void)UnmapViewOfFile(shared_mem);\n\t\t(void)CloseHandle(map_handle);\n\n\t#else\n\n\t\t// Not linux, not unix, not WIN32 ... do our best\n\t\trate = bench_algo_stage3(algo);\n\n\t#endif // defined(unix)\n\n\t// Done\n\treturn rate;\n}\n\nstatic void bench_algo(\n\tdouble            *best_rate,\n\tenum sha256_algos *best_algo,\n\tenum sha256_algos algo\n)\n{\n\tsize_t n = max_name_len - strlen(algo_names[algo]);\n\tmemset(name_spaces_pad, ' ', n);\n\tname_spaces_pad[n] = 0;\n\n\tapplog(\n\t\tLOG_ERR,\n\t\t\"\\\"%s\\\"%s : benchmarking algorithm ...\",\n\t\talgo_names[algo],\n\t\tname_spaces_pad\n\t);\n\n\tdouble rate = bench_algo_stage2(algo);\n\tif (rate<0.0) {\n\t\tapplog(\n\t\t\tLOG_ERR,\n\t\t\t\"\\\"%s\\\"%s : algorithm fails on this platform\",\n\t\t\talgo_names[algo],\n\t\t\tname_spaces_pad\n\t\t);\n\t} else {\n\t\tapplog(\n\t\t\tLOG_ERR,\n\t\t\t\"\\\"%s\\\"%s : algorithm runs at %.5f MH/s\",\n\t\t\talgo_names[algo],\n\t\t\tname_spaces_pad,\n\t\t\trate\n\t\t);\n\t\tif (*best_rate<rate) {\n\t\t\t*best_rate = rate;\n\t\t\t*best_algo = algo;\n\t\t}\n\t}\n}\n\n// Figure out the longest algorithm name\nvoid init_max_name_len()\n{\n\tsize_t i;\n\tsize_t nb_names = sizeof(algo_names)/sizeof(algo_names[0]);\n\tfor (i=0; i<nb_names; ++i) {\n\t\tconst char *p = algo_names[i];\n\t\tsize_t name_len = p ? strlen(p) : 0;\n\t\tif (max_name_len<name_len)\n\t\t\tmax_name_len = name_len;\n\t}\n\n\tname_spaces_pad = (char*) malloc(max_name_len+16);\n\tif (0==name_spaces_pad) {\n\t\tperror(\"malloc failed\");\n\t\texit(1);\n\t}\n}\n\n// Pick the fastest CPU hasher\nstatic enum sha256_algos pick_fastest_algo()\n{\n\tdouble best_rate = -1.0;\n\tenum sha256_algos best_algo = 0;\n\tapplog(LOG_ERR, \"benchmarking all sha256 algorithms ...\");\n\n\tbench_algo(&best_rate, &best_algo, ALGO_C);\n\n\t#if defined(WANT_SSE2_4WAY)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_4WAY);\n\t#endif\n\n\t#if defined(WANT_VIA_PADLOCK)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_VIA);\n\t#endif\n\n\tbench_algo(&best_rate, &best_algo, ALGO_CRYPTOPP);\n\n\t#if defined(WANT_CRYPTOPP_ASM32)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_CRYPTOPP_ASM32);\n\t#endif\n\n\t#if defined(WANT_X8632_SSE2)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE2_32);\n\t#endif\n\n\t#if defined(WANT_X8664_SSE2)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE2_64);\n\t#endif\n\n\t#if defined(WANT_X8664_SSE4)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE4_64);\n\t#endif\n\n        #if defined(WANT_ALTIVEC_4WAY)\n                bench_algo(&best_rate, &best_algo, ALGO_ALTIVEC_4WAY);\n        #endif\n\n\tsize_t n = max_name_len - strlen(algo_names[best_algo]);\n\tmemset(name_spaces_pad, ' ', n);\n\tname_spaces_pad[n] = 0;\n\tapplog(\n\t\tLOG_ERR,\n\t\t\"\\\"%s\\\"%s : is fastest algorithm at %.5f MH/s\",\n\t\talgo_names[best_algo],\n\t\tname_spaces_pad,\n\t\tbest_rate\n\t);\n\treturn best_algo;\n}\n\nchar *set_algo(const char *arg, enum sha256_algos *algo)\n{\n\tenum sha256_algos i;\n\n\tfor (i = 0; i < ARRAY_SIZE(algo_names); i++) {\n\t\tif (algo_names[i] && !strcmp(arg, algo_names[i])) {\n\t\t\t*algo = i;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn \"Unknown algorithm\";\n}\n\nvoid show_algo(char buf[OPT_SHOW_LEN], const enum sha256_algos *algo)\n{\n\tstrncpy(buf, algo_names[*algo], OPT_SHOW_LEN);\n}\n#endif  /* USE_SHA256D */\n\nchar *force_nthreads_int(const char *arg, int *i)\n{\n\tforced_n_threads = true;\n\treturn set_int_range(arg, i, 0, 9999);\n}\n\nstatic int cpu_autodetect()\n{\n\tRUNONCE(0);\n\t\n\tint i;\n\n\t// Reckon number of cores in the box\n\t#if defined(WIN32)\n\t{\n\t\tDWORD_PTR system_am;\n\t\tDWORD_PTR process_am;\n\t\tBOOL ok = GetProcessAffinityMask(\n\t\t\tGetCurrentProcess(),\n\t\t\t&system_am,\n\t\t\t&process_am\n\t\t);\n\t\tif (!ok) {\n\t\t\tapplog(LOG_ERR, \"couldn't figure out number of processors :(\");\n\t\t\tnum_processors = 1;\n\t\t} else {\n\t\t\tsize_t n = 32;\n\t\t\tnum_processors = 0;\n\t\t\twhile (n--)\n\t\t\t\tif (process_am & (1<<n))\n\t\t\t\t\t++num_processors;\n\t\t}\n\t}\n\t#elif defined(_SC_NPROCESSORS_CONF)\n\t\tnum_processors = sysconf(_SC_NPROCESSORS_CONF);\n\t#elif defined(CTL_HW) && defined(HW_NCPU)\n\t\tint req[] = { CTL_HW, HW_NCPU };\n\t\tsize_t len = sizeof(num_processors);\n\t\tsysctl(req, 2, &num_processors, &len, NULL, 0);\n\t#else\n\t\tnum_processors = 1;\n\t#endif /* !WIN32 */\n\n\tif (opt_n_threads < 0 || !forced_n_threads) {\n\t\t\topt_n_threads = num_processors;\n\t}\n\tif (num_processors < 1)\n\t\treturn 0;\n\n\tcpus = calloc(opt_n_threads, sizeof(struct cgpu_info));\n\tif (unlikely(!cpus))\n\t\tquit(1, \"Failed to calloc cpus\");\n\tfor (i = 0; i < opt_n_threads; ++i) {\n\t\tstruct cgpu_info *cgpu;\n\n\t\tcgpu = &cpus[i];\n\t\tcgpu->drv = &cpu_drv;\n\t\tcgpu->deven = DEV_ENABLED;\n\t\tcgpu->threads = 1;\n#ifdef USE_SHA256D\n\t\tcgpu->kname = algo_names[opt_algo];\n#endif\n\t\tadd_cgpu(cgpu);\n\t}\n\treturn opt_n_threads;\n}\n\nstatic void cpu_detect()\n{\n\tnoserial_detect_manual(&cpu_drv, cpu_autodetect);\n}\n\nstatic pthread_mutex_t cpualgo_lock;\n\nstatic bool cpu_thread_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\t\n\tif (!(cgpu->device_id || thr->device_thread || cgpu->proc_id))\n\t\tmutex_init(&cpualgo_lock);\n\t\n\tthread_reportin(thr);\n\n\treturn true;\n}\n\nstatic uint64_t cpu_can_limit_work(struct thr_info __maybe_unused *thr)\n{\n\treturn 0xffff;\n}\n\nstatic bool cpu_thread_init(struct thr_info *thr)\n{\n\tconst int thr_id = thr->id;\n#ifdef USE_SHA256D\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\n\tmutex_lock(&cpualgo_lock);\n\tswitch (opt_algo)\n\t{\n\t\tcase ALGO_AUTO:\n\t\tcase ALGO_FASTAUTO:\n\t\t\topt_algo = pick_fastest_algo();\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&cpualgo_lock);\n\n\tcgpu->kname = algo_names[opt_algo];\n#endif\n\t\n\t/* Set worker threads to nice 19 and then preferentially to SCHED_IDLE\n\t * and if that fails, then SCHED_BATCH. No need for this to be an\n\t * error if it fails */\n\tsetpriority(PRIO_PROCESS, 0, 19);\n\tdrop_policy();\n\t/* Cpu affinity only makes sense if the number of threads is a multiple\n\t * of the number of CPUs */\n\tif (num_processors > 1 && opt_n_threads % num_processors == 0)\n\t\taffine_to_cpu(dev_from_id(thr_id), dev_from_id(thr_id) % num_processors);\n\treturn true;\n}\n\nstatic\nfloat cpu_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\treturn minimum_pdiff;\n}\n\nstatic\nbool scanhash_generic(struct thr_info * const thr, struct work * const work, const uint32_t max_nonce, uint32_t * const last_nonce, uint32_t n)\n{\n\tstruct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tvoid (* const hash_data_f)(void *, const void *) = malgo->hash_data_f;\n\tuint8_t * const hash = work->hash;\n\tuint8_t *data = work->data;\n\tconst uint8_t * const target = work->target;\n\tuint32_t * const out_nonce = (uint32_t *)&data[0x4c];\n\tbool ret = false;\n\t\n\tconst uint32_t hash7_targ = le32toh(((const uint32_t *)target)[7]);\n\tuint32_t * const hash7_tmp = &((uint32_t *)hash)[7];\n\t\n\twhile (true)\n\t{\n\t\t*out_nonce = n;\n\t\t\n\t\thash_data_f(hash, data);\n\t\t\n\t\tif (unlikely(le32toh(*hash7_tmp) <= hash7_targ))\n\t\t{\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart)\n\t\t\tbreak;\n\n\t\tn++;\n\t}\n\t\n\t*last_nonce = n;\n\treturn ret;\n}\n\nstatic int64_t cpu_scanhash(struct thr_info *thr, struct work *work, int64_t max_nonce)\n{\n\tuint32_t first_nonce = work->blk.nonce;\n\tuint32_t last_nonce;\n\tbool rc;\n\nCPUSearch:\n\tlast_nonce = first_nonce;\n\trc = false;\n\n\t/* scan nonces for a proof-of-work hash */\n\t{\n\t\tsha256_func func = scanhash_generic;\n\t\tswitch (work_mining_algorithm(work)->algo)\n\t\t{\n#ifdef USE_SCRYPT\n\t\t\tcase POW_SCRYPT:\n\t\t\t\tfunc = scanhash_scrypt;\n\t\t\t\tbreak;\n#endif\n#ifdef USE_SHA256D\n\t\t\tcase POW_SHA256D:\n\t\t\t\tif (work->nonce_diff >= 1.)\n\t\t\t\t\tfunc = sha256_funcs[opt_algo];\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!func))\n\t\t\tapplogr(0, LOG_ERR, \"%\"PRIpreprv\": Unknown mining algorithm\", thr->cgpu->proc_repr);\n\t\trc = (*func)(\n\t\t\tthr,\n\t\t\twork,\n\t\t\tmax_nonce,\n\t\t\t&last_nonce,\n\t\t\twork->blk.nonce\n\t\t);\n\t}\n\n\t/* if nonce found, submit work */\n\tif (unlikely(rc)) {\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\" found something?\", thr->cgpu->proc_repr);\n\t\tsubmit_nonce(thr, work, le32toh(*(uint32_t*)&work->data[76]));\n\t\twork->blk.nonce = last_nonce + 1;\n\t\tgoto CPUSearch;\n\t}\n\telse\n\tif (unlikely(last_nonce == first_nonce))\n\t\treturn 0;\n\n\twork->blk.nonce = last_nonce + 1;\n\treturn last_nonce - first_nonce + 1;\n}\n\nstruct device_drv cpu_drv = {\n\t.dname = \"cpu\",\n\t.name = \"CPU\",\n\t.probe_priority = 120,\n\t.drv_min_nonce_diff = cpu_min_nonce_diff,\n\t.drv_detect = cpu_detect,\n\t.thread_prepare = cpu_thread_prepare,\n\t.can_limit_work = cpu_can_limit_work,\n\t.thread_init = cpu_thread_init,\n\t.scanhash = cpu_scanhash,\n};\n"
        },
        {
          "name": "driver-cpu.h",
          "type": "blob",
          "size": 2.1259765625,
          "content": "/*\n * Copyright 2011-2013 Luke Dashjr\n * Copyright 2011-2012 Con Kolivas\n * Copyright 2011 Mark Crichton\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_DRIVER_CPU_H\n#define BFG_DRIVER_CPU_H\n\n#include \"miner.h\"\n\n#include \"config.h\"\n#include <stdbool.h>\n\n#ifndef OPT_SHOW_LEN\n#define OPT_SHOW_LEN 80\n#endif\n\n#ifdef USE_SHA256D\n\n#if defined(__i386__) && defined(HAVE_SSE2)\n#define WANT_SSE2_4WAY 1\n#endif\n\n#ifdef __ALTIVEC__\n#define WANT_ALTIVEC_4WAY 1\n#endif\n\n#if defined(__i386__) && defined(HAVE_YASM) && defined(HAVE_SSE2)\n#define WANT_X8632_SSE2 1\n#endif\n\n#ifdef __i386__\n#define WANT_VIA_PADLOCK 1\n#endif\n\n#if defined(__x86_64__) && defined(HAVE_YASM)\n#define WANT_X8664_SSE2 1\n#endif\n\n#if defined(__x86_64__) && defined(HAVE_YASM)\n#define WANT_X8664_SSE4 1\n#endif\n\n#endif  /* USE_SHA256D */\n\n#ifdef USE_SCRYPT\n#define WANT_SCRYPT\n#endif\n\nenum sha256_algos {\n#ifdef USE_SHA256D\n\tALGO_C,\t\t\t/* plain C */\n\tALGO_4WAY,\t\t/* parallel SSE2 */\n\tALGO_VIA,\t\t/* VIA padlock */\n\tALGO_CRYPTOPP,\t\t/* Crypto++ (C) */\n\tALGO_CRYPTOPP_ASM32,\t/* Crypto++ 32-bit assembly */\n\tALGO_SSE2_32,\t\t/* SSE2 for x86_32 */\n\tALGO_SSE2_64,\t\t/* SSE2 for x86_64 */\n\tALGO_SSE4_64,\t\t/* SSE4 for x86_64 */\n\tALGO_ALTIVEC_4WAY,\t/* parallel Altivec */\n#endif\n#ifdef USE_SCRYPT\n\tALGO_SCRYPT,\t\t/* scrypt */\n#endif\n\t\n#ifdef USE_SHA256D\n\tALGO_FASTAUTO,\t\t/* fast autodetect */\n\tALGO_AUTO,\t\t/* autodetect */\n#endif\n\t\n\tCUSTOM_CPU_MINING_ALGOS_COUNT,\n};\n\nextern const char *algo_names[];\nextern struct device_drv cpu_drv;\n\nextern const uint32_t hash1_init[];\n\nextern char *set_algo(const char *arg, enum sha256_algos *algo);\nextern void show_algo(char buf[OPT_SHOW_LEN], const enum sha256_algos *algo);\nextern char *force_nthreads_int(const char *arg, int *i);\nextern void init_max_name_len();\nextern double bench_algo_stage3(enum sha256_algos algo);\nextern void set_scrypt_algo(enum sha256_algos *algo);\n\n#endif /* __DEVICE_CPU_H__ */\n"
        },
        {
          "name": "driver-drillbit.c",
          "type": "blob",
          "size": 18.93359375,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n * Copyright 2013-2014 Angus Gratton\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n\nBFG_REGISTER_DRIVER(drillbit_drv)\n\n#define DRILLBIT_MIN_VERSION 2\n#define DRILLBIT_MAX_VERSION 4\n\n#define DRILLBIT_MAX_WORK_RESULTS 0x400\n#define DRILLBIT_MAX_RESULT_NONCES 0x10\n\nenum drillbit_capability {\n\tDBC_TEMP      = 1,\n\tDBC_EXT_CLOCK = 2,\n};\n\nstruct drillbit_board {\n\tunsigned core_voltage;\n\tunsigned clock_freq;\n\tbool clock_div2;\n\tbool use_ext_clock;\n\tbool need_reinit;\n\tbool trigger_identify;\n\tuint16_t caps;\n\tuint8_t protover;\n};\n\nstatic\nbool drillbit_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn (info->manufacturer && strstr(info->manufacturer, \"Drillbit\"));\n}\n\nstatic\nbool drillbit_detect_one(const char * const devpath)\n{\n\tuint8_t buf[0x10];\n\tconst int fd = serial_open(devpath, 0, 1, true);\n\tif (fd == -1)\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s: Failed to open\", __func__, devpath);\n\tif (1 != write(fd, \"I\", 1))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: %s: Error writing 'I'\", __func__, devpath);\nerr:\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\tif (sizeof(buf) != serial_read(fd, buf, sizeof(buf)))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: %s: Short read in response to 'I'\",\n\t\t       __func__, devpath);\n\t\tgoto err;\n\t}\n\tserial_close(fd);\n\t\n\tconst unsigned protover = buf[0];\n\tconst unsigned long serialno = (uint32_t)buf[9] | ((uint32_t)buf[0xa] << 8) | ((uint32_t)buf[0xb] << 16) | ((uint32_t)buf[0xc] << 24);\n\tchar * const product = (void*)&buf[1];\n\tbuf[9] = '\\0';  // Ensure it is null-terminated (clobbers serial, but we already parsed it)\n\tunsigned chips = buf[0xd];\n\tuint16_t caps = buf[0xe] | ((uint16_t)buf[0xf] << 8);\n\tif (!product[0])\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s: Null product name\", __func__, devpath);\n\tif (!serialno)\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s: Serial number is zero\", __func__, devpath);\n\tif (!chips)\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s: No chips found\", __func__, devpath);\n\t\n\tint loglev = LOG_WARNING;\n\tif (!strcmp(product, \"DRILLBIT\"))\n\t{\n\t\t// Hack: first production firmwares all described themselves as DRILLBIT, so fill in the gaps\n\t\tif (chips == 1)\n\t\t\tstrcpy(product, \"Thumb\");\n\t\telse\n\t\t\tstrcpy(product, \"Eight\");\n\t}\n\telse\n\tif ((chips >= 8) && (chips <= 64) && (chips % 8 == 0) && !strcmp(product, \"Eight\"))\n\t{}  // Known device\n\telse\n\tif (chips == 1 && !strcmp(product, \"Thumb\"))\n\t{}  // Known device\n\telse\n\t\tloglev = LOG_DEBUG;\n\t\n\tif (protover < DRILLBIT_MIN_VERSION || (loglev == LOG_DEBUG && protover > DRILLBIT_MAX_VERSION))\n\t\tapplogr(false, loglev, \"%s: %s: Unknown device protocol version %u.\",\n\t\t        __func__, devpath, protover);\n\tif (protover > DRILLBIT_MAX_VERSION)\n\t\tapplogr(false, loglev, \"%s: %s: Device firmware uses newer Drillbit protocol %u. We only support up to %u. Find a newer BFGMiner!\",\n\t\t        __func__, devpath, protover, (unsigned)DRILLBIT_MAX_VERSION);\n\t\n\tif (protover == 2 && chips == 1)\n\t\t// Production firmware Thumbs don't set any capability bits, so fill in the EXT_CLOCK one\n\t\tcaps |= DBC_EXT_CLOCK;\n\t\n\tif (chips > 0x100)\n\t{\n\t\tapplog(LOG_WARNING, \"%s: %s: %u chips reported, but driver only supports up to 256\",\n\t\t       __func__, devpath, chips);\n\t\tchips = 0x100;\n\t}\n\t\n\tif (serial_claim_v(devpath, &drillbit_drv))\n\t\treturn false;\n\t\n\tintptr_t device_data = caps | ((intptr_t)protover << 16); // Store capabilities & protocol version in device_data, temporarily\n\n\tchar *serno = malloc(9);\n\tsnprintf(serno, 9, \"%08lx\", serialno);\n\t\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &drillbit_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.dev_product = strdup(product),\n\t\t.dev_serial = serno,\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = chips,\n\t\t.threads = 1,\n\t\t.device_data = (void *)device_data,\n\t};\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nbool drillbit_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, drillbit_detect_one);\n}\n\nstatic\nvoid drillbit_problem(struct cgpu_info * const dev)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\t\n\tif (dev->device_fd != -1)\n\t{\n\t\tserial_close(dev->device_fd);\n\t\tdev->device_fd = -1;\n\t}\n\ttimer_set_delay_from_now(&master_thr->tv_poll, 5000000);\n}\n\n#define problem(...)  do{  \\\n\tdrillbit_problem(dev);  \\\n\tapplogr(__VA_ARGS__);  \\\n}while(0)\n\nstatic\nbool drillbit_check_response(const char * const repr, const int fd, struct cgpu_info * const dev, const char expect)\n{\n\tuint8_t ack;\n\tif (1 != serial_read(fd, &ack, 1))\n\t\tproblem(false, LOG_ERR, \"%s: Short read in response to '%c'\",\n\t\t        repr, expect);\n\tif (ack != expect)\n\t\tproblem(false, LOG_ERR, \"%s: Wrong response to '%c': %u\",\n\t\t        dev->dev_repr, expect, (unsigned)ack);\n\treturn true;\n}\n\nstatic\nbool drillbit_reset(struct cgpu_info * const dev)\n{\n\tconst int fd = dev->device_fd;\n\tif (unlikely(fd == -1))\n\t\treturn false;\n\t\n\tif (1 != write(fd, \"R\", 1))\n\t\tproblem(false, LOG_ERR, \"%s: Error writing reset command\", dev->dev_repr);\n\t\n\treturn drillbit_check_response(dev->dev_repr, fd, dev, 'R');\n}\n\nstatic\nbool drillbit_send_config(struct cgpu_info * const dev)\n{\n\tconst int fd = dev->device_fd;\n\tif (unlikely(fd == -1))\n\t\treturn false;\n\t\n\tconst struct drillbit_board * const board = dev->device_data;\n\tuint8_t buf[7] = {'C'};\n\tif(board->protover < 4) {\n\t\tif(board->core_voltage < 750)\n\t\t\tbuf[1] = 0; // 650mV\n\t\telse if(board->core_voltage < 850)\n\t\t\tbuf[1] = 1; // 750mV\n\t\telse if(board->core_voltage < 950)\n\t\t\tbuf[1] = 2; // 850mV\n\t\telse\n\t\t\tbuf[1] = 3; // 950mV\n\t\tif(board->clock_freq < 64) // internal clock level, either direct or MHz/5\n\t\t\tbuf[2] = board->clock_freq;\n\t\telse\n\t\t\tbuf[2] = board->clock_freq / 5;\n\t\tbuf[3] = board->clock_div2 ? 1 : 0;\n\t\tbuf[4] = board->use_ext_clock ? 1 : 0;\n\t\tbuf[5] = board->clock_freq;\n\t\tbuf[6] = board->clock_freq >> 8;\n\t}\n\telse {\n\t\tbuf[1] = board->core_voltage;\n\t\tbuf[2] = board->core_voltage >> 8;\n\t\tbuf[3] = board->clock_freq;\n\t\tbuf[4] = board->clock_freq >> 8;\n\t\tbuf[5] = board->clock_div2 ? 1 : 0;\n\t\tbuf[6] = board->use_ext_clock ? 1 : 0;\n\t}\n\n\tif (sizeof(buf) != write(fd, buf, sizeof(buf)))\n\t\tproblem(false, LOG_ERR, \"%s: Error sending config\", dev->dev_repr);\n\t\n\treturn drillbit_check_response(dev->dev_repr, fd, dev, 'C');\n}\n\nstatic bool drillbit_resend_jobs(struct cgpu_info *proc);\n\nstatic\nbool drillbit_reconfigure(struct cgpu_info * const dev, const bool reopen)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tint fd = dev->device_fd;\n\tif (reopen || fd == -1)\n\t{\n\t\tif (fd != -1)\n\t\t\tserial_close(fd);\n\t\t\n\t\tdev->device_fd = fd = serial_open(dev->device_path, 0, 10, true);\n\t\tif (fd == -1)\n\t\t\treturn false;\n\t}\n\t\n\tif (!(drillbit_reset(dev) && drillbit_send_config(dev)))\n\t{\n\t\tserial_close(fd);\n\t\tdev->device_fd = -1;\n\t\treturn false;\n\t}\n\t\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t\tdrillbit_resend_jobs(proc);\n\t\n\ttimer_set_delay_from_now(&master_thr->tv_poll, 10000);\n\t\n\treturn true;\n}\n\nstatic\nbool drillbit_ensure_configured(struct cgpu_info * const dev)\n{\n\tif (dev->device_fd != -1)\n\t\treturn true;\n\treturn drillbit_reconfigure(dev, false);\n}\n\nstatic\nbool drillbit_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\t\n\tdev->device_fd = -1;\n\n\tintptr_t device_data = (intptr_t)dev->device_data; // capabilities & protocol version stored here\n\n\tstruct drillbit_board * const board = malloc(sizeof(*board));\n\t*board = (struct drillbit_board){\n\t\t.core_voltage = 850,\n\t\t.clock_freq = 200,\n\t\t.clock_div2 = false,\n\t\t.use_ext_clock = false,\n\t\t.caps = device_data,\n\t\t.protover = device_data >> 16,\n\t};\n\tdev->device_data = board;\n\t\n\tdrillbit_reconfigure(dev, false);\n\t\n\treturn true;\n}\n\nstatic\nbool drillbit_job_prepare(struct thr_info * const thr, struct work * const work, __maybe_unused const uint64_t max_nonce)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tconst int chipid = proc->proc_id;\n\tstruct cgpu_info * const dev = proc->device;\n\tuint8_t buf[0x2f];\n\t\n\tif (!drillbit_ensure_configured(dev))\n\t\treturn false;\n\tconst int fd = dev->device_fd;\n\t\n\tbuf[0] = 'W';\n\tbuf[1] = chipid;\n\tbuf[2] = 0;  // high bits of chipid\n\tmemcpy(&buf[3], work->midstate, 0x20);\n\tmemcpy(&buf[0x23], &work->data[0x40], 0xc);\n\t\n\tif (sizeof(buf) != write(fd, buf, sizeof(buf)))\n\t\tproblem(false, LOG_ERR, \"%\"PRIpreprv\": Error sending work %d\",\n\t\t        proc->proc_repr, work->id);\n\t\n\tif (!drillbit_check_response(proc->proc_repr, fd, dev, 'W'))\n\t\tproblem(false, LOG_ERR, \"%\"PRIpreprv\": Error queuing work %d\",\n\t\t        proc->proc_repr, work->id);\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Queued work %d\",\n\t       proc->proc_repr, work->id);\n\t\n\twork->blk.nonce = 0xffffffff;\n\treturn true;\n}\n\nstatic\nbool drillbit_resend_jobs(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tbool rv = true;\n\t\n\tif (thr->work)\n\t\tif (!drillbit_job_prepare(thr, thr->work, 0))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Failed to resend %s work\",\n\t\t\t       proc->proc_repr, \"current\");\n\t\t\trv = false;\n\t\t}\n\tif (thr->next_work)\n\t{\n\t\tif (!drillbit_job_prepare(thr, thr->next_work, 0))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Failed to resend %s work\",\n\t\t\t       proc->proc_repr, \"next\");\n\t\t\trv = false;\n\t\t}\n\t\tif (!rv)\n\t\t{\n\t\t\t// Fake transition so we kinda recover eventually\n\t\t\tmt_job_transition(thr);\n\t\t\tjob_start_complete(thr);\n\t\t\ttimer_set_now(&thr->tv_morework);\n\t\t}\n\t}\n\treturn rv;\n}\n\nstatic\nvoid drillbit_first_job_start(struct thr_info __maybe_unused * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tif (unlikely(!thr->work))\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": No current work, assuming immediate start\",\n\t\t       proc->proc_repr);\n\t\tmt_job_transition(thr);\n\t\tjob_start_complete(thr);\n\t\ttimer_set_now(&thr->tv_morework);\n\t}\n}\n\nstatic\nint64_t drillbit_job_process_results(struct thr_info *thr, struct work *work, bool stopping)\n{\n\treturn 0xbd000000;\n}\n\nstatic\nstruct cgpu_info *drillbit_find_proc(struct cgpu_info * const dev, int chipid)\n{\n\tstruct cgpu_info *proc = dev;\n\tfor (int i = 0; i < chipid; ++i)\n\t{\n\t\tproc = proc->next_proc;\n\t\tif (unlikely(!proc))\n\t\t\treturn NULL;\n\t}\n\treturn proc;\n}\n\nstatic\nbool bitfury_fudge_nonce2(struct work * const work, uint32_t * const nonce_p)\n{\n\tif (!work)\n\t\treturn false;\n\tconst uint32_t m7    = *((uint32_t *)&work->data[64]);\n\tconst uint32_t ntime = *((uint32_t *)&work->data[68]);\n\tconst uint32_t nbits = *((uint32_t *)&work->data[72]);\n\treturn bitfury_fudge_nonce(work->midstate, m7, ntime, nbits, nonce_p);\n}\n\nstatic\nbool drillbit_get_work_results(struct cgpu_info * const dev)\n{\n\tconst int fd = dev->device_fd;\n\tif (fd == -1)\n\t\treturn false;\n\t\n\tuint8_t buf[4 + (4 * DRILLBIT_MAX_RESULT_NONCES)];\n\tuint32_t total;\n\tint i, j;\n\t\n\tdo {\n\t\tif (1 != write(fd, \"E\", 1))\n\t\t\tproblem(false, LOG_ERR, \"%s: Error sending request for work results\", dev->dev_repr);\n\t\n\t\tif (sizeof(total) != serial_read(fd, &total, sizeof(total)))\n\t\t\tproblem(false, LOG_ERR, \"%s: Short read in response to 'E'\", dev->dev_repr);\n\t\ttotal = le32toh(total);\n\t\n\t\tif (total > DRILLBIT_MAX_WORK_RESULTS)\n\t\t\tproblem(false, LOG_ERR, \"%s: Impossible number of total work: %lu\",\n\t\t\t\tdev->dev_repr, (unsigned long)total);\n\t\n\t\tfor (i = 0; i < total; ++i)\n\t\t{\n\t\t\tif (sizeof(buf) != serial_read(fd, buf, sizeof(buf)))\n\t\t\t\tproblem(false, LOG_ERR, \"%s: Short read on %dth total work\",\n\t\t\t\t\tdev->dev_repr, i);\n\t\t\tconst int chipid = buf[0];\n\t\t\tstruct cgpu_info * const proc = drillbit_find_proc(dev, chipid);\n\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\tif (unlikely(!proc))\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%s: Unknown chip id %d\", dev->dev_repr, chipid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst bool is_idle = buf[3];\n\t\t\tint nonces = buf[2];\n\t\t\tif (nonces > DRILLBIT_MAX_RESULT_NONCES)\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": More than %d nonces claimed, impossible\",\n\t\t\t\t\tproc->proc_repr, (int)DRILLBIT_MAX_RESULT_NONCES);\n\t\t\t\tnonces = DRILLBIT_MAX_RESULT_NONCES;\n\t\t\t}\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Handling completion of %d nonces from chip %d. is_idle=%d work=%p next_work=%p\",\n\t\t\t\tproc->proc_repr, nonces, chipid, is_idle, thr->work, thr->next_work);\n\t\t\tconst uint32_t *nonce_p = (void*)&buf[4];\n\t\t\tfor (j = 0; j < nonces; ++j, ++nonce_p)\n\t\t\t{\n\t\t\t\tuint32_t nonce = bitfury_decnonce(*nonce_p);\n\t\t\t\tif (bitfury_fudge_nonce2(thr->work, &nonce))\n\t\t\t\t\tsubmit_nonce(thr, thr->work, nonce);\n\t\t\t\telse\n\t\t\t\t\tif (bitfury_fudge_nonce2(thr->next_work, &nonce))\n\t\t\t\t\t{\n\t\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Result for next work, transitioning\",\n\t\t\t\t\t\t\tproc->proc_repr);\n\t\t\t\t\t\tsubmit_nonce(thr, thr->next_work, nonce);\n\t\t\t\t\t\tmt_job_transition(thr);\n\t\t\t\t\t\tjob_start_complete(thr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tif (bitfury_fudge_nonce2(thr->prev_work, &nonce))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Result for PREVIOUS work\",\n\t\t\t\t\t\t\t\tproc->proc_repr);\n\t\t\t\t\t\t\tsubmit_nonce(thr, thr->prev_work, nonce);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinc_hw_errors(thr, thr->work, nonce);\n\t\t\t}\n\t\t\tif (is_idle && thr->next_work)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Chip went idle without any results for next work\",\n\t\t\t\t\tproc->proc_repr);\n\t\t\t\tmt_job_transition(thr);\n\t\t\t\tjob_start_complete(thr);\n\t\t\t}\n\t\t\tif (!thr->next_work)\n\t\t\t\ttimer_set_now(&thr->tv_morework);\n\t\t}\n\t} while(total > 0);\n\t\n\treturn true;\n}\n\nstatic\nvoid drillbit_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\tstruct drillbit_board * const board = dev->device_data;\n\t\n\tif (!drillbit_ensure_configured(dev))\n\t\treturn;\n\t\n\tdrillbit_get_work_results(dev);\n\t\n\tif (board->need_reinit)\n\t{\n\t\tapplog(LOG_NOTICE, \"%s: Reinitialisation needed for configuration changes\",\n\t\t       dev->dev_repr);\n\t\tdrillbit_reconfigure(dev, false);\n\t\tboard->need_reinit = false;\n\t}\n\tif (board->trigger_identify)\n\t{\n\t\tconst int fd = dev->device_fd;\n\t\tapplog(LOG_DEBUG, \"%s: Sending identify command\", dev->dev_repr);\n\t\tif (1 != write(fd, \"L\", 1))\n\t\t\tapplog(LOG_ERR, \"%s: Error writing identify command\", dev->dev_repr);\n\t\tdrillbit_check_response(dev->dev_repr, fd, dev, 'L');\n\t\tboard->trigger_identify = false;\n\t}\n\t\n\ttimer_set_delay_from_now(&master_thr->tv_poll, 10000);\n}\n\nstatic bool drillbit_identify(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct drillbit_board * const board = dev->device_data;\n\tboard->trigger_identify = true;\n\treturn true;\n}\n\nstatic\nbool drillbit_get_stats(struct cgpu_info * const dev)\n{\n\tif (dev != dev->device)\n\t\treturn true;\n\t\n\tstruct drillbit_board * const board = dev->device_data;\n\tif (!(board->caps & DBC_TEMP))\n\t\treturn true;\n\t\n\tconst int fd = dev->device_fd;\n\tif (fd == -1)\n\t\treturn false;\n\t\n\tif (1 != write(fd, \"T\", 1))\n\t\tproblem(false, LOG_ERR, \"%s: Error requesting temperature\", dev->dev_repr);\n\t\n\tuint8_t buf[2];\n\t\n\tif (sizeof(buf) != serial_read(fd, buf, sizeof(buf)))\n\t\tproblem(false, LOG_ERR, \"%s: Short read in response to 'T'\", dev->dev_repr);\n\t\n\tfloat temp = ((uint16_t)buf[0]) | ((uint16_t)buf[1] << 8);\n\ttemp /= 10.;\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t\tproc->temp = temp;\n\t\n\treturn true;\n}\n\nstatic\nvoid drillbit_clockcfg_str(char * const buf, size_t bufsz, struct drillbit_board * const board)\n{\n\tsnprintf(buf, bufsz, \"%u\", board->clock_freq);\n\tif (board->clock_div2)\n\t\ttailsprintf(buf, bufsz, \":2\");\n}\n\nstatic\nstruct api_data *drillbit_api_stats(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct drillbit_board * const board = dev->device_data;\n\tstruct api_data *root = NULL;\n\tchar buf[0x100];\n\t\n\tdrillbit_clockcfg_str(buf, sizeof(buf), board);\n\troot = api_add_string(root, \"ClockCfg\", buf, true);\n\t\n\tfloat volts = board->core_voltage / 1000.0;\n\troot = api_add_volts(root, \"Voltage\", &volts, true);\n\t\n\treturn root;\n}\n\nstatic\nchar *drillbit_set_device(struct cgpu_info * const proc, char * const option, char *setting, char * const replybuf)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct drillbit_board * const board = dev->device_data;\n\t\n\tif (!strcasecmp(option, \"help\"))\n\t{\n\t\tsprintf(replybuf,\n\t\t\t\"voltage: 0.65, 0.75, 0.85, or 0.95 (volts)\\n\"\n\t\t\t\"clock: %sL0-L63 for internal clock levels; append :2 to activate div2\",\n\t\t\t(board->caps & DBC_EXT_CLOCK) ? \"0-255 (MHz) using external clock (80-230 recommended), or \" : \"\"\n\t\t);\n\t\treturn replybuf;\n\t}\n\t\n\tif (!strcasecmp(option, \"voltage\"))\n\t{\n\t\t// NOTE: Do not use replybuf in here without implementing it in drillbit_tui_handle_choice\n\t\tif (!setting || !*setting)\n\t\t\treturn \"Missing voltage setting\";\n\t\tconst int val = atof(setting) * 1000;\n\t\tboard->core_voltage = val;\n\t\tboard->need_reinit = true;\n\t\t\n\t\treturn NULL;\n\t}\n\t\n\tif (!strcasecmp(option, \"clock\"))\n\t{\n\t\t// NOTE: Do not use replybuf in here without implementing it in drillbit_tui_handle_choice\n\t\tconst bool use_ext_clock = !(setting[0] == 'L');\n\t\tchar *end = &setting[use_ext_clock ? 0 : 1];\n\t\tconst long int num = strtol(end, &end, 0);\n\t\tconst bool div2 = (end[0] == ':' && end[1] == '2');\n\t\t// NOTE: board assignments are ordered such that it is safe to race\n\t\tif (use_ext_clock)\n\t\t{\n\t\t\tif (!(board->caps & DBC_EXT_CLOCK))\n\t\t\t\treturn \"External clock not supported by this device\";\n\t\t\tboard->use_ext_clock = true;\n\t\t}\n\t\tif (num < 0 || num > 0xffff)\n\t\t\treturn \"Clock frequency out of range (0-65535)\";\n\t\tboard->clock_div2 = div2;\n\t\tboard->clock_freq = num;\n\t\tboard->need_reinit = true;\n\t\treturn NULL;\n\t}\n\t\n\tsprintf(replybuf, \"Unknown option: %s\", option);\n\treturn replybuf;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid drillbit_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock [V]oltage \");\n}\n\nstatic\nconst char *drillbit_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tchar *val;\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t\tval = curses_input(\"Set clock (80-230 MHz using external clock, or L0-L63 for internal clock levels; append :2 to activate div2\");\n\t\t\treturn drillbit_set_device(proc, \"clock\", val, NULL) ?: \"Requesting clock change\";\n\t\tcase 'v': case 'V':\n\t\t\tval = curses_input(\"Set voltage (0.65, 0.75, 0.85, or 0.95)\");\n\t\t\treturn drillbit_set_device(proc, \"voltage\", val, NULL) ?: \"Requesting voltage change\";\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid drillbit_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct drillbit_board * const board = dev->device_data;\n\tchar buf[0x100];\n\t\n\tdrillbit_clockcfg_str(buf, sizeof(buf), board);\n\twlogprint(\"Clock: %s\\n\", buf);\n\twlogprint(\"Voltage: %.2f\\n\", board->core_voltage / 1000.0);\n}\n#endif\n\nstruct device_drv drillbit_drv = {\n\t.dname = \"drillbit\",\n\t.name = \"DRB\",\n\t\n\t.lowl_match = drillbit_lowl_match,\n\t.lowl_probe = drillbit_lowl_probe,\n\t\n\t.thread_init = drillbit_init,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = drillbit_job_prepare,\n\t.job_start = drillbit_first_job_start,\n\t.job_process_results = drillbit_job_process_results,\n\t.poll = drillbit_poll,\n\t.get_stats = drillbit_get_stats,\n\t.identify_device = drillbit_identify,\n\t\n\t.get_api_stats = drillbit_api_stats,\n\t.set_device = drillbit_set_device,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = drillbit_wlogprint_status,\n\t.proc_tui_wlogprint_choices = drillbit_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = drillbit_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-dualminer.c",
          "type": "blob",
          "size": 9.7236328125,
          "content": "/*\n * Copyright 2013-2015 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2014 Dualminer Team\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#include \"miner.h\"\n#include \"driver-icarus.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"util.h\"\n#include \"gc3355.h\"\n\n#ifndef WIN32\n  #include <sys/ioctl.h>\n#else\n  #include <io.h>\n#endif\n\n#define DUALMINER_IO_SPEED 115200\n\n#define DUALMINER_SCRYPT_SM_HASH_TIME   0.00001428571429\n#define DUALMINER_SCRYPT_DM_HASH_TIME\t0.00003333333333\n#define DUALMINER_SHA2_DM_HASH_TIME     0.00000000300000\n\n#define DUALMINER_SCRYPT_READ_TIMEOUT_MS 4800  // 4.8s to read\n#define DUALMINER_SHA2_READ_TIMEOUT_MS   1600  // 1.6s to read\n\n#define DUALMINER_0_9V_SHA2_UNITS  60\n#define DUALMINER_1_2V_SHA2_UNITS   0\n\n#define DUALMINER_DM_DEFAULT_FREQUENCY  550\n#define DUALMINER_SM_DEFAULT_FREQUENCY  850\n\nstatic\nconst char sha2_golden_ob[] =\n\t\"55aa0f00a08701004a548fe471fa3a9a\"\n\t\"1371144556c3f64d2500b4826008fe4b\"\n\t\"bf7698c94eba7946ce22a72f4f672614\"\n\t\"1a0b3287\";\n\nstatic\nconst char sha2_golden_nonce[] = \"a2870100\";\n\nstatic\nconst char scrypt_golden_ob[] =\n\t\"55aa1f00000000000000000000000000\"\n\t\"000000000000000000000000aaaaaaaa\"\n\t\"711c0000603ebdb6e35b05223c54f815\"\n\t\"5ac33123006b4192e7aafafbeb9ef654\"\n\t\"4d2973d700000002069b9f9e3ce8a677\"\n\t\"8dea3d7a00926cd6eaa9585502c9b83a\"\n\t\"5601f198d7fbf09be9559d6335ebad36\"\n\t\"3e4f147a8d9934006963030b4e54c408\"\n\t\"c837ebc2eeac129852a55fee1b1d88f6\"\n\t\"000c050000000600\";\n\nstatic\nconst char scrypt_golden_nonce[] = \"dd0c0500\";\n\nBFG_REGISTER_DRIVER(dualminer_drv)\nstatic\nconst struct bfg_set_device_definition dualminer_set_device_funcs[];\n\n// device helper functions\n\nstatic inline\nbool dualminer_is_scrypt(struct ICARUS_INFO * const info)\n{\n#ifdef USE_SCRYPT\n\treturn info->scrypt;\n#else\n\treturn false;\n#endif\n}\n\nstatic\nvoid dualminer_teardown_device(int fd)\n{\n\t// set data terminal ready (DTR) status\n\tset_serial_dtr(fd, BGV_HIGH);\n\t// set request to send (RTS) status\n\tset_serial_rts(fd, BGV_LOW);\n}\n\nstatic\nvoid dualminer_init_hashrate(struct cgpu_info * const cgpu)\n{\n\tint fd = cgpu->device_fd;\n\tstruct ICARUS_INFO *info = cgpu->device_data;\n\n\t// get clear to send (CTS) status\n\tif ((gc3355_get_cts_status(fd) != 1) &&  // 0.9v - dip-switch set to B\n\t\t(dualminer_is_scrypt(info)))\n\t\t// adjust hash-rate for voltage\n\t\tinfo->Hs = DUALMINER_SCRYPT_DM_HASH_TIME;\n}\n\n// runs when job starts and the device has been reset (or first run)\nstatic\nvoid dualminer_init_firstrun(struct cgpu_info *icarus)\n{\n\tstruct ICARUS_INFO * const info = icarus->device_data;\n\tint fd = icarus->device_fd;\n\n\tgc3355_init_dualminer(fd, opt_pll_freq, !info->dual_mode, false, dualminer_is_scrypt(info));\n\t\n\tdualminer_init_hashrate(icarus);\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": dualminer: Init: pll=%d, scrypt: %d, scrypt only: %d\",\n\t\t   icarus->proc_repr,\n\t\t   opt_pll_freq,\n\t\t   dualminer_is_scrypt(info),\n\t\t   dualminer_is_scrypt(info) && !info->dual_mode);\n}\n\n// set defaults for options that the user didn't specify\nstatic\nvoid dualminer_set_defaults(int fd)\n{\n\t// set opt_sha2_units defaults depending on dip-switch\n\tif (opt_sha2_units == -1)\n\t{\n\t\t// get clear to send (CTS) status\n\t\tif (gc3355_get_cts_status(fd) == 1)\n\t\t\topt_sha2_units = DUALMINER_1_2V_SHA2_UNITS;  // dip-switch in L position\n\t\telse\n\t\t\topt_sha2_units = DUALMINER_0_9V_SHA2_UNITS;  // dip-switch in B position\n\t}\n\t\n\t// set opt_pll_freq defaults depending on dip-switch\n\tif (opt_pll_freq <= 0)\n\t{\n\t\t// get clear to send (CTS) status\n\t\tif (gc3355_get_cts_status(fd) == 1)\n\t\t\topt_pll_freq = DUALMINER_SM_DEFAULT_FREQUENCY; // 1.2v - dip-switch in L position\n\t\telse\n\t\t\topt_pll_freq = DUALMINER_DM_DEFAULT_FREQUENCY; // 0.9v - dip-switch in B position\n\t}\n}\n\nfloat dualminer_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\tstruct ICARUS_INFO * const info = proc ? proc->device_data : NULL;\n\tswitch (malgo->algo)\n\t{\n#ifdef USE_SCRYPT\n\t\tcase POW_SCRYPT:\n\t\t\treturn ((!info) || dualminer_is_scrypt(info)) ? (1./0x10000) : -1.;\n#endif\n#ifdef USE_SHA256D\n\t\tcase POW_SHA256D:\n\t\t\treturn (info && dualminer_is_scrypt(info)) ? -1. : 1.;\n#endif\n\t\tdefault:\n\t\t\treturn -1.;\n\t}\n}\n\n// ICARUS_INFO functions - icarus-common.h\n\n// runs after fd is opened but before the device detection code\nstatic\nbool dualminer_detect_init(const char *devpath, int fd, struct ICARUS_INFO * const info)\n{\n\tdualminer_set_defaults(fd);\n\t\n\tgc3355_init_dualminer(fd, opt_pll_freq, !info->dual_mode, true, dualminer_is_scrypt(info));\n\n\treturn true;\n}\n\n// runs each time a job starts\nstatic\nbool dualminer_job_start(struct thr_info * const thr)\n{\n\tstruct cgpu_info *icarus = thr->cgpu;\n\tstruct ICARUS_INFO * const info = icarus->device_data;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\tint fd = icarus->device_fd;\n\n\tif (state->firstrun)\n\t\t// runs when job starts and the device has been reset (or first run)\n\t\tdualminer_init_firstrun(icarus);\n\n\tif (dualminer_is_scrypt(info))\n\t{\n\t\tif (info->dual_mode)\n\t\t\tgc3355_scrypt_reset(fd);\n\t\telse\n\t\t\tgc3355_scrypt_only_reset(fd);\n\n\t\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_DataSheet.pdf\n\t\t// WAIT: Before start a new transaction, WAIT Cycle must be inserted.\n\t\t// WAIT Cycle value is programmable register in UART and default wait\n\t\t// time is UART receive 32 bits time (One DATA Cycle).\n\t\t// Note: prevents register corruption\n\t\tcgsleep_ms(100);\n\t}\n\n\treturn icarus_job_start(thr);\n}\n\n// device detection\n\nstatic\nbool dualminer_detect_one(const char *devpath)\n{\n\tstruct device_drv *drv = &dualminer_drv;\n\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\n\t*info = (struct ICARUS_INFO){\n\t\t.baud = DUALMINER_IO_SPEED,\n\t\t.timing_mode = MODE_DEFAULT,\n\t\t.do_icarus_timing = false,\n\t\t.nonce_littleendian = true,\n\t\t.work_division = 1,\n\t\t.detect_init_func = dualminer_detect_init,\n\t\t.job_start_func = dualminer_job_start,\n#ifdef USE_SCRYPT\n\t\t.scrypt = (get_mining_goal(\"default\")->malgo->algo == POW_SCRYPT),\n#endif\n\t};\n\n\tdrv_set_defaults(drv, dualminer_set_device_funcs, info, devpath, detectone_meta_info.serial, 1);\n\n\tif (dualminer_is_scrypt(info))\n\t{\n\t\tinfo->golden_ob = (char*)scrypt_golden_ob;\n\t\tinfo->golden_nonce = (char*)scrypt_golden_nonce;\n\t\tinfo->Hs = DUALMINER_SCRYPT_SM_HASH_TIME;\n\t}\n\telse\n\t{\n\t\tinfo->golden_ob = (char*)sha2_golden_ob;\n\t\tinfo->golden_nonce = (char*)sha2_golden_nonce;\n\t\tinfo->Hs = DUALMINER_SHA2_DM_HASH_TIME;\n\t}\n\n\tif (!icarus_detect_custom(devpath, drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\n\tif (dualminer_is_scrypt(info))\n\t\tinfo->read_timeout_ms = DUALMINER_SCRYPT_READ_TIMEOUT_MS; // 4.8s to read\n\telse\n\t\tinfo->read_timeout_ms = DUALMINER_SHA2_READ_TIMEOUT_MS; // 1.6s to read\n\n\treturn true;\n}\n\n// support for --set-device dualminer:dual_mode=1\n// most be set before probing the device\n\nstatic\nconst char *dualminer_set_dual_mode(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tint val = atoi(setting);\n\tinfo->dual_mode = val == 1;\n\treturn NULL;\n}\n\n#ifdef USE_SCRYPT\nstatic\nconst char *dualminer_set_scrypt(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tinfo->scrypt = atoi(newvalue);\n\treturn NULL;\n}\n#endif\n\nstatic\nconst struct bfg_set_device_definition dualminer_set_device_funcs[] = {\n\t{\"dual_mode\", dualminer_set_dual_mode, \"set to 1 to enable dual algorithm mining\"},\n#ifdef USE_SCRYPT\n\t{\"scrypt\", dualminer_set_scrypt, \"set to 1 to put in scrypt mode\"},\n#endif\n\t{NULL},\n};\n\n// device_drv functions - miner.h\n\nstatic\nbool dualminer_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, dualminer_detect_one);\n}\n\nstatic\nvoid dualminer_thread_shutdown(struct thr_info *thr)\n{\n\t// dualminer teardown\n\tdualminer_teardown_device(thr->cgpu->device_fd);\n\n\t// icarus teardown\n\tdo_icarus_close(thr);\n\tfree(thr->cgpu_data);\n}\n\nstatic\nbool dualminer_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info * const icarus = thr->cgpu;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\tstruct ICARUS_INFO * const info = icarus->device_data;\n\n\tmemset(state->ob_bin, 0, info->ob_size);\n\n\tif (dualminer_is_scrypt(info))\n\t\tgc3355_scrypt_prepare_work(state->ob_bin, work);\n\telse\n\t\tgc3355_sha2_prepare_work(state->ob_bin, work);\n\n\treturn true;\n}\n\n// support for --set-device dualminer:clock=freq\nstatic\nchar *dualminer_set_device(struct cgpu_info *cgpu, char *option, char *setting, char *replybuf)\n{\n\tif (strcasecmp(option, \"clock\") == 0)\n\t{\n\t\tint val = atoi(setting);\n\t\topt_pll_freq = val;\n\t\treturn NULL;\n\t}\n\n\tsprintf(replybuf, \"Unknown option: %s\", option);\n\treturn replybuf;\n}\n\n// device_drv definition - miner.h\n\nstatic\nvoid dualminer_drv_init()\n{\n\tdualminer_drv = icarus_drv;\n\tdualminer_drv.dname = \"dualminer\";\n\tdualminer_drv.name = \"DMU\";\n\tdualminer_drv.drv_min_nonce_diff = dualminer_min_nonce_diff;\n\tdualminer_drv.lowl_probe = dualminer_lowl_probe;\n\tdualminer_drv.thread_shutdown = dualminer_thread_shutdown;\n\tdualminer_drv.job_prepare = dualminer_job_prepare;\n\tdualminer_drv.set_device = dualminer_set_device;\n\n\t// currently setup specifically to probe after ZeusMiner\n\tdualminer_drv.probe_priority = -50;\n}\n\nstruct device_drv dualminer_drv =\n{\n\t.drv_init = dualminer_drv_init,\n};\n"
        },
        {
          "name": "driver-erupter.c",
          "type": "blob",
          "size": 2.935546875,
          "content": "/*\n * Copyright 2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n\n#include \"miner.h\"\n#include \"driver-icarus.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n\n#define ERUPTER_IO_SPEED 115200\n#define ERUPTER_HASH_TIME 0.0000000029761\n\nBFG_REGISTER_DRIVER(erupter_drv)\nBFG_REGISTER_DRIVER(erupter_drv_emerald)\n\nstatic bool _erupter_detect_one(const char *devpath, struct device_drv *drv)\n{\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\n\t*info = (struct ICARUS_INFO){\n\t\t.baud = ERUPTER_IO_SPEED,\n\t\t.Hs = ERUPTER_HASH_TIME,\n\t\t.timing_mode = MODE_DEFAULT,\n\t\t.continue_search = true,\n\t};\n\n\tif (!icarus_detect_custom(devpath, drv, info)) {\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool erupter_emerald_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"Block\", \"Erupter\", \"Emerald\");\n}\n\nstatic bool erupter_emerald_detect_one(const char *devpath)\n{\n\t// For detection via BEE:*\n\treturn _erupter_detect_one(devpath, &erupter_drv_emerald);\n}\n\nstatic\nbool erupter_emerald_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, erupter_emerald_detect_one);\n}\n\nstatic\nbool erupter_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_vcom, \"Block\", \"Erupter\");\n}\n\nstatic bool erupter_detect_one(const char *devpath)\n{\n\tstruct device_drv *drv = &erupter_drv;\n\t\n\t// For autodetection\n\tif (unlikely(detectone_meta_info.product && strstr(detectone_meta_info.product, \"Emerald\")))\n\t\tdrv = &erupter_drv_emerald;\n\t\n\treturn _erupter_detect_one(devpath, drv);\n}\n\nstatic\nbool erupter_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, erupter_detect_one);\n}\n\nstatic bool erupter_identify(struct cgpu_info *erupter)\n{\n\tstruct thr_info *thr = erupter->thr[0];\n\tstruct icarus_state *state = thr->cgpu_data;\n\tstate->identify = true;\n\treturn true;\n}\n\nstatic void erupter_drv_init()\n{\n\terupter_drv = icarus_drv;\n\terupter_drv.dname = \"erupter\";\n\terupter_drv.name = \"BES\";\n\terupter_drv.lowl_match = erupter_lowl_match;\n\terupter_drv.lowl_probe = erupter_lowl_probe;\n\terupter_drv.identify_device = erupter_identify;\n\terupter_drv.probe_priority = -120;\n\t\n\terupter_drv_emerald = erupter_drv;\n\terupter_drv_emerald.name = \"BEE\";\n\terupter_drv_emerald.lowl_match = erupter_emerald_lowl_match;\n\terupter_drv_emerald.lowl_probe = erupter_emerald_lowl_probe;\n\terupter_drv_emerald.probe_priority = -119;\n}\n\nstruct device_drv erupter_drv = {\n\t.drv_init = erupter_drv_init,\n};\n\nstruct device_drv erupter_drv_emerald = {\n\t.drv_init = erupter_drv_init,\n};\n"
        },
        {
          "name": "driver-getwork.c",
          "type": "blob",
          "size": 6.8662109375,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#include <stdint.h>\n#include <string.h>\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#endif\n\n#include <jansson.h>\n#include <microhttpd.h>\n#include <uthash.h>\n\n#include \"deviceapi.h\"\n#include \"driver-proxy.h\"\n#include \"httpsrv.h\"\n#include \"miner.h\"\n\nstatic\nvoid getwork_prepare_resp(struct MHD_Response *resp, struct MHD_Connection * const conn)\n{\n\thttpsrv_prepare_resp(resp);\n\tMHD_add_response_header(resp, MHD_HTTP_HEADER_CONTENT_TYPE, \"application/json\");\n\tMHD_add_response_header(resp, \"X-Mining-Extensions\", \"hashesdone\");\n#if MHD_VERSION >= 0x00093701\n\tconst char * const agent = MHD_lookup_connection_value(conn, MHD_HEADER_KIND, \"User-Agent\");\n\t// Block Erupter products can't handle the Connection: close header, so force HTTP/1.0 for them\n\tif (!(strcmp(agent, \"BE Cube BTC Miner\") && strcmp(agent, \"Jephis PIC Miner\")))\n\t\tMHD_set_response_options(resp, MHD_RF_HTTP_VERSION_1_0_ONLY, MHD_RO_END);\n#endif\n}\n\nstatic\nstruct MHD_Response *getwork_gen_error(int16_t errcode, const char *errmsg, const char *idstr, size_t idstr_sz, struct MHD_Connection * const conn)\n{\n\tsize_t replysz = 0x40 + strlen(errmsg) + idstr_sz;\n\tchar * const reply = malloc(replysz);\n\treplysz = snprintf(reply, replysz, \"{\\\"result\\\":null,\\\"error\\\":{\\\"code\\\":%d,\\\"message\\\":\\\"%s\\\"},\\\"id\\\":%s}\", errcode, errmsg, idstr ?: \"0\");\n\tstruct MHD_Response * const resp = MHD_create_response_from_buffer(replysz, reply, MHD_RESPMEM_MUST_FREE);\n\tgetwork_prepare_resp(resp, conn);\n\treturn resp;\n}\n\nstatic\nint getwork_error(struct MHD_Connection *conn, int16_t errcode, const char *errmsg, const char *idstr, size_t idstr_sz)\n{\n\tstruct MHD_Response * const resp = getwork_gen_error(errcode, errmsg, idstr, idstr_sz, conn);\n\tconst int ret = MHD_queue_response(conn, 500, resp);\n\tMHD_destroy_response(resp);\n\treturn ret;\n}\n\nint handle_getwork(struct MHD_Connection *conn, bytes_t *upbuf)\n{\n\tstruct proxy_client *client;\n\tstruct MHD_Response *resp;\n\tchar *user, *idstr = NULL;\n\tconst char *submit = NULL;\n\tsize_t idstr_sz = 1;\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\tjson_t *json = NULL, *j2;\n\tjson_error_t jerr;\n\tstruct work *work;\n\tchar *reply;\n\tlong long hashes_done = -1;\n\tint ret;\n\t\n\tif (bytes_len(upbuf))\n\t{\n\t\tbytes_nullterminate(upbuf);\n\t\tjson = JSON_LOADS((char*)bytes_buf(upbuf), &jerr);\n\t\tif (!json)\n\t\t{\n\t\t\tret = getwork_error(conn, -32700, \"JSON parse error\", idstr, idstr_sz);\n\t\t\tgoto out;\n\t\t}\n\t\tj2 = json_object_get(json, \"id\");\n\t\tif (j2)\n\t\t{\n\t\t\tidstr = json_dumps_ANY(j2, 0);\n\t\t\tidstr_sz = strlen(idstr);\n\t\t}\n\t\tif (strcmp(\"getwork\", bfg_json_obj_string(json, \"method\", \"getwork\")))\n\t\t{\n\t\t\tret = getwork_error(conn, -32601, \"Only getwork supported\", idstr, idstr_sz);\n\t\t\tgoto out;\n\t\t}\n\t\tj2 = json_object_get(json, \"params\");\n\t\tsubmit = j2 ? __json_array_string(j2, 0) : NULL;\n\t}\n\t\n\tuser = MHD_basic_auth_get_username_password(conn, NULL);\n\tif (!user)\n\t{\n\t\tresp = getwork_gen_error(-4096, \"Please provide a username\", idstr, idstr_sz, conn);\n\t\tret = MHD_queue_basic_auth_fail_response(conn, PACKAGE, resp);\n\t\tgoto out;\n\t}\n\t\n\tclient = proxy_find_or_create_client(user);\n\tfree(user);\n\tif (!client)\n\t{\n\t\tret = getwork_error(conn, -32603, \"Failed creating new cgpu\", idstr, idstr_sz);\n\t\tgoto out;\n\t}\n\tcgpu = client->cgpu;\n\tthr = cgpu->thr[0];\n\t\n\t{\n\t\tconst char * const hashesdone = MHD_lookup_connection_value(conn, MHD_HEADER_KIND, \"X-Hashes-Done\");\n\t\tif (hashesdone)\n\t\t\thashes_done = strtoll(hashesdone, NULL, 0);\n\t}\n\t\n\tif (submit)\n\t{\n\t\tunsigned char hdr[80];\n\t\tconst char *rejreason;\n\t\tuint32_t nonce;\n\t\t\n\t\t// NOTE: expecting hex2bin to fail since we only parse 80 of the 128\n\t\thex2bin(hdr, submit, 80);\n\t\tnonce = le32toh(*(uint32_t *)&hdr[76]);\n\t\tHASH_FIND(hh, client->work, hdr, 76, work);\n\t\tif (!work)\n\t\t{\n\t\t\tinc_hw_errors2(thr, NULL, &nonce);\n\t\t\trejreason = \"unknown-work\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!submit_nonce(thr, work, nonce))\n\t\t\t\trejreason = \"H-not-zero\";\n\t\t\telse\n\t\t\tif (stale_work(work, true))\n\t\t\t\trejreason = \"stale\";\n\t\t\telse\n\t\t\t\trejreason = NULL;\n\t\t\t\n\t\t\tif (hashes_done == -1)\n\t\t\t\thashes_done = (double)0x100000000 * work->nonce_diff;\n\t\t}\n\t\t\n\t\treply = malloc(36 + idstr_sz);\n\t\tconst size_t replysz =\n\t\tsprintf(reply, \"{\\\"error\\\":null,\\\"result\\\":%s,\\\"id\\\":%s}\",\n\t\t        rejreason ? \"false\" : \"true\", idstr);\n\t\tresp = MHD_create_response_from_buffer(replysz, reply, MHD_RESPMEM_MUST_FREE);\n\t\tgetwork_prepare_resp(resp, conn);\n\t\tMHD_add_response_header(resp, \"X-Mining-Identifier\", cgpu->proc_repr);\n\t\tif (rejreason)\n\t\t\tMHD_add_response_header(resp, \"X-Reject-Reason\", rejreason);\n\t\tret = MHD_queue_response(conn, 200, resp);\n\t\tMHD_destroy_response(resp);\n\t\tgoto out;\n\t}\n\t\n\tif (cgpu->deven == DEV_DISABLED)\n\t{\n\t\tresp = getwork_gen_error(-10, \"Virtual device has been disabled\", idstr, idstr_sz, conn);\n\t\tMHD_add_response_header(resp, \"X-Mining-Identifier\", cgpu->proc_repr);\n\t\tret = MHD_queue_response(conn, 500, resp);\n\t\tMHD_destroy_response(resp);\n\t\tgoto out;\n\t}\n\t\n\t{\n\t\tsize_t replysz = 590 + idstr_sz;\n\t\t\n\t\twork = get_work(thr);\n\t\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\t\twork->nonce_diff = client->desired_share_pdiff ?: malgo->reasonable_low_nonce_diff;\n\t\tif (work->nonce_diff > work->work_difficulty)\n\t\t\twork->nonce_diff = work->work_difficulty;\n\t\t\n\t\treply = malloc(replysz);\n\t\tuint8_t target[0x20];\n\t\tset_target_to_pdiff(target, work->nonce_diff);\n\t\tmemcpy(reply, \"{\\\"error\\\":null,\\\"result\\\":{\\\"target\\\":\\\"\", 34);\n\t\tbin2hex(&reply[34], target, sizeof(target));\n\t\tmemcpy(&reply[98], \"\\\",\\\"data\\\":\\\"\", 10);\n\t\tbin2hex(&reply[108], work->data, 128);\n\t\tmemcpy(&reply[364], \"\\\",\\\"midstate\\\":\\\"\", 14);\n\t\tbin2hex(&reply[378], work->midstate, 32);\n\t\tmemcpy(&reply[442], \"\\\",\\\"hash1\\\":\\\"00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000\\\"},\\\"id\\\":\", 147);\n\t\tmemcpy(&reply[589], idstr ?: \"0\", idstr_sz);\n\t\tmemcpy(&reply[589 + idstr_sz], \"}\", 1);\n#ifdef USE_SCRYPT\n\t\tif (malgo->algo == POW_SCRYPT)\n\t\t{\n\t\t\treplysz += 21;\n\t\t\treply = realloc(reply, replysz);\n\t\t\tmemmove(&reply[443 + 21], &reply[443], replysz - (443 + 21));\n\t\t\tmemcpy(&reply[443], \",\\\"algorithm\\\":\\\"scrypt\\\"\", 21);\n\t\t}\n#endif\n\t\t\n\t\ttimer_set_now(&work->tv_work_start);\n\t\tHASH_ADD_KEYPTR(hh, client->work, work->data, 76, work);\n\t\t\n\t\tresp = MHD_create_response_from_buffer(replysz, reply, MHD_RESPMEM_MUST_FREE);\n\t\tgetwork_prepare_resp(resp, conn);\n\t\tMHD_add_response_header(resp, \"X-Mining-Identifier\", cgpu->proc_repr);\n\t\tret = MHD_queue_response(conn, 200, resp);\n\t\tMHD_destroy_response(resp);\n\t}\n\t\nout:\n\tif (hashes_done != -1)\n\t\thashes_done2(thr, hashes_done, NULL);\n\t\n\tfree(idstr);\n\tif (json)\n\t\tjson_decref(json);\n\treturn ret;\n}\n"
        },
        {
          "name": "driver-gridseed.c",
          "type": "blob",
          "size": 12.37890625,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2014 GridSeed Team\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n\n#include \"deviceapi.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"gc3355.h\"\n\n#define GRIDSEED_DEFAULT_FREQUENCY  600\n// 60Kh/s at 700MHz in ms\n#define GRIDSEED_HASH_SPEED         0.08571428571429\n// GridSeed driver currently scans a full nonce range\n#define GRIDSEED_MAX_NONCE          0xffffffff\n\nBFG_REGISTER_DRIVER(gridseed_drv)\n\nstatic const struct bfg_set_device_definition gridseed_set_device_funcs_probe[];\nstatic const struct bfg_set_device_definition gridseed_set_device_funcs_live[];\n\n/*\n * helper functions\n */\n\nstatic\nstruct cgpu_info *gridseed_alloc_device(const char *path, struct device_drv *driver, struct gc3355_info *info)\n{\n\tstruct cgpu_info *device = calloc(1, sizeof(struct cgpu_info));\n\tif (unlikely(!device))\n\t\tquit(1, \"Failed to malloc cgpu_info\");\n\t\n\tdevice->drv = driver;\n\tdevice->device_path = strdup(path);\n\tdevice->device_fd = -1;\n\tdevice->threads = 1;\n\tdevice->device_data = info;\n\tdevice->set_device_funcs = gridseed_set_device_funcs_live;\n\t\n\treturn device;\n}\n\nstatic\nstruct gc3355_info *gridseed_alloc_info()\n{\n\tstruct gc3355_info *info = calloc(1, sizeof(struct gc3355_info));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc gc3355_info\");\n\t\n\tinfo->freq = GRIDSEED_DEFAULT_FREQUENCY;\n\t\n\treturn info;\n}\n\nstatic\nvoid gridseed_empty_work(int fd)\n{\n\tunsigned char buf[GC3355_READ_SIZE];\n\tgc3355_read(fd, (char *)buf, GC3355_READ_SIZE);\n}\n\nstatic\nstruct thr_info *gridseed_thread_by_chip(const struct cgpu_info * const device, uint32_t const chip)\n{\n\tconst struct cgpu_info *proc = device_proc_by_id(device, chip);\n\tif (unlikely(!proc))\n\t\tproc = device;\n\treturn proc->thr[0];\n}\n\n// return the number of hashes done in elapsed_ms\nstatic\nint64_t gridseed_calculate_chip_hashes_ms(const struct cgpu_info * const device, int const elapsed_ms)\n{\n\tstruct gc3355_info *info = device->device_data;\n\treturn GRIDSEED_HASH_SPEED * (double)elapsed_ms * (double)(info->freq);\n}\n\n// return the number of hashes done since start_tv\nstatic\nint64_t gridseed_calculate_chip_hashes(const struct cgpu_info * const device, struct timeval const start_tv)\n{\n\tstruct timeval now_tv;\n\ttimer_set_now(&now_tv);\n\tint elapsed_ms = ms_tdiff(&now_tv, &start_tv);\n\n\treturn gridseed_calculate_chip_hashes_ms(device, elapsed_ms);\n}\n\n// adjust calculated hashes that overflow possible values\nstatic\nint64_t gridseed_fix_hashes_done(int64_t const hashes_done)\n{\n\tint64_t result = hashes_done;\n\n\t// not possible to complete more than 0xffffffff nonces\n\tif (unlikely(result > 0xffffffff))\n\t\tresult = 0xffffffff;\n\n\treturn result;\n}\n\n// report on hashes done since start_tv\n// return the number of hashes done since start_tv\nstatic\nint64_t gridseed_hashes_done(struct cgpu_info * const device, struct timeval const start_tv, int64_t previous_hashes)\n{\n\tint64_t total_chip_hashes = gridseed_calculate_chip_hashes(device, start_tv);\n\ttotal_chip_hashes = gridseed_fix_hashes_done(total_chip_hashes);\n\n\tint64_t previous_chip_hashes = previous_hashes / device->procs;\n\tint64_t recent_chip_hashes = total_chip_hashes - previous_chip_hashes;\n\tint64_t total_hashes = 0;\n\n\tfor_each_managed_proc(proc, device)\n\t{\n\t\ttotal_hashes += recent_chip_hashes;\n\t\thashes_done2(proc->thr[0], recent_chip_hashes, NULL);\n\t}\n\n\treturn total_hashes;\n}\n\n// return duration in seconds for device to scan a nonce range\nstatic\nuint32_t gridseed_nonce_range_duration(const struct cgpu_info * const device)\n{\n\tstruct gc3355_info *info = device->device_data;\n\n\t// total hashrate of this device:\n\tuint32_t hashes_per_sec = gridseed_calculate_chip_hashes_ms(device, 1000) * info->chips;\n\t// amount of time it takes this device to scan a nonce range:\n\tuint32_t nonce_range_sec = 0xffffffff / hashes_per_sec;\n\n\treturn nonce_range_sec;\n}\n\n/*\n * device detection\n */\n\nstatic\nbool gridseed_detect_custom(const char *path, struct device_drv *driver, struct gc3355_info *info)\n{\n\tint fd = gc3355_open(path);\n\tif(fd < 0)\n\t\treturn false;\n\t\n\tgridseed_empty_work(fd);\n\t\n\tint64_t fw_version = gc3355_get_firmware_version(fd);\n\t\n\tif (fw_version == -1)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Invalid detect response from %s\", gridseed_drv.dname, path);\n\t\tgc3355_close(fd);\n\t\treturn false;\n\t}\n\t\n\tif (serial_claim_v(path, driver))\n\t\treturn false;\n\t\n\tinfo->chips = GC3355_ORB_DEFAULT_CHIPS;\n\tif((fw_version & 0xffff) == 0x1402)\n\t\tinfo->chips = GC3355_BLADE_DEFAULT_CHIPS;\n\t\n\t//pick up any user-defined settings passed in via --set\n\tdrv_set_defaults(driver, gridseed_set_device_funcs_probe, info, path, detectone_meta_info.serial, 1);\n\t\n\tstruct cgpu_info *device = gridseed_alloc_device(path, driver, info);\n\tdevice->device_fd = fd;\n\tdevice->procs = info->chips;\n\t\n\tif (!add_cgpu(device))\n\t\treturn false;\n\t\n\tgc3355_init_miner(device->device_fd, info->freq);\n\t\n\tapplog(LOG_INFO, \"Found %\"PRIpreprv\" at %s\", device->proc_repr, path);\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Init: firmware=%\"PRId64\", chips=%d\", device->proc_repr, fw_version, info->chips);\n\t\n\treturn true;\n}\n\nstatic\nbool gridseed_detect_one(const char *path)\n{\n\tstruct gc3355_info *info = gridseed_alloc_info();\n\t\n\tif (!gridseed_detect_custom(path, &gridseed_drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool gridseed_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, gridseed_detect_one);\n}\n\n/*\n * setup & shutdown\n */\n\nstatic\nvoid gridseed_thread_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\n\tgc3355_close(device->device_fd);\n}\n\n/*\n * scanhash mining loop\n */\n\n// send work to the device\nstatic\nbool gridseed_job_start(const struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tunsigned char cmd[156];\n\n\tgc3355_scrypt_reset(device->device_fd);\n\tgc3355_scrypt_prepare_work(cmd, work);\n\n\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_DataSheet.pdf\n\t// WAIT: Before start a new transaction, WAIT Cycle must be inserted.\n\t// WAIT Cycle value is programmable register in UART and default wait\n\t// time is UART receive 32 bits time (One DATA Cycle).\n\t// Note: prevents register corruption\n\tcgsleep_ms(100);\n\t\n\t// send work\n\tif (sizeof(cmd) != gc3355_write(device->device_fd, cmd, sizeof(cmd)))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to send work\", device->dev_repr);\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t\treturn false;\n\t}\n\n\t// after sending work to the device, minerloop_scanhash-based\n\t// drivers must set work->blk.nonce to the last nonce to hash\n\twork->blk.nonce = GRIDSEED_MAX_NONCE;\n\n\treturn true;\n}\n\nstatic\nvoid gridseed_submit_nonce(struct thr_info * const thr, const unsigned char buf[GC3355_READ_SIZE], struct work * const work)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\t\n\tuint32_t nonce = *(uint32_t *)(buf + 4);\n\tnonce = le32toh(nonce);\n\tuint32_t chip = nonce / (GRIDSEED_MAX_NONCE / device->procs);\n\t\n\tstruct thr_info *proc_thr = gridseed_thread_by_chip(device, chip);\n\t\n\tsubmit_nonce(proc_thr, work, nonce);\n}\n\n// read from device for nonce or command\n// unless the device can target specific nonce ranges, the scanhash routine should loop\n// until the device has processed the work item, scanning the full nonce range\n// return the total number of hashes done\nstatic\nint64_t gridseed_scanhash(struct thr_info *thr, struct work *work, int64_t __maybe_unused max_nonce)\n{\n\tstruct cgpu_info *device = thr->cgpu;\n\tstruct timeval start_tv, nonce_range_tv, report_hashes_tv;\n\n\t// amount of time it takes this device to scan a nonce range:\n\tuint32_t nonce_full_range_sec = gridseed_nonce_range_duration(device);\n\t// timer to break out of scanning should we close in on an entire nonce range\n\t// should break out before the range is scanned, so we are doing 99% of the range\n\tuint64_t nonce_near_range_usec = (nonce_full_range_sec * 1000000. * 0.99);\n\ttimer_set_delay_from_now(&nonce_range_tv, nonce_near_range_usec);\n\n\t// timer to calculate hashes every 10s\n\tconst uint32_t report_delay = 10 * 1000000;\n\ttimer_set_delay_from_now(&report_hashes_tv, report_delay);\n\n\t// start the job\n\ttimer_set_now(&start_tv);\n\tgridseed_job_start(thr, work);\n\n\t// scan for results\n\tunsigned char buf[GC3355_READ_SIZE];\n\tint read = 0;\n\tint fd = device->device_fd;\n\tint64_t total_hashes = 0;\n\tbool range_nearly_scanned = false;\n\n\twhile (!thr->work_restart                                                   // true when new work is available (miner.c)\n\t    && ((read = gc3355_read(fd, (char *)buf, GC3355_READ_SIZE)) >= 0)       // only check for failure - allow 0 bytes\n\t    && !(range_nearly_scanned = timer_passed(&nonce_range_tv, NULL)))       // true when we've nearly scanned a nonce range\n\t{\n\t\tif (timer_passed(&report_hashes_tv, NULL))\n\t\t{\n\t\t\ttotal_hashes += gridseed_hashes_done(device, start_tv, total_hashes);\n\t\t\ttimer_set_delay_from_now(&report_hashes_tv, report_delay);\n\t\t}\n\n\t\tif (read == 0)\n\t\t\tcontinue;\n\n\t\tif ((buf[0] == 0x55) && (buf[1] == 0x20))\n\t\t\tgridseed_submit_nonce(thr, buf, work);\n\t\telse\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Unrecognized response\", device->proc_repr);\n\t}\n\n\tif (read == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to read result\", device->dev_repr);\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t}\n\n\t// calculate remaining hashes for elapsed time\n\t// e.g. work_restart ~report_delay after report_hashes_tv\n\tgridseed_hashes_done(device, start_tv, total_hashes);\n\n\treturn 0;\n}\n\n/*\n * specify settings / options via RPC or command line\n */\n\n// support for --set-device\n// must be set before probing the device\n\nstatic\nvoid gridseed_set_clock_freq(struct cgpu_info * const device, int const val)\n{\n\tstruct gc3355_info * const info = device->device_data;\n\n\tif ((info->freq != val) &&                          // method called for each processor, we only want to set pll once\n\t    (device->device_fd > 0))                        // we may not be mining yet, in which case just store freq\n\t    gc3355_set_pll_freq(device->device_fd, val);    // clock was set via RPC or TUI\n\n\tinfo->freq = val;\n}\n\nstatic\nconst char *gridseed_set_clock(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tgridseed_set_clock_freq(device, atoi(setting));\n\n\treturn NULL;\n}\n\nstatic\nconst char *gridseed_set_chips(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct gc3355_info * const info = device->device_data;\n\tint val = atoi(setting);\n\t\n\tinfo->chips = val;\n\t\n\treturn NULL;\n}\n\n// for setting clock and chips during probe / detect\nstatic\nconst struct bfg_set_device_definition gridseed_set_device_funcs_probe[] = {\n\t{ \"clock\", gridseed_set_clock, NULL },\n\t{ \"chips\", gridseed_set_chips, NULL },\n\t{ NULL },\n};\n\n// for setting clock while mining\nstatic\nconst struct bfg_set_device_definition gridseed_set_device_funcs_live[] = {\n\t{ \"clock\", gridseed_set_clock, NULL },\n\t{ NULL },\n};\n\n/*\n * specify settings / options via TUI\n */\n\n#ifdef HAVE_CURSES\nstatic\nvoid gridseed_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *gridseed_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstatic char buf[0x100];  // Static for replies\n\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tsprintf(buf, \"Set clock speed\");\n\t\t\tchar * const setting = curses_input(buf);\n\n\t\t\tgridseed_set_clock_freq(proc->device, atoi(setting));\n\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid gridseed_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct gc3355_info * const info = proc->device->device_data;\n\twlogprint(\"Clock speed: %d\\n\", info->freq);\n}\n#endif\n\nstruct device_drv gridseed_drv =\n{\n\t// metadata\n\t.dname = \"gridseed\",\n\t.name = \"GSD\",\n\t.drv_min_nonce_diff = common_scrypt_min_nonce_diff,\n\t\n\t// detect device\n\t.lowl_probe = gridseed_lowl_probe,\n\t\n\t// specify mining type - scanhash\n\t.minerloop = minerloop_scanhash,\n\t\n\t// scanhash mining hooks\n\t.scanhash = gridseed_scanhash,\n\t\n\t// teardown device\n\t.thread_shutdown = gridseed_thread_shutdown,\n\n\t// TUI support - e.g. setting clock via UI\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = gridseed_wlogprint_status,\n\t.proc_tui_wlogprint_choices = gridseed_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = gridseed_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-hashbuster.c",
          "type": "blob",
          "size": 7.9384765625,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n * Copyright 2013 Vladimir Strinski\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-hid.h\"\n#include \"miner.h\"\n\n#define HASHBUSTER_USB_PRODUCT \"HashBuster\"\n\n#define HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER 62\n\nBFG_REGISTER_DRIVER(hashbuster_drv)\n\nstatic\nbool hashbuster_io(hid_device * const h, void * const buf, const void * const cmd)\n{\n\tconst uint8_t cmdbyte = *((uint8_t *)cmd);\n\tchar x[0x81];\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tbin2hex(x, cmd, 0x40);\n\t\tapplog(LOG_DEBUG, \"%s(%p): SEND: %s\", __func__, h, x);\n\t}\n\tconst bool rv = likely(\n\t\t0x40 == hid_write(h, cmd, 0x40) &&\n\t\t0x40 == hid_read (h, buf, 0x40) &&\n\t\t((uint8_t *)buf)[0] == cmdbyte\n\t);\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tbin2hex(x, buf, 0x40);\n\t\tapplog(LOG_DEBUG, \"%s(%p): RECV: %s\", __func__, h, x);\n\t}\n\treturn rv;\n}\n\nstatic\nbool hashbuster_spi_config(hid_device * const h, const uint8_t mode, const uint8_t miso, const uint32_t freq)\n{\n\tuint8_t buf[0x40] = {'\\x01', '\\x01', mode, miso};\n\tswitch (freq)\n\t{\n\t\tcase 100000:\n\t\t\tbuf[4] = '\\0';\n\t\t\tbreak;\n\t\tcase 750000:\n\t\t\tbuf[4] = '\\x01';\n\t\t\tbreak;\n\t\tcase 3000000:\n\t\t\tbuf[4] = '\\x02';\n\t\t\tbreak;\n\t\tcase 12000000:\n\t\t\tbuf[4] = '\\x03';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\tif (!hashbuster_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == '\\x0f');\n}\n\nstatic\nbool hashbuster_spi_disable(hid_device * const h)\n{\n\tuint8_t buf[0x40] = {'\\x01'};\n\tif (!hashbuster_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == '\\x0f');\n}\n\nstatic\nbool hashbuster_spi_reset(hid_device * const h, uint8_t chips)\n{\n\tuint8_t buf[0x40] = {'\\x02', chips};\n\tif (!hashbuster_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == 0xff);\n}\n\nstatic\nbool hashbuster_spi_transfer(hid_device * const h, void * const buf, const void * const data, size_t datasz)\n{\n\tif (datasz > HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER)\n\t\treturn false;\n\tuint8_t cbuf[0x40] = {'\\x03', datasz};\n\tmemcpy(&cbuf[2], data, datasz);\n\tif (!hashbuster_io(h, cbuf, cbuf))\n\t\treturn false;\n\tif (cbuf[1] != datasz)\n\t\treturn false;\n\tmemcpy(buf, &cbuf[2], datasz);\n\treturn true;\n}\n\nstatic\nbool hashbuster_spi_txrx(struct spi_port * const port)\n{\n\thid_device * const h = port->userp;\n\tconst uint8_t *wrbuf = spi_gettxbuf(port);\n\tuint8_t *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\t\n\thashbuster_spi_disable(h);\n\thashbuster_spi_reset(h, 0x10);\n\t\n\thashbuster_spi_config(h, port->mode, 0, port->speed);\n\t\n\twhile (bufsz >= HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER)\n\t{\n\t\tif (!hashbuster_spi_transfer(h, rdbuf, wrbuf, HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER))\n\t\t\treturn false;\n\t\trdbuf += HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t\twrbuf += HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t\tbufsz -= HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t}\n\t\n\tif (bufsz > 0)\n\t{\n\t\tif (!hashbuster_spi_transfer(h, rdbuf, wrbuf, bufsz))\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool hashbuster_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_hid, HASHBUSTER_USB_PRODUCT);\n}\n\nstatic\nint hashbuster_chip_count(hid_device *h)\n{\n\t/* Do not allocate spi_port on the stack! OS X, at least, has a 512 KB default stack size for secondary threads */\n\tstruct spi_port *spi = malloc(sizeof(*spi));\n\tspi->txrx = hashbuster_spi_txrx;\n\tspi->userp = h;\n\tspi->repr = hashbuster_drv.dname;\n\tspi->logprio = LOG_DEBUG;\n\tspi->speed = 100000;\n\tspi->mode = 0;\n\t\n\tconst int chip_count = libbitfury_detectChips1(spi);\n\t\n\tfree(spi);\n\t\n\treturn chip_count;\n}\n\nstatic\nbool hashbuster_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tconst char * const product = info->product;\n\tconst char * const serial = info->serial;\n\tchar * const path = info->path;\n\thid_device *h;\n\tuint8_t buf[0x40] = {'\\xfe'};\n\t\n\tif (info->lowl != &lowl_hid)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplogr(false, LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not hid!\",\n\t\t       __func__, product, serial);\n\t}\n\t\n\tif (info->vid != 0xFA04 || info->pid != 0x0011)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplogr(false, LOG_DEBUG, \"%s: Wrong VID/PID\", __func__);\n\t}\n\t\n\th = hid_open_path(path);\n\tif (!h)\n\t\tapplogr(false, LOG_WARNING, \"%s: Failed to open HID path %s\",\n\t\t       __func__, path);\n\t\n\tif ((!hashbuster_io(h, buf, buf)) || buf[1] != 0x07)\n\t{\n\t\thid_close(h);\n\t\tapplogr(false, LOG_DEBUG, \"%s: Identify sequence didn't match on %s\",\n\t\t        __func__, path);\n\t}\n\t\t\n\tconst int chip_n = hashbuster_chip_count(h);\n\t\n\thid_close(h);\n\t\n\tif (lowlevel_claim(&hashbuster_drv, true, info))\n\t\treturn false;\n\t\n\tstruct cgpu_info *cgpu;\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &hashbuster_drv,\n\t\t.set_device_funcs = bitfury_set_device_funcs,\n\t\t.device_data = lowlevel_ref(info),\n\t\t.threads = 1,\n\t\t.procs = chip_n,\n\t\t.device_path = strdup(info->path),\n\t\t.dev_manufacturer = maybe_strdup(info->manufacturer),\n\t\t.dev_product = maybe_strdup(product),\n\t\t.dev_serial = maybe_strdup(serial),\n\t\t.deven = DEV_ENABLED,\n\t};\n\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nbool hashbuster_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct bitfury_device *bitfury;\n\tstruct spi_port *port;\n\thid_device *h;\n\t\n\th = hid_open_path(cgpu->device_path);\n\tlowlevel_devinfo_free(cgpu->device_data);\n\t\n\tif (!h)\n\t{\n\t\thid_close(h);\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to open hid device\", cgpu->dev_repr);\n\t}\n\t\n\tport = malloc(sizeof(*port));\n\tif (!port)\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to allocate spi_port\", cgpu->dev_repr);\n\t\n\t/* Be careful, read lowl-spi.h comments for warnings */\n\tmemset(port, 0, sizeof(*port));\n\tport->txrx = hashbuster_spi_txrx;\n\tport->userp = h;\n\tport->cgpu = cgpu;\n\tport->repr = cgpu->dev_repr;\n\tport->logprio = LOG_ERR;\n\tport->speed = 100000;\n\tport->mode = 0;\n\t\n\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tbitfury = malloc(sizeof(*bitfury));\n\t\t\n\t\tif (!bitfury)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to allocate bitfury_device\",\n\t\t\t       cgpu->proc_repr);\n\t\t\tproc->status = LIFE_DEAD2;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t*bitfury = (struct bitfury_device){\n\t\t\t.spi = port,\n\t\t};\n\t\tproc->device_data = bitfury;\n\t\tbitfury_init_chip(proc);\n\t\tbitfury->osc6_bits = 53;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\tcgpu->status = LIFE_INIT2;\n\treturn true;\n}\n\nstatic\nbool hashbuster_get_stats(struct cgpu_info * const cgpu)\n{\n\tstruct cgpu_info *proc;\n\tif (cgpu != cgpu->device)\n\t\treturn true;\n\t\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\thid_device * const h = spi->userp;\n\tuint8_t buf[0x40] = {'\\x04'};\n\tif (!hashbuster_io(h, buf, buf))\n\t\treturn false;\n\tif (buf[1])\n\t{\n\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t\tproc->temp = buf[1];\n\t}\n\treturn true;\n}\n\nstruct device_drv hashbuster_drv = {\n\t.dname = \"hashbuster\",\n\t.name = \"HBR\",\n\t.lowl_match = hashbuster_lowl_match,\n\t.lowl_probe = hashbuster_lowl_probe,\n\t\n\t.thread_init = hashbuster_init,\n\t.thread_disable = bitfury_disable,\n\t.thread_enable = bitfury_enable,\n\t.thread_shutdown = bitfury_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = bitfury_do_io,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_stats = hashbuster_get_stats,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-hashbusteravalon.c",
          "type": "blob",
          "size": 1.57421875,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"deviceapi.h\"\n#include \"driver-klondike.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n\nBFG_REGISTER_DRIVER(hashbusteravalon_drv)\n\nstatic\nbool hashbusteravalon_lowl_match(const struct lowlevel_device_info * const info)\n{\n\tif (!lowlevel_match_id(info, &lowl_usb, 0xfa05, 0x0001))\n\t\treturn false;\n\treturn (info->manufacturer && strstr(info->manufacturer, \"HashBuster\"));\n}\n\nstatic\nbool hashbusteravalon_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tstruct klondike_info * const klninfo = malloc(sizeof(*klninfo));\n\tif (unlikely(!klninfo))\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to malloc klninfo\", __func__);\n\t\n\t*klninfo = (struct klondike_info){\n\t\t.clock = 2425,\n\t\t.max_work_count = 0x20,\n\t\t.old_work_ms = 30000,\n\t\t.reply_wait_time = 5,\n\t};\n\t\n\treturn klondike_lowl_probe_custom(info, &hashbusteravalon_drv, klninfo);\n}\n\nstatic void hashbusteravalon_drv_init()\n{\n\thashbusteravalon_drv = klondike_drv;\n\thashbusteravalon_drv.dname = \"hashbusteravalon\";\n\thashbusteravalon_drv.name = \"HBA\";\n\thashbusteravalon_drv.lowl_match = hashbusteravalon_lowl_match;\n\thashbusteravalon_drv.lowl_probe = hashbusteravalon_lowl_probe;\n}\n\nstruct device_drv hashbusteravalon_drv = {\n\t.drv_init = hashbusteravalon_drv_init,\n};\n"
        },
        {
          "name": "driver-hashbusterusb.c",
          "type": "blob",
          "size": 16.1220703125,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n * Copyright 2013 Vladimir Strinski\n * Copyright 2013 HashBuster team\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-usb.h\"\n#include \"miner.h\"\n\n#define HASHBUSTER_USB_PRODUCT \"HashBuster\"\n\n#define HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER 61\n\nBFG_REGISTER_DRIVER(hashbusterusb_drv)\nstatic const struct bfg_set_device_definition hashbusterusb_set_device_funcs[];\n\nstruct hashbusterusb_state {\n\tuint16_t voltage;\n\tstruct timeval identify_started;\n\tbool identify_requested;\n};\n\nstatic\nbool hashbusterusb_io(struct lowl_usb_endpoint * const h, unsigned char *buf, unsigned char *cmd)\n{\n\tchar x[0x81];\n\t\n\tbool rv = true;\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tbin2hex(x, cmd, 0x40);\n\t\tapplog(LOG_DEBUG, \"%s(%p): SEND: %s\", __func__, h, x);\n\t}\n\t\n\tdo // Workaround for PIC USB buffer corruption. We should repeat last packet if receive FF\n\t{\n\t\tdo\n\t\t{\n\t\t\tusb_write(h, cmd, 64);\n\t\t} while (usb_read(h, buf, 64) != 64);\n\t} while(buf[0]==0xFF);\n\t\n\tif (unlikely(opt_dev_protocol))\n\t{\n\t\tbin2hex(x, buf, 0x40);\n\t\tapplog(LOG_DEBUG, \"%s(%p): RECV: %s\", __func__, h, x);\n\t}\n\treturn rv;\n}\n\nstatic\nbool hashbusterusb_spi_config(struct lowl_usb_endpoint * const h, const uint8_t mode, const uint8_t miso, const uint32_t freq)\n{\n\tuint8_t buf[0x40] = {'\\x01', '\\x01'};\n\tif (!hashbusterusb_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == '\\x00');\n}\n\nstatic\nbool hashbusterusb_spi_disable(struct lowl_usb_endpoint * const h)\n{\n\tuint8_t buf[0x40] = {'\\x01', '\\x00'};\n\tif (!hashbusterusb_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == '\\x00');\n}\n\nstatic\nbool hashbusterusb_spi_reset(struct lowl_usb_endpoint * const h, uint8_t chips)\n{\n\tuint8_t buf[0x40] = {'\\x02', '\\x00', chips};\n\tif (!hashbusterusb_io(h, buf, buf))\n\t\treturn false;\n\treturn (buf[1] == '\\x00');\n}\n\nstatic\nbool hashbusterusb_spi_transfer(struct lowl_usb_endpoint * const h, void * const buf, const void * const data, size_t datasz)\n{\n\tif (datasz > HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER)\n\t\treturn false;\n\tuint8_t cbuf[0x40] = {'\\x03', '\\x00', datasz};\n\tmemcpy(&cbuf[3], data, datasz);\n\tif (!hashbusterusb_io(h, cbuf, cbuf))\n\t\treturn false;\n\tif (cbuf[2] != datasz)\n\t\treturn false;\n\tmemcpy(buf, &cbuf[3], datasz);\n\treturn true;\n}\n\nstatic\nbool hashbusterusb_spi_txrx(struct spi_port * const port)\n{\n\tstruct lowl_usb_endpoint * const h = port->userp;\n\tconst uint8_t *wrbuf = spi_gettxbuf(port);\n\tuint8_t *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\t\n\thashbusterusb_spi_disable(h);\n\thashbusterusb_spi_reset(h, 0x10);\n\t\n\thashbusterusb_spi_config(h, port->mode, 0, port->speed);\n\t\n\twhile (bufsz >= HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER)\n\t{\n\t\tif (!hashbusterusb_spi_transfer(h, rdbuf, wrbuf, HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER))\n\t\t\treturn false;\n\t\trdbuf += HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t\twrbuf += HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t\tbufsz -= HASHBUSTER_MAX_BYTES_PER_SPI_TRANSFER;\n\t}\n\t\n\tif (bufsz > 0)\n\t{\n\t\tif (!hashbusterusb_spi_transfer(h, rdbuf, wrbuf, bufsz))\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool hashbusterusb_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_id(info, &lowl_usb, 0xFA04, 0x000D);\n}\n\nstatic\nbool hashbusterusb_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tstruct cgpu_info *cgpu = NULL;\n\tstruct bitfury_device **devicelist, *bitfury;\n\tstruct spi_port *port;\n\tint j;\n\tstruct cgpu_info dummy_cgpu;\n\tconst char * const product = info->product;\n\tchar *serial = info->serial;\n\tlibusb_device_handle *h;\n\t\n\tif (info->lowl != &lowl_usb)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplogr(false, LOG_DEBUG, \"%s: Matched \\\"%s\\\" %s, but lowlevel driver is not usb_generic!\",\n\t\t       __func__, product, info->devid);\n\t}\n\t\n\tif (info->vid != 0xFA04 || info->pid != 0x000D)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplogr(false, LOG_DEBUG, \"%s: Wrong VID/PID\", __func__);\n\t}\n\t\n\tlibusb_device *dev = info->lowl_data;\n\tif ( (j = libusb_open(dev, &h)) )\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to open %s: %s\",\n\t\t        __func__, info->devid, bfg_strerror(j, BST_LIBUSB));\n\tif ( (j = libusb_set_configuration(h, 1)) )\n\t{\n\t\tlibusb_close(h);\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to set configuration 1 on %s: %s\",\n\t\t        __func__, info->devid, bfg_strerror(j, BST_LIBUSB));\n\t}\n\tif ( (j = libusb_claim_interface(h, 0)) )\n\t{\n\t\tlibusb_close(h);\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to claim interface 0 on %s: %s\",\n\t\t        __func__, info->devid, bfg_strerror(j, BST_LIBUSB));\n\t}\n\tstruct lowl_usb_endpoint * const ep = usb_open_ep_pair(h, 0x81, 64, 0x01, 64);\n\tusb_ep_set_timeouts_ms(ep, 100, 0);\n\t\n\tunsigned char OUTPacket[64] = { 0xfe };\n\tunsigned char INPacket[64];\n\thashbusterusb_io(ep, INPacket, OUTPacket);\n\tif (INPacket[1] == 0x18)\n\t{\n\t\t// Turn on miner PSU\n\t\tOUTPacket[0] = 0x10;\n\t\tOUTPacket[1] = 0x00;\n\t\tOUTPacket[2] = 0x01;\n\t\thashbusterusb_io(ep, INPacket, OUTPacket);\n\t}\n\t\n\tOUTPacket[0] = '\\x20';\n\thashbusterusb_io(ep, INPacket, OUTPacket);\n\tif (!memcmp(INPacket, \"\\x20\\0\", 2))\n\t{\n\t\t// 64-bit BE serial number\n\t\tuint64_t sernum = 0;\n\t\tfor (j = 0; j < 8; ++j)\n\t\t\tsernum |= (uint64_t)INPacket[j + 2] << (j * 8);\n\t\tserial = malloc((8 * 2) + 1);\n\t\tsprintf(serial, \"%08\"PRIX64, sernum);\n\t}\n\telse\n\t\tserial = maybe_strdup(info->serial);\n\t\n\tint chip_n;\n\t\n\tport = malloc(sizeof(*port));\n\tport->cgpu = &dummy_cgpu;\n\tport->txrx = hashbusterusb_spi_txrx;\n\tport->userp = ep;\n\tport->repr = hashbusterusb_drv.dname;\n\tport->logprio = LOG_DEBUG;\n\tport->speed = 100000;\n\tport->mode = 0;\n\t\n\tchip_n = libbitfury_detectChips1(port);\n\n\tif (unlikely(!chip_n))\n\t\tchip_n = libbitfury_detectChips1(port);\n\n\tif (unlikely(!chip_n))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: No chips found on %s (serial \\\"%s\\\")\",\n\t\t       __func__, info->devid, serial);\nfail:\n\t\tusb_close_ep(ep);\n\t\tfree(port);\n\t\tfree(serial);\n\t\tlibusb_release_interface(h, 0);\n\t\tlibusb_close(h);\n\t\treturn false;\n\t}\n\t\n\tif (bfg_claim_libusb(&hashbusterusb_drv, true, dev))\n\t\tgoto fail;\n\t\n\t{\n\t\tdevicelist = malloc(sizeof(*devicelist) * chip_n);\n\t\tfor (j = 0; j < chip_n; ++j)\n\t\t{\n\t\t\tdevicelist[j] = bitfury = malloc(sizeof(*bitfury));\n\t\t\t*bitfury = (struct bitfury_device){\n\t\t\t\t.spi = port,\n\t\t\t\t.slot = 0,\n\t\t\t\t.fasync = j,\n\t\t\t};\n\t\t}\n\t\t\n\t\tcgpu = malloc(sizeof(*cgpu));\n\t\t*cgpu = (struct cgpu_info){\n\t\t\t.drv = &hashbusterusb_drv,\n\t\t\t.set_device_funcs = hashbusterusb_set_device_funcs,\n\t\t\t.procs = chip_n,\n\t\t\t.device_data = devicelist,\n\t\t\t.cutofftemp = 200,\n\t\t\t.threads = 1,\n\t\t\t.device_path = strdup(info->devid),\n\t\t\t.dev_manufacturer = maybe_strdup(info->manufacturer),\n\t\t\t.dev_product = maybe_strdup(product),\n\t\t\t.dev_serial = serial,\n\t\t\t.deven = DEV_ENABLED,\n\t\t};\n\t}\n\t\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nbool hashbusterusb_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\t\n\tstruct bitfury_device **devicelist;\n\tstruct bitfury_device *bitfury;\n\tstruct hashbusterusb_state * const state = malloc(sizeof(*state));\n\t\n\t*state = (struct hashbusterusb_state){\n\t\t.voltage = 0,\n\t};\n\tcgpu_setup_control_requests(cgpu);\n\t\n\tfor (proc = thr->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tdevicelist = proc->device_data;\n\t\tbitfury = devicelist[proc->proc_id];\n\t\tproc->device_data = bitfury;\n\t\tproc->thr[0]->cgpu_data = state;\n\t\tbitfury->spi->cgpu = proc;\n\t\tbitfury_init_chip(proc);\n\t\tbitfury->osc6_bits = 53;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);\n\t\t\n\t\tif (proc->proc_id == proc->procs - 1)\n\t\t\tfree(devicelist);\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\tcgpu->status = LIFE_INIT2;\n\treturn true;\n}\n\nstatic void hashbusterusb_set_colour(struct cgpu_info *, uint8_t, uint8_t, uint8_t);\n\nstatic\nvoid hashbusterusb_poll(struct thr_info * const master_thr)\n{\n\tstruct hashbusterusb_state * const state = master_thr->cgpu_data;\n\tstruct cgpu_info * const cgpu = master_thr->cgpu;\n\t\n\tif (state->identify_requested)\n\t{\n\t\tif (!timer_isset(&state->identify_started))\n\t\t\thashbusterusb_set_colour(cgpu, 0xff, 0, 0xff);\n\t\ttimer_set_delay_from_now(&state->identify_started, 5000000);\n\t\tstate->identify_requested = false;\n\t}\n\t\n\tbitfury_do_io(master_thr);\n\t\n\tif (timer_passed(&state->identify_started, NULL))\n\t{\n\t\thashbusterusb_set_colour(cgpu, 0, 0x7e, 0);\n\t\ttimer_unset(&state->identify_started);\n\t}\n}\n\nstatic\nbool hashbusterusb_get_stats(struct cgpu_info * const cgpu)\n{\n\tbool rv = false;\n\tstruct cgpu_info *proc;\n\tif (cgpu != cgpu->device)\n\t\treturn true;\n\t\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\tuint8_t buf[0x40] = {'\\x04'};\n\t\n\tif (hashbusterusb_io(h, buf, buf))\n\t{\n\t\tif (buf[1])\n\t\t{\n\t\t\trv = true;\n\t\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t\t\tproc->temp = buf[1];\n\t\t}\n\t}\n\t\n\tbuf[0] = '\\x15';\n\tif (hashbusterusb_io(h, buf, buf))\n\t{\n\t\tif (!memcmp(buf, \"\\x15\\0\", 2))\n\t\t{\n\t\t\trv = true;\n\t\t\tconst uint16_t voltage = (buf[3] << 8) | buf[2];\n\t\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t\t{\n\t\t\t\tstruct hashbusterusb_state * const state = proc->thr[0]->cgpu_data;\n\t\t\t\tstate->voltage = voltage;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn rv;\n}\n\nstatic\nvoid hashbusterusb_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\t\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\t\n\t// Shutdown PSU\n\tunsigned char OUTPacket[64] = { 0x10 };\n\tunsigned char INPacket[64];\n\thashbusterusb_io(h, INPacket, OUTPacket);\n}\n\nstatic\nvoid hashbusterusb_set_colour(struct cgpu_info * const cgpu, const uint8_t red, const uint8_t green, const uint8_t blue)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\t\n\tuint8_t buf[0x40] = {'\\x30', 0, red, green, blue};\n\thashbusterusb_io(h, buf, buf);\n\tapplog(LOG_DEBUG, \"%s: Set LED colour to r=0x%x g=0x%x b=0x%x\",\n\t       cgpu->dev_repr, (unsigned)red, (unsigned)green, (unsigned)blue);\n}\n\nstatic\nbool hashbusterusb_identify(struct cgpu_info * const proc)\n{\n\tstruct hashbusterusb_state * const state = proc->thr[0]->cgpu_data;\n\t\n\tstate->identify_requested = true;\n\t\n\treturn true;\n}\n\nstatic\nbool hashbusterusb_set_voltage(struct cgpu_info * const proc, const uint16_t nv)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\tunsigned char buf[0x40] = {0x11, 0, (nv & 0xff), (nv >> 8)};\n\t\n\thashbusterusb_io(h, buf, buf);\n\treturn !memcmp(buf, \"\\x11\\0\", 2);\n}\n\nstatic\nbool hashbusterusb_vrm_unlock(struct cgpu_info * const proc, const char * const code)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\tunsigned char buf[0x40] = {0x12};\n\tsize_t size;\n\t\n\tsize = strlen(code) >> 1;\n\tif (size > 63)\n\t\tsize = 63;\n\t\n\thex2bin(&buf[1], code, size);\n\t\n\thashbusterusb_io(h, buf, buf);\n\treturn !memcmp(buf, \"\\x12\\0\", 2);\n}\n\nstatic\nvoid hashbusterusb_vrm_lock(struct cgpu_info * const proc)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tstruct spi_port * const spi = bitfury->spi;\n\tstruct lowl_usb_endpoint * const h = spi->userp;\n\tunsigned char buf[0x40] = {0x14};\n\thashbusterusb_io(h, buf, buf);\n}\n\nstatic\nstruct api_data *hashbusterusb_api_extra_device_stats(struct cgpu_info * const cgpu)\n{\n\tstruct hashbusterusb_state * const state = cgpu->thr[0]->cgpu_data;\n\tstruct api_data *root = bitfury_api_device_status(cgpu);\n\t\n\tfloat volts = state->voltage;\n\tvolts /= 1000.;\n\troot = api_add_volts(root, \"Voltage\", &volts, true);\n\t\n\treturn root;\n}\n\nstatic\nconst char *hashbusterusb_rpcset_vrmlock(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tcgpu_request_control(proc->device);\n\thashbusterusb_vrm_lock(proc);\n\tcgpu_release_control(proc->device);\n\treturn NULL;\n}\n\nstatic\nconst char *hashbusterusb_rpcset_vrmunlock(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tcgpu_request_control(proc->device);\n\tconst bool rv = hashbusterusb_vrm_unlock(proc, setting);\n\tcgpu_release_control(proc->device);\n\tif (!rv)\n\t\treturn \"Unlock error\";\n\treturn NULL;\n}\n\nstatic\nconst char *hashbusterusb_rpcset_voltage(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tconst int val = atof(setting) * 1000;\n\tif (val < 600 || val > 1100)\n\t\treturn \"Invalid PSU voltage value\";\n\t\n\tcgpu_request_control(proc->device);\n\tconst bool rv = hashbusterusb_set_voltage(proc, val);\n\tcgpu_release_control(proc->device);\n\t\n\tif (!rv)\n\t\treturn \"Voltage change error\";\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition hashbusterusb_set_device_funcs[] = {\n\t{\"baud\"     , bitfury_set_baud              , \"SPI baud rate\"},\n\t{\"osc6_bits\", bitfury_set_osc6_bits         , \"range 1-\"BITFURY_MAX_OSC6_BITS_S\" (slow to fast)\"},\n\t{\"vrmlock\"  , hashbusterusb_rpcset_vrmlock  , \"Lock the VRM voltage to safe range\"},\n\t{\"vrmunlock\", hashbusterusb_rpcset_vrmunlock, \"Allow setting potentially unsafe voltages (requires unlock code)\"},\n\t{\"voltage\"  , hashbusterusb_rpcset_voltage  , \"Set voltage\"},\n\t{NULL},\n};\n\n#ifdef HAVE_CURSES\nvoid hashbusterusb_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[V]oltage \");\n\twlogprint(\"[O]scillator bits \");\n\t//wlogprint(\"[F]an speed \");  // To be implemented\n\twlogprint(\"[U]nlock VRM \");\n\twlogprint(\"[L]ock VRM \");\n}\n\nconst char *hashbusterusb_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'v': case 'V':\n\t\t{\n\t\t\tconst int val = curses_int(\"Set PSU voltage (range 600mV-1100mV. VRM unlock is required for over 870mV)\");\n\t\t\tif (val < 600 || val > 1100)\n\t\t\t\treturn \"Invalid PSU voltage value\\n\";\n\t\t\t\n\t\t\tcgpu_request_control(proc->device);\n\t\t\tconst bool rv = hashbusterusb_set_voltage(proc, val);\n\t\t\tcgpu_release_control(proc->device);\n\t\t\t\n\t\t\tif (!rv)\n\t\t\t\treturn \"Voltage change error\\n\";\n\t\t\t\n\t\t\treturn \"Voltage change successful\\n\";\n\t\t}\n\t\t\n\t\tcase 'u': case 'U':\n\t\t{\n\t\t\tchar *input = curses_input(\"VRM unlock code\");\n\t\t\t\n\t\t\tif (!input)\n\t\t\t\tinput = calloc(1, 1);\n\t\t\t\n\t\t\tcgpu_request_control(proc->device);\n\t\t\tconst bool rv = hashbusterusb_vrm_unlock(proc, input);\n\t\t\tcgpu_release_control(proc->device);\n\t\t\tfree(input);\n\t\t\t\n\t\t\tif (!rv)\n\t\t\t\treturn \"Unlock error\\n\";\n\t\t\t\n\t\t\treturn \"Unlocking PSU\\n\";\n\t\t}\n\t\t\n\t\tcase 'o': case 'O':\n\t\t\treturn bitfury_tui_handle_choice(proc, input);\n\t\t\n\t\tcase 'l': case 'L':\n\t\t{\n\t\t\tcgpu_request_control(proc->device);\n\t\t\thashbusterusb_vrm_lock(proc);\n\t\t\tcgpu_release_control(proc->device);\n\t\t\treturn \"VRM lock\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid hashbusterusb_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct hashbusterusb_state * const state = proc->thr[0]->cgpu_data;\n\t\n\tbitfury_wlogprint_status(proc);\n\t\n\twlogprint(\"PSU voltage: %umV\\n\", (unsigned)state->voltage);\n}\n#endif\n\nstruct device_drv hashbusterusb_drv = {\n\t.dname = \"hashbusterusb\",\n\t.name = \"HBR\",\n\t.lowl_match = hashbusterusb_lowl_match,\n\t.lowl_probe = hashbusterusb_lowl_probe,\n\t\n\t.thread_init = hashbusterusb_init,\n\t.thread_disable = bitfury_disable,\n\t.thread_enable = bitfury_enable,\n\t.thread_shutdown = hashbusterusb_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = hashbusterusb_poll,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_stats = hashbusterusb_get_stats,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = hashbusterusb_api_extra_device_stats,\n\t.identify_device = hashbusterusb_identify,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = hashbusterusb_wlogprint_status,\n\t.proc_tui_wlogprint_choices = hashbusterusb_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = hashbusterusb_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-hashfast.c",
          "type": "blob",
          "size": 25.294921875,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <utlist.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\nBFG_REGISTER_DRIVER(hashfast_ums_drv)\n\n#define HASHFAST_QUEUE_MEMORY 0x20\n\n#define HASHFAST_ALL_CHIPS 0xff\n#define HASHFAST_ALL_CORES 0xff\n\n#define HASHFAST_HEADER_SIZE 8\n#define HASHFAST_MAX_DATA 0x3fc\n#define HASHFAST_HASH_SIZE (0x20 + 0xc + 4 + 4 + 2 + 1 + 1)\n#define HASHFAST_MAX_VOLTAGES 4\n#define HASHFAST_CONFIG_DATA_SIZE  0x10\n\nenum hashfast_opcode {\n\tHFOP_NULL          =    0,\n\tHFOP_ROOT          =    1,\n\tHFOP_RESET         =    2,\n\tHFOP_PLL_CONFIG    =    3,\n\tHFOP_ADDRESS       =    4,\n\tHFOP_READDRESS     =    5,\n\tHFOP_HIGHEST       =    6,\n\tHFOP_BAUD          =    7,\n\tHFOP_UNROOT        =    8,\n\tHFOP_HASH          =    9,\n\tHFOP_NONCE         = 0x0a,\n\tHFOP_ABORT         = 0x0b,\n\tHFOP_STATUS        = 0x0c,\n\tHFOP_GPIO          = 0x0d,\n\tHFOP_CONFIG        = 0x0e,\n\tHFOP_STATISTICS    = 0x0f,\n\tHFOP_GROUP         = 0x10,\n\tHFOP_CLOCKGATE     = 0x11,\n\t\n\tHFOP_USB_INIT      = 0x80,\n\tHFOP_GET_TRACE     = 0x81,\n\tHFOP_LOOPBACK_USB  = 0x82,\n\tHFOP_LOOPBACK_UART = 0x83,\n\tHFOP_DFU           = 0x84,\n\tHFOP_USB_SHUTDOWN  = 0x85,\n\tHFOP_DIE_STATUS    = 0x86,\n\tHFOP_GWQ_STATUS    = 0x87,\n\tHFOP_UMS_CLOCK_CHANGE = 0x88,\n\tHFOP_WORK_RESTART  = 0x88,\n\tHFOP_USB_STATS1    = 0x89,\n\tHFOP_USB_GWQSTATS  = 0x8a,\n\tHFOP_USB_NOTICE    = 0x8b,\n\tHFOP_USB_DEBUG     = 0xff,\n};\n\nenum hashfast_config_hdata {\n\tHFCH_WRITE         = 1 << 0xf,\n\tHFCH_THERMAL_LIMIT = 1 << 0xe,\n\tHFCH_TACHO         = 1 << 0xd,\n};\n\nenum hashfast_config_flags {\n\tHFCF_STATUS_PERIOD = 1 << 0xb,\n\tHFCF_STATUS_IDLE   = 1 << 0xc,\n\tHFCF_STATUS_EMPTY  = 1 << 0xd,\n\tHFCF_PWM_ACTIVE_LV = 1 << 0xe,\n};\n\nenum hashfast_clock_change_cmd {\n\tHFWR_SET_CLOCK     = 1 << 0xc,\n};\n\ntypedef unsigned long hashfast_isn_t;\n\nstatic inline\nfloat hashfast_temperature_conv(const uint8_t * const data)\n{\n\t// Temperature is 12-bit fraction ranging between -61.5 C and ~178.5 C\n\tint32_t tempdata = ((uint32_t)data[1] << 8) | data[0];\n\ttempdata &= 0xfff;\n\ttempdata *= 240;\n\ttempdata -= 251904;  // 61.5 * 4096\n\tfloat temp = tempdata;\n\ttemp /= 4096.;\n\treturn temp;\n}\n\nstatic inline\nfloat hashfast_voltage_conv(const uint8_t vdata)\n{\n\t// Voltage is 8-bit fraction ranging between 0 V and ~1.2 V\n\treturn (float)vdata / 256. * 1.2;\n}\n\nstruct hashfast_parsed_msg {\n\tuint8_t opcode;\n\tuint8_t chipaddr;\n\tuint8_t coreaddr;\n\tuint16_t hdata;\n\tuint8_t data[HASHFAST_MAX_DATA];\n\tsize_t datalen;\n};\n\nstatic\nssize_t hashfast_write(const int fd, void * const buf, size_t bufsz)\n{\n\tconst ssize_t rv = write(fd, buf, bufsz);\n\tif ((opt_debug && opt_dev_protocol) || unlikely(rv != bufsz))\n\t{\n\t\tconst int e = errno;\n\t\tchar hex[(bufsz * 2) + 1];\n\t\tbin2hex(hex, buf, bufsz);\n\t\tif (rv < 0)\n\t\t\tapplog(LOG_WARNING, \"%s fd=%d: SEND (%s) => %d errno=%d(%s)\",\n\t\t\t       \"hashfast\", fd, hex, (int)rv, e, bfg_strerror(e, BST_ERRNO));\n\t\telse\n\t\tif (rv < bufsz)\n\t\t\tapplog(LOG_WARNING, \"%s fd=%d: SEND %.*s(%s)\",\n\t\t\t       \"hashfast\", fd, (int)(rv * 2), hex, &hex[rv * 2]);\n\t\telse\n\t\tif (rv > bufsz)\n\t\t\tapplog(LOG_WARNING, \"%s fd=%d: SEND %s => +%d\",\n\t\t\t       \"hashfast\", fd, hex, (int)(rv - bufsz));\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"%s fd=%d: SEND %s\",\n\t\t\t       \"hashfast\", fd, hex);\n\t}\n\treturn rv;\n}\n\nstatic\nssize_t hashfast_read(const int fd, void * const buf, size_t bufsz)\n{\n\tconst ssize_t rv = serial_read(fd, buf, bufsz);\n\tif (opt_debug && opt_dev_protocol && rv)\n\t{\n\t\tchar hex[(rv * 2) + 1];\n\t\tbin2hex(hex, buf, rv);\n\t\tapplog(LOG_DEBUG, \"%s fd=%d: RECV %s\",\n\t\t       \"hashfast\", fd, hex);\n\t}\n\treturn rv;\n}\n\nstatic\nbool hashfast_prepare_msg(uint8_t * const buf, const uint8_t opcode, const uint8_t chipaddr, const uint8_t coreaddr, const uint16_t hdata, const size_t datalen)\n{\n\tbuf[0] = '\\xaa';\n\tbuf[1] = opcode;\n\tbuf[2] = chipaddr;\n\tbuf[3] = coreaddr;\n\tbuf[4] = hdata & 0xff;\n\tbuf[5] = hdata >> 8;\n\tif (datalen > 1020 || datalen % 4)\n\t\treturn false;\n\tbuf[6] = datalen / 4;\n\tbuf[7] = crc8ccitt(&buf[1], 6);\n\treturn true;\n}\n\nstatic\nbool hashfast_send_msg(const int fd, uint8_t * const buf, const uint8_t opcode, const uint8_t chipaddr, const uint8_t coreaddr, const uint16_t hdata, const size_t datalen)\n{\n\tif (!hashfast_prepare_msg(buf, opcode, chipaddr, coreaddr, hdata, datalen))\n\t\treturn false;\n\tconst size_t buflen = HASHFAST_HEADER_SIZE + datalen;\n\treturn (buflen == hashfast_write(fd, buf, buflen));\n}\n\nstatic\nbool hashfast_parse_msg(const int fd, struct hashfast_parsed_msg * const out_msg)\n{\n\tuint8_t buf[HASHFAST_HEADER_SIZE];\nstartover:\n\tif (HASHFAST_HEADER_SIZE != hashfast_read(fd, buf, HASHFAST_HEADER_SIZE))\n\t\treturn false;\n\tuint8_t *p = memchr(buf, '\\xaa', HASHFAST_HEADER_SIZE);\n\tif (p != buf)\n\t{\nignoresome:\n\t\tif (!p)\n\t\t\tgoto startover;\n\t\tint moreneeded = p - buf;\n\t\tint alreadyhave = HASHFAST_HEADER_SIZE - moreneeded;\n\t\tmemmove(buf, p, alreadyhave);\n\t\tif (moreneeded != hashfast_read(fd, &buf[alreadyhave], moreneeded))\n\t\t\treturn false;\n\t}\n\tconst uint8_t correct_crc8 = crc8ccitt(&buf[1], 6);\n\tif (buf[7] != correct_crc8)\n\t{\n\t\tp = memchr(&buf[1], '\\xaa', HASHFAST_HEADER_SIZE - 1);\n\t\tgoto ignoresome;\n\t}\n\tout_msg->opcode   = buf[1];\n\tout_msg->chipaddr = buf[2];\n\tout_msg->coreaddr = buf[3];\n\tout_msg->hdata    = (uint16_t)buf[4] | ((uint16_t)buf[5] << 8);\n\tout_msg->datalen  = buf[6] * 4;\n\treturn (out_msg->datalen == hashfast_read(fd, &out_msg->data[0], out_msg->datalen));\n}\n\nstatic\nbool hashfast_lowl_match(const struct lowlevel_device_info * const info)\n{\n\tif (lowlevel_match_product(info, \"GoldenNonce\"))\n\t\treturn true;\n\treturn (info->manufacturer && strstr(info->manufacturer, \"HashFast\"));\n}\n\nstatic\nconst char *hashfast_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n\n{\n\tuint16_t * const clockp = proc->device_data;\n\t*clockp = atoi(newvalue);\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition hashfast_set_device_funcs_probe[] = {\n\t{\"clock\", hashfast_set_clock, \"clock frequency\"},\n\t{NULL},\n};\n\nstatic const struct bfg_set_device_definition hashfast_set_device_funcs[];\n\nstatic\nbool hashfast_detect_one(const char * const devpath)\n{\n\tuint16_t clock = 550;\n\tuint8_t buf[HASHFAST_HEADER_SIZE];\n\tconst int fd = serial_open(devpath, 0, 100, true);\n\tif (fd == -1)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to open %s\", __func__, devpath);\n\t\treturn false;\n\t}\n\tstruct hashfast_parsed_msg * const pmsg = malloc(sizeof(*pmsg));\n\tdrv_set_defaults(&hashfast_ums_drv, hashfast_set_device_funcs_probe, &clock, devpath, detectone_meta_info.serial, 1);\n\thashfast_send_msg(fd, buf, HFOP_USB_INIT, 0, 0, clock, 0);\n\tdo {\n\t\tif (!hashfast_parse_msg(fd, pmsg))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s: Failed to parse response on %s\",\n\t\t\t        __func__, devpath);\n\t\t\tserial_close(fd);\n\t\t\tgoto err;\n\t\t}\n\t} while (pmsg->opcode != HFOP_USB_INIT);\n\tserial_close(fd);\n\tconst int expectlen = 0x20 + (pmsg->chipaddr * pmsg->coreaddr) / 8;\n\tif (pmsg->datalen < expectlen)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: USB_INIT response too short on %s (%d < %d)\",\n\t\t       __func__, devpath, (int)pmsg->datalen, expectlen);\n\t\tgoto err;\n\t}\n\tif (pmsg->data[8] != 0)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: USB_INIT failed on %s (err=%d)\",\n\t\t        __func__, devpath, pmsg->data[8]);\n\t\tgoto err;\n\t}\n\tuint16_t fwrev = upk_u16le(pmsg->data, 0);\n\tif (!fwrev)\n\t{\n\t\t// fwrev == 0 means latest experimental; make it >= every possible comparison\n\t\tfwrev = 0xffff;\n\t\tpk_u16le(pmsg->data, 0, fwrev);\n\t}\n\t\n\tif (serial_claim_v(devpath, &hashfast_ums_drv))\n\t\treturn false;\n\t\n\t// Hijack hdata for a quick way to transfer clock to init\n\tpmsg->hdata = clock;\n\t\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &hashfast_ums_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = (pmsg->chipaddr * pmsg->coreaddr),\n\t\t.threads = 1,\n\t\t.device_data = pmsg,\n\t\t.cutofftemp = 100,\n\t};\n\t\n\tif (fwrev >= 0x0005)\n\t\tcgpu->set_device_funcs = hashfast_set_device_funcs;\n\t\n\treturn add_cgpu(cgpu);\n\nerr:\n\tfree(pmsg);\n\treturn false;\n}\n\nstatic\nbool hashfast_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, hashfast_detect_one);\n}\n\nstruct hashfast_dev_state {\n\tuint8_t cores_per_chip;\n\tint fd;\n\tstruct hashfast_chip_state *chipstates;\n\tuint16_t fwrev;\n};\n\nstruct hashfast_chip_state {\n\tstruct cgpu_info **coreprocs;\n\thashfast_isn_t last_isn;\n\tfloat voltages[HASHFAST_MAX_VOLTAGES];\n\tuint16_t clock;\n\tuint16_t clock_desired;\n\tuint8_t cfgdata[HASHFAST_CONFIG_DATA_SIZE];\n};\n\nstruct hashfast_core_state {\n\tuint8_t chipaddr;\n\tuint8_t coreaddr;\n\tint next_device_id;\n\tuint8_t last_seq;\n\thashfast_isn_t last_isn;\n\thashfast_isn_t last2_isn;\n\tbool has_pending;\n\tunsigned queued;\n};\n\nstatic\nconst char *hashfast_set_clock_runtime(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[cs->chipaddr];\n\t\n\tconst int nv = atoi(newvalue);\n\tif (nv >= 0xfff)\n\t\treturn \"Clock frequency too high\";\n\t\n\tchipstate->clock_desired = nv;\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition hashfast_set_device_funcs[] = {\n\t{\"clock\", hashfast_set_clock_runtime, \"clock frequency\"},\n\t{NULL},\n};\n\nstatic\nvoid hashfast_init_cfgdata(struct hashfast_chip_state * const chipstate)\n{\n\tuint8_t * const cfgdata = chipstate->cfgdata;\n\t\n\tconst uint16_t status_ms = 500;\n\tconst bool send_status_on_core_idle = false;\n\tconst bool send_status_on_pending_empty = false;\n\tconst bool pwm_active_level = false;\n\tconst uint8_t status_batching_delay_ms = 0;\n\tconst uint8_t watchdog_sec = 0;\n\tconst uint8_t rx_header_timeout = 20, rx_data_timeout = 20;\n\tconst uint8_t stats_sec = 10;\n\tconst uint8_t temp_measure_ms = 100;\n\tconst uint16_t lf_clocks_per_usec = 125 /* FIXME: or 126? */;\n\tconst uint8_t max_nonces_per_frame = 1;\n\tconst uint8_t voltage_sample_points = 0x1f;\n\tconst uint8_t pwm_phases = 1, pwm_period = 0, pwm_pulse_period = 0;\n\tconst uint8_t temp_trim = 0;\n\t\n\tpk_u16le(cfgdata, 0,\n\t         (status_ms & 0x7ff) | (status_ms ? HFCF_STATUS_PERIOD : 0) |\n\t         (send_status_on_core_idle     ? HFCF_STATUS_IDLE   : 0) |\n\t         (send_status_on_pending_empty ? HFCF_STATUS_EMPTY  : 0) |\n\t         (pwm_active_level             ? HFCF_PWM_ACTIVE_LV : 0));\n\tpk_u8(cfgdata, 2, status_batching_delay_ms);\n\tpk_u8(cfgdata, 3, watchdog_sec & 0x7f);\n\t\n\tpk_u8(cfgdata, 4, rx_header_timeout & 0x7f);\n\tpk_u8(cfgdata, 5, rx_data_timeout   & 0x7f);\n\tpk_u8(cfgdata, 6, stats_sec         & 0x7f);\n\tpk_u8(cfgdata, 7, temp_measure_ms);\n\t\n\tpk_u16le(cfgdata, 8,\n\t         ((lf_clocks_per_usec - 1) & 0xfff) |\n\t         ((max_nonces_per_frame & 0xf) << 0xc));\n\tpk_u8(cfgdata, 0xa, voltage_sample_points);\n\tpk_u8(cfgdata, 0xb,\n\t      ((pwm_phases - 1) & 3) |\n\t      ((temp_trim & 0xf) << 2));\n\t\n\tpk_u16le(cfgdata, 0xc, pwm_period);\n\tpk_u16le(cfgdata, 0xe, pwm_pulse_period);\n}\n\nstatic\nuint16_t hashfast_chip_thermal_cutoff_hdata(const float temp)\n{\n\tconst uint16_t v = (temp + 61.5) * 0x1000 / 240;\n\treturn HFCH_THERMAL_LIMIT | (v & 0x3ff);\n}\n\nstatic\nbool hashfast_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu, *proc;\n\tstruct hashfast_parsed_msg * const pmsg = dev->device_data;\n\tstruct hashfast_dev_state * const devstate = malloc(sizeof(*devstate));\n\tstruct hashfast_chip_state * const chipstates = malloc(sizeof(*chipstates) * pmsg->chipaddr), *chipstate;\n\tstruct hashfast_core_state * const corestates = malloc(sizeof(*corestates) * dev->procs), *cs;\n\tint i;\n\t\n\t*devstate = (struct hashfast_dev_state){\n\t\t.chipstates = chipstates,\n\t\t.cores_per_chip = pmsg->coreaddr,\n\t\t.fd = serial_open(dev->device_path, 0, 1, true),\n\t\t.fwrev = upk_u16le(pmsg->data, 0),\n\t};\n\t\n\tconst uint16_t clock = pmsg->hdata;\n\t\n\tfor (i = 0; i < pmsg->chipaddr; ++i)\n\t{\n\t\tchipstate = &chipstates[i];\n\t\t*chipstate = (struct hashfast_chip_state){\n\t\t\t.coreprocs = malloc(sizeof(struct cgpu_info *) * pmsg->coreaddr),\n\t\t\t.clock = clock,\n\t\t\t.clock_desired = clock,\n\t\t};\n\t\thashfast_init_cfgdata(chipstate);\n\t}\n\t\n\tfor ((i = 0), (proc = dev); proc; ++i, (proc = proc->next_proc))\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tconst bool core_is_working = pmsg->data[0x20 + (i / 8)] & (1 << (i % 8));\n\t\t\n\t\tif (!core_is_working)\n\t\t\tproc->deven = DEV_RECOVER_DRV;\n\t\tproc->device_data = devstate;\n\t\tthr->cgpu_data = cs = &corestates[i];\n\t\t*cs = (struct hashfast_core_state){\n\t\t\t.chipaddr = i / pmsg->coreaddr,\n\t\t\t.coreaddr = i % pmsg->coreaddr,\n\t\t};\n\t\tchipstates[cs->chipaddr].coreprocs[cs->coreaddr] = proc;\n\t}\n\tfree(pmsg);\n\t\n\t// TODO: actual clock = [12,13]\n\t\n\tfor_each_managed_proc(proc, dev)\n\t{\n\t\tproc->status = LIFE_INIT2;\n\t}\n\t\n\ttimer_set_now(&master_thr->tv_poll);\n\treturn true;\n}\n\nstatic\nbool hashfast_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tconst int fd = devstate->fd;\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[cs->chipaddr];\n\tconst size_t cmdlen = HASHFAST_HEADER_SIZE + HASHFAST_HASH_SIZE;\n\tuint8_t cmd[cmdlen];\n\tuint8_t * const hashdata = &cmd[HASHFAST_HEADER_SIZE];\n\thashfast_isn_t isn;\n\tuint8_t seq;\n\t\n\tif (cs->has_pending || chipstate->clock_desired != chipstate->clock)\n\t{\n\t\tthr->queue_full = true;\n\t\treturn false;\n\t}\n\t\n\tisn = ++chipstate->last_isn;\n\tseq = ++cs->last_seq;\n\twork->device_id = seq;\n\tcs->last2_isn = cs->last_isn;\n\tcs->last_isn = isn;\n\thashfast_prepare_msg(cmd, HFOP_HASH, cs->chipaddr, cs->coreaddr, (cs->coreaddr << 8) | seq, 56);\n\tmemcpy(&hashdata[   0], work->midstate, 0x20);\n\tmemcpy(&hashdata[0x20], &work->data[64], 0xc);\n\tmemset(&hashdata[0x2c], '\\0', 0xa);  // starting_nonce, nonce_loops, ntime_loops\n\thashdata[0x36] = 32;  // search target (number of zero bits)\n\thashdata[0x37] = 0;\n\tcs->has_pending = true;\n\t\n\tif (cmdlen != hashfast_write(fd, cmd, cmdlen))\n\t\treturn false;\n\t\n\tDL_APPEND(thr->work, work);\n\tif (cs->queued > HASHFAST_QUEUE_MEMORY)\n\t{\n\t\tstruct work * const old_work = thr->work;\n\t\tDL_DELETE(thr->work, old_work);\n\t\tfree_work(old_work);\n\t}\n\telse\n\t\t++cs->queued;\n\t\n\treturn true;\n}\n\nstatic\nvoid hashfast_queue_flush(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tconst int fd = devstate->fd;\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tuint8_t cmd[HASHFAST_HEADER_SIZE];\n\tuint16_t hdata = 2;\n\tif ((!thr->work) || stale_work(thr->work->prev, true))\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Flushing both active and pending work\",\n\t\t       proc->proc_repr);\n\t\thdata |= 1;\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Flushing pending work\",\n\t\t       proc->proc_repr);\n\thashfast_send_msg(fd, cmd, HFOP_ABORT, cs->chipaddr, cs->coreaddr, hdata, 0);\n}\n\nstatic\nstruct cgpu_info *hashfast_find_proc(struct thr_info * const master_thr, int chipaddr, int coreaddr)\n{\n\tstruct cgpu_info *proc = master_thr->cgpu;\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tif (coreaddr >= devstate->cores_per_chip)\n\t\treturn NULL;\n\tconst unsigned chip_count = proc->procs / devstate->cores_per_chip;\n\tif (chipaddr >= chip_count)\n\t\treturn NULL;\n\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[chipaddr];\n\treturn chipstate->coreprocs[coreaddr];\n}\n\nstatic\nhashfast_isn_t hashfast_get_isn(struct hashfast_chip_state * const chipstate, uint16_t hfseq)\n{\n\tconst uint8_t coreaddr = hfseq >> 8;\n\tconst uint8_t seq = hfseq & 0xff;\n\tstruct cgpu_info * const proc = chipstate->coreprocs[coreaddr];\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tif (cs->last_seq == seq)\n\t\treturn cs->last_isn;\n\tif (cs->last_seq == (uint8_t)(seq + 1))\n\t\treturn cs->last2_isn;\n\treturn 0;\n}\n\nstatic\nvoid hashfast_submit_nonce(struct thr_info * const thr, struct work * const work, const uint32_t nonce, const bool searched)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Found nonce for seq %02x (last=%02x): %08lx%s\",\n\t       proc->proc_repr, (unsigned)work->device_id, (unsigned)cs->last_seq,\n\t       (unsigned long)nonce, searched ? \" (searched)\" : \"\");\n\tsubmit_nonce(thr, work, nonce);\n}\n\nstatic\nbool hashfast_poll_msg(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\tstruct hashfast_dev_state * const devstate = dev->device_data;\n\tconst int fd = devstate->fd;\n\t\n\tstruct hashfast_parsed_msg msg;\n\tif (!hashfast_parse_msg(fd, &msg))\n\t\treturn false;\n\t\n\tswitch (msg.opcode)\n\t{\n\t\tcase HFOP_NONCE:\n\t\t{\n\t\t\tconst uint8_t *data = msg.data;\n\t\t\tfor (int i = msg.datalen / 8; i; --i, (data = &data[8]))\n\t\t\t{\n\t\t\t\tconst uint32_t nonce = (data[0] <<  0)\n\t\t\t\t                     | (data[1] <<  8)\n\t\t\t\t                     | (data[2] << 16)\n\t\t\t\t                     | (data[3] << 24);\n\t\t\t\tconst uint8_t seq = data[4];\n\t\t\t\tconst uint8_t coreaddr = data[5];\n\t\t\t\t// uint32_t ntime = data[6] | ((data[7] & 0xf) << 8);\n\t\t\t\tconst bool search = data[7] & 0x10;\n\t\t\t\tstruct cgpu_info * const proc = hashfast_find_proc(master_thr, msg.chipaddr, coreaddr);\n\t\t\t\tif (unlikely(!proc))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_ERR, \"%s: Unknown chip/core address %u/%u\",\n\t\t\t\t\t       dev->dev_repr, (unsigned)msg.chipaddr, (unsigned)coreaddr);\n\t\t\t\t\tinc_hw_errors_only(master_thr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\t\t\t\tstruct work *work;\n\t\t\t\t\n\t\t\t\tDL_SEARCH_SCALAR(thr->work, work, device_id, seq);\n\t\t\t\tif (unlikely(!work))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Unknown seq %02x (last=%02x)\",\n\t\t\t\t\t       proc->proc_repr, (unsigned)seq, (unsigned)cs->last_seq);\n\t\t\t\t\tinc_hw_errors2(thr, NULL, &nonce);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tunsigned nonces_found = 1;\n\t\t\t\t\n\t\t\t\thashfast_submit_nonce(thr, work, nonce, false);\n\t\t\t\tif (search)\n\t\t\t\t{\n\t\t\t\t\tfor (int noffset = 1; noffset <= 0x80; ++noffset)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst uint32_t nonce2 = nonce + noffset;\n\t\t\t\t\t\tif (test_nonce(work, nonce2, false))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thashfast_submit_nonce(thr, work, nonce2, true);\n\t\t\t\t\t\t\t++nonces_found;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!nonces_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": search=1, but failed to turn up any additional solutions\",\n\t\t\t\t\t\t       proc->proc_repr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thashes_done2(thr, 0x100000000 * nonces_found, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase HFOP_STATUS:\n\t\t{\n\t\t\tconst uint8_t *data = &msg.data[8];\n\t\t\tstruct cgpu_info *proc = hashfast_find_proc(master_thr, msg.chipaddr, 0);\n\t\t\tstruct cgpu_info *first_proc = proc;\n\t\t\tif (unlikely(!proc))\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%s: Unknown chip address %u\",\n\t\t\t\t       dev->dev_repr, (unsigned)msg.chipaddr);\n\t\t\t\tinc_hw_errors_only(master_thr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[msg.chipaddr];\n\t\t\thashfast_isn_t isn = hashfast_get_isn(chipstate, msg.hdata);\n\t\t\tconst float temp = hashfast_temperature_conv(&msg.data[0]);\n\t\t\tfor (int i = 0; i < HASHFAST_MAX_VOLTAGES; ++i)\n\t\t\t\tchipstate->voltages[i] = hashfast_voltage_conv(msg.data[2 + i]);\n\t\t\tint cores_uptodate, cores_active, cores_pending, cores_transitioned;\n\t\t\tcores_uptodate = cores_active = cores_pending = cores_transitioned = 0;\n\t\t\tfor (int i = 0; i < devstate->cores_per_chip; ++i, (proc = proc->next_proc))\n\t\t\t{\n\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\t\t\t\tconst uint8_t bits = data[i / 4] >> (2 * (i % 4));\n\t\t\t\tconst bool has_active  = bits & 1;\n\t\t\t\tconst bool has_pending = bits & 2;\n\t\t\t\tbool try_transition = true;\n\t\t\t\t\n\t\t\t\tproc->temp = temp;\n\t\t\t\t\n\t\t\t\tif (cs->last_isn <= isn)\n\t\t\t\t\t++cores_uptodate;\n\t\t\t\telse\n\t\t\t\t\ttry_transition = false;\n\t\t\t\t\n\t\t\t\tif (has_active)\n\t\t\t\t\t++cores_active;\n\t\t\t\t\n\t\t\t\tif (has_pending)\n\t\t\t\t\t++cores_pending;\n\t\t\t\telse\n\t\t\t\tif (try_transition)\n\t\t\t\t{\n\t\t\t\t\t++cores_transitioned;\n\t\t\t\t\tcs->has_pending = false;\n\t\t\t\t\t// Avoid refilling pending slot if we are preparing to change the clock frequency\n\t\t\t\t\tif (chipstate->clock_desired == chipstate->clock)\n\t\t\t\t\t\tthr->queue_full = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tapplog(LOG_DEBUG, \"%s: STATUS from chipaddr=0x%02x with hdata=0x%04x (isn=0x%lx): total=%d uptodate=%d active=%d pending=%d transitioned=%d\",\n\t\t\t       dev->dev_repr, (unsigned)msg.chipaddr, (unsigned)msg.hdata, isn,\n\t\t\t       devstate->cores_per_chip, cores_uptodate,\n\t\t\t       cores_active, cores_pending, cores_transitioned);\n\t\t\tif ((!cores_active) && chipstate->clock_desired != chipstate->clock)\n\t\t\t{\n\t\t\t\t// All cores finished their work, change clock frequency and then refill\n\t\t\t\tuint8_t buf[HASHFAST_HEADER_SIZE + HASHFAST_CONFIG_DATA_SIZE];\n\t\t\t\tuint16_t clock = chipstate->clock_desired, hdata;\n\t\t\t\tif (!hashfast_send_msg(fd, buf, HFOP_UMS_CLOCK_CHANGE, msg.chipaddr, 0, HFWR_SET_CLOCK | clock, 0))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Clock change failure (%s)\", proc->proc_repr, \"OP_UMS_CLOCK_CHANGE\");\n\t\t\t\t\tgoto clockchangefailed;\n\t\t\t\t}\n\t\t\t\t// Until we send HFOP_CONFIG, the state is undefined\n\t\t\t\tchipstate->clock = 0;\n\t\t\t\t\n\t\t\t\thdata = HFCH_WRITE;\n\t\t\t\thdata |= hashfast_chip_thermal_cutoff_hdata(110);\n\t\t\t\tpk_uNle(chipstate->cfgdata, 8, 0, 0xc, clock);\n\t\t\t\tmemcpy(&buf[HASHFAST_HEADER_SIZE], chipstate->cfgdata, HASHFAST_CONFIG_DATA_SIZE);\n\t\t\t\tif (!hashfast_send_msg(fd, buf, HFOP_CONFIG, msg.chipaddr, 0, hdata, HASHFAST_CONFIG_DATA_SIZE))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Clock change failure (%s)\", proc->proc_repr, \"OP_CONFIG\");\n\t\t\t\t\tgoto clockchangefailed;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchipstate->clock = clock;\n\t\t\t\t\n\t\t\t\t// Time to refill queues\n\t\t\t\tproc = first_proc;\n\t\t\t\tfor (int i = 0; i < devstate->cores_per_chip; ++i, (proc = proc->next_proc))\n\t\t\t\t{\n\t\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\t\tthr->queue_full = false;\n\t\t\t\t}\n\t\t\t\t\nclockchangefailed: ;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic\nvoid hashfast_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\tstruct timeval tv_timeout;\n\ttimer_set_delay_from_now(&tv_timeout, 10000);\n\twhile (true)\n\t{\n\t\tif (!hashfast_poll_msg(master_thr))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s poll: No more messages\", dev->dev_repr);\n\t\t\tbreak;\n\t\t}\n\t\tif (timer_passed(&tv_timeout, NULL))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s poll: 10ms timeout met\", dev->dev_repr);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\ttimer_set_delay_from_now(&master_thr->tv_poll, 100000);\n}\n\nstatic\nstruct api_data *hashfast_api_stats(struct cgpu_info * const proc)\n{\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[cs->chipaddr];\n\tstruct api_data *root = NULL;\n\tchar key[] = \"VoltageNN\";\n\t\n\tfor (int i = 0; i < HASHFAST_MAX_VOLTAGES; ++i)\n\t{\n\t\tsnprintf(&key[7], 3, \"%d\", i);\n\t\tif (chipstate->voltages[i])\n\t\t\troot = api_add_volts(root, key, &chipstate->voltages[i], false);\n\t}\n\t\n\treturn root;\n}\n\nstatic\nstruct api_data *hashfast_api_devdetail(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\t\n\troot = api_add_uint8(root, \"Chip Address\", &cs->chipaddr, false);\n\troot = api_add_uint8(root, \"Core Address\", &cs->coreaddr, false);\n\t\n\treturn root;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid hashfast_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct hashfast_dev_state * const devstate = proc->device_data;\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct hashfast_core_state * const cs = thr->cgpu_data;\n\tstruct hashfast_chip_state * const chipstate = &devstate->chipstates[cs->chipaddr];\n\t\n\t{\n\t\t// -> \"NNN.xxx / NNN.xxx / NNN.xxx\"\n\t\tsize_t sz = (HASHFAST_MAX_VOLTAGES * 10) + 1;\n\t\tchar buf[sz];\n\t\tchar *s = buf;\n\t\tint rv = 0;\n\t\tfor (int i = 0; i < HASHFAST_MAX_VOLTAGES; ++i)\n\t\t{\n\t\t\tconst float voltage = chipstate->voltages[i];\n\t\t\tif (!voltage)\n\t\t\t\tcontinue;\n\t\t\t_SNP(\"%.3f / \", voltage);\n\t\t}\n\t\tif (rv >= 3 && s[-2] == '/')\n\t\t{\n\t\t\ts[-3] = '\\0';\n\t\t\twlogprint(\"Voltages: %s\\n\", buf);\n\t\t}\n\t}\n}\n\nstatic\nvoid hashfast_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *hashfast_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tchar prompt[0x80];\n\t\t\tsnprintf(prompt, sizeof(prompt), \"Set clock speed (%u-%u)\", 1, 0xffe);\n\t\t\treturn proc_set_device_tui_wrapper(proc, NULL, hashfast_set_clock_runtime, prompt, NULL);\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\nstruct device_drv hashfast_ums_drv = {\n\t.dname = \"hashfast_ums\",\n\t.name = \"HFA\",\n\t\n\t.lowl_match = hashfast_lowl_match,\n\t.lowl_probe = hashfast_lowl_probe,\n\t\n\t.thread_init = hashfast_init,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = hashfast_queue_append,\n\t.queue_flush = hashfast_queue_flush,\n\t.poll = hashfast_poll,\n\t\n\t.get_api_stats = hashfast_api_stats,\n\t.get_api_extra_device_detail = hashfast_api_devdetail,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = hashfast_wlogprint_status,\n\t.proc_tui_wlogprint_choices = hashfast_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = hashfast_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-icarus.c",
          "type": "blob",
          "size": 44.40625,
          "content": "/*\n * Copyright 2012-2015 Luke Dashjr\n * Copyright 2012 Xiangfu\n * Copyright 2014 Nate Woolls\n * Copyright 2012 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n/*\n * Those code should be works fine with V2 and V3 bitstream of Icarus.\n * Operation:\n *   No detection implement.\n *   Input: 64B = 32B midstate + 20B fill bytes + last 12 bytes of block head.\n *   Return: send back 32bits immediately when Icarus found a valid nonce.\n *           no query protocol implemented here, if no data send back in ~11.3\n *           seconds (full cover time on 32bit nonce range by 380MH/s speed)\n *           just send another work.\n * Notice:\n *   1. Icarus will start calculate when you push a work to them, even they\n *      are busy.\n *   2. The 2 FPGAs on Icarus will distribute the job, one will calculate the\n *      0 ~ 7FFFFFFF, another one will cover the 80000000 ~ FFFFFFFF.\n *   3. It's possible for 2 FPGAs both find valid nonce in the meantime, the 2\n *      valid nonce will all be send back.\n *   4. Icarus will stop work when: a valid nonce has been found or 32 bits\n *      nonce range is completely calculated.\n */\n\n#include \"config.h\"\n#include \"miner.h\"\n\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#ifndef WIN32\n  #include <termios.h>\n  #include <sys/stat.h>\n  #include <fcntl.h>\n  #ifndef O_CLOEXEC\n    #define O_CLOEXEC 0\n  #endif\n#else\n  #include <windows.h>\n  #include <io.h>\n#endif\n#ifdef HAVE_SYS_EPOLL_H\n  #include <sys/epoll.h>\n  #define HAVE_EPOLL\n#endif\n\n#include \"compat.h\"\n#include \"dynclock.h\"\n#include \"driver-icarus.h\"\n#include \"lowl-vcom.h\"\n\n// The serial I/O speed - Linux uses a define 'B115200' in bits/termios.h\n#define ICARUS_IO_SPEED 115200\n\n// The number of bytes in a nonce (always 4)\n// This is NOT the read-size for the Icarus driver\n// That is defined in ICARUS_INFO->read_size\n#define ICARUS_NONCE_SIZE 4\n\n#define ASSERT1(condition) __maybe_unused static char sizeof_uint32_t_must_be_4[(condition)?1:-1]\nASSERT1(sizeof(uint32_t) == 4);\n\n#define ICARUS_READ_TIME(baud, read_size) ((double)read_size * (double)8.0 / (double)(baud))\n\n// Defined in deciseconds\n// There's no need to have this bigger, since the overhead/latency of extra work\n// is pretty small once you get beyond a 10s nonce range time and 10s also\n// means that nothing slower than 429MH/s can go idle so most icarus devices\n// will always mine without idling\n#define ICARUS_READ_COUNT_LIMIT_MAX 100\n\n// In timing mode: Default starting value until an estimate can be obtained\n#define ICARUS_READ_COUNT_TIMING_MS  75\n\n// For a standard Icarus REV3\n#define ICARUS_REV3_HASH_TIME 0.00000000264083\n\n// Icarus Rev3 doesn't send a completion message when it finishes\n// the full nonce range, so to avoid being idle we must abort the\n// work (by starting a new work) shortly before it finishes\n//\n// Thus we need to estimate 2 things:\n//\t1) How many hashes were done if the work was aborted\n//\t2) How high can the timeout be before the Icarus is idle,\n//\t\tto minimise the number of work started\n//\tWe set 2) to 'the calculated estimate' - 1\n//\tto ensure the estimate ends before idle\n//\n// The simple calculation used is:\n//\tTn = Total time in seconds to calculate n hashes\n//\tHs = seconds per hash\n//\tXn = number of hashes\n//\tW  = code overhead per work\n//\n// Rough but reasonable estimate:\n//\tTn = Hs * Xn + W\t(of the form y = mx + b)\n//\n// Thus:\n//\tLine of best fit (using least squares)\n//\n//\tHs = (n*Sum(XiTi)-Sum(Xi)*Sum(Ti))/(n*Sum(Xi^2)-Sum(Xi)^2)\n//\tW = Sum(Ti)/n - (Hs*Sum(Xi))/n\n//\n// N.B. W is less when aborting work since we aren't waiting for the reply\n//\tto be transferred back (ICARUS_READ_TIME)\n//\tCalculating the hashes aborted at n seconds is thus just n/Hs\n//\t(though this is still a slight overestimate due to code delays)\n//\n\n// Both below must be exceeded to complete a set of data\n// Minimum how long after the first, the last data point must be\n#define HISTORY_SEC 60\n// Minimum how many points a single ICARUS_HISTORY should have\n#define MIN_DATA_COUNT 5\n// The value above used is doubled each history until it exceeds:\n#define MAX_MIN_DATA_COUNT 100\n\nstatic struct timeval history_sec = { HISTORY_SEC, 0 };\n\nstatic const char *MODE_DEFAULT_STR = \"default\";\nstatic const char *MODE_SHORT_STR = \"short\";\nstatic const char *MODE_SHORT_STREQ = \"short=\";\nstatic const char *MODE_LONG_STR = \"long\";\nstatic const char *MODE_LONG_STREQ = \"long=\";\nstatic const char *MODE_VALUE_STR = \"value\";\nstatic const char *MODE_UNKNOWN_STR = \"unknown\";\n\n#define END_CONDITION 0x0000ffff\n#define DEFAULT_DETECT_THRESHOLD 1\n\nBFG_REGISTER_DRIVER(icarus_drv)\nextern const struct bfg_set_device_definition icarus_set_device_funcs[];\nextern const struct bfg_set_device_definition icarus_set_device_funcs_live[];\n\nextern void convert_icarus_to_cairnsmore(struct cgpu_info *);\n\nstatic inline\nuint32_t icarus_nonce32toh(const struct ICARUS_INFO * const info, const uint32_t nonce)\n{\n\treturn info->nonce_littleendian ? le32toh(nonce) : be32toh(nonce);\n}\n\n#define icarus_open2(devpath, baud, purge)  serial_open(devpath, baud, ICARUS_READ_FAULT_DECISECONDS, purge)\n#define icarus_open(devpath, baud)  icarus_open2(devpath, baud, false)\n\nstatic\nvoid icarus_log_protocol(const char * const repr, const void *buf, size_t bufLen, const char *prefix)\n{\n\tchar hex[(bufLen * 2) + 1];\n\tbin2hex(hex, buf, bufLen);\n\tapplog(LOG_DEBUG, \"%s: DEVPROTO: %s %s\", repr, prefix, hex);\n}\n\nint icarus_read(const char * const repr, uint8_t *buf, const int fd, struct timeval * const tvp_finish, struct thr_info * const thr, const struct timeval * const tvp_timeout, struct timeval * const tvp_now, int read_size)\n{\n\tint rv;\n\tlong remaining_ms;\n\tssize_t ret;\n\tstruct timeval tv_start = *tvp_now;\n\tbool first = true;\n\t// If there is no thr, then there's no work restart to watch..\n\t\n#ifdef HAVE_EPOLL\n\tbool watching_work_restart = !thr;\n\tint epollfd;\n\tstruct epoll_event evr[2];\n\t\n\tepollfd = epoll_create(2);\n\tif (epollfd != -1) {\n\t\tstruct epoll_event ev = {\n\t\t\t.events = EPOLLIN,\n\t\t\t.data.fd = fd,\n\t\t};\n\t\tif (-1 == epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev)) {\n\t\t\tapplog(LOG_DEBUG, \"%s: Error adding %s fd to epoll\", \"device\", repr);\n\t\t\tclose(epollfd);\n\t\t\tepollfd = -1;\n\t\t}\n\t\telse\n\t\tif (thr && thr->work_restart_notifier[1] != -1)\n\t\t{\n\t\t\tev.data.fd = thr->work_restart_notifier[0];\n\t\t\tif (-1 == epoll_ctl(epollfd, EPOLL_CTL_ADD, thr->work_restart_notifier[0], &ev))\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Error adding %s fd to epoll\", \"work restart\", repr);\n\t\t\telse\n\t\t\t\twatching_work_restart = true;\n\t\t}\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%s: Error creating epoll\", repr);\n\t\n\tif (epollfd == -1 && (remaining_ms = timer_remaining_us(tvp_timeout, tvp_now)) < 100000)\n\t\tapplog(LOG_WARNING, \"%s: Failed to use epoll, and very short read timeout (%ldms)\", repr, remaining_ms);\n#endif\n\t\n\twhile (true) {\n\t\tremaining_ms = timer_remaining_us(tvp_timeout, tvp_now) / 1000;\n#ifdef HAVE_EPOLL\n\t\tif (epollfd != -1)\n\t\t{\n\t\t\tif ((!watching_work_restart) && remaining_ms > 100)\n\t\t\t\tremaining_ms = 100;\n\t\t\tret = epoll_wait(epollfd, evr, 2, remaining_ms);\n\t\t\ttimer_set_now(tvp_now);\n\t\t\tswitch (ret)\n\t\t\t{\n\t\t\t\tcase -1:\n\t\t\t\t\tif (unlikely(errno != EINTR))\n\t\t\t\t\t\treturn_via(out, rv = ICA_GETS_ERROR);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:  // timeout\n\t\t\t\t\t// handled after switch\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (evr[0].data.fd != fd)  // must be work restart notifier\n\t\t\t\t\t{\n\t\t\t\t\t\tnotifier_read(thr->work_restart_notifier);\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// fallthru to...\n\t\t\t\tcase 2:  // device has data\n\t\t\t\t\tret = read(fd, buf, read_size);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn_via(out, rv = ICA_GETS_ERROR);\n\t\t\t}\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (remaining_ms > 100)\n\t\t\t\tremaining_ms = 100;\n\t\t\telse\n\t\t\tif (remaining_ms < 1)\n\t\t\t\tremaining_ms = 1;\n\t\t\tvcom_set_timeout_ms(fd, remaining_ms);\n\t\t\t// Read first byte alone to get earliest tv_finish\n\t\t\tret = read(fd, buf, first ? 1 : read_size);\n\t\t\ttimer_set_now(tvp_now);\n\t\t}\n\t\tif (first)\n\t\t\t*tvp_finish = *tvp_now;\n\t\tif (ret)\n\t\t{\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn_via(out, rv = ICA_GETS_ERROR);\n\t\t\t\n\t\t\tfirst = false;\n\t\t\t\n\t\t\tif (opt_dev_protocol && opt_debug)\n\t\t\t\ticarus_log_protocol(repr, buf, ret, \"RECV\");\n\t\t\t\n\t\t\tif (ret >= read_size)\n\t\t\t\treturn_via(out, rv = ICA_GETS_OK);\n\t\t\t\n\t\t\tread_size -= ret;\n\t\t\tbuf += ret;\n\t\t\t// Always continue reading while data is coming in, ignoring the timeout\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (thr && thr->work_restart)\n\t\t\treturn_via_applog(out, rv = ICA_GETS_RESTART, LOG_DEBUG, \"%s: Interrupted by work restart\", repr);\n\t\t\n\t\tif (timer_passed(tvp_timeout, tvp_now))\n\t\t\treturn_via_applog(out, rv = ICA_GETS_TIMEOUT, LOG_DEBUG, \"%s: No data in %.3f seconds\", repr, timer_elapsed_us(&tv_start, tvp_now) / 1e6);\n\t}\n\nout:\n#ifdef HAVE_EPOLL\n\tif (epollfd != -1)\n\t\tclose(epollfd);\n#endif\n\treturn rv;\n}\n\nint icarus_write(const char * const repr, int fd, const void *buf, size_t bufLen)\n{\n\tsize_t ret;\n\n\tif (opt_dev_protocol && opt_debug)\n\t\ticarus_log_protocol(repr, buf, bufLen, \"SEND\");\n\n\tif (unlikely(fd == -1))\n\t\treturn 1;\n\t\n\tret = write(fd, buf, bufLen);\n\tif (unlikely(ret != bufLen))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#define icarus_close(fd) serial_close(fd)\n\nvoid do_icarus_close(struct thr_info *thr)\n{\n\tstruct cgpu_info *icarus = thr->cgpu;\n\tconst int fd = icarus->device_fd;\n\tif (fd == -1)\n\t\treturn;\n\ticarus_close(fd);\n\ticarus->device_fd = -1;\n}\n\nstatic const char *timing_mode_str(enum timing_mode timing_mode)\n{\n\tswitch(timing_mode) {\n\tcase MODE_DEFAULT:\n\t\treturn MODE_DEFAULT_STR;\n\tcase MODE_SHORT:\n\t\treturn MODE_SHORT_STR;\n\tcase MODE_LONG:\n\t\treturn MODE_LONG_STR;\n\tcase MODE_VALUE:\n\t\treturn MODE_VALUE_STR;\n\tdefault:\n\t\treturn MODE_UNKNOWN_STR;\n\t}\n}\n\nstatic\nconst char *_icarus_set_timing(struct ICARUS_INFO * const info, const char * const repr, const struct device_drv * const drv, const char * const buf)\n{\n\tdouble Hs;\n\tchar *eq;\n\n\tif (strcasecmp(buf, MODE_SHORT_STR) == 0) {\n\t\t// short\n\t\tinfo->read_timeout_ms = ICARUS_READ_COUNT_TIMING_MS;\n\t\tinfo->read_count_limit = 0;  // 0 = no limit\n\n\t\tinfo->timing_mode = MODE_SHORT;\n\t\tinfo->do_icarus_timing = true;\n\t} else if (strncasecmp(buf, MODE_SHORT_STREQ, strlen(MODE_SHORT_STREQ)) == 0) {\n\t\t// short=limit\n\t\tinfo->read_timeout_ms = ICARUS_READ_COUNT_TIMING_MS;\n\n\t\tinfo->timing_mode = MODE_SHORT;\n\t\tinfo->do_icarus_timing = true;\n\n\t\tinfo->read_count_limit = atoi(&buf[strlen(MODE_SHORT_STREQ)]);\n\t\tif (info->read_count_limit < 0)\n\t\t\tinfo->read_count_limit = 0;\n\t\tif (info->read_count_limit > ICARUS_READ_COUNT_LIMIT_MAX)\n\t\t\tinfo->read_count_limit = ICARUS_READ_COUNT_LIMIT_MAX;\n\t} else if (strcasecmp(buf, MODE_LONG_STR) == 0) {\n\t\t// long\n\t\tinfo->read_timeout_ms = ICARUS_READ_COUNT_TIMING_MS;\n\t\tinfo->read_count_limit = 0;  // 0 = no limit\n\n\t\tinfo->timing_mode = MODE_LONG;\n\t\tinfo->do_icarus_timing = true;\n\t} else if (strncasecmp(buf, MODE_LONG_STREQ, strlen(MODE_LONG_STREQ)) == 0) {\n\t\t// long=limit\n\t\tinfo->read_timeout_ms = ICARUS_READ_COUNT_TIMING_MS;\n\n\t\tinfo->timing_mode = MODE_LONG;\n\t\tinfo->do_icarus_timing = true;\n\n\t\tinfo->read_count_limit = atoi(&buf[strlen(MODE_LONG_STREQ)]);\n\t\tif (info->read_count_limit < 0)\n\t\t\tinfo->read_count_limit = 0;\n\t\tif (info->read_count_limit > ICARUS_READ_COUNT_LIMIT_MAX)\n\t\t\tinfo->read_count_limit = ICARUS_READ_COUNT_LIMIT_MAX;\n\t} else if ((Hs = atof(buf)) != 0) {\n\t\t// ns[=read_count]\n\t\tinfo->Hs = Hs / NANOSEC;\n\t\tinfo->fullnonce = info->Hs * (((double)0xffffffff) + 1);\n\n\t\tinfo->read_timeout_ms = 0;\n\t\tif ((eq = strchr(buf, '=')) != NULL)\n\t\t\tinfo->read_timeout_ms = atof(&eq[1]) * 100;\n\n\t\tif (info->read_timeout_ms < 1)\n\t\t{\n\t\t\tinfo->read_timeout_ms = info->fullnonce * 1000;\n\t\t\tif (unlikely(info->read_timeout_ms < 2))\n\t\t\t\tinfo->read_timeout_ms = 1;\n\t\t\telse\n\t\t\t\t--info->read_timeout_ms;\n\t\t}\n\n\t\tinfo->read_count_limit = 0;  // 0 = no limit\n\t\t\n\t\tinfo->timing_mode = MODE_VALUE;\n\t\tinfo->do_icarus_timing = false;\n\t} else {\n\t\t// Anything else in buf just uses DEFAULT mode\n\n\t\tinfo->fullnonce = info->Hs * (((double)0xffffffff) + 1);\n\n\t\tinfo->read_timeout_ms = 0;\n\t\tif ((eq = strchr(buf, '=')) != NULL)\n\t\t\tinfo->read_timeout_ms = atof(&eq[1]) * 100;\n\n\t\tunsigned def_read_timeout_ms = ICARUS_READ_COUNT_TIMING_MS;\n\n\t\tif (info->timing_mode == MODE_DEFAULT) {\n\t\t\tif (drv == &icarus_drv) {\n\t\t\t\tinfo->do_default_detection = 0x10;\n\t\t\t} else {\n\t\t\t\tdef_read_timeout_ms = info->fullnonce * 1000;\n\t\t\t\tif (def_read_timeout_ms > 0)\n\t\t\t\t\t--def_read_timeout_ms;\n\t\t\t}\n\n\t\t\tinfo->do_icarus_timing = false;\n\t\t}\n\t\tif (info->read_timeout_ms < 1)\n\t\t\tinfo->read_timeout_ms = def_read_timeout_ms;\n\t\t\n\t\tinfo->read_count_limit = 0;  // 0 = no limit\n\t}\n\n\tinfo->min_data_count = MIN_DATA_COUNT;\n\n\tapplog(LOG_DEBUG, \"%s: Init: mode=%s read_timeout_ms=%u limit=%dms Hs=%e\",\n\t\trepr,\n\t\ttiming_mode_str(info->timing_mode),\n\t\tinfo->read_timeout_ms, info->read_count_limit, info->Hs);\n\t\n\treturn NULL;\n}\n\nconst char *icarus_set_timing(struct cgpu_info * const proc, const char * const optname, const char * const buf, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\treturn _icarus_set_timing(info, proc->dev_repr, proc->drv, buf);\n}\n\nstatic uint32_t mask(int work_division)\n{\n\treturn 0xffffffff / work_division;\n}\n\n// Number of bytes remaining after reading a nonce from Icarus\nint icarus_excess_nonce_size(int fd, struct ICARUS_INFO *info)\n{\n\t// How big a buffer?\n\tint excess_size = info->read_size - ICARUS_NONCE_SIZE;\n\n\t// Try to read one more to ensure the device doesn't return\n\t// more than we want for this driver\n\texcess_size++;\n\n\tunsigned char excess_bin[excess_size];\n\t// Read excess_size from Icarus\n\tstruct timeval tv_now;\n\ttimer_set_now(&tv_now);\n\tint bytes_read = read(fd, excess_bin, excess_size);\n\t// Number of bytes that were still available\n\n\treturn bytes_read;\n}\n\nint icarus_probe_work_division(const int fd, const char * const repr, struct ICARUS_INFO * const info)\n{\n\tstruct timeval tv_now, tv_timeout;\n\tstruct timeval tv_finish;\n\t\n\t// For reading the nonce from Icarus\n\tunsigned char res_bin[info->read_size];\n\t// For storing the the 32-bit nonce\n\tuint32_t res;\n\tint work_division = 0;\n\t\n\tapplog(LOG_DEBUG, \"%s: Work division not specified - autodetecting\", repr);\n\t\n\t// Special packet to probe work_division\n\tunsigned char pkt[64] =\n\t\t\"\\x2e\\x4c\\x8f\\x91\\xfd\\x59\\x5d\\x2d\\x7e\\xa2\\x0a\\xaa\\xcb\\x64\\xa2\\xa0\"\n\t\t\"\\x43\\x82\\x86\\x02\\x77\\xcf\\x26\\xb6\\xa1\\xee\\x04\\xc5\\x6a\\x5b\\x50\\x4a\"\n\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\"\\x64\\x61\\x01\\x1a\\xc9\\x06\\xa9\\x51\\xfb\\x9b\\x3c\\x73\";\n\t\n\ticarus_write(repr, fd, pkt, sizeof(pkt));\n\tmemset(res_bin, 0, sizeof(res_bin));\n\ttimer_set_now(&tv_now);\n\ttimer_set_delay(&tv_timeout, &tv_now, info->read_timeout_ms * 1000);\n\tif (ICA_GETS_OK == icarus_read(repr, res_bin, fd, &tv_finish, NULL, &tv_timeout, &tv_now, info->read_size))\n\t{\n\t\tmemcpy(&res, res_bin, sizeof(res));\n\t\tres = icarus_nonce32toh(info, res);\n\t}\n\telse\n\t\tres = 0;\n\t\n\tswitch (res) {\n\t\tcase 0x04C0FDB4:\n\t\t\twork_division = 1;\n\t\t\tbreak;\n\t\tcase 0x82540E46:\n\t\t\twork_division = 2;\n\t\t\tbreak;\n\t\tcase 0x417C0F36:\n\t\t\twork_division = 4;\n\t\t\tbreak;\n\t\tcase 0x60C994D5:\n\t\t\twork_division = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tapplog(LOG_ERR, \"%s: Work division autodetection failed (assuming 2): got %08x\", repr, res);\n\t\t\twork_division = 2;\n\t}\n\tapplog(LOG_DEBUG, \"%s: Work division autodetection got %08x (=%d)\", repr, res, work_division);\n\treturn work_division;\n}\n\nstruct cgpu_info *icarus_detect_custom(const char *devpath, struct device_drv *api, struct ICARUS_INFO *info)\n{\n\tstruct timeval tv_start, tv_finish;\n\tint fd;\n\n\tunsigned char nonce_bin[ICARUS_NONCE_SIZE];\n\tchar nonce_hex[(sizeof(nonce_bin) * 2) + 1];\n\n\tdrv_set_defaults(api, icarus_set_device_funcs, info, devpath, detectone_meta_info.serial, 1);\n\n\tint baud = info->baud;\n\tint work_division = info->work_division;\n\tint fpga_count = info->fpga_count;\n\n\tapplog(LOG_DEBUG, \"%s: Attempting to open %s\", api->dname, devpath);\n\n\tfd = icarus_open2(devpath, baud, true);\n\tif (unlikely(fd == -1)) {\n\t\tapplog(LOG_DEBUG, \"%s: Failed to open %s\", api->dname, devpath);\n\t\treturn NULL;\n\t}\n\t\n\t// Set a default so that individual drivers need not specify\n\t// e.g. Cairnsmore\n\tBFGINIT(info->probe_read_count, 1);\n\tif (info->read_size == 0)\n\t\tinfo->read_size = ICARUS_DEFAULT_READ_SIZE;\n\t\n\tif (!info->golden_ob)\n\t{\n\t\t// Block 171874 nonce = (0xa2870100) = 0x000187a2\n\t\t// NOTE: this MUST take less time to calculate\n\t\t//\tthan the timeout set in icarus_open()\n\t\t//\tThis one takes ~0.53ms on Rev3 Icarus\n\t\tinfo->golden_ob =\n\t\t\t\"4679ba4ec99876bf4bfe086082b40025\"\n\t\t\t\"4df6c356451471139a3afa71e48f544a\"\n\t\t\t\"00000000000000000000000000000000\"\n\t\t\t\"0000000087320b1a1426674f2fa722ce\";\n\t\t/* NOTE: This gets sent to basically every port specified in --scan-serial,\n\t\t *       even ones that aren't Icarus; be sure they can all handle it, when\n\t\t *       this is changed...\n\t\t *       BitForce: Ignores entirely\n\t\t *       ModMiner: Starts (useless) work, gets back to clean state\n\t\t */\n\t\t\n\t\tinfo->golden_nonce = \"000187a2\";\n\t}\n\n\tif (info->detect_init_func)\n\t\tinfo->detect_init_func(devpath, fd, info);\n\t\n\tint ob_size = strlen(info->golden_ob) / 2;\n\tunsigned char ob_bin[ob_size];\n\tBFGINIT(info->ob_size, ob_size);\n\n\tif (!info->ignore_golden_nonce)\n\t{\n\t\thex2bin(ob_bin, info->golden_ob, sizeof(ob_bin));\n\t\ticarus_write(devpath, fd, ob_bin, sizeof(ob_bin));\n\t\tcgtime(&tv_start);\n\t\t\n\t\tmemset(nonce_bin, 0, sizeof(nonce_bin));\n\t\t// Do not use info->read_size here, instead read exactly ICARUS_NONCE_SIZE\n\t\t// We will then compare the bytes left in fd with info->read_size to determine\n\t\t// if this is a valid device\n\t\tstruct timeval tv_now, tv_timeout;\n\t\ttimer_set_now(&tv_now);\n\t\ttimer_set_delay(&tv_timeout, &tv_now, info->probe_read_count * 100000);\n\t\ticarus_read(devpath, nonce_bin, fd, &tv_finish, NULL, &tv_timeout, &tv_now, ICARUS_NONCE_SIZE);\n\t\t\n\t\t// How many bytes were left after reading the above nonce\n\t\tint bytes_left = icarus_excess_nonce_size(fd, info);\n\t\t\n\t\ticarus_close(fd);\n\t\t\n\t\tbin2hex(nonce_hex, nonce_bin, sizeof(nonce_bin));\n\t\tif (strncmp(nonce_hex, info->golden_nonce, 8))\n\t\t{\n\t\t\tapplog(LOG_DEBUG,\n\t\t\t\t   \"%s: \"\n\t\t\t\t   \"Test failed at %s: get %s, should: %s\",\n\t\t\t\t   api->dname,\n\t\t\t\t   devpath, nonce_hex, info->golden_nonce);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tif (info->read_size - ICARUS_NONCE_SIZE != bytes_left)\n\t\t{\n\t\t\tapplog(LOG_DEBUG,\n\t\t\t\t   \"%s: \"\n\t\t\t\t   \"Test failed at %s: expected %d bytes, got %d\",\n\t\t\t\t   api->dname,\n\t\t\t\t   devpath, info->read_size, ICARUS_NONCE_SIZE + bytes_left);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t\ticarus_close(fd);\n\t\n\tapplog(LOG_DEBUG,\n\t\t\"%s: \"\n\t\t\"Test succeeded at %s: got %s\",\n\t       api->dname,\n\t\t\tdevpath, nonce_hex);\n\n\tif (serial_claim_v(devpath, api))\n\t\treturn NULL;\n\n\t_icarus_set_timing(info, devpath, api, \"\");\n\tif (!info->fpga_count)\n\t{\n\t\tif (!info->work_division)\n\t\t{\n\t\t\tfd = icarus_open2(devpath, baud, true);\n\t\t\tinfo->work_division = icarus_probe_work_division(fd, api->dname, info);\n\t\t\ticarus_close(fd);\n\t\t}\n\t\tinfo->fpga_count = info->work_division;\n\t}\n\t// Lock fpga_count from set_work_division\n\tinfo->user_set |= IUS_FPGA_COUNT;\n\t\n\t/* We have a real Icarus! */\n\tstruct cgpu_info *icarus;\n\ticarus = calloc(1, sizeof(struct cgpu_info));\n\ticarus->drv = api;\n\ticarus->device_path = strdup(devpath);\n\ticarus->device_fd = -1;\n\ticarus->threads = 1;\n\ticarus->procs = info->fpga_count;\n\ticarus->device_data = info;\n\ticarus->set_device_funcs = icarus_set_device_funcs_live;\n\tadd_cgpu(icarus);\n\n\tapplog(LOG_INFO, \"Found %s at %s\",\n\t\ticarus->dev_repr,\n\t\tdevpath);\n\n\tapplog(LOG_DEBUG, \"%s: Init: baud=%d work_division=%d fpga_count=%d\",\n\t\ticarus->dev_repr,\n\t\tbaud, work_division, fpga_count);\n\n\ttimersub(&tv_finish, &tv_start, &(info->golden_tv));\n\n\treturn icarus;\n}\n\nstatic bool icarus_detect_one(const char *devpath)\n{\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\n\t// TODO: try some higher speeds with the Icarus and BFL to see\n\t// if they support them and if setting them makes any difference\n\t// N.B. B3000000 doesn't work on Icarus\n\tinfo->baud = ICARUS_IO_SPEED;\n\tinfo->reopen_mode = IRM_TIMEOUT;\n\tinfo->Hs = ICARUS_REV3_HASH_TIME;\n\tinfo->timing_mode = MODE_DEFAULT;\n\tinfo->read_size = ICARUS_DEFAULT_READ_SIZE;\n\n\tif (!icarus_detect_custom(devpath, &icarus_drv, info)) {\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool icarus_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, icarus_detect_one);\n}\n\nstatic bool icarus_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *icarus = thr->cgpu;\n\n\tstruct icarus_state *state;\n\tthr->cgpu_data = state = calloc(1, sizeof(*state));\n\tstate->firstrun = true;\n\n#ifdef HAVE_EPOLL\n\tint epollfd = epoll_create(2);\n\tif (epollfd != -1)\n\t{\n\t\tclose(epollfd);\n\t\tnotifier_init(thr->work_restart_notifier);\n\t}\n#endif\n\n\ticarus->status = LIFE_INIT2;\n\t\n\treturn true;\n}\n\nbool icarus_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *icarus = thr->cgpu;\n\tstruct ICARUS_INFO *info = icarus->device_data;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\t\n\tint fd = icarus_open2(icarus->device_path, info->baud, true);\n\ticarus->device_fd = fd;\n\tif (unlikely(-1 == fd)) {\n\t\tapplog(LOG_ERR, \"%s: Failed to open %s\",\n\t\t       icarus->dev_repr,\n\t\t       icarus->device_path);\n\t\treturn false;\n\t}\n\tapplog(LOG_INFO, \"%s: Opened %s\", icarus->dev_repr, icarus->device_path);\n\t\n\tBFGINIT(info->job_start_func, icarus_job_start);\n\tBFGINIT(state->ob_bin, calloc(1, info->ob_size));\n\t\n\tif (!info->work_division)\n\t\tinfo->work_division = icarus_probe_work_division(fd, icarus->dev_repr, info);\n\t\n\tif (!is_power_of_two(info->work_division))\n\t\tinfo->work_division = upper_power_of_two_u32(info->work_division);\n\tinfo->nonce_mask = mask(info->work_division);\n\t\n\treturn true;\n}\n\nstatic\nconst struct cgpu_info *icarus_proc_for_nonce(const struct cgpu_info * const icarus, const uint32_t nonce)\n{\n\tstruct ICARUS_INFO * const info = icarus->device_data;\n\tunsigned proc_id = 0;\n\tfor (int i = info->work_division, j = 0; i /= 2; ++j)\n\t\tif (nonce & (1UL << (31 - j)))\n\t\t\tproc_id |= (1 << j);\n\tconst struct cgpu_info * const proc = device_proc_by_id(icarus, proc_id) ?: icarus;\n\treturn proc;\n}\n\nstatic bool icarus_reopen(struct cgpu_info *icarus, struct icarus_state *state, int *fdp)\n{\n\tstruct ICARUS_INFO *info = icarus->device_data;\n\n\t// Reopen the serial port to workaround a USB-host-chipset-specific issue with the Icarus's buggy USB-UART\n\tdo_icarus_close(icarus->thr[0]);\n\t*fdp = icarus->device_fd = icarus_open(icarus->device_path, info->baud);\n\tif (unlikely(-1 == *fdp)) {\n\t\tapplog(LOG_ERR, \"%s: Failed to reopen on %s\", icarus->dev_repr, icarus->device_path);\n\t\tdev_error(icarus, REASON_DEV_COMMS_ERROR);\n\t\tstate->firstrun = true;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool icarus_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info * const icarus = thr->cgpu;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\tuint8_t * const ob_bin = state->ob_bin;\n\t\n\tswab256(ob_bin, work->midstate);\n\tbswap_96p(&ob_bin[0x34], &work->data[0x40]);\n\tif (!(memcmp(&ob_bin[56], \"\\xff\\xff\\xff\\xff\", 4)\n\t   || memcmp(&ob_bin[0], \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 32))) {\n\t\t// This sequence is used on cairnsmore bitstreams for commands, NEVER send it otherwise\n\t\tapplog(LOG_WARNING, \"%s: Received job attempting to send a command, corrupting it!\",\n\t\t       icarus->dev_repr);\n\t\tob_bin[56] = 0;\n\t}\n\t\n\treturn true;\n}\n\nbool icarus_job_start(struct thr_info *thr)\n{\n\tstruct cgpu_info *icarus = thr->cgpu;\n\tstruct ICARUS_INFO *info = icarus->device_data;\n\tstruct icarus_state *state = thr->cgpu_data;\n\tconst uint8_t * const ob_bin = state->ob_bin;\n\tint fd = icarus->device_fd;\n\tint ret;\n\n\t// Handle dynamic clocking for \"subclass\" devices\n\t// This needs to run before sending next job, since it hashes the command too\n\tif (info->dclk.freqM && likely(!state->firstrun)) {\n\t\tdclk_preUpdate(&info->dclk);\n\t\tdclk_updateFreq(&info->dclk, info->dclk_change_clock_func, thr);\n\t}\n\t\n\tcgtime(&state->tv_workstart);\n\n\tret = icarus_write(icarus->dev_repr, fd, ob_bin, info->ob_size);\n\tif (ret) {\n\t\tdo_icarus_close(thr);\n\t\tapplog(LOG_ERR, \"%s: Comms error (werr=%d)\", icarus->dev_repr, ret);\n\t\tdev_error(icarus, REASON_DEV_COMMS_ERROR);\n\t\treturn false;\t/* This should never happen */\n\t}\n\n\treturn true;\n}\n\nstatic\nstruct work *icarus_process_worknonce(const struct ICARUS_INFO * const info, struct icarus_state *state, uint32_t *nonce)\n{\n\t*nonce = icarus_nonce32toh(info, *nonce);\n\tif (test_nonce(state->last_work, *nonce, false))\n\t\treturn state->last_work;\n\tif (likely(state->last2_work && test_nonce(state->last2_work, *nonce, false)))\n\t\treturn state->last2_work;\n\treturn NULL;\n}\n\nstatic\nvoid handle_identify(struct thr_info * const thr, int ret, const bool was_first_run)\n{\n\tconst struct cgpu_info * const icarus = thr->cgpu;\n\tconst struct ICARUS_INFO * const info = icarus->device_data;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\tint fd = icarus->device_fd;\n\tstruct timeval tv_now;\n\tstruct timeval tv_timeout, tv_finish;\n\tdouble delapsed;\n\t\n\t// For reading the nonce from Icarus\n\tunsigned char nonce_bin[info->read_size];\n\t// For storing the the 32-bit nonce\n\tuint32_t nonce;\n\t\n\tif (fd == -1)\n\t\treturn;\n\t\n\t// If identify is requested (block erupters):\n\t// 1. Don't start the next job right away (above)\n\t// 2. Wait for the current job to complete 100%\n\t\n\tif (!was_first_run)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Identify: Waiting for current job to finish\", icarus->dev_repr);\n\t\twhile (true)\n\t\t{\n\t\t\tcgtime(&tv_now);\n\t\t\tdelapsed = tdiff(&tv_now, &state->tv_workstart);\n\t\t\tif (delapsed + 0.1 > info->fullnonce)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// Try to get more nonces (ignoring work restart)\n\t\t\tmemset(nonce_bin, 0, sizeof(nonce_bin));\n\t\t\ttimer_set_delay(&tv_timeout, &tv_now, (uint64_t)(info->fullnonce - delapsed) * 1000000);\n\t\t\tret = icarus_read(icarus->dev_repr, nonce_bin, fd, &tv_finish, NULL, &tv_timeout, &tv_now, info->read_size);\n\t\t\tif (ret == ICA_GETS_OK)\n\t\t\t{\n\t\t\t\tmemcpy(&nonce, nonce_bin, sizeof(nonce));\n\t\t\t\tnonce = icarus_nonce32toh(info, nonce);\n\t\t\t\tsubmit_nonce(icarus_proc_for_nonce(icarus, nonce)->thr[0], state->last_work, nonce);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%s: Identify: Current job should already be finished\", icarus->dev_repr);\n\t\n\t// 3. Delay 3 more seconds\n\tapplog(LOG_DEBUG, \"%s: Identify: Leaving idle for 3 seconds\", icarus->dev_repr);\n\tcgsleep_ms(3000);\n\t\n\t// Check for work restart in the meantime\n\tif (thr->work_restart)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Identify: Work restart requested during delay\", icarus->dev_repr);\n\t\tgoto no_job_start;\n\t}\n\t\n\t// 4. Start next job\n\tif (!state->firstrun)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Identify: Starting next job\", icarus->dev_repr);\n\t\tif (!info->job_start_func(thr))\nno_job_start:\n\t\t\tstate->firstrun = true;\n\t}\n\t\n\tstate->identify = false;\n}\n\nstatic\nvoid icarus_transition_work(struct icarus_state *state, struct work *work)\n{\n\tif (state->last2_work)\n\t\tfree_work(state->last2_work);\n\tstate->last2_work = state->last_work;\n\tstate->last_work = copy_work(work);\n}\n\nstatic int64_t icarus_scanhash(struct thr_info *thr, struct work *work,\n\t\t\t\t__maybe_unused int64_t max_nonce)\n{\n\tstruct cgpu_info *icarus;\n\tint fd;\n\tint ret;\n\n\tstruct ICARUS_INFO *info;\n\n\tstruct work *nonce_work;\n\tint64_t hash_count;\n\tstruct timeval tv_start = {.tv_sec=0}, elapsed;\n\tstruct timeval tv_history_start, tv_history_finish;\n\tstruct timeval tv_now, tv_timeout;\n\tdouble Ti, Xi;\n\tint i;\n\tbool was_hw_error = false;\n\tbool was_first_run;\n\n\tstruct ICARUS_HISTORY *history0, *history;\n\tint count;\n\tdouble Hs, W, fullnonce;\n\tint read_timeout_ms;\n\tbool limited;\n\tuint32_t values;\n\tint64_t hash_count_range;\n\n\telapsed.tv_sec = elapsed.tv_usec = 0;\n\n\ticarus = thr->cgpu;\n\tstruct icarus_state *state = thr->cgpu_data;\n\twas_first_run = state->firstrun;\n\n\ticarus->drv->job_prepare(thr, work, max_nonce);\n\n\t// Wait for the previous run's result\n\tfd = icarus->device_fd;\n\tinfo = icarus->device_data;\n\t\n\t// For reading the nonce from Icarus\n\tunsigned char nonce_bin[info->read_size];\n\t// For storing the the 32-bit nonce\n\tuint32_t nonce;\n\n\tif (unlikely(fd == -1) && !icarus_reopen(icarus, state, &fd))\n\t\treturn -1;\n\t\n\tif (!state->firstrun) {\n\t\tif (state->changework)\n\t\t{\n\t\t\tstate->changework = false;\n\t\t\tret = ICA_GETS_RESTART;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_timeout_ms = info->read_timeout_ms;\nkeepwaiting:\n\t\t\t/* Icarus will return info->read_size bytes nonces or nothing */\n\t\t\tmemset(nonce_bin, 0, sizeof(nonce_bin));\n\t\t\ttimer_set_now(&tv_now);\n\t\t\ttimer_set_delay(&tv_timeout, &tv_now, read_timeout_ms * 1000);\n\t\t\tret = icarus_read(icarus->dev_repr, nonce_bin, fd, &state->tv_workfinish, thr, &tv_timeout, &tv_now, info->read_size);\n\t\t\tswitch (ret) {\n\t\t\t\tcase ICA_GETS_RESTART:\n\t\t\t\t\t// The prepared work is invalid, and the current work is abandoned\n\t\t\t\t\t// Go back to the main loop to get the next work, and stuff\n\t\t\t\t\t// Returning to the main loop will clear work_restart, so use a flag...\n\t\t\t\t\tstate->changework = true;\n\t\t\t\t\treturn 0;\n\t\t\t\tcase ICA_GETS_ERROR:\n\t\t\t\t\tdo_icarus_close(thr);\n\t\t\t\t\tapplog(LOG_ERR, \"%s: Comms error (rerr)\", icarus->dev_repr);\n\t\t\t\t\tdev_error(icarus, REASON_DEV_COMMS_ERROR);\n\t\t\t\t\tif (!icarus_reopen(icarus, state, &fd))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ICA_GETS_TIMEOUT:\n\t\t\t\t\tif (info->reopen_mode == IRM_TIMEOUT && !icarus_reopen(icarus, state, &fd))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tcase ICA_GETS_OK:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttv_start = state->tv_workstart;\n\t\ttimersub(&state->tv_workfinish, &tv_start, &elapsed);\n\t}\n\telse\n\t{\n\t\tif (fd == -1 && !icarus_reopen(icarus, state, &fd))\n\t\t\treturn -1;\n\t\t\n\t\t// First run; no nonce, no hashes done\n\t\tret = ICA_GETS_ERROR;\n\t}\n\n#ifndef WIN32\n\ttcflush(fd, TCOFLUSH);\n#endif\n\n\tif (ret == ICA_GETS_OK)\n\t{\n\t\tmemcpy(&nonce, nonce_bin, sizeof(nonce));\n\t\tnonce_work = icarus_process_worknonce(info, state, &nonce);\n\t\tif (likely(nonce_work))\n\t\t{\n\t\t\tif (nonce_work == state->last2_work)\n\t\t\t{\n\t\t\t\t// nonce was for the last job; submit and keep processing the current one\n\t\t\t\tsubmit_nonce(icarus_proc_for_nonce(icarus, nonce)->thr[0], nonce_work, nonce);\n\t\t\t\tgoto keepwaiting;\n\t\t\t}\n\t\t\tif (info->continue_search)\n\t\t\t{\n\t\t\t\tread_timeout_ms = info->read_timeout_ms - ((timer_elapsed_us(&state->tv_workstart, NULL) / 1000) + 1);\n\t\t\t\tif (read_timeout_ms)\n\t\t\t\t{\n\t\t\t\t\tsubmit_nonce(icarus_proc_for_nonce(icarus, nonce)->thr[0], nonce_work, nonce);\n\t\t\t\t\tgoto keepwaiting;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twas_hw_error = true;\n\t}\n\t\n\t// Handle dynamic clocking for \"subclass\" devices\n\t// This needs to run before sending next job, since it hashes the command too\n\tif (info->dclk.freqM && likely(ret == ICA_GETS_OK || ret == ICA_GETS_TIMEOUT)) {\n\t\tint qsec = ((4 * elapsed.tv_sec) + (elapsed.tv_usec / 250000)) ?: 1;\n\t\tfor (int n = qsec; n; --n)\n\t\t\tdclk_gotNonces(&info->dclk);\n\t\tif (was_hw_error)\n\t\t\tdclk_errorCount(&info->dclk, qsec);\n\t}\n\t\n\t// Force a USB close/reopen on any hw error (or on request, eg for baud change)\n\tif (was_hw_error || info->reopen_now)\n\t{\n\t\tinfo->reopen_now = false;\n\t\tif (info->reopen_mode == IRM_CYCLE)\n\t\t{}  // Do nothing here, we reopen after sending the job\n\t\telse\n\t\tif (!icarus_reopen(icarus, state, &fd))\n\t\t\tstate->firstrun = true;\n\t}\n\n\tif (unlikely(state->identify))\n\t{\n\t\t// Delay job start until later...\n\t}\n\telse\n\tif (unlikely(icarus->deven != DEV_ENABLED || !info->job_start_func(thr)))\n\t\tstate->firstrun = true;\n\n\tif (info->reopen_mode == IRM_CYCLE && !icarus_reopen(icarus, state, &fd))\n\t\tstate->firstrun = true;\n\n\twork->blk.nonce = 0xffffffff;\n\n\tif (ret == ICA_GETS_ERROR) {\n\t\tstate->firstrun = false;\n\t\ticarus_transition_work(state, work);\n\t\thash_count = 0;\n\t\tgoto out;\n\t}\n\n\t// OK, done starting Icarus's next job... now process the last run's result!\n\n\tif (ret == ICA_GETS_OK && !was_hw_error)\n\t{\n\t\tconst struct cgpu_info * const proc = icarus_proc_for_nonce(icarus, nonce);\n\t\tsubmit_nonce(proc->thr[0], nonce_work, nonce);\n\t\t\n\t\ticarus_transition_work(state, work);\n\t\t\n\t\thash_count = (nonce & info->nonce_mask);\n\t\thash_count++;\n\t\thash_count *= info->fpga_count;\n\n\t\tif (opt_debug)\n\t\t{\n\t\t\tconst uint64_t elapsed_fs = (elapsed.tv_sec * 1000000000000000LL) + (elapsed.tv_usec * 1000000000LL);\n\t\t\tconst uint64_t est_Hs_fs = elapsed_fs / hash_count;\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\" nonce = 0x%08x = 0x%08\" PRIx64 \" hashes (%\"PRId64\".%06lus; %\"PRIu64\".%06luns/hash)\",\n\t\t\t       proc->proc_repr,\n\t\t\t       nonce,\n\t\t\t       (uint64_t)hash_count,\n\t\t\t       (int64_t)elapsed.tv_sec, (unsigned long)elapsed.tv_usec,\n\t\t\t       (uint64_t)(est_Hs_fs / 1000000LL), (unsigned long)(est_Hs_fs % 1000000LL));\n\t\t}\n\t}\n\telse\n\t{\n\t\tdouble estimate_hashes = elapsed.tv_sec;\n\t\testimate_hashes += ((double)elapsed.tv_usec) / 1000000.;\n\t\t\n\t\tconst char *repr = icarus->dev_repr;\n\t\tif (ret == ICA_GETS_OK)\n\t\t{\n\t\t\t// We can't be sure which processor got the error, but at least this is a decent guess\n\t\t\tconst struct cgpu_info * const proc = icarus_proc_for_nonce(icarus, nonce);\n\t\t\trepr = proc->proc_repr;\n\t\t\tinc_hw_errors(proc->thr[0], state->last_work, nonce);\n\t\t\testimate_hashes -= ICARUS_READ_TIME(info->baud, info->read_size);\n\t\t}\n\t\t\n\t\ticarus_transition_work(state, work);\n\t\t\n\t\testimate_hashes /= info->Hs;\n\n\t\t// If some Serial-USB delay allowed the full nonce range to\n\t\t// complete it can't have done more than a full nonce\n\t\tif (unlikely(estimate_hashes > 0xffffffff))\n\t\t\testimate_hashes = 0xffffffff;\n\t\tif (unlikely(estimate_hashes < 0))\n\t\t\testimate_hashes = 0;\n\n\t\tapplog(LOG_DEBUG, \"%s %s nonce = 0x%08\"PRIx64\" hashes (%\"PRId64\".%06lus)\",\n\t\t       repr,\n\t\t       (ret == ICA_GETS_OK) ? \"bad\" : \"no\",\n\t\t       (uint64_t)estimate_hashes,\n\t\t       (int64_t)elapsed.tv_sec, (unsigned long)elapsed.tv_usec);\n\n\t\thash_count = estimate_hashes;\n\t\t\n\t\tif (ret != ICA_GETS_OK)\n\t\t\tgoto out;\n\t}\n\n\t// Only ICA_GETS_OK gets here\n\t\n\tif (info->do_default_detection && elapsed.tv_sec >= DEFAULT_DETECT_THRESHOLD) {\n\t\tint MHs = (double)hash_count / ((double)elapsed.tv_sec * 1e6 + (double)elapsed.tv_usec);\n\t\t--info->do_default_detection;\n\t\tapplog(LOG_DEBUG, \"%s: Autodetect device speed: %d MH/s\", icarus->dev_repr, MHs);\n\t\tif (MHs <= 370 || MHs > 420) {\n\t\t\t// Not a real Icarus: enable short timing\n\t\t\tapplog(LOG_WARNING, \"%s: Seems too %s to be an Icarus; calibrating with short timing\", icarus->dev_repr, MHs>380?\"fast\":\"slow\");\n\t\t\tinfo->timing_mode = MODE_SHORT;\n\t\t\tinfo->do_icarus_timing = true;\n\t\t\tinfo->do_default_detection = 0;\n\t\t}\n\t\telse\n\t\tif (MHs <= 380) {\n\t\t\t// Real Icarus?\n\t\t\tif (!info->do_default_detection) {\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Seems to be a real Icarus\", icarus->dev_repr);\n\t\t\t\tinfo->read_timeout_ms = info->fullnonce * 1000;\n\t\t\t\tif (info->read_timeout_ms > 0)\n\t\t\t\t\t--info->read_timeout_ms;\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif (MHs <= 420) {\n\t\t\t// Enterpoint Cairnsmore1\n\t\t\tsize_t old_repr_len = strlen(icarus->dev_repr);\n\t\t\tchar old_repr[old_repr_len + 1];\n\t\t\tstrcpy(old_repr, icarus->dev_repr);\n\t\t\tconvert_icarus_to_cairnsmore(icarus);\n\t\t\tinfo->do_default_detection = 0;\n\t\t\tapplog(LOG_WARNING, \"%s: Detected Cairnsmore1 device, upgrading driver to %s\", old_repr, icarus->dev_repr);\n\t\t}\n\t}\n\n\t// Ignore possible end condition values ... and hw errors\n\t// TODO: set limitations on calculated values depending on the device\n\t// to avoid crap values caused by CPU/Task Switching/Swapping/etc\n\tif (info->do_icarus_timing\n\t&&  !was_hw_error\n\t&&  ((nonce & info->nonce_mask) > END_CONDITION)\n\t&&  ((nonce & info->nonce_mask) < (info->nonce_mask & ~END_CONDITION))) {\n\t\tcgtime(&tv_history_start);\n\n\t\thistory0 = &(info->history[0]);\n\n\t\tif (history0->values == 0)\n\t\t\ttimeradd(&tv_start, &history_sec, &(history0->finish));\n\n\t\tTi = (double)(elapsed.tv_sec)\n\t\t\t+ ((double)(elapsed.tv_usec))/((double)1000000)\n\t\t\t- ((double)ICARUS_READ_TIME(info->baud, info->read_size));\n\t\tXi = (double)hash_count;\n\t\thistory0->sumXiTi += Xi * Ti;\n\t\thistory0->sumXi += Xi;\n\t\thistory0->sumTi += Ti;\n\t\thistory0->sumXi2 += Xi * Xi;\n\n\t\thistory0->values++;\n\n\t\tif (history0->hash_count_max < hash_count)\n\t\t\thistory0->hash_count_max = hash_count;\n\t\tif (history0->hash_count_min > hash_count || history0->hash_count_min == 0)\n\t\t\thistory0->hash_count_min = hash_count;\n\n\t\tif (history0->values >= info->min_data_count\n\t\t&&  timercmp(&tv_start, &(history0->finish), >)) {\n\t\t\tfor (i = INFO_HISTORY; i > 0; i--)\n\t\t\t\tmemcpy(&(info->history[i]),\n\t\t\t\t\t&(info->history[i-1]),\n\t\t\t\t\tsizeof(struct ICARUS_HISTORY));\n\n\t\t\t// Initialise history0 to zero for summary calculation\n\t\t\tmemset(history0, 0, sizeof(struct ICARUS_HISTORY));\n\n\t\t\t// We just completed a history data set\n\t\t\t// So now recalc read_count based on the whole history thus we will\n\t\t\t// initially get more accurate until it completes INFO_HISTORY\n\t\t\t// total data sets\n\t\t\tcount = 0;\n\t\t\tfor (i = 1 ; i <= INFO_HISTORY; i++) {\n\t\t\t\thistory = &(info->history[i]);\n\t\t\t\tif (history->values >= MIN_DATA_COUNT) {\n\t\t\t\t\tcount++;\n\n\t\t\t\t\thistory0->sumXiTi += history->sumXiTi;\n\t\t\t\t\thistory0->sumXi += history->sumXi;\n\t\t\t\t\thistory0->sumTi += history->sumTi;\n\t\t\t\t\thistory0->sumXi2 += history->sumXi2;\n\t\t\t\t\thistory0->values += history->values;\n\n\t\t\t\t\tif (history0->hash_count_max < history->hash_count_max)\n\t\t\t\t\t\thistory0->hash_count_max = history->hash_count_max;\n\t\t\t\t\tif (history0->hash_count_min > history->hash_count_min || history0->hash_count_min == 0)\n\t\t\t\t\t\thistory0->hash_count_min = history->hash_count_min;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All history data\n\t\t\tHs = (history0->values*history0->sumXiTi - history0->sumXi*history0->sumTi)\n\t\t\t\t/ (history0->values*history0->sumXi2 - history0->sumXi*history0->sumXi);\n\t\t\tW = history0->sumTi/history0->values - Hs*history0->sumXi/history0->values;\n\t\t\thash_count_range = history0->hash_count_max - history0->hash_count_min;\n\t\t\tvalues = history0->values;\n\t\t\t\n\t\t\t// Initialise history0 to zero for next data set\n\t\t\tmemset(history0, 0, sizeof(struct ICARUS_HISTORY));\n\n\t\t\tfullnonce = W + Hs * (((double)0xffffffff) + 1);\n\t\t\tread_timeout_ms = fullnonce * 1000;\n\t\t\tif (read_timeout_ms > 0)\n\t\t\t\t--read_timeout_ms;\n\t\t\tif (info->read_count_limit > 0 && read_timeout_ms > info->read_count_limit * 100) {\n\t\t\t\tread_timeout_ms = info->read_count_limit * 100;\n\t\t\t\tlimited = true;\n\t\t\t} else\n\t\t\t\tlimited = false;\n\n\t\t\tinfo->Hs = Hs;\n\t\t\tinfo->read_timeout_ms = read_timeout_ms;\n\n\t\t\tinfo->fullnonce = fullnonce;\n\t\t\tinfo->count = count;\n\t\t\tinfo->W = W;\n\t\t\tinfo->values = values;\n\t\t\tinfo->hash_count_range = hash_count_range;\n\n\t\t\tif (info->min_data_count < MAX_MIN_DATA_COUNT)\n\t\t\t\tinfo->min_data_count *= 2;\n\t\t\telse if (info->timing_mode == MODE_SHORT)\n\t\t\t\tinfo->do_icarus_timing = false;\n\n\t\t\tapplog(LOG_DEBUG, \"%s Re-estimate: Hs=%e W=%e read_timeout_ms=%u%s fullnonce=%.3fs\",\n\t\t\t\t\ticarus->dev_repr,\n\t\t\t\t\tHs, W, read_timeout_ms,\n\t\t\t\t\tlimited ? \" (limited)\" : \"\", fullnonce);\n\t\t}\n\t\tinfo->history_count++;\n\t\tcgtime(&tv_history_finish);\n\n\t\ttimersub(&tv_history_finish, &tv_history_start, &tv_history_finish);\n\t\ttimeradd(&tv_history_finish, &(info->history_time), &(info->history_time));\n\t}\n\nout:\n\tif (unlikely(state->identify))\n\t\thandle_identify(thr, ret, was_first_run);\n\t\n\tint hash_count_per_proc = hash_count / icarus->procs;\n\tif (hash_count_per_proc > 0)\n\t{\n\t\tfor_each_managed_proc(proc, icarus)\n\t\t{\n\t\t\tstruct thr_info * const proc_thr = proc->thr[0];\n\t\t\t\n\t\t\thashes_done2(proc_thr, hash_count_per_proc, NULL);\n\t\t\thash_count -= hash_count_per_proc;\n\t\t}\n\t}\n\t\n\treturn hash_count;\n}\n\nstatic struct api_data *icarus_drv_stats(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\t//use cgpu->device to handle multiple processors\n\tstruct ICARUS_INFO * const info = cgpu->device->device_data;\n\n\t// Warning, access to these is not locked - but we don't really\n\t// care since hashing performance is way more important than\n\t// locking access to displaying API debug 'stats'\n\t// If locking becomes an issue for any of them, use copy_data=true also\n\tconst unsigned read_count_ds = info->read_timeout_ms / 100;\n\troot = api_add_uint(root, \"read_count\", &read_count_ds, true);\n\troot = api_add_uint(root, \"read_timeout_ms\", &(info->read_timeout_ms), false);\n\troot = api_add_int(root, \"read_count_limit\", &(info->read_count_limit), false);\n\troot = api_add_double(root, \"fullnonce\", &(info->fullnonce), false);\n\troot = api_add_int(root, \"count\", &(info->count), false);\n\troot = api_add_hs(root, \"Hs\", &(info->Hs), false);\n\troot = api_add_double(root, \"W\", &(info->W), false);\n\troot = api_add_uint(root, \"total_values\", &(info->values), false);\n\troot = api_add_uint64(root, \"range\", &(info->hash_count_range), false);\n\troot = api_add_uint64(root, \"history_count\", &(info->history_count), false);\n\troot = api_add_timeval(root, \"history_time\", &(info->history_time), false);\n\troot = api_add_uint(root, \"min_data_count\", &(info->min_data_count), false);\n\troot = api_add_uint(root, \"timing_values\", &(info->history[0].values), false);\n\troot = api_add_const(root, \"timing_mode\", timing_mode_str(info->timing_mode), false);\n\troot = api_add_bool(root, \"is_timing\", &(info->do_icarus_timing), false);\n\troot = api_add_int(root, \"baud\", &(info->baud), false);\n\troot = api_add_int(root, \"work_division\", &(info->work_division), false);\n\troot = api_add_int(root, \"fpga_count\", &(info->fpga_count), false);\n\n\treturn root;\n}\n\nconst char *icarus_set_baud(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tconst int baud = atoi(newvalue);\n\tif (!valid_baud(baud))\n\t\treturn \"Invalid baud setting\";\n\tif (info->baud != baud)\n\t{\n\t\tinfo->baud = baud;\n\t\tinfo->reopen_now = true;\n\t}\n\treturn NULL;\n}\n\nstatic\nconst char *icarus_set_probe_timeout(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tinfo->probe_read_count = atof(newvalue) * 10.0 / ICARUS_READ_FAULT_DECISECONDS;\n\treturn NULL;\n}\n\nconst char *icarus_set_work_division(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tconst int work_division = atoi(newvalue);\n\tif (!is_power_of_two(work_division))\n\t\treturn \"Invalid work_division: must be a power of two\";\n\tif (info->user_set & IUS_FPGA_COUNT)\n\t{\n\t\tif (info->fpga_count > work_division)\n\t\t\treturn \"work_division must be >= fpga_count\";\n\t}\n\telse\n\t\tinfo->fpga_count = work_division;\n\tinfo->user_set |= IUS_WORK_DIVISION;\n\tinfo->work_division = work_division;\n\tinfo->nonce_mask = mask(work_division);\n\treturn NULL;\n}\n\nstatic\nconst char *icarus_set_fpga_count(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tconst int fpga_count = atoi(newvalue);\n\tif (fpga_count < 1 || (fpga_count > info->work_division && info->work_division))\n\t\treturn \"Invalid fpga_count: must be >0 and <=work_division\";\n\tinfo->fpga_count = fpga_count;\n\treturn NULL;\n}\n\nconst char *icarus_set_reopen(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct ICARUS_INFO * const info = proc->device_data;\n\tif ((!strcasecmp(newvalue, \"never\")) || !strcasecmp(newvalue, \"-r\"))\n\t\tinfo->reopen_mode = IRM_NEVER;\n\telse\n\tif (!strcasecmp(newvalue, \"timeout\"))\n\t\tinfo->reopen_mode = IRM_TIMEOUT;\n\telse\n\tif ((!strcasecmp(newvalue, \"cycle\")) || !strcasecmp(newvalue, \"r\"))\n\t\tinfo->reopen_mode = IRM_CYCLE;\n\telse\n\tif (!strcasecmp(newvalue, \"now\"))\n\t\tinfo->reopen_now = true;\n\telse\n\t\treturn \"Invalid reopen mode\";\n\treturn NULL;\n}\n\nstatic void icarus_shutdown(struct thr_info *thr)\n{\n\tdo_icarus_close(thr);\n\tfree(thr->cgpu_data);\n}\n\nconst struct bfg_set_device_definition icarus_set_device_funcs[] = {\n\t// NOTE: Order of parameters below is important for --icarus-options\n\t{\"baud\"         , icarus_set_baud         , \"serial baud rate\"},\n\t{\"work_division\", icarus_set_work_division, \"number of pieces work is split into\"},\n\t{\"fpga_count\"   , icarus_set_fpga_count   , \"number of chips working on pieces\"},\n\t{\"reopen\"       , icarus_set_reopen       , \"how often to reopen device: never, timeout, cycle, (or now for a one-shot reopen)\"},\n\t// NOTE: Below here, order is irrelevant\n\t{\"probe_timeout\", icarus_set_probe_timeout},\n\t{\"timing\"       , icarus_set_timing       , \"timing of device; see README.FPGA\"},\n\t{NULL},\n};\n\nconst struct bfg_set_device_definition icarus_set_device_funcs_live[] = {\n\t{\"baud\"         , icarus_set_baud         , \"serial baud rate\"},\n\t{\"work_division\", icarus_set_work_division, \"number of pieces work is split into\"},\n\t{\"reopen\"       , icarus_set_reopen       , \"how often to reopen device: never, timeout, cycle, (or now for a one-shot reopen)\"},\n\t{\"timing\"       , icarus_set_timing       , \"timing of device; see README.FPGA\"},\n\t{NULL},\n};\n\nstruct device_drv icarus_drv = {\n\t.dname = \"icarus\",\n\t.name = \"ICA\",\n\t.probe_priority = -115,\n\t.lowl_probe = icarus_lowl_probe,\n\t.get_api_stats = icarus_drv_stats,\n\t.thread_prepare = icarus_prepare,\n\t.thread_init = icarus_init,\n\t.scanhash = icarus_scanhash,\n\t.job_prepare = icarus_job_prepare,\n\t.thread_disable = close_device_fd,\n\t.thread_shutdown = icarus_shutdown,\n};\n"
        },
        {
          "name": "driver-icarus.h",
          "type": "blob",
          "size": 4.703125,
          "content": "/*\n * Copyright 2012-2015 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2012 Xiangfu\n * Copyright 2012 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_DRIVER_ICARUS_H\n#define BFG_DRIVER_ICARUS_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#include \"deviceapi.h\"\n#include \"dynclock.h\"\n#include \"miner.h\"\n\n#define ICARUS_READ_FAULT_DECISECONDS 1\n\n#define NANOSEC 1000000000.0\n\n// Default value for ICARUS_INFO->read_size\n#define ICARUS_DEFAULT_READ_SIZE 4\n\n#define ICA_GETS_ERROR -1\n#define ICA_GETS_OK 0\n#define ICA_GETS_RESTART 1\n#define ICA_GETS_TIMEOUT 2\n\n// Store the last INFO_HISTORY data sets\n// [0] = current data, not yet ready to be included as an estimate\n// Each new data set throws the last old set off the end thus\n// keeping a ongoing average of recent data\n#define INFO_HISTORY 10\n\nextern struct device_drv icarus_drv;\n\nstruct ICARUS_HISTORY {\n\tstruct timeval finish;\n\tdouble sumXiTi;\n\tdouble sumXi;\n\tdouble sumTi;\n\tdouble sumXi2;\n\tuint32_t values;\n\tuint32_t hash_count_min;\n\tuint32_t hash_count_max;\n};\n\nenum timing_mode { MODE_DEFAULT, MODE_SHORT, MODE_LONG, MODE_VALUE };\nenum icarus_reopen_mode {\n\tIRM_NEVER,\n\tIRM_TIMEOUT,\n\tIRM_CYCLE,\n};\nenum icarus_user_settings {\n\tIUS_WORK_DIVISION = 1,\n\tIUS_FPGA_COUNT    = 2,\n};\n\nstruct ICARUS_INFO {\n\t// time to calculate the golden_ob\n\tstruct timeval golden_tv;\n\n\t// History structures for calculating read_count\n\t// when info->do_icarus_timing is true\n\tstruct ICARUS_HISTORY history[INFO_HISTORY+1];\n\tuint32_t min_data_count;\n\n\t// Timeout scanning for a nonce\n\tunsigned read_timeout_ms;\n\t// Timeout scanning for a golden nonce (deciseconds)\n\tint probe_read_count;\n\t\n\t// ds limit for (short=/long=) read_count\n\tint read_count_limit;\n\n\tenum timing_mode timing_mode;\n\tbool do_icarus_timing;\n\tint do_default_detection;\n\n\tdouble fullnonce;\n\tint count;\n\tdouble W;\n\tuint32_t values;\n\tuint64_t hash_count_range;\n\n\t// Determine the cost of history processing\n\t// (which will only affect W)\n\tuint64_t history_count;\n\tstruct timeval history_time;\n\n\t// icarus-options\n\tint baud;\n\t\n\t// Used to calculate / display hash count when nonce is NOT found\n\t// seconds per Hash\n\tdouble Hs;\n\t\n\t// Used to calculate / display hash count when a nonce is found\n\tint work_division;\n\tint fpga_count;\n\tuint32_t nonce_mask;\n\t\n\tenum icarus_reopen_mode reopen_mode;\n\tbool reopen_now;\n\tuint8_t user_set;\n\tbool continue_search;\n\n\tdclk_change_clock_func_t dclk_change_clock_func;\n\tstruct dclk_data dclk;\n\t\n\t// Bytes to read from Icarus for nonce\n\tint read_size;\n\t\n\t// Settings used when probing / detecting\n\tsize_t ob_size;\n\tconst char *golden_ob;\n\tconst char *golden_nonce;\n\tbool nonce_littleendian;\n\t// Don't check the golden nonce returned when probing\n\tbool ignore_golden_nonce;\n\t\n\t// Custom driver functions\n\tbool (*detect_init_func)(const char *devpath, int fd, struct ICARUS_INFO *);\n\tbool (*job_start_func)(struct thr_info *);\n\tbool has_bm1382_freq_register;\n\t\n#ifdef USE_DUALMINER\n#ifdef USE_SCRYPT\n\tbool scrypt;\n#endif\n\tbool dual_mode;\n#endif\n\t\n#ifdef USE_ZEUSMINER\n\t// Hardware information, doesn't affect anything directly\n\tuint16_t freq;\n\tuint16_t chips;\n#endif\n};\n\nstruct icarus_state {\n\tbool firstrun;\n\tstruct timeval tv_workstart;\n\tstruct timeval tv_workfinish;\n\tstruct work *last_work;\n\tstruct work *last2_work;\n\tbool changework;\n\tbool identify;\n\t\n\tuint8_t *ob_bin;\n};\n\nextern struct cgpu_info *icarus_detect_custom(const char *devpath, struct device_drv *, struct ICARUS_INFO *);\nextern int icarus_read(const char *repr, uint8_t *buf, int fd, struct timeval *tvp_finish, struct thr_info *, const struct timeval *tvp_timeout, struct timeval *tvp_now, int read_size);\nextern int icarus_write(const char * const repr, int fd, const void *buf, size_t bufLen);\nextern bool icarus_init(struct thr_info *);\nextern void do_icarus_close(struct thr_info *thr);\nextern bool icarus_job_start(struct thr_info *);\n\nextern const char *icarus_set_baud(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\nextern const char *icarus_set_work_division(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\nextern const char *icarus_set_reopen(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\nextern const char *icarus_set_timing(struct cgpu_info *proc, const char *optname, const char *newvalue, char *replybuf, enum bfg_set_device_replytype *out_success);\n\n#endif\n"
        },
        {
          "name": "driver-jingtian.c",
          "type": "blob",
          "size": 6.5146484375,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#include \"deviceapi.h\"\n#include \"driver-aan.h\"\n#include \"logging.h\"\n#include \"lowl-spi.h\"\n#include \"util.h\"\n\nstatic const int jingtian_cs_gpio[] = {14, 15, 18};\nstatic const int jingtian_spi_disable_gpio = 25;\nstatic const int jingtian_reset_gpio = 3;\nstatic const int jingtian_max_cs = 1 << (sizeof(jingtian_cs_gpio) / sizeof(*jingtian_cs_gpio));\nstatic const uint8_t jingtian_pre_header[] = {0xb5, 0xb5};\n\n#define JINGTIAN_REGISTER_EXTRA_SIZE  2\n\nBFG_REGISTER_DRIVER(jingtian_drv)\n\nstatic\nbool jingtian_spi_txrx(struct spi_port * const port)\n{\n\tif (*port->chipselect_current != port->chipselect)\n\t{\n\t\tunsigned cs_set_low = 0, cs_set_high = 0, cur_cs_bit;\n\t\tbool bit_desired;\n\t\tfor (int i = 0; i < sizeof(jingtian_cs_gpio) / sizeof(*jingtian_cs_gpio); ++i)\n\t\t{\n\t\t\tcur_cs_bit = (1 << i);\n\t\t\tbit_desired = (port->chipselect & cur_cs_bit);\n\t\t\tif (bit_desired == (bool)(*port->chipselect_current & cur_cs_bit))\n\t\t\t\t// No change needed\n\t\t\t\tcontinue;\n\t\t\tif (bit_desired)\n\t\t\t\tcs_set_high |= (1 << jingtian_cs_gpio[i]);\n\t\t\telse\n\t\t\t\tcs_set_low  |= (1 << jingtian_cs_gpio[i]);\n\t\t}\n\t\tbfg_gpio_set_high(1 << jingtian_spi_disable_gpio);\n\t\tif (cs_set_low)\n\t\t\tbfg_gpio_set_low(cs_set_low);\n\t\tif (cs_set_high)\n\t\t\tbfg_gpio_set_high(cs_set_high);\n\t\tbfg_gpio_set_low(1 << jingtian_spi_disable_gpio);\n\t\tif (opt_dev_protocol)\n\t\t\tapplog(LOG_DEBUG, \"%s(%p): CS %d\", __func__, port, port->chipselect);\n\t\t*port->chipselect_current = port->chipselect;\n\t}\n\tif (opt_dev_protocol)\n\t{\n\t\tchar x[(spi_getbufsz(port) * 2) + 1];\n\t\tbin2hex(x, spi_gettxbuf(port), spi_getbufsz(port));\n\t\tapplog(LOG_DEBUG, \"%s(%p): %cX %s\", __func__, port, 'T', x);\n\t}\n\tbool rv = linux_spi_txrx(port);\n\tif (opt_dev_protocol)\n\t{\n\t\tchar x[(spi_getbufsz(port) * 2) + 1];\n\t\tbin2hex(x, spi_getrxbuf(port), spi_getbufsz(port));\n\t\tapplog(LOG_DEBUG, \"%s(%p): %cX %s\", __func__, port, 'R', x);\n\t}\n\treturn rv;\n}\n\nstatic\nvoid jingtian_precmd(struct spi_port * const spi)\n{\n\tspi_emit_buf(spi, jingtian_pre_header, sizeof(jingtian_pre_header));\n}\n\nstatic\nbool jingtian_read_reg(struct spi_port * const spi, const uint8_t chip, void * const out_buf, const struct timeval * const tvp_timeout)\n{\n\tif (!aan_read_reg_direct(spi, chip, out_buf, tvp_timeout))\n\t\treturn false;\n\t\n\tspi_emit_nop(spi, JINGTIAN_REGISTER_EXTRA_SIZE);\n\tif (!spi_txrx(spi))\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s failed\", __func__, \"spi_txrx\");\n\t\n\tstruct cgpu_info * const dev = spi->cgpu;\n\tif (unlikely(!dev))\n\t\treturn true;\n\tstruct cgpu_info * const proc = aan_proc_for_chipid(dev, chip);\n\t\n\tuint8_t * const rx = spi_getrxbuf(spi);\n\tproc->temp = upk_u16be(rx, 0);\n\t\n\treturn true;\n}\n\nstatic\nstruct aan_hooks jingtian_hooks = {\n\t.precmd = jingtian_precmd,\n\t.read_reg = jingtian_read_reg,\n};\n\nstatic\nvoid jingtian_common_init(void)\n{\n\tRUNONCE();\n\tspi_init();\n\tfor (int i = 0; i < sizeof(jingtian_cs_gpio) / sizeof(*jingtian_cs_gpio); ++i)\n\t\tbfg_gpio_setpin_output(jingtian_cs_gpio[i]);\n\tbfg_gpio_setpin_output(jingtian_spi_disable_gpio);\n\tbfg_gpio_set_high(1 << jingtian_spi_disable_gpio);\n\t\n\tbfg_gpio_setpin_output(jingtian_reset_gpio);\n\tbfg_gpio_set_high(1 << jingtian_reset_gpio);\n\tcgsleep_ms(200);\n\tbfg_gpio_set_low(1 << jingtian_reset_gpio);\n}\n\nstatic\nbool jingtian_detect_one(const char * const devpath)\n{\n\tint found = 0, chips;\n\t\n\tjingtian_common_init();\n\t\n\tstruct spi_port spi_cfg;\n\tmemset(&spi_cfg, 0, sizeof(spi_cfg));\n\tspi_cfg.speed = 4000000;\n\tspi_cfg.delay = 0;\n\tspi_cfg.mode = SPI_MODE_1;\n\tspi_cfg.bits = 8;\n\tif (spi_open(&spi_cfg, devpath) < 0)\n\t\tapplogr(false, LOG_DEBUG, \"%s: Failed to open %s\", jingtian_drv.dname, devpath);\n\t\n\tstruct cgpu_info *cgpu, *prev_cgpu = NULL;\n\tstruct spi_port *spi;\n\tint * const chipselect_current = malloc(sizeof(*spi->chipselect_current));\n\t*chipselect_current = -1;\n\t\n\tint devpath_len = strlen(devpath);\n\t\n\tint chipcount[jingtian_max_cs];\n\tstruct spi_port *spi_a[jingtian_max_cs];\n\tfor (int i = 0; i < jingtian_max_cs; ++i)\n\t{\n\t\tspi = spi_a[i] = calloc(sizeof(*spi), 1);\n\t\tmemcpy(spi, &spi_cfg, sizeof(*spi));\n\t\tspi->repr = malloc(devpath_len + 0x10);\n\t\tsprintf((void*)spi->repr, \"%s(cs%d)\", devpath, i);\n\t\tspi->txrx = jingtian_spi_txrx;\n\t\tspi->userp = &jingtian_hooks;\n\t\tspi->chipselect = i;\n\t\tspi->chipselect_current = chipselect_current;\n\t}\n\t\n\taan_detect_spi(chipcount, spi_a, jingtian_max_cs);\n\t\n\tfor (int i = 0; i < jingtian_max_cs; ++i)\n\t{\n\t\tchips = chipcount[i];\n\t\tfree((void*)spi_a[i]->repr);\n\t\tspi_a[i]->repr = NULL;\n\t\tif (chips <= 0)\n\t\t{\n\t\t\tfree(spi_a[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tcgpu = malloc(sizeof(*cgpu));\n\t\t*cgpu = (struct cgpu_info){\n\t\t\t.drv = &jingtian_drv,\n\t\t\t.procs = chips,\n\t\t\t.threads = prev_cgpu ? 0 : 1,\n\t\t\t.device_data = spi_a[i],\n\t\t\t.device_path = strdup(devpath),\n\t\t\t.set_device_funcs = aan_set_device_funcs,\n\t\t};\n\t\tspi_a[i]->cgpu = cgpu;\n\t\tadd_cgpu_slave(cgpu, prev_cgpu);\n\t\tprev_cgpu = cgpu;\n\t\tfound += chips;\n\t}\n\t\n\tclose(spi_cfg.fd);\n\tif (!found)\n\t\tfree(chipselect_current);\n\treturn found;\n}\n\nstatic\nint jingtian_detect_auto(void)\n{\n\treturn jingtian_detect_one(\"/dev/spidev0.0\") ? 1 : 0;\n}\n\nstatic\nvoid jingtian_detect(void)\n{\n\tgeneric_detect(&jingtian_drv, jingtian_detect_one, jingtian_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\nstatic\nbool jingtian_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const master_dev = master_thr->cgpu;\n\tconst char * const devpath = master_dev->device_path;\n\tconst int fd = open(devpath, O_RDWR);\n\tif (fd < 0)\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to open %s\", master_dev->dev_repr, devpath);\n\t\n\tfor_each_managed_proc(proc, master_dev)\n\t{\n\t\tstruct spi_port * const spi = proc->device_data;\n\t\tspi->fd = fd;\n\t}\n\t\n\treturn aan_init(master_thr);\n}\n\nstruct device_drv jingtian_drv = {\n\t.dname = \"jingtian\",\n\t.name = \"JTN\",\n\t.drv_detect = jingtian_detect,\n\t\n\t.thread_init = jingtian_init,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = aan_queue_append,\n\t.queue_flush = aan_queue_flush,\n\t.poll = aan_poll,\n\t\n\t.get_api_extra_device_status = aan_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = aan_wlogprint_status,\n\t.proc_tui_wlogprint_choices = aan_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = aan_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-klondike.c",
          "type": "blob",
          "size": 47.8759765625,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n * Copyright 2013 Andrew Smith\n * Copyright 2013 Con Kolivas\n * Copyright 2013 Chris Savery\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <float.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <math.h>\n\n#ifdef WIN32\n#include <windows.h>\n#endif\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"driver-klondike.h\"\n#include \"lowlevel.h\"\n#include \"lowl-usb.h\"\n#include \"miner.h\"\n\n#define K1 \"K1\"\n#define K16 \"K16\"\n#define K64 \"K64\"\n\nstatic const char *msg_detect_send = \"DSend\";\nstatic const char *msg_detect_reply = \"DReply\";\nstatic const char *msg_send = \"Send\";\nstatic const char *msg_reply = \"Reply\";\n\n#define KLN_CMD_ABORT\t'A'\n#define KLN_CMD_CONFIG\t'C'\n#define KLN_CMD_ENABLE\t'E'\n#define KLN_CMD_IDENT\t'I'\n#define KLN_CMD_NONCE\t'='\n#define KLN_CMD_STATUS\t'S'\n#define KLN_CMD_WORK\t'W'\n\n#define KLN_CMD_ENABLE_OFF\t'0'\n#define KLN_CMD_ENABLE_ON\t'1'\n\n#define MIDSTATE_BYTES 32\n#define MERKLE_OFFSET 64\n#define MERKLE_BYTES 12\n\n#define REPLY_SIZE\t\t15\t// adequate for all types of replies\n#define MAX_KLINES\t\t1024\t// unhandled reply limit\n#define CMD_REPLY_RETRIES\t8\t// how many retries for cmds\n#define TACH_FACTOR\t\t87890\t// fan rpm divisor\n\n#define KLN_KILLWORK_TEMP\t53.5\n#define KLN_COOLED_DOWN\t\t45.5\n\n/*\n * How many incorrect slave counts to ignore in a row\n * 2 means it allows random grabage returned twice\n * Until slaves are implemented, this should never occur\n * so allowing 2 in a row should ignore random errros\n */\n#define KLN_ISS_IGNORE 2\n\n/*\n * If the queue status hasn't been updated for this long then do it now\n * 5GH/s = 859ms per full nonce range\n */\n#define LATE_UPDATE_MS ((int)(2.5 * 1000))\n\n// If 5 late updates in a row, try to reset the device\n#define LATE_UPDATE_LIMIT\t5\n\n// If the reset fails sleep for 1s\n#define LATE_UPDATE_SLEEP_MS 1000\n\n// However give up after 8s\n#define LATE_UPDATE_NODEV_MS ((int)(8.0 * 1000))\n\nBFG_REGISTER_DRIVER(klondike_drv)\n\ntypedef struct klondike_header {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t buf[REPLY_SIZE-2];\n} HEADER;\n\n#define K_2(_bytes) ((int)(_bytes[0]) + \\\n\t\t\t((int)(_bytes[1]) << 8))\n\n#define K_4(_bytes) ((uint64_t)(_bytes[0]) + \\\n\t\t\t((uint64_t)(_bytes[1]) << 8) + \\\n\t\t\t((uint64_t)(_bytes[2]) << 16) + \\\n\t\t\t((uint64_t)(_bytes[3]) << 24))\n\n#define K_SERIAL(_serial) K_4(_serial)\n#define K_HASHCOUNT(_hashcount) K_2(_hashcount)\n#define K_MAXCOUNT(_maxcount) K_2(_maxcount)\n#define K_NONCE(_nonce) K_4(_nonce)\n#define K_HASHCLOCK(_hashclock) K_2(_hashclock)\n\n#define SET_HASHCLOCK(_hashclock, _value) do { \\\n\t\t\t\t\t\t(_hashclock)[0] = (uint8_t)((_value) & 0xff); \\\n\t\t\t\t\t\t(_hashclock)[1] = (uint8_t)(((_value) >> 8) & 0xff); \\\n\t\t\t\t\t  } while(0)\n\n#define KSENDHD(_add) (sizeof(uint8_t) + sizeof(uint8_t) + _add)\n\ntypedef struct klondike_id {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t version;\n\tuint8_t product[7];\n\tuint8_t serial[4];\n} IDENTITY;\n\ntypedef struct klondike_status {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t state;\n\tuint8_t chipcount;\n\tuint8_t slavecount;\n\tuint8_t workqc;\n\tuint8_t workid;\n\tuint8_t temp;\n\tuint8_t fanspeed;\n\tuint8_t errorcount;\n\tuint8_t hashcount[2];\n\tuint8_t maxcount[2];\n\tuint8_t noise;\n} WORKSTATUS;\n\ntypedef struct _worktask {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t workid;\n\tuint8_t midstate[32];\n\tuint8_t merkle[12];\n} WORKTASK;\n\ntypedef struct _workresult {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t workid;\n\tuint8_t nonce[4];\n} WORKRESULT;\n\ntypedef struct klondike_cfg {\n\tuint8_t cmd;\n\tuint8_t dev;\n\tuint8_t hashclock[2];\n\tuint8_t temptarget;\n\tuint8_t tempcritical;\n\tuint8_t fantarget;\n\tuint8_t pad2;\n} WORKCFG;\n\ntypedef struct kline {\n\tunion {\n\t\tHEADER hd;\n\t\tIDENTITY id;\n\t\tWORKSTATUS ws;\n\t\tWORKTASK wt;\n\t\tWORKRESULT wr;\n\t\tWORKCFG cfg;\n\t};\n} KLINE;\n\n#define zero_kline(_kline) memset((void *)(_kline), 0, sizeof(KLINE));\n\ntypedef struct device_info {\n\tuint32_t noncecount;\n\tuint32_t nextworkid;\n\tuint16_t lasthashcount;\n\tuint64_t totalhashcount;\n\tuint32_t rangesize;\n\tuint32_t *chipstats;\n} DEVINFO;\n\ntypedef struct klist {\n\tstruct klist *prev;\n\tstruct klist *next;\n\tKLINE kline;\n\tstruct timeval tv_when;\n\tint block_seq;\n\tbool ready;\n\tbool working;\n} KLIST;\n\ntypedef struct jobque {\n\tint workqc;\n\tstruct timeval last_update;\n\tbool overheat;\n\tbool flushed;\n\tint late_update_count;\n\tint late_update_sequential;\n} JOBQUE;\n\nstatic\nstruct cgpu_info *klondike_get_proc(struct cgpu_info *cgpu, int procid)\n{\n\twhile (procid--)\n\t\tif (cgpu->next_proc)\n\t\t\tcgpu = cgpu->next_proc;\n\treturn cgpu;\n}\n\nstatic KLIST *new_klist_set(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *klist = NULL;\n\tint i;\n\n\tklist = calloc(MAX_KLINES, sizeof(*klist));\n\tif (!klist)\n\t\tquit(1, \"Failed to calloc klist - when old count=%d\", klninfo->kline_count);\n\n\tklninfo->kline_count += MAX_KLINES;\n\n\tklist[0].prev = NULL;\n\tklist[0].next = &(klist[1]);\n\tfor (i = 1; i < MAX_KLINES-1; i++) {\n\t\tklist[i].prev = &klist[i-1];\n\t\tklist[i].next = &klist[i+1];\n\t}\n\tklist[MAX_KLINES-1].prev = &(klist[MAX_KLINES-2]);\n\tklist[MAX_KLINES-1].next = NULL;\n\n\treturn klist;\n}\n\nstatic KLIST *allocate_kitem(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem = NULL;\n\tint ran_out = 0;\n\tchar errbuf[1024];\n\n\tcg_wlock(&klninfo->klist_lock);\n\n\tif (klninfo->free == NULL) {\n\t\tran_out = klninfo->kline_count;\n\t\tklninfo->free = new_klist_set(klncgpu);\n\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\t \"%s%i: KLINE count exceeded %d, now %d\",\n\t\t\t\t klncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t ran_out, klninfo->kline_count);\n\t}\n\n\tkitem = klninfo->free;\n\n\tklninfo->free = klninfo->free->next;\n\tif (klninfo->free)\n\t\tklninfo->free->prev = NULL;\n\n\tkitem->next = klninfo->used;\n\tkitem->prev = NULL;\n\tif (kitem->next)\n\t\tkitem->next->prev = kitem;\n\tklninfo->used = kitem;\n\n\tkitem->ready = false;\n\tkitem->working = false;\n\n\tmemset((void *)&(kitem->kline), 0, sizeof(kitem->kline));\n\n\tklninfo->used_count++;\n\n\tcg_wunlock(&klninfo->klist_lock);\n\n\tif (ran_out > 0)\n\t\tapplog(LOG_WARNING, \"%s\", errbuf);\n\n\treturn kitem;\n}\n\nstatic KLIST *release_kitem(struct cgpu_info *klncgpu, KLIST *kitem)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\n\tcg_wlock(&klninfo->klist_lock);\n\n\tif (kitem == klninfo->used)\n\t\tklninfo->used = kitem->next;\n\n\tif (kitem->next)\n\t\tkitem->next->prev = kitem->prev;\n\tif (kitem->prev)\n\t\tkitem->prev->next = kitem->next;\n\n\tkitem->next = klninfo->free;\n\tif (klninfo->free)\n\t\tklninfo->free->prev = kitem;\n\n\tkitem->prev = NULL;\n\n\tklninfo->free = kitem;\n\n\tklninfo->used_count--;\n\n\tcg_wunlock(&klninfo->klist_lock);\n\n\treturn NULL;\n}\n\nstatic\nint usb_init(struct cgpu_info * const klncgpu, struct libusb_device * const dev)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tint e;\n\tif (libusb_open(dev, &klninfo->usbdev_handle) != LIBUSB_SUCCESS)\n\t\treturn 0;\n\tif (LIBUSB_SUCCESS != (e = libusb_set_configuration(klninfo->usbdev_handle, 1)))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to set configuration 1: %s\",\n\t\t       klondike_drv.dname, bfg_strerror(e, BST_LIBUSB));\nfail:\n\t\tlibusb_close(klninfo->usbdev_handle);\n\t\treturn 0;\n\t}\n\tif (LIBUSB_SUCCESS != (e = libusb_claim_interface(klninfo->usbdev_handle, 0)))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to claim interface 0: %s\",\n\t\t       klondike_drv.dname, bfg_strerror(e, BST_LIBUSB));\n\t\tgoto fail;\n\t}\n\treturn 1;\n}\n\nstatic\nint _usb_rw(struct cgpu_info * const klncgpu, void * const buf, const size_t bufsiz, int * const processed, int ep)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tconst unsigned int timeout = 999;\n\tunsigned char *cbuf = buf;\n\tint err, sent;\n\t\n\t*processed = 0;\n\t\n\twhile (*processed < bufsiz)\n\t{\n\t\terr = libusb_bulk_transfer(klninfo->usbdev_handle, ep, cbuf, bufsiz, &sent, timeout);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\t*processed += sent;\n\t}\n\t\n\treturn LIBUSB_SUCCESS;\n}\n#define usb_read( klncgpu, buf, bufsiz, processed) _usb_rw(klncgpu, buf, bufsiz, processed, 1 | LIBUSB_ENDPOINT_IN)\n#define usb_write(klncgpu, buf, bufsiz, processed) _usb_rw(klncgpu, buf, bufsiz, processed, 1 | LIBUSB_ENDPOINT_OUT)\n\nstatic\nvoid usb_nodev(__maybe_unused struct cgpu_info * const klncgpu)\n{\n\t// TODO\n}\n\nstatic\nvoid usb_uninit(struct cgpu_info * const klncgpu)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tlibusb_release_interface(klninfo->usbdev_handle, 0);\n\tlibusb_close(klninfo->usbdev_handle);\n}\n\nstatic double cvtKlnToC(uint8_t temp)\n{\n\tdouble Rt, stein, celsius;\n\n\tif (temp == 0)\n\t\treturn 0.0;\n\n\tRt = 1000.0 * 255.0 / (double)temp - 1000.0;\n\n\tstein = log(Rt / 2200.0) / 3987.0;\n\n\tstein += 1.0 / (double)(25.0 + 273.15);\n\n\tcelsius = (1.0 / stein) - 273.15;\n\n\t// For display of bad data\n\tif (celsius < 0.0)\n\t\tcelsius = 0.0;\n\tif (celsius > 200.0)\n\t\tcelsius = 200.0;\n\n\treturn celsius;\n}\n\nstatic int cvtCToKln(double deg)\n{\n\tdouble Rt, stein, temp;\n\n\tif (deg < 0.0)\n\t\tdeg = 0.0;\n\n\tstein = 1.0 / (deg + 273.15);\n\n\tstein -= 1.0 / (double)(25.0 + 273.15);\n\n\tRt = exp(stein * 3987.0) * 2200.0;\n\n\tif (Rt == -1000.0)\n\t\tRt++;\n\n\ttemp = 1000.0 * 256.0 / (Rt + 1000.0);\n\n\tif (temp > 255)\n\t\ttemp = 255;\n\tif (temp < 0)\n\t\ttemp = 0;\n\n\treturn (int)temp;\n}\n\n// Change this to LOG_WARNING if you wish to always see the replies\n#define READ_DEBUG LOG_DEBUG\n\nstatic void display_kline(struct cgpu_info *klncgpu, KLINE *kline, const char *msg)\n{\n\tconst struct klondike_info * const klninfo = klncgpu->device_data;\n\tswitch (kline->hd.cmd) {\n\t\tcase KLN_CMD_NONCE:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s work [%c] dev=%d workid=%d\"\n\t\t\t\t\" nonce=0x%08x\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->wr.dev), msg, kline->wr.cmd,\n\t\t\t\t(int)(kline->wr.dev),\n\t\t\t\t(int)(kline->wr.workid),\n\t\t\t\t(unsigned int)K_NONCE(kline->wr.nonce) + klninfo->nonce_offset);\n\t\t\tbreak;\n\t\tcase KLN_CMD_STATUS:\n\t\tcase KLN_CMD_WORK:\n\t\tcase KLN_CMD_ENABLE:\n\t\tcase KLN_CMD_ABORT:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s status [%c] dev=%d chips=%d\"\n\t\t\t\t\" slaves=%d workcq=%d workid=%d temp=%d fan=%d\"\n\t\t\t\t\" errors=%d hashes=%d max=%d noise=%d\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->ws.dev), msg, kline->ws.cmd,\n\t\t\t\t(int)(kline->ws.dev),\n\t\t\t\t(int)(kline->ws.chipcount),\n\t\t\t\t(int)(kline->ws.slavecount),\n\t\t\t\t(int)(kline->ws.workqc),\n\t\t\t\t(int)(kline->ws.workid),\n\t\t\t\t(int)(kline->ws.temp),\n\t\t\t\t(int)(kline->ws.fanspeed),\n\t\t\t\t(int)(kline->ws.errorcount),\n\t\t\t\tK_HASHCOUNT(kline->ws.hashcount),\n\t\t\t\tK_MAXCOUNT(kline->ws.maxcount),\n\t\t\t\t(int)(kline->ws.noise));\n\t\t\tbreak;\n\t\tcase KLN_CMD_CONFIG:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s config [%c] dev=%d clock=%d\"\n\t\t\t\t\" temptarget=%d tempcrit=%d fan=%d\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->cfg.dev), msg, kline->cfg.cmd,\n\t\t\t\t(int)(kline->cfg.dev),\n\t\t\t\tK_HASHCLOCK(kline->cfg.hashclock),\n\t\t\t\t(int)(kline->cfg.temptarget),\n\t\t\t\t(int)(kline->cfg.tempcritical),\n\t\t\t\t(int)(kline->cfg.fantarget));\n\t\t\tbreak;\n\t\tcase KLN_CMD_IDENT:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s info [%c] version=0x%02x prod=%.7s\"\n\t\t\t\t\" serial=0x%08x\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev), msg, kline->hd.cmd,\n\t\t\t\t(int)(kline->id.version),\n\t\t\t\tkline->id.product,\n\t\t\t\t(unsigned int)K_SERIAL(kline->id.serial));\n\t\t\tbreak;\n\t\tdefault:\n\t\t{\n\t\t\tchar hexdata[REPLY_SIZE * 2];\n\t\t\tbin2hex(hexdata, &kline->hd.dev, REPLY_SIZE - 1);\n\t\t\tapplog(LOG_ERR,\n\t\t\t\t\"%s%i:%d %s [%c:%s] unknown and ignored\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev), msg, kline->hd.cmd,\n\t\t\t\thexdata);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void display_send_kline(struct cgpu_info *klncgpu, KLINE *kline, const char *msg)\n{\n\tswitch (kline->hd.cmd) {\n\t\tcase KLN_CMD_WORK:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s work [%c] dev=%d workid=0x%02x ...\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->wt.dev), msg, kline->ws.cmd,\n\t\t\t\t(int)(kline->wt.dev),\n\t\t\t\t(int)(kline->wt.workid));\n\t\t\tbreak;\n\t\tcase KLN_CMD_CONFIG:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s config [%c] dev=%d clock=%d\"\n\t\t\t\t\" temptarget=%d tempcrit=%d fan=%d\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->cfg.dev), msg, kline->cfg.cmd,\n\t\t\t\t(int)(kline->cfg.dev),\n\t\t\t\tK_HASHCLOCK(kline->cfg.hashclock),\n\t\t\t\t(int)(kline->cfg.temptarget),\n\t\t\t\t(int)(kline->cfg.tempcritical),\n\t\t\t\t(int)(kline->cfg.fantarget));\n\t\t\tbreak;\n\t\tcase KLN_CMD_IDENT:\n\t\tcase KLN_CMD_STATUS:\n\t\tcase KLN_CMD_ABORT:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s cmd [%c]\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev), msg, kline->hd.cmd);\n\t\t\tbreak;\n\t\tcase KLN_CMD_ENABLE:\n\t\t\tapplog(READ_DEBUG,\n\t\t\t\t\"%s%i:%d %s enable [%c] enable=%c\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev), msg, kline->hd.cmd,\n\t\t\t\t(char)(kline->hd.buf[0]));\n\t\t\tbreak;\n\t\tcase KLN_CMD_NONCE:\n\t\tdefault:\n\t\t{\n\t\t\tchar hexdata[REPLY_SIZE * 2];\n\t\t\tbin2hex(hexdata, (unsigned char *)&(kline->hd.dev), REPLY_SIZE - 1);\n\t\t\tapplog(LOG_ERR,\n\t\t\t\t\"%s%i:%d %s [%c:%s] unknown/unexpected and ignored\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev), msg, kline->hd.cmd,\n\t\t\t\thexdata);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool SendCmd(struct cgpu_info *klncgpu, KLINE *kline, int datalen)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tint err, amt, writ;\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn false;\n\n\tdisplay_send_kline(klncgpu, kline, msg_send);\n\twrit = KSENDHD(datalen);\n\terr = usb_write(klncgpu, kline, writ, &amt);\n\tif (err < 0 || amt != writ) {\n\t\tapplog(LOG_ERR, \"%s%i:%d Cmd:%c Dev:%d, write failed (%d:%d:%d)\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t(int)(kline->hd.dev),\n\t\t\t\tkline->hd.cmd, (int)(kline->hd.dev),\n\t\t\t\twrit, amt, err);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic KLIST *GetReply(struct cgpu_info *klncgpu, uint8_t cmd, uint8_t dev)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem;\n\tint retries = CMD_REPLY_RETRIES;\n\n\twhile (retries-- > 0 && klncgpu->shutdown == false) {\n\t\tcgsleep_ms(klninfo->reply_wait_time);\n\t\tcg_rlock(&klninfo->klist_lock);\n\t\tkitem = klninfo->used;\n\t\twhile (kitem) {\n\t\t\tif (kitem->kline.hd.cmd == cmd &&\n\t\t\t    kitem->kline.hd.dev == dev &&\n\t\t\t    kitem->ready == true && kitem->working == false) {\n\t\t\t\tkitem->working = true;\n\t\t\t\tcg_runlock(&klninfo->klist_lock);\n\t\t\t\treturn kitem;\n\t\t\t}\n\t\t\tkitem = kitem->next;\n\t\t}\n\t\tcg_runlock(&klninfo->klist_lock);\n\t}\n\treturn NULL;\n}\n\nstatic KLIST *SendCmdGetReply(struct cgpu_info *klncgpu, KLINE *kline, int datalen)\n{\n\tif (!SendCmd(klncgpu, kline, datalen))\n\t\treturn NULL;\n\n\treturn GetReply(klncgpu, kline->hd.cmd, kline->hd.dev);\n}\n\nstatic bool klondike_get_stats(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem;\n\tKLINE kline;\n\tint slaves, dev;\n\tuint8_t temp = 0xFF;\n\n\tif (klninfo->usbinfo_nodev || klninfo->status == NULL)\n\t\treturn false;\n\n\tapplog(LOG_DEBUG, \"%s%i: getting status\",\n\t\t\tklncgpu->drv->name, klncgpu->device_id);\n\n\trd_lock(&(klninfo->stat_lock));\n\tslaves = klninfo->status[0].kline.ws.slavecount;\n\trd_unlock(&(klninfo->stat_lock));\n\n\t// loop thru devices and get status for each\n\tfor (dev = 0; dev <= slaves; dev++) {\n\t\tzero_kline(&kline);\n\t\tkline.hd.cmd = KLN_CMD_STATUS;\n\t\tkline.hd.dev = dev;\n\t\tkitem = SendCmdGetReply(klncgpu, &kline, 0);\n\t\tif (kitem != NULL) {\n\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\tmemcpy((void *)(&(klninfo->status[dev])),\n\t\t\t\t(void *)kitem,\n\t\t\t\tsizeof(klninfo->status[dev]));\n\t\t\twr_unlock(&(klninfo->stat_lock));\n\t\t\tkitem = release_kitem(klncgpu, kitem);\n\t\t} else {\n\t\t\tapplog(LOG_ERR, \"%s%i:%d failed to update stats\",\n\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id, dev);\n\t\t}\n\t\tif (klninfo->status[dev].kline.ws.temp < temp)\n\t\t\ttemp = klninfo->status[dev].kline.ws.temp;\n\t}\n\tklncgpu->temp = cvtKlnToC(temp);\n\treturn true;\n}\n\nstatic bool kln_enable(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tKLIST *kitem;\n\tKLINE kline;\n\tconst int slaves = klninfo->status[0].kline.ws.slavecount;\n\n\tzero_kline(&kline);\n\tkline.hd.cmd = KLN_CMD_ENABLE;\n\tkline.hd.buf[0] = KLN_CMD_ENABLE_ON;\n\t\n\tfor (int dev = 0; dev <= slaves; ++dev)\n\t{\n\t\tkline.hd.dev = dev;\n\t\tfor (int tries = 3; ; --tries)\n\t\t{\n\t\t\tkitem = SendCmdGetReply(klncgpu, &kline, 1);\n\t\t\tcgsleep_ms(50);\n\t\t\tif (kitem)\n\t\t\t{\n\t\t\t\tkitem = release_kitem(klncgpu, kitem);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tries == 1)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nstatic void kln_disable(struct cgpu_info *klncgpu, int dev, bool all)\n{\n\tKLINE kline;\n\tint i;\n\n\tzero_kline(&kline);\n\tkline.hd.cmd = KLN_CMD_ENABLE;\n\tkline.hd.buf[0] = KLN_CMD_ENABLE_OFF;\n\tfor (i = (all ? 0 : dev); i <= dev; i++) {\n\t\tkline.hd.dev = i;\n\t\tSendCmd(klncgpu, &kline, KSENDHD(1));\n\t}\n}\n\nstatic\nvoid klondike_zero_stats(struct cgpu_info * const proc)\n{\n\tstruct klondike_info * const klninfo = proc->device_data;\n\t\n\tfor (int devn = klninfo->status[0].kline.ws.slavecount; devn >= 0; --devn)\n\t\tfor (int i = klninfo->status[devn].kline.ws.chipcount * 2; --i >= 0; )\n\t\t\tklninfo->devinfo[devn].chipstats[i] = 0;\n\tklninfo->hashcount = klninfo->errorcount = klninfo->noisecount = 0;\n\tklninfo->delay_count = klninfo->delay_total = klninfo->delay_min = klninfo->delay_max = 0;\n\tklninfo->nonce_count = klninfo->nonce_total = klninfo->nonce_min = klninfo->nonce_max = 0;\n}\n\nstatic bool klondike_init(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem;\n\tKLINE kline;\n\tint slaves, dev;\n\n\tklninfo->initialised = false;\n\tcgpu_set_defaults(klncgpu);\n\n\tzero_kline(&kline);\n\tkline.hd.cmd = KLN_CMD_STATUS;\n\tkline.hd.dev = 0;\n\tkitem = SendCmdGetReply(klncgpu, &kline, 0);\n\tif (kitem == NULL)\n\t\treturn false;\n\n\tslaves = kitem->kline.ws.slavecount;\n\tif (klninfo->status == NULL) {\n\t\tapplog(LOG_DEBUG, \"%s%i: initializing data\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id);\n\n\t\t// alloc space for status, devinfo, cfg and jobque for master and slaves\n\t\tklninfo->status = calloc(slaves+1, sizeof(*(klninfo->status)));\n\t\tif (unlikely(!klninfo->status))\n\t\t\tquit(1, \"Failed to calloc status array in klondke_get_stats\");\n\t\tklninfo->devinfo = calloc(slaves+1, sizeof(*(klninfo->devinfo)));\n\t\tif (unlikely(!klninfo->devinfo))\n\t\t\tquit(1, \"Failed to calloc devinfo array in klondke_get_stats\");\n\t\tklninfo->cfg = calloc(slaves+1, sizeof(*(klninfo->cfg)));\n\t\tif (unlikely(!klninfo->cfg))\n\t\t\tquit(1, \"Failed to calloc cfg array in klondke_get_stats\");\n\t\tklninfo->jobque = calloc(slaves+1, sizeof(*(klninfo->jobque)));\n\t\tif (unlikely(!klninfo->jobque))\n\t\t\tquit(1, \"Failed to calloc jobque array in klondke_get_stats\");\n\t}\n\n\tmemcpy((void *)(&(klninfo->status[0])), (void *)kitem, sizeof(klninfo->status[0]));\n\tkitem = release_kitem(klncgpu, kitem);\n\n\t// zero init triggers read back only\n\tzero_kline(&kline);\n\tkline.cfg.cmd = KLN_CMD_CONFIG;\n\n\tint size = 2;\n\n\t// boundaries are checked by device, with valid values returned\n\t{\n\t\tSET_HASHCLOCK(kline.cfg.hashclock, klninfo->clock);\n\t\tkline.cfg.temptarget = cvtCToKln(klncgpu->targettemp);\n\t\tkline.cfg.tempcritical = 0; // hard code for old firmware\n\t\tkline.cfg.fantarget = 0xff; // hard code for old firmware\n\t\tsize = sizeof(kline.cfg) - 2;\n\t}\n\n\tfor (dev = 0; dev <= slaves; dev++) {\n\t\tkline.cfg.dev = dev;\n\t\tkitem = SendCmdGetReply(klncgpu, &kline, size);\n\t\tif (kitem != NULL) {\n\t\t\tmemcpy((void *)&(klninfo->cfg[dev]), kitem, sizeof(klninfo->cfg[dev]));\n\t\t\tapplog(LOG_WARNING, \"%s%i:%d config (%d: Clk: %d, T:%.0lf, C:%.0lf, F:%d)\",\n\t\t\t\tklncgpu->drv->name, klncgpu->device_id, dev,\n\t\t\t\tdev, K_HASHCLOCK(klninfo->cfg[dev].kline.cfg.hashclock),\n\t\t\t\tcvtKlnToC(klninfo->cfg[dev].kline.cfg.temptarget),\n\t\t\t\tcvtKlnToC(klninfo->cfg[dev].kline.cfg.tempcritical),\n\t\t\t\t(int)100*klninfo->cfg[dev].kline.cfg.fantarget/256);\n\t\t\tkitem = release_kitem(klncgpu, kitem);\n\t\t}\n\t}\n\tklondike_get_stats(klncgpu);\n\tklninfo->initialised = true;\n\tfor (dev = 0; dev <= slaves; dev++) {\n\t\tklninfo->devinfo[dev].rangesize = ((uint64_t)1<<32) / klninfo->status[dev].kline.ws.chipcount;\n\t\tklninfo->devinfo[dev].chipstats = calloc(klninfo->status[dev].kline.ws.chipcount*2 , sizeof(uint32_t));\n\t}\n\n\tbool ok = kln_enable(klncgpu);\n\n\tif (!ok)\n\t\tapplog(LOG_ERR, \"%s%i: failed to enable\", klncgpu->drv->name, klncgpu->device_id);\n\n\treturn ok;\n}\n\nstatic void control_init(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\tint err, interface;\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn;\n\n\tinterface = 0;\n\n\terr = libusb_control_transfer(klninfo->usbdev_handle, 0, 9, 1, interface, NULL, 0, 999);\n\n\tapplog(LOG_DEBUG, \"%s%i: reset got err %d\",\n\t\t\t  klncgpu->drv->name, klncgpu->device_id, err);\n}\n\nstatic\nconst char *klondike_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct klondike_info * const klninfo = proc->device_data;\n\tif (klninfo->initialised)\n\t\treturn \"Cannot change clock after initialisation\";\n\tklninfo->clock = atoi(newvalue);\n\treturn NULL;\n}\n\nstatic\nconst char *klondike_set_max_work_count(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct klondike_info * const klninfo = proc->device_data;\n\tklninfo->max_work_count = atoi(newvalue);\n\treturn NULL;\n}\n\nstatic\nconst char *klondike_set_old_work_time(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct klondike_info * const klninfo = proc->device_data;\n\tklninfo->old_work_ms = atof(newvalue) * 1000.0;\n\treturn NULL;\n}\n\nstatic\nconst char *klondike_set_reply_wait_time(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct klondike_info * const klninfo = proc->device_data;\n\tklninfo->reply_wait_time = atoi(newvalue);\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition klondike_set_device_funcs[] = {\n\t{\"clock\", klondike_set_clock, \"clock frequency (can only be set at startup, with --set-device)\"},\n\t{\"max_work_count\", klondike_set_max_work_count, \"number of work items to queue on each bus\"},\n\t{\"old_work_time\", klondike_set_old_work_time, \"number of seconds to retain work\"},\n\t{\"reply_wait_time\", klondike_set_reply_wait_time, \"number of seconds poll interval\"},\n\t{NULL}\n};\n\nstatic\nbool klondike_lowl_match(const struct lowlevel_device_info * const info)\n{\n\tif (!lowlevel_match_id(info, &lowl_usb, 0x04d8, 0xf60a))\n\t\treturn false;\n\treturn (info->manufacturer && strstr(info->manufacturer, \"Klondike\"));\n}\n\nbool klondike_lowl_probe_custom(const struct lowlevel_device_info * const info, struct device_drv * const drv, struct klondike_info * const klninfo)\n{\n\tif (unlikely(info->lowl != &lowl_usb))\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplog(LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not usb!\",\n\t\t       __func__, info->product, info->serial);\n\t\tgoto err;\n\t}\n\tstruct libusb_device * const dev = info->lowl_data;\n\tif (bfg_claim_libusb(drv, true, dev))\n\t\tgoto err;\n\t\n// static bool klondike_detect_one(struct libusb_device *dev, struct usb_find_devices *found)\n\tstruct cgpu_info * const klncgpu = malloc(sizeof(*klncgpu));\n\tKLINE kline;\n\n\tif (unlikely(!klncgpu))\n\t\tquit(1, \"Failed to calloc klncgpu in klondike_detect_one\");\n\t\n\t*klncgpu = (struct cgpu_info){\n\t\t.drv = drv,\n\t\t.deven = DEV_ENABLED,\n\t\t.threads = 1,\n\t\t.targettemp = 50,\n\t\t.cutofftemp = (int)KLN_KILLWORK_TEMP,\n\t\t.set_device_funcs = klondike_set_device_funcs,\n\t};\n\n\tklncgpu->device_data = (void *)klninfo;\n\n\tklninfo->free = new_klist_set(klncgpu);\n\n\tif (usb_init(klncgpu, dev)) {\n\t\tint sent, recd, err;\n\t\tKLIST kitem;\n\t\tint attempts = 0;\n\t\t\n\t\tklncgpu->device_path = strdup(info->devid);\n\n\t\tcontrol_init(klncgpu);\n\n\t\twhile (attempts++ < 3) {\n\t\t\tkline.hd.cmd = KLN_CMD_IDENT;\n\t\t\tkline.hd.dev = 0;\n\t\t\tdisplay_send_kline(klncgpu, &kline, msg_detect_send);\n\t\t\terr = usb_write(klncgpu, (char *)&(kline.hd), 2, &sent);\n\t\t\tif (err < 0 || sent != 2) {\n\t\t\t\tapplog(LOG_ERR, \"%s (%s) detect write failed (%d:%d)\",\n\t\t\t\t\t\tklncgpu->drv->dname,\n\t\t\t\t\t\tklncgpu->device_path,\n\t\t\t\t\t\tsent, err);\n\t\t\t}\n\t\t\tcgsleep_ms(klninfo->reply_wait_time * 10);\n\t\t\terr = usb_read(klncgpu, &kitem.kline, REPLY_SIZE, &recd);\n\t\t\tif (err < 0) {\n\t\t\t\tapplog(LOG_ERR, \"%s (%s) detect read failed (%d:%d)\",\n\t\t\t\t\t\tklncgpu->drv->dname,\n\t\t\t\t\t\tklncgpu->device_path,\n\t\t\t\t\t\trecd, err);\n\t\t\t} else if (recd < 1) {\n\t\t\t\tapplog(LOG_ERR, \"%s (%s) detect empty reply (%d)\",\n\t\t\t\t\t\tklncgpu->drv->dname,\n\t\t\t\t\t\tklncgpu->device_path,\n\t\t\t\t\t\trecd);\n\t\t\t} else if (kitem.kline.hd.cmd == KLN_CMD_IDENT && kitem.kline.hd.dev == 0) {\n\t\t\t\tdisplay_kline(klncgpu, &kitem.kline, msg_detect_reply);\n\t\t\t\tapplog(LOG_DEBUG, \"%s (%s) detect successful (%d attempt%s)\",\n\t\t\t\t\t\t  klncgpu->drv->dname,\n\t\t\t\t\t\t  klncgpu->device_path,\n\t\t\t\t\t\t  attempts, attempts == 1 ? \"\" : \"s\");\n\t\t\t\t\n\t\t\t\tkline.hd.cmd = KLN_CMD_STATUS;\n\t\t\t\tif (!SendCmd(klncgpu, &kline, 0))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s (%s) status request failed\",\n\t\t\t\t\t       klncgpu->drv->dname, klncgpu->device_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcgsleep_ms(klninfo->reply_wait_time * 10);\n\t\t\t\terr = usb_read(klncgpu, &kitem.kline, REPLY_SIZE, &recd);\n\t\t\t\tif (err < 0 || recd < REPLY_SIZE)\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s (%s) status request failed (2)\",\n\t\t\t\t\t       klncgpu->drv->dname, klncgpu->device_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tklncgpu->procs = 1 + kitem.kline.ws.slavecount;\n\t\t\t\t\n\t\t\t\tif (!add_cgpu(klncgpu))\n\t\t\t\t\tbreak;\n\t\t\t\tapplog(LOG_DEBUG, \"Klondike cgpu added\");\n\t\t\t\trwlock_init(&klninfo->stat_lock);\n\t\t\t\tcglock_init(&klninfo->klist_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tusb_uninit(klncgpu);\n\t}\n\tfree(klninfo->free);\n\tfree(klncgpu);\nerr:\n\tfree(klninfo);\n\treturn false;\n}\n\nstatic\nbool klondike_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tstruct klondike_info * const klninfo = malloc(sizeof(*klninfo));\n\tif (unlikely(!klninfo))\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to malloc klninfo\", __func__);\n\t\n\t*klninfo = (struct klondike_info){\n\t\t.clock = 282,\n\t\t.max_work_count = 4,\n\t\t.old_work_ms = 5000,\n\t\t.reply_wait_time = 100,\n\t};\n\t\n\treturn klondike_lowl_probe_custom(info, &klondike_drv, klninfo);\n}\n\nstatic void klondike_check_nonce(struct cgpu_info *klncgpu, KLIST *kitem)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tstruct work *work, *look, *tmp;\n\tKLINE *kline = &(kitem->kline);\n\tstruct cgpu_info * const proc = klondike_get_proc(klncgpu, kline->wr.dev);\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct timeval tv_now;\n\tdouble us_diff;\n\tuint32_t nonce = K_NONCE(kline->wr.nonce) + klninfo->nonce_offset;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": FOUND NONCE (%02x:%08x)\",\n\t       proc->proc_repr,\n\t\t\t  kline->wr.workid, (unsigned int)nonce);\n\n\twork = NULL;\n\tcgtime(&tv_now);\n\trd_lock(&(klncgpu->qlock));\n\tHASH_ITER(hh, klncgpu->queued_work, look, tmp) {\n\t\tif (ms_tdiff(&tv_now, &(look->tv_stamp)) < klninfo->old_work_ms &&\n\t\t    (look->subid == (kline->wr.dev*256 + kline->wr.workid))) {\n\t\t\twork = look;\n\t\t\tbreak;\n\t\t}\n\t}\n\trd_unlock(&(klncgpu->qlock));\n\n\tif (work) {\n\t\tif (unlikely(!klninfo->nonce_offset))\n\t\t{\n\t\t\tbool test_c0  = test_nonce(work, nonce -  0xc0, false);\n\t\t\tbool test_180 = test_nonce(work, nonce - 0x180, false);\n\t\t\tif (test_c0)\n\t\t\t{\n\t\t\t\tif (unlikely(test_180))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Matched both c0 and 180 offsets (%02x:%08lx)\",\n\t\t\t\t\t       klncgpu->dev_repr, kline->wr.workid, (unsigned long)nonce);\n\t\t\t\t\tsubmit_nonce(thr, work, nonce - 0x180);\n\t\t\t\t\tnonce -= 0xc0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Matched c0 offset (%02x:%08lx)\",\n\t\t\t\t\t       klncgpu->dev_repr, kline->wr.workid, (unsigned long)nonce);\n\t\t\t\t\tnonce += (klninfo->nonce_offset = -0xc0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (test_180)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Matched 180 offset (%02x:%08lx)\",\n\t\t\t\t       klncgpu->dev_repr, kline->wr.workid, (unsigned long)nonce);\n\t\t\t\tnonce += (klninfo->nonce_offset = -0x180);\n\t\t\t}\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Matched neither c0 nor 180 offset (%02x:%08lx)\",\n\t\t\t\t       klncgpu->dev_repr, kline->wr.workid, (unsigned long)nonce);\n\t\t}\n\t\t\n\t\twr_lock(&(klninfo->stat_lock));\n\t\tklninfo->devinfo[kline->wr.dev].noncecount++;\n\t\tklninfo->noncecount++;\n\t\twr_unlock(&(klninfo->stat_lock));\n\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": SUBMIT NONCE (%02x:%08x)\",\n\t\t       proc->proc_repr,\n\t\t\t\t  kline->wr.workid, (unsigned int)nonce);\n\n\t\tcgtime(&tv_now);\n\t\tbool ok = submit_nonce(thr, work, nonce);\n\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": chip stats %d, %08x, %d, %d\",\n\t\t       proc->proc_repr,\n\t\t\t\t  kline->wr.dev, (unsigned int)nonce,\n\t\t\t\t  klninfo->devinfo[kline->wr.dev].rangesize,\n\t\t\t\t  klninfo->status[kline->wr.dev].kline.ws.chipcount);\n\n\t\tklninfo->devinfo[kline->wr.dev].chipstats[(nonce / klninfo->devinfo[kline->wr.dev].rangesize) + (ok ? 0 : klninfo->status[kline->wr.dev].kline.ws.chipcount)]++;\n\n\t\tus_diff = us_tdiff(&tv_now, &(kitem->tv_when));\n\t\tif (klninfo->delay_count == 0) {\n\t\t\tklninfo->delay_min = us_diff;\n\t\t\tklninfo->delay_max = us_diff;\n\t\t} else {\n\t\t\tif (klninfo->delay_min > us_diff)\n\t\t\t\tklninfo->delay_min = us_diff;\n\t\t\tif (klninfo->delay_max < us_diff)\n\t\t\t\tklninfo->delay_max = us_diff;\n\t\t}\n\t\tklninfo->delay_count++;\n\t\tklninfo->delay_total += us_diff;\n\n\t\tif (klninfo->nonce_count > 0) {\n\t\t\tus_diff = us_tdiff(&(kitem->tv_when), &(klninfo->tv_last_nonce_received));\n\t\t\tif (klninfo->nonce_count == 1) {\n\t\t\t\tklninfo->nonce_min = us_diff;\n\t\t\t\tklninfo->nonce_max = us_diff;\n\t\t\t} else {\n\t\t\t\tif (klninfo->nonce_min > us_diff)\n\t\t\t\t\tklninfo->nonce_min = us_diff;\n\t\t\t\tif (klninfo->nonce_max < us_diff)\n\t\t\t\t\tklninfo->nonce_max = us_diff;\n\t\t\t}\n\t\t\tklninfo->nonce_total += us_diff;\n\t\t}\n\t\tklninfo->nonce_count++;\n\t\thashes_done2(thr, 0x100000000, NULL);\n\n\t\tmemcpy(&(klninfo->tv_last_nonce_received), &(kitem->tv_when),\n\t\t\tsizeof(klninfo->tv_last_nonce_received));\n\n\t\treturn;\n\t}\n\n\tapplog(LOG_ERR, \"%\"PRIpreprv\": unknown work (%02x:%08x) - ignored\",\n\t       proc->proc_repr,\n\t\t\tkline->wr.workid, (unsigned int)nonce);\n\n\tinc_hw_errors2(thr, NULL, &nonce);\n}\n\n// thread to keep looking for replies\nstatic void *klondike_get_replies(void *userdata)\n{\n\tstruct cgpu_info *klncgpu = (struct cgpu_info *)userdata;\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem = NULL;\n\tint err, recd, slaves, dev, isc;\n\tbool overheat, sent;\n\n\tapplog(LOG_DEBUG, \"%s%i: listening for replies\",\n\t\t\t  klncgpu->drv->name, klncgpu->device_id);\n\n\twhile (klncgpu->shutdown == false) {\n\t\tif (klninfo->usbinfo_nodev)\n\t\t\treturn NULL;\n\n\t\tif (kitem == NULL)\n\t\t\tkitem = allocate_kitem(klncgpu);\n\t\telse\n\t\t\tmemset((void *)&(kitem->kline), 0, sizeof(kitem->kline));\n\n\t\terr = usb_read(klncgpu, &kitem->kline, REPLY_SIZE, &recd);\n\t\tif (err || recd != REPLY_SIZE) {\n\t\t\tif (err != -7)\n\t\t\t\tapplog(LOG_ERR, \"%s%i: reply err=%d amt=%d\",\n\t\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t\t\terr, recd);\n\t\t}\n\t\tif (!err && recd == REPLY_SIZE) {\n\t\t\tcgtime(&(kitem->tv_when));\n\t\t\trd_lock(&(klninfo->stat_lock));\n\t\t\tkitem->block_seq = klninfo->block_seq;\n\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\tif (opt_log_level <= READ_DEBUG) {\n\t\t\t\tchar hexdata[recd * 2];\n\t\t\t\tbin2hex(hexdata, &kitem->kline.hd.dev, recd-1);\n\t\t\t\tapplog(READ_DEBUG, \"%s%i:%d reply [%c:%s]\",\n\t\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t\t\t(int)(kitem->kline.hd.dev),\n\t\t\t\t\t\tkitem->kline.hd.cmd, hexdata);\n\t\t\t}\n\n\t\t\t// We can't check this until it's initialised\n\t\t\tif (klninfo->initialised) {\n\t\t\t\trd_lock(&(klninfo->stat_lock));\n\t\t\t\tslaves = klninfo->status[0].kline.ws.slavecount;\n\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\n\t\t\t\tif (kitem->kline.hd.dev > slaves) {\n\t\t\t\t\tapplog(LOG_ERR, \"%s%i: reply [%c] has invalid dev=%d (max=%d) using 0\",\n\t\t\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t\t\t\t(char)(kitem->kline.hd.cmd),\n\t\t\t\t\t\t\t(int)(kitem->kline.hd.dev),\n\t\t\t\t\t\t\tslaves);\n\t\t\t\t\t/* TODO: this is rather problematic if there are slaves\n\t\t\t\t\t * however without slaves - it should always be zero */\n\t\t\t\t\tkitem->kline.hd.dev = 0;\n\t\t\t\t} else {\n\t\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\t\tklninfo->jobque[kitem->kline.hd.dev].late_update_sequential = 0;\n\t\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (kitem->kline.hd.cmd) {\n\t\t\t\tcase KLN_CMD_NONCE:\n\t\t\t\t\tklondike_check_nonce(klncgpu, kitem);\n\t\t\t\t\tdisplay_kline(klncgpu, &kitem->kline, msg_reply);\n\t\t\t\t\tbreak;\n\t\t\t\tcase KLN_CMD_WORK:\n\t\t\t\t\t// We can't do/check this until it's initialised\n\t\t\t\t\tif (klninfo->initialised) {\n\t\t\t\t\t\tdev = kitem->kline.ws.dev;\n\t\t\t\t\t\tif (kitem->kline.ws.workqc == 0) {\n\t\t\t\t\t\t\tbool idle = false;\n\t\t\t\t\t\t\trd_lock(&(klninfo->stat_lock));\n\t\t\t\t\t\t\tif (klninfo->jobque[dev].flushed == false)\n\t\t\t\t\t\t\t\tidle = true;\n\t\t\t\t\t\t\tslaves = klninfo->status[0].kline.ws.slavecount;\n\t\t\t\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\t\t\t\tif (idle)\n\t\t\t\t\t\t\t\tapplog(LOG_WARNING, \"%s%i:%d went idle before work was sent\",\n\t\t\t\t\t\t\t\t\t\t    klncgpu->drv->name,\n\t\t\t\t\t\t\t\t\t\t    klncgpu->device_id,\n\t\t\t\t\t\t\t\t\t\t    dev);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\t\t\tklninfo->jobque[dev].flushed = false;\n\t\t\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\t\t\t\t\t}\n\t\t\t\tcase KLN_CMD_STATUS:\n\t\t\t\tcase KLN_CMD_ABORT:\n\t\t\t\t\t// We can't do/check this until it's initialised\n\t\t\t\t\tif (klninfo->initialised) {\n\t\t\t\t\t\tisc = 0;\n\t\t\t\t\t\tdev = kitem->kline.ws.dev;\n\t\t\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\t\t\tklninfo->jobque[dev].workqc = (int)(kitem->kline.ws.workqc);\n\t\t\t\t\t\tcgtime(&(klninfo->jobque[dev].last_update));\n\t\t\t\t\t\tslaves = klninfo->status[0].kline.ws.slavecount;\n\t\t\t\t\t\toverheat = klninfo->jobque[dev].overheat;\n\t\t\t\t\t\tif (dev == 0) {\n\t\t\t\t\t\t\tif (kitem->kline.ws.slavecount != slaves)\n\t\t\t\t\t\t\t\tisc = ++klninfo->incorrect_slave_sequential;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tisc = klninfo->incorrect_slave_sequential = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\n\t\t\t\t\t\tif (isc) {\n\t\t\t\t\t\t\tapplog(LOG_ERR, \"%s%i:%d reply [%c] has a diff\"\n\t\t\t\t\t\t\t\t\t\" # of slaves=%d (curr=%d)%s\",\n\t\t\t\t\t\t\t\t\tklncgpu->drv->name,\n\t\t\t\t\t\t\t\t\tklncgpu->device_id,\n\t\t\t\t\t\t\t\t\tdev,\n\t\t\t\t\t\t\t\t\t(char)(kitem->kline.ws.cmd),\n\t\t\t\t\t\t\t\t\t(int)(kitem->kline.ws.slavecount),\n\t\t\t\t\t\t\t\t\tslaves,\n\t\t\t\t\t\t\t\t\tisc <= KLN_ISS_IGNORE ? \"\" :\n\t\t\t\t\t\t\t\t\t \" disabling device\");\n\t\t\t\t\t\t\tif (isc > KLN_ISS_IGNORE)\n\t\t\t\t\t\t\t\tusb_nodev(klncgpu);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!overheat) {\n\t\t\t\t\t\t\tdouble temp = cvtKlnToC(kitem->kline.ws.temp);\n\t\t\t\t\t\t\tif (temp >= KLN_KILLWORK_TEMP) {\n\t\t\t\t\t\t\t\tKLINE kline;\n\n\t\t\t\t\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\t\t\t\t\tklninfo->jobque[dev].overheat = true;\n\t\t\t\t\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\n\t\t\t\t\t\t\t\tapplog(LOG_WARNING, \"%s%i:%d Critical overheat (%.0fC)\",\n\t\t\t\t\t\t\t\t\t\t    klncgpu->drv->name,\n\t\t\t\t\t\t\t\t\t\t    klncgpu->device_id,\n\t\t\t\t\t\t\t\t\t\t    dev, temp);\n\n\t\t\t\t\t\t\t\tzero_kline(&kline);\n\t\t\t\t\t\t\t\tkline.hd.cmd = KLN_CMD_ABORT;\n\t\t\t\t\t\t\t\tkline.hd.dev = dev;\n\t\t\t\t\t\t\t\tsent = SendCmd(klncgpu, &kline, KSENDHD(0));\n\t\t\t\t\t\t\t\tkln_disable(klncgpu, dev, false);\n\t\t\t\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\t\t\t\tapplog(LOG_ERR, \"%s%i:%d overheat failed to\"\n\t\t\t\t\t\t\t\t\t\t\t\" abort work - disabling device\",\n\t\t\t\t\t\t\t\t\t\t\tklncgpu->drv->name,\n\t\t\t\t\t\t\t\t\t\t\tklncgpu->device_id,\n\t\t\t\t\t\t\t\t\t\t\tdev);\n\t\t\t\t\t\t\t\t\tusb_nodev(klncgpu);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase KLN_CMD_ENABLE:\n\t\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\t\tklninfo->errorcount += kitem->kline.ws.errorcount;\n\t\t\t\t\tklninfo->noisecount += kitem->kline.ws.noise;\n\t\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\t\t\t\t\tdisplay_kline(klncgpu, &kitem->kline, msg_reply);\n\t\t\t\t\tkitem->ready = true;\n\t\t\t\t\tkitem = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KLN_CMD_CONFIG:\n\t\t\t\t\tdisplay_kline(klncgpu, &kitem->kline, msg_reply);\n\t\t\t\t\tkitem->ready = true;\n\t\t\t\t\tkitem = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KLN_CMD_IDENT:\n\t\t\t\t\tdisplay_kline(klncgpu, &kitem->kline, msg_reply);\n\t\t\t\t\tkitem->ready = true;\n\t\t\t\t\tkitem = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdisplay_kline(klncgpu, &kitem->kline, msg_reply);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void klondike_flush_work(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tKLIST *kitem;\n\tKLINE kline;\n\tint slaves, dev;\n\n\tif (klninfo->initialised) {\n\t\twr_lock(&(klninfo->stat_lock));\n\t\tklninfo->block_seq++;\n\t\tslaves = klninfo->status[0].kline.ws.slavecount;\n\t\twr_unlock(&(klninfo->stat_lock));\n\n\t\tapplog(LOG_DEBUG, \"%s%i: flushing work\",\n\t\t\t\t  klncgpu->drv->name, klncgpu->device_id);\n\t\tzero_kline(&kline);\n\t\tkline.hd.cmd = KLN_CMD_ABORT;\n\t\tfor (dev = 0; dev <= slaves; dev++) {\n\t\t\tkline.hd.dev = dev;\n\t\t\tkitem = SendCmdGetReply(klncgpu, &kline, KSENDHD(0));\n\t\t\tif (kitem != NULL) {\n\t\t\t\twr_lock(&(klninfo->stat_lock));\n\t\t\t\tmemcpy((void *)&(klninfo->status[dev]),\n\t\t\t\t\tkitem,\n\t\t\t\t\tsizeof(klninfo->status[dev]));\n\t\t\t\tklninfo->jobque[dev].flushed = true;\n\t\t\t\twr_unlock(&(klninfo->stat_lock));\n\t\t\t\tkitem = release_kitem(klncgpu, kitem);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool klondike_thread_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *klncgpu = thr->cgpu;\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\n\tif (thr_info_create(&(klninfo->replies_thr), NULL, klondike_get_replies, (void *)klncgpu)) {\n\t\tapplog(LOG_ERR, \"%s%i: thread create failed\", klncgpu->drv->name, klncgpu->device_id);\n\t\treturn false;\n\t}\n\tpthread_detach(klninfo->replies_thr.pth);\n\n\t// let the listening get started\n\tcgsleep_ms(100);\n\n\treturn klondike_init(klncgpu);\n}\n\nstatic bool klondike_thread_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *klncgpu = thr->cgpu;\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\t\n\tnotifier_init(thr->work_restart_notifier);\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn false;\n\n\tklondike_flush_work(klncgpu);\n\n\treturn true;\n}\n\nstatic void klondike_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *klncgpu = thr->cgpu;\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\n\tapplog(LOG_DEBUG, \"%s%i: shutting down work\",\n\t\t\t  klncgpu->drv->name, klncgpu->device_id);\n\n\tkln_disable(klncgpu, klninfo->status[0].kline.ws.slavecount, true);\n\n\tklncgpu->shutdown = true;\n}\n\nstatic void klondike_thread_enable(struct thr_info *thr)\n{\n\tstruct cgpu_info *klncgpu = thr->cgpu;\n\tstruct klondike_info * const klninfo = klncgpu->device_data;\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn;\n\n/*\n\tKLINE kline;\n\n\tzero_kline(&kline);\n\tkline.hd.cmd = KLN_CMD_ENABLE;\n\tkline.hd.dev = dev;\n\tkline.hd.buf[0] = KLN_CMD_ENABLE_OFF;\n\tkitem = SendCmdGetReply(klncgpu, &kline, KSENDHD(1));\n*/\n\n}\n\nstatic bool klondike_send_work(struct cgpu_info *klncgpu, int dev, struct work *work)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tstruct work *look, *tmp;\n\tKLINE kline;\n\tstruct timeval tv_old;\n\tint wque_size, wque_cleared;\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn false;\n\n\tzero_kline(&kline);\n\tkline.wt.cmd = KLN_CMD_WORK;\n\tkline.wt.dev = dev;\n\tmemcpy(kline.wt.midstate, work->midstate, MIDSTATE_BYTES);\n\tmemcpy(kline.wt.merkle, work->data + MERKLE_OFFSET, MERKLE_BYTES);\n\tkline.wt.workid = (uint8_t)(klninfo->devinfo[dev].nextworkid++ & 0xFF);\n\twork->subid = dev*256 + kline.wt.workid;\n\tcgtime(&work->tv_stamp);\n\n\tif (opt_log_level <= LOG_DEBUG) {\n\t\tchar hexdata[(sizeof(kline.wt) * 2) + 1];\n\t\tbin2hex(hexdata, &kline.wt, sizeof(kline.wt));\n\t\tapplog(LOG_DEBUG, \"WORKDATA: %s\", hexdata);\n\t}\n\n\tapplog(LOG_DEBUG, \"%s%i:%d sending work (%d:%02x)\",\n\t\t\t  klncgpu->drv->name, klncgpu->device_id, dev,\n\t\t\t  dev, kline.wt.workid);\n\tKLIST *kitem = SendCmdGetReply(klncgpu, &kline, sizeof(kline.wt));\n\tif (kitem != NULL) {\n\t\twr_lock(&(klninfo->stat_lock));\n\t\tmemcpy((void *)&(klninfo->status[dev]), kitem, sizeof(klninfo->status[dev]));\n\t\twr_unlock(&(klninfo->stat_lock));\n\t\tkitem = release_kitem(klncgpu, kitem);\n\n\t\t// remove old work\n\t\twque_size = 0;\n\t\twque_cleared = 0;\n\t\tcgtime(&tv_old);\n\t\twr_lock(&klncgpu->qlock);\n\t\tHASH_ITER(hh, klncgpu->queued_work, look, tmp) {\n\t\t\tif (ms_tdiff(&tv_old, &(look->tv_stamp)) > klninfo->old_work_ms) {\n\t\t\t\t__work_completed(klncgpu, look);\n\t\t\t\tfree_work(look);\n\t\t\t\twque_cleared++;\n\t\t\t} else\n\t\t\t\twque_size++;\n\t\t}\n\t\twr_unlock(&klncgpu->qlock);\n\n\t\twr_lock(&(klninfo->stat_lock));\n\t\tklninfo->wque_size = wque_size;\n\t\tklninfo->wque_cleared = wque_cleared;\n\t\twr_unlock(&(klninfo->stat_lock));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool klondike_queue_full(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tstruct work *work = NULL;\n\tint dev, queued, slaves, seq, howlong;\n\tstruct timeval now;\n\tbool nowork;\n\n\tif (klncgpu->shutdown == true)\n\t\treturn true;\n\n\tcgtime(&now);\n\trd_lock(&(klninfo->stat_lock));\n\tslaves = klninfo->status[0].kline.ws.slavecount;\n\tfor (dev = 0; dev <= slaves; dev++)\n\t\tif (ms_tdiff(&now, &(klninfo->jobque[dev].last_update)) > LATE_UPDATE_MS) {\n\t\t\tklninfo->jobque[dev].late_update_count++;\n\t\t\tseq = ++klninfo->jobque[dev].late_update_sequential;\n\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\tif (seq < LATE_UPDATE_LIMIT) {\n\t\t\t\tapplog(LOG_DEBUG, \"%s%i:%d late update\",\n\t\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id, dev);\n\t\t\t\tklondike_get_stats(klncgpu);\n\t\t\t\tgoto que;\n\t\t\t} else {\n\t\t\t\tapplog(LOG_WARNING, \"%s%i:%d late update (%d) reached - attempting reset\",\n\t\t\t\t\t\t    klncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t\t\t    dev, LATE_UPDATE_LIMIT);\n\t\t\t\tcontrol_init(klncgpu);\n\t\t\t\tkln_enable(klncgpu);\n\t\t\t\tklondike_get_stats(klncgpu);\n\t\t\t\trd_lock(&(klninfo->stat_lock));\n\t\t\t\thowlong = ms_tdiff(&now, &(klninfo->jobque[dev].last_update));\n\t\t\t\tif (howlong > LATE_UPDATE_MS) {\n\t\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\t\tif (howlong > LATE_UPDATE_NODEV_MS) {\n\t\t\t\t\t\tapplog(LOG_ERR, \"%s%i:%d reset failed - dropping device\",\n\t\t\t\t\t\t\t\tklncgpu->drv->name, klncgpu->device_id, dev);\n\t\t\t\t\t\tusb_nodev(klncgpu);\n\t\t\t\t\t} else\n\t\t\t\t\t\tcgsleep_ms(LATE_UPDATE_SLEEP_MS);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\trd_unlock(&(klninfo->stat_lock));\n\nque:\n\n\tnowork = true;\n\tfor (queued = 0; queued < klninfo->max_work_count - 1; ++queued)\n\t\tfor (dev = 0; dev <= slaves; dev++) {\ntryagain:\n\t\t\trd_lock(&(klninfo->stat_lock));\n\t\t\tif (klninfo->jobque[dev].overheat) {\n\t\t\t\tdouble temp = cvtKlnToC(klninfo->status[0].kline.ws.temp);\n\t\t\t\tif ((queued == klninfo->max_work_count - 2) &&\n\t\t\t\t    ms_tdiff(&now, &(klninfo->jobque[dev].last_update)) > (LATE_UPDATE_MS/2)) {\n\t\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\t\tklondike_get_stats(klncgpu);\n\t\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\t\tif (temp <= KLN_COOLED_DOWN) {\n\t\t\t\t\tklninfo->jobque[dev].overheat = false;\n\t\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\t\tapplog(LOG_WARNING, \"%s%i:%d Overheat recovered (%.0fC)\",\n\t\t\t\t\t\t\t    klncgpu->drv->name, klncgpu->device_id,\n\t\t\t\t\t\t\t    dev, temp);\n\t\t\t\t\tkln_enable(klncgpu);\n\t\t\t\t\tgoto tryagain;\n\t\t\t\t} else {\n\t\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (klninfo->jobque[dev].workqc <= queued) {\n\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t\t\tif (!work)\n\t\t\t\t\twork = get_queued(klncgpu);\n\t\t\t\tif (unlikely(!work))\n\t\t\t\t\treturn false;\n\t\t\t\tnowork = false;\n\t\t\t\tif (klondike_send_work(klncgpu, dev, work))\n\t\t\t\t\treturn false;\n\t\t\t} else\n\t\t\t\trd_unlock(&(klninfo->stat_lock));\n\t\t}\n\n\tif (nowork)\n\t\tcgsleep_ms(10); // avoid a hard loop in case we have nothing to do\n\n\treturn true;\n}\n\nstatic int64_t klondike_scanwork(struct thr_info *thr)\n{\n\tstruct cgpu_info *klncgpu = thr->cgpu;\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tint dev, slaves;\n\n\tif (klninfo->usbinfo_nodev)\n\t\treturn -1;\n\n\trestart_wait(thr, 200);\n\tif (klninfo->status != NULL) {\n\t\trd_lock(&(klninfo->stat_lock));\n\t\tslaves = klninfo->status[0].kline.ws.slavecount;\n\t\tfor (dev = 0; dev <= slaves; dev++) {\n\t\t\tuint64_t newhashdev = 0, hashcount;\n\t\t\tint maxcount;\n\n\t\t\thashcount = K_HASHCOUNT(klninfo->status[dev].kline.ws.hashcount);\n\t\t\tmaxcount = K_MAXCOUNT(klninfo->status[dev].kline.ws.maxcount);\n\t\t\t// todo: chg this to check workid for wrapped instead\n\t\t\tif (klninfo->devinfo[dev].lasthashcount > hashcount)\n\t\t\t\tnewhashdev += maxcount; // hash counter wrapped\n\t\t\tnewhashdev += hashcount - klninfo->devinfo[dev].lasthashcount;\n\t\t\tklninfo->devinfo[dev].lasthashcount = hashcount;\n\t\t\tif (maxcount != 0)\n\t\t\t\tklninfo->hashcount += (newhashdev << 32) / maxcount;\n\t\t}\n\t\tklninfo->noncecount = 0;\n\t\trd_unlock(&(klninfo->stat_lock));\n\t}\n\n\treturn 0;\n}\n\n\n#ifdef HAVE_CURSES\nstatic\nvoid klondike_wlogprint_status(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tuint16_t fan = 0;\n\tuint16_t clock = 0;\n\tint dev, slaves;\n\n\tif (klninfo->status == NULL) {\n\t\treturn;\n\t}\n\n\trd_lock(&(klninfo->stat_lock));\n\tslaves = klninfo->status[0].kline.ws.slavecount;\n\tfor (dev = 0; dev <= slaves; dev++) {\n\t\tfan += klninfo->cfg[dev].kline.cfg.fantarget;\n\t\tclock += (uint16_t)K_HASHCLOCK(klninfo->cfg[dev].kline.cfg.hashclock);\n\t}\n\trd_unlock(&(klninfo->stat_lock));\n\tfan /= slaves + 1;\n        fan = 100 * fan / 255;\n\tclock /= slaves + 1;\n\twlogprint(\"Frequency: %d MHz\\n\", (int)clock);\n\tif (fan && fan <= 100)\n\t\twlogprint(\"Fan speed: %d%%\\n\", fan);\n}\n#endif\n\nstatic struct api_data *klondike_api_stats(struct cgpu_info *klncgpu)\n{\n\tstruct klondike_info *klninfo = (struct klondike_info *)(klncgpu->device_data);\n\tstruct api_data *root = NULL;\n\tchar buf[32];\n\tint dev, slaves;\n\n\tif (klninfo->status == NULL)\n\t\treturn NULL;\n\n\trd_lock(&(klninfo->stat_lock));\n\tslaves = klninfo->status[0].kline.ws.slavecount;\n\tfor (dev = 0; dev <= slaves; dev++) {\n\n\t\tfloat fTemp = cvtKlnToC(klninfo->status[dev].kline.ws.temp);\n\t\tsprintf(buf, \"Temp %d\", dev);\n\t\troot = api_add_temp(root, buf, &fTemp, true);\n\n\t\tdouble dClk = (double)K_HASHCLOCK(klninfo->cfg[dev].kline.cfg.hashclock);\n\t\tsprintf(buf, \"Clock %d\", dev);\n\t\troot = api_add_freq(root, buf, &dClk, true);\n\n\t\tunsigned int iFan = (unsigned int)100 * klninfo->cfg[dev].kline.cfg.fantarget / 255;\n\t\tsprintf(buf, \"Fan Percent %d\", dev);\n\t\troot = api_add_int(root, buf, (int *)(&iFan), true);\n\n\t\tiFan = 0;\n\t\tif (klninfo->status[dev].kline.ws.fanspeed > 0)\n\t\t\tiFan = (unsigned int)TACH_FACTOR / klninfo->status[dev].kline.ws.fanspeed;\n\t\tsprintf(buf, \"Fan RPM %d\", dev);\n\t\troot = api_add_int(root, buf, (int *)(&iFan), true);\n\n\t\tif (klninfo->devinfo[dev].chipstats != NULL) {\n\t\t\tchar data[2048];\n\t\t\tchar one[32];\n\t\t\tint n;\n\n\t\t\tsprintf(buf, \"Nonces / Chip %d\", dev);\n\t\t\tdata[0] = '\\0';\n\t\t\tfor (n = 0; n < klninfo->status[dev].kline.ws.chipcount; n++) {\n\t\t\t\tsnprintf(one, sizeof(one), \"%07d \", klninfo->devinfo[dev].chipstats[n]);\n\t\t\t\tstrcat(data, one);\n\t\t\t}\n\t\t\troot = api_add_string(root, buf, data, true);\n\n\t\t\tsprintf(buf, \"Errors / Chip %d\", dev);\n\t\t\tdata[0] = '\\0';\n\t\t\tfor (n = 0; n < klninfo->status[dev].kline.ws.chipcount; n++) {\n\t\t\t\tsnprintf(one, sizeof(one), \"%07d \", klninfo->devinfo[dev].chipstats[n + klninfo->status[dev].kline.ws.chipcount]);\n\t\t\t\tstrcat(data, one);\n\t\t\t}\n\t\t\troot = api_add_string(root, buf, data, true);\n\t\t}\n\t}\n\n\troot = api_add_uint64(root, \"Hash Count\", &(klninfo->hashcount), true);\n\troot = api_add_uint64(root, \"Error Count\", &(klninfo->errorcount), true);\n\troot = api_add_uint64(root, \"Noise Count\", &(klninfo->noisecount), true);\n\n\troot = api_add_int(root, \"KLine Limit\", &(klninfo->kline_count), true);\n\troot = api_add_int(root, \"KLine Used\", &(klninfo->used_count), true);\n\n\troot = api_add_elapsed(root, \"KQue Delay Count\", &(klninfo->delay_count), true);\n\troot = api_add_elapsed(root, \"KQue Delay Total\", &(klninfo->delay_total), true);\n\troot = api_add_elapsed(root, \"KQue Delay Min\", &(klninfo->delay_min), true);\n\troot = api_add_elapsed(root, \"KQue Delay Max\", &(klninfo->delay_max), true);\n\tdouble avg;\n\tif (klninfo->delay_count == 0)\n\t\tavg = 0;\n\telse\n\t\tavg = klninfo->delay_total / klninfo->delay_count;\n\troot = api_add_diff(root, \"KQue Delay Avg\", &avg, true);\n\n\troot = api_add_elapsed(root, \"KQue Nonce Count\", &(klninfo->nonce_count), true);\n\troot = api_add_elapsed(root, \"KQue Nonce Total\", &(klninfo->nonce_total), true);\n\troot = api_add_elapsed(root, \"KQue Nonce Min\", &(klninfo->nonce_min), true);\n\troot = api_add_elapsed(root, \"KQue Nonce Max\", &(klninfo->nonce_max), true);\n\tif (klninfo->nonce_count == 0)\n\t\tavg = 0;\n\telse\n\t\tavg = klninfo->nonce_total / klninfo->nonce_count;\n\troot = api_add_diff(root, \"KQue Nonce Avg\", &avg, true);\n\n\troot = api_add_int(root, \"WQue Size\", &(klninfo->wque_size), true);\n\troot = api_add_int(root, \"WQue Cleared\", &(klninfo->wque_cleared), true);\n\n\trd_unlock(&(klninfo->stat_lock));\n\n\treturn root;\n}\n\nstruct device_drv klondike_drv = {\n\t.dname = \"klondike\",\n\t.name = \"KLN\",\n\t.lowl_match = klondike_lowl_match,\n\t.lowl_probe = klondike_lowl_probe,\n\t.get_api_stats = klondike_api_stats,\n\t.get_stats = klondike_get_stats,\n\t.thread_prepare = klondike_thread_prepare,\n\t.thread_init = klondike_thread_init,\n\t.minerloop = hash_queued_work,\n\t.scanwork = klondike_scanwork,\n\t.queue_full = klondike_queue_full,\n\t.flush_work = klondike_flush_work,\n\t.thread_shutdown = klondike_shutdown,\n\t.thread_enable = klondike_thread_enable,\n\t\n\t.zero_stats = klondike_zero_stats,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = klondike_wlogprint_status,\n#endif\n};\n"
        },
        {
          "name": "driver-klondike.h",
          "type": "blob",
          "size": 1.3056640625,
          "content": "#ifndef BFG_DRIVER_KLONDIKE_H\n#define BFG_DRIVER_KLONDIKE_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#include <pthread.h>\n\n#include \"lowlevel.h\"\n#include \"miner.h\"\n\nstruct klondike_info {\n\tpthread_rwlock_t stat_lock;\n\tstruct thr_info replies_thr;\n\tcglock_t klist_lock;\n\tstruct klist *used;\n\tstruct klist *free;\n\tint kline_count;\n\tint used_count;\n\tint block_seq;\n\tstruct klist *status;\n\tstruct device_info *devinfo;\n\tstruct klist *cfg;\n\tstruct jobque *jobque;\n\tint noncecount;\n\tuint64_t hashcount;\n\tuint64_t errorcount;\n\tuint64_t noisecount;\n\tint incorrect_slave_sequential;\n\tint16_t nonce_offset;\n\n\t// us Delay from USB reply to being processed\n\tdouble delay_count;\n\tdouble delay_total;\n\tdouble delay_min;\n\tdouble delay_max;\n\n\tstruct timeval tv_last_nonce_received;\n\n\t// Time from recieving one nonce to the next\n\tdouble nonce_count;\n\tdouble nonce_total;\n\tdouble nonce_min;\n\tdouble nonce_max;\n\n\tint wque_size;\n\tint wque_cleared;\n\n\tint clock;\n\tbool initialised;\n\t\n\tstruct libusb_device_handle *usbdev_handle;\n\t\n\t// TODO:\n\tbool usbinfo_nodev;\n\t\n\tint max_work_count;\n\tint old_work_ms;\n\tint reply_wait_time;\n};\n\nextern bool klondike_lowl_probe_custom(const struct lowlevel_device_info * const info, struct device_drv * const drv, struct klondike_info * const klninfo);\n\nextern struct device_drv klondike_drv;\n\n#endif\n"
        },
        {
          "name": "driver-knc.c",
          "type": "blob",
          "size": 20.173828125,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <math.h>\n\n#ifdef HAVE_LINUX_I2C_DEV_USER_H\n#include <linux/i2c-dev-user.h>\n#else\n#include <linux/i2c-dev.h>\n#endif\n#include <linux/spi/spidev.h>\n\n#include <uthash.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#define KNC_POLL_INTERVAL_US 10000\n#define KNC_SPI_SPEED 3000000\n#define KNC_SPI_DELAY 0\n#define KNC_SPI_MODE  (SPI_CPHA | SPI_CPOL | SPI_CS_HIGH)\n#define KNC_SPI_BITS  8\n\n\n/*\n The core disable/enable strategy is as follows:\n\n If a core gets 10 HW errors in a row without doing any proper work\n it is disabled for 10 seconds.\n\n When a core gets 10 HW errors the next time it checks when it was enabled\n the last time and compare that to when it started to get errors.\n If those times are close (50%) the disabled time is doubled,\n if not it is just disabled for 10s again.\n\n */\n\n#define KNC_MAX_HWERR_IN_ROW    10\n#define KNC_HWERR_DISABLE_SECS (10)\n#define KNC_MAX_DISABLE_SECS   (15 * 60)\n\n#define KNC_CORES_PER_DIE  0x30\n#define KNC_DIE_PER_CHIP      4\n#define KNC_CORES_PER_CHIP  (KNC_CORES_PER_DIE * KNC_DIE_PER_CHIP)\n\n\nstatic const char * const i2cpath = \"/dev/i2c-2\";\n\n#define KNC_I2C_TEMPLATE \"/dev/i2c-%d\"\n\nenum knc_request_cmd {\n\tKNC_REQ_SUBMIT_WORK = 2,\n\tKNC_REQ_FLUSH_QUEUE = 3,\n};\n\nenum knc_reply_type {\n\tKNC_REPLY_NONCE_FOUND = 1,\n\tKNC_REPLY_WORK_DONE   = 2,\n};\n\nenum knc_i2c_core_status {\n\tKNC_I2CSTATUS_DISABLED = 2,\n\tKNC_I2CSTATUS_ENABLED  = 3,\n};\n\nBFG_REGISTER_DRIVER(knc_drv)\nstatic const struct bfg_set_device_definition knc_set_device_funcs[];\n\nstruct knc_device {\n\tint i2c;\n\tstruct spi_port *spi;\n\tstruct cgpu_info *cgpu;\n\t\n\tbool need_flush;\n\tstruct work *workqueue;\n\tint workqueue_size;\n\tint workqueue_max;\n\tint next_id;\n\t\n\tstruct work *devicework;\n};\n\nstruct knc_core {\n\tint asicno;\n\tint coreno;\n\t\n\tbool use_dcdc;\n\tfloat volt;\n\tfloat current;\n\t\n\tint hwerr_in_row;\n\tint hwerr_disable_time;\n\tstruct timeval enable_at;\n\tstruct timeval first_hwerr;\n};\n\nstatic\nbool knc_detect_one(const char *devpath)\n{\n\tstatic struct cgpu_info *prev_cgpu = NULL;\n\tstruct cgpu_info *cgpu;\n\tint i;\n\tconst int fd = open(i2cpath, O_RDWR);\n\tchar *leftover = NULL;\n\tconst int i2cslave = strtol(devpath, &leftover, 0);\n\tuint8_t buf[0x20];\n\t\n\tif (leftover && leftover[0])\n\t\treturn false;\n\t\n\tif (unlikely(fd == -1))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to open %s\", __func__, i2cpath);\n\t\treturn false;\n\t}\n\t\n\tif (ioctl(fd, I2C_SLAVE, i2cslave))\n\t{\n\t\tclose(fd);\n\t\tapplog(LOG_DEBUG, \"%s: Failed to select i2c slave 0x%x\",\n\t\t       __func__, i2cslave);\n\t\treturn false;\n\t}\n\t\n\ti = i2c_smbus_read_i2c_block_data(fd, 0, 0x20, buf);\n\tclose(fd);\n\tif (-1 == i)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: 0x%x: Failed to read i2c block data\",\n\t\t       __func__, i2cslave);\n\t\treturn false;\n\t}\n\tfor (i = 0; ; ++i)\n\t{\n\t\tif (buf[i] == 3)\n\t\t\tbreak;\n\t\tif (i == 0x1f)\n\t\t\treturn false;\n\t}\n\t\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &knc_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.set_device_funcs = knc_set_device_funcs,\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = KNC_CORES_PER_CHIP,\n\t\t.threads = prev_cgpu ? 0 : 1,\n\t};\n\tconst bool rv = add_cgpu_slave(cgpu, prev_cgpu);\n\tprev_cgpu = cgpu;\n\treturn rv;\n}\n\nstatic int knc_detect_auto(void)\n{\n\tconst int first = 0x20, last = 0x26;\n\tchar devpath[4];\n\tint found = 0, i;\n\t\n\tfor (i = first; i <= last; ++i)\n\t{\n\t\tsprintf(devpath, \"%d\", i);\n\t\tif (knc_detect_one(devpath))\n\t\t\t++found;\n\t}\n\t\n\treturn found;\n}\n\nstatic void knc_detect(void)\n{\n\tgeneric_detect(&knc_drv, knc_detect_one, knc_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\n\nstatic\nbool knc_spi_open(const char *repr, struct spi_port * const spi)\n{\n\tconst char * const spipath = \"/dev/spidev1.0\";\n\tconst int fd = open(spipath, O_RDWR);\n\tconst uint8_t lsbfirst = 0;\n\tif (fd == -1)\n\t\treturn false;\n\tif (ioctl(fd, SPI_IOC_WR_MODE         , &spi->mode )) goto fail;\n\tif (ioctl(fd, SPI_IOC_WR_LSB_FIRST    , &lsbfirst  )) goto fail;\n\tif (ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &spi->bits )) goto fail;\n\tif (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ , &spi->speed)) goto fail;\n\tspi->fd = fd;\n\treturn true;\n\nfail:\n\tclose(fd);\n\tspi->fd = -1;\n\tapplog(LOG_WARNING, \"%s: Failed to open %s\", repr, spipath);\n\treturn false;\n}\n\n#define knc_spi_txrx  linux_spi_txrx\n\nstatic\nvoid knc_clean_flush(struct spi_port * const spi)\n{\n\tconst uint8_t flushcmd = KNC_REQ_FLUSH_QUEUE << 4;\n\tconst size_t spi_req_sz = 0x1000;\n\t\n\tspi_clear_buf(spi);\n\tspi_emit_buf(spi, &flushcmd, 1);\n\tspi_emit_nop(spi, spi_req_sz - spi_getbufsz(spi));\n\tapplog(LOG_DEBUG, \"%s: Issuing flush command to clear out device queues\", knc_drv.dname);\n\tspi_txrx(spi);\n}\n\nstatic\nbool knc_init(struct thr_info * const thr)\n{\n\tconst int max_cores = KNC_CORES_PER_CHIP;\n\tstruct thr_info *mythr;\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct knc_device *knc;\n\tstruct knc_core *knccore;\n\tstruct spi_port *spi;\n\tconst int i2c = open(i2cpath, O_RDWR);\n\tint i2cslave, i, j;\n\tuint8_t buf[0x20];\n\t\n\tif (unlikely(i2c == -1))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to open %s\", __func__, i2cpath);\n\t\treturn false;\n\t}\n\t\n\tknc = malloc(sizeof(*knc));\n\t\n\tfor (proc = cgpu; proc; )\n\t{\n\t\tif (proc->device != proc)\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Extra processor?\", proc->proc_repr);\n\t\t\tproc = proc->next_proc;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ti2cslave = atoi(proc->device_path);\n\t\t\n\t\tif (ioctl(i2c, I2C_SLAVE, i2cslave))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%s: Failed to select i2c slave 0x%x\",\n\t\t\t       __func__, i2cslave);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < max_cores; i += 0x20)\n\t\t{\n\t\t\ti2c_smbus_read_i2c_block_data(i2c, i, 0x20, buf);\n\t\t\tfor (j = 0; j < 0x20; ++j)\n\t\t\t{\n\t\t\t\tmythr = proc->thr[0];\n\t\t\t\tmythr->cgpu_data = knccore = malloc(sizeof(*knccore));\n\t\t\t\t*knccore = (struct knc_core){\n\t\t\t\t\t.asicno = i2cslave - 0x20,\n\t\t\t\t\t.coreno = i + j,\n\t\t\t\t\t.hwerr_in_row = 0,\n\t\t\t\t\t.hwerr_disable_time = KNC_HWERR_DISABLE_SECS,\n\t\t\t\t\t.use_dcdc = true,\n\t\t\t\t};\n\t\t\t\ttimer_set_now(&knccore->enable_at);\n\t\t\t\tproc->device_data = knc;\n\t\t\t\tswitch (buf[j])\n\t\t\t\t{\n\t\t\t\t\tcase KNC_I2CSTATUS_ENABLED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:  // permanently disabled\n\t\t\t\t\t\tproc->deven = DEV_DISABLED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KNC_I2CSTATUS_DISABLED:\n\t\t\t\t\t\tproc->deven = DEV_RECOVER_DRV;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tproc = proc->next_proc;\n\t\t\t\tif ((!proc) || proc->device == proc)\n\t\t\t\t\tgoto nomorecores;\n\t\t\t}\n\t\t}\nnomorecores: ;\n\t}\n\t\n\tspi = malloc(sizeof(*spi));\n\t*knc = (struct knc_device){\n\t\t.i2c = i2c,\n\t\t.spi = spi,\n\t\t.cgpu = cgpu,\n\t\t.workqueue_max = 1,\n\t};\n\t\n\t/* Be careful, read lowl-spi.h comments for warnings */\n\tmemset(spi, 0, sizeof(*spi));\n\tspi->txrx = knc_spi_txrx;\n\tspi->cgpu = cgpu;\n\tspi->repr = knc_drv.dname;\n\tspi->logprio = LOG_ERR;\n\tspi->speed = KNC_SPI_SPEED;\n\tspi->delay = KNC_SPI_DELAY;\n\tspi->mode = KNC_SPI_MODE;\n\tspi->bits = KNC_SPI_BITS;\n\t\n\tcgpu_set_defaults(cgpu);\n\t\n\tif (!knc_spi_open(cgpu->dev_repr, spi))\n\t\treturn false;\n\t\n\tknc_clean_flush(spi);\n\t\n\ttimer_set_now(&thr->tv_poll);\n\t\n\treturn true;\n}\n\nstatic\nvoid knc_set_queue_full(struct knc_device * const knc)\n{\n\tconst bool full = (knc->workqueue_size >= knc->workqueue_max);\n\tstruct cgpu_info *proc;\n\t\n\tfor (proc = knc->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tthr->queue_full = full;\n\t}\n}\n\nstatic\nvoid knc_remove_local_queue(struct knc_device * const knc, struct work * const work)\n{\n\tDL_DELETE(knc->workqueue, work);\n\tfree_work(work);\n\t--knc->workqueue_size;\n}\n\nstatic\nvoid knc_prune_local_queue(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_device * const knc = cgpu->device_data;\n\tstruct work *work, *tmp;\n\t\n\tDL_FOREACH_SAFE(knc->workqueue, work, tmp)\n\t{\n\t\tif (stale_work(work, false))\n\t\t\tknc_remove_local_queue(knc, work);\n\t}\n\tknc_set_queue_full(knc);\n}\n\nstatic\nbool knc_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_device * const knc = cgpu->device_data;\n\t\n\tif (knc->workqueue_size >= knc->workqueue_max)\n\t{\n\t\tknc_prune_local_queue(thr);\n\t\tif (thr->queue_full)\n\t\t\treturn false;\n\t}\n\t\n\tDL_APPEND(knc->workqueue, work);\n\t++knc->workqueue_size;\n\t\n\tknc_set_queue_full(knc);\n\tif (thr->queue_full)\n\t\tknc_prune_local_queue(thr);\n\t\n\treturn true;\n}\n\n#define HASH_LAST_ADDED(head, out)  \\\n\t(out = (head) ? (ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail)) : NULL)\n\nstatic\nvoid knc_queue_flush(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_device * const knc = cgpu->device_data;\n\tstruct work *work, *tmp;\n\t\n\tif (knc->cgpu != cgpu)\n\t\treturn;\n\t\n\tDL_FOREACH_SAFE(knc->workqueue, work, tmp)\n\t{\n\t\tknc_remove_local_queue(knc, work);\n\t}\n\tknc_set_queue_full(knc);\n\t\n\tHASH_LAST_ADDED(knc->devicework, work);\n\tif (work && stale_work(work, true))\n\t{\n\t\tknc->need_flush = true;\n\t\ttimer_set_now(&thr->tv_poll);\n\t}\n}\n\nstatic inline\nuint16_t get_u16be(const void * const p)\n{\n\tconst uint8_t * const b = p;\n\treturn (((uint16_t)b[0]) << 8) | b[1];\n}\n\nstatic inline\nuint32_t get_u32be(const void * const p)\n{\n\tconst uint8_t * const b = p;\n\treturn (((uint32_t)b[0]) << 0x18)\n\t     | (((uint32_t)b[1]) << 0x10)\n\t     | (((uint32_t)b[2]) << 8)\n\t     |             b[3];\n}\n\nstatic\nvoid knc_poll(struct thr_info * const thr)\n{\n\tstruct thr_info *mythr;\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct knc_device * const knc = cgpu->device_data;\n\tstruct spi_port * const spi = knc->spi;\n\tstruct knc_core *knccore;\n\tstruct work *work, *tmp;\n\tuint8_t buf[0x30], *rxbuf;\n\tint works_sent = 0, asicno, i;\n\tuint16_t workaccept;\n\tint workid = knc->next_id;\n\tuint32_t nonce, coreno;\n\tsize_t spi_req_sz = 0x1000;\n\tunsigned long delay_usecs = KNC_POLL_INTERVAL_US;\n\t\n\tknc_prune_local_queue(thr);\n\t\n\tspi_clear_buf(spi);\n\tif (knc->need_flush)\n\t{\n\t\tapplog(LOG_NOTICE, \"%s: Abandoning stale searches to restart\", knc_drv.dname);\n\t\tbuf[0] = KNC_REQ_FLUSH_QUEUE << 4;\n\t\tspi_emit_buf(spi, buf, sizeof(buf));\n\t}\n\tDL_FOREACH(knc->workqueue, work)\n\t{\n\t\tbuf[0] = KNC_REQ_SUBMIT_WORK << 4;\n\t\tbuf[1] = 0;\n\t\tbuf[2] = (workid >> 8) & 0x7f;\n\t\tbuf[3] = workid & 0xff;\n\t\t\n\t\tfor (i = 0; i < 0x20; ++i)\n\t\t\tbuf[4 + i] = work->midstate[0x1f - i];\n\t\tfor (i = 0; i < 0xc; ++i)\n\t\t\tbuf[0x24 + i] = work->data[0x4b - i];\n\t\t\n\t\tspi_emit_buf(spi, buf, sizeof(buf));\n\t\t\n\t\t++works_sent;\n\t\t++workid;\n\t}\n\tspi_emit_nop(spi, spi_req_sz - spi_getbufsz(spi));\n\tspi_txrx(spi);\n\t\n\trxbuf = spi_getrxbuf(spi);\n\tif (rxbuf[3] & 1)\n\t\tapplog(LOG_DEBUG, \"%s: Receive buffer overflow reported\", knc_drv.dname);\n\tworkaccept = get_u16be(&rxbuf[6]);\n\tapplog(LOG_DEBUG, \"%s: %lu/%d jobs accepted to queue (max=%d)\",\n\t       knc_drv.dname, (unsigned long)workaccept, works_sent, knc->workqueue_max);\n\t\n\twhile (true)\n\t{\n\t\trxbuf += 0xc;\n\t\tspi_req_sz -= 0xc;\n\t\tif (spi_req_sz < 0xc)\n\t\t\tbreak;\n\t\t\n\t\tconst int rtype = rxbuf[0] >> 6;\n\t\tif (rtype && opt_debug)\n\t\t{\n\t\t\tchar x[(0xc * 2) + 1];\n\t\t\tbin2hex(x, rxbuf, 0xc);\n\t\t\tapplog(LOG_DEBUG, \"%s: RECV: %s\", knc_drv.dname, x);\n\t\t}\n\t\tif (rtype != KNC_REPLY_NONCE_FOUND && rtype != KNC_REPLY_WORK_DONE)\n\t\t\tcontinue;\n\t\t\n\t\tasicno = (rxbuf[0] & 0x38) >> 3;\n\t\tcoreno = get_u32be(&rxbuf[8]);\n\t\tproc = cgpu;\n\t\twhile (true)\n\t\t{\n\t\t\tknccore = proc->thr[0]->cgpu_data;\n\t\t\tif (knccore->asicno == asicno)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tproc = proc->next_proc;\n\t\t\t} while(proc != proc->device);\n\t\t}\n\t\tfor (i = 0; i < coreno; ++i)\n\t\t\tproc = proc->next_proc;\n\t\tmythr = proc->thr[0];\n\t\tknccore = mythr->cgpu_data;\n\t\t\n\t\ti = get_u16be(&rxbuf[2]);\n\t\tHASH_FIND_INT(knc->devicework, &i, work);\n\t\tif (!work)\n\t\t{\n\t\t\tconst char * const msgtype = (rtype == KNC_REPLY_NONCE_FOUND) ? \"nonce found\" : \"work done\";\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Got %s message about unknown work 0x%04x\",\n\t\t\t       proc->proc_repr, msgtype, i);\n\t\t\tif (KNC_REPLY_NONCE_FOUND == rtype)\n\t\t\t{\n\t\t\t\tnonce = get_u32be(&rxbuf[4]);\n\t\t\t\tnonce = le32toh(nonce);\n\t\t\t\tinc_hw_errors2(mythr, NULL, &nonce);\n\t\t\t}\n\t\t\telse\n\t\t\t\tinc_hw_errors2(mythr, NULL, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (rtype)\n\t\t{\n\t\t\tcase KNC_REPLY_NONCE_FOUND:\n\t\t\t\tnonce = get_u32be(&rxbuf[4]);\n\t\t\t\tnonce = le32toh(nonce);\n\t\t\t\tif (submit_nonce(mythr, work, nonce))\n\t\t\t\t\tknccore->hwerr_in_row = 0;\n\t\t\t\tbreak;\n\t\t\tcase KNC_REPLY_WORK_DONE:\n\t\t\t\tHASH_DEL(knc->devicework, work);\n\t\t\t\tfree_work(work);\n\t\t\t\thashes_done2(mythr, 0x100000000, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (knc->need_flush)\n\t{\n\t\tknc->need_flush = false;\n\t\tHASH_ITER(hh, knc->devicework, work, tmp)\n\t\t{\n\t\t\tHASH_DEL(knc->devicework, work);\n\t\t\tfree_work(work);\n\t\t}\n\t\tdelay_usecs = 0;\n\t}\n\t\n\tif (workaccept)\n\t{\n\t\tif (workaccept >= knc->workqueue_max)\n\t\t{\n\t\t\tknc->workqueue_max = workaccept;\n\t\t\tdelay_usecs = 0;\n\t\t}\n\t\tDL_FOREACH_SAFE(knc->workqueue, work, tmp)\n\t\t{\n\t\t\t--knc->workqueue_size;\n\t\t\tDL_DELETE(knc->workqueue, work);\n\t\t\twork->device_id = knc->next_id++ & 0x7fff;\n\t\t\tHASH_ADD(hh, knc->devicework, device_id, sizeof(work->device_id), work);\n\t\t\tif (!--workaccept)\n\t\t\t\tbreak;\n\t\t}\n\t\tknc_set_queue_full(knc);\n\t}\n\t\n\ttimer_set_delay_from_now(&thr->tv_poll, delay_usecs);\n}\n\nstatic\nbool _knc_core_setstatus(struct thr_info * const thr, uint8_t val)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct knc_device * const knc = proc->device_data;\n\tstruct knc_core * const knccore = thr->cgpu_data;\n\tconst int i2c = knc->i2c;\n\tconst int i2cslave = 0x20 + knccore->asicno;\n\t\n\tif (ioctl(i2c, I2C_SLAVE, i2cslave))\n\t{\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s: Failed to select i2c slave 0x%x\",\n\t\t       proc->proc_repr, __func__, i2cslave);\n\t\treturn false;\n\t}\n\t\n\treturn (-1 != i2c_smbus_write_byte_data(i2c, knccore->coreno, val));\n}\n\nstatic\nvoid knc_core_disable(struct thr_info * const thr)\n{\n\t_knc_core_setstatus(thr, 0);\n}\n\nstatic\nvoid knc_core_enable(struct thr_info * const thr)\n{\n\tstruct knc_core * const knccore = thr->cgpu_data;\n\ttimer_set_now(&knccore->enable_at);\n\t_knc_core_setstatus(thr, 1);\n}\n\nstatic\nfloat knc_dcdc_decode_5_11(uint16_t raw)\n{\n\tif (raw == 0)\n\t\treturn 0.0;\n\t\n\tint dcdc_vin_exp = (raw & 0xf800) >> 11;\n\tfloat dcdc_vin_man = raw & 0x07ff;\n\tif (dcdc_vin_exp >= 16)\n\t\tdcdc_vin_exp = -32 + dcdc_vin_exp;\n\tfloat dcdc_vin = dcdc_vin_man * exp2(dcdc_vin_exp);\n\treturn dcdc_vin;\n}\n\nstatic\nvoid knc_hw_error(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct knc_core * const knccore = thr->cgpu_data;\n\t\n\tif(knccore->hwerr_in_row == 0)\n\t\ttimer_set_now(&knccore->first_hwerr);\n\t++knccore->hwerr_in_row;\n\t\n\tif (knccore->hwerr_in_row >= KNC_MAX_HWERR_IN_ROW && proc->deven == DEV_ENABLED)\n\t{\n\t\tstruct timeval now;\n\t\ttimer_set_now(&now);\n\t\tfloat first_err_dt  = tdiff(&now, &knccore->first_hwerr);\n\t\tfloat enable_dt     = tdiff(&now, &knccore->enable_at);\n\t\t\n\t\tif(first_err_dt * 1.5 > enable_dt)\n\t\t{\n\t\t\t// didn't really do much good\n\t\t\tknccore->hwerr_disable_time *= 2;\n\t\t\tif (knccore->hwerr_disable_time > KNC_MAX_DISABLE_SECS)\n\t\t\t\tknccore->hwerr_disable_time = KNC_MAX_DISABLE_SECS;\n\t\t}\n\t\telse\n\t\t\tknccore->hwerr_disable_time  = KNC_HWERR_DISABLE_SECS;\n\t\tproc->deven = DEV_RECOVER_DRV;\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Disabled. %d hwerr in %.3f / %.3f . disabled %d s\",\n\t\t       proc->proc_repr, knccore->hwerr_in_row,\n\t\t       enable_dt, first_err_dt, knccore->hwerr_disable_time);\n\t\t\n\t\ttimer_set_delay_from_now(&knccore->enable_at, knccore->hwerr_disable_time * 1000000);\n\t}\n}\n\nstatic\nbool knc_get_stats(struct cgpu_info * const cgpu)\n{\n\tif (cgpu->device != cgpu)\n\t\treturn true;\n\t\n\tstruct thr_info *thr = cgpu->thr[0];\n\tstruct knc_core *knccore = thr->cgpu_data;\n\tstruct cgpu_info *proc;\n\tconst int i2cdev = knccore->asicno + 3;\n\tconst int i2cslave_temp = 0x48;\n\tconst int i2cslave_dcdc[] = {0x10, 0x12, 0x14, 0x17};\n\tint die, i;\n\tint i2c;\n\tint32_t rawtemp, rawvolt, rawcurrent;\n\tfloat temp, volt, current;\n\tstruct timeval tv_now;\n\tbool rv = false;\n\t\n\tchar i2cpath[sizeof(KNC_I2C_TEMPLATE)];\n\tsprintf(i2cpath, KNC_I2C_TEMPLATE, i2cdev);\n\ti2c = open(i2cpath, O_RDWR);\n\tif (i2c == -1)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: %s: Failed to open %s\",\n\t\t       cgpu->dev_repr, __func__, i2cpath);\n\t\treturn false;\n\t}\n\t\n\tif (ioctl(i2c, I2C_SLAVE, i2cslave_temp))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: %s: Failed to select i2c slave 0x%x\",\n\t\t       cgpu->dev_repr, __func__, i2cslave_temp);\n\t\tgoto out;\n\t}\n\t\n\trawtemp = i2c_smbus_read_word_data(i2c, 0);\n\tif (rawtemp == -1)\n\t\tgoto out;\n\ttemp = ((float)(rawtemp & 0xff));\n\tif (rawtemp & 0x8000)\n\t\ttemp += 0.5;\n\t\n\t/* DCDC i2c slaves are on 0x10 + [0-7]\n\t   8 DCDC boards have all populated\n\t   4 DCDC boards only have 0,2,4,7 populated\n\t   Only 0,2,4,7 are used\n\t   Each DCDC powers one die in the chip, each die has 48 cores\n\t   \n\t   Datasheet at http://www.lineagepower.com/oem/pdf/MDT040A0X.pdf\n\t*/\n\n\ttimer_set_now(&tv_now);\n\tvolt = current = 0;\n\tfor (proc = cgpu, i = 0; proc && proc->device == cgpu; proc = proc->next_proc, ++i)\n\t{\n\t\tthr = proc->thr[0];\n\t\tknccore = thr->cgpu_data;\n\t\tdie = i / KNC_CORES_PER_DIE;\n\t\t\n\t\tif (0 == i % KNC_CORES_PER_DIE && knccore->use_dcdc)\n\t\t{\n\t\t\tif (ioctl(i2c, I2C_SLAVE, i2cslave_dcdc[die]))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s: %s: Failed to select i2c slave 0x%x\",\n\t\t\t\t       cgpu->dev_repr, __func__, i2cslave_dcdc[die]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t\n\t\t\trawvolt = i2c_smbus_read_word_data(i2c, 0x8b);  // VOUT\n\t\t\tif (rawvolt == -1)\n\t\t\t\tgoto out;\n\t\t\t\n\t\t\trawcurrent = i2c_smbus_read_word_data(i2c, 0x8c);  // IOUT\n\t\t\tif (rawcurrent == -1)\n\t\t\t\tgoto out;\n\t\t\t\n\t\t\tvolt    = (float)rawvolt * exp2(-10);\n\t\t\tcurrent = (float)knc_dcdc_decode_5_11(rawcurrent);\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"%s: die %d %6.3fV %5.2fA\",\n\t\t\t       cgpu->dev_repr, die, volt, current);\n\t\t}\n\t\t\n\t\tproc->temp = temp;\n\t\tknccore->volt = volt;\n\t\tknccore->current = current;\n\t\t\n\t\t// NOTE: We need to check _mt_disable_called because otherwise enabling won't assert it to i2c (it's false when getting stats for eg proc 0 before proc 1+ haven't initialised completely yet)\n\t\tif (proc->deven == DEV_RECOVER_DRV && timer_passed(&knccore->enable_at, &tv_now) && thr->_mt_disable_called)\n\t\t{\n\t\t\tknccore->hwerr_in_row = 0;\n\t\t\tproc_enable(proc);\n\t\t}\n\t}\n\t\n\trv = true;\nout:\n\tclose(i2c);\n\treturn rv;\n}\n\nstatic\nstruct api_data *knc_api_extra_device_status(struct cgpu_info * const cgpu)\n{\n\tstruct api_data *root = NULL;\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct knc_core * const knccore = thr->cgpu_data;\n\t\n\tif (knccore->use_dcdc)\n\t{\n\t\troot = api_add_volts(root, \"Voltage\", &knccore->volt, false);\n\t\troot = api_add_volts(root, \"DCDC Current\", &knccore->current, false);\n\t}\n\t\n\treturn root;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid knc_wlogprint_status(struct cgpu_info * const cgpu)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct knc_core * const knccore = thr->cgpu_data;\n\t\n\tif (knccore->use_dcdc)\n\t\twlogprint(\"Voltage: %.3f  DCDC Current: %.3f\\n\",\n\t\t          knccore->volt, knccore->current);\n}\n#endif\n\nstatic\nconst char *knc_set_use_dcdc(struct cgpu_info *proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tint core_index_on_die = proc->proc_id % KNC_CORES_PER_DIE;\n\tbool nv;\n\tchar *end;\n\t\n\tnv = bfg_strtobool(newvalue, &end, 0);\n\tif (!(newvalue[0] && !end[0]))\n\t\treturn \"Usage: use_dcdc=yes/no\";\n\t\n\tif (core_index_on_die)\n\t{\n\t\tconst int seek = (proc->proc_id / KNC_CORES_PER_DIE) * KNC_CORES_PER_DIE;\n\t\tproc = proc->device;\n\t\tfor (int i = 0; i < seek; ++i)\n\t\t\tproc = proc->next_proc;\n\t}\n\t\n\t{\n\t\tstruct thr_info * const mythr = proc->thr[0];\n\t\tstruct knc_core * const knccore = mythr->cgpu_data;\n\t\t\n\t\tif (knccore->use_dcdc == nv)\n\t\t\treturn NULL;\n\t}\n\t\n\tfor (int i = 0; i < KNC_CORES_PER_DIE; (proc = proc->next_proc), ++i)\n\t{\n\t\tstruct thr_info * const mythr = proc->thr[0];\n\t\tstruct knc_core * const knccore = mythr->cgpu_data;\n\t\t\n\t\tknccore->use_dcdc = nv;\n\t}\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition knc_set_device_funcs[] = {\n\t{\"use_dcdc\", knc_set_use_dcdc, \"whether to access DCDC module for voltage/current information\"},\n\t{NULL}\n};\n\nstruct device_drv knc_drv = {\n\t.dname = \"knc\",\n\t.name = \"KNC\",\n\t.drv_detect = knc_detect,\n\t\n\t.thread_init = knc_init,\n\t.thread_disable = knc_core_disable,\n\t.thread_enable  = knc_core_enable,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = knc_queue_append,\n\t.queue_flush = knc_queue_flush,\n\t.poll = knc_poll,\n\t.hw_error = knc_hw_error,\n\t\n\t.get_stats = knc_get_stats,\n\t.get_api_extra_device_status = knc_api_extra_device_status,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = knc_wlogprint_status,\n#endif\n};\n"
        },
        {
          "name": "driver-kncasic.c",
          "type": "blob",
          "size": 31.9912109375,
          "content": "/*\n * Copyright 2014 KnCminer\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include <stdlib.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#include <zlib.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"knc-asic/knc-transport.h\"\n#include \"knc-asic/knc-asic.h\"\n\n#define WORKS_PER_CORE          3\n\n#define CORE_ERROR_LIMIT\t30\n#define CORE_ERROR_INTERVAL\t30\n#define CORE_ERROR_DISABLE_TIME\t5*60\n#define CORE_SUBMIT_MIN_TIME\t2\n#define CORE_TIMEOUT\t\t20\n#define SCAN_ADJUST_RANGE\t32\n\nBFG_REGISTER_DRIVER(kncasic_drv)\n\n#define KNC_FREE_WORK(WORK) do { \\\n\tfree_work(WORK); \\\n\tWORK = NULL; \\\n} while (0)\n\nstatic struct timeval now;\nstatic const struct timeval core_check_interval = {\n\tCORE_ERROR_INTERVAL, 0\n};\nstatic const struct timeval core_disable_interval = {\n\tCORE_ERROR_DISABLE_TIME, 0\n};\nstatic const struct timeval core_submit_interval = {\n\tCORE_SUBMIT_MIN_TIME, 0\n};\nstatic const struct timeval core_timeout_interval = {\n\tCORE_TIMEOUT, 0\n};\n\nstruct knc_die;\n\nstruct knc_core_state {\n\tint generation;\n\tint core;\n\tstruct knc_die *die;\n\tstruct {\n\t\tint slot;\n\t\tstruct work *work;\n\t} workslot[WORKS_PER_CORE]; \t/* active, next */\n\tint transfer_stamp;\n\tstruct knc_report report;\n\tstruct {\n\t\tint slot;\n\t\tuint32_t nonce;\n\t} last_nonce;\n\tuint32_t last_nonce_verified;\n\tuint32_t works;\n\tuint32_t shares;\n\tuint32_t errors;\n\tuint32_t completed;\n\tint last_slot;\n\tuint32_t errors_now;\n\tstruct timeval disabled_until;\n\tstruct timeval hold_work_until;\n\tstruct timeval timeout;\n\tbool inuse;\n};\n\nstruct knc_state;\n\nstruct knc_die {\n\tint channel;\n\tint die;\n\tint version;\n\tint cores;\n\tstruct cgpu_info *proc;\n\tstruct knc_state *knc;\n\tstruct knc_core_state *core;\n};\n\n#define MAX_SPI_SIZE\t\t(4096)\n#define MAX_SPI_RESPONSES\t(MAX_SPI_SIZE / (2 + 4 + 1 + 1 + 1 + 4))\n#define MAX_SPI_MESSAGE\t\t(128)\n#define KNC_SPI_BUFFERS\t\t(3)\n\nstruct knc_state {\n\tvoid *ctx;\n\tint generation;    /* work/block generation, incremented on each flush invalidating older works */\n\tint dies;\n\tstruct knc_die die[KNC_MAX_ASICS * KNC_MAX_DIES_PER_ASIC];\n\tint cores;\n\tint scan_adjust;\n\tint startup;\n\t/* Statistics */\n\tuint64_t shares;\t\t/* diff1 shares reported by hardware */\n\tuint64_t works;\t\t\t/* Work units submitted */\n\tuint64_t completed;\t\t/* Work units completed */\n\tuint64_t errors;\t\t/* Hardware & communication errors */\n\tstruct timeval next_error_interval;\n\t/* End of statistics */\n\t/* SPI communications thread */\n\tpthread_mutex_t spi_qlock;\t/* SPI queue status lock */\n\tstruct thr_info spi_thr;\t/* SPI I/O thread */\n\tpthread_cond_t spi_qcond;\t/* SPI queue change wakeup */\n\tstruct knc_spi_buffer {\n\t\tenum {\n\t\t\tKNC_SPI_IDLE=0,\n\t\t\tKNC_SPI_PENDING,\n\t\t\tKNC_SPI_DONE\n\t\t} state;\n\t\tint size;\n\t\tuint8_t txbuf[MAX_SPI_SIZE];\n\t\tuint8_t rxbuf[MAX_SPI_SIZE];\n\t\tint responses;\n\t\tstruct knc_spi_response {\n\t\t\tint request_length;\n\t\t\tint response_length;\n\t\t\tenum {\n\t\t\t\tKNC_UNKNOWN = 0,\n\t\t\t\tKNC_NO_RESPONSE,\n\t\t\t\tKNC_SETWORK,\n\t\t\t\tKNC_REPORT,\n\t\t\t\tKNC_INFO\n\t\t\t} type;\n\t\t\tstruct knc_core_state *core;\n\t\t\tuint32_t data;\n\t\t\tint offset;\n\t\t} response_info[MAX_SPI_RESPONSES];\n\t} spi_buffer[KNC_SPI_BUFFERS];\n\tint send_buffer;\n\tint read_buffer;\n\tint send_buffer_count;\n\tint read_buffer_count;\n\t/* end SPI thread */\n\n\t/* lock to protect resources between different threads */\n\tpthread_mutex_t state_lock;\n\n\tstruct knc_core_state core[KNC_MAX_ASICS * KNC_MAX_DIES_PER_ASIC * KNC_MAX_CORES_PER_DIE];\n};\n\nint opt_knc_device_bus = -1;\nchar *knc_log_file = NULL;\n\nstatic void *knc_spi(void *thr_data)\n{\n\tstruct cgpu_info *cgpu = thr_data;\n\tstruct knc_state *knc = cgpu->device_data;\n\tint buffer = 0;\n\t\n\tpthread_mutex_lock(&knc->spi_qlock);\n\twhile (!cgpu->shutdown) {\n\t\tint this_buffer = buffer;\n\t\twhile (knc->spi_buffer[buffer].state != KNC_SPI_PENDING && !cgpu->shutdown)\n\t\t\tpthread_cond_wait(&knc->spi_qcond, &knc->spi_qlock);\n\t\tpthread_mutex_unlock(&knc->spi_qlock);\n\t\tif (cgpu->shutdown)\n\t\t\treturn NULL;\n\n\t\tknc_trnsp_transfer(knc->ctx, knc->spi_buffer[buffer].txbuf, knc->spi_buffer[buffer].rxbuf, knc->spi_buffer[buffer].size);\n\n\t\tbuffer += 1;\n\t\tif (buffer >= KNC_SPI_BUFFERS)\n\t\t\tbuffer = 0;\n\n\t\tpthread_mutex_lock(&knc->spi_qlock);\n\t\tknc->spi_buffer[this_buffer].state = KNC_SPI_DONE;\n\t\tpthread_cond_signal(&knc->spi_qcond);\n\t}\n\tpthread_mutex_unlock(&knc->spi_qlock);\n\treturn NULL;\n}\n\nstatic void knc_process_responses(struct thr_info *thr);\n\nstatic void knc_flush(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct knc_state *knc = cgpu->device_data;\n\tstruct knc_spi_buffer *buffer = &knc->spi_buffer[knc->send_buffer];\n\tif (buffer->state == KNC_SPI_IDLE && buffer->size > 0) {\n\t\tpthread_mutex_lock(&knc->spi_qlock);\n\t\tbuffer->state = KNC_SPI_PENDING;\n\t\tpthread_cond_signal(&knc->spi_qcond);\n\t\tknc->send_buffer += 1;\n\t\tknc->send_buffer_count += 1;\n\t\tif (knc->send_buffer >= KNC_SPI_BUFFERS)\n\t\t\tknc->send_buffer = 0;\n\t\tbuffer = &knc->spi_buffer[knc->send_buffer];\n\t\t/* Block for SPI to finish a transfer if all buffers are busy */\n\t\twhile (buffer->state == KNC_SPI_PENDING) {\n\t\t\tapplog(LOG_DEBUG, \"KnC: SPI buffer full (%d), waiting for SPI thread\", buffer->responses);\n\t\t\tpthread_cond_wait(&knc->spi_qcond, &knc->spi_qlock);\n\t\t}\n\t\tpthread_mutex_unlock(&knc->spi_qlock);\n\t}\n        knc_process_responses(thr);\n}\n\nstatic void knc_transfer(struct thr_info *thr, struct knc_core_state *core, int request_length, uint8_t *request, int response_length, int response_type, uint32_t data)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct knc_state *knc = cgpu->device_data;\n\tstruct knc_spi_buffer *buffer = &knc->spi_buffer[knc->send_buffer];\n\t/* FPGA control, request header, request body/response, CRC(4), ACK(1), EXTRA(3) */\n\tint msglen = 2 + max(request_length, 4 + response_length) + 4 + 1 + 3;\n\tif (buffer->size + msglen > MAX_SPI_SIZE || buffer->responses >= MAX_SPI_RESPONSES) {\n\t\tapplog(LOG_INFO, \"KnC: SPI buffer sent, %d messages %d bytes\", buffer->responses, buffer->size);\n\t\tknc_flush(thr);\n\t\tbuffer = &knc->spi_buffer[knc->send_buffer];\n\t}\n\tstruct knc_spi_response *response_info = &buffer->response_info[buffer->responses];\n\tbuffer->responses++;\n\tresponse_info->offset = buffer->size;\n\tresponse_info->type = response_type;\n\tresponse_info->request_length = request_length;\n\tresponse_info->response_length = response_length;\n\tresponse_info->core = core;\n\tresponse_info->data = data;\n\tbuffer->size = knc_prepare_transfer(buffer->txbuf, buffer->size, MAX_SPI_SIZE, core->die->channel, request_length, request, response_length);\n}\n\nstatic int knc_transfer_stamp(struct knc_state *knc)\n{\n\treturn knc->send_buffer_count;\n}\n\nstatic int knc_transfer_completed(struct knc_state *knc, int stamp)\n{\n\t/* signed delta math, counter wrap OK */\n\treturn (int)(knc->read_buffer_count - stamp) >= 1;\n}\n\nstatic struct cgpu_info * all_cgpus[KNC_MAX_ASICS][KNC_MAX_DIES_PER_ASIC] = {{NULL}};\n\n/* Note: content of knc might be not initialized yet */\nstatic bool prealloc_all_cgpus(struct knc_state *knc)\n{\n\tint channel, die;\n\tstruct cgpu_info *cgpu, *prev_cgpu;\n\n\tprev_cgpu = NULL;\n\tfor (channel = 0; channel < KNC_MAX_ASICS; ++channel) {\n\t\tcgpu = all_cgpus[channel][0];\n\t\tif (NULL != cgpu)\n\t\t\tcontinue;\n\t\tcgpu = malloc(sizeof(*cgpu));\n\t\tif (NULL == cgpu)\n\t\t\treturn false;\n\t\t*cgpu = (struct cgpu_info){\n\t\t\t.drv = &kncasic_drv,\n\t\t\t.name = \"KnCminer\",\n\t\t\t.procs = KNC_MAX_DIES_PER_ASIC,\n\t\t\t.threads = prev_cgpu ? 0 : 1,\n\t\t\t.device_data = knc,\n\t\t\t};\n\t\tif (!add_cgpu_slave(cgpu, prev_cgpu)) {\n\t\t\tfree(cgpu);\n\t\t\treturn false;\n\t\t}\n\t\tprev_cgpu = cgpu;\n\t\tdie = 0;\n\t\tfor_each_managed_proc(proc, cgpu) {\n\t\t\tproc->deven = DEV_DISABLED;\n\t\t\tall_cgpus[channel][die++] = proc;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic struct cgpu_info * get_cgpu(int channel, int die)\n{\n\tif ((channel < 0) || (channel >= KNC_MAX_ASICS) || (die < 0) || (die >= KNC_MAX_DIES_PER_ASIC))\n\t\treturn NULL;\n\treturn all_cgpus[channel][die];\n}\n\nint knc_change_die_state(void* device_data, int asic_id, int die_id, bool enable)\n{\n\tint ret = 0;\n\tstruct knc_state *knc = device_data;\n\tstruct knc_die_info die_info = {};\n\tint die, next_die, core;\n\n\tapplog(LOG_NOTICE, \"KnC: %s die, ASIC id=%d, DIE id=%d\", enable ? \"enable\" : \"disable\", asic_id, die_id);\n\tmutex_lock(&knc->state_lock);\n\n\tif (asic_id < 0 || asic_id >= KNC_MAX_ASICS || die_id < 0 || die_id >= KNC_MAX_DIES_PER_ASIC) {\n\t\tret = EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tstruct cgpu_info *proc = get_cgpu(asic_id, die_id);\n\n\tfor (die = 0; die < knc->dies; ++die) {\n\t\tif (knc->die[die].channel != asic_id || knc->die[die].die != die_id)\n\t\t\tcontinue;\n\n\t\tif (!enable) {\n\t\t\tint slot, buffer, resp;\n\t\t\tint deleted_cores = knc->die[die].cores;\n\t\t\tknc->cores -= deleted_cores;\n\t\t\t--knc->dies;\n\n\t\t\t/* cgpu[0][0] must be always enabled */\n\t\t\tif ((asic_id != 0) || (die_id != 0))\n\t\t\t\tproc->deven = DEV_DISABLED;\n\n\t\t\tstruct knc_core_state *pcore_to = knc->die[die].core;\n\t\t\tstruct knc_core_state *pcore_from = pcore_to + knc->die[die].cores;\n\t\t\tstruct knc_core_state *pcore;\n\n\t\t\tfor (pcore = pcore_to; pcore < pcore_from; ++pcore) {\n\t\t\t\tfor (slot = 0; slot < WORKS_PER_CORE; ++slot) {\n\t\t\t\t\tif (pcore->workslot[slot].work)\n\t\t\t\t\t\tKNC_FREE_WORK(pcore->workslot[slot].work);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint core_move_count = &(knc->core[knc->cores]) - pcore_to;\n\t\t\tassert(core_move_count >= 0);\n\t\t\tmemmove(pcore_to, pcore_from, core_move_count * sizeof(struct knc_core_state));\n\n\t\t\tstruct knc_die *pdie_to = &(knc->die[die]);\n\t\t\tstruct knc_die *pdie_from = pdie_to + 1;\n\t\t\tint die_move_count = knc->dies - die;\n\t\t\tassert(die_move_count >= 0);\n\t\t\tmemmove(pdie_to, pdie_from, die_move_count * sizeof(struct knc_die));\n\n\t\t\t/* Now fix pointers */\n\t\t\tfor (next_die = 0; next_die < knc->dies; ++next_die) {\n\t\t\t\tassert(knc->die[next_die].core != pcore_to);\n\t\t\t\tif (knc->die[next_die].core > pcore_to)\n\t\t\t\t\tknc->die[next_die].core -= deleted_cores;\n\t\t\t}\n\t\t\tfor (core = 0; core < knc->cores; ++core) {\n\t\t\t\tassert(knc->core[core].die != pdie_to);\n\t\t\t\tif (knc->core[core].die > pdie_to)\n\t\t\t\t\t--(knc->core[core].die);\n\t\t\t}\n\t\t\tfor (buffer = 0; buffer < KNC_SPI_BUFFERS; ++buffer) {\n\t\t\t\tfor (resp = 0; resp < MAX_SPI_RESPONSES; ++resp) {\n\t\t\t\t\tif (knc->spi_buffer[buffer].response_info[resp].core < pcore_to)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (knc->spi_buffer[buffer].response_info[resp].core < pcore_from) {\n\t\t\t\t\t\tknc->spi_buffer[buffer].response_info[resp].core = NULL;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tknc->spi_buffer[buffer].response_info[resp].core -= deleted_cores;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* die was found */\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t/* die was not found */\n\tif (enable) {\n\t\t/* Send GETINFO to a die to detect if it is usable */\n\t\tif (knc_trnsp_asic_detect(knc->ctx, asic_id)) {\n\t\t\tif (knc_detect_die(knc->ctx, asic_id, die_id, &die_info) != 0) {\n\t\t\t\tret = ENODEV;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmemset(&(knc->core[knc->cores]), 0, die_info.cores * sizeof(struct knc_core_state));\n\t\tint next_die = knc->dies;\n\n\t\tknc->die[next_die].channel = asic_id;\n\t\tknc->die[next_die].die = die_id;\n\t\tknc->die[next_die].version = die_info.version;\n\t\tknc->die[next_die].cores = die_info.cores;\n\t\tknc->die[next_die].core = &(knc->core[knc->cores]);\n\t\tknc->die[next_die].knc = knc;\n\t\tknc->die[next_die].proc = proc;\n\n\t\tfor (core = 0; core < knc->die[next_die].cores; ++core) {\n\t\t\tknc->die[next_die].core[core].die = &knc->die[next_die];\n\t\t\tknc->die[next_die].core[core].core = core;\n\t\t}\n\n\t\t++knc->dies;\n\t\tknc->cores += die_info.cores;\n\n\t\tproc_enable(proc);\n\t}\n\nout_unlock:\n\tmutex_unlock(&knc->state_lock);\n\treturn ret;\n}\n\nstatic bool knc_detect_one(void *ctx)\n{\n\t/* Scan device for ASICs */\n\tint channel, die, cores = 0, core;\n\tstruct knc_state *knc;\n\tstruct knc_die_info die_info[KNC_MAX_ASICS][KNC_MAX_DIES_PER_ASIC];\n\n\tmemset(die_info, 0, sizeof(die_info));\n\n\t/* Send GETINFO to each die to detect if it is usable */\n\tfor (channel = 0; channel < KNC_MAX_ASICS; channel++) {\n\t\tif (!knc_trnsp_asic_detect(ctx, channel))\n\t\t\tcontinue;\n\t\tfor (die = 0; die < KNC_MAX_DIES_PER_ASIC; die++) {\n\t\t    if (knc_detect_die(ctx, channel, die, &die_info[channel][die]) == 0)\n\t\t\tcores += die_info[channel][die].cores;\n\t\t}\n\t}\n\n\tif (!cores) {\n\t\tapplog(LOG_ERR, \"no KnCminer cores found\");\n\t\treturn false;\n\t}\n\n\tapplog(LOG_NOTICE, \"Found a KnC miner with %d cores\", cores);\n\n\tknc = calloc(1, sizeof(*knc));\n\tif (!knc) {\nerr_nomem:\n\t\tapplog(LOG_ERR, \"KnC miner detected, but failed to allocate memory\");\n\t\treturn false;\n\t}\n\tif (!prealloc_all_cgpus(knc)) {\n\t\tfree(knc);\n\t\tgoto err_nomem;\n\t}\n\n\tknc->ctx = ctx;\n\tknc->generation = 1;\n\n\t/* Index all cores */\n\tstruct cgpu_info *first_cgpu = NULL;\n\tint dies = 0;\n\tcores = 0;\n\tstruct knc_core_state *pcore = knc->core;\n\tfor (channel = 0; channel < KNC_MAX_ASICS; channel++) {\n\t\tfor (die = 0; die < KNC_MAX_DIES_PER_ASIC; die++) {\n\t\t\tif (die_info[channel][die].cores) {\n\t\t\t\tknc->die[dies].channel = channel;\n\t\t\t\tknc->die[dies].die = die;\n\t\t\t\tknc->die[dies].version = die_info[channel][die].version;\n\t\t\t\tknc->die[dies].cores = die_info[channel][die].cores;\n\t\t\t\tknc->die[dies].core = pcore;\n\t\t\t\tknc->die[dies].knc = knc;\n\t\t\t\tknc->die[dies].proc = get_cgpu(channel, die);\n\t\t\t\tknc->die[dies].proc->deven = DEV_ENABLED;\n\t\t\t\tif (NULL == first_cgpu)\n\t\t\t\t\tfirst_cgpu = knc->die[dies].proc;\n\t\t\t\tfor (core = 0; core < knc->die[dies].cores; core++) {\n\t\t\t\t\tknc->die[dies].core[core].die = &knc->die[dies];\n\t\t\t\t\tknc->die[dies].core[core].core = core;\n\t\t\t\t}\n\t\t\t\tcores += knc->die[dies].cores;\n\t\t\t\tpcore += knc->die[dies].cores;\n\t\t\t\tdies++;\n\t\t\t}\n\t\t}\n\t}\n\n\tknc->dies = dies;\n\tknc->cores = cores;\n\tknc->startup = 2;\n\n\tpthread_mutex_init(&knc->spi_qlock, NULL);\n\tpthread_cond_init(&knc->spi_qcond, NULL);\n\tpthread_mutex_init(&knc->state_lock, NULL);\n\n\tif (thr_info_create(&knc->spi_thr, NULL, knc_spi, first_cgpu)) {\n\t\tapplog(LOG_ERR, \"%s: SPI thread create failed\", first_cgpu->dev_repr);\n\t\tfree(knc);\n\t\t/* TODO: free all cgpus. We can not do it at the moment as there is no good\n\t\t * way to free all cgpu-related resources. */\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* Probe devices and register with add_cgpu */\nstatic\nbool kncasic_detect_one(const char * const devpath)\n{\n\tvoid *ctx = knc_trnsp_new(devpath);\n\n\tif (ctx != NULL) {\n\t\tif (!knc_detect_one(ctx))\n\t\t\tknc_trnsp_free(ctx);\n\t\telse\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic\nint kncasic_detect_auto(void)\n{\n\treturn kncasic_detect_one(NULL) ? 1 : 0;\n}\n\nstatic\nvoid kncasic_detect(void)\n{\n\tgeneric_detect(&kncasic_drv, kncasic_detect_one, kncasic_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\nstatic\nbool knc_init(struct thr_info * const thr)\n{\n\tint channel, die;\n\tstruct cgpu_info *cgpu = thr->cgpu, *proc;\n\tstruct knc_state *knc = cgpu->device_data;\n\n\t/* Set initial enable/disable state */\n\tbool die_detected[KNC_MAX_ASICS][KNC_MAX_DIES_PER_ASIC];\n\tmemset(die_detected, 0, sizeof(die_detected));\n\tfor (die = 0; die < knc->dies; ++die) {\n\t\tif (0 < knc->die[die].cores) {\n\t\t\tdie_detected[knc->die[die].channel][knc->die[die].die] = true;\n\t\t}\n\t}\n\t/* cgpu[0][0] must be always enabled */\n\tdie_detected[0][0] = true;\n\tfor (channel = 0; channel < KNC_MAX_ASICS; ++channel) {\n\t\tfor (die = 0; die < KNC_MAX_DIES_PER_ASIC; ++die) {\n\t\t\tproc = get_cgpu(channel, die);\n\t\t\tif (NULL != proc) {\n\t\t\t\tproc->deven = die_detected[channel][die] ? DEV_ENABLED : DEV_DISABLED;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/* Core helper functions */\nstatic int knc_core_hold_work(struct knc_core_state *core)\n{\n\treturn timercmp(&core->hold_work_until, &now, >);\n}\n\nstatic int knc_core_has_work(struct knc_core_state *core)\n{\n\tint i;\n\tfor (i = 0; i < WORKS_PER_CORE; i++) {\n\t\tif (core->workslot[i].slot > 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int knc_core_need_work(struct knc_core_state *core)\n{\n\treturn !knc_core_hold_work(core) && !core->workslot[1].work && !core->workslot[2].work;\n}\n\nstatic int knc_core_disabled(struct knc_core_state *core)\n{\n\treturn timercmp(&core->disabled_until, &now, >);\n}\n\nstatic int _knc_core_next_slot(struct knc_core_state *core)\n{\n\t/* Avoid slot #0 and #15. #0 is \"no work assigned\" and #15 is seen on bad cores */\n\tint slot = core->last_slot + 1;\n\tif (slot >= 15)\n\t\tslot = 1;\n\tcore->last_slot = slot;\n\treturn slot;\n}\n\nstatic bool knc_core_slot_busy(struct knc_core_state *core, int slot)\n{\n\tif (slot == core->report.active_slot)\n\t\treturn true;\n\tif (slot == core->report.next_slot)\n\t\treturn true;\n\tint i;\n\tfor (i = 0; i < WORKS_PER_CORE; i++) {\n\t\tif (slot == core->workslot[i].slot)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int knc_core_next_slot(struct knc_core_state *core)\n{\n\tint slot;\n\tdo slot = _knc_core_next_slot(core);\n\twhile (knc_core_slot_busy(core, slot));\n\treturn slot;\n}\n\nstatic void knc_core_failure(struct knc_core_state *core)\n{\n\tcore->errors++;\n\tcore->errors_now++;\n\tcore->die->knc->errors++;\n\tif (knc_core_disabled(core))\n\t\treturn;\n\tif (core->errors_now > CORE_ERROR_LIMIT) {\n\t\tstruct cgpu_info * const proc = core->die->proc;\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\"[%d] disabled for %ld seconds due to repeated hardware errors\",\n\t\t\tproc->proc_repr, core->core, (long)core_disable_interval.tv_sec);\n\t\ttimeradd(&now, &core_disable_interval, &core->disabled_until);\n\t}\n}\n\nstatic\nvoid knc_core_handle_nonce(struct thr_info *thr, struct knc_core_state *core, int slot, uint32_t nonce, bool comm_errors)\n{\n\tint i;\n\tif (!slot)\n\t\treturn;\n\tcore->last_nonce.slot = slot;\n\tcore->last_nonce.nonce = nonce;\n\tif (core->die->knc->startup)\n\t\treturn;\n\tfor (i = 0; i < WORKS_PER_CORE; i++) {\n\t\tif (slot == core->workslot[i].slot && core->workslot[i].work) {\n\t\t\tstruct cgpu_info * const proc = core->die->proc;\n\t\t\tstruct thr_info * const corethr = proc->thr[0];\n\t\t\tchar *comm_err_str = comm_errors ? \" (comm error)\" : \"\";\n\n\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] found nonce %08x%s\", proc->proc_repr, core->core, nonce, comm_err_str);\n\t\t\tif (submit_nonce(corethr, core->workslot[i].work, nonce)) {\n\t\t\t\tif (nonce != core->last_nonce_verified) {\n\t\t\t\t\t/* Good share */\n\t\t\t\t\tcore->shares++;\n\t\t\t\t\tcore->die->knc->shares++;\n\t\t\t\t\thashes_done2(corethr, 0x100000000, NULL);\n\t\t\t\t\tcore->last_nonce_verified = nonce;\n\t\t\t\t} else {\n\t\t\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] duplicate nonce %08x%s\", proc->proc_repr, core->core, nonce, comm_err_str);\n\t\t\t\t}\n\t\t\t\t/* This core is useful. Ignore any errors */\n\t\t\t\tcore->errors_now = 0;\n\t\t\t} else {\n\t\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] hwerror nonce %08x%s\", proc->proc_repr, core->core, nonce, comm_err_str);\n\t\t\t\t/* Bad share */\n\t\t\t\tknc_core_failure(core);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int knc_core_process_report(struct thr_info *thr, struct knc_core_state *core, uint8_t *response, bool comm_errors)\n{\n\tstruct cgpu_info * const proc = core->die->proc;\n\tstruct knc_report *report = &core->report;\n\tknc_decode_report(response, report, core->die->version);\n\tbool had_event = false;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\"[%d]: Process report %d %d(%d) / %d %d %d\", proc->proc_repr, core->core, report->active_slot, report->next_slot, report->next_state, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\tint n;\n\tfor (n = 0; n < KNC_NONCES_PER_REPORT; n++) {\n\t\tif (report->nonce[n].slot < 0)\n\t\t\tbreak;\n\t\tif (core->last_nonce.slot == report->nonce[n].slot && core->last_nonce.nonce == report->nonce[n].nonce)\n\t\t\tbreak;\n\t}\n\twhile(n-- > 0) {\n\t\tknc_core_handle_nonce(thr, core, report->nonce[n].slot, report->nonce[n].nonce, comm_errors);\n\t}\n\n\tif (!comm_errors) {\n\t\tif (report->active_slot && core->workslot[0].slot != report->active_slot) {\n\t\t\thad_event = true;\n\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: New work %d %d / %d %d %d\", proc->proc_repr, core->core, report->active_slot, report->next_slot, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\t\t\t/* Core switched to next work */\n\t\t\tif (core->workslot[0].work) {\n\t\t\t\tcore->die->knc->completed++;\n\t\t\t\tcore->completed++;\n\t\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Work completed!\", proc->proc_repr, core->core);\n\t\t\t\tKNC_FREE_WORK(core->workslot[0].work);\n\t\t\t}\n\t\t\tcore->workslot[0] = core->workslot[1];\n\t\t\tcore->workslot[1].work = NULL;\n\t\t\tcore->workslot[1].slot = -1;\n\n\t\t\t/* or did it switch directly to pending work? */\n\t\t\tif (report->active_slot == core->workslot[2].slot) {\n\t\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: New work %d %d %d %d (pending)\", proc->proc_repr, core->core, report->active_slot, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\t\t\t\tif (core->workslot[0].work)\n\t\t\t\t\tKNC_FREE_WORK(core->workslot[0].work);\n\t\t\t\tcore->workslot[0] = core->workslot[2];\n\t\t\t\tcore->workslot[2].work = NULL;\n\t\t\t\tcore->workslot[2].slot = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (report->next_state && core->workslot[2].slot > 0 && (core->workslot[2].slot == report->next_slot  || report->next_slot == -1)) {\n\t\t\thad_event = true;\n\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Accepted work %d %d %d %d (pending)\", proc->proc_repr, core->core, report->active_slot, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\t\t\t/* core accepted next work */\n\t\t\tif (core->workslot[1].work)\n\t\t\t\tKNC_FREE_WORK(core->workslot[1].work);\n\t\t\tcore->workslot[1] = core->workslot[2];\n\t\t\tcore->workslot[2].work = NULL;\n\t\t\tcore->workslot[2].slot = -1;\n\t\t}\n\t}\n\n\tif (core->workslot[2].work && knc_transfer_completed(core->die->knc, core->transfer_stamp)) {\n\t\thad_event = true;\n\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Setwork failed?\", proc->proc_repr, core->core);\n\t\tKNC_FREE_WORK(core->workslot[2].work);\n\t\tcore->workslot[2].slot = -1;\n\t}\n\n\tif (had_event)\n\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Exit report %d %d / %d %d %d\", proc->proc_repr, core->core, report->active_slot, report->next_slot, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\n\treturn 0;\n}\n\nstatic void knc_process_responses(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct knc_state *knc = cgpu->device_data;\n\tstruct knc_spi_buffer *buffer = &knc->spi_buffer[knc->read_buffer];\n\twhile (buffer->state == KNC_SPI_DONE) {\n\t\tint i;\n\t\tfor (i = 0; i < buffer->responses; i++) {\n\t\t\tstruct knc_spi_response *response_info = &buffer->response_info[i];\n\t\t\tuint8_t *rxbuf = &buffer->rxbuf[response_info->offset];\n\t\t\tstruct knc_core_state *core = response_info->core;\n\t\t\tif (NULL == core) /* core was deleted, e.g. by API call */\n\t\t\t\tcontinue;\n\t\t\tstruct cgpu_info * const proc = core->die->proc;\n\t\t\tint status = knc_decode_response(rxbuf, response_info->request_length, &rxbuf, response_info->response_length);\n\t\t\t/* Invert KNC_ACCEPTED to simplify logics below */\n\t\t\tif (response_info->type == KNC_SETWORK && !KNC_IS_ERROR(status))\n\t\t\t\tstatus ^= KNC_ACCEPTED;\n\t\t\tbool comm_errors = false;\n\t\t\tif (core->die->version != KNC_VERSION_JUPITER && status != 0) {\n\t\t\t\tif (response_info->type == KNC_SETWORK && status == KNC_ACCEPTED) {\n\t\t\t\t\t/* Core refused our work vector. Likely out of sync. Reset it */\n\t\t\t\t\tcore->inuse = false;\n\t\t\t\t} else {\n\t\t\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Communication error (%x / %d)\", proc->proc_repr, core->core, status, i);\n\t\t\t\t\tcomm_errors = true;\n\t\t\t\t}\n\t\t\t\tknc_core_failure(core);\n\t\t\t}\n\t\t\tswitch(response_info->type) {\n\t\t\tcase KNC_REPORT:\n\t\t\tcase KNC_SETWORK:\n\t\t\t\t/* Should we care about failed SETWORK explicit? Or simply handle it by next state not loaded indication in reports?  */\n\t\t\t\tknc_core_process_report(thr, core, rxbuf, comm_errors);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbuffer->state = KNC_SPI_IDLE;\n\t\tbuffer->responses = 0;\n\t\tbuffer->size = 0;\n\t\tknc->read_buffer += 1;\n\t\tknc->read_buffer_count += 1;\n\t\tif (knc->read_buffer >= KNC_SPI_BUFFERS)\n\t\t\tknc->read_buffer = 0;\n\t\tbuffer = &knc->spi_buffer[knc->read_buffer];\n\t}\n}\n\nstatic int knc_core_send_work(struct thr_info *thr, struct knc_core_state *core, struct work *work, bool clean)\n{\n\tstruct knc_state *knc = core->die->knc;\n\tstruct cgpu_info * const proc = core->die->proc;\n\tint request_length = 4 + 1 + 6*4 + 3*4 + 8*4;\n\tuint8_t request[request_length];\n\tint response_length = 1 + 1 + (1 + 4) * 5;\n\n\tint slot = knc_core_next_slot(core);\n\tif (slot < 0)\n\t\tgoto error;\n\n\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] setwork%s  = %d, %d %d / %d %d %d\", proc->proc_repr, core->core, clean ? \" CLEAN\" : \"\", slot, core->report.active_slot, core->report.next_slot, core->workslot[0].slot, core->workslot[1].slot, core->workslot[2].slot);\n\tif (!clean && !knc_core_need_work(core))\n\t\tgoto error;\n\n\tswitch(core->die->version) {\n\tcase KNC_VERSION_JUPITER:\n\t\tif (clean) {\n\t\t\t/* Double halt to get rid of any previous queued work */\n\t\t\trequest_length = knc_prepare_jupiter_halt(request, core->die->die, core->core);\n\t\t\tknc_transfer(thr, core, request_length, request, 0, KNC_NO_RESPONSE, 0);\n\t\t\tknc_transfer(thr, core, request_length, request, 0, KNC_NO_RESPONSE, 0);\n\t\t}\n\t\trequest_length = knc_prepare_jupiter_setwork(request, core->die->die, core->core, slot, work);\n\t\tknc_transfer(thr, core, request_length, request, 0, KNC_NO_RESPONSE, 0);\n\t\tbreak;\n\tcase KNC_VERSION_NEPTUNE:\n\t\trequest_length = knc_prepare_neptune_setwork(request, core->die->die, core->core, slot, work, clean);\n\t\tknc_transfer(thr, core, request_length, request, response_length, KNC_SETWORK, slot);\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tif (core->workslot[2].work)\n\t\tKNC_FREE_WORK(core->workslot[2].work);\n\tcore->workslot[2].work = work;\n\tcore->workslot[2].slot = slot;\n\tcore->works++;\n\tcore->die->knc->works++;\n\tcore->transfer_stamp = knc_transfer_stamp(knc);\n\tcore->inuse = true;\n\n\ttimeradd(&now, &core_submit_interval, &core->hold_work_until);\n\ttimeradd(&now, &core_timeout_interval, &core->timeout);\n\n\treturn 0;\n\nerror:\n\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Failed to setwork (%d)\", proc->proc_repr, core->core, core->errors_now);\n\tknc_core_failure(core);\n\tKNC_FREE_WORK(work);\n\treturn -1;\n}\n\nstatic int knc_core_request_report(struct thr_info *thr, struct knc_core_state *core)\n{\n\tstruct cgpu_info * const proc = core->die->proc;\n\tint request_length = 4;\n\tuint8_t request[request_length];\n\tint response_length = 1 + 1 + (1 + 4) * 5;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\"[%d]: Request report\", proc->proc_repr, core->core);\n\n\trequest_length = knc_prepare_report(request, core->die->die, core->core);\n\n\tswitch(core->die->version) {\n\tcase KNC_VERSION_JUPITER:\n\t\tresponse_length = 1 + 1 + (1 + 4);\n\t\tknc_transfer(thr, core, request_length, request, response_length, KNC_REPORT, 0);\n\t\treturn 0;\n\tcase KNC_VERSION_NEPTUNE:\n\t\tknc_transfer(thr, core, request_length, request, response_length, KNC_REPORT, 0);\n\t\treturn 0;\n\t}\n\n\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d]: Failed to scan work report\", proc->proc_repr, core->core);\n\tknc_core_failure(core);\n\treturn -1;\n}\n\n/* return value is number of nonces that have been checked since\n * previous call\n */\nstatic int64_t knc_scanwork(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct knc_state *knc = cgpu->device_data;\n\n\tapplog(LOG_DEBUG, \"KnC running scanwork\");\n\tmutex_lock(&knc->state_lock);\n\n\tgettimeofday(&now, NULL);\n\n\tknc_trnsp_periodic_check(knc->ctx);\n\n\tint i;\n\n\tknc_process_responses(thr);\n\n\tif (timercmp(&knc->next_error_interval, &now, >)) {\n\t\t/* Reset hw error limiter every check interval */\n\t\ttimeradd(&now, &core_check_interval, &knc->next_error_interval);\n\t\tfor (i = 0; i < knc->cores; i++) {\n\t\t\tstruct knc_core_state *core = &knc->core[i];\n\t\t\tcore->errors_now = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < knc->cores; i++) {\n\t\tstruct knc_core_state *core = &knc->core[i];\n\t\tstruct cgpu_info * const proc = core->die->proc;\n\t\tbool clean = !core->inuse;\n\t\tif (knc_core_disabled(core))\n\t\t\tcontinue;\n\t\tif (core->generation != knc->generation) {\n\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] flush gen=%d/%d\", proc->proc_repr, core->core, core->generation, knc->generation);\n\t\t\t/* clean set state, forget everything */\n\t\t\tint slot;\n\t\t\tfor (slot = 0; slot < WORKS_PER_CORE; slot ++) {\n\t\t\t\tif (core->workslot[slot].work)\n\t\t\t\t\tKNC_FREE_WORK(core->workslot[slot].work);\n\t\t\t\tcore->workslot[slot].slot = -1;\n\t\t\t}\n\t\t\tcore->hold_work_until = now;\n\t\t\tcore->generation = knc->generation;\n\t\t} else if (timercmp(&core->timeout, &now, <=) && (core->workslot[0].slot > 0 || core->workslot[1].slot > 0 || core->workslot[2].slot > 0)) {\n\t\t\tapplog(LOG_INFO, \"%\"PRIpreprv\"[%d] timeout gen=%d/%d\", proc->proc_repr, core->core, core->generation, knc->generation);\n\t\t\tclean = true;\n\t\t}\n\t\tif (!knc_core_has_work(core))\n\t\t\tclean = true;\n\t\tif (core->workslot[0].slot < 0 && core->workslot[1].slot < 0 && core->workslot[2].slot < 0)\n\t\t\tclean = true;\n\t\tif (i % SCAN_ADJUST_RANGE == knc->scan_adjust)\n\t\t\tclean = true;\n\t\tif ((knc_core_need_work(core) || clean) && !knc->startup) {\n\t\t\tstruct work *work = get_work(thr);\n\t\t\tknc_core_send_work(thr, core, work, clean);\n\t\t} else {\n\t\t\tknc_core_request_report(thr, core);\n\t\t}\n\t}\n\t/* knc->startup delays initial work submission until we have had chance to query all cores on their current status, to avoid slot number collisions with earlier run */\n\tif (knc->startup)\n\t\tknc->startup--;\n\telse if (knc->scan_adjust < SCAN_ADJUST_RANGE)\n\t\tknc->scan_adjust++;\n\n\tknc_flush(thr);\n\n\tmutex_unlock(&knc->state_lock);\n\treturn 0;\n}\n\nstatic void knc_flush_work(struct cgpu_info *cgpu)\n{\n\tstruct knc_state *knc = cgpu->device_data;\n\n\tapplog(LOG_INFO, \"KnC running flushwork\");\n\n\tmutex_lock(&knc->state_lock);\n\n\tknc->generation++;\n\tknc->scan_adjust=0;\n\tif (!knc->generation)\n\t\tknc->generation++;\n\n\tmutex_unlock(&knc->state_lock);\n}\n\nstatic void knc_zero_stats(struct cgpu_info *cgpu)\n{\n\tint core;\n\tstruct knc_state *knc = cgpu->device_data;\n\n\tmutex_lock(&knc->state_lock);\n\tfor (core = 0; core < knc->cores; core++) {\n\t\tknc->shares = 0;\n\t\tknc->completed = 0;\n\t\tknc->works = 0;\n\t\tknc->errors = 0;\n\t\tknc->core[core].works = 0;\n\t\tknc->core[core].errors = 0;\n\t\tknc->core[core].shares = 0;\n\t\tknc->core[core].completed = 0;\n\t}\n\tmutex_unlock(&knc->state_lock);\n}\n\nstatic struct api_data *knc_api_stats(struct cgpu_info *cgpu)\n{\n\tstruct knc_state *knc = cgpu->device_data;\n\tstruct knc_core_state * const proccore = &knc->core[cgpu->proc_id];\n\tstruct knc_die * const die = proccore->die;\n\tstruct api_data *root = NULL;\n\tint core;\n\tchar label[256];\n\n\tmutex_lock(&knc->state_lock);\n\n\troot = api_add_int(root, \"dies\", &knc->dies, 1);\n\troot = api_add_int(root, \"cores\", &knc->cores, 1);\n\troot = api_add_uint64(root, \"shares\", &knc->shares, 1);\n\troot = api_add_uint64(root, \"works\", &knc->works, 1);\n\troot = api_add_uint64(root, \"completed\", &knc->completed, 1);\n\troot = api_add_uint64(root, \"errors\", &knc->errors, 1);\n\n\t/* Active cores */\n\tint active = knc->cores;\n\tfor (core = 0; core < knc->cores; core++) {\n\t\tif (knc_core_disabled(&knc->core[core]))\n\t\t\tactive -= 1;\n\t}\n\troot = api_add_int(root, \"active\", &active, 1);\n\n\t/* Per ASIC/die data */\n\t{\n#define knc_api_die_string(name, value) do { \\\n\tsnprintf(label, sizeof(label), \"%d.%d.%s\", die->channel, die->die, name); \\\n\troot = api_add_string(root, label, value, 1); \\\n\t} while(0)\n#define knc_api_die_int(name, value) do { \\\n\tsnprintf(label, sizeof(label), \"%d.%d.%s\", die->channel, die->die, name); \\\n\tuint64_t v = value; \\\n\troot = api_add_uint64(root, label, &v, 1); \\\n\t} while(0)\n\n\t\t/* Model */\n\t\t{\n\t\t\tchar *model = \"?\";\n\t\t\tswitch(die->version) {\n\t\t\tcase KNC_VERSION_JUPITER:\n\t\t\t\tmodel = \"Jupiter\";\n\t\t\t\tbreak;\n\t\t\tcase KNC_VERSION_NEPTUNE:\n\t\t\t\tmodel = \"Neptune\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tknc_api_die_string(\"model\", model);\n\t\t\tknc_api_die_int(\"cores\", die->cores);\n\t\t}\n\n\t\t/* Core based stats */\n\t\t{\n\t\t\tuint64_t errors = 0;\n\t\t\tuint64_t shares = 0;\n\t\t\tuint64_t works = 0;\n\t\t\tuint64_t completed = 0;\n\t\t\tchar coremap[die->cores+1];\n\n\t\t\tfor (core = 0; core < die->cores; core++) {\n\t\t\t\tcoremap[core] = knc_core_disabled(&die->core[core]) ? '0' : '1';\n\t\t\t\tworks += die->core[core].works;\n\t\t\t\tshares += die->core[core].shares;\n\t\t\t\terrors += die->core[core].errors;\n\t\t\t\tcompleted += die->core[core].completed;\n\t\t\t}\n\t\t\tcoremap[die->cores] = '\\0';\n\t\t\tknc_api_die_int(\"errors\", errors);\n\t\t\tknc_api_die_int(\"shares\", shares);\n\t\t\tknc_api_die_int(\"works\", works);\n\t\t\tknc_api_die_int(\"completed\", completed);\n\t\t\tknc_api_die_string(\"coremap\", coremap);\n\t\t}\n\t}\n\n\tmutex_unlock(&knc->state_lock);\n\treturn root;\n}\n\nstatic\nvoid hash_driver_work(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct device_drv * const drv = cgpu->drv;\n\t\n\twhile (likely(!cgpu->shutdown))\n\t{\n\t\tdrv->scanwork(thr);\n\t\t\n\t\tif (unlikely(thr->pause || cgpu->deven != DEV_ENABLED))\n\t\t\tmt_disable(thr);\n\n\t\tif (unlikely(thr->work_restart)) {\n\t\t\tthr->work_restart = false;\n\t\t\tflush_queue(cgpu);\n\t\t\tdrv->flush_work(cgpu);\n\t\t}\n\n\t}\n}\n\nstruct device_drv kncasic_drv = {\n\t.dname = \"kncasic\",\n\t.name = \"KNC\",\n\t.drv_detect = kncasic_detect,\n\t.thread_init = knc_init,\n\t.minerloop = hash_driver_work,\n\t.flush_work = knc_flush_work,\n\t.scanwork = knc_scanwork,\n\t.zero_stats = knc_zero_stats,\n\t.get_api_stats = knc_api_stats,\n};\n"
        },
        {
          "name": "driver-littlefury.c",
          "type": "blob",
          "size": 13.24609375,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-spi.h\"\n#include \"lowl-vcom.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n\nenum littlefury_opcode {\n\tLFOP_VERSION = 0,\n\tLFOP_SPI     = 1,\n\tLFOP_REGVOLT = 2,\n\tLFOP_REGINFO = 3,\n\tLFOP_REGPWR  = 4,\n\tLFOP_TEMP    = 5,\n\tLFOP_LED     = 6,\n\tLFOP_ADC     = 7,\n};\n\nBFG_REGISTER_DRIVER(littlefury_drv)\n\nstatic\nssize_t keep_reading(int prio, int fd, void *buf, size_t count)\n{\n\tssize_t r, rv = 0;\n\t\n\twhile (count)\n\t{\n\t\tr = read(fd, buf, count);\n\t\tif (unlikely(r <= 0))\n\t\t{\n\t\t\tapplog(prio, \"Read of fd %d returned %d\", fd, (int)r);\n\t\t\treturn rv ?: r;\n\t\t}\n\t\trv += r;\n\t\tcount -= r;\n\t\tbuf += r;\n\t}\n\t\n\treturn rv;\n}\n\nstatic\nbool bitfury_do_packet(int prio, const char *repr, const int fd, void * const buf, uint16_t * const bufsz, const uint8_t op, const void * const payload, const uint16_t payloadsz)\n{\n\tuint16_t crc;\n\tsize_t sz;\n\tssize_t r;\n\tuint8_t pkt[0x407];\n\tbool b;\n\t\n\t{\n\t\tsz = 2 + 1 + 2 + payloadsz + 2;\n\t\tpkt[0] = 0xab;\n\t\tpkt[1] = 0xcd;\n\t\tpkt[2] = op;\n\t\tpkt[3] = payloadsz >> 8;\n\t\tpkt[4] = payloadsz & 0xff;\n\t\tif (payloadsz)\n\t\t\tmemcpy(&pkt[5], payload, payloadsz);\n\t\tcrc = crc16ffff(&pkt[2], 3 + (size_t)payloadsz);\n\t\tpkt[sz - 2] = crc >> 8;\n\t\tpkt[sz - 1] = crc & 0xff;\n\t\tif (unlikely(opt_dev_protocol))\n\t\t{\n\t\t\tchar hex[(sz * 2) + 1];\n\t\t\tbin2hex(hex, pkt, sz);\n\t\t\tapplog(LOG_DEBUG, \"%s: DEVPROTO: SEND %s\", repr, hex);\n\t\t}\n\t\tr = write(fd, pkt, sz);\n\t\tif (sz != r)\n\t\t{\n\t\t\tapplog(prio, \"%s: Failed to write packet (%d bytes succeeded)\", repr, (int)r);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t{\n\t\tr = keep_reading(prio, fd, pkt, 5);\n\t\tif (5 != r || pkt[0] != 0xab || pkt[1] != 0xcd || pkt[2] != op)\n\t\t{\n\t\t\tchar hex[(r * 2) + 1];\n\t\t\tbin2hex(hex, pkt, r);\n\t\t\tapplog(prio, \"%s: DEVPROTO: RECV %s\", repr, hex);\n\t\t\tapplog(prio, \"%s: Failed to read correct packet header\", repr);\n\t\t\treturn false;\n\t\t}\n\t\tsz = (((unsigned)pkt[3] << 8) | pkt[4]) + 2;\n\t\tr = keep_reading(prio, fd, &pkt[5], sz);\n\t\tif (sz != r)\n\t\t{\n\t\t\tr += 5;\n\t\t\tchar hex[(r * 2) + 1];\n\t\t\tbin2hex(hex, pkt, r);\n\t\t\tapplog(prio, \"%s: DEVPROTO: RECV %s\", repr, hex);\n\t\t\tapplog(prio, \"%s: Failed to read packet payload (len=%d)\", repr, (int)sz);\n\t\t\treturn false;\n\t\t}\n\t\tcrc = (pkt[sz + 3] << 8) | pkt[sz + 4];\n\t\tb = (crc != crc16ffff(&pkt[2], sz + 1));\n\t\tif (unlikely(opt_dev_protocol || b))\n\t\t{\n\t\t\tchar hex[((sz + 5) * 2) + 1];\n\t\t\tbin2hex(hex, pkt, sz + 5);\n\t\t\tapplog(b ? prio : LOG_DEBUG, \"%s: DEVPROTO: RECV %s\", repr, hex);\n\t\t\tif (b)\n\t\t\t{\n\t\t\t\tapplog(prio, \"%s: Packet checksum mismatch\", repr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tsz -= 2;\n\t\tmemcpy(buf, &pkt[5], (*bufsz < sz ? *bufsz : sz));\n\t\t*bufsz = sz;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool littlefury_set_power(const int loglev, const char * const repr, const int fd, const bool power)\n{\n\tconst uint8_t pflg = (power ? '\\1' : '\\0');\n\tuint8_t buf[1] = { pflg };\n\tuint16_t bufsz = 1;\n\treturn bitfury_do_packet(loglev, repr, fd, buf, &bufsz, LFOP_REGPWR, buf, 1) && bufsz && (buf[0] == pflg);\n}\n\nstatic\nbool littlefury_txrx(struct spi_port *port)\n{\n\tconst struct cgpu_info * const cgpu = port->cgpu;\n\tconst void *wrbuf = spi_gettxbuf(port);\n\tvoid *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\tuint16_t rbufsz, xfer;\n\tconst int logprio = port->logprio;\n\tconst char * const repr = port->repr;\n\tconst int fd = cgpu->device->device_fd;\n\t\n\tif (unlikely(fd == -1))\n\t\treturn false;\n\t\n\trbufsz = 1;\n\tif (!bitfury_do_packet(logprio, repr, fd, rdbuf, &rbufsz, LFOP_SPI, NULL, 0))\n\t{\n\t\tlittlefury_set_power(LOG_DEBUG, cgpu->dev_repr, fd, false);\n\t\tserial_close(fd);\n\t\tcgpu->device->device_fd = -1;\n\t\treturn false;\n\t}\n\t\n\twhile (bufsz)\n\t{\n\t\txfer = (bufsz > 1024) ? 1024 : bufsz;\n\t\trbufsz = xfer;\n\t\tif (!bitfury_do_packet(logprio, repr, fd, rdbuf, &rbufsz, LFOP_SPI, wrbuf, xfer))\n\t\t\treturn false;\n\t\tif (rbufsz < xfer)\n\t\t{\n\t\t\tapplog(port->logprio, \"%s: SPI: Got fewer bytes back than sent (%d < %d)\",\n\t\t\t       repr, rbufsz, xfer);\n\t\t\treturn false;\n\t\t}\n\t\tbufsz -= xfer;\n\t\trdbuf += xfer;\n\t\twrbuf += xfer;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool littlefury_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"LittleFury\");\n}\n\nstatic\nint littlefury_chip_count(struct cgpu_info * const info)\n{\n\t/* Do not allocate spi_port on the stack! OS X, at least, has a 512 KB default stack size for secondary threads */\n\tstruct spi_port *spi = malloc(sizeof(*spi));\n\tspi->txrx = littlefury_txrx;\n\tspi->cgpu = info;\n\tspi->repr = littlefury_drv.dname;\n\tspi->logprio = LOG_DEBUG;\n\t\n\tconst int chip_count = libbitfury_detectChips1(spi);\n\t\n\tfree(spi);\n\t\n\treturn chip_count;\n}\n\nstatic\nbool littlefury_detect_one(const char *devpath)\n{\n\tint fd, chips;\n\tuint8_t buf[255];\n\tuint16_t bufsz;\n\tstruct cgpu_info dummy;\n\tchar *devname = NULL;\n\t\n\tfd = serial_open(devpath, 0, 10, true);\n\tapplog(LOG_DEBUG, \"%s: %s %s\",\n\t       littlefury_drv.dname,\n\t       ((fd == -1) ? \"Failed to open\" : \"Successfully opened\"),\n\t       devpath);\n\t\n\tif (unlikely(fd == -1))\n\t\tgoto err;\n\t\n\tbufsz = sizeof(buf);\n\tif (!bitfury_do_packet(LOG_DEBUG, littlefury_drv.dname, fd, buf, &bufsz, LFOP_VERSION, NULL, 0))\n\t\tgoto err;\n\t\n\tif (bufsz < 4)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Incomplete version response\", littlefury_drv.dname);\n\t\tgoto err;\n\t}\n\t\n\tdevname = malloc(bufsz - 3);\n\tmemcpy(devname, (char*)&buf[4], bufsz - 4);\n\tdevname[bufsz - 4] = '\\0';\n\tapplog(LOG_DEBUG, \"%s: Identified %s %d.%d.%d (features %02x)\",\n\t       littlefury_drv.dname, devname, buf[0], buf[1], buf[2], buf[3]);\n\t\n\tif (!littlefury_set_power(LOG_DEBUG, littlefury_drv.dname, fd, true))\n\t\tapplog(LOG_WARNING, \"%s: Unable to power on chip(s) for %s\",\n\t\t       littlefury_drv.dname, devpath);\n\t\n\tdummy.device = &dummy;\n\tdummy.device_fd = fd;\n\t\n\tchips = littlefury_chip_count(&dummy);\n\t\n\tif (!chips) {\n\t\tapplog(LOG_WARNING, \"%s: No Bitfury chips detected on %s\",\n\t\t       littlefury_drv.dname, devpath);\n\t\tgoto err;\n\t} else {\n\t\tapplog(LOG_DEBUG, \"%s: %d chips detected\",\n\t\t       littlefury_drv.dname, chips);\n\t}\n\t\n\tlittlefury_set_power(LOG_DEBUG, littlefury_drv.dname, fd, false);\n\t\n\tif (serial_claim_v(devpath, &littlefury_drv))\n\t\tgoto err;\n\t\n\tserial_close(fd);\n\t\n\tstruct cgpu_info *cgpu;\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &littlefury_drv,\n\t\t.set_device_funcs = bitfury_set_device_funcs,\n\t\t.device_path = strdup(devpath),\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = chips,\n\t\t.threads = 1,\n\t\t.name = devname,\n\t\t.cutofftemp = 85,\n\t};\n\t// NOTE: Xcode's clang has a bug where it cannot find fields inside anonymous unions (more details in fpgautils)\n\tcgpu->device_fd = -1;\n\t\n\treturn add_cgpu(cgpu);\n\nerr:\n\tif (fd != -1)\n\t\tserial_close(fd);\n\tfree(devname);\n\treturn false;\n}\n\nstatic\nbool littlefury_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, littlefury_detect_one);\n}\n\nstruct littlefury_state {\n\tint chips_enabled;\n\tbool powered;\n};\n\nstatic\nbool littlefury_thread_init(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct cgpu_info *proc;\n\tstruct spi_port *spi;\n\tstruct bitfury_device *bitfury;\n\tstruct littlefury_state * const lfstate = malloc(sizeof(*lfstate));\n\tint i = 0;\n\t\n\t*lfstate = (struct littlefury_state){\n\t\t.chips_enabled = 0,\n\t};\n\t\n\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tstruct thr_info * const proc_thr = proc->thr[0];\n\t\t\n\t\tspi = malloc(sizeof(*spi));\n\t\t\n\t\t/* Be careful, read lowl-spi.h comments for warnings */\n\t\tmemset(spi, 0, sizeof(*spi));\n\t\tspi->txrx = littlefury_txrx;\n\t\tspi->cgpu = proc;\n\t\tspi->repr = proc->proc_repr;\n\t\tspi->logprio = LOG_ERR;\n\t\t\n\t\tbitfury = malloc(sizeof(*bitfury));\n\t\t*bitfury = (struct bitfury_device){\n\t\t\t.spi = spi,\n\t\t\t.fasync = i++,\n\t\t};\n\t\t\n\t\tproc->device_data = bitfury;\n\t\t\n\t\tbitfury->osc6_bits = 50;\n\t\t\n\t\tproc_thr->cgpu_data = lfstate;\n\t\t++lfstate->chips_enabled;\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\tcgpu->status = LIFE_INIT2;\n\treturn true;\n}\n\nstatic void littlefury_common_error(struct cgpu_info *, enum dev_reason);\n\nstatic\nbool littlefury_power_on(struct cgpu_info * const dev)\n{\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct littlefury_state * const lfstate = master_thr->cgpu_data;\n\t\n\tapplog(LOG_DEBUG, \"%s: Turning power on\", dev->dev_repr);\n\tif (!littlefury_set_power(LOG_WARNING, dev->dev_repr, dev->device_fd, true))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Unable to power on chip(s)\", dev->dev_repr);\n\t\tlittlefury_common_error(dev, REASON_THREAD_FAIL_INIT);\n\t\tserial_close(dev->device_fd);\n\t\tdev->device_fd = -1;\n\t\tlfstate->powered = false;\n\t\treturn false;\n\t}\n\t\n\tlfstate->powered = true;\n\treturn true;\n}\n\nstatic\nvoid littlefury_chip_init(struct cgpu_info * const proc)\n{\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\tbitfury_init_chip(proc);\n}\n\nstatic\nvoid littlefury_disable(struct thr_info * const thr)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct littlefury_state * const lfstate = thr->cgpu_data;\n\t\n\tbitfury_disable(thr);\n\t\n\t// If all chips disabled, kill power and close device\n\tif (!--lfstate->chips_enabled)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: 0 chips enabled, turning off power\", dev->dev_repr);\n\t\tlfstate->powered = false;\n\t\tif (!littlefury_set_power(LOG_ERR, dev->dev_repr, dev->device_fd, false))\n\t\t\tapplog(LOG_WARNING, \"%s: Unable to power off chip(s)\", dev->dev_repr);\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%s: %d chips enabled, power remains on\", dev->dev_repr, lfstate->chips_enabled);\n}\n\nstatic\nvoid littlefury_enable(struct thr_info * const thr)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct thr_info * const master_thr = dev->thr[0];\n\tstruct littlefury_state * const lfstate = thr->cgpu_data;\n\t\n\t++lfstate->chips_enabled;\n\t\n\tif (dev->device_fd != -1 && !lfstate->powered)\n\t\tlittlefury_power_on(dev);\n\t\n\tif (dev->device_fd != -1)\n\t{\n\t\tstruct bitfury_device * const bitfury = proc->device_data;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_chip(proc);\n\t}\n\t\n\tif (!timer_isset(&master_thr->tv_poll))\n\t\ttimer_set_now(&master_thr->tv_poll);\n}\n\nstatic void littlefury_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tconst int fd = cgpu->device->device_fd;\n\t\n\tbitfury_shutdown(thr);\n\tif (!littlefury_set_power(LOG_ERR, cgpu->dev_repr, fd, false))\n\t\tapplog(LOG_WARNING, \"%s: Unable to power off chip(s)\", cgpu->dev_repr);\n}\n\nstatic\nvoid littlefury_common_error(struct cgpu_info * const dev, const enum dev_reason reason)\n{\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tdev_error(proc, reason);\n\t\tinc_hw_errors_only(thr);\n\t}\n}\n\nstatic\nbool littlefury_get_stats(struct cgpu_info * const dev)\n{\n\tif (dev != dev->device)\n\t\treturn true;\n\t\n\tuint16_t bufsz = 2;\n\tuint8_t buf[bufsz];\n\t\n\tif (bitfury_do_packet(LOG_WARNING, dev->dev_repr, dev->device_fd, buf, &bufsz, LFOP_TEMP, NULL, 0) && bufsz == sizeof(buf))\n\t{\n\t\tfloat temp = upk_u16be(buf, 0);\n\t\ttemp = (1.3979 * temp) - 295.23;\n\t\tfor_each_managed_proc(proc, dev)\n\t\t\tproc->temp = temp;\n\t}\n\t\n\treturn true;\n}\n\nstatic\nvoid littlefury_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu, *proc;\n\tstruct littlefury_state * const lfstate = master_thr->cgpu_data;\n\tint fd = dev->device_fd;\n\t\n\tif (unlikely(fd == -1))\n\t{\n\t\tfd = serial_open(dev->device_path, 0, 10, true);\n\t\tif (unlikely(fd == -1))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Failed to open %s\",\n\t\t\t       dev->dev_repr, dev->device_path);\n\t\t\tlittlefury_common_error(dev, REASON_THREAD_FAIL_INIT);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdev->device_fd = fd;\n\t\tlfstate->powered = false;\n\t}\n\t\n\tif (unlikely((!lfstate->powered) && lfstate->chips_enabled > 0))\n\t{\n\t\tif (!littlefury_power_on(dev))\n\t\t\treturn;\n\t\t\n\t\tfor (proc = dev; proc; proc = proc->next_proc)\n\t\t{\n\t\t\tif (proc->deven != DEV_ENABLED || proc->thr[0]->pause)\n\t\t\t\tcontinue;\n\t\t\tlittlefury_chip_init(proc);\n\t\t}\n\t}\n\t\n\tlittlefury_get_stats(dev);\n\t\n\tbitfury_do_io(master_thr);\n\t\n\tif (!timer_isset(&master_thr->tv_poll))\n\t\t// We want to keep polling temperature\n\t\ttimer_set_delay_from_now(&master_thr->tv_poll, 1000000);\n}\n\nstatic\nvoid littlefury_reinit(struct cgpu_info * const proc)\n{\n\ttimer_set_now(&proc->thr[0]->tv_poll);\n}\n\nstruct device_drv littlefury_drv = {\n\t.dname = \"littlefury\",\n\t.name = \"LFY\",\n\t.lowl_match = littlefury_lowl_match,\n\t.lowl_probe = littlefury_lowl_probe,\n\t\n\t.thread_init = littlefury_thread_init,\n\t.thread_disable = littlefury_disable,\n\t.thread_enable = littlefury_enable,\n\t.reinit_device = littlefury_reinit,\n\t.thread_shutdown = littlefury_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = littlefury_poll,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-metabank.c",
          "type": "blob",
          "size": 6.1396484375,
          "content": "/*\n * Copyright 2013 bitfury\n * Copyright 2013 Anatoly Legkodymov\n * Copyright 2013 Luke Dashjr\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"lowl-spi.h\"\n#include \"tm_i2c.h\"\n\nBFG_REGISTER_DRIVER(metabank_drv)\n\nstatic\nbool metabank_spi_txrx(struct spi_port *port)\n{\n\tstatic int current_slot = -1;\n\tstruct cgpu_info * const proc = port->cgpu;\n\tstruct bitfury_device * const bitfury = proc->device_data;\n\t\n\tif (current_slot != bitfury->slot)\n\t{\n\t\tif (current_slot != -1)\n\t\t\ttm_i2c_clear_oe(current_slot);\n\t\ttm_i2c_set_oe(bitfury->slot);\n\t\tcurrent_slot = bitfury->slot;\n\t}\n\t\n\tconst bool rv = sys_spi_txrx(port);\n\treturn rv;\n}\n\nstatic\nint metabank_autodetect()\n{\n\tRUNONCE(0);\n\t\n\tstruct cgpu_info *cgpu = NULL, *proc1 = NULL, *prev_cgpu = NULL;\n\tstruct bitfury_device **devicelist, *bitfury;\n\tstruct spi_port *port;\n\tint i, j;\n\tint proc_count = 0;\n\tbool slot_on[32];\n\tstruct bitfury_device dummy_bitfury;\n\tstruct cgpu_info dummy_cgpu;\n\t\n\tapplog(LOG_INFO, \"INFO: bitfury_detect\");\n\tspi_init();\n\tif (!sys_spi)\n\t\treturn 0;\n\t\n\tif (tm_i2c_init() < 0) {\n\t\tapplog(LOG_DEBUG, \"%s: I2C init error\", metabank_drv.dname);\n\t\treturn 0;\n\t}\n\t\n\tdummy_cgpu.device_data = &dummy_bitfury;\n\t\n\tfor (i = 0; i < 32; i++) {\n\t\tslot_on[i] = 0;\n\t}\n\tfor (i = 0; i < 32; i++) {\n\t\tint slot_detected = tm_i2c_detect(i) != -1;\n\t\tslot_on[i] = slot_detected;\n\t\ttm_i2c_clear_oe(i);\n\t\tcgsleep_ms(1);\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (slot_on[i]) {\n\t\t\tint chip_n;\n\t\t\t\n\t\t\tport = malloc(sizeof(*port));\n\t\t\t*port = *sys_spi;\n\t\t\tport->cgpu = &dummy_cgpu;\n\t\t\tport->txrx = metabank_spi_txrx;\n\t\t\tdummy_bitfury.slot = i;\n\t\t\t\n\t\t\tchip_n = libbitfury_detectChips1(port);\n\t\t\tif (chip_n)\n\t\t\t{\n\t\t\t\tapplog(LOG_WARNING, \"BITFURY slot %d: %d chips detected\", i, chip_n);\n\t\t\t\t\n\t\t\t\tdevicelist = malloc(sizeof(*devicelist) * chip_n);\n\t\t\t\tfor (j = 0; j < chip_n; ++j)\n\t\t\t\t{\n\t\t\t\t\tdevicelist[j] = bitfury = malloc(sizeof(*bitfury));\n\t\t\t\t\t*bitfury = (struct bitfury_device){\n\t\t\t\t\t\t.spi = port,\n\t\t\t\t\t\t.slot = i,\n\t\t\t\t\t\t.fasync = j,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcgpu = malloc(sizeof(*cgpu));\n\t\t\t\t*cgpu = (struct cgpu_info){\n\t\t\t\t\t.drv = &metabank_drv,\n\t\t\t\t\t.set_device_funcs = bitfury_set_device_funcs,\n\t\t\t\t\t.procs = chip_n,\n\t\t\t\t\t.device_data = devicelist,\n\t\t\t\t\t.cutofftemp = 50,\n\t\t\t\t};\n\t\t\t\tadd_cgpu_slave(cgpu, prev_cgpu);\n\t\t\t\t\n\t\t\t\tproc_count += chip_n;\n\t\t\t\tif (!proc1)\n\t\t\t\t\tproc1 = cgpu;\n\t\t\t\tprev_cgpu = cgpu;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(port);\n\t\t}\n\t}\n\t\n\tif (proc1)\n\t\tproc1->threads = 1;\n\t\n\treturn proc_count;\n}\n\nstatic void metabank_detect(void)\n{\n\tnoserial_detect_manual(&metabank_drv, metabank_autodetect);\n}\n\nstatic\nbool metabank_init(struct thr_info *thr)\n{\n\tstruct bitfury_device **devicelist;\n\tstruct cgpu_info *proc;\n\tstruct bitfury_device *bitfury;\n\t\n\tfor (proc = thr->cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tdevicelist = proc->device_data;\n\t\tbitfury = devicelist[proc->proc_id];\n\t\tproc->device_data = bitfury;\n\t\tbitfury->spi->cgpu = proc;\n\t\tbitfury_init_chip(proc);\n\t\tbitfury->osc6_bits = 53;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);\n\t\t\n\t\tif (proc->proc_id == proc->procs - 1)\n\t\t\tfree(devicelist);\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\t\n\treturn true;\n}\n\nstatic void metabank_shutdown(struct thr_info *thr)\n{\n\tbitfury_shutdown(thr);\n\ttm_i2c_close();\n}\n\nstatic bool metabank_get_stats(struct cgpu_info *cgpu)\n{\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\tfloat t;\n\n\tt = tm_i2c_gettemp(bitfury->slot) * 0.1;\n\n\tif (t < -27) //Sometimes tm_i2c_gettemp() returns strange result, ignoring it.\n\t\treturn false;\n\n\tcgpu->temp = t;\n\n\treturn true;\n}\n\nstatic struct api_data *metabank_api_extra_device_detail(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\t\n\troot = bitfury_api_device_detail(cgpu);\n\n\troot = api_add_uint(root, \"Slot\", &(bitfury->slot), false);\n\n\treturn root;\n}\n\nstatic struct api_data *metabank_api_extra_device_status(struct cgpu_info *cgpu)\n{\n\tstruct api_data *root = NULL;\n\tfloat vc0, vc1;\n\tstruct bitfury_device * const bitfury = cgpu->device_data;\n\t\n\troot = bitfury_api_device_status(cgpu);\n\n\tvc0 = tm_i2c_getcore0(bitfury->slot);\n\tvc1 = tm_i2c_getcore1(bitfury->slot);\n\n\troot = api_add_volts(root, \"Slot VC0\", &vc0, true);\n\troot = api_add_volts(root, \"Slot VC1\", &vc1, true);\n\n\treturn root;\n}\n\nstruct device_drv metabank_drv = {\n\t.dname = \"metabank\",\n\t.name = \"MBF\",\n\t.drv_detect = metabank_detect,\n\t\n\t.thread_init = metabank_init,\n\t.thread_enable = bitfury_enable,\n\t.thread_disable = bitfury_disable,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = bitfury_do_io,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.thread_shutdown = metabank_shutdown,\n\t.get_api_extra_device_detail = metabank_api_extra_device_detail,\n\t.get_api_extra_device_status = metabank_api_extra_device_status,\n\t.get_stats = metabank_get_stats,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-minergate.c",
          "type": "blob",
          "size": 18.2421875,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n *\n * To avoid doubt: Programs using the minergate protocol to interface with\n * BFGMiner are considered part of the Corresponding Source, and not an\n * independent work. This means that such programs distrbuted with BFGMiner\n * must be released under the terms of the GPLv3 license, or sufficiently\n * compatible terms.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"miner.h\"\n\n#define MINERGATE_MAX_NONCE_DIFF  0x20\n\nstatic const char * const minergate_stats_file = \"/var/run/mg_rate_temp\";\n\n#define MINERGATE_MAGIC  0xcaf4\n#define MINERGATE_PKT_HEADER_SZ       8\n#define MINERGATE_PKT_REQ_ITEM_SZ  0x34\n#define MINERGATE_POLL_US      100000\n#define MINERGATE_RETRY_US    5000000\n\nBFG_REGISTER_DRIVER(minergate_drv)\n\nenum minergate_protocol_ver {\n\tMPV_SP10 =  6,\n\tMPV_SP30 = 30,\n};\n\nenum minergate_reqpkt_flags {\n\tMRPF_FIRST = 1,\n\tMRPF_FLUSH = 2,\n};\n\nstruct minergate_config {\n\tuint8_t protover;\n\tint n_req;\n\tint n_req_queue;\n\tint n_rsp;\n\tint queue;\n\tchar *stats_file;\n\tint minimum_roll;\n\tint desired_roll;\n\tint work_duration;\n\t\n\tint pkt_req_sz;\n\tint pkt_rsp_sz;\n\tint pkt_rsp_item_sz;\n};\n\nstruct minergate_state {\n\twork_device_id_t next_jobid;\n\tunsigned ready_to_queue;\n\tuint8_t *req_buffer;\n\tlong *stats;\n\tunsigned stats_count;\n\tstruct work *flushed_work;\n};\n\nstatic\nint minergate_open(const char * const devpath)\n{\n\tsize_t devpath_len = strlen(devpath);\n\tstruct sockaddr_un sa = {\n\t\t.sun_family = AF_UNIX,\n\t};\n#ifdef UNIX_PATH_MAX\n\tif (devpath_len >= UNIX_PATH_MAX)\n#else\n\tif (devpath_len >= sizeof(sa.sun_path))\n#endif\n\t\treturn -1;\n\tconst int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tstrcpy(sa.sun_path, devpath);\n\tif (connect(fd, &sa, sizeof(sa)))\n\t{\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}\n\nstatic\nssize_t minergate_read(const int fd, void * const buf_p, size_t bufLen)\n{\n\tuint8_t *buf = buf_p;\n\tssize_t rv, ret = 0;\n\twhile (bufLen > 0)\n\t{\n\t\trv = read(fd, buf, bufLen);\n\t\tif (rv <= 0)\n\t\t{\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\t\t\treturn rv;\n\t\t}\n\t\tbuf += rv;\n\t\tbufLen -= rv;\n\t\tret += rv;\n\t}\n\treturn ret;\n}\n\n\n#define DEF_POSITIVE_VAR(VARNAME)  \\\nstatic  \\\nconst char *minergate_init_ ## VARNAME(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)  \\\n{  \\\n\tstruct minergate_config * const mgcfg = proc->device_data;  \\\n\tint nv = atoi(newvalue);  \\\n\tif (nv < 0)  \\\n\t\treturn #VARNAME \" must be positive\";  \\\n\tmgcfg->VARNAME = nv;  \\\n\treturn NULL;  \\\n}  \\\n// END OF DEF_POSITIVE_VAR\n\nstatic\nconst char *minergate_init_protover(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct minergate_config * const mgcfg = proc->device_data;\n\t\n\tint i = atoi(newvalue);\n\t\n\tif (i != MPV_SP10 || i != MPV_SP30)\n\t\treturn \"Invalid protocol version\";\n\t\n\tmgcfg->protover = i;\n\t\n\treturn NULL;\n}\n\nDEF_POSITIVE_VAR(n_req)\nDEF_POSITIVE_VAR(n_req_queue)\nDEF_POSITIVE_VAR(n_rsp)\nDEF_POSITIVE_VAR(queue)\n\nstatic\nconst char *minergate_init_stats_file(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct minergate_config * const mgcfg = proc->device_data;\n\tfree(mgcfg->stats_file);\n\tmgcfg->stats_file = trimmed_strdup(newvalue);\n\treturn NULL;\n}\n\nDEF_POSITIVE_VAR(work_duration)\nDEF_POSITIVE_VAR(minimum_roll)\nDEF_POSITIVE_VAR(desired_roll)\n\nstatic const struct bfg_set_device_definition minergate_set_device_funcs_probe[] = {\n\t{\"protover\", minergate_init_protover, NULL},\n\t{\"n_req\", minergate_init_n_req, NULL},\n\t{\"n_req_queue\", minergate_init_n_req_queue, NULL},\n\t{\"n_rsp\", minergate_init_n_rsp, NULL},\n\t{\"queue\", minergate_init_queue, NULL},\n\t{\"stats_file\", minergate_init_stats_file, NULL},\n\t{\"work_duration\", minergate_init_work_duration, NULL},\n\t{\"minimum_roll\", minergate_init_minimum_roll, NULL},\n\t{\"desired_roll\", minergate_init_desired_roll, NULL},\n\t{NULL},\n};\n\nstatic\nbool minergate_detect_one_extra(const char * const devpath, const enum minergate_protocol_ver def_protover)\n{\n\tbool rv = false;\n\tconst int fd = minergate_open(devpath);\n\tif (unlikely(fd < 0))\n\t\tapplogr(false, LOG_DEBUG, \"%s: %s: Cannot connect\", minergate_drv.dname, devpath);\n\t\n\tstruct minergate_config * const mgcfg = malloc(sizeof(*mgcfg));\n\t*mgcfg = (struct minergate_config){\n\t\t.protover = def_protover,\n\t\t.work_duration = -1,\n\t\t.minimum_roll = -1,\n\t\t.desired_roll = -1,\n\t};\n\tdrv_set_defaults(&minergate_drv, minergate_set_device_funcs_probe, mgcfg, devpath, NULL, 1);\n\tswitch (mgcfg->protover)\n\t{\n\t\tcase MPV_SP10:\n\t\t\tBFGINIT(mgcfg->n_req, 100);\n\t\t\tBFGINIT(mgcfg->n_req_queue, mgcfg->n_req);\n\t\t\tBFGINIT(mgcfg->n_rsp, 300);\n\t\t\tBFGINIT(mgcfg->queue, 300);\n\t\t\tmgcfg->pkt_rsp_item_sz = 0x14;\n\t\t\tmgcfg->minimum_roll = mgcfg->desired_roll = 0;  // not supported\n\t\t\tbreak;\n\t\tcase MPV_SP30:\n\t\t\tBFGINIT(mgcfg->n_req, 30);\n\t\t\tBFGINIT(mgcfg->n_req_queue, min(10, mgcfg->n_req));\n\t\t\tBFGINIT(mgcfg->n_rsp, 60);\n\t\t\tBFGINIT(mgcfg->queue, 40);\n\t\t\tmgcfg->pkt_rsp_item_sz = 0x10;\n\t\t\tif (mgcfg->minimum_roll == -1)\n\t\t\t\tmgcfg->minimum_roll = 60;\n\t\t\tbreak;\n\t}\n\tBFGINIT(mgcfg->stats_file, strdup(minergate_stats_file));\n\tmgcfg->desired_roll = max(mgcfg->desired_roll, mgcfg->minimum_roll);\n\tif (mgcfg->work_duration == -1)\n\t\tmgcfg->work_duration = 0x10;  // reasonable guess?\n\tmgcfg->pkt_req_sz = MINERGATE_PKT_HEADER_SZ + (MINERGATE_PKT_REQ_ITEM_SZ * mgcfg->n_req);\n\tmgcfg->pkt_rsp_sz = MINERGATE_PKT_HEADER_SZ + (mgcfg->pkt_rsp_item_sz * mgcfg->n_rsp);\n\t\n\tint epfd = -1;\n\tuint8_t buf[mgcfg->pkt_req_sz];\n\tbuf[0] = 0xbf;\n\tbuf[1] = 0x90;\n\tbuf[2] = mgcfg->protover;\n\tbuf[3] = MRPF_FIRST;\n\tpk_u16le(buf, 4, MINERGATE_MAGIC);\n\tmemset(&buf[6], '\\0', mgcfg->pkt_req_sz - 6);\n\tif (mgcfg->pkt_req_sz != write(fd, buf, mgcfg->pkt_req_sz))\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: write incomplete or failed\", minergate_drv.dname, devpath);\n\t\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s failed\", minergate_drv.dname, devpath, \"epoll_create\");\n\t\n\tstruct epoll_event eev;\n\teev.events = EPOLLIN;\n\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &eev))\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s failed\", minergate_drv.dname, devpath, \"epoll_ctl\");\n\t\n\tsize_t read_bytes = 0;\n\tstatic const size_t read_expect = MINERGATE_PKT_HEADER_SZ;\n\tssize_t r;\n\twhile (read_bytes < read_expect)\n\t{\n\t\tif (epoll_wait(epfd, &eev, 1, 1000) != 1)\n\t\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: Timeout waiting for response\", minergate_drv.dname, devpath);\n\t\tr = read(fd, &buf[read_bytes], read_expect - read_bytes);\n\t\tif (r <= 0)\n\t\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s failed\", minergate_drv.dname, devpath, \"read\");\n\t\tread_bytes += r;\n\t}\n\t\n\tif (buf[1] != 0x90)\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s mismatch\", minergate_drv.dname, devpath, \"request_id\");\n\tif (buf[2] != mgcfg->protover)\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s mismatch\", minergate_drv.dname, devpath, \"Protocol version\");\n\tif (upk_u16le(buf, 4) != MINERGATE_MAGIC)\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: %s mismatch\", minergate_drv.dname, devpath, \"magic\");\n\t\n\tuint16_t responses = upk_u16le(buf, 6);\n\tif (responses > mgcfg->n_rsp)\n\t\treturn_via_applog(out, , LOG_DEBUG, \"%s: %s: More than maximum responses\", minergate_drv.dname, devpath);\n\t\n\tif (bfg_claim_any2(&minergate_drv, devpath, \"unix\", devpath))\n\t\tgoto out;\n\t\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &minergate_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.device_data = mgcfg,\n\t\t.deven = DEV_ENABLED,\n\t\t.threads = 1,\n\t};\n\trv = add_cgpu(cgpu);\n\t\nout:\n\tif (!rv)\n\t\tfree(mgcfg);\n\tclose(fd);\n\tif (epfd >= 0)\n\t\tclose(epfd);\n\treturn rv;\n}\n\nstatic\nbool minergate_detect_one(const char * const devpath)\n{\n\treturn minergate_detect_one_extra(devpath, MPV_SP10);\n}\n\nstatic\nint minergate_detect_auto(void)\n{\n\tint total = 0;\n\tif (minergate_detect_one_extra(\"/tmp/connection_pipe\", MPV_SP10))\n\t\t++total;\n\tif (minergate_detect_one_extra(\"/tmp/connection_pipe_sp30\", MPV_SP30))\n\t\t++total;\n\treturn total;\n}\n\nstatic\nvoid minergate_detect(void)\n{\n\tgeneric_detect(&minergate_drv, minergate_detect_one, minergate_detect_auto, 0);\n}\n\nstatic\nbool minergate_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct minergate_config * const mgcfg = dev->device_data;\n\t\n\tconst int fd = minergate_open(dev->device_path);\n\tdev->device_fd = fd;\n\tif (fd < 0)\n\t\tapplogr(false, LOG_ERR, \"%s: Cannot connect\", dev->dev_repr);\n\t\n\tstruct minergate_state * const state = malloc(sizeof(*state) + mgcfg->pkt_req_sz);\n\tif (!state)\n\t\tapplogr(false, LOG_ERR, \"%s: %s failed\", dev->dev_repr, \"malloc\");\n\t*state = (struct minergate_state){\n\t\t.req_buffer = (void*)&state[1]\n\t};\n\tthr->cgpu_data = state;\n\tthr->work = thr->work_list = NULL;\n\t\n\tmutex_init(&dev->device_mutex);\n\tmemset(state->req_buffer, 0, mgcfg->pkt_req_sz);\n\tpk_u8(state->req_buffer, 2, mgcfg->protover);\n\tstate->req_buffer[3] = MRPF_FIRST | MRPF_FLUSH;\n\tpk_u16le(state->req_buffer, 4, MINERGATE_MAGIC);\n\ttimer_set_delay_from_now(&thr->tv_poll, 0);\n\t\n\treturn true;\n}\n\nstatic\nbool minergate_queue_full(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct minergate_config * const mgcfg = dev->device_data;\n\tstruct minergate_state * const state = thr->cgpu_data;\n\tbool qf;\n\t\n\tif (HASH_COUNT(thr->work) + state->ready_to_queue >= mgcfg->queue)\n\t\tqf = true;\n\telse\n\tif (state->ready_to_queue >= mgcfg->n_req_queue)\n\t\tqf = true;\n\telse\n\tif (state->req_buffer[3] & MRPF_FLUSH)\n\t\t// Job flush occurs after new jobs get queued, so we have to wait until it completes\n\t\tqf = true;\n\telse\n\t\tqf = false;\n\t\n\tthr->queue_full = qf;\n\treturn qf;\n}\n\nstatic\nbool minergate_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct minergate_config * const mgcfg = dev->device_data;\n\tstruct minergate_state * const state = thr->cgpu_data;\n\t\n\tif (minergate_queue_full(thr))\n\t\treturn false;\n\t\n\twork->device_id = (uint32_t)(state->next_jobid++);\n\twork->tv_stamp.tv_sec = 0;\n\t\n\tuint8_t * const my_buf = &state->req_buffer[MINERGATE_PKT_HEADER_SZ + (MINERGATE_PKT_REQ_ITEM_SZ * state->ready_to_queue++)];\n\t\n\tif (mgcfg->desired_roll)\n\t{\n\t\tstruct timeval tv_now, tv_latest;\n\t\ttimer_set_now(&tv_now);\n\t\ttimer_set_delay(&tv_latest, &tv_now, mgcfg->work_duration * 1000000LL);\n\t\tint ntimeroll = work_ntime_range(work, &tv_now, &tv_latest, mgcfg->desired_roll);\n\t\t// NOTE: If minimum_roll bumps ntimeroll up, we may get rejects :(\n\t\tntimeroll = min(0xff, max(mgcfg->minimum_roll, ntimeroll));\n\t\tpk_u8(my_buf, 0x31, ntimeroll);  // ntime limit\n\t}\n\telse\n\t\tpk_u8(my_buf, 0x31, 0);  // ntime limit\n\t\n\tpk_u32be(my_buf,  0, work->device_id);\n\tmemcpy(&my_buf[   4], &work->data[0x48], 4);  // nbits\n\tmemcpy(&my_buf[   8], &work->data[0x44], 4);  // ntime\n\tmemcpy(&my_buf[0x0c], &work->data[0x40], 4);  // merkle-tail\n\tmemcpy(&my_buf[0x10], work->midstate, 0x20);\n\t\n\tif (work->work_difficulty >= MINERGATE_MAX_NONCE_DIFF)\n\t\twork->nonce_diff = MINERGATE_MAX_NONCE_DIFF;\n\telse\n\t\twork->nonce_diff = work->work_difficulty;\n\tconst uint16_t zerobits = log2(floor(work->nonce_diff * 4294967296));\n\twork->nonce_diff = pow(2, zerobits) / 4294967296;\n\tpk_u8(my_buf, 0x30, zerobits);\n\t// 0x31 is ntimeroll, which must be set before data ntime (in case it's changed)\n\tpk_u8(my_buf, 0x32,    0);  // pv6: ntime offset ; pv30: reserved\n\tpk_u8(my_buf, 0x33,    0);  // reserved\n\t\n\tstruct work *oldwork;\n\tHASH_FIND(hh, thr->work, &work->device_id, sizeof(work->device_id), oldwork);\n\tif (unlikely(oldwork))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Reusing allocated device id %\"PRIwdi, dev->dev_repr, work->device_id);\n\t\tHASH_DEL(thr->work, oldwork);\n\t\tfree_work(oldwork);\n\t}\n\tHASH_ADD(hh, thr->work, device_id, sizeof(work->device_id), work);\n\tLL_PREPEND(thr->work_list, work);\n\ttimer_set_delay_from_now(&thr->tv_poll, 0);\n\tminergate_queue_full(thr);\n\t\n\treturn true;\n}\n\nstatic\nvoid minergate_queue_flush(struct thr_info * const thr)\n{\n\tstruct minergate_state * const state = thr->cgpu_data;\n\tstruct work *work, *worktmp;\n\t\n\t// Flush internal ready-to-queue list\n\tLL_FOREACH_SAFE(thr->work_list, work, worktmp)\n\t{\n\t\tHASH_DEL(thr->work, work);\n\t\tLL_DELETE(thr->work_list, work);\n\t\tfree_work(work);\n\t}\n\tstate->ready_to_queue = 0;\n\t\n\t// Trigger minergate flush\n\tstate->req_buffer[3] |= MRPF_FLUSH;\n\t\n\ttimer_set_delay_from_now(&thr->tv_poll, 0);\n}\n\nstatic\nbool minergate_submit(struct thr_info * const thr, struct work * const work, const uint32_t nonce, const uint8_t ntime_offset, int64_t * const hashes)\n{\n\tif (!nonce)\n\t\treturn false;\n\t\n\tif (likely(work))\n\t{\n\t\tsubmit_noffset_nonce(thr, work, nonce, ntime_offset);\n\t\t\n\t\tstruct cgpu_info * const dev = thr->cgpu;\n\t\tstruct minergate_config * const mgcfg = dev->device_data;\n\t\tif (mgcfg->desired_roll)\n\t\t\t*hashes += 0x100000000 * work->nonce_diff;\n\t}\n\telse\n\t\tinc_hw_errors3(thr, NULL, &nonce, 1.);\n\t\n\treturn true;\n}\n\nstatic\nvoid minergate_poll(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct minergate_config * const mgcfg = dev->device_data;\n\tstruct minergate_state * const state = thr->cgpu_data;\n\tconst int fd = dev->device_fd;\n\tuint8_t buf[mgcfg->pkt_rsp_sz];\n\t\n\tif (opt_dev_protocol || state->ready_to_queue)\n\t\tapplog(LOG_DEBUG, \"%s: Polling with %u new jobs\", dev->dev_repr, state->ready_to_queue);\n\tpk_u16le(state->req_buffer, 6, state->ready_to_queue);\n\tif (mgcfg->pkt_req_sz != write(fd, state->req_buffer, mgcfg->pkt_req_sz))\n\t\treturn_via_applog(err, , LOG_ERR, \"%s: write incomplete or failed\", dev->dev_repr);\n\t\n\tuint8_t flags = state->req_buffer[3];\n\tstate->req_buffer[3] = 0;\n\tstate->ready_to_queue = 0;\n\tthr->work_list = NULL;\n\t\n\tif (minergate_read(fd, buf, mgcfg->pkt_rsp_sz) != mgcfg->pkt_rsp_sz)\n\t\treturn_via_applog(err, , LOG_ERR, \"%s: %s failed\", dev->dev_repr, \"read\");\n\t\n\tif (upk_u8(buf, 2) != mgcfg->protover || upk_u16le(buf, 4) != MINERGATE_MAGIC)\n\t\treturn_via_applog(err, , LOG_ERR, \"%s: Protocol mismatch\", dev->dev_repr);\n\t\n\tuint8_t *jobrsp = &buf[MINERGATE_PKT_HEADER_SZ];\n\tstruct work *work;\n\tuint16_t rsp_count = upk_u16le(buf, 6);\n\tif (rsp_count || opt_dev_protocol)\n\t\tapplog(LOG_DEBUG, \"%s: Received %u job completions\", dev->dev_repr, rsp_count);\n\tuint32_t nonce;\n\tuint8_t ntime_offset;\n\tint64_t hashes = 0;\n\tfor (unsigned i = 0; i < rsp_count; ++i, (jobrsp += mgcfg->pkt_rsp_item_sz))\n\t{\n\t\twork_device_id_t jobid = upk_u32be(jobrsp, 0);\n\t\tnonce = upk_u32le(jobrsp, 8);\n\t\tntime_offset = upk_u8(jobrsp, (mgcfg->protover == MPV_SP10) ? 0x10 : 0xc);\n\t\t\n\t\tHASH_FIND(hh, thr->work, &jobid, sizeof(jobid), work);\n\t\tif (unlikely(!work))\n\t\t\tapplog(LOG_ERR, \"%s: Unknown job %\"PRIwdi, dev->dev_repr, jobid);\n\t\t\n\t\tif (minergate_submit(thr, work, nonce, ntime_offset, &hashes))\n\t\t{\n\t\t\tif (mgcfg->protover == MPV_SP10)\n\t\t\t{\n\t\t\t\tnonce = upk_u32le(jobrsp, 0xc);\n\t\t\t\tminergate_submit(thr, work, nonce, ntime_offset, &hashes);\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif (unlikely(!work))\n\t\t\t// Increment HW errors even if no nonce to submit\n\t\t\tinc_hw_errors_only(thr);\n\t\t\n\t\tconst bool work_completed = (mgcfg->protover == MPV_SP10) ? (bool)work : (bool)jobrsp[0xe];\n\t\tif (work_completed)\n\t\t{\n\t\t\tHASH_DEL(thr->work, work);\n\t\t\tapplog(LOG_DEBUG, \"%s: %s job %\"PRIwdi\" completed\", dev->dev_repr, work->tv_stamp.tv_sec ? \"Flushed\" : \"Active\", work->device_id);\n\t\t\tif ((!mgcfg->desired_roll) && !work->tv_stamp.tv_sec)\n\t\t\t\thashes += 0x100000000 * work->nonce_diff;\n\t\t\tfree_work(work);\n\t\t}\n\t}\n\thashes_done2(thr, hashes, NULL);\n\t\n\tif (flags & MRPF_FLUSH)\n\t{\n\t\t// Mark all remaining jobs as flushed so we don't count them in hashes_done\n\t\tstruct work *worktmp;\n\t\tHASH_ITER(hh, thr->work, work, worktmp)\n\t\t{\n\t\t\twork->tv_stamp.tv_sec = 1;\n\t\t}\n\t}\n\t\n\tminergate_queue_full(thr);\n\ttimer_set_delay_from_now(&thr->tv_poll, MINERGATE_POLL_US);\n\treturn;\n\nerr:\n\t// TODO: reconnect\n\ttimer_set_delay_from_now(&thr->tv_poll, MINERGATE_RETRY_US);\n}\n\nstatic\nbool minergate_get_stats(struct cgpu_info * const dev)\n{\n\tstatic const int skip_stats = 1;\n\tstruct minergate_config * const mgcfg = dev->device_data;\n\tstruct thr_info * const thr = dev->thr[0];\n\tstruct minergate_state * const state = thr->cgpu_data;\n\t\n\tif (!(mgcfg->stats_file && mgcfg->stats_file[0]))\n\t\treturn true;\n\t\n\tFILE *F = fopen(mgcfg->stats_file, \"r\");\n\tchar buf[0x100];\n\tif (F)\n\t{\n\t\tchar *p = fgets(buf, sizeof(buf), F);\n\t\tfclose(F);\n\t\tif (p)\n\t\t{\n\t\t\tlong nums[0x80];\n\t\t\tchar *endptr;\n\t\t\tint i;\n\t\t\tfloat max_temp = 0;\n\t\t\tfor (i = 0; 1; ++i)\n\t\t\t{\n\t\t\t\tif (!p[0])\n\t\t\t\t\tbreak;\n\t\t\t\tnums[i] = strtol(p, &endptr, 0);\n\t\t\t\tif (p == endptr)\n\t\t\t\t\tbreak;\n\t\t\t\tif (i >= skip_stats && nums[i] > max_temp)\n\t\t\t\t\tmax_temp = nums[i];\n\t\t\t\twhile (endptr[0] && !isspace(endptr[0]))\n\t\t\t\t\t++endptr;\n\t\t\t\twhile (endptr[0] && isspace(endptr[0]))\n\t\t\t\t\t++endptr;\n\t\t\t\tp = endptr;\n\t\t\t}\n\t\t\ti -= skip_stats;\n\t\t\tlong *new_stats;\n\t\t\tif (likely(i > 0))\n\t\t\t{\n\t\t\t\tnew_stats = malloc(sizeof(*state->stats) * i);\n\t\t\t\tmemcpy(new_stats, &nums[skip_stats], sizeof(*nums) * i);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnew_stats = NULL;\n\t\t\tmutex_lock(&dev->device_mutex);\n\t\t\tfree(state->stats);\n\t\t\tstate->stats = new_stats;\n\t\t\tstate->stats_count = i;\n\t\t\tmutex_unlock(&dev->device_mutex);\n\t\t\tdev->temp = max_temp;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nstatic\nstruct api_data *minergate_api_extra_device_status(struct cgpu_info * const dev)\n{\n\tstruct thr_info * const thr = dev->thr[0];\n\tstruct minergate_state * const state = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\t\n\tmutex_lock(&dev->device_mutex);\n\tif (state->stats_count > 1)\n\t{\n\t\tchar buf[0x10];\n\t\tfor (unsigned i = 0; i < state->stats_count; ++i)\n\t\t{\n\t\t\tfloat temp = state->stats[i];\n\t\t\tif (!temp)\n\t\t\t\tcontinue;\n\t\t\tsprintf(buf, \"Temperature%u\", i);\n\t\t\troot = api_add_temp(root, buf, &temp, true);\n\t\t}\n\t}\n\tmutex_unlock(&dev->device_mutex);\n\t\n\treturn root;\n}\n\nstruct device_drv minergate_drv = {\n\t.dname = \"minergate\",\n\t.name = \"MGT\",\n\t.drv_detect = minergate_detect,\n\t\n\t.thread_init = minergate_init,\n\t.minerloop = minerloop_queue,\n\t\n\t.queue_append = minergate_queue_append,\n\t.queue_flush = minergate_queue_flush,\n\t.poll = minergate_poll,\n\t\n\t.get_stats = minergate_get_stats,\n\t.get_api_extra_device_status = minergate_api_extra_device_status,\n};\n"
        },
        {
          "name": "driver-minion.c",
          "type": "blob",
          "size": 20.453125,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <linux/spi/spidev.h>\n#include <utlist.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nstatic const uint8_t minion_max_chipid = 0x1f;\nstatic const uint8_t minion_chip_signature[] = {0x44, 0x8a, 0xac, 0xb1};\nstatic const unsigned minion_max_queued = 0x10;\nstatic const unsigned minion_poll_us = 10000;\nstatic const unsigned minion_min_clock =  800;\nstatic const unsigned minion_max_clock = 1999;\nstatic const unsigned long minion_temp_interval_us = 5273437;\n\nenum minion_register {\n\tMRA_SIGNATURE        = 0x00,\n\tMRA_STATUS           = 0x01,\n\tMRA_TEMP_CFG         = 0x03,\n\tMRA_PLL_CFG          = 0x04,\n\tMRA_MISC_CTL         = 0x06,\n\tMRA_RESET            = 0x07,\n\tMRA_FIFO_STATUS      = 0x0b,\n\t\n\tMRA_CORE_EN_         = 0x10,\n\t\n\tMRA_RESULT           = 0x20,\n\t\n\tMRA_TASK             = 0x30,\n\t\n\tMRA_NONCE_START      = 0x70,\n\tMRA_NONCE_INC        = 0x71,\n};\n\nstruct minion_chip {\n\tuint8_t chipid;\n\tuint8_t core_count;\n\tuint8_t core_enabled_count;\n\tuint16_t next_taskid;\n\tstruct cgpu_info *first_proc;\n\tunsigned queue_count;\n\tuint32_t core_nonce_inc;\n\tuint32_t pllcfg_asserted;\n\tuint32_t pllcfg_desired;\n\tstruct timeval tv_read_temp;\n\tunsigned long timeout_us;\n\tstruct timeval tv_timeout;\n};\n\nstruct minion_bus {\n\tstruct spi_port *spi;\n};\n\nstatic const uint8_t minion_crystal_mhz = 12;\n\nstatic\nuint32_t minion_freq_to_pllcfg(unsigned freq)\n{\n\tuint32_t rv;\n\tuint8_t * const pllcfg = (void*)&rv;\n\tuint8_t best_rem = 12, pll_dm = 1;\n\tfor (uint8_t try_dm = 1; try_dm <= 8; ++try_dm)\n\t{\n\t\tconst unsigned x = freq * try_dm;\n\t\tif (x > 0x100 * minion_crystal_mhz)\n\t\t\t// We'd overflow pll_dn to continue\n\t\t\tbreak;\n\t\tconst uint8_t rem = x % minion_crystal_mhz;\n\t\tif (rem > best_rem)\n\t\t\tcontinue;\n\t\tbest_rem = rem;\n\t\tpll_dm = try_dm;\n\t\tif (!rem)\n\t\t\tbreak;\n\t}\n\tconst unsigned pll_dn = freq * pll_dm / minion_crystal_mhz;\n\tfreq = pll_dn * minion_crystal_mhz / pll_dm;\n\tconst uint8_t pll_cont = ((freq - 800) / 300);  // 2 bits\n\tstatic const uint8_t pll_dp   = 0;  // 3 bits\n\tstatic const uint8_t pll_byp  = 0;  // 1 bit\n\tstatic const uint8_t pll_div2 = 0;  // 1 bit\n\tstatic const uint8_t sys_div  = 1;  // 3 bits\n\tpllcfg[0] = pll_dn - 1;\n\tpllcfg[1] = (pll_dm - 1) | (pll_dp << 4);\n\tpllcfg[2] = pll_cont | (pll_byp << 2) | (pll_div2 << 4) | (sys_div << 5);\n\tpllcfg[3] = 0;\n\treturn rv;\n}\n\nstatic\nunsigned minion_pllcfg_to_freq(const uint32_t in_pllcfg)\n{\n\tconst uint8_t * const pllcfg = (void*)&in_pllcfg;\n\tconst unsigned pll_dn = (unsigned)pllcfg[0] + 1;\n\tconst uint8_t pll_dm = (pllcfg[1] & 0xf) + 1;\n\tconst unsigned freq = pll_dn * minion_crystal_mhz / pll_dm;\n\t// FIXME: How to interpret the rest of the pll cfg?\n\tif (minion_freq_to_pllcfg(freq) != in_pllcfg)\n\t\treturn 0;\n\treturn freq;\n}\n\nstatic\nvoid minion_get(struct spi_port * const spi, const uint8_t chipid, const uint8_t addr, void * const buf, const size_t bufsz)\n{\n\tconst uint8_t header[] = {chipid, addr | 0x80, bufsz & 0xff, bufsz >> 8};\n\tspi_clear_buf(spi);\n\tspi_emit_buf(spi, header, sizeof(header));\n\tuint8_t dummy[bufsz];\n\tmemset(dummy, 0xff, bufsz);\n\tspi_emit_buf(spi, dummy, bufsz);\n\tspi_txrx(spi);\n\t\n\tuint8_t * const rdbuf = spi_getrxbuf(spi);\n\tmemcpy(buf, &rdbuf[sizeof(header)], bufsz);\n}\n\nstatic\nvoid minion_set(struct spi_port * const spi, const uint8_t chipid, const uint8_t addr, const void * const buf, const size_t bufsz)\n{\n\tconst uint8_t header[] = {chipid, addr, bufsz & 0xff, bufsz >> 8};\n\tspi_clear_buf(spi);\n\tspi_emit_buf(spi, header, sizeof(header));\n\tspi_emit_buf(spi, buf, bufsz);\n\tspi_txrx(spi);\n}\n\nstatic\nunsigned minion_count_cores(struct spi_port * const spi)\n{\n\tuint8_t buf[max(4, sizeof(minion_chip_signature))];\n\tunsigned total_core_count = 0;\n\t\n\tfor (unsigned chipid = 0; chipid <= minion_max_chipid; ++chipid)\n\t{\n\t\tminion_get(spi, chipid, MRA_SIGNATURE, buf, sizeof(minion_chip_signature));\n\t\tif (memcmp(buf, minion_chip_signature, sizeof(minion_chip_signature)))\n\t\t{\n\t\t\tfor (unsigned i = 0; i < sizeof(minion_chip_signature); ++i)\n\t\t\t{\n\t\t\t\tif (buf[i] != 0xff)\n\t\t\t\t{\n\t\t\t\t\tchar hex[(sizeof(minion_chip_signature) * 2) + 1];\n\t\t\t\t\tbin2hex(hex, buf, sizeof(minion_chip_signature));\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: chipid %u: Bad signature (%s)\", spi->repr, chipid, hex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tminion_get(spi, chipid, MRA_STATUS, buf, 4);\n\t\tconst uint8_t core_count = buf[2];\n\t\t\n\t\tapplog(LOG_DEBUG, \"%s: chipid %u: Found %u cores\", spi->repr, chipid, core_count);\n\t\ttotal_core_count += core_count;\n\t}\n\t\n\treturn total_core_count;\n}\n\nstatic inline\nvoid minion_config_pll(struct spi_port * const spi, struct minion_chip * const chip)\n{\n\tif (chip->pllcfg_asserted == chip->pllcfg_desired)\n\t\treturn;\n\tconst uint8_t chipid = chip->chipid;\n\tminion_set(spi, chipid, MRA_PLL_CFG, &chip->pllcfg_desired, 4);\n\tchip->pllcfg_asserted = chip->pllcfg_desired;\n\t// NOTE: This assumes we only ever assert pllcfgs we can decode!\n\tchip->timeout_us = 0xffffffff / minion_pllcfg_to_freq(chip->pllcfg_asserted);\n\ttimer_set_delay_from_now(&chip->tv_timeout, chip->timeout_us);\n}\n\nstatic inline\nvoid minion_core_enable_register_position(const uint8_t coreid, uint8_t * const corereg, uint8_t * const corebyte, uint8_t * const corebit)\n{\n\t*corereg = MRA_CORE_EN_ + (coreid >> 5);\n\t*corebyte = (coreid >> 3) % 4;\n\t*corebit = 1 << (coreid % 8);\n}\n\nstatic\nvoid minion_reinit(struct cgpu_info * const first_proc, struct minion_chip * const chip, const struct timeval * const tvp_now)\n{\n\tstruct thr_info * const thr = first_proc->thr[0];\n\tstruct minion_bus * const mbus = first_proc->device_data;\n\tstruct spi_port * const spi = mbus->spi;\n\tconst uint8_t chipid = chip->chipid;\n\tuint8_t buf[4];\n\t\n\tstatic const uint8_t resetcmd[4] = {0xff, 0xff, 0xa5, 0xf5};\n\tminion_set(spi, chipid, MRA_RESET, resetcmd, sizeof(resetcmd));\n\t\n\tminion_set(spi, chipid, MRA_NONCE_START, \"\\0\\0\\0\\0\", 4);\n\tchip->core_nonce_inc = 0xffffffff / chip->core_count;\n\tpk_u32le(buf, 0, chip->core_nonce_inc);\n\tminion_set(spi, chipid, MRA_NONCE_INC, buf, 4);\n\t\n\tminion_get(spi, chipid, MRA_TEMP_CFG, buf, 4);\n\tbuf[0] &= ~(1 << 5);  // Enable temperature sensor\n\tbuf[0] &= ~(1 << 4);  // 20 C precision (alternative is 40 C)\n\tminion_set(spi, chipid, MRA_TEMP_CFG, buf, 4);\n\t\n\tminion_get(spi, chipid, MRA_PLL_CFG, &chip->pllcfg_asserted, 4);\n\t\n\tminion_get(spi, chipid, MRA_MISC_CTL, buf, 4);\n\tbuf[0] &= ~(1 << 4);  // Unpause cores\n\tbuf[0] &= ~(1 << 3);  // Unpause queue\n\tbuf[0] |= 1 << 2;  // Enable \"no nonce\" result reports\n\tbuf[0] &= ~(1 << 1);  // Disable test mode\n\tminion_set(spi, chipid, MRA_MISC_CTL, buf, 4);\n\t\n\tthr->tv_poll = *tvp_now;\n\tchip->tv_read_temp = *tvp_now;\n}\n\nstatic\nvoid minion_reenable_cores(struct cgpu_info * const first_proc, struct minion_chip * const chip)\n{\n\tstruct minion_bus * const mbus = first_proc->device_data;\n\tstruct spi_port * const spi = mbus->spi;\n\tconst uint8_t chipid = chip->chipid;\n\tuint8_t buf[4] = {0,0,0,0};\n\tstruct cgpu_info *proc = first_proc;\n\tfor (unsigned coreid = 0; coreid < chip->core_count; (proc = proc->next_proc), ++coreid)\n\t{\n\t\tuint8_t corereg, corebyte, corebit;\n\t\tminion_core_enable_register_position(coreid, &corereg, &corebyte, &corebit);\n\t\tif (proc->deven == DEV_ENABLED)\n\t\t\tbuf[corebyte] |= corebit;\n\t\tif (coreid % 0x20 == 0x1f || coreid == chip->core_count - 1)\n\t\t\tminion_set(spi, chipid, corereg, buf, 4);\n\t}\n}\n\nstatic\nbool minion_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu, *proc = dev;\n\tstruct minion_bus * const mbus = dev->device_data;\n\tstruct spi_port * const spi = mbus->spi;\n\tuint8_t buf[max(4, sizeof(minion_chip_signature))];\n\tstruct timeval tv_now;\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tstruct minion_chip * const chips = malloc(sizeof(*chips) * ((size_t)minion_max_chipid + 1));\n\tfor (unsigned chipid = 0; proc; ++chipid)\n\t{\n\t\tstruct minion_chip * const chip = &chips[chipid];\n\t\tspi->repr = proc->proc_repr;\n\t\t\n\t\tminion_get(spi, chipid, MRA_SIGNATURE, buf, sizeof(minion_chip_signature));\n\t\tif (memcmp(buf, minion_chip_signature, sizeof(minion_chip_signature)))\n\t\t\tcontinue;\n\t\t\n\t\tminion_get(spi, chipid, MRA_STATUS, buf, 4);\n\t\tif (!buf[2])\n\t\t\tcontinue;\n\t\t\n\t\t*chip = (struct minion_chip){\n\t\t\t.chipid = chipid,\n\t\t\t.core_count = buf[2],\n\t\t\t.first_proc = proc,\n\t\t\t.pllcfg_desired = minion_freq_to_pllcfg(900),\n\t\t};\n\t\tminion_reinit(proc, chip, &tv_now);\n\t\t\n\t\tfor (unsigned coreid = 0; coreid < chip->core_count; ++coreid)\n\t\t{\n\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\n\t\t\tuint8_t corereg, corebyte, corebit;\n\t\t\tminion_core_enable_register_position(coreid, &corereg, &corebyte, &corebit);\n\t\t\tif (coreid % 0x20 == 0)\n\t\t\t{\n\t\t\t\tspi->repr = proc->proc_repr;\n\t\t\t\tminion_get(spi, chipid, corereg, buf, 4);\n\t\t\t}\n\t\t\tif (buf[corebyte] & corebit)\n\t\t\t\t++chip->core_enabled_count;\n\t\t\telse\n\t\t\t\tproc->deven = DEV_DISABLED;\n\t\t\t\n\t\t\tthr->cgpu_data = chip;\n\t\t\t\n\t\t\tproc = proc->next_proc;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool minion_queue_full(struct minion_chip * const chip)\n{\n\tstruct cgpu_info *proc = chip->first_proc;\n\tstruct thr_info *thr = proc->thr[0];\n\t\n\tconst bool full = (chip->queue_count >= minion_max_queued);\n\tif (full != thr->queue_full)\n\t{\n\t\tfor (unsigned i = 0; i < chip->core_count; (proc = proc->next_proc), ++i)\n\t\t{\n\t\t\tthr = proc->thr[0];\n\t\t\t\n\t\t\tthr->queue_full = full;\n\t\t}\n\t}\n\t\n\treturn full;\n}\n\nstatic\nvoid minion_core_enabledisable(struct thr_info * const thr, const bool enable)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct minion_bus * const mbus = proc->device_data;\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tstruct spi_port * const spi = mbus->spi;\n\tconst uint8_t chipid = chip->chipid;\n\t\n\tuint8_t coreid = 0;\n\tfor (struct cgpu_info *p = chip->first_proc; p != proc; p = p->next_proc)\n\t\t++coreid;\n\t\n\tuint8_t corereg, corebyte, corebit;\n\tminion_core_enable_register_position(coreid, &corereg, &corebyte, &corebit);\n\t\n\tuint8_t buf[4];\n\tminion_get(spi, chipid, corereg, buf, 4);\n\tconst uint8_t oldbyte = buf[corebyte];\n\tif (enable)\n\t\tbuf[corebyte] |= corebit;\n\telse\n\t\tbuf[corebyte] &= ~corebit;\n\tif (buf[corebyte] != oldbyte)\n\t{\n\t\tminion_set(spi, chipid, corereg, buf, 4);\n\t\tchip->core_enabled_count += enable ? 1 : -1;\n\t}\n}\n\nstatic\nvoid minion_core_disable(struct thr_info * const thr)\n{\n\tminion_core_enabledisable(thr, false);\n}\n\nstatic\nvoid minion_core_enable(struct thr_info * const thr)\n{\n\tminion_core_enabledisable(thr, true);\n}\n\nstatic\nbool minion_queue_append(struct thr_info *thr, struct work * const work)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct minion_bus * const mbus = proc->device_data;\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tproc = chip->first_proc;\n\tthr = proc->thr[0];\n\t\n\tif (minion_queue_full(chip))\n\t\treturn false;\n\t\n\tstruct spi_port * const spi = mbus->spi;\n\tconst uint8_t chipid = chip->chipid;\n\tuint8_t taskdata[0x30];\n\tspi->repr = proc->proc_repr;\n\t\n\twork->device_id = ++chip->next_taskid;\n\twork->tv_stamp.tv_sec = 1;\n\twork->blk.nonce = 0;\n\t\n\tpk_u16be(taskdata, 0, work->device_id);\n\tmemset(&taskdata[2], 0, 2);\n\tmemcpy(&taskdata[4], work->midstate, 0x20);\n\tmemcpy(&taskdata[0x24], &work->data[0x40], 0xc);\n\t\n\tminion_config_pll(spi, chip);\n\tminion_set(spi, chipid, MRA_TASK, taskdata, sizeof(taskdata));\n\t\n\tDL_APPEND(thr->work_list, work);\n\t++chip->queue_count;\n\t\n\tminion_queue_full(chip);\n\treturn true;\n}\n\nstatic void minion_refill_queue(struct thr_info *);\n\nstatic\nvoid minion_queue_flush(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct minion_bus * const mbus = proc->device_data;\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tif (proc != chip->first_proc)\n\t\t// Redundant, all queues flush at the same time\n\t\treturn;\n\tconst uint8_t chipid = chip->chipid;\n\tstruct spi_port * const spi = mbus->spi;\n\t\n\tstatic const uint8_t flushcmd[4] = {0xfb, 0xff, 0xff, 0xff};\n\tminion_set(spi, chipid, MRA_RESET, flushcmd, sizeof(flushcmd));\n\t\n\tminion_refill_queue(thr);\n}\n\nstatic\nvoid minion_refill_queue(struct thr_info * const thr)\n{\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tstruct work *work;\n\tDL_FOREACH(thr->work_list, work)\n\t{\n\t\twork->tv_stamp.tv_sec = 0;\n\t}\n\tchip->queue_count = 0;\n\tminion_queue_full(chip);\n}\n\nstatic\nvoid minion_hashes_done(struct cgpu_info *proc, const uint8_t core_count, const uint64_t hashes)\n{\n\tfor (int j = 0; j < core_count; (proc = proc->next_proc), ++j)\n\t{\n\t\tif (proc->deven != DEV_ENABLED)\n\t\t\tcontinue;\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\thashes_done2(thr, hashes, NULL);\n\t}\n}\n\nstatic\nvoid minion_poll(struct thr_info * const chip_thr)\n{\n\tstruct cgpu_info * const first_proc = chip_thr->cgpu;\n\tstruct minion_bus * const mbus = first_proc->device_data;\n\tstruct minion_chip * const chip = chip_thr->cgpu_data;\n\tstruct spi_port * const spi = mbus->spi;\n\tconst uint8_t chipid = chip->chipid;\n\tspi->repr = first_proc->proc_repr;\n\t\n\tuint8_t buf[4];\n\tminion_get(spi, chipid, MRA_FIFO_STATUS, buf, 4);\n\t\n\tconst uint8_t res_fifo_len = buf[0];\n\tif (res_fifo_len)\n\t{\n\t\tstatic const size_t resbuf_i_len = 8;\n\t\tconst size_t resbuf_len = (size_t)res_fifo_len * resbuf_i_len;\n\t\tuint8_t resbuf[resbuf_len], *resbuf_i = resbuf;\n\t\tminion_get(spi, chipid, MRA_RESULT, resbuf, resbuf_len);\n\t\t\n\t\tfor (unsigned i = 0; i < res_fifo_len; (resbuf_i += resbuf_i_len), ++i)\n\t\t{\n\t\t\tconst uint8_t coreid = resbuf_i[2];\n\t\t\twork_device_id_t taskid = upk_u16be(resbuf_i, 0);\n\t\t\tconst bool have_nonce = !(resbuf_i[3] & 0x80);\n\t\t\tstruct cgpu_info *proc;\n\t\t\tstruct thr_info *core_thr;\n\t\t\tbool clean = false;\n\t\t\t\n\t\t\tif (likely(coreid < chip->core_count))\n\t\t\t{\n\t\t\t\tproc = first_proc;\n\t\t\t\tfor (int j = 0; j < coreid; ++j)\n\t\t\t\t\tproc = proc->next_proc;\n\t\t\t\tcore_thr = proc->thr[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tproc = first_proc;\n\t\t\t\tcore_thr = proc->thr[0];\n\t\t\t\tinc_hw_errors_only(core_thr);\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Core id out of range (%u >= %u)\", proc->proc_repr, coreid, chip->core_count);\n\t\t\t}\n\t\t\t\n\t\t\tstruct work *work;\n\t\t\tDL_SEARCH_SCALAR(chip_thr->work_list, work, device_id, taskid);\n\t\t\tif (unlikely(!work))\n\t\t\t{\n\t\t\t\tinc_hw_errors_only(core_thr);\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Unknown task %\"PRIwdi, proc->proc_repr, taskid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (have_nonce)\n\t\t\t{\n\t\t\t\tconst uint32_t nonce = upk_u32le(resbuf_i, 4);\n\t\t\t\t\n\t\t\t\tif (submit_nonce(core_thr, work, nonce))\n\t\t\t\t{\n\t\t\t\t\tclean = (coreid < chip->core_count);\n\t\t\t\t\t\n\t\t\t\t\t// It's only 0xffffffff if we prematurely considered it complete\n\t\t\t\t\tif (likely(work->blk.nonce != 0xffffffff))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t hashes = (nonce % chip->core_nonce_inc);\n\t\t\t\t\t\tif (hashes > work->blk.nonce)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thashes -= work->blk.nonce - 1;\n\t\t\t\t\t\t\tminion_hashes_done(first_proc, chip->core_count, hashes);\n\t\t\t\t\t\t\twork->blk.nonce = hashes + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst uint32_t hashes = chip->core_nonce_inc - work->blk.nonce;\n\t\t\t\tminion_hashes_done(first_proc, chip->core_count, hashes);\n\t\t\t\twork->blk.nonce = 0xffffffff;\n\t\t\t}\n\t\t\t\n\t\t\t// Flag previous work(s) as done, and delete them when we are sure\n\t\t\tstruct work *work_tmp;\n\t\t\tDL_FOREACH_SAFE(chip_thr->work_list, work, work_tmp)\n\t\t\t{\n\t\t\t\tif (work->device_id == taskid)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tif (work->blk.nonce && work->blk.nonce != 0xffffffff)\n\t\t\t\t{\n\t\t\t\t\t// At least one nonce was found, assume the job completed\n\t\t\t\t\tconst uint32_t hashes = chip->core_nonce_inc - work->blk.nonce;\n\t\t\t\t\tminion_hashes_done(first_proc, chip->core_count, hashes);\n\t\t\t\t\twork->blk.nonce = 0xffffffff;\n\t\t\t\t}\n\t\t\t\tif (work->tv_stamp.tv_sec)\n\t\t\t\t{\n\t\t\t\t\t--chip->queue_count;\n\t\t\t\t\twork->tv_stamp.tv_sec = 0;\n\t\t\t\t}\n\t\t\t\tif (clean)\n\t\t\t\t{\n\t\t\t\t\tDL_DELETE(chip_thr->work_list, work);\n\t\t\t\t\tfree_work(work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminion_queue_full(chip);\n\t}\n\t\n\tstruct timeval tv_now;\n\ttimer_set_now(&tv_now);\n\t\n\tif (timer_passed(&chip->tv_read_temp, &tv_now))\n\t{\n\t\tminion_get(spi, chipid, MRA_STATUS, buf, 4);\n\t\tconst float temp = buf[3] * 20.;\n\t\tstruct cgpu_info *proc = first_proc;\n\t\tfor (int j = 0; j < chip->core_count; (proc = proc->next_proc), ++j)\n\t\t\tproc->temp = temp;\n\t\ttimer_set_delay(&chip_thr->tv_poll, &tv_now, minion_temp_interval_us);\n\t}\n\t\n\tif (res_fifo_len)\n\t\ttimer_set_delay(&chip->tv_timeout, &tv_now, chip->timeout_us);\n\telse\n\tif (timer_passed(&chip->tv_timeout, &tv_now))\n\t{\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Chip timeout, reinitialising\", first_proc->proc_repr);\n\t\tminion_reinit(first_proc, chip, &tv_now);\n\t\tminion_reenable_cores(first_proc, chip);\n\t\tminion_refill_queue(chip_thr);\n\t}\n\t\n\tminion_config_pll(spi, chip);\n\t\n\ttimer_set_delay(&chip_thr->tv_poll, &tv_now, minion_poll_us);\n}\n\nstatic\nstruct api_data *minion_get_api_extra_device_status(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tstruct api_data *root = NULL;\n\tdouble d;\n\t\n\td = minion_pllcfg_to_freq(chip->pllcfg_asserted);\n\tif (d > 0)\n\t\troot = api_add_freq(root, \"Frequency\", &d, true);\n\t\n\treturn root;\n}\n\nstatic\nconst char *minion_set_clock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\t\n\tconst int nv = atoi(newvalue);\n\tif (nv < minion_min_clock || nv > minion_max_clock)\n\t{\n\t\tsprintf(replybuf, \"Clock frequency must be within range of %u-%u MHz\", minion_min_clock, minion_max_clock);\n\t\treturn replybuf;\n\t}\n\t\n\tconst uint32_t pllcfg = minion_freq_to_pllcfg(nv);\n\tchip->pllcfg_desired = pllcfg;\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition minion_set_device_funcs[] = {\n\t{\"clock\", minion_set_clock, \"clock frequency\"},\n\t{NULL},\n};\n\n#ifdef HAVE_CURSES\nstatic\nvoid minion_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *minion_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\tchar buf[0x100];\n\t\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tsprintf(buf, \"Set clock speed (range %d-%d)\", minion_min_clock, minion_max_clock);\n\t\t\tconst int nv = curses_int(buf);\n\t\t\tif (nv < minion_min_clock || nv > minion_max_clock)\n\t\t\t\treturn \"Invalid clock speed\\n\";\n\t\t\t\n\t\t\tconst uint32_t pllcfg = minion_freq_to_pllcfg(nv);\n\t\t\tchip->pllcfg_desired = pllcfg;\n\t\t\t\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\t\n\treturn NULL;\n}\n\nstatic\nvoid minion_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct minion_chip * const chip = thr->cgpu_data;\n\t\n\tconst unsigned freq = minion_pllcfg_to_freq(chip->pllcfg_asserted);\n\tif (freq)\n\t\twlogprint(\"Clock speed: %u\\n\", freq);\n}\n#endif\n\nBFG_REGISTER_DRIVER(minion_drv)\n\nstatic\nbool minion_detect_one(const char * const devpath)\n{\n\tspi_init();\n\t\n\tstruct spi_port *spi = malloc(sizeof(*spi));\n\t// Be careful, read lowl-spi.h comments for warnings\n\tmemset(spi, 0, sizeof(*spi));\n\tspi->speed = 50000000;\n\tspi->mode = SPI_MODE_0;\n\tspi->bits = 8;\n\tspi->txrx = linux_spi_txrx2;\n\tif (spi_open(spi, devpath) < 0)\n\t{\n\t\tfree(spi);\n\t\tapplogr(false, LOG_ERR, \"%s: Failed to open %s\", minion_drv.dname, devpath);\n\t}\n\t\n\tspi->repr = minion_drv.dname;\n\tspi->logprio = LOG_WARNING;\n\tconst unsigned total_core_count = minion_count_cores(spi);\n\t\n\tif (!total_core_count)\n\t{\n\t\tfree(spi);\n\t\tapplogr(false, LOG_WARNING, \"%s: Zero chips detected on %s\", minion_drv.dname, devpath);\n\t}\n\t\n\tstruct minion_bus * const mbus = malloc(sizeof(*mbus));\n\t*mbus = (struct minion_bus){\n\t\t.spi = spi,\n\t};\n\t\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &minion_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.device_data = mbus,\n\t\t.set_device_funcs = minion_set_device_funcs,\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = total_core_count,\n\t\t.threads = 1,\n\t};\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nint minion_detect_auto(void)\n{\n\treturn minion_detect_one(\"/dev/spidev0.0\") ? 1 : 0;\n}\n\nstatic\nvoid minion_detect(void)\n{\n\tgeneric_detect(&minion_drv, minion_detect_one, minion_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\nstruct device_drv minion_drv = {\n\t.dname = \"minion\",\n\t.name = \"MNN\",\n\t.drv_detect = minion_detect,\n\t\n\t.thread_init = minion_init,\n\t.minerloop = minerloop_queue,\n\t\n\t.thread_disable = minion_core_disable,\n\t.thread_enable = minion_core_enable,\n\t\n\t.queue_append = minion_queue_append,\n\t.queue_flush = minion_queue_flush,\n\t.poll = minion_poll,\n\t\n\t.get_api_extra_device_status = minion_get_api_extra_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = minion_wlogprint_status,\n\t.proc_tui_wlogprint_choices = minion_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = minion_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-modminer.c",
          "type": "blob",
          "size": 24.40234375,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2012 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"binloader.h\"\n#include \"compat.h\"\n#include \"dynclock.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"util.h\"\n\n#define BITSTREAM_FILENAME \"fpgaminer_x6500-overclocker-0402.bit\"\n#define BISTREAM_USER_ID \"\\2\\4$B\"\n\n#define MODMINER_MAX_CLOCK 250\n#define MODMINER_DEF_CLOCK 190\n#define MODMINER_MIN_CLOCK   2\n\n// Commands\n#define MODMINER_PING \"\\x00\"\n#define MODMINER_GET_VERSION \"\\x01\"\n#define MODMINER_FPGA_COUNT \"\\x02\"\n// Commands + require FPGAid\n#define MODMINER_GET_IDCODE '\\x03'\n#define MODMINER_GET_USERCODE '\\x04'\n#define MODMINER_PROGRAM '\\x05'\n#define MODMINER_SET_CLOCK '\\x06'\n#define MODMINER_READ_CLOCK '\\x07'\n#define MODMINER_SEND_WORK '\\x08'\n#define MODMINER_CHECK_WORK '\\x09'\n// One byte temperature reply\n#define MODMINER_TEMP1 '\\x0a'\n\n#define FPGAID_ALL 4\n\nBFG_REGISTER_DRIVER(modminer_drv)\n\nstruct modminer_fpga_state {\n\tbool work_running;\n\tstruct work running_work;\n\tstruct work last_work;\n\tstruct timeval tv_workstart;\n\tuint32_t hashes;\n\n\tchar next_work_cmd[46];\n\n\tstruct dclk_data dclk;\n\tuint8_t freqMaxMaxM;\n\t// Number of nonces didn't meet pdiff 1, ever\n\tint bad_share_counter;\n\t// Number of nonces did meet pdiff 1, ever\n\tint good_share_counter;\n\t// Time the clock was last reduced due to temperature\n\tstruct timeval tv_last_cutoff_reduced;\n\n\tunsigned char temp;\n\n\tunsigned char pdone;\n};\n\nstatic inline bool _bailout(int fd, struct cgpu_info*modminer, int prio, const char *fmt, ...) FORMAT_SYNTAX_CHECK(printf, 4, 5);\n\nstatic inline bool\n_bailout(int fd, struct cgpu_info*modminer, int prio, const char *fmt, ...)\n{\n\tif (fd != -1)\n\t\tserial_close(fd);\n\tif (modminer) {\n\t\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\t\tmodminer->device->device_fd = -1;\n\t\tmutex_unlock(mutexp);\n\t}\n\n\tva_list ap;\n\tchar buf[LOGBUFSIZ];\n\t\n\tva_start(ap, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\t_applog(prio, buf);\n\treturn false;\n}\n#define bailout(...)  return _bailout(fd, NULL, __VA_ARGS__);\n\n// 45 noops sent when detecting, in case the device was left in \"start job\" reading\nstatic const char NOOP[] = MODMINER_PING \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\";\n\nstatic\nbool modminer_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"ModMiner\");\n}\n\nstatic bool\nmodminer_detect_one(const char *devpath)\n{\n\tint fd = serial_open(devpath, 0, 10, true);\n\tif (unlikely(fd == -1))\n\t\tbailout(LOG_DEBUG, \"ModMiner detect: failed to open %s\", devpath);\n\n\tchar buf[0x100];\n\tssize_t len;\n\n\t// Sending a \"ping\" first, to workaround bug in new firmware betas (see issue #62)\n\t// Sending 45 noops, just in case the device was left in \"start job\" reading\n\t(void)(write(fd, NOOP, sizeof(NOOP)) ?:0);\n\twhile (serial_read(fd, buf, sizeof(buf)) > 0)\n\t\t;\n\n\tif (1 != write(fd, MODMINER_GET_VERSION, 1))\n\t\tbailout(LOG_DEBUG, \"ModMiner detect: write failed on %s (get version)\", devpath);\n\tlen = serial_read(fd, buf, sizeof(buf)-1);\n\tif (len < 1)\n\t\tbailout(LOG_DEBUG, \"ModMiner detect: no response to version request from %s\", devpath);\n\tbuf[len] = '\\0';\n\tif (strncasecmp(buf, \"ModMiner\", 8))\n\t\tbailout(LOG_DEBUG, \"%s: %s: response did not begin with 'ModMiner'\", __func__, devpath);\n\tapplog(LOG_DEBUG, \"ModMiner identified as: %s\", buf);\n\n\tif (serial_claim_v(devpath, &modminer_drv))\n\t{\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\t\n\tchar*devname = strdup(buf);\n\tif (1 != write(fd, MODMINER_FPGA_COUNT, 1))\n\t\tbailout(LOG_DEBUG, \"ModMiner detect: write failed on %s (get FPGA count)\", devpath);\n\tlen = read(fd, buf, 1);\n\tif (len < 1)\n\t\tbailout(LOG_ERR, \"ModMiner detect: timeout waiting for FPGA count from %s\", devpath);\n\tif (!buf[0])\n\t\tbailout(LOG_ERR, \"ModMiner detect: zero FPGAs reported on %s\", devpath);\n\tapplog(LOG_DEBUG, \"ModMiner %s has %u FPGAs\", devname, buf[0]);\n\n\tserial_close(fd);\n\n\tstruct cgpu_info *modminer;\n\tmodminer = calloc(1, sizeof(*modminer));\n\tmodminer->drv = &modminer_drv;\n\tmutex_init(&modminer->device_mutex);\n\tmodminer->device_path = strdup(devpath);\n\tmodminer->device_fd = -1;\n\tmodminer->deven = DEV_ENABLED;\n\tmodminer->procs = buf[0];\n\tmodminer->threads = buf[0];\n\tmodminer->name = devname;\n\tmodminer->cutofftemp = 85;\n\n\treturn add_cgpu(modminer);\n}\n\n#undef bailout\n\nstatic\nbool modminer_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, modminer_detect_one);\n}\n\n#define bailout(...)  return _bailout(-1, modminer, __VA_ARGS__);\n#define bailout2(...)  return _bailout(fd, modminer, __VA_ARGS__);\n#define bailout3(...)  _bailout(fd, modminer, __VA_ARGS__);\n\nstatic bool\nmodminer_reopen(struct cgpu_info*modminer)\n{\n\tserial_close(modminer->device->device_fd);\n\tint fd = serial_open(modminer->device_path, 0, 10, true);\n\tif (unlikely(-1 == fd)) {\n\t\tapplog(LOG_ERR, \"%s: Failed to reopen %s\", modminer->dev_repr, modminer->device_path);\n\t\treturn false;\n\t}\n\tmodminer->device->device_fd = fd;\n\treturn true;\n}\n#define safebailout() do {  \\\n\tbool _safebailoutrv;  \\\n\tstate->work_running = false;  \\\n\t_safebailoutrv = modminer_reopen(modminer);  \\\n\tmutex_unlock(mutexp);  \\\n\treturn _safebailoutrv ? 0 : -1;  \\\n} while(0)\n\n#define check_magic(L)  do {  \\\n\tif (1 != fread(buf, 1, 1, f))  \\\n\t\tbailout(LOG_ERR, \"Error reading ModMiner bitstream ('%c')\", L);  \\\n\tif (buf[0] != L)  \\\n\t\tbailout(LOG_ERR, \"ModMiner bitstream has wrong magic ('%c')\", L);  \\\n} while(0)\n\n#define read_str(eng)  do {  \\\n\tif (1 != fread(buf, 2, 1, f))  \\\n\t\tbailout(LOG_ERR, \"Error reading ModMiner bitstream (\" eng \" len)\");  \\\n\tlen = (ubuf[0] << 8) | ubuf[1];  \\\n\tif (len >= sizeof(buf))  \\\n\t\tbailout(LOG_ERR, \"ModMiner bitstream \" eng \" too long\");  \\\n\tif (1 != fread(buf, len, 1, f))  \\\n\t\tbailout(LOG_ERR, \"Error reading ModMiner bitstream (\" eng \")\");  \\\n\tbuf[len] = '\\0';  \\\n} while(0)\n\n#define status_read(eng)  do {  \\\nFD_ZERO(&fds); \\\nFD_SET(fd, &fds);  \\\nselect(fd+1, &fds, NULL, NULL, NULL);  \\\n\tif (1 != read(fd, buf, 1))  \\\n\t\tbailout2(LOG_ERR, \"%s: Error programming %s (\" eng \")\", modminer->dev_repr, modminer->device_path);  \\\n\tif (buf[0] != 1)  \\\n\t\tbailout2(LOG_ERR, \"%s: Wrong \" eng \" programming %s\", modminer->dev_repr, modminer->device_path);  \\\n} while(0)\n\nstatic bool\nmodminer_fpga_upload_bitstream(struct cgpu_info*modminer)\n{\n\tstruct modminer_fpga_state *state = modminer->thr[0]->cgpu_data;\n\tfd_set fds;\n\tchar buf[0x100];\n\tunsigned long len, flen;\n\tchar fpgaid = FPGAID_ALL;\n\tFILE *f = open_xilinx_bitstream(modminer->drv->dname, modminer->dev_repr, BITSTREAM_FILENAME, &len);\n\tif (!f)\n\t\treturn false;\n\n\tflen = len;\n\tint fd = modminer->device->device_fd;\n\n\tapplog(LOG_WARNING, \"%s: Programming %s... DO NOT EXIT UNTIL COMPLETE\", modminer->dev_repr, modminer->device_path);\n\tbuf[0] = MODMINER_PROGRAM;\n\tbuf[1] = fpgaid;\n\tbuf[2] = (len >>  0) & 0xff;\n\tbuf[3] = (len >>  8) & 0xff;\n\tbuf[4] = (len >> 16) & 0xff;\n\tbuf[5] = (len >> 24) & 0xff;\n\tif (6 != write(fd, buf, 6))\n\t\tbailout2(LOG_ERR, \"%s: Error programming %s (cmd)\", modminer->dev_repr, modminer->device_path);\n\tstatus_read(\"cmd reply\");\n\tssize_t buflen;\n\tchar nextstatus = 10;\n\twhile (len) {\n\t\tbuflen = len < 32 ? len : 32;\n\t\tif (fread(buf, buflen, 1, f) != 1)\n\t\t\tbailout2(LOG_ERR, \"%s: File underrun programming %s (%lu bytes left)\", modminer->dev_repr, modminer->device_path, len);\n\t\tif (write(fd, buf, buflen) != buflen)\n\t\t\tbailout2(LOG_ERR, \"%s: Error programming %s (data)\", modminer->dev_repr,  modminer->device_path);\n\t\tstate->pdone = 100 - ((len * 100) / flen);\n\t\tif (state->pdone >= nextstatus)\n\t\t{\n\t\t\tnextstatus += 10;\n\t\t\tapplog(LOG_WARNING, \"%s: Programming %s... %d%% complete...\", modminer->dev_repr, modminer->device_path, state->pdone);\n\t\t}\n\t\tstatus_read(\"status\");\n\t\tlen -= buflen;\n\t}\n\tstatus_read(\"final status\");\n\tapplog(LOG_WARNING, \"%s: Done programming %s\", modminer->dev_repr, modminer->device_path);\n\n\treturn true;\n}\n\nstatic bool\nmodminer_device_prepare(struct cgpu_info *modminer)\n{\n\tint fd = serial_open(modminer->device_path, 0, 10, true);\n\tif (unlikely(-1 == fd))\n\t\tbailout(LOG_ERR, \"%s: Failed to open %s\", modminer->dev_repr, modminer->device_path);\n\n\tmodminer->device->device_fd = fd;\n\tapplog(LOG_INFO, \"%s: Opened %s\", modminer->dev_repr, modminer->device_path);\n\n\treturn true;\n}\n\n#undef bailout\n\nstatic bool\nmodminer_fpga_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\tstruct cgpu_info *modminer = proc->device;\n\n\t// Don't need to lock the mutex here, since prepare runs from the main thread before the miner threads start\n\tif (modminer->device->device_fd == -1 && !modminer_device_prepare(modminer))\n\t\treturn false;\n\n\tstruct modminer_fpga_state *state;\n\tstate = thr->cgpu_data = calloc(1, sizeof(struct modminer_fpga_state));\n\tdclk_prepare(&state->dclk);\n\tstate->dclk.freqMinM = MODMINER_MIN_CLOCK / 2;\n\tstate->next_work_cmd[0] = MODMINER_SEND_WORK;\n\tstate->next_work_cmd[1] = proc->proc_id;  // FPGA id\n\t\n\tproc->status = LIFE_INIT2;\n\n\treturn true;\n}\n\nstatic bool\nmodminer_change_clock(struct thr_info*thr, bool needlock, signed char delta)\n{\n\tstruct cgpu_info*modminer = thr->cgpu;\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tchar fpgaid = modminer->proc_id;\n\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\tint fd;\n\tunsigned char cmd[6], buf[1];\n\tunsigned char clk;\n\n\tclk = (state->dclk.freqM * 2) + delta;\n\n\tcmd[0] = MODMINER_SET_CLOCK;\n\tcmd[1] = fpgaid;\n\tcmd[2] = clk;\n\tcmd[3] = cmd[4] = cmd[5] = '\\0';\n\n\tif (needlock)\n\t\tmutex_lock(mutexp);\n\tfd = modminer->device->device_fd;\n\tif (6 != write(fd, cmd, 6))\n\t\tbailout2(LOG_ERR, \"%s: Error writing (set frequency)\", modminer->proc_repr);\n\tif (serial_read(fd, &buf, 1) != 1)\n\t\tbailout2(LOG_ERR, \"%s: Error reading (set frequency)\", modminer->proc_repr);\n\tif (needlock)\n\t\tmutex_unlock(mutexp);\n\n\tif (buf[0])\n\t\tstate->dclk.freqM = clk / 2;\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool modminer_dclk_change_clock(struct thr_info*thr, int multiplier)\n{\n\tstruct cgpu_info *modminer = thr->cgpu;\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tuint8_t oldFreq = state->dclk.freqM;\n\tsigned char delta = (multiplier - oldFreq) * 2;\n\tif (unlikely(!modminer_change_clock(thr, true, delta)))\n\t\treturn false;\n\n\tdclk_msg_freqchange(modminer->proc_repr, oldFreq * 2, state->dclk.freqM * 2, NULL);\n\treturn true;\n}\n\nstatic bool\nmodminer_reduce_clock(struct thr_info*thr, bool needlock)\n{\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\n\tif (state->dclk.freqM <= MODMINER_MIN_CLOCK / 2)\n\t\treturn false;\n\n\treturn modminer_change_clock(thr, needlock, -2);\n}\n\nstatic bool _modminer_get_nonce(struct cgpu_info*modminer, char fpgaid, uint32_t*nonce)\n{\n\tint fd = modminer->device->device_fd;\n\tchar cmd[2] = {MODMINER_CHECK_WORK, fpgaid};\n\t\n\tif (write(fd, cmd, 2) != 2) {\n\t\tapplog(LOG_ERR, \"%s: Error writing (get nonce)\", modminer->proc_repr);\n\t\treturn false;\n\t}\n\tif (4 != serial_read(fd, nonce, 4)) {\n\t\tapplog(LOG_ERR, \"%s: Short read (get nonce)\", modminer->proc_repr);\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nstatic bool\nmodminer_fpga_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *modminer = thr->cgpu;\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tint fd;\n\tchar fpgaid = modminer->proc_id;\n\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\tuint32_t nonce;\n\n\tunsigned char cmd[2], buf[4];\n\n\tmutex_lock(mutexp);\n\tfd = modminer->device->device_fd;\n\tif (fd == -1) {\n\t\t// Died in another thread...\n\t\tmutex_unlock(mutexp);\n\t\treturn false;\n\t}\n\n\tcmd[0] = MODMINER_GET_USERCODE;\n\tcmd[1] = fpgaid;\n\tif (write(fd, cmd, 2) != 2)\n\t\tbailout2(LOG_ERR, \"%s: Error writing (read USER code)\", modminer->proc_repr);\n\tif (serial_read(fd, buf, 4) != 4)\n\t\tbailout2(LOG_ERR, \"%s: Error reading (read USER code)\", modminer->proc_repr);\n\n\tif (memcmp(buf, BISTREAM_USER_ID, 4)) {\n\t\tapplog(LOG_ERR, \"%s: FPGA not programmed\", modminer->proc_repr);\n\t\tif (!modminer_fpga_upload_bitstream(modminer))\n\t\t\treturn false;\n\t} else if (opt_force_dev_init && !((struct modminer_fpga_state *)modminer->device->thr[0]->cgpu_data)->pdone) {\n\t\tapplog(LOG_DEBUG, \"%s: FPGA is already programmed, but --force-dev-init is set\",\n\t\t       modminer->proc_repr);\n\t\tif (!modminer_fpga_upload_bitstream(modminer))\n\t\t\treturn false;\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"%s: FPGA is already programmed :)\", modminer->proc_repr);\n\tstate->pdone = 101;\n\n\tstate->dclk.freqM = MODMINER_MAX_CLOCK / 2 + 1;  // Will be reduced immediately\n\twhile (1) {\n\t\tif (state->dclk.freqM <= MODMINER_MIN_CLOCK / 2)\n\t\t\tbailout2(LOG_ERR, \"%s: Hit minimum trying to find acceptable frequencies\", modminer->proc_repr);\n\t\t--state->dclk.freqM;\n\t\tif (!modminer_change_clock(thr, false, 0))\n\t\t\t// MCU rejected assignment\n\t\t\tcontinue;\n\t\tif (!_modminer_get_nonce(modminer, fpgaid, &nonce))\n\t\t\tbailout2(LOG_ERR, \"%s: Error detecting acceptable frequencies\", modminer->proc_repr);\n\t\tif (!memcmp(&nonce, \"\\x00\\xff\\xff\\xff\", 4))\n\t\t\t// MCU took assignment, but disabled FPGA\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tstate->freqMaxMaxM =\n\tstate->dclk.freqMaxM = state->dclk.freqM;\n\tif (MODMINER_DEF_CLOCK / 2 < state->dclk.freqM) {\n\t\tif (!modminer_change_clock(thr, false, -(state->dclk.freqM * 2 - MODMINER_DEF_CLOCK)))\n\t\t\tapplog(LOG_WARNING, \"%s: Failed to set desired initial frequency of %u\", modminer->proc_repr, MODMINER_DEF_CLOCK);\n\t}\n\tstate->dclk.freqMDefault = state->dclk.freqM;\n\tapplog(LOG_WARNING, \"%s: Frequency set to %u MHz (range: %u-%u)\", modminer->proc_repr, state->dclk.freqM * 2, MODMINER_MIN_CLOCK, state->dclk.freqMaxM * 2);\n\n\tmutex_unlock(mutexp);\n\n\tthr->primary_thread = true;\n\n\treturn true;\n}\n\nstatic\nbool get_modminer_upload_percent(char *buf, size_t bufsz, struct cgpu_info *modminer, __maybe_unused bool per_processor)\n{\n\tchar pdone = ((struct modminer_fpga_state*)(modminer->device->thr[0]->cgpu_data))->pdone;\n\tif (pdone != 101) {\n\t\ttailsprintf(buf, bufsz, \"%3d%% \", pdone);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void modminer_get_temperature(struct cgpu_info *modminer, struct thr_info *thr)\n{\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\n#ifdef WIN32\n\t/* Workaround for bug in Windows driver */\n\tif (!modminer_reopen(modminer))\n\t\treturn;\n#endif\n\n\tint fd = modminer->device->device_fd;\n\tint fpgaid = modminer->proc_id;\n\tchar cmd[2] = {MODMINER_TEMP1, fpgaid};\n\tchar temperature;\n\n\tif (2 == write(fd, cmd, 2) && read(fd, &temperature, 1) == 1)\n\t{\n\t\tstate->temp = temperature;\n\t\tif (temperature > modminer->targettemp + opt_hysteresis) {\n\t\t\t{\n\t\t\t\tstruct timeval now;\n\t\t\t\tcgtime(&now);\n\t\t\t\tif (timer_elapsed(&state->tv_last_cutoff_reduced, &now)) {\n\t\t\t\t\tstate->tv_last_cutoff_reduced = now;\n\t\t\t\t\tint oldFreq = state->dclk.freqM;\n\t\t\t\t\tif (modminer_reduce_clock(thr, false))\n\t\t\t\t\t\tapplog(LOG_NOTICE, \"%s: Frequency %s from %u to %u MHz (temp: %d)\",\n\t\t\t\t\t\t       modminer->proc_repr,\n\t\t\t\t\t\t       (oldFreq > state->dclk.freqM ? \"dropped\" : \"raised \"),\n\t\t\t\t\t\t       oldFreq * 2, state->dclk.freqM * 2,\n\t\t\t\t\t\t       temperature\n\t\t\t\t\t\t);\n\t\t\t\t\tstate->dclk.freqMaxM = state->dclk.freqM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif (state->dclk.freqMaxM < state->freqMaxMaxM && temperature < modminer->targettemp) {\n\t\t\tif (temperature < modminer->targettemp - opt_hysteresis) {\n\t\t\t\tstate->dclk.freqMaxM = state->freqMaxMaxM;\n\t\t\t} else {\n\t\t\t\t++state->dclk.freqMaxM;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool modminer_get_stats(struct cgpu_info *modminer)\n{\n\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\tint hottest = 0;\n\tbool get_temp = (modminer->deven != DEV_ENABLED);\n\t// Getting temperature more efficiently while enabled\n\tfor (int i = modminer->threads; i--; ) {\n\t\tstruct thr_info*thr = modminer->thr[i];\n\t\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\t\tif (get_temp)\n\t\t{\n\t\t\tmutex_lock(mutexp);\n\t\t\tmodminer_get_temperature(modminer, thr);\n\t\t\tmutex_unlock(mutexp);\n\t\t}\n\t\tint temp = state->temp;\n\t\tif (temp > hottest)\n\t\t\thottest = temp;\n\t}\n\n\tmodminer->temp = (float)hottest;\n\n\treturn true;\n}\n\nstatic struct api_data*\nget_modminer_drv_extra_device_status(struct cgpu_info*modminer)\n{\n\tstruct api_data*root = NULL;\n\tstruct thr_info*thr = modminer->thr[0];\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tdouble d;\n\n\td = (double)state->dclk.freqM * 2;\n\troot = api_add_freq(root, \"Frequency\", &d, true);\n\td = (double)state->dclk.freqMaxM * 2;\n\troot = api_add_freq(root, \"Cool Max Frequency\", &d, true);\n\td = (double)state->freqMaxMaxM * 2;\n\troot = api_add_freq(root, \"Max Frequency\", &d, true);\n\troot = api_add_int(root, \"Hardware Errors\", &state->bad_share_counter, true);\n\troot = api_add_int(root, \"Valid Nonces\", &state->good_share_counter, true);\n\n\treturn root;\n}\n\nstatic bool\nmodminer_prepare_next_work(struct modminer_fpga_state*state, struct work*work)\n{\n\tchar *midstate = state->next_work_cmd + 2;\n\tchar *taildata = midstate + 32;\n\tif (!(memcmp(midstate, work->midstate, 32) || memcmp(taildata, work->data + 64, 12)))\n\t\treturn false;\n\tmemcpy(midstate, work->midstate, 32);\n\tmemcpy(taildata, work->data + 64, 12);\n\treturn true;\n}\n\nstatic bool\nmodminer_start_work(struct thr_info*thr)\n{\nfd_set fds;\n\tstruct cgpu_info*modminer = thr->cgpu;\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\tint fd;\n\n\tchar buf[1];\n\n\tmutex_lock(mutexp);\n\tfd = modminer->device->device_fd;\n\n\tif (unlikely(fd == -1)) {\n\t\tif (!modminer_reopen(modminer)) {\n\t\t\tmutex_unlock(mutexp);\n\t\t\treturn false;\n\t\t}\n\t\tfd = modminer->device->device_fd;\n\t}\n\n\tif (46 != write(fd, state->next_work_cmd, 46))\n\t\tbailout2(LOG_ERR, \"%s: Error writing (start work)\", modminer->proc_repr);\n\ttimer_set_now(&state->tv_workstart);\n\tstate->hashes = 0;\n\tstatus_read(\"start work\");\n\tmutex_unlock(mutexp);\n\tif (opt_debug) {\n\t\tchar xdata[161];\n\t\tbin2hex(xdata, state->running_work.data, 80);\n\t\tapplog(LOG_DEBUG, \"%s: Started work: %s\",\n\t\t       modminer->proc_repr, xdata);\n\t}\n\n\treturn true;\n}\n\n#define work_restart(thr)  thr->work_restart\n\n#define NONCE_CHARS(nonce)  \\\n\t(int)((unsigned char*)&nonce)[3],  \\\n\t(int)((unsigned char*)&nonce)[2],  \\\n\t(int)((unsigned char*)&nonce)[1],  \\\n\t(int)((unsigned char*)&nonce)[0]\n\nstatic int64_t\nmodminer_process_results(struct thr_info*thr)\n{\n\tstruct cgpu_info*modminer = thr->cgpu;\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tchar fpgaid = modminer->proc_id;\n\tpthread_mutex_t *mutexp = &modminer->device->device_mutex;\n\tstruct work *work = &state->running_work;\n\n\tuint32_t nonce;\n\tlong iter;\n\tint immediate_bad_nonces = 0, immediate_nonces = 0;\n\tbool bad;\n\n\tmutex_lock(mutexp);\n\tmodminer_get_temperature(modminer, thr);\n\n\titer = 200;\n\twhile (1) {\n\t\tif (!_modminer_get_nonce(modminer, fpgaid, &nonce))\n\t\t\tsafebailout();\n\t\tmutex_unlock(mutexp);\n\t\tif (memcmp(&nonce, \"\\xff\\xff\\xff\\xff\", 4)) {\n\t\t\tnonce = le32toh(nonce);\n\t\t\tbad = !test_nonce(work, nonce, false);\n\t\t\t++immediate_nonces;\n\t\t\tif (!bad)\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Nonce for current  work: %02x%02x%02x%02x\",\n\t\t\t\t       modminer->proc_repr,\n\t\t\t\t       NONCE_CHARS(nonce));\n\t\t\telse\n\t\t\tif (test_nonce(&state->last_work, nonce, false))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Nonce for previous work: %02x%02x%02x%02x\",\n\t\t\t\t       modminer->proc_repr,\n\t\t\t\t       NONCE_CHARS(nonce));\n\t\t\t\twork = &state->last_work;\n\t\t\t\tbad = false;\n\t\t\t}\n\t\t\tif (!bad)\n\t\t\t{\n\t\t\t\t++state->good_share_counter;\n\t\t\t\tsubmit_nonce(thr, work, nonce);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinc_hw_errors(thr, work, nonce);\n\t\t\t\t++state->bad_share_counter;\n\t\t\t\t++immediate_bad_nonces;\n\t\t\t}\n\t\t}\n\t\tif (work_restart(thr) || !--iter)\n\t\t\tbreak;\n\t\tcgsleep_ms(1);\n\t\tif (work_restart(thr))\n\t\t\tbreak;\n\t\tmutex_lock(mutexp);\n\t}\n\n\tstruct timeval tv_workend, elapsed;\n\ttimer_set_now(&tv_workend);\n\ttimersub(&tv_workend, &state->tv_workstart, &elapsed);\n\n\tuint64_t hashes = (uint64_t)state->dclk.freqM * 2 * (((uint64_t)elapsed.tv_sec * 1000000) + elapsed.tv_usec);\n\tif (hashes > 0xffffffff)\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Finished work before new one sent\", modminer->proc_repr);\n\t\thashes = 0xffffffff;\n\t}\n\tif (hashes <= state->hashes)\n\t\thashes = 1;\n\telse\n\t\thashes -= state->hashes;\n\tstate->hashes += hashes;\n\n\tdclk_gotNonces(&state->dclk);\n\tif (immediate_bad_nonces)\n\t\tdclk_errorCount(&state->dclk, ((double)immediate_bad_nonces) / (double)immediate_nonces);\n\tdclk_preUpdate(&state->dclk);\n\tif (!dclk_updateFreq(&state->dclk, modminer_dclk_change_clock, thr))\n\t\treturn -1;\n\n\treturn hashes;\n}\n\nstatic int64_t\nmodminer_scanhash(struct thr_info*thr, struct work*work, int64_t __maybe_unused max_nonce)\n{\n\tstruct modminer_fpga_state *state = thr->cgpu_data;\n\tint64_t hashes = 0;\n\tbool startwork;\n\n\tstartwork = modminer_prepare_next_work(state, work);\n\tif (startwork) {\n\t\t/* HACK: For some reason, this is delayed a bit\n\t\t *       Let last_work handle the end of the work,\n\t\t *       and start the next one immediately\n\t\t */\n\t}\n\telse\n\tif (state->work_running) {\n\t\thashes = modminer_process_results(thr);\n\t\tif (work_restart(thr)) {\n\t\t\tstate->work_running = false;\n\t\t\treturn hashes;\n\t\t}\n\t} else\n\t\tstate->work_running = true;\n\n\tif (startwork) {\n\t\t__copy_work(&state->last_work, &state->running_work);\n\t\t__copy_work(&state->running_work, work);\n\t\tif (!modminer_start_work(thr))\n\t\t\treturn -1;\n\t}\n\n\t// This is intentionally early\n\twork->blk.nonce += hashes;\n\treturn hashes;\n}\n\nstatic void\nmodminer_fpga_shutdown(struct thr_info *thr)\n{\n\tfor (struct cgpu_info *proc = thr->cgpu->device; proc; proc = proc->next_proc)\n\t\tproc->status = LIFE_DEAD2;\n\tfree(thr->cgpu_data);\n\tthr->cgpu_data = NULL;\n}\n\nstatic\nbool modminer_user_set_clock(struct cgpu_info *cgpu, const int val)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct modminer_fpga_state * const state = thr->cgpu_data;\n\tconst int multiplier = val / 2;\n\tconst uint8_t oldFreqM = state->dclk.freqM;\n\tconst signed char delta = (multiplier - oldFreqM) * 2;\n\tstate->dclk.freqMDefault = multiplier;\n\tconst bool rv = modminer_change_clock(thr, true, delta);\n\tif (likely(rv))\n\t\tdclk_msg_freqchange(cgpu->proc_repr, oldFreqM * 2, state->dclk.freqM * 2, \" on user request\");\n\treturn rv;\n}\n\nstatic char *modminer_set_device(struct cgpu_info *modminer, char *option, char *setting, char *replybuf)\n{\n\tint val;\n\n\tif (strcasecmp(option, \"help\") == 0) {\n\t\tsprintf(replybuf, \"clock: range %d-%d and a multiple of 2\",\n\t\t\t\t\tMODMINER_MIN_CLOCK, MODMINER_MAX_CLOCK);\n\t\treturn replybuf;\n\t}\n\n\tif (strcasecmp(option, \"clock\") == 0) {\n\t\tif (!setting || !*setting) {\n\t\t\tsprintf(replybuf, \"missing clock setting\");\n\t\t\treturn replybuf;\n\t\t}\n\n\t\tval = atoi(setting);\n\t\tif (val < MODMINER_MIN_CLOCK || val > MODMINER_MAX_CLOCK || (val & 1) != 0) {\n\t\t\tsprintf(replybuf, \"invalid clock: '%s' valid range %d-%d and a multiple of 2\",\n\t\t\t\t\t\tsetting, MODMINER_MIN_CLOCK, MODMINER_MAX_CLOCK);\n\t\t\treturn replybuf;\n\t\t}\n\n\t\tif (unlikely(!modminer_user_set_clock(modminer, val)))\n\t\t{\n\t\t\tsprintf(replybuf, \"Set clock failed: %s\",\n\t\t\t        modminer->proc_repr);\n\t\t\treturn replybuf;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tsprintf(replybuf, \"Unknown option: %s\", option);\n\treturn replybuf;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid modminer_tui_wlogprint_choices(struct cgpu_info *cgpu)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *modminer_tui_handle_choice(struct cgpu_info *cgpu, int input)\n{\n\tstatic char buf[0x100];  // Static for replies\n\t\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tint val;\n\t\t\tchar *intvar;\n\t\t\t\n\t\t\tsprintf(buf, \"Set clock speed (range %d-%d, multiple of 2)\", MODMINER_MIN_CLOCK, MODMINER_MAX_CLOCK);\n\t\t\tintvar = curses_input(buf);\n\t\t\tif (!intvar)\n\t\t\t\treturn \"Invalid clock speed\\n\";\n\t\t\tval = atoi(intvar);\n\t\t\tfree(intvar);\n\t\t\tif (val < MODMINER_MIN_CLOCK || val > MODMINER_MAX_CLOCK || (val & 1) != 0)\n\t\t\t\treturn \"Invalid clock speed\\n\";\n\t\t\t\n\t\t\tif (unlikely(!modminer_user_set_clock(cgpu, val)))\n\t\t\t\treturn \"Set clock failed\\n\";\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid modminer_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct modminer_fpga_state *state = cgpu->thr[0]->cgpu_data;\n\twlogprint(\"Clock speed: %d\\n\", (int)(state->dclk.freqM * 2));\n}\n#endif\n\nstruct device_drv modminer_drv = {\n\t.dname = \"modminer\",\n\t.name = \"MMQ\",\n\t.lowl_match = modminer_lowl_match,\n\t.lowl_probe = modminer_lowl_probe,\n\t.override_statline_temp2 = get_modminer_upload_percent,\n\t.get_stats = modminer_get_stats,\n\t.get_api_extra_device_status = get_modminer_drv_extra_device_status,\n\t.set_device = modminer_set_device,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = modminer_wlogprint_status,\n\t.proc_tui_wlogprint_choices = modminer_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = modminer_tui_handle_choice,\n#endif\n\t.thread_prepare = modminer_fpga_prepare,\n\t.thread_init = modminer_fpga_init,\n\t.scanhash = modminer_scanhash,\n\t.thread_shutdown = modminer_fpga_shutdown,\n};\n"
        },
        {
          "name": "driver-nanofury.c",
          "type": "blob",
          "size": 15.2783203125,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n * Copyright 2013-2014 Vladimir Strinski\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"deviceapi.h\"\n#include \"driver-bitfury.h\"\n#include \"libbitfury.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"mcp2210.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#define NANOFURY_USB_PRODUCT \"NanoFury\"\n\n#define NANOFURY_GP_PIN_LED 0\n#define NANOFURY_GP_PIN_SCK_OVR 5\n#define NANOFURY_GP_PIN_PWR_EN 6\n#define NANOFURY_GP_PIN_PWR_EN0 7\n\n#define NANOFURY_MAX_BYTES_PER_SPI_TRANSFER 60\t\t\t// due to MCP2210 limitation\n\nBFG_REGISTER_DRIVER(nanofury_drv)\nstatic const struct bfg_set_device_definition nanofury_set_device_funcs[];\n\nstruct nanofury_state {\n\tstruct lowlevel_device_info *lowl_info;\n\tstruct mcp2210_device *mcp;\n\tstruct timeval identify_started;\n\tbool identify_requested;\n\tunsigned long current_baud;\n\tbool ledalternating;\n\tbool ledvalue;\n\tbool powered_off;\n};\n\n// Bit-banging reset, to reset more chips in chain - toggle for longer period... Each 3 reset cycles reset first chip in chain\nstatic\nbool nanofury_spi_reset(struct mcp2210_device * const mcp)\n{\n\tint r;\n\tchar tx[1] = {0x81};  // will send this waveform: - _ _ _  _ _ _ -\n\tchar buf[1];\n\t\n\t// SCK_OVRRIDE\n\tif (!mcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_SCK_OVR, BGV_HIGH))\n\t\treturn false;\n\t\n\tfor (r = 0; r < 16; ++r)\n\t\tif (!mcp2210_spi_transfer(mcp, tx, buf, 1))\n\t\t\treturn false;\n\t\n\tif (mcp2210_get_gpio_input(mcp, NANOFURY_GP_PIN_SCK_OVR) == BGV_ERROR)\n\t\treturn false;\n\t\n\treturn true;\n}\n\nstatic void nanofury_device_off(struct mcp2210_device *, struct nanofury_state *);\n\nstatic\nbool nanofury_spi_txrx(struct spi_port * const port)\n{\n\tstruct cgpu_info * const cgpu = port->cgpu;\n\tstruct nanofury_state * const state = port->userp;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\tconst void *wrbuf = spi_gettxbuf(port);\n\tvoid *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\tconst uint8_t *ptrwrbuf = wrbuf;\n\tuint8_t *ptrrdbuf = rdbuf;\n\t\n\tif (state->current_baud != port->speed)\n\t{\n\t\tapplog(LOG_NOTICE, \"%\"PRIpreprv\": Changing baud from %lu to %lu\",\n\t\t       cgpu ? cgpu->proc_repr : nanofury_drv.dname,\n\t\t       (unsigned long)state->current_baud, (unsigned long)port->speed);\n\t\tif (!mcp2210_configure_spi(mcp, port->speed, 0xffff, 0xffef, 0, 0, 0))\n\t\t\tgoto err;\n\t\tstate->current_baud = port->speed;\n\t}\n\t\n\tnanofury_spi_reset(mcp);\n\t\n\t// start by sending chunks of 60 bytes...\n\twhile (bufsz >= NANOFURY_MAX_BYTES_PER_SPI_TRANSFER)\n\t{\n\t\tif (!mcp2210_spi_transfer(mcp, ptrwrbuf, ptrrdbuf, NANOFURY_MAX_BYTES_PER_SPI_TRANSFER))\n\t\t\tgoto err;\n\t\tptrrdbuf += NANOFURY_MAX_BYTES_PER_SPI_TRANSFER;\n\t\tptrwrbuf += NANOFURY_MAX_BYTES_PER_SPI_TRANSFER;\n\t\tbufsz -= NANOFURY_MAX_BYTES_PER_SPI_TRANSFER;\n\t}\n\t\n\t// send any remaining bytes...\n\tif (bufsz > 0)\n\t{\n\t\tif (!mcp2210_spi_transfer(mcp, ptrwrbuf, ptrrdbuf, bufsz))\n\t\t\tgoto err;\n\t}\n\t\n\treturn true;\n\nerr:\n\tmcp2210_spi_cancel(mcp);\n\tnanofury_device_off(mcp, state);\n\tif (cgpu)\n\t{\n\t\tstruct thr_info * const thr = cgpu->thr[0];\n\t\thashes_done2(thr, -1, NULL);\n\t}\n\treturn false;\n}\n\nstatic\nvoid nanofury_send_led_gpio(struct nanofury_state * const state)\n{\n\tstruct mcp2210_device * const mcp = state->mcp;\n\tmcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_LED, state->ledvalue ? BGV_HIGH : BGV_LOW);\n}\n\nstatic\nvoid nanofury_do_led_alternating(struct nanofury_state * const state)\n{\n\tstate->ledvalue = !state->ledvalue;\n\tnanofury_send_led_gpio(state);\n}\n\nstatic\nvoid nanofury_device_off(struct mcp2210_device * const mcp, struct nanofury_state * const state)\n{\n\t// Try to reset everything back to input\n\tfor (int i = 0; i < 9; ++i)\n\t\tmcp2210_get_gpio_input(mcp, i);\n\tif (state)\n\t\tstate->powered_off = true;\n}\n\nstatic\nbool nanofury_power_enable(struct mcp2210_device * const mcp, const bool poweron, struct nanofury_state * const state)\n{\n\tif (!mcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_PWR_EN, poweron ? BGV_HIGH : BGV_LOW))\n\t\treturn false;\n\t\n\tif (!mcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_PWR_EN0, poweron ? BGV_LOW : BGV_HIGH))\n\t\treturn false;\n\t\n\tif (state)\n\t\tstate->powered_off = !poweron;\n\t\n\treturn true;\n}\n\nstatic\nbool nanofury_checkport(struct mcp2210_device * const mcp, const unsigned long baud, struct nanofury_state * const state)\n{\n\tint i;\n\tconst char tmp = 0;\n\tchar tmprx;\n\t\n\t// default: set everything to input\n\tfor (i = 0; i < 9; ++i)\n\t\tif (BGV_ERROR == mcp2210_get_gpio_input(mcp, i))\n\t\t\tgoto fail;\n\t\n\t// configure the pins that we need:\n\t\n\t// LED\n\tif (!mcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_LED, BGV_HIGH))\n\t\tgoto fail;\n\t\n\tnanofury_power_enable(mcp, true, state);\n\t\n\t// cancel any outstanding SPI transfers\n\tmcp2210_spi_cancel(mcp);\n\t\n\t// configure SPI\n\t// This is the only place where speed, mode and other settings are configured!!!\n\tif (!mcp2210_configure_spi(mcp, baud, 0xffff, 0xffef, 0, 0, 0))\n\t\tgoto fail;\n\tif (!mcp2210_set_spimode(mcp, 0))\n\t\tgoto fail;\n\t\n\tif (!mcp2210_spi_transfer(mcp, &tmp, &tmprx, 1))\n\t\tgoto fail;\n\t\n\t// after this command SCK_OVRRIDE should read the same as current SCK value (which for mode 0 should be 0)\n\t\n\tif (mcp2210_get_gpio_input(mcp, NANOFURY_GP_PIN_SCK_OVR) != BGV_LOW)\n\t\tgoto fail;\n\t\n\t// switch SCK to polarity (default SCK=1 in mode 2)\n\tif (!mcp2210_set_spimode(mcp, 2))\n\t\tgoto fail;\n\tif (!mcp2210_spi_transfer(mcp, &tmp, &tmprx, 1))\n\t\tgoto fail;\n\t\n\t// after this command SCK_OVRRIDE should read the same as current SCK value (which for mode 2 should be 1)\n\t\n\tif (mcp2210_get_gpio_input(mcp, NANOFURY_GP_PIN_SCK_OVR) != BGV_HIGH)\n\t\tgoto fail;\n\t\n\t// switch SCK to polarity (default SCK=0 in mode 0)\n\tif (!mcp2210_set_spimode(mcp, 0))\n\t\tgoto fail;\n\tif (!mcp2210_spi_transfer(mcp, &tmp, &tmprx, 1))\n\t\tgoto fail;\n\t\n\tif (mcp2210_get_gpio_input(mcp, NANOFURY_GP_PIN_SCK_OVR) != BGV_LOW)\n\t\tgoto fail;\n\t\n\treturn true;\n\nfail:\n\tnanofury_device_off(mcp, state);\n\treturn false;\n}\n\nstatic\nbool nanofury_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_mcp2210, NANOFURY_USB_PRODUCT);\n}\n\nstatic\nbool nanofury_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tconst char * const product = info->product;\n\tconst char * const serial = info->serial;\n\tstruct mcp2210_device *mcp;\n\tstruct spi_port *port;\n\tstruct nanofury_state *state;\n\tint chips;\n\t\n\tif (info->lowl != &lowl_mcp2210)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tif (info->lowl != &lowl_hid && info->lowl != &lowl_usb)\n\t\t\tapplog(LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not mcp2210!\",\n\t\t\t       __func__, product, serial);\n\t\treturn false;\n\t}\n\t\n\tmcp = mcp2210_open(info);\n\tif (!mcp)\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but mcp2210 lowlevel driver failed to open it\",\n\t\t       __func__, product, serial);\n\t\treturn false;\n\t}\n\t\n\tstate = malloc(sizeof(*state));\n\t*state = (struct nanofury_state){\n\t\t.mcp = mcp,\n\t\t.ledvalue = true,\n\t};\n\tport = calloc(1, sizeof(*port));\n\tport->userp = state;\n\tport->txrx = nanofury_spi_txrx;\n\tport->repr = nanofury_drv.dname;\n\tport->logprio = LOG_DEBUG;\n\tport->speed = 200000;\n\t\n\t{\n\t\tstruct bitfury_device dummy_bitfury = {\n\t\t\t.spi = port,\n\t\t};\n\t\tdrv_set_defaults(&nanofury_drv, bitfury_set_device_funcs_probe, &dummy_bitfury, NULL, NULL, 1);\n\t}\n\t\n\tif (!nanofury_checkport(mcp, port->speed, NULL))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but failed to detect nanofury\",\n\t\t       __func__, product, serial);\n\t\tmcp2210_close(mcp);\n\t\treturn false;\n\t}\n\tstate->current_baud = port->speed;\n\t\n\tchips = libbitfury_detectChips1(port);\n\tfree(port);\n\t\n\tnanofury_device_off(mcp, NULL);\n\tmcp2210_close(mcp);\n\t\n\tif (lowlevel_claim(&nanofury_drv, true, info))\n\t{\n\t\tfree(state);\n\t\treturn false;\n\t}\n\t\n\tstate->lowl_info = lowlevel_ref(info);\n\t\n\tstruct cgpu_info *cgpu;\n\tcgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &nanofury_drv,\n\t\t.set_device_funcs = nanofury_set_device_funcs,\n\t\t.device_data = state,\n\t\t.threads = 1,\n\t\t.procs = chips,\n\t\t// TODO: .name\n\t\t.device_path = strdup(info->path),\n\t\t.dev_manufacturer = maybe_strdup(info->manufacturer),\n\t\t.dev_product = maybe_strdup(product),\n\t\t.dev_serial = maybe_strdup(serial),\n\t\t.deven = DEV_ENABLED,\n\t\t// TODO: .cutofftemp\n\t};\n\n\treturn add_cgpu(cgpu);\n}\n\nstatic\nbool nanofury_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct nanofury_state * const state = cgpu->device_data;\n\tstruct lowlevel_device_info * const info = state->lowl_info;\n\tstruct spi_port *port;\n\tstruct bitfury_device *bitfury;\n\tstruct mcp2210_device *mcp;\n\t\n\tmcp = mcp2210_open(info);\n\tlowlevel_devinfo_free(info);\n\tif (!mcp)\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to open mcp2210 device\", cgpu->proc_repr);\n\t\treturn false;\n\t}\n\tif (!nanofury_checkport(mcp, state->current_baud, state))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": checkport failed\", cgpu->proc_repr);\n\t\tmcp2210_close(mcp);\n\t\treturn false;\n\t}\n\t\n\tport = malloc(sizeof(*port));\n\tbitfury = malloc(sizeof(*bitfury) * cgpu->procs);\n\t\n\tif (!(port && bitfury && state))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to allocate structures\", cgpu->proc_repr);\n\t\tfree(port);\n\t\tfree(bitfury);\n\t\tfree(state);\n\t\tmcp2210_close(mcp);\n\t\treturn false;\n\t}\n\t\n\t/* Be careful, read lowl-spi.h comments for warnings */\n\tmemset(port, 0, sizeof(*port));\n\tport->txrx = nanofury_spi_txrx;\n\tport->cgpu = cgpu;\n\tport->repr = cgpu->proc_repr;\n\tport->logprio = LOG_ERR;\n\tport->speed = state->current_baud;\n\t\t\n\t\n\tconst int init_osc6_bits = 50;\n\tconst int ramp_osc6_bits = (cgpu->procs > 1) ? 5 : init_osc6_bits;\n\t\n\tstate->mcp = mcp;\n\tport->userp = state;\n\tfor (proc = cgpu; proc; (proc = proc->next_proc), ++bitfury)\n\t{\n\t\tstruct thr_info * const mythr = proc->thr[0];\n\t\t*bitfury = (struct bitfury_device){\n\t\t\t.spi = port,\n\t\t\t.fasync = proc->proc_id,\n\t\t};\n\t\tproc->device_data = bitfury;\n\t\tmythr->cgpu_data = state;\n\t\tbitfury->osc6_bits = ramp_osc6_bits;\n\t\tbitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\tbitfury_init_chip(proc);\n\t}\n\t\n\t--bitfury;\n\twhile (bitfury->osc6_bits < init_osc6_bits)\n\t{\n\t\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t\t{\n\t\t\tbitfury = proc->device_data;\n\t\t\tbitfury->osc6_bits += 5;\n\t\t\tbitfury_send_freq(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);\n\t\t}\n\t}\n\t\n\tfor (proc = cgpu; proc; proc = proc->next_proc)\n\t{\n\t\tbitfury_init_chip(proc);\n\t\tproc->status = LIFE_INIT2;\n\t}\n\t\n\tnanofury_send_led_gpio(state);\n\ttimer_set_now(&thr->tv_poll);\n\treturn true;\n}\n\nstatic\nvoid nanofury_disable(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\t\n\tbitfury_disable(thr);\n\t\n\t// Before powering off, ensure no other chip needs power\n\tfor_each_managed_proc(oproc, dev)\n\t\tif (oproc->deven == DEV_ENABLED)\n\t\t\treturn;\n\t\n\tapplog(LOG_NOTICE, \"%s: Last chip disabled, shutting off power\",\n\t       dev->dev_repr);\n\tnanofury_device_off(mcp, state);\n}\n\nstatic\nvoid nanofury_enable(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\t\n\tif (state->powered_off)\n\t{\n\t\t// All chips were disabled, so we need to power back on\n\t\tapplog(LOG_DEBUG, \"%s: Enabling power\",\n\t\t       dev->dev_repr);\n\t\tnanofury_checkport(mcp, state->current_baud, state);\n\t\tnanofury_send_led_gpio(state);\n\t}\n\t\n\tbitfury_enable(thr);\n}\n\nstatic\nvoid nanofury_reinit(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\t\n\tnanofury_device_off(mcp, state);\n\tcgsleep_ms(1);\n\tfor_each_managed_proc(oproc, dev)\n\t\tif (oproc->deven == DEV_ENABLED)\n\t\t\tnanofury_enable(oproc->thr[0]);\n}\n\nstatic\ndouble _nanofury_total_diff1(struct cgpu_info * const dev)\n{\n\tdouble d = 0.;\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t\td += proc->diff1;\n\treturn d;\n}\n\nstatic\nvoid nanofury_poll(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\tdouble diff1_before = 0.;\n\t\n\tif (state->identify_requested)\n\t{\n\t\tif (!timer_isset(&state->identify_started))\n\t\t\tmcp2210_set_gpio_output(mcp, NANOFURY_GP_PIN_LED, state->ledvalue ? BGV_LOW : BGV_HIGH);\n\t\ttimer_set_delay_from_now(&state->identify_started, 5000000);\n\t\tstate->identify_requested = false;\n\t}\n\t\n\tif (state->ledalternating && !timer_isset(&state->identify_started))\n\t\tdiff1_before = _nanofury_total_diff1(dev);\n\t\n\tbitfury_do_io(thr);\n\t\n\tif (state->ledalternating && (timer_isset(&state->identify_started) || diff1_before != _nanofury_total_diff1(dev)))\n\t\tnanofury_do_led_alternating(state);\n\t\n\tif (timer_passed(&state->identify_started, NULL))\n\t{\n\t\t// Also used when setting ledmode\n\t\tnanofury_send_led_gpio(state);\n\t\ttimer_unset(&state->identify_started);\n\t}\n}\n\nstatic\nbool nanofury_identify(struct cgpu_info * const cgpu)\n{\n\tstruct nanofury_state * const state = cgpu->thr[0]->cgpu_data;\n\tstate->identify_requested = true;\n\treturn true;\n}\n\nstatic\nvoid nanofury_shutdown(struct thr_info * const thr)\n{\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\tif (!state)\n\t\treturn;\n\tstruct mcp2210_device * const mcp = state->mcp;\n\t\n\tif (mcp)\n\t\tnanofury_device_off(mcp, state);\n}\n\nconst char *nanofury_set_ledmode(struct cgpu_info * const proc, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct nanofury_state * const state = thr->cgpu_data;\n\t\n\tif (!strcasecmp(setting, \"on\"))\n\t{\n\t\tstate->ledvalue = true;\n\t\tstate->ledalternating = false;\n\t}\n\telse\n\tif (!strcasecmp(setting, \"off\"))\n\t\tstate->ledvalue = state->ledalternating = false;\n\telse\n\tif (!strcasecmp(setting, \"alternating\"))\n\t\tstate->ledalternating = true;\n\telse\n\t\treturn \"Invalid LED mode; must be on/off/alternating\";\n\t\n\tif (!timer_isset(&state->identify_started))\n\t\ttimer_set_now(&state->identify_started);\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition nanofury_set_device_funcs[] = {\n\t{\"baud\", bitfury_set_baud, \"SPI baud rate\"},\n\t{\"osc6_bits\", bitfury_set_osc6_bits, \"range 1-\"BITFURY_MAX_OSC6_BITS_S\" (slow to fast)\"},\n\t{\"ledmode\", nanofury_set_ledmode, \"on/off/alternating\"},\n\t{NULL},\n};\n\nstruct device_drv nanofury_drv = {\n\t.dname = \"nanofury\",\n\t.name = \"NFY\",\n\t.lowl_match = nanofury_lowl_match,\n\t.lowl_probe = nanofury_lowl_probe,\n\t\n\t.thread_init = nanofury_init,\n\t.thread_disable = nanofury_disable,\n\t.thread_enable = nanofury_enable,\n\t.reinit_device = nanofury_reinit,\n\t.thread_shutdown = nanofury_shutdown,\n\t\n\t.minerloop = minerloop_async,\n\t.job_prepare = bitfury_job_prepare,\n\t.job_start = bitfury_noop_job_start,\n\t.poll = nanofury_poll,\n\t.job_process_results = bitfury_job_process_results,\n\t\n\t.get_api_extra_device_detail = bitfury_api_device_detail,\n\t.get_api_extra_device_status = bitfury_api_device_status,\n\t.identify_device = nanofury_identify,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = bitfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = bitfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = bitfury_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-opencl.c",
          "type": "blob",
          "size": 56.2744140625,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2011-2014 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifdef HAVE_CURSES\n// Must be before stdbool, since pdcurses typedefs bool :/\n#include <curses.h>\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#else\n#include <windows.h>\n#endif\n\n#include <ctype.h>\n#include <math.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n\n#ifndef WIN32\n#include <sys/resource.h>\n#endif\n\n#define OMIT_OPENCL_API\n\n#include \"compat.h\"\n#include \"miner.h\"\n#include \"deviceapi.h\"\n#include \"driver-opencl.h\"\n#include \"findnonce.h\"\n#include \"ocl.h\"\n#include \"adl.h\"\n#include \"util.h\"\n\n/* TODO: cleanup externals ********************/\n\n\n/* Platform API */\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetPlatformIDs)(cl_uint          /* num_entries */,\n                 cl_platform_id * /* platforms */,\n                 cl_uint *        /* num_platforms */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetPlatformInfo)(cl_platform_id   /* platform */,\n                  cl_platform_info /* param_name */,\n                  size_t           /* param_value_size */,\n                  void *           /* param_value */,\n                  size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Device APIs */\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetDeviceIDs)(cl_platform_id   /* platform */,\n               cl_device_type   /* device_type */,\n               cl_uint          /* num_entries */,\n               cl_device_id *   /* devices */,\n               cl_uint *        /* num_devices */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetDeviceInfo)(cl_device_id    /* device */,\n                cl_device_info  /* param_name */,\n                size_t          /* param_value_size */,\n                void *          /* param_value */,\n                size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Context APIs  */\nCL_API_ENTRY cl_context CL_API_CALL\n(*clCreateContextFromType)(const cl_context_properties * /* properties */,\n                        cl_device_type          /* device_type */,\n                        void (CL_CALLBACK *     /* pfn_notify*/ )(const char *, const void *, size_t, void *),\n                        void *                  /* user_data */,\n                        cl_int *                /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseContext)(cl_context /* context */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Command Queue APIs */\nCL_API_ENTRY cl_command_queue CL_API_CALL\n(*clCreateCommandQueue)(cl_context                     /* context */,\n                     cl_device_id                   /* device */,\n                     cl_command_queue_properties    /* properties */,\n                     cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseCommandQueue)(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Memory Object APIs */\nCL_API_ENTRY cl_mem CL_API_CALL\n(*clCreateBuffer)(cl_context   /* context */,\n               cl_mem_flags /* flags */,\n               size_t       /* size */,\n               void *       /* host_ptr */,\n               cl_int *     /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Program Object APIs  */\nCL_API_ENTRY cl_program CL_API_CALL\n(*clCreateProgramWithSource)(cl_context        /* context */,\n                          cl_uint           /* count */,\n                          const char **     /* strings */,\n                          const size_t *    /* lengths */,\n                          cl_int *          /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_program CL_API_CALL\n(*clCreateProgramWithBinary)(cl_context                     /* context */,\n                          cl_uint                        /* num_devices */,\n                          const cl_device_id *           /* device_list */,\n                          const size_t *                 /* lengths */,\n                          const unsigned char **         /* binaries */,\n                          cl_int *                       /* binary_status */,\n                          cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseProgram)(cl_program /* program */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clBuildProgram)(cl_program           /* program */,\n               cl_uint              /* num_devices */,\n               const cl_device_id * /* device_list */,\n               const char *         /* options */,\n               void (CL_CALLBACK *  /* pfn_notify */)(cl_program /* program */, void * /* user_data */),\n               void *               /* user_data */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetProgramInfo)(cl_program         /* program */,\n                 cl_program_info    /* param_name */,\n                 size_t             /* param_value_size */,\n                 void *             /* param_value */,\n                 size_t *           /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetProgramBuildInfo)(cl_program            /* program */,\n                      cl_device_id          /* device */,\n                      cl_program_build_info /* param_name */,\n                      size_t                /* param_value_size */,\n                      void *                /* param_value */,\n                      size_t *              /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Kernel Object APIs */\nCL_API_ENTRY cl_kernel CL_API_CALL\n(*clCreateKernel)(cl_program      /* program */,\n               const char *    /* kernel_name */,\n               cl_int *        /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseKernel)(cl_kernel   /* kernel */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clSetKernelArg)(cl_kernel    /* kernel */,\n               cl_uint      /* arg_index */,\n               size_t       /* arg_size */,\n               const void * /* arg_value */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Flush and Finish APIs */\nCL_API_ENTRY cl_int CL_API_CALL\n(*clFinish)(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Enqueued Commands APIs */\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueReadBuffer)(cl_command_queue    /* command_queue */,\n                    cl_mem              /* buffer */,\n                    cl_bool             /* blocking_read */,\n                    size_t              /* offset */,\n                    size_t              /* size */,\n                    void *              /* ptr */,\n                    cl_uint             /* num_events_in_wait_list */,\n                    const cl_event *    /* event_wait_list */,\n                    cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueWriteBuffer)(cl_command_queue   /* command_queue */,\n                     cl_mem             /* buffer */,\n                     cl_bool            /* blocking_write */,\n                     size_t             /* offset */,\n                     size_t             /* size */,\n                     const void *       /* ptr */,\n                     cl_uint            /* num_events_in_wait_list */,\n                     const cl_event *   /* event_wait_list */,\n                     cl_event *         /* event */) CL_API_SUFFIX__VERSION_1_0;\n\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueNDRangeKernel)(cl_command_queue /* command_queue */,\n                       cl_kernel        /* kernel */,\n                       cl_uint          /* work_dim */,\n                       const size_t *   /* global_work_offset */,\n                       const size_t *   /* global_work_size */,\n                       const size_t *   /* local_work_size */,\n                       cl_uint          /* num_events_in_wait_list */,\n                       const cl_event * /* event_wait_list */,\n                       cl_event *       /* event */) CL_API_SUFFIX__VERSION_1_0;\n\n#ifdef WIN32\n#define dlsym (void*)GetProcAddress\n#define dlclose FreeLibrary\n#endif\n\n#define LOAD_OCL_SYM(sym)  do { \\\n\tif (!(sym = dlsym(cl, #sym))) {  \\\n\t\tapplog(LOG_ERR, \"Failed to load OpenCL symbol \" #sym \", no GPUs usable\");  \\\n\t\tdlclose(cl);  \\\n\t\treturn false;  \\\n\t}  \\\n} while(0)\n\nstatic bool\nload_opencl_symbols() {\n#if defined(__APPLE__)\n\tvoid *cl = dlopen(\"/System/Library/Frameworks/OpenCL.framework/Versions/Current/OpenCL\", RTLD_LAZY);\n#elif !defined(WIN32)\n\tvoid *cl = dlopen(\"libOpenCL.so\", RTLD_LAZY);\n#else\n\tHMODULE cl = LoadLibrary(\"OpenCL.dll\");\n#endif\n\tif (!cl)\n\t{\n\t\tapplog(LOG_ERR, \"Failed to load OpenCL library, no GPUs usable\");\n\t\treturn false;\n\t}\n\t\n\tLOAD_OCL_SYM(clGetPlatformIDs);\n\tLOAD_OCL_SYM(clGetPlatformInfo);\n\tLOAD_OCL_SYM(clGetDeviceIDs);\n\tLOAD_OCL_SYM(clGetDeviceInfo);\n\tLOAD_OCL_SYM(clCreateContextFromType);\n\tLOAD_OCL_SYM(clReleaseContext);\n\tLOAD_OCL_SYM(clCreateCommandQueue);\n\tLOAD_OCL_SYM(clReleaseCommandQueue);\n\tLOAD_OCL_SYM(clCreateBuffer);\n\tLOAD_OCL_SYM(clCreateProgramWithSource);\n\tLOAD_OCL_SYM(clCreateProgramWithBinary);\n\tLOAD_OCL_SYM(clReleaseProgram);\n\tLOAD_OCL_SYM(clBuildProgram);\n\tLOAD_OCL_SYM(clGetProgramInfo);\n\tLOAD_OCL_SYM(clGetProgramBuildInfo);\n\tLOAD_OCL_SYM(clCreateKernel);\n\tLOAD_OCL_SYM(clReleaseKernel);\n\tLOAD_OCL_SYM(clSetKernelArg);\n\tLOAD_OCL_SYM(clFinish);\n\tLOAD_OCL_SYM(clEnqueueReadBuffer);\n\tLOAD_OCL_SYM(clEnqueueWriteBuffer);\n\tLOAD_OCL_SYM(clEnqueueNDRangeKernel);\n\t\n\treturn true;\n}\n\n\nstruct opencl_kernel_interface {\n\tconst char *kiname;\n\tqueue_kernel_parameters_func_t queue_kernel_parameters_func;\n};\n\n\n#ifdef HAVE_CURSES\nextern WINDOW *mainwin, *statuswin, *logwin;\nextern void enable_curses(void);\n#endif\n\nextern int mining_threads;\nextern int opt_g_threads;\nextern bool ping;\nextern bool opt_loginput;\nextern char *opt_kernel_path;\nextern int gpur_thr_id;\nextern bool opt_noadl;\nextern bool have_opencl;\nstatic _clState *clStates[MAX_GPUDEVICES];\nstatic struct opencl_kernel_interface kernel_interfaces[];\n\n\n\nextern void *miner_thread(void *userdata);\nextern int dev_from_id(int thr_id);\nextern void decay_time(double *f, double fadd);\n\n\n/**********************************************/\n\n#ifdef HAVE_ADL\nextern float gpu_temp(int gpu);\nextern int gpu_fanspeed(int gpu);\nextern int gpu_fanpercent(int gpu);\n#endif\n\n\nvoid opencl_early_init()\n{\n\tstatic struct opencl_device_data dataarray[MAX_GPUDEVICES];\n\tfor (int i = 0; i < MAX_GPUDEVICES; ++i)\n\t{\n\t\tstruct opencl_device_data * const data = &dataarray[i];\n\t\t*data = (struct opencl_device_data){\n\t\t\t.dynamic = true,\n\t\t\t.use_goffset = BTS_UNKNOWN,\n\t\t\t.intensity = intensity_not_set,\n#ifdef USE_SCRYPT\n\t\t\t.lookup_gap = 2,\n#endif\n\t\t};\n\t\tgpus[i] = (struct cgpu_info){\n\t\t\t.device_data = data,\n\t\t};\n\t}\n}\n\nstatic\nconst char *_set_list(char * const arg, const char * const emsg, bool (*set_func)(struct cgpu_info *, const char *))\n{\n\tint i, device = 0;\n\tchar *nextptr, buf[0x10];\n\n\tnextptr = strtok(arg, \",\");\n\tif (nextptr == NULL)\n\t\treturn emsg;\n\tif (!set_func(&gpus[device++], nextptr))\n\t\treturn emsg;\n\tsnprintf(buf, sizeof(buf), \"%s\", nextptr);\n\n\twhile ((nextptr = strtok(NULL, \",\")) != NULL)\n\t\tif (!set_func(&gpus[device++], nextptr))\n\t\t\treturn emsg;\n\tif (device == 1) {\n\t\tfor (i = device; i < MAX_GPUDEVICES; i++)\n\t\t\tset_func(&gpus[i], buf);\n\t}\n\n\treturn NULL;\n}\n\n#define _SET_INTERFACE(PNAME)  \\\nstatic  \\\nconst char *opencl_init_ ## PNAME (struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)  \\\n{  \\\n\tif (!_set_ ## PNAME (proc, newvalue))  \\\n\t\treturn \"Invalid value for \" #PNAME;  \\\n\treturn NULL;  \\\n}  \\\n// END OF _SET_INTERFACE\n\n#define _SET_INT_LIST2(PNAME, VCHECK, FIELD)  \\\nstatic  \\\nbool _set_ ## PNAME (struct cgpu_info * const cgpu, const char * const _val)  \\\n{  \\\n\tconst int v = atoi(_val);  \\\n\tif (!(VCHECK))  \\\n\t\treturn false;  \\\n\tFIELD = v;  \\\n\treturn true;  \\\n}  \\\n_SET_INTERFACE(PNAME)  \\\nconst char *set_ ## PNAME(char *arg)  \\\n{  \\\n\treturn _set_list(arg, \"Invalid value passed to \" #PNAME, _set_ ## PNAME);  \\\n}  \\\n// END OF _SET_INT_LIST\n\n#define _SET_INT_LIST(PNAME, VCHECK, FIELD)  \\\n\t_SET_INT_LIST2(PNAME, VCHECK, ((struct opencl_device_data *)cgpu->device_data)->FIELD)\n\n_SET_INT_LIST(vector  , (v == 1 || v == 2 || v == 4), vwidth   )\n_SET_INT_LIST(worksize, (v >= 1 && v <= 9999)       , work_size)\n\n#ifdef USE_SCRYPT\n_SET_INT_LIST(shaders           , true, shaders)\n_SET_INT_LIST(lookup_gap        , true, lookup_gap)\n_SET_INT_LIST(thread_concurrency, true, thread_concurrency)\n#endif\n\nenum cl_kernels select_kernel(const char * const arg)\n{\n\tfor (unsigned i = 1; i < (unsigned)OPENCL_KERNEL_INTERFACE_COUNT; ++i)\n\t\tif (!strcasecmp(arg, kernel_interfaces[i].kiname))\n\t\t\treturn i;\n\treturn KL_NONE;\n}\n\nconst char *opencl_get_kernel_interface_name(const enum cl_kernels kern)\n{\n\tstruct opencl_kernel_interface *ki = &kernel_interfaces[kern];\n\treturn ki->kiname;\n}\n\nstatic\nbool _set_kernel(struct cgpu_info * const cgpu, const char *_val)\n{\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\t\n\tsize_t knamelen = strlen(_val);\n\tchar filename[knamelen + 3 + 1];\n\tsprintf(filename, \"%s.cl\", _val);\n\t\n\tint dummy_srclen;\n\tenum cl_kernels interface;\n\tstruct mining_algorithm *malgo;\n\tchar *src = opencl_kernel_source(filename, &dummy_srclen, &interface, &malgo);\n\tif (!src)\n\t\treturn false;\n\tfree(src);\n\tif (!malgo)\n\t\treturn false;\n\t\n\tstruct opencl_kernel_info * const kernelinfo = &data->kernelinfo[malgo->algo];\n\tfree(kernelinfo->file);\n\tkernelinfo->file = strdup(_val);\n\t\n\treturn true;\n}\n_SET_INTERFACE(kernel)\nconst char *set_kernel(char *arg)\n{\n\treturn _set_list(arg, \"Invalid value passed to set_kernel\", _set_kernel);\n}\n\nstatic\nconst char *opencl_init_binary(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tchar *end;\n\tbool nv;\n\t\n\tnv = bfg_strtobool(newvalue, &end, 0);\n\tif (newvalue[0] && !end[0])\n\t\tdata->opt_opencl_binaries = nv ? OBU_LOADSAVE : OBU_NONE;\n\telse\n\tif (!(strcasecmp(newvalue, \"load\") && strcasecmp(newvalue, \"read\")))\n\t\tdata->opt_opencl_binaries = OBU_LOAD;\n\telse\n\tif (!(strcasecmp(newvalue, \"save\") && strcasecmp(newvalue, \"write\")))\n\t\tdata->opt_opencl_binaries = OBU_SAVE;\n\telse\n\tif (!(strcasecmp(newvalue, \"both\")))\n\t\tdata->opt_opencl_binaries = OBU_LOADSAVE;\n\telse\n\tif (!(strcasecmp(newvalue, \"default\")))\n\t\tdata->opt_opencl_binaries = OBU_DEFAULT;\n\telse\n\t\treturn \"Invalid value passed to opencl binary\";\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *opencl_init_goffset(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tchar *end;\n\tbool nv = bfg_strtobool(newvalue, &end, 0);\n\tif (newvalue[0] && !end[0])\n\t\tdata->use_goffset = nv;\n\telse\n\t\treturn \"Invalid boolean value\";\n\treturn NULL;\n}\n\n#ifdef HAVE_ADL\n/* This function allows us to map an adl device to an opencl device for when\n * simple enumeration has failed to match them. */\nstatic\nconst char *opencl_init_gpu_map(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tdata->virtual_adl = atoi(newvalue);\n\tdata->mapped = true;\n\treturn NULL;\n}\n\nchar *set_gpu_map(char *arg)\n{\n\tstruct opencl_device_data *data;\n\tint val1 = 0, val2 = 0;\n\tchar *nextptr;\n\n\tnextptr = strtok(arg, \",\");\n\tif (nextptr == NULL)\n\t\treturn \"Invalid parameters for set gpu map\";\n\tif (sscanf(arg, \"%d:%d\", &val1, &val2) != 2)\n\t\treturn \"Invalid description for map pair\";\n\tif (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)\n\t\treturn \"Invalid value passed to set_gpu_map\";\n\n\tdata = gpus[val1].device_data;\n\tdata->virtual_adl = val2;\n\tdata->mapped = true;\n\n\twhile ((nextptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (sscanf(nextptr, \"%d:%d\", &val1, &val2) != 2)\n\t\t\treturn \"Invalid description for map pair\";\n\t\tif (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)\n\t\t\treturn \"Invalid value passed to set_gpu_map\";\n\t\tdata = gpus[val1].device_data;\n\t\tdata->virtual_adl = val2;\n\t\tdata->mapped = true;\n\t}\n\n\treturn NULL;\n}\n\nstatic\nbool _set_gpu_engine(struct cgpu_info * const cgpu, const char * const _val)\n{\n\tint val1, val2;\n\tget_intrange(_val, &val1, &val2);\n\tif (val1 < 0 || val1 > 9999 || val2 < 0 || val2 > 9999 || val2 < val1)\n\t\treturn false;\n\t\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl * const ga = &data->adl;\n\t\n\tdata->min_engine = val1;\n\tdata->gpu_engine = val2;\n\tga->autoengine = (val1 != val2);\n\treturn true;\n}\n_SET_INTERFACE(gpu_engine)\nconst char *set_gpu_engine(char *arg)\n{\n\treturn _set_list(arg, \"Invalid value passed to set_gpu_engine\", _set_gpu_engine);\n}\nstatic\nconst char *opencl_set_gpu_engine(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tstruct gpu_adl * const ga = &data->adl;\n\t\n\tint val1, val2;\n\tget_intrange(newvalue, &val1, &val2);\n\tif (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100 || val2 < val1)\n\t\treturn \"Invalid value for clock\";\n\t\n\tif (val1 == val2)\n\t{\n\t\tif (set_engineclock(proc->device_id, val1))\n\t\t\treturn \"Failed to set gpu_engine\";\n\t\tga->autoengine = false;\n\t}\n\telse\n\t{\n\t\t// Ensure current clock is within range\n\t\tif (ga->lastengine < val1)\n\t\t{\n\t\t\tif (set_engineclock(proc->device_id, val1))\n\t\t\t\treturn \"Failed to set gpu_engine\";\n\t\t}\n\t\telse\n\t\tif (ga->lastengine > val2)\n\t\t\tif (set_engineclock(proc->device_id, val2))\n\t\t\t\treturn \"Failed to set gpu_engine\";\n\t\t\n\t\tdata->min_engine = val1;\n\t\tdata->gpu_engine = val2;\n\t\tga->autoengine = true;\n\t}\n\t\n\treturn NULL;\n}\n\nstatic\nbool _set_gpu_fan(struct cgpu_info * const cgpu, const char * const _val)\n{\n\tint val1, val2;\n\tget_intrange(_val, &val1, &val2);\n\tif (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100 || val2 < val1)\n\t\treturn false;\n\t\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct gpu_adl * const ga = &data->adl;\n\t\n\tdata->min_fan = val1;\n\tdata->gpu_fan = val2;\n\tga->autofan = (val1 != val2);\n\treturn true;\n}\n_SET_INTERFACE(gpu_fan)\nconst char *set_gpu_fan(char *arg)\n{\n\treturn _set_list(arg, \"Invalid value passed to set_gpu_fan\", _set_gpu_fan);\n}\nstatic\nconst char *opencl_set_gpu_fan(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tstruct gpu_adl * const ga = &data->adl;\n\t\n\tint val1, val2;\n\tget_intrange(newvalue, &val1, &val2);\n\tif (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100 || val2 < val1)\n\t\treturn \"Invalid value for fan\";\n\t\n\tif (val1 == val2)\n\t{\n\t\tif (set_fanspeed(proc->device_id, val1))\n\t\t\treturn \"Failed to set gpu_fan\";\n\t\tga->autofan = false;\n\t}\n\telse\n\t{\n\t\t// Ensure current fan is within range\n\t\tif (ga->targetfan < val1)\n\t\t{\n\t\t\tif (set_fanspeed(proc->device_id, val1))\n\t\t\t\treturn \"Failed to set gpu_fan\";\n\t\t}\n\t\telse\n\t\tif (ga->targetfan > val2)\n\t\t\tif (set_fanspeed(proc->device_id, val2))\n\t\t\t\treturn \"Failed to set gpu_fan\";\n\t\t\n\t\tdata->min_fan = val1;\n\t\tdata->gpu_fan = val2;\n\t\tga->autofan = true;\n\t}\n\t\n\treturn NULL;\n}\n\n_SET_INT_LIST(gpu_memclock , (v >=     1 && v <  9999), gpu_memclock )\nstatic\nconst char *opencl_set_gpu_memclock(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tif (set_memoryclock(proc->device_id, atoi(newvalue)))\n\t\treturn \"Failed to set gpu_memclock\";\n\treturn NULL;\n}\n\n_SET_INT_LIST(gpu_memdiff  , (v >= -9999 && v <= 9999), gpu_memdiff  )\nstatic\nconst char *opencl_set_gpu_memdiff(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\t\n\tif (!_set_gpu_memdiff(proc, newvalue))\n\t\treturn \"Invalid value for gpu_memdiff\";\n\t\n\tset_engineclock(proc->device_id, data->gpu_engine);\n\t\n\treturn NULL;\n}\n\n_SET_INT_LIST(gpu_powertune, (v >=   -99 && v <=   99), gpu_powertune)\n_SET_INT_LIST(gpu_vddc     , (v >=     0 && v <  9999), gpu_vddc     )\nstatic\nconst char *opencl_set_gpu_vddc(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tif (set_vddc(proc->device_id, atof(newvalue)))\n\t\treturn \"Failed to set gpu_vddc\";\n\treturn NULL;\n}\n\n_SET_INT_LIST(temp_overheat, (v >=     0 && v <   200), adl.overtemp )\n#endif\n\ndouble oclthreads_to_xintensity(const unsigned long oclthreads, const cl_uint max_compute_units)\n{\n\treturn (double)oclthreads / (double)max_compute_units / 64.;\n}\n\nunsigned long xintensity_to_oclthreads(const double xintensity, const cl_uint max_compute_units)\n{\n\treturn xintensity * max_compute_units * 0x40;\n}\n\nstatic int min_intensity, max_intensity;\n\n// NOTE: This can't be attribute-constructor because then it would race with the mining_algorithms list being populated\nstatic\nvoid opencl_calc_intensity_range()\n{\n\tRUNONCE();\n\t\n\tmin_intensity = INT_MAX;\n\tmax_intensity = INT_MIN;\n\tstruct mining_algorithm *malgo;\n\tLL_FOREACH(mining_algorithms, malgo)\n\t{\n\t\tconst int malgo_min_intensity = malgo->opencl_oclthreads_to_intensity(malgo->opencl_min_oclthreads);\n\t\tconst int malgo_max_intensity = malgo->opencl_oclthreads_to_intensity(malgo->opencl_max_oclthreads);\n\t\tif (malgo_min_intensity < min_intensity)\n\t\t\tmin_intensity = malgo_min_intensity;\n\t\tif (malgo_max_intensity > max_intensity)\n\t\t\tmax_intensity = malgo_max_intensity;\n\t}\n}\n\nbool opencl_set_intensity_from_str(struct cgpu_info * const cgpu, const char *_val)\n{\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tunsigned long oclthreads = 0;\n\tfloat intensity = intensity_not_set;\n\tbool dynamic = false;\n\t\n\tif (!strncasecmp(_val, \"d\", 1))\n\t{\n\t\tdynamic = true;\n\t\t++_val;\n\t}\n\t\n\tif (!strncasecmp(_val, \"x\", 1))\n\t{\n\t\tconst double v = atof(&_val[1]);\n\t\tif (v < 1 || v > 9999)\n\t\t\treturn false;\n\t\t\n\t\t// thr etc won't be initialised here, so avoid dereferencing it\n\t\tif (data->oclthreads)\n\t\t{\n\t\t\tstruct thr_info * const thr = cgpu->thr[0];\n\t\t\tconst int thr_id = thr->id;\n\t\t\t_clState * const clState = clStates[thr_id];\n\t\t\t\n\t\t\toclthreads = xintensity_to_oclthreads(v, clState->max_compute_units);\n\t\t}\n\t}\n\telse\n\t{\n\t\tchar *endptr;\n\t\tconst double v = strtod(_val, &endptr);\n\t\tif (endptr == _val)\n\t\t{\n\t\t\tif (!dynamic)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\topencl_calc_intensity_range();\n\t\t\tif (v < min_intensity || v > max_intensity)\n\t\t\t\treturn false;\n\t\t\toclthreads = 1;\n\t\t\tintensity = v;\n\t\t}\n\t}\n\t\n\t// Make actual assignments after we know the values are valid\n\tdata->dynamic = dynamic;\n\tif (data->oclthreads)\n\t{\n\t\tif (oclthreads)\n\t\t{\n\t\t\tdata->oclthreads = oclthreads;\n\t\t\tdata->intensity = intensity;\n\t\t}\n\t\tpause_dynamic_threads(cgpu->device_id);\n\t}\n\telse\n\t{\n\t\tif (unlikely(data->_init_intensity))\n\t\t\tfree(data->_init_intensity);\n\t\tdata->_init_intensity = strdup(_val);\n\t}\n\t\n\treturn true;\n}\n#define _set_intensity opencl_set_intensity_from_str\n_SET_INTERFACE(intensity)\nconst char *set_intensity(char *arg)\n{\n\treturn _set_list(arg, \"Invalid value passed to intensity\", _set_intensity);\n}\n\n_SET_INT_LIST2(gpu_threads, (v >= 1 && v <= 10), cgpu->threads)\n\nvoid write_config_opencl(FILE * const fcfg)\n{\n#ifdef HAVE_ADL\n\tif (opt_reorder)\n\t\tfprintf(fcfg, \",\\n\\\"gpu-reorder\\\" : true\");\n#endif\n}\n\n\nBFG_REGISTER_DRIVER(opencl_api)\nstatic const struct bfg_set_device_definition opencl_set_device_funcs_probe[];\nstatic const struct bfg_set_device_definition opencl_set_device_funcs[];\n\nchar *print_ndevs_and_exit(int *ndevs)\n{\n\topt_log_output = true;\n\topencl_api.drv_detect();\n\tclear_adl(*ndevs);\n\tapplog(LOG_INFO, \"%i GPU devices max detected\", *ndevs);\n\texit(*ndevs);\n}\n\n\nstruct cgpu_info gpus[MAX_GPUDEVICES]; /* Maximum number apparently possible */\n\n\n/* In dynamic mode, only the first thread of each device will be in use.\n * This potentially could start a thread that was stopped with the start-stop\n * options if one were to disable dynamic from the menu on a paused GPU */\nvoid pause_dynamic_threads(int gpu)\n{\n\tstruct cgpu_info *cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tint i;\n\n\tfor (i = 1; i < cgpu->threads; i++) {\n\t\tstruct thr_info *thr;\n\n\t\tthr = cgpu->thr[i];\n\t\tif (!thr->pause && data->dynamic) {\n\t\t\tapplog(LOG_WARNING, \"Disabling extra threads due to dynamic mode.\");\n\t\t}\n\n\t\tthr->pause = data->dynamic;\n\t\tif (!data->dynamic && cgpu->deven != DEV_DISABLED)\n\t\t\tmt_enable(thr);\n\t}\n}\n\n\nstruct device_drv opencl_api;\n\nfloat opencl_proc_get_intensity(struct cgpu_info * const proc, const char ** const iunit)\n{\n\tstruct opencl_device_data * const data = proc->device_data;\n\tstruct thr_info *thr = proc->thr[0];\n\tconst int thr_id = thr->id;\n\t_clState * const clState = clStates[thr_id];\n\tfloat intensity = data->intensity;\n\tif (intensity == intensity_not_set)\n\t{\n\t\tintensity = oclthreads_to_xintensity(data->oclthreads, clState->max_compute_units);\n\t\t*iunit = data->dynamic ? \"dx\" : \"x\";\n\t}\n\telse\n\t\t*iunit = data->dynamic ? \"d\" : \"\";\n\treturn intensity;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid opencl_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct thr_info *thr = cgpu->thr[0];\n\tint i;\n\tchar checkin[40];\n\tdouble displayed_rolling;\n\tbool mhash_base = !(cgpu->rolling < 1);\n\tchar logline[255];\n\tstrcpy(logline, \"\"); // In case it has no data\n\t\n\t{\n\t\tconst char *iunit;\n\t\tfloat intensity = opencl_proc_get_intensity(cgpu, &iunit);\n\t\ttailsprintf(logline, sizeof(logline), \"I:%s%g \",\n\t\t            iunit,\n\t\t            intensity);\n\t}\n#ifdef HAVE_ADL\n\tif (data->has_adl) {\n\t\tint engineclock = 0, memclock = 0, activity = 0, fanspeed = 0, fanpercent = 0, powertune = 0;\n\t\tfloat temp = 0, vddc = 0;\n\n\t\tif (gpu_stats(cgpu->device_id, &temp, &engineclock, &memclock, &vddc, &activity, &fanspeed, &fanpercent, &powertune)) {\n\t\t\tif (fanspeed != -1 || fanpercent != -1) {\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"F:\");\n\t\t\t\tif (fanspeed > 9999)\n\t\t\t\t\tfanspeed = 9999;\n\t\t\t\tif (fanpercent != -1)\n\t\t\t\t{\n\t\t\t\t\ttailsprintf(logline, sizeof(logline), \"%d%%\", fanpercent);\n\t\t\t\t\tif (fanspeed != -1)\n\t\t\t\t\t\ttailsprintf(logline, sizeof(logline), \"(%dRPM)\", fanspeed);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttailsprintf(logline, sizeof(logline), \"%dRPM\", fanspeed);\n\t\t\t\ttailsprintf(logline, sizeof(logline), \" \");\n\t\t\t}\n\t\t\tif (engineclock != -1)\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"E:%dMHz \", engineclock);\n\t\t\tif (memclock != -1)\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"M:%dMHz \", memclock);\n\t\t\tif (vddc != -1)\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"V:%.3fV \", vddc);\n\t\t\tif (activity != -1)\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"A:%d%% \", activity);\n\t\t\tif (powertune != -1)\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"P:%d%%\", powertune);\n\t\t}\n\t}\n#endif\n\t\n\twlogprint(\"%s\\n\", logline);\n\t\n\twlogprint(\"Last initialised: %s\\n\", cgpu->init);\n\t\n\tfor (i = 0; i < mining_threads; i++) {\n\t\tthr = get_thread(i);\n\t\tif (thr->cgpu != cgpu)\n\t\t\tcontinue;\n\t\t\n\t\tget_datestamp(checkin, sizeof(checkin), time(NULL) - timer_elapsed(&thr->last, NULL));\n\t\tdisplayed_rolling = thr->rolling;\n\t\tif (!mhash_base)\n\t\t\tdisplayed_rolling *= 1000;\n\t\tsnprintf(logline, sizeof(logline), \"Thread %d: %.1f %sh/s %s \", i, displayed_rolling, mhash_base ? \"M\" : \"K\" , cgpu->deven != DEV_DISABLED ? \"Enabled\" : \"Disabled\");\n\t\tswitch (cgpu->status) {\n\t\t\tdefault:\n\t\t\tcase LIFE_WELL:\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"ALIVE\");\n\t\t\t\tbreak;\n\t\t\tcase LIFE_SICK:\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"SICK reported in %s\", checkin);\n\t\t\t\tbreak;\n\t\t\tcase LIFE_DEAD:\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"DEAD reported in %s\", checkin);\n\t\t\t\tbreak;\n\t\t\tcase LIFE_INIT:\n\t\t\tcase LIFE_NOSTART:\n\t\t\t\ttailsprintf(logline, sizeof(logline), \"Never started\");\n\t\t\t\tbreak;\n\t\t}\n\t\tif (thr->pause)\n\t\t\ttailsprintf(logline, sizeof(logline), \" paused\");\n\t\twlogprint(\"%s\\n\", logline);\n\t}\n}\n\nstatic\nvoid opencl_tui_wlogprint_choices(struct cgpu_info *cgpu)\n{\n\twlogprint(\"[I]ntensity [R]estart GPU \");\n#ifdef HAVE_ADL\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tif (data->has_adl)\n\t\twlogprint(\"[C]hange settings \");\n#endif\n}\n\nstatic\nconst char *opencl_tui_handle_choice(struct cgpu_info *cgpu, int input)\n{\n\tswitch (input)\n\t{\n\t\tcase 'i': case 'I':\n\t\t{\n\t\t\tchar promptbuf[0x40];\n\t\t\tchar *intvar;\n\n\t\t\topencl_calc_intensity_range();\n\t\t\tsnprintf(promptbuf, sizeof(promptbuf), \"Set GPU scan intensity (d or %d -> %d)\", min_intensity, max_intensity);\n\t\t\tintvar = curses_input(promptbuf);\n\t\t\tif (!intvar)\n\t\t\t\treturn \"Invalid intensity\\n\";\n\t\t\tif (!_set_intensity(cgpu, intvar))\n\t\t\t{\n\t\t\t\tfree(intvar);\n\t\t\t\treturn \"Invalid intensity (out of range)\\n\";\n\t\t\t}\n\t\t\tfree(intvar);\n\t\t\treturn \"Intensity changed\\n\";\n\t\t}\n\t\tcase 'r': case 'R':\n\t\t\treinit_device(cgpu);\n\t\t\treturn \"Attempting to restart\\n\";\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tchar logline[256];\n\t\t\t\n\t\t\tclear_logwin();\n\t\t\tget_statline3(logline, sizeof(logline), cgpu, true, true);\n\t\t\twattron(logwin, A_BOLD);\n\t\t\twlogprint(\"%s\", logline);\n\t\t\twattroff(logwin, A_BOLD);\n\t\t\twlogprint(\"\\n\");\n\t\t\t\n\t\t\tchange_gpusettings(cgpu->device_id);\n\t\t\treturn \"\";  // Force refresh\n\t\t}\n\t}\n\treturn NULL;\n}\n\n#endif\n\n\n#define CL_SET_BLKARG(blkvar) status |= clSetKernelArg(*kernel, num++, sizeof(uint), (void *)&blk->blkvar)\n#define CL_SET_ARG(var) status |= clSetKernelArg(*kernel, num++, sizeof(var), (void *)&var)\n#define CL_SET_VARG(args, var) status |= clSetKernelArg(*kernel, num++, args * sizeof(uint), (void *)var)\n\n#ifdef USE_SHA256D\nstatic\nvoid *_opencl_work_data_dup(struct work * const work)\n{\n\tstruct opencl_work_data *p = malloc(sizeof(*p));\n\tmemcpy(p, work->device_data, sizeof(*p));\n\treturn p;\n}\n\nstatic\nvoid _opencl_work_data_free(struct work * const work)\n{\n\tfree(work->device_data);\n}\n\nstatic\nstruct opencl_work_data *_opencl_work_data(struct work * const work)\n{\n\tif (!work->device_data)\n\t{\n\t\twork->device_data = calloc(1, sizeof(struct opencl_work_data));\n\t\twork->device_data_dup_func = _opencl_work_data_dup;\n\t\twork->device_data_free_func = _opencl_work_data_free;\n\t}\n\treturn work->device_data;\n}\n\nstatic\ncl_int queue_poclbm_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, const cl_uint threads)\n{\n\tstruct opencl_work_data * const blk = _opencl_work_data(work);\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tunsigned int num = 0;\n\tcl_int status = 0;\n\n\tCL_SET_BLKARG(ctx_a);\n\tCL_SET_BLKARG(ctx_b);\n\tCL_SET_BLKARG(ctx_c);\n\tCL_SET_BLKARG(ctx_d);\n\tCL_SET_BLKARG(ctx_e);\n\tCL_SET_BLKARG(ctx_f);\n\tCL_SET_BLKARG(ctx_g);\n\tCL_SET_BLKARG(ctx_h);\n\n\tCL_SET_BLKARG(cty_b);\n\tCL_SET_BLKARG(cty_c);\n\n\t\n\tCL_SET_BLKARG(cty_f);\n\tCL_SET_BLKARG(cty_g);\n\tCL_SET_BLKARG(cty_h);\n\n\tif (!kinfo->goffset)\n\t{\n\t\tcl_uint vwidth = clState->vwidth;\n\t\tuint *nonces = alloca(sizeof(uint) * vwidth);\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < vwidth; i++)\n\t\t\tnonces[i] = work->blk.nonce + (i * threads);\n\t\tCL_SET_VARG(vwidth, nonces);\n\t}\n\n\tCL_SET_BLKARG(fW0);\n\tCL_SET_BLKARG(fW1);\n\tCL_SET_BLKARG(fW2);\n\tCL_SET_BLKARG(fW3);\n\tCL_SET_BLKARG(fW15);\n\tCL_SET_BLKARG(fW01r);\n\n\tCL_SET_BLKARG(D1A);\n\tCL_SET_BLKARG(C1addK5);\n\tCL_SET_BLKARG(B1addK6);\n\tCL_SET_BLKARG(W16addK16);\n\tCL_SET_BLKARG(W17addK17);\n\tCL_SET_BLKARG(PreVal4addT1);\n\tCL_SET_BLKARG(PreVal0);\n\n\tCL_SET_ARG(clState->outputBuffer);\n\n\treturn status;\n}\n\nstatic\ncl_int queue_phatk_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, __maybe_unused const cl_uint threads)\n{\n\tstruct opencl_work_data * const blk = _opencl_work_data(work);\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tcl_uint vwidth = clState->vwidth;\n\tunsigned int i, num = 0;\n\tcl_int status = 0;\n\tuint *nonces;\n\n\tCL_SET_BLKARG(ctx_a);\n\tCL_SET_BLKARG(ctx_b);\n\tCL_SET_BLKARG(ctx_c);\n\tCL_SET_BLKARG(ctx_d);\n\tCL_SET_BLKARG(ctx_e);\n\tCL_SET_BLKARG(ctx_f);\n\tCL_SET_BLKARG(ctx_g);\n\tCL_SET_BLKARG(ctx_h);\n\n\tCL_SET_BLKARG(cty_b);\n\tCL_SET_BLKARG(cty_c);\n\tCL_SET_BLKARG(cty_d);\n\tCL_SET_BLKARG(cty_f);\n\tCL_SET_BLKARG(cty_g);\n\tCL_SET_BLKARG(cty_h);\n\n\tnonces = alloca(sizeof(uint) * vwidth);\n\tfor (i = 0; i < vwidth; i++)\n\t\tnonces[i] = work->blk.nonce + i;\n\tCL_SET_VARG(vwidth, nonces);\n\n\tCL_SET_BLKARG(W16);\n\tCL_SET_BLKARG(W17);\n\tCL_SET_BLKARG(PreVal4_2);\n\tCL_SET_BLKARG(PreVal0);\n\tCL_SET_BLKARG(PreW18);\n\tCL_SET_BLKARG(PreW19);\n\tCL_SET_BLKARG(PreW31);\n\tCL_SET_BLKARG(PreW32);\n\n\tCL_SET_ARG(clState->outputBuffer);\n\n\treturn status;\n}\n\nstatic\ncl_int queue_diakgcn_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, __maybe_unused const cl_uint threads)\n{\n\tstruct opencl_work_data * const blk = _opencl_work_data(work);\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tunsigned int num = 0;\n\tcl_int status = 0;\n\n\tif (!kinfo->goffset) {\n\t\tcl_uint vwidth = clState->vwidth;\n\t\tuint *nonces = alloca(sizeof(uint) * vwidth);\n\t\tunsigned int i;\n\t\tfor (i = 0; i < vwidth; i++)\n\t\t\tnonces[i] = work->blk.nonce + i;\n\t\tCL_SET_VARG(vwidth, nonces);\n\t}\n\n\tCL_SET_BLKARG(PreVal0);\n\tCL_SET_BLKARG(PreVal4_2);\n\tCL_SET_BLKARG(cty_h);\n\tCL_SET_BLKARG(D1A);\n\tCL_SET_BLKARG(cty_b);\n\tCL_SET_BLKARG(cty_c);\n\tCL_SET_BLKARG(cty_f);\n\tCL_SET_BLKARG(cty_g);\n\tCL_SET_BLKARG(C1addK5);\n\tCL_SET_BLKARG(B1addK6);\n\tCL_SET_BLKARG(PreVal0addK7);\n\tCL_SET_BLKARG(W16addK16);\n\tCL_SET_BLKARG(W17addK17);\n\tCL_SET_BLKARG(PreW18);\n\tCL_SET_BLKARG(PreW19);\n\tCL_SET_BLKARG(W16);\n\tCL_SET_BLKARG(W17);\n\tCL_SET_BLKARG(PreW31);\n\tCL_SET_BLKARG(PreW32);\n\n\tCL_SET_BLKARG(ctx_a);\n\tCL_SET_BLKARG(ctx_b);\n\tCL_SET_BLKARG(ctx_c);\n\tCL_SET_BLKARG(ctx_d);\n\tCL_SET_BLKARG(ctx_e);\n\tCL_SET_BLKARG(ctx_f);\n\tCL_SET_BLKARG(ctx_g);\n\tCL_SET_BLKARG(ctx_h);\n\n\tCL_SET_BLKARG(zeroA);\n\tCL_SET_BLKARG(zeroB);\n\n\tCL_SET_BLKARG(oneA);\n\tCL_SET_BLKARG(twoA);\n\tCL_SET_BLKARG(threeA);\n\tCL_SET_BLKARG(fourA);\n\tCL_SET_BLKARG(fiveA);\n\tCL_SET_BLKARG(sixA);\n\tCL_SET_BLKARG(sevenA);\n\n\tCL_SET_ARG(clState->outputBuffer);\n\n\treturn status;\n}\n\nstatic\ncl_int queue_diablo_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, const cl_uint threads)\n{\n\tstruct opencl_work_data * const blk = _opencl_work_data(work);\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tunsigned int num = 0;\n\tcl_int status = 0;\n\n\tif (!kinfo->goffset) {\n\t\tcl_uint vwidth = clState->vwidth;\n\t\tuint *nonces = alloca(sizeof(uint) * vwidth);\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < vwidth; i++)\n\t\t\tnonces[i] = work->blk.nonce + (i * threads);\n\t\tCL_SET_VARG(vwidth, nonces);\n\t}\n\n\n\tCL_SET_BLKARG(PreVal0);\n\tCL_SET_BLKARG(PreVal0addK7);\n\tCL_SET_BLKARG(PreVal4addT1);\n\tCL_SET_BLKARG(PreW18);\n\tCL_SET_BLKARG(PreW19);\n\tCL_SET_BLKARG(W16);\n\tCL_SET_BLKARG(W17);\n\tCL_SET_BLKARG(W16addK16);\n\tCL_SET_BLKARG(W17addK17);\n\tCL_SET_BLKARG(PreW31);\n\tCL_SET_BLKARG(PreW32);\n\n\tCL_SET_BLKARG(D1A);\n\tCL_SET_BLKARG(cty_b);\n\tCL_SET_BLKARG(cty_c);\n\tCL_SET_BLKARG(cty_h);\n\tCL_SET_BLKARG(cty_f);\n\tCL_SET_BLKARG(cty_g);\n\n\tCL_SET_BLKARG(C1addK5);\n\tCL_SET_BLKARG(B1addK6);\n\n\tCL_SET_BLKARG(ctx_a);\n\tCL_SET_BLKARG(ctx_b);\n\tCL_SET_BLKARG(ctx_c);\n\tCL_SET_BLKARG(ctx_d);\n\tCL_SET_BLKARG(ctx_e);\n\tCL_SET_BLKARG(ctx_f);\n\tCL_SET_BLKARG(ctx_g);\n\tCL_SET_BLKARG(ctx_h);\n\n\tCL_SET_ARG(clState->outputBuffer);\n\n\treturn status;\n}\n#endif\n\n#ifdef USE_SCRYPT\nstatic\ncl_int queue_scrypt_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, __maybe_unused const cl_uint threads)\n{\n\tunsigned char *midstate = work->midstate;\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tunsigned int num = 0;\n\tcl_uint le_target;\n\tcl_int status = 0;\n\t\n\tif (!kinfo->goffset)\n\t{\n\t\tcl_uint nonce_base = work->blk.nonce;\n\t\tCL_SET_ARG(nonce_base);\n\t}\n\n\tle_target = *(cl_uint *)(work->target + 28);\n\tclState->cldata = work->data;\n\tstatus = clEnqueueWriteBuffer(clState->commandQueue, clState->CLbuffer0, true, 0, 80, clState->cldata, 0, NULL,NULL);\n\n\tCL_SET_ARG(clState->CLbuffer0);\n\tCL_SET_ARG(clState->outputBuffer);\n\tCL_SET_ARG(clState->padbuffer8);\n\tCL_SET_VARG(4, &midstate[0]);\n\tCL_SET_VARG(4, &midstate[16]);\n\tCL_SET_ARG(le_target);\n\n\treturn status;\n}\n#endif\n\n#ifdef USE_OPENCL_FULLHEADER\nstatic\ncl_int queue_fullheader_kernel(const struct opencl_kernel_info * const kinfo, _clState * const clState, struct work * const work, __maybe_unused const cl_uint threads)\n{\n\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tunsigned int num = 0;\n\tcl_int status = 0;\n\tuint8_t blkheader[80];\n\t\n\twork->nonce_diff = malgo->opencl_min_nonce_diff;\n\t\n\tif (!kinfo->goffset)\n\t{\n\t\tcl_uint nonce_base = work->blk.nonce;\n\t\tCL_SET_ARG(nonce_base);\n\t}\n\t\n\tswap32yes(blkheader, work->data, 80/4);\n\tstatus = clEnqueueWriteBuffer(clState->commandQueue, clState->CLbuffer0, CL_TRUE, 0, sizeof(blkheader), blkheader, 0, NULL, NULL);\n\t\n\tCL_SET_ARG(clState->CLbuffer0);\n\tCL_SET_ARG(clState->outputBuffer);\n\t\n\treturn status;\n}\n#endif\n\n\nstatic\nstruct opencl_kernel_interface kernel_interfaces[] = {\n\t{NULL},\n#ifdef USE_SHA256D\n\t{\"poclbm\",  queue_poclbm_kernel },\n\t{\"phatk\",   queue_phatk_kernel  },\n\t{\"diakgcn\", queue_diakgcn_kernel},\n\t{\"diablo\",  queue_diablo_kernel },\n#endif\n#ifdef USE_OPENCL_FULLHEADER\n\t{\"fullheader\", queue_fullheader_kernel },\n#endif\n#ifdef USE_SCRYPT\n\t{\"scrypt\",  queue_scrypt_kernel },\n#endif\n};\n\n\n/* We have only one thread that ever re-initialises GPUs, thus if any GPU\n * init command fails due to a completely wedged GPU, the thread will never\n * return, unable to harm other GPUs. If it does return, it means we only had\n * a soft failure and then the reinit_gpu thread is ready to tackle another\n * GPU */\nvoid *reinit_gpu(void *userdata)\n{\n\tstruct thr_info *mythr = userdata;\n\tstruct cgpu_info *cgpu, *sel_cgpu;\n\tstruct thr_info *thr;\n\tchar name[256];\n\tint thr_id;\n\tint i;\n\n\tpthread_detach(pthread_self());\n\tRenameThread(\"reinit_gpu\");\n\nselect_cgpu:\n\tsel_cgpu =\n\tcgpu = tq_pop(mythr->q);\n\tif (!cgpu)\n\t\tgoto out;\n\t\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\n\tif (clDevicesNum() != nDevs) {\n\t\tapplog(LOG_WARNING, \"Hardware not reporting same number of active devices, will not attempt to restart GPU\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < cgpu->threads; ++i)\n\t{\n\t\tthr = cgpu->thr[i];\n\t\tthr_id = thr->id;\n\n\t\tthr->rolling = thr->cgpu->rolling = 0;\n\t\t/* Reports the last time we tried to revive a sick GPU */\n\t\tcgtime(&thr->sick);\n\t\tif (!pthread_cancel(thr->pth)) {\n\t\t\tapplog(LOG_WARNING, \"Thread %d still exists, killing it off\", thr_id);\n\t\t} else\n\t\t\tapplog(LOG_WARNING, \"Thread %d no longer exists\", thr_id);\n\t}\n\n\tfor (i = 0; i < cgpu->threads; ++i)\n\t{\n\t\tint virtual_gpu;\n\n\t\tthr = cgpu->thr[i];\n\t\tthr_id = thr->id;\n\n\t\tvirtual_gpu = data->virtual_gpu;\n\t\t/* Lose this ram cause we may get stuck here! */\n\t\t//tq_freeze(thr->q);\n\n\t\tthr->q = tq_new();\n\t\tif (!thr->q)\n\t\t\tquithere(1, \"Failed to tq_new\");\n\n\t\t/* Lose this ram cause we may dereference in the dying thread! */\n\t\t//free(clState);\n\n\t\tapplog(LOG_INFO, \"Reinit GPU thread %d\", thr_id);\n\t\tclStates[thr_id] = opencl_create_clState(virtual_gpu, name, sizeof(name));\n\t\tif (!clStates[thr_id]) {\n\t\t\tapplog(LOG_ERR, \"Failed to reinit GPU thread %d\", thr_id);\n\t\t\tgoto select_cgpu;\n\t\t}\n\t\tapplog(LOG_INFO, \"initCl() finished. Found %s\", name);\n\n\t\tif (unlikely(thr_info_create(thr, NULL, miner_thread, thr))) {\n\t\t\tapplog(LOG_ERR, \"thread %d create failed\", thr_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tapplog(LOG_WARNING, \"Thread %d restarted\", thr_id);\n\t}\n\n\tget_now_datestamp(sel_cgpu->init, sizeof(sel_cgpu->init));\n\n\tproc_enable(cgpu);\n\n\tgoto select_cgpu;\nout:\n\treturn NULL;\n}\n\nstruct device_drv opencl_api;\n\nstatic int opencl_autodetect()\n{\n\tRUNONCE(0);\n\t\n#ifndef WIN32\n\tif (!getenv(\"DISPLAY\")) {\n\t\tapplog(LOG_DEBUG, \"DISPLAY not set, setting :0 just in case\");\n\t\tsetenv(\"DISPLAY\", \":0\", 1);\n\t}\n#endif\n\n\tif (!load_opencl_symbols()) {\n\t\tnDevs = 0;\n\t\treturn 0;\n\t}\n\n\n\tint i;\n\n\tnDevs = clDevicesNum();\n\tif (nDevs < 0) {\n\t\tapplog(LOG_ERR, \"clDevicesNum returned error, no GPUs usable\");\n\t\tnDevs = 0;\n\t}\n\n\tif (!nDevs)\n\t\treturn 0;\n\n\tif (opt_g_threads == -1) {\n\t\t// NOTE: This should ideally default to 2 for non-scrypt\n\t\topt_g_threads = 1;\n\t}\n\n#ifdef HAVE_SENSORS\n\tconst sensors_chip_name *cn;\n\tint c = 0;\n\t\n\tsensors_init(NULL);\n\tsensors_chip_name cnm;\n\tif (sensors_parse_chip_name(\"radeon-*\", &cnm))\n\t\tc = -1;\n#endif\n\n\tfor (i = 0; i < nDevs; ++i) {\n\t\tstruct cgpu_info *cgpu;\n\n\t\tcgpu = &gpus[i];\n\t\tstruct opencl_device_data * const data = cgpu->device_data;\n\t\t\n\t\tcgpu->deven = DEV_ENABLED;\n\t\tcgpu->drv = &opencl_api;\n\t\tcgpu->device_id = i;\n\t\tif (cgpu->threads == 0)\n\t\t\tcgpu->threads = opt_g_threads;\n\t\tdata->virtual_gpu = i;\n\t\t\n#ifdef HAVE_SENSORS\n\t\tcn = (c == -1) ? NULL : sensors_get_detected_chips(&cnm, &c);\n\t\tdata->sensor = cn;\n#endif\n\t\t\n\t\tcgpu->set_device_funcs = opencl_set_device_funcs_probe;\n\t\tcgpu_set_defaults(cgpu);\n\t\tcgpu->set_device_funcs = opencl_set_device_funcs;\n\t\t\n\t\tadd_cgpu(cgpu);\n\t}\n\n\tif (!opt_noadl)\n\t\tinit_adl(nDevs);\n\t\n\treturn nDevs;\n}\n\nstatic void opencl_detect()\n{\n\tint flags = GDF_DEFAULT_NOAUTO;\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tif (!goal->malgo->opencl_nodefault)\n\t\t\tflags &= ~GDF_DEFAULT_NOAUTO;\n\t}\n\tgeneric_detect(&opencl_api, NULL, opencl_autodetect, flags);\n}\n\nstatic void reinit_opencl_device(struct cgpu_info *gpu)\n{\n#ifdef HAVE_ADL\n\tstruct opencl_device_data * const data = gpu->device_data;\n\tif (adl_active && data->has_adl && gpu_activity(gpu->device_id) > 50)\n\t{\n\t\tapplogr(, LOG_ERR, \"%s: Still showing activity (suggests a hard hang); cancelling reinitialise.\",\n\t\t        gpu->dev_repr);\n\t}\n#endif\n\t\n\ttq_push(control_thr[gpur_thr_id].q, gpu);\n}\n\nstatic\nbool opencl_get_stats(struct cgpu_info * const gpu)\n{\n\t__maybe_unused struct opencl_device_data * const data = gpu->device_data;\n#ifdef HAVE_SENSORS\n\tif (data->sensor)\n\t{\n\t\tconst sensors_chip_name *cn = data->sensor;\n\t\tconst sensors_feature *feat;\n\t\tfor (int f = 0; (feat = sensors_get_features(cn, &f)); )\n\t\t{\n\t\t\tconst sensors_subfeature *subf;\n\t\t\tsubf = sensors_get_subfeature(cn, feat, SENSORS_SUBFEATURE_TEMP_INPUT);\n\t\t\tif (!(subf && subf->flags & SENSORS_MODE_R))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdouble val;\n\t\t\tint rc = sensors_get_value(cn, subf->number, &val);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tgpu->temp = val;\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n#ifdef HAVE_ADL\n\tif (data->has_adl) {\n\t\tint gpuid = gpu->device_id;\n\t\tgpu_temp(gpuid);\n\t\tgpu_fanspeed(gpuid);\n\t}\n#endif\n\treturn true;\n}\n\nstatic\nvoid opencl_watchdog(struct cgpu_info * const cgpu, __maybe_unused const struct timeval * const tv_now)\n{\n#ifdef HAVE_ADL\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tconst int gpu = cgpu->device_id;\n\tenum dev_enable *denable = &cgpu->deven;\n\t\n\tif (adl_active && data->has_adl)\n\t\tgpu_autotune(gpu, denable);\n\tif (opt_debug && data->has_adl) {\n\t\tint engineclock = 0, memclock = 0, activity = 0, fanspeed = 0, fanpercent = 0, powertune = 0;\n\t\tfloat temp = 0, vddc = 0;\n\n\t\tif (gpu_stats(gpu, &temp, &engineclock, &memclock, &vddc, &activity, &fanspeed, &fanpercent, &powertune))\n\t\t\tapplog(LOG_DEBUG, \"%.1f C  F: %d%%(%dRPM)  E: %dMHz  M: %dMHz  V: %.3fV  A: %d%%  P: %d%%\",\n\t\t\ttemp, fanpercent, fanspeed, engineclock, memclock, vddc, activity, powertune);\n\t}\n#endif\n}\n\nstatic struct api_data*\nget_opencl_api_extra_device_status(struct cgpu_info *gpu)\n{\n\tstruct opencl_device_data * const data = gpu->device_data;\n\tstruct thr_info * const thr = gpu->thr[0];\n\tconst int thr_id = thr->id;\n\t_clState * const clState = clStates[thr_id];\n\tstruct api_data*root = NULL;\n\n\tfloat gt, gv;\n\tint ga, gf, gp, gc, gm, pt;\n#ifdef HAVE_ADL\n\tif (!gpu_stats(gpu->device_id, &gt, &gc, &gm, &gv, &ga, &gf, &gp, &pt))\n#endif\n\t\tgt = gv = gm = gc = ga = gf = gp = pt = 0;\n\troot = api_add_int(root, \"Fan Speed\", &gf, true);\n\troot = api_add_int(root, \"Fan Percent\", &gp, true);\n\troot = api_add_int(root, \"GPU Clock\", &gc, true);\n\troot = api_add_int(root, \"Memory Clock\", &gm, true);\n\troot = api_add_volts(root, \"GPU Voltage\", &gv, true);\n\troot = api_add_int(root, \"GPU Activity\", &ga, true);\n\troot = api_add_int(root, \"Powertune\", &pt, true);\n\n\tchar intensity[20];\n\tuint32_t oclthreads;\n\tdouble intensityf = data->intensity;\n\t// FIXME: Some way to express intensities malgo-neutral?\n\tstruct mining_goal_info * const goal = get_mining_goal(\"default\");\n\tstruct mining_algorithm * const malgo = goal->malgo;\n\tif (data->intensity == intensity_not_set)\n\t{\n\t\toclthreads = data->oclthreads;\n\t\tintensityf = malgo->opencl_oclthreads_to_intensity(oclthreads);\n\t}\n\telse\n\t\toclthreads = malgo->opencl_intensity_to_oclthreads(intensityf);\n\tdouble xintensity = oclthreads_to_xintensity(oclthreads, clState->max_compute_units);\n\tif (data->dynamic)\n\t\tstrcpy(intensity, \"D\");\n\telse\n\t\tsprintf(intensity, \"%g\", intensityf);\n\troot = api_add_string(root, \"Intensity\", intensity, true);\n\troot = api_add_uint32(root, \"OCLThreads\", &oclthreads, true);\n\troot = api_add_double(root, \"CIntensity\", &intensityf, true);\n\troot = api_add_double(root, \"XIntensity\", &xintensity, true);\n\n\treturn root;\n}\n\nstruct opencl_thread_data {\n\tuint32_t *res;\n};\n\nstatic uint32_t *blank_res;\n\nstatic bool opencl_thread_prepare(struct thr_info *thr)\n{\n\tchar name[256];\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tint gpu = cgpu->device_id;\n\tint virtual_gpu = data->virtual_gpu;\n\tint i = thr->id;\n\tstatic bool failmessage = false;\n\tint buffersize = OPENCL_MAX_BUFFERSIZE;\n\n\tif (!blank_res)\n\t\tblank_res = calloc(buffersize, 1);\n\tif (!blank_res) {\n\t\tapplog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");\n\t\treturn false;\n\t}\n\n\tstrcpy(name, \"\");\n\tapplog(LOG_INFO, \"Init GPU thread %i GPU %i virtual GPU %i\", i, gpu, virtual_gpu);\n\tclStates[i] = opencl_create_clState(virtual_gpu, name, sizeof(name));\n\tif (!clStates[i]) {\n#ifdef HAVE_CURSES\n\t\tif (use_curses)\n\t\t\tenable_curses();\n#endif\n\t\tapplog(LOG_ERR, \"Failed to init GPU thread %d, disabling device %d\", i, gpu);\n\t\tif (!failmessage) {\n\t\t\tapplog(LOG_ERR, \"Restarting the GPU from the menu will not fix this.\");\n\t\t\tapplog(LOG_ERR, \"Try restarting BFGMiner.\");\n\t\t\tfailmessage = true;\n#ifdef HAVE_CURSES\n\t\t\tchar *buf;\n\t\t\tif (use_curses) {\n\t\t\t\tbuf = curses_input(\"Press enter to continue\");\n\t\t\t\tif (buf)\n\t\t\t\t\tfree(buf);\n\t\t\t}\n#endif\n\t\t}\n\t\tcgpu->deven = DEV_DISABLED;\n\t\tcgpu->status = LIFE_NOSTART;\n\n\t\tdev_error(cgpu, REASON_DEV_NOSTART);\n\n\t\treturn false;\n\t}\n\tif (!cgpu->name)\n\t\tcgpu->name = trimmed_strdup(name);\n\tapplog(LOG_INFO, \"initCl() finished. Found %s\", name);\n\tget_now_datestamp(cgpu->init, sizeof(cgpu->init));\n\n\thave_opencl = true;\n\n\treturn true;\n}\n\nstatic bool opencl_thread_init(struct thr_info *thr)\n{\n\tconst int thr_id = thr->id;\n\tstruct cgpu_info *gpu = thr->cgpu;\n\tstruct opencl_thread_data *thrdata;\n\t_clState *clState = clStates[thr_id];\n\tcl_int status = 0;\n\tthrdata = calloc(1, sizeof(*thrdata));\n\tthr->cgpu_data = thrdata;\n\tint buffersize = OPENCL_MAX_BUFFERSIZE;\n\n\tif (!thrdata) {\n\t\tapplog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");\n\t\treturn false;\n\t}\n\n\tthrdata->res = calloc(buffersize, 1);\n\n\tif (!thrdata->res) {\n\t\tfree(thrdata);\n\t\tapplog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");\n\t\treturn false;\n\t}\n\n\tstatus |= clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_TRUE, 0,\n\t\t\t\t       buffersize, blank_res, 0, NULL, NULL);\n\tif (unlikely(status != CL_SUCCESS)) {\n\t\tapplog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");\n\t\treturn false;\n\t}\n\n\tgpu->status = LIFE_WELL;\n\n\tgpu->device_last_well = time(NULL);\n\n\treturn true;\n}\n\nstatic\nfloat opencl_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\treturn malgo->opencl_min_nonce_diff ?: -1.;\n}\n\n#ifdef USE_SHA256D\nstatic bool opencl_prepare_work(struct thr_info __maybe_unused *thr, struct work *work)\n{\n\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tif (malgo->algo == POW_SHA256D)\n\t{\n\t\tstruct opencl_work_data * const blk = _opencl_work_data(work);\n\t\tprecalc_hash(blk, (uint32_t *)(work->midstate), (uint32_t *)(work->data + 64));\n\t}\n\treturn true;\n}\n#endif\n\nextern int opt_dynamic_interval;\n\nconst struct opencl_kernel_info *opencl_scanhash_get_kernel(struct cgpu_info * const cgpu, _clState * const clState, const struct mining_algorithm * const malgo)\n{\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tstruct opencl_kernel_info *kernelinfo = NULL;\n\tkernelinfo = &data->kernelinfo[malgo->algo];\n\tif (!kernelinfo->file)\n\t{\n\t\tkernelinfo->file = malgo->opencl_get_default_kernel_file(malgo, cgpu, clState);\n\t\tif (!kernelinfo->file)\n\t\t\tapplogr(NULL, LOG_ERR, \"%s: Unsupported mining algorithm\", cgpu->dev_repr);\n\t}\n\tif (!kernelinfo->loaded)\n\t{\n\t\tif (!opencl_load_kernel(cgpu, clState, cgpu->name, kernelinfo, kernelinfo->file, malgo))\n\t\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to load kernel\", cgpu->dev_repr);\n\t\t\n\t\tkernelinfo->queue_kernel_parameters = kernel_interfaces[kernelinfo->interface].queue_kernel_parameters_func;\n\t}\n\treturn kernelinfo;\n}\n\nstatic int64_t opencl_scanhash(struct thr_info *thr, struct work *work,\n\t\t\t\tint64_t __maybe_unused max_nonce)\n{\n\tconst int thr_id = thr->id;\n\tstruct opencl_thread_data *thrdata = thr->cgpu_data;\n\tstruct cgpu_info *gpu = thr->cgpu;\n\tstruct opencl_device_data * const data = gpu->device_data;\n\t_clState *clState = clStates[thr_id];\n\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tconst struct opencl_kernel_info *kinfo = opencl_scanhash_get_kernel(gpu, clState, malgo);\n\tif (!kinfo)\n\t\treturn -1;\n\tconst cl_kernel * const kernel = &kinfo->kernel;\n\tconst int dynamic_us = opt_dynamic_interval * 1000;\n\n\tcl_int status;\n\tsize_t globalThreads[1];\n\tsize_t localThreads[1] = { kinfo->wsize };\n\tint64_t hashes;\n\tint found = FOUND;\n\tint buffersize = BUFFERSIZE;\n#ifdef USE_SCRYPT\n\tif (malgo->algo == POW_SCRYPT)\n\t{\n\t\tfound = SCRYPT_FOUND;\n\t\tbuffersize = SCRYPT_BUFFERSIZE;\n\t}\n#endif\n\tif (data->intensity != intensity_not_set)\n\t\tdata->oclthreads = malgo->opencl_intensity_to_oclthreads(data->intensity);\n\n\t/* Windows' timer resolution is only 15ms so oversample 5x */\n\tif (data->dynamic && (++data->intervals * dynamic_us) > 70000) {\n\t\tstruct timeval tv_gpuend;\n\t\tdouble gpu_us;\n\n\t\tcgtime(&tv_gpuend);\n\t\tgpu_us = us_tdiff(&tv_gpuend, &data->tv_gpustart) / data->intervals;\n\t\tif (gpu_us > dynamic_us) {\n\t\t\tconst unsigned long min_oclthreads = malgo->opencl_min_oclthreads;\n\t\t\tdata->oclthreads /= 2;\n\t\t\tif (data->oclthreads < min_oclthreads)\n\t\t\t\tdata->oclthreads = min_oclthreads;\n\t\t} else if (gpu_us < dynamic_us / 2) {\n\t\t\tconst unsigned long max_oclthreads = malgo->opencl_max_oclthreads;\n\t\t\tdata->oclthreads *= 2;\n\t\t\tif (data->oclthreads > max_oclthreads)\n\t\t\t\tdata->oclthreads = max_oclthreads;\n\t\t}\n\t\tif (data->intensity != intensity_not_set)\n\t\t\tdata->intensity = malgo->opencl_oclthreads_to_intensity(data->oclthreads);\n\t\tmemcpy(&(data->tv_gpustart), &tv_gpuend, sizeof(struct timeval));\n\t\tdata->intervals = 0;\n\t}\n\n\tif (data->oclthreads < localThreads[0])\n\t\tdata->oclthreads = localThreads[0];\n\tglobalThreads[0] = data->oclthreads;\n\thashes = globalThreads[0];\n\thashes *= clState->vwidth;\n\t\n\tif (hashes > gpu->max_hashes)\n\t\tgpu->max_hashes = hashes;\n\n\tstatus = kinfo->queue_kernel_parameters(kinfo, clState, work, globalThreads[0]);\n\tif (unlikely(status != CL_SUCCESS)) {\n\t\tapplog(LOG_ERR, \"Error: clSetKernelArg of all params failed.\");\n\t\treturn -1;\n\t}\n\n\tif (kinfo->goffset)\n\t{\n\t\tsize_t global_work_offset[1];\n\n\t\tglobal_work_offset[0] = work->blk.nonce;\n\t\tstatus = clEnqueueNDRangeKernel(clState->commandQueue, *kernel, 1, global_work_offset,\n\t\t\t\t\t\tglobalThreads, localThreads, 0,  NULL, NULL);\n\t} else\n\t\tstatus = clEnqueueNDRangeKernel(clState->commandQueue, *kernel, 1, NULL,\n\t\t\t\t\t\tglobalThreads, localThreads, 0,  NULL, NULL);\n\tif (unlikely(status != CL_SUCCESS)) {\n\t\tapplog(LOG_ERR, \"Error %d: Enqueueing kernel onto command queue. (clEnqueueNDRangeKernel)\", status);\n\t\treturn -1;\n\t}\n\n\tstatus = clEnqueueReadBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,\n\t\t\t\t     buffersize, thrdata->res, 0, NULL, NULL);\n\tif (unlikely(status != CL_SUCCESS)) {\n\t\tapplog(LOG_ERR, \"Error: clEnqueueReadBuffer failed error %d. (clEnqueueReadBuffer)\", status);\n\t\treturn -1;\n\t}\n\n\t/* The amount of work scanned can fluctuate when intensity changes\n\t * and since we do this one cycle behind, we increment the work more\n\t * than enough to prevent repeating work */\n\twork->blk.nonce += gpu->max_hashes;\n\n\t/* This finish flushes the readbuffer set with CL_FALSE in clEnqueueReadBuffer */\n\tclFinish(clState->commandQueue);\n\n\t/* FOUND entry is used as a counter to say how many nonces exist */\n\tif (thrdata->res[found]) {\n\t\t/* Clear the buffer again */\n\t\tstatus = clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,\n\t\t\t\t\t      buffersize, blank_res, 0, NULL, NULL);\n\t\tif (unlikely(status != CL_SUCCESS)) {\n\t\t\tapplog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");\n\t\t\treturn -1;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"GPU %d found something?\", gpu->device_id);\n\t\tpostcalc_hash_async(thr, work, thrdata->res, kinfo->interface);\n\t\tmemset(thrdata->res, 0, buffersize);\n\t\t/* This finish flushes the writebuffer set with CL_FALSE in clEnqueueWriteBuffer */\n\t\tclFinish(clState->commandQueue);\n\t}\n\n\treturn hashes;\n}\n\nstatic\nvoid opencl_clean_kernel_info(struct opencl_kernel_info * const kinfo)\n{\n\tclReleaseKernel(kinfo->kernel);\n\tclReleaseProgram(kinfo->program);\n}\n\nstatic void opencl_thread_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tconst int thr_id = thr->id;\n\t_clState *clState = clStates[thr_id];\n\n\tfor (unsigned i = 0; i < (unsigned)POW_ALGORITHM_COUNT; ++i)\n\t{\n\t\topencl_clean_kernel_info(&data->kernelinfo[i]);\n\t}\n\tclReleaseCommandQueue(clState->commandQueue);\n\tclReleaseContext(clState->context);\n}\n\nstatic\nconst char *opencl_cannot_set(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\treturn \"Cannot set at runtime (use --set-device on commandline)\";\n}\n\nstatic const struct bfg_set_device_definition opencl_set_device_funcs_probe[] = {\n\t{\"intensity\", opencl_init_intensity},\n\t{\"kernel\", opencl_init_kernel},\n\t{\"threads\", opencl_init_gpu_threads},\n\t{\"vector\", opencl_init_vector},\n\t{\"work_size\", opencl_init_worksize},\n\t{\"binary\", opencl_init_binary},\n\t{\"goffset\", opencl_init_goffset},\n#ifdef HAVE_ADL\n\t{\"adl_mapping\", opencl_init_gpu_map},\n\t{\"clock\", opencl_init_gpu_engine},\n\t{\"fan\", opencl_init_gpu_fan},\n\t{\"memclock\", opencl_init_gpu_memclock},\n\t{\"memdiff\", opencl_init_gpu_memdiff},\n\t{\"powertune\", opencl_init_gpu_powertune},\n\t{\"temp_overheat\", opencl_init_temp_overheat},\n\t{\"voltage\", opencl_init_gpu_vddc},\n#endif\n#ifdef USE_SCRYPT\n\t{\"shaders\", opencl_init_shaders},\n\t{\"lookup_gap\", opencl_init_lookup_gap},\n\t{\"thread_concurrency\", opencl_init_thread_concurrency},\n#endif\n\t{NULL}\n};\n\nstatic const struct bfg_set_device_definition opencl_set_device_funcs[] = {\n\t{\"intensity\", opencl_init_intensity, \"Intensity of GPU scanning (d, -10 -> 31, or x1 to x9999)\"},\n\t{\"kernel\", opencl_cannot_set, \"Mining kernel code to use\"},\n\t{\"threads\", opencl_cannot_set, \"Number of threads\"},\n\t{\"vector\", opencl_cannot_set, \"\"},\n\t{\"work_size\", opencl_cannot_set, \"\"},\n\t{\"binary\", opencl_cannot_set, \"\"},\n\t{\"goffset\", opencl_cannot_set, \"\"},\n#ifdef HAVE_ADL\n\t{\"adl_mapping\", opencl_cannot_set, \"Map to ADL device\"},\n\t{\"clock\", opencl_set_gpu_engine, \"GPU engine clock\"},\n\t{\"fan\", opencl_set_gpu_fan, \"GPU fan percentage range\"},\n\t{\"memclock\", opencl_set_gpu_memclock, \"GPU memory clock\"},\n\t{\"memdiff\", opencl_set_gpu_memdiff, \"Clock speed difference between GPU and memory (auto-gpu mode only)\"},\n\t{\"powertune\", opencl_cannot_set, \"GPU powertune percentage\"},\n\t{\"temp_overheat\", opencl_init_temp_overheat, \"Overheat temperature when automatically managing fan and GPU speeds\"},\n\t{\"voltage\", opencl_set_gpu_vddc, \"GPU voltage\"},\n#endif\n#ifdef USE_SCRYPT\n\t{\"shaders\", opencl_cannot_set, \"GPU shaders per card (scrypt only)\"},\n\t{\"lookup_gap\", opencl_cannot_set, \"GPU lookup gap (scrypt only)\"},\n\t{\"thread_concurrency\", opencl_cannot_set, \"GPU thread concurrency (scrypt only)\"},\n#endif\n\t{NULL}\n};\n\nstruct device_drv opencl_api = {\n\t.dname = \"opencl\",\n\t.name = \"OCL\",\n\t.probe_priority = 110,\n\t.drv_min_nonce_diff = opencl_min_nonce_diff,\n\t.drv_detect = opencl_detect,\n\t.reinit_device = reinit_opencl_device,\n\t.watchdog = opencl_watchdog,\n\t.get_stats = opencl_get_stats,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = opencl_wlogprint_status,\n\t.proc_tui_wlogprint_choices = opencl_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = opencl_tui_handle_choice,\n#endif\n\t.get_api_extra_device_status = get_opencl_api_extra_device_status,\n\t.thread_prepare = opencl_thread_prepare,\n\t.thread_init = opencl_thread_init,\n#ifdef USE_SHA256D\n\t.prepare_work = opencl_prepare_work,\n#endif\n\t.scanhash = opencl_scanhash,\n\t.thread_shutdown = opencl_thread_shutdown,\n};\n"
        },
        {
          "name": "driver-opencl.h",
          "type": "blob",
          "size": 3.9541015625,
          "content": "#ifndef BFG_DRIVER_OPENCL\n#define BFG_DRIVER_OPENCL\n\n#include <float.h>\n#include <stdbool.h>\n\n#include \"CL/cl.h\"\n#ifdef HAVE_SENSORS\n#include <sensors/sensors.h>\n#endif\n\n#include \"miner.h\"\n\nenum opencl_binary_usage {\n\tOBU_DEFAULT  = 0,\n\tOBU_LOAD     = 1,\n\tOBU_SAVE     = 2,\n\tOBU_LOADSAVE = 3,\n\tOBU_NONE     = 4,\n};\n\nstatic const float intensity_not_set = FLT_MAX;\n\nstruct opencl_kernel_info;\nstruct _clState;\n\ntypedef cl_int (*queue_kernel_parameters_func_t)(const struct opencl_kernel_info *, struct _clState *, struct work *, cl_uint);\n\nstruct opencl_kernel_info {\n\tchar *file;\n\tbool loaded;\n\tcl_program program;\n\tcl_kernel kernel;\n\tbool goffset;\n\tenum cl_kernels interface;\n\tsize_t wsize;\n\tqueue_kernel_parameters_func_t queue_kernel_parameters;\n};\n\nstruct opencl_device_data {\n\tbool mapped;\n\tint virtual_gpu;\n\tint virtual_adl;\n\tunsigned long oclthreads;\n\tfloat intensity;\n\tchar *_init_intensity;\n\tbool dynamic;\n\t\n\tenum bfg_tristate use_goffset;\n\tcl_uint vwidth;\n\tsize_t work_size;\n\tcl_ulong max_alloc;\n\t\n\tstruct opencl_kernel_info kernelinfo[POW_ALGORITHM_COUNT];\n\t\n\tenum opencl_binary_usage opt_opencl_binaries;\n#ifdef USE_SCRYPT\n\tint lookup_gap;\n\tsize_t thread_concurrency;\n\tsize_t shaders;\n#endif\n\tstruct timeval tv_gpustart;\n\tint intervals;\n\t\n#ifdef HAVE_ADL\n\tbool has_adl;\n\tstruct gpu_adl adl;\n\t\n\tint gpu_engine;\n\tint min_engine;\n\tint gpu_fan;\n\tint min_fan;\n\tint gpu_memclock;\n\tint gpu_memdiff;\n\tint gpu_powertune;\n\tfloat gpu_vddc;\n#endif\n\t\n#ifdef HAVE_SENSORS\n\tconst sensors_chip_name *sensor;\n#endif\n};\n\nextern float opencl_proc_get_intensity(struct cgpu_info *, const char **iunit);\nextern unsigned long xintensity_to_oclthreads(double xintensity, cl_uint max_compute_units);\nextern bool opencl_set_intensity_from_str(struct cgpu_info *, const char *newvalue);\n\n#ifdef USE_SHA256D\nstruct opencl_work_data {\n\tcl_uint ctx_a; cl_uint ctx_b; cl_uint ctx_c; cl_uint ctx_d;\n\tcl_uint ctx_e; cl_uint ctx_f; cl_uint ctx_g; cl_uint ctx_h;\n\tcl_uint cty_a; cl_uint cty_b; cl_uint cty_c; cl_uint cty_d;\n\tcl_uint cty_e; cl_uint cty_f; cl_uint cty_g; cl_uint cty_h;\n\tcl_uint merkle; cl_uint ntime; cl_uint nbits;\n\tcl_uint fW0; cl_uint fW1; cl_uint fW2; cl_uint fW3; cl_uint fW15;\n\tcl_uint fW01r; cl_uint fcty_e; cl_uint fcty_e2;\n\tcl_uint W16; cl_uint W17; cl_uint W2;\n\tcl_uint PreVal4; cl_uint T1;\n\tcl_uint C1addK5; cl_uint D1A; cl_uint W2A; cl_uint W17_2;\n\tcl_uint PreVal4addT1; cl_uint T1substate0;\n\tcl_uint PreVal4_2;\n\tcl_uint PreVal0;\n\tcl_uint PreW18;\n\tcl_uint PreW19;\n\tcl_uint PreW31;\n\tcl_uint PreW32;\n\n\t/* For diakgcn */\n\tcl_uint B1addK6, PreVal0addK7, W16addK16, W17addK17;\n\tcl_uint zeroA, zeroB;\n\tcl_uint oneA, twoA, threeA, fourA, fiveA, sixA, sevenA;\n};\n#endif\n\nextern void opencl_early_init();\nextern char *print_ndevs_and_exit(int *ndevs);\nextern void *reinit_gpu(void *userdata);\nextern char *set_gpu_map(char *arg);\nextern const char *set_gpu_engine(char *arg);\nextern const char *set_gpu_fan(char *arg);\nextern const char *set_gpu_memclock(char *arg);\nextern const char *set_gpu_memdiff(char *arg);\nextern const char *set_gpu_powertune(char *arg);\nextern const char *set_gpu_threads(char *arg);\nextern const char *set_gpu_vddc(char *arg);\nextern const char *set_temp_overheat(char *arg);\nextern const char *set_intensity(char *arg);\nextern const char *set_vector(char *arg);\nextern const char *set_worksize(char *arg);\n#ifdef USE_SCRYPT\nextern const char *set_shaders(char *arg);\nextern const char *set_lookup_gap(char *arg);\nextern const char *set_thread_concurrency(char *arg);\n#endif\nextern enum cl_kernels select_kernel(const char *);\nextern const char *opencl_get_kernel_interface_name(const enum cl_kernels);\nextern const char *opencl_get_default_kernel_filename(const enum cl_kernels);\nextern const char *set_kernel(char *arg);\nextern void write_config_opencl(FILE *);\nvoid manage_gpu(void);\nextern void opencl_dynamic_cleanup();\nextern void pause_dynamic_threads(int gpu);\n\nextern bool have_opencl;\nextern int opt_platform_id;\nextern bool opt_opencl_binaries;\n\nextern struct device_drv opencl_api;\n\n#endif /* __DEVICE_GPU_H__ */\n"
        },
        {
          "name": "driver-proxy.c",
          "type": "blob",
          "size": 3.8896484375,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n\n#include <pthread.h>\n\n#include <uthash.h>\n\n#include \"deviceapi.h\"\n#include \"driver-proxy.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nBFG_REGISTER_DRIVER(proxy_drv)\nstatic const struct bfg_set_device_definition proxy_set_device_funcs[];\n\nstatic\nstruct proxy_client *proxy_clients;\nstatic\npthread_mutex_t proxy_clients_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic\nvoid prune_worklog()\n{\n\tstruct proxy_client *client, *tmp;\n\tstruct work *work, *tmp2;\n\tstruct timeval tv_now;\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tmutex_lock(&proxy_clients_mutex);\n\tHASH_ITER(hh, proxy_clients, client, tmp)\n\t{\n\t\tHASH_ITER(hh, client->work, work, tmp2)\n\t\t{\n\t\t\tif (timer_elapsed(&work->tv_work_start, &tv_now) <= opt_expiry)\n\t\t\t\tbreak;\n\t\t\tHASH_DEL(client->work, work);\n\t\t\tfree_work(work);\n\t\t}\n\t}\n\tmutex_unlock(&proxy_clients_mutex);\n}\n\nstatic\npthread_t prune_worklog_pth;\n\nstatic\nvoid *prune_worklog_thread(void *userdata)\n{\n\tstruct cgpu_info *cgpu = userdata;\n\t\n\tpthread_detach(pthread_self());\n\tRenameThread(\"PXY_pruner\");\n\t\n\twhile (!cgpu->shutdown)\n\t{\n\t\tprune_worklog();\n\t\tsleep(60);\n\t}\n\treturn NULL;\n}\n\nstatic\nfloat proxy_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\treturn minimum_pdiff;\n}\n\nstatic\nvoid proxy_first_client(struct cgpu_info *cgpu)\n{\n\tpthread_create(&prune_worklog_pth, NULL, prune_worklog_thread, cgpu);\n}\n\nstruct proxy_client *proxy_find_or_create_client(const char *username)\n{\n\tstruct proxy_client *client;\n\tstruct cgpu_info *cgpu;\n\tchar *user;\n\tint b;\n\t\n\tif (!username)\n\t\treturn NULL;\n\t\n\tmutex_lock(&proxy_clients_mutex);\n\tHASH_FIND_STR(proxy_clients, username, client);\n\tif (!client)\n\t{\n\t\tuser = strdup(username);\n\t\tcgpu = malloc(sizeof(*cgpu));\n\t\tclient = malloc(sizeof(*client));\n\t\t*cgpu = (struct cgpu_info){\n\t\t\t.drv = &proxy_drv,\n\t\t\t.set_device_funcs = proxy_set_device_funcs,\n\t\t\t.threads = 0,\n\t\t\t.device_data = client,\n\t\t\t.device_path = user,\n\t\t};\n\t\ttimer_set_now(&cgpu->cgminer_stats.start_tv);\n\t\tif (unlikely(!create_new_cgpus(add_cgpu_live, cgpu)))\n\t\t{\n\t\t\tfree(client);\n\t\t\tfree(cgpu);\n\t\t\tfree(user);\n\t\t\treturn NULL;\n\t\t}\n\t\t*client = (struct proxy_client){\n\t\t\t.username = user,\n\t\t\t.cgpu = cgpu,\n\t\t\t.desired_share_pdiff = 0.,\n\t\t};\n\t\t\n\t\tb = HASH_COUNT(proxy_clients);\n\t\tHASH_ADD_KEYPTR(hh, proxy_clients, client->username, strlen(user), client);\n\t\tmutex_unlock(&proxy_clients_mutex);\n\t\t\n\t\tif (!b)\n\t\t\tproxy_first_client(cgpu);\n\t\t\n\t\tcgpu_set_defaults(cgpu);\n\t}\n\telse\n\t{\n\t\tmutex_unlock(&proxy_clients_mutex);\n\t\tcgpu = client->cgpu;\n\t}\n\tthread_reportin(cgpu->thr[0]);\n\treturn client;\n}\n\n// See also, stratumsrv_init_diff in driver-stratum.c\nstatic\nconst char *proxy_set_diff(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct proxy_client * const client = proc->device_data;\n\tdouble nv = atof(newvalue);\n\tif (nv < 0)\n\t\treturn \"Invalid difficulty\";\n\t\n\tif (nv <= minimum_pdiff)\n\t\tnv = minimum_pdiff;\n\tclient->desired_share_pdiff = nv;\n\t\n#ifdef USE_LIBEVENT\n\tstratumsrv_client_changed_diff(client);\n#endif\n\t\n\treturn NULL;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid proxy_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct proxy_client *client = cgpu->device_data;\n\twlogprint(\"Username: %s\\n\", client->username);\n}\n#endif\n\nstatic const struct bfg_set_device_definition proxy_set_device_funcs[] = {\n\t{\"diff\", proxy_set_diff, \"desired share difficulty for clients\"},\n\t{NULL},\n};\n\nstruct device_drv proxy_drv = {\n\t.dname = \"proxy\",\n\t.name = \"PXY\",\n\t.drv_min_nonce_diff = proxy_min_nonce_diff,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = proxy_wlogprint_status,\n#endif\n};\n"
        },
        {
          "name": "driver-proxy.h",
          "type": "blob",
          "size": 0.611328125,
          "content": "#ifndef BFG_DRIVER_PROXY_H\n#define BFG_DRIVER_PROXY_H\n\n#include <uthash.h>\n\n#include \"miner.h\"\n\n#ifdef USE_LIBEVENT\nstruct stratumsrv_conn_userlist;\n#endif\n\nextern struct device_drv proxy_drv;\n\nstruct proxy_client {\n\tchar *username;\n\tstruct cgpu_info *cgpu;\n\tstruct work *work;\n\tstruct timeval tv_hashes_done;\n\tfloat desired_share_pdiff;\n\t\n#ifdef USE_LIBEVENT\n\tstruct stratumsrv_conn_userlist *stratumsrv_connlist;\n#endif\n\t\n\tUT_hash_handle hh;\n};\n\nextern struct proxy_client *proxy_find_or_create_client(const char *user);\n\n#ifdef USE_LIBEVENT\nextern void stratumsrv_client_changed_diff(struct proxy_client *);\n#endif\n\n#endif\n"
        },
        {
          "name": "driver-rockminer.c",
          "type": "blob",
          "size": 16.291015625,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n * Copyright 2014 Nate Woolls\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"deviceapi.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"miner.h\"\n\n#define ROCKMINER_MIN_FREQ_MHZ  200\n#define ROCKMINER_DEF_FREQ_MHZ  270\n#define ROCKMINER_MAX_SAFE_FREQ_MHZ  290\n#define ROCKMINER_MAX_FREQ_MHZ  640\n#define ROCKMINER_POLL_US         0\n#define ROCKMINER_RETRY_US  5000000\n#define ROCKMINER_MIDTASK_TIMEOUT_US  500000\n#define ROCKMINER_MIDTASK_RETRY_US   1000000\n#define ROCKMINER_TASK_TIMEOUT_US    5273438\n#define ROCKMINER_IO_SPEED 115200\n#define ROCKMINER_READ_TIMEOUT 1 //deciseconds\n\n#define ROCKMINER_MAX_CHIPS  64\n#define ROCKMINER_WORK_REQ_SIZE  0x40\n#define ROCKMINER_REPLY_SIZE        8\n\nenum rockminer_replies {\n\tROCKMINER_REPLY_NONCE_FOUND = 0,\n\tROCKMINER_REPLY_TASK_COMPLETE = 1,\n\tROCKMINER_REPLY_GET_TASK = 2,\n};\n\nBFG_REGISTER_DRIVER(rockminer_drv)\nstatic const struct bfg_set_device_definition rockminer_set_device_funcs[];\n\nstruct rockminer_chip_data {\n\tuint8_t next_work_req[ROCKMINER_WORK_REQ_SIZE];\n\tstruct work *works[2];\n\tuint8_t last_taskid;\n\tstruct timeval tv_midtask_timeout;\n\tint requested_work;\n};\n\nstatic\nint rockminer_open(const char *devpath)\n{\n\treturn serial_open(devpath, ROCKMINER_IO_SPEED, ROCKMINER_READ_TIMEOUT, true);\n}\n\nstatic\nvoid rockminer_log_protocol(int fd, const void *buf, size_t bufLen, const char *prefix)\n{\n\tchar hex[(bufLen * 2) + 1];\n\tbin2hex(hex, buf, bufLen);\n\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: %s %s\", rockminer_drv.dname, fd, prefix, hex);\n}\n\nstatic\nint rockminer_read(int fd, void *buf, size_t bufLen)\n{\n\tint result = read(fd, buf, bufLen);\n\t\n\tif (result < 0)\n\t\tapplog(LOG_ERR, \"%s: %s fd %d\", rockminer_drv.dname, \"Failed to read\", fd);\n\telse if ((result > 0) && opt_dev_protocol && opt_debug)\n\t\trockminer_log_protocol(fd, buf, bufLen, \"RECV\");\n\n\treturn result;\n}\n\nstatic\nint rockminer_write(int fd, const void *buf, size_t bufLen)\n{\n\tif (opt_dev_protocol && opt_debug)\n\t\trockminer_log_protocol(fd, buf, bufLen, \"SEND\");\n\n\treturn write(fd, buf, bufLen);\n}\n\nstatic\nvoid rockminer_job_buf_init(uint8_t * const buf, const uint8_t chipid)\n{\n\tmemset(&buf[0x20], 0, 0x10);\n\tbuf[0x30] = 0xaa;\n\t// 0x31 is frequency, filled in elsewhere\n\tbuf[0x32] = chipid;\n\tbuf[0x33] = 0x55;\n}\n\nstatic\nvoid rockminer_job_buf_set_freq(uint8_t * const buf, const unsigned short freq)\n{\n\tbuf[0x31] = (freq / 10) - 1;\n}\n\nstatic\nbool rockminer_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"R-BOX miner\") || lowlevel_match_product(info, \"RX-BOX miner\");\n}\n\nstatic const uint8_t golden_midstate[] = {\n\t0x4a, 0x54, 0x8f, 0xe4, 0x71, 0xfa, 0x3a, 0x9a,\n\t0x13, 0x71, 0x14, 0x45, 0x56, 0xc3, 0xf6, 0x4d,\n\t0x25, 0x00, 0xb4, 0x82, 0x60, 0x08, 0xfe, 0x4b,\n\t0xbf, 0x76, 0x98, 0xc9, 0x4e, 0xba, 0x79, 0x46,\n};\n\nstatic const uint8_t golden_datatail[] = {\n\t                        0xce, 0x22, 0xa7, 0x2f,\n\t0x4f, 0x67, 0x26, 0x14, 0x1a, 0x0b, 0x32, 0x87,\n};\n\nstatic const uint8_t golden_result[] = {\n\t0x00, 0x01, 0x87, 0xa2,\n};\n\nint8_t rockminer_bisect_chips(const int fd, uint8_t * const buf)\n{\n\tstatic const int max_concurrent_tests = 4;\n\tint concurrent_tests = max_concurrent_tests;\n\tuint8_t tests[max_concurrent_tests];\n\tuint8_t reply[ROCKMINER_REPLY_SIZE];\n\tuint8_t minvalid = 0, maxvalid = ROCKMINER_MAX_CHIPS - 1;\n\tuint8_t pertest;\n\tchar msg[0x10];\n\tssize_t rsz;\n\t\n\tdo {\n\t\tpertest = (maxvalid + 1 - minvalid) / concurrent_tests;\n\t\tif (!pertest)\n\t\t\tpertest = 1;\n\t\tmsg[0] = '\\0';\n\t\tfor (int i = 0; i < concurrent_tests; ++i)\n\t\t{\n\t\t\tuint8_t chipid = (minvalid + pertest * (i + 1)) - 1;\n\t\t\tif (chipid > maxvalid)\n\t\t\t{\n\t\t\t\tconcurrent_tests = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttests[i] = chipid;\n\t\t\t\n\t\t\tbuf[0x32] = chipid;\n\t\t\tif (rockminer_write(fd, buf, ROCKMINER_WORK_REQ_SIZE) != ROCKMINER_WORK_REQ_SIZE)\n\t\t\t\tapplogr(-1, LOG_DEBUG, \"%s(%d): Error sending request for chip %d\", __func__, fd, chipid);\n\t\t\t\n\t\t\ttailsprintf(msg, sizeof(msg), \"%d \", chipid);\n\t\t}\n\t\t\n\t\tmsg[strlen(msg)-1] = '\\0';\n\t\tapplog(LOG_DEBUG, \"%s(%d): Testing chips %s (within range %d-%d)\", __func__, fd, msg, minvalid, maxvalid);\n\t\t\n\t\twhile ( (rsz = rockminer_read(fd, reply, sizeof(reply))) == sizeof(reply))\n\t\t{\n\t\t\tconst uint8_t chipid = reply[5] & 0x3f;\n\t\t\tif (chipid > minvalid)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s(%d): Saw chip %d\", __func__, fd, chipid);\n\t\t\t\tminvalid = chipid;\n\t\t\t\tif (minvalid >= tests[concurrent_tests-1])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = concurrent_tests; i--; )\n\t\t{\n\t\t\tif (tests[i] > minvalid)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s(%d): Didn't see chip %d\", __func__, fd, tests[i]);\n\t\t\t\tmaxvalid = tests[i] - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t} while (minvalid != maxvalid);\n\t\n\treturn maxvalid + 1;\n}\n\nstatic\nbool rockminer_detect_one(const char * const devpath)\n{\n\tint fd, chips;\n\tuint8_t buf[ROCKMINER_WORK_REQ_SIZE], reply[ROCKMINER_REPLY_SIZE];\n\tssize_t rsz;\n\t\n\tfd = rockminer_open(devpath);\n\tif (fd < 0)\n\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: %s %s\", rockminer_drv.dname, \"Failed to open\", devpath);\n\t\n\tapplog(LOG_DEBUG, \"%s: %s %s\", rockminer_drv.dname, \"Successfully opened\", devpath);\n\t\n\trockminer_job_buf_init(buf, 0);\n\trockminer_job_buf_set_freq(buf, ROCKMINER_MIN_FREQ_MHZ);\n\tmemcpy(&buf[   0], golden_midstate, 0x20);\n\tmemcpy(&buf[0x34], golden_datatail,  0xc);\n\t\n\tif (rockminer_write(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: %s %s\", rockminer_drv.dname, \"Error sending request to \", devpath);\n\t\n\twhile (true)\n\t{\n\t\trsz = rockminer_read(fd, reply, sizeof(reply));\n\t\tif (rsz != sizeof(reply))\n\t\t\treturn_via_applog(err, , LOG_DEBUG, \"%s: Short read from %s (%d)\", rockminer_drv.dname, devpath, (int)rsz);\n\t\tif ((!memcmp(reply, golden_result, sizeof(golden_result))) && (reply[4] & 0xf) == ROCKMINER_REPLY_NONCE_FOUND)\n\t\t\tbreak;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"%s: Found chip 0 on %s, probing for total chip count\", rockminer_drv.dname, devpath);\n\tchips = rockminer_bisect_chips(fd, buf);\n\tapplog(LOG_DEBUG, \"%s: Identified %d chips on %s\", rockminer_drv.dname, chips, devpath);\n\t\n\tif (serial_claim_v(devpath, &rockminer_drv))\n\t\tgoto err;\n\t\n\tserial_close(fd);\n\t\n\tstruct cgpu_info * const cgpu = malloc(sizeof(*cgpu));\n\t*cgpu = (struct cgpu_info){\n\t\t.drv = &rockminer_drv,\n\t\t.set_device_funcs = rockminer_set_device_funcs,\n\t\t.device_path = strdup(devpath),\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = chips,\n\t\t.threads = 1,\n\t};\n\t// NOTE: Xcode's clang has a bug where it cannot find fields inside anonymous unions (more details in fpgautils)\n\tcgpu->device_fd = -1;\n\t\n\treturn add_cgpu(cgpu);\n\nerr:\n\tif (fd >= 0)\n\t\tserial_close(fd);\n\treturn false;\n}\n\nstatic\nbool rockminer_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, rockminer_detect_one);\n}\n\nstatic\nbool rockminer_init(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\t\n\tfor_each_managed_proc(proc, dev)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct rockminer_chip_data * const chip = malloc(sizeof(*chip));\n\t\t\n\t\tthr->cgpu_data = chip;\n\t\t*chip = (struct rockminer_chip_data){\n\t\t\t.last_taskid = 0,\n\t\t};\n\t\t\n\t\trockminer_job_buf_init(chip->next_work_req, proc->proc_id);\n\t\trockminer_job_buf_set_freq(chip->next_work_req, ROCKMINER_DEF_FREQ_MHZ);\n\t}\n\t\n\ttimer_set_now(&master_thr->tv_poll);\n\t\n\treturn true;\n}\n\nstatic\nvoid rockminer_dead(struct cgpu_info * const dev)\n{\n\tserial_close(dev->device_fd);\n\tdev->device_fd = -1;\n\tfor_each_managed_proc(proc, dev)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tthr->queue_full = true;\n\t}\n}\n\nstatic\nbool rockminer_send_work(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\tconst int fd = dev->device_fd;\n\t\n\treturn (rockminer_write(fd, chip->next_work_req, sizeof(chip->next_work_req)) == sizeof(chip->next_work_req));\n}\n\nstatic\nbool rockminer_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const proc = thr->cgpu;\n\tstruct cgpu_info * const dev = proc->device;\n\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\tconst int fd = dev->device_fd;\n\t\n\tif (fd < 0 || !chip->requested_work)\n\t{\n\t\tthr->queue_full = true;\n\t\treturn false;\n\t}\n\t\n\tmemcpy(&chip->next_work_req[   0], work->midstate, 0x20);\n\tmemcpy(&chip->next_work_req[0x34], &work->data[0x40], 0xc);\n\tif (!rockminer_send_work(thr))\n\t{\n\t\trockminer_dead(dev);\n\t\tinc_hw_errors_only(thr);\n\t\tapplogr(false, LOG_ERR, \"%\"PRIpreprv\": Failed to send work\", proc->proc_repr);\n\t}\n\t\n\tchip->last_taskid = chip->last_taskid ? 0 : 1;\n\tif (chip->works[chip->last_taskid])\n\t\tfree_work(chip->works[chip->last_taskid]);\n\tchip->works[chip->last_taskid] = work;\n\ttimer_set_delay_from_now(&chip->tv_midtask_timeout, ROCKMINER_MIDTASK_RETRY_US);\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Work %d queued as task %d\", proc->proc_repr, work->id, chip->last_taskid);\n\t\n\tif (!--chip->requested_work)\n\t\tthr->queue_full = true;\n\t\n\treturn true;\n}\n\nstatic\nvoid rockminer_queue_flush(__maybe_unused struct thr_info * const thr)\n{\n\t\n}\n\nstatic\nvoid rockminer_poll(struct thr_info * const master_thr)\n{\n\tstruct cgpu_info * const dev = master_thr->cgpu;\n\tint fd = dev->device_fd;\n\tuint8_t reply[ROCKMINER_REPLY_SIZE];\n\tssize_t rsz;\n\t\n\tif (fd < 0)\n\t{\n\t\tfd = rockminer_open(dev->device_path);\n\t\tif (fd < 0)\n\t\t{\n\t\t\ttimer_set_delay_from_now(&master_thr->tv_poll, ROCKMINER_RETRY_US);\n\t\t\tfor_each_managed_proc(proc, dev)\n\t\t\t{\n\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t}\n\t\t\tapplogr(, LOG_ERR, \"%s: Failed to open %s\", dev->dev_repr, dev->device_path);\n\t\t}\n\t\tdev->device_fd = fd;\n\t\tstruct timeval tv_timeout;\n\t\ttimer_set_delay_from_now(&tv_timeout, ROCKMINER_TASK_TIMEOUT_US);\n\t\tfor_each_managed_proc(proc, dev)\n\t\t{\n\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\t\t\t\n\t\t\tchip->requested_work = 1;\n\t\t\tthr->queue_full = false;\n\t\t\tchip->tv_midtask_timeout = tv_timeout;\n\t\t}\n\t}\n\t\n\twhile ( (rsz = rockminer_read(fd, reply, sizeof(reply))) == sizeof(reply))\n\t{\n// \t\tconst uint8_t status = reply[4] >> 4;\n\t\tconst enum rockminer_replies cmd = reply[4] & 0xf;\n// \t\tconst uint8_t prodid = reply[5] >> 6;\n\t\tconst uint8_t chipid = reply[5] & 0x3f;\n\t\tconst uint8_t taskid = reply[6] & 1;\n\t\tconst uint8_t temp = reply[7];\n\t\tstruct cgpu_info * const proc = device_proc_by_id(dev, chipid);\n\t\tif (unlikely(!proc))\n\t\t{\n\t\t\tfor_each_managed_proc(proc, dev)\n\t\t\t{\n\t\t\t\tstruct thr_info * const thr = proc->thr[0];\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t}\n\t\t\tapplog(LOG_ERR, \"%s: Chip id %d out of range\", dev->dev_repr, chipid);\n\t\t\tcontinue;\n\t\t}\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\t\t\n\t\tif (temp != 128)\n\t\t\tproc->temp = temp;\n\t\t\n\t\tswitch (cmd) {\n\t\t\tcase ROCKMINER_REPLY_NONCE_FOUND:\n\t\t\t{\n\t\t\t\tconst uint32_t nonce = upk_u32be(reply, 0);\n\t\t\t\tstruct work *work;\n\t\t\t\tif (chip->works[taskid] && test_nonce(chip->works[taskid], nonce, false))\n\t\t\t\t{}\n\t\t\t\telse\n\t\t\t\tif (chip->works[taskid ? 0 : 1] && test_nonce(chip->works[taskid ? 0 : 1], nonce, false))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": We have task ids inverted; fixing\", proc->proc_repr);\n\t\t\t\t\twork = chip->works[0];\n\t\t\t\t\tchip->works[0] = chip->works[1];\n\t\t\t\t\tchip->works[1] = work;\n\t\t\t\t\tchip->last_taskid = chip->last_taskid ? 0 : 1;\n\t\t\t\t}\n\t\t\t\twork = chip->works[taskid];\n\t\t\t\tsubmit_nonce(thr, work, nonce);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ROCKMINER_REPLY_TASK_COMPLETE:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Task %d completed\", proc->proc_repr, taskid);\n\t\t\t\thashes_done2(thr, 0x100000000, NULL);\n\t\t\t\tif (proc->deven == DEV_ENABLED)\n\t\t\t\t\ttimer_set_delay_from_now(&chip->tv_midtask_timeout, ROCKMINER_MIDTASK_TIMEOUT_US);\n\t\t\t\tbreak;\n\t\t\tcase ROCKMINER_REPLY_GET_TASK:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Task %d requested\", proc->proc_repr, taskid);\n\t\t\t\tthr->queue_full = false;\n\t\t\t\t++chip->requested_work;\n\t\t\t\tif (proc->deven == DEV_ENABLED)\n\t\t\t\t\ttimer_set_delay_from_now(&chip->tv_midtask_timeout, ROCKMINER_TASK_TIMEOUT_US);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (rsz < 0)\n\t\trockminer_dead(dev);\n\t\n\tstruct timeval tv_now;\n\ttimer_set_now(&tv_now);\n\tfor_each_managed_proc(proc, dev)\n\t{\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\t\t\n\t\tif (timer_passed(&chip->tv_midtask_timeout, &tv_now))\n\t\t{\n\t\t\tif (proc->deven != DEV_ENABLED)\n\t\t\t{\n\t\t\t\ttimer_unset(&chip->tv_midtask_timeout);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// A task completed, but no request followed\n\t\t\t// This means it missed our last task send, so we need to resend it\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": No task request? Probably lost, resending task %d\", proc->proc_repr, chip->last_taskid);\n\t\t\tinc_hw_errors_only(thr);\n\t\t\ttimer_set_delay(&chip->tv_midtask_timeout, &tv_now, ROCKMINER_MIDTASK_RETRY_US);\n\t\t\tstruct work *work;\n\t\t\tif ((!(work = chip->works[chip->last_taskid])) || stale_work(work, false))\n\t\t\t{\n\t\t\t\t// Either no work was queued, or it was stale\n\t\t\t\t// Instead of resending, just queue a new one\n\t\t\t\tif (!chip->requested_work)\n\t\t\t\t\tchip->requested_work = 1;\n\t\t\t\tthr->queue_full = false;\n\t\t\t}\n\t\t\telse\n\t\t\tif (!rockminer_send_work(thr))\n\t\t\t{\n\t\t\t\trockminer_dead(dev);\n\t\t\t\ttimer_set_delay_from_now(&master_thr->tv_poll, ROCKMINER_RETRY_US);\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t\tapplogr(, LOG_ERR, \"%\"PRIpreprv\": Failed to resend work\", proc->proc_repr);\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttimer_set_delay_from_now(&master_thr->tv_poll, ROCKMINER_POLL_US);\n}\n\nstatic\nconst char *rockminer_set_clock(struct cgpu_info * const proc, const char * const optname, const char *newvalue, char * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\tbool unsafe = false;\n\t\n\tif (!strncasecmp(newvalue, \"unsafe:\", 7))\n\t{\n\t\tnewvalue += 7;\n\t\tunsafe = true;\n\t}\n\t\n\tconst int val = atoi(newvalue);\n\tif (val < ROCKMINER_MIN_FREQ_MHZ || val > ROCKMINER_MAX_FREQ_MHZ)\n\t\treturn \"Invalid clock speed\";\n\telse\n\tif (val > ROCKMINER_MAX_SAFE_FREQ_MHZ && !unsafe)\n\t\treturn \"Dangerous clock speed (use \\\"unsafe:N\\\" to force)\";\n\t\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Changing clock frequency for future jobs to %d MHz\", proc->proc_repr, val);\n\trockminer_job_buf_set_freq(chip->next_work_req, val);\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition rockminer_set_device_funcs[] = {\n\t{\"clock\", rockminer_set_clock, \"clock frequency\"},\n\t{NULL}\n};\n\nstatic\nint rockminer_get_clock(struct cgpu_info * const proc)\n{\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct rockminer_chip_data * const chip = thr->cgpu_data;\n\treturn ((int)chip->next_work_req[0x31] + 1) * 10;\n}\n\nstatic\nstruct api_data *rockminer_get_extra_device_status(struct cgpu_info * const proc)\n{\n\tstruct api_data *root = NULL;\n\t\n\tdouble d = rockminer_get_clock(proc);\n\troot = api_add_freq(root, \"Frequency\", &d, true);\n\t\n\treturn root;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid rockminer_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *rockminer_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstatic char buf[0x100];  // Static for replies\n\t\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tsprintf(buf, \"Set clock speed (range %d-%d, multiple of 10)\", ROCKMINER_MIN_FREQ_MHZ, ROCKMINER_MAX_FREQ_MHZ);\n\t\t\tchar * const val = curses_input(buf);\n\t\t\tconst char * const msg = rockminer_set_clock(proc, \"clock\", val ?: \"\", NULL, NULL);\n\t\t\tfree(val);\n\t\t\tif (msg)\n\t\t\t{\n\t\t\t\tsnprintf(buf, sizeof(buf), \"%s\\n\", msg);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid rockminer_wlogprint_status(struct cgpu_info * const proc)\n{\n\twlogprint(\"Clock speed: %d\\n\", rockminer_get_clock(proc));\n}\n#endif\n\nstruct device_drv rockminer_drv = {\n\t.dname = \"rockminer\",\n\t.name = \"RKM\",\n\t\n\t.lowl_match = rockminer_lowl_match,\n\t.lowl_probe = rockminer_lowl_probe,\n\t\n\t.thread_init = rockminer_init,\n\t\n\t.minerloop = minerloop_queue,\n\t.queue_append = rockminer_queue_append,\n\t.queue_flush = rockminer_queue_flush,\n\t.poll = rockminer_poll,\n\t\n\t.get_api_extra_device_status = rockminer_get_extra_device_status,\n\t\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = rockminer_wlogprint_status,\n\t.proc_tui_wlogprint_choices = rockminer_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = rockminer_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-stratum.c",
          "type": "blob",
          "size": 27.220703125,
          "content": "/*\n * Copyright 2013-2016 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifndef WIN32\n#include <arpa/inet.h>\n#else\n#include <winsock2.h>\n#endif\n\n#include <float.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#include <event2/buffer.h>\n#include <event2/bufferevent.h>\n#include <event2/event.h>\n#include <event2/listener.h>\n#include <event2/thread.h>\n\n#include <jansson.h>\n\n#include \"deviceapi.h\"\n#include \"driver-proxy.h\"\n#include \"miner.h\"\n#include \"util.h\"\n#include \"work2d.h\"\n\n#define _ssm_client_octets     work2d_xnonce1sz\n#define _ssm_client_xnonce2sz  work2d_xnonce2sz\nstatic char *_ssm_notify, *_ssm_setgoal;\nstatic int _ssm_notify_sz, _ssm_setgoal_sz;\nstatic struct stratumsrv_job *_ssm_last_ssj;\nstatic struct event *ev_notify;\nstatic notifier_t _ssm_update_notifier;\n\nstruct stratumsrv_job {\n\tchar *my_job_id;\n\t\n\tstruct timeval tv_prepared;\n\tstruct stratum_work swork;\n\tfloat job_pdiff[WORK2D_MAX_DIVISIONS+1];\n\t\n\tUT_hash_handle hh;\n};\n\nstatic struct stratumsrv_job *_ssm_jobs;\nstatic struct work _ssm_cur_job_work;\nstatic uint64_t _ssm_jobid;\n\nstatic struct event_base *_smm_evbase;\nstatic bool _smm_running;\nstatic struct evconnlistener *_smm_listener;\n\nstruct stratumsrv_conn_userlist {\n\tstruct proxy_client *client;\n\tstruct stratumsrv_conn *conn;\n\tstruct stratumsrv_conn_userlist *client_next;\n\tstruct stratumsrv_conn_userlist *next;\n};\n\nenum stratumsrv_conn_capability {\n\tSCC_NOTIFY    = 1 << 0,\n\tSCC_SET_DIFF  = 1 << 1,\n\tSCC_SET_GOAL  = 1 << 2,\n};\ntypedef uint8_t stratumsrv_conn_capabilities_t;\n\nstruct stratumsrv_conn {\n\tstruct bufferevent *bev;\n\tstratumsrv_conn_capabilities_t capabilities;\n\tuint32_t xnonce1_le;\n\tstruct timeval tv_hashes_done;\n\tbool hashes_done_ext;\n\tfloat current_share_pdiff;\n\tbool desired_default_share_pdiff;  // Set if any authenticated user is configured for the default\n\tfloat desired_share_pdiff;\n\tstruct stratumsrv_conn_userlist *authorised_users;\n\t\n\tstruct stratumsrv_conn *next;\n};\n\nstatic struct stratumsrv_conn *_ssm_connections;\n\nstatic\nvoid stratumsrv_send_set_difficulty(struct stratumsrv_conn * const conn, const float share_pdiff)\n{\n\tstruct bufferevent * const bev = conn->bev;\n\tchar buf[0x100];\n\tconst double bdiff = pdiff_to_bdiff(share_pdiff);\n\tconn->current_share_pdiff = share_pdiff;\n\tconst int prec = double_find_precision(bdiff, 10.);\n\tconst size_t bufsz = snprintf(buf, sizeof(buf), \"{\\\"params\\\":[%.*f],\\\"id\\\":null,\\\"method\\\":\\\"mining.set_difficulty\\\"}\\n\", prec, bdiff);\n\tbufferevent_write(bev, buf, bufsz);\n}\n\nstatic\nfloat stratumsrv_choose_share_pdiff(const struct stratumsrv_conn * const conn, const struct mining_algorithm * const malgo)\n{\n\tfloat conn_pdiff = conn->desired_share_pdiff;\n\tif (conn->desired_default_share_pdiff && malgo->reasonable_low_nonce_diff < conn_pdiff)\n\t\tconn_pdiff = malgo->reasonable_low_nonce_diff;\n\treturn conn_pdiff;\n}\n\nstatic void stratumsrv_boot_all_subscribed(const char *);\nstatic void _ssj_free(struct stratumsrv_job *);\nstatic void stratumsrv_job_pruner();\n\nstatic\nbool stratumsrv_update_notify_str(struct pool * const pool)\n{\n\tconst bool clean = _ssm_cur_job_work.pool ? stale_work(&_ssm_cur_job_work, true) : true;\n\tstruct timeval tv_now;\n\t\n\tcg_rlock(&pool->data_lock);\n\t\n\tif (!pool_has_usable_swork(pool))\n\t{\nfail:\n\t\tcg_runlock(&pool->data_lock);\n\t\tapplog(LOG_WARNING, \"SSM: No usable 2D work upstream!\");\n\t\tif (clean)\n\t\t\tstratumsrv_boot_all_subscribed(\"Current upstream pool does not have usable 2D work\");\n\t\treturn false;\n\t}\n\t\n\ttimer_set_now(&tv_now);\n\t\n\t{\n\t\tstruct work work;\n\t\twork2d_gen_dummy_work_for_stale_check(&work, &pool->swork, &tv_now, NULL);\n\t\t\n\t\tconst bool is_stale = stale_work2(&work, false, true);\n\t\t\n\t\tclean_work(&work);\n\t\t\n\t\tif (is_stale) {\n\t\t\tcg_runlock(&pool->data_lock);\n\t\t\tapplog(LOG_DEBUG, \"SSM: Ignoring work update notification while pool %d has stale swork\", pool->pool_no);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tstruct stratumsrv_conn *conn;\n\tconst struct stratum_work * const swork = &pool->swork;\n\tconst int n2size = pool->swork.n2size;\n\tconst size_t coinb2_offset = swork->nonce2_offset + n2size;\n\tconst size_t coinb2_len = bytes_len(&swork->coinbase) - swork->nonce2_offset - n2size;\n\t\n\tif (_ssm_last_ssj &&\n\t    !(memcmp(&swork->header1[0], &_ssm_last_ssj->swork.header1[0], 0x24)\n\t   || swork->nonce2_offset != _ssm_last_ssj->swork.nonce2_offset\n\t   || bytes_len(&swork->coinbase) != bytes_len(&_ssm_last_ssj->swork.coinbase)\n\t   || memcmp(bytes_buf(&swork->coinbase), bytes_buf(&_ssm_last_ssj->swork.coinbase), swork->nonce2_offset)\n\t   || memcmp(&bytes_buf(&swork->coinbase)[coinb2_offset], &bytes_buf(&_ssm_last_ssj->swork.coinbase)[coinb2_offset], coinb2_len)\n\t   || memcmp(swork->diffbits, _ssm_last_ssj->swork.diffbits, 4)\n\t)) {\n\t\tcg_runlock(&pool->data_lock);\n\t\tapplog(LOG_DEBUG, \"SSM: Updating with (near?-)identical work2d; skipping...\");\n\t\treturn false;\n\t}\n\t\n\tchar my_job_id[33];\n\tint i;\n\tstruct stratumsrv_job *ssj;\n\tssize_t n2pad = work2d_pad_xnonce_size(swork);\n\tif (n2pad < 0)\n\t{\n\t\tgoto fail;\n\t}\n\tsize_t coinb1in_lenx = swork->nonce2_offset * 2;\n\tsize_t n2padx = n2pad * 2;\n\tsize_t coinb1_lenx = coinb1in_lenx + n2padx;\n\tsize_t coinb2_lenx = coinb2_len * 2;\n\tsprintf(my_job_id, \"%\"PRIx64\"-%\"PRIx64, (uint64_t)time(NULL), _ssm_jobid++);\n\t// NOTE: The buffer has up to 2 extra/unused bytes:\n\t// NOTE: - If clean is \"true\", we spare the extra needed for \"false\"\n\t// NOTE: - The first merkle link does not need a comma, but we cannot subtract it without breaking the case of zero merkle links\n\tsize_t bufsz = 24 /* sprintf 1 constant */ + strlen(my_job_id) + 64 /* prevhash */ + coinb1_lenx + coinb2_lenx + (swork->merkles * 67) + 49 /* sprintf 2 constant */ + 8 /* version */ + 8 /* nbits */ + 8 /* ntime */ + 5 /* clean */ + 1;\n\tchar * const buf = malloc(bufsz);\n\tchar *p = buf;\n\tchar prevhash[65], coinb1[coinb1_lenx + 1], coinb2[coinb2_lenx + 1], version[9], nbits[9], ntime[9];\n\tuint32_t ntime_n;\n\tbin2hex(prevhash, &swork->header1[4], 32);\n\tbin2hex(coinb1, bytes_buf(&swork->coinbase), swork->nonce2_offset);\n\twork2d_pad_xnonce(&coinb1[coinb1in_lenx], swork, true);\n\tcoinb1[coinb1_lenx] = '\\0';\n\tbin2hex(coinb2, &bytes_buf(&swork->coinbase)[coinb2_offset], coinb2_len);\n\tp += sprintf(p, \"{\\\"params\\\":[\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",[\", my_job_id, prevhash, coinb1, coinb2);\n\tfor (i = 0; i < swork->merkles; ++i)\n\t{\n\t\tif (i)\n\t\t\t*p++ = ',';\n\t\t*p++ = '\"';\n\t\tbin2hex(p, &bytes_buf(&swork->merkle_bin)[i * 32], 32);\n\t\tp += 64;\n\t\t*p++ = '\"';\n\t}\n\tbin2hex(version, swork->header1, 4);\n\tbin2hex(nbits, swork->diffbits, 4);\n\tntime_n = htobe32(swork->ntime + timer_elapsed(&swork->tv_received, NULL));\n\tbin2hex(ntime, &ntime_n, 4);\n\tp += sprintf(p, \"],\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",%s],\\\"method\\\":\\\"mining.notify\\\",\\\"id\\\":null}\\n\", version, nbits, ntime, clean ? \"true\" : \"false\");\n\t\n\tconst size_t setgoalbufsz = 49 + strlen(pool->goal->name) + (pool->goalname ? (1 + strlen(pool->goalname)) : 0) + 12 + strlen(pool->goal->malgo->name) + 5 + 1;\n\tchar * const setgoalbuf = malloc(setgoalbufsz);\n\tsnprintf(setgoalbuf, setgoalbufsz, \"{\\\"method\\\":\\\"mining.set_goal\\\",\\\"id\\\":null,\\\"params\\\":[\\\"%s%s%s\\\",{\\\"malgo\\\":\\\"%s\\\"}]}\\n\", pool->goal->name, pool->goalname ? \"/\" : \"\", pool->goalname ?: \"\", pool->goal->malgo->name);\n\t\n\tssj = malloc(sizeof(*ssj));\n\t*ssj = (struct stratumsrv_job){\n\t\t.my_job_id = strdup(my_job_id),\n\t};\n\tssj->tv_prepared = tv_now;\n\tstratum_work_cpy(&ssj->swork, swork);\n\t\n\tcg_runlock(&pool->data_lock);\n\t\n\tif (clean)\n\t{\n\t\tstruct stratumsrv_job *ssj, *tmp;\n\t\t\n\t\tapplog(LOG_DEBUG, \"SSM: Current replacing job stale, pruning all jobs\");\n\t\tHASH_ITER(hh, _ssm_jobs, ssj, tmp)\n\t\t{\n\t\t\tHASH_DEL(_ssm_jobs, ssj);\n\t\t\t_ssj_free(ssj);\n\t\t}\n\t}\n\telse\n\t\tstratumsrv_job_pruner();\n\t\n\tHASH_ADD_KEYPTR(hh, _ssm_jobs, ssj->my_job_id, strlen(ssj->my_job_id), ssj);\n\t\n\tif (likely(_ssm_cur_job_work.pool))\n\t\tclean_work(&_ssm_cur_job_work);\n\twork2d_gen_dummy_work_for_stale_check(&_ssm_cur_job_work, &ssj->swork, &ssj->tv_prepared, NULL);\n\t\n\t_ssm_notify_sz = p - buf;\n\tassert(_ssm_notify_sz <= bufsz);\n\tfree(_ssm_notify);\n\t_ssm_notify = buf;\n\tconst bool setgoal_changed = _ssm_setgoal ? strcmp(setgoalbuf, _ssm_setgoal) : true;\n\tif (setgoal_changed)\n\t{\n\t\tfree(_ssm_setgoal);\n\t\t_ssm_setgoal = setgoalbuf;\n\t\t_ssm_setgoal_sz = setgoalbufsz - 1;\n\t}\n\telse\n\t\tfree(setgoalbuf);\n\t_ssm_last_ssj = ssj;\n\t\n\tfloat pdiff = target_diff(ssj->swork.target);\n\tconst struct mining_goal_info * const goal = pool->goal;\n\tconst struct mining_algorithm * const malgo = goal->malgo;\n\tLL_FOREACH(_ssm_connections, conn)\n\t{\n\t\tif (unlikely(!conn->xnonce1_le))\n\t\t\tcontinue;\n\t\tif (setgoal_changed && (conn->capabilities & SCC_SET_GOAL))\n\t\t\tbufferevent_write(conn->bev, setgoalbuf, setgoalbufsz);\n\t\tif (likely(conn->capabilities & SCC_SET_DIFF))\n\t\t{\n\t\t\tfloat conn_pdiff = stratumsrv_choose_share_pdiff(conn, malgo);\n\t\t\tif (pdiff < conn_pdiff)\n\t\t\t\tconn_pdiff = pdiff;\n\t\t\tssj->job_pdiff[conn->xnonce1_le] = conn_pdiff;\n\t\t\tif (conn_pdiff != conn->current_share_pdiff)\n\t\t\t\tstratumsrv_send_set_difficulty(conn, conn_pdiff);\n\t\t}\n\t\tif (likely(conn->capabilities & SCC_NOTIFY))\n\t\t\tbufferevent_write(conn->bev, _ssm_notify, _ssm_notify_sz);\n\t}\n\t\n\treturn true;\n}\n\nvoid stratumsrv_client_changed_diff(struct proxy_client * const client)\n{\n\tint connections_affected = 0, connections_changed = 0;\n\tstruct stratumsrv_conn_userlist *ule, *ule2;\n\tLL_FOREACH2(client->stratumsrv_connlist, ule, client_next)\n\t{\n\t\tstruct stratumsrv_conn * const conn = ule->conn;\n\t\t\n\t\t++connections_affected;\n\t\t\n\t\tfloat desired_share_pdiff = client->desired_share_pdiff;\n\t\tbool any_default_share_pdiff = !desired_share_pdiff;\n\t\tLL_FOREACH(conn->authorised_users, ule2)\n\t\t{\n\t\t\tstruct proxy_client * const other_client = ule2->client;\n\t\t\tif (!other_client->desired_share_pdiff)\n\t\t\t\tany_default_share_pdiff = true;\n\t\t\telse\n\t\t\tif (other_client->desired_share_pdiff < desired_share_pdiff)\n\t\t\t\tdesired_share_pdiff = other_client->desired_share_pdiff;\n\t\t}\n\t\tBFGINIT(desired_share_pdiff, FLT_MAX);\n\t\tif (conn->desired_share_pdiff != desired_share_pdiff || conn->desired_default_share_pdiff != any_default_share_pdiff)\n\t\t{\n\t\t\tconn->desired_share_pdiff = desired_share_pdiff;\n\t\t\tconn->desired_default_share_pdiff = any_default_share_pdiff;\n\t\t\t++connections_changed;\n\t\t}\n\t}\n\tif (connections_affected)\n\t\tapplog(LOG_DEBUG, \"Proxy-share difficulty change for user '%s' affected %d connections (%d changed difficulty)\", client->username, connections_affected, connections_changed);\n}\n\nstatic\nvoid _ssj_free(struct stratumsrv_job * const ssj)\n{\n\tfree(ssj->my_job_id);\n\tstratum_work_clean(&ssj->swork);\n\tfree(ssj);\n}\n\nstatic\nvoid stratumsrv_job_pruner()\n{\n\tstruct stratumsrv_job *ssj, *tmp_ssj;\n\tstruct timeval tv_now;\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tHASH_ITER(hh, _ssm_jobs, ssj, tmp_ssj)\n\t{\n\t\tif (timer_elapsed(&ssj->tv_prepared, &tv_now) <= opt_expiry)\n\t\t\tbreak;\n\t\tHASH_DEL(_ssm_jobs, ssj);\n\t\tapplog(LOG_DEBUG, \"SSM: Pruning job_id %s\", ssj->my_job_id);\n\t\t_ssj_free(ssj);\n\t}\n}\n\nstatic void stratumsrv_client_close(struct stratumsrv_conn *);\n\nstatic\nvoid stratumsrv_conn_close_completion_cb(struct bufferevent *bev, void *p)\n{\n\tstruct evbuffer * const output = bufferevent_get_output(bev);\n\tif (evbuffer_get_length(output))\n\t\t// Still have more data to write...\n\t\treturn;\n\tstratumsrv_client_close(p);\n}\n\nstatic void stratumsrv_event(struct bufferevent *, short, void *);\n\nstatic\nvoid stratumsrv_boot(struct stratumsrv_conn * const conn, const char * const msg)\n{\n\tstruct bufferevent * const bev = conn->bev;\n\tchar buf[58 + strlen(msg)];\n\tint bufsz = sprintf(buf, \"{\\\"params\\\":[\\\"%s\\\"],\\\"method\\\":\\\"client.show_message\\\",\\\"id\\\":null}\\n\", msg);\n\tbufferevent_write(bev, buf, bufsz);\n\tbufferevent_setcb(bev, NULL, stratumsrv_conn_close_completion_cb, stratumsrv_event, conn);\n}\n\nstatic\nvoid stratumsrv_boot_all_subscribed(const char * const msg)\n{\n\tstruct stratumsrv_conn *conn, *tmp_conn;\n\t\n\tfree(_ssm_notify);\n\t_ssm_notify = NULL;\n\t_ssm_last_ssj = NULL;\n\t\n\t// Boot all connections\n\tLL_FOREACH_SAFE(_ssm_connections, conn, tmp_conn)\n\t{\n\t\tif (!conn->xnonce1_le)\n\t\t\tcontinue;\n\t\tstratumsrv_boot(conn, msg);\n\t}\n}\n\nstatic\nvoid _stratumsrv_update_notify(evutil_socket_t fd, short what, __maybe_unused void *p)\n{\n\tstruct pool *pool = current_pool();\n\t\n\tif (fd == _ssm_update_notifier[0])\n\t{\n\t\tevtimer_del(ev_notify);\n\t\tnotifier_read(_ssm_update_notifier);\n\t\tapplog(LOG_DEBUG, \"SSM: Update triggered by notifier\");\n\t}\n\t\n\tstratumsrv_update_notify_str(pool);\n\t\n\tstruct timeval tv_scantime = {\n\t\t.tv_sec = opt_scantime,\n\t};\n\tevtimer_add(ev_notify, &tv_scantime);\n}\n\nstatic struct proxy_client *_stratumsrv_find_or_create_client(const char *);\n\nstatic\nstruct proxy_client *(*stratumsrv_find_or_create_client)(const char *) = _stratumsrv_find_or_create_client;\n\nstatic\nstruct proxy_client *_stratumsrv_find_or_create_client(const char *user)\n{\n\tstruct proxy_client * const client = proxy_find_or_create_client(user);\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\t\n\tif (!client)\n\t\treturn NULL;\n\t\n\tcgpu = client->cgpu;\n\tthr = cgpu->thr[0];\n\t\n\tmemcpy(thr->work_restart_notifier, _ssm_update_notifier, sizeof(thr->work_restart_notifier));\n\tstratumsrv_find_or_create_client = proxy_find_or_create_client;\n\t\n\treturn client;\n}\n\nstatic\nvoid _stratumsrv_failure(struct bufferevent * const bev, const char * const idstr, const int e, const char * const emsg)\n{\n\tif (!idstr)\n\t\treturn;\n\t\n\tchar buf[0x100];\n\tsize_t bufsz = snprintf(buf, sizeof(buf), \"{\\\"error\\\":[%d,\\\"%s\\\",null],\\\"id\\\":%s,\\\"result\\\":null}\\n\", e, emsg, idstr);\n\tbufferevent_write(bev, buf, bufsz);\n}\n#define return_stratumsrv_failure(e, emsg)  do{  \\\n\t_stratumsrv_failure(bev, idstr, e, emsg);    \\\n\treturn;                                      \\\n}while(0)\n\nstatic\nvoid stratumsrv_success2(struct bufferevent * const bev, const char * const idstr, const char * const resultstr)\n{\n\tif (!idstr)\n\t\treturn;\n\t\n\tsize_t bufsz = 32 + strlen(resultstr) + strlen(idstr);\n\tchar buf[bufsz];\n\t\n\tbufsz = sprintf(buf, \"{\\\"result\\\":%s,\\\"id\\\":%s,\\\"error\\\":null}\\n\", resultstr, idstr);\n\tbufferevent_write(bev, buf, bufsz);\n}\n\nstatic inline\nvoid _stratumsrv_success(struct bufferevent * const bev, const char * const idstr)\n{\n\tstratumsrv_success2(bev, idstr, \"true\");\n}\n\nstatic\nvoid stratumsrv_mining_capabilities(struct bufferevent * const bev, json_t * const params, const char * const idstr, struct stratumsrv_conn * const conn)\n{\n\tif (json_is_null(params) || (!json_is_array(params)))\n\t\treturn_stratumsrv_failure(20, \"Bad params\");\n\t\n\tconn->capabilities = 0;\n\t\n\tjson_t * const caps = (json_array_size(params) < 1) ? NULL : json_array_get(params, 0);\n\tif (caps && (!json_is_null(caps)) && json_is_object(caps))\n\t{\n\t\tfor (void *iter = json_object_iter(caps); iter; iter = json_object_iter_next(caps, iter))\n\t\t{\n\t\t\tconst char * const s = json_object_iter_key(iter);\n\t\t\tif (!strcasecmp(s, \"notify\"))\n\t\t\t\tconn->capabilities |= SCC_NOTIFY;\n\t\t\telse\n\t\t\tif (!strcasecmp(s, \"set_difficulty\"))\n\t\t\t\tconn->capabilities |= SCC_SET_DIFF;\n\t\t\telse\n\t\t\tif (!strcasecmp(s, \"set_goal\"))\n\t\t\t\tconn->capabilities |= SCC_SET_GOAL;\n\t\t}\n\t}\n\t\n\tstratumsrv_success2(bev, idstr, \"null\");\n}\n\nstatic\nvoid stratumsrv_mining_subscribe(struct bufferevent * const bev, json_t * const params, const char * const idstr, struct stratumsrv_conn * const conn)\n{\n\tuint32_t * const xnonce1_p = &conn->xnonce1_le;\n\tchar buf[90 + strlen(idstr) + (_ssm_client_octets * 2 * 2) + 0x10];\n\tchar xnonce1x[(_ssm_client_octets * 2) + 1];\n\tint bufsz;\n\t\n\tif (!_ssm_notify)\n\t{\n\t\tevtimer_del(ev_notify);\n\t\t_stratumsrv_update_notify(-1, 0, NULL);\n\t\tif (!_ssm_notify)\n\t\t\treturn_stratumsrv_failure(20, \"No notify set (upstream not stratum?)\");\n\t}\n\t\n\tif (!*xnonce1_p)\n\t{\n\t\tif (!reserve_work2d_(xnonce1_p))\n\t\t\treturn_stratumsrv_failure(20, \"Maximum clients already connected\");\n\t}\n\t\n\tbin2hex(xnonce1x, xnonce1_p, _ssm_client_octets);\n\tbufsz = sprintf(buf, \"{\\\"id\\\":%s,\\\"result\\\":[[[\\\"mining.set_difficulty\\\",\\\"x\\\"],[\\\"mining.notify\\\",\\\"%s\\\"]],\\\"%s\\\",%d],\\\"error\\\":null}\\n\", idstr, xnonce1x, xnonce1x, _ssm_client_xnonce2sz);\n\tbufferevent_write(bev, buf, bufsz);\n\t\n\tif (conn->capabilities & SCC_SET_GOAL)\n\t\tbufferevent_write(conn->bev, _ssm_setgoal, _ssm_setgoal_sz);\n\tif (likely(conn->capabilities & SCC_SET_DIFF))\n\t{\n\t\tconst struct pool * const pool = _ssm_last_ssj->swork.pool;\n\t\tconst struct mining_goal_info * const goal = pool->goal;\n\t\tconst struct mining_algorithm * const malgo = goal->malgo;\n\t\tfloat pdiff = target_diff(_ssm_last_ssj->swork.target);\n\t\tconst float conn_pdiff = stratumsrv_choose_share_pdiff(conn, malgo);\n\t\tif (pdiff > conn_pdiff)\n\t\t\tpdiff = conn_pdiff;\n\t\t_ssm_last_ssj->job_pdiff[*xnonce1_p] = pdiff;\n\t\tstratumsrv_send_set_difficulty(conn, pdiff);\n\t}\n\tif (likely(conn->capabilities & SCC_NOTIFY))\n\t\tbufferevent_write(bev, _ssm_notify, _ssm_notify_sz);\n}\n\nstatic\nvoid stratumsrv_mining_authorize(struct bufferevent * const bev, json_t * const params, const char * const idstr, struct stratumsrv_conn * const conn)\n{\n\tconst char * const username = __json_array_string(params, 0);\n\tif (!username)\n\t\treturn_stratumsrv_failure(20, \"Missing or non-String username parameter\");\n\t\n\tstruct proxy_client * const client = stratumsrv_find_or_create_client(username);\n\t\n\tif (unlikely(!client))\n\t\treturn_stratumsrv_failure(20, \"Failed creating new cgpu\");\n\t\n\tif (client->desired_share_pdiff)\n\t{\n\t\tif (!conn->authorised_users)\n\t\t\tconn->desired_default_share_pdiff = false;\n\t\tif ((!conn->authorised_users) || client->desired_share_pdiff < conn->desired_share_pdiff)\n\t\t\tconn->desired_share_pdiff = client->desired_share_pdiff;\n\t}\n\telse\n\t{\n\t\tconn->desired_default_share_pdiff = true;\n\t\tif (!conn->authorised_users)\n\t\t\tconn->desired_share_pdiff = FLT_MAX;\n\t}\n\t\n\tstruct stratumsrv_conn_userlist *ule = malloc(sizeof(*ule));\n\t*ule = (struct stratumsrv_conn_userlist){\n\t\t.client = client,\n\t\t.conn = conn,\n\t};\n\tLL_PREPEND(conn->authorised_users, ule);\n\tLL_PREPEND2(client->stratumsrv_connlist, ule, client_next);\n\t\n\t_stratumsrv_success(bev, idstr);\n}\n\nstatic\nvoid stratumsrv_mining_submit(struct bufferevent *bev, json_t *params, const char *idstr, struct stratumsrv_conn * const conn)\n{\n\tuint32_t * const xnonce1_p = &conn->xnonce1_le;\n\tstruct stratumsrv_job *ssj;\n\tstruct proxy_client *client = stratumsrv_find_or_create_client(__json_array_string(params, 0));\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\tconst char * const job_id = __json_array_string(params, 1);\n\tconst char * const extranonce2 = __json_array_string(params, 2);\n\tconst char * const ntime = __json_array_string(params, 3);\n\tconst char * const nonce = __json_array_string(params, 4);\n\tuint8_t xnonce2[work2d_xnonce2sz];\n\tuint32_t ntime_n, nonce_n;\n\tbool is_stale;\n\t\n\tif (unlikely(!client))\n\t\treturn_stratumsrv_failure(20, \"Failed creating new cgpu\");\n\tif (unlikely(!(job_id && extranonce2 && ntime && nonce)))\n\t\treturn_stratumsrv_failure(20, \"Couldn't understand parameters\");\n\tif (unlikely(strlen(nonce) < 8))\n\t\treturn_stratumsrv_failure(20, \"nonce too short\");\n\tif (unlikely(strlen(ntime) < 8))\n\t\treturn_stratumsrv_failure(20, \"ntime too short\");\n\tif (unlikely(strlen(extranonce2) < _ssm_client_xnonce2sz * 2))\n\t\treturn_stratumsrv_failure(20, \"extranonce2 too short\");\n\t\n\tcgpu = client->cgpu;\n\tthr = cgpu->thr[0];\n\t\n\t// Lookup job_id\n\tHASH_FIND_STR(_ssm_jobs, job_id, ssj);\n\tif (!ssj)\n\t\treturn_stratumsrv_failure(21, \"Job not found\");\n\t\n\tfloat nonce_diff = ssj->job_pdiff[*xnonce1_p];\n\tif (unlikely(nonce_diff <= 0))\n\t{\n\t\tapplog(LOG_WARNING, \"Unknown share difficulty for SSM job %s\", ssj->my_job_id);\n\t\tnonce_diff = conn->current_share_pdiff;\n\t}\n\t\n\thex2bin(xnonce2, extranonce2, work2d_xnonce2sz);\n\t\n\t// Submit nonce\n\thex2bin((void*)&ntime_n, ntime, 4);\n\tntime_n = be32toh(ntime_n);\n\thex2bin((void*)&nonce_n, nonce, 4);\n\tnonce_n = le32toh(nonce_n);\n\tif (!work2d_submit_nonce(thr, &ssj->swork, &ssj->tv_prepared, xnonce2, *xnonce1_p, nonce_n, ntime_n, &is_stale, nonce_diff))\n\t\t_stratumsrv_failure(bev, idstr, 23, \"H-not-zero\");\n\telse\n\tif (is_stale)\n\t\t_stratumsrv_failure(bev, idstr, 21, \"stale\");\n\telse\n\t\t_stratumsrv_success(bev, idstr);\n\t\n\tif (!conn->hashes_done_ext)\n\t{\n\t\tstruct timeval tv_now, tv_delta;\n\t\ttimer_set_now(&tv_now);\n\t\ttimersub(&tv_now, &conn->tv_hashes_done, &tv_delta);\n\t\tconn->tv_hashes_done = tv_now;\n\t\tconst uint64_t hashes = (float)0x100000000 * nonce_diff;\n\t\thashes_done(thr, hashes, &tv_delta, NULL);\n\t}\n}\n\nstatic\nvoid stratumsrv_mining_hashes_done(struct bufferevent * const bev, json_t * const params, const char * const idstr, struct stratumsrv_conn * const conn)\n{\n\tdouble f;\n\tstruct timeval tv_delta;\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\tstruct proxy_client * const client = stratumsrv_find_or_create_client(__json_array_string(params, 0));\n\tjson_t *jduration = json_array_get(params, 1);\n\tjson_t *jhashcount = json_array_get(params, 2);\n\t\n\tif (!(json_is_number(jduration) && json_is_number(jhashcount)))\n\t\treturn_stratumsrv_failure(20, \"mining.hashes_done(String username, Number duration-in-seconds, Number hashcount)\");\n\t\n\tcgpu = client->cgpu;\n\tthr = cgpu->thr[0];\n\t\n\tf = json_number_value(jduration);\n\ttv_delta.tv_sec = f;\n\ttv_delta.tv_usec = (f - tv_delta.tv_sec) * 1e6;\n\t\n\tf = json_number_value(jhashcount);\n\thashes_done(thr, f, &tv_delta, NULL);\n\t\n\tconn->hashes_done_ext = true;\n}\n\nstatic\nbool stratumsrv_process_line(struct bufferevent * const bev, const char * const ln, void * const p)\n{\n\tstruct stratumsrv_conn *conn = p;\n\tjson_error_t jerr;\n\tjson_t *json, *params, *j2;\n\tconst char *method;\n\tchar *idstr;\n\t\n\tjson = JSON_LOADS(ln, &jerr);\n\tif (!json)\n\t{\n\t\tif (strncmp(ln, \"GET \", 4) && strncmp(ln, \"POST \", 5) && ln[0] != '\\x16' /* TLS handshake */)\n\t\t\tapplog(LOG_ERR, \"SSM: JSON parse error: %s\", ln);\n\t\treturn false;\n\t}\n\t\n\tmethod = bfg_json_obj_string(json, \"method\", NULL);\n\tif (!method)\n\t{\n\t\tapplog(LOG_ERR, \"SSM: JSON missing method: %s\", ln);\nerrout:\n\t\tjson_decref(json);\n\t\treturn false;\n\t}\n\t\n\tparams = json_object_get(json, \"params\");\n\tif (!params)\n\t{\n\t\tapplog(LOG_ERR, \"SSM: JSON missing params: %s\", ln);\n\t\tgoto errout;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"SSM: RECV: %s\", ln);\n\t\n\tj2 = json_object_get(json, \"id\");\n\tidstr = (j2 && !json_is_null(j2)) ? json_dumps_ANY(j2, 0) : NULL;\n\t\n\tif (!strcasecmp(method, \"mining.submit\"))\n\t\tstratumsrv_mining_submit(bev, params, idstr, conn);\n\telse\n\tif (!strcasecmp(method, \"mining.hashes_done\"))\n\t\tstratumsrv_mining_hashes_done(bev, params, idstr, conn);\n\telse\n\tif (!strcasecmp(method, \"mining.authorize\"))\n\t\tstratumsrv_mining_authorize(bev, params, idstr, conn);\n\telse\n\tif (!strcasecmp(method, \"mining.subscribe\"))\n\t\tstratumsrv_mining_subscribe(bev, params, idstr, conn);\n\telse\n\tif (!strcasecmp(method, \"mining.capabilities\"))\n\t\tstratumsrv_mining_capabilities(bev, params, idstr, conn);\n\telse\n\t\t_stratumsrv_failure(bev, idstr, -3, \"Method not supported\");\n\t\n\tfree(idstr);\n\tjson_decref(json);\n\treturn true;\n}\n\nstatic\nvoid stratumsrv_client_close(struct stratumsrv_conn * const conn)\n{\n\tstruct bufferevent * const bev = conn->bev;\n\tstruct stratumsrv_conn_userlist *ule, *uletmp;\n\t\n\tbufferevent_free(bev);\n\tLL_DELETE(_ssm_connections, conn);\n\trelease_work2d_(conn->xnonce1_le);\n\tLL_FOREACH_SAFE(conn->authorised_users, ule, uletmp)\n\t{\n\t\tstruct proxy_client * const client = ule->client;\n\t\tLL_DELETE(conn->authorised_users, ule);\n\t\tLL_DELETE2(client->stratumsrv_connlist, ule, client_next);\n\t\tfree(ule);\n\t}\n\tfree(conn);\n}\n\nstatic\nvoid stratumsrv_read(struct bufferevent *bev, void *p)\n{\n\tstruct evbuffer *input = bufferevent_get_input(bev);\n\tchar *ln;\n\tbool rv;\n\t\n\twhile ( (ln = evbuffer_readln(input, NULL, EVBUFFER_EOL_ANY)) )\n\t{\n\t\trv = stratumsrv_process_line(bev, ln, p);\n\t\tfree(ln);\n\t\tif (unlikely(!rv))\n\t\t{\n\t\t\tstratumsrv_client_close(p);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic\nvoid stratumsrv_event(struct bufferevent *bev, short events, void *p)\n{\n\tif (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR))\n\t{\n\t\tif (events & BEV_EVENT_ERROR)\n\t\t\tapplog(LOG_ERR, \"Error from bufferevent\");\n\t\tif (events & BEV_EVENT_EOF)\n\t\t\tapplog(LOG_DEBUG, \"EOF from bufferevent\");\n\t\tstratumsrv_client_close(p);\n\t}\n}\n\n// See also, proxy_set_diff in driver-proxy.c\nstatic\nconst char *stratumsrv_init_diff(struct cgpu_info * const proc, const char * const optname, const char * const newvalue, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct stratumsrv_conn * const conn = proc->device_data;\n\t\n\tdouble nv = atof(newvalue);\n\tif (nv < 0)\n\t\treturn \"Invalid difficulty\";\n\t\n\tif (nv <= minimum_pdiff)\n\t\tnv = minimum_pdiff;\n\tconn->desired_share_pdiff = nv;\n\tconn->desired_default_share_pdiff = false;\n\t\n\treturn NULL;\n}\n\nstatic const struct bfg_set_device_definition stratumsrv_set_device_funcs_newconnect[] = {\n\t{\"diff\", stratumsrv_init_diff, NULL},\n\t{NULL},\n};\n\nstatic\nvoid stratumlistener(struct evconnlistener *listener, evutil_socket_t sock, struct sockaddr *addr, int len, void *p)\n{\n\tstruct stratumsrv_conn *conn;\n\tstruct event_base *evbase = evconnlistener_get_base(listener);\n\tstruct bufferevent *bev = bufferevent_socket_new(evbase, sock, BEV_OPT_CLOSE_ON_FREE);\n\tconn = malloc(sizeof(*conn));\n\t*conn = (struct stratumsrv_conn){\n\t\t.bev = bev,\n\t\t.capabilities = SCC_NOTIFY | SCC_SET_DIFF,\n\t\t.desired_share_pdiff = FLT_MAX,\n\t\t.desired_default_share_pdiff = true,\n\t};\n\tdrv_set_defaults(&proxy_drv, stratumsrv_set_device_funcs_newconnect, conn, NULL, NULL, 1);\n\tLL_PREPEND(_ssm_connections, conn);\n\tbufferevent_setcb(bev, stratumsrv_read, NULL, stratumsrv_event, conn);\n\tbufferevent_enable(bev, EV_READ | EV_WRITE);\n}\n\nstatic bool stratumsrv_init_server(void);\n\nbool stratumsrv_change_port(const unsigned port)\n{\n\tif (!_smm_running) {\n\t\tif (!stratumsrv_init_server()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tstruct event_base * const evbase = _smm_evbase;\n\tstruct evconnlistener * const old_smm_listener = _smm_listener;\n\t\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_addr.s_addr = INADDR_ANY,\n\t\t.sin_port = htons(port),\n\t};\n\t_smm_listener = evconnlistener_new_bind(evbase, stratumlistener, NULL, (\n\t\tLEV_OPT_CLOSE_ON_FREE | LEV_OPT_CLOSE_ON_EXEC | LEV_OPT_REUSEABLE\n\t), 0x10, (void*)&sin, sizeof(sin));\n\t\n\tif (!_smm_listener) {\n\t\tapplog(LOG_ERR, \"SSM: Failed to listen on port %u\", (unsigned)port);\n\t\treturn false;\n\t}\n\t\n\t// NOTE: libevent doesn't seem to implement LEV_OPT_CLOSE_ON_EXEC for Windows, so we must do this ourselves\n\tset_cloexec_socket(evconnlistener_get_fd(_smm_listener), true);\n\t\n\tif (old_smm_listener) {\n\t\tevconnlistener_free(old_smm_listener);\n\t}\n\tstratumsrv_port = port;\n\t\n\treturn true;\n}\n\nstatic\nvoid *stratumsrv_thread(__maybe_unused void *p)\n{\n\tpthread_detach(pthread_self());\n\tRenameThread(\"stratumsrv\");\n\t\n\tstruct event_base *evbase = _smm_evbase;\n\tevent_base_dispatch(evbase);\n\t_smm_running = false;\n\t\n\treturn NULL;\n}\n\nstatic\nbool stratumsrv_init_server() {\n\twork2d_init();\n\t\n\tif (-1\n#if EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED\n\t && evthread_use_windows_threads()\n#endif\n#if EVTHREAD_USE_PTHREADS_IMPLEMENTED\n\t && evthread_use_pthreads()\n#endif\n\t) {\n\t\tapplog(LOG_ERR, \"SSM: %s failed\", \"event_use_*threads\");\n\t\treturn false;\n\t}\n\t\n\tstruct event_base *evbase = event_base_new();\n\tif (!evbase) {\n\t\tapplog(LOG_ERR, \"SSM: %s failed\", \"event_base_new\");\n\t\treturn false;\n\t}\n\t_smm_evbase = evbase;\n\t\n\t{\n\t\tev_notify = evtimer_new(evbase, _stratumsrv_update_notify, NULL);\n\t\tif (!ev_notify) {\n\t\t\tapplog(LOG_ERR, \"SSM: %s failed\", \"evtimer_new\");\n\t\t\treturn false;\n\t\t}\n\t\t_stratumsrv_update_notify(-1, 0, NULL);\n\t}\n\t{\n\t\tnotifier_init(_ssm_update_notifier);\n\t\tstruct event *ev_update_notifier = event_new(evbase, _ssm_update_notifier[0], EV_READ | EV_PERSIST, _stratumsrv_update_notify, NULL);\n\t\tif (!ev_update_notifier) {\n\t\t\tapplog(LOG_ERR, \"SSM: %s failed\", \"event_new\");\n\t\t\treturn false;\n\t\t}\n\t\tevent_add(ev_update_notifier, NULL);\n\t}\n\t\n\t_smm_running = true;\n\t\n\tpthread_t pth;\n\tif (unlikely(pthread_create(&pth, NULL, stratumsrv_thread, NULL)))\n\t\tquit(1, \"stratumsrv thread create failed\");\n\t\n\treturn true;\n}\n"
        },
        {
          "name": "driver-titan.c",
          "type": "blob",
          "size": 28.2822265625,
          "content": "/*\n * Copyright 2014 Vitalii Demianets\n * Copyright 2014 KnCMiner\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include <fcntl.h>\n#include <sys/ioctl.h>\n\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#include \"titan-asic.h\"\n\n#define\tKNC_TITAN_DEFAULT_FREQUENCY\t275\n\n#define KNC_TITAN_HWERR_DISABLE_SECS\t10\n\n#define\tKNC_POLL_INTERVAL_US\t\t10000\n\n#define\tDIE_HEALTH_INTERVAL_SEC\t\t20\n\n/* Broadcast address to all cores in a die */\n#define\tALL_CORES\t0xFFFF\n\n/* Work queue pre-fill level.\n * Must be high enough to supply all ASICs with works after a flush */\n#define\tWORK_QUEUE_PREFILL\t\t\t20\n\n#define MANUAL_CHECK_CORES_PER_POLL            100\n\n/* Specify here minimum number of leading zeroes in hash */\n#define\tDEFAULT_DIFF_FILTERING_ZEROES\t24\n#define\tDEFAULT_DIFF_FILTERING_FLOAT\t(1. / ((double)(0x00000000FFFFFFFF >> DEFAULT_DIFF_FILTERING_ZEROES)))\n#define\tDEFAULT_DIFF_HASHES_PER_NONCE\t(1 << DEFAULT_DIFF_FILTERING_ZEROES)\n\nBFG_REGISTER_DRIVER(knc_titan_drv)\n\n/* 3 - default number of threads per core */\nstatic int opt_knc_threads_per_core = 3;\n\nstatic const struct bfg_set_device_definition knc_titan_set_device_funcs[];\n\nstruct knc_titan_core {\n\tint asicno;\n\tint dieno; /* inside asic */\n\tint coreno; /* inside die */\n\tstruct knc_titan_die *die;\n\tstruct knc_titan_core *next_core;\n\n\tint hwerr_in_row;\n\tint hwerr_disable_time;\n\tstruct timeval enable_at;\n\tstruct timeval first_hwerr;\n\n\tstruct nonce_report last_nonce;\n\tbool need_manual_check;\n};\n\nstruct knc_titan_die {\n\tint asicno;\n\tint dieno; /* inside asic */\n\tint cores;\n\tstruct cgpu_info *proc;\n\tstruct knc_titan_core *first_core;\n\n\tbool need_flush;\n\tint next_slot;\n\t/* First slot after flush. If next_slot reaches this, then\n\t * we need to re-flush all the cores to avoid duplicating slot numbers\n\t * for different works */\n\tint first_slot;\n\n\tstruct timeval last_share;\n\t/* Don't use this! DC/DCs don't like broadcast urgent setworks */\n\tbool broadcast_flushes;\n\n\tuint64_t hashes_done;\n/* We store history of hash counters for the last minute (12*5 = 60 s) */\n#define\tHASHES_BUF_ONE_ENTRY_TIME\t5\n#define\tHASHES_BUF_ENTRIES\t\t12\n\tuint64_t hashes_buf[HASHES_BUF_ENTRIES];\n\tint hashes_buf_idx; /* next write position === the oldest data stored */\n\n\tint freq;\n\tint manual_check_count;\n\n\tbool reconfigure_request;\n\tbool delete_request;\n\tint add_request;\n};\n\nstruct knc_titan_info {\n\tvoid *ctx;\n\tstruct cgpu_info *cgpu;\n\tint cores;\n\tstruct knc_titan_die dies[KNC_TITAN_MAX_ASICS][KNC_TITAN_DIES_PER_ASIC];\n\tbool asic_served_by_fpga[KNC_TITAN_MAX_ASICS];\n\tstruct timeval tv_prev;\n\n\tstruct work *workqueue;\n\tint workqueue_size;\n\tint workqueue_max;\n\tint next_id;\n\n\tstruct work *devicework;\n};\n\nstatic void knc_titan_zero_stats(struct cgpu_info *cgpu)\n{\n\tif (cgpu->device != cgpu)\n\t\treturn;\n\n\tint asic = ((struct knc_titan_die *)cgpu->thr[0]->cgpu_data)->asicno;\n\tstruct knc_titan_info *knc = cgpu->device_data;\n\tstruct knc_titan_die *die;\n\tint dieno;\n\n\tfor (dieno = 0; dieno < KNC_TITAN_DIES_PER_ASIC; ++dieno) {\n\t\tdie = &(knc->dies[asic][dieno]);\n\t\tdie->hashes_done = 0;\n\t\tmemset(die->hashes_buf, 0, sizeof(die->hashes_buf));\n\t}\n}\n\nstatic double knc_titan_get_die_rolling_hashrate(struct cgpu_info *device)\n{\n\tstruct knc_titan_die *die = device->thr[0]->cgpu_data;\n\tint asicno = die->asicno;\n\tint dieno = die->dieno;\n\tstruct knc_titan_info *knc = device->device_data;\n\tdouble hashrate = 0.0;\n\tint i;\n\n\tfor (i = 0; i < HASHES_BUF_ENTRIES; ++i) {\n\t\thashrate += (double)knc->dies[asicno][dieno].hashes_buf[i] / 1.0e6;\n\t}\n\n\treturn hashrate / ((double)(HASHES_BUF_ENTRIES * HASHES_BUF_ONE_ENTRY_TIME));\n}\n\nstatic void knc_titan_die_hashmeter(struct knc_titan_die *die, uint64_t hashes_done)\n{\n\tstruct timeval tv_now;\n\tcgtime(&tv_now);\n\tint cur_idx = (tv_now.tv_sec / HASHES_BUF_ONE_ENTRY_TIME) % HASHES_BUF_ENTRIES;\n\n\tif (die->hashes_buf_idx == cur_idx) {\n\t\tdie->hashes_done += hashes_done;\n\t\treturn;\n\t}\n\n\tdie->hashes_buf[die->hashes_buf_idx] = die->hashes_done;\n\tdie->hashes_done = hashes_done;\n\n\tdie->hashes_buf_idx = (die->hashes_buf_idx + 1) % HASHES_BUF_ENTRIES;\n\twhile (die->hashes_buf_idx != cur_idx) {\n\t\tdie->hashes_buf[die->hashes_buf_idx] = 0;\n\t\tdie->hashes_buf_idx = (die->hashes_buf_idx + 1) % HASHES_BUF_ENTRIES;\n\t}\n}\n\nstatic bool knc_titan_detect_one(const char *devpath)\n{\n\tstatic struct cgpu_info *prev_cgpu = NULL;\n\tstruct cgpu_info *cgpu;\n\tvoid *ctx;\n\tstruct knc_titan_info *knc;\n\tint cores = 0, asic, die, dies = 0;\n\tstruct knc_die_info die_info;\n\tchar repr[6];\n\n\tcgpu = malloc(sizeof(*cgpu));\n\tif (unlikely(!cgpu))\n\t\tquit(1, \"Failed to alloc cgpu_info\");\n\n\tif (!prev_cgpu) {\n\t\tif (NULL == (ctx = knc_trnsp_new(NULL))) {\n\t\t\tfree(cgpu);\n\t\t\treturn false;\n\t\t}\n\n\t\tknc = calloc(1, sizeof(*knc));\n\t\tif (unlikely(!knc))\n\t\t\tquit(1, \"Failed to alloc knc_titan_info\");\n\n\t\tknc->ctx = ctx;\n\t\tknc->cgpu = cgpu;\n\t\tknc->workqueue_max = WORK_QUEUE_PREFILL;\n\t} else {\n\t\tknc = prev_cgpu->device_data;\n\t\tctx = knc->ctx;\n\t}\n\n\tsnprintf(repr, sizeof(repr), \"%s %s\", knc_titan_drv.name, devpath);\n\tasic = atoi(devpath);\n\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\tdie_info.cores = KNC_TITAN_CORES_PER_DIE; /* core hint */\n\t\tdie_info.version = KNC_VERSION_TITAN;\n\t\tif (!knc_titan_get_info(LOG_NOTICE, ctx, asic, die, &die_info))\n\t\t\tdie_info.cores = -1;\n\t\tif (0 < die_info.cores) {\n\t\t\tknc->dies[asic][die] = (struct knc_titan_die) {\n\t\t\t\t.asicno = asic,\n\t\t\t\t.dieno = die,\n\t\t\t\t.cores = die_info.cores,\n\t\t\t\t.proc = NULL, /* Will be assigned at init stage */\n\t\t\t\t.first_core = NULL,\n\t\t\t\t.freq = KNC_TITAN_DEFAULT_FREQUENCY,\n\t\t\t};\n\t\t\tcores += die_info.cores;\n\t\t\tdies++;\n\t\t} else {\n\t\t\tknc->dies[asic][die] = (struct knc_titan_die) {\n\t\t\t\t.asicno = -INT_MAX,\n\t\t\t\t.dieno = -INT_MAX,\n\t\t\t\t.cores = 0,\n\t\t\t\t.proc = NULL,\n\t\t\t\t.first_core = NULL,\n\t\t\t};\n\t\t}\n\t}\n\tif (0 == cores) {\n\t\tfree(cgpu);\n\t\tif (!prev_cgpu) {\n\t\t\tfree(knc);\n\t\t\tknc_trnsp_free(ctx);\n\t\t}\n\t\treturn false;\n\t}\n\n\tapplog(LOG_NOTICE, \"%s: Found ASIC with %d dies and %d cores\", repr, dies, cores);\n\n\t*cgpu = (struct cgpu_info) {\n\t\t.drv = &knc_titan_drv,\n\t\t.device_path = strdup(devpath),\n\t\t.set_device_funcs = knc_titan_set_device_funcs,\n\t\t.deven = DEV_ENABLED,\n\t\t.procs = dies,\n\t\t.threads = prev_cgpu ? 0 : 1,\n\t\t.extra_work_queue = -1,\n\t\t.device_data = knc,\n\t};\n\tconst bool rv = add_cgpu_slave(cgpu, prev_cgpu);\n\tif (!prev_cgpu) {\n\t\tcgpu->extra_work_queue += WORK_QUEUE_PREFILL - opt_queue;\n\t\tif (0 > cgpu->extra_work_queue)\n\t\t\tcgpu->extra_work_queue = 0;\n\t}\n\tprev_cgpu = cgpu;\n\treturn rv;\n}\n\nstatic int knc_titan_detect_auto(void)\n{\n\tconst int first = 0, last = KNC_TITAN_MAX_ASICS - 1;\n\tchar devpath[256];\n\tint found = 0, i;\n\n\tfor (i = first; i <= last; ++i) {\n\t\tsprintf(devpath, \"%d\", i);\n\t\tif (knc_titan_detect_one(devpath))\n\t\t\t++found;\n\t}\n\n\treturn found;\n}\n\nstatic void knc_titan_detect(void)\n{\n\tgeneric_detect(&knc_titan_drv, knc_titan_detect_one, knc_titan_detect_auto, GDF_REQUIRE_DNAME | GDF_DEFAULT_NOAUTO);\n}\n\nstatic void knc_titan_clean_flush(const char *repr, void * const ctx, struct knc_titan_core *knccore)\n{\n\tstruct knc_report report;\n\tbool unused;\n\tif (knc_titan_set_work(repr, ctx, knccore->asicno, knccore->dieno, knccore->coreno, 0, NULL, true, &unused, &report)) {\n\t\tknccore->last_nonce.slot = report.nonce[0].slot;\n\t\tknccore->last_nonce.nonce = report.nonce[0].nonce;\n\t}\n}\n\nstatic uint32_t nonce_tops[KNC_TITAN_CORES_PER_DIE];\nstatic bool nonce_tops_inited = false;\n\nstatic void get_nonce_range(int coreno, uint32_t *nonce_bottom, uint32_t *nonce_top)\n{\n\tif (!nonce_tops_inited) {\n\t\tuint32_t top;\n\t\tdouble nonce_f, nonce_step;\n\t\tint core;\n\n\t\tnonce_f = 0.0;\n\t\tnonce_step = 4294967296.0 / KNC_TITAN_CORES_PER_DIE;\n\n\t\tfor (core = 0; core < KNC_TITAN_CORES_PER_DIE; ++core) {\n\t\t\tnonce_f += nonce_step;\n\t\t\tif (core < (KNC_TITAN_CORES_PER_DIE - 1))\n\t\t\t\ttop = nonce_f;\n\t\t\telse\n\t\t\t\ttop = 0xFFFFFFFF;\n\t\t\tnonce_tops[core] = top;\n\t\t}\n\n\t\tnonce_tops_inited = true;\n\t}\n\n\t*nonce_top = nonce_tops[coreno];\n\tif (coreno > 0) {\n\t\t*nonce_bottom = nonce_tops[coreno - 1] + 1;\n\t\treturn;\n\t}\n\t*nonce_bottom = 0;\n}\n\nstatic bool configure_one_die(struct knc_titan_info *knc, int asic, int die)\n{\n\tstruct knc_titan_core *knccore;\n\tchar *repr;\n\tstruct knc_titan_die *die_p;\n\n\tif ((0 > asic) || (KNC_TITAN_MAX_ASICS <= asic) || (0 > die) || (KNC_TITAN_DIES_PER_ASIC <= die))\n\t\treturn false;\n\tdie_p = &(knc->dies[asic][die]);\n\tif (0 >= die_p->cores)\n\t\treturn false;\n\n\t/* Init nonce ranges for cores */\n\tstruct titan_setup_core_params setup_params = {\n\t\t.bad_address_mask = {0, 0},\n\t\t.bad_address_match = {0x3FF, 0x3FF},\n\t\t.difficulty = DEFAULT_DIFF_FILTERING_ZEROES - 1,\n\t\t.thread_enable = 0xFF,\n\t\t.thread_base_address = {0, 1, 2, 3, 4, 5, 6, 7},\n\t\t.lookup_gap_mask = {0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7},\n\t\t.N_mask = {0, 0, 0, 0, 0, 0, 0, 0},\n\t\t.N_shift = {0, 0, 0, 0, 0, 0, 0, 0},\n\t\t.nonce_bottom = 0,\n\t\t.nonce_top = 0xFFFFFFFF,\n\t};\n\tfill_in_thread_params(opt_knc_threads_per_core, &setup_params);\n\n\trepr = die_p->proc->device->dev_repr;\n\tbool success = true;\n\tfor (knccore = die_p->first_core ; knccore ; knccore = knccore->next_core) {\n\t\tknc_titan_clean_flush(repr, knc->ctx, knccore);\n\t\tget_nonce_range(knccore->coreno, &setup_params.nonce_bottom, &setup_params.nonce_top);\n\t\tapplog(LOG_DEBUG, \"%s[%d:%d:%d]: Setup core, nonces 0x%08X - 0x%08X\", repr, knccore->asicno, knccore->dieno, knccore->coreno, setup_params.nonce_bottom, setup_params.nonce_top);\n\t\tif (!knc_titan_setup_core_local(repr, knc->ctx, knccore->asicno, knccore->dieno, knccore->coreno, &setup_params))\n\t\t\tsuccess = false;\n\t}\n\tapplog(LOG_NOTICE, \"%s[%d-%d] Die configur%s\", repr, asic, die, success ? \"ed successfully\" : \"ation failed\");\n\tdie_p->need_flush = true;\n\ttimer_set_now(&(die_p->last_share));\n\tdie_p->broadcast_flushes = false;\n\tdie_p->manual_check_count = 0;\n\n\treturn true;\n}\n\nstatic\nfloat titan_min_nonce_diff(struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\treturn (malgo->algo == POW_SCRYPT) ? DEFAULT_DIFF_FILTERING_FLOAT : -1.;\n}\n\nstatic bool knc_titan_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu, *proc;\n\tstruct knc_titan_core *knccore;\n\tstruct knc_titan_die *kncdie;\n\tstruct knc_titan_info *knc;\n\tint i, asic = 0, logical_dieno = 0, ena_die, die;\n\tint total_cores = 0;\n\tint asic_cores[KNC_TITAN_MAX_ASICS] = {0};\n\n\tknc = cgpu->device_data;\n\n\tfor (proc = cgpu ; proc ; proc = proc->next_proc) {\n\t\tproc->device_data = knc;\n\t\tif (proc->device == proc) {\n\t\t\tasic = atoi(proc->device_path);\n\t\t\tlogical_dieno = 0;\n\t\t\tknc->asic_served_by_fpga[asic] = true;\n\t\t} else {\n\t\t\t++logical_dieno;\n\t\t}\n\t\tkncdie = NULL;\n\t\tfor (die = 0, ena_die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tif (knc->dies[asic][die].cores <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (ena_die++ == logical_dieno) {\n\t\t\t\tkncdie = &knc->dies[asic][die];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (NULL == kncdie) {\n\t\t\tapplog(LOG_ERR, \"Can not find logical dieno %d\", logical_dieno);\n\t\t\tcontinue;\n\t\t}\n\t\tkncdie->proc = proc;\n\t\t((struct thr_info *)proc->thr[0])->cgpu_data = kncdie;\n\t\tfor (i = 0 ; i < KNC_TITAN_CORES_PER_DIE ; i++) {\n\t\t\tif (i == 0) {\n\t\t\t\tkncdie->first_core = malloc(sizeof(*knccore));\n\t\t\t\tknccore = kncdie->first_core;\n\t\t\t} else {\n\t\t\t\tknccore->next_core = malloc(sizeof(*knccore));\n\t\t\t\tknccore = knccore->next_core;\n\t\t\t}\n\t\t\tif (unlikely(!knccore))\n\t\t\t\tquit(1, \"Failed to alloc knc_titan_core\");\n\t\t\t*knccore = (struct knc_titan_core) {\n\t\t\t\t.asicno = asic,\n\t\t\t\t.dieno = die,\n\t\t\t\t.coreno = i,\n\t\t\t\t.die = &(knc->dies[asic][die]),\n\t\t\t\t.hwerr_in_row = 0,\n\t\t\t\t.hwerr_disable_time = KNC_TITAN_HWERR_DISABLE_SECS,\n\t\t\t\t.need_manual_check = false,\n\t\t\t};\n\t\t\ttimer_set_now(&knccore->enable_at);\n\t\t\t++total_cores;\n\t\t\t++(asic_cores[asic]);\n\t\t}\n\t\tknccore->next_core = NULL;\n\t}\n\n\tknc->cores = total_cores;\n\n\tcgpu_set_defaults(cgpu);\n\tcgpu_setup_control_requests(cgpu);\n\tif (0 >= total_cores)\n\t\treturn false;\n\n\tknc = cgpu->device_data;\n\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n\t\tknc_titan_setup_spi(\"ASIC\", knc->ctx, asic, KNC_TITAN_FPGA_SPI_DIVIDER,\n\t\t\t\t    KNC_TITAN_FPGA_SPI_PRECLK, KNC_TITAN_FPGA_SPI_DECLK,\n\t\t\t\t    KNC_TITAN_FPGA_SPI_SSLOWMIN);\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tconfigure_one_die(knc, asic, die);\n\t\t\tknc->dies[asic][die].next_slot = KNC_TITAN_MIN_WORK_SLOT_NUM;\n\t\t\tknc->dies[asic][die].first_slot = KNC_TITAN_MIN_WORK_SLOT_NUM;\n\t\t}\n\t}\n\ttimer_set_now(&thr->tv_poll);\n\n\treturn true;\n}\n\nstatic bool die_test_and_add(struct knc_titan_info * const knc, int asic, int die, char * const errbuf)\n{\n\tstruct knc_die_info die_info;\n\tstruct knc_titan_die *die_p = &(knc->dies[asic][die]);\n\n\tdie_info.cores = KNC_TITAN_CORES_PER_DIE; /* core hint */\n\tdie_info.version = KNC_VERSION_TITAN;\n\tif (!knc_titan_get_info(LOG_INFO, knc->ctx, asic, die, &die_info))\n\t\tdie_info.cores = -1;\n\tif (0 < die_info.cores) {\n\t\tdie_p->add_request = 0;\n\t\tsprintf(errbuf, \"Die[%d:%d] not detected\", asic, die);\n\t\treturn false;\n\t}\n\n\t/* TODO: Implement add_request in knc_titan_poll */\n\tdie_p->add_request = die_info.cores;\n\tsprintf(errbuf, \"Die[%d:%d] has %d cores; was not added (addition not implemented)\", asic, die, die_info.cores);\n\n\treturn false;\n}\n\nstatic bool die_enable(struct knc_titan_info * const knc, int asic, int die, char * const errbuf)\n{\n\tbool res = true;\n\n\tif (0 >= knc->dies[asic][die].cores)\n\t\tres = die_test_and_add(knc, asic, die, errbuf);\n\tif (res) {\n\t\tstruct knc_titan_die *die_p = &(knc->dies[asic][die]);\n\t\tdie_p->reconfigure_request = true;\n\t\tres = true;\n\t}\n\n\treturn res;\n}\n\nstatic bool die_disable(struct knc_titan_info * const knc, int asic, int die, char * const errbuf)\n{\n\t/* TODO: Implement delete_request in knc_titan_poll */\n\tstruct knc_titan_die *die_p = &(knc->dies[asic][die]);\n\tdie_p->delete_request = true;\n\tcgpu_release_control(knc->cgpu);\n\tsprintf(errbuf, \"die_disable[%d:%d] not imnplemented\", asic, die);\n\treturn false;\n}\n\nstatic bool die_reconfigure(struct knc_titan_info * const knc, int asic, int die, char * const errbuf)\n{\n\treturn die_enable(knc, asic, die, errbuf);\n}\n\nstatic bool knc_titan_prepare_work(struct thr_info *thr, struct work *work)\n{\n\twork->nonce_diff = DEFAULT_DIFF_FILTERING_FLOAT;\n\treturn true;\n}\n\nstatic void knc_titan_set_queue_full(struct knc_titan_info * const knc)\n{\n\tconst bool full = (knc->workqueue_size >= knc->workqueue_max);\n\tstruct cgpu_info *proc;\n\n\tfor (proc = knc->cgpu; proc; proc = proc->next_proc) {\n\t\tstruct thr_info * const thr = proc->thr[0];\n\t\tthr->queue_full = full;\n\t}\n}\n\nstatic void knc_titan_remove_local_queue(struct knc_titan_info * const knc, struct work * const work)\n{\n\tDL_DELETE(knc->workqueue, work);\n\tfree_work(work);\n\t--knc->workqueue_size;\n}\n\nstatic void knc_titan_prune_local_queue(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_titan_info * const knc = cgpu->device_data;\n\tstruct work *work, *tmp;\n\n\tDL_FOREACH_SAFE(knc->workqueue, work, tmp) {\n\t\tif (stale_work(work, false))\n\t\t\tknc_titan_remove_local_queue(knc, work);\n\t}\n\tknc_titan_set_queue_full(knc);\n}\n\nstatic bool knc_titan_queue_append(struct thr_info * const thr, struct work * const work)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_titan_info * const knc = cgpu->device_data;\n\n\tif (knc->workqueue_size >= knc->workqueue_max) {\n\t\tknc_titan_prune_local_queue(thr);\n\t\tif (thr->queue_full)\n\t\t\treturn false;\n\t}\n\n\tDL_APPEND(knc->workqueue, work);\n\t++knc->workqueue_size;\n\n\tknc_titan_set_queue_full(knc);\n\tif (thr->queue_full)\n\t\tknc_titan_prune_local_queue(thr);\n\n\treturn true;\n}\n\n#define HASH_LAST_ADDED(head, out)  \\\n\t(out = (head) ? (ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail)) : NULL)\n\nstatic void knc_titan_queue_flush(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_titan_info * const knc = cgpu->device_data;\n\tstruct work *work, *tmp;\n\n\tif (knc->cgpu != cgpu)\n\t\treturn;\n\n\tDL_FOREACH_SAFE(knc->workqueue, work, tmp){\n\t\tknc_titan_remove_local_queue(knc, work);\n\t}\n\tknc_titan_set_queue_full(knc);\n\n\tHASH_LAST_ADDED(knc->devicework, work);\n\tif (work && stale_work(work, true)) {\n\t\tint asic, die;\n\t\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n\t\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\t\tknc->dies[asic][die].need_flush = true;\n\t\t\t}\n\t\t\tknc->asic_served_by_fpga[asic] = true;\n\t\t}\n\t\ttimer_set_now(&thr->tv_poll);\n\t}\n}\n\n#define\tMAKE_WORKID(asic, die, slot)\t((((uint32_t)(asic)) << 16) | ((uint32_t)(die) << 8) | ((uint32_t)(slot)))\n#define\tASIC_FROM_WORKID(workid)\t\t((((uint32_t)(workid)) >> 16) & 0xFF)\n#define\tDIE_FROM_WORKID(workid)\t\t\t((((uint32_t)(workid)) >> 8) & 0xFF)\n#define\tSLOT_FROM_WORKID(workid)\t\t(((uint32_t)(workid)) & 0xFF)\n\nstatic bool knc_titan_process_report(struct knc_titan_info * const knc, struct knc_titan_core * const knccore, struct knc_report * const report)\n{\n\tint i, tmp_int;\n\tstruct work *work;\n\tstruct cgpu_info * const proc = knccore->die->proc;\n\tbool ret = false;\n\n\tfor (i = 0; i < KNC_TITAN_NONCES_PER_REPORT; ++i) {\n\t\tif ((report->nonce[i].slot == knccore->last_nonce.slot) &&\n\t\t    (report->nonce[i].nonce == knccore->last_nonce.nonce))\n\t\t\tbreak;\n\t\tret = true;\n\t\ttmp_int = MAKE_WORKID(knccore->asicno, knccore->dieno, report->nonce[i].slot);\n\t\tHASH_FIND_INT(knc->devicework, &tmp_int, work);\n\t\tif (!work) {\n\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\"[%d:%d:%d]: Got nonce for unknown work in slot %u\", proc->proc_repr, knccore->asicno, knccore->dieno, knccore->coreno, (unsigned)report->nonce[i].slot);\n\t\t\tcontinue;\n\t\t}\n\t\tif (submit_nonce(proc->thr[0], work, report->nonce[i].nonce)) {\n\t\t\thashes_done2(proc->thr[0], DEFAULT_DIFF_HASHES_PER_NONCE, NULL);\n\t\t\tknc_titan_die_hashmeter(knccore->die, DEFAULT_DIFF_HASHES_PER_NONCE);\n\t\t\tknccore->hwerr_in_row = 0;\n\t\t}\n\t}\n\tknccore->last_nonce.slot = report->nonce[0].slot;\n\tknccore->last_nonce.nonce = report->nonce[0].nonce;\n\tknccore->need_manual_check = false;\n\t\n\treturn ret;\n}\n\nstatic void knc_titan_poll(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct knc_titan_info * const knc = cgpu->device_data;\n\tstruct knc_titan_core *knccore;\n\tstruct work *work, *tmp;\n\tint workaccept = 0;\n\tunsigned long delay_usecs = KNC_POLL_INTERVAL_US;\n\tstruct knc_report report;\n\tstruct knc_die_info die_info;\n\tint asic;\n\tint die;\n\tstruct knc_titan_die *die_p;\n\tstruct timeval tv_now;\n\tint num_request_busy;\n\tint num_status_byte_error[4];\n\tbool fpga_status_checked;\n\n\tknc_titan_prune_local_queue(thr);\n\n\t/* Process API requests */\n\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tdie_p = &(knc->dies[asic][die]);\n\t\t\tif (__sync_bool_compare_and_swap(&die_p->reconfigure_request, true, false)) {\n\t\t\t\tconfigure_one_die(knc, asic, die);\n\t\t\t}\n\t\t\tif (__sync_bool_compare_and_swap(&die_p->delete_request, true, false)) {\n\t\t\t\t/* TODO: Implement delete_request */\n\t\t\t}\n\t\t\tint add_cores = __sync_fetch_and_and(&die_p->add_request, 0);\n\t\t\tif (0 < add_cores) {\n\t\t\t\t/* TODO: Implement add_request */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send new works */\n\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n                fpga_status_checked = false;\n                num_request_busy = KNC_TITAN_DIES_PER_ASIC;\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tdie_p = &(knc->dies[asic][die]);\n\t\t\t/* make sure the running average buffers are updated even in the absence of found nonces */\n\t\t\tknc_titan_die_hashmeter(die_p, 0);\n\t\t\tif (0 >= die_p->cores)\n\t\t\t\tcontinue;\n\t\t\tstruct cgpu_info *die_proc = die_p->proc;\n\t\t\tDL_FOREACH_SAFE(knc->workqueue, work, tmp) {\n\t\t\t\tbool work_accepted = false;\n\t\t\t\tbool need_replace;\n\t\t\t\tif (die_p->first_slot > KNC_TITAN_MIN_WORK_SLOT_NUM)\n\t\t\t\t\tneed_replace = ((die_p->next_slot + 1) == die_p->first_slot);\n\t\t\t\telse\n\t\t\t\t\tneed_replace = (die_p->next_slot == KNC_TITAN_MAX_WORK_SLOT_NUM);\n\t\t\t\tif (die_p->need_flush || need_replace) {\n\t\t\t\t\tbool unused;\n\t\t\t\t\tif (die_p->broadcast_flushes) {\n\t\t\t\t\t\t/* Use broadcast */\n\t\t\t\t\t\tif (knc_titan_set_work(die_proc->device->dev_repr, knc->ctx, asic, die, ALL_CORES, die_p->next_slot, work, true, &unused, &report)) {\n\t\t\t\t\t\t\twork_accepted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Use FPGA accelerated unicasts */\n\t\t\t\t\t\tif (!fpga_status_checked) {\n\t\t\t\t\t\t\ttimer_set_now(&knc->tv_prev);\n\t\t\t\t\t\t\tknc_titan_get_work_status(die_proc->device->dev_repr, knc->ctx, asic, &num_request_busy, num_status_byte_error);\n\t\t\t\t\t\t\tfpga_status_checked = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (num_request_busy == 0) {\n\t\t\t\t\t\t\tif (knc_titan_set_work_parallel(die_proc->device->dev_repr, knc->ctx, asic, 1 << die, 0, die_p->next_slot, work, true, die_p->cores, KNC_TITAN_FPGA_RETRIES)) {\n\t\t\t\t\t\t\t\twork_accepted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (knc->asic_served_by_fpga[asic]) {\n\t\t\t\t\t\tknc_titan_get_work_status(die_proc->device->dev_repr, knc->ctx, asic, &num_request_busy, num_status_byte_error);\n\t\t\t\t\t\tif (num_request_busy == 0) {\n\t\t\t\t\t\t\ttimer_set_now(&tv_now);\n\t\t\t\t\t\t\tdouble diff = ((tv_now.tv_sec - knc->tv_prev.tv_sec) * 1000000.0 + (tv_now.tv_usec - knc->tv_prev.tv_usec)) / 1000000.0;\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"%s: Flush took %f secs for ASIC %d\", knc_titan_drv.dname, diff, asic);\n\t\t\t\t\t\t\tapplog(LOG_DEBUG, \"FPGA CRC error counters: %d %d %d %d\", num_status_byte_error[0], num_status_byte_error[1], num_status_byte_error[2], num_status_byte_error[3]);\n\t\t\t\t\t\t\tknc->asic_served_by_fpga[asic] = false;\n\n\t\t\t\t\t\t\tfor (int die2 = 0; die2 < KNC_TITAN_DIES_PER_ASIC; ++die2) {\n\t\t\t\t\t\t\t\tknc->dies[asic][die2].manual_check_count = KNC_TITAN_CORES_PER_DIE - MANUAL_CHECK_CORES_PER_POLL;\n\t\t\t\t\t\t\t\tfor (knccore = knc->dies[asic][die2].first_core ; knccore ; knccore = knccore->next_core)\n\t\t\t\t\t\t\t\t\tknccore->need_manual_check = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (knc->asic_served_by_fpga[asic] || !knc_titan_set_work(die_proc->dev_repr, knc->ctx, asic, die, ALL_CORES, die_p->next_slot, work, false, &work_accepted, &report))\n\t\t\t\t\t\twork_accepted = false;\n\t\t\t\t}\n\t\t\t\tknccore = die_proc->thr[0]->cgpu_data;\n\t\t\t\tif ((!work_accepted) || (NULL == knccore))\n\t\t\t\t\tbreak;\n\t\t\t\tbool was_flushed = false;\n\t\t\t\tif (die_p->need_flush || need_replace) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s[%d-%d] Flushing stale works (%s)\", die_proc->dev_repr, asic, die,\n\t\t\t\t\t       die_p->need_flush ? \"New work\" : \"Slot collision\");\n\t\t\t\t\tdie_p->need_flush = false;\n\t\t\t\t\tdie_p->first_slot = die_p->next_slot;\n\t\t\t\t\tdelay_usecs = 0;\n\t\t\t\t\twas_flushed = true;\n\t\t\t\t}\n\t\t\t\t--knc->workqueue_size;\n\t\t\t\tDL_DELETE(knc->workqueue, work);\n\t\t\t\twork->device_id = MAKE_WORKID(asic, die, die_p->next_slot);\n\t\t\t\tstruct work *work1, *tmp1;\n\t\t\t\tHASH_ITER(hh, knc->devicework, work1, tmp1) {\n\t\t\t\t\tif (work->device_id == work1->device_id) {\n\t\t\t\t\t\tHASH_DEL(knc->devicework, work1);\n\t\t\t\t\t\tfree_work(work1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tHASH_ADD(hh, knc->devicework, device_id, sizeof(work->device_id), work);\n\t\t\t\tif (++(die_p->next_slot) > KNC_TITAN_MAX_WORK_SLOT_NUM)\n\t\t\t\t\tdie_p->next_slot = KNC_TITAN_MIN_WORK_SLOT_NUM;\n\t\t\t\t++workaccept;\n\t\t\t\t/* If we know for sure that this work was urgent, then we don't need to hurry up\n\t\t\t\t * with filling next slot, we have plenty of time until current work completes.\n\t\t\t\t * So, better to proceed with other ASICs/dies. */\n\t\t\t\tif (was_flushed)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tapplog(LOG_DEBUG, \"%s: %d jobs accepted to queue (max=%d)\", knc_titan_drv.dname, workaccept, knc->workqueue_max);\n\ttimer_set_now(&tv_now);\n\n\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tdie_p = &(knc->dies[asic][die]);\n\t\t\tif (0 >= die_p->cores)\n\t\t\t\tcontinue;\n\t\t\tdie_info.cores = die_p->cores; /* core hint */\n\t\t\tdie_info.version = KNC_VERSION_TITAN;\n\t\t\tif (knc->asic_served_by_fpga[asic] || !knc_titan_get_info(LOG_DEBUG, knc->ctx, asic, die, &die_info))\n\t\t\t\tcontinue;\n\t\t\tthread_reportin(die_p->proc->thr[0]);\n\n\t\t\tfor (knccore = die_p->first_core ; knccore ; knccore = knccore->next_core) {\n\t\t\t\tif (!die_info.has_report[knccore->coreno])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!knc_titan_get_report(die_p->proc->proc_repr, knc->ctx, asic, die, knccore->coreno, &report))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (knc_titan_process_report(knc, knccore, &report))\n\t\t\t\t\ttimer_set_now(&(die_p->last_share));\n\t\t\t}\n\t\t}\n\n\t\t/* Check die health */\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tdie_p = &(knc->dies[asic][die]);\n\t\t\tif (0 >= die_p->cores)\n\t\t\t\tcontinue;\n\t\t\tif (timer_elapsed(&(die_p->last_share), &tv_now) < DIE_HEALTH_INTERVAL_SEC)\n\t\t\t\tcontinue;\n\t\t\t/* Reconfigure die */\n\t\t\tconfigure_one_die(knc, asic, die);\n\t\t}\n\t}\n\n\tfor (asic = 0; asic < KNC_TITAN_MAX_ASICS; ++asic) {\n\t\tfor (die = 0; die < KNC_TITAN_DIES_PER_ASIC; ++die) {\n\t\t\tdie_p = &(knc->dies[asic][die]);\n\t\t\tif (0 >= die_p->cores || die_p->manual_check_count < 0)\n\t\t\t\tcontinue;\n\n\t\t\tfor (knccore = die_p->first_core ; knccore ; knccore = knccore->next_core) {\n\t\t\t\tint core = knccore->coreno;\n\t\t\t\tif (core < die_p->manual_check_count)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (core >= die_p->manual_check_count + MANUAL_CHECK_CORES_PER_POLL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!knccore->need_manual_check)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!knc_titan_get_report(die_p->proc->proc_repr, knc->ctx, asic, die, knccore->coreno, &report))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (knc_titan_process_report(knc, knccore, &report))\n\t\t\t\t\ttimer_set_now(&(die_p->last_share));\n\t\t\t}\n\t\t\tif (die_p->manual_check_count == 0) {\n\t\t\t\tdie_p->manual_check_count = -1;\n\t\t\t} else {\n\t\t\t\tdie_p->manual_check_count -= MANUAL_CHECK_CORES_PER_POLL;\n\t\t\t\tif (die_p->manual_check_count < 0)\n\t\t\t\t\tdie_p->manual_check_count = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (workaccept) {\n\t\tif (workaccept >= knc->workqueue_max) {\n\t\t\tknc->workqueue_max = workaccept;\n\t\t\tdelay_usecs = 0;\n\t\t}\n\t\tknc_titan_set_queue_full(knc);\n\t}\n\n\ttimer_set_delay_from_now(&thr->tv_poll, delay_usecs);\n}\n\n/*\n * specify settings / options via RPC or command line\n */\n\n/* support for --set-device\n * must be set before probing the device\n */\nstatic void knc_titan_set_clock_freq(struct cgpu_info * const device, int const val)\n{\n}\n\nstatic const char *knc_titan_set_clock(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tknc_titan_set_clock_freq(device, atoi(setting));\n\treturn NULL;\n}\n\nstatic const char *knc_titan_die_ena(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tint asic, die;\n\tchar str[256];\n\n\t/* command format: ASIC:N;DIE:N;MODE:ENABLE|DISABLE|RECONFIGURE */\n\tif (3 != sscanf(setting, \"ASIC:%d;DIE:%d;MODE:%255s\", &asic, &die, str)) {\nerror_bad_params:\n\t\tsprintf(replybuf, \"Die setup failed, bad parameters\");\n\t\treturn replybuf;\n\t}\n\tif (0 == strncasecmp(str, \"enable\", sizeof(str) - 1)) {\n\t\tif (!die_enable(device->device_data, asic, die, replybuf))\n\t\t\treturn replybuf;\n\t} else if (0 == strncasecmp(str, \"disable\", sizeof(str) - 1)) {\n\t\tif (!die_disable(device->device_data, asic, die, replybuf))\n\t\t\treturn replybuf;\n\t} else if (0 == strncasecmp(str, \"reconfigure\", sizeof(str) - 1)) {\n\t\tif (!die_reconfigure(device->device_data, asic, die, replybuf)) {\n\t\t\t/* Do not return error on reconfigure command!\n\t\t\t * (or the whole bfgminer will be restarted) */\n\t\t\t*success = SDR_OK;\n\t\t\treturn replybuf;\n\t\t}\n\t} else\n\t\tgoto error_bad_params;\n\tsprintf(replybuf, \"Die setup Ok; asic %d die %d cmd %s\", asic, die, str);\n\t*success = SDR_OK;\n\treturn replybuf;\n}\n\nstatic const struct bfg_set_device_definition knc_titan_set_device_funcs[] = {\n\t{ \"clock\", knc_titan_set_clock, NULL },\n\t{ \"die\", knc_titan_die_ena, NULL },\n\t{ NULL },\n};\n\n/*\n * specify settings / options via TUI\n */\n\n#ifdef HAVE_CURSES\nstatic void knc_titan_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic const char *knc_titan_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstatic char buf[0x100];  /* Static for replies */\n\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tsprintf(buf, \"Set clock speed\");\n\t\t\tchar * const setting = curses_input(buf);\n\n\t\t\tknc_titan_set_clock_freq(proc->device, atoi(setting));\n\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void knc_titan_wlogprint_status(struct cgpu_info * const proc)\n{\n\twlogprint(\"Clock speed: N/A\\n\");\n}\n#endif\n\nstruct device_drv knc_titan_drv =\n{\n\t/* metadata */\n\t.dname = \"titan\",\n\t.name = \"KNC\",\n\t.drv_min_nonce_diff = titan_min_nonce_diff,\n\t.drv_detect = knc_titan_detect,\n\n\t.thread_init = knc_titan_init,\n\n\t/* specify mining type - queue */\n\t.minerloop = minerloop_queue,\n\t.queue_append = knc_titan_queue_append,\n\t.queue_flush = knc_titan_queue_flush,\n\t.poll = knc_titan_poll,\n\t.prepare_work = knc_titan_prepare_work,\n\n\t/* additional statistics */\n\t.get_proc_rolling_hashrate = knc_titan_get_die_rolling_hashrate,\n\t.zero_stats = knc_titan_zero_stats,\n\n\t/* TUI support - e.g. setting clock via UI */\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = knc_titan_wlogprint_status,\n\t.proc_tui_wlogprint_choices = knc_titan_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = knc_titan_tui_handle_choice,\n#endif\n};\n"
        },
        {
          "name": "driver-twinfury.c",
          "type": "blob",
          "size": 13.8310546875,
          "content": "/*\n * Copyright 2013 Andreas Auer\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n/*\n * Twin Bitfury USB miner with two Bitfury ASIC\n */\n\n#include \"config.h\"\n#include \"miner.h\"\n#include \"logging.h\"\n#include \"util.h\"\n\n#include \"libbitfury.h\"\n#include \"lowlevel.h\"\n#include \"lowl-vcom.h\"\n#include \"deviceapi.h\"\n#include \"sha2.h\"\n\n#include \"driver-twinfury.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <pthread.h>\n\nBFG_REGISTER_DRIVER(twinfury_drv)\n\nstatic const uint8_t PREAMBLE[] = { 0xDE, 0xAD, 0xBE, 0xEF };\n\n//------------------------------------------------------------------------------\nstatic\nbool twinfury_send_command(const int fd, const void * const tx, const uint16_t tx_size)\n{\n\tif (opt_dev_protocol)\n\t{\n\t\tchar hex[((4 + tx_size) * 2) + 1];\n\t\tbin2hex(hex, PREAMBLE, 4);\n\t\tbin2hex(&hex[8], tx, tx_size);\n\t\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: SEND: %s\", twinfury_drv.dname, fd, hex);\n\t}\n\t\n\tif(4 != write(fd, PREAMBLE, 4))\n\t{\n\t\treturn false;\n\t}\n\n\tif(tx_size != write(fd, tx, tx_size))\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic\nint16_t twinfury_wait_response(const int fd, const void * const rx, const uint16_t rx_size)\n{\n\tint16_t rx_len;\n\tint timeout = 20;\n\n\twhile(timeout > 0)\n\t{\n\t\trx_len = serial_read(fd, rx, rx_size);\n\t\tif(rx_len > 0)\n\t\t\tbreak;\n\n\t\ttimeout--;\n\t}\n\n\tif (opt_dev_protocol)\n\t{\n\t\tchar hex[(rx_len * 2) + 1];\n\t\tbin2hex(hex, rx, rx_len);\n\t\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: RECV(%u=>%d): %s\", twinfury_drv.dname, fd, rx_size, rx_len, hex);\n\t}\n\t\n\tif(unlikely(timeout == 0))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn rx_len;\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_detect_custom(const char *devpath, struct device_drv *api, struct twinfury_info *info)\n{\n\tint fd = serial_open(devpath, info->baud, 1, true);\n\n\tif(fd < 0)\n\t{\n\t\treturn false;\n\t}\n\n\tchar buf[1024];\n\tint16_t len;\n\n\tapplog(LOG_DEBUG, \"%s: Probing for Twinfury device %s\", twinfury_drv.dname, devpath);\n\tserial_read(fd, buf, sizeof(buf));\n\tif (!twinfury_send_command(fd, \"I\", 1))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed writing id request to %s\",\n\t\t       twinfury_drv.dname, devpath);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\tlen = twinfury_wait_response(fd, buf, sizeof(buf));\n\tif(len != 29)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Not a valid response from device (%d)\", twinfury_drv.dname, len);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\n\tinfo->id.version = buf[1];\n\tmemcpy(info->id.product, buf+2, 16);\n\tbin2hex(info->id.serial, buf+18, 11);\n\tapplog(LOG_DEBUG, \"%s: %s: %d, %s %s\",\n\t       twinfury_drv.dname,\n\t       devpath,\n\t       info->id.version, info->id.product,\n\t       info->id.serial);\n\n\tchar buf_state[sizeof(struct twinfury_state)+1];\n\tif (!twinfury_send_command(fd, \"R\", 1))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed writing reset request to %s\",\n\t\t       twinfury_drv.dname, devpath);\n\t\tserial_close(fd);\n\t\treturn false;\n\t}\n\tlen = 0;\n\twhile(len == 0)\n\t{\n\t\tlen = serial_read(fd, buf, sizeof(buf_state));\n\t\tcgsleep_ms(100);\n\t}\n\tserial_close(fd);\n\n\tif(len != 8)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: %s not responding to reset: %d\",\n\t\t       twinfury_drv.dname,\n\t\t       devpath, len);\n\t\treturn false;\n\t}\n\n\tif (serial_claim_v(devpath, api))\n\t\treturn false;\n\n\tstruct cgpu_info *bigpic;\n\tbigpic = calloc(1, sizeof(struct cgpu_info));\n\tbigpic->drv = api;\n\tbigpic->device_path = strdup(devpath);\n\tbigpic->device_fd = -1;\n\tbigpic->threads = 1;\n\tbigpic->procs = 2;\n\tadd_cgpu(bigpic);\n\n\tapplog(LOG_INFO, \"Found %\"PRIpreprv\" at %s\", bigpic->proc_repr, devpath);\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Init: baud=%d\",\n\t\tbigpic->proc_repr, info->baud);\n\n\tbigpic->device_data = info;\n\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_detect_one(const char *devpath)\n{\n\tstruct twinfury_info *info = calloc(1, sizeof(struct twinfury_info));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc bigpicInfo\");\n\n\tinfo->baud = BPM_BAUD;\n\n\tif (!twinfury_detect_custom(devpath, &twinfury_drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_product(info, \"Twinfury\");\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, twinfury_detect_one);\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_init(struct thr_info *thr)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\tstruct twinfury_info *info = (struct twinfury_info *)cgpu->device_data;\n\tstruct cgpu_info *proc;\n\tint i=0;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": init\", cgpu->proc_repr);\n\n\tint fd = serial_open(cgpu->device_path, info->baud, 1, true);\n\tif (unlikely(-1 == fd))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to open %s\",\n\t\t\t\tcgpu->proc_repr, cgpu->device_path);\n\t\treturn false;\n\t}\n\n\tcgpu->device_fd = fd;\n\n\tapplog(LOG_INFO, \"%\"PRIpreprv\": Opened %s\", cgpu->proc_repr, cgpu->device_path);\n\n\tinfo->tx_buffer[0] = 'W';\n\n\tif(info->id.version == 2)\n\t{\n\t\tchar buf[8] = \"V\\x00\\x00\";\n\t\tif(twinfury_send_command(fd, buf, 3))\n\t\t{\n\t\t\tif(8 == twinfury_wait_response(fd, buf, 8))\n\t\t\t{\n\t\t\t\tinfo->voltage  =  (buf[4] & 0xFF);\n\t\t\t\tinfo->voltage |=  (buf[5] << 8);\n\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Voltage: %dmV\", cgpu->dev_repr, info->voltage);\n\t\t\t\tif(info->voltage < 800 || info->voltage > 950)\n\t\t\t\t{\n\t\t\t\t\tinfo->voltage = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to get voltage.\", cgpu->dev_repr);\n\t\t\t\tinfo->voltage = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to send voltage request\", cgpu->dev_repr);\n\t\t}\n\t}\n\n\tfor(i=1, proc = cgpu->next_proc; proc; proc = proc->next_proc, i++)\n\t{\n\t\tstruct twinfury_info *data = malloc(sizeof(struct twinfury_info));\n\t\t*data = *info;\n\t\tproc->device_data = data;\n\t\tdata->tx_buffer[1] = i;\n\t}\n\t\n\ttimer_set_now(&thr->tv_poll);\n\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_process_results(struct cgpu_info * const proc)\n{\n\tstruct twinfury_info *device = proc->device_data;\n\tuint8_t *rx_buffer = device->rx_buffer;\n\tint16_t rx_len = device->rx_len;\n\n\tstruct work *work = proc->thr[0]->work;\n\n\tif(rx_len == 0 || rx_len == -1)\n\t{\n\t\treturn false;\n\t}\n\n\tif(rx_buffer[3] == 0)\n\t{\n\t\treturn false;\n\t}\n\n\tif(!work)\n\t{\n\t\treturn true;\n\t}\n\n\tuint32_t m7    = *((uint32_t *)&work->data[64]);\n\tuint32_t ntime = *((uint32_t *)&work->data[68]);\n\tuint32_t nbits = *((uint32_t *)&work->data[72]);\n\n\tint j=0;\n\tfor(j=0; j<rx_len; j+= 8)\n\t{\n\t\tstruct twinfury_state state;\n\t\tstate.chip = rx_buffer[j + 1];\n\t\tstate.state = rx_buffer[j + 2];\n\t\tstate.switched = rx_buffer[j + 3];\n\t\tmemcpy(&state.nonce, rx_buffer + j + 4, 4);\n\n\t\tuint32_t nonce = bitfury_decnonce(state.nonce);\n\t\tif((nonce & 0xFFC00000) != 0xdf800000)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Len: %lu Cmd: %c Chip: %d State: %c Switched: %d Nonce: %08lx\",\n\t\t\t\t\tproc->proc_repr,\n\t\t\t\t   (unsigned long)rx_len, rx_buffer[j], state.chip, state.state, state.switched, (unsigned long)nonce);\n\t\t\tif (bitfury_fudge_nonce(work->midstate, m7, ntime, nbits, &nonce))\n\t\t\t\tsubmit_nonce(proc->thr[0], work, nonce);\n\t\t\telse\n\t\t\t\tinc_hw_errors(proc->thr[0], work, nonce);\n\t\t}\n\t}\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nint64_t twinfury_job_process_results(struct thr_info *thr, struct work *work, bool stopping)\n{\n\t// Bitfury chips process only 768/1024 of the nonce range\n\treturn 0xbd000000;\n}\n\n//------------------------------------------------------------------------------\nstatic\nbool twinfury_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info *board = thr->cgpu;\n\tstruct twinfury_info *info = (struct twinfury_info *)board->device_data;\n\n\tmemcpy(&info->tx_buffer[ 2], work->midstate, 32);\n\tmemcpy(&info->tx_buffer[34], &work->data[64], 12);\n\n\twork->blk.nonce = 0xffffffff;\n\treturn true;\n}\n\n//------------------------------------------------------------------------------\nstatic\nvoid twinfury_poll(struct thr_info *thr)\n{\n\tstruct cgpu_info * const dev = thr->cgpu;\n\tstruct twinfury_info *info = dev->device_data;\n\n\tuint8_t n_chips = 0;\n\tuint8_t buffer[2] = { 'Q', 0 };\n\n\tuint8_t response[8];\n\tbool flashed = false;\n\n\tif(info->send_voltage)\n\t{\n\t\tchar buf[8] = \"V\";\n\t\tbuf[1] = info->voltage & 0xFF;\n\t\tbuf[2] = (info->voltage >> 8) & 0xFF;\n\t\tif(!twinfury_send_command(dev->device_fd, buf, 3))\n\t\t\tapplog(LOG_ERR, \"%s: Failed supply voltage\", dev->dev_repr);\n\t\telse\n\t\tif(8 != twinfury_wait_response(dev->device_fd, buf, 8))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Waiting for response timed out (Supply voltage)\", dev->dev_repr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinfo->voltage  =  (buf[4] & 0xFF);\n\t\t\tinfo->voltage |=  (buf[5] << 8);\n\t\t}\n\t\tinfo->send_voltage = false;\n\t}\n\n\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc, ++n_chips)\n\t{\n\t\tstruct thr_info * const proc_thr = proc->thr[0];\n\t\tstruct twinfury_info *info = (struct twinfury_info *)proc->device_data;\n\t\t\n\t\tif (proc->flash_led)\n\t\t{\n\t\t\tif (flashed)\n\t\t\t\tproc->flash_led = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buf[] = \"L\";\n\t\t\t\t\n\t\t\t\tif(!twinfury_send_command(dev->device_fd, buf, 1))\n\t\t\t\t\tapplog(LOG_ERR, \"%s: Failed writing flash LED\", dev->dev_repr);\n\t\t\t\telse\n\t\t\t\tif(1 != twinfury_wait_response(dev->device_fd, buf, 1))\n\t\t\t\t\tapplog(LOG_ERR, \"%s: Waiting for response timed out (Flash LED)\", dev->dev_repr);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tflashed = true;\n\t\t\t\t\tproc->flash_led = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbuffer[1] = n_chips;\n\n\t\tif(!twinfury_send_command(dev->device_fd, buffer, 2))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed writing work task\", proc->proc_repr);\n\t\t\tdev_error(dev, REASON_DEV_COMMS_ERROR);\n\t\t\treturn;\n\t\t}\n\n\t\tinfo->rx_len = twinfury_wait_response(dev->device_fd, info->rx_buffer, sizeof(info->rx_buffer));\n\t\tif(unlikely(info->rx_len == -1))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Query timeout\", proc->proc_repr);\n\t\t}\n\n\t\tif(twinfury_process_results(proc) && proc_thr->next_work)\n\t\t{\n\t\t\tmt_job_transition(proc_thr);\n\t\t\t// TODO: Delay morework until right before it's needed\n\t\t\ttimer_set_now(&proc_thr->tv_morework);\n\t\t\tjob_start_complete(proc_thr);\n\t\t}\n\t}\n\n\tbuffer[0] = 'T';\n\tif(twinfury_send_command(dev->device_fd, buffer, 1))\n\t{\n\t\tif(8 == twinfury_wait_response(dev->device_fd, response, 8))\n\t\t{\n\t\t\tif(response[0] == buffer[0])\n\t\t\t{\n\t\t\t\tconst float temp = ((uint16_t)response[4] | (uint16_t)(response[5] << 8)) / 10.0;\n\t\t\t\tfor (struct cgpu_info *proc = dev; proc; proc = proc->next_proc)\n\t\t\t\t\tproc->temp = temp;\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Temperature: %f\", dev->dev_repr, temp);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": No temperature response\", dev->dev_repr);\n\t\t}\n\t}\n\n\ttimer_set_delay_from_now(&thr->tv_poll, 250000);\n}\n\n//------------------------------------------------------------------------------\nstatic\nvoid twinfury_job_start(struct thr_info *thr)\n{\n\tstruct cgpu_info *board = thr->cgpu;\n\tstruct twinfury_info *info = (struct twinfury_info *)board->device_data;\n\tint device_fd = thr->cgpu->device->device_fd;\n\n\tuint8_t buffer[8];\n\tint16_t len;\n\n\tif(!twinfury_send_command(device_fd, info->tx_buffer, 46))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed writing work task\", board->proc_repr);\n\t\tdev_error(board, REASON_DEV_COMMS_ERROR);\n\t\tjob_start_abort(thr, true);\n\t\treturn;\n\t}\n\n\tlen = twinfury_wait_response(device_fd, buffer, 8);\n\tif(unlikely(len == -1))\n\t{\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Work send timeout.\", board->proc_repr);\n\t}\n}\n\n//------------------------------------------------------------------------------\nstatic void twinfury_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\n\tserial_close(cgpu->device_fd);\n}\n\n//------------------------------------------------------------------------------\nstatic bool twinfury_identify(struct cgpu_info *cgpu)\n{\n\tcgpu->flash_led = 1;\n\n\treturn true;\n}\n\n#ifdef HAVE_CURSES\nvoid twinfury_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\tstruct twinfury_info * const state = proc->device->device_data;\n\tif(state->id.version > 1)\n\t{\n\t\twlogprint(\"[V]oltage \");\n\t}\n}\n\nconst char *twinfury_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstruct twinfury_info * const state = proc->device->device_data;\n\n\tif(state->id.version > 1)\n\t{\n\t\tswitch (input)\n\t\t{\n\t\t\tcase 'v': case 'V':\n\t\t\t{\n\t\t\t\tconst int val = curses_int(\"Set supply voltage (range 800mV-950mV; slow to fast)\");\n\t\t\t\tif (val < 800 || val > 950)\n\t\t\t\t\treturn \"Invalid supply voltage value\\n\";\n\n\t\t\t\tstate->voltage = val;\n\t\t\t\tstate->send_voltage = true;\n\n\t\t\t\treturn \"Supply voltage changing\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid twinfury_wlogprint_status(struct cgpu_info * const proc)\n{\n\tconst struct twinfury_info * const state = proc->device->device_data;\n\tif(state->id.version > 1)\n\t\twlogprint(\"Supply voltage: %dmV\\n\", state->voltage);\n}\n#endif\n\n//------------------------------------------------------------------------------\nstruct device_drv twinfury_drv = {\n        //lowercase driver name so --scan pattern matching works\n\t.dname = \"twinfury\",\n\t.name = \"TBF\",\n\t.probe_priority = -111,\n\n\t.lowl_match = twinfury_lowl_match,\n\t.lowl_probe = twinfury_lowl_probe,\n\n\t.identify_device = twinfury_identify,\n\n\t.thread_init = twinfury_init,\n\n\t.minerloop = minerloop_async,\n\n\t.job_prepare = twinfury_job_prepare,\n\t.job_start = twinfury_job_start,\n\t.poll = twinfury_poll,\n\t.job_process_results = twinfury_job_process_results,\n\n\t.thread_shutdown = twinfury_shutdown,\n\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = twinfury_wlogprint_status,\n\t.proc_tui_wlogprint_choices = twinfury_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = twinfury_tui_handle_choice,\n#endif\n\n};\n"
        },
        {
          "name": "driver-twinfury.h",
          "type": "blob",
          "size": 0.5986328125,
          "content": "#ifndef BFG_DRIVER_TWINFURY_H\n#define BFG_DRIVER_TWINFURY_H\n\n#define BPM_BAUD\t115200\n\n#define NUM_BITFURY_CHIPS\t2\n\nstruct twinfury_identity\n{\n\tuint8_t version;\n\tchar    product[16];\n\tchar    serial[23];\n} __attribute__((packed));\n\nstruct twinfury_state\n{\n    uint8_t chip;\n    uint8_t state;\n    uint8_t switched;\n    uint32_t nonce;\n} __attribute__((packed));\n\nstruct twinfury_info\n{\n\tuint32_t baud;\n\n\tstruct work *prev_work;\n\tstruct work *work;\n\tbool work_sent;\n\tstruct twinfury_identity id;\n\n\tuint8_t tx_buffer[46];\n\tuint8_t rx_buffer[1024];\n\tint16_t rx_len;\n\n\tuint32_t voltage;\n\tbool send_voltage;\n};\n\n#endif\n"
        },
        {
          "name": "driver-x6500.c",
          "type": "blob",
          "size": 22.0595703125,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2013 Nate Woolls\n * Copyright 2012 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#include <libusb.h>\n\n#include \"binloader.h\"\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"dynclock.h\"\n#include \"jtag.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"lowlevel.h\"\n#include \"lowl-ftdi.h\"\n#include \"lowl-usb.h\"\n\n#define X6500_USB_PRODUCT \"X6500 FPGA Miner\"\n#define X6500_BITSTREAM_FILENAME \"fpgaminer_x6500-overclocker-0402.bit\"\n// NOTE: X6500_BITSTREAM_USERID is bitflipped\n#define X6500_BITSTREAM_USERID \"\\x40\\x20\\x24\\x42\"\n#define X6500_MINIMUM_CLOCK    2\n#define X6500_DEFAULT_CLOCK  190\n#define X6500_MAXIMUM_CLOCK  250\n\nBFG_REGISTER_DRIVER(x6500_api)\n\n#define fromlebytes(ca, j)  (ca[j] | (((uint16_t)ca[j+1])<<8) | (((uint32_t)ca[j+2])<<16) | (((uint32_t)ca[j+3])<<24))\n\nstatic\nvoid int2bits(uint32_t n, uint8_t *b, uint8_t bits)\n{\n\tuint8_t i;\n\tfor (i = (bits + 7) / 8; i > 0; )\n\t\tb[--i] = 0;\n\tfor (i = 0; i < bits; ++i) {\n\t\tif (n & 1)\n\t\t\tb[i/8] |= 0x80 >> (i % 8);\n\t\tn >>= 1;\n\t}\n}\n\nstatic\nuint32_t bits2int(uint8_t *b, uint8_t bits)\n{\n\tuint32_t n, i;\n\tn = 0;\n\tfor (i = 0; i < bits; ++i)\n\t\tif (b[i/8] & (0x80 >> (i % 8)))\n\t\t\tn |= 1<<i;\n\treturn n;\n}\n\nstatic\nvoid checksum(uint8_t *b, uint8_t bits)\n{\n\tuint8_t i;\n\tuint8_t checksum = 1;\n\tfor(i = 0; i < bits; ++i)\n\t\tchecksum ^= (b[i/8] & (0x80 >> (i % 8))) ? 1 : 0;\n\tif (checksum)\n\t\tb[i/8] |= 0x80 >> (i % 8);\n}\n\nstatic\nvoid x6500_jtag_set(struct jtag_port *jp, uint8_t pinoffset)\n{\n\tjp->tck = pinoffset << 3;\n\tjp->tms = pinoffset << 2;\n\tjp->tdi = pinoffset << 1;\n\tjp->tdo = pinoffset << 0;\n\tjp->ignored = ~(jp->tdo | jp->tdi | jp->tms | jp->tck);\n}\n\nstatic uint32_t x6500_get_register(struct jtag_port *jp, uint8_t addr);\n\nstatic\nvoid x6500_set_register(struct jtag_port *jp, uint8_t addr, uint32_t nv)\n{\n\tuint8_t buf[38];\nretry:\n\tjtag_write(jp, JTAG_REG_IR, \"\\x40\", 6);\n\tint2bits(nv, &buf[0], 32);\n\tint2bits(addr, &buf[4], 4);\n\tbuf[4] |= 8;\n\tchecksum(buf, 37);\n\tjtag_write(jp, JTAG_REG_DR, buf, 38);\n\tjtag_run(jp);\n#ifdef DEBUG_X6500_SET_REGISTER\n\tif (x6500_get_register(jp, addr) != nv)\n#else\n\tif (0)\n#endif\n\t{\n\t\tapplog(LOG_WARNING, \"x6500_set_register failed %x=%08x\", addr, nv);\n\t\tgoto retry;\n\t}\n}\n\nstatic\nuint32_t x6500_get_register(struct jtag_port *jp, uint8_t addr)\n{\n\tuint8_t buf[4] = {0};\n\tjtag_write(jp, JTAG_REG_IR, \"\\x40\", 6);\n\tint2bits(addr, &buf[0], 4);\n\tchecksum(buf, 5);\n\tjtag_write(jp, JTAG_REG_DR, buf, 6);\n\tjtag_read (jp, JTAG_REG_DR, buf, 32);\n\tjtag_reset(jp);\n\treturn bits2int(buf, 32);\n}\n\nstatic\nbool x6500_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_ft232r, X6500_USB_PRODUCT);\n}\n\nstatic\nbool x6500_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tconst char * const product = info->product;\n\tconst char * const serial = info->serial;\n\tif (info->lowl != &lowl_ft232r)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tif (info->lowl != &lowl_usb)\n\t\t\tapplog(LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not ft232r!\",\n\t\t\t       __func__, product, serial);\n\t\treturn false;\n\t}\n\t\n\tlibusb_device * const dev = info->lowl_data;\n\tif (bfg_claim_libusb(&x6500_api, true, dev))\n\t\treturn false;\n\t\n\tstruct cgpu_info *x6500;\n\tx6500 = calloc(1, sizeof(*x6500));\n\tx6500->drv = &x6500_api;\n\tx6500->device_path = strdup(serial);\n\tx6500->deven = DEV_ENABLED;\n\tx6500->threads = 1;\n\tx6500->procs = 2;\n\tx6500->name = strdup(product);\n\tx6500->cutofftemp = 85;\n\tx6500->device_data = lowlevel_ref(info);\n\tcgpu_copy_libusb_strings(x6500, dev);\n\n\treturn add_cgpu(x6500);\n}\n\nstatic bool x6500_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\t\n\tif (x6500->proc_id)\n\t\treturn true;\n\t\n\tstruct ft232r_device_handle *ftdi = ft232r_open(x6500->device_data);\n\tlowlevel_devinfo_free(x6500->device_data);\n\tx6500->device_ft232r = NULL;\n\tif (!ftdi)\n\t\treturn false;\n\tif (!ft232r_set_bitmode(ftdi, 0xee, 4))\n\t\treturn false;\n\tif (!ft232r_purge_buffers(ftdi, FTDI_PURGE_BOTH))\n\t\treturn false;\n\tx6500->device_ft232r = ftdi;\n\t\n\tstruct jtag_port_a *jtag_a;\n\tunsigned char *pdone = calloc(1, sizeof(*jtag_a) + 1);\n\t*pdone = 101;\n\tjtag_a = (void*)(pdone + 1);\n\tjtag_a->ftdi = ftdi;\n\tx6500->device_data = jtag_a;\n\t\n\tfor (struct cgpu_info *slave = x6500->next_proc; slave; slave = slave->next_proc)\n\t{\n\t\tslave->device_ft232r = x6500->device_ft232r;\n\t\tslave->device_data = x6500->device_data;\n\t}\n\t\n\treturn true;\n}\n\nstruct x6500_fpga_data {\n\tstruct jtag_port jtag;\n\tstruct timeval tv_hashstart;\n\tint64_t hashes_left;\n\n\tstruct dclk_data dclk;\n\tuint8_t freqMaxMaxM;\n\n\t// Time the clock was last reduced due to temperature\n\tstruct timeval tv_last_cutoff_reduced;\n\n\tuint32_t prepwork_last_register;\n};\n\n#define bailout2(...) do {  \\\n\tapplog(__VA_ARGS__);  \\\n\treturn false;  \\\n} while(0)\n\nstatic bool\nx6500_fpga_upload_bitstream(struct cgpu_info *x6500, struct jtag_port *jp1)\n{\n\tchar buf[0x100];\n\tunsigned long len, flen;\n\tunsigned char *pdone = (unsigned char*)x6500->device_data - 1;\n\tstruct ft232r_device_handle *ftdi = jp1->a->ftdi;\n\n\tFILE *f = open_xilinx_bitstream(x6500->drv->dname, x6500->dev_repr, X6500_BITSTREAM_FILENAME, &len);\n\tif (!f)\n\t\treturn false;\n\n\tflen = len;\n\n\tapplog(LOG_WARNING, \"%s: Programming %s...\",\n\t       x6500->dev_repr, x6500->device_path);\n\tx6500->status = LIFE_INIT2;\n\t\n\t// \"Magic\" jtag_port configured to access both FPGAs concurrently\n\tstruct jtag_port jpt = {\n\t\t.a = jp1->a,\n\t};\n\tstruct jtag_port *jp = &jpt;\n\tuint8_t i, j;\n\tx6500_jtag_set(jp, 0x11);\n\t\n\t// Need to reset here despite previous FPGA state, since we are programming all at once\n\tjtag_reset(jp);\n\t\n\tjtag_write(jp, JTAG_REG_IR, \"\\xd0\", 6);  // JPROGRAM\n\t// Poll each FPGA status individually since they might not be ready at the same time\n\tfor (j = 0; j < 2; ++j) {\n\t\tx6500_jtag_set(jp, j ? 0x10 : 1);\n\t\tdo {\n\t\t\ti = 0xd0;  // Re-set JPROGRAM while reading status\n\t\t\tjtag_read(jp, JTAG_REG_IR, &i, 6);\n\t\t} while (i & 8);\n\t\tapplog(LOG_DEBUG, \"%s%c: JPROGRAM ready\",\n\t\t       x6500->dev_repr, 'a' + j);\n\t}\n\tx6500_jtag_set(jp, 0x11);\n\tjtag_write(jp, JTAG_REG_IR, \"\\xa0\", 6);  // CFG_IN\n\t\n\tcgsleep_ms(1000);\n\t\n\tif (fread(buf, 32, 1, f) != 1)\n\t\tbailout2(LOG_ERR, \"%s: File underrun programming %s (%lu bytes left)\", x6500->dev_repr, x6500->device_path, len);\n\tjtag_swrite(jp, JTAG_REG_DR, buf, 256);\n\tlen -= 32;\n\t\n\t// Put ft232r chip in asynchronous bitbang mode so we don't need to read back tdo\n\t// This takes upload time down from about an hour to about 3 minutes\n\tif (!ft232r_set_bitmode(ftdi, 0xee, 1))\n\t\treturn false;\n\tif (!ft232r_purge_buffers(ftdi, FTDI_PURGE_BOTH))\n\t\treturn false;\n\tjp->a->bufread = 0;\n\tjp->a->async = true;\n\n\tssize_t buflen;\n\tchar nextstatus = 25;\n\twhile (len) {\n\t\tbuflen = len < 32 ? len : 32;\n\t\tif (fread(buf, buflen, 1, f) != 1)\n\t\t\tbailout2(LOG_ERR, \"%s: File underrun programming %s (%lu bytes left)\", x6500->dev_repr, x6500->device_path, len);\n\t\tjtag_swrite_more(jp, buf, buflen * 8, len == (unsigned long)buflen);\n\t\t*pdone = 100 - ((len * 100) / flen);\n\t\tif (*pdone >= nextstatus)\n\t\t{\n\t\t\tnextstatus += 25;\n\t\t\tapplog(LOG_WARNING, \"%s: Programming %s... %d%% complete...\", x6500->dev_repr, x6500->device_path, *pdone);\n\t\t}\n\t\tlen -= buflen;\n\t}\n\t\n\t// Switch back to synchronous bitbang mode\n\tif (!ft232r_set_bitmode(ftdi, 0xee, 4))\n\t\treturn false;\n\tif (!ft232r_purge_buffers(ftdi, FTDI_PURGE_BOTH))\n\t\treturn false;\n\tjp->a->bufread = 0;\n\tjp->a->async = false;\n\tjp->a->bufread = 0;\n\n\tjtag_write(jp, JTAG_REG_IR, \"\\x30\", 6);  // JSTART\n\tfor (i=0; i<16; ++i)\n\t\tjtag_run(jp);\n\ti = 0xff;  // BYPASS\n\tjtag_read(jp, JTAG_REG_IR, &i, 6);\n\tif (!(i & 4))\n\t\treturn false;\n\t\n\tapplog(LOG_WARNING, \"%s: Done programming %s\", x6500->dev_repr, x6500->device_path);\n\t*pdone = 101;\n\n\treturn true;\n}\n\nstatic bool x6500_change_clock(struct thr_info *thr, int multiplier)\n{\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tstruct jtag_port *jp = &fpga->jtag;\n\n\tx6500_set_register(jp, 0xD, multiplier * 2);\n\tft232r_flush(jp->a->ftdi);\n\tfpga->dclk.freqM = multiplier;\n\n\treturn true;\n}\n\nstatic bool x6500_dclk_change_clock(struct thr_info *thr, int multiplier)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tuint8_t oldFreq = fpga->dclk.freqM;\n\n\tif (!x6500_change_clock(thr, multiplier)) {\n\t\treturn false;\n\t}\n\n\tdclk_msg_freqchange(x6500->proc_repr, oldFreq * 2, fpga->dclk.freqM * 2, NULL);\n\treturn true;\n}\n\nstatic bool x6500_thread_init(struct thr_info *thr)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\tstruct ft232r_device_handle *ftdi = x6500->device_ft232r;\n\n\tcgpu_setup_control_requests(x6500);\n\t\n\t// This works because x6500_thread_init is only called for the first processor now that they're all using the same thread\n\tfor ( ; x6500; x6500 = x6500->next_proc)\n\t{\n\t\tthr = x6500->thr[0];\n\n\tstruct x6500_fpga_data *fpga;\n\tstruct jtag_port *jp;\n\tint fpgaid = x6500->proc_id;\n\tuint8_t pinoffset = fpgaid ? 0x10 : 1;\n\tunsigned char buf[4] = {0};\n\tint i;\n\t\n\tif (!ftdi)\n\t\treturn false;\n\t\n\tfpga = calloc(1, sizeof(*fpga));\n\tjp = &fpga->jtag;\n\tjp->a = x6500->device_data;\n\tx6500_jtag_set(jp, pinoffset);\n\tthr->cgpu_data = fpga;\n\tx6500->status = LIFE_INIT2;\n\t\n\tif (!jtag_reset(jp)) {\n\t\tapplog(LOG_ERR, \"%s: JTAG reset failed\",\n\t\t       x6500->dev_repr);\n\t\treturn false;\n\t}\n\t\n\ti = jtag_detect(jp);\n\tif (i != 1) {\n\t\tapplog(LOG_ERR, \"%s: JTAG detect returned %d\",\n\t\t       x6500->dev_repr, i);\n\t\treturn false;\n\t}\n\t\n\tif (!(1\n\t && jtag_write(jp, JTAG_REG_IR, \"\\x10\", 6)\n\t && jtag_read (jp, JTAG_REG_DR, buf, 32)\n\t && jtag_reset(jp)\n\t)) {\n\t\tapplog(LOG_ERR, \"%s: JTAG error reading user code\",\n\t\t       x6500->dev_repr);\n\t\treturn false;\n\t}\n\t\n\tif (memcmp(buf, X6500_BITSTREAM_USERID, 4)) {\n\t\tapplog(LOG_ERR, \"%\"PRIprepr\": FPGA not programmed\",\n\t\t       x6500->proc_repr);\n\t\tif (!x6500_fpga_upload_bitstream(x6500, jp))\n\t\t\treturn false;\n\t} else if (opt_force_dev_init && x6500 == x6500->device) {\n\t\tapplog(LOG_DEBUG, \"%\"PRIprepr\": FPGA is already programmed, but --force-dev-init is set\",\n\t\t       x6500->proc_repr);\n\t\tif (!x6500_fpga_upload_bitstream(x6500, jp))\n\t\t\treturn false;\n\t} else\n\t\tapplog(LOG_DEBUG, \"%s\"PRIprepr\": FPGA is already programmed :)\",\n\t\t       x6500->proc_repr);\n\t\n\tdclk_prepare(&fpga->dclk);\n\tfpga->dclk.freqMinM = X6500_MINIMUM_CLOCK / 2;\n\tx6500_change_clock(thr, X6500_DEFAULT_CLOCK / 2);\n\tfor (i = 0; 0xffffffff != x6500_get_register(jp, 0xE); ++i)\n\t{}\n\n\tif (i)\n\t\tapplog(LOG_WARNING, \"%\"PRIprepr\": Flushed %d nonces from buffer at init\",\n\t\t       x6500->proc_repr, i);\n\n\tfpga->dclk.minGoodSamples = 3;\n\tfpga->freqMaxMaxM =\n\tfpga->dclk.freqMaxM = X6500_MAXIMUM_CLOCK / 2;\n\tfpga->dclk.freqMDefault = fpga->dclk.freqM;\n\tapplog(LOG_WARNING, \"%\"PRIprepr\": Frequency set to %u MHz (range: %u-%u)\",\n\t       x6500->proc_repr,\n\t       fpga->dclk.freqM * 2,\n\t       X6500_MINIMUM_CLOCK,\n\t       fpga->dclk.freqMaxM * 2);\n\n\t}\n\n\treturn true;\n}\n\nstatic \nvoid x6500_get_temperature(struct cgpu_info *x6500)\n{\n\tstruct x6500_fpga_data *fpga = x6500->thr[0]->cgpu_data;\n\tstruct jtag_port *jp = &fpga->jtag;\n\tstruct ft232r_device_handle *ftdi = jp->a->ftdi;\n\tint i, code[2];\n\tbool sio[2];\n\n\tcode[0] = 0;\n\tcode[1] = 0;\n\n\tft232r_flush(ftdi);\n\n\n\tif (!(ft232r_set_cbus_bits(ftdi, false, true))) return;\n\tif (!(ft232r_set_cbus_bits(ftdi, true, true))) return;\n\tif (!(ft232r_set_cbus_bits(ftdi, false, true))) return;\n\tif (!(ft232r_set_cbus_bits(ftdi, true, true))) return;\n\tif (!(ft232r_set_cbus_bits(ftdi, false, false))) return;\n\n\tfor (i = 16; i--; ) {\n\t\tif (ft232r_set_cbus_bits(ftdi, true, false)) {\n\t\t\tif (!(ft232r_get_cbus_bits(ftdi, &sio[0], &sio[1]))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tcode[0] |= sio[0] << i;\n\t\tcode[1] |= sio[1] << i;\n\t\tif (!ft232r_set_cbus_bits(ftdi, false, false)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(ft232r_set_cbus_bits(ftdi, false, true))) {\n\t\treturn;\n\t}\n\tif (!(ft232r_set_cbus_bits(ftdi, true, true))) {\n\t\treturn;\n\t}\n\tif (!(ft232r_set_cbus_bits(ftdi, false, true))) {\n\t\treturn;\n\t}\n\tif (!ft232r_set_bitmode(ftdi, 0xee, 4)) {\n\t\treturn;\n\t}\n\tft232r_purge_buffers(jp->a->ftdi, FTDI_PURGE_BOTH);\n\tjp->a->bufread = 0;\n\n\tx6500 = x6500->device;\n\tfor (i = 0; i < 2; ++i, x6500 = x6500->next_proc) {\n\t\tstruct thr_info *thr = x6500->thr[0];\n\t\tfpga = thr->cgpu_data;\n\n\t\tif (!fpga) continue;\n\n\t\tif (code[i] == 0xffff || !code[i]) {\n\t\t\tx6500->temp = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((code[i] >> 15) & 1)\n\t\t\tcode[i] -= 0x10000;\n\t\tx6500->temp = (float)(code[i] >> 2) * 0.03125f;\n\t\tapplog(LOG_DEBUG,\"x6500_get_temperature: fpga[%d]->temp=%.1fC\",\n\t\t       i, x6500->temp);\n\n\t\tint temperature = round(x6500->temp);\n\t\tif (temperature > x6500->targettemp + opt_hysteresis) {\n\t\t\tstruct timeval now;\n\t\t\tcgtime(&now);\n\t\t\tif (timer_elapsed(&fpga->tv_last_cutoff_reduced, &now)) {\n\t\t\t\tfpga->tv_last_cutoff_reduced = now;\n\t\t\t\tint oldFreq = fpga->dclk.freqM;\n\t\t\t\tif (x6500_change_clock(thr, oldFreq - 1))\n\t\t\t\t\tapplog(LOG_NOTICE, \"%\"PRIprepr\": Frequency dropped from %u to %u MHz (temp: %.1fC)\",\n\t\t\t\t\t       x6500->proc_repr,\n\t\t\t\t\t       oldFreq * 2, fpga->dclk.freqM * 2,\n\t\t\t\t\t       x6500->temp\n\t\t\t\t\t);\n\t\t\t\tfpga->dclk.freqMaxM = fpga->dclk.freqM;\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif (fpga->dclk.freqMaxM < fpga->freqMaxMaxM && temperature < x6500->targettemp) {\n\t\t\tif (temperature < x6500->targettemp - opt_hysteresis) {\n\t\t\t\tfpga->dclk.freqMaxM = fpga->freqMaxMaxM;\n\t\t\t} else if (fpga->dclk.freqM == fpga->dclk.freqMaxM) {\n\t\t\t\t++fpga->dclk.freqMaxM;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic\nbool x6500_all_idle(struct cgpu_info *any_proc)\n{\n\tfor (struct cgpu_info *proc = any_proc->device; proc; proc = proc->next_proc)\n\t\tif (proc->thr[0]->tv_poll.tv_sec != -1 || proc->deven == DEV_ENABLED)\n\t\t\treturn false;\n\treturn true;\n}\n\nstatic bool x6500_get_stats(struct cgpu_info *x6500)\n{\n\tif (x6500_all_idle(x6500)) {\n\t\tstruct cgpu_info *cgpu = x6500->device;\n\t\t// Getting temperature more efficiently while running\n\t\tcgpu_request_control(cgpu);\n\t\tx6500_get_temperature(x6500);\n\t\tcgpu_release_control(cgpu);\n\t}\n\n\treturn true;\n}\n\nstatic\nbool get_x6500_upload_percent(char *buf, size_t bufsz, struct cgpu_info *x6500, __maybe_unused bool per_processor)\n{\n\tunsigned char pdone = *((unsigned char*)x6500->device_data - 1);\n\tif (pdone != 101) {\n\t\ttailsprintf(buf, bufsz, \"%3d%% \", pdone);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct api_data*\nget_x6500_api_extra_device_status(struct cgpu_info *x6500)\n{\n\tstruct api_data *root = NULL;\n\tstruct thr_info *thr = x6500->thr[0];\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tdouble d;\n\n\td = (double)fpga->dclk.freqM * 2;\n\troot = api_add_freq(root, \"Frequency\", &d, true);\n\td = (double)fpga->dclk.freqMaxM * 2;\n\troot = api_add_freq(root, \"Cool Max Frequency\", &d, true);\n\td = (double)fpga->freqMaxMaxM * 2;\n\troot = api_add_freq(root, \"Max Frequency\", &d, true);\n\n\treturn root;\n}\n\nstatic\nbool x6500_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tstruct jtag_port *jp = &fpga->jtag;\n\t\n\tfor (int i = 1, j = 0; i < 9; ++i, j += 4)\n\t\tx6500_set_register(jp, i, fromlebytes(work->midstate, j));\n\n\tfor (int i = 9, j = 64; i < 11; ++i, j += 4)\n\t\tx6500_set_register(jp, i, fromlebytes(work->data, j));\n\n\tx6500_get_temperature(x6500);\n\t\n\tft232r_flush(jp->a->ftdi);\n\t\n\tfpga->prepwork_last_register = fromlebytes(work->data, 72);\n\t\n\twork->blk.nonce = 0xffffffff;\n\t\n\treturn true;\n}\n\nstatic int64_t calc_hashes(struct thr_info *, struct timeval *);\n\nstatic\nvoid x6500_job_start(struct thr_info *thr)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tstruct jtag_port *jp = &fpga->jtag;\n\tstruct timeval tv_now;\n\n\tif (thr->prev_work)\n\t{\n\t\tdclk_preUpdate(&fpga->dclk);\n\t\tdclk_updateFreq(&fpga->dclk, x6500_dclk_change_clock, thr);\n\t}\n\n\tx6500_set_register(jp, 11, fpga->prepwork_last_register);\n\n\tft232r_flush(jp->a->ftdi);\n\n\ttimer_set_now(&tv_now);\n\tif (!thr->prev_work)\n\t\tfpga->tv_hashstart = tv_now;\n\telse\n\tif (thr->prev_work != thr->work)\n\t\tcalc_hashes(thr, &tv_now);\n\tfpga->hashes_left = 0x100000000;\n\tmt_job_transition(thr);\n\t\n\tif (opt_debug) {\n\t\tchar xdata[161];\n\t\tbin2hex(xdata, thr->work->data, 80);\n\t\tapplog(LOG_DEBUG, \"%\"PRIprepr\": Started work: %s\",\n\t\t       x6500->proc_repr, xdata);\n\t}\n\n\tuint32_t usecs = 0x80000000 / fpga->dclk.freqM;\n\tusecs -= 1000000;\n\ttimer_set_delay(&thr->tv_morework, &tv_now, usecs);\n\n\ttimer_set_delay(&thr->tv_poll, &tv_now, 10000);\n\t\n\tjob_start_complete(thr);\n}\n\nstatic\nint64_t calc_hashes(struct thr_info *thr, struct timeval *tv_now)\n{\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tstruct timeval tv_delta;\n\tint64_t hashes, hashes_left;\n\n\ttimersub(tv_now, &fpga->tv_hashstart, &tv_delta);\n\thashes = (((int64_t)tv_delta.tv_sec * 1000000) + tv_delta.tv_usec) * fpga->dclk.freqM * 2;\n\thashes_left = fpga->hashes_left;\n\tif (unlikely(hashes > hashes_left))\n\t\thashes = hashes_left;\n\tfpga->hashes_left -= hashes;\n\thashes_done(thr, hashes, &tv_delta, NULL);\n\tfpga->tv_hashstart = *tv_now;\n\treturn hashes;\n}\n\nstatic\nint64_t x6500_process_results(struct thr_info *thr, struct work *work)\n{\n\tstruct cgpu_info *x6500 = thr->cgpu;\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tstruct jtag_port *jtag = &fpga->jtag;\n\n\tstruct timeval tv_now;\n\tint64_t hashes;\n\tuint32_t nonce;\n\tbool bad;\n\n\twhile (1) {\n\t\ttimer_set_now(&tv_now);\n\t\tnonce = x6500_get_register(jtag, 0xE);\n\t\tif (nonce != 0xffffffff) {\n\t\t\tbad = !(work && test_nonce(work, nonce, false));\n\t\t\tif (!bad) {\n\t\t\t\tsubmit_nonce(thr, work, nonce);\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIprepr\": Nonce for current  work: %08lx\",\n\t\t\t\t       x6500->proc_repr,\n\t\t\t\t       (unsigned long)nonce);\n\n\t\t\t\tdclk_gotNonces(&fpga->dclk);\n\t\t\t} else if (likely(thr->prev_work) && test_nonce(thr->prev_work, nonce, false)) {\n\t\t\t\tsubmit_nonce(thr, thr->prev_work, nonce);\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIprepr\": Nonce for PREVIOUS work: %08lx\",\n\t\t\t\t       x6500->proc_repr,\n\t\t\t\t       (unsigned long)nonce);\n\t\t\t} else {\n\t\t\t\tinc_hw_errors(thr, work, nonce);\n\n\t\t\t\tdclk_gotNonces(&fpga->dclk);\n\t\t\t\tdclk_errorCount(&fpga->dclk, 1.);\n\t\t\t}\n\t\t\t// Keep reading nonce buffer until it's empty\n\t\t\t// This is necessary to avoid getting hw errors from Freq B after we've moved on to Freq A\n\t\t\tcontinue;\n\t\t}\n\n\t\thashes = calc_hashes(thr, &tv_now);\n\t\t\n\t\tbreak;\n\t}\n\n\treturn hashes;\n}\n\nstatic\nvoid x6500_fpga_poll(struct thr_info *thr)\n{\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\t\n\tx6500_process_results(thr, thr->work);\n\tif (unlikely(!fpga->hashes_left))\n\t{\n\t\tmt_disable_start__async(thr);\n\t\tthr->tv_poll.tv_sec = -1;\n\t}\n\telse\n\t\ttimer_set_delay_from_now(&thr->tv_poll, 10000);\n}\n\nstatic\nvoid x6500_user_set_clock(struct cgpu_info *cgpu, const int val)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tconst int multiplier = val / 2;\n\tfpga->dclk.freqMDefault = multiplier;\n}\n\nstatic\nvoid x6500_user_set_max_clock(struct cgpu_info *cgpu, const int val)\n{\n\tstruct thr_info * const thr = cgpu->thr[0];\n\tstruct x6500_fpga_data *fpga = thr->cgpu_data;\n\tconst int multiplier = val / 2;\n\tfpga->freqMaxMaxM =\n\tfpga->dclk.freqMaxM = multiplier;\n}\n\nstatic\nchar *x6500_set_device(struct cgpu_info *cgpu, char *option, char *setting, char *replybuf)\n{\n\tint val;\n\t\n\tif (strcasecmp(option, \"help\") == 0) {\n\t\tsprintf(replybuf, \"clock: range %d-%d and a multiple of 2\\nmaxclock: default %d, range %d-%d and a multiple of 2\",\n\t\t        X6500_MINIMUM_CLOCK, X6500_MAXIMUM_CLOCK, X6500_MAXIMUM_CLOCK, X6500_MINIMUM_CLOCK, X6500_MAXIMUM_CLOCK);\n\t\treturn replybuf;\n\t}\n\t\n\tif (strcasecmp(option, \"clock\") == 0) {\n\t\tif (!setting || !*setting) {\n\t\t\tsprintf(replybuf, \"missing clock setting\");\n\t\t\treturn replybuf;\n\t\t}\n\t\t\n\t\tval = atoi(setting);\n\t\tif (val < X6500_MINIMUM_CLOCK || val > X6500_MAXIMUM_CLOCK || (val & 1) != 0) {\n\t\t\tsprintf(replybuf, \"invalid clock: '%s' valid range %d-%d and a multiple of 2\",\n\t\t\t        setting, X6500_MINIMUM_CLOCK, X6500_MAXIMUM_CLOCK);\n\t\t\treturn replybuf;\n\t\t}\n\t\t\n\t\tx6500_user_set_clock(cgpu, val);\n\t\t\n\t\treturn NULL;\n\t}\n\t\n\tif (strcasecmp(option, \"maxclock\") == 0) {\n\t\tif (!setting || !*setting) {\n\t\t\tsprintf(replybuf, \"missing maxclock setting\");\n\t\t\treturn replybuf;\n\t\t}\n\t\t\n\t\tval = atoi(setting);\n\t\tif (val < X6500_MINIMUM_CLOCK || val > X6500_MAXIMUM_CLOCK || (val & 1) != 0) {\n\t\t\tsprintf(replybuf, \"invalid maxclock: '%s' valid range %d-%d and a multiple of 2\",\n\t\t\t        setting, X6500_MINIMUM_CLOCK, X6500_MAXIMUM_CLOCK);\n\t\t\treturn replybuf;\n\t\t}\n\t\t\n\t\tx6500_user_set_max_clock(cgpu, val);\n                \n\t\tapplog(LOG_NOTICE, \"%\"PRIpreprv\": Maximum frequency reset to %u MHz\",\n\t\t       cgpu->proc_repr,\n\t\t       val\n\t\t);\n\t\t\n\t\treturn NULL;\n\t}\n\n\tsprintf(replybuf, \"Unknown option: %s\", option);\n\treturn replybuf;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid x6500_tui_wlogprint_choices(struct cgpu_info *cgpu)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *x6500_tui_handle_choice(struct cgpu_info *cgpu, int input)\n{\n\tstatic char buf[0x100];  // Static for replies\n\t\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tint val;\n\t\t\tchar *intvar;\n\t\t\t\n\t\t\tsprintf(buf, \"Set clock speed (range %d-%d, multiple of 2)\", X6500_MINIMUM_CLOCK, X6500_MAXIMUM_CLOCK);\n\t\t\tintvar = curses_input(buf);\n\t\t\tif (!intvar)\n\t\t\t\treturn \"Invalid clock speed\\n\";\n\t\t\tval = atoi(intvar);\n\t\t\tfree(intvar);\n\t\t\tif (val < X6500_MINIMUM_CLOCK || val > X6500_MAXIMUM_CLOCK || (val & 1) != 0)\n\t\t\t\treturn \"Invalid clock speed\\n\";\n\t\t\t\n\t\t\tx6500_user_set_clock(cgpu, val);\n\t\t\treturn \"Clock speed changed\\n\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid x6500_wlogprint_status(struct cgpu_info *cgpu)\n{\n\tstruct x6500_fpga_data *fpga = cgpu->thr[0]->cgpu_data;\n\twlogprint(\"Clock speed: %d\\n\", (int)(fpga->dclk.freqM * 2));\n}\n#endif\n\nstruct device_drv x6500_api = {\n\t.dname = \"x6500\",\n\t.name = \"XBS\",\n\t.lowl_match = x6500_lowl_match,\n\t.lowl_probe = x6500_lowl_probe,\n\t.thread_prepare = x6500_prepare,\n\t.thread_init = x6500_thread_init,\n\t.get_stats = x6500_get_stats,\n\t.override_statline_temp2 = get_x6500_upload_percent,\n\t.get_api_extra_device_status = get_x6500_api_extra_device_status,\n\t.set_device = x6500_set_device,\n#ifdef HAVE_CURSES\n\t.proc_wlogprint_status = x6500_wlogprint_status,\n\t.proc_tui_wlogprint_choices = x6500_tui_wlogprint_choices,\n\t.proc_tui_handle_choice = x6500_tui_handle_choice,\n#endif\n\t.poll = x6500_fpga_poll,\n\t.minerloop = minerloop_async,\n\t.job_prepare = x6500_job_prepare,\n\t.job_start = x6500_job_start,\n// \t.thread_shutdown = x6500_fpga_shutdown,\n};\n"
        },
        {
          "name": "driver-zeusminer.c",
          "type": "blob",
          "size": 10.1650390625,
          "content": "/*\n * Copyright 2014 Nate Woolls\n * Copyright 2014 ZeusMiner Team\n * Copyright 2014-2015 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <math.h>\n\n#include \"miner.h\"\n#include \"driver-icarus.h\"\n#include \"lowl-vcom.h\"\n\n#define ZEUSMINER_IO_SPEED          115200\n\n#define ZEUSMINER_CHIP_GEN1_CORES   8\n#define ZEUSMINER_CHIP_CORES        ZEUSMINER_CHIP_GEN1_CORES\n#define ZEUSMINER_CHIPS_COUNT_MAX   1\n#define ZEUSMINER_CHIPS_COUNT       6\n#define ZEUSMINER_DEFAULT_CLOCK     328\n#define ZEUSMINER_MIN_CLOCK         200\n#define ZEUSMINER_MAX_CLOCK         383\n\n\nBFG_REGISTER_DRIVER(zeusminer_drv)\n\nstatic\nconst struct bfg_set_device_definition zeusminer_set_device_funcs_probe[];\n\nstatic\nconst struct bfg_set_device_definition zeusminer_set_device_funcs_live[];\n\n// device helper functions\n\nstatic\nuint32_t zeusminer_calc_clk_header(uint16_t freq)\n{\n\t//set clk_reg based on chip_clk\n\tuint32_t clk_reg = (uint32_t)freq * 2 / 3;\n\t\n\t//clock speed mask for header\n\tuint32_t clk_header = (clk_reg << 24) + ((0xff - clk_reg) << 16);\n\t\n\treturn clk_header;\n}\n\n// ICARUS_INFO functions - driver-icarus.h\n\n// device detection\n\nstatic\nbool zeusminer_detect_one(const char *devpath)\n{\n\tstruct device_drv *drv = &zeusminer_drv;\n\t\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\t\n\tchar scrypt_golden_ob[] =\n\t\"55aa\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Freq is set to 0x55*1.5=85Mhz\n\t\"0001\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//We want to find a Nonce which result's diff is at least 32768\n\t\"00038000\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Starting Nonce\n\t\"063b0b1b\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Bits (target in compact form)\n\t\"028f3253\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Timestamp\n\t\"5e900609c15dc49a42b1d8492a6dd4f8f15295c989a1decf584a6aa93be26066\"\t//Merkle root\n\t\"d3185f55ef635b5865a7a79b7fa74121a6bb819da416328a9bd2f8cef72794bf\"\t//Previous hash\n\t\"02000000\";\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Version\n\t\n\tconst char scrypt_golden_nonce[] = \"00038d26\";\n\t\n\t*info = (struct ICARUS_INFO){\n\t\t.baud = ZEUSMINER_IO_SPEED,\n\t\t.timing_mode = MODE_DEFAULT,\n\t\t// if do_icarus_timing is true, the timing adjustment may\n\t\t// result in a read_count that considers the device Idle\n\t\t.do_icarus_timing = false,\n\t\t.probe_read_count = 5,\n\t\t.golden_nonce = scrypt_golden_nonce,\n\t\t.chips = ZEUSMINER_CHIPS_COUNT,\n\t\t.freq = ZEUSMINER_DEFAULT_CLOCK,\n\t};\n\t\n\t//pick up any user-defined settings passed in via --set\n\tdrv_set_defaults(drv, zeusminer_set_device_funcs_probe, info, devpath, detectone_meta_info.serial, 1);\n\t\n\tinfo->work_division = upper_power_of_two_u32(info->chips * ZEUSMINER_CHIP_CORES);\n\tinfo->fpga_count = info->chips * ZEUSMINER_CHIP_CORES;\n\t\n\t//send the requested Chip Speed with the detect golden OB\n\t//we use the time this request takes in order to calc hashes\n\t//so we need to use the same Chip Speed used when hashing\n\tuint32_t clk_header = zeusminer_calc_clk_header(info->freq);\n\tchar clk_header_str[10];\n\tsprintf(clk_header_str, \"%08x\", clk_header + 1);\n\tmemcpy(scrypt_golden_ob, clk_header_str, 8);\n\t\n\tinfo->golden_ob = scrypt_golden_ob;\n\t\n\tif (!icarus_detect_custom(devpath, drv, info) &&\n\t\t//ZM doesn't respond to detection 1 out of ~30 times\n\t\t!icarus_detect_custom(devpath, drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\t\n\tdouble duration_sec;\n\tconst double hash_count = (double)0xd26;\n\tuint64_t default_hashes_per_core = (((info->freq * 2) / 3) * 1024) / ZEUSMINER_CHIP_CORES;\n\t\n\tif (info->ignore_golden_nonce)\n\t\tduration_sec = hash_count / default_hashes_per_core;\n\telse\n\t\tduration_sec = ((double)(info->golden_tv.tv_sec) + ((double)(info->golden_tv.tv_usec)) / ((double)1000000));\n\t\n\t//determines how the hash rate is calculated when no nonce is returned\n\tinfo->Hs = (double)(duration_sec / hash_count / info->chips / ZEUSMINER_CHIP_CORES);\n\t\n\t//set the read_count (how long to wait for a result) based on chips, cores, and time to find a nonce\n\tint chips_count_max = ZEUSMINER_CHIPS_COUNT_MAX;\n\tif (info->chips > chips_count_max)\n\t\tchips_count_max = upper_power_of_two_u32(info->chips);\n\t//golden_speed_per_core is the number of hashes / second / core\n\tuint64_t golden_speed_per_core = (uint64_t)(hash_count / duration_sec);\n\t//don't combine the following two lines - overflows leaving info->read_count at 0\n\tinfo->read_timeout_ms = ((uint64_t)(0x100000000 * 1000)) / (ZEUSMINER_CHIP_CORES * chips_count_max * golden_speed_per_core * 2);\n\tinfo->read_timeout_ms = info->read_timeout_ms * 3 / 4;\n\t\n\treturn true;\n}\n\n// support for --set-device\n// must be set before probing the device\n\nstatic\nbool zeusminer_set_clock_freq(struct cgpu_info * const device, int const freq)\n{\n\tstruct ICARUS_INFO * const info = device->device_data;\n\n\tif (freq < ZEUSMINER_MIN_CLOCK || freq > ZEUSMINER_MAX_CLOCK)\n\t\treturn false;\n\n\tinfo->freq = freq;\n\n\treturn true;\n}\n\nstatic\nconst char *zeusminer_set_clock(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tint val = atoi(setting);\n\t\n\tif (!zeusminer_set_clock_freq(device, val))\n\t{\n\t\tsprintf(replybuf, \"invalid clock: '%s' valid range %d-%d\",\n\t\t        setting, ZEUSMINER_MIN_CLOCK, ZEUSMINER_MAX_CLOCK);\n\t\treturn replybuf;\n\t}\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *zeusminer_set_chips(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct ICARUS_INFO * const info = device->device_data;\n\t\n\tinfo->chips = atoi(setting);\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *zeusminer_set_ignore_golden_nonce(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)\n{\n\tstruct ICARUS_INFO * const info = device->device_data;\n\t\n\tinfo->ignore_golden_nonce = atoi(setting) == 1;\n\t\n\treturn NULL;\n}\n\n// for setting clock and chips during probe / detect\nstatic\nconst struct bfg_set_device_definition zeusminer_set_device_funcs_probe[] = {\n\t{ \"clock\", zeusminer_set_clock, NULL },\n\t{ \"chips\", zeusminer_set_chips, NULL },\n\t{ \"ignore_golden_nonce\",zeusminer_set_ignore_golden_nonce, NULL },\n\t{ NULL },\n};\n\n// for setting clock while mining\nstatic\nconst struct bfg_set_device_definition zeusminer_set_device_funcs_live[] = {\n\t{ \"clock\", zeusminer_set_clock, NULL },\n\t{ NULL },\n};\n\nstatic\nbool zeusminer_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\treturn vcom_lowl_probe_wrapper(info, zeusminer_detect_one);\n}\n\n// device_drv functions - miner.h\n\nstatic\nbool zeusminer_thread_init(struct thr_info * const thr)\n{\n\tstruct cgpu_info * const device = thr->cgpu;\n\t\n\tdevice->set_device_funcs = zeusminer_set_device_funcs_live;\n\t\n\treturn icarus_init(thr);\n}\n\nstatic\nbool zeusminer_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused uint64_t max_nonce)\n{\n\tstruct cgpu_info * const device = thr->cgpu;\n\tstruct icarus_state * const state = thr->cgpu_data;\n\tstruct ICARUS_INFO * const info = device->device_data;\n\t\n\tuint32_t clk_header = zeusminer_calc_clk_header(info->freq);\n\tuint32_t diff = work->nonce_diff * 0x10000;\n\tuint32_t target_me = 0xffff / diff;\n\tuint32_t header = clk_header + target_me;\n\t\n\tpk_u32be(state->ob_bin, 0, header);\n\tbswap_32mult(&state->ob_bin[4], work->data, 80/4);\n\t\n\treturn true;\n}\n\n// display the Chip # in the UI when viewing per-proc details\nstatic\nbool zeusminer_override_statline_temp2(char *buf, size_t bufsz, struct cgpu_info *device, __maybe_unused bool per_processor)\n{\n\tif (per_processor && ((device->proc_id % ZEUSMINER_CHIP_CORES) == 0))\n\t{\n\t\ttailsprintf(buf, bufsz, \"C:%-3d\", device->proc_id / ZEUSMINER_CHIP_CORES);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// return the Chip # in via the API when procdetails is called\nstatic\nstruct api_data *zeusminer_get_api_extra_device_detail(struct cgpu_info *device)\n{\n\tint chip = device->proc_id / ZEUSMINER_CHIP_CORES;\n\treturn api_add_int(NULL, \"Chip\", &chip, true);\n}\n\n/*\n * specify settings / options via TUI\n */\n\n#ifdef HAVE_CURSES\nstatic\nvoid zeusminer_tui_wlogprint_choices(struct cgpu_info * const proc)\n{\n\twlogprint(\"[C]lock speed \");\n}\n\nstatic\nconst char *zeusminer_tui_handle_choice(struct cgpu_info * const proc, const int input)\n{\n\tstatic char buf[0x100];  // Static for replies\n\n\tswitch (input)\n\t{\n\t\tcase 'c': case 'C':\n\t\t{\n\t\t\tsprintf(buf, \"Set clock speed\");\n\t\t\tchar * const setting = curses_input(buf);\n\n\t\t\tif (zeusminer_set_clock_freq(proc->device, atoi(setting)))\n\t\t\t{\n\t\t\t\treturn \"Clock speed changed\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsprintf(buf, \"Invalid clock: '%s' valid range %d-%d\",\n\t\t\t\t\t\tsetting, ZEUSMINER_MIN_CLOCK, ZEUSMINER_MAX_CLOCK);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid zeusminer_wlogprint_status(struct cgpu_info * const proc)\n{\n\tstruct ICARUS_INFO * const info = proc->device->device_data;\n\twlogprint(\"Clock speed: %d\\n\", info->freq);\n}\n#endif\n\n// device_drv definition - miner.h\n\nstatic\nvoid zeusminer_drv_init()\n{\n\t// based on Icarus\n\tzeusminer_drv = icarus_drv;\n\t\n\t// metadata\n\tzeusminer_drv.dname = \"zeusminer\";\n\tzeusminer_drv.name = \"ZUS\";\n\tzeusminer_drv.drv_min_nonce_diff = common_scrypt_min_nonce_diff;\n\t\n\t// detect device\n\tzeusminer_drv.lowl_probe = zeusminer_lowl_probe;\n\t\n\t// initialize thread\n\tzeusminer_drv.thread_init = zeusminer_thread_init;\n\t\n\t// Icarus scanhash mining hooks\n\tzeusminer_drv.job_prepare = zeusminer_job_prepare;\n\t\n\t// specify driver probe priority\n\t// currently setup specifically to probe before DualMiner\n\tzeusminer_drv.probe_priority = -100;\n\n\t// output the chip # when viewing per-proc stats\n\t// so we can easily ID chips vs cores\n\tzeusminer_drv.override_statline_temp2 = zeusminer_override_statline_temp2;\n\n\t// output the chip # via RPC API\n\tzeusminer_drv.get_api_extra_device_detail = zeusminer_get_api_extra_device_detail;\n\n\t// TUI support - e.g. setting clock via UI\n#ifdef HAVE_CURSES\n\tzeusminer_drv.proc_wlogprint_status = zeusminer_wlogprint_status;\n\tzeusminer_drv.proc_tui_wlogprint_choices = zeusminer_tui_wlogprint_choices;\n\tzeusminer_drv.proc_tui_handle_choice = zeusminer_tui_handle_choice;\n#endif\n}\n\nstruct device_drv zeusminer_drv = {\n\t.drv_init = zeusminer_drv_init,\n};\n"
        },
        {
          "name": "driver-ztex.c",
          "type": "blob",
          "size": 11.16015625,
          "content": "/*\n * Copyright 2012 nelisky\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2012-2013 Denis Ahrens\n * Copyright 2012 Xiangfu\n *\n * This work is based upon the Java SDK provided by ztex which is\n * Copyright (C) 2009-2011 ZTEX GmbH.\n * http://www.ztex.de\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"miner.h\"\n#include <unistd.h>\n#include <sha2.h>\n\n#include \"deviceapi.h\"\n#include \"dynclock.h\"\n#include \"libztex.h\"\n#include \"lowlevel.h\"\n#include \"lowl-usb.h\"\n#include \"util.h\"\n\n#define GOLDEN_BACKLOG 5\n\nBFG_REGISTER_DRIVER(ztex_drv)\n\n// Forward declarations\nstatic void ztex_disable(struct thr_info* thr);\nstatic bool ztex_prepare(struct thr_info *thr);\n\nstatic void ztex_selectFpga(struct libztex_device* ztex, int16_t fpgaNum)\n{\n\tif (ztex->root->numberOfFpgas > 1) {\n\t\tif (ztex->root->selectedFpga != fpgaNum)\n\t\t\tmutex_lock(&ztex->root->mutex);\n\t\tlibztex_selectFpga(ztex, fpgaNum);\n\t}\n}\n\nstatic void ztex_releaseFpga(struct libztex_device* ztex)\n{\n\tif (ztex->root->numberOfFpgas > 1) {\n\t\tztex->root->selectedFpga = -1;\n\t\tmutex_unlock(&ztex->root->mutex);\n\t}\n}\n\nstatic struct cgpu_info *ztex_setup(struct libztex_device *dev, int fpgacount)\n{\n\tstruct cgpu_info *ztex;\n\tchar *fpganame = (char*)dev->snString;\n\n\tztex = calloc(1, sizeof(struct cgpu_info));\n\tztex->drv = &ztex_drv;\n\tztex->device_ztex = dev;\n\tztex->procs = fpgacount;\n\tztex->threads = fpgacount;\n\tztex->dev_manufacturer = dev->dev_manufacturer;\n\tztex->dev_product = dev->dev_product;\n\tztex->dev_serial = (char*)&dev->snString[0];\n\tztex->name = fpganame;\n\tadd_cgpu(ztex);\n\tstrcpy(ztex->device_ztex->repr, ztex->dev_repr);\n\tapplog(LOG_INFO, \"%\"PRIpreprv\": Found Ztex (ZTEX %s)\", ztex->dev_repr, fpganame);\n\n\treturn ztex;\n}\n\nstatic\nbool ztex_lowl_match(const struct lowlevel_device_info * const info)\n{\n\treturn lowlevel_match_lowlproduct(info, &lowl_usb, \"btcminer for ZTEX\");\n}\n\nstatic\nbool ztex_lowl_probe(const struct lowlevel_device_info * const info)\n{\n\tconst char * const product = info->product;\n\tconst char * const serial = info->serial;\n\tif (info->lowl != &lowl_usb)\n\t{\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\tapplog(LOG_DEBUG, \"%s: Matched \\\"%s\\\" serial \\\"%s\\\", but lowlevel driver is not usb!\",\n\t\t       __func__, product, serial);\n\t\treturn false;\n\t}\n\t\n\tlibusb_device * const usbdev = info->lowl_data;\n\t\n\tconst enum ztex_check_result err = libztex_checkDevice(usbdev);\n\tswitch (err)\n\t{\n\t\tcase CHECK_ERROR:\n\t\t\tapplogr(false, LOG_ERR, \"%s: Can not check device %s\", ztex_drv.dname, info->devid);\n\t\tcase CHECK_IS_NOT_ZTEX:\n\t\t\treturn false;\n\t\tcase CHECK_OK:\n\t\t\tbreak;\n\t\tcase CHECK_RESCAN:\n\t\t\tbfg_need_detect_rescan = true;\n\t\t\treturn false;\n\t}\n\t\n\tint fpgacount;\n\tstruct libztex_device *ztex_master;\n\tstruct cgpu_info *ztex;\n\t\n\tztex_master = libztex_prepare_device2(usbdev);\n\tif (!ztex_master)\n\t\tapplogr(false, LOG_ERR, \"%s: libztex_prepare_device2 failed on %s\", ztex_drv.dname, info->devid);\n\t\n\tif (bfg_claim_usb(&ztex_drv, true, ztex_master->usbbus, ztex_master->usbaddress))\n\t\treturn false;\n\tztex_master->root = ztex_master;\n\tfpgacount = libztex_numberOfFpgas(ztex_master);\n\tztex_master->handles = fpgacount;\n\tztex = ztex_setup(ztex_master, fpgacount);\n\n\tif (fpgacount > 1)\n\t\tpthread_mutex_init(&ztex->device_ztex->mutex, NULL);\n\t\n\treturn true;\n}\n\nstatic bool ztex_change_clock_func(struct thr_info *thr, int bestM)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct libztex_device *ztex = thr->cgpu->device_ztex;\n\n\tztex_selectFpga(ztex, cgpu->proc_id);\n\tlibztex_setFreq(ztex, bestM, cgpu->proc_repr);\n\tztex_releaseFpga(ztex);\n\n\treturn true;\n}\n\nstatic bool ztex_updateFreq(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct libztex_device *ztex = thr->cgpu->device_ztex;\n\tbool rv = dclk_updateFreq(&ztex->dclk, ztex_change_clock_func, thr);\n\tif (unlikely(!rv)) {\n\t\tztex_selectFpga(ztex, cgpu->proc_id);\n\t\tlibztex_resetFpga(ztex);\n\t\tztex_releaseFpga(ztex);\n\t}\n\treturn rv;\n}\n\nstatic bool ztex_checkNonce(struct cgpu_info *cgpu,\n                            struct work *work,\n                            struct libztex_hash_data *hdata)\n{\n\tuint32_t *data32 = (uint32_t *)(work->data);\n\tunsigned char swap[80];\n\tuint32_t *swap32 = (uint32_t *)swap;\n\tunsigned char hash1[32];\n\tunsigned char hash2[32];\n\tuint32_t *hash2_32 = (uint32_t *)hash2;\n\n\tswap32[76/4] = htobe32(hdata->nonce);\n\n\tswap32yes(swap32, data32, 76 / 4);\n\n\tsha256(swap, 80, hash1);\n\tsha256(hash1, 32, hash2);\n\n\tif (be32toh(hash2_32[7]) != ((hdata->hash7 + 0x5be0cd19) & 0xFFFFFFFF)) {\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": checkNonce failed for %08x\", cgpu->proc_repr, hdata->nonce);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int64_t ztex_scanhash(struct thr_info *thr, struct work *work,\n                              __maybe_unused int64_t max_nonce)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct libztex_device *ztex;\n\tunsigned char sendbuf[44];\n\tint i, j, k;\n\tuint32_t *backlog;\n\tint backlog_p = 0, backlog_max;\n\tuint32_t *lastnonce;\n\tuint32_t nonce, noncecnt = 0;\n\tbool overflow, found;\n\tstruct libztex_hash_data hdata[GOLDEN_BACKLOG];\n\n\tif (thr->cgpu->deven == DEV_DISABLED)\n\t\treturn -1;\n\n\tztex = thr->cgpu->device_ztex;\n\n\tmemcpy(sendbuf, work->data + 64, 12);\n\tmemcpy(sendbuf + 12, work->midstate, 32);\n\n\tztex_selectFpga(ztex, cgpu->proc_id);\n\ti = libztex_sendHashData(ztex, sendbuf);\n\tif (i < 0) {\n\t\t// Something wrong happened in send\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to send hash data with err %d, retrying\", cgpu->proc_repr, i);\n\t\tcgsleep_ms(500);\n\t\ti = libztex_sendHashData(ztex, sendbuf);\n\t\tif (i < 0) {\n\t\t\t// And there's nothing we can do about it\n\t\t\tztex_disable(thr);\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to send hash data with err %d, giving up\", cgpu->proc_repr, i);\n\t\t\tztex_releaseFpga(ztex);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tztex_releaseFpga(ztex);\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": sent hashdata\", cgpu->proc_repr);\n\n\tlastnonce = calloc(1, sizeof(uint32_t)*ztex->numNonces);\n\tif (lastnonce == NULL) {\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": failed to allocate lastnonce[%d]\", cgpu->proc_repr, ztex->numNonces);\n\t\treturn -1;\n\t}\n\n\t/* Add an extra slot for detecting dupes that lie around */\n\tbacklog_max = ztex->numNonces * (2 + ztex->extraSolutions);\n\tbacklog = calloc(1, sizeof(uint32_t) * backlog_max);\n\tif (backlog == NULL) {\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": failed to allocate backlog[%d]\", cgpu->proc_repr, backlog_max);\n\t\tfree(lastnonce);\n\t\treturn -1;\n\t}\n\n\toverflow = false;\n\tint count = 0;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": entering poll loop\", cgpu->proc_repr);\n\twhile (!(overflow || thr->work_restart)) {\n\t\tcount++;\n\t\tif (!restart_wait(thr, 250))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": New work detected\", cgpu->proc_repr);\n\t\t\tbreak;\n\t\t}\n\t\tztex_selectFpga(ztex, cgpu->proc_id);\n\t\ti = libztex_readHashData(ztex, &hdata[0]);\n\t\tif (i < 0) {\n\t\t\t// Something wrong happened in read\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to read hash data with err %d, retrying\", cgpu->proc_repr, i);\n\t\t\tcgsleep_ms(500);\n\t\t\ti = libztex_readHashData(ztex, &hdata[0]);\n\t\t\tif (i < 0) {\n\t\t\t\t// And there's nothing we can do about it\n\t\t\t\tztex_disable(thr);\n\t\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to read hash data with err %d, giving up\", cgpu->proc_repr, i);\n\t\t\t\tfree(lastnonce);\n\t\t\t\tfree(backlog);\n\t\t\t\tztex_releaseFpga(ztex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tztex_releaseFpga(ztex);\n\n\t\tif (thr->work_restart) {\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": New work detected\", cgpu->proc_repr);\n\t\t\tbreak;\n\t\t}\n\n\t\tdclk_gotNonces(&ztex->dclk);\n\n\t\tfor (i = 0; i < ztex->numNonces; i++) {\n\t\t\tnonce = hdata[i].nonce;\n\t\t\tif (nonce > noncecnt)\n\t\t\t\tnoncecnt = nonce;\n\t\t\tif (((0xffffffff - nonce) < (nonce - lastnonce[i])) || nonce < lastnonce[i]) {\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": overflow nonce=%08x lastnonce=%08x\", cgpu->proc_repr, nonce, lastnonce[i]);\n\t\t\t\toverflow = true;\n\t\t\t} else\n\t\t\t\tlastnonce[i] = nonce;\n\n\t\t\tif (!ztex_checkNonce(cgpu, work, &hdata[i])) {\n\t\t\t\t// do not count errors in the first 500ms after sendHashData (2x250 wait time)\n\t\t\t\tif (count > 2)\n\t\t\t\t\tdclk_errorCount(&ztex->dclk, 1.0 / ztex->numNonces);\n\n\t\t\t\tinc_hw_errors_only(thr);\n\t\t\t}\n\n\t\t\tfor (j=0; j<=ztex->extraSolutions; j++) {\n\t\t\t\tnonce = hdata[i].goldenNonce[j];\n\n\t\t\t\tif (nonce == ztex->offsNonces) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfound = false;\n\t\t\t\tfor (k = 0; k < backlog_max; k++) {\n\t\t\t\t\tif (backlog[k] == nonce) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tbacklog[backlog_p++] = nonce;\n\n\t\t\t\t\tif (backlog_p >= backlog_max)\n\t\t\t\t\t\tbacklog_p = 0;\n\n\t\t\t\t\twork->blk.nonce = 0xffffffff;\n\t\t\t\t\tif (!j || test_nonce(work, nonce, false))\n\t\t\t\t\t\tsubmit_nonce(thr, work, nonce);\n\t\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": submitted %08x (from N%dE%d)\", cgpu->proc_repr, nonce, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdclk_preUpdate(&ztex->dclk);\n\n\tif (!ztex_updateFreq(thr)) {\n\t\t// Something really serious happened, so mark this thread as dead!\n\t\tfree(lastnonce);\n\t\tfree(backlog);\n\t\t\n\t\treturn -1;\n\t}\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": exit %1.8X\", cgpu->proc_repr, noncecnt);\n\n\twork->blk.nonce = 0xffffffff;\n\n\tfree(lastnonce);\n\tfree(backlog);\n\n\treturn noncecnt;\n}\n\nstatic struct api_data*\nget_ztex_drv_extra_device_status(struct cgpu_info *ztex)\n{\n\tstruct api_data*root = NULL;\n\tstruct libztex_device *ztexr = ztex->device_ztex;\n\n\tif (ztexr) {\n\t\tdouble frequency = ztexr->freqM1 * (ztexr->dclk.freqM + 1);\n\t\troot = api_add_freq(root, \"Frequency\", &frequency, true);\n\t}\n\n\treturn root;\n}\n\nstatic bool ztex_prepare(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct libztex_device *ztex = cgpu->device_ztex;\n\n\t{\n\t\tchar *fpganame = malloc(LIBZTEX_SNSTRING_LEN+3+1);\n\t\tsprintf(fpganame, \"%s-%u\", ztex->snString, cgpu->proc_id+1);\n\t\tcgpu->name = fpganame;\n\t}\n\n\tztex_selectFpga(ztex, cgpu->proc_id);\n\tif (libztex_configureFpga(ztex, cgpu->proc_repr) != 0) {\n\t\tlibztex_resetFpga(ztex);\n\t\tztex_releaseFpga(ztex);\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Disabling!\", cgpu->proc_repr);\n\t\tthr->cgpu->deven = DEV_DISABLED;\n\t\treturn true;\n\t}\n\tztex->dclk.freqM = ztex->dclk.freqMaxM+1;\n\t//ztex_updateFreq(thr);\n\tlibztex_setFreq(ztex, ztex->dclk.freqMDefault, cgpu->proc_repr);\n\tztex_releaseFpga(ztex);\n\tnotifier_init(thr->work_restart_notifier);\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": prepare\", cgpu->proc_repr);\n\tcgpu->status = LIFE_INIT2;\n\treturn true;\n}\n\nstatic void ztex_shutdown(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct libztex_device *ztex = cgpu->device_ztex;\n\t\n\tif (!ztex)\n\t\treturn;\n\t\n\tcgpu->device_ztex = NULL;\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": shutdown\", cgpu->proc_repr);\n\tif (--ztex->handles)\n\t\treturn;\n\tapplog(LOG_DEBUG, \"%s: No handles remaining, destroying libztex device\", cgpu->dev_repr);\n\tif (ztex->root->numberOfFpgas > 1)\n\t\tpthread_mutex_destroy(&ztex->mutex);\n\tlibztex_destroy_device(ztex);\n}\n\nstatic void ztex_disable(struct thr_info *thr)\n{\n\tapplog(LOG_ERR, \"%\"PRIpreprv\": Disabling!\", thr->cgpu->proc_repr);\n\tthr->cgpu->deven = DEV_DISABLED;\n\tztex_shutdown(thr);\n}\n\nstruct device_drv ztex_drv = {\n\t.dname = \"ztex\",\n\t.name = \"ZTX\",\n\t.lowl_match = ztex_lowl_match,\n\t.lowl_probe = ztex_lowl_probe,\n\t.get_api_extra_device_status = get_ztex_drv_extra_device_status,\n\t.thread_init = ztex_prepare,\n\t.scanhash = ztex_scanhash,\n\t.thread_shutdown = ztex_shutdown,\n};\n"
        },
        {
          "name": "dynclock.c",
          "type": "blob",
          "size": 3.9541015625,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2012 nelisky\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"dynclock.h\"\n#include \"miner.h\"\n\nvoid dclk_prepare(struct dclk_data *data)\n{\n\t*data = (struct dclk_data){\n\t\t// after 275 sample periods\n\t\t.minGoodSamples = 150.,\n\t\t.freqMinM = 1,\n\t};\n}\n\nvoid dclk_msg_freqchange(const char *repr, int oldFreq, int newFreq, const char *tail)\n{\n\tapplog(LOG_NOTICE, \"%\"PRIpreprv\": Frequency %s from %u to %u MHz%s\",\n\t       repr,\n\t       (oldFreq > newFreq ? \"dropped\" : \"raised \"),\n\t       oldFreq, newFreq,\n\t       tail ?: \"\"\n\t);\n}\n\nbool dclk_updateFreq(struct dclk_data *data, dclk_change_clock_func_t changeclock, struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tuint8_t freqMDefault = data->freqMDefault;\n\tint i, maxM, bestM;\n\tdouble bestR, r;\n\tbool rv = true;\n\n\tif (freqMDefault > data->freqMaxM)\n\t\t// This occurs when the device in question adjusts its MaxM down due to temperature or similar reasons\n\t\tfreqMDefault = data->freqMaxM;\n\n\tfor (i = 0; i < data->freqMaxM; i++)\n\t\tif (data->maxErrorRate[i + 1] * i < data->maxErrorRate[i] * (i + 20))\n\t\t\tdata->maxErrorRate[i + 1] = data->maxErrorRate[i] * (1.0 + 20.0 / i);\n\n\tmaxM = 0;\n\t// Use max mulitplier up to the default as far as possible without hitting the max error rate\n\twhile (maxM < freqMDefault && data->maxErrorRate[maxM + 1] < DCLK_MAXMAXERRORRATE)\n\t\tmaxM++;\n\t// Use max mulitplier beyond the default if it's never hit the max error rate, and our current max has collected sufficient samples\n\twhile (maxM < data->freqMaxM && data->maxErrorRate[maxM + 1] < DCLK_MAXMAXERRORRATE && data->errorWeight[maxM] >= data->minGoodSamples)\n\t\tmaxM++;\n\n\t// Find the multiplier that gives the best hashrate\n\tbestM = data->freqMinM;\n\tbestR = 0;\n\tfor (i = bestM; i <= maxM; i++) {\n\t\t// Hashrate is weighed on a linear scale\n\t\tr = (i + 1);\n\t\t\n\t\t// The currently selected frequency gets a small \"bonus\" in comparison, as hysteresis\n\t\tif (i == data->freqM)\n\t\t\tr += DCLK_ERRORHYSTERESIS;\n\t\t\n\t\t// Adjust for measured error rate\n\t\tr *= (1 - data->maxErrorRate[i]);\n\t\t\n\t\t// If it beats the current best, update best*\n\t\tif (r > bestR) {\n\t\t\tbestM = i;\n\t\t\tbestR = r;\n\t\t}\n\t}\n\n\t// Actually change the clock if the best multiplier is not currently selected\n\tif (bestM != data->freqM) {\n\t\trv = changeclock(thr, bestM);\n\t}\n\n\t// Find the highest multiplier that we've taken a reasonable sampling of\n\tmaxM = freqMDefault;\n\twhile (maxM < data->freqMaxM && data->errorWeight[maxM + 1] > 100)\n\t\tmaxM++;\n\t// If the new multiplier is some fraction of the highest we've used long enough to get a good sample, assume there is something wrong and instruct the driver to shut it off\n\tif ((bestM < (1.0 - DCLK_OVERHEATTHRESHOLD) * maxM) && bestM < maxM - 1) {\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": frequency drop of %.1f%% detect. This may be caused by overheating. FPGA is shut down to prevent damage.\",\n\t\t       cgpu->proc_repr,\n\t\t       (1.0 - 1.0 * bestM / maxM) * 100);\n\t\treturn false;\n\t}\n\treturn rv;\n}\n\nvoid dclk_gotNonces(struct dclk_data *data)\n{\n\tdata->errorCount[data->freqM] *= 0.995;\n\tdata->errorWeight[data->freqM] = data->errorWeight[data->freqM] * 0.995 + 1.0;\n}\n\nvoid dclk_errorCount(struct dclk_data *data, double portion)\n{\n\tdata->errorCount[data->freqM] += portion;\n}\n\nvoid dclk_preUpdate(struct dclk_data *data)\n{\n\tdata->errorRate[data->freqM] = data->errorCount[data->freqM] / data->errorWeight[data->freqM];\n\t// errorWeight 100 begins after sample period 137; before then, we minimize the effect of measured errorRate\n\tif (data->errorWeight[data->freqM] < 100)\n\t\tdata->errorRate[data->freqM] /= 100;\n\t\n\tif (data->errorRate[data->freqM] > data->maxErrorRate[data->freqM])\n\t\tdata->maxErrorRate[data->freqM] = data->errorRate[data->freqM];\n}\n"
        },
        {
          "name": "dynclock.h",
          "type": "blob",
          "size": 2.2099609375,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2012 nelisky\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef DYNCLOCK_H\n#define DYNCLOCK_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\nstruct thr_info;\n\n#define DCLK_MAXMAXERRORRATE 0.05\n#define DCLK_ERRORHYSTERESIS 0.1\n#define DCLK_OVERHEATTHRESHOLD 0.4\n\nstruct dclk_data {\n\t// Current frequency multiplier\n\tuint8_t freqM;\n\t\n\t// Minimum frequency multiplier to consider (set by driver)\n\tuint8_t freqMinM;\n\t\n\t// Maximum frequency multiplier to consider (set by driver)\n\tuint8_t freqMaxM;\n\t\n\t// \"Default\" frequency multiplier to work with (set by driver)\n\tuint8_t freqMDefault;\n\n\t// Threshold before errorWeight is considered reasonably constant\n\t// NOTE: This is not a mere number of sampling periods (but related)\n\tuint8_t minGoodSamples;\n\n\t// Numerator of errorWeight after dclk_errorCount\n\tdouble errorCount[256];\n\t\n\t// Approaches 200\n\tdouble errorWeight[256];\n\t\n\t// Error rate (0.0 - 1.0) as of end of last sampling period\n\tdouble errorRate[256];\n\t\n\t// Highest error rate (0.0 - 1.0) encountered\n\tdouble maxErrorRate[256];\n};\n\ntypedef bool (*dclk_change_clock_func_t)(struct thr_info *, int multiplier);\n\n// Standard applog message called by driver frequency-change functions\nextern void dclk_msg_freqchange(const char *, int oldFreq, int newFreq, const char *tail);\n\n// Called to initialize dclk_data at startup\nextern void dclk_prepare(struct dclk_data *data);\n\n// Called to start a sampling period\nextern void dclk_gotNonces(struct dclk_data *);\n\n// Called to increment the current sampling period's error rate (1.0 \"portion\" is 100% errors)\nextern void dclk_errorCount(struct dclk_data *, double portion);\n\n// Called after a sampling period is completed to update actual error rate\nextern void dclk_preUpdate(struct dclk_data *data);\n\n// Called after a sampling period is completed, and error rate updated, to make actual clock adjustments\nextern bool dclk_updateFreq(struct dclk_data *, dclk_change_clock_func_t changeclock, struct thr_info *);\n\n#endif\n"
        },
        {
          "name": "example.conf",
          "type": "blob",
          "size": 0.82421875,
          "content": "{\n\"pools\" : [\n\t{\n\t\t\"url\" : \"http://url1:8332\",\n\t\t\"user\" : \"user1\",\n\t\t\"pass\" : \"pass1\"\n\t},\n\t{\n\t\t\"url\" : \"http://url2:8344\",\n\t\t\"pool-proxy\" : \"socks5://127.0.0.1:1080\",\n\t\t\"user\" : \"user2\",\n\t\t\"pass\" : \"pass2\"\n\t},\n\t{\n\t\t\"url\" : \"http://url3:8332\",\n\t\t\"user\" : \"user3\",\n\t\t\"pass\" : \"pass3\"\n\t}\n],\n\n\"intensity\" : \"d,9,9,9\",\n\"gpu-engine\" : \"0-985,0-950,0-960,0-1000\",\n\"gpu-fan\" : \"0-85,0-85,0-85,0-85\",\n\"gpu-memclock\" : \"860,825,835,875\",\n\"gpu-powertune\" : \"20,20,20,20\",\n\"temp-cutoff\" : \"95,95,95,95\",\n\"temp-overheat\" : \"85,85,85,85\",\n\"temp-target\" : \"75,75,75,75\",\n\n\"auto-fan\" : true,\n\"auto-gpu\" : true,\n\"expiry\" : 120,\n\"failover-only\" : true,\n\"gpu-threads\" : 2,\n\"log\" : 5,\n\"queue\" : 1,\n\"scan-time\" : 60,\n\"temp-hysteresis\" : 3,\n\n\"scan-serial\" : [\n\t\"/dev/ttyUSB0\",\n\t\"/dev/ttyUSB1\",\n\t\"/dev/ttyUSB2\",\n\t\"/dev/ttyUSB3\"\n],\n\n\"kernel-path\" : \"/usr/local/bin\"\n}\n"
        },
        {
          "name": "findnonce.c",
          "type": "blob",
          "size": 6.328125,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2011 Nils Schneider\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <string.h>\n\n#include \"findnonce.h\"\n#include \"miner.h\"\n\n#ifdef USE_SHA256D\nconst uint32_t SHA256_K[64] = {\n\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n#define rotate(x,y) ((x<<y) | (x>>(sizeof(x)*8-y)))\n#define rotr(x,y) ((x>>y) | (x<<(sizeof(x)*8-y)))\n\n#define R(a, b, c, d, e, f, g, h, w, k) \\\n\th = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \\\n\td = d + h; \\\n\th = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))\n\nvoid precalc_hash(struct opencl_work_data *blk, uint32_t *state, uint32_t *data)\n{\n\tcl_uint A, B, C, D, E, F, G, H;\n\n\tA = state[0];\n\tB = state[1];\n\tC = state[2];\n\tD = state[3];\n\tE = state[4];\n\tF = state[5];\n\tG = state[6];\n\tH = state[7];\n\n\tR(A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);\n\tR(H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);\n\tR(G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);\n\n\tblk->cty_a = A;\n\tblk->cty_b = B;\n\tblk->cty_c = C;\n\tblk->cty_d = D;\n\n\tblk->D1A = D + 0xb956c25b;\n\n\tblk->cty_e = E;\n\tblk->cty_f = F;\n\tblk->cty_g = G;\n\tblk->cty_h = H;\n\n\tblk->ctx_a = state[0];\n\tblk->ctx_b = state[1];\n\tblk->ctx_c = state[2];\n\tblk->ctx_d = state[3];\n\tblk->ctx_e = state[4];\n\tblk->ctx_f = state[5];\n\tblk->ctx_g = state[6];\n\tblk->ctx_h = state[7];\n\n\tblk->merkle = data[0];\n\tblk->ntime = data[1];\n\tblk->nbits = data[2];\n\n\tblk->W16 = blk->fW0 = data[0] + (rotr(data[1], 7) ^ rotr(data[1], 18) ^ (data[1] >> 3));\n\tblk->W17 = blk->fW1 = data[1] + (rotr(data[2], 7) ^ rotr(data[2], 18) ^ (data[2] >> 3)) + 0x01100000;\n\tblk->PreVal4 = blk->fcty_e = blk->ctx_e + (rotr(B, 6) ^ rotr(B, 11) ^ rotr(B, 25)) + (D ^ (B & (C ^ D))) + 0xe9b5dba5;\n\tblk->T1 = blk->fcty_e2 = (rotr(F, 2) ^ rotr(F, 13) ^ rotr(F, 22)) + ((F & G) | (H & (F | G)));\n\tblk->PreVal4_2 = blk->PreVal4 + blk->T1;\n\tblk->PreVal0 = blk->PreVal4 + blk->ctx_a;\n\tblk->PreW31 = 0x00000280 + (rotr(blk->W16,  7) ^ rotr(blk->W16, 18) ^ (blk->W16 >> 3));\n\tblk->PreW32 = blk->W16 + (rotr(blk->W17, 7) ^ rotr(blk->W17, 18) ^ (blk->W17 >> 3));\n\tblk->PreW18 = data[2] + (rotr(blk->W16, 17) ^ rotr(blk->W16, 19) ^ (blk->W16 >> 10));\n\tblk->PreW19 = 0x11002000 + (rotr(blk->W17, 17) ^ rotr(blk->W17, 19) ^ (blk->W17 >> 10));\n\n\n\tblk->W2 = data[2];\n\n\tblk->W2A = blk->W2 + (rotr(blk->W16, 19) ^ rotr(blk->W16, 17) ^ (blk->W16 >> 10));\n\tblk->W17_2 = 0x11002000 + (rotr(blk->W17, 19) ^ rotr(blk->W17, 17) ^ (blk->W17 >> 10));\n\n\tblk->fW2 = data[2] + (rotr(blk->fW0, 17) ^ rotr(blk->fW0, 19) ^ (blk->fW0 >> 10));\n\tblk->fW3 = 0x11002000 + (rotr(blk->fW1, 17) ^ rotr(blk->fW1, 19) ^ (blk->fW1 >> 10));\n\tblk->fW15 = 0x00000280 + (rotr(blk->fW0, 7) ^ rotr(blk->fW0, 18) ^ (blk->fW0 >> 3));\n\tblk->fW01r = blk->fW0 + (rotr(blk->fW1, 7) ^ rotr(blk->fW1, 18) ^ (blk->fW1 >> 3));\n\n\n\tblk->PreVal4addT1 = blk->PreVal4 + blk->T1;\n\tblk->T1substate0 = blk->ctx_a - blk->T1;\n\n\tblk->C1addK5 = blk->cty_c + SHA256_K[5];\n\tblk->B1addK6 = blk->cty_b + SHA256_K[6];\n\tblk->PreVal0addK7 = blk->PreVal0 + SHA256_K[7];\n\tblk->W16addK16 = blk->W16 + SHA256_K[16];\n\tblk->W17addK17 = blk->W17 + SHA256_K[17];\n\n\tblk->zeroA = blk->ctx_a + 0x98c7e2a2;\n\tblk->zeroB = blk->ctx_a + 0xfc08884d;\n\tblk->oneA = blk->ctx_b + 0x90bb1e3c;\n\tblk->twoA = blk->ctx_c + 0x50c6645b;\n\tblk->threeA = blk->ctx_d + 0x3ac42e24;\n\tblk->fourA = blk->ctx_e + SHA256_K[4];\n\tblk->fiveA = blk->ctx_f + SHA256_K[5];\n\tblk->sixA = blk->ctx_g + SHA256_K[6];\n\tblk->sevenA = blk->ctx_h + SHA256_K[7];\n}\n#endif\n\nstruct pc_data {\n\tstruct thr_info *thr;\n\tstruct work work;\n\tuint32_t res[OPENCL_MAX_BUFFERSIZE];\n\tpthread_t pth;\n\tint found;\n\tenum cl_kernels kinterface;\n};\n\nstatic void *postcalc_hash(void *userdata)\n{\n\tstruct pc_data *pcd = (struct pc_data *)userdata;\n\tstruct thr_info *thr = pcd->thr;\n\tunsigned int entry = 0;\n\tint found = FOUND;\n#ifdef USE_SCRYPT\n\tif (pcd->kinterface == KL_SCRYPT)\n\t\tfound = SCRYPT_FOUND;\n#endif\n\n\tpthread_detach(pthread_self());\n\tRenameThread(\"postcalchsh\");\n\n\t/* To prevent corrupt values in FOUND from trying to read beyond the\n\t * end of the res[] array */\n\tif (unlikely(pcd->res[found] & ~found)) {\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": invalid nonce count - HW error\",\n\t\t\t\tthr->cgpu->proc_repr);\n\t\tinc_hw_errors_only(thr);\n\t\tpcd->res[found] &= found;\n\t}\n\n\tfor (entry = 0; entry < pcd->res[found]; entry++) {\n\t\tuint32_t nonce = pcd->res[entry];\n#ifdef USE_OPENCL_FULLHEADER\n\t\tif (pcd->kinterface == KL_FULLHEADER)\n\t\t\tnonce = swab32(nonce);\n#endif\n\n\t\tapplog(LOG_DEBUG, \"OCL NONCE %u found in slot %d\", nonce, entry);\n\t\tsubmit_nonce(thr, &pcd->work, nonce);\n\t}\n\n\tclean_work(&pcd->work);\n\tfree(pcd);\n\n\treturn NULL;\n}\n\nvoid postcalc_hash_async(struct thr_info * const thr, struct work * const work, uint32_t * const res, const enum cl_kernels kinterface)\n{\n\tstruct pc_data *pcd = malloc(sizeof(struct pc_data));\n\tint buffersize;\n\n\tif (unlikely(!pcd)) {\n\t\tapplog(LOG_ERR, \"Failed to malloc pc_data in postcalc_hash_async\");\n\t\treturn;\n\t}\n\n\t*pcd = (struct pc_data){\n\t\t.thr = thr,\n\t\t.kinterface = kinterface,\n\t};\n\t__copy_work(&pcd->work, work);\n#ifdef USE_SCRYPT\n\tif (kinterface == KL_SCRYPT)\n\t\tbuffersize = SCRYPT_BUFFERSIZE;\n\telse\n#endif\n\t\tbuffersize = BUFFERSIZE;\n\tmemcpy(&pcd->res, res, buffersize);\n\n\tif (pthread_create(&pcd->pth, NULL, postcalc_hash, (void *)pcd)) {\n\t\tapplog(LOG_ERR, \"Failed to create postcalc_hash thread\");\n\t\treturn;\n\t}\n}\n"
        },
        {
          "name": "findnonce.h",
          "type": "blob",
          "size": 0.7529296875,
          "content": "#ifndef BFG_FINDNONCE_H\n#define BFG_FINDNONCE_H\n\n#include <stdint.h>\n\n#include \"driver-opencl.h\"\n#include \"miner.h\"\n#include \"config.h\"\n\n#define MAXTHREADS (0xFFFFFFFEULL)\n#define MAXBUFFERS (0x10)\n#define BUFFERSIZE (sizeof(uint32_t) * MAXBUFFERS)\n#define FOUND (0x0F)\n\n#ifdef USE_SCRYPT\n#define SCRYPT_MAXBUFFERS (0x100)\n#define SCRYPT_BUFFERSIZE (sizeof(uint32_t) * SCRYPT_MAXBUFFERS)\n#define SCRYPT_FOUND (0xFF)\n\n#define OPENCL_MAX_BUFFERSIZE  SCRYPT_BUFFERSIZE\n#else\n#define OPENCL_MAX_BUFFERSIZE  BUFFERSIZE\n#endif\n\n#ifdef USE_SHA256D\nextern void precalc_hash(struct opencl_work_data *blk, uint32_t *state, uint32_t *data);\n#endif\nextern void postcalc_hash_async(struct thr_info *thr, struct work *work, uint32_t *res, enum cl_kernels);\n\n#endif /*__FINDNONCE_H__*/\n"
        },
        {
          "name": "gc3355.c",
          "type": "blob",
          "size": 14.99609375,
          "content": "/*\n * Copyright 2014 Nate Woolls\n * Copyright 2014 Luke Dashjr\n * Copyright 2014 GridSeed Team\n * Copyright 2014 Dualminer Team\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include \"gc3355.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"miner.h\"\n#include \"driver-icarus.h\"\n#include \"logging.h\"\n#include \"lowl-vcom.h\"\n\n#ifndef WIN32\n  #include <sys/ioctl.h>\n#else\n  #include <io.h>\n#endif\n\n// options configurable by the end-user\n\nint opt_sha2_units = -1;\nint opt_pll_freq = 0; // default is set in gc3355_set_pll_freq\n\n#define GC3355_CHIP_NAME         \"gc3355\"\n#define GC3355_COMMAND_DELAY_MS  20\n#define GC3355_WRITE_DELAY_MS    10\n\n// General GC3355 commands\n\nstatic\nconst char *firmware_request_cmd[] =\n{\n\t\"55AAC000909090900000000001000000\",  // get firmware version of GC3355\n\tNULL\n};\n\n// SHA-2 commands\n\nstatic\nconst char *sha2_gating_cmd[] =\n{\n\t\"55AAEF0200000000\",  // Chip 1 - power down SHA-2 (unless masked w/PLL)\n\t\"55AAEF0300000000\",  // Chip 2\n\t\"55AAEF0400000000\",  // Chip 3\n\t\"55AAEF0500000000\",  // Chip 4\n\t\"55AAEF0600000000\",  // Chip 5\n\tNULL\n};\n\n// maps the above SHA chip gating with SHA-2 units\nstatic\nconst char *sha2_open_cmd[] =\n{\n\t\"55AAEF0200000001\",\n\t\"55AAEF0200000003\",\n\t\"55AAEF0200000007\",\n\t\"55AAEF020000000F\",\n\t\"55AAEF020000001F\",\n\t\"55AAEF020000003F\",\n\t\"55AAEF020000007F\",\n\t\"55AAEF02000000FF\",\n\t\"55AAEF02000001FF\",\n\t\"55AAEF02000003FF\",\n\t\"55AAEF02000007FF\",\n\t\"55AAEF0200000FFF\",\n\t\"55AAEF0200001FFF\",\n\t\"55AAEF0200003FFF\",\n\t\"55AAEF0200007FFF\",\n\t\"55AAEF020000FFFF\",\n\t\"55AAEF020001FFFF\",\n\t\"55AAEF020003FFFF\",\n\t\"55AAEF020007FFFF\",\n\t\"55AAEF02000FFFFF\",\n\t\"55AAEF02001FFFFF\",\n\t\"55AAEF02003FFFFF\",\n\t\"55AAEF02007FFFFF\",\n\t\"55AAEF0200FFFFFF\",\n\t\"55AAEF0201FFFFFF\",\n\t\"55AAEF0203FFFFFF\",\n\t\"55AAEF0207FFFFFF\",\n\t\"55AAEF020FFFFFFF\",\n\t\"55AAEF021FFFFFFF\",\n\t\"55AAEF023FFFFFFF\",\n\t\"55AAEF027FFFFFFF\",\n\t\"55AAEF02FFFFFFFF\",\n\t\"55AAEF0300000001\",\n\t\"55AAEF0300000003\",\n\t\"55AAEF0300000007\",\n\t\"55AAEF030000000F\",\n\t\"55AAEF030000001F\",\n\t\"55AAEF030000003F\",\n\t\"55AAEF030000007F\",\n\t\"55AAEF03000000FF\",\n\t\"55AAEF03000001FF\",\n\t\"55AAEF03000003FF\",\n\t\"55AAEF03000007FF\",\n\t\"55AAEF0300000FFF\",\n\t\"55AAEF0300001FFF\",\n\t\"55AAEF0300003FFF\",\n\t\"55AAEF0300007FFF\",\n\t\"55AAEF030000FFFF\",\n\t\"55AAEF030001FFFF\",\n\t\"55AAEF030003FFFF\",\n\t\"55AAEF030007FFFF\",\n\t\"55AAEF03000FFFFF\",\n\t\"55AAEF03001FFFFF\",\n\t\"55AAEF03003FFFFF\",\n\t\"55AAEF03007FFFFF\",\n\t\"55AAEF0300FFFFFF\",\n\t\"55AAEF0301FFFFFF\",\n\t\"55AAEF0303FFFFFF\",\n\t\"55AAEF0307FFFFFF\",\n\t\"55AAEF030FFFFFFF\",\n\t\"55AAEF031FFFFFFF\",\n\t\"55AAEF033FFFFFFF\",\n\t\"55AAEF037FFFFFFF\",\n\t\"55AAEF03FFFFFFFF\",\n\t\"55AAEF0400000001\",\n\t\"55AAEF0400000003\",\n\t\"55AAEF0400000007\",\n\t\"55AAEF040000000F\",\n\t\"55AAEF040000001F\",\n\t\"55AAEF040000003F\",\n\t\"55AAEF040000007F\",\n\t\"55AAEF04000000FF\",\n\t\"55AAEF04000001FF\",\n\t\"55AAEF04000003FF\",\n\t\"55AAEF04000007FF\",\n\t\"55AAEF0400000FFF\",\n\t\"55AAEF0400001FFF\",\n\t\"55AAEF0400003FFF\",\n\t\"55AAEF0400007FFF\",\n\t\"55AAEF040000FFFF\",\n\t\"55AAEF040001FFFF\",\n\t\"55AAEF040003FFFF\",\n\t\"55AAEF040007FFFF\",\n\t\"55AAEF04000FFFFF\",\n\t\"55AAEF04001FFFFF\",\n\t\"55AAEF04003FFFFF\",\n\t\"55AAEF04007FFFFF\",\n\t\"55AAEF0400FFFFFF\",\n\t\"55AAEF0401FFFFFF\",\n\t\"55AAEF0403FFFFFF\",\n\t\"55AAEF0407FFFFFF\",\n\t\"55AAEF040FFFFFFF\",\n\t\"55AAEF041FFFFFFF\",\n\t\"55AAEF043FFFFFFF\",\n\t\"55AAEF047FFFFFFF\",\n\t\"55AAEF04FFFFFFFF\",\n\t\"55AAEF0500000001\",\n\t\"55AAEF0500000003\",\n\t\"55AAEF0500000007\",\n\t\"55AAEF050000000F\",\n\t\"55AAEF050000001F\",\n\t\"55AAEF050000003F\",\n\t\"55AAEF050000007F\",\n\t\"55AAEF05000000FF\",\n\t\"55AAEF05000001FF\",\n\t\"55AAEF05000003FF\",\n\t\"55AAEF05000007FF\",\n\t\"55AAEF0500000FFF\",\n\t\"55AAEF0500001FFF\",\n\t\"55AAEF0500003FFF\",\n\t\"55AAEF0500007FFF\",\n\t\"55AAEF050000FFFF\",\n\t\"55AAEF050001FFFF\",\n\t\"55AAEF050003FFFF\",\n\t\"55AAEF050007FFFF\",\n\t\"55AAEF05000FFFFF\",\n\t\"55AAEF05001FFFFF\",\n\t\"55AAEF05003FFFFF\",\n\t\"55AAEF05007FFFFF\",\n\t\"55AAEF0500FFFFFF\",\n\t\"55AAEF0501FFFFFF\",\n\t\"55AAEF0503FFFFFF\",\n\t\"55AAEF0507FFFFFF\",\n\t\"55AAEF050FFFFFFF\",\n\t\"55AAEF051FFFFFFF\",\n\t\"55AAEF053FFFFFFF\",\n\t\"55AAEF057FFFFFFF\",\n\t\"55AAEF05FFFFFFFF\",\n\t\"55AAEF0600000001\",\n\t\"55AAEF0600000003\",\n\t\"55AAEF0600000007\",\n\t\"55AAEF060000000F\",\n\t\"55AAEF060000001F\",\n\t\"55AAEF060000003F\",\n\t\"55AAEF060000007F\",\n\t\"55AAEF06000000FF\",\n\t\"55AAEF06000001FF\",\n\t\"55AAEF06000003FF\",\n\t\"55AAEF06000007FF\",\n\t\"55AAEF0600000FFF\",\n\t\"55AAEF0600001FFF\",\n\t\"55AAEF0600003FFF\",\n\t\"55AAEF0600007FFF\",\n\t\"55AAEF060000FFFF\",\n\t\"55AAEF060001FFFF\",\n\t\"55AAEF060003FFFF\",\n\t\"55AAEF060007FFFF\",\n\t\"55AAEF06000FFFFF\",\n\t\"55AAEF06001FFFFF\",\n\t\"55AAEF06003FFFFF\",\n\t\"55AAEF06007FFFFF\",\n\t\"55AAEF0600FFFFFF\",\n\t\"55AAEF0601FFFFFF\",\n\t\"55AAEF0603FFFFFF\",\n\t\"55AAEF0607FFFFFF\",\n\t\"55AAEF060FFFFFFF\",\n\t\"55AAEF061FFFFFFF\",\n\t\"55AAEF063FFFFFFF\",\n\t\"55AAEF067FFFFFFF\",\n\t\"55AAEF06FFFFFFFF\",\n\tNULL\n};\n\nstatic\nconst char *multichip_init_cmd[] =\n{\n\t\"55AAC000C0C0C0C00500000001000000\",  // set number of sub-chips (05 in this case)\n\t\"55AAEF020000000000000000000000000000000000000000\",  // power down all SHA-2 modules\n\t\"55AAEF3020000000\",  // Enable SHA-2 OR NOT - NO SCRYPT ACCEPTS WITHOUT THIS???\n\tNULL\n};\n\nstatic\nconst char *sha2_init_cmd[] =\n{\n\t\"55AAEF3020000000\",  // Enable SHA-2\n\t\"55AA1F2817000000\",  // Enable GCP\n\tNULL\n};\n\n// called when initializing GridSeed device\n// called while initializing DualMiner when mining in scrypt+sha (dual-mode)\nstatic\nconst char *scrypt_init_cmd[] =\n{\n\t\"55AA1F2814000000\",  // Enable Scrypt\n\t\"55AA1F2817000000\",  // Enable GCP\n\tNULL\n};\n\n// called before job start by GridSeed when mining scrypt\n// called before job start by DualMiner when mining scrypt in scrypt+sha (dual-mode)\nstatic\nconst char *scrypt_reset_cmd[] =\n{\n\t// faster, for start of each job:\n\t\"55AA1F2816000000\",  // Reset Scrypt(?)\n\t\"55AA1F2817000000\",  // Enable GCP(?)\n\tNULL\n};\n\n// called while initializing DualMiner when mining scrypt in scrypt-only (not dual-mode)\nstatic\nconst char *scrypt_only_init_cmd[] =\n{\n\t\"55AAEF0200000000\",\n\t\"55AAEF0300000000\",\n\t\"55AAEF0400000000\",\n\t\"55AAEF0500000000\",\n\t\"55AAEF0600000000\",\n\t\"55AAEF3040000000\",\n\t\"55AA1F2810000000\",\n\t\"55AA1F2813000000\",\n\tNULL\n};\n\n// called before job start by DualMiner when mining scrypt in scrypt-only (not dual-mode)\n// called while initializing DualMiner when mining scrypt in scrypt-only (not dual-mode)\nstatic\nconst char *scrypt_only_reset_cmd[] =\n{\n\t\"55AA1F2810000000\",  // Close Scrypt(?)\n\t\"55AA1F2813000000\",  // Open Scrypt(?)\n\tNULL\n};\n\nstatic\nconst char *gcp_chip_reset_cmd[] =\n{\n\t\"55AAC000808080800000000001000000\",  // GCP (GridChip) reset\n\tNULL\n};\n\nstatic\nconst char *sha2_chip_reset_cmd[] =\n{\n\t\"55AAC000E0E0E0E00000000001000000\",  // SHA2 reset\n\tNULL\n};\n\n\nvoid gc3355_reset_dtr(int fd)\n{\n\t// set data terminal ready (DTR) status\n\tset_serial_dtr(fd, BGV_HIGH);\n\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\tset_serial_dtr(fd, BGV_LOW);\n}\n\nstatic\nvoid gc3355_set_register(uint8_t * const buf, const uint8_t clusaddr, const uint8_t chipaddr, const uint8_t regaddr, const uint32_t val)\n{\n\tbuf[0] = 0x55;\n\tbuf[1] = 0xaa;\n\tbuf[2] = (clusaddr << 4) | chipaddr;\n\tbuf[3] = regaddr;\n\tbuf[4] = (val >>    0) & 0xff;\n\tbuf[5] = (val >>    8) & 0xff;\n\tbuf[6] = (val >> 0x10) & 0xff;\n\tbuf[7] = (val >> 0x18) & 0xff;\n}\n\nstatic\nvoid gc3355_config_cpm(uint8_t * const buf, const uint8_t chipaddr, const float mhz)\n{\n\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_Register_Spec.pdf\n\tconst uint8_t pll_bypass = 1;\n\tconst uint8_t pll_bandselect = 0;\n\tconst uint8_t pll_outdiv = 0;\n\t\n\tuint8_t freq_div, freq_mult, last_freq_mult = 0;  // mhz = (25 / freq_div * freq_mult)\n\tfloat actual_mhz, last_actual_mhz = -1;\n\tfor (freq_div = 1; freq_div <= 32; ++freq_div)\n\t{\n\t\tfreq_mult = mhz * freq_div / 25;\n\t\tif (freq_mult > 0x80)\n\t\t\tfreq_mult = 0x80;\n\t\tactual_mhz = 25. / freq_div * freq_mult;\n\t\tif (last_actual_mhz > actual_mhz)\n\t\t{\n\t\t\t--freq_div;\n\t\t\tfreq_mult = last_freq_mult;\n\t\t\tif (opt_debug)\n\t\t\t\tactual_mhz = 25. / freq_div * freq_mult;\n\t\t\tbreak;\n\t\t}\n\t\tif (actual_mhz > mhz - .5)\n\t\t\tbreak;\n\t\tlast_actual_mhz = actual_mhz;\n\t\tlast_freq_mult = freq_mult;\n\t}\n\tconst uint8_t pll_F = freq_mult - 1;\n\tconst uint8_t pll_R = freq_div - 1;\n\t\n\tconst uint8_t core_clk_out1_diven = 0;\n\tconst uint8_t core_clk_sel1 = 0;\n\tconst uint8_t core_clk_sel0 = 0;\n\tconst uint8_t pll_clk_gate = 0;\n\tconst uint8_t pll_recfg = 1;\n\tconst uint8_t cfg_cpm = 1;\n\tconst uint32_t cfg = (pll_bypass << 31) | (pll_bandselect << 30) | (pll_outdiv << 28) | (pll_F << 21) | (pll_R << 16) | (core_clk_out1_diven << 6) | (core_clk_sel1 << 5) | (core_clk_sel0 << 4) | (pll_clk_gate << 3) | (pll_recfg << 2) | (cfg_cpm << 0);\n\tgc3355_set_register(buf, 0xe, chipaddr, 0, cfg);\n}\n\n// NOTE: MHz must match CPM config\nstatic\nvoid gc3355_config_sha256d(uint8_t * const buf, const uint8_t chipaddr, const float mhz, const uint32_t baud)\n{\n\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_Register_Spec.pdf\n\tconst uint8_t force_start = 1;\n\tconst uint8_t uart_enable = 1;\n\tconst uint8_t uart_debug = 0;\n\tconst uint8_t byte_order = 0;\n\tconst uint16_t rpt_cycle = (mhz * 1000000 / baud);\n\tconst uint32_t cfg = (force_start << 31) | (uart_enable << 30) | (uart_debug << 29) | (byte_order << 28) | rpt_cycle;\n\tgc3355_set_register(buf, 0, chipaddr, 0xff, cfg);\n}\n\nstatic\nvoid gc3355_log_protocol(int fd, const char *buf, size_t size, const char *prefix)\n{\n\tchar hex[(size * 2) + 1];\n\tbin2hex(hex, buf, size);\n\tapplog(LOG_DEBUG, \"%s fd=%d: DEVPROTO: %s(%3lu) %s\",\n\t       GC3355_CHIP_NAME, fd, prefix, (unsigned long)size, hex);\n}\n\nssize_t gc3355_read(int fd, char *buf, size_t size)\n{\n\tsize_t read = serial_read(fd, buf, size);\n\t\n\tif ((read > 0) && opt_dev_protocol)\n\t\tgc3355_log_protocol(fd, buf, read, \"RECV\");\n\t\n\treturn read;\n}\n\nssize_t gc3355_write(int fd, const void * const buf, const size_t size)\n{\n\tif (opt_dev_protocol)\n\t\tgc3355_log_protocol(fd, buf, size, \"SEND\");\n\n\tssize_t result = write(fd, buf, size);\n\n\t// gc3355 can suffer register corruption if multiple writes are\n\t// made in a short period of time.\n\t// This is not possible to reproduce on Mac OS X where the serial\n\t// drivers seem to carry an additional overhead / latency.\n\t// This is reproducable on Linux though by removing the following:\n\tcgsleep_ms(GC3355_WRITE_DELAY_MS);\n\n\treturn result;\n}\n\nstatic\nvoid gc3355_send_cmds(int fd, const char *cmds[])\n{\n\tint i = 0;\n\tunsigned char ob_bin[512];\n\tfor (i = 0; ; i++)\n\t{\n\t\tconst char *cmd = cmds[i];\n\t\tif (cmd == NULL)\n\t\t\tbreak;\n\n\t\tint bin_size = strlen(cmd) / 2;\n\t\thex2bin(ob_bin, cmd, bin_size);\n\t\tgc3355_write(fd, ob_bin, bin_size);\n\n\t\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\t}\n}\n\nvoid gc3355_scrypt_only_reset(int fd)\n{\n\tgc3355_send_cmds(fd, scrypt_only_reset_cmd);\n}\n\nvoid gc3355_set_pll_freq(int fd, int pll_freq)\n{\n\tconst uint8_t chipaddr = 0xf;\n\tconst uint32_t baud = 115200;  // FIXME: Make this configurable\n\tuint8_t buf[8];\n\t\n\tgc3355_config_cpm(buf, chipaddr, pll_freq);\n\tgc3355_write(fd, buf, sizeof(buf));\n\t\n\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\t\n\tgc3355_config_sha256d(buf, chipaddr, pll_freq, baud);\n\tgc3355_write(fd, buf, sizeof(buf));\n}\n\nstatic\nvoid gc3355_open_sha2_units(int fd, int sha2_units)\n{\n\tint unit_count = 0;\n\tunsigned char ob_bin[8];\n\tint i;\n\n\t// should be 0 - 160\n\tunit_count = sha2_units < 0 ? 0 : sha2_units > 160 ? 160 : sha2_units;\n\n\tif (unit_count > 0)\n\t{\n\t\tfor(i = 0; i <= unit_count; i++)\n\t\t{\n\t\t\thex2bin(ob_bin, sha2_open_cmd[i], sizeof(ob_bin));\n\t\t\tgc3355_write(fd, ob_bin, 8);\n\t\t\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\t\t}\n\t}\n\telse if (unit_count == 0)\n\t\tgc3355_send_cmds(fd, sha2_gating_cmd);\n}\n\nvoid gc3355_scrypt_init(int fd)\n{\n\tgc3355_send_cmds(fd, scrypt_init_cmd);\n}\n\nstatic\nvoid gc3355_scrypt_only_init(int fd)\n{\n\tgc3355_send_cmds(fd, sha2_gating_cmd);\n\tgc3355_send_cmds(fd, scrypt_only_init_cmd);\n\tgc3355_scrypt_only_reset(fd);\n}\n\nvoid gc3355_sha2_init(int fd)\n{\n\tgc3355_send_cmds(fd, sha2_gating_cmd);\n\tgc3355_send_cmds(fd, sha2_init_cmd);\n}\n\nvoid gc3355_init_miner(int fd, int pll_freq)\n{\n\tgc3355_send_cmds(fd, gcp_chip_reset_cmd);\n\n\t// zzz\n\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\n\t// initialize units\n\tgc3355_send_cmds(fd, multichip_init_cmd);\n\tgc3355_scrypt_init(fd);\n\n\t//set freq\n\tgc3355_set_pll_freq(fd, pll_freq);\n}\n\nvoid gc3355_init_dualminer(int fd, int pll_freq, bool scrypt_only, bool detect_only, bool scrypt)\n{\n\tgc3355_send_cmds(fd, gcp_chip_reset_cmd);\n\n\t// zzz\n\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\n\tgc3355_send_cmds(fd, sha2_chip_reset_cmd);\n\n\t// initialize units\n\tgc3355_reset_dtr(fd);\n\n\tif (scrypt && scrypt_only)\n\t\tgc3355_scrypt_only_init(fd);\n\telse\n\t{\n\t\tgc3355_sha2_init(fd);\n\t\tgc3355_scrypt_init(fd);\n\t}\n\n\t//set freq\n\tgc3355_set_pll_freq(fd, pll_freq);\n\n\t// zzz\n\tcgsleep_ms(GC3355_COMMAND_DELAY_MS);\n\n\tif (!detect_only)\n\t{\n\t\tif (!scrypt)\n\t\t\t// open sha2 units\n\t\t\tgc3355_open_sha2_units(fd, opt_sha2_units);\n\n\t\t// set request to send (RTS) status\n\t\tset_serial_rts(fd, BGV_HIGH);\n\t}\n}\n\nvoid gc3355_scrypt_reset(int fd)\n{\n\tgc3355_send_cmds(fd, scrypt_reset_cmd);\n}\n\nvoid gc3355_scrypt_prepare_work(unsigned char cmd[156], struct work *work)\n{\n\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_Register_Spec.pdf\n\n\t// command header\n\tcmd[0] = 0x55;  // static header\n\tcmd[1] = 0xaa;  // static header\n\tcmd[2] = 0x1f;  // 0x1 (for Scrypt) | chip_id (0xf for broadcast)\n\tcmd[3] = 0x00;  // identifies the following task data, beginning with 0x00\n\t                // gc3355 supports sending batches of work at once\n\t                // in which case this would be incremented for each batch\n\t\n\t// task data - starts at 0x0 (with 4 byte offset for header)\n\tmemcpy(cmd + 4, work->target, 32);\n\tmemcpy(cmd + 36, work->midstate, 32);\n\tmemcpy(cmd + 68, work->data, 80);\n\n\t// nonce min - starts at 0x23 (with 4 byte offset for header)\n\tcmd[144] = 0x00;\n\tcmd[145] = 0x00;\n\tcmd[146] = 0x00;\n\tcmd[147] = 0x00;\n\n\t// nonce max - starts at 0x24 (with 4 byte offset for header)\n\tcmd[148] = 0xff;\n\tcmd[149] = 0xff;\n\tcmd[150] = 0xff;\n\tcmd[151] = 0xff;\n\n\t// 0x25 - 0x28 are for specific Scrypt unit configs, don't set without reason\n}\n\nvoid gc3355_sha2_prepare_work(unsigned char cmd[52], struct work *work)\n{\n\t// See https://github.com/gridseed/gc3355-doc/blob/master/GC3355_Register_Spec.pdf\n\n\t// command header\n\tcmd[0] = 0x55;  // static header\n\tcmd[1] = 0xaa;  // static header\n\tcmd[2] = 0x0f;  // 0x0 (for SHA2) | chip_id (0xf for broadcast)\n\tcmd[3] = 0x00;  // identifies the following task data, beginning with 0x00\n\t                // gc3355 supports sending batches of work at once\n\t                // in which case this would be incremented for each batch\n\n\t// initial nonce - starts at 0x0 (with 4 byte offset for header)\n\tcmd[4] = 0x00;\n\tcmd[5] = 0x00;\n\tcmd[6] = 0x00;\n\tcmd[7] = 0x00;\n\n\t// task data - starts at 0x1 (with 4 byte offset for header)\n\tmemcpy(cmd + 8, work->midstate, 32);\n\tmemcpy(cmd + 40, work->data + 64, 12);\n\n\t// 0x1e - 0xff are for specific SHA2 unit configs, don't set without reason\n}\n\nint64_t gc3355_get_firmware_version(int fd)\n{\n\tgc3355_send_cmds(fd, firmware_request_cmd);\n\t\n\tchar buf[GC3355_READ_SIZE];\n\tint read = gc3355_read(fd, buf, GC3355_READ_SIZE);\n\tif (read != GC3355_READ_SIZE)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed reading work from %d\", GC3355_CHIP_NAME, fd);\n\t\treturn -1;\n\t}\n\t\n\t// firmware response begins with 55aac000 90909090\n\tif (memcmp(buf, \"\\x55\\xaa\\xc0\\x00\\x90\\x90\\x90\\x90\", GC3355_READ_SIZE - 4) != 0)\n\t\treturn -1;\n\t\n\tuint32_t fw_version = be32toh(*(uint32_t *)(buf + 8));\n\t\n\treturn fw_version;\n}\n"
        },
        {
          "name": "gc3355.h",
          "type": "blob",
          "size": 1.6416015625,
          "content": "/*\n * Copyright 2014 Nate Woolls\n * Copyright 2014 GridSeed Team\n * Copyright 2014 Dualminer Team\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef bfgminer_gc3355_h\n#define bfgminer_gc3355_h\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"miner.h\"\n\n// options configurable by the end-user\n\nextern int opt_sha2_units;\n\nextern\nint opt_pll_freq;\n\n// GridSeed common code begins here\n\n#define GC3355_ORB_DEFAULT_CHIPS   5\n#define GC3355_BLADE_DEFAULT_CHIPS\t40\n#define GC3355_READ_SIZE          12\n\nstruct gc3355_info\n{\n\tuint16_t freq;\n\tunsigned chips;\n};\n\n#define gc3355_open(path)  serial_open(path, 115200, 1, true)\n#define gc3355_close(fd)  serial_close(fd)\n\nextern ssize_t gc3355_read(int fd, char *buf, size_t size);\nextern ssize_t gc3355_write(int fd, const void * const buf, const size_t size);\n\nextern void gc3355_init_miner(int fd, int pll_freq);\nextern void gc3355_init_dualminer(int fd, int pll_freq, bool scrypt_only, bool detect_only, bool scrypt);\n\nextern void gc3355_scrypt_reset(int fd);\nextern void gc3355_scrypt_only_reset(int fd);\n\nextern void gc3355_scrypt_prepare_work(unsigned char cmd[156], struct work *);\nextern void gc3355_sha2_prepare_work(unsigned char cmd[52], struct work *);\n\nextern int64_t gc3355_get_firmware_version(int fd);\nextern void gc3355_set_pll_freq(int fd, int pll_freq);\n\n#define gc3355_get_cts_status(fd)  ((get_serial_cts(fd) == BGV_LOW) ? 1 : 0)\n\n#endif\n"
        },
        {
          "name": "gen-version.sh",
          "type": "blob",
          "size": 0.5654296875,
          "content": "#!/bin/sh\ngitdesc=\nif [ -e .git ]; then\n\t# Some versions of git require `git diff` to scan and update dirty-or-not status\n\tgit diff >/dev/null 2>/dev/null\n\t\n\tgitdesc=$(git describe)\nfi\nif [ -z \"$gitdesc\" ]; then\n\tcurrent=$(sed 's/^\\#define[[:space:]]\\+BFG_GIT_DESCRIBE[[:space:]]\\+\\\"\\(.*\\)\\\"$/\\1/;t;d' version.h)\n\tif [ -z \"$current\" ]; then\n\t\tgitdesc='\"PACKAGE_VERSION\"-unknown'\n\telse\n\t\tgitdesc=\"$current\"\n\tfi\nfi\nversion=$(echo \"$gitdesc\" | sed 's/^bfgminer-//')\ncat <<EOF\n#define BFG_GIT_DESCRIBE \"$gitdesc\"\n#ifdef VERSION\n#  undef VERSION\n#endif\n#define VERSION \"$version\"\nEOF\n"
        },
        {
          "name": "httpsrv.c",
          "type": "blob",
          "size": 2.646484375,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#endif\n\n#include <microhttpd.h>\n\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nstatic struct MHD_Daemon *httpsrv;\n\nextern int handle_getwork(struct MHD_Connection *, bytes_t *);\n\nvoid httpsrv_prepare_resp(struct MHD_Response *resp)\n{\n\tMHD_add_response_header(resp, MHD_HTTP_HEADER_SERVER, bfgminer_name_slash_ver);\n}\n\nstatic\nint httpsrv_handle_req(struct MHD_Connection *conn, const char *url, const char *method, bytes_t *upbuf)\n{\n\treturn handle_getwork(conn, upbuf);\n}\n\nstatic\n#if MHD_VERSION < 0x00097002\nint\n#else\nenum MHD_Result\n#endif\nhttpsrv_handle_access(void *cls, struct MHD_Connection *conn, const char *url, const char *method, const char *version, const char *upload_data, size_t *upload_data_size, void **con_cls)\n{\n\tbytes_t *upbuf;\n\t\n\tif (!*con_cls)\n\t{\n\t\t*con_cls = upbuf = malloc(sizeof(bytes_t));\n\t\tbytes_init(upbuf);\n\t\treturn MHD_YES;\n\t}\n\t\n\tupbuf = *con_cls;\n\tif (*upload_data_size)\n\t{\n\t\tbytes_append(upbuf, upload_data, *upload_data_size);\n\t\t*upload_data_size = 0;\n\t\treturn MHD_YES;\n\t}\n\treturn httpsrv_handle_req(conn, url, method, *con_cls);\n}\n\nstatic\nvoid httpsrv_cleanup_request(void *cls, struct MHD_Connection *conn, void **con_cls, enum MHD_RequestTerminationCode toe)\n{\n\tif (*con_cls)\n\t{\n\t\tbytes_t *upbuf = *con_cls;\n\t\tbytes_free(upbuf);\n\t\tfree(upbuf);\n\t\t*con_cls = NULL;\n\t}\n}\n\nstatic\nvoid httpsrv_log(void *arg, const char *fmt, va_list ap)\n{\n\tif (!opt_debug)\n\t\treturn;\n\t\n\tchar tmp42[LOGBUFSIZ] = \"HTTPSrv: \";\n\tvsnprintf(&tmp42[9], sizeof(tmp42)-9, fmt, ap);\n\t_applog(LOG_DEBUG, tmp42);\n}\n\nvoid httpsrv_start(unsigned short port)\n{\n\thttpsrv = MHD_start_daemon(\n\t\tMHD_USE_SELECT_INTERNALLY | MHD_USE_DEBUG,\n\t\tport, NULL, NULL,\n\t\t&httpsrv_handle_access, NULL,\n\t\tMHD_OPTION_NOTIFY_COMPLETED, &httpsrv_cleanup_request, NULL,\n\t\tMHD_OPTION_EXTERNAL_LOGGER, &httpsrv_log, NULL,\n\tMHD_OPTION_END);\n\tif (httpsrv)\n\t\tapplog(LOG_NOTICE, \"HTTP server listening on port %d\", (int)port);\n\telse\n\t\tapplog(LOG_ERR, \"Failed to start HTTP server on port %d\", (int)port);\n}\n\nvoid httpsrv_stop()\n{\n\tif (!httpsrv)\n\t\treturn;\n\t\n\tapplog(LOG_DEBUG, \"Stopping HTTP server\");\n\tMHD_stop_daemon(httpsrv);\n\thttpsrv = NULL;\n}\n"
        },
        {
          "name": "httpsrv.h",
          "type": "blob",
          "size": 0.2060546875,
          "content": "#ifndef BFG_HTTPSRV_H\n#define BFG_HTTPSRV_H\n\n#include <microhttpd.h>\n\nextern void httpsrv_start(unsigned short port);\nextern void httpsrv_prepare_resp(struct MHD_Response *);\nextern void httpsrv_stop();\n\n#endif\n"
        },
        {
          "name": "iospeeds.h",
          "type": "blob",
          "size": 0.2734375,
          "content": "#include <iospeeds_posix.h>\n\nIOSPEED(57600)\nIOSPEED(115200)\nIOSPEED(230400)\nIOSPEED(460800)\nIOSPEED(921600)\n\nIOSPEED(576000)\nIOSPEED(1152000)\n\nIOSPEED(1500000)\nIOSPEED(3000000)\n\nIOSPEED(500000)\nIOSPEED(1000000)\nIOSPEED(2000000)\nIOSPEED(4000000)\n\nIOSPEED(2500000)\nIOSPEED(3500000)\n"
        },
        {
          "name": "iospeeds_posix.h",
          "type": "blob",
          "size": 0.208984375,
          "content": "IOSPEED(0)\nIOSPEED(50)\nIOSPEED(110)\nIOSPEED(134)\nIOSPEED(200)\n\nIOSPEED(75)\nIOSPEED(150)\nIOSPEED(300)\nIOSPEED(600)\nIOSPEED(1200)\nIOSPEED(1800)\nIOSPEED(2400)\nIOSPEED(4800)\nIOSPEED(9600)\nIOSPEED(19200)\nIOSPEED(38400)\n"
        },
        {
          "name": "jtag.c",
          "type": "blob",
          "size": 7.146484375,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n// NOTE: This code is based on code Luke-Jr wrote originally for LPC1343CodeBase\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lowl-ftdi.h\"\n#include \"jtag.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n\n//#define DEBUG_JTAG_CLOCK\n\n#define FTDI_READ_BUFFER_SIZE 100\n\nstatic\nunsigned char jtag_clock_byte(struct jtag_port *jp, bool tms, bool tdi)\n{\n\treturn (jp->a->state & jp->ignored)\n\t          | (tms ? jp->tms : 0)\n\t          | (tdi ? jp->tdi : 0);\n}\n\n// NOTE: The order of tms and tdi here are inverted from LPC1343CodeBase\nbool jtag_clock(struct jtag_port *jp, bool tms, bool tdi, bool *tdo)\n{\n\tunsigned char bufsz = tdo ? 3 : 2;\n\tunsigned char buf[3];\n\tmemset(buf, jtag_clock_byte(jp, tms, tdi), sizeof(buf));\n\tbuf[2] =\n\tbuf[1] |= jp->tck;\n\tif (ft232r_write_all(jp->a->ftdi, buf, bufsz) != bufsz)\n\t\treturn false;\n\tjp->a->state = buf[2];\n\tif (jp->a->async) {\n\t\tif (unlikely(tdo))\n\t\t\tapplog(LOG_WARNING, \"jtag_clock: request for tdo in async mode not possible\");\n#ifdef DEBUG_JTAG_CLOCK\n\t\tapplog(LOG_DEBUG, \"%p %02x tms=%d tdi=%d tdo=?async\", jp, (unsigned)buf[2], (int)tms, (int)tdi);\n#endif\n\t\treturn true;\n\t}\n\tjp->a->bufread += bufsz;\n\tif (jp->a->bufread < FTDI_READ_BUFFER_SIZE - sizeof(buf) && !tdo) {\n\t\t// By deferring unnecessary reads, we can avoid some USB latency\n#ifdef DEBUG_JTAG_CLOCK\n\t\tapplog(LOG_DEBUG, \"%p %02x tms=%d tdi=%d tdo=?defer\", jp, (unsigned)buf[2], (int)tms, (int)tdi);\n#endif\n\t\treturn true;\n\t}\n#if 0 /* untested */\n\telse if (!tdo) {\n\t\tif (ft232r_purge_buffers(jp->a->ftdi, FTDI_PURGE_BOTH)) {\n\t\t\tjp->bufread = 0;\n#ifdef DEBUG_JTAG_CLOCK\n\t\tapplog(LOG_DEBUG, \"%p %02x tms=%d tdi=%d tdo=?purge\", jp, (unsigned)buf[2], (int)tms, (int)tdi);\n#endif\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\tuint8_t rbufsz = jp->a->bufread;\n\tjp->a->bufread = 0;\n\tunsigned char rbuf[rbufsz];\n\tif (ft232r_read_all(jp->a->ftdi, rbuf, rbufsz) != rbufsz)\n\t\treturn false;\n\tif (tdo) {\n\t\t*tdo = (rbuf[rbufsz-1] & jp->tdo);\n#ifdef DEBUG_JTAG_CLOCK\n\t\tchar x[(rbufsz * 2) + 1];\n\t\tbin2hex(x, rbuf, rbufsz);\n\tapplog(LOG_DEBUG, \"%p %02x tms=%d tdi=%d tdo=%d (%u:%s)\", jp, (unsigned)rbuf[rbufsz-1], (int)tms, (int)tdi, (int)(bool)(rbuf[rbufsz-1] & jp->tdo), (unsigned)rbufsz, x);\n\t} else {\n\t\tapplog(LOG_DEBUG, \"%p %02x tms=%d tdi=%d tdo=?ignore\", jp, (unsigned)buf[2], (int)tms, (int)tdi);\n#endif\n\t}\n\treturn true;\n}\n\nstatic bool jtag_rw_bit(struct jtag_port *jp, void *buf, uint8_t mask, bool tms, bool do_read)\n{\n\tuint8_t *byte = buf;\n\tbool tdo;\n\tif (!jtag_clock(jp, tms, byte[0] & mask, do_read ? &tdo : NULL))\n\t\treturn false;\n\tif (do_read) {\n\t\tif (tdo)\n\t\t\tbyte[0] |= mask;\n\t\telse\n\t\t\tbyte[0] &= ~mask;\n\t}\n\treturn true;\n}\n\nstatic inline\nbool getbit(void *data, uint32_t bitnum)\n{\n\tunsigned char *cdata = data;\n\tdiv_t d = div(bitnum, 8);\n\tunsigned char b = cdata[d.quot];\n\treturn b & (1<<(7 - d.rem));\n}\n\nstatic inline\nvoid setbit(void *data, uint32_t bitnum, bool nv)\n{\n\tunsigned char *cdata = data;\n\tdiv_t d = div(bitnum, 8);\n\tunsigned char *p = &cdata[d.quot];\n\tunsigned char o = (1<<(7 - d.rem));\n\tif (nv)\n\t\t*p |= o;\n\telse\n\t\t*p &= ~o;\n}\n\n// Expects to start at the Capture step, to handle 0-length gracefully\nbool _jtag_llrw(struct jtag_port *jp, void *buf, size_t bitlength, bool do_read, int stage)\n{\n\tuint8_t *data = buf;\n\t\n\tif (!bitlength)\n\t\treturn jtag_clock(jp, true, false, NULL);\n\n\tif (stage & 1)\n\t\tif (!jtag_clock(jp, false, false, NULL))\n\t\t\treturn false;\n\n#ifndef DEBUG_JTAG_CLOCK\n\t// This alternate implementation is designed to minimize ft232r reads (which are slow)\n\tif (do_read) {\n\t\tunsigned char rbuf[FTDI_READ_BUFFER_SIZE];\n\t\tunsigned char wbuf[3];\n\t\tssize_t rbufsz, bitspending = 0;\n\t\tsize_t databitoff = 0, i;\n\n\t\t--bitlength;\n\t\tfor (i = 0; i < bitlength; ++i) {\n\t\t\twbuf[0] = jtag_clock_byte(jp, false, getbit(data, i));\n\t\t\twbuf[1] = wbuf[0] | jp->tck;\n\t\t\tif (ft232r_write_all(jp->a->ftdi, wbuf, 2) != 2)\n\t\t\t\treturn false;\n\t\t\tjp->a->bufread += 2;\n\t\t\t++bitspending;\n\t\t\tif (jp->a->bufread > FTDI_READ_BUFFER_SIZE - 2) {\n\t\t\t\t// The next bit would overflow, so read now\n\t\t\t\trbufsz = jp->a->bufread;\n\t\t\t\tif (ft232r_read_all(jp->a->ftdi, rbuf, rbufsz) != rbufsz)\n\t\t\t\t\treturn false;\n\t\t\t\tfor (ssize_t j = rbufsz - ((bitspending - 1) * 2); j < rbufsz; j += 2)\n\t\t\t\t\tsetbit(data, databitoff++, (rbuf[j] & jp->tdo));\n\t\t\t\tbitspending = 1;\n\t\t\t\tjp->a->bufread = 0;\n\t\t\t}\n\t\t}\n\t\t// Last bit needs special treatment\n\t\twbuf[0] = jtag_clock_byte(jp, (stage & 2), getbit(data, i));\n\t\twbuf[2] = wbuf[1] = wbuf[0] | jp->tck;\n\t\tif (ft232r_write_all(jp->a->ftdi, wbuf, sizeof(wbuf)) != sizeof(wbuf))\n\t\t\treturn false;\n\t\trbufsz = jp->a->bufread + 3;\n\t\tif (ft232r_read_all(jp->a->ftdi, rbuf, rbufsz) != rbufsz)\n\t\t\treturn false;\n\t\t--rbufsz;\n\t\tfor (ssize_t j = rbufsz - (bitspending * 2); j < rbufsz; j += 2)\n\t\t\tsetbit(data, databitoff++, (rbuf[j] & jp->tdo));\n\t\tsetbit(data, databitoff++, (rbuf[rbufsz] & jp->tdo));\n\t\tjp->a->bufread = 0;\n\t\t\n\t\tif (stage & 2) {\n\t\t\tif (!jtag_clock(jp, true, false, NULL))  // Update\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n#endif\n\n\tint i, j;\n\tdiv_t d;\n\n\td = div(bitlength - 1, 8);\n\n\tfor (i = 0; i < d.quot; ++i) {\n\t\tfor (j = 0x80; j; j /= 2) {\n\t\t\tif (!jtag_rw_bit(jp, &data[i], j, false, do_read))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tfor (j = 0; j < d.rem; ++j)\n\t\tif (!jtag_rw_bit(jp, &data[i], 0x80 >> j, false, do_read))\n\t\t\treturn false;\n\tif (stage & 2) {\n\t\tif (!jtag_rw_bit(jp, &data[i], 0x80 >> j, true, do_read))\n\t\t\treturn false;\n\t\tif (!jtag_clock(jp, true, false, NULL))  // Update\n\t\t\treturn false;\n\t}\n\telse\n\t\tif (!jtag_rw_bit(jp, &data[i], 0x80 >> j, false, do_read))\n\t\t\treturn false;\n\treturn true;\n}\n\nbool jtag_reset(struct jtag_port *jp)\n{\n\tfor (int i = 0; i < 5; ++i)\n\t\tif (!jtag_clock(jp, true, false, NULL))\n\t\t\treturn false;\n\treturn jtag_clock(jp, false, false, NULL);\n}\n\n// Returns -1 for failure, -2 for unknown, or zero and higher for number of devices\nssize_t jtag_detect(struct jtag_port *jp)\n{\n\t// TODO: detect more than 1 device\n\tint i;\n\tbool tdo;\n\t\n\tif (!(1\n\t && jtag_write(jp, JTAG_REG_IR, \"\\xff\", 8)\n\t && jtag_clock(jp, true , false, NULL)  // Select DR\n\t && jtag_clock(jp, false, false, NULL)  // Capture DR\n\t && jtag_clock(jp, false, false, NULL)  // Shift DR\n\t))\n\t\treturn -1;\n\tfor (i = 0; i < 4; ++i)\n\t\tif (!jtag_clock(jp, false, false, NULL))\n\t\t\treturn -1;\n\tif (!jtag_clock(jp, false, false, &tdo))\n\t\treturn -1;\n\tif (tdo)\n\t\treturn -1;\n\tfor (i = 0; i < 4; ++i)\n\t{\n\t\tif (!jtag_clock(jp, false, true, &tdo))\n\t\t\treturn -1;\n\t\tif (tdo)\n\t\t\tbreak;\n\t}\n\tif (!jtag_reset(jp))\n\t\treturn -1;\n\treturn i < 2 ? i : -2;\n}\n\nbool _jtag_rw(struct jtag_port *jp, enum jtagreg r, void *buf, size_t bitlength, bool do_read, int stage)\n{\n\tif (!jtag_clock(jp, true, false, NULL))  // Select DR\n\t\treturn false;\n\tif (r == JTAG_REG_IR)\n\t\tif (!jtag_clock(jp, true, false, NULL))  // Select IR\n\t\t\treturn false;\n\tif (!jtag_clock(jp, false, false, NULL))  // Capture\n\t\treturn false;\n\treturn _jtag_llrw(jp, buf, bitlength, do_read, stage);  // Exit1\n}\n\nbool jtag_run(struct jtag_port *jp)\n{\n\treturn jtag_clock(jp, false, false, NULL);\n}\n"
        },
        {
          "name": "jtag.h",
          "type": "blob",
          "size": 1.765625,
          "content": "/*\n * Copyright 2012 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFGMINER_JTAG_H\n#define BFGMINER_JTAG_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n\nstruct jtag_port_a {\n\tstruct ft232r_device_handle *ftdi;\n\tuint8_t state;\n\tbool async;\n\tuint8_t bufread;\n};\n\nstruct jtag_port {\n\tstruct jtag_port_a *a;\n\tuint8_t tck;\n\tuint8_t tms;\n\tuint8_t tdi;\n\tuint8_t tdo;\n\tuint8_t ignored;\n};\n\nenum jtagreg {\n\tJTAG_REG_DR,\n\tJTAG_REG_IR,\n};\n\nextern bool jtag_clock(struct jtag_port *, bool tms, bool tdi, bool *tdo);\nextern bool _jtag_llrw(struct jtag_port *, void *buf, size_t bitlength, bool do_read, int stage);\nextern bool jtag_reset(struct jtag_port *);\nextern ssize_t jtag_detect(struct jtag_port *);\nextern bool _jtag_rw(struct jtag_port *, enum jtagreg r, void *buf, size_t bitlength, bool do_read, int stage);\n#define jtag_read(jp, r, data, bitlen)  _jtag_rw(jp, r, data, bitlen, true, 0xff)\n#define jtag_sread(jp, r, data, bitlen)  _jtag_rw(jp, r, data, bitlen, true, 1)\n#define jtag_sread_more(jp, data, bitlen, finish)  _jtag_llrw(jp, data, bitlen, true, (finish) ? 2 : 0)\n// Cast is used to accept const data - while it ignores the compiler attribute, it still won't modify the data\n#define jtag_write(jp, r, data, bitlen)  _jtag_rw(jp, r, (void*)data, bitlen, false, 0xff)\n#define jtag_swrite(jp, r, data, bitlen)  _jtag_rw(jp, r, (void*)data, bitlen, false, 1)\n#define jtag_swrite_more(jp, data, bitlen, finish)  _jtag_llrw(jp, (void*)data, bitlen, false, (finish) ? 2 : 0)\nextern bool jtag_run(struct jtag_port *);\n\n#endif\n"
        },
        {
          "name": "knc-asic",
          "type": "commit",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libbase58",
          "type": "commit",
          "content": null
        },
        {
          "name": "libbitfury.c",
          "type": "blob",
          "size": 12.6865234375,
          "content": "/*\n * Copyright 2013 bitfury\n * Copyright 2013 Anatoly Legkodymov\n * Copyright 2013-2014 Luke Dashjr\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"libbitfury.h\"\n#include \"lowl-spi.h\"\n#include \"sha2.h\"\n\n#include <time.h>\n\n#define BITFURY_REFRESH_DELAY 100\n#define BITFURY_DETECT_TRIES 3000 / BITFURY_REFRESH_DELAY\n\nuint32_t bitfury_decnonce(uint32_t);\n\n/* Configuration registers - control oscillators and such stuff. PROGRAMMED when magic number is matches, UNPROGRAMMED (default) otherwise */\nstatic\nvoid bitfury_config_reg(struct spi_port *port, int cfgreg, int ena)\n{\n\tstatic const uint8_t enaconf[4] = { 0xc1, 0x6a, 0x59, 0xe3 };\n\tstatic const uint8_t disconf[4] = { 0, 0, 0, 0 };\n\t\n\tif (ena) spi_emit_data(port, 0x7000+cfgreg*32, enaconf, 4);\n\telse     spi_emit_data(port, 0x7000+cfgreg*32, disconf, 4);\n}\n\n#define FIRST_BASE 61\n#define SECOND_BASE 4\nstatic\nconst int8_t bitfury_counters[16] = { 64, 64,\n\tSECOND_BASE, SECOND_BASE+4, SECOND_BASE+2, SECOND_BASE+2+16, SECOND_BASE, SECOND_BASE+1,\n\t(FIRST_BASE)%65,  (FIRST_BASE+1)%65,  (FIRST_BASE+3)%65, (FIRST_BASE+3+16)%65, (FIRST_BASE+4)%65, (FIRST_BASE+4+4)%65, (FIRST_BASE+3+3)%65, (FIRST_BASE+3+1+3)%65};\n\n/* Oscillator setup variants (maybe more), values inside of chip ANDed to not allow by programming errors work it at higher speeds  */\n/* WARNING! no chip temperature control limits, etc. It may self-fry and make fried chips with great ease :-) So if trying to overclock */\n/* Do not place chip near flammable objects, provide adequate power protection and better wear eye protection ! */\n/* Thermal runaway in this case could produce nice flames of chippy fries */\n\n// Thermometer code from left to right - more ones ==> faster clock!\n\n#define rotrFixed(x,y) (((x) >> (y)) | ((x) << (32-(y))))\n#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))\n#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))\n#define Ch(x,y,z) (z^(x&(y^z)))\n#define Maj(x,y,z) (y^((x^y)&(y^z)))\n#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))\n#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))\n\n/* SHA256 CONSTANTS */\nstatic const uint32_t SHA_K[64] = {\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\n\nstatic\nvoid libbitfury_ms3_compute(uint32_t *p)\n{\n\tuint32_t cp[8];\n\tuint32_t a,b,c,d,e,f,g,h, ne, na,  i;\n\n\tswap32tole(cp, p, 8);\n\ta = cp[0]; b = cp[1]; c = cp[2]; d = cp[3]; e = cp[4]; f = cp[5]; g = cp[6]; h = cp[7];\n\n\tfor (i = 0; i < 3; i++) {\n\t\tconst uint32_t x = le32toh(p[i+16]);\n\t\tne = x + SHA_K[i] + h + Ch(e,f,g) + S1(e) + d;\n\t\tna = x + SHA_K[i] + h + Ch(e,f,g) + S1(e) + S0(a) + Maj(a,b,c);\n\t\td = c; c = b; b = a; a = na;\n\t\th = g; g = f; f = e; e = ne;\n\t}\n\n\tp[15] = a; p[14] = b; p[13] = c; p[12] = d; p[11] = e; p[10] = f; p[9] = g; p[8] = h;\n\tswap32tole(&p[8], &p[8], 8);\n}\n\nstatic\nvoid bitfury_send_conf(struct spi_port *port) {\n\tint i;\n\tfor (i = 7; i <= 11; ++i)\n\t\tbitfury_config_reg(port, i, 0);\n\tbitfury_config_reg(port, 6, 0); /* disable OUTSLK */\n\tbitfury_config_reg(port, 4, 1); /* Enable slow oscillator */\n\tfor (i = 1; i <= 3; ++i)\n\t\tbitfury_config_reg(port, i, 0);\n\tspi_emit_data(port, 0x0100, bitfury_counters, 16); /* Program counters correctly for rounds processing, here baby should start consuming power */\n}\n\nstatic\nvoid bitfury_send_init(struct spi_port *port) {\n\t/* Prepare internal buffers */\n\t/* PREPARE BUFFERS (INITIAL PROGRAMMING) */\n\t{\n\t\tuint32_t w[] = {\n\t\t\t0,0,0,0xffffffff,\n\t\t\t0x80000000,0,0,0,\n\t\t\t0,0,0,0,\n\t\t\t0,0,0,0x00000280,\n\t\t};\n\t\tswap32tole(w, w, sizeof(w)/4);\n\t\tspi_emit_data(port, 0x1000, w, 16*4);\n\t\tspi_emit_data(port, 0x1400, w,  8*4);\n\t}\n\t{\n\t\tuint32_t w[] = {\n\t\t\t0x80000000,0,0,0,\n\t\t\t0,0,0,0x100,\n\t\t};\n\t\tswap32tole(w, w, sizeof(w)/4);\n\t\tspi_emit_data(port, 0x1900, &w[0],8*4); /* Prepare MS and W buffers! */\n\t\tuint32_t atrvec[] = {\n\t\t\t0xb0e72d8e, 0x1dc5b862, 0xe9e7c4a6, 0x3050f1f5, 0x8a1a6b7e, 0x7ec384e8, 0x42c1c3fc, 0x8ed158a1, /* MIDSTATE */\n\t\t\t0,0,0,0,0,0,0,0,\n\t\t\t0x8a0bb7b7, 0x33af304f, 0x0b290c1a, 0xf0c4e61f, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t\t};\n\t\tlibbitfury_ms3_compute(&atrvec[0]);\n\t\tswap32tole(atrvec, atrvec, sizeof(atrvec)/4);\n\t\tspi_emit_data(port, 0x3000, &atrvec[0], 19*4);\n\t}\n}\n\nstatic\nvoid bitfury_set_freq(struct spi_port *port, int bits) {\n\tuint64_t freq;\n\tconst uint8_t *\n\tosc6 = (unsigned char *)&freq;\n\tfreq = (1ULL << bits) - 1ULL;\n\tfreq = htole64(freq);\n\n\tspi_emit_data(port, 0x6000, osc6, 8); /* Program internal on-die slow oscillator frequency */\n\tbitfury_config_reg(port, 4, 1); /* Enable slow oscillator */\n}\n\nvoid bitfury_send_reinit(struct spi_port *port, int slot, int chip_n, int n) {\n\tspi_clear_buf(port);\n\tspi_emit_break(port);\n\tspi_emit_fasync(port, chip_n);\n\tbitfury_set_freq(port, n);\n\tbitfury_send_conf(port);\n\tbitfury_send_init(port);\n\tspi_txrx(port);\n}\n\nvoid bitfury_send_shutdown(struct spi_port *port, int slot, int chip_n) {\n\tspi_clear_buf(port);\n\tspi_emit_break(port);\n\tspi_emit_fasync(port, chip_n);\n\tbitfury_config_reg(port, 4, 0); /* Disable slow oscillator */\n\tspi_txrx(port);\n}\n\nvoid bitfury_send_freq(struct spi_port *port, int slot, int chip_n, int bits) {\n\tspi_clear_buf(port);\n\tspi_emit_break(port);\n\tspi_emit_fasync(port, chip_n);\n\tbitfury_set_freq(port, bits);\n\tspi_txrx(port);\n}\n\nstatic\nuint32_t libbitfury_c_diff(uint32_t ocounter, uint32_t counter) {\n\treturn counter >  ocounter ? counter - ocounter : (0x003FFFFF - ocounter) + counter;\n}\n\nstatic\nuint32_t libbitfury_get_counter(uint32_t *newbuf, uint32_t *oldbuf) {\n\tint j;\n\tfor(j = 0; j < 16; j++) {\n\t\tif (newbuf[j] != oldbuf[j]) {\n\t\t\tuint32_t counter = bitfury_decnonce(newbuf[j]);\n\t\t\tif ((counter & 0xFFC00000) == 0xdf800000) {\n\t\t\t\tcounter -= 0xdf800000;\n\t\t\t\treturn counter;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic\nint libbitfury_detect_chip(struct spi_port *port, int chip_n) {\n\t/* Test vectors to calculate (using address-translated loads) */\n\tuint32_t atrvec[] = {\n\t\t0xb0e72d8e, 0x1dc5b862, 0xe9e7c4a6, 0x3050f1f5, 0x8a1a6b7e, 0x7ec384e8, 0x42c1c3fc, 0x8ed158a1, /* MIDSTATE */\n\t\t0,0,0,0,0,0,0,0,\n\t\t0x8a0bb7b7, 0x33af304f, 0x0b290c1a, 0xf0c4e61f, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t\t\n\t\t0x9c4dfdc0, 0xf055c9e1, 0xe60f079d, 0xeeada6da, 0xd459883d, 0xd8049a9d, 0xd49f9a96, 0x15972fed, /* MIDSTATE */\n\t\t0,0,0,0,0,0,0,0,\n\t\t0x048b2528, 0x7acb2d4f, 0x0b290c1a, 0xbe00084a, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t\t\n\t\t0x0317b3ea, 0x1d227d06, 0x3cca281e, 0xa6d0b9da, 0x1a359fe2, 0xa7287e27, 0x8b79c296, 0xc4d88274, /* MIDSTATE */\n\t\t0,0,0,0,0,0,0,0,\n\t\t0x328bcd4f, 0x75462d4f, 0x0b290c1a, 0x002c6dbc, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t\t\n\t\t0xac4e38b6, 0xba0e3b3b, 0x649ad6f8, 0xf72e4c02, 0x93be06fb, 0x366d1126, 0xf4aae554, 0x4ff19c5b, /* MIDSTATE */\n\t\t0,0,0,0,0,0,0,0,\n\t\t0x72698140, 0x3bd62b4f, 0x3fd40c1a, 0x801e43e9, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t\t\n\t\t0x9dbf91c9, 0x12e5066c, 0xf4184b87, 0x8060bc4d, 0x18f9c115, 0xf589d551, 0x0f7f18ae, 0x885aca59, /* MIDSTATE */\n\t\t0,0,0,0,0,0,0,0,\n\t\t0x6f3806c3, 0x41f82a4f, 0x3fd40c1a, 0x00334b39, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */\n\t};\n\tint i;\n\tuint32_t newbuf[17] = {0}, oldbuf[17] = {0};\n\tuint32_t ocounter;\n\tlong long odiff = 0;\n\n\tmemset(newbuf, 0, 17 * 4);\n\tmemset(oldbuf, 0, 17 * 4);\n\n\tlibbitfury_ms3_compute(&atrvec[0]);\n\tlibbitfury_ms3_compute(&atrvec[20]);\n\tlibbitfury_ms3_compute(&atrvec[40]);\n\t\n\tswap32tole(atrvec, atrvec, sizeof(atrvec)/4);\n\n\n\tspi_clear_buf(port);\n\tspi_emit_break(port); /* First we want to break chain! Otherwise we'll get all of traffic bounced to output */\n\tspi_emit_fasync(port, chip_n);\n\tbitfury_set_freq(port, 30);\n\tbitfury_send_conf(port);\n\tbitfury_send_init(port);\n\tspi_txrx(port);\n\n\tocounter = 0;\n\tfor (i = 0; i < BITFURY_DETECT_TRIES; i++) {\n\t\tint counter;\n\n\t\tspi_clear_buf(port);\n\t\tspi_emit_break(port);\n\t\tspi_emit_fasync(port, chip_n);\n\t\tspi_emit_data(port, 0x3000, &atrvec[0], 19*4);\n\t\tspi_txrx(port);\n\t\tswap32tole(newbuf, spi_getrxbuf(port) + 4 + chip_n, 17);\n\n\t\tcounter = libbitfury_get_counter(newbuf, oldbuf);\n\t\tif (ocounter) {\n\t\t\tlong long cdiff = libbitfury_c_diff(ocounter, counter);\n\n\t\t\tif (llabs(odiff - cdiff) < 5000)\n\t\t\t\treturn 1;\n\t\t\todiff = cdiff;\n\t\t}\n\t\tocounter = counter;\n\t\tif (newbuf[16] != 0 && newbuf[16] != 0xFFFFFFFF) {\n\t\t\treturn 0;\n\t\t}\n\t\tcgsleep_ms(BITFURY_REFRESH_DELAY / 10);\n\t\tmemcpy(oldbuf, newbuf, 17 * 4);\n\t}\n\treturn 0;\n}\n\nint libbitfury_detectChips1(struct spi_port *port) {\n\tint n;\n\tfor (n = 0; libbitfury_detect_chip(port, n); ++n)\n\t{}\n\treturn n;\n}\n\n// in  = 1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10  f  e  d  c  b  a  9  8  7  6  5  4  3  2  1  0\nuint32_t bitfury_decnonce(uint32_t in)\n{\n\tuint32_t out;\n\n\t/* First part load */\n\tout = (in & 0xFF) << 24; in >>= 8;\n\n\t/* Byte reversal */\n\tin = (((in & 0xaaaaaaaa) >> 1) | ((in & 0x55555555) << 1));\n\tin = (((in & 0xcccccccc) >> 2) | ((in & 0x33333333) << 2));\n\tin = (((in & 0xf0f0f0f0) >> 4) | ((in & 0x0f0f0f0f) << 4));\n\n\tout |= (in >> 2)&0x3FFFFF;\n\n\t/* Extraction */\n\tif (in & 1) out |= (1 << 23);\n\tif (in & 2) out |= (1 << 22);\n// out =  7  6  5  4  3  2  1  0  f  e 18 19 1a 1b 1c 1d 1e 1f 10 11 12 13 14 15 16 17  8  9  a  b  c  d\n\n\tout -= 0x800004;\n\treturn out;\n}\n\nstatic\nint libbitfury_rehash(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t nnonce) {\n\tuint8_t in[16];\n\tuint32_t *in32 = (uint32_t *)in;\n\tconst uint32_t *mid32 = midstate;\n\tuint32_t out32[8];\n\tuint8_t *out = (uint8_t *) out32;\n#ifdef BITFURY_REHASH_DEBUG\n\tstatic uint32_t history[512];\n\tstatic uint32_t history_p;\n#endif\n\tsha256_ctx ctx;\n\n\n\tmemset( &ctx, 0, sizeof( sha256_ctx ) );\n\tmemcpy(ctx.h, mid32, 8*4);\n\tctx.tot_len = 64;\n\tctx.len = 0;\n\n\tin32[0] = bswap_32(m7);\n\tin32[1] = bswap_32(ntime);\n\tin32[2] = bswap_32(nbits);\n\tin32[3] = bswap_32(nnonce);\n\n\tsha256_update(&ctx, in, 16);\n\tsha256_final(&ctx, out);\n\tsha256(out, 32, out);\n\n\tif (out32[7] == 0) {\n#ifdef BITFURY_REHASH_DEBUG\n\t\tchar hex[65];\n\t\tbin2hex(hex, out, 32);\n\t\tapplog(LOG_INFO, \"! MS0: %08x, m7: %08x, ntime: %08x, nbits: %08x, nnonce: %08x\", mid32[0], m7, ntime, nbits, nnonce);\n\t\tapplog(LOG_INFO, \" out: %s\", hex);\n\t\thistory[history_p] = nnonce;\n\t\thistory_p++; history_p &= 512 - 1;\n#endif\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nbool bitfury_fudge_nonce(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t *nonce_p) {\n\tstatic const uint32_t offsets[] = {0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000, 0x00400000};\n\tuint32_t nonce;\n\tint i;\n\t\n\tfor (i = 0; i < 6; ++i)\n\t{\n\t\tnonce = *nonce_p + offsets[i];\n\t\tif (libbitfury_rehash(midstate, m7, ntime, nbits, nonce))\n\t\t{\n\t\t\t*nonce_p = nonce;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid work_to_bitfury_payload(struct bitfury_payload *p, struct work *w) {\n\tmemset(p, 0, sizeof(struct bitfury_payload));\n\n\tmemcpy(p->midstate, w->midstate, 32);\n\tp->m7 = *(uint32_t *)&w->data[0x40];\n\tp->ntime = *(uint32_t *)&w->data[0x44];\n\tp->nbits = *(uint32_t *)&w->data[0x48];\n}\n\nvoid bitfury_payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *p)\n{\n\t/* Programming next value */\n\tmemcpy(atrvec, p, 20*4);\n\tlibbitfury_ms3_compute(atrvec);\n}\n"
        },
        {
          "name": "libbitfury.h",
          "type": "blob",
          "size": 1.595703125,
          "content": "#ifndef BFG_LIBBITFURY_H\n#define BFG_LIBBITFURY_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n\nstruct work;\n\n#define BITFURY_STAT_N 1024\n\nstruct bitfury_payload {\n\tuint8_t midstate[32];\n\tuint32_t junk[8];\n\tuint32_t m7;\n\tuint32_t ntime;\n\tuint32_t nbits;\n\tuint32_t nnonce;\n};\n\nstruct freq_stat {\n\tdouble *mh;\n\tdouble *s;\n\tint osc6_min;\n\tint osc6_max;\n\tdouble omh;\n\tdouble os;\n\tint best_osc;\n\tint best_done;\n};\n\nstruct bitfury_device {\n\tstruct spi_port *spi;\n\tuint8_t osc6_bits;\n\tuint32_t newbuf[17];\n\tuint32_t oldbuf[17];\n\tbool oldjob;\n\tint active;\n\tint chipgen;\n\tint chipgen_probe;\n\tuint32_t atrvec[20];\n\tstruct bitfury_payload payload;\n\tstruct freq_stat chip_stat;\n\tstruct timeval timer1;\n\tstruct timeval tv_stat;\n\tuint32_t counter1, counter2;\n\tdouble mhz;\n\tint mhz_last;\n\tint mhz_best;\n\tuint32_t slot;\n\tunsigned fasync;\n\tunsigned strange_counter;\n\tbool force_reinit;\n\tint desync_counter;\n\tint sample_hwe;\n\tint sample_tot;\n};\n\nextern void work_to_bitfury_payload(struct bitfury_payload *, struct work *);\nextern void bitfury_payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *);\nextern void bitfury_send_reinit(struct spi_port *, int slot, int chip_n, int n);\nextern void bitfury_send_shutdown(struct spi_port *, int slot, int chip_n);\nextern void bitfury_send_freq(struct spi_port *, int slot, int chip_n, int bits);\nextern int libbitfury_detectChips1(struct spi_port *);\nextern uint32_t bitfury_decnonce(uint32_t);\nextern bool bitfury_fudge_nonce(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t *nonce_p);\n\n#endif /* __LIBBITFURY_H__ */\n"
        },
        {
          "name": "libblkmaker",
          "type": "commit",
          "content": null
        },
        {
          "name": "libztex.c",
          "type": "blob",
          "size": 23.4951171875,
          "content": "/*\n * Copyright 2012 nelisky\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2012-2013 Denis Ahrens~\n * Copyright 2012 Peter Stuge~\n *\n * This work is based upon the Java SDK provided by ztex which is\n * Copyright (C) 2009-2011 ZTEX GmbH.\n * http://www.ztex.de\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n *\n * The copyright status of some of this code is currently a bit confused. They\n * were initially released under a license (GPLv2 only) incompatible with the\n * rest of the program at the time (GPLv3 or newer), and I haven't had luck\n * getting in touch with some later contributors (denoted above with a tilde) to\n * clarify it. Since their modifications would have been a license violation,\n * I'm assuming it was just an innocent mistake on their part.\n */\n\n#define _GNU_SOURCE\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"binloader.h\"\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"dynclock.h\"\n#include \"miner.h\"\n#include \"libztex.h\"\n#include \"util.h\"\n\n//* Capability index for EEPROM support.\n#define CAPABILITY_EEPROM 0,0\n//* Capability index for FPGA configuration support. \n#define CAPABILITY_FPGA 0,1\n//* Capability index for FLASH memory support.\n#define CAPABILITY_FLASH 0,2\n//* Capability index for DEBUG helper support.\n#define CAPABILITY_DEBUG 0,3\n//* Capability index for AVR XMEGA support.\n#define CAPABILITY_XMEGA 0,4\n//* Capability index for AVR XMEGA support.\n#define CAPABILITY_HS_FPGA 0,5\n//* Capability index for AVR XMEGA support.\n#define CAPABILITY_MAC_EEPROM 0,6\n//* Capability index for multi FPGA support.\n#define CAPABILITY_MULTI_FPGA 0,7\n\nstatic int libztex_get_string_descriptor_ascii(libusb_device_handle *dev, uint8_t desc_index,\n\t\tunsigned char *data, int length)\n{\n\tint i, cnt;\n\tuint16_t langid;\n\tunsigned char buf[260];\n\n\t/* We open code string descriptor retrieval and ASCII decoding here\n\t * in order to work around that libusb_get_string_descriptor_ascii()\n\t * in the FreeBSD libusb implementation hits a bug in ZTEX firmware,\n\t * where the device returns more bytes than requested, causing babble,\n\t * which makes FreeBSD return an error to us.\n\t *\n\t * Avoid the mess by doing it manually the same way as libusb-1.0.\n\t */\n\n\tcnt = libusb_control_transfer(dev, LIBUSB_ENDPOINT_IN,\n\t    LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING << 8) | 0,\n\t    0x0000, buf, sizeof(buf), 1000);\n\tif (cnt < 0) {\n\t\tapplog(LOG_ERR, \"%s: Failed to read LANGIDs: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\t\treturn cnt;\n\t}\n\n\tlangid = libusb_le16_to_cpu(((uint16_t *)buf)[1]);\n\n\tcnt = libusb_control_transfer(dev, LIBUSB_ENDPOINT_IN,\n\t    LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING << 8) | desc_index,\n\t    langid, buf, sizeof(buf), 1000);\n\tif (cnt < 0) {\n\t\tapplog(LOG_ERR, \"%s: Failed to read string descriptor: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\t\treturn cnt;\n\t}\n\n\t/* num chars = (all bytes except bLength and bDescriptorType) / 2 */\n\tfor (i = 0; i <= (cnt - 2) / 2 && i < length-1; i++)\n\t\tdata[i] = buf[2 + i*2];\n\n\tdata[i] = 0;\n\n\treturn LIBUSB_SUCCESS;\n}\n\nstatic bool libztex_firmwareReset(struct libusb_device_handle *hndl, bool enable)\n{\n\tuint8_t reset = enable ? 1 : 0;\n\tint cnt = libusb_control_transfer(hndl, 0x40, 0xA0, 0xE600, 0, &reset, 1, 1000);\n\tif (cnt < 0)\n\t{\n\t\tapplog(LOG_ERR, \"Ztex reset %d failed: %s\", enable, bfg_strerror(cnt, BST_LIBUSB));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nenum ztex_check_result libztex_checkDevice(struct libusb_device *dev)\n{\n\tlibusb_device_handle *hndl = NULL;\n\tstruct libusb_device_descriptor desc;\n\tint ret = CHECK_ERROR, err, cnt;\n\tunsigned char buf[64];\n\tunsigned int i;\n\tbytes_t bsdata = BYTES_INIT;\n\n\terr = libusb_get_device_descriptor(dev, &desc);\n\tif (unlikely(err != 0)) {\n\t\tapplog(LOG_ERR, \"Ztex check device: Failed to open read descriptor with error %d\", err);\n\t\treturn CHECK_ERROR;\n\t}\n\n\tif (desc.idVendor != LIBZTEX_IDVENDOR || desc.idProduct != LIBZTEX_IDPRODUCT) {\n\t\tapplog(LOG_DEBUG, \"Not a ZTEX device %04x:%04x\", desc.idVendor, desc.idProduct);\n\t\treturn CHECK_IS_NOT_ZTEX;\n\t}\n\n\terr = libusb_open(dev, &hndl);\n\tif (err != LIBUSB_SUCCESS) {\n\t\tapplog(LOG_ERR, \"%s: Can not open ZTEX device: %s\", __func__, bfg_strerror(err, BST_LIBUSB));\n\t\tgoto done;\n\t}\n\n\tif (libusb_claim_interface(hndl, 0) == LIBUSB_ERROR_BUSY)\n\t{\n\t\tapplog(LOG_DEBUG, \"Ztex check device: Interface already busy, skipping\");\n\t\tgoto done;\n\t}\n\t\n\tcnt = libusb_control_transfer(hndl, 0xc0, 0x22, 0, 0, buf, 40, 500);\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"Ztex check device: Failed to read ztex descriptor with err %d\", cnt);\n\t\tgoto done;\n\t}\n\n\tif (buf[0] != 40 || buf[1] != 1 || buf[2] != 'Z' || buf[3] != 'T' || buf[4] != 'E' || buf[5] != 'X') {\n\t\tapplog(LOG_ERR, \"Ztex check device: Error reading ztex descriptor\");\n\t\tgoto done;\n\t}\n\n\tif (buf[6] != 10)\n\t{\n\t\tret = CHECK_IS_NOT_ZTEX;\n\t\tgoto done;\n\t}\n\n\t// 15 = 1.15y   13 = 1.15d or 1.15x\n\tswitch(buf[7])\n\t{\n\t\tcase 13:\n\t\t\tapplog(LOG_ERR, \"Found ztex board 1.15d or 1.15x\");\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tapplog(LOG_ERR, \"Found ztex board 1.15y\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tapplog(LOG_ERR, \"Found unknown ztex board\");\n\t\t\tret = CHECK_IS_NOT_ZTEX;\n\t\t\tgoto done;\n\t}\n\n\t// testing for dummy firmware\n\tif (buf[8] != 0) {\n\t\tret = CHECK_OK;\n\t\tgoto done;\n\t}\n\n\tapplog(LOG_ERR, \"Found dummy firmware, trying to send mining firmware\");\n\n\tchar productString[32];\n\n\tcnt = libztex_get_string_descriptor_ascii(hndl, desc.iProduct, (unsigned char*)productString, sizeof(productString));\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"Ztex check device: Failed to read device productString with err %d\", cnt);\n\t\treturn cnt;\n\t}\n\n\tapplog(LOG_ERR, \"productString: %s\", productString);\n\n\tunsigned char productID2 = buf[7];\n\tchar *firmware = NULL;\n\n\tif (strcmp(\"USB-FPGA Module 1.15d (default)\", productString) == 0 && productID2 == 13)\n\t{\n\t\tfirmware = \"ztex_ufm1_15d4\";\n\t}\n\telse if (strcmp(\"USB-FPGA Module 1.15x (default)\", productString) == 0 && productID2 == 13)\n\t{\n\t\tfirmware = \"ztex_ufm1_15d4\";\n\t}\n\telse if (strcmp(\"USB-FPGA Module 1.15y (default)\", productString) == 0 && productID2 == 15)\n\t{\n\t\tfirmware = \"ztex_ufm1_15y1\";\n\t}\n\n\tif (firmware == NULL)\n\t{\n\t\tapplog(LOG_ERR, \"could not figure out which firmware to use\");\n\t\tgoto done;\n\t}\n\n\tapplog(LOG_ERR, \"Mining firmware filename: %s\", firmware);\n\n\tbytes_init(&bsdata);\n\tif (!load_bitstream_bytes(&bsdata, \"ztex\", \"ZTX *\", firmware))\n\t\tgoto done;\n\n\t// in buf[] is still the identifier of the dummy firmware\n\t// use it to compare it with the new firmware\n\tchar *rv = memmem(bytes_buf(&bsdata), bytes_len(&bsdata), buf, 8);\n\tif (rv == NULL)\n\t{\n\t\tapplog(LOG_ERR, \"%s: found firmware is not ZTEX\", __func__);\n\t\tgoto done;\n\t}\n\n\t// check for dummy firmware\n\tif (rv[8] == 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: found a ZTEX dummy firmware\", __func__);\n\t\tgoto done;\n\t}\n\n\tif (libztex_firmwareReset(hndl, true))\n\t\tgoto done;\n\n\tfor (i = 0; i < bytes_len(&bsdata); i+= 256) {\n\t\t// firmware wants data in small chunks like 256 bytes\n\t\tint numbytes = (bytes_len(&bsdata) - i) < 256 ? (bytes_len(&bsdata) - i) : 256;\n\t\tint k = libusb_control_transfer(hndl, 0x40, 0xA0, i, 0, bytes_buf(&bsdata) + i, numbytes, 1000);\n\t\tif (k < numbytes)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Ztex device: Failed to write firmware at %d with: %s\", i, bfg_strerror(k, BST_LIBUSB));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (libztex_firmwareReset(hndl, false))\n\t\tgoto done;\n\n\tapplog(LOG_ERR, \"Ztex device: succesfully wrote firmware\");\n\tret = CHECK_RESCAN;\n\ndone:\n\tbytes_free(&bsdata);\n\tif (hndl)\n\t{\n\t\tlibusb_release_interface(hndl, 0);\n\t\tlibusb_close(hndl);\n\t}\n\treturn ret;\n}\n\nstatic bool libztex_checkCapability(struct libztex_device *ztex, int i, int j)\n{\n\tif (!((i >= 0) && (i <= 5) && (j >= 0) && (j < 8) &&\n\t     (((ztex->interfaceCapabilities[i] & 255) & (1 << j)) != 0))) {\n\t\tapplog(LOG_ERR, \"%s: capability missing: %d %d\", ztex->repr, i, j);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic char libztex_detectBitstreamBitOrder(const unsigned char *buf, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size - 4; i++) {\n\t\tif (((buf[i] & 255) == 0xaa) && ((buf[i + 1] & 255) == 0x99) && ((buf[i + 2] & 255) == 0x55) && ((buf[i + 3] & 255) == 0x66))\n\t\t\treturn 1;\n\t\tif (((buf[i] & 255) == 0x55) && ((buf[i + 1] & 255) == 0x99) && ((buf[i + 2] & 255) == 0xaa) && ((buf[i + 3] & 255) == 0x66))\n\t\t\treturn 0;\n\t} \n\tapplog(LOG_WARNING, \"Unable to determine bitstream bit order: no signature found\");\n\treturn 0;\n}\n\nstatic void libztex_swapBits(unsigned char *buf, int size)\n{\n\tunsigned char c;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tc = buf[i];\n\t\tbuf[i] = ((c & 128) >> 7) |\n\t\t         ((c & 64) >> 5) |\n\t\t         ((c & 32) >> 3) |\n\t\t         ((c & 16) >> 1) |\n\t\t         ((c & 8) << 1) |\n\t\t         ((c & 4) << 3) |\n\t\t         ((c & 2) << 5) |\n\t\t         ((c & 1) << 7);\n\t}\n}\n\nstatic int libztex_getFpgaState(struct libztex_device *ztex, struct libztex_fpgastate *state)\n{\n\tunsigned char buf[9];\n\tint cnt;\n\n\tif (!libztex_checkCapability(ztex, CAPABILITY_FPGA))\n\t\treturn -1;\n\tcnt = libusb_control_transfer(ztex->hndl, 0xc0, 0x30, 0, 0, buf, 9, 1000);\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"%s: Failed getFpgaState with err %d\", ztex->repr, cnt);\n\t\treturn cnt;\n\t}\n\tstate->fpgaConfigured = (buf[0] == 0);\n\tstate->fpgaChecksum = buf[1] & 0xff;\n\tstate->fpgaBytes = ((buf[5] & 0xff) << 24) | ((buf[4] & 0xff) << 16) | ((buf[3] & 0xff) << 8) | (buf[2] & 0xff);\n\tstate->fpgaInitB = buf[6] & 0xff;\n\tstate->fpgaFlashResult = buf[7];\n\tstate->fpgaFlashBitSwap = (buf[8] != 0);\n\treturn 0;\n}\n\nstatic int libztex_configureFpgaHS(struct libztex_device *ztex, const char* firmware, bool force, char bs, const char *repr)\n{\n\tstruct libztex_fpgastate state;\n\tconst int transactionBytes = 65536;\n\tunsigned char buf[transactionBytes], settings[2];\n\tint tries, cnt, err;\n\tFILE *fp;\n\n\tif (!libztex_checkCapability(ztex, CAPABILITY_HS_FPGA))\n\t\treturn -1;\n\tlibztex_getFpgaState(ztex, &state);\n\tif (!force && state.fpgaConfigured) {\n\t\tapplog(LOG_INFO, \"Bitstream already configured\");\n\t\treturn 0;\n\t}\n\tcnt = libusb_control_transfer(ztex->hndl, 0xc0, 0x33, 0, 0, settings, 2, 1000);\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"%s: Failed getHSFpgaSettings with err %d\", ztex->repr, cnt);\n\t\treturn cnt;\n\t}\n\n\terr = libusb_claim_interface(ztex->hndl, settings[1]);\n\tif (err != LIBUSB_SUCCESS) {\n\t\tapplog(LOG_ERR, \"%s: failed to claim interface for hs transfer\", ztex->repr);\n\t\treturn -4;\n\t}\n\n\tfor (tries = 3; tries > 0; tries--) {\n\t\tfp = open_bitstream(\"ztex\", firmware);\n\t\tif (!fp) {\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": failed to read bitstream '%s'\", repr, firmware);\n\t\t\tlibusb_release_interface(ztex->hndl, settings[1]);\n\t\t\treturn -2;\n\t\t}\n\n\t\tlibusb_control_transfer(ztex->hndl, 0x40, 0x34, 0, 0, NULL, 0, 1000);\n\t\t// 0x34 - initHSFPGAConfiguration\n\n\t\tdo\n\t\t{\n\t\t\tint length = fread(buf,1,transactionBytes,fp);\n\n\t\t\tif (bs != 0 && bs != 1)\n\t\t\t\tbs = libztex_detectBitstreamBitOrder(buf, length);\n\t\t\tif (bs == 1)\n\t\t\t\tlibztex_swapBits(buf, length);\n\n\t\t\terr = libusb_bulk_transfer(ztex->hndl, settings[0], buf, length, &cnt, 1000);\n\t\t\tif (cnt != length)\n\t\t\t\tapplog(LOG_ERR, \"%s: cnt != length\", ztex->repr);\n\t\t\tif (err != 0)\n\t\t\t\tapplog(LOG_ERR, \"%s: Failed send hs fpga data\", ztex->repr);\n\t\t}\n\t\twhile (!feof(fp));\n\n\t\t// While 1.15y can finish immediately, at least 1.15x needs some delay\n\t\t// (200ms might be enough, but 500ms is safer)\n\t\tif (ztex->productId[1] != 15)\n\t\t\tusleep(500);\n\n\t\tlibusb_control_transfer(ztex->hndl, 0x40, 0x35, 0, 0, NULL, 0, 1000);\n\t\t// 0x35 - finishHSFPGAConfiguration\n\t\tif (cnt >= 0)\n\t\t\ttries = 0;\n\n\t\tfclose(fp);\n\n\t\tlibztex_getFpgaState(ztex, &state);\n\t\tif (!state.fpgaConfigured) {\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": HS FPGA configuration failed: DONE pin does not go high\", repr);\n\t\t\tlibusb_release_interface(ztex->hndl, settings[1]);\n\t\t\treturn -3;\n\t\t}\n\t}\n\n\tlibusb_release_interface(ztex->hndl, settings[1]);\n\n\tcgsleep_ms(200);\n\tapplog(LOG_INFO, \"%\"PRIpreprv\": HS FPGA configuration done\", repr);\n\treturn 0;\n}\n\nstatic int libztex_configureFpgaLS(struct libztex_device *ztex, const char* firmware, bool force, char bs, const char *repr)\n{\n\tstruct libztex_fpgastate state;\n\tconst int transactionBytes = 2048;\n\tunsigned char buf[transactionBytes];\n\tint tries, cnt;\n\tFILE *fp;\n\n\tif (!libztex_checkCapability(ztex, CAPABILITY_FPGA))\n\t\treturn -1;\n\n\tlibztex_getFpgaState(ztex, &state);\n\tif (!force && state.fpgaConfigured) {\n\t\tapplog(LOG_DEBUG, \"Bitstream already configured\");\n\t\treturn 0;\n\t}\n\n\tfor (tries = 10; tries > 0; tries--) {\n\t\tfp = open_bitstream(\"ztex\", firmware);\n\t\tif (!fp) {\n\t\t\t_bitstream_not_found(repr, firmware);\n\t\t\treturn -2;\n\t\t}\n\n\t\t//* Reset fpga\n\t\tcnt = libztex_resetFpga(ztex);\n\t\tif (unlikely(cnt < 0)) {\n\t\t\tapplog(LOG_ERR, \"%s: Failed reset fpga with err %d\", ztex->repr, cnt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo\n\t\t{\n\t\t\tint length = fread(buf, 1, transactionBytes, fp);\n\n\t\t\tif (bs != 0 && bs != 1)\n\t\t\t\tbs = libztex_detectBitstreamBitOrder(buf, length);\n\t\t\tif (bs == 1)\n\t\t\t\tlibztex_swapBits(buf, length);\n\t\t\tcnt = libusb_control_transfer(ztex->hndl, 0x40, 0x32, 0, 0, buf, length, 5000);\n\t\t\tif (cnt != length)\n\t\t\t{\n\t\t\t\tapplog(LOG_ERR, \"%s: Failed send ls fpga data\", ztex->repr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (!feof(fp));\n\n\t\tif (cnt > 0)\n\t\t\ttries = 0;\n\n\t\tfclose(fp);\n\t}\n\n\tlibztex_getFpgaState(ztex, &state);\n\tif (!state.fpgaConfigured) {\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": LS FPGA configuration failed: DONE pin does not go high\", repr);\n\t\treturn -3;\n\t}\n\n\tcgsleep_ms(200);\n\tapplog(LOG_INFO, \"%\"PRIpreprv\": FPGA configuration done\", repr);\n\treturn 0;\n}\n\nint libztex_configureFpga(struct libztex_device *ztex, const char *repr)\n{\n\tchar buf[256];\n\tint rv;\n\n\tstrcpy(buf, ztex->bitFileName);\n\tstrcat(buf, \".bit\");\n\trv = libztex_configureFpgaHS(ztex, buf, true, 2, repr);\n\tif (rv != 0)\n\t\trv = libztex_configureFpgaLS(ztex, buf, true, 2, repr);\n\tif (!rv)\n\t\tif (libusb_claim_interface(ztex->hndl, 0) == LIBUSB_ERROR_BUSY)\n\t\t\trv = -5;\n\treturn rv;\n}\n\nint libztex_numberOfFpgas(struct libztex_device *ztex)\n{\n\tint cnt;\n\tunsigned char buf[3];\n\n\tif (ztex->numberOfFpgas < 0) {\n\t\tif (libztex_checkCapability(ztex, CAPABILITY_MULTI_FPGA)) {\n\t\t\tcnt = libusb_control_transfer(ztex->hndl, 0xc0, 0x50, 0, 0, buf, 3, 1000);\n\t\t\tif (unlikely(cnt < 0)) {\n\t\t\t\tapplog(LOG_ERR, \"%s: Failed getMultiFpgaInfo with err %d\", ztex->repr, cnt);\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t\tztex->numberOfFpgas = buf[0] + 1;\n\t\t\tztex->selectedFpga = -1;//buf[1];\n\t\t\tztex->parallelConfigSupport = (buf[2] == 1);\n\t\t} else {\n\t\t\tztex->numberOfFpgas = 1;\n\t\t\tztex->selectedFpga = -1;//0;\n\t\t\tztex->parallelConfigSupport = false;\n\t\t}\n\t}\n\treturn ztex->numberOfFpgas;\n}\n\nint libztex_selectFpga(struct libztex_device *ztex, int16_t number)\n{\n\tint cnt, fpgacnt = libztex_numberOfFpgas(ztex->root);\n\n\tif (number < 0 || number >= fpgacnt) {\n\t\tapplog(LOG_WARNING, \"%s: Trying to select wrong fpga (%d in %d)\", ztex->repr, number, fpgacnt);\n\t\treturn 1;\n\t}\n\tif (ztex->root->selectedFpga != number && libztex_checkCapability(ztex->root, CAPABILITY_MULTI_FPGA)) {\n\t\tcnt = libusb_control_transfer(ztex->root->hndl, 0x40, 0x51, (uint16_t)number, 0, NULL, 0, 500);\n\t\tif (unlikely(cnt < 0)) {\n\t\t\tapplog(LOG_ERR, \"Ztex check device: Failed to set fpga with err %d\", cnt);\n\t\t\tztex->root->selectedFpga = -1;\n\t\t\treturn cnt;\n\t\t}\n\t\tztex->root->selectedFpga = number;\n\t}\n\treturn 0;\n}\n\nint libztex_setFreq(struct libztex_device *ztex, uint16_t freq, const char *repr)\n{\n\tint cnt;\n\tuint16_t oldfreq = ztex->dclk.freqM;\n\n\tif (freq > ztex->dclk.freqMaxM)\n\t\tfreq = ztex->dclk.freqMaxM;\n\n\tcnt = libusb_control_transfer(ztex->hndl, 0x40, 0x83, freq, 0, NULL, 0, 500);\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"Ztex check device: Failed to set frequency with err %d\", cnt);\n\t\treturn cnt;\n\t}\n\tztex->dclk.freqM = freq;\n\tif (oldfreq > ztex->dclk.freqMaxM)\n\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Frequency set to %u MHz (range: %u-%u)\",\n\t\t       repr,\n\t\t       (unsigned)(ztex->freqM1 * (ztex->dclk.freqM + 1)),\n\t\t       (unsigned)ztex->freqM1,\n\t\t       (unsigned)(ztex->freqM1 * (ztex->dclk.freqMaxM + 1))\n\t\t);\n\telse\n\t\tdclk_msg_freqchange(repr,\n\t\t                    ztex->freqM1 * (oldfreq + 1),\n\t\t                    ztex->freqM1 * (ztex->dclk.freqM + 1),\n\t\t                    NULL);\n\n\treturn 0;\n}\n\nint libztex_resetFpga(struct libztex_device *ztex)\n{\n\treturn libusb_control_transfer(ztex->hndl, 0x40, 0x31, 0, 0, NULL, 0, 1000);\n}\n\nint libztex_suspend(struct libztex_device *ztex)\n{\n\tif (ztex->suspendSupported) {\n\t\treturn libusb_control_transfer(ztex->hndl, 0x40, 0x84, 0, 0, NULL, 0, 1000);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstruct libztex_device *libztex_prepare_device2(struct libusb_device * const dev)\n{\n\tstruct libztex_device *newdev;\n\tint i, cnt, err;\n\tunsigned char buf[64];\n\n\tnewdev = malloc(sizeof(*newdev));\n\tif (!newdev)\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to malloc libztex_device\", __func__);\n\t\n\tnewdev->bitFileName = NULL;\n\tnewdev->numberOfFpgas = -1;\n\t\n\tdclk_prepare(&newdev->dclk);\n\tnewdev->dclk.freqMinM = 0;\n\terr = libusb_open(dev, &newdev->hndl);\n\tif (err != LIBUSB_SUCCESS) {\n\t\tapplog(LOG_ERR, \"%s: Can not open ZTEX device: %s\", __func__, bfg_strerror(err, BST_LIBUSB));\n\t\treturn NULL;\n\t}\n\n\terr = libusb_get_device_descriptor(dev, &newdev->descriptor);\n\tif (unlikely(err != 0)) {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to open read descriptor: %s\", __func__, bfg_strerror(err, BST_LIBUSB));\n\t}\n\n\tcnt = libztex_get_string_descriptor_ascii(newdev->hndl, newdev->descriptor.iSerialNumber, newdev->snString, sizeof(newdev->snString));\n\tif (unlikely(cnt < 0)) {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to read device snString: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\t}\n\t\n\tcnt = libztex_get_string_descriptor_ascii(newdev->hndl, newdev->descriptor.iProduct, buf, sizeof(buf));\n\tif (unlikely(cnt < 0))\n\t\tapplog(LOG_WARNING, \"%s: Failed to read device product: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\telse\n\t\tnewdev->dev_product = buf[0] ? strdup((void*)buf) : NULL;\n\t\n\tcnt = libztex_get_string_descriptor_ascii(newdev->hndl, newdev->descriptor.iManufacturer, buf, sizeof(buf));\n\tif (unlikely(cnt < 0))\n\t\tapplog(LOG_WARNING, \"%s: Failed to read device manufacturer: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\telse\n\t\tnewdev->dev_manufacturer = buf[0] ? strdup((void*)buf) : NULL;\n\n\tcnt = libusb_control_transfer(newdev->hndl, 0xc0, 0x22, 0, 0, buf, 40, 500);\n\tif (unlikely(cnt < 0)) {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to read ztex descriptor: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\t}\n\n\tif (buf[0] != 40 || buf[1] != 1 || buf[2] != 'Z' || buf[3] != 'T' || buf[4] != 'E' || buf[5] != 'X') {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Unexpected data reading ztex descriptor\", __func__);\n\t}\n\n\tnewdev->productId[0] = buf[6];\n\tnewdev->productId[1] = buf[7];\n\tnewdev->productId[2] = buf[8];\n\tnewdev->productId[3] = buf[9];\n\tnewdev->fwVersion = buf[10];\n\tnewdev->interfaceVersion = buf[11];\n\tnewdev->interfaceCapabilities[0] = buf[12];\n\tnewdev->interfaceCapabilities[1] = buf[13];\n\tnewdev->interfaceCapabilities[2] = buf[14];\n\tnewdev->interfaceCapabilities[3] = buf[15];\n\tnewdev->interfaceCapabilities[4] = buf[16];\n\tnewdev->interfaceCapabilities[5] = buf[17];\n\tnewdev->moduleReserved[0] = buf[18];\n\tnewdev->moduleReserved[1] = buf[19];\n\tnewdev->moduleReserved[2] = buf[20];\n\tnewdev->moduleReserved[3] = buf[21];\n\tnewdev->moduleReserved[4] = buf[22];\n\tnewdev->moduleReserved[5] = buf[23];\n\tnewdev->moduleReserved[6] = buf[24];\n\tnewdev->moduleReserved[7] = buf[25];\n\tnewdev->moduleReserved[8] = buf[26];\n\tnewdev->moduleReserved[9] = buf[27];\n\tnewdev->moduleReserved[10] = buf[28];\n\tnewdev->moduleReserved[11] = buf[29];\n\n\tcnt = libusb_control_transfer(newdev->hndl, 0xc0, 0x82, 0, 0, buf, 64, 500);\n\tif (unlikely(cnt < 0)) {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Failed to read ztex descriptor: %s\", __func__, bfg_strerror(cnt, BST_LIBUSB));\n\t}\n\n\tif (unlikely(buf[0] != 5)) {\n\t\tif (unlikely(buf[0] != 2 && buf[0] != 4)) {\n\t\t\tapplogr(NULL, LOG_ERR, \"%s: Invalid BTCMiner descriptor version (%d). Firmware must be updated.\", __func__, buf[0]);\n\t\t\treturn NULL;\n\t\t}\n\t\tapplog(LOG_WARNING, \"%s: Firmware out of date (%d).\", __func__, buf[0]);\n\t}\n\n\ti = buf[0] > 4? 11: (buf[0] > 2? 10: 8);\n\n\twhile (cnt < 64 && buf[cnt] != 0)\n\t\tcnt++;\n\tif (cnt < i + 1) {\n\t\tapplogr(NULL, LOG_ERR, \"%s: Invalid bitstream file name.\", __func__);\n\t}\n\n\tnewdev->bitFileName = malloc(sizeof(char) * (cnt + 1));\n\tmemcpy(newdev->bitFileName, &buf[i], cnt);\n\tnewdev->bitFileName[cnt] = 0;\t\n\n\tnewdev->numNonces = buf[1] + 1;\n\tnewdev->offsNonces = ((buf[2] & 255) | ((buf[3] & 255) << 8)) - 10000;\n\tnewdev->freqM1 = ((buf[4] & 255) | ((buf[5] & 255) << 8) ) * 0.01;\n\tnewdev->dclk.freqMaxM = (buf[7] & 255);\n\tnewdev->dclk.freqM = (buf[6] & 255);\n\tnewdev->dclk.freqMDefault = newdev->dclk.freqM;\n\tnewdev->suspendSupported = (buf[0] == 5);\n\tnewdev->hashesPerClock = buf[0] > 2? (((buf[8] & 255) | ((buf[9] & 255) << 8)) + 1) / 128.0: 1.0;\n\tnewdev->extraSolutions = buf[0] > 4? buf[10]: 0;\n\n\tapplog(LOG_DEBUG, \"%s: PID: %d numNonces: %d offsNonces: %d freqM1: %f freqMaxM: %d freqM: %d suspendSupported: %s hashesPerClock: %f extraSolutions: %d\",\n\t       __func__,\n\t                 buf[0], newdev->numNonces, newdev->offsNonces, newdev->freqM1, newdev->dclk.freqMaxM, newdev->dclk.freqM, newdev->suspendSupported ? \"T\": \"F\",\n\t                 newdev->hashesPerClock, newdev->extraSolutions);\n\n\tif (buf[0] < 4) {\n\t\tif (strncmp(newdev->bitFileName, \"ztex_ufm1_15b\", 13) != 0)\n\t\t\tnewdev->hashesPerClock = 0.5;\n\t\tapplog(LOG_WARNING, \"%s: HASHES_PER_CLOCK not defined, assuming %0.2f\", __func__, newdev->hashesPerClock);\n\t}\n\n\tnewdev->usbbus = libusb_get_bus_number(dev);\n\tnewdev->usbaddress = libusb_get_device_address(dev);\n\tsprintf(newdev->repr, \"ZTEX %s-1\", newdev->snString);\n\treturn newdev;\n}\n\nvoid libztex_destroy_device(struct libztex_device* ztex)\n{\n\tif (ztex->hndl != NULL) {\n\t\tlibusb_release_interface(ztex->hndl, 0);\n\t\tlibusb_close(ztex->hndl);\n\t\tztex->hndl = NULL;\n\t}\n\tif (ztex->bitFileName != NULL) {\n\t\tfree(ztex->bitFileName);\n\t\tztex->bitFileName = NULL;\n\t}\n\tfree(ztex);\n}\n\nint libztex_sendHashData(struct libztex_device *ztex, unsigned char *sendbuf)\n{\n\tint cnt = 0, ret, len;\n\n\tif (ztex == NULL || ztex->hndl == NULL)\n\t\treturn 0;\n\tret = 44; len = 0;\n\twhile (ret > 0) {\n\t\tcnt = libusb_control_transfer(ztex->hndl, 0x40, 0x80, 0, 0, sendbuf + len, ret, 1000);\n\t\tif (cnt >= 0) {\n\t\t\tret -= cnt;\n\t\t\tlen += cnt;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (unlikely(cnt < 0))\n\t\tapplog(LOG_ERR, \"%s: Failed sendHashData with err %d\", ztex->repr, cnt);\n\n\treturn cnt;\n}\n\nint libztex_readHashData(struct libztex_device *ztex, struct libztex_hash_data nonces[])\n{\n\tint bufsize = 12 + ztex->extraSolutions * 4;\n\tint cnt = 0, i, j, ret, len;\n\tunsigned char *rbuf;\n\n\tif (ztex->hndl == NULL)\n\t\treturn 0;\n\n\trbuf = malloc(sizeof(unsigned char) * (ztex->numNonces * bufsize));\n\tif (rbuf == NULL) {\n\t\tapplog(LOG_ERR, \"%s: Failed to allocate memory for reading nonces\", ztex->repr);\n\t\treturn 0;\n\t}\n\tret = bufsize * ztex->numNonces; len = 0;\n\twhile (ret > 0) {\n\t\tcnt = libusb_control_transfer(ztex->hndl, 0xc0, 0x81, 0, 0, rbuf + len, ret, 1000);\n\t\tif (cnt >= 0) {\n\t\t\tret -= cnt;\n\t\t\tlen += cnt;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(cnt < 0)) {\n\t\tapplog(LOG_ERR, \"%s: Failed readHashData with err %d\", ztex->repr, cnt);\n\t\tfree(rbuf);\n\t\treturn cnt;\n\t}\n\n\tfor (i=0; i<ztex->numNonces; i++) {\n\t\tuint32_t *nonce_data = (void*)&rbuf[i * bufsize];\n\t\tnonces[i].goldenNonce[0] = nonce_data[0] - ztex->offsNonces;\n\t\t//applog(LOG_DEBUG, \"W %d:0 %0.8x\", i, nonces[i].goldenNonce[0]);\n\n\t\tnonces[i].nonce = le32toh(nonce_data[1]) - ztex->offsNonces;\n\t\tnonces[i].hash7 = le32toh(nonce_data[2]);\n\n\t\tfor (j = 1; j <= ztex->extraSolutions; ++j)\n\t\t{\n\t\t\tnonces[i].goldenNonce[j] = le32toh(nonce_data[2 + j]) - ztex->offsNonces;\n\t\t\t//applog(LOG_DEBUG, \"W %d:%d %0.8x\", i, j, nonces[i].goldenNonce[j]);\n\t\t}\n\t}\n\n\tfree(rbuf);\n\treturn cnt;\n}\n\nvoid libztex_freeDevList(struct libztex_dev_list **devs)\n{\n\tbool done = false;\n\tssize_t cnt = 0;\n\n\twhile (!done) {\n\t\tif (devs[cnt]->next == NULL)\n\t\t\tdone = true;\n\t\tfree(devs[cnt++]);\n\t}\n\tfree(devs);\n}\n\n"
        },
        {
          "name": "libztex.h",
          "type": "blob",
          "size": 2.3505859375,
          "content": "#ifndef BFG_LIBZTEX_H\n#define BFG_LIBZTEX_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include <libusb.h>\n\n#include \"dynclock.h\"\n\n#define LIBZTEX_MAX_DESCRIPTORS 512\n#define LIBZTEX_SNSTRING_LEN 10\n\n#define LIBZTEX_IDVENDOR 0x221A\n#define LIBZTEX_IDPRODUCT 0x0100\n\nstruct libztex_fpgastate {\n\tbool fpgaConfigured;\n\tunsigned char fpgaChecksum;\n\tuint16_t fpgaBytes;\n\tunsigned char fpgaInitB;\n\tunsigned char fpgaFlashResult;\n\tbool fpgaFlashBitSwap;\n};\n\nstruct libztex_device {\n\tpthread_mutex_t\tmutex;\n\tstruct libztex_device *root;\n\tstruct libusb_device_descriptor descriptor;\n\tlibusb_device_handle *hndl; \n\tunsigned char usbbus;\n\tunsigned char usbaddress;\n\tchar *dev_manufacturer;\n\tchar *dev_product;\n\tunsigned char snString[LIBZTEX_SNSTRING_LEN+1];\n\tunsigned char productId[4];\n\tunsigned char fwVersion;\n\tunsigned char interfaceVersion;\n\tunsigned char interfaceCapabilities[6];\n\tunsigned char moduleReserved[12];\n\tuint8_t numNonces;\n\tuint16_t offsNonces;\n\tdouble freqM1;\t\n\tchar* bitFileName;\n\tbool suspendSupported;\n\tdouble hashesPerClock;\n\tuint8_t extraSolutions;\n\n\tstruct dclk_data dclk;\n\n\tint16_t numberOfFpgas;\n\tint handles;\n\tint selectedFpga;\n\tbool parallelConfigSupport;\n\t\n\tchar repr[20];\n};\n\nstruct libztex_dev_list { \n\tstruct libztex_device *dev;\n\tstruct libztex_dev_list *next;\n};\n\nstruct libztex_hash_data {\n\tuint32_t goldenNonce[2];\n\tuint32_t nonce;\n\tuint32_t hash7;\n};\n\nenum ztex_check_result\n{\n\tCHECK_ERROR,\n\tCHECK_IS_NOT_ZTEX,\n\tCHECK_OK,\n\tCHECK_RESCAN,\n};\n\nextern int libztex_scanDevices (struct libztex_dev_list ***devs);\nextern void libztex_freeDevList (struct libztex_dev_list **devs);\nextern enum ztex_check_result libztex_checkDevice(struct libusb_device *);\nextern struct libztex_device *libztex_prepare_device2(struct libusb_device *);\nextern void libztex_destroy_device (struct libztex_device* ztex);\nextern int libztex_configureFpga (struct libztex_device *dev, const char *repr);\nextern int libztex_setFreq (struct libztex_device *ztex, uint16_t freq, const char *repr);\nextern int libztex_sendHashData (struct libztex_device *ztex, unsigned char *sendbuf);\nextern int libztex_readHashData (struct libztex_device *ztex, struct libztex_hash_data nonces[]);\nextern int libztex_resetFpga (struct libztex_device *ztex);\nextern int libztex_selectFpga(struct libztex_device *ztex, int16_t fpgaNum);\nextern int libztex_numberOfFpgas(struct libztex_device *ztex);\n\n#endif /* __LIBZTEX_H__ */\n"
        },
        {
          "name": "linux-usb-bfgminer",
          "type": "blob",
          "size": 10.4296875,
          "content": "How to setup a BFGMiner using Xubuntu 11.04 live on a USB\n\nThe master version of this document is here:\n https://github.com/luke-jr/bfgminer/blob/master/linux-usb-bfgminer\n\nThe original old version on bitcointalk is:\n https://bitcointalk.org/index.php?topic=28402.msg426741#msg426741\n\n========\n\nI have said to select English for the install process for 2 reasons:\n1) I don't know any other spoken language very well\nand\n2) I'm not sure what problems installing under a different language\nmight cause (it will probably cause no problems but I don't know)\n\nSoftware\n========\nShort hardware comment:\nYour mining computer doesn't need any HDD or CD/DVD/BD as long as it has at\nleast 2GB of RAM, can boot USB, has some network connection to the internet\nand of course a reasonable mining ATI graphics card\n... Or you can boot a windows PC with the USB to only do mining ... and ignore\nthe system HDD ... wasting energy running the HDD (roughly 10 Watts per HDD) :)\n\nIf you wish to install to an HDD instead of a USB,\n see the changes to the instructions at the end\n\nTo create the USB, you need of course a 4GB USB and temporarily need a PC\nwith a CD (or DVD/BD) writer, a USB port and of course an internet\nconnection to the PC\n\n1) Download the xubuntu 11.04 desktop live CD iso for amd64\n   ( look here for mirrors: http://www.xubuntu.org/getubuntu )\n\n2) Burn it to CD then boot that temporarily on any PC with a CD/DVD/BD and\n   a USB port (this and the next 2 step won't effect that PC)\n   Select \"English\" then select \"Try Xubuntu without installing\"\n   and wait for the desktop to appear\n   (this happens by default if you wait for the timeouts)\n\n3) Plug in your 4GB USB device and it should appear on the desktop - you can\n   leave it's contents as long as there is at least 2.8GB free\n\n4) Now run \"Startup Disk Creator\" in \"Applications->System\"\n   (the system menu is the little rat in the top left corner)\n\n(if you have no mouse you can get the menu with <ctr><esc> and navigate\nthe menu with the arrow keys and <return> key)\n\nFrom here select the boot CD as the \"Source\" and the USB as the \"Disk to use\"\nlastly move the slider to 2GB for reserved extra space\n\nThe 2GB should be enough for modifications\n\nClick: \"Make Install Disk\"\nAfter about 10-15 minutes you have a base xubuntu 11.04 boot USB\n(you can shut down this computer now)\n\n5) Boot your BFGMiner PC with this USB stick, select \"English\"\n   then select \"Try Xubuntu without installing\" and wait for the desktop to\n   appear (this happens by default if you wait for the timeouts)\n\n6) Start a terminal\n   \"Applications->Accessories->Terminal Emulator\"\n\n7) sudo apt-get install openssh-server screen\n\n   if you have a problem here then it's probably coz the internet isn't\n   available ... sort that out by reading elsewhere about routers etc\n\n8) sudo apt-get install fglrx fglrx-amdcccle fglrx-dev\n   sudo sync\n   sudo shutdown -r now\n\nN.B. always do a \"sudo sync\" and wait for it to finish every time before\nshutting down the PC to ensure all data is written to the USB\n\n9) sudo aticonfig --lsa\n   this lists your ATI cards so you can see them\n sudo aticonfig --adapter=all --odgt\n   this checks it can access all the cards ...\n\n10) sudo aticonfig --adapter=all --initial\n   this gets an error - no idea why but the xorg.conf is OK\n sudo sync\n sudo shutdown -r now\n\n11) sudo aticonfig --adapter=all --odgt\n   this checks it can access all the cards ...\n\n12) get AMD-APP-SDK-v2.8-lnx64.tgz from\n http://developer.amd.com/tools/heterogeneous-computing/amd-accelerated-parallel-processing-app-sdk/downloads/\n  ( http://developer.amd.com/wordpress/media/2012/11/AMD-APP-SDK-v2.8-lnx64.tgz )\n\n sudo su\n cd /opt\n  (replace /home/ubuntu/ with wherever you put the file: )\n tar -xvzf /home/ubuntu/AMD-APP-SDK-v2.8-lnx64.tgz\n\n cd AMD-APP-SDK-v2.8-lnx64/\n cp -pv lib/x86_64/* /usr/lib/\n rsync -avl include/CL/ /usr/include/CL/\n tar -xvzf icd-registration.tgz\n rsync -avl etc/OpenCL/ /etc/OpenCL/\n ldconfig\n sync\n shutdown -r now\n\n You now have an OpenCL enabled xubuntu\n\n13) BFGMiner:\n sudo apt-get install curl\n\n get the binary Ubuntu BFGMiner from PPA\n https://launchpad.net/~unit3/+archive/bfgminer\n\n ./bfgminer -n\n   this shows you the GPU's it found on your PC\n   See further below if you get an error regarding libtinfo.so.5\n\n14) An OC option:\n This is no longer needed since BFGMiner 2.* includes OC, however:\n\n sudo apt-get install libwxbase2.8-0 libwxgtk2.8-0\n\n http://sourceforge.net/projects/amdovdrvctrl/\n  for an Over/underclocking application and get the file listed below then:\n sudo dpkg -i amdoverdrivectrl_1.2.1_amd64.deb\n\n15) set the screen saver to ONLY blank ...\n\n Move the mouse to the bottom of the screen and you see a set of icons like\n on an Apple PC\n Click on Settings, then in the Settings window \"Screensaver\"\n Set \"Mode:\" to \"Blank Screen Only\"\n\n16) apt-get install ntpd\n An accurate clock is always a good idea :)\n\n17) if you wish to ssh into the box you must set a password\n    to do this you simply have to be logged into it at the screen and type\n\n  sudo passwd ubuntu\n\n    it will prompt you (twice) to enter a password for the ubuntu account\n\n\nInitial setup complete.\n\n========\n\nIf you want to SSH into the machine and run BFGMiner:\n From a terminal on the miner display each time after you boot:\n  xhost +\n\n 'xhost +' isn't needed if you ssh into the machine with the same\n username that the GUI boots into (which is 'ubuntu' in this case)\n\nThen after you ssh into the machine:\n export DISPLAY=:0\nbefore running BFGMiner\n\nAlso note, that you should force the screen to blank when mining if\nthe ATI card is displaying the screen (using the screen saver\napplication menu)\nIn my case it takes away 50Mh/s when the screen isn't blanked\nIt will auto blank - but make sure the blank is of course just blank\nas mentioned above at 15)\n\n\nThis is of course just the basics ... but it should get you a computer\nup and running and able to run BFGMiner\n\n========\n\nYou should keep an eye on USB disk space\nThe system logger writes log files in the /var/log/ directory\nThe two main ones that grow large are 'kern.log' and 'syslog'\nIf you want to keep them, save them away to some other computer\nWhen space is low, just delete them e.g.\n\n   sudo rm -i /var/log/syslog\n   sudo rm -i /var/log/kern.log\n\nThe 'df' command will show you the current space e.g.:\n\n   sudo df\n\nFilesystem           1K-blocks      Used Available Use% Mounted on\naufs                   2099420    892024   1100748  45% /\nnone                   1015720       628   1015092   1% /dev\n/dev/sda1              3909348   2837248   1072100  73% /cdrom\n/dev/loop0              670848    670848         0 100% /rofs\nnone                   1023772       136   1023636   1% /dev/shm\ntmpfs                  1023772        16   1023756   1% /tmp\nnone                   1023772       124   1023648   1% /var/run\nnone                   1023772         0   1023772   0% /var/lock\n\n\nThis shows the 2GB space allocated when you setup the USB as '/' (aufs)\nIn this example, it's currently 45% full with almost 1.1GB of free space\n\n========\n\nThe latest version (2.0.8) of BFGMiner is built with 11.10 (not 11.04)\nIf you get the following error when running the prebuilt version in 11.04:\n\n   ./bfgminer: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory\n\nThe fix is to simply link the old curses library to the new name e.g.:\n\n   cd /lib64/\n   sudo ln -s libncurses.so.5 libtinfo.so.5\n\n========\n\nIf you wish to install to an HDD instead of a USB:\n--------------------------------------------------\n\nAs per before:\n\n1) Download the xubuntu 11.04 desktop live CD iso for amd64\n   ( look here for mirrors: http://www.xubuntu.org/getubuntu )\n\nThen:\n\n2) Burn it to CD then boot that on your new mining PC\n   Select \"English\" then select \"Install Xubuntu\"\n   (you have 30 seconds to do this)\n\n3) When the Install window comes up - again select \"English\" and click \"Forward\"\n\n4) The next page will show you if you meet certain install requirements\n   (make sure you do meet them all)\n   Don't select the download option\n   The 3rd party option isn't needed for mining so ignore that also\n\n   Click \"Forward\"\n\n5) With \"Allocate drive space\" it's probably easiest to say to use the\n   \"Erase\" option.\n\n   This is just for mining right? :)\n\n   However, if you have anything on the HDD that you want to keep - the\n   \"Erase\" install process will delete it - so back it up (quit the install)\n   Also make sure there are no OTHER HDD attached that it may erase also\n   i.e. only have attached the one HDD that you want to install onto unless\n   you know exactly what you are doing\n\n   If you see the \"Install Xubuntu 11.04 alongside 'something'\" then that\n   just means that the HDD wasn't blank.\n   If you want to try this option - do that yourself and then skip to step\n   7) below when you get to that.\n\n   There are plenty of other options available if you select \"Something else\"\n   but I'm not going to go into all the details here other than to say that\n   my preferred partioning is: /boot = 1GB = ext2, swap = twice memory size,\n   / = 100GB = ext3 and the rest: /extra = ext3\n\n   Click \"Forward\"\n\n6) If you selected \"Erase\" then it allows you to choose the drive to install to\n   Then click \"Install Now\"\n\n7) \"Where are you?\" sort that out then click \"Forward\"\n\n8) \"Keyboard layout\" sort that out (use the default) then click \"Forward\"\n\n9) \"Who are you?\" The important one here is \"Pick a username:\" coz that's\n   the name you will need to ssh into, to access it remotely (and of course\n   the \"Choose a Password\" you set)\n\n   If you set the \"username\" to anything but \"ubuntu\" then: wherever in this\n   document I have mentioned the username \"ubuntu\" you must of course use the\n   username you chose here instead of \"ubuntu\"\n\n   Important: set it to \"log in automatically\" if you ever want to be able\n   to start BFGMiner without being in front of the computer since 'X' must\n   be running to use BFGMiner properly\n   That does of course mean that the computer isn't secure from anyone who\n   has access to it - but then again no computer that can automatically\n   reboot is secure from anyone who has access to the actual computer itself\n\n   Then click \"Forward\"\n\n10) Of course when it completes click on \"Restart Now\"\n    ... and remove the Xubuntu CD when it asks you\n\n11) Wait for it to finish rebooting ... and it will auto login\n    (unless you didn't do step 9) \"Important:\")\n\n12) After it logs in, an upgrade popup for 11.10 (or later) will appear\n    Select \"Don't Upgrade\"\n\n13) Now go to step 6) of the USB script above for what to do next and that\n    covers everything else needed\n"
        },
        {
          "name": "logging.c",
          "type": "blob",
          "size": 2.2763671875,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2013 Andrew Smith\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <unistd.h>\n\n#include \"compat.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n\nbool opt_debug = false;\nbool opt_debug_console = false;  // Only used if opt_debug is also enabled\nbool opt_log_output = false;\nbool opt_log_microseconds;\n\n/* per default priorities higher than LOG_NOTICE are logged */\nint opt_log_level = LOG_NOTICE;\n\nstatic void _my_log_curses(int prio, const char *datetime, const char *str)\n{\n#ifdef HAVE_CURSES\n\textern bool use_curses;\n\tif (use_curses && _log_curses_only(prio, datetime, str))\n\t\t;\n\telse\n#endif\n\t{\n\t\tlast_logstatusline_len = -1;\n\t\tprintf(\"\\n %s %s\\r\", datetime, str);\n\t\tfflush(stdout);\n\t}\n}\n\n/* high-level logging function, based on global opt_log_level */\n\n/*\n * log function\n */\nvoid _applog(int prio, const char *str)\n{\n#ifdef HAVE_SYSLOG_H\n\tif (use_syslog) {\n\t\tsyslog(prio, \"%s\", str);\n\t}\n#else\n\tif (0) {}\n#endif\n\telse {\n\t\tbool writetocon =\n\t\t\t(opt_debug_console || (opt_log_output && prio != LOG_DEBUG) || prio <= LOG_NOTICE)\n\t\t && !(opt_quiet && prio != LOG_ERR);\n\t\tbool writetofile = !isatty(fileno((FILE *)stderr));\n\t\tif (!(writetocon || writetofile))\n\t\t\treturn;\n\n\t\tchar datetime[64];\n\n\t\tif (opt_log_microseconds)\n\t\t{\n\t\t\tstruct timeval tv;\n\t\t\tstruct tm tm;\n\t\t\t\n\t\t\tbfg_gettimeofday(&tv);\n\t\t\tlocaltime_r(&tv.tv_sec, &tm);\n\t\t\t\n\t\t\tsnprintf(datetime, sizeof(datetime), \"[%d-%02d-%02d %02d:%02d:%02d.%06ld]\",\n\t\t\t\ttm.tm_year + 1900,\n\t\t\t\ttm.tm_mon + 1,\n\t\t\t\ttm.tm_mday,\n\t\t\t\ttm.tm_hour,\n\t\t\t\ttm.tm_min,\n\t\t\t\ttm.tm_sec,\n\t\t\t\t(long)tv.tv_usec);\n\t\t}\n\t\telse\n\t\t\tget_now_datestamp(datetime, sizeof(datetime));\n\n\t\tif (writetofile || writetocon)\n\t\t{\n\t\t\tbfg_console_lock();\n\t\t\t\n\t\t\t/* Only output to stderr if it's not going to the screen as well */\n\t\t\tif (writetofile) {\n\t\t\t\tfprintf(stderr, \" %s %s\\n\", datetime, str);\t/* atomic write to stderr */\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\n\t\t\tif (writetocon)\n\t\t\t\t_my_log_curses(prio, datetime, str);\n\t\t\t\n\t\t\tbfg_console_unlock();\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "logging.h",
          "type": "blob",
          "size": 3.9228515625,
          "content": "/*\n * Copyright 2013-2014 Luke Dashjr\n * Copyright 2012 zefir\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_LOGGING_H\n#define BFG_LOGGING_H\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#ifdef HAVE_SYSLOG_H\n#include <syslog.h>\n#else\nenum {\n\tLOG_ERR,\n\tLOG_WARNING,\n\tLOG_NOTICE,\n\tLOG_INFO,\n\tLOG_DEBUG,\n};\n#endif\n\n#include \"util.h\"\n\n/* debug flags */\nextern bool opt_debug;\nextern bool opt_debug_console;\nextern bool opt_log_output;\nextern bool opt_log_microseconds;\nextern bool opt_realquiet;\nextern bool want_per_device_stats;\n\n/* global log_level, messages with lower or equal prio are logged */\nextern int opt_log_level;\n\n#define return_via(label, stmt)  do {  \\\n\tstmt;  \\\n\tgoto label;  \\\n} while (0)\n\n#define LOGBUFSIZ 0x1000\n\nextern void _applog(int prio, const char *str);\n\n#define IN_FMT_FFL \" in %s %s():%d\"\n\n#define applog(prio, fmt, ...) do { \\\n\tif (opt_debug || (prio) != LOG_DEBUG) { \\\n\t\t\tchar tmp42[LOGBUFSIZ]; \\\n\t\t\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\t\t\t_applog(prio, tmp42); \\\n\t} \\\n} while (0)\n\n#define applogsiz(prio, _SIZ, fmt, ...) do { \\\n\tif (opt_debug || (prio) != LOG_DEBUG) { \\\n\t\t\tchar tmp42[_SIZ]; \\\n\t\t\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\t\t\t_applog(prio, tmp42); \\\n\t} \\\n} while (0)\n\n#define applogr(rv, prio, ...)  do {  \\\n\tapplog(prio, __VA_ARGS__);  \\\n\treturn rv;  \\\n} while (0)\n\n#define return_via_applog(label, expr, prio, ...)  do {  \\\n\tapplog(prio, __VA_ARGS__);  \\\n\texpr;  \\\n\tgoto label;  \\\n} while (0)\n\n#define appperror(prio, s)  do {  \\\n\tconst char *_tmp43 = bfg_strerror(errno, BST_ERRNO);  \\\n\tif (s && s[0])  \\\n\t\tapplog(prio, \"%s: %s\", s, _tmp43);  \\\n\telse  \\\n\t\t_applog(prio, _tmp43);  \\\n} while (0)\n\n#define perror(s)  appperror(LOG_ERR, s)\n\n#define applogfailinfo(prio, failed, fmt, ...)  do {  \\\n\tapplog(prio, \"Failed to %s\"IN_FMT_FFL\": \"fmt,  \\\n\t       failed,  \\\n\t       __FILE__, __func__, __LINE__,  \\\n\t       __VA_ARGS__);  \\\n} while (0)\n\n#define applogfailinfor(rv, prio, failed, fmt, ...)  do {  \\\n\tapplogfailinfo(prio, failed, fmt, __VA_ARGS__);  \\\n\treturn rv;  \\\n} while (0)\n\n#define return_via_applogfailinfo(label, expr, prio, failed, fmt, ...)  do {  \\\n\tapplogfailinfo(prio, failed, fmt, __VA_ARGS__);  \\\n\texpr;  \\\n\tgoto label;  \\\n} while (0)\n\n#define applogfail(prio, failed)  do {  \\\n\tapplog(prio, \"Failed to %s\"IN_FMT_FFL,  \\\n\t       failed,  \\\n\t       __FILE__, __func__, __LINE__);  \\\n} while (0)\n\n#define applogfailr(rv, prio, failed)  do {  \\\n\tapplogfail(prio, failed);  \\\n\treturn rv;  \\\n} while (0)\n\n#define return_via_applogfail(label, expr, prio, failed)  do {  \\\n\tapplogfail(prio, failed);  \\\n\texpr;  \\\n\tgoto label;  \\\n} while (0)\n\nextern void _bfg_clean_up(bool);\n\n#define quit(status, fmt, ...) do { \\\n\t_bfg_clean_up(false);  \\\n\tif (fmt) { \\\n\t\tfprintf(stderr, \"\\n\" fmt, ##__VA_ARGS__);  \\\n\t} \\\n\tfflush(stderr);  \\\n\t_quit(status); \\\n} while (0)\n\n#define quithere(status, fmt, ...) do { \\\n\tif (fmt) { \\\n\t\tchar tmp42[LOGBUFSIZ]; \\\n\t\tsnprintf(tmp42, sizeof(tmp42), fmt IN_FMT_FFL, \\\n\t\t\t\t##__VA_ARGS__, __FILE__, __func__, __LINE__); \\\n\t\t_applog(LOG_ERR, tmp42); \\\n\t} \\\n\t_quit(status); \\\n} while (0)\n\n#define quitfrom(status, _file, _func, _line, fmt, ...) do { \\\n\tif (fmt) { \\\n\t\tchar tmp42[LOGBUFSIZ]; \\\n\t\tsnprintf(tmp42, sizeof(tmp42), fmt IN_FMT_FFL, \\\n\t\t\t\t##__VA_ARGS__, _file, _func, _line); \\\n\t\t_applog(LOG_ERR, tmp42); \\\n\t} \\\n\t_quit(status); \\\n} while (0)\n\n#ifdef HAVE_CURSES\n\n#define wlog(fmt, ...) do { \\\n\tchar tmp42[LOGBUFSIZ]; \\\n\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\t_wlog(tmp42); \\\n} while (0)\n\n#define wlogprint(fmt, ...) do { \\\n\tchar tmp42[LOGBUFSIZ]; \\\n\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\t_wlogprint(tmp42); \\\n} while (0)\n\n#endif\n\n#endif /* __LOGGING_H__ */\n"
        },
        {
          "name": "lowl-ftdi.c",
          "type": "blob",
          "size": 13.966796875,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#include <libusb.h>\n\n#include \"compat.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-ftdi.h\"\n#include \"miner.h\"\n\n#define FT232R_IDVENDOR   0x0403\n#define FT232R_IDPRODUCT  0x6001\n#define FT232H_IDPRODUCT  0x6014\n\n#define FT232H_LATENCY_MS  2\n\nstatic\nvoid ft232r_devinfo_free(struct lowlevel_device_info * const info)\n{\n\tlibusb_device * const dev = info->lowl_data;\n\tif (dev)\n\t\tlibusb_unref_device(dev);\n}\n\nstatic\nbool _ft232r_devinfo_scan_cb(struct lowlevel_device_info * const usbinfo, void * const userp)\n{\n\tstruct lowlevel_device_info **devinfo_list_p = userp, *info;\n\t\n\tinfo = malloc(sizeof(*info));\n\t*info = (struct lowlevel_device_info){\n\t\t.lowl = &lowl_ft232r,\n\t\t.lowl_data = libusb_ref_device(usbinfo->lowl_data),\n\t};\n\tlowlevel_devinfo_semicpy(info, usbinfo);\n\tLL_PREPEND(*devinfo_list_p, info);\n\t\n\t// Never *consume* the lowl_usb entry - especially since this is during the scan!\n\treturn false;\n}\n\nstatic\nstruct lowlevel_device_info *ft232r_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_list = NULL;\n\t\n\tlowlevel_detect_id(_ft232r_devinfo_scan_cb, &devinfo_list, &lowl_usb, FT232R_IDVENDOR, FT232H_IDPRODUCT);\n\tlowlevel_detect_id(_ft232r_devinfo_scan_cb, &devinfo_list, &lowl_usb, FT232R_IDVENDOR, FT232R_IDPRODUCT);\n\t\n\treturn devinfo_list;\n}\n\n#define FTDI_REQTYPE  (LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE)\n#define FTDI_REQTYPE_IN   (FTDI_REQTYPE | LIBUSB_ENDPOINT_IN)\n#define FTDI_REQTYPE_OUT  (FTDI_REQTYPE | LIBUSB_ENDPOINT_OUT)\n\n#define FTDI_REQUEST_RESET           0\n#define FTDI_REQUEST_SET_BAUDRATE    3\n#define FTDI_REQUEST_SET_EVENT_CHAR     0x06\n#define FTDI_REQUEST_SET_ERROR_CHAR     0x07\n#define FTDI_REQUEST_SET_LATENCY_TIMER  0x09\n#define FTDI_REQUEST_SET_BITMODE  0x0b\n#define FTDI_REQUEST_GET_PINS     0x0c\n#define FTDI_REQUEST_GET_BITMODE  0x0c\n\n#define FTDI_RESET_SIO  0\n\n#define FTDI_BAUDRATE_3M  0,0\n\n#define FTDI_BITMODE_MPSSE  0x02\n\n#define FTDI_INDEX       1\n#define FTDI_TIMEOUT  1000\n\n// http://www.ftdichip.com/Support/Documents/AppNotes/AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf\n#define FTDI_ADBUS_SET         0x80\n#define FTDI_ACBUS_SET         0x82\n#define FTDI_LOOPBACK_DISABLE  0x85\n#define FTDI_TCK_DIVISOR       0x86\n// Divide-by-five clock prescaler\n#define FTDI_DIV5_ENABLE       0x8b\n\nstruct ft232r_device_handle {\n\tlibusb_device_handle *h;\n\tuint8_t i;\n\tuint8_t o;\n\tint iPktSz;\n\tunsigned char ibuf[0x400];\n\tint ibufLen;\n\tuint16_t osz;\n\tunsigned char *obuf;\n\tuint16_t obufsz;\n\tbool mpsse;\n};\n\nstatic\nstruct ft232r_device_handle *ftdi_common_open(const struct lowlevel_device_info * const info)\n{\n\tlibusb_device * const dev = info->lowl_data;\n\t\n\t// FIXME: Cleanup on errors\n\tlibusb_device_handle *devh;\n\tstruct ft232r_device_handle *ftdi;\n\n\tif (libusb_open(dev, &devh)) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Error opening device\");\n\t\treturn NULL;\n\t}\n\tlibusb_reset_device(devh);\n\tlibusb_detach_kernel_driver(devh, 0);\n\tif (libusb_set_configuration(devh, 1)) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Error setting configuration\");\n\t\treturn NULL;\n\t}\n\tif (libusb_claim_interface(devh, 0)) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Error claiming interface\");\n\t\treturn NULL;\n\t}\n\n\tstruct libusb_config_descriptor *cfg;\n\tif (libusb_get_config_descriptor(dev, 0, &cfg)) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Error getting config descriptor\");\n\t\treturn NULL;\n\t}\n\tconst struct libusb_interface_descriptor *altcfg = &cfg->interface[0].altsetting[0];\n\tif (altcfg->bNumEndpoints < 2) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Too few endpoints\");\n\t\treturn NULL;\n\t}\n\tftdi = calloc(1, sizeof(*ftdi));\n\tftdi->h = devh;\n\tftdi->i = altcfg->endpoint[0].bEndpointAddress;\n\tftdi->iPktSz = altcfg->endpoint[0].wMaxPacketSize;\n\tftdi->o = altcfg->endpoint[1].bEndpointAddress;\n\tftdi->osz = 0x1000;\n\tftdi->obuf = malloc(ftdi->osz);\n\tlibusb_free_config_descriptor(cfg);\n\n\treturn ftdi;\n}\n\nstruct ft232r_device_handle *ft232r_open(const struct lowlevel_device_info * const info)\n{\n\tstruct ft232r_device_handle * const ftdi = ftdi_common_open(info);\n\tif (!ftdi)\n\t\treturn NULL;\n\t\n\tif (libusb_control_transfer(ftdi->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_BAUDRATE, FTDI_BAUDRATE_3M, NULL, 0, FTDI_TIMEOUT) < 0) {\n\t\tapplog(LOG_ERR, \"ft232r_open: Error performing control transfer\");\n\t\tft232r_close(ftdi);\n\t\treturn NULL;\n\t}\n\t\n\treturn ftdi;\n}\n\nstatic\nvoid ft232h_mpsse_clock_divisor(uint8_t * const buf, const unsigned long clock, const unsigned long freq)\n{\n\tconst uint16_t divisor = (clock / freq / 2) - 1;\n\tbuf[0] = divisor & 0xff;\n\tbuf[1] = divisor >> 8;\n}\n\nstatic ssize_t ft232r_readwrite(struct ft232r_device_handle *, unsigned char, void *, size_t);\n\nstruct ft232r_device_handle *ft232h_open_mpsse(const struct lowlevel_device_info * const info)\n{\n\tif (info->pid != FT232H_IDPRODUCT)\n\t\treturn NULL;\n\t\n\tstruct ft232r_device_handle * const ftdi = ftdi_common_open(info);\n\tuint8_t buf[3];\n\tif (!ftdi)\n\t\treturn NULL;\n\t\n\tif (libusb_control_transfer(ftdi->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_RESET, FTDI_RESET_SIO, 1, NULL, 0, FTDI_TIMEOUT) < 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error requesting %s\", __func__, \"SIO reset\");\n\t\tgoto err;\n\t}\n\t\n\tif (libusb_control_transfer(ftdi->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_LATENCY_TIMER, FT232H_LATENCY_MS, 1, NULL, 0, FTDI_TIMEOUT) < 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting %s\", __func__, \"latency timer\");\n\t\tgoto err;\n\t}\n\t\n\tif (libusb_control_transfer(ftdi->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_EVENT_CHAR, 0, 1, NULL, 0, FTDI_TIMEOUT) < 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting %s\", __func__, \"event char\");\n\t\tgoto err;\n\t}\n\t\n\tif (libusb_control_transfer(ftdi->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_ERROR_CHAR, 0, 1, NULL, 0, FTDI_TIMEOUT) < 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting %s\", __func__, \"error char\");\n\t\tgoto err;\n\t}\n\t\n\tif (!ft232r_set_bitmode(ftdi, 0, FTDI_BITMODE_MPSSE))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting %s\", __func__, \"MPSSE bitmode\");\n\t\tgoto err;\n\t}\n\t\n\tbuf[0] = FTDI_DIV5_ENABLE;\n\tif (ft232r_readwrite(ftdi, ftdi->o, buf, 1) != 1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error requesting %s\", __func__, \"divide-by-five clock prescaler\");\n\t\tgoto err;\n\t}\n\t\n\tbuf[0] = FTDI_TCK_DIVISOR;\n\tft232h_mpsse_clock_divisor(&buf[1], 12000000, 200000);\n\tif (ft232r_readwrite(ftdi, ftdi->o, buf, 3) != 3)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting %s\", __func__, \"MPSSE clock divisor\");\n\t\tgoto err;\n\t}\n\t\n\tbuf[0] = FTDI_LOOPBACK_DISABLE;\n\tif (ft232r_readwrite(ftdi, ftdi->o, buf, 1) != 1)\n\t\tapplog(LOG_WARNING, \"%s: Error disabling loopback\", __func__);\n\t\n\tftdi->mpsse = true;\n\t\n\treturn ftdi;\n\nerr:\n\tft232r_close(ftdi);\n\treturn NULL;\n}\n\nvoid ft232r_close(struct ft232r_device_handle *dev)\n{\n\tlibusb_release_interface(dev->h, 0);\n\tlibusb_reset_device(dev->h);\n\tlibusb_close(dev->h);\n\tfree(dev);\n}\n\nbool ft232r_purge_buffers(struct ft232r_device_handle *dev, enum ft232r_reset_purge purge)\n{\n\tif (ft232r_flush(dev) < 0)\n\t\treturn false;\n\n\tif (purge & FTDI_PURGE_RX) {\n\t\tif (libusb_control_transfer(dev->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_RESET, FTDI_PURGE_RX, FTDI_INDEX, NULL, 0, FTDI_TIMEOUT))\n\t\t\treturn false;\n\t\tdev->ibufLen = 0;\n\t}\n\tif (purge & FTDI_PURGE_TX)\n\t\tif (libusb_control_transfer(dev->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_RESET, FTDI_PURGE_TX, FTDI_INDEX, NULL, 0, FTDI_TIMEOUT))\n\t\t\treturn false;\n\treturn true;\n}\n\nbool ft232r_set_bitmode(struct ft232r_device_handle *dev, uint8_t mask, uint8_t mode)\n{\n\tif (ft232r_flush(dev) < 0)\n\t\treturn false;\n\tif (libusb_control_transfer(dev->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_BITMODE, mask, FTDI_INDEX, NULL, 0, FTDI_TIMEOUT))\n\t\treturn false;\n\treturn !libusb_control_transfer(dev->h, FTDI_REQTYPE_OUT, FTDI_REQUEST_SET_BITMODE, (mode << 8) | mask, FTDI_INDEX, NULL, 0, FTDI_TIMEOUT);\n}\n\nstatic ssize_t ft232r_readwrite(struct ft232r_device_handle *dev, unsigned char endpoint, void *data, size_t count)\n{\n\tint transferred;\n\tswitch (libusb_bulk_transfer(dev->h, endpoint, data, count, &transferred, FTDI_TIMEOUT)) {\n\t\tcase LIBUSB_ERROR_TIMEOUT:\n\t\t\tif (!transferred) {\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// fallthru\n\t\tcase 0:\n\t\t\tif (opt_dev_protocol)\n\t\t\t{\n\t\t\t\tchar x[(transferred * 2) + 1];\n\t\t\t\tbin2hex(x, data, transferred);\n\t\t\t\tapplog(LOG_DEBUG, \"ft232r %p: %s: %s\",\n\t\t\t\t       dev,\n\t\t\t\t       (endpoint & LIBUSB_ENDPOINT_IN) ? \"RECV\" : \"SEND\",\n\t\t\t\t       x);\n\t\t\t}\n\t\t\t\n\t\t\treturn transferred;\n\t\tdefault:\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t}\n}\n\nssize_t ft232r_flush(struct ft232r_device_handle *dev)\n{\n\tif (!dev->obufsz)\n\t\treturn 0;\n\tssize_t r = ft232r_readwrite(dev, dev->o, dev->obuf, dev->obufsz);\n\tif (r == dev->obufsz) {\n\t\tdev->obufsz = 0;\n\t} else if (r > 0) {\n\t\tdev->obufsz -= r;\n\t\tmemmove(dev->obuf, &dev->obuf[r], dev->obufsz);\n\t}\n\treturn r;\n}\n\nssize_t ft232r_write(struct ft232r_device_handle * const dev, const void * const data, const size_t count)\n{\n\tuint16_t bufleft;\n\tssize_t r;\n\t\n\tbufleft = dev->osz - dev->obufsz;\n\t\n\tif (count < bufleft) {\n\t\t// Just add to output buffer\n\t\tmemcpy(&dev->obuf[dev->obufsz], data, count);\n\t\tdev->obufsz += count;\n\t\treturn count;\n\t}\n\t\n\t// Fill up buffer and flush\n\tmemcpy(&dev->obuf[dev->obufsz], data, bufleft);\n\tdev->obufsz += bufleft;\n\tr = ft232r_flush(dev);\n\t\n\tif (unlikely(r <= 0)) {\n\t\t// In this case, no bytes were written supposedly, so remove this data from buffer\n\t\tdev->obufsz -= bufleft;\n\t\treturn r;\n\t}\n\t\n\t// Even if not all <bufleft> bytes from this write got out, the remaining are still buffered\n\treturn bufleft;\n}\n\ntypedef ssize_t (*ft232r_rwfunc_t)(struct ft232r_device_handle *, void*, size_t);\n\nstatic\nssize_t ft232r_rw_all(const void * const rwfunc_p, struct ft232r_device_handle * const dev, void * const data, size_t count)\n{\n\tft232r_rwfunc_t rwfunc = rwfunc_p;\n\tchar *p = data;\n\tssize_t writ = 0, total = 0;\n\n\twhile (count && (writ = rwfunc(dev, p, count)) > 0) {\n\t\tp += writ;\n\t\tcount -= writ;\n\t\ttotal += writ;\n\t}\n\treturn total ?: writ;\n}\n\nssize_t ft232r_write_all(struct ft232r_device_handle * const dev, const void * const data_p, size_t count)\n{\n\tconst uint8_t *data = data_p;\n\tif (dev->mpsse)\n\t{\n\t\tssize_t e;\n\t\twhile (count > 0x10000)\n\t\t{\n\t\t\te = ft232r_write_all(dev, data, 0x10000);\n\t\t\tif (e != 0x10000)\n\t\t\t\treturn e;\n\t\t\tdata += 0x10000;\n\t\t\tcount -= 0x10000;\n\t\t}\n\t\t\n\t\tconst uint16_t ftdilen = count - 1;\n\t\tconst uint8_t cmd[] = { 0x11, ftdilen & 0xff, ftdilen >> 8 };\n\t\te = ft232r_rw_all(ft232r_write, dev, (void*)cmd, 3);\n\t\tif (e != 3)\n\t\t\treturn e;\n\t}\n\treturn ft232r_rw_all(ft232r_write, dev, (void*)data, count) + (data - (uint8_t*)data_p);\n}\n\nssize_t ft232r_read(struct ft232r_device_handle *dev, void *data, size_t count)\n{\n\tssize_t r;\n\tint adj;\n\t\n\t// Flush any pending output before reading\n\tr = ft232r_flush(dev);\n\tif (r < 0)\n\t\treturn r;\n\t\n\t// First 2 bytes of every packet are FTDI status or something\n\twhile (dev->ibufLen <= 2) {\n\t\t// TODO: Implement a timeout for status byte repeating\n\t\tint transferred = ft232r_readwrite(dev, dev->i, dev->ibuf, sizeof(dev->ibuf));\n\t\tif (transferred <= 0)\n\t\t\treturn transferred;\n\t\tdev->ibufLen = transferred;\n\t\tfor (adj = dev->iPktSz; dev->ibufLen > adj; adj += dev->iPktSz - 2) {\n\t\t\tdev->ibufLen -= 2;\n\t\t\tmemmove(&dev->ibuf[adj], &dev->ibuf[adj+2], dev->ibufLen - adj);\n\t\t}\n\t}\n\tunsigned char *ibufs = &dev->ibuf[2];\n\tsize_t ibufsLen = dev->ibufLen - 2;\n\t\n\tif (count > ibufsLen)\n\t\tcount = ibufsLen;\n\tmemcpy(data, ibufs, count);\n\tdev->ibufLen -= count;\n\tibufsLen -= count;\n\tif (ibufsLen) {\n\t\tmemmove(ibufs, &ibufs[count], ibufsLen);\n\t\tapplog(LOG_DEBUG, \"ft232r_read: %\"PRIu64\" bytes extra\", (uint64_t)ibufsLen);\n\t}\n\treturn count;\n}\n\nssize_t ft232r_read_all(struct ft232r_device_handle *dev, void *data, size_t count)\n{\n\treturn ft232r_rw_all(ft232r_read, dev, data, count);\n}\n\nbool ft232r_get_pins(struct ft232r_device_handle *dev, uint8_t *pins)\n{\n\treturn libusb_control_transfer(dev->h, FTDI_REQTYPE_IN, FTDI_REQUEST_GET_PINS, 0, FTDI_INDEX, pins, 1, FTDI_TIMEOUT) == 1;\n}\n\nbool ft232r_get_bitmode(struct ft232r_device_handle *dev, uint8_t *out_mode)\n{\n\treturn libusb_control_transfer(dev->h, FTDI_REQTYPE_IN, FTDI_REQUEST_GET_BITMODE, 0, FTDI_INDEX, out_mode, 1, FTDI_TIMEOUT) == 1;\n}\n\nbool ft232r_set_cbus_bits(struct ft232r_device_handle *dev, bool sc, bool cs)\n{\n\tuint8_t pin_state = (cs ? (1<<2) : 0)\n\t                  | (sc ? (1<<3) : 0);\n\treturn ft232r_set_bitmode(dev, 0xc0 | pin_state, 0x20);\n}\n\nbool ft232r_get_cbus_bits(struct ft232r_device_handle *dev, bool *out_sio0, bool *out_sio1)\n{\n\tuint8_t data;\n\tif (!ft232r_get_bitmode(dev, &data))\n\t\treturn false;\n\t*out_sio0 = data & 1;\n\t*out_sio1 = data & 2;\n\treturn true;\n}\n\nbool ft232h_mpsse_set_axbus(struct ft232r_device_handle * const ftdi, const uint8_t value, const uint8_t directions, const bool adbus)\n{\n\tif (ft232r_flush(ftdi))\n\t\tcgsleep_ms(1);\n\tconst uint8_t buf[] = { adbus ? FTDI_ADBUS_SET : FTDI_ACBUS_SET, value, directions };\n\treturn (ft232r_write(ftdi, buf, 3) == 3) && (ft232r_flush(ftdi) == 3);\n}\n\nssize_t ft232h_mpsse_readwrite_all(struct ft232r_device_handle * const dev, void * const read_data_p, const void * const write_data_p, size_t count)\n{\n\tuint8_t *read_data = read_data_p;\n\tconst uint8_t *write_data = write_data_p;\n\t\n\twhile (count > 0x10000)\n\t{\n\t\tft232h_mpsse_readwrite_all(dev, read_data, write_data, 0x10000);\n\t\tread_data += 0x10000;\n\t\twrite_data += 0x10000;\n\t\tcount -= 0x10000;\n\t}\n\t\n\tconst uint16_t ftdilen = count - 1;\n\tconst uint8_t cmd[] = { 0x31, ftdilen & 0xff, ftdilen >> 8 };\n\tssize_t e;\n\t\n\te = ft232r_rw_all(ft232r_write, dev, (void*)cmd, 3);\n\tif (e != 3)\n\t\treturn e;\n\t\n\te = ft232r_rw_all(ft232r_write, dev, (void*)write_data, count);\n\tif (e != count)\n\t\treturn e;\n\t\n\treturn ft232r_read_all(dev, read_data, count) + (read_data - (uint8_t*)read_data_p);\n}\n\nstruct lowlevel_driver lowl_ft232r = {\n\t.dname = \"ft232r\",\n\t.devinfo_scan = ft232r_devinfo_scan,\n\t.devinfo_free = ft232r_devinfo_free,\n};\n\n#if 0\nint main() {\n\tlibusb_init(NULL);\n\tft232r_scan();\n\tft232r_scan_free();\n\tlibusb_exit(NULL);\n}\nvoid applog(int prio, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvprintf(fmt, ap);\n\tputs(\"\");\n\tva_end(ap);\n}\n#endif\n"
        },
        {
          "name": "lowl-ftdi.h",
          "type": "blob",
          "size": 1.7548828125,
          "content": "#ifndef BFG_LOWL_FTDI_H\n#define BFG_LOWL_FTDI_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include <libusb.h>\n\n#include \"lowlevel.h\"\n\nenum ft232r_reset_purge {\n\tFTDI_PURGE_RX   = 1,\n\tFTDI_PURGE_TX   = 2,\n\tFTDI_PURGE_BOTH = 3,\n};\n\nstruct ft232r_device_handle;\n\nextern struct ft232r_device_handle *ft232r_open(const struct lowlevel_device_info *);\nextern struct ft232r_device_handle *ft232h_open_mpsse(const struct lowlevel_device_info *);\nextern void ft232r_close(struct ft232r_device_handle *);\nextern bool ft232r_purge_buffers(struct ft232r_device_handle *, enum ft232r_reset_purge);\nextern bool ft232r_set_bitmode(struct ft232r_device_handle *, uint8_t mask, uint8_t mode);\nextern ssize_t ft232r_flush(struct ft232r_device_handle *);\nextern ssize_t ft232r_write(struct ft232r_device_handle *, const void *data, size_t count);\nextern ssize_t ft232r_write_all(struct ft232r_device_handle *, const void *data, size_t count);\nextern ssize_t ft232r_read(struct ft232r_device_handle *, void *buf, size_t count);\nextern ssize_t ft232r_read_all(struct ft232r_device_handle *, void *data, size_t count);\nextern bool ft232r_get_pins(struct ft232r_device_handle *, uint8_t *pins);\nextern bool ft232r_set_cbus_bits(struct ft232r_device_handle *dev, bool sc, bool cs);\nextern bool ft232r_get_cbus_bits(struct ft232r_device_handle *dev, bool *out_sio0, bool *out_sio1);\nextern bool ft232h_mpsse_set_axbus(struct ft232r_device_handle *, uint8_t value, uint8_t directions, bool adbus);\n#define ft232h_mpsse_set_acbus(ftdi, val, dir)  ft232h_mpsse_set_axbus(ftdi, val, dir, false)\n#define ft232h_mpsse_set_adbus(ftdi, val, dir)  ft232h_mpsse_set_axbus(ftdi, val, dir, true)\nextern ssize_t ft232h_mpsse_readwrite_all(struct ft232r_device_handle *, void *read_data, const void *write_data, size_t count);\n\n#endif\n"
        },
        {
          "name": "lowl-hid.c",
          "type": "blob",
          "size": 4.9873046875,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifndef WIN32\n#include <dlfcn.h>\ntypedef void *dlh_t;\n#else\n#include <windows.h>\n#define dlopen(lib, flags) LoadLibrary(lib)\n#define dlsym(h, sym)  ((void*)GetProcAddress(h, sym))\n#define dlerror()  \"unknown\"\n#define dlclose(h)  FreeLibrary(h)\ntypedef HMODULE dlh_t;\n#endif\n\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <hidapi.h>\n#include <utlist.h>\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"miner.h\"\n\nstruct hid_device_info HID_API_EXPORT *(*dlsym_hid_enumerate)(unsigned short, unsigned short);\nvoid HID_API_EXPORT (*dlsym_hid_free_enumeration)(struct hid_device_info *);\nhid_device * HID_API_EXPORT (*dlsym_hid_open_path)(const char *);\nvoid HID_API_EXPORT (*dlsym_hid_close)(hid_device *);\nint HID_API_EXPORT (*dlsym_hid_read)(hid_device *, unsigned char *, size_t);\nint HID_API_EXPORT (*dlsym_hid_write)(hid_device *, const unsigned char *, size_t);\n\n#define LOAD_SYM(sym)  do { \\\n\tif (!(dlsym_ ## sym = dlsym(dlh, #sym))) {  \\\n\t\tapplog(LOG_DEBUG, \"%s: Failed to load %s in %s\", __func__, #sym, dlname);  \\\n\t\tgoto fail;  \\\n\t}  \\\n} while(0)\n\nstatic bool hidapi_libusb;\nstatic struct hid_device_info *_probe_hid_enum;\n\nstatic\nbool hidapi_try_lib(const char * const dlname)\n{\n\tstruct hid_device_info *hid_enum;\n\tdlh_t dlh;\n\t\n\tdlh = dlopen(dlname, RTLD_NOW);\n\tif (!dlh)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Couldn't load %s: %s\", __func__, dlname, dlerror());\n\t\treturn false;\n\t}\n\t\n\tLOAD_SYM(hid_enumerate);\n\tLOAD_SYM(hid_free_enumeration);\n\t\n\thid_enum = dlsym_hid_enumerate(0, 0);\n\tif (!hid_enum)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Loaded %s, but no devices enumerated; trying other libraries\", __func__, dlname);\n\t\tgoto fail;\n\t}\n\t_probe_hid_enum = hid_enum;\n\t\n\tLOAD_SYM(hid_open_path);\n\tLOAD_SYM(hid_close);\n\tLOAD_SYM(hid_read);\n\tLOAD_SYM(hid_write);\n\t\n\tif (strstr(dlname, \"libusb\"))\n\t\thidapi_libusb = true;\n\t\n\tapplog(LOG_DEBUG, \"%s: Successfully loaded %s\", __func__, dlname);\n\t\n\treturn true;\n\nfail:\n\tdlclose(dlh);\n\treturn false;\n}\n\n// #defines hid_* calls, so must be after library loader\n#include \"lowl-hid.h\"\n\nstatic\nbool hidapi_load_library()\n{\n\tif (dlsym_hid_write)\n\t\treturn true;\n\t\n\tconst char **p;\n\tchar dlname[23] = \"libhidapi\";\n\tconst char *dltry[] = {\n\t\t\"\",\n\t\t\"-0\",\n\t\t\"-hidraw\",\n\t\t\"-libusb\",\n\t\tNULL\n\t};\n\tfor (p = &dltry[0]; *p; ++p)\n\t{\n\t\tsprintf(&dlname[9], \"%s.%s\", *p,\n#ifdef WIN32\n\t\t        \"dll\"\n#elif defined(__APPLE__)\n\t\t        //Mach-O uses dylibs for shared libraries\n\t\t        //http://www.finkproject.org/doc/porting/porting.en.html#shared\n\t\t        \"dylib\"\n#else\n\t\t        \"so\"\n#endif\n\t\t);\n\t\tif (hidapi_try_lib(dlname))\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nstatic\nchar *wcs2str_dup(wchar_t *ws)\n{\n\tif (!(ws && ws[0]))\n\t\treturn NULL;\n\t\n\tchar *rv;\n\tint clen, i;\n\t\n\tclen = wcslen(ws);\n\t++clen;\n\trv = malloc(clen);\n\tfor (i = 0; i < clen; ++i)\n\t\trv[i] = ws[i];\n\t\n\treturn rv;\n}\n\nstatic\nstruct lowlevel_device_info *hid_devinfo_scan()\n{\n\tif (!hidapi_load_library())\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Failed to load any hidapi library\", __func__);\n\t\treturn NULL;\n\t}\n\t\n\tstruct hid_device_info *hid_enum, *hid_item;\n\tstruct lowlevel_device_info *info, *devinfo_list = NULL;\n\t\n\tif (_probe_hid_enum)\n\t{\n\t\thid_enum = _probe_hid_enum;\n\t\t_probe_hid_enum = NULL;\n\t}\n\telse\n\t\thid_enum = hid_enumerate(0, 0);\n\tif (!hid_enum)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: No HID devices found\", __func__);\n\t\treturn NULL;\n\t}\n\t\n\tLL_FOREACH(hid_enum, hid_item)\n\t{\n\t\tinfo = malloc(sizeof(struct lowlevel_device_info));\n\t\tchar *devid;\n\t\tconst char * const hidpath = hid_item->path;\n\t\tif (hidapi_libusb\n\t\t  && strlen(hidpath) == 12\n\t\t  && hidpath[0] == '0'\n\t\t  && hidpath[1] == '0'\n\t\t  && isxdigit(hidpath[2])\n\t\t  && isxdigit(hidpath[3])\n\t\t  && hidpath[4] == ':'\n\t\t  && hidpath[5] == '0'\n\t\t  && hidpath[6] == '0'\n\t\t  && isxdigit(hidpath[7])\n\t\t  && isxdigit(hidpath[8])\n\t\t  && hidpath[9] == ':')\n\t\t{\n\t\t\tunsigned char usbbus, usbaddr;\n\t\t\thex2bin(&usbbus , &hidpath[2], 1);\n\t\t\thex2bin(&usbaddr, &hidpath[7], 1);\n\t\t\tdevid = bfg_make_devid_usb(usbbus, usbaddr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevid = malloc(4 + strlen(hid_item->path) + 1);\n\t\t\tsprintf(devid, \"hid:%s\", hid_item->path);\n\t\t}\n\t\t*info = (struct lowlevel_device_info){\n\t\t\t.lowl = &lowl_hid,\n\t\t\t.path = strdup(hid_item->path),\n\t\t\t.devid = devid,\n\t\t\t.vid = hid_item->vendor_id,\n\t\t\t.pid = hid_item->product_id,\n\t\t\t.manufacturer = wcs2str_dup(hid_item->manufacturer_string),\n\t\t\t.product = wcs2str_dup(hid_item->product_string),\n\t\t\t.serial  = wcs2str_dup(hid_item->serial_number),\n\t\t};\n\t\tLL_PREPEND(devinfo_list, info);\n\n\t\tapplog(LOG_DEBUG, \"%s: Found \\\"%s\\\" serial \\\"%s\\\"\",\n\t\t       __func__, info->product, info->serial);\n\t}\n\t\n\thid_free_enumeration(hid_enum);\n\t\n\treturn devinfo_list;\n}\n\nstruct lowlevel_driver lowl_hid = {\n\t.dname = \"hid\",\n\t.devinfo_scan = hid_devinfo_scan,\n};\n"
        },
        {
          "name": "lowl-hid.h",
          "type": "blob",
          "size": 0.890625,
          "content": "#ifndef BFG_LOWL_HID_H\n#define BFG_LOWL_HID_H\n\n#include <hidapi.h>\n\n#ifdef WIN32\n#define HID_API_EXPORT __declspec(dllexport)\n#else\n#define HID_API_EXPORT /* */\n#endif\nextern struct hid_device_info HID_API_EXPORT *(*dlsym_hid_enumerate)(unsigned short, unsigned short);\nextern void HID_API_EXPORT (*dlsym_hid_free_enumeration)(struct hid_device_info *);\nextern hid_device * HID_API_EXPORT (*dlsym_hid_open_path)(const char *);\nextern void HID_API_EXPORT (*dlsym_hid_close)(hid_device *);\nextern int HID_API_EXPORT (*dlsym_hid_read)(hid_device *, unsigned char *, size_t);\nextern int HID_API_EXPORT (*dlsym_hid_write)(hid_device *, const unsigned char *, size_t);\n\n#define hid_enumerate dlsym_hid_enumerate\n#define hid_free_enumeration dlsym_hid_free_enumeration\n#define hid_open_path dlsym_hid_open_path\n#define hid_close dlsym_hid_close\n#define hid_read dlsym_hid_read\n#define hid_write dlsym_hid_write\n\n#endif\n"
        },
        {
          "name": "lowl-mswin.c",
          "type": "blob",
          "size": 2.8154296875,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <malloc.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <objbase.h>\n#include <rpc.h>\n#include <setupapi.h>\n#include <utlist.h>\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-mswin.h\"\n#include \"util.h\"\n\nstatic\nstruct lowlevel_device_info *mswin_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_list = NULL, *info;\n\t\n\tHDEVINFO devinfo = SetupDiGetClassDevs(NULL, NULL, NULL, (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));\n\tif (INVALID_HANDLE_VALUE == devinfo)\n\t\tapplogfailinfor(NULL, LOG_DEBUG, \"SetupDiGetClassDevs\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\tSP_DEVINFO_DATA devinfodata = {\n\t\t.cbSize = sizeof(devinfodata),\n\t};\n\tSP_DEVICE_INTERFACE_DATA devifacedata = {\n\t\t.cbSize = sizeof(devifacedata),\n\t};\n\tfor (int i = 0; SetupDiEnumDeviceInfo(devinfo, i, &devinfodata); ++i)\n\t{\n\t\t// FIXME: Figure out a way to get all GUIDs here\n\t\tif (!SetupDiEnumDeviceInterfaces(devinfo, &devinfodata, &WIN_GUID_DEVINTERFACE_MonarchKMDF, 0, &devifacedata))\n\t\t{\n\t\t\tapplogfailinfo(LOG_DEBUG, \"SetupDiEnumDeviceInterfaces\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\t\tcontinue;\n\t\t}\n\t\tDWORD detailsz;\n\t\tif (!(!SetupDiGetDeviceInterfaceDetail(devinfo, &devifacedata, NULL, 0, &detailsz, NULL) && GetLastError() == ERROR_INSUFFICIENT_BUFFER))\n\t\t{\n\t\t\tapplogfailinfo(LOG_ERR, \"SetupDiEnumDeviceInterfaceDetail (1)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\t\tcontinue;\n\t\t}\n\t\tPSP_DEVICE_INTERFACE_DETAIL_DATA detail = alloca(detailsz);\n\t\tdetail->cbSize = sizeof(*detail);\n\t\tif (!SetupDiGetDeviceInterfaceDetail(devinfo, &devifacedata, detail, detailsz, &detailsz, NULL))\n\t\t{\n\t\t\tapplogfailinfo(LOG_ERR, \"SetupDiEnumDeviceInterfaceDetail (2)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tchar *devid = malloc(6 + strlen(detail->DevicePath) + 1);\n\t\tsprintf(devid, \"mswin:%s\", detail->DevicePath);\n\t\t\n\t\tinfo = malloc(sizeof(struct lowlevel_device_info));\n\t\t*info = (struct lowlevel_device_info){\n\t\t\t.lowl = &lowl_mswin,\n\t\t\t.devid = devid,\n\t\t\t.path = strdup(detail->DevicePath),\n\t\t\t.lowl_data = (void *)&WIN_GUID_DEVINTERFACE_MonarchKMDF,\n\t\t};\n\t\tLL_PREPEND(devinfo_list, info);\n\t}\n\t\n\tSetupDiDestroyDeviceInfoList(devinfo);\n\t\n\treturn devinfo_list;\n}\n\nbool lowl_mswin_match_guid(const struct lowlevel_device_info * const info, const GUID * const guid)\n{\n\tif (info->lowl != &lowl_mswin)\n\t\treturn false;\n\treturn IsEqualGUID(info->lowl_data, guid);\n}\n\nstruct lowlevel_driver lowl_mswin = {\n\t.dname = \"mswin\",\n\t.devinfo_scan = mswin_devinfo_scan,\n};\n"
        },
        {
          "name": "lowl-mswin.h",
          "type": "blob",
          "size": 0.314453125,
          "content": "#ifndef BFG_LOWL_MSWIN_H\n#define BFG_LOWL_MSWIN_H\n\n#include <stdbool.h>\n\n#include <rpc.h>\n\nstatic const GUID WIN_GUID_DEVINTERFACE_MonarchKMDF = { 0xdcdb8d6f, 0x98b0, 0x4d1c, {0xa2, 0x77, 0x71, 0x17, 0x69, 0x70, 0x54, 0x31} };\n\nextern bool lowl_mswin_match_guid(const struct lowlevel_device_info *, const GUID *);\n\n#endif\n"
        },
        {
          "name": "lowl-pci.c",
          "type": "blob",
          "size": 13.431640625,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#if defined(USE_VFIO) || defined(USE_UIO)\n#\tdefine USE_LOWL_PCI_MMAP\n#\tdefine USE_LOWL_PCI_DATA_WRAPPERS\n#endif\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include <utlist.h>\n\n#ifdef USE_VFIO\n#include <linux/vfio.h>\n#include <sys/ioctl.h>\n#endif\n\n#ifdef USE_LOWL_PCI_MMAP\n#include <sys/mman.h>\n#endif\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-pci.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nstatic\nstruct lowlevel_device_info *pci_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_list = NULL, *info;\n\tstruct dirent *de;\n\tchar filename[0x100] = \"/sys/bus/pci/devices\", buf[0x10];\n\tDIR * const D = opendir(filename);\n\tif (!D)\n\t\treturn 0;\n\tchar * const p = &filename[strlen(filename)], *devid;\n\tconst size_t psz = sizeof(filename) - (p - filename);\n\tuint32_t vid, pid;\n\tsize_t d_name_len;\n\twhile ( (de = readdir(D)) )\n\t{\n\t\td_name_len = strlen(de->d_name);\n\t\tsnprintf(p, psz, \"/%s/vendor\", de->d_name);\n\t\tif (!bfg_slurp_file(buf, sizeof(buf), filename))\n\t\t\tcontinue;\n\t\tvid = strtoll(buf, NULL, 0);\n\t\tsnprintf(p, psz, \"/%s/device\", de->d_name);\n\t\tif (!bfg_slurp_file(buf, sizeof(buf), filename))\n\t\t\tcontinue;\n\t\tpid = strtoll(buf, NULL, 0);\n\t\tdevid = malloc(4 + d_name_len + 1);\n\t\tsprintf(devid, \"pci:%s\", de->d_name);\n\t\t\n\t\tinfo = malloc(sizeof(struct lowlevel_device_info));\n\t\t*info = (struct lowlevel_device_info){\n\t\t\t.lowl = &lowl_pci,\n\t\t\t.devid = devid,\n\t\t\t.path = strdup(de->d_name),\n\t\t\t.vid = vid,\n\t\t\t.pid = pid,\n\t\t};\n\t\t\n\t\tLL_PREPEND(devinfo_list, info);\n\t}\n\tclosedir(D);\n\treturn devinfo_list;\n}\n\nstruct lowl_pci_interface {\n\tstruct lowl_pci_handle *(*open)(const char *path, const struct _lowl_pci_config *);\n\tvoid (*close)(struct lowl_pci_handle *);\n\tconst uint32_t *(*get_words)(struct lowl_pci_handle *, void *buf, size_t words, int bar, off_t);\n\tconst void *(*get_data)(struct lowl_pci_handle *, void *buf, size_t, int bar, off_t);\n\tbool (*set_words)(struct lowl_pci_handle *, const uint32_t *, size_t, int bar, off_t);\n\tbool (*set_data)(struct lowl_pci_handle *, const void *, size_t, int bar, off_t);\n};\n\nstruct lowl_pci_handle {\n\tconst char *path;\n\tconst struct lowl_pci_interface *lpi;\n#ifdef USE_VFIO\n\tint fd[3];\n\toff_t baroff[6];\n#endif\n#ifdef USE_LOWL_PCI_MMAP\n\tvolatile uint32_t *bar[6];\n\tsize_t barsz[6];\n#endif\n};\n\n#ifdef USE_LOWL_PCI_MMAP\nstatic\nvoid lowl_pci_close_mmap(struct lowl_pci_handle * const lph)\n{\n\tfor (int i = 0; i < 6; ++i)\n\t\tif (lph->bar[i])\n\t\t\tmunmap((void*)lph->bar[i], lph->barsz[i]);\n\tfree(lph);\n}\n\nstatic\nconst uint32_t *lowl_pci_get_words_mmap(struct lowl_pci_handle * const lph, void * const buf, const size_t words, const int bar, const off_t offset)\n{\n\tvolatile uint32_t *src = &lph->bar[bar][offset];\n\tuint32_t *dest = buf;\n\tfor (int i = 0; i < words; ++i)\n\t\t*(dest++) = *(src++);\n\treturn buf;\n}\n\nstatic\nbool lowl_pci_set_words_mmap(struct lowl_pci_handle * const lph, const uint32_t *buf, const size_t words, const int bar, const off_t offset)\n{\n\tvolatile uint32_t *dest = &lph->bar[bar][offset];\n\tfor (int i = 0; i < words; ++i)\n\t\t*(dest++) = *(buf++);\n\treturn true;\n}\n\nstatic\nint _file_mode_to_mmap_prot(const int mode)\n{\n\tswitch (mode)\n\t{\n\t\tcase O_RDONLY:\n\t\t\treturn PROT_READ;\n\t\tcase O_WRONLY:\n\t\t\treturn PROT_WRITE;\n\t\tcase O_RDWR:\n\t\t\treturn PROT_READ | PROT_WRITE;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}\n#endif\n\n#ifdef USE_LOWL_PCI_DATA_WRAPPERS\nstatic\nconst void *lowl_pci_get_data_from_words(struct lowl_pci_handle * const lph, void * const bufp, const size_t sz, const int bar, const off_t offset)\n{\n\tuint8_t * const buf = bufp;\n\tconst off_t offset32 = offset / 4;\n\tconst off_t offset8  = offset % 4;\n\tconst size_t words = (sz + offset8 + 3) / 4;\n\tconst uint32_t * const wdata = lowl_pci_get_words(lph, buf, words, bar, offset32);\n\tswap32tobe((uint32_t *)buf, wdata, words);\n\treturn &buf[offset8];\n}\n\nstatic\nbool lowl_pci_set_data_in_words(struct lowl_pci_handle * const lph, const void * const bufp, size_t sz, const int bar, const off_t offset)\n{\n\tconst uint8_t *buf = bufp;\n\tconst off_t offset32 = offset / 4;\n\toff_t offset8  = offset % 4;\n\tconst size_t words = (sz + offset8 + 3) / 4;\n\tuint32_t wdata[words], *wdp = wdata;\n\tif (offset8)\n\t{\n\t\tconst uint32_t * const p = lowl_pci_get_words(lph, wdata, 1, bar, offset32);\n\t\tif (unlikely(!p))\n\t\t\treturn false;\n\t\twdata[0] = *p >> (32 - (8 * offset8));\n\t}\n\tfor ( ; sz; --sz)\n\t{\n\t\t*wdp = (*wdp << 8) | *(buf++);\n\t\tif (++offset8 == 4)\n\t\t{\n\t\t\toffset8 = 0;\n\t\t\t++wdp;\n\t\t}\n\t}\n\tif (offset8)\n\t{\n\t\tuint32_t u;\n\t\tconst uint32_t * const p = lowl_pci_get_words(lph, &u, 1, bar, offset32 + words - 1);\n\t\tif (unlikely(!p))\n\t\t\treturn false;\n\t\tconst int n = 32 - (8 * offset8);\n\t\twdp[0] <<= n;\n\t\twdp[0] |= *p & ((1 << n) - 1);\n\t}\n\treturn lowl_pci_set_words(lph, wdata, words, bar, offset32);\n}\n#endif\n\n#ifdef USE_UIO\nstatic const struct lowl_pci_interface lpi_uio;\n\nstatic\nvoid *_uio_mmap_bar(const char * const path, const int bar, const size_t sz, const int prot)\n{\n\tchar buf[0x100];\n\tsnprintf(buf, sizeof(buf), \"/sys/bus/pci/devices/%s/resource%d\", path, bar);\n\tconst int fd = open(buf, O_RDWR);\n\tif (fd == -1)\n\t\treturn MAP_FAILED;\n\tvoid * const rv = mmap(NULL, sz, prot, MAP_SHARED, fd, 0);\n\tclose(fd);\n\treturn rv;\n}\n\nstruct lowl_pci_handle *lowl_pci_open_uio(const char * const path, const struct _lowl_pci_config * const barcfgs)\n{\n\tstruct lowl_pci_handle * const lph = malloc(sizeof(*lph));\n\t*lph = (struct lowl_pci_handle){\n\t\t.path = path,\n\t\t.lpi = &lpi_uio,\n\t};\n\tfor (const struct _lowl_pci_config *barcfg = barcfgs; barcfg->bar != -1; ++barcfg)\n\t{\n\t\tconst int barno = barcfg->bar;\n\t\tconst int prot = _file_mode_to_mmap_prot(barcfg->mode);\n\t\tif (unlikely(prot == -1))\n\t\t\tgoto err;\n\t\tlph->bar[barno] = _uio_mmap_bar(path, barno, barcfg->sz, prot);\n\t\tlph->barsz[barno] = barcfg->sz;\n\t\tif (lph->bar[barno] == MAP_FAILED)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"mmap %s bar %d failed\", path, barno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn lph;\n\nerr:\n\tfor (int i = 0; i < 6; ++i)\n\t\tif (lph->bar[i])\n\t\t\tmunmap((void*)lph->bar[i], lph->barsz[i]);\n\tfree(lph);\n\treturn NULL;\n}\n\nstatic const struct lowl_pci_interface lpi_uio = {\n\t.open = lowl_pci_open_uio,\n\t.close = lowl_pci_close_mmap,\n\t.get_words = lowl_pci_get_words_mmap,\n\t.get_data  = lowl_pci_get_data_from_words,\n\t.set_words = lowl_pci_set_words_mmap,\n\t.set_data  = lowl_pci_set_data_in_words,\n};\n#endif\n\n#ifdef USE_VFIO\nstatic const struct lowl_pci_interface lpi_vfio;\n\n#define _VFIO_ACCESS_BAR_PROBLEM ((void*)&lpi_vfio)\nstatic\nvoid *_vfio_access_bar(const int device, const int bar, const size_t sz, const int prot, off_t *out_offset)\n{\n\tstruct vfio_region_info region_info = { .argsz = sizeof(region_info) };\n\tswitch (bar)\n\t{\n#define _BARCASE(n)  \\\n\t\tcase n:  \\\n\t\t\tregion_info.index = VFIO_PCI_BAR ## n ## _REGION_INDEX;  \\\n\t\t\tbreak;\n\t\t_BARCASE(0) _BARCASE(1) _BARCASE(2) _BARCASE(3)\n\t\t_BARCASE(4) _BARCASE(5)\n#undef _BARCASE\n\t\tdefault:\n\t\t\treturn _VFIO_ACCESS_BAR_PROBLEM;\n\t}\n\tif (ioctl(device, VFIO_DEVICE_GET_REGION_INFO, &region_info))\n\t\tapplogr(_VFIO_ACCESS_BAR_PROBLEM, LOG_ERR, \"%s: VFIO_DEVICE_GET_REGION_INFO failed\", __func__);\n\tif ((prot & PROT_READ ) && !(region_info.flags & VFIO_REGION_INFO_FLAG_READ ))\n\t\tapplogr(_VFIO_ACCESS_BAR_PROBLEM, LOG_ERR, \"%s: region does not support %s\", __func__, \"read\");\n\tif ((prot & PROT_WRITE) && !(region_info.flags & VFIO_REGION_INFO_FLAG_WRITE))\n\t\tapplogr(_VFIO_ACCESS_BAR_PROBLEM, LOG_ERR, \"%s: region does not support %s\", __func__, \"write\");\n\tif (region_info.size < sz)\n\t\tapplogr(_VFIO_ACCESS_BAR_PROBLEM, LOG_ERR, \"%s: region is only %lu bytes (needed %lu)\",\n\t\t        __func__, (unsigned long)region_info.size, (unsigned long)sz);\n\t\n\t*out_offset = region_info.offset;\n\tif (!(region_info.flags & VFIO_REGION_INFO_FLAG_MMAP))\n\t\treturn MAP_FAILED;\n\t\n\treturn mmap(NULL, sz, prot, MAP_SHARED, device, region_info.offset);\n}\n\nstruct lowl_pci_handle *lowl_pci_open_vfio(const char * const path, const struct _lowl_pci_config * const barcfgs)\n{\n\tchar buf[0x100], buf2[0x100];\n\tssize_t ss;\n\tchar *p;\n\tint group = -1, device = -1;\n\toff_t offset;\n\t\n\tstruct lowl_pci_handle * const lph = malloc(sizeof(*lph));\n\t*lph = (struct lowl_pci_handle){\n\t\t.path = path,\n\t\t.lpi = &lpi_vfio,\n\t};\n\tconst char * const vfio_path = \"/dev/vfio/vfio\";\n\tconst int container = open(vfio_path, O_RDWR);\n\tif (container == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to open %s\", __func__, vfio_path);\n\t\tgoto err;\n\t}\n\t{\n\t\tconst int vfio_ver = ioctl(container, VFIO_GET_API_VERSION);\n\t\tif (vfio_ver != VFIO_API_VERSION)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: vfio API version mismatch (have=%d expect=%d)\",\n\t\t\t       __func__, vfio_ver, VFIO_API_VERSION);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tsnprintf(buf, sizeof(buf), \"/sys/bus/pci/devices/%s/iommu_group\", path);\n\tss = readlink(buf, buf2, sizeof(buf2) - 1);\n\tif (ss == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to read %s\", __func__, buf);\n\t\tgoto err;\n\t}\n\tbuf2[ss] = '\\0';\n\tp = memrchr(buf2, '/', ss - 1);\n\tif (p)\n\t\t++p;\n\telse\n\t\tp = buf2;\n\tsnprintf(buf, sizeof(buf), \"/dev/vfio/%s\", p);\n\tgroup = open(buf, O_RDWR);\n\tif (group == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to open %s\", __func__, buf);\n\t\tgoto err;\n\t}\n\tstruct vfio_group_status group_status = { .argsz = sizeof(group_status) };\n\tif (ioctl(group, VFIO_GROUP_GET_STATUS, &group_status))\n\t{\n\t\tapplog(LOG_ERR, \"%s: VFIO_GROUP_GET_STATUS failed on iommu group %s\", __func__, p);\n\t\tgoto err;\n\t}\n\tif (!(group_status.flags & VFIO_GROUP_FLAGS_VIABLE))\n\t{\n\t\tapplog(LOG_ERR, \"%s: iommu group %s is not viable\", __func__, p);\n\t\tgoto err;\n\t}\n\tif (ioctl(group, VFIO_GROUP_SET_CONTAINER, &container))\n\t{\n\t\tapplog(LOG_ERR, \"%s: VFIO_GROUP_SET_CONTAINER failed on iommu group %s\", __func__, p);\n\t\tgoto err;\n\t}\n\tif (ioctl(container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to set type1 iommu on group %s\", __func__, p);\n\t\tgoto err;\n\t}\n\tdevice = ioctl(group, VFIO_GROUP_GET_DEVICE_FD, path);\n\tif (device == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to get device fd for %s in group %s\", __func__, path, p);\n\t\tgoto err;\n\t}\n\tfor (const struct _lowl_pci_config *barcfg = barcfgs; barcfg->bar != -1; ++barcfg)\n\t{\n\t\tconst int barno = barcfg->bar;\n\t\tconst int prot = _file_mode_to_mmap_prot(barcfg->mode);\n\t\tif (unlikely(prot == -1))\n\t\t\tgoto err;\n\t\tlph->bar[barno] = _vfio_access_bar(device, barno, barcfg->sz, prot, &offset);\n\t\tlph->barsz[barno] = barcfg->sz;\n\t\tif (lph->bar[barno] == _VFIO_ACCESS_BAR_PROBLEM)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Accessing %s bar %d failed\", __func__, path, barno);\n\t\t\tgoto err;\n\t\t}\n\t\telse\n\t\tif (lph->bar[barno] == MAP_FAILED)\n\t\t\tlph->bar[barno] = NULL;\n\t\tlph->baroff[barno] = offset;\n\t}\n\tlph->fd[0] = device;\n\tlph->fd[1] = group;\n\tlph->fd[2] = container;\n\treturn lph;\n\nerr:\n\tfor (int i = 0; i < 6; ++i)\n\t\tif (lph->bar[i])\n\t\t\tmunmap((void*)lph->bar[i], lph->barsz[i]);\n\tif (device != -1)\n\t\tclose(device);\n\tif (group != -1)\n\t\tclose(group);\n\tif (container != -1)\n\t\tclose(container);\n\tfree(lph);\n\treturn NULL;\n}\n\nstatic\nvoid lowl_pci_close_vfio(struct lowl_pci_handle * const lph)\n{\n\tclose(lph->fd[0]);\n\tclose(lph->fd[1]);\n\tclose(lph->fd[2]);\n\tlowl_pci_close_mmap(lph);\n}\n\nstatic\nconst uint32_t *lowl_pci_get_words_vfio(struct lowl_pci_handle * const lph, void * const buf, const size_t words, const int bar, const off_t offset)\n{\n\tif (lph->bar[bar])\n\t\treturn lowl_pci_get_words_mmap(lph, buf, words, bar, offset);\n\t\n\tconst size_t sz = 4 * words;\n\tif (unlikely(sz != pread(lph->fd[0], buf, sz, (4 * offset) + lph->baroff[bar])))\n\t\treturn NULL;\n\treturn buf;\n}\n\nstatic\nbool lowl_pci_set_words_vfio(struct lowl_pci_handle * const lph, const uint32_t *buf, const size_t words, const int bar, const off_t offset)\n{\n\tif (lph->bar[bar])\n\t\treturn lowl_pci_set_words_mmap(lph, buf, words, bar, offset);\n\t\n\tconst size_t sz = 4 * words;\n\tif (unlikely(sz != pwrite(lph->fd[0], buf, sz, (4 * offset) + lph->baroff[bar])))\n\t\treturn false;\n\treturn true;\n}\n\nstatic const struct lowl_pci_interface lpi_vfio = {\n\t.open = lowl_pci_open_vfio,\n\t.close = lowl_pci_close_vfio,\n\t.get_words = lowl_pci_get_words_vfio,\n\t.get_data  = lowl_pci_get_data_from_words,\n\t.set_words = lowl_pci_set_words_vfio,\n\t.set_data  = lowl_pci_set_data_in_words,\n};\n#endif\n\nstruct lowl_pci_handle *lowl_pci_open(const char * const path, const struct _lowl_pci_config * const barcfgs)\n{\n\treturn\n#ifdef USE_VFIO\n\t\tlpi_vfio.open(path, barcfgs) ?:\n#endif\n#ifdef USE_UIO\n\t\tlpi_uio.open(path, barcfgs) ?:\n#endif\n\t\tfalse;\n}\n\nconst uint32_t *lowl_pci_get_words(struct lowl_pci_handle * const lph, void * const buf, const size_t words, const int bar, const off_t offset)\n{\n\treturn lph->lpi->get_words(lph, buf, words, bar, offset);\n}\n\nconst void *lowl_pci_get_data(struct lowl_pci_handle * const lph, void * const buf, const size_t sz, const int bar, const off_t offset)\n{\n\treturn lph->lpi->get_data(lph, buf, sz, bar, offset);\n}\n\nbool lowl_pci_set_words(struct lowl_pci_handle * const lph, const uint32_t * const buf, const size_t words, const int bar, const off_t offset)\n{\n\treturn lph->lpi->set_words(lph, buf, words, bar, offset);\n}\n\nbool lowl_pci_set_data(struct lowl_pci_handle * const lph, const void * const buf, const size_t sz, const int bar, const off_t offset)\n{\n\treturn lph->lpi->set_data(lph, buf, sz, bar, offset);\n}\n\nvoid lowl_pci_close(struct lowl_pci_handle * const lph)\n{\n\treturn lph->lpi->close(lph);\n}\n\nstruct lowlevel_driver lowl_pci = {\n\t.dname = \"pci\",\n\t.devinfo_scan = pci_devinfo_scan,\n\t.exclude_from_all = true,\n};\n"
        },
        {
          "name": "lowl-pci.h",
          "type": "blob",
          "size": 2.1728515625,
          "content": "#ifndef BFG_LOWL_PCI_H\n#define BFG_LOWL_PCI_H\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstruct lowl_pci_handle;\n\nstruct _lowl_pci_config {\n\tint bar;\n\tsize_t sz;\n\tint mode;\n};\nextern struct lowl_pci_handle *lowl_pci_open(const char *, const struct _lowl_pci_config *);\n#define LP_BARINFO(...)  (struct _lowl_pci_config[]){__VA_ARGS__ { .bar = -1 }}\n#define LP_BAR(barno, size, mode)  {barno, size, mode}\nextern void lowl_pci_close(struct lowl_pci_handle *);\n\n// Don't assume buf is used in any specific way! Memory returned may be mmap'd (and thus change after call)\nextern const uint32_t *lowl_pci_get_words(struct lowl_pci_handle *, void *buf, size_t words, int bar, off_t);\nextern bool lowl_pci_set_words(struct lowl_pci_handle *, const uint32_t *, size_t, int bar, off_t);\n// buf passed to lowl_pci_get_data must have at least LOWL_PCI_GET_DATA_PADDING bytes more than size to read\n#define LOWL_PCI_GET_DATA_PADDING 6\nextern const void *lowl_pci_get_data(struct lowl_pci_handle *, void *buf, size_t, int bar, off_t);\nextern bool lowl_pci_set_data(struct lowl_pci_handle *, const void *, size_t, int bar, off_t);\n\nstatic inline\nuint32_t lowl_pci_get_word(struct lowl_pci_handle * const lph, const int bar, const off_t offset)\n{\n\tuint32_t buf[1];\n\tconst uint32_t * const p = lowl_pci_get_words(lph, buf, 1, bar, offset);\n\tif (!p)\n\t\treturn 0;\n\treturn *p;\n}\n\nstatic inline\nbool lowl_pci_set_word(struct lowl_pci_handle * const lph, const int bar, const off_t offset, const uint32_t val)\n{\n\treturn lowl_pci_set_words(lph, &val, 1, bar, offset);\n}\n\nstatic inline\nbool lowl_pci_read_words(struct lowl_pci_handle * const lph, void * const buf, const size_t words, const int bar, const off_t offset)\n{\n\tconst void * const p = lowl_pci_get_words(lph, buf, words, bar, offset);\n\tif (!p)\n\t\treturn false;\n\tif (buf != p)\n\t\tmemmove(buf, p, words * 4);\n\treturn true;\n}\n\nstatic inline\nbool lowl_pci_read_data(struct lowl_pci_handle * const lph, void * const buf, const size_t sz, const int bar, const off_t offset)\n{\n\tconst void * const p = lowl_pci_get_data(lph, buf, sz, bar, offset);\n\tif (!p)\n\t\treturn false;\n\tif (buf != p)\n\t\tmemmove(buf, p, sz);\n\treturn true;\n}\n\n#endif\n"
        },
        {
          "name": "lowl-spi.c",
          "type": "blob",
          "size": 8.765625,
          "content": "/*\n * Copyright 2013 bitfury\n * Copyright 2013-2014 Luke Dashjr\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#ifdef HAVE_LINUX_SPI_SPIDEV_H\n#define HAVE_LINUX_SPI\n#endif\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n\n#ifdef HAVE_LINUX_SPI\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <linux/spi/spidev.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#endif\n\n#include \"logging.h\"\n#include \"lowl-spi.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#ifdef HAVE_LINUX_SPI\nbool sys_spi_txrx(struct spi_port *port);\nstatic volatile unsigned *gpio;\n#endif\n\nstruct spi_port *sys_spi;\n\nvoid spi_init(void)\n{\n#ifdef HAVE_LINUX_SPI\n\tint fd;\n\tfd = open(\"/dev/mem\",O_RDWR|O_SYNC);\n\tif (fd < 0)\n\t{\n\t\tperror(\"/dev/mem trouble\");\n\t\treturn;\n\t}\n\tgpio = mmap(0,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0x20200000);\n\tif (gpio == MAP_FAILED)\n\t{\n\t\tperror(\"gpio mmap trouble\");\n\t\treturn;\n\t}\n\tclose(fd);\n\t\n\tsys_spi = malloc(sizeof(*sys_spi));\n\t*sys_spi = (struct spi_port){\n\t\t.txrx = sys_spi_txrx,\n\t};\n#endif\n}\n\n#ifdef HAVE_LINUX_SPI\n\nint spi_open(struct spi_port * const spi, const char * const devpath)\n{\n\tconst int fd = open(devpath, O_RDWR);\n\tif (fd < 0)\n\t\treturn fd;\n\t\n\tif (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &spi->speed) < 0\n\t || ioctl(fd, SPI_IOC_WR_MODE, &spi->mode) < 0\n\t || ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &spi->bits) < 0)\n\t{\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t\n\tspi->fd = fd;\n\treturn fd;\n}\n\n#define INP_GPIO(g) *(gpio+((g)/10)) &= ~(7<<(((g)%10)*3))\n#define OUT_GPIO(g) *(gpio+((g)/10)) |=  (1<<(((g)%10)*3))\n#define SET_GPIO_ALT(g,a) *(gpio+(((g)/10))) |= (((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))\n\n#define GPIO_SET *(gpio+7)  // sets   bits which are 1 ignores bits which are 0\n#define GPIO_CLR *(gpio+10) // clears bits which are 1 ignores bits which are 0\n#define GPIO_LEV *(gpio+13)\n\nvoid bfg_gpio_setpin_output(const unsigned pin)\n{\n\tINP_GPIO(pin);\n\tOUT_GPIO(pin);\n}\n\nvoid bfg_gpio_set_high(const unsigned mask)\n{\n\tGPIO_SET = mask;\n}\n\nvoid bfg_gpio_set_low(const unsigned mask)\n{\n\tGPIO_CLR = mask;\n}\n\nunsigned bfg_gpio_get()\n{\n\treturn GPIO_LEV;\n}\n\n// Bit-banging reset, to reset more chips in chain - toggle for longer period... Each 3 reset cycles reset first chip in chain\nstatic\nint spi_reset(int a)\n{\n\tint i,j;\n\tint len = 8;\n\tINP_GPIO(10); OUT_GPIO(10);\n\tINP_GPIO(11); OUT_GPIO(11);\n\tGPIO_SET = 1 << 11; // Set SCK\n\tfor (i = 0; i < 32; i++) { // On standard settings this unoptimized code produces 1 Mhz freq.\n\t\tGPIO_SET = 1 << 10;\n\t\tfor (j = 0; j < len; j++) {\n\t\t\ta *= a;\n\t\t}\n\t\tGPIO_CLR = 1 << 10;\n\t\tfor (j = 0; j < len; j++) {\n\t\t\ta *= a;\n\t\t}\n\t}\n\tGPIO_CLR = 1 << 10;\n\tGPIO_CLR = 1 << 11;\n\tINP_GPIO(10);\n\tSET_GPIO_ALT(10,0);\n\tINP_GPIO(11);\n\tSET_GPIO_ALT(11,0);\n\tINP_GPIO(9);\n\tSET_GPIO_ALT(9,0);\n\n\treturn a;\n}\n\n#define BAILOUT(s)  do{  \\\n\tperror(s);  \\\n\tclose(fd);  \\\n\treturn false;  \\\n}while(0)\n\nbool sys_spi_txrx(struct spi_port *port)\n{\n\tconst void *wrbuf = spi_gettxbuf(port);\n\tvoid *rdbuf = spi_getrxbuf(port);\n\tsize_t bufsz = spi_getbufsz(port);\n\tint fd;\n\tint mode, bits, speed, rv, i, j;\n\tstruct spi_ioc_transfer tr[16];\n\n\tmemset(&tr,0,sizeof(tr));\n\tmode = 0; bits = 8; speed = 4000000;\n\tif (port->speed)\n\t\tspeed = port->speed;\n\n\tspi_reset(1234);\n\tfd = open(\"/dev/spidev0.0\", O_RDWR);\n\tif (fd < 0) {\n\t\tperror(\"Unable to open SPI device\");\n\t\treturn false;\n\t}\n\tif (ioctl(fd, SPI_IOC_WR_MODE, &mode) < 0)\n\t\tBAILOUT(\"Unable to set WR MODE\");\n\tif (ioctl(fd, SPI_IOC_RD_MODE, &mode) < 0)\n\t\tBAILOUT(\"Unable to set RD MODE\");\n\tif (ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits) < 0)\n\t\tBAILOUT(\"Unable to set WR_BITS_PER_WORD\");\n\tif (ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits) < 0)\n\t\tBAILOUT(\"Unable to set RD_BITS_PER_WORD\");\n\tif (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) < 0)\n\t\tBAILOUT(\"Unable to set WR_MAX_SPEED_HZ\");\n\tif (ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed) < 0)\n\t\tBAILOUT(\"Unable to set RD_MAX_SPEED_HZ\");\n\n\trv = 0;\n\twhile (bufsz >= 4096) {\n                tr[rv].tx_buf = (uintptr_t) wrbuf;\n                tr[rv].rx_buf = (uintptr_t) rdbuf;\n                tr[rv].len = 4096;\n                tr[rv].delay_usecs = 1;\n                tr[rv].speed_hz = speed;\n                tr[rv].bits_per_word = bits;\n                bufsz -= 4096;\n                wrbuf += 4096; rdbuf += 4096; rv ++;\n        }\n        if (bufsz > 0) {\n                tr[rv].tx_buf = (uintptr_t) wrbuf;\n                tr[rv].rx_buf = (uintptr_t) rdbuf;\n                tr[rv].len = (unsigned)bufsz;\n                tr[rv].delay_usecs = 1;\n                tr[rv].speed_hz = speed;\n                tr[rv].bits_per_word = bits;\n                rv ++;\n        }\n\n        i = rv;\n        for (j = 0; j < i; j++) {\n                rv = (int)ioctl(fd, SPI_IOC_MESSAGE(1), (intptr_t)&tr[j]);\n\t\tif (rv < 0)\n\t\t\tBAILOUT(\"WTF!\");\n        }\n\n\tclose(fd);\n\tspi_reset(4321);\n\n\treturn true;\n}\n\nbool linux_spi_txrx(struct spi_port * const spi)\n{\n\tconst void * const wrbuf = spi_gettxbuf(spi);\n\tvoid * const rdbuf = spi_getrxbuf(spi);\n\tconst size_t bufsz = spi_getbufsz(spi);\n\tconst int fd = spi->fd;\n\tstruct spi_ioc_transfer xf = {\n\t\t.tx_buf = (uintptr_t) wrbuf,\n\t\t.rx_buf = (uintptr_t) rdbuf,\n\t\t.len = bufsz,\n\t\t.delay_usecs = spi->delay,\n\t\t.speed_hz = spi->speed,\n\t\t.bits_per_word = spi->bits,\n\t};\n\treturn (ioctl(fd, SPI_IOC_MESSAGE(1), &xf) > 0);\n}\n\nbool linux_spi_txrx2(struct spi_port * const spi)\n{\n\tconst size_t bufsz = spi_getbufsz(spi);\n\t\n\tif (opt_dev_protocol)\n\t{\n\t\tconst void * const txbuf = spi_gettxbuf(spi);\n\t\tchar hex[(bufsz * 2) + 1];\n\t\tbin2hex(hex, txbuf, bufsz);\n\t\tapplog(LOG_DEBUG, \"%s: %cX %s\", spi->repr, 'T', hex);\n\t}\n\tbool rv = linux_spi_txrx(spi);\n\tif (opt_dev_protocol)\n\t{\n\t\tif (likely(rv))\n\t\t{\n\t\t\tvoid * const rxbuf = spi_getrxbuf(spi);\n\t\t\tchar hex[(bufsz * 2) + 1];\n\t\t\tbin2hex(hex, rxbuf, bufsz);\n\t\t\tapplog(LOG_DEBUG, \"%s: %cX %s\", spi->repr, 'R', hex);\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"%s: SPI ERROR\", spi->repr);\n\t}\n\treturn rv;\n}\n\n#endif\n\nstatic\nvoid *spi_emit_buf_reverse(struct spi_port *port, const void *p, size_t sz)\n{\n\tconst unsigned char *str = p;\n\tvoid * const rv = &port->spibuf_rx[port->spibufsz];\n\tif (port->spibufsz + sz >= SPIMAXSZ)\n\t\treturn NULL;\n\tfor (size_t i = 0; i < sz; ++i)\n\t{\n\t\t// Reverse bit order in each byte!\n\t\tport->spibuf[port->spibufsz++] = bitflip8(str[i]);\n\t}\n\treturn rv;\n}\n\nvoid spi_emit_buf(struct spi_port * const port, const void * const str, const size_t sz)\n{\n\tif (port->spibufsz + sz >= SPIMAXSZ)\n\t\treturn;\n\tmemcpy(&port->spibuf[port->spibufsz], str, sz);\n\tport->spibufsz += sz;\n}\n\n/* TODO: in production, emit just bit-sequences! Eliminate padding to byte! */\nvoid spi_emit_break(struct spi_port *port)\n{\n\tspi_emit_buf(port, \"\\x4\", 1);\n}\n\nvoid spi_emit_fsync(struct spi_port *port)\n{\n\tspi_emit_buf(port, \"\\x6\", 1);\n}\n\nvoid spi_emit_fasync(struct spi_port *port, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tspi_emit_buf(port, \"\\x5\", 1);\n\t}\n}\n\nvoid spi_emit_nop(struct spi_port *port, int n) {\n\tint i;\n\tfor (i = 0; i < n; ++i) {\n\t\tspi_emit_buf(port, \"\\x0\", 1);\n\t}\n}\n\nvoid *spi_emit_data(struct spi_port *port, uint16_t addr, const void *buf, size_t len)\n{\n\tunsigned char otmp[3];\n\tif (len < 4 || len > 128)\n\t\treturn NULL;  /* This cannot be programmed in single frame! */\n\tlen /= 4; /* Strip */\n\totmp[0] = (len - 1) | 0xE0;\n\totmp[1] = (addr >> 8)&0xFF; otmp[2] = addr & 0xFF;\n\tspi_emit_buf(port, otmp, 3);\n\treturn spi_emit_buf_reverse(port, buf, len*4);\n}\n\n#ifdef USE_BFSB\nvoid spi_bfsb_select_bank(int bank)\n{\n\tstatic int last_bank = -2;\n\tif (bank == last_bank)\n\t\treturn;\n\tconst int banks[4]={18,23,24,25}; // GPIO connected to OE of level shifters\n\tint i;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif (i == bank)\n\t\t\tcontinue;\n\t\t\n\t\tINP_GPIO(banks[i]);\n\t\tOUT_GPIO(banks[i]);\n\t\tGPIO_CLR = 1 << banks[i];\n\t}\n\t\n\tif (bank != -1)\n\t{\n\t\tOUT_GPIO(banks[bank]);\n\t\tGPIO_SET = 1 << banks[bank];\n\t}\n\t\n\tlast_bank = bank;\n}\n#endif\n"
        },
        {
          "name": "lowl-spi.h",
          "type": "blob",
          "size": 2.5107421875,
          "content": "#ifndef BFG_LOWL_SPI_H\n#define BFG_LOWL_SPI_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n\n#define SPIMAXSZ (256*1024)\n\n/* Initialize SPI using this function */\nvoid spi_init(void);\n\n#ifdef HAVE_LINUX_SPI_SPIDEV_H\nextern void bfg_gpio_setpin_output(unsigned pin);\nextern void bfg_gpio_set_high(unsigned mask);\nextern void bfg_gpio_set_low(unsigned mask);\nextern unsigned bfg_gpio_get();\n#endif\n\n/* Do not allocate spi_port on the stack! OS X, at least, has a 512 KB default stack size for secondary threads\n   This includes struct assignments which get allocated on the stack before being assigned to */\nstruct spi_port {\n\t/* TX-RX single frame */\n\tbool (*txrx)(struct spi_port *port);\n\t\n\tchar spibuf[SPIMAXSZ], spibuf_rx[SPIMAXSZ];\n\tsize_t spibufsz;\n\t\n\tvoid *userp;\n\tstruct cgpu_info *cgpu;\n\tconst char *repr;\n\tint logprio;\n\t\n\tint fd;\n\tuint32_t speed;\n\tuint16_t delay;\n\tuint8_t mode;\n\tuint8_t bits;\n\tint chipselect;\n\tint *chipselect_current;\n};\n\nextern struct spi_port *sys_spi;\n\n\n/* SPI BUFFER OPS */\nstatic inline\nvoid spi_clear_buf(struct spi_port *port)\n{\n\tport->spibufsz = 0;\n}\n\nstatic inline\nvoid *spi_getrxbuf(struct spi_port *port)\n{\n\treturn port->spibuf_rx;\n}\n\nstatic inline\nvoid *spi_gettxbuf(struct spi_port *port)\n{\n\treturn port->spibuf;\n}\n\nstatic inline\nsize_t spi_getbufsz(struct spi_port *port)\n{\n\treturn port->spibufsz;\n}\n\nextern void spi_emit_buf(struct spi_port *, const void *, size_t);\n\nextern void spi_emit_break(struct spi_port *port); /* BREAK CONNECTIONS AFTER RESET */\nextern void spi_emit_fsync(struct spi_port *port); /* FEED-THROUGH TO NEXT CHIP SYNCHRONOUSLY (WITH FLIP-FLOP) */\nextern void spi_emit_fasync(struct spi_port *port, int n); /* FEED-THROUGH TO NEXT CHIP ASYNCHRONOUSLY (WITHOUT FLIP-FLOP INTERMEDIATE) */\nextern void spi_emit_nop(struct spi_port *port, int n);\n\n/* TRANSMIT PROGRAMMING SEQUENCE (AND ALSO READ-BACK) */\n/* addr is the destination address in bits (16-bit - 0 to 0xFFFF valid ones)\n   buf is buffer to be transmitted, it will go at position spi_getbufsz()+3\n   len is length in _bytes_, should be 4 to 128 and be multiple of 4, as smallest\n   transmission quantum is 32 bits */\nextern void *spi_emit_data(struct spi_port *port, uint16_t addr, const void *buf, size_t len);\n\nstatic inline\nbool spi_txrx(struct spi_port *port)\n{\n\treturn port->txrx(port);\n}\n\nextern int spi_open(struct spi_port *, const char *);\nextern bool sys_spi_txrx(struct spi_port *);\nextern bool linux_spi_txrx(struct spi_port *);\nextern bool linux_spi_txrx2(struct spi_port *);\n\nvoid spi_bfsb_select_bank(int bank);\n\n#endif\n"
        },
        {
          "name": "lowl-usb.c",
          "type": "blob",
          "size": 7.7451171875,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <libusb.h>\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-usb.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\nstatic\nchar *lowl_libusb_dup_string(libusb_device_handle * const handle, const uint8_t idx, const char * const idxname, const char * const fname, const char * const devid)\n{\n\tif (!idx)\n\t\treturn NULL;\n\tunsigned char buf[0x100];\n\tconst int n = libusb_get_string_descriptor_ascii(handle, idx, buf, sizeof(buf)-1);\n\tif (unlikely(n < 0)) {\n\t\t// This could be LOG_ERR, but it's annoyingly common :/\n\t\tapplog(LOG_DEBUG, \"%s: Error getting USB string %d (%s) from %s: %s\",\n\t\t       fname, idx, idxname, devid, bfg_strerror(n, BST_LIBUSB));\n\t\treturn NULL;\n\t}\n\tif (n == 0)\n\t\treturn NULL;\n\tbuf[n] = '\\0';\n\treturn strdup((void*)buf);\n}\n\n\nstatic\nvoid usb_devinfo_free(struct lowlevel_device_info * const info)\n{\n\tlibusb_device * const dev = info->lowl_data;\n\tif (dev)\n\t\tlibusb_unref_device(dev);\n}\n\nstatic\nstruct lowlevel_device_info *usb_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_list = NULL;\n\tssize_t count, i;\n\tlibusb_device **list;\n\tstruct libusb_device_descriptor desc;\n\tlibusb_device_handle *handle;\n\tstruct lowlevel_device_info *info;\n\tint err;\n\n\tif (unlikely(!have_libusb))\n\t\treturn NULL;\n\t\n\tcount = libusb_get_device_list(NULL, &list);\n\tif (unlikely(count < 0)) {\n\t\tapplog(LOG_ERR, \"%s: Error getting USB device list: %s\",\n\t\t       __func__, bfg_strerror(count, BST_LIBUSB));\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\terr = libusb_get_device_descriptor(list[i], &desc);\n\t\tif (unlikely(err)) {\n\t\t\tapplog(LOG_ERR, \"%s: Error getting device descriptor: %s\",\n\t\t\t       __func__, bfg_strerror(err, BST_LIBUSB));\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo = malloc(sizeof(struct lowlevel_device_info));\n\t\t*info = (struct lowlevel_device_info){\n\t\t\t.lowl = &lowl_usb,\n\t\t\t.devid = bfg_make_devid_libusb(list[i]),\n\t\t\t.lowl_data = libusb_ref_device(list[i]),\n\t\t\t.vid = desc.idVendor,\n\t\t\t.pid = desc.idProduct,\n\t\t};\n\t\t\n\t\terr = libusb_open(list[i], &handle);\n\t\tif (unlikely(err))\n\t\t\tapplog(LOG_DEBUG, \"%s: Error opening device %s: %s\",\n\t\t\t       __func__, info->devid, bfg_strerror(err, BST_LIBUSB));\n\t\telse\n\t\t{\n\t\t\tinfo->manufacturer = lowl_libusb_dup_string(handle, desc.iManufacturer, \"iManufacturer\", __func__, info->devid);\n\t\t\tinfo->product = lowl_libusb_dup_string(handle, desc.iProduct, \"iProduct\", __func__, info->devid);\n\t\t\tinfo->serial = lowl_libusb_dup_string(handle, desc.iSerialNumber, \"iSerialNumber\", __func__, info->devid);\n\t\t\tlibusb_close(handle);\n\t\t}\n\n\t\tLL_PREPEND(devinfo_list, info);\n\t}\n\n\tlibusb_free_device_list(list, 1);\n\t\n\treturn devinfo_list;\n}\n\nbool lowl_usb_attach_kernel_driver(const struct lowlevel_device_info * const info)\n{\n\tlibusb_device * const dev = info->lowl_data;\n\tlibusb_device_handle *devh;\n\tbool rv = false;\n\t\n\tif (libusb_open(dev, &devh))\n\t\treturn false;\n\t\n\tif (libusb_kernel_driver_active(devh, 0) == 0)\n\t\tif (!libusb_attach_kernel_driver(devh, 0))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Reattaching kernel driver for %s\", info->devid);\n\t\t\trv = true;\n\t\t}\n\t\n\tlibusb_close(devh);\n\t\n\treturn rv;\n}\n\nstruct device_drv *bfg_claim_usb(struct device_drv * const api, const bool verbose, const uint8_t usbbus, const uint8_t usbaddr)\n{\n\tchar * const devpath = bfg_make_devid_usb(usbbus, usbaddr);\n\tstruct device_drv * const rv = bfg_claim_any(api, verbose ? \"\" : NULL, devpath);\n\tfree(devpath);\n\treturn rv;\n}\n\n#ifdef HAVE_LIBUSB\nvoid cgpu_copy_libusb_strings(struct cgpu_info *cgpu, libusb_device *usb)\n{\n\tunsigned char buf[0x20];\n\tlibusb_device_handle *h;\n\tstruct libusb_device_descriptor desc;\n\t\n\tif (LIBUSB_SUCCESS != libusb_open(usb, &h))\n\t\treturn;\n\tif (libusb_get_device_descriptor(usb, &desc))\n\t{\n\t\tlibusb_close(h);\n\t\treturn;\n\t}\n\t\n\tif ((!cgpu->dev_manufacturer) && libusb_get_string_descriptor_ascii(h, desc.iManufacturer, buf, sizeof(buf)) >= 0)\n\t\tcgpu->dev_manufacturer = strdup((void *)buf);\n\tif ((!cgpu->dev_product) && libusb_get_string_descriptor_ascii(h, desc.iProduct, buf, sizeof(buf)) >= 0)\n\t\tcgpu->dev_product = strdup((void *)buf);\n\tif ((!cgpu->dev_serial) && libusb_get_string_descriptor_ascii(h, desc.iSerialNumber, buf, sizeof(buf)) >= 0)\n\t\tcgpu->dev_serial = strdup((void *)buf);\n\t\n\tlibusb_close(h);\n}\n#endif\n\nstruct lowl_usb_endpoint {\n\tstruct libusb_device_handle *devh;\n\t\n\tunsigned char endpoint_r;\n\tint packetsz_r;\n\tbytes_t _buf_r;\n\tunsigned timeout_ms_r;\n\t\n\tunsigned char endpoint_w;\n\tint packetsz_w;\n\tunsigned timeout_ms_w;\n};\n\nstruct lowl_usb_endpoint *usb_open_ep(struct libusb_device_handle * const devh, const uint8_t epid, const int pktsz)\n{\n\tstruct lowl_usb_endpoint * const ep = malloc(sizeof(*ep));\n\tep->devh = devh;\n\tif (epid & 0x80)\n\t{\n\t\t// Read endpoint\n\t\tep->endpoint_r = epid;\n\t\tep->packetsz_r = pktsz;\n\t\tbytes_init(&ep->_buf_r);\n\t}\n\telse\n\t{\n\t\t// Write endpoint\n\t\tep->endpoint_w = epid;\n\t\tep->packetsz_w = epid;\n\t\tep->packetsz_r = -1;\n\t}\n\treturn ep;\n};\n\nstruct lowl_usb_endpoint *usb_open_ep_pair(struct libusb_device_handle * const devh, const uint8_t epid_r, const int pktsz_r, const uint8_t epid_w, const int pktsz_w)\n{\n\tstruct lowl_usb_endpoint * const ep = malloc(sizeof(*ep));\n\t*ep = (struct lowl_usb_endpoint){\n\t\t.devh = devh,\n\t\t.endpoint_r = epid_r,\n\t\t.packetsz_r = pktsz_r,\n\t\t._buf_r = BYTES_INIT,\n\t\t.endpoint_w = epid_w,\n\t\t.packetsz_w = pktsz_w,\n\t};\n\treturn ep;\n}\n\nvoid usb_ep_set_timeouts_ms(struct lowl_usb_endpoint * const ep, const unsigned timeout_ms_r, const unsigned timeout_ms_w)\n{\n\tep->timeout_ms_r = timeout_ms_r;\n\tep->timeout_ms_w = timeout_ms_w;\n}\n\nssize_t usb_read(struct lowl_usb_endpoint * const ep, void * const data, size_t datasz)\n{\n\tunsigned timeout;\n\tsize_t xfer;\n\tif ( (xfer = bytes_len(&ep->_buf_r)) < datasz)\n\t{\n\t\tbytes_extend_buf(&ep->_buf_r, datasz + ep->packetsz_r - 1);\n\t\tunsigned char *p = &bytes_buf(&ep->_buf_r)[xfer];\n\t\tint pxfer;\n\t\tint rem = datasz - xfer, rsz;\n\t\ttimeout = xfer ? 0 : ep->timeout_ms_r;\n\t\twhile (rem > 0)\n\t\t{\n\t\t\trsz = (rem / ep->packetsz_r) * ep->packetsz_r;\n\t\t\tif (rsz < rem)\n\t\t\t\trsz += ep->packetsz_r;\n\t\t\tswitch (libusb_bulk_transfer(ep->devh, ep->endpoint_r, p, rsz, &pxfer, timeout))\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase LIBUSB_ERROR_TIMEOUT:\n\t\t\t\t\tif (!pxfer)\n\t\t\t\t\t\t// Behaviour is like tcsetattr-style timeout\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tp += pxfer;\n\t\t\t\t\trem -= pxfer;\n\t\t\t\t\t// NOTE: Need to maintain _buf_r length so data is saved in case of error\n\t\t\t\t\txfer += pxfer;\n\t\t\t\t\tbytes_resize(&ep->_buf_r, xfer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LIBUSB_ERROR_PIPE:\n\t\t\t\tcase LIBUSB_ERROR_NO_DEVICE:\n\t\t\t\t\terrno = EPIPE;\n\t\t\t\t\treturn -1;\n\t\t\t\tdefault:\n\t\t\t\t\terrno = EIO;\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ttimeout = 0;\n\t\t}\n\t}\n\tmemcpy(data, bytes_buf(&ep->_buf_r), datasz);\n\tbytes_shift(&ep->_buf_r, datasz);\n\treturn datasz;\n}\n\nssize_t usb_write(struct lowl_usb_endpoint * const ep, const void * const data, size_t datasz)\n{\n\tunsigned timeout = ep->timeout_ms_w;\n\tunsigned char *p = (void*)data;\n\tsize_t rem = datasz;\n\tint pxfer;\n\twhile (rem > 0)\n\t{\n\t\tswitch (libusb_bulk_transfer(ep->devh, ep->endpoint_w, p, rem, &pxfer, timeout))\n\t\t{\n\t\t\tcase 0:\n\t\t\tcase LIBUSB_ERROR_TIMEOUT:\n\t\t\t\tp += pxfer;\n\t\t\t\trem -= pxfer;\n\t\t\t\tbreak;\n\t\t\tcase LIBUSB_ERROR_PIPE:\n\t\t\tcase LIBUSB_ERROR_NO_DEVICE:\n\t\t\t\terrno = EPIPE;\n\t\t\t\treturn (datasz - rem) ?: -1;\n\t\t\tdefault:\n\t\t\t\terrno = EIO;\n\t\t\t\treturn (datasz - rem) ?: -1;\n\t\t}\n\t\ttimeout = 0;\n\t}\n\terrno = 0;\n\treturn datasz;\n}\n\nvoid usb_close_ep(struct lowl_usb_endpoint * const ep)\n{\n\tif (ep->packetsz_r != -1)\n\t\tbytes_free(&ep->_buf_r);\n\tfree(ep);\n}\n\nstruct lowlevel_driver lowl_usb = {\n\t.dname = \"usb\",\n\t.devinfo_scan = usb_devinfo_scan,\n\t.devinfo_free = usb_devinfo_free,\n};\n"
        },
        {
          "name": "lowl-usb.h",
          "type": "blob",
          "size": 1.126953125,
          "content": "#ifndef BFG_LOWL_USB_H\n#define BFG_LOWL_USB_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include <libusb.h>\n\nextern struct device_drv *bfg_claim_usb(struct device_drv * const, const bool verbose, const uint8_t usbbus, const uint8_t usbaddr);\n#define bfg_make_devid_libusb(dev)  bfg_make_devid_usb(libusb_get_bus_number(dev), libusb_get_device_address(dev))\n#define bfg_claim_libusb(api, verbose, dev)  bfg_claim_usb(api, verbose, libusb_get_bus_number(dev), libusb_get_device_address(dev))\n\nextern void cgpu_copy_libusb_strings(struct cgpu_info *, libusb_device *);\n\nstruct lowl_usb_endpoint;\n\nextern struct lowl_usb_endpoint *usb_open_ep(struct libusb_device_handle *, uint8_t epid, int pktsz);\nextern struct lowl_usb_endpoint *usb_open_ep_pair(struct libusb_device_handle *, uint8_t epid_r, int pktsz_r, uint8_t epid_w, int pktsz_w);\nextern void usb_ep_set_timeouts_ms(struct lowl_usb_endpoint *, unsigned timeout_ms_r, unsigned timeout_ms_w);\nextern ssize_t usb_read(struct lowl_usb_endpoint *, void *, size_t);\nextern ssize_t usb_write(struct lowl_usb_endpoint *, const void *, size_t);\nextern void usb_close_ep(struct lowl_usb_endpoint *);\n\n#endif\n"
        },
        {
          "name": "lowl-vcom.c",
          "type": "blob",
          "size": 37.25390625,
          "content": "/*\n * Copyright 2012-2015 Luke Dashjr\n * Copyright 2013 Con Kolivas\n * Copyright 2012 Andrew Smith\n * Copyright 2013 Xiangfu\n * Copyright 2014 Nate Woolls\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <string.h>\n\n#ifdef HAVE_SYS_FILE_H\n#include <sys/file.h>\n#endif\n\n#ifdef HAVE_LIBUSB\n#include <libusb.h>\n#endif\n\n#include \"miner.h\"\n\n#ifndef WIN32\n#include <errno.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n#else  /* WIN32 */\n#include <windows.h>\n\n#ifdef HAVE_WIN_DDKUSB\n#include <setupapi.h>\n#include <usbioctl.h>\n#include <usbiodef.h>\n#endif\n\n#include <io.h>\n\n#include <utlist.h>\n\n#define dlsym (void*)GetProcAddress\n#define dlclose FreeLibrary\n\ntypedef unsigned long FT_STATUS;\ntypedef PVOID FT_HANDLE;\n__stdcall FT_STATUS (*FT_ListDevices)(PVOID pArg1, PVOID pArg2, DWORD Flags);\n__stdcall FT_STATUS (*FT_Open)(int idx, FT_HANDLE*);\n__stdcall FT_STATUS (*FT_GetComPortNumber)(FT_HANDLE, LPLONG lplComPortNumber);\n__stdcall FT_STATUS (*FT_Close)(FT_HANDLE);\nconst uint32_t FT_OPEN_BY_SERIAL_NUMBER =     1;\nconst uint32_t FT_OPEN_BY_DESCRIPTION =       2;\nconst uint32_t FT_LIST_ALL         = 0x20000000;\nconst uint32_t FT_LIST_BY_INDEX    = 0x40000000;\nconst uint32_t FT_LIST_NUMBER_ONLY = 0x80000000;\nenum {\n\tFT_OK,\n};\n#endif  /* WIN32 */\n\n#ifdef HAVE_LIBUDEV\n#include <libudev.h>\n#include <sys/ioctl.h>\n#endif\n\n#ifdef __APPLE__\n#include <IOKit/IOKitLib.h>\n#include <IOKit/IOCFPlugIn.h>\n#include <IOKit/usb/IOUSBLib.h>\n#endif\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"miner.h\"\n#include \"util.h\"\n\n#include \"lowl-vcom.h\"\n\nstruct lowlevel_driver lowl_vcom;\n\nstruct detectone_meta_info_t detectone_meta_info;\n\nvoid clear_detectone_meta_info(void)\n{\n\tdetectone_meta_info = (struct detectone_meta_info_t){\n\t\t.manufacturer = NULL,\n\t};\n}\n\n#define _vcom_unique_id(devpath)  devpath_to_devid(devpath)\n\nstruct lowlevel_device_info *_vcom_devinfo_findorcreate(struct lowlevel_device_info ** const devinfo_list, const char * const devpath)\n{\n\tstruct lowlevel_device_info *devinfo;\n\tchar * const devid = _vcom_unique_id(devpath);\n\tif (!devid)\n\t\treturn NULL;\n\tHASH_FIND_STR(*devinfo_list, devid, devinfo);\n\tif (!devinfo)\n\t{\n\t\tdevinfo = malloc(sizeof(*devinfo));\n\t\t*devinfo = (struct lowlevel_device_info){\n\t\t\t.lowl = &lowl_vcom,\n\t\t\t.path = strdup(devpath),\n\t\t\t.devid = devid,\n\t\t};\n\t\tHASH_ADD_KEYPTR(hh, *devinfo_list, devinfo->devid, strlen(devid), devinfo);\n\t}\n\telse\n\t\tfree(devid);\n\treturn devinfo;\n}\n\n#ifdef HAVE_LIBUDEV\nstatic\nvoid _decode_udev_enc(char *o, const char *s)\n{\n\twhile(s[0])\n\t{\n\t\tif (s[0] == '\\\\' && s[1] == 'x' && s[2] && s[3])\n\t\t{\n\t\t\thex2bin((void*)(o++), &s[2], 1);\n\t\t\ts += 4;\n\t\t}\n\t\telse\n\t\t\t(o++)[0] = (s++)[0];\n\t}\n\to[0] = '\\0';\n}\n\nstatic\nchar *_decode_udev_enc_dup(const char *s)\n{\n\tif (!s)\n\t\treturn NULL;\n\t\n\tchar *o = malloc(strlen(s) + 1);\n\tif (!o)\n\t{\n\t\tapplog(LOG_ERR, \"Failed to malloc in _decode_udev_enc_dup\");\n\t\treturn NULL;\n\t}\n\t\n\t_decode_udev_enc(o, s);\n\treturn o;\n}\n\nstatic\nvoid _vcom_devinfo_scan_udev(struct lowlevel_device_info ** const devinfo_list)\n{\n\tstruct udev *udev = udev_new();\n\tstruct udev_enumerate *enumerate = udev_enumerate_new(udev);\n\tstruct udev_list_entry *list_entry;\n\tstruct lowlevel_device_info *devinfo;\n\n\tudev_enumerate_add_match_subsystem(enumerate, \"tty\");\n\tudev_enumerate_add_match_property(enumerate, \"ID_SERIAL\", \"*\");\n\tudev_enumerate_scan_devices(enumerate);\n\tudev_list_entry_foreach(list_entry, udev_enumerate_get_list_entry(enumerate)) {\n\t\tstruct udev_device *device = udev_device_new_from_syspath(\n\t\t\tudev_enumerate_get_udev(enumerate),\n\t\t\tudev_list_entry_get_name(list_entry)\n\t\t);\n\t\tif (!device)\n\t\t\tcontinue;\n\n\t\tconst char * const devpath = udev_device_get_devnode(device);\n\t\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, devpath);\n\t\t\n\t\tBFGINIT(devinfo->manufacturer, _decode_udev_enc_dup(udev_device_get_property_value(device, \"ID_VENDOR_ENC\")));\n\t\tBFGINIT(devinfo->product, _decode_udev_enc_dup(udev_device_get_property_value(device, \"ID_MODEL_ENC\")));\n\t\tBFGINIT(devinfo->serial, _decode_udev_enc_dup(udev_device_get_property_value(device, \"ID_SERIAL_SHORT\")));\n\t\t\n\t\tudev_device_unref(device);\n\t}\n\tudev_enumerate_unref(enumerate);\n\tudev_unref(udev);\n}\n#endif\n\n#ifdef __APPLE__\nstatic\nconst char * _iokit_get_string_descriptor(IOUSBDeviceInterface300 ** const usb_device, const uint8_t string_idx)\n{\n\tUInt16 buf[64];\n\tIOUSBDevRequest dev_req;\n\n\tdev_req.bmRequestType = USBmakebmRequestType(kUSBIn, kUSBStandard, kUSBDevice);\n\tdev_req.bRequest = kUSBRqGetDescriptor;\n\tdev_req.wValue = (kUSBStringDesc << 8) | string_idx;\n\tdev_req.wIndex = 0x409; //English\n\tdev_req.wLength = sizeof(buf);\n\tdev_req.pData = buf;\n\n\tkern_return_t kret = (*usb_device)->DeviceRequest(usb_device, &dev_req);\n\tif (kret != 0)\n\t\treturn NULL;\n\n\tsize_t str_len = (dev_req.wLenDone / 2) - 1;\n\n\treturn ucs2_to_utf8_dup(&buf[1], str_len);\n}\n\nstatic\nIOUSBDeviceInterface300 ** _iokit_get_service_device(const io_service_t usb_svc)\n{\n\tIOCFPlugInInterface ** plugin;\n\tSInt32 score;\n\tIOUSBDeviceInterface300 ** usb_device;\n\n\tIOCreatePlugInInterfaceForService(usb_svc, kIOUSBDeviceUserClientTypeID,\n\t\t\t\t\t\t\t\t\t  kIOCFPlugInInterfaceID, &plugin, &score);\n\t(*plugin)->QueryInterface(plugin,\n\t\t\t\t\t\t\t  CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID300),\n\t\t\t\t\t\t\t  (LPVOID)&usb_device);\n\t(*plugin)->Release(plugin);\n\n\treturn usb_device;\n}\n\nstatic\nbool _iokit_get_device_path(const io_service_t usb_svc, char * const buf, const size_t buf_len)\n{\n\tCFTypeRef dev_path_cf = IORegistryEntrySearchCFProperty(usb_svc, kIOServicePlane, CFSTR(\"IOCalloutDevice\"),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkCFAllocatorDefault, kIORegistryIterateRecursively);\n\tif (dev_path_cf)\n\t{\n\t\tCFStringGetCString(dev_path_cf, buf, buf_len, kCFStringEncodingASCII);\n\t\tCFRelease(dev_path_cf);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic\nvoid _vcom_devinfo_scan_iokit_service(struct lowlevel_device_info ** const devinfo_list, const io_service_t usb_svc)\n{\n\tIOUSBDeviceInterface300 ** usb_device = _iokit_get_service_device(usb_svc);\n\n\tchar dev_path[PATH_MAX];\n\tif (_iokit_get_device_path(usb_svc, dev_path, PATH_MAX))\n\t{\n\t\tUInt8 manuf_idx;\n\t\tUInt8 prod_idx;\n\t\tUInt8 serialno_idx;\n\n\t\t(*usb_device)->USBGetManufacturerStringIndex(usb_device, &manuf_idx);\n\t\t(*usb_device)->USBGetProductStringIndex(usb_device, &prod_idx);\n\t\t(*usb_device)->USBGetSerialNumberStringIndex(usb_device, &serialno_idx);\n\n\t\tconst char * dev_manuf = _iokit_get_string_descriptor(usb_device, manuf_idx);\n\t\tconst char * dev_product = _iokit_get_string_descriptor(usb_device, prod_idx);\n\t\tconst char * dev_serial = _iokit_get_string_descriptor(usb_device, serialno_idx);\n\n\t\tstruct lowlevel_device_info *devinfo;\n\t\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, dev_path);\n\n\t\tBFGINIT(devinfo->manufacturer, (char *)dev_manuf);\n\t\tBFGINIT(devinfo->product, (char *)dev_product);\n\t\tBFGINIT(devinfo->serial, (char *)dev_serial);\n\t}\n}\n\nstatic\nvoid _vcom_devinfo_scan_iokit(struct lowlevel_device_info ** const devinfo_list)\n{\n\tCFMutableDictionaryRef matching_dict = IOServiceMatching(kIOUSBDeviceClassName);\n\tif (matching_dict == NULL)\n\t\treturn;\n\n\tio_iterator_t iterator;\n\tkern_return_t kret = IOServiceGetMatchingServices(kIOMasterPortDefault, matching_dict, &iterator);\n\tif (kret != KERN_SUCCESS)\n\t\treturn;\n\n\tio_service_t usb_svc;\n\twhile ((usb_svc = IOIteratorNext(iterator)))\n\t{\n\t\t_vcom_devinfo_scan_iokit_service(devinfo_list, usb_svc);\n\n\t\tIOObjectRelease(usb_svc);\n\t}\n\n\tIOObjectRelease(iterator);\n}\n#endif\n\n#ifndef WIN32\nstatic\nvoid _vcom_devinfo_scan_devserial(struct lowlevel_device_info ** const devinfo_list)\n{\n\tDIR *D;\n\tstruct dirent *de;\n\tconst char udevdir[] = \"/dev/serial/by-id\";\n\tchar devpath[sizeof(udevdir) + 1 + NAME_MAX];\n\tchar *devfile = devpath + sizeof(udevdir);\n\tstruct lowlevel_device_info *devinfo;\n\t\n\tD = opendir(udevdir);\n\tif (!D)\n\t\treturn;\n\tmemcpy(devpath, udevdir, sizeof(udevdir) - 1);\n\tdevpath[sizeof(udevdir) - 1] = '/';\n\twhile ( (de = readdir(D)) ) {\n\t\tif (strncmp(de->d_name, \"usb-\", 4))\n\t\t\tcontinue;\n\t\tstrcpy(devfile, de->d_name);\n\t\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, devpath);\n\t\tif (devinfo && !(devinfo->manufacturer || devinfo->product || devinfo->serial))\n\t\t\tdevinfo->product = strdup(devfile);\n\t}\n\tclosedir(D);\n}\n#endif\n\n#ifndef WIN32\nstatic\nchar *_sysfs_do_read(const char *devpath, char *devfile, const char *append)\n{\n\tchar buf[0x40];\n\tFILE *F;\n\t\n\tstrcpy(devfile, append);\n\tF = fopen(devpath, \"r\");\n\tif (F)\n\t{\n\t\tif (fgets(buf, sizeof(buf), F))\n\t\t{\n\t\t\tsize_t L = strlen(buf);\n\t\t\twhile (isCspace(buf[--L]))\n\t\t\t\tbuf[L] = '\\0';\n\t\t}\n\t\telse\n\t\t\tbuf[0] = '\\0';\n\t\tfclose(F);\n\t}\n\telse\n\t\tbuf[0] = '\\0';\n\t\n\treturn buf[0] ? strdup(buf) : NULL;\n}\n\nstatic\nvoid _sysfs_find_tty(char *devpath, char *devfile, struct lowlevel_device_info ** const devinfo_list)\n{\n\tstruct lowlevel_device_info *devinfo;\n\tDIR *DT;\n\tstruct dirent *de;\n\tchar ttybuf[0x10] = \"/dev/\";\n\tchar *mydevfile = strdup(devfile);\n\t\n\tDT = opendir(devpath);\n\tif (!DT)\n\t\tgoto out;\n\t\n\twhile ( (de = readdir(DT)) )\n\t{\n\t\tif (strncmp(de->d_name, \"tty\", 3))\n\t\t\tcontinue;\n\t\tif (!de->d_name[3])\n\t\t{\n\t\t\t// \"tty\" directory: recurse (needed for ttyACM)\n\t\t\tsprintf(devfile, \"%s/tty\", mydevfile);\n\t\t\t_sysfs_find_tty(devpath, devfile, devinfo_list);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(&de->d_name[3], \"USB\", 3) && strncmp(&de->d_name[3], \"ACM\", 3))\n\t\t\tcontinue;\n\t\t\n\t\tstrcpy(&ttybuf[5], de->d_name);\n\t\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, ttybuf);\n\t\tif (!devinfo)\n\t\t\tcontinue;\n\t\tBFGINIT(devinfo->manufacturer, _sysfs_do_read(devpath, devfile, \"/manufacturer\"));\n\t\tBFGINIT(devinfo->product, _sysfs_do_read(devpath, devfile, \"/product\"));\n\t\tBFGINIT(devinfo->serial, _sysfs_do_read(devpath, devfile, \"/serial\"));\n\t}\n\tclosedir(DT);\n\t\nout:\n\tfree(mydevfile);\n}\n\nstatic\nvoid _vcom_devinfo_scan_sysfs(struct lowlevel_device_info ** const devinfo_list)\n{\n\tDIR *D, *DS;\n\tstruct dirent *de;\n\tconst char devroot[] = \"/sys/bus/usb/devices\";\n\tconst size_t devrootlen = sizeof(devroot) - 1;\n\tchar devpath[sizeof(devroot) + (NAME_MAX * 3)];\n\tchar *devfile, *upfile;\n\tsize_t len, len2;\n\t\n\tD = opendir(devroot);\n\tif (!D)\n\t\treturn;\n\tmemcpy(devpath, devroot, devrootlen);\n\tdevpath[devrootlen] = '/';\n\twhile ( (de = readdir(D)) )\n\t{\n\t\tlen = strlen(de->d_name);\n\t\tupfile = &devpath[devrootlen + 1];\n\t\tmemcpy(upfile, de->d_name, len);\n\t\tdevfile = upfile + len;\n\t\t\n\t\tdevfile[0] = '\\0';\n\t\tDS = opendir(devpath);\n\t\tif (!DS)\n\t\t\tcontinue;\n\t\tdevfile[0] = '/';\n\t\t++devfile;\n\t\t\n\t\twhile ( (de = readdir(DS)) )\n\t\t{\n\t\t\tif (strncmp(de->d_name, upfile, len))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tlen2 = strlen(de->d_name);\n\t\t\tmemcpy(devfile, de->d_name, len2 + 1);\n\t\t\t\n\t\t\t_sysfs_find_tty(devpath, devfile, devinfo_list);\n\t\t}\n\t\tclosedir(DS);\n\t}\n\tclosedir(D);\n}\n#endif\n\n#ifdef HAVE_WIN_DDKUSB\n\nstatic const GUID WIN_GUID_DEVINTERFACE_USB_HOST_CONTROLLER = { 0x3ABF6F2D, 0x71C4, 0x462A, {0x8A, 0x92, 0x1E, 0x68, 0x61, 0xE6, 0xAF, 0x27} };\n\nstatic\nchar *windows_usb_get_port_path(HANDLE hubh, const int portno)\n{\n\tsize_t namesz;\n\tULONG rsz;\n\t\n\t{\n\t\tUSB_NODE_CONNECTION_NAME pathinfo = {\n\t\t\t.ConnectionIndex = portno,\n\t\t};\n\t\tif (!(DeviceIoControl(hubh, IOCTL_USB_GET_NODE_CONNECTION_NAME, &pathinfo, sizeof(pathinfo), &pathinfo, sizeof(pathinfo), &rsz, NULL) && rsz >= sizeof(pathinfo)))\n\t\t\tapplogfailinfor(NULL, LOG_ERR, \"ioctl (1)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\tnamesz = pathinfo.ActualLength;\n\t}\n\t\n\tconst size_t bufsz = sizeof(USB_NODE_CONNECTION_NAME) + namesz;\n\tuint8_t buf[bufsz];\n\tUSB_NODE_CONNECTION_NAME *path = (USB_NODE_CONNECTION_NAME *)buf;\n\t*path = (USB_NODE_CONNECTION_NAME){\n\t\t.ConnectionIndex = portno,\n\t};\n\t\n\tif (!(DeviceIoControl(hubh, IOCTL_USB_GET_NODE_CONNECTION_NAME, path, bufsz, path, bufsz, &rsz, NULL) && rsz >= sizeof(*path)))\n\t\tapplogfailinfor(NULL, LOG_ERR, \"ioctl (2)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\treturn ucs2_to_utf8_dup(path->NodeName, path->ActualLength);\n}\n\nstatic\nchar *windows_usb_get_string(HANDLE hubh, const int portno, const uint8_t descid)\n{\n\tif (!descid)\n\t\treturn NULL;\n\t\n\tconst size_t descsz_max = sizeof(USB_STRING_DESCRIPTOR) + MAXIMUM_USB_STRING_LENGTH;\n\tconst size_t reqsz = sizeof(USB_DESCRIPTOR_REQUEST) + descsz_max;\n\tuint8_t buf[reqsz];\n\t\n\tUSB_DESCRIPTOR_REQUEST * const req = (USB_DESCRIPTOR_REQUEST *)buf;\n\tUSB_STRING_DESCRIPTOR * const desc = (USB_STRING_DESCRIPTOR *)&req[1];\n\t*req = (USB_DESCRIPTOR_REQUEST){\n\t\t.ConnectionIndex = portno,\n\t\t.SetupPacket = {\n\t\t\t.wValue = (USB_STRING_DESCRIPTOR_TYPE << 8) | descid,\n\t\t\t.wIndex = 0,\n\t\t\t.wLength = descsz_max,\n\t\t},\n\t};\n\t// Need to explicitly zero the output memory\n\tmemset(desc, '\\0', descsz_max);\n\t\n\tULONG descsz;\n\tif (!DeviceIoControl(hubh, IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION, req, reqsz, req, reqsz, &descsz, NULL))\n\t\tapplogfailinfor(NULL, LOG_DEBUG, \"ioctl\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\tif (descsz < 2 || desc->bDescriptorType != USB_STRING_DESCRIPTOR_TYPE || desc->bLength > descsz - sizeof(USB_DESCRIPTOR_REQUEST) || desc->bLength % 2)\n\t\tapplogfailr(NULL, LOG_ERR, \"sanity check\");\n\t\n\treturn ucs2_to_utf8_dup(desc->bString, desc->bLength);\n}\n\nstatic void _vcom_devinfo_scan_windows__hub(struct lowlevel_device_info **, const char *);\n\nstatic\nvoid _vcom_devinfo_scan_windows__hubport(struct lowlevel_device_info ** const devinfo_list, HANDLE hubh, const int portno)\n{\n\tstruct lowlevel_device_info *devinfo;\n\tconst size_t conninfosz = sizeof(USB_NODE_CONNECTION_INFORMATION) + (sizeof(USB_PIPE_INFO) * 30);\n\tuint8_t buf[conninfosz];\n\tUSB_NODE_CONNECTION_INFORMATION * const conninfo = (USB_NODE_CONNECTION_INFORMATION *)buf;\n\t\n\tconninfo->ConnectionIndex = portno;\n\t\n\tULONG respsz;\n\tif (!DeviceIoControl(hubh, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION, conninfo, conninfosz, conninfo, conninfosz, &respsz, NULL))\n\t\tapplogfailinfor(, LOG_ERR, \"ioctl\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\tif (conninfo->ConnectionStatus != DeviceConnected)\n\t\treturn;\n\t\n\tif (conninfo->DeviceIsHub)\n\t{\n\t\tconst char * const hubpath = windows_usb_get_port_path(hubh, portno);\n\t\tif (hubpath)\n\t\t\t_vcom_devinfo_scan_windows__hub(devinfo_list, hubpath);\n\t\treturn;\n\t}\n\t\n\tconst USB_DEVICE_DESCRIPTOR * const devdesc = &conninfo->DeviceDescriptor;\n\tchar * const serial = windows_usb_get_string(hubh, portno, devdesc->iSerialNumber);\n\tif (!serial)\n\t{\nout:\n\t\tfree(serial);\n\t\treturn;\n\t}\n\tconst size_t slen = strlen(serial);\n\tchar subkey[52 + slen + 18 + 1];\n\tsprintf(subkey, \"SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USB\\\\VID_%04x&PID_%04x\\\\%s\\\\Device Parameters\",\n\t        (unsigned)devdesc->idVendor, (unsigned)devdesc->idProduct, serial);\n\tHKEY hkey;\n\tint e;\n\tif (ERROR_SUCCESS != (e = RegOpenKey(HKEY_LOCAL_MACHINE, subkey, &hkey)))\n\t{\n\t\tapplogfailinfo(LOG_ERR, \"open Device Parameters registry key\", \"%s\", bfg_strerror(e, BST_SYSTEM));\n\t\tgoto out;\n\t}\n\tchar devpath[0x10] = \"\\\\\\\\.\\\\\";\n\tDWORD type, sz = sizeof(devpath) - 4;\n\tif (ERROR_SUCCESS != (e = RegQueryValueExA(hkey, \"PortName\", NULL, &type, (LPBYTE)&devpath[4], &sz)))\n\t{\n\t\tapplogfailinfo(LOG_DEBUG, \"get PortName registry key value\", \"%s\", bfg_strerror(e, BST_SYSTEM));\n\t\tRegCloseKey(hkey);\n\t\tgoto out;\n\t}\n\tRegCloseKey(hkey);\n\tif (type != REG_SZ)\n\t{\n\t\tapplogfailinfor(, LOG_ERR, \"get expected type for PortName registry key value\", \"%ld\", (long)type);\n\t\tgoto out;\n\t}\n\t\n\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, devpath);\n\tif (!devinfo)\n\t{\n\t\tfree(serial);\n\t\treturn;\n\t}\n\tBFGINIT(devinfo->manufacturer, windows_usb_get_string(hubh, portno, devdesc->iManufacturer));\n\tBFGINIT(devinfo->product, windows_usb_get_string(hubh, portno, devdesc->iProduct));\n\tif (devinfo->serial)\n\t\tfree(serial);\n\telse\n\t\tdevinfo->serial = serial;\n}\n\nstatic\nvoid _vcom_devinfo_scan_windows__hub(struct lowlevel_device_info ** const devinfo_list, const char * const hubpath)\n{\n\tHANDLE hubh;\n\tUSB_NODE_INFORMATION nodeinfo;\n\t\n\t{\n\t\tchar deviceName[4 + strlen(hubpath) + 1];\n\t\tsprintf(deviceName, \"\\\\\\\\.\\\\%s\", hubpath);\n\t\thubh = CreateFile(deviceName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\t\tif (hubh == INVALID_HANDLE_VALUE)\n\t\t\tapplogr(, LOG_ERR, \"Error opening USB hub device %s for autodetect: %s\", deviceName, bfg_strerror(GetLastError(), BST_SYSTEM));\n\t}\n\t\n\tULONG nBytes;\n\tif (!DeviceIoControl(hubh, IOCTL_USB_GET_NODE_INFORMATION, &nodeinfo, sizeof(nodeinfo), &nodeinfo, sizeof(nodeinfo), &nBytes, NULL))\n\t\tapplogfailinfor(, LOG_ERR, \"ioctl\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\tconst int portcount = nodeinfo.u.HubInformation.HubDescriptor.bNumberOfPorts;\n\tfor (int i = 1; i <= portcount; ++i)\n\t\t_vcom_devinfo_scan_windows__hubport(devinfo_list, hubh, i);\n\t\n\tCloseHandle(hubh);\n}\n\nstatic\nchar *windows_usb_get_root_hub_path(HANDLE hcntlrh)\n{\n\tsize_t namesz;\n\tULONG rsz;\n\t\n\t{\n\t\tUSB_ROOT_HUB_NAME pathinfo;\n\t\tif (!DeviceIoControl(hcntlrh, IOCTL_USB_GET_ROOT_HUB_NAME, 0, 0, &pathinfo, sizeof(pathinfo), &rsz, NULL))\n\t\t\tapplogfailinfor(NULL, LOG_ERR, \"ioctl (1)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\tif (rsz < sizeof(pathinfo))\n\t\t\tapplogfailinfor(NULL, LOG_ERR, \"ioctl (1)\", \"Size too small (%d < %d)\", (int)rsz, (int)sizeof(pathinfo));\n\t\tnamesz = pathinfo.ActualLength;\n\t}\n\t\n\tconst size_t bufsz = sizeof(USB_ROOT_HUB_NAME) + namesz;\n\tuint8_t buf[bufsz];\n\tUSB_ROOT_HUB_NAME *hubpath = (USB_ROOT_HUB_NAME *)buf;\n\t\n\tif (!(DeviceIoControl(hcntlrh, IOCTL_USB_GET_ROOT_HUB_NAME, NULL, 0, hubpath, bufsz, &rsz, NULL) && rsz >= sizeof(*hubpath)))\n\t\tapplogfailinfor(NULL, LOG_ERR, \"ioctl (2)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\treturn ucs2_to_utf8_dup(hubpath->RootHubName, hubpath->ActualLength);\n}\n\nstatic\nvoid _vcom_devinfo_scan_windows__hcntlr(struct lowlevel_device_info ** const devinfo_list, HDEVINFO *devinfo, const int i)\n{\n\tSP_DEVICE_INTERFACE_DATA devifacedata = {\n\t\t.cbSize = sizeof(devifacedata),\n\t};\n\tif (!SetupDiEnumDeviceInterfaces(*devinfo, 0, (LPGUID)&WIN_GUID_DEVINTERFACE_USB_HOST_CONTROLLER, i, &devifacedata))\n\t\tapplogfailinfor(, LOG_ERR, \"SetupDiEnumDeviceInterfaces\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\tDWORD detailsz;\n\tif (!(!SetupDiGetDeviceInterfaceDetail(*devinfo, &devifacedata, NULL, 0, &detailsz, NULL) && GetLastError() == ERROR_INSUFFICIENT_BUFFER))\n\t\tapplogfailinfor(, LOG_ERR, \"SetupDiEnumDeviceInterfaceDetail (1)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\tPSP_DEVICE_INTERFACE_DETAIL_DATA detail = alloca(detailsz);\n\tdetail->cbSize = sizeof(*detail);\n\tif (!SetupDiGetDeviceInterfaceDetail(*devinfo, &devifacedata, detail, detailsz, &detailsz, NULL))\n\t\tapplogfailinfor(, LOG_ERR, \"SetupDiEnumDeviceInterfaceDetail (2)\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\tHANDLE hcntlrh = CreateFile(detail->DevicePath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif (hcntlrh == INVALID_HANDLE_VALUE)\n\t\tapplogfailinfor(, LOG_DEBUG, \"open USB host controller device\", \"%s\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\tchar * const hubpath = windows_usb_get_root_hub_path(hcntlrh);\n\tCloseHandle(hcntlrh);\n\tif (unlikely(!hubpath))\n\t\treturn;\n\t_vcom_devinfo_scan_windows__hub(devinfo_list, hubpath);\n\tfree(hubpath);\n}\n\nstatic\nvoid _vcom_devinfo_scan_windows(struct lowlevel_device_info ** const devinfo_list)\n{\n\tHDEVINFO devinfo;\n\tdevinfo = SetupDiGetClassDevs(&WIN_GUID_DEVINTERFACE_USB_HOST_CONTROLLER, NULL, NULL, (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));\n\tSP_DEVINFO_DATA devinfodata = {\n\t\t.cbSize = sizeof(devinfodata),\n\t};\n\t\n\tfor (int i = 0; SetupDiEnumDeviceInfo(devinfo, i, &devinfodata); ++i)\n\t\t_vcom_devinfo_scan_windows__hcntlr(devinfo_list, &devinfo, i);\n\tSetupDiDestroyDeviceInfoList(devinfo);\n}\n\n#endif\n\n\n#ifdef WIN32\n#define LOAD_SYM(sym)  do { \\\n\tif (!(sym = dlsym(dll, #sym))) {  \\\n\t\tapplog(LOG_DEBUG, \"Failed to load \" #sym \", not using FTDI autodetect\");  \\\n\t\tgoto out;  \\\n\t}  \\\n} while(0)\n\nstatic\nchar *_ftdi_get_string(char *buf, intptr_t i, DWORD flags)\n{\n\tif (FT_OK != FT_ListDevices((PVOID)i, buf, FT_LIST_BY_INDEX | flags))\n\t\treturn NULL;\n\treturn buf[0] ? buf : NULL;\n}\n\nstatic\nvoid _vcom_devinfo_scan_ftdi(struct lowlevel_device_info ** const devinfo_list)\n{\n\tchar devpath[] = \"\\\\\\\\.\\\\COMnnnnn\";\n\tchar *devpathnum = &devpath[7];\n\tchar **bufptrs;\n\tchar *buf;\n\tchar serial[64];\n\tstruct lowlevel_device_info *devinfo;\n\tDWORD i;\n\n\tFT_STATUS ftStatus;\n\tDWORD numDevs;\n\tHMODULE dll = LoadLibrary(\"FTD2XX.DLL\");\n\tif (!dll) {\n\t\tapplog(LOG_DEBUG, \"FTD2XX.DLL failed to load, not using FTDI autodetect\");\n\t\treturn;\n\t}\n\tLOAD_SYM(FT_ListDevices);\n\tLOAD_SYM(FT_Open);\n\tLOAD_SYM(FT_GetComPortNumber);\n\tLOAD_SYM(FT_Close);\n\t\n\tftStatus = FT_ListDevices(&numDevs, NULL, FT_LIST_NUMBER_ONLY);\n\tif (ftStatus != FT_OK) {\n\t\tapplog(LOG_DEBUG, \"FTDI device count failed, not using FTDI autodetect\");\n\t\tgoto out;\n\t}\n\tapplog(LOG_DEBUG, \"FTDI reports %u devices\", (unsigned)numDevs);\n\n\tbuf = alloca(65 * numDevs);\n\tbufptrs = alloca(sizeof(*bufptrs) * (numDevs + 1));\n\n\tfor (i = 0; i < numDevs; ++i)\n\t\tbufptrs[i] = &buf[i * 65];\n\tbufptrs[numDevs] = NULL;\n\tftStatus = FT_ListDevices(bufptrs, &numDevs, FT_LIST_ALL | FT_OPEN_BY_DESCRIPTION);\n\tif (ftStatus != FT_OK) {\n\t\tapplog(LOG_DEBUG, \"FTDI device list failed, not using FTDI autodetect\");\n\t\tgoto out;\n\t}\n\t\n\tfor (i = numDevs; i > 0; ) {\n\t\t--i;\n\t\tbufptrs[i][64] = '\\0';\n\t\t\n\t\tFT_HANDLE ftHandle;\n\t\tif (FT_OK != FT_Open(i, &ftHandle))\n\t\t\tcontinue;\n\t\tLONG lComPortNumber;\n\t\tftStatus = FT_GetComPortNumber(ftHandle, &lComPortNumber);\n\t\tFT_Close(ftHandle);\n\t\tif (FT_OK != ftStatus || lComPortNumber < 0)\n\t\t\tcontinue;\n\t\t\n\t\tapplog(LOG_ERR, \"FT_GetComPortNumber(%p (%ld), %ld)\", ftHandle, (long)i, (long)lComPortNumber);\n\t\tsprintf(devpathnum, \"%d\", (int)lComPortNumber);\n\t\t\n\t\tdevinfo = _vcom_devinfo_findorcreate(devinfo_list, devpath);\n\t\tif (!devinfo)\n\t\t\tcontinue;\n\t\tBFGINIT(devinfo->product, (bufptrs[i] && bufptrs[i][0]) ? strdup(bufptrs[i]) : NULL);\n\t\tBFGINIT(devinfo->serial, maybe_strdup(_ftdi_get_string(serial, i, FT_OPEN_BY_SERIAL_NUMBER)));\n\t}\n\nout:\n\tdlclose(dll);\n}\n#endif\n\n#ifdef WIN32\nextern void _vcom_devinfo_scan_querydosdevice(struct lowlevel_device_info **);\n#else\nextern void _vcom_devinfo_scan_lsdev(struct lowlevel_device_info **);\n#endif\n\nvoid _vcom_devinfo_scan_user(struct lowlevel_device_info ** const devinfo_list)\n{\n\tstruct string_elist *sd_iter, *sd_tmp;\n\tDL_FOREACH_SAFE(scan_devices, sd_iter, sd_tmp)\n\t{\n\t\tconst char * const dname = sd_iter->string;\n\t\tconst char * const colon = strpbrk(dname, \":@\");\n\t\tconst char *dev;\n\t\tif (!(colon && colon != dname))\n\t\t\tdev = dname;\n\t\telse\n\t\t\tdev = &colon[1];\n\t\tif (!access(dev, F_OK))\n\t\t\t_vcom_devinfo_findorcreate(devinfo_list, dev);\n\t}\n}\n\nextern bool lowl_usb_attach_kernel_driver(const struct lowlevel_device_info *);\n\nbool vcom_lowl_probe_wrapper(const struct lowlevel_device_info * const info, detectone_func_t detectone)\n{\n\tif (info->lowl != &lowl_vcom)\n\t{\n#ifdef HAVE_LIBUSB\n\t\tif (info->lowl == &lowl_usb)\n\t\t{\n\t\t\tif (lowl_usb_attach_kernel_driver(info))\n\t\t\t\tbfg_need_detect_rescan = true;\n\t\t}\n#endif\n\t\tbfg_probe_result_flags = BPR_WRONG_DEVTYPE;\n\t\treturn false;\n\t}\n\tdetectone_meta_info = (struct detectone_meta_info_t){\n\t\t.manufacturer = info->manufacturer,\n\t\t.product = info->product,\n\t\t.serial = info->serial,\n\t};\n\tconst bool rv = detectone(info->path);\n\tclear_detectone_meta_info();\n\treturn rv;\n}\n\nbool _serial_autodetect_found_cb(struct lowlevel_device_info * const devinfo, void *userp)\n{\n\tdetectone_func_t detectone = userp;\n\tif (bfg_claim_any(NULL, devinfo->path, devinfo->devid))\n\t{\n\t\tapplog(LOG_DEBUG, \"%s (%s) is already claimed, skipping probe\", devinfo->path, devinfo->devid);\n\t\treturn false;\n\t}\n\tif (devinfo->lowl != &lowl_vcom)\n\t{\n#ifdef HAVE_LIBUSB\n\t\tif (devinfo->lowl == &lowl_usb)\n\t\t{\n\t\t\tif (lowl_usb_attach_kernel_driver(devinfo))\n\t\t\t\tbfg_need_detect_rescan = true;\n\t\t}\n\t\telse\n#endif\n\t\t\tapplog(LOG_WARNING, \"Non-VCOM %s (%s) matched\", devinfo->path, devinfo->devid);\n\t\treturn false;\n\t}\n\tdetectone_meta_info = (struct detectone_meta_info_t){\n\t\t.manufacturer = devinfo->manufacturer,\n\t\t.product = devinfo->product,\n\t\t.serial = devinfo->serial,\n\t};\n\tconst bool rv = detectone(devinfo->path);\n\tclear_detectone_meta_info();\n\treturn rv;\n}\n\nint _serial_autodetect(detectone_func_t detectone, ...)\n{\n\tva_list needles;\n\tchar *needles_array[0x10];\n\tint needlecount = 0;\n\t\n\tva_start(needles, detectone);\n\twhile ( (needles_array[needlecount++] = va_arg(needles, void *)) )\n\t{}\n\tva_end(needles);\n\t\n\treturn _lowlevel_detect(_serial_autodetect_found_cb, NULL, (const char **)needles_array, detectone);\n}\n\nstatic\nstruct lowlevel_device_info *vcom_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_hash = NULL;\n\tstruct lowlevel_device_info *devinfo_list = NULL;\n\tstruct lowlevel_device_info *devinfo, *tmp;\n\t\n\t// All 3 USB Strings available:\n#ifndef WIN32\n\t_vcom_devinfo_scan_sysfs(&devinfo_hash);\n#endif\n#ifdef HAVE_WIN_DDKUSB\n\t_vcom_devinfo_scan_windows(&devinfo_hash);\n#endif\n#ifdef HAVE_LIBUDEV\n\t_vcom_devinfo_scan_udev(&devinfo_hash);\n#endif\n#ifdef __APPLE__\n\t_vcom_devinfo_scan_iokit(&devinfo_hash);\n#endif\n\t// Missing Manufacturer:\n#ifdef WIN32\n\t_vcom_devinfo_scan_ftdi(&devinfo_hash);\n#endif\n\t// All blobbed together:\n#ifndef WIN32\n\t_vcom_devinfo_scan_devserial(&devinfo_hash);\n#endif\n\t// No info:\n#ifdef WIN32\n\t_vcom_devinfo_scan_querydosdevice(&devinfo_hash);\n#else\n\t_vcom_devinfo_scan_lsdev(&devinfo_hash);\n#endif\n\t_vcom_devinfo_scan_user(&devinfo_hash);\n\t\n\t// Convert hash to simple list\n\tHASH_ITER(hh, devinfo_hash, devinfo, tmp)\n\t{\n\t\tLL_PREPEND(devinfo_list, devinfo);\n\t}\n\tHASH_CLEAR(hh, devinfo_hash);\n\t\n\treturn devinfo_list;\n}\n\n\nstruct device_drv *bfg_claim_serial(struct device_drv * const api, const bool verbose, const char * const devpath)\n{\n\tchar * const devs = _vcom_unique_id(devpath);\n\tif (!devs)\n\t\treturn false;\n\tstruct device_drv * const rv = bfg_claim_any(api, (verbose ? devpath : NULL), devs);\n\tfree(devs);\n\treturn rv;\n}\n\n// This code is purely for debugging but is very useful for that\n// It also took quite a bit of effort so I left it in\n// #define TERMIOS_DEBUG 1\n// Here to include it at compile time\n// It's off by default\n#ifndef WIN32\n#ifdef TERMIOS_DEBUG\n\n#define BITSSET \"Y\"\n#define BITSNOTSET \"N\"\n\nint tiospeed(speed_t speed)\n{\n\tswitch (speed) {\n#define IOSPEED(baud)  \\\n\t\tcase B ## baud:  \\\n\t\t\treturn baud;  \\\n// END\n#include \"iospeeds_local.h\"\n#undef IOSPEED\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nvoid termios_debug(const char *devpath, struct termios *my_termios, const char *msg)\n{\n\tapplog(LOG_DEBUG, \"TIOS: Open %s attributes %s: ispeed=%d ospeed=%d\",\n\t\t\tdevpath, msg, tiospeed(cfgetispeed(my_termios)), tiospeed(cfgetispeed(my_termios)));\n\n#define ISSETI(b) ((my_termios->c_iflag | (b)) ? BITSSET : BITSNOTSET)\n\n\tapplog(LOG_DEBUG, \"TIOS:  c_iflag: IGNBRK=%s BRKINT=%s IGNPAR=%s PARMRK=%s INPCK=%s ISTRIP=%s INLCR=%s IGNCR=%s ICRNL=%s IUCLC=%s IXON=%s IXANY=%s IOFF=%s IMAXBEL=%s IUTF8=%s\",\n\t\t\tISSETI(IGNBRK), ISSETI(BRKINT), ISSETI(IGNPAR), ISSETI(PARMRK),\n\t\t\tISSETI(INPCK), ISSETI(ISTRIP), ISSETI(INLCR), ISSETI(IGNCR),\n\t\t\tISSETI(ICRNL), ISSETI(IUCLC), ISSETI(IXON), ISSETI(IXANY),\n\t\t\tISSETI(IXOFF), ISSETI(IMAXBEL), ISSETI(IUTF8));\n\n#define ISSETO(b) ((my_termios->c_oflag | (b)) ? BITSSET : BITSNOTSET)\n#define VALO(b) (my_termios->c_oflag | (b))\n\n\tapplog(LOG_DEBUG, \"TIOS:  c_oflag: OPOST=%s OLCUC=%s ONLCR=%s OCRNL=%s ONOCR=%s ONLRET=%s OFILL=%s OFDEL=%s NLDLY=%d CRDLY=%d TABDLY=%d BSDLY=%d VTDLY=%d FFDLY=%d\",\n\t\t\tISSETO(OPOST), ISSETO(OLCUC), ISSETO(ONLCR), ISSETO(OCRNL),\n\t\t\tISSETO(ONOCR), ISSETO(ONLRET), ISSETO(OFILL), ISSETO(OFDEL),\n\t\t\tVALO(NLDLY), VALO(CRDLY), VALO(TABDLY), VALO(BSDLY),\n\t\t\tVALO(VTDLY), VALO(FFDLY));\n\n#define ISSETC(b) ((my_termios->c_cflag | (b)) ? BITSSET : BITSNOTSET)\n#define VALC(b) (my_termios->c_cflag | (b))\n\n\tapplog(LOG_DEBUG, \"TIOS:  c_cflag: CBAUDEX=%s CSIZE=%d CSTOPB=%s CREAD=%s PARENB=%s PARODD=%s HUPCL=%s CLOCAL=%s\"\n#ifdef LOBLK\n\t\t\t\" LOBLK=%s\"\n#endif\n\t\t\t\" CMSPAR=%s CRTSCTS=%s\",\n\t\t\tISSETC(CBAUDEX), VALC(CSIZE), ISSETC(CSTOPB), ISSETC(CREAD),\n\t\t\tISSETC(PARENB), ISSETC(PARODD), ISSETC(HUPCL), ISSETC(CLOCAL),\n#ifdef LOBLK\n\t\t\tISSETC(LOBLK),\n#endif\n\t\t\tISSETC(CMSPAR), ISSETC(CRTSCTS));\n\n#define ISSETL(b) ((my_termios->c_lflag | (b)) ? BITSSET : BITSNOTSET)\n\n\tapplog(LOG_DEBUG, \"TIOS:  c_lflag: ISIG=%s ICANON=%s XCASE=%s ECHO=%s ECHOE=%s ECHOK=%s ECHONL=%s ECHOCTL=%s ECHOPRT=%s ECHOKE=%s\"\n#ifdef DEFECHO\n\t\t\t\" DEFECHO=%s\"\n#endif\n\t\t\t\" FLUSHO=%s NOFLSH=%s TOSTOP=%s PENDIN=%s IEXTEN=%s\",\n\t\t\tISSETL(ISIG), ISSETL(ICANON), ISSETL(XCASE), ISSETL(ECHO),\n\t\t\tISSETL(ECHOE), ISSETL(ECHOK), ISSETL(ECHONL), ISSETL(ECHOCTL),\n\t\t\tISSETL(ECHOPRT), ISSETL(ECHOKE),\n#ifdef DEFECHO\n\t\t\tISSETL(DEFECHO),\n#endif\n\t\t\tISSETL(FLUSHO), ISSETL(NOFLSH), ISSETL(TOSTOP), ISSETL(PENDIN),\n\t\t\tISSETL(IEXTEN));\n\n#define VALCC(b) (my_termios->c_cc[b])\n\tapplog(LOG_DEBUG, \"TIOS:  c_cc: VINTR=0x%02x VQUIT=0x%02x VERASE=0x%02x VKILL=0x%02x VEOF=0x%02x VMIN=%u VEOL=0x%02x VTIME=%u VEOL2=0x%02x\"\n#ifdef VSWTCH\n\t\t\t\" VSWTCH=0x%02x\"\n#endif\n\t\t\t\" VSTART=0x%02x VSTOP=0x%02x VSUSP=0x%02x\"\n#ifdef VDSUSP\n\t\t\t\" VDSUSP=0x%02x\"\n#endif\n\t\t\t\" VLNEXT=0x%02x VWERASE=0x%02x VREPRINT=0x%02x VDISCARD=0x%02x\"\n#ifdef VSTATUS\n\t\t\t\" VSTATUS=0x%02x\"\n#endif\n\t\t\t,\n\t\t\tVALCC(VINTR), VALCC(VQUIT), VALCC(VERASE), VALCC(VKILL),\n\t\t\tVALCC(VEOF), VALCC(VMIN), VALCC(VEOL), VALCC(VTIME),\n\t\t\tVALCC(VEOL2),\n#ifdef VSWTCH\n\t\t\tVALCC(VSWTCH),\n#endif\n\t\t\tVALCC(VSTART), VALCC(VSTOP), VALCC(VSUSP),\n#ifdef VDSUSP\n\t\t\tVALCC(VDSUSP),\n#endif\n\t\t\tVALCC(VLNEXT), VALCC(VWERASE),\n\t\t\tVALCC(VREPRINT), VALCC(VDISCARD)\n#ifdef VSTATUS\n\t\t\t,VALCC(VSTATUS)\n#endif\n\t\t\t);\n}\n#endif  /* TERMIOS_DEBUG */\n\nspeed_t tiospeed_t(int baud)\n{\n\tswitch (baud) {\n#define IOSPEED(baud)  \\\n\t\tcase baud:  \\\n\t\t\treturn B ## baud;  \\\n// END\n#include \"iospeeds_local.h\"\n#undef IOSPEED\n\tdefault:\n\t\treturn B0;\n\t}\n}\n\n#endif  /* WIN32 */\n\nbool valid_baud(int baud)\n{\n\tswitch (baud) {\n#define IOSPEED(baud)  \\\n\t\tcase baud:  \\\n\t\t\treturn true;  \\\n// END\n#include \"iospeeds_local.h\"\n#undef IOSPEED\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nbool vcom_set_timeout_ms(const int fdDev, const unsigned timeout_ms)\n{\n#ifdef WIN32\n\tconst HANDLE hSerial = (HANDLE)_get_osfhandle(fdDev);\n\t// Code must specify a valid timeout value (0 means don't timeout)\n\tconst DWORD ctoms = timeout_ms;\n\tCOMMTIMEOUTS cto = {ctoms, 0, ctoms, 0, ctoms};\n\treturn (SetCommTimeouts(hSerial, &cto) != 0);\n#else\n\tstruct termios my_termios;\n\t\n\ttcgetattr(fdDev, &my_termios);\n\tmy_termios.c_cc[VTIME] = (cc_t)((timeout_ms + 99) / 100);\n\treturn (tcsetattr(fdDev, TCSANOW, &my_termios) == 0);\n#endif\n}\n\n/* NOTE: Linux only supports uint8_t (decisecond) timeouts; limiting it in\n *       this interface buys us warnings when bad constants are passed in.\n */\nint serial_open(const char *devpath, unsigned long baud, uint8_t timeout, bool purge)\n{\n#ifdef WIN32\n\tHANDLE hSerial = CreateFile(devpath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);\n\tif (unlikely(hSerial == INVALID_HANDLE_VALUE))\n\t{\n\t\tDWORD e = GetLastError();\n\t\tswitch (e) {\n\t\tcase ERROR_ACCESS_DENIED:\n\t\t\tapplog(LOG_ERR, \"Do not have user privileges required to open %s\", devpath);\n\t\t\tbreak;\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\tapplog(LOG_ERR, \"%s is already in use by another process\", devpath);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tapplog(LOG_DEBUG, \"Open %s failed, GetLastError:%u\", devpath, (unsigned)e);\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (baud)\n\t{\n\n\tCOMMCONFIG comCfg = {0};\n\tcomCfg.dwSize = sizeof(COMMCONFIG);\n\tcomCfg.wVersion = 1;\n\tcomCfg.dcb.DCBlength = sizeof(DCB);\n\tcomCfg.dcb.BaudRate = baud;\n\tcomCfg.dcb.fBinary = 1;\n\tcomCfg.dcb.fDtrControl = DTR_CONTROL_ENABLE;\n\tcomCfg.dcb.fRtsControl = RTS_CONTROL_ENABLE;\n\tcomCfg.dcb.ByteSize = 8;\n\n\t\tif (!SetCommConfig(hSerial, &comCfg, sizeof(comCfg)))\n\t\t\t// FIXME: We should probably be setting even if baud is clear (in which case, only LOG_DEBUG this)\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"SetCommConfig\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\n\t}\n\n\t// Code must specify a valid timeout value (0 means don't timeout)\n\tconst DWORD ctoms = ((DWORD)timeout * 100);\n\tCOMMTIMEOUTS cto = {ctoms, 0, ctoms, 0, ctoms};\n\tif (!SetCommTimeouts(hSerial, &cto))\n\t\tapplog(timeout ? LOG_WARNING : LOG_DEBUG, \"%s: %s failed: %s\", devpath, \"SetCommTimeouts\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\n\tif (purge) {\n\t\tif (!PurgeComm(hSerial, PURGE_RXABORT))\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"PURGE_RXABORT\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\tif (!PurgeComm(hSerial, PURGE_TXABORT))\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"PURGE_TXABORT\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\tif (!PurgeComm(hSerial, PURGE_RXCLEAR))\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"PURGE_RXCLEAR\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\tif (!PurgeComm(hSerial, PURGE_TXCLEAR))\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"PURGE_TXCLEAR\", bfg_strerror(GetLastError(), BST_SYSTEM));\n\t}\n\n\treturn _open_osfhandle((intptr_t)hSerial, 0);\n#else\n\tint fdDev = open(devpath, O_RDWR | O_CLOEXEC | O_NOCTTY);\n\n\tif (unlikely(fdDev == -1))\n\t{\n\t\tif (errno == EACCES)\n\t\t\tapplog(LOG_ERR, \"Do not have user privileges required to open %s\", devpath);\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"Open %s failed: %s\", devpath, bfg_strerror(errno, BST_ERRNO));\n\n\t\treturn -1;\n\t}\n\t\n#if defined(LOCK_EX) && defined(LOCK_NB)\n\tif (likely(!flock(fdDev, LOCK_EX | LOCK_NB)))\n\t\tapplog(LOG_DEBUG, \"Acquired exclusive advisory lock on %s\", devpath);\n\telse\n\tif (errno == EWOULDBLOCK)\n\t{\n\t\tapplog(LOG_ERR, \"%s is already in use by another process\", devpath);\n\t\tclose(fdDev);\n\t\treturn -1;\n\t}\n\telse\n\t\tapplog(LOG_WARNING, \"Failed to acquire exclusive lock on %s: %s (ignoring)\", devpath, bfg_strerror(errno, BST_ERRNO));\n#endif\n\n\tstruct termios my_termios;\n\n\tif (tcgetattr(fdDev, &my_termios))\n\t\tapplog(baud ? LOG_WARNING : LOG_DEBUG, \"%s: %s failed: %s\", devpath, \"tcgetattr\", bfg_strerror(errno, BST_ERRNO));\n\telse\n\t{\n\n#ifdef TERMIOS_DEBUG\n\ttermios_debug(devpath, &my_termios, \"before\");\n#endif\n\n\tif (baud)\n\t{\n\t\tspeed_t speed = tiospeed_t(baud);\n\t\tif (speed == B0)\n\t\t\tapplog(LOG_WARNING, \"Unrecognized baud rate: %lu\", baud);\n\t\telse\n\t\t{\n\t\t\tcfsetispeed(&my_termios, speed);\n\t\t\tcfsetospeed(&my_termios, speed);\n\t\t}\n\t}\n\n\tmy_termios.c_cflag &= ~(CSIZE | PARENB);\n\tmy_termios.c_cflag |= CS8;\n\tmy_termios.c_cflag |= CREAD;\n#ifdef USE_AVALON\n//\tmy_termios.c_cflag |= CRTSCTS;\n#endif\n\tmy_termios.c_cflag |= CLOCAL;\n\n\tmy_termios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK |\n\t\t\t\tISTRIP | INLCR | IGNCR | ICRNL | IXON);\n\tmy_termios.c_oflag &= ~OPOST;\n\tmy_termios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n\n\t// Code must specify a valid timeout value (0 means don't timeout)\n\tmy_termios.c_cc[VTIME] = (cc_t)timeout;\n\tmy_termios.c_cc[VMIN] = 0;\n\n#ifdef TERMIOS_DEBUG\n\ttermios_debug(devpath, &my_termios, \"settings\");\n#endif\n\n\t\tif (tcsetattr(fdDev, TCSANOW, &my_termios))\n\t\t\tapplog(baud ? LOG_WARNING : LOG_DEBUG, \"%s: %s failed: %s\", devpath, \"tcsetattr\", bfg_strerror(errno, BST_ERRNO));\n\n#ifdef TERMIOS_DEBUG\n\ttcgetattr(fdDev, &my_termios);\n\ttermios_debug(devpath, &my_termios, \"after\");\n#endif\n\n\t}\n\n\tif (purge)\n\t{\n\t\tif (tcflush(fdDev, TCIOFLUSH))\n\t\t\tapplog(LOG_WARNING, \"%s: %s failed: %s\", devpath, \"tcflush\", bfg_strerror(errno, BST_ERRNO));\n\t}\n\treturn fdDev;\n#endif\n}\n\nint serial_close(const int fd)\n{\n#if defined(LOCK_EX) && defined(LOCK_NB) && defined(LOCK_UN)\n\tflock(fd, LOCK_UN);\n#endif\n\treturn close(fd);\n}\n\nssize_t _serial_read(int fd, char *buf, size_t bufsiz, char *eol)\n{\n\tssize_t len, tlen = 0;\n\twhile (bufsiz) {\n\t\tlen = read(fd, buf, eol ? 1 : bufsiz);\n\t\tif (len < 1)\n\t\t\tbreak;\n\t\ttlen += len;\n\t\tif (eol && *eol == buf[0])\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tbufsiz -= len;\n\t}\n\treturn tlen;\n}\n\n#ifndef WIN32\n\nenum bfg_gpio_value get_serial_cts(int fd)\n{\n\tint flags;\n\n\tif (fd == -1)\n\t\treturn BGV_ERROR;\n\n\tioctl(fd, TIOCMGET, &flags);\n\treturn (flags & TIOCM_CTS) ? BGV_HIGH : BGV_LOW;\n}\n\nstatic\nenum bfg_gpio_value _set_serial_cmflag(int fd, int flag, bool val)\n{\n\tint flags;\n\n\tif (fd == -1)\n\t\treturn BGV_ERROR;\n\n\tioctl(fd, TIOCMGET, &flags);\n\t\n\tif (val)\n\t\tflags |= flag;\n\telse\n\t\tflags &= ~flag;\n\n\tioctl(fd, TIOCMSET, &flags);\n\treturn val ? BGV_HIGH : BGV_LOW;\n}\n\nenum bfg_gpio_value set_serial_dtr(int fd, enum bfg_gpio_value dtr)\n{\n\treturn _set_serial_cmflag(fd, TIOCM_DTR, dtr);\n}\n\nenum bfg_gpio_value set_serial_rts(int fd, enum bfg_gpio_value rts)\n{\n\treturn _set_serial_cmflag(fd, TIOCM_RTS, rts);\n}\n#else\nenum bfg_gpio_value get_serial_cts(const int fd)\n{\n\tif (fd == -1)\n\t\treturn BGV_ERROR;\n\tconst HANDLE fh = (HANDLE)_get_osfhandle(fd);\n\tif (fh == INVALID_HANDLE_VALUE)\n\t\treturn BGV_ERROR;\n\n\tDWORD flags;\n\tif (!GetCommModemStatus(fh, &flags))\n\t\treturn BGV_ERROR;\n\n\treturn (flags & MS_CTS_ON) ? BGV_HIGH : BGV_LOW;\n}\n\nstatic\nenum bfg_gpio_value _set_serial_cmflag(int fd, void (*setfunc)(DCB*, bool), bool val, const char * const fname)\n{\n\tif (fd == -1)\n\t\treturn BGV_ERROR;\n\tconst HANDLE fh = (HANDLE)_get_osfhandle(fd);\n\tif (fh == INVALID_HANDLE_VALUE)\n\t\treturn BGV_ERROR;\n\t\n\tDCB dcb;\n\tif (!GetCommState(fh, &dcb))\n\t\tapplogr(BGV_ERROR, LOG_DEBUG, \"Failed to %s\"IN_FMT_FFL\": %s\",\n\t\t        \"GetCommState\", __FILE__, fname, __LINE__,\n\t\t        bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\tsetfunc(&dcb, val);\n\t\n\tif (!SetCommState(fh, &dcb))\n\t\tapplogr(BGV_ERROR, LOG_DEBUG, \"Failed to %s\"IN_FMT_FFL\": %s\",\n\t\t        \"GetCommState\", __FILE__, fname, __LINE__,\n\t\t        bfg_strerror(GetLastError(), BST_SYSTEM));\n\t\n\treturn val ? BGV_HIGH : BGV_LOW;\n}\n#define _set_serial_cmflag2(name, field, trueval, falseval)  \\\nstatic  \\\nvoid _set_serial_cmflag_ ## name(DCB *dcb, bool val)  \\\n{  \\\n\tdcb->field = val ? (trueval) : (falseval);  \\\n}  \\\n  \\\nenum bfg_gpio_value set_serial_ ## name(int fd, enum bfg_gpio_value val)  \\\n{  \\\n\treturn _set_serial_cmflag(fd, _set_serial_cmflag_ ## name, val, \"set_serial_\" #name);  \\\n}  \\\n// END _set_serial_cmflag2\n\n_set_serial_cmflag2(dtr, fDtrControl, DTR_CONTROL_ENABLE, DTR_CONTROL_DISABLE)\n_set_serial_cmflag2(rts, fRtsControl, RTS_CONTROL_ENABLE, RTS_CONTROL_DISABLE)\n#endif // ! WIN32\n\nstruct lowlevel_driver lowl_vcom = {\n\t.dname = \"vcom\",\n\t.devinfo_scan = vcom_devinfo_scan,\n};\n"
        },
        {
          "name": "lowl-vcom.h",
          "type": "blob",
          "size": 1.7314453125,
          "content": "#ifndef BFG_LOWL_VCOM_H\n#define BFG_LOWL_VCOM_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"deviceapi.h\"\n#include \"util.h\"\n\nstruct device_drv;\nstruct cgpu_info;\n\nstruct detectone_meta_info_t {\n\tconst char *manufacturer;\n\tconst char *product;\n\tconst char *serial;\n};\n\nextern struct detectone_meta_info_t *_detectone_meta_info();\n#define detectone_meta_info (*_detectone_meta_info())\nextern void clear_detectone_meta_info(void);\n\nextern bool vcom_lowl_probe_wrapper(const struct lowlevel_device_info *, detectone_func_t);\n\nextern int _serial_autodetect(detectone_func_t, ...);\n#define serial_autodetect(...)  _serial_autodetect(__VA_ARGS__, NULL)\n\nextern struct device_drv *bfg_claim_serial(struct device_drv * const, const bool verbose, const char * const devpath);\n#define serial_claim(devpath, drv)    bfg_claim_serial(drv, false, devpath)\n#define serial_claim_v(devpath, drv)  bfg_claim_serial(drv, true , devpath)\n\nextern int serial_open(const char *devpath, unsigned long baud, uint8_t timeout, bool purge);\nextern ssize_t _serial_read(int fd, char *buf, size_t buflen, char *eol);\n#define serial_read(fd, buf, count)  \\\n\t_serial_read(fd, (char*)(buf), count, NULL)\n#define serial_read_line(fd, buf, bufsiz, eol)  \\\n\t_serial_read(fd, buf, bufsiz, &eol)\nextern int serial_close(int fd);\n\n// NOTE: timeout_ms=0 means it never times out\nextern bool vcom_set_timeout_ms(int fd, unsigned timeout_ms);\n#define vcom_set_timeout(fd, timeout)  vcom_set_timeout_ms(fd, (timeout) * 100)\nextern enum bfg_gpio_value get_serial_cts(int fd);\nextern enum bfg_gpio_value set_serial_dtr(int fd, enum bfg_gpio_value dtr);\nextern enum bfg_gpio_value set_serial_rts(int fd, enum bfg_gpio_value rts);\nextern bool valid_baud(int baud);\n\n#endif\n"
        },
        {
          "name": "lowlevel.c",
          "type": "blob",
          "size": 7.138671875,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <utlist.h>\n\n#include \"compat.h\"\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"miner.h\"\n\nstatic struct lowlevel_device_info *devinfo_list;\n\n#if defined(HAVE_LIBUSB) || defined(NEED_BFG_LOWL_HID)\nchar *bfg_make_devid_usb(const uint8_t usbbus, const uint8_t usbaddr)\n{\n\tchar * const devpath = malloc(12);\n\tsprintf(devpath, \"usb:%03u:%03u\", (unsigned)usbbus, (unsigned)usbaddr);\n\treturn devpath;\n}\n#endif\n\nvoid lowlevel_devinfo_semicpy(struct lowlevel_device_info * const dst, const struct lowlevel_device_info * const src)\n{\n#define COPYSTR(key)  BFGINIT(dst->key, maybe_strdup(src->key))\n\tCOPYSTR(manufacturer);\n\tCOPYSTR(product);\n\tCOPYSTR(serial);\n\tCOPYSTR(path);\n\tCOPYSTR(devid);\n\tBFGINIT(dst->vid, src->vid);\n\tBFGINIT(dst->pid, src->pid);\n}\n\nvoid lowlevel_devinfo_free(struct lowlevel_device_info * const info)\n{\n\tif (info->ref--)\n\t\treturn;\n\tif (info->lowl->devinfo_free)\n\t\tinfo->lowl->devinfo_free(info);\n\tfree(info->manufacturer);\n\tfree(info->product);\n\tfree(info->serial);\n\tfree(info->path);\n\tfree(info->devid);\n\tfree(info);\n}\n\nstruct lowlevel_device_info *lowlevel_ref(const struct lowlevel_device_info * const cinfo)\n{\n\tstruct lowlevel_device_info * const info = (void*)cinfo;\n\t++info->ref;\n\treturn info;\n}\n\nvoid lowlevel_scan_free()\n{\n\tif (!devinfo_list)\n\t\treturn;\n\t\n\tstruct lowlevel_device_info *info, *tmp;\n\tstruct lowlevel_device_info *info2, *tmp2;\n\t\n\tLL_FOREACH_SAFE(devinfo_list, info, tmp)\n\t{\n\t\tLL_DELETE(devinfo_list, info);\n\t\tLL_FOREACH_SAFE2(info, info2, tmp2, same_devid_next)\n\t\t{\n\t\t\tLL_DELETE2(info, info2, same_devid_next);\n\t\t\tlowlevel_devinfo_free(info2);\n\t\t}\n\t}\n}\n\nstruct lowlevel_device_info *lowlevel_scan()\n{\n\tstruct lowlevel_device_info *devinfo_mid_list;\n\t\n\tlowlevel_scan_free();\n\t\n#ifdef HAVE_LIBUSB\n\tdevinfo_mid_list = lowl_usb.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef NEED_BFG_LOWL_FTDI\n\tdevinfo_mid_list = lowl_ft232r.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef NEED_BFG_LOWL_HID\n\tdevinfo_mid_list = lowl_hid.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef USE_NANOFURY\n\tdevinfo_mid_list = lowl_mcp2210.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef NEED_BFG_LOWL_MSWIN\n\tdevinfo_mid_list = lowl_mswin.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef NEED_BFG_LOWL_PCI\n\tdevinfo_mid_list = lowl_pci.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n#ifdef NEED_BFG_LOWL_VCOM\n\tdevinfo_mid_list = lowl_vcom.devinfo_scan();\n\tLL_CONCAT(devinfo_list, devinfo_mid_list);\n#endif\n\t\n\tstruct lowlevel_device_info *devinfo_same_prev_ht = NULL, *devinfo_same_list;\n\tLL_FOREACH(devinfo_list, devinfo_mid_list)\n\t{\n\t\t// Check for devid overlapping, and build a secondary linked list for them, only including the devid in the main list once (high level to low level)\n\t\tHASH_FIND_STR(devinfo_same_prev_ht, devinfo_mid_list->devid, devinfo_same_list);\n\t\tif (devinfo_same_list)\n\t\t{\n\t\t\tHASH_DEL(devinfo_same_prev_ht, devinfo_same_list);\n\t\t\tLL_DELETE(devinfo_list, devinfo_same_list);\n\t\t}\n\t\tLL_PREPEND2(devinfo_same_list, devinfo_mid_list, same_devid_next);\n\t\tHASH_ADD_KEYPTR(hh, devinfo_same_prev_ht, devinfo_mid_list->devid, strlen(devinfo_mid_list->devid), devinfo_same_list);\n\t\t\n\t\tapplog(LOG_DEBUG, \"%s: Found %s device at %s (path=%s, vid=%04x, pid=%04x, manuf=%s, prod=%s, serial=%s)\",\n\t\t       __func__,\n\t\t       devinfo_mid_list->lowl->dname,\n\t\t       devinfo_mid_list->devid,\n\t\t       devinfo_mid_list->path,\n\t\t       (unsigned)devinfo_mid_list->vid, (unsigned)devinfo_mid_list->pid,\n\t\t       devinfo_mid_list->manufacturer, devinfo_mid_list->product, devinfo_mid_list->serial);\n\t}\n\tHASH_CLEAR(hh, devinfo_same_prev_ht);\n\t\n\treturn devinfo_list;\n}\n\nbool _lowlevel_match_product(const struct lowlevel_device_info * const info, const char ** const needles)\n{\n\tif (!info->product)\n\t\treturn false;\n\tfor (int i = 0; needles[i]; ++i)\n\t\tif (!strstr(info->product, needles[i]))\n\t\t\treturn false;\n\treturn true;\n}\n\nbool lowlevel_match_id(const struct lowlevel_device_info * const info, const struct lowlevel_driver * const lowl, const int32_t vid, const int32_t pid)\n{\n\tif (info->lowl != lowl)\n\t\treturn false;\n\tif (vid != -1 && vid != info->vid)\n\t\treturn false;\n\tif (pid != -1 && pid != info->pid)\n\t\treturn false;\n\treturn true;\n}\n\n#define DETECT_BEGIN  \\\n\tstruct lowlevel_device_info *info, *tmp;  \\\n\tint found = 0;  \\\n\t  \\\n\tLL_FOREACH_SAFE(devinfo_list, info, tmp)  \\\n\t{  \\\n// END DETECT_BEGIN\n\n#define DETECT_END  \\\n\t\tif (!cb(info, userp))  \\\n\t\t\tcontinue;  \\\n\t\tLL_DELETE(devinfo_list, info);  \\\n\t\t++found;  \\\n\t}  \\\n\treturn found;  \\\n// END DETECT_END\n\nint _lowlevel_detect(lowl_found_devinfo_func_t cb, const char *serial, const char **product_needles, void * const userp)\n{\n\tDETECT_BEGIN\n\t\tif (serial && ((!info->serial) || strcmp(serial, info->serial)))\n\t\t\tcontinue;\n\t\tif (product_needles[0] && !_lowlevel_match_product(info, product_needles))\n\t\t\tcontinue;\n\tDETECT_END\n}\n\nint lowlevel_detect_id(const lowl_found_devinfo_func_t cb, void * const userp, const struct lowlevel_driver * const lowl, const int32_t vid, const int32_t pid)\n{\n\tDETECT_BEGIN\n\t\tif (!lowlevel_match_id(info, lowl, vid, pid))\n\t\t\tcontinue;\n\tDETECT_END\n}\n\n\nstruct _device_claim {\n\tstruct device_drv *drv;\n\tchar *devpath;\n\tUT_hash_handle hh;\n};\n\nstruct device_drv *bfg_claim_any(struct device_drv * const api, const char *verbose, const char * const devpath)\n{\n\tstatic struct _device_claim *claims = NULL;\n\tstatic pthread_mutex_t claims_lock = PTHREAD_MUTEX_INITIALIZER;\n\tstruct _device_claim *c;\n\t\n\tmutex_lock(&claims_lock);\n\tHASH_FIND_STR(claims, devpath, c);\n\tif (c)\n\t{\n\t\tmutex_unlock(&claims_lock);\n\t\tif (verbose && opt_debug)\n\t\t{\n\t\t\tchar logbuf[LOGBUFSIZ];\n\t\t\tlogbuf[0] = '\\0';\n\t\t\tif (api)\n\t\t\t\ttailsprintf(logbuf, sizeof(logbuf), \"%s device \", api->dname);\n\t\t\tif (verbose[0])\n\t\t\t\ttailsprintf(logbuf, sizeof(logbuf), \"%s (%s)\", verbose, devpath);\n\t\t\telse\n\t\t\t\ttailsprintf(logbuf, sizeof(logbuf), \"%s\", devpath);\n\t\t\ttailsprintf(logbuf, sizeof(logbuf), \" already claimed by \");\n\t\t\tif (api)\n\t\t\t\ttailsprintf(logbuf, sizeof(logbuf), \"other \");\n\t\t\ttailsprintf(logbuf, sizeof(logbuf), \"driver: %s\", c->drv->dname);\n\t\t\t_applog(LOG_DEBUG, logbuf);\n\t\t}\n\t\treturn c->drv;\n\t}\n\t\n\tif (!api)\n\t{\n\t\tmutex_unlock(&claims_lock);\n\t\treturn NULL;\n\t}\n\t\n\tc = malloc(sizeof(*c));\n\tc->devpath = strdup(devpath);\n\tc->drv = api;\n\tHASH_ADD_KEYPTR(hh, claims, c->devpath, strlen(devpath), c);\n\tmutex_unlock(&claims_lock);\n\treturn NULL;\n}\n\nstruct device_drv *bfg_claim_any2(struct device_drv * const api, const char * const verbose, const char * const llname, const char * const path)\n{\n\tconst size_t llnamesz = strlen(llname);\n\tconst size_t pathsz = strlen(path);\n\tchar devpath[llnamesz + 1 + pathsz + 1];\n\tmemcpy(devpath, llname, llnamesz);\n\tdevpath[llnamesz] = ':';\n\tmemcpy(&devpath[llnamesz+1], path, pathsz + 1);\n\treturn bfg_claim_any(api, verbose, devpath);\n}\n"
        },
        {
          "name": "lowlevel.h",
          "type": "blob",
          "size": 3.0712890625,
          "content": "#ifndef BFG_LOWLEVEL_H\n#define BFG_LOWLEVEL_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <pthread.h>\n\n#include <uthash.h>\n\n#include \"miner.h\"\n\nstruct lowlevel_device_info;\n\ntypedef bool (*lowl_found_devinfo_func_t)(struct lowlevel_device_info *, void *);\n\nstruct lowlevel_driver {\n\tconst char *dname;\n\tbool exclude_from_all;\n\t\n\tstruct lowlevel_device_info *(*devinfo_scan)();\n\tvoid (*devinfo_free)(struct lowlevel_device_info *);\n};\n\nstruct lowlevel_device_info {\n\tchar *manufacturer;\n\tchar *product;\n\tchar *serial;\n\tchar *path;\n\tchar *devid;\n\tuint16_t vid;\n\tuint16_t pid;\n\t\n\tstruct lowlevel_driver *lowl;\n\tvoid *lowl_data;\n\t\n\tstruct lowlevel_device_info *next;\n\tstruct lowlevel_device_info *same_devid_next;\n\tUT_hash_handle hh;\n\tpthread_t probe_pth;\n\tint ref;\n};\n\nextern char *bfg_make_devid_usb(uint8_t usbbus, uint8_t usbaddr);\n\nextern struct lowlevel_device_info *lowlevel_scan();\nextern bool _lowlevel_match_product(const struct lowlevel_device_info *, const char **);\n#define lowlevel_match_product(info, ...)  \\\n\t_lowlevel_match_product(info, (const char *[]){__VA_ARGS__, NULL})\n#define lowlevel_match_lowlproduct(info, matchlowl, ...)  \\\n\t(matchlowl == info->lowl && _lowlevel_match_product(info, (const char *[]){__VA_ARGS__, NULL}))\nextern bool lowlevel_match_id(const struct lowlevel_device_info *, const struct lowlevel_driver *, int32_t vid, int32_t pid);\nextern int _lowlevel_detect(lowl_found_devinfo_func_t, const char *serial, const char **product_needles, void *);\n#define lowlevel_detect(func, ...)  _lowlevel_detect(func, NULL, (const char *[]){__VA_ARGS__, NULL}, NULL)\n#define lowlevel_detect_serial(func, serial)  _lowlevel_detect(func, serial, (const char *[]){NULL}, NULL)\nextern int lowlevel_detect_id(lowl_found_devinfo_func_t, void *, const struct lowlevel_driver *, int32_t vid, int32_t pid);\nextern void lowlevel_scan_free();\n\nextern struct lowlevel_device_info *lowlevel_ref(const struct lowlevel_device_info *);\n#define lowlevel_claim(drv, verbose, info)  \\\n\tbfg_claim_any(drv, (verbose) ? ((info)->path ?: \"\") : NULL, (info)->devid)\nextern void lowlevel_devinfo_semicpy(struct lowlevel_device_info *dst, const struct lowlevel_device_info *src);\nextern void lowlevel_devinfo_free(struct lowlevel_device_info *);\n\n#ifdef NEED_BFG_LOWL_FTDI\nextern struct lowlevel_driver lowl_ft232r;\n#endif\n#ifdef NEED_BFG_LOWL_HID\nextern struct lowlevel_driver lowl_hid;\n#endif\n#ifdef USE_NANOFURY\nextern struct lowlevel_driver lowl_mcp2210;\n#endif\n#ifdef NEED_BFG_LOWL_MSWIN\nextern struct lowlevel_driver lowl_mswin;\n#endif\n#ifdef NEED_BFG_LOWL_PCI\nextern struct lowlevel_driver lowl_pci;\n#endif\n#ifdef HAVE_LIBUSB\nextern struct lowlevel_driver lowl_usb;\n#else\n// Dummy definition for the various \"don't warn if just a lower-level interface\" checks\nstatic __maybe_unused struct lowlevel_driver lowl_usb;\n#endif\n#ifdef NEED_BFG_LOWL_VCOM\nextern struct lowlevel_driver lowl_vcom;\n#endif\n\nextern struct device_drv *bfg_claim_any(struct device_drv *, const char *verbose, const char *devpath);\nextern struct device_drv *bfg_claim_any2(struct device_drv *, const char *verbose, const char *llname, const char *path);\n\n#endif\n"
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "make-release",
          "type": "blob",
          "size": 4.60546875,
          "content": "#!/bin/bash\n# Copyright 2012-2014 Luke Dashjr\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the Free\n# Software Foundation; either version 3 of the License, or (at your option)\n# any later version.  See COPYING for more details.\n\nset -e\nset -x\ntag=\"$1\"; shift\n[ -n \"$tag\" ] || exit 1\nsw=\"$1\"; shift || true\n[ -n \"$sw\" ] || sw=\"$tag\"\n\ntest -n \"$DEBUG_RELEASE\" || DEBUG_RELEASE=1\n\nbuilds=(win32 win64)\n\nwin32_machine='i686-pc-mingw32'\nwin32_CFLAGS='-march=i686'\n\nwin64_machine='x86_64-w64-mingw32'\nwin64_CFLAGS=''\n\nIDIR=\"$PWD\"\nOUTDIR=\"$PWD\"\nTMPROOT=\"$PWD/make-release-tmp\"\nTMPDIR=\"${TMPROOT}/${sw}-tmp\"\n\nmkdir -vp \"$TMPDIR\"\n\n# Source release\ngit branch TMP \"$tag\"\ngit clone . \"$TMPDIR\" -b TMP --depth 1\ngit branch -D TMP\ncd \"$TMPDIR\"\nsed 's/^\\[submodule \"\\(.*\\)\"\\]$/\\1/;t;d' .gitmodules |\n while read submodule; do\n\tgit config submodule.$submodule.url \"$IDIR/.git/modules/$submodule\"\ndone\ngit submodule update --init\n{\n\tgit archive --prefix \"$sw\"/ --format tar \"$tag\"\n\tgit submodule --quiet foreach --recursive 'test x$name = xccan || git archive --prefix \"'\"$sw\"'/$path/\" --format tar HEAD'\n\t(\n\t\tcd ccan-upstream\n\t\tgit archive --prefix \"$sw/ccan-upstream/\" --format tar HEAD ccan/{build_assert,cast,compiler,opt,typesafe_cb} licenses/{CC0,GPL-3,LGPL-2.1}\n\t)\n} | tar -xivp\nrm -r \"$sw\"/knc-asic/{*.rbf,*system,waas}\n./gen-version.sh >\"$sw\"/version.h\ncd \"$sw\"\nNOSUBMODULES=1 \\\nNOCONFIGURE=1 \\\n./autogen.sh\nfind . -name autom4te.cache |\n xargs rm -r\ncd ..\nzip -y -r \"$OUTDIR/${sw}.zip\" \"$sw\"\ntar -cJvpf \"$OUTDIR/${sw}.txz\" \"$sw\"\nSRCDIR=\"$TMPDIR/$sw\"\n\ndocs='\n\tAUTHORS\n\tCOPYING\n\tNEWS\n\tREADME\n\tREADME.ASIC\n\tREADME.FPGA\n\tREADME.GPU\n\tREADME.RPC\n\tREADME.scrypt\n'\nfor build in \"${builds[@]}\"; do\n\tPKGNAME=\"${sw}-${build}\"\n\tPKGDIR=\"$TMPDIR/$PKGNAME\"\n\tcd \"$SRCDIR\"\n\tmkdir -vp \"$PKGDIR\"\n\tfor v in machine CFLAGS; do\n\t\teval \"${v}\"=\"'$(eval echo \"\\${${build}_${v}}\")'\"\n\tdone\n\tif test \"x$DEBUG_RELEASE\" = \"x1\"; then\n\t\tCFLAGS=\"${CFLAGS} -g\"\n\tfi\n\tfor doc in $docs; do\n\t\tsed 's/$/\\r/' <\"$doc\" >\"$PKGDIR/${doc}.txt\"\n\tdone\n\t\n\t./configure \\\n\t\t--prefix='C:\\\\Program Files\\\\BFGMiner\\\\' \\\n\t\tCFLAGS=\"${CFLAGS} -Wall\" \\\n\t\t--disable-cpumining \\\n\t\t--enable-opencl \\\n\t\t--enable-adl \\\n\t\t--enable-bitforce \\\n\t\t--enable-icarus \\\n\t\t--enable-modminer \\\n\t\t--enable-ztex \\\n\t\t--enable-keccak \\\n\t\t--enable-scrypt \\\n\t\t--without-system-libbase58 \\\n\t\t--host=\"$machine\"\n\tmake $MAKEOPTS\n\tif test \"x$DEBUG_RELEASE\" != \"x1\"; then\n\t\t\"$machine\"-strip \\\n\t\t\tlibblkmaker/.libs/*.dll \\\n\t\t\tlibbase58/.libs/*.dll \\\n\t\t\t*.exe\n\tfi\n\tcp -vr \\\n\t\t*.exe \\\n\t\tlibblkmaker/.libs/*.dll \\\n\t\tlibbase58/.libs/*.dll \\\n\t\topencl \\\n\t\texample.conf \\\n\t\twindows-build.txt \\\n\t\tminer.php \\\n\t\t\"$PKGDIR/\"\n\tmkdir \"$PKGDIR/bitstreams\"\n\t\n\tls \"$PKGDIR\" | grep '\\.\\(exe\\|dll\\)$' |\n\t perl -e '\n\t\tuse strict;\n\t\tuse warnings;\n\t\tuse File::Basename;\n\t\tuse File::Glob;\n\t\t\n\t\tmy ($PKGDIR, $machine) = @ARGV;\n\t\tmy @todo = map { chomp; $_ } <STDIN>;\n\t\tmy %have = map { lc $_=>undef } (@todo, qw(\n\t\t\tadvapi32.dll\n\t\t\tcrypt32.dll\n\t\t\timagehlp.dll\n\t\t\tkernel32.dll\n\t\t\tmsvcrt.dll\n\t\t\tsetupapi.dll\n\t\t\tshell32.dll\n\t\t\tuser32.dll\n\t\t\twinmm.dll\n\t\t\tws2_32.dll\n\t\t\twsock32.dll\n\t\t));\n\t\t# Optional/dlopen libs\n\t\tpush @todo, qw(\n\t\t\tbacktrace.dll\n\t\t\tlibhidapi-0.dll\n\t\t\tlibfootest.dll\n\t\t);\n\t\tsub ciexist {\n\t\t\tmy ($f) = @_;\n\t\t\tmy $lcf = lc $f;\n\t\t\tfor my $match (File::Glob::bsd_glob(\"${f}*\", File::Glob::GLOB_CSH | File::Glob::GLOB_NOCASE)) {\n\t\t\t\tmy $matchlc = lc $match;\n\t\t\t\tif ($matchlc eq $lcf) {\n\t\t\t\t\treturn basename($match);\n\t\t\t\t}\n\t\t\t}\n\t\t\tundef\n\t\t}\n\t\tsub copydll {\n\t\t\tmy ($dlllc, $opt) = @_;\n\t\t\tmy $dll;\n\t\t\tmy $libdir;\n\t\t\tfor my $check_libdir (\n\t\t\t\t\"/usr/$machine/usr/lib\",\n\t\t\t\t\"/usr/$machine/usr/bin\",\n\t\t\t) {\n\t\t\t\t$dll = ciexist \"$check_libdir/${dlllc}\";\n\t\t\t\tif ($dll) {\n\t\t\t\t\t$libdir = $check_libdir;\n\t\t\t\t\tlast\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (not defined $libdir) {\n\t\t\t\treturn if $opt;\n\t\t\t\tdie \"Cannot find $dlllc\\n\"\n\t\t\t}\n\t\t\tsystem(\"cp -v -L \\\"$libdir/$dll\\\" \\\"$PKGDIR\\\"\") && die \"Copy $dll failed\\n\";\n\t\t\tsystem(\"\\\"${machine}-strip\\\" \\\"$PKGDIR/$dll\\\"\") && die \"Strip $dll failed\\n\";\n\t\t\tpush @todo, $dll;\n\t\t\t$have{$dlllc} = undef;\n\t\t\t1\n\t\t}\n\t\twhile (my $c = shift @todo) {\n\t\t\tif (not ciexist \"$PKGDIR/$c\") {\n\t\t\t\tcopydll $c, 1;\n\t\t\t\t# copydll will add it to @todo again if found\n\t\t\t\tnext\n\t\t\t}\n\t\t\t\n\t\t\tmy $found;\n\t\t\tprint(\"Processing dependencies for ${c}...\\n\");\n\t\t\tmy $objdump = `\"${machine}-objdump\" -p \"${PKGDIR}/${c}\"`;\n\t\t\twhile ($objdump =~ /\\G(?:\\n|.)*?^\\s*DLL Name\\:\\s*(.*)$/mg) {\n\t\t\t\tmy $dlllc = lc $1;\n\t\t\t\t++$found;\n\t\t\t\tnext if exists $have{$dlllc};\n\t\t\t\t\n\t\t\t\tcopydll $dlllc;\n\t\t\t}\n\t\t\tdie \"Failed to objdump $c\\n\" unless $found;\n\t\t}\n' \"$PKGDIR\" \"$machine\"\n\t\n\tmake clean\n\tcd \"$PKGDIR/..\"\n\tzip -r \"$OUTDIR/$PKGNAME.zip\" \"$PKGNAME\"\ndone\ncd \"$IDIR\"\n"
        },
        {
          "name": "malgo",
          "type": "tree",
          "content": null
        },
        {
          "name": "mcp2210.c",
          "type": "blob",
          "size": 7.7041015625,
          "content": "/*\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <utlist.h>\n\n#include \"logging.h\"\n#include \"lowlevel.h\"\n#include \"lowl-hid.h\"\n#include \"miner.h\"\n\n#include \"mcp2210.h\"\n\n#define MCP2210_IDVENDOR   0x04d8\n#define MCP2210_IDPRODUCT  0x00de\n\nstatic\nbool _mcp2210_devinfo_scan_cb(struct lowlevel_device_info * const usbinfo, void * const userp)\n{\n\tstruct lowlevel_device_info **devinfo_list_p = userp, *info;\n\t\n\tinfo = malloc(sizeof(*info));\n\t*info = (struct lowlevel_device_info){\n\t\t.lowl = &lowl_mcp2210,\n\t};\n\tlowlevel_devinfo_semicpy(info, usbinfo);\n\tLL_PREPEND(*devinfo_list_p, info);\n\t\n\t// Never *consume* the lowl_usb entry - especially since this is during the scan!\n\treturn false;\n}\n\nstatic\nstruct lowlevel_device_info *mcp2210_devinfo_scan()\n{\n\tstruct lowlevel_device_info *devinfo_list = NULL;\n\t\n\tlowlevel_detect_id(_mcp2210_devinfo_scan_cb, &devinfo_list, &lowl_hid, MCP2210_IDVENDOR, MCP2210_IDPRODUCT);\n\t\n\treturn devinfo_list;\n}\n\nstruct mcp2210_device {\n\thid_device *hid;\n\t\n\t// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 34\n\tuint8_t cfg_spi[0x11];\n\t// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 40\n\tuint8_t cfg_gpio[0xf];\n};\n\nstatic\nbool mcp2210_io(hid_device * const hid, uint8_t * const cmd, uint8_t * const buf)\n{\n\tchar hexcmd[(0x41 * 2) + 1];\n\tif (opt_dev_protocol)\n\t\tbin2hex(hexcmd, cmd, 0x41);\n\tconst bool rv = likely(\n\t\t0x41 == hid_write(hid, cmd, 0x41) &&\n\t\t64 == hid_read(hid, buf, 64)\n\t);\n\tif (opt_dev_protocol)\n\t{\n\t\tchar hexbuf[(0x40 * 2) + 1];\n\t\tbin2hex(hexbuf, buf, 0x40);\n\t\tapplog(LOG_DEBUG, \"mcp2210_io(%p, %s, %s)\", hid, hexcmd, hexbuf);\n\t}\n\treturn rv;\n}\n\nstatic\nbool mcp2210_get_configs(struct mcp2210_device * const h)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t cmd[0x41] = {0,0x41}, buf[0x40];\n\t\n\tif (!mcp2210_io(hid, cmd, buf))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to get current %s config\", __func__, \"SPI\");\n\t\treturn false;\n\t}\n\tmemcpy(h->cfg_spi, &buf[4], sizeof(h->cfg_spi));\n\t\n\tcmd[1] = 0x20;\n\tif (!mcp2210_io(hid, cmd, buf))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to get current %s config\", __func__, \"GPIO\");\n\t\treturn false;\n\t}\n\tmemcpy(h->cfg_gpio, &buf[4], sizeof(h->cfg_gpio));\n\t\n\treturn true;\n}\n\nstruct mcp2210_device *mcp2210_open(const struct lowlevel_device_info * const info)\n{\n\tstruct mcp2210_device *h;\n\tchar * const path = info->path;\n\thid_device * const hid = hid_open_path(path);\n\t\n\tif (unlikely(!hid))\n\t\treturn NULL;\n\t\n\th = malloc(sizeof(*h));\n\th->hid = hid;\n\t\n\tif (!mcp2210_get_configs(h))\n\t\tgoto fail;\n\t\n\treturn h;\n\nfail:\n\tfree(h);\n\treturn NULL;\n}\n\nvoid mcp2210_close(struct mcp2210_device * const h)\n{\n\thid_close(h->hid);\n\tfree(h);\n}\n\nstatic\nbool mcp2210_set_cfg_spi(struct mcp2210_device * const h)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t cmd[0x41] = {0,0x40}, buf[0x40];\n\tmemcpy(&cmd[5], h->cfg_spi, sizeof(h->cfg_spi));\n\tif (!mcp2210_io(hid, cmd, buf))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to set current %s config\", __func__, \"SPI\");\n\t\treturn false;\n\t}\n\t\n\tif (buf[1] != 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting current %s config (%d)\", __func__, \"SPI\", buf[1]);\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nbool mcp2210_configure_spi(struct mcp2210_device * const h, const uint32_t bitrate, const uint16_t idlechipsel, const uint16_t activechipsel, const uint16_t chipseltodatadelay, const uint16_t lastbytetocsdelay, const uint16_t midbytedelay)\n{\n\tuint8_t * const cfg = h->cfg_spi;\n\t\n\tcfg[0] = (bitrate >> 0x00) & 0xff;\n\tcfg[1] = (bitrate >> 0x08) & 0xff;\n\tcfg[2] = (bitrate >> 0x10) & 0xff;\n\tcfg[3] = (bitrate >> 0x18) & 0xff;\n\t\n\tcfg[4] = (  idlechipsel >> 0) & 0xff;\n\tcfg[5] = (  idlechipsel >> 8) & 0xff;\n\t\n\tcfg[6] = (activechipsel >> 0) & 0xff;\n\tcfg[7] = (activechipsel >> 8) & 0xff;\n\t\n\tcfg[8] = (chipseltodatadelay >> 0) & 0xff;\n\tcfg[9] = (chipseltodatadelay >> 8) & 0xff;\n\t\n\tcfg[0xa] = (lastbytetocsdelay >> 0) & 0xff;\n\tcfg[0xb] = (lastbytetocsdelay >> 8) & 0xff;\n\t\n\tcfg[0xc] = (midbytedelay >> 0) & 0xff;\n\tcfg[0xd] = (midbytedelay >> 8) & 0xff;\n\t\n\treturn mcp2210_set_cfg_spi(h);\n}\n\nbool mcp2210_set_spimode(struct mcp2210_device * const h, const uint8_t spimode)\n{\n\tuint8_t * const cfg = h->cfg_spi;\n\tcfg[0x10] = spimode;\n\treturn mcp2210_set_cfg_spi(h);\n}\n\nbool mcp2210_spi_transfer(struct mcp2210_device * const h, const void * const tx, void * const rx, uint8_t sz)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t * const cfg = h->cfg_spi;\n\tuint8_t cmd[0x41] = {0,0x42}, buf[0x40];\n\tuint8_t *p = rx;\n\t\n\tif (unlikely(sz > 60))\n\t{\n\t\tapplog(LOG_ERR, \"%s: SPI transfer too long (%d bytes)\", __func__, sz);\n\t\treturn false;\n\t}\n\t\n\tcfg[0xe] = sz;\n\tcfg[0xf] = 0;\n\tif (!mcp2210_set_cfg_spi(h))\n\t\treturn false;\n\t\n\tcmd[2] = sz;\n\tmemcpy(&cmd[5], tx, sz);\n\tif (unlikely(!mcp2210_io(hid, cmd, buf)))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to issue SPI transfer\", __func__);\n\t\treturn false;\n\t}\n\t\n\twhile (true)\n\t{\n\t\tswitch (buf[1])\n\t\t{\n\t\t\tcase 0:     // accepted\n\t\t\t\tcmd[2] = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0xf8:  // transfer in progress\n\t\t\t\tif (opt_dev_protocol)\n\t\t\t\t\tapplog(LOG_DEBUG, \"%s: SPI transfer rejected temporarily (%d bytes remaining)\", __func__, sz);\n\t\t\t\tcgsleep_ms(20);\n\t\t\t\tgoto retry;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_ERR, \"%s: SPI transfer error (%d) (%d bytes remaining)\", __func__, buf[1], sz);\n\t\t\t\treturn false;\n\t\t}\n\t\tif (buf[2] >= sz)\n\t\t{\n\t\t\tif (buf[2] > sz)\n\t\t\t\tapplog(LOG_WARNING, \"%s: Received %d extra bytes in SPI transfer\", __func__, sz - buf[2]);\n\t\t\tmemcpy(p, &buf[4], sz);\n\t\t\treturn true;\n\t\t}\n\t\tmemcpy(p, &buf[4], buf[2]);\n\t\tp += buf[2];\n\t\tsz -= buf[2];\nretry:\n\t\tif (unlikely(!mcp2210_io(hid, cmd, buf)))\n\t\t{\n\t\t\tapplog(LOG_ERR, \"%s: Failed to continue SPI transfer (%d bytes remaining)\", __func__, sz);\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool mcp2210_spi_cancel(struct mcp2210_device * const h)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t cmd[0x41] = {0,0x11}, buf[0x40];\n\t\n\tif (!mcp2210_io(hid, cmd, buf))\n\t\treturn false;\n\t\n\treturn (buf[1] == 0);\n}\n\nstatic\nbool mcp2210_set_cfg_gpio(struct mcp2210_device * const h)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t cmd[0x41] = {0,0x21}, buf[0x40];\n\t\n\t// NOTE: NVRAM chip params access control is not set here\n\tmemcpy(&cmd[5], h->cfg_gpio, 0xe);\n\tif (!mcp2210_io(hid, cmd, buf))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to set current %s config\", __func__, \"GPIO\");\n\t\treturn false;\n\t}\n\t\n\tif (buf[1] != 0)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error setting current %s config (%d)\", __func__, \"GPIO\", buf[1]);\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nbool mcp2210_set_gpio_output(struct mcp2210_device * const h, const int pin, const enum bfg_gpio_value d)\n{\n\tconst int bit = 1 << (pin % 8);\n\tconst int byte = (pin / 8);\n\t\n\t// Set pin to GPIO mode\n\th->cfg_gpio[pin] = 0;\n\t\n\t// Set GPIO to output mode\n\th->cfg_gpio[byte + 0xb] &= ~bit;\n\t\n\t// Set value for GPIO output\n\tif (d == BGV_HIGH)\n\t\th->cfg_gpio[byte + 9] |= bit;\n\telse\n\t\th->cfg_gpio[byte + 9] &= ~bit;\n\t\n\treturn mcp2210_set_cfg_gpio(h);\n}\n\nenum bfg_gpio_value mcp2210_get_gpio_input(struct mcp2210_device * const h, const int pin)\n{\n\thid_device * const hid = h->hid;\n\tuint8_t cmd[0x41] = {0,0x31}, buf[0x40];\n\tconst int bit = 1 << (pin % 8);\n\tconst int byte = (pin / 8);\n\t\n\t// Set pin to GPIO mode\n\th->cfg_gpio[pin] = 0;\n\t\n\t// Set GPIO to input mode\n\th->cfg_gpio[byte + 0xb] |= bit;\n\t\n\tif (!mcp2210_set_cfg_gpio(h))\n\t\treturn BGV_ERROR;\n\t\n\tif (!mcp2210_io(hid, cmd, buf))\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to get current GPIO input values\", __func__);\n\t\treturn BGV_ERROR;\n\t}\n\t\n\tif (buf[byte + 4] & bit)\n\t\treturn BGV_HIGH;\n\telse\n\t\treturn BGV_LOW;\n}\n\nstruct lowlevel_driver lowl_mcp2210 = {\n\t.dname = \"mcp2210\",\n\t.devinfo_scan = mcp2210_devinfo_scan,\n};\n"
        },
        {
          "name": "mcp2210.h",
          "type": "blob",
          "size": 0.9013671875,
          "content": "#ifndef BFG_MCP2210_H\n#define BFG_MCP2210_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\nenum mcp2210_gpio_direction {\n\tMGD_OUTPUT,\n\tMGD_INPUT,\n};\n\nstruct mcp2210_device;\n\nextern struct mcp2210_device *mcp2210_open(const struct lowlevel_device_info *);\nextern void mcp2210_close(struct mcp2210_device *);\n\nextern bool mcp2210_spi_cancel(struct mcp2210_device *);\nextern bool mcp2210_configure_spi(struct mcp2210_device *, uint32_t bitrate, uint16_t idlechipsel, uint16_t activechipsel, uint16_t chipseltodatadelay, uint16_t lastbytetocsdelay, uint16_t midbytedelay);\nextern bool mcp2210_set_spimode(struct mcp2210_device *, uint8_t spimode);\nextern bool mcp2210_spi_transfer(struct mcp2210_device *, const void *tx, void *rx, uint8_t sz);\n\nextern bool mcp2210_set_gpio_output(struct mcp2210_device *, int pin, enum bfg_gpio_value);\nextern enum bfg_gpio_value mcp2210_get_gpio_input(struct mcp2210_device *, int pin);\n\n#endif\n"
        },
        {
          "name": "miner.c",
          "type": "blob",
          "size": 360.71484375,
          "content": "/*\n * Copyright 2011-2014 Con Kolivas\n * Copyright 2011-2017 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2012-2014 Andrew Smith\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#ifdef HAVE_CURSES\n#ifdef USE_UNICODE\n#define PDC_WIDE\n#endif\n// Must be before stdbool, since pdcurses typedefs bool :/\n#include <curses.h>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <signal.h>\n#include <wctype.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n\n#ifndef WIN32\n#include <sys/resource.h>\n#include <sys/socket.h>\n#if defined(HAVE_LIBUDEV) && defined(HAVE_SYS_EPOLL_H)\n#include <libudev.h>\n#include <sys/epoll.h>\n#define HAVE_BFG_HOTPLUG\n#endif\n#else\n#include <winsock2.h>\n#include <windows.h>\n#include <dbt.h>\n#define HAVE_BFG_HOTPLUG\n#endif\n#include <ccan/opt/opt.h>\n#include <jansson.h>\n#include <curl/curl.h>\n#include <libgen.h>\n#include <sha2.h>\n#include <utlist.h>\n\n#include <blkmaker.h>\n#include <blkmaker_jansson.h>\n#include <blktemplate.h>\n#include <libbase58.h>\n\n#include \"compat.h\"\n#include \"deviceapi.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"adl.h\"\n#include \"driver-cpu.h\"\n#include \"driver-opencl.h\"\n#include \"util.h\"\n\n#ifdef USE_AVALON\n#include \"driver-avalon.h\"\n#endif\n\n#ifdef HAVE_BFG_LOWLEVEL\n#include \"lowlevel.h\"\n#endif\n\n#if defined(unix) || defined(__APPLE__)\n\t#include <errno.h>\n\t#include <fcntl.h>\n\t#include <sys/wait.h>\n#endif\n\n#ifdef USE_SCRYPT\n#include \"malgo/scrypt.h\"\n#endif\n\n#if defined(USE_AVALON) || defined(USE_BITFORCE) || defined(USE_ICARUS) || defined(USE_MODMINER) || defined(USE_NANOFURY) || defined(USE_X6500) || defined(USE_ZTEX)\n#\tdefine USE_FPGA\n#endif\n\nenum bfg_quit_summary {\n\tBQS_DEFAULT,\n\tBQS_NONE,\n\tBQS_DEVS,\n\tBQS_PROCS,\n\tBQS_DETAILED,\n};\n\nstruct strategies strategies[] = {\n\t{ \"Failover\" },\n\t{ \"Round Robin\" },\n\t{ \"Rotate\" },\n\t{ \"Load Balance\" },\n\t{ \"Balance\" },\n};\n\n#define packagename bfgminer_name_space_ver\n\nbool opt_protocol;\nbool opt_dev_protocol;\nstatic bool opt_benchmark, opt_benchmark_intense;\nstatic bool want_longpoll = true;\nstatic bool want_gbt = true;\nstatic bool want_getwork = true;\n#if BLKMAKER_VERSION > 1\nstatic bool opt_load_bitcoin_conf = true;\nstatic uint32_t coinbase_script_block_id;\nstatic uint32_t template_nonce;\n#endif\n#if BLKMAKER_VERSION > 0\nchar *opt_coinbase_sig;\n#endif\nstatic enum bfg_quit_summary opt_quit_summary = BQS_DEFAULT;\nstatic bool include_serial_in_statline;\nchar *request_target_str;\nfloat request_pdiff = 1.0;\ndouble request_bdiff;\nstatic bool want_stratum = true;\nint opt_skip_checks;\nbool want_per_device_stats;\nbool use_syslog;\nbool opt_quiet_work_updates = true;\nbool opt_quiet;\nbool opt_realquiet;\nint loginput_size;\nbool opt_compact;\nbool opt_show_procs;\nconst int opt_cutofftemp = 95;\nint opt_hysteresis = 3;\nstatic int opt_retries = -1;\nint opt_fail_pause = 5;\nint opt_log_interval = 20;\nint opt_queue = 1;\nint opt_scantime = 60;\nint opt_expiry = 120;\nint opt_expiry_lp = 3600;\nunsigned long long global_hashrate;\nstatic bool opt_unittest = false;\nunsigned unittest_failures;\nunsigned long global_quota_gcd = 1;\ntime_t last_getwork;\n\n#ifdef USE_OPENCL\nint opt_dynamic_interval = 7;\nint nDevs;\nint opt_g_threads = -1;\n#endif\n#ifdef USE_SCRYPT\nstatic char detect_algo = 1;\n#else\nstatic char detect_algo;\n#endif\nbool opt_restart = true;\n\n#ifdef USE_LIBMICROHTTPD\n#include \"httpsrv.h\"\nint httpsrv_port = -1;\n#endif\n#ifdef USE_LIBEVENT\nlong stratumsrv_port = -1;\n#endif\n\nconst\nint rescan_delay_ms = 1000;\n#ifdef HAVE_BFG_HOTPLUG\nbool opt_hotplug = 1;\nconst\nint hotplug_delay_ms = 100;\n#else\nconst bool opt_hotplug;\n#endif\nstruct string_elist *scan_devices;\nstatic struct string_elist *opt_set_device_list;\nbool opt_force_dev_init;\nstatic struct string_elist *opt_devices_enabled_list;\nstatic bool opt_display_devs;\nint total_devices;\nstruct cgpu_info **devices;\nint total_devices_new;\nstruct cgpu_info **devices_new;\nbool have_opencl;\nint opt_n_threads = -1;\nint mining_threads;\nint base_queue;\nint num_processors;\n#ifdef HAVE_CURSES\nbool use_curses = true;\n#else\nbool use_curses;\n#endif\nint last_logstatusline_len;\n#ifdef HAVE_LIBUSB\nbool have_libusb;\n#endif\nstatic bool opt_submit_stale = true;\nstatic float opt_shares;\nstatic int opt_submit_threads = 0x40;\nbool opt_fail_only;\nint opt_fail_switch_delay = 300;\nbool opt_autofan;\nbool opt_autoengine;\nbool opt_noadl;\nchar *opt_api_allow = NULL;\nchar *opt_api_groups;\nchar *opt_api_description = PACKAGE_STRING;\nint opt_api_port = 4028;\nbool opt_api_listen;\nbool opt_api_mcast;\nchar *opt_api_mcast_addr = API_MCAST_ADDR;\nchar *opt_api_mcast_code = API_MCAST_CODE;\nchar *opt_api_mcast_des = \"\";\nint opt_api_mcast_port = 4028;\nbool opt_api_network;\nbool opt_delaynet;\nbool opt_disable_pool;\nbool opt_disable_client_reconnect = false;\nstatic bool no_work;\nbool opt_worktime;\nbool opt_weighed_stats;\n\nchar *opt_kernel_path;\nchar *cgminer_path;\n\n#if defined(USE_BITFORCE)\nbool opt_bfl_noncerange;\n#endif\n#define QUIET\t(opt_quiet || opt_realquiet)\n\nstruct thr_info *control_thr;\nstruct thr_info **mining_thr;\nstatic int watchpool_thr_id;\nstatic int watchdog_thr_id;\n#ifdef HAVE_CURSES\nstatic int input_thr_id;\n#endif\nint gpur_thr_id;\nstatic int api_thr_id;\nstatic int total_control_threads;\n\npthread_mutex_t hash_lock;\nstatic pthread_mutex_t *stgd_lock;\npthread_mutex_t console_lock;\ncglock_t ch_lock;\nstatic pthread_rwlock_t blk_lock;\nstatic pthread_mutex_t sshare_lock;\n\npthread_rwlock_t netacc_lock;\npthread_rwlock_t mining_thr_lock;\npthread_rwlock_t devices_lock;\n\nstatic pthread_mutex_t lp_lock;\nstatic pthread_cond_t lp_cond;\n\npthread_cond_t gws_cond;\n\nbool shutting_down;\n\ndouble total_rolling;\ndouble total_mhashes_done;\nstatic struct timeval total_tv_start, total_tv_end;\nstatic struct timeval miner_started;\n\ncglock_t control_lock;\npthread_mutex_t stats_lock;\n\nstatic pthread_mutex_t submitting_lock;\nstatic int total_submitting;\nstatic struct work *submit_waiting;\nnotifier_t submit_waiting_notifier;\n\nint hw_errors;\nint total_accepted, total_rejected;\nint total_getworks, total_stale, total_discarded;\nuint64_t total_bytes_rcvd, total_bytes_sent;\ndouble total_diff1, total_bad_diff1;\ndouble total_diff_accepted, total_diff_rejected, total_diff_stale;\nstatic int staged_rollable, staged_spare;\nunsigned int new_blocks;\nunsigned int found_blocks;\n\nunsigned int local_work;\nunsigned int total_go, total_ro;\n\nstruct pool **pools;\nstatic struct pool *currentpool = NULL;\n\nint total_pools, enabled_pools;\nenum pool_strategy pool_strategy = POOL_FAILOVER;\nint opt_rotate_period;\nstatic int total_urls, total_users, total_passes;\n\nstatic\n#ifndef HAVE_CURSES\nconst\n#endif\nbool curses_active;\n\n#ifdef HAVE_CURSES\n#if !(defined(PDCURSES) || defined(NCURSES_VERSION))\nconst\n#endif\nshort default_bgcolor = COLOR_BLACK;\nstatic int attr_title = A_BOLD;\n#endif\n\nstatic\n#if defined(HAVE_CURSES) && defined(USE_UNICODE)\nbool use_unicode;\nstatic\nbool have_unicode_degrees;\nstatic\nwchar_t unicode_micro = 'u';\n#else\nconst bool use_unicode;\nstatic\nconst bool have_unicode_degrees;\n#ifdef HAVE_CURSES\nstatic\nconst char unicode_micro = 'u';\n#endif\n#endif\n\n#ifdef HAVE_CURSES\n#define U8_BAD_START \"\\xef\\x80\\x81\"\n#define U8_BAD_END   \"\\xef\\x80\\x80\"\n#define AS_BAD(x) U8_BAD_START x U8_BAD_END\n\n/* logstart is where the log window should start */\nstatic int devcursor, logstart, logcursor;\n\nbool selecting_device;\nunsigned selected_device;\n#endif\n\nstatic int max_lpdigits;\n\n// current_hash was replaced with goal->current_goal_detail\n// current_block_id was replaced with blkchain->currentblk->block_id\n\nstatic char datestamp[40];\nstatic char best_share[ALLOC_H2B_SHORTV] = \"0\";\ndouble best_diff = 0;\n\nstruct mining_algorithm *mining_algorithms;\nstruct mining_goal_info *mining_goals;\nint active_goals = 1;\n\n\nint swork_id;\n\n/* For creating a hash database of stratum shares submitted that have not had\n * a response yet */\nstruct stratum_share {\n\tUT_hash_handle hh;\n\tbool block;\n\tstruct work *work;\n\tint id;\n};\n\nstatic struct stratum_share *stratum_shares = NULL;\n\nchar *opt_socks_proxy = NULL;\n\nstatic const char def_conf[] = \"bfgminer.conf\";\nstatic bool config_loaded;\nstatic int include_count;\n#define JSON_INCLUDE_CONF \"include\"\n#define JSON_LOAD_ERROR \"JSON decode of file '%s' failed\\n %s\"\n#define JSON_LOAD_ERROR_LEN strlen(JSON_LOAD_ERROR)\n#define JSON_MAX_DEPTH 10\n#define JSON_MAX_DEPTH_ERR \"Too many levels of JSON includes (limit 10) or a loop\"\n#define JSON_WEB_ERROR \"WEB config err\"\n\nchar *cmd_idle, *cmd_sick, *cmd_dead;\n\n#if defined(unix) || defined(__APPLE__)\n\tstatic char *opt_stderr_cmd = NULL;\n\tstatic int forkpid;\n#endif // defined(unix)\n\n#ifdef HAVE_CHROOT\nchar *chroot_dir;\n#endif\n\n#ifdef HAVE_PWD_H\nchar *opt_setuid;\n#endif\n\nstruct sigaction termhandler, inthandler;\n\nstruct thread_q *getq;\n\nstatic int total_work;\nstatic bool staged_full;\nstruct work *staged_work = NULL;\n\nstruct schedtime {\n\tbool enable;\n\tstruct tm tm;\n};\n\nstruct schedtime schedstart;\nstruct schedtime schedstop;\nbool sched_paused;\n\nstatic bool time_before(struct tm *tm1, struct tm *tm2)\n{\n\tif (tm1->tm_hour < tm2->tm_hour)\n\t\treturn true;\n\tif (tm1->tm_hour == tm2->tm_hour && tm1->tm_min < tm2->tm_min)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool should_run(void)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tbool within_range;\n\n\tif (!schedstart.enable && !schedstop.enable)\n\t\treturn true;\n\n\ttt = time(NULL);\n\tlocaltime_r(&tt, &tm);\n\n\t// NOTE: This is delicately balanced so that should_run is always false if schedstart==schedstop\n\tif (time_before(&schedstop.tm, &schedstart.tm))\n\t\twithin_range = (time_before(&tm, &schedstop.tm) || !time_before(&tm, &schedstart.tm));\n\telse\n\t\twithin_range = (time_before(&tm, &schedstop.tm) && !time_before(&tm, &schedstart.tm));\n\n\tif (within_range && !schedstop.enable)\n\t\t/* This is a once off event with no stop time set */\n\t\tschedstart.enable = false;\n\n\treturn within_range;\n}\n\nvoid get_datestamp(char *f, size_t fsiz, time_t tt)\n{\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\t\n\tif (tt == INVALID_TIMESTAMP)\n\t\ttt = time(NULL);\n\n\tlocaltime_r(&tt, tm);\n\tsnprintf(f, fsiz, \"[%d-%02d-%02d %02d:%02d:%02d]\",\n\t\ttm->tm_year + 1900,\n\t\ttm->tm_mon + 1,\n\t\ttm->tm_mday,\n\t\ttm->tm_hour,\n\t\ttm->tm_min,\n\t\ttm->tm_sec);\n}\n\nstatic\nvoid get_timestamp(char *f, size_t fsiz, time_t tt)\n{\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\n\tlocaltime_r(&tt, tm);\n\tsnprintf(f, fsiz, \"[%02d:%02d:%02d]\",\n\t\ttm->tm_hour,\n\t\ttm->tm_min,\n\t\ttm->tm_sec);\n}\n\nstatic void applog_and_exit(const char *fmt, ...) FORMAT_SYNTAX_CHECK(printf, 1, 2);\n\nstatic char exit_buf[512];\n\nstatic void applog_and_exit(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(exit_buf, sizeof(exit_buf), fmt, ap);\n\tva_end(ap);\n\t_applog(LOG_ERR, exit_buf);\n\texit(1);\n}\n\nstatic\nfloat drv_min_nonce_diff(const struct device_drv * const drv, struct cgpu_info * const proc, const struct mining_algorithm * const malgo)\n{\n\tif (drv->drv_min_nonce_diff)\n\t\treturn drv->drv_min_nonce_diff(proc, malgo);\n#ifdef USE_SHA256D\n\treturn (malgo->algo == POW_SHA256D) ? 1. : -1.;\n#else\n\treturn -1.;\n#endif\n}\n\nchar *devpath_to_devid(const char *devpath)\n{\n#ifndef WIN32\n\tif (devpath[0] != '/')\n\t\treturn NULL;\n\tstruct stat my_stat;\n\tif (stat(devpath, &my_stat))\n\t\treturn NULL;\n\tchar *devs = malloc(6 + (sizeof(dev_t) * 2) + 1);\n\tmemcpy(devs, \"dev_t:\", 6);\n\tbin2hex(&devs[6], &my_stat.st_rdev, sizeof(dev_t));\n#else\n\tif (!strncmp(devpath, \"\\\\\\\\.\\\\\", 4))\n\t\tdevpath += 4;\n\tif (strncasecmp(devpath, \"COM\", 3) || !devpath[3])\n\t\treturn NULL;\n\tdevpath += 3;\n\tchar *p;\n\tstrtol(devpath, &p, 10);\n\tif (p[0])\n\t\treturn NULL;\n\tconst int sz = (p - devpath);\n\tchar *devs = malloc(4 + sz + 1);\n\tsprintf(devs, \"com:%s\", devpath);\n#endif\n\treturn devs;\n}\n\nstatic\nbool devpaths_match(const char * const ap, const char * const bp)\n{\n\tchar * const a = devpath_to_devid(ap);\n\tif (!a)\n\t\treturn false;\n\tchar * const b = devpath_to_devid(bp);\n\tbool rv = false;\n\tif (b)\n\t{\n\t\trv = !strcmp(a, b);\n\t\tfree(b);\n\t}\n\tfree(a);\n\treturn rv;\n}\n\nstatic\nint proc_letter_to_number(const char *s, const char ** const rem)\n{\n\tint n = 0, c;\n\tfor ( ; s[0]; ++s)\n\t{\n\t\tif (unlikely(n > INT_MAX / 26))\n\t\t\tbreak;\n\t\tc = tolower(s[0]) - 'a';\n\t\tif (unlikely(c < 0 || c > 25))\n\t\t\tbreak;\n\t\tif (unlikely(INT_MAX - c < n))\n\t\t\tbreak;\n\t\tn = (n * 26) + c;\n\t}\n\t*rem = s;\n\treturn n;\n}\n\nstatic\nbool cgpu_match(const char * const pattern, const struct cgpu_info * const cgpu)\n{\n\t// all - matches anything\n\t// d0 - matches all processors of device 0\n\t// d0-3 - matches all processors of device 0, 1, 2, or 3\n\t// d0a - matches first processor of device 0\n\t// 0 - matches processor 0\n\t// 0-4 - matches processors 0, 1, 2, 3, or 4\n\t// ___ - matches all processors on all devices using driver/name ___\n\t// ___0 - matches all processors of 0th device using driver/name ___\n\t// ___0a - matches first processor of 0th device using driver/name ___\n\t// @* - matches device with serial or path *\n\t// @*@a - matches first processor of device with serial or path *\n\t// ___@* - matches device with serial or path * using driver/name ___\n\tif (!strcasecmp(pattern, \"all\"))\n\t\treturn true;\n\t\n\tconst struct device_drv * const drv = cgpu->drv;\n\tconst char *p = pattern, *p2;\n\tsize_t L;\n\tint n, i, c = -1;\n\tint n2;\n\tint proc_first = -1, proc_last = -1;\n\tstruct cgpu_info *device;\n\t\n\tif (!(strncasecmp(drv->dname, p, (L = strlen(drv->dname)))\n\t   && strncasecmp(drv-> name, p, (L = strlen(drv-> name)))))\n\t\t// dname or name\n\t\tp = &pattern[L];\n\telse\n\tif (p[0] == 'd' && (isdigit(p[1]) || p[1] == '-'))\n\t\t// d#\n\t\t++p;\n\telse\n\tif (isdigit(p[0]) || p[0] == '@' || p[0] == '-')\n\t\t// # or @\n\t\t{}\n\telse\n\t\treturn false;\n\t\n\tL = p - pattern;\n\twhile (isspace(p[0]))\n\t\t++p;\n\tif (p[0] == '@')\n\t{\n\t\t// Serial/path\n\t\tconst char * const ser = &p[1];\n\t\tfor (p = ser; p[0] != '@' && p[0] != '\\0'; ++p)\n\t\t{}\n\t\tp2 = (p[0] == '@') ? &p[1] : p;\n\t\tconst size_t serlen = (p - ser);\n\t\tp = \"\";\n\t\tn = n2 = 0;\n\t\tconst char * const devpath = cgpu->device_path ?: \"\";\n\t\tconst char * const devser = cgpu->dev_serial ?: \"\";\n\t\tif ((!strncmp(devpath, ser, serlen)) && devpath[serlen] == '\\0')\n\t\t{}  // Match\n\t\telse\n\t\tif ((!strncmp(devser, ser, serlen)) && devser[serlen] == '\\0')\n\t\t{}  // Match\n\t\telse\n\t\t{\n\t\t\tchar devpath2[serlen + 1];\n\t\t\tmemcpy(devpath2, ser, serlen);\n\t\t\tdevpath2[serlen] = '\\0';\n\t\t\tif (!devpaths_match(devpath, ser))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (isdigit(p[0]))\n\t\t\tn = strtol(p, (void*)&p2, 0);\n\t\telse\n\t\t{\n\t\t\tn = 0;\n\t\t\tp2 = p;\n\t\t}\n\t\tif (p2[0] == '-')\n\t\t{\n\t\t\t++p2;\n\t\t\tif (p2[0] && isdigit(p2[0]))\n\t\t\t\tn2 = strtol(p2, (void*)&p2, 0);\n\t\t\telse\n\t\t\t\tn2 = INT_MAX;\n\t\t}\n\t\telse\n\t\t\tn2 = n;\n\t\tif (p == pattern)\n\t\t{\n\t\t\tif (!p[0])\n\t\t\t\treturn true;\n\t\t\tif (p2 && p2[0])\n\t\t\t\tgoto invsyntax;\n\t\t\tfor (i = n; i <= n2; ++i)\n\t\t\t{\n\t\t\t\tif (i >= total_devices)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cgpu == devices[i])\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tif (p2[0])\n\t{\n\t\tproc_first = proc_letter_to_number(&p2[0], &p2);\n\t\tif (p2[0] == '-')\n\t\t{\n\t\t\t++p2;\n\t\t\tif (p2[0])\n\t\t\t\tproc_last = proc_letter_to_number(p2, &p2);\n\t\t\telse\n\t\t\t\tproc_last = INT_MAX;\n\t\t}\n\t\telse\n\t\t\tproc_last = proc_first;\n\t\tif (p2[0])\n\t\t\tgoto invsyntax;\n\t}\n\t\n\tif (L > 1 || tolower(pattern[0]) != 'd' || !p[0])\n\t{\n\t\tif ((L == 3 && !strncasecmp(pattern, drv->name, 3)) ||\n\t\t\t(!L) ||\n\t\t\t(L == strlen(drv->dname) && !strncasecmp(pattern, drv->dname, L)))\n\t\t\t{}  // Matched name or dname\n\t\telse\n\t\t\treturn false;\n\t\tif (p[0] && (cgpu->device_id < n || cgpu->device_id > n2))\n\t\t\treturn false;\n\t\tif (proc_first != -1 && (cgpu->proc_id < proc_first || cgpu->proc_id > proc_last))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t// d#\n\t\n\tc = -1;\n\tfor (i = 0; ; ++i)\n\t{\n\t\tif (i == total_devices)\n\t\t\treturn false;\n\t\tif (devices[i]->device != devices[i])\n\t\t\tcontinue;\n\t\t++c;\n\t\tif (c < n)\n\t\t\tcontinue;\n\t\tif (c > n2)\n\t\t\tbreak;\n\t\t\n\t\tfor (device = devices[i]; device; device = device->next_proc)\n\t\t{\n\t\t\tif (proc_first != -1 && (device->proc_id < proc_first || device->proc_id > proc_last))\n\t\t\t\tcontinue;\n\t\t\tif (device == cgpu)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\ninvsyntax:\n\tapplog(LOG_WARNING, \"%s: Invalid syntax: %s\", __func__, pattern);\n\treturn false;\n}\n\n#define TEST_CGPU_MATCH(pattern)  \\\n\tif (!cgpu_match(pattern, &cgpu))  \\\n\t{  \\\n\t\t++unittest_failures;  \\\n\t\tapplog(LOG_ERR, \"%s: Pattern \\\"%s\\\" should have matched!\", __func__, pattern);  \\\n\t}  \\\n// END TEST_CGPU_MATCH\n#define TEST_CGPU_NOMATCH(pattern)  \\\n\tif (cgpu_match(pattern, &cgpu))  \\\n\t{  \\\n\t\t++unittest_failures;  \\\n\t\tapplog(LOG_ERR, \"%s: Pattern \\\"%s\\\" should NOT have matched!\", __func__, pattern);  \\\n\t}  \\\n// END TEST_CGPU_MATCH\nstatic __maybe_unused\nvoid test_cgpu_match()\n{\n\tstruct device_drv drv = {\n\t\t.dname = \"test\",\n\t\t.name = \"TST\",\n\t};\n\tstruct cgpu_info cgpu = {\n\t\t.drv = &drv,\n\t\t.device = &cgpu,\n\t\t.device_id = 1,\n\t\t.proc_id = 1,\n\t\t.proc_repr = \"TST 1b\",\n\t}, cgpu0a = {\n\t\t.drv = &drv,\n\t\t.device = &cgpu0a,\n\t\t.device_id = 0,\n\t\t.proc_id = 0,\n\t\t.proc_repr = \"TST 0a\",\n\t}, cgpu1a = {\n\t\t.drv = &drv,\n\t\t.device = &cgpu0a,\n\t\t.device_id = 1,\n\t\t.proc_id = 0,\n\t\t.proc_repr = \"TST 1a\",\n\t};\n\tstruct cgpu_info *devices_list[3] = {&cgpu0a, &cgpu1a, &cgpu,};\n\tdevices = devices_list;\n\ttotal_devices = 3;\n\tTEST_CGPU_MATCH(\"all\")\n\tTEST_CGPU_MATCH(\"d1\")\n\tTEST_CGPU_NOMATCH(\"d2\")\n\tTEST_CGPU_MATCH(\"d0-5\")\n\tTEST_CGPU_NOMATCH(\"d0-0\")\n\tTEST_CGPU_NOMATCH(\"d2-5\")\n\tTEST_CGPU_MATCH(\"d-1\")\n\tTEST_CGPU_MATCH(\"d1-\")\n\tTEST_CGPU_NOMATCH(\"d-0\")\n\tTEST_CGPU_NOMATCH(\"d2-\")\n\tTEST_CGPU_MATCH(\"2\")\n\tTEST_CGPU_NOMATCH(\"3\")\n\tTEST_CGPU_MATCH(\"1-2\")\n\tTEST_CGPU_MATCH(\"2-3\")\n\tTEST_CGPU_NOMATCH(\"1-1\")\n\tTEST_CGPU_NOMATCH(\"3-4\")\n\tTEST_CGPU_MATCH(\"TST\")\n\tTEST_CGPU_MATCH(\"test\")\n\tTEST_CGPU_MATCH(\"tst\")\n\tTEST_CGPU_MATCH(\"TEST\")\n\tTEST_CGPU_NOMATCH(\"TSF\")\n\tTEST_CGPU_NOMATCH(\"TS\")\n\tTEST_CGPU_NOMATCH(\"TSTF\")\n\tTEST_CGPU_MATCH(\"TST1\")\n\tTEST_CGPU_MATCH(\"test1\")\n\tTEST_CGPU_MATCH(\"TST0-1\")\n\tTEST_CGPU_MATCH(\"TST 1\")\n\tTEST_CGPU_MATCH(\"TST 1-2\")\n\tTEST_CGPU_MATCH(\"TEST 1-2\")\n\tTEST_CGPU_NOMATCH(\"TST2\")\n\tTEST_CGPU_NOMATCH(\"TST2-3\")\n\tTEST_CGPU_NOMATCH(\"TST0-0\")\n\tTEST_CGPU_MATCH(\"TST1b\")\n\tTEST_CGPU_MATCH(\"tst1b\")\n\tTEST_CGPU_NOMATCH(\"TST1c\")\n\tTEST_CGPU_NOMATCH(\"TST1bb\")\n\tTEST_CGPU_MATCH(\"TST0-1b\")\n\tTEST_CGPU_NOMATCH(\"TST0-1c\")\n\tTEST_CGPU_MATCH(\"TST1a-d\")\n\tTEST_CGPU_NOMATCH(\"TST1a-a\")\n\tTEST_CGPU_NOMATCH(\"TST1-a\")\n\tTEST_CGPU_NOMATCH(\"TST1c-z\")\n\tTEST_CGPU_NOMATCH(\"TST1c-\")\n\tTEST_CGPU_MATCH(\"@\")\n\tTEST_CGPU_NOMATCH(\"@abc\")\n\tTEST_CGPU_MATCH(\"@@b\")\n\tTEST_CGPU_NOMATCH(\"@@c\")\n\tTEST_CGPU_MATCH(\"TST@\")\n\tTEST_CGPU_NOMATCH(\"TST@abc\")\n\tTEST_CGPU_MATCH(\"TST@@b\")\n\tTEST_CGPU_NOMATCH(\"TST@@c\")\n\tTEST_CGPU_MATCH(\"TST@@b-f\")\n\tTEST_CGPU_NOMATCH(\"TST@@c-f\")\n\tTEST_CGPU_NOMATCH(\"TST@@-a\")\n\tcgpu.device_path = \"/dev/test\";\n\tcgpu.dev_serial = \"testy\";\n\tTEST_CGPU_MATCH(\"TST@/dev/test\")\n\tTEST_CGPU_MATCH(\"TST@testy\")\n\tTEST_CGPU_NOMATCH(\"TST@\")\n\tTEST_CGPU_NOMATCH(\"TST@/dev/test5@b\")\n\tTEST_CGPU_NOMATCH(\"TST@testy3@b\")\n\tTEST_CGPU_MATCH(\"TST@/dev/test@b\")\n\tTEST_CGPU_MATCH(\"TST@testy@b\")\n\tTEST_CGPU_NOMATCH(\"TST@/dev/test@c\")\n\tTEST_CGPU_NOMATCH(\"TST@testy@c\")\n\tcgpu.device_path = \"usb:000:999\";\n\tTEST_CGPU_MATCH(\"TST@usb:000:999\")\n\tdrv.dname = \"test7\";\n\tTEST_CGPU_MATCH(\"test7\")\n\tTEST_CGPU_MATCH(\"TEST7\")\n\tTEST_CGPU_NOMATCH(\"test&\")\n\tTEST_CGPU_MATCH(\"test7 1-2\")\n\tTEST_CGPU_MATCH(\"test7@testy@b\")\n}\n\nstatic\nint cgpu_search(const char * const pattern, const int first)\n{\n\tint i;\n\tstruct cgpu_info *cgpu;\n\t\n#define CHECK_CGPU_SEARCH  do{      \\\n\tcgpu = get_devices(i);          \\\n\tif (cgpu_match(pattern, cgpu))  \\\n\t\treturn i;                   \\\n}while(0)\n\tfor (i = first; i < total_devices; ++i)\n\t\tCHECK_CGPU_SEARCH;\n\tfor (i = 0; i < first; ++i)\n\t\tCHECK_CGPU_SEARCH;\n#undef CHECK_CGPU_SEARCH\n\treturn -1;\n}\n\nstatic pthread_mutex_t sharelog_lock;\nstatic FILE *sharelog_file = NULL;\n\nstruct thr_info *get_thread(int thr_id)\n{\n\tstruct thr_info *thr;\n\n\trd_lock(&mining_thr_lock);\n\tthr = mining_thr[thr_id];\n\trd_unlock(&mining_thr_lock);\n\n\treturn thr;\n}\n\nstatic struct cgpu_info *get_thr_cgpu(int thr_id)\n{\n\tstruct thr_info *thr = get_thread(thr_id);\n\n\treturn thr->cgpu;\n}\n\nstruct cgpu_info *get_devices(int id)\n{\n\tstruct cgpu_info *cgpu;\n\n\trd_lock(&devices_lock);\n\tcgpu = devices[id];\n\trd_unlock(&devices_lock);\n\n\treturn cgpu;\n}\n\nstatic pthread_mutex_t noncelog_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic FILE *noncelog_file = NULL;\n\nstatic\nvoid noncelog(const struct work * const work)\n{\n\tconst int thr_id = work->thr_id;\n\tconst struct cgpu_info *proc = get_thr_cgpu(thr_id);\n\tchar buf[0x200], hash[65], data[161], midstate[65];\n\tint rv;\n\tsize_t ret;\n\t\n\tbin2hex(hash, work->hash, 32);\n\tbin2hex(data, work->data, 80);\n\tbin2hex(midstate, work->midstate, 32);\n\t\n\t// timestamp,proc,hash,data,midstate\n\trv = snprintf(buf, sizeof(buf), \"%lu,%s,%s,%s,%s\\n\",\n\t              (unsigned long)time(NULL), proc->proc_repr_ns,\n\t              hash, data, midstate);\n\t\n\tif (unlikely(rv < 1))\n\t{\n\t\tapplog(LOG_ERR, \"noncelog printf error\");\n\t\treturn;\n\t}\n\t\n\tmutex_lock(&noncelog_lock);\n\tret = fwrite(buf, rv, 1, noncelog_file);\n\tfflush(noncelog_file);\n\tmutex_unlock(&noncelog_lock);\n\t\n\tif (ret != 1)\n\t\tapplog(LOG_ERR, \"noncelog fwrite error\");\n}\n\nstatic void sharelog(const char*disposition, const struct work*work)\n{\n\tchar target[(sizeof(work->target) * 2) + 1];\n\tchar hash[(sizeof(work->hash) * 2) + 1];\n\tchar data[(sizeof(work->data) * 2) + 1];\n\tstruct cgpu_info *cgpu;\n\tunsigned long int t;\n\tstruct pool *pool;\n\tint thr_id, rv;\n\tchar s[1024];\n\tsize_t ret;\n\n\tif (!sharelog_file)\n\t\treturn;\n\n\tthr_id = work->thr_id;\n\tcgpu = get_thr_cgpu(thr_id);\n\tpool = work->pool;\n\tt = work->ts_getwork + timer_elapsed(&work->tv_getwork, &work->tv_work_found);\n\tbin2hex(target, work->target, sizeof(work->target));\n\tbin2hex(hash, work->hash, sizeof(work->hash));\n\tbin2hex(data, work->data, sizeof(work->data));\n\n\t// timestamp,disposition,target,pool,dev,thr,sharehash,sharedata\n\trv = snprintf(s, sizeof(s), \"%lu,%s,%s,%s,%s,%u,%s,%s\\n\", t, disposition, target, pool->rpc_url, cgpu->proc_repr_ns, thr_id, hash, data);\n\tif (rv >= (int)(sizeof(s)))\n\t\ts[sizeof(s) - 1] = '\\0';\n\telse if (rv < 0) {\n\t\tapplog(LOG_ERR, \"sharelog printf error\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sharelog_lock);\n\tret = fwrite(s, rv, 1, sharelog_file);\n\tfflush(sharelog_file);\n\tmutex_unlock(&sharelog_lock);\n\n\tif (ret != 1)\n\t\tapplog(LOG_ERR, \"sharelog fwrite error\");\n}\n\n#ifdef HAVE_CURSES\nstatic void switch_logsize(void);\n#endif\n\nstatic void hotplug_trigger();\n\nvoid goal_set_malgo(struct mining_goal_info * const goal, struct mining_algorithm * const malgo)\n{\n\tif (goal->malgo == malgo)\n\t\treturn;\n\t\n\tif (goal->malgo)\n\t\t--goal->malgo->goal_refs;\n\tif (malgo->goal_refs++)\n\t\t// First time using a new mining algorithm may means we need to add mining hardware to support it\n\t\t// api_thr_id is used as an ugly hack to determine if mining has started - if not, we do NOT want to try to hotplug anything (let the initial detect handle it)\n\t\tif (opt_hotplug && api_thr_id)\n\t\t\thotplug_trigger();\n\tgoal->malgo = malgo;\n}\n\nstruct mining_algorithm *mining_algorithm_by_alias(const char * const alias)\n{\n\tstruct mining_algorithm *malgo;\n\tLL_FOREACH(mining_algorithms, malgo)\n\t{\n\t\tif (match_strtok(malgo->aliases, \"|\", alias))\n\t\t\treturn malgo;\n\t}\n\treturn NULL;\n}\n\n#ifdef USE_SCRYPT\nextern struct mining_algorithm malgo_scrypt;\n\nstatic\nconst char *set_malgo_scrypt()\n{\n\tgoal_set_malgo(get_mining_goal(\"default\"), &malgo_scrypt);\n\treturn NULL;\n}\n#endif\n\nstatic\nint mining_goals_name_cmp(const struct mining_goal_info * const a, const struct mining_goal_info * const b)\n{\n\t// default always goes first\n\tif (a->is_default)\n\t\treturn -1;\n\tif (b->is_default)\n\t\treturn 1;\n\treturn strcmp(a->name, b->name);\n}\n\nstatic\nvoid blkchain_init_block(struct blockchain_info * const blkchain)\n{\n\tstruct block_info * const dummy_block = calloc(sizeof(*dummy_block), 1);\n\tmemset(dummy_block->prevblkhash, 0, 0x20);\n\tHASH_ADD(hh, blkchain->blocks, prevblkhash, sizeof(dummy_block->prevblkhash), dummy_block);\n\tblkchain->currentblk = dummy_block;\n}\n\nextern struct mining_algorithm malgo_sha256d;\n\nstruct mining_goal_info *get_mining_goal(const char * const name)\n{\n\tstatic unsigned next_goal_id;\n\tstruct mining_goal_info *goal;\n\tHASH_FIND_STR(mining_goals, name, goal);\n\tif (!goal)\n\t{\n\t\tstruct blockchain_info * const blkchain = malloc(sizeof(*blkchain) + sizeof(*goal));\n\t\tgoal = (void*)(&blkchain[1]);\n\t\t\n\t\t*blkchain = (struct blockchain_info){\n\t\t\t.currentblk = NULL,\n\t\t};\n\t\tblkchain_init_block(blkchain);\n\t\t\n\t\t*goal = (struct mining_goal_info){\n\t\t\t.id = next_goal_id++,\n\t\t\t.name = strdup(name),\n\t\t\t.is_default = !strcmp(name, \"default\"),\n\t\t\t.blkchain = blkchain,\n\t\t\t.current_diff = 0xFFFFFFFFFFFFFFFFULL,\n\t\t};\n#ifdef USE_SHA256D\n\t\tgoal_set_malgo(goal, &malgo_sha256d);\n#else\n\t\t// NOTE: Basically random default\n\t\tgoal_set_malgo(goal, mining_algorithms);\n#endif\n\t\tHASH_ADD_KEYPTR(hh, mining_goals, goal->name, strlen(goal->name), goal);\n\t\tHASH_SORT(mining_goals, mining_goals_name_cmp);\n\t\t\n#ifdef HAVE_CURSES\n\t\tdevcursor = 7 + active_goals;\n\t\tswitch_logsize();\n#endif\n\t}\n\treturn goal;\n}\n\nvoid mining_goal_reset(struct mining_goal_info * const goal)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\tstruct block_info *blkinfo, *tmpblkinfo;\n\tHASH_ITER(hh, blkchain->blocks, blkinfo, tmpblkinfo)\n\t{\n\t\tHASH_DEL(blkchain->blocks, blkinfo);\n\t\tfree(blkinfo);\n\t}\n\tblkchain_init_block(blkchain);\n}\n\nstatic char *getwork_req = \"{\\\"method\\\": \\\"getwork\\\", \\\"params\\\": [], \\\"id\\\":0}\\n\";\n\n/* Adjust all the pools' quota to the greatest common denominator after a pool\n * has been added or the quotas changed. */\nvoid adjust_quota_gcd(void)\n{\n\tunsigned long gcd, lowest_quota = ~0UL, quota;\n\tstruct pool *pool;\n\tint i;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tpool = pools[i];\n\t\tquota = pool->quota;\n\t\tif (!quota)\n\t\t\tcontinue;\n\t\tif (quota < lowest_quota)\n\t\t\tlowest_quota = quota;\n\t}\n\n\tif (likely(lowest_quota < ~0UL)) {\n\t\tgcd = lowest_quota;\n\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\tpool = pools[i];\n\t\t\tquota = pool->quota;\n\t\t\tif (!quota)\n\t\t\t\tcontinue;\n\t\t\twhile (quota % gcd)\n\t\t\t\tgcd--;\n\t\t}\n\t} else\n\t\tgcd = 1;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tpool = pools[i];\n\t\tpool->quota_used *= global_quota_gcd;\n\t\tpool->quota_used /= gcd;\n\t\tpool->quota_gcd = pool->quota / gcd;\n\t}\n\n\tglobal_quota_gcd = gcd;\n\tapplog(LOG_DEBUG, \"Global quota greatest common denominator set to %lu\", gcd);\n}\n\n/* Return value is ignored if not called from add_pool_details */\nstruct pool *add_pool2(struct mining_goal_info * const goal)\n{\n\tstruct pool *pool;\n\n\tpool = calloc(sizeof(struct pool), 1);\n\tif (!pool)\n\t\tquit(1, \"Failed to malloc pool in add_pool\");\n\tpool->pool_no = pool->prio = total_pools;\n\tmutex_init(&pool->last_work_lock);\n\tmutex_init(&pool->pool_lock);\n\tmutex_init(&pool->pool_test_lock);\n\tif (unlikely(pthread_cond_init(&pool->cr_cond, bfg_condattr)))\n\t\tquit(1, \"Failed to pthread_cond_init in add_pool\");\n\tcglock_init(&pool->data_lock);\n\tpool->swork.data_lock_p = &pool->data_lock;\n\tmutex_init(&pool->stratum_lock);\n\ttimer_unset(&pool->swork.tv_transparency);\n\tpool->swork.pool = pool;\n\tpool->goal = goal;\n\n\tpool->idle = true;\n\t/* Make sure the pool doesn't think we've been idle since time 0 */\n\tpool->tv_idle.tv_sec = ~0UL;\n\t\n\tcgtime(&pool->cgminer_stats.start_tv);\n\tpool->cgminer_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\tpool->cgminer_pool_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\n\tpool->rpc_proxy = NULL;\n\tpool->quota = 1;\n\n\tpool->sock = INVSOCK;\n\tpool->lp_socket = CURL_SOCKET_BAD;\n\n\tpools = realloc(pools, sizeof(struct pool *) * (total_pools + 2));\n\tpools[total_pools++] = pool;\n\t\n\tif (opt_benchmark)\n\t{\n\t\t// Immediately remove it\n\t\tremove_pool(pool);\n\t\treturn pool;\n\t}\n\t\n\tadjust_quota_gcd();\n\t\n\tif (!currentpool)\n\t\tcurrentpool = pool;\n\t\n\tenable_pool(pool);\n\n\treturn pool;\n}\n\nstatic\nvoid pool_set_uri(struct pool * const pool, char * const uri)\n{\n\tpool->rpc_url = uri;\n\tpool->pool_diff_effective_retroactively = uri_get_param_bool2(uri, \"retrodiff\");\n}\n\nstatic\nbool pool_diff_effective_retroactively(struct pool * const pool)\n{\n\tif (pool->pool_diff_effective_retroactively != BTS_UNKNOWN) {\n\t\treturn pool->pool_diff_effective_retroactively;\n\t}\n\t\n\t// By default, we enable retrodiff for stratum pools since some servers implement mining.set_difficulty in this way\n\t// Note that share_result will explicitly disable BTS_UNKNOWN -> BTS_FALSE if a retrodiff share is rejected specifically for its failure to meet the target.\n\treturn pool->stratum_active;\n}\n\n/* Pool variant of test and set */\nstatic bool pool_tset(struct pool *pool, bool *var)\n{\n\tbool ret;\n\n\tmutex_lock(&pool->pool_lock);\n\tret = *var;\n\t*var = true;\n\tmutex_unlock(&pool->pool_lock);\n\n\treturn ret;\n}\n\nbool pool_tclear(struct pool *pool, bool *var)\n{\n\tbool ret;\n\n\tmutex_lock(&pool->pool_lock);\n\tret = *var;\n\t*var = false;\n\tmutex_unlock(&pool->pool_lock);\n\n\treturn ret;\n}\n\nstruct pool *current_pool(void)\n{\n\tstruct pool *pool;\n\n\tcg_rlock(&control_lock);\n\tpool = currentpool;\n\tcg_runlock(&control_lock);\n\n\treturn pool;\n}\n\n#if defined(USE_CPUMINING) && !defined(USE_SHA256D)\nstatic\nchar *arg_ignored(const char * const arg)\n{\n\treturn NULL;\n}\n#endif\n\nstatic\nchar *set_bool_ignore_arg(const char * const arg, bool * const b)\n{\n\treturn opt_set_bool(b);\n}\n\nchar *set_int_range(const char *arg, int *i, int min, int max)\n{\n\tchar *err = opt_set_intval(arg, i);\n\n\tif (err)\n\t\treturn err;\n\n\tif (*i < min || *i > max)\n\t\treturn \"Value out of range\";\n\n\treturn NULL;\n}\n\nstatic char *set_int_0_to_9999(const char *arg, int *i)\n{\n\treturn set_int_range(arg, i, 0, 9999);\n}\n\nstatic char *set_int_1_to_65535(const char *arg, int *i)\n{\n\treturn set_int_range(arg, i, 1, 65535);\n}\n\nstatic char *set_int_0_to_10(const char *arg, int *i)\n{\n\treturn set_int_range(arg, i, 0, 10);\n}\n\nstatic char *set_int_1_to_10(const char *arg, int *i)\n{\n\treturn set_int_range(arg, i, 1, 10);\n}\n\nstatic char *set_long_1_to_65535_or_neg1(const char * const arg, long * const i)\n{\n\tconst long min = 1, max = 65535;\n\t\n\tchar * const err = opt_set_longval(arg, i);\n\t\n\tif (err) {\n\t\treturn err;\n\t}\n\t\n\tif (*i != -1 && (*i < min || *i > max)) {\n\t\treturn \"Value out of range\";\n\t}\n\t\n\treturn NULL;\n}\n\nchar *set_strdup(const char *arg, char **p)\n{\n\t*p = strdup((char *)arg);\n\treturn NULL;\n}\n\n#if BLKMAKER_VERSION > 1\nstatic\nchar *set_b58addr(const char * const arg, bytes_t * const b)\n{\n\tsize_t scriptsz = blkmk_address_to_script(NULL, 0, arg);\n\tif (!scriptsz)\n\t\treturn \"Invalid address\";\n\tchar *script = malloc(scriptsz);\n\tif (blkmk_address_to_script(script, scriptsz, arg) != scriptsz) {\n\t\tfree(script);\n\t\treturn \"Failed to convert address to script\";\n\t}\n\tbytes_assimilate_raw(b, script, scriptsz, scriptsz);\n\treturn NULL;\n}\n\nstatic char *set_generate_addr2(struct mining_goal_info *, const char *);\n\nstatic\nchar *set_generate_addr(char *arg)\n{\n\tchar * const colon = strchr(arg, ':');\n\tstruct mining_goal_info *goal;\n\tif (colon)\n\t{\n\t\tcolon[0] = '\\0';\n\t\tgoal = get_mining_goal(arg);\n\t\targ = &colon[1];\n\t}\n\telse\n\t\tgoal = get_mining_goal(\"default\");\n\t\n\treturn set_generate_addr2(goal, arg);\n}\n\nstatic\nchar *set_generate_addr2(struct mining_goal_info * const goal, const char * const arg)\n{\n\tbytes_t newscript = BYTES_INIT;\n\tchar *estr = set_b58addr(arg, &newscript);\n\tif (estr)\n\t{\n\t\tbytes_free(&newscript);\n\t\treturn estr;\n\t}\n\tif (!goal->generation_script)\n\t{\n\t\tgoal->generation_script = malloc(sizeof(*goal->generation_script));\n\t\tbytes_init(goal->generation_script);\n\t}\n\tbytes_assimilate(goal->generation_script, &newscript);\n\tbytes_free(&newscript);\n\t\n\treturn NULL;\n}\n#endif\n\nstatic\nchar *set_quit_summary(const char * const arg)\n{\n\tif (!(strcasecmp(arg, \"none\") && strcasecmp(arg, \"no\")))\n\t\topt_quit_summary = BQS_NONE;\n\telse\n\tif (!(strcasecmp(arg, \"devs\") && strcasecmp(arg, \"devices\")))\n\t\topt_quit_summary = BQS_DEVS;\n\telse\n\tif (!(strcasecmp(arg, \"procs\") && strcasecmp(arg, \"processors\") && strcasecmp(arg, \"chips\") && strcasecmp(arg, \"cores\")))\n\t\topt_quit_summary = BQS_PROCS;\n\telse\n\tif (!(strcasecmp(arg, \"detailed\") && strcasecmp(arg, \"detail\") && strcasecmp(arg, \"all\")))\n\t\topt_quit_summary = BQS_DETAILED;\n\telse\n\t\treturn \"Quit summary must be one of none/devs/procs/detailed\";\n\treturn NULL;\n}\n\nstatic void pdiff_target_leadzero(void *, double);\n\nchar *set_request_diff(const char *arg, float *p)\n{\n\tunsigned char target[32];\n\tchar *e = opt_set_floatval(arg, p);\n\tif (e)\n\t\treturn e;\n\t\n\trequest_bdiff = (double)*p * 0.9999847412109375;\n\tpdiff_target_leadzero(target, *p);\n\trequest_target_str = malloc(65);\n\tbin2hex(request_target_str, target, 32);\n\t\n\treturn NULL;\n}\n\n#ifdef NEED_BFG_LOWL_VCOM\nextern struct lowlevel_device_info *_vcom_devinfo_findorcreate(struct lowlevel_device_info **, const char *);\n\n#ifdef WIN32\nvoid _vcom_devinfo_scan_querydosdevice(struct lowlevel_device_info ** const devinfo_list)\n{\n\tchar dev[PATH_MAX];\n\tchar *devp = dev;\n\tsize_t bufLen = 0x100;\ntryagain: ;\n\tchar buf[bufLen];\n\tif (!QueryDosDevice(NULL, buf, bufLen)) {\n\t\tif (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tbufLen *= 2;\n\t\t\tapplog(LOG_DEBUG, \"QueryDosDevice returned insufficent buffer error; enlarging to %lx\", (unsigned long)bufLen);\n\t\t\tgoto tryagain;\n\t\t}\n\t\tapplogr(, LOG_WARNING, \"Error occurred trying to enumerate COM ports with QueryDosDevice\");\n\t}\n\tsize_t tLen;\n\tmemcpy(devp, \"\\\\\\\\.\\\\\", 4);\n\tdevp = &devp[4];\n\tfor (char *t = buf; *t; t += tLen) {\n\t\ttLen = strlen(t) + 1;\n\t\tif (strncmp(\"COM\", t, 3))\n\t\t\tcontinue;\n\t\tmemcpy(devp, t, tLen);\n\t\t// NOTE: We depend on _vcom_devinfo_findorcreate to further check that there's a number (and only a number) on the end\n\t\t_vcom_devinfo_findorcreate(devinfo_list, dev);\n\t}\n}\n#else\nvoid _vcom_devinfo_scan_lsdev(struct lowlevel_device_info ** const devinfo_list)\n{\n\tchar dev[PATH_MAX];\n\tchar *devp = dev;\n\tDIR *D;\n\tstruct dirent *de;\n\tconst char devdir[] = \"/dev\";\n\tconst size_t devdirlen = sizeof(devdir) - 1;\n\tchar *devpath = devp;\n\tchar *devfile = devpath + devdirlen + 1;\n\t\n\tD = opendir(devdir);\n\tif (!D)\n\t\tapplogr(, LOG_DEBUG, \"No /dev directory to look for VCOM devices in\");\n\tmemcpy(devpath, devdir, devdirlen);\n\tdevpath[devdirlen] = '/';\n\twhile ( (de = readdir(D)) ) {\n\t\tif (!strncmp(de->d_name, \"cu.\", 3)\n\t\t\t//don't probe Bluetooth devices - causes bus errors and segfaults\n\t\t\t&& strncmp(de->d_name, \"cu.Bluetooth\", 12))\n\t\t\tgoto trydev;\n\t\tif (strncmp(de->d_name, \"tty\", 3))\n\t\t\tcontinue;\n\t\tif (strncmp(&de->d_name[3], \"USB\", 3) && strncmp(&de->d_name[3], \"ACM\", 3))\n\t\t\tcontinue;\n\t\t\ntrydev:\n\t\tstrcpy(devfile, de->d_name);\n\t\t_vcom_devinfo_findorcreate(devinfo_list, dev);\n\t}\n\tclosedir(D);\n}\n#endif\n#endif\n\nstatic char *add_serial(const char *arg)\n{\n\tstring_elist_add(arg, &scan_devices);\n\treturn NULL;\n}\n\nstatic\nchar *opt_string_elist_add(const char *arg, struct string_elist **elist)\n{\n\tstring_elist_add(arg, elist);\n\treturn NULL;\n}\n\nbool get_intrange(const char *arg, int *val1, int *val2)\n{\n\t// NOTE: This could be done with sscanf, but its %n is broken in strange ways on Windows\n\tchar *p, *p2;\n\t\n\t*val1 = strtol(arg, &p, 0);\n\tif (arg == p)\n\t\t// Zero-length ending number, invalid\n\t\treturn false;\n\twhile (true)\n\t{\n\t\tif (!p[0])\n\t\t{\n\t\t\t*val2 = *val1;\n\t\t\treturn true;\n\t\t}\n\t\tif (p[0] == '-')\n\t\t\tbreak;\n\t\tif (!isspace(p[0]))\n\t\t\t// Garbage, invalid\n\t\t\treturn false;\n\t\t++p;\n\t}\n\tp2 = &p[1];\n\t*val2 = strtol(p2, &p, 0);\n\tif (p2 == p)\n\t\t// Zero-length ending number, invalid\n\t\treturn false;\n\twhile (true)\n\t{\n\t\tif (!p[0])\n\t\t\treturn true;\n\t\tif (!isspace(p[0]))\n\t\t\t// Garbage, invalid\n\t\t\treturn false;\n\t\t++p;\n\t}\n}\n\nstatic\nvoid _test_intrange(const char *s, const int v[2])\n{\n\tint a[2];\n\tif (!get_intrange(s, &a[0], &a[1]))\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_ERR, \"Test \\\"%s\\\" failed: returned false\", s);\n\t}\n\tfor (int i = 0; i < 2; ++i)\n\t\tif (unlikely(a[i] != v[i]))\n\t\t{\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"Test \\\"%s\\\" failed: value %d should be %d but got %d\", s, i, v[i], a[i]);\n\t\t}\n}\n#define _test_intrange(s, ...)  _test_intrange(s, (int[]){ __VA_ARGS__ })\n\nstatic\nvoid _test_intrange_fail(const char *s)\n{\n\tint a[2];\n\tif (get_intrange(s, &a[0], &a[1]))\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_ERR, \"Test !\\\"%s\\\" failed: returned true with %d and %d\", s, a[0], a[1]);\n\t}\n}\n\nstatic\nvoid test_intrange()\n{\n\t_test_intrange(\"-1--2\", -1, -2);\n\t_test_intrange(\"-1-2\", -1, 2);\n\t_test_intrange(\"1--2\", 1, -2);\n\t_test_intrange(\"1-2\", 1, 2);\n\t_test_intrange(\"111-222\", 111, 222);\n\t_test_intrange(\" 11 - 22 \", 11, 22);\n\t_test_intrange(\"+11-+22\", 11, 22);\n\t_test_intrange(\"-1\", -1, -1);\n\t_test_intrange_fail(\"all\");\n\t_test_intrange_fail(\"1-\");\n\t_test_intrange_fail(\"\");\n\t_test_intrange_fail(\"1-54x\");\n}\n\nstatic char *set_devices(char *arg)\n{\n\tif (*arg) {\n\t\tif (*arg == '?') {\n\t\t\topt_display_devs = true;\n\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\treturn \"Invalid device parameters\";\n\n\tstring_elist_add(arg, &opt_devices_enabled_list);\n\n\treturn NULL;\n}\n\nstatic char *set_balance(enum pool_strategy *strategy)\n{\n\t*strategy = POOL_BALANCE;\n\treturn NULL;\n}\n\nstatic char *set_loadbalance(enum pool_strategy *strategy)\n{\n\t*strategy = POOL_LOADBALANCE;\n\treturn NULL;\n}\n\nstatic char *set_rotate(const char *arg, int *i)\n{\n\tpool_strategy = POOL_ROTATE;\n\treturn set_int_range(arg, i, 0, 9999);\n}\n\nstatic char *set_rr(enum pool_strategy *strategy)\n{\n\t*strategy = POOL_ROUNDROBIN;\n\treturn NULL;\n}\n\nstatic\nchar *set_benchmark_intense()\n{\n\topt_benchmark = true;\n\topt_benchmark_intense = true;\n\treturn NULL;\n}\n\n/* Detect that url is for a stratum protocol either via the presence of\n * stratum+tcp or by detecting a stratum server response */\nbool detect_stratum(struct pool *pool, char *url)\n{\n\tif (!extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port))\n\t\treturn false;\n\n\tif (!strncasecmp(url, \"stratum+tcp://\", 14)) {\n\t\tpool_set_uri(pool, strdup(url));\n\t\tpool->has_stratum = true;\n\t\tpool->stratum_url = pool->sockaddr_url;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct pool *add_url(void)\n{\n\ttotal_urls++;\n\tif (total_urls > total_pools)\n\t\tadd_pool();\n\treturn pools[total_urls - 1];\n}\n\nstatic void setup_url(struct pool *pool, char *arg)\n{\n\tif (detect_stratum(pool, arg))\n\t\treturn;\n\n\topt_set_charp(arg, &pool->rpc_url);\n\tif (strncmp(arg, \"http://\", 7) &&\n\t    strncmp(arg, \"https://\", 8)) {\n\t\tconst size_t L = strlen(arg);\n\t\tchar *httpinput;\n\n\t\thttpinput = malloc(8 + L);\n\t\tif (!httpinput)\n\t\t\tquit(1, \"Failed to malloc httpinput\");\n\t\tsprintf(httpinput, \"http://%s\", arg);\n\t\tpool_set_uri(pool, httpinput);\n\t}\n}\n\nstatic char *set_url(char *arg)\n{\n\tstruct pool *pool = add_url();\n\n\tsetup_url(pool, arg);\n\treturn NULL;\n}\n\nstatic char *set_quota(char *arg)\n{\n\tchar *semicolon = strchr(arg, ';'), *url;\n\tint len, qlen, quota;\n\tstruct pool *pool;\n\n\tif (!semicolon)\n\t\treturn \"No semicolon separated quota;URL pair found\";\n\tlen = strlen(arg);\n\t*semicolon = '\\0';\n\tqlen = strlen(arg);\n\tif (!qlen)\n\t\treturn \"No parameter for quota found\";\n\tlen -= qlen + 1;\n\tif (len < 1)\n\t\treturn \"No parameter for URL found\";\n\tquota = atoi(arg);\n\tif (quota < 0)\n\t\treturn \"Invalid negative parameter for quota set\";\n\turl = arg + qlen + 1;\n\tpool = add_url();\n\tsetup_url(pool, url);\n\tpool->quota = quota;\n\tapplog(LOG_INFO, \"Setting pool %d to quota %d\", pool->pool_no, pool->quota);\n\tadjust_quota_gcd();\n\n\treturn NULL;\n}\n\nstatic char *set_user(const char *arg)\n{\n\tstruct pool *pool;\n\n\ttotal_users++;\n\tif (total_users > total_pools)\n\t\tadd_pool();\n\n\tpool = pools[total_users - 1];\n\topt_set_charp(arg, &pool->rpc_user);\n\n\treturn NULL;\n}\n\nstatic char *set_pass(const char *arg)\n{\n\tstruct pool *pool;\n\n\ttotal_passes++;\n\tif (total_passes > total_pools)\n\t\tadd_pool();\n\n\tpool = pools[total_passes - 1];\n\topt_set_charp(arg, &pool->rpc_pass);\n\n\treturn NULL;\n}\n\nstatic char *set_userpass(const char *arg)\n{\n\tstruct pool *pool;\n\tchar *updup;\n\n\tif (total_users != total_passes)\n\t\treturn \"User + pass options must be balanced before userpass\";\n\t++total_users;\n\t++total_passes;\n\tif (total_users > total_pools)\n\t\tadd_pool();\n\n\tpool = pools[total_users - 1];\n\tupdup = strdup(arg);\n\topt_set_charp(arg, &pool->rpc_userpass);\n\tpool->rpc_user = updup;\n\tpool->rpc_pass = strchr(updup, ':');\n\tif (pool->rpc_pass)\n\t\tpool->rpc_pass++[0] = '\\0';\n\telse\n\t\tpool->rpc_pass = &updup[strlen(updup)];\n\n\treturn NULL;\n}\n\nstatic char *set_cbcaddr(char *arg)\n{\n\tstruct pool *pool;\n\tchar *p, *addr;\n\tbytes_t target_script = BYTES_INIT;\n\t\n\tif (!total_pools)\n\t\treturn \"Define pool first, then the --coinbase-check-addr list\";\n\t\n\tpool = pools[total_pools - 1];\n\t\n\t/* NOTE: 'x' is a new prefix which leads both mainnet and testnet address, we would\n\t * need support it later, but now leave the code just so.\n\t *\n\t * Regarding details of address prefix 'x', check the below URL:\n\t * https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#Serialization_format\n\t */\n\tpool->cb_param.testnet = (arg[0] != '1' && arg[0] != '3' && arg[0] != 'x');\n\t\n\tfor (; (addr = strtok_r(arg, \",\", &p)); arg = NULL)\n\t{\n\t\tstruct bytes_hashtbl *ah;\n\t\t\n\t\tif (set_b58addr(addr, &target_script))\n\t\t\t/* No bother to free memory since we are going to exit anyway */\n\t\t\treturn \"Invalid address in --coinbase-check-address list\";\n\t\t\n\t\tHASH_FIND(hh, pool->cb_param.scripts, bytes_buf(&target_script), bytes_len(&target_script), ah);\n\t\tif (!ah)\n\t\t{\n\t\t\t/* Note: for the below allocated memory we have good way to release its memory\n\t\t\t * since we can't be sure there are no reference to the pool struct when remove_pool() \n\t\t\t * get called.\n\t\t\t *\n\t\t\t * We just hope the remove_pool() would not be called many many times during\n\t\t\t * the whole running life of this program.\n\t\t\t */\n\t\t\tah = malloc(sizeof(*ah));\n\t\t\tbytes_init(&ah->b);\n\t\t\tbytes_assimilate(&ah->b, &target_script);\n\t\t\tHASH_ADD(hh, pool->cb_param.scripts, b.buf, bytes_len(&ah->b), ah);\n\t\t}\n\t}\n\tbytes_free(&target_script);\n\t\n\treturn NULL;\n}\n\nstatic char *set_cbctotal(const char *arg)\n{\n\tstruct pool *pool;\n\t\n\tif (!total_pools)\n\t\treturn \"Define pool first, then the --coinbase-check-total argument\";\n\t\n\tpool = pools[total_pools - 1];\n\tpool->cb_param.total = atoll(arg);\n\tif (pool->cb_param.total < 0)\n\t\treturn \"The total payout amount in coinbase should be greater than 0\";\n\t\n\treturn NULL;\n}\n\nstatic char *set_cbcperc(const char *arg)\n{\n\tstruct pool *pool;\n\t\n\tif (!total_pools)\n\t\treturn \"Define pool first, then the --coinbase-check-percent argument\";\n\t\n\tpool = pools[total_pools - 1];\n\tif (!pool->cb_param.scripts)\n\t\treturn \"Define --coinbase-check-addr list first, then the --coinbase-check-total argument\";\n\t\n\tpool->cb_param.perc = atof(arg) / 100;\n\tif (pool->cb_param.perc < 0.0 || pool->cb_param.perc > 1.0)\n\t\treturn \"The percentage should be between 0 and 100\";\n\t\n\treturn NULL;\n}\n\nstatic\nconst char *goal_set(struct mining_goal_info * const goal, const char * const optname, const char * const newvalue, bytes_t * const replybuf, enum bfg_set_device_replytype * const out_success)\n{\n\t*out_success = SDR_ERR;\n\tif (!(strcasecmp(optname, \"malgo\") && strcasecmp(optname, \"algo\")))\n\t{\n\t\tif (!newvalue)\n\t\t\treturn \"Goal option 'malgo' requires a value (eg, SHA256d)\";\n\t\tstruct mining_algorithm * const new_malgo = mining_algorithm_by_alias(newvalue);\n\t\tif (!new_malgo)\n\t\t\treturn \"Unrecognised mining algorithm\";\n\t\tgoal_set_malgo(goal, new_malgo);\n\t\tgoto success;\n\t}\n#if BLKMAKER_VERSION > 1\n\tif (match_strtok(\"generate-to|generate-to-addr|generate-to-address|genaddress|genaddr|gen-address|gen-addr|generate-address|generate-addr|coinbase-addr|coinbase-address|coinbase-payout|cbaddress|cbaddr|cb-address|cb-addr|payout\", \"|\", optname))\n\t{\n\t\tif (!newvalue)\n\t\t\treturn \"Missing value for 'generate-to' goal option\";\n\t\tconst char * const emsg = set_generate_addr2(goal, newvalue);\n\t\tif (emsg)\n\t\t\treturn emsg;\n\t\tgoto success;\n\t}\n#endif\n\t*out_success = SDR_UNKNOWN;\n\treturn \"Unknown goal option\";\n\nsuccess:\n\t*out_success = SDR_OK;\n\treturn NULL;\n}\n\n// May leak replybuf if returning an error\nstatic\nconst char *set_goal_params(struct mining_goal_info * const goal, char *arg)\n{\n\tbytes_t replybuf = BYTES_INIT;\n\tfor (char *param, *nextptr; (param = strtok_r(arg, \",\", &nextptr)); arg = NULL)\n\t{\n\t\tchar *val = strchr(param, '=');\n\t\tif (val)\n\t\t\tval++[0] = '\\0';\n\t\tenum bfg_set_device_replytype success;\n\t\tconst char * const emsg = goal_set(goal, param, val, &replybuf, &success);\n\t\tif (success != SDR_OK)\n\t\t\treturn emsg ?: \"Error setting goal param\";\n\t}\n\tbytes_free(&replybuf);\n\treturn NULL;\n}\n\nstatic\nconst char *set_pool_goal(const char * const arg)\n{\n\tstruct pool *pool;\n\t\n\tif (!total_pools)\n\t\treturn \"Usage of --pool-goal before pools are defined does not make sense\";\n\t\n\tpool = pools[total_pools - 1];\n\tchar *param = strchr(arg, ':');\n\tif (param)\n\t\tparam++[0] = '\\0';\n\tpool->goal = get_mining_goal(arg);\n\t\n\tif (param)\n\t\treturn set_goal_params(pool->goal, param);\n\t\n\treturn NULL;\n}\n\nstatic char *set_pool_priority(const char *arg)\n{\n\tstruct pool *pool;\n\n\tif (!total_pools)\n\t\treturn \"Usage of --pool-priority before pools are defined does not make sense\";\n\n\tpool = pools[total_pools - 1];\n\topt_set_intval(arg, &pool->prio);\n\n\treturn NULL;\n}\n\nstatic char *set_pool_proxy(const char *arg)\n{\n\tstruct pool *pool;\n\n\tif (!total_pools)\n\t\treturn \"Usage of --pool-proxy before pools are defined does not make sense\";\n\n\tif (!our_curl_supports_proxy_uris())\n\t\treturn \"Your installed cURL library does not support proxy URIs. At least version 7.21.7 is required.\";\n\n\tpool = pools[total_pools - 1];\n\topt_set_charp(arg, &pool->rpc_proxy);\n\n\treturn NULL;\n}\n\nstatic char *set_pool_force_rollntime(const char *arg)\n{\n\tstruct pool *pool;\n\t\n\tif (!total_pools)\n\t\treturn \"Usage of --force-rollntime before pools are defined does not make sense\";\n\t\n\tpool = pools[total_pools - 1];\n\topt_set_intval(arg, &pool->force_rollntime);\n\t\n\treturn NULL;\n}\n\nstatic char *enable_debug(bool *flag)\n{\n\t*flag = true;\n\topt_debug_console = true;\n\t/* Turn on verbose output, too. */\n\topt_log_output = true;\n\treturn NULL;\n}\n\nstatic char *set_schedtime(const char *arg, struct schedtime *st)\n{\n\tif (sscanf(arg, \"%d:%d\", &st->tm.tm_hour, &st->tm.tm_min) != 2)\n\t{\n\t\tif (strcasecmp(arg, \"now\"))\n\t\treturn \"Invalid time set, should be HH:MM\";\n\t} else\n\t\tschedstop.tm.tm_sec = 0;\n\tif (st->tm.tm_hour > 23 || st->tm.tm_min > 59 || st->tm.tm_hour < 0 || st->tm.tm_min < 0)\n\t\treturn \"Invalid time set.\";\n\tst->enable = true;\n\treturn NULL;\n}\n\nstatic\nchar *set_log_file(char *arg)\n{\n\tchar *r = \"\";\n\tlong int i = strtol(arg, &r, 10);\n\tint fd, stderr_fd = fileno(stderr);\n\n\tif ((!*r) && i >= 0 && i <= INT_MAX)\n\t\tfd = i;\n\telse\n\tif (!strcmp(arg, \"-\"))\n\t{\n\t\tfd = fileno(stdout);\n\t\tif (unlikely(fd == -1))\n\t\t\treturn \"Standard output missing for log-file\";\n\t}\n\telse\n\t{\n\t\tfd = open(arg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);\n\t\tif (unlikely(fd == -1))\n\t\t\treturn \"Failed to open log-file\";\n\t}\n\t\n\tclose(stderr_fd);\n\tif (unlikely(-1 == dup2(fd, stderr_fd)))\n\t\treturn \"Failed to dup2 for log-file\";\n\tclose(fd);\n\t\n\treturn NULL;\n}\n\nstatic\nchar *_bfgopt_set_file(const char *arg, FILE **F, const char *mode, const char *purpose)\n{\n\tchar *r = \"\";\n\tlong int i = strtol(arg, &r, 10);\n\tstatic char *err = NULL;\n\tconst size_t errbufsz = 0x100;\n\n\tfree(err);\n\terr = NULL;\n\t\n\tif ((!*r) && i >= 0 && i <= INT_MAX) {\n\t\t*F = fdopen((int)i, mode);\n\t\tif (!*F)\n\t\t{\n\t\t\terr = malloc(errbufsz);\n\t\t\tsnprintf(err, errbufsz, \"Failed to open fd %d for %s\",\n\t\t\t         (int)i, purpose);\n\t\t\treturn err;\n\t\t}\n\t} else if (!strcmp(arg, \"-\")) {\n\t\t*F = (mode[0] == 'a') ? stdout : stdin;\n\t\tif (!*F)\n\t\t{\n\t\t\terr = malloc(errbufsz);\n\t\t\tsnprintf(err, errbufsz, \"Standard %sput missing for %s\",\n\t\t\t         (mode[0] == 'a') ? \"out\" : \"in\", purpose);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t*F = fopen(arg, mode);\n\t\tif (!*F)\n\t\t{\n\t\t\terr = malloc(errbufsz);\n\t\t\tsnprintf(err, errbufsz, \"Failed to open %s for %s\",\n\t\t\t         arg, purpose);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *set_noncelog(char *arg)\n{\n\treturn _bfgopt_set_file(arg, &noncelog_file, \"a\", \"nonce log\");\n}\n\nstatic char *set_sharelog(char *arg)\n{\n\treturn _bfgopt_set_file(arg, &sharelog_file, \"a\", \"share log\");\n}\n\nstatic\nvoid _add_set_device_option(const char * const func, const char * const buf)\n{\n\tapplog(LOG_DEBUG, \"%s: Using --set-device %s\", func, buf);\n\tstring_elist_add(buf, &opt_set_device_list);\n}\n\n#define add_set_device_option(...)  do{  \\\n\tchar _tmp1718[0x100];  \\\n\tsnprintf(_tmp1718, sizeof(_tmp1718), __VA_ARGS__);  \\\n\t_add_set_device_option(__func__, _tmp1718);  \\\n}while(0)\n\nchar *set_temp_cutoff(char *arg)\n{\n\tif (strchr(arg, ','))\n\t\treturn \"temp-cutoff no longer supports comma-delimited syntax, use --set-device for better control\";\n\tapplog(LOG_WARNING, \"temp-cutoff is deprecated! Use --set-device for better control\");\n\t\n\tadd_set_device_option(\"all:temp-cutoff=%s\", arg);\n\t\n\treturn NULL;\n}\n\nchar *set_temp_target(char *arg)\n{\n\tif (strchr(arg, ','))\n\t\treturn \"temp-target no longer supports comma-delimited syntax, use --set-device for better control\";\n\tapplog(LOG_WARNING, \"temp-target is deprecated! Use --set-device for better control\");\n\t\n\tadd_set_device_option(\"all:temp-target=%s\", arg);\n\t\n\treturn NULL;\n}\n\n#ifdef USE_OPENCL\nstatic\nchar *set_no_opencl_binaries(__maybe_unused void * const dummy)\n{\n\tapplog(LOG_WARNING, \"The --no-opencl-binaries option is deprecated! Use --set-device OCL:binary=no\");\n\tadd_set_device_option(\"OCL:binary=no\");\n\treturn NULL;\n}\n#endif\n\nstatic\nchar *disable_pool_redirect(__maybe_unused void * const dummy)\n{\n\topt_disable_client_reconnect = true;\n\twant_stratum = false;\n\treturn NULL;\n}\n\nstatic char *set_api_allow(const char *arg)\n{\n\topt_set_charp(arg, &opt_api_allow);\n\n\treturn NULL;\n}\n\nstatic char *set_api_groups(const char *arg)\n{\n\topt_set_charp(arg, &opt_api_groups);\n\n\treturn NULL;\n}\n\nstatic char *set_api_description(const char *arg)\n{\n\topt_set_charp(arg, &opt_api_description);\n\n\treturn NULL;\n}\n\nstatic char *set_api_mcast_des(const char *arg)\n{\n\topt_set_charp(arg, &opt_api_mcast_des);\n\n\treturn NULL;\n}\n\n#ifdef USE_ICARUS\nextern const struct bfg_set_device_definition icarus_set_device_funcs[];\n\nstatic char *set_icarus_options(const char *arg)\n{\n\tif (strchr(arg, ','))\n\t\treturn \"icarus-options no longer supports comma-delimited syntax, see README.FPGA for better control\";\n\tapplog(LOG_WARNING, \"icarus-options is deprecated! See README.FPGA for better control\");\n\t\n\tchar *opts = strdup(arg), *argdup;\n\targdup = opts;\n\tconst struct bfg_set_device_definition *sdf = icarus_set_device_funcs;\n\tconst char *drivers[] = {\"antminer\", \"cairnsmore\", \"erupter\", \"icarus\"};\n\tchar *saveptr, *opt;\n\tfor (int i = 0; i < 4; ++i, ++sdf)\n\t{\n\t\topt = strtok_r(opts, \":\", &saveptr);\n\t\topts = NULL;\n\t\t\n\t\tif (!opt)\n\t\t\tbreak;\n\t\t\n\t\tif (!opt[0])\n\t\t\tcontinue;\n\t\t\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tadd_set_device_option(\"%s:%s=%s\", drivers[j], sdf->optname, opt);\n\t}\n\tfree(argdup);\n\treturn NULL;\n}\n\nstatic char *set_icarus_timing(const char *arg)\n{\n\tif (strchr(arg, ','))\n\t\treturn \"icarus-timing no longer supports comma-delimited syntax, see README.FPGA for better control\";\n\tapplog(LOG_WARNING, \"icarus-timing is deprecated! See README.FPGA for better control\");\n\t\n\tconst char *drivers[] = {\"antminer\", \"cairnsmore\", \"erupter\", \"icarus\"};\n\tfor (int j = 0; j < 4; ++j)\n\t\tadd_set_device_option(\"%s:timing=%s\", drivers[j], arg);\n\treturn NULL;\n}\n#endif\n\n#ifdef USE_AVALON\nextern const struct bfg_set_device_definition avalon_set_device_funcs[];\n\nstatic char *set_avalon_options(const char *arg)\n{\n\tif (strchr(arg, ','))\n\t\treturn \"avalon-options no longer supports comma-delimited syntax, see README.FPGA for better control\";\n\tapplog(LOG_WARNING, \"avalon-options is deprecated! See README.FPGA for better control\");\n\t\n\tchar *opts = strdup(arg), *argdup;\n\targdup = opts;\n\tconst struct bfg_set_device_definition *sdf = avalon_set_device_funcs;\n\tchar *saveptr, *opt;\n\tfor (int i = 0; i < 5; ++i, ++sdf)\n\t{\n\t\topt = strtok_r(opts, \":\", &saveptr);\n\t\topts = NULL;\n\t\t\n\t\tif (!opt)\n\t\t\tbreak;\n\t\t\n\t\tif (!opt[0])\n\t\t\tcontinue;\n\t\t\n\t\tadd_set_device_option(\"avalon:%s=%s\", sdf->optname, opt);\n\t}\n\tfree(argdup);\n\treturn NULL;\n}\n#endif\n\n#ifdef USE_KLONDIKE\nstatic char *set_klondike_options(const char *arg)\n{\n\tint hashclock;\n\tdouble temptarget;\n\tswitch (sscanf(arg, \"%d:%lf\", &hashclock, &temptarget))\n\t{\n\t\tdefault:\n\t\t\treturn \"Unrecognised --klondike-options\";\n\t\tcase 2:\n\t\t\tadd_set_device_option(\"klondike:temp-target=%lf\", temptarget);\n\t\t\t// fallthru\n\t\tcase 1:\n\t\t\tadd_set_device_option(\"klondike:clock=%d\", hashclock);\n\t}\n\tapplog(LOG_WARNING, \"klondike-options is deprecated! Use --set-device for better control\");\n\t\n\treturn NULL;\n}\n#endif\n\n__maybe_unused\nstatic char *set_null(const char __maybe_unused *arg)\n{\n\treturn NULL;\n}\n\n/* These options are available from config file or commandline */\nstatic struct opt_table opt_config_table[] = {\n#ifdef USE_CPUMINING\n#ifdef USE_SHA256D\n\tOPT_WITH_ARG(\"--algo\",\n\t\t     set_algo, show_algo, &opt_algo,\n\t\t     \"Specify sha256 implementation for CPU mining:\\n\"\n\t\t     \"\\tfastauto*\\tQuick benchmark at startup to pick a working algorithm\\n\"\n\t\t     \"\\tauto\\t\\tBenchmark at startup and pick fastest algorithm\"\n\t\t     \"\\n\\tc\\t\\tLinux kernel sha256, implemented in C\"\n#ifdef WANT_SSE2_4WAY\n\t\t     \"\\n\\t4way\\t\\ttcatm's 4-way SSE2 implementation\"\n#endif\n#ifdef WANT_VIA_PADLOCK\n\t\t     \"\\n\\tvia\\t\\tVIA padlock implementation\"\n#endif\n\t\t     \"\\n\\tcryptopp\\tCrypto++ C/C++ implementation\"\n#ifdef WANT_CRYPTOPP_ASM32\n\t\t     \"\\n\\tcryptopp_asm32\\tCrypto++ 32-bit assembler implementation\"\n#endif\n#ifdef WANT_X8632_SSE2\n\t\t     \"\\n\\tsse2_32\\t\\tSSE2 32 bit implementation for i386 machines\"\n#endif\n#ifdef WANT_X8664_SSE2\n\t\t     \"\\n\\tsse2_64\\t\\tSSE2 64 bit implementation for x86_64 machines\"\n#endif\n#ifdef WANT_X8664_SSE4\n\t\t     \"\\n\\tsse4_64\\t\\tSSE4.1 64 bit implementation for x86_64 machines\"\n#endif\n#ifdef WANT_ALTIVEC_4WAY\n    \"\\n\\taltivec_4way\\tAltivec implementation for PowerPC G4 and G5 machines\"\n#endif\n\t\t),\n\tOPT_WITH_ARG(\"-a\",\n\t             set_algo, show_algo, &opt_algo,\n\t             opt_hidden),\n#else\n\t// NOTE: Silently ignoring option, since it is plausable a non-SHA256d miner was using it just to skip benchmarking\n\tOPT_WITH_ARG(\"--algo|-a\", arg_ignored, NULL, NULL, opt_hidden),\n#endif  /* USE_SHA256D */\n#endif  /* USE_CPUMINING */\n\tOPT_WITH_ARG(\"--api-allow\",\n\t\t     set_api_allow, NULL, NULL,\n\t\t     \"Allow API access only to the given list of [G:]IP[/Prefix] addresses[/subnets]\"),\n\tOPT_WITH_ARG(\"--api-description\",\n\t\t     set_api_description, NULL, NULL,\n\t\t     \"Description placed in the API status header, default: BFGMiner version\"),\n\tOPT_WITH_ARG(\"--api-groups\",\n\t\t     set_api_groups, NULL, NULL,\n\t\t     \"API one letter groups G:cmd:cmd[,P:cmd:*...] defining the cmds a groups can use\"),\n\tOPT_WITHOUT_ARG(\"--api-listen\",\n\t\t\topt_set_bool, &opt_api_listen,\n\t\t\t\"Enable API, default: disabled\"),\n\tOPT_WITHOUT_ARG(\"--api-mcast\",\n\t\t\topt_set_bool, &opt_api_mcast,\n\t\t\t\"Enable API Multicast listener, default: disabled\"),\n\tOPT_WITH_ARG(\"--api-mcast-addr\",\n\t\t     opt_set_charp, opt_show_charp, &opt_api_mcast_addr,\n\t\t     \"API Multicast listen address\"),\n\tOPT_WITH_ARG(\"--api-mcast-code\",\n\t\t     opt_set_charp, opt_show_charp, &opt_api_mcast_code,\n\t\t     \"Code expected in the API Multicast message, don't use '-'\"),\n\tOPT_WITH_ARG(\"--api-mcast-des\",\n\t\t     set_api_mcast_des, NULL, NULL,\n\t\t     \"Description appended to the API Multicast reply, default: ''\"),\n\tOPT_WITH_ARG(\"--api-mcast-port\",\n\t\t     set_int_1_to_65535, opt_show_intval, &opt_api_mcast_port,\n\t\t     \"API Multicast listen port\"),\n\tOPT_WITHOUT_ARG(\"--api-network\",\n\t\t\topt_set_bool, &opt_api_network,\n\t\t\t\"Allow API (if enabled) to listen on/for any address, default: only 127.0.0.1\"),\n\tOPT_WITH_ARG(\"--api-port\",\n\t\t     set_int_1_to_65535, opt_show_intval, &opt_api_port,\n\t\t     \"Port number of miner API\"),\n#ifdef HAVE_ADL\n\tOPT_WITHOUT_ARG(\"--auto-fan\",\n\t\t\topt_set_bool, &opt_autofan,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--auto-gpu\",\n\t\t\topt_set_bool, &opt_autoengine,\n\t\t\topt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--balance\",\n\t\t     set_balance, &pool_strategy,\n\t\t     \"Change multipool strategy from failover to even share balance\"),\n\tOPT_WITHOUT_ARG(\"--benchmark\",\n\t\t\topt_set_bool, &opt_benchmark,\n\t\t\t\"Run BFGMiner in benchmark mode - produces no shares\"),\n\tOPT_WITHOUT_ARG(\"--benchmark-intense\",\n\t\t\tset_benchmark_intense, &opt_benchmark_intense,\n\t\t\t\"Run BFGMiner in intensive benchmark mode - produces no shares\"),\n#if defined(USE_BITFORCE)\n\tOPT_WITHOUT_ARG(\"--bfl-range\",\n\t\t\topt_set_bool, &opt_bfl_noncerange,\n\t\t\t\"Use nonce range on bitforce devices if supported\"),\n#endif\n#ifdef HAVE_CHROOT\n        OPT_WITH_ARG(\"--chroot-dir\",\n                     opt_set_charp, NULL, &chroot_dir,\n                     \"Chroot to a directory right after startup\"),\n#endif\n\tOPT_WITH_ARG(\"--cmd-idle\",\n\t             opt_set_charp, NULL, &cmd_idle,\n\t             \"Execute a command when a device is allowed to be idle (rest or wait)\"),\n\tOPT_WITH_ARG(\"--cmd-sick\",\n\t             opt_set_charp, NULL, &cmd_sick,\n\t             \"Execute a command when a device is declared sick\"),\n\tOPT_WITH_ARG(\"--cmd-dead\",\n\t             opt_set_charp, NULL, &cmd_dead,\n\t             \"Execute a command when a device is declared dead\"),\n#if BLKMAKER_VERSION > 0\n\tOPT_WITH_ARG(\"--coinbase-sig\",\n\t\t     set_strdup, NULL, &opt_coinbase_sig,\n\t\t     \"Set coinbase signature when possible\"),\n\tOPT_WITH_ARG(\"--coinbase|--cbsig|--cb-sig|--cb|--prayer\",\n\t\t     set_strdup, NULL, &opt_coinbase_sig,\n\t\t     opt_hidden),\n#endif\n#ifdef HAVE_CURSES\n\tOPT_WITHOUT_ARG(\"--compact\",\n\t\t\topt_set_bool, &opt_compact,\n\t\t\t\"Use compact display without per device statistics\"),\n#endif\n#ifdef USE_CPUMINING\n\tOPT_WITH_ARG(\"--cpu-threads\",\n\t\t     force_nthreads_int, opt_show_intval, &opt_n_threads,\n\t\t     \"Number of miner CPU threads\"),\n\tOPT_WITH_ARG(\"-t\",\n\t             force_nthreads_int, opt_show_intval, &opt_n_threads,\n\t             opt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--debug|-D\",\n\t\t     enable_debug, &opt_debug,\n\t\t     \"Enable debug output\"),\n\tOPT_WITHOUT_ARG(\"--debuglog\",\n\t\t     opt_set_bool, &opt_debug,\n\t\t     \"Enable debug logging\"),\n\tOPT_WITHOUT_ARG(\"--device-protocol-dump\",\n\t\t\topt_set_bool, &opt_dev_protocol,\n\t\t\t\"Verbose dump of device protocol-level activities\"),\n\tOPT_WITH_ARG(\"--device|-d\",\n\t\t     set_devices, NULL, NULL,\n\t             \"Enable only devices matching pattern (default: all)\"),\n\tOPT_WITHOUT_ARG(\"--disable-rejecting\",\n\t\t\topt_set_bool, &opt_disable_pool,\n\t\t\t\"Automatically disable pools that continually reject shares\"),\n#ifdef USE_LIBMICROHTTPD\n\tOPT_WITH_ARG(\"--http-port\",\n\t             opt_set_intval, opt_show_intval, &httpsrv_port,\n\t             \"Port number to listen on for HTTP getwork miners (-1 means disabled)\"),\n#endif\n\tOPT_WITH_ARG(\"--expiry\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_expiry,\n\t\t     \"Upper bound on how many seconds after getting work we consider a share from it stale (w/o longpoll active)\"),\n\tOPT_WITH_ARG(\"-E\",\n\t             set_int_0_to_9999, opt_show_intval, &opt_expiry,\n\t             opt_hidden),\n\tOPT_WITH_ARG(\"--expiry-lp\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_expiry_lp,\n\t\t     \"Upper bound on how many seconds after getting work we consider a share from it stale (with longpoll active)\"),\n\tOPT_WITHOUT_ARG(\"--failover-only\",\n\t\t\topt_set_bool, &opt_fail_only,\n\t\t\t\"Don't leak work to backup pools when primary pool is lagging\"),\n\tOPT_WITH_ARG(\"--failover-switch-delay\",\n\t\t\tset_int_1_to_65535, opt_show_intval, &opt_fail_switch_delay,\n\t\t\t\"Delay in seconds before switching back to a failed pool\"),\n#ifdef USE_FPGA\n\tOPT_WITHOUT_ARG(\"--force-dev-init\",\n\t        opt_set_bool, &opt_force_dev_init,\n\t        \"Always initialize devices when possible (such as bitstream uploads to some FPGAs)\"),\n#endif\n#if BLKMAKER_VERSION > 1\n\tOPT_WITH_ARG(\"--generate-to\",\n\t             set_generate_addr, NULL, NULL,\n\t             \"Set an address to generate to for solo mining\"),\n\tOPT_WITH_ARG(\"--generate-to-addr|--generate-to-address|--genaddress|--genaddr|--gen-address|--gen-addr|--generate-address|--generate-addr|--coinbase-addr|--coinbase-address|--coinbase-payout|--cbaddress|--cbaddr|--cb-address|--cb-addr|--payout\",\n\t             set_generate_addr, NULL, NULL,\n\t             opt_hidden),\n#endif\n#ifdef USE_OPENCL\n\tOPT_WITH_ARG(\"--gpu-dyninterval\",\n\t\t     set_int_1_to_65535, opt_show_intval, &opt_dynamic_interval,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--gpu-platform\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_platform_id,\n\t\t     \"Select OpenCL platform ID to use for GPU mining\"),\n\tOPT_WITH_ARG(\"--gpu-threads|-g\",\n\t             set_gpu_threads, opt_show_intval, &opt_g_threads,\n\t             opt_hidden),\n#ifdef HAVE_ADL\n\tOPT_WITH_ARG(\"--gpu-engine\",\n\t\t     set_gpu_engine, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITH_ARG(\"--gpu-fan\",\n\t\t     set_gpu_fan, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITH_ARG(\"--gpu-map\",\n\t\t     set_gpu_map, NULL, NULL,\n\t\t     \"Map OpenCL to ADL device order manually, paired CSV (e.g. 1:0,2:1 maps OpenCL 1 to ADL 0, 2 to 1)\"),\n\tOPT_WITH_ARG(\"--gpu-memclock\",\n\t\t     set_gpu_memclock, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITH_ARG(\"--gpu-memdiff\",\n\t\t     set_gpu_memdiff, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITH_ARG(\"--gpu-powertune\",\n\t\t     set_gpu_powertune, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITHOUT_ARG(\"--gpu-reorder\",\n\t\t\topt_set_bool, &opt_reorder,\n\t\t\t\"Attempt to reorder GPU devices according to PCI Bus ID\"),\n\tOPT_WITH_ARG(\"--gpu-vddc\",\n\t\t     set_gpu_vddc, NULL, NULL,\n\t             opt_hidden),\n#endif\n#ifdef USE_SCRYPT\n\tOPT_WITH_ARG(\"--lookup-gap\",\n\t\t     set_lookup_gap, NULL, NULL,\n\t             opt_hidden),\n#endif\n\tOPT_WITH_ARG(\"--intensity|-I\",\n\t             set_intensity, NULL, NULL,\n\t             opt_hidden),\n#endif\n#if defined(USE_OPENCL) || defined(USE_MODMINER) || defined(USE_X6500) || defined(USE_ZTEX)\n\tOPT_WITH_ARG(\"--kernel-path\",\n\t\t     opt_set_charp, opt_show_charp, &opt_kernel_path,\n\t             \"Specify a path to where bitstream and kernel files are\"),\n\tOPT_WITH_ARG(\"-K\",\n\t             opt_set_charp, opt_show_charp, &opt_kernel_path,\n\t             opt_hidden),\n#endif\n#ifdef USE_OPENCL\n\tOPT_WITH_ARG(\"--kernel|-k\",\n\t             set_kernel, NULL, NULL,\n\t             opt_hidden),\n#endif\n#ifdef USE_ICARUS\n\tOPT_WITH_ARG(\"--icarus-options\",\n\t\t     set_icarus_options, NULL, NULL,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--icarus-timing\",\n\t\t     set_icarus_timing, NULL, NULL,\n\t\t     opt_hidden),\n#endif\n#ifdef USE_AVALON\n\tOPT_WITH_ARG(\"--avalon-options\",\n\t\t     set_avalon_options, NULL, NULL,\n\t\t     opt_hidden),\n#endif\n#ifdef USE_KLONDIKE\n\tOPT_WITH_ARG(\"--klondike-options\",\n\t\t     set_klondike_options, NULL, NULL,\n\t\t     \"Set klondike options clock:temptarget\"),\n#endif\n\tOPT_WITHOUT_ARG(\"--load-balance\",\n\t\t     set_loadbalance, &pool_strategy,\n\t\t     \"Change multipool strategy from failover to quota based balance\"),\n\tOPT_WITH_ARG(\"--log|-l\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_log_interval,\n\t\t     \"Interval in seconds between log output\"),\n\tOPT_WITH_ARG(\"--log-file|-L\",\n\t             set_log_file, NULL, NULL,\n\t             \"Append log file for output messages\"),\n\tOPT_WITH_ARG(\"--logfile\",\n\t             set_log_file, NULL, NULL,\n\t             opt_hidden),\n\tOPT_WITHOUT_ARG(\"--log-microseconds\",\n\t                opt_set_bool, &opt_log_microseconds,\n\t                \"Include microseconds in log output\"),\n#if defined(unix) || defined(__APPLE__)\n\tOPT_WITH_ARG(\"--monitor|-m\",\n\t\t     opt_set_charp, NULL, &opt_stderr_cmd,\n\t\t     \"Use custom pipe cmd for output messages\"),\n#endif // defined(unix)\n\tOPT_WITHOUT_ARG(\"--net-delay\",\n\t\t\topt_set_bool, &opt_delaynet,\n\t\t\t\"Impose small delays in networking to avoid overloading slow routers\"),\n\tOPT_WITHOUT_ARG(\"--no-adl\",\n\t\t\topt_set_bool, &opt_noadl,\n#ifdef HAVE_ADL\n\t\t\t\"Disable the ATI display library used for monitoring and setting GPU parameters\"\n#else\n\t\t\topt_hidden\n#endif\n\t\t\t),\n\tOPT_WITHOUT_ARG(\"--no-gbt\",\n\t\t\topt_set_invbool, &want_gbt,\n\t\t\t\"Disable getblocktemplate support\"),\n\tOPT_WITHOUT_ARG(\"--no-getwork\",\n\t\t\topt_set_invbool, &want_getwork,\n\t\t\t\"Disable getwork support\"),\n\tOPT_WITHOUT_ARG(\"--no-hotplug\",\n#ifdef HAVE_BFG_HOTPLUG\n\t                opt_set_invbool, &opt_hotplug,\n\t                \"Disable hotplug detection\"\n#else\n\t                set_null, &opt_hotplug,\n\t                opt_hidden\n#endif\n\t),\n\tOPT_WITHOUT_ARG(\"--no-local-bitcoin\",\n#if BLKMAKER_VERSION > 1\n\t                opt_set_invbool, &opt_load_bitcoin_conf,\n\t                \"Disable adding pools for local bitcoin RPC servers\"),\n#else\n\t                set_null, NULL, opt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--no-longpoll\",\n\t\t\topt_set_invbool, &want_longpoll,\n\t\t\t\"Disable X-Long-Polling support\"),\n\tOPT_WITHOUT_ARG(\"--no-pool-disable\",\n\t\t\topt_set_invbool, &opt_disable_pool,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--no-client-reconnect\",\n\t\t\topt_set_invbool, &opt_disable_client_reconnect,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--no-pool-redirect\",\n\t\t\tdisable_pool_redirect, NULL,\n\t\t\t\"Ignore pool requests to redirect to another server\"),\n\tOPT_WITHOUT_ARG(\"--no-restart\",\n\t\t\topt_set_invbool, &opt_restart,\n\t\t\t\"Do not attempt to restart devices that hang\"\n\t),\n\tOPT_WITHOUT_ARG(\"--no-show-processors\",\n\t\t\topt_set_invbool, &opt_show_procs,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--no-show-procs\",\n\t\t\topt_set_invbool, &opt_show_procs,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--no-stratum\",\n\t\t\topt_set_invbool, &want_stratum,\n\t\t\t\"Disable Stratum detection\"),\n\tOPT_WITHOUT_ARG(\"--no-submit-stale\",\n\t\t\topt_set_invbool, &opt_submit_stale,\n\t\t        \"Don't submit shares if they are detected as stale\"),\n#ifdef USE_OPENCL\n\tOPT_WITHOUT_ARG(\"--no-opencl-binaries\",\n\t                set_no_opencl_binaries, NULL,\n\t                opt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--no-unicode\",\n#ifdef USE_UNICODE\n\t                opt_set_invbool, &use_unicode,\n\t                \"Don't use Unicode characters in TUI\"\n#else\n\t                set_null, &use_unicode,\n\t                opt_hidden\n#endif\n\t),\n\tOPT_WITH_ARG(\"--noncelog\",\n\t\t     set_noncelog, NULL, NULL,\n\t\t     \"Create log of all nonces found\"),\n\tOPT_WITH_ARG(\"--pass|-p\",\n\t\t     set_pass, NULL, NULL,\n\t\t     \"Password for bitcoin JSON-RPC server\"),\n\tOPT_WITHOUT_ARG(\"--per-device-stats\",\n\t\t\topt_set_bool, &want_per_device_stats,\n\t\t\t\"Force verbose mode and output per-device statistics\"),\n\tOPT_WITH_ARG(\"--userpass|-O\",\n\t             set_userpass, NULL, NULL,\n\t             \"Username:Password pair for bitcoin JSON-RPC server\"),\n\tOPT_WITH_ARG(\"--pool-goal\",\n\t\t\t set_pool_goal, NULL, NULL,\n\t\t\t \"Named goal for the previous-defined pool\"),\n\tOPT_WITH_ARG(\"--pool-priority\",\n\t\t\t set_pool_priority, NULL, NULL,\n\t\t\t \"Priority for just the previous-defined pool\"),\n\tOPT_WITH_ARG(\"--pool-proxy|-x\",\n\t\t     set_pool_proxy, NULL, NULL,\n\t\t     \"Proxy URI to use for connecting to just the previous-defined pool\"),\n\tOPT_WITH_ARG(\"--force-rollntime\",  // NOTE: must be after --pass for config file ordering\n\t\t\t set_pool_force_rollntime, NULL, NULL,\n\t\t\t opt_hidden),\n\tOPT_WITHOUT_ARG(\"--protocol-dump|-P\",\n\t\t\topt_set_bool, &opt_protocol,\n\t\t\t\"Verbose dump of protocol-level activities\"),\n\tOPT_WITH_ARG(\"--queue|-Q\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_queue,\n\t\t     \"Minimum number of work items to have queued (0+)\"),\n\tOPT_WITHOUT_ARG(\"--quiet|-q\",\n\t\t\topt_set_bool, &opt_quiet,\n\t\t\t\"Disable logging output, display status and errors\"),\n\tOPT_WITHOUT_ARG(\"--quiet-work-updates|--quiet-work-update\",\n\t\t\topt_set_bool, &opt_quiet_work_updates,\n\t\t\topt_hidden),\n\tOPT_WITH_ARG(\"--quit-summary\",\n\t             set_quit_summary, NULL, NULL,\n\t             \"Summary printed when you quit: none/devs/procs/detailed\"),\n\tOPT_WITH_ARG(\"--quota|-U\",\n\t\t     set_quota, NULL, NULL,\n\t\t     \"quota;URL combination for server with load-balance strategy quotas\"),\n\tOPT_WITHOUT_ARG(\"--real-quiet\",\n\t\t\topt_set_bool, &opt_realquiet,\n\t\t\t\"Disable all output\"),\n\tOPT_WITH_ARG(\"--request-diff\",\n\t             set_request_diff, opt_show_floatval, &request_pdiff,\n\t             \"Request a specific difficulty from pools\"),\n\tOPT_WITH_ARG(\"--retries\",\n\t\t     opt_set_intval, opt_show_intval, &opt_retries,\n\t\t     \"Number of times to retry failed submissions before giving up (-1 means never)\"),\n\tOPT_WITH_ARG(\"--retry-pause\",\n\t\t     set_null, NULL, NULL,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--rotate\",\n\t\t     set_rotate, opt_show_intval, &opt_rotate_period,\n\t\t     \"Change multipool strategy from failover to regularly rotate at N minutes\"),\n\tOPT_WITHOUT_ARG(\"--round-robin\",\n\t\t     set_rr, &pool_strategy,\n\t\t     \"Change multipool strategy from failover to round robin on failure\"),\n\tOPT_WITH_ARG(\"--scan|-S\",\n\t\t     add_serial, NULL, NULL,\n\t\t     \"Configure how to scan for mining devices\"),\n\tOPT_WITH_ARG(\"--scan-device|--scan-serial|--devscan\",\n\t\t     add_serial, NULL, NULL,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--scan-time\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_scantime,\n\t\t     \"Upper bound on time spent scanning current work, in seconds\"),\n\tOPT_WITH_ARG(\"-s\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_scantime,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--scantime\",\n\t\t     set_int_0_to_9999, opt_show_intval, &opt_scantime,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--sched-start\",\n\t\t     set_schedtime, NULL, &schedstart,\n\t\t     \"Set a time of day in HH:MM to start mining (a once off without a stop time)\"),\n\tOPT_WITH_ARG(\"--sched-stop\",\n\t\t     set_schedtime, NULL, &schedstop,\n\t\t     \"Set a time of day in HH:MM to stop mining (will quit without a start time)\"),\n#ifdef USE_SCRYPT\n\tOPT_WITHOUT_ARG(\"--scrypt\",\n\t                set_malgo_scrypt, NULL,\n\t\t\t\"Use the scrypt algorithm for mining (non-bitcoin)\"),\n#endif\n\tOPT_WITH_ARG(\"--set-device|--set\",\n\t\t\topt_string_elist_add, NULL, &opt_set_device_list,\n\t\t\t\"Set default parameters on devices; eg\"\n\t\t\t\", NFY:osc6_bits=50\"\n\t\t\t\", bfl:voltage=<value>\"\n\t\t\t\", compac:clock=<value>\"\n\t),\n\n#if defined(USE_SCRYPT) && defined(USE_OPENCL)\n\tOPT_WITH_ARG(\"--shaders\",\n\t\t     set_shaders, NULL, NULL,\n\t             opt_hidden),\n#endif\n#ifdef HAVE_PWD_H\n        OPT_WITH_ARG(\"--setuid\",\n                     opt_set_charp, NULL, &opt_setuid,\n                     \"Username of an unprivileged user to run as\"),\n#endif\n\tOPT_WITH_ARG(\"--sharelog\",\n\t\t     set_sharelog, NULL, NULL,\n\t\t     \"Append share log to file\"),\n\tOPT_WITH_ARG(\"--shares\",\n\t\t     opt_set_floatval, NULL, &opt_shares,\n\t\t     \"Quit after mining 2^32 * N hashes worth of shares (default: unlimited)\"),\n\tOPT_WITHOUT_ARG(\"--show-processors\",\n\t\t\topt_set_bool, &opt_show_procs,\n\t\t\t\"Show per processor statistics in summary\"),\n\tOPT_WITHOUT_ARG(\"--show-procs\",\n\t\t\topt_set_bool, &opt_show_procs,\n\t\t\topt_hidden),\n\tOPT_WITH_ARG(\"--skip-security-checks\",\n\t\t\tset_int_0_to_9999, NULL, &opt_skip_checks,\n\t\t\t\"Skip security checks sometimes to save bandwidth; only check 1/<arg>th of the time (default: never skip)\"),\n\tOPT_WITH_ARG(\"--socks-proxy\",\n\t\t     opt_set_charp, NULL, &opt_socks_proxy,\n\t\t     \"Set socks proxy (host:port)\"),\n#ifdef USE_LIBEVENT\n\tOPT_WITH_ARG(\"--stratum-port\",\n\t             set_long_1_to_65535_or_neg1, opt_show_longval, &stratumsrv_port,\n\t             \"Port number to listen on for stratum miners (-1 means disabled)\"),\n#endif\n\tOPT_WITHOUT_ARG(\"--submit-stale\",\n\t\t\topt_set_bool, &opt_submit_stale,\n\t                opt_hidden),\n\tOPT_WITH_ARG(\"--submit-threads\",\n\t                opt_set_intval, opt_show_intval, &opt_submit_threads,\n\t                \"Minimum number of concurrent share submissions (default: 64)\"),\n#ifdef HAVE_SYSLOG_H\n\tOPT_WITHOUT_ARG(\"--syslog\",\n\t\t\topt_set_bool, &use_syslog,\n\t\t\t\"Use system log for output messages (default: standard error)\"),\n#endif\n\tOPT_WITH_ARG(\"--temp-cutoff\",\n\t\t     set_temp_cutoff, NULL, &opt_cutofftemp,\n\t\t     opt_hidden),\n\tOPT_WITH_ARG(\"--temp-hysteresis\",\n\t\t     set_int_1_to_10, opt_show_intval, &opt_hysteresis,\n\t\t     \"Set how much the temperature can fluctuate outside limits when automanaging speeds\"),\n#ifdef HAVE_ADL\n\tOPT_WITH_ARG(\"--temp-overheat\",\n\t\t     set_temp_overheat, opt_show_intval, &opt_overheattemp,\n\t             opt_hidden),\n#endif\n\tOPT_WITH_ARG(\"--temp-target\",\n\t\t     set_temp_target, NULL, NULL,\n\t\t     opt_hidden),\n\tOPT_WITHOUT_ARG(\"--text-only|-T\",\n\t\t\topt_set_invbool, &use_curses,\n#ifdef HAVE_CURSES\n\t\t\t\"Disable ncurses formatted screen output\"\n#else\n\t\t\topt_hidden\n#endif\n\t),\n#if defined(USE_SCRYPT) && defined(USE_OPENCL)\n\tOPT_WITH_ARG(\"--thread-concurrency\",\n\t\t     set_thread_concurrency, NULL, NULL,\n\t             opt_hidden),\n#endif\n#ifdef USE_UNICODE\n\tOPT_WITHOUT_ARG(\"--unicode\",\n\t                opt_set_bool, &use_unicode,\n\t                \"Use Unicode characters in TUI\"),\n#endif\n\tOPT_WITH_ARG(\"--url|-o\",\n\t\t     set_url, NULL, NULL,\n\t\t     \"URL for bitcoin JSON-RPC server\"),\n\tOPT_WITH_ARG(\"--user|-u\",\n\t\t     set_user, NULL, NULL,\n\t\t     \"Username for bitcoin JSON-RPC server\"),\n#ifdef USE_OPENCL\n\tOPT_WITH_ARG(\"--vectors|-v\",\n\t             set_vector, NULL, NULL,\n\t             opt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--verbose\",\n\t\t\topt_set_bool, &opt_log_output,\n\t\t\t\"Log verbose output to stderr as well as status output\"),\n\tOPT_WITHOUT_ARG(\"--verbose-work-updates|--verbose-work-update\",\n\t\t\topt_set_invbool, &opt_quiet_work_updates,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--weighed-stats\",\n\t                opt_set_bool, &opt_weighed_stats,\n\t                \"Display statistics weighed to difficulty 1\"),\n#ifdef USE_OPENCL\n\tOPT_WITH_ARG(\"--worksize|-w\",\n\t             set_worksize, NULL, NULL,\n\t             opt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--unittest\",\n\t\t\topt_set_bool, &opt_unittest, opt_hidden),\n\tOPT_WITH_ARG(\"--coinbase-check-addr\",\n\t\t\tset_cbcaddr, NULL, NULL,\n\t\t\t\"A list of address to check against in coinbase payout list received from the previous-defined pool, separated by ','\"),\n\tOPT_WITH_ARG(\"--cbcheck-addr|--cbc-addr|--cbcaddr\",\n\t\t\tset_cbcaddr, NULL, NULL,\n\t\t\topt_hidden),\n\tOPT_WITH_ARG(\"--coinbase-check-total\",\n\t\t\tset_cbctotal, NULL, NULL,\n\t\t\t\"The least total payout amount expected in coinbase received from the previous-defined pool\"),\n\tOPT_WITH_ARG(\"--cbcheck-total|--cbc-total|--cbctotal\",\n\t\t\tset_cbctotal, NULL, NULL,\n\t\t\topt_hidden),\n\tOPT_WITH_ARG(\"--coinbase-check-percent\",\n\t\t\tset_cbcperc, NULL, NULL,\n\t\t\t\"The least benefit percentage expected for the sum of addr(s) listed in --cbaddr argument for previous-defined pool\"),\n\tOPT_WITH_ARG(\"--cbcheck-percent|--cbc-percent|--cbcpercent|--cbcperc\",\n\t\t\tset_cbcperc, NULL, NULL,\n\t\t\topt_hidden),\n\tOPT_WITHOUT_ARG(\"--worktime\",\n\t\t\topt_set_bool, &opt_worktime,\n\t\t\t\"Display extra work time debug information\"),\n\tOPT_WITH_ARG(\"--pools\",\n\t\t\topt_set_bool, NULL, NULL, opt_hidden),\n\tOPT_ENDTABLE\n};\n\nstatic char *load_config(const char *arg, void __maybe_unused *unused);\n\nstatic char *parse_config(json_t *config, bool fileconf, int * const fileconf_load_p)\n{\n\tstatic char err_buf[200];\n\tstruct opt_table *opt;\n\tjson_t *val;\n\n\tif (fileconf && !*fileconf_load_p)\n\t\t*fileconf_load_p = 1;\n\n\tfor (opt = opt_config_table; opt->type != OPT_END; opt++) {\n\t\tchar *p, *name, *sp;\n\n\t\t/* We don't handle subtables. */\n\t\tassert(!(opt->type & OPT_SUBTABLE));\n\n\t\tif (!opt->names)\n\t\t\tcontinue;\n\n\t\t/* Pull apart the option name(s). */\n\t\tname = strdup(opt->names);\n\t\tfor (p = strtok_r(name, \"|\", &sp); p; p = strtok_r(NULL, \"|\", &sp)) {\n\t\t\tchar *err = \"Invalid value\";\n\n\t\t\t/* Ignore short options. */\n\t\t\tif (p[1] != '-')\n\t\t\t\tcontinue;\n\n\t\t\tval = json_object_get(config, p+2);\n\t\t\tif (!val)\n\t\t\t\tcontinue;\n\n\t\t\tif (opt->type & OPT_HASARG) {\n\t\t\t  if (json_is_string(val)) {\n\t\t\t\terr = opt->cb_arg(json_string_value(val),\n\t\t\t\t\t\t  opt->u.arg);\n\t\t\t  } else if (json_is_number(val)) {\n\t\t\t\t\tchar buf[256], *p, *q;\n\t\t\t\t\tsnprintf(buf, 256, \"%f\", json_number_value(val));\n\t\t\t\t\tif ( (p = strchr(buf, '.')) ) {\n\t\t\t\t\t\t// Trim /\\.0*$/ to work properly with integer-only arguments\n\t\t\t\t\t\tq = p;\n\t\t\t\t\t\twhile (*(++q) == '0') {}\n\t\t\t\t\t\tif (*q == '\\0')\n\t\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\terr = opt->cb_arg(buf, opt->u.arg);\n\t\t\t  } else if (json_is_array(val)) {\n\t\t\t\tint n, size = json_array_size(val);\n\n\t\t\t\terr = NULL;\n\t\t\t\tfor (n = 0; n < size && !err; n++) {\n\t\t\t\t\tif (json_is_string(json_array_get(val, n)))\n\t\t\t\t\t\terr = opt->cb_arg(json_string_value(json_array_get(val, n)), opt->u.arg);\n\t\t\t\t\telse if (json_is_object(json_array_get(val, n)))\n\t\t\t\t\t\terr = parse_config(json_array_get(val, n), false, fileconf_load_p);\n\t\t\t\t}\n\t\t\t  }\n\t\t\t} else if (opt->type & OPT_NOARG) {\n\t\t\t\tif (json_is_true(val))\n\t\t\t\t\terr = opt->cb(opt->u.arg);\n\t\t\t\telse if (json_is_boolean(val)) {\n\t\t\t\t\tif (opt->cb == (void*)opt_set_bool)\n\t\t\t\t\t\terr = opt_set_invbool(opt->u.arg);\n\t\t\t\t\telse if (opt->cb == (void*)opt_set_invbool)\n\t\t\t\t\t\terr = opt_set_bool(opt->u.arg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (err) {\n\t\t\t\t/* Allow invalid values to be in configuration\n\t\t\t\t * file, just skipping over them provided the\n\t\t\t\t * JSON is still valid after that. */\n\t\t\t\tif (fileconf) {\n\t\t\t\t\tapplog(LOG_ERR, \"Invalid config option %s: %s\", p, err);\n\t\t\t\t\t*fileconf_load_p = -1;\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(err_buf, sizeof(err_buf), \"Parsing JSON option %s: %s\",\n\t\t\t\t\t\tp, err);\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn err_buf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t}\n\n\tval = json_object_get(config, JSON_INCLUDE_CONF);\n\tif (val && json_is_string(val))\n\t\treturn load_config(json_string_value(val), NULL);\n\n\treturn NULL;\n}\n\nstruct bfg_loaded_configfile *bfg_loaded_configfiles;\n\nchar conf_web1[] = \"http://\";\nchar conf_web2[] = \"https://\";\n\nstatic char *load_web_config(const char *arg)\n{\n\tjson_t *val;\n\tCURL *curl;\n\tstruct bfg_loaded_configfile *cfginfo;\n\n\tcurl = curl_easy_init();\n\tif (unlikely(!curl))\n\t\tquithere(1, \"CURL initialisation failed\");\n\n\tval = json_web_config(curl, arg);\n\n\tcurl_easy_cleanup(curl);\n\n\tif (!val || !json_is_object(val))\n\t\treturn JSON_WEB_ERROR;\n\n\tcfginfo = malloc(sizeof(*cfginfo));\n\t*cfginfo = (struct bfg_loaded_configfile){\n\t\t.filename = strdup(arg),\n\t};\n\tLL_APPEND(bfg_loaded_configfiles, cfginfo);\n\n\tconfig_loaded = true;\n\n\treturn parse_config(val, true, &cfginfo->fileconf_load);\n}\n\nstatic char *load_config(const char *arg, void __maybe_unused *unused)\n{\n\tjson_error_t err;\n\tjson_t *config;\n\tchar *json_error;\n\tsize_t siz;\n\tstruct bfg_loaded_configfile *cfginfo;\n\n\tif (strncasecmp(arg, conf_web1, sizeof(conf_web1)-1) == 0 ||\n\t    strncasecmp(arg, conf_web2, sizeof(conf_web2)-1) == 0)\n\t\treturn load_web_config(arg);\n\n\tcfginfo = malloc(sizeof(*cfginfo));\n\t*cfginfo = (struct bfg_loaded_configfile){\n\t\t.filename = strdup(arg),\n\t};\n\tLL_APPEND(bfg_loaded_configfiles, cfginfo);\n\n\tif (++include_count > JSON_MAX_DEPTH)\n\t\treturn JSON_MAX_DEPTH_ERR;\n\n#if JANSSON_MAJOR_VERSION > 1\n\tconfig = json_load_file(arg, 0, &err);\n#else\n\tconfig = json_load_file(arg, &err);\n#endif\n\tif (!json_is_object(config)) {\n\t\tsiz = JSON_LOAD_ERROR_LEN + strlen(arg) + strlen(err.text);\n\t\tjson_error = malloc(siz);\n\t\tif (!json_error)\n\t\t\tquit(1, \"Malloc failure in json error\");\n\n\t\tsnprintf(json_error, siz, JSON_LOAD_ERROR, arg, err.text);\n\t\treturn json_error;\n\t}\n\n\tconfig_loaded = true;\n\n\t/* Parse the config now, so we can override it.  That can keep pointers\n\t * so don't free config object. */\n\treturn parse_config(config, true, &cfginfo->fileconf_load);\n}\n\nstatic\nbool _load_default_configs(const char * const filepath, void * __maybe_unused userp)\n{\n\tbool * const found_defcfg_p = userp;\n\t*found_defcfg_p = true;\n\t\n\tload_config(filepath, NULL);\n\t\n\t// Regardless of status of loading the config file, we should continue loading other defaults\n\treturn false;\n}\n\nstatic void load_default_config(void)\n{\n\tbool found_defcfg = false;\n\tappdata_file_call(\"BFGMiner\", def_conf, _load_default_configs, &found_defcfg);\n\t\n\tif (!found_defcfg)\n\t{\n\t\t// No BFGMiner config, try Cgminer's...\n\t\tappdata_file_call(\"cgminer\", \"cgminer.conf\", _load_default_configs, &found_defcfg);\n\t}\n}\n\nextern const char *opt_argv0;\n\nstatic\nvoid bfg_versioninfo(void)\n{\n\tputs(packagename);\n\tprintf(\"  Lowlevel:%s\\n\", BFG_LOWLLIST);\n\tprintf(\"  Drivers:%s\\n\", BFG_DRIVERLIST);\n\tprintf(\"  Algorithms:%s\\n\", BFG_ALGOLIST);\n\tprintf(\"  Options:%s\\n\", BFG_OPTLIST);\n}\n\nstatic char *opt_verusage_and_exit(const char *extra)\n{\n\tbfg_versioninfo();\n\tprintf(\"%s\", opt_usage(opt_argv0, extra));\n\tfflush(stdout);\n\texit(0);\n}\n\nstatic\nconst char *my_opt_version_and_exit(void)\n{\n\tbfg_versioninfo();\n\tfflush(stdout);\n\texit(0);\n}\n\n/* These options are parsed before anything else */\nstatic struct opt_table opt_early_table[] = {\n\t// Default config is loaded in command line order, like a regular config\n\tOPT_EARLY_WITH_ARG(\"--config|-c|--default-config\",\n\t                   set_bool_ignore_arg, NULL, &config_loaded,\n\t                   opt_hidden),\n\tOPT_EARLY_WITHOUT_ARG(\"--no-config|--no-default-config\",\n\t                opt_set_bool, &config_loaded,\n\t                \"Inhibit loading default config file\"),\n\tOPT_ENDTABLE\n};\n\n/* These options are available from commandline only */\nstatic struct opt_table opt_cmdline_table[] = {\n\tOPT_WITH_ARG(\"--config|-c\",\n\t\t     load_config, NULL, NULL,\n\t\t     \"Load a JSON-format configuration file\\n\"\n\t\t     \"See example.conf for an example configuration.\"),\n\tOPT_EARLY_WITHOUT_ARG(\"--no-config\",\n\t                opt_set_bool, &config_loaded,\n\t                opt_hidden),\n\tOPT_EARLY_WITHOUT_ARG(\"--no-default-config\",\n\t                opt_set_bool, &config_loaded,\n\t                \"Inhibit loading default config file\"),\n\tOPT_WITHOUT_ARG(\"--default-config\",\n\t                load_default_config, NULL,\n\t                \"Always load the default config file\"),\n\tOPT_WITHOUT_ARG(\"--help|-h\",\n\t\t\topt_verusage_and_exit, NULL,\n\t\t\t\"Print this message\"),\n#ifdef USE_OPENCL\n\tOPT_WITHOUT_ARG(\"--ndevs|-n\",\n\t\t\tprint_ndevs_and_exit, &nDevs,\n\t\t\topt_hidden),\n#endif\n\tOPT_WITHOUT_ARG(\"--version|-V\",\n\t\t\tmy_opt_version_and_exit, NULL,\n\t\t\t\"Display version and exit\"),\n\tOPT_ENDTABLE\n};\n\nstatic bool jobj_binary(const json_t *obj, const char *key,\n\t\t\tvoid *buf, size_t buflen, bool required)\n{\n\tconst char *hexstr;\n\tjson_t *tmp;\n\n\ttmp = json_object_get(obj, key);\n\tif (unlikely(!tmp)) {\n\t\tif (unlikely(required))\n\t\t\tapplog(LOG_ERR, \"JSON key '%s' not found\", key);\n\t\treturn false;\n\t}\n\thexstr = json_string_value(tmp);\n\tif (unlikely(!hexstr)) {\n\t\tapplog(LOG_ERR, \"JSON key '%s' is not a string\", key);\n\t\treturn false;\n\t}\n\tif (!hex2bin(buf, hexstr, buflen))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void calc_midstate(struct work *work)\n{\n\tunion {\n\t\tunsigned char c[64];\n\t\tuint32_t i[16];\n\t} data;\n\n\tswap32yes(&data.i[0], work->data, 16);\n\tsha256_ctx ctx;\n\tsha256_init(&ctx);\n\tsha256_update(&ctx, data.c, 64);\n\tmemcpy(work->midstate, ctx.h, sizeof(work->midstate));\n\tswap32tole(work->midstate, work->midstate, 8);\n}\n\nstatic\nstruct bfg_tmpl_ref *tmpl_makeref(blktemplate_t * const tmpl)\n{\n\tstruct bfg_tmpl_ref * const tr = malloc(sizeof(*tr));\n\t*tr = (struct bfg_tmpl_ref){\n\t\t.tmpl = tmpl,\n\t\t.refcount = 1,\n\t};\n\tmutex_init(&tr->mutex);\n\treturn tr;\n}\n\nstatic\nvoid tmpl_incref(struct bfg_tmpl_ref * const tr)\n{\n\tmutex_lock(&tr->mutex);\n\t++tr->refcount;\n\tmutex_unlock(&tr->mutex);\n}\n\nvoid tmpl_decref(struct bfg_tmpl_ref * const tr)\n{\n\tmutex_lock(&tr->mutex);\n\tbool free_tmpl = !--tr->refcount;\n\tmutex_unlock(&tr->mutex);\n\tif (free_tmpl)\n\t{\n\t\tblktmpl_free(tr->tmpl);\n\t\tmutex_destroy(&tr->mutex);\n\t\tfree(tr);\n\t}\n}\n\nstatic struct work *make_work(void)\n{\n\tstruct work *work = calloc(1, sizeof(struct work));\n\n\tif (unlikely(!work))\n\t\tquit(1, \"Failed to calloc work in make_work\");\n\n\tcg_wlock(&control_lock);\n\twork->id = total_work++;\n\tcg_wunlock(&control_lock);\n\n\treturn work;\n}\n\n/* This is the central place all work that is about to be retired should be\n * cleaned to remove any dynamically allocated arrays within the struct */\nvoid clean_work(struct work *work)\n{\n\tfree(work->job_id);\n\tbytes_free(&work->nonce2);\n\tfree(work->nonce1);\n\tif (work->device_data_free_func)\n\t\twork->device_data_free_func(work);\n\n\tif (work->tr)\n\t\ttmpl_decref(work->tr);\n\n\tmemset(work, 0, sizeof(struct work));\n}\n\n/* All dynamically allocated work structs should be freed here to not leak any\n * ram from arrays allocated within the work struct */\nvoid free_work(struct work *work)\n{\n\tclean_work(work);\n\tfree(work);\n}\n\nconst char *bfg_workpadding_bin = \"\\0\\0\\0\\x80\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x80\\x02\\0\\0\";\n#define workpadding_bin  bfg_workpadding_bin\n\nstatic const size_t block_info_str_sz = 3 /* ... */ + 16 /* block hash segment */ + 1;\n\nstatic\nvoid block_info_str(char * const out, const struct block_info * const blkinfo)\n{\n\tunsigned char hash_swap[32];\n\tswap256(hash_swap, blkinfo->prevblkhash);\n\tswap32tole(hash_swap, hash_swap, 32 / 4);\n\t\n\tmemset(out, '.', 3);\n\t// FIXME: The block number will overflow this sometime around AD 2025-2027\n\tif (blkinfo->height > 0 && blkinfo->height < 1000000)\n\t{\n\t\tbin2hex(&out[3], &hash_swap[0x1c], 4);\n\t\tsnprintf(&out[11], block_info_str_sz-11, \" #%6u\", blkinfo->height);\n\t}\n\telse\n\t\tbin2hex(&out[3], &hash_swap[0x18], 8);\n}\n\n#ifdef HAVE_CURSES\nstatic void update_block_display(bool);\n#endif\n\n// Must only be called with ch_lock held!\nstatic\nvoid __update_block_title(struct mining_goal_info * const goal)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\t\n\tif (!goal->current_goal_detail)\n\t\tgoal->current_goal_detail = malloc(block_info_str_sz);\n\tblock_info_str(goal->current_goal_detail, blkchain->currentblk);\n#ifdef HAVE_CURSES\n\tupdate_block_display(false);\n#endif\n}\n\nstatic struct block_info *block_exists(const struct blockchain_info *, const void *);\n\nstatic\nvoid have_block_height(struct mining_goal_info * const goal, const void * const prevblkhash, uint32_t blkheight)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\tstruct block_info * const blkinfo = block_exists(blkchain, prevblkhash);\n\tif ((!blkinfo) || blkinfo->height)\n\t\treturn;\n\t\n\tuint32_t block_id = ((uint32_t*)prevblkhash)[0];\n\tapplog(LOG_DEBUG, \"Learned that block id %08\" PRIx32 \" is height %\" PRIu32, (uint32_t)be32toh(block_id), blkheight);\n\tcg_wlock(&ch_lock);\n\tblkinfo->height = blkheight;\n\tif (blkinfo == blkchain->currentblk)\n\t{\n\t\tblkchain->currentblk_subsidy = 5000000000LL >> (blkheight / 210000);\n\t\t__update_block_title(goal);\n\t}\n\tcg_wunlock(&ch_lock);\n}\n\nstatic\nvoid pool_set_opaque(struct pool *pool, bool opaque)\n{\n\tif (pool->swork.opaque == opaque)\n\t\treturn;\n\t\n\tpool->swork.opaque = opaque;\n\tif (opaque)\n\t\tapplog(LOG_WARNING, \"Pool %u is hiding block contents from us\",\n\t\t       pool->pool_no);\n\telse\n\t\tapplog(LOG_NOTICE, \"Pool %u now providing block contents to us\",\n\t\t       pool->pool_no);\n}\n\nbool pool_may_redirect_to(struct pool * const pool, const char * const uri)\n{\n\tif (uri_get_param_bool(pool->rpc_url, \"redirect\", false))\n\t\treturn true;\n\treturn match_domains(pool->rpc_url, strlen(pool->rpc_url), uri, strlen(uri));\n}\n\nvoid pool_check_coinbase(struct pool * const pool, const uint8_t * const cbtxn, const size_t cbtxnsz)\n{\n\tif (uri_get_param_bool(pool->rpc_url, \"skipcbcheck\", false))\n\t{}\n\telse\n\tif (!check_coinbase(cbtxn, cbtxnsz, &pool->cb_param))\n\t{\n\t\tif (pool->enabled == POOL_ENABLED)\n\t\t{\n\t\t\tapplog(LOG_ERR, \"Pool %d misbehaving (%s), disabling!\", pool->pool_no, \"coinbase check\");\n\t\t\tdisable_pool(pool, POOL_MISBEHAVING);\n\t\t}\n\t}\n\telse\n\tif (pool->enabled == POOL_MISBEHAVING)\n\t{\n\t\tapplog(LOG_NOTICE, \"Pool %d no longer misbehaving, re-enabling!\", pool->pool_no);\n\t\tenable_pool(pool);\n\t}\n}\n\nvoid set_simple_ntime_roll_limit(struct ntime_roll_limits * const nrl, const uint32_t ntime_base, const int ntime_roll, const struct timeval * const tvp_ref)\n{\n\tconst int offsets = max(ntime_roll, 60);\n\t*nrl = (struct ntime_roll_limits){\n\t\t.min = ntime_base,\n\t\t.max = ntime_base + ntime_roll,\n\t\t.tv_ref = *tvp_ref,\n\t\t.minoff = -offsets,\n\t\t.maxoff = offsets,\n\t};\n}\n\nvoid work_set_simple_ntime_roll_limit(struct work * const work, const int ntime_roll, const struct timeval * const tvp_ref)\n{\n\tset_simple_ntime_roll_limit(&work->ntime_roll_limits, upk_u32be(work->data, 0x44), ntime_roll, tvp_ref);\n}\n\nint work_ntime_range(struct work * const work, const struct timeval * const tvp_earliest, const struct timeval * const tvp_latest, const int desired_roll)\n{\n\tconst struct ntime_roll_limits * const nrl = &work->ntime_roll_limits;\n\tconst uint32_t ref_ntime = work_get_ntime(work);\n\tconst int earliest_elapsed = timer_elapsed(&nrl->tv_ref, tvp_earliest);\n\tconst int   latest_elapsed = timer_elapsed(&nrl->tv_ref, tvp_latest);\n\t// minimum ntime is the latest possible result (add a second to spare) adjusted for minimum offset (or fixed minimum ntime)\n\tuint32_t min_ntime = max(nrl->min, ref_ntime + latest_elapsed+1 + nrl->minoff);\n\t// maximum ntime is the earliest possible result adjusted for maximum offset (or fixed maximum ntime)\n\tuint32_t max_ntime = min(nrl->max, ref_ntime + earliest_elapsed + nrl->maxoff);\n\tif (max_ntime < min_ntime)\n\t\treturn -1;\n\t\n\tif (max_ntime - min_ntime > desired_roll)\n\t{\n\t\t// Adjust min_ntime upward for accuracy, when possible\n\t\tconst int mid_elapsed = ((latest_elapsed - earliest_elapsed) / 2) + earliest_elapsed;\n\t\tuint32_t ideal_ntime = ref_ntime + mid_elapsed;\n\t\tif (ideal_ntime > min_ntime)\n\t\t\tmin_ntime = min(ideal_ntime, max_ntime - desired_roll);\n\t}\n\t\n\twork_set_ntime(work, min_ntime);\n\treturn max_ntime - min_ntime;\n}\n\n#if BLKMAKER_VERSION > 1\nstatic\nbool goal_has_at_least_one_getcbaddr(const struct mining_goal_info * const goal)\n{\n\tfor (int i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool * const pool = pools[i];\n\t\tif (uri_get_param_bool(pool->rpc_url, \"getcbaddr\", false))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic\nvoid refresh_bitcoind_address(struct mining_goal_info * const goal, const bool fresh)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\t\n\tif (!goal_has_at_least_one_getcbaddr(goal))\n\t\treturn;\n\t\n\tchar getcbaddr_req[60];\n\tCURL *curl = NULL;\n\tjson_t *json, *j2;\n\tconst char *s, *s2;\n\tbytes_t newscript = BYTES_INIT;\n\t\n\tsnprintf(getcbaddr_req, sizeof(getcbaddr_req), \"{\\\"method\\\":\\\"get%saddress\\\",\\\"id\\\":0,\\\"params\\\":[\\\"BFGMiner\\\"]}\", fresh ? \"new\" : \"account\");\n\t\n\tfor (int i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool * const pool = pools[i];\n\t\tif (!uri_get_param_bool(pool->rpc_url, \"getcbaddr\", false))\n\t\t\tcontinue;\n\t\tif (pool->goal != goal)\n\t\t\tcontinue;\n\t\t\n\t\tapplog(LOG_DEBUG, \"Refreshing coinbase address from pool %d\", pool->pool_no);\n\t\tif (!curl)\n\t\t{\n\t\t\tcurl = curl_easy_init();\n\t\t\tif (unlikely(!curl))\n\t\t\t{\n\t\t\t\tapplogfail(LOG_ERR, \"curl_easy_init\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjson = json_rpc_call(curl, pool->rpc_url, pool->rpc_userpass, getcbaddr_req, false, false, NULL, pool, true);\n\t\tif (unlikely((!json) || !json_is_null( (j2 = json_object_get(json, \"error\")) )))\n\t\t{\n\t\t\tconst char *estrc;\n\t\t\tchar *estr = NULL;\n\t\t\tif (!(json && j2))\n\t\t\t\testrc = NULL;\n\t\t\telse\n\t\t\t{\n\t\t\t\testrc = json_string_value(j2);\n\t\t\t\tif (!estrc)\n\t\t\t\t\testrc = estr = json_dumps_ANY(j2, JSON_ENSURE_ASCII | JSON_SORT_KEYS);\n\t\t\t}\n\t\t\tapplog(LOG_WARNING, \"Error %cetting coinbase address from pool %d: %s\", 'g', pool->pool_no, estrc);\n\t\t\tfree(estr);\n\t\t\tjson_decref(json);\n\t\t\tcontinue;\n\t\t}\n\t\ts = bfg_json_obj_string(json, \"result\", NULL);\n\t\tif (unlikely(!s))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"Error %cetting coinbase address from pool %d: %s\", 'g', pool->pool_no, \"(return value was not a String)\");\n\t\t\tjson_decref(json);\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = set_b58addr(s, &newscript);\n\t\tif (unlikely(s2))\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"Error %cetting coinbase address from pool %d: %s\", 's', pool->pool_no, s2);\n\t\t\tjson_decref(json);\n\t\t\tcontinue;\n\t\t}\n\t\tcg_ilock(&control_lock);\n\t\tif (goal->generation_script)\n\t\t{\n\t\t\tif (bytes_eq(&newscript, goal->generation_script))\n\t\t\t{\n\t\t\t\tcg_iunlock(&control_lock);\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %d returned coinbase address already in use (%s)\", pool->pool_no, s);\n\t\t\t\tjson_decref(json);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcg_ulock(&control_lock);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcg_ulock(&control_lock);\n\t\t\tgoal->generation_script = malloc(sizeof(*goal->generation_script));\n\t\t\tbytes_init(goal->generation_script);\n\t\t}\n\t\tbytes_assimilate(goal->generation_script, &newscript);\n\t\tcoinbase_script_block_id = blkchain->currentblk->block_id;\n\t\tcg_wunlock(&control_lock);\n\t\tapplog(LOG_NOTICE, \"Now using coinbase address %s, provided by pool %d\", s, pool->pool_no);\n\t\tjson_decref(json);\n\t\tbreak;\n\t}\n\t\n\tbytes_free(&newscript);\n\tif (curl)\n\t\tcurl_easy_cleanup(curl);\n}\n#endif\n\n#define GBT_XNONCESZ (sizeof(uint32_t))\n\n#if BLKMAKER_VERSION > 6\n#define blkmk_append_coinbase_safe(tmpl, append, appendsz)  \\\n       blkmk_append_coinbase_safe2(tmpl, append, appendsz, GBT_XNONCESZ, false)\n#endif\n\nstatic bool work_decode(struct pool *pool, struct work *work, json_t *val)\n{\n\tjson_t *res_val = json_object_get(val, \"result\");\n\tjson_t *tmp_val;\n\tbool ret = false;\n\tstruct timeval tv_now;\n\n\tif (unlikely(detect_algo == 1)) {\n\t\tjson_t *tmp = json_object_get(res_val, \"algorithm\");\n\t\tconst char *v = tmp ? json_string_value(tmp) : \"\";\n\t\tif (strncasecmp(v, \"scrypt\", 6))\n\t\t\tdetect_algo = 2;\n\t}\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tif (work->tr)\n\t{\n\t\tblktemplate_t * const tmpl = work->tr->tmpl;\n\t\tconst char *err = blktmpl_add_jansson(tmpl, res_val, tv_now.tv_sec);\n\t\tif (err) {\n\t\t\tapplog(LOG_ERR, \"blktmpl error: %s\", err);\n\t\t\treturn false;\n\t\t}\n\t\twork->rolltime = blkmk_time_left(tmpl, tv_now.tv_sec);\n#if BLKMAKER_VERSION > 1\n\t\tstruct mining_goal_info * const goal = pool->goal;\n\t\tconst uint32_t tmpl_block_id = ((uint32_t*)tmpl->prevblk)[0];\n\t\tif ((!tmpl->cbtxn) && coinbase_script_block_id != tmpl_block_id)\n\t\t\trefresh_bitcoind_address(goal, false);\n\t\tif (goal->generation_script)\n\t\t{\n\t\t\tbool newcb;\n#if BLKMAKER_VERSION > 2\n\t\t\tblkmk_init_generation2(tmpl, bytes_buf(goal->generation_script), bytes_len(goal->generation_script), &newcb);\n#else\n\t\t\tnewcb = !tmpl->cbtxn;\n\t\t\tblkmk_init_generation(tmpl, bytes_buf(goal->generation_script), bytes_len(goal->generation_script));\n#endif\n\t\t\tif (newcb)\n\t\t\t{\n\t\t\t\tssize_t ae = blkmk_append_coinbase_safe(tmpl, &template_nonce, sizeof(template_nonce));\n\t\t\t\tif (ae < (ssize_t)sizeof(template_nonce))\n\t\t\t\t\tapplog(LOG_WARNING, \"Cannot append template-nonce to coinbase on pool %u (%\"PRId64\") - you might be wasting hashing!\", work->pool->pool_no, (int64_t)ae);\n\t\t\t\t++template_nonce;\n\t\t\t}\n\t\t}\n#endif\n#if BLKMAKER_VERSION > 0\n\t\t{\n\t\t\tssize_t ae = blkmk_append_coinbase_safe(tmpl, opt_coinbase_sig, 101);\n\t\t\tstatic bool appenderr = false;\n\t\t\tif (ae <= 0) {\n\t\t\t\tif (opt_coinbase_sig) {\n\t\t\t\t\tapplog((appenderr ? LOG_DEBUG : LOG_WARNING), \"Cannot append coinbase signature at all on pool %u (%\"PRId64\")\", pool->pool_no, (int64_t)ae);\n\t\t\t\t\tappenderr = true;\n\t\t\t\t}\n\t\t\t} else if (ae >= 3 || opt_coinbase_sig) {\n\t\t\t\tconst char *cbappend = opt_coinbase_sig;\n\t\t\t\tconst char * const full = bfgminer_name_space_ver;\n\t\t\t\tchar *need_free = NULL;\n\t\t\t\tif (!cbappend) {\n\t\t\t\t\tif ((size_t)ae >= sizeof(full) - 1)\n\t\t\t\t\t\tcbappend = full;\n\t\t\t\t\telse if ((size_t)ae >= sizeof(PACKAGE) - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst char *pos = strchr(full, '-');\n\t\t\t\t\t\tsize_t sz = (pos - full);\n\t\t\t\t\t\tif (pos && ae > sz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcbappend = need_free = malloc(sz + 1);\n\t\t\t\t\t\t\tmemcpy(need_free, full, sz);\n\t\t\t\t\t\t\tneed_free[sz] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcbappend = PACKAGE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcbappend = \"BFG\";\n\t\t\t\t}\n\t\t\t\tsize_t cbappendsz = strlen(cbappend);\n\t\t\t\tstatic bool truncatewarning = false;\n\t\t\t\tif (cbappendsz <= (size_t)ae) {\n\t\t\t\t\tif (cbappendsz < (size_t)ae)\n\t\t\t\t\t\t// If we have space, include the trailing \\0\n\t\t\t\t\t\t++cbappendsz;\n\t\t\t\t\tae = cbappendsz;\n\t\t\t\t\ttruncatewarning = false;\n\t\t\t\t} else {\n\t\t\t\t\tchar *tmp = malloc(ae + 1);\n\t\t\t\t\tmemcpy(tmp, opt_coinbase_sig, ae);\n\t\t\t\t\ttmp[ae] = '\\0';\n\t\t\t\t\tapplog((truncatewarning ? LOG_DEBUG : LOG_WARNING),\n\t\t\t\t\t       \"Pool %u truncating appended coinbase signature at %\"PRId64\" bytes: %s(%s)\",\n\t\t\t\t\t       pool->pool_no, (int64_t)ae, tmp, &opt_coinbase_sig[ae]);\n\t\t\t\t\tfree(tmp);\n\t\t\t\t\ttruncatewarning = true;\n\t\t\t\t}\n\t\t\t\tae = blkmk_append_coinbase_safe(tmpl, cbappend, ae);\n\t\t\t\tfree(need_free);\n\t\t\t\tif (ae <= 0) {\n\t\t\t\t\tapplog((appenderr ? LOG_DEBUG : LOG_WARNING), \"Error appending coinbase signature (%\"PRId64\")\", (int64_t)ae);\n\t\t\t\t\tappenderr = true;\n\t\t\t\t} else\n\t\t\t\t\tappenderr = false;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (blkmk_get_data(tmpl, work->data, 80, tv_now.tv_sec, NULL, &work->dataid) < 76)\n\t\t\treturn false;\n\t\tswap32yes(work->data, work->data, 80 / 4);\n\t\tmemcpy(&work->data[80], workpadding_bin, 48);\n\t\t\n\t\twork->ntime_roll_limits = (struct ntime_roll_limits){\n\t\t\t.min = tmpl->mintime,\n\t\t\t.max = tmpl->maxtime,\n\t\t\t.tv_ref = tv_now,\n\t\t\t.minoff = tmpl->mintimeoff,\n\t\t\t.maxoff = tmpl->maxtimeoff,\n\t\t};\n\n\t\tconst struct blktmpl_longpoll_req *lp;\n\t\tmutex_lock(&pool->pool_lock);\n\t\tif ((lp = blktmpl_get_longpoll(tmpl)) && ((!pool->lp_id) || strcmp(lp->id, pool->lp_id))) {\n\t\t\tfree(pool->lp_id);\n\t\t\tpool->lp_id = strdup(lp->id);\n\n#if 0  /* This just doesn't work :( */\n\t\t\tcurl_socket_t sock = pool->lp_socket;\n\t\t\tif (sock != CURL_SOCKET_BAD) {\n\t\t\t\tpool->lp_socket = CURL_SOCKET_BAD;\n\t\t\t\tapplog(LOG_WARNING, \"Pool %u long poll request hanging, reconnecting\", pool->pool_no);\n\t\t\t\tshutdown(sock, SHUT_RDWR);\n\t\t\t}\n#endif\n\t\t}\n\t\tmutex_unlock(&pool->pool_lock);\n\t}\n\telse\n\tif (unlikely(!jobj_binary(res_val, \"data\", work->data, sizeof(work->data), true))) {\n\t\tapplog(LOG_ERR, \"JSON inval data\");\n\t\treturn false;\n\t}\n\telse\n\t\twork_set_simple_ntime_roll_limit(work, 0, &tv_now);\n\n\tif (!jobj_binary(res_val, \"midstate\", work->midstate, sizeof(work->midstate), false)) {\n\t\t// Calculate it ourselves\n\t\tapplog(LOG_DEBUG, \"Calculating midstate locally\");\n\t\tcalc_midstate(work);\n\t}\n\n\tif (unlikely(!jobj_binary(res_val, \"target\", work->target, sizeof(work->target), true))) {\n\t\tapplog(LOG_ERR, \"JSON inval target\");\n\t\treturn false;\n\t}\n\tif (work->tr)\n\t{\n\t\tfor (size_t i = 0; i < sizeof(work->target) / 2; ++i)\n\t\t{\n\t\t\tint p = (sizeof(work->target) - 1) - i;\n\t\t\tunsigned char c = work->target[i];\n\t\t\twork->target[i] = work->target[p];\n\t\t\twork->target[p] = c;\n\t\t}\n\t}\n\n\tif ( (tmp_val = json_object_get(res_val, \"height\")) ) {\n\t\tstruct mining_goal_info * const goal = pool->goal;\n\t\tuint32_t blkheight = json_number_value(tmp_val);\n\t\tconst void * const prevblkhash = &work->data[4];\n\t\thave_block_height(goal, prevblkhash, blkheight);\n\t}\n\n\tmemset(work->hash, 0, sizeof(work->hash));\n\n\twork->tv_staged = tv_now;\n\t\n#if BLKMAKER_VERSION > 6\n\tif (work->tr)\n\t{\n\t\tblktemplate_t * const tmpl = work->tr->tmpl;\n\t\tuint8_t buf[80];\n\t\tint16_t expire;\n\t\tuint8_t *cbtxn;\n\t\tsize_t cbtxnsz;\n\t\tsize_t cbextranonceoffset;\n\t\tint branchcount;\n\t\tlibblkmaker_hash_t *branches;\n\t\t\n\t\tif (blkmk_get_mdata(tmpl, buf, sizeof(buf), tv_now.tv_sec, &expire, &cbtxn, &cbtxnsz, &cbextranonceoffset, &branchcount, &branches, GBT_XNONCESZ, false))\n\t\t{\n\t\t\tstruct stratum_work * const swork = &pool->swork;\n\t\t\tconst size_t branchdatasz = branchcount * 0x20;\n\t\t\t\n\t\t\tpool_check_coinbase(pool, cbtxn, cbtxnsz);\n\t\t\t\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tif (swork->tr)\n\t\t\t\ttmpl_decref(swork->tr);\n\t\t\tswork->tr = work->tr;\n\t\t\ttmpl_incref(swork->tr);\n\t\t\tbytes_assimilate_raw(&swork->coinbase, cbtxn, cbtxnsz, cbtxnsz);\n\t\t\tswork->nonce2_offset = cbextranonceoffset;\n\t\t\tbytes_assimilate_raw(&swork->merkle_bin, branches, branchdatasz, branchdatasz);\n\t\t\tswork->merkles = branchcount;\n\t\t\tswap32yes(swork->header1, &buf[0], 36 / 4);\n\t\t\tswork->ntime = le32toh(*(uint32_t *)(&buf[68]));\n\t\t\tswork->tv_received = tv_now;\n\t\t\tswap32yes(swork->diffbits, &buf[72], 4 / 4);\n\t\t\tmemcpy(swork->target, work->target, sizeof(swork->target));\n\t\t\tfree(swork->job_id);\n\t\t\tswork->job_id = NULL;\n\t\t\tswork->clean = true;\n\t\t\tswork->work_restart_id = pool->work_restart_id;\n\t\t\t// FIXME: Do something with expire\n\t\t\tpool->nonce2sz = swork->n2size = GBT_XNONCESZ;\n\t\t\tpool->nonce2 = 0;\n\t\t\tcg_wunlock(&pool->data_lock);\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"blkmk_get_mdata failed for pool %u\", pool->pool_no);\n\t}\n#endif  // BLKMAKER_VERSION > 6\n\tpool_set_opaque(pool, !work->tr);\n\n\tret = true;\n\n\treturn ret;\n}\n\n/* Returns whether the pool supports local work generation or not. */\nstatic bool pool_localgen(struct pool *pool)\n{\n\treturn (pool->last_work_copy || pool->has_stratum);\n}\n\nint dev_from_id(int thr_id)\n{\n\tstruct cgpu_info *cgpu = get_thr_cgpu(thr_id);\n\n\treturn cgpu->device_id;\n}\n\n/* Create an exponentially decaying average over the opt_log_interval */\nvoid decay_time(double *f, double fadd, double fsecs)\n{\n\tdouble ftotal, fprop;\n\n\tfprop = 1.0 - 1 / (exp(fsecs / (double)opt_log_interval));\n\tftotal = 1.0 + fprop;\n\t*f += (fadd * fprop);\n\t*f /= ftotal;\n}\n\nstatic\nint __total_staged(const bool include_spares)\n{\n\tint tot = HASH_COUNT(staged_work);\n\tif (!include_spares)\n\t\ttot -= staged_spare;\n\treturn tot;\n}\n\nstatic int total_staged(const bool include_spares)\n{\n\tint ret;\n\n\tmutex_lock(stgd_lock);\n\tret = __total_staged(include_spares);\n\tmutex_unlock(stgd_lock);\n\n\treturn ret;\n}\n\n#ifdef HAVE_CURSES\nWINDOW *mainwin, *statuswin, *logwin;\n#endif\ndouble total_secs = 1.0;\n#ifdef HAVE_CURSES\nstatic char statusline[256];\n/* statusy is where the status window goes up to in cases where it won't fit at startup */\nstatic int statusy;\nstatic int devsummaryYOffset;\nstatic int total_lines;\n#endif\n\nbool _bfg_console_cancel_disabled;\nint _bfg_console_prev_cancelstate;\n\n#ifdef HAVE_CURSES\n#define   lock_curses()  bfg_console_lock()\n#define unlock_curses()  bfg_console_unlock()\n\nstatic bool curses_active_locked(void)\n{\n\tbool ret;\n\n\tlock_curses();\n\tret = curses_active;\n\tif (!ret)\n\t\tunlock_curses();\n\treturn ret;\n}\n\n// Cancellable getch\nint my_cancellable_getch(void)\n{\n\t// This only works because the macro only hits direct getch() calls\n\ttypedef int (*real_getch_t)(void);\n\tconst real_getch_t real_getch = __real_getch;\n\n\tint type, rv;\n\tbool sct;\n\n\tsct = !pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &type);\n\trv = real_getch();\n\tif (sct)\n\t\tpthread_setcanceltype(type, &type);\n\n\treturn rv;\n}\n\n#ifdef PDCURSES\nstatic\nint bfg_wresize(WINDOW *win, int lines, int columns)\n{\n\tint rv = wresize(win, lines, columns);\n\tint x, y;\n\tgetyx(win, y, x);\n\tif (unlikely(y >= lines || x >= columns))\n\t{\n\t\tif (y >= lines)\n\t\t\ty = lines - 1;\n\t\tif (x >= columns)\n\t\t\tx = columns - 1;\n\t\twmove(win, y, x);\n\t}\n\treturn rv;\n}\n#else\n#\tdefine bfg_wresize wresize\n#endif\n\n#endif\n\nvoid tailsprintf(char *buf, size_t bufsz, const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t presz = strlen(buf);\n\t\n\tva_start(ap, fmt);\n\tvsnprintf(&buf[presz], bufsz - presz, fmt, ap);\n\tva_end(ap);\n}\n\ndouble stats_elapsed(struct cgminer_stats *stats)\n{\n\tstruct timeval now;\n\tdouble elapsed;\n\n\tif (stats->start_tv.tv_sec == 0)\n\t\telapsed = total_secs;\n\telse {\n\t\tcgtime(&now);\n\t\telapsed = tdiff(&now, &stats->start_tv);\n\t}\n\n\tif (elapsed < 1.0)\n\t\telapsed = 1.0;\n\n\treturn elapsed;\n}\n\nbool drv_ready(struct cgpu_info *cgpu)\n{\n\tswitch (cgpu->status) {\n\t\tcase LIFE_INIT:\n\t\tcase LIFE_DEAD2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n\ndouble cgpu_utility(struct cgpu_info *cgpu)\n{\n\tdouble dev_runtime = cgpu_runtime(cgpu);\n\treturn cgpu->utility = cgpu->accepted / dev_runtime * 60;\n}\n\n#define suffix_string(val, buf, bufsiz, sigdigits)  do{ \\\n\t_Static_assert(sigdigits == 0, \"suffix_string only supported with sigdigits==0\");  \\\n\tformat_unit3(buf, bufsiz, FUP_DIFF, \"\", H2B_SHORTV, val, -1);  \\\n}while(0)\n\nstatic float\nutility_to_hashrate(double utility)\n{\n\treturn utility * 0x4444444;\n}\n\nstatic const char*_unitchar = \"pn\\xb5m kMGTPEZY?\";\nstatic const int _unitbase = 4;\n\nstatic\nvoid pick_unit(float hashrate, unsigned char *unit)\n{\n\tunsigned char i;\n\t\n\tif (hashrate == 0 || !isfinite(hashrate))\n\t{\n\t\tif (*unit < _unitbase)\n\t\t\t*unit = _unitbase;\n\t\treturn;\n\t}\n\t\n\thashrate *= 1e12;\n\tfor (i = 0; i < *unit; ++i)\n\t\thashrate /= 1e3;\n\t\n\t// 1000 but with tolerance for floating-point rounding, avoid showing \"1000.0\"\n\twhile (hashrate >= 999.95)\n\t{\n\t\thashrate /= 1e3;\n\t\tif (likely(_unitchar[*unit] != '?'))\n\t\t\t++*unit;\n\t}\n}\n#define hashrate_pick_unit(hashrate, unit)  pick_unit(hashrate, unit)\n\nenum h2bs_fmt {\n\tH2B_NOUNIT,  // \"xxx.x\"\n\tH2B_SHORT,   // \"xxx.xMH/s\"\n\tH2B_SPACED,  // \"xxx.x MH/s\"\n\tH2B_SHORTV,  // Like H2B_SHORT, but omit space for base unit\n};\n\nenum bfu_floatprec {\n\tFUP_INTEGER,\n\tFUP_HASHES,\n\tFUP_BTC,\n\tFUP_DIFF,\n};\n\nstatic\nint format_unit3(char *buf, size_t sz, enum bfu_floatprec fprec, const char *measurement, enum h2bs_fmt fmt, float hashrate, signed char unitin)\n{\n\tchar *s = buf;\n\tunsigned char prec, i, unit;\n\tint rv = 0;\n\t\n\tif (unitin == -1)\n\t{\n\t\tunit = 0;\n\t\thashrate_pick_unit(hashrate, &unit);\n\t}\n\telse\n\t\tunit = unitin;\n\t\n\thashrate *= 1e12;\n\t\n\tfor (i = 0; i < unit; ++i)\n\t\thashrate /= 1000;\n\t\n\tswitch (fprec)\n\t{\n\tcase FUP_HASHES:\n\t\t// 100 but with tolerance for floating-point rounding, max \"99.99\" then \"100.0\"\n\t\tif (hashrate >= 99.995 || unit < 6)\n\t\t\tprec = 1;\n\t\telse\n\t\t\tprec = 2;\n\t\t_SNP(\"%5.*f\", prec, hashrate);\n\t\tbreak;\n\tcase FUP_INTEGER:\n\t\t_SNP(\"%3d\", (int)hashrate);\n\t\tbreak;\n\tcase FUP_BTC:\n\t\tif (hashrate >= 99.995)\n\t\t\tprec = 0;\n\t\telse\n\t\t\tprec = 2;\n\t\t_SNP(\"%5.*f\", prec, hashrate);\n\t\tbreak;\n\tcase FUP_DIFF:\n\t\tif (unit > _unitbase)\n\t\t\t_SNP(\"%.3g\", hashrate);\n\t\telse\n\t\t\t_SNP(\"%u\", (unsigned int)hashrate);\n\t}\n\t\n\tif (fmt != H2B_NOUNIT)\n\t{\n\t\tchar uc[3] = {_unitchar[unit], '\\0'};\n\t\tswitch (fmt) {\n\t\t\tcase H2B_SPACED:\n\t\t\t\t_SNP(\" \");\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase H2B_SHORTV:\n\t\t\t\tif (isspace(uc[0]))\n\t\t\t\t\tuc[0] = '\\0';\n\t\t}\n\t\t\n\t\tif (uc[0] == '\\xb5')\n\t\t\t// Convert to UTF-8\n\t\t\tsnprintf(uc, sizeof(uc), \"%s\", U8_MICRO);\n\t\t\n\t\t_SNP(\"%s%s\", uc, measurement);\n\t}\n\t\n\treturn rv;\n}\n#define format_unit2(buf, sz, floatprec, measurement, fmt, n, unit)  \\\n\tformat_unit3(buf, sz, floatprec ? FUP_HASHES : FUP_INTEGER, measurement, fmt, n, unit)\n\nstatic\nchar *_multi_format_unit(char **buflist, size_t *bufszlist, bool floatprec, const char *measurement, enum h2bs_fmt fmt, const char *delim, int count, const float *numbers, bool isarray)\n{\n\tunsigned char unit = 0;\n\tbool allzero = true;\n\tint i;\n\tsize_t delimsz = 0;\n\tchar *buf = buflist[0];\n\tsize_t bufsz = bufszlist[0];\n\tsize_t itemwidth = (floatprec ? 5 : 3);\n\t\n\tif (!isarray)\n\t\tdelimsz = strlen(delim);\n\t\n\tfor (i = 0; i < count; ++i)\n\t\tif (numbers[i] != 0)\n\t\t{\n\t\t\tpick_unit(numbers[i], &unit);\n\t\t\tallzero = false;\n\t\t}\n\t\n\tif (allzero)\n\t\tunit = _unitbase;\n\t\n\t--count;\n\tfor (i = 0; i < count; ++i)\n\t{\n\t\tformat_unit2(buf, bufsz, floatprec, NULL, H2B_NOUNIT, numbers[i], unit);\n\t\tif (isarray)\n\t\t{\n\t\t\tbuf = buflist[i + 1];\n\t\t\tbufsz = bufszlist[i + 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuf += itemwidth;\n\t\t\tbufsz -= itemwidth;\n\t\t\tif (delimsz > bufsz)\n\t\t\t\tdelimsz = bufsz;\n\t\t\tmemcpy(buf, delim, delimsz);\n\t\t\tbuf += delimsz;\n\t\t\tbufsz -= delimsz;\n\t\t}\n\t}\n\t\n\t// Last entry has the unit\n\tformat_unit2(buf, bufsz, floatprec, measurement, fmt, numbers[count], unit);\n\t\n\treturn buflist[0];\n}\n#define multi_format_unit2(buf, bufsz, floatprec, measurement, fmt, delim, count, ...)  _multi_format_unit((char *[]){buf}, (size_t[]){bufsz}, floatprec, measurement, fmt, delim, count, (float[]){ __VA_ARGS__ }, false)\n#define multi_format_unit_array2(buflist, bufszlist, floatprec, measurement, fmt, count, ...)  (void)_multi_format_unit(buflist, bufszlist, floatprec, measurement, fmt, NULL, count, (float[]){ __VA_ARGS__ }, true)\n\nstatic\nint percentf3(char * const buf, size_t sz, double p, const double t)\n{\n\tchar *s = buf;\n\tint rv = 0;\n\tif (!p)\n\t\t_SNP(\"none\");\n\telse\n\tif (t <= p)\n\t\t_SNP(\"100%%\");\n\telse\n\t{\n\n\tp /= t;\n\tif (p < 0.00995)  // 0.01 but with tolerance for floating-point rounding, max \".99%\"\n\t\t_SNP(\".%02.0f%%\", p * 10000);  // \".01%\"\n\telse\n\tif (p < 0.0995)  // 0.1 but with tolerance for floating-point rounding, max \"9.9%\"\n\t\t_SNP(\"%.1f%%\", p * 100);  // \"9.1%\"\n\telse\n\t\t_SNP(\"%3.0f%%\", p * 100);  // \" 99%\"\n\n\t}\n\t\n\treturn rv;\n}\n#define percentf4(buf, bufsz, p, t)  percentf3(buf, bufsz, p, p + t)\n\nstatic\nvoid test_decimal_width()\n{\n\t// The pipe character at end of each line should perfectly line up\n\tchar printbuf[512];\n\tchar testbuf1[64];\n\tchar testbuf2[64];\n\tchar testbuf3[64];\n\tchar testbuf4[64];\n\tdouble testn;\n\tint width;\n\tint saved;\n\t\n\t// Hotspots around 0.1 and 0.01\n\tsaved = -1;\n\tfor (testn = 0.09; testn <= 0.11; testn += 0.000001) {\n\t\tpercentf3(testbuf1, sizeof(testbuf1), testn,  1.0);\n\t\tpercentf3(testbuf2, sizeof(testbuf2), testn, 10.0);\n\t\twidth = snprintf(printbuf, sizeof(printbuf), \"%10g %s %s |\", testn, testbuf1, testbuf2);\n\t\tif (unlikely((saved != -1) && (width != saved))) {\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"Test width mismatch in percentf3! %d not %d at %10g\", width, saved, testn);\n\t\t\tapplog(LOG_ERR, \"%s\", printbuf);\n\t\t}\n\t\tsaved = width;\n\t}\n\t\n\t// Hotspot around 100 (but test this in several units because format_unit2 also has unit<2 check)\n\tsaved = -1;\n\tfor (testn = 99.0; testn <= 101.0; testn += 0.0001) {\n\t\tformat_unit2(testbuf1, sizeof(testbuf1), true, \"x\", H2B_SHORT, testn      , -1);\n\t\tformat_unit2(testbuf2, sizeof(testbuf2), true, \"x\", H2B_SHORT, testn * 1e3, -1);\n\t\tformat_unit2(testbuf3, sizeof(testbuf3), true, \"x\", H2B_SHORT, testn * 1e6, -1);\n\t\tsnprintf(printbuf, sizeof(printbuf), \"%10g %s %s %s |\", testn, testbuf1, testbuf2, testbuf3);\n\t\twidth = utf8_strlen(printbuf);\n\t\tif (unlikely((saved != -1) && (width != saved))) {\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"Test width mismatch in format_unit2! %d not %d at %10g\", width, saved, testn);\n\t\t\tapplog(LOG_ERR, \"%s\", printbuf);\n\t\t}\n\t\tsaved = width;\n\t}\n\t\n\t// Hotspot around unit transition boundary in pick_unit\n\tsaved = -1;\n\tfor (testn = 999.0; testn <= 1001.0; testn += 0.0001) {\n\t\tformat_unit2(testbuf1, sizeof(testbuf1), true, \"x\", H2B_SHORT, testn      , -1);\n\t\tformat_unit2(testbuf2, sizeof(testbuf2), true, \"x\", H2B_SHORT, testn * 1e3, -1);\n\t\tformat_unit2(testbuf3, sizeof(testbuf3), true, \"x\", H2B_SHORT, testn * 1e6, -1);\n\t\tformat_unit2(testbuf4, sizeof(testbuf4), true, \"x\", H2B_SHORT, testn * 1e9, -1);\n\t\tsnprintf(printbuf, sizeof(printbuf), \"%10g %s %s %s %s |\", testn, testbuf1, testbuf2, testbuf3, testbuf4);\n\t\twidth = utf8_strlen(printbuf);\n\t\tif (unlikely((saved != -1) && (width != saved))) {\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"Test width mismatch in pick_unit! %d not %d at %10g\", width, saved, testn);\n\t\t\tapplog(LOG_ERR, \"%s\", printbuf);\n\t\t}\n\t\tsaved = width;\n\t}\n}\n\n#ifdef HAVE_CURSES\nstatic void adj_width(int var, int *length);\n#endif\n\n#ifdef HAVE_CURSES\nstatic int awidth = 1, rwidth = 1, swidth = 1, hwwidth = 1;\n\nstatic\nvoid format_statline(char *buf, size_t bufsz, const char *cHr, const char *aHr, const char *uHr, int accepted, int rejected, int stale, double wnotaccepted, double waccepted, int hwerrs, double bad_diff1, double allnonces)\n{\n\tchar rejpcbuf[6];\n\tchar bnbuf[6];\n\t\n\tadj_width(accepted, &awidth);\n\tadj_width(rejected, &rwidth);\n\tadj_width(stale, &swidth);\n\tadj_width(hwerrs, &hwwidth);\n\tpercentf4(rejpcbuf, sizeof(rejpcbuf), wnotaccepted, waccepted);\n\tpercentf3(bnbuf, sizeof(bnbuf), bad_diff1, allnonces);\n\t\n\ttailsprintf(buf, bufsz, \"%s/%s/%s | A:%*d R:%*d+%*d(%s) HW:%*d/%s\",\n\t            cHr, aHr, uHr,\n\t            awidth, accepted,\n\t            rwidth, rejected,\n\t            swidth, stale,\n\t            rejpcbuf,\n\t            hwwidth, hwerrs,\n\t            bnbuf\n\t);\n}\n\nstatic\nconst char *pool_proto_str(const struct pool * const pool)\n{\n\tif (pool->idle)\n\t\treturn \"Dead \";\n\tif (pool->has_stratum)\n\t\treturn \"Strtm\";\n\tif (pool->lp_url && pool->proto != pool->lp_proto)\n\t\treturn \"Mixed\";\n\tswitch (pool->proto)\n\t{\n\t\tcase PLP_GETBLOCKTEMPLATE:\n\t\t\treturn \" GBT \";\n\t\tcase PLP_GETWORK:\n\t\t\treturn \"GWork\";\n\t\tdefault:\n\t\t\treturn \"Alive\";\n\t}\n}\n\n#endif\n\nstatic inline\nvoid temperature_column(char *buf, size_t bufsz, bool maybe_unicode, const float * const temp)\n{\n\tif (!(use_unicode && have_unicode_degrees))\n\t\tmaybe_unicode = false;\n\tif (temp && *temp > 0.)\n\t\tif (maybe_unicode)\n\t\t\tsnprintf(buf, bufsz, \"%4.1f\"U8_DEGREE\"C\", *temp);\n\t\telse\n\t\t\tsnprintf(buf, bufsz, \"%4.1fC\", *temp);\n\telse\n\t{\n\t\tif (temp)\n\t\t\tsnprintf(buf, bufsz, \"     \");\n\t\tif (maybe_unicode)\n\t\t\ttailsprintf(buf, bufsz, \" \");\n\t}\n\ttailsprintf(buf, bufsz, \" | \");\n}\n\nvoid get_statline3(char *buf, size_t bufsz, struct cgpu_info *cgpu, bool for_curses, bool opt_show_procs)\n{\n#ifndef HAVE_CURSES\n\tassert(for_curses == false);\n#endif\n\tstruct device_drv *drv = cgpu->drv;\n\tenum h2bs_fmt hashrate_style = for_curses ? H2B_SHORT : H2B_SPACED;\n\tchar cHr[ALLOC_H2B_NOUNIT+1], aHr[ALLOC_H2B_NOUNIT+1], uHr[max(ALLOC_H2B_SHORT, ALLOC_H2B_SPACED)+3+1];\n\tchar rejpcbuf[6];\n\tchar bnbuf[6];\n\tdouble dev_runtime;\n\t\n\tif (!opt_show_procs)\n\t\tcgpu = cgpu->device;\n\t\n\tdev_runtime = cgpu_runtime(cgpu);\n\t\n\tdouble rolling, mhashes;\n\tint accepted, rejected, stale;\n\tdouble waccepted;\n\tdouble wnotaccepted;\n\tint hwerrs;\n\tdouble bad_diff1, good_diff1;\n\t\n\trolling = mhashes = waccepted = wnotaccepted = 0;\n\taccepted = rejected = stale = hwerrs = bad_diff1 = good_diff1 = 0;\n\t\n\t{\n\t\tstruct cgpu_info *slave = cgpu;\n\t\tfor (int i = 0; i < cgpu->procs; ++i, (slave = slave->next_proc))\n\t\t{\n\t\t\tslave->utility = slave->accepted / dev_runtime * 60;\n\t\t\tslave->utility_diff1 = slave->diff_accepted / dev_runtime * 60;\n\t\t\t\n\t\t\trolling += drv->get_proc_rolling_hashrate ? drv->get_proc_rolling_hashrate(slave) : slave->rolling;\n\t\t\tmhashes += slave->total_mhashes;\n\t\t\tif (opt_weighed_stats)\n\t\t\t{\n\t\t\t\taccepted += slave->diff_accepted;\n\t\t\t\trejected += slave->diff_rejected;\n\t\t\t\tstale += slave->diff_stale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taccepted += slave->accepted;\n\t\t\t\trejected += slave->rejected;\n\t\t\t\tstale += slave->stale;\n\t\t\t}\n\t\t\twaccepted += slave->diff_accepted;\n\t\t\twnotaccepted += slave->diff_rejected + slave->diff_stale;\n\t\t\thwerrs += slave->hw_errors;\n\t\t\tbad_diff1 += slave->bad_diff1;\n\t\t\tgood_diff1 += slave->diff1;\n\t\t\t\n\t\t\tif (opt_show_procs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tdouble wtotal = (waccepted + wnotaccepted);\n\t\n\tmulti_format_unit_array2(\n\t\t((char*[]){cHr, aHr, uHr}),\n\t\t((size_t[]){sizeof(cHr), sizeof(aHr), sizeof(uHr)}),\n\t\ttrue, \"h/s\", hashrate_style,\n\t\t3,\n\t\t1e6*rolling,\n\t\t1e6*mhashes / dev_runtime,\n\t\tutility_to_hashrate(good_diff1 * (wtotal ? (waccepted / wtotal) : 1) * 60 / dev_runtime));\n\n\t// Processor representation\n#ifdef HAVE_CURSES\n\tif (for_curses)\n\t{\n\t\tif (opt_show_procs)\n\t\t\tsnprintf(buf, bufsz, \" %*s: \", -(5 + max_lpdigits), cgpu->proc_repr);\n\t\telse\n\t\t\tsnprintf(buf, bufsz, \" %s: \", cgpu->dev_repr);\n\t}\n\telse\n#endif\n\t{\n\t\tif (opt_show_procs)\n\t\t\tsnprintf(buf, bufsz, \"%*s \", -(5 + max_lpdigits), cgpu->proc_repr_ns);\n\t\telse\n\t\t\tsnprintf(buf, bufsz, \"%-5s \", cgpu->dev_repr_ns);\n\t}\n\t\n\tif (include_serial_in_statline && cgpu->dev_serial)\n\t\ttailsprintf(buf, bufsz, \"[serial=%s] \", cgpu->dev_serial);\n\t\n\tif (unlikely(cgpu->status == LIFE_INIT))\n\t{\n\t\ttailsprintf(buf, bufsz, \"Initializing...\");\n\t\treturn;\n\t}\n\t\n\t{\n\t\tconst size_t bufln = strlen(buf);\n\t\tconst size_t abufsz = (bufln >= bufsz) ? 0 : (bufsz - bufln);\n\t\t\n\t\tif (likely(cgpu->status != LIFE_DEAD2) && drv->override_statline_temp2 && drv->override_statline_temp2(buf, bufsz, cgpu, opt_show_procs))\n\t\t\ttemperature_column(&buf[bufln], abufsz, for_curses, NULL);\n\t\telse\n\t\t{\n\t\t\tfloat temp = cgpu->temp;\n\t\t\tif (!opt_show_procs)\n\t\t\t{\n\t\t\t\t// Find the highest temperature of all processors\n\t\t\t\tstruct cgpu_info *proc = cgpu;\n\t\t\t\tfor (int i = 0; i < cgpu->procs; ++i, (proc = proc->next_proc))\n\t\t\t\t\tif (proc->temp > temp)\n\t\t\t\t\t\ttemp = proc->temp;\n\t\t\t}\n\t\t\ttemperature_column(&buf[bufln], abufsz, for_curses, &temp);\n\t\t}\n\t}\n\t\n#ifdef HAVE_CURSES\n\tif (for_curses)\n\t{\n\t\tconst char *cHrStatsOpt[] = {AS_BAD(\"DEAD \"), AS_BAD(\"SICK \"), \"OFF  \", AS_BAD(\"REST \"), AS_BAD(\" ERR \"), AS_BAD(\"WAIT \"), cHr};\n\t\tconst char *cHrStats;\n\t\tint cHrStatsI = (sizeof(cHrStatsOpt) / sizeof(*cHrStatsOpt)) - 1;\n\t\tbool all_dead = true, all_off = true, all_rdrv = true;\n\t\tstruct cgpu_info *proc = cgpu;\n\t\tfor (int i = 0; i < cgpu->procs; ++i, (proc = proc->next_proc))\n\t\t{\n\t\t\tswitch (cHrStatsI) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (proc->status == LIFE_WAIT)\n\t\t\t\t\t\tcHrStatsI = 5;\n\t\t\t\tcase 5:\n\t\t\t\t\tif (proc->deven == DEV_RECOVER_ERR)\n\t\t\t\t\t\tcHrStatsI = 4;\n\t\t\t\tcase 4:\n\t\t\t\t\tif (proc->deven == DEV_RECOVER)\n\t\t\t\t\t\tcHrStatsI = 3;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (proc->status == LIFE_SICK || proc->status == LIFE_DEAD || proc->status == LIFE_DEAD2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcHrStatsI = 1;\n\t\t\t\t\t\tall_off = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (likely(proc->deven == DEV_ENABLED))\n\t\t\t\t\t\t\tall_off = false;\n\t\t\t\t\t\tif (proc->deven != DEV_RECOVER_DRV)\n\t\t\t\t\t\t\tall_rdrv = false;\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (likely(proc->status != LIFE_DEAD && proc->status != LIFE_DEAD2))\n\t\t\t\tall_dead = false;\n\t\t\tif (opt_show_procs)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(all_dead))\n\t\t\tcHrStatsI = 0;\n\t\telse\n\t\tif (unlikely(all_off))\n\t\t\tcHrStatsI = 2;\n\t\tcHrStats = cHrStatsOpt[cHrStatsI];\n\t\tif (cHrStatsI == 2 && all_rdrv)\n\t\t\tcHrStats = \" RST \";\n\t\t\n\t\tformat_statline(buf, bufsz,\n\t\t                cHrStats,\n\t\t                aHr, uHr,\n\t\t                accepted, rejected, stale,\n\t\t                wnotaccepted, waccepted,\n\t\t                hwerrs,\n\t\t                bad_diff1, bad_diff1 + good_diff1);\n\t}\n\telse\n#endif\n\t{\n\t\tpercentf4(rejpcbuf, sizeof(rejpcbuf), wnotaccepted, waccepted);\n\t\tpercentf4(bnbuf, sizeof(bnbuf), bad_diff1, good_diff1);\n\t\ttailsprintf(buf, bufsz, \"%ds:%s avg:%s u:%s | A:%d R:%d+%d(%s) HW:%d/%s\",\n\t\t\topt_log_interval,\n\t\t\tcHr, aHr, uHr,\n\t\t\taccepted,\n\t\t\trejected,\n\t\t\tstale,\n\t\t\trejpcbuf,\n\t\t\thwerrs,\n\t\t\tbnbuf\n\t\t);\n\t}\n}\n\n#define get_statline(buf, bufsz, cgpu)               get_statline3(buf, bufsz, cgpu, false, opt_show_procs)\n#define get_statline2(buf, bufsz, cgpu, for_curses)  get_statline3(buf, bufsz, cgpu, for_curses, opt_show_procs)\n\nstatic void text_print_status(int thr_id)\n{\n\tstruct cgpu_info *cgpu;\n\tchar logline[256];\n\n\tcgpu = get_thr_cgpu(thr_id);\n\tif (cgpu) {\n\t\tget_statline(logline, sizeof(logline), cgpu);\n\t\tprintf(\"\\n%s\\r\", logline);\n\t\tfflush(stdout);\n\t}\n}\n\n#ifdef HAVE_CURSES\nstatic int attr_bad = A_BOLD;\n\n#ifdef WIN32\n#define swprintf snwprintf\n#endif\n\nstatic\nvoid bfg_waddstr(WINDOW *win, const char *s)\n{\n\tconst char *p = s;\n\tint32_t w;\n\tint wlen;\n\tunsigned char stop_ascii = (use_unicode ? '|' : 0x80);\n\t\n\twhile (true)\n\t{\n\t\twhile (likely(p[0] == '\\n' || (p[0] >= 0x20 && p[0] < stop_ascii)))\n\t\t{\n\t\t\t// Printable ASCII\n\t\t\t++p;\n\t\t}\n\t\tif (p != s)\n\t\t\twaddnstr(win, s, p - s);\n\t\tw = utf8_decode(p, &wlen);\n\t\ts = p += wlen;\n\t\tswitch(w)\n\t\t{\n\t\t\t// NOTE: U+F000-U+F7FF are reserved for font hacks\n\t\t\tcase '\\0':\n\t\t\t\treturn;\n\t\t\tcase 0xb5:  // micro symbol\n\t\t\t\tw = unicode_micro;\n\t\t\t\tgoto default_addch;\n\t\t\tcase 0xf000:  // \"bad\" off\n\t\t\t\twattroff(win, attr_bad);\n\t\t\t\tbreak;\n\t\t\tcase 0xf001:  // \"bad\" on\n\t\t\t\twattron(win, attr_bad);\n\t\t\t\tbreak;\n#ifdef USE_UNICODE\n\t\t\tcase '|':\n\t\t\t\twadd_wch(win, WACS_VLINE);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 0x2500:  // BOX DRAWINGS LIGHT HORIZONTAL\n\t\t\tcase 0x2534:  // BOX DRAWINGS LIGHT UP AND HORIZONTAL\n\t\t\t\tif (!use_unicode)\n\t\t\t\t{\n\t\t\t\t\twaddch(win, '-');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef USE_UNICODE\n\t\t\t\twadd_wch(win, (w == 0x2500) ? WACS_HLINE : WACS_BTEE);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 0x2022:\n\t\t\t\tif (w > WCHAR_MAX || !iswprint(w))\n\t\t\t\t\tw = '*';\n\t\t\tdefault:\ndefault_addch:\n\t\t\t\tif (w > WCHAR_MAX || !(iswprint(w) || w == '\\n'))\n\t\t\t\t{\n#if REPLACEMENT_CHAR <= WCHAR_MAX\n\t\t\t\t\tif (iswprint(REPLACEMENT_CHAR))\n\t\t\t\t\t\tw = REPLACEMENT_CHAR;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tw = '?';\n\t\t\t\t}\n\t\t\t\t{\n#ifdef USE_UNICODE\n\t\t\t\t\twchar_t wbuf[0x10];\n\t\t\t\t\tint wbuflen = sizeof(wbuf) / sizeof(*wbuf);\n\t\t\t\t\twbuflen = swprintf(wbuf, wbuflen, L\"%lc\", (wint_t)w);\n\t\t\t\t\twaddnwstr(win, wbuf, wbuflen);\n#else\n\t\t\t\t\twprintw(win, \"%lc\", (wint_t)w);\n#endif\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline\nvoid bfg_hline(WINDOW *win, int y)\n{\n\tint maxx, __maybe_unused maxy;\n\tgetmaxyx(win, maxy, maxx);\n#ifdef USE_UNICODE\n\tif (use_unicode)\n\t\tmvwhline_set(win, y, 0, WACS_HLINE, maxx);\n\telse\n#endif\n\t\tmvwhline(win, y, 0, '-', maxx);\n}\n\nstatic\nint bfg_win_linelen(WINDOW * const win)\n{\n\tint maxx;\n\tint __maybe_unused y;\n\tgetmaxyx(win, y, maxx);\n\treturn maxx;\n}\n\n// Spaces until end of line, using current attributes (ie, not completely clear)\nstatic\nvoid bfg_wspctoeol(WINDOW * const win, const int offset)\n{\n\tint x, maxx;\n\tint __maybe_unused y;\n\tgetmaxyx(win, y, maxx);\n\tgetyx(win, y, x);\n\tconst int space_count = (maxx - x) - offset;\n\t\n\t// Check for negative - terminal too narrow\n\tif (space_count <= 0)\n\t\treturn;\n\t\n\tchar buf[space_count];\n\tmemset(buf, ' ', space_count);\n\twaddnstr(win, buf, space_count);\n}\n\nstatic int menu_attr = A_REVERSE;\n\n#define CURBUFSIZ 256\n#define cg_mvwprintw(win, y, x, fmt, ...) do { \\\n\tchar tmp42[CURBUFSIZ]; \\\n\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\twmove(win, y, x);  \\\n\tbfg_waddstr(win, tmp42); \\\n} while (0)\n#define cg_wprintw(win, fmt, ...) do { \\\n\tchar tmp42[CURBUFSIZ]; \\\n\tsnprintf(tmp42, sizeof(tmp42), fmt, ##__VA_ARGS__); \\\n\tbfg_waddstr(win, tmp42); \\\n} while (0)\n\nstatic\nvoid update_block_display_line(const int blky, struct mining_goal_info *goal)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\tstruct block_info * const blkinfo = blkchain->currentblk;\n\tdouble income;\n\tchar incomestr[ALLOC_H2B_SHORT+6+1];\n\t\n\tif (blkinfo->height)\n\t{\n\t\tincome = goal->diff_accepted * 3600 * blkchain->currentblk_subsidy / total_secs / goal->current_diff;\n\t\tformat_unit3(incomestr, sizeof(incomestr), FUP_BTC, \"BTC/hr\", H2B_SHORT, income/1e8, -1);\n\t}\n\telse\n\t\tstrcpy(incomestr, \"?\");\n\t\n\tint linelen = bfg_win_linelen(statuswin);\n\twmove(statuswin, blky, 0);\n\t\n\tbfg_waddstr(statuswin, \" Block\");\n\tif (!goal->is_default)\n\t\tlinelen -= strlen(goal->name) + 1;\n\tlinelen -= 6;  // \" Block\"\n\t\n\tif (blkinfo->height && blkinfo->height < 1000000)\n\t{\n\t\tcg_wprintw(statuswin, \" #%6u\", blkinfo->height);\n\t\tlinelen -= 8;\n\t}\n\tbfg_waddstr(statuswin, \":\");\n\t\n\tif (linelen > 55)\n\t\tbfg_waddstr(statuswin, \" \");\n\tif (linelen >= 65)\n\t\tbfg_waddstr(statuswin, \"...\");\n\t\n\t{\n\t\tchar hexpbh[0x11];\n\t\tif (!(blkinfo->height && blkinfo->height < 1000000))\n\t\t{\n\t\t\tbin2hex(hexpbh, &blkinfo->prevblkhash[4], 4);\n\t\t\tbfg_waddstr(statuswin, hexpbh);\n\t\t}\n\t\tbin2hex(hexpbh, &blkinfo->prevblkhash[0], 4);\n\t\tbfg_waddstr(statuswin, hexpbh);\n\t}\n\t\n\tif (linelen >= 55)\n\t\tbfg_waddstr(statuswin, \" \");\n\t\n\tcg_wprintw(statuswin, \" Diff:%s\", goal->current_diff_str);\n\t\n\tif (linelen >= 69)\n\t\tbfg_waddstr(statuswin, \" \");\n\t\n\tcg_wprintw(statuswin, \"(%s) \", goal->net_hashrate);\n\t\n\tif (linelen >= 62)\n\t{\n\t\tif (linelen >= 69)\n\t\t\tbfg_waddstr(statuswin, \" \");\n\t\tbfg_waddstr(statuswin, \"Started:\");\n\t}\n\telse\n\t\tbfg_waddstr(statuswin, \"S:\");\n\tif (linelen >= 69)\n\t\tbfg_waddstr(statuswin, \" \");\n\t\n\tbfg_waddstr(statuswin, blkchain->currentblk_first_seen_time_str);\n\t\n\tif (linelen >= 69)\n\t\tbfg_waddstr(statuswin, \" \");\n\t\n\tcg_wprintw(statuswin, \" I:%s\", incomestr);\n\t\n\tif (!goal->is_default)\n\t\tcg_wprintw(statuswin, \" %s\", goal->name);\n\t\n\twclrtoeol(statuswin);\n}\n\nstatic bool pool_actively_in_use(const struct pool *, const struct pool *);\n\nstatic\nvoid update_block_display(const bool within_console_lock)\n{\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tint blky = 3, i, total_found_goals = 0;\n\tif (!within_console_lock)\n\t\tif (!curses_active_locked())\n\t\t\treturn;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tfor (i = 0; i < total_pools; ++i)\n\t\t{\n\t\t\tstruct pool * const pool = pools[i];\n\t\t\tif (pool->goal == goal && pool_actively_in_use(pool, NULL))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= total_pools)\n\t\t\t// no pools using this goal, so it's probably stale anyway\n\t\t\tcontinue;\n\t\tupdate_block_display_line(blky++, goal);\n\t\t++total_found_goals;\n\t}\n\t\n\t// We cannot do resizing if called within someone else's console lock\n\tif (within_console_lock)\n\t\treturn;\n\t\n\tbfg_console_unlock();\n\tif (total_found_goals != active_goals)\n\t{\n\t\tactive_goals = total_found_goals;\n\t\tdevcursor = 7 + active_goals;\n\t\tswitch_logsize();\n\t}\n}\n\nstatic bool pool_unworkable(const struct pool *);\n\n/* Must be called with curses mutex lock held and curses_active */\nstatic void curses_print_status(const int ts)\n{\n\tstruct pool *pool = currentpool;\n\tstruct timeval now, tv;\n\tfloat efficiency;\n\tint logdiv;\n\n\tefficiency = total_bytes_xfer ? total_diff_accepted * 2048. / total_bytes_xfer : 0.0;\n\n\twattron(statuswin, attr_title);\n\tconst int linelen = bfg_win_linelen(statuswin);\n\tint titlelen = 1 + strlen(PACKAGE) + 1 + strlen(bfgminer_ver) + 3 + 21 + 3 + 19;\n\tcg_mvwprintw(statuswin, 0, 0, \" \" PACKAGE \" \");\n\tif (titlelen + 17 < linelen)\n\t\tcg_wprintw(statuswin, \"version \");\n\tcg_wprintw(statuswin, \"%s - \", bfgminer_ver);\n\tif (titlelen + 9 < linelen)\n\t\tcg_wprintw(statuswin, \"Started: \");\n\telse\n\tif (titlelen + 7 <= linelen)\n\t\tcg_wprintw(statuswin, \"Start: \");\n\tcg_wprintw(statuswin, \"%s\", datestamp);\n\ttimer_set_now(&now);\n\t{\n\t\tunsigned int days, hours;\n\t\tdiv_t d;\n\t\t\n\t\ttimersub(&now, &miner_started, &tv);\n\t\td = div(tv.tv_sec, 86400);\n\t\tdays = d.quot;\n\t\td = div(d.rem, 3600);\n\t\thours = d.quot;\n\t\td = div(d.rem, 60);\n\t\tcg_wprintw(statuswin, \" - [%3u day%c %02d:%02d:%02d]\"\n\t\t\t, days\n\t\t\t, (days == 1) ? ' ' : 's'\n\t\t\t, hours\n\t\t\t, d.quot\n\t\t\t, d.rem\n\t\t);\n\t}\n\tbfg_wspctoeol(statuswin, 0);\n\twattroff(statuswin, attr_title);\n\t\n\twattron(statuswin, menu_attr);\n\twmove(statuswin, 1, 0);\n\tbfg_waddstr(statuswin, \" [M]anage devices [P]ool management [S]ettings [D]isplay options \");\n\tbfg_wspctoeol(statuswin, 14);\n\tbfg_waddstr(statuswin, \"[H]elp [Q]uit \");\n\twattroff(statuswin, menu_attr);\n\n\tif ((pool_strategy == POOL_LOADBALANCE  || pool_strategy == POOL_BALANCE) && enabled_pools > 1) {\n\t\tchar poolinfo[20], poolinfo2[20];\n\t\tint poolinfooff = 0, poolinfo2off, workable_pools = 0;\n\t\tdouble lowdiff = DBL_MAX, highdiff = -1;\n\t\tstruct pool *lowdiff_pool = pools[0], *highdiff_pool = pools[0];\n\t\ttime_t oldest_work_restart = time(NULL) + 1;\n\t\tstruct pool *oldest_work_restart_pool = pools[0];\n\t\tfor (int i = 0; i < total_pools; ++i)\n\t\t{\n\t\t\tif (pool_unworkable(pools[i]))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// NOTE: Only set pool var when it's workable; if only one is, it gets used by single-pool code\n\t\t\tpool = pools[i];\n\t\t\t++workable_pools;\n\t\t\t\n\t\t\tif (poolinfooff < sizeof(poolinfo))\n\t\t\t\tpoolinfooff += snprintf(&poolinfo[poolinfooff], sizeof(poolinfo) - poolinfooff, \"%u,\", pool->pool_no);\n\t\t\t\n\t\t\tstruct cgminer_pool_stats * const pool_stats = &pool->cgminer_pool_stats;\n\t\t\tif (pool_stats->last_diff < lowdiff)\n\t\t\t{\n\t\t\t\tlowdiff = pool_stats->last_diff;\n\t\t\t\tlowdiff_pool = pool;\n\t\t\t}\n\t\t\tif (pool_stats->last_diff > highdiff)\n\t\t\t{\n\t\t\t\thighdiff = pool_stats->last_diff;\n\t\t\t\thighdiff_pool = pool;\n\t\t\t}\n\t\t\t\n\t\t\tif (oldest_work_restart >= pool->work_restart_time)\n\t\t\t{\n\t\t\t\toldest_work_restart = pool->work_restart_time;\n\t\t\t\toldest_work_restart_pool = pool;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(!workable_pools))\n\t\t\tgoto no_workable_pools;\n\t\tif (workable_pools == 1)\n\t\t\tgoto one_workable_pool;\n\t\tpoolinfo2off = snprintf(poolinfo2, sizeof(poolinfo2), \"%u (\", workable_pools);\n\t\tif (poolinfooff > sizeof(poolinfo2) - poolinfo2off - 1)\n\t\t\tsnprintf(&poolinfo2[poolinfo2off], sizeof(poolinfo2) - poolinfo2off, \"%.*s...)\", (int)(sizeof(poolinfo2) - poolinfo2off - 5), poolinfo);\n\t\telse\n\t\t\tsnprintf(&poolinfo2[poolinfo2off], sizeof(poolinfo2) - poolinfo2off, \"%.*s)%*s\", (int)(poolinfooff - 1), poolinfo, (int)(sizeof(poolinfo2)), \"\");\n\t\tcg_mvwprintw(statuswin, 2, 0, \" Pools: %s  Diff:%s%s%s  %c  LU:%s\",\n\t\t             poolinfo2,\n\t\t             lowdiff_pool->diff,\n\t\t             (lowdiff == highdiff) ? \"\" : \"-\",\n\t\t             (lowdiff == highdiff) ? \"\" : highdiff_pool->diff,\n\t\t             pool->goal->have_longpoll ? '+' : '-',\n\t\t             oldest_work_restart_pool->work_restart_timestamp);\n\t}\n\telse\n\tif (pool_unworkable(pool))\n\t{\nno_workable_pools: ;\n\t\twattron(statuswin, attr_bad);\n\t\tcg_mvwprintw(statuswin, 2, 0, \" (all pools are dead) \");\n\t\twattroff(statuswin, attr_bad);\n\t}\n\telse\n\t{\none_workable_pool: ;\n\t\tchar pooladdr[19];\n\t\t{\n\t\t\tconst char *rawaddr = pool->sockaddr_url;\n\t\t\tBFGINIT(rawaddr, pool->rpc_url);\n\t\t\tsize_t pooladdrlen = strlen(rawaddr);\n\t\t\tif (pooladdrlen > 20)\n\t\t\t\tsnprintf(pooladdr, sizeof(pooladdr), \"...%s\", &rawaddr[pooladdrlen - (sizeof(pooladdr) - 4)]);\n\t\t\telse\n\t\t\t\tsnprintf(pooladdr, sizeof(pooladdr), \"%*s\", -(int)(sizeof(pooladdr) - 1), rawaddr);\n\t\t}\n\t\tcg_mvwprintw(statuswin, 2, 0, \" Pool%2u: %s  Diff:%s  %c%s  LU:%s  User:%s\",\n\t\t             pool->pool_no, pooladdr, pool->diff,\n\t\t             pool->goal->have_longpoll ? '+' : '-', pool_proto_str(pool),\n\t\t             pool->work_restart_timestamp,\n\t\t             pool->rpc_user);\n\t}\n\twclrtoeol(statuswin);\n\t\n\tupdate_block_display(true);\n\t\n\tchar bwstr[(ALLOC_H2B_SHORT*2)+3+1];\n\t\n\tcg_mvwprintw(statuswin, devcursor - 4, 0, \" ST:%d  F:%d  NB:%d  AS:%d  BW:[%s]  E:%.2f  BS:%s\",\n\t\tts,\n\t\ttotal_go + total_ro,\n\t\tnew_blocks,\n\t\ttotal_submitting,\n\t\tmulti_format_unit2(bwstr, sizeof(bwstr),\n\t\t                   false, \"B/s\", H2B_SHORT, \"/\", 2,\n\t\t                  (float)(total_bytes_rcvd / total_secs),\n\t\t                  (float)(total_bytes_sent / total_secs)),\n\t\tefficiency,\n\t\tbest_share);\n\twclrtoeol(statuswin);\n\t\n\tmvwaddstr(statuswin, devcursor - 3, 0, \" \");\n\tbfg_waddstr(statuswin, statusline);\n\twclrtoeol(statuswin);\n\t\n\tint devdiv = devcursor - 2;\n\tlogdiv = statusy - 1;\n\tbfg_hline(statuswin, devdiv);\n\tbfg_hline(statuswin, logdiv);\n#ifdef USE_UNICODE\n\tif (use_unicode)\n\t{\n\t\tint offset = 8 /* device */ + 5 /* temperature */ + 1 /* padding space */;\n\t\tif (opt_show_procs && !opt_compact)\n\t\t\toffset += max_lpdigits;  // proc letter(s)\n\t\tif (have_unicode_degrees)\n\t\t\t++offset;  // degrees symbol\n\t\tmvwadd_wch(statuswin, devdiv, offset, WACS_PLUS);\n\t\tmvwadd_wch(statuswin, logdiv, offset, WACS_BTEE);\n\t\toffset += 24;  // hashrates etc\n\t\tmvwadd_wch(statuswin, devdiv, offset, WACS_PLUS);\n\t\tmvwadd_wch(statuswin, logdiv, offset, WACS_BTEE);\n\t}\n#endif\n}\n\nstatic void adj_width(int var, int *length)\n{\n\tif ((int)(log10(var) + 1) > *length)\n\t\t(*length)++;\n}\n\nstatic int dev_width;\n\nstatic void curses_print_devstatus(struct cgpu_info *cgpu)\n{\n\tchar logline[256];\n\tint ypos;\n\n\tif (opt_compact)\n\t\treturn;\n\n\t/* Check this isn't out of the window size */\n\tif (opt_show_procs)\n\typos = cgpu->cgminer_id;\n\telse\n\t{\n\t\tif (cgpu->proc_id)\n\t\t\treturn;\n\t\typos = cgpu->device_line_id;\n\t}\n\typos += devsummaryYOffset;\n\tif (ypos < 0)\n\t\treturn;\n\typos += devcursor - 1;\n\tif (ypos >= statusy - 1)\n\t\treturn;\n\n\tif (wmove(statuswin, ypos, 0) == ERR)\n\t\treturn;\n\t\n\tget_statline2(logline, sizeof(logline), cgpu, true);\n\tif (selecting_device && (opt_show_procs ? (selected_device == cgpu->cgminer_id) : (devices[selected_device]->device == cgpu)))\n\t\twattron(statuswin, A_REVERSE);\n\tbfg_waddstr(statuswin, logline);\n\twattroff(statuswin, A_REVERSE);\n\n\twclrtoeol(statuswin);\n}\n\nstatic\nvoid _refresh_devstatus(const bool already_have_lock) {\n\tif ((!opt_compact) && (already_have_lock || curses_active_locked())) {\n\t\tint i;\n\t\tif (unlikely(!total_devices))\n\t\t{\n\t\t\tconst int ypos = devcursor - 1;\n\t\t\tif (ypos < statusy - 1 && wmove(statuswin, ypos, 0) != ERR)\n\t\t\t{\n\t\t\t\twattron(statuswin, attr_bad);\n\t\t\t\tbfg_waddstr(statuswin, \"NO DEVICES FOUND: Press 'M' and '+' to add\");\n\t\t\t\twclrtoeol(statuswin);\n\t\t\t\twattroff(statuswin, attr_bad);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < total_devices; i++)\n\t\t\tcurses_print_devstatus(get_devices(i));\n\t\ttouchwin(statuswin);\n\t\twrefresh(statuswin);\n\t\tif (!already_have_lock)\n\t\t\tunlock_curses();\n\t}\n}\n#define refresh_devstatus() _refresh_devstatus(false)\n\n#endif\n\nstatic void print_status(int thr_id)\n{\n\tif (!curses_active)\n\t\ttext_print_status(thr_id);\n}\n\n#ifdef HAVE_CURSES\nstatic\nbool set_statusy(int maxy)\n{\n\tif (loginput_size)\n\t{\n\t\tmaxy -= loginput_size;\n\t\tif (maxy < 0)\n\t\t\tmaxy = 0;\n\t}\n\t\n\tif (logstart < maxy)\n\t\tmaxy = logstart;\n\t\n\tif (statusy == maxy)\n\t\treturn false;\n\t\n\tstatusy = maxy;\n\tlogcursor = statusy;\n\t\n\treturn true;\n}\n\n/* Check for window resize. Called with curses mutex locked */\nstatic inline void change_logwinsize(void)\n{\n\tint x, y, logx, logy;\n\n\tgetmaxyx(mainwin, y, x);\n\tif (x < 80 || y < 25)\n\t\treturn;\n\n\tif (y > statusy + 2 && statusy < logstart) {\n\t\tset_statusy(y - 2);\n\t\tmvwin(logwin, logcursor, 0);\n\t\tbfg_wresize(statuswin, statusy, x);\n\t}\n\n\ty -= logcursor;\n\tgetmaxyx(logwin, logy, logx);\n\t/* Detect screen size change */\n\tif (x != logx || y != logy)\n\t\tbfg_wresize(logwin, y, x);\n}\n\nstatic void check_winsizes(void)\n{\n\tif (!use_curses)\n\t\treturn;\n\tif (curses_active_locked()) {\n\t\tint y, x;\n\n\t\tx = getmaxx(statuswin);\n\t\tif (set_statusy(LINES - 2))\n\t\t{\n\t\t\terase();\n\t\t\tbfg_wresize(statuswin, statusy, x);\n\t\t\tgetmaxyx(mainwin, y, x);\n\t\t\ty -= logcursor;\n\t\t\tbfg_wresize(logwin, y, x);\n\t\t\tmvwin(logwin, logcursor, 0);\n\t\t}\n\t\tunlock_curses();\n\t}\n}\n\nstatic int device_line_id_count;\n\nstatic void switch_logsize(void)\n{\n\tif (curses_active_locked()) {\n\t\tif (opt_compact) {\n\t\t\tlogstart = devcursor - 1;\n\t\t\tlogcursor = logstart + 1;\n\t\t} else {\n\t\t\ttotal_lines = (opt_show_procs ? total_devices : device_line_id_count) ?: 1;\n\t\t\tlogstart = devcursor + total_lines;\n\t\t\tlogcursor = logstart;\n\t\t}\n\t\tunlock_curses();\n\t}\n\tcheck_winsizes();\n\tupdate_block_display(false);\n}\n\n/* For mandatory printing when mutex is already locked */\nvoid _wlog(const char *str)\n{\n\tstatic bool newline;\n\tsize_t end = strlen(str) - 1;\n\t\n\tif (newline)\n\t\tbfg_waddstr(logwin, \"\\n\");\n\t\n\tif (str[end] == '\\n')\n\t{\n\t\tchar *s;\n\t\t\n\t\tnewline = true;\n\t\ts = alloca(end + 1);\n\t\tmemcpy(s, str, end);\n\t\ts[end] = '\\0';\n\t\tstr = s;\n\t}\n\telse\n\t\tnewline = false;\n\t\n\tbfg_waddstr(logwin, str);\n}\n\n/* Mandatory printing */\nvoid _wlogprint(const char *str)\n{\n\tif (curses_active_locked()) {\n\t\t_wlog(str);\n\t\tunlock_curses();\n\t}\n}\n#endif\n\n#ifdef HAVE_CURSES\nbool _log_curses_only(int prio, const char *datetime, const char *str)\n{\n\tbool high_prio;\n\n\thigh_prio = (prio == LOG_WARNING || prio == LOG_ERR);\n\n\tif (curses_active)\n\t{\n\t\tif (!loginput_size || high_prio) {\n\t\t\twlog(\" %s %s\\n\", datetime, str);\n\t\t\tif (high_prio) {\n\t\t\t\ttouchwin(logwin);\n\t\t\t\twrefresh(logwin);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid clear_logwin(void)\n{\n\tif (curses_active_locked()) {\n\t\twclear(logwin);\n\t\tunlock_curses();\n\t}\n}\n\nvoid logwin_update(void)\n{\n\tif (curses_active_locked()) {\n\t\ttouchwin(logwin);\n\t\twrefresh(logwin);\n\t\tunlock_curses();\n\t}\n}\n#endif\n\nvoid enable_pool(struct pool * const pool)\n{\n\tif (pool->enabled != POOL_ENABLED) {\n\t\tmutex_lock(&lp_lock);\n\t\tenabled_pools++;\n\t\tpool->enabled = POOL_ENABLED;\n\t\tpthread_cond_broadcast(&lp_cond);\n\t\tmutex_unlock(&lp_lock);\n\t\tif (pool->prio < current_pool()->prio)\n\t\t\tswitch_pools(pool);\n\t}\n}\n\nvoid manual_enable_pool(struct pool * const pool)\n{\n\tpool->failover_only = false;\n\tBFGINIT(pool->quota, 1);\n\tenable_pool(pool);\n}\n\nvoid disable_pool(struct pool * const pool, const enum pool_enable enable_status)\n{\n\tif (pool->enabled == POOL_DISABLED)\n\t\t/* had been manually disabled before */\n\t\treturn;\n\t\n\tif (pool->enabled != POOL_ENABLED)\n\t{\n\t\t/* has been programmatically disabled already, just change to the new status directly */\n\t\tpool->enabled = enable_status;\n\t\treturn;\n\t}\n\t\n\t/* Fall into the lock area */\n\tmutex_lock(&lp_lock);\n\t--enabled_pools;\n\tpool->enabled = enable_status;\n\tmutex_unlock(&lp_lock);\n\t\n\tif (pool == current_pool())\n\t\tswitch_pools(NULL);\n}\n\nstatic\nvoid share_result_msg(const struct work *work, const char *disp, const char *reason, bool resubmit, const char *worktime) {\n\tstruct cgpu_info *cgpu;\n\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tconst unsigned char *hashpart = &work->hash[0x1c - malgo->ui_skip_hash_bytes];\n\tchar shrdiffdisp[ALLOC_H2B_SHORTV];\n\tconst double tgtdiff = work->work_difficulty;\n\tchar tgtdiffdisp[ALLOC_H2B_SHORTV];\n\tchar where[20];\n\t\n\tcgpu = get_thr_cgpu(work->thr_id);\n\t\n\tsuffix_string(work->share_diff, shrdiffdisp, sizeof(shrdiffdisp), 0);\n\tsuffix_string(tgtdiff, tgtdiffdisp, sizeof(tgtdiffdisp), 0);\n\t\n\tif (total_pools > 1)\n\t\tsnprintf(where, sizeof(where), \" pool %d\", work->pool->pool_no);\n\telse\n\t\twhere[0] = '\\0';\n\t\n\tapplog(LOG_NOTICE, \"%s %02x%02x%02x%02x %\"PRIprepr\"%s Diff %s/%s%s %s%s\",\n\t       disp,\n\t       (unsigned)hashpart[3], (unsigned)hashpart[2], (unsigned)hashpart[1], (unsigned)hashpart[0],\n\t       cgpu->proc_repr,\n\t       where,\n\t       shrdiffdisp, tgtdiffdisp,\n\t       reason,\n\t       resubmit ? \"(resubmit)\" : \"\",\n\t       worktime\n\t);\n}\n\nstatic bool test_work_current(struct work *);\nstatic void _submit_work_async(struct work *);\n\nstatic\nvoid maybe_local_submit(const struct work *work)\n{\n#if BLKMAKER_VERSION > 3\n\tif (unlikely(work->block && work->tr))\n\t{\n\t\t// This is a block with a full template (GBT)\n\t\t// Regardless of the result, submit to local bitcoind(s) as well\n\t\tstruct work *work_cp;\n\t\t\n\t\tfor (int i = 0; i < total_pools; ++i)\n\t\t{\n\t\t\tif (!uri_get_param_bool(pools[i]->rpc_url, \"allblocks\", false))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"Attempting submission of full block to pool %d\", pools[i]->pool_no);\n\t\t\twork_cp = copy_work(work);\n\t\t\twork_cp->pool = pools[i];\n\t\t\twork_cp->do_foreign_submit = true;\n\t\t\t_submit_work_async(work_cp);\n\t\t}\n\t}\n#endif\n}\n\nstatic\njson_t *extract_reject_reason_j(json_t * const val, json_t *res, json_t * const err, const struct work * const work)\n{\n\tif (json_is_string(res))\n\t\treturn res;\n\tif ( (res = json_object_get(val, \"reject-reason\")) )\n\t\treturn res;\n\tif (work->stratum && err && json_is_array(err) && json_array_size(err) >= 2 && (res = json_array_get(err, 1)) && json_is_string(res))\n\t\treturn res;\n\treturn NULL;\n}\n\nstatic\nconst char *extract_reject_reason(json_t * const val, json_t *res, json_t * const err, const struct work * const work)\n{\n\tjson_t * const j = extract_reject_reason_j(val, res, err, work);\n\treturn j ? json_string_value(j) : NULL;\n}\n\nstatic\nint put_in_parens(char * const buf, const size_t bufsz, const char * const s)\n{\n\tif (!s)\n\t{\n\t\tif (bufsz)\n\t\t\tbuf[0] = '\\0';\n\t\treturn 0;\n\t}\n\t\n\tint p = snprintf(buf, bufsz, \" (%s\", s);\n\tif (p >= bufsz - 1)\n\t\tp = bufsz - 2;\n\tstrcpy(&buf[p], \")\");\n\treturn p + 1;\n}\n\n/* Theoretically threads could race when modifying accepted and\n * rejected values but the chance of two submits completing at the\n * same time is zero so there is no point adding extra locking */\nstatic void\nshare_result(json_t *val, json_t *res, json_t *err, const struct work *work,\n\t     /*char *hashshow,*/ bool resubmit, char *worktime)\n{\n\tstruct pool *pool = work->pool;\n\tstruct cgpu_info *cgpu;\n\n\tcgpu = get_thr_cgpu(work->thr_id);\n\n\tif ((json_is_null(err) || !err) && (json_is_null(res) || json_is_true(res))) {\n\t\tstruct mining_goal_info * const goal = pool->goal;\n\t\t\n\t\tmutex_lock(&stats_lock);\n\t\tcgpu->accepted++;\n\t\ttotal_accepted++;\n\t\tpool->accepted++;\n\t\tcgpu->diff_accepted += work->work_difficulty;\n\t\ttotal_diff_accepted += work->work_difficulty;\n\t\tpool->diff_accepted += work->work_difficulty;\n\t\tgoal->diff_accepted += work->work_difficulty;\n\t\tmutex_unlock(&stats_lock);\n\n\t\tpool->seq_rejects = 0;\n\t\tcgpu->last_share_pool = pool->pool_no;\n\t\tcgpu->last_share_pool_time = time(NULL);\n\t\tcgpu->last_share_diff = work->work_difficulty;\n\t\tpool->last_share_time = cgpu->last_share_pool_time;\n\t\tpool->last_share_diff = work->work_difficulty;\n\t\tapplog(LOG_DEBUG, \"PROOF OF WORK RESULT: true (yay!!!)\");\n\t\tif (!QUIET) {\n\t\t\tshare_result_msg(work, \"Accepted\", \"\", resubmit, worktime);\n\t\t}\n\t\tsharelog(\"accept\", work);\n\t\tif (opt_shares && total_diff_accepted >= opt_shares) {\n\t\t\tapplog(LOG_WARNING, \"Successfully mined %g accepted shares as requested and exiting.\", opt_shares);\n\t\t\tkill_work();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Detect if a pool that has been temporarily disabled for\n\t\t * continually rejecting shares has started accepting shares.\n\t\t * This will only happen with the work returned from a\n\t\t * longpoll */\n\t\tif (unlikely(pool->enabled == POOL_REJECTING)) {\n\t\t\tapplog(LOG_WARNING, \"Rejecting pool %d now accepting shares, re-enabling!\", pool->pool_no);\n\t\t\tenable_pool(pool);\n\t\t}\n\n\t\tif (unlikely(work->block)) {\n\t\t\t// Force moving on to this new block :)\n\t\t\tstruct work fakework;\n\t\t\tmemset(&fakework, 0, sizeof(fakework));\n\t\t\tfakework.pool = work->pool;\n\n\t\t\t// Copy block version, bits, and time from share\n\t\t\tmemcpy(&fakework.data[ 0], &work->data[ 0], 4);\n\t\t\tmemcpy(&fakework.data[68], &work->data[68], 8);\n\n\t\t\t// Set prevblock to winning hash (swap32'd)\n\t\t\tswap32yes(&fakework.data[4], &work->hash[0], 32 / 4);\n\n\t\t\ttest_work_current(&fakework);\n\t\t}\n\t}\n\telse\n\tif (!hash_target_check(work->hash, work->target))\n\t{\n\t\t// This was submitted despite failing the proper target\n\t\t// Quietly ignore the reject\n\t\tchar reason[32];\n\t\tput_in_parens(reason, sizeof(reason), extract_reject_reason(val, res, err, work));\n\t\tapplog(LOG_DEBUG, \"Share above target rejected%s by pool %u as expected, ignoring\", reason, pool->pool_no);\n\t\t\n\t\t// Stratum error 23 is \"low difficulty share\", which suggests this pool tracks job difficulty correctly.\n\t\t// Therefore, we disable retrodiff if it was enabled-by-default.\n\t\tif (pool->pool_diff_effective_retroactively == BTS_UNKNOWN) {\n\t\t\tjson_t *errnum;\n\t\t\tif (work->stratum && err && json_is_array(err) && json_array_size(err) >= 1 && (errnum = json_array_get(err, 0)) && json_is_number(errnum) && ((int)json_number_value(errnum)) == 23) {\n\t\t\t\tapplog(LOG_DEBUG, \"Disabling retroactive difficulty adjustments for pool %u\", pool->pool_no);\n\t\t\t\tpool->pool_diff_effective_retroactively = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmutex_lock(&stats_lock);\n\t\tcgpu->rejected++;\n\t\ttotal_rejected++;\n\t\tpool->rejected++;\n\t\tcgpu->diff_rejected += work->work_difficulty;\n\t\ttotal_diff_rejected += work->work_difficulty;\n\t\tpool->diff_rejected += work->work_difficulty;\n\t\tpool->seq_rejects++;\n\t\tmutex_unlock(&stats_lock);\n\n\t\tapplog(LOG_DEBUG, \"PROOF OF WORK RESULT: false (booooo)\");\n\t\tif (!QUIET) {\n\t\t\tchar disposition[36] = \"reject\";\n\t\t\tchar reason[32];\n\n\t\t\tconst char *reasontmp = extract_reject_reason(val, res, err, work);\n\t\t\tint n = put_in_parens(reason, sizeof(reason), reasontmp);\n\t\t\tif (reason[0])\n\t\t\t\tsnprintf(&disposition[6], sizeof(disposition) - 6, \":%.*s\", n - 3, &reason[2]);\n\n\t\t\tshare_result_msg(work, \"Rejected\", reason, resubmit, worktime);\n\t\t\tsharelog(disposition, work);\n\t\t}\n\n\t\t/* Once we have more than a nominal amount of sequential rejects,\n\t\t * at least 10 and more than 3 mins at the current utility,\n\t\t * disable the pool because some pool error is likely to have\n\t\t * ensued. Do not do this if we know the share just happened to\n\t\t * be stale due to networking delays.\n\t\t */\n\t\tif (pool->seq_rejects > 10 && !work->stale && opt_disable_pool && enabled_pools > 1) {\n\t\t\tdouble utility = total_accepted / total_secs * 60;\n\n\t\t\tif (pool->seq_rejects > utility * 3) {\n\t\t\t\tapplog(LOG_WARNING, \"Pool %d rejected %d sequential shares, disabling!\",\n\t\t\t\t       pool->pool_no, pool->seq_rejects);\n\t\t\t\tdisable_pool(pool, POOL_REJECTING);\n\t\t\t\tpool->seq_rejects = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmaybe_local_submit(work);\n}\n\nstatic char *submit_upstream_work_request(struct work *work)\n{\n\tchar *hexstr = NULL;\n\tchar *s, *sd;\n\tstruct pool *pool = work->pool;\n\n\tif (work->tr)\n\t{\n\t\tblktemplate_t * const tmpl = work->tr->tmpl;\n\t\tjson_t *req;\n\t\tunsigned char data[80];\n\t\t\n\t\tswap32yes(data, work->data, 80 / 4);\n#if BLKMAKER_VERSION > 6\n\t\tif (work->stratum) {\n\t\t\treq = blkmk_submitm_jansson(tmpl, data, bytes_buf(&work->nonce2), bytes_len(&work->nonce2), le32toh(*((uint32_t*)&work->data[76])), work->do_foreign_submit);\n\t\t} else\n#endif\n#if BLKMAKER_VERSION > 3\n\t\tif (work->do_foreign_submit)\n\t\t\treq = blkmk_submit_foreign_jansson(tmpl, data, work->dataid, le32toh(*((uint32_t*)&work->data[76])));\n\t\telse\n#endif\n\t\t\treq = blkmk_submit_jansson(tmpl, data, work->dataid, le32toh(*((uint32_t*)&work->data[76])));\n\t\ts = json_dumps(req, 0);\n\t\tjson_decref(req);\n\t\tsd = malloc(161);\n\t\tbin2hex(sd, data, 80);\n\t} else {\n\n\t/* build hex string */\n\t\thexstr = malloc((sizeof(work->data) * 2) + 1);\n\t\tbin2hex(hexstr, work->data, sizeof(work->data));\n\n\t/* build JSON-RPC request */\n\t\ts = strdup(\"{\\\"method\\\": \\\"getwork\\\", \\\"params\\\": [ \\\"\");\n\t\ts = realloc_strcat(s, hexstr);\n\t\ts = realloc_strcat(s, \"\\\" ], \\\"id\\\":1}\");\n\n\t\tfree(hexstr);\n\t\tsd = s;\n\n\t}\n\n\tapplog(LOG_DEBUG, \"DBG: sending %s submit RPC call: %s\", pool->rpc_url, sd);\n\tif (work->tr)\n\t\tfree(sd);\n\telse\n\t\ts = realloc_strcat(s, \"\\n\");\n\n\treturn s;\n}\n\nstatic bool submit_upstream_work_completed(struct work *work, bool resubmit, struct timeval *ptv_submit, json_t *val) {\n\tjson_t *res, *err;\n\tbool rc = false;\n\tint thr_id = work->thr_id;\n\tstruct pool *pool = work->pool;\n\tstruct timeval tv_submit_reply;\n\ttime_t ts_submit_reply;\n\tchar worktime[200] = \"\";\n\n\tcgtime(&tv_submit_reply);\n\tts_submit_reply = time(NULL);\n\n\tif (unlikely(!val)) {\n\t\tapplog(LOG_INFO, \"submit_upstream_work json_rpc_call failed\");\n\t\tif (!pool_tset(pool, &pool->submit_fail)) {\n\t\t\ttotal_ro++;\n\t\t\tpool->remotefail_occasions++;\n\t\t\tapplog(LOG_WARNING, \"Pool %d communication failure, caching submissions\", pool->pool_no);\n\t\t}\n\t\tgoto out;\n\t} else if (pool_tclear(pool, &pool->submit_fail))\n\t\tapplog(LOG_WARNING, \"Pool %d communication resumed, submitting work\", pool->pool_no);\n\n\tres = json_object_get(val, \"result\");\n\terr = json_object_get(val, \"error\");\n\n\tif (!QUIET) {\n\t\tif (opt_worktime) {\n\t\t\tchar workclone[20];\n\t\t\tstruct tm _tm;\n\t\t\tstruct tm *tm, tm_getwork, tm_submit_reply;\n\t\t\ttm = &_tm;\n\t\t\tdouble getwork_time = tdiff((struct timeval *)&(work->tv_getwork_reply),\n\t\t\t\t\t\t\t(struct timeval *)&(work->tv_getwork));\n\t\t\tdouble getwork_to_work = tdiff((struct timeval *)&(work->tv_work_start),\n\t\t\t\t\t\t\t(struct timeval *)&(work->tv_getwork_reply));\n\t\t\tdouble work_time = tdiff((struct timeval *)&(work->tv_work_found),\n\t\t\t\t\t\t\t(struct timeval *)&(work->tv_work_start));\n\t\t\tdouble work_to_submit = tdiff(ptv_submit,\n\t\t\t\t\t\t\t(struct timeval *)&(work->tv_work_found));\n\t\t\tdouble submit_time = tdiff(&tv_submit_reply, ptv_submit);\n\t\t\tint diffplaces = 3;\n\n\t\t\tlocaltime_r(&work->ts_getwork, tm);\n\t\t\tmemcpy(&tm_getwork, tm, sizeof(struct tm));\n\t\t\tlocaltime_r(&ts_submit_reply, tm);\n\t\t\tmemcpy(&tm_submit_reply, tm, sizeof(struct tm));\n\n\t\t\tif (work->clone) {\n\t\t\t\tsnprintf(workclone, sizeof(workclone), \"C:%1.3f\",\n\t\t\t\t\t\ttdiff((struct timeval *)&(work->tv_cloned),\n\t\t\t\t\t\t(struct timeval *)&(work->tv_getwork_reply)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrcpy(workclone, \"O\");\n\n\t\t\tif (work->work_difficulty < 1)\n\t\t\t\tdiffplaces = 6;\n\n\t\t\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\t\t\tconst uint8_t * const prevblkhash = &work->data[4];\n\t\t\tsnprintf(worktime, sizeof(worktime),\n\t\t\t\t\" <-%08lx.%08lx M:%c D:%1.*f G:%02d:%02d:%02d:%1.3f %s (%1.3f) W:%1.3f (%1.3f) S:%1.3f R:%02d:%02d:%02d\",\n\t\t\t\t(unsigned long)be32toh(((uint32_t *)prevblkhash)[7 - malgo->worktime_skip_prevblk_u32]),\n\t\t\t\t(unsigned long)be32toh(((uint32_t *)prevblkhash)[6 - malgo->worktime_skip_prevblk_u32]),\n\t\t\t\twork->getwork_mode, diffplaces, work->work_difficulty,\n\t\t\t\ttm_getwork.tm_hour, tm_getwork.tm_min,\n\t\t\t\ttm_getwork.tm_sec, getwork_time, workclone,\n\t\t\t\tgetwork_to_work, work_time, work_to_submit, submit_time,\n\t\t\t\ttm_submit_reply.tm_hour, tm_submit_reply.tm_min,\n\t\t\t\ttm_submit_reply.tm_sec);\n\t\t}\n\t}\n\n\tshare_result(val, res, err, work, resubmit, worktime);\n\n\tif (!opt_realquiet)\n\t\tprint_status(thr_id);\n\tif (!want_per_device_stats) {\n\t\tchar logline[256];\n\t\tstruct cgpu_info *cgpu;\n\n\t\tcgpu = get_thr_cgpu(thr_id);\n\t\t\n\t\tget_statline(logline, sizeof(logline), cgpu);\n\t\tapplog(LOG_INFO, \"%s\", logline);\n\t}\n\n\tjson_decref(val);\n\n\trc = true;\nout:\n\treturn rc;\n}\n\n/* Specifies whether we can use this pool for work or not. */\nstatic bool pool_unworkable(const struct pool * const pool)\n{\n\tif (pool->idle)\n\t\treturn true;\n\tif (pool->enabled != POOL_ENABLED)\n\t\treturn true;\n\tif (pool->has_stratum && !pool->stratum_active)\n\t\treturn true;\n\treturn false;\n}\n\nstatic struct pool *priority_pool(int);\nstatic bool pool_unusable(struct pool *);\n\nstatic\nbool pool_actively_desired(const struct pool * const pool, const struct pool *cp)\n{\n\tif (pool->enabled != POOL_ENABLED)\n\t\treturn false;\n\tif (pool_strategy == POOL_LOADBALANCE && pool->quota)\n\t\treturn true;\n\tif (pool_strategy == POOL_BALANCE && !pool->failover_only)\n\t\treturn true;\n\tif (!cp)\n\t\tcp = current_pool();\n\tif (pool == cp)\n\t\treturn true;\n\t\n\t// If we are the highest priority, workable pool for a given algorithm, we are needed\n\tstruct mining_algorithm * const malgo = pool->goal->malgo;\n\tfor (int i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool * const other_pool = priority_pool(i);\n\t\tif (other_pool == pool)\n\t\t\treturn true;\n\t\tif (pool_unusable(other_pool))\n\t\t\tcontinue;\n\t\tif (other_pool->goal->malgo == malgo)\n\t\t\tbreak;\n\t}\n\t\n\treturn false;\n}\n\nstatic\nbool pool_actively_in_use(const struct pool * const pool, const struct pool *cp)\n{\n\treturn (!pool_unworkable(pool)) && pool_actively_desired(pool, cp);\n}\n\nstatic\nbool pool_supports_block_change_notification(struct pool * const pool)\n{\n\treturn pool->has_stratum || pool->lp_url;\n}\n\nstatic\nbool pool_has_active_block_change_notification(struct pool * const pool)\n{\n\treturn pool->stratum_active || pool->lp_active;\n}\n\nstatic struct pool *_select_longpoll_pool(struct pool *, bool(*)(struct pool *));\n#define select_longpoll_pool(pool)  _select_longpoll_pool(pool, pool_supports_block_change_notification)\n#define pool_active_lp_pool(pool)  _select_longpoll_pool(pool, pool_has_active_block_change_notification)\n\n/* In balanced mode, the amount of diff1 solutions per pool is monitored as a\n * rolling average per 10 minutes and if pools start getting more, it biases\n * away from them to distribute work evenly. The share count is reset to the\n * rolling average every 10 minutes to not send all work to one pool after it\n * has been disabled/out for an extended period. */\nstatic\nstruct pool *select_balanced(struct pool *cp, struct mining_algorithm * const malgo)\n{\n\tint i, lowest = cp->shares;\n\tstruct pool *ret = cp, *failover_pool = NULL;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tif (malgo && pool->goal->malgo != malgo)\n\t\t\tcontinue;\n\t\tif (pool_unworkable(pool))\n\t\t\tcontinue;\n\t\tif (pool->failover_only)\n\t\t{\n\t\t\tBFGINIT(failover_pool, pool);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pool->shares < lowest) {\n\t\t\tlowest = pool->shares;\n\t\t\tret = pool;\n\t\t}\n\t}\n\tif (malgo && ret->goal->malgo != malgo)\n\t\t// Yes, we want failover_pool even if it's NULL\n\t\tret = failover_pool;\n\telse\n\tif (pool_unworkable(ret) && failover_pool)\n\t\tret = failover_pool;\n\n\tif (ret)\n\t\t++ret->shares;\n\treturn ret;\n}\n\nstatic\nstruct pool *select_loadbalance(struct mining_algorithm * const malgo)\n{\n\tstatic int rotating_pool = 0;\n\tstruct pool *pool;\n\tbool avail = false;\n\tint tested, i, rpsave;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *tp = pools[i];\n\n\t\tif (tp->quota_used < tp->quota_gcd) {\n\t\t\tavail = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* There are no pools with quota, so reset them. */\n\tif (!avail) {\n\t\tfor (i = 0; i < total_pools; i++)\n\t\t{\n\t\t\tstruct pool * const tp = pools[i];\n\t\t\ttp->quota_used -= tp->quota_gcd;\n\t\t}\n\t\tif (++rotating_pool >= total_pools)\n\t\t\trotating_pool = 0;\n\t}\n\n\t/* Try to find the first pool in the rotation that is usable */\n\t// Look for the lowest integer quota_used / quota_gcd in case we are imbalanced by algorithm demands\n\tstruct pool *pool_lowest = NULL;\n\tint lowest = INT_MAX;\n\trpsave = rotating_pool;\n\tfor (tested = 0; tested < total_pools; ++tested)\n\t{\n\t\tpool = pools[rotating_pool];\n\t\tif (malgo && pool->goal->malgo != malgo)\n\t\t\tgoto continue_tested;\n\t\t\n\t\tif (pool->quota_used < pool->quota_gcd)\n\t\t{\n\t\t\t++pool->quota_used;\n\t\t\tif (!pool_unworkable(pool))\n\t\t\t\tgoto out;\n\t\t\t/* Failover-only flag for load-balance means distribute\n\t\t\t * unused quota to priority pool 0. */\n\t\t\tif (opt_fail_only)\n\t\t\t\tpriority_pool(0)->quota_used--;\n\t\t}\n\t\tif (malgo)\n\t\t{\n\t\t\tconst int count = pool->quota_used / pool->quota_gcd;\n\t\t\tif (count < lowest)\n\t\t\t{\n\t\t\t\tpool_lowest = pool;\n\t\t\t\tlowest = count;\n\t\t\t}\n\t\t}\n\t\t\ncontinue_tested: ;\n\t\tif (++rotating_pool >= total_pools)\n\t\t\trotating_pool = 0;\n\t}\n\t\n\t// Even if pool_lowest is NULL, we want to return that to indicate failure\n\t// Note it isn't possible to get here if !malgo\n\tpool = pool_lowest;\n\t\nout: ;\n\t// Restore rotating_pool static, so malgo searches don't affect the usual load balancing\n\tif (malgo)\n\t\trotating_pool = rpsave;\n\t\n\treturn pool;\n}\n\nstatic\nstruct pool *select_failover(struct mining_algorithm * const malgo)\n{\n\tint i;\n\t\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *tp = priority_pool(i);\n\t\t\n\t\tif (malgo && tp->goal->malgo != malgo)\n\t\t\tcontinue;\n\t\t\n\t\tif (!pool_unusable(tp)) {\n\t\t\treturn tp;\n\t\t}\n\t}\n\t\n\treturn NULL;\n}\n\nstatic bool pool_active(struct pool *, bool pinging);\nstatic void pool_died(struct pool *);\n\n/* Select any active pool in a rotating fashion when loadbalance is chosen if\n * it has any quota left. */\nstatic inline struct pool *select_pool(bool lagging, struct mining_algorithm * const malgo)\n{\n\tstruct pool *pool = NULL, *cp;\n\nretry:\n\tcp = current_pool();\n\n\tif (pool_strategy == POOL_BALANCE) {\n\t\tpool = select_balanced(cp, malgo);\n\t\tif ((!pool) || pool_unworkable(pool))\n\t\t\tgoto simple_failover;\n\t\tgoto out;\n\t}\n\n\tif (pool_strategy != POOL_LOADBALANCE && (!lagging || opt_fail_only)) {\n\t\tif (malgo && cp->goal->malgo != malgo)\n\t\t\tgoto simple_failover;\n\t\tpool = cp;\n\t\tgoto out;\n\t} else\n\t\tpool = select_loadbalance(malgo);\n\nsimple_failover:\n\t/* If there are no alive pools with quota, choose according to\n\t * priority. */\n\tif (!pool) {\n\t\tpool = select_failover(malgo);\n\t}\n\n\t/* If still nothing is usable, use the current pool */\n\tif (!pool)\n\t{\n\t\tif (malgo && cp->goal->malgo != malgo)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Failed to select pool for specific mining algorithm '%s'\", malgo->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tpool = cp;\n\t}\n\nout:\n\tif (!pool_actively_in_use(pool, cp))\n\t{\n\t\tif (!pool_active(pool, false))\n\t\t{\n\t\t\tpool_died(pool);\n\t\t\tgoto retry;\n\t\t}\n\t\tpool_tclear(pool, &pool->idle);\n\t}\n\tapplog(LOG_DEBUG, \"Selecting pool %d for %s%swork\", pool->pool_no, malgo ? malgo->name : \"\", malgo ? \" \" : \"\");\n\treturn pool;\n}\n\nstatic double DIFFEXACTONE = 26959946667150639794667015087019630673637144422540572481103610249215.0;\n\ndouble target_diff(const unsigned char *target)\n{\n\tdouble targ = 0;\n\tsigned int i;\n\n\tfor (i = 31; i >= 0; --i)\n\t\ttarg = (targ * 0x100) + target[i];\n\n\treturn DIFFEXACTONE / (targ ?: 1);\n}\n\n/*\n * Calculate the work share difficulty\n */\nstatic void calc_diff(struct work *work, int known)\n{\n\tstruct cgminer_pool_stats *pool_stats = &(work->pool->cgminer_pool_stats);\n\tdouble difficulty;\n\n\tif (!known) {\n\t\twork->work_difficulty = target_diff(work->target);\n\t} else\n\t\twork->work_difficulty = known;\n\tdifficulty = work->work_difficulty;\n\n\tpool_stats->last_diff = difficulty;\n\tsuffix_string(difficulty, work->pool->diff, sizeof(work->pool->diff), 0);\n\n\tif (difficulty == pool_stats->min_diff)\n\t\tpool_stats->min_diff_count++;\n\telse if (difficulty < pool_stats->min_diff || pool_stats->min_diff == 0) {\n\t\tpool_stats->min_diff = difficulty;\n\t\tpool_stats->min_diff_count = 1;\n\t}\n\n\tif (difficulty == pool_stats->max_diff)\n\t\tpool_stats->max_diff_count++;\n\telse if (difficulty > pool_stats->max_diff) {\n\t\tpool_stats->max_diff = difficulty;\n\t\tpool_stats->max_diff_count = 1;\n\t}\n}\n\nstatic void gen_stratum_work(struct pool *, struct work *);\nstatic void pool_update_work_restart_time(struct pool *);\nstatic void restart_threads(void);\n\nstatic uint32_t benchmark_blkhdr[20];\nstatic const int benchmark_update_interval = 1;\n\nstatic\nvoid *benchmark_intense_work_update_thread(void *userp)\n{\n\tpthread_detach(pthread_self());\n\tRenameThread(\"benchmark-intense\");\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\t\n\tstruct pool * const pool = userp;\n\tstruct stratum_work * const swork = &pool->swork;\n\tuint8_t * const blkhdr = swork->header1;\n\t\n\twhile (true)\n\t{\n\t\tsleep(benchmark_update_interval);\n\t\t\n\t\tcg_wlock(&pool->data_lock);\n\t\tfor (int i = 36; --i >= 0; )\n\t\t\tif (++blkhdr[i])\n\t\t\t\tbreak;\n\t\tcg_wunlock(&pool->data_lock);\n\t\t\n\t\tstruct work *work = make_work();\n\t\tgen_stratum_work(pool, work);\n\t\tpool->swork.work_restart_id = ++pool->work_restart_id;\n\t\tpool_update_work_restart_time(pool);\n\t\ttest_work_current(work);\n\t\tfree_work(work);\n\t\t\n\t\trestart_threads();\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid setup_benchmark_pool()\n{\n\tstruct pool *pool;\n\t\n\twant_longpoll = false;\n\t\n\t// Temporarily disable opt_benchmark to avoid auto-removal\n\topt_benchmark = false;\n\tpool = add_pool();\n\topt_benchmark = true;\n\t\n\tpool->rpc_url = malloc(255);\n\tstrcpy(pool->rpc_url, \"Benchmark\");\n\tpool_set_uri(pool, pool->rpc_url);\n\tpool->rpc_user = pool->rpc_url;\n\tpool->rpc_pass = pool->rpc_url;\n\tenable_pool(pool);\n\tpool->idle = false;\n\tsuccessful_connect = true;\n\t\n\t{\n\t\tuint32_t * const blkhdr = benchmark_blkhdr;\n\t\tblkhdr[2] = htobe32(1);\n\t\tblkhdr[17] = htobe32(0x7fffffff);  // timestamp\n\t\tblkhdr[18] = htobe32(0x1700ffff);  // \"bits\"\n\t}\n\t\n\t{\n\t\tstruct stratum_work * const swork = &pool->swork;\n\t\tconst int branchcount = 15;  // 1 MB block\n\t\tconst size_t branchdatasz = branchcount * 0x20;\n\t\tconst size_t coinbase_sz = (opt_benchmark_intense ? 250 : 6) * 1024;\n\t\t\n\t\tbytes_resize(&swork->coinbase, coinbase_sz);\n\t\tmemset(bytes_buf(&swork->coinbase), '\\xff', coinbase_sz);\n\t\tswork->nonce2_offset = 0;\n\t\t\n\t\tbytes_resize(&swork->merkle_bin, branchdatasz);\n\t\tmemset(bytes_buf(&swork->merkle_bin), '\\xff', branchdatasz);\n\t\tswork->merkles = branchcount;\n\t\t\n\t\tswork->header1[0] = '\\xff';\n\t\tmemset(&swork->header1[1], '\\0', 34);\n\t\tswork->header1[35] = '\\x01';\n\t\tswork->ntime = 0x7fffffff;\n\t\ttimer_unset(&swork->tv_received);\n\t\tmemcpy(swork->diffbits, \"\\x17\\0\\xff\\xff\", 4);\n\t\tconst struct mining_goal_info * const goal = get_mining_goal(\"default\");\n\t\tconst struct mining_algorithm * const malgo = goal->malgo;\n\t\tset_target_to_pdiff(swork->target, malgo->reasonable_low_nonce_diff);\n\t\tpool->nonce2sz = swork->n2size = GBT_XNONCESZ;\n\t\tpool->nonce2 = 0;\n\t}\n\t\n\tif (opt_benchmark_intense)\n\t{\n\t\tpthread_t pth;\n\t\tif (unlikely(pthread_create(&pth, NULL, benchmark_intense_work_update_thread, pool)))\n\t\t\tapplog(LOG_WARNING, \"Failed to start benchmark intense work update thread\");\n\t}\n}\n\nvoid get_benchmark_work(struct work *work, bool use_swork)\n{\n\tif (use_swork)\n\t{\n\t\tstruct timeval tv_now;\n\t\ttimer_set_now(&tv_now);\n\t\tgen_stratum_work(pools[0], work);\n\t\twork->getwork_mode = GETWORK_MODE_BENCHMARK;\n\t\twork_set_simple_ntime_roll_limit(work, 0, &tv_now);\n\t\treturn;\n\t}\n\t\n\tstruct pool * const pool = pools[0];\n\tuint32_t * const blkhdr = benchmark_blkhdr;\n\tfor (int i = 16; i >= 0; --i)\n\t\tif (++blkhdr[i])\n\t\t\tbreak;\n\t\n\tmemcpy(&work->data[ 0], blkhdr, 80);\n\tmemcpy(&work->data[80], workpadding_bin, 48);\n\tchar hex[161];\n\tbin2hex(hex, work->data, 80);\n\tapplog(LOG_DEBUG, \"Generated benchmark header %s\", hex);\n\tcalc_midstate(work);\n\tmemcpy(work->target, pool->swork.target, sizeof(work->target));\n\t\n\twork->mandatory = true;\n\twork->pool = pools[0];\n\tcgtime(&work->tv_getwork);\n\tcopy_time(&work->tv_getwork_reply, &work->tv_getwork);\n\tcopy_time(&work->tv_staged, &work->tv_getwork);\n\twork->getwork_mode = GETWORK_MODE_BENCHMARK;\n\tcalc_diff(work, 0);\n\twork_set_simple_ntime_roll_limit(work, 60, &work->tv_getwork);\n}\n\nstatic void wake_gws(void);\n\nstatic void update_last_work(struct work *work)\n{\n\tif (!work->tr)\n\t\t// Only save GBT jobs, since rollntime isn't coordinated well yet\n\t\treturn;\n\n\tstruct pool *pool = work->pool;\n\tmutex_lock(&pool->last_work_lock);\n\tif (pool->last_work_copy)\n\t\tfree_work(pool->last_work_copy);\n\tpool->last_work_copy = copy_work(work);\n\tpool->last_work_copy->work_restart_id = pool->work_restart_id;\n\tmutex_unlock(&pool->last_work_lock);\n}\n\nstatic\nvoid gbt_req_target(json_t *req)\n{\n\tjson_t *j;\n\tjson_t *n;\n\t\n\tif (!request_target_str)\n\t\treturn;\n\t\n\tj = json_object_get(req, \"params\");\n\tif (!j)\n\t{\n\t\tn = json_array();\n\t\tif (!n)\n\t\t\treturn;\n\t\tif (json_object_set_new(req, \"params\", n))\n\t\t\tgoto erradd;\n\t\tj = n;\n\t}\n\t\n\tn = json_array_get(j, 0);\n\tif (!n)\n\t{\n\t\tn = json_object();\n\t\tif (!n)\n\t\t\treturn;\n\t\tif (json_array_append_new(j, n))\n\t\t\tgoto erradd;\n\t}\n\tj = n;\n\t\n\tn = json_string(request_target_str);\n\tif (!n)\n\t\treturn;\n\tif (json_object_set_new(j, \"target\", n))\n\t\tgoto erradd;\n\t\n\treturn;\n\nerradd:\n\tjson_decref(n);\n}\n\nstatic char *prepare_rpc_req2(struct work *work, enum pool_protocol proto, const char *lpid, bool probe, struct pool * const pool)\n{\n\tchar *rpc_req;\n\n\tclean_work(work);\n\tswitch (proto) {\n\t\tcase PLP_GETWORK:\n\t\t\twork->getwork_mode = GETWORK_MODE_POOL;\n\t\t\treturn strdup(getwork_req);\n\t\tcase PLP_GETBLOCKTEMPLATE:\n\t\t\twork->getwork_mode = GETWORK_MODE_GBT;\n\t\t\tblktemplate_t * const tmpl = blktmpl_create();\n\t\t\tif (!tmpl)\n\t\t\t\tgoto gbtfail2;\n\t\t\twork->tr = tmpl_makeref(tmpl);\n\t\t\tgbt_capabilities_t caps = blktmpl_addcaps(tmpl);\n\t\t\tif (!caps)\n\t\t\t\tgoto gbtfail;\n\t\t\tcaps |= GBT_LONGPOLL;\n#if BLKMAKER_VERSION > 1\n\t\t\tconst struct mining_goal_info * const goal = pool->goal;\n\t\t\tif (goal->generation_script || goal_has_at_least_one_getcbaddr(goal))\n\t\t\t\tcaps |= GBT_CBVALUE;\n#endif\n\t\t\tjson_t *req = blktmpl_request_jansson(caps, lpid);\n\t\t\tif (!req)\n\t\t\t\tgoto gbtfail;\n\t\t\t\n\t\t\tif (probe)\n\t\t\t\tgbt_req_target(req);\n\t\t\t\n\t\t\trpc_req = json_dumps(req, 0);\n\t\t\tif (!rpc_req)\n\t\t\t\tgoto gbtfail;\n\t\t\tjson_decref(req);\n\t\t\treturn rpc_req;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n\ngbtfail:\n\ttmpl_decref(work->tr);\n\twork->tr = NULL;\ngbtfail2:\n\treturn NULL;\n}\n\n#define prepare_rpc_req(work, proto, lpid, pool)  prepare_rpc_req2(work, proto, lpid, false, pool)\n#define prepare_rpc_req_probe(work, proto, lpid, pool)  prepare_rpc_req2(work, proto, lpid, true, pool)\n\nstatic const char *pool_protocol_name(enum pool_protocol proto)\n{\n\tswitch (proto) {\n\t\tcase PLP_GETBLOCKTEMPLATE:\n\t\t\treturn \"getblocktemplate\";\n\t\tcase PLP_GETWORK:\n\t\t\treturn \"getwork\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic enum pool_protocol pool_protocol_fallback(enum pool_protocol proto)\n{\n\tswitch (proto) {\n\t\tcase PLP_GETBLOCKTEMPLATE:\n\t\t\tif (want_getwork)\n\t\t\treturn PLP_GETWORK;\n\t\tdefault:\n\t\t\treturn PLP_NONE;\n\t}\n}\n\nstatic bool get_upstream_work(struct work *work, CURL *curl)\n{\n\tstruct pool *pool = work->pool;\n\tstruct cgminer_pool_stats *pool_stats = &(pool->cgminer_pool_stats);\n\tstruct timeval tv_elapsed;\n\tjson_t *val = NULL;\n\tbool rc = false;\n\tchar *url;\n\tenum pool_protocol proto;\n\n\tchar *rpc_req;\n\n\tif (pool->proto == PLP_NONE)\n\t\tpool->proto = PLP_GETBLOCKTEMPLATE;\n\ntryagain:\n\trpc_req = prepare_rpc_req(work, pool->proto, NULL, pool);\n\twork->pool = pool;\n\tif (!rpc_req)\n\t\treturn false;\n\n\tapplog(LOG_DEBUG, \"DBG: sending %s get RPC call: %s\", pool->rpc_url, rpc_req);\n\n\turl = pool->rpc_url;\n\n\tcgtime(&work->tv_getwork);\n\n\tval = json_rpc_call(curl, url, pool->rpc_userpass, rpc_req, false,\n\t\t\t    false, &work->rolltime, pool, false);\n\tpool_stats->getwork_attempts++;\n\n\tfree(rpc_req);\n\n\tif (likely(val)) {\n\t\trc = work_decode(pool, work, val);\n\t\tif (unlikely(!rc))\n\t\t\tapplog(LOG_DEBUG, \"Failed to decode work in get_upstream_work\");\n\t} else if (PLP_NONE != (proto = pool_protocol_fallback(pool->proto))) {\n\t\tapplog(LOG_WARNING, \"Pool %u failed getblocktemplate request; falling back to getwork protocol\", pool->pool_no);\n\t\tpool->proto = proto;\n\t\tgoto tryagain;\n\t} else\n\t\tapplog(LOG_DEBUG, \"Failed json_rpc_call in get_upstream_work\");\n\n\tcgtime(&work->tv_getwork_reply);\n\ttimersub(&(work->tv_getwork_reply), &(work->tv_getwork), &tv_elapsed);\n\tpool_stats->getwork_wait_rolling += ((double)tv_elapsed.tv_sec + ((double)tv_elapsed.tv_usec / 1000000)) * 0.63;\n\tpool_stats->getwork_wait_rolling /= 1.63;\n\n\ttimeradd(&tv_elapsed, &(pool_stats->getwork_wait), &(pool_stats->getwork_wait));\n\tif (timercmp(&tv_elapsed, &(pool_stats->getwork_wait_max), >)) {\n\t\tpool_stats->getwork_wait_max.tv_sec = tv_elapsed.tv_sec;\n\t\tpool_stats->getwork_wait_max.tv_usec = tv_elapsed.tv_usec;\n\t}\n\tif (timercmp(&tv_elapsed, &(pool_stats->getwork_wait_min), <)) {\n\t\tpool_stats->getwork_wait_min.tv_sec = tv_elapsed.tv_sec;\n\t\tpool_stats->getwork_wait_min.tv_usec = tv_elapsed.tv_usec;\n\t}\n\tpool_stats->getwork_calls++;\n\n\twork->pool = pool;\n\twork->longpoll = false;\n\tcalc_diff(work, 0);\n\ttotal_getworks++;\n\tpool->getwork_requested++;\n\n\tif (rc)\n\t\tupdate_last_work(work);\n\n\tif (likely(val))\n\t\tjson_decref(val);\n\n\treturn rc;\n}\n\n#ifdef HAVE_CURSES\nstatic void disable_curses(void)\n{\n\tif (curses_active_locked()) {\n\t\tuse_curses = false;\n\t\tcurses_active = false;\n\t\tleaveok(logwin, false);\n\t\tleaveok(statuswin, false);\n\t\tleaveok(mainwin, false);\n\t\tnocbreak();\n\t\techo();\n\t\tdelwin(logwin);\n\t\tdelwin(statuswin);\n\t\tdelwin(mainwin);\n\t\tendwin();\n#ifdef WIN32\n\t\t// Move the cursor to after curses output.\n\t\tHANDLE hout = GetStdHandle(STD_OUTPUT_HANDLE);\n\t\tCONSOLE_SCREEN_BUFFER_INFO csbi;\n\t\tCOORD coord;\n\n\t\tif (GetConsoleScreenBufferInfo(hout, &csbi)) {\n\t\t\tcoord.X = 0;\n\t\t\tcoord.Y = csbi.dwSize.Y - 1;\n\t\t\tSetConsoleCursorPosition(hout, coord);\n\t\t}\n#endif\n\t\tunlock_curses();\n\t}\n}\n#endif\n\nstatic void __kill_work(void)\n{\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\tint i;\n\n\tif (!successful_connect)\n\t\treturn;\n\n\tapplog(LOG_INFO, \"Received kill message\");\n\n\tshutting_down = true;\n\n\tapplog(LOG_DEBUG, \"Prompting submit_work thread to finish\");\n\tnotifier_wake(submit_waiting_notifier);\n\n#ifdef USE_LIBMICROHTTPD\n\thttpsrv_stop();\n#endif\n\t\n\tapplog(LOG_DEBUG, \"Killing off watchpool thread\");\n\t/* Kill the watchpool thread */\n\tthr = &control_thr[watchpool_thr_id];\n\tthr_info_cancel(thr);\n\n\tapplog(LOG_DEBUG, \"Killing off watchdog thread\");\n\t/* Kill the watchdog thread */\n\tthr = &control_thr[watchdog_thr_id];\n\tthr_info_cancel(thr);\n\n\tapplog(LOG_DEBUG, \"Shutting down mining threads\");\n\tfor (i = 0; i < mining_threads; i++) {\n\t\tthr = get_thread(i);\n\t\tif (!thr)\n\t\t\tcontinue;\n\t\tcgpu = thr->cgpu;\n\t\tif (!cgpu)\n\t\t\tcontinue;\n\t\tif (!cgpu->threads)\n\t\t\tcontinue;\n\n\t\tcgpu->shutdown = true;\n\t\tthr->work_restart = true;\n\t\tnotifier_wake(thr->notifier);\n\t\tnotifier_wake(thr->work_restart_notifier);\n\t}\n\n\tsleep(1);\n\n\tapplog(LOG_DEBUG, \"Killing off mining threads\");\n\t/* Kill the mining threads*/\n\tfor (i = 0; i < mining_threads; i++) {\n\t\tthr = get_thread(i);\n\t\tif (!thr)\n\t\t\tcontinue;\n\t\tcgpu = thr->cgpu;\n\t\tif (cgpu->threads)\n\t\t{\n\t\t\tapplog(LOG_WARNING, \"Killing %\"PRIpreprv, thr->cgpu->proc_repr);\n\t\t\tthr_info_cancel(thr);\n\t\t}\n\t\tcgpu->status = LIFE_DEAD2;\n\t}\n\n\t/* Stop the others */\n\tapplog(LOG_DEBUG, \"Killing off API thread\");\n\tthr = &control_thr[api_thr_id];\n\tthr_info_cancel(thr);\n}\n\n/* This should be the common exit path */\nvoid kill_work(void)\n{\n\t__kill_work();\n\n\tquit(0, \"Shutdown signal received.\");\n}\n\nstatic\n#ifdef WIN32\n#ifndef _WIN64\nconst\n#endif\n#endif\nchar **initial_args;\n\nvoid _bfg_clean_up(bool);\n\nvoid app_restart(void)\n{\n\tapplog(LOG_WARNING, \"Attempting to restart %s\", packagename);\n\n\t__kill_work();\n\t_bfg_clean_up(true);\n\n#if defined(unix) || defined(__APPLE__)\n\tif (forkpid > 0) {\n\t\tkill(forkpid, SIGTERM);\n\t\tforkpid = 0;\n\t}\n#endif\n\n\texecv(initial_args[0], initial_args);\n\tapplog(LOG_WARNING, \"Failed to restart application\");\n}\n\nstatic void sighandler(int __maybe_unused sig)\n{\n\t/* Restore signal handlers so we can still quit if kill_work fails */\n\tsigaction(SIGTERM, &termhandler, NULL);\n\tsigaction(SIGINT, &inthandler, NULL);\n\tkill_work();\n}\n\nstatic void start_longpoll(void);\nstatic void stop_longpoll(void);\n\n/* Called with pool_lock held. Recruit an extra curl if none are available for\n * this pool. */\nstatic void recruit_curl(struct pool *pool)\n{\n\tstruct curl_ent *ce = calloc(sizeof(struct curl_ent), 1);\n\n\tif (unlikely(!ce))\n\t\tquit(1, \"Failed to calloc in recruit_curl\");\n\n\tce->curl = curl_easy_init();\n\tif (unlikely(!ce->curl))\n\t\tquit(1, \"Failed to init in recruit_curl\");\n\n\tLL_PREPEND(pool->curllist, ce);\n\tpool->curls++;\n}\n\n/* Grab an available curl if there is one. If not, then recruit extra curls\n * unless we are in a submit_fail situation, or we have opt_delaynet enabled\n * and there are already 5 curls in circulation. Limit total number to the\n * number of mining threads per pool as well to prevent blasting a pool during\n * network delays/outages. */\nstatic struct curl_ent *pop_curl_entry3(struct pool *pool, int blocking)\n{\n\tint curl_limit = opt_delaynet ? 5 : (mining_threads + opt_queue) * 2;\n\tbool recruited = false;\n\tstruct curl_ent *ce;\n\n\tmutex_lock(&pool->pool_lock);\nretry:\n\tif (!pool->curls) {\n\t\trecruit_curl(pool);\n\t\trecruited = true;\n\t} else if (!pool->curllist) {\n\t\tif (blocking < 2 && pool->curls >= curl_limit && (blocking || pool->curls >= opt_submit_threads)) {\n\t\t\tif (!blocking) {\n\t\t\t\tmutex_unlock(&pool->pool_lock);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpthread_cond_wait(&pool->cr_cond, &pool->pool_lock);\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\trecruit_curl(pool);\n\t\t\trecruited = true;\n\t\t}\n\t}\n\tce = pool->curllist;\n\tLL_DELETE(pool->curllist, ce);\n\tmutex_unlock(&pool->pool_lock);\n\n\tif (recruited)\n\t\tapplog(LOG_DEBUG, \"Recruited curl for pool %d\", pool->pool_no);\n\treturn ce;\n}\n\nstatic struct curl_ent *pop_curl_entry2(struct pool *pool, bool blocking)\n{\n\treturn pop_curl_entry3(pool, blocking ? 1 : 0);\n}\n\n__maybe_unused\nstatic struct curl_ent *pop_curl_entry(struct pool *pool)\n{\n\treturn pop_curl_entry3(pool, 1);\n}\n\nstatic void push_curl_entry(struct curl_ent *ce, struct pool *pool)\n{\n\tmutex_lock(&pool->pool_lock);\n\tif (!ce || !ce->curl)\n\t\tquithere(1, \"Attempted to add NULL\");\n\tLL_PREPEND(pool->curllist, ce);\n\tcgtime(&ce->tv);\n\tpthread_cond_broadcast(&pool->cr_cond);\n\tmutex_unlock(&pool->pool_lock);\n}\n\nstatic inline bool should_roll(struct work *work)\n{\n\tstruct timeval now;\n\ttime_t expiry;\n\n\tif (!pool_actively_in_use(work->pool, NULL))\n\t\treturn false;\n\n\tif (stale_work(work, false))\n\t\treturn false;\n\n\tif (work->rolltime > opt_scantime)\n\t\texpiry = work->rolltime;\n\telse\n\t\texpiry = opt_scantime;\n\texpiry = expiry * 2 / 3;\n\n\t/* We shouldn't roll if we're unlikely to get one shares' duration\n\t * work out of doing so */\n\tcgtime(&now);\n\tif (now.tv_sec - work->tv_staged.tv_sec > expiry)\n\t\treturn false;\n\t\n\treturn true;\n}\n\n/* Limit rolls to 7000 to not beyond 2 hours in the future where bitcoind will\n * reject blocks as invalid. */\nstatic inline bool can_roll(struct work *work)\n{\n\tif (work->stratum)\n\t\treturn false;\n\tif (!(work->pool && !work->clone))\n\t\treturn false;\n\tif (work->tr)\n\t{\n\t\tif (stale_work(work, false))\n\t\t\treturn false;\n\t\treturn blkmk_work_left(work->tr->tmpl);\n\t}\n\treturn (work->rolltime &&\n\t\twork->rolls < 7000 && !stale_work(work, false));\n}\n\nstatic void roll_work(struct work *work)\n{\n\tif (work->tr)\n\t{\n\t\tstruct timeval tv_now;\n\t\tcgtime(&tv_now);\n\t\tif (blkmk_get_data(work->tr->tmpl, work->data, 80, tv_now.tv_sec, NULL, &work->dataid) < 76)\n\t\t\tapplog(LOG_ERR, \"Failed to get next data from template; spinning wheels!\");\n\t\tswap32yes(work->data, work->data, 80 / 4);\n\t\tcalc_midstate(work);\n\t\tapplog(LOG_DEBUG, \"Successfully rolled extranonce to dataid %u\", work->dataid);\n\t} else {\n\n\tuint32_t *work_ntime;\n\tuint32_t ntime;\n\n\twork_ntime = (uint32_t *)(work->data + 68);\n\tntime = be32toh(*work_ntime);\n\tntime++;\n\t*work_ntime = htobe32(ntime);\n\t\twork_set_simple_ntime_roll_limit(work, 0, &work->ntime_roll_limits.tv_ref);\n\n\t\tapplog(LOG_DEBUG, \"Successfully rolled time header in work\");\n\t}\n\n\tlocal_work++;\n\twork->rolls++;\n\twork->blk.nonce = 0;\n\n\t/* This is now a different work item so it needs a different ID for the\n\t * hashtable */\n\twork->id = total_work++;\n}\n\n/* Duplicates any dynamically allocated arrays within the work struct to\n * prevent a copied work struct from freeing ram belonging to another struct */\nstatic void _copy_work(struct work *work, const struct work *base_work, int noffset)\n{\n\tint id = work->id;\n\n\tclean_work(work);\n\tmemcpy(work, base_work, sizeof(struct work));\n\t/* Keep the unique new id assigned during make_work to prevent copied\n\t * work from having the same id. */\n\twork->id = id;\n\tif (base_work->job_id)\n\t\twork->job_id = strdup(base_work->job_id);\n\tif (base_work->nonce1)\n\t\twork->nonce1 = strdup(base_work->nonce1);\n\tbytes_cpy(&work->nonce2, &base_work->nonce2);\n\n\tif (base_work->tr)\n\t\ttmpl_incref(base_work->tr);\n\t\n\tif (noffset)\n\t{\n\t\tuint32_t *work_ntime = (uint32_t *)(work->data + 68);\n\t\tuint32_t ntime = be32toh(*work_ntime);\n\n\t\tntime += noffset;\n\t\t*work_ntime = htobe32(ntime);\n\t}\n\t\n\tif (work->device_data_dup_func)\n\t\twork->device_data = work->device_data_dup_func(work);\n}\n\n/* Generates a copy of an existing work struct, creating fresh heap allocations\n * for all dynamically allocated arrays within the struct. noffset is used for\n * when a driver has internally rolled the ntime, noffset is a relative value.\n * The macro copy_work() calls this function with an noffset of 0. */\nstruct work *copy_work_noffset(const struct work *base_work, int noffset)\n{\n\tstruct work *work = make_work();\n\n\t_copy_work(work, base_work, noffset);\n\n\treturn work;\n}\n\nvoid __copy_work(struct work *work, const struct work *base_work)\n{\n\t_copy_work(work, base_work, 0);\n}\n\nstatic struct work *make_clone(struct work *work)\n{\n\tstruct work *work_clone = copy_work(work);\n\n\twork_clone->clone = true;\n\tcgtime((struct timeval *)&(work_clone->tv_cloned));\n\twork_clone->longpoll = false;\n\twork_clone->mandatory = false;\n\t/* Make cloned work appear slightly older to bias towards keeping the\n\t * master work item which can be further rolled */\n\twork_clone->tv_staged.tv_sec -= 1;\n\n\treturn work_clone;\n}\n\nstatic void stage_work(struct work *work);\n\nstatic bool clone_available(void)\n{\n\tstruct work *work_clone = NULL, *work, *tmp;\n\tbool cloned = false;\n\n\tmutex_lock(stgd_lock);\n\tif (!staged_rollable)\n\t\tgoto out_unlock;\n\n\tHASH_ITER(hh, staged_work, work, tmp) {\n\t\tif (can_roll(work) && should_roll(work)) {\n\t\t\troll_work(work);\n\t\t\twork_clone = make_clone(work);\n\t\t\tapplog(LOG_DEBUG, \"%s: Rolling work %d to %d\", __func__, work->id, work_clone->id);\n\t\t\troll_work(work);\n\t\t\tcloned = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_unlock:\n\tmutex_unlock(stgd_lock);\n\n\tif (cloned) {\n\t\tapplog(LOG_DEBUG, \"Pushing cloned available work to stage thread\");\n\t\tstage_work(work_clone);\n\t}\n\treturn cloned;\n}\n\nstatic void pool_died(struct pool *pool)\n{\n\tmutex_lock(&lp_lock);\n\tif (!pool_tset(pool, &pool->idle)) {\n\t\tcgtime(&pool->tv_idle);\n\t\tpthread_cond_broadcast(&lp_cond);\n\t\tmutex_unlock(&lp_lock);\n\t\tif (pool == current_pool()) {\n\t\t\tapplog(LOG_WARNING, \"Pool %d %s not responding!\", pool->pool_no, pool->rpc_url);\n\t\t\tswitch_pools(NULL);\n\t\t} else\n\t\t\tapplog(LOG_INFO, \"Pool %d %s failed to return work\", pool->pool_no, pool->rpc_url);\n\t}\n\telse\n\t\tmutex_unlock(&lp_lock);\n}\n\nbool stale_work2(struct work * const work, const bool share, const bool have_pool_data_lock)\n{\n\tunsigned work_expiry;\n\tstruct pool *pool;\n\tuint32_t block_id;\n\tunsigned getwork_delay;\n\n\tblock_id = ((uint32_t*)work->data)[1];\n\tpool = work->pool;\n\tstruct mining_goal_info * const goal = pool->goal;\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\n\t/* Technically the rolltime should be correct but some pools\n\t * advertise a broken expire= that is lower than a meaningful\n\t * scantime */\n\tif (work->rolltime >= opt_scantime || work->tr)\n\t\twork_expiry = work->rolltime;\n\telse\n\t\twork_expiry = opt_expiry;\n\n\tunsigned max_expiry = (goal->have_longpoll ? opt_expiry_lp : opt_expiry);\n\tif (work_expiry > max_expiry)\n\t\twork_expiry = max_expiry;\n\n\tif (share) {\n\t\t/* If the share isn't on this pool's latest block, it's stale */\n\t\tif (pool->block_id && pool->block_id != block_id)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Share stale due to block mismatch (%08lx != %08lx)\", (long)block_id, (long)pool->block_id);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* If the pool doesn't want old shares, then any found in work before\n\t\t * the most recent longpoll is stale */\n\t\tif ((!pool->submit_old) && work->work_restart_id != pool->work_restart_id)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Share stale due to mandatory work update (%02x != %02x)\", work->work_restart_id, pool->work_restart_id);\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/* If this work isn't for the latest Bitcoin block, it's stale */\n\t\t/* But only care about the current pool if failover-only */\n\t\tif (enabled_pools <= 1 || opt_fail_only) {\n\t\t\tif (pool->block_id && block_id != pool->block_id)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Work stale due to block mismatch (%08lx != 1 ? %08lx : %08lx)\", (long)block_id, (long)pool->block_id, (long)blkchain->currentblk->block_id);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (block_id != blkchain->currentblk->block_id)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Work stale due to block mismatch (%08lx != 0 ? %08lx : %08lx)\", (long)block_id, (long)pool->block_id, (long)blkchain->currentblk->block_id);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* If the pool has asked us to restart since this work, it's stale */\n\t\tif (work->work_restart_id != pool->work_restart_id)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Work stale due to work update (%02x != %02x)\", work->work_restart_id, pool->work_restart_id);\n\t\t\treturn true;\n\t\t}\n\n\tif (pool->has_stratum && work->job_id) {\n\t\tbool same_job;\n\n\t\tif (!pool->stratum_active || !pool->stratum_notify) {\n\t\t\tapplog(LOG_DEBUG, \"Work stale due to stratum inactive\");\n\t\t\treturn true;\n\t\t}\n\n\t\tsame_job = true;\n\n\t\tif (!have_pool_data_lock) {\n\t\t\tcg_rlock(&pool->data_lock);\n\t\t}\n\t\tif (strcmp(work->job_id, pool->swork.job_id))\n\t\t\tsame_job = false;\n\t\tif (!have_pool_data_lock) {\n\t\t\tcg_runlock(&pool->data_lock);\n\t\t}\n\n\t\tif (!same_job) {\n\t\t\tapplog(LOG_DEBUG, \"Work stale due to stratum job_id mismatch\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Factor in the average getwork delay of this pool, rounding it up to\n\t * the nearest second */\n\tgetwork_delay = pool->cgminer_pool_stats.getwork_wait_rolling * 5 + 1;\n\tif (unlikely(work_expiry <= getwork_delay + 5))\n\t\twork_expiry = 5;\n\telse\n\t\twork_expiry -= getwork_delay;\n\n\t}\n\n\tint elapsed_since_staged = timer_elapsed(&work->tv_staged, NULL);\n\tif (elapsed_since_staged > work_expiry) {\n\t\tapplog(LOG_DEBUG, \"%s stale due to expiry (%d >= %u)\", share?\"Share\":\"Work\", elapsed_since_staged, work_expiry);\n\t\treturn true;\n\t}\n\n\t/* If the user only wants strict failover, any work from a pool other than\n\t * the current one is always considered stale */\n\tif (opt_fail_only && !share && !work->mandatory && !pool_actively_in_use(pool, NULL))\n\t{\n\t\tapplog(LOG_DEBUG, \"Work stale due to fail only pool mismatch (pool %u vs %u)\", pool->pool_no, current_pool()->pool_no);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\ndouble share_diff(const struct work *work)\n{\n\tdouble ret;\n\tbool new_best = false;\n\n\tret = target_diff(work->hash);\n\n\tcg_wlock(&control_lock);\n\tif (unlikely(ret > best_diff)) {\n\t\tnew_best = true;\n\t\tbest_diff = ret;\n\t\tsuffix_string(best_diff, best_share, sizeof(best_share), 0);\n\t}\n\tif (unlikely(ret > work->pool->best_diff))\n\t\twork->pool->best_diff = ret;\n\tcg_wunlock(&control_lock);\n\n\tif (unlikely(new_best))\n\t\tapplog(LOG_INFO, \"New best share: %s\", best_share);\n\n\treturn ret;\n}\n\nstatic\nvoid work_check_for_block(struct work * const work)\n{\n\tstruct pool * const pool = work->pool;\n\tstruct mining_goal_info * const goal = pool->goal;\n\t\n\twork->share_diff = share_diff(work);\n\tif (unlikely(work->share_diff >= goal->current_diff)) {\n\t\twork->block = true;\n\t\twork->pool->solved++;\n\t\tfound_blocks++;\n\t\twork->mandatory = true;\n\t\tapplog(LOG_NOTICE, \"Found block for pool %d!\", work->pool->pool_no);\n\t}\n}\n\nstatic void submit_discard_share2(const char *reason, struct work *work)\n{\n\tstruct cgpu_info *cgpu = get_thr_cgpu(work->thr_id);\n\n\tsharelog(reason, work);\n\n\tmutex_lock(&stats_lock);\n\t++total_stale;\n\t++cgpu->stale;\n\t++(work->pool->stale_shares);\n\ttotal_diff_stale += work->work_difficulty;\n\tcgpu->diff_stale += work->work_difficulty;\n\twork->pool->diff_stale += work->work_difficulty;\n\tmutex_unlock(&stats_lock);\n}\n\nstatic void submit_discard_share(struct work *work)\n{\n\tsubmit_discard_share2(\"discard\", work);\n}\n\nstruct submit_work_state {\n\tstruct work *work;\n\tbool resubmit;\n\tstruct curl_ent *ce;\n\tint failures;\n\tstruct timeval tv_staleexpire;\n\tchar *s;\n\tstruct timeval tv_submit;\n\tstruct submit_work_state *next;\n};\n\nstatic int my_curl_timer_set(__maybe_unused CURLM *curlm, long timeout_ms, void *userp)\n{\n\tlong *p_timeout_us = userp;\n\t\n\tconst long max_ms = LONG_MAX / 1000;\n\tif (max_ms < timeout_ms)\n\t\ttimeout_ms = max_ms;\n\t\n\t*p_timeout_us = timeout_ms * 1000;\n\treturn 0;\n}\n\nstatic void sws_has_ce(struct submit_work_state *sws)\n{\n\tstruct pool *pool = sws->work->pool;\n\tsws->s = submit_upstream_work_request(sws->work);\n\tcgtime(&sws->tv_submit);\n\tjson_rpc_call_async(sws->ce->curl, pool->rpc_url, pool->rpc_userpass, sws->s, false, pool, true, sws);\n}\n\nstatic struct submit_work_state *begin_submission(struct work *work)\n{\n\tstruct pool *pool;\n\tstruct submit_work_state *sws = NULL;\n\n\tpool = work->pool;\n\tsws = malloc(sizeof(*sws));\n\t*sws = (struct submit_work_state){\n\t\t.work = work,\n\t};\n\n\twork_check_for_block(work);\n\n\tif (stale_work(work, true)) {\n\t\twork->stale = true;\n\t\tif (opt_submit_stale)\n\t\t\tapplog(LOG_NOTICE, \"Pool %d stale share detected, submitting as user requested\", pool->pool_no);\n\t\telse if (pool->submit_old)\n\t\t\tapplog(LOG_NOTICE, \"Pool %d stale share detected, submitting as pool requested\", pool->pool_no);\n\t\telse {\n\t\t\tapplog(LOG_NOTICE, \"Pool %d stale share detected, discarding\", pool->pool_no);\n\t\t\tsubmit_discard_share(work);\n\t\t\tgoto out;\n\t\t}\n\t\ttimer_set_delay_from_now(&sws->tv_staleexpire, 300000000);\n\t}\n\n\tif (work->getwork_mode == GETWORK_MODE_STRATUM) {\n\t\tchar *s;\n\n\t\ts = malloc(1024);\n\n\t\tsws->s = s;\n\t} else {\n\t\t/* submit solution to bitcoin via JSON-RPC */\n\t\tsws->ce = pop_curl_entry2(pool, false);\n\t\tif (sws->ce) {\n\t\t\tsws_has_ce(sws);\n\t\t} else {\n\t\t\tsws->next = pool->sws_waiting_on_curl;\n\t\t\tpool->sws_waiting_on_curl = sws;\n\t\t\tif (sws->next)\n\t\t\t\tapplog(LOG_DEBUG, \"submit_thread queuing submission\");\n\t\t\telse\n\t\t\t\tapplog(LOG_WARNING, \"submit_thread queuing submissions (see --submit-threads)\");\n\t\t}\n\t}\n\n\treturn sws;\n\nout:\n\tfree(sws);\n\treturn NULL;\n}\n\nstatic bool retry_submission(struct submit_work_state *sws)\n{\n\tstruct work *work = sws->work;\n\tstruct pool *pool = work->pool;\n\n\t\tsws->resubmit = true;\n\t\tif ((!work->stale) && stale_work(work, true)) {\n\t\t\twork->stale = true;\n\t\t\tif (opt_submit_stale)\n\t\t\t\tapplog(LOG_NOTICE, \"Pool %d share became stale during submission failure, will retry as user requested\", pool->pool_no);\n\t\t\telse if (pool->submit_old)\n\t\t\t\tapplog(LOG_NOTICE, \"Pool %d share became stale during submission failure, will retry as pool requested\", pool->pool_no);\n\t\t\telse {\n\t\t\t\tapplog(LOG_NOTICE, \"Pool %d share became stale during submission failure, discarding\", pool->pool_no);\n\t\t\t\tsubmit_discard_share(work);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttimer_set_delay_from_now(&sws->tv_staleexpire, 300000000);\n\t\t}\n\t\tif (unlikely((opt_retries >= 0) && (++sws->failures > opt_retries))) {\n\t\t\tapplog(LOG_ERR, \"Pool %d failed %d submission retries, discarding\", pool->pool_no, opt_retries);\n\t\t\tsubmit_discard_share(work);\n\t\t\treturn false;\n\t\t}\n\t\telse if (work->stale) {\n\t\t\tif (unlikely(opt_retries < 0 && timer_passed(&sws->tv_staleexpire, NULL)))\n\t\t\t{\n\t\t\t\tapplog(LOG_NOTICE, \"Pool %d stale share failed to submit for 5 minutes, discarding\", pool->pool_no);\n\t\t\t\tsubmit_discard_share(work);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* pause, then restart work-request loop */\n\t\tapplog(LOG_INFO, \"json_rpc_call failed on submit_work, retrying\");\n\n\t\tcgtime(&sws->tv_submit);\n\t\tjson_rpc_call_async(sws->ce->curl, pool->rpc_url, pool->rpc_userpass, sws->s, false, pool, true, sws);\n\t\n\treturn true;\n}\n\nstatic void free_sws(struct submit_work_state *sws)\n{\n\tfree(sws->s);\n\tfree_work(sws->work);\n\tfree(sws);\n}\n\nstatic void *submit_work_thread(__maybe_unused void *userdata)\n{\n\tint wip = 0;\n\tCURLM *curlm;\n\tlong curlm_timeout_us = -1;\n\tstruct timeval curlm_timer;\n\tstruct submit_work_state *sws, **swsp;\n\tstruct submit_work_state *write_sws = NULL;\n\tunsigned tsreduce = 0;\n\n\tpthread_detach(pthread_self());\n\n\tRenameThread(\"submit_work\");\n\n\tapplog(LOG_DEBUG, \"Creating extra submit work thread\");\n\n\tcurlm = curl_multi_init();\n\tcurlm_timeout_us = -1;\n\tcurl_multi_setopt(curlm, CURLMOPT_TIMERDATA, &curlm_timeout_us);\n\tcurl_multi_setopt(curlm, CURLMOPT_TIMERFUNCTION, my_curl_timer_set);\n\n\tfd_set rfds, wfds, efds;\n\tint maxfd;\n\tstruct timeval tv_timeout, tv_now;\n\tint n;\n\tCURLMsg *cm;\n\tFD_ZERO(&rfds);\n\twhile (1) {\n\t\tmutex_lock(&submitting_lock);\n\t\ttotal_submitting -= tsreduce;\n\t\ttsreduce = 0;\n\t\tif (FD_ISSET(submit_waiting_notifier[0], &rfds)) {\n\t\t\tnotifier_read(submit_waiting_notifier);\n\t\t}\n\t\t\n\t\t// Receive any new submissions\n\t\twhile (submit_waiting) {\n\t\t\tstruct work *work = submit_waiting;\n\t\t\tDL_DELETE(submit_waiting, work);\n\t\t\tif ( (sws = begin_submission(work)) ) {\n\t\t\t\tif (sws->ce)\n\t\t\t\t\tcurl_multi_add_handle(curlm, sws->ce->curl);\n\t\t\t\telse if (sws->s) {\n\t\t\t\t\tsws->next = write_sws;\n\t\t\t\t\twrite_sws = sws;\n\t\t\t\t}\n\t\t\t\t++wip;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t--total_submitting;\n\t\t\t\tfree_work(work);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (unlikely(shutting_down && !wip))\n\t\t\tbreak;\n\t\tmutex_unlock(&submitting_lock);\n\t\t\n\t\tFD_ZERO(&rfds);\n\t\tFD_ZERO(&wfds);\n\t\tFD_ZERO(&efds);\n\t\ttv_timeout.tv_sec = -1;\n\t\t\n\t\t// Setup cURL with select\n\t\t// Need to call perform to ensure the timeout gets updated\n\t\tcurl_multi_perform(curlm, &n);\n\t\tcurl_multi_fdset(curlm, &rfds, &wfds, &efds, &maxfd);\n\t\tif (curlm_timeout_us >= 0)\n\t\t{\n\t\t\ttimer_set_delay_from_now(&curlm_timer, curlm_timeout_us);\n\t\t\treduce_timeout_to(&tv_timeout, &curlm_timer);\n\t\t}\n\t\t\n\t\t// Setup waiting stratum submissions with select\n\t\tfor (sws = write_sws; sws; sws = sws->next)\n\t\t{\n\t\t\tstruct pool *pool = sws->work->pool;\n\t\t\tint fd = pool->sock;\n\t\t\tif (fd == INVSOCK || (!pool->stratum_init) || !pool->stratum_notify)\n\t\t\t\tcontinue;\n\t\t\tFD_SET(fd, &wfds);\n\t\t\tset_maxfd(&maxfd, fd);\n\t\t}\n\t\t\n\t\t// Setup \"submit waiting\" notifier with select\n\t\tFD_SET(submit_waiting_notifier[0], &rfds);\n\t\tset_maxfd(&maxfd, submit_waiting_notifier[0]);\n\t\t\n\t\t// Wait for something interesting to happen :)\n\t\tcgtime(&tv_now);\n\t\tif (select(maxfd+1, &rfds, &wfds, &efds, select_timeout(&tv_timeout, &tv_now)) < 0) {\n\t\t\tFD_ZERO(&rfds);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Handle any stratum ready-to-write results\n\t\tfor (swsp = &write_sws; (sws = *swsp); ) {\n\t\t\tstruct work *work = sws->work;\n\t\t\tstruct pool *pool = work->pool;\n\t\t\tint fd = pool->sock;\n\t\t\tbool sessionid_match;\n\t\t\t\n\t\t\tif (fd == INVSOCK || (!pool->stratum_init) || (!pool->stratum_notify) || !FD_ISSET(fd, &wfds)) {\nnext_write_sws:\n\t\t\t\t// TODO: Check if stale, possibly discard etc\n\t\t\t\tswsp = &sws->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tcg_rlock(&pool->data_lock);\n\t\t\t// NOTE: cgminer only does this check on retries, but BFGMiner does it for even the first/normal submit; therefore, it needs to be such that it always is true on the same connection regardless of session management\n\t\t\t// NOTE: Worst case scenario for a false positive: the pool rejects it as H-not-zero\n\t\t\tsessionid_match = (!pool->swork.nonce1) || !strcmp(work->nonce1, pool->swork.nonce1);\n\t\t\tcg_runlock(&pool->data_lock);\n\t\t\tif (!sessionid_match)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"No matching session id for resubmitting stratum share\");\n\t\t\t\tsubmit_discard_share2(\"disconnect\", work);\n\t\t\t\t++tsreduce;\nnext_write_sws_del:\n\t\t\t\t// Clear the fd from wfds, to avoid potentially blocking on other submissions to the same socket\n\t\t\t\tFD_CLR(fd, &wfds);\n\t\t\t\t// Delete sws for this submission, since we're done with it\n\t\t\t\t*swsp = sws->next;\n\t\t\t\tfree_sws(sws);\n\t\t\t\t--wip;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tchar *s = sws->s;\n\t\t\tstruct stratum_share *sshare = calloc(sizeof(struct stratum_share), 1);\n\t\t\tint sshare_id;\n\t\t\tuint32_t nonce;\n\t\t\tchar nonce2hex[(bytes_len(&work->nonce2) * 2) + 1];\n\t\t\tchar noncehex[9];\n\t\t\tchar ntimehex[9];\n\t\t\t\n\t\t\tsshare->work = copy_work(work);\n\t\t\tbin2hex(nonce2hex, bytes_buf(&work->nonce2), bytes_len(&work->nonce2));\n\t\t\tnonce = *((uint32_t *)(work->data + 76));\n\t\t\tbin2hex(noncehex, (const unsigned char *)&nonce, 4);\n\t\t\tbin2hex(ntimehex, (void *)&work->data[68], 4);\n\t\t\t\n\t\t\tmutex_lock(&sshare_lock);\n\t\t\t/* Give the stratum share a unique id */\n\t\t\tsshare_id =\n\t\t\tsshare->id = swork_id++;\n\t\t\tHASH_ADD_INT(stratum_shares, id, sshare);\n\t\t\tsnprintf(s, 1024, \"{\\\"params\\\": [\\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\"], \\\"id\\\": %d, \\\"method\\\": \\\"mining.submit\\\"}\",\n\t\t\t\tpool->rpc_user, work->job_id, nonce2hex, ntimehex, noncehex, sshare->id);\n\t\t\tmutex_unlock(&sshare_lock);\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"DBG: sending %s submit RPC call: %s\", pool->stratum_url, s);\n\n\t\t\tif (likely(stratum_send(pool, s, strlen(s)))) {\n\t\t\t\tif (pool_tclear(pool, &pool->submit_fail))\n\t\t\t\t\tapplog(LOG_WARNING, \"Pool %d communication resumed, submitting work\", pool->pool_no);\n\t\t\t\tapplog(LOG_DEBUG, \"Successfully submitted, adding to stratum_shares db\");\n\t\t\t\tgoto next_write_sws_del;\n\t\t\t} else if (!pool_tset(pool, &pool->submit_fail)) {\n\t\t\t\t// Undo stuff\n\t\t\t\tmutex_lock(&sshare_lock);\n\t\t\t\t// NOTE: Need to find it again in case something else has consumed it already (like the stratum-disconnect resubmitter...)\n\t\t\t\tHASH_FIND_INT(stratum_shares, &sshare_id, sshare);\n\t\t\t\tif (sshare)\n\t\t\t\t\tHASH_DEL(stratum_shares, sshare);\n\t\t\t\tmutex_unlock(&sshare_lock);\n\t\t\t\tif (sshare)\n\t\t\t\t{\n\t\t\t\t\tfree_work(sshare->work);\n\t\t\t\t\tfree(sshare);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tapplog(LOG_WARNING, \"Pool %d stratum share submission failure\", pool->pool_no);\n\t\t\t\ttotal_ro++;\n\t\t\t\tpool->remotefail_occasions++;\n\t\t\t\t\n\t\t\t\tif (!sshare)\n\t\t\t\t\tgoto next_write_sws_del;\n\t\t\t\t\n\t\t\t\tgoto next_write_sws;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Handle any cURL activities\n\t\tcurl_multi_perform(curlm, &n);\n\t\twhile( (cm = curl_multi_info_read(curlm, &n)) ) {\n\t\t\tif (cm->msg == CURLMSG_DONE)\n\t\t\t{\n\t\t\t\tbool finished;\n\t\t\t\tjson_t *val = json_rpc_call_completed(cm->easy_handle, cm->data.result, false, NULL, &sws);\n\t\t\t\tcurl_multi_remove_handle(curlm, cm->easy_handle);\n\t\t\t\tfinished = submit_upstream_work_completed(sws->work, sws->resubmit, &sws->tv_submit, val);\n\t\t\t\tif (!finished) {\n\t\t\t\t\tif (retry_submission(sws))\n\t\t\t\t\t\tcurl_multi_add_handle(curlm, sws->ce->curl);\n\t\t\t\t\telse\n\t\t\t\t\t\tfinished = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (finished) {\n\t\t\t\t\t--wip;\n\t\t\t\t\t++tsreduce;\n\t\t\t\t\tstruct pool *pool = sws->work->pool;\n\t\t\t\t\tif (pool->sws_waiting_on_curl) {\n\t\t\t\t\t\tpool->sws_waiting_on_curl->ce = sws->ce;\n\t\t\t\t\t\tsws_has_ce(pool->sws_waiting_on_curl);\n\t\t\t\t\t\tpool->sws_waiting_on_curl = pool->sws_waiting_on_curl->next;\n\t\t\t\t\t\tcurl_multi_add_handle(curlm, sws->ce->curl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush_curl_entry(sws->ce, sws->work->pool);\n\t\t\t\t\t}\n\t\t\t\t\tfree_sws(sws);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(!write_sws);\n\tmutex_unlock(&submitting_lock);\n\n\tcurl_multi_cleanup(curlm);\n\n\tapplog(LOG_DEBUG, \"submit_work thread exiting\");\n\n\treturn NULL;\n}\n\n/* Find the pool that currently has the highest priority */\nstatic struct pool *priority_pool(int choice)\n{\n\tstruct pool *ret = NULL;\n\tint i;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tif (pool->prio == choice) {\n\t\t\tret = pool;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"WTF No pool %d found!\", choice);\n\t\treturn pools[choice];\n\t}\n\treturn ret;\n}\n\nint prioritize_pools(char *param, int *pid)\n{\n\tchar *ptr, *next;\n\tint i, pr, prio = 0;\n\n\tif (total_pools == 0) {\n\t\treturn MSG_NOPOOL;\n\t}\n\n\tif (param == NULL || *param == '\\0') {\n\t\treturn MSG_MISPID;\n\t}\n\n\tbool pools_changed[total_pools];\n\tint new_prio[total_pools];\n\tfor (i = 0; i < total_pools; ++i)\n\t\tpools_changed[i] = false;\n\n\tnext = param;\n\twhile (next && *next) {\n\t\tptr = next;\n\t\tnext = strchr(ptr, ',');\n\t\tif (next)\n\t\t\t*(next++) = '\\0';\n\n\t\ti = atoi(ptr);\n\t\tif (i < 0 || i >= total_pools) {\n\t\t\t*pid = i;\n\t\t\treturn MSG_INVPID;\n\t\t}\n\n\t\tif (pools_changed[i]) {\n\t\t\t*pid = i;\n\t\t\treturn MSG_DUPPID;\n\t\t}\n\n\t\tpools_changed[i] = true;\n\t\tnew_prio[i] = prio++;\n\t}\n\n\t// Only change them if no errors\n\tfor (i = 0; i < total_pools; i++) {\n\t\tif (pools_changed[i])\n\t\t\tpools[i]->prio = new_prio[i];\n\t}\n\n\t// In priority order, cycle through the unchanged pools and append them\n\tfor (pr = 0; pr < total_pools; pr++)\n\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\tif (!pools_changed[i] && pools[i]->prio == pr) {\n\t\t\t\tpools[i]->prio = prio++;\n\t\t\t\tpools_changed[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (current_pool()->prio)\n\t\tswitch_pools(NULL);\n\n\treturn MSG_POOLPRIO;\n}\n\nvoid validate_pool_priorities(void)\n{\n\t// TODO: this should probably do some sort of logging\n\tint i, j;\n\tbool used[total_pools];\n\tbool valid[total_pools];\n\n\tfor (i = 0; i < total_pools; i++)\n\t\tused[i] = valid[i] = false;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tif (pools[i]->prio >=0 && pools[i]->prio < total_pools) {\n\t\t\tif (!used[pools[i]->prio]) {\n\t\t\t\tvalid[i] = true;\n\t\t\t\tused[pools[i]->prio] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tif (!valid[i]) {\n\t\t\tfor (j = 0; j < total_pools; j++) {\n\t\t\t\tif (!used[j]) {\n\t\t\t\t\tapplog(LOG_WARNING, \"Pool %d priority changed from %d to %d\", i, pools[i]->prio, j);\n\t\t\t\t\tpools[i]->prio = j;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void clear_pool_work(struct pool *pool);\n\n/* Specifies whether we can switch to this pool or not. */\nstatic bool pool_unusable(struct pool *pool)\n{\n\tif (pool->idle)\n\t\treturn true;\n\tif (pool->enabled != POOL_ENABLED)\n\t\treturn true;\n\treturn false;\n}\n\nvoid switch_pools(struct pool *selected)\n{\n\tstruct pool *pool, *last_pool, *failover_pool = NULL;\n\tint i, pool_no, next_pool;\n\n\tif (selected)\n\t\tenable_pool(selected);\n\t\n\tcg_wlock(&control_lock);\n\tlast_pool = currentpool;\n\tpool_no = currentpool->pool_no;\n\n\t/* Switch selected to pool number 0 and move the rest down */\n\tif (selected) {\n\t\tif (selected->prio != 0) {\n\t\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\t\tpool = pools[i];\n\t\t\t\tif (pool->prio < selected->prio)\n\t\t\t\t\tpool->prio++;\n\t\t\t}\n\t\t\tselected->prio = 0;\n\t\t}\n\t}\n\n\tswitch (pool_strategy) {\n\t\t/* All of these set to the master pool */\n\t\tcase POOL_BALANCE:\n\t\tcase POOL_FAILOVER:\n\t\tcase POOL_LOADBALANCE:\n\t\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\t\tpool = priority_pool(i);\n\t\t\t\tif (pool_unusable(pool))\n\t\t\t\t\tcontinue;\n\t\t\t\tpool_no = pool->pool_no;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t/* Both of these simply increment and cycle */\n\t\tcase POOL_ROUNDROBIN:\n\t\tcase POOL_ROTATE:\n\t\t\tif (selected && !selected->idle) {\n\t\t\t\tpool_no = selected->pool_no;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext_pool = pool_no;\n\t\t\t/* Select the next alive pool */\n\t\t\tfor (i = 1; i < total_pools; i++) {\n\t\t\t\tnext_pool++;\n\t\t\t\tif (next_pool >= total_pools)\n\t\t\t\t\tnext_pool = 0;\n\t\t\t\tpool = pools[next_pool];\n\t\t\t\tif (pool_unusable(pool))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pool->failover_only)\n\t\t\t\t{\n\t\t\t\t\tBFGINIT(failover_pool, pool);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpool_no = next_pool;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tpool = pools[pool_no];\n\tif (pool_unusable(pool) && failover_pool)\n\t\tpool = failover_pool;\n\tcurrentpool = pool;\n\tcg_wunlock(&control_lock);\n\tmutex_lock(&lp_lock);\n\tpthread_cond_broadcast(&lp_cond);\n\tmutex_unlock(&lp_lock);\n\n\t/* Set the lagging flag to avoid pool not providing work fast enough\n\t * messages in failover only mode since  we have to get all fresh work\n\t * as in restart_threads */\n\tif (opt_fail_only)\n\t\tpool_tset(pool, &pool->lagging);\n\n\tif (pool != last_pool)\n\t{\n\t\tpool->block_id = 0;\n\t\tif (pool_strategy != POOL_LOADBALANCE && pool_strategy != POOL_BALANCE) {\n\t\t\tapplog(LOG_WARNING, \"Switching to pool %d %s\", pool->pool_no, pool->rpc_url);\n\t\t\tif (pool_localgen(pool) || opt_fail_only)\n\t\t\t\tclear_pool_work(last_pool);\n\t\t}\n\t}\n\n\tmutex_lock(&lp_lock);\n\tpthread_cond_broadcast(&lp_cond);\n\tmutex_unlock(&lp_lock);\n\n#ifdef HAVE_CURSES\n\tupdate_block_display(false);\n#endif\n}\n\nstatic void discard_work(struct work *work)\n{\n\tif (!work->clone && !work->rolls && !work->mined) {\n\t\tif (work->pool) {\n\t\t\twork->pool->discarded_work++;\n\t\t\twork->pool->quota_used--;\n\t\t\twork->pool->works--;\n\t\t}\n\t\ttotal_discarded++;\n\t\tapplog(LOG_DEBUG, \"Discarded work\");\n\t} else\n\t\tapplog(LOG_DEBUG, \"Discarded cloned or rolled work\");\n\tfree_work(work);\n}\n\nstatic bool work_rollable(struct work *);\n\nstatic\nvoid unstage_work(struct work * const work)\n{\n\tHASH_DEL(staged_work, work);\n\t--work_mining_algorithm(work)->staged;\n\tif (work_rollable(work))\n\t\t--staged_rollable;\n\tif (work->spare)\n\t\t--staged_spare;\n\tstaged_full = false;\n}\n\nstatic void wake_gws(void)\n{\n\tmutex_lock(stgd_lock);\n\tpthread_cond_signal(&gws_cond);\n\tmutex_unlock(stgd_lock);\n}\n\nstatic void discard_stale(void)\n{\n\tstruct work *work, *tmp;\n\tint stale = 0;\n\n\tmutex_lock(stgd_lock);\n\tHASH_ITER(hh, staged_work, work, tmp) {\n\t\tif (stale_work(work, false)) {\n\t\t\tunstage_work(work);\n\t\t\tdiscard_work(work);\n\t\t\tstale++;\n\t\t}\n\t}\n\tpthread_cond_signal(&gws_cond);\n\tmutex_unlock(stgd_lock);\n\n\tif (stale)\n\t\tapplog(LOG_DEBUG, \"Discarded %d stales that didn't match current hash\", stale);\n}\n\nbool stale_work_future(struct work *work, bool share, unsigned long ustime)\n{\n\tbool rv;\n\tstruct timeval tv, orig;\n\tldiv_t d;\n\t\n\td = ldiv(ustime, 1000000);\n\ttv = (struct timeval){\n\t\t.tv_sec = d.quot,\n\t\t.tv_usec = d.rem,\n\t};\n\torig = work->tv_staged;\n\ttimersub(&orig, &tv, &work->tv_staged);\n\trv = stale_work(work, share);\n\twork->tv_staged = orig;\n\t\n\treturn rv;\n}\n\nstatic\nvoid pool_update_work_restart_time(struct pool * const pool)\n{\n\tpool->work_restart_time = time(NULL);\n\tget_timestamp(pool->work_restart_timestamp, sizeof(pool->work_restart_timestamp), pool->work_restart_time);\n}\n\nstatic void restart_threads(void)\n{\n\tstruct pool *cp = current_pool();\n\tint i;\n\tstruct thr_info *thr;\n\n\t/* Artificially set the lagging flag to avoid pool not providing work\n\t * fast enough  messages after every long poll */\n\tpool_tset(cp, &cp->lagging);\n\n\t/* Discard staged work that is now stale */\n\tdiscard_stale();\n\n\trd_lock(&mining_thr_lock);\n\t\n\tfor (i = 0; i < mining_threads; i++)\n\t{\n\t\tthr = mining_thr[i];\n\t\tthr->work_restart = true;\n\t}\n\t\n\tfor (i = 0; i < mining_threads; i++)\n\t{\n\t\tthr = mining_thr[i];\n\t\tnotifier_wake(thr->work_restart_notifier);\n\t}\n\t\n\trd_unlock(&mining_thr_lock);\n}\n\nvoid blkhashstr(char *rv, const unsigned char *hash)\n{\n\tunsigned char hash_swap[32];\n\t\n\tswap256(hash_swap, hash);\n\tswap32tole(hash_swap, hash_swap, 32 / 4);\n\tbin2hex(rv, hash_swap, 32);\n}\n\nstatic\nvoid set_curblock(struct mining_goal_info * const goal, struct block_info * const blkinfo)\n{\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\n\tblkchain->currentblk = blkinfo;\n\tblkchain->currentblk_subsidy = 5000000000LL >> (blkinfo->height / 210000);\n\n\tcg_wlock(&ch_lock);\n\t__update_block_title(goal);\n\tget_timestamp(blkchain->currentblk_first_seen_time_str, sizeof(blkchain->currentblk_first_seen_time_str), blkinfo->first_seen_time);\n\tcg_wunlock(&ch_lock);\n\n\tapplog(LOG_INFO, \"New block: %s diff %s (%s)\", goal->current_goal_detail, goal->current_diff_str, goal->net_hashrate);\n}\n\n/* Search to see if this prevblkhash has been seen before */\nstatic\nstruct block_info *block_exists(const struct blockchain_info * const blkchain, const void * const prevblkhash)\n{\n\tstruct block_info *s;\n\n\trd_lock(&blk_lock);\n\tHASH_FIND(hh, blkchain->blocks, prevblkhash, 0x20, s);\n\trd_unlock(&blk_lock);\n\n\treturn s;\n}\n\nstatic int block_sort(struct block_info * const blocka, struct block_info * const blockb)\n{\n\treturn blocka->block_seen_order - blockb->block_seen_order;\n}\n\nstatic\nvoid set_blockdiff(struct mining_goal_info * const goal, const struct work * const work)\n{\n\tunsigned char target[32];\n\tdouble diff;\n\tuint64_t diff64;\n\n\treal_block_target(target, work->data);\n\tdiff = target_diff(target);\n\tdiff64 = diff;\n\n\tsuffix_string(diff64, goal->current_diff_str, sizeof(goal->current_diff_str), 0);\n\tformat_unit2(goal->net_hashrate, sizeof(goal->net_hashrate),\n\t             true, \"h/s\", H2B_SHORT, diff * 7158278, -1);\n\tif (unlikely(goal->current_diff != diff))\n\t\tapplog(LOG_NOTICE, \"Network difficulty changed to %s (%s)\", goal->current_diff_str, goal->net_hashrate);\n\tgoal->current_diff = diff;\n}\n\nstatic bool test_work_current(struct work *work)\n{\n\tbool ret = true;\n\t\n\tif (work->mandatory)\n\t\treturn ret;\n\t\n\tuint32_t block_id = ((uint32_t*)(work->data))[1];\n\tconst uint8_t * const prevblkhash = &work->data[4];\n\t\n\t{\n\t\t/* Hack to work around dud work sneaking into test */\n\t\tbool dudwork = true;\n\t\tfor (int i = 8; i < 26; ++i)\n\t\t\tif (work->data[i])\n\t\t\t{\n\t\t\t\tdudwork = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (dudwork)\n\t\t\tgoto out_free;\n\t}\n\t\n\tstruct pool * const pool = work->pool;\n\tstruct mining_goal_info * const goal = pool->goal;\n\tstruct blockchain_info * const blkchain = goal->blkchain;\n\t\n\t/* Search to see if this block exists yet and if not, consider it a\n\t * new block and set the current block details to this one */\n\tif (!block_exists(blkchain, prevblkhash))\n\t{\n\t\tstruct block_info * const s = calloc(sizeof(struct block_info), 1);\n\t\tint deleted_block = 0;\n\t\tret = false;\n\t\t\n\t\tif (unlikely(!s))\n\t\t\tquit (1, \"test_work_current OOM\");\n\t\tmemcpy(s->prevblkhash, prevblkhash, sizeof(s->prevblkhash));\n\t\ts->block_id = block_id;\n\t\ts->block_seen_order = new_blocks++;\n\t\ts->first_seen_time = time(NULL);\n\t\t\n\t\twr_lock(&blk_lock);\n\t\t/* Only keep the last hour's worth of blocks in memory since\n\t\t * work from blocks before this is virtually impossible and we\n\t\t * want to prevent memory usage from continually rising */\n\t\tif (HASH_COUNT(blkchain->blocks) > 6)\n\t\t{\n\t\t\tstruct block_info *oldblock;\n\t\t\t\n\t\t\tHASH_SORT(blkchain->blocks, block_sort);\n\t\t\toldblock = blkchain->blocks;\n\t\t\tdeleted_block = oldblock->block_seen_order;\n\t\t\tHASH_DEL(blkchain->blocks, oldblock);\n\t\t\tfree(oldblock);\n\t\t}\n\t\tHASH_ADD(hh, blkchain->blocks, prevblkhash, sizeof(s->prevblkhash), s);\n\t\tset_blockdiff(goal, work);\n\t\twr_unlock(&blk_lock);\n\t\tpool->block_id = block_id;\n\t\tpool_update_work_restart_time(pool);\n\t\t\n\t\tif (deleted_block)\n\t\t\tapplog(LOG_DEBUG, \"Deleted block %d from database\", deleted_block);\n#if BLKMAKER_VERSION > 1\n\t\ttemplate_nonce = 0;\n#endif\n\t\tset_curblock(goal, s);\n\t\tif (unlikely(new_blocks == 1))\n\t\t\tgoto out_free;\n\t\t\n\t\tif (!work->stratum)\n\t\t{\n\t\t\tif (work->longpoll)\n\t\t\t{\n\t\t\t\tapplog(LOG_NOTICE, \"Longpoll from pool %d detected new block\",\n\t\t\t\t       pool->pool_no);\n\t\t\t}\n\t\t\telse\n\t\t\tif (goal->have_longpoll)\n\t\t\t\tapplog(LOG_NOTICE, \"New block detected on network before longpoll\");\n\t\t\telse\n\t\t\t\tapplog(LOG_NOTICE, \"New block detected on network\");\n\t\t}\n\t\trestart_threads();\n\t}\n\telse\n\t{\n\t\tbool restart = false;\n\t\tif (unlikely(pool->block_id != block_id))\n\t\t{\n\t\t\tbool was_active = pool->block_id != 0;\n\t\t\tpool->block_id = block_id;\n\t\t\tpool_update_work_restart_time(pool);\n\t\t\tif (!work->longpoll)\n\t\t\t\tupdate_last_work(work);\n\t\t\tif (was_active)\n\t\t\t{\n\t\t\t\t// Pool actively changed block\n\t\t\t\tif (pool == current_pool())\n\t\t\t\t\trestart = true;\n\t\t\t\tif (block_id == blkchain->currentblk->block_id)\n\t\t\t\t{\n\t\t\t\t\t// Caught up, only announce if this pool is the one in use\n\t\t\t\t\tif (restart)\n\t\t\t\t\t\tapplog(LOG_NOTICE, \"%s %d caught up to new block\",\n\t\t\t\t\t\t       work->longpoll ? \"Longpoll from pool\" : \"Pool\",\n\t\t\t\t\t\t       pool->pool_no);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Switched to a block we know, but not the latest... why?\n\t\t\t\t\t// This might detect pools trying to double-spend or 51%,\n\t\t\t\t\t// but let's not make any accusations until it's had time\n\t\t\t\t\t// in the real world.\n\t\t\t\t\tchar hexstr[65];\n\t\t\t\t\tblkhashstr(hexstr, prevblkhash);\n\t\t\t\t\tapplog(LOG_WARNING, \"%s %d is issuing work for an old block: %s\",\n\t\t\t\t\t       work->longpoll ? \"Longpoll from pool\" : \"Pool\",\n\t\t\t\t\t       pool->pool_no,\n\t\t\t\t\t       hexstr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (work->longpoll)\n\t\t{\n\t\t\tstruct pool * const cp = current_pool();\n\t\t\t++pool->work_restart_id;\n\t\t\tif (work->tr && work->tr == pool->swork.tr)\n\t\t\t\tpool->swork.work_restart_id = pool->work_restart_id;\n\t\t\tupdate_last_work(work);\n\t\t\tpool_update_work_restart_time(pool);\n\t\t\tapplog(\n\t\t\t       ((!opt_quiet_work_updates) && pool_actively_in_use(pool, cp) ? LOG_NOTICE : LOG_DEBUG),\n\t\t\t       \"Longpoll from pool %d requested work update\",\n\t\t\t\tpool->pool_no);\n\t\t\tif ((!restart) && pool == cp)\n\t\t\t\trestart = true;\n\t\t}\n\t\tif (restart)\n\t\t\trestart_threads();\n\t}\n\twork->longpoll = false;\nout_free:\n\treturn ret;\n}\n\nstatic int tv_sort(struct work *worka, struct work *workb)\n{\n\treturn worka->tv_staged.tv_sec - workb->tv_staged.tv_sec;\n}\n\nstatic bool work_rollable(struct work *work)\n{\n\treturn (!work->clone && work->rolltime);\n}\n\nstatic bool hash_push(struct work *work)\n{\n\tbool rc = true;\n\n\tmutex_lock(stgd_lock);\n\tif (work_rollable(work))\n\t\tstaged_rollable++;\n\t++work_mining_algorithm(work)->staged;\n\tif (work->spare)\n\t\t++staged_spare;\n\tif (likely(!getq->frozen)) {\n\t\tHASH_ADD_INT(staged_work, id, work);\n\t\tHASH_SORT(staged_work, tv_sort);\n\t} else\n\t\trc = false;\n\tpthread_cond_broadcast(&getq->cond);\n\tmutex_unlock(stgd_lock);\n\n\treturn rc;\n}\n\nstatic void stage_work(struct work *work)\n{\n\tapplog(LOG_DEBUG, \"Pushing work %d from pool %d to hash queue\",\n\t       work->id, work->pool->pool_no);\n\twork->work_restart_id = work->pool->work_restart_id;\n\twork->pool->last_work_time = time(NULL);\n\tcgtime(&work->pool->tv_last_work_time);\n\ttest_work_current(work);\n\twork->pool->works++;\n\thash_push(work);\n}\n\n#ifdef HAVE_CURSES\nint curses_int(const char *query)\n{\n\tint ret;\n\tchar *cvar;\n\n\tcvar = curses_input(query);\n\tif (unlikely(!cvar))\n\t\treturn -1;\n\tret = atoi(cvar);\n\tfree(cvar);\n\treturn ret;\n}\n#endif\n\n#ifdef HAVE_CURSES\nstatic bool input_pool(bool live);\n#endif\n\n#ifdef HAVE_CURSES\nstatic void display_pool_summary(struct pool *pool)\n{\n\tdouble efficiency = 0.0;\n\tchar xfer[ALLOC_H2B_NOUNIT+ALLOC_H2B_SPACED+4+1], bw[ALLOC_H2B_NOUNIT+ALLOC_H2B_SPACED+6+1];\n\tint pool_secs;\n\n\tif (curses_active_locked()) {\n\t\twlog(\"Pool: %s  Goal: %s\\n\", pool->rpc_url, pool->goal->name);\n\t\tif (pool->solved)\n\t\t\twlog(\"SOLVED %d BLOCK%s!\\n\", pool->solved, pool->solved > 1 ? \"S\" : \"\");\n\t\tif (!pool->has_stratum)\n\t\t\twlog(\"%s own long-poll support\\n\", pool->lp_url ? \"Has\" : \"Does not have\");\n\t\twlog(\" Queued work requests: %d\\n\", pool->getwork_requested);\n\t\twlog(\" Share submissions: %d\\n\", pool->accepted + pool->rejected);\n\t\twlog(\" Accepted shares: %d\\n\", pool->accepted);\n\t\twlog(\" Rejected shares: %d + %d stale (%.2f%%)\\n\",\n\t\t     pool->rejected, pool->stale_shares,\n\t\t     (float)(pool->rejected + pool->stale_shares) / (float)(pool->rejected + pool->stale_shares + pool->accepted)\n\t\t);\n\t\twlog(\" Accepted difficulty shares: %1.f\\n\", pool->diff_accepted);\n\t\twlog(\" Rejected difficulty shares: %1.f\\n\", pool->diff_rejected);\n\t\tpool_secs = timer_elapsed(&pool->cgminer_stats.start_tv, NULL);\n\t\twlog(\" Network transfer: %s  (%s)\\n\",\n\t\t     multi_format_unit2(xfer, sizeof(xfer), true, \"B\", H2B_SPACED, \" / \", 2,\n\t\t                       (float)pool->cgminer_pool_stats.net_bytes_received,\n\t\t                       (float)pool->cgminer_pool_stats.net_bytes_sent),\n\t\t     multi_format_unit2(bw, sizeof(bw), true, \"B/s\", H2B_SPACED, \" / \", 2,\n\t\t                       (float)(pool->cgminer_pool_stats.net_bytes_received / pool_secs),\n\t\t                       (float)(pool->cgminer_pool_stats.net_bytes_sent / pool_secs)));\n\t\tuint64_t pool_bytes_xfer = pool->cgminer_pool_stats.net_bytes_received + pool->cgminer_pool_stats.net_bytes_sent;\n\t\tefficiency = pool_bytes_xfer ? pool->diff_accepted * 2048. / pool_bytes_xfer : 0.0;\n\t\twlog(\" Efficiency (accepted * difficulty / 2 KB): %.2f\\n\", efficiency);\n\n\t\twlog(\" Items worked on: %d\\n\", pool->works);\n\t\twlog(\" Stale submissions discarded due to new blocks: %d\\n\", pool->stale_shares);\n\t\twlog(\" Unable to get work from server occasions: %d\\n\", pool->getfail_occasions);\n\t\twlog(\" Submitting work remotely delay occasions: %d\\n\\n\", pool->remotefail_occasions);\n\t\tunlock_curses();\n\t}\n}\n#endif\n\n/* We can't remove the memory used for this struct pool because there may\n * still be work referencing it. We just remove it from the pools list */\nvoid remove_pool(struct pool *pool)\n{\n\tint i, last_pool = total_pools - 1;\n\tstruct pool *other;\n\n\tdisable_pool(pool, POOL_DISABLED);\n\t\n\t/* Boost priority of any lower prio than this one */\n\tfor (i = 0; i < total_pools; i++) {\n\t\tother = pools[i];\n\t\tif (other->prio > pool->prio)\n\t\t\tother->prio--;\n\t}\n\n\tif (pool->pool_no < last_pool) {\n\t\t/* Swap the last pool for this one */\n\t\t(pools[last_pool])->pool_no = pool->pool_no;\n\t\tpools[pool->pool_no] = pools[last_pool];\n\t}\n\t/* Give it an invalid number */\n\tpool->pool_no = total_pools;\n\tpool->removed = true;\n\tpool->has_stratum = false;\n\ttotal_pools--;\n}\n\n/* add a mutex if this needs to be thread safe in the future */\nstatic struct JE {\n\tchar *buf;\n\tstruct JE *next;\n} *jedata = NULL;\n\nstatic void json_escape_free()\n{\n\tstruct JE *jeptr = jedata;\n\tstruct JE *jenext;\n\n\tjedata = NULL;\n\n\twhile (jeptr) {\n\t\tjenext = jeptr->next;\n\t\tfree(jeptr->buf);\n\t\tfree(jeptr);\n\t\tjeptr = jenext;\n\t}\n}\n\nstatic\nchar *json_escape(const char *str)\n{\n\tstruct JE *jeptr;\n\tchar *buf, *ptr;\n\n\t/* 2x is the max, may as well just allocate that */\n\tptr = buf = malloc(strlen(str) * 2 + 1);\n\n\tjeptr = malloc(sizeof(*jeptr));\n\n\tjeptr->buf = buf;\n\tjeptr->next = jedata;\n\tjedata = jeptr;\n\n\twhile (*str) {\n\t\tif (*str == '\\\\' || *str == '\"')\n\t\t\t*(ptr++) = '\\\\';\n\n\t\t*(ptr++) = *(str++);\n\t}\n\n\t*ptr = '\\0';\n\n\treturn buf;\n}\n\nstatic\nvoid _write_config_string_elist(FILE *fcfg, const char *configname, struct string_elist * const elist)\n{\n\tif (!elist)\n\t\treturn;\n\t\n\tstatic struct string_elist *entry;\n\tfprintf(fcfg, \",\\n\\\"%s\\\" : [\", configname);\n\tbool first = true;\n\tDL_FOREACH(elist, entry)\n\t{\n\t\tconst char * const s = entry->string;\n\t\tfprintf(fcfg, \"%s\\n\\t\\\"%s\\\"\", first ? \"\" : \",\", json_escape(s));\n\t\tfirst = false;\n\t}\n\tfprintf(fcfg, \"\\n]\");\n}\n\nvoid write_config(FILE *fcfg)\n{\n\tint i;\n\n\t/* Write pool values */\n\tfputs(\"{\\n\\\"pools\\\" : [\", fcfg);\n\tfor(i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tif (pool->failover_only)\n\t\t\t// Don't write failover-only (automatically added) pools to the config file for now\n\t\t\tcontinue;\n\t\t\n\t\tif (pool->quota != 1) {\n\t\t\tfprintf(fcfg, \"%s\\n\\t{\\n\\t\\t\\\"quota\\\" : \\\"%d;%s\\\",\", i > 0 ? \",\" : \"\",\n\t\t\t\tpool->quota,\n\t\t\t\tjson_escape(pool->rpc_url));\n\t\t} else {\n\t\t\tfprintf(fcfg, \"%s\\n\\t{\\n\\t\\t\\\"url\\\" : \\\"%s\\\",\", i > 0 ? \",\" : \"\",\n\t\t\t\tjson_escape(pool->rpc_url));\n\t\t}\n\t\tif (pool->rpc_proxy)\n\t\t\tfprintf(fcfg, \"\\n\\t\\t\\\"pool-proxy\\\" : \\\"%s\\\",\", json_escape(pool->rpc_proxy));\n\t\tfprintf(fcfg, \"\\n\\t\\t\\\"user\\\" : \\\"%s\\\",\", json_escape(pool->rpc_user));\n\t\tfprintf(fcfg, \"\\n\\t\\t\\\"pass\\\" : \\\"%s\\\",\", json_escape(pool->rpc_pass));\n\t\tif (strcmp(pool->goal->name, \"default\"))\n\t\t\tfprintf(fcfg, \"\\n\\t\\t\\\"pool-goal\\\" : \\\"%s\\\",\", pool->goal->name);\n\t\tfprintf(fcfg, \"\\n\\t\\t\\\"pool-priority\\\" : \\\"%d\\\"\", pool->prio);\n\t\tif (pool->force_rollntime)\n\t\t\tfprintf(fcfg, \",\\n\\t\\t\\\"force-rollntime\\\" : %d\", pool->force_rollntime);\n\t\tfprintf(fcfg, \"\\n\\t}\");\n\t}\n\tfputs(\"\\n]\\n\", fcfg);\n\n#ifdef USE_OPENCL\n\twrite_config_opencl(fcfg);\n#endif\n#if defined(USE_CPUMINING) && defined(USE_SHA256D)\n\tfprintf(fcfg, \",\\n\\\"algo\\\" : \\\"%s\\\"\", algo_names[opt_algo]);\n#endif\n\n\t/* Simple bool and int options */\n\tstruct opt_table *opt;\n\tfor (opt = opt_config_table; opt->type != OPT_END; opt++) {\n\t\tchar *p, *name = strdup(opt->names);\n\t\tfor (p = strtok(name, \"|\"); p; p = strtok(NULL, \"|\")) {\n\t\t\tif (p[1] != '-')\n\t\t\t\tcontinue;\n\t\t\tif (opt->type & OPT_NOARG &&\n\t\t\t   ((void *)opt->cb == (void *)opt_set_bool || (void *)opt->cb == (void *)opt_set_invbool) &&\n\t\t\t   (*(bool *)opt->u.arg == ((void *)opt->cb == (void *)opt_set_bool)))\n\t\t\t\tfprintf(fcfg, \",\\n\\\"%s\\\" : true\", p+2);\n\n\t\t\tif (opt->type & OPT_HASARG &&\n\t\t\t   ((void *)opt->cb_arg == (void *)set_int_0_to_9999 ||\n\t\t\t   (void *)opt->cb_arg == (void *)set_int_1_to_65535 ||\n\t\t\t   (void *)opt->cb_arg == (void *)set_int_0_to_10 ||\n\t\t\t   (void *)opt->cb_arg == (void *)set_int_1_to_10) &&\n\t\t\t   opt->desc != opt_hidden &&\n\t\t\t   0 <= *(int *)opt->u.arg)\n\t\t\t\tfprintf(fcfg, \",\\n\\\"%s\\\" : \\\"%d\\\"\", p+2, *(int *)opt->u.arg);\n\t\t}\n\t\tfree(name);\n\t}\n\n\t/* Special case options */\n\tif (request_target_str)\n\t{\n\t\tif (request_pdiff == (long)request_pdiff)\n\t\t\tfprintf(fcfg, \",\\n\\\"request-diff\\\" : %ld\", (long)request_pdiff);\n\t\telse\n\t\t\tfprintf(fcfg, \",\\n\\\"request-diff\\\" : %f\", request_pdiff);\n\t}\n\tfprintf(fcfg, \",\\n\\\"shares\\\" : %g\", opt_shares);\n\tif (pool_strategy == POOL_BALANCE)\n\t\tfputs(\",\\n\\\"balance\\\" : true\", fcfg);\n\tif (pool_strategy == POOL_LOADBALANCE)\n\t\tfputs(\",\\n\\\"load-balance\\\" : true\", fcfg);\n\tif (pool_strategy == POOL_ROUNDROBIN)\n\t\tfputs(\",\\n\\\"round-robin\\\" : true\", fcfg);\n\tif (pool_strategy == POOL_ROTATE)\n\t\tfprintf(fcfg, \",\\n\\\"rotate\\\" : \\\"%d\\\"\", opt_rotate_period);\n#if defined(unix) || defined(__APPLE__)\n\tif (opt_stderr_cmd && *opt_stderr_cmd)\n\t\tfprintf(fcfg, \",\\n\\\"monitor\\\" : \\\"%s\\\"\", json_escape(opt_stderr_cmd));\n#endif // defined(unix)\n\tif (opt_kernel_path && *opt_kernel_path) {\n\t\tchar *kpath = strdup(opt_kernel_path);\n\t\tif (kpath[strlen(kpath)-1] == '/')\n\t\t\tkpath[strlen(kpath)-1] = 0;\n\t\tfprintf(fcfg, \",\\n\\\"kernel-path\\\" : \\\"%s\\\"\", json_escape(kpath));\n\t\tfree(kpath);\n\t}\n\tif (schedstart.enable)\n\t\tfprintf(fcfg, \",\\n\\\"sched-time\\\" : \\\"%d:%d\\\"\", schedstart.tm.tm_hour, schedstart.tm.tm_min);\n\tif (schedstop.enable)\n\t\tfprintf(fcfg, \",\\n\\\"stop-time\\\" : \\\"%d:%d\\\"\", schedstop.tm.tm_hour, schedstop.tm.tm_min);\n\tif (opt_socks_proxy && *opt_socks_proxy)\n\t\tfprintf(fcfg, \",\\n\\\"socks-proxy\\\" : \\\"%s\\\"\", json_escape(opt_socks_proxy));\n\t\n\t_write_config_string_elist(fcfg, \"scan\", scan_devices);\n#ifdef USE_LIBMICROHTTPD\n\tif (httpsrv_port != -1)\n\t\tfprintf(fcfg, \",\\n\\\"http-port\\\" : %d\", httpsrv_port);\n#endif\n#ifdef USE_LIBEVENT\n\tif (stratumsrv_port != -1)\n\t\tfprintf(fcfg, \",\\n\\\"stratum-port\\\" : %ld\", stratumsrv_port);\n#endif\n\t_write_config_string_elist(fcfg, \"device\", opt_devices_enabled_list);\n\t_write_config_string_elist(fcfg, \"set-device\", opt_set_device_list);\n\t\n\tif (opt_api_allow)\n\t\tfprintf(fcfg, \",\\n\\\"api-allow\\\" : \\\"%s\\\"\", json_escape(opt_api_allow));\n\tif (strcmp(opt_api_mcast_addr, API_MCAST_ADDR) != 0)\n\t\tfprintf(fcfg, \",\\n\\\"api-mcast-addr\\\" : \\\"%s\\\"\", json_escape(opt_api_mcast_addr));\n\tif (strcmp(opt_api_mcast_code, API_MCAST_CODE) != 0)\n\t\tfprintf(fcfg, \",\\n\\\"api-mcast-code\\\" : \\\"%s\\\"\", json_escape(opt_api_mcast_code));\n\tif (*opt_api_mcast_des)\n\t\tfprintf(fcfg, \",\\n\\\"api-mcast-des\\\" : \\\"%s\\\"\", json_escape(opt_api_mcast_des));\n\tif (strcmp(opt_api_description, PACKAGE_STRING) != 0)\n\t\tfprintf(fcfg, \",\\n\\\"api-description\\\" : \\\"%s\\\"\", json_escape(opt_api_description));\n\tif (opt_api_groups)\n\t\tfprintf(fcfg, \",\\n\\\"api-groups\\\" : \\\"%s\\\"\", json_escape(opt_api_groups));\n\tfputs(\"\\n}\\n\", fcfg);\n\n\tjson_escape_free();\n}\n\nvoid zero_bestshare(void)\n{\n\tint i;\n\n\tbest_diff = 0;\n\tsuffix_string(best_diff, best_share, sizeof(best_share), 0);\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\t\tpool->best_diff = 0;\n\t}\n}\n\nvoid zero_stats(void)\n{\n\tint i;\n\t\n\tapplog(LOG_DEBUG, \"Zeroing stats\");\n\n\tcgtime(&total_tv_start);\n\tminer_started = total_tv_start;\n\ttotal_rolling = 0;\n\ttotal_mhashes_done = 0;\n\ttotal_getworks = 0;\n\ttotal_accepted = 0;\n\ttotal_rejected = 0;\n\thw_errors = 0;\n\ttotal_stale = 0;\n\ttotal_discarded = 0;\n\ttotal_bytes_rcvd = total_bytes_sent = 0;\n\tnew_blocks = 0;\n\tlocal_work = 0;\n\ttotal_go = 0;\n\ttotal_ro = 0;\n\ttotal_secs = 1.0;\n\ttotal_diff1 = 0;\n\ttotal_bad_diff1 = 0;\n\tfound_blocks = 0;\n\ttotal_diff_accepted = 0;\n\ttotal_diff_rejected = 0;\n\ttotal_diff_stale = 0;\n#ifdef HAVE_CURSES\n\tawidth = rwidth = swidth = hwwidth = 1;\n#endif\n\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tgoal->diff_accepted = 0;\n\t}\n\t\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tpool->getwork_requested = 0;\n\t\tpool->accepted = 0;\n\t\tpool->rejected = 0;\n\t\tpool->solved = 0;\n\t\tpool->getwork_requested = 0;\n\t\tpool->stale_shares = 0;\n\t\tpool->discarded_work = 0;\n\t\tpool->getfail_occasions = 0;\n\t\tpool->remotefail_occasions = 0;\n\t\tpool->last_share_time = 0;\n\t\tpool->works = 0;\n\t\tpool->diff1 = 0;\n\t\tpool->diff_accepted = 0;\n\t\tpool->diff_rejected = 0;\n\t\tpool->diff_stale = 0;\n\t\tpool->last_share_diff = 0;\n\t\tpool->cgminer_stats.start_tv = total_tv_start;\n\t\tpool->cgminer_stats.getwork_calls = 0;\n\t\tpool->cgminer_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\t\tpool->cgminer_stats.getwork_wait_max.tv_sec = 0;\n\t\tpool->cgminer_stats.getwork_wait_max.tv_usec = 0;\n\t\tpool->cgminer_pool_stats.getwork_calls = 0;\n\t\tpool->cgminer_pool_stats.getwork_attempts = 0;\n\t\tpool->cgminer_pool_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\t\tpool->cgminer_pool_stats.getwork_wait_max.tv_sec = 0;\n\t\tpool->cgminer_pool_stats.getwork_wait_max.tv_usec = 0;\n\t\tpool->cgminer_pool_stats.min_diff = 0;\n\t\tpool->cgminer_pool_stats.max_diff = 0;\n\t\tpool->cgminer_pool_stats.min_diff_count = 0;\n\t\tpool->cgminer_pool_stats.max_diff_count = 0;\n\t\tpool->cgminer_pool_stats.times_sent = 0;\n\t\tpool->cgminer_pool_stats.bytes_sent = 0;\n\t\tpool->cgminer_pool_stats.net_bytes_sent = 0;\n\t\tpool->cgminer_pool_stats.times_received = 0;\n\t\tpool->cgminer_pool_stats.bytes_received = 0;\n\t\tpool->cgminer_pool_stats.net_bytes_received = 0;\n\t}\n\n\tzero_bestshare();\n\n\tfor (i = 0; i < total_devices; ++i) {\n\t\tstruct cgpu_info *cgpu = get_devices(i);\n\n\t\tmutex_lock(&hash_lock);\n\t\tcgpu->total_mhashes = 0;\n\t\tcgpu->accepted = 0;\n\t\tcgpu->rejected = 0;\n\t\tcgpu->stale = 0;\n\t\tcgpu->hw_errors = 0;\n\t\tcgpu->utility = 0.0;\n\t\tcgpu->utility_diff1 = 0;\n\t\tcgpu->last_share_pool_time = 0;\n\t\tcgpu->bad_diff1 = 0;\n\t\tcgpu->diff1 = 0;\n\t\tcgpu->diff_accepted = 0;\n\t\tcgpu->diff_rejected = 0;\n\t\tcgpu->diff_stale = 0;\n\t\tcgpu->last_share_diff = 0;\n\t\tcgpu->thread_fail_init_count = 0;\n\t\tcgpu->thread_zero_hash_count = 0;\n\t\tcgpu->thread_fail_queue_count = 0;\n\t\tcgpu->dev_sick_idle_60_count = 0;\n\t\tcgpu->dev_dead_idle_600_count = 0;\n\t\tcgpu->dev_nostart_count = 0;\n\t\tcgpu->dev_over_heat_count = 0;\n\t\tcgpu->dev_thermal_cutoff_count = 0;\n\t\tcgpu->dev_comms_error_count = 0;\n\t\tcgpu->dev_throttle_count = 0;\n\t\tcgpu->cgminer_stats.start_tv = total_tv_start;\n\t\tcgpu->cgminer_stats.getwork_calls = 0;\n\t\tcgpu->cgminer_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\t\tcgpu->cgminer_stats.getwork_wait_max.tv_sec = 0;\n\t\tcgpu->cgminer_stats.getwork_wait_max.tv_usec = 0;\n\t\tmutex_unlock(&hash_lock);\n\t\t\n\t\tif (cgpu->drv->zero_stats)\n\t\t\tcgpu->drv->zero_stats(cgpu);\n\t}\n}\n\nint bfg_strategy_parse(const char * const s)\n{\n\tchar *endptr;\n\tif (!(s && s[0]))\n\t\treturn -1;\n\tlong int selected = strtol(s, &endptr, 0);\n\tif (endptr == s || *endptr) {\n\t\t// Look-up by name\n\t\tselected = -1;\n\t\tfor (unsigned i = 0; i <= TOP_STRATEGY; ++i) {\n\t\t\tif (!strcasecmp(strategies[i].s, s)) {\n\t\t\t\tselected = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (selected < 0 || selected > TOP_STRATEGY) {\n\t\treturn -1;\n\t}\n\treturn selected;\n}\n\nbool bfg_strategy_change(const int selected, const char * const param)\n{\n\tif (param && param[0]) {\n\t\tswitch (selected) {\n\t\t\tcase POOL_ROTATE:\n\t\t\t{\n\t\t\t\tchar *endptr;\n\t\t\t\tlong int n = strtol(param, &endptr, 0);\n\t\t\t\tif (n < 0 || n > 9999 || *endptr) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\topt_rotate_period = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tmutex_lock(&lp_lock);\n\tpool_strategy = selected;\n\tpthread_cond_broadcast(&lp_cond);\n\tmutex_unlock(&lp_lock);\n\tswitch_pools(NULL);\n\t\n\treturn true;\n}\n\n#ifdef HAVE_CURSES\nstatic\nvoid loginput_mode(const int size)\n{\n\tclear_logwin();\n\tloginput_size = size;\n\tcheck_winsizes();\n}\n\nstatic void display_pools(void)\n{\n\tstruct pool *pool;\n\tint selected, i, j;\n\tchar input;\n\n\tloginput_mode(7 + total_pools);\n\timmedok(logwin, true);\nupdated:\n\tfor (j = 0; j < total_pools; j++) {\n\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\tpool = pools[i];\n\n\t\t\tif (pool->prio != j)\n\t\t\t\tcontinue;\n\n\t\t\tif (pool_actively_in_use(pool, NULL))\n\t\t\t\twattron(logwin, A_BOLD);\n\t\t\tif (pool->enabled != POOL_ENABLED || pool->failover_only)\n\t\t\t\twattron(logwin, A_DIM);\n\t\t\twlogprint(\"%d: \", pool->prio);\n\t\t\tswitch (pool->enabled) {\n\t\t\t\tcase POOL_ENABLED:\n\t\t\t\t\tif ((pool_strategy == POOL_LOADBALANCE) ? (!pool->quota)\n\t\t\t\t\t    : ((pool_strategy != POOL_FAILOVER) ? pool->failover_only : 0))\n\t\t\t\t\t\twlogprint(\"Failover \");\n\t\t\t\t\telse\n\t\t\t\t\t\twlogprint(\"Enabled  \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase POOL_DISABLED:\n\t\t\t\t\twlogprint(\"Disabled \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase POOL_REJECTING:\n\t\t\t\t\twlogprint(\"Rejectin \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase POOL_MISBEHAVING:\n\t\t\t\t\twlogprint(\"Misbehav \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_wlogprint(pool_proto_str(pool));\n\t\t\twlogprint(\" Quota %d Pool %d: %s  User:%s\\n\",\n\t\t\t\tpool->quota,\n\t\t\t\tpool->pool_no,\n\t\t\t\tpool->rpc_url, pool->rpc_user);\n\t\t\twattroff(logwin, A_BOLD | A_DIM);\n\n\t\t\tbreak; //for (i = 0; i < total_pools; i++)\n\t\t}\n\t}\nretry:\n\twlogprint(\"\\nCurrent pool management strategy: %s\\n\",\n\t\tstrategies[pool_strategy].s);\n\tif (pool_strategy == POOL_ROTATE)\n\t\twlogprint(\"Set to rotate every %d minutes\\n\", opt_rotate_period);\n\twlogprint(\"[F]ailover only %s\\n\", opt_fail_only ? \"enabled\" : \"disabled\");\n\twlogprint(\"Pool [A]dd [R]emove [D]isable [E]nable [P]rioritize [Q]uota change\\n\");\n\twlogprint(\"[C]hange management strategy [S]witch pool [I]nformation\\n\");\n\twlogprint(\"Or press any other key to continue\\n\");\n\tlogwin_update();\n\tinput = getch();\n\n\tif (!strncasecmp(&input, \"a\", 1)) {\n\t\tif (opt_benchmark)\n\t\t{\n\t\t\twlogprint(\"Cannot add pools in benchmark mode\");\n\t\t\tgoto retry;\n\t\t}\n\t\tinput_pool(true);\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"r\", 1)) {\n\t\tif (total_pools <= 1) {\n\t\t\twlogprint(\"Cannot remove last pool\");\n\t\t\tgoto retry;\n\t\t}\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tif (pool == current_pool())\n\t\t\tswitch_pools(NULL);\n\t\tif (pool == current_pool()) {\n\t\t\twlogprint(\"Unable to remove pool due to activity\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tremove_pool(pool);\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"s\", 1)) {\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tmanual_enable_pool(pool);\n\t\tswitch_pools(pool);\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"d\", 1)) {\n\t\tif (enabled_pools <= 1) {\n\t\t\twlogprint(\"Cannot disable last pool\");\n\t\t\tgoto retry;\n\t\t}\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tdisable_pool(pool, POOL_DISABLED);\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"e\", 1)) {\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tmanual_enable_pool(pool);\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"c\", 1)) {\n\t\tfor (i = 0; i <= TOP_STRATEGY; i++)\n\t\t\twlogprint(\"%d: %s\\n\", i, strategies[i].s);\n\t\t{\n\t\t\tchar * const selected_str = curses_input(\"Select strategy type\");\n\t\t\tselected = bfg_strategy_parse(selected_str);\n\t\t\tfree(selected_str);\n\t\t}\n\t\tif (selected < 0 || selected > TOP_STRATEGY) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tchar *param = NULL;\n\t\tif (selected == POOL_ROTATE) {\n\t\t\tparam = curses_input(\"Select interval in minutes\");\n\t\t}\n\t\tbool result = bfg_strategy_change(selected, param);\n\t\tfree(param);\n\t\tif (!result) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"i\", 1)) {\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tdisplay_pool_summary(pool);\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"q\", 1)) {\n\t\tselected = curses_int(\"Select pool number\");\n\t\tif (selected < 0 || selected >= total_pools) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tpool = pools[selected];\n\t\tselected = curses_int(\"Set quota\");\n\t\tif (selected < 0) {\n\t\t\twlogprint(\"Invalid negative quota\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tif (selected > 0)\n\t\t\tpool->failover_only = false;\n\t\tpool->quota = selected;\n\t\tadjust_quota_gcd();\n\t\tgoto updated;\n\t} else if (!strncasecmp(&input, \"f\", 1)) {\n\t\topt_fail_only ^= true;\n\t\tgoto updated;\n        } else if (!strncasecmp(&input, \"p\", 1)) {\n\t\t\tchar *prilist = curses_input(\"Enter new pool priority (comma separated list)\");\n\t\t\tif (!prilist)\n\t\t\t{\n\t\t\t\twlogprint(\"Not changing priorities\\n\");\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tint res = prioritize_pools(prilist, &i);\n\t\t\tfree(prilist);\n\t\t\tswitch (res) {\n        \t\tcase MSG_NOPOOL:\n        \t\t\twlogprint(\"No pools\\n\");\n        \t\t\tgoto retry;\n        \t\tcase MSG_MISPID:\n        \t\t\twlogprint(\"Missing pool id parameter\\n\");\n        \t\t\tgoto retry;\n        \t\tcase MSG_INVPID:\n        \t\t\twlogprint(\"Invalid pool id %d - range is 0 - %d\\n\", i, total_pools - 1);\n        \t\t\tgoto retry;\n        \t\tcase MSG_DUPPID:\n        \t\t\twlogprint(\"Duplicate pool specified %d\\n\", i);\n        \t\t\tgoto retry;\n        \t\tcase MSG_POOLPRIO:\n        \t\tdefault:\n        \t\t\tgoto updated;\n        \t}\n\t}\n\n\timmedok(logwin, false);\n\tloginput_mode(0);\n}\n\nstatic const char *summary_detail_level_str(void)\n{\n\tif (opt_compact)\n\t\treturn \"compact\";\n\tif (opt_show_procs)\n\t\treturn \"processors\";\n\treturn \"devices\";\n}\n\nstatic void display_options(void)\n{\n\tint selected;\n\tchar input;\n\n\timmedok(logwin, true);\n\tloginput_mode(12);\nretry:\n\tclear_logwin();\n\twlogprint(\"[N]ormal [C]lear [S]ilent mode (disable all output)\\n\");\n\twlogprint(\"[D]ebug:%s\\n[P]er-device:%s\\n[Q]uiet:%s\\n[V]erbose:%s\\n\"\n\t\t  \"[R]PC debug:%s\\n[W]orkTime details:%s\\nsu[M]mary detail level:%s\\n\"\n\t\t  \"[L]og interval:%d\\nS[T]atistical counts: %s\\n[Z]ero statistics\\n\",\n\t\topt_debug_console ? \"on\" : \"off\",\n\t        want_per_device_stats? \"on\" : \"off\",\n\t\topt_quiet ? \"on\" : \"off\",\n\t\topt_log_output ? \"on\" : \"off\",\n\t\topt_protocol ? \"on\" : \"off\",\n\t\topt_worktime ? \"on\" : \"off\",\n\t\tsummary_detail_level_str(),\n\t\topt_log_interval,\n\t\topt_weighed_stats ? \"weighed\" : \"absolute\");\n\twlogprint(\"Select an option or any other key to return\\n\");\n\tlogwin_update();\n\tinput = getch();\n\tif (!strncasecmp(&input, \"q\", 1)) {\n\t\topt_quiet ^= true;\n\t\twlogprint(\"Quiet mode %s\\n\", opt_quiet ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"v\", 1)) {\n\t\topt_log_output ^= true;\n\t\tif (opt_log_output)\n\t\t\topt_quiet = false;\n\t\twlogprint(\"Verbose mode %s\\n\", opt_log_output ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"n\", 1)) {\n\t\topt_log_output = false;\n\t\topt_debug_console = false;\n\t\topt_quiet = false;\n\t\topt_protocol = false;\n\t\topt_compact = false;\n\t\topt_show_procs = false;\n\t\tdevsummaryYOffset = 0;\n\t\twant_per_device_stats = false;\n\t\twlogprint(\"Output mode reset to normal\\n\");\n\t\tswitch_logsize();\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"d\", 1)) {\n\t\topt_debug = true;\n\t\topt_debug_console ^= true;\n\t\topt_log_output = opt_debug_console;\n\t\tif (opt_debug_console)\n\t\t\topt_quiet = false;\n\t\twlogprint(\"Debug mode %s\\n\", opt_debug_console ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"m\", 1)) {\n\t\tif (opt_compact)\n\t\t\topt_compact = false;\n\t\telse\n\t\tif (!opt_show_procs)\n\t\t\topt_show_procs = true;\n\t\telse\n\t\t{\n\t\t\topt_compact = true;\n\t\t\topt_show_procs = false;\n\t\t\tdevsummaryYOffset = 0;\n\t\t}\n\t\twlogprint(\"su[M]mary detail level changed to: %s\\n\", summary_detail_level_str());\n\t\tswitch_logsize();\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"p\", 1)) {\n\t\twant_per_device_stats ^= true;\n\t\topt_log_output = want_per_device_stats;\n\t\twlogprint(\"Per-device stats %s\\n\", want_per_device_stats ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"r\", 1)) {\n\t\topt_protocol ^= true;\n\t\tif (opt_protocol)\n\t\t\topt_quiet = false;\n\t\twlogprint(\"RPC protocol debugging %s\\n\", opt_protocol ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"c\", 1))\n\t\tclear_logwin();\n\telse if (!strncasecmp(&input, \"l\", 1)) {\n\t\tselected = curses_int(\"Interval in seconds\");\n\t\tif (selected < 0 || selected > 9999) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\topt_log_interval = selected;\n\t\twlogprint(\"Log interval set to %d seconds\\n\", opt_log_interval);\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"s\", 1)) {\n\t\topt_realquiet = true;\n\t} else if (!strncasecmp(&input, \"w\", 1)) {\n\t\topt_worktime ^= true;\n\t\twlogprint(\"WorkTime details %s\\n\", opt_worktime ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"t\", 1)) {\n\t\topt_weighed_stats ^= true;\n\t\twlogprint(\"Now displaying %s statistics\\n\", opt_weighed_stats ? \"weighed\" : \"absolute\");\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"z\", 1)) {\n\t\tzero_stats();\n\t\tgoto retry;\n\t}\n\n\timmedok(logwin, false);\n\tloginput_mode(0);\n}\n#endif\n\nvoid default_save_file(char *filename)\n{\n#if defined(unix) || defined(__APPLE__)\n\tif (getenv(\"HOME\") && *getenv(\"HOME\")) {\n\t        strcpy(filename, getenv(\"HOME\"));\n\t\tstrcat(filename, \"/\");\n\t}\n\telse\n\t\tstrcpy(filename, \"\");\n\tstrcat(filename, \".bfgminer/\");\n\tmkdir(filename, 0777);\n#else\n\tstrcpy(filename, \"\");\n#endif\n\tstrcat(filename, def_conf);\n}\n\n#ifdef HAVE_CURSES\nstatic void set_options(void)\n{\n\tint selected;\n\tchar input;\n\n\timmedok(logwin, true);\n\tloginput_mode(8);\nretry:\n\twlogprint(\"\\n[L]ongpoll: %s\\n\", want_longpoll ? \"On\" : \"Off\");\n\twlogprint(\"[Q]ueue: %d\\n[S]cantime: %d\\n[E]xpiry: %d\\n[R]etries: %d\\n\"\n\t\t  \"[W]rite config file\\n[B]FGMiner restart\\n\",\n\t\topt_queue, opt_scantime, opt_expiry, opt_retries);\n\twlogprint(\"Select an option or any other key to return\\n\");\n\tlogwin_update();\n\tinput = getch();\n\n\tif (!strncasecmp(&input, \"q\", 1)) {\n\t\tselected = curses_int(\"Extra work items to queue\");\n\t\tif (selected < 0 || selected > 9999) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\topt_queue = selected;\n\t\tgoto retry;\n\t} else if (!strncasecmp(&input, \"l\", 1)) {\n\t\tif (want_longpoll)\n\t\t\tstop_longpoll();\n\t\telse\n\t\t\tstart_longpoll();\n\t\tapplog(LOG_WARNING, \"Longpoll %s\", want_longpoll ? \"enabled\" : \"disabled\");\n\t\tgoto retry;\n\t} else if  (!strncasecmp(&input, \"s\", 1)) {\n\t\tselected = curses_int(\"Set scantime in seconds\");\n\t\tif (selected < 0 || selected > 9999) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\topt_scantime = selected;\n\t\tgoto retry;\n\t} else if  (!strncasecmp(&input, \"e\", 1)) {\n\t\tselected = curses_int(\"Set expiry time in seconds\");\n\t\tif (selected < 0 || selected > 9999) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\topt_expiry = selected;\n\t\tgoto retry;\n\t} else if  (!strncasecmp(&input, \"r\", 1)) {\n\t\tselected = curses_int(\"Retries before failing (-1 infinite)\");\n\t\tif (selected < -1 || selected > 9999) {\n\t\t\twlogprint(\"Invalid selection\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\topt_retries = selected;\n\t\tgoto retry;\n\t} else if  (!strncasecmp(&input, \"w\", 1)) {\n\t\tFILE *fcfg;\n\t\tchar *str, filename[PATH_MAX], prompt[PATH_MAX + 50];\n\n\t\tdefault_save_file(filename);\n\t\tsnprintf(prompt, sizeof(prompt), \"Config filename to write (Enter for default) [%s]\", filename);\n\t\tstr = curses_input(prompt);\n\t\tif (str) {\n\t\t\tstruct stat statbuf;\n\n\t\t\tstrcpy(filename, str);\n\t\t\tfree(str);\n\t\t\tif (!stat(filename, &statbuf)) {\n\t\t\t\twlogprint(\"File exists, overwrite?\\n\");\n\t\t\t\tinput = getch();\n\t\t\t\tif (strncasecmp(&input, \"y\", 1))\n\t\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\tfcfg = fopen(filename, \"w\");\n\t\tif (!fcfg) {\n\t\t\twlogprint(\"Cannot open or create file\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\twrite_config(fcfg);\n\t\tfclose(fcfg);\n\t\tgoto retry;\n\n\t} else if (!strncasecmp(&input, \"b\", 1)) {\n\t\twlogprint(\"Are you sure?\\n\");\n\t\tinput = getch();\n\t\tif (!strncasecmp(&input, \"y\", 1))\n\t\t\tapp_restart();\n\t\telse\n\t\t\tclear_logwin();\n\t} else\n\t\tclear_logwin();\n\n\tloginput_mode(0);\n\timmedok(logwin, false);\n}\n\nint scan_serial(const char *);\n\nstatic\nvoid _managetui_msg(const char *repr, const char **msg)\n{\n\tif (*msg)\n\t{\n\t\tapplog(LOG_DEBUG, \"ManageTUI: %\"PRIpreprv\": %s\", repr, *msg);\n\t\twattron(logwin, A_BOLD);\n\t\twlogprint(\"%s\", *msg);\n\t\twattroff(logwin, A_BOLD);\n\t\t*msg = NULL;\n\t}\n\tlogwin_update();\n}\n\nvoid manage_device(void)\n{\n\tchar logline[256];\n\tconst char *msg = NULL;\n\tstruct cgpu_info *cgpu;\n\tconst struct device_drv *drv;\n\t\n\tselecting_device = true;\n\timmedok(logwin, true);\n\tloginput_mode(12);\n\t\ndevchange:\n\tif (unlikely(!total_devices))\n\t{\n\t\tclear_logwin();\n\t\twlogprint(\"(no devices)\\n\");\n\t\twlogprint(\"[Plus] Add device(s)  [Enter] Close device manager\\n\");\n\t\t_managetui_msg(\"(none)\", &msg);\n\t\tint input = getch();\n\t\tswitch (input)\n\t\t{\n\t\t\tcase '+':  case '=':  // add new device\n\t\t\t\tgoto addnew;\n\t\t\tdefault:\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t\n\tcgpu = devices[selected_device];\n\tdrv = cgpu->drv;\n\trefresh_devstatus();\n\t\nrefresh:\n\tclear_logwin();\n\twlogprint(\"Select processor to manage using up/down arrow keys\\n\");\n\t\n\tget_statline3(logline, sizeof(logline), cgpu, true, true);\n\twattron(logwin, A_BOLD);\n\twlogprint(\"%s\", logline);\n\twattroff(logwin, A_BOLD);\n\twlogprint(\"\\n\");\n\t\n\tif (cgpu->dev_manufacturer)\n\t\twlogprint(\"  %s from %s\\n\", (cgpu->dev_product ?: \"Device\"), cgpu->dev_manufacturer);\n\telse\n\tif (cgpu->dev_product)\n\t\twlogprint(\"  %s\\n\", cgpu->dev_product);\n\t\n\tif (cgpu->dev_serial)\n\t\twlogprint(\"Serial: %s\\n\", cgpu->dev_serial);\n\t\n\tif (cgpu->kname)\n\t\twlogprint(\"Kernel: %s\\n\", cgpu->kname);\n\t\n\tif (drv->proc_wlogprint_status && likely(cgpu->status != LIFE_INIT))\n\t\tdrv->proc_wlogprint_status(cgpu);\n\t\n\twlogprint(\"\\n\");\n\t// TODO: Last share at TIMESTAMP on pool N\n\t// TODO: Custom device info/commands\n\tif (cgpu->deven != DEV_ENABLED)\n\t\twlogprint(\"[E]nable \");\n\tif (cgpu->deven != DEV_DISABLED)\n\t\twlogprint(\"[D]isable \");\n\tif (drv->identify_device)\n\t\twlogprint(\"[I]dentify \");\n\tif (drv->proc_tui_wlogprint_choices && likely(cgpu->status != LIFE_INIT))\n\t\tdrv->proc_tui_wlogprint_choices(cgpu);\n\twlogprint(\"\\n\");\n\twlogprint(\"[Slash] Find processor  [Plus] Add device(s)  [Enter] Close device manager\\n\");\n\t_managetui_msg(cgpu->proc_repr, &msg);\n\t\n\twhile (true)\n\t{\n\t\tint input = getch();\n\t\tapplog(LOG_DEBUG, \"ManageTUI: %\"PRIpreprv\": (choice %d)\", cgpu->proc_repr, input);\n\t\tswitch (input) {\n\t\t\tcase 'd': case 'D':\n\t\t\t\tif (cgpu->deven == DEV_DISABLED)\n\t\t\t\t\tmsg = \"Processor already disabled\\n\";\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcgpu->deven = DEV_DISABLED;\n\t\t\t\t\tmsg = \"Processor being disabled\\n\";\n\t\t\t\t}\n\t\t\t\tgoto refresh;\n\t\t\tcase 'e': case 'E':\n\t\t\t\tif (cgpu->deven == DEV_ENABLED)\n\t\t\t\t\tmsg = \"Processor already enabled\\n\";\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tproc_enable(cgpu);\n\t\t\t\t\tmsg = \"Processor being enabled\\n\";\n\t\t\t\t}\n\t\t\t\tgoto refresh;\n\t\t\tcase 'i': case 'I':\n\t\t\t\tif (drv->identify_device && drv->identify_device(cgpu))\n\t\t\t\t\tmsg = \"Identify command sent\\n\";\n\t\t\t\telse\n\t\t\t\t\tgoto key_default;\n\t\t\t\tgoto refresh;\n\t\t\tcase KEY_DOWN:\n\t\t\t\tif (selected_device >= total_devices - 1)\n\t\t\t\t\tbreak;\n\t\t\t\t++selected_device;\n\t\t\t\tgoto devchange;\n\t\t\tcase KEY_UP:\n\t\t\t\tif (selected_device <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\t--selected_device;\n\t\t\t\tgoto devchange;\n\t\t\tcase KEY_NPAGE:\n\t\t\t{\n\t\t\t\tif (selected_device >= total_devices - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tstruct cgpu_info *mdev = devices[selected_device]->device;\n\t\t\t\tdo {\n\t\t\t\t\t++selected_device;\n\t\t\t\t} while (devices[selected_device]->device == mdev && selected_device < total_devices - 1);\n\t\t\t\tgoto devchange;\n\t\t\t}\n\t\t\tcase KEY_PPAGE:\n\t\t\t{\n\t\t\t\tif (selected_device <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstruct cgpu_info *mdev = devices[selected_device]->device;\n\t\t\t\tdo {\n\t\t\t\t\t--selected_device;\n\t\t\t\t} while (devices[selected_device]->device == mdev && selected_device > 0);\n\t\t\t\tgoto devchange;\n\t\t\t}\n\t\t\tcase '/':  case '?':  // find device\n\t\t\t{\n\t\t\t\tstatic char *pattern = NULL;\n\t\t\t\tchar *newpattern = curses_input(\"Enter pattern\");\n\t\t\t\tif (newpattern)\n\t\t\t\t{\n\t\t\t\t\tfree(pattern);\n\t\t\t\t\tpattern = newpattern;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (!pattern)\n\t\t\t\t\tpattern = calloc(1, 1);\n\t\t\t\tint match = cgpu_search(pattern, selected_device + 1);\n\t\t\t\tif (match == -1)\n\t\t\t\t{\n\t\t\t\t\tmsg = \"Couldn't find device\\n\";\n\t\t\t\t\tgoto refresh;\n\t\t\t\t}\n\t\t\t\tselected_device = match;\n\t\t\t\tgoto devchange;\n\t\t\t}\n\t\t\tcase '+':  case '=':  // add new device\n\t\t\t{\naddnew:\n\t\t\t\tclear_logwin();\n\t\t\t\t_wlogprint(\n\t\t\t\t\t\"Enter \\\"auto\\\", \\\"all\\\", or a serial port to probe for mining devices.\\n\"\n\t\t\t\t\t\"Prefix by a driver name and colon to only probe a specific driver.\\n\"\n\t\t\t\t\t\"For example: erupter:\"\n#ifdef WIN32\n\t\t\t\t\t\"\\\\\\\\.\\\\COM40\"\n#elif defined(__APPLE__)\n\t\t\t\t\t\"/dev/cu.SLAB_USBtoUART\"\n#else\n\t\t\t\t\t\"/dev/ttyUSB39\"\n#endif\n\t\t\t\t\t\"\\n\"\n\t\t\t\t);\n\t\t\t\tchar *scanser = curses_input(\"Enter target\");\n\t\t\t\tif (scan_serial(scanser))\n\t\t\t\t{\n\t\t\t\t\tselected_device = total_devices - 1;\n\t\t\t\t\tmsg = \"Device scan succeeded\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmsg = \"No new devices found\\n\";\n\t\t\t\tgoto devchange;\n\t\t\t}\n\t\t\tcase 'Q': case 'q':\n\t\t\tcase KEY_BREAK: case KEY_BACKSPACE: case KEY_CANCEL: case KEY_CLOSE: case KEY_EXIT:\n\t\t\tcase '\\x1b':  // ESC\n\t\t\tcase KEY_ENTER:\n\t\t\tcase '\\r':  // Ctrl-M on Windows, with nonl\n#ifdef PADENTER\n\t\t\tcase PADENTER:  // pdcurses, used by Enter key on Windows with nonl\n#endif\n\t\t\tcase '\\n':\n\t\t\t\tgoto out;\n\t\t\tdefault:\n\t\t\t\t;\nkey_default:\n\t\t\t\tif (drv->proc_tui_handle_choice && likely(drv_ready(cgpu)))\n\t\t\t\t{\n\t\t\t\t\tmsg = drv->proc_tui_handle_choice(cgpu, input);\n\t\t\t\t\tif (msg)\n\t\t\t\t\t\tgoto refresh;\n\t\t\t\t}\n\t\t}\n\t}\n\nout:\n\tselecting_device = false;\n\tloginput_mode(0);\n\timmedok(logwin, false);\n}\n\nvoid show_help(void)\n{\n\tloginput_mode(11);\n\t\n\t// NOTE: wlogprint is a macro with a buffer limit\n\t_wlogprint(\n\t\t\"LU: oldest explicit work update currently being used for new work\\n\"\n\t\t\"ST: work in queue              | F: network fails   | NB: new blocks detected\\n\"\n\t\t\"AS: shares being submitted     | BW: bandwidth (up/down)\\n\"\n\t\t\"E: # shares * diff per 2kB bw  | I: expected income | BS: best share ever found\\n\"\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_BTEE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_BTEE  U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\tU8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE U8_HLINE\n\t\t\"\\n\"\n\t\t\"devices/processors hashing (only for totals line), hottest temperature\\n\"\n\t);\n\twlogprint(\n\t\t\"hashrates: %ds decaying / all-time average / all-time average (effective)\\n\"\n\t\t, opt_log_interval);\n\t_wlogprint(\n\t\t\"A: accepted shares | R: rejected+discarded(% of total)\\n\"\n\t\t\"HW: hardware errors / % nonces invalid\\n\"\n\t\t\"\\n\"\n\t\t\"Press any key to clear\"\n\t);\n\t\n\tlogwin_update();\n\tgetch();\n\t\n\tloginput_mode(0);\n}\n\nstatic void *input_thread(void __maybe_unused *userdata)\n{\n\tRenameThread(\"input\");\n\n\tif (!curses_active)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tint input;\n\n\t\tinput = getch();\n\t\tswitch (input) {\n\t\t\tcase 'h': case 'H': case '?':\n\t\t\tcase KEY_F(1):\n\t\t\t\tshow_help();\n\t\t\t\tbreak;\n\t\tcase 'q': case 'Q':\n\t\t\tkill_work();\n\t\t\treturn NULL;\n\t\tcase 'd': case 'D':\n\t\t\tdisplay_options();\n\t\t\tbreak;\n\t\tcase 'm': case 'M':\n\t\t\tmanage_device();\n\t\t\tbreak;\n\t\tcase 'p': case 'P':\n\t\t\tdisplay_pools();\n\t\t\tbreak;\n\t\tcase 's': case 'S':\n\t\t\tset_options();\n\t\t\tbreak;\n#ifdef HAVE_CURSES\n\t\tcase KEY_DOWN:\n\t\t{\n\t\t\tconst int visible_lines = logcursor - devcursor;\n\t\t\tconst int invisible_lines = total_lines - visible_lines;\n\t\t\tif (devsummaryYOffset <= -invisible_lines)\n\t\t\t\tbreak;\n\t\t\tdevsummaryYOffset -= 2;\n\t\t}\n\t\tcase KEY_UP:\n\t\t\tif (devsummaryYOffset == 0)\n\t\t\t\tbreak;\n\t\t\t++devsummaryYOffset;\n\t\t\trefresh_devstatus();\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\n\t\t{\n\t\t\tconst int visible_lines = logcursor - devcursor;\n\t\t\tconst int invisible_lines = total_lines - visible_lines;\n\t\t\tif (devsummaryYOffset - visible_lines <= -invisible_lines)\n\t\t\t\tdevsummaryYOffset = -invisible_lines;\n\t\t\telse\n\t\t\t\tdevsummaryYOffset -= visible_lines;\n\t\t\trefresh_devstatus();\n\t\t\tbreak;\n\t\t}\n\t\tcase KEY_PPAGE:\n\t\t{\n\t\t\tconst int visible_lines = logcursor - devcursor;\n\t\t\tif (devsummaryYOffset + visible_lines >= 0)\n\t\t\t\tdevsummaryYOffset = 0;\n\t\t\telse\n\t\t\t\tdevsummaryYOffset += visible_lines;\n\t\t\trefresh_devstatus();\n\t\t\tbreak;\n\t\t}\n#endif\n\t\t}\n\t\tif (opt_realquiet) {\n\t\t\tdisable_curses();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n#endif\n\nstatic void *api_thread(void *userdata)\n{\n\tstruct thr_info *mythr = userdata;\n\n\tpthread_detach(pthread_self());\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\n\tRenameThread(\"rpc\");\n\n\tapi(api_thr_id);\n\n\tmythr->has_pth = false;\n\n\treturn NULL;\n}\n\nvoid thread_reportin(struct thr_info *thr)\n{\n\tcgtime(&thr->last);\n\tthr->cgpu->status = LIFE_WELL;\n\tthr->getwork = 0;\n\tthr->cgpu->device_last_well = time(NULL);\n}\n\nvoid thread_reportout(struct thr_info *thr)\n{\n\tthr->getwork = time(NULL);\n}\n\nstatic void hashmeter(int thr_id, struct timeval *diff,\n\t\t      uint64_t hashes_done)\n{\n\tchar logstatusline[256];\n\tstruct timeval temp_tv_end, total_diff;\n\tdouble secs;\n\tdouble local_secs;\n\tstatic double local_mhashes_done = 0;\n\tdouble local_mhashes = (double)hashes_done / 1000000.0;\n\tbool showlog = false;\n\tchar cHr[ALLOC_H2B_NOUNIT+1], aHr[ALLOC_H2B_NOUNIT+1], uHr[ALLOC_H2B_SPACED+3+1];\n\tchar rejpcbuf[6];\n\tchar bnbuf[6];\n\tstruct thr_info *thr;\n\n\t/* Update the last time this thread reported in */\n\tif (thr_id >= 0) {\n\t\tthr = get_thread(thr_id);\n\t\tcgtime(&(thr->last));\n\t\tthr->cgpu->device_last_well = time(NULL);\n\t}\n\n\tsecs = (double)diff->tv_sec + ((double)diff->tv_usec / 1000000.0);\n\n\t/* So we can call hashmeter from a non worker thread */\n\tif (thr_id >= 0) {\n\t\tstruct cgpu_info *cgpu = thr->cgpu;\n\t\tint threadobj = cgpu->threads ?: 1;\n\t\tdouble thread_rolling = 0.0;\n\t\tint i;\n\n\t\tapplog(LOG_DEBUG, \"[thread %d: %\"PRIu64\" hashes, %.1f khash/sec]\",\n\t\t\tthr_id, hashes_done, hashes_done / 1000 / secs);\n\n\t\t/* Rolling average for each thread and each device */\n\t\tdecay_time(&thr->rolling, local_mhashes / secs, secs);\n\t\tfor (i = 0; i < threadobj; i++)\n\t\t\tthread_rolling += cgpu->thr[i]->rolling;\n\n\t\tmutex_lock(&hash_lock);\n\t\tdecay_time(&cgpu->rolling, thread_rolling, secs);\n\t\tcgpu->total_mhashes += local_mhashes;\n\t\tmutex_unlock(&hash_lock);\n\n\t\t// If needed, output detailed, per-device stats\n\t\tif (want_per_device_stats) {\n\t\t\tstruct timeval now;\n\t\t\tstruct timeval elapsed;\n\t\t\tstruct timeval *last_msg_tv = opt_show_procs ? &thr->cgpu->last_message_tv : &thr->cgpu->device->last_message_tv;\n\n\t\t\tcgtime(&now);\n\t\t\ttimersub(&now, last_msg_tv, &elapsed);\n\t\t\tif (opt_log_interval <= elapsed.tv_sec) {\n\t\t\t\tstruct cgpu_info *cgpu = thr->cgpu;\n\t\t\t\tchar logline[255];\n\n\t\t\t\t*last_msg_tv = now;\n\n\t\t\t\tget_statline(logline, sizeof(logline), cgpu);\n\t\t\t\tif (!curses_active) {\n\t\t\t\t\tprintf(\"\\n%s\\r\", logline);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t} else\n\t\t\t\t\tapplog(LOG_INFO, \"%s\", logline);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Totals are updated by all threads so can race without locking */\n\tmutex_lock(&hash_lock);\n\tcgtime(&temp_tv_end);\n\t\n\ttimersub(&temp_tv_end, &total_tv_start, &total_diff);\n\ttotal_secs = (double)total_diff.tv_sec + ((double)total_diff.tv_usec / 1000000.0);\n\t\n\ttimersub(&temp_tv_end, &total_tv_end, &total_diff);\n\n\ttotal_mhashes_done += local_mhashes;\n\tlocal_mhashes_done += local_mhashes;\n\t/* Only update with opt_log_interval */\n\tif (total_diff.tv_sec < opt_log_interval)\n\t\tgoto out_unlock;\n\tshowlog = true;\n\tcgtime(&total_tv_end);\n\n\tlocal_secs = (double)total_diff.tv_sec + ((double)total_diff.tv_usec / 1000000.0);\n\tdecay_time(&total_rolling, local_mhashes_done / local_secs, local_secs);\n\tglobal_hashrate = ((unsigned long long)lround(total_rolling)) * 1000000;\n\n\tdouble wtotal = (total_diff_accepted + total_diff_rejected + total_diff_stale);\n\t\n\tmulti_format_unit_array2(\n\t\t((char*[]){cHr, aHr, uHr}),\n\t\t((size_t[]){sizeof(cHr), sizeof(aHr), sizeof(uHr)}),\n\t\ttrue, \"h/s\", H2B_SHORT,\n\t\t3,\n\t\t1e6*total_rolling,\n\t\t1e6*total_mhashes_done / total_secs,\n\t\tutility_to_hashrate(total_diff1 * (wtotal ? (total_diff_accepted / wtotal) : 1) * 60 / total_secs));\n\n\tint ui_accepted, ui_rejected, ui_stale;\n\tif (opt_weighed_stats)\n\t{\n\t\tui_accepted = total_diff_accepted;\n\t\tui_rejected = total_diff_rejected;\n\t\tui_stale = total_diff_stale;\n\t}\n\telse\n\t{\n\t\tui_accepted = total_accepted;\n\t\tui_rejected = total_rejected;\n\t\tui_stale = total_stale;\n\t}\n\t\n#ifdef HAVE_CURSES\n\tif (curses_active_locked()) {\n\t\tfloat temp = 0;\n\t\tstruct cgpu_info *proc, *last_working_dev = NULL;\n\t\tint i, working_devs = 0, working_procs = 0;\n\t\tint divx;\n\t\tbool bad = false;\n\t\t\n\t\t// Find the highest temperature of all processors\n\t\tfor (i = 0; i < total_devices; ++i)\n\t\t{\n\t\t\tproc = get_devices(i);\n\t\t\t\n\t\t\tif (proc->temp > temp)\n\t\t\t\ttemp = proc->temp;\n\t\t\t\n\t\t\tif (unlikely(proc->deven == DEV_DISABLED))\n\t\t\t\t;  // Just need to block it off from both conditions\n\t\t\telse\n\t\t\tif (likely(proc->status == LIFE_WELL && proc->deven == DEV_ENABLED))\n\t\t\t{\n\t\t\t\tif (proc->rolling > .1)\n\t\t\t\t{\n\t\t\t\t\t++working_procs;\n\t\t\t\t\tif (proc->device != last_working_dev)\n\t\t\t\t\t{\n\t\t\t\t\t\t++working_devs;\n\t\t\t\t\t\tlast_working_dev = proc->device;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tbad = true;\n\t\t}\n\t\t\n\t\tif (working_devs == working_procs)\n\t\t\tsnprintf(statusline, sizeof(statusline), \"%s%d        \", bad ? U8_BAD_START : \"\", working_devs);\n\t\telse\n\t\t\tsnprintf(statusline, sizeof(statusline), \"%s%d/%d     \", bad ? U8_BAD_START : \"\", working_devs, working_procs);\n\t\t\n\t\tdivx = 7;\n\t\tif (opt_show_procs && !opt_compact)\n\t\t\tdivx += max_lpdigits;\n\t\t\n\t\tif (bad)\n\t\t{\n\t\t\tdivx += sizeof(U8_BAD_START)-1;\n\t\t\tstrcpy(&statusline[divx], U8_BAD_END);\n\t\t\tdivx += sizeof(U8_BAD_END)-1;\n\t\t}\n\t\t\n\t\ttemperature_column(&statusline[divx], sizeof(statusline)-divx, true, &temp);\n\t\t\n\t\tformat_statline(statusline, sizeof(statusline),\n\t\t                cHr, aHr,\n\t\t                uHr,\n\t\t                ui_accepted,\n\t\t                ui_rejected,\n\t\t                ui_stale,\n\t\t                total_diff_rejected + total_diff_stale, total_diff_accepted,\n\t\t                hw_errors,\n\t\t                total_bad_diff1, total_bad_diff1 + total_diff1);\n\t\tunlock_curses();\n\t}\n#endif\n\t\n\t// Add a space\n\tmemmove(&uHr[6], &uHr[5], strlen(&uHr[5]) + 1);\n\tuHr[5] = ' ';\n\t\n\tpercentf4(rejpcbuf, sizeof(rejpcbuf), total_diff_rejected + total_diff_stale, total_diff_accepted);\n\tpercentf4(bnbuf, sizeof(bnbuf), total_bad_diff1, total_diff1);\n\t\n\tsnprintf(logstatusline, sizeof(logstatusline),\n\t         \"%s%ds:%s avg:%s u:%s | A:%d R:%d+%d(%s) HW:%d/%s\",\n\t\twant_per_device_stats ? \"ALL \" : \"\",\n\t\topt_log_interval,\n\t\tcHr, aHr,\n\t\tuHr,\n\t\tui_accepted,\n\t\tui_rejected,\n\t\tui_stale,\n\t\trejpcbuf,\n\t\thw_errors,\n\t\tbnbuf\n\t);\n\n\n\tlocal_mhashes_done = 0;\nout_unlock:\n\tmutex_unlock(&hash_lock);\n\n\tif (showlog) {\n\t\tif (!curses_active) {\n\t\t\tif (want_per_device_stats)\n\t\t\t\tprintf(\"\\n%s\\r\", logstatusline);\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst int logstatusline_len = strlen(logstatusline);\n\t\t\t\tint padding;\n\t\t\t\tif (last_logstatusline_len > logstatusline_len)\n\t\t\t\t\tpadding = (last_logstatusline_len - logstatusline_len);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpadding = 0;\n\t\t\t\t\tif (last_logstatusline_len == -1)\n\t\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tprintf(\"%s%*s\\r\", logstatusline, padding, \"\");\n\t\t\t\tlast_logstatusline_len = logstatusline_len;\n\t\t\t}\n\t\t\tfflush(stdout);\n\t\t} else\n\t\t\tapplog(LOG_INFO, \"%s\", logstatusline);\n\t}\n}\n\nvoid hashmeter2(struct thr_info *thr)\n{\n\tstruct timeval tv_now, tv_elapsed;\n\t\n\ttimerclear(&thr->tv_hashes_done);\n\t\n\tcgtime(&tv_now);\n\ttimersub(&tv_now, &thr->tv_lastupdate, &tv_elapsed);\n\t/* Update the hashmeter at most 5 times per second */\n\tif ((thr->hashes_done && (tv_elapsed.tv_sec > 0 || tv_elapsed.tv_usec > 200000)) ||\n\t    tv_elapsed.tv_sec >= opt_log_interval) {\n\t\thashmeter(thr->id, &tv_elapsed, thr->hashes_done);\n\t\tthr->hashes_done = 0;\n\t\tthr->tv_lastupdate = tv_now;\n\t}\n}\n\nstatic void stratum_share_result(json_t *val, json_t *res_val, json_t *err_val,\n\t\t\t\t struct stratum_share *sshare)\n{\n\tstruct work *work = sshare->work;\n\n\tshare_result(val, res_val, err_val, work, false, \"\");\n}\n\n/* Parses stratum json responses and tries to find the id that the request\n * matched to and treat it accordingly. */\nbool parse_stratum_response(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *err_val, *res_val, *id_val;\n\tstruct stratum_share *sshare;\n\tjson_error_t err;\n\tbool ret = false;\n\tint id;\n\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tid_val = json_object_get(val, \"id\");\n\n\tif (json_is_null(id_val) || !id_val) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC non method decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tif (!json_is_integer(id_val)) {\n\t\tif (json_is_string(id_val)\n\t\t && !strncmp(json_string_value(id_val), \"txlist\", 6))\n\t\t{\n\t\t\tconst bool is_array = json_is_array(res_val);\n\t\t\tapplog(LOG_DEBUG, \"Received %s for pool %u job %s\",\n\t\t\t       is_array ? \"transaction list\" : \"no-transaction-list response\",\n\t\t\t       pool->pool_no, &json_string_value(id_val)[6]);\n\t\t\tif (!is_array)\n\t\t\t{\n\t\t\t\t// No need to wait for a timeout\n\t\t\t\ttimer_unset(&pool->swork.tv_transparency);\n\t\t\t\tpool_set_opaque(pool, true);\n\t\t\t\tgoto fishy;\n\t\t\t}\n\t\t\tif (strcmp(json_string_value(id_val) + 6, pool->swork.job_id))\n\t\t\t\t// We only care about a transaction list for the current job id\n\t\t\t\tgoto fishy;\n\t\t\t\n\t\t\t// Check that the transactions actually hash to the merkle links\n\t\t\t{\n\t\t\t\tunsigned maxtx = 1 << pool->swork.merkles;\n\t\t\t\tunsigned mintx = maxtx >> 1;\n\t\t\t\t--maxtx;\n\t\t\t\tunsigned acttx = (unsigned)json_array_size(res_val);\n\t\t\t\tif (acttx < mintx || acttx > maxtx) {\n\t\t\t\t\tapplog(LOG_WARNING, \"Pool %u is sending mismatched block contents to us (%u is not %u-%u)\",\n\t\t\t\t\t       pool->pool_no, acttx, mintx, maxtx);\n\t\t\t\t\tgoto fishy;\n\t\t\t\t}\n\t\t\t\t// TODO: Check hashes match actual merkle links\n\t\t\t}\n\n\t\t\tpool_set_opaque(pool, false);\n\t\t\ttimer_unset(&pool->swork.tv_transparency);\n\nfishy:\n\t\t\tret = true;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tid = json_integer_value(id_val);\n\n\tmutex_lock(&sshare_lock);\n\tHASH_FIND_INT(stratum_shares, &id, sshare);\n\tif (sshare)\n\t\tHASH_DEL(stratum_shares, sshare);\n\tmutex_unlock(&sshare_lock);\n\n\tif (!sshare) {\n\t\tdouble pool_diff;\n\n\t\t/* Since the share is untracked, we can only guess at what the\n\t\t * work difficulty is based on the current pool diff. */\n\t\tcg_rlock(&pool->data_lock);\n\t\tpool_diff = target_diff(pool->swork.target);\n\t\tcg_runlock(&pool->data_lock);\n\n\t\tif (json_is_true(res_val)) {\n\t\t\tstruct mining_goal_info * const goal = pool->goal;\n\t\t\t\n\t\t\tapplog(LOG_NOTICE, \"Accepted untracked stratum share from pool %d\", pool->pool_no);\n\n\t\t\t/* We don't know what device this came from so we can't\n\t\t\t * attribute the work to the relevant cgpu */\n\t\t\tmutex_lock(&stats_lock);\n\t\t\ttotal_accepted++;\n\t\t\tpool->accepted++;\n\t\t\ttotal_diff_accepted += pool_diff;\n\t\t\tpool->diff_accepted += pool_diff;\n\t\t\tgoal->diff_accepted += pool_diff;\n\t\t\tmutex_unlock(&stats_lock);\n\t\t} else {\n\t\t\tapplog(LOG_NOTICE, \"Rejected untracked stratum share from pool %d\", pool->pool_no);\n\n\t\t\tmutex_lock(&stats_lock);\n\t\t\ttotal_rejected++;\n\t\t\tpool->rejected++;\n\t\t\ttotal_diff_rejected += pool_diff;\n\t\t\tpool->diff_rejected += pool_diff;\n\t\t\tmutex_unlock(&stats_lock);\n\t\t}\n\t\tgoto out;\n\t}\n\telse {\n\t\tmutex_lock(&submitting_lock);\n\t\t--total_submitting;\n\t\tmutex_unlock(&submitting_lock);\n\t}\n\tstratum_share_result(val, res_val, err_val, sshare);\n\tfree_work(sshare->work);\n\tfree(sshare);\n\n\tret = true;\nout:\n\tif (val)\n\t\tjson_decref(val);\n\n\treturn ret;\n}\n\nstatic void shutdown_stratum(struct pool *pool)\n{\n\t// Shut down Stratum as if we never had it\n\tpool->stratum_active = false;\n\tpool->stratum_init = false;\n\tpool->has_stratum = false;\n\tshutdown(pool->sock, SHUT_RDWR);\n\tfree(pool->stratum_url);\n\tif (pool->sockaddr_url == pool->stratum_url)\n\t\tpool->sockaddr_url = NULL;\n\tpool->stratum_url = NULL;\n}\n\nvoid clear_stratum_shares(struct pool *pool)\n{\n\tint my_mining_threads = mining_threads;  // Cached outside of locking\n\tstruct stratum_share *sshare, *tmpshare;\n\tstruct work *work;\n\tstruct cgpu_info *cgpu;\n\tdouble diff_cleared = 0;\n\tdouble thr_diff_cleared[my_mining_threads];\n\tint cleared = 0;\n\tint thr_cleared[my_mining_threads];\n\t\n\t// NOTE: This is per-thread rather than per-device to avoid getting devices lock in stratum_shares loop\n\tfor (int i = 0; i < my_mining_threads; ++i)\n\t{\n\t\tthr_diff_cleared[i] = 0;\n\t\tthr_cleared[i] = 0;\n\t}\n\n\tmutex_lock(&sshare_lock);\n\tHASH_ITER(hh, stratum_shares, sshare, tmpshare) {\n\t\twork = sshare->work;\n\t\tif (sshare->work->pool == pool && work->thr_id < my_mining_threads) {\n\t\t\tHASH_DEL(stratum_shares, sshare);\n\t\t\t\n\t\t\tsharelog(\"disconnect\", work);\n\t\t\t\n\t\t\tdiff_cleared += sshare->work->work_difficulty;\n\t\t\tthr_diff_cleared[work->thr_id] += work->work_difficulty;\n\t\t\t++thr_cleared[work->thr_id];\n\t\t\tfree_work(sshare->work);\n\t\t\tfree(sshare);\n\t\t\tcleared++;\n\t\t}\n\t}\n\tmutex_unlock(&sshare_lock);\n\n\tif (cleared) {\n\t\tapplog(LOG_WARNING, \"Lost %d shares due to stratum disconnect on pool %d\", cleared, pool->pool_no);\n\t\tmutex_lock(&stats_lock);\n\t\tpool->stale_shares += cleared;\n\t\ttotal_stale += cleared;\n\t\tpool->diff_stale += diff_cleared;\n\t\ttotal_diff_stale += diff_cleared;\n\t\tfor (int i = 0; i < my_mining_threads; ++i)\n\t\t\tif (thr_cleared[i])\n\t\t\t{\n\t\t\t\tcgpu = get_thr_cgpu(i);\n\t\t\t\tcgpu->diff_stale += thr_diff_cleared[i];\n\t\t\t\tcgpu->stale += thr_cleared[i];\n\t\t\t}\n\t\tmutex_unlock(&stats_lock);\n\n\t\tmutex_lock(&submitting_lock);\n\t\ttotal_submitting -= cleared;\n\t\tmutex_unlock(&submitting_lock);\n\t}\n}\n\nstatic void resubmit_stratum_shares(struct pool *pool)\n{\n\tstruct stratum_share *sshare, *tmpshare;\n\tstruct work *work;\n\tunsigned resubmitted = 0;\n\n\tmutex_lock(&sshare_lock);\n\tmutex_lock(&submitting_lock);\n\tHASH_ITER(hh, stratum_shares, sshare, tmpshare) {\n\t\tif (sshare->work->pool != pool)\n\t\t\tcontinue;\n\t\t\n\t\tHASH_DEL(stratum_shares, sshare);\n\t\t\n\t\twork = sshare->work;\n\t\tDL_APPEND(submit_waiting, work);\n\t\t\n\t\tfree(sshare);\n\t\t++resubmitted;\n\t}\n\tmutex_unlock(&submitting_lock);\n\tmutex_unlock(&sshare_lock);\n\n\tif (resubmitted) {\n\t\tnotifier_wake(submit_waiting_notifier);\n\t\tapplog(LOG_DEBUG, \"Resubmitting %u shares due to stratum disconnect on pool %u\", resubmitted, pool->pool_no);\n\t}\n}\n\nstatic void clear_pool_work(struct pool *pool)\n{\n\tstruct work *work, *tmp;\n\tint cleared = 0;\n\n\tmutex_lock(stgd_lock);\n\tHASH_ITER(hh, staged_work, work, tmp) {\n\t\tif (work->pool == pool) {\n\t\t\tunstage_work(work);\n\t\t\tfree_work(work);\n\t\t\tcleared++;\n\t\t}\n\t}\n\tmutex_unlock(stgd_lock);\n}\n\nstatic int cp_prio(void)\n{\n\tint prio;\n\n\tcg_rlock(&control_lock);\n\tprio = currentpool->prio;\n\tcg_runlock(&control_lock);\n\n\treturn prio;\n}\n\n/* We only need to maintain a secondary pool connection when we need the\n * capacity to get work from the backup pools while still on the primary */\nstatic bool cnx_needed(struct pool *pool)\n{\n\tstruct pool *cp;\n\n\t// We want to keep a connection open for rejecting or misbehaving pools, to detect when/if they change their tune\n\tif (pool->enabled == POOL_DISABLED)\n\t\treturn false;\n\n\t/* Idle stratum pool needs something to kick it alive again */\n\tif (pool->has_stratum && pool->idle)\n\t\treturn true;\n\n\t/* Getwork pools without opt_fail_only need backup pools up to be able\n\t * to leak shares */\n\tcp = current_pool();\n\tif (pool_actively_desired(pool, cp))\n\t\treturn true;\n\tif (!pool_localgen(cp) && (!opt_fail_only || !cp->hdr_path))\n\t\treturn true;\n\n\t/* Keep the connection open to allow any stray shares to be submitted\n\t * on switching pools for 2 minutes. */\n\tif (timer_elapsed(&pool->tv_last_work_time, NULL) < 120)\n\t\treturn true;\n\n\t/* If the pool has only just come to life and is higher priority than\n\t * the current pool keep the connection open so we can fail back to\n\t * it. */\n\tif (pool_strategy == POOL_FAILOVER && pool->prio < cp_prio())\n\t\treturn true;\n\n\tif (pool_unworkable(cp))\n\t\treturn true;\n\t\n\t/* We've run out of work, bring anything back to life. */\n\tif (no_work)\n\t\treturn true;\n\t\n\t// If the current pool lacks its own block change detection, see if we are needed for that\n\tif (pool_active_lp_pool(cp) == pool)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void wait_lpcurrent(struct pool *pool);\nstatic void pool_resus(struct pool *pool);\n\nstatic void stratum_resumed(struct pool *pool)\n{\n\tif (!pool->stratum_notify)\n\t\treturn;\n\tif (pool_tclear(pool, &pool->idle)) {\n\t\tapplog(LOG_INFO, \"Stratum connection to pool %d resumed\", pool->pool_no);\n\t\tpool_resus(pool);\n\t}\n}\n\nstatic bool supports_resume(struct pool *pool)\n{\n\tbool ret;\n\n\tcg_rlock(&pool->data_lock);\n\tret = (pool->sessionid != NULL);\n\tcg_runlock(&pool->data_lock);\n\n\treturn ret;\n}\n\nstatic bool pools_active;\n\n/* One stratum thread per pool that has stratum waits on the socket checking\n * for new messages and for the integrity of the socket connection. We reset\n * the connection based on the integrity of the receive side only as the send\n * side will eventually expire data it fails to send. */\nstatic void *stratum_thread(void *userdata)\n{\n\tstruct pool *pool = (struct pool *)userdata;\n\n\tpthread_detach(pthread_self());\n\n\tchar threadname[20];\n\tsnprintf(threadname, 20, \"stratum%u\", pool->pool_no);\n\tRenameThread(threadname);\n\n\tsrand(time(NULL) + (intptr_t)userdata);\n\n\twhile (42) {\n\t\tstruct timeval timeout;\n\t\tint sel_ret;\n\t\tfd_set rd;\n\t\tchar *s;\n\t\tint sock;\n\n\t\tif (unlikely(!pool->has_stratum))\n\t\t\tbreak;\n\n\t\t/* Check to see whether we need to maintain this connection\n\t\t * indefinitely or just bring it up when we switch to this\n\t\t * pool */\n\t\twhile (true)\n\t\t{\n\t\t\tsock = pool->sock;\n\t\t\t\n\t\t\tif (sock == INVSOCK)\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %u: Invalid socket, suspending\",\n\t\t\t\t       pool->pool_no);\n\t\t\telse\n\t\t\tif (!sock_full(pool) && !cnx_needed(pool) && pools_active)\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %u: Connection not needed, suspending\",\n\t\t\t\t       pool->pool_no);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tsuspend_stratum(pool);\n\t\t\tclear_stratum_shares(pool);\n\t\t\tclear_pool_work(pool);\n\n\t\t\twait_lpcurrent(pool);\n\t\t\tif (!restart_stratum(pool)) {\n\t\t\t\tpool_died(pool);\n\t\t\t\twhile (!restart_stratum(pool)) {\n\t\t\t\t\tif (pool->removed)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tcgsleep_ms(30000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFD_ZERO(&rd);\n\t\tFD_SET(sock, &rd);\n\t\ttimeout.tv_sec = 120;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* If we fail to receive any notify messages for 2 minutes we\n\t\t * assume the connection has been dropped and treat this pool\n\t\t * as dead */\n\t\tif (!sock_full(pool) && (sel_ret = select(sock + 1, &rd, NULL, NULL, &timeout)) < 1) {\n\t\t\tapplog(LOG_DEBUG, \"Stratum select failed on pool %d with value %d\", pool->pool_no, sel_ret);\n\t\t\ts = NULL;\n\t\t} else\n\t\t\ts = recv_line(pool);\n\t\tif (!s) {\n\t\t\tif (!pool->has_stratum)\n\t\t\t\tbreak;\n\n\t\t\tapplog(LOG_NOTICE, \"Stratum connection to pool %d interrupted\", pool->pool_no);\n\t\t\tpool->getfail_occasions++;\n\t\t\ttotal_go++;\n\n\t\t\tmutex_lock(&pool->stratum_lock);\n\t\t\tpool->stratum_active = pool->stratum_notify = false;\n\t\t\tpool->sock = INVSOCK;\n\t\t\tmutex_unlock(&pool->stratum_lock);\n\n\t\t\t/* If the socket to our stratum pool disconnects, all\n\t\t\t * submissions need to be discarded or resent. */\n\t\t\tif (!supports_resume(pool))\n\t\t\t\tclear_stratum_shares(pool);\n\t\t\telse\n\t\t\t\tresubmit_stratum_shares(pool);\n\t\t\tclear_pool_work(pool);\n\t\t\tif (pool == current_pool())\n\t\t\t\trestart_threads();\n\n\t\t\tif (restart_stratum(pool))\n\t\t\t\tcontinue;\n\n\t\t\tshutdown_stratum(pool);\n\t\t\tpool_died(pool);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check this pool hasn't died while being a backup pool and\n\t\t * has not had its idle flag cleared */\n\t\tstratum_resumed(pool);\n\n\t\tif (!parse_method(pool, s) && !parse_stratum_response(pool, s))\n\t\t\tapplog(LOG_INFO, \"Unknown stratum msg: %s\", s);\n\t\tfree(s);\n\t\tif (pool->swork.clean) {\n\t\t\tstruct work *work = make_work();\n\n\t\t\t/* Generate a single work item to update the current\n\t\t\t * block database */\n\t\t\tpool->swork.clean = false;\n\t\t\tgen_stratum_work(pool, work);\n\n\t\t\t/* Try to extract block height from coinbase scriptSig */\n\t\t\tuint8_t *bin_height = &bytes_buf(&pool->swork.coinbase)[4 /*version*/ + 1 /*txin count*/ + 36 /*prevout*/ + 1 /*scriptSig len*/ + 1 /*push opcode*/];\n\t\t\tunsigned char cb_height_sz;\n\t\t\tcb_height_sz = bin_height[-1];\n\t\t\tif (cb_height_sz == 3) {\n\t\t\t\t// FIXME: The block number will overflow this by AD 2173\n\t\t\t\tstruct mining_goal_info * const goal = pool->goal;\n\t\t\t\tconst void * const prevblkhash = &work->data[4];\n\t\t\t\tuint32_t height = 0;\n\t\t\t\tmemcpy(&height, bin_height, 3);\n\t\t\t\theight = le32toh(height);\n\t\t\t\thave_block_height(goal, prevblkhash, height);\n\t\t\t}\n\n\t\t\tpool->swork.work_restart_id =\n\t\t\t++pool->work_restart_id;\n\t\t\tpool_update_work_restart_time(pool);\n\t\t\tif (test_work_current(work)) {\n\t\t\t\t/* Only accept a work update if this stratum\n\t\t\t\t * connection is from the current pool */\n\t\t\t\tstruct pool * const cp = current_pool();\n\t\t\t\tif (pool == cp)\n\t\t\t\t\trestart_threads();\n\t\t\t\t\n\t\t\t\tapplog(\n\t\t\t\t       ((!opt_quiet_work_updates) && pool_actively_in_use(pool, cp) ? LOG_NOTICE : LOG_DEBUG),\n\t\t\t\t       \"Stratum from pool %d requested work update\", pool->pool_no);\n\t\t\t} else\n\t\t\t\tapplog(LOG_NOTICE, \"Stratum from pool %d detected new block\", pool->pool_no);\n\t\t\tfree_work(work);\n\t\t}\n\n\t\tif (timer_passed(&pool->swork.tv_transparency, NULL)) {\n\t\t\t// More than 4 timmills past since requested transactions\n\t\t\ttimer_unset(&pool->swork.tv_transparency);\n\t\t\tpool_set_opaque(pool, true);\n\t\t}\n\t}\n\nout:\n\treturn NULL;\n}\n\nstatic void init_stratum_thread(struct pool *pool)\n{\n\tstruct mining_goal_info * const goal = pool->goal;\n\tgoal->have_longpoll = true;\n\n\tif (unlikely(pthread_create(&pool->stratum_thread, NULL, stratum_thread, (void *)pool)))\n\t\tquit(1, \"Failed to create stratum thread\");\n}\n\nstatic void *longpoll_thread(void *userdata);\n\nstatic bool stratum_works(struct pool *pool)\n{\n\tapplog(LOG_INFO, \"Testing pool %d stratum %s\", pool->pool_no, pool->stratum_url);\n\tif (!extract_sockaddr(pool->stratum_url, &pool->sockaddr_url, &pool->stratum_port))\n\t\treturn false;\n\n\tif (pool->stratum_active)\n\t\treturn true;\n\t\n\tif (!initiate_stratum(pool))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic\nbool pool_recently_got_work(struct pool * const pool, const struct timeval * const tvp_now)\n{\n\treturn (timer_isset(&pool->tv_last_work_time) && timer_elapsed(&pool->tv_last_work_time, tvp_now) < 60);\n}\n\nstatic bool pool_active(struct pool *pool, bool pinging)\n{\n\tstruct timeval tv_now, tv_getwork, tv_getwork_reply;\n\tbool ret = false;\n\tjson_t *val;\n\tCURL *curl = NULL;\n\tint rolltime;\n\tchar *rpc_req;\n\tstruct work *work;\n\tenum pool_protocol proto;\n\n\tif (pool->stratum_init)\n\t{\n\t\tif (pool->stratum_active)\n\t\t\treturn true;\n\t}\n\telse\n\tif (!pool->idle)\n\t{\n\t\ttimer_set_now(&tv_now);\n\t\tif (pool_recently_got_work(pool, &tv_now))\n\t\t\treturn true;\n\t}\n\t\n\tmutex_lock(&pool->pool_test_lock);\n\t\n\tif (pool->stratum_init)\n\t{\n\t\tret = pool->stratum_active;\n\t\tgoto out;\n\t}\n\t\n\ttimer_set_now(&tv_now);\n\t\n\tif (pool->idle)\n\t{\n\t\tif (timer_elapsed(&pool->tv_idle, &tv_now) < 30)\n\t\t\tgoto out;\n\t}\n\telse\n\tif (pool_recently_got_work(pool, &tv_now))\n\t{\n\t\tret = true;\n\t\tgoto out;\n\t}\n\t\n\t\tapplog(LOG_INFO, \"Testing pool %s\", pool->rpc_url);\n\n\t/* This is the central point we activate stratum when we can */\n\tcurl = curl_easy_init();\n\tif (unlikely(!curl)) {\n\t\tapplog(LOG_ERR, \"CURL initialisation failed\");\n\t\tgoto out;\n\t}\n\n\tif (!(want_gbt || want_getwork))\n\t\tgoto nohttp;\n\n\twork = make_work();\n\n\t/* Probe for GBT support on first pass */\n\tproto = want_gbt ? PLP_GETBLOCKTEMPLATE : PLP_GETWORK;\n\ntryagain:\n\trpc_req = prepare_rpc_req_probe(work, proto, NULL, pool);\n\twork->pool = pool;\n\tif (!rpc_req)\n\t\tgoto out;\n\n\tpool->probed = false;\n\tcgtime(&tv_getwork);\n\tval = json_rpc_call(curl, pool->rpc_url, pool->rpc_userpass, rpc_req,\n\t\t\ttrue, false, &rolltime, pool, false);\n\tcgtime(&tv_getwork_reply);\n\n\tfree(rpc_req);\n\n\t/* Detect if a http getwork pool has an X-Stratum header at startup,\n\t * and if so, switch to that in preference to getwork if it works */\n\tif (pool->stratum_url && want_stratum && pool_may_redirect_to(pool, pool->stratum_url) && (pool->has_stratum || stratum_works(pool))) {\n\t\tif (!pool->has_stratum) {\n\n\t\tapplog(LOG_NOTICE, \"Switching pool %d %s to %s\", pool->pool_no, pool->rpc_url, pool->stratum_url);\n\t\tif (!pool->rpc_url)\n\t\t\tpool_set_uri(pool, strdup(pool->stratum_url));\n\t\tpool->has_stratum = true;\n\n\t\t}\n\n\t\tfree_work(work);\n\t\tif (val)\n\t\t\tjson_decref(val);\n\nretry_stratum:\n\t\t;\n\t\t/* We create the stratum thread for each pool just after\n\t\t * successful authorisation. Once the init flag has been set\n\t\t * we never unset it and the stratum thread is responsible for\n\t\t * setting/unsetting the active flag */\n\t\tbool init = pool_tset(pool, &pool->stratum_init);\n\n\t\tif (!init) {\n\t\t\tret = initiate_stratum(pool) && auth_stratum(pool);\n\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tdetect_algo = 2;\n\t\t\t\tinit_stratum_thread(pool);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpool_tclear(pool, &pool->stratum_init);\n\t\t\t\tpool->tv_idle = tv_getwork_reply;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tret = pool->stratum_active;\n\t\tgoto out;\n\t}\n\telse if (pool->has_stratum)\n\t\tshutdown_stratum(pool);\n\n\tif (val) {\n\t\tbool rc;\n\t\tjson_t *res;\n\n\t\tres = json_object_get(val, \"result\");\n\t\tif ((!json_is_object(res)) || (proto == PLP_GETBLOCKTEMPLATE && !json_object_get(res, \"bits\")))\n\t\t\tgoto badwork;\n\n\t\twork->rolltime = rolltime;\n\t\trc = work_decode(pool, work, val);\n\t\tif (rc) {\n\t\t\tapplog(LOG_DEBUG, \"Successfully retrieved and deciphered work from pool %u %s\",\n\t\t\t       pool->pool_no, pool->rpc_url);\n\t\t\twork->pool = pool;\n\t\t\tcopy_time(&work->tv_getwork, &tv_getwork);\n\t\t\tcopy_time(&work->tv_getwork_reply, &tv_getwork_reply);\n\t\t\twork->getwork_mode = GETWORK_MODE_TESTPOOL;\n\t\t\tcalc_diff(work, 0);\n\n\t\t\tupdate_last_work(work);\n\n\t\t\tapplog(LOG_DEBUG, \"Pushing pooltest work to base pool\");\n\n\t\t\tstage_work(work);\n\t\t\ttotal_getworks++;\n\t\t\tpool->getwork_requested++;\n\t\t\tret = true;\n\t\t\tpool->tv_idle = tv_getwork_reply;\n\t\t} else {\nbadwork:\n\t\t\tjson_decref(val);\n\t\t\tapplog(LOG_DEBUG, \"Successfully retrieved but FAILED to decipher work from pool %u %s\",\n\t\t\t       pool->pool_no, pool->rpc_url);\n\t\t\tpool->proto = proto = pool_protocol_fallback(proto);\n\t\t\tif (PLP_NONE != proto)\n\t\t\t\tgoto tryagain;\n\t\t\tpool->tv_idle = tv_getwork_reply;\n\t\t\tfree_work(work);\n\t\t\tgoto out;\n\t\t}\n\t\tjson_decref(val);\n\n\t\tif (proto != pool->proto) {\n\t\t\tpool->proto = proto;\n\t\t\tapplog(LOG_INFO, \"Selected %s protocol for pool %u\", pool_protocol_name(proto), pool->pool_no);\n\t\t}\n\n\t\tif (pool->lp_url)\n\t\t\tgoto out;\n\n\t\t/* Decipher the longpoll URL, if any, and store it in ->lp_url */\n\n\t\tconst struct blktmpl_longpoll_req *lp;\n\t\tif (work->tr && (lp = blktmpl_get_longpoll(work->tr->tmpl))) {\n\t\t\t// NOTE: work_decode takes care of lp id\n\t\t\tpool->lp_url = lp->uri ? absolute_uri(lp->uri, pool->rpc_url) : pool->rpc_url;\n\t\t\tif (!pool->lp_url)\n\t\t\t{\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpool->lp_proto = PLP_GETBLOCKTEMPLATE;\n\t\t}\n\t\telse\n\t\tif (pool->hdr_path && want_getwork) {\n\t\t\tpool->lp_url = absolute_uri(pool->hdr_path, pool->rpc_url);\n\t\t\tif (!pool->lp_url)\n\t\t\t{\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpool->lp_proto = PLP_GETWORK;\n\t\t} else\n\t\t\tpool->lp_url = NULL;\n\n\t\tif (want_longpoll && !pool->lp_started) {\n\t\t\tpool->lp_started = true;\n\t\t\tif (unlikely(pthread_create(&pool->longpoll_thread, NULL, longpoll_thread, (void *)pool)))\n\t\t\t\tquit(1, \"Failed to create pool longpoll thread\");\n\t\t}\n\t} else if (PLP_NONE != (proto = pool_protocol_fallback(proto))) {\n\t\tpool->proto = proto;\n\t\tgoto tryagain;\n\t} else {\n\t\tpool->tv_idle = tv_getwork_reply;\n\t\tfree_work(work);\nnohttp:\n\t\t/* If we failed to parse a getwork, this could be a stratum\n\t\t * url without the prefix stratum+tcp:// so let's check it */\n\t\tif (extract_sockaddr(pool->rpc_url, &pool->sockaddr_url, &pool->stratum_port) && initiate_stratum(pool)) {\n\t\t\tpool->has_stratum = true;\n\t\t\tgoto retry_stratum;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"FAILED to retrieve work from pool %u %s\",\n\t\t       pool->pool_no, pool->rpc_url);\n\t\tif (!pinging)\n\t\t\tapplog(LOG_WARNING, \"Pool %u slow/down or URL or credentials invalid\", pool->pool_no);\n\t}\nout:\n\tif (curl)\n\t\tcurl_easy_cleanup(curl);\n\tmutex_unlock(&pool->pool_test_lock);\n\treturn ret;\n}\n\nstatic void pool_resus(struct pool *pool)\n{\n\tif (pool->enabled == POOL_ENABLED && pool_strategy == POOL_FAILOVER && pool->prio < cp_prio())\n\t\tapplog(LOG_WARNING, \"Pool %d %s alive, testing stability\", pool->pool_no, pool->rpc_url);\n\telse\n\t\tapplog(LOG_INFO, \"Pool %d %s alive\", pool->pool_no, pool->rpc_url);\n}\n\nstatic\nvoid *cmd_idle_thread(void * const __maybe_unused userp)\n{\n\tpthread_detach(pthread_self());\n\tRenameThread(\"cmd-idle\");\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\t\n\tsleep(opt_log_interval);\n\tpthread_testcancel();\n\trun_cmd(cmd_idle);\n\t\n\treturn NULL;\n}\n\nstatic struct work *hash_pop(struct cgpu_info * const proc)\n{\n\tint hc;\n\tstruct work *work, *work_found, *tmp;\n\tenum {\n\t\tHPWS_NONE,\n\t\tHPWS_LOWDIFF,\n\t\tHPWS_SPARE,\n\t\tHPWS_ROLLABLE,\n\t\tHPWS_PERFECT,\n\t} work_score = HPWS_NONE;\n\tbool did_cmd_idle = false;\n\tpthread_t cmd_idle_thr;\n\nretry:\n\tmutex_lock(stgd_lock);\n\twhile (true)\n\t{\n\t\twork_found = NULL;\n\t\twork_score = 0;\n\t\thc = HASH_COUNT(staged_work);\n\t\tHASH_ITER(hh, staged_work, work, tmp)\n\t\t{\n\t\t\tconst struct mining_algorithm * const work_malgo = work_mining_algorithm(work);\n\t\t\tconst float min_nonce_diff = drv_min_nonce_diff(proc->drv, proc, work_malgo);\n#define FOUND_WORK(score)  do{  \\\n\t\t\t\tif (work_score < score)  \\\n\t\t\t\t{  \\\n\t\t\t\t\twork_found = work;  \\\n\t\t\t\t\twork_score = score;  \\\n\t\t\t\t}  \\\n\t\t\t\tcontinue;  \\\n}while(0)\n\t\t\tif (min_nonce_diff < work->work_difficulty)\n\t\t\t{\n\t\t\t\tif (min_nonce_diff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tFOUND_WORK(HPWS_LOWDIFF);\n\t\t\t}\n\t\t\tif (work->spare)\n\t\t\t\tFOUND_WORK(HPWS_SPARE);\n\t\t\tif (work->rolltime && hc > staged_rollable)\n\t\t\t\tFOUND_WORK(HPWS_ROLLABLE);\n#undef FOUND_WORK\n\t\t\t\n\t\t\t// Good match\n\t\t\twork_found = work;\n\t\t\twork_score = HPWS_PERFECT;\n\t\t\tbreak;\n\t\t}\n\t\tif (work_found)\n\t\t{\n\t\t\twork = work_found;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// Failed to get a usable work\n\t\tif (unlikely(staged_full))\n\t\t{\n\t\t\tif (likely(opt_queue < 10 + mining_threads))\n\t\t\t{\n\t\t\t\t++opt_queue;\n\t\t\t\tapplog(LOG_WARNING, \"Staged work underrun; increasing queue minimum to %d\", opt_queue);\n\t\t\t}\n\t\t\telse\n\t\t\t\tapplog(LOG_WARNING, \"Staged work underrun; not automatically increasing above %d\", opt_queue);\n\t\t\tstaged_full = false;  // Let it fill up before triggering an underrun again\n\t\t\tno_work = true;\n\t\t}\n\t\tpthread_cond_signal(&gws_cond);\n\t\t\n\t\tif (cmd_idle && !did_cmd_idle)\n\t\t{\n\t\t\tif (likely(!pthread_create(&cmd_idle_thr, NULL, cmd_idle_thread, NULL)))\n\t\t\t\tdid_cmd_idle = true;\n\t\t}\n\t\tpthread_cond_wait(&getq->cond, stgd_lock);\n\t}\n\tif (did_cmd_idle)\n\t\tpthread_cancel(cmd_idle_thr);\n\t\n\tno_work = false;\n\n\tif (can_roll(work) && should_roll(work))\n\t{\n\t\t// Instead of consuming it, force it to be cloned and grab the clone\n\t\tmutex_unlock(stgd_lock);\n\t\tclone_available();\n\t\tgoto retry;\n\t}\n\t\n\tunstage_work(work);\n\n\t/* Signal the getwork scheduler to look for more work */\n\tpthread_cond_signal(&gws_cond);\n\n\t/* Signal hash_pop again in case there are mutliple hash_pop waiters */\n\tpthread_cond_signal(&getq->cond);\n\tmutex_unlock(stgd_lock);\n\twork->pool->last_work_time = time(NULL);\n\tcgtime(&work->pool->tv_last_work_time);\n\n\treturn work;\n}\n\n/* Clones work by rolling it if possible, and returning a clone instead of the\n * original work item which gets staged again to possibly be rolled again in\n * the future */\nstatic struct work *clone_work(struct work *work)\n{\n\tint mrs = mining_threads + opt_queue - total_staged(false);\n\tstruct work *work_clone;\n\tbool cloned;\n\n\tif (mrs < 1)\n\t\treturn work;\n\n\tcloned = false;\n\twork_clone = make_clone(work);\n\twhile (mrs-- > 0 && can_roll(work) && should_roll(work)) {\n\t\tapplog(LOG_DEBUG, \"Pushing rolled converted work to stage thread\");\n\t\tstage_work(work_clone);\n\t\troll_work(work);\n\t\twork_clone = make_clone(work);\n\t\t/* Roll it again to prevent duplicates should this be used\n\t\t * directly later on */\n\t\troll_work(work);\n\t\tcloned = true;\n\t}\n\n\tif (cloned) {\n\t\tstage_work(work);\n\t\treturn work_clone;\n\t}\n\n\tfree_work(work_clone);\n\n\treturn work;\n}\n\nvoid gen_hash(unsigned char *data, unsigned char *hash, int len)\n{\n\tunsigned char hash1[32];\n\n\tsha256(data, len, hash1);\n\tsha256(hash1, 32, hash);\n}\n\n/* PDiff 1 is a 256 bit unsigned integer of\n * 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n * so we use a big endian 32 bit unsigned integer positioned at the Nth byte to\n * cover a huge range of difficulty targets, though not all 256 bits' worth */\nstatic void pdiff_target_leadzero(void * const target_p, double diff)\n{\n\tuint8_t *target = target_p;\n\tdiff *= 0x100000000;\n\tint skip = log2(diff) / 8;\n\tif (skip)\n\t{\n\t\tif (skip > 0x1c)\n\t\t\tskip = 0x1c;\n\t\tdiff /= pow(0x100, skip);\n\t\tmemset(target, 0, skip);\n\t}\n\tuint32_t n = 0xffffffff;\n\tn = (double)n / diff;\n\tn = htobe32(n);\n\tmemcpy(&target[skip], &n, sizeof(n));\n\tmemset(&target[skip + sizeof(n)], 0xff, 32 - (skip + sizeof(n)));\n}\n\nvoid set_target_to_pdiff(void * const dest_target, const double pdiff)\n{\n\tunsigned char rtarget[32];\n\tpdiff_target_leadzero(rtarget, pdiff);\n\tswab256(dest_target, rtarget);\n\t\n\tif (opt_debug) {\n\t\tchar htarget[65];\n\t\tbin2hex(htarget, rtarget, 32);\n\t\tapplog(LOG_DEBUG, \"Generated target %s\", htarget);\n\t}\n}\n\nvoid set_target_to_bdiff(void * const dest_target, const double bdiff)\n{\n\tset_target_to_pdiff(dest_target, bdiff_to_pdiff(bdiff));\n}\n\nvoid _test_target(void * const funcp, const char * const funcname, const bool little_endian, const void * const expectp, const double diff)\n{\n\tuint8_t bufr[32], buf[32], expectr[32], expect[32];\n\tint off;\n\tvoid (*func)(void *, double) = funcp;\n\t\n\tfunc(little_endian ? bufr : buf, diff);\n\tif (little_endian)\n\t\tswab256(buf, bufr);\n\t\n\tswap32tobe(expect, expectp, 256/32);\n\t\n\t// Fuzzy comparison: the first 32 bits set must match, and the actual target must be >= the expected\n\tfor (off = 0; off < 28 && !buf[off]; ++off)\n\t{}\n\t\n\tif (memcmp(&buf[off], &expect[off], 4))\n\t{\ntestfail: ;\n\t\t++unittest_failures;\n\t\tchar hexbuf[65], expectbuf[65];\n\t\tbin2hex(hexbuf, buf, 32);\n\t\tbin2hex(expectbuf, expect, 32);\n\t\tapplogr(, LOG_WARNING, \"%s test failed: diff %g got %s (expected %s)\",\n\t\t        funcname, diff, hexbuf, expectbuf);\n\t}\n\t\n\tif (!little_endian)\n\t\tswab256(bufr, buf);\n\tswab256(expectr, expect);\n\t\n\tif (!hash_target_check(expectr, bufr))\n\t\tgoto testfail;\n}\n\n#define TEST_TARGET(func, le, expect, diff)  \\\n\t_test_target(func, #func, le, expect, diff)\n\nvoid test_target()\n{\n\tuint32_t expect[8] = {0};\n\t// bdiff 1 should be exactly 00000000ffff0000000006f29cfd29510a6caee84634e86a57257cf03152537f due to floating-point imprecision (pdiff1 / 1.0000152590218966)\n\texpect[0] = 0x0000ffff;\n\tTEST_TARGET(set_target_to_bdiff, true, expect, 1./0x10000);\n\texpect[0] = 0;\n\texpect[1] = 0xffff0000;\n\tTEST_TARGET(set_target_to_bdiff, true, expect, 1);\n\texpect[1] >>= 1;\n\tTEST_TARGET(set_target_to_bdiff, true, expect, 2);\n\texpect[1] >>= 3;\n\tTEST_TARGET(set_target_to_bdiff, true, expect, 0x10);\n\texpect[1] >>= 4;\n\tTEST_TARGET(set_target_to_bdiff, true, expect, 0x100);\n\t\n\tmemset(&expect[1], '\\xff', 28);\n\texpect[0] = 0x0000ffff;\n\tTEST_TARGET(set_target_to_pdiff, true, expect, 1./0x10000);\n\texpect[0] = 0;\n\tTEST_TARGET(set_target_to_pdiff, true, expect, 1);\n\texpect[1] >>= 1;\n\tTEST_TARGET(set_target_to_pdiff, true, expect, 2);\n\texpect[1] >>= 3;\n\tTEST_TARGET(set_target_to_pdiff, true, expect, 0x10);\n\texpect[1] >>= 4;\n\tTEST_TARGET(set_target_to_pdiff, true, expect, 0x100);\n}\n\nvoid stratum_work_cpy(struct stratum_work * const dst, const struct stratum_work * const src)\n{\n\t*dst = *src;\n\tif (dst->tr)\n\t\ttmpl_incref(dst->tr);\n\tdst->nonce1 = maybe_strdup(src->nonce1);\n\tdst->job_id = maybe_strdup(src->job_id);\n\tbytes_cpy(&dst->coinbase, &src->coinbase);\n\tbytes_cpy(&dst->merkle_bin, &src->merkle_bin);\n\tdst->data_lock_p = NULL;\n}\n\nvoid stratum_work_clean(struct stratum_work * const swork)\n{\n\tif (swork->tr)\n\t\ttmpl_decref(swork->tr);\n\tfree(swork->nonce1);\n\tfree(swork->job_id);\n\tbytes_free(&swork->coinbase);\n\tbytes_free(&swork->merkle_bin);\n}\n\nbool pool_has_usable_swork(const struct pool * const pool)\n{\n\tif (opt_benchmark)\n\t\treturn true;\n\tif (pool->swork.tr)\n\t{\n\t\t// GBT\n\t\tstruct timeval tv_now;\n\t\ttimer_set_now(&tv_now);\n\t\treturn blkmk_time_left(pool->swork.tr->tmpl, tv_now.tv_sec);\n\t}\n\treturn pool->stratum_notify;\n}\n\n/* Generates stratum based work based on the most recent notify information\n * from the pool. This will keep generating work while a pool is down so we use\n * other means to detect when the pool has died in stratum_thread */\nstatic void gen_stratum_work(struct pool *pool, struct work *work)\n{\n\tclean_work(work);\n\t\n\tcg_wlock(&pool->data_lock);\n\t\n\tconst int n2size = pool->swork.n2size;\n\tbytes_resize(&work->nonce2, n2size);\n\tif (pool->nonce2sz < n2size)\n\t\tmemset(&bytes_buf(&work->nonce2)[pool->nonce2sz], 0, n2size - pool->nonce2sz);\n\tmemcpy(bytes_buf(&work->nonce2),\n#ifdef WORDS_BIGENDIAN\n\t// NOTE: On big endian, the most significant bits are stored at the end, so skip the LSBs\n\t       &((char*)&pool->nonce2)[pool->nonce2off],\n#else\n\t       &pool->nonce2,\n#endif\n\t       pool->nonce2sz);\n\tpool->nonce2++;\n\t\n\twork->pool = pool;\n\twork->work_restart_id = pool->swork.work_restart_id;\n\tgen_stratum_work2(work, &pool->swork);\n\t\n\tcgtime(&work->tv_staged);\n}\n\nvoid gen_stratum_work2(struct work *work, struct stratum_work *swork)\n{\n\tunsigned char *coinbase;\n\t\n\t/* Generate coinbase */\n\tcoinbase = bytes_buf(&swork->coinbase);\n\tmemcpy(&coinbase[swork->nonce2_offset], bytes_buf(&work->nonce2), bytes_len(&work->nonce2));\n\n\t/* Downgrade to a read lock to read off the variables */\n\tif (swork->data_lock_p)\n\t\tcg_dwlock(swork->data_lock_p);\n\t\n\tgen_stratum_work3(work, swork, swork->data_lock_p);\n\t\n\tif (opt_debug)\n\t{\n\t\tchar header[161];\n\t\tchar nonce2hex[(bytes_len(&work->nonce2) * 2) + 1];\n\t\tbin2hex(header, work->data, 80);\n\t\tbin2hex(nonce2hex, bytes_buf(&work->nonce2), bytes_len(&work->nonce2));\n\t\tapplog(LOG_DEBUG, \"Generated stratum header %s\", header);\n\t\tapplog(LOG_DEBUG, \"Work job_id %s nonce2 %s\", work->job_id, nonce2hex);\n\t}\n}\n\nvoid gen_stratum_work3(struct work * const work, struct stratum_work * const swork, cglock_t * const data_lock_p)\n{\n\tunsigned char *coinbase, merkle_root[32], merkle_sha[64];\n\tuint8_t *merkle_bin;\n\tuint32_t *data32, *swap32;\n\tint i;\n\t\n\tcoinbase = bytes_buf(&swork->coinbase);\n\t\n\t/* Generate merkle root */\n\tgen_hash(coinbase, merkle_root, bytes_len(&swork->coinbase));\n\tmemcpy(merkle_sha, merkle_root, 32);\n\tmerkle_bin = bytes_buf(&swork->merkle_bin);\n\tfor (i = 0; i < swork->merkles; ++i, merkle_bin += 32) {\n\t\tmemcpy(merkle_sha + 32, merkle_bin, 32);\n\t\tgen_hash(merkle_sha, merkle_root, 64);\n\t\tmemcpy(merkle_sha, merkle_root, 32);\n\t}\n\tdata32 = (uint32_t *)merkle_sha;\n\tswap32 = (uint32_t *)merkle_root;\n\tflip32(swap32, data32);\n\t\n\tmemcpy(&work->data[0], swork->header1, 36);\n\tmemcpy(&work->data[36], merkle_root, 32);\n\t*((uint32_t*)&work->data[68]) = htobe32(swork->ntime + timer_elapsed(&swork->tv_received, NULL));\n\tmemcpy(&work->data[72], swork->diffbits, 4);\n\tmemset(&work->data[76], 0, 4);  // nonce\n\tmemcpy(&work->data[80], workpadding_bin, 48);\n\t\n\twork->ntime_roll_limits = swork->ntime_roll_limits;\n\n\t/* Copy parameters required for share submission */\n\tmemcpy(work->target, swork->target, sizeof(work->target));\n\twork->job_id = maybe_strdup(swork->job_id);\n\twork->nonce1 = maybe_strdup(swork->nonce1);\n\tif (data_lock_p)\n\t\tcg_runlock(data_lock_p);\n\n\tcalc_midstate(work);\n\n\tlocal_work++;\n\twork->stratum = true;\n\twork->blk.nonce = 0;\n\twork->id = total_work++;\n\twork->longpoll = false;\n\twork->getwork_mode = GETWORK_MODE_STRATUM;\n\tif (swork->tr) {\n\t\twork->getwork_mode = GETWORK_MODE_GBT;\n\t\twork->tr = swork->tr;\n\t\ttmpl_incref(work->tr);\n\t}\n\tcalc_diff(work, 0);\n}\n\nvoid request_work(struct thr_info *thr)\n{\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct cgminer_stats *dev_stats = &(cgpu->cgminer_stats);\n\n\t/* Tell the watchdog thread this thread is waiting on getwork and\n\t * should not be restarted */\n\tthread_reportout(thr);\n\t\n\t// HACK: Since get_work still blocks, reportout all processors dependent on this thread\n\tfor (struct cgpu_info *proc = thr->cgpu->next_proc; proc; proc = proc->next_proc)\n\t{\n\t\tif (proc->threads)\n\t\t\tbreak;\n\t\tthread_reportout(proc->thr[0]);\n\t}\n\n\tcgtime(&dev_stats->_get_start);\n}\n\n// FIXME: Make this non-blocking (and remove HACK above)\nstruct work *get_work(struct thr_info *thr)\n{\n\tconst int thr_id = thr->id;\n\tstruct cgpu_info *cgpu = thr->cgpu;\n\tstruct cgminer_stats *dev_stats = &(cgpu->cgminer_stats);\n\tstruct cgminer_stats *pool_stats;\n\tstruct timeval tv_get;\n\tstruct work *work = NULL;\n\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Popping work from get queue to get work\", cgpu->proc_repr);\n\twhile (!work) {\n\t\twork = hash_pop(cgpu);\n\t\tif (stale_work(work, false)) {\n\t\t\tstaged_full = false;  // It wasn't really full, since it was stale :(\n\t\t\tdiscard_work(work);\n\t\t\twork = NULL;\n\t\t\twake_gws();\n\t\t}\n\t}\n\tlast_getwork = time(NULL);\n\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Got work %d from get queue to get work for thread %d\",\n\t       cgpu->proc_repr, work->id, thr_id);\n\n\twork->thr_id = thr_id;\n\tthread_reportin(thr);\n\t\n\t// HACK: Since get_work still blocks, reportin all processors dependent on this thread\n\tfor (struct cgpu_info *proc = thr->cgpu->next_proc; proc; proc = proc->next_proc)\n\t{\n\t\tif (proc->threads)\n\t\t\tbreak;\n\t\tthread_reportin(proc->thr[0]);\n\t}\n\t\n\twork->mined = true;\n\twork->blk.nonce = 0;\n\n\tcgtime(&tv_get);\n\ttimersub(&tv_get, &dev_stats->_get_start, &tv_get);\n\n\ttimeradd(&tv_get, &dev_stats->getwork_wait, &dev_stats->getwork_wait);\n\tif (timercmp(&tv_get, &dev_stats->getwork_wait_max, >))\n\t\tdev_stats->getwork_wait_max = tv_get;\n\tif (timercmp(&tv_get, &dev_stats->getwork_wait_min, <))\n\t\tdev_stats->getwork_wait_min = tv_get;\n\t++dev_stats->getwork_calls;\n\n\tpool_stats = &(work->pool->cgminer_stats);\n\ttimeradd(&tv_get, &pool_stats->getwork_wait, &pool_stats->getwork_wait);\n\tif (timercmp(&tv_get, &pool_stats->getwork_wait_max, >))\n\t\tpool_stats->getwork_wait_max = tv_get;\n\tif (timercmp(&tv_get, &pool_stats->getwork_wait_min, <))\n\t\tpool_stats->getwork_wait_min = tv_get;\n\t++pool_stats->getwork_calls;\n\t\n\tif (work->work_difficulty < 1)\n\t{\n\t\tconst float min_nonce_diff = drv_min_nonce_diff(cgpu->drv, cgpu, work_mining_algorithm(work));\n\t\tif (unlikely(work->work_difficulty < min_nonce_diff))\n\t\t{\n\t\t\tif (min_nonce_diff - work->work_difficulty > 1./0x10000000)\n\t\t\t\tapplog(LOG_WARNING, \"%\"PRIpreprv\": Using work with lower difficulty than device supports\",\n\t\t\t\t       cgpu->proc_repr);\n\t\t\twork->nonce_diff = min_nonce_diff;\n\t\t}\n\t\telse\n\t\t\twork->nonce_diff = work->work_difficulty;\n\t}\n\telse\n\t\twork->nonce_diff = 1;\n\n\treturn work;\n}\n\nstruct dupe_hash_elem {\n\tuint8_t hash[0x20];\n\tstruct timeval tv_prune;\n\tUT_hash_handle hh;\n};\n\nstatic\nvoid _submit_work_async(struct work *work)\n{\n\tapplog(LOG_DEBUG, \"Pushing submit work to work thread\");\n\t\n\tif (opt_benchmark)\n\t{\n\t\tjson_t * const jn = json_null(), *result = NULL;\n\t\twork_check_for_block(work);\n\t\t{\n\t\t\tstatic struct dupe_hash_elem *dupe_hashes;\n\t\t\tstruct dupe_hash_elem *dhe, *dhetmp;\n\t\t\tHASH_FIND(hh, dupe_hashes, &work->hash, sizeof(dhe->hash), dhe);\n\t\t\tif (dhe)\n\t\t\t\tresult = json_string(\"duplicate\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tstruct timeval tv_now;\n\t\t\t\ttimer_set_now(&tv_now);\n\t\t\t\t\n\t\t\t\t// Prune old entries\n\t\t\t\tHASH_ITER(hh, dupe_hashes, dhe, dhetmp)\n\t\t\t\t{\n\t\t\t\t\tif (!timer_passed(&dhe->tv_prune, &tv_now))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tHASH_DEL(dupe_hashes, dhe);\n\t\t\t\t\tfree(dhe);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdhe = malloc(sizeof(*dhe));\n\t\t\t\tmemcpy(dhe->hash, work->hash, sizeof(dhe->hash));\n\t\t\t\ttimer_set_delay(&dhe->tv_prune, &tv_now, 337500000);\n\t\t\t\tHASH_ADD(hh, dupe_hashes, hash, sizeof(dhe->hash), dhe);\n\t\t\t}\n\t\t}\n\t\tif (result)\n\t\t{}\n\t\telse\n\t\tif (stale_work(work, true))\n\t\t{\n\t\t\tchar stalemsg[0x10];\n\t\t\tsnprintf(stalemsg, sizeof(stalemsg), \"stale %us\", benchmark_update_interval * (work->pool->work_restart_id - work->work_restart_id));\n\t\t\tresult = json_string(stalemsg);\n\t\t}\n\t\telse\n\t\t\tresult = json_incref(jn);\n\t\tshare_result(jn, result, jn, work, false, \"\");\n\t\tfree_work(work);\n\t\tjson_decref(result);\n\t\tjson_decref(jn);\n\t\treturn;\n\t}\n\n\tmutex_lock(&submitting_lock);\n\t++total_submitting;\n\tDL_APPEND(submit_waiting, work);\n\tmutex_unlock(&submitting_lock);\n\n\tnotifier_wake(submit_waiting_notifier);\n}\n\n/* Submit a copy of the tested, statistic recorded work item asynchronously */\nstatic void submit_work_async2(struct work *work, struct timeval *tv_work_found)\n{\n\tif (tv_work_found)\n\t\tcopy_time(&work->tv_work_found, tv_work_found);\n\t\n\t_submit_work_async(work);\n}\n\nvoid inc_hw_errors3(struct thr_info *thr, const struct work *work, const uint32_t *bad_nonce_p, float nonce_diff)\n{\n\tstruct cgpu_info * const cgpu = thr->cgpu;\n\t\n\tif (bad_nonce_p)\n\t{\n\t\tif (bad_nonce_p == UNKNOWN_NONCE)\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": invalid nonce - HW error\",\n\t\t\t       cgpu->proc_repr);\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": invalid nonce (%08lx) - HW error\",\n\t\t\t       cgpu->proc_repr, (unsigned long)be32toh(*bad_nonce_p));\n\t}\n\t\n\tmutex_lock(&stats_lock);\n\thw_errors++;\n\t++cgpu->hw_errors;\n\tif (bad_nonce_p)\n\t{\n\t\ttotal_bad_diff1 += nonce_diff;\n\t\tcgpu->bad_diff1 += nonce_diff;\n\t}\n\tmutex_unlock(&stats_lock);\n\n\tif (thr->cgpu->drv->hw_error)\n\t\tthr->cgpu->drv->hw_error(thr);\n}\n\nvoid work_hash(struct work * const work)\n{\n\tconst struct mining_algorithm * const malgo = work_mining_algorithm(work);\n\tmalgo->hash_data_f(work->hash, work->data);\n}\n\nstatic\nbool test_hash(const void * const phash, const float diff)\n{\n\tconst uint32_t * const hash = phash;\n\tif (diff >= 1.)\n\t\t// FIXME: > 1 should check more\n\t\treturn !hash[7];\n\t\n\tconst uint32_t Htarg = (uint32_t)ceil((1. / diff) - 1);\n\tconst uint32_t tmp_hash7 = le32toh(hash[7]);\n\t\n\tapplog(LOG_DEBUG, \"htarget %08lx hash %08lx\",\n\t\t\t\t(long unsigned int)Htarg,\n\t\t\t\t(long unsigned int)tmp_hash7);\n\treturn (tmp_hash7 <= Htarg);\n}\n\nenum test_nonce2_result _test_nonce2(struct work *work, uint32_t nonce, bool checktarget)\n{\n\tuint32_t *work_nonce = (uint32_t *)(work->data + 64 + 12);\n\t*work_nonce = htole32(nonce);\n\n\twork_hash(work);\n\t\n\tif (!test_hash(work->hash, work->nonce_diff))\n\t\treturn TNR_BAD;\n\t\n\tif (checktarget && !hash_target_check_v(work->hash, work->target))\n\t{\n\t\tbool high_hash = true;\n\t\tstruct pool * const pool = work->pool;\n\t\tif (pool_diff_effective_retroactively(pool))\n\t\t{\n\t\t\t// Some stratum pools are buggy and expect difficulty changes to be immediate retroactively, so if the target has changed, check and submit just in case\n\t\t\tif (memcmp(pool->next_target, work->target, sizeof(work->target)))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Stratum pool %u target has changed since work job issued, checking that too\",\n\t\t\t\t       pool->pool_no);\n\t\t\t\tif (hash_target_check_v(work->hash, pool->next_target))\n\t\t\t\t{\n\t\t\t\t\thigh_hash = false;\n\t\t\t\t\twork->work_difficulty = target_diff(pool->next_target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (high_hash)\n\t\t\treturn TNR_HIGH;\n\t}\n\t\n\treturn TNR_GOOD;\n}\n\n/* Returns true if nonce for work was a valid share */\nbool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce)\n{\n\treturn submit_noffset_nonce(thr, work, nonce, 0);\n}\n\n/* Allows drivers to submit work items where the driver has changed the ntime\n * value by noffset. Must be only used with a work protocol that does not ntime\n * roll itself intrinsically to generate work (eg stratum). We do not touch\n * the original work struct, but the copy of it only. */\nbool submit_noffset_nonce(struct thr_info *thr, struct work *work_in, uint32_t nonce,\n\t\t\t  int noffset)\n{\n\tstruct work *work = make_work();\n\t_copy_work(work, work_in, noffset);\n\t\n\tuint32_t *work_nonce = (uint32_t *)(work->data + 64 + 12);\n\tstruct timeval tv_work_found;\n\tenum test_nonce2_result res;\n\tbool ret = true;\n\n\tthread_reportout(thr);\n\n\tcgtime(&tv_work_found);\n\t*work_nonce = htole32(nonce);\n\twork->thr_id = thr->id;\n\n\t/* Do one last check before attempting to submit the work */\n\t/* Side effect: sets work->data and work->hash for us */\n\tres = test_nonce2(work, nonce);\n\t\n\tif (unlikely(res == TNR_BAD))\n\t\t{\n\t\t\tinc_hw_errors(thr, work, nonce);\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\n\tmutex_lock(&stats_lock);\n\ttotal_diff1       += work->nonce_diff;\n\tthr ->cgpu->diff1 += work->nonce_diff;\n\twork->pool->diff1 += work->nonce_diff;\n\tthr->cgpu->last_device_valid_work = time(NULL);\n\tmutex_unlock(&stats_lock);\n\t\n\tif (noncelog_file)\n\t\tnoncelog(work);\n\t\n\tif (res == TNR_HIGH)\n\t{\n\t\t\t// Share above target, normal\n\t\t\t/* Check the diff of the share, even if it didn't reach the\n\t\t\t * target, just to set the best share value if it's higher. */\n\t\t\tshare_diff(work);\n\t\t\tgoto out;\n\t}\n\t\n\tsubmit_work_async2(work, &tv_work_found);\n\twork = NULL;  // Taken by submit_work_async2\nout:\n\tif (work)\n\t\tfree_work(work);\n\tthread_reportin(thr);\n\n\treturn ret;\n}\n\n// return true of we should stop working on this piece of work\n// returning false means we will keep scanning for a nonce\n// assumptions: work->blk.nonce is the number of nonces completed in the work\n// see minerloop_scanhash comments for more details & usage\nbool abandon_work(struct work *work, struct timeval *wdiff, uint64_t max_hashes)\n{\n\tif (work->blk.nonce == 0xffffffff ||                // known we are scanning a full nonce range\n\t    wdiff->tv_sec > opt_scantime ||                 // scan-time has elapsed (user specified, default 60s)\n\t    work->blk.nonce >= 0xfffffffe - max_hashes ||   // are there enough nonces left in the work\n\t    max_hashes >= 0xfffffffe ||                     // assume we are scanning a full nonce range\n\t    stale_work(work, false))                        // work is stale\n\t\treturn true;\n\treturn false;\n}\n\nvoid __thr_being_msg(int prio, struct thr_info *thr, const char *being)\n{\n\tstruct cgpu_info *proc = thr->cgpu;\n\t\n\tif (proc->threads > 1)\n\t\tapplog(prio, \"%\"PRIpreprv\" (thread %d) %s\", proc->proc_repr, thr->id, being);\n\telse\n\t\tapplog(prio, \"%\"PRIpreprv\" %s\", proc->proc_repr, being);\n}\n\n// Called by asynchronous minerloops, when they find their processor should be disabled\nvoid mt_disable_start(struct thr_info *mythr)\n{\n\tstruct cgpu_info *cgpu = mythr->cgpu;\n\tstruct device_drv *drv = cgpu->drv;\n\t\n\tif (drv->thread_disable)\n\t\tdrv->thread_disable(mythr);\n\t\n\thashmeter2(mythr);\n\t__thr_being_msg(LOG_WARNING, mythr, \"being disabled\");\n\tmythr->rolling = mythr->cgpu->rolling = 0;\n\tthread_reportout(mythr);\n\tmythr->_mt_disable_called = true;\n}\n\n/* Put a new unqueued work item in cgpu->unqueued_work under cgpu->qlock till\n * the driver tells us it's full so that it may extract the work item using\n * the get_queued() function which adds it to the hashtable on\n * cgpu->queued_work. */\nstatic void fill_queue(struct thr_info *mythr, struct cgpu_info *cgpu, struct device_drv *drv, const int thr_id)\n{\n\tthread_reportout(mythr);\n\tdo {\n\t\tbool need_work;\n\n\t\t/* Do this lockless just to know if we need more unqueued work. */\n\t\tneed_work = (!cgpu->unqueued_work);\n\n\t\t/* get_work is a blocking function so do it outside of lock\n\t\t * to prevent deadlocks with other locks. */\n\t\tif (need_work) {\n\t\t\tstruct work *work = get_work(mythr);\n\n\t\t\twr_lock(&cgpu->qlock);\n\t\t\t/* Check we haven't grabbed work somehow between\n\t\t\t * checking and picking up the lock. */\n\t\t\tif (likely(!cgpu->unqueued_work))\n\t\t\t\tcgpu->unqueued_work = work;\n\t\t\telse\n\t\t\t\tneed_work = false;\n\t\t\twr_unlock(&cgpu->qlock);\n\n\t\t\tif (unlikely(!need_work))\n\t\t\t\tdiscard_work(work);\n\t\t}\n\t\t/* The queue_full function should be used by the driver to\n\t\t * actually place work items on the physical device if it\n\t\t * does have a queue. */\n\t} while (drv->queue_full && !drv->queue_full(cgpu));\n}\n\n/* Add a work item to a cgpu's queued hashlist */\nvoid __add_queued(struct cgpu_info *cgpu, struct work *work)\n{\n\tcgpu->queued_count++;\n\tHASH_ADD_INT(cgpu->queued_work, id, work);\n}\n\n/* This function is for retrieving one work item from the unqueued pointer and\n * adding it to the hashtable of queued work. Code using this function must be\n * able to handle NULL as a return which implies there is no work available. */\nstruct work *get_queued(struct cgpu_info *cgpu)\n{\n\tstruct work *work = NULL;\n\n\twr_lock(&cgpu->qlock);\n\tif (cgpu->unqueued_work) {\n\t\twork = cgpu->unqueued_work;\n\t\tif (unlikely(stale_work(work, false))) {\n\t\t\tdiscard_work(work);\n\t\t\twork = NULL;\n\t\t\twake_gws();\n\t\t} else\n\t\t\t__add_queued(cgpu, work);\n\t\tcgpu->unqueued_work = NULL;\n\t}\n\twr_unlock(&cgpu->qlock);\n\n\treturn work;\n}\n\nvoid add_queued(struct cgpu_info *cgpu, struct work *work)\n{\n\twr_lock(&cgpu->qlock);\n\t__add_queued(cgpu, work);\n\twr_unlock(&cgpu->qlock);\n}\n\n/* Get fresh work and add it to cgpu's queued hashlist */\nstruct work *get_queue_work(struct thr_info *thr, struct cgpu_info *cgpu, int thr_id)\n{\n\tstruct work *work = get_work(thr);\n\n\tadd_queued(cgpu, work);\n\treturn work;\n}\n\n/* This function is for finding an already queued work item in the\n * given que hashtable. Code using this function must be able\n * to handle NULL as a return which implies there is no matching work.\n * The calling function must lock access to the que if it is required.\n * The common values for midstatelen, offset, datalen are 32, 64, 12 */\nstruct work *__find_work_bymidstate(struct work *que, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen)\n{\n\tstruct work *work, *tmp, *ret = NULL;\n\n\tHASH_ITER(hh, que, work, tmp) {\n\t\tif (memcmp(work->midstate, midstate, midstatelen) == 0 &&\n\t\t    memcmp(work->data + offset, data, datalen) == 0) {\n\t\t\tret = work;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function is for finding an already queued work item in the\n * device's queued_work hashtable. Code using this function must be able\n * to handle NULL as a return which implies there is no matching work.\n * The common values for midstatelen, offset, datalen are 32, 64, 12 */\nstruct work *find_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen)\n{\n\tstruct work *ret;\n\n\trd_lock(&cgpu->qlock);\n\tret = __find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);\n\trd_unlock(&cgpu->qlock);\n\n\treturn ret;\n}\n\nstruct work *clone_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen)\n{\n\tstruct work *work, *ret = NULL;\n\n\trd_lock(&cgpu->qlock);\n\twork = __find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);\n\tif (work)\n\t\tret = copy_work(work);\n\trd_unlock(&cgpu->qlock);\n\n\treturn ret;\n}\n\nvoid __work_completed(struct cgpu_info *cgpu, struct work *work)\n{\n\tcgpu->queued_count--;\n\tHASH_DEL(cgpu->queued_work, work);\n}\n\n/* This iterates over a queued hashlist finding work started more than secs\n * seconds ago and discards the work as completed. The driver must set the\n * work->tv_work_start value appropriately. Returns the number of items aged. */\nint age_queued_work(struct cgpu_info *cgpu, double secs)\n{\n\tstruct work *work, *tmp;\n\tstruct timeval tv_now;\n\tint aged = 0;\n\n\tcgtime(&tv_now);\n\n\twr_lock(&cgpu->qlock);\n\tHASH_ITER(hh, cgpu->queued_work, work, tmp) {\n\t\tif (tdiff(&tv_now, &work->tv_work_start) > secs) {\n\t\t\t__work_completed(cgpu, work);\n\t\t\taged++;\n\t\t}\n\t}\n\twr_unlock(&cgpu->qlock);\n\n\treturn aged;\n}\n\n/* This function should be used by queued device drivers when they're sure\n * the work struct is no longer in use. */\nvoid work_completed(struct cgpu_info *cgpu, struct work *work)\n{\n\twr_lock(&cgpu->qlock);\n\t__work_completed(cgpu, work);\n\twr_unlock(&cgpu->qlock);\n\n\tfree_work(work);\n}\n\n/* Combines find_queued_work_bymidstate and work_completed in one function\n * withOUT destroying the work so the driver must free it. */\nstruct work *take_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen)\n{\n\tstruct work *work;\n\n\twr_lock(&cgpu->qlock);\n\twork = __find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);\n\tif (work)\n\t\t__work_completed(cgpu, work);\n\twr_unlock(&cgpu->qlock);\n\n\treturn work;\n}\n\nvoid flush_queue(struct cgpu_info *cgpu)\n{\n\tstruct work *work = NULL;\n\n\twr_lock(&cgpu->qlock);\n\twork = cgpu->unqueued_work;\n\tcgpu->unqueued_work = NULL;\n\twr_unlock(&cgpu->qlock);\n\n\tif (work) {\n\t\tfree_work(work);\n\t\tapplog(LOG_DEBUG, \"Discarded queued work item\");\n\t}\n}\n\n/* This version of hash work is for devices that are fast enough to always\n * perform a full nonce range and need a queue to maintain the device busy.\n * Work creation and destruction is not done from within this function\n * directly. */\nvoid hash_queued_work(struct thr_info *mythr)\n{\n\tconst long cycle = opt_log_interval / 5 ? : 1;\n\tstruct timeval tv_start = {0, 0}, tv_end;\n\tstruct cgpu_info *cgpu = mythr->cgpu;\n\tstruct device_drv *drv = cgpu->drv;\n\tconst int thr_id = mythr->id;\n\tint64_t hashes_done = 0;\n\n\tif (unlikely(cgpu->deven != DEV_ENABLED))\n\t\tmt_disable(mythr);\n\t\n\twhile (likely(!cgpu->shutdown)) {\n\t\tstruct timeval diff;\n\t\tint64_t hashes;\n\n\t\tfill_queue(mythr, cgpu, drv, thr_id);\n\n\t\tthread_reportin(mythr);\n\t\thashes = drv->scanwork(mythr);\n\n\t\t/* Reset the bool here in case the driver looks for it\n\t\t * synchronously in the scanwork loop. */\n\t\tmythr->work_restart = false;\n\n\t\tif (unlikely(hashes == -1 )) {\n\t\t\tapplog(LOG_ERR, \"%s %d failure, disabling!\", drv->name, cgpu->device_id);\n\t\t\tcgpu->deven = DEV_DISABLED;\n\t\t\tdev_error(cgpu, REASON_THREAD_ZERO_HASH);\n\t\t\tmt_disable(mythr);\n\t\t}\n\n\t\thashes_done += hashes;\n\t\tcgtime(&tv_end);\n\t\ttimersub(&tv_end, &tv_start, &diff);\n\t\tif (diff.tv_sec >= cycle) {\n\t\t\thashmeter(thr_id, &diff, hashes_done);\n\t\t\thashes_done = 0;\n\t\t\tcopy_time(&tv_start, &tv_end);\n\t\t}\n\n\t\tif (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))\n\t\t\tmt_disable(mythr);\n\n\t\tif (unlikely(mythr->work_restart)) {\n\t\t\tflush_queue(cgpu);\n\t\t\tif (drv->flush_work)\n\t\t\t\tdrv->flush_work(cgpu);\n\t\t}\n\t}\n\t// cgpu->deven = DEV_DISABLED; set in miner_thread\n}\n\n// Called by minerloop, when it is re-enabling a processor\nvoid mt_disable_finish(struct thr_info *mythr)\n{\n\tstruct device_drv *drv = mythr->cgpu->drv;\n\t\n\tthread_reportin(mythr);\n\t__thr_being_msg(LOG_WARNING, mythr, \"being re-enabled\");\n\tif (drv->thread_enable)\n\t\tdrv->thread_enable(mythr);\n\tmythr->_mt_disable_called = false;\n}\n\n// Called by synchronous minerloops, when they find their processor should be disabled\n// Calls mt_disable_start, waits until it's re-enabled, then calls mt_disable_finish\nvoid mt_disable(struct thr_info *mythr)\n{\n\tconst struct cgpu_info * const cgpu = mythr->cgpu;\n\tmt_disable_start(mythr);\n\tapplog(LOG_DEBUG, \"Waiting for wakeup notification in miner thread\");\n\tdo {\n\t\tnotifier_read(mythr->notifier);\n\t} while (mythr->pause || cgpu->deven != DEV_ENABLED);\n\tmt_disable_finish(mythr);\n}\n\n\nenum {\n\tSTAT_SLEEP_INTERVAL\t\t= 1,\n\tSTAT_CTR_INTERVAL\t\t= 10000000,\n\tFAILURE_INTERVAL\t\t= 30,\n};\n\n/* Stage another work item from the work returned in a longpoll */\nstatic void convert_to_work(json_t *val, int rolltime, struct pool *pool, struct work *work, struct timeval *tv_lp, struct timeval *tv_lp_reply)\n{\n\tbool rc;\n\n\twork->rolltime = rolltime;\n\trc = work_decode(pool, work, val);\n\tif (unlikely(!rc)) {\n\t\tapplog(LOG_ERR, \"Could not convert longpoll data to work\");\n\t\tfree_work(work);\n\t\treturn;\n\t}\n\ttotal_getworks++;\n\tpool->getwork_requested++;\n\twork->pool = pool;\n\tcopy_time(&work->tv_getwork, tv_lp);\n\tcopy_time(&work->tv_getwork_reply, tv_lp_reply);\n\tcalc_diff(work, 0);\n\n\tif (pool->enabled == POOL_REJECTING)\n\t\twork->mandatory = true;\n\n\twork->longpoll = true;\n\twork->getwork_mode = GETWORK_MODE_LP;\n\n\tupdate_last_work(work);\n\n\t/* We'll be checking this work item twice, but we already know it's\n\t * from a new block so explicitly force the new block detection now\n\t * rather than waiting for it to hit the stage thread. This also\n\t * allows testwork to know whether LP discovered the block or not. */\n\ttest_work_current(work);\n\n\t/* Don't use backup LPs as work if we have failover-only enabled. Use\n\t * the longpoll work from a pool that has been rejecting shares as a\n\t * way to detect when the pool has recovered.\n\t */\n\tif (pool != current_pool() && opt_fail_only && pool->enabled != POOL_REJECTING) {\n\t\tfree_work(work);\n\t\treturn;\n\t}\n\n\twork = clone_work(work);\n\n\tapplog(LOG_DEBUG, \"Pushing converted work to stage thread\");\n\n\tstage_work(work);\n\tapplog(LOG_DEBUG, \"Converted longpoll data to work\");\n}\n\n/* If we want longpoll, enable it for the chosen default pool, or, if\n * the pool does not support longpoll, find the first one that does\n * and use its longpoll support */\nstatic\nstruct pool *_select_longpoll_pool(struct pool *cp, bool(*func)(struct pool *))\n{\n\tint i;\n\n\tif (func(cp))\n\t\treturn cp;\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\t\tif (cp->goal != pool->goal)\n\t\t\tcontinue;\n\n\t\tif (func(pool))\n\t\t\treturn pool;\n\t}\n\treturn NULL;\n}\n\n/* This will make the longpoll thread wait till it's the current pool, or it\n * has been flagged as rejecting, before attempting to open any connections.\n */\nstatic void wait_lpcurrent(struct pool *pool)\n{\n\tmutex_lock(&lp_lock);\n\twhile (!cnx_needed(pool))\n\t{\n\t\tpool->lp_active = false;\n\t\tpthread_cond_wait(&lp_cond, &lp_lock);\n\t}\n\tmutex_unlock(&lp_lock);\n}\n\nstatic curl_socket_t save_curl_socket(void *vpool, __maybe_unused curlsocktype purpose, struct curl_sockaddr *addr) {\n\tstruct pool *pool = vpool;\n\tcurl_socket_t sock = bfg_socket(addr->family, addr->socktype, addr->protocol);\n\tpool->lp_socket = sock;\n\treturn sock;\n}\n\nstatic void *longpoll_thread(void *userdata)\n{\n\tstruct pool *cp = (struct pool *)userdata;\n\t/* This *pool is the source of the actual longpoll, not the pool we've\n\t * tied it to */\n\tstruct timeval start, reply, end;\n\tstruct pool *pool = NULL;\n\tchar threadname[20];\n\tCURL *curl = NULL;\n\tint failures = 0;\n\tchar *lp_url;\n\tint rolltime;\n\n#ifndef HAVE_PTHREAD_CANCEL\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n#endif\n\n\tsnprintf(threadname, 20, \"longpoll%u\", cp->pool_no);\n\tRenameThread(threadname);\n\n\tcurl = curl_easy_init();\n\tif (unlikely(!curl)) {\n\t\tapplog(LOG_ERR, \"CURL initialisation failed\");\n\t\treturn NULL;\n\t}\n\nretry_pool:\n\tpool = select_longpoll_pool(cp);\n\tif (!pool) {\n\t\tapplog(LOG_WARNING, \"No suitable long-poll found for %s\", cp->rpc_url);\n\t\twhile (!pool) {\n\t\t\tcgsleep_ms(60000);\n\t\t\tpool = select_longpoll_pool(cp);\n\t\t}\n\t}\n\n\tif (pool->has_stratum) {\n\t\tapplog(LOG_WARNING, \"Block change for %s detection via %s stratum\",\n\t\t       cp->rpc_url, pool->rpc_url);\n\t\tgoto out;\n\t}\n\n\t/* Any longpoll from any pool is enough for this to be true */\n\tpool->goal->have_longpoll = true;\n\n\twait_lpcurrent(cp);\n\n\t{\n\t\tlp_url = pool->lp_url;\n\t\tif (cp == pool)\n\t\t\tapplog(LOG_WARNING, \"Long-polling activated for %s (%s)\", lp_url, pool_protocol_name(pool->lp_proto));\n\t\telse\n\t\t\tapplog(LOG_WARNING, \"Long-polling activated for %s via %s (%s)\", cp->rpc_url, lp_url, pool_protocol_name(pool->lp_proto));\n\t}\n\n\twhile (42) {\n\t\tjson_t *val, *soval;\n\n\t\tstruct work *work = make_work();\n\t\tchar *lpreq;\n\t\tlpreq = prepare_rpc_req(work, pool->lp_proto, pool->lp_id, pool);\n\t\twork->pool = pool;\n\t\tif (!lpreq)\n\t\t{\n\t\t\tfree_work(work);\n\t\t\tgoto lpfail;\n\t\t}\n\n\t\twait_lpcurrent(cp);\n\n\t\tcgtime(&start);\n\n\t\t/* Longpoll connections can be persistent for a very long time\n\t\t * and any number of issues could have come up in the meantime\n\t\t * so always establish a fresh connection instead of relying on\n\t\t * a persistent one. */\n\t\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETFUNCTION, save_curl_socket);\n\t\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETDATA, pool);\n\t\tval = json_rpc_call(curl, lp_url, pool->rpc_userpass,\n\t\t\t\t    lpreq, false, true, &rolltime, pool, false);\n\t\tpool->lp_socket = CURL_SOCKET_BAD;\n\n\t\tcgtime(&reply);\n\n\t\tfree(lpreq);\n\n\t\tif (likely(val)) {\n\t\t\tsoval = json_object_get(json_object_get(val, \"result\"), \"submitold\");\n\t\t\tif (soval)\n\t\t\t\tpool->submit_old = json_is_true(soval);\n\t\t\telse\n\t\t\t\tpool->submit_old = false;\n\t\t\tconvert_to_work(val, rolltime, pool, work, &start, &reply);\n\t\t\tfailures = 0;\n\t\t\tjson_decref(val);\n\t\t} else {\n\t\t\t/* Some pools regularly drop the longpoll request so\n\t\t\t * only see this as longpoll failure if it happens\n\t\t\t * immediately and just restart it the rest of the\n\t\t\t * time. */\n\t\t\tcgtime(&end);\n\t\t\tfree_work(work);\n\t\t\tif (end.tv_sec - start.tv_sec <= 30)\n\t\t\t{\n\t\t\t\tif (failures == 1)\n\t\t\t\t\tapplog(LOG_WARNING, \"longpoll failed for %s, retrying every 30s\", lp_url);\nlpfail:\n\t\t\t\tcgsleep_ms(30000);\n\t\t\t}\n\t\t}\n\n\t\tif (pool != cp) {\n\t\t\tpool = select_longpoll_pool(cp);\n\t\t\tif (pool->has_stratum) {\n\t\t\t\tapplog(LOG_WARNING, \"Block change for %s detection via %s stratum\",\n\t\t\t\t       cp->rpc_url, pool->rpc_url);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(!pool))\n\t\t\t\tgoto retry_pool;\n\t\t}\n\n\t\tif (unlikely(pool->removed))\n\t\t\tbreak;\n\t}\n\nout:\n\tpool->lp_active = false;\n\tcurl_easy_cleanup(curl);\n\n\treturn NULL;\n}\n\nstatic void stop_longpoll(void)\n{\n\tint i;\n\t\n\twant_longpoll = false;\n\tfor (i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool *pool = pools[i];\n\t\t\n\t\tif (unlikely(!pool->lp_started))\n\t\t\tcontinue;\n\t\t\n\t\tpool->lp_started = false;\n\t\tpthread_cancel(pool->longpoll_thread);\n\t}\n\t\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tgoal->have_longpoll = false;\n\t}\n}\n\nstatic void start_longpoll(void)\n{\n\tint i;\n\t\n\twant_longpoll = true;\n\tfor (i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool *pool = pools[i];\n\t\t\n\t\tif (unlikely(pool->removed || pool->lp_started || !pool->lp_url))\n\t\t\tcontinue;\n\t\t\n\t\tpool->lp_started = true;\n\t\tif (unlikely(pthread_create(&pool->longpoll_thread, NULL, longpoll_thread, (void *)pool)))\n\t\t\tquit(1, \"Failed to create pool longpoll thread\");\n\t}\n}\n\nvoid reinit_device(struct cgpu_info *cgpu)\n{\n\tif (cgpu->drv->reinit_device)\n\t\tcgpu->drv->reinit_device(cgpu);\n}\n\nstatic struct timeval rotate_tv;\n\n/* We reap curls if they are unused for over a minute */\nstatic void reap_curl(struct pool *pool)\n{\n\tstruct curl_ent *ent, *iter;\n\tstruct timeval now;\n\tint reaped = 0;\n\n\tcgtime(&now);\n\n\tmutex_lock(&pool->pool_lock);\n\tLL_FOREACH_SAFE(pool->curllist, ent, iter) {\n\t\tif (pool->curls < 2)\n\t\t\tbreak;\n\t\tif (now.tv_sec - ent->tv.tv_sec > 300) {\n\t\t\treaped++;\n\t\t\tpool->curls--;\n\t\t\tLL_DELETE(pool->curllist, ent);\n\t\t\tcurl_easy_cleanup(ent->curl);\n\t\t\tfree(ent);\n\t\t}\n\t}\n\tmutex_unlock(&pool->pool_lock);\n\n\tif (reaped)\n\t\tapplog(LOG_DEBUG, \"Reaped %d curl%s from pool %d\", reaped, reaped > 1 ? \"s\" : \"\", pool->pool_no);\n}\n\nstatic void *watchpool_thread(void __maybe_unused *userdata)\n{\n\tint intervals = 0;\n\n#ifndef HAVE_PTHREAD_CANCEL\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n#endif\n\n\tRenameThread(\"watchpool\");\n\n\twhile (42) {\n\t\tstruct timeval now;\n\t\tint i;\n\n\t\tif (++intervals > 20)\n\t\t\tintervals = 0;\n\t\tcgtime(&now);\n\n\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\tstruct pool *pool = pools[i];\n\n\t\t\tif (!opt_benchmark)\n\t\t\t\treap_curl(pool);\n\n\t\t\t/* Get a rolling utility per pool over 10 mins */\n\t\t\tif (intervals > 19) {\n\t\t\t\tint shares = pool->diff1 - pool->last_shares;\n\n\t\t\t\tpool->last_shares = pool->diff1;\n\t\t\t\tpool->utility = (pool->utility + (double)shares * 0.63) / 1.63;\n\t\t\t\tpool->shares = pool->utility;\n\t\t\t}\n\n\t\t\tif (pool->enabled == POOL_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\t/* Don't start testing any pools if the test threads\n\t\t\t * from startup are still doing their first attempt. */\n\t\t\tif (unlikely(pool->testing)) {\n\t\t\t\tpthread_join(pool->test_thread, NULL);\n\t\t\t}\n\n\t\t\t/* Test pool is idle once every minute */\n\t\t\tif (pool->idle && now.tv_sec - pool->tv_idle.tv_sec > 30) {\n\t\t\t\tif (pool_active(pool, true) && pool_tclear(pool, &pool->idle))\n\t\t\t\t\tpool_resus(pool);\n\t\t\t}\n\n\t\t\t/* Only switch pools if the failback pool has been\n\t\t\t * alive for more than 5 minutes (default) to prevent\n\t\t\t * intermittently failing pools from being used. */\n\t\t\tif (!pool->idle && pool->enabled == POOL_ENABLED && pool_strategy == POOL_FAILOVER && pool->prio < cp_prio() && now.tv_sec - pool->tv_idle.tv_sec > opt_fail_switch_delay)\n\t\t\t{\n\t\t\t\tif (opt_fail_switch_delay % 60)\n\t\t\t\t\tapplog(LOG_WARNING, \"Pool %d %s stable for %d second%s\",\n\t\t\t\t\t       pool->pool_no, pool->rpc_url,\n\t\t\t\t\t       opt_fail_switch_delay,\n\t\t\t\t\t       (opt_fail_switch_delay == 1 ? \"\" : \"s\"));\n\t\t\t\telse\n\t\t\t\t\tapplog(LOG_WARNING, \"Pool %d %s stable for %d minute%s\",\n\t\t\t\t\t       pool->pool_no, pool->rpc_url,\n\t\t\t\t\t       opt_fail_switch_delay / 60,\n\t\t\t\t\t       (opt_fail_switch_delay == 60 ? \"\" : \"s\"));\n\t\t\t\tswitch_pools(NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (current_pool()->idle)\n\t\t\tswitch_pools(NULL);\n\n\t\tif (pool_strategy == POOL_ROTATE && now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period) {\n\t\t\tcgtime(&rotate_tv);\n\t\t\tswitch_pools(NULL);\n\t\t}\n\n\t\tcgsleep_ms(30000);\n\t\t\t\n\t}\n\treturn NULL;\n}\n\nvoid mt_enable(struct thr_info *thr)\n{\n\tapplog(LOG_DEBUG, \"Waking up thread %d\", thr->id);\n\tnotifier_wake(thr->notifier);\n}\n\nvoid proc_enable(struct cgpu_info *cgpu)\n{\n\tint j;\n\n\tcgpu->deven = DEV_ENABLED;\n\tfor (j = cgpu->threads ?: 1; j--; )\n\t\tmt_enable(cgpu->thr[j]);\n}\n\n#define device_recovered(cgpu)  proc_enable(cgpu)\n\nvoid cgpu_set_defaults(struct cgpu_info * const cgpu)\n{\n\tstruct string_elist *setstr_elist;\n\tconst char *p, *p2;\n\tchar replybuf[0x2000];\n\tsize_t L;\n\tDL_FOREACH(opt_set_device_list, setstr_elist)\n\t{\n\t\tconst char * const setstr = setstr_elist->string;\n\t\tp = strchr(setstr, ':');\n\t\tif (!p)\n\t\t\tp = setstr;\n\t\t{\n\t\t\tL = p - setstr;\n\t\t\tchar pattern[L + 1];\n\t\t\tif (L)\n\t\t\t\tmemcpy(pattern, setstr, L);\n\t\t\tpattern[L] = '\\0';\n\t\t\tif (!cgpu_match(pattern, cgpu))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": %s: Matched with set default: %s\",\n\t\t       cgpu->proc_repr, __func__, setstr);\n\t\t\n\t\tif (p[0] == ':')\n\t\t\t++p;\n\t\tp2 = strchr(p, '=');\n\t\tif (!p2)\n\t\t{\n\t\t\tL = strlen(p);\n\t\t\tp2 = \"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL = p2 - p;\n\t\t\t++p2;\n\t\t}\n\t\tchar opt[L + 1];\n\t\tif (L)\n\t\t\tmemcpy(opt, p, L);\n\t\topt[L] = '\\0';\n\t\t\n\t\tL = strlen(p2);\n\t\tchar setval[L + 1];\n\t\tif (L)\n\t\t\tmemcpy(setval, p2, L);\n\t\tsetval[L] = '\\0';\n\t\t\n\t\tenum bfg_set_device_replytype success;\n\t\tp = proc_set_device(cgpu, opt, setval, replybuf, &success);\n\t\tswitch (success)\n\t\t{\n\t\t\tcase SDR_OK:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Applied rule %s%s%s\",\n\t\t\t\t       cgpu->proc_repr, setstr,\n\t\t\t\t       p ? \": \" : \"\", p ?: \"\");\n\t\t\t\tbreak;\n\t\t\tcase SDR_ERR:\n\t\t\tcase SDR_HELP:\n\t\t\tcase SDR_UNKNOWN:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": Applying rule %s: %s\",\n\t\t\t\t       cgpu->proc_repr, setstr, p);\n\t\t\t\tbreak;\n\t\t\tcase SDR_AUTO:\n\t\t\tcase SDR_NOSUPP:\n\t\t\t\tapplog(LOG_DEBUG, \"%\"PRIpreprv\": set_device is not implemented (trying to apply rule: %s)\",\n\t\t\t\t       cgpu->proc_repr, setstr);\n\t\t}\n\t}\n\tcgpu->already_set_defaults = true;\n}\n\nvoid drv_set_defaults(const struct device_drv * const drv, const void *datap, void *userp, const char * const devpath, const char * const serial, const int mode)\n{\n\tstruct device_drv dummy_drv = *drv;\n\tstruct cgpu_info dummy_cgpu = {\n\t\t.drv = &dummy_drv,\n\t\t.device = &dummy_cgpu,\n\t\t.device_id = -1,\n\t\t.proc_id = -1,\n\t\t.device_data = userp,\n\t\t.device_path = devpath,\n\t\t.dev_serial = serial,\n\t};\n\tstrcpy(dummy_cgpu.proc_repr, drv->name);\n\tswitch (mode)\n\t{\n\t\tcase 0:\n\t\t\tdummy_drv.set_device = datap;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdummy_drv.set_device = NULL;\n\t\t\tdummy_cgpu.set_device_funcs = datap;\n\t\t\tbreak;\n\t}\n\tcgpu_set_defaults(&dummy_cgpu);\n}\n\n/* Makes sure the hashmeter keeps going even if mining threads stall, updates\n * the screen at regular intervals, and restarts threads if they appear to have\n * died. */\n#define WATCHDOG_SICK_TIME\t\t60\n#define WATCHDOG_DEAD_TIME\t\t600\n#define WATCHDOG_SICK_COUNT\t\t(WATCHDOG_SICK_TIME/WATCHDOG_INTERVAL)\n#define WATCHDOG_DEAD_COUNT\t\t(WATCHDOG_DEAD_TIME/WATCHDOG_INTERVAL)\n\nstatic void *watchdog_thread(void __maybe_unused *userdata)\n{\n\tconst unsigned int interval = WATCHDOG_INTERVAL;\n\tstruct timeval zero_tv;\n\n#ifndef HAVE_PTHREAD_CANCEL\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n#endif\n\n\tRenameThread(\"watchdog\");\n\n\tmemset(&zero_tv, 0, sizeof(struct timeval));\n\tcgtime(&rotate_tv);\n\n\twhile (1) {\n\t\tint i;\n\t\tstruct timeval now;\n\n\t\tsleep(interval);\n\n\t\tdiscard_stale();\n\n\t\thashmeter(-1, &zero_tv, 0);\n\n#ifdef HAVE_CURSES\n\t\tconst int ts = total_staged(true);\n\t\tif (curses_active_locked()) {\n\t\t\tchange_logwinsize();\n\t\t\tcurses_print_status(ts);\n\t\t\t_refresh_devstatus(true);\n\t\t\ttouchwin(logwin);\n\t\t\twrefresh(logwin);\n\t\t\tunlock_curses();\n\t\t}\n#endif\n\n\t\tcgtime(&now);\n\n\t\tif (!sched_paused && !should_run()) {\n\t\t\tapplog(LOG_WARNING, \"Pausing execution as per stop time %02d:%02d scheduled\",\n\t\t\t       schedstop.tm.tm_hour, schedstop.tm.tm_min);\n\t\t\tif (!schedstart.enable) {\n\t\t\t\tquit(0, \"Terminating execution as planned\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tapplog(LOG_WARNING, \"Will restart execution as scheduled at %02d:%02d\",\n\t\t\t       schedstart.tm.tm_hour, schedstart.tm.tm_min);\n\t\t\tsched_paused = true;\n\n\t\t\trd_lock(&mining_thr_lock);\n\t\t\tfor (i = 0; i < mining_threads; i++)\n\t\t\t\tmining_thr[i]->pause = true;\n\t\t\trd_unlock(&mining_thr_lock);\n\t\t} else if (sched_paused && should_run()) {\n\t\t\tapplog(LOG_WARNING, \"Restarting execution as per start time %02d:%02d scheduled\",\n\t\t\t\tschedstart.tm.tm_hour, schedstart.tm.tm_min);\n\t\t\tif (schedstop.enable)\n\t\t\t\tapplog(LOG_WARNING, \"Will pause execution as scheduled at %02d:%02d\",\n\t\t\t\t\tschedstop.tm.tm_hour, schedstop.tm.tm_min);\n\t\t\tsched_paused = false;\n\n\t\t\tfor (i = 0; i < mining_threads; i++) {\n\t\t\t\tstruct thr_info *thr;\n\n\t\t\t\tthr = get_thread(i);\n\t\t\t\tthr->pause = false;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; i < total_devices; ++i)\n\t\t\t{\n\t\t\t\tstruct cgpu_info *cgpu = get_devices(i);\n\t\t\t\t\n\t\t\t\t/* Don't touch disabled devices */\n\t\t\t\tif (cgpu->deven == DEV_DISABLED)\n\t\t\t\t\tcontinue;\n\t\t\t\tproc_enable(cgpu);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < total_devices; ++i) {\n\t\t\tstruct cgpu_info *cgpu = get_devices(i);\n\t\t\tif (!cgpu->disable_watchdog)\n\t\t\t\tbfg_watchdog(cgpu, &now);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nvoid bfg_watchdog(struct cgpu_info * const cgpu, struct timeval * const tvp_now)\n{\n\t\t\tstruct thr_info *thr = cgpu->thr[0];\n\t\t\tenum dev_enable *denable;\n\t\t\tchar *dev_str = cgpu->proc_repr;\n\n\t\t\tif (likely(drv_ready(cgpu)))\n\t\t\t{\n\t\t\t\tif (unlikely(!cgpu->already_set_defaults))\n\t\t\t\t\tcgpu_set_defaults(cgpu);\n\t\t\t\tif (cgpu->drv->get_stats)\n\t\t\t\t\tcgpu->drv->get_stats(cgpu);\n\t\t\t}\n\n\t\t\tdenable = &cgpu->deven;\n\n\t\t\tif (cgpu->drv->watchdog)\n\t\t\t\tcgpu->drv->watchdog(cgpu, tvp_now);\n\t\t\t\n\t\t\t/* Thread is disabled */\n\t\t\tif (*denable == DEV_DISABLED)\n\t\t\t\treturn;\n\t\t\telse\n\t\t\tif (*denable == DEV_RECOVER_ERR) {\n\t\t\t\tif (opt_restart && timer_elapsed(&cgpu->tv_device_last_not_well, NULL) > cgpu->reinit_backoff) {\n\t\t\t\t\tapplog(LOG_NOTICE, \"Attempting to reinitialize %s\",\n\t\t\t\t\t       dev_str);\n\t\t\t\t\tif (cgpu->reinit_backoff < 300)\n\t\t\t\t\t\tcgpu->reinit_backoff *= 2;\n\t\t\t\t\tdevice_recovered(cgpu);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\tif (*denable == DEV_RECOVER) {\n\t\t\t\tif (opt_restart && cgpu->temp < cgpu->targettemp) {\n\t\t\t\t\tapplog(LOG_NOTICE, \"%s recovered to temperature below target, re-enabling\",\n\t\t\t\t\t       dev_str);\n\t\t\t\t\tdevice_recovered(cgpu);\n\t\t\t\t}\n\t\t\t\tdev_error_update(cgpu, REASON_DEV_THERMAL_CUTOFF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\tif (cgpu->temp > cgpu->cutofftemp)\n\t\t\t{\n\t\t\t\tapplog(LOG_WARNING, \"%s hit thermal cutoff limit at %dC, disabling!\",\n\t\t\t\t       dev_str, (int)cgpu->temp);\n\t\t\t\t*denable = DEV_RECOVER;\n\n\t\t\t\tdev_error(cgpu, REASON_DEV_THERMAL_CUTOFF);\n\t\t\t\trun_cmd(cmd_idle);\n\t\t\t}\n\n\t\t\tif (thr->getwork) {\n\t\t\t\tif (cgpu->status == LIFE_WELL && thr->getwork < tvp_now->tv_sec - opt_log_interval) {\n\t\t\t\t\tint thrid;\n\t\t\t\t\tbool cgpu_idle = true;\n\t\t\t\t\tthr->rolling = 0;\n\t\t\t\t\tfor (thrid = 0; thrid < cgpu->threads; ++thrid)\n\t\t\t\t\t\tif (!cgpu->thr[thrid]->getwork)\n\t\t\t\t\t\t\tcgpu_idle = false;\n\t\t\t\t\tif (cgpu_idle) {\n\t\t\t\t\t\tcgpu->rolling = 0;\n\t\t\t\t\t\tcgpu->status = LIFE_WAIT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (cgpu->status == LIFE_WAIT)\n\t\t\t\tcgpu->status = LIFE_WELL;\n\n#ifdef USE_CPUMINING\n\t\t\tif (!strcmp(cgpu->drv->dname, \"cpu\"))\n\t\t\t\treturn;\n#endif\n\t\t\tif (cgpu->status != LIFE_WELL && (tvp_now->tv_sec - thr->last.tv_sec < WATCHDOG_SICK_TIME)) {\n\t\t\t\tif (likely(cgpu->status != LIFE_INIT && cgpu->status != LIFE_INIT2))\n\t\t\t\tapplog(LOG_ERR, \"%s: Recovered, declaring WELL!\", dev_str);\n\t\t\t\tcgpu->status = LIFE_WELL;\n\t\t\t\tcgpu->device_last_well = time(NULL);\n\t\t\t} else if (cgpu->status == LIFE_WELL && (tvp_now->tv_sec - thr->last.tv_sec > WATCHDOG_SICK_TIME)) {\n\t\t\t\tthr->rolling = cgpu->rolling = 0;\n\t\t\t\tcgpu->status = LIFE_SICK;\n\t\t\t\tapplog(LOG_ERR, \"%s: Idle for more than 60 seconds, declaring SICK!\", dev_str);\n\t\t\t\tcgtime(&thr->sick);\n\n\t\t\t\tdev_error(cgpu, REASON_DEV_SICK_IDLE_60);\n\t\t\t\trun_cmd(cmd_sick);\n\t\t\t\t\n\t\t\t\tif (opt_restart && cgpu->drv->reinit_device) {\n\t\t\t\t\tapplog(LOG_ERR, \"%s: Attempting to restart\", dev_str);\n\t\t\t\t\treinit_device(cgpu);\n\t\t\t\t}\n\t\t\t} else if (cgpu->status == LIFE_SICK && (tvp_now->tv_sec - thr->last.tv_sec > WATCHDOG_DEAD_TIME)) {\n\t\t\t\tcgpu->status = LIFE_DEAD;\n\t\t\t\tapplog(LOG_ERR, \"%s: Not responded for more than 10 minutes, declaring DEAD!\", dev_str);\n\t\t\t\tcgtime(&thr->sick);\n\n\t\t\t\tdev_error(cgpu, REASON_DEV_DEAD_IDLE_600);\n\t\t\t\trun_cmd(cmd_dead);\n\t\t\t} else if (tvp_now->tv_sec - thr->sick.tv_sec > 60 &&\n\t\t\t\t   (cgpu->status == LIFE_SICK || cgpu->status == LIFE_DEAD)) {\n\t\t\t\t/* Attempt to restart a GPU that's sick or dead once every minute */\n\t\t\t\tcgtime(&thr->sick);\n\t\t\t\tif (opt_restart)\n\t\t\t\t\treinit_device(cgpu);\n\t\t\t}\n}\n\nstatic void log_print_status(struct cgpu_info *cgpu)\n{\n\tchar logline[255];\n\n\tget_statline(logline, sizeof(logline), cgpu);\n\tapplog(LOG_WARNING, \"%s\", logline);\n}\n\nvoid print_summary(void)\n{\n\tstruct timeval diff;\n\tint hours, mins, secs, i;\n\tdouble utility, efficiency = 0.0;\n\tchar xfer[(ALLOC_H2B_SPACED*2)+4+1], bw[(ALLOC_H2B_SPACED*2)+6+1];\n\tint pool_secs;\n\n\ttimersub(&total_tv_end, &total_tv_start, &diff);\n\thours = diff.tv_sec / 3600;\n\tmins = (diff.tv_sec % 3600) / 60;\n\tsecs = diff.tv_sec % 60;\n\n\tutility = total_accepted / total_secs * 60;\n\tefficiency = total_bytes_xfer ? total_diff_accepted * 2048. / total_bytes_xfer : 0.0;\n\n\tapplog(LOG_WARNING, \"\\nSummary of runtime statistics:\\n\");\n\tapplog(LOG_WARNING, \"Started at %s\", datestamp);\n\tif (total_pools == 1)\n\t\tapplog(LOG_WARNING, \"Pool: %s\", pools[0]->rpc_url);\n#if defined(USE_CPUMINING) && defined(USE_SHA256D)\n\tif (opt_n_threads > 0)\n\t\tapplog(LOG_WARNING, \"CPU hasher algorithm used: %s\", algo_names[opt_algo]);\n#endif\n\tapplog(LOG_WARNING, \"Runtime: %d hrs : %d mins : %d secs\", hours, mins, secs);\n\tapplog(LOG_WARNING, \"Average hashrate: %.1f Megahash/s\", total_mhashes_done / total_secs);\n\tapplog(LOG_WARNING, \"Solved blocks: %d\", found_blocks);\n\tapplog(LOG_WARNING, \"Best share difficulty: %s\", best_share);\n\tapplog(LOG_WARNING, \"Share submissions: %d\", total_accepted + total_rejected);\n\tapplog(LOG_WARNING, \"Accepted shares: %d\", total_accepted);\n\tapplog(LOG_WARNING, \"Rejected shares: %d + %d stale (%.2f%%)\",\n\t       total_rejected, total_stale,\n\t       (float)(total_rejected + total_stale) / (float)(total_rejected + total_stale + total_accepted)\n\t);\n\tapplog(LOG_WARNING, \"Accepted difficulty shares: %1.f\", total_diff_accepted);\n\tapplog(LOG_WARNING, \"Rejected difficulty shares: %1.f\", total_diff_rejected);\n\tapplog(LOG_WARNING, \"Hardware errors: %d\", hw_errors);\n\tapplog(LOG_WARNING, \"Network transfer: %s  (%s)\",\n\t       multi_format_unit2(xfer, sizeof(xfer), true, \"B\", H2B_SPACED, \" / \", 2,\n\t                         (float)total_bytes_rcvd,\n\t                         (float)total_bytes_sent),\n\t       multi_format_unit2(bw, sizeof(bw), true, \"B/s\", H2B_SPACED, \" / \", 2,\n\t                         (float)(total_bytes_rcvd / total_secs),\n\t                         (float)(total_bytes_sent / total_secs)));\n\tapplog(LOG_WARNING, \"Efficiency (accepted shares * difficulty / 2 KB): %.2f\", efficiency);\n\tapplog(LOG_WARNING, \"Utility (accepted shares / min): %.2f/min\\n\", utility);\n\n\tapplog(LOG_WARNING, \"Unable to get work from server occasions: %d\", total_go);\n\tapplog(LOG_WARNING, \"Work items generated locally: %d\", local_work);\n\tapplog(LOG_WARNING, \"Submitting work remotely delay occasions: %d\", total_ro);\n\tapplog(LOG_WARNING, \"New blocks detected on network: %d\\n\", new_blocks);\n\n\tif (total_pools > 1) {\n\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\tstruct pool *pool = pools[i];\n\n\t\t\tapplog(LOG_WARNING, \"Pool: %s\", pool->rpc_url);\n\t\t\tif (pool->solved)\n\t\t\t\tapplog(LOG_WARNING, \"SOLVED %d BLOCK%s!\", pool->solved, pool->solved > 1 ? \"S\" : \"\");\n\t\t\tapplog(LOG_WARNING, \" Share submissions: %d\", pool->accepted + pool->rejected);\n\t\t\tapplog(LOG_WARNING, \" Accepted shares: %d\", pool->accepted);\n\t\t\tapplog(LOG_WARNING, \" Rejected shares: %d + %d stale (%.2f%%)\",\n\t\t\t       pool->rejected, pool->stale_shares,\n\t\t\t       (float)(pool->rejected + pool->stale_shares) / (float)(pool->rejected + pool->stale_shares + pool->accepted)\n\t\t\t);\n\t\t\tapplog(LOG_WARNING, \" Accepted difficulty shares: %1.f\", pool->diff_accepted);\n\t\t\tapplog(LOG_WARNING, \" Rejected difficulty shares: %1.f\", pool->diff_rejected);\n\t\t\tpool_secs = timer_elapsed(&pool->cgminer_stats.start_tv, NULL);\n\t\t\tapplog(LOG_WARNING, \" Network transfer: %s  (%s)\",\n\t\t\t       multi_format_unit2(xfer, sizeof(xfer), true, \"B\", H2B_SPACED, \" / \", 2,\n\t\t\t                         (float)pool->cgminer_pool_stats.net_bytes_received,\n\t\t\t                         (float)pool->cgminer_pool_stats.net_bytes_sent),\n\t\t\t       multi_format_unit2(bw, sizeof(bw), true, \"B/s\", H2B_SPACED, \" / \", 2,\n\t\t\t                         (float)(pool->cgminer_pool_stats.net_bytes_received / pool_secs),\n\t\t\t                         (float)(pool->cgminer_pool_stats.net_bytes_sent / pool_secs)));\n\t\t\tuint64_t pool_bytes_xfer = pool->cgminer_pool_stats.net_bytes_received + pool->cgminer_pool_stats.net_bytes_sent;\n\t\t\tefficiency = pool_bytes_xfer ? pool->diff_accepted * 2048. / pool_bytes_xfer : 0.0;\n\t\t\tapplog(LOG_WARNING, \" Efficiency (accepted * difficulty / 2 KB): %.2f\", efficiency);\n\n\t\t\tapplog(LOG_WARNING, \" Items worked on: %d\", pool->works);\n\t\t\tapplog(LOG_WARNING, \" Unable to get work from server occasions: %d\", pool->getfail_occasions);\n\t\t\tapplog(LOG_WARNING, \" Submitting work remotely delay occasions: %d\\n\", pool->remotefail_occasions);\n\t\t}\n\t}\n\n\tif (opt_quit_summary != BQS_NONE)\n\t{\n\t\tif (opt_quit_summary == BQS_DEFAULT)\n\t\t{\n\t\t\tif (total_devices < 25)\n\t\t\t\topt_quit_summary = BQS_PROCS;\n\t\t\telse\n\t\t\t\topt_quit_summary = BQS_DEVS;\n\t\t}\n\t\t\n\t\tif (opt_quit_summary == BQS_DETAILED)\n\t\t\tinclude_serial_in_statline = true;\n\t\tapplog(LOG_WARNING, \"Summary of per device statistics:\\n\");\n\t\tfor (i = 0; i < total_devices; ++i) {\n\t\t\tstruct cgpu_info *cgpu = get_devices(i);\n\t\t\t\n\t\t\tif (!cgpu->proc_id)\n\t\t\t{\n\t\t\t\t// Device summary line\n\t\t\t\topt_show_procs = false;\n\t\t\t\tlog_print_status(cgpu);\n\t\t\t\topt_show_procs = true;\n\t\t\t}\n\t\t\tif ((opt_quit_summary == BQS_PROCS || opt_quit_summary == BQS_DETAILED) && cgpu->procs > 1)\n\t\t\t\tlog_print_status(cgpu);\n\t\t}\n\t}\n\n\tif (opt_shares) {\n\t\tapplog(LOG_WARNING, \"Mined %g accepted shares of %g requested\\n\", total_diff_accepted, opt_shares);\n\t\tif (opt_shares > total_diff_accepted)\n\t\t\tapplog(LOG_WARNING, \"WARNING - Mined only %g shares of %g requested.\", total_diff_accepted, opt_shares);\n\t}\n\tapplog(LOG_WARNING, \" \");\n\n\tfflush(stderr);\n\tfflush(stdout);\n}\n\nvoid _bfg_clean_up(bool restarting)\n{\n#ifdef USE_OPENCL\n\tclear_adl(nDevs);\n#endif\n#ifdef HAVE_LIBUSB\n\tif (likely(have_libusb))\n        libusb_exit(NULL);\n#endif\n\n\tcgtime(&total_tv_end);\n#ifdef WIN32\n\ttimeEndPeriod(1);\n#endif\n\tif (!restarting) {\n\t\t/* Attempting to disable curses or print a summary during a\n\t\t * restart can lead to a deadlock. */\n#ifdef HAVE_CURSES\n\t\tdisable_curses();\n#endif\n\t\tif (!opt_realquiet && successful_connect)\n\t\t\tprint_summary();\n\t}\n\n#ifdef USE_CPUMINING\n\tif (opt_n_threads > 0)\n\t\tfree(cpus);\n#endif\n\n\tcurl_global_cleanup();\n\t\n#ifdef WIN32\n\tWSACleanup();\n#endif\n}\n\nvoid _quit(int status)\n{\n\tif (status) {\n\t\tconst char *ev = getenv(\"__BFGMINER_SEGFAULT_ERRQUIT\");\n\t\tif (unlikely(ev && ev[0] && ev[0] != '0')) {\n\t\t\tint *p = NULL;\n\t\t\t// NOTE debugger can bypass with: p = &p\n\t\t\t*p = status;  // Segfault, hopefully dumping core\n\t\t}\n\t}\n\n#if defined(unix) || defined(__APPLE__)\n\tif (forkpid > 0) {\n\t\tkill(forkpid, SIGTERM);\n\t\tforkpid = 0;\n\t}\n#endif\n\n\texit(status);\n}\n\n#ifdef HAVE_CURSES\nchar *curses_input(const char *query)\n{\n\tchar *input;\n\n\techo();\n\tinput = malloc(255);\n\tif (!input)\n\t\tquit(1, \"Failed to malloc input\");\n\tleaveok(logwin, false);\n\twlogprint(\"%s:\\n\", query);\n\twgetnstr(logwin, input, 255);\n\tif (!strlen(input))\n\t{\n\t\tfree(input);\n\t\tinput = NULL;\n\t}\n\tleaveok(logwin, true);\n\tnoecho();\n\treturn input;\n}\n#endif\n\nstatic void *test_pool_thread(void *arg)\n{\n\tstruct pool *pool = (struct pool *)arg;\n\n\tif (pool_active(pool, false)) {\n\t\tpool_tset(pool, &pool->lagging);\n\t\tpool_tclear(pool, &pool->idle);\n\t\tbool first_pool = false;\n\n\t\tcg_wlock(&control_lock);\n\t\tif (!pools_active) {\n\t\t\tcurrentpool = pool;\n\t\t\tif (pool->pool_no != 0)\n\t\t\t\tfirst_pool = true;\n\t\t\tpools_active = true;\n\t\t}\n\t\tcg_wunlock(&control_lock);\n\n\t\tif (unlikely(first_pool))\n\t\t\tapplog(LOG_NOTICE, \"Switching to pool %d %s - first alive pool\", pool->pool_no, pool->rpc_url);\n\t\telse\n\t\t\tapplog(LOG_NOTICE, \"Pool %d %s alive\", pool->pool_no, pool->rpc_url);\n\n\t\tswitch_pools(NULL);\n\t} else\n\t\tpool_died(pool);\n\n\tpool->testing = false;\n\treturn NULL;\n}\n\n/* Always returns true that the pool details were added unless we are not\n * live, implying this is the only pool being added, so if no pools are\n * active it returns false. */\nbool add_pool_details(struct pool *pool, bool live, char *url, char *user, char *pass)\n{\n\tsize_t siz;\n\n\tpool_set_uri(pool, url);\n\tpool->rpc_user = user;\n\tpool->rpc_pass = pass;\n\tsiz = strlen(pool->rpc_user) + strlen(pool->rpc_pass) + 2;\n\tpool->rpc_userpass = malloc(siz);\n\tif (!pool->rpc_userpass)\n\t\tquit(1, \"Failed to malloc userpass\");\n\tsnprintf(pool->rpc_userpass, siz, \"%s:%s\", pool->rpc_user, pool->rpc_pass);\n\n\tpool->testing = true;\n\tpool->idle = true;\n\tenable_pool(pool);\n\n\tpthread_create(&pool->test_thread, NULL, test_pool_thread, (void *)pool);\n\tif (!live) {\n\t\tpthread_join(pool->test_thread, NULL);\n\t\treturn pools_active;\n\t}\n\treturn true;\n}\n\n#ifdef HAVE_CURSES\nstatic bool input_pool(bool live)\n{\n\tchar *url = NULL, *user = NULL, *pass = NULL;\n\tstruct pool *pool;\n\tbool ret = false;\n\n\timmedok(logwin, true);\n\twlogprint(\"Input server details.\\n\");\n\n\turl = curses_input(\"URL\");\n\tif (!url)\n\t\tgoto out;\n\n\tuser = curses_input(\"Username\");\n\tif (!user)\n\t\tgoto out;\n\n\tpass = curses_input(\"Password\");\n\tif (!pass)\n\t\tpass = calloc(1, 1);\n\n\tpool = add_pool();\n\n\tif (!detect_stratum(pool, url) && strncmp(url, \"http://\", 7) &&\n\t    strncmp(url, \"https://\", 8)) {\n\t\tchar *httpinput;\n\n\t\thttpinput = malloc(256);\n\t\tif (!httpinput)\n\t\t\tquit(1, \"Failed to malloc httpinput\");\n\t\tstrcpy(httpinput, \"http://\");\n\t\tstrncat(httpinput, url, 248);\n\t\tfree(url);\n\t\turl = httpinput;\n\t}\n\n\tret = add_pool_details(pool, live, url, user, pass);\nout:\n\timmedok(logwin, false);\n\n\tif (!ret) {\n\t\tif (url)\n\t\t\tfree(url);\n\t\tif (user)\n\t\t\tfree(user);\n\t\tif (pass)\n\t\t\tfree(pass);\n\t}\n\treturn ret;\n}\n#endif\n\n#if BLKMAKER_VERSION > 1 && defined(USE_SHA256D)\nstatic\nbool _add_local_gbt(const char * const filepath, void *userp)\n{\n\tconst bool * const live_p = userp;\n\tstruct pool *pool;\n\tchar buf[0x100];\n\tchar *rpcuser = NULL, *rpcpass = NULL, *rpcconnect = NULL;\n\tint rpcport = 0, rpcssl = -101;\n\tFILE * const F = fopen(filepath, \"r\");\n\tif (!F)\n\t\tapplogr(false, LOG_WARNING, \"%s: Failed to open %s for reading\", \"add_local_gbt\", filepath);\n\t\n\twhile (fgets(buf, sizeof(buf), F))\n\t{\n\t\tif (!strncasecmp(buf, \"rpcuser=\", 8))\n\t\t\trpcuser = trimmed_strdup(&buf[8]);\n\t\telse\n\t\tif (!strncasecmp(buf, \"rpcpassword=\", 12))\n\t\t\trpcpass = trimmed_strdup(&buf[12]);\n\t\telse\n\t\tif (!strncasecmp(buf, \"rpcport=\", 8))\n\t\t\trpcport = atoi(&buf[8]);\n\t\telse\n\t\tif (!strncasecmp(buf, \"rpcssl=\", 7))\n\t\t\trpcssl = atoi(&buf[7]);\n\t\telse\n\t\tif (!strncasecmp(buf, \"rpcconnect=\", 11))\n\t\t\trpcconnect = trimmed_strdup(&buf[11]);\n\t\telse\n\t\t\tcontinue;\n\t\tif (rpcuser && rpcpass && rpcport && rpcssl != -101 && rpcconnect)\n\t\t\tbreak;\n\t}\n\t\n\tfclose(F);\n\t\n\tif (!rpcpass)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Did not find rpcpassword in %s\", \"add_local_gbt\", filepath);\nerr:\n\t\tfree(rpcuser);\n\t\tfree(rpcpass);\n\t\tgoto out;\n\t}\n\t\n\tif (!rpcport)\n\t\trpcport = 8332;\n\t\n\tif (rpcssl == -101)\n\t\trpcssl = 0;\n\t\n\tconst bool have_cbaddr = get_mining_goal(\"default\")->generation_script;\n\t\n\tconst int uri_sz = 0x30;\n\tchar * const uri = malloc(uri_sz);\n\tsnprintf(uri, uri_sz, \"http%s://%s:%d/%s#allblocks\", rpcssl ? \"s\" : \"\", rpcconnect ?: \"localhost\", rpcport, have_cbaddr ? \"\" : \"#getcbaddr\");\n\t\n\tchar hfuri[0x40];\n\tif (rpcconnect)\n\t\tsnprintf(hfuri, sizeof(hfuri), \"%s:%d\", rpcconnect, rpcport);\n\telse\n\t\tsnprintf(hfuri, sizeof(hfuri), \"port %d\", rpcport);\n\tapplog(LOG_DEBUG, \"Local bitcoin RPC server on %s found in %s\", hfuri, filepath);\n\t\n\tfor (int i = 0; i < total_pools; ++i)\n\t{\n\t\tstruct pool *pool = pools[i];\n\t\t\n\t\tif (!(strcmp(pool->rpc_url, uri) || strcmp(pool->rpc_pass, rpcpass)))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Server on %s is already configured, not adding as failover\", hfuri);\n\t\t\tfree(uri);\n\t\t\tgoto err;\n\t\t}\n\t}\n\t\n\tpool = add_pool();\n\tif (!pool)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Error adding pool for bitcoin configured in %s\", \"add_local_gbt\", filepath);\n\t\tgoto err;\n\t}\n\t\n\tif (!rpcuser)\n\t\trpcuser = \"\";\n\t\n\tpool->quota = 0;\n\tadjust_quota_gcd();\n\tpool->failover_only = true;\n\tadd_pool_details(pool, *live_p, uri, rpcuser, rpcpass);\n\t\n\tapplog(LOG_NOTICE, \"Added local bitcoin RPC server on %s as pool %d\", hfuri, pool->pool_no);\n\t\nout:\n\treturn false;\n}\n\nstatic\nvoid add_local_gbt(bool live)\n{\n\tappdata_file_call(\"Bitcoin\", \"bitcoin.conf\", _add_local_gbt, &live);\n}\n#endif\n\n#if defined(unix) || defined(__APPLE__)\nstatic void fork_monitor()\n{\n\t// Make a pipe: [readFD, writeFD]\n\tint pfd[2];\n\tint r = pipe(pfd);\n\n\tif (r < 0) {\n\t\tperror(\"pipe - failed to create pipe for --monitor\");\n\t\texit(1);\n\t}\n\n\t// Make stderr write end of pipe\n\tfflush(stderr);\n\tr = dup2(pfd[1], 2);\n\tif (r < 0) {\n\t\tperror(\"dup2 - failed to alias stderr to write end of pipe for --monitor\");\n\t\texit(1);\n\t}\n\tr = close(pfd[1]);\n\tif (r < 0) {\n\t\tperror(\"close - failed to close write end of pipe for --monitor\");\n\t\texit(1);\n\t}\n\n\t// Don't allow a dying monitor to kill the main process\n\tsighandler_t sr0 = signal(SIGPIPE, SIG_IGN);\n\tsighandler_t sr1 = signal(SIGPIPE, SIG_IGN);\n\tif (SIG_ERR == sr0 || SIG_ERR == sr1) {\n\t\tperror(\"signal - failed to edit signal mask for --monitor\");\n\t\texit(1);\n\t}\n\n\t// Fork a child process\n\tforkpid = fork();\n\tif (forkpid < 0) {\n\t\tperror(\"fork - failed to fork child process for --monitor\");\n\t\texit(1);\n\t}\n\n\t// Child: launch monitor command\n\tif (0 == forkpid) {\n\t\t// Make stdin read end of pipe\n\t\tr = dup2(pfd[0], 0);\n\t\tif (r < 0) {\n\t\t\tperror(\"dup2 - in child, failed to alias read end of pipe to stdin for --monitor\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(pfd[0]);\n\t\tif (r < 0) {\n\t\t\tperror(\"close - in child, failed to close read end of  pipe for --monitor\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Launch user specified command\n\t\texecl(\"/bin/bash\", \"/bin/bash\", \"-c\", opt_stderr_cmd, (char*)NULL);\n\t\tperror(\"execl - in child failed to exec user specified command for --monitor\");\n\t\texit(1);\n\t}\n\n\t// Parent: clean up unused fds and bail\n\tr = close(pfd[0]);\n\tif (r < 0) {\n\t\tperror(\"close - failed to close read end of pipe for --monitor\");\n\t\texit(1);\n\t}\n}\n#endif // defined(unix)\n\n#ifdef HAVE_CURSES\n#ifdef USE_UNICODE\nstatic\nwchar_t select_unicode_char(const wchar_t *opt)\n{\n\tfor ( ; *opt; ++opt)\n\t\tif (iswprint(*opt))\n\t\t\treturn *opt;\n\treturn '?';\n}\n#endif\n\nvoid enable_curses(void) {\n\tint x;\n\t__maybe_unused int y;\n\n\tlock_curses();\n\tif (curses_active) {\n\t\tunlock_curses();\n\t\treturn;\n\t}\n\n#ifdef USE_UNICODE\n\tif (use_unicode)\n\t{\n\t\tsetlocale(LC_CTYPE, \"\");\n\t\tif (iswprint(0xb0))\n\t\t\thave_unicode_degrees = true;\n\t\tunicode_micro = select_unicode_char(L\"\\xb5\\u03bcu\");\n\t}\n#endif\n\tmainwin = initscr();\n\tstart_color();\n#if defined(PDCURSES) || defined(NCURSES_VERSION)\n\tif (ERR != use_default_colors())\n\t\tdefault_bgcolor = -1;\n#endif\n\tif (has_colors() && ERR != init_pair(1, COLOR_WHITE, COLOR_BLUE))\n\t{\n\t\tmenu_attr = COLOR_PAIR(1);\n\t\tif (ERR != init_pair(2, COLOR_RED, default_bgcolor))\n\t\t\tattr_bad |= COLOR_PAIR(2);\n\t}\n\tkeypad(mainwin, true);\n\tgetmaxyx(mainwin, y, x);\n\tstatuswin = newwin(logstart, x, 0, 0);\n\tleaveok(statuswin, true);\n\t// For whatever reason, PDCurses crashes if the logwin is initialized to height y-logcursor\n\t// We resize the window later anyway, so just start it off at 1 :)\n\tlogwin = newwin(1, 0, logcursor, 0);\n\tidlok(logwin, true);\n\tscrollok(logwin, true);\n\tleaveok(logwin, true);\n\tcbreak();\n\tnoecho();\n\tnonl();\n\tcurses_active = true;\n\tstatusy = logstart;\n\tunlock_curses();\n}\n#endif\n\n/* TODO: fix need a dummy CPU device_drv even if no support for CPU mining */\n#ifndef USE_CPUMINING\nstruct device_drv cpu_drv;\nstruct device_drv cpu_drv = {\n\t.name = \"CPU\",\n};\n#endif\n\nstatic int cgminer_id_count = 0;\nstatic int device_line_id_count;\n\nvoid register_device(struct cgpu_info *cgpu)\n{\n\tcgpu->deven = DEV_ENABLED;\n\n\twr_lock(&devices_lock);\n\tdevices[cgpu->cgminer_id = cgminer_id_count++] = cgpu;\n\twr_unlock(&devices_lock);\n\n\tif (!cgpu->proc_id)\n\t\tcgpu->device_line_id = device_line_id_count++;\n\tint thr_objs = cgpu->threads ?: 1;\n\tmining_threads += thr_objs;\n\tbase_queue += thr_objs + cgpu->extra_work_queue;\n\t{\n\t\tconst struct device_drv * const drv = cgpu->drv;\n\t\tstruct mining_algorithm *malgo;\n\t\tLL_FOREACH(mining_algorithms, malgo)\n\t\t{\n\t\t\tif (drv_min_nonce_diff(drv, cgpu, malgo) < 0)\n\t\t\t\tcontinue;\n\t\t\tmalgo->base_queue += thr_objs + cgpu->extra_work_queue;\n\t\t}\n\t}\n#ifdef HAVE_CURSES\n\tadj_width(mining_threads, &dev_width);\n#endif\n\n\trwlock_init(&cgpu->qlock);\n\tcgpu->queued_work = NULL;\n}\n\nstruct _cgpu_devid_counter {\n\tchar name[4];\n\tint lastid;\n\tUT_hash_handle hh;\n};\n\nvoid renumber_cgpu(struct cgpu_info *cgpu)\n{\n\tstatic struct _cgpu_devid_counter *devids = NULL;\n\tstruct _cgpu_devid_counter *d;\n\t\n\tHASH_FIND_STR(devids, cgpu->drv->name, d);\n\tif (d)\n\t\tcgpu->device_id = ++d->lastid;\n\telse {\n\t\td = malloc(sizeof(*d));\n\t\tmemcpy(d->name, cgpu->drv->name, sizeof(d->name));\n\t\tcgpu->device_id = d->lastid = 0;\n\t\tHASH_ADD_STR(devids, name, d);\n\t}\n\t\n\t// Build repr strings\n\tsprintf(cgpu->dev_repr, \"%s%2u\", cgpu->drv->name, cgpu->device_id % 100);\n\tsprintf(cgpu->dev_repr_ns, \"%s%u\", cgpu->drv->name, cgpu->device_id % 100);\n\tstrcpy(cgpu->proc_repr, cgpu->dev_repr);\n\tsprintf(cgpu->proc_repr_ns, \"%s%u\", cgpu->drv->name, cgpu->device_id);\n\t\n\tconst int lpcount = cgpu->procs;\n\tif (lpcount > 1)\n\t{\n\t\tint ns;\n\t\tstruct cgpu_info *slave;\n\t\tint lpdigits = 1;\n\t\tfor (int i = lpcount; i > 26 && lpdigits < 3; i /= 26)\n\t\t\t++lpdigits;\n\t\t\n\t\tif (lpdigits > max_lpdigits)\n\t\t\tmax_lpdigits = lpdigits;\n\t\t\n\t\tmemset(&cgpu->proc_repr[5], 'a', lpdigits);\n\t\tcgpu->proc_repr[5 + lpdigits] = '\\0';\n\t\tns = strlen(cgpu->proc_repr_ns);\n\t\tstrcpy(&cgpu->proc_repr_ns[ns], &cgpu->proc_repr[5]);\n\t\t\n\t\tslave = cgpu;\n\t\tfor (int i = 1; i < lpcount; ++i)\n\t\t{\n\t\t\tslave = slave->next_proc;\n\t\t\tstrcpy(slave->proc_repr, cgpu->proc_repr);\n\t\t\tstrcpy(slave->proc_repr_ns, cgpu->proc_repr_ns);\n\t\t\tfor (int x = i, y = lpdigits; --y, x; x /= 26)\n\t\t\t{\n\t\t\t\tslave->proc_repr_ns[ns + y] =\n\t\t\t\tslave->proc_repr[5 + y] += (x % 26);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool my_blkmaker_sha256_callback(void *digest, const void *buffer, size_t length)\n{\n\tsha256(buffer, length, digest);\n\treturn true;\n}\n\nstatic\nbool drv_algo_check(const struct device_drv * const drv)\n{\n\tstruct mining_goal_info *goal, *tmpgoal;\n\tHASH_ITER(hh, mining_goals, goal, tmpgoal)\n\t{\n\t\tif (drv_min_nonce_diff(drv, NULL, goal->malgo) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifndef HAVE_PTHREAD_CANCEL\nextern void setup_pthread_cancel_workaround();\nextern struct sigaction pcwm_orig_term_handler;\n#endif\n\nbool bfg_need_detect_rescan;\nextern void probe_device(struct lowlevel_device_info *);\nstatic void schedule_rescan(const struct timeval *);\n\nstatic\nvoid drv_detect_all()\n{\n\tbool rescanning = false;\nrescan:\n\tbfg_need_detect_rescan = false;\n\t\n#ifdef HAVE_BFG_LOWLEVEL\n\tstruct lowlevel_device_info * const infolist = lowlevel_scan(), *info, *infotmp;\n\t\n\tLL_FOREACH_SAFE(infolist, info, infotmp)\n\t\tprobe_device(info);\n\tLL_FOREACH_SAFE(infolist, info, infotmp)\n\t\tpthread_join(info->probe_pth, NULL);\n#endif\n\t\n\tstruct driver_registration *reg;\n\tBFG_FOREACH_DRIVER_BY_PRIORITY(reg)\n\t{\n\t\tconst struct device_drv * const drv = reg->drv;\n\t\tif (!(drv_algo_check(drv) && drv->drv_detect))\n\t\t\tcontinue;\n\t\t\n\t\tdrv->drv_detect();\n\t}\n\n#ifdef HAVE_BFG_LOWLEVEL\n\tlowlevel_scan_free();\n#endif\n\t\n\tif (bfg_need_detect_rescan)\n\t{\n\t\tif (rescanning)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Device rescan requested a second time, delaying\");\n\t\t\tstruct timeval tv_when;\n\t\t\ttimer_set_delay_from_now(&tv_when, rescan_delay_ms * 1000);\n\t\t\tschedule_rescan(&tv_when);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trescanning = true;\n\t\t\tapplog(LOG_DEBUG, \"Device rescan requested\");\n\t\t\tgoto rescan;\n\t\t}\n\t}\n}\n\nstatic\nvoid allocate_cgpu(struct cgpu_info *cgpu, unsigned int *kp)\n{\n\tstruct thr_info *thr;\n\tint j;\n\t\n\tstruct device_drv *api = cgpu->drv;\n\tcgpu->cgminer_stats.getwork_wait_min.tv_sec = MIN_SEC_UNSET;\n\t\n\tint threadobj = cgpu->threads;\n\tif (!threadobj)\n\t\t// Create a fake thread object to handle hashmeter etc\n\t\tthreadobj = 1;\n\tcgpu->thr = calloc(threadobj + 1, sizeof(*cgpu->thr));\n\tcgpu->thr[threadobj] = NULL;\n\tcgpu->status = LIFE_INIT;\n\t\n\tif (opt_devices_enabled_list)\n\t{\n\t\tstruct string_elist *enablestr_elist;\n\t\tcgpu->deven = DEV_DISABLED;\n\t\tDL_FOREACH(opt_devices_enabled_list, enablestr_elist)\n\t\t{\n\t\t\tconst char * const enablestr = enablestr_elist->string;\n\t\t\tif (cgpu_match(enablestr, cgpu))\n\t\t\t{\n\t\t\t\tcgpu->deven = DEV_ENABLED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcgpu->max_hashes = 0;\n\t\n\tBFGINIT(cgpu->cutofftemp, opt_cutofftemp);\n\tBFGINIT(cgpu->targettemp, cgpu->cutofftemp - 6);\n\n\t// Setup thread structs before starting any of the threads, in case they try to interact\n\tfor (j = 0; j < threadobj; ++j, ++*kp) {\n\t\tthr = get_thread(*kp);\n\t\tthr->id = *kp;\n\t\tthr->cgpu = cgpu;\n\t\tthr->device_thread = j;\n\t\tthr->work_restart_notifier[1] = INVSOCK;\n\t\tthr->mutex_request[1] = INVSOCK;\n\t\tthr->_job_transition_in_progress = true;\n\t\ttimerclear(&thr->tv_morework);\n\n\t\tthr->scanhash_working = true;\n\t\tthr->hashes_done = 0;\n\t\ttimerclear(&thr->tv_hashes_done);\n\t\tcgtime(&thr->tv_lastupdate);\n\t\tthr->tv_poll.tv_sec = -1;\n\t\tthr->_max_nonce = api->can_limit_work ? api->can_limit_work(thr) : 0xffffffff;\n\n\t\tcgpu->thr[j] = thr;\n\t}\n\t\n\tif (!cgpu->device->threads)\n\t\tnotifier_init_invalid(cgpu->thr[0]->notifier);\n\telse\n\tif (!cgpu->threads)\n\t\tmemcpy(&cgpu->thr[0]->notifier, &cgpu->device->thr[0]->notifier, sizeof(cgpu->thr[0]->notifier));\n\telse\n\tfor (j = 0; j < cgpu->threads; ++j)\n\t{\n\t\tthr = cgpu->thr[j];\n\t\tnotifier_init(thr->notifier);\n\t}\n}\n\nstatic\nvoid start_cgpu(struct cgpu_info *cgpu)\n{\n\tstruct thr_info *thr;\n\tint j;\n\t\n\tfor (j = 0; j < cgpu->threads; ++j) {\n\t\tthr = cgpu->thr[j];\n\n\t\t/* Enable threads for devices set not to mine but disable\n\t\t * their queue in case we wish to enable them later */\n\t\tif (cgpu->drv->thread_prepare && !cgpu->drv->thread_prepare(thr))\n\t\t\tcontinue;\n\n\t\tthread_reportout(thr);\n\n\t\tif (unlikely(thr_info_create(thr, NULL, miner_thread, thr)))\n\t\t\tquit(1, \"thread %d create failed\", thr->id);\n\t\t\n\t\tnotifier_wake(thr->notifier);\n\t}\n\tif (cgpu->deven == DEV_ENABLED)\n\t\tproc_enable(cgpu);\n}\n\nstatic\nvoid _scan_serial(void *p)\n{\n\tconst char *s = p;\n\tstruct string_elist *iter, *tmp;\n\tstruct string_elist *orig_scan_devices = scan_devices;\n\t\n\tif (s)\n\t{\n\t\t// Make temporary scan_devices list\n\t\tscan_devices = NULL;\n\t\tstring_elist_add(\"noauto\", &scan_devices);\n\t\tadd_serial(s);\n\t}\n\t\n\tdrv_detect_all();\n\t\n\tif (s)\n\t{\n\t\tDL_FOREACH_SAFE(scan_devices, iter, tmp)\n\t\t{\n\t\t\tstring_elist_del(&scan_devices, iter);\n\t\t}\n\t\tscan_devices = orig_scan_devices;\n\t}\n}\n\n#ifdef HAVE_BFG_LOWLEVEL\nstatic\nbool _probe_device_match(const struct lowlevel_device_info * const info, const char * const ser)\n{\n\tif (!(false\n\t\t|| (info->serial && !strcasecmp(ser, info->serial))\n\t\t|| (info->path   && !strcasecmp(ser, info->path  ))\n\t\t|| (info->devid  && !strcasecmp(ser, info->devid ))\n\t))\n\t{\n\t\tchar *devid = devpath_to_devid(ser);\n\t\tif (!devid)\n\t\t\treturn false;\n\t\tconst bool different = strcmp(info->devid, devid);\n\t\tfree(devid);\n\t\tif (different)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic\nbool _probe_device_do_probe(const struct device_drv * const drv, const struct lowlevel_device_info * const info, bool * const request_rescan_p)\n{\n\tbfg_probe_result_flags = 0;\n\tif (drv->lowl_probe(info))\n\t{\n\t\tif (!(bfg_probe_result_flags & BPR_CONTINUE_PROBES))\n\t\t\treturn true;\n\t}\n\telse\n\tif (request_rescan_p && opt_hotplug && !(bfg_probe_result_flags & BPR_DONT_RESCAN))\n\t\t*request_rescan_p = true;\n\treturn false;\n}\n\nbool dummy_check_never_true = false;\n\nstatic\nvoid *probe_device_thread(void *p)\n{\n\tstruct lowlevel_device_info * const infolist = p;\n\tstruct lowlevel_device_info *info = infolist;\n\tbool request_rescan = false;\n\t\n\t{\n\t\tchar threadname[6 + strlen(info->devid) + 1];\n\t\tsprintf(threadname, \"probe_%s\", info->devid);\n\t\tRenameThread(threadname);\n\t}\n\t\n\t// If already in use, ignore\n\tif (bfg_claim_any(NULL, NULL, info->devid))\n\t\tapplogr(NULL, LOG_DEBUG, \"%s: \\\"%s\\\" already in use\",\n\t\t        __func__, info->product);\n\t\n\t// if lowlevel device matches specific user assignment, probe requested driver(s)\n\tstruct string_elist *sd_iter, *sd_tmp;\n\tstruct driver_registration *dreg;\n\tDL_FOREACH_SAFE(scan_devices, sd_iter, sd_tmp)\n\t{\n\t\tconst char * const dname = sd_iter->string;\n\t\tconst char * const colon = strpbrk(dname, \":@\");\n\t\tif (!(colon && colon != dname))\n\t\t\tcontinue;\n\t\tconst char * const ser = &colon[1];\n\t\tLL_FOREACH2(infolist, info, same_devid_next)\n\t\t{\n\t\t\tif (!_probe_device_match(info, ser))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tconst size_t dnamelen = (colon - dname);\n\t\t\tchar dname_nt[dnamelen + 1];\n\t\t\tmemcpy(dname_nt, dname, dnamelen);\n\t\t\tdname_nt[dnamelen] = '\\0';\n\t\t\t\n\t\t\tBFG_FOREACH_DRIVER_BY_PRIORITY(dreg) {\n\t\t\t\tconst struct device_drv * const drv = dreg->drv;\n\t\t\t\tif (!(drv && drv->lowl_probe && drv_algo_check(drv)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strcasecmp(drv->dname, dname_nt) && strcasecmp(drv->name, dname_nt))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (_probe_device_do_probe(drv, info, &request_rescan))\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// probe driver(s) with auto enabled and matching VID/PID/Product/etc of device\n\tBFG_FOREACH_DRIVER_BY_PRIORITY(dreg)\n\t{\n\t\tconst struct device_drv * const drv = dreg->drv;\n\t\t\n\t\tif (!drv_algo_check(drv))\n\t\t\tcontinue;\n\t\t\n\t\t// Check for \"noauto\" flag\n\t\t// NOTE: driver-specific configuration overrides general\n\t\tbool doauto = true;\n\t\tDL_FOREACH_SAFE(scan_devices, sd_iter, sd_tmp)\n\t\t{\n\t\t\tconst char * const dname = sd_iter->string;\n\t\t\t// NOTE: Only checking flags here, NOT path/serial, so @ is unacceptable\n\t\t\tconst char *colon = strchr(dname, ':');\n\t\t\tif (!colon)\n\t\t\t\tcolon = &dname[-1];\n\t\t\tif (strcasecmp(\"noauto\", &colon[1]) && strcasecmp(\"auto\", &colon[1]))\n\t\t\t\tcontinue;\n\t\t\tconst ssize_t dnamelen = (colon - dname);\n\t\t\tif (dnamelen >= 0) {\n\t\t\t\tchar dname_nt[dnamelen + 1];\n\t\t\t\tmemcpy(dname_nt, dname, dnamelen);\n\t\t\t\tdname_nt[dnamelen] = '\\0';\n\t\t\t\t\n\t\t\t\tif (strcasecmp(drv->dname, dname_nt) && strcasecmp(drv->name, dname_nt))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdoauto = (tolower(colon[1]) == 'a');\n\t\t\tif (dnamelen != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (doauto && drv->lowl_match)\n\t\t{\n\t\t\tLL_FOREACH2(infolist, info, same_devid_next)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t The below call to applog is absolutely necessary\n\t\t\t\t Starting with commit 76d0cc183b1c9ddcc0ef34d2e43bc696ef9de92e installing BFGMiner on\n\t\t\t\t Mac OS X using Homebrew results in a binary that segfaults on startup\n\t\t\t\t There are two unresolved issues:\n\n\t\t\t\t 1) The BFGMiner authors cannot find a way to install BFGMiner with Homebrew that results\n\t\t\t\t    in debug symbols being available to help troubleshoot the issue\n\t\t\t\t 2) The issue disappears when unrelated code changes are made, such as adding the following\n\t\t\t\t    call to applog with infolist and / or p\n\t\t\t\t \n\t\t\t\t We would encourage revisiting this in the future to come up with a more concrete solution\n\t\t\t\t Reproducing should only require commenting / removing the following line and installing\n\t\t\t\t BFGMiner using \"brew install bfgminer --HEAD\"\n\t\t\t\t */\n\t\t\t\tif (dummy_check_never_true)\n\t\t\t\t\tapplog(LOG_DEBUG, \"lowl_match: %p(%s) %p %p %p\", drv, drv->dname, info, infolist, p);\n\t\t\t\t\n\t\t\t\tif (!drv->lowl_match(info))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (_probe_device_do_probe(drv, info, &request_rescan))\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// probe driver(s) with 'all' enabled\n\tDL_FOREACH_SAFE(scan_devices, sd_iter, sd_tmp)\n\t{\n\t\tconst char * const dname = sd_iter->string;\n\t\t// NOTE: Only checking flags here, NOT path/serial, so @ is unacceptable\n\t\tconst char * const colon = strchr(dname, ':');\n\t\tif (!colon)\n\t\t{\n\t\t\tLL_FOREACH2(infolist, info, same_devid_next)\n\t\t\t{\n\t\t\t\tif (\n#ifdef NEED_BFG_LOWL_VCOM\n\t\t\t\t\t(info->lowl == &lowl_vcom && !strcasecmp(dname, \"all\")) ||\n#endif\n\t\t\t\t\t_probe_device_match(info, (dname[0] == '@') ? &dname[1] : dname))\n\t\t\t\t{\n\t\t\t\t\tbool dont_rescan = false;\n\t\t\t\t\tBFG_FOREACH_DRIVER_BY_PRIORITY(dreg)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst struct device_drv * const drv = dreg->drv;\n\t\t\t\t\t\tif (!drv_algo_check(drv))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (drv->lowl_probe_by_name_only)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!drv->lowl_probe)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (_probe_device_do_probe(drv, info, NULL))\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\tif (bfg_probe_result_flags & BPR_DONT_RESCAN)\n\t\t\t\t\t\t\tdont_rescan = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (opt_hotplug && !dont_rescan)\n\t\t\t\t\t\trequest_rescan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcasecmp(&colon[1], \"all\"))\n\t\t\tcontinue;\n\t\tconst size_t dnamelen = (colon - dname);\n\t\tchar dname_nt[dnamelen + 1];\n\t\tmemcpy(dname_nt, dname, dnamelen);\n\t\tdname_nt[dnamelen] = '\\0';\n\n\t\tBFG_FOREACH_DRIVER_BY_PRIORITY(dreg) {\n\t\t\tconst struct device_drv * const drv = dreg->drv;\n\t\t\tif (!(drv && drv->lowl_probe && drv_algo_check(drv)))\n\t\t\t\tcontinue;\n\t\t\tif (strcasecmp(drv->dname, dname_nt) && strcasecmp(drv->name, dname_nt))\n\t\t\t\tcontinue;\n\t\t\tLL_FOREACH2(infolist, info, same_devid_next)\n\t\t\t{\n\t\t\t\tif (info->lowl->exclude_from_all)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (_probe_device_do_probe(drv, info, NULL))\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Only actually request a rescan if we never found any cgpu\n\tif (request_rescan)\n\t\tbfg_need_detect_rescan = true;\n\t\n\treturn NULL;\n}\n\nvoid probe_device(struct lowlevel_device_info * const info)\n{\n\tpthread_create(&info->probe_pth, NULL, probe_device_thread, info);\n}\n#endif\n\nint create_new_cgpus(void (*addfunc)(void*), void *arg)\n{\n\tstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\tint devcount, i, mining_threads_new = 0;\n\tunsigned int k;\n\tstruct cgpu_info *cgpu;\n\tstruct thr_info *thr;\n\tvoid *p;\n\t\n\tmutex_lock(&mutex);\n\tdevcount = total_devices;\n\t\n\taddfunc(arg);\n\t\n\tif (!total_devices_new)\n\t\tgoto out;\n\t\n\twr_lock(&devices_lock);\n\tp = realloc(devices, sizeof(struct cgpu_info *) * (total_devices + total_devices_new + 1));\n\tif (unlikely(!p))\n\t{\n\t\twr_unlock(&devices_lock);\n\t\tapplog(LOG_ERR, \"scan_serial: realloc failed trying to grow devices array\");\n\t\tgoto out;\n\t}\n\tdevices = p;\n\twr_unlock(&devices_lock);\n\t\n\tfor (i = 0; i < total_devices_new; ++i)\n\t{\n\t\tcgpu = devices_new[i];\n\t\tmining_threads_new += cgpu->threads ?: 1;\n\t}\n\t\n\twr_lock(&mining_thr_lock);\n\tmining_threads_new += mining_threads;\n\tp = realloc(mining_thr, sizeof(struct thr_info *) * mining_threads_new);\n\tif (unlikely(!p))\n\t{\n\t\twr_unlock(&mining_thr_lock);\n\t\tapplog(LOG_ERR, \"scan_serial: realloc failed trying to grow mining_thr\");\n\t\tgoto out;\n\t}\n\tmining_thr = p;\n\twr_unlock(&mining_thr_lock);\n\tfor (i = mining_threads; i < mining_threads_new; ++i) {\n\t\tmining_thr[i] = calloc(1, sizeof(*thr));\n\t\tif (!mining_thr[i])\n\t\t{\n\t\t\tapplog(LOG_ERR, \"scan_serial: Failed to calloc mining_thr[%d]\", i);\n\t\t\tfor ( ; --i >= mining_threads; )\n\t\t\t\tfree(mining_thr[i]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t\n\tk = mining_threads;\n\tfor (i = 0; i < total_devices_new; ++i)\n\t{\n\t\tcgpu = devices_new[i];\n\t\t\n\t\tallocate_cgpu(cgpu, &k);\n\t}\n\tfor (i = 0; i < total_devices_new; ++i)\n\t{\n\t\tcgpu = devices_new[i];\n\t\t\n\t\tstart_cgpu(cgpu);\n\t\tregister_device(cgpu);\n\t\t++total_devices;\n\t}\n\t\n#ifdef HAVE_CURSES\n\tswitch_logsize();\n#endif\n\t\nout:\n\ttotal_devices_new = 0;\n\t\n\tdevcount = total_devices - devcount;\n\tmutex_unlock(&mutex);\n\t\n\treturn devcount;\n}\n\nint scan_serial(const char *s)\n{\n\treturn create_new_cgpus(_scan_serial, (void*)s);\n}\n\nstatic pthread_mutex_t rescan_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool rescan_active;\nstatic struct timeval tv_rescan;\nstatic notifier_t rescan_notifier;\n\nstatic\nvoid *rescan_thread(__maybe_unused void *p)\n{\n\tpthread_detach(pthread_self());\n\tRenameThread(\"rescan\");\n\t\n\tstruct timeval tv_timeout, tv_now;\n\tfd_set rfds;\n\t\n\twhile (true)\n\t{\n\t\tmutex_lock(&rescan_mutex);\n\t\ttv_timeout = tv_rescan;\n\t\tif (!timer_isset(&tv_timeout))\n\t\t{\n\t\t\trescan_active = false;\n\t\t\tmutex_unlock(&rescan_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&rescan_mutex);\n\t\t\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(rescan_notifier[0], &rfds);\n\t\tconst int maxfd = rescan_notifier[0];\n\t\t\n\t\ttimer_set_now(&tv_now);\n\t\tif (select(maxfd+1, &rfds, NULL, NULL, select_timeout(&tv_timeout, &tv_now)) > 0)\n\t\t\tnotifier_read(rescan_notifier);\n\t\t\n\t\tmutex_lock(&rescan_mutex);\n\t\tif (timer_passed(&tv_rescan, NULL))\n\t\t{\n\t\t\ttimer_unset(&tv_rescan);\n\t\t\tmutex_unlock(&rescan_mutex);\n\t\t\tapplog(LOG_DEBUG, \"Rescan timer expired, triggering\");\n\t\t\tscan_serial(NULL);\n\t\t}\n\t\telse\n\t\t\tmutex_unlock(&rescan_mutex);\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid _schedule_rescan(const struct timeval * const tvp_when)\n{\n\tif (rescan_active)\n\t{\n\t\tif (timercmp(tvp_when, &tv_rescan, <))\n\t\t\tapplog(LOG_DEBUG, \"schedule_rescan: New schedule is before current, waiting it out\");\n\t\telse\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"schedule_rescan: New schedule is after current, delaying rescan\");\n\t\t\ttv_rescan = *tvp_when;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tapplog(LOG_DEBUG, \"schedule_rescan: Scheduling rescan (no rescans currently pending)\");\n\ttv_rescan = *tvp_when;\n\trescan_active = true;\n\t\n\tstatic pthread_t pth;\n\tif (unlikely(pthread_create(&pth, NULL, rescan_thread, NULL)))\n\t\tapplog(LOG_ERR, \"Failed to start rescan thread\");\n}\n\nstatic\nvoid schedule_rescan(const struct timeval * const tvp_when)\n{\n\tmutex_lock(&rescan_mutex);\n\t_schedule_rescan(tvp_when);\n\tmutex_unlock(&rescan_mutex);\n}\n\nstatic\nvoid hotplug_trigger()\n{\n\tapplog(LOG_DEBUG, \"%s: Scheduling rescan immediately\", __func__);\n\tstruct timeval tv_now;\n\ttimer_set_now(&tv_now);\n\tschedule_rescan(&tv_now);\n}\n\n#if defined(HAVE_LIBUDEV) && defined(HAVE_SYS_EPOLL_H)\n\nstatic\nvoid *hotplug_thread(__maybe_unused void *p)\n{\n\tpthread_detach(pthread_self());\n\tRenameThread(\"hotplug\");\n\t\n\tstruct udev * const udev = udev_new();\n\tif (unlikely(!udev))\n\t\tapplogfailr(NULL, LOG_ERR, \"udev_new\");\n\tstruct udev_monitor * const mon = udev_monitor_new_from_netlink(udev, \"udev\");\n\tif (unlikely(!mon))\n\t\tapplogfailr(NULL, LOG_ERR, \"udev_monitor_new_from_netlink\");\n\tif (unlikely(udev_monitor_enable_receiving(mon)))\n\t\tapplogfailr(NULL, LOG_ERR, \"udev_monitor_enable_receiving\");\n\tconst int epfd = epoll_create(1);\n\tif (unlikely(epfd == -1))\n\t\tapplogfailr(NULL, LOG_ERR, \"epoll_create\");\n\t{\n\t\tconst int fd = udev_monitor_get_fd(mon);\n\t\tstruct epoll_event ev = {\n\t\t\t.events = EPOLLIN | EPOLLPRI,\n\t\t\t.data.fd = fd,\n\t\t};\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev))\n\t\t\tapplogfailr(NULL, LOG_ERR, \"epoll_ctl\");\n\t}\n\t\n\tstruct epoll_event ev;\n\tint rv;\n\tbool pending = false;\n\twhile (true)\n\t{\n\t\trv = epoll_wait(epfd, &ev, 1, pending ? hotplug_delay_ms : -1);\n\t\tif (rv == -1)\n\t\t{\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (!rv)\n\t\t{\n\t\t\thotplug_trigger();\n\t\t\tpending = false;\n\t\t\tcontinue;\n\t\t}\n\t\tstruct udev_device * const device = udev_monitor_receive_device(mon);\n\t\tif (!device)\n\t\t\tcontinue;\n\t\tconst char * const action = udev_device_get_action(device);\n\t\tapplog(LOG_DEBUG, \"%s: Received %s event\", __func__, action);\n\t\tif (!strcmp(action, \"add\"))\n\t\t\tpending = true;\n\t\tudev_device_unref(device);\n\t}\n\t\n\tapplogfailr(NULL, LOG_ERR, \"epoll_wait\");\n}\n\n#elif defined(WIN32)\n\nstatic UINT_PTR _hotplug_wintimer_id;\n\nVOID CALLBACK hotplug_win_timer(HWND hwnd, UINT msg, UINT_PTR idEvent, DWORD dwTime)\n{\n\tKillTimer(NULL, _hotplug_wintimer_id);\n\t_hotplug_wintimer_id = 0;\n\thotplug_trigger();\n}\n\nLRESULT CALLBACK hotplug_win_callback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tif (msg == WM_DEVICECHANGE && wParam == DBT_DEVNODES_CHANGED)\n\t{\n\t\tapplog(LOG_DEBUG, \"%s: Received DBT_DEVNODES_CHANGED event\", __func__);\n\t\t_hotplug_wintimer_id = SetTimer(NULL, _hotplug_wintimer_id, hotplug_delay_ms, hotplug_win_timer);\n\t}\n\treturn DefWindowProc(hwnd, msg, wParam, lParam);\n}\n\nstatic\nvoid *hotplug_thread(__maybe_unused void *p)\n{\n\tpthread_detach(pthread_self());\n\t\n\tWNDCLASS DummyWinCls = {\n\t\t.lpszClassName = \"BFGDummyWinCls\",\n\t\t.lpfnWndProc = hotplug_win_callback,\n\t};\n\tATOM a = RegisterClass(&DummyWinCls);\n\tif (unlikely(!a))\n\t\tapplogfailinfor(NULL, LOG_ERR, \"RegisterClass\", \"%d\", (int)GetLastError());\n\tHWND hwnd = CreateWindow((void*)(intptr_t)a, NULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);\n\tif (unlikely(!hwnd))\n\t\tapplogfailinfor(NULL, LOG_ERR, \"CreateWindow\", \"%d\", (int)GetLastError());\n\tMSG msg;\n\twhile (GetMessage(&msg, NULL, 0, 0))\n\t{\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\t}\n\tquit(0, \"WM_QUIT received\");\n\treturn NULL;\n}\n\n#endif\n\n#ifdef HAVE_BFG_HOTPLUG\nstatic\nvoid hotplug_start()\n{\n\tpthread_t pth;\n\tif (unlikely(pthread_create(&pth, NULL, hotplug_thread, NULL)))\n\t\tapplog(LOG_ERR, \"Failed to start hotplug thread\");\n}\n#endif\n\nstatic void probe_pools(void)\n{\n\tint i;\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\n\t\tpool->testing = true;\n\t\tpthread_create(&pool->test_thread, NULL, test_pool_thread, (void *)pool);\n\t}\n}\n\nstatic void raise_fd_limits(void)\n{\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit fdlimit;\n\trlim_t old_soft_limit;\n\tchar frombuf[MAX_STR_UINT(unsigned long)] = \"unlimited\";\n\tchar hardbuf[MAX_STR_UINT(unsigned long)] = \"unlimited\";\n\t\n\tif (getrlimit(RLIMIT_NOFILE, &fdlimit))\n\t\tapplogr(, LOG_DEBUG, \"setrlimit: Failed to getrlimit(RLIMIT_NOFILE)\");\n\t\n\told_soft_limit = fdlimit.rlim_cur;\n\t\n\tif (fdlimit.rlim_max > FD_SETSIZE || fdlimit.rlim_max == RLIM_INFINITY)\n\t\tfdlimit.rlim_cur = FD_SETSIZE;\n\telse\n\t\tfdlimit.rlim_cur = fdlimit.rlim_max;\n\t\n\tif (fdlimit.rlim_max != RLIM_INFINITY)\n\t\tsnprintf(hardbuf, sizeof(hardbuf), \"%lu\", (unsigned long)fdlimit.rlim_max);\n\tif (old_soft_limit != RLIM_INFINITY)\n\t\tsnprintf(frombuf, sizeof(frombuf), \"%lu\", (unsigned long)old_soft_limit);\n\t\n\tif (fdlimit.rlim_cur == old_soft_limit)\n\t\tapplogr(, LOG_DEBUG, \"setrlimit: Soft fd limit not being changed from %lu (FD_SETSIZE=%lu; hard limit=%s)\",\n\t\t        (unsigned long)old_soft_limit, (unsigned long)FD_SETSIZE, hardbuf);\n\t\n\tif (setrlimit(RLIMIT_NOFILE, &fdlimit))\n\t\tapplogr(, LOG_DEBUG, \"setrlimit: Failed to change soft fd limit from %s to %lu (FD_SETSIZE=%lu; hard limit=%s)\",\n\t\t        frombuf, (unsigned long)fdlimit.rlim_cur, (unsigned long)FD_SETSIZE, hardbuf);\n\t\n\tapplog(LOG_DEBUG, \"setrlimit: Changed soft fd limit from %s to %lu (FD_SETSIZE=%lu; hard limit=%s)\",\n\t       frombuf, (unsigned long)fdlimit.rlim_cur, (unsigned long)FD_SETSIZE, hardbuf);\n#else\n\tapplog(LOG_DEBUG, \"setrlimit: Not supported by platform\");\n#endif\n}\n\nstatic\nvoid bfg_atexit(void)\n{\n\tputs(\"\");\n}\n\nextern void bfg_init_threadlocal();\nextern bool stratumsrv_change_port(unsigned);\nextern void test_aan_pll(void);\n\nint main(int argc, char *argv[])\n{\n\tstruct sigaction handler;\n\tstruct thr_info *thr;\n\tunsigned int k;\n\tint i;\n\tint rearrange_pools = 0;\n\tchar *s;\n\n#ifdef WIN32\n\tLoadLibrary(\"backtrace.dll\");\n#endif\n\t\n\tatexit(bfg_atexit);\n\n\tb58_sha256_impl = my_blkmaker_sha256_callback;\n\tblkmk_sha256_impl = my_blkmaker_sha256_callback;\n\n\tbfg_init_threadlocal();\n#ifndef HAVE_PTHREAD_CANCEL\n\tsetup_pthread_cancel_workaround();\n#endif\n\tbfg_init_checksums();\n\n#ifdef WIN32\n\t{\n\t\tWSADATA wsa;\n\t\ti = WSAStartup(MAKEWORD(2, 2), &wsa);\n\t\tif (i)\n\t\t\tquit(1, \"Failed to initialise Winsock: %s\", bfg_strerror(i, BST_SOCKET));\n\t}\n#endif\n\t\n\t/* This dangerous functions tramples random dynamically allocated\n\t * variables so do it before anything at all */\n\tif (unlikely(curl_global_init(CURL_GLOBAL_ALL)))\n\t\tquit(1, \"Failed to curl_global_init\");\n\n\tinitial_args = malloc(sizeof(char *) * (argc + 1));\n\tfor  (i = 0; i < argc; i++)\n\t\tinitial_args[i] = strdup(argv[i]);\n\tinitial_args[argc] = NULL;\n\n\tmutex_init(&hash_lock);\n\tmutex_init(&console_lock);\n\tcglock_init(&control_lock);\n\tmutex_init(&stats_lock);\n\tmutex_init(&sharelog_lock);\n\tcglock_init(&ch_lock);\n\tmutex_init(&sshare_lock);\n\trwlock_init(&blk_lock);\n\trwlock_init(&netacc_lock);\n\trwlock_init(&mining_thr_lock);\n\trwlock_init(&devices_lock);\n\n\tmutex_init(&lp_lock);\n\tif (unlikely(pthread_cond_init(&lp_cond, bfg_condattr)))\n\t\tquit(1, \"Failed to pthread_cond_init lp_cond\");\n\n\tif (unlikely(pthread_cond_init(&gws_cond, bfg_condattr)))\n\t\tquit(1, \"Failed to pthread_cond_init gws_cond\");\n\n\tnotifier_init(submit_waiting_notifier);\n\ttimer_unset(&tv_rescan);\n\tnotifier_init(rescan_notifier);\n\n\t/* Create a unique get work queue */\n\tgetq = tq_new();\n\tif (!getq)\n\t\tquit(1, \"Failed to create getq\");\n\t/* We use the getq mutex as the staged lock */\n\tstgd_lock = &getq->mutex;\n\n#if defined(USE_CPUMINING) && defined(USE_SHA256D)\n\tinit_max_name_len();\n#endif\n\n\thandler.sa_handler = &sighandler;\n\thandler.sa_flags = 0;\n\tsigemptyset(&handler.sa_mask);\n#ifdef HAVE_PTHREAD_CANCEL\n\tsigaction(SIGTERM, &handler, &termhandler);\n#else\n\t// Need to let pthread_cancel emulation handle SIGTERM first\n\ttermhandler = pcwm_orig_term_handler;\n\tpcwm_orig_term_handler = handler;\n#endif\n\tsigaction(SIGINT, &handler, &inthandler);\n#ifndef WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#else\n\ttimeBeginPeriod(1);\n#endif\n\topt_kernel_path = CGMINER_PREFIX;\n\tcgminer_path = alloca(PATH_MAX);\n\ts = strdup(argv[0]);\n\tstrcpy(cgminer_path, dirname(s));\n\tfree(s);\n\tstrcat(cgminer_path, \"/\");\n#if defined(USE_CPUMINING) && defined(WIN32)\n\t{\n\t\tchar buf[32];\n\t\tint gev = GetEnvironmentVariable(\"BFGMINER_BENCH_ALGO\", buf, sizeof(buf));\n\t\tif (gev > 0 && gev < sizeof(buf))\n\t\t{\n\t\t\tsetup_benchmark_pool();\n\t\t\tdouble rate = bench_algo_stage3(atoi(buf));\n\t\t\t\n\t\t\t// Write result to shared memory for parent\n\t\t\tchar unique_name[64];\n\t\t\t\n\t\t\tif (GetEnvironmentVariable(\"BFGMINER_SHARED_MEM\", unique_name, 32))\n\t\t\t{\n\t\t\t\tHANDLE map_handle = CreateFileMapping(\n\t\t\t\t\tINVALID_HANDLE_VALUE,   // use paging file\n\t\t\t\t\tNULL,                   // default security attributes\n\t\t\t\t\tPAGE_READWRITE,         // read/write access\n\t\t\t\t\t0,                      // size: high 32-bits\n\t\t\t\t\t4096,                   // size: low 32-bits\n\t\t\t\t\tunique_name             // name of map object\n\t\t\t\t);\n\t\t\t\tif (NULL != map_handle) {\n\t\t\t\t\tvoid *shared_mem = MapViewOfFile(\n\t\t\t\t\t\tmap_handle,     // object to map view of\n\t\t\t\t\t\tFILE_MAP_WRITE, // read/write access\n\t\t\t\t\t\t0,              // high offset:  map from\n\t\t\t\t\t\t0,              // low offset:   beginning\n\t\t\t\t\t\t0               // default: map entire file\n\t\t\t\t\t);\n\t\t\t\t\tif (NULL != shared_mem)\n\t\t\t\t\t\tCopyMemory(shared_mem, &rate, sizeof(rate));\n\t\t\t\t\t(void)UnmapViewOfFile(shared_mem);\n\t\t\t\t}\n\t\t\t\t(void)CloseHandle(map_handle);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\t}\n#endif\n\n#ifdef HAVE_CURSES\n\tdevcursor = 8;\n\tlogstart = devcursor;\n\tlogcursor = logstart;\n#endif\n\n\tmutex_init(&submitting_lock);\n\n\t// Ensure at least the default goal is created\n\tget_mining_goal(\"default\");\n#ifdef USE_OPENCL\n\topencl_early_init();\n#endif\n\n\tschedstart.tm.tm_sec = 1;\n\tschedstop .tm.tm_sec = 1;\n\n\topt_register_table(opt_early_table, NULL);\n\topt_register_table(opt_config_table, NULL);\n\topt_register_table(opt_cmdline_table, NULL);\n\topt_early_parse(argc, argv, applog_and_exit);\n\t\n\tif (!config_loaded)\n\t{\n\t\tload_default_config();\n\t\trearrange_pools = total_pools;\n\t}\n\t\n\topt_free_table();\n\t\n\t/* parse command line */\n\topt_register_table(opt_config_table,\n\t\t\t   \"Options for both config file and command line\");\n\topt_register_table(opt_cmdline_table,\n\t\t\t   \"Options for command line only\");\n\n\topt_parse(&argc, argv, applog_and_exit);\n\tif (argc != 1)\n\t\tquit(1, \"Unexpected extra commandline arguments\");\n\t\n\tif (rearrange_pools && rearrange_pools < total_pools)\n\t{\n\t\t// Prioritise commandline pools before default-config pools\n\t\tfor (i = 0; i < rearrange_pools; ++i)\n\t\t\tpools[i]->prio += rearrange_pools;\n\t\tfor ( ; i < total_pools; ++i)\n\t\t\tpools[i]->prio -= rearrange_pools;\n\t}\n\n#ifndef HAVE_PTHREAD_CANCEL\n\t// Can't do this any earlier, or config isn't loaded\n\tapplog(LOG_DEBUG, \"pthread_cancel workaround in use\");\n#endif\n\n#ifdef HAVE_PWD_H\n\tstruct passwd *user_info = NULL;\n\tif (opt_setuid != NULL) {\n\t\tif ((user_info = getpwnam(opt_setuid)) == NULL) {\n\t\t\tquit(1, \"Unable to find setuid user information\");\n\t\t}\n\t}\n#endif\n\n#ifdef HAVE_CHROOT\n        if (chroot_dir != NULL) {\n#ifdef HAVE_PWD_H\n                if (user_info == NULL && getuid() == 0) {\n                        applog(LOG_WARNING, \"Running as root inside chroot\");\n                }\n#endif\n                if (chroot(chroot_dir) != 0) {\n                       quit(1, \"Unable to chroot\");\n                }\n\t\tif (chdir(\"/\"))\n\t\t\tquit(1, \"Unable to chdir to chroot\");\n        }\n#endif\n\n#ifdef HAVE_PWD_H\n\t\tif (user_info != NULL) {\n\t\t\tif (setgid((*user_info).pw_gid) != 0)\n\t\t\t\tquit(1, \"Unable to setgid\");\n\t\t\tif (setuid((*user_info).pw_uid) != 0)\n\t\t\t\tquit(1, \"Unable to setuid\");\n\t\t}\n#endif\n\traise_fd_limits();\n\t\n\tif (opt_benchmark) {\n\t\twhile (total_pools)\n\t\t\tremove_pool(pools[0]);\n\n\t\tsetup_benchmark_pool();\n\t}\n\t\n\tif (opt_unittest) {\n\t\ttest_cgpu_match();\n\t\ttest_intrange();\n\t\ttest_decimal_width();\n\t\ttest_domain_funcs();\n#ifdef USE_SCRYPT\n\t\ttest_scrypt();\n#endif\n\t\ttest_target();\n\t\ttest_uri_get_param();\n\t\tutf8_test();\n#ifdef USE_JINGTIAN\n\t\ttest_aan_pll();\n#endif\n\t\tif (unittest_failures)\n\t\t\tquit(1, \"Unit tests failed\");\n\t}\n\n#ifdef HAVE_CURSES\n\tif (opt_realquiet || opt_display_devs)\n\t\tuse_curses = false;\n\n\tsetlocale(LC_ALL, \"C\");\n\tif (use_curses)\n\t\tenable_curses();\n#endif\n\n#ifdef HAVE_LIBUSB\n\tint err = libusb_init(NULL);\n\tif (err)\n\t\tapplog(LOG_WARNING, \"libusb_init() failed err %d\", err);\n\telse\n\t\thave_libusb = true;\n#endif\n\n\tapplog(LOG_WARNING, \"Started %s\", packagename);\n\t{\n\t\tstruct bfg_loaded_configfile *configfile;\n\t\tLL_FOREACH(bfg_loaded_configfiles, configfile)\n\t\t{\n\t\t\tchar * const cnfbuf = configfile->filename;\n\t\t\tint fileconf_load = configfile->fileconf_load;\n\t\t\tapplog(LOG_NOTICE, \"Loaded configuration file %s\", cnfbuf);\n\t\t\tswitch (fileconf_load) {\n\t\t\t\tcase 0:\n\t\t\t\t\tapplog(LOG_WARNING, \"Fatal JSON error in configuration file.\");\n\t\t\t\t\tapplog(LOG_WARNING, \"Configuration file could not be used.\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase -1:\n\t\t\t\t\tapplog(LOG_WARNING, \"Error in configuration file, partially loaded.\");\n\t\t\t\t\tif (use_curses)\n\t\t\t\t\t\tapplog(LOG_WARNING, \"Start BFGMiner with -T to see what failed to load.\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = strlen(opt_kernel_path) + 2;\n\tchar __kernel_path[i];\n\tsnprintf(__kernel_path, i, \"%s/\", opt_kernel_path);\n\topt_kernel_path = __kernel_path;\n\n\tif (want_per_device_stats)\n\t\topt_log_output = true;\n\n\tbfg_devapi_init();\n\tdrv_detect_all();\n\ttotal_devices = total_devices_new;\n\tdevices = devices_new;\n\ttotal_devices_new = 0;\n\tdevices_new = NULL;\n\n\tif (opt_display_devs) {\n\t\tint devcount = 0;\n\t\tapplog(LOG_ERR, \"Devices detected:\");\n\t\tfor (i = 0; i < total_devices; ++i) {\n\t\t\tstruct cgpu_info *cgpu = devices[i];\n\t\t\tchar buf[0x100];\n\t\t\tif (cgpu->device != cgpu)\n\t\t\t\tcontinue;\n\t\t\tif (cgpu->name)\n\t\t\t\tsnprintf(buf, sizeof(buf), \" %s\", cgpu->name);\n\t\t\telse\n\t\t\tif (cgpu->dev_manufacturer)\n\t\t\t\tsnprintf(buf, sizeof(buf), \" %s by %s\", (cgpu->dev_product ?: \"Device\"), cgpu->dev_manufacturer);\n\t\t\telse\n\t\t\tif (cgpu->dev_product)\n\t\t\t\tsnprintf(buf, sizeof(buf), \" %s\", cgpu->dev_product);\n\t\t\telse\n\t\t\t\tstrcpy(buf, \" Device\");\n\t\t\ttailsprintf(buf, sizeof(buf), \" (driver=%s; procs=%d\", cgpu->drv->dname, cgpu->procs);\n\t\t\tif (cgpu->dev_serial)\n\t\t\t\ttailsprintf(buf, sizeof(buf), \"; serial=%s\", cgpu->dev_serial);\n\t\t\tif (cgpu->device_path)\n\t\t\t\ttailsprintf(buf, sizeof(buf), \"; path=%s\", cgpu->device_path);\n\t\t\ttailsprintf(buf, sizeof(buf), \")\");\n\t\t\t_applog(LOG_NOTICE, buf);\n\t\t\t++devcount;\n\t\t}\n\t\tquit(0, \"%d devices listed\", devcount);\n\t}\n\n\tmining_threads = 0;\n\tfor (i = 0; i < total_devices; ++i)\n\t\tregister_device(devices[i]);\n\n\tif (!total_devices) {\n\t\tapplog(LOG_WARNING, \"No devices detected!\");\n\t\tif (use_curses)\n\t\t\tapplog(LOG_WARNING, \"Waiting for devices; press 'M+' to add, or 'Q' to quit\");\n\t\telse\n\t\t\tapplog(LOG_WARNING, \"Waiting for devices\");\n\t}\n\t\n#ifdef HAVE_CURSES\n\tswitch_logsize();\n#endif\n\n#if BLKMAKER_VERSION > 1 && defined(USE_SHA256D)\n\tif (opt_load_bitcoin_conf && !(get_mining_goal(\"default\")->malgo->algo != POW_SHA256D || opt_benchmark))\n\t\tadd_local_gbt(total_pools);\n#endif\n\t\n\tif (!total_pools) {\n\t\tapplog(LOG_WARNING, \"Need to specify at least one pool server.\");\n#ifdef HAVE_CURSES\n\t\tif (!use_curses || !input_pool(false))\n#endif\n\t\t\tquit(1, \"Pool setup failed\");\n\t}\n\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool = pools[i];\n\t\tsize_t siz;\n\n\t\tif (!pool->rpc_url)\n\t\t\tquit(1, \"No URI supplied for pool %u\", i);\n\t\t\n\t\tif (!pool->rpc_userpass) {\n\t\t\tif (!pool->rpc_user || !pool->rpc_pass)\n\t\t\t\tquit(1, \"No login credentials supplied for pool %u %s\", i, pool->rpc_url);\n\t\t\tsiz = strlen(pool->rpc_user) + strlen(pool->rpc_pass) + 2;\n\t\t\tpool->rpc_userpass = malloc(siz);\n\t\t\tif (!pool->rpc_userpass)\n\t\t\t\tquit(1, \"Failed to malloc userpass\");\n\t\t\tsnprintf(pool->rpc_userpass, siz, \"%s:%s\", pool->rpc_user, pool->rpc_pass);\n\t\t}\n\t}\n\t/* Set the currentpool to pool with priority 0 */\n\tvalidate_pool_priorities();\n\tfor (i = 0; i < total_pools; i++) {\n\t\tstruct pool *pool  = pools[i];\n\n\t\tif (!pool->prio)\n\t\t\tcurrentpool = pool;\n\t}\n\n#ifdef HAVE_SYSLOG_H\n\tif (use_syslog)\n\t\topenlog(PACKAGE, LOG_PID, LOG_USER);\n#endif\n\n\t#if defined(unix) || defined(__APPLE__)\n\t\tif (opt_stderr_cmd)\n\t\t\tfork_monitor();\n\t#endif // defined(unix)\n\n\tmining_thr = calloc(mining_threads, sizeof(thr));\n\tif (!mining_thr)\n\t\tquit(1, \"Failed to calloc mining_thr\");\n\tfor (i = 0; i < mining_threads; i++) {\n\t\tmining_thr[i] = calloc(1, sizeof(*thr));\n\t\tif (!mining_thr[i])\n\t\t\tquit(1, \"Failed to calloc mining_thr[%d]\", i);\n\t}\n\n\ttotal_control_threads = 6;\n\tcontrol_thr = calloc(total_control_threads, sizeof(*thr));\n\tif (!control_thr)\n\t\tquit(1, \"Failed to calloc control_thr\");\n\n\tif (opt_benchmark)\n\t\tgoto begin_bench;\n\n\tapplog(LOG_NOTICE, \"Probing for an alive pool\");\n\tdo {\n\t\tbool still_testing;\n\t\tint i;\n\n\t\t/* Look for at least one active pool before starting */\n\t\tprobe_pools();\n\t\tdo {\n\t\t\tsleep(1);\n\t\t\tif (pools_active)\n\t\t\t\tbreak;\n\t\t\tstill_testing = false;\n\t\t\tfor (int i = 0; i < total_pools; ++i)\n\t\t\t\tif (pools[i]->testing)\n\t\t\t\t\tstill_testing = true;\n\t\t} while (still_testing);\n\n\t\tif (!pools_active) {\n\t\t\tapplog(LOG_ERR, \"No servers were found that could be used to get work from.\");\n\t\t\tapplog(LOG_ERR, \"Please check the details from the list below of the servers you have input\");\n\t\t\tapplog(LOG_ERR, \"Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers\");\n\t\t\tfor (i = 0; i < total_pools; i++) {\n\t\t\t\tstruct pool *pool;\n\n\t\t\t\tpool = pools[i];\n\t\t\t\tapplog(LOG_WARNING, \"Pool: %d  URL: %s  User: %s  Password: %s\",\n\t\t\t\t       i, pool->rpc_url, pool->rpc_user, pool->rpc_pass);\n\t\t\t}\n#ifdef HAVE_CURSES\n\t\t\tif (use_curses) {\n\t\t\t\thalfdelay(150);\n\t\t\t\tapplog(LOG_ERR, \"Press any key to exit, or BFGMiner will try again in 15s.\");\n\t\t\t\tif (getch() != ERR)\n\t\t\t\t\tquit(0, \"No servers could be used! Exiting.\");\n\t\t\t\tcbreak();\n\t\t\t} else\n#endif\n\t\t\t\tquit(0, \"No servers could be used! Exiting.\");\n\t\t}\n\t} while (!pools_active);\n\n#ifdef USE_SCRYPT\n\tif (detect_algo == 1 && get_mining_goal(\"default\")->malgo->algo != POW_SCRYPT) {\n\t\tapplog(LOG_NOTICE, \"Detected scrypt algorithm\");\n\t\tset_malgo_scrypt();\n\t}\n#endif\n\tdetect_algo = 0;\n\nbegin_bench:\n\ttotal_mhashes_done = 0;\n\tfor (i = 0; i < total_devices; i++) {\n\t\tstruct cgpu_info *cgpu = devices[i];\n\n\t\tcgpu->rolling = cgpu->total_mhashes = 0;\n\t}\n\t\n\tcgtime(&total_tv_start);\n\tcgtime(&total_tv_end);\n\tminer_started = total_tv_start;\n\ttime_t miner_start_ts = time(NULL);\n\tif (schedstart.tm.tm_sec)\n\t\tlocaltime_r(&miner_start_ts, &schedstart.tm);\n\tif (schedstop.tm.tm_sec)\n\t\tlocaltime_r(&miner_start_ts, &schedstop .tm);\n\tget_datestamp(datestamp, sizeof(datestamp), miner_start_ts);\n\n\t// Initialise processors and threads\n\tk = 0;\n\tfor (i = 0; i < total_devices; ++i) {\n\t\tstruct cgpu_info *cgpu = devices[i];\n\t\tallocate_cgpu(cgpu, &k);\n\t}\n\n\t// Start threads\n\tfor (i = 0; i < total_devices; ++i) {\n\t\tstruct cgpu_info *cgpu = devices[i];\n\t\tstart_cgpu(cgpu);\n\t}\n\n#ifdef USE_OPENCL\n\tfor (i = 0; i < nDevs; i++)\n\t\tpause_dynamic_threads(i);\n#endif\n\n#if defined(USE_CPUMINING) && defined(USE_SHA256D)\n\tif (opt_n_threads > 0)\n\t\tapplog(LOG_INFO, \"%d cpu miner threads started, using '%s' algorithm.\",\n\t\t       opt_n_threads, algo_names[opt_algo]);\n#endif\n\n\tcgtime(&total_tv_start);\n\tcgtime(&total_tv_end);\n\n\tif (!opt_benchmark)\n\t{\n\t\tpthread_t submit_thread;\n\t\tif (unlikely(pthread_create(&submit_thread, NULL, submit_work_thread, NULL)))\n\t\t\tquit(1, \"submit_work thread create failed\");\n\t}\n\n\twatchpool_thr_id = 1;\n\tthr = &control_thr[watchpool_thr_id];\n\t/* start watchpool thread */\n\tif (thr_info_create(thr, NULL, watchpool_thread, NULL))\n\t\tquit(1, \"watchpool thread create failed\");\n\tpthread_detach(thr->pth);\n\n\twatchdog_thr_id = 2;\n\tthr = &control_thr[watchdog_thr_id];\n\t/* start watchdog thread */\n\tif (thr_info_create(thr, NULL, watchdog_thread, NULL))\n\t\tquit(1, \"watchdog thread create failed\");\n\tpthread_detach(thr->pth);\n\n#ifdef USE_OPENCL\n\t/* Create reinit gpu thread */\n\tgpur_thr_id = 3;\n\tthr = &control_thr[gpur_thr_id];\n\tthr->q = tq_new();\n\tif (!thr->q)\n\t\tquit(1, \"tq_new failed for gpur_thr_id\");\n\tif (thr_info_create(thr, NULL, reinit_gpu, thr))\n\t\tquit(1, \"reinit_gpu thread create failed\");\n#endif\t\n\n\t/* Create API socket thread */\n\tapi_thr_id = 4;\n\tthr = &control_thr[api_thr_id];\n\tif (thr_info_create(thr, NULL, api_thread, thr))\n\t\tquit(1, \"API thread create failed\");\n\t\n#ifdef USE_LIBMICROHTTPD\n\tif (httpsrv_port != -1)\n\t\thttpsrv_start(httpsrv_port);\n#endif\n\n#ifdef USE_LIBEVENT\n\tif (stratumsrv_port != -1)\n\t\tstratumsrv_change_port(stratumsrv_port);\n#endif\n\n#ifdef HAVE_BFG_HOTPLUG\n\tif (opt_hotplug)\n\t\thotplug_start();\n#endif\n\n#ifdef HAVE_CURSES\n\t/* Create curses input thread for keyboard input. Create this last so\n\t * that we know all threads are created since this can call kill_work\n\t * to try and shut down ll previous threads. */\n\tinput_thr_id = 5;\n\tthr = &control_thr[input_thr_id];\n\tif (thr_info_create(thr, NULL, input_thread, thr))\n\t\tquit(1, \"input thread create failed\");\n\tpthread_detach(thr->pth);\n#endif\n\n\t/* Just to be sure */\n\tif (total_control_threads != 6)\n\t\tquit(1, \"incorrect total_control_threads (%d) should be 7\", total_control_threads);\n\n\t/* Once everything is set up, main() becomes the getwork scheduler */\n\twhile (42) {\n\t\tint ts, max_staged = opt_queue;\n\t\tstruct pool *pool, *cp;\n\t\tbool lagging = false;\n\t\tstruct curl_ent *ce;\n\t\tstruct work *work;\n\t\tstruct mining_algorithm *malgo = NULL;\n\n\t\tcp = current_pool();\n\n\t\t// Generally, each processor needs a new work, and all at once during work restarts\n\t\tmax_staged += base_queue;\n\n\t\tmutex_lock(stgd_lock);\n\t\tts = __total_staged(false);\n\n\t\tif (!pool_localgen(cp) && !ts && !opt_fail_only)\n\t\t\tlagging = true;\n\n\t\t/* Wait until hash_pop tells us we need to create more work */\n\t\tif (ts > max_staged) {\n\t\t\t{\n\t\t\t\tLL_FOREACH(mining_algorithms, malgo)\n\t\t\t\t{\n\t\t\t\t\tif (!malgo->goal_refs)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!malgo->base_queue)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (malgo->staged < malgo->base_queue + opt_queue)\n\t\t\t\t\t{\n\t\t\t\t\t\tmutex_unlock(stgd_lock);\n\t\t\t\t\t\tpool = select_pool(lagging, malgo);\n\t\t\t\t\t\tif (pool)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twork = make_work();\n\t\t\t\t\t\t\twork->spare = true;\n\t\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmutex_lock(stgd_lock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmalgo = NULL;\n\t\t\t}\n\t\t\tstaged_full = true;\n\t\t\tpthread_cond_wait(&gws_cond, stgd_lock);\n\t\t\tts = __total_staged(false);\n\t\t}\n\t\tmutex_unlock(stgd_lock);\n\n\t\tif (ts > max_staged)\n\t\t\tcontinue;\n\n\t\twork = make_work();\n\n\t\tif (lagging && !pool_tset(cp, &cp->lagging)) {\n\t\t\tapplog(LOG_WARNING, \"Pool %d not providing work fast enough\", cp->pool_no);\n\t\t\tcp->getfail_occasions++;\n\t\t\ttotal_go++;\n\t\t}\n\t\tpool = select_pool(lagging, malgo);\n\nretry:\n\t\tif (pool->has_stratum) {\n\t\t\twhile (!pool->stratum_active || !pool->stratum_notify) {\n\t\t\t\tstruct pool *altpool = select_pool(true, malgo);\n\n\t\t\t\tif (altpool == pool && pool->has_stratum)\n\t\t\t\t\tcgsleep_ms(5000);\n\t\t\t\tpool = altpool;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgen_stratum_work(pool, work);\n\t\t\tapplog(LOG_DEBUG, \"Generated stratum work\");\n\t\t\tstage_work(work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pool->last_work_copy) {\n\t\t\tmutex_lock(&pool->last_work_lock);\n\t\t\tstruct work *last_work = pool->last_work_copy;\n\t\t\tif (!last_work)\n\t\t\t\t{}\n\t\t\telse\n\t\t\tif (can_roll(last_work) && should_roll(last_work)) {\n\t\t\t\tstruct timeval tv_now;\n\t\t\t\tcgtime(&tv_now);\n\t\t\t\tfree_work(work);\n\t\t\t\twork = make_clone(pool->last_work_copy);\n\t\t\t\tmutex_unlock(&pool->last_work_lock);\n\t\t\t\troll_work(work);\n\t\t\t\tapplog(LOG_DEBUG, \"Generated work from latest GBT job in get_work_thread with %d seconds left\", (int)blkmk_time_left(work->tr->tmpl, tv_now.tv_sec));\n\t\t\t\tstage_work(work);\n\t\t\t\tcontinue;\n\t\t\t} else if (last_work->tr && pool->proto == PLP_GETBLOCKTEMPLATE && blkmk_work_left(last_work->tr->tmpl) > (unsigned long)mining_threads) {\n\t\t\t\t// Don't free last_work_copy, since it is used to detect upstream provides plenty of work per template\n\t\t\t} else {\n\t\t\t\tfree_work(last_work);\n\t\t\t\tpool->last_work_copy = NULL;\n\t\t\t}\n\t\t\tmutex_unlock(&pool->last_work_lock);\n\t\t}\n\n\t\tif (clone_available()) {\n\t\t\tapplog(LOG_DEBUG, \"Cloned getwork work\");\n\t\t\tfree_work(work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (opt_benchmark) {\n\t\t\tget_benchmark_work(work, opt_benchmark_intense);\n\t\t\tapplog(LOG_DEBUG, \"Generated benchmark work\");\n\t\t\tstage_work(work);\n\t\t\tcontinue;\n\t\t}\n\n\t\twork->pool = pool;\n\t\tce = pop_curl_entry3(pool, 2);\n\t\t/* obtain new work from bitcoin via JSON-RPC */\n\t\tif (!get_upstream_work(work, ce->curl)) {\n\t\t\tstruct pool *next_pool;\n\n\t\t\t/* Make sure the pool just hasn't stopped serving\n\t\t\t * requests but is up as we'll keep hammering it */\n\t\t\tpush_curl_entry(ce, pool);\n\t\t\t++pool->seq_getfails;\n\t\t\tpool_died(pool);\n\t\t\tnext_pool = select_pool(!opt_fail_only, malgo);\n\t\t\tif (pool == next_pool) {\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %d json_rpc_call failed on get work, retrying in 5s\", pool->pool_no);\n\t\t\t\tcgsleep_ms(5000);\n\t\t\t} else {\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %d json_rpc_call failed on get work, failover activated\", pool->pool_no);\n\t\t\t\tpool = next_pool;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ts >= max_staged)\n\t\t\tpool_tclear(pool, &pool->lagging);\n\t\tif (pool_tclear(pool, &pool->idle))\n\t\t\tpool_resus(pool);\n\n\t\tapplog(LOG_DEBUG, \"Generated getwork work\");\n\t\tstage_work(work);\n\t\tpush_curl_entry(ce, pool);\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "miner.h",
          "type": "blob",
          "size": 45.359375,
          "content": "/*\n * Copyright 2012-2014 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2012-2013 Andrew Smith\n * Copyright 2011 Glenn Francis Murray\n * Copyright 2010-2011 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_MINER_H\n#define BFG_MINER_H\n\n#include \"config.h\"\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#include <float.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <jansson.h>\n#include <curl/curl.h>\n#include <sched.h>\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n#include <blkmaker.h>\n#include <blktemplate.h>\n\n#if defined(WORDS_BIGENDIAN) && !defined(__BIG_ENDIAN__)\n/* uthash.h depends on __BIG_ENDIAN__ on BE platforms */\n#define __BIG_ENDIAN__ 1\n#endif\n\n#include <uthash.h>\n#include <utlist.h>\n\n#include \"logging.h\"\n#include \"util.h\"\n\nextern const char * const bfgminer_name_space_ver;\nextern const char * const bfgminer_name_slash_ver;\nextern const char * const bfgminer_ver;\n\n#ifdef STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#else\n# ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif\n#ifdef HAVE_ALLOCA_H\n# include <alloca.h>\n#elif !defined alloca\n# ifdef __GNUC__\n#  define alloca __builtin_alloca\n# elif defined _AIX\n#  define alloca __alloca\n# elif defined _MSC_VER\n#  include <malloc.h>\n#  define alloca _alloca\n# elif !defined HAVE_ALLOCA\n#  ifdef  __cplusplus\nextern \"C\"\n#  endif\nvoid *alloca (size_t);\n# endif\n#endif\n\n#ifdef __MINGW32__\n#include <windows.h>\n#include <io.h>\nstatic inline int fsync (int fd)\n{\n\treturn (FlushFileBuffers ((HANDLE) _get_osfhandle (fd))) ? 0 : -1;\n}\n\n#ifndef EWOULDBLOCK\n# define EWOULDBLOCK EAGAIN\n#endif\n\n#ifndef MSG_DONTWAIT\n# define MSG_DONTWAIT 0x1000000\n#endif\n#endif /* __MINGW32__ */\n\n#if defined (__linux)\n #ifndef LINUX\n  #define LINUX\n #endif\n#endif\n\n\n#ifdef HAVE_ADL\n #include \"ADL/adl_sdk.h\"\n#endif\n\n#ifdef HAVE_LIBUSB\n  #include <libusb.h>\n#endif\n\n#ifdef USE_ZTEX\n  #include \"libztex.h\"\n#endif\n\n#ifdef USE_BITFURY\n  #include \"libbitfury.h\"\n#endif\n\n#ifdef HAVE_BYTESWAP_H\n#include <byteswap.h>\n#endif\n#ifdef HAVE_ENDIAN_H\n#include <endian.h>\n#endif\n#ifdef HAVE_SYS_ENDIAN_H\n#include <sys/endian.h>\n#endif\n#ifdef HAVE_LIBKERN_OSBYTEORDER_H\n#include <libkern/OSByteOrder.h>\n#endif\n#ifndef bswap_16\n#define\tbswap_16(value)  \\\n \t((((value) & 0xff) << 8) | ((value) >> 8))\n\n#define\tbswap_32(value)\t\\\n \t(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \\\n \t(uint32_t)bswap_16((uint16_t)((value) >> 16)))\n\n#define\tbswap_64(value)\t\\\n \t(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \\\n \t    << 32) | \\\n \t(uint64_t)bswap_32((uint32_t)((value) >> 32)))\n#endif\n\n/* This assumes htobe32 is a macro and that if it doesn't exist, then the\n * also won't exist */\n#ifndef htobe32\n# ifndef WORDS_BIGENDIAN\n#  define htole16(x) (x)\n#  define htole32(x) (x)\n#  define htole64(x) (x)\n#  define htobe16(x) bswap_16(x)\n#  define htobe32(x) bswap_32(x)\n#  define htobe64(x) bswap_64(x)\n# else\n#  define htole16(x) bswap_16(x)\n#  define htole32(x) bswap_32(x)\n#  define htole64(x) bswap_64(x)\n#  define htobe16(x) (x)\n#  define htobe32(x) (x)\n#  define htobe64(x) (x)\n# endif\n#endif\n#ifndef be32toh\n# define le16toh(x) htole16(x)\n# define le32toh(x) htole32(x)\n# define le64toh(x) htole64(x)\n# define be16toh(x) htobe16(x)\n# define be32toh(x) htobe32(x)\n# define be64toh(x) htobe64(x)\n#endif\n\n#ifndef max\n#  define max(a, b)  ((a) > (b) ? (a) : (b))\n#endif\n\n#undef unlikely\n#undef likely\n#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)\n#define unlikely(expr) (__builtin_expect(!!(expr), 0))\n#define likely(expr) (__builtin_expect(!!(expr), 1))\n#else\n#define unlikely(expr) (expr)\n#define likely(expr) (expr)\n#endif\n#ifndef __maybe_unused\n#define __maybe_unused\t\t__attribute__((unused))\n#endif\n\n#define uninitialised_var(x) x = x\n\n#if defined(__i386__)\n#define WANT_CRYPTOPP_ASM32\n#endif\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n#endif\n\n#ifdef HAVE_CURSES\n\textern int my_cancellable_getch(void);\n#\tifdef getch\n\t\t// getch() is a macro\n\t\tstatic int __maybe_unused __real_getch(void) {\n\t\t\treturn getch();\n\t\t}\n#\t\tundef getch\n#\t\tdefine getch()  my_cancellable_getch()\n#\telse\n\t\t// getch() is a real function\n#\t\tdefine __real_getch  getch\n#\t\tdefine getch()  my_cancellable_getch()\n#\tendif\n#endif\n\nenum alive {\n\tLIFE_WELL,\n\tLIFE_SICK,\n\tLIFE_DEAD,\n\tLIFE_NOSTART,\n\tLIFE_INIT,\n\tLIFE_WAIT,\n\tLIFE_INIT2,  // Still initializing, but safe to call functions\n\tLIFE_DEAD2,  // Totally dead, NOT safe to call functions\n\tLIFE_MIXED,  // Only valid in display variables, NOT on devices\n};\n\n\nenum pool_strategy {\n\tPOOL_FAILOVER,\n\tPOOL_ROUNDROBIN,\n\tPOOL_ROTATE,\n\tPOOL_LOADBALANCE,\n\tPOOL_BALANCE,\n};\n\n#define TOP_STRATEGY (POOL_BALANCE)\n\nstruct strategies {\n\tconst char *s;\n};\n\nstruct cgpu_info;\n\n#ifdef HAVE_ADL\nstruct gpu_adl {\n\tADLTemperature lpTemperature;\n\tint iAdapterIndex;\n\tint lpAdapterID;\n\tint iBusNumber;\n\tchar strAdapterName[256];\n\n\tADLPMActivity lpActivity;\n\tADLODParameters lpOdParameters;\n\tADLODPerformanceLevels *DefPerfLev;\n\tADLFanSpeedInfo lpFanSpeedInfo;\n\tADLFanSpeedValue lpFanSpeedValue;\n\tADLFanSpeedValue DefFanSpeedValue;\n\n\tint iEngineClock;\n\tint iMemoryClock;\n\tint iVddc;\n\tint iPercentage;\n\n\tbool autofan;\n\tbool autoengine;\n\tbool managed; /* Were the values ever changed on this card */\n\n\tint lastengine;\n\tint lasttemp;\n\tint targetfan;\n\tint overtemp;\n\tint minspeed;\n\tint maxspeed;\n\n\tint gpu;\n\tbool has_fanspeed;\n\tstruct gpu_adl *twin;\n};\n#endif\n\nenum pow_algorithm {\n#ifdef USE_KECCAK\n\tPOW_KECCAK,\n#endif\n#ifdef USE_SHA256D\n\tPOW_SHA256D,\n#endif\n#ifdef USE_SCRYPT\n\tPOW_SCRYPT,\n#endif\n\tPOW_ALGORITHM_COUNT,\n};\n\nstruct api_data;\nstruct thr_info;\nstruct work;\nstruct lowlevel_device_info;\n\nenum bfg_probe_result_flags_values {\n\tBPR_CONTINUE_PROBES = 1<< 0,\n\tBPR_DONT_RESCAN     = 1<< 1,\n\tBPR_WRONG_DEVTYPE   = BPR_CONTINUE_PROBES | BPR_DONT_RESCAN,\n};\nextern unsigned *_bfg_probe_result_flags();\n#define bfg_probe_result_flags (*_bfg_probe_result_flags())\n\nstruct mining_algorithm;\n\nstruct device_drv {\n\tconst char *dname;\n\tconst char *name;\n\tint8_t probe_priority;\n\tbool lowl_probe_by_name_only;\n\n\t// DRV-global functions\n\tvoid (*drv_init)();\n\t// drv_min_nonce_diff's proc may be NULL\n\t// drv_min_nonce_diff should return negative if algorithm is not supported\n\tfloat (*drv_min_nonce_diff)(struct cgpu_info *proc, const struct mining_algorithm *);\n\tvoid (*drv_detect)();\n\tbool (*lowl_match)(const struct lowlevel_device_info *);\n\tbool (*lowl_probe)(const struct lowlevel_device_info *);\n\n\t// Processor-specific functions\n\tvoid (*watchdog)(struct cgpu_info *, const struct timeval *tv_now);\n\tvoid (*reinit_device)(struct cgpu_info *);\n\tbool (*override_statline_temp2)(char *buf, size_t bufsz, struct cgpu_info *, bool per_processor);\n\tstruct api_data* (*get_api_extra_device_detail)(struct cgpu_info *);\n\tstruct api_data* (*get_api_extra_device_status)(struct cgpu_info *);\n\tstruct api_data *(*get_api_stats)(struct cgpu_info *);\n\tbool (*get_stats)(struct cgpu_info *);\n\tbool (*identify_device)(struct cgpu_info *);  // e.g. to flash a led\n\tchar *(*set_device)(struct cgpu_info *, char *option, char *setting, char *replybuf);\n\tvoid (*proc_wlogprint_status)(struct cgpu_info *);\n\tvoid (*proc_tui_wlogprint_choices)(struct cgpu_info *);\n\tconst char *(*proc_tui_handle_choice)(struct cgpu_info *, int input);\n\tvoid (*zero_stats)(struct cgpu_info *);\n\tdouble (*get_proc_rolling_hashrate)(struct cgpu_info *);\n\n\t// Thread-specific functions\n\tbool (*thread_prepare)(struct thr_info *);\n\tvoid (*minerloop)(struct thr_info *);\n\tuint64_t (*can_limit_work)(struct thr_info *);\n\tbool (*thread_init)(struct thr_info *);\n\tbool (*prepare_work)(struct thr_info *, struct work *);\n\tint64_t (*scanhash)(struct thr_info *, struct work *, int64_t);\n\tint64_t (*scanwork)(struct thr_info *);\n\n\t/* Used to extract work from the hash table of queued work and tell\n\t * the main loop that it should not add any further work to the table.\n\t */\n\tbool (*queue_full)(struct cgpu_info *);\n\tvoid (*flush_work)(struct cgpu_info *);\n\n\tvoid (*hw_error)(struct thr_info *);\n\tvoid (*thread_shutdown)(struct thr_info *);\n\tvoid (*thread_disable)(struct thr_info *);\n\tvoid (*thread_enable)(struct thr_info *);\n\n\t// Can be used per-thread or per-processor (only with minerloop async or queue!)\n\tvoid (*poll)(struct thr_info *);\n\n\t// === Implemented by minerloop_async ===\n\tbool (*job_prepare)(struct thr_info*, struct work*, uint64_t);\n\tvoid (*job_start)(struct thr_info*);\n\tvoid (*job_get_results)(struct thr_info*, struct work*);\n\tint64_t (*job_process_results)(struct thr_info*, struct work*, bool stopping);\n\n\t// === Implemented by minerloop_queue ===\n\tbool (*queue_append)(struct thr_info *, struct work *);\n\tvoid (*queue_flush)(struct thr_info *);\n};\n\nenum dev_enable {\n\tDEV_ENABLED,\n\tDEV_DISABLED,     // Disabled by user\n\tDEV_RECOVER,      // Disabled by temperature cutoff in watchdog\n\tDEV_RECOVER_ERR,  // Disabled by communications error\n\tDEV_RECOVER_DRV,  // Disabled by driver\n};\n\nenum cl_kernels {\n\tKL_NONE,\n#ifdef USE_SHA256D\n\tKL_POCLBM,\n\tKL_PHATK,\n\tKL_DIAKGCN,\n\tKL_DIABLO,\n#endif\n#ifdef USE_OPENCL_FULLHEADER\n\tKL_FULLHEADER,\n#endif\n#ifdef USE_SCRYPT\n\tKL_SCRYPT,\n#endif\n\tOPENCL_KERNEL_INTERFACE_COUNT,\n};\n\nenum dev_reason {\n\tREASON_THREAD_FAIL_INIT,\n\tREASON_THREAD_ZERO_HASH,\n\tREASON_THREAD_FAIL_QUEUE,\n\tREASON_DEV_SICK_IDLE_60,\n\tREASON_DEV_DEAD_IDLE_600,\n\tREASON_DEV_NOSTART,\n\tREASON_DEV_OVER_HEAT,\n\tREASON_DEV_THERMAL_CUTOFF,\n\tREASON_DEV_COMMS_ERROR,\n\tREASON_DEV_THROTTLE,\n};\n\n#define REASON_NONE\t\t\t\"None\"\n#define REASON_THREAD_FAIL_INIT_STR\t\"Thread failed to init\"\n#define REASON_THREAD_ZERO_HASH_STR\t\"Thread got zero hashes\"\n#define REASON_THREAD_FAIL_QUEUE_STR\t\"Thread failed to queue work\"\n#define REASON_DEV_SICK_IDLE_60_STR\t\"Device idle for 60s\"\n#define REASON_DEV_DEAD_IDLE_600_STR\t\"Device dead - idle for 600s\"\n#define REASON_DEV_NOSTART_STR\t\t\"Device failed to start\"\n#define REASON_DEV_OVER_HEAT_STR\t\"Device over heated\"\n#define REASON_DEV_THERMAL_CUTOFF_STR\t\"Device reached thermal cutoff\"\n#define REASON_DEV_COMMS_ERROR_STR\t\"Device comms error\"\n#define REASON_DEV_THROTTLE_STR\t\t\"Device throttle\"\n#define REASON_UNKNOWN_STR\t\t\"Unknown reason - code bug\"\n\n#define MIN_SEC_UNSET 99999999\n\nenum {\n\tMSG_NOPOOL\t\t= 8,\n\tMSG_MISPID\t\t= 25,\n\tMSG_INVPID\t\t= 26,\n\tMSG_DUPPID\t\t= 74,\n\tMSG_POOLPRIO\t= 73,\n};\n\nstruct cgminer_stats {\n\tstruct timeval start_tv;\n\t\n\tuint32_t getwork_calls;\n\tstruct timeval getwork_wait;\n\tstruct timeval getwork_wait_max;\n\tstruct timeval getwork_wait_min;\n\n\tstruct timeval _get_start;\n};\n\n// Just the actual network getworks to the pool\nstruct cgminer_pool_stats {\n\tuint32_t getwork_calls;\n\tuint32_t getwork_attempts;\n\tstruct timeval getwork_wait;\n\tstruct timeval getwork_wait_max;\n\tstruct timeval getwork_wait_min;\n\tdouble getwork_wait_rolling;\n\tbool hadrolltime;\n\tbool canroll;\n\tbool hadexpire;\n\tuint32_t rolltime;\n\tdouble min_diff;\n\tdouble max_diff;\n\tdouble last_diff;\n\tuint32_t min_diff_count;\n\tuint32_t max_diff_count;\n\tuint64_t times_sent;\n\tuint64_t bytes_sent;\n\tuint64_t net_bytes_sent;\n\tuint64_t times_received;\n\tuint64_t bytes_received;\n\tuint64_t net_bytes_received;\n};\n\n\n#define PRIprepr \"-6s\"\n#define PRIpreprv \"s\"\n\n#define ALLOC_H2B_NOUNIT  6\n#define ALLOC_H2B_SHORT   7\n#define ALLOC_H2B_SPACED  8\n#define ALLOC_H2B_SHORTV  7\n\n\nstruct cgpu_info {\n\tint cgminer_id;\n\tint device_line_id;\n\tstruct device_drv *drv;\n\tconst struct bfg_set_device_definition *set_device_funcs;\n\tint device_id;\n\tchar *dev_repr;\n\tchar *dev_repr_ns;\n\tconst char *name;\n\t\n\tint procs;\n\tint proc_id;\n\tchar proc_repr[9];\n\tchar proc_repr_ns[9];\n\tstruct cgpu_info *device;\n\tstruct cgpu_info *next_proc;\n\tint extra_work_queue;\n\t\n\tconst char *device_path;\n\tvoid *device_data;\n\tconst char *dev_manufacturer;\n\tconst char *dev_product;\n\tconst char *dev_serial;\n\tunion {\n#ifdef USE_ZTEX\n\t\tstruct libztex_device *device_ztex;\n#endif\n\t\tint device_fd;\n#ifdef USE_X6500\n\t\tstruct ft232r_device_handle *device_ft232r;\n#endif\n\t};\n#ifdef USE_AVALON\n\tstruct work **works;\n\tint work_array;\n\tint queued;\n\tint results;\n#endif\n#ifdef USE_BITFORCE\n\tstruct timeval work_start_tv;\n\tunsigned int wait_ms;\n\tunsigned int sleep_ms;\n\tdouble avg_wait_f;\n\tunsigned int avg_wait_d;\n\tuint32_t nonces;\n\tbool polling;\n#endif\n#if defined(USE_BITFORCE) || defined(USE_ICARUS) || defined(USE_TWINFURY)\n\tbool flash_led;\n#endif\n\tpthread_mutex_t\t\tdevice_mutex;\n\tpthread_cond_t\tdevice_cond;\n\n\tenum dev_enable deven;\n\tbool already_set_defaults;\n\tint accepted;\n\tint rejected;\n\tint stale;\n\tdouble bad_diff1;\n\tint hw_errors;\n\tdouble rolling;\n\tdouble total_mhashes;\n\tdouble utility;\n\tdouble utility_diff1;\n\tenum alive status;\n\tchar init[40];\n\tstruct timeval last_message_tv;\n\n\tint threads;\n\tstruct thr_info **thr;\n\n\tint64_t max_hashes;\n\n\tconst char *kname;\n\n\tfloat temp;\n\tint cutofftemp;\n\tint targettemp;\n\tbool targettemp_user;\n\n\tdouble diff1;\n\tdouble diff_accepted;\n\tdouble diff_rejected;\n\tdouble diff_stale;\n\tint last_share_pool;\n\ttime_t last_share_pool_time;\n\tdouble last_share_diff;\n\ttime_t last_device_valid_work;\n\n\ttime_t device_last_well;\n\ttime_t device_last_not_well;\n\tstruct timeval tv_device_last_not_well;\n\tenum dev_reason device_not_well_reason;\n\tfloat reinit_backoff;\n\tint thread_fail_init_count;\n\tint thread_zero_hash_count;\n\tint thread_fail_queue_count;\n\tint dev_sick_idle_60_count;\n\tint dev_dead_idle_600_count;\n\tint dev_nostart_count;\n\tint dev_over_heat_count;\t// It's a warning but worth knowing\n\tint dev_thermal_cutoff_count;\n\tint dev_comms_error_count;\n\tint dev_throttle_count;\n\n\tstruct cgminer_stats cgminer_stats;\n\n\tpthread_rwlock_t qlock;\n\tstruct work *queued_work;\n\tstruct work *unqueued_work;\n\tunsigned int queued_count;\n\n\tbool disable_watchdog;\n\tbool shutdown;\n};\n\nextern void renumber_cgpu(struct cgpu_info *);\nextern bool add_cgpu(struct cgpu_info*);\n\nstruct tq_ent;\n\nstruct thread_q {\n\tstruct tq_ent *q;\n\n\tbool frozen;\n\n\tpthread_mutex_t\t\tmutex;\n\tpthread_cond_t\t\tcond;\n};\n\nenum thr_busy_state {\n\tTBS_IDLE,\n\tTBS_GETTING_RESULTS,\n\tTBS_STARTING_JOB,\n};\n\nstruct thr_info {\n\tint\t\tid;\n\tint\t\tdevice_thread;\n\tbool\t\tprimary_thread;\n\n\tbool\t\thas_pth;\n\tpthread_t\tpth;\n\tstruct thread_q\t*q;\n\tstruct cgpu_info *cgpu;\n\tvoid *cgpu_data;\n\tstruct timeval last;\n\tstruct timeval sick;\n\n\tbool\tscanhash_working;\n\tuint64_t hashes_done;\n\tstruct timeval tv_hashes_done;\n\tstruct timeval tv_lastupdate;\n\tstruct timeval _tv_last_hashes_done_call;\n\n\tbool\tpause;\n\ttime_t\tgetwork;\n\tdouble\trolling;\n\n\t// Used by minerloop_async\n\tstruct work *prev_work;\n\tstruct work *work;\n\tstruct work *next_work;\n\tenum thr_busy_state busy_state;\n\tbool _mt_disable_called;\n\tstruct timeval tv_morework;\n\tstruct work *results_work;\n\tbool _job_transition_in_progress;\n\tbool _proceed_with_new_job;\n\tstruct timeval tv_results_jobstart;\n\tstruct timeval tv_jobstart;\n\tstruct timeval tv_poll;\n\tstruct timeval tv_watchdog;\n\tnotifier_t notifier;\n\tbool starting_next_work;\n\tuint32_t _max_nonce;\n\tnotifier_t mutex_request;\n\n\t// Used by minerloop_queue\n\tstruct work *work_list;\n\tbool queue_full;\n\n\tbool\twork_restart;\n\tnotifier_t work_restart_notifier;\n};\n\nstruct string_elist {\n\tchar *string;\n\tbool free_me;\n\n\tstruct string_elist *prev;\n\tstruct string_elist *next;\n};\n\nstatic inline void string_elist_add(const char *s, struct string_elist **head)\n{\n\tstruct string_elist *n;\n\n\tn = calloc(1, sizeof(*n));\n\tn->string = strdup(s);\n\tn->free_me = true;\n\tDL_APPEND(*head, n);\n}\n\nstatic inline void string_elist_del(struct string_elist **head, struct string_elist *item)\n{\n\tif (item->free_me)\n\t\tfree(item->string);\n\tDL_DELETE(*head, item);\n\tfree(item);\n}\n\n\nstruct bfg_loaded_configfile {\n\tchar *filename;\n\tint fileconf_load;\n\t\n\tstruct bfg_loaded_configfile *next;\n};\n\nextern struct bfg_loaded_configfile *bfg_loaded_configfiles;\n\n\nstatic inline uint32_t swab32(uint32_t v)\n{\n\treturn bswap_32(v);\n}\n\nstatic inline void swap256(void *dest_p, const void *src_p)\n{\n\tuint32_t *dest = dest_p;\n\tconst uint32_t *src = src_p;\n\n\tdest[0] = src[7];\n\tdest[1] = src[6];\n\tdest[2] = src[5];\n\tdest[3] = src[4];\n\tdest[4] = src[3];\n\tdest[5] = src[2];\n\tdest[6] = src[1];\n\tdest[7] = src[0];\n}\n\nstatic inline void swap32yes(void*out, const void*in, size_t sz) {\n\tsize_t swapcounter = 0;\n\tfor (swapcounter = 0; swapcounter < sz; ++swapcounter)\n\t\t(((uint32_t*)out)[swapcounter]) = swab32(((uint32_t*)in)[swapcounter]);\n}\n\n#define LOCAL_swap32(type, var, sz)  \\\n\ttype __swapped_ ## var[sz * 4 / sizeof(type)];  \\\n\tswap32yes(__swapped_ ## var, var, sz);  \\\n\tvar = __swapped_ ## var;  \\\n// end\n\n#ifdef WORDS_BIGENDIAN\n#  define swap32tobe(out, in, sz)  ((out == in) ? (void)0 : (void)memmove(out, in, (sz)*4))\n#  define LOCAL_swap32be(type, var, sz)  ;\n#  define swap32tole(out, in, sz)  swap32yes(out, in, sz)\n#  define LOCAL_swap32le(type, var, sz)  LOCAL_swap32(type, var, sz)\n#else\n#  define swap32tobe(out, in, sz)  swap32yes(out, in, sz)\n#  define LOCAL_swap32be(type, var, sz)  LOCAL_swap32(type, var, sz)\n#  define swap32tole(out, in, sz)  ((out == in) ? (void)0 : (void)memmove(out, in, (sz)*4))\n#  define LOCAL_swap32le(type, var, sz)  ;\n#endif\n\nstatic inline void swab256(void *dest_p, const void *src_p)\n{\n\tuint32_t *dest = dest_p;\n\tconst uint32_t *src = src_p;\n\n\tdest[0] = swab32(src[7]);\n\tdest[1] = swab32(src[6]);\n\tdest[2] = swab32(src[5]);\n\tdest[3] = swab32(src[4]);\n\tdest[4] = swab32(src[3]);\n\tdest[5] = swab32(src[2]);\n\tdest[6] = swab32(src[1]);\n\tdest[7] = swab32(src[0]);\n}\n\nstatic inline\nvoid bswap_96p(void * const dest_p, const void * const src_p)\n{\n\tuint32_t * const dest = dest_p;\n\tconst uint32_t * const src = src_p;\n\t\n\tdest[0] = bswap_32(src[2]);\n\tdest[1] = bswap_32(src[1]);\n\tdest[2] = bswap_32(src[0]);\n}\n\nstatic inline\nvoid bswap_32mult(void * const dest_p, const void * const src_p, const size_t sz)\n{\n\tconst uint32_t *s = src_p;\n\tconst uint32_t *s_end = &s[sz];\n\tuint32_t *d = dest_p;\n\td = &d[sz - 1];\n\t\n\tfor ( ; s < s_end; ++s, --d)\n\t\t*d = bswap_32(*s);\n}\n\n#define flip12(dest_p, src_p) swap32yes(dest_p, src_p, 12 / 4)\n#define flip32(dest_p, src_p) swap32yes(dest_p, src_p, 32 / 4)\n\n#define WATCHDOG_INTERVAL  2\nextern void bfg_watchdog(struct cgpu_info *, struct timeval *tvp_now);\n\nextern void _quit(int status);\n\nstatic inline void mutex_lock(pthread_mutex_t *lock)\n{\n\tif (unlikely(pthread_mutex_lock(lock)))\n\t\tquit(1, \"WTF MUTEX ERROR ON LOCK!\");\n}\n\nstatic inline void mutex_unlock_noyield(pthread_mutex_t *lock)\n{\n\tif (unlikely(pthread_mutex_unlock(lock)))\n\t\tquit(1, \"WTF MUTEX ERROR ON UNLOCK!\");\n}\n\nstatic inline void mutex_unlock(pthread_mutex_t *lock)\n{\n\tmutex_unlock_noyield(lock);\n\tsched_yield();\n}\n\nstatic inline int mutex_trylock(pthread_mutex_t *lock)\n{\n\treturn pthread_mutex_trylock(lock);\n}\n\nstatic inline void wr_lock(pthread_rwlock_t *lock)\n{\n\tif (unlikely(pthread_rwlock_wrlock(lock)))\n\t\tquit(1, \"WTF WRLOCK ERROR ON LOCK!\");\n}\n\nstatic inline void rd_lock(pthread_rwlock_t *lock)\n{\n\tif (unlikely(pthread_rwlock_rdlock(lock)))\n\t\tquit(1, \"WTF RDLOCK ERROR ON LOCK!\");\n}\n\nstatic inline void rw_unlock(pthread_rwlock_t *lock)\n{\n\tif (unlikely(pthread_rwlock_unlock(lock)))\n\t\tquit(1, \"WTF RWLOCK ERROR ON UNLOCK!\");\n}\n\nstatic inline void rd_unlock_noyield(pthread_rwlock_t *lock)\n{\n\trw_unlock(lock);\n}\n\nstatic inline void wr_unlock_noyield(pthread_rwlock_t *lock)\n{\n\trw_unlock(lock);\n}\n\nstatic inline void rd_unlock(pthread_rwlock_t *lock)\n{\n\trw_unlock(lock);\n\tsched_yield();\n}\n\nstatic inline void wr_unlock(pthread_rwlock_t *lock)\n{\n\trw_unlock(lock);\n\tsched_yield();\n}\n\nstatic inline void mutex_init(pthread_mutex_t *lock)\n{\n\tif (unlikely(pthread_mutex_init(lock, NULL)))\n\t\tquit(1, \"Failed to pthread_mutex_init\");\n}\n\nstatic inline void mutex_destroy(pthread_mutex_t *lock)\n{\n\t/* Ignore return code. This only invalidates the mutex on linux but\n\t * releases resources on windows. */\n\tpthread_mutex_destroy(lock);\n}\n\nstatic inline void rwlock_init(pthread_rwlock_t *lock)\n{\n\tif (unlikely(pthread_rwlock_init(lock, NULL)))\n\t\tquit(1, \"Failed to pthread_rwlock_init\");\n}\n\n/* cgminer locks, a write biased variant of rwlocks */\nstruct cglock {\n\tpthread_mutex_t mutex;\n\tpthread_rwlock_t rwlock;\n};\n\ntypedef struct cglock cglock_t;\n\nstatic inline void rwlock_destroy(pthread_rwlock_t *lock)\n{\n\tpthread_rwlock_destroy(lock);\n}\n\nstatic inline void cglock_init(cglock_t *lock)\n{\n\tmutex_init(&lock->mutex);\n\trwlock_init(&lock->rwlock);\n}\n\nstatic inline void cglock_destroy(cglock_t *lock)\n{\n\trwlock_destroy(&lock->rwlock);\n\tmutex_destroy(&lock->mutex);\n}\n\n/* Read lock variant of cglock. Cannot be promoted. */\nstatic inline void cg_rlock(cglock_t *lock)\n{\n\tmutex_lock(&lock->mutex);\n\trd_lock(&lock->rwlock);\n\tmutex_unlock_noyield(&lock->mutex);\n}\n\n/* Intermediate variant of cglock - behaves as a read lock but can be promoted\n * to a write lock or demoted to read lock. */\nstatic inline void cg_ilock(cglock_t *lock)\n{\n\tmutex_lock(&lock->mutex);\n}\n\n/* Upgrade intermediate variant to a write lock */\nstatic inline void cg_ulock(cglock_t *lock)\n{\n\twr_lock(&lock->rwlock);\n}\n\n/* Write lock variant of cglock */\nstatic inline void cg_wlock(cglock_t *lock)\n{\n\tmutex_lock(&lock->mutex);\n\twr_lock(&lock->rwlock);\n}\n\n/* Downgrade write variant to a read lock */\nstatic inline void cg_dwlock(cglock_t *lock)\n{\n\twr_unlock_noyield(&lock->rwlock);\n\trd_lock(&lock->rwlock);\n\tmutex_unlock_noyield(&lock->mutex);\n}\n\n/* Demote a write variant to an intermediate variant */\nstatic inline void cg_dwilock(cglock_t *lock)\n{\n\twr_unlock(&lock->rwlock);\n}\n\n/* Downgrade intermediate variant to a read lock */\nstatic inline void cg_dlock(cglock_t *lock)\n{\n\trd_lock(&lock->rwlock);\n\tmutex_unlock(&lock->mutex);\n}\n\nstatic inline void cg_runlock(cglock_t *lock)\n{\n\trd_unlock(&lock->rwlock);\n}\n\nstatic inline void cg_iunlock(cglock_t *lock)\n{\n\tmutex_unlock(&lock->mutex);\n}\n\nstatic inline void cg_wunlock(cglock_t *lock)\n{\n\twr_unlock_noyield(&lock->rwlock);\n\tmutex_unlock(&lock->mutex);\n}\n\nstruct pool;\n\n#define API_MCAST_CODE \"FTW\"\n#define API_MCAST_ADDR \"224.0.0.75\"\n\nextern bool opt_protocol;\nextern bool opt_dev_protocol;\nextern char *opt_coinbase_sig;\nextern char *request_target_str;\nextern float request_pdiff;\nextern double request_bdiff;\nextern int opt_skip_checks;\nextern char *opt_kernel_path;\nextern char *opt_socks_proxy;\nextern char *cmd_idle, *cmd_sick, *cmd_dead;\nextern char *cgminer_path;\nextern bool opt_fail_only;\nextern bool opt_autofan;\nextern bool opt_autoengine;\nextern bool use_curses;\nextern int last_logstatusline_len;\n#ifdef HAVE_LIBUSB\nextern bool have_libusb;\n#endif\nextern int httpsrv_port;\nextern long stratumsrv_port;\nextern char *opt_api_allow;\nextern bool opt_api_mcast;\nextern char *opt_api_mcast_addr;\nextern char *opt_api_mcast_code;\nextern char *opt_api_mcast_des;\nextern int opt_api_mcast_port;\nextern char *opt_api_groups;\nextern char *opt_api_description;\nextern int opt_api_port;\nextern bool opt_api_listen;\nextern bool opt_api_network;\nextern bool opt_delaynet;\nextern time_t last_getwork;\nextern bool opt_disable_client_reconnect;\nextern bool opt_restart;\nextern char *opt_icarus_options;\nextern char *opt_icarus_timing;\nextern bool opt_worktime;\n#ifdef USE_AVALON\nextern char *opt_avalon_options;\n#endif\n#ifdef USE_KLONDIKE\nextern char *opt_klondike_options;\n#endif\n#ifdef USE_BITFORCE\nextern bool opt_bfl_noncerange;\n#endif\nextern int swork_id;\n\nextern pthread_rwlock_t netacc_lock;\n\nextern const uint32_t sha256_init_state[];\nextern json_t *json_web_config(CURL *curl, const char *url);\nextern json_t *json_rpc_call(CURL *curl, const char *url, const char *userpass,\n\t\t\t     const char *rpc_req, bool, bool, int *,\n\t\t\t     struct pool *pool, bool);\nextern bool our_curl_supports_proxy_uris();\nextern void bin2hex(char *out, const void *in, size_t len);\nextern bool hex2bin(unsigned char *p, const char *hexstr, size_t len);\n\nextern int opt_queue;\nextern int opt_scantime;\nextern int opt_expiry;\n\nextern cglock_t control_lock;\nextern pthread_mutex_t stats_lock;\nextern pthread_mutex_t hash_lock;\nextern pthread_mutex_t console_lock;\nextern cglock_t ch_lock;\nextern pthread_rwlock_t mining_thr_lock;\nextern pthread_rwlock_t devices_lock;\n\n\nextern bool _bfg_console_cancel_disabled;\nextern int _bfg_console_prev_cancelstate;\n\nstatic inline\nvoid bfg_console_lock(void)\n{\n\tint prev_cancelstate;\n\tbool cancel_disabled = !pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &prev_cancelstate);\n\tmutex_lock(&console_lock);\n\t_bfg_console_cancel_disabled = cancel_disabled;\n\tif (cancel_disabled)\n\t\t_bfg_console_prev_cancelstate = prev_cancelstate;\n}\n\nstatic inline\nvoid bfg_console_unlock(void)\n{\n\tint prev_cancelstate;\n\tbool cancel_disabled = _bfg_console_cancel_disabled;\n\tif (cancel_disabled)\n\t{\n\t\tprev_cancelstate = _bfg_console_prev_cancelstate;\n\t\tmutex_unlock(&console_lock);\n\t\tpthread_setcancelstate(prev_cancelstate, &prev_cancelstate);\n\t}\n\telse\n\t\tmutex_unlock(&console_lock);\n}\n\n\nextern void thread_reportin(struct thr_info *thr);\nextern void thread_reportout(struct thr_info *);\nextern void clear_stratum_shares(struct pool *pool);\nextern void hashmeter2(struct thr_info *);\nextern bool stale_work2(struct work *, bool share, bool have_pool_data_lock);\n#define stale_work(work, share)  stale_work2(work, share, false)\nextern bool stale_work_future(struct work *, bool share, unsigned long ustime);\nextern void blkhashstr(char *out, const unsigned char *hash);\nstatic const float minimum_pdiff = max(FLT_MIN, 1./0x100000000);\nextern void set_target_to_pdiff(void *dest_target, double pdiff);\n#define bdiff_to_pdiff(n) (n * 1.0000152587)\nextern void set_target_to_bdiff(void *dest_target, double bdiff);\n#define pdiff_to_bdiff(n) (n * 0.9999847412109375)\nextern double target_diff(const unsigned char *target);\n\nextern void kill_work(void);\nextern void app_restart(void);\n\nextern void __thr_being_msg(int prio, struct thr_info *, const char *);\nextern void mt_enable(struct thr_info *thr);\nextern void proc_enable(struct cgpu_info *);\nextern void reinit_device(struct cgpu_info *cgpu);\n\nextern void cgpu_set_defaults(struct cgpu_info *);\nextern void drv_set_defaults(const struct device_drv *, const void *, void *userp, const char *devpath, const char *serial, int mode);\n\n#ifdef HAVE_ADL\nextern bool gpu_stats(int gpu, float *temp, int *engineclock, int *memclock, float *vddc, int *activity, int *fanspeed, int *fanpercent, int *powertune);\nextern int set_fanspeed(int gpu, int iFanSpeed);\nextern int set_vddc(int gpu, float fVddc);\nextern int set_engineclock(int gpu, int iEngineClock);\nextern int set_memoryclock(int gpu, int iMemoryClock);\n#endif\n\nextern void api(int thr_id);\n\nextern struct pool *current_pool(void);\nextern int enabled_pools;\nextern bool get_intrange(const char *arg, int *val1, int *val2);\nextern bool detect_stratum(struct pool *pool, char *url);\nextern void print_summary(void);\nextern struct mining_algorithm *mining_algorithm_by_alias(const char *alias);\nextern struct mining_goal_info *get_mining_goal(const char *name);\nextern void goal_set_malgo(struct mining_goal_info *, struct mining_algorithm *);\nextern void mining_goal_reset(struct mining_goal_info * const goal);\nextern void adjust_quota_gcd(void);\nextern struct pool *add_pool2(struct mining_goal_info *);\n#define add_pool()  add_pool2(get_mining_goal(\"default\"))\nextern bool add_pool_details(struct pool *pool, bool live, char *url, char *user, char *pass);\nextern int bfg_strategy_parse(const char *strategy);\nextern bool bfg_strategy_change(int strategy, const char *param);\n\n#define MAX_GPUDEVICES 16\n#define MAX_DEVICES 4096\n\nstruct block_info {\n\tuint32_t block_id;\n\tuint8_t prevblkhash[0x20];\n\tunsigned block_seen_order;  // new_blocks when this block was first seen; was 'block_no'\n\tuint32_t height;\n\ttime_t first_seen_time;\n\t\n\tUT_hash_handle hh;\n};\n\nstruct blockchain_info {\n\tstruct block_info *blocks;\n\tstruct block_info *currentblk;\n\tuint64_t currentblk_subsidy;  // only valid when height is known! (and assumes Bitcoin)\n\tchar currentblk_first_seen_time_str[0x20];  // was global blocktime\n};\n\nstruct _clState;\nstruct cgpu_info;\nstruct mining_algorithm;\n\nstruct mining_algorithm {\n\tconst char *name;\n\tconst char *aliases;\n\t\n\tenum pow_algorithm algo;\n\tuint8_t ui_skip_hash_bytes;\n\tuint8_t worktime_skip_prevblk_u32;\n\tfloat reasonable_low_nonce_diff;\n\t\n\tvoid (*hash_data_f)(void *digest, const void *data);\n\t\n\tint goal_refs;\n\tint staged;\n\tint base_queue;\n\t\n\tstruct mining_algorithm *next;\n\t\n#ifdef USE_OPENCL\n\tbool opencl_nodefault;\n\tfloat (*opencl_oclthreads_to_intensity)(unsigned long oclthreads);\n\tunsigned long (*opencl_intensity_to_oclthreads)(float intensity);\n\tunsigned long opencl_min_oclthreads;\n\tunsigned long opencl_max_oclthreads;\n\tfloat opencl_min_nonce_diff;\n\tchar *(*opencl_get_default_kernel_file)(const struct mining_algorithm *, struct cgpu_info *, struct _clState *);\n#endif\n};\n\nstruct mining_goal_info {\n\tunsigned id;\n\tchar *name;\n\tbool is_default;\n\t\n\tstruct blockchain_info *blkchain;\n\t\n\tbytes_t *generation_script;  // was opt_coinbase_script\n\t\n\tstruct mining_algorithm *malgo;\n\tdouble current_diff;\n\tchar current_diff_str[ALLOC_H2B_SHORTV];  // was global block_diff\n\tchar net_hashrate[ALLOC_H2B_SHORT];\n\t\n\tchar *current_goal_detail;\n\t\n\tdouble diff_accepted;\n\t\n\tbool have_longpoll;\n\t\n\tUT_hash_handle hh;\n};\n\nextern struct string_elist *scan_devices;\nextern bool opt_force_dev_init;\nextern int nDevs;\nextern int opt_n_threads;\nextern int num_processors;\nextern int hw_errors;\nextern bool use_syslog;\nextern bool opt_quiet;\nextern struct thr_info *control_thr;\nextern struct thr_info **mining_thr;\nextern struct cgpu_info gpus[MAX_GPUDEVICES];\nextern double total_secs;\nextern int mining_threads;\nextern struct cgpu_info *cpus;\nextern int total_devices;\nextern struct cgpu_info **devices;\nextern int total_devices_new;\nextern struct cgpu_info **devices_new;\nextern int total_pools;\nextern struct pool **pools;\nextern const char *algo_names[];\nextern enum sha256_algos opt_algo;\nextern struct strategies strategies[];\nextern enum pool_strategy pool_strategy;\nextern int opt_rotate_period;\nextern double total_rolling;\nextern double total_mhashes_done;\nextern unsigned int new_blocks;\nextern unsigned int found_blocks;\nextern int total_accepted, total_rejected;\nextern int total_getworks, total_stale, total_discarded;\nextern uint64_t total_bytes_rcvd, total_bytes_sent;\n#define total_bytes_xfer (total_bytes_rcvd + total_bytes_sent)\nextern double total_diff1, total_bad_diff1;\nextern double total_diff_accepted, total_diff_rejected, total_diff_stale;\nextern unsigned int local_work;\nextern unsigned int total_go, total_ro;\nextern const int opt_cutofftemp;\nextern int opt_hysteresis;\nextern int opt_fail_pause;\nextern int opt_log_interval;\nextern unsigned long long global_hashrate;\nextern unsigned unittest_failures;\nextern double best_diff;\nextern struct mining_algorithm *mining_algorithms;\nextern struct mining_goal_info *mining_goals;\n\nstruct curl_ent {\n\tCURL *curl;\n\tstruct curl_ent *next;\n\tstruct timeval tv;\n};\n\n/* Disabled needs to be the lowest enum as a freshly calloced value will then\n * equal disabled */\nenum pool_enable {\n\tPOOL_DISABLED,\n\tPOOL_ENABLED,\n\tPOOL_REJECTING,\n\tPOOL_MISBEHAVING,\n};\n\nenum pool_protocol {\n\tPLP_NONE,\n\tPLP_GETWORK,\n\tPLP_GETBLOCKTEMPLATE,\n};\n\nstruct bfg_tmpl_ref {\n\tblktemplate_t *tmpl;\n\tint refcount;\n\tpthread_mutex_t mutex;\n};\n\nstruct ntime_roll_limits {\n\tuint32_t min;\n\tuint32_t max;\n\tstruct timeval tv_ref;\n\tint16_t minoff;\n\tint16_t maxoff;\n};\n\nstruct stratum_work {\n\t// Used only as a session id for resuming\n\tchar *nonce1;\n\t\n\tstruct bfg_tmpl_ref *tr;\n\tchar *job_id;\n\tbool clean;\n\t\n\tbytes_t coinbase;\n\tsize_t nonce2_offset;\n\tint n2size;\n\t\n\tint merkles;\n\tbytes_t merkle_bin;\n\t\n\tuint8_t header1[36];\n\tuint8_t diffbits[4];\n\t\n\tuint32_t ntime;\n\tstruct timeval tv_received;\n\tstruct ntime_roll_limits ntime_roll_limits;\n\t\n\tstruct timeval tv_expire;\n\n\tuint8_t target[32];\n\n\tbool transparency_probed;\n\tstruct timeval tv_transparency;\n\tbool opaque;\n\t\n\tcglock_t *data_lock_p;\n\t\n\tstruct pool *pool;\n\tunsigned char work_restart_id;\n};\n\n#define RBUFSIZE 8192\n#define RECVSIZE (RBUFSIZE - 4)\n\n/*\n * Build an hash table in case there are lots\n * of addresses to check against\n */\nstruct bytes_hashtbl {\n\tbytes_t b;\n\tUT_hash_handle hh;\n};\n\nstruct coinbase_param {\n\tbool testnet;\n\tstruct bytes_hashtbl *scripts;\n\tint64_t total;\n\tfloat perc;\n};\n\nstruct pool {\n\tint pool_no;\n\tint prio;\n\tint accepted, rejected;\n\tint seq_rejects;\n\tint seq_getfails;\n\tint solved;\n\tdouble diff1;\n\tchar diff[ALLOC_H2B_SHORTV];\n\tint quota;\n\tint quota_gcd;\n\tint quota_used;\n\tint works;\n\n\tdouble diff_accepted;\n\tdouble diff_rejected;\n\tdouble diff_stale;\n\n\tbool submit_fail;\n\tbool idle;\n\tbool lagging;\n\tbool probed;\n\tint force_rollntime;\n\tenum pool_enable enabled;\n\tbool failover_only;  // NOTE: Ignored by failover and loadbalance strategies (use priority and quota respectively)\n\tbool submit_old;\n\tbool removed;\n\tbool lp_started;\n\tunsigned char\twork_restart_id;\n\ttime_t work_restart_time;\n\tchar work_restart_timestamp[11];\n\tuint32_t\tblock_id;\n\tstruct mining_goal_info *goal;\n\tenum bfg_tristate pool_diff_effective_retroactively;\n\n\tenum pool_protocol proto;\n\n\tchar *hdr_path;\n\tchar *lp_url;\n\tchar *lp_id;\n\tenum pool_protocol lp_proto;\n\tcurl_socket_t lp_socket;\n\tbool lp_active;\n\n\tunsigned int getwork_requested;\n\tunsigned int stale_shares;\n\tunsigned int discarded_work;\n\tunsigned int getfail_occasions;\n\tunsigned int remotefail_occasions;\n\tstruct timeval tv_idle;\n\n\tdouble utility;\n\tint last_shares, shares;\n\n\tchar *rpc_url;\n\tchar *rpc_userpass;\n\tchar *rpc_user, *rpc_pass;\n\tchar *rpc_proxy;\n\n\tpthread_mutex_t pool_lock;\n\tpthread_mutex_t pool_test_lock;\n\tcglock_t data_lock;\n\n\tstruct thread_q *submit_q;\n\tstruct thread_q *getwork_q;\n\n\tpthread_t longpoll_thread;\n\tpthread_t test_thread;\n\tbool testing;\n\n\tint curls;\n\tpthread_cond_t cr_cond;\n\tstruct curl_ent *curllist;\n\tstruct submit_work_state *sws_waiting_on_curl;\n\n\ttime_t last_work_time;\n\tstruct timeval tv_last_work_time;\n\ttime_t last_share_time;\n\tdouble last_share_diff;\n\tdouble best_diff;\n\n\tstruct cgminer_stats cgminer_stats;\n\tstruct cgminer_pool_stats cgminer_pool_stats;\n\n\t/* Stratum variables */\n\tchar *stratum_url;\n\tchar *stratum_port;\n\tCURL *stratum_curl;\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tSOCKETTYPE sock;\n\tchar *sockbuf;\n\tsize_t sockbuf_size;\n\tchar *sockaddr_url; /* stripped url used for sockaddr */\n\tsize_t n1_len;\n\tuint64_t nonce2;\n\tint nonce2sz;\n#ifdef WORDS_BIGENDIAN\n\tint nonce2off;\n#endif\n\tchar *sessionid;\n\tbool has_stratum;\n\tbool stratum_active;\n\tbool stratum_init;\n\tbool stratum_notify;\n\tstruct stratum_work swork;\n\tchar *goalname;\n\tchar *next_goalname;\n\tstruct mining_algorithm *next_goal_malgo;\n\tuint8_t next_target[0x20];\n\tchar *next_nonce1;\n\tint next_n2size;\n\tpthread_t stratum_thread;\n\tpthread_mutex_t stratum_lock;\n\tchar *admin_msg;\n\n\t/* param for coinbase check */\n\tstruct coinbase_param cb_param;\n\t\n\tpthread_mutex_t last_work_lock;\n\tstruct work *last_work_copy;\n};\n\n#define GETWORK_MODE_TESTPOOL 'T'\n#define GETWORK_MODE_POOL 'P'\n#define GETWORK_MODE_LP 'L'\n#define GETWORK_MODE_BENCHMARK 'B'\n#define GETWORK_MODE_STRATUM 'S'\n#define GETWORK_MODE_GBT 'G'\n\ntypedef unsigned work_device_id_t;\n#define PRIwdi \"04x\"\n\nstruct work {\n\tunsigned char\tdata[128];\n\tunsigned char\tmidstate[32];\n\tunsigned char\ttarget[32];\n\tunsigned char\thash[32];\n\n\tdouble share_diff;\n\n\tint\t\trolls;\n\tstruct ntime_roll_limits ntime_roll_limits;\n\n\tstruct {\n\t\tuint32_t nonce;\n\t} blk;\n\n\tstruct thr_info\t*thr;\n\tint\t\tthr_id;\n\tstruct pool\t*pool;\n\tstruct timeval\ttv_staged;\n\n\tbool\t\tmined;\n\tbool\t\tclone;\n\tbool\t\tcloned;\n\tint\t\trolltime;\n\tbool\t\tlongpoll;\n\tbool\t\tstale;\n\tbool\t\tmandatory;\n\tbool spare;\n\tbool\t\tblock;\n\n\tbool\t\tstratum;\n\tchar \t\t*job_id;\n\tbytes_t\t\tnonce2;\n\tchar\t\t*nonce1;\n\n\tunsigned char\twork_restart_id;\n\tint\t\tid;\n\twork_device_id_t device_id;\n\tUT_hash_handle hh;\n\t\n\t// Please don't use this if it's at all possible, I'd like to get rid of it eventually.\n\tvoid *device_data;\n\tvoid *(*device_data_dup_func)(struct work *);\n\tvoid (*device_data_free_func)(struct work *);\n\t\n\tdouble\t\twork_difficulty;\n\tfloat\t\tnonce_diff;\n\n\t// Allow devices to identify work if multiple sub-devices\n\t// DEPRECATED: New code should be using multiple processors instead\n\tint\t\tsubid;\n\t\n\t// Allow devices to timestamp work for their own purposes\n\tstruct timeval\ttv_stamp;\n\n\tstruct bfg_tmpl_ref *tr;\n\tunsigned int\tdataid;\n\tbool\t\tdo_foreign_submit;\n\n\tstruct timeval\ttv_getwork;\n\ttime_t\t\tts_getwork;\n\tstruct timeval\ttv_getwork_reply;\n\tstruct timeval\ttv_cloned;\n\tstruct timeval\ttv_work_start;\n\tstruct timeval\ttv_work_found;\n\tchar\t\tgetwork_mode;\n\n\t/* Used to queue shares in submit_waiting */\n\tstruct work *prev;\n\tstruct work *next;\n};\n\nextern void get_datestamp(char *, size_t, time_t);\n#define get_now_datestamp(buf, bufsz)  get_datestamp(buf, bufsz, INVALID_TIMESTAMP)\nextern void get_benchmark_work(struct work *, bool use_swork);\nextern void stratum_work_cpy(struct stratum_work *dst, const struct stratum_work *src);\nextern void stratum_work_clean(struct stratum_work *);\nextern bool pool_has_usable_swork(const struct pool *);\nextern void gen_stratum_work2(struct work *, struct stratum_work *);\nextern void gen_stratum_work3(struct work *, struct stratum_work *, cglock_t *data_lock_p);\nextern void inc_hw_errors3(struct thr_info *thr, const struct work *work, const uint32_t *bad_nonce_p, float nonce_diff);\nstatic inline\nvoid inc_hw_errors2(struct thr_info * const thr, const struct work * const work, const uint32_t *bad_nonce_p)\n{\n\tinc_hw_errors3(thr, work, bad_nonce_p, work ? work->nonce_diff : 1.);\n}\n#define UNKNOWN_NONCE ((uint32_t*)inc_hw_errors2)\nstatic inline\nvoid inc_hw_errors(struct thr_info * const thr, const struct work * const work, const uint32_t bad_nonce)\n{\n\tinc_hw_errors2(thr, work, work ? &bad_nonce : NULL);\n}\n#define inc_hw_errors_only(thr)  inc_hw_errors(thr, NULL, 0)\nenum test_nonce2_result {\n\tTNR_GOOD = 1,\n\tTNR_HIGH = 0,\n\tTNR_BAD = -1,\n};\nextern enum test_nonce2_result _test_nonce2(struct work *, uint32_t nonce, bool checktarget);\n#define test_nonce(work, nonce, checktarget)  (_test_nonce2(work, nonce, checktarget) == TNR_GOOD)\n#define test_nonce2(work, nonce)  (_test_nonce2(work, nonce, true))\nextern bool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce);\nextern bool submit_noffset_nonce(struct thr_info *thr, struct work *work, uint32_t nonce,\n\t\t\t  int noffset);\nextern void __add_queued(struct cgpu_info *cgpu, struct work *work);\nextern struct work *get_queued(struct cgpu_info *cgpu);\nextern void add_queued(struct cgpu_info *cgpu, struct work *work);\nextern struct work *get_queue_work(struct thr_info *thr, struct cgpu_info *cgpu, int thr_id);\nextern struct work *__find_work_bymidstate(struct work *que, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);\nextern struct work *find_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);\nextern struct work *clone_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);\nextern void __work_completed(struct cgpu_info *cgpu, struct work *work);\nextern int age_queued_work(struct cgpu_info *cgpu, double secs);\nextern void work_completed(struct cgpu_info *cgpu, struct work *work);\nextern struct work *take_queued_work_bymidstate(struct cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);\nextern void flush_queue(struct cgpu_info *cgpu);\nextern bool abandon_work(struct work *, struct timeval *work_runtime, uint64_t hashes);\nextern void hash_queued_work(struct thr_info *mythr);\nextern void get_statline3(char *buf, size_t bufsz, struct cgpu_info *, bool for_curses, bool opt_show_procs);\nextern void tailsprintf(char *buf, size_t bufsz, const char *fmt, ...) FORMAT_SYNTAX_CHECK(printf, 3, 4);\nextern void _wlog(const char *str);\nextern void _wlogprint(const char *str);\nextern int curses_int(const char *query);\nextern char *curses_input(const char *query);\nextern bool drv_ready(struct cgpu_info *);\nextern double stats_elapsed(struct cgminer_stats *);\n#define cgpu_runtime(cgpu)  stats_elapsed(&((cgpu)->cgminer_stats))\nextern double cgpu_utility(struct cgpu_info *);\nextern void kill_work(void);\nextern int prioritize_pools(char *param, int *pid);\nextern void validate_pool_priorities(void);\nextern void enable_pool(struct pool *);\nextern void manual_enable_pool(struct pool *);\nextern void disable_pool(struct pool *, enum pool_enable);\nextern void switch_pools(struct pool *selected);\nextern void remove_pool(struct pool *pool);\nextern void write_config(FILE *fcfg);\nextern void zero_bestshare(void);\nextern void zero_stats(void);\nextern void default_save_file(char *filename);\nextern bool _log_curses_only(int prio, const char *datetime, const char *str);\nextern void clear_logwin(void);\nextern void logwin_update(void);\nextern bool pool_tclear(struct pool *pool, bool *var);\nextern bool pool_may_redirect_to(struct pool *, const char *uri);\nextern void pool_check_coinbase(struct pool *, const uint8_t *cbtxn, size_t cbtxnsz);\nextern struct thread_q *tq_new(void);\nextern void tq_free(struct thread_q *tq);\nextern bool tq_push(struct thread_q *tq, void *data);\nextern void *tq_pop(struct thread_q *);\nextern void tq_freeze(struct thread_q *tq);\nextern void tq_thaw(struct thread_q *tq);\nextern bool successful_connect;\nextern void adl(void);\nextern void tmpl_decref(struct bfg_tmpl_ref *);\nextern void clean_work(struct work *work);\nextern void free_work(struct work *work);\nextern void __copy_work(struct work *work, const struct work *base_work);\nextern struct work *copy_work_noffset(const struct work *base_work, int noffset);\n#define copy_work(work_in) copy_work_noffset(work_in, 0)\nextern double share_diff(const struct work *);\nextern const char *bfg_workpadding_bin;\nextern void set_simple_ntime_roll_limit(struct ntime_roll_limits *, uint32_t ntime_base, int ntime_roll, const struct timeval *tvp_ref);\nextern void work_set_simple_ntime_roll_limit(struct work *, int ntime_roll, const struct timeval *tvp_ref);\nextern int work_ntime_range(struct work *, const struct timeval *tvp_earliest, const struct timeval *tvp_latest, int desired_roll);\n\nstatic inline\nstruct mining_algorithm *work_mining_algorithm(const struct work * const work)\n{\n\tconst struct pool * const pool = work->pool;\n\tconst struct mining_goal_info * const goal = pool->goal;\n\tstruct mining_algorithm * const malgo = goal->malgo;\n\treturn malgo;\n}\n\nextern void work_hash(struct work *);\n\n#define NTIME_DATA_OFFSET  0x44\n\nstatic inline\nuint32_t work_get_ntime(const struct work * const work)\n{\n\treturn upk_u32be(work->data, 0x44);\n}\n\nstatic inline\nvoid work_set_ntime(struct work * const work, const uint32_t ntime)\n{\n\tpk_u32be(work->data, 0x44, ntime);\n}\n\n\nextern char *devpath_to_devid(const char *);\nextern struct thr_info *get_thread(int thr_id);\nextern struct cgpu_info *get_devices(int id);\nextern int create_new_cgpus(void (*addfunc)(void*), void *arg);\nextern int scan_serial(const char *);\nextern bool check_coinbase(const uint8_t *, size_t, const struct coinbase_param *cb_param);\n\nenum api_data_type {\n\tAPI_ESCAPE,\n\tAPI_STRING,\n\tAPI_CONST,\n\tAPI_UINT8,\n\tAPI_INT16,\n\tAPI_UINT16,\n\tAPI_INT,\n\tAPI_UINT,\n\tAPI_UINT32,\n\tAPI_UINT64,\n\tAPI_DOUBLE,\n\tAPI_ELAPSED,\n\tAPI_BOOL,\n\tAPI_TIMEVAL,\n\tAPI_TIME,\n\tAPI_MHS,\n\tAPI_MHTOTAL,\n\tAPI_TEMP,\n\tAPI_UTILITY,\n\tAPI_FREQ,\n\tAPI_VOLTS,\n\tAPI_HS,\n\tAPI_DIFF,\n\tAPI_JSON,\n\tAPI_PERCENT\n};\n\nstruct api_data {\n\tenum api_data_type type;\n\tchar *name;\n\tconst void *data;\n\tbool data_was_malloc;\n\tstruct api_data *prev;\n\tstruct api_data *next;\n};\n\nextern struct api_data *api_add_escape(struct api_data *root, const char *name, const char *data, bool copy_data);\nextern struct api_data *api_add_string(struct api_data *root, const char *name, const char *data, bool copy_data);\nextern struct api_data *api_add_const(struct api_data *root, const char *name, const char *data, bool copy_data);\nextern struct api_data *api_add_uint8(struct api_data *root, const char *name, const uint8_t *data, bool copy_data);\nextern struct api_data *api_add_int16(struct api_data *root, const char *name, const uint16_t *data, bool copy_data);\nextern struct api_data *api_add_uint16(struct api_data *root, const char *name, const uint16_t *data, bool copy_data);\nextern struct api_data *api_add_int(struct api_data *root, const char *name, const int *data, bool copy_data);\nextern struct api_data *api_add_uint(struct api_data *root, const char *name, const unsigned int *data, bool copy_data);\nextern struct api_data *api_add_uint32(struct api_data *root, const char *name, const uint32_t *data, bool copy_data);\nextern struct api_data *api_add_uint64(struct api_data *root, const char *name, const uint64_t *data, bool copy_data);\nextern struct api_data *api_add_double(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_elapsed(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_bool(struct api_data *root, const char *name, const bool *data, bool copy_data);\nextern struct api_data *api_add_timeval(struct api_data *root, const char *name, const struct timeval *data, bool copy_data);\nextern struct api_data *api_add_time(struct api_data *root, const char *name, const time_t *data, bool copy_data);\nextern struct api_data *api_add_mhs(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_mhstotal(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_temp(struct api_data *root, const char *name, const float *data, bool copy_data);\nextern struct api_data *api_add_utility(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_freq(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_volts(struct api_data *root, const char *name, const float *data, bool copy_data);\nextern struct api_data *api_add_hs(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_diff(struct api_data *root, const char *name, const double *data, bool copy_data);\nextern struct api_data *api_add_json(struct api_data *root, const char *name, json_t *data, bool copy_data);\nextern struct api_data *api_add_percent(struct api_data *root, const char *name, const double *data, bool copy_data);\n\n#endif /* __MINER_H__ */\n"
        },
        {
          "name": "miner.php",
          "type": "blob",
          "size": 68.6748046875,
          "content": "<?php\nsession_start();\ndate_default_timezone_set(@date_default_timezone_get());\n#\nglobal $doctype, $title, $miner, $port, $readonly, $notify;\nglobal $rigport, $rigs, $rignames, $rigbuttons;\nglobal $mcast, $mcastexpect, $mcastaddr, $mcastport, $mcastcode;\nglobal $mcastlistport, $mcasttimeout, $mcastretries, $allowgen;\nglobal $rigipsecurity, $rigtotals, $forcerigtotals;\nglobal $socksndtimeoutsec, $sockrcvtimeoutsec;\nglobal $checklastshare, $poolinputs, $hidefields;\nglobal $ignorerefresh, $changerefresh, $autorefresh;\nglobal $allowcustompages, $customsummarypages;\nglobal $miner_font_family, $miner_font_size;\nglobal $bad_font_family, $bad_font_size;\nglobal $colouroverride, $placebuttons, $userlist;\nglobal $per_proc;\n#\n$doctype = \"<!DOCTYPE html>\\n\";\n#\n# See README.RPC for more details of these variables and how\n# to configure miner.php\n#\n# Web page title\n$title = 'Mine';\n#\n# Set $readonly to true to force miner.php to be readonly\n# Set $readonly to false then it will check BFGMiner 'privileged'\n$readonly = false;\n#\n# Set $userlist to null to allow anyone access or read README.RPC\n$userlist = null;\n#\n# Set $per_proc to false to display only full device summaries\n$per_proc = true;\n#\n# Set $notify to false to NOT attempt to display the notify command\n# Set $notify to true to attempt to display the notify command\n$notify = true;\n#\n# Set $checklastshare to true to do the following checks:\n# If a device's last share is 12x expected ago then display as an error\n# If a device's last share is 8x expected ago then display as a warning\n# If either of the above is true, also display the whole line highlighted\n# This assumes shares are 1 difficulty shares\n$checklastshare = true;\n#\n# Set $poolinputs to true to show the input fields for adding a pool\n# and changing the pool priorities\n# N.B. also if $readonly is true, it will not display the fields\n$poolinputs = false;\n#\n# Default port to use if any $rigs entries don't specify the port number\n$rigport = 4028;\n#\n# Set $rigs to an array of your BFGMiner rigs that are running\n#  format: 'IP' or 'Host' or 'IP:Port' or 'Host:Port' or 'Host:Port:Name'\n$rigs = array('127.0.0.1:4028');\n#\n# Set $rignames to false, or one of 'ip' or 'ipx'\n#  this says what to use if $rigs doesn't have a 'name'\n$rignames = false;\n#\n# Set $rigbuttons to false to display a link rather than a button\n$rigbuttons = true;\n#\n# Set $mcast to true to look for your rigs and ignore $rigs\n$mcast = false;\n#\n# Set $mcastexpect to at least how many rigs you expect it to find\n$mcastexpect = 0;\n#\n# API Multicast address all cgminers are listening on\n$mcastaddr = '224.0.0.75';\n#\n# API Multicast UDP port all cgminers are listening on\n$mcastport = 4028;\n#\n# The code all cgminers expect in the Multicast message sent\n$mcastcode = 'FTW';\n#\n# UDP port cgminers are to reply on (by request)\n$mcastlistport = 4027;\n#\n# Set $mcasttimeout to the number of seconds (floating point)\n# to wait for replies to the Multicast message\n$mcasttimeout = 1.5;\n#\n# Set $mcastretries to the number of times to retry the multicast\n$mcastretries = 0;\n#\n# Set $allowgen to true to allow customsummarypages to use 'gen' \n# false means ignore any 'gen' options\n$allowgen = false;\n#\n# Set $rigipsecurity to false to show the IP/Port of the rig\n# in the socket error messages and also show the full socket message\n$rigipsecurity = true;\n#\n# Set $rigtotals to true to display totals on the single rig page\n# 'false' means no totals (and ignores $forcerigtotals)\n# You can force it to always show rig totals when there is only\n# one line by setting $forcerigtotals = true;\n$rigtotals = true;\n$forcerigtotals = false;\n#\n# These should be OK for most cases\n$socksndtimeoutsec = 10;\n$sockrcvtimeoutsec = 40;\n#\n# List of fields NOT to be displayed\n# This example would hide the slightly more sensitive pool information\n#$hidefields = array('POOL.URL' => 1, 'POOL.User' => 1);\n$hidefields = array();\n#\n# Auto-refresh of the page (in seconds) - integers only\n# $ignorerefresh = true/false always ignore refresh parameters\n# $changerefresh = true/false show buttons to change the value\n# $autorefresh = default value, 0 means dont auto-refresh\n$ignorerefresh = false;\n$changerefresh = true;\n$autorefresh = 0;\n#\n# Should we allow custom pages?\n# (or just completely ignore them and don't display the buttons)\n$allowcustompages = true;\n#\n# OK this is a bit more complex item: Custom Summary Pages\n# As mentioned above, see README.RPC\n# see the example below (if there is no matching data, no total will show)\n$mobilepage = array(\n 'DATE' => null,\n 'RIGS' => null,\n 'SUMMARY' => array('Elapsed', 'MHS av', 'Found Blocks=Blks', 'Accepted', 'Rejected=Rej', 'Utility'),\n 'DEVS+NOTIFY' => array('DEVS.Name=Name', 'DEVS.ID=ID', 'DEVS.ProcID=Proc',\n\t\t\t'DEVS.Status=Status', 'DEVS.Temperature=Temp',\n\t\t\t'DEVS.MHS av=MHS av', 'DEVS.Accepted=Accept', 'DEVS.Rejected=Rej',\n\t\t\t'DEVS.Utility=Utility', 'NOTIFY.Last Not Well=Not Well'),\n 'POOL' => array('POOL', 'Status', 'Accepted', 'Rejected=Rej', 'Last Share Time'));\n$mobilesum = array(\n 'SUMMARY' => array('MHS av', 'Found Blocks', 'Accepted', 'Rejected', 'Utility'),\n 'DEVS+NOTIFY' => array('DEVS.MHS av', 'DEVS.Accepted', 'DEVS.Rejected', 'DEVS.Utility'),\n 'POOL' => array('Accepted', 'Rejected'));\n#\n$statspage = array(\n 'DATE' => null,\n 'RIGS' => null,\n 'SUMMARY' => array('Elapsed', 'MHS av', 'Found Blocks=Blks',\n\t\t\t'Accepted', 'Rejected=Rej', 'Utility',\n\t\t\t'Hardware Errors=HW Errs', 'Network Blocks=Net Blks',\n\t\t\t'Work Utility'),\n 'COIN' => array('*'),\n 'STATS' => array('*'));\n#\n$statssum = array(\n 'SUMMARY' => array('MHS av', 'Found Blocks', 'Accepted',\n\t\t\t'Rejected', 'Utility', 'Hardware Errors',\n\t\t\t'Work Utility'));\n#\n$poolspage = array(\n 'DATE' => null,\n 'RIGS' => null,\n 'SUMMARY' => array('Elapsed', 'MHS av', 'Found Blocks=Blks', 'Accepted', 'Rejected=Rej',\n\t\t\t'Utility', 'Hardware Errors=HW Errs', 'Network Blocks=Net Blks'),\n 'POOL+STATS' => array('STATS.ID=ID', 'POOL.URL=URL',\n\t\t\t'POOL.Has Stratum=Stratum', 'POOL.Stratum Active=StrAct',\n\t\t\t'STATS.Net Bytes Sent=NSent',\n\t\t\t'STATS.Net Bytes Recv=NRecv', 'GEN.AvShr=AvShr'));\n#\n$poolssum = array(\n 'SUMMARY' => array('MHS av', 'Found Blocks', 'Accepted',\n\t\t\t'Rejected', 'Utility', 'Hardware Errors'),\n 'POOL+STATS' => array(\n\t\t\t'STATS.Net Bytes Sent',\n\t\t\t'STATS.Net Bytes Recv'));\n#\n$poolsext = array(\n 'POOL+STATS' => array(\n\t'where' => null,\n\t'group' => array('POOL.URL', 'POOL.Has Stratum', 'POOL.Stratum Active'),\n\t'calc' => array(\n\t\t\t'STATS.Net Bytes Sent' => 'sum',\n\t\t\t'STATS.Net Bytes Recv' => 'sum',\n\t\t\t'POOL.Accepted' => 'sum'),\n\t'gen' => array('AvShr' => 'round(POOL.Difficulty Accepted/max(POOL.Accepted,1)*100)/100'),\n\t'having' => array(array('STATS.Bytes Recv', '>', 0)))\n);\n\n#\n# customsummarypages is an array of these Custom Summary Pages\n$customsummarypages = array('Mobile' => array($mobilepage, $mobilesum),\n 'Stats' => array($statspage, $statssum),\n 'Pools' => array($poolspage, $poolssum, $poolsext));\n#\n$here = basename(__FILE__);\n#\nglobal $tablebegin, $tableend, $warnfont, $warnoff, $dfmt;\n#\n$tablebegin = '<tr><td><table border=1 cellpadding=5 cellspacing=0>';\n$tableend = '</table></td></tr>';\n$warnfont = '<font color=red><b>';\n$warnoff = '</b></font>';\n$dfmt = 'H:i:s j-M-Y \\U\\T\\CP';\n#\n$miner_font_family = 'Verdana, Arial, sans-serif, sans';\n$miner_font_size = '13pt';\n#\n$bad_font_family = '\"Times New Roman\", Times, serif';\n$bad_font_size = '18pt';\n#\n# Edit this or redefine it in myminer.php to change the colour scheme\n# See $colourtable below for the list of names\n$colouroverride = array();\n#\n# Where to place the buttons: 'top' 'bot' 'both'\n#  anything else means don't show them - case sensitive\n$placebuttons = 'top';\n#\n# This below allows you to put your own settings into a seperate file\n# so you don't need to update miner.php with your preferred settings\n# every time a new version is released\n# Just create the file 'myminer.php' in the same directory as\n# 'miner.php' - and put your own settings in there\nif (file_exists('myminer.php'))\n include_once('myminer.php');\n#\n# This is the system default that must always contain all necessary\n# colours so it must be a constant\n# You can override these values with $colouroverride\n# The only one missing is $warnfont\n# - which you can override directly anyway\nglobal $colourtable;\n$colourtable = array(\n\t'body bgcolor'\t\t=> '#ecffff',\n\t'td color'\t\t=> 'blue',\n\t'td.two color'\t\t=> 'blue',\n\t'td.two background'\t=> '#ecffff',\n\t'td.h color'\t\t=> 'blue',\n\t'td.h background'\t=> '#c4ffff',\n\t'td.err color'\t\t=> 'black',\n\t'td.err background'\t=> '#ff3050',\n\t'td.bad color'\t\t=> 'black',\n\t'td.bad background'\t=> '#ff3050',\n\t'td.warn color'\t\t=> 'black',\n\t'td.warn background'\t=> '#ffb050',\n\t'td.sta color'\t\t=> 'green',\n\t'td.tot color'\t\t=> 'blue',\n\t'td.tot background'\t=> '#fff8f2',\n\t'td.lst color'\t\t=> 'blue',\n\t'td.lst background'\t=> '#ffffdd',\n\t'td.hi color'\t\t=> 'blue',\n\t'td.hi background'\t=> '#f6ffff',\n\t'td.lo color'\t\t=> 'blue',\n\t'td.lo background'\t=> '#deffff'\n);\n#\n# Don't touch these 2\n$miner = null;\n$port = null;\n#\nglobal $rigips;\n$rigips = array();\n#\n# Ensure it is only ever shown once\nglobal $showndate;\n$showndate = false;\n#\n# For summary page to stop retrying failed rigs\nglobal $rigerror;\n$rigerror = array();\n#\nglobal $rownum;\n$rownum = 0;\n#\n// Login\nglobal $ses;\n$ses = 'rutroh';\n#\nfunction getcss($cssname, $dom = false)\n{\n global $colourtable, $colouroverride;\n\n $css = '';\n foreach ($colourtable as $cssdata => $value)\n {\n\t$cssobj = explode(' ', $cssdata, 2);\n\tif ($cssobj[0] == $cssname)\n\t{\n\t\tif (isset($colouroverride[$cssdata]))\n\t\t\t$value = $colouroverride[$cssdata];\n\n\t\tif ($dom == true)\n\t\t\t$css .= ' '.$cssobj[1].'='.$value;\n\t\telse\n\t\t\t$css .= $cssobj[1].':'.$value.'; ';\n\t}\n }\n return $css;\n}\n#\nfunction getdom($domname)\n{\n return getcss($domname, true);\n}\n#\n# N.B. don't call this before calling htmlhead()\nfunction php_pr($cmd)\n{\n global $here, $autorefresh;\n\n return \"$here?ref=$autorefresh$cmd\";\n}\n#\nfunction htmlhead($mcerr, $checkapi, $rig, $pg = null, $noscript = false)\n{\n global $doctype, $title, $miner_font_family, $miner_font_size;\n global $bad_font_family, $bad_font_size;\n global $error, $readonly, $poolinputs, $here;\n global $ignorerefresh, $autorefresh;\n\n $extraparams = '';\n if ($rig != null && $rig != '')\n\t$extraparams = \"&rig=$rig\";\n else\n\tif ($pg != null && $pg != '')\n\t\t$extraparams = \"&pg=$pg\";\n\n if ($ignorerefresh == true || $autorefresh == 0)\n\t$refreshmeta = '';\n else\n {\n\t$url = \"$here?ref=$autorefresh$extraparams\";\n\t$refreshmeta = \"\\n<meta http-equiv='refresh' content='$autorefresh;url=$url'>\";\n }\n\n if ($readonly === false && $checkapi === true)\n {\n\t$error = null;\n\t$access = api($rig, 'privileged');\n\tif ($error != null\n\t||  !isset($access['STATUS']['STATUS'])\n\t||  $access['STATUS']['STATUS'] != 'S')\n\t\t$readonly = true;\n }\n $miner_font = \"font-family:$miner_font_family; font-size:$miner_font_size;\";\n $bad_font = \"font-family:$bad_font_family; font-size:$bad_font_size;\";\n\n echo \"$doctype<html><head>$refreshmeta\n<title>$title</title>\n<style type='text/css'>\ntd { $miner_font \".getcss('td').\"}\ntd.two { $miner_font \".getcss('td.two').\"}\ntd.h { $miner_font \".getcss('td.h').\"}\ntd.err { $miner_font \".getcss('td.err').\"}\ntd.bad { $bad_font \".getcss('td.bad').\"}\ntd.warn { $miner_font \".getcss('td.warn').\"}\ntd.sta { $miner_font \".getcss('td.sta').\"}\ntd.tot { $miner_font \".getcss('td.tot').\"}\ntd.lst { $miner_font \".getcss('td.lst').\"}\ntd.hi { $miner_font \".getcss('td.hi').\"}\ntd.lo { $miner_font \".getcss('td.lo').\"}\n</style>\n</head><body\".getdom('body').\">\\n\";\nif ($noscript === false)\n{\necho \"<script type='text/javascript'>\nfunction pr(a,m){if(m!=null){if(!confirm(m+'?'))return}window.location='$here?ref=$autorefresh'+a}\\n\";\n\nif ($ignorerefresh == false)\n echo \"function prr(a){if(a){v=document.getElementById('refval').value}else{v=0}window.location='$here?ref='+v+'$extraparams'}\\n\";\n\n if ($readonly === false && $checkapi === true)\n {\necho \"function prc(a,m){pr('&arg='+a,m)}\nfunction prs(a,r){var c=a.substr(3);var z=c.split('|',2);var m=z[0].substr(0,1).toUpperCase()+z[0].substr(1)+' GPU '+z[1];prc(a+'&rig='+r,m)}\nfunction prs2(a,n,r){var v=document.getElementById('gi'+n).value;var c=a.substr(3);var z=c.split('|',2);var m='Set GPU '+z[1]+' '+z[0].substr(0,1).toUpperCase()+z[0].substr(1)+' to '+v;prc(a+','+v+'&rig='+r,m)}\\n\";\n\tif ($poolinputs === true)\n\t\techo \"function cbs(s){var t=s.replace(/\\\\\\\\/g,'\\\\\\\\\\\\\\\\'); return t.replace(/,/g, '\\\\\\\\,')}\\nfunction pla(r){var u=document.getElementById('purl').value;var w=document.getElementById('pwork').value;var p=document.getElementById('ppass').value;pr('&rig='+r+'&arg=addpool|'+cbs(u)+','+cbs(w)+','+cbs(p),'Add Pool '+u)}\\nfunction psp(r){var p=document.getElementById('prio').value;pr('&rig='+r+'&arg=poolpriority|'+p,'Set Pool Priorities to '+p)}\\n\";\n }\necho \"</script>\\n\";\n}\n?>\n<table width=100% height=100% border=0 cellpadding=0 cellspacing=0 summary='Mine'>\n<tr><td align=center valign=top>\n<table border=0 cellpadding=4 cellspacing=0 summary='Mine'>\n<?php\n echo $mcerr;\n}\n#\nfunction minhead($mcerr = '')\n{\n global $readonly;\n $readonly = true;\n htmlhead($mcerr, false, null, null, true);\n}\n#\nglobal $haderror, $error;\n$haderror = false;\n$error = null;\n#\nfunction mcastrigs()\n{\n global $rigs, $mcastexpect, $mcastaddr, $mcastport, $mcastcode;\n global $mcastlistport, $mcasttimeout, $mcastretries, $error;\n\n $listname = \"0.0.0.0\";\n\n $rigs = array();\n\n $rep_soc = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n if ($rep_soc === false || $rep_soc == null)\n {\n\t$msg = \"ERR: mcast listen socket create(UDP) failed\";\n\tif ($rigipsecurity === false)\n\t{\n\t\t$error = socket_strerror(socket_last_error());\n\t\t$error = \"$msg '$error'\\n\";\n\t}\n\telse\n\t\t$error = \"$msg\\n\";\n\n\treturn;\n }\n\n $res = socket_bind($rep_soc, $listname, $mcastlistport);\n if ($res === false)\n {\n\t$msg1 = \"ERR: mcast listen socket bind(\";\n\t$msg2 = \") failed\";\n\tif ($rigipsecurity === false)\n\t{\n\t\t$error = socket_strerror(socket_last_error());\n\t\t$error = \"$msg1$listname,$mcastlistport$msg2 '$error'\\n\";\n\t}\n\telse\n\t\t$error = \"$msg1$msg2\\n\";\n\n\tsocket_close($rep_soc);\n\treturn;\n }\n\n $retries = $mcastretries;\n $doretry = ($retries > 0);\n do\n {\n\t$mcast_soc = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);\n\tif ($mcast_soc === false || $mcast_soc == null)\n\t{\n\t\t$msg = \"ERR: mcast send socket create(UDP) failed\";\n\t\tif ($rigipsecurity === false)\n\t\t{\n\t\t\t$error = socket_strerror(socket_last_error());\n\t\t\t$error = \"$msg '$error'\\n\";\n\t\t}\n\t\telse\n\t\t\t$error = \"$msg\\n\";\n\n\t\tsocket_close($rep_soc);\n\t\treturn;\n\t}\n\n\t$buf = \"cgminer-$mcastcode-$mcastlistport\";\n\tsocket_sendto($mcast_soc, $buf, strlen($buf), 0, $mcastaddr, $mcastport);\n\tsocket_close($mcast_soc);\n\n\t$stt = microtime(true);\n\twhile (true)\n\t{\n\t\t$got = @socket_recvfrom($rep_soc, $buf, 32, MSG_DONTWAIT, $ip, $p);\n\t\tif ($got !== false && $got > 0)\n\t\t{\n\t\t\t$ans = explode('-', $buf, 4);\n\t\t\tif (count($ans) >= 3 && $ans[0] == 'cgm' && $ans[1] == 'FTW')\n\t\t\t{\n\t\t\t\t$rp = intval($ans[2]);\n\n\t\t\t\tif (count($ans) > 3)\n\t\t\t\t\t$mdes = str_replace(\"\\0\", '', $ans[3]);\n\t\t\t\telse\n\t\t\t\t\t$mdes = '';\n\n\t\t\t\tif (strlen($mdes) > 0)\n\t\t\t\t\t$rig = \"$ip:$rp:$mdes\";\n\t\t\t\telse\n\t\t\t\t\t$rig = \"$ip:$rp\";\n\n\t\t\t\tif (!in_array($rig, $rigs))\n\t\t\t\t\t$rigs[] = $rig;\n\t\t\t}\n\t\t}\n\t\tif ((microtime(true) - $stt) >= $mcasttimeout)\n\t\t\tbreak;\n\n\t\tusleep(100000);\n\t}\n\n\tif ($mcastexpect > 0 && count($rigs) >= $mcastexpect)\n\t\t$doretry = false;\n\n } while ($doretry && --$retries > 0);\n\n socket_close($rep_soc);\n}\n#\nfunction getrigs()\n{\n global $rigs;\n\n mcastrigs();\n\n sort($rigs);\n}\n#\nfunction getsock($rig, $addr, $port)\n{\n global $rigport, $rigips, $rignames, $rigipsecurity;\n global $haderror, $error, $socksndtimeoutsec, $sockrcvtimeoutsec;\n\n $port = trim($port);\n if (strlen($port) == 0)\n\t$port = $rigport;\n $error = null;\n $socket = null;\n $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n if ($socket === false || $socket === null)\n {\n\t$haderror = true;\n\tif ($rigipsecurity === false)\n\t{\n\t\t$error = socket_strerror(socket_last_error());\n\t\t$msg = \"socket create(TCP) failed\";\n\t\t$error = \"ERR: $msg '$error'\\n\";\n\t}\n\telse\n\t\t$error = \"ERR: socket create(TCP) failed\\n\";\n\n\treturn null;\n }\n\n // Ignore if this fails since the socket connect may work anyway\n //  and nothing is gained by aborting if the option cannot be set\n //  since we don't know in advance if it can connect\n socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, array('sec' => $socksndtimeoutsec, 'usec' => 0));\n socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, array('sec' => $sockrcvtimeoutsec, 'usec' => 0));\n\n $res = socket_connect($socket, $addr, $port);\n if ($res === false)\n {\n\t$haderror = true;\n\tif ($rigipsecurity === false)\n\t{\n\t\t$error = socket_strerror(socket_last_error());\n\t\t$msg = \"socket connect($addr,$port) failed\";\n\t\t$error = \"ERR: $msg '$error'\\n\";\n\t}\n\telse\n\t\t$error = \"ERR: socket connect($rig) failed\\n\";\n\n\tsocket_close($socket);\n\treturn null;\n }\n if ($rignames !== false && !isset($rigips[$addr]))\n\tif (socket_getpeername($socket, $ip) == true)\n\t\t$rigips[$addr] = $ip;\n return $socket;\n}\n#\nfunction readsockline($socket)\n{\n $line = '';\n while (true)\n {\n\t$byte = socket_read($socket, 1);\n\tif ($byte === false || $byte === '')\n\t\tbreak;\n\tif ($byte === \"\\0\")\n\t\tbreak;\n\t$line .= $byte;\n }\n return $line;\n}\n#\nfunction api_convert_escape($str)\n{\n $res = '';\n $len = strlen($str);\n for ($i = 0; $i < $len; $i++)\n {\n\t$ch = substr($str, $i, 1);\n\tif ($ch != '\\\\' || $i == ($len-1))\n\t\t$res .= $ch;\n\telse\n\t{\n\t\t$i++;\n\t\t$ch = substr($str, $i, 1);\n\t\tswitch ($ch)\n\t\t{\n\t\tcase '|':\n\t\t\t$res .= \"\\1\";\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t$res .= \"\\2\";\n\t\t\tbreak;\n\t\tcase '=':\n\t\t\t$res .= \"\\3\";\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\t$res .= \"\\4\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$res .= $ch;\n\t\t}\n\t}\n }\n return $res;\n}\n#\nfunction revert($str)\n{\n return str_replace(array(\"\\1\", \"\\2\", \"\\3\", \"\\4\"), array(\"|\", \"\\\\\", \"=\", \",\"), $str);\n}\n#\nfunction api($rig, $cmd)\n{\n global $haderror, $error;\n global $miner, $port, $hidefields;\n global $per_proc;\n\n if ($per_proc)\n {\n\t$cmd = preg_replace('/^devs\\b/', 'procs', $cmd);\n\t$cmd = preg_replace('/^pga/', 'proc', $cmd);\n }\n\n $socket = getsock($rig, $miner, $port);\n if ($socket != null)\n {\n\tsocket_write($socket, $cmd, strlen($cmd));\n\t$line = readsockline($socket);\n\tsocket_close($socket);\n\n\tif (strlen($line) == 0)\n\t{\n\t\t$haderror = true;\n\t\t$error = \"WARN: '$cmd' returned nothing\\n\";\n\t\treturn $line;\n\t}\n\n#\tprint \"$cmd returned '$line'\\n\";\n\n\t$line = api_convert_escape($line);\n\n\t$data = array();\n\n\t$objs = explode('|', $line);\n\tforeach ($objs as $obj)\n\t{\n\t\tif (strlen($obj) > 0)\n\t\t{\n\t\t\t$items = explode(',', $obj);\n\t\t\t$item = $items[0];\n\t\t\t$id = explode('=', $items[0], 2);\n\t\t\tif (count($id) == 1 or !ctype_digit($id[1]))\n\t\t\t\t$name = $id[0];\n\t\t\telse\n\t\t\t\t$name = $id[0].$id[1];\n\n\t\t\tif (strlen($name) == 0)\n\t\t\t\t$name = 'null';\n\n\t\t\t$sectionname = preg_replace('/\\d/', '', $name);\n\n\t\t\tif (isset($data[$name]))\n\t\t\t{\n\t\t\t\t$num = 1;\n\t\t\t\twhile (isset($data[$name.$num]))\n\t\t\t\t\t$num++;\n\t\t\t\t$name .= $num;\n\t\t\t}\n\n\t\t\t$counter = 0;\n\t\t\tforeach ($items as $item)\n\t\t\t{\n\t\t\t\t$id = explode('=', $item, 2);\n\n\t\t\t\tif (isset($hidefields[$sectionname.'.'.$id[0]]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (count($id) == 2)\n\t\t\t\t\t$data[$name][$id[0]] = revert($id[1]);\n\t\t\t\telse\n\t\t\t\t\t$data[$name][$counter] = $id[0];\n\n\t\t\t\t$counter++;\n\t\t\t}\n\t\t}\n\t}\n\treturn $data;\n }\n return null;\n}\n#\nfunction getparam($name, $both = false)\n{\n $a = null;\n if (isset($_POST[$name]))\n\t$a = $_POST[$name];\n\n if (($both === true) and ($a === null))\n {\n\tif (isset($_GET[$name]))\n\t\t$a = $_GET[$name];\n }\n\n if ($a == '' || $a == null)\n\treturn null;\n\n // limit to 1K just to be safe\n return substr($a, 0, 1024);\n}\n#\nfunction newtable()\n{\n global $tablebegin, $rownum;\n echo $tablebegin;\n $rownum = 0;\n}\n#\nfunction newrow()\n{\n echo '<tr>';\n}\n#\nfunction othrow($row)\n{\n return \"<tr>$row</tr>\";\n}\n#\nfunction otherrow($row)\n{\n echo othrow($row);\n}\n#\nfunction endrow()\n{\n global $rownum;\n echo '</tr>';\n $rownum++;\n}\n#\nfunction endtable()\n{\n global $tableend;\n echo $tableend;\n}\n#\nfunction classlastshare($when, $alldata, $warnclass, $errorclass)\n{\n global $checklastshare;\n\n if ($checklastshare === false)\n\treturn '';\n\n if ($when == 0)\n\treturn '';\n\n if (!isset($alldata['MHS av']))\n\treturn '';\n\n if ($alldata['MHS av'] == 0)\n\treturn '';\n\n if (!isset($alldata['Last Share Time']))\n\treturn '';\n\n if (!isset($alldata['Last Share Difficulty']))\n\treturn '';\n\n $expected = pow(2, 32) / ($alldata['MHS av'] * pow(10, 6));\n\n // If the share difficulty changes while waiting on a share,\n // this calculation will of course be incorrect\n $expected *= $alldata['Last Share Difficulty'];\n\n $howlong = $when - $alldata['Last Share Time'];\n if ($howlong < 1)\n\t$howlong = 1;\n\n if ($howlong > ($expected * 12))\n\treturn $errorclass;\n\n if ($howlong > ($expected * 8))\n\treturn $warnclass;\n\n return '';\n}\n#\nfunction endzero($num)\n{\n $rep = preg_replace('/0*$/', '', $num);\n if ($rep === '')\n\t$rep = '0';\n return $rep;\n}\n#\nfunction fmt($section, $name, $value, $when, $alldata)\n{\n global $dfmt, $rownum;\n\n if ($alldata == null)\n\t$alldata = array();\n\n $errorclass = ' class=err';\n $warnclass = ' class=warn';\n $lstclass = ' class=lst';\n $hiclass = ' class=hi';\n $loclass = ' class=lo';\n $c2class = ' class=two';\n $totclass = ' class=tot';\n $b = '&nbsp;';\n\n $ret = $value;\n $class = '';\n\n $nams = explode('.', $name);\n if (count($nams) > 1)\n\t$name = $nams[count($nams)-1];\n\n if ($value === null)\n\t$ret = $b;\n else\n\tswitch ($section.'.'.$name)\n\t{\n\tcase 'GPU.Last Share Time':\n\tcase 'PGA.Last Share Time':\n\tcase 'DEVS.Last Share Time':\n\t\tif ($value == 0\n\t\t||  (isset($alldata['Last Share Pool']) && $alldata['Last Share Pool'] == -1))\n\t\t{\n\t\t\t$ret = 'Never';\n\t\t\t$class = $warnclass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$ret = date('H:i:s', $value);\n\t\t\t$class = classlastshare($when, $alldata, $warnclass, $errorclass);\n\t\t}\n\t\tbreak;\n\tcase 'GPU.Last Valid Work':\n\tcase 'PGA.Last Valid Work':\n\tcase 'DEVS.Last Valid Work':\n\t\tif ($value == 0)\n\t\t\t$ret = 'Never';\n\t\telse\n\t\t\t$ret = ($value - $when) . 's';\n\t\tbreak;\n\tcase 'POOL.Last Share Time':\n\t\tif ($value == 0)\n\t\t\t$ret = 'Never';\n\t\telse\n\t\t\t$ret = date('H:i:s d-M', $value);\n\t\tbreak;\n\tcase 'GPU.Last Share Pool':\n\tcase 'PGA.Last Share Pool':\n\tcase 'DEVS.Last Share Pool':\n\t\tif ($value == -1)\n\t\t{\n\t\t\t$ret = 'None';\n\t\t\t$class = $warnclass;\n\t\t}\n\t\tbreak;\n\tcase 'SUMMARY.Elapsed':\n\tcase 'STATS.Elapsed':\n\t\t$s = $value % 60;\n\t\t$value -= $s;\n\t\t$value /= 60;\n\t\tif ($value == 0)\n\t\t\t$ret = $s.'s';\n\t\telse\n\t\t{\n\t\t\t$m = $value % 60;\n\t\t\t$value -= $m;\n\t\t\t$value /= 60;\n\t\t\tif ($value == 0)\n\t\t\t\t$ret = sprintf(\"%dm$b%02ds\", $m, $s);\n\t\t\telse\n\t\t\t{\n\t\t\t\t$h = $value % 24;\n\t\t\t\t$value -= $h;\n\t\t\t\t$value /= 24;\n\t\t\t\tif ($value == 0)\n\t\t\t\t\t$ret = sprintf(\"%dh$b%02dm$b%02ds\", $h, $m, $s);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ($value == 1)\n\t\t\t\t\t\t$days = '';\n\t\t\t\t\telse\n\t\t\t\t\t\t$days = 's';\n\t\n\t\t\t\t\t$ret = sprintf(\"%dday$days$b%02dh$b%02dm$b%02ds\", $value, $h, $m, $s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'NOTIFY.Last Well':\n\t\tif ($value == '0')\n\t\t{\n\t\t\t$ret = 'Never';\n\t\t\t$class = $warnclass;\n\t\t}\n\t\telse\n\t\t\t$ret = date('H:i:s', $value);\n\t\tbreak;\n\tcase 'NOTIFY.Last Not Well':\n\t\tif ($value == '0')\n\t\t\t$ret = 'Never';\n\t\telse\n\t\t{\n\t\t\t$ret = date('H:i:s', $value);\n\t\t\t$class = $errorclass;\n\t\t}\n\t\tbreak;\n\tcase 'NOTIFY.Reason Not Well':\n\t\tif ($value != 'None')\n\t\t\t$class = $errorclass;\n\t\tbreak;\n\tcase 'GPU.Utility':\n\tcase 'PGA.Utility':\n\tcase 'DEVS.Utility':\n\tcase 'SUMMARY.Utility':\n\tcase 'total.Utility':\n\t\t$ret = $value.'/m';\n\t\tif ($value == 0)\n\t\t\t$class = $errorclass;\n\t\telse\n\t\t\tif (isset($alldata['Difficulty Accepted'])\n\t\t\t&&  isset($alldata['Accepted'])\n\t\t\t&&  isset($alldata['MHS av'])\n\t\t\t&&  ($alldata['Difficulty Accepted'] > 0)\n\t\t\t&&  ($alldata['Accepted'] > 0))\n\t\t\t{\n\t\t\t\t$expected = 60 * $alldata['MHS av'] * (pow(10, 6) / pow(2, 32));\n\t\t\t\tif ($expected == 0)\n\t\t\t\t\t$expected = 0.000001; // 1 H/s\n\n\t\t\t\t$da = $alldata['Difficulty Accepted'];\n\t\t\t\t$a = $alldata['Accepted'];\n\t\t\t\t$expected /= ($da / $a);\n\n\t\t\t\t$ratio = $value / $expected;\n\t\t\t\tif ($ratio < 0.9)\n\t\t\t\t\t$class = $loclass;\n\t\t\t\telse\n\t\t\t\t\tif ($ratio > 1.1)\n\t\t\t\t\t\t$class = $hiclass;\n\t\t\t}\n\t\tbreak;\n\tcase 'PGA.Temperature':\n\tcase 'GPU.Temperature':\n\tcase 'DEVS.Temperature':\n\t\t$ret = $value.'&deg;C';\n\t\tif (!isset($alldata['GPU']))\n\t\t{\n\t\t\tif ($value == 0)\n\t\t\t\t$ret = '&nbsp;';\n\t\t\tbreak;\n\t\t}\n\tcase 'GPU.GPU Clock':\n\tcase 'DEVS.GPU Clock':\n\tcase 'GPU.Memory Clock':\n\tcase 'DEVS.Memory Clock':\n\tcase 'GPU.GPU Voltage':\n\tcase 'DEVS.GPU Voltage':\n\tcase 'GPU.GPU Activity':\n\tcase 'DEVS.GPU Activity':\n\t\tif ($value == 0)\n\t\t\t$class = $warnclass;\n\t\tbreak;\n\tcase 'GPU.Fan Percent':\n\tcase 'DEVS.Fan Percent':\n\t\tif ($value == 0)\n\t\t\t$class = $warnclass;\n\t\telse\n\t\t{\n\t\t\tif ($value == 100)\n\t\t\t\t$class = $errorclass;\n\t\t\telse\n\t\t\t\tif ($value > 85)\n\t\t\t\t\t$class = $warnclass;\n\t\t}\n\t\tbreak;\n\tcase 'GPU.Fan Speed':\n\tcase 'DEVS.Fan Speed':\n\t\tif ($value == 0)\n\t\t\t$class = $warnclass;\n\t\telse\n\t\t\tif (isset($alldata['Fan Percent']))\n\t\t\t{\n\t\t\t\t$test = $alldata['Fan Percent'];\n\t\t\t\tif ($test == 100)\n\t\t\t\t\t$class = $errorclass;\n\t\t\t\telse\n\t\t\t\t\tif ($test > 85)\n\t\t\t\t\t\t$class = $warnclass;\n\t\t\t}\n\t\tbreak;\n\tcase 'GPU.MHS av':\n\tcase 'PGA.MHS av':\n\tcase 'DEVS.MHS av':\n\tcase 'SUMMARY.MHS av':\n\tcase 'total.MHS av':\n\t\t$parts = explode('.', $value, 2);\n\t\tif (count($parts) == 1)\n\t\t\t$dec = '';\n\t\telse\n\t\t\t$dec = '.'.$parts[1];\n\t\t$ret = number_format((float)$parts[0]).$dec;\n\n\t\tif ($value == 0)\n\t\t\t$class = $errorclass;\n\t\telse\n\t\t\tif (isset($alldata['Difficulty Accepted'])\n\t\t\t&&  isset($alldata['Accepted'])\n\t\t\t&&  isset($alldata['Utility'])\n\t\t\t&&  ($alldata['Difficulty Accepted'] > 0)\n\t\t\t&&  ($alldata['Accepted'] > 0))\n\t\t\t{\n\t\t\t\t$expected = 60 * $value * (pow(10, 6) / pow(2, 32));\n\t\t\t\tif ($expected == 0)\n\t\t\t\t\t$expected = 0.000001; // 1 H/s\n\n\t\t\t\t$da = $alldata['Difficulty Accepted'];\n\t\t\t\t$a = $alldata['Accepted'];\n\t\t\t\t$expected /= ($da / $a);\n\n\t\t\t\t$ratio = $alldata['Utility'] / $expected;\n\t\t\t\tif ($ratio < 0.9)\n\t\t\t\t\t$class = $hiclass;\n\t\t\t\telse\n\t\t\t\t\tif ($ratio > 1.1)\n\t\t\t\t\t\t$class = $loclass;\n\t\t\t}\n\t\tbreak;\n\tcase 'GPU.Total MH':\n\tcase 'PGA.Total MH':\n\tcase 'DEVS.Total MH':\n\tcase 'SUMMARY.Total MH':\n\tcase 'total.Total MH':\n\tcase 'SUMMARY.Getworks':\n\tcase 'POOL.Getworks':\n\tcase 'total.Getworks':\n\tcase 'GPU.Accepted':\n\tcase 'PGA.Accepted':\n\tcase 'DEVS.Accepted':\n\tcase 'SUMMARY.Accepted':\n\tcase 'POOL.Accepted':\n\tcase 'total.Accepted':\n\tcase 'GPU.Rejected':\n\tcase 'PGA.Rejected':\n\tcase 'DEVS.Rejected':\n\tcase 'SUMMARY.Rejected':\n\tcase 'POOL.Rejected':\n\tcase 'total.Rejected':\n\tcase 'SUMMARY.Local Work':\n\tcase 'total.Local Work':\n\tcase 'SUMMARY.Discarded':\n\tcase 'POOL.Discarded':\n\tcase 'total.Discarded':\n\tcase 'POOL.Diff1 Shares':\n\tcase 'total.Diff1 Shares':\n\tcase 'GPU.Diff1 Work':\n\tcase 'PGA.Diff1 Work':\n\tcase 'total.Diff1 Work':\n\tcase 'STATS.Times Sent':\n\tcase 'STATS.Bytes Sent':\n\tcase 'STATS.Net Bytes Sent':\n\tcase 'STATS.Times Recv':\n\tcase 'STATS.Bytes Recv':\n\tcase 'STATS.Net Bytes Recv':\n\tcase 'total.Times Sent':\n\tcase 'total.Bytes Sent':\n\tcase 'total.Net Bytes Sent':\n\tcase 'total.Times Recv':\n\tcase 'total.Bytes Recv':\n\tcase 'total.Net Bytes Recv':\n\t\t$parts = explode('.', $value, 2);\n\t\tif (count($parts) == 1)\n\t\t\t$dec = '';\n\t\telse\n\t\t\t$dec = '.'.$parts[1];\n\t\t$ret = number_format((float)$parts[0]).$dec;\n\t\tbreak;\n\tcase 'STATS.Hs':\n\tcase 'STATS.W':\n\tcase 'STATS.history_time':\n\tcase 'STATS.Pool Wait':\n\tcase 'STATS.Pool Max':\n\tcase 'STATS.Pool Min':\n\tcase 'STATS.Pool Av':\n\tcase 'STATS.Min Diff':\n\tcase 'STATS.Max Diff':\n\tcase 'STATS.Work Diff':\n\t\t$parts = explode('.', $value, 2);\n\t\tif (count($parts) == 1)\n\t\t\t$dec = '';\n\t\telse\n\t\t\t$dec = '.'.endzero($parts[1]);\n\t\t$ret = number_format((float)$parts[0]).$dec;\n\t\tbreak;\n\tcase 'GPU.Status':\n\tcase 'PGA.Status':\n\tcase 'DEVS.Status':\n\tcase 'POOL.Status':\n\t\tif ($value != 'Alive')\n\t\t\t$class = $errorclass;\n\t\tbreak;\n\tcase 'GPU.Enabled':\n\tcase 'PGA.Enabled':\n\tcase 'DEVS.Enabled':\n\t\tif ($value != 'Y')\n\t\t\t$class = $warnclass;\n\t\tbreak;\n\tcase 'STATUS.When':\n\tcase 'COIN.Current Block Time':\n\t\t$ret = date($dfmt, $value);\n\t\tbreak;\n\tcase 'BUTTON.Rig':\n\tcase 'BUTTON.Pool':\n\tcase 'BUTTON.GPU':\n\t\t$ret = $value;\n\t\tbreak;\n\tcase 'SUMMARY.Difficulty Accepted':\n\tcase 'GPU.Difficulty Accepted':\n\tcase 'PGA.Difficulty Accepted':\n\tcase 'DEVS.Difficulty Accepted':\n\tcase 'POOL.Difficulty Accepted':\n\tcase 'total.Difficulty Accepted':\n\tcase 'SUMMARY.Difficulty Rejected':\n\tcase 'GPU.Difficulty Rejected':\n\tcase 'PGA.Difficulty Rejected':\n\tcase 'DEVS.Difficulty Rejected':\n\tcase 'POOL.Difficulty Rejected':\n\tcase 'total.Difficulty Rejected':\n\tcase 'SUMMARY.Difficulty Stale':\n\tcase 'POOL.Difficulty Stale':\n\tcase 'total.Difficulty Stale':\n\tcase 'GPU.Last Share Difficulty':\n\tcase 'PGA.Last Share Difficulty':\n\tcase 'DEVS.Last Share Difficulty':\n\tcase 'POOL.Last Share Difficulty':\n\t\tif ($value != '')\n\t\t\t$ret = number_format((float)$value, 2);\n\t\tbreak;\n\tcase 'DEVS.Device Hardware%':\n\tcase 'DEVS.Device Rejected%':\n\tcase 'PGA.Device Hardware%':\n\tcase 'PGA.Device Rejected%':\n\tcase 'GPU.Device Hardware%':\n\tcase 'GPU.Device Rejected%':\n\tcase 'POOL.Pool Rejected%':\n\tcase 'POOL.Pool Stale%':\n\tcase 'SUMMARY.Device Hardware%':\n\tcase 'SUMMARY.Device Rejected%':\n\tcase 'SUMMARY.Pool Rejected%':\n\tcase 'SUMMARY.Pool Stale%':\n\t\tif ($value != '')\n\t\t\t$ret = number_format((float)$value, 2) . '%';\n\t\tbreak;\n\tcase 'SUMMARY.Best Share':\n\t\tif ($value != '')\n\t\t\t$ret = number_format((float)$value);\n\t\tbreak;\n\t}\n\n if ($section == 'NOTIFY' && substr($name, 0, 1) == '*' && $value != '0')\n\t$class = $errorclass;\n\n if ($class == '' && $section != 'POOL')\n\t$class = classlastshare($when, $alldata, $lstclass, $lstclass);\n\n if ($class == '' && $section == 'total')\n\t$class = $totclass;\n\n if ($class == '' && ($rownum % 2) == 0)\n\t$class = $c2class;\n\n if ($ret === '')\n\t$ret = $b;\n\n return array($ret, $class);\n}\n#\nglobal $poolcmd;\n$poolcmd = array(\t'Switch to'\t=> 'switchpool',\n\t\t\t'Enable'\t=> 'enablepool',\n\t\t\t'Disable'\t=> 'disablepool',\n\t\t\t'Remove'\t=> 'removepool' );\n#\nfunction showhead($cmd, $values, $justnames = false)\n{\n global $poolcmd, $readonly;\n\n newrow();\n\n foreach ($values as $name => $value)\n {\n\tif ($name == '0' or $name == '')\n\t\t$name = '&nbsp;';\n\techo \"<td valign=bottom class=h>$name</td>\";\n }\n\n if ($justnames === false && $cmd == 'pools' && $readonly === false)\n\tforeach ($poolcmd as $name => $pcmd)\n\t\techo \"<td valign=bottom class=h>$name</td>\";\n\n endrow();\n}\n#\nfunction showdatetime()\n{\n global $dfmt;\n\n otherrow('<td class=sta>Date: '.date($dfmt).'</td>');\n}\n#\nglobal $singlerigsum;\n$singlerigsum = array(\n 'devs' => array('MHS av' => 1, 'MHS rolling' => 1, 'Accepted' => 1, 'Rejected' => 1,\n                 'Temperature' => 2,\n\t\t\t'Hardware Errors' => 1, 'Utility' => 1, 'Total MH' => 1),\n 'pools' => array('Getworks' => 1, 'Accepted' => 1, 'Rejected' => 1, 'Discarded' => 1,\n\t\t\t'Stale' => 1, 'Get Failures' => 1, 'Remote Failures' => 1),\n 'notify' => array('*' => 1));\n#\nfunction showtotal($total, $when, $oldvalues)\n{\n global $rigtotals;\n\n list($showvalue, $class) = fmt('total', '', 'Total:', $when, null);\n echo \"<td$class align=right>$showvalue</td>\";\n\n $skipfirst = true;\n foreach ($oldvalues as $name => $value)\n {\n\tif ($skipfirst === true)\n\t{\n\t\t$skipfirst = false;\n\t\tcontinue;\n\t}\n\n\tif (isset($total[$name]))\n\t\t$newvalue = $total[$name];\n\telse\n\t\t$newvalue = '';\n\n\tlist($showvalue, $class) = fmt('total', $name, $newvalue, $when, null);\n\techo \"<td$class\";\n\tif ($rigtotals === true)\n\t\techo ' align=right';\n\techo \">$showvalue</td>\";\n }\n}\n#\nfunction details($cmd, $list, $rig)\n{\n global $dfmt, $poolcmd, $readonly, $showndate;\n global $rownum, $rigtotals, $forcerigtotals, $singlerigsum;\n\n $when = 0;\n\n $stas = array('S' => 'Success', 'W' => 'Warning', 'I' => 'Informational', 'E' => 'Error', 'F' => 'Fatal');\n\n newtable();\n\n if ($showndate === false)\n {\n\tshowdatetime();\n\n\tendtable();\n\tnewtable();\n\n\t$showndate = true;\n }\n\n if (isset($list['STATUS']))\n {\n\tnewrow();\n\techo '<td>Computer: '.$list['STATUS']['Description'].'</td>';\n\tif (isset($list['STATUS']['When']))\n\t{\n\t\techo '<td>When: '.date($dfmt, $list['STATUS']['When']).'</td>';\n\t\t$when = $list['STATUS']['When'];\n\t}\n\t$sta = $list['STATUS']['STATUS'];\n\techo '<td>Status: '.$stas[$sta].'</td>';\n\techo '<td>Message: '.$list['STATUS']['Msg'].'</td>';\n\tendrow();\n }\n\n if ($rigtotals === true && isset($singlerigsum[$cmd]))\n\t$dototal = $singlerigsum[$cmd];\n else\n\t$dototal = array();\n $total = array();\n\n $section = '';\n $oldvalues = null;\n\n // Build a common row column for all entries\n $columns = array();\n $columnsByIndex = array();\n foreach ($list as $item => $values)\n {\n\tif ($item == 'STATUS')\n\t\tcontinue;\n\tif (isset($values['ID']))\n\t{\n\t\t$repr = $values['Name'].$values['ID'];\n\t\tif (isset($values['ProcID']))\n\t\t\t$repr .= join_get_field('ProcID', $values);\n\t\t$list[$item] = $values = array('Device' => $repr) + array_slice($values, 1);\n\t\tunset($values['Name']);\n\t\tunset($values['ID']);\n\t\tunset($values['ProcID']);\n\t}\n\t$namesByIndex = array_keys($values);\n\t$nameCount = count($namesByIndex);\n\tfor ($i = 0; $i < $nameCount; ++$i)\n\t{\n\t\t$name = $namesByIndex[$i];\n\t\tif (isset($columns[$name]))\n\t\t\tcontinue;\n\t\t$value = $values[$name];\n\t\t$before = null;\n\t\tfor ($j = $i + 1; $j < $nameCount; ++$j)\n\t\t{\n\t\t\t$maybebefore = $namesByIndex[$j];\n\t\t\tif (isset($columns[$maybebefore]))\n\t\t\t{\n\t\t\t\t$before = $columns[$maybebefore];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!$before)\n\t\t{\n\t\t\t$columns[$name] = array_push($columnsByIndex, $name) - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tarray_splice($columnsByIndex, $before, 0, $name);\n\t\t$columns[$name] = $before;\n\t\t$columnCount = count($columnsByIndex);\n\t\tfor ($j = $before + 1; $j < $columnCount; ++$j)\n\t\t\t$columns[$columnsByIndex[$j]] = $j;\n\t}\n }\n asort($columns);\n endtable();\n newtable();\n showhead($cmd, $columns);\n\n foreach ($list as $item => $values)\n {\n\tif ($item == 'STATUS')\n\t\tcontinue;\n\n\tnewrow();\n\n\tforeach ($columns as $name => $columnidx)\n\t{\n\t\tif (!isset($values[$name]))\n\t\t{\n\t\t\techo '<td></td>';\n\t\t\tcontinue;\n\t\t}\n\t\t$value = $values[$name];\n\n\t\tlist($showvalue, $class) = fmt($section, $name, $value, $when, $values);\n\t\techo \"<td$class\";\n\t\tif ($rigtotals === true)\n\t\t\techo ' align=right';\n\t\techo \">$showvalue</td>\";\n\n\t\tif (isset($dototal[$name])\n\t\t||  (isset($dototal['*']) and substr($name, 0, 1) == '*'))\n\t\t{\n\t\t\tif (isset($total[$name]))\n\t\t\t{\n\t\t\t\tif (isset($dototal[$name]) && $dototal[$name] == 2)\n\t\t\t\t\t$total[$name] = max($total[$name], $value);\n\t\t\t\telse\n\t\t\t\t\t$total[$name] += $value;\n\t\t\t}\n\t\t\telse\n\t\t\t\t$total[$name] = $value;\n\t\t}\n\t}\n\n\tif ($cmd == 'pools' && $readonly === false)\n\t{\n\t\treset($values);\n\t\t$pool = current($values);\n\t\tforeach ($poolcmd as $name => $pcmd)\n\t\t{\n\t\t\tlist($ignore, $class) = fmt('BUTTON', 'Pool', '', $when, $values);\n\t\t\techo \"<td$class>\";\n\t\t\tif ($pool === false)\n\t\t\t\techo '&nbsp;';\n\t\t\telse\n\t\t\t{\n\t\t\t\techo \"<input type=button value='Pool $pool'\";\n\t\t\t\techo \" onclick='prc(\\\"$pcmd|$pool&rig=$rig\\\",\\\"$name Pool $pool\\\")'>\";\n\t\t\t}\n\t\t\techo '</td>';\n\t\t}\n\t}\n\tendrow();\n\n\t$oldvalues = $values;\n }\n\n if ($oldvalues != null && count($total) > 0\n &&  ($rownum > 2 || $forcerigtotals === true))\n\tshowtotal($total, $when, $columns);\n\n endtable();\n}\n#\nglobal $devs;\n$devs = null;\n#\nfunction gpubuttons($count, $rig)\n{\n global $devs;\n\n $basic = array( 'GPU', 'Enable', 'Disable', 'Restart' );\n\n $options = array(\t'intensity' => 'Intensity',\n\t\t\t'fan' => 'Fan Percent',\n\t\t\t'engine' => 'GPU Clock',\n\t\t\t'mem' => 'Memory Clock',\n\t\t\t'vddc' => 'GPU Voltage' );\n\n newtable();\n newrow();\n\n foreach ($basic as $head)\n\techo \"<td class=h>$head</td>\";\n\n foreach ($options as $name => $des)\n\techo \"<td class=h nowrap>$des</td>\";\n\n $n = 0;\n for ($c = 0; $c < $count; $c++)\n {\n\tendrow();\n\tnewrow();\n\n\tforeach ($basic as $name)\n\t{\n\t\tlist($ignore, $class) = fmt('BUTTON', 'GPU', '', 0, null);\n\t\techo \"<td$class>\";\n\n\t\tif ($name == 'GPU')\n\t\t\techo $c;\n\t\telse\n\t\t{\n\t\t\techo \"<input type=button value='$name $c' onclick='prs(\\\"gpu\";\n\t\t\techo strtolower($name);\n\t\t\techo \"|$c\\\",$rig)'>\";\n\t\t}\n\n\t\techo '</td>';\n\t}\n\n\tforeach ($options as $name => $des)\n\t{\n\t\tlist($ignore, $class) = fmt('BUTTON', 'GPU', '', 0, null);\n\t\techo \"<td$class>\";\n\n\t\tif (!isset($devs[\"GPU$c\"][$des]))\n\t\t\techo '&nbsp;';\n\t\telse\n\t\t{\n\t\t\t$value = $devs[\"GPU$c\"][$des];\n\t\t\techo \"<input type=button value='Set $c:' onclick='prs2(\\\"gpu$name|$c\\\",$n,$rig)'>\";\n\t\t\techo \"<input size=7 type=text name=gi$n value='$value' id=gi$n>\";\n\t\t\t$n++;\n\t\t}\n\n\t\techo '</td>';\n\t}\n\n }\n endrow();\n endtable();\n}\n#\nfunction processgpus($rig)\n{\n global $error;\n global $warnfont, $warnoff;\n\n $gpus = api($rig, 'gpucount');\n\n if ($error != null)\n\totherrow(\"<td>Error getting GPU count: $warnfont$error$warnoff</td>\");\n else\n {\n\tif (!isset($gpus['GPUS']['Count']))\n\t{\n\t\t$rw = '<td>No GPU count returned: '.$warnfont;\n\t\t$rw .= $gpus['STATUS']['STATUS'].' '.$gpus['STATUS']['Msg'];\n\t\t$rw .= $warnoff.'</td>';\n\t\totherrow($rw);\n\t}\n\telse\n\t{\n\t\t$count = $gpus['GPUS']['Count'];\n\t\tif ($count == 0)\n\t\t\totherrow('<td>No GPUs</td>');\n\t\telse\n\t\t\tgpubuttons($count, $rig);\n\t}\n }\n}\n#\nfunction showpoolinputs($rig, $ans)\n{\n global $readonly, $poolinputs;\n\n if ($readonly === true || $poolinputs === false)\n\treturn;\n\n newtable();\n newrow();\n\n $inps = array('Pool URL' => array('purl', 20),\n\t\t'Worker Name' => array('pwork', 10),\n\t\t'Worker Password' => array('ppass', 10));\n $b = '&nbsp;';\n\n echo \"<td align=right class=h> Add a pool: </td><td>\";\n\n foreach ($inps as $text => $name)\n\techo \"$text: <input name='\".$name[0].\"' id='\".$name[0].\"' value='' type=text size=\".$name[1].\"> \";\n\n echo \"</td><td align=middle><input type=button value='Add' onclick='pla($rig)'></td>\";\n\n endrow();\n\n if (count($ans) > 1)\n {\n\tnewrow();\n\n\techo '<td align=right class=h> Set pool priorities: </td>';\n\techo \"<td> Comma list of pool numbers: <input type=text name=prio id=prio size=20>\";\n\techo \"</td><td align=middle><input type=button value='Set' onclick='psp($rig)'></td>\";\n\n\tendrow();\n }\n endtable();\n}\n#\nfunction process($cmds, $rig)\n{\n global $error, $devs;\n global $warnfont, $warnoff;\n\n $count = count($cmds);\n foreach ($cmds as $cmd => $des)\n {\n\t$process = api($rig, $cmd);\n\n\tif ($error != null)\n\t{\n\t\totherrow(\"<td colspan=100>Error getting $des: $warnfont$error$warnoff</td>\");\n\t\tbreak;\n\t}\n\telse\n\t{\n\t\tdetails($cmd, $process, $rig);\n\n\t\tif ($cmd == 'devs')\n\t\t\t$devs = $process;\n\n\t\tif ($cmd == 'pools')\n\t\t\tshowpoolinputs($rig, $process);\n\n\t\t# Not after the last one\n\t\tif (--$count > 0)\n\t\t\totherrow('<td><br><br></td>');\n\t}\n }\n}\n#\nfunction rigname($rig, $rigname)\n{\n global $rigs, $rignames, $rigips;\n\n if (isset($rigs[$rig]))\n {\n\t$parts = explode(':', $rigs[$rig], 3);\n\tif (count($parts) == 3)\n\t\t$rigname = $parts[2];\n\telse\n\t\tif ($rignames !== false)\n\t\t{\n\t\t\tswitch ($rignames)\n\t\t\t{\n\t\t\tcase 'ip':\n\t\t\t\tif (isset($parts[0]) && isset($rigips[$parts[0]]))\n\t\t\t\t{\n\t\t\t\t\t$ip = explode('.', $rigips[$parts[0]]);\n\t\t\t\t\tif (count($ip) == 4)\n\t\t\t\t\t\t$rigname = intval($ip[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ipx':\n\t\t\t\tif (isset($parts[0]) && isset($rigips[$parts[0]]))\n\t\t\t\t{\n\t\t\t\t\t$ip = explode('.', $rigips[$parts[0]]);\n\t\t\t\t\tif (count($ip) == 4)\n\t\t\t\t\t\t$rigname = intval($ip[3], 16);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n }\n\n return $rigname;\n}\n#\nfunction riginput($rig, $rigname, $usebuttons)\n{\n $rigname = rigname($rig, $rigname);\n\n if ($usebuttons === true)\n\treturn \"<input type=button value='$rigname' onclick='pr(\\\"&rig=$rig\\\",null)'>\";\n else\n\treturn \"<a href='\".php_pr(\"&rig=$rig\").\"'>$rigname</a>\";\n}\n#\nfunction rigbutton($rig, $rigname, $when, $row, $usebuttons)\n{\n list($value, $class) = fmt('BUTTON', 'Rig', '', $when, $row);\n\n if ($rig === '')\n\t$ri = '&nbsp;';\n else\n\t$ri = riginput($rig, $rigname, $usebuttons);\n\n return \"<td align=middle$class>$ri</td>\";\n}\n#\nfunction showrigs($anss, $headname, $rigname)\n{\n global $rigbuttons;\n\n $dthead = array($headname => 1, 'STATUS' => 1, 'Description' => 1, 'When' => 1, 'API' => 1, 'CGMiner' => 1);\n showhead('', $dthead);\n\n foreach ($anss as $rig => $ans)\n {\n\tif ($ans == null)\n\t\tcontinue;\n\n\tnewrow();\n\n\t$when = 0;\n\tif (isset($ans['STATUS']['When']))\n\t\t$when = $ans['STATUS']['When'];\n\n\tforeach ($ans as $item => $row)\n\t{\n\t\tif ($item != 'STATUS' && $item != 'VERSION')\n\t\t\tcontinue;\n\n\t\tforeach ($dthead as $name => $x)\n\t\t{\n\t\t\tif ($item == 'STATUS' && $name == $headname)\n\t\t\t\techo rigbutton($rig, $rigname.$rig, $when, null, $rigbuttons);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isset($row[$name]))\n\t\t\t\t{\n\t\t\t\t\tlist($showvalue, $class) = fmt('STATUS', $name, $row[$name], $when, null);\n\t\t\t\t\techo \"<td$class align=right>$showvalue</td>\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tendrow();\n }\n}\n#\n# $head is a hack but this is just a demo anyway :)\nfunction doforeach($cmd, $des, $sum, $head, $datetime)\n{\n global $miner, $port;\n global $error, $readonly, $notify, $rigs, $rigbuttons;\n global $warnfont, $warnoff, $dfmt;\n global $rigerror;\n\n $when = 0;\n\n $header = $head;\n $anss = array();\n\n $count = 0;\n $preverr = count($rigerror);\n foreach ($rigs as $num => $rig)\n {\n\t$anss[$num] = null;\n\n\tif (isset($rigerror[$rig]))\n\t\tcontinue;\n\n\t$parts = explode(':', $rig, 3);\n\tif (count($parts) >= 1)\n\t{\n\t\t$miner = $parts[0];\n\t\tif (count($parts) >= 2)\n\t\t\t$port = $parts[1];\n\t\telse\n\t\t\t$port = '';\n\n\t\tif (count($parts) > 2)\n\t\t\t$name = $parts[2];\n\t\telse\n\t\t\t$name = $num;\n\n\t\t$ans = api($name, $cmd);\n\n\t\tif ($error != null)\n\t\t{\n\t\t\t$rw = \"<td colspan=100>Error on rig $name getting \";\n\t\t\t$rw .= \"$des: $warnfont$error$warnoff</td>\";\n\t\t\totherrow($rw);\n\t\t\t$rigerror[$rig] = $error;\n\t\t\t$error = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$anss[$num] = $ans;\n\t\t\t$count++;\n\t\t}\n\t}\n }\n\n if ($count == 0)\n {\n\t$rw = '<td>Failed to access any rigs successfully';\n\tif ($preverr > 0)\n\t\t$rw .= ' (or rigs had previous errors)';\n\t$rw .= '</td>';\n\totherrow($rw);\n\treturn;\n }\n\n if ($datetime)\n {\n\tshowdatetime();\n\tendtable();\n\tnewtable();\n\tshowrigs($anss, '', 'Rig ');\n\tendtable();\n\totherrow('<td><br><br></td>');\n\tnewtable();\n\n\treturn;\n }\n\n $total = array();\n\n foreach ($anss as $rig => $ans)\n {\n\tif ($ans == null)\n\t\tcontinue;\n\n\tforeach ($ans as $item => $row)\n\t{\n\t\tif ($item == 'STATUS')\n\t\t\tcontinue;\n\n\t\tif (count($row) > count($header))\n\t\t{\n\t\t\t$header = $head;\n\t\t\tforeach ($row as $name => $value)\n\t\t\t\tif (!isset($header[$name]))\n\t\t\t\t\t$header[$name] = '';\n\t\t}\n\n\t\tif ($sum != null)\n\t\t\tforeach ($sum as $name)\n\t\t\t{\n\t\t\t\tif (isset($row[$name]))\n\t\t\t\t{\n\t\t\t\t\tif (isset($total[$name]))\n\t\t\t\t\t\t$total[$name] += $row[$name];\n\t\t\t\t\telse\n\t\t\t\t\t\t$total[$name] = $row[$name];\n\t\t\t\t}\n\t\t\t}\n\t}\n }\n\n if ($sum != null)\n\t$anss['total']['total'] = $total;\n\n showhead('', $header);\n\n foreach ($anss as $rig => $ans)\n {\n\tif ($ans == null)\n\t\tcontinue;\n\n\t$when = 0;\n\tif (isset($ans['STATUS']['When']))\n\t\t$when = $ans['STATUS']['When'];\n\n\tforeach ($ans as $item => $row)\n\t{\n\t\tif ($item == 'STATUS')\n\t\t\tcontinue;\n\n\t\tnewrow();\n\n\t\t$section = preg_replace('/\\d/', '', $item);\n\n\t\tforeach ($header as $name => $x)\n\t\t{\n\t\t\tif ($name == '')\n\t\t\t{\n\t\t\t\tif ($rig === 'total')\n\t\t\t\t{\n\t\t\t\t\tlist($ignore, $class) = fmt($rig, '', '', $when, $row);\n\t\t\t\t\techo \"<td align=right$class>Total:</td>\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\techo rigbutton($rig, \"Rig $rig\", $when, $row, $rigbuttons);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isset($row[$name]))\n\t\t\t\t\t$value = $row[$name];\n\t\t\t\telse\n\t\t\t\t\t$value = null;\n\n\t\t\t\tlist($showvalue, $class) = fmt($section, $name, $value, $when, $row);\n\t\t\t\techo \"<td$class align=right>$showvalue</td>\";\n\t\t\t}\n\t\t}\n\t\tendrow();\n\t}\n }\n}\n#\nfunction refreshbuttons()\n{\n global $ignorerefresh, $changerefresh, $autorefresh;\n\n if ($ignorerefresh == false && $changerefresh == true)\n {\n\techo '&nbsp;&nbsp;&nbsp;&nbsp;';\n\techo \"<input type=button value='Auto Refresh:' onclick='prr(true)'>\";\n\techo \"<input type=text name='refval' id='refval' size=2 value='$autorefresh'>\";\n\techo \"<input type=button value='Off' onclick='prr(false)'>\";\n }\n}\n#\nfunction pagebuttons($rig, $pg)\n{\n global $readonly, $rigs, $rigbuttons, $userlist, $ses;\n global $allowcustompages, $customsummarypages;\n\n if ($rig === null)\n {\n\t$prev = null;\n\t$next = null;\n\n\tif ($pg === null)\n\t\t$refresh = '';\n\telse\n\t\t$refresh = \"&pg=$pg\";\n }\n else\n {\n\tswitch (count($rigs))\n\t{\n\tcase 0:\n\tcase 1:\n\t\t$prev = null;\n\t\t$next = null;\n\t\tbreak;\n\tcase 2:\n\t\t$prev = null;\n\t\t$next = ($rig + 1) % count($rigs);\n\t\tbreak;\n\tdefault:\n\t\t$prev = ($rig - 1) % count($rigs);\n\t\t$next = ($rig + 1) % count($rigs);\n\t\tbreak;\n\t}\n\n\t$refresh = \"&rig=$rig\";\n }\n\n echo '<tr><td><table cellpadding=0 cellspacing=0 border=0><tr><td nowrap>';\n if ($userlist === null || isset($_SESSION[$ses]))\n {\n\tif ($prev !== null)\n\t\techo riginput($prev, 'Prev', true).'&nbsp;';\n\n\techo \"<input type=button value='Refresh' onclick='pr(\\\"$refresh\\\",null)'>&nbsp;\";\n\n\tif ($next !== null)\n\t\techo riginput($next, 'Next', true).'&nbsp;';\n\techo '&nbsp;';\n\tif (count($rigs) > 1)\n\t\techo \"<input type=button value='Summary' onclick='pr(\\\"\\\",null)'>&nbsp;\";\n }\n\n if ($allowcustompages === true)\n {\n\tif ($userlist === null || isset($_SESSION[$ses]))\n\t\t$list = $customsummarypages;\n\telse\n\t{\n\t\tif ($userlist !== null && isset($userlist['def']))\n\t\t\t$list = array_flip($userlist['def']);\n\t\telse\n\t\t\t$list = array();\n\t}\n\n\tforeach ($list as $pagename => $data)\n\t\techo \"<input type=button value='$pagename' onclick='pr(\\\"&pg=$pagename\\\",null)'>&nbsp;\";\n }\n\n echo '</td><td width=100%>&nbsp;</td><td nowrap>';\n if ($rig !== null && $readonly === false)\n {\n\t$rg = '';\n\tif (count($rigs) > 1)\n\t\t$rg = \" Rig $rig\";\n\techo \"<input type=button value='Restart' onclick='prc(\\\"restart&rig=$rig\\\",\\\"Restart BFGMiner$rg\\\")'>\";\n\techo \"&nbsp;<input type=button value='Quit' onclick='prc(\\\"quit&rig=$rig\\\",\\\"Quit BFGMiner$rg\\\")'>\";\n }\n refreshbuttons();\n if (isset($_SESSION[$ses]))\n\techo \"&nbsp;<input type=button value='Logout' onclick='pr(\\\"&logout=1\\\",null)'>\";\n else\n\tif ($userlist !== null)\n\t\techo \"&nbsp;<input type=button value='Login' onclick='pr(\\\"&login=1\\\",null)'>\";\n\n echo \"</td></tr></table></td></tr>\";\n}\n#\nfunction doOne($rig, $preprocess)\n{\n global $haderror, $readonly, $notify, $rigs;\n global $placebuttons;\n\n if ($placebuttons == 'top' || $placebuttons == 'both')\n\tpagebuttons($rig, null);\n\n if ($preprocess != null)\n\tprocess(array($preprocess => $preprocess), $rig);\n\n $cmds = array(\t'devs'    => 'device list',\n\t\t'summary' => 'summary information',\n\t\t'pools'   => 'pool list');\n\n if ($notify)\n\t$cmds['notify'] = 'device status';\n\n $cmds['config'] = 'BFGMiner config';\n\n process($cmds, $rig);\n\n if ($haderror == false && $readonly === false)\n\tprocessgpus($rig);\n\n if ($placebuttons == 'bot' || $placebuttons == 'both')\n\tpagebuttons($rig, null);\n}\n#\nglobal $sectionmap;\n# map sections to their api command\n# DEVS is a special case that will match GPU or PGA\n# so you can have a single table with both in it\n# DATE is hard coded so not in here\n$sectionmap = array(\n\t'RIGS' => 'version',\n\t'SUMMARY' => 'summary',\n\t'POOL' => 'pools',\n\t'DEVS' => 'devs',\n\t'GPU' => 'devs',\t// You would normally use DEVS\n\t'PGA' => 'devs',\t// You would normally use DEVS\n\t'NOTIFY' => 'notify',\n\t'DEVDETAILS' => 'devdetails',\n\t'STATS' => 'stats',\n\t'CONFIG' => 'config',\n\t'COIN' => 'coin');\n#\nfunction joinfields($section1, $section2, $join, $results)\n{\n global $sectionmap;\n\n $name1 = $sectionmap[$section1];\n $name2 = $sectionmap[$section2];\n $newres = array();\n\n // foreach rig in section1\n foreach ($results[$name1] as $rig => $result)\n {\n\t$status = null;\n\n\t// foreach answer section in the rig api call\n\tforeach ($result as $name1b => $fields1b)\n\t{\n\t\tif ($name1b == 'STATUS')\n\t\t{\n\t\t\t// remember the STATUS from section1\n\t\t\t$status = $result[$name1b];\n\t\t\tcontinue;\n\t\t}\n\n\t\t// foreach answer section in the rig api call (for the other api command)\n\t\tforeach ($results[$name2][$rig] as $name2b => $fields2b)\n\t\t{\n\t\t\tif ($name2b == 'STATUS')\n\t\t\t\tcontinue;\n\n\t\t\t// If match the same field values of fields in $join\n\t\t\t$match = true;\n\t\t\tforeach ($join as $field)\n\t\t\t\tif ($fields1b[$field] != $fields2b[$field])\n\t\t\t\t{\n\t\t\t\t\t$match = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif ($match === true)\n\t\t\t{\n\t\t\t\tif ($status != null)\n\t\t\t\t{\n\t\t\t\t\t$newres[$rig]['STATUS'] = $status;\n\t\t\t\t\t$status = null;\n\t\t\t\t}\n\n\t\t\t\t$subsection = $section1.'+'.$section2;\n\t\t\t\t$subsection .= preg_replace('/[^0-9]/', '', $name1b.$name2b);\n\n\t\t\t\tforeach ($fields1b as $nam => $val)\n\t\t\t\t\t$newres[$rig][$subsection][\"$section1.$nam\"] = $val;\n\t\t\t\tforeach ($fields2b as $nam => $val)\n\t\t\t\t\t$newres[$rig][$subsection][\"$section2.$nam\"] = $val;\n\t\t\t}\n\t\t}\n\t}\n }\n return $newres;\n}\n#\nfunction join_get_field($field, $fields)\n{\n\t// : means a string constant otherwise it's a field name\n\t// ProcID field name is converted to a lowercase letter\n\tif (substr($field, 0, 1) == ':')\n\t\treturn substr($field, 1);\n\telse\n\tif ($field == 'ProcID')\n\t\treturn chr(97 + $fields[$field]);\n\telse\n\t\treturn $fields[$field];\n}\n#\nfunction joinlr($section1, $section2, $join, $results)\n{\n global $sectionmap;\n\n $name1 = $sectionmap[$section1];\n $name2 = $sectionmap[$section2];\n $newres = array();\n\n // foreach rig in section1\n foreach ($results[$name1] as $rig => $result)\n {\n\t$status = null;\n\n\t// foreach answer section in the rig api call\n\tforeach ($result as $name1b => $fields1b)\n\t{\n\t\tif ($name1b == 'STATUS')\n\t\t{\n\t\t\t// remember the STATUS from section1\n\t\t\t$status = $result[$name1b];\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Build L string to be matched\n\t\t$Lval = '';\n\t\tforeach ($join['L'] as $field)\n\t\t\t$Lval .= join_get_field($field, $fields1b);\n\n\t\t// foreach answer section in the rig api call (for the other api command)\n\t\tforeach ($results[$name2][$rig] as $name2b => $fields2b)\n\t\t{\n\t\t\tif ($name2b == 'STATUS')\n\t\t\t\tcontinue;\n\n\t\t\t// Build R string and compare\n\t\t\t$Rval = '';\n\t\t\tforeach ($join['R'] as $field)\n\t\t\t\t$Rval .= join_get_field($field, $fields2b);\n\n\t\t\tif ($Lval === $Rval)\n\t\t\t{\n\t\t\t\tif ($status != null)\n\t\t\t\t{\n\t\t\t\t\t$newres[$rig]['STATUS'] = $status;\n\t\t\t\t\t$status = null;\n\t\t\t\t}\n\n\t\t\t\t$subsection = $section1.'+'.$section2;\n\t\t\t\t$subsection .= preg_replace('/[^0-9]/', '', $name1b.$name2b);\n\n\t\t\t\tforeach ($fields1b as $nam => $val)\n\t\t\t\t\t$newres[$rig][$subsection][\"$section1.$nam\"] = $val;\n\t\t\t\tforeach ($fields2b as $nam => $val)\n\t\t\t\t\t$newres[$rig][$subsection][\"$section2.$nam\"] = $val;\n\t\t\t}\n\t\t}\n\t}\n }\n return $newres;\n}\n#\nfunction joinall($section1, $section2, $results)\n{\n global $sectionmap;\n\n $name1 = $sectionmap[$section1];\n $name2 = $sectionmap[$section2];\n $newres = array();\n\n // foreach rig in section1\n foreach ($results[$name1] as $rig => $result)\n {\n\t// foreach answer section in the rig api call\n\tforeach ($result as $name1b => $fields1b)\n\t{\n\t\tif ($name1b == 'STATUS')\n\t\t{\n\t\t\t// copy the STATUS from section1\n\t\t\t$newres[$rig][$name1b] = $result[$name1b];\n\t\t\tcontinue;\n\t\t}\n\n\t\t// foreach answer section in the rig api call (for the other api command)\n\t\tforeach ($results[$name2][$rig] as $name2b => $fields2b)\n\t\t{\n\t\t\tif ($name2b == 'STATUS')\n\t\t\t\tcontinue;\n\n\t\t\t$subsection = $section1.'+'.$section2;\n\t\t\t$subsection .= preg_replace('/[^0-9]/', '', $name1b.$name2b);\n\n\t\t\tforeach ($fields1b as $nam => $val)\n\t\t\t\t$newres[$rig][$subsection][\"$section1.$nam\"] = $val;\n\t\t\tforeach ($fields2b as $nam => $val)\n\t\t\t\t$newres[$rig][$subsection][\"$section2.$nam\"] = $val;\n\t\t}\n\t}\n }\n return $newres;\n}\n#\nfunction joinsections($sections, $results, $errors)\n{\n global $sectionmap;\n\n // GPU's don't have Name,ID,ProcID fields - so create them\n foreach ($results as $section => $res)\n\tforeach ($res as $rig => $result)\n\t\tforeach ($result as $name => $fields)\n\t\t{\n\t\t\t$subname = preg_replace('/[0-9]/', '', $name);\n\t\t\tif ($subname == 'GPU' and isset($result[$name]['GPU']))\n\t\t\t{\n\t\t\t\t$results[$section][$rig][$name]['Name'] = 'GPU';\n\t\t\t\t$results[$section][$rig][$name]['ID'] = $result[$name]['GPU'];\n\t\t\t\t$results[$section][$rig][$name]['ProcID'] = 0;\n\t\t\t}\n\t\t}\n\n foreach ($sections as $section => $fields)\n\tif ($section != 'DATE' && !isset($sectionmap[$section]))\n\t{\n\t\t$both = explode('+', $section, 2);\n\t\tif (count($both) > 1)\n\t\t{\n\t\t\tswitch($both[0])\n\t\t\t{\n\t\t\tcase 'SUMMARY':\n\t\t\t\tswitch($both[1])\n\t\t\t\t{\n\t\t\t\tcase 'POOL':\n\t\t\t\tcase 'DEVS':\n\t\t\t\tcase 'CONFIG':\n\t\t\t\tcase 'COIN':\n\t\t\t\t\t$sectionmap[$section] = $section;\n\t\t\t\t\t$results[$section] = joinall($both[0], $both[1], $results);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$errors[] = \"Error: Invalid section '$section'\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'DEVS':\n\t\t\t\tswitch($both[1])\n\t\t\t\t{\n\t\t\t\tcase 'NOTIFY':\n\t\t\t\tcase 'DEVDETAILS':\n\t\t\t\tcase 'USBSTATS':\n\t\t\t\t\t$join = array('Name', 'ID', 'ProcID');\n\t\t\t\t\t$sectionmap[$section] = $section;\n\t\t\t\t\t$results[$section] = joinfields($both[0], $both[1], $join, $results);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'STATS':\n\t\t\t\t\t$join = array('L' => array('Name','ID','ProcID'), 'R' => array('ID'));\n\t\t\t\t\t$sectionmap[$section] = $section;\n\t\t\t\t\t$results[$section] = joinlr($both[0], $both[1], $join, $results);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$errors[] = \"Error: Invalid section '$section'\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'POOL':\n\t\t\t\tswitch($both[1])\n\t\t\t\t{\n\t\t\t\tcase 'STATS':\n\t\t\t\t\t$join = array('L' => array(':POOL','POOL'), 'R' => array('ID'));\n\t\t\t\t\t$sectionmap[$section] = $section;\n\t\t\t\t\t$results[$section] = joinlr($both[0], $both[1], $join, $results);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$errors[] = \"Error: Invalid section '$section'\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$errors[] = \"Error: Invalid section '$section'\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\t$errors[] = \"Error: Invalid section '$section'\";\n\t}\n\n return array($results, $errors);\n}\n#\nfunction secmatch($section, $field)\n{\n if ($section == $field)\n\treturn true;\n\n if ($section == 'DEVS'\n &&  ($field == 'GPU' || $field == 'PGA'))\n\treturn true;\n\n return false;\n}\n#\nfunction customset($showfields, $sum, $section, $rig, $isbutton, $result, $total)\n{\n global $rigbuttons;\n\n foreach ($result as $sec => $row)\n {\n\t$secname = preg_replace('/\\d/', '', $sec);\n\n\tif ($sec != 'total')\n\t\tif (!secmatch($section, $secname))\n\t\t\tcontinue;\n\n\tnewrow();\n\n\t$when = 0;\n\tif (isset($result['STATUS']['When']))\n\t\t$when = $result['STATUS']['When'];\n\n\n\tif ($isbutton)\n\t\techo rigbutton($rig, $rig, $when, $row, $rigbuttons);\n\telse\n\t{\n\t\tlist($ignore, $class) = fmt('total', '', '', $when, $row);\n\t\techo \"<td align=middle$class>$rig</td>\";\n\t}\n\n\tforeach ($showfields as $name => $one)\n\t{\n\t\tif (isset($row[$name]))\n\t\t{\n\t\t\t$value = $row[$name];\n\n\t\t\tif (isset($sum[$section][$name]))\n\t\t\t{\n\t\t\t\tif (isset($total[$name]))\n\t\t\t\t\t$total[$name] += $value;\n\t\t\t\telse\n\t\t\t\t\t$total[$name] = $value;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($sec == 'total' && isset($total[$name]))\n\t\t\t\t$value = $total[$name];\n\t\t\telse\n\t\t\t\t$value = null;\n\t\t}\n\n\t\tif (strpos($secname, '+') === false)\n\t\t\tlist($showvalue, $class) = fmt($secname, $name, $value, $when, $row);\n\t\telse\n\t\t{\n\t\t\t$parts = explode('.', $name, 2);\n\t\t\tlist($showvalue, $class) = fmt($parts[0], $parts[1], $value, $when, $row);\n\t\t}\n\n\t\techo \"<td$class align=right>$showvalue</td>\";\n\t}\n\tendrow();\n }\n return $total;\n}\n#\nfunction docalc($func, $data)\n{\n switch ($func)\n {\n case 'sum':\n\t$tot = 0;\n\tforeach ($data as $val)\n\t\t$tot += $val;\n\treturn $tot;\n case 'avg':\n\t$tot = 0;\n\tforeach ($data as $val)\n\t\t$tot += $val;\n\treturn ($tot / count($data));\n case 'min':\n\t$ans = null;\n\tforeach ($data as $val)\n\t\tif ($ans === null)\n\t\t\t$ans = $val;\n\t\telse\n\t\t\tif ($val < $ans)\n\t\t\t\t$ans = $val;\n\treturn $ans;\n case 'max':\n\t$ans = null;\n\tforeach ($data as $val)\n\t\tif ($ans === null)\n\t\t\t$ans = $val;\n\t\telse\n\t\t\tif ($val > $ans)\n\t\t\t\t$ans = $val;\n\treturn $ans;\n case 'lo':\n\t$ans = null;\n\tforeach ($data as $val)\n\t\tif ($ans === null)\n\t\t\t$ans = $val;\n\t\telse\n\t\t\tif (strcasecmp($val, $ans) < 0)\n\t\t\t\t$ans = $val;\n\treturn $ans;\n case 'hi':\n\t$ans = null;\n\tforeach ($data as $val)\n\t\tif ($ans === null)\n\t\t\t$ans = $val;\n\t\telse\n\t\t\tif (strcasecmp($val, $ans) > 0)\n\t\t\t\t$ans = $val;\n\treturn $ans;\n case 'count':\n\treturn count($data);\n case 'any':\n default:\n\treturn $data[0];\n }\n}\n#\nfunction docompare($row, $test)\n{\n // invalid $test data means true\n if (count($test) < 2)\n\treturn true;\n\n if (isset($row[$test[0]]))\n\t$val = $row[$test[0]];\n else\n\t$val = null;\n\n if ($test[1] == 'set')\n\treturn ($val !== null);\n\n if ($val === null || count($test) < 3)\n\treturn true;\n\n switch($test[1])\n {\n case '=':\n\treturn ($val == $test[2]);\n case '<':\n\treturn ($val < $test[2]);\n case '<=':\n\treturn ($val <= $test[2]);\n case '>':\n\treturn ($val > $test[2]);\n case '>=':\n\treturn ($val >= $test[2]);\n case 'eq':\n\treturn (strcasecmp($val, $test[2]) == 0);\n case 'lt':\n\treturn (strcasecmp($val, $test[2]) < 0);\n case 'le':\n\treturn (strcasecmp($val, $test[2]) <= 0);\n case 'gt':\n\treturn (strcasecmp($val, $test[2]) > 0);\n case 'ge':\n\treturn (strcasecmp($val, $test[2]) >= 0);\n default:\n\treturn true;\n }\n}\n#\nfunction processcompare($which, $ext, $section, $res)\n{\n if (isset($ext[$section][$which]))\n {\n\t$proc = $ext[$section][$which];\n\tif ($proc !== null)\n\t{\n\t\t$res2 = array();\n\t\tforeach ($res as $rig => $result)\n\t\t\tforeach ($result as $sec => $row)\n\t\t\t{\n\t\t\t\t$secname = preg_replace('/\\d/', '', $sec);\n\t\t\t\tif (!secmatch($section, $secname))\n\t\t\t\t\t$res2[$rig][$sec] = $row;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$keep = true;\n\t\t\t\t\tforeach ($proc as $test)\n\t\t\t\t\t\tif (!docompare($row, $test))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$keep = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif ($keep)\n\t\t\t\t\t\t$res2[$rig][$sec] = $row;\n\t\t\t\t}\n\t\t\t}\n\n\t\t$res = $res2;\n\t}\n }\n return $res;\n}\n#\nfunction ss($a, $b)\n{\n $la = strlen($a);\n $lb = strlen($b);\n if ($la != $lb)\n\treturn $lb - $la;\n return strcmp($a, $b);\n}\n#\nfunction genfld($row, $calc)\n{\n uksort($row, \"ss\");\n\n foreach ($row as $name => $value)\n\tif (strstr($calc, $name) !== FALSE)\n\t\t$calc = str_replace($name, $value, $calc);\n\n eval(\"\\$val = $calc;\");\n\n return $val;\n}\n#\nfunction dogen($ext, $section, &$res, &$fields)\n{\n $gen = $ext[$section]['gen'];\n\n foreach ($gen as $fld => $calc)\n\t$fields[] = \"GEN.$fld\";\n\n foreach ($res as $rig => $result)\n\tforeach ($result as $sec => $row)\n\t{\n\t\t$secname = preg_replace('/\\d/', '', $sec);\n\t\tif (secmatch($section, $secname))\n\t\t\tforeach ($gen as $fld => $calc)\n\t\t\t{\n\t\t\t\t$name = \"GEN.$fld\";\n\n\t\t\t\t$val = genfld($row, $calc);\n\n\t\t\t\t$res[$rig][$sec][$name] = $val;\n\t\t\t}\n\t}\n}\n#\nfunction processext($ext, $section, $res, &$fields)\n{\n global $allowgen;\n\n $res = processcompare('where', $ext, $section, $res);\n\n if (isset($ext[$section]['group']))\n {\n\t$grp = $ext[$section]['group'];\n\t$calc = $ext[$section]['calc'];\n\tif ($grp !== null)\n\t{\n\t\t$interim = array();\n\t\t$res2 = array();\n\t\t$cou = 0;\n\t\tforeach ($res as $rig => $result)\n\t\t\tforeach ($result as $sec => $row)\n\t\t\t{\n\t\t\t\t$secname = preg_replace('/\\d/', '', $sec);\n\t\t\t\tif (!secmatch($section, $secname))\n\t\t\t\t{\n\t\t\t\t\t// STATUS may be problematic ...\n\t\t\t\t\tif (!isset($res2[$sec]))\n\t\t\t\t\t\t$res2[$sec] = $row;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$grpkey = '';\n\t\t\t\t\t$newrow = array();\n\t\t\t\t\tforeach ($grp as $field)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isset($row[$field]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$grpkey .= $row[$field].'.';\n\t\t\t\t\t\t\t$newrow[$field] = $row[$field];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t$grpkey .= '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isset($interim[$grpkey]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$interim[$grpkey]['grp'] = $newrow;\n\t\t\t\t\t\t$interim[$grpkey]['sec'] = $secname.$cou;\n\t\t\t\t\t\t$cou++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($calc !== null)\n\t\t\t\t\t\tforeach ($calc as $field => $func)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!isset($interim[$grpkey]['cal'][$field]))\n\t\t\t\t\t\t\t\t$interim[$grpkey]['cal'][$field] = array();\n\t\t\t\t\t\t\t$interim[$grpkey]['cal'][$field][] = $row[$field];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Build the rest of $res2 from $interim\n\t\tforeach ($interim as $rowkey => $row)\n\t\t{\n\t\t\t$key = $row['sec'];\n\t\t\tforeach ($row['grp'] as $field => $value)\n\t\t\t\t$res2[$key][$field] = $value;\n\t\t\tforeach ($row['cal'] as $field => $data)\n\t\t\t\t$res2[$key][$field] = docalc($calc[$field], $data);\n\t\t}\n\n\t\t$res = array('' => $res2);\n\t}\n }\n\n // Generated fields (functions of other fields)\n if ($allowgen === true && isset($ext[$section]['gen']))\n\tdogen($ext, $section, $res, $fields);\n\n return processcompare('having', $ext, $section, $res);\n}\n#\nfunction processcustompage($pagename, $sections, $sum, $ext, $namemap)\n{\n global $sectionmap;\n global $miner, $port;\n global $rigs, $error;\n global $warnfont, $warnoff;\n global $dfmt;\n global $readonly, $showndate;\n\n $cmds = array();\n $errors = array();\n foreach ($sections as $section => $fields)\n {\n\t$all = explode('+', $section);\n\tforeach ($all as $section)\n\t{\n\t\tif (isset($sectionmap[$section]))\n\t\t{\n\t\t\t$cmd = $sectionmap[$section];\n\t\t\tif (!isset($cmds[$cmd]))\n\t\t\t\t$cmds[$cmd] = 1;\n\t\t}\n\t\telse\n\t\t\tif ($section != 'DATE')\n\t\t\t\t$errors[] = \"Error: unknown section '$section' in custom summary page '$pagename'\";\n\t}\n }\n\n $results = array();\n foreach ($rigs as $num => $rig)\n {\n\t$parts = explode(':', $rig, 3);\n\tif (count($parts) >= 1)\n\t{\n\t\t$miner = $parts[0];\n\t\tif (count($parts) >= 2)\n\t\t\t$port = $parts[1];\n\t\telse\n\t\t\t$port = '';\n\n\t\tif (count($parts) > 2)\n\t\t\t$name = $parts[2];\n\t\telse\n\t\t\t$name = $rig;\n\n\t\tforeach ($cmds as $cmd => $one)\n\t\t{\n\t\t\t$process = api($name, $cmd);\n\n\t\t\tif ($error != null)\n\t\t\t{\n\t\t\t\t$errors[] = \"Error getting $cmd for $name $warnfont$error$warnoff\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t$results[$cmd][$num] = $process;\n\t\t}\n\t}\n\telse\n\t\totherrow('<td class=bad>Bad \"$rigs\" array</td>');\n }\n\n $shownsomething = false;\n if (count($results) > 0)\n {\n\tlist($results, $errors) = joinsections($sections, $results, $errors);\n\t$first = true;\n\tforeach ($sections as $section => $fields)\n\t{\n\t\tif ($section === 'DATE')\n\t\t{\n\t\t\tif ($shownsomething)\n\t\t\t\totherrow('<td>&nbsp;</td>');\n\n\t\t\tnewtable();\n\t\t\tshowdatetime();\n\t\t\tendtable();\n\t\t\t// On top of the next table\n\t\t\t$shownsomething = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ($section === 'RIGS')\n\t\t{\n\t\t\tif ($shownsomething)\n\t\t\t\totherrow('<td>&nbsp;</td>');\n\n\t\t\tnewtable();\n\t\t\tshowrigs($results['version'], 'Rig', '');\n\t\t\tendtable();\n\t\t\t$shownsomething = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isset($results[$sectionmap[$section]]))\n\t\t{\n\t\t\t$rigresults = processext($ext, $section, $results[$sectionmap[$section]], $fields);\n\n\t\t\t$showfields = array();\n\t\t\t$showhead = array();\n\t\t\tforeach ($fields as $field)\n\t\t\t\tforeach ($rigresults as $result)\n\t\t\t\t\tforeach ($result as $sec => $row)\n\t\t\t\t\t{\n\t\t\t\t\t\t$secname = preg_replace('/\\d/', '', $sec);\n\t\t\t\t\t\tif (secmatch($section, $secname))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($field === '*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeach ($row as $f => $v)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$showfields[$f] = 1;\n\t\t\t\t\t\t\t\t\t$map = $section.'.'.$f;\n\t\t\t\t\t\t\t\t\tif (isset($namemap[$map]))\n\t\t\t\t\t\t\t\t\t\t$showhead[$namemap[$map]] = 1;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t$showhead[$f] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telseif (isset($row[$field]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$showfields[$field] = 1;\n\t\t\t\t\t\t\t\t$map = $section.'.'.$field;\n\t\t\t\t\t\t\t\tif (isset($namemap[$map]))\n\t\t\t\t\t\t\t\t\t$showhead[$namemap[$map]] = 1;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t$showhead[$field] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\tif (count($showfields) > 0)\n\t\t\t{\n\t\t\t\tif ($shownsomething)\n\t\t\t\t\totherrow('<td>&nbsp;</td>');\n\n\t\t\t\tnewtable();\n\t\t\t\tif (count($rigresults) == 1 && isset($rigresults['']))\n\t\t\t\t\t$ri = array('' => 1) + $showhead;\n\t\t\t\telse\n\t\t\t\t\t$ri = array('Rig' => 1) + $showhead;\n\t\t\t\tshowhead('', $ri, true);\n\n\t\t\t\t$total = array();\n\t\t\t\t$add = array('total' => array());\n\n\t\t\t\tforeach ($rigresults as $num => $result)\n\t\t\t\t\t$total = customset($showfields, $sum, $section, $num, true, $result, $total);\n\n\t\t\t\tif (count($total) > 0)\n\t\t\t\t\tcustomset($showfields, $sum, $section, '&Sigma;', false, $add, $total);\n\n\t\t\t\t$first = false;\n\n\t\t\t\tendtable();\n\t\t\t\t$shownsomething = true;\n\t\t\t}\n\t\t}\n\t}\n }\n\n if (count($errors) > 0)\n {\n\tif (count($results) > 0)\n\t\totherrow('<td>&nbsp;</td>');\n\n\tforeach ($errors as $err)\n\t\totherrow(\"<td colspan=100>$err</td>\");\n }\n}\n#\nfunction showcustompage($pagename)\n{\n global $customsummarypages;\n global $placebuttons;\n\n if ($placebuttons == 'top' || $placebuttons == 'both')\n\tpagebuttons(null, $pagename);\n\n if (!isset($customsummarypages[$pagename]))\n {\n\totherrow(\"<td colspan=100 class=bad>Unknown custom summary page '$pagename'</td>\");\n\treturn;\n }\n\n $c = count($customsummarypages[$pagename]);\n if ($c < 2 || $c > 3)\n {\n\t$rw = \"<td colspan=100 class=bad>Invalid custom summary page '$pagename' (\";\n\t$rw .= count($customsummarypages[$pagename]).')</td>';\n\totherrow($rw);\n\treturn;\n }\n\n $page = $customsummarypages[$pagename][0];\n $namemap = array();\n foreach ($page as $name => $fields)\n {\n\tif ($fields === null)\n\t\t$page[$name] = array();\n\telse\n\t\tforeach ($fields as $num => $field)\n\t\t{\n\t\t\t$pos = strpos($field, '=');\n\t\t\tif ($pos !== false)\n\t\t\t{\n\t\t\t\t$names = explode('=', $field, 2);\n\t\t\t\tif (strlen($names[1]) > 0)\n\t\t\t\t\t$namemap[$name.'.'.$names[0]] = $names[1];\n\t\t\t\t$page[$name][$num] = $names[0];\n\t\t\t}\n\t\t}\n }\n\n $ext = null;\n if (isset($customsummarypages[$pagename][2]))\n\t$ext = $customsummarypages[$pagename][2];\n\n $sum = $customsummarypages[$pagename][1];\n if ($sum === null)\n\t$sum = array();\n\n // convert them to searchable via isset()\n foreach ($sum as $section => $fields)\n {\n\t$newfields = array();\n\tforeach ($fields as $field)\n\t\t$newfields[$field] = 1;\n\t$sum[$section] = $newfields;\n }\n\n if (count($page) <= 1)\n {\n\totherrow(\"<td colspan=100 class=bad>Invalid custom summary page '$pagename' no content </td>\");\n\treturn;\n }\n\n processcustompage($pagename, $page, $sum, $ext, $namemap);\n\n if ($placebuttons == 'bot' || $placebuttons == 'both')\n\tpagebuttons(null, $pagename);\n}\n#\nfunction onlylogin()\n{\n global $here;\n\n htmlhead('', false, null, null, true);\n\n?>\n<tr height=15%><td>&nbsp;</td></tr>\n<tr><td>\n <center>\n  <table width=384 height=368 cellpadding=0 cellspacing=0 border=0>\n   <tr><td>\n    <table width=100% height=100% border=0 align=center cellpadding=5 cellspacing=0>\n     <tr><td><form action='<?php echo $here; ?>' method=post>\n      <table width=200 border=0 align=center cellpadding=5 cellspacing=0>\n       <tr><td height=120 colspan=2>&nbsp;</td></tr>\n       <tr><td colspan=2 align=center valign=middle>\n        <h2>LOGIN</h2></td></tr>\n       <tr><td align=center valign=middle><div align=right>Username:</div></td>\n        <td height=33 align=center valign=middle>\n        <input type=text name=rut size=18></td></tr>\n       <tr><td align=center valign=middle><div align=right>Password:</div></td>\n        <td height=33 align=center valign=middle>\n        <input type=password name=roh size=18></td></tr>\n       <tr valign=top><td></td><td><input type=submit value=Login>\n        </td></tr>\n      </table></form></td></tr>\n    </table></td></tr>\n  </table></center>\n</td></tr>\n<?php\n}\n#\nfunction checklogin()\n{\n global $allowcustompages, $customsummarypages;\n global $readonly, $userlist, $ses;\n\n $out = trim(getparam('logout', true));\n if ($out !== null && $out !== '' && isset($_SESSION[$ses]))\n\tunset($_SESSION[$ses]);\n\n $login = trim(getparam('login', true));\n if ($login !== null && $login !== '')\n {\n\tif (isset($_SESSION[$ses]))\n\t\tunset($_SESSION[$ses]);\n\n\tonlylogin();\n\treturn 'login';\n }\n\n if ($userlist === null)\n\treturn false;\n\n $rut = trim(getparam('rut', true));\n $roh = trim(getparam('roh', true));\n\n if (($rut !== null && $rut !== '') || ($roh !== null && $roh !== ''))\n {\n\tif (isset($_SESSION[$ses]))\n\t\tunset($_SESSION[$ses]);\n\n\tif ($rut !== null && $rut !== '' && $roh !== null && $roh !== '')\n\t{\n\t\tif (isset($userlist['sys']) && isset($userlist['sys'][$rut])\n\t\t&&  ($userlist['sys'][$rut] === $roh))\n\t\t{\n\t\t\t$_SESSION[$ses] = true;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isset($userlist['usr']) && isset($userlist['usr'][$rut])\n\t\t&&  ($userlist['usr'][$rut] === $roh))\n\t\t{\n\t\t\t$_SESSION[$ses] = false;\n\t\t\t$readonly = true;\n\t\t\treturn false;\n\t\t}\n\t}\n }\n\n if (isset($_SESSION[$ses]))\n {\n\tif ($_SESSION[$ses] == false)\n\t\t$readonly = true;\n\treturn false;\n }\n\n if (isset($userlist['def']) && $allowcustompages === true)\n {\n\t// Ensure at least one exists\n\tforeach ($userlist['def'] as $pg)\n\t\tif (isset($customsummarypages[$pg]))\n\t\t\treturn true;\n }\n\n onlylogin();\n return 'login';\n}\n#\nfunction display()\n{\n global $miner, $port;\n global $mcast, $mcastexpect;\n global $readonly, $notify, $rigs;\n global $ignorerefresh, $autorefresh;\n global $allowcustompages, $customsummarypages;\n global $placebuttons;\n global $userlist, $ses;\n\n $pagesonly = checklogin();\n\n if ($pagesonly === 'login')\n\treturn;\n\n $mcerr = '';\n\n if ($rigs == null or count($rigs) == 0)\n {\n\tif ($mcast === true)\n\t\t$action = 'found';\n\telse\n\t\t$action = 'defined';\n\n\tminhead();\n\totherrow(\"<td class=bad>No rigs $action</td>\");\n\treturn;\n }\n else\n {\n\tif ($mcast === true && count($rigs) < $mcastexpect)\n\t\t$mcerr = othrow('<td class=bad>Found '.count($rigs).\" rigs but expected at least $mcastexpect</td>\");\n }\n\n if ($ignorerefresh == false)\n {\n\t$ref = trim(getparam('ref', true));\n\tif ($ref != null && $ref != '')\n\t\t$autorefresh = intval($ref);\n }\n\n if ($pagesonly !== true)\n {\n\t$rig = trim(getparam('rig', true));\n\n\t$arg = trim(getparam('arg', true));\n\t$preprocess = null;\n\tif ($arg != null and $arg != '')\n\t{\n\t\tif ($rig != null and $rig != '' and $rig >= 0 and $rig < count($rigs))\n\t\t{\n\t\t\t$parts = explode(':', $rigs[$rig], 3);\n\t\t\tif (count($parts) >= 1)\n\t\t\t{\n\t\t\t\t$miner = $parts[0];\n\t\t\t\tif (count($parts) >= 2)\n\t\t\t\t\t$port = $parts[1];\n\t\t\t\telse\n\t\t\t\t\t$port = '';\n\n\t\t\t\tif ($readonly !== true)\n\t\t\t\t\t$preprocess = $arg;\n\t\t\t}\n\t\t}\n\t}\n }\n\n if ($allowcustompages === true)\n {\n\t$pg = urlencode(trim(getparam('pg', true)));\n\tif ($pagesonly === true)\n\t{\n\t\tif ($pg !== null && $pg !== '')\n\t\t{\n\t\t\tif ($userlist !== null && isset($userlist['def'])\n\t\t\t&&  !in_array($pg, $userlist['def']))\n\t\t\t\t$pg = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($userlist !== null && isset($userlist['def']))\n\t\t\t\tforeach ($userlist['def'] as $pglook)\n\t\t\t\t\tif (isset($customsummarypages[$pglook]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$pg = $pglook;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t}\n\t}\n\n\tif ($pg !== null && $pg !== '')\n\t{\n\t\thtmlhead($mcerr, false, null, $pg);\n\t\tshowcustompage($pg, $mcerr);\n\t\treturn;\n\t}\n }\n\n if ($pagesonly === true)\n {\n\tonlylogin();\n\treturn;\n }\n\n if (count($rigs) == 1)\n {\n\t$parts = explode(':', $rigs[0], 3);\n\tif (count($parts) >= 1)\n\t{\n\t\t$miner = $parts[0];\n\t\tif (count($parts) >= 2)\n\t\t\t$port = $parts[1];\n\t\telse\n\t\t\t$port = '';\n\n\t\thtmlhead($mcerr, true, 0);\n\t\tdoOne(0, $preprocess);\n\t}\n\telse\n\t{\n\t\tminhead($mcerr);\n\t\totherrow('<td class=bad>Invalid \"$rigs\" array</td>');\n\t}\n\n\treturn;\n }\n\n if ($rig != null and $rig != '' and $rig >= 0 and $rig < count($rigs))\n {\n\t$parts = explode(':', $rigs[$rig], 3);\n\tif (count($parts) >= 1)\n\t{\n\t\t$miner = $parts[0];\n\t\tif (count($parts) >= 2)\n\t\t\t$port = $parts[1];\n\t\telse\n\t\t\t$port = '';\n\n\t\thtmlhead($mcerr, true, 0);\n\t\tdoOne($rig, $preprocess);\n\t}\n\telse\n\t{\n\t\tminhead($mcerr);\n\t\totherrow('<td class=bad>Invalid \"$rigs\" array</td>');\n\t}\n\n\treturn;\n }\n\n htmlhead($mcerr, false, null);\n\n if ($placebuttons == 'top' || $placebuttons == 'both')\n\tpagebuttons(null, null);\n\n if ($preprocess != null)\n\tprocess(array($preprocess => $preprocess), $rig);\n\n newtable();\n doforeach('version', 'rig summary', array(), array(), true);\n $sum = array('MHS av', 'Getworks', 'Found Blocks', 'Accepted', 'Rejected', 'Discarded', 'Stale', 'Utility', 'Local Work', 'Total MH');\n doforeach('summary', 'summary information', $sum, array(), false);\n endtable();\n otherrow('<td><br><br></td>');\n newtable();\n doforeach('devs', 'device list', $sum, array(''=>'','ProcID'=>'','ID'=>'','Name'=>''), false);\n endtable();\n otherrow('<td><br><br></td>');\n newtable();\n doforeach('pools', 'pool list', $sum, array(''=>''), false);\n endtable();\n\n if ($placebuttons == 'bot' || $placebuttons == 'both')\n\tpagebuttons(null, null);\n}\n#\nif ($mcast === true)\n getrigs();\ndisplay();\n#\n?>\n</table></td></tr></table>\n</body></html>\n"
        },
        {
          "name": "ocl.c",
          "type": "blob",
          "size": 43.140625,
          "content": "/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2012-2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <ctype.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include <time.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define OMIT_OPENCL_API\n\n#include \"deviceapi.h\"\n#include \"driver-opencl.h\"\n#include \"findnonce.h\"\n#include \"logging.h\"\n#include \"miner.h\"\n#include \"ocl.h\"\n#include \"sha2.h\"\n#include \"util.h\"\n\n/* Platform API */\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetPlatformIDs)(cl_uint          /* num_entries */,\n                 cl_platform_id * /* platforms */,\n                 cl_uint *        /* num_platforms */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetPlatformInfo)(cl_platform_id   /* platform */,\n                  cl_platform_info /* param_name */,\n                  size_t           /* param_value_size */,\n                  void *           /* param_value */,\n                  size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Device APIs */\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetDeviceIDs)(cl_platform_id   /* platform */,\n               cl_device_type   /* device_type */,\n               cl_uint          /* num_entries */,\n               cl_device_id *   /* devices */,\n               cl_uint *        /* num_devices */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetDeviceInfo)(cl_device_id    /* device */,\n                cl_device_info  /* param_name */,\n                size_t          /* param_value_size */,\n                void *          /* param_value */,\n                size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Context APIs  */\nextern\nCL_API_ENTRY cl_context CL_API_CALL\n(*clCreateContextFromType)(const cl_context_properties * /* properties */,\n                        cl_device_type          /* device_type */,\n                        void (CL_CALLBACK *     /* pfn_notify*/ )(const char *, const void *, size_t, void *),\n                        void *                  /* user_data */,\n                        cl_int *                /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseContext)(cl_context /* context */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Command Queue APIs */\nextern\nCL_API_ENTRY cl_command_queue CL_API_CALL\n(*clCreateCommandQueue)(cl_context                     /* context */,\n                     cl_device_id                   /* device */,\n                     cl_command_queue_properties    /* properties */,\n                     cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseCommandQueue)(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Memory Object APIs */\nextern\nCL_API_ENTRY cl_mem CL_API_CALL\n(*clCreateBuffer)(cl_context   /* context */,\n               cl_mem_flags /* flags */,\n               size_t       /* size */,\n               void *       /* host_ptr */,\n               cl_int *     /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Program Object APIs  */\nextern\nCL_API_ENTRY cl_program CL_API_CALL\n(*clCreateProgramWithSource)(cl_context        /* context */,\n                          cl_uint           /* count */,\n                          const char **     /* strings */,\n                          const size_t *    /* lengths */,\n                          cl_int *          /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_program CL_API_CALL\n(*clCreateProgramWithBinary)(cl_context                     /* context */,\n                          cl_uint                        /* num_devices */,\n                          const cl_device_id *           /* device_list */,\n                          const size_t *                 /* lengths */,\n                          const unsigned char **         /* binaries */,\n                          cl_int *                       /* binary_status */,\n                          cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseProgram)(cl_program /* program */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clBuildProgram)(cl_program           /* program */,\n               cl_uint              /* num_devices */,\n               const cl_device_id * /* device_list */,\n               const char *         /* options */,\n               void (CL_CALLBACK *  /* pfn_notify */)(cl_program /* program */, void * /* user_data */),\n               void *               /* user_data */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetProgramInfo)(cl_program         /* program */,\n                 cl_program_info    /* param_name */,\n                 size_t             /* param_value_size */,\n                 void *             /* param_value */,\n                 size_t *           /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clGetProgramBuildInfo)(cl_program            /* program */,\n                      cl_device_id          /* device */,\n                      cl_program_build_info /* param_name */,\n                      size_t                /* param_value_size */,\n                      void *                /* param_value */,\n                      size_t *              /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Kernel Object APIs */\nextern\nCL_API_ENTRY cl_kernel CL_API_CALL\n(*clCreateKernel)(cl_program      /* program */,\n               const char *    /* kernel_name */,\n               cl_int *        /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clReleaseKernel)(cl_kernel   /* kernel */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clSetKernelArg)(cl_kernel    /* kernel */,\n               cl_uint      /* arg_index */,\n               size_t       /* arg_size */,\n               const void * /* arg_value */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Flush and Finish APIs */\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clFinish)(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n\n/* Enqueued Commands APIs */\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueReadBuffer)(cl_command_queue    /* command_queue */,\n                    cl_mem              /* buffer */,\n                    cl_bool             /* blocking_read */,\n                    size_t              /* offset */,\n                    size_t              /* size */,\n                    void *              /* ptr */,\n                    cl_uint             /* num_events_in_wait_list */,\n                    const cl_event *    /* event_wait_list */,\n                    cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueWriteBuffer)(cl_command_queue   /* command_queue */,\n                     cl_mem             /* buffer */,\n                     cl_bool            /* blocking_write */,\n                     size_t             /* offset */,\n                     size_t             /* size */,\n                     const void *       /* ptr */,\n                     cl_uint            /* num_events_in_wait_list */,\n                     const cl_event *   /* event_wait_list */,\n                     cl_event *         /* event */) CL_API_SUFFIX__VERSION_1_0;\n\nextern\nCL_API_ENTRY cl_int CL_API_CALL\n(*clEnqueueNDRangeKernel)(cl_command_queue /* command_queue */,\n                       cl_kernel        /* kernel */,\n                       cl_uint          /* work_dim */,\n                       const size_t *   /* global_work_offset */,\n                       const size_t *   /* global_work_size */,\n                       const size_t *   /* local_work_size */,\n                       cl_uint          /* num_events_in_wait_list */,\n                       const cl_event * /* event_wait_list */,\n                       cl_event *       /* event */) CL_API_SUFFIX__VERSION_1_0;\n\nint opt_platform_id = -1;\n\nFILE *opencl_open_kernel(const char * const filename)\n{\n\tchar *fullpath = alloca(PATH_MAX);\n\tFILE *f;\n\n\t/* Try in the optional kernel path or installed prefix first */\n\tf = open_bitstream(\"opencl\", filename);\n\tif (!f) {\n\t\t/* Then try from the path BFGMiner was called */\n\t\tstrcpy(fullpath, cgminer_path);\n\t\tstrcat(fullpath, filename);\n\t\tf = fopen(fullpath, \"rb\");\n\t}\n\t/* Finally try opening it directly */\n\tif (!f)\n\t\tf = fopen(filename, \"rb\");\n\t\n\treturn f;\n}\n\nchar *file_contents(const char *filename, int *length)\n{\n\tvoid *buffer;\n\tFILE *f;\n\n\tf = opencl_open_kernel(filename);\n\n\tif (!f) {\n\t\tapplog(LOG_ERR, \"Unable to open %s for reading\", filename);\n\t\treturn NULL;\n\t}\n\n\tfseek(f, 0, SEEK_END);\n\t*length = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\tbuffer = malloc(*length+1);\n\t*length = fread(buffer, 1, *length, f);\n\tfclose(f);\n\t((char*)buffer)[*length] = '\\0';\n\n\treturn (char*)buffer;\n}\n\nstatic\nvoid extract_word(char * const buf, const size_t bufsz, const char ** const endptr, const char *s)\n{\n\tconst char *q;\n\tfor ( ; s[0] && isspace(s[0]); ++s)\n\t\tif (s[0] == '\\n' || s[0] == '\\r')\n\t\t\tbreak;\n\tfor (q = s; q[0] && !isspace(q[0]); ++q)\n\t{}  // Find end of string\n\tsize_t len = q - s;\n\tif (len >= bufsz)\n\t\tlen = bufsz - 1;\n\tmemcpy(buf, s, len);\n\tbuf[len] = '\\0';\n\tif (endptr)\n\t\t*endptr = q;\n}\n\nchar *opencl_kernel_source(const char * const filename, int * const out_sourcelen, enum cl_kernels * const out_kinterface, struct mining_algorithm ** const out_malgo)\n{\n\tchar *source = file_contents(filename, out_sourcelen);\n\tif (!source)\n\t\treturn NULL;\n\tchar *s = strstr(source, \"kernel-interface:\");\n\tif (s)\n\t{\n\t\tconst char *q;\n\t\tchar buf[0x20];\n\t\textract_word(buf, sizeof(buf), &q, &s[17]);\n\t\t*out_kinterface = select_kernel(buf);\n\t\t\n\t\tif (out_malgo && (q[0] == '\\t' || q[0] == ' '))\n\t\t{\n\t\t\textract_word(buf, sizeof(buf), &q, q);\n\t\t\t*out_malgo = mining_algorithm_by_alias(buf);\n\t\t}\n\t}\n\telse\n\t\t*out_kinterface = KL_NONE;\n\treturn source;\n}\n\nextern int opt_g_threads;\n\nint clDevicesNum(void) {\n\tcl_int status;\n\tchar pbuff[256];\n\tcl_uint numDevices;\n\tcl_uint numPlatforms;\n\tint most_devices = -1;\n\tcl_platform_id *platforms;\n\tcl_platform_id platform = NULL;\n\tunsigned int i, mdplatform = 0;\n\tbool mdmesa = false;\n\n\tstatus = clGetPlatformIDs(0, NULL, &numPlatforms);\n\t/* If this fails, assume no GPUs. */\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: clGetPlatformsIDs failed (no OpenCL SDK installed?)\", status);\n\t\treturn -1;\n\t}\n\n\tif (numPlatforms == 0) {\n\t\tapplog(LOG_ERR, \"clGetPlatformsIDs returned no platforms (no OpenCL SDK installed?)\");\n\t\treturn -1;\n\t}\n\n\tplatforms = (cl_platform_id *)alloca(numPlatforms*sizeof(cl_platform_id));\n\tstatus = clGetPlatformIDs(numPlatforms, platforms, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Getting Platform Ids. (clGetPlatformsIDs)\", status);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < numPlatforms; i++) {\n\t\tif (opt_platform_id >= 0 && (int)i != opt_platform_id)\n\t\t\tcontinue;\n\n\t\tstatus = clGetPlatformInfo( platforms[i], CL_PLATFORM_VENDOR, sizeof(pbuff), pbuff, NULL);\n\t\tif (status != CL_SUCCESS) {\n\t\t\tapplog(LOG_ERR, \"Error %d: Getting Platform Info. (clGetPlatformInfo)\", status);\n\t\t\treturn -1;\n\t\t}\n\t\tplatform = platforms[i];\n\t\tapplog(LOG_INFO, \"CL Platform %d vendor: %s\", i, pbuff);\n\t\tstatus = clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(pbuff), pbuff, NULL);\n\t\tif (status == CL_SUCCESS)\n\t\t\tapplog(LOG_INFO, \"CL Platform %d name: %s\", i, pbuff);\n\t\tstatus = clGetPlatformInfo(platform, CL_PLATFORM_VERSION, sizeof(pbuff), pbuff, NULL);\n\t\tif (status == CL_SUCCESS)\n\t\t\tapplog(LOG_INFO, \"CL Platform %d version: %s\", i, pbuff);\n\t\tstatus = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &numDevices);\n\t\tif (status != CL_SUCCESS) {\n\t\t\tapplog(LOG_INFO, \"Error %d: Getting Device IDs (num)\", status);\n\t\t\tcontinue;\n\t\t}\n\t\tapplog(LOG_INFO, \"Platform %d devices: %d\", i, numDevices);\n\t\tif ((int)numDevices > most_devices) {\n\t\t\tmost_devices = numDevices;\n\t\t\tmdplatform = i;\n\t\t\tmdmesa = strstr(pbuff, \"MESA\");\n\t\t}\n\t\tif (numDevices) {\n\t\t\tunsigned int j;\n\t\t\tcl_device_id *devices = (cl_device_id *)malloc(numDevices*sizeof(cl_device_id));\n\n\t\t\tclGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);\n\t\t\tfor (j = 0; j < numDevices; j++) {\n\t\t\t\tclGetDeviceInfo(devices[j], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);\n\t\t\t\tapplog(LOG_INFO, \"\\t%i\\t%s\", j, pbuff);\n\t\t\t}\n\t\t\tfree(devices);\n\t\t}\n\t}\n\n\tif (opt_platform_id < 0)\n\t\topt_platform_id = mdplatform;\n\tif (mdmesa && opt_g_threads == -1)\n\t\topt_g_threads = 1;\n\n\treturn most_devices;\n}\n\ncl_int bfg_clBuildProgram(cl_program * const program, const cl_device_id devid, const char * const CompilerOptions)\n{\n\tcl_int status;\n\t\n\tstatus = clBuildProgram(*program, 1, &devid, CompilerOptions, NULL, NULL);\n\t\n\tif (status != CL_SUCCESS)\n\t{\n\t\tapplog(LOG_ERR, \"Error %d: Building Program (clBuildProgram)\", status);\n\t\tsize_t logSize;\n\t\tstatus = clGetProgramBuildInfo(*program, devid, CL_PROGRAM_BUILD_LOG, 0, NULL, &logSize);\n\t\t\n\t\tchar *log = malloc(logSize ?: 1);\n\t\tstatus = clGetProgramBuildInfo(*program, devid, CL_PROGRAM_BUILD_LOG, logSize, log, NULL);\n\t\tif (logSize > 0 && log[0])\n\t\t\tapplog(LOG_ERR, \"%s\", log);\n\t\tfree(log);\n\t}\n\t\n\treturn status;\n}\n\nstatic int advance(char **area, unsigned *remaining, const char *marker)\n{\n\tchar *find = memmem(*area, *remaining, marker, strlen(marker));\n\n\tif (!find) {\n\t\tapplog(LOG_DEBUG, \"Marker \\\"%s\\\" not found\", marker);\n\t\treturn 0;\n\t}\n\t*remaining -= find - *area;\n\t*area = find;\n\treturn 1;\n}\n\n#define OP3_INST_BFE_UINT\t4ULL\n#define OP3_INST_BFE_INT\t5ULL\n#define OP3_INST_BFI_INT\t6ULL\n#define OP3_INST_BIT_ALIGN_INT\t12ULL\n#define OP3_INST_BYTE_ALIGN_INT\t13ULL\n\nvoid patch_opcodes(char *w, unsigned remaining)\n{\n\tuint64_t *opcode = (uint64_t *)w;\n\tint patched = 0;\n\tint count_bfe_int = 0;\n\tint count_bfe_uint = 0;\n\tint count_byte_align = 0;\n\twhile (42) {\n\t\tint clamp = (*opcode >> (32 + 31)) & 0x1;\n\t\tint dest_rel = (*opcode >> (32 + 28)) & 0x1;\n\t\tint alu_inst = (*opcode >> (32 + 13)) & 0x1f;\n\t\tint s2_neg = (*opcode >> (32 + 12)) & 0x1;\n\t\tint s2_rel = (*opcode >> (32 + 9)) & 0x1;\n\t\tint pred_sel = (*opcode >> 29) & 0x3;\n\t\tif (!clamp && !dest_rel && !s2_neg && !s2_rel && !pred_sel) {\n\t\t\tif (alu_inst == OP3_INST_BFE_INT) {\n\t\t\t\tcount_bfe_int++;\n\t\t\t} else if (alu_inst == OP3_INST_BFE_UINT) {\n\t\t\t\tcount_bfe_uint++;\n\t\t\t} else if (alu_inst == OP3_INST_BYTE_ALIGN_INT) {\n\t\t\t\tcount_byte_align++;\n\t\t\t\t// patch this instruction to BFI_INT\n\t\t\t\t*opcode &= 0xfffc1fffffffffffULL;\n\t\t\t\t*opcode |= OP3_INST_BFI_INT << (32 + 13);\n\t\t\t\tpatched++;\n\t\t\t}\n\t\t}\n\t\tif (remaining <= 8)\n\t\t\tbreak;\n\t\topcode++;\n\t\tremaining -= 8;\n\t}\n\tapplog(LOG_DEBUG, \"Potential OP3 instructions identified: \"\n\t\t\"%i BFE_INT, %i BFE_UINT, %i BYTE_ALIGN\",\n\t\tcount_bfe_int, count_bfe_uint, count_byte_align);\n\tapplog(LOG_DEBUG, \"Patched a total of %i BFI_INT instructions\", patched);\n}\n\n_clState *opencl_create_clState(unsigned int gpu, char *name, size_t nameSize)\n{\n\t_clState *clState = calloc(1, sizeof(_clState));\n\tstruct cgpu_info *cgpu = &gpus[gpu];\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tcl_platform_id platform = NULL;\n\tchar pbuff[256], vbuff[255];\n\tchar *s;\n\tcl_platform_id* platforms;\n\tcl_device_id *devices;\n\tcl_uint numPlatforms;\n\tcl_uint numDevices;\n\tcl_int status;\n\n\tstatus = clGetPlatformIDs(0, NULL, &numPlatforms);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Getting Platforms. (clGetPlatformsIDs)\", status);\nerr:\n\t\tfree(clState);\n\t\treturn NULL;\n\t}\n\n\tplatforms = (cl_platform_id *)alloca(numPlatforms*sizeof(cl_platform_id));\n\tstatus = clGetPlatformIDs(numPlatforms, platforms, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Getting Platform Ids. (clGetPlatformsIDs)\", status);\n\t\tgoto err;\n\t}\n\n\tif (opt_platform_id >= (int)numPlatforms) {\n\t\tapplog(LOG_ERR, \"Specified platform that does not exist\");\n\t\tgoto err;\n\t}\n\n\tstatus = clGetPlatformInfo(platforms[opt_platform_id], CL_PLATFORM_VENDOR, sizeof(pbuff), pbuff, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Getting Platform Info. (clGetPlatformInfo)\", status);\n\t\tgoto err;\n\t}\n\tplatform = platforms[opt_platform_id];\n\n\tif (platform == NULL) {\n\t\tperror(\"NULL platform found!\\n\");\n\t\tgoto err;\n\t}\n\n\tapplog(LOG_INFO, \"CL Platform vendor: %s\", pbuff);\n\tstatus = clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(pbuff), pbuff, NULL);\n\tif (status == CL_SUCCESS)\n\t\tapplog(LOG_INFO, \"CL Platform name: %s\", pbuff);\n\tstatus = clGetPlatformInfo(platform, CL_PLATFORM_VERSION, sizeof(vbuff), vbuff, NULL);\n\tif (status == CL_SUCCESS)\n\t\tapplog(LOG_INFO, \"CL Platform version: %s\", vbuff);\n\tclState->platform_ver_str = strdup(vbuff);\n\n\tstatus = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &numDevices);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Getting Device IDs (num)\", status);\n\t\tgoto err;\n\t}\n\n\tif (numDevices <= 0)\n\t\tgoto err;\n\t\n\t{\n\t\tdevices = (cl_device_id *)malloc(numDevices*sizeof(cl_device_id));\n\n\t\t/* Now, get the device list data */\n\n\t\tstatus = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);\n\t\tif (status != CL_SUCCESS) {\n\t\t\tapplog(LOG_ERR, \"Error %d: Getting Device IDs (list)\", status);\nerr2:\n\t\t\tfree(devices);\n\t\t\tgoto err;\n\t\t}\n\n\t\tapplog(LOG_INFO, \"List of devices:\");\n\n\t\tunsigned int i;\n\t\tfor (i = 0; i < numDevices; i++) {\n\t\t\tstatus = clGetDeviceInfo(devices[i], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);\n\t\t\tif (status != CL_SUCCESS) {\n\t\t\t\tapplog(LOG_ERR, \"Error %d: Getting Device Info\", status);\n\t\t\t\tgoto err2;\n\t\t\t}\n\n\t\t\tapplog(LOG_INFO, \"\\t%i\\t%s\", i, pbuff);\n\t\t}\n\n\t\tif (gpu < numDevices) {\n\t\t\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);\n\t\t\tif (status != CL_SUCCESS) {\n\t\t\t\tapplog(LOG_ERR, \"Error %d: Getting Device Info\", status);\n\t\t\t\tgoto err2;\n\t\t\t}\n\n\t\t\tapplog(LOG_INFO, \"Selected %i: %s\", gpu, pbuff);\n\t\t\tstrncpy(name, pbuff, nameSize);\n\t\t} else {\n\t\t\tapplog(LOG_ERR, \"Invalid GPU %i\", gpu);\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\tcl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)platform, 0 };\n\n\tclState->context = clCreateContextFromType(cps, CL_DEVICE_TYPE_GPU, NULL, NULL, &status);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Creating Context. (clCreateContextFromType)\", status);\n\t\tgoto err2;\n\t}\n\n\t/////////////////////////////////////////////////////////////////\n\t// Create an OpenCL command queue\n\t/////////////////////////////////////////////////////////////////\n\tclState->commandQueue = clCreateCommandQueue(clState->context, devices[gpu],\n\t\t\t\t\t\t     CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &status);\n\tif (status != CL_SUCCESS) /* Try again without OOE enable */\n\t\tclState->commandQueue = clCreateCommandQueue(clState->context, devices[gpu], 0 , &status);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Creating Command Queue. (clCreateCommandQueue)\", status);\n\t\tgoto err2;\n\t}\n\n\t/* Check for BFI INT support. Hopefully people don't mix devices with\n\t * and without it! */\n\tchar * extensions = malloc(1024);\n\tconst char * camo = \"cl_amd_media_ops\";\n\tchar *find;\n\n\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_EXTENSIONS, 1024, (void *)extensions, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_EXTENSIONS\", status);\n\t\tfree(extensions);\n\t\tgoto err2;\n\t}\n\tfind = strstr(extensions, camo);\n\tif (find)\n\t\tclState->hasBitAlign = true;\n\tfree(extensions);\n\n\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, sizeof(cl_uint), (void *)&clState->preferred_vwidth, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT\", status);\n\t\tgoto err2;\n\t}\n\tapplog(LOG_DEBUG, \"Preferred vector width reported %d\", clState->preferred_vwidth);\n\n\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), (void *)&clState->max_work_size, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_WORK_GROUP_SIZE\", status);\n\t\tgoto err2;\n\t}\n\tapplog(LOG_DEBUG, \"Max work group size reported %\"PRId64, (int64_t)clState->max_work_size);\n\n\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(clState->max_compute_units), (void *)&clState->max_compute_units, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_COMPUTE_UNITS\", status);\n\t\tgoto err2;\n\t}\n\tif (data->_init_intensity)\n\t{\n\t\tdata->oclthreads = 1;  // Needed to ensure we don't just try to re-save the string (which would free before strduping and segfault anyway)\n\t\topencl_set_intensity_from_str(cgpu, data->_init_intensity);\n\t}\n\telse\n\t{\n\t\tdata->oclthreads = 1;\n\t\tdata->intensity = INT_MIN;\n\t}\n\tapplog(LOG_DEBUG, \"Max compute units reported %u\", (unsigned)clState->max_compute_units);\n\t\n\tstatus = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_MEM_ALLOC_SIZE , sizeof(cl_ulong), (void *)&data->max_alloc, NULL);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_MEM_ALLOC_SIZE\", status);\n\t\tgoto err2;\n\t}\n\tapplog(LOG_DEBUG, \"Max mem alloc size is %lu\", (unsigned long)data->max_alloc);\n\t\n\tfind = strstr(vbuff, \"MESA\");\n\tif (find)\n\t{\n\t\tlong int major = strtol(&find[4], &s, 10), minor = 0;\n\t\tif (!major)\n\t\t{} // No version number at all\n\t\telse\n\t\tif (s[0] == '.')\n\t\t\tminor = strtol(&s[1], NULL, 10);\n\t\tif (major < 10 || (major == 10 && minor < 1))\n\t\t{\n\t\t\tif (data->opt_opencl_binaries == OBU_DEFAULT)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Mesa OpenCL platform detected (v%ld.%ld), disabling OpenCL kernel binaries and bitalign\", major, minor);\n\t\t\t\tdata->opt_opencl_binaries = OBU_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t\tapplog(LOG_DEBUG, \"Mesa OpenCL platform detected (v%ld.%ld), disabling bitalign\", major, minor);\n\t\t\tclState->hasBitAlign = false;\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_DEBUG, \"Mesa OpenCL platform detected (v%ld.%ld)\", major, minor);\n\t\tclState->is_mesa = true;\n\t}\n\t\n\tif (data->opt_opencl_binaries == OBU_DEFAULT)\n\t{\n#ifdef __APPLE__\n\t\t// Apple OpenCL doesn't like using binaries this way\n\t\tdata->opt_opencl_binaries = OBU_NONE;\n#else\n\t\tdata->opt_opencl_binaries = OBU_LOADSAVE;\n#endif\n\t}\n\t\n\tclState->devid = devices[gpu];\n\tfree(devices);\n\t\n\t/* For some reason 2 vectors is still better even if the card says\n\t * otherwise, and many cards lie about their max so use 256 as max\n\t * unless explicitly set on the command line. Tahiti prefers 1 */\n\tif (strstr(name, \"Tahiti\"))\n\t\tclState->preferred_vwidth = 1;\n\telse\n\tif (clState->preferred_vwidth > 2)\n\t\tclState->preferred_vwidth = 2;\n\n\tif (data->vwidth)\n\t\tclState->vwidth = data->vwidth;\n\telse {\n\t\tclState->vwidth = clState->preferred_vwidth;\n\t\tdata->vwidth = clState->preferred_vwidth;\n\t}\n\n\tclState->outputBuffer = clCreateBuffer(clState->context, 0, OPENCL_MAX_BUFFERSIZE, NULL, &status);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: clCreateBuffer (outputBuffer)\", status);\n\t\t// NOTE: devices is freed here, but still assigned\n\t\tgoto err;\n\t}\n\t\n\treturn clState;\n}\n\nstatic\nbool opencl_load_kernel_binary(struct cgpu_info * const cgpu, _clState * const clState, struct opencl_kernel_info * const kernelinfo, const char * const binaryfilename, bytes_t * const b)\n{\n\tcl_int status;\n\t\n\tFILE * const binaryfile = fopen(binaryfilename, \"rb\");\n\tif (!binaryfile)\n\t\treturn false;\n\t\n\tstruct stat binary_stat;\n\tif (unlikely(stat(binaryfilename, &binary_stat)))\n\t{\n\t\tapplog(LOG_DEBUG, \"Unable to stat binary, generating from source\");\n\t\tfclose(binaryfile);\n\t\treturn false;\n\t}\n\tif (!binary_stat.st_size)\n\t{\n\t\tfclose(binaryfile);\n\t\treturn false;\n\t}\n\t\n\tconst size_t binsz = binary_stat.st_size;\n\tbytes_resize(b, binsz);\n\tif (fread(bytes_buf(b), 1, binsz, binaryfile) != binsz)\n\t{\n\t\tapplog(LOG_ERR, \"Unable to fread binaries\");\n\t\tfclose(binaryfile);\n\t\treturn false;\n\t}\n\tfclose(binaryfile);\n\t\n\tkernelinfo->program = clCreateProgramWithBinary(clState->context, 1, &clState->devid, &binsz, (void*)&bytes_buf(b), &status, NULL);\n\tif (status != CL_SUCCESS)\n\t\tapplogr(false, LOG_ERR, \"Error %d: Loading Binary into cl_program (clCreateProgramWithBinary)\", status);\n\t\n\tstatus = bfg_clBuildProgram(&kernelinfo->program, clState->devid, NULL);\n\tif (status != CL_SUCCESS)\n\t\treturn false;\n\t\n\tapplog(LOG_DEBUG, \"Loaded binary image %s\", binaryfilename);\n\treturn true;\n}\n\nstatic\nbool opencl_should_patch_bfi_int(struct cgpu_info * const cgpu, _clState * const clState, struct opencl_kernel_info * const kernelinfo)\n{\n#ifdef USE_SHA256D\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tconst char * const name = cgpu->name;\n\tconst char * const vbuff = clState->platform_ver_str;\n\tchar *s;\n\t\n\tif (!clState->hasBitAlign)\n\t\treturn false;\n\t\n\tif (!(strstr(name, \"Cedar\") ||\n\t      strstr(name, \"Redwood\") ||\n\t      strstr(name, \"Juniper\") ||\n\t      strstr(name, \"Cypress\" ) ||\n\t      strstr(name, \"Hemlock\" ) ||\n\t      strstr(name, \"Caicos\" ) ||\n\t      strstr(name, \"Turks\" ) ||\n\t      strstr(name, \"Barts\" ) ||\n\t      strstr(name, \"Cayman\" ) ||\n\t      strstr(name, \"Antilles\" ) ||\n\t      strstr(name, \"Wrestler\" ) ||\n\t      strstr(name, \"Zacate\" ) ||\n\t      strstr(name, \"WinterPark\" )))\n\t\treturn false;\n\t\n\t// BFI_INT patching only works with AMD-APP up to 1084\n\tif (strstr(vbuff, \"ATI-Stream\"))\n\t{}\n\telse\n\tif ((s = strstr(vbuff, \"AMD-APP\")) && (s = strchr(s, '(')) && atoi(&s[1]) < 1085)\n\t{}\n\telse\n\t\treturn false;\n\t\n\tswitch (kernelinfo->interface)\n\t{\n\t\tcase KL_DIABLO: case KL_DIAKGCN: case KL_PHATK: case KL_POCLBM:\n\t\t\t// Okay, these actually use BFI_INT hacking\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Anything else has never needed it\n\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\t\n\tif (data->opt_opencl_binaries != OBU_LOADSAVE)\n\t\tapplogr(false, LOG_WARNING, \"BFI_INT patch requiring device found, but OpenCL binary usage disabled; cannot BFI_INT patch\");\n\t\n\tapplog(LOG_DEBUG, \"BFI_INT patch requiring device found, will patch source with BFI_INT\");\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic\nbool opencl_build_kernel(struct cgpu_info * const cgpu, _clState * const clState, struct opencl_kernel_info * const kernelinfo, const char *source, const size_t source_len, const bool patchbfi)\n{\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tcl_int status;\n\t\n\tkernelinfo->program = clCreateProgramWithSource(clState->context, 1, &source, &source_len, &status);\n\tif (status != CL_SUCCESS)\n\t\tapplogr(false, LOG_ERR, \"Error %d: Loading Binary into cl_program (clCreateProgramWithSource)\", status);\n\n\t/* create a cl program executable for all the devices specified */\n\tchar *CompilerOptions = calloc(1, 256);\n\n#ifdef USE_SCRYPT\n\tif (kernelinfo->interface == KL_SCRYPT)\n\t\tsprintf(CompilerOptions, \"-D LOOKUP_GAP=%d -D CONCURRENT_THREADS=%d -D WORKSIZE=%d\",\n\t\t\tdata->lookup_gap, (unsigned int)data->thread_concurrency, (int)kernelinfo->wsize);\n\telse\n#endif\n\t{\n\t\tsprintf(CompilerOptions, \"-D WORKSIZE=%d -D VECTORS%d -D WORKVEC=%d\",\n\t\t\t(int)kernelinfo->wsize, clState->vwidth, (int)kernelinfo->wsize * clState->vwidth);\n\t}\n\tapplog(LOG_DEBUG, \"Setting worksize to %\"PRId64, (int64_t)kernelinfo->wsize);\n\tif (clState->vwidth > 1)\n\t\tapplog(LOG_DEBUG, \"Patched source to suit %d vectors\", clState->vwidth);\n\n\tif (clState->hasBitAlign)\n\t{\n\t\tstrcat(CompilerOptions, \" -D BITALIGN\");\n\t\tapplog(LOG_DEBUG, \"cl_amd_media_ops found, setting BITALIGN\");\n\t}\n\telse\n\t\tapplog(LOG_DEBUG, \"cl_amd_media_ops not found, will not set BITALIGN\");\n\n#ifdef USE_SHA256D\n\tif (patchbfi)\n\t\tstrcat(CompilerOptions, \" -D BFI_INT\");\n#endif\n\n\tif (kernelinfo->goffset)\n\t\tstrcat(CompilerOptions, \" -D GOFFSET\");\n\n\tapplog(LOG_DEBUG, \"CompilerOptions: %s\", CompilerOptions);\n\tstatus = bfg_clBuildProgram(&kernelinfo->program, clState->devid, CompilerOptions);\n\tfree(CompilerOptions);\n\n\tif (status != CL_SUCCESS)\n\t\treturn false;\n\t\n\treturn true;\n}\n\nstatic\nbool opencl_get_kernel_binary(struct cgpu_info * const cgpu, _clState * const clState, struct opencl_kernel_info * const kernelinfo, bytes_t * const b)\n{\n\tcl_int status;\n\tcl_uint slot, cpnd;\n\t\n\tstatus = clGetProgramInfo(kernelinfo->program, CL_PROGRAM_NUM_DEVICES, sizeof(cl_uint), &cpnd, NULL);\n\tif (unlikely(status != CL_SUCCESS))\n\t\tapplogr(false, LOG_ERR, \"Error %d: Getting program info CL_PROGRAM_NUM_DEVICES. (clGetProgramInfo)\", status);\n\t\n\tif (!cpnd)\n\t\treturn false;\n\n\tsize_t binary_sizes[cpnd];\n\tstatus = clGetProgramInfo(kernelinfo->program, CL_PROGRAM_BINARY_SIZES, sizeof(binary_sizes), binary_sizes, NULL);\n\tif (unlikely(status != CL_SUCCESS))\n\t\tapplogr(false, LOG_ERR, \"Error %d: Getting program info CL_PROGRAM_BINARY_SIZES. (clGetProgramInfo)\", status);\n\t\n\tuint8_t **binaries = malloc(sizeof(*binaries) * cpnd);\n\tfor (slot = 0; slot < cpnd; ++slot)\n\t\tbinaries[slot] = malloc(binary_sizes[slot] + 1);\n\n\t/* The actual compiled binary ends up in a RANDOM slot! Grr, so we have\n\t * to iterate over all the binary slots and find where the real program\n\t * is. What the heck is this!? */\n\tfor (slot = 0; slot < cpnd; slot++)\n\t\tif (binary_sizes[slot])\n\t\t\tbreak;\n\n\t/* copy over all of the generated binaries. */\n\tapplog(LOG_DEBUG, \"%s: Binary size found in binary slot %u: %\"PRId64, cgpu->dev_repr, (unsigned)slot, (int64_t)binary_sizes[slot]);\n\tif (!binary_sizes[slot])\n\t\tapplogr(false, LOG_ERR, \"OpenCL compiler generated a zero sized binary, FAIL!\");\n\tstatus = clGetProgramInfo(kernelinfo->program, CL_PROGRAM_BINARIES, sizeof(binaries), binaries, NULL);\n\tif (unlikely(status != CL_SUCCESS))\n\t\tapplogr(false, LOG_ERR, \"Error %d: Getting program info. CL_PROGRAM_BINARIES (clGetProgramInfo)\", status);\n\t\n\tbytes_resize(b, binary_sizes[slot]);\n\tmemcpy(bytes_buf(b), binaries[slot], bytes_len(b));\n\t\n\tfor (slot = 0; slot < cpnd; ++slot)\n\t\tfree(binaries[slot]);\n\tfree(binaries);\n\t\n\treturn true;\n}\n\n#ifdef USE_SHA256D\n\t/* Patch the kernel if the hardware supports BFI_INT but it needs to\n\t * be hacked in */\nstatic\nbool opencl_patch_kernel_binary(bytes_t * const b)\n{\n\tunsigned remaining = bytes_len(b);\n\tchar *w = (void*)bytes_buf(b);\n\tunsigned int start, length;\n\n\t/* Find 2nd incidence of .text, and copy the program's\n\t* position and length at a fixed offset from that. Then go\n\t* back and find the 2nd incidence of \\x7ELF (rewind by one\n\t* from ELF) and then patch the opcocdes */\n\tif (!advance(&w, &remaining, \".text\"))\n\t\treturn false;\n\tw++; remaining--;\n\tif (!advance(&w, &remaining, \".text\")) {\n\t\t/* 32 bit builds only one ELF */\n\t\tw--; remaining++;\n\t}\n\tmemcpy(&start, w + 285, 4);\n\tmemcpy(&length, w + 289, 4);\n\tw = (void*)bytes_buf(b);\n\tremaining = bytes_len(b);\n\tif (!advance(&w, &remaining, \"ELF\"))\n\t\treturn false;\n\tw++; remaining--;\n\tif (!advance(&w, &remaining, \"ELF\")) {\n\t\t/* 32 bit builds only one ELF */\n\t\tw--; remaining++;\n\t}\n\tw--; remaining++;\n\tw += start; remaining -= start;\n\tapplog(LOG_DEBUG, \"At %p (%u rem. bytes), to begin patching\", w, remaining);\n\tpatch_opcodes(w, length);\n\treturn true;\n}\n\nstatic\nbool opencl_replace_binary_kernel(struct cgpu_info * const cgpu, _clState * const clState, struct opencl_kernel_info * const kernelinfo, bytes_t * const b)\n{\n\tcl_int status;\n\t\n\tstatus = clReleaseProgram(kernelinfo->program);\n\tif (status != CL_SUCCESS)\n\t\tapplogr(false, LOG_ERR, \"Error %d: Releasing program. (clReleaseProgram)\", status);\n\t\n\tconst size_t binsz = bytes_len(b);\n\tkernelinfo->program = clCreateProgramWithBinary(clState->context, 1, &clState->devid, &binsz, (void*)&bytes_buf(b), &status, NULL);\n\tif (status != CL_SUCCESS)\n\t\tapplogr(false, LOG_ERR, \"Error %d: Loading Binary into cl_program (clCreateProgramWithBinary)\", status);\n\t\n\tstatus = bfg_clBuildProgram(&kernelinfo->program, clState->devid, NULL);\n\tif (status != CL_SUCCESS)\n\t\treturn false;\n\t\n\treturn true;\n}\n#endif\n\nstatic\nbool opencl_save_kernel_binary(const char * const binaryfilename, bytes_t * const b)\n{\n\tFILE *binaryfile;\n\t\n\t/* Save the binary to be loaded next time */\n\tbinaryfile = fopen(binaryfilename, \"wb\");\n\tif (!binaryfile)\n\t\treturn false;\n\t\n\t// FIXME: Failure here results in a bad file; better to write and move-replace (but unlink before replacing for Windows)\n\tif (unlikely(fwrite(bytes_buf(b), 1, bytes_len(b), binaryfile) != bytes_len(b)))\n\t{\n\t\tfclose(binaryfile);\n\t\treturn false;\n\t}\n\t\n\tfclose(binaryfile);\n\treturn true;\n}\n\nstatic\nbool opencl_test_goffset(_clState * const clState)\n{\n\tif (sizeof(size_t) < sizeof(uint32_t))\n\t\treturn false;\n\t\n\tconst char *source = \"__kernel __attribute__((reqd_work_group_size(64, 1, 1))) void runtest(volatile __global uint *out) { *out = get_global_id(0); }\";\n\tconst size_t source_len = strlen(source);\n\tcl_int status;\n\tcl_program program = clCreateProgramWithSource(clState->context, 1, &source, &source_len, &status);\n\tif (status != CL_SUCCESS)\n\t\tapplogr(false, LOG_ERR, \"Error %d: Loading %s code into cl_program (clCreateProgramWithSource)\", status, \"goffset test\");\n\tstatus = bfg_clBuildProgram(&program, clState->devid, \"\");\n\tif (status != CL_SUCCESS)\n\t{\nfail:\n\t\tclReleaseProgram(program);\n\t\treturn false;\n\t}\n\tcl_kernel kernel = clCreateKernel(program, \"runtest\", &status);\n\tif (status != CL_SUCCESS)\n\t\treturn_via_applog(fail, , LOG_ERR, \"Error %d: Creating kernel from %s program (clCreateKernel)\", status, \"goffset test\");\n\tstatic const uint32_t cleardata = 0;\n\tstatus = clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0, sizeof(cleardata), &cleardata, 0, NULL, NULL);\n\tif (status != CL_SUCCESS)\n\t{\n\t\tapplog(LOG_ERR, \"Error %d: Clearing output buffer for %s kernel (clEnqueueWriteBuffer)\", status, \"goffset test\");\nfail2:\n\t\tclReleaseKernel(kernel);\n\t\tgoto fail;\n\t}\n\tstatus = clSetKernelArg(kernel, 0, sizeof(clState->outputBuffer), &clState->outputBuffer);\n\tif (status != CL_SUCCESS)\n\t\treturn_via_applog(fail2, , LOG_ERR, \"Error %d: Setting kernel argument for %s kernel (clSetKernelArg)\", status, \"goffset test\");\n\tconst size_t size_t_one = 1, test_goffset = 0xfabd0bf9;\n\tstatus = clEnqueueNDRangeKernel(clState->commandQueue, kernel, 1, &test_goffset, &size_t_one, &size_t_one, 0,  NULL, NULL);\n\tif (status != CL_SUCCESS)\n\t\treturn_via_applog(fail2, , LOG_DEBUG, \"Error %d: Running %s kernel (clEnqueueNDRangeKernel)\", status, \"goffset test\");\n\tuint32_t resultdata;\n\tstatus = clEnqueueReadBuffer(clState->commandQueue, clState->outputBuffer, CL_TRUE, 0, sizeof(resultdata), &resultdata, 0, NULL, NULL);\n\tif (status != CL_SUCCESS)\n\t\treturn_via_applog(fail2, , LOG_DEBUG, \"Error %d: Reading result from %s kernel (clEnqueueReadBuffer)\", status, \"goffset test\");\n\tapplog(LOG_DEBUG, \"%s kernel returned 0x%08lx for goffset 0x%08lx\", \"goffset test\", (unsigned long)resultdata, (unsigned long)test_goffset);\n\treturn (resultdata == test_goffset);\n}\n\nbool opencl_load_kernel(struct cgpu_info * const cgpu, _clState * const clState, const char * const name, struct opencl_kernel_info * const kernelinfo, const char * const kernel_file, __maybe_unused const struct mining_algorithm * const malgo)\n{\n\tconst int gpu = cgpu->device_id;\n\tstruct opencl_device_data * const data = cgpu->device_data;\n\tconst char * const vbuff = clState->platform_ver_str;\n\tcl_int status;\n\t\n\t/* Create binary filename based on parameters passed to opencl\n\t * compiler to ensure we only load a binary that matches what would\n\t * have otherwise created. The filename is:\n\t * kernelname + name +/- g(offset) + v + vectors + w + work_size + l + sizeof(long) + p + platform version + .bin\n\t * For scrypt the filename is:\n\t * kernelname + name + g + lg + lookup_gap + tc + thread_concurrency + w + work_size + l + sizeof(long) + p + platform version + .bin\n\t */\n\tchar binaryfilename[255];\n\tchar filename[255];\n\tchar numbuf[32];\n\n\tsnprintf(filename, sizeof(filename), \"%s.cl\", kernel_file);\n\tsnprintf(binaryfilename, sizeof(filename), \"%s\", kernel_file);\n\tint pl;\n\tchar *source = opencl_kernel_source(filename, &pl, &kernelinfo->interface, NULL);\n\tif (!source)\n\t\treturn false;\n\t{\n\t\tuint8_t hash[0x20];\n\t\tchar hashhex[7];\n\t\tsha256((void*)source, pl, hash);\n\t\tbin2hex(hashhex, hash, 3);\n\t\ttailsprintf(binaryfilename, sizeof(binaryfilename), \"-%s\", hashhex);\n\t}\n\tswitch (kernelinfo->interface)\n\t{\n\t\tcase KL_NONE:\n\t\t\tapplog(LOG_ERR, \"%s: Failed to identify kernel interface for %s\",\n\t\t\t       cgpu->dev_repr, kernel_file);\n\t\t\tfree(source);\n\t\t\treturn false;\n#ifdef USE_SHA256D\n\t\tcase KL_PHATK:\n\t\t\tif ((strstr(vbuff, \"844.4\") || strstr(vbuff, \"851.4\") ||\n\t\t\t     strstr(vbuff, \"831.4\") || strstr(vbuff, \"898.1\") ||\n\t\t\t     strstr(vbuff, \"923.1\") || strstr(vbuff, \"938.2\") ||\n\t\t\t     strstr(vbuff, \"1113.2\"))) {\n\t\t\t\tapplog(LOG_WARNING, \"WARNING: You have selected the phatk kernel.\");\n\t\t\t\tapplog(LOG_WARNING, \"You are running SDK 2.6+ which performs poorly with this kernel.\");\n\t\t\t\tapplog(LOG_WARNING, \"Downgrade your SDK and delete any .bin files before starting again.\");\n\t\t\t\tapplog(LOG_WARNING, \"Or allow BFGMiner to automatically choose a more suitable kernel.\");\n\t\t\t}\n#endif\n\t\tdefault:\n\t\t\t;\n\t}\n\tapplog(LOG_DEBUG, \"%s: Using kernel %s with interface %s\",\n\t       cgpu->dev_repr, kernel_file,\n\t       opencl_get_kernel_interface_name(kernelinfo->interface));\n\n\t{\n\t\tint kernel_goffset_support = 0;  // 0 = none; 1 = optional; 2 = required\n\t\tif (strstr(source, \"def GOFFSET\"))\n\t\t\tkernel_goffset_support = 1;\n\t\telse\n\t\tif (strstr(source, \" base,\"))\n\t\t\tkernel_goffset_support = 0;\n\t\telse\n\t\t\tkernel_goffset_support = 2;\n\t\tbool device_goffset_support = false;\n\t\tswitch (data->use_goffset)\n\t\t{\n\t\t\tcase BTS_TRUE:\n\t\t\t\tdevice_goffset_support = true;\n\t\t\t\tbreak;\n\t\t\tcase BTS_FALSE:\n\t\t\t\t// if the kernel requires goffset, don't allow the user to disable it\n\t\t\t\tif (kernel_goffset_support == 2)\n\t\t\t\t{\n\t\t\t\t\tif (opencl_test_goffset(clState))\n\t\t\t\t\t\tdevice_goffset_support = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BTS_UNKNOWN:\n\t\t\t\tdata->use_goffset = opencl_test_goffset(clState);\n\t\t\t\tif (data->use_goffset)\n\t\t\t\t\tdevice_goffset_support = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"%s: goffset support: device=%s kernel=%s\", cgpu->dev_repr, device_goffset_support ? \"yes\" : \"no\", (kernel_goffset_support == 2) ? \"required\" : ((kernel_goffset_support == 1) ? \"optional\" : \"none\"));\n\t\tif (device_goffset_support)\n\t\t{\n\t\t\tif (kernel_goffset_support)\n\t\t\t\tkernelinfo->goffset = true;\n\t\t}\n\t\telse\n\t\tif (kernel_goffset_support == 2)\n\t\t{\n\t\t\t// FIXME: Determine this before min_nonce_diff returns positive\n\t\t\tapplog(LOG_ERR, \"%s: Need goffset support!\", cgpu->dev_repr);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (data->work_size && data->work_size <= clState->max_work_size)\n\t\tkernelinfo->wsize = data->work_size;\n\telse\n#ifdef USE_SCRYPT\n\tif (malgo->algo == POW_SCRYPT)\n\t\tkernelinfo->wsize = 256;\n\telse\n#endif\n\tif (strstr(name, \"Tahiti\"))\n\t\tkernelinfo->wsize = 64;\n\telse\n\t\tkernelinfo->wsize = (clState->max_work_size <= 256 ? clState->max_work_size : 256) / clState->vwidth;\n\n#ifdef USE_SCRYPT\n\tif (kernelinfo->interface == KL_SCRYPT)\n\t{\n\t\tif (!data->thread_concurrency)\n\t\t{\n\t\t\tunsigned int sixtyfours;\n\n\t\t\tsixtyfours =  data->max_alloc / 131072 / 64 - 1;\n\t\t\tdata->thread_concurrency = sixtyfours * 64;\n\t\t\tif (data->shaders && data->thread_concurrency > data->shaders) {\n\t\t\t\tdata->thread_concurrency -= data->thread_concurrency % data->shaders;\n\t\t\t\tif (data->thread_concurrency > data->shaders * 5)\n\t\t\t\t\tdata->thread_concurrency = data->shaders * 5;\n\t\t\t}\n\t\t\tapplog(LOG_DEBUG, \"GPU %u: selecting thread concurrency of %lu\", gpu,  (unsigned long)data->thread_concurrency);\n\t\t}\n\t}\n#endif\n\n\tstrcat(binaryfilename, name);\n\tif (kernelinfo->goffset)\n\t\tstrcat(binaryfilename, \"g\");\n#ifdef USE_SCRYPT\n\tif (kernelinfo->interface == KL_SCRYPT)\n\t{\n\t\tsprintf(numbuf, \"lg%utc%u\", data->lookup_gap, (unsigned int)data->thread_concurrency);\n\t\tstrcat(binaryfilename, numbuf);\n\t}\n\telse\n#endif\n\t{\n\t\tsprintf(numbuf, \"v%d\", clState->vwidth);\n\t\tstrcat(binaryfilename, numbuf);\n\t}\n\tsprintf(numbuf, \"w%d\", (int)kernelinfo->wsize);\n\tstrcat(binaryfilename, numbuf);\n\tsprintf(numbuf, \"l%d\", (int)sizeof(long));\n\tstrcat(binaryfilename, numbuf);\n\tstrcat(binaryfilename, \"p\");\n\tstrcat(binaryfilename, vbuff);\n\tsanestr(binaryfilename, binaryfilename);\n\tapplog(LOG_DEBUG, \"OCL%2u: Configured OpenCL kernel name: %s\", gpu, binaryfilename);\n\tstrcat(binaryfilename, \".bin\");\n\t\n\tbool patchbfi = opencl_should_patch_bfi_int(cgpu, clState, kernelinfo);\n\t\n\tbytes_t binary_bytes = BYTES_INIT;\n\tbool loaded_kernel = false;\n\tif (data->opt_opencl_binaries & OBU_LOAD)\n\t{\n\t\tif (opencl_load_kernel_binary(cgpu, clState, kernelinfo, binaryfilename, &binary_bytes))\n\t\t\tloaded_kernel = true;\n\t\telse\n\t\t{\n\t\t\tbytes_free(&binary_bytes);\n\t\t\tapplog(LOG_DEBUG, \"No usable binary found, generating from source\");\n\t\t}\n\t}\n\t\n\tif (!loaded_kernel)\n\t{\nbuild:\n\t\tif (!opencl_build_kernel(cgpu, clState, kernelinfo, source, pl, patchbfi))\n\t\t{\n\t\t\tfree(source);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif ((patchbfi || (data->opt_opencl_binaries & OBU_SAVE)) && !bytes_len(&binary_bytes))\n\t\t{\n\t\t\tif (!opencl_get_kernel_binary(cgpu, clState, kernelinfo, &binary_bytes))\n\t\t\t{\n\t\t\t\tbytes_free(&binary_bytes);\n\t\t\t\tapplog(LOG_DEBUG, \"%s: Failed to get compiled kernel binary from OpenCL (cannot save it)\", cgpu->dev_repr);\n\t\t\t\t// NOTE: empty binary_bytes will fail BFI_INT patch on its own\n\t\t\t}\n\t\t}\n\t\t\n#ifdef USE_SHA256D\n\t\tif (patchbfi)\n\t\t{\n\t\t\tif (!(opencl_patch_kernel_binary(&binary_bytes)) && opencl_replace_binary_kernel(cgpu, clState, kernelinfo, &binary_bytes))\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"%s: BFI_INT patching failed, rebuilding without it\", cgpu->dev_repr);\n\t\t\t\tpatchbfi = false;\n\t\t\t\tbytes_free(&binary_bytes);\n\t\t\t\tgoto build;\n\t\t\t}\n\t\t}\n#endif\n\t\t\n\t\tif (data->opt_opencl_binaries & OBU_SAVE)\n\t\t{\n\t\t\tif (!opencl_save_kernel_binary(binaryfilename, &binary_bytes))\n\t\t\t\tapplog(LOG_DEBUG, \"Unable to save file %s\", binaryfilename);\n\t\t}\n\t}\n\t\n\tfree(source);\n\tbytes_free(&binary_bytes);\n\t\n\tapplog(LOG_INFO, \"Initialising kernel %s with%s bitalign, %\"PRId64\" vectors and worksize %\"PRIu64,\n\t       filename, clState->hasBitAlign ? \"\" : \"out\", (int64_t)clState->vwidth, (uint64_t)kernelinfo->wsize);\n\n\t/* get a kernel object handle for a kernel with the given name */\n\tkernelinfo->kernel = clCreateKernel(kernelinfo->program, \"search\", &status);\n\tif (status != CL_SUCCESS) {\n\t\tapplog(LOG_ERR, \"Error %d: Creating Kernel from program. (clCreateKernel)\", status);\n\t\treturn false;\n\t}\n\t\n\tfree((void*)cgpu->kname);\n\tcgpu->kname = strdup(kernel_file);\n\n#ifdef MAX_CLBUFFER0_SZ\n\tswitch (kernelinfo->interface)\n\t{\n#ifdef USE_SCRYPT\n\t\tcase KL_SCRYPT:\n\t\t\tif (!clState->padbufsize)\n\t\t\t{\n\t\t\t\tsize_t ipt = (1024 / data->lookup_gap + (1024 % data->lookup_gap > 0));\n\t\t\t\tsize_t bufsize = 128 * ipt * data->thread_concurrency;\n\n\t\t\t\t/* Use the max alloc value which has been rounded to a power of\n\t\t\t\t * 2 greater >= required amount earlier */\n\t\t\t\tif (bufsize > data->max_alloc) {\n\t\t\t\t\tapplog(LOG_WARNING, \"Maximum buffer memory device %d supports says %lu\", gpu, (unsigned long)data->max_alloc);\n\t\t\t\t\tapplog(LOG_WARNING, \"Your scrypt settings come to %lu\", (unsigned long)bufsize);\n\t\t\t\t}\n\t\t\t\tapplog(LOG_DEBUG, \"Creating scrypt buffer sized %lu\", (unsigned long)bufsize);\n\t\t\t\tclState->padbufsize = bufsize;\n\n\t\t\t\t/* This buffer is weird and might work to some degree even if\n\t\t\t\t * the create buffer call has apparently failed, so check if we\n\t\t\t\t * get anything back before we call it a failure. */\n\t\t\t\tclState->padbuffer8 = NULL;\n\t\t\t\tclState->padbuffer8 = clCreateBuffer(clState->context, CL_MEM_READ_WRITE, bufsize, NULL, &status);\n\t\t\t\tif (status != CL_SUCCESS && !clState->padbuffer8) {\n\t\t\t\t\tapplog(LOG_ERR, \"Error %d: clCreateBuffer (padbuffer8), decrease TC or increase LG\", status);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// NOTE: fallthru\n#endif\n#ifdef USE_OPENCL_FULLHEADER\n\t\tcase KL_FULLHEADER:\n#endif\n\t\t\tif (!clState->CLbuffer0)\n\t\t\t{\n\t\t\t\tclState->CLbuffer0 = clCreateBuffer(clState->context, CL_MEM_READ_ONLY, MAX_CLBUFFER0_SZ, NULL, &status);\n\t\t\t\tif (status != CL_SUCCESS) {\n\t\t\t\t\tapplog(LOG_ERR, \"Error %d: clCreateBuffer (CLbuffer0)\", status);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n\n\tkernelinfo->loaded = true;\n\treturn true;\n}\n"
        },
        {
          "name": "ocl.h",
          "type": "blob",
          "size": 1.3828125,
          "content": "#ifndef BFG_OCL_H\n#define BFG_OCL_H\n\n#include <stdbool.h>\n#include <stdio.h>\n\n#include \"CL/cl.h\"\n\n#include \"miner.h\"\n\n#define SCRYPT_CLBUFFER0_SZ      (128)\n#define FULLHEADER_CLBUFFER0_SZ  ( 80)\n#ifdef USE_SCRYPT\n#\tdefine MAX_CLBUFFER0_SZ  SCRYPT_CLBUFFER0_SZ\n#elif USE_OPENCL_FULLHEADER\n#\tdefine MAX_CLBUFFER0_SZ  FULLHEADER_CLBUFFER0_SZ\n#endif\n\nstruct mining_algorithm;\nstruct opencl_kernel_info;\ntypedef struct _clState _clState;\n\nstruct _clState {\n\tcl_device_id devid;\n\tchar *platform_ver_str;\n\tbool is_mesa;\n\t\n\tcl_context context;\n\tcl_command_queue commandQueue;\n\t\n\tcl_mem outputBuffer;\n#ifdef MAX_CLBUFFER0_SZ\n\tcl_mem CLbuffer0;\n#endif\n#ifdef USE_SCRYPT\n\tcl_mem padbuffer8;\n\tsize_t padbufsize;\n\tvoid * cldata;\n#endif\n\tbool hasBitAlign;\n\tcl_uint preferred_vwidth;\n\tcl_uint vwidth;\n\tsize_t max_work_size;\n\tcl_uint max_compute_units;\n};\n\nextern FILE *opencl_open_kernel(const char *filename);\nextern char *file_contents(const char *filename, int *length);\nextern char *opencl_kernel_source(const char *filename, int *out_sourcelen, enum cl_kernels *out_kinterface, struct mining_algorithm **);\nextern int clDevicesNum(void);\nextern _clState *opencl_create_clState(unsigned int gpu, char *name, size_t nameSize);\nextern bool opencl_load_kernel(struct cgpu_info *, _clState *clState, const char *name, struct opencl_kernel_info *, const char *kernel_file, const struct mining_algorithm *);\n\n#endif /* __OCL_H__ */\n"
        },
        {
          "name": "opencl",
          "type": "tree",
          "content": null
        },
        {
          "name": "openwrt",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup-vfio",
          "type": "blob",
          "size": 3.0458984375,
          "content": "#!/bin/bash\n\nDEVICES_PATH=/sys/bus/pci/devices\nVFIO_MODULE=\"vfio-pci\"\nVFIO_PCI_NEW_ID=/sys/bus/pci/drivers/${VFIO_MODULE}/new_id\nInteractive=true\nUnsafeInts=false\nCHOWN_USER=\n\ndie() {\n\techo \"$@\" >&2\n\texit 1\n}\n\ndieusage() {\n\tdie \"Usage: $0 [--unsafe] [--user <username>] [--yes] <vendor> <device>\"\n}\n\nyesno() {\n\tif ! $Interactive; then\n\t\t$2\n\t\treturn\n\tfi\n\twhile true; do\n\t\techo -n \"$1 \"\n\t\tread answer\n\t\tcase \"$answer\" in\n\t\tyes|y|ye)\n\t\t\treturn 0\n\t\t\t;;\n\t\tno|n)\n\t\t\treturn 1\n\t\t\t;;\n\t\t*)\n\t\t\techo \"Please enter 'yes' or 'no'.\"\n\t\tesac\n\tdone\n}\n\nwhile [ \"$#\" -gt 0 ]; do\n\tcase \"$1\" in\n\t--help|-h)\n\t\tdieusage\n\t\t;;\n\t--unsafe)\n\t\tUnsafeInts=true\n\t\t;;\n\t--user|-u)\n\t\tshift\n\t\tCHOWN_USER=\"$1\"\n\t\t;;\n\t--yes|-y)\n\t\tInteractive=false\n\t\t;;\n\t*)\n\t\tif [ -n \"$WANT_VENDOR\" ]; then\n\t\t\tWANT_DEVICE=\"$1\"\n\t\telse\n\t\t\tWANT_VENDOR=\"$1\"\n\t\tfi\n\t\t;;\n\tesac\n\tshift\ndone\n\n[ -n \"$WANT_DEVICE\" ] || dieusage\n\nmodprobe ${VFIO_MODULE} || die 'Failed to load ${VFIO_MODULE} module'\nfor TARGET_DEVICE_ID in $(ls $DEVICES_PATH); do\n\t{ grep -q '^0x'\"${WANT_VENDOR}\" \"${DEVICES_PATH}/${TARGET_DEVICE_ID}/vendor\" && grep -q '^0x'\"${WANT_DEVICE}\" \"${DEVICES_PATH}/${TARGET_DEVICE_ID}/device\"; } || continue\n\t\n\techo \"Found $(lspci -s \"$TARGET_DEVICE_ID\")\"\n\textradevs=\n\textradevsn=0\n\textradevsq=\n\tfor RELATED_DEVICE_ID in $(ls \"${DEVICES_PATH}/${TARGET_DEVICE_ID}/iommu_group/devices/\"); do\n\t\tif [ \"$RELATED_DEVICE_ID\" = \"$TARGET_DEVICE_ID\" ] ||\n\t\t {\n\t\t  { ! [ -e \"${DEVICES_PATH}/${RELATED_DEVICE_ID}/driver\" ]; } ||\n\t\t  [ \"$(basename \"$(readlink \"${DEVICES_PATH}/${RELATED_DEVICE_ID}/driver\")\")\" = \"${VFIO_MODULE}\" ]\n\t\t } ||\n\t\t grep -q '^0x060400$' \"${DEVICES_PATH}/${RELATED_DEVICE_ID}/class\"; then\n\t\t\textradevsq=\"$extradevsq $RELATED_DEVICE_ID\"\n\t\telse\n\t\t\textradevs=\"$extradevs $RELATED_DEVICE_ID\"\n\t\t\tlet ++extradevsn\n\t\tfi\n\tdone\n\tif [ \"$extradevsn\" -gt 0 ]; then\n\t\tif [ $extradevsn -gt 1 ]; then\n\t\t\techo \"Enabling VFIO for this device will also disable the following $extradevsn devices:\"\n\t\telse\n\t\t\techo \"Enabling VFIO for this device will also disable this device:\"\n\t\tfi\n\t\tfor RELATED_DEVICE_ID in ${extradevs}; do\n\t\t\techo \"- $(lspci -s \"$RELATED_DEVICE_ID\")\"\n\t\tdone\n\tfi\n\tyesno 'Enable VFIO?' true || continue\n\t\n\tif $UnsafeInts; then\n\t\techo 1 >/sys/module/vfio_iommu_type1/parameters/allow_unsafe_interrupts || die 'Failed to enable unsafe interrupts'\n\tfi\n\tfor RELATED_DEVICE_ID in ${extradevsq} ${extradevs}; do\n\t\tif [ -e \"${DEVICES_PATH}/${RELATED_DEVICE_ID}/driver\" ]; then\n\t\t\techo \"$RELATED_DEVICE_ID\" >\"${DEVICES_PATH}/${RELATED_DEVICE_ID}/driver/unbind\" || die \"Failed to unbind $RELATED_DEVICE_ID\"\n\t\tfi\n\t\techo \"$(<\"${DEVICES_PATH}/${RELATED_DEVICE_ID}/vendor\") $(<\"${DEVICES_PATH}/${RELATED_DEVICE_ID}/device\")\" >\"${VFIO_PCI_NEW_ID}\" || die \"Failed to associate device id with ${VFIO_MODULE} module\"\n\tdone\n\tIOMMU_GROUP=\"$(basename \"$(readlink \"${DEVICES_PATH}/${TARGET_DEVICE_ID}/iommu_group\")\")\"\n\tVFIO_DEVICE=\"/dev/vfio/$IOMMU_GROUP\"\n\t[ -e \"$VFIO_DEVICE\" ] || die \"$VFIO_DEVICE does not exist\"\n\tif [ -n \"${CHOWN_USER}\" ]; then\n\t\tchown \"${CHOWN_USER}\" \"$VFIO_DEVICE\" || die \"Failed to chown $VFIO_DEVICE to $CHOWN_USER\"\n\tfi\n\techo \"VFIO enabled on $VFIO_DEVICE\"\ndone\n"
        },
        {
          "name": "sha2.c",
          "type": "blob",
          "size": 6.474609375,
          "content": "/*\n * FIPS 180-2 SHA-224/256/384/512 implementation\n * Last update: 02/02/2007\n * Issue date:  04/30/2005\n *\n * Copyright 2013 Con Kolivas\n * Copyright 2005 2007 Olivier Gay\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"sha2.h\"\n\n#define UNPACK32(x, str)                      \\\n{                                             \\\n    *((str) + 3) = (uint8_t) ((x)      );       \\\n    *((str) + 2) = (uint8_t) ((x) >>  8);       \\\n    *((str) + 1) = (uint8_t) ((x) >> 16);       \\\n    *((str) + 0) = (uint8_t) ((x) >> 24);       \\\n}\n\n#define PACK32(str, x)                        \\\n{                                             \\\n    *(x) =   ((uint32_t) *((str) + 3)      )    \\\n           | ((uint32_t) *((str) + 2) <<  8)    \\\n           | ((uint32_t) *((str) + 1) << 16)    \\\n           | ((uint32_t) *((str) + 0) << 24);   \\\n}\n\n#define SHA256_SCR(i)                         \\\n{                                             \\\n    w[i] =  SHA256_F4(w[i -  2]) + w[i -  7]  \\\n          + SHA256_F3(w[i - 15]) + w[i - 16]; \\\n}\n\nuint32_t sha256_h0[8] =\n            {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\nuint32_t sha256_k[64] =\n            {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n             0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n             0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n             0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n             0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n             0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n             0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n             0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n             0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n             0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n             0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n             0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n             0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n             0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n             0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n             0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\n/* SHA-256 functions */\n\nvoid sha256_transf(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int block_nb)\n{\n    uint32_t w[64];\n    uint32_t wv[8];\n    uint32_t t1, t2;\n    const unsigned char *sub_block;\n    int i;\n\n    int j;\n\n    for (i = 0; i < (int) block_nb; i++) {\n        sub_block = message + (i << 6);\n\n        for (j = 0; j < 16; j++) {\n            PACK32(&sub_block[j << 2], &w[j]);\n        }\n\n        for (j = 16; j < 64; j++) {\n            SHA256_SCR(j);\n        }\n\n        for (j = 0; j < 8; j++) {\n            wv[j] = ctx->h[j];\n        }\n\n        for (j = 0; j < 64; j++) {\n            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])\n                + sha256_k[j] + w[j];\n            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);\n            wv[7] = wv[6];\n            wv[6] = wv[5];\n            wv[5] = wv[4];\n            wv[4] = wv[3] + t1;\n            wv[3] = wv[2];\n            wv[2] = wv[1];\n            wv[1] = wv[0];\n            wv[0] = t1 + t2;\n        }\n\n        for (j = 0; j < 8; j++) {\n            ctx->h[j] += wv[j];\n        }\n    }\n}\n\nvoid sha256(const unsigned char *message, unsigned int len, unsigned char *digest)\n{\n    sha256_ctx ctx;\n\n    sha256_init(&ctx);\n    sha256_update(&ctx, message, len);\n    sha256_final(&ctx, digest);\n}\n\nvoid sha256_init(sha256_ctx *ctx)\n{\n    int i;\n    for (i = 0; i < 8; i++) {\n        ctx->h[i] = sha256_h0[i];\n    }\n\n    ctx->len = 0;\n    ctx->tot_len = 0;\n}\n\nvoid sha256_update(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int len)\n{\n    unsigned int block_nb;\n    unsigned int new_len, rem_len, tmp_len;\n    const unsigned char *shifted_message;\n\n    tmp_len = SHA256_BLOCK_SIZE - ctx->len;\n    rem_len = len < tmp_len ? len : tmp_len;\n\n    memcpy(&ctx->block[ctx->len], message, rem_len);\n\n    if (ctx->len + len < SHA256_BLOCK_SIZE) {\n        ctx->len += len;\n        return;\n    }\n\n    new_len = len - rem_len;\n    block_nb = new_len / SHA256_BLOCK_SIZE;\n\n    shifted_message = message + rem_len;\n\n    sha256_transf(ctx, ctx->block, 1);\n    sha256_transf(ctx, shifted_message, block_nb);\n\n    rem_len = new_len % SHA256_BLOCK_SIZE;\n\n    memcpy(ctx->block, &shifted_message[block_nb << 6],\n           rem_len);\n\n    ctx->len = rem_len;\n    ctx->tot_len += (block_nb + 1) << 6;\n}\n\nvoid sha256_final(sha256_ctx *ctx, unsigned char *digest)\n{\n    unsigned int block_nb;\n    unsigned int pm_len;\n    unsigned int len_b;\n\n    int i;\n\n    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)\n                     < (ctx->len % SHA256_BLOCK_SIZE)));\n\n    len_b = (ctx->tot_len + ctx->len) << 3;\n    pm_len = block_nb << 6;\n\n    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);\n    ctx->block[ctx->len] = 0x80;\n    UNPACK32(len_b, ctx->block + pm_len - 4);\n\n    sha256_transf(ctx, ctx->block, block_nb);\n\n    for (i = 0 ; i < 8; i++) {\n        UNPACK32(ctx->h[i], &digest[i << 2]);\n    }\n}\n"
        },
        {
          "name": "sha2.h",
          "type": "blob",
          "size": 2.7314453125,
          "content": "/*\n * FIPS 180-2 SHA-224/256/384/512 implementation\n * Last update: 02/02/2007\n * Issue date:  04/30/2005\n *\n * Copyright 2013 Con Kolivas\n * Copyright 2005, 2007 Olivier Gay\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n\n#include \"miner.h\"\n\n#ifndef SHA2_H\n#define SHA2_H\n\n#define SHA256_DIGEST_SIZE ( 256 / 8)\n#define SHA256_BLOCK_SIZE  ( 512 / 8)\n\n#define SHFR(x, n)    (x >> n)\n#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))\n#define CH(x, y, z)  ((x & y) ^ (~x & z))\n#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))\n\n#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))\n#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))\n#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))\n#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))\n\ntypedef struct {\n    unsigned int tot_len;\n    unsigned int len;\n    unsigned char block[2 * SHA256_BLOCK_SIZE];\n    uint32_t h[8];\n} sha256_ctx;\n\nextern uint32_t sha256_k[64];\n\nvoid sha256_init(sha256_ctx * ctx);\nvoid sha256_update(sha256_ctx *ctx, const unsigned char *message,\n                   unsigned int len);\nvoid sha256_final(sha256_ctx *ctx, unsigned char *digest);\nvoid sha256(const unsigned char *message, unsigned int len,\n            unsigned char *digest);\n\n#endif /* !SHA2_H */\n"
        },
        {
          "name": "sha256_4way.c",
          "type": "blob",
          "size": 19.771484375,
          "content": "// Copyright 2012-2013 Luke Dashjr\n// Copyright 2010 Satoshi Nakamoto\n// Distributed under the MIT/X11 software license, see the accompanying\n// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n\n// tcatm's 4-way 128-bit SSE2 SHA-256\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#ifdef WANT_SSE2_4WAY\n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include <xmmintrin.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#define NPAR 32\n\nstatic void DoubleBlockSHA256(const void* pin, const void* pout, const void* pinit, unsigned int hash[8][NPAR], const void* init2);\n\nstatic const unsigned int sha256_consts[] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, /*  0 */\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, /*  8 */\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, /* 16 */\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, /* 24 */\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, /* 32 */\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, /* 40 */\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, /* 48 */\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, /* 56 */\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\nstatic inline __m128i Ch(const __m128i b, const __m128i c, const __m128i d) {\n    return _mm_xor_si128(_mm_and_si128(b,c),_mm_andnot_si128(b,d));\n}\n\nstatic inline __m128i Maj(const __m128i b, const __m128i c, const __m128i d) {\n    return _mm_xor_si128(_mm_xor_si128(_mm_and_si128(b,c),_mm_and_si128(b,d)),_mm_and_si128(c,d));\n}\n\nstatic inline __m128i  ROTR(__m128i x, const int n) {\n    return _mm_or_si128(_mm_srli_epi32(x, n),_mm_slli_epi32(x, 32 - n));\n}\n\nstatic inline __m128i SHR(__m128i x, const int n) {\n    return _mm_srli_epi32(x, n);\n}\n\n/* SHA256 Functions */\n#define BIGSIGMA0_256(x)    (_mm_xor_si128(_mm_xor_si128(ROTR((x), 2),ROTR((x), 13)),ROTR((x), 22)))\n#define BIGSIGMA1_256(x)    (_mm_xor_si128(_mm_xor_si128(ROTR((x), 6),ROTR((x), 11)),ROTR((x), 25)))\n\n\n#define SIGMA0_256(x)       (_mm_xor_si128(_mm_xor_si128(ROTR((x), 7),ROTR((x), 18)), SHR((x), 3 )))\n#define SIGMA1_256(x)       (_mm_xor_si128(_mm_xor_si128(ROTR((x),17),ROTR((x), 19)), SHR((x), 10)))\n\n#define add4(x0, x1, x2, x3) _mm_add_epi32(_mm_add_epi32(x0, x1),_mm_add_epi32( x2,x3))\n#define add5(x0, x1, x2, x3, x4) _mm_add_epi32(add4(x0, x1, x2, x3), x4)\n\n#define SHA256ROUND(a, b, c, d, e, f, g, h, i, w)                       \\\n    T1 = add5(h, BIGSIGMA1_256(e), Ch(e, f, g), _mm_set1_epi32(sha256_consts[i]), w);   \\\nd = _mm_add_epi32(d, T1);                                           \\\nh = _mm_add_epi32(T1, _mm_add_epi32(BIGSIGMA0_256(a), Maj(a, b, c)));\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n\nbool ScanHash_4WaySSE2(struct thr_info * const thr, struct work * const work,\n\tuint32_t max_nonce, uint32_t *last_nonce,\n\tuint32_t nonce)\n{\n\tconst uint8_t * const pmidstate = work->midstate;\n\tuint8_t *pdata = work->data;\n\tconst uint32_t * const phash1 = hash1_init;\n\tuint8_t * const phash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *)phash;\n    unsigned int *nNonce_p = (unsigned int*)(pdata + 76);\n\n\tpdata += 64;\n\n    for (;;)\n    {\n        unsigned int thash[9][NPAR] __attribute__((aligned(128)));\n\tint j;\n\n\t*nNonce_p = nonce;\n\n        DoubleBlockSHA256(pdata, phash1, pmidstate, thash, pSHA256InitState);\n\n        for (j = 0; j < NPAR; j++)\n        {\n            if (unlikely(thash[7][j] == 0))\n            {\n\t\tint i;\n\n                for (i = 0; i < 32/4; i++)\n                    ((unsigned int*)phash)[i] = thash[i][j];\n\n\t\t\t\tif (unlikely(hash32[7] == 0))\n\t\t\t\t{\n\t\t\t\t\tnonce += j;\n\t\t\t\t\t*last_nonce = nonce;\n\t\t\t\t\t*nNonce_p = nonce;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n            }\n        }\n\n        if ((nonce >= max_nonce) || thr->work_restart)\n        {\n            *last_nonce = nonce;\n            return false;\n        }\n\n\t\tnonce += NPAR;\n    }\n}\n\n\nstatic void DoubleBlockSHA256(const void* pin, const void* pad, const void *pre, unsigned int thash[9][NPAR], const void *init)\n{\n    unsigned int* In = (unsigned int*)pin;\n    const unsigned int* Pad = pad;\n    unsigned int* hPre = (unsigned int*)pre;\n    unsigned int* hInit = (unsigned int*)init;\n    unsigned int /* i, j, */ k;\n\n    /* vectors used in calculation */\n    __m128i w0, w1, w2, w3, w4, w5, w6, w7;\n    __m128i w8, w9, w10, w11, w12, w13, w14, w15;\n    __m128i T1;\n    __m128i a, b, c, d, e, f, g, h;\n    __m128i nonce, preNonce;\n\n    /* nonce offset for vector */\n    __m128i offset = _mm_set_epi32(0x00000003, 0x00000002, 0x00000001, 0x00000000);\n\n\n    preNonce = _mm_add_epi32(_mm_set1_epi32(In[3]), offset);\n\n    for(k = 0; k<NPAR; k+=4) {\n        w0 = _mm_set1_epi32(In[0]);\n        w1 = _mm_set1_epi32(In[1]);\n        w2 = _mm_set1_epi32(In[2]);\n        //w3 = _mm_set1_epi32(In[3]); nonce will be later hacked into the hash\n        w4 = _mm_set1_epi32(In[4]);\n        w5 = _mm_set1_epi32(In[5]);\n        w6 = _mm_set1_epi32(In[6]);\n        w7 = _mm_set1_epi32(In[7]);\n        w8 = _mm_set1_epi32(In[8]);\n        w9 = _mm_set1_epi32(In[9]);\n        w10 = _mm_set1_epi32(In[10]);\n        w11 = _mm_set1_epi32(In[11]);\n        w12 = _mm_set1_epi32(In[12]);\n        w13 = _mm_set1_epi32(In[13]);\n        w14 = _mm_set1_epi32(In[14]);\n        w15 = _mm_set1_epi32(In[15]);\n\n        /* hack nonce into lowest byte of w3 */\n\tnonce = _mm_add_epi32(preNonce, _mm_set1_epi32(k));\n        w3 = nonce;\n\n        a = _mm_set1_epi32(hPre[0]);\n        b = _mm_set1_epi32(hPre[1]);\n        c = _mm_set1_epi32(hPre[2]);\n        d = _mm_set1_epi32(hPre[3]);\n        e = _mm_set1_epi32(hPre[4]);\n        f = _mm_set1_epi32(hPre[5]);\n        g = _mm_set1_epi32(hPre[6]);\n        h = _mm_set1_epi32(hPre[7]);\n\n        SHA256ROUND(a, b, c, d, e, f, g, h, 0, w0);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 1, w1);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 2, w2);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 3, w3);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 4, w4);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 5, w5);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 6, w6);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 7, w7);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 8, w8);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 9, w9);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 10, w10);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 11, w11);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 12, w12);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 13, w13);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 14, w14);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 15, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 16, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 17, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 18, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 19, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 20, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 21, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 22, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 23, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 24, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 25, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 26, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 27, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 28, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 29, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 30, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 31, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 32, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 33, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 34, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 35, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 36, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 37, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 38, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 39, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 40, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 41, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 42, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 43, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 44, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 45, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 46, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 47, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 48, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 49, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 50, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 51, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 52, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 53, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 54, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 55, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 56, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 57, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 58, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 59, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 60, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 61, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 62, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 63, w15);\n\n#define store_load(x, i, dest) \\\n        T1 = _mm_set1_epi32((hPre)[i]); \\\n        dest = _mm_add_epi32(T1, x);\n\n        store_load(a, 0, w0);\n        store_load(b, 1, w1);\n        store_load(c, 2, w2);\n        store_load(d, 3, w3);\n        store_load(e, 4, w4);\n        store_load(f, 5, w5);\n        store_load(g, 6, w6);\n        store_load(h, 7, w7);\n\n        w8 = _mm_set1_epi32(Pad[8]);\n        w9 = _mm_set1_epi32(Pad[9]);\n        w10 = _mm_set1_epi32(Pad[10]);\n        w11 = _mm_set1_epi32(Pad[11]);\n        w12 = _mm_set1_epi32(Pad[12]);\n        w13 = _mm_set1_epi32(Pad[13]);\n        w14 = _mm_set1_epi32(Pad[14]);\n        w15 = _mm_set1_epi32(Pad[15]);\n\n        a = _mm_set1_epi32(hInit[0]);\n        b = _mm_set1_epi32(hInit[1]);\n        c = _mm_set1_epi32(hInit[2]);\n        d = _mm_set1_epi32(hInit[3]);\n        e = _mm_set1_epi32(hInit[4]);\n        f = _mm_set1_epi32(hInit[5]);\n        g = _mm_set1_epi32(hInit[6]);\n        h = _mm_set1_epi32(hInit[7]);\n\n        SHA256ROUND(a, b, c, d, e, f, g, h, 0, w0);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 1, w1);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 2, w2);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 3, w3);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 4, w4);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 5, w5);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 6, w6);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 7, w7);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 8, w8);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 9, w9);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 10, w10);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 11, w11);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 12, w12);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 13, w13);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 14, w14);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 15, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 16, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 17, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 18, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 19, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 20, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 21, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 22, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 23, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 24, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 25, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 26, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 27, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 28, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 29, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 30, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 31, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 32, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 33, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 34, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 35, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 36, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 37, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 38, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 39, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 40, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 41, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 42, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 43, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 44, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 45, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 46, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 47, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 48, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 49, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 50, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 51, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 52, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 53, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 54, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 55, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 56, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 57, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 58, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 59, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 60, w12);\n\n\t/* Skip last 3-rounds; not necessary for H==0 */\n#if 0\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 61, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 62, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 63, w15);\n#endif\n\n        /* store resulsts directly in thash */\n#define store_2(x,i)  \\\n        w0 = _mm_set1_epi32(hInit[i]); \\\n        *(__m128i *)&(thash)[i][0+k] = _mm_add_epi32(w0, x);\n\n        store_2(a, 0);\n        store_2(b, 1);\n        store_2(c, 2);\n        store_2(d, 3);\n        store_2(e, 4);\n        store_2(f, 5);\n        store_2(g, 6);\n        store_2(h, 7);\n        *(__m128i *)&(thash)[8][0+k] = nonce;\n    }\n\n}\n\n#endif /* WANT_SSE2_4WAY */\n"
        },
        {
          "name": "sha256_altivec_4way.c",
          "type": "blob",
          "size": 21.5009765625,
          "content": "// Copyright 2010 Satoshi Nakamoto\n// Copyright 2011 Gilles Risch\n// Copyright 2012-2013 Luke Dashjr\n// Distributed under the MIT/X11 software license, see the accompanying\n// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n\n\n// 4-way 128-bit Altivec SHA-256,\n// based on tcatm's 4-way 128-bit SSE2 SHA-256\n//\n\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#ifdef WANT_ALTIVEC_4WAY\n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n//#include <altivec.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#define NPAR 32\n\nstatic void DoubleBlockSHA256(const void* pin, void* pout, const void* pinit, unsigned int hash[8][NPAR], const void* init2);\n\nstatic const unsigned int sha256_consts[] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, /*  0 */\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, /*  8 */\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, /* 16 */\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, /* 24 */\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, /* 32 */\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, /* 40 */\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, /* 48 */\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, /* 56 */\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\nstatic inline vector unsigned int Ch(const vector unsigned int b, const vector unsigned int c, const vector unsigned int d) {\n    return vec_sel(d,c,b);\n}\n\nstatic inline vector unsigned int Maj(const vector unsigned int b, const vector unsigned int c, const vector unsigned int d) {\n    return vec_sel(b,c, vec_xor(b,d));\n}\n\n/* RotateRight(x, n) := RotateLeft(x, 32-n) */\n/* SHA256 Functions */\n#define BIGSIGMA0_256(x)    (vec_xor(vec_xor(vec_rl((x), (vector unsigned int)(32-2)),vec_rl((x), (vector unsigned int)(32-13))),vec_rl((x), (vector unsigned int)(32-22))))\n#define BIGSIGMA1_256(x)    (vec_xor(vec_xor(vec_rl((x), (vector unsigned int)(32-6)),vec_rl((x), (vector unsigned int)(32-11))),vec_rl((x), (vector unsigned int)(32-25))))\n\n#define SIGMA0_256(x)       (vec_xor(vec_xor(vec_rl((x), (vector unsigned int)(32- 7)),vec_rl((x), (vector unsigned int)(32-18))), vec_sr((x), (vector unsigned int)(3 ))))\n#define SIGMA1_256(x)       (vec_xor(vec_xor(vec_rl((x), (vector unsigned int)(32-17)),vec_rl((x), (vector unsigned int)(32-19))), vec_sr((x), (vector unsigned int)(10))))\n\n#define add4(x0, x1, x2, x3) vec_add(vec_add(x0, x1),vec_add( x2,x3))\n#define add5(x0, x1, x2, x3, x4) vec_add(add4(x0, x1, x2, x3), x4)\n\n#define SHA256ROUND(a, b, c, d, e, f, g, h, i, w)                       \\\n    T1 = add5(h, BIGSIGMA1_256(e), Ch(e, f, g), (vector unsigned int)(sha256_consts[i],sha256_consts[i],sha256_consts[i],sha256_consts[i]), w);   \\\n    d = vec_add(d, T1);                                           \\\n    h = vec_add(T1, vec_add(BIGSIGMA0_256(a), Maj(a, b, c)));\n\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n\nbool ScanHash_altivec_4way(struct thr_info * const thr, struct work * const work,\n\tuint32_t max_nonce, uint32_t *last_nonce,\n\tuint32_t nonce)\n{\n\tconst uint8_t * const pmidstate = work->midstate;\n\tuint8_t *pdata = work->data;\n\tuint8_t hash1[0x40];\n\tmemcpy(hash1, hash1_init, sizeof(hash1));\n\tuint8_t * const phash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *)phash;\n    unsigned int *nNonce_p = (unsigned int*)(pdata + 76);\n\n\tpdata += 64;\n\n    for (;;)\n    {\n        unsigned int thash[9][NPAR] __attribute__((aligned(128)));\n\tint j;\n\n\t*nNonce_p = nonce;\n\n        DoubleBlockSHA256(pdata, phash1, pmidstate, thash, pSHA256InitState);\n\n        for (j = 0; j < NPAR; j++)\n        {\n            if (unlikely(thash[7][j] == 0))\n            {\n\t\tint i;\n\n                for (i = 0; i < 32/4; i++)\n                    ((unsigned int*)phash)[i] = thash[i][j];\n\n\t\t\t\tif (unlikely(hash32[7] == 0))\n\t\t\t\t{\n\t\t\t\t\tnonce += j;\n\t\t\t\t\t*last_nonce = nonce;\n\t\t\t\t\t*nNonce_p = nonce;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n            }\n        }\n\n        if ((nonce >= max_nonce) || thr->work_restart)\n        {\n            *last_nonce = nonce;\n            return false;\n        }\n\n        nonce += NPAR;\n    }\n}\n\n\nstatic void DoubleBlockSHA256(const void* pin, void* pad, const void *pre, unsigned int thash[9][NPAR], const void *init)\n{\n    unsigned int* In = (unsigned int*)pin;\n    unsigned int* Pad = (unsigned int*)pad;\n    unsigned int* hPre = (unsigned int*)pre;\n    unsigned int* hInit = (unsigned int*)init;\n    unsigned int /* i, j, */ k;\n\n    /* vectors used in calculation */\n    vector unsigned int w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n    vector unsigned int T1;\n    vector unsigned int a, b, c, d, e, f, g, h;\n    vector unsigned int nonce, preNonce;\n\n    /* nonce offset for vector */\n    vector unsigned int offset = (vector unsigned int)(0, 1, 2, 3);\n\n    preNonce = vec_add((vector unsigned int)(In[3],In[3],In[3],In[3]), offset);\n\n   for(k = 0; k<NPAR; k+=4)\n   {\n        w0 = (vector unsigned int)(In[0],In[0],In[0],In[0]);\n        w1 = (vector unsigned int)(In[1],In[1],In[1],In[1]);\n        w2 = (vector unsigned int)(In[2],In[2],In[2],In[2]);\n        //w3 = (vector unsigned int)(In[3],In[3],In[3],In[3]); nonce will be later hacked into the hash\n        w4 = (vector unsigned int)(In[4],In[4],In[4],In[4]);\n        w5 = (vector unsigned int)(In[5],In[5],In[5],In[5]);\n        w6 = (vector unsigned int)(In[6],In[6],In[6],In[6]);\n        w7 = (vector unsigned int)(In[7],In[7],In[7],In[7]);\n        w8 = (vector unsigned int)(In[8],In[8],In[8],In[8]);\n        w9 = (vector unsigned int)(In[9],In[9],In[9],In[9]);\n        w10 = (vector unsigned int)(In[10],In[10],In[10],In[10]);\n        w11 = (vector unsigned int)(In[11],In[11],In[11],In[11]);\n        w12 = (vector unsigned int)(In[12],In[12],In[12],In[12]);\n        w13 = (vector unsigned int)(In[13],In[13],In[13],In[13]);\n        w14 = (vector unsigned int)(In[14],In[14],In[14],In[14]);\n        w15 = (vector unsigned int)(In[15],In[15],In[15],In[15]);\n\n        /* hack nonce into lowest byte of w3 */\n\tnonce = vec_add(preNonce, (vector unsigned int)(k,k,k,k));\n\n        w3 = nonce;\n        //printf (\"W3: %08vlx\\n\", w3);\n\n        a = (vector unsigned int)(hPre[0],hPre[0],hPre[0],hPre[0]);\n        b = (vector unsigned int)(hPre[1],hPre[1],hPre[1],hPre[1]);\n        c = (vector unsigned int)(hPre[2],hPre[2],hPre[2],hPre[2]);\n        d = (vector unsigned int)(hPre[3],hPre[3],hPre[3],hPre[3]);\n        e = (vector unsigned int)(hPre[4],hPre[4],hPre[4],hPre[4]);\n        f = (vector unsigned int)(hPre[5],hPre[5],hPre[5],hPre[5]);\n        g = (vector unsigned int)(hPre[6],hPre[6],hPre[6],hPre[6]);\n        h = (vector unsigned int)(hPre[7],hPre[7],hPre[7],hPre[7]);\n\n        SHA256ROUND(a, b, c, d, e, f, g, h, 0, w0);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 1, w1);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 2, w2);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 3, w3);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 4, w4);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 5, w5);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 6, w6);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 7, w7);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 8, w8);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 9, w9);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 10, w10);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 11, w11);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 12, w12);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 13, w13);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 14, w14);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 15, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 16, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 17, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 18, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 19, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 20, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 21, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 22, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 23, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 24, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 25, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 26, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 27, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 28, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 29, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 30, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 31, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 32, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 33, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 34, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 35, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 36, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 37, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 38, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 39, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 40, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 41, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 42, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 43, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 44, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 45, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 46, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 47, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 48, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 49, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 50, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 51, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 52, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 53, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 54, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 55, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 56, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 57, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 58, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 59, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 60, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 61, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 62, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 63, w15);\n\n#define store_load(x, i, dest) \\\n        T1 = (vector unsigned int)((hPre)[i],(hPre)[i],(hPre)[i],(hPre)[i]); \\\n        dest = vec_add(T1, x);\n\n        store_load(a, 0, w0);\n        store_load(b, 1, w1);\n        store_load(c, 2, w2);\n        store_load(d, 3, w3);\n        store_load(e, 4, w4);\n        store_load(f, 5, w5);\n        store_load(g, 6, w6);\n        store_load(h, 7, w7);\n\n        /* end of first SHA256 round */\n\n        w8 = (vector unsigned int)(Pad[8],Pad[8],Pad[8],Pad[8]);\n        w9 = (vector unsigned int)(Pad[9],Pad[9],Pad[9],Pad[9]);\n        w10 = (vector unsigned int)(Pad[10],Pad[10],Pad[10],Pad[10]);\n        w11 = (vector unsigned int)(Pad[11],Pad[11],Pad[11],Pad[11]);\n        w12 = (vector unsigned int)(Pad[12],Pad[12],Pad[12],Pad[12]);\n        w13 = (vector unsigned int)(Pad[13],Pad[13],Pad[13],Pad[13]);\n        w14 = (vector unsigned int)(Pad[14],Pad[14],Pad[14],Pad[14]);\n        w15 = (vector unsigned int)(Pad[15],Pad[15],Pad[15],Pad[15]);\n\n        a = (vector unsigned int)(hInit[0],hInit[0],hInit[0],hInit[0]);\n        b = (vector unsigned int)(hInit[1],hInit[1],hInit[1],hInit[1]);\n        c = (vector unsigned int)(hInit[2],hInit[2],hInit[2],hInit[2]);\n        d = (vector unsigned int)(hInit[3],hInit[3],hInit[3],hInit[3]);\n        e = (vector unsigned int)(hInit[4],hInit[4],hInit[4],hInit[4]);\n        f = (vector unsigned int)(hInit[5],hInit[5],hInit[5],hInit[5]);\n        g = (vector unsigned int)(hInit[6],hInit[6],hInit[6],hInit[6]);\n        h = (vector unsigned int)(hInit[7],hInit[7],hInit[7],hInit[7]);\n\n        SHA256ROUND(a, b, c, d, e, f, g, h, 0, w0);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 1, w1);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 2, w2);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 3, w3);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 4, w4);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 5, w5);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 6, w6);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 7, w7);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 8, w8);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 9, w9);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 10, w10);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 11, w11);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 12, w12);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 13, w13);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 14, w14);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 15, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 16, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 17, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 18, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 19, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 20, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 21, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 22, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 23, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 24, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 25, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 26, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 27, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 28, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 29, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 30, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 31, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 32, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 33, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 34, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 35, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 36, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 37, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 38, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 39, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 40, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 41, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 42, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 43, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 44, w12);\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 45, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 46, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 47, w15);\n\n        w0 = add4(SIGMA1_256(w14), w9, SIGMA0_256(w1), w0);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 48, w0);\n        w1 = add4(SIGMA1_256(w15), w10, SIGMA0_256(w2), w1);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 49, w1);\n        w2 = add4(SIGMA1_256(w0), w11, SIGMA0_256(w3), w2);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 50, w2);\n        w3 = add4(SIGMA1_256(w1), w12, SIGMA0_256(w4), w3);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 51, w3);\n        w4 = add4(SIGMA1_256(w2), w13, SIGMA0_256(w5), w4);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 52, w4);\n        w5 = add4(SIGMA1_256(w3), w14, SIGMA0_256(w6), w5);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 53, w5);\n        w6 = add4(SIGMA1_256(w4), w15, SIGMA0_256(w7), w6);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 54, w6);\n        w7 = add4(SIGMA1_256(w5), w0, SIGMA0_256(w8), w7);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 55, w7);\n        w8 = add4(SIGMA1_256(w6), w1, SIGMA0_256(w9), w8);\n        SHA256ROUND(a, b, c, d, e, f, g, h, 56, w8);\n        w9 = add4(SIGMA1_256(w7), w2, SIGMA0_256(w10), w9);\n        SHA256ROUND(h, a, b, c, d, e, f, g, 57, w9);\n        w10 = add4(SIGMA1_256(w8), w3, SIGMA0_256(w11), w10);\n        SHA256ROUND(g, h, a, b, c, d, e, f, 58, w10);\n        w11 = add4(SIGMA1_256(w9), w4, SIGMA0_256(w12), w11);\n        SHA256ROUND(f, g, h, a, b, c, d, e, 59, w11);\n        w12 = add4(SIGMA1_256(w10), w5, SIGMA0_256(w13), w12);\n        SHA256ROUND(e, f, g, h, a, b, c, d, 60, w12);\n\n\t/* Skip last 3-rounds; not necessary for H==0 */\n/*#if 0\n        w13 = add4(SIGMA1_256(w11), w6, SIGMA0_256(w14), w13);\n        SHA256ROUND(d, e, f, g, h, a, b, c, 61, w13);\n        w14 = add4(SIGMA1_256(w12), w7, SIGMA0_256(w15), w14);\n        SHA256ROUND(c, d, e, f, g, h, a, b, 62, w14);\n        w15 = add4(SIGMA1_256(w13), w8, SIGMA0_256(w0), w15);\n        SHA256ROUND(b, c, d, e, f, g, h, a, 63, w15);\n#endif*/\n\n        /* store resulsts directly in thash */\n#define store_2(x,i)  \\\n        w0 = (vector unsigned int)(hInit[i],hInit[i],hInit[i],hInit[i]); \\\n        vec_st(vec_add(w0, x), 0 ,&thash[i][k]);\n\n        store_2(a, 0);\n        store_2(b, 1);\n        store_2(c, 2);\n        store_2(d, 3);\n        store_2(e, 4);\n        store_2(f, 5);\n        store_2(g, 6);\n        store_2(h, 7);\n\n        vec_st(nonce, 0 ,&thash[8][k]);\n        /* writing the results into the array is time intensive */\n        /* -> try if it´s faster to compare the results with the target inside this function */\n    }\n\n}\n\n#endif /* WANT_ALTIVEC_4WAY */\n\n"
        },
        {
          "name": "sha256_cryptopp.c",
          "type": "blob",
          "size": 16.130859375,
          "content": "/*\n * Copyright 2010-2011 Jeff Garzik\n * Copyright 2002-2010 Wei Dai (released as public domain)\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2011 Con Kolivas\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"driver-cpu.h\"\n#include \"miner.h\"\n\ntypedef uint32_t word32;\n\nstatic word32 rotrFixed(word32 word, unsigned int shift)\n{\n\treturn (word >> shift) | (word << (32 - shift));\n}\n\n#define blk0(i) (W[i] = data[i])\n\nstatic const word32 SHA256_K[64] = {\n\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n#define blk2(i) (W[i&15]+=s1(W[(i-2)&15])+W[(i-7)&15]+s0(W[(i-15)&15]))\n\n#define Ch(x,y,z) (z^(x&(y^z)))\n#define Maj(x,y,z) (y^((x^y)&(y^z)))\n\n#define a(i) T[(0-i)&7]\n#define b(i) T[(1-i)&7]\n#define c(i) T[(2-i)&7]\n#define d(i) T[(3-i)&7]\n#define e(i) T[(4-i)&7]\n#define f(i) T[(5-i)&7]\n#define g(i) T[(6-i)&7]\n#define h(i) T[(7-i)&7]\n\n#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA256_K[i+j]+(j?blk2(i):blk0(i));\\\n\td(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))\n\n// for SHA256\n#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))\n#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))\n#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))\n#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))\n\nstatic void SHA256_Transform(word32 *state, const word32 *data)\n{\n\tword32 W[16] = { };\n\tword32 T[8];\n\tunsigned int j;\n\n    /* Copy context->state[] to working vars */\n\tmemcpy(T, state, sizeof(T));\n    /* 64 operations, partially loop unrolled */\n\tfor (j=0; j<64; j+=16)\n\t{\n\t\tR( 0); R( 1); R( 2); R( 3);\n\t\tR( 4); R( 5); R( 6); R( 7);\n\t\tR( 8); R( 9); R(10); R(11);\n\t\tR(12); R(13); R(14); R(15);\n\t}\n    /* Add the working vars back into context.state[] */\n    state[0] += a(0);\n    state[1] += b(0);\n    state[2] += c(0);\n    state[3] += d(0);\n    state[4] += e(0);\n    state[5] += f(0);\n    state[6] += g(0);\n    state[7] += h(0);\n}\n\nstatic void runhash(void *state, const void *input, const void *init)\n{\n\tmemcpy(state, init, 32);\n\tSHA256_Transform(state, input);\n}\n\n/* suspiciously similar to ScanHash* from bitcoin */\nbool scanhash_cryptopp(struct thr_info * const thr, struct work * const work,\n\t        uint32_t max_nonce, uint32_t *last_nonce,\n\t\tuint32_t n)\n{\n\tconst uint8_t *midstate = work->midstate;\n\tuint8_t *data = work->data;\n\tuint8_t hash1[0x40];\n\tmemcpy(hash1, hash1_init, sizeof(hash1));\n\tuint8_t * const hash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *) hash;\n\tuint32_t *nonce = (uint32_t *)(data + 76);\n\n\tdata += 64;\n\n\t// Midstate and data are stored in little endian\n\tLOCAL_swap32le(unsigned char, midstate, 32/4)\n\tLOCAL_swap32le(unsigned char, data, 64/4)\n\tuint32_t *nonce_w = (uint32_t *)(data + 12);\n\n\twhile (1) {\n\t\t*nonce_w = n;\n\n\t\trunhash(hash1, data, midstate);\n\t\trunhash(hash, hash1, sha256_init_state);\n\n\t\tif (unlikely((hash32[7] == 0)))\n\t\t{\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart) {\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn false;\n\t\t}\n\n\t\tn++;\n\t}\n}\n\n#if defined(WANT_CRYPTOPP_ASM32)\n\n#define CRYPTOPP_FASTCALL\n#define CRYPTOPP_BOOL_X86 1\n#define CRYPTOPP_BOOL_X64 0\n#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 0\n\n#ifdef CRYPTOPP_GENERATE_X64_MASM\n\t#define AS1(x) x*newline*\n\t#define AS2(x, y) x, y*newline*\n\t#define AS3(x, y, z) x, y, z*newline*\n\t#define ASS(x, y, a, b, c, d) x, y, a*64+b*16+c*4+d*newline*\n\t#define ASL(x) label##x:*newline*\n\t#define ASJ(x, y, z) x label##y*newline*\n\t#define ASC(x, y) x label##y*newline*\n\t#define AS_HEX(y) 0##y##h\n#elif defined(_MSC_VER) || defined(__BORLANDC__)\n\t#define CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY\n\t#define AS1(x) __asm {x}\n\t#define AS2(x, y) __asm {x, y}\n\t#define AS3(x, y, z) __asm {x, y, z}\n\t#define ASS(x, y, a, b, c, d) __asm {x, y, (a)*64+(b)*16+(c)*4+(d)}\n\t#define ASL(x) __asm {label##x:}\n\t#define ASJ(x, y, z) __asm {x label##y}\n\t#define ASC(x, y) __asm {x label##y}\n\t#define CRYPTOPP_NAKED __declspec(naked)\n\t#define AS_HEX(y) 0x##y\n#else\n\t#define CRYPTOPP_GNU_STYLE_INLINE_ASSEMBLY\n\t// define these in two steps to allow arguments to be expanded\n\t#define GNU_AS1(x) #x \";\"\n\t#define GNU_AS2(x, y) #x \", \" #y \";\"\n\t#define GNU_AS3(x, y, z) #x \", \" #y \", \" #z \";\"\n\t#define GNU_ASL(x) \"\\n\" #x \":\"\n\t#define GNU_ASJ(x, y, z) #x \" \" #y #z \";\"\n\t#define AS1(x) GNU_AS1(x)\n\t#define AS2(x, y) GNU_AS2(x, y)\n\t#define AS3(x, y, z) GNU_AS3(x, y, z)\n\t#define ASS(x, y, a, b, c, d) #x \", \" #y \", \" #a \"*64+\" #b \"*16+\" #c \"*4+\" #d \";\"\n\t#define ASL(x) GNU_ASL(x)\n\t#define ASJ(x, y, z) GNU_ASJ(x, y, z)\n\t#define ASC(x, y) #x \" \" #y \";\"\n\t#define CRYPTOPP_NAKED\n\t#define AS_HEX(y) 0x##y\n#endif\n\n#define IF0(y)\n#define IF1(y) y\n\n#ifdef CRYPTOPP_GENERATE_X64_MASM\n#define ASM_MOD(x, y) ((x) MOD (y))\n#define XMMWORD_PTR XMMWORD PTR\n#else\n// GNU assembler doesn't seem to have mod operator\n#define ASM_MOD(x, y) ((x)-((x)/(y))*(y))\n// GAS 2.15 doesn't support XMMWORD PTR. it seems necessary only for MASM\n#define XMMWORD_PTR\n#endif\n\n#if CRYPTOPP_BOOL_X86\n\t#define AS_REG_1 ecx\n\t#define AS_REG_2 edx\n\t#define AS_REG_3 esi\n\t#define AS_REG_4 edi\n\t#define AS_REG_5 eax\n\t#define AS_REG_6 ebx\n\t#define AS_REG_7 ebp\n\t#define AS_REG_1d ecx\n\t#define AS_REG_2d edx\n\t#define AS_REG_3d esi\n\t#define AS_REG_4d edi\n\t#define AS_REG_5d eax\n\t#define AS_REG_6d ebx\n\t#define AS_REG_7d ebp\n\t#define WORD_SZ 4\n\t#define WORD_REG(x)\te##x\n\t#define WORD_PTR DWORD PTR\n\t#define AS_PUSH_IF86(x) AS1(push e##x)\n\t#define AS_POP_IF86(x) AS1(pop e##x)\n\t#define AS_JCXZ jecxz\n#elif CRYPTOPP_BOOL_X64\n\t#ifdef CRYPTOPP_GENERATE_X64_MASM\n\t\t#define AS_REG_1 rcx\n\t\t#define AS_REG_2 rdx\n\t\t#define AS_REG_3 r8\n\t\t#define AS_REG_4 r9\n\t\t#define AS_REG_5 rax\n\t\t#define AS_REG_6 r10\n\t\t#define AS_REG_7 r11\n\t\t#define AS_REG_1d ecx\n\t\t#define AS_REG_2d edx\n\t\t#define AS_REG_3d r8d\n\t\t#define AS_REG_4d r9d\n\t\t#define AS_REG_5d eax\n\t\t#define AS_REG_6d r10d\n\t\t#define AS_REG_7d r11d\n\t#else\n\t\t#define AS_REG_1 rdi\n\t\t#define AS_REG_2 rsi\n\t\t#define AS_REG_3 rdx\n\t\t#define AS_REG_4 rcx\n\t\t#define AS_REG_5 r8\n\t\t#define AS_REG_6 r9\n\t\t#define AS_REG_7 r10\n\t\t#define AS_REG_1d edi\n\t\t#define AS_REG_2d esi\n\t\t#define AS_REG_3d edx\n\t\t#define AS_REG_4d ecx\n\t\t#define AS_REG_5d r8d\n\t\t#define AS_REG_6d r9d\n\t\t#define AS_REG_7d r10d\n\t#endif\n\t#define WORD_SZ 8\n\t#define WORD_REG(x)\tr##x\n\t#define WORD_PTR QWORD PTR\n\t#define AS_PUSH_IF86(x)\n\t#define AS_POP_IF86(x)\n\t#define AS_JCXZ jrcxz\n#endif\n\nstatic void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len\n#if defined(_MSC_VER) && (_MSC_VER == 1200)\n\t, ...\t// VC60 workaround: prevent VC 6 from inlining this function\n#endif\n\t)\n{\n#if defined(_MSC_VER) && (_MSC_VER == 1200)\n\tAS2(mov ecx, [state])\n\tAS2(mov edx, [data])\n#endif\n\n\t#define LOCALS_SIZE\t8*4 + 16*4 + 4*WORD_SZ\n\t#define H(i)\t\t[BASE+ASM_MOD(1024+7-(i),8)*4]\n\t#define G(i)\t\tH(i+1)\n\t#define F(i)\t\tH(i+2)\n\t#define E(i)\t\tH(i+3)\n\t#define D(i)\t\tH(i+4)\n\t#define C(i)\t\tH(i+5)\n\t#define B(i)\t\tH(i+6)\n\t#define A(i)\t\tH(i+7)\n\t#define Wt(i)\t\tBASE+8*4+ASM_MOD(1024+15-(i),16)*4\n\t#define Wt_2(i)\t\tWt((i)-2)\n\t#define Wt_15(i)\tWt((i)-15)\n\t#define Wt_7(i)\t\tWt((i)-7)\n\t#define K_END\t\t[BASE+8*4+16*4+0*WORD_SZ]\n\t#define STATE_SAVE\t[BASE+8*4+16*4+1*WORD_SZ]\n\t#define DATA_SAVE\t[BASE+8*4+16*4+2*WORD_SZ]\n\t#define DATA_END\t[BASE+8*4+16*4+3*WORD_SZ]\n\t#define Kt(i)\t\tWORD_REG(si)+(i)*4\n#if CRYPTOPP_BOOL_X86\n\t#define BASE\t\tesp+4\n#elif defined(__GNUC__)\n\t#define BASE\t\tr8\n#else\n\t#define BASE\t\trsp\n#endif\n\n#define RA0(i, edx, edi)\t\t\\\n\tAS2(\tadd edx, [Kt(i)]\t)\\\n\tAS2(\tadd edx, [Wt(i)]\t)\\\n\tAS2(\tadd edx, H(i)\t\t)\\\n\n#define RA1(i, edx, edi)\n\n#define RB0(i, edx, edi)\n\n#define RB1(i, edx, edi)\t\\\n\tAS2(\tmov AS_REG_7d, [Wt_2(i)]\t)\\\n\tAS2(\tmov edi, [Wt_15(i)])\\\n\tAS2(\tmov ebx, AS_REG_7d\t)\\\n\tAS2(\tshr AS_REG_7d, 10\t\t)\\\n\tAS2(\tror ebx, 17\t\t)\\\n\tAS2(\txor AS_REG_7d, ebx\t)\\\n\tAS2(\tror ebx, 2\t\t)\\\n\tAS2(\txor ebx, AS_REG_7d\t)/* s1(W_t-2) */\\\n\tAS2(\tadd ebx, [Wt_7(i)])\\\n\tAS2(\tmov AS_REG_7d, edi\t)\\\n\tAS2(\tshr AS_REG_7d, 3\t\t)\\\n\tAS2(\tror edi, 7\t\t)\\\n\tAS2(\tadd ebx, [Wt(i)])/* s1(W_t-2) + W_t-7 + W_t-16 */\\\n\tAS2(\txor AS_REG_7d, edi\t)\\\n\tAS2(\tadd edx, [Kt(i)])\\\n\tAS2(\tror edi, 11\t\t)\\\n\tAS2(\tadd edx, H(i)\t)\\\n\tAS2(\txor AS_REG_7d, edi\t)/* s0(W_t-15) */\\\n\tAS2(\tadd AS_REG_7d, ebx\t)/* W_t = s1(W_t-2) + W_t-7 + s0(W_t-15) W_t-16*/\\\n\tAS2(\tmov [Wt(i)], AS_REG_7d)\\\n\tAS2(\tadd edx, AS_REG_7d\t)\\\n\n#define ROUND(i, r, eax, ecx, edi, edx)\\\n\t/* in: edi = E\t*/\\\n\t/* unused: eax, ecx, temp: ebx, AS_REG_7d, out: edx = T1 */\\\n\tAS2(\tmov edx, F(i)\t)\\\n\tAS2(\txor edx, G(i)\t)\\\n\tAS2(\tand edx, edi\t)\\\n\tAS2(\txor edx, G(i)\t)/* Ch(E,F,G) = (G^(E&(F^G))) */\\\n\tAS2(\tmov AS_REG_7d, edi\t)\\\n\tAS2(\tror edi, 6\t\t)\\\n\tAS2(\tror AS_REG_7d, 25\t\t)\\\n\tRA##r(i, edx, edi\t\t)/* H + Wt + Kt + Ch(E,F,G) */\\\n\tAS2(\txor AS_REG_7d, edi\t)\\\n\tAS2(\tror edi, 5\t\t)\\\n\tAS2(\txor AS_REG_7d, edi\t)/* S1(E) */\\\n\tAS2(\tadd edx, AS_REG_7d\t)/* T1 = S1(E) + Ch(E,F,G) + H + Wt + Kt */\\\n\tRB##r(i, edx, edi\t\t)/* H + Wt + Kt + Ch(E,F,G) */\\\n\t/* in: ecx = A, eax = B^C, edx = T1 */\\\n\t/* unused: edx, temp: ebx, AS_REG_7d, out: eax = A, ecx = B^C, edx = E */\\\n\tAS2(\tmov ebx, ecx\t)\\\n\tAS2(\txor ecx, B(i)\t)/* A^B */\\\n\tAS2(\tand eax, ecx\t)\\\n\tAS2(\txor eax, B(i)\t)/* Maj(A,B,C) = B^((A^B)&(B^C) */\\\n\tAS2(\tmov AS_REG_7d, ebx\t)\\\n\tAS2(\tror ebx, 2\t\t)\\\n\tAS2(\tadd eax, edx\t)/* T1 + Maj(A,B,C) */\\\n\tAS2(\tadd edx, D(i)\t)\\\n\tAS2(\tmov D(i), edx\t)\\\n\tAS2(\tror AS_REG_7d, 22\t\t)\\\n\tAS2(\txor AS_REG_7d, ebx\t)\\\n\tAS2(\tror ebx, 11\t\t)\\\n\tAS2(\txor AS_REG_7d, ebx\t)\\\n\tAS2(\tadd eax, AS_REG_7d\t)/* T1 + S0(A) + Maj(A,B,C) */\\\n\tAS2(\tmov H(i), eax\t)\\\n\n#define SWAP_COPY(i)\t\t\\\n\tAS2(\tmov\t\tWORD_REG(bx), [WORD_REG(dx)+i*WORD_SZ])\\\n\tAS1(\tbswap\tWORD_REG(bx))\\\n\tAS2(\tmov\t\t[Wt(i*(1+CRYPTOPP_BOOL_X64)+CRYPTOPP_BOOL_X64)], WORD_REG(bx))\n\n#if defined(__GNUC__)\n\t#if CRYPTOPP_BOOL_X64\n\t\tFixedSizeAlignedSecBlock<byte, LOCALS_SIZE> workspace;\n\t#endif\n\t__asm__ __volatile__\n\t(\n\t#if CRYPTOPP_BOOL_X64\n\t\t\"lea %4, %%r8;\"\n\t#endif\n\t\".intel_syntax noprefix;\"\n#elif defined(CRYPTOPP_GENERATE_X64_MASM)\n\t\tALIGN   8\n\tX86_SHA256_HashBlocks\tPROC FRAME\n\t\trex_push_reg rsi\n\t\tpush_reg rdi\n\t\tpush_reg rbx\n\t\tpush_reg rbp\n\t\talloc_stack(LOCALS_SIZE+8)\n\t\t.endprolog\n\t\tmov rdi, r8\n\t\tlea rsi, [?SHA256_K@CryptoPP@@3QBIB + 48*4]\n#endif\n\n#if CRYPTOPP_BOOL_X86\n\t#ifndef __GNUC__\n\t\tAS2(\tmov\t\tedi, [len])\n\t\tAS2(\tlea\t\tWORD_REG(si), [SHA256_K+48*4])\n\t#endif\n\t#if !defined(_MSC_VER) || (_MSC_VER < 1400)\n\t\tAS_PUSH_IF86(bx)\n\t#endif\n\n\tAS_PUSH_IF86(bp)\n\tAS2(\tmov\t\tebx, esp)\n\tAS2(\tand\t\tesp, -16)\n\tAS2(\tsub\t\tWORD_REG(sp), LOCALS_SIZE)\n\tAS_PUSH_IF86(bx)\n#endif\n\tAS2(\tmov\t\tSTATE_SAVE, WORD_REG(cx))\n\tAS2(\tmov\t\tDATA_SAVE, WORD_REG(dx))\n\tAS2(\tlea\t\tWORD_REG(ax), [WORD_REG(di) + WORD_REG(dx)])\n\tAS2(\tmov\t\tDATA_END, WORD_REG(ax))\n\tAS2(\tmov\t\tK_END, WORD_REG(si))\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n#if CRYPTOPP_BOOL_X86\n\tAS2(\ttest\tedi, 1)\n\tASJ(\tjnz,\t2, f)\n\tAS1(\tdec\t\tDWORD PTR K_END)\n#endif\n\tAS2(\tmovdqa\txmm0, XMMWORD_PTR [WORD_REG(cx)+0*16])\n\tAS2(\tmovdqa\txmm1, XMMWORD_PTR [WORD_REG(cx)+1*16])\n#endif\n\n#if CRYPTOPP_BOOL_X86\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\tASJ(\tjmp,\t0, f)\n#endif\n\tASL(2)\t// non-SSE2\n\tAS2(\tmov\t\tesi, ecx)\n\tAS2(\tlea\t\tedi, A(0))\n\tAS2(\tmov\t\tecx, 8)\n\tAS1(\trep movsd)\n\tAS2(\tmov\t\tesi, K_END)\n\tASJ(\tjmp,\t3, f)\n#endif\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\tASL(0)\n\tAS2(\tmovdqa\tE(0), xmm1)\n\tAS2(\tmovdqa\tA(0), xmm0)\n#endif\n#if CRYPTOPP_BOOL_X86\n\tASL(3)\n#endif\n\tAS2(\tsub\t\tWORD_REG(si), 48*4)\n\tSWAP_COPY(0)\tSWAP_COPY(1)\tSWAP_COPY(2)\tSWAP_COPY(3)\n\tSWAP_COPY(4)\tSWAP_COPY(5)\tSWAP_COPY(6)\tSWAP_COPY(7)\n#if CRYPTOPP_BOOL_X86\n\tSWAP_COPY(8)\tSWAP_COPY(9)\tSWAP_COPY(10)\tSWAP_COPY(11)\n\tSWAP_COPY(12)\tSWAP_COPY(13)\tSWAP_COPY(14)\tSWAP_COPY(15)\n#endif\n\tAS2(\tmov\t\tedi, E(0))\t// E\n\tAS2(\tmov\t\teax, B(0))\t// B\n\tAS2(\txor\t\teax, C(0))\t// B^C\n\tAS2(\tmov\t\tecx, A(0))\t// A\n\n\tROUND(0, 0, eax, ecx, edi, edx)\n\tROUND(1, 0, ecx, eax, edx, edi)\n\tROUND(2, 0, eax, ecx, edi, edx)\n\tROUND(3, 0, ecx, eax, edx, edi)\n\tROUND(4, 0, eax, ecx, edi, edx)\n\tROUND(5, 0, ecx, eax, edx, edi)\n\tROUND(6, 0, eax, ecx, edi, edx)\n\tROUND(7, 0, ecx, eax, edx, edi)\n\tROUND(8, 0, eax, ecx, edi, edx)\n\tROUND(9, 0, ecx, eax, edx, edi)\n\tROUND(10, 0, eax, ecx, edi, edx)\n\tROUND(11, 0, ecx, eax, edx, edi)\n\tROUND(12, 0, eax, ecx, edi, edx)\n\tROUND(13, 0, ecx, eax, edx, edi)\n\tROUND(14, 0, eax, ecx, edi, edx)\n\tROUND(15, 0, ecx, eax, edx, edi)\n\n\tASL(1)\n\tAS2(add WORD_REG(si), 4*16)\n\tROUND(0, 1, eax, ecx, edi, edx)\n\tROUND(1, 1, ecx, eax, edx, edi)\n\tROUND(2, 1, eax, ecx, edi, edx)\n\tROUND(3, 1, ecx, eax, edx, edi)\n\tROUND(4, 1, eax, ecx, edi, edx)\n\tROUND(5, 1, ecx, eax, edx, edi)\n\tROUND(6, 1, eax, ecx, edi, edx)\n\tROUND(7, 1, ecx, eax, edx, edi)\n\tROUND(8, 1, eax, ecx, edi, edx)\n\tROUND(9, 1, ecx, eax, edx, edi)\n\tROUND(10, 1, eax, ecx, edi, edx)\n\tROUND(11, 1, ecx, eax, edx, edi)\n\tROUND(12, 1, eax, ecx, edi, edx)\n\tROUND(13, 1, ecx, eax, edx, edi)\n\tROUND(14, 1, eax, ecx, edi, edx)\n\tROUND(15, 1, ecx, eax, edx, edi)\n\tAS2(\tcmp\t\tWORD_REG(si), K_END)\n\tASJ(\tjb,\t\t1, b)\n\n\tAS2(\tmov\t\tWORD_REG(dx), DATA_SAVE)\n\tAS2(\tadd\t\tWORD_REG(dx), 64)\n\tAS2(\tmov\t\tAS_REG_7, STATE_SAVE)\n\tAS2(\tmov\t\tDATA_SAVE, WORD_REG(dx))\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n#if CRYPTOPP_BOOL_X86\n\tAS2(\ttest\tDWORD PTR K_END, 1)\n\tASJ(\tjz,\t\t4, f)\n#endif\n\tAS2(\tmovdqa\txmm1, XMMWORD_PTR [AS_REG_7+1*16])\n\tAS2(\tmovdqa\txmm0, XMMWORD_PTR [AS_REG_7+0*16])\n\tAS2(\tpaddd\txmm1, E(0))\n\tAS2(\tpaddd\txmm0, A(0))\n\tAS2(\tmovdqa\t[AS_REG_7+1*16], xmm1)\n\tAS2(\tmovdqa\t[AS_REG_7+0*16], xmm0)\n\tAS2(\tcmp\t\tWORD_REG(dx), DATA_END)\n\tASJ(\tjb,\t\t0, b)\n#endif\n\n#if CRYPTOPP_BOOL_X86\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\tASJ(\tjmp,\t5, f)\n\tASL(4)\t// non-SSE2\n#endif\n\tAS2(\tadd\t\t[AS_REG_7+0*4], ecx)\t// A\n\tAS2(\tadd\t\t[AS_REG_7+4*4], edi)\t// E\n\tAS2(\tmov\t\teax, B(0))\n\tAS2(\tmov\t\tebx, C(0))\n\tAS2(\tmov\t\tecx, D(0))\n\tAS2(\tadd\t\t[AS_REG_7+1*4], eax)\n\tAS2(\tadd\t\t[AS_REG_7+2*4], ebx)\n\tAS2(\tadd\t\t[AS_REG_7+3*4], ecx)\n\tAS2(\tmov\t\teax, F(0))\n\tAS2(\tmov\t\tebx, G(0))\n\tAS2(\tmov\t\tecx, H(0))\n\tAS2(\tadd\t\t[AS_REG_7+5*4], eax)\n\tAS2(\tadd\t\t[AS_REG_7+6*4], ebx)\n\tAS2(\tadd\t\t[AS_REG_7+7*4], ecx)\n\tAS2(\tmov\t\tecx, AS_REG_7d)\n\tAS2(\tcmp\t\tWORD_REG(dx), DATA_END)\n\tASJ(\tjb,\t\t2, b)\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\tASL(5)\n#endif\n#endif\n\n\tAS_POP_IF86(sp)\n\tAS_POP_IF86(bp)\n\t#if !defined(_MSC_VER) || (_MSC_VER < 1400)\n\t\tAS_POP_IF86(bx)\n\t#endif\n\n#ifdef CRYPTOPP_GENERATE_X64_MASM\n\tadd\t\trsp, LOCALS_SIZE+8\n\tpop\t\trbp\n\tpop\t\trbx\n\tpop\t\trdi\n\tpop\t\trsi\n\tret\n\tX86_SHA256_HashBlocks ENDP\n#endif\n\n#ifdef __GNUC__\n\t\".att_syntax prefix;\"\n\t:\n\t: \"c\" (state), \"d\" (data), \"S\" (SHA256_K+48), \"D\" (len)\n\t#if CRYPTOPP_BOOL_X64\n\t\t, \"m\" (workspace[0])\n\t#endif\n\t: \"memory\", \"cc\", \"%eax\"\n\t#if CRYPTOPP_BOOL_X64\n\t\t, \"%rbx\", \"%r8\", \"%r10\"\n\t#endif\n\t);\n#endif\n}\n\nstatic void SHA256_Transform32(word32 *state, const word32 *data)\n{\n\tword32 W[16];\n\n\tswap32yes(W, data, 16);\n\n\tX86_SHA256_HashBlocks(state, W, 16 * 4);\n}\n\nstatic void runhash32(void *state, const void *input, const void *init)\n{\n\tmemcpy(state, init, 32);\n\tSHA256_Transform32(state, input);\n}\n\n/* suspiciously similar to ScanHash* from bitcoin */\nbool scanhash_asm32(struct thr_info * const thr, struct work * const work,\n\t        uint32_t max_nonce, uint32_t *last_nonce,\n\t\tuint32_t n)\n{\n\tconst uint8_t * const midstate = work->midstate;\n\tuint8_t *data = work->data;\n\tuint8_t hash1[0x40];\n\tmemcpy(hash1, hash1_init, sizeof(hash1));\n\tuint8_t * const hash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *) hash;\n\tuint32_t *nonce = (uint32_t *)(data + 76);\n\n\tdata += 64;\n\n\twhile (1) {\n\t\t*nonce = n;\n\n\t\trunhash32(hash1, data, midstate);\n\t\trunhash32(hash, hash1, sha256_init_state);\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t\t*last_nonce = n;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart) {\n\t\t\t*last_nonce = n;\n\t\t\treturn false;\n\t\t}\n\n\t\t++n;\n\t}\n}\n\n#endif\t// #if defined(WANT_CRYPTOPP_ASM32)\n"
        },
        {
          "name": "sha256_generic.c",
          "type": "blob",
          "size": 9.5078125,
          "content": "/*\n * Copyright Jean-Luc Cooke\n * Copyright Andrew McDonald\n * Copyright 2002 James Morris\n * SHA224 Support Copyright 2007 Intel Corporation (by Jonathan Lynch)\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"driver-cpu.h\"\n#include \"miner.h\"\n\ntypedef uint32_t u32;\ntypedef uint8_t u8;\n\nstatic inline u32 ror32(u32 word, unsigned int shift)\n{\n\treturn (word >> shift) | (word << (32 - shift));\n}\n\nstatic inline u32 Ch(u32 x, u32 y, u32 z)\n{\n\treturn z ^ (x & (y ^ z));\n}\n\nstatic inline u32 Maj(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | (z & (x | y));\n}\n\n#define e0(x)       (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22))\n#define e1(x)       (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25))\n#define s0(x)       (ror32(x, 7) ^ ror32(x,18) ^ (x >> 3))\n#define s1(x)       (ror32(x,17) ^ ror32(x,19) ^ (x >> 10))\n\nstatic inline void LOAD_OP(int I, u32 *W, const u8 *input)\n{\n\t/* byteswap is handled once in scanhash_c\n\t */\n\tW[I] = /* ntohl */ ( ((u32*)(input))[I] );\n}\n\nstatic inline void BLEND_OP(int I, u32 *W)\n{\n\tW[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];\n}\n\nstatic void sha256_transform(u32 *state, const u8 *input)\n{\n\tu32 a, b, c, d, e, f, g, h, t1, t2;\n\tu32 W[64];\n\tint i;\n\n\t/* load the input */\n\tfor (i = 0; i < 16; i++)\n\t\tLOAD_OP(i, W, input);\n\n\t/* now blend */\n\tfor (i = 16; i < 64; i++)\n\t\tBLEND_OP(i, W);\n\n\t/* load the state into our registers */\n\ta=state[0];  b=state[1];  c=state[2];  d=state[3];\n\te=state[4];  f=state[5];  g=state[6];  h=state[7];\n\n\t/* now iterate */\n\tt1 = h + e1(e) + Ch(e,f,g) + 0x428a2f98 + W[ 0];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0x71374491 + W[ 1];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0xb5c0fbcf + W[ 2];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0xe9b5dba5 + W[ 3];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x3956c25b + W[ 4];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0x59f111f1 + W[ 5];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x923f82a4 + W[ 6];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0xab1c5ed5 + W[ 7];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0xd807aa98 + W[ 8];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0x12835b01 + W[ 9];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0x243185be + W[10];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0x550c7dc3 + W[11];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x72be5d74 + W[12];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0x80deb1fe + W[13];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x9bdc06a7 + W[14];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0xc19bf174 + W[15];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0xe49b69c1 + W[16];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0xefbe4786 + W[17];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0x0fc19dc6 + W[18];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0x240ca1cc + W[19];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x2de92c6f + W[20];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0x4a7484aa + W[21];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x5cb0a9dc + W[22];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0x76f988da + W[23];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0x983e5152 + W[24];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0xa831c66d + W[25];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0xb00327c8 + W[26];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0xbf597fc7 + W[27];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0xc6e00bf3 + W[28];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0xd5a79147 + W[29];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x06ca6351 + W[30];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0x14292967 + W[31];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0x27b70a85 + W[32];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0x2e1b2138 + W[33];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0x4d2c6dfc + W[34];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0x53380d13 + W[35];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x650a7354 + W[36];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0x766a0abb + W[37];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x81c2c92e + W[38];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0x92722c85 + W[39];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0xa2bfe8a1 + W[40];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0xa81a664b + W[41];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0xc24b8b70 + W[42];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0xc76c51a3 + W[43];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0xd192e819 + W[44];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0xd6990624 + W[45];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0xf40e3585 + W[46];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0x106aa070 + W[47];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0x19a4c116 + W[48];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0x1e376c08 + W[49];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0x2748774c + W[50];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0x34b0bcb5 + W[51];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x391c0cb3 + W[52];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0x4ed8aa4a + W[53];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0x5b9cca4f + W[54];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0x682e6ff3 + W[55];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tt1 = h + e1(e) + Ch(e,f,g) + 0x748f82ee + W[56];\n\tt2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;\n\tt1 = g + e1(d) + Ch(d,e,f) + 0x78a5636f + W[57];\n\tt2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;\n\tt1 = f + e1(c) + Ch(c,d,e) + 0x84c87814 + W[58];\n\tt2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;\n\tt1 = e + e1(b) + Ch(b,c,d) + 0x8cc70208 + W[59];\n\tt2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;\n\tt1 = d + e1(a) + Ch(a,b,c) + 0x90befffa + W[60];\n\tt2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;\n\tt1 = c + e1(h) + Ch(h,a,b) + 0xa4506ceb + W[61];\n\tt2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;\n\tt1 = b + e1(g) + Ch(g,h,a) + 0xbef9a3f7 + W[62];\n\tt2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;\n\tt1 = a + e1(f) + Ch(f,g,h) + 0xc67178f2 + W[63];\n\tt2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;\n\n\tstate[0] += a; state[1] += b; state[2] += c; state[3] += d;\n\tstate[4] += e; state[5] += f; state[6] += g; state[7] += h;\n\n#if 0\n\t/* clear any sensitive info... */\n\ta = b = c = d = e = f = g = h = t1 = t2 = 0;\n\tmemset(W, 0, 64 * sizeof(u32));\n#endif\n}\n\nstatic void runhash(void *state, const void *input, const void *init)\n{\n\tmemcpy(state, init, 32);\n\tsha256_transform(state, input);\n}\n\nconst uint32_t sha256_init_state[8] = {\n\t0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n\t0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n};\n\n/* suspiciously similar to ScanHash* from bitcoin */\nbool scanhash_c(struct thr_info * const thr, struct work * const work,\n\t        uint32_t max_nonce, uint32_t *last_nonce,\n\t\tuint32_t n)\n{\n\tconst uint8_t *midstate = work->midstate;\n\tuint8_t *data = work->data;\n\tuint8_t hash1[0x40];\n\tmemcpy(hash1, hash1_init, sizeof(hash1));\n\tuint8_t * const hash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *) hash;\n\tuint32_t *nonce = (uint32_t *)(data + 76);\n\tunsigned long stat_ctr = 0;\n\n\tdata += 64;\n\n\t// Midstate and data are stored in little endian\n\tLOCAL_swap32le(unsigned char, midstate, 32/4)\n\tLOCAL_swap32le(unsigned char, data, 64/4)\n\tuint32_t *nonce_w = (uint32_t *)(data + 12);\n\n\twhile (1) {\n\t\t*nonce_w = n;\n\n\t\t// runhash expects int32 data preprocessed into native endian\n\t\trunhash(hash1, data, midstate);\n\t\trunhash(hash, hash1, sha256_init_state);\n\n\t\tstat_ctr++;\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart) {\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn false;\n\t\t}\n\n\t\tn++;\n\t}\n}\n\n"
        },
        {
          "name": "sha256_sse2_amd64.c",
          "type": "blob",
          "size": 3.8994140625,
          "content": "/*\n * Copyright 2011 Mark Crichton\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#ifdef WANT_X8664_SSE2\n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include <xmmintrin.h>\n#include <stdint.h>\n#include <stdio.h>\n\nextern void sha256_sse2_64_new (__m128i *res, __m128i *res1, __m128i *data, const uint32_t init[8])__asm__(\"sha256_sse2_64_new\");\n\nstatic uint32_t g_sha256_k[]__attribute__((aligned(0x100))) = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, /*  0 */\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, /*  8 */\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, /* 16 */\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, /* 24 */\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, /* 32 */\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, /* 40 */\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, /* 48 */\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, /* 56 */\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\nconst uint32_t sha256_init_sse2[8]__asm__(\"sha256_init_sse2\")__attribute__((aligned(0x100))) =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n__m128i sha256_consts_m128i[64]__asm__(\"sha256_consts_m128i\")__attribute__((aligned(0x1000)));\n\nbool scanhash_sse2_64(struct thr_info * const thr, struct work * const work,\n\tuint32_t max_nonce, uint32_t *last_nonce,\n\tuint32_t nonce)\n{\n\tconst uint8_t * const pmidstate = work->midstate;\n\tuint8_t *pdata = work->data;\n\tconst uint32_t * const phash1 = hash1_init;\n\tuint8_t * const phash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *)phash;\n    uint32_t *nNonce_p = (uint32_t *)(pdata + 76);\n    uint32_t m_midstate[8], m_w[16], m_w1[16];\n    __m128i m_4w[64] __attribute__ ((aligned (0x100)));\n    __m128i m_4hash[64] __attribute__ ((aligned (0x100)));\n    __m128i m_4hash1[64] __attribute__ ((aligned (0x100)));\n    __m128i offset;\n    int i;\n\n\tpdata += 64;\n\n    /* For debugging */\n    union {\n        __m128i m;\n        uint32_t i[4];\n    } mi;\n\n    /* Message expansion */\n    memcpy(m_midstate, pmidstate, sizeof(m_midstate));\n    memcpy(m_w, pdata, sizeof(m_w)); /* The 2nd half of the data */\n    memcpy(m_w1, phash1, sizeof(m_w1));\n    memset(m_4hash, 0, sizeof(m_4hash));\n\n    /* Transmongrify */\n    for (i = 0; i < 16; i++)\n        m_4w[i] = _mm_set1_epi32(m_w[i]);\n\n    for (i = 0; i < 16; i++)\n        m_4hash1[i] = _mm_set1_epi32(m_w1[i]);\n\n    for (i = 0; i < 64; i++)\n\tsha256_consts_m128i[i] = _mm_set1_epi32(g_sha256_k[i]);\n\n    offset = _mm_set_epi32(0x3, 0x2, 0x1, 0x0);\n\n    for (;;)\n    {\n\tint j;\n\n\tm_4w[3] = _mm_add_epi32(offset, _mm_set1_epi32(nonce));\n\n\tsha256_sse2_64_new (m_4hash, m_4hash1, m_4w, m_midstate);\n\n\tfor (j = 0; j < 4; j++) {\n\t    mi.m = m_4hash[7];\n\t    if (unlikely(mi.i[j] == 0))\n\t\tbreak;\n        }\n\n\t/* If j = true, we found a hit...so check it */\n\t/* Use the C version for a check... */\n\tif (unlikely(j != 4)) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t    mi.m = m_4hash[i];\n\t\t    *(uint32_t *)&(phash)[i*4] = mi.i[j];\n\t\t}\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t     nonce += j;\n\t\t     *last_nonce = nonce + 1;\n\t\t     *nNonce_p = nonce;\n\t\t     return true;\n\t\t}\n\t}\n\n        if (unlikely((nonce >= max_nonce) || thr->work_restart))\n        {\n\t\t\t*last_nonce = nonce;\n\t\t\treturn false;\n\t}\n\n\tnonce += 4;\n   }\n}\n\n#endif /* WANT_X8664_SSE2 */\n\n"
        },
        {
          "name": "sha256_sse2_i386.c",
          "type": "blob",
          "size": 3.8291015625,
          "content": "/*\n * Copyright 2011 Mark Crichton\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#ifdef WANT_X8632_SSE2\n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include <xmmintrin.h>\n#include <stdint.h>\n#include <stdio.h>\n\nextern void CalcSha256_x86 (__m128i *res, __m128i *data, const uint32_t init[8])__asm__(\"CalcSha256_x86\")__attribute__((fastcall));\n\nstatic uint32_t g_sha256_k[]__attribute__((aligned(0x100))) = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, /*  0 */\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, /*  8 */\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, /* 16 */\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, /* 24 */\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, /* 32 */\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, /* 40 */\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, /* 48 */\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, /* 56 */\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\nconst uint32_t sha256_32init[8]__attribute__((aligned(0x100))) =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n__m128i sha256_consts_m128i[64]__asm__(\"sha256_consts_m128i\")__attribute__((aligned(0x1000)));\n\nbool scanhash_sse2_32(struct thr_info * const thr, struct work * const work,\n\tuint32_t max_nonce, uint32_t *last_nonce,\n\tuint32_t nonce)\n{\n\tconst uint8_t * const pmidstate = work->midstate;\n\tuint8_t *pdata = work->data;\n\tconst uint32_t * const phash1 = hash1_init;\n\tuint8_t * const phash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *)phash;\n    uint32_t *nNonce_p = (uint32_t *)(pdata + 76);\n    uint32_t m_midstate[8], m_w[16], m_w1[16];\n    __m128i m_4w[64] __attribute__ ((aligned (0x100)));\n    __m128i m_4hash[64] __attribute__ ((aligned (0x100)));\n    __m128i m_4hash1[64] __attribute__ ((aligned (0x100)));\n    __m128i offset;\n    int i;\n\n\tpdata += 64;\n\n    /* Message expansion */\n    memcpy(m_midstate, pmidstate, sizeof(m_midstate));\n    memcpy(m_w, pdata, sizeof(m_w)); /* The 2nd half of the data */\n    memcpy(m_w1, phash1, sizeof(m_w1));\n    memset(m_4hash, 0, sizeof(m_4hash));\n\n    /* Transmongrify */\n    for (i = 0; i < 16; i++)\n        m_4w[i] = _mm_set1_epi32(m_w[i]);\n\n    for (i = 0; i < 16; i++)\n        m_4hash1[i] = _mm_set1_epi32(m_w1[i]);\n\n    for (i = 0; i < 64; i++)\n\tsha256_consts_m128i[i] = _mm_set1_epi32(g_sha256_k[i]);\n\n    offset = _mm_set_epi32(0x3, 0x2, 0x1, 0x0);\n\n    for (;;)\n    {\n\tint j;\n\n\tm_4w[3] = _mm_add_epi32(offset, _mm_set1_epi32(nonce));\n\n\t/* Some optimization can be done here W.R.T. precalculating some hash */\n\tCalcSha256_x86 (m_4hash1, m_4w, m_midstate);\n\tCalcSha256_x86 (m_4hash, m_4hash1, sha256_32init);\n\n\tfor (j = 0; j < 4; j++) {\n\t    if (unlikely(((uint32_t *)&(m_4hash[7]))[j] == 0)) {\n\t\t/* We found a hit...so check it */\n\t\t/* Use the C version for a check... */\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t    *(uint32_t *)&(phash)[i<<2] = ((uint32_t *)&(m_4hash[i]))[j];\n\t\t}\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t     nonce += j;\n\t\t     *last_nonce = nonce;\n\t\t     *nNonce_p = nonce;\n\t\t     return true;\n\t\t}\n\t    }\n\t}\n\n\tif (unlikely((nonce >= max_nonce) || thr->work_restart)) {\n\t\t*last_nonce = nonce;\n\t\treturn false;\n\t}\n\n\tnonce += 4;\n\n   }\n}\n\n#endif /* WANT_X8632_SSE2 */\n\n"
        },
        {
          "name": "sha256_sse4_amd64.c",
          "type": "blob",
          "size": 3.720703125,
          "content": "/*\n * Copyright 2011 Mark Crichton\n * Copyright 2012-2013 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#ifdef WANT_X8664_SSE4\n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include <xmmintrin.h>\n#include <stdint.h>\n#include <stdio.h>\n\nextern void CalcSha256_x64_sse4(__m128i *res, __m128i *data, uint32_t init[8])__asm__(\"CalcSha256_x64_sse4\");\n\nstatic uint32_t g_sha256_k[] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, /*  0 */\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, /*  8 */\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, /* 16 */\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, /* 24 */\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, /* 32 */\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, /* 40 */\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, /* 48 */\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, /* 56 */\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n\nstatic uint32_t g_sha256_hinit[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n__m128i g_4sha256_k[64]__asm__(\"g_4sha256_k\");\n\nbool scanhash_sse4_64(struct thr_info * const thr, struct work * const work,\n\tuint32_t max_nonce, uint32_t *last_nonce,\n\tuint32_t nonce)\n{\n\tconst uint8_t * const pmidstate = work->midstate;\n\tuint8_t *pdata = work->data;\n\tconst uint32_t * const phash1 = hash1_init;\n\tuint8_t * const phash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *)phash;\n    uint32_t *nNonce_p = (uint32_t *)(pdata + 76);\n    uint32_t m_midstate[8], m_w[16], m_w1[16];\n    __m128i m_4w[64], m_4hash[64], m_4hash1[64];\n    __m128i offset;\n    int i;\n\n\tpdata += 64;\n\n    /* For debugging */\n    union {\n        __m128i m;\n        uint32_t i[4];\n    } mi;\n\n    /* Message expansion */\n    memcpy(m_midstate, pmidstate, sizeof(m_midstate));\n    memcpy(m_w, pdata, sizeof(m_w)); /* The 2nd half of the data */\n    memcpy(m_w1, phash1, sizeof(m_w1));\n    memset(m_4hash, 0, sizeof(m_4hash));\n\n    /* Transmongrify */\n    for (i = 0; i < 16; i++)\n        m_4w[i] = _mm_set1_epi32(m_w[i]);\n\n    for (i = 0; i < 16; i++)\n        m_4hash1[i] = _mm_set1_epi32(m_w1[i]);\n\n    for (i = 0; i < 64; i++)\n\tg_4sha256_k[i] = _mm_set1_epi32(g_sha256_k[i]);\n\n    offset = _mm_set_epi32(0x3, 0x2, 0x1, 0x0);\n\n    for (;;)\n    {\n\tint j;\n\n\tm_4w[3] = _mm_add_epi32(offset, _mm_set1_epi32(nonce));\n\n\t/* Some optimization can be done here W.R.T. precalculating some hash */\n        CalcSha256_x64_sse4(m_4hash1, m_4w, m_midstate);\n\tCalcSha256_x64_sse4(m_4hash, m_4hash1, g_sha256_hinit);\n\n\tfor (j = 0; j < 4; j++) {\n\t    mi.m = m_4hash[7];\n\t    if (unlikely(mi.i[j] == 0))\n\t\tbreak;\n        }\n\n\t/* If j = true, we found a hit...so check it */\n\t/* Use the C version for a check... */\n\tif (unlikely(j != 4)) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t    mi.m = m_4hash[i];\n\t\t    *(uint32_t *)&(phash)[i*4] = mi.i[j];\n\t\t}\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t\tnonce += j;\n\t\t\t*last_nonce = nonce;\n\t\t\t*nNonce_p = nonce;\n\t\t\treturn true;\n\t\t}\n\t}\n\n        if (unlikely((nonce >= max_nonce) || thr->work_restart))\n        {\n\t\t\t*last_nonce = nonce;\n\t\t\treturn false;\n\t}\n\n\tnonce += 4;\n   }\n}\n\n#endif /* WANT_X8664_SSE4 */\n\n"
        },
        {
          "name": "sha256_via.c",
          "type": "blob",
          "size": 2.2431640625,
          "content": "/*\n * Copyright 2010-2011 Jeff Garzik\n * Copyright 2012-2013 Luke Dashjr\n * Copyright 2011-2012 Con Kolivas\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include \"driver-cpu.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include \"miner.h\"\n\n#ifdef WANT_VIA_PADLOCK\n\nstatic void via_sha256(void *hash, void *buf, unsigned len)\n{\n\tunsigned stat = 0;\n\tasm volatile(\".byte 0xf3, 0x0f, 0xa6, 0xd0\"\n\t\t     :\"+S\"(buf), \"+a\"(stat)\n\t\t     :\"c\"(len), \"D\" (hash)\n\t\t     :\"memory\");\n}\n\nbool scanhash_via(struct thr_info * const thr, struct work * const work,\n\t\t  uint32_t max_nonce, uint32_t *last_nonce,\n\t\t  uint32_t n)\n{\n\tuint8_t * const data_inout = work->data;\n\t\n\tunsigned char data[128] __attribute__((aligned(128)));\n\tunsigned char tmp_hash[32] __attribute__((aligned(128)));\n\tunsigned char tmp_hash1[32] __attribute__((aligned(128)));\n\tuint32_t *data32 = (uint32_t *) data;\n\tuint32_t *hash32 = (uint32_t *) tmp_hash;\n\tuint32_t *nonce = (uint32_t *)(data + 64 + 12);\n\tuint32_t *nonce_inout = (uint32_t *)(data_inout + 64 + 12);\n\tunsigned long stat_ctr = 0;\n\n\t/* bitcoin gives us big endian input, but via wants LE,\n\t * so we reverse the swapping bitcoin has already done (extra work)\n\t * in order to permit the hardware to swap everything\n\t * back to BE again (extra work).\n\t */\n\tswap32yes(data32, data_inout, 128/4);\n\n\twhile (1) {\n\t\t*nonce = n;\n\n\t\t/* first SHA256 transform */\n\t\tmemcpy(tmp_hash1, sha256_init_state, 32);\n\t\tvia_sha256(tmp_hash1, data, 80);\t/* or maybe 128? */\n\n\t\tswap32yes(tmp_hash1, tmp_hash1, 32/4);\n\n\t\t/* second SHA256 transform */\n\t\tmemcpy(tmp_hash, sha256_init_state, 32);\n\t\tvia_sha256(tmp_hash, tmp_hash1, 32);\n\n\t\tstat_ctr++;\n\n\t\tif (unlikely((hash32[7] == 0)))\n\t\t{\n\t\t\t/* swap nonce'd data back into original storage area;\n\t\t\t */\n\t\t\t*nonce_inout = bswap_32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart) {\n\t\t\t*last_nonce = n;\n\t\t\treturn false;\n\t\t}\n\n\t\tn++;\n\t}\n}\n\n#endif /* WANT_VIA_PADLOCK */\n\n"
        },
        {
          "name": "start-bfgminer.sh",
          "type": "blob",
          "size": 0.61328125,
          "content": "#!/bin/sh\nn=\"\n\"\nstartscreen() {\n\tname=\"$1\"; shift\n\tcmd=\"$1\"; shift\n\tif ! screen -ls | grep -q \"^[[:space:]]\\+[0-9]\\+\\.$name\"; then\n\t\tscreen -dmS \"$name\"\n\telse\n\t\tfor i in 1 2 3; do\n\t\t\tscreen -x \"$name\" -p 0 -X stuff $(echo 'x' | tr 'x' '\\003')\n\t\tdone\n\t\tscreen -x \"$name\" -p 0 -X stuff \"stty sane$n\"\n\tfi\n\tscreen -x \"$name\" -p 0 -X stuff \"$cmd$n\"\n}\nPROG=bfgminer\nMYDIR=\"$(dirname \"$0\")\"\nWHICHPROG=\"$(which \"$PROG\" 2>/dev/null)\"\nif test -f \"$MYDIR/$PROG\" && test \"$(realpath \"$WHICHPROG\" 2>/dev/null)\" != \"$(realpath \"$MYDIR/$PROG\")\"; then\n\tPROG=\"cd $(realpath -s \"$MYDIR\")$n./$PROG\"\nfi\nstartscreen miner \"${PROG} ${BFGMINER_OPTS}\"\n"
        },
        {
          "name": "test-bfgminer.sh",
          "type": "blob",
          "size": 0.0771484375,
          "content": "#!/bin/sh\necho $PATH\nbfgminer --unittest --no-default-config --scan noauto -d?\n"
        },
        {
          "name": "titan-asic.c",
          "type": "blob",
          "size": 7.0791015625,
          "content": "/*\n * Copyright 2014 Vitalii Demianets\n * Copyright 2014 KnCMiner\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"miner.h\"\n#include \"logging.h\"\n\n#include \"titan-asic.h\"\n\nbool knc_titan_get_info(int log_level, void * const ctx, int channel, int die, struct knc_die_info *die_info)\n{\n\tint rc;\n\trc = knc_detect_die_(log_level, ctx, channel, die, die_info);\n\treturn (0 == rc);\n}\n\nbool knc_titan_set_work(const char *repr, void * const ctx, int channel, int die, int core, int slot, struct work *work, bool urgent, bool *work_accepted, struct knc_report *report)\n{\n\tint request_length = 4 + 1 + BLOCK_HEADER_BYTES_WITHOUT_NONCE;\n\tuint8_t request[request_length];\n\tint response_length = 1 + 1 + (1 + 4) * 5;\n\tuint8_t response[response_length];\n\tint status;\n\n\trequest_length = knc_prepare_titan_setwork(request, die, core, slot, work, urgent);\n\tstatus = knc_syncronous_transfer(ctx, channel, request_length, request, response_length, response);\n\tif (status == KNC_ACCEPTED) {\n\t\t*work_accepted = true;\n\t} else {\n\t\t*work_accepted = false;\n\t\tif (response[0] == 0x7f) {\n\t\t\tapplog(LOG_DEBUG, \"%s[%d:%d:%d]: Core disabled\", repr, channel, die, core);\n\t\t\treturn false;\n\t\t}\n\t\tif (status & KNC_ERR_MASK) {\n\t\t\tapplog(LOG_INFO, \"%s[%d:%d:%d]: Failed to set work state (%x)\", repr, channel, die, core, status);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(status & KNC_ERR_MASK)) {\n\t\t\t/* !KNC_ERRMASK */\n\t\t\tapplog(LOG_DEBUG, \"%s[%d:%d:%d]: Core busy (%x)\", repr, channel, die, core, status);\n\t\t}\n\t}\n\n\tknc_decode_report(response, report, KNC_VERSION_TITAN);\n\treturn true;\n}\n\nbool knc_titan_set_work_multi(const char *repr, void * const ctx, int channel, int die, int core_start, int slot, struct work *work, bool urgent, bool *work_accepted, struct knc_report *reports, int num)\n{\n\tint REQUEST_BUFSIZE = 4 + 1 + BLOCK_HEADER_BYTES_WITHOUT_NONCE;\n\tint RESPONSE_BUFSIZE = 1 + 1 + (1 + 4) * 5;\n\tint i, core;\n\tuint8_t *requests = NULL;\n\tuint8_t *responses = NULL;\n\tint *request_lengths = NULL;\n\tint *response_lengths = NULL;\n\tint *statuses = NULL;\n\n\trequests = malloc(REQUEST_BUFSIZE * num);\n\tif (NULL == requests)\n\t\tgoto exit_err;\n\tresponses = malloc(RESPONSE_BUFSIZE * num);\n\tif (NULL == responses)\n\t\tgoto exit_err;\n\trequest_lengths = malloc(num * sizeof(int));\n\tif (NULL == request_lengths)\n\t\tgoto exit_err;\n\tresponse_lengths = malloc(num * sizeof(int));\n\tif (NULL == response_lengths)\n\t\tgoto exit_err;\n\tstatuses = malloc(num * sizeof(int));\n\tif (NULL == statuses)\n\t\tgoto exit_err;\n\n\tfor (i = 0, core = core_start; i < num; ++i, ++core) {\n\t\trequest_lengths[i] = knc_prepare_titan_setwork(&requests[REQUEST_BUFSIZE * i], die, core, slot, work, urgent);\n\t\tresponse_lengths[i] = RESPONSE_BUFSIZE;\n\t\tstatuses[i] = KNC_ERR_UNAVAIL;\n\t}\n\n\tknc_syncronous_transfer_multi(ctx, channel, request_lengths, REQUEST_BUFSIZE, requests, response_lengths, RESPONSE_BUFSIZE, responses, statuses, num);\n\n\tfor (i = 0, core = core_start; i < num; ++i, ++core) {\n\t\tuint8_t *response = &responses[RESPONSE_BUFSIZE * i];\n\t\tif (statuses[i] == KNC_ACCEPTED) {\n\t\t\twork_accepted[i] = true;\n\t\t} else {\n\t\t\twork_accepted[i] = false;\n\t\t\tif (response[0] == 0x7f) {\n\t\t\t\tapplog(LOG_DEBUG, \"%s[%d:%d:%d]: Core disabled\", repr, channel, die, core);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (statuses[i] & KNC_ERR_MASK) {\n\t\t\t\tapplog(LOG_INFO, \"%s[%d:%d:%d]: Failed to set work state (%x)\", repr, channel, die, core, statuses[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(statuses[i] & KNC_ERR_MASK)) {\n\t\t\t\tapplog(LOG_DEBUG, \"%s[%d:%d:%d]: Core busy (%x)\", repr, channel, die, core, statuses[i]);\n\t\t\t}\n\t\t}\n\t\tknc_decode_report(response, &reports[i], KNC_VERSION_TITAN);\n\t}\n\n\tfree(response_lengths);\n\tfree(request_lengths);\n\tfree(statuses);\n\tfree(responses);\n\tfree(requests);\n\treturn true;\nexit_err:\n\tif (NULL != response_lengths)\n\t\tfree(response_lengths);\n\tif (NULL != request_lengths)\n\t\tfree(request_lengths);\n\tif (NULL != statuses)\n\t\tfree(statuses);\n\tif (NULL != responses)\n\t\tfree(responses);\n\tif (NULL != requests)\n\t\tfree(requests);\n\treturn false;\n}\n\nbool knc_titan_get_report(const char *repr, void * const ctx, int channel, int die, int core, struct knc_report *report)\n{\n\tuint8_t request[4];\n\tint request_length;\n\tint response_length = 1 + 1 + (1 + 4) * 5;\n\tuint8_t response[response_length];\n\tint status;\n\n\trequest_length = knc_prepare_report(request, die, core);\n\tstatus = knc_syncronous_transfer(ctx, channel, request_length, request, response_length, response);\n\tif (status) {\n\t\tapplog(LOG_INFO, \"%s[%d:%d:%d]: get_report failed (%x)\", repr, channel, die, core, status);\n\t\treturn false;\n\t}\n\n\tknc_decode_report(response, report, KNC_VERSION_TITAN);\n\treturn true;\n}\n\n/* This fails if core is hashing!\n * Stop it before setting up.\n */\nbool knc_titan_setup_core_local(const char *repr, void * const ctx, int channel, int die, int core, struct titan_setup_core_params *params)\n{\n\treturn knc_titan_setup_core_(LOG_INFO, ctx, channel, die, core, params);\n}\n\nbool knc_titan_setup_spi(const char *repr, void * const ctx, int asic, int divider, int preclk, int declk, int sslowmin)\n{\n\tuint8_t request[7];\n\tint request_length;\n\tint status;\n\n\trequest_length = knc_prepare_titan_setup(request, asic, divider, preclk, declk, sslowmin);\n\n\tstatus = knc_syncronous_transfer_fpga(ctx, request_length, request, 0, NULL);\n\tif (status) {\n\t\tapplog(LOG_INFO, \"%s[%d]: setup_spi failed (%x)\", repr, asic, status);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool knc_titan_set_work_parallel(const char *repr, void * const ctx, int asic, int die, int core_start, int slot, struct work *work, bool urgent, int num, int resend)\n{\n\tuint8_t request[9 + BLOCK_HEADER_BYTES_WITHOUT_NONCE];\n\tint request_length;\n\tint status;\n\n\trequest_length = knc_prepare_titan_work_request(request, asic, die, slot, core_start, core_start + num - 1, resend, work);\n\n\tstatus = knc_syncronous_transfer_fpga(ctx, request_length, request, 0, NULL);\n\tif (status) {\n\t\tapplog(LOG_INFO, \"%s[%d]: set_work_parallel failed (%x)\", repr, asic, status);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool knc_titan_get_work_status(const char *repr, void * const ctx, int asic, int *num_request_busy, int *num_status_byte_error)\n{\n\tuint8_t request[2];\n\tint request_length;\n\tint response_length = 2 + 2 * KNC_STATUS_BYTE_ERROR_COUNTERS;\n\tuint8_t response[response_length];\n\tint status;\n\tuint8_t num_request_busy_byte;\n\tuint16_t num_status_byte_error_counters[KNC_STATUS_BYTE_ERROR_COUNTERS];\n\n\trequest_length = knc_prepare_titan_work_status(request, asic);\n\n\tstatus = knc_syncronous_transfer_fpga(ctx, request_length, request, response_length, response);\n\tif (status) {\n\t\tapplog(LOG_INFO, \"%s[%d]: get_work_status failed (%x)\", repr, asic, status);\n\t\treturn false;\n\t}\n\n\tstatus = knc_decode_work_status(response, &num_request_busy_byte, num_status_byte_error_counters);\n\tif (status) {\n\t\tapplog(LOG_INFO, \"%s[%d]: get_work_status got undefined response\", repr, asic);\n\t\treturn false;\n\t}\n\n\t*num_request_busy = num_request_busy_byte;\n\tfor (int i = 0 ; i < KNC_STATUS_BYTE_ERROR_COUNTERS ; i++)\n\t\tnum_status_byte_error[i] = num_status_byte_error_counters[i];\n\treturn true;\n}\n"
        },
        {
          "name": "titan-asic.h",
          "type": "blob",
          "size": 2.2724609375,
          "content": "#ifndef __TITAN_ASIC_H\n#define __TITAN_ASIC_H\n\n#include \"knc-asic/knc-asic.h\"\n#include \"knc-asic/knc-transport.h\"\n\n#define\tKNC_TITAN_MAX_ASICS\t\t6\n#define\tKNC_TITAN_DIES_PER_ASIC\t\t4\n#define\tKNC_TITAN_CORES_PER_DIE\t\t571\n#define\tKNC_TITAN_CORES_PER_ASIC\t(KNC_TITAN_CORES_PER_DIE * KNC_TITAN_DIES_PER_ASIC)\n#define\tKNC_TITAN_WORKSLOTS_PER_CORE\t2\n#define\tKNC_TITAN_THREADS_PER_CORE\t8\n#define\tKNC_TITAN_NONCES_PER_REPORT\t5\n\n/* Valid slot numbers: 1..15 */\n#define\tKNC_TITAN_MIN_WORK_SLOT_NUM\t1\n#define\tKNC_TITAN_MAX_WORK_SLOT_NUM\t15\n\n#define KNC_TITAN_FPGA_SYSCLK_FREQ      24576000\n#define KNC_TITAN_FPGA_SPI_FREQ         6144000\n#define KNC_TITAN_FPGA_SPI_DIVIDER      (KNC_TITAN_FPGA_SYSCLK_FREQ / (2*KNC_TITAN_FPGA_SPI_FREQ) - 1)\n#if KNC_TITAN_FPGA_SYSCLK_FREQ % (2*KNC_TITAN_FPGA_SPI_FREQ) != 0\n#warning Requested SPI frequency could not be accomplished exactly, adjusting as needed\n#endif\n#define KNC_TITAN_FPGA_SPI_PRECLK       7\n#define KNC_TITAN_FPGA_SPI_DECLK        7\n#define KNC_TITAN_FPGA_SPI_SSLOWMIN     15\n#define KNC_TITAN_FPGA_RETRIES          1\n\nstruct nonce_report {\n\tuint32_t nonce;\n\tuint8_t slot;\n};\n\nbool knc_titan_get_info(int log_level, void * const ctx, int channel, int die, struct knc_die_info *die_info);\nbool knc_titan_set_work(const char *repr, void * const ctx, int channel, int die, int core, int slot, struct work *work, bool urgent, bool *work_accepted, struct knc_report *report);\nbool knc_titan_set_work_multi(const char *repr, void * const ctx, int channel, int die, int core_start, int slot, struct work *work, bool urgent, bool *work_accepted, struct knc_report *reports, int num);\nbool knc_titan_get_report(const char *repr, void * const ctx, int channel, int die, int core, struct knc_report *report);\nbool knc_titan_setup_core_local(const char *repr, void * const ctx, int channel, int die, int core, struct titan_setup_core_params *params);\nbool knc_titan_setup_spi(const char *repr, void * const ctx, int asic, int divider, int preclk, int declk, int sslowmin);\nbool knc_titan_set_work_parallel(const char *repr, void * const ctx, int asic, int die, int core_start, int slot, struct work *work, bool urgent, int num, int resend);\nbool knc_titan_get_work_status(const char *repr, void * const ctx, int asic, int *num_request_busy, int *num_status_byte_error);\n\n#endif /* __TITAN_ASIC_H */\n"
        },
        {
          "name": "tm_i2c.c",
          "type": "blob",
          "size": 3.6435546875,
          "content": "/*\n * Copyright 2013 gluk\n * Copyright 2013 Anatoly Legkodymov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n\n#ifdef NEED_LINUX_I2C_H\n#include <linux/i2c.h>\n#endif\n#include <linux/i2c-dev.h>\n\n#include \"logging.h\"\n#include \"tm_i2c.h\"\n\nstatic int tm_i2c_fd;\n\nfloat tm_i2c_Data2Temp(unsigned int ans) {\n\tfloat t = ans;\n\treturn (t / 1023.0 * 3.3 * 2-2.73) * 100.0;\n}\n\nfloat tm_i2c_Data2Core(unsigned int ans) {\n\tfloat t = ans;\n\treturn t / 1023.0 * 3.3;\n}\n\nint tm_i2c_init() {\n\tif ((tm_i2c_fd = open(\"/dev/i2c-1\", O_RDWR)) < 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nvoid tm_i2c_close() {\n\tclose(tm_i2c_fd);\n}\n\nunsigned int tm_i2c_req(int fd, unsigned char addr, unsigned char cmd, unsigned int data) {\n\tint i;\n\tunsigned char buf[16];\n\tstruct i2c_msg msg;\n\ttm_struct *tm = (tm_struct *) buf;\n\tstruct i2c_rdwr_ioctl_data msg_rdwr;\n\tunsigned int ret;\n\n\t//applog(LOG_DEBUG, \"REQ from %02X cmd: %02X\", addr, cmd);\n\n\ttm->cmd = cmd;\n\ttm->data_lsb = data & 0xFF;\n\ttm->data_msb = (data & 0xFF00) >> 8;\n\n\t/* Write CMD */\n\tmsg.addr = addr;\n\tmsg.flags = 0;\n\tmsg.len = 3;\n\tmsg.buf = (void*)tm;\n\tmsg_rdwr.msgs = &msg;\n\tmsg_rdwr.nmsgs = 1;\n\tif ((i = ioctl(fd, I2C_RDWR, &msg_rdwr)) < 0) {\n//\t\tperror(\"ioctl error\");\n\t\treturn -1;\n\t}\n\n\t/* Read result */\n\tmsg.addr = addr;\n\tmsg.flags = I2C_M_RD;\n\tmsg.len = 3;\n\tmsg.buf = (void*)tm;\n\tmsg_rdwr.msgs = &msg;\n\tmsg_rdwr.nmsgs = 1;\n\tif ((i = ioctl(fd, I2C_RDWR, &msg_rdwr)) < 0) {\n//\t\tperror(\"ioctl error\");\n\t\treturn -1;\n\t}\n\n\tret = (tm->data_msb << 8) + tm->data_lsb;\n\tif (tm->cmd == cmd) return ret;\n\treturn 0;\n}\n\nint tm_i2c_detect(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return 0;\n\treturn tm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_GET_CORE0, 0);\n}\n\nfloat tm_i2c_getcore0(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return 0;\n\treturn tm_i2c_Data2Core(tm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_GET_CORE0, 0));\n}\n\nfloat tm_i2c_getcore1(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return 0;\n\treturn tm_i2c_Data2Core(tm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_GET_CORE1, 0));\n}\n\nfloat tm_i2c_gettemp(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return 0;\n\treturn tm_i2c_Data2Temp(tm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_GET_TEMP, 0));\n}\n\nvoid tm_i2c_set_oe(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return;\n\ttm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_SET_OE, 0);\n}\n\nvoid tm_i2c_clear_oe(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return;\n\ttm_i2c_req(tm_i2c_fd, (TM_ADDR >> 1) + slot, TM_SET_OE, 1);\n}\n\nunsigned char tm_i2c_slot2addr(unsigned char slot) {\n\tif (slot < 0 || slot > 31) return 0;\n\treturn ((TM_ADDR >> 1) + slot);\n}\n\n"
        },
        {
          "name": "tm_i2c.h",
          "type": "blob",
          "size": 1.1064453125,
          "content": "/* - Version 1.0 - */\n\n#define TM_ADDR         0xC0\n\n#define TM_GET_TEMP     0x10\n#define TM_GET_CORE0    0x11\n#define TM_GET_CORE1    0x12\n\n#define TM_SET_OE       0x20\n#define TM_SET_MODE     0x21\n#define TM_SET_RED      0x22\n#define TM_SET_GREEN    0x23\n\n#define TM_GET_PORTB    0x30\n#define TM_SET_PORTB    0x31\n#define TM_GET_PINB     0x32\n#define TM_GET_PORTD    0x33\n#define TM_SET_PORTD    0x34\n#define TM_GET_PIND     0x35\n#define TM_GET_ADC      0x36\n\n#define TM_MODE_AUTO    0\n#define TM_MODE_MANUAL  1\n\ntypedef struct {\n\tunsigned char cmd;\n\tunsigned char data_lsb;\n\tunsigned char data_msb;\n} tm_struct;\n\nint tm_i2c_init();\nvoid tm_i2c_close();\nunsigned int tm_i2c_req(int fd, unsigned char addr, unsigned char cmd, unsigned int data);\nfloat tm_i2c_Data2Temp(unsigned int ans);\nfloat tm_i2c_Data2Core(unsigned int ans);\nfloat tm_i2c_gettemp(unsigned char slot);\nfloat tm_i2c_getcore0(unsigned char slot);\nfloat tm_i2c_getcore1(unsigned char slot);\nvoid tm_i2c_set_oe(unsigned char slot);\nvoid tm_i2c_clear_oe(unsigned char slot);\nint tm_i2c_detect(unsigned char slot);\nunsigned char tm_i2c_slot2addr(unsigned char slot);\n\n"
        },
        {
          "name": "todo_ztex.txt",
          "type": "blob",
          "size": 0.1806640625,
          "content": "- verify setting cgpu.status=DEAD does in fact stop the thread\n- allow configuring bitstream directory\n- HS fpga config\n- allow configuring LIBZTEX_OVERHEATTHRESHOLD\n- hotplug support?\n"
        },
        {
          "name": "usbtest.py",
          "type": "blob",
          "size": 3.3583984375,
          "content": "#!/usr/bin/env python\n# Copyright 2012-2013 Xiangfu\n# Copyright 2012-2013 Andrew Smith\n# Copyright 2013 Luke Dashjr\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option) any later\n# version.  See COPYING for more details.\n\n# Linux usage: ./usbtest.py /dev/ttyUSB0 0xhexcodes|string|icarus\n#  OR          python usbtest.py /dev/ttyUSB0 0xhexcodes|string|icarus\n#\n# Windows usage: ./usbtest.py COM1 0xhexcodes|string|icarus\n#\n#   sends the data sepcified to the USB device and waits\n#   for a reply then displays it\n#\n#   the data can be:\n#\t0xhexcodes: e.g. 0x68656c6c6f20776f726c640a\n#\t\t\twould send \"hello world\\n\"\n#\n#\tstring: e.g. sendsometext\n#\n#\ticarus: sends 2 known block payloads for an icarus device\n#\t\tand shows the expected and actual answers if it's\n#\t\ta working V3 icarus\n\nimport sys\nimport serial\nimport binascii\n\nif len(sys.argv) < 2:\n\tsys.stderr.write(\"Usage: \" + sys.argv[0] + \" device strings...\\n\")\n\tsys.stderr.write(\" where device is either like /dev/ttyUSB0 or COM1\\n\")\n\tsys.stderr.write(\" and strings are either '0xXXXX' or 'text'\\n\")\n\tsys.stderr.write(\" if the first string is 'icarus' the rest are ignored\\n\")\n\tsys.stderr.write(\"  and 2 valid icarus test payloads are sent with results displayed\\n\")\n\tsys.stderr.write(\"\\nAfter any command is sent it waits up to 30 seconds for a reply\\n\");\n\tsys.exit(\"Aborting\")\n\n# Open with a 10 second timeout - just to be sure\nser = serial.Serial(sys.argv[1], 115200, serial.EIGHTBITS, serial.PARITY_NONE, serial.STOPBITS_ONE, 10, False, False, 5)\n\nif sys.argv[2] == \"icarus\":\n\n\t# This show how Icarus use the block and midstate data\n\t# This will produce nonce 063c5e01\n\tblock = \"0000000120c8222d0497a7ab44a1a2c7bf39de941c9970b1dc7cdc400000079700000000e88aabe1f353238c668d8a4df9318e614c10c474f8cdf8bc5f6397b946c33d7c4e7242c31a098ea500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000\"\n\tmidstate = \"33c5bf5751ec7f7e056443b5aee3800331432c83f404d9de38b94ecbf907b92d\"\n\n\trdata2  = binascii.a2b_hex(block.encode('ascii'))[95:63:-1]\n\trmid    = binascii.a2b_hex(midstate.encode('ascii'))[::-1]\n\tpayload = rmid + rdata2\n\n\tprint(\"Push payload to icarus: \" + binascii.hexlify(payload).decode('ascii'))\n\tser.write(payload)\n\n\tb=ser.read(4)\n\tprint(\"Result:(should be: 063c5e01): \" + binascii.hexlify(b).decode('ascii'))\n\n\t# Just another test\n\tpayload2 = \"ce92099c5a80bb81c52990d5c0924c625fd25a535640607d5a4bdf8174e2c8d500000000000000000000000080000000000000000b290c1a42313b4f21b5bcb8\"\n\tprint(\"Push payload to icarus: \" + payload2)\n\tser.write(binascii.a2b_hex(payload2.encode('ascii')))\n\n\tb=ser.read(4)\n\tprint(\"Result:(should be: 8e0b31c5): \" + binascii.hexlify(b).decode('ascii'))\nelse:\n\tdata = b\"\"\n\tfor arg in sys.argv[2::]:\n\t\tif arg[0:2:] == '0x':\n\t\t\tdata += binascii.a2b_hex(arg[2::].encode('ascii'))\n\t\telse:\n\t\t\tdata += arg.encode('latin-1')\n\n\tprint(\"Sending: 0x\" + binascii.hexlify(data).decode('ascii'))\n\tser.write(data)\n\n\t# If you're expecting more than one linefeed terminated reply,\n\t# you'll only see the first one\n\t# AND with no linefeed, this will wait the 10 seconds before returning\n\tprint(\"Waiting up to 10 seconds ...\")\n\tb=ser.readline()\n\tprint(\"Result: hex 0x\" + binascii.hexlify(b).decode('ascii'))\n\n\tprint(\"Result: asc %s\" % (repr(b),))\n\nser.close()\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 104.6064453125,
          "content": "/*\n * Copyright 2011-2014 Con Kolivas\n * Copyright 2011-2017 Luke Dashjr\n * Copyright 2014 Nate Woolls\n * Copyright 2010-2011 Jeff Garzik\n * Copyright 2012 Giel van Schijndel\n * Copyright 2012 Gavin Andresen\n * Copyright 2013 Lingchao Xu\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <float.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <pthread.h>\n#include <jansson.h>\n#include <curl/curl.h>\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_PRCTL_H\n# include <sys/prctl.h>\n#endif\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n# include <pthread_np.h>\n#endif\n#ifndef WIN32\n#include <fcntl.h>\n# ifdef __linux\n#  include <sys/prctl.h>\n# endif\n# include <sys/socket.h>\n# include <netinet/in.h>\n# include <netinet/tcp.h>\n# include <netdb.h>\n#else\n# include <windows.h>\n# include <winsock2.h>\n# include <mstcpip.h>\n# include <ws2tcpip.h>\n# include <mmsystem.h>\n#endif\n\n#include <libbase58.h>\n#include <utlist.h>\n\n#ifdef NEED_BFG_LOWL_VCOM\n#include \"lowl-vcom.h\"\n#endif\n#include \"miner.h\"\n#include \"compat.h\"\n#include \"util.h\"\n\n#define DEFAULT_SOCKWAIT 60\n\nbool successful_connect = false;\nstruct timeval nettime;\n\nstruct data_buffer {\n\tvoid\t\t*buf;\n\tsize_t\t\tlen;\n\tcurl_socket_t\t*idlemarker;\n};\n\nstruct upload_buffer {\n\tconst void\t*buf;\n\tsize_t\t\tlen;\n\tsize_t\t\tpos;\n};\n\nstruct header_info {\n\tchar\t\t*lp_path;\n\tint\t\trolltime;\n\tchar\t\t*reason;\n\tchar\t\t*stratum_url;\n\tbool\t\thadrolltime;\n\tbool\t\tcanroll;\n\tbool\t\thadexpire;\n};\n\nstruct tq_ent {\n\tvoid\t\t\t*data;\n\tstruct tq_ent *prev;\n\tstruct tq_ent *next;\n};\n\nstatic void databuf_free(struct data_buffer *db)\n{\n\tif (!db)\n\t\treturn;\n\n\tfree(db->buf);\n#ifdef DEBUG_DATABUF\n\tapplog(LOG_DEBUG, \"databuf_free(%p)\", db->buf);\n#endif\n\n\tmemset(db, 0, sizeof(*db));\n}\n\nstruct json_rpc_call_state {\n\tstruct data_buffer all_data;\n\tstruct header_info hi;\n\tvoid *priv;\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tstruct curl_slist *headers;\n\tstruct upload_buffer upload_data;\n\tstruct pool *pool;\n\tbool longpoll;\n};\n\n// aka data_buffer_write\nstatic size_t all_data_cb(const void *ptr, size_t size, size_t nmemb,\n\t\t\t  void *user_data)\n{\n\tstruct data_buffer *db = user_data;\n\tsize_t oldlen, newlen;\n\n\toldlen = db->len;\n\tif (unlikely(nmemb == 0 || size == 0 || oldlen >= SIZE_MAX - size))\n\t\treturn 0;\n\tif (unlikely(nmemb > (SIZE_MAX - oldlen) / size))\n\t\tnmemb = (SIZE_MAX - oldlen) / size;\n\n\tsize_t len = size * nmemb;\n\tvoid *newmem;\n\tstatic const unsigned char zero = 0;\n\n\tif (db->idlemarker) {\n\t\tconst unsigned char *cptr = ptr;\n\t\tfor (size_t i = 0; i < len; ++i)\n\t\t\tif (!(isCspace(cptr[i]) || cptr[i] == '{')) {\n\t\t\t\t*db->idlemarker = CURL_SOCKET_BAD;\n\t\t\t\tdb->idlemarker = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tnewlen = oldlen + len;\n\n\tnewmem = realloc(db->buf, newlen + 1);\n#ifdef DEBUG_DATABUF\n\tapplog(LOG_DEBUG, \"data_buffer_write realloc(%p, %lu) => %p\", db->buf, (long unsigned)(newlen + 1), newmem);\n#endif\n\tif (!newmem)\n\t\treturn 0;\n\n\tdb->buf = newmem;\n\tdb->len = newlen;\n\tmemcpy(db->buf + oldlen, ptr, len);\n\tmemcpy(db->buf + newlen, &zero, 1);\t/* null terminate */\n\n\treturn nmemb;\n}\n\nstatic size_t upload_data_cb(void *ptr, size_t size, size_t nmemb,\n\t\t\t     void *user_data)\n{\n\tstruct json_rpc_call_state * const state = user_data;\n\tstruct upload_buffer * const ub = &state->upload_data;\n\tunsigned int len = size * nmemb;\n\t\n\tif (state->longpoll)\n\t{\n\t\tstruct pool * const pool = state->pool;\n\t\tpool->lp_active = true;\n\t}\n\n\tif (len > ub->len - ub->pos)\n\t\tlen = ub->len - ub->pos;\n\n\tif (len) {\n\t\tmemcpy(ptr, ub->buf + ub->pos, len);\n\t\tub->pos += len;\n\t}\n\n\treturn len;\n}\n\n#if LIBCURL_VERSION_NUM >= 0x071200\nstatic int seek_data_cb(void *user_data, curl_off_t offset, int origin)\n{\n\tstruct json_rpc_call_state * const state = user_data;\n\tstruct upload_buffer * const ub = &state->upload_data;\n\t\n\tswitch (origin) {\n\t\tcase SEEK_SET:\n\t\t\tif (offset < 0 || offset > ub->len)\n\t\t\t\treturn 1;\n\t\t\tub->pos = offset;\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\t// Check the offset is valid, taking care to avoid overflows or negative unsigned numbers\n\t\t\tif (offset < 0 && ub->pos < (size_t)-offset)\n\t\t\t\treturn 1;\n\t\t\tif (ub->len < offset)\n\t\t\t\treturn 1;\n\t\t\tif (ub->pos > ub->len - offset)\n\t\t\t\treturn 1;\n\t\t\tub->pos += offset;\n\t\t\tbreak;\n\t\tcase SEEK_END:\n\t\t\tif (offset > 0 || (size_t)-offset > ub->len)\n\t\t\t\treturn 1;\n\t\t\tub->pos = ub->len + offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;  /* CURL_SEEKFUNC_FAIL */\n\t}\n\t\n\treturn 0;  /* CURL_SEEKFUNC_OK */\n}\n#endif\n\nstatic size_t resp_hdr_cb(void *ptr, size_t size, size_t nmemb, void *user_data)\n{\n\tstruct header_info *hi = user_data;\n\tsize_t remlen, slen, ptrlen = size * nmemb;\n\tchar *rem, *val = NULL, *key = NULL;\n\tvoid *tmp;\n\n\tval = calloc(1, ptrlen);\n\tkey = calloc(1, ptrlen);\n\tif (!key || !val)\n\t\tgoto out;\n\n\ttmp = memchr(ptr, ':', ptrlen);\n\tif (!tmp || (tmp == ptr))\t/* skip empty keys / blanks */\n\t\tgoto out;\n\tslen = tmp - ptr;\n\tif ((slen + 1) == ptrlen)\t/* skip key w/ no value */\n\t\tgoto out;\n\tmemcpy(key, ptr, slen);\t\t/* store & nul term key */\n\tkey[slen] = 0;\n\n\trem = ptr + slen + 1;\t\t/* trim value's leading whitespace */\n\tremlen = ptrlen - slen - 1;\n\twhile ((remlen > 0) && (isCspace(*rem))) {\n\t\tremlen--;\n\t\trem++;\n\t}\n\n\tmemcpy(val, rem, remlen);\t/* store value, trim trailing ws */\n\tval[remlen] = 0;\n\twhile ((*val) && (isCspace(val[strlen(val) - 1])))\n\t\tval[strlen(val) - 1] = 0;\n\n\tif (!*val)\t\t\t/* skip blank value */\n\t\tgoto out;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);\n\n\tif (!strcasecmp(\"X-Roll-Ntime\", key)) {\n\t\thi->hadrolltime = true;\n\t\tif (!strncasecmp(\"N\", val, 1))\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime: N found\");\n\t\telse {\n\t\t\thi->canroll = true;\n\n\t\t\t/* Check to see if expire= is supported and if not, set\n\t\t\t * the rolltime to the default scantime */\n\t\t\tif (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {\n\t\t\t\tsscanf(val + 7, \"%d\", &hi->rolltime);\n\t\t\t\thi->hadexpire = true;\n\t\t\t} else\n\t\t\t\thi->rolltime = opt_scantime;\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);\n\t\t}\n\t}\n\n\tif (!strcasecmp(\"X-Long-Polling\", key)) {\n\t\thi->lp_path = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Reject-Reason\", key)) {\n\t\thi->reason = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Stratum\", key)) {\n\t\thi->stratum_url = val;\n\t\tval = NULL;\n\t}\n\nout:\n\tfree(key);\n\tfree(val);\n\treturn ptrlen;\n}\n\nstatic int keep_sockalive(SOCKETTYPE fd)\n{\n\tconst int tcp_one = 1;\n\tconst int tcp_keepidle = 45;\n\tconst int tcp_keepintvl = 30;\n\tint ret = 0;\n\n\tif (unlikely(setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one))))\n\t\tret = 1;\n\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n\n\tif (!opt_delaynet)\n#ifndef __linux\n\t\tif (unlikely(setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one))))\n#else /* __linux */\n\t\tif (unlikely(setsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one))))\n#endif /* __linux */\n\t\t\tret = 1;\n\n#ifdef __linux\n\n\tif (unlikely(setsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one))))\n\t\tret = 1;\n\n\tif (unlikely(setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle))))\n\t\tret = 1;\n\n\tif (unlikely(setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl))))\n\t\tret = 1;\n#endif /* __linux */\n\n#ifdef __APPLE_CC__\n\n\tif (unlikely(setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl))))\n\t\tret = 1;\n\n#endif /* __APPLE_CC__ */\n\n#ifdef WIN32\n\n\tconst int zero = 0;\n\tstruct tcp_keepalive vals;\n\tvals.onoff = 1;\n\tvals.keepalivetime = tcp_keepidle * 1000;\n\tvals.keepaliveinterval = tcp_keepintvl * 1000;\n\n\tDWORD outputBytes;\n\n\tif (unlikely(WSAIoctl(fd, SIO_KEEPALIVE_VALS, &vals, sizeof(vals), NULL, 0, &outputBytes, NULL, NULL)))\n\t\tret = 1;\n\n\t/* Windows happily submits indefinitely to the send buffer blissfully\n\t * unaware nothing is getting there without gracefully failing unless\n\t * we disable the send buffer */\n\tif (unlikely(setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (const char *)&zero, sizeof(zero))))\n\t\tret = 1;\n#endif /* WIN32 */\n\n\treturn ret;\n}\n\nvoid set_cloexec_socket(SOCKETTYPE sock, const bool cloexec)\n{\n#ifdef WIN32\n\tSetHandleInformation((HANDLE)sock, HANDLE_FLAG_INHERIT, cloexec ? 0 : HANDLE_FLAG_INHERIT);\n#elif defined(F_GETFD) && defined(F_SETFD) && defined(O_CLOEXEC)\n\tconst int curflags = fcntl(sock, F_GETFD);\n\tint flags = curflags;\n\tif (cloexec)\n\t\tflags |= FD_CLOEXEC;\n\telse\n\t\tflags &= ~FD_CLOEXEC;\n\tif (flags != curflags)\n\t\tfcntl(sock, F_SETFD, flags);\n#endif\n}\n\nint json_rpc_call_sockopt_cb(void __maybe_unused *userdata, curl_socket_t fd,\n\t\t\t     curlsocktype __maybe_unused purpose)\n{\n\treturn keep_sockalive(fd);\n}\n\nstatic void last_nettime(struct timeval *last)\n{\n\trd_lock(&netacc_lock);\n\tlast->tv_sec = nettime.tv_sec;\n\tlast->tv_usec = nettime.tv_usec;\n\trd_unlock(&netacc_lock);\n}\n\nstatic void set_nettime(void)\n{\n\twr_lock(&netacc_lock);\n\tcgtime(&nettime);\n\twr_unlock(&netacc_lock);\n}\n\nstatic int curl_debug_cb(__maybe_unused CURL *handle, curl_infotype type,\n\t\t\t char *data, size_t size,\n\t\t\t void *userdata)\n{\n\tstruct pool *pool = (struct pool *)userdata;\n\n\tswitch(type) {\n\t\tcase CURLINFO_HEADER_IN:\n\t\tcase CURLINFO_DATA_IN:\n\t\tcase CURLINFO_SSL_DATA_IN:\n\t\t\tpool->cgminer_pool_stats.bytes_received += size;\n\t\t\ttotal_bytes_rcvd += size;\n\t\t\tpool->cgminer_pool_stats.net_bytes_received += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_HEADER_OUT:\n\t\tcase CURLINFO_DATA_OUT:\n\t\tcase CURLINFO_SSL_DATA_OUT:\n\t\t\tpool->cgminer_pool_stats.bytes_sent += size;\n\t\t\ttotal_bytes_sent += size;\n\t\t\tpool->cgminer_pool_stats.net_bytes_sent += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_TEXT:\n\t\t{\n\t\t\tif (!opt_protocol)\n\t\t\t\tbreak;\n\t\t\t// data is not null-terminated, so we need to copy and terminate it for applog\n\t\t\tchar datacp[size + 1];\n\t\t\tmemcpy(datacp, data, size);\n\t\t\twhile (likely(size) && unlikely(isCspace(datacp[size-1])))\n\t\t\t\t--size;\n\t\t\tif (unlikely(!size))\n\t\t\t\tbreak;\n\t\t\tdatacp[size] = '\\0';\n\t\t\tapplog(LOG_DEBUG, \"Pool %u: %s\", pool->pool_no, datacp);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\njson_t *json_web_config(CURL *curl, const char *url)\n{\n\tstruct data_buffer all_data = {NULL, 0};\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tjson_error_t err;\n\tlong timeout = 60;\n\tjson_t *val;\n\tint rc;\n\n\tmemset(&err, 0, sizeof(err));\n\n\t/* it is assumed that 'curl' is freshly [re]initialized at this pt */\n\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\tcurl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1);\n\t\n\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);\n\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_ENCODING, \"\");\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);\n\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\n\tval = NULL;\n\trc = curl_easy_perform(curl);\n\tif (rc) {\n\t\tapplog(LOG_ERR, \"HTTP config request of '%s' failed: %s\",\n\t\t\t\turl, curl_err_str);\n\t\tgoto c_out;\n\t}\n\n\tif (!all_data.buf) {\n\t\tapplog(LOG_ERR, \"Empty config data received from '%s'\",\n\t\t\t\turl);\n\t\tgoto c_out;\n\t}\n\n\tval = JSON_LOADS(all_data.buf, &err);\n\tif (!val) {\n\t\tapplog(LOG_ERR, \"JSON config decode of '%s' failed(%d): %s\",\n\t\t\t\turl, err.line, err.text);\n\t\tgoto c_out;\n\t}\n\nc_out:\n\tdatabuf_free(&all_data);\n\tcurl_easy_reset(curl);\n\treturn val;\n}\n\nvoid json_rpc_call_async(CURL *curl, const char *url,\n\t\t      const char *userpass, const char *rpc_req,\n\t\t      bool longpoll,\n\t\t      struct pool *pool, bool share,\n\t\t      void *priv)\n{\n\tstruct json_rpc_call_state *state = malloc(sizeof(struct json_rpc_call_state));\n\t*state = (struct json_rpc_call_state){\n\t\t.priv = priv,\n\t\t.pool = pool,\n\t};\n\tlong timeout = longpoll ? (60 * 60) : 60;\n\tchar len_hdr[64], user_agent_hdr[128];\n\tstruct curl_slist *headers = NULL;\n\n\tif (longpoll)\n\t{\n\t\tstate->all_data.idlemarker = &pool->lp_socket;\n\t\tstate->longpoll = true;\n\t}\n\n\t/* it is assumed that 'curl' is freshly [re]initialized at this pt */\n\n\tcurl_easy_setopt(curl, CURLOPT_PRIVATE, state);\n\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);\n\n\t/* We use DEBUGFUNCTION to count bytes sent/received, and verbose is needed\n\t * to enable it */\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);\n\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_ENCODING, \"\");\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\n\t/* Shares are staggered already and delays in submission can be costly\n\t * so do not delay them */\n\tif (!opt_delaynet || share)\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &state->all_data);\n\tcurl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_READDATA, state);\n#if LIBCURL_VERSION_NUM >= 0x071200\n\tcurl_easy_setopt(curl, CURLOPT_SEEKFUNCTION, &seek_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_SEEKDATA, state);\n#endif\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &state->curl_err_str[0]);\n\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERDATA, &state->hi);\n\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\tif (pool->rpc_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);\n\t} else if (opt_socks_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);\n\t}\n\tif (userpass) {\n\t\tcurl_easy_setopt(curl, CURLOPT_USERPWD, userpass);\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n\t}\n\tif (longpoll)\n\t\tcurl_easy_setopt(curl, CURLOPT_SOCKOPTFUNCTION, json_rpc_call_sockopt_cb);\n\tcurl_easy_setopt(curl, CURLOPT_POST, 1);\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);\n\n\tstate->upload_data.buf = rpc_req;\n\tstate->upload_data.len = strlen(rpc_req);\n\tstate->upload_data.pos = 0;\n\tsprintf(len_hdr, \"Content-Length: %lu\",\n\t\t(unsigned long) state->upload_data.len);\n\tsprintf(user_agent_hdr, \"User-Agent: %s\", bfgminer_name_slash_ver);\n\n\theaders = curl_slist_append(headers,\n\t\t\"Content-type: application/json\");\n\theaders = curl_slist_append(headers,\n\t\t\"X-Mining-Extensions: longpoll midstate rollntime submitold\");\n\n\tif (longpoll)\n\t\theaders = curl_slist_append(headers,\n\t\t\t\"X-Minimum-Wait: 0\");\n\n\tif (likely(global_hashrate)) {\n\t\tchar ghashrate[255];\n\n\t\tsprintf(ghashrate, \"X-Mining-Hashrate: %\"PRIu64, (uint64_t)global_hashrate);\n\t\theaders = curl_slist_append(headers, ghashrate);\n\t}\n\n\theaders = curl_slist_append(headers, len_hdr);\n\theaders = curl_slist_append(headers, user_agent_hdr);\n\theaders = curl_slist_append(headers, \"Expect:\"); /* disable Expect hdr*/\n\n\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\tstate->headers = headers;\n\n\tif (opt_delaynet) {\n\t\t/* Don't delay share submission, but still track the nettime */\n\t\tif (!share) {\n\t\t\tlong long now_msecs, last_msecs;\n\t\t\tstruct timeval now, last;\n\n\t\t\tcgtime(&now);\n\t\t\tlast_nettime(&last);\n\t\t\tnow_msecs = (long long)now.tv_sec * 1000;\n\t\t\tnow_msecs += now.tv_usec / 1000;\n\t\t\tlast_msecs = (long long)last.tv_sec * 1000;\n\t\t\tlast_msecs += last.tv_usec / 1000;\n\t\t\tif (now_msecs > last_msecs && now_msecs - last_msecs < 250) {\n\t\t\t\tstruct timespec rgtp;\n\n\t\t\t\trgtp.tv_sec = 0;\n\t\t\t\trgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;\n\t\t\t\tnanosleep(&rgtp, NULL);\n\t\t\t}\n\t\t}\n\t\tset_nettime();\n\t}\n}\n\njson_t *json_rpc_call_completed(CURL *curl, int rc, bool probe, int *rolltime, void *out_priv)\n{\n\tstruct json_rpc_call_state *state;\n\tif (curl_easy_getinfo(curl, CURLINFO_PRIVATE, (void*)&state) != CURLE_OK) {\n\t\tapplog(LOG_ERR, \"Failed to get private curl data\");\n\t\tif (out_priv)\n\t\t\t*(void**)out_priv = NULL;\n\t\tgoto err_out;\n\t}\n\tif (out_priv)\n\t\t*(void**)out_priv = state->priv;\n\n\tjson_t *val, *err_val, *res_val;\n\tjson_error_t err;\n\tstruct pool *pool = state->pool;\n\tbool probing = probe && !pool->probed;\n\n\tif (rc) {\n\t\tapplog(LOG_DEBUG, \"HTTP request failed: %s\", state->curl_err_str);\n\t\tgoto err_out;\n\t}\n\n\tif (!state->all_data.buf) {\n\t\tapplog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");\n\t\tgoto err_out;\n\t}\n\n\tpool->cgminer_pool_stats.times_sent++;\n\tpool->cgminer_pool_stats.times_received++;\n\n\tif (probing) {\n\t\tpool->probed = true;\n\t\t/* If X-Long-Polling was found, activate long polling */\n\t\tif (state->hi.lp_path) {\n\t\t\tif (pool->hdr_path != NULL)\n\t\t\t\tfree(pool->hdr_path);\n\t\t\tpool->hdr_path = state->hi.lp_path;\n\t\t} else\n\t\t\tpool->hdr_path = NULL;\n\t\tif (state->hi.stratum_url) {\n\t\t\tpool->stratum_url = state->hi.stratum_url;\n\t\t\tstate->hi.stratum_url = NULL;\n\t\t}\n\t} else {\n\t\tif (state->hi.lp_path) {\n\t\t\tfree(state->hi.lp_path);\n\t\t\tstate->hi.lp_path = NULL;\n\t\t}\n\t\tif (state->hi.stratum_url) {\n\t\t\tfree(state->hi.stratum_url);\n\t\t\tstate->hi.stratum_url = NULL;\n\t\t}\n\t}\n\n\tif (pool->force_rollntime)\n\t{\n\t\tstate->hi.canroll = true;\n\t\tstate->hi.hadexpire = true;\n\t\tstate->hi.rolltime = pool->force_rollntime;\n\t}\n\t\n\tif (rolltime)\n\t\t*rolltime = state->hi.rolltime;\n\tpool->cgminer_pool_stats.rolltime = state->hi.rolltime;\n\tpool->cgminer_pool_stats.hadrolltime = state->hi.hadrolltime;\n\tpool->cgminer_pool_stats.canroll = state->hi.canroll;\n\tpool->cgminer_pool_stats.hadexpire = state->hi.hadexpire;\n\n\tval = JSON_LOADS(state->all_data.buf, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\n\t\tif (opt_protocol)\n\t\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char*)state->all_data.buf);\n\n\t\tgoto err_out;\n\t}\n\n\tif (opt_protocol) {\n\t\tchar *s = json_dumps(val, JSON_INDENT(3));\n\n\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* JSON-RPC valid response returns a non-null 'result',\n\t * and a null 'error'.\n\t */\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val ||(err_val && !json_is_null(err_val))) {\n\t\tchar *s;\n\n\t\tif (err_val)\n\t\t\ts = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\ts = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC call failed: %s\", s);\n\n\t\tfree(s);\n\t\tjson_decref(val);\n\n\t\tgoto err_out;\n\t}\n\n\tif (state->hi.reason) {\n\t\tjson_object_set_new(val, \"reject-reason\", json_string(state->hi.reason));\n\t\tfree(state->hi.reason);\n\t\tstate->hi.reason = NULL;\n\t}\n\tsuccessful_connect = true;\n\tdatabuf_free(&state->all_data);\n\tcurl_slist_free_all(state->headers);\n\tcurl_easy_reset(curl);\n\tfree(state);\n\treturn val;\n\nerr_out:\n\tdatabuf_free(&state->all_data);\n\tcurl_slist_free_all(state->headers);\n\tcurl_easy_reset(curl);\n\tif (!successful_connect)\n\t\tapplog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\tfree(state);\n\treturn NULL;\n}\n\njson_t *json_rpc_call(CURL *curl, const char *url,\n\t\t      const char *userpass, const char *rpc_req,\n\t\t      bool probe, bool longpoll, int *rolltime,\n\t\t      struct pool *pool, bool share)\n{\n\tjson_rpc_call_async(curl, url, userpass, rpc_req, longpoll, pool, share, NULL);\n\tint rc = curl_easy_perform(curl);\n\treturn json_rpc_call_completed(curl, rc, probe, rolltime, NULL);\n}\n\nbool our_curl_supports_proxy_uris()\n{\n\tcurl_version_info_data *data = curl_version_info(CURLVERSION_NOW);\n\treturn data->age && data->version_num >= (( 7 <<16)|( 21 <<8)| 7);  // 7.21.7\n}\n\n// NOTE: This assumes reference URI is a root\nchar *absolute_uri(char *uri, const char *ref)\n{\n\tif (strstr(uri, \"://\"))\n\t\treturn strdup(uri);\n\n\tchar *copy_start, *abs;\n\tbool need_slash = false;\n\n\tcopy_start = (uri[0] == '/') ? &uri[1] : uri;\n\tif (ref[strlen(ref) - 1] != '/')\n\t\tneed_slash = true;\n\n\tabs = malloc(strlen(ref) + strlen(copy_start) + 2);\n\tif (!abs) {\n\t\tapplog(LOG_ERR, \"Malloc failure in absolute_uri\");\n\t\treturn NULL;\n\t}\n\n\tsprintf(abs, \"%s%s%s\", ref, need_slash ? \"/\" : \"\", copy_start);\n\n\treturn abs;\n}\n\nstatic const char _hexchars[0x10] = \"0123456789abcdef\";\n\nvoid bin2hex(char *out, const void *in, size_t len)\n{\n\tconst unsigned char *p = in;\n\twhile (len--)\n\t{\n\t\t(out++)[0] = _hexchars[p[0] >> 4];\n\t\t(out++)[0] = _hexchars[p[0] & 0xf];\n\t\t++p;\n\t}\n\tout[0] = '\\0';\n}\n\nstatic inline\nint _hex2bin_char(const char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn (c - 'a') + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn (c - 'A') + 10;\n\treturn -1;\n}\n\n/* Does the reverse of bin2hex but does not allocate any ram */\nbool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n{\n\tint n, o;\n\t\n\twhile (len--)\n\t{\n\t\tn = _hex2bin_char((hexstr++)[0]);\n\t\tif (unlikely(n == -1))\n\t\t{\nbadchar:\n\t\t\tif (!hexstr[-1])\n\t\t\t\tapplog(LOG_ERR, \"hex2bin: str truncated\");\n\t\t\telse\n\t\t\t\tapplog(LOG_ERR, \"hex2bin: invalid character 0x%02x\", (int)hexstr[-1]);\n\t\t\treturn false;\n\t\t}\n\t\to = _hex2bin_char((hexstr++)[0]);\n\t\tif (unlikely(o == -1))\n\t\t\tgoto badchar;\n\t\t(p++)[0] = (n << 4) | o;\n\t}\n\t\n\treturn likely(!hexstr[0]);\n}\n\nsize_t ucs2_to_utf8(char * const out, const uint16_t * const in, const size_t sz)\n{\n\tuint8_t *p = (void*)out;\n\tfor (int i = 0; i < sz; ++i)\n\t{\n\t\tconst uint16_t c = in[i];\n\t\tif (c < 0x80)\n\t\t\tp++[0] = c;\n\t\telse\n\t\t{\n\t\t\tif (c < 0x800)\n\t\t\t\tp++[0] = 0xc0 | (c >> 6);\n\t\t\telse\n\t\t\t{\n\t\t\t\tp++[0] = 0xe0 | (c >> 12);\n\t\t\t\tp++[0] = 0x80 | ((c >> 6) & 0x3f);\n\t\t\t}\n\t\t\tp++[0] = 0x80 | (c & 0x3f);\n\t\t}\n\t}\n\treturn p - (uint8_t*)(void*)out;\n}\n\nchar *ucs2_to_utf8_dup(uint16_t * const in, size_t sz)\n{\n\tchar * const out = malloc((sz * 4) + 1);\n\tsz = ucs2_to_utf8(out, in, sz);\n\tout[sz] = '\\0';\n\treturn out;\n}\n\n// Example output: 0000000000000000000000000000000000000000000000000000ffff00000000 (bdiff 1)\nvoid real_block_target(unsigned char *target, const unsigned char *data)\n{\n\tuint8_t targetshift;\n\n\tif (unlikely(data[72] < 3 || data[72] > 0x20))\n\t{\n\t\t// Invalid (out of bounds) target\n\t\tmemset(target, 0xff, 32);\n\t\treturn;\n\t}\n\n\ttargetshift = data[72] - 3;\n\tmemset(target, 0, targetshift);\n\ttarget[targetshift++] = data[75];\n\ttarget[targetshift++] = data[74];\n\ttarget[targetshift++] = data[73];\n\tmemset(&target[targetshift], 0, 0x20 - targetshift);\n}\n\nbool hash_target_check(const unsigned char *hash, const unsigned char *target)\n{\n\tconst uint32_t *h32 = (uint32_t*)&hash[0];\n\tconst uint32_t *t32 = (uint32_t*)&target[0];\n\tfor (int i = 7; i >= 0; --i) {\n\t\tuint32_t h32i = le32toh(h32[i]);\n\t\tuint32_t t32i = le32toh(t32[i]);\n\t\tif (h32i > t32i)\n\t\t\treturn false;\n\t\tif (h32i < t32i)\n\t\t\treturn true;\n\t}\n\treturn true;\n}\n\nbool hash_target_check_v(const unsigned char *hash, const unsigned char *target)\n{\n\tbool rc;\n\n\trc = hash_target_check(hash, target);\n\n\tif (opt_debug) {\n\t\tunsigned char hash_swap[32], target_swap[32];\n\t\tchar hash_str[65];\n\t\tchar target_str[65];\n\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\thash_swap[i] = hash[31-i];\n\t\t\ttarget_swap[i] = target[31-i];\n\t\t}\n\n\t\tbin2hex(hash_str, hash_swap, 32);\n\t\tbin2hex(target_str, target_swap, 32);\n\n\t\tapplog(LOG_DEBUG, \" Proof: %s\\nTarget: %s\\nTrgVal? %s\",\n\t\t\thash_str,\n\t\t\ttarget_str,\n\t\t\trc ? \"YES (hash <= target)\" :\n\t\t\t     \"no (false positive; hash > target)\");\n\t}\n\n\treturn rc;\n}\n\nstruct thread_q *tq_new(void)\n{\n\tstruct thread_q *tq;\n\n\ttq = calloc(1, sizeof(*tq));\n\tif (!tq)\n\t\treturn NULL;\n\n\tpthread_mutex_init(&tq->mutex, NULL);\n\tpthread_cond_init(&tq->cond, bfg_condattr);\n\n\treturn tq;\n}\n\nvoid tq_free(struct thread_q *tq)\n{\n\tstruct tq_ent *ent, *iter;\n\n\tif (!tq)\n\t\treturn;\n\n\tDL_FOREACH_SAFE(tq->q, ent, iter) {\n\t\tDL_DELETE(tq->q, ent);\n\t\tfree(ent);\n\t}\n\n\tpthread_cond_destroy(&tq->cond);\n\tpthread_mutex_destroy(&tq->mutex);\n\n\tmemset(tq, 0, sizeof(*tq));\t/* poison */\n\tfree(tq);\n}\n\nstatic void tq_freezethaw(struct thread_q *tq, bool frozen)\n{\n\tmutex_lock(&tq->mutex);\n\ttq->frozen = frozen;\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n}\n\nvoid tq_freeze(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, true);\n}\n\nvoid tq_thaw(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, false);\n}\n\nbool tq_push(struct thread_q *tq, void *data)\n{\n\tstruct tq_ent *ent;\n\tbool rc = true;\n\n\tent = calloc(1, sizeof(*ent));\n\tif (!ent)\n\t\treturn false;\n\n\tent->data = data;\n\n\tmutex_lock(&tq->mutex);\n\tif (!tq->frozen) {\n\t\tDL_APPEND(tq->q, ent);\n\t} else {\n\t\tfree(ent);\n\t\trc = false;\n\t}\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n\n\treturn rc;\n}\n\nvoid *tq_pop(struct thread_q * const tq)\n{\n\tstruct tq_ent *ent;\n\tvoid *rval = NULL;\n\tint rc;\n\n\tmutex_lock(&tq->mutex);\n\tif (tq->q)\n\t\tgoto pop;\n\n\trc = pthread_cond_wait(&tq->cond, &tq->mutex);\n\tif (rc)\n\t\tgoto out;\n\tif (!tq->q)\n\t\tgoto out;\npop:\n\tent = tq->q;\n\trval = ent->data;\n\n\tDL_DELETE(tq->q, ent);\n\tfree(ent);\nout:\n\tmutex_unlock(&tq->mutex);\n\n\treturn rval;\n}\n\nint thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg)\n{\n\tint rv = pthread_create(&thr->pth, attr, start, arg);\n\tif (likely(!rv))\n\t\tthr->has_pth = true;\n\treturn rv;\n}\n\nvoid thr_info_freeze(struct thr_info *thr)\n{\n\tstruct tq_ent *ent, *iter;\n\tstruct thread_q *tq;\n\n\tif (!thr)\n\t\treturn;\n\n\ttq = thr->q;\n\tif (!tq)\n\t\treturn;\n\n\tmutex_lock(&tq->mutex);\n\ttq->frozen = true;\n\tDL_FOREACH_SAFE(tq->q, ent, iter) {\n\t\tDL_DELETE(tq->q, ent);\n\t\tfree(ent);\n\t}\n\tmutex_unlock(&tq->mutex);\n}\n\nvoid thr_info_cancel(struct thr_info *thr)\n{\n\tif (!thr)\n\t\treturn;\n\n\tif (thr->has_pth) {\n\t\tpthread_cancel(thr->pth);\n\t\tthr->has_pth = false;\n\t}\n}\n\n#ifndef HAVE_PTHREAD_CANCEL\n\n// Bionic (Android) is intentionally missing pthread_cancel, so it is implemented using pthread_kill\n\nenum pthread_cancel_workaround_mode {\n\tPCWM_DEFAULT   = 0,\n\tPCWM_TERMINATE = 1,\n\tPCWM_ASYNC     = 2,\n\tPCWM_DISABLED  = 4,\n\tPCWM_CANCELLED = 8,\n};\n\nstatic pthread_key_t key_pcwm;\nstruct sigaction pcwm_orig_term_handler;\n\nstatic\nvoid do_pthread_cancel_exit(int flags)\n{\n\tif (!(flags & PCWM_ASYNC))\n\t\t// NOTE: Logging disables cancel while mutex held, so this is safe\n\t\tapplog(LOG_WARNING, \"pthread_cancel workaround: Cannot defer cancellation, terminating thread NOW\");\n\tpthread_exit(PTHREAD_CANCELED);\n}\n\nstatic\nvoid sighandler_pthread_cancel(int sig)\n{\n\tint flags = (int)pthread_getspecific(key_pcwm);\n\tif (flags & PCWM_TERMINATE)  // Main thread\n\t{\n\t\t// Restore original handler and call it\n\t\tif (sigaction(sig, &pcwm_orig_term_handler, NULL))\n\t\t\tquit(1, \"pthread_cancel workaround: Failed to restore original handler\");\n\t\traise(SIGTERM);\n\t\tquit(1, \"pthread_cancel workaround: Original handler returned\");\n\t}\n\tif (flags & PCWM_CANCELLED)  // Already pending cancel\n\t\treturn;\n\tif (flags & PCWM_DISABLED)\n\t{\n\t\tflags |= PCWM_CANCELLED;\n\t\tif (pthread_setspecific(key_pcwm, (void*)flags))\n\t\t\tquit(1, \"pthread_cancel workaround: pthread_setspecific failed (setting PCWM_CANCELLED)\");\n\t\treturn;\n\t}\n\tdo_pthread_cancel_exit(flags);\n}\n\nvoid pthread_testcancel(void)\n{\n\tint flags = (int)pthread_getspecific(key_pcwm);\n\tif (flags & PCWM_CANCELLED && !(flags & PCWM_DISABLED))\n\t\tdo_pthread_cancel_exit(flags);\n}\n\nint pthread_setcancelstate(int state, int *oldstate)\n{\n\tint flags = (int)pthread_getspecific(key_pcwm);\n\tif (oldstate)\n\t\t*oldstate = (flags & PCWM_DISABLED) ? PTHREAD_CANCEL_DISABLE : PTHREAD_CANCEL_ENABLE;\n\tif (state == PTHREAD_CANCEL_DISABLE)\n\t\tflags |= PCWM_DISABLED;\n\telse\n\t{\n\t\tif (flags & PCWM_CANCELLED)\n\t\t\tdo_pthread_cancel_exit(flags);\n\t\tflags &= ~PCWM_DISABLED;\n\t}\n\tif (pthread_setspecific(key_pcwm, (void*)flags))\n\t\treturn -1;\n\treturn 0;\n}\n\nint pthread_setcanceltype(int type, int *oldtype)\n{\n\tint flags = (int)pthread_getspecific(key_pcwm);\n\tif (oldtype)\n\t\t*oldtype = (flags & PCWM_ASYNC) ? PTHREAD_CANCEL_ASYNCHRONOUS : PTHREAD_CANCEL_DEFERRED;\n\tif (type == PTHREAD_CANCEL_ASYNCHRONOUS)\n\t\tflags |= PCWM_ASYNC;\n\telse\n\t\tflags &= ~PCWM_ASYNC;\n\tif (pthread_setspecific(key_pcwm, (void*)flags))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid setup_pthread_cancel_workaround()\n{\n\tif (pthread_key_create(&key_pcwm, NULL))\n\t\tquit(1, \"pthread_cancel workaround: pthread_key_create failed\");\n\tif (pthread_setspecific(key_pcwm, (void*)PCWM_TERMINATE))\n\t\tquit(1, \"pthread_cancel workaround: pthread_setspecific failed\");\n\tstruct sigaction new_sigact = {\n\t\t.sa_handler = sighandler_pthread_cancel,\n\t};\n\tif (sigaction(SIGTERM, &new_sigact, &pcwm_orig_term_handler))\n\t\tquit(1, \"pthread_cancel workaround: Failed to install SIGTERM handler\");\n}\n\n#endif\n\nstatic void _now_gettimeofday(struct timeval *);\nstatic void _cgsleep_us_r_nanosleep(cgtimer_t *, int64_t);\n\n#ifdef HAVE_POOR_GETTIMEOFDAY\nstatic struct timeval tv_timeofday_offset;\nstatic struct timeval _tv_timeofday_lastchecked;\nstatic pthread_mutex_t _tv_timeofday_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic\nvoid bfg_calibrate_timeofday(struct timeval *expected, char *buf)\n{\n\tstruct timeval actual, delta;\n\ttimeradd(expected, &tv_timeofday_offset, expected);\n\t_now_gettimeofday(&actual);\n\tif (expected->tv_sec >= actual.tv_sec - 1 && expected->tv_sec <= actual.tv_sec + 1)\n\t\t// Within reason - no change necessary\n\t\treturn;\n\t\n\ttimersub(&actual, expected, &delta);\n\ttimeradd(&tv_timeofday_offset, &delta, &tv_timeofday_offset);\n\tsprintf(buf, \"Recalibrating timeofday offset (delta %ld.%06lds)\", (long)delta.tv_sec, (long)delta.tv_usec);\n\t*expected = actual;\n}\n\nvoid bfg_gettimeofday(struct timeval *out)\n{\n\tchar buf[64] = \"\";\n\ttimer_set_now(out);\n\tmutex_lock(&_tv_timeofday_mutex);\n\tif (_tv_timeofday_lastchecked.tv_sec < out->tv_sec - 21)\n\t\tbfg_calibrate_timeofday(out, buf);\n\telse\n\t\ttimeradd(out, &tv_timeofday_offset, out);\n\tmutex_unlock(&_tv_timeofday_mutex);\n\tif (unlikely(buf[0]))\n\t\tapplog(LOG_WARNING, \"%s\", buf);\n}\n#endif\n\n#ifdef WIN32\nstatic LARGE_INTEGER _perffreq;\n\nstatic\nvoid _now_queryperformancecounter(struct timeval *tv)\n{\n\tLARGE_INTEGER now;\n\tif (unlikely(!QueryPerformanceCounter(&now)))\n\t\tquit(1, \"QueryPerformanceCounter failed\");\n\t\n\t*tv = (struct timeval){\n\t\t.tv_sec = now.QuadPart / _perffreq.QuadPart,\n\t\t.tv_usec = (now.QuadPart % _perffreq.QuadPart) * 1000000 / _perffreq.QuadPart,\n\t};\n}\n#endif\n\nstatic void bfg_init_time();\n\nstatic\nvoid _now_is_not_set(__maybe_unused struct timeval *tv)\n{\n\tbfg_init_time();\n\ttimer_set_now(tv);\n}\n\nvoid (*timer_set_now)(struct timeval *tv) = _now_is_not_set;\nvoid (*cgsleep_us_r)(cgtimer_t *, int64_t) = _cgsleep_us_r_nanosleep;\n\n#ifdef HAVE_CLOCK_GETTIME_MONOTONIC\nstatic clockid_t bfg_timer_clk;\n\nstatic\nvoid _now_clock_gettime(struct timeval *tv)\n{\n\tstruct timespec ts;\n\tif (unlikely(clock_gettime(bfg_timer_clk, &ts)))\n\t\tquit(1, \"clock_gettime failed\");\n\t\n\t*tv = (struct timeval){\n\t\t.tv_sec = ts.tv_sec,\n\t\t.tv_usec = ts.tv_nsec / 1000,\n\t};\n}\n\n#ifdef HAVE_CLOCK_NANOSLEEP\nstatic\nvoid _cgsleep_us_r_monotonic(cgtimer_t *tv_start, int64_t us)\n{\n\tstruct timeval tv_end[1];\n\tstruct timespec ts_end[1];\n\tint ret;\n\t\n\ttimer_set_delay(tv_end, tv_start, us);\n\ttimeval_to_spec(ts_end, tv_end);\n\tdo {\n\t\tret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);\n\t} while (ret == EINTR);\n}\n#endif\n\nstatic\nbool _bfg_try_clock_gettime(clockid_t clk)\n{\n\tstruct timespec ts;\n\tif (clock_gettime(clk, &ts))\n\t\treturn false;\n\t\n\tbfg_timer_clk = clk;\n\ttimer_set_now = _now_clock_gettime;\n\treturn true;\n}\n#endif\n\npthread_condattr_t *bfg_condattr_()\n{\n\treturn NULL;\n}\n\nstatic\nvoid bfg_init_time()\n{\n\tif (timer_set_now != _now_is_not_set)\n\t\treturn;\n\t\n#ifdef HAVE_CLOCK_GETTIME_MONOTONIC\n#ifdef HAVE_CLOCK_GETTIME_MONOTONIC_RAW\n\tif (_bfg_try_clock_gettime(CLOCK_MONOTONIC_RAW))\n\t\tapplog(LOG_DEBUG, \"Timers: Using clock_gettime(CLOCK_MONOTONIC_RAW)\");\n\telse\n#endif\n\tif (_bfg_try_clock_gettime(CLOCK_MONOTONIC))\n\t{\n\t\tapplog(LOG_DEBUG, \"Timers: Using clock_gettime(CLOCK_MONOTONIC)\");\n#ifdef HAVE_CLOCK_NANOSLEEP\n\t\tcgsleep_us_r = _cgsleep_us_r_monotonic;\n#endif\n\t}\n\telse\n#endif\n#ifdef WIN32\n\tif (QueryPerformanceFrequency(&_perffreq) && _perffreq.QuadPart)\n\t{\n\t\ttimer_set_now = _now_queryperformancecounter;\n\t\tapplog(LOG_DEBUG, \"Timers: Using QueryPerformanceCounter\");\n\t}\n\telse\n#endif\n\t{\n\t\ttimer_set_now = _now_gettimeofday;\n\t\tapplog(LOG_DEBUG, \"Timers: Using gettimeofday\");\n\t}\n\t\n#ifdef HAVE_POOR_GETTIMEOFDAY\n\tchar buf[64] = \"\";\n\tstruct timeval tv;\n\ttimer_set_now(&tv);\n\tbfg_calibrate_timeofday(&tv, buf);\n\tapplog(LOG_DEBUG, \"%s\", buf);\n#endif\n}\n\nvoid subtime(struct timeval *a, struct timeval *b)\n{\n\ttimersub(a, b, b);\n}\n\nvoid addtime(struct timeval *a, struct timeval *b)\n{\n\ttimeradd(a, b, b);\n}\n\nbool time_more(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, >);\n}\n\nbool time_less(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, <);\n}\n\nvoid copy_time(struct timeval *dest, const struct timeval *src)\n{\n\tmemcpy(dest, src, sizeof(struct timeval));\n}\n\nvoid timespec_to_val(struct timeval *val, const struct timespec *spec)\n{\n\tval->tv_sec = spec->tv_sec;\n\tval->tv_usec = spec->tv_nsec / 1000;\n}\n\nvoid timeval_to_spec(struct timespec *spec, const struct timeval *val)\n{\n\tspec->tv_sec = val->tv_sec;\n\tspec->tv_nsec = val->tv_usec * 1000;\n}\n\nvoid us_to_timeval(struct timeval *val, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tval->tv_sec = tvdiv.quot;\n\tval->tv_usec = tvdiv.rem;\n}\n\nvoid us_to_timespec(struct timespec *spec, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000;\n}\n\nvoid ms_to_timespec(struct timespec *spec, int64_t ms)\n{\n\tlldiv_t tvdiv = lldiv(ms, 1000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000000;\n}\n\nvoid timeraddspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec += b->tv_sec;\n\ta->tv_nsec += b->tv_nsec;\n\tif (a->tv_nsec >= 1000000000) {\n\t\ta->tv_nsec -= 1000000000;\n\t\ta->tv_sec++;\n\t}\n}\n\n#ifndef WIN32\nstatic\nvoid _now_gettimeofday(struct timeval *tv)\n{\n\tgettimeofday(tv, NULL);\n}\n#else\n/* Windows start time is since 1601 lol so convert it to unix epoch 1970. */\n#define EPOCHFILETIME (116444736000000000LL)\n\nvoid _now_gettimeofday(struct timeval *tv)\n{\n\tFILETIME ft;\n\tLARGE_INTEGER li;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tli.LowPart  = ft.dwLowDateTime;\n\tli.HighPart = ft.dwHighDateTime;\n\tli.QuadPart -= EPOCHFILETIME;\n\n\t/* SystemTime is in decimicroseconds so divide by an unusual number */\n\ttv->tv_sec  = li.QuadPart / 10000000;\n\ttv->tv_usec = li.QuadPart % 10000000;\n}\n#endif\n\nvoid cgsleep_ms_r(cgtimer_t *tv_start, int ms)\n{\n\tcgsleep_us_r(tv_start, ((int64_t)ms) * 1000);\n}\n\nstatic\nvoid _cgsleep_us_r_nanosleep(cgtimer_t *tv_start, int64_t us)\n{\n\tstruct timeval tv_timer[1], tv[1];\n\tstruct timespec ts[1];\n\t\n\ttimer_set_delay(tv_timer, tv_start, us);\n\twhile (true)\n\t{\n\t\ttimer_set_now(tv);\n\t\tif (!timercmp(tv_timer, tv, >))\n\t\t\treturn;\n\t\ttimersub(tv_timer, tv, tv);\n\t\ttimeval_to_spec(ts, tv);\n\t\tnanosleep(ts, NULL);\n\t}\n}\n\nvoid cgsleep_ms(int ms)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_ms_r(&ts_start, ms);\n}\n\nvoid cgsleep_us(int64_t us)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_us_r(&ts_start, us);\n}\n\n/* Returns the microseconds difference between end and start times as a double */\ndouble us_tdiff(struct timeval *end, struct timeval *start)\n{\n\treturn end->tv_sec * 1000000 + end->tv_usec - start->tv_sec * 1000000 - start->tv_usec;\n}\n\n/* Returns the seconds difference between end and start times as a double */\ndouble tdiff(struct timeval *end, struct timeval *start)\n{\n\treturn end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;\n}\n\n\nint double_find_precision(double f, const double base)\n{\n\tint rv = 0;\n\tfor ( ; floor(f) != f; ++rv)\n\t\tf *= base;\n\treturn rv;\n}\n\n\nint utf8_len(const uint8_t b)\n{\n\tif (!(b & 0x80))\n\t\treturn 1;\n\tif (!(b & 0x20))\n\t\treturn 2;\n\telse\n\tif (!(b & 0x10))\n\t\treturn 3;\n\telse\n\t\treturn 4;\n}\n\nint32_t utf8_decode(const void *b, int *out_len)\n{\n\tint32_t w;\n\tconst unsigned char *s = b;\n\t\n\t*out_len = utf8_len(s[0]);\n\t\n\tif (*out_len == 1)\n\t\t// ASCII\n\t\treturn s[0];\n\t\n#ifdef STRICT_UTF8\n\tif (unlikely(!(s[0] & 0x40)))\n\t\tgoto invalid;\n\tif (unlikely(s[0] & 0x38 == 0x38))\n\t\tgoto invalid;\n#endif\n\t\n\tw = s[0] & ((2 << (6 - *out_len)) - 1);\n\tfor (int i = 1; i < *out_len; ++i)\n\t{\n#ifdef STRICT_UTF8\n\t\tif (unlikely((s[i] & 0xc0) != 0x80))\n\t\t\tgoto invalid;\n#endif\n\t\tw = (w << 6) | (s[i] & 0x3f);\n\t}\n\t\n#if defined(STRICT_UTF8)\n\tif (unlikely(w > 0x10FFFF))\n\t\tgoto invalid;\n\t\n\t// FIXME: UTF-8 requires smallest possible encoding; check it\n#endif\n\t\n\treturn w;\n\n#ifdef STRICT_UTF8\ninvalid:\n\t*out_len = 1;\n\treturn REPLACEMENT_CHAR;\n#endif\n}\n\nsize_t utf8_strlen(const void * const b)\n{\n\tconst uint8_t *s = b;\n\tsize_t c = 0;\n\tint clen, i;\n\twhile (s[0])\n\t{\n\t\tclen = utf8_len(s[0]);\n\t\tfor (i = 0; i < clen; ++i)\n\t\t\tif (!s[i])\n\t\t\t\tclen = 1;\n\t\t++c;\n\t\ts += clen;\n\t}\n\treturn c;\n}\n\nstatic\nvoid _utf8_test(const char *s, const wchar_t expected, int expectedlen)\n{\n\tint len;\n\twchar_t r;\n\t\n\tif (expected != REPLACEMENT_CHAR)\n\t{\n\t\tlen = utf8_len(((uint8_t*)s)[0]);\n\t\tif (len != expectedlen)\n\t\t{\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"UTF-8 test U+%06lX (len %d) failed: got utf8_len=>%d\", (unsigned long)expected, expectedlen, len);\n\t\t}\n\t\tlen = utf8_strlen(s);\n\t\tif (len != (s[0] ? 1 : 0))\n\t\t{\n\t\t\t++unittest_failures;\n\t\t\tapplog(LOG_ERR, \"UTF-8 test U+%06lX (len %d) failed: got utf8_strlen=>%d\", (unsigned long)expected, expectedlen, len);\n\t\t}\n\t\tlen = -1;\n\t}\n\t\n\tr = utf8_decode(s, &len);\n\tif (unlikely(r != expected || expectedlen != len))\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_ERR, \"UTF-8 test U+%06lX (len %d) failed: got U+%06lX (len %d)\", (unsigned long)expected, expectedlen, (unsigned long)r, len);\n\t}\n}\n#define _test_intrange(s, ...)  _test_intrange(s, (int[]){ __VA_ARGS__ })\n\nvoid utf8_test()\n{\n\t_utf8_test(\"\", 0, 1);\n\t_utf8_test(\"\\1\", 1, 1);\n\t_utf8_test(\"\\x7f\", 0x7f, 1);\n#if WCHAR_MAX >= 0x80\n\t_utf8_test(\"\\xc2\\x80\", 0x80, 2);\n#if WCHAR_MAX >= 0xff\n\t_utf8_test(\"\\xc3\\xbf\", 0xff, 2);\n#if WCHAR_MAX >= 0x7ff\n\t_utf8_test(\"\\xdf\\xbf\", 0x7ff, 2);\n#if WCHAR_MAX >= 0x800\n\t_utf8_test(\"\\xe0\\xa0\\x80\", 0x800, 3);\n#if WCHAR_MAX >= 0xffff\n\t_utf8_test(\"\\xef\\xbf\\xbf\", 0xffff, 3);\n#if WCHAR_MAX >= 0x10000\n\t_utf8_test(\"\\xf0\\x90\\x80\\x80\", 0x10000, 4);\n#if WCHAR_MAX >= 0x10ffff\n\t_utf8_test(\"\\xf4\\x8f\\xbf\\xbf\", 0x10ffff, 4);\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#ifdef STRICT_UTF8\n\t_utf8_test(\"\\x80\", REPLACEMENT_CHAR, 1);\n\t_utf8_test(\"\\xbf\", REPLACEMENT_CHAR, 1);\n\t_utf8_test(\"\\xfe\", REPLACEMENT_CHAR, 1);\n\t_utf8_test(\"\\xff\", REPLACEMENT_CHAR, 1);\n#endif\n}\n\n\nbool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\t\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\tfree(*sockaddr_port);\n\t*sockaddr_port = strdup(port);\n\tfree(*sockaddr_url);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n\nenum send_ret {\n\tSEND_OK,\n\tSEND_SELECTFAIL,\n\tSEND_SENDFAIL,\n\tSEND_INACTIVE\n};\n\n/* Send a single command across a socket, appending \\n to it. This should all\n * be done under stratum lock except when first establishing the socket */\nstatic enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\n\tstrcat(s, \"\\n\");\n\tlen++;\n\n\twhile (len > 0 ) {\n\t\tstruct timeval timeout = {1, 0};\n\t\tsize_t sent = 0;\n\t\tCURLcode rc;\n\t\tfd_set wd;\nretry:\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(sock, &wd);\n\t\tif (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {\n\t\t\tif (interrupted())\n\t\t\t\tgoto retry;\n\t\t\treturn SEND_SELECTFAIL;\n\t\t}\n\t\trc = curl_easy_send(pool->stratum_curl, s + ssent, len, &sent);\n\t\tif (rc != CURLE_OK)\n\t\t{\n\t\t\tif (rc != CURLE_AGAIN)\n\t\t\t\treturn SEND_SENDFAIL;\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\n\n\tpool->cgminer_pool_stats.times_sent++;\n\tpool->cgminer_pool_stats.bytes_sent += ssent;\n\ttotal_bytes_sent += ssent;\n\tpool->cgminer_pool_stats.net_bytes_sent += ssent;\n\treturn SEND_OK;\n}\n\nbool _stratum_send(struct pool *pool, char *s, ssize_t len, bool force)\n{\n\tenum send_ret ret = SEND_INACTIVE;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"Pool %u: SEND: %s\", pool->pool_no, s);\n\n\tmutex_lock(&pool->stratum_lock);\n\tif (pool->stratum_active || force)\n\t\tret = __stratum_send(pool, s, len);\n\tmutex_unlock(&pool->stratum_lock);\n\n\t/* This is to avoid doing applog under stratum_lock */\n\tswitch (ret) {\n\t\tdefault:\n\t\tcase SEND_OK:\n\t\t\tbreak;\n\t\tcase SEND_SELECTFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Write select failed on pool %d sock\", pool->pool_no);\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_SENDFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Failed to send in stratum_send\");\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_INACTIVE:\n\t\t\tapplog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");\n\t\t\tbreak;\n\t}\n\treturn (ret == SEND_OK);\n}\n\nstatic bool socket_full(struct pool *pool, int wait)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tstruct timeval timeout;\n\tfd_set rd;\n\n\tif (sock == INVSOCK)\n\t\treturn true;\n\t\n\tif (unlikely(wait < 0))\n\t\twait = 0;\n\tFD_ZERO(&rd);\n\tFD_SET(sock, &rd);\n\ttimeout.tv_usec = 0;\n\ttimeout.tv_sec = wait;\n\tif (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)\n\t\treturn true;\n\treturn false;\n}\n\n/* Check to see if Santa's been good to you */\nbool sock_full(struct pool *pool)\n{\n\tif (strlen(pool->sockbuf))\n\t\treturn true;\n\n\treturn (socket_full(pool, 0));\n}\n\nstatic void clear_sockbuf(struct pool *pool)\n{\n\tstrcpy(pool->sockbuf, \"\");\n}\n\nstatic void clear_sock(struct pool *pool)\n{\n\tsize_t n = 0;\n\n\tmutex_lock(&pool->stratum_lock);\n\tdo {\n\t\tn = 0;\n\t\tif (pool->stratum_curl)\n\t\t\tcurl_easy_recv(pool->stratum_curl, pool->sockbuf, RECVSIZE, &n);\n\t} while (n > 0);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tclear_sockbuf(pool);\n}\n\n/* Make sure the pool sockbuf is large enough to cope with any coinbase size\n * by reallocing it to a large enough size rounded up to a multiple of RBUFSIZE\n * and zeroing the new memory */\nstatic void recalloc_sock(struct pool *pool, size_t len)\n{\n\tsize_t old, new;\n\n\told = strlen(pool->sockbuf);\n\tnew = old + len + 1;\n\tif (new < pool->sockbuf_size)\n\t\treturn;\n\tnew = new + (RBUFSIZE - (new % RBUFSIZE));\n\t// Avoid potentially recursive locking\n\t// applog(LOG_DEBUG, \"Recallocing pool sockbuf to %lu\", (unsigned long)new);\n\tpool->sockbuf = realloc(pool->sockbuf, new);\n\tif (!pool->sockbuf)\n\t\tquithere(1, \"Failed to realloc pool sockbuf\");\n\tmemset(pool->sockbuf + old, 0, new - old);\n\tpool->sockbuf_size = new;\n}\n\n/* Peeks at a socket to find the first end of line and then reads just that\n * from the socket and returns that as a malloced char */\nchar *recv_line(struct pool *pool)\n{\n\tchar *tok, *sret = NULL;\n\tssize_t len, buflen;\n\tint waited = 0;\n\n\tif (!strstr(pool->sockbuf, \"\\n\")) {\n\t\tstruct timeval rstart, now;\n\n\t\tcgtime(&rstart);\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdo {\n\t\t\tchar s[RBUFSIZE];\n\t\t\tsize_t slen;\n\t\t\tsize_t n = 0;\n\t\t\tCURLcode rc;\n\n\t\t\tmemset(s, 0, RBUFSIZE);\n\t\t\trc = curl_easy_recv(pool->stratum_curl, s, RECVSIZE, &n);\n\t\t\tif (rc == CURLE_OK && !n)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Socket closed waiting in recv_line\");\n\t\t\t\tsuspend_stratum(pool);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcgtime(&now);\n\t\t\twaited = tdiff(&now, &rstart);\n\t\t\tif (rc != CURLE_OK)\n\t\t\t{\n\t\t\t\tif (rc != CURLE_AGAIN || !socket_full(pool, DEFAULT_SOCKWAIT - waited))\n\t\t\t\t{\n\t\t\t\t\tapplog(LOG_DEBUG, \"Failed to recv sock in recv_line\");\n\t\t\t\t\tsuspend_stratum(pool);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslen = strlen(s);\n\t\t\t\trecalloc_sock(pool, slen);\n\t\t\t\tstrcat(pool->sockbuf, s);\n\t\t\t}\n\t\t} while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));\n\t}\n\n\tbuflen = strlen(pool->sockbuf);\n\ttok = strtok(pool->sockbuf, \"\\n\");\n\tif (!tok) {\n\t\tapplog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");\n\t\tgoto out;\n\t}\n\tsret = strdup(tok);\n\tlen = strlen(sret);\n\n\t/* Copy what's left in the buffer after the \\n, including the\n\t * terminating \\0 */\n\tif (buflen > len + 1)\n\t\tmemmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);\n\telse\n\t\tstrcpy(pool->sockbuf, \"\");\n\n\tpool->cgminer_pool_stats.times_received++;\n\tpool->cgminer_pool_stats.bytes_received += len;\n\ttotal_bytes_rcvd += len;\n\tpool->cgminer_pool_stats.net_bytes_received += len;\n\nout:\n\tif (!sret)\n\t\tclear_sock(pool);\n\telse if (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"Pool %u: RECV: %s\", pool->pool_no, sret);\n\treturn sret;\n}\n\n/* Dumps any JSON value as a string. Just like jansson 2.1's JSON_ENCODE_ANY\n * flag, but this is compatible with 2.0. */\nchar *json_dumps_ANY(json_t *json, size_t flags)\n{\n\tswitch (json_typeof(json))\n\t{\n\t\tcase JSON_ARRAY:\n\t\tcase JSON_OBJECT:\n\t\t\treturn json_dumps(json, flags);\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tchar *rv;\n#ifdef JSON_ENCODE_ANY\n\trv = json_dumps(json, JSON_ENCODE_ANY | flags);\n\tif (rv)\n\t\treturn rv;\n#endif\n\tjson_t *tmp = json_array();\n\tchar *s;\n\tint i;\n\tsize_t len;\n\t\n\tif (!tmp)\n\t\tquithere(1, \"Failed to allocate json array\");\n\tif (json_array_append(tmp, json))\n\t\tquithere(1, \"Failed to append temporary array\");\n\ts = json_dumps(tmp, flags);\n\tif (!s)\n\t\treturn NULL;\n\tfor (i = 0; s[i] != '['; ++i)\n\t\tif (unlikely(!(s[i] && isCspace(s[i]))))\n\t\t\tquithere(1, \"Failed to find opening bracket in array dump\");\n\tlen = strlen(&s[++i]) - 1;\n\tif (unlikely(s[i+len] != ']'))\n\t\tquithere(1, \"Failed to find closing bracket in array dump\");\n\trv = malloc(len + 1);\n\tmemcpy(rv, &s[i], len);\n\trv[len] = '\\0';\n\tfree(s);\n\tjson_decref(tmp);\n\treturn rv;\n}\n\n/* Extracts a string value from a json array with error checking. To be used\n * when the value of the string returned is only examined and not to be stored.\n * See json_array_string below */\nconst char *__json_array_string(json_t *val, unsigned int entry)\n{\n\tjson_t *arr_entry;\n\n\tif (json_is_null(val))\n\t\treturn NULL;\n\tif (!json_is_array(val))\n\t\treturn NULL;\n\tif (entry > json_array_size(val))\n\t\treturn NULL;\n\tarr_entry = json_array_get(val, entry);\n\tif (!json_is_string(arr_entry))\n\t\treturn NULL;\n\n\treturn json_string_value(arr_entry);\n}\n\n/* Creates a freshly malloced dup of __json_array_string */\nstatic char *json_array_string(json_t *val, unsigned int entry)\n{\n\tconst char *buf = __json_array_string(val, entry);\n\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}\n\nvoid *my_memrchr(const void * const datap, const int c, const size_t sz)\n{\n\tconst uint8_t *data = datap;\n\tconst uint8_t *p = &data[sz];\n\twhile (p > data)\n\t\tif (*--p == c)\n\t\t\treturn (void *)p;\n\treturn NULL;\n}\n\nbool isCalpha(const int c)\n{\n\tif (c >= 'A' && c <= 'Z')\n\t\treturn true;\n\tif (c >= 'a' && c <= 'z')\n\t\treturn true;\n\treturn false;\n}\n\nbool match_strtok(const char * const optlist, const char * const delim, const char * const needle)\n{\n\tconst size_t optlist_sz = strlen(optlist) + 1;\n\tchar opts[optlist_sz];\n\tmemcpy(opts, optlist, optlist_sz);\n\tfor (char *el, *nextptr, *s = opts; (el = strtok_r(s, delim, &nextptr)); s = NULL)\n\t\tif (!strcasecmp(el, needle))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic\nbool _appdata_file_call(const char * const appname, const char * const filename, const appdata_file_callback_t cb, void * const userp, const char * const path)\n{\n\tif (!(path && path[0]))\n\t\treturn false;\n\tchar filepath[PATH_MAX];\n\tsnprintf(filepath, sizeof(filepath), \"%s/%s/%s\", path, appname, filename);\n\tif (!access(filepath, R_OK))\n\t\treturn cb(filepath, userp);\n\treturn false;\n}\n\n#define _APPDATA_FILE_CALL(appname, path)  do{  \\\n\tif (_appdata_file_call(appname, filename, cb, userp, path))  \\\n\t\treturn true;  \\\n}while(0)\n\nbool appdata_file_call(const char *appname, const char * const filename, const appdata_file_callback_t cb, void * const userp)\n{\n\tsize_t appname_len = strlen(appname);\n\tchar appname_lcd[appname_len + 2];\n\tappname_lcd[0] = '.';\n\tchar *appname_lc = &appname_lcd[1];\n\tfor (size_t i = 0; i < appname_len; ++i)\n\t\tappname_lc[i] = tolower(appname[i]);\n\tappname_lc[appname_len] = '\\0';\n\t\n\tconst char * const HOME = getenv(\"HOME\");\n\t\n\t_APPDATA_FILE_CALL(\".\", \".\");\n\t\n#ifdef WIN32\n\t_APPDATA_FILE_CALL(appname, getenv(\"APPDATA\"));\n#elif defined(__APPLE__)\n\tif (HOME && HOME[0])\n\t{\n\t\tchar AppSupport[strlen(HOME) + 28 + 1];\n\t\tsnprintf(AppSupport, sizeof(AppSupport), \"%s/Library/Application Support\", HOME);\n\t\t_APPDATA_FILE_CALL(appname, AppSupport);\n\t}\n#endif\n\t\n\t_APPDATA_FILE_CALL(appname_lcd, HOME);\n\t\n#ifdef WIN32\n\t_APPDATA_FILE_CALL(appname, getenv(\"ALLUSERSAPPDATA\"));\n#elif defined(__APPLE__)\n\t_APPDATA_FILE_CALL(appname, \"/Library/Application Support\");\n#endif\n#ifndef WIN32\n\t_APPDATA_FILE_CALL(appname_lc, \"/etc\");\n#endif\n\t\n\treturn false;\n}\n\nstatic\nbool _appdata_file_find_first(const char * const filepath, void *userp)\n{\n\tchar **rv = userp;\n\t*rv = strdup(filepath);\n\treturn true;\n}\n\nchar *appdata_file_find_first(const char * const appname, const char * const filename)\n{\n\tchar *rv;\n\tif (appdata_file_call(appname, filename, _appdata_file_find_first, &rv))\n\t\treturn rv;\n\treturn NULL;\n}\n\nconst char *get_registered_domain(size_t * const out_domainlen, const char * const fqdn, const size_t fqdnlen)\n{\n\tconst char *s;\n\tint dots = 0;\n\t\n\tfor (s = &fqdn[fqdnlen-1]; s >= fqdn; --s)\n\t{\n\t\tif (s[0] == '.')\n\t\t{\n\t\t\t*out_domainlen = fqdnlen - (&s[1] - fqdn);\n\t\t\tif (++dots >= 2 && *out_domainlen > 5)\n\t\t\t\treturn &s[1];\n\t\t}\n\t\telse\n\t\tif (!(dots || isCalpha(s[0])))\n\t\t{\n\t\t\t*out_domainlen = fqdnlen;\n\t\t\treturn fqdn;\n\t\t}\n\t}\n\t\n\t*out_domainlen = fqdnlen;\n\treturn fqdn;\n}\n\nconst char *extract_domain(size_t * const out_domainlen, const char * const uri, const size_t urilen)\n{\n\tconst char *p = uri, *b, *q, *s;\n\tbool alldigit;\n\t\n\tp = memchr(&p[1], '/', urilen - (&p[1] - uri));\n\tif (p)\n\t{\n\t\tif (p[-1] == ':')\n\t\t{\n\t\t\t// part of the URI scheme, ignore it\n\t\t\twhile (p[0] == '/')\n\t\t\t\t++p;\n\t\t\tp = memchr(p, '/', urilen - (p - uri));\n\t\t}\n\t}\n\tif (!p)\n\t{\n\t\tp = memchr(uri, '?', urilen) ?:\n\t\t    memchr(uri, '#', urilen) ?:\n\t\t    &uri[urilen];\n\t}\n\t\n\ts = p;\n\tq = my_memrchr(uri, ':', p - uri);\n\tif (q)\n\t{\n\t\talldigit = true;\n\t\tfor (q = b = &q[1]; q < p; ++q)\n\t\t\tif (!isdigit(q[0]))\n\t\t\t{\n\t\t\t\talldigit = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (alldigit && p != b)\n\t\t\tp = &b[-1];\n\t}\n\t\n\talldigit = true;\n\tfor (b = uri; b < p; ++b)\n\t{\n\t\tif (b[0] == ':')\n\t\t\tbreak;\n\t\tif (alldigit && !isdigit(b[0]))\n\t\t\talldigit = false;\n\t}\n\tif ((b < p && b[0] == ':') && (b == uri || !alldigit))\n\t\tb = &b[1];\n\telse\n\t\tb = uri;\n\twhile (b <= p && b[0] == '/')\n\t\t++b;\n\tif (p - b > 1 && b[0] == '[' && p[-1] == ']')\n\t{\n\t\t++b;\n\t\t--p;\n\t}\n\telse\n\tif (memchr(b, ':', p - b))\n\t\tp = s;\n\tif (p > b && p[-1] == '.')\n\t\t--p;\n\t\n\t*out_domainlen = p - b;\n\treturn b;\n}\n\nbool match_domains(const char * const a, const size_t alen, const char * const b, const size_t blen)\n{\n\tsize_t a_domainlen, b_domainlen;\n\tconst char *a_domain, *b_domain;\n\ta_domain = extract_domain(&a_domainlen, a, alen);\n\ta_domain = get_registered_domain(&a_domainlen, a_domain, a_domainlen);\n\tb_domain = extract_domain(&b_domainlen, b, blen);\n\tb_domain = get_registered_domain(&b_domainlen, b_domain, b_domainlen);\n\tif (a_domainlen != b_domainlen)\n\t\treturn false;\n\treturn !strncasecmp(a_domain, b_domain, a_domainlen);\n}\n\nstatic\nvoid _test_extract_domain(const char * const expect, const char * const uri)\n{\n\tsize_t sz;\n\tconst char * const d = extract_domain(&sz, uri, strlen(uri));\n\tif (sz != strlen(expect) || strncasecmp(d, expect, sz))\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_WARNING, \"extract_domain \\\"%s\\\" test failed; got \\\"%.*s\\\" instead of \\\"%s\\\"\",\n\t\t       uri, (int)sz, d, expect);\n\t}\n}\n\nstatic\nvoid _test_get_regd_domain(const char * const expect, const char * const fqdn)\n{\n\tsize_t sz;\n\tconst char * const d = get_registered_domain(&sz, fqdn, strlen(fqdn));\n\tif (d == NULL || sz != strlen(expect) || strncasecmp(d, expect, sz))\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_WARNING, \"get_registered_domain \\\"%s\\\" test failed; got \\\"%.*s\\\" instead of \\\"%s\\\"\",\n\t\t       fqdn, (int)sz, d, expect);\n\t}\n}\n\nvoid test_domain_funcs()\n{\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st:3334\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st:3334/abc/abc/\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st/abc/abc/\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http:s.m.eligius.st\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"stratum+tcp:s.m.eligius.st\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"stratum+tcp:s.m.eligius.st:3334\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"stratum+tcp://s.m.eligius.st:3334\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"stratum+tcp://s.m.eligius.st:3334///\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"stratum+tcp://s.m.eligius.st.:3334///\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st:3334\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st:3334///\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st:3334#foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st:3334?foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st#foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"http://s.m.eligius.st?foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st#foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st?foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st:3334#foo\");\n\t_test_extract_domain(\"s.m.eligius.st\", \"s.m.eligius.st:3334?foo\");\n\t_test_extract_domain(\"foohost\", \"foohost:3334\");\n\t_test_extract_domain(\"foohost\", \"foohost:3334///\");\n\t_test_extract_domain(\"foohost\", \"foohost:3334/abc.com//\");\n\t_test_extract_domain(\"\", \"foohost:\");\n\t_test_extract_domain(\"3334\", \"foohost://3334/abc.com//\");\n\t_test_extract_domain(\"192.0.2.0\", \"foohost:192.0.2.0\");\n\t_test_extract_domain(\"192.0.2.0\", \"192.0.2.0:3334\");\n\t_test_extract_domain(\"192.0.2.0\", \"192.0.2.0:3334///\");\n\t_test_extract_domain(\"2001:db8::1\", \"2001:db8::1\");\n\t_test_extract_domain(\"2001:db8::1\", \"http://[2001:db8::1]\");\n\t_test_extract_domain(\"2001:db8::1\", \"http:[2001:db8::1]\");\n\t_test_extract_domain(\"2001:db8::1\", \"http://[2001:db8::1]:42\");\n\t_test_extract_domain(\"2001:db8::1\", \"http://[2001:db8::1]:42/abc//def/ghi\");\n\t_test_extract_domain(\"2001:db8::cafe\", \"http://[2001:db8::cafe]\");\n\t_test_extract_domain(\"2001:db8::cafe\", \"http:[2001:db8::cafe]\");\n\t_test_extract_domain(\"2001:db8::cafe\", \"http://[2001:db8::cafe]:42\");\n\t_test_extract_domain(\"2001:db8::cafe\", \"http://[2001:db8::cafe]:42/abc//def/ghi\");\n\t_test_get_regd_domain(\"eligius.st\", \"s.m.eligius.st\");\n\t_test_get_regd_domain(\"eligius.st\", \"eligius.st\");\n\t_test_get_regd_domain(\"foohost.co.uk\", \"myserver.foohost.co.uk\");\n\t_test_get_regd_domain(\"foohost\", \"foohost\");\n\t_test_get_regd_domain(\"192.0.2.0\", \"192.0.2.0\");\n\t_test_get_regd_domain(\"2001:db8::1\", \"2001:db8::1\");\n}\n\nstruct bfg_strtobool_keyword {\n\tbool val;\n\tconst char *keyword;\n};\n\nbool bfg_strtobool(const char * const s, char ** const endptr, __maybe_unused const int opts)\n{\n\tstruct bfg_strtobool_keyword keywords[] = {\n\t\t{false, \"disable\"},\n\t\t{false, \"false\"},\n\t\t{false, \"never\"},\n\t\t{false, \"none\"},\n\t\t{false, \"off\"},\n\t\t{false, \"no\"},\n\t\t{false, \"0\"},\n\t\t\n\t\t{true , \"enable\"},\n\t\t{true , \"always\"},\n\t\t{true , \"force\"},\n\t\t{true , \"true\"},\n\t\t{true , \"yes\"},\n\t\t{true , \"on\"},\n\t};\n\t\n\tconst int total_keywords = sizeof(keywords) / sizeof(*keywords);\n\tfor (int i = 0; i < total_keywords; ++i)\n\t{\n\t\tconst size_t kwlen = strlen(keywords[i].keyword);\n\t\tif (!strncasecmp(keywords[i].keyword, s, kwlen))\n\t\t{\n\t\t\tif (endptr)\n\t\t\t\t*endptr = (char*)&s[kwlen];\n\t\t\treturn keywords[i].val;\n\t\t}\n\t}\n\t\n\tchar *lend;\n\tstrtol(s, &lend, 0);\n\tif (lend > s)\n\t{\n\t\tif (endptr)\n\t\t\t*endptr = lend;\n\t\t// Any number other than \"0\" is intentionally considered true, including 0x0\n\t\treturn true;\n\t}\n\t\n\t*endptr = (char*)s;\n\treturn false;\n}\n\n#define URI_FIND_PARAM_FOUND ((const char *)uri_find_param)\n\nconst char *uri_find_param(const char * const uri, const char * const param, bool * const invert_p)\n{\n\tconst char *start = strchr(uri, '#');\n\tif (invert_p)\n\t\t*invert_p = false;\n\tif (!start)\n\t\treturn NULL;\n\tconst char *p = start;\n\t++start;\nnextmatch:\n\tp = strstr(&p[1], param);\n\tif (!p)\n\t\treturn NULL;\n\tconst char *q = &p[strlen(param)];\n\tif (isCalpha(q[0]))\n\t\tgoto nextmatch;\n\tif (invert_p && p - start >= 2 && (!strncasecmp(&p[-2], \"no\", 2)) && !isCalpha(p[-3]))\n\t\t*invert_p = true;\n\telse\n\tif (isCalpha(p[-1]))\n\t\tgoto nextmatch;\n\tif (q[0] == '=')\n\t\treturn &q[1];\n\treturn URI_FIND_PARAM_FOUND;\n}\n\nenum bfg_tristate uri_get_param_bool2(const char * const uri, const char * const param)\n{\n\tbool invert, foundval = true;\n\tconst char *q = uri_find_param(uri, param, &invert);\n\tif (!q)\n\t\treturn BTS_UNKNOWN;\n\telse\n\tif (q != URI_FIND_PARAM_FOUND)\n\t{\n\t\tchar *end;\n\t\tbool v = bfg_strtobool(q, &end, 0);\n\t\tif (end > q && !isCalpha(end[0]))\n\t\t\tfoundval = v;\n\t}\n\tif (invert)\n\t\tfoundval = !foundval;\n\treturn foundval;\n}\n\nbool uri_get_param_bool(const char * const uri, const char * const param, const bool defval)\n{\n\tconst enum bfg_tristate rv = uri_get_param_bool2(uri, param);\n\tif (rv == BTS_UNKNOWN)\n\t\treturn defval;\n\treturn rv;\n}\n\nstatic\nvoid _test_uri_find_param(const char * const uri, const char * const param, const int expect_offset, const int expect_invert)\n{\n\tbool invert;\n\tconst char *actual = uri_find_param(uri, param, (expect_invert >= 0) ? &invert : NULL);\n\tint actual_offset;\n\tif (actual == URI_FIND_PARAM_FOUND)\n\t\tactual_offset = -1;\n\telse\n\tif (!actual)\n\t\tactual_offset = -2;\n\telse\n\t\tactual_offset = actual - uri;\n\tint actual_invert = (expect_invert >= 0) ? (invert ? 1 : 0) : -1;\n\tif (actual_offset != expect_offset || expect_invert != actual_invert)\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_WARNING, \"%s(\\\"%s\\\", \\\"%s\\\", %s) test failed (offset: expect=%d actual=%d; invert: expect=%d actual=%d)\",\n\t\t       \"uri_find_param\", uri, param, (expect_invert >= 0) ? \"(invert)\" : \"NULL\",\n\t\t       expect_offset, actual_offset,\n\t\t       expect_invert, actual_invert);\n\t}\n}\n\nstatic\nvoid _test_uri_get_param(const char * const uri, const char * const param, const bool defval, const bool expect)\n{\n\tconst bool actual = uri_get_param_bool(uri, param, defval);\n\tif (actual != expect)\n\t{\n\t\t++unittest_failures;\n\t\tapplog(LOG_WARNING, \"%s(\\\"%s\\\", \\\"%s\\\", %s) test failed\",\n\t\t       \"uri_get_param_bool\", uri, param, defval ? \"true\" : \"false\");\n\t}\n}\n\nvoid test_uri_get_param()\n{\n\t_test_uri_find_param(\"stratum+tcp://footest/#redirect\", \"redirect\", -1, -1);\n\t_test_uri_find_param(\"stratum+tcp://footest/#redirectme\", \"redirect\", -2, -1);\n\t_test_uri_find_param(\"stratum+tcp://footest/#noredirect\", \"redirect\", -2, -1);\n\t_test_uri_find_param(\"stratum+tcp://footest/#noredirect\", \"redirect\", -1, 1);\n\t_test_uri_find_param(\"stratum+tcp://footest/#redirect\", \"redirect\", -1, 0);\n\t_test_uri_find_param(\"stratum+tcp://footest/#redirect=\", \"redirect\", 32, -1);\n\t_test_uri_find_param(\"stratum+tcp://footest/#noredirect=\", \"redirect\", 34, 1);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect\", \"redirect\", false, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirectme\", \"redirect\", false, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#noredirect\", \"redirect\", false, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=0\", \"redirect\", false, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=1\", \"redirect\", false, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect\", \"redirect\", true, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirectme\", \"redirect\", true, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#noredirect\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=0\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=1\", \"redirect\", true, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=0,foo=1\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=1,foo=0\", \"redirect\", false, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#foo=1,noredirect=0,foo=1\", \"redirect\", false, true);\n\t_test_uri_get_param(\"stratum+tcp://footest/#bar=0,noredirect=1,foo=0\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=false\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=no\", \"redirect\", true, false);\n\t_test_uri_get_param(\"stratum+tcp://footest/#redirect=yes\", \"redirect\", false, true);\n}\n\nvoid stratum_probe_transparency(struct pool *pool)\n{\n\t// Request transaction data to discourage pools from doing anything shady\n\tchar s[1024];\n\tint sLen;\n\tsLen = sprintf(s, \"{\\\"params\\\": [\\\"%s\\\"], \\\"id\\\": \\\"txlist%s\\\", \\\"method\\\": \\\"mining.get_transactions\\\"}\",\n\t        pool->swork.job_id,\n\t        pool->swork.job_id);\n\tstratum_send(pool, s, sLen);\n\tif ((!pool->swork.opaque) && !timer_isset(&pool->swork.tv_transparency))\n\t\ttimer_set_delay_from_now(&pool->swork.tv_transparency, 21093750L);\n\tpool->swork.transparency_probed = true;\n}\n\nsize_t script_to_address(char *out, size_t outsz, const uint8_t *script, size_t scriptsz, bool testnet)\n{\n\tchar addr[35];\n\tsize_t size = sizeof(addr);\n\tbool bok = false;\n\t\n\tif (scriptsz == 25 && script[0] == 0x76 && script[1] == 0xa9 && script[2] == 0x14 && script[23] == 0x88 && script[24] == 0xac)\n\t\tbok = b58check_enc(addr, &size, testnet ? 0x6f : 0x00, &script[3], 20);\n\telse if (scriptsz == 23 && script[0] == 0xa9 && script[1] == 0x14 && script[22] == 0x87)\n\t\tbok = b58check_enc(addr, &size, testnet ? 0xc4 : 0x05, &script[2], 20);\n\tif (!bok)\n\t\treturn 0;\n\tif (outsz >= size)\n\t\tstrcpy(out, addr);\n\treturn size;\n}\n\nsize_t varint_decode(const uint8_t *p, size_t size, uint64_t *n)\n{\n\tif (size > 8 && p[0] == 0xff)\n\t{\n\t\t*n = upk_u64le(p, 1);\n\t\treturn 9;\n\t}\n\tif (size > 4 && p[0] == 0xfe)\n\t{\n\t\t*n = upk_u32le(p, 1);\n\t\treturn 5;\n\t}\n\tif (size > 2 && p[0] == 0xfd)\n\t{\n\t\t*n = upk_u16le(p, 1);\n\t\treturn 3;\n\t}\n\tif (size > 0 && p[0] <= 0xfc)\n\t{\n\t\t*n = p[0];\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Caller ensure cb_param is an valid pointer */\nbool check_coinbase(const uint8_t *coinbase, size_t cbsize, const struct coinbase_param *cb_param)\n{\n\tint i;\n\tsize_t pos;\n\tuint64_t len, total, target, amount, curr_pk_script_len;\n\tbool found_target = false;\n\t\n\tif (cbsize < 62)\n\t\t/* Smallest possible length */\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: invalid length -- %lu\", (unsigned long)cbsize);\n\tpos = 4; /* Skip the version */\n\t\n\tif (coinbase[pos] != 1)\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: multiple inputs in coinbase: 0x%02x\", coinbase[pos]);\n\tpos += 1 /* varint length */ + 32 /* prevhash */ + 4 /* 0xffffffff */;\n\t\n\tif (coinbase[pos] < 2 || coinbase[pos] > 100)\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: invalid input script sig length: 0x%02x\", coinbase[pos]);\n\tpos += 1 /* varint length */ + coinbase[pos] + 4 /* 0xffffffff */;\n\t\n\tif (cbsize <= pos)\nincomplete_cb:\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: incomplete coinbase for payout check\");\n\t\n\ttotal = target = 0;\n\t\n\ti = varint_decode(coinbase + pos, cbsize - pos, &len);\n\tif (!i)\n\t\tgoto incomplete_cb;\n\tpos += i;\n\t\n\twhile (len-- > 0)\n\t{\n\t\tif (cbsize <= pos + 8)\n\t\t\tgoto incomplete_cb;\n\t\t\n\t\tamount = upk_u64le(coinbase, pos);\n\t\tpos += 8; /* amount length */\n\t\t\n\t\ttotal += amount;\n\t\t\n\t\ti = varint_decode(coinbase + pos, cbsize - pos, &curr_pk_script_len);\n\t\tif (!i || cbsize <= pos + i + curr_pk_script_len)\n\t\t\tgoto incomplete_cb;\n\t\tpos += i;\n\t\t\n\t\tstruct bytes_hashtbl *ah = NULL;\n\t\tHASH_FIND(hh, cb_param->scripts, &coinbase[pos], curr_pk_script_len, ah);\n\t\tif (ah)\n\t\t{\n\t\t\tfound_target = true;\n\t\t\ttarget += amount;\n\t\t}\n\t\t\n\t\tif (opt_debug)\n\t\t{\n\t\t\tchar s[(curr_pk_script_len * 2) + 3];\n\t\t\ti = script_to_address(s, sizeof(s), &coinbase[pos], curr_pk_script_len, cb_param->testnet);\n\t\t\tif (!(i && i <= sizeof(s)))\n\t\t\t{\n\t\t\t\ts[0] = '[';\n\t\t\t\tbin2hex(&s[1], &coinbase[pos], curr_pk_script_len);\n\t\t\t\tstrcpy(&s[(curr_pk_script_len * 2) + 1], \"]\");\n\t\t\t}\n\t\t\tapplog(LOG_DEBUG, \"Coinbase output: %10\"PRIu64\" -- %s%s\", amount, s, ah ? \"*\" : \"\");\n\t\t}\n\t\t\n\t\tpos += curr_pk_script_len;\n\t}\n\tif (total < cb_param->total)\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: lopsided total output amount = %\"PRIu64\", expecting >=%\"PRIu64, total, cb_param->total);\n\tif (cb_param->scripts)\n\t{\n\t\tif (cb_param->perc && !(total && (float)((double)target / total) >= cb_param->perc))\n\t\t\tapplogr(false, LOG_ERR, \"Coinbase check: lopsided target/total = %g(%\"PRIu64\"/%\"PRIu64\"), expecting >=%g\", (total ? (double)target / total : (double)0), target, total, cb_param->perc);\n\t\telse\n\t\tif (!found_target)\n\t\t\tapplogr(false, LOG_ERR, \"Coinbase check: not found any target addr\");\n\t}\n\t\n\tif (cbsize < pos + 4)\n\t\tapplogr(false, LOG_ERR, \"Coinbase check: No room for locktime\");\n\tpos += 4;\n\t\n\tif (opt_debug)\n\t\tapplog(LOG_DEBUG, \"Coinbase: (size, pos, addr_count, target, total) = (%lu, %lu, %d, %\"PRIu64\", %\"PRIu64\")\", (unsigned long)cbsize, (unsigned long)pos, (int)(HASH_COUNT(cb_param->scripts)), target, total);\n\t\n\treturn true;\n}\n\nstatic bool parse_notify(struct pool *pool, json_t *val)\n{\n\tconst char *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime;\n\tchar *job_id;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tsize_t cb1_len, cb2_len;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\tfor (i = 0; i < merkles; i++)\n\t\tif (!json_is_string(json_array_get(arr, i)))\n\t\t\tgoto out;\n\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = __json_array_string(val, 2);\n\tcoinbase2 = __json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n\tntime = __json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime)\n\t\tgoto out;\n\t\n\tjob_id = json_array_string(val, 0);\n\tif (!job_id)\n\t\tgoto out;\n\n\tcg_wlock(&pool->data_lock);\n\tcgtime(&pool->swork.tv_received);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tif (pool->swork.tr)\n\t{\n\t\ttmpl_decref(pool->swork.tr);\n\t\tpool->swork.tr = NULL;\n\t}\n\tpool->submit_old = !clean;\n\tpool->swork.clean = true;\n\t\n\t// stratum_set_goal ensures these are the same pointer if they match\n\tif (pool->goalname != pool->next_goalname)\n\t{\n\t\tfree(pool->goalname);\n\t\tpool->goalname = pool->next_goalname;\n\t\tmining_goal_reset(pool->goal);\n\t}\n\tif (pool->next_goal_malgo)\n\t{\n\t\tgoal_set_malgo(pool->goal, pool->next_goal_malgo);\n\t\tpool->next_goal_malgo = NULL;\n\t}\n\t\n\tif (pool->next_nonce1)\n\t{\n\t\tfree(pool->swork.nonce1);\n\t\tpool->n1_len = strlen(pool->next_nonce1) / 2;\n\t\tpool->swork.nonce1 = pool->next_nonce1;\n\t\tpool->next_nonce1 = NULL;\n\t}\n\tint n2size = pool->swork.n2size = pool->next_n2size;\n\tpool->nonce2sz  = (n2size > sizeof(pool->nonce2)) ? sizeof(pool->nonce2) : n2size;\n#ifdef WORDS_BIGENDIAN\n\tpool->nonce2off = (n2size < sizeof(pool->nonce2)) ? (sizeof(pool->nonce2) - n2size) : 0;\n#endif\n\t\n\thex2bin(&pool->swork.header1[0], bbversion,  4);\n\thex2bin(&pool->swork.header1[4], prev_hash, 32);\n\thex2bin((void*)&pool->swork.ntime, ntime, 4);\n\tpool->swork.ntime = be32toh(pool->swork.ntime);\n\thex2bin(&pool->swork.diffbits[0], nbit, 4);\n\t\n\t/* Nominally allow a driver to ntime roll 60 seconds */\n\tset_simple_ntime_roll_limit(&pool->swork.ntime_roll_limits, pool->swork.ntime, 60, &pool->swork.tv_received);\n\t\n\tcb1_len = strlen(coinbase1) / 2;\n\tpool->swork.nonce2_offset = cb1_len + pool->n1_len;\n\tcb2_len = strlen(coinbase2) / 2;\n\n\tbytes_resize(&pool->swork.coinbase, pool->swork.nonce2_offset + pool->swork.n2size + cb2_len);\n\tuint8_t *coinbase = bytes_buf(&pool->swork.coinbase);\n\thex2bin(coinbase, coinbase1, cb1_len);\n\thex2bin(&coinbase[cb1_len], pool->swork.nonce1, pool->n1_len);\n\t// NOTE: gap for nonce2, filled at work generation time\n\thex2bin(&coinbase[pool->swork.nonce2_offset + pool->swork.n2size], coinbase2, cb2_len);\n\t\n\tbytes_resize(&pool->swork.merkle_bin, 32 * merkles);\n\tfor (i = 0; i < merkles; i++)\n\t\thex2bin(&bytes_buf(&pool->swork.merkle_bin)[i * 32], json_string_value(json_array_get(arr, i)), 32);\n\tpool->swork.merkles = merkles;\n\tpool->nonce2 = 0;\n\t\n\tmemcpy(pool->swork.target, pool->next_target, 0x20);\n\t\n\tpool_check_coinbase(pool, coinbase, bytes_len(&pool->swork.coinbase));\n\t\n\tcg_wunlock(&pool->data_lock);\n\n\tapplog(LOG_DEBUG, \"Received stratum notify from pool %u with job_id=%s\",\n\t       pool->pool_no, job_id);\n\tif (opt_debug && opt_protocol)\n\t{\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tfor (i = 0; i < merkles; i++)\n\t\t\tapplog(LOG_DEBUG, \"merkle%d: %s\", i, json_string_value(json_array_get(arr, i)));\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\n\tif ((merkles && (!pool->swork.transparency_probed || rand() <= RAND_MAX / (opt_skip_checks + 1))) || timer_isset(&pool->swork.tv_transparency))\n\t\tif (pool->probed)\n\t\t\tstratum_probe_transparency(pool);\n\n\tret = true;\nout:\n\treturn ret;\n}\n\nstatic bool parse_diff(struct pool *pool, json_t *val)\n{\n\tconst struct mining_goal_info * const goal = pool->goal;\n\tconst struct mining_algorithm * const malgo = goal->malgo;\n\tdouble diff;\n\n\tdiff = json_number_value(json_array_get(val, 0));\n\tif (diff == 0)\n\t\treturn false;\n\n\tif ((int64_t)diff != diff)\n\t{\n\t\t// Assume fractional values are proper bdiff per specification\n\t\t// Allow integers to be interpreted as pdiff, since the difference is trivial and some pools see it this way\n\t\tdiff = bdiff_to_pdiff(diff);\n\t}\n\t\n#ifdef USE_SHA256D\n\tif (malgo->algo == POW_SHA256D && diff < 1 && diff > 0.999)\n\t\tdiff = 1;\n#endif\n\t\n#ifdef USE_SCRYPT\n\t// Broken Scrypt pools multiply difficulty by 0x10000\n\tconst double broken_scrypt_diff_multiplier = 0x10000;\n\n\t/* 7/12/2014: P2Pool code was fixed: https://github.com/forrestv/p2pool/pull/210\n\t   7/15/2014: Popular pools unfixed: wemineltc, dogehouse, p2pool.org\n                  Cannot find a broken Scrypt pool that will dispense diff lower than 16 */\n\n\t// Ideally pools will fix their implementation and we can remove this\n\t// This should suffice until miners are hashing Scrypt at ~1-7 Gh/s (based on a share rate target of 10-60s)\n\n\tconst double minimum_broken_scrypt_diff = 16;\n\t// Diff 16 at 1.15 Gh/s = 1 share / 60s\n\t// Diff 16 at 7.00 Gh/s = 1 share / 10s\n\n\tif (malgo->algo == POW_SCRYPT && (diff >= minimum_broken_scrypt_diff))\n\t\tdiff /= broken_scrypt_diff_multiplier;\n#endif\n\n\tcg_wlock(&pool->data_lock);\n\tset_target_to_pdiff(pool->next_target, diff);\n\tcg_wunlock(&pool->data_lock);\n\n\tapplog(LOG_DEBUG, \"Pool %d stratum difficulty set to %g\", pool->pool_no, diff);\n\n\treturn true;\n}\n\nstatic\nbool stratum_set_extranonce(struct pool * const pool, json_t * const val, json_t * const params)\n{\n\tchar *nonce1 = NULL;\n\tint n2size = 0;\n\tjson_t *j;\n\t\n\tif (!json_is_array(params))\n\t\tgoto err;\n\tswitch (json_array_size(params))\n\t{\n\t\tdefault:  // >=2\n\t\t\t// n2size\n\t\t\tj = json_array_get(params, 1);\n\t\t\tif (json_is_number(j))\n\t\t\t{\n\t\t\t\tn2size = json_integer_value(j);\n\t\t\t\tif (n2size < 1)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t\telse\n\t\t\tif (!json_is_null(j))\n\t\t\t\tgoto err;\n\t\t\t// fallthru\n\t\tcase 1:\n\t\t\t// nonce1\n\t\t\tj = json_array_get(params, 0);\n\t\t\tif (json_is_string(j))\n\t\t\t\tnonce1 = strdup(json_string_value(j));\n\t\t\telse\n\t\t\tif (!json_is_null(j))\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tapplog(LOG_WARNING, \"Pool %u: No-op mining.set_extranonce?\", pool->pool_no);\n\t\t\treturn true;\n\t}\n\t\n\tcg_wlock(&pool->data_lock);\n\tif (nonce1)\n\t{\n\t\tfree(pool->next_nonce1);\n\t\tpool->next_nonce1 = nonce1;\n\t}\n\tif (n2size)\n\t\tpool->next_n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\t\n\treturn true;\n\nerr:\n\tapplog(LOG_ERR, \"Pool %u: Invalid mining.set_extranonce\", pool->pool_no);\n\t\n\tjson_t *id = json_object_get(val, \"id\");\n\tif (id && !json_is_null(id))\n\t{\n\t\tchar s[RBUFSIZE], *idstr;\n\t\tidstr = json_dumps_ANY(id, 0);\n\t\tsprintf(s, \"{\\\"id\\\": %s, \\\"result\\\": null, \\\"error\\\": [20, \\\"Invalid params\\\"]}\", idstr);\n\t\tfree(idstr);\n\t\tstratum_send(pool, s, strlen(s));\n\t}\n\t\n\treturn true;\n}\n\nstatic\nbool stratum_set_goal(struct pool * const pool, json_t * const val, json_t * const params)\n{\n\tif (!uri_get_param_bool(pool->rpc_url, \"goalreset\", false))\n\t\treturn false;\n\t\n\tconst char * const new_goalname = __json_array_string(params, 0);\n\tstruct mining_algorithm *new_malgo = NULL;\n\tconst char *emsg = NULL;\n\t\n\tif (json_is_array(params) && json_array_size(params) > 1)\n\t{\n\t\tjson_t * const j_goaldesc = json_array_get(params, 1);\n\t\tif (json_is_object(j_goaldesc))\n\t\t{\n\t\t\tjson_t * const j_malgo = json_object_get(j_goaldesc, \"malgo\");\n\t\t\tif (j_malgo && json_is_string(j_malgo))\n\t\t\t{\n\t\t\t\tconst char * const newvalue = json_string_value(j_malgo);\n\t\t\t\tnew_malgo = mining_algorithm_by_alias(newvalue);\n\t\t\t\t// Even if it's the current malgo, we should reset next_goal_malgo in case of a prior set_goal\n\t\t\t\tif (new_malgo == pool->goal->malgo)\n\t\t\t\t{}  // Do nothing, assignment takes place below\n\t\t\t\tif (new_malgo && uri_get_param_bool(pool->rpc_url, \"change_goal_malgo\", false))\n\t\t\t\t{}  // Do nothing, assignment takes place below\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\temsg = \"Mining algorithm not supported\";\n\t\t\t\t\t// Ignore even the goal name, if we are failing\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (new_malgo == pool->goal->malgo)\n\t\t\t\t\tnew_malgo = NULL;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Even if the goal name is not changing, we need to adopt and configuration change\n\tpool->next_goal_malgo = new_malgo;\n\t\n\tif (pool->next_goalname && pool->next_goalname != pool->goalname)\n\t\tfree(pool->next_goalname);\n\t\n\t// This compares goalname to new_goalname, but matches NULL correctly :)\n\tif (pool->goalname ? !strcmp(pool->goalname, new_goalname) : !new_goalname)\n\t\tpool->next_goalname = pool->goalname;\n\telse\n\t\tpool->next_goalname = maybe_strdup(new_goalname);\n\t\nout: ;\n\tjson_t * const j_id = json_object_get(val, \"id\");\n\tif (j_id && !json_is_null(j_id))\n\t{\n\t\tchar * const idstr = json_dumps_ANY(j_id, 0);\n\t\tchar buf[0x80];\n\t\tif (unlikely(emsg))\n\t\t\tsnprintf(buf, sizeof(buf), \"{\\\"id\\\":%s,\\\"result\\\":null,\\\"error\\\":[-1,\\\"%s\\\",null]}\", idstr, emsg);\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"{\\\"id\\\":%s,\\\"result\\\":true,\\\"error\\\":null}\", idstr);\n\t\tfree(idstr);\n\t\tstratum_send(pool, buf, strlen(buf));\n\t}\n\t\n\treturn true;\n}\n\nstatic bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tif (opt_disable_client_reconnect)\n\t\treturn false;\n\t\n\tconst char *url;\n\tchar address[256];\n\tjson_t *port_json;\n\n\turl = __json_array_string(val, 0);\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse\n\tif (!pool_may_redirect_to(pool, url))\n\t\treturn false;\n\n\tport_json = json_array_get(val, 1);\n\tif (json_is_number(port_json))\n\t{\n\t\tconst unsigned port = json_number_value(port_json);\n\t\tsnprintf(address, sizeof(address), \"%s:%u\", url, port);\n\t}\n\telse\n\t{\n\t\tconst char *port;\n\t\tif (json_is_string(port_json))\n\t\t\tport = json_string_value(port_json);\n\t\telse\n\t\t\tport = pool->stratum_port;\n\t\t\n\t\tsnprintf(address, sizeof(address), \"%s:%s\", url, port);\n\t}\n\n\tif (!extract_sockaddr(address, &pool->sockaddr_url, &pool->stratum_port))\n\t\treturn false;\n\n\tpool->stratum_url = pool->sockaddr_url;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tif (!restart_stratum(pool))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool send_version(struct pool *pool, json_t *val)\n{\n\tchar s[RBUFSIZE], *idstr;\n\tjson_t *id = json_object_get(val, \"id\");\n\t\n\tif (!(id && !json_is_null(id)))\n\t\treturn false;\n\n\tidstr = json_dumps_ANY(id, 0);\n\tsprintf(s, \"{\\\"id\\\": %s, \\\"result\\\": \\\"%s\\\", \\\"error\\\": null}\", idstr, bfgminer_name_slash_ver);\n\tfree(idstr);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool stratum_show_message(struct pool *pool, json_t *val, json_t *params)\n{\n\tchar *msg;\n\tchar s[RBUFSIZE], *idstr;\n\tjson_t *id = json_object_get(val, \"id\");\n\tmsg = json_array_string(params, 0);\n\t\n\tif (likely(msg))\n\t{\n\t\tfree(pool->admin_msg);\n\t\tpool->admin_msg = msg;\n\t\tapplog(LOG_NOTICE, \"Message from pool %u: %s\", pool->pool_no, msg);\n\t}\n\t\n\tif (!(id && !json_is_null(id)))\n\t\treturn true;\n\t\n\tidstr = json_dumps_ANY(id, 0);\n\tif (likely(msg))\n\t\tsprintf(s, \"{\\\"id\\\": %s, \\\"result\\\": true, \\\"error\\\": null}\", idstr);\n\telse\n\t\tsprintf(s, \"{\\\"id\\\": %s, \\\"result\\\": null, \\\"error\\\": [-1, \\\"Failed to parse message\\\", null]}\", idstr);\n\tfree(idstr);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\n\t\n\treturn true;\n}\n\nbool parse_method(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *method, *err_val, *params;\n\tjson_error_t err;\n\tbool ret = false;\n\tconst char *buf;\n\n\tif (!s)\n\t\tgoto out;\n\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tmethod = json_object_get(val, \"method\");\n\tif (!method)\n\t\tgoto out;\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\n\tif (err_val && !json_is_null(err_val)) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tbuf = json_string_value(method);\n\tif (!buf)\n\t\tgoto out;\n\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t\tif (parse_notify(pool, params))\n\t\t\tpool->stratum_notify = ret = true;\n\t\telse\n\t\t\tpool->stratum_notify = ret = false;\n\t\tgoto out;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tif (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tif (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tif (!strncasecmp(buf, \"client.show_message\", 19) && stratum_show_message(pool, val, params)) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\t\n\tif (!strncasecmp(buf, \"mining.set_extranonce\", 21) && stratum_set_extranonce(pool, val, params)) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\t\n\t// Usage: mining.set_goal(\"goal name\", {\"malgo\":\"SHA256d\", ...})\n\tif (!strncasecmp(buf, \"mining.set_goal\", 15) && stratum_set_goal(pool, val, params))\n\t\treturn_via(out, ret = true);\n\t\nout:\n\tif (val)\n\t\tjson_decref(val);\n\n\treturn ret;\n}\n\nextern bool parse_stratum_response(struct pool *, char *s);\n\nbool auth_stratum(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\n\tsprintf(s, \"{\\\"id\\\": \\\"auth\\\", \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",\n\t        pool->rpc_user, pool->rpc_pass);\n\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\tgoto out;\n\n\t/* Parse all data in the queue and anything left should be auth */\n\twhile (42) {\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\tgoto out;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t{\n\t\t\tbool unknown = true;\n\t\t\tval = JSON_LOADS(sret, &err);\n\t\t\tjson_t *j_id = json_object_get(val, \"id\");\n\t\t\tif (json_is_string(j_id))\n\t\t\t{\n\t\t\t\tif (!strcmp(json_string_value(j_id), \"auth\"))\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\tif (!strcmp(json_string_value(j_id), \"xnsub\"))\n\t\t\t\t\tunknown = false;\n\t\t\t}\n\t\t\tif (unknown)\n\t\t\t\tapplog(LOG_WARNING, \"Pool %u: Unknown stratum msg: %s\", pool->pool_no, sret);\n\t\t\tfree(sret);\n\t\t}\n\t}\n\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_WARNING, \"pool %d JSON stratum auth failed: %s\", pool->pool_no, ss);\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum authorisation success for pool %d\", pool->pool_no);\n\tpool->probed = true;\n\tsuccessful_connect = true;\n\t\n\tif (uri_get_param_bool(pool->rpc_url, \"cksuggest\", false)) {\n\t\tunsigned long req_bdiff = request_bdiff;\n\t\t\n\t\tconst char *q = uri_find_param(pool->rpc_url, \"cksuggest\", NULL);\n\t\tif (q && q != URI_FIND_PARAM_FOUND) {\n\t\t\treq_bdiff = atoi(q);\n\t\t}\n\t\t\n\t\tif (req_bdiff) {\n\t\t\tint sz = snprintf(s, sizeof(s), \"{\\\"id\\\": null, \\\"method\\\": \\\"mining.suggest_difficulty\\\", \\\"params\\\": [%lu]}\", req_bdiff);\n\t\t\tstratum_send(pool, s, sz);\n\t\t}\n\t}\n\t\nout:\n\tif (val)\n\t\tjson_decref(val);\n\n\tif (pool->stratum_notify)\n\t\tstratum_probe_transparency(pool);\n\n\treturn ret;\n}\n\ncurl_socket_t grab_socket_opensocket_cb(void *clientp, __maybe_unused curlsocktype purpose, struct curl_sockaddr *addr)\n{\n\tstruct pool *pool = clientp;\n\tcurl_socket_t sck = bfg_socket(addr->family, addr->socktype, addr->protocol);\n\tpool->sock = sck;\n\treturn sck;\n}\n\nstatic bool setup_stratum_curl(struct pool *pool)\n{\n\tCURL *curl = NULL;\n\tchar s[RBUFSIZE];\n\tbool ret = false;\n\tbool tls_only = false, try_tls = true;\n\tbool tlsca = uri_get_param_bool(pool->rpc_url, \"tlsca\", false);\n\t\n\t{\n\t\tconst enum bfg_tristate tlsparam = uri_get_param_bool2(pool->rpc_url, \"tls\");\n\t\tif (tlsparam != BTS_UNKNOWN)\n\t\t\ttry_tls = tls_only = tlsparam;\n\t\telse\n\t\tif (tlsca)\n\t\t\t// If tlsca is enabled, require TLS by default\n\t\t\ttls_only = true;\n\t}\n\n\tapplog(LOG_DEBUG, \"initiate_stratum with sockbuf=%p\", pool->sockbuf);\n\tmutex_lock(&pool->stratum_lock);\n\ttimer_unset(&pool->swork.tv_transparency);\n\tpool->stratum_active = false;\n\tpool->stratum_notify = false;\n\tpool->swork.transparency_probed = false;\n\tif (pool->stratum_curl)\n\t\tcurl_easy_cleanup(pool->stratum_curl);\n\tpool->stratum_curl = curl_easy_init();\n\tif (unlikely(!pool->stratum_curl))\n\t\tquithere(1, \"Failed to curl_easy_init\");\n\tif (pool->sockbuf)\n\t\tpool->sockbuf[0] = '\\0';\n\n\tcurl = pool->stratum_curl;\n\n\tif (!pool->sockbuf) {\n\t\tpool->sockbuf = calloc(RBUFSIZE, 1);\n\t\tif (!pool->sockbuf)\n\t\t\tquithere(1, \"Failed to calloc pool sockbuf\");\n\t\tpool->sockbuf_size = RBUFSIZE;\n\t}\n\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 30);\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pool->curl_err_str);\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tif (!opt_delaynet)\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\n\t/* We use DEBUGFUNCTION to count bytes sent/received, and verbose is needed\n\t * to enable it */\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);\n\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\n\t// CURLINFO_LASTSOCKET is broken on Win64 (which has a wider SOCKET type than curl_easy_getinfo returns), so we use this hack for now\n\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETFUNCTION, grab_socket_opensocket_cb);\n\tcurl_easy_setopt(curl, CURLOPT_OPENSOCKETDATA, pool);\n\t\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, (long)(tlsca ? 2 : 0));\n\tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, (long)(tlsca ? 1 : 0));\n\tif (pool->rpc_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);\n\t} else if (opt_socks_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, 1);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);\n\t}\n\tcurl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, 1);\n\t\nretry:\n\t/* Create a http url for use with curl */\n\tsprintf(s, \"http%s://%s:%s\", try_tls ? \"s\" : \"\",\n\t        pool->sockaddr_url, pool->stratum_port);\n\tcurl_easy_setopt(curl, CURLOPT_URL, s);\n\t\n\tpool->sock = INVSOCK;\n\tif (curl_easy_perform(curl)) {\n\t\tif (try_tls)\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Stratum connect failed with TLS to pool %u: %s\",\n\t\t\t       pool->pool_no, pool->curl_err_str);\n\t\t\tif (!tls_only)\n\t\t\t{\n\t\t\t\ttry_tls = false;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_INFO, \"Stratum connect failed to pool %d: %s\",\n\t\t\t       pool->pool_no, pool->curl_err_str);\nerrout:\n\t\tcurl_easy_cleanup(curl);\n\t\tpool->stratum_curl = NULL;\n\t\tgoto out;\n\t}\n\tif (pool->sock == INVSOCK)\n\t{\n\t\tapplog(LOG_ERR, \"Stratum connect succeeded, but technical problem extracting socket (pool %u)\", pool->pool_no);\n\t\tgoto errout;\n\t}\n\tkeep_sockalive(pool->sock);\n\n\tpool->cgminer_pool_stats.times_sent++;\n\tpool->cgminer_pool_stats.times_received++;\n\tret = true;\n\nout:\n\tmutex_unlock(&pool->stratum_lock);\n\t\n\treturn ret;\n}\n\nstatic char *get_sessionid(json_t *val)\n{\n\tchar *ret = NULL;\n\tjson_t *arr_val;\n\tint arrsize, i;\n\n\tarr_val = json_array_get(val, 0);\n\tif (!arr_val || !json_is_array(arr_val))\n\t\tgoto out;\n\tarrsize = json_array_size(arr_val);\n\tfor (i = 0; i < arrsize; i++) {\n\t\tjson_t *arr = json_array_get(arr_val, i);\n\t\tconst char *notify;\n\n\t\tif (!arr | !json_is_array(arr))\n\t\t\tbreak;\n\t\tnotify = __json_array_string(arr, 0);\n\t\tif (!notify)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(notify, \"mining.notify\", 13)) {\n\t\t\tret = json_array_string(arr, 1);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nvoid suspend_stratum(struct pool *pool)\n{\n\tclear_sockbuf(pool);\n\tapplog(LOG_INFO, \"Closing socket for stratum pool %d\", pool->pool_no);\n\n\tmutex_lock(&pool->stratum_lock);\n\tpool->stratum_active = pool->stratum_notify = false;\n\tif (pool->stratum_curl) {\n\t\tcurl_easy_cleanup(pool->stratum_curl);\n\t}\n\tpool->stratum_curl = NULL;\n\tpool->sock = INVSOCK;\n\tmutex_unlock(&pool->stratum_lock);\n}\n\nbool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tbool trysuggest = request_target_str && !uri_get_param_bool(pool->rpc_url, \"cksuggest\", false);\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\n\nresend:\n\tif (!setup_stratum_curl(pool)) {\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\n\tsockd = true;\n\n\tclear_sock(pool);\n\t\n\tif (trysuggest)\n\t{\n\t\tint sz = sprintf(s, \"{\\\"id\\\": null, \\\"method\\\": \\\"mining.suggest_target\\\", \\\"params\\\": [\\\"%s\\\"]}\", request_target_str);\n\t\tif (!_stratum_send(pool, s, sz, true))\n\t\t{\n\t\t\tapplog(LOG_DEBUG, \"Pool %u: Failed to send suggest_target in initiate_stratum\", pool->pool_no);\n\t\t\tgoto out;\n\t\t}\n\t\trecvd = true;\n\t}\n\t\n\tif (uri_get_param_bool(pool->rpc_url, \"goalreset\", false))\n\t{\n\t\t// Default: [\"notify\", \"set_difficulty\"] (but these must be explicit if mining.capabilities is used)\n\t\tsnprintf(s, sizeof(s), \"{\\\"id\\\":null,\\\"method\\\":\\\"mining.capabilities\\\",\\\"params\\\":[{\\\"notify\\\":[],\\\"set_difficulty\\\":{},\\\"set_goal\\\":[],\\\"malgo\\\":{\");\n\t\tstruct mining_algorithm *malgo;\n\t\tLL_FOREACH(mining_algorithms, malgo)\n\t\t{\n\t\t\ttailsprintf(s, sizeof(s), \"\\\"%s\\\":{}%c\", malgo->name, malgo->next ? ',' : '}');\n\t\t}\n\t\tif (request_target_str)\n\t\t\ttailsprintf(s, sizeof(s), \",\\\"suggested_target\\\":\\\"%s\\\"\", request_target_str);\n\t\ttailsprintf(s, sizeof(s), \"}]}\");\n\t\t_stratum_send(pool, s, strlen(s), true);\n\t}\n\t\n\tif (noresume) {\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\", swork_id++, bfgminer_name_slash_ver, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"%s\\\"]}\", swork_id++, bfgminer_name_slash_ver);\n\t}\n\n\tif (!_stratum_send(pool, s, strlen(s), true)) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\trecvd = true;\n\t\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->sessionid);\n\tpool->sessionid = sessionid;\n\tfree(pool->next_nonce1);\n\tpool->next_nonce1 = nonce1;\n\tpool->next_n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"Pool %d stratum session id: %s\", pool->pool_no, pool->sessionid);\n\n\tret = true;\nout:\n\tif (val)\n\t{\n\t\tjson_decref(val);\n\t\tval = NULL;\n\t}\n\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tset_target_to_pdiff(pool->next_target, 1);\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       pool->pool_no, pool->next_nonce1, pool->next_n2size);\n\t\t}\n\t\t\n\t\tif (uri_get_param_bool(pool->rpc_url, \"xnsub\", false))\n\t\t{\n\t\t\tsprintf(s, \"{\\\"id\\\": \\\"xnsub\\\", \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\");\n\t\t\t_stratum_send(pool, s, strlen(s), true);\n\t\t}\n\t} else {\n\t\tif (recvd)\n\t\t{\n\t\t\tif (trysuggest)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Pool %u: Failed to connect stratum with mining.suggest_target, retrying without\", pool->pool_no);\n\t\t\t\ttrysuggest = false;\n\t\t\t\tgoto resend;\n\t\t\t}\n\t\t\tif (!noresume)\n\t\t\t{\n\t\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\t\tnoresume = true;\n\t\t\t\tgoto resend;\n\t\t\t}\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiate stratum failed\");\n\t\tif (sockd)\n\t\t\tsuspend_stratum(pool);\n\t}\n\n\treturn ret;\n}\n\nbool restart_stratum(struct pool *pool)\n{\n\tbool ret = true;\n\t\n\tmutex_lock(&pool->pool_test_lock);\n\t\n\tif (pool->stratum_active)\n\t\tsuspend_stratum(pool);\n\t\n\tif (!initiate_stratum(pool))\n\t\treturn_via(out, ret = false);\n\tif (!auth_stratum(pool))\n\t\treturn_via(out, ret = false);\n\t\nout:\n\tmutex_unlock(&pool->pool_test_lock);\n\t\n\treturn ret;\n}\n\nvoid dev_error_update(struct cgpu_info *dev, enum dev_reason reason)\n{\n\tdev->device_last_not_well = time(NULL);\n\tcgtime(&dev->tv_device_last_not_well);\n\tdev->device_not_well_reason = reason;\n}\n\nvoid dev_error(struct cgpu_info *dev, enum dev_reason reason)\n{\n\tdev_error_update(dev, reason);\n\n\tswitch (reason) {\n\t\tcase REASON_THREAD_FAIL_INIT:\n\t\t\tdev->thread_fail_init_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_ZERO_HASH:\n\t\t\tdev->thread_zero_hash_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_FAIL_QUEUE:\n\t\t\tdev->thread_fail_queue_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_SICK_IDLE_60:\n\t\t\tdev->dev_sick_idle_60_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_DEAD_IDLE_600:\n\t\t\tdev->dev_dead_idle_600_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_NOSTART:\n\t\t\tdev->dev_nostart_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_OVER_HEAT:\n\t\t\tdev->dev_over_heat_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THERMAL_CUTOFF:\n\t\t\tdev->dev_thermal_cutoff_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_COMMS_ERROR:\n\t\t\tdev->dev_comms_error_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THROTTLE:\n\t\t\tdev->dev_throttle_count++;\n\t\t\tbreak;\n\t}\n}\n\n/* Realloc an existing string to fit an extra string s, appending s to it. */\nvoid *realloc_strcat(char *ptr, char *s)\n{\n\tsize_t old = strlen(ptr), len = strlen(s);\n\tchar *ret;\n\n\tif (!len)\n\t\treturn ptr;\n\n\tlen += old + 1;\n\talign_len(&len);\n\n\tret = malloc(len);\n\tif (unlikely(!ret))\n\t\tquithere(1, \"Failed to malloc\");\n\n\tsprintf(ret, \"%s%s\", ptr, s);\n\tfree(ptr);\n\treturn ret;\n}\n\nstatic\nbool sanechars[] = {\n\tfalse, false, false, false, false, false, false, false,\n\tfalse, false, false, false, false, false, false, false,\n\tfalse, false, false, false, false, false, false, false,\n\tfalse, false, false, false, false, false, false, false,\n\tfalse, false, false, false, false, false, false, false,\n\tfalse, false, false, false, false, true , false, false,\n\ttrue , true , true , true , true , true , true , true ,\n\ttrue , true , false, false, false, false, false, false,\n\tfalse, true , true , true , true , true , true , true ,\n\ttrue , true , true , true , true , true , true , true ,\n\ttrue , true , true , true , true , true , true , true ,\n\ttrue , true , true , false, false, false, false, false,\n\tfalse, true , true , true , true , true , true , true ,\n\ttrue , true , true , true , true , true , true , true ,\n\ttrue , true , true , true , true , true , true , true ,\n\ttrue , true , true , false, false, false, false, false,\n};\n\nchar *sanestr(char *o, char *s)\n{\n\tchar *rv = o;\n\tbool br = false;\n\t\n\tfor ( ; s[0]; ++s)\n\t{\n\t\tif (sanechars[s[0] & 0x7f])\n\t\t{\n\t\t\tif (br)\n\t\t\t{\n\t\t\t\tbr = false;\n\t\t\t\tif (s[0] >= '0' && s[0] <= '9')\n\t\t\t\t\t(o++)[0] = '_';\n\t\t\t}\n\t\t\t(o++)[0] = s[0];\n\t\t}\n\t\telse\n\t\tif (o != s && o[-1] >= '0' && o[-1] <= '9')\n\t\t\tbr = true;\n\t}\n\to[0] = '\\0';\n\treturn rv;\n}\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n\t// Only the first 15 characters are used (16 - NUL terminator)\n\tprctl(PR_SET_NAME, name, 0, 0, 0);\n#elif defined(__APPLE__)\n\tpthread_setname_np(name);\n#elif (defined(__FreeBSD__) || defined(__OpenBSD__))\n\tpthread_set_name_np(pthread_self(), name);\n#else\n\t// Prevent warnings for unused parameters...\n\t(void)name;\n#endif\n}\n\nstatic pthread_key_t key_bfgtls;\nstruct bfgtls_data {\n\tchar *bfg_strerror_result;\n\tsize_t bfg_strerror_resultsz;\n#ifdef WIN32\n\tLPSTR bfg_strerror_socketresult;\n#endif\n#ifdef NEED_BFG_LOWL_VCOM\n\tstruct detectone_meta_info_t __detectone_meta_info;\n#endif\n\tunsigned probe_result_flags;\n};\n\nstatic\nstruct bfgtls_data *get_bfgtls()\n{\n\tstruct bfgtls_data *bfgtls = pthread_getspecific(key_bfgtls);\n\tif (bfgtls)\n\t\treturn bfgtls;\n\t\n\tvoid *p;\n\t\n\tbfgtls = malloc(sizeof(*bfgtls));\n\tif (!bfgtls)\n\t\tquithere(1, \"malloc bfgtls failed\");\n\tp = malloc(64);\n\tif (!p)\n\t\tquithere(1, \"malloc bfg_strerror_result failed\");\n\t*bfgtls = (struct bfgtls_data){\n\t\t.bfg_strerror_resultsz = 64,\n\t\t.bfg_strerror_result = p,\n\t};\n\tif (pthread_setspecific(key_bfgtls, bfgtls))\n\t\tquithere(1, \"pthread_setspecific failed\");\n\t\n\treturn bfgtls;\n}\n\nstatic\nvoid bfgtls_free(void * const p)\n{\n\tstruct bfgtls_data * const bfgtls = p;\n\tfree(bfgtls->bfg_strerror_result);\n#ifdef WIN32\n\tif (bfgtls->bfg_strerror_socketresult)\n\t\tLocalFree(bfgtls->bfg_strerror_socketresult);\n#endif\n\tfree(bfgtls);\n}\n\n#ifdef NEED_BFG_LOWL_VCOM\nstruct detectone_meta_info_t *_detectone_meta_info()\n{\n\treturn &get_bfgtls()->__detectone_meta_info;\n}\n#endif\n\nunsigned *_bfg_probe_result_flags()\n{\n\treturn &get_bfgtls()->probe_result_flags;\n}\n\nvoid bfg_init_threadlocal()\n{\n\tif (pthread_key_create(&key_bfgtls, bfgtls_free))\n\t\tquithere(1, \"pthread_key_create failed\");\n}\n\nstatic\nbool bfg_grow_buffer(char ** const bufp, size_t * const bufszp, size_t minimum)\n{\n\tif (minimum <= *bufszp)\n\t\treturn false;\n\t\n\twhile (minimum > *bufszp)\n\t\t*bufszp = 2;\n\t*bufp = realloc(*bufp, *bufszp);\n\tif (unlikely(!*bufp))\n\t\tquithere(1, \"realloc failed\");\n\t\n\treturn true;\n}\n\nstatic\nconst char *bfg_strcpy_growing_buffer(char ** const bufp, size_t * const bufszp, const char *src)\n{\n\tif (!src)\n\t\treturn NULL;\n\t\n\tconst size_t srcsz = strlen(src) + 1;\n\t\n\tbfg_grow_buffer(bufp, bufszp, srcsz);\n\tmemcpy(*bufp, src, srcsz);\n\t\n\treturn *bufp;\n}\n\n// Guaranteed to always return some string (or quit)\nconst char *bfg_strerror(int e, enum bfg_strerror_type type)\n{\n\tstatic __maybe_unused pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\tstruct bfgtls_data *bfgtls = get_bfgtls();\n\tsize_t * const bufszp = &bfgtls->bfg_strerror_resultsz;\n\tchar ** const bufp = &bfgtls->bfg_strerror_result;\n\tconst char *have = NULL;\n\t\n\tswitch (type) {\n\t\tcase BST_LIBUSB:\n// NOTE: Nested preprocessor checks since the latter isn't defined at all without the former\n#ifdef HAVE_LIBUSB\n#\tif HAVE_DECL_LIBUSB_ERROR_NAME\n\t\t\t// libusb makes no guarantees for thread-safety or persistence\n\t\t\tmutex_lock(&mutex);\n\t\t\thave = bfg_strcpy_growing_buffer(bufp, bufszp, libusb_error_name(e));\n\t\t\tmutex_unlock(&mutex);\n#\tendif\n#endif\n\t\t\tbreak;\n\t\tcase BST_SOCKET:\n\t\tcase BST_SYSTEM:\n\t\t{\n#ifdef WIN32\n\t\t\t// Windows has a different namespace for system and socket errors\n\t\t\tLPSTR *msg = &bfgtls->bfg_strerror_socketresult;\n\t\t\tif (*msg)\n\t\t\t\tLocalFree(*msg);\n\t\t\tif (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 0, e, 0, (LPSTR)msg, 0, 0))\n\t\t\t{\n\t\t\t\tLPSTR msgp = *msg;\n\t\t\t\tsize_t n = strlen(msgp);\n\t\t\t\twhile (isCspace(msgp[--n]))\n\t\t\t\t\tmsgp[n] = '\\0';\n\t\t\t\treturn *msg;\n\t\t\t}\n\t\t\t*msg = NULL;\n\t\t\t\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t\t// Fallthru on non-WIN32\n\t\tcase BST_ERRNO:\n\t\t{\n#ifdef __STRERROR_S_WORKS\n\t\t\t// FIXME: Not sure how to get this on MingW64\nretry:\n\t\t\tif (likely(!strerror_s(*bufp, *bufszp, e)))\n\t\t\t{\n\t\t\t\tif (bfg_grow_buffer(bufp, bufszp, strlen(*bufp) + 2))\n\t\t\t\t\tgoto retry;\n\t\t\t\treturn *bufp;\n\t\t\t}\n// TODO: XSI strerror_r\n// TODO: GNU strerror_r\n#else\n\t\t\tmutex_lock(&mutex);\n\t\t\thave = bfg_strcpy_growing_buffer(bufp, bufszp, strerror(e));\n\t\t\tmutex_unlock(&mutex);\n#endif\n\t\t}\n\t}\n\t\n\tif (have)\n\t\treturn *bufp;\n\t\n\t// Failback: Stringify the number\n\tstatic const char fmt[] = \"%s error #%d\", *typestr;\n\tswitch (type) {\n\t\tcase BST_ERRNO:\n\t\t\ttypestr = \"System\";\n\t\t\tbreak;\n\t\tcase BST_SOCKET:\n\t\t\ttypestr = \"Socket\";\n\t\t\tbreak;\n\t\tcase BST_LIBUSB:\n\t\t\ttypestr = \"libusb\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttypestr = \"Unexpected\";\n\t}\n\tint sz = snprintf((char*)bfgtls, 0, fmt, typestr, e) + 1;\n\tbfg_grow_buffer(bufp, bufszp, sz);\n\tsprintf(*bufp, fmt, typestr, e);\n\treturn *bufp;\n}\n\nvoid notifier_init(notifier_t pipefd)\n{\n#ifdef WIN32\n#define WindowsErrorStr(e)  bfg_strerror(e, BST_SOCKET)\n\tSOCKET listener, connecter, acceptor;\n\tlistener = bfg_socket(AF_INET, SOCK_STREAM, 0);\n\tif (listener == INVALID_SOCKET)\n\t\tquit(1, \"Failed to create listener socket\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tconnecter = bfg_socket(AF_INET, SOCK_STREAM, 0);\n\tif (connecter == INVALID_SOCKET)\n\t\tquit(1, \"Failed to create connect socket\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tstruct sockaddr_in inaddr = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_addr = {\n\t\t\t.s_addr = htonl(INADDR_LOOPBACK),\n\t\t},\n\t\t.sin_port = 0,\n\t};\n\t{\n\t\tstatic const int reuse = 1;\n\t\tsetsockopt(listener, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse));\n\t}\n\tif (bind(listener, (struct sockaddr*)&inaddr, sizeof(inaddr)) == SOCKET_ERROR)\n\t\tquit(1, \"Failed to bind listener socket\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tsocklen_t inaddr_sz = sizeof(inaddr);\n\tif (getsockname(listener, (struct sockaddr*)&inaddr, &inaddr_sz) == SOCKET_ERROR)\n\t\tquit(1, \"Failed to getsockname\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tif (listen(listener, 1) == SOCKET_ERROR)\n\t\tquit(1, \"Failed to listen\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tinaddr.sin_family = AF_INET;\n\tinaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tif (connect(connecter, (struct sockaddr*)&inaddr, inaddr_sz) == SOCKET_ERROR)\n\t\tquit(1, \"Failed to connect\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tacceptor = accept(listener, NULL, NULL);\n\tif (acceptor == INVALID_SOCKET)\n\t\tquit(1, \"Failed to accept\"IN_FMT_FFL\": %s\",\n\t\t     __FILE__, __func__, __LINE__, WindowsErrorStr(WSAGetLastError()));\n\tclosesocket(listener);\n\tpipefd[0] = connecter;\n\tpipefd[1] = acceptor;\n#else\n\tif (pipe(pipefd))\n\t\tquithere(1, \"Failed to create pipe\");\n#endif\n}\n\n\nvoid *bfg_slurp_file(void * const bufp, size_t bufsz, const char * const filename)\n{\n\tchar *buf = bufp;\n\tFILE * const F = fopen(filename, \"r\");\n\tif (!F)\n\t\tgoto err;\n\t\n\tif (!buf)\n\t{\n\t\tfseek(F, 0, SEEK_END);\n\t\tconst long filesz = ftell(F);\n\t\tif (unlikely(filesz < 0))\n\t\t{\n\t\t\tfclose(F);\n\t\t\tgoto err;\n\t\t}\n\t\trewind(F);\n\t\tbufsz = filesz + 1;\n\t\tbuf = malloc(bufsz);\n\t}\n\tconst size_t rsz = fread(buf, 1, bufsz - 1, F);\n\tfclose(F);\n\tbuf[rsz] = '\\0';\n\treturn buf;\n\nerr:\n\tif (buf)\n\t\tbuf[0] = '\\0';\n\treturn NULL;\n}\n\n\nvoid notifier_wake(notifier_t fd)\n{\n\tif (fd[1] == INVSOCK)\n\t\treturn;\n\tif (1 !=\n#ifdef WIN32\n\tsend(fd[1], \"\\0\", 1, 0)\n#else\n\twrite(fd[1], \"\\0\", 1)\n#endif\n\t)\n\t\tapplog(LOG_WARNING, \"Error trying to wake notifier\");\n}\n\nvoid notifier_read(notifier_t fd)\n{\n\tchar buf[0x10];\n#ifdef WIN32\n\tIGNORE_RETURN_VALUE(recv(fd[0], buf, sizeof(buf), 0));\n#else\n\tIGNORE_RETURN_VALUE(read(fd[0], buf, sizeof(buf)));\n#endif\n}\n\nbool notifier_wait(notifier_t notifier, const struct timeval *tvp_timeout)\n{\n\tstruct timeval tv_now, tv_timeout;\n\tfd_set rfds;\n\tint e;\n\t\n\twhile (true)\n\t{\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(notifier[0], &rfds);\n\t\ttv_timeout = *tvp_timeout;\n\t\ttimer_set_now(&tv_now);\n\t\te = select(notifier[0]+1, &rfds, NULL, NULL, select_timeout(&tv_timeout, &tv_now));\n\t\tif (e > 0)\n\t\t\treturn true;\n\t\tif (e == 0)\n\t\t\treturn false;\n\t}\n}\n\nbool notifier_wait_us(notifier_t notifier, const unsigned long long usecs)\n{\n\tstruct timeval tv_timeout = TIMEVAL_USECS(usecs);\n\treturn notifier_wait(notifier, &tv_timeout);\n}\n\nvoid notifier_reset(notifier_t notifier)\n{\n\tfd_set rfds;\n\tstruct timeval tv_timeout = { .tv_sec = 0, };\n\tFD_ZERO(&rfds);\n\tFD_SET(notifier[0], &rfds);\n\twhile (select(notifier[0]+1, &rfds, NULL, NULL, &tv_timeout) != 0)\n\t\tnotifier_read(notifier);\n}\n\nvoid notifier_init_invalid(notifier_t fd)\n{\n\tfd[0] = fd[1] = INVSOCK;\n}\n\nvoid notifier_destroy(notifier_t fd)\n{\n#ifdef WIN32\n\tclosesocket(fd[0]);\n\tclosesocket(fd[1]);\n#else\n\tclose(fd[0]);\n\tclose(fd[1]);\n#endif\n\tfd[0] = fd[1] = INVSOCK;\n}\n\nvoid _bytes_alloc_failure(size_t sz)\n{\n\tquit(1, \"bytes_resize failed to allocate %lu bytes\", (unsigned long)sz);\n}\n\n\nchar *trimmed_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *c;\n\t\n\twhile (isspace(s[0]))\n\t\t++s;\n\tn = strlen(s) - 1;\n\twhile (isspace(s[n]))\n\t\t--n;\n\t++n;\n\tc = malloc(n + 1);\n\tc[n] = '\\0';\n\tmemcpy(c, s, n);\n\treturn c;\n}\n\n\nvoid *cmd_thread(void *cmdp)\n{\n\tconst char *cmd = cmdp;\n\tapplog(LOG_DEBUG, \"Executing command: %s\", cmd);\n\tint rc = system(cmd);\n\tif (rc)\n\t\tapplog(LOG_WARNING, \"Command returned %d exit code: %s\", rc, cmd);\n\treturn NULL;\n}\n\nvoid run_cmd(const char *cmd)\n{\n\tif (!cmd)\n\t\treturn;\n\tpthread_t pth;\n\tpthread_create(&pth, NULL, cmd_thread, (void*)cmd);\n}\n\n\n#if defined(USE_BITMAIN) || defined(USE_ICARUS)\nbool bm1382_freq_to_reg_data(uint8_t * const out_reg_data, float mhz)\n{\n\t// We add 1 so fractions don't interfere with near-integer settings\n\t++mhz;\n\t\n\tif (mhz < 100)\n\t\treturn false;\n\tfloat best_delta = FLT_MAX;\n\tunsigned best_dc = 0;\n\tunsigned try_list[4], *tlp = try_list;\n\tif (mhz >= 200) {\n\t\tif (mhz >= 403.125) {\n\t\t\t*(tlp++) = 0x0101;\n\t\t\t*(tlp++) = 0x0205;\n\t\t} else {\n\t\t\t*(tlp++) = 0x0202;\n\t\t}\n\t\t*(tlp++) = 0x0406;\n\t} else {\n\t\t*(tlp++) = 0x0403;\n\t}\n\t*(tlp++) = 0x0807;\n\tfor (unsigned *tli = try_list; tli < tlp; ++tli) {\n\t\tconst float d = *tli >> 8;\n\t\tconst float df = 25. / d;\n\t\tunsigned n = mhz / df;\n\t\t// NOTE: 0x3f here is 0x3e in the final register\n\t\tif (n > 0x3f) {\n\t\t\tn = 0x3f;\n\t\t}\n\t\tconst float delta = mhz - (n * df);\n\t\tif (delta < best_delta) {\n\t\t\tbest_delta = delta;\n\t\t\tbest_dc = *tli;\n\t\t\tif (delta == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!best_dc)\n\t\treturn false;\n\tconst float d = best_dc >> 8;\n\tconst float df = 25. / d;\n\tconst unsigned di = best_dc & 0xff;\n\tunsigned n = (mhz / df) - 1;\n\tif (n > 0x3e) {\n\t\tn = 0x3e;\n\t}\n\tconst uint16_t reg_num = (n << 7) | di;\n\tpk_u16be(out_reg_data, 0, reg_num);\n\treturn true;\n}\n#endif\n\n\nuint8_t crc5usb(unsigned char *ptr, uint8_t len)\n{\n    uint8_t i, j, k;\n    uint8_t crc = 0x1f;\n\t\n    uint8_t crcin[5] = {1, 1, 1, 1, 1};\n    uint8_t crcout[5] = {1, 1, 1, 1, 1};\n    uint8_t din = 0;\n\t\n    j = 0x80;\n    k = 0;\n\t\n    for (i = 0; i < len; i++)\n    {\n    \tif (*ptr & j)\n    \t\tdin = 1;\n    \telse\n    \t\tdin = 0;\n\t\t\n    \tcrcout[0] = crcin[4] ^ din;\n    \tcrcout[1] = crcin[0];\n    \tcrcout[2] = crcin[1] ^ crcin[4] ^ din;\n    \tcrcout[3] = crcin[2];\n    \tcrcout[4] = crcin[3];\n\t\t\n        j = j >> 1;\n        k++;\n        if (k == 8)\n        {\n            j = 0x80;\n            k = 0;\n            ptr++;\n        }\n        memcpy(crcin, crcout, 5);\n    }\n\t\n    crc = 0;\n    if(crcin[4])\n    \tcrc |= 0x10;\n\t\n    if(crcin[3])\n    \tcrc |= 0x08;\n\t\n    if(crcin[2])\n    \tcrc |= 0x04;\n\t\n    if(crcin[1])\n    \tcrc |= 0x02;\n\t\n    if(crcin[0])\n    \tcrc |= 0x01;\n\t\n    return crc;\n}\n\nstatic uint8_t _crc8ccitt_table[0x100];\n\nvoid bfg_init_checksums(void)\n{\n\tfor (int i = 0; i < 0x100; ++i)\n\t{\n\t\tuint8_t crc = i;\n\t\tfor (int j = 0; j < 8; ++j)\n\t\t\tcrc = (crc << 1) ^ ((crc & 0x80) ? 7 : 0);\n\t\t_crc8ccitt_table[i] = crc & 0xff;\n\t}\n}\n\nuint8_t crc8ccitt(const void * const buf, const size_t buflen)\n{\n\tconst uint8_t *p = buf;\n\tuint8_t crc = 0xff;\n\tfor (int i = 0; i < buflen; ++i)\n\t\tcrc = _crc8ccitt_table[crc ^ *p++];\n\treturn crc;\n}\n\nstatic uint16_t crc16tab[] = {\n\t0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n\t0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n\t0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n\t0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n\t0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n\t0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n\t0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n\t0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n\t0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n\t0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n\t0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n\t0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n\t0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n\t0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n\t0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n\t0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n\t0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n\t0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n\t0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n\t0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n\t0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n\t0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n\t0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n\t0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n\t0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n\t0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n\t0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n\t0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n\t0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n\t0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n\t0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n\t0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0,\n};\n\nstatic\nuint16_t crc16_floating(uint16_t next_byte, uint16_t seed)\n{\n\treturn ((seed << 8) ^ crc16tab[(seed >> 8) ^ next_byte]) & 0xFFFF;\n}\n\nuint16_t crc16(const void *p, size_t sz, uint16_t crc)\n{\n\tconst uint8_t * const s = p;\n\tfor (size_t i = 0; i < sz; ++i)\n\t\tcrc = crc16_floating(s[i], crc);\n\treturn crc;\n}\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 21.2392578125,
          "content": "/*\n * Copyright 2013-2015 Luke Dashjr\n * Copyright 2012-2014 Con Kolivas\n * Copyright 2011 Andrew Smith\n * Copyright 2011 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#ifndef BFG_UTIL_H\n#define BFG_UTIL_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/time.h>\n\n#include <curl/curl.h>\n#include <jansson.h>\n\n#include \"compat.h\"\n\n#define INVALID_TIMESTAMP ((time_t)-1)\n\n#if defined(unix) || defined(__APPLE__)\n\t#include <errno.h>\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <netinet/in.h>\n\t#include <arpa/inet.h>\n\n\t#define SOCKETTYPE int\n\t#define SOCKETFAIL(a) ((a) < 0)\n\t#define INVSOCK -1\n\t#define INVINETADDR -1\n\t#define CLOSESOCKET close\n\n\t#define SOCKERR (errno)\n\t#define SOCKERRMSG bfg_strerror(errno, BST_SOCKET)\n\tstatic inline bool sock_blocks(void)\n\t{\n\t\treturn (errno == EAGAIN || errno == EWOULDBLOCK);\n\t}\n\tstatic inline bool interrupted(void)\n\t{\n\t\treturn (errno == EINTR);\n\t}\n#elif defined WIN32\n\t#include <ws2tcpip.h>\n\t#include <winsock2.h>\n\n\t#define SOCKETTYPE SOCKET\n\t#define SOCKETFAIL(a) ((int)(a) == SOCKET_ERROR)\n\t#define INVSOCK INVALID_SOCKET\n\t#define INVINETADDR INADDR_NONE\n\t#define CLOSESOCKET closesocket\n\n\t#define SOCKERR (WSAGetLastError())\n\t#define SOCKERRMSG bfg_strerror(WSAGetLastError(), BST_SOCKET)\n\n\t/* Check for windows variants of the errors as well as when ming\n\t * decides to wrap the error into the errno equivalent. */\n\tstatic inline bool sock_blocks(void)\n\t{\n\t\treturn (WSAGetLastError() == WSAEWOULDBLOCK || errno == EAGAIN);\n\t}\n\tstatic inline bool interrupted(void)\n\t{\n\t\treturn (WSAGetLastError() == WSAEINTR || errno == EINTR);\n\t}\n\t#ifndef SHUT_RDWR\n\t#define SHUT_RDWR SD_BOTH\n\t#endif\n\n\t#ifndef in_addr_t\n\t#define in_addr_t uint32_t\n\t#endif\n#endif\n\n#define IGNORE_RETURN_VALUE(expr)  {if(expr);}(void)0\n\nenum bfg_tristate {\n\tBTS_FALSE = (int)false,\n\tBTS_TRUE  = (int)true,\n\tBTS_UNKNOWN,\n};\n\n#if JANSSON_MAJOR_VERSION >= 2\n#define JSON_LOADS(str, err_ptr) json_loads((str), 0, (err_ptr))\n#else\n#define JSON_LOADS(str, err_ptr) json_loads((str), (err_ptr))\n#endif\nextern char *json_dumps_ANY(json_t *, size_t flags);\n\nstatic inline\nconst char *bfg_json_obj_string(json_t *json, const char *key, const char *fail)\n{\n\tjson = json_object_get(json, key);\n\tif (!json)\n\t\treturn fail;\n\treturn json_string_value(json) ?: fail;\n}\n\nextern const char *__json_array_string(json_t *, unsigned int entry);\n\n#define MAX_STR_UINT(type)  ((sizeof(type) * CHAR_BIT + 2) / 3)\n\n#ifndef min\n#  define min(a, b)  ((a) < (b) ? (a) : (b))\n#endif\n\nextern void *my_memrchr(const void *, int, size_t);\n\nextern bool isCalpha(int);\nstatic inline\nbool isCspace(int c)\n{\n\tswitch (c)\n\t{\n\t\tcase ' ': case '\\f': case '\\n': case '\\r': case '\\t': case '\\v':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nextern bool match_strtok(const char *optlist, const char *delim, const char *needle);\n\ntypedef bool (*appdata_file_callback_t)(const char *, void *);\nextern bool appdata_file_call(const char *appname, const char *filename, appdata_file_callback_t, void *userp);\nextern char *appdata_file_find_first(const char *appname, const char *filename);\n\nextern const char *get_registered_domain(size_t *out_len, const char *, size_t len);\nextern const char *extract_domain(size_t *out_len, const char *uri, size_t urilen);\nextern bool match_domains(const char *a, size_t alen, const char *b, size_t blen);\nextern void test_domain_funcs();\n\nextern bool bfg_strtobool(const char *, char **endptr, int opts);\n\nextern enum bfg_tristate uri_get_param_bool2(const char *ri, const char *param);\nextern bool uri_get_param_bool(const char *uri, const char *param, bool defval);\nextern void test_uri_get_param();\n\n\nenum bfg_gpio_value {\n\tBGV_LOW   =  0,\n\tBGV_HIGH  =  1,\n\tBGV_ERROR = -1,\n};\n\n\ntypedef struct timeval cgtimer_t;\n\nstruct thr_info;\nstruct pool;\nenum dev_reason;\nstruct cgpu_info;\n\n\nextern void set_cloexec_socket(SOCKETTYPE, bool cloexec);\n\nstatic inline\nSOCKETTYPE bfg_socket(const int domain, const int type, const int protocol)\n{\n\tconst bool cloexec = true;\n\tSOCKETTYPE sock;\n#ifdef WIN32\n# ifndef WSA_FLAG_NO_HANDLE_INHERIT\n#  define WSA_FLAG_NO_HANDLE_INHERIT 0x80\n# endif\n\tsock = WSASocket(domain, type, protocol, NULL, 0, WSA_FLAG_OVERLAPPED | ((cloexec) ? WSA_FLAG_NO_HANDLE_INHERIT : 0));\n\tif (sock == INVSOCK)\n#endif\n\tsock = socket(domain, type, protocol);\n\tif (sock == INVSOCK)\n\t\treturn INVSOCK;\n\tset_cloexec_socket(sock, cloexec);\n\treturn sock;\n}\n\n\nextern void json_rpc_call_async(CURL *, const char *url, const char *userpass, const char *rpc_req, bool longpoll, struct pool *pool, bool share, void *priv);\nextern json_t *json_rpc_call_completed(CURL *, int rc, bool probe, int *rolltime, void *out_priv);\n\nextern char *absolute_uri(char *uri, const char *ref);  // ref must be a root URI\n\nextern size_t ucs2_to_utf8(char *out, const uint16_t *in, size_t sz);\nextern char *ucs2_to_utf8_dup(uint16_t *in, size_t sz);\n\n#define BFGINIT(var, val)  do{  \\\n\tif (!(var))       \\\n\t\t(var) = val;  \\\n}while(0)\n\nextern void gen_hash(unsigned char *data, unsigned char *hash, int len);\nextern void real_block_target(unsigned char *target, const unsigned char *data);\nextern bool hash_target_check(const unsigned char *hash, const unsigned char *target);\nextern bool hash_target_check_v(const unsigned char *hash, const unsigned char *target);\n\nint thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg);\nvoid thr_info_freeze(struct thr_info *thr);\nvoid thr_info_cancel(struct thr_info *thr);\nvoid subtime(struct timeval *a, struct timeval *b);\nvoid addtime(struct timeval *a, struct timeval *b);\nbool time_more(struct timeval *a, struct timeval *b);\nbool time_less(struct timeval *a, struct timeval *b);\nvoid copy_time(struct timeval *dest, const struct timeval *src);\nvoid timespec_to_val(struct timeval *val, const struct timespec *spec);\nvoid timeval_to_spec(struct timespec *spec, const struct timeval *val);\nvoid us_to_timeval(struct timeval *val, int64_t us);\nvoid us_to_timespec(struct timespec *spec, int64_t us);\nvoid ms_to_timespec(struct timespec *spec, int64_t ms);\nvoid timeraddspec(struct timespec *a, const struct timespec *b);\nvoid cgsleep_ms(int ms);\nvoid cgsleep_us(int64_t us);\n#define cgtimer_time(ts_start) timer_set_now(ts_start)\n#define cgsleep_prepare_r(ts_start) cgtimer_time(ts_start)\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms);\nextern void (*cgsleep_us_r)(cgtimer_t *ts_start, int64_t us);\n\nstatic inline\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn (cgt->tv_sec * 1000) + (cgt->tv_usec / 1000);\n}\n\nextern int bfg_cond_timedwait(pthread_cond_t * restrict, pthread_mutex_t * restrict, const struct timeval *);\nextern pthread_condattr_t *bfg_condattr_();\n#define bfg_condattr (bfg_condattr_())\n\n#define cgtimer_sub(a, b, res)  timersub(a, b, res)\ndouble us_tdiff(struct timeval *end, struct timeval *start);\ndouble tdiff(struct timeval *end, struct timeval *start);\nbool _stratum_send(struct pool *pool, char *s, ssize_t len, bool force);\n#define stratum_send(pool, s, len)  _stratum_send(pool, s, len, false)\nbool sock_full(struct pool *pool);\nchar *recv_line(struct pool *pool);\nbool parse_method(struct pool *pool, char *s);\nbool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port);\nbool auth_stratum(struct pool *pool);\nbool initiate_stratum(struct pool *pool);\nbool restart_stratum(struct pool *pool);\nvoid suspend_stratum(struct pool *pool);\nextern void dev_error_update(struct cgpu_info *, enum dev_reason);\nvoid dev_error(struct cgpu_info *dev, enum dev_reason reason);\nvoid *realloc_strcat(char *ptr, char *s);\nextern char *sanestr(char *o, char *s);\nvoid RenameThread(const char* name);\n\nenum bfg_strerror_type {\n\tBST_ERRNO,\n\tBST_SOCKET,\n\tBST_LIBUSB,\n\tBST_SYSTEM,\n};\nextern const char *bfg_strerror(int, enum bfg_strerror_type);\n\nextern void *bfg_slurp_file(void *buf, size_t bufsz, const char *filename);\n\ntypedef SOCKETTYPE notifier_t[2];\nextern void notifier_init(notifier_t);\nextern void notifier_wake(notifier_t);\nextern void notifier_read(notifier_t);\nextern bool notifier_wait(notifier_t, const struct timeval *);\nextern bool notifier_wait_us(notifier_t, unsigned long long usecs);\nextern void notifier_reset(notifier_t);\nextern void notifier_init_invalid(notifier_t);\nextern void notifier_destroy(notifier_t);\n\n/* Align a size_t to 4 byte boundaries for fussy arches */\nstatic inline void align_len(size_t *len)\n{\n\tif (*len % 4)\n\t\t*len += 4 - (*len % 4);\n}\n\n\nstatic inline\nuint8_t bitflip8(uint8_t p)\n{\n\tp = ((p & 0xaa) >> 1) | ((p & 0x55) << 1);\n\tp = ((p & 0xcc) >> 2) | ((p & 0x33) << 2);\n\tp = ((p & 0xf0) >> 4) | ((p & 0x0f) << 4);\n\treturn p;\n}\n\nstatic inline\nuint8_t upk_u8(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn buf[offset];\n}\n\n#define upk_u8be(buf, offset)  upk_u8(buf, offset)\n\nstatic inline\nuint16_t upk_u16be(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint16_t)buf[offset+0]) <<    8)\n\t     | (((uint16_t)buf[offset+1]) <<    0);\n}\n\nstatic inline\nuint32_t upk_u32be(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint32_t)buf[offset+0]) << 0x18)\n\t     | (((uint32_t)buf[offset+1]) << 0x10)\n\t     | (((uint32_t)buf[offset+2]) <<    8)\n\t     | (((uint32_t)buf[offset+3]) <<    0);\n}\n\nstatic inline\nuint64_t upk_u64be(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint64_t)buf[offset+0]) << 0x38)\n\t     | (((uint64_t)buf[offset+1]) << 0x30)\n\t     | (((uint64_t)buf[offset+2]) << 0x28)\n\t     | (((uint64_t)buf[offset+3]) << 0x20)\n\t     | (((uint64_t)buf[offset+4]) << 0x18)\n\t     | (((uint64_t)buf[offset+5]) << 0x10)\n\t     | (((uint64_t)buf[offset+6]) <<    8)\n\t     | (((uint64_t)buf[offset+7]) <<    0);\n}\n\n#define upk_u8le(buf, offset)  upk_u8(buf, offset)\n\nstatic inline\nuint16_t upk_u16le(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint16_t)buf[offset+0]) <<    0)\n\t     | (((uint16_t)buf[offset+1]) <<    8);\n}\n\nstatic inline\nuint32_t upk_u32le(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint32_t)buf[offset+0]) <<    0)\n\t     | (((uint32_t)buf[offset+1]) <<    8)\n\t     | (((uint32_t)buf[offset+2]) << 0x10)\n\t     | (((uint32_t)buf[offset+3]) << 0x18);\n}\n\nstatic inline\nuint64_t upk_u64le(const void * const bufp, const int offset)\n{\n\tconst uint8_t * const buf = bufp;\n\treturn (((uint64_t)buf[offset+0]) <<    0)\n\t     | (((uint64_t)buf[offset+1]) <<    8)\n\t     | (((uint64_t)buf[offset+2]) << 0x10)\n\t     | (((uint64_t)buf[offset+3]) << 0x18)\n\t     | (((uint64_t)buf[offset+4]) << 0x20)\n\t     | (((uint64_t)buf[offset+5]) << 0x28)\n\t     | (((uint64_t)buf[offset+6]) << 0x30)\n\t     | (((uint64_t)buf[offset+7]) << 0x38);\n}\n\n\nstatic inline\nvoid pk_u8(void * const bufp, const int offset, const uint8_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset] = nv;\n}\n\n#define pk_u8be(buf, offset, nv)  pk_u8(buf, offset, nv)\n\nstatic inline\nvoid pk_u16be(void * const bufp, const int offset, const uint16_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >>    8) & 0xff;\n\tbuf[offset+1] = (nv >>    0) & 0xff;\n}\n\nstatic inline\nvoid pk_u32be(void * const bufp, const int offset, const uint32_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >> 0x18) & 0xff;\n\tbuf[offset+1] = (nv >> 0x10) & 0xff;\n\tbuf[offset+2] = (nv >>    8) & 0xff;\n\tbuf[offset+3] = (nv >>    0) & 0xff;\n}\n\nstatic inline\nvoid pk_u64be(void * const bufp, const int offset, const uint64_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >> 0x38) & 0xff;\n\tbuf[offset+1] = (nv >> 0x30) & 0xff;\n\tbuf[offset+2] = (nv >> 0x28) & 0xff;\n\tbuf[offset+3] = (nv >> 0x20) & 0xff;\n\tbuf[offset+4] = (nv >> 0x18) & 0xff;\n\tbuf[offset+5] = (nv >> 0x10) & 0xff;\n\tbuf[offset+6] = (nv >>    8) & 0xff;\n\tbuf[offset+7] = (nv >>    0) & 0xff;\n}\n\n#define pk_u8le(buf, offset, nv)  pk_u8(buf, offset, nv)\n\nstatic inline\nvoid pk_u16le(void * const bufp, const int offset, const uint16_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >>    0) & 0xff;\n\tbuf[offset+1] = (nv >>    8) & 0xff;\n}\n\nstatic inline\nvoid pk_u32le(void * const bufp, const int offset, const uint32_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >>    0) & 0xff;\n\tbuf[offset+1] = (nv >>    8) & 0xff;\n\tbuf[offset+2] = (nv >> 0x10) & 0xff;\n\tbuf[offset+3] = (nv >> 0x18) & 0xff;\n}\n\nstatic inline\nvoid pk_u64le(void * const bufp, const int offset, const uint64_t nv)\n{\n\tuint8_t * const buf = bufp;\n\tbuf[offset+0] = (nv >>    0) & 0xff;\n\tbuf[offset+1] = (nv >>    8) & 0xff;\n\tbuf[offset+2] = (nv >> 0x10) & 0xff;\n\tbuf[offset+3] = (nv >> 0x18) & 0xff;\n\tbuf[offset+4] = (nv >> 0x20) & 0xff;\n\tbuf[offset+5] = (nv >> 0x28) & 0xff;\n\tbuf[offset+6] = (nv >> 0x30) & 0xff;\n\tbuf[offset+7] = (nv >> 0x38) & 0xff;\n}\n\n#define _pk_uNle(bitwidth, newvalue)  do{  \\\n\tuint ## bitwidth ## _t _mask = 1;  \\\n\t_mask <<= _bitlen;  \\\n\t--_mask;  \\\n\tuint ## bitwidth ## _t _filt = _mask;  \\\n\t_filt <<= _bitoff;  \\\n\t_filt = ~_filt;  \\\n\tuint ## bitwidth ## _t _u = upk_u ## bitwidth ## le(_buf, 0);  \\\n\t_u = (_u & _filt) | (((newvalue) & _mask) << _bitoff);  \\\n\tpk_u ## bitwidth ## le(_buf, 0, _u);  \\\n}while(0)\n\n#define pk_uNle(bufp, offset, bitoffset, bitlength, newvalue)  do{  \\\n\tuint8_t * const _buf = &((uint8_t *)(bufp))[offset];  \\\n\tconst int _bitoff = (bitoffset), _bitlen = bitlength;  \\\n\tconst int _bittot = bitoffset + bitlength;  \\\n\t_Static_assert((bitoffset + bitlength) <= 0x40, \"Too many bits addressed in pk_uNle (bitoffset + bitlength must be <= 64)\");  \\\n\tif (_bittot <=    8)  \\\n\t\t_pk_uNle( 8, newvalue);  \\\n\telse  \\\n\tif (_bittot <= 0x10)  \\\n\t\t_pk_uNle(16, newvalue);  \\\n\telse  \\\n\tif (_bittot <= 0x20)  \\\n\t\t_pk_uNle(32, newvalue);  \\\n\telse  \\\n\t\t_pk_uNle(64, newvalue);  \\\n}while(0)\n\n#define is_power_of_two(n)  \\\n\t(0 == ((n) & ((n) - 1)))\n\nstatic inline\nuint32_t upper_power_of_two_u32(uint32_t n)\n{\n\t--n;\n\tfor (int i = 1; i <= 0x10; i *= 2)\n\t\tn |= n >> i;\n\t++n;\n\treturn n;\n}\n\n\ntypedef struct bytes_t {\n\tuint8_t *buf;\n\tsize_t sz;\n\tsize_t allocsz;\n} bytes_t;\n\n#define BYTES_INIT {.buf=NULL,}\n\nstatic inline\nvoid bytes_init(bytes_t *b)\n{\n\t*b = (bytes_t)BYTES_INIT;\n}\n\n// This can't be inline without ugly const/non-const issues\n#define bytes_buf(b)  ((b)->buf)\n\nstatic inline\nsize_t bytes_len(const bytes_t *b)\n{\n\treturn b->sz;\n}\n\nstatic inline\nssize_t bytes_find(const bytes_t * const b, const uint8_t needle)\n{\n\tconst size_t blen = bytes_len(b);\n\tconst uint8_t * const buf = bytes_buf(b);\n\tfor (int i = 0; i < blen; ++i)\n\t\tif (buf[i] == needle)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic inline\nbool bytes_eq(const bytes_t * const a, const bytes_t * const b)\n{\n\tif (a->sz != b->sz)\n\t\treturn false;\n\treturn !memcmp(a->buf, b->buf, a->sz);\n}\n\nextern void _bytes_alloc_failure(size_t);\n\nstatic inline\nvoid bytes_extend_buf(bytes_t * const b, const size_t newsz)\n{\n\tif (newsz <= b->allocsz)\n\t\treturn;\n\t\n\tif (!b->allocsz)\n\t\tb->allocsz = 0x10;\n\tdo {\n\t\tb->allocsz *= 2;\n\t} while (newsz > b->allocsz);\n\tb->buf = realloc(b->buf, b->allocsz);\n\tif (!b->buf)\n\t\t_bytes_alloc_failure(b->allocsz);\n}\n\nstatic inline\nvoid bytes_resize(bytes_t * const b, const size_t newsz)\n{\n\tbytes_extend_buf(b, newsz);\n\tb->sz = newsz;\n}\n\nstatic inline\nvoid *bytes_preappend(bytes_t * const b, const size_t addsz)\n{\n\tsize_t origsz = bytes_len(b);\n\tbytes_extend_buf(b, origsz + addsz);\n\treturn &bytes_buf(b)[origsz];\n}\n\nstatic inline\nvoid bytes_postappend(bytes_t * const b, const size_t addsz)\n{\n\tsize_t origsz = bytes_len(b);\n\tbytes_resize(b, origsz + addsz);\n}\n\nstatic inline\nvoid bytes_append(bytes_t * const b, const void * const add, const size_t addsz)\n{\n\tvoid * const appendbuf = bytes_preappend(b, addsz);\n\tmemcpy(appendbuf, add, addsz);\n\tbytes_postappend(b, addsz);\n}\n\nstatic inline\nvoid bytes_cat(bytes_t *b, const bytes_t *cat)\n{\n\tbytes_append(b, bytes_buf(cat), bytes_len(cat));\n}\n\nstatic inline\nvoid bytes_cpy(bytes_t *dst, const bytes_t *src)\n{\n\tdst->sz = src->sz;\n\tif (!dst->sz) {\n\t\tdst->allocsz = 0;\n\t\tdst->buf = NULL;\n\t\treturn;\n\t}\n\tdst->allocsz = src->allocsz;\n\tsize_t half;\n\twhile (dst->sz <= (half = dst->allocsz / 2))\n\t\tdst->allocsz = half;\n\tdst->buf = malloc(dst->allocsz);\n\tmemcpy(dst->buf, src->buf, dst->sz);\n}\n\n// Efficiently moves the data from src to dst, emptying src in the process\nstatic inline\nvoid bytes_assimilate(bytes_t * const dst, bytes_t * const src)\n{\n\tvoid * const buf = dst->buf;\n\tconst size_t allocsz = dst->allocsz;\n\t*dst = *src;\n\t*src = (bytes_t){\n\t\t.buf = buf,\n\t\t.allocsz = allocsz,\n\t};\n}\n\nstatic inline\nvoid bytes_assimilate_raw(bytes_t * const b, void * const buf, const size_t bufsz, const size_t buflen)\n{\n\tfree(b->buf);\n\tb->buf = buf;\n\tb->allocsz = bufsz;\n\tb->sz = buflen;\n}\n\nstatic inline\nvoid bytes_shift(bytes_t *b, size_t shift)\n{\n\tif (shift >= b->sz)\n\t{\n\t\tb->sz = 0;\n\t\treturn;\n\t}\n\tb->sz -= shift;\n\tmemmove(bytes_buf(b), &bytes_buf(b)[shift], bytes_len(b));\n}\n\nstatic inline\nvoid bytes_reset(bytes_t *b)\n{\n\tb->sz = 0;\n}\n\nstatic inline\nvoid bytes_nullterminate(bytes_t *b)\n{\n\tbytes_append(b, \"\", 1);\n\t--b->sz;\n}\n\nstatic inline\nvoid bytes_free(bytes_t *b)\n{\n\tfree(b->buf);\n\tbytes_init(b);\n}\n\n\nstatic inline\nvoid set_maxfd(int *p_maxfd, int fd)\n{\n\tif (fd > *p_maxfd)\n\t\t*p_maxfd = fd;\n}\n\n\nstatic inline\nvoid timer_unset(struct timeval *tvp)\n{\n\ttvp->tv_sec = -1;\n}\n\nstatic inline\nbool timer_isset(const struct timeval *tvp)\n{\n\treturn tvp->tv_sec != -1;\n}\n\nextern void (*timer_set_now)(struct timeval *);\n#define cgtime(tvp)  timer_set_now(tvp)\n\n#define TIMEVAL_USECS(usecs)  (  \\\n\t(struct timeval){  \\\n\t\t.tv_sec = (usecs) / 1000000,  \\\n\t\t.tv_usec = (usecs) % 1000000,  \\\n\t}  \\\n)\n\nstatic inline\nlong timeval_to_us(const struct timeval *tvp)\n{\n\treturn ((long)tvp->tv_sec * 1000000) + tvp->tv_usec;\n}\n\n#define timer_set_delay(tvp_timer, tvp_now, usecs)  do {  \\\n\tstruct timeval tv_add = TIMEVAL_USECS(usecs);  \\\n\ttimeradd(&tv_add, tvp_now, tvp_timer);  \\\n} while(0)\n\n#define timer_set_delay_from_now(tvp_timer, usecs)  do {  \\\n\tstruct timeval tv_now;  \\\n\ttimer_set_now(&tv_now);  \\\n\ttimer_set_delay(tvp_timer, &tv_now, usecs);  \\\n} while(0)\n\nstatic inline\nconst struct timeval *_bfg_nullisnow(const struct timeval *tvp, struct timeval *tvp_buf)\n{\n\tif (tvp)\n\t\treturn tvp;\n\tcgtime(tvp_buf);\n\treturn tvp_buf;\n}\n\nstatic inline\nlong timer_elapsed_us(const struct timeval *tvp_timer, const struct timeval *tvp_now)\n{\n\tstruct timeval tv;\n\tconst struct timeval *_tvp_now = _bfg_nullisnow(tvp_now, &tv);\n\ttimersub(_tvp_now, tvp_timer, &tv);\n\treturn timeval_to_us(&tv);\n}\n\n#define ms_tdiff(end, start)  (timer_elapsed_us(start, end) / 1000)\n\nstatic inline\nint timer_elapsed(const struct timeval *tvp_timer, const struct timeval *tvp_now)\n{\n\tstruct timeval tv;\n\tconst struct timeval *_tvp_now = _bfg_nullisnow(tvp_now, &tv);\n\ttimersub(_tvp_now, tvp_timer, &tv);\n\treturn tv.tv_sec;\n}\n\nstatic inline\nlong timer_remaining_us(const struct timeval *tvp_timer, const struct timeval *tvp_now)\n{\n\tstruct timeval tv;\n\tconst struct timeval *_tvp_now = _bfg_nullisnow(tvp_now, &tv);\n\ttimersub(tvp_timer, _tvp_now, &tv);\n\treturn timeval_to_us(&tv);\n}\n\nstatic inline\nbool timer_passed(const struct timeval *tvp_timer, const struct timeval *tvp_now)\n{\n\tif (!timer_isset(tvp_timer))\n\t\treturn false;\n\t\n\tstruct timeval tv;\n\tconst struct timeval *_tvp_now = _bfg_nullisnow(tvp_now, &tv);\n\t\n\treturn timercmp(tvp_timer, _tvp_now, <);\n}\n\n#if defined(WIN32) && !defined(HAVE_POOR_GETTIMEOFDAY)\n#define HAVE_POOR_GETTIMEOFDAY\n#endif\n\n#ifdef HAVE_POOR_GETTIMEOFDAY\nextern void bfg_gettimeofday(struct timeval *);\n#else\n#define bfg_gettimeofday(out)  gettimeofday(out, NULL)\n#endif\n\nstatic inline\nvoid reduce_timeout_to(struct timeval *tvp_timeout, struct timeval *tvp_time)\n{\n\tif (!timer_isset(tvp_time))\n\t\treturn;\n\tif ((!timer_isset(tvp_timeout)) || timercmp(tvp_time, tvp_timeout, <))\n\t\t*tvp_timeout = *tvp_time;\n}\n\nstatic inline\nstruct timeval *select_timeout(struct timeval *tvp_timeout, struct timeval *tvp_now)\n{\n\tif (!timer_isset(tvp_timeout))\n\t\treturn NULL;\n\t\n\tif (timercmp(tvp_timeout, tvp_now, <))\n\t\ttimerclear(tvp_timeout);\n\telse\n\t\ttimersub(tvp_timeout, tvp_now, tvp_timeout);\n\t\n\treturn tvp_timeout;\n}\n\n\n#define _SNP2(fn, ...)  do{  \\\n        int __n42 = fn(s, sz, __VA_ARGS__);  \\\n        s += __n42;  \\\n        sz = (sz <= __n42) ? 0 : (sz - __n42);  \\\n        rv += __n42;  \\\n}while(0)\n\n#define _SNP(...)  _SNP2(snprintf, __VA_ARGS__)\n\n\nextern int double_find_precision(double, double base);\n\n\n#define REPLACEMENT_CHAR (0xFFFD)\n#define U8_DEGREE \"\\xc2\\xb0\"\n#define U8_MICRO  \"\\xc2\\xb5\"\n#define U8_HLINE  \"\\xe2\\x94\\x80\"\n#define U8_BTEE   \"\\xe2\\x94\\xb4\"\nextern int utf8_len(uint8_t);\nextern int32_t utf8_decode(const void *, int *out_len);\nextern size_t utf8_strlen(const void *);\nextern void utf8_test();\n\n\n\n#define RUNONCE(rv)  do {  \\\n\tstatic bool _runonce = false;  \\\n\tif (_runonce)  \\\n\t\treturn rv;  \\\n\t_runonce = true;  \\\n} while(0)\n\n\nstatic inline\nchar *maybe_strdup(const char *s)\n{\n\treturn s ? strdup(s) : NULL;\n}\n\nstatic inline\nvoid maybe_strdup_if_null(const char **p, const char *s)\n{\n\tif (!*p)\n\t\t*p = maybe_strdup(s);\n}\n\nextern char *trimmed_strdup(const char *);\n\n\nextern void run_cmd(const char *cmd);\n\n\nextern bool bm1382_freq_to_reg_data(uint8_t *out_reg_data, float mhz);\n\n\nextern uint8_t crc5usb(unsigned char *ptr, uint8_t len);\nextern void bfg_init_checksums(void);\nextern uint8_t crc8ccitt(const void *, size_t);\n\nextern uint16_t crc16(const void *, size_t, uint16_t init);\n#define crc16ffff(  DATA, SZ)  crc16(DATA, SZ, 0xffff)\n#define crc16xmodem(DATA, SZ)  crc16(DATA, SZ, 0)\n\n#endif /* __UTIL_H__ */\n"
        },
        {
          "name": "version.c",
          "type": "blob",
          "size": 0.529296875,
          "content": "/*\n * Copyright 2014 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include \"version.h\"\n\nconst char * const bfgminer_name_space_ver = PACKAGE \" \" VERSION;\nconst char * const bfgminer_name_slash_ver = PACKAGE \"/\" VERSION;\nconst char * const bfgminer_ver = VERSION;\n"
        },
        {
          "name": "warn-on-use.h",
          "type": "blob",
          "size": 5.013671875,
          "content": "/* A C macro for emitting warnings if a function is used.\n   Copyright (C) 2010-2011 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published\n   by the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* _GL_WARN_ON_USE (function, \"literal string\") issues a declaration\n   for FUNCTION which will then trigger a compiler warning containing\n   the text of \"literal string\" anywhere that function is called, if\n   supported by the compiler.  If the compiler does not support this\n   feature, the macro expands to an unused extern declaration.\n\n   This macro is useful for marking a function as a potential\n   portability trap, with the intent that \"literal string\" include\n   instructions on the replacement function that should be used\n   instead.  However, one of the reasons that a function is a\n   portability trap is if it has the wrong signature.  Declaring\n   FUNCTION with a different signature in C is a compilation error, so\n   this macro must use the same type as any existing declaration so\n   that programs that avoid the problematic FUNCTION do not fail to\n   compile merely because they included a header that poisoned the\n   function.  But this implies that _GL_WARN_ON_USE is only safe to\n   use if FUNCTION is known to already have a declaration.  Use of\n   this macro implies that there must not be any other macro hiding\n   the declaration of FUNCTION; but undefining FUNCTION first is part\n   of the poisoning process anyway (although for symbols that are\n   provided only via a macro, the result is a compilation error rather\n   than a warning containing \"literal string\").  Also note that in\n   C++, it is only safe to use if FUNCTION has no overloads.\n\n   For an example, it is possible to poison 'getline' by:\n   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],\n     [getline]) in configure.ac, which potentially defines\n     HAVE_RAW_DECL_GETLINE\n   - adding this code to a header that wraps the system <stdio.h>:\n     #undef getline\n     #if HAVE_RAW_DECL_GETLINE\n     _GL_WARN_ON_USE (getline, \"getline is required by POSIX 2008, but\"\n       \"not universally present; use the gnulib module getline\");\n     #endif\n\n   It is not possible to directly poison global variables.  But it is\n   possible to write a wrapper accessor function, and poison that\n   (less common usage, like &environ, will cause a compilation error\n   rather than issue the nice warning, but the end result of informing\n   the developer about their portability problem is still achieved):\n   #if HAVE_RAW_DECL_ENVIRON\n   static inline char ***rpl_environ (void) { return &environ; }\n   _GL_WARN_ON_USE (rpl_environ, \"environ is not always properly declared\");\n   # undef environ\n   # define environ (*rpl_environ ())\n   #endif\n   */\n#ifndef _GL_WARN_ON_USE\n\n# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)\n/* A compiler attribute is available in gcc versions 4.3.0 and later.  */\n#  define _GL_WARN_ON_USE(function, message) \\\nextern __typeof__ (function) function __attribute__ ((__warning__ (message)))\n# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING\n/* Verify the existence of the function.  */\n#  define _GL_WARN_ON_USE(function, message) \\\nextern __typeof__ (function) function\n# else /* Unsupported.  */\n#  define _GL_WARN_ON_USE(function, message) \\\n_GL_WARN_EXTERN_C int _gl_warn_on_use\n# endif\n#endif\n\n/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, \"string\")\n   is like _GL_WARN_ON_USE (function, \"string\"), except that the function is\n   declared with the given prototype, consisting of return type, parameters,\n   and attributes.\n   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does\n   not work in this case.  */\n#ifndef _GL_WARN_ON_USE_CXX\n# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)\n#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \\\nextern rettype function parameters_and_attributes \\\n     __attribute__ ((__warning__ (msg)))\n# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING\n/* Verify the existence of the function.  */\n#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \\\nextern rettype function parameters_and_attributes\n# else /* Unsupported.  */\n#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \\\n_GL_WARN_EXTERN_C int _gl_warn_on_use\n# endif\n#endif\n\n/* _GL_WARN_EXTERN_C declaration;\n   performs the declaration with C linkage.  */\n#ifndef _GL_WARN_EXTERN_C\n# if defined __cplusplus\n#  define _GL_WARN_EXTERN_C extern \"C\"\n# else\n#  define _GL_WARN_EXTERN_C extern\n# endif\n#endif\n"
        },
        {
          "name": "windows-build.txt",
          "type": "blob",
          "size": 7.453125,
          "content": "*******************\n** Install MinGW **\n*******************\n\n1.  Go to https://sourceforge.net/downloads/mingw\n2.  Download and execute mingw-get-setup.exe\n3.  Complete the installation wizard leaving default values\n\n*********************\n** Configure MinGW **\n*********************\n\n1.  Launch the MinGW Installation Manager\n2.  Select Basic Setup on the left\n3.  Mark the following packages for installation: mingw-developer-toolkit, mingw32-base, mingw-gcc-g++, and msys-base\n4.  Select All Packages on the left\n5.  Mark the following packages for installation: mingw32-pthreads-w32 (dev), mingw32-libpdcurses (dev), mingw32-pdcurses (bin), msys-libopenssl (dev)\n6.  Click Installation > Apply Changes\n7.  Click Apply\n8.  Wait...\n9.  Click Close\n10. Close MinGW Installation Manager\n\n************************\n** MinGW Post-Install **\n************************\n\n1.  Check your Start menu for “MinGW Shell”\n2.  If the shortcut exists, continue to the next section, otherwise:\n3.  Navigate to C:\\MinGW\\msys\\1.0\\postinstall\n4.  Run pi.bat & answer the questions\n5.  Navigate to C:\\MinGW\\msys\\1.0\n6.  Right-click msys.bat and click Copy \n7.  Click the Start button\n8.  Right-click All Programs and click Open\n9.  Right-click on the opened folder and click “Paste shortcut”\n10. Right-click the new shortcut and click Properties\n11. On the General tab, rename the shortcut to “MinGW Shell”\n12. On the Shortcut tab, change Start in to C:\\MinGW\\msys\\1.0\\bin\n13. Click OK\n\n******************************************\n** Install YASM (optional - CPU mining) **\n******************************************\n\n1.  Visit http://yasm.tortall.net/Download.html\n2.  Download the Win32 or Win64 .exe, depending on your version of Windows\n3.  Rename the downloaded executable to yasm.exe\n4.  Copy the executable to C:\\MinGW\\bin\n\n********************\n** Install uthash **\n********************\n\n1.  Visit http://troydhanson.github.io/uthash/\n2.  Download the uthash-master.zip file\n3.  Extract the contents of the uthash-master/src folder into C:\\MinGW\\include\n\n******************************\n** Install GTK+ for Windows **\n******************************\n\n1.  Visit http://sourceforge.net/projects/gtk-win/\n2.  Download and execute the gtk2-runtime installer\n3.  Complete the installation wizard leaving default values\n4.  Copy libglib-2.0-0.dll from C:\\Program Files\\GTK2-Runtime\\bin to C:\\MinGW\\bin\n\n************************\n** Install pkg-config **\n************************\n\n1.  Visit http://www.gtk.org/download/win32.php\n2.  Search for a version of pkg-config that includes both the Tool and Dev downloads\n3.  Click and download both the Tool link and the Dev link\n4.  Open the pkg-config zip file and extract the bin folder to C:\\MinGW\n5.  Open the pkg-config-dev zip file and extract the share folder to C:\\MinGW\n\n*********************\n** Install libcurl **\n*********************\n\n1.  Visit http://curl.haxx.se/download.html#Win32\n2.  Look for the Win32 - Generic heading\n3.  Download the link that indicates both *libcurl* (not just binary) and *SSL*\n4.  Open the zip file and extract the lib, include, and bin folders to C:\\MinGW\n5.  Edit C:\\MinGW\\lib\\pkgconfig\\libcurl.pc\n6.  Change \"-lcurl\" to \"-lcurl -lcurldll\"\n\n************************\n** Install libjansson **\n************************\n\n1.  Visit http://www.digip.org/jansson/releases/\n2.  Download the latest .tar.gz file (not doc.tar.gz)\n3.  Open the .tar.gz file and extract the jansson folder to C:\\MinGW\\msys\\1.0\\home\\USER (where USER is your user name)\n4.  Click Start and launch MinGW Shell\n5.  Type the following (replace X.X with actual version):\n\n\tcd ~/jansson-X.X\n\t./configure --prefix=/MinGW\n\tmake\n\tmake check\n\tmake install\n\n********************\n** Install libusb **\n********************\n\n1.  Visit http://git.libusb.org/?p=libusb.git;a=snapshot;h=master;sf=zip\n2.  Download and open the resulting zip file\n3.  Extract the libusb-master folder to C:\\MinGW\\msys\\1.0\\home\\USER\n4.  Return to the MinGW Shell\n5.  Type the following (replace XYZ with actual identifier):\n\n\tcd ~/libusb-master-XYZ\n\t./autogen.sh --disable-debug-log --prefix=/MinGW\n\tmake\n\tmake install \n\n******************************************************\n** Install libmicrohttpd (optional - Stratum Proxy) **\n******************************************************\n\n1.  Visit http://ftp.gnu.org/gnu/libmicrohttpd/\n2.  Download the latest w32.zip file\n3.  Open the zip file and extract the share, lib, include, and bin folders to C:\\MinGW\n\n*************************************************\n** Install libevent (optional - Stratum Proxy) **\n*************************************************\n\n1.  Visit http://libevent.org/\n2.  Download the latest stable.tar.gz file\n3.  Open the .tar.gz file and extract the libevent-X.Y.Z-stable folder to C:\\MinGW\\msys\\1.0\\home\\USER\n4.  Return to the MinGW Shell\n5.  Type the following (replace X.Y.Z with actual version):\n\n\tcd ~/libevent-X.Y.Z-stable\n\t./configure --disable-openssl --prefix=/MinGW\n\tmake\n\tmake install\n\n*******************************************************\n** Install HIDAPI (optional - Hashbuster & Nanofury) **\n*******************************************************\n\n1.  Visit https://github.com/signal11/hidapi\n2.  Click Releases and download the latest zip file\n3.  Open the zip file and extract the hidapi-hidapi folder to C:\\MinGW\\msys\\1.0\\home\\USER\n4.  Return to the MinGW Shell\n5.  Type the following (replace X.Y.Z with actual version):\n\n\tcd ~/hidapi-hidapi-X.Y.Z\n\t./bootstrap\n\t./configure --prefix=/MinGW\n\tmake\n\tmake install\n\n*****************\n** Install Git **\n*****************\n\n1.  Visit http://git-scm.com/downloads\n2.  Click the Download for Windows\n3.  Run the resulting installer once downloaded\n4.  Complete the installation wizard leaving default values\n\n****************************\n** Configure Git in MinGW **\n****************************\n\n1.  Navigate to C:\\MinGW\\msys\\1.0\\home\\USER\n2.  Create a new text file with Notepad called profile.txt with the contents:\n\nPATH=$PATH:/c/Program\\ Files/Git/bin\n\n3.  Return to the MinGW Shell\n4.  Type the following:\n\n\tmv ~/profile.txt ~/.profile\n\n5.  Restart the MinGW Shell\n\n******************\n** OS Header(s) **\n******************\n\n1.  Navigate to C:\\MinGW\\include\n2.  Use Notepad to create a new file called mstcpip.h (not .txt) with the contents:\n\nstruct tcp_keepalive\n{\n    u_long onoff;\n    u_long keepalivetime;\n    u_long keepaliveinterval;\n};\n\n#ifndef USE_WS_PREFIX\n\n#define SIO_KEEPALIVE_VALS    _WSAIOW(IOC_VENDOR, 4)\n\n#else\n\n#define WS_SIO_KEEPALIVE_VALS    _WSAIOW(WS_IOC_VENDOR, 4)\n\n#endif\n\n**********************\n** Compile bfgminer **\n**********************\n\n1.  Return to the MinGW Shell\n2.  Type the following:\n\n\tcd ~/\n\tgit clone git://github.com/luke-jr/bfgminer.git\n\tcd bfgminer/\n\t./autogen.sh\n\t./configure\n\tmake\n\n* Note: see the README for bfgminer ./configure options\n\n**********************\n** Package Binaries **\n**********************\n\nCreate a new folder anywhere and copy the following items there:\n\nC:\\MinGW\\msys\\1.0\\home\\USER\\bfgminer\n\n\tbfgminer.exe\n\tbfgminer-rpc.exe\n\tCOPYING\n\tLICENSE \n\tREADME*\n\nC:\\MinGW\\msys\\1.0\\home\\USER\\bfgminer\\opencl\n\n\t*.cl\n\nC:\\MinGW\\msys\\1.0\\home\\USER\\bfgminer\\libbase58\\.libs\n\n\tlibbase58-0.dll\n\nC:\\MinGW\\msys\\1.0\\home\\USER\\bfgminer\\libblkmaker\\.libs  \n\n\tlibblkmaker-0.1-6.dll\n\tlibblkmaker_jansson-0.1-6.dll\n\nC:\\MinGW\\bin\n\n\tlibcurl.dll\n\tlibjansson-4.dll\n\tlibmicrohttpd-10.dll\n\tlibpdcursesw.dll\n\tpthreadGC2.dll\n\tlibusb-1.0.dll\n\tlibidn-11.dll\n\tlibeay32.dll\n\tssleay32.dll\n\tlibgcc_s_dw2-1.dll\n\tlibgnutls-28.dll\n\tlibgcrypt-11.dll\n\tlibplibc-1.dll\n\tlibgmp.dll\n\tlibintl-8.dll\n\tlibgpg-error-0.dll\n\tlibiconv-2.dll\n\tlibevent-2-0-5.dll\n\tzlib1.dll\n\n"
        },
        {
          "name": "winhacks.h",
          "type": "blob",
          "size": 0.3427734375,
          "content": "#ifndef BFG_WINHACKS_H\n#define BFG_WINHACKS_H\n\n#include <winsock2.h>\n\n// wincon.h contains a KEY_EVENT that conflicts with ncurses\n#include <wincon.h>\n#ifdef KEY_EVENT\n#\tundef KEY_EVENT\n#endif\n// wincon.h contains a MOUSE_MOVED that conflicts with curses\n#ifdef MOUSE_MOVED\n#\tundef MOUSE_MOVED\n#endif\n\n#ifdef interface\n#undef interface\n#endif\n\n#endif\n"
        },
        {
          "name": "work2d.c",
          "type": "blob",
          "size": 3.44140625,
          "content": "/*\n * Copyright 2013-2016 Luke Dashjr\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"miner.h\"\n#include \"util.h\"\n#include \"work2d.h\"\n\n#define MAX_DIVISIONS  WORK2D_MAX_DIVISIONS\n\nstatic bool work2d_reserved[MAX_DIVISIONS + 1] = { true };\nint work2d_xnonce1sz;\nint work2d_xnonce2sz;\n\nvoid work2d_init()\n{\n\tRUNONCE();\n\t\n\tfor (uint64_t n = MAX_DIVISIONS; n; n >>= 8)\n\t\t++work2d_xnonce1sz;\n\twork2d_xnonce2sz = 2;\n}\n\nbool reserve_work2d_(uint32_t * const xnonce1_p)\n{\n\tuint32_t xnonce1;\n\tfor (xnonce1 = MAX_DIVISIONS; work2d_reserved[xnonce1]; --xnonce1)\n\t\tif (!xnonce1)\n\t\t\treturn false;\n\twork2d_reserved[xnonce1] = true;\n\t*xnonce1_p = htole32(xnonce1);\n\treturn true;\n}\n\nvoid release_work2d_(uint32_t xnonce1)\n{\n\txnonce1 = le32toh(xnonce1);\n\twork2d_reserved[xnonce1] = false;\n}\n\nint work2d_pad_xnonce_size(const struct stratum_work * const swork)\n{\n\treturn swork->n2size - work2d_xnonce1sz - work2d_xnonce2sz;\n}\n\nvoid *work2d_pad_xnonce(void * const buf_, const struct stratum_work * const swork, const bool hex)\n{\n\tuint8_t * const buf = buf_;\n\tint pad = work2d_pad_xnonce_size(swork);\n\tif (pad < 0)\n\t\treturn NULL;\n\tif (hex)\n\t{\n\t\tpad *= 2;\n\t\tmemset(buf, 'b', pad);\n\t}\n\telse\n\t\tmemset(buf, '\\xbb', pad);\n\treturn &buf[pad];\n}\n\nstatic void work2d_gen_dummy_work_prepare(struct work * const work, struct stratum_work * const swork, const struct timeval * const tvp_prepared)\n{\n\t*work = (struct work){\n\t\t.pool = swork->pool,\n\t\t.work_restart_id = swork->work_restart_id,\n\t\t.tv_staged = *tvp_prepared,\n\t};\n}\n\nvoid work2d_gen_dummy_work(struct work * const work, struct stratum_work * const swork, const struct timeval * const tvp_prepared, const void * const xnonce2, const uint32_t xnonce1)\n{\n\tuint8_t *p, *s;\n\t\n\twork2d_gen_dummy_work_prepare(work, swork, tvp_prepared);\n\t\n\tbytes_resize(&work->nonce2, swork->n2size);\n\ts = bytes_buf(&work->nonce2);\n\tp = &s[swork->n2size - work2d_xnonce2sz];\n\tif (xnonce2)\n\t\tmemcpy(p, xnonce2, work2d_xnonce2sz);\n#ifndef __OPTIMIZE__\n\telse\n\t\tmemset(p, '\\0', work2d_xnonce2sz);\n#endif\n\tp -= work2d_xnonce1sz;\n\tmemcpy(p, &xnonce1, work2d_xnonce1sz);\n\twork2d_pad_xnonce(s, swork, false);\n\tgen_stratum_work2(work, swork);\n}\n\nvoid work2d_gen_dummy_work_for_stale_check(struct work * const work, struct stratum_work * const swork, const struct timeval * const tvp_prepared, cglock_t * const data_lock_p)\n{\n\twork2d_gen_dummy_work_prepare(work, swork, tvp_prepared);\n\tgen_stratum_work3(work, swork, data_lock_p);\n}\n\nbool work2d_submit_nonce(struct thr_info * const thr, struct stratum_work * const swork, const struct timeval * const tvp_prepared, const void * const xnonce2, const uint32_t xnonce1, const uint32_t nonce, const uint32_t ntime, bool * const out_is_stale, const float nonce_diff)\n{\n\tstruct work _work, *work;\n\tbool rv;\n\t\n\t// Generate dummy work\n\twork = &_work;\n\twork2d_gen_dummy_work(work, swork, tvp_prepared, xnonce2, xnonce1);\n\t*(uint32_t *)&work->data[68] = htobe32(ntime);\n\twork->nonce_diff = nonce_diff;\n\twork->rolltime = INT_MAX;  // FIXME\n\t\n\t// Check if it's stale, if desired\n\tif (out_is_stale)\n\t\t*out_is_stale = stale_work(work, true);\n\t\n\t// Submit nonce\n\trv = submit_nonce(thr, work, nonce);\n\t\n\tclean_work(work);\n\t\n\treturn rv;\n}\n"
        },
        {
          "name": "work2d.h",
          "type": "blob",
          "size": 0.951171875,
          "content": "#ifndef BFG_WORK2D_H\n#define BFG_WORK2D_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#define WORK2D_MAX_DIVISIONS  255\n\nextern int work2d_xnonce1sz;\nextern int work2d_xnonce2sz;\n\nextern void work2d_init();\nextern bool reserve_work2d_(uint32_t *xnonce1_p);\nextern void release_work2d_(uint32_t xnonce1);\n\nextern int work2d_pad_xnonce_size(const struct stratum_work *);\nextern void *work2d_pad_xnonce(void *buf, const struct stratum_work *, bool hex);\nextern void work2d_gen_dummy_work(struct work *, struct stratum_work *, const struct timeval *tvp_prepared, const void *xnonce2, uint32_t xnonce1);\nextern void work2d_gen_dummy_work_for_stale_check(struct work *, struct stratum_work *, const struct timeval *tvp_prepared, cglock_t *data_lock_p);\nextern bool work2d_submit_nonce(struct thr_info *, struct stratum_work *, const struct timeval *tvp_prepared, const void *xnonce2, uint32_t xnonce1, uint32_t nonce, uint32_t ntime, bool *out_is_stale, float nonce_diff);\n\n#endif\n"
        },
        {
          "name": "x86_32",
          "type": "tree",
          "content": null
        },
        {
          "name": "x86_64",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}