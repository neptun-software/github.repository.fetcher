{
  "metadata": {
    "timestamp": 1736710166143,
    "page": 843,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "liexusong/php-beast",
      "stars": 1717,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 0.0048828125,
          "content": "beast"
        },
        {
          "name": "EXPERIMENTAL",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.98828125,
          "content": "<pre>\n        ____  __  ______     ____  _________   ___________\n       / __ \\/ / / / __ \\   / __ )/ ____/   | / ___/_  __/\n      / /_/ / /_/ / /_/ /  / __  / __/ / /| | \\__ \\ / /\n     / ____/ __  / ____/  / /_/ / /___/ ___ |___/ // /\n    /_/   /_/ /_/_/      /_____/_____/_/  |_/____//_/\n\n贡献者名字：\n@imaben (windows版本提供者)  https://github.com/imaben\n@pinguo-niulingyun (PHP7版本提供者) https://github.com/pinguo-niulingyun\n\nQQ交流群：239243332\n</pre>\n\n<b>Windows DLL：<a href=\"https://github.com/imaben/php-beast-binaries\">下载地址</a></b>\n\n<b>php-beast可以自定义加密模块，加密模块编写教程: <a href=\"https://github.com/liexusong/php-beast/wiki/%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B\">点击</a></b>\n\n<h3>编译安装如下:</h3>\n<pre><code>\n$ wget https://github.com/liexusong/php-beast/archive/master.zip\n$ unzip master.zip\n$ cd php-beast-master\n$ phpize\n$ ./configure\n$ sudo make && make install\n\n编译好之后修改php.ini配置文件, 加入配置项: extension=beast.so, 重启php-fpm\n</code></pre>\n\n<pre>温馨提示: 可以设置较大的缓存提高效率</pre>\n\n<p><b>使用php-beast的性能：</b><br/><br/>\n<img src=\"http://git.oschina.net/liexusong/php-beast/raw/master/images/beast1.png?dir=0&filepath=images/beast1.png&oid=645b87003dada2eac4f1a9fcfd353aa0423f5711&sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7\" /></p>\n\n<p><b>不使用php-beast的性能：</b><br/><br/>\n<img src=\"http://git.oschina.net/liexusong/php-beast/raw/master/images/beast2.png?dir=0&filepath=images/beast2.png&oid=3f07cff6dca34b22d8933ab0ea1740a0e4f37e34&sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7\" /></p>\n\n配置项:\n<pre><code>\n beast.cache_size = size\n beast.log_file = \"path_to_log\"\n beast.log_user = \"user\"\n beast.log_level = \"debug\"\n beast.enable = On\n</code></pre>\n\nbeast.log_level支持参数：\n<pre>\n 1. DEBUG\n 2. NOTICE\n 3. ERROR\n</pre>\n\n支持的模块有：\n<pre>\n 1. AES\n 2. DES\n 3. Base64\n</pre>\n\n通过测试环境:\n<pre><code>\n Nginx + Fastcgi + (PHP-5.2.x ~ PHP-7.1.x)\n</code></pre>\n\n------------------------------\n\n## 怎么加密项目\n**加密方案1**\n\n安装完 `php-beast` 后可以使用 `tools` 目录下的 `encode_files.php` 来加密你的项目。使用 `encode_files.php` 之前先修改 `tools` 目录下的 `configure.ini` 文件，如下：\n```ini\n; source path\nsrc_path = \"\"\n\n; destination path\ndst_path = \"\"\n\n; expire time\nexpire = \"\"\n\n; encrypt type (selection: DES, AES, BASE64)\nencrypt_type = \"DES\"\n```\n`src_path` 是要加密项目的路径，`dst_path` 是保存加密后项目的路径，`expire` 是设置项目可使用的时间 (`expire` 的格式是：`YYYY-mm-dd HH:ii:ss`)。`encrypt_type`是加密的方式，选择项有：DES、AES、BASE64。\n修改完 `configure.ini` 文件后就可以使用命令 `php encode_files.php` 开始加密项目。\n\n**加密方案2**\n\n使用`beast_encode_file()`函数加密文件，函数原型如下：<br/>\n`beast_encode_file(string $input_file, string $output_file, int expire_timestamp, int encrypt_type)`。\n<pre>\n1. $input_file: 要加密的文件\n2. $output_file: 输出的加密文件路径\n3. $expire_timestamp: 文件过期时间戳\n4. $encrypt_type: 加密使用的算法（支持：BEAST_ENCRYPT_TYPE_DES、BEAST_ENCRYPT_TYPE_AES）\n</pre>\n\n------------------------------\n\n## 制定自己的php-beast\n\n`php-beast` 有多个地方可以定制的，以下一一列出：\n\n*1.* 使用 `header.c` 文件可以修改 `php-beast` 加密后的文件头结构，这样网上的解密软件就不能认识我们的加密文件，就不能进行解密，增加加密的安全性。\n\n*2.* `php-beast` 提供只能在指定的机器上运行的功能。要使用此功能可以在 `networkcards.c` 文件添加能够运行机器的网卡号，例如：\n```c\nchar *allow_networkcards[] = {\n\t\"fa:16:3e:08:88:01\",\n    NULL,\n};\n```\n这样设置之后，`php-beast` 扩展就只能在 `fa:16:3e:08:88:01` 这台机器上运行。另外要注意的是，由于有些机器网卡名可能不一样，所以如果你的网卡名不是 `eth0` 的话，可以在 `php.ini` 中添加配置项： `beast.networkcard = \"xxx\"` 其中 `xxx` 就是你的网卡名，也可以配置多张网卡，如：`beast.networkcard = \"eth0,eth1,eth2\"`。\n\n*3.* 使用 `php-beast` 时最好不要使用默认的加密key，因为扩展是开源的，如果使用默认加密key的话，很容易被人发现。所以最好编译的时候修改加密的key，`aes模块` 可以在 `aes_algo_handler.c` 文件修改，而 `des模块` 可以在 `des_algo_handler.c` 文件修改。\n\n------------------------------\n\n## 开启debug模式\n可以在configure时加上 `--enable-beast-debug` 选项来开启debug模式。开启debug模式后需要在php.ini配置文件中加入配置项：`beast.debug_path` 和 `beast.debug_mode`。`beast.debug_mode` 用于指定是否使用debug模式，而 `beast.debug_path` 用于输出解密后的php脚本源码。这样就可以在 `beast.debug_path` 目录中看到php-beast解密后的源代码，可以方便知道扩展解密是否正确。\n\n## 开启禁止执行未加密的脚本\n可以在configure时加上 `--enable-execute-normal-script=off` 选项来禁止执行未加密的PHP脚本。\n\n------------------------------\n\n## 函数列表\n*1.* beast_encode_file(): 用于加密一个文件\n\n*2.* beast_avail_cache(): 获取可以缓存大小\n\n*3.* beast_support_filesize(): 获取beast支持的最大可加密文件大小\n\n*4.* beast_file_expire(): 获取一个文件的过期时间\n\n*5.* beast_clean_cache(): 清空beast的所有缓存(如果有文件更新, 可以使用此函数清空缓存)\n\n------------------------------\n\n## 常见问题\n\n*1.* linux：如果出现502错误，一般是由于GCC版本太低导致，请先升级GCC再安装本模块。\n\n*2.* Windows：IIS环境下FastCGI进程异常退出：尝试将IIS的运行用户从ApplicationPoolIdentity改为LocalSystem\n\n------------------------------\n\n### 我们的公众号\n\n![](https://image-static.segmentfault.com/376/558/3765589661-607fef350658b_fix732)\n\n------------------------------\n"
        },
        {
          "name": "aes_algo_handler.c",
          "type": "blob",
          "size": 1.67578125,
          "content": "/**\n * AES encrypt algorithms handler module for Beast\n * @author: liexusong\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"beast_log.h\"\n#include \"beast_module.h\"\n#include \"aes_algo_lib.c\"\n\nstatic uint8_t key[] = {\n\t0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n\t0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,\n};\n\nint aes_encrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n\tint blocks, i;\n\tchar *out;\n\tchar in[16];\n\n\tblocks = len / 16;\n\tif (len % 16) { /* not enough one block (16 bytes) */\n\t\tblocks += 1;\n\t}\n\n\tout = malloc(blocks * 16);\n\tif (!out) {\n\t\tbeast_write_log(beast_log_error,\n            \"Out of memory when allocate `%d' size by encrypt(AES)\", blocks*16);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < blocks; i++) {\n\t\tint size;\n\n\t\tmemset(in, 0, 16);\n\n\t\tif (i == blocks - 1 && (len % 16)) { /* the last block */\n\t\t\tsize = len % 16;\n\t\t} else {\n\t\t\tsize = 16;\n\t\t}\n\n\t\tmemcpy(in, inbuf + i * 16, size);\n\n\t\tAES128_ECB_encrypt(in, key, out + i * 16);\n\t}\n\n\t*outbuf = out;\n\t*outlen = blocks * 16;\n\n\treturn 0;\n}\n\n\nint aes_decrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n\tint blocks, i;\n\tchar *out;\n\n\tif (len % 16) {\n\t\treturn -1;\n\t}\n\n\tblocks = len / 16;\n\n\tout = malloc(blocks * 16);\n\tif (!out) {\n\t\tbeast_write_log(beast_log_error,\n            \"Out of memory when allocate `%d' size by decrypt(AES)\", blocks*16);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < blocks; i++) {\n\t\tAES128_ECB_decrypt(inbuf + i * 16, key, out + i * 16);\n\t}\n\n\t*outbuf = out;\n\t*outlen = blocks * 16;\n\n\treturn 0;\n}\n\n\nvoid aes_free_handler(void *ptr)\n{\n    if (ptr) {\n        free(ptr);\n    }\n}\n\nstruct beast_ops aes_handler_ops = {\n\t\"aes-algo\",\n\taes_encrypt_handler,\n\taes_decrypt_handler,\n\taes_free_handler,\n\tNULL\n};\n"
        },
        {
          "name": "aes_algo_lib.c",
          "type": "blob",
          "size": 16.3046875,
          "content": "/*\n\nThis is an implementation of the AES128 algorithm, specifically ECB and CBC mode.\n\nThe implementation is verified against the test vectors in:\n  National Institute of Standards and Technology Special Publication 800-38A 2001 ED\n\nECB-AES128\n----------\n\n  plain-text:\n    6bc1bee22e409f96e93d7e117393172a\n    ae2d8a571e03ac9c9eb76fac45af8e51\n    30c81c46a35ce411e5fbc1191a0a52ef\n    f69f2445df4f9b17ad2b417be66c3710\n\n  key:\n    2b7e151628aed2a6abf7158809cf4f3c\n\n  resulting cipher\n    3ad77bb40d7a3660a89ecaf32466ef97\n    f5d3d58503b9699de785895a96fdbaaf\n    43b1cd7f598ece23881b00e3ed030688\n    7b0c785e27e8ad3f8223207104725dd4\n\n\nNOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)\n        You should pad the end of the string with zeros if this is not the case.\n\n*/\n\n\n/*****************************************************************************/\n/* Includes:                                                                 */\n/*****************************************************************************/\n#include <stdint.h>\n#include <string.h> // CBC mode, for memset\n\n/*****************************************************************************/\n/* Defines:                                                                  */\n/*****************************************************************************/\n// The number of columns comprising a state in AES. This is a constant in AES. Value=4\n#define Nb 4\n// The number of 32 bit words in a key.\n#define Nk 4\n// Key length in bytes [128 bit]\n#define KEYLEN 16\n// The number of rounds in AES Cipher.\n#define Nr 10\n\n// jcallan@github points out that declaring Multiply as a function\n// reduces code size considerably with the Keil ARM compiler.\n// See this link for more information: https://github.com/kokke/tiny-AES128-C/pull/3\n#ifndef MULTIPLY_AS_A_FUNCTION\n  #define MULTIPLY_AS_A_FUNCTION 0\n#endif\n\n\n/*****************************************************************************/\n/* Private variables:                                                        */\n/*****************************************************************************/\n// state - array holding the intermediate results during decryption.\ntypedef uint8_t state_t[4][4];\nstatic state_t* state;\n\n// The array that stores the round keys.\nstatic uint8_t RoundKey[176];\n\n// The Key input to the AES Program\nstatic const uint8_t* Key;\n\n// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM\n// The numbers below can be computed dynamically trading ROM for RAM -\n// This can be useful in (embedded) bootloader applications, where ROM is often limited.\nstatic const uint8_t sbox[256] =   {\n  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F\n  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };\n\nstatic const uint8_t rsbox[256] =\n{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };\n\n\n// The round constant word array, Rcon[i], contains the values given by\n// x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)\n// Note that i starts at 1, not 0).\nstatic const uint8_t Rcon[255] = {\n  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n  0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\n  0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,\n  0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,\n  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,\n  0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,\n  0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,\n  0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,\n  0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,\n  0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,\n  0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,\n  0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,\n  0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,\n  0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,\n  0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,\n  0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };\n\n\n/*****************************************************************************/\n/* Private functions:                                                        */\n/*****************************************************************************/\nstatic uint8_t getSBoxValue(uint8_t num)\n{\n  return sbox[num];\n}\n\nstatic uint8_t getSBoxInvert(uint8_t num)\n{\n  return rsbox[num];\n}\n\n// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states.\nstatic void KeyExpansion(void)\n{\n  uint32_t i, j, k;\n  uint8_t tempa[4]; // Used for the column/row operations\n\n  // The first round key is the key itself.\n  for(i = 0; i < Nk; ++i)\n  {\n    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];\n    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];\n    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];\n    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];\n  }\n\n  // All other round keys are found from the previous round keys.\n  for(; (i < (Nb * (Nr + 1))); ++i)\n  {\n    for(j = 0; j < 4; ++j)\n    {\n      tempa[j]=RoundKey[(i-1) * 4 + j];\n    }\n    if (i % Nk == 0)\n    {\n      // This function rotates the 4 bytes in a word to the left once.\n      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]\n\n      // Function RotWord()\n      {\n        k = tempa[0];\n        tempa[0] = tempa[1];\n        tempa[1] = tempa[2];\n        tempa[2] = tempa[3];\n        tempa[3] = k;\n      }\n\n      // SubWord() is a function that takes a four-byte input word and\n      // applies the S-box to each of the four bytes to produce an output word.\n\n      // Function Subword()\n      {\n        tempa[0] = getSBoxValue(tempa[0]);\n        tempa[1] = getSBoxValue(tempa[1]);\n        tempa[2] = getSBoxValue(tempa[2]);\n        tempa[3] = getSBoxValue(tempa[3]);\n      }\n\n      tempa[0] =  tempa[0] ^ Rcon[i/Nk];\n    }\n    else if (Nk > 6 && i % Nk == 4)\n    {\n      // Function Subword()\n      {\n        tempa[0] = getSBoxValue(tempa[0]);\n        tempa[1] = getSBoxValue(tempa[1]);\n        tempa[2] = getSBoxValue(tempa[2]);\n        tempa[3] = getSBoxValue(tempa[3]);\n      }\n    }\n    RoundKey[i * 4 + 0] = RoundKey[(i - Nk) * 4 + 0] ^ tempa[0];\n    RoundKey[i * 4 + 1] = RoundKey[(i - Nk) * 4 + 1] ^ tempa[1];\n    RoundKey[i * 4 + 2] = RoundKey[(i - Nk) * 4 + 2] ^ tempa[2];\n    RoundKey[i * 4 + 3] = RoundKey[(i - Nk) * 4 + 3] ^ tempa[3];\n  }\n}\n\n// This function adds the round key to state.\n// The round key is added to the state by an XOR function.\nstatic void AddRoundKey(uint8_t round)\n{\n  uint8_t i,j;\n  for(i=0;i<4;++i)\n  {\n    for(j = 0; j < 4; ++j)\n    {\n      (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];\n    }\n  }\n}\n\n// The SubBytes Function Substitutes the values in the\n// state matrix with values in an S-box.\nstatic void SubBytes(void)\n{\n  uint8_t i, j;\n  for(i = 0; i < 4; ++i)\n  {\n    for(j = 0; j < 4; ++j)\n    {\n      (*state)[j][i] = getSBoxValue((*state)[j][i]);\n    }\n  }\n}\n\n// The ShiftRows() function shifts the rows in the state to the left.\n// Each row is shifted with different offset.\n// Offset = Row number. So the first row is not shifted.\nstatic void ShiftRows(void)\n{\n  uint8_t temp;\n\n  // Rotate first row 1 columns to left\n  temp           = (*state)[0][1];\n  (*state)[0][1] = (*state)[1][1];\n  (*state)[1][1] = (*state)[2][1];\n  (*state)[2][1] = (*state)[3][1];\n  (*state)[3][1] = temp;\n\n  // Rotate second row 2 columns to left\n  temp           = (*state)[0][2];\n  (*state)[0][2] = (*state)[2][2];\n  (*state)[2][2] = temp;\n\n  temp       = (*state)[1][2];\n  (*state)[1][2] = (*state)[3][2];\n  (*state)[3][2] = temp;\n\n  // Rotate third row 3 columns to left\n  temp       = (*state)[0][3];\n  (*state)[0][3] = (*state)[3][3];\n  (*state)[3][3] = (*state)[2][3];\n  (*state)[2][3] = (*state)[1][3];\n  (*state)[1][3] = temp;\n}\n\nstatic uint8_t xtime(uint8_t x)\n{\n  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));\n}\n\n// MixColumns function mixes the columns of the state matrix\nstatic void MixColumns(void)\n{\n  uint8_t i;\n  uint8_t Tmp,Tm,t;\n  for(i = 0; i < 4; ++i)\n  {\n    t   = (*state)[i][0];\n    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;\n    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][3] ^ t ;        Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;\n  }\n}\n\n// Multiply is used to multiply numbers in the field GF(2^8)\n#if MULTIPLY_AS_A_FUNCTION\nstatic uint8_t Multiply(uint8_t x, uint8_t y)\n{\n  return (((y & 1) * x) ^\n       ((y>>1 & 1) * xtime(x)) ^\n       ((y>>2 & 1) * xtime(xtime(x))) ^\n       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^\n       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))));\n  }\n#else\n#define Multiply(x, y)                                \\\n      (  ((y & 1) * x) ^                              \\\n      ((y>>1 & 1) * xtime(x)) ^                       \\\n      ((y>>2 & 1) * xtime(xtime(x))) ^                \\\n      ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \\\n      ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \\\n\n#endif\n\n// MixColumns function mixes the columns of the state matrix.\n// The method used to multiply may be difficult to understand for the inexperienced.\n// Please use the references to gain more information.\nstatic void InvMixColumns(void)\n{\n  int i;\n  uint8_t a,b,c,d;\n  for(i=0;i<4;++i)\n  {\n    a = (*state)[i][0];\n    b = (*state)[i][1];\n    c = (*state)[i][2];\n    d = (*state)[i][3];\n\n    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);\n    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);\n    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);\n    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);\n  }\n}\n\n\n// The SubBytes Function Substitutes the values in the\n// state matrix with values in an S-box.\nstatic void InvSubBytes(void)\n{\n  uint8_t i,j;\n  for(i=0;i<4;++i)\n  {\n    for(j=0;j<4;++j)\n    {\n      (*state)[j][i] = getSBoxInvert((*state)[j][i]);\n    }\n  }\n}\n\nstatic void InvShiftRows(void)\n{\n  uint8_t temp;\n\n  // Rotate first row 1 columns to right\n  temp=(*state)[3][1];\n  (*state)[3][1]=(*state)[2][1];\n  (*state)[2][1]=(*state)[1][1];\n  (*state)[1][1]=(*state)[0][1];\n  (*state)[0][1]=temp;\n\n  // Rotate second row 2 columns to right\n  temp=(*state)[0][2];\n  (*state)[0][2]=(*state)[2][2];\n  (*state)[2][2]=temp;\n\n  temp=(*state)[1][2];\n  (*state)[1][2]=(*state)[3][2];\n  (*state)[3][2]=temp;\n\n  // Rotate third row 3 columns to right\n  temp=(*state)[0][3];\n  (*state)[0][3]=(*state)[1][3];\n  (*state)[1][3]=(*state)[2][3];\n  (*state)[2][3]=(*state)[3][3];\n  (*state)[3][3]=temp;\n}\n\n\n// Cipher is the main function that encrypts the PlainText.\nstatic void Cipher(void)\n{\n  uint8_t round = 0;\n\n  // Add the First round key to the state before starting the rounds.\n  AddRoundKey(0);\n\n  // There will be Nr rounds.\n  // The first Nr-1 rounds are identical.\n  // These Nr-1 rounds are executed in the loop below.\n  for(round = 1; round < Nr; ++round)\n  {\n    SubBytes();\n    ShiftRows();\n    MixColumns();\n    AddRoundKey(round);\n  }\n\n  // The last round is given below.\n  // The MixColumns function is not here in the last round.\n  SubBytes();\n  ShiftRows();\n  AddRoundKey(Nr);\n}\n\nstatic void InvCipher(void)\n{\n  uint8_t round=0;\n\n  // Add the First round key to the state before starting the rounds.\n  AddRoundKey(Nr);\n\n  // There will be Nr rounds.\n  // The first Nr-1 rounds are identical.\n  // These Nr-1 rounds are executed in the loop below.\n  for(round=Nr-1;round>0;round--)\n  {\n    InvShiftRows();\n    InvSubBytes();\n    AddRoundKey(round);\n    InvMixColumns();\n  }\n\n  // The last round is given below.\n  // The MixColumns function is not here in the last round.\n  InvShiftRows();\n  InvSubBytes();\n  AddRoundKey(0);\n}\n\nstatic void BlockCopy(uint8_t* output, uint8_t* input)\n{\n  uint8_t i;\n  for (i=0;i<KEYLEN;++i)\n  {\n    output[i] = input[i];\n  }\n}\n\n\n\n/*****************************************************************************/\n/* Public functions:                                                         */\n/*****************************************************************************/\n\nvoid AES128_ECB_encrypt(uint8_t* input, const uint8_t* key, uint8_t* output)\n{\n  // Copy input to output, and work in-memory on output\n  BlockCopy(output, input);\n  state = (state_t*)output;\n\n  Key = key;\n  KeyExpansion();\n\n  // The next function call encrypts the PlainText with the Key using AES algorithm.\n  Cipher();\n}\n\nvoid AES128_ECB_decrypt(uint8_t* input, const uint8_t* key, uint8_t *output)\n{\n  // Copy input to output, and work in-memory on output\n  BlockCopy(output, input);\n  state = (state_t*)output;\n\n  // The KeyExpansion routine must be called before encryption.\n  Key = key;\n  KeyExpansion();\n\n  InvCipher();\n}\n"
        },
        {
          "name": "base64_algo_handler.c",
          "type": "blob",
          "size": 4.6875,
          "content": "/**\n * Base64 encrypt algorithms handler module for Beast\n * @author: liexusong\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"beast_log.h\"\n#include \"beast_module.h\"\n\nstatic const char base64_table[] =\n{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', '\\0'\n};\n\nstatic const char base64_pad = '=';\n\nstatic const short base64_reverse_table[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,\n\t-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n\t-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nchar *base64_encode(char *str, int length, int *ret_length)\n{\n\tchar *current = str;\n\tchar *p;\n\tchar *result;\n\tint alen;\n\n\tif ((length + 2) < 0\n\t\t|| ((length + 2) / 3) >= (1 << (sizeof(int) * 8 - 2)))\n\t{\n\t\tif (ret_length != NULL) {\n\t\t\t*ret_length = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\talen = ((length + 2) / 3) * 4 + 1;\n\n\tresult = malloc(alen);\n\tif (!result) {\n\t\tbeast_write_log(beast_log_error,\n              \"Out of memory when allocate `%d' size by encrypt(BASE64)\", alen);\n\t\treturn NULL;\n\t}\n\n\tp = result;\n\n\twhile (length > 2) { /* keep going until we have less than 24 bits */\n\t\t*p++ = base64_table[current[0] >> 2];\n\t\t*p++ = base64_table[((current[0] & 0x03) << 4) + (current[1] >> 4)];\n\t\t*p++ = base64_table[((current[1] & 0x0f) << 2) + (current[2] >> 6)];\n\t\t*p++ = base64_table[current[2] & 0x3f];\n\n\t\tcurrent += 3;\n\t\tlength -= 3; /* we just handle 3 octets of data */\n\t}\n\n\t/* now deal with the tail end of things */\n\tif (length != 0) {\n\t\t*p++ = base64_table[current[0] >> 2];\n\t\tif (length > 1) {\n\t\t\t*p++ = base64_table[((current[0] & 0x03) << 4) + (current[1] >> 4)];\n\t\t\t*p++ = base64_table[(current[1] & 0x0f) << 2];\n\t\t\t*p++ = base64_pad;\n\t\t} else {\n\t\t\t*p++ = base64_table[(current[0] & 0x03) << 4];\n\t\t\t*p++ = base64_pad;\n\t\t\t*p++ = base64_pad;\n\t\t}\n\t}\n\n\tif (ret_length != NULL) {\n\t\t*ret_length = (int)(p - result);\n\t}\n\n\t*p = '\\0';\n\n\treturn result;\n}\n\n\nchar *base64_decode(char *str, int length, int *ret_length)\n{\n\tchar *current = str;\n\tint ch, i = 0, j = 0, k;\n\tchar *result;\n\n\tresult = malloc(length + 1);\n\tif (result == NULL) {\n\t\tbeast_write_log(beast_log_error,\n          \"Out of memory when allocate `%d' size by decrypt(BASE64)\", length+1);\n\t\treturn NULL;\n\t}\n\n\t/* run through the whole string, converting as we go */\n\twhile ((ch = *current++) != '\\0' && length-- > 0) {\n\t\tif (ch == base64_pad) break;\n\n\t\tch = base64_reverse_table[ch];\n\t\tif (ch < 0) continue;\n\n\t\tswitch(i % 4) {\n\t\tcase 0:\n\t\t\tresult[j] = ch << 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult[j++] |= ch >> 4;\n\t\t\tresult[j] = (ch & 0x0f) << 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult[j++] |= ch >>2;\n\t\t\tresult[j] = (ch & 0x03) << 6;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tresult[j++] |= ch;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tk = j;\n\t/* mop things up if we ended on a boundary */\n\tif (ch == base64_pad) {\n\t\tswitch(i % 4) {\n\t\tcase 1:\n\t\t\tfree(result);\n\t\t\treturn NULL;\n\t\tcase 2:\n\t\t\tk++;\n\t\tcase 3:\n\t\t\tresult[k++] = 0;\n\t\t}\n\t}\n\n\tif(ret_length) {\n\t\t*ret_length = j;\n\t}\n\n\tresult[j] = '\\0';\n\n\treturn result;\n}\n\n\nint base64_encrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n\tchar *result;\n\tint reslen;\n\n\tresult = base64_encode(inbuf, len, &reslen);\n\tif (!result) {\n\t\treturn -1;\n\t}\n\n\t*outbuf = result;\n\t*outlen = reslen;\n\n\treturn 0;\n}\n\n\nint base64_decrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n\tchar *result;\n\tint reslen;\n\n\tresult = base64_decode(inbuf, len, &reslen);\n\tif (!result) {\n\t\treturn -1;\n\t}\n\n\t*outbuf = result;\n\t*outlen = reslen;\n\n\treturn 0;\n}\n\n\nvoid base64_free_handler(void *ptr)\n{\n    if (ptr) {\n        free(ptr);\n    }\n}\n\n\nstruct beast_ops base64_handler_ops = {\n\t\"base64-algo\",\n\tbase64_encrypt_handler,\n\tbase64_decrypt_handler,\n\tbase64_free_handler,\n\tNULL\n};\n"
        },
        {
          "name": "beast.c",
          "type": "blob",
          "size": 36.70703125,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2007 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Liexusong <liexusong@qq.com>                                 |\n  |         maben <www.maben@foxmail.com>                                |\n  +----------------------------------------------------------------------+\n*/\n\n/* $Id: header,v 1.16.2.1.2.1 2007/01/01 19:32:09 iliaa Exp $ */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <time.h>\n\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n\n#include \"zend.h\"\n#include \"zend_operators.h\"\n#include \"zend_globals.h\"\n#include \"zend_highlight.h\"\n#include \"zend_language_scanner.h\"\n\n#include \"zend_API.h\"\n#include \"zend_compile.h\"\n\n#include \"php.h\"\n#include \"php_main.h\"\n#include \"php_globals.h\"\n#include \"php_ini.h\"\n#include \"main/SAPI.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/date/php_date.h\"\n#include \"php_streams.h\"\n#include \"php_beast.h\"\n#include \"beast_mm.h\"\n#include \"cache.h\"\n#include \"beast_log.h\"\n#include \"beast_module.h\"\n#include \"file_handler.h\"\n\n#ifdef PHP_WIN32\n    #include <WinSock2.h>\n    #include <Iphlpapi.h>\n    #pragma comment(lib, PHP_LIB)\n    #pragma comment(lib, \"Iphlpapi.lib\")\n#else\n    #include <pwd.h>\n    #include <unistd.h>\n    #include <execinfo.h>\n#endif\n\n#if ZEND_MODULE_API_NO >= 20151012\n# define BEAST_RETURN_STRING(str, dup) RETURN_STRING(str)\n#else\n# define BEAST_RETURN_STRING(str, dup) RETURN_STRING(str, dup)\n#endif\n\n#define BEAST_VERSION       \"2.7\"\n#define DEFAULT_CACHE_SIZE  10485760   /* 10MB */\n#define HEADER_MAX_SIZE     256\n#define INT_SIZE            (sizeof(int))\n\nextern struct beast_ops *ops_handler_list[];\n\n/*\n * Global vaiables for extension\n */\nchar *beast_log_file = NULL;\nchar *beast_log_user = NULL;\nint log_level = beast_log_notice;\nint beast_ncpu = 1;\nint beast_is_root = 0;\nint beast_pid = -1;\n\n/* True global resources - no need for thread safety here */\nstatic zend_op_array* (*old_compile_file)(zend_file_handle*, int TSRMLS_DC);\n\nstatic int le_beast;\nstatic int max_cache_size = DEFAULT_CACHE_SIZE;\nstatic int beast_enable = 1;\nstatic int beast_max_filesize = 0;\nstatic char *local_networkcard = NULL;\nstatic int beast_now_time = 0;\nstatic int log_normal_file = 0;\nstatic char *beast_debug_path = NULL;\nstatic int beast_debug_mode = 0;\n\n/* {{{ beast_functions[]\n *\n * Every user visible function must have an entry in beast_functions[].\n */\nzend_function_entry beast_functions[] = {\n    PHP_FE(beast_encode_file,      NULL)\n    PHP_FE(beast_avail_cache,      NULL)\n    PHP_FE(beast_support_filesize, NULL)\n    PHP_FE(beast_file_expire,      NULL)\n    PHP_FE(beast_clean_cache,      NULL)\n    {NULL, NULL, NULL}    /* Must be the last line in beast_functions[] */\n};\n/* }}} */\n\n/* {{{ beast_module_entry\n */\nzend_module_entry beast_module_entry = {\n#if ZEND_MODULE_API_NO >= 20010901\n    STANDARD_MODULE_HEADER,\n#endif\n    \"beast\",\n    beast_functions,\n    PHP_MINIT(beast),\n    PHP_MSHUTDOWN(beast),\n    PHP_RINIT(beast),\n    PHP_RSHUTDOWN(beast),\n    PHP_MINFO(beast),\n#if ZEND_MODULE_API_NO >= 20010901\n    BEAST_VERSION, /* Replace with version number for your extension */\n#endif\n    STANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_BEAST\nZEND_GET_MODULE(beast)\n#endif\n\nextern struct file_handler tmpfile_handler;\nextern struct file_handler pipe_handler;\n\nstatic struct file_handler *default_file_handler = NULL;\nstatic struct file_handler *file_handlers[] = {\n    &tmpfile_handler,\n#ifndef PHP_WIN32\n    &pipe_handler,\n#endif\n    NULL\n};\n\nextern char encrypt_file_header_sign[];\nextern int encrypt_file_header_length;\nextern char *file_handler_switch;\n\n#define swab32(x)                                        \\\n     ((x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8 |   \\\n      (x & 0x00FF0000) >>  8 | (x & 0xFF000000) >> 24)\n\n\n#define little_endian()  (!big_endian())\n\nstatic int big_endian()\n{\n    unsigned short num = 0x1122;\n\n    if(*((unsigned char *)&num) == 0x11) {\n        return 1;\n    }\n\n    return 0;\n}\n\n\nint filter_code_comments(char *filename, zval *retval TSRMLS_DC)\n{\n    zend_lex_state original_lex_state;\n    zend_file_handle file_handle = {0};\n\n#if PHP_API_VERSION > 20090626\n\n    php_output_start_default(TSRMLS_C);\n\n    file_handle.type = ZEND_HANDLE_FILENAME;\n    file_handle.filename = filename;\n    file_handle.free_filename = 0;\n    file_handle.opened_path = NULL;\n\n    zend_save_lexical_state(&original_lex_state TSRMLS_CC);\n    if (open_file_for_scanning(&file_handle TSRMLS_CC) == FAILURE) {\n        zend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n        php_output_end(TSRMLS_C);\n        return -1;\n    }\n\n    zend_strip(TSRMLS_C);\n\n    zend_destroy_file_handle(&file_handle TSRMLS_CC);\n    zend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\n    php_output_get_contents(retval TSRMLS_CC);\n    php_output_discard(TSRMLS_C);\n\n#else\n\n    file_handle.type = ZEND_HANDLE_FILENAME;\n    file_handle.filename = filename;\n    file_handle.free_filename = 0;\n    file_handle.opened_path = NULL;\n\n    zend_save_lexical_state(&original_lex_state TSRMLS_CC);\n    if (open_file_for_scanning(&file_handle TSRMLS_CC) == FAILURE) {\n        zend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n        return -1;\n    }\n\n    php_start_ob_buffer(NULL, 0, 1 TSRMLS_CC);\n\n    zend_strip(TSRMLS_C);\n\n    zend_destroy_file_handle(&file_handle TSRMLS_CC);\n    zend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\n    php_ob_get_buffer(retval TSRMLS_CC);\n    php_end_ob_buffer(0, 0 TSRMLS_CC);\n\n#endif\n\n    return 0;\n}\n\n\nstruct beast_ops *beast_get_encrypt_algo(int type)\n{\n    int index = type - 1;\n\n    if (index < 0 || index >= BEAST_ENCRYPT_TYPE_ERROR) {\n        return ops_handler_list[0];\n    }\n\n    return ops_handler_list[index];\n}\n\n\n/*****************************************************************************\n*                                                                            *\n*  Encrypt a plain text file and output a cipher file                        *\n*                                                                            *\n*****************************************************************************/\n\nint encrypt_file(const char *inputfile,\n    const char *outputfile, int expire,\n    int encrypt_type TSRMLS_DC)\n{\n    php_stream *output_stream = NULL;\n    zval codes;\n    int need_free_code = 0;\n    char *inbuf, *outbuf;\n    int inlen, outlen, dumplen, expireval, dumptype;\n    struct beast_ops *encrypt_ops = beast_get_encrypt_algo(encrypt_type);\n\n    /* Get php codes from script file */\n    if (filter_code_comments((char *)inputfile, &codes TSRMLS_CC) == -1) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n                         \"Unable get codes from php file `%s'\", inputfile);\n        return -1;\n    }\n\n    need_free_code = 1;\n\n#if ZEND_MODULE_API_NO >= 20151012\n    inlen = Z_STRLEN(codes);\n    inbuf = Z_STRVAL(codes);\n#else\n    inlen = codes.value.str.len;\n    inbuf = codes.value.str.val;\n#endif\n\n    /* PHP file size can not large than beast_max_filesize */\n    if (beast_max_filesize > 0 && inlen > beast_max_filesize) {\n        return -1;\n    }\n\n    /* Open output file */\n#if ZEND_MODULE_API_NO >= 20151012\n    output_stream = php_stream_open_wrapper((char *)outputfile, \"w+\",\n                              IGNORE_URL_WIN|REPORT_ERRORS, NULL);\n#else\n    output_stream = php_stream_open_wrapper((char *)outputfile, \"w+\",\n                              ENFORCE_SAFE_MODE|REPORT_ERRORS, NULL);\n#endif\n\n    if (!output_stream) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n                                        \"Unable to open file `%s'\", outputfile);\n        goto failed;\n    }\n\n    /* if computer is little endian, change file size to big endian */\n    if (little_endian()) {\n        dumplen   = swab32(inlen);\n        expireval = swab32(expire);\n        dumptype  = swab32(encrypt_type);\n\n    } else {\n        dumplen   = inlen;\n        expireval = expire;\n        dumptype  = encrypt_type;\n    }\n\n    php_stream_write(output_stream,\n        encrypt_file_header_sign, encrypt_file_header_length);\n    php_stream_write(output_stream, (const char *)&dumplen, INT_SIZE);\n    php_stream_write(output_stream, (const char *)&expireval, INT_SIZE);\n    php_stream_write(output_stream, (const char *)&dumptype, INT_SIZE);\n\n    if (encrypt_ops->encrypt(inbuf, inlen, &outbuf, &outlen) == -1) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n                         \"Unable to encrypt file `%s'\", outputfile);\n        goto failed;\n    }\n\n    php_stream_write(output_stream, outbuf, outlen);\n    php_stream_close(output_stream);\n    zval_dtor(&codes);\n\n    if (encrypt_ops->free) {\n        encrypt_ops->free(outbuf);\n    }\n\n    return 0;\n\nfailed:\n    if (output_stream)\n        php_stream_close(output_stream);\n    if (need_free_code)\n        zval_dtor(&codes);\n    return -1;\n}\n\n\n/*****************************************************************************\n*                                                                            *\n*  Decrypt a cipher text file and output plain buffer                        *\n*                                                                            *\n*****************************************************************************/\n\nint decrypt_file(const char *filename, int stream,\n        char **retbuf, int *retlen, int *free_buffer,\n        struct beast_ops **ret_encrypt TSRMLS_DC)\n{\n    struct stat stat_ssb;\n    cache_key_t findkey;\n    cache_item_t *cache;\n    int reallen, bodylen, expire;\n    char header[HEADER_MAX_SIZE];\n    int headerlen;\n    char *buffer = NULL, *decbuf;\n    int declen;\n    int entype;\n    struct beast_ops *encrypt_ops;\n    int retval = -1;\n    int n = 0;\n    int filesize = 0;\n\n#ifdef PHP_WIN32\n    ULARGE_INTEGER ull;\n    BY_HANDLE_FILE_INFORMATION fileinfo;\n    HANDLE hFile = (HANDLE)_get_osfhandle(stream);\n    if (!GetFileInformationByHandle(hFile, &fileinfo)) {\n        beast_write_log(beast_log_error,\n                \"Failed to get file information from file `%s'\", filename);\n        retval = -1;\n        goto failed;\n    }\n    findkey.device = fileinfo.dwVolumeSerialNumber;\n    findkey.inode = fileinfo.nFileIndexHigh * (MAXDWORD + 1) + fileinfo.nFileIndexLow;\n\n\n    ull.LowPart = fileinfo.ftLastWriteTime.dwLowDateTime;\n    ull.HighPart = fileinfo.ftLastWriteTime.dwHighDateTime;\n\n    findkey.mtime =  ull.QuadPart / 10000000ULL - 11644473600ULL;\n    filesize = fileinfo.nFileSizeHigh * (MAXDWORD + 1) + fileinfo.nFileSizeLow;\n\n#else\n    if (fstat(stream, &stat_ssb) == -1) {\n        beast_write_log(beast_log_error,\n                \"Failed to readed state buffer from file `%s'\", filename);\n        retval = -1;\n        goto failed;\n    }\n    findkey.device = stat_ssb.st_dev;\n    findkey.inode = stat_ssb.st_ino;\n    findkey.mtime = stat_ssb.st_mtime;\n    filesize = stat_ssb.st_size;\n#endif\n\n    /**\n     * 1) 1 int is dump length,\n     * 2) 1 int is expire time.\n     * 3) 1 int is encrypt type.\n     */\n    headerlen = encrypt_file_header_length + INT_SIZE * 3;\n\n    if (filesize < headerlen) { /* This file is not a encrypt file */\n        retval = -1;\n        goto failed;\n    }\n\n    cache = beast_cache_find(&findkey);\n\n    if (cache != NULL) { /* Found cache */\n        *retbuf = beast_cache_data(cache);\n        *retlen = beast_cache_size(cache);\n        return 0;\n    }\n\n    *free_buffer = 0; /* Set free buffer flag to false */\n\n    /*  Not found cache and decrypt file */\n\n    if ((n = read(stream, header, headerlen)) != headerlen) {\n        beast_write_log(beast_log_error,\n            \"Failed to readed header from file `%s', headerlen:%d, readlen:%d\",\n            filename, headerlen, n);\n        retval = -1;\n        goto failed;\n    }\n\n    /* Not a encrypted file */\n    if (memcmp(header,\n               encrypt_file_header_sign,\n               encrypt_file_header_length))\n    {\n        if (log_normal_file) {\n            beast_write_log(beast_log_error,\n                            \"File `%s' isn't a encrypted file\", filename);\n        }\n\n        retval = -1;\n        goto failed;\n    }\n\n    /* Real php script file's size */\n    reallen = *((int *)&header[encrypt_file_header_length]);\n    expire  = *((int *)&header[encrypt_file_header_length + INT_SIZE]);\n    entype  = *((int *)&header[encrypt_file_header_length + 2 * INT_SIZE]);\n\n    if (little_endian()) {\n        reallen = swab32(reallen);\n        expire  = swab32(expire);\n        entype  = swab32(entype);\n    }\n\n    /* Check file size is vaild */\n    if (beast_max_filesize > 0 && reallen > beast_max_filesize) {\n        beast_write_log(beast_log_error,\n                \"File size `%d' out of max size `%d'\",\n                reallen, beast_max_filesize);\n        retval = -1;\n        goto failed;\n    }\n\n    /* Check file is not expired */\n    if (expire > 0 && expire < beast_now_time) {\n        beast_write_log(beast_log_error, \"File `%s' was expired\", filename);\n        retval = -2;\n        goto failed;\n    }\n\n    *ret_encrypt = encrypt_ops = beast_get_encrypt_algo(entype);\n\n    /**\n     * How many bytes would be read from encrypt file,\n     * subtract encrypt file's header size,\n     * because we had read the header yet.\n     */\n\n    bodylen = filesize - headerlen;\n\n    /* 1) Alloc memory for decrypt file */\n    if (!(buffer = malloc(bodylen))) {\n        beast_write_log(beast_log_error,\n                \"Failed to alloc memory to file `%s' size `%d'\",\n                filename, bodylen);\n        retval = -1;\n        goto failed;\n    }\n\n    /* 2) Read file stream */\n    if (read(stream, buffer, bodylen) != bodylen) {\n        beast_write_log(beast_log_error,\n                \"Failed to readed stream from file `%s'\", filename);\n        retval = -1;\n        goto failed;\n    }\n\n    /* 3) Decrypt file stream */\n    if (encrypt_ops->decrypt(buffer, bodylen, &decbuf, &declen) == -1) {\n        beast_write_log(beast_log_error,\n                \"Failed to decrypted file `%s', using `%s' handler\",\n                filename, encrypt_ops->name);\n        retval = -1;\n        goto failed;\n    }\n\n    free(buffer); /* Buffer don't need right now and free it */\n\n    findkey.fsize = reallen; /* How many size would we alloc from cache */\n\n    /* Try to add decrypt result to cache */\n    if ((cache = beast_cache_create(&findkey))) {\n\n        memcpy(beast_cache_data(cache), decbuf, reallen);\n\n        cache = beast_cache_push(cache); /* Push cache into hash table */\n\n        *retbuf = beast_cache_data(cache);\n        *retlen = beast_cache_size(cache);\n\n        if (encrypt_ops->free) {\n            encrypt_ops->free(decbuf);\n        }\n\n    } else {  /* Return raw buffer and we need free after PHP finished */\n\n        *retbuf = decbuf;\n        *retlen = reallen;\n\n        *free_buffer = 1;\n    }\n\n    return 0;\n\nfailed:\n    if (buffer) {\n        free(buffer);\n    }\n\n    return retval;\n}\n\n\nint beast_super_mkdir(char *path)\n{\n    char *head, *last;\n    char temp[1024];\n\n    for (head = last = path; *last; last++) {\n\n        if (*last == '/') {\n\n            if (last > head) {\n\n                memset(temp, 0, 1024);\n                memcpy(temp, path, last - path);\n\n                if (access(temp, F_OK) == -1) {\n                    if (mkdir(temp, 0777) != 0) {\n                        beast_write_log(beast_log_error,\n                                        \"Failed to make new directory `%s'\",\n                                        temp);\n                        return -1;\n                    }\n                }\n            }\n\n            head = last + 1;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * CGI compile file\n */\nzend_op_array *\ncgi_compile_file(zend_file_handle *h, int type TSRMLS_DC)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n    zend_string *opened_path;\n#else\n    char *opened_path;\n#endif\n    char *buf;\n    int fd;\n    FILE *fp = NULL;\n    int size, free_buffer = 0;\n    int retval;\n    struct beast_ops *ops = NULL;\n    int destroy_file_handler = 0;\n\n#if 0\n    fp = zend_fopen(h->filename, &opened_path TSRMLS_CC);\n#else\n    fp = fopen(h->filename, \"rb\");\n#endif\n    if (fp != NULL) {\n        fd = fileno(fp);\n    } else {\n        goto final;\n    }\n\n    retval = decrypt_file(h->filename, fd, &buf, &size,\n                          &free_buffer, &ops TSRMLS_CC);\n    if (retval == -2) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n            \"This program was expired, please contact administrator\");\n        return NULL;\n    }\n\n    if (retval == -1) {\n#if BEAST_EXECUTE_NORMAL_SCRIPT\n        goto final;\n#else\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n                         \"Not allow execute normal PHP script\");\n        return NULL;\n#endif\n    }\n\n#if BEAST_DEBUG_MODE\n\n    if (beast_debug_mode && beast_debug_path) {\n\n        if (access(beast_debug_path, F_OK) == 0) {\n\n            char realpath[1024];\n\n            sprintf(realpath, \"%s/%s\", beast_debug_path, h->filename);\n\n            if (beast_super_mkdir(realpath) == 0) {\n\n                FILE *debug_fp = fopen(realpath, \"w+\");\n\n                if (debug_fp) {\n                    fwrite(buf, size, 1, debug_fp);\n                    fclose(debug_fp);\n                }\n            }\n        }\n    }\n\n#endif\n\n    if (default_file_handler->open(default_file_handler) == -1 ||\n        default_file_handler->write(default_file_handler, buf, size) == -1 ||\n        default_file_handler->rewind(default_file_handler) == -1)\n    {\n        destroy_file_handler = 1;\n        goto final;\n    }\n\n    if (h->type == ZEND_HANDLE_FP) fclose(h->handle.fp);\n#ifdef ZEND_HANDLE_FD\n    if (h->type == ZEND_HANDLE_FD) close(h->handle.fd);\n#endif\n    /*\n     * Get file handler and free context\n     */\n    switch (default_file_handler->type) {\n    case BEAST_FILE_HANDLER_FP:\n        h->type = ZEND_HANDLE_FP;\n        h->handle.fp = default_file_handler->get_fp(default_file_handler);\n        break;\n#ifdef ZEND_HANDLE_FD\n    case BEAST_FILE_HANDLER_FD:\n        h->type = ZEND_HANDLE_FD;\n        h->handle.fd = default_file_handler->get_fd(default_file_handler);\n        break;\n#endif\n    }\n\nfinal:\n    if (free_buffer && ops) {\n        if (ops->free) {\n            ops->free(buf);\n        }\n    }\n\n    if (fp) fclose(fp);\n\n    if (destroy_file_handler) {\n        default_file_handler->destroy(default_file_handler);\n    }\n\n    return old_compile_file(h, type TSRMLS_CC);\n}\n\n\n/* Configure entries */\n\nvoid beast_atoi(const char *str, int *ret, int *len)\n{\n    const char *ptr = str;\n    char ch;\n    int absolute = 1;\n    int rlen, result;\n\n    ch = *ptr;\n\n    if (ch == '-') {\n        absolute = -1;\n        ++ptr;\n    } else if (ch == '+') {\n        absolute = 1;\n        ++ptr;\n    }\n\n    for (rlen = 0, result = 0; *ptr != '\\0'; ptr++) {\n        ch = *ptr;\n\n        if (ch >= '0' && ch <= '9') {\n            result = result * 10 + (ch - '0');\n            rlen++;\n        } else {\n            break;\n        }\n    }\n\n    if (ret) *ret = absolute * result;\n    if (len) *len = rlen;\n}\n\nZEND_INI_MH(php_beast_cache_size)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    char *value = ZSTR_VAL(new_value);\n    int length = ZSTR_LEN(new_value);\n    int retlen;\n\n    if (length == 0) {\n        return FAILURE;\n    }\n\n    beast_atoi(value, &max_cache_size, &retlen);\n\n    if (retlen > 0 && retlen < length) {\n        switch (value[retlen]) {\n        case 'k':\n        case 'K':\n            max_cache_size *= 1024;\n            break;\n        case 'm':\n        case 'M':\n            max_cache_size *= 1024 * 1024;\n            break;\n        case 'g':\n        case 'G':\n            max_cache_size *= 1024 * 1024 * 1024;\n            break;\n        default:\n            return FAILURE;\n        }\n\n    } else if (retlen == 0) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#else\n\n    int len;\n\n    if (new_value_length == 0) {\n        return FAILURE;\n    }\n\n    beast_atoi(new_value, &max_cache_size, &len);\n\n    if (len > 0 && len < new_value_length) {\n        switch (new_value[len]) {\n        case 'k':\n        case 'K':\n            max_cache_size *= 1024;\n            break;\n        case 'm':\n        case 'M':\n            max_cache_size *= 1024 * 1024;\n            break;\n        case 'g':\n        case 'G':\n            max_cache_size *= 1024 * 1024 * 1024;\n            break;\n        default:\n            return FAILURE;\n        }\n\n    } else if (len == 0) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\nZEND_INI_MH(php_beast_log_file)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return SUCCESS;\n    }\n\n    beast_log_file = estrdup(ZSTR_VAL(new_value));\n    if (beast_log_file == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return SUCCESS;\n    }\n\n    beast_log_file = strdup(new_value);\n    if (beast_log_file == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\n\nZEND_INI_MH(php_beast_log_user)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return SUCCESS;\n    }\n\n    beast_log_user = estrdup(ZSTR_VAL(new_value));\n    if (beast_log_user == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return SUCCESS;\n    }\n\n    beast_log_user = strdup(new_value);\n    if (beast_log_user == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\nZEND_INI_MH(php_beast_log_level)\n{\n    char *level = NULL;\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return SUCCESS;\n    }\n\n    level = ZSTR_VAL(new_value);\n\n#else\n\n    if (new_value_length == 0) {\n        return SUCCESS;\n    }\n\n    level = new_value;\n\n#endif\n    if (level == NULL) {\n        return FAILURE;\n    }\n\n    if (strcasecmp(level, \"debug\") == 0) {\n        log_level = beast_log_debug;\n    } else if (strcasecmp(level, \"notice\") == 0) {\n        log_level = beast_log_notice;\n    } else if (strcasecmp(level, \"error\") == 0) {\n        log_level = beast_log_error;\n    } else {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n}\n\n\nZEND_INI_MH(php_beast_enable)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(ZSTR_VAL(new_value), \"on\")\n        || !strcmp(ZSTR_VAL(new_value), \"1\"))\n    {\n        beast_enable = 1;\n    } else {\n        beast_enable = 0;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(new_value, \"on\")\n        || !strcmp(new_value, \"1\"))\n    {\n        beast_enable = 1;\n    } else {\n        beast_enable = 0;\n    }\n\n    return SUCCESS;\n#endif\n}\n\n\nZEND_INI_MH(php_beast_set_networkcard)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return FAILURE;\n    }\n\n    local_networkcard = estrdup(ZSTR_VAL(new_value));\n    if (local_networkcard == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return FAILURE;\n    }\n\n    local_networkcard = strdup(new_value);\n    if (local_networkcard == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\n\nZEND_INI_MH(php_beast_set_log_normal_file)\n{\n#if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(ZSTR_VAL(new_value), \"on\")\n        || !strcmp(ZSTR_VAL(new_value), \"1\"))\n    {\n        log_normal_file = 1;\n    } else {\n        log_normal_file = 0;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(new_value, \"on\")\n        || !strcmp(new_value, \"1\"))\n    {\n        log_normal_file = 1;\n    } else {\n        log_normal_file = 0;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\n\nZEND_INI_MH(php_beast_debug_path)\n{\n    #if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return SUCCESS;\n    }\n\n    beast_debug_path = estrdup(ZSTR_VAL(new_value));\n    if (beast_debug_path == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return SUCCESS;\n    }\n\n    beast_debug_path = strdup(new_value);\n    if (beast_debug_path == NULL) {\n        return FAILURE;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\n\nZEND_INI_MH(php_beast_debug_mode)\n{\n    #if ZEND_MODULE_API_NO >= 20151012\n\n    if (ZSTR_LEN(new_value) == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(ZSTR_VAL(new_value), \"on\")\n        || !strcmp(ZSTR_VAL(new_value), \"1\"))\n    {\n        beast_debug_mode = 1;\n    } else {\n        beast_debug_mode = 0;\n    }\n\n    return SUCCESS;\n\n#else\n\n    if (new_value_length == 0) {\n        return FAILURE;\n    }\n\n    if (!strcasecmp(new_value, \"on\")\n        || !strcmp(new_value, \"1\"))\n    {\n        beast_debug_mode = 1;\n    } else {\n        beast_debug_mode = 0;\n    }\n\n    return SUCCESS;\n\n#endif\n}\n\n\nPHP_INI_BEGIN()\n    PHP_INI_ENTRY(\"beast.cache_size\", \"10485760\", PHP_INI_ALL,\n          php_beast_cache_size)\n    PHP_INI_ENTRY(\"beast.log_file\", \"./php-beast.log\", PHP_INI_ALL,\n          php_beast_log_file)\n    PHP_INI_ENTRY(\"beast.log_user\", \"root\", PHP_INI_ALL,\n          php_beast_log_user)\n    PHP_INI_ENTRY(\"beast.log_level\", \"notice\", PHP_INI_ALL,\n          php_beast_log_level)\n    PHP_INI_ENTRY(\"beast.enable\", \"1\", PHP_INI_ALL,\n          php_beast_enable)\n    PHP_INI_ENTRY(\"beast.networkcard\", \"eth0\", PHP_INI_ALL,\n          php_beast_set_networkcard)\n    PHP_INI_ENTRY(\"beast.log_normal_file\", \"0\", PHP_INI_ALL,\n          php_beast_set_log_normal_file)\n#if BEAST_DEBUG_MODE\n    PHP_INI_ENTRY(\"beast.debug_path\", \"/tmp\", PHP_INI_ALL,\n          php_beast_debug_path)\n    PHP_INI_ENTRY(\"beast.debug_mode\", \"0\", PHP_INI_ALL,\n          php_beast_debug_mode)\n#endif\nPHP_INI_END()\n\n/* }}} */\n\n\nvoid segmentfault_deadlock_fix(int sig)\n{\n#ifdef PHP_WIN32 // windows not support backtrace\n    beast_write_log(beast_log_error, \"Segmentation fault and fix deadlock\");\n#else\n    void *array[10] = {0};\n    size_t size;\n    char **info = NULL;\n    int i;\n\n    size = backtrace(array, 10);\n    info = backtrace_symbols(array, (int)size);\n\n    beast_write_log(beast_log_error, \"Segmentation fault and fix deadlock\");\n\n    if (info) {\n        for (i = 0; i < size; i++) {\n            beast_write_log(beast_log_error, info[i]);\n        }\n        free(info);\n    }\n#endif\n    beast_mm_unlock();     /* Maybe lock mm so free here */\n    beast_cache_unlock();  /* Maybe lock cache so free here */\n\n    exit(sig);\n}\n\n\nstatic char *get_mac_address(char *networkcard)\n{\n#ifdef PHP_WIN32\n\n    // For windows\n    ULONG size = sizeof(IP_ADAPTER_INFO);\n    int ret, i;\n    char *address = NULL;\n    char buf[128] = { 0 }, *pos;\n\n    PIP_ADAPTER_INFO pCurrentAdapter = NULL;\n    PIP_ADAPTER_INFO pIpAdapterInfo = (PIP_ADAPTER_INFO)malloc(sizeof(*pIpAdapterInfo));\n    if (!pIpAdapterInfo) {\n        beast_write_log(beast_log_error, \"Failed to allocate memory for IP_ADAPTER_INFO\");\n        return NULL;\n    }\n\n    ret = GetAdaptersInfo(pIpAdapterInfo, &size);\n    if (ERROR_BUFFER_OVERFLOW == ret) {\n        // see ERROR_BUFFER_OVERFLOW https://msdn.microsoft.com/en-us/library/aa365917(VS.85).aspx\n        free(pIpAdapterInfo);\n        pIpAdapterInfo = (PIP_ADAPTER_INFO)malloc(size);\n\n        ret = GetAdaptersInfo(pIpAdapterInfo, &size);\n    }\n\n    if (ERROR_SUCCESS != ret) {\n        beast_write_log(beast_log_error, \"Failed to get network adapter information\");\n        free(pIpAdapterInfo);\n        return NULL;\n    }\n\n    pCurrentAdapter = pIpAdapterInfo;\n    do {\n        if (strcmp(pCurrentAdapter->AdapterName, networkcard) == 0) {\n            for (i = 0, pos = buf; i < pCurrentAdapter->AddressLength; i++, pos += 3) {\n                sprintf(pos, \"%.2X-\", (int)pCurrentAdapter->Address[i]);\n            }\n            *(--pos) = '\\0'; // remove last -\n            address = strdup(buf);\n            break;\n        }\n        pCurrentAdapter = pCurrentAdapter->Next;\n    } while (pCurrentAdapter);\n\n    free(pIpAdapterInfo);\n    return address;\n\n#else\n\n    // For linux / unix\n    char netfile[128] = { 0 }, cmd[128] = { 0 }, buf[128] = { 0 };\n    FILE *fp;\n    char *retbuf, *curr, *last;\n\n    snprintf(netfile, 128, \"/sys/class/net/%s/address\", networkcard);\n\n    if (access((const char *)netfile, R_OK) != 0) { /* File not exists */\n        snprintf(cmd, 128, \"ifconfig %s|awk '/ether/ {print $2}'\", networkcard);\n    } else {\n        snprintf(cmd, 128, \"cat %s\", netfile);\n    }\n\n    fp = popen(cmd, \"r\");\n    if (!fp) {\n        return NULL;\n    }\n\n    retbuf = fgets(buf, 128, fp);\n\n    for (curr = buf, last = NULL; *curr; curr++) {\n        if (*curr != '\\n') {\n            last = curr;\n        }\n    }\n\n    if (!last) {\n        return NULL;\n    }\n\n    for (last += 1; *last; last++) {\n        *last = '\\0';\n    }\n\n    pclose(fp);\n\n    return strdup(buf);\n\n#endif\n}\n\nstatic int validate_networkcard()\n{\n    extern char *allow_networkcards[];\n    char **ptr;\n    char *networkcard_start, *networkcard_end;\n    int endof_networkcard = 0;\n    int active = 0;\n    char *address;\n\n    for (ptr = allow_networkcards; *ptr; ptr++, active++);\n\n    if (!active) {\n        return 0;\n    }\n\n    networkcard_start = networkcard_end = local_networkcard;\n\n    while (1) {\n        while (*networkcard_end && *networkcard_end != ',') {\n            networkcard_end++;\n        }\n\n        if (networkcard_start == networkcard_end) { /* empty string */\n            break;\n        }\n\n        if (*networkcard_end == ',') {\n            *networkcard_end = '\\0';\n        }\n        else {\n            endof_networkcard = 1;\n        }\n\n        address = get_mac_address(networkcard_start);\n        if (address) {\n            for (ptr = allow_networkcards; *ptr; ptr++) {\n                if (!strcasecmp(address, *ptr)) {\n                    free(address); /* release buffer */\n                    return 0;\n                }\n            }\n            free(address);\n        }\n\n        if (endof_networkcard) {\n            break;\n        }\n\n        networkcard_start = networkcard_end + 1;\n    }\n\n    return -1;\n}\n\n/* {{{ PHP_MINIT_FUNCTION\n */\nPHP_MINIT_FUNCTION(beast)\n{\n    int i;\n#ifdef PHP_WIN32\n    SYSTEM_INFO info;\n#endif\n\n    /* If you have INI entries, uncomment these lines */\n    REGISTER_INI_ENTRIES();\n\n    if (!beast_enable) {\n        return SUCCESS;\n    }\n\n    if (validate_networkcard() == -1) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n                         \"Not allow run at this computer\");\n        return FAILURE;\n    }\n\n    if ((encrypt_file_header_length + INT_SIZE * 2) > HEADER_MAX_SIZE) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR,\n            \"Header size overflow max size `%d'\", HEADER_MAX_SIZE);\n        return FAILURE;\n    }\n\n    /* Check module support the max file size */\n    for (i = 0; ; i++) {\n        default_file_handler = file_handlers[i];\n        if (!default_file_handler ||\n            !strcasecmp(file_handler_switch, default_file_handler->name))\n        {\n            break;\n        }\n    }\n\n    if (!default_file_handler) {\n        return FAILURE;\n    }\n\n    beast_max_filesize = default_file_handler->check();\n    if (beast_max_filesize == -1) {\n        return FAILURE;\n    }\n\n    if (beast_cache_init(max_cache_size) == -1) {\n        php_error_docref(NULL TSRMLS_CC,\n                         E_ERROR, \"Unable initialize cache for beast\");\n        return FAILURE;\n    }\n\n    if (beast_log_init(beast_log_file, log_level) == -1) {\n        php_error_docref(NULL TSRMLS_CC,\n                         E_ERROR, \"Unable open log file for beast\");\n        return FAILURE;\n    }\n\n#ifndef PHP_WIN32\n    if (getuid() == 0 && beast_log_user) { /* Change log file owner user */\n        struct passwd *pwd;\n\n        pwd = getpwnam((const char *)beast_log_user);\n        if (!pwd) {\n            php_error_docref(NULL TSRMLS_CC,\n                             E_ERROR, \"Unable get user passwd information\");\n            return FAILURE;\n        }\n\n        if (beast_log_chown(pwd->pw_uid, pwd->pw_gid) != 0) {\n            php_error_docref(NULL TSRMLS_CC,\n                             E_ERROR, \"Unable change log file owner\");\n            return FAILURE;\n        }\n    }\n#endif\n\n    old_compile_file = zend_compile_file;\n    zend_compile_file = cgi_compile_file;\n\n#ifdef PHP_WIN32\n    GetSystemInfo(&info);\n    beast_ncpu = info.dwNumberOfProcessors;\n#else\n    beast_ncpu = sysconf(_SC_NPROCESSORS_ONLN); /* Get CPU nums */\n#endif\n    if (beast_ncpu <= 0) {\n        beast_ncpu = 1;\n    }\n\n    signal(SIGSEGV, segmentfault_deadlock_fix);\n\n    REGISTER_LONG_CONSTANT(\"BEAST_ENCRYPT_TYPE_DES\",\n        BEAST_ENCRYPT_TYPE_DES, CONST_CS|CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"BEAST_ENCRYPT_TYPE_AES\",\n        BEAST_ENCRYPT_TYPE_AES, CONST_CS|CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"BEAST_ENCRYPT_TYPE_BASE64\",\n        BEAST_ENCRYPT_TYPE_BASE64, CONST_CS|CONST_PERSISTENT);\n\n    beast_write_log(beast_log_debug, \"Beast module was initialized\");\n\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nPHP_MSHUTDOWN_FUNCTION(beast)\n{\n    /* uncomment this line if you have INI entries */\n    UNREGISTER_INI_ENTRIES();\n\n    if (!beast_enable) {\n        return SUCCESS;\n    }\n\n    beast_cache_destroy();\n    beast_log_destroy();\n\n    zend_compile_file = old_compile_file;\n\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(beast)\n{\n    if (beast_pid == -1) {\n        beast_pid = getpid();\n    }\n\n    beast_now_time = time(NULL); /* Update now time */\n\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_RSHUTDOWN_FUNCTION\n */\nPHP_RSHUTDOWN_FUNCTION(beast)\n{\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(beast)\n{\n    php_info_print_table_start();\n    php_info_print_table_header(2,\n        \"beast V\" BEAST_VERSION \" support\", \"enabled\");\n    php_info_print_table_end();\n\n    DISPLAY_INI_ENTRIES();\n}\n/* }}} */\n\n\nPHP_FUNCTION(beast_file_expire)\n{\n    char *file;\n    int file_len;\n    char header[HEADER_MAX_SIZE] = {0};\n    int header_len;\n    signed long expire = 0;\n    int fd = -1;\n    char *string;\n    char *format = \"Y-m-d H:i:s\";\n\n#if ZEND_MODULE_API_NO >= 20151012\n\n    zend_string *input_file;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"S\",\n                              &input_file TSRMLS_CC) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    file     = ZSTR_VAL(input_file);\n    file_len = ZSTR_LEN(input_file);\n\n#else\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n                              &file, &file_len TSRMLS_CC) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n#endif\n\n    fd = open(file, O_RDONLY);\n    if (fd < 0) {\n        goto error;\n    }\n\n    header_len = encrypt_file_header_length + INT_SIZE * 2;\n\n    if (read(fd, header, header_len) != header_len\n        || memcmp(header, encrypt_file_header_sign, encrypt_file_header_length))\n    {\n        goto error;\n    }\n\n    close(fd);\n\n    expire = *((int *)&header[encrypt_file_header_length + INT_SIZE]);\n\n    if (little_endian()) {\n        expire = swab32(expire);\n    }\n\n    if (expire > 0) {\n        string = (char *)php_format_date(format, strlen(format), expire, 1 TSRMLS_CC);\n        BEAST_RETURN_STRING(string, 0);\n    } else {\n        BEAST_RETURN_STRING(\"+Infinity\", 1);\n    }\n\nerror:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    RETURN_FALSE;\n}\n\n\nPHP_FUNCTION(beast_encode_file)\n{\n    char *input, *output;\n    int input_len, output_len;\n    long expire = 0;\n    long encrypt_type = BEAST_ENCRYPT_TYPE_DES;\n    int ret;\n\n#if ZEND_MODULE_API_NO >= 20151012\n\n    zend_string *in, *out;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"SS|ll\",\n        &in, &out, &expire, &encrypt_type) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    input      = ZSTR_VAL(in);\n    output     = ZSTR_VAL(out);\n    input_len  = ZSTR_LEN(in);\n    output_len = ZSTR_LEN(out);\n\n#else\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|ll\",\n            &input, &input_len, &output, &output_len,\n            &expire, &encrypt_type TSRMLS_CC) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n#endif\n\n    if (encrypt_type <= 0\n        || encrypt_type >= BEAST_ENCRYPT_TYPE_ERROR)\n    {\n        RETURN_FALSE;\n    }\n\n    ret = encrypt_file(input, output,\n                      (int)expire, (int)encrypt_type TSRMLS_CC);\n    if (ret == -1) {\n        RETURN_FALSE;\n    }\n\n    RETURN_TRUE;\n}\n\n\nPHP_FUNCTION(beast_avail_cache)\n{\n    RETURN_LONG(beast_mm_availspace());\n}\n\n\nPHP_FUNCTION(beast_support_filesize)\n{\n    RETURN_LONG(beast_max_filesize);\n}\n\n\nPHP_FUNCTION(beast_clean_cache)\n{\n    beast_cache_flush();\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker expandtab\n * vim<600: noet sw=4 ts=4\n */\n"
        },
        {
          "name": "beast_log.c",
          "type": "blob",
          "size": 1.4912109375,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#ifdef PHP_WIN32\n\n#else\n#include <unistd.h>\n#endif\n#include \"main/php_reentrancy.h\"\n#include \"beast_log.h\"\n\nstatic FILE *beast_log_fp = NULL;\nstatic int log_level = beast_log_notice;\n\nint beast_log_init(char *log_file, int level)\n{\n    if (!log_file || strlen(log_file) == 0) {\n        return 0;\n    }\n\n    beast_log_fp = fopen(log_file, \"a+\");\n    if (!beast_log_fp)\n        return -1;\n    log_level = level;\n    return 0;\n}\n\n\nint beast_log_chown(uid_t uid, gid_t gid)\n{\n#ifdef PHP_WIN32\n\treturn 1;\n#else\n    int fd;\n\n    if (!beast_log_fp) {\n        return 0;\n    }\n\n    fd = fileno(beast_log_fp);\n\n    return fchown(fd, uid, gid);\n#endif\n}\n\n\nvoid beast_write_log(beast_log_level level, const char *fmt, ...)\n{\n\n    struct tm local_tm, *result_tm;\n    time_t the_time;\n    char buf[64];\n    char *headers[] = {\"DEBUG\", \"NOTICE\", \"ERROR\"};\n    va_list ap;\n\n    if (beast_log_fp == NULL ||\n        level > beast_log_error ||\n        level < log_level)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n\n    the_time = time(NULL);\n    result_tm = php_localtime_r(&the_time, &local_tm);\n    strftime(buf, 64, \"%d %b %H:%M:%S\", result_tm);\n\n    fprintf(beast_log_fp, \"[%s] %s: \", buf, headers[level]);\n    vfprintf(beast_log_fp, fmt, ap);\n    fprintf(beast_log_fp, \"\\n\");\n    fflush(beast_log_fp);\n\n    va_end(ap);\n\n    return;\n}\n\nvoid beast_log_destroy()\n{\n    if (beast_log_fp) {\n        fclose(beast_log_fp);\n        beast_log_fp = NULL;\n    }\n}\n"
        },
        {
          "name": "beast_log.h",
          "type": "blob",
          "size": 0.4189453125,
          "content": "#ifndef BEAST_LOG_H\n#define BEAST_LOG_H\n\n#ifdef PHP_WIN32\n#include \"win95nt.h\"\n#else\n#include <unistd.h>\n#endif\n\ntypedef enum {\n    beast_log_debug,  /* 0 */\n    beast_log_notice, /* 1 */\n    beast_log_error   /* 2 */\n} beast_log_level;\n\nint beast_log_init(char *log_file, int level);\nint beast_log_chown(uid_t uid, gid_t gid);\nvoid beast_write_log(beast_log_level level, const char *fmt, ...);\nvoid beast_log_destroy();\n\n#endif\n"
        },
        {
          "name": "beast_mm.c",
          "type": "blob",
          "size": 9.52734375,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2007 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Liexusong <liexusong@qq.com>                                 |\n  +----------------------------------------------------------------------+\n*/\n\n/*\n * The simple share memory manager algorithm\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#ifdef PHP_WIN32\n#include <Windows.h>\n#else\n#include <sys/mman.h>\n#endif\n\n#include \"spinlock.h\"\n#include \"beast_log.h\"\n#include \"shm.h\"\n\n#define BEAST_SEGMENT_DEFAULT_SIZE (256 * 1024)\n\n#define BLOCKAT(addr, offset)  ((beast_block_t *)((char *)(addr) + (offset)))\n\n#ifdef max\n#undef max\n#endif\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct beast_header_s {\n    int segsize;    /* size of entire segment */\n    int avail;      /* bytes available memorys */\n} beast_header_t;\n\ntypedef struct beast_block_s {\n    int size;       /* size of this block */\n    int next;       /* offset in segment of next free block */\n} beast_block_t;\n\nstatic int beast_mm_initialized = 0;\nstatic void *beast_mm_block = NULL;\nstatic int beast_mm_block_size = 0;\nstatic beast_atomic_t *mm_lock;\nextern int beast_pid;\n\nvoid beast_mm_lock()\n{\n    beast_spinlock(mm_lock, beast_pid);\n}\n\nvoid beast_mm_unlock()\n{\n    beast_spinunlock(mm_lock, beast_pid);\n}\n\n/*\n * memory align function\n * @param bits, align bits\n */\nstatic inline int beast_mm_alignmem(int bits)\n{\n    typedef union {\n        void* p;\n        int i;\n        long l;\n        double d;\n        void (*f)();\n    } beast_word_t; /* may be 8 bits */\n\n    return sizeof(beast_word_t) * (1 + ((bits - 1) / sizeof(beast_word_t)));\n}\n\nstatic int beast_mm_allocate(void *shmaddr, int size)\n{\n    beast_header_t *header;       /* header of shared memory segment */\n    beast_block_t *prv;           /* block prior to working block */\n    beast_block_t *cur;           /* working block in list */\n    beast_block_t *prvbestfit;    /* block before best fit */\n    int realsize;                 /* actual size of block needed, including header */\n    int minsize;                  /* for finding best fit */\n    int offset;\n\n    /* Realsize must be aligned to a word boundary on some architectures. */\n    realsize = size + beast_mm_alignmem(sizeof(int));\n    realsize = beast_mm_alignmem(max(realsize, sizeof(beast_block_t)));\n\n    /*\n     * First, insure that the segment contains at least realsize free bytes,\n     * even if they are not contiguous.\n     */\n    header = (beast_header_t *)shmaddr;\n    if (header->avail < realsize) {\n        beast_write_log(beast_log_error,\n                        \"Not enough memory for beast_mm_alloc()\");\n        return -1;\n    }\n\n    prvbestfit = 0;    /* Best block prev's node */\n    minsize = INT_MAX;\n\n    prv = BLOCKAT(shmaddr, sizeof(beast_header_t)); /* Free list header */\n\n    while (prv->next != 0) {\n        cur = BLOCKAT(shmaddr, prv->next); /* Current active block */\n        if (cur->size == realsize) {\n            prvbestfit = prv;\n            break;\n        }\n        else if (cur->size > (sizeof(beast_block_t) + realsize)\n                 && cur->size < minsize)\n        {\n            prvbestfit = prv;\n            minsize = cur->size;\n        }\n        prv = cur;\n    }\n\n    if (prvbestfit == 0) { /* Not found best block */\n        return -1;\n    }\n\n    prv = prvbestfit;\n    cur = BLOCKAT(shmaddr, prv->next);\n\n    /* update the block header */\n    header->avail -= realsize;\n\n    if (cur->size == realsize) {\n        prv->next = cur->next;\n\n    } else {\n        beast_block_t *nxt;   /* The new block (chopped part of cur) */\n        int nxtoffset;        /* Offset of the block currently after cur */\n        int oldsize;          /* Size of cur before split */\n\n        /* bestfit is too big; split it into two smaller blocks */\n        nxtoffset = cur->next;\n        oldsize = cur->size;\n        prv->next += realsize;\n        cur->size = realsize;\n        nxt = BLOCKAT(shmaddr, prv->next);\n        nxt->next = nxtoffset;\n        nxt->size = oldsize - realsize;\n    }\n\n    /* skip size field */\n\n    offset = (char *)cur - (char *)shmaddr;\n\n    return offset + beast_mm_alignmem(sizeof(int));\n}\n\nstatic int beast_mm_deallocate(void *shmaddr, int offset)\n{\n    beast_header_t *header;   /* Header of shared memory segment */\n    beast_block_t *cur;       /* The new block to insert */\n    beast_block_t *prv;       /* The block before cur */\n    beast_block_t *nxt;       /* The block after cur */\n    int size;                 /* Size of deallocated block */\n\n    offset -= beast_mm_alignmem(sizeof(int)); /* Really offset */\n\n    /* Find position of new block in free list */\n    prv = BLOCKAT(shmaddr, sizeof(beast_header_t));\n\n    while (prv->next != 0 && prv->next < offset) {\n        prv = BLOCKAT(shmaddr, prv->next);\n    }\n\n    /* Insert new block after prv */\n    cur = BLOCKAT(shmaddr, offset);\n    cur->next = prv->next;\n    prv->next = offset;\n\n    /* Update the block header */\n    header = (beast_header_t *)shmaddr;\n    header->avail += cur->size;\n    size = cur->size;\n\n    if (((char *)prv) + prv->size == (char *) cur) {\n        /* cur and prv share an edge, combine them */\n        prv->size += cur->size;\n        prv->next = cur->next;\n        cur = prv;\n    }\n\n    nxt = BLOCKAT(shmaddr, cur->next);\n    if (((char *)cur) + cur->size == (char *) nxt) {\n        /* cur and nxt shared an edge, combine them */\n        cur->size += nxt->size;\n        cur->next = nxt->next;\n    }\n\n    return size;\n}\n\nvoid beast_mm_reinit()\n{\n    beast_header_t *header;\n    beast_block_t  *block;\n\n    header = (beast_header_t *)beast_mm_block;\n    header->segsize = beast_mm_block_size;\n    header->avail = beast_mm_block_size\n                    - sizeof(beast_header_t)\n                    - sizeof(beast_block_t)\n                    - beast_mm_alignmem(sizeof(int));\n\n    /* The free list head block node */\n    block = BLOCKAT(beast_mm_block, sizeof(beast_header_t));\n    block->size = 0;\n    block->next = sizeof(beast_header_t) + sizeof(beast_block_t);\n\n    /* The avail block */\n    block = BLOCKAT(beast_mm_block, block->next);\n    block->size = header->avail;\n    block->next = 0;\n}\n\n/*\n * Init memory manager\n */\nint beast_mm_init(int block_size)\n{\n    if (beast_mm_initialized) {\n        return 0;\n    }\n\n    /* Init memory manager lock */\n    mm_lock = (int *)beast_shm_alloc(sizeof(beast_atomic_t));\n    if (!mm_lock) {\n        beast_write_log(beast_log_error,\n                        \"Unable alloc share memory for memory manager lock\");\n        return -1;\n    }\n\n    *mm_lock = 0;\n\n    /* Init share memory for beast */\n    if (block_size < BEAST_SEGMENT_DEFAULT_SIZE) {\n        beast_mm_block_size = BEAST_SEGMENT_DEFAULT_SIZE;\n    } else {\n        beast_mm_block_size = block_size;\n    }\n\n    beast_mm_block = (void *)beast_shm_alloc(beast_mm_block_size);\n    if (!beast_mm_block) {\n        beast_write_log(beast_log_error,\n                        \"Unable alloc share memory for beast\");\n        beast_shm_free((void *)mm_lock, sizeof(beast_atomic_t));\n        return -1;\n    }\n\n    beast_mm_reinit();\n\n    beast_mm_initialized = 1;\n\n    return 0;\n}\n\nvoid *beast_mm_malloc(int size)\n{\n    int offset;\n    void *p = NULL;\n\n    beast_mm_lock();\n\n    offset = beast_mm_allocate(beast_mm_block, size);\n    if (offset != -1) {\n        p = (void *)(((char *)beast_mm_block) + offset);\n    }\n\n    beast_mm_unlock();\n\n    return p;\n}\n\nvoid *beast_mm_calloc(int size)\n{\n    int offset;\n    void *p = NULL;\n\n    beast_mm_lock();\n\n    offset = beast_mm_allocate(beast_mm_block, size);\n    if (offset != -1) {\n        p = (void *)(((char *)beast_mm_block) + offset);\n    }\n\n    beast_mm_unlock();\n\n    if (NULL != p) {\n        memset(p, 0, size);\n    }\n\n    return p;\n}\n\nvoid beast_mm_free(void *p)\n{\n    int offset;\n\n    offset = (unsigned int)((char *)p - (char *)beast_mm_block);\n    if (offset <= 0) {\n        return;\n    }\n\n    beast_mm_lock();\n    beast_mm_deallocate(beast_mm_block, offset);\n    beast_mm_unlock();\n}\n\nvoid beast_mm_flush()\n{\n    beast_mm_lock();\n    beast_mm_reinit();\n    beast_mm_unlock();\n}\n\n/*\n * Get the avail's memory space\n */\nint beast_mm_availspace()\n{\n    int size;\n    beast_header_t *header = (beast_header_t *)beast_mm_block;\n\n    beast_mm_lock();\n    size = header->avail;\n    beast_mm_unlock();\n\n    return size;\n}\n\n/*\n * Don't locked here, because the segsize not change forever\n */\nint beast_mm_realspace()\n{\n    int size;\n\n    beast_mm_lock();\n    size = ((beast_header_t *)beast_mm_block)->segsize;\n    beast_mm_unlock();\n\n    return size;\n}\n\n/*\n * Destroy memory's manager\n */\nvoid beast_mm_destroy()\n{\n    if (beast_mm_initialized) {\n        beast_shm_free((void *)beast_mm_block, beast_mm_block_size);\n        beast_shm_free((void *)mm_lock, sizeof(beast_atomic_t));\n        beast_mm_initialized = 0;\n    }\n}\n"
        },
        {
          "name": "beast_mm.h",
          "type": "blob",
          "size": 0.3212890625,
          "content": "#ifndef __BEAST_MM_H\n#define __BEAST_MM_H\n\nint beast_mm_init(int block_size);\nvoid *beast_mm_malloc(int size);\nvoid *beast_mm_calloc(int size);\nvoid beast_mm_free(void *p);\nvoid beast_mm_flush();\nint beast_mm_availspace();\nint beast_mm_realspace();\nvoid beast_mm_destroy();\n\nvoid beast_mm_lock();\nvoid beast_mm_unlock();\n\n#endif\n"
        },
        {
          "name": "beast_module.h",
          "type": "blob",
          "size": 0.576171875,
          "content": "#ifndef __BEAST_MODULE_H\n#define __BEAST_MODULE_H\n\ntypedef int beast_encrypt_op_t(char *inbuf, int inlen,\n    char **outbuf, int *outlen);\ntypedef int beast_decrypt_op_t(char *inbuf, int inlen,\n    char **outbuf, int *outlen);\ntypedef void beast_free_buf_t(void *buf);\n\ntypedef enum {\n  BEAST_ENCRYPT_TYPE_DES = 1,\n  BEAST_ENCRYPT_TYPE_AES,\n  BEAST_ENCRYPT_TYPE_BASE64,\n  BEAST_ENCRYPT_TYPE_ERROR\n} beast_encrypt_type_t;\n\nstruct beast_ops {\n    char *name;\n    beast_encrypt_op_t *encrypt;\n    beast_decrypt_op_t *decrypt;\n    beast_free_buf_t *free;\n    struct beast_ops *next;\n};\n\n#endif\n"
        },
        {
          "name": "cache.c",
          "type": "blob",
          "size": 6.1328125,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2007 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Liexusong <280259971@qq.com>                                 |\n  +----------------------------------------------------------------------+\n*/\n\n#include <stdlib.h>\n#include <sys/types.h>\n#ifndef PHP_WIN32\n#include <sys/mman.h>\n#endif\n\n#include \"beast_mm.h\"\n#include \"spinlock.h\"\n#include \"php.h\"\n#include \"cache.h\"\n#include \"beast_log.h\"\n#include \"shm.h\"\n\n#define BUCKETS_DEFAULT_SIZE 8191\n\nstatic int beast_cache_initialization = 0;\nstatic cache_item_t **beast_cache_buckets = NULL;\nstatic beast_atomic_t *cache_lock;\nextern int beast_pid;\n\nvoid beast_cache_lock()\n{\n    beast_spinlock(cache_lock, beast_pid);\n}\n\nvoid beast_cache_unlock()\n{\n    beast_spinunlock(cache_lock, beast_pid);\n}\n\nstatic inline unsigned int\nbeast_cache_hash(cache_key_t *key)\n{\n    unsigned int retval;\n\n    retval = (unsigned int)key->device * 3\n           + (unsigned int)key->inode * 7;\n\n    return retval;\n}\n\n\nint beast_cache_init(int size)\n{\n    int index, bucket_size;\n\n    if (beast_cache_initialization) {\n        return 0;\n    }\n\n    if (beast_mm_init(size) == -1) {\n        return -1;\n    }\n\n    /* init cache lock */\n    cache_lock = (int *)beast_shm_alloc(sizeof(int));\n    if (!cache_lock) {\n        beast_write_log(beast_log_error,\n                        \"Unable alloc share memory for cache lock\");\n        beast_mm_destroy();\n        return -1;\n    }\n\n    *cache_lock = 0;\n\n    /* init cache buckets's memory */\n    bucket_size = sizeof(cache_item_t *) * BUCKETS_DEFAULT_SIZE;\n\n    beast_cache_buckets = (cache_item_t **)beast_shm_alloc(bucket_size);\n\n    if (!beast_cache_buckets) {\n        beast_write_log(beast_log_error,\n                        \"Unable alloc share memory for cache buckets\");\n        beast_shm_free((void *)cache_lock, sizeof(int));\n        beast_mm_destroy();\n        return -1;\n    }\n\n    for (index = 0; index < BUCKETS_DEFAULT_SIZE; index++) {\n        beast_cache_buckets[index] = NULL;\n    }\n\n    beast_cache_initialization = 1;\n\n    return 0;\n}\n\n\ncache_item_t *beast_cache_find(cache_key_t *key)\n{\n    unsigned int hashval = beast_cache_hash(key);\n    unsigned int index = hashval % BUCKETS_DEFAULT_SIZE;\n    cache_item_t *item, *temp;\n\n    beast_cache_lock();\n\n    item = beast_cache_buckets[index];\n    while (item) {\n        if (item->key.device == key->device &&\n             item->key.inode == key->inode)\n        {\n            break;\n        }\n        item = item->next;\n    }\n\n    if (item && item->key.mtime < key->mtime) /* cache exprie */\n    {\n        temp = beast_cache_buckets[index];\n        if (temp == item) { /* the header node */\n            beast_cache_buckets[index] = item->next;\n        } else {\n            while (temp->next != item) { /* find prev node */\n                temp = temp->next;\n            }\n            temp->next = item->next;\n        }\n\n        beast_mm_free(item);\n\n        item = NULL;\n    }\n\n    beast_cache_unlock();\n\n    return item;\n}\n\n\ncache_item_t *beast_cache_create(cache_key_t *key)\n{\n    cache_item_t *item;\n    int msize, bsize;\n\n    msize = sizeof(*item) + key->fsize;\n    bsize = sizeof(cache_item_t *) * BUCKETS_DEFAULT_SIZE;\n\n    if ((msize + bsize) > beast_mm_realspace()) {\n        beast_write_log(beast_log_error,\n                        \"Cache item size too big\");\n        return NULL;\n    }\n\n    item = beast_mm_malloc(msize);\n\n    if (!item) {\n        beast_write_log(beast_log_notice,\n                        \"Not enough memory for alloc cache\");\n        return NULL;\n    }\n\n    item->key.device = key->device;\n    item->key.inode = key->inode;\n    item->key.fsize = key->fsize;\n    item->key.mtime = key->mtime;\n\n    item->next = NULL;\n\n    return item;\n}\n\n\n/*\n * Push cache item into cache manager,\n * this function return a cache item,\n * may be return value not equals push item,\n * so we must use return value.\n */\ncache_item_t *beast_cache_push(cache_item_t *item)\n{\n    unsigned int hashval = beast_cache_hash(&item->key);\n    unsigned int index = hashval % BUCKETS_DEFAULT_SIZE;\n\n    beast_cache_lock();\n\n    item->next = beast_cache_buckets[index];\n    beast_cache_buckets[index] = item;\n\n    beast_cache_unlock();\n\n    return item;\n}\n\n\nint beast_cache_destroy()\n{\n    if (!beast_cache_initialization) {\n        return 0;\n    }\n\n    beast_mm_destroy(); /* Destroy memory manager */\n\n    /* Free cache buckets's mmap memory */\n    beast_shm_free((void *)beast_cache_buckets,\n            sizeof(cache_item_t *) * BUCKETS_DEFAULT_SIZE);\n    beast_shm_free((void *)cache_lock, sizeof(int));\n    beast_cache_initialization = 0;\n\n    return 0;\n}\n\n\nvoid beast_cache_info(zval *retval)\n{\n    char key[128];\n    int i;\n    cache_item_t *item;\n\n    beast_cache_lock();\n\n    for (i = 0; i < BUCKETS_DEFAULT_SIZE; i++) {\n        item = beast_cache_buckets[i];\n        while (item) {\n            sprintf(key, \"{device(%d)#inode(%d)}\",\n                  item->key.device, item->key.inode);\n            add_assoc_long(retval, key, item->key.fsize);\n            item = item->next;\n        }\n    }\n\n    beast_cache_unlock();\n}\n\nvoid beast_cache_flush()\n{\n    int index;\n\n    beast_cache_lock();\n\n    /* Flush hash buckets */\n    for (index = 0; index < BUCKETS_DEFAULT_SIZE; index++) {\n        beast_cache_buckets[index] = NULL;\n    }\n\n    /* Flush share memory */\n    beast_mm_flush();\n\n    beast_cache_unlock();\n}\n"
        },
        {
          "name": "cache.h",
          "type": "blob",
          "size": 0.6767578125,
          "content": "#ifndef __BEAST_CACHE_H\n#define __BEAST_CACHE_H\n\ntypedef struct cache_key_s {\n    int device;\n    int inode;\n    int mtime;\n    int fsize;\n} cache_key_t;\n\n\ntypedef struct cache_item_s {\n    cache_key_t key;\n    struct cache_item_s *next;\n    char data[0];\n} cache_item_t;\n\n\n#define beast_cache_data(item)  (item)->data\n#define beast_cache_size(item)  (item)->key.fsize\n\nint beast_cache_init();\ncache_item_t *beast_cache_find(cache_key_t *key);\ncache_item_t *beast_cache_create(cache_key_t *key);\ncache_item_t *beast_cache_push(cache_item_t *item);\nint beast_cache_destroy();\nvoid beast_cache_flush();\n\nvoid beast_cache_lock();\nvoid beast_cache_unlock();\nvoid beast_cache_info(zval *);\n\n#endif\n"
        },
        {
          "name": "config.m4",
          "type": "blob",
          "size": 2.84375,
          "content": "dnl $Id$\ndnl config.m4 for extension beast\n\ndnl Comments in this file start with the string 'dnl'.\ndnl Remove where necessary. This file will not work\ndnl without editing.\n\ndnl If your extension references something external, use with:\n\ndnl PHP_ARG_WITH(beast, for beast support,\ndnl Make sure that the comment is aligned:\ndnl [  --with-beast             Include beast support])\n\ndnl Otherwise use enable:\n\nPHP_ARG_ENABLE(beast, whether to enable beast support,\ndnl Make sure that the comment is aligned:\n[  --enable-beast           Enable beast support])\n\nPHP_ARG_ENABLE(beast-debug, whether to enable beast debug mode,\ndnl Make sure that the comment is aligned:\n[  --enable-beast-debug            Enable beast debug mode], no, no)\n\nPHP_ARG_ENABLE(execute-normal-script, whether to enable execute normal PHP script mode,\ndnl Make sure that the comment is aligned:\n[  --enable-execute-normal-script  Enable execute normal PHP script], yes, yes)\n\nif test \"$PHP_BEAST\" != \"no\"; then\n  dnl Write more examples of tests here...\n\n  if test \"$PHP_BEAST_DEBUG\" != \"yes\"; then\n    AC_DEFINE(BEAST_DEBUG_MODE, 0, [ ])\n  else\n    AC_DEFINE(BEAST_DEBUG_MODE, 1, [ ])\n  fi\n\n  if test \"$PHP_EXECUTE_NORMAL_SCRIPT\" != \"yes\"; then\n    AC_DEFINE(BEAST_EXECUTE_NORMAL_SCRIPT, 0, [ ])\n  else\n    AC_DEFINE(BEAST_EXECUTE_NORMAL_SCRIPT, 1, [ ])\n  fi\n\n  dnl # --with-beast -> check with-path\n  dnl SEARCH_PATH=\"/usr/local /usr\"     # you might want to change this\n  dnl SEARCH_FOR=\"/include/beast.h\"  # you most likely want to change this\n  dnl if test -r $PHP_BEAST/$SEARCH_FOR; then # path given as parameter\n  dnl   BEAST_DIR=$PHP_BEAST\n  dnl else # search default path list\n  dnl   AC_MSG_CHECKING([for beast files in default path])\n  dnl   for i in $SEARCH_PATH ; do\n  dnl     if test -r $i/$SEARCH_FOR; then\n  dnl       BEAST_DIR=$i\n  dnl       AC_MSG_RESULT(found in $i)\n  dnl     fi\n  dnl   done\n  dnl fi\n  dnl\n  dnl if test -z \"$BEAST_DIR\"; then\n  dnl   AC_MSG_RESULT([not found])\n  dnl   AC_MSG_ERROR([Please reinstall the beast distribution])\n  dnl fi\n\n  dnl # --with-beast -> add include path\n  dnl PHP_ADD_INCLUDE($BEAST_DIR/include)\n\n  dnl # --with-beast -> check for lib and symbol presence\n  dnl LIBNAME=beast # you may want to change this\n  dnl LIBSYMBOL=beast # you most likely want to change this\n\n  dnl PHP_CHECK_LIBRARY($LIBNAME,$LIBSYMBOL,\n  dnl [\n  dnl   PHP_ADD_LIBRARY_WITH_PATH($LIBNAME, $BEAST_DIR/lib, BEAST_SHARED_LIBADD)\n  dnl   AC_DEFINE(HAVE_BEASTLIB,1,[ ])\n  dnl ],[\n  dnl   AC_MSG_ERROR([wrong beast lib version or lib not found])\n  dnl ],[\n  dnl   -L$BEAST_DIR/lib -lm -ldl\n  dnl ])\n  dnl\n  dnl PHP_SUBST(BEAST_SHARED_LIBADD)\n\n  PHP_NEW_EXTENSION(beast, beast.c aes_algo_handler.c des_algo_handler.c base64_algo_handler.c beast_mm.c spinlock.c cache.c beast_log.c global_algo_modules.c header.c networkcards.c tmpfile_file_handler.c pipe_file_handler.c file_handler_switch.c shm.c, $ext_shared)\nfi\n"
        },
        {
          "name": "config.w32",
          "type": "blob",
          "size": 0.607421875,
          "content": "// $Id$\n// vim:ft=javascript\n\n// If your extension references something external\nARG_WITH(\"beast\", \"for beast support\", \"yes,shared\");\n\n\nARG_ENABLE(\"beast\", \"enable beast support\", \"yes,shared\");\n\nARG_ENABLE(\"beast-debug\", \"enable beast debug mode\", \"no\");\n\nif (PHP_BEAST != \"no\") {\n\tif (PHP_BEAST_DEBUG != \"no\") {\n\t\tAC_DEFINE('BEAST_DEBUG_MODE', 1, 'Debug support in beast');\n\t}\n\t\n\tEXTENSION(\"beast\", \"beast.c aes_algo_handler.c des_algo_handler.c base64_algo_handler.c beast_mm.c spinlock.c cache.c beast_log.c global_algo_modules.c header.c networkcards.c tmpfile_file_handler.c file_handler_switch.c shm.c\", true);\n}\n\n"
        },
        {
          "name": "des_algo_handler.c",
          "type": "blob",
          "size": 1.990234375,
          "content": "/**\n * DES encrypt algorithms handler module for Beast\n * @author: liexusong\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"beast_log.h\"\n#include \"beast_module.h\"\n#include \"des_algo_lib.c\"\n\n\nstatic char key[8] = {\n    0x01, 0x1f, 0x01, 0x1f,\n    0x01, 0x0e, 0x01, 0x0e,\n};\n\n\nint des_encrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n    int blocks, i, fixcnt;\n    char input[8], output[8];\n    char *out;\n    int retlen;\n\n    if ((len % 8) == 0) {\n        fixcnt = 0;\n        blocks = len / 8;\n\n    } else {\n        fixcnt = len % 8;\n        blocks = len / 8 + 1;\n    }\n\n    retlen = blocks * 8;\n\n    out = malloc(retlen);\n    if (!out) {\n        beast_write_log(beast_log_error,\n               \"Out of memory when allocate `%d' size by encrypt(DES)\", retlen);\n    \treturn -1;\n    }\n\n    for (i = 0; i < blocks; i++) {\n        memset(input, 0, 8);\n\n        /* The last block not enough 8 bytes, fix me */\n        if (i + 1 == blocks && fixcnt > 0) {\n            memcpy(input, &inbuf[i*8], fixcnt);\n        } else {\n            memcpy(input, &inbuf[i*8], 8);\n        }\n\n        DES_encipher(input, output, key);\n\n        memcpy(&out[i * 8], output, 8);\n    }\n\n    *outbuf = out;\n    *outlen = retlen;\n\n    return 0;\n}\n\n\nint des_decrypt_handler(char *inbuf, int len,\n\tchar **outbuf, int *outlen)\n{\n    int blocks, retlen, i;\n    char *out;\n\n    if (len % 8 == 0) {\n        blocks = len / 8;\n    } else {\n        blocks = len / 8 + 1;\n    }\n\n    retlen = blocks * 8;\n\n    out = malloc(retlen);\n    if (!out) {\n        beast_write_log(beast_log_error,\n               \"Out of memory when allocate `%d' size by decrypt(DES)\", retlen);\n        return -1;\n    }\n\n    for (i = 0; i < blocks; i++) {\n        DES_decipher(&inbuf[i*8], &out[i*8], key);\n    }\n\n    *outbuf = out;\n    *outlen = retlen;\n\n    return 0;\n}\n\n\nvoid des_free_handler(void *ptr)\n{\n    if (ptr) {\n        free(ptr);\n    }\n}\n\nstruct beast_ops des_handler_ops = {\n\t\"des-algo\",\n\tdes_encrypt_handler,\n\tdes_decrypt_handler,\n\tdes_free_handler,\n    NULL\n};\n"
        },
        {
          "name": "des_algo_lib.c",
          "type": "blob",
          "size": 29.9716796875,
          "content": "/*****************************************************************************\n*                                                                            *\n*  --------------------------------- des.c --------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n/*****************************************************************************\n*                                                                            *\n*  -------------------------------- bit_get -------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nint bit_get(const unsigned char *bits, int pos) {\n\nunsigned char      mask;\n\nint                i;\n\n/*****************************************************************************\n*                                                                            *\n*  Set a mask for the bit to get.                                            *\n*                                                                            *\n*****************************************************************************/\n\nmask = 0x80;\n\nfor (i = 0; i < (pos % 8); i++)\n   mask = mask >> 1;\n\n/*****************************************************************************\n*                                                                            *\n*  Get the bit.                                                              *\n*                                                                            *\n*****************************************************************************/\n\nreturn (((mask & bits[(int)(pos / 8)]) == mask) ? 1 : 0);\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  -------------------------------- bit_set -------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nvoid bit_set(unsigned char *bits, int pos, int state) {\n\nunsigned char      mask;\n\nint                i;\n\n/*****************************************************************************\n*                                                                            *\n*  Set a mask for the bit to set.                                            *\n*                                                                            *\n*****************************************************************************/\n\nmask = 0x80;\n\nfor (i = 0; i < (pos % 8); i++)\n   mask = mask >> 1;\n\n/*****************************************************************************\n*                                                                            *\n*  Set the bit.                                                              *\n*                                                                            *\n*****************************************************************************/\n\nif (state)\n   bits[pos / 8] = bits[pos / 8] | mask;\nelse\n   bits[pos / 8] = bits[pos / 8] & (~mask);\n\nreturn;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  -------------------------------- bit_xor -------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nvoid bit_xor(const unsigned char *bits1, const unsigned char *bits2, unsigned\n   char *bitsx, int size) {\n\nint                i;\n\n/*****************************************************************************\n*                                                                            *\n*  Compute the bitwise XOR (exclusive OR) of the two buffers.                *\n*                                                                            *\n*****************************************************************************/\n\nfor (i = 0; i < size; i++) {\n\n   if (bit_get(bits1, i) != bit_get(bits2, i))\n      bit_set(bitsx, i, 1);\n   else\n      bit_set(bitsx, i, 0);\n\n}\n\nreturn;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  ----------------------------- bit_rot_left -----------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nvoid bit_rot_left(unsigned char *bits, int size, int count) {\n\nint                fbit,\n                   lbit,\n                   i,\n                   j;\n\n/*****************************************************************************\n*                                                                            *\n*  Rotate the buffer to the left the specified number of bits.               *\n*                                                                            *\n*****************************************************************************/\n\nif (size > 0) {\n\n   for (j = 0; j < count; j++) {\n\n      for (i = 0; i <= ((size - 1) / 8); i++) {\n\n         /********************************************************************\n         *                                                                   *\n         *  Get the bit about to be shifted off the current byte.            *\n         *                                                                   *\n         ********************************************************************/\n\n         lbit = bit_get(&bits[i], 0);\n\n         if (i == 0) {\n\n            /*****************************************************************\n            *                                                                *\n            *  Save the bit shifted off the first byte for later.            *\n            *                                                                *\n            *****************************************************************/\n\n            fbit = lbit;\n\n            }\n\n         else {\n\n            /*****************************************************************\n            *                                                                *\n            *  Set the rightmost bit of the previous byte to the leftmost    *\n            *  bit about to be shifted off the current byte.                 *\n            *                                                                *\n            *****************************************************************/\n\n            bit_set(&bits[i - 1], 7, lbit);\n\n         }\n\n         /********************************************************************\n         *                                                                   *\n         *  Shift the current byte to the left.                              *\n         *                                                                   *\n         ********************************************************************/\n\n         bits[i] = bits[i] << 1;\n\n      }\n\n      /***********************************************************************\n      *                                                                      *\n      *  Set the rightmost bit of the buffer to the bit shifted off the      *\n      *  first byte.                                                         *\n      *                                                                      *\n      ***********************************************************************/\n\n      bit_set(bits, size - 1, fbit);\n\n   }\n\n}\n\nreturn;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the key transformation.                              *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesTransform[56] = {\n\n   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,\n   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,\n   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,\n   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define the number of rotations for computing subkeys.                     *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesRotations[16] = {\n\n   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the permuted choice for subkeys.                     *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesPermuted[48] = {\n\n   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,\n   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,\n   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,\n   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the initial permutation of data blocks.              *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesInitial[64] = {\n\n   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12,  4,\n   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16,  8,\n   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3,\n   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the expansion permutation of data blocks.            *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesExpansion[48] = {\n\n   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define tables for the S-box substitutions performed for data blocks.      *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesSbox[8][4][16] = {\n\n   {\n   {14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},\n   { 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8},\n   { 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0},\n   {15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13},\n   },\n\n   {\n   {15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10},\n   { 3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5},\n   { 0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},\n   {13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9},\n   },\n\n   {\n   {10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8},\n   {13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1},\n   {13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7},\n   { 1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12},\n   },\n\n   {\n   { 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15},\n   {13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9},\n   {10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4},\n   { 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14},\n   },\n\n   {\n   { 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9},\n   {14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6},\n   { 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14},\n   {11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3},\n   },\n\n   {\n   {12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11},\n   {10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8},\n   { 9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6},\n   { 4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13},\n   },\n\n   {\n   { 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1},\n   {13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6},\n   { 1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2},\n   { 6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12},\n   },\n\n   {\n   {13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7},\n   { 1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2},\n   { 7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8},\n   { 2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11},\n   },\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the P-box permutation of data blocks.                *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesPbox[32] = {\n\n   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,\n    2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a mapping for the final permutation of data blocks.                *\n*                                                                            *\n*****************************************************************************/\n\nstatic const int DesFinal[64] = {\n\n   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,\n   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,\n   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,\n   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25\n\n};\n\n/*****************************************************************************\n*                                                                            *\n*  Define a type for whether to encipher or decipher data.                   *\n*                                                                            *\n*****************************************************************************/\n\ntypedef enum DesEorD_ {encipher, decipher} DesEorD;\n\n/*****************************************************************************\n*                                                                            *\n*  -------------------------------- permute -------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nstatic void permute(unsigned char *bits, const int *mapping, int n) {\n\nunsigned char      temp[8];\n\nint                i;\n\n/*****************************************************************************\n*                                                                            *\n*  Permute the buffer using an n-entry mapping.                              *\n*                                                                            *\n*****************************************************************************/\n\nmemset(temp, 0, (int)ceil(n / 8));\n\nfor (i = 0; i < n; i++)\n   bit_set(temp, i, bit_get(bits, mapping[i] - 1));\n\nmemcpy(bits, temp, (int)ceil(n / 8));\n\nreturn;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  ------------------------------- des_main -------------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nstatic int DES_main(const unsigned char *source, unsigned char *target, const\n   unsigned char *key, DesEorD direction) {\n\nstatic unsigned char subkeys[16][7];\n\nunsigned char        temp[8],\n                     lkey[4],\n                     rkey[4],\n                     lblk[6],\n                     rblk[6],\n                     fblk[6],\n                     xblk[6],\n                     sblk;\n\nint                  row,\n                     col,\n                     i,\n                     j,\n                     k,\n                     p;\n\n/*****************************************************************************\n*                                                                            *\n*  If key is NULL, use the subkeys as computed in a previous call.           *\n*                                                                            *\n*****************************************************************************/\n\nif (key != NULL) {\n\n   /**************************************************************************\n   *                                                                         *\n   *  Make a local copy of the key.                                          *\n   *                                                                         *\n   **************************************************************************/\n\n   memcpy(temp, key, 8);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Permute and compress the key into 56 bits.                             *\n   *                                                                         *\n   **************************************************************************/\n\n   permute(temp, DesTransform, 56);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Split the key into two 28-bit blocks.                                  *\n   *                                                                         *\n   **************************************************************************/\n\n   memset(lkey, 0, 4);\n   memset(rkey, 0, 4);\n\n   for (j = 0; j < 28; j++)\n      bit_set(lkey, j, bit_get(temp, j));\n\n   for (j = 0; j < 28; j++)\n      bit_set(rkey, j, bit_get(temp, j + 28));\n\n   /**************************************************************************\n   *                                                                         *\n   *  Compute the subkeys for each round.                                    *\n   *                                                                         *\n   **************************************************************************/\n\n   for (i = 0; i < 16; i++) {\n\n      /***********************************************************************\n      *                                                                      *\n      *  Rotate each block according to its round.                           *\n      *                                                                      *\n      ***********************************************************************/\n\n      bit_rot_left(lkey, 28, DesRotations[i]);\n      bit_rot_left(rkey, 28, DesRotations[i]);\n\n      /***********************************************************************\n      *                                                                      *\n      *  Concatenate the blocks into a single subkey.                        *\n      *                                                                      *\n      ***********************************************************************/\n\n      for (j = 0; j < 28; j++)\n         bit_set(subkeys[i], j, bit_get(lkey, j));\n\n      for (j = 0; j < 28; j++)\n         bit_set(subkeys[i], j + 28, bit_get(rkey, j));\n\n      /***********************************************************************\n      *                                                                      *\n      *  Do the permuted choice permutation.                                 *\n      *                                                                      *\n      ***********************************************************************/\n\n      permute(subkeys[i], DesPermuted, 48);\n\n   }\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  Make a local copy of the source text.                                     *\n*                                                                            *\n*****************************************************************************/\n\nmemcpy(temp, source, 8);\n\n/*****************************************************************************\n*                                                                            *\n*  Do the initial permutation.                                               *\n*                                                                            *\n*****************************************************************************/\n\npermute(temp, DesInitial, 64);\n\n/*****************************************************************************\n*                                                                            *\n*  Split the source text into a left and right block of 32 bits.             *\n*                                                                            *\n*****************************************************************************/\n\nmemcpy(lblk, &temp[0], 4);\nmemcpy(rblk, &temp[4], 4);\n\n/*****************************************************************************\n*                                                                            *\n*  Encipher or decipher the source text.                                     *\n*                                                                            *\n*****************************************************************************/\n\nfor (i = 0; i < 16; i++) {\n\n   /**************************************************************************\n   *                                                                         *\n   *  Begin the computation of f.                                            *\n   *                                                                         *\n   **************************************************************************/\n\n   memcpy(fblk, rblk, 4);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Permute and expand the copy of the right block into 48 bits.           *\n   *                                                                         *\n   **************************************************************************/\n\n   permute(fblk, DesExpansion, 48);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Apply the appropriate subkey for the round.                            *\n   *                                                                         *\n   **************************************************************************/\n\n   if (direction == encipher) {\n\n      /***********************************************************************\n      *                                                                      *\n      *  For enciphering, subkeys are applied in increasing order.           *\n      *                                                                      *\n      ***********************************************************************/\n\n      bit_xor(fblk, subkeys[i], xblk, 48);\n      memcpy(fblk, xblk, 6);\n\n      }\n\n   else {\n\n      /***********************************************************************\n      *                                                                      *\n      *  For deciphering, subkeys are applied in decreasing order.           *\n      *                                                                      *\n      ***********************************************************************/\n\n      bit_xor(fblk, subkeys[15 - i], xblk, 48);\n      memcpy(fblk, xblk, 6);\n\n   }\n\n   /**************************************************************************\n   *                                                                         *\n   *  Do the S-box substitutions.                                            *\n   *                                                                         *\n   **************************************************************************/\n\n   p = 0;\n\n   for (j = 0; j < 8; j++) {\n\n      /***********************************************************************\n      *                                                                      *\n      *  Compute a row and column into the S-box tables.                     *\n      *                                                                      *\n      ***********************************************************************/\n\n      row = (bit_get(fblk, (j * 6)+0) * 2) + (bit_get(fblk, (j * 6)+5) * 1);\n      col = (bit_get(fblk, (j * 6)+1) * 8) + (bit_get(fblk, (j * 6)+2) * 4) +\n            (bit_get(fblk, (j * 6)+3) * 2) + (bit_get(fblk, (j * 6)+4) * 1);\n\n      /***********************************************************************\n      *                                                                      *\n      *  Do the S-box substitution for the current six-bit block.            *\n      *                                                                      *\n      ***********************************************************************/\n\n      sblk = (unsigned char)DesSbox[j][row][col];\n\n      for (k = 4; k < 8; k++) {\n\n         bit_set(fblk, p, bit_get(&sblk, k));\n         p++;\n\n      }\n\n   }\n\n   /**************************************************************************\n   *                                                                         *\n   *  Do the P-box permutation to complete f.                                *\n   *                                                                         *\n   **************************************************************************/\n\n   permute(fblk, DesPbox, 32);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Compute the XOR of the left block and f.                               *\n   *                                                                         *\n   **************************************************************************/\n\n   bit_xor(lblk, fblk, xblk, 32);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Set the left block for the round.                                      *\n   *                                                                         *\n   **************************************************************************/\n\n   memcpy(lblk, rblk, 4);\n\n   /**************************************************************************\n   *                                                                         *\n   *  Set the right block for the round.                                     *\n   *                                                                         *\n   **************************************************************************/\n\n   memcpy(rblk, xblk, 4);\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  Set the target text to the rejoined final right and left blocks.          *\n*                                                                            *\n*****************************************************************************/\n\nmemcpy(&target[0], rblk, 4);\nmemcpy(&target[4], lblk, 4);\n\n/*****************************************************************************\n*                                                                            *\n*  Do the final permutation.                                                 *\n*                                                                            *\n*****************************************************************************/\n\npermute(target, DesFinal, 64);\n\nreturn 0;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  ----------------------------- DES_encipher -----------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nvoid DES_encipher(const unsigned char *plaintext, unsigned char *ciphertext,\n   const unsigned char *key) {\n\nDES_main(plaintext, ciphertext, key, encipher);\n\nreturn;\n\n}\n\n/*****************************************************************************\n*                                                                            *\n*  ----------------------------- DES_decipher -----------------------------  *\n*                                                                            *\n*****************************************************************************/\n\nvoid DES_decipher(const unsigned char *ciphertext, unsigned char *plaintext,\n   const unsigned char *key) {\n\nDES_main(ciphertext, plaintext, key, decipher);\n\nreturn;\n\n}\n\n"
        },
        {
          "name": "file_handler.h",
          "type": "blob",
          "size": 0.5185546875,
          "content": "#ifndef __FILE_HANDLER_H\n#define __FILE_HANDLER_H\n\n#include <stdio.h>\n\n#define BEAST_FILE_HANDLER_FP 1\n#define BEAST_FILE_HANDLER_FD 2\n\nstruct file_handler {\n    char *name;\n    int type;\n    void *ctx;\n    int (*check)();\n    int (*open)(struct file_handler *self);\n    int (*write)(struct file_handler *self, char *buf, int size);\n    int (*rewind)(struct file_handler *self);\n    int (*get_fd)(struct file_handler *self);\n    FILE *(*get_fp)(struct file_handler *self);\n    int (*destroy)(struct file_handler *self);\n};\n\n#endif\n"
        },
        {
          "name": "file_handler_switch.c",
          "type": "blob",
          "size": 0.0390625,
          "content": "\nchar *file_handler_switch = \"tmpfile\";\n"
        },
        {
          "name": "global_algo_modules.c",
          "type": "blob",
          "size": 0.2900390625,
          "content": "#include <stdlib.h>\n#include \"beast_module.h\"\n\nextern struct beast_ops des_handler_ops;\nextern struct beast_ops aes_handler_ops;\nextern struct beast_ops base64_handler_ops;\n\nstruct beast_ops *ops_handler_list[] = {\n    &des_handler_ops,\n    &aes_handler_ops,\n    &base64_handler_ops,\n    NULL,\n};\n"
        },
        {
          "name": "header.c",
          "type": "blob",
          "size": 0.216796875,
          "content": "\n/*\n * You can modify this sign to disguise your encrypt file\n */\nchar encrypt_file_header_sign[] = {\n\t0xe8, 0x16, 0xa4, 0x0c,\n\t0xf2, 0xb2, 0x60, 0xee\n};\n\nint encrypt_file_header_length = sizeof(encrypt_file_header_sign);\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "networkcards.c",
          "type": "blob",
          "size": 0.1376953125,
          "content": "#include <stdlib.h>\n\n/*\n * Allow network card. if this list empty, this feature was closed!\n */\n\nchar *allow_networkcards[] = {\n    NULL,\n};\n"
        },
        {
          "name": "php_beast.h",
          "type": "blob",
          "size": 2.7314453125,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2007 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author:                                                              |\n  +----------------------------------------------------------------------+\n*/\n\n/* $Id: header,v 1.16.2.1.2.1 2007/01/01 19:32:09 iliaa Exp $ */\n\n#ifndef PHP_BEAST_H\n#define PHP_BEAST_H\n\nextern zend_module_entry beast_module_entry;\n#define phpext_beast_ptr &beast_module_entry\n\n#ifdef PHP_WIN32\n#define PHP_BEAST_API __declspec(dllexport)\n#else\n#define PHP_BEAST_API\n#endif\n\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n\nPHP_MINIT_FUNCTION(beast);\nPHP_MSHUTDOWN_FUNCTION(beast);\nPHP_RINIT_FUNCTION(beast);\nPHP_RSHUTDOWN_FUNCTION(beast);\nPHP_MINFO_FUNCTION(beast);\n\nPHP_FUNCTION(beast_encode_file);\nPHP_FUNCTION(beast_avail_cache);\nPHP_FUNCTION(beast_support_filesize);\nPHP_FUNCTION(beast_file_expire);\nPHP_FUNCTION(beast_clean_cache);\n\n/*\n  \tDeclare any global variables you may need between the BEGIN\n\tand END macros here:\n\nZEND_BEGIN_MODULE_GLOBALS(beast)\n\tlong  global_value;\n\tchar *global_string;\nZEND_END_MODULE_GLOBALS(beast)\n*/\n\n/* In every utility function you add that needs to use variables\n   in php_beast_globals, call TSRMLS_FETCH(); after declaring other\n   variables used by that function, or better yet, pass in TSRMLS_CC\n   after the last function argument and declare your utility function\n   with TSRMLS_DC after the last declared argument.  Always refer to\n   the globals in your function as BEAST_G(variable).  You are\n   encouraged to rename these macros something shorter, see\n   examples in any other php module directory.\n*/\n\n#ifdef ZTS\n#define BEAST_G(v) TSRMG(beast_globals_id, zend_beast_globals *, v)\n#else\n#define BEAST_G(v) (beast_globals.v)\n#endif\n\n#endif\t/* PHP_BEAST_H */\n\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker expandtab\n * vim<600: noet sw=4 ts=4\n */\n"
        },
        {
          "name": "pipe_file_handler.c",
          "type": "blob",
          "size": 1.5927734375,
          "content": "\n#ifndef PHP_WIN32\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"file_handler.h\"\n\nstruct pipe_handler_ctx {\n    int fd[2];\n};\n\nint pipe_handler_check()\n{\n    return 64 * 1024;\n}\n\nint pipe_handler_open(struct file_handler *self)\n{\n    struct pipe_handler_ctx *ctx = self->ctx;\n\n    if (pipe(ctx->fd) == -1) {\n        ctx->fd[0] = -1;\n        ctx->fd[1] = -1;\n        return -1;\n    }\n\n    return 0;\n}\n\nint pipe_handler_write(struct file_handler *self, char *buf, int size)\n{\n    struct pipe_handler_ctx *ctx = self->ctx;\n\n    if (write(ctx->fd[1], buf, size) == size) {\n        return 0;\n    }\n\n    return -1;\n}\n\nint pipe_handler_rewind(struct file_handler *self)\n{\n    return 0;\n}\n\nFILE *pipe_handler_get_fp(struct file_handler *self)\n{\n    return NULL;\n}\n\nint pipe_handler_get_fd(struct file_handler *self)\n{\n    struct pipe_handler_ctx *ctx = self->ctx;\n    int retval;\n\n    retval = ctx->fd[0];\n\n    close(ctx->fd[1]);  /* Closed write pipe */\n\n    ctx->fd[0] = -1;\n    ctx->fd[1] = -1;\n\n    return retval;\n}\n\nint pipe_handler_destroy(struct file_handler *self)\n{\n    struct pipe_handler_ctx *ctx = self->ctx;\n\n    if (ctx->fd[0] != -1)\n        close(ctx->fd[0]);\n    if (ctx->fd[1] != -1)\n        close(ctx->fd[1]);\n\n    ctx->fd[0] = -1;\n    ctx->fd[1] = -1;\n\n    return 0;\n}\n\nstatic struct pipe_handler_ctx _ctx = {\n    {-1, -1}\n};\n\nstruct file_handler pipe_handler = {\n    \"pipe\",\n    BEAST_FILE_HANDLER_FD,\n    &_ctx,\n    pipe_handler_check,\n    pipe_handler_open,\n    pipe_handler_write,\n    pipe_handler_rewind,\n    pipe_handler_get_fd,\n    pipe_handler_get_fp,\n    pipe_handler_destroy\n};\n\n#endif\n"
        },
        {
          "name": "shm.c",
          "type": "blob",
          "size": 0.8466796875,
          "content": "#include \"shm.h\"\n\n#ifdef PHP_WIN32\n    #include <Windows.h>\n#else\n    #include <sys/mman.h>\n\n    #ifndef MAP_NOSYNC\n        #define MAP_NOSYNC 0\n    #endif\n#endif\n\nvoid *beast_shm_alloc(size_t size)\n{\n    void *p;\n#ifdef PHP_WIN32\n    HANDLE hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE,\n\t\tNULL, PAGE_READWRITE, 0, size, NULL);\n\n\tif (hMapFile == INVALID_HANDLE_VALUE) {\n        return NULL;\n    }\n\n    p = MapViewOfFile(\n            hMapFile,\n            FILE_MAP_ALL_ACCESS,\n            0,\n            0,\n            size);\n    CloseHandle(hMapFile);\n\n#else\n\n    p = mmap(NULL,\n            size,\n            PROT_READ|PROT_WRITE,\n            MAP_SHARED|MAP_ANON,\n            -1,\n            0);\n\n#endif\n    return p;\n}\n\nint beast_shm_free(void *p, size_t size)\n{\n#ifdef PHP_WIN32\n\treturn UnmapViewOfFile(p) ? 0 : -1;\n#else\n    return munmap(p, size);\n#endif\n}\n\n"
        },
        {
          "name": "shm.h",
          "type": "blob",
          "size": 0.13671875,
          "content": "#ifndef __SHM_H\n#define __SHM_H\n\n#include <stddef.h>\n\nvoid *beast_shm_alloc(size_t size);\nint beast_shm_free(void *p, size_t size);\n\n#endif\n"
        },
        {
          "name": "spinlock.c",
          "type": "blob",
          "size": 2.2919921875,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2007 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Liexusong <280259971@qq.com>                                 |\n  +----------------------------------------------------------------------+\n*/\n\n#include <stdlib.h>\n#include \"spinlock.h\"\n#ifdef PHP_WIN32\n  #include <Windows.h>\n#else\n  #include <pthread.h>\n#endif\n#include \"beast_log.h\"\n\n#ifdef PHP_WIN32\n  #define compare_and_swap(lock, o, n) \\\n      (InterlockedCompareExchange(lock, n, o) == n)\n  #define pause() YieldProcessor()\n  #define yield() SwitchToThread()\n#else\n  #define compare_and_swap(lock, o, n) \\\n      __sync_bool_compare_and_swap(lock, o, n)\n  #ifdef __arm__\n    #define pause() __asm__(\"NOP\");\n  #elif __aarch64__\n    #define pause() __asm__(\"NOP\");\n  #else\n    #define pause() __asm__(\"pause\")\n  #endif\n  #define yield() sched_yield()\n#endif\n\nextern int beast_ncpu;\n\nvoid beast_spinlock(beast_atomic_t *lock, int pid)\n{\n    int i, n;\n\n    for ( ;; ) {\n        if (compare_and_swap(lock, 0, pid)) {\n            return;\n        }\n\n        if (beast_ncpu > 1) {\n\n            for (n = 1; n < 129; n <<= 1) {\n\n                if (compare_and_swap(lock, 0, pid)) {\n                    return;\n                }\n\n                for (i = 0; i < n; i++) {\n                    pause();\n                }\n            }\n        }\n\n        yield();\n    }\n}\n\nvoid beast_spinunlock(beast_atomic_t *lock, int pid)\n{\n    compare_and_swap(lock, pid, 0);\n}\n"
        },
        {
          "name": "spinlock.h",
          "type": "blob",
          "size": 0.2109375,
          "content": "#ifndef __BEAST_SPINLOCK_H\n#define __BEAST_SPINLOCK_H\n\ntypedef volatile unsigned int beast_atomic_t;\n\nvoid beast_spinlock(beast_atomic_t *lock, int pid);\nvoid beast_spinunlock(beast_atomic_t *lock, int pid);\n\n#endif\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmpfile_file_handler.c",
          "type": "blob",
          "size": 1.4521484375,
          "content": "#include <stdlib.h>\n#include <stdio.h>\n#include \"file_handler.h\"\n\nstruct tmpfile_handler_ctx {\n    FILE *fp;\n};\n\nint tmpfile_handler_check()\n{\n    return 0;\n}\n\nint tmpfile_handler_open(struct file_handler *self)\n{\n    struct tmpfile_handler_ctx *ctx = self->ctx;\n\n    ctx->fp = tmpfile();\n    if (!ctx->fp) {\n        return -1;\n    }\n\n    return 0;\n}\n\nint tmpfile_handler_write(struct file_handler *self, char *buf, int size)\n{\n    struct tmpfile_handler_ctx *ctx = self->ctx;\n\n    if (fwrite(buf, 1, size, ctx->fp) == size) {\n        return 0;\n    }\n\n    return -1;\n}\n\nint tmpfile_handler_rewind(struct file_handler *self)\n{\n    struct tmpfile_handler_ctx *ctx = self->ctx;\n\n    rewind(ctx->fp);\n\n    return 0;\n}\n\nFILE *tmpfile_handler_get_fp(struct file_handler *self)\n{\n    struct tmpfile_handler_ctx *ctx = self->ctx;\n    FILE *retval;\n\n    retval = ctx->fp;\n    ctx->fp = NULL;\n\n    return retval;\n}\n\nint tmpfile_handler_get_fd(struct file_handler *self)\n{\n    return -1;\n}\n\nint tmpfile_handler_destroy(struct file_handler *self)\n{\n    struct tmpfile_handler_ctx *ctx = self->ctx;\n\n    if (ctx->fp) {\n        fclose(ctx->fp);\n    }\n\n    ctx->fp = NULL;\n\n    return 0;\n}\n\nstatic struct tmpfile_handler_ctx _ctx = {\n\tNULL\n};\n\nstruct file_handler tmpfile_handler = {\n\t\"tmpfile\",\n\tBEAST_FILE_HANDLER_FP,\n\t&_ctx,\n\ttmpfile_handler_check,\n\ttmpfile_handler_open,\n\ttmpfile_handler_write,\n\ttmpfile_handler_rewind,\n\ttmpfile_handler_get_fd,\n\ttmpfile_handler_get_fp,\n\ttmpfile_handler_destroy\n};\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}