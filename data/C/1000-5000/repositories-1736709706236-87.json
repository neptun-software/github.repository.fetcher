{
  "metadata": {
    "timestamp": 1736709706236,
    "page": 87,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "plasma-umass/coz",
      "stars": 4146,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.9755859375,
          "content": "deps\nlibcoz/libcoz.so\nlibcoz/obj\n\nbenchmarks/*/obj\nbenchmarks/*/profile.coz\n\nbenchmarks/histogram/histogram\nbenchmarks/kmeans/kmeans\nbenchmarks/linear_regression/linear_regression\nbenchmarks/matrix_multiply/matrix_multiply\nbenchmarks/pbzip2/pbzip2\nbenchmarks/pca/pca\nbenchmarks/producer_consumer/producer_consumer\nbenchmarks/string_match/string_match\nbenchmarks/sqlite/sqlite-bench\nbenchmarks/sqlite-modified/sqlite-bench\nbenchmarks/toy/toy\nbenchmarks/word_count/word_count\n\nbenchmarks/histogram/histogram_datafiles\nbenchmarks/linear_regression/linear_regression_datafiles\nbenchmarks/matrix_multiply/.input_large\nbenchmarks/matrix_multiply/.input_small\nbenchmarks/matrix_multiply/matrix_file_A.txt\nbenchmarks/matrix_multiply/matrix_file_B.txt\nbenchmarks/matrix_multiply/matrix_file_out_pthreads.txt\nbenchmarks/pbzip2/data\nbenchmarks/pbzip2/bzip2-1.0.6\nbenchmarks/string_match/string_match_datafiles\nbenchmarks/word_count/word_count_datafiles\n\nbuild/\n\nviewer/node_modules\nrust/Cargo.lock\nrust/target\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.90234375,
          "content": "# Build on Ubuntu 18.04\ndist: bionic\n\n# Specify language\nlanguage: cpp\n\n# Build with both clang and gcc\ncompiler:\n  - clang\n  - g++\n\n# Build all branches except gh-pages\nbranches:\n  except:\n    - gh-pages\n\n# Install dependencies\nbefore_install:\n  - sudo apt-get update\n  - sudo apt-get install -y --install-recommends build-essential cmake ninja-build docutils-common nodejs npm\n  - sudo pip install conan\n\n# Make and install\ninstall:\n  - mkdir build && cd build\n  - conan install .. -s compiler.libcxx=libstdc++11 -s compiler.cppstd=11 --build=outdated\n  - cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUILD_BENCHMARKS=ON -G Ninja\n  - ninja\n  - sudo ninja install\n\n# Run tests\nscript:\n  - CTEST_OUTPUT_ON_FAILURE=1 ninja test\n\n# Test the Rust support as well\nmatrix:\n  include:\n    - language: rust\n      rust: stable\n      before_install: true\n      install: true\n      script: cargo test --manifest-path rust/Cargo.toml\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.8173828125,
          "content": "cmake_minimum_required(VERSION 3.13.0)\nproject(coz VERSION 0.2.2 LANGUAGES C CXX)\n\nenable_testing()\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CONAN_CMAKE_SILENT_OUTPUT ON)\n\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_BINARY_DIR} ${PROJECT_SOURCE_DIR}/cmake)\n\nfind_package(Threads REQUIRED)\nfind_package(libelfin REQUIRED)\n\nadd_compile_options(-gdwarf-3)\n\noption(INSTALL_COZ \"Enable installation of coz. (Projects embedding coz may want to turn this OFF.)\" ON)\n\nif(INSTALL_COZ)\n    include(GNUInstallDirs)\n    include(CMakePackageConfigHelpers)\n    install(PROGRAMS coz DESTINATION bin)\n    install(FILES LICENSE.md DESTINATION licenses)\n    configure_package_config_file(\n        cmake/coz-profilerConfig.cmake.in\n        ${CMAKE_CURRENT_BINARY_DIR}/coz-profilerConfig.cmake\n        INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake)\n    write_basic_package_version_file(\n        ${CMAKE_CURRENT_BINARY_DIR}/coz-profilerConfigVersion.cmake\n        COMPATIBILITY ExactVersion) # SameMajor only applies to versions >= 1.0. Versions 0.x have to match exactly according to semver.org\n    install(\n        FILES\n        ${CMAKE_CURRENT_BINARY_DIR}/coz-profilerConfig.cmake\n        ${CMAKE_CURRENT_BINARY_DIR}/coz-profilerConfigVersion.cmake\n        DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake)\n    install(\n        EXPORT coz-profilerTargets\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake\n        NAMESPACE coz::)\nendif()\n\nadd_subdirectory(libcoz)\n\noption(BUILD_BENCHMARKS \"Build benchmarks\" OFF)\nif(BUILD_BENCHMARKS)\n    if(NOT (CMAKE_BUILD_TYPE STREQUAL \"Debug\" OR CMAKE_BUILD_TYPE STREQUAL \"RelWithDebInfo\"))\n        message(FATAL_ERROR \"Build benchmarks with debug information - use Debug or RelWithDebInfo\")\n    endif()\n    find_package(SQLite3 REQUIRED)\n    find_package(BZip2 REQUIRED)\n    add_subdirectory(benchmarks)\nendif()\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.62109375,
          "content": "Original work: _Copyright &copy; 2015, Charlie Curtsinger and Emery Berger, University of Massachusetts Amherst_\nModified work: _Copyright &copy; 2016, Charlie Curtsinger_\n_All rights reserved._\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies, \neither expressed or implied, of the FreeBSD Project."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.84375,
          "content": "ROOT := .\nDIRS := libcoz viewer\n\ninclude $(ROOT)/common.mk\n\nupdate-gh-pages:: all\n\t@echo $(LOG_PREFIX) Pushing profiler viewer to gh-pages branch $(LOG_SUFFIX)\n\t@git push origin `git subtree split --prefix viewer master 2> /dev/null`:gh-pages\n\ninstall:: all\n\t@echo $(LOG_PREFIX) Installing coz to prefix $(prefix) $(LOG_SUFFIX)\n\t@sed 's@destdir@\"${DESTDIR}${prefix}\"@g' coz-profilerConfig.cmake.in > coz-profilerConfig.cmake\n\t@$(INSTALL) -D coz $(DESTDIR)$(bindir)/coz\n\t@$(INSTALL) -D coz-profilerConfig.cmake $(DESTDIR)$(pkglibdir)/coz-profilerConfig.cmake\n\t@$(INSTALL) -D libcoz/libcoz.so $(DESTDIR)$(pkglibdir)/libcoz.so\n\t@$(INSTALL) -D include/coz.h $(DESTDIR)$(incdir)/coz.h\n\t@mkdir -p $(DESTDIR)$(man1dir)\n\t@$(RST2MAN) docs/coz.rst $(DESTDIR)$(man1dir)/coz.1\n\nbench bench_small bench_large::\n\t@$(MAKE) -C benchmarks $@\n\ncheck::\n\t@$(MAKE) -C benchmarks check\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.341796875,
          "content": "# Coz: Finding Code that Counts with Causal Profiling\n\nby [Charlie Curtsinger](https://curtsinger.cs.grinnell.edu/) and [Emery Berger](https://emeryberger.com)\n\n[![Rust Crate downloads](https://img.shields.io/crates/d/coz?logo=rust&link=https%3A%2F%2Fcrates.io%2Fcrates%2Fcoz)](https://crates.io/crates/coz)\n\nCoz is a profiler for native code (C/C++/Rust) that unlocks\noptimization opportunities missed by traditional profilers. Coz\nemploys a novel technique called *causal profiling* that measures\noptimization potential. It predicts what the impact of optimizing code\nwill have on overall throughput or latency.\n\nProfiles generated by Coz show the \"bang for buck\" of optimizing a\nline of code in an application. In the below profile, almost every\neffort to optimize the performance of this line of code directly leads\nto an increase in overall performance, making it an excellent\ncandidate for optimization efforts.\n\n![Example Coz profile](https://github.com/plasma-umass/coz/blob/master/example-coz-output.png)\n\nCoz's measurement matches developers' assumptions about profilers: that optimizing highly-ranked code will have the greatest impact on performance. Causal profiling measures optimization potential for serial, parallel, and asynchronous programs without instrumentation of special handling for library calls and concurrency primitives. Instead, a causal profiler uses performance experiments to predict the effect of optimizations. This allows the profiler to establish causality: \"optimizing function X will have effect Y,\" exactly the measurement developers had assumed they were getting all along.\n\nFull details of Coz are available in our paper, [Coz: Finding Code\nthat Counts with Causal Profiling\n(pdf)](http://arxiv.org/pdf/1608.03676v1.pdf), SOSP 2015, October 2015\n(recipient of a Best Paper Award).\n\n[![Coz presentation at SOSP](http://img.youtube.com/vi/jE0V-p1odPg/0.jpg)](http://www.youtube.com/watch?v=jE0V-p1odPg&t=0m28s \"Coz presentation at SOSP\")\n\n## Installation\n\nOn Debian and Ubuntu, you can install Coz via apt:\n\n```shell\nsudo apt install coz-profiler\n```\n\nAn OpenSUSE package was prepared by user\n[@zethra](https://github.com/zethra) and is available at\n<https://build.opensuse.org/package/show/home:zethra/coz-profiler>.\n\nCoz should work on any modern Linux system (specifically, running\nversion 2.6.32 or later, with support for the `perf_event_open` system\ncall) with a Python 3.x interpreter.\n\n## Libraries/Wrappers\n\nBy default, Coz works for C, C++, and Rust programs. It has been ported or\nhas wrappers for several other languages, listed below:\n\n| Language      | Link |\n| ----------- | -----------  \n| Java   | JCoz: https://github.com/Decave/JCoz|\n| Go     | Cozgo: https://github.com/urjitbhatia/cozgo|\n| Swift  | Swift Coz: https://github.com/funcmike/swift-coz |\n\n## Building Coz From Source\n\nTo build Coz from source, you will need:\n\n- A copy of the source code for this project\n- A compiler with C++0x support (clang++ or g++)\n- A Python interpreter (Python 3.x is required)\n- *OPTIONAL*: for building the profiler viewer, you need NodeJS and npm -- `sudo apt-get install nodejs npm`\n\nOnce you have all dependencies in place, build Coz with CMake. On Debian-based distributions, the following commands should take care of the entire process:\n\n```shell\nsudo apt-get update\nsudo apt-get install libdwarf-dev\nsudo apt-get install build-essential cmake docutils-common git python3 pkg-config\ngit clone https://github.com/plasma-umass/libelfin && cd libelfin && make && sudo make install && cd ..\ngit clone https://github.com/plasma-umass/coz && cd coz && cmake . && make && sudo make install && cd ..\n```\n\nNext, you need to change the \"perf_event_paranoia\" level so Coz can run.\n\n```shell\nsudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'\n```\n\nNow you can test Coz. Build the benchmark suite and run one of the benchmarks (the SQLite3 benchmark takes a while to build).\n\n```shell\nsudo apt-get install libbz2-dev libsqlite3-dev\ncd coz/benchmarks && cmake . && make && cd ../..\ncoz run --- ./coz/benchmarks/toy/toy\n```\n\nFinally, use the Coz viewer to see the results. This command will open up a browser tab, from which you will need to load the file `profile.coz`.\n\n```shell\ncoz plot\n```\n\nIf you are on a remote system, you can open the Coz viewer in your browser: [https://plasma-umass.github.io/coz](https://plasma-umass.github.io/coz) and then load the file `profile.coz`, which you will have to transfer to your local machine.\n\n(You may need to move the \"Minimum Points\" slider on the left side to see the results.)\n\n## Using Coz\nUsing Coz requires a small amount of setup, but you can jump ahead to the section on the included [sample applications](#sample-applications) in this repository if you want to try Coz right away.\n\nTo run your program with Coz, you will need to build it with debug information (`-g -gdwarf-3`). You do not need to include debug symbols in the main executable: coz uses the same procedure as `gdb` to locate debug information for stripped binaries.\n\nOnce you have your program built with debug information, you can run it with Coz using the command `coz run {coz options} --- {program name and arguments}`. But, to produce a useful profile you need to decide which part(s) of the application you want to speed up by specifying one or more progress points.\n\n### Profiling Modes\nCoz departs from conventional profiling by making it possible to view the effect of optimizations on both throughput and latency. To profile throughput, you must specify a progress point. To profile latency, you must specify a pair of progress points.\n\n#### Throughput Profiling: Specifying Progress Points\nTo profile throughput you must indicate a line in the code that corresponds to the end of a unit of work. For example, a progress point could be the point at which a transaction concludes, when a web page finishes rendering, or when a query completes. Coz then measures the rate of visits to each progress point to determine any potential optimization's effect on throughput.\n\nTo place a progress point, include `coz.h` (under the `include` directory in this repository) and add the `COZ_PROGRESS` macro to at least one line you would like to execute more frequently. Don't forget to link your program with libdl: use the `-ldl` option.\n\nBy default, Coz uses the source file and line number as the name for your progress points. If you use `COZ_PROGRESS_NAMED(\"name for progress point\")` instead, you can provide an informative name for your progress points. This also allows you to mark multiple source locations that correspond to the same progress point.\n\n#### Latency Profiling: Specifying Progress Points\nTo profile latency, you must place two progress points that correspond to the start and end of an event of interest, such as when a transaction begins and completes. Simply  mark the beginning of a transaction with the `COZ_BEGIN(\"transaction name\")` macro, and the end with the `COZ_END(\"transaction name\")` macro. Unlike regular progress points, you always need to specify a name for your latency progress points. Don't forget to link your program with libdl: use the `-ldl` option.\n\nWhen coz tests a hypothetical optimization it will report the effect of that optimization on the average latency between these two points. Coz can track this information without any knowledge of individual transactions thanks to [Little's Law](https://en.wikipedia.org/wiki/Little%27s_law).\n\n### Specifying Progress Points on the Command Line\nCoz has command line options to specify progress points when profiling the application instead of modifying its source. This feature is currently disabled because it did not work particularly well. Adding support for better command line-specified progress points is planned in the near future.\n\n## Processing Results\nTo plot profile results, go to http://plasma-umass.github.io/coz/ and load your profile. This page also includes several sample profiles from PARSEC benchmarks.\n\n## Sample Applications\nThe `benchmarks` directory in this repository includes several small benchmarks with progress points added at appropriate locations. To build and run one of these benchmarks with `coz`, just browse to `benchmarks` and type `cmake . && make`, then you can execute the programs compiled in `benchmarks/{benchmark}`. These programs may require several runs before coz has enough measurements to generate a useful profile. Once you have profiled these programs for several minutes, go to http://plasma-umass.github.io/coz/ to load and plot your profile.\n\n## CMake\nWhen you install coz it installs a cmake config file. To add coz to a cmake project simply use the command `find_package(coz-profiler)`. This will import a target for the library and includes called `coz::coz` and a target for the coz binary `coz::profiler`. For guidance on how to use these targets refer to the CMake documentation.\n\n## Limitations\nCoz currently does not support interpreted or JIT-compiled languages such as Python, Ruby, or JavaScript. Interpreted languages will likely not be supported at any point, but support for JIT-compiled languages that produce debug information could be added in the future.\n\n## License\nAll source code is licensed under the BSD 2-clause license unless otherwise indicated. See LICENSE.md for details.\n\nSample applications (in the `benchmarks` directory) include several [Phoenix](https://github.com/kozyraki/phoenix) programs and [pbzip2](http://compression.ca/pbzip2/), which are licensed separately and included with this release for convenience.\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "common.mk",
          "type": "blob",
          "size": 2.67578125,
          "content": "DESTDIR   ?=\nprefix    ?= /usr\nbindir    := $(prefix)/bin\npkglibdir := $(prefix)/lib/coz-profiler\nincdir    := $(prefix)/include\nmandir    := $(prefix)/share/man\nman1dir   := $(mandir)/man1\n\nINSTALL = install\nRST2MAN = rst2man\n\n# Build with clang by default\nCC  ?= clang\nCXX ?= clang++\n\n# Set coz and include path for coz\nifeq ($(USE_SYSTEM_COZ),1)\nCOZ := $(shell which coz)\nelse\nCOZ := $(ROOT)/coz\nendif\n\n# Default flags\nCFLAGS   ?= -g -O2\nCXXFLAGS ?= $(CFLAGS)\n\n# Default source and object files\nSRCS ?= $(wildcard *.cpp) $(wildcard *.c)\nOBJS ?= $(addprefix obj/,$(patsubst %.cpp,%.o,$(patsubst %.c,%.o,$(SRCS))))\n\n# Prevent errors if files named all, clean, distclean, bench, or test exist\n.PHONY: all clean distclean bench bench_small bench_large test\n\n# Targets to build recursively into $(DIRS)\nRECURSIVE_TARGETS  ?= all clean bench bench_large bench_small test install check\n\n# Targets separated by type\nSHARED_LIB_TARGETS := $(filter %.so, $(TARGETS))\nSTATIC_LIB_TARGETS := $(filter %.a, $(TARGETS))\nOTHER_TARGETS      := $(filter-out %.so, $(filter-out %.a, $(TARGETS)))\n\n# If not set, the build path is just the current directory name\nMAKEPATH ?= $(shell basename $(shell pwd))\n\n# Log the build path in gray, following by a log message in bold green\nLOG_PREFIX := \"$(shell tput setaf 7)[$(MAKEPATH)]$(shell tput sgr0)$(shell tput setaf 2)\"\nLOG_SUFFIX := \"$(shell tput sgr0)\"\n\n# Build in parallel\nMAKEFLAGS += -j\n\n# Build all targets by default, unless this is a benchmark\nall:: $(TARGETS)\n\n# Clean up after a build\nclean::\n\t@for t in $(TARGETS); do \\\n\techo $(LOG_PREFIX) Cleaning $$t $(LOG_SUFFIX); \\\n\tdone\n\t@rm -rf $(TARGETS) obj\n\n# Bring source back to pristine state\ndistclean:: clean\n\t@$(MAKE) -C benchmarks clean\n\n# Compile a C++ source file (and generate its dependency rules)\nobj/%.o: %.cpp $(PREREQS)\n\t@echo $(LOG_PREFIX) Compiling $< $(LOG_SUFFIX)\n\t@mkdir -p obj\n\t@$(CXX) $(CXXFLAGS) -MMD -MP -o $@ -c $<\n\n# Compile a C source file (and generate its dependency rules)\nobj/%.o: %.c $(PREREQS)\n\t@echo $(LOG_PREFIX) Compiling $< $(LOG_SUFFIX)\n\t@mkdir -p obj\n\t@$(CC) $(CFLAGS) -MMD -MP -o $@ -c $<\n\n# Link a shared library\n$(SHARED_LIB_TARGETS): $(OBJS)\n\t@echo $(LOG_PREFIX) Linking $@ $(LOG_SUFFIX)\n\t@$(CXX) -shared $(LDFLAGS) -o $@ $^ $(LIBS)\n\n$(STATIC_LIB_TARGETS): $(OBJS)\n\t@echo $(LOG_PREFIX) Linking $@ $(LOG_SUFFIX)\n\t@ar rs $@ $^\n\n# Link binary targets\n$(OTHER_TARGETS): $(OBJS)\n\t@echo $(LOG_PREFIX) Linking $@ $(LOG_SUFFIX)\n\t@$(CXX) $(LDFLAGS) -o $@ $^ $(LIBS)\n\n# Include dependency rules for all objects\n-include $(OBJS:.o=.d)\n\n# Build any recursive targets in subdirectories\n$(RECURSIVE_TARGETS)::\n\t@for dir in $(DIRS); do \\\n\t$(MAKE) -C $$dir --no-print-directory $@ MAKEPATH=\"$(MAKEPATH)/$$dir\" || exit 1; \\\n\tdone\n"
        },
        {
          "name": "conanfile.txt",
          "type": "blob",
          "size": 0.111328125,
          "content": "[requires]\nlibelfin/[>=0.3]\n\n[build_requires]\nbzip2/[>=1.0.8]\nsqlite3/[>=3.33.0]\n\n[generators]\ncmake_find_package\n"
        },
        {
          "name": "coz",
          "type": "blob",
          "size": 6.9462890625,
          "content": "#!/usr/bin/env python3\n\n# Copyright (c) 2019, Charlie Curtsinger and Emery Berger,\n#                     University of Massachusetts Amherst\n# This file is part of the Coz project. See LICENSE.md file at the top-level\n# directory of this distribution and at http://github.com/plasma-umass/coz.\n\nimport argparse\nimport copy\nimport os\nimport subprocess\nimport sys\n\nfrom os.path import abspath, realpath, curdir, dirname, sep as path_sep\n\n# Entry point\ndef run_command_line():\n  # By default, parse all arguments\n  parsed_args = sys.argv[1:]\n  remaining_args = []\n  # If there is a '---' separator, only parse arguments before the separator\n  if '---' in sys.argv:\n    separator_index = sys.argv.index('---')\n    parsed_args = sys.argv[1:separator_index]\n    remaining_args = sys.argv[separator_index+1:]\n  # Pass the un-parsed arguments to the parser result\n  _parser.set_defaults(remaining_args=remaining_args)\n  # Parse it\n  args = _parser.parse_args(parsed_args)\n  if not hasattr(args, 'func'):\n    sys.stderr.write('error: pass a command before ---, such as `coz run --- $CMD`\\n')\n    _parser.print_help()\n    sys.exit(1)\n\n  # Call the parser's handler (set by the subcommand parser using defaults)\n  args.func(args)\n\n# Handler for the `coz run` subcommand\ndef _coz_run(args):\n  # Ensure the user specified a command after the '---' separator\n  if len(args.remaining_args) == 0:\n    sys.stderr.write('error: specify a command to profile after `---`\\n')\n    args.parser.print_help()\n    sys.exit(1)\n\n  env = copy.deepcopy(os.environ)\n\n  # Find coz\n  coz_prefix = dirname(realpath(sys.argv[0]))\n\n  # Candidate runtime library locations\n  library_locations = [\n    # Check for library adjacent to this script\n    os.path.join(coz_prefix, '..', 'lib64', 'libcoz.so'),\n    os.path.join(coz_prefix, '..', 'lib', 'libcoz.so'),\n\n    # Check for library under the coz-profiler subdirectory\n    os.path.join(coz_prefix, '..', 'lib64', 'coz-profiler', 'libcoz.so'),\n    os.path.join(coz_prefix, '..', 'lib', 'coz-profiler', 'libcoz.so'),\n\n    # Local library under development directory\n    os.path.join('libcoz', 'libcoz.so'),      # Local library during development\n    os.path.join(coz_prefix, 'libcoz', 'libcoz.so'),\n    os.path.join(coz_prefix, 'build', 'libcoz', 'libcoz.so'),\n  ]\n\n  # Find the first library location that exists\n  coz_runtime_found = False\n  coz_runtime = None\n\n  while len(library_locations) > 0 and not coz_runtime_found:\n    candidate = library_locations.pop(0)\n    if os.path.exists(candidate):\n      coz_runtime_found = True\n      coz_runtime = candidate\n\n  if not coz_runtime_found:\n    sys.stderr.write('error: unable to locate coz runtime library\\n')\n    sys.exit(1)\n\n  if 'LD_PRELOAD' in env:\n    env['LD_PRELOAD'] += ':' + coz_runtime\n  else:\n    env['LD_PRELOAD'] = coz_runtime\n\n  if len(args.binary_scope) > 0:\n    env['COZ_BINARY_SCOPE'] = '\\t'.join(args.binary_scope)\n  else:\n    env['COZ_BINARY_SCOPE'] = 'MAIN'\n\n  if len(args.source_scope) > 0:\n    env['COZ_SOURCE_SCOPE'] = '\\t'.join(args.source_scope)\n  else:\n    env['COZ_SOURCE_SCOPE'] = '%'\n\n  env['COZ_PROGRESS_POINTS'] = '\\t'.join(args.progress)\n\n  env['COZ_OUTPUT'] = args.output\n\n  if args.end_to_end:\n    env['COZ_END_TO_END'] = '1'\n\n  if args.fixed_line:\n    env['COZ_FIXED_LINE'] = args.fixed_line\n\n  if args.fixed_speedup != None:\n    env['COZ_FIXED_SPEEDUP'] = str(args.fixed_speedup)\n\n  try:\n    result = subprocess.call(args.remaining_args, env=env)\n  except KeyboardInterrupt:\n    # Exit with special control-C return code\n    result = 130\n    # Add a newline to mimic output when running without coz\n    print()\n  exit(result)\n\ndef open_browser(url):\n  import webbrowser\n  webbrowser.open_new_tab(url)\n  \ndef _coz_plot(args):\n  coz_plot_url = 'http://plasma-umass.github.io/coz'\n  import threading\n  t1 = threading.Thread(target=open_browser,args=(coz_plot_url,))\n  t1.start()\n  #if sys.platform == 'darwin':\n  #  subprocess.call(['open', coz_plot_url])\n  #elif sys.platform == 'win32':\n  #  os.startfile(coz_plot_url)\n  #else:\n  #  subprocess.call(['xdg-open', coz_plot_url])\n  \n\n# Special format handler for line reference arguments\ndef line_ref(val):\n  try:\n    (filename, line) = val.rsplit(':', 1)\n    line = int(line)\n    return filename + ':' + str(line)\n  except:\n    msg = \"Invalid line reference %r. The format is <source file>:<line number>.\" % val\n    raise argparse.ArgumentTypeError(msg)\n\n######### Build the top-level parser #########\n_parser = argparse.ArgumentParser()\n_subparsers = _parser.add_subparsers()\n\n######### Build the parser for the `run` sub-command #########\n_run_parser = _subparsers.add_parser('run',\n                                     usage='%(prog)s [profiling options] --- <command> [args]',\n                                     help='Run a program with coz to collect a causal profile.')\n\n# Add common profiler options\n_run_parser.add_argument('--binary-scope', '-b',\n                         metavar='<file pattern>',\n                         default=[], action='append',\n                         help='Profile matching executables. Use \\'%%\\' as a wildcard, or \\'MAIN\\' to include the main executable (default=MAIN)')\n\n_run_parser.add_argument('--source-scope', '-s',\n                         metavar='<file pattern>',\n                         default=[], action='append',\n                         help='Profile matching source files. Use \\'%%\\' as a wildcard. (default=%%)')\n\n_run_parser.add_argument('--progress', '-p',\n                         metavar='<source file>:<line number>',\n                         type=line_ref, action='append', default=[],\n                         help='[NOT SUPPORTED] Add a sampling-based progress point')\n\n_run_parser.add_argument('--output', '-o',\n                         metavar='<profile output>',\n                         default=abspath(curdir+path_sep+'profile.coz'),\n                         help='Profiler output (default=`profile.coz`)')\n\n_run_parser.add_argument('--end-to-end',\n                         action='store_true', default=False,\n                         help='Run a single performance experiment per-execution')\n\n_run_parser.add_argument('--fixed-line',\n                         metavar='<source file>:<line number>', default=None,\n                         help='Evaluate optimizations of a specific source line')\n\n_run_parser.add_argument('--fixed-speedup',\n                         metavar='<speedup> (0-100)',\n                         type=int, choices=list(range(0, 101)), default=None,\n                         help='Evaluate optimizations of a specific amount')\n\n# Use defaults to recover handler function and parser object from parser output\n_run_parser.set_defaults(func=_coz_run, parser=_run_parser)\n\n######### Build the parser for the `coz plot` subcommand\n_plot_parser = _subparsers.add_parser('plot',\n                                      help='Plot the speedup results from one or more causal profiling runs.')\n\n# Use defaults to recover handler function and parser object from parser output\n_plot_parser.set_defaults(func=_coz_plot, parser=_plot_parser)\n\nif __name__ == \"__main__\":\n  run_command_line()\n"
        },
        {
          "name": "coz-profilerConfig.cmake.in",
          "type": "blob",
          "size": 0.71484375,
          "content": "\n\nset(COZDIR destdir)\n\nset(COZ_BIN ${COZDIR}/bin/coz)\nset(COZ_INCLUDE_DIR ${COZDIR}/include)\nget_filename_component(LIBRARY_DIR ${CMAKE_CURRENT_LIST_FILE} DIRECTORY)\nset(COZ_LIBRARY ${LIBRARY_DIR}/libcoz.so)\n\nset(COZ_FOUND ON)\n\nmessage(INFO \" ${COZ_INCLUDE_DIR} ${COZ_LIBRARY} ${COZ_FOUND}\")\n\nmark_as_advanced(COZ_FOUND COZ_INCLUDE_DIR COZ_LIBRARY)\n\nadd_library(coz::coz UNKNOWN IMPORTED)\nset_target_properties(coz::coz PROPERTIES \n    INTERFACE_INCLUDE_DIRECTORIES \"${COZ_INCLUDE_DIR}\")\n\nset_target_properties(coz::coz PROPERTIES \n    IMPORTED_LINK_INTERFACE_LANGUAGES \"C\"\n    IMPORTED_LOCATION \"${COZ_INCLUDE_DIR}\")\n\nadd_executable(coz::profiler IMPORTED)\n\nset_property(TARGET coz::profiler PROPERTY IMPORTED_LOCATION ${COZ_BIN})\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-coz-output.png",
          "type": "blob",
          "size": 57.9326171875,
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "libcoz",
          "type": "tree",
          "content": null
        },
        {
          "name": "patches",
          "type": "tree",
          "content": null
        },
        {
          "name": "rust",
          "type": "tree",
          "content": null
        },
        {
          "name": "viewer",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}