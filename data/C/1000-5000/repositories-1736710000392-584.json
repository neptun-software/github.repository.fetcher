{
  "metadata": {
    "timestamp": 1736710000392,
    "page": 584,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Pithikos/C-Thread-Pool",
      "stars": 2135,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Johan Hanssen Seferidis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.1572265625,
          "content": "[![GitHub Actions](https://github.com/Pithikos/C-Thread-Pool/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/Pithikos/C-Thread-Pool/actions?query=workflow%3Atests+branch%3Amaster)\n\n\n# C Thread Pool\n\nThis is a minimal but advanced threadpool implementation.\n\n  * ANCI C and POSIX compliant\n  * Pause/resume/wait as you like\n  * Simple easy-to-digest API\n  * Well tested\n\nThe threadpool is under MIT license. Notice that this project took a considerable amount of work and sacrifice of my free time and the reason I give it for free (even for commercial use) is so when you become rich and wealthy you don't forget about us open-source creatures of the night. Cheers!\n\nIf this project reduced your development time feel free to buy me a coffee.\n\n[![Donate](https://www.paypal.com/en_US/i/btn/x-click-but21.gif)](https://www.paypal.me/seferidis)\n\n\n## Run an example\n\nThe library is not precompiled so you have to compile it with your project. The thread pool\nuses POSIX threads so if you compile with gcc on Linux you have to use the flag `-pthread` like this:\n\n    gcc example.c thpool.c -D THPOOL_DEBUG -pthread -o example\n\n\nThen run the executable like this:\n\n    ./example\n\n\n## Basic usage\n\n1. Include the header in your source file: `#include \"thpool.h\"`\n2. Create a thread pool with number of threads you want: `threadpool thpool = thpool_init(4);`\n3. Add work to the pool: `thpool_add_work(thpool, (void*)function_p, (void*)arg_p);`\n\nThe workers(threads) will start their work automatically as fast as there is new work\nin the pool. If you want to wait for all added work to be finished before continuing\nyou can use `thpool_wait(thpool);`. If you want to destroy the pool you can use\n`thpool_destroy(thpool);`.\n\n\n## API\n\nFor a deeper look into the documentation check in the [thpool.h](https://github.com/Pithikos/C-Thread-Pool/blob/master/thpool.h) file. Below is a fast practical overview.\n\n| Function example                | Description                                                         |\n|---------------------------------|---------------------------------------------------------------------|\n| ***thpool_init(4)***            | Will return a new threadpool with `4` threads.                        |\n| ***thpool_add_work(thpool, (void&#42;)function_p, (void&#42;)arg_p)*** | Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, `NULL` should be passed. |\n| ***thpool_wait(thpool)***       | Will wait for all jobs (both in queue and currently running) to finish. |\n| ***thpool_destroy(thpool)***    | This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish. |\n| ***thpool_pause(thpool)***      | All threads in the threadpool will pause no matter if they are idle or executing work. |\n| ***thpool_resume(thpool)***      | If the threadpool is paused, then all threads will resume from where they were.   |\n| ***thpool_num_threads_working(thpool)***  | Will return the number of currently working threads.   |\n\n\n## Contribution\n\nYou are very welcome to contribute. If you have a new feature in mind, you can always open an issue on github describing it so you don't end up doing a lot of work that might not be eventually merged. Generally we are very open to contributions as long as they follow the below keypoints.\n\n* Try to keep the API as minimal as possible. That means if a feature or fix can be implemented without affecting the existing API but requires more development time, then we will opt to sacrifice development time.\n* Solutions need to be POSIX compliant. The thread-pool is advertised as such so it makes sense that it actually is.\n* For coding style simply try to stick to the conventions you find in the existing codebase.\n* Tests: A new fix or feature should be covered by tests. If the existing tests are not sufficient, we expect an according test to follow with the pull request.\n* Documentation: for a new feature please add documentation. For an API change the documentation has to be thorough and super easy to understand.\n\nIf you wish to **get access as a collaborator** feel free to mention it in the issue https://github.com/Pithikos/C-Thread-Pool/issues/78\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 0.986328125,
          "content": "/* \n * WHAT THIS EXAMPLE DOES\n * \n * We create a pool of 4 threads and then add 40 tasks to the pool(20 task1 \n * functions and 20 task2 functions). task1 and task2 simply print which thread is running them.\n * \n * As soon as we add the tasks to the pool, the threads will run them. It can happen that \n * you see a single thread running all the tasks (highly unlikely). It is up the OS to\n * decide which thread will run what. So it is not an error of the thread pool but rather\n * a decision of the OS.\n * \n * */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdint.h>\n#include \"thpool.h\"\n\nvoid task(void *arg){\n\tprintf(\"Thread #%u working on %d\\n\", (int)pthread_self(), (int) arg);\n}\n\n\nint main(){\n\t\n\tputs(\"Making threadpool with 4 threads\");\n\tthreadpool thpool = thpool_init(4);\n\n\tputs(\"Adding 40 tasks to threadpool\");\n\tint i;\n\tfor (i=0; i<40; i++){\n\t\tthpool_add_work(thpool, task, (void*)(uintptr_t)i);\n\t};\n\n\tthpool_wait(thpool);\n\tputs(\"Killing threadpool\");\n\tthpool_destroy(thpool);\n\t\n\treturn 0;\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "thpool.c",
          "type": "blob",
          "size": 13.5185546875,
          "content": "/* ********************************\n * Author:       Johan Hanssen Seferidis\n * License:\t     MIT\n * Description:  Library providing a threading pool where you can add\n *               work. For usage, check the thpool.h file or README.md\n *\n *//** @file thpool.h *//*\n *\n ********************************/\n\n#if defined(__APPLE__)\n#include <AvailabilityMacros.h>\n#else\n#ifndef _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 200809L\n#endif\n#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 500\n#endif\n#endif\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <errno.h>\n#include <time.h>\n#if defined(__linux__)\n#include <sys/prctl.h>\n#endif\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <pthread_np.h>\n#endif\n\n#include \"thpool.h\"\n\n#ifdef THPOOL_DEBUG\n#define THPOOL_DEBUG 1\n#else\n#define THPOOL_DEBUG 0\n#endif\n\n#if !defined(DISABLE_PRINT) || defined(THPOOL_DEBUG)\n#define err(str) fprintf(stderr, str)\n#else\n#define err(str)\n#endif\n\n#ifndef THPOOL_THREAD_NAME\n#define THPOOL_THREAD_NAME thpool\n#endif\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\nstatic volatile int threads_keepalive;\nstatic volatile int threads_on_hold;\n\n\n\n/* ========================== STRUCTURES ============================ */\n\n\n/* Binary semaphore */\ntypedef struct bsem {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t   cond;\n\tint v;\n} bsem;\n\n\n/* Job */\ntypedef struct job{\n\tstruct job*  prev;                   /* pointer to previous job   */\n\tvoid   (*function)(void* arg);       /* function pointer          */\n\tvoid*  arg;                          /* function's argument       */\n} job;\n\n\n/* Job queue */\ntypedef struct jobqueue{\n\tpthread_mutex_t rwmutex;             /* used for queue r/w access */\n\tjob  *front;                         /* pointer to front of queue */\n\tjob  *rear;                          /* pointer to rear  of queue */\n\tbsem *has_jobs;                      /* flag as binary semaphore  */\n\tint   len;                           /* number of jobs in queue   */\n} jobqueue;\n\n\n/* Thread */\ntypedef struct thread{\n\tint       id;                        /* friendly id               */\n\tpthread_t pthread;                   /* pointer to actual thread  */\n\tstruct thpool_* thpool_p;            /* access to thpool          */\n} thread;\n\n\n/* Threadpool */\ntypedef struct thpool_{\n\tthread**   threads;                  /* pointer to threads        */\n\tvolatile int num_threads_alive;      /* threads currently alive   */\n\tvolatile int num_threads_working;    /* threads currently working */\n\tpthread_mutex_t  thcount_lock;       /* used for thread count etc */\n\tpthread_cond_t  threads_all_idle;    /* signal to thpool_wait     */\n\tjobqueue  jobqueue;                  /* job queue                 */\n} thpool_;\n\n\n\n\n\n/* ========================== PROTOTYPES ============================ */\n\n\nstatic int  thread_init(thpool_* thpool_p, struct thread** thread_p, int id);\nstatic void* thread_do(struct thread* thread_p);\nstatic void  thread_hold(int sig_id);\nstatic void  thread_destroy(struct thread* thread_p);\n\nstatic int   jobqueue_init(jobqueue* jobqueue_p);\nstatic void  jobqueue_clear(jobqueue* jobqueue_p);\nstatic void  jobqueue_push(jobqueue* jobqueue_p, struct job* newjob_p);\nstatic struct job* jobqueue_pull(jobqueue* jobqueue_p);\nstatic void  jobqueue_destroy(jobqueue* jobqueue_p);\n\nstatic void  bsem_init(struct bsem *bsem_p, int value);\nstatic void  bsem_reset(struct bsem *bsem_p);\nstatic void  bsem_post(struct bsem *bsem_p);\nstatic void  bsem_post_all(struct bsem *bsem_p);\nstatic void  bsem_wait(struct bsem *bsem_p);\n\n\n\n\n\n/* ========================== THREADPOOL ============================ */\n\n\n/* Initialise thread pool */\nstruct thpool_* thpool_init(int num_threads){\n\n\tthreads_on_hold   = 0;\n\tthreads_keepalive = 1;\n\n\tif (num_threads < 0){\n\t\tnum_threads = 0;\n\t}\n\n\t/* Make new thread pool */\n\tthpool_* thpool_p;\n\tthpool_p = (struct thpool_*)malloc(sizeof(struct thpool_));\n\tif (thpool_p == NULL){\n\t\terr(\"thpool_init(): Could not allocate memory for thread pool\\n\");\n\t\treturn NULL;\n\t}\n\tthpool_p->num_threads_alive   = 0;\n\tthpool_p->num_threads_working = 0;\n\n\t/* Initialise the job queue */\n\tif (jobqueue_init(&thpool_p->jobqueue) == -1){\n\t\terr(\"thpool_init(): Could not allocate memory for job queue\\n\");\n\t\tfree(thpool_p);\n\t\treturn NULL;\n\t}\n\n\t/* Make threads in pool */\n\tthpool_p->threads = (struct thread**)malloc(num_threads * sizeof(struct thread *));\n\tif (thpool_p->threads == NULL){\n\t\terr(\"thpool_init(): Could not allocate memory for threads\\n\");\n\t\tjobqueue_destroy(&thpool_p->jobqueue);\n\t\tfree(thpool_p);\n\t\treturn NULL;\n\t}\n\n\tpthread_mutex_init(&(thpool_p->thcount_lock), NULL);\n\tpthread_cond_init(&thpool_p->threads_all_idle, NULL);\n\n\t/* Thread init */\n\tint n;\n\tfor (n=0; n<num_threads; n++){\n\t\tthread_init(thpool_p, &thpool_p->threads[n], n);\n#if THPOOL_DEBUG\n\t\t\tprintf(\"THPOOL_DEBUG: Created thread %d in pool \\n\", n);\n#endif\n\t}\n\n\t/* Wait for threads to initialize */\n\twhile (thpool_p->num_threads_alive != num_threads) {}\n\n\treturn thpool_p;\n}\n\n\n/* Add work to the thread pool */\nint thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p){\n\tjob* newjob;\n\n\tnewjob=(struct job*)malloc(sizeof(struct job));\n\tif (newjob==NULL){\n\t\terr(\"thpool_add_work(): Could not allocate memory for new job\\n\");\n\t\treturn -1;\n\t}\n\n\t/* add function and argument */\n\tnewjob->function=function_p;\n\tnewjob->arg=arg_p;\n\n\t/* add job to queue */\n\tjobqueue_push(&thpool_p->jobqueue, newjob);\n\n\treturn 0;\n}\n\n\n/* Wait until all jobs have finished */\nvoid thpool_wait(thpool_* thpool_p){\n\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\twhile (thpool_p->jobqueue.len || thpool_p->num_threads_working) {\n\t\tpthread_cond_wait(&thpool_p->threads_all_idle, &thpool_p->thcount_lock);\n\t}\n\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n}\n\n\n/* Destroy the threadpool */\nvoid thpool_destroy(thpool_* thpool_p){\n\t/* No need to destroy if it's NULL */\n\tif (thpool_p == NULL) return ;\n\n\tvolatile int threads_total = thpool_p->num_threads_alive;\n\n\t/* End each thread 's infinite loop */\n\tthreads_keepalive = 0;\n\n\t/* Give one second to kill idle threads */\n\tdouble TIMEOUT = 1.0;\n\ttime_t start, end;\n\tdouble tpassed = 0.0;\n\ttime (&start);\n\twhile (tpassed < TIMEOUT && thpool_p->num_threads_alive){\n\t\tbsem_post_all(thpool_p->jobqueue.has_jobs);\n\t\ttime (&end);\n\t\ttpassed = difftime(end,start);\n\t}\n\n\t/* Poll remaining threads */\n\twhile (thpool_p->num_threads_alive){\n\t\tbsem_post_all(thpool_p->jobqueue.has_jobs);\n\t\tsleep(1);\n\t}\n\n\t/* Job queue cleanup */\n\tjobqueue_destroy(&thpool_p->jobqueue);\n\t/* Deallocs */\n\tint n;\n\tfor (n=0; n < threads_total; n++){\n\t\tthread_destroy(thpool_p->threads[n]);\n\t}\n\tfree(thpool_p->threads);\n\tfree(thpool_p);\n}\n\n\n/* Pause all threads in threadpool */\nvoid thpool_pause(thpool_* thpool_p) {\n\tint n;\n\tfor (n=0; n < thpool_p->num_threads_alive; n++){\n\t\tpthread_kill(thpool_p->threads[n]->pthread, SIGUSR1);\n\t}\n}\n\n\n/* Resume all threads in threadpool */\nvoid thpool_resume(thpool_* thpool_p) {\n    // resuming a single threadpool hasn't been\n    // implemented yet, meanwhile this suppresses\n    // the warnings\n    (void)thpool_p;\n\n\tthreads_on_hold = 0;\n}\n\n\nint thpool_num_threads_working(thpool_* thpool_p){\n\treturn thpool_p->num_threads_working;\n}\n\n\n\n\n\n/* ============================ THREAD ============================== */\n\n\n/* Initialize a thread in the thread pool\n *\n * @param thread        address to the pointer of the thread to be created\n * @param id            id to be given to the thread\n * @return 0 on success, -1 otherwise.\n */\nstatic int thread_init (thpool_* thpool_p, struct thread** thread_p, int id){\n\n\t*thread_p = (struct thread*)malloc(sizeof(struct thread));\n\tif (*thread_p == NULL){\n\t\terr(\"thread_init(): Could not allocate memory for thread\\n\");\n\t\treturn -1;\n\t}\n\n\t(*thread_p)->thpool_p = thpool_p;\n\t(*thread_p)->id       = id;\n\n\tpthread_create(&(*thread_p)->pthread, NULL, (void * (*)(void *)) thread_do, (*thread_p));\n\tpthread_detach((*thread_p)->pthread);\n\treturn 0;\n}\n\n\n/* Sets the calling thread on hold */\nstatic void thread_hold(int sig_id) {\n    (void)sig_id;\n\tthreads_on_hold = 1;\n\twhile (threads_on_hold){\n\t\tsleep(1);\n\t}\n}\n\n\n/* What each thread is doing\n*\n* In principle this is an endless loop. The only time this loop gets interrupted is once\n* thpool_destroy() is invoked or the program exits.\n*\n* @param  thread        thread that will run this function\n* @return nothing\n*/\nstatic void* thread_do(struct thread* thread_p){\n\n\t/* Set thread name for profiling and debugging */\n\tchar thread_name[16] = {0};\n\n\tsnprintf(thread_name, 16, TOSTRING(THPOOL_THREAD_NAME) \"-%d\", thread_p->id);\n\n#if defined(__linux__)\n\t/* Use prctl instead to prevent using _GNU_SOURCE flag and implicit declaration */\n\tprctl(PR_SET_NAME, thread_name);\n#elif defined(__APPLE__) && defined(__MACH__)\n\tpthread_setname_np(thread_name);\n#elif defined(__FreeBSD__) || defined(__OpenBSD__)\n    pthread_set_name_np(thread_p->pthread, thread_name);\n#else\n\terr(\"thread_do(): pthread_setname_np is not supported on this system\");\n#endif\n\n\t/* Assure all threads have been created before starting serving */\n\tthpool_* thpool_p = thread_p->thpool_p;\n\n\t/* Register signal handler */\n\tstruct sigaction act;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = SA_ONSTACK;\n\tact.sa_handler = thread_hold;\n\tif (sigaction(SIGUSR1, &act, NULL) == -1) {\n\t\terr(\"thread_do(): cannot handle SIGUSR1\");\n\t}\n\n\t/* Mark thread as alive (initialized) */\n\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\tthpool_p->num_threads_alive += 1;\n\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\twhile(threads_keepalive){\n\n\t\tbsem_wait(thpool_p->jobqueue.has_jobs);\n\n\t\tif (threads_keepalive){\n\n\t\t\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\t\t\tthpool_p->num_threads_working++;\n\t\t\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\t\t\t/* Read job from queue and execute it */\n\t\t\tvoid (*func_buff)(void*);\n\t\t\tvoid*  arg_buff;\n\t\t\tjob* job_p = jobqueue_pull(&thpool_p->jobqueue);\n\t\t\tif (job_p) {\n\t\t\t\tfunc_buff = job_p->function;\n\t\t\t\targ_buff  = job_p->arg;\n\t\t\t\tfunc_buff(arg_buff);\n\t\t\t\tfree(job_p);\n\t\t\t}\n\n\t\t\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\t\t\tthpool_p->num_threads_working--;\n\t\t\tif (!thpool_p->num_threads_working) {\n\t\t\t\tpthread_cond_signal(&thpool_p->threads_all_idle);\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\t\t}\n\t}\n\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\tthpool_p->num_threads_alive --;\n\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\treturn NULL;\n}\n\n\n/* Frees a thread  */\nstatic void thread_destroy (thread* thread_p){\n\tfree(thread_p);\n}\n\n\n\n\n\n/* ============================ JOB QUEUE =========================== */\n\n\n/* Initialize queue */\nstatic int jobqueue_init(jobqueue* jobqueue_p){\n\tjobqueue_p->len = 0;\n\tjobqueue_p->front = NULL;\n\tjobqueue_p->rear  = NULL;\n\n\tjobqueue_p->has_jobs = (struct bsem*)malloc(sizeof(struct bsem));\n\tif (jobqueue_p->has_jobs == NULL){\n\t\treturn -1;\n\t}\n\n\tpthread_mutex_init(&(jobqueue_p->rwmutex), NULL);\n\tbsem_init(jobqueue_p->has_jobs, 0);\n\n\treturn 0;\n}\n\n\n/* Clear the queue */\nstatic void jobqueue_clear(jobqueue* jobqueue_p){\n\n\twhile(jobqueue_p->len){\n\t\tfree(jobqueue_pull(jobqueue_p));\n\t}\n\n\tjobqueue_p->front = NULL;\n\tjobqueue_p->rear  = NULL;\n\tbsem_reset(jobqueue_p->has_jobs);\n\tjobqueue_p->len = 0;\n\n}\n\n\n/* Add (allocated) job to queue\n */\nstatic void jobqueue_push(jobqueue* jobqueue_p, struct job* newjob){\n\n\tpthread_mutex_lock(&jobqueue_p->rwmutex);\n\tnewjob->prev = NULL;\n\n\tswitch(jobqueue_p->len){\n\n\t\tcase 0:  /* if no jobs in queue */\n\t\t\t\t\tjobqueue_p->front = newjob;\n\t\t\t\t\tjobqueue_p->rear  = newjob;\n\t\t\t\t\tbreak;\n\n\t\tdefault: /* if jobs in queue */\n\t\t\t\t\tjobqueue_p->rear->prev = newjob;\n\t\t\t\t\tjobqueue_p->rear = newjob;\n\n\t}\n\tjobqueue_p->len++;\n\n\tbsem_post(jobqueue_p->has_jobs);\n\tpthread_mutex_unlock(&jobqueue_p->rwmutex);\n}\n\n\n/* Get first job from queue(removes it from queue)\n * Notice: Caller MUST hold a mutex\n */\nstatic struct job* jobqueue_pull(jobqueue* jobqueue_p){\n\n\tpthread_mutex_lock(&jobqueue_p->rwmutex);\n\tjob* job_p = jobqueue_p->front;\n\n\tswitch(jobqueue_p->len){\n\n\t\tcase 0:  /* if no jobs in queue */\n\t\t  \t\t\tbreak;\n\n\t\tcase 1:  /* if one job in queue */\n\t\t\t\t\tjobqueue_p->front = NULL;\n\t\t\t\t\tjobqueue_p->rear  = NULL;\n\t\t\t\t\tjobqueue_p->len = 0;\n\t\t\t\t\tbreak;\n\n\t\tdefault: /* if >1 jobs in queue */\n\t\t\t\t\tjobqueue_p->front = job_p->prev;\n\t\t\t\t\tjobqueue_p->len--;\n\t\t\t\t\t/* more than one job in queue -> post it */\n\t\t\t\t\tbsem_post(jobqueue_p->has_jobs);\n\n\t}\n\n\tpthread_mutex_unlock(&jobqueue_p->rwmutex);\n\treturn job_p;\n}\n\n\n/* Free all queue resources back to the system */\nstatic void jobqueue_destroy(jobqueue* jobqueue_p){\n\tjobqueue_clear(jobqueue_p);\n\tfree(jobqueue_p->has_jobs);\n}\n\n\n\n\n\n/* ======================== SYNCHRONISATION ========================= */\n\n\n/* Init semaphore to 1 or 0 */\nstatic void bsem_init(bsem *bsem_p, int value) {\n\tif (value < 0 || value > 1) {\n\t\terr(\"bsem_init(): Binary semaphore can take only values 1 or 0\");\n\t\texit(1);\n\t}\n\tpthread_mutex_init(&(bsem_p->mutex), NULL);\n\tpthread_cond_init(&(bsem_p->cond), NULL);\n\tbsem_p->v = value;\n}\n\n\n/* Reset semaphore to 0 */\nstatic void bsem_reset(bsem *bsem_p) {\n\tpthread_mutex_destroy(&(bsem_p->mutex));\n\tpthread_cond_destroy(&(bsem_p->cond));\n\tbsem_init(bsem_p, 0);\n}\n\n\n/* Post to at least one thread */\nstatic void bsem_post(bsem *bsem_p) {\n\tpthread_mutex_lock(&bsem_p->mutex);\n\tbsem_p->v = 1;\n\tpthread_cond_signal(&bsem_p->cond);\n\tpthread_mutex_unlock(&bsem_p->mutex);\n}\n\n\n/* Post to all threads */\nstatic void bsem_post_all(bsem *bsem_p) {\n\tpthread_mutex_lock(&bsem_p->mutex);\n\tbsem_p->v = 1;\n\tpthread_cond_broadcast(&bsem_p->cond);\n\tpthread_mutex_unlock(&bsem_p->mutex);\n}\n\n\n/* Wait on semaphore until semaphore has value 0 */\nstatic void bsem_wait(bsem* bsem_p) {\n\tpthread_mutex_lock(&bsem_p->mutex);\n\twhile (bsem_p->v != 1) {\n\t\tpthread_cond_wait(&bsem_p->cond, &bsem_p->mutex);\n\t}\n\tbsem_p->v = 0;\n\tpthread_mutex_unlock(&bsem_p->mutex);\n}\n"
        },
        {
          "name": "thpool.h",
          "type": "blob",
          "size": 4.52734375,
          "content": "/**********************************\n * @author      Johan Hanssen Seferidis\n * License:     MIT\n *\n **********************************/\n\n#ifndef _THPOOL_\n#define _THPOOL_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* =================================== API ======================================= */\n\n\ntypedef struct thpool_* threadpool;\n\n\n/**\n * @brief  Initialize threadpool\n *\n * Initializes a threadpool. This function will not return until all\n * threads have initialized successfully.\n *\n * @example\n *\n *    ..\n *    threadpool thpool;                     //First we declare a threadpool\n *    thpool = thpool_init(4);               //then we initialize it to 4 threads\n *    ..\n *\n * @param  num_threads   number of threads to be created in the threadpool\n * @return threadpool    created threadpool on success,\n *                       NULL on error\n */\nthreadpool thpool_init(int num_threads);\n\n\n/**\n * @brief Add work to the job queue\n *\n * Takes an action and its argument and adds it to the threadpool's job queue.\n * If you want to add to work a function with more than one arguments then\n * a way to implement this is by passing a pointer to a structure.\n *\n * NOTICE: You have to cast both the function and argument to not get warnings.\n *\n * @example\n *\n *    void print_num(int num){\n *       printf(\"%d\\n\", num);\n *    }\n *\n *    int main() {\n *       ..\n *       int a = 10;\n *       thpool_add_work(thpool, (void*)print_num, (void*)a);\n *       ..\n *    }\n *\n * @param  threadpool    threadpool to which the work will be added\n * @param  function_p    pointer to function to add as work\n * @param  arg_p         pointer to an argument\n * @return 0 on success, -1 otherwise.\n */\nint thpool_add_work(threadpool, void (*function_p)(void*), void* arg_p);\n\n\n/**\n * @brief Wait for all queued jobs to finish\n *\n * Will wait for all jobs - both queued and currently running to finish.\n * Once the queue is empty and all work has completed, the calling thread\n * (probably the main program) will continue.\n *\n * Smart polling is used in wait. The polling is initially 0 - meaning that\n * there is virtually no polling at all. If after 1 seconds the threads\n * haven't finished, the polling interval starts growing exponentially\n * until it reaches max_secs seconds. Then it jumps down to a maximum polling\n * interval assuming that heavy processing is being used in the threadpool.\n *\n * @example\n *\n *    ..\n *    threadpool thpool = thpool_init(4);\n *    ..\n *    // Add a bunch of work\n *    ..\n *    thpool_wait(thpool);\n *    puts(\"All added work has finished\");\n *    ..\n *\n * @param threadpool     the threadpool to wait for\n * @return nothing\n */\nvoid thpool_wait(threadpool);\n\n\n/**\n * @brief Pauses all threads immediately\n *\n * The threads will be paused no matter if they are idle or working.\n * The threads return to their previous states once thpool_resume\n * is called.\n *\n * While the thread is being paused, new work can be added.\n *\n * @example\n *\n *    threadpool thpool = thpool_init(4);\n *    thpool_pause(thpool);\n *    ..\n *    // Add a bunch of work\n *    ..\n *    thpool_resume(thpool); // Let the threads start their magic\n *\n * @param threadpool    the threadpool where the threads should be paused\n * @return nothing\n */\nvoid thpool_pause(threadpool);\n\n\n/**\n * @brief Unpauses all threads if they are paused\n *\n * @example\n *    ..\n *    thpool_pause(thpool);\n *    sleep(10);              // Delay execution 10 seconds\n *    thpool_resume(thpool);\n *    ..\n *\n * @param threadpool     the threadpool where the threads should be unpaused\n * @return nothing\n */\nvoid thpool_resume(threadpool);\n\n\n/**\n * @brief Destroy the threadpool\n *\n * This will wait for the currently active threads to finish and then 'kill'\n * the whole threadpool to free up memory.\n *\n * @example\n * int main() {\n *    threadpool thpool1 = thpool_init(2);\n *    threadpool thpool2 = thpool_init(2);\n *    ..\n *    thpool_destroy(thpool1);\n *    ..\n *    return 0;\n * }\n *\n * @param threadpool     the threadpool to destroy\n * @return nothing\n */\nvoid thpool_destroy(threadpool);\n\n\n/**\n * @brief Show currently working threads\n *\n * Working threads are the threads that are performing work (not idle).\n *\n * @example\n * int main() {\n *    threadpool thpool1 = thpool_init(2);\n *    threadpool thpool2 = thpool_init(2);\n *    ..\n *    printf(\"Working threads: %d\\n\", thpool_num_threads_working(thpool1));\n *    ..\n *    return 0;\n * }\n *\n * @param threadpool     the threadpool of interest\n * @return integer       number of threads working\n */\nint thpool_num_threads_working(threadpool);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        }
      ]
    }
  ]
}