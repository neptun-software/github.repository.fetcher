{
  "metadata": {
    "timestamp": 1736709893258,
    "page": 387,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "madler/pigz",
      "stars": 2684,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": "*.o\n/pigz\n/unpigz\n/pigzj\n/pigzt\n/pigzn\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.96484375,
          "content": "CC=gcc\nCFLAGS=-O3 -Wall -Wextra -Wno-unknown-pragmas -Wcast-qual\nLDFLAGS=\n# CFLAGS=-O3 -Wall -Wextra -Wno-unknown-pragmas -Wcast-qual -g -fsanitize=thread\n# LDFLAGS=-g -fsanitize=thread\n# CFLAGS=-O3 -Wall -Wextra -Wno-unknown-pragmas -Wcast-qual -g -fsanitize=address\n# LDFLAGS=-g -fsanitize=address\nLIBS=-lm -lpthread -lz\nZOPFLI=zopfli/src/zopfli/\nZOP=deflate.o blocksplitter.o tree.o lz77.o cache.o hash.o util.o squeeze.o katajainen.o symbols.o\n\n# use gcc and gmake on Solaris\n\npigz: pigz.o yarn.o try.o $(ZOP)\n\t$(CC) $(LDFLAGS) -o pigz pigz.o yarn.o try.o $(ZOP) $(LIBS)\n\tln -f pigz unpigz\n\npigz.o: pigz.c yarn.h try.h $(ZOPFLI)deflate.h $(ZOPFLI)util.h\n\nyarn.o: yarn.c yarn.h\n\ntry.o: try.c try.h\n\ndeflate.o: $(ZOPFLI)deflate.c $(ZOPFLI)deflate.h $(ZOPFLI)blocksplitter.h $(ZOPFLI)lz77.h $(ZOPFLI)squeeze.h $(ZOPFLI)tree.h $(ZOPFLI)zopfli.h $(ZOPFLI)cache.h $(ZOPFLI)hash.h $(ZOPFLI)util.h $(ZOPFLI)symbols.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)deflate.c\n\nblocksplitter.o: $(ZOPFLI)blocksplitter.c $(ZOPFLI)blocksplitter.h $(ZOPFLI)deflate.h $(ZOPFLI)lz77.h $(ZOPFLI)squeeze.h $(ZOPFLI)tree.h $(ZOPFLI)util.h $(ZOPFLI)zopfli.h $(ZOPFLI)cache.h $(ZOPFLI)hash.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)blocksplitter.c\n\ntree.o: $(ZOPFLI)tree.c $(ZOPFLI)tree.h $(ZOPFLI)katajainen.h $(ZOPFLI)util.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)tree.c\n\nlz77.o: $(ZOPFLI)lz77.c $(ZOPFLI)lz77.h $(ZOPFLI)util.h $(ZOPFLI)cache.h $(ZOPFLI)hash.h $(ZOPFLI)zopfli.h $(ZOPFLI)symbols.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)lz77.c\n\ncache.o: $(ZOPFLI)cache.c $(ZOPFLI)cache.h $(ZOPFLI)util.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)cache.c\n\nhash.o: $(ZOPFLI)hash.c $(ZOPFLI)hash.h $(ZOPFLI)util.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)hash.c\n\nutil.o: $(ZOPFLI)util.c $(ZOPFLI)util.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)util.c\n\nsqueeze.o: $(ZOPFLI)squeeze.c $(ZOPFLI)squeeze.h $(ZOPFLI)blocksplitter.h $(ZOPFLI)deflate.h $(ZOPFLI)tree.h $(ZOPFLI)util.h $(ZOPFLI)zopfli.h $(ZOPFLI)lz77.h $(ZOPFLI)cache.h $(ZOPFLI)hash.h $(ZOPFLI)symbols.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)squeeze.c\n\nkatajainen.o: $(ZOPFLI)katajainen.c $(ZOPFLI)katajainen.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)katajainen.c\n\nsymbols.o: $(ZOPFLI)symbols.c $(ZOPFLI)symbols.h\n\t$(CC) $(CFLAGS) -c $(ZOPFLI)symbols.c\n\ndev: pigz pigzj pigzt pigzn\n\npigzj: pigzj.o yarn.o try.o\n\t$(CC) $(LDFLAGS) -o pigzj pigzj.o yarn.o try.o $(LIBS)\n\npigzj.o: pigz.c yarn.h try.h\n\t$(CC) $(CFLAGS) -DNOZOPFLI -c -o pigzj.o pigz.c\n\npigzt: pigzt.o yarnt.o try.o $(ZOP)\n\t$(CC) $(LDFLAGS) -o pigzt pigzt.o yarnt.o try.o $(ZOP) $(LIBS)\n\npigzt.o: pigz.c yarn.h try.h\n\t$(CC) $(CFLAGS) -DPIGZ_DEBUG -g -c -o pigzt.o pigz.c\n\nyarnt.o: yarn.c yarn.h\n\t$(CC) $(CFLAGS) -DPIGZ_DEBUG -g -c -o yarnt.o yarn.c\n\npigzn: pigzn.o tryn.o $(ZOP)\n\t$(CC) $(LDFLAGS) -o pigzn pigzn.o tryn.o $(ZOP) $(LIBS)\n\npigzn.o: pigz.c try.h\n\t$(CC) $(CFLAGS) -DPIGZ_DEBUG -DNOTHREAD -g -c -o pigzn.o pigz.c\n\ntryn.o: try.c try.h\n\t$(CC) $(CFLAGS) -DPIGZ_DEBUG -DNOTHREAD -g -c -o tryn.o try.c\n\ntest: pigz\n\t./pigz -kf pigz.c ; ./pigz -t pigz.c.gz\n\t./pigz -kfb 32 pigz.c ; ./pigz -t pigz.c.gz\n\t./pigz -kfp 1 pigz.c ; ./pigz -t pigz.c.gz\n\t./pigz -kfz pigz.c ; ./pigz -t pigz.c.zz\n\t./pigz -kfK pigz.c ; ./pigz -t pigz.c.zip\n\tprintf \"\" | ./pigz -cdf | wc -c | test `cat` -eq 0\n\tprintf \"x\" | ./pigz -cdf | wc -c | test `cat` -eq 1\n\tprintf \"xy\" | ./pigz -cdf | wc -c | test `cat` -eq 2\n\tprintf \"xyz\" | ./pigz -cdf | wc -c | test `cat` -eq 3\n\t(printf \"w\" | gzip ; printf \"x\") | ./pigz -cdf | wc -c | test `cat` -eq 2\n\t(printf \"w\" | gzip ; printf \"xy\") | ./pigz -cdf | wc -c | test `cat` -eq 3\n\t(printf \"w\" | gzip ; printf \"xyz\") | ./pigz -cdf | wc -c | test `cat` -eq 4\n\t-@if test \"`which compress | grep /`\" != \"\"; then \\\n\t  echo 'compress -f < pigz.c | ./unpigz | cmp - pigz.c' ;\\\n\t  compress -f < pigz.c | ./unpigz | cmp - pigz.c ;\\\n\tfi\n\t@rm -f pigz.c.gz pigz.c.zz pigz.c.zip\n\ntests: dev test\n\t./pigzn -kf pigz.c ; ./pigz -t pigz.c.gz\n\t@rm -f pigz.c.gz\n\ndocs: pigz.pdf\n\npigz.pdf: pigz.1\n\tgroff -mandoc -f H -T ps pigz.1 | ps2pdf - pigz.pdf\n\nall: pigz pigzj pigzt pigzn docs\n\nclean:\n\t@rm -f *.o pigz unpigz pigzj pigzn pigzt pigz.c.gz pigz.c.zz pigz.c.zip\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.134765625,
          "content": "pigz 2.8 (19 Aug 2022) by Mark Adler\n\npigz, which stands for Parallel Implementation of GZip, is a fully functional\nreplacement for gzip that exploits multiple processors and multiple cores to\nthe hilt when compressing data.\n\npigz was written by Mark Adler and does not include third-party code. I am\nmaking my contributions to and distributions of this project solely in my\npersonal capacity, and am not conveying any rights to any intellectual property\nof any third parties.\n\nThis version of pigz is written to be portable across Unix-style operating\nsystems that provide the zlib and pthread libraries.\n\nType \"make\" in this directory to build the \"pigz\" executable.  You can then\ninstall the executable wherever you like in your path (e.g. /usr/local/bin/).\nType \"pigz\" to see the command help and all of the command options.\n\nThe latest version of pigz can be found at http://zlib.net/pigz/ .  You need\nzlib version 1.2.3 or later to compile pigz.  zlib version 1.2.6 or later is\nrecommended, which reduces the overhead between blocks.  You can find the\nlatest version of zlib at http://zlib.net/ .  You can look in pigz.c for the\nchange history.\n\nQuestions, comments, bug reports, fixes, etc. can be emailed to Mark at his\naddress in the license below.\n\nThe license from pigz.c is copied here:\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler\n  madler@alumni.caltech.edu\n"
        },
        {
          "name": "pigz.1",
          "type": "blob",
          "size": 6.7109375,
          "content": ".TH PIGZ 1 \"August 19, 2023\"\n.SH NAME\npigz, unpigz \\- compress or expand files\n.SH SYNOPSIS\n.ll +8\n.B pigz\n.RB [ \" \\-cdfhikKlLmMnNqrRtz0..9,11 \" ]\n[\n.B -b\n.I blocksize\n]\n[\n.B -p\n.I threads\n]\n[\n.B -S\n.I suffix\n]\n[\n.I \"name \\&...\"\n]\n.ll -8\n.br\n.B unpigz\n.RB [ \" \\-cfhikKlLmMnNqrRtz \" ]\n[\n.B -b\n.I blocksize\n]\n[\n.B -p\n.I threads\n]\n[\n.B -S\n.I suffix\n]\n[\n.I \"name \\&...\"\n]\n.SH DESCRIPTION\n.I Pigz\ncompresses using threads to make use of multiple processors and cores.\nThe input is broken up into 128 KB chunks with each compressed in parallel.\nThe individual check value for each chunk is also calculated in parallel.\nThe compressed data is written in order to the output, and a combined check\nvalue is calculated from the individual check values.\n.PP\nThe compressed data format generated is in the gzip, zlib, or single-entry\nzip format using the deflate compression method.  The compression produces\npartial raw deflate streams which are concatenated by a single write thread\nand wrapped with the appropriate header and trailer, where the trailer\ncontains the combined check value.\n.PP\nEach partial raw deflate stream is terminated by an empty stored block\n(using the Z_SYNC_FLUSH option of zlib), in order to end that partial bit\nstream at a byte boundary.  That allows the partial streams to be\nconcatenated simply as sequences of bytes.  This adds a very small four to\nfive byte overhead to the output for each input chunk.\n.PP\nThe default input block size is 128K, but can be changed with the\n.B -b\noption.  The number of compress threads is set by default to the number\nof online processors,\nwhich can be changed using the\n.B -p\noption.  Specifying\n.B -p 1\navoids the use of threads entirely.\n.PP\nThe input blocks, while compressed independently, have the last 32K of the\nprevious block loaded as a preset dictionary to preserve the compression\neffectiveness of deflating in a single thread.  This can be turned off using\nthe\n.B -i\nor\n.B --independent\noption, so that the blocks can be decompressed\nindependently for partial error recovery or for random access. This also\ninserts an extra empty block to flag independent blocks by prefacing\neach with the nine-byte sequence (in hex): 00 00 FF FF 00 00 00 FF FF.\n.PP\nDecompression can't be parallelized, at least not without specially prepared\ndeflate streams for that purpose.  As a result,\n.I pigz\nuses a single thread\n(the main thread) for decompression, but will create three other threads for\nreading, writing, and check calculation, which can speed up decompression\nunder some circumstances.  Parallel decompression can be turned off by\nspecifying one process\n(\n.B -dp 1\nor\n.B -tp 1\n).\n.PP\nAll options on the command line are processed before any names are processed.\nIf no names are provided on the command line, or if \"-\" is given as a name (but\nnot after \"--\"), then the input is taken from stdin. If the GZIP or PIGZ\nenvironment variables are set, then options are taken from their values before\nany command line options are processed, first from GZIP, then from PIGZ.\n.PP\nCompressed files can be restored to their original form using\n.I pigz -d\nor\n.I unpigz.\n\n.SH OPTIONS\n.TP\n.B -# --fast --best\nRegulate the speed of compression using the specified digit\n.IR # ,\nwhere\n.B \\-1\nor\n.B \\-\\-fast\nindicates the fastest compression method (less compression)\nand\n.B \\-9\nor\n.B \\-\\-best\nindicates the slowest compression method (best compression).\n.B -0\nis no compression.\n.B \\-11\ngives a few percent better compression at a severe cost in execution time,\nusing the zopfli algorithm by Jyrki Alakuijala.\nThe default is\n.B \\-6.\n.TP\n.B -A --alias xxx\nUse xxx as the name for any --zip entry from stdin (the default name is \"-\").\n.TP\n.B -b --blocksize mmm\nSet compression block size to mmmK (default 128KiB).\n.TP\n.B -c --stdout --to-stdout\nWrite all processed output to stdout (won't delete).\n.TP\n.B -C --comment ccc\nInclude the provided comment in the gzip header or zip central file header.\n.TP\n.B -d --decompress --uncompress\nDecompress the compressed input.\n.TP\n.B -f --force\nForce overwrite, compress .gz, links, and to terminal.\n.TP\n.B -h --help\nDisplay a help screen and quit.\n.TP\n.B -H --huffman\nCompress using the Huffman-only strategy.\n.TP\n.B -i --independent\nCompress blocks independently for damage recovery.\n.TP\n.B -k --keep\nDo not delete original file after processing.\n.TP\n.B -K --zip\nCompress to PKWare zip (.zip) single entry format.\n.TP\n.B -l --list\nList the contents of the compressed input.\n.TP\n.B -L --license\nDisplay the\n.I pigz\nlicense and quit.\n.TP\n.B -m --no-time\nDo not store or restore the modification time. -Nm will store or restore the\nname, but not the modification time. Note that the order of the options is\nimportant.\n.TP\n.B -M --time\nStore or restore the modification time. -nM will store or restore the\nmodification time, but not the name. Note that the order of the options is\nimportant. Modification times are stored only for regular files, not pipes.\n.TP\n.B -n --no-name\nDo not store or restore the file name or the modification time. This is the\ndefault when decompressing. When the file name is not restored from the header,\nthe name of the compressed file with the suffix stripped is the name of the\ndecompressed file. When the modification time is not restored from the header,\nthe modification time of the compressed file is used (not the current time).\n.TP\n.B -N --name\nStore or restore both the file name and the modification time. This is the\ndefault when compressing.\n.TP\n.B -p --processes n\nAllow up to n processes (default is the number of online processors)\n.TP\n.B -q --quiet --silent\nPrint no messages, even on error.\n.TP\n.B -r --recursive\nProcess the contents of all subdirectories.\n.TP\n.B -R --rsyncable\nInput-determined block locations for rsync.\n.TP\n.B -S --suffix .sss\nUse suffix .sss instead of .gz (for compression).\n.TP\n.B -t --test\nTest the integrity of the compressed input.\n.TP\n.B -U --rle\nCompress using the run length encoding strategy.\n.TP\n.B -v --verbose\nProvide more verbose output.\n.TP\n.B -V --version\nShow the version of pigz. -vV also shows the zlib version.\n.TP\n.B -z --zlib\nCompress to zlib (.zz) instead of gzip format.\n.TP\n.B --\nAll arguments after \"--\" are treated as file names (for names that start with \"-\")\n.TP\nThese options are unique to the -11 compression level:\n.TP\n.B -F  --first\nDo iterations first, before block split (default is last).\n.TP\n.B -I, --iterations n\nNumber of iterations for optimization (default 15).\n.TP\n.B -J, --maxsplits n\nMaximum number of split blocks (default 15).\n.TP\n.B -O  --oneblock\nDo not split into smaller blocks (default is block splitting).\n.SH \"COPYRIGHT NOTICE\"\nThis software is provided 'as-is', without any express or implied\nwarranty.  In no event will the author be held liable for any damages\narising from the use of this software.\n.PP\nCopyright (C) 2007-2023 Mark Adler <madler@alumni.caltech.edu>\n"
        },
        {
          "name": "pigz.c",
          "type": "blob",
          "size": 175.998046875,
          "content": "/* pigz.c -- parallel implementation of gzip\n * Copyright (C) 2007-2023 Mark Adler\n * Version 2.8  19 Aug 2023  Mark Adler\n */\n\n/*\n  This software is provided 'as-is', without any express or implied\n  warranty. In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler\n  madler@alumni.caltech.edu\n\n */\n\n/* Version history:\n   1.0    17 Jan 2007  First version, pipe only\n   1.1    28 Jan 2007  Avoid void * arithmetic (some compilers don't get that)\n                       Add note about requiring zlib 1.2.3\n                       Allow compression level 0 (no compression)\n                       Completely rewrite parallelism -- add a write thread\n                       Use deflateSetDictionary() to make use of history\n                       Tune argument defaults to best performance on four cores\n   1.2.1   1 Feb 2007  Add long command line options, add all gzip options\n                       Add debugging options\n   1.2.2  19 Feb 2007  Add list (--list) function\n                       Process file names on command line, write .gz output\n                       Write name and time in gzip header, set output file time\n                       Implement all command line options except --recursive\n                       Add --keep option to prevent deleting input files\n                       Add thread tracing information with -vv used\n                       Copy crc32_combine() from zlib (shared libraries issue)\n   1.3    25 Feb 2007  Implement --recursive\n                       Expand help to show all options\n                       Show help if no arguments or output piping are provided\n                       Process options in GZIP environment variable\n                       Add progress indicator to write thread if --verbose\n   1.4     4 Mar 2007  Add --independent to facilitate damaged file recovery\n                       Reallocate jobs for new --blocksize or --processes\n                       Do not delete original if writing to stdout\n                       Allow --processes 1, which does no threading\n                       Add NOTHREAD define to compile without threads\n                       Incorporate license text from zlib in source code\n   1.5    25 Mar 2007  Reinitialize jobs for new compression level\n                       Copy attributes and owner from input file to output file\n                       Add decompression and testing\n                       Add -lt (or -ltv) to show all entries and proper lengths\n                       Add decompression, testing, listing of LZW (.Z) files\n                       Only generate and show trace log if DEBUG defined\n                       Take \"-\" argument to mean read file from stdin\n   1.6    30 Mar 2007  Add zlib stream compression (--zlib), and decompression\n   1.7    29 Apr 2007  Decompress first entry of a zip file (if deflated)\n                       Avoid empty deflate blocks at end of deflate stream\n                       Show zlib check value (Adler-32) when listing\n                       Don't complain when decompressing empty file\n                       Warn about trailing junk for gzip and zlib streams\n                       Make listings consistent, ignore gzip extra flags\n                       Add zip stream compression (--zip)\n   1.8    13 May 2007  Document --zip option in help output\n   2.0    19 Oct 2008  Complete rewrite of thread usage and synchronization\n                       Use polling threads and a pool of memory buffers\n                       Remove direct pthread library use, hide in yarn.c\n   2.0.1  20 Oct 2008  Check version of zlib at compile time, need >= 1.2.3\n   2.1    24 Oct 2008  Decompress with read, write, inflate, and check threads\n                       Remove spurious use of ctime_r(), ctime() more portable\n                       Change application of job->calc lock to be a semaphore\n                       Detect size of off_t at run time to select %lu vs. %llu\n                       #define large file support macro even if not __linux__\n                       Remove _LARGEFILE64_SOURCE, _FILE_OFFSET_BITS is enough\n                       Detect file-too-large error and report, blame build\n                       Replace check combination routines with those from zlib\n   2.1.1  28 Oct 2008  Fix a leak for files with an integer number of blocks\n                       Update for yarn 1.1 (yarn_prefix and yarn_abort)\n   2.1.2  30 Oct 2008  Work around use of beta zlib in production systems\n   2.1.3   8 Nov 2008  Don't use zlib combination routines, put back in pigz\n   2.1.4   9 Nov 2008  Fix bug when decompressing very short files\n   2.1.5  20 Jul 2009  Added 2008, 2009 to --license statement\n                       Allow numeric parameter immediately after -p or -b\n                       Enforce parameter after -p, -b, -s, before other options\n                       Enforce numeric parameters to have only numeric digits\n                       Try to determine the number of processors for -p default\n                       Fix --suffix short option to be -S to match gzip [Bloch]\n                       Decompress if executable named \"unpigz\" [Amundsen]\n                       Add a little bit of testing to Makefile\n   2.1.6  17 Jan 2010  Added pigz.spec to distribution for RPM systems [Brown]\n                       Avoid some compiler warnings\n                       Process symbolic links if piping to stdout [Hoffstätte]\n                       Decompress if executable named \"gunzip\" [Hoffstätte]\n                       Allow \".tgz\" suffix [Chernookiy]\n                       Fix adler32 comparison on .zz files\n   2.1.7  17 Dec 2011  Avoid unused parameter warning in reenter()\n                       Don't assume 2's complement ints in compress_thread()\n                       Replicate gzip -cdf cat-like behavior\n                       Replicate gzip -- option to suppress option decoding\n                       Test output from make test instead of showing it\n                       Updated pigz.spec to install unpigz, pigz.1 [Obermaier]\n                       Add PIGZ environment variable [Mueller]\n                       Replicate gzip suffix search when decoding or listing\n                       Fix bug in load() to set in_left to zero on end of file\n                       Do not check suffix when input file won't be modified\n                       Decompress to stdout if name is \"*cat\" [Hayasaka]\n                       Write data descriptor signature to be like Info-ZIP\n                       Update and sort options list in help\n                       Use CC variable for compiler in Makefile\n                       Exit with code 2 if a warning has been issued\n                       Fix thread synchronization problem when tracing\n                       Change macro name MAX to MAX2 to avoid library conflicts\n                       Determine number of processors on HP-UX [Lloyd]\n   2.2    31 Dec 2011  Check for expansion bound busting (e.g. modified zlib)\n                       Make the \"threads\" list head global variable volatile\n                       Fix construction and printing of 32-bit check values\n                       Add --rsyncable functionality\n   2.2.1   1 Jan 2012  Fix bug in --rsyncable buffer management\n   2.2.2   1 Jan 2012  Fix another bug in --rsyncable buffer management\n   2.2.3  15 Jan 2012  Remove volatile in yarn.c\n                       Reduce the number of input buffers\n                       Change initial rsyncable hash to comparison value\n                       Improve the efficiency of arriving at a byte boundary\n                       Add thread portability #defines from yarn.c\n                       Have rsyncable compression be independent of threading\n                       Fix bug where constructed dictionaries not being used\n   2.2.4  11 Mar 2012  Avoid some return value warnings\n                       Improve the portability of printing the off_t type\n                       Check for existence of compress binary before using\n                       Update zlib version checking to 1.2.6 for new functions\n                       Fix bug in zip (-K) output\n                       Fix license in pigz.spec\n                       Remove thread portability #defines in pigz.c\n   2.2.5  28 Jul 2012  Avoid race condition in free_pool()\n                       Change suffix to .tar when decompressing or listing .tgz\n                       Print name of executable in error messages\n                       Show help properly when the name is unpigz or gunzip\n                       Fix permissions security problem before output is closed\n   2.3     3 Mar 2013  Don't complain about missing suffix on stdout\n                       Put all global variables in a structure for readability\n                       Do not decompress concatenated zlib streams (just gzip)\n                       Add option for compression level 11 to use zopfli\n                       Fix handling of junk after compressed data\n   2.3.1   9 Oct 2013  Fix builds of pigzt and pigzn to include zopfli\n                       Add -lm, needed to link log function on some systems\n                       Respect LDFLAGS in Makefile, use CFLAGS consistently\n                       Add memory allocation tracking\n                       Fix casting error in uncompressed length calculation\n                       Update zopfli to Mar 10, 2013 Google state\n                       Support zopfli in single thread case\n                       Add -F, -I, -M, and -O options for zopfli tuning\n   2.3.2  24 Jan 2015  Change whereis to which in Makefile for portability\n                       Return zero exit code when only warnings are issued\n                       Increase speed of unlzw (Unix compress decompression)\n                       Update zopfli to current google state\n                       Allow larger maximum blocksize (-b), now 512 MiB\n                       Do not require that -d precede -N, -n, -T options\n                       Strip any path from header name for -dN or -dNT\n                       Remove use of PATH_MAX (PATH_MAX is not reliable)\n                       Do not abort on inflate data error, do remaining files\n                       Check gzip header CRC if present\n                       Improve decompression error detection and reporting\n   2.3.3  24 Jan 2015  Portability improvements\n                       Update copyright years in documentation\n   2.3.4   1 Oct 2016  Fix an out of bounds access due to invalid LZW input\n                       Add an extra sync marker between independent blocks\n                       Add zlib version for verbose version option (-vV)\n                       Permit named pipes as input (e.g. made by mkfifo())\n                       Fix a bug in -r directory traversal\n                       Add warning for a zip file entry 4 GiB or larger\n   2.4    26 Dec 2017  Portability improvements\n                       Produce Zip64 format when needed for --zip (>= 4 GiB)\n                       Make -no-name compatible with gzip, add --time option\n                       Add -m as a short option for --no-time\n                       Check run-time zlib version to handle weak linking\n                       Fix a concurrent read bug in --list operation\n                       Process options first, for gzip compatibility\n                       Add --synchronous (-Y) option to force device write\n                       Disallow an empty suffix (e.g. --suffix '')\n                       Return an exit code of 1 if any issues are encountered\n                       Fix sign error in compression reduction percentage\n   2.5    23 Jan 2021  Add --alias/-A option to set .zip name for stdin input\n                       Add --comment/-C option to add comment in .gz or .zip\n                       Fix a bug that misidentified a multi-entry .zip\n                       Fix a bug that did not emit double syncs for -i -p 1\n                       Fix a bug in yarn that could try to access freed data\n                       Do not delete multi-entry .zip files when extracting\n                       Do not reject .zip entries with bit 11 set\n                       Avoid a possible threads lock-order inversion\n                       Ignore trailing junk after a gzip stream by default\n   2.6     6 Feb 2021  Add --huffman/-H and --rle/U strategy options\n                       Fix issue when compiling for no threads\n                       Fail silently on a broken pipe\n   2.7    15 Jan 2022  Show time stamp only for the first gzip member\n                       Show totals when listing more than one gzip member\n                       Don't unlink input file if it has other links\n                       Add documentation for environment variables\n                       Fix bug when combining -l with -d\n                       Exit with status of zero if skipping non .gz files\n                       Permit Huffman only (-H) when not compiling with zopfli\n   2.8    19 Aug 2023  Fix version bug when compiling with zlib 1.3\n                       Save a modification time only for regular files\n                       Write all available uncompressed data on an error\n */\n\n#define VERSION \"pigz 2.8\"\n\n/* To-do:\n    - make source portable for Windows, VMS, etc. (see gzip source code)\n    - make build portable (currently good for Unixish)\n */\n\n/*\n   pigz compresses using threads to make use of multiple processors and cores.\n   The input is broken up into 128 KB chunks with each compressed in parallel.\n   The individual check value for each chunk is also calculated in parallel.\n   The compressed data is written in order to the output, and a combined check\n   value is calculated from the individual check values.\n\n   The compressed data format generated is in the gzip, zlib, or single-entry\n   zip format using the deflate compression method. The compression produces\n   partial raw deflate streams which are concatenated by a single write thread\n   and wrapped with the appropriate header and trailer, where the trailer\n   contains the combined check value.\n\n   Each partial raw deflate stream is terminated by an empty stored block\n   (using the Z_SYNC_FLUSH option of zlib), in order to end that partial bit\n   stream at a byte boundary, unless that partial stream happens to already end\n   at a byte boundary (the latter requires zlib 1.2.6 or later). Ending on a\n   byte boundary allows the partial streams to be concatenated simply as\n   sequences of bytes. This adds a very small four to five byte overhead\n   (average 3.75 bytes) to the output for each input chunk.\n\n   The default input block size is 128K, but can be changed with the -b option.\n   The number of compress threads is set by default to 8, which can be changed\n   using the -p option. Specifying -p 1 avoids the use of threads entirely.\n   pigz will try to determine the number of processors in the machine, in which\n   case if that number is two or greater, pigz will use that as the default for\n   -p instead of 8.\n\n   The input blocks, while compressed independently, have the last 32K of the\n   previous block loaded as a preset dictionary to preserve the compression\n   effectiveness of deflating in a single thread. This can be turned off using\n   the --independent or -i option, so that the blocks can be decompressed\n   independently for partial error recovery or for random access.\n\n   Decompression can't be parallelized over an arbitrary number of processors\n   like compression can be, at least not without specially prepared deflate\n   streams for that purpose. As a result, pigz uses a single thread (the main\n   thread) for decompression, but will create three other threads for reading,\n   writing, and check calculation, which can speed up decompression under some\n   circumstances. Parallel decompression can be turned off by specifying one\n   process (-dp 1 or -tp 1).\n\n   pigz requires zlib 1.2.1 or later to allow setting the dictionary when doing\n   raw deflate. Since zlib 1.2.3 corrects security vulnerabilities in zlib\n   version 1.2.1 and 1.2.2, conditionals check for zlib 1.2.3 or later during\n   the compilation of pigz.c. zlib 1.2.4 includes some improvements to\n   Z_FULL_FLUSH and deflateSetDictionary() that permit identical output for\n   pigz with and without threads, which is not possible with zlib 1.2.3. This\n   may be important for uses of pigz -R where small changes in the contents\n   should result in small changes in the archive for rsync. Note that due to\n   the details of how the lower levels of compression result in greater speed,\n   compression level 3 and below does not permit identical pigz output with and\n   without threads.\n\n   pigz uses the POSIX pthread library for thread control and communication,\n   through the yarn.h interface to yarn.c. yarn.c can be replaced with\n   equivalent implementations using other thread libraries. pigz can be\n   compiled with NOTHREAD #defined to not use threads at all (in which case\n   pigz will not be able to live up to the \"parallel\" in its name).\n */\n\n/*\n   Details of parallel compression implementation:\n\n   When doing parallel compression, pigz uses the main thread to read the input\n   in 'size' sized chunks (see -b), and puts those in a compression job list,\n   each with a sequence number to keep track of the ordering. If it is not the\n   first chunk, then that job also points to the previous input buffer, from\n   which the last 32K will be used as a dictionary (unless -i is specified).\n   This sets a lower limit of 32K on 'size'.\n\n   pigz launches up to 'procs' compression threads (see -p). Each compression\n   thread continues to look for jobs in the compression list and perform those\n   jobs until instructed to return. When a job is pulled, the dictionary, if\n   provided, will be loaded into the deflate engine and then that input buffer\n   is dropped for reuse. Then the input data is compressed into an output\n   buffer that grows in size if necessary to hold the compressed data. The job\n   is then put into the write job list, sorted by the sequence number. The\n   compress thread however continues to calculate the check value on the input\n   data, either a CRC-32 or Adler-32, possibly in parallel with the write\n   thread writing the output data. Once that's done, the compress thread drops\n   the input buffer and also releases the lock on the check value so that the\n   write thread can combine it with the previous check values. The compress\n   thread has then completed that job, and goes to look for another.\n\n   All of the compress threads are left running and waiting even after the last\n   chunk is processed, so that they can support the next input to be compressed\n   (more than one input file on the command line). Once pigz is done, it will\n   call all the compress threads home (that'll do pig, that'll do).\n\n   Before starting to read the input, the main thread launches the write thread\n   so that it is ready pick up jobs immediately. The compress thread puts the\n   write jobs in the list in sequence sorted order, so that the first job in\n   the list is always has the lowest sequence number. The write thread waits\n   for the next write job in sequence, and then gets that job. The job still\n   holds its input buffer, from which the write thread gets the input buffer\n   length for use in check value combination. Then the write thread drops that\n   input buffer to allow its reuse. Holding on to the input buffer until the\n   write thread starts also has the benefit that the read and compress threads\n   can't get way ahead of the write thread and build up a large backlog of\n   unwritten compressed data. The write thread will write the compressed data,\n   drop the output buffer, and then wait for the check value to be unlocked by\n   the compress thread. Then the write thread combines the check value for this\n   chunk with the total check value for eventual use in the trailer. If this is\n   not the last chunk, the write thread then goes back to look for the next\n   output chunk in sequence. After the last chunk, the write thread returns and\n   joins the main thread. Unlike the compress threads, a new write thread is\n   launched for each input stream. The write thread writes the appropriate\n   header and trailer around the compressed data.\n\n   The input and output buffers are reused through their collection in pools.\n   Each buffer has a use count, which when decremented to zero returns the\n   buffer to the respective pool. Each input buffer has up to three parallel\n   uses: as the input for compression, as the data for the check value\n   calculation, and as a dictionary for compression. Each output buffer has\n   only one use, which is as the output of compression followed serially as\n   data to be written. The input pool is limited in the number of buffers, so\n   that reading does not get way ahead of compression and eat up memory with\n   more input than can be used. The limit is approximately two times the number\n   of compression threads. In the case that reading is fast as compared to\n   compression, that number allows a second set of buffers to be read while the\n   first set of compressions are being performed. The number of output buffers\n   is not directly limited, but is indirectly limited by the release of input\n   buffers to about the same number.\n */\n\n// Portability defines.\n#define _FILE_OFFSET_BITS 64            // Use large file functions\n#define _LARGE_FILES                    // Same thing for AIX\n#define _XOPEN_SOURCE 700               // For POSIX 2008\n\n// Included headers and what is expected from each.\n#include <stdio.h>      // fflush(), fprintf(), fputs(), getchar(), putc(),\n                        // puts(), printf(), vasprintf(), stderr, EOF, NULL,\n                        // SEEK_END, size_t, off_t\n#include <stdlib.h>     // exit(), malloc(), free(), realloc(), atol(), atoi(),\n                        // getenv()\n#include <stdarg.h>     // va_start(), va_arg(), va_end(), va_list\n#include <string.h>     // memset(), memchr(), memcpy(), strcmp(), strcpy(),\n                        // strncpy(), strlen(), strcat(), strrchr(),\n                        // strerror()\n#include <errno.h>      // errno, EEXIST\n#include <assert.h>     // assert()\n#include <time.h>       // ctime(), time(), time_t, mktime()\n#include <signal.h>     // signal(), SIGINT\n#include <sys/types.h>  // ssize_t\n#include <sys/stat.h>   // chmod(), stat(), fstat(), lstat(), struct stat,\n                        // S_IFDIR, S_IFLNK, S_IFMT, S_IFREG\n#include <sys/time.h>   // utimes(), gettimeofday(), struct timeval\n#include <unistd.h>     // unlink(), _exit(), read(), write(), close(),\n                        // lseek(), isatty(), chown(), fsync()\n#include <fcntl.h>      // open(), O_CREAT, O_EXCL, O_RDONLY, O_TRUNC,\n                        // O_WRONLY, fcntl(), F_FULLFSYNC\n#include <dirent.h>     // opendir(), readdir(), closedir(), DIR,\n                        // struct dirent\n#include <limits.h>     // UINT_MAX, INT_MAX\n#if __STDC_VERSION__-0 >= 199901L || __GNUC__-0 >= 3\n#  include <inttypes.h> // intmax_t, uintmax_t\n   typedef uintmax_t length_t;\n   typedef uint32_t crc_t;\n   typedef uint_least16_t prefix_t;\n#else\n   typedef unsigned long length_t;\n   typedef unsigned long crc_t;\n   typedef unsigned prefix_t;\n#endif\n\n#ifdef PIGZ_DEBUG\n#  if defined(__APPLE__)\n#    include <malloc/malloc.h>\n#    define MALLOC_SIZE(p) malloc_size(p)\n#  elif defined (__linux)\n#    include <malloc.h>\n#    define MALLOC_SIZE(p) malloc_usable_size(p)\n#  elif defined (_WIN32) || defined(_WIN64)\n#    include <malloc.h>\n#    define MALLOC_SIZE(p) _msize(p)\n#  else\n#    define MALLOC_SIZE(p) (0)\n#  endif\n#endif\n\n#ifdef __hpux\n#  include <sys/param.h>\n#  include <sys/pstat.h>\n#endif\n\n#ifndef S_IFLNK\n#  define S_IFLNK 0\n#endif\n\n#ifdef __MINGW32__\n#  define chown(p,o,g) 0\n#  define utimes(p,t)  0\n#  define lstat(p,s)   stat(p,s)\n#  define _exit(s)     exit(s)\n#endif\n\n#include \"zlib.h\"       // deflateInit2(), deflateReset(), deflate(),\n                        // deflateEnd(), deflateSetDictionary(), crc32(),\n                        // adler32(), inflateBackInit(), inflateBack(),\n                        // inflateBackEnd(), Z_DEFAULT_COMPRESSION,\n                        // Z_DEFAULT_STRATEGY, Z_DEFLATED, Z_NO_FLUSH, Z_NULL,\n                        // Z_OK, Z_SYNC_FLUSH, z_stream\n#if !defined(ZLIB_VERNUM) || ZLIB_VERNUM < 0x1230\n#  error \"Need zlib version 1.2.3 or later\"\n#endif\n\n#ifndef NOTHREAD\n#  include \"yarn.h\"     // thread, launch(), join(), join_all(), lock,\n                        // new_lock(), possess(), twist(), wait_for(),\n                        // release(), peek_lock(), free_lock(), yarn_name\n#endif\n\n#ifndef NOZOPFLI\n#  include \"zopfli/src/zopfli/deflate.h\"    // ZopfliDeflatePart(),\n                                            // ZopfliInitOptions(),\n                                            // ZopfliOptions\n#endif\n\n#include \"try.h\"        // try, catch, always, throw, drop, punt, ball_t\n\n// For local functions and globals.\n#define local static\n\n// Prevent end-of-line conversions on MSDOSish operating systems.\n#if defined(MSDOS) || defined(OS2) || defined(_WIN32) || defined(__CYGWIN__)\n#  include <io.h>       // setmode(), O_BINARY, _commit() for _WIN32\n#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)\n#else\n#  define SET_BINARY_MODE(fd)\n#endif\n\n// Release an allocated pointer, if allocated, and mark as unallocated.\n#define RELEASE(ptr) \\\n    do { \\\n        if ((ptr) != NULL) { \\\n            FREE(ptr); \\\n            ptr = NULL; \\\n        } \\\n    } while (0)\n\n// Sliding dictionary size for deflate.\n#define DICT 32768U\n\n// Largest power of 2 that fits in an unsigned int. Used to limit requests to\n// zlib functions that use unsigned int lengths.\n#define MAXP2 (UINT_MAX - (UINT_MAX >> 1))\n\n/* rsyncable constants -- RSYNCBITS is the number of bits in the mask for\n   comparison. For random input data, there will be a hit on average every\n   1<<RSYNCBITS bytes. So for an RSYNCBITS of 12, there will be an average of\n   one hit every 4096 bytes, resulting in a mean block size of 4096. RSYNCMASK\n   is the resulting bit mask. RSYNCHIT is what the hash value is compared to\n   after applying the mask.\n\n   The choice of 12 for RSYNCBITS is consistent with the original rsyncable\n   patch for gzip which also uses a 12-bit mask. This results in a relatively\n   small hit to compression, on the order of 1.5% to 3%. A mask of 13 bits can\n   be used instead if a hit of less than 1% to the compression is desired, at\n   the expense of more blocks transmitted for rsync updates. (Your mileage may\n   vary.)\n\n   This implementation of rsyncable uses a different hash algorithm than what\n   the gzip rsyncable patch uses in order to provide better performance in\n   several regards. The algorithm is simply to shift the hash value left one\n   bit and exclusive-or that with the next byte. This is masked to the number\n   of hash bits (RSYNCMASK) and compared to all ones except for a zero in the\n   top bit (RSYNCHIT). This rolling hash has a very small window of 19 bytes\n   (RSYNCBITS+7). The small window provides the benefit of much more rapid\n   resynchronization after a change, than does the 4096-byte window of the gzip\n   rsyncable patch.\n\n   The comparison value is chosen to avoid matching any repeated bytes or short\n   sequences. The gzip rsyncable patch on the other hand uses a sum and zero\n   for comparison, which results in certain bad behaviors, such as always\n   matching everywhere in a long sequence of zeros. Such sequences occur\n   frequently in tar files.\n\n   This hash efficiently discards history older than 19 bytes simply by\n   shifting that data past the top of the mask -- no history needs to be\n   retained to undo its impact on the hash value, as is needed for a sum.\n\n   The choice of the comparison value (RSYNCHIT) has the virtue of avoiding\n   extremely short blocks. The shortest block is five bytes (RSYNCBITS-7) from\n   hit to hit, and is unlikely. Whereas with the gzip rsyncable algorithm,\n   blocks of one byte are not only possible, but in fact are the most likely\n   block size.\n\n   Thanks and acknowledgement to Kevin Day for his experimentation and insights\n   on rsyncable hash characteristics that led to some of the choices here.\n */\n#define RSYNCBITS 12\n#define RSYNCMASK ((1U << RSYNCBITS) - 1)\n#define RSYNCHIT (RSYNCMASK >> 1)\n\n// Initial pool counts and sizes -- INBUFS is the limit on the number of input\n// spaces as a function of the number of processors (used to throttle the\n// creation of compression jobs), OUTPOOL is the initial size of the output\n// data buffer, chosen to make resizing of the buffer very unlikely and to\n// allow prepending with a dictionary for use as an input buffer for zopfli.\n#define INBUFS(p) (((p)<<1)+3)\n#define OUTPOOL(s) ((s)+((s)>>4)+DICT)\n\n// Input buffer size, and augmentation for re-inserting a central header.\n#define BUF 32768\n#define CEN 42\n#define EXT (BUF + CEN)     // provide enough room to unget a header\n\n// Globals (modified by main thread only when it's the only thread).\nlocal struct {\n    int ret;                // pigz return code\n    char *prog;             // name by which pigz was invoked\n    int ind;                // input file descriptor\n    int outd;               // output file descriptor\n    char *inf;              // input file name (allocated)\n    size_t inz;             // input file name allocated size\n    char *outf;             // output file name (allocated)\n    int verbosity;          // 0 = quiet, 1 = normal, 2 = verbose, 3 = trace\n    int headis;             // 1 to store name, 2 to store date, 3 both\n    int pipeout;            // write output to stdout even if file\n    int keep;               // true to prevent deletion of input file\n    int force;              // true to overwrite, compress links, cat\n    int sync;               // true to flush output file\n    int form;               // gzip = 0, zlib = 1, zip = 2 or 3\n    int magic1;             // first byte of possible header when decoding\n    int recurse;            // true to dive down into directory structure\n    char *sufx;             // suffix to use (\".gz\" or user supplied)\n    char *name;             // name for gzip or zip header\n    char *alias;            // name for zip header when input is stdin\n    char *comment;          // comment for gzip or zip header.\n    time_t mtime;           // time stamp from input file for gzip header\n    int list;               // true to list files instead of compress\n    int first;              // true if we need to print listing header\n    int decode;             // 0 to compress, 1 to decompress, 2 to test\n    int level;              // compression level\n    int strategy;           // compression strategy\n#ifndef NOZOPFLI\n    ZopfliOptions zopts;    // zopfli compression options\n#endif\n    int rsync;              // true for rsync blocking\n    int procs;              // maximum number of compression threads (>= 1)\n    int setdict;            // true to initialize dictionary in each thread\n    size_t block;           // uncompressed input size per thread (>= 32K)\n    crc_t shift;            // pre-calculated CRC-32 shift for length block\n\n    // saved gzip/zip header data for decompression, testing, and listing\n    time_t stamp;           // time stamp from gzip header\n    char *hname;            // name from header (allocated)\n    char *hcomm;            // comment from header (allocated)\n    unsigned long zip_crc;  // local header crc\n    length_t zip_clen;      // local header compressed length\n    length_t zip_ulen;      // local header uncompressed length\n    int zip64;              // true if has zip64 extended information\n\n    // globals for decompression and listing buffered reading\n    unsigned char in_buf[EXT];  // input buffer\n    unsigned char *in_next; // next unused byte in buffer\n    size_t in_left;         // number of unused bytes in buffer\n    int in_eof;             // true if reached end of file on input\n    int in_short;           // true if last read didn't fill buffer\n    length_t in_tot;        // total bytes read from input\n    length_t out_tot;       // total bytes written to output\n    unsigned long out_check;    // check value of output\n\n#ifndef NOTHREAD\n    // globals for decompression parallel reading\n    unsigned char in_buf2[EXT]; // second buffer for parallel reads\n    size_t in_len;          // data waiting in next buffer\n    int in_which;           // -1: start, 0: in_buf2, 1: in_buf\n    lock *load_state;       // value = 0 to wait, 1 to read a buffer\n    thread *load_thread;    // load_read() thread for joining\n#endif\n} g;\n\nlocal void message(char *fmt, va_list ap) {\n    if (g.verbosity > 0) {\n        fprintf(stderr, \"%s: \", g.prog);\n        vfprintf(stderr, fmt, ap);\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n}\n\n// Display a complaint with the program name on stderr.\nlocal int complain(char *fmt, ...) {\n    g.ret = 1;\n    va_list ap;\n    va_start(ap, fmt);\n    message(fmt, ap);\n    va_end(ap);\n    return 0;\n}\n\n// Same as complain(), but don't force a bad return code.\nlocal int grumble(char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    message(fmt, ap);\n    va_end(ap);\n    return 0;\n}\n\n#ifdef PIGZ_DEBUG\n\n// Memory tracking.\n\n#define MAXMEM 131072   // maximum number of tracked pointers\n\nlocal struct mem_track_s {\n    size_t num;         // current number of allocations\n    size_t size;        // total size of current allocations\n    size_t tot;         // maximum number of allocations\n    size_t max;         // maximum size of allocations\n#ifndef NOTHREAD\n    lock *lock;         // lock for access across threads\n#endif\n    size_t have;        // number in array (possibly != num)\n    void *mem[MAXMEM];  // sorted array of allocated pointers\n} mem_track;\n\n#ifndef NOTHREAD\n#  define mem_track_grab(m) possess((m)->lock)\n#  define mem_track_drop(m) release((m)->lock)\n#else\n#  define mem_track_grab(m)\n#  define mem_track_drop(m)\n#endif\n\n// Return the leftmost insert location of ptr in the sorted list mem->mem[],\n// which currently has mem->have elements. If ptr is already in the list, the\n// returned value will point to its first occurrence. The return location will\n// be one after the last element if ptr is greater than all of the elements.\nlocal size_t search_track(struct mem_track_s *mem, void *ptr) {\n    ptrdiff_t left = 0;\n    ptrdiff_t right = mem->have - 1;\n    while (left <= right) {\n        ptrdiff_t mid = (left + right) >> 1;\n        if (mem->mem[mid] < ptr)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return left;\n}\n\n// Insert ptr in the sorted list mem->mem[] and update the memory allocation\n// statistics.\nlocal void insert_track(struct mem_track_s *mem, void *ptr) {\n    mem_track_grab(mem);\n    assert(mem->have < MAXMEM && \"increase MAXMEM in source and try again\");\n    size_t i = search_track(mem, ptr);\n    if (i < mem->have && mem->mem[i] == ptr)\n        complain(\"mem_track: duplicate pointer %p\\n\", ptr);\n    memmove(&mem->mem[i + 1], &mem->mem[i],\n            (mem->have - i) * sizeof(void *));\n    mem->mem[i] = ptr;\n    mem->have++;\n    mem->num++;\n    mem->size += MALLOC_SIZE(ptr);\n    if (mem->num > mem->tot)\n        mem->tot = mem->num;\n    if (mem->size > mem->max)\n        mem->max = mem->size;\n    mem_track_drop(mem);\n}\n\n// Find and delete ptr from the sorted list mem->mem[] and update the memory\n// allocation statistics.\nlocal void delete_track(struct mem_track_s *mem, void *ptr) {\n    mem_track_grab(mem);\n    size_t i = search_track(mem, ptr);\n    if (i < mem->num && mem->mem[i] == ptr) {\n        memmove(&mem->mem[i], &mem->mem[i + 1],\n                (mem->have - (i + 1)) * sizeof(void *));\n        mem->have--;\n    }\n    else\n        complain(\"mem_track: missing pointer %p\\n\", ptr);\n    mem->num--;\n    mem->size -= MALLOC_SIZE(ptr);\n    mem_track_drop(mem);\n}\n\nlocal void *malloc_track(struct mem_track_s *mem, size_t size) {\n    void *ptr = malloc(size);\n    if (ptr != NULL)\n        insert_track(mem, ptr);\n    return ptr;\n}\n\nlocal void *realloc_track(struct mem_track_s *mem, void *ptr, size_t size) {\n    if (ptr == NULL)\n        return malloc_track(mem, size);\n    delete_track(mem, ptr);\n    void *got = realloc(ptr, size);\n    insert_track(mem, got == NULL ? ptr : got);\n    return got;\n}\n\nlocal void free_track(struct mem_track_s *mem, void *ptr) {\n    if (ptr != NULL) {\n        delete_track(mem, ptr);\n        free(ptr);\n    }\n}\n\n#ifndef NOTHREAD\nlocal void *yarn_malloc(size_t size) {\n    return malloc_track(&mem_track, size);\n}\n\nlocal void yarn_free(void *ptr) {\n    free_track(&mem_track, ptr);\n}\n#endif\n\nlocal voidpf zlib_alloc(voidpf opaque, uInt items, uInt size) {\n    return malloc_track(opaque, items * (size_t)size);\n}\n\nlocal void zlib_free(voidpf opaque, voidpf address) {\n    free_track(opaque, address);\n}\n\n#define REALLOC(p, s) realloc_track(&mem_track, p, s)\n#define FREE(p) free_track(&mem_track, p)\n#define OPAQUE (&mem_track)\n#define ZALLOC zlib_alloc\n#define ZFREE zlib_free\n\n#else // !PIGZ_DEBUG\n\n#define REALLOC realloc\n#define FREE free\n#define OPAQUE Z_NULL\n#define ZALLOC Z_NULL\n#define ZFREE Z_NULL\n\n#endif\n\n// Assured memory allocation.\nlocal void *alloc(void *ptr, size_t size) {\n    ptr = REALLOC(ptr, size);\n    if (ptr == NULL)\n        throw(ENOMEM, \"not enough memory\");\n    return ptr;\n}\n\n#ifdef PIGZ_DEBUG\n\n// Logging.\n\n// Starting time of day for tracing.\nlocal struct timeval start;\n\n// Trace log.\nlocal struct log {\n    struct timeval when;    // time of entry\n    char *msg;              // message\n    struct log *next;       // next entry\n} *log_head, **log_tail = NULL;\n#ifndef NOTHREAD\n  local lock *log_lock = NULL;\n#endif\n\n// Maximum log entry length.\n#define MAXMSG 256\n\n// Set up log (call from main thread before other threads launched).\nlocal void log_init(void) {\n    if (log_tail == NULL) {\n        mem_track.num = 0;\n        mem_track.size = 0;\n        mem_track.num = 0;\n        mem_track.max = 0;\n        mem_track.have = 0;\n#ifndef NOTHREAD\n        mem_track.lock = new_lock(0);\n        yarn_mem(yarn_malloc, yarn_free);\n        log_lock = new_lock(0);\n#endif\n        log_head = NULL;\n        log_tail = &log_head;\n    }\n}\n\n// Add entry to trace log.\nlocal void log_add(char *fmt, ...) {\n    struct timeval now;\n    struct log *me;\n    va_list ap;\n    char msg[MAXMSG];\n\n    gettimeofday(&now, NULL);\n    me = alloc(NULL, sizeof(struct log));\n    me->when = now;\n    va_start(ap, fmt);\n    vsnprintf(msg, MAXMSG, fmt, ap);\n    va_end(ap);\n    me->msg = alloc(NULL, strlen(msg) + 1);\n    strcpy(me->msg, msg);\n    me->next = NULL;\n#ifndef NOTHREAD\n    assert(log_lock != NULL);\n    possess(log_lock);\n#endif\n    *log_tail = me;\n    log_tail = &(me->next);\n#ifndef NOTHREAD\n    twist(log_lock, BY, +1);\n#endif\n}\n\n// Pull entry from trace log and print it, return false if empty.\nlocal int log_show(void) {\n    struct log *me;\n    struct timeval diff;\n\n    if (log_tail == NULL)\n        return 0;\n#ifndef NOTHREAD\n    possess(log_lock);\n#endif\n    me = log_head;\n    if (me == NULL) {\n#ifndef NOTHREAD\n        release(log_lock);\n#endif\n        return 0;\n    }\n    log_head = me->next;\n    if (me->next == NULL)\n        log_tail = &log_head;\n#ifndef NOTHREAD\n    twist(log_lock, BY, -1);\n#endif\n    diff.tv_usec = me->when.tv_usec - start.tv_usec;\n    diff.tv_sec = me->when.tv_sec - start.tv_sec;\n    if (diff.tv_usec < 0) {\n        diff.tv_usec += 1000000L;\n        diff.tv_sec--;\n    }\n    fprintf(stderr, \"trace %ld.%06ld %s\\n\",\n            (long)diff.tv_sec, (long)diff.tv_usec, me->msg);\n    fflush(stderr);\n    FREE(me->msg);\n    FREE(me);\n    return 1;\n}\n\n// Release log resources (need to do log_init() to use again).\nlocal void log_free(void) {\n    struct log *me;\n\n    if (log_tail != NULL) {\n#ifndef NOTHREAD\n        possess(log_lock);\n#endif\n        while ((me = log_head) != NULL) {\n            log_head = me->next;\n            FREE(me->msg);\n            FREE(me);\n        }\n#ifndef NOTHREAD\n        twist(log_lock, TO, 0);\n        free_lock(log_lock);\n        log_lock = NULL;\n        yarn_mem(malloc, free);\n        free_lock(mem_track.lock);\n#endif\n        log_tail = NULL;\n    }\n}\n\n// Show entries until no more, free log.\nlocal void log_dump(void) {\n    if (log_tail == NULL)\n        return;\n    while (log_show())\n        ;\n    log_free();\n    if (mem_track.num || mem_track.size)\n        complain(\"memory leak: %zu allocs of %zu bytes total\",\n                 mem_track.num, mem_track.size);\n    if (mem_track.max)\n        fprintf(stderr, \"%zu bytes of memory used in %zu allocs\\n\",\n                mem_track.max, mem_track.tot);\n}\n\n// Debugging macro.\n#define Trace(x) \\\n    do { \\\n        if (g.verbosity > 2) { \\\n            log_add x; \\\n        } \\\n    } while (0)\n\n#else // !PIGZ_DEBUG\n\n#define log_dump()\n#define Trace(x)\n\n#endif\n\n// Abort or catch termination signal.\nlocal void cut_short(int sig) {\n    if (sig == SIGINT) {\n        Trace((\"termination by user\"));\n    }\n    if (g.outd != -1 && g.outd != 1) {\n        unlink(g.outf);\n        RELEASE(g.outf);\n        g.outd = -1;\n    }\n    log_dump();\n    _exit(sig < 0 ? -sig : EINTR);\n}\n\n// Common code for catch block of top routine in the thread.\n#define THREADABORT(ball) \\\n    do { \\\n        if ((ball).code != EPIPE) \\\n            complain(\"abort: %s\", (ball).why); \\\n        drop(ball); \\\n        cut_short(-(ball).code); \\\n    } while (0)\n\n// Compute next size up by multiplying by about 2**(1/3) and rounding to the\n// next power of 2 if close (three applications results in doubling). If small,\n// go up to at least 16, if overflow, go to max size_t value.\nlocal inline size_t grow(size_t size) {\n    size_t was, top;\n    int shift;\n\n    was = size;\n    size += size >> 2;\n    top = size;\n    for (shift = 0; top > 7; shift++)\n        top >>= 1;\n    if (top == 7)\n        size = (size_t)1 << (shift + 3);\n    if (size < 16)\n        size = 16;\n    if (size <= was)\n        size = (size_t)0 - 1;\n    return size;\n}\n\n// Copy cpy[0..len-1] to *mem + off, growing *mem if necessary, where *size is\n// the allocated size of *mem. Return the number of bytes in the result.\nlocal inline size_t vmemcpy(char **mem, size_t *size, size_t off,\n                            void *cpy, size_t len) {\n    size_t need;\n\n    need = off + len;\n    if (need < off)\n        throw(ERANGE, \"overflow\");\n    if (need > *size) {\n        need = grow(need);\n        if (off == 0) {\n            RELEASE(*mem);\n            *size = 0;\n        }\n        *mem = alloc(*mem, need);\n        *size = need;\n    }\n    memcpy(*mem + off, cpy, len);\n    return off + len;\n}\n\n// Copy the zero-terminated string cpy to *str + off, growing *str if\n// necessary, where *size is the allocated size of *str. Return the length of\n// the string plus one.\nlocal inline size_t vstrcpy(char **str, size_t *size, size_t off, void *cpy) {\n    return vmemcpy(str, size, off, cpy, strlen(cpy) + 1);\n}\n\n// Read up to len bytes into buf, repeating read() calls as needed.\nlocal size_t readn(int desc, unsigned char *buf, size_t len) {\n    ssize_t ret;\n    size_t got;\n\n    got = 0;\n    while (len) {\n        ret = read(desc, buf, len);\n        if (ret < 0)\n            throw(errno, \"read error on %s (%s)\", g.inf, strerror(errno));\n        if (ret == 0)\n            break;\n        buf += ret;\n        len -= (size_t)ret;\n        got += (size_t)ret;\n    }\n    return got;\n}\n\n// Write len bytes, repeating write() calls as needed. Return len.\nlocal size_t writen(int desc, void const *buf, size_t len) {\n    char const *next = buf;\n    size_t left = len;\n\n    while (left) {\n        size_t const max = SSIZE_MAX;\n        ssize_t ret = write(desc, next, left > max ? max : left);\n        if (ret < 1)\n            throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));\n        next += ret;\n        left -= (size_t)ret;\n    }\n    return len;\n}\n\n// Convert Unix time to MS-DOS date and time, assuming the current timezone.\n// (You got a better idea?)\nlocal unsigned long time2dos(time_t t) {\n    struct tm *tm;\n    unsigned long dos;\n\n    if (t == 0)\n        t = time(NULL);\n    tm = localtime(&t);\n    if (tm->tm_year < 80 || tm->tm_year > 207)\n        return 0;\n    dos = (unsigned long)(tm->tm_year - 80) << 25;\n    dos += (unsigned long)(tm->tm_mon + 1) << 21;\n    dos += (unsigned long)tm->tm_mday << 16;\n    dos += (unsigned long)tm->tm_hour << 11;\n    dos += (unsigned long)tm->tm_min << 5;\n    dos += (unsigned long)(tm->tm_sec + 1) >> 1;    // round to even seconds\n    return dos;\n}\n\n// Value type for put() value arguments. All value arguments for put() must be\n// cast to this type in order for va_arg() to pull the correct type from the\n// argument list.\ntypedef length_t val_t;\n\n// Write a set of header or trailer values to out, which is a file descriptor.\n// The values are specified by a series of arguments in pairs, where the first\n// argument in each pair is the number of bytes, and the second argument in\n// each pair is the unsigned integer value to write. The first argument in each\n// pair must be an int, and the second argument in each pair must be a val_t.\n// The arguments are terminated by a single zero (an int). If the number of\n// bytes is positive, then the value is written in little-endian order. If the\n// number of bytes is negative, then the value is written in big-endian order.\n// The total number of bytes written is returned. This makes the long and\n// tiresome zip format headers and trailers more readable, maintainable, and\n// verifiable.\nlocal unsigned put(int out, ...) {\n    // compute the total number of bytes\n    unsigned count = 0;\n    int n;\n    va_list ap;\n    va_start(ap, out);\n    while ((n = va_arg(ap, int)) != 0) {\n        va_arg(ap, val_t);\n        count += (unsigned)abs(n);\n    }\n    va_end(ap);\n\n    // allocate memory for the data\n    unsigned char *wrap = alloc(NULL, count);\n    unsigned char *next = wrap;\n\n    // write the requested data to wrap[]\n    va_start(ap, out);\n    while ((n = va_arg(ap, int)) != 0) {\n        val_t val = va_arg(ap, val_t);\n        if (n < 0) {            // big endian\n            n = -n << 3;\n            do {\n                n -= 8;\n                *next++ = (unsigned char)(val >> n);\n            } while (n);\n        }\n        else                    // little endian\n            do {\n                *next++ = (unsigned char)val;\n                val >>= 8;\n            } while (--n);\n    }\n    va_end(ap);\n\n    // write wrap[] to out and return the number of bytes written\n    writen(out, wrap, count);\n    FREE(wrap);\n    return count;\n}\n\n// Low 32-bits set to all ones.\n#define LOW32 0xffffffff\n\n// Write a gzip, zlib, or zip header using the information in the globals.\nlocal length_t put_header(void) {\n    length_t len;\n\n    if (g.form > 1) {               // zip\n        // write local header -- we don't know yet whether the lengths will fit\n        // in 32 bits or not, so we have to assume that they might not and put\n        // in a Zip64 extra field so that the data descriptor that appears\n        // after the compressed data is interpreted with 64-bit lengths\n        len = put(g.outd,\n            4, (val_t)0x04034b50,   // local header signature\n            2, (val_t)45,           // version needed to extract (4.5)\n            2, (val_t)8,            // flags: data descriptor follows data\n            2, (val_t)8,            // deflate\n            4, (val_t)time2dos(g.mtime),\n            4, (val_t)0,            // crc (not here)\n            4, (val_t)LOW32,        // compressed length (not here)\n            4, (val_t)LOW32,        // uncompressed length (not here)\n            2, (val_t)(strlen(g.name == NULL ? g.alias : g.name)),  // name len\n            2, (val_t)29,           // length of extra field (see below)\n            0);\n\n        // write file name (use g.alias for stdin)\n        len += writen(g.outd, g.name == NULL ? g.alias : g.name,\n                      strlen(g.name == NULL ? g.alias : g.name));\n\n        // write Zip64 and extended timestamp extra field blocks (29 bytes)\n        len += put(g.outd,\n            2, (val_t)0x0001,       // Zip64 extended information ID\n            2, (val_t)16,           // number of data bytes in this block\n            8, (val_t)0,            // uncompressed length (not here)\n            8, (val_t)0,            // compressed length (not here)\n            2, (val_t)0x5455,       // extended timestamp ID\n            2, (val_t)5,            // number of data bytes in this block\n            1, (val_t)1,            // flag presence of mod time\n            4, (val_t)g.mtime,      // mod time\n            0);\n    }\n    else if (g.form) {              // zlib\n        if (g.comment != NULL)\n            complain(\"can't store comment in zlib format -- ignoring\");\n        unsigned head;\n        head = (0x78 << 8) +        // deflate, 32K window\n               (g.level >= 9 ? 3 << 6 :\n                g.level == 1 ? 0 << 6:\n                g.level >= 6 || g.level == Z_DEFAULT_COMPRESSION ? 1 << 6 :\n                2 << 6);            // optional compression level clue\n        head += 31 - (head % 31);   // make it a multiple of 31\n        len = put(g.outd,\n            -2, (val_t)head,        // zlib format uses big-endian order\n            0);\n    }\n    else {                          // gzip\n        len = put(g.outd,\n            1, (val_t)31,\n            1, (val_t)139,\n            1, (val_t)8,            // deflate\n            1, (val_t)((g.name != NULL ? 8 : 0) +\n                       (g.comment != NULL ? 16 : 0)),\n            4, (val_t)g.mtime,\n            1, (val_t)(g.level >= 9 ? 2 : g.level == 1 ? 4 : 0),\n            1, (val_t)3,            // unix\n            0);\n        if (g.name != NULL)\n            len += writen(g.outd, g.name, strlen(g.name) + 1);\n        if (g.comment != NULL)\n            len += writen(g.outd, g.comment, strlen(g.comment) + 1);\n    }\n    return len;\n}\n\n// Write a gzip, zlib, or zip trailer.\nlocal void put_trailer(length_t ulen, length_t clen,\n                       unsigned long check, length_t head) {\n    if (g.form > 1) {               // zip\n        // write Zip64 data descriptor, as promised in the local header\n        length_t desc = put(g.outd,\n            4, (val_t)0x08074b50,\n            4, (val_t)check,\n            8, (val_t)clen,\n            8, (val_t)ulen,\n            0);\n\n        // zip64 is true if either the compressed or the uncompressed length\n        // does not fit in 32 bits, in which case there needs to be a Zip64\n        // extra block in the central directory entry\n        int zip64 = ulen >= LOW32 || clen >= LOW32;\n\n        // write central file header\n        length_t cent = put(g.outd,\n            4, (val_t)0x02014b50,   // central header signature\n            1, (val_t)45,           // made by 4.5 for Zip64 V1 end record\n            1, (val_t)255,          // ignore external attributes\n            2, (val_t)45,           // version needed to extract (4.5)\n            2, (val_t)8,            // data descriptor is present\n            2, (val_t)8,            // deflate\n            4, (val_t)time2dos(g.mtime),\n            4, (val_t)check,        // crc\n            4, (val_t)(zip64 ? LOW32 : clen),   // compressed length\n            4, (val_t)(zip64 ? LOW32 : ulen),   // uncompressed length\n            2, (val_t)(strlen(g.name == NULL ? g.alias : g.name)),  // name len\n            2, (val_t)(zip64 ? 29 : 9), // extra field size (see below)\n            2, (val_t)(g.comment == NULL ? 0 : strlen(g.comment)),  // comment\n            2, (val_t)0,            // disk number 0\n            2, (val_t)0,            // internal file attributes\n            4, (val_t)0,            // external file attributes (ignored)\n            4, (val_t)0,            // offset of local header\n            0);\n\n        // write file name (use g.alias for stdin)\n        cent += writen(g.outd, g.name == NULL ? g.alias : g.name,\n                       strlen(g.name == NULL ? g.alias : g.name));\n\n        // write Zip64 extra field block (20 bytes)\n        if (zip64)\n            cent += put(g.outd,\n                2, (val_t)0x0001,   // Zip64 extended information ID\n                2, (val_t)16,       // number of data bytes in this block\n                8, (val_t)ulen,     // uncompressed length\n                8, (val_t)clen,     // compressed length\n                0);\n\n        // write extended timestamp extra field block (9 bytes)\n        cent += put(g.outd,\n            2, (val_t)0x5455,       // extended timestamp signature\n            2, (val_t)5,            // number of data bytes in this block\n            1, (val_t)1,            // flag presence of mod time\n            4, (val_t)g.mtime,      // mod time\n            0);\n\n        // write comment, if requested\n        if (g.comment != NULL)\n            cent += writen(g.outd, g.comment, strlen(g.comment));\n\n        // here zip64 is true if the offset of the central directory does not\n        // fit in 32 bits, in which case insert the Zip64 end records to\n        // provide a 64-bit offset\n        zip64 = head + clen + desc >= LOW32;\n        if (zip64) {\n            // write Zip64 end of central directory record and locator\n            put(g.outd,\n                4, (val_t)0x06064b50,   // Zip64 end of central dir sig\n                8, (val_t)44,       // size of the remainder of this record\n                2, (val_t)45,       // version made by\n                2, (val_t)45,       // version needed to extract\n                4, (val_t)0,        // number of this disk\n                4, (val_t)0,        // disk with start of central directory\n                8, (val_t)1,        // number of entries on this disk\n                8, (val_t)1,        // total number of entries\n                8, (val_t)cent,     // size of central directory\n                8, (val_t)(head + clen + desc), // central dir offset\n                4, (val_t)0x07064b50,   // Zip64 end locator signature\n                4, (val_t)0,        // disk with Zip64 end of central dir\n                8, (val_t)(head + clen + desc + cent),  // location\n                4, (val_t)1,        // total number of disks\n                0);\n        }\n\n        // write end of central directory record\n        put(g.outd,\n            4, (val_t)0x06054b50,   // end of central directory signature\n            2, (val_t)0,            // number of this disk\n            2, (val_t)0,            // disk with start of central directory\n            2, (val_t)(zip64 ? 0xffff : 1), // entries on this disk\n            2, (val_t)(zip64 ? 0xffff : 1), // total number of entries\n            4, (val_t)(zip64 ? LOW32 : cent),   // size of central directory\n            4, (val_t)(zip64 ? LOW32 : head + clen + desc), // offset\n            2, (val_t)0,            // no zip file comment\n            0);\n    }\n    else if (g.form)                // zlib\n        put(g.outd,\n            -4, (val_t)check,       // zlib format uses big-endian order\n            0);\n    else                            // gzip\n        put(g.outd,\n            4, (val_t)check,\n            4, (val_t)ulen,\n            0);\n}\n\n// Compute an Adler-32, allowing a size_t length.\nlocal unsigned long adler32z(unsigned long adler,\n                           unsigned char const *buf, size_t len) {\n    while (len > UINT_MAX && buf != NULL) {\n        adler = adler32(adler, buf, UINT_MAX);\n        buf += UINT_MAX;\n        len -= UINT_MAX;\n    }\n    return adler32(adler, buf, (unsigned)len);\n}\n\n// Compute a CRC-32, allowing a size_t length.\nlocal unsigned long crc32z(unsigned long crc,\n                           unsigned char const *buf, size_t len) {\n    while (len > UINT_MAX && buf != NULL) {\n        crc = crc32(crc, buf, UINT_MAX);\n        buf += UINT_MAX;\n        len -= UINT_MAX;\n    }\n    return crc32(crc, buf, (unsigned)len);\n}\n\n// Compute check value depending on format.\n#define CHECK(a,b,c) (g.form == 1 ? adler32z(a,b,c) : crc32z(a,b,c))\n\n// Return the zlib version as an integer, where each component is interpreted\n// as a decimal number and converted to four hexadecimal digits. E.g.\n// '1.2.11.1' -> 0x12b1, or return -1 if the string is not a valid version.\nlocal long zlib_vernum(void) {\n    char const *ver = zlibVersion();\n    long num = 0;\n    int left = 4;\n    int comp = 0;\n    do {\n        if (*ver >= '0' && *ver <= '9')\n            comp = 10 * comp + *ver - '0';\n        else {\n            num = (num << 4) + (comp > 0xf ? 0xf : comp);\n            left--;\n            if (*ver != '.')\n                break;\n            comp = 0;\n        }\n        ver++;\n    } while (left);\n    return left < 3 ? num << (left << 2) : -1;\n}\n\n// -- check value combination routines for parallel calculation --\n\n#define COMB(a,b,c) (g.form == 1 ? adler32_comb(a,b,c) : crc32_comb(a,b,c))\n// Combine two crc-32's or two adler-32's (copied from zlib 1.2.3 so that pigz\n// can be compatible with older versions of zlib).\n\n// We copy the combination routines from zlib here, in order to avoid linkage\n// issues with the zlib 1.2.3 builds on Sun, Ubuntu, and others.\n\n// CRC-32 polynomial, reflected.\n#define POLY 0xedb88320\n\n// Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC\n// polynomial, reflected. For speed, this requires that a not be zero.\nlocal crc_t multmodp(crc_t a, crc_t b) {\n    crc_t m = (crc_t)1 << 31;\n    crc_t p = 0;\n    for (;;) {\n        if (a & m) {\n            p ^= b;\n            if ((a & (m - 1)) == 0)\n                break;\n        }\n        m >>= 1;\n        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n    }\n    return p;\n}\n\n// Table of x^2^n modulo p(x).\nlocal const crc_t x2n_table[] = {\n    0x40000000, 0x20000000, 0x08000000, 0x00800000, 0x00008000,\n    0xedb88320, 0xb1e6b092, 0xa06a2517, 0xed627dae, 0x88d14467,\n    0xd7bbfe6a, 0xec447f11, 0x8e7ea170, 0x6427800e, 0x4d47bae0,\n    0x09fe548f, 0x83852d0f, 0x30362f1a, 0x7b5a9cc3, 0x31fec169,\n    0x9fec022a, 0x6c8dedc4, 0x15d6874d, 0x5fde7a4e, 0xbad90e37,\n    0x2e4e5eef, 0x4eaba214, 0xa8a472c0, 0x429a969e, 0x148d302a,\n    0xc40ba6d0, 0xc4e22c3c};\n\n// Return x^(n*2^k) modulo p(x).\nlocal crc_t x2nmodp(size_t n, unsigned k) {\n    crc_t p = (crc_t)1 << 31;       // x^0 == 1\n    while (n) {\n        if (n & 1)\n            p = multmodp(x2n_table[k & 31], p);\n        n >>= 1;\n        k++;\n    }\n    return p;\n}\n\n// This uses the pre-computed g.shift value most of the time. Only the last\n// combination requires a new x2nmodp() calculation.\nlocal unsigned long crc32_comb(unsigned long crc1, unsigned long crc2,\n                               size_t len2) {\n    return multmodp(len2 == g.block ? g.shift : x2nmodp(len2, 3), crc1) ^ crc2;\n}\n\n#define BASE 65521U     // largest prime smaller than 65536\n#define LOW16 0xffff    // mask lower 16 bits\n\nlocal unsigned long adler32_comb(unsigned long adler1, unsigned long adler2,\n                                 size_t len2) {\n    unsigned long sum1;\n    unsigned long sum2;\n    unsigned rem;\n\n    // the derivation of this formula is left as an exercise for the reader\n    rem = (unsigned)(len2 % BASE);\n    sum1 = adler1 & LOW16;\n    sum2 = (rem * sum1) % BASE;\n    sum1 += (adler2 & LOW16) + BASE - 1;\n    sum2 += ((adler1 >> 16) & LOW16) + ((adler2 >> 16) & LOW16) + BASE - rem;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);\n    if (sum2 >= BASE) sum2 -= BASE;\n    return sum1 | (sum2 << 16);\n}\n\n#ifndef NOTHREAD\n// -- threaded portions of pigz --\n\n// -- pool of spaces for buffer management --\n\n// These routines manage a pool of spaces. Each pool specifies a fixed size\n// buffer to be contained in each space. Each space has a use count, which when\n// decremented to zero returns the space to the pool. If a space is requested\n// from the pool and the pool is empty, a space is immediately created unless a\n// specified limit on the number of spaces has been reached. Only if the limit\n// is reached will it wait for a space to be returned to the pool. Each space\n// knows what pool it belongs to, so that it can be returned.\n\n// A space (one buffer for each space).\nstruct space {\n    lock *use;              // use count -- return to pool when zero\n    unsigned char *buf;     // buffer of size size\n    size_t size;            // current size of this buffer\n    size_t len;             // for application usage (initially zero)\n    struct pool *pool;      // pool to return to\n    struct space *next;     // for pool linked list\n};\n\n// Pool of spaces (one pool for each type needed).\nstruct pool {\n    lock *have;             // unused spaces available, lock for list\n    struct space *head;     // linked list of available buffers\n    size_t size;            // size of new buffers in this pool\n    int limit;              // number of new spaces allowed, or -1\n    int made;               // number of buffers made\n};\n\n// Initialize a pool (pool structure itself provided, not allocated). The limit\n// is the maximum number of spaces in the pool, or -1 to indicate no limit,\n// i.e., to never wait for a buffer to return to the pool.\nlocal void new_pool(struct pool *pool, size_t size, int limit) {\n    pool->have = new_lock(0);\n    pool->head = NULL;\n    pool->size = size;\n    pool->limit = limit;\n    pool->made = 0;\n}\n\n// Get a space from a pool. The use count is initially set to one, so there is\n// no need to call use_space() for the first use.\nlocal struct space *get_space(struct pool *pool) {\n    struct space *space;\n\n    // if can't create any more, wait for a space to show up\n    possess(pool->have);\n    if (pool->limit == 0)\n        wait_for(pool->have, NOT_TO_BE, 0);\n\n    // if a space is available, pull it from the list and return it\n    if (pool->head != NULL) {\n        space = pool->head;\n        pool->head = space->next;\n        twist(pool->have, BY, -1);      // one less in pool\n        possess(space->use);\n        twist(space->use, TO, 1);       // initially one user\n        space->len = 0;\n        return space;\n    }\n\n    // nothing available, don't want to wait, make a new space\n    assert(pool->limit != 0);\n    if (pool->limit > 0)\n        pool->limit--;\n    pool->made++;\n    release(pool->have);\n    space = alloc(NULL, sizeof(struct space));\n    space->use = new_lock(1);           // initially one user\n    space->buf = alloc(NULL, pool->size);\n    space->size = pool->size;\n    space->len = 0;\n    space->pool = pool;                 // remember the pool this belongs to\n    return space;\n}\n\n// Increase the size of the buffer in space.\nlocal void grow_space(struct space *space) {\n    size_t more;\n\n    // compute next size up\n    more = grow(space->size);\n    if (more == space->size)\n        throw(ERANGE, \"overflow\");\n\n    // reallocate the buffer\n    space->buf = alloc(space->buf, more);\n    space->size = more;\n}\n\n// Increment the use count to require one more drop before returning this space\n// to the pool.\nlocal void use_space(struct space *space) {\n    long use;\n\n    possess(space->use);\n    use = peek_lock(space->use);\n    assert(use != 0);\n    twist(space->use, BY, +1);\n}\n\n// Drop a space, returning it to the pool if the use count is zero.\nlocal void drop_space(struct space *space) {\n    long use;\n    struct pool *pool;\n\n    if (space == NULL)\n        return;\n    possess(space->use);\n    use = peek_lock(space->use);\n    assert(use != 0);\n    twist(space->use, BY, -1);\n    if (use == 1) {\n        pool = space->pool;\n        possess(pool->have);\n        space->next = pool->head;\n        pool->head = space;\n        twist(pool->have, BY, +1);\n    }\n}\n\n// Free the memory and lock resources of a pool. Return number of spaces for\n// debugging and resource usage measurement.\nlocal int free_pool(struct pool *pool) {\n    int count;\n    struct space *space;\n\n    possess(pool->have);\n    count = 0;\n    while ((space = pool->head) != NULL) {\n        pool->head = space->next;\n        FREE(space->buf);\n        free_lock(space->use);\n        FREE(space);\n        count++;\n    }\n    assert(count == pool->made);\n    release(pool->have);\n    free_lock(pool->have);\n    return count;\n}\n\n// Input and output buffer pools.\nlocal struct pool in_pool;\nlocal struct pool out_pool;\nlocal struct pool dict_pool;\nlocal struct pool lens_pool;\n\n// -- parallel compression --\n\n// Compress or write job (passed from compress list to write list). If seq is\n// equal to -1, compress_thread is instructed to return; if more is false then\n// this is the last chunk, which after writing tells write_thread to return.\nstruct job {\n    long seq;                   // sequence number\n    int more;                   // true if this is not the last chunk\n    struct space *in;           // input data to compress\n    struct space *out;          // dictionary or resulting compressed data\n    struct space *lens;         // coded list of flush block lengths\n    unsigned long check;        // check value for input data\n    lock *calc;                 // released when check calculation complete\n    struct job *next;           // next job in the list (either list)\n};\n\n// List of compress jobs (with tail for appending to list).\nlocal lock *compress_have = NULL;   // number of compress jobs waiting\nlocal struct job *compress_head, **compress_tail;\n\n// List of write jobs.\nlocal lock *write_first;            // lowest sequence number in list\nlocal struct job *write_head;\n\n// Number of compression threads running.\nlocal int cthreads = 0;\n\n// Write thread if running.\nlocal thread *writeth = NULL;\n\n// Setup job lists (call from main thread).\nlocal void setup_jobs(void) {\n    // set up only if not already set up\n    if (compress_have != NULL)\n        return;\n\n    // allocate locks and initialize lists\n    compress_have = new_lock(0);\n    compress_head = NULL;\n    compress_tail = &compress_head;\n    write_first = new_lock(-1);\n    write_head = NULL;\n\n    // initialize buffer pools (initial size for out_pool not critical, since\n    // buffers will be grown in size if needed -- the initial size chosen to\n    // make this unlikely, the same for lens_pool)\n    new_pool(&in_pool, g.block, INBUFS(g.procs));\n    new_pool(&out_pool, OUTPOOL(g.block), -1);\n    new_pool(&dict_pool, DICT, -1);\n    new_pool(&lens_pool, g.block >> (RSYNCBITS - 1), -1);\n}\n\n// Command the compress threads to all return, then join them all (call from\n// main thread), free all the thread-related resources.\nlocal void finish_jobs(void) {\n    struct job job;\n    int caught;\n\n    // only do this once\n    if (compress_have == NULL)\n        return;\n\n    // command all of the extant compress threads to return\n    possess(compress_have);\n    job.seq = -1;\n    job.next = NULL;\n    compress_head = &job;\n    compress_tail = &(job.next);\n    twist(compress_have, BY, +1);       // will wake them all up\n\n    // join all of the compress threads, verify they all came back\n    caught = join_all();\n    Trace((\"-- joined %d compress threads\", caught));\n    assert(caught == cthreads);\n    cthreads = 0;\n\n    // free the resources\n    caught = free_pool(&lens_pool);\n    Trace((\"-- freed %d block lengths buffers\", caught));\n    caught = free_pool(&dict_pool);\n    Trace((\"-- freed %d dictionary buffers\", caught));\n    caught = free_pool(&out_pool);\n    Trace((\"-- freed %d output buffers\", caught));\n    caught = free_pool(&in_pool);\n    Trace((\"-- freed %d input buffers\", caught));\n    free_lock(write_first);\n    free_lock(compress_have);\n    compress_have = NULL;\n}\n\n// Compress all strm->avail_in bytes at strm->next_in to out->buf, updating\n// out->len, grow the size of the buffer (out->size) if necessary. Respect the\n// size limitations of the zlib stream data types (size_t may be larger than\n// unsigned).\nlocal void deflate_engine(z_stream *strm, struct space *out, int flush) {\n    size_t room;\n\n    do {\n        room = out->size - out->len;\n        if (room == 0) {\n            grow_space(out);\n            room = out->size - out->len;\n        }\n        strm->next_out = out->buf + out->len;\n        strm->avail_out = room < UINT_MAX ? (unsigned)room : UINT_MAX;\n        (void)deflate(strm, flush);\n        out->len = (size_t)(strm->next_out - out->buf);\n    } while (strm->avail_out == 0);\n    assert(strm->avail_in == 0);\n}\n\n// Get the next compression job from the head of the list, compress and compute\n// the check value on the input, and put a job in the write list with the\n// results. Keep looking for more jobs, returning when a job is found with a\n// sequence number of -1 (leave that job in the list for other incarnations to\n// find).\nlocal void compress_thread(void *dummy) {\n    struct job *job;                // job pulled and working on\n    struct job *here, **prior;      // pointers for inserting in write list\n    unsigned long check;            // check value of input\n    unsigned char *next;            // pointer for blocks, check value data\n    size_t left;                    // input left to process\n    size_t len;                     // remaining bytes to compress/check\n#if ZLIB_VERNUM >= 0x1260\n    int bits;                       // deflate pending bits\n#endif\n    int ret;                        // zlib return code\n    ball_t err;                     // error information from throw()\n\n    (void)dummy;\n\n    try {\n        z_stream strm;                  // deflate stream\n#ifndef NOZOPFLI\n        struct space *temp = NULL;\n        // get temporary space for zopfli input\n        if (g.level > 9)\n            temp = get_space(&out_pool);\n        else\n#endif\n        {\n            // initialize the deflate stream for this thread\n            strm.zfree = ZFREE;\n            strm.zalloc = ZALLOC;\n            strm.opaque = OPAQUE;\n            ret = deflateInit2(&strm, 6, Z_DEFLATED, -15, 8, g.strategy);\n            if (ret == Z_MEM_ERROR)\n                throw(ENOMEM, \"not enough memory\");\n            if (ret != Z_OK)\n                throw(EINVAL, \"internal error\");\n        }\n\n        // keep looking for work\n        for (;;) {\n            // get a job (like I tell my son)\n            possess(compress_have);\n            wait_for(compress_have, NOT_TO_BE, 0);\n            job = compress_head;\n            assert(job != NULL);\n            if (job->seq == -1)\n                break;\n            compress_head = job->next;\n            if (job->next == NULL)\n                compress_tail = &compress_head;\n            twist(compress_have, BY, -1);\n\n            // got a job -- initialize and set the compression level (note that\n            // if deflateParams() is called immediately after deflateReset(),\n            // there is no need to initialize input/output for the stream)\n            Trace((\"-- compressing #%ld\", job->seq));\n#ifndef NOZOPFLI\n            if (g.level <= 9) {\n#endif\n                (void)deflateReset(&strm);\n                (void)deflateParams(&strm, g.level, g.strategy);\n#ifndef NOZOPFLI\n            }\n            else\n                temp->len = 0;\n#endif\n\n            // set dictionary if provided, release that input or dictionary\n            // buffer (not NULL if g.setdict is true and if this is not the\n            // first work unit)\n            if (job->out != NULL) {\n                len = job->out->len;\n                left = len < DICT ? len : DICT;\n#ifndef NOZOPFLI\n                if (g.level <= 9)\n#endif\n                    deflateSetDictionary(&strm, job->out->buf + (len - left),\n                                         (unsigned)left);\n#ifndef NOZOPFLI\n                else {\n                    memcpy(temp->buf, job->out->buf + (len - left), left);\n                    temp->len = left;\n                }\n#endif\n                drop_space(job->out);\n            }\n\n            // set up input and output\n            job->out = get_space(&out_pool);\n#ifndef NOZOPFLI\n            if (g.level <= 9) {\n#endif\n                strm.next_in = job->in->buf;\n                strm.next_out = job->out->buf;\n#ifndef NOZOPFLI\n            }\n            else\n                memcpy(temp->buf + temp->len, job->in->buf, job->in->len);\n#endif\n\n            // compress each block, either flushing or finishing\n            next = job->lens == NULL ? NULL : job->lens->buf;\n            left = job->in->len;\n            job->out->len = 0;\n            do {\n                // decode next block length from blocks list\n                len = next == NULL ? 128 : *next++;\n                if (len < 128)                  // 64..32831\n                    len = (len << 8) + (*next++) + 64;\n                else if (len == 128)            // end of list\n                    len = left;\n                else if (len < 192)             // 1..63\n                    len &= 0x3f;\n                else if (len < 224){            // 32832..2129983\n                    len = ((len & 0x1f) << 16) + ((size_t)*next++ << 8);\n                    len += *next++ + 32832U;\n                }\n                else {                          // 2129984..539000895\n                    len = ((len & 0x1f) << 24) + ((size_t)*next++ << 16);\n                    len += (size_t)*next++ << 8;\n                    len += (size_t)*next++ + 2129984UL;\n                }\n                left -= len;\n\n#ifndef NOZOPFLI\n                if (g.level <= 9) {\n#endif\n                    // run MAXP2-sized amounts of input through deflate -- this\n                    // loop is needed for those cases where the unsigned type\n                    // is smaller than the size_t type, or when len is close to\n                    // the limit of the size_t type\n                    while (len > MAXP2) {\n                        strm.avail_in = MAXP2;\n                        deflate_engine(&strm, job->out, Z_NO_FLUSH);\n                        len -= MAXP2;\n                    }\n\n                    // run the last piece through deflate -- end on a byte\n                    // boundary, using a sync marker if necessary, or finish\n                    // the deflate stream if this is the last block\n                    strm.avail_in = (unsigned)len;\n                    if (left || job->more) {\n#if ZLIB_VERNUM >= 0x1260\n                        if (zlib_vernum() >= 0x1260) {\n                            deflate_engine(&strm, job->out, Z_BLOCK);\n\n                            // add enough empty blocks to get to a byte\n                            // boundary\n                            (void)deflatePending(&strm, Z_NULL, &bits);\n                            if ((bits & 1) || !g.setdict)\n                                deflate_engine(&strm, job->out, Z_SYNC_FLUSH);\n                            else if (bits & 7) {\n                                do {        // add static empty blocks\n                                    bits = deflatePrime(&strm, 10, 2);\n                                    assert(bits == Z_OK);\n                                    (void)deflatePending(&strm, Z_NULL, &bits);\n                                } while (bits & 7);\n                                deflate_engine(&strm, job->out, Z_BLOCK);\n                            }\n                        }\n                        else\n#endif\n                        {\n                            deflate_engine(&strm, job->out, Z_SYNC_FLUSH);\n                        }\n                        if (!g.setdict)     // two markers when independent\n                            deflate_engine(&strm, job->out, Z_FULL_FLUSH);\n                    }\n                    else\n                        deflate_engine(&strm, job->out, Z_FINISH);\n#ifndef NOZOPFLI\n                }\n                else {\n                    // compress len bytes using zopfli, end at byte boundary\n                    unsigned char bits, *out;\n                    size_t outsize;\n\n                    out = NULL;\n                    outsize = 0;\n                    bits = 0;\n                    ZopfliDeflatePart(&g.zopts, 2, !(left || job->more),\n                                      temp->buf, temp->len, temp->len + len,\n                                      &bits, &out, &outsize);\n                    assert(job->out->len + outsize + 5 <= job->out->size);\n                    memcpy(job->out->buf + job->out->len, out, outsize);\n                    free(out);\n                    job->out->len += outsize;\n                    if (left || job->more) {\n                        bits &= 7;\n                        if ((bits & 1) || !g.setdict) {\n                            if (bits == 0 || bits > 5)\n                                job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0xff;\n                            job->out->buf[job->out->len++] = 0xff;\n                        }\n                        else if (bits) {\n                            do {\n                                job->out->buf[job->out->len - 1] += 2 << bits;\n                                job->out->buf[job->out->len++] = 0;\n                                bits += 2;\n                            } while (bits < 8);\n                        }\n                        if (!g.setdict) {   // two markers when independent\n                            job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0;\n                            job->out->buf[job->out->len++] = 0xff;\n                            job->out->buf[job->out->len++] = 0xff;\n                        }\n                    }\n                    temp->len += len;\n                }\n#endif\n            } while (left);\n            drop_space(job->lens);\n            job->lens = NULL;\n            Trace((\"-- compressed #%ld%s\", job->seq,\n                   job->more ? \"\" : \" (last)\"));\n\n            // reserve input buffer until check value has been calculated\n            use_space(job->in);\n\n            // insert write job in list in sorted order, alert write thread\n            possess(write_first);\n            prior = &write_head;\n            while ((here = *prior) != NULL) {\n                if (here->seq > job->seq)\n                    break;\n                prior = &(here->next);\n            }\n            job->next = here;\n            *prior = job;\n            twist(write_first, TO, write_head->seq);\n\n            // calculate the check value in parallel with writing, alert the\n            // write thread that the calculation is complete, and drop this\n            // usage of the input buffer\n            len = job->in->len;\n            next = job->in->buf;\n            check = CHECK(0L, Z_NULL, 0);\n            while (len > MAXP2) {\n                check = CHECK(check, next, MAXP2);\n                len -= MAXP2;\n                next += MAXP2;\n            }\n            check = CHECK(check, next, (unsigned)len);\n            drop_space(job->in);\n            job->check = check;\n            Trace((\"-- checked #%ld%s\", job->seq, job->more ? \"\" : \" (last)\"));\n            possess(job->calc);\n            twist(job->calc, TO, 1);\n\n            // done with that one -- go find another job\n        }\n\n        // found job with seq == -1 -- return to join\n        release(compress_have);\n#ifndef NOZOPFLI\n        if (g.level > 9)\n            drop_space(temp);\n        else\n#endif\n        {\n            (void)deflateEnd(&strm);\n        }\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n}\n\n// Collect the write jobs off of the list in sequence order and write out the\n// compressed data until the last chunk is written. Also write the header and\n// trailer and combine the individual check values of the input buffers.\nlocal void write_thread(void *dummy) {\n    long seq;                       // next sequence number looking for\n    struct job *job;                // job pulled and working on\n    size_t len;                     // input length\n    int more;                       // true if more chunks to write\n    length_t head;                  // header length\n    length_t ulen;                  // total uncompressed size (overflow ok)\n    length_t clen;                  // total compressed size (overflow ok)\n    unsigned long check;            // check value of uncompressed data\n    ball_t err;                     // error information from throw()\n\n    (void)dummy;\n\n    try {\n        // build and write header\n        Trace((\"-- write thread running\"));\n        head = put_header();\n\n        // process output of compress threads until end of input\n        ulen = clen = 0;\n        check = CHECK(0L, Z_NULL, 0);\n        seq = 0;\n        do {\n            // get next write job in order\n            possess(write_first);\n            wait_for(write_first, TO_BE, seq);\n            job = write_head;\n            write_head = job->next;\n            twist(write_first, TO, write_head == NULL ? -1 : write_head->seq);\n\n            // update lengths, save uncompressed length for COMB\n            more = job->more;\n            len = job->in->len;\n            drop_space(job->in);\n            ulen += len;\n            clen += job->out->len;\n\n            // write the compressed data and drop the output buffer\n            Trace((\"-- writing #%ld\", seq));\n            writen(g.outd, job->out->buf, job->out->len);\n            drop_space(job->out);\n            Trace((\"-- wrote #%ld%s\", seq, more ? \"\" : \" (last)\"));\n\n            // wait for check calculation to complete, then combine, once the\n            // compress thread is done with the input, release it\n            possess(job->calc);\n            wait_for(job->calc, TO_BE, 1);\n            release(job->calc);\n            check = COMB(check, job->check, len);\n            Trace((\"-- combined #%ld%s\", seq, more ? \"\" : \" (last)\"));\n\n            // free the job\n            free_lock(job->calc);\n            FREE(job);\n\n            // get the next buffer in sequence\n            seq++;\n        } while (more);\n\n        // write trailer\n        put_trailer(ulen, clen, check, head);\n\n        // verify no more jobs, prepare for next use\n        possess(compress_have);\n        assert(compress_head == NULL && peek_lock(compress_have) == 0);\n        release(compress_have);\n        possess(write_first);\n        assert(write_head == NULL);\n        twist(write_first, TO, -1);\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n}\n\n// Encode a hash hit to the block lengths list. hit == 0 ends the list.\nlocal void append_len(struct job *job, size_t len) {\n    struct space *lens;\n\n    assert(len < 539000896UL);\n    if (job->lens == NULL)\n        job->lens = get_space(&lens_pool);\n    lens = job->lens;\n    if (lens->size < lens->len + 3)\n        grow_space(lens);\n    if (len < 64)\n        lens->buf[lens->len++] = (unsigned char)(len + 128);\n    else if (len < 32832U) {\n        len -= 64;\n        lens->buf[lens->len++] = (unsigned char)(len >> 8);\n        lens->buf[lens->len++] = (unsigned char)len;\n    }\n    else if (len < 2129984UL) {\n        len -= 32832U;\n        lens->buf[lens->len++] = (unsigned char)((len >> 16) + 192);\n        lens->buf[lens->len++] = (unsigned char)(len >> 8);\n        lens->buf[lens->len++] = (unsigned char)len;\n    }\n    else {\n        len -= 2129984UL;\n        lens->buf[lens->len++] = (unsigned char)((len >> 24) + 224);\n        lens->buf[lens->len++] = (unsigned char)(len >> 16);\n        lens->buf[lens->len++] = (unsigned char)(len >> 8);\n        lens->buf[lens->len++] = (unsigned char)len;\n    }\n}\n\n// Compress ind to outd, using multiple threads for the compression and check\n// value calculations and one other thread for writing the output. Compress\n// threads will be launched and left running (waiting actually) to support\n// subsequent calls of parallel_compress().\nlocal void parallel_compress(void) {\n    long seq;                       // sequence number\n    struct space *curr;             // input data to compress\n    struct space *next;             // input data that follows curr\n    struct space *hold;             // input data that follows next\n    struct space *dict;             // dictionary for next compression\n    struct job *job;                // job for compress, then write\n    int more;                       // true if more input to read\n    unsigned hash;                  // hash for rsyncable\n    unsigned char *scan;            // next byte to compute hash on\n    unsigned char *end;             // after end of data to compute hash on\n    unsigned char *last;            // position after last hit\n    size_t left;                    // last hit in curr to end of curr\n    size_t len;                     // for various length computations\n\n    // if first time or after an option change, setup the job lists\n    setup_jobs();\n\n    // start write thread\n    writeth = launch(write_thread, NULL);\n\n    // read from input and start compress threads (write thread will pick up\n    // the output of the compress threads)\n    seq = 0;\n    next = get_space(&in_pool);\n    next->len = readn(g.ind, next->buf, next->size);\n    hold = NULL;\n    dict = NULL;\n    scan = next->buf;\n    hash = RSYNCHIT;\n    left = 0;\n    do {\n        // create a new job\n        job = alloc(NULL, sizeof(struct job));\n        job->calc = new_lock(0);\n\n        // update input spaces\n        curr = next;\n        next = hold;\n        hold = NULL;\n\n        // get more input if we don't already have some\n        if (next == NULL) {\n            next = get_space(&in_pool);\n            next->len = readn(g.ind, next->buf, next->size);\n        }\n\n        // if rsyncable, generate block lengths and prepare curr for job to\n        // likely have less than size bytes (up to the last hash hit)\n        job->lens = NULL;\n        if (g.rsync && curr->len) {\n            // compute the hash function starting where we last left off to\n            // cover either size bytes or to EOF, whichever is less, through\n            // the data in curr (and in the next loop, through next) -- save\n            // the block lengths resulting from the hash hits in the job->lens\n            // list\n            if (left == 0) {\n                // scan is in curr\n                last = curr->buf;\n                end = curr->buf + curr->len;\n                while (scan < end) {\n                    hash = ((hash << 1) ^ *scan++) & RSYNCMASK;\n                    if (hash == RSYNCHIT) {\n                        len = (size_t)(scan - last);\n                        append_len(job, len);\n                        last = scan;\n                    }\n                }\n\n                // continue scan in next\n                left = (size_t)(scan - last);\n                scan = next->buf;\n            }\n\n            // scan in next for enough bytes to fill curr, or what is available\n            // in next, whichever is less (if next isn't full, then we're at\n            // the end of the file) -- the bytes in curr since the last hit,\n            // stored in left, counts towards the size of the first block\n            last = next->buf;\n            len = curr->size - curr->len;\n            if (len > next->len)\n                len = next->len;\n            end = next->buf + len;\n            while (scan < end) {\n                hash = ((hash << 1) ^ *scan++) & RSYNCMASK;\n                if (hash == RSYNCHIT) {\n                    len = (size_t)(scan - last) + left;\n                    left = 0;\n                    append_len(job, len);\n                    last = scan;\n                }\n            }\n            append_len(job, 0);\n\n            // create input in curr for job up to last hit or entire buffer if\n            // no hits at all -- save remainder in next and possibly hold\n            len = (size_t)((job->lens->len == 1 ? scan : last) - next->buf);\n            if (len) {\n                // got hits in next, or no hits in either -- copy to curr\n                memcpy(curr->buf + curr->len, next->buf, len);\n                curr->len += len;\n                memmove(next->buf, next->buf + len, next->len - len);\n                next->len -= len;\n                scan -= len;\n                left = 0;\n            }\n            else if (job->lens->len != 1 && left && next->len) {\n                // had hits in curr, but none in next, and last hit in curr\n                // wasn't right at the end, so we have input there to save --\n                // use curr up to the last hit, save the rest, moving next to\n                // hold\n                hold = next;\n                next = get_space(&in_pool);\n                memcpy(next->buf, curr->buf + (curr->len - left), left);\n                next->len = left;\n                curr->len -= left;\n            }\n            else {\n                // else, last match happened to be right at the end of curr, or\n                // we're at the end of the input compressing the rest\n                left = 0;\n            }\n        }\n\n        // compress curr->buf to curr->len -- compress thread will drop curr\n        job->in = curr;\n\n        // set job->more if there is more to compress after curr\n        more = next->len != 0;\n        job->more = more;\n\n        // provide dictionary for this job, prepare dictionary for next job\n        job->out = dict;\n        if (more && g.setdict) {\n            if (curr->len >= DICT || job->out == NULL) {\n                dict = curr;\n                use_space(dict);\n            }\n            else {\n                dict = get_space(&dict_pool);\n                len = DICT - curr->len;\n                memcpy(dict->buf, job->out->buf + (job->out->len - len), len);\n                memcpy(dict->buf + len, curr->buf, curr->len);\n                dict->len = DICT;\n            }\n        }\n\n        // preparation of job is complete\n        job->seq = seq;\n        Trace((\"-- read #%ld%s\", seq, more ? \"\" : \" (last)\"));\n        if (++seq < 1)\n            throw(ERANGE, \"overflow\");\n\n        // start another compress thread if needed\n        if (cthreads < seq && cthreads < g.procs) {\n            (void)launch(compress_thread, NULL);\n            cthreads++;\n        }\n\n        // put job at end of compress list, let all the compressors know\n        possess(compress_have);\n        job->next = NULL;\n        *compress_tail = job;\n        compress_tail = &(job->next);\n        twist(compress_have, BY, +1);\n    } while (more);\n    drop_space(next);\n\n    // wait for the write thread to complete (we leave the compress threads out\n    // there and waiting in case there is another stream to compress)\n    join(writeth);\n    writeth = NULL;\n    Trace((\"-- write thread joined\"));\n}\n\n#endif\n\n// Repeated code in single_compress to compress available input and write it.\n#define DEFLATE_WRITE(flush) \\\n    do { \\\n        do { \\\n            strm->avail_out = out_size; \\\n            strm->next_out = out; \\\n            (void)deflate(strm, flush); \\\n            clen += writen(g.outd, out, out_size - strm->avail_out); \\\n        } while (strm->avail_out == 0); \\\n        assert(strm->avail_in == 0); \\\n    } while (0)\n\n// Do a simple compression in a single thread from ind to outd. If reset is\n// true, instead free the memory that was allocated and retained for input,\n// output, and deflate.\nlocal void single_compress(int reset) {\n    size_t got;                     // amount of data in in[]\n    size_t more;                    // amount of data in next[] (0 if eof)\n    size_t start;                   // start of data in next[]\n    size_t have;                    // bytes in current block for -i\n    size_t hist;                    // offset of permitted history\n    int fresh;                      // if true, reset compression history\n    unsigned hash;                  // hash for rsyncable\n    unsigned char *scan;            // pointer for hash computation\n    size_t left;                    // bytes left to compress after hash hit\n    unsigned long head;             // header length\n    length_t ulen;                  // total uncompressed size\n    length_t clen;                  // total compressed size\n    unsigned long check;            // check value of uncompressed data\n    static unsigned out_size;       // size of output buffer\n    static unsigned char *in, *next, *out;  // reused i/o buffers\n    static z_stream *strm = NULL;   // reused deflate structure\n\n    // if requested, just release the allocations and return\n    if (reset) {\n        if (strm != NULL) {\n            (void)deflateEnd(strm);\n            FREE(strm);\n            FREE(out);\n            FREE(next);\n            FREE(in);\n            strm = NULL;\n        }\n        return;\n    }\n\n    // initialize the deflate structure if this is the first time\n    if (strm == NULL) {\n        int ret;                    // zlib return code\n\n        out_size = g.block > MAXP2 ? MAXP2 : (unsigned)g.block;\n        in = alloc(NULL, g.block + DICT);\n        next = alloc(NULL, g.block + DICT);\n        out = alloc(NULL, out_size);\n        strm = alloc(NULL, sizeof(z_stream));\n        strm->zfree = ZFREE;\n        strm->zalloc = ZALLOC;\n        strm->opaque = OPAQUE;\n        ret = deflateInit2(strm, 6, Z_DEFLATED, -15, 8, g.strategy);\n        if (ret == Z_MEM_ERROR)\n            throw(ENOMEM, \"not enough memory\");\n        if (ret != Z_OK)\n            throw(EINVAL, \"internal error\");\n    }\n\n    // write header\n    head = put_header();\n\n    // set compression level in case it changed\n#ifndef NOZOPFLI\n    if (g.level <= 9) {\n#endif\n        (void)deflateReset(strm);\n        (void)deflateParams(strm, g.level, g.strategy);\n#ifndef NOZOPFLI\n    }\n#endif\n\n    // do raw deflate and calculate check value\n    got = 0;\n    more = readn(g.ind, next, g.block);\n    ulen = more;\n    start = 0;\n    hist = 0;\n    clen = 0;\n    have = 0;\n    check = CHECK(0L, Z_NULL, 0);\n    hash = RSYNCHIT;\n    do {\n        // get data to compress, see if there is any more input\n        if (got == 0) {\n            scan = in;  in = next;  next = scan;\n            strm->next_in = in + start;\n            got = more;\n            if (g.level > 9) {\n                left = start + more - hist;\n                if (left > DICT)\n                    left = DICT;\n                memcpy(next, in + ((start + more) - left), left);\n                start = left;\n                hist = 0;\n            }\n            else\n                start = 0;\n            more = readn(g.ind, next + start, g.block);\n            ulen += more;\n        }\n\n        // if rsyncable, compute hash until a hit or the end of the block\n        left = 0;\n        if (g.rsync && got) {\n            scan = strm->next_in;\n            left = got;\n            do {\n                if (left == 0) {\n                    // went to the end -- if no more or no hit in size bytes,\n                    // then proceed to do a flush or finish with got bytes\n                    if (more == 0 || got == g.block)\n                        break;\n\n                    // fill in[] with what's left there and as much as possible\n                    // from next[] -- set up to continue hash hit search\n                    if (g.level > 9) {\n                        left = (size_t)(strm->next_in - in) - hist;\n                        if (left > DICT)\n                            left = DICT;\n                    }\n                    memmove(in, strm->next_in - left, left + got);\n                    hist = 0;\n                    strm->next_in = in + left;\n                    scan = in + left + got;\n                    left = more > g.block - got ? g.block - got : more;\n                    memcpy(scan, next + start, left);\n                    got += left;\n                    more -= left;\n                    start += left;\n\n                    // if that emptied the next buffer, try to refill it\n                    if (more == 0) {\n                        more = readn(g.ind, next, g.block);\n                        ulen += more;\n                        start = 0;\n                    }\n                }\n                left--;\n                hash = ((hash << 1) ^ *scan++) & RSYNCMASK;\n            } while (hash != RSYNCHIT);\n            got -= left;\n        }\n\n        // clear history for --independent option\n        fresh = 0;\n        if (!g.setdict) {\n            have += got;\n            if (have > g.block) {\n                fresh = 1;\n                have = got;\n            }\n        }\n\n#ifndef NOZOPFLI\n        if (g.level <= 9) {\n#endif\n            // clear history if requested\n            if (fresh)\n                (void)deflateReset(strm);\n\n            // compress MAXP2-size chunks in case unsigned type is small\n            while (got > MAXP2) {\n                strm->avail_in = MAXP2;\n                check = CHECK(check, strm->next_in, strm->avail_in);\n                DEFLATE_WRITE(Z_NO_FLUSH);\n                got -= MAXP2;\n            }\n\n            // compress the remainder, emit a block, finish if end of input\n            strm->avail_in = (unsigned)got;\n            got = left;\n            check = CHECK(check, strm->next_in, strm->avail_in);\n            if (more || got) {\n#if ZLIB_VERNUM >= 0x1260\n                if (zlib_vernum() >= 0x1260) {\n                    int bits;\n\n                    DEFLATE_WRITE(Z_BLOCK);\n                    (void)deflatePending(strm, Z_NULL, &bits);\n                    if ((bits & 1) || !g.setdict)\n                        DEFLATE_WRITE(Z_SYNC_FLUSH);\n                    else if (bits & 7) {\n                        do {\n                            bits = deflatePrime(strm, 10, 2);\n                            assert(bits == Z_OK);\n                            (void)deflatePending(strm, Z_NULL, &bits);\n                        } while (bits & 7);\n                        DEFLATE_WRITE(Z_NO_FLUSH);\n                    }\n                }\n                else\n                    DEFLATE_WRITE(Z_SYNC_FLUSH);\n#else\n                DEFLATE_WRITE(Z_SYNC_FLUSH);\n#endif\n                if (!g.setdict)             // two markers when independent\n                    DEFLATE_WRITE(Z_FULL_FLUSH);\n            }\n            else\n                DEFLATE_WRITE(Z_FINISH);\n#ifndef NOZOPFLI\n        }\n        else {\n            // compress got bytes using zopfli, bring to byte boundary\n            unsigned char bits, *def;\n            size_t size, off;\n\n            // discard history if requested\n            off = (size_t)(strm->next_in - in);\n            if (fresh)\n                hist = off;\n\n            def = NULL;\n            size = 0;\n            bits = 0;\n            ZopfliDeflatePart(&g.zopts, 2, !(more || left),\n                              in + hist, off - hist, (off - hist) + got,\n                              &bits, &def, &size);\n            bits &= 7;\n            if (more || left) {\n                if ((bits & 1) || !g.setdict) {\n                    writen(g.outd, def, size);\n                    if (bits == 0 || bits > 5)\n                        writen(g.outd, (unsigned char *)\"\\0\", 1);\n                    writen(g.outd, (unsigned char *)\"\\0\\0\\xff\\xff\", 4);\n                }\n                else {\n                    assert(size > 0);\n                    writen(g.outd, def, size - 1);\n                    if (bits)\n                        do {\n                            def[size - 1] += 2 << bits;\n                            writen(g.outd, def + size - 1, 1);\n                            def[size - 1] = 0;\n                            bits += 2;\n                        } while (bits < 8);\n                    writen(g.outd, def + size - 1, 1);\n                }\n                if (!g.setdict)             // two markers when independent\n                    writen(g.outd, (unsigned char *)\"\\0\\0\\0\\xff\\xff\", 5);\n            }\n            else\n                writen(g.outd, def, size);\n            free(def);\n            while (got > MAXP2) {\n                check = CHECK(check, strm->next_in, MAXP2);\n                strm->next_in += MAXP2;\n                got -= MAXP2;\n            }\n            check = CHECK(check, strm->next_in, (unsigned)got);\n            strm->next_in += got;\n            got = left;\n        }\n#endif\n\n        // do until no more input\n    } while (more || got);\n\n    // write trailer\n    put_trailer(ulen, clen, check, head);\n}\n\n// --- decompression ---\n\n#ifndef NOTHREAD\n// Parallel read thread. If the state is 1, then read a buffer and set the\n// state to 0 when done, if the state is > 1, then end this thread.\nlocal void load_read(void *dummy) {\n    size_t len;\n    ball_t err;                     // error information from throw()\n\n    (void)dummy;\n\n    Trace((\"-- launched decompress read thread\"));\n    try {\n        do {\n            possess(g.load_state);\n            wait_for(g.load_state, NOT_TO_BE, 0);\n            if (peek_lock(g.load_state) > 1) {\n                release(g.load_state);\n                break;\n            }\n            g.in_len = len = readn(g.ind, g.in_which ? g.in_buf : g.in_buf2,\n                                   BUF);\n            Trace((\"-- decompress read thread read %lu bytes\", len));\n            twist(g.load_state, TO, 0);\n        } while (len == BUF);\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n    Trace((\"-- exited decompress read thread\"));\n}\n\n// Wait for load_read() to complete the current read operation. If the\n// load_read() thread is not active, then return immediately.\nlocal void load_wait(void) {\n    if (g.in_which == -1)\n        return;\n    possess(g.load_state);\n    wait_for(g.load_state, TO_BE, 0);\n    release(g.load_state);\n}\n#endif\n\n// load() is called when the input has been consumed in order to provide more\n// input data: load the input buffer with BUF or fewer bytes (fewer if at end\n// of file) from the file g.ind, set g.in_next to point to the g.in_left bytes\n// read, update g.in_tot, and return g.in_left. g.in_eof is set to true when\n// g.in_left has gone to zero and there is no more data left to read.\nlocal size_t load(void) {\n    // if already detected end of file, do nothing\n    if (g.in_short) {\n        g.in_eof = 1;\n        g.in_left = 0;\n        return 0;\n    }\n\n#ifndef NOTHREAD\n    // if first time in or procs == 1, read a buffer to have something to\n    // return, otherwise wait for the previous read job to complete\n    if (g.procs > 1) {\n        // if first time, fire up the read thread, ask for a read\n        if (g.in_which == -1) {\n            g.in_which = 1;\n            g.load_state = new_lock(1);\n            g.load_thread = launch(load_read, NULL);\n        }\n\n        // wait for the previously requested read to complete\n        load_wait();\n\n        // set up input buffer with the data just read\n        g.in_next = g.in_which ? g.in_buf : g.in_buf2;\n        g.in_left = g.in_len;\n\n        // if not at end of file, alert read thread to load next buffer,\n        // alternate between g.in_buf and g.in_buf2\n        if (g.in_len == BUF) {\n            g.in_which = 1 - g.in_which;\n            possess(g.load_state);\n            twist(g.load_state, TO, 1);\n        }\n\n        // at end of file -- join read thread (already exited), clean up\n        else {\n            join(g.load_thread);\n            free_lock(g.load_state);\n            g.in_which = -1;\n        }\n    }\n    else\n#endif\n    {\n        // don't use threads -- simply read a buffer into g.in_buf\n        g.in_left = readn(g.ind, g.in_next = g.in_buf, BUF);\n    }\n\n    // note end of file\n    if (g.in_left < BUF) {\n        g.in_short = 1;\n\n        // if we got bupkis, now is the time to mark eof\n        if (g.in_left == 0)\n            g.in_eof = 1;\n    }\n\n    // update the total and return the available bytes\n    g.in_tot += g.in_left;\n    return g.in_left;\n}\n\n// Terminate the load() operation. Empty buffer, mark end, close file (if not\n// stdin), and free the name and comment obtained from the header, if present.\nlocal void load_end(void) {\n#ifndef NOTHREAD\n    // if the read thread is running, then end it\n    if (g.in_which != -1) {\n        // wait for the previously requested read to complete and send the\n        // thread a message to exit\n        possess(g.load_state);\n        wait_for(g.load_state, TO_BE, 0);\n        twist(g.load_state, TO, 2);\n\n        // join the thread (which has exited or will very shortly) and clean up\n        join(g.load_thread);\n        free_lock(g.load_state);\n        g.in_which = -1;\n    }\n#endif\n    g.in_left = 0;\n    g.in_short = 1;\n    g.in_eof = 1;\n    if (g.ind != 0)\n        close(g.ind);\n    RELEASE(g.hname);\n    RELEASE(g.hcomm);\n}\n\n// Initialize for reading new input.\nlocal void in_init(void) {\n    g.in_left = 0;\n    g.in_eof = 0;\n    g.in_short = 0;\n    g.in_tot = 0;\n#ifndef NOTHREAD\n    g.in_which = -1;\n#endif\n}\n\n// Buffered reading macros for decompression and listing.\n#define GET() (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : \\\n               (g.in_left--, *g.in_next++))\n#define GET2() (tmp2 = GET(), tmp2 + ((unsigned)(GET()) << 8))\n#define GET4() (tmp4 = GET2(), tmp4 + ((unsigned long)(GET2()) << 16))\n#define SKIP(dist) \\\n    do { \\\n        size_t togo = (dist); \\\n        while (togo > g.in_left) { \\\n            togo -= g.in_left; \\\n            if (load() == 0) \\\n                return -3; \\\n        } \\\n        g.in_left -= togo; \\\n        g.in_next += togo; \\\n    } while (0)\n\n// GET(), GET2(), GET4() and SKIP() equivalents, with crc update.\n#define GETC() (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : \\\n                (g.in_left--, crc = crc32z(crc, g.in_next, 1), *g.in_next++))\n#define GET2C() (tmp2 = GETC(), tmp2 + ((unsigned)(GETC()) << 8))\n#define GET4C() (tmp4 = GET2C(), tmp4 + ((unsigned long)(GET2C()) << 16))\n#define SKIPC(dist) \\\n    do { \\\n        size_t togo = (dist); \\\n        while (togo > g.in_left) { \\\n            crc = crc32z(crc, g.in_next, g.in_left); \\\n            togo -= g.in_left; \\\n            if (load() == 0) \\\n                return -3; \\\n        } \\\n        crc = crc32z(crc, g.in_next, togo); \\\n        g.in_left -= togo; \\\n        g.in_next += togo; \\\n    } while (0)\n\n// Get a zero-terminated string into allocated memory, with crc update.\n#define GETZC(str) \\\n    do { \\\n        unsigned char *end; \\\n        size_t copy, have, size = 0; \\\n        have = 0; \\\n        do { \\\n            if (g.in_left == 0 && load() == 0) \\\n                return -3; \\\n            end = memchr(g.in_next, 0, g.in_left); \\\n            copy = end == NULL ? g.in_left : (size_t)(end - g.in_next) + 1; \\\n            have = vmemcpy(&str, &size, have, g.in_next, copy); \\\n            g.in_left -= copy; \\\n            g.in_next += copy; \\\n        } while (end == NULL); \\\n        crc = crc32z(crc, (unsigned char *)str, have); \\\n    } while (0)\n\n// Pull LSB order or MSB order integers from an unsigned char buffer.\n#define PULL2L(p) ((p)[0] + ((unsigned)((p)[1]) << 8))\n#define PULL4L(p) (PULL2L(p) + ((unsigned long)(PULL2L((p) + 2)) << 16))\n#define PULL2M(p) (((unsigned)((p)[0]) << 8) + (p)[1])\n#define PULL4M(p) (((unsigned long)(PULL2M(p)) << 16) + PULL2M((p) + 2))\n\n// Convert MS-DOS date and time to a Unix time, assuming current timezone.\n// (You got a better idea?)\nlocal time_t dos2time(unsigned long dos) {\n    struct tm tm;\n\n    if (dos == 0)\n        return time(NULL);\n    tm.tm_year = ((int)(dos >> 25) & 0x7f) + 80;\n    tm.tm_mon  = ((int)(dos >> 21) & 0xf) - 1;\n    tm.tm_mday = (int)(dos >> 16) & 0x1f;\n    tm.tm_hour = (int)(dos >> 11) & 0x1f;\n    tm.tm_min  = (int)(dos >> 5) & 0x3f;\n    tm.tm_sec  = (int)(dos << 1) & 0x3e;\n    tm.tm_isdst = -1;           // figure out if DST or not\n    return mktime(&tm);\n}\n\n// Convert an unsigned 32-bit integer to signed, even if long > 32 bits.\nlocal long tolong(unsigned long val) {\n    return (long)(val & 0x7fffffffUL) - (long)(val & 0x80000000UL);\n}\n\n// Process zip extra field to extract zip64 lengths and Unix mod time.\nlocal int read_extra(unsigned len, int save) {\n    unsigned id, size, tmp2;\n    unsigned long tmp4;\n\n    // process extra blocks\n    while (len >= 4) {\n        id = GET2();\n        size = GET2();\n        if (g.in_eof)\n            return -1;\n        len -= 4;\n        if (size > len)\n            break;\n        len -= size;\n        if (id == 0x0001) {\n            // Zip64 Extended Information Extra Field\n            g.zip64 = 1;\n            if (g.zip_ulen == LOW32 && size >= 8) {\n                g.zip_ulen = GET4();\n                SKIP(4);\n                size -= 8;\n            }\n            if (g.zip_clen == LOW32 && size >= 8) {\n                g.zip_clen = GET4();\n                SKIP(4);\n                size -= 8;\n            }\n        }\n        if (save) {\n            if ((id == 0x000d || id == 0x5855) && size >= 8) {\n                // PKWare Unix or Info-ZIP Type 1 Unix block\n                SKIP(4);\n                g.stamp = tolong(GET4());\n                size -= 8;\n            }\n            if (id == 0x5455 && size >= 5) {\n                // Extended Timestamp block\n                size--;\n                if (GET() & 1) {\n                    g.stamp = tolong(GET4());\n                    size -= 4;\n                }\n            }\n        }\n        SKIP(size);\n    }\n    SKIP(len);\n    return 0;\n}\n\n// Read a gzip, zip, zlib, or Unix compress header from ind and return the\n// compression method in the range 0..257. 8 is deflate, 256 is a zip method\n// greater than 255, and 257 is LZW (compress). The only methods decompressed\n// by pigz are 8 and 257. On error, return negative: -1 is immediate EOF, -2 is\n// not a recognized compressed format (considering only the first two bytes of\n// input), -3 is premature EOF within the header, -4 is unexpected header flag\n// values, -5 is the zip central directory, and -6 is a failed gzip header crc\n// check. If -2 is returned, the input pointer has been reset to the beginning.\n// If the return value is not negative, then get_header() sets g.form to\n// indicate gzip (0), zlib (1), or zip (2, or 3 if the entry is followed by a\n// data descriptor), and the input points to the first byte of compressed data.\nlocal int get_header(int save) {\n    unsigned magic;             // magic header\n    unsigned method;            // compression method\n    unsigned flags;             // header flags\n    unsigned fname, extra;      // name and extra field lengths\n    unsigned tmp2;              // for macro\n    unsigned long tmp4;         // for macro\n    unsigned long crc;          // gzip header crc\n\n    // clear return information\n    if (save) {\n        g.stamp = 0;\n        RELEASE(g.hname);\n        RELEASE(g.hcomm);\n    }\n\n    // see if it's a gzip, zlib, or lzw file\n    g.magic1 = GET();\n    if (g.in_eof) {\n        g.magic1 = -1;\n        return -1;\n    }\n    magic = (unsigned)g.magic1 << 8;\n    magic += GET();\n    if (g.in_eof)\n        return -2;\n    if (magic % 31 == 0 && (magic & 0x8f20) == 0x0800) {\n        // it's zlib\n        g.form = 1;\n        return 8;\n    }\n    if (magic == 0x1f9d) {          // it's lzw\n        g.form = -1;\n        return 257;\n    }\n    if (magic == 0x504b) {          // it's zip\n        magic = GET2();             // the rest of the signature\n        if (g.in_eof)\n            return -3;\n        if (magic == 0x0201 || magic == 0x0806)\n            return -5;              // central header or archive extra\n        if (magic != 0x0403)\n            return -4;              // not a local header\n        g.zip64 = 0;\n        SKIP(2);\n        flags = GET2();\n        if (flags & 0xf7f0)\n            return -4;\n        method = GET();             // return low byte of method or 256\n        if (GET() != 0 || flags & 1)\n            method = 256;           // unknown or encrypted\n        if (save)\n            g.stamp = dos2time(GET4());\n        else\n            SKIP(4);\n        g.zip_crc = GET4();\n        g.zip_clen = GET4();\n        g.zip_ulen = GET4();\n        fname = GET2();\n        extra = GET2();\n        if (save) {\n            char *next;\n\n            if (g.in_eof)\n                return -3;\n            next = g.hname = alloc(NULL, fname + 1);\n            while (fname > g.in_left) {\n                memcpy(next, g.in_next, g.in_left);\n                fname -= g.in_left;\n                next += g.in_left;\n                if (load() == 0)\n                    return -3;\n            }\n            memcpy(next, g.in_next, fname);\n            g.in_left -= fname;\n            g.in_next += fname;\n            next += fname;\n            *next = 0;\n        }\n        else\n            SKIP(fname);\n        read_extra(extra, save);\n        g.form = 2 + ((flags & 8) >> 3);\n        return g.in_eof ? -3 : (int)method;\n    }\n    if (magic != 0x1f8b) {          // not gzip\n        g.in_left++;                // return the second byte\n        g.in_next--;\n        return -2;\n    }\n\n    // it's gzip -- get method and flags\n    crc = 0xf6e946c9;       // crc of 0x1f 0x8b\n    method = GETC();\n    flags = GETC();\n    if (flags & 0xe0)\n        return -4;\n\n    // get time stamp\n    if (save)\n        g.stamp = tolong(GET4C());\n    else\n        SKIPC(4);\n\n    // skip extra field and OS\n    SKIPC(2);\n\n    // skip extra field, if present\n    if (flags & 4)\n        SKIPC(GET2C());\n\n    // read file name, if present, into allocated memory\n    if (flags & 8) {\n        if (save)\n            GETZC(g.hname);\n        else\n            while (GETC() != 0)\n                ;\n    }\n\n    // read comment, if present, into allocated memory\n    if (flags & 16) {\n        if (save)\n            GETZC(g.hcomm);\n        else\n            while (GETC() != 0)\n                ;\n    }\n\n    // check header crc\n    if ((flags & 2) && GET2() != (crc & 0xffff))\n        return -6;\n\n    // return gzip compression method\n    g.form = 0;\n    return g.in_eof ? -3 : (int)method;\n}\n\n// Process the remainder of a zip file after the first entry. Return true if\n// the next signature is another local file header. If listing verbosely, then\n// search the remainder of the zip file for the central file header\n// corresponding to the first zip entry, and save the file comment, if any.\nlocal int more_zip_entries(void) {\n    unsigned long sig;\n    int ret, n;\n    unsigned char *first;\n    unsigned tmp2;              // for macro\n    unsigned long tmp4;         // for macro\n    unsigned char const central[] = {0x50, 0x4b, 1, 2};\n\n    sig = GET4();\n    ret = !g.in_eof && sig == 0x04034b50;   // true if another entry follows\n    if (!g.list || g.verbosity < 2)\n        return ret;\n\n    // if it was a central file header signature, then already four bytes\n    // into a central directory header -- otherwise search for the next one\n    n = sig == 0x02014b50 ? 4 : 0;  // number of bytes into central header\n    for (;;) {\n        // assure that more input is available\n        if (g.in_left == 0 && load() == 0)      // never found it!\n            return ret;\n        if (n == 0) {\n            // look for first byte in central signature\n            first = memchr(g.in_next, central[0], g.in_left);\n            if (first == NULL) {\n                // not found -- go get the next buffer and keep looking\n                g.in_left = 0;\n            }\n            else {\n                // found -- continue search at next byte\n                n++;\n                g.in_left -= first - g.in_next + 1;\n                g.in_next = first + 1;\n            }\n        }\n        else if (n < 4) {\n            // look for the remaining bytes in the central signature\n            if (g.in_next[0] == central[n]) {\n                n++;\n                g.in_next++;\n                g.in_left--;\n            }\n            else\n                n = 0;      // mismatch -- restart search with this byte\n        }\n        else {\n            // Now in a suspected central file header, just past the signature.\n            // Read the rest of the fixed-length portion of the header.\n            unsigned char head[CEN];\n            size_t need = CEN, part = 0, len, i;\n\n            if (need > g.in_left) {     // will only need to do this once\n                part = g.in_left;\n                memcpy(head + CEN - need, g.in_next, part);\n                need -= part;\n                g.in_left = 0;\n                if (load() == 0)                // never found it!\n                    return ret;\n            }\n            memcpy(head + CEN - need, g.in_next, need);\n\n            // Determine to sufficient probability that this is the droid we're\n            // looking for, by checking the CRC and the local header offset.\n            if (PULL4L(head + 12) == g.out_check && PULL4L(head + 38) == 0) {\n                // Update the number of bytes consumed from the current buffer.\n                g.in_next += need;\n                g.in_left -= need;\n\n                // Get the comment length.\n                len = PULL2L(head + 28);\n                if (len == 0)                   // no comment\n                    return ret;\n\n                // Skip the file name and extra field.\n                SKIP(PULL2L(head + 24) + (unsigned long)PULL2L(head + 26));\n\n                // Save the comment field.\n                need = len;\n                g.hcomm = alloc(NULL, len + 1);\n                while (need > g.in_left) {\n                    memcpy(g.hcomm + len - need, g.in_next, g.in_left);\n                    need -= g.in_left;\n                    g.in_left = 0;\n                    if (load() == 0) {          // premature EOF\n                        RELEASE(g.hcomm);\n                        return ret;\n                    }\n                }\n                memcpy(g.hcomm + len - need, g.in_next, need);\n                g.in_next += need;\n                g.in_left -= need;\n                for (i = 0; i < len; i++)\n                    if (g.hcomm[i] == 0)\n                        g.hcomm[i] = ' ';\n                g.hcomm[len] = 0;\n                return ret;\n            }\n            else {\n                // Nope, false alarm. Restart the search at the first byte\n                // after what we thought was the central file header signature.\n                if (part) {\n                    // Move buffer data up and insert the part of the header\n                    // data read from the previous buffer.\n                    memmove(g.in_next + part, g.in_next, g.in_left);\n                    memcpy(g.in_next, head, part);\n                    g.in_left += part;\n                }\n                n = 0;\n            }\n        }\n    }\n}\n\n// --- list contents of compressed input (gzip, zlib, or lzw) ---\n\n// Find standard compressed file suffix, return length of suffix.\nlocal size_t compressed_suffix(char *nm) {\n    size_t len;\n\n    len = strlen(nm);\n    if (len > 4) {\n        nm += len - 4;\n        len = 4;\n        if (strcmp(nm, \".zip\") == 0 || strcmp(nm, \".ZIP\") == 0 ||\n            strcmp(nm, \".tgz\") == 0)\n            return 4;\n    }\n    if (len > 3) {\n        nm += len - 3;\n        len = 3;\n        if (strcmp(nm, \".gz\") == 0 || strcmp(nm, \"-gz\") == 0 ||\n            strcmp(nm, \".zz\") == 0 || strcmp(nm, \"-zz\") == 0)\n            return 3;\n    }\n    if (len > 2) {\n        nm += len - 2;\n        if (strcmp(nm, \".z\") == 0 || strcmp(nm, \"-z\") == 0 ||\n            strcmp(nm, \"_z\") == 0 || strcmp(nm, \".Z\") == 0)\n            return 2;\n    }\n    return 0;\n}\n\n// Listing file name lengths for -l and -lv.\n#define NAMEMAX1 48     // name display limit at verbosity 1\n#define NAMEMAX2 16     // name display limit at verbosity 2\n\n// Print gzip, lzw, zlib, or zip file information.\nlocal void show_info(int method, unsigned long check, length_t len, int cont) {\n    size_t max;             // maximum name length for current verbosity\n    size_t n;               // name length without suffix\n    time_t now;             // for getting current year\n    char mod[26];           // modification time in text\n    char tag[NAMEMAX1+1];   // header or file name, possibly truncated\n\n    // create abbreviated name from header file name or actual file name\n    max = g.verbosity > 1 ? NAMEMAX2 : NAMEMAX1;\n    memset(tag, 0, max + 1);\n    if (cont)\n        strncpy(tag, \"<...>\", max + 1);\n    else if (g.hname == NULL) {\n        n = strlen(g.inf) - compressed_suffix(g.inf);\n        memcpy(tag, g.inf, n > max + 1 ? max + 1 : n);\n        if (strcmp(g.inf + n, \".tgz\") == 0 && n < max + 1)\n            strncpy(tag + n, \".tar\", max + 1 - n);\n    }\n    else\n        strncpy(tag, g.hname, max + 1);\n    if (tag[max])\n        strcpy(tag + max - 3, \"...\");\n\n    // convert time stamp to text\n    if (g.stamp && !cont) {\n        strcpy(mod, ctime(&g.stamp));\n        now = time(NULL);\n        if (strcmp(mod + 20, ctime(&now) + 20) != 0)\n            strcpy(mod + 11, mod + 19);\n    }\n    else\n        strcpy(mod + 4, \"------ -----\");\n    mod[16] = 0;\n\n    // if first time, print header\n    if (g.first) {\n        if (g.verbosity > 1)\n            fputs(\"method    check    timestamp    \", stdout);\n        if (g.verbosity > 0)\n            puts(\"compressed   original reduced  name\");\n        g.first = 0;\n    }\n\n    // print information\n    if (g.verbosity > 1) {\n        if (g.form == 3 && !g.decode)\n            printf(\"zip%3d  --------  %s  \", method, mod + 4);\n        else if (g.form > 1)\n            printf(\"zip%3d  %08lx  %s  \", method, check, mod + 4);\n        else if (g.form == 1)\n            printf(\"zlib%2d  %08lx  %s  \", method, check, mod + 4);\n        else if (method == 257)\n            printf(\"lzw     --------  %s  \", mod + 4);\n        else\n            printf(\"gzip%2d  %08lx  %s  \", method, check, mod + 4);\n    }\n    if (g.verbosity > 0) {\n        // compute reduction percent -- allow divide-by-zero, displays as -inf%\n        double red = 100. * (len - (double)g.in_tot) / len;\n        if ((g.form == 3 && !g.decode) ||\n            (method == 8 && g.in_tot > (len + (len >> 10) + 12)) ||\n            (method == 257 && g.in_tot > len + (len >> 1) + 3))\n#if __STDC_VERSION__-0 >= 199901L || __GNUC__-0 >= 3\n            printf(\"%10ju %10ju?  unk    %s\\n\", g.in_tot, len, tag);\n        else\n            printf(\"%10ju %10ju %6.1f%%  %s\\n\", g.in_tot, len, red, tag);\n#else\n            printf(\"%10lu %10lu?  unk    %s\\n\", g.in_tot, len, tag);\n        else\n            printf(\"%10lu %10lu %6.1f%%  %s\\n\", g.in_tot, len, red, tag);\n#endif\n    }\n    if (g.verbosity > 1 && g.hcomm != NULL)\n        puts(g.hcomm);\n}\n\n// List content information about the gzip file at ind (only works if the gzip\n// file contains a single gzip stream with no junk at the end, and only works\n// well if the uncompressed length is less than 4 GB).\nlocal void list_info(void) {\n    int method;             // get_header() return value\n    size_t n;               // available trailer bytes\n    off_t at;               // used to calculate compressed length\n    unsigned char tail[8];  // trailer containing check and length\n    unsigned long check;    // check value\n    length_t len;           // length from trailer\n\n    // initialize input buffer\n    in_init();\n\n    // read header information and position input after header\n    method = get_header(1);\n    if (method < 0) {\n        complain(method == -6 ? \"skipping: %s corrupt: header crc error\" :\n                 method == -1 ? \"skipping: %s empty\" :\n                 \"skipping: %s unrecognized format\", g.inf);\n        return;\n    }\n\n#ifndef NOTHREAD\n    // wait for read thread to complete current read() operation, to permit\n    // seeking and reading on g.ind here in the main thread\n    load_wait();\n#endif\n\n    // list zip file\n    if (g.form > 1) {\n        more_zip_entries();         // get first entry comment, if any\n        g.in_tot = g.zip_clen;\n        show_info(method, g.zip_crc, g.zip_ulen, 0);\n        return;\n    }\n\n    // list zlib file\n    if (g.form == 1) {\n        at = lseek(g.ind, 0, SEEK_END);\n        if (at == -1) {\n            check = 0;\n            do {\n                len = g.in_left < 4 ? g.in_left : 4;\n                g.in_next += g.in_left - len;\n                while (len--)\n                    check = (check << 8) + *g.in_next++;\n            } while (load() != 0);\n            check &= LOW32;\n        }\n        else {\n            g.in_tot = (length_t)at;\n            lseek(g.ind, -4, SEEK_END);\n            readn(g.ind, tail, 4);\n            check = PULL4M(tail);\n        }\n        g.in_tot -= 6;\n        show_info(method, check, 0, 0);\n        return;\n    }\n\n    // list lzw file\n    if (method == 257) {\n        at = lseek(g.ind, 0, SEEK_END);\n        if (at == -1)\n            while (load() != 0)\n                ;\n        else\n            g.in_tot = (length_t)at;\n        g.in_tot -= 3;\n        show_info(method, 0, 0, 0);\n        return;\n    }\n\n    // skip to end to get trailer (8 bytes), compute compressed length\n    if (g.in_short) {                   // whole thing already read\n        if (g.in_left < 8) {\n            complain(\"skipping: %s not a valid gzip file\", g.inf);\n            return;\n        }\n        g.in_tot = g.in_left - 8;       // compressed size\n        memcpy(tail, g.in_next + (g.in_left - 8), 8);\n    }\n    else if ((at = lseek(g.ind, -8, SEEK_END)) != -1) {\n        g.in_tot = (length_t)at - g.in_tot + g.in_left; // compressed size\n        readn(g.ind, tail, 8);          // get trailer\n    }\n    else {                              // can't seek\n        len = g.in_tot - g.in_left;     // save header size\n        do {\n            n = g.in_left < 8 ? g.in_left : 8;\n            memcpy(tail, g.in_next + (g.in_left - n), n);\n            load();\n        } while (g.in_left == BUF);     // read until end\n        if (g.in_left < 8) {\n            if (n + g.in_left < 8) {\n                complain(\"skipping: %s not a valid gzip file\", g.inf);\n                return;\n            }\n            if (g.in_left) {\n                if (n + g.in_left > 8)\n                    memcpy(tail, tail + n - (8 - g.in_left), 8 - g.in_left);\n                memcpy(tail + 8 - g.in_left, g.in_next, g.in_left);\n            }\n        }\n        else\n            memcpy(tail, g.in_next + (g.in_left - 8), 8);\n        g.in_tot -= len + 8;\n    }\n    if (g.in_tot < 2) {\n        complain(\"skipping: %s not a valid gzip file\", g.inf);\n        return;\n    }\n\n    // convert trailer to check and uncompressed length (modulo 2^32)\n    check = PULL4L(tail);\n    len = PULL4L(tail + 4);\n\n    // list information about contents\n    show_info(method, check, len, 0);\n}\n\n// --- copy input to output (when acting like cat) ---\n\nlocal void cat(void) {\n    // copy the first header byte read, if any\n    if (g.magic1 != -1) {\n        unsigned char buf[1] = {g.magic1};\n        g.out_tot += writen(g.outd, buf, 1);\n    }\n\n    // copy the remainder of the input to the output\n    while (g.in_left) {\n        g.out_tot += writen(g.outd, g.in_next, g.in_left);\n        g.in_left = 0;\n        load();\n    }\n}\n\n// --- decompress deflate input ---\n\n// Call-back input function for inflateBack().\nlocal unsigned inb(void *desc, unsigned char **buf) {\n    (void)desc;\n    if (g.in_left == 0)\n        load();\n    *buf = g.in_next;\n    unsigned len = g.in_left > UINT_MAX ? UINT_MAX : (unsigned)g.in_left;\n    g.in_next += len;\n    g.in_left -= len;\n    return len;\n}\n\n// Output buffers and window for infchk() and unlzw().\n#define OUTSIZE 32768U      // must be at least 32K for inflateBack() window\nlocal unsigned char out_buf[OUTSIZE];\n\n#ifndef NOTHREAD\n// Output data for parallel write and check.\nlocal unsigned char out_copy[OUTSIZE];\nlocal size_t out_len;\n\n// outb threads states.\nlocal lock *outb_write_more = NULL;\nlocal lock *outb_check_more;\n\n// Output write thread.\nlocal void outb_write(void *dummy) {\n    size_t len;\n    ball_t err;                     // error information from throw()\n\n    (void)dummy;\n\n    Trace((\"-- launched decompress write thread\"));\n    try {\n        do {\n            possess(outb_write_more);\n            wait_for(outb_write_more, TO_BE, 1);\n            len = out_len;\n            if (len && g.decode == 1)\n                writen(g.outd, out_copy, len);\n            Trace((\"-- decompress wrote %lu bytes\", len));\n            twist(outb_write_more, TO, 0);\n        } while (len);\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n    Trace((\"-- exited decompress write thread\"));\n}\n\n// Output check thread.\nlocal void outb_check(void *dummy) {\n    size_t len;\n    ball_t err;                     // error information from throw()\n\n    (void)dummy;\n\n    Trace((\"-- launched decompress check thread\"));\n    try {\n        do {\n            possess(outb_check_more);\n            wait_for(outb_check_more, TO_BE, 1);\n            len = out_len;\n            g.out_check = CHECK(g.out_check, out_copy, len);\n            Trace((\"-- decompress checked %lu bytes\", len));\n            twist(outb_check_more, TO, 0);\n        } while (len);\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n    Trace((\"-- exited decompress check thread\"));\n}\n#endif\n\n// Call-back output function for inflateBack(). Wait for the last write and\n// check calculation to complete, copy the write buffer, and then alert the\n// write and check threads and return for more decompression while that's going\n// on (or just write and check if no threads or if proc == 1).\nlocal int outb(void *desc, unsigned char *buf, unsigned len) {\n    (void)desc;\n\n#ifndef NOTHREAD\n    static thread *wr, *ch;\n\n    if (g.procs > 1) {\n        // if first time, initialize state and launch threads\n        if (outb_write_more == NULL) {\n            outb_write_more = new_lock(0);\n            outb_check_more = new_lock(0);\n            wr = launch(outb_write, NULL);\n            ch = launch(outb_check, NULL);\n        }\n\n        // wait for previous write and check threads to complete\n        possess(outb_check_more);\n        wait_for(outb_check_more, TO_BE, 0);\n        possess(outb_write_more);\n        wait_for(outb_write_more, TO_BE, 0);\n\n        // copy the output and alert the worker bees\n        out_len = len;\n        if (len) {\n            g.out_tot += len;\n            memcpy(out_copy, buf, len);\n        }\n        twist(outb_write_more, TO, 1);\n        twist(outb_check_more, TO, 1);\n\n        // if requested with len == 0, clean up -- terminate and join write and\n        // check threads, free lock\n        if (len == 0 && outb_write_more != NULL) {\n            join(ch);\n            join(wr);\n            free_lock(outb_check_more);\n            free_lock(outb_write_more);\n            outb_write_more = NULL;\n        }\n\n        // return for more decompression while last buffer is being written and\n        // having its check value calculated -- we wait for those to finish the\n        // next time this function is called\n        return 0;\n    }\n#endif\n\n    // if just one process or no threads, then do it without threads\n    if (len) {\n        if (g.decode == 1)\n            writen(g.outd, buf, len);\n        g.out_check = CHECK(g.out_check, buf, len);\n        g.out_tot += len;\n    }\n    return 0;\n}\n\n// Zip file data descriptor signature. This signature may or may not precede\n// the CRC and lengths, with either resulting in a valid zip file! There is\n// some odd code below that tries to detect and accommodate both cases.\n#define SIG 0x08074b50\n\n// Inflate for decompression or testing. Decompress from ind to outd unless\n// decode != 1, in which case just test ind, and then also list if list != 0;\n// look for and decode multiple, concatenated gzip and/or zlib streams; read\n// and check the gzip, zlib, or zip trailer.\nlocal void infchk(void) {\n    int ret, cont, more;\n    unsigned long check, len, ktot;\n    z_stream strm;\n    unsigned tmp2;\n    unsigned long tmp4;\n    length_t clen, ctot, utot;\n\n    ctot = utot = 0;\n    ktot = CHECK(0L, Z_NULL, 0);\n    cont = more = 0;\n    do {\n        // header already read -- set up for decompression\n        g.in_tot = g.in_left;       // track compressed data length\n        g.out_tot = 0;\n        g.out_check = CHECK(0L, Z_NULL, 0);\n        strm.zalloc = ZALLOC;\n        strm.zfree = ZFREE;\n        strm.opaque = OPAQUE;\n        ret = inflateBackInit(&strm, 15, out_buf);\n        if (ret == Z_MEM_ERROR)\n            throw(ENOMEM, \"not enough memory\");\n        if (ret != Z_OK)\n            throw(EINVAL, \"internal error\");\n\n        // decompress, compute lengths and check value\n        strm.avail_in = 0;\n        strm.next_in = Z_NULL;\n        ret = inflateBack(&strm, inb, NULL, outb, NULL);\n        inflateBackEnd(&strm);\n        g.in_left += strm.avail_in;\n        g.in_next = strm.next_in;\n        outb(NULL, NULL, 0);        // finish off final write and check\n        if (ret == Z_DATA_ERROR)\n            throw(EDOM, \"%s: corrupted -- invalid deflate data (%s)\",\n                  g.inf, strm.msg);\n        if (ret == Z_BUF_ERROR)\n            throw(EDOM, \"%s: corrupted -- incomplete deflate data\", g.inf);\n        if (ret != Z_STREAM_END)\n            throw(EINVAL, \"internal error\");\n\n        // compute compressed data length\n        clen = g.in_tot - g.in_left;\n\n        // read and check trailer\n        if (g.form > 1) {           // zip local trailer (if any)\n            if (g.form == 3) {      // data descriptor follows\n                // get data descriptor values, assuming no signature\n                g.zip_crc = GET4();\n                g.zip_clen = GET4();\n                g.zip_ulen = GET4();        // ZIP64 -> high clen, not ulen\n\n                // deduce whether or not a signature precedes the values\n                if (g.zip_crc == SIG &&         // might be the signature\n                    // if the expected CRC is not SIG, then it's a signature\n                    (g.out_check != SIG ||      // assume signature\n                     // now we're in a very rare case where CRC == SIG -- the\n                     // first four bytes could be the signature or the CRC\n                     (g.zip_clen == SIG &&      // if not, then no signature\n                      // now we have the first two words are SIG and the\n                      // expected CRC is SIG, so it could be a signature and\n                      // the CRC, or it could be the CRC and a compressed\n                      // length that is *also* SIG (!) -- so check the low 32\n                      // bits of the expected compressed length for SIG\n                      ((clen & LOW32) != SIG || // assume signature and CRC\n                       // now the expected CRC *and* the expected low 32 bits\n                       // of the compressed length are SIG -- this is so\n                       // incredibly unlikely, clearly someone is messing with\n                       // us, but we continue ... if the next four bytes are\n                       // not SIG, then there is not a signature -- check those\n                       // bytes, currently in g.zip_ulen:\n                       (g.zip_ulen == SIG &&    // if not, then no signature\n                        // we have three SIGs in a row in the descriptor, and\n                        // both the expected CRC and the expected clen are SIG\n                        // -- the first one is a signature if we don't expect\n                        // the third word to be SIG, which is either the low 32\n                        // bits of ulen, or if ZIP64, the high 32 bits of clen:\n                        (g.zip64 ? clen >> 32 : g.out_tot) != SIG\n                        // if that last compare was equal, then the expected\n                        // values for the CRC, the low 32 bits of clen, *and*\n                        // the low 32 bits of ulen are all SIG (!!), or in the\n                        // case of ZIP64, even crazier, the CRC and *both*\n                        // 32-bit halves of clen are all SIG (clen > 500\n                        // petabytes!!!) ... we can no longer discriminate the\n                        // hypotheses, so we will assume no signature\n                        ))))) {\n                    // first four bytes were actually the descriptor -- shift\n                    // the values down and get another four bytes\n                    g.zip_crc = g.zip_clen;\n                    g.zip_clen = g.zip_ulen;\n                    g.zip_ulen = GET4();\n                }\n\n                // if ZIP64, then ulen is really the high word of clen -- get\n                // the actual ulen and skip its high word as well (we only\n                // compare the low 32 bits of the lengths to verify)\n                if (g.zip64) {\n                    g.zip_ulen = GET4();\n                    (void)GET4();\n                }\n                if (g.in_eof)\n                    throw(EDOM, \"%s: corrupted entry -- missing trailer\",\n                          g.inf);\n            }\n            check = g.zip_crc;\n            if (check != g.out_check)\n                throw(EDOM, \"%s: corrupted entry -- crc32 mismatch\", g.inf);\n            if (g.zip_clen != (clen & LOW32) ||\n                g.zip_ulen != (g.out_tot & LOW32))\n                throw(EDOM, \"%s: corrupted entry -- length mismatch\",\n                      g.inf);\n            more = more_zip_entries();  // see if more entries, get comment\n        }\n        else if (g.form == 1) {     // zlib (big-endian) trailer\n            check = (unsigned long)(GET()) << 24;\n            check += (unsigned long)(GET()) << 16;\n            check += (unsigned)(GET()) << 8;\n            check += GET();\n            if (g.in_eof)\n                throw(EDOM, \"%s: corrupted -- missing trailer\", g.inf);\n            if (check != g.out_check)\n                throw(EDOM, \"%s: corrupted -- adler32 mismatch\", g.inf);\n        }\n        else {                      // gzip trailer\n            check = GET4();\n            len = GET4();\n            if (g.in_eof)\n                throw(EDOM, \"%s: corrupted -- missing trailer\", g.inf);\n            if (check != g.out_check)\n                throw(EDOM, \"%s: corrupted -- crc32 mismatch\", g.inf);\n            if (len != (g.out_tot & LOW32))\n                throw(EDOM, \"%s: corrupted -- length mismatch\", g.inf);\n        }\n\n        // show file information if requested\n        if (g.list) {\n            ctot += clen;\n            utot += g.out_tot;\n            ktot = COMB(ktot, check, g.out_tot);\n            g.in_tot = clen;\n            show_info(8, check, g.out_tot, cont);\n            cont = cont ? 2 : 1;\n        }\n\n        // if a gzip entry follows a gzip entry, decompress it (don't replace\n        // saved header information from first entry)\n    } while (g.form == 0 && (ret = get_header(0)) == 8);\n\n    // show totals if more than one gzip member\n    if (cont > 1 && g.verbosity > 0) {\n        if (g.verbosity > 1)\n            printf(\"        %08lx                \", ktot);\n        printf(\n#if __STDC_VERSION__-0 >= 199901L || __GNUC__-0 >= 3\n               \"%10ju %10ju %6.1f%%  (total)\\n\",\n#else\n               \"%10lu %10lu %6.1f%%  (total)\\n\",\n#endif\n               ctot, utot, 100. * (utot - (double)ctot) / utot);\n    }\n\n    // gzip -cdf copies junk after gzip stream directly to output\n    if (g.form == 0 && ret == -2 && g.force && g.pipeout && g.decode != 2 &&\n        !g.list)\n        cat();\n\n    // check for more entries in zip file\n    else if (more) {\n        complain(\"warning: %s: entries after the first were ignored\", g.inf);\n        g.keep = 1;         // don't delete the .zip file\n    }\n\n    // check for non-gzip after gzip stream, or anything after zlib stream\n    else if ((g.verbosity > 1 && g.form == 0 && ret != -1) ||\n             (g.form == 1 && (GET(), !g.in_eof)))\n        complain(\"warning: %s: trailing junk was ignored\", g.inf);\n}\n\n// --- decompress Unix compress (LZW) input ---\n\n// Type for accumulating bits. 23 bits will be used to accumulate up to 16-bit\n// symbols.\ntypedef unsigned long bits_t;\n\n#define NOMORE() (g.in_left == 0 && (g.in_eof || load() == 0))\n#define NEXT() (g.in_left--, (unsigned)*g.in_next++)\n\n// Decompress a compress (LZW) file from ind to outd. The compress magic header\n// (two bytes) has already been read and verified.\nlocal void unlzw(void) {\n    unsigned bits;              // current bits per code (9..16)\n    unsigned mask;              // mask for current bits codes = (1<<bits)-1\n    bits_t buf;                 // bit buffer (need 23 bits)\n    unsigned left;              // bits left in buf (0..7 after code pulled)\n    length_t mark;              // offset where last change in bits began\n    unsigned code;              // code, table traversal index\n    unsigned max;               // maximum bits per code for this stream\n    unsigned flags;             // compress flags, then block compress flag\n    unsigned end;               // last valid entry in prefix/suffix tables\n    unsigned prev;              // previous code\n    unsigned final;             // last character written for previous code\n    unsigned stack;             // next position for reversed string\n    unsigned outcnt;            // bytes in output buffer\n    // memory for unlzw() -- the first 256 entries of prefix[] and suffix[] are\n    // never used, so could have offset the index but it's faster to waste a\n    // little memory\n    prefix_t prefix[65536];             // index to LZW prefix string\n    unsigned char suffix[65536];        // one-character LZW suffix\n    unsigned char match[65280 + 2];     // buffer for reversed match\n\n    // process remainder of compress header -- a flags byte\n    g.out_tot = 0;\n    if (NOMORE())\n        throw(EDOM, \"%s: lzw premature end\", g.inf);\n    flags = NEXT();\n    if (flags & 0x60)\n        throw(EDOM, \"%s: unknown lzw flags set\", g.inf);\n    max = flags & 0x1f;\n    if (max < 9 || max > 16)\n        throw(EDOM, \"%s: lzw bits out of range\", g.inf);\n    if (max == 9)                           // 9 doesn't really mean 9\n        max = 10;\n    flags &= 0x80;                          // true if block compress\n\n    // mark the start of the compressed data for computing the first flush\n    mark = g.in_tot - g.in_left;\n\n    // clear table, start at nine bits per symbol\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    // set up: get first 9-bit code, which is the first decompressed byte, but\n    // don't create a table entry until the next code\n    if (NOMORE())                           // no compressed data is ok\n        return;\n    buf = NEXT();\n    if (NOMORE())\n        throw(EDOM, \"%s: lzw premature end\", g.inf);  // need nine bits\n    buf += NEXT() << 8;\n    final = prev = buf & mask;              // code\n    buf >>= bits;\n    left = 16 - bits;\n    if (prev > 255)\n        throw(EDOM, \"%s: invalid lzw code\", g.inf);\n    out_buf[0] = (unsigned char)final;      // write first decompressed byte\n    outcnt = 1;\n\n    // decode codes\n    stack = 0;\n    for (;;) {\n        // if the table will be full after this, increment the code size\n        if (end >= mask && bits < max) {\n            // flush unused input bits and bytes to next 8*bits bit boundary\n            // (this is a vestigial aspect of the compressed data format\n            // derived from an implementation that made use of a special VAX\n            // machine instruction!)\n            {\n                unsigned rem = ((g.in_tot - g.in_left) - mark) % bits;\n                if (rem) {\n                    rem = bits - rem;\n                    if (NOMORE())\n                        break;              // end of compressed data\n                    while (rem > g.in_left) {\n                        rem -= g.in_left;\n                        if (load() == 0)\n                            throw(EDOM, \"%s: lzw premature end\", g.inf);\n                    }\n                    g.in_left -= rem;\n                    g.in_next += rem;\n                }\n            }\n            buf = 0;\n            left = 0;\n\n            // mark this new location for computing the next flush\n            mark = g.in_tot - g.in_left;\n\n            // go to the next number of bits per symbol\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        // get a code of bits bits\n        if (NOMORE())\n            break;                          // end of compressed data\n        buf += (bits_t)(NEXT()) << left;\n        left += 8;\n        if (left < bits) {\n            if (NOMORE())\n                throw(EDOM, \"%s: lzw premature end\", g.inf);\n            buf += (bits_t)(NEXT()) << left;\n            left += 8;\n        }\n        code = buf & mask;\n        buf >>= bits;\n        left -= bits;\n\n        // process clear code (256)\n        if (code == 256 && flags) {\n            // flush unused input bits and bytes to next 8*bits bit boundary\n            {\n                unsigned rem = ((g.in_tot - g.in_left) - mark) % bits;\n                if (rem) {\n                    rem = bits - rem;\n                    while (rem > g.in_left) {\n                        rem -= g.in_left;\n                        if (load() == 0)\n                            throw(EDOM, \"%s: lzw premature end\", g.inf);\n                    }\n                    g.in_left -= rem;\n                    g.in_next += rem;\n                }\n            }\n            buf = 0;\n            left = 0;\n\n            // mark this new location for computing the next flush\n            mark = g.in_tot - g.in_left;\n\n            // go back to nine bits per symbol\n            bits = 9;                       // initialize bits and mask\n            mask = 0x1ff;\n            end = 255;                      // empty table\n            continue;                       // get next code\n        }\n\n        // special code to reuse last match\n        {\n            unsigned temp = code;           // save the current code\n            if (code > end) {\n                // be picky on the allowed code here, and make sure that the\n                // code we drop through (prev) will be a valid index so that\n                // random input does not cause an exception\n                if (code != end + 1 || prev > end)\n                    throw(EDOM, \"%s: invalid lzw code\", g.inf);\n                match[stack++] = (unsigned char)final;\n                code = prev;\n            }\n\n            // walk through linked list to generate output in reverse order\n            while (code >= 256) {\n                match[stack++] = suffix[code];\n                code = prefix[code];\n            }\n            match[stack++] = (unsigned char)code;\n            final = code;\n\n            // link new table entry\n            if (end < mask) {\n                end++;\n                prefix[end] = (prefix_t)prev;\n                suffix[end] = (unsigned char)final;\n            }\n\n            // set previous code for next iteration\n            prev = temp;\n        }\n\n        // write output in forward order\n        while (stack > OUTSIZE - outcnt) {\n            while (outcnt < OUTSIZE)\n                out_buf[outcnt++] = match[--stack];\n            g.out_tot += outcnt;\n            if (g.decode == 1)\n                writen(g.outd, out_buf, outcnt);\n            outcnt = 0;\n        }\n        do {\n            out_buf[outcnt++] = match[--stack];\n        } while (stack);\n    }\n\n    // write any remaining buffered output\n    g.out_tot += outcnt;\n    if (outcnt && g.decode == 1)\n        writen(g.outd, out_buf, outcnt);\n}\n\n// --- file processing ---\n\n// Extract file name from path.\nlocal char *justname(char *path) {\n    char *p;\n\n    p = strrchr(path, '/');\n    return p == NULL ? path : p + 1;\n}\n\n// Copy file attributes, from -> to, as best we can. This is best effort, so no\n// errors are reported. The mode bits, including suid, sgid, and the sticky bit\n// are copied (if allowed), the owner's user id and group id are copied (again\n// if allowed), and the access and modify times are copied.\nlocal int copymeta(char *from, char *to) {\n    struct stat st;\n    struct timeval times[2];\n\n    // get all of from's Unix meta data, return if not a regular file\n    if (stat(from, &st) != 0 || (st.st_mode & S_IFMT) != S_IFREG)\n        return -4;\n\n    // set to's mode bits, ignore errors\n    int ret = chmod(to, st.st_mode & 07777);\n\n    // copy owner's user and group, ignore errors\n    ret += chown(to, st.st_uid, st.st_gid);\n\n    // copy access and modify times, ignore errors\n    times[0].tv_sec = st.st_atime;\n    times[0].tv_usec = 0;\n    times[1].tv_sec = st.st_mtime;\n    times[1].tv_usec = 0;\n    ret += utimes(to, times);\n    return ret;\n}\n\n// Set the access and modify times of fd to t.\nlocal void touch(char *path, time_t t) {\n    struct timeval times[2];\n\n    times[0].tv_sec = t;\n    times[0].tv_usec = 0;\n    times[1].tv_sec = t;\n    times[1].tv_usec = 0;\n    (void)utimes(path, times);\n}\n\n// Request that all data buffered by the operating system for g.outd be written\n// to the permanent storage device. If fsync(fd) is used (POSIX), then all of\n// the data is sent to the device, but will likely be buffered in volatile\n// memory on the device itself, leaving open a window of vulnerability.\n// fcntl(fd, F_FULLSYNC) on the other hand, available in macOS only, will\n// request and wait for the device to write out its buffered data to permanent\n// storage. On Windows, _commit() is used.\nlocal void out_push(void) {\n    if (g.outd == -1)\n        return;\n#if defined(F_FULLSYNC)\n    int ret = fcntl(g.outd, F_FULLSYNC);\n#elif defined(_WIN32)\n    int ret = _commit(g.outd);\n#else\n    int ret = fsync(g.outd);\n#endif\n    if (ret == -1)\n        throw(errno, \"sync error on %s (%s)\", g.outf, strerror(errno));\n}\n\n// Process provided input file, or stdin if path is NULL. process() can call\n// itself for recursive directory processing.\nlocal void process(char *path) {\n    volatile int method = -1;       // get_header() return value\n    size_t len;                     // length of base name (minus suffix)\n    struct stat st;                 // to get file type and mod time\n    ball_t err;                     // error information from throw()\n    // all compressed suffixes for decoding search, in length order\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    // open input file with name in, descriptor ind -- set name and mtime\n    if (path == NULL) {\n        vstrcpy(&g.inf, &g.inz, 0, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = (g.headis & 2) && fstat(g.ind, &st) == 0 &&\n                  S_ISREG(st.st_mode) ? st.st_mtime : 0;\n        len = 0;\n    }\n    else {\n        // set input file name (already set if recursed here)\n        if (path != g.inf)\n            vstrcpy(&g.inf, &g.inz, 0, path);\n        len = strlen(g.inf);\n\n        // try to stat input file -- if not there and decoding, look for that\n        // name with compressed suffixes\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **sufx = sufs;\n                do {\n                    if (*sufx == NULL)\n                        break;\n                    vstrcpy(&g.inf, &g.inz, len, *sufx++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#if defined(EOVERFLOW) && defined(EFBIG)\n            if (errno == EOVERFLOW || errno == EFBIG)\n                throw(EDOM, \"%s too large -- \"\n                      \"not compiled with large file support\", g.inf);\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"skipping: %s does not exist\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        // only process regular files or named pipes, but allow symbolic links\n        // if -f, recurse into directory if -r\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFIFO &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"skipping: %s is a special file or device\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"skipping: %s is a symbolic link\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"skipping: %s is a directory\", g.inf);\n            return;\n        }\n\n        // recurse into directory (assumes Unix)\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll = NULL;\n            size_t size = 0, off = 0, base;\n            DIR *here;\n            struct dirent *next;\n\n            // accumulate list of entries (need to do this, since readdir()\n            // behavior not defined if directory modified between calls)\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                off = vstrcpy(&roll, &size, off, next->d_name);\n            }\n            closedir(here);\n            vstrcpy(&roll, &size, off, \"\");\n\n            // run process() for each entry in the directory\n            base = len && g.inf[len - 1] != (unsigned char)'/' ?\n                   vstrcpy(&g.inf, &g.inz, len, \"/\") - 1 : len;\n            for (off = 0; roll[off]; off += strlen(roll + off) + 1) {\n                vstrcpy(&g.inf, &g.inz, base, roll + off);\n                process(g.inf);\n            }\n            g.inf[len] = 0;\n\n            // release list of entries\n            FREE(roll);\n            return;\n        }\n\n        // don't compress .gz (or provided suffix) files, unless -f\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            grumble(\"skipping: %s ends with %s\", g.inf, g.sufx);\n            return;\n        }\n\n        // create output file only if input file has compressed suffix\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            size_t suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"skipping: %s does not have compressed suffix\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        // open input file\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            throw(errno, \"read error on %s (%s)\", g.inf, strerror(errno));\n\n        // prepare gzip header information for compression\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    // if requested, just list information about the input file\n    if (g.list && g.decode != 2) {\n        list_info();\n        load_end();\n        return;\n    }\n\n    // if decoding or testing, try to read gzip header\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                // gzip -cdf acts like cat on uncompressed input\n                !((method == -1 || method == -2) && g.force && g.pipeout &&\n                  g.decode != 2 && !g.list)) {\n            load_end();\n            complain(method == -6 ? \"skipping: %s corrupt: header crc error\" :\n                     method == -1 ? \"skipping: %s empty\" :\n                     method < 0 ? \"skipping: %s unrecognized format\" :\n                     \"skipping: %s unknown compression method\", g.inf);\n            return;\n        }\n\n        // if requested, test input file (possibly a test list)\n        if (g.decode == 2) {\n            try {\n                if (method == 8)\n                    infchk();\n                else {\n                    unlzw();\n                    if (g.list) {\n                        g.in_tot -= 3;\n                        show_info(method, 0, g.out_tot, 0);\n                    }\n                }\n            }\n            catch (err) {\n                if (err.code != EDOM)\n                    punt(err);\n                complain(\"skipping: %s\", err.why);\n                drop(err);\n                outb(NULL, NULL, 0);\n            }\n            load_end();\n            return;\n        }\n    }\n\n    // create output file out, descriptor outd\n    if (path == NULL || g.pipeout) {\n        // write to stdout\n        g.outf = alloc(NULL, strlen(\"<stdout>\") + 1);\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            throw(EINVAL, \"trying to write compressed data to a terminal\"\n                          \" (use -f to force)\");\n    }\n    else {\n        char *to = g.inf, *sufx = \"\";\n        size_t pre = 0;\n\n        // select parts of the output file name\n        if (g.decode) {\n            // for -dN or -dNT, use the path from the input file and the name\n            // from the header, stripping any path in the header name\n            if ((g.headis & 1) != 0 && g.hname != NULL) {\n                pre = (size_t)(justname(g.inf) - g.inf);\n                to = justname(g.hname);\n                len = strlen(to);\n            }\n            // for -d or -dNn, replace abbreviated suffixes\n            else if (strcmp(to + len, \".tgz\") == 0)\n                sufx = \".tar\";\n        }\n        else\n            // add appropriate suffix when compressing\n            sufx = g.sufx;\n\n        // create output file and open to write, overwriting any existing file\n        // of the same name only if requested with --force or -f\n        g.outf = alloc(NULL, pre + len + strlen(sufx) + 1);\n        memcpy(g.outf, g.inf, pre);\n        memcpy(g.outf + pre, to, len);\n        strcpy(g.outf + pre + len, sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                              (g.force ? 0 : O_EXCL), 0600);\n\n        // if it exists and wasn't forced, give the user a chance to overwrite\n        if (g.outd < 0 && errno == EEXIST) {\n            int overwrite = 0;\n            if (isatty(0) && g.verbosity) {\n                // get a response from the user -- the first non-blank\n                // character has to be a \"y\" or a \"Y\" to permit an overwrite\n                fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n                fflush(stderr);\n                int ch, first = 1;\n                do {\n                    ch = getchar();\n                    if (first == 1) {\n                        if (ch == ' ' || ch == '\\t')\n                            continue;\n                        if (ch == 'y' || ch == 'Y')\n                            overwrite = 1;\n                        first = 0;\n                    }\n                } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            }\n            if (!overwrite) {\n                complain(\"skipping: %s exists\", g.outf);\n                RELEASE(g.outf);\n                load_end();\n                return;\n            }\n            g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n        }\n\n        // if some other error, give up\n        if (g.outd < 0)\n            throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));\n    }\n    SET_BINARY_MODE(g.outd);\n\n    // process ind to outd\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        try {\n            if (method == 8)\n                infchk();\n            else if (method == 257)\n                unlzw();\n            else\n                cat();\n        }\n        catch (err) {\n            if (err.code != EDOM)\n                punt(err);\n            complain(\"skipping: %s\", err.why);\n            drop(err);\n            outb(NULL, NULL, 0);\n            if (g.outd != -1 && g.outd != 1) {\n                close(g.outd);\n                g.outd = -1;\n                unlink(g.outf);\n                RELEASE(g.outf);\n            }\n        }\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    // finish up, copy attributes, set times, delete original\n    load_end();\n    if (g.outd != -1 && g.outd != 1) {\n        if (g.sync)\n            out_push();         // push to permanent storage\n        if (close(g.outd))\n            throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));\n        g.outd = -1;            // now prevent deletion on interrupt\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep) {\n                if (st.st_nlink > 1 && !g.force)\n                    complain(\"%s has hard links -- not unlinking\", g.inf);\n                else\n                    unlink(g.inf);\n            }\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}\n\nlocal char *helptext[] = {\n\"Usage: pigz [options] [files ...]\",\n\"  will compress files in place, adding the suffix '.gz'. If no files are\",\n#ifdef NOTHREAD\n\"  specified, stdin will be compressed to stdout. pigz does what gzip does.\",\n#else\n\"  specified, stdin will be compressed to stdout. pigz does what gzip does,\",\n\"  but spreads the work over multiple processors and cores when compressing.\",\n#endif\n\"\",\n\"Options:\",\n#ifdef NOZOPFLI\n\"  -0 to -9             Compression level\",\n#else\n\"  -0 to -9, -11        Compression level (level 11, zopfli, is much slower)\",\n#endif\n\"  --fast, --best       Compression levels 1 and 9 respectively\",\n\"  -A, --alias xxx      Use xxx as the name for any --zip entry from stdin\",\n\"  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)\",\n\"  -c, --stdout         Write all processed output to stdout (won't delete)\",\n\"  -C, --comment ccc    Put comment ccc in the gzip or zip header\",\n\"  -d, --decompress     Decompress the compressed input\",\n\"  -f, --force          Force overwrite, compress .gz, links, and to terminal\",\n#ifndef NOZOPFLI\n\"  -F  --first          Do iterations first, before block split for -11\",\n#endif\n\"  -h, --help           Display a help screen and quit\",\n\"  -H, --huffman        Use only Huffman coding for compression\",\n\"  -i, --independent    Compress blocks independently for damage recovery\",\n#ifndef NOZOPFLI\n\"  -I, --iterations n   Number of iterations for -11 optimization\",\n\"  -J, --maxsplits n    Maximum number of split blocks for -11\",\n#endif\n\"  -k, --keep           Do not delete original file after processing\",\n\"  -K, --zip            Compress to PKWare zip (.zip) single entry format\",\n\"  -l, --list           List the contents of the compressed input\",\n\"  -L, --license        Display the pigz license and quit\",\n\"  -m, --no-time        Do not store or restore mod time\",\n\"  -M, --time           Store or restore mod time\",\n\"  -n, --no-name        Do not store or restore file name or mod time\",\n\"  -N, --name           Store or restore file name and mod time\",\n#ifndef NOZOPFLI\n\"  -O  --oneblock       Do not split into smaller blocks for -11\",\n#endif\n#ifndef NOTHREAD\n\"  -p, --processes n    Allow up to n compression threads (default is the\",\n\"                       number of online processors, or 8 if unknown)\",\n#endif\n\"  -q, --quiet          Print no messages, even on error\",\n\"  -r, --recursive      Process the contents of all subdirectories\",\n\"  -R, --rsyncable      Input-determined block locations for rsync\",\n\"  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)\",\n\"  -t, --test           Test the integrity of the compressed input\",\n\"  -U, --rle            Use run-length encoding for compression\",\n#ifdef PIGZ_DEBUG\n\"  -v, --verbose        Provide more verbose output (-vv to debug)\",\n#else\n\"  -v, --verbose        Provide more verbose output\",\n#endif\n\"  -V  --version        Show the version of pigz\",\n\"  -Y  --synchronous    Force output file write to permanent storage\",\n\"  -z, --zlib           Compress to zlib (.zz) instead of gzip format\",\n\"  --                   All arguments after \\\"--\\\" are treated as files\"\n};\n\n// Display the help text above.\nlocal void help(void) {\n    int n;\n\n    if (g.verbosity == 0)\n        return;\n    for (n = 0; n < (int)(sizeof(helptext) / sizeof(char *)); n++)\n        fprintf(stderr, \"%s\\n\", helptext[n]);\n    fflush(stderr);\n    exit(0);\n}\n\n#ifndef NOTHREAD\n\n// Try to determine the number of processors.\nlocal int nprocs(int n) {\n#  ifdef _SC_NPROCESSORS_ONLN\n    n = (int)sysconf(_SC_NPROCESSORS_ONLN);\n#  else\n#    ifdef _SC_NPROC_ONLN\n    n = (int)sysconf(_SC_NPROC_ONLN);\n#    else\n#      ifdef __hpux\n    struct pst_dynamic psd;\n\n    if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)\n        n = psd.psd_proc_cnt;\n#      endif\n#    endif\n#  endif\n    return n;\n}\n\n#endif\n\n// Set option defaults.\nlocal void defaults(void) {\n    g.level = Z_DEFAULT_COMPRESSION;\n    g.strategy = Z_DEFAULT_STRATEGY;\n#ifndef NOZOPFLI\n    // default zopfli options as set by ZopfliInitOptions():\n    //  verbose = 0\n    //  numiterations = 15\n    //  blocksplitting = 1\n    //  blocksplittinglast = 0\n    //  blocksplittingmax = 15\n    ZopfliInitOptions(&g.zopts);\n#endif\n    g.block = 131072UL;             // 128K\n    g.shift = x2nmodp(g.block, 3);\n#ifdef NOTHREAD\n    g.procs = 1;\n#else\n    g.procs = nprocs(8);\n#endif\n    g.rsync = 0;                    // don't do rsync blocking\n    g.setdict = 1;                  // initialize dictionary each thread\n    g.verbosity = 1;                // normal message level\n    g.headis = 3;                   // store name and time (low bits == 11),\n                                    // restore neither (next bits == 00),\n                                    // where 01 is name and 10 is time\n    g.pipeout = 0;                  // don't force output to stdout\n    g.sufx = \".gz\";                 // compressed file suffix\n    g.comment = NULL;               // no comment\n    g.decode = 0;                   // compress\n    g.list = 0;                     // compress\n    g.keep = 0;                     // delete input file once compressed\n    g.force = 0;                    // don't overwrite, don't compress links\n    g.sync = 0;                     // don't force a flush on output\n    g.recurse = 0;                  // don't go into directories\n    g.form = 0;                     // use gzip format\n}\n\n// Long options conversion to short options.\nlocal char *longopts[][2] = {\n    {\"LZW\", \"Z\"}, {\"lzw\", \"Z\"}, {\"alias\", \"A\"}, {\"ascii\", \"a\"}, {\"best\", \"9\"},\n    {\"bits\", \"Z\"}, {\"blocksize\", \"b\"}, {\"decompress\", \"d\"}, {\"fast\", \"1\"},\n    {\"force\", \"f\"}, {\"comment\", \"C\"},\n#ifndef NOZOPFLI\n    {\"first\", \"F\"}, {\"iterations\", \"I\"}, {\"maxsplits\", \"J\"}, {\"oneblock\", \"O\"},\n#endif\n    {\"help\", \"h\"}, {\"independent\", \"i\"}, {\"keep\", \"k\"}, {\"license\", \"L\"},\n    {\"list\", \"l\"}, {\"name\", \"N\"}, {\"no-name\", \"n\"}, {\"no-time\", \"m\"},\n    {\"processes\", \"p\"}, {\"quiet\", \"q\"}, {\"recursive\", \"r\"}, {\"rsyncable\", \"R\"},\n    {\"silent\", \"q\"}, {\"stdout\", \"c\"}, {\"suffix\", \"S\"}, {\"synchronous\", \"Y\"},\n    {\"test\", \"t\"}, {\"time\", \"M\"}, {\"to-stdout\", \"c\"}, {\"uncompress\", \"d\"},\n    {\"verbose\", \"v\"}, {\"version\", \"V\"}, {\"zip\", \"K\"}, {\"zlib\", \"z\"},\n    {\"huffman\", \"H\"}, {\"rle\", \"U\"}};\n#define NLOPTS (sizeof(longopts) / (sizeof(char *) << 1))\n\n// Either new buffer size, new compression level, or new number of processes.\n// Get rid of old buffers and threads to force the creation of new ones with\n// the new settings.\nlocal void new_opts(void) {\n    single_compress(1);\n#ifndef NOTHREAD\n    finish_jobs();\n#endif\n}\n\n// Verify that arg is only digits, and if so, return the decimal value.\nlocal size_t num(char *arg) {\n    char *str = arg;\n    size_t val = 0;\n\n    if (*str == 0)\n        throw(EINVAL, \"internal error: empty parameter\");\n    do {\n        if (*str < '0' || *str > '9' ||\n            (val && ((~(size_t)0) - (size_t)(*str - '0')) / val < 10))\n            throw(EINVAL, \"invalid numeric parameter: %s\", arg);\n        val = val * 10 + (size_t)(*str - '0');\n    } while (*++str);\n    return val;\n}\n\n// Process an argument, return true if it is an option (not a filename)\nlocal int option(char *arg) {\n    static int get = 0;     // if not zero, look for option parameter\n    char bad[3] = \"-X\";     // for error messages (X is replaced)\n\n    // if no argument or dash option, check status of get\n    if (get && (arg == NULL || *arg == '-')) {\n        bad[1] = \"bpSIJAC\"[get - 1];\n        throw(EINVAL, \"missing parameter after %s\", bad);\n    }\n    if (arg == NULL)\n        return 1;\n\n    // process long option or short options\n    if (*arg == '-') {\n        // a single dash will be interpreted as stdin\n        if (*++arg == 0)\n            return 0;\n\n        // process long option (fall through with equivalent short option)\n        if (*arg == '-') {\n            int j;\n\n            arg++;\n            for (j = NLOPTS - 1; j >= 0; j--)\n                if (strcmp(arg, longopts[j][0]) == 0) {\n                    arg = longopts[j][1];\n                    break;\n                }\n            if (j < 0)\n                throw(EINVAL, \"invalid option: %s\", arg - 2);\n        }\n\n        // process short options (more than one allowed after dash)\n        do {\n            // if looking for a parameter, don't process more single character\n            // options until we have the parameter\n            if (get) {\n                if (get == 3)\n                    throw(EINVAL,\n                          \"invalid usage: -S must be followed by space\");\n                if (get == 7)\n                    throw(EINVAL,\n                          \"invalid usage: -C must be followed by space\");\n                break;      // allow -*nnn to fall to parameter code\n            }\n\n            // process next single character option or compression level\n            bad[1] = *arg;\n            switch (*arg) {\n            case '0': case '1': case '2': case '3': case '4':\n            case '5': case '6': case '7': case '8': case '9':\n                g.level = *arg - '0';\n                while (arg[1] >= '0' && arg[1] <= '9') {\n                    if (g.level && (INT_MAX - (arg[1] - '0')) / g.level < 10)\n                        throw(EINVAL, \"only levels 0..9 and 11 are allowed\");\n                    g.level = g.level * 10 + *++arg - '0';\n                }\n                if (g.level == 10 || g.level > 11)\n                    throw(EINVAL, \"only levels 0..9 and 11 are allowed\");\n                break;\n            case 'A':  get = 6;  break;\n            case 'C':  get = 7;  break;\n#ifndef NOZOPFLI\n            case 'F':  g.zopts.blocksplittinglast = 1;  break;\n#endif\n            case 'H':  g.strategy = Z_HUFFMAN_ONLY;  break;\n#ifndef NOZOPFLI\n            case 'I':  get = 4;  break;\n            case 'J':  get = 5;  break;\n#endif\n            case 'K':  g.form = 2;  g.sufx = \".zip\";  break;\n            case 'L':\n                puts(VERSION);\n                puts(\"Copyright (C) 2007-2023 Mark Adler\");\n                puts(\"Subject to the terms of the zlib license.\");\n                puts(\"No warranty is provided or implied.\");\n                exit(0);\n                break;          // avoid warning\n            case 'M':  g.headis |= 0xa;  break;\n            case 'N':  g.headis = 0xf;  break;\n#ifndef NOZOPFLI\n            case 'O':  g.zopts.blocksplitting = 0;  break;\n#endif\n            case 'R':  g.rsync = 1;  break;\n            case 'S':  get = 3;  break;\n                // -T defined below as an alternative for -m\n            case 'V':\n                puts(VERSION);\n                if (g.verbosity > 1)\n                    printf(\"zlib %s\\n\", zlibVersion());\n                exit(0);\n                break;          // avoid warning\n            case 'Y':  g.sync = 1;  break;\n            case 'Z':\n                throw(EINVAL, \"invalid option: LZW output not supported: %s\",\n                      bad);\n                break;          // avoid warning\n            case 'a':\n                throw(EINVAL, \"invalid option: no ascii conversion: %s\",\n                      bad);\n                break;          // avoid warning\n            case 'b':  get = 1;  break;\n            case 'c':  g.pipeout = 1;  break;\n            case 'd':  if (!g.decode) g.headis >>= 2;  g.decode = 1;  break;\n            case 'f':  g.force = 1;  break;\n            case 'h':  help();  break;\n            case 'i':  g.setdict = 0;  break;\n            case 'k':  g.keep = 1;  break;\n            case 'l':  g.list = 1;  break;\n            case 'n':  g.headis = 0;  break;\n            case 'T':\n            case 'm':  g.headis &= ~0xa;  break;\n            case 'p':  get = 2;  break;\n            case 'q':  g.verbosity = 0;  break;\n            case 'r':  g.recurse = 1;  break;\n            case 't':  g.decode = 2;  break;\n            case 'U':  g.strategy = Z_RLE;  break;\n            case 'v':  g.verbosity++;  break;\n            case 'z':  g.form = 1;  g.sufx = \".zz\";  break;\n            default:\n                throw(EINVAL, \"invalid option: %s\", bad);\n            }\n        } while (*++arg);\n        if (*arg == 0)\n            return 1;\n    }\n\n    // process option parameter for -b, -p, -A, -S, -I, or -J\n    if (get) {\n        size_t n;\n\n        if (get == 1) {\n            n = num(arg);\n            g.block = n << 10;                  // chunk size\n#ifndef NOTHREAD\n            g.shift = x2nmodp(g.block, 3);\n#endif\n            if (g.block < DICT)\n                throw(EINVAL, \"block size too small (must be >= 32K)\");\n            if (n != g.block >> 10 ||\n                OUTPOOL(g.block) < g.block ||\n                (ssize_t)OUTPOOL(g.block) < 0 ||\n                g.block > (1UL << 29))          // limited by append_len()\n                throw(EINVAL, \"block size too large: %s\", arg);\n        }\n        else if (get == 2) {\n            n = num(arg);\n            g.procs = (int)n;                   // # processes\n            if (g.procs < 1)\n                throw(EINVAL, \"invalid number of processes: %s\", arg);\n            if ((size_t)g.procs != n || INBUFS(g.procs) < 1)\n                throw(EINVAL, \"too many processes: %s\", arg);\n#ifdef NOTHREAD\n            if (g.procs > 1)\n                throw(EINVAL, \"compiled without threads\");\n#endif\n        }\n        else if (get == 3) {\n            if (*arg == 0)\n                throw(EINVAL, \"suffix cannot be empty\");\n            g.sufx = arg;                       // gz suffix\n        }\n#ifndef NOZOPFLI\n        else if (get == 4)\n            g.zopts.numiterations = (int)num(arg);  // optimize iterations\n        else if (get == 5)\n            g.zopts.blocksplittingmax = (int)num(arg);  // max block splits\n        else if (get == 6)\n            g.alias = arg;                      // zip name for stdin\n#endif\n        else if (get == 7)\n            g.comment = arg;                    // header comment\n        get = 0;\n        return 1;\n    }\n\n    // neither an option nor parameter\n    return 0;\n}\n\n#ifndef NOTHREAD\n// handle error received from yarn function\nlocal void cut_yarn(int err) {\n    throw(err, \"internal threads error\");\n}\n#endif\n\n// Process command line arguments.\nint main(int argc, char **argv) {\n    int n;                          // general index\n    int nop;                        // index before which \"-\" means stdin\n    int done;                       // number of named files processed\n    size_t k;                       // program name length\n    char *opts, *p;                 // environment default options, marker\n    ball_t err;                     // error information from throw()\n\n    g.ret = 0;\n    try {\n        // initialize globals\n        g.inf = NULL;\n        g.inz = 0;\n#ifndef NOTHREAD\n        g.in_which = -1;\n#endif\n        g.alias = \"-\";\n        g.outf = NULL;\n        g.first = 1;\n        g.hname = NULL;\n        g.hcomm = NULL;\n\n        // save pointer to program name for error messages\n        p = strrchr(argv[0], '/');\n        p = p == NULL ? argv[0] : p + 1;\n        g.prog = *p ? p : \"pigz\";\n\n        // prepare for interrupts and logging\n        signal(SIGINT, cut_short);\n#ifndef NOTHREAD\n        yarn_prefix = g.prog;           // prefix for yarn error messages\n        yarn_abort = cut_yarn;          // call on thread error\n#endif\n#ifdef PIGZ_DEBUG\n        gettimeofday(&start, NULL);     // starting time for log entries\n        log_init();                     // initialize logging\n#endif\n\n        // set all options to defaults\n        defaults();\n\n        // check zlib version\n        if (zlib_vernum() < 0x1230)\n           throw(EINVAL, \"zlib version less than 1.2.3\");\n\n        // create CRC table, in case zlib compiled with dynamic tables\n        get_crc_table();\n\n        // process user environment variable defaults in GZIP\n        opts = getenv(\"GZIP\");\n        if (opts != NULL) {\n            while (*opts) {\n                while (*opts == ' ' || *opts == '\\t')\n                    opts++;\n                p = opts;\n                while (*p && *p != ' ' && *p != '\\t')\n                    p++;\n                n = *p;\n                *p = 0;\n                if (!option(opts))\n                    throw(EINVAL, \"cannot provide files in \"\n                                  \"GZIP environment variable\");\n                opts = p + (n ? 1 : 0);\n            }\n            option(NULL);           // check for missing parameter\n        }\n\n        // process user environment variable defaults in PIGZ as well\n        opts = getenv(\"PIGZ\");\n        if (opts != NULL) {\n            while (*opts) {\n                while (*opts == ' ' || *opts == '\\t')\n                    opts++;\n                p = opts;\n                while (*p && *p != ' ' && *p != '\\t')\n                    p++;\n                n = *p;\n                *p = 0;\n                if (!option(opts))\n                    throw(EINVAL, \"cannot provide files in \"\n                                  \"PIGZ environment variable\");\n                opts = p + (n ? 1 : 0);\n            }\n            option(NULL);           // check for missing parameter\n        }\n\n        // decompress if named \"unpigz\" or \"gunzip\", to stdout if \"*cat\"\n        if (strcmp(g.prog, \"unpigz\") == 0 || strcmp(g.prog, \"gunzip\") == 0) {\n            if (!g.decode)\n                g.headis >>= 2;\n            g.decode = 1;\n        }\n        if ((k = strlen(g.prog)) > 2 && strcmp(g.prog + k - 3, \"cat\") == 0) {\n            if (!g.decode)\n                g.headis >>= 2;\n            g.decode = 1;\n            g.pipeout = 1;\n        }\n\n        // if no arguments and compressed data to/from terminal, show help\n        if (argc < 2 && isatty(g.decode ? 0 : 1))\n            help();\n\n        // process all command-line options first\n        nop = argc;\n        for (n = 1; n < argc; n++)\n            if (strcmp(argv[n], \"--\") == 0) {\n                nop = n;                // after this, \"-\" is the name \"-\"\n                argv[n] = NULL;         // remove option\n                break;                  // ignore options after \"--\"\n            }\n            else if (option(argv[n]))   // process argument\n                argv[n] = NULL;         // remove if option\n        option(NULL);                   // check for missing parameter\n\n        // process command-line filenames\n        done = 0;\n        for (n = 1; n < argc; n++)\n            if (argv[n] != NULL) {\n                if (done == 1 && g.pipeout && !g.decode && !g.list &&\n                    g.form > 1)\n                    complain(\"warning: output will be concatenated zip files\"\n                             \" -- %s will not be able to extract\", g.prog);\n                process(n < nop && strcmp(argv[n], \"-\") == 0 ? NULL : argv[n]);\n                done++;\n            }\n\n        // list stdin or compress stdin to stdout if no file names provided\n        if (done == 0)\n            process(NULL);\n    }\n    always {\n        // release resources\n        RELEASE(g.inf);\n        g.inz = 0;\n        new_opts();\n    }\n    catch (err) {\n        THREADABORT(err);\n    }\n\n    // show log (if any)\n    log_dump();\n    return g.ret;\n}\n"
        },
        {
          "name": "pigz.pdf",
          "type": "blob",
          "size": 24.2841796875,
          "content": null
        },
        {
          "name": "pigz.spec",
          "type": "blob",
          "size": 0.9228515625,
          "content": "Summary: pigz is a parallel implementation of gzip which utilizes multiple cores\nName: pigz\nVersion: 2.8\nRelease: 1\nSource0: %{name}-%{version}.tar.gz\nLicense: zlib\nGroup: Applications/Tools\nPackager: Duncan Brown <duncan@duncanbrown.org>\nBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\nURL: http://www.zlib.net/pigz\n\n%description\npigz, which stands for parallel implementation of gzip, is a fully functional replacement for gzip that exploits multiple processors and multiple cores to the hilt when compressing data. pigz was written by Mark Adler, and uses the zlib and pthread libraries.\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n%prep\nmkdir -p $RPM_BUILD_ROOT\n\n%setup -q\n%build\nmake\nmkdir -p ${RPM_BUILD_ROOT}/usr/bin\nmkdir -p ${RPM_BUILD_ROOT}/usr/man/man1\nmv pigz unpigz ${RPM_BUILD_ROOT}/usr/bin\nmv pigz.1 ${RPM_BUILD_ROOT}/usr/man/man1\n\n%files\n%defattr(-,root,root)\n/usr/bin/pigz\n/usr/bin/unpigz\n%doc\n/usr/man/man1/pigz.1\n"
        },
        {
          "name": "try.c",
          "type": "blob",
          "size": 2.5546875,
          "content": "/* try.c -- try / catch / throw exception handling for C99\n * For copyright, version, and conditions of distribution and use, see try.h\n */\n\n/* See try.h for documentation.  This source file provides the global pointer\n   and the functions needed by throw().  The pointer is thread-unique if\n   pthread.h is included in try.h. */\n\n#include \"try.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n/* Set up the try stack with a global pointer to the next try block.  The\n   global is thread-unique if pthread.h is included in try.h. */\n#ifdef PTHREAD_ONCE_INIT\n    pthread_key_t try_key_;\n    static pthread_once_t try_once_ = PTHREAD_ONCE_INIT;\n    static void try_create_(void)\n    {\n        int ret = pthread_key_create(&try_key_, NULL);\n        assert(ret == 0 && \"try: pthread_key_create() failed\");\n    }\n    void try_setup_(void)\n    {\n        int ret = pthread_once(&try_once_, try_create_);\n        assert(ret == 0 && \"try: pthread_once() failed\");\n    }\n#else /* !PTHREAD_ONCE_INIT */\n    try_t_ *try_stack_ = NULL;\n#endif /* PTHREAD_ONCE_INIT */\n\n/* Throw an exception.  This must always have at least two arguments, where the\n   second argument can be a NULL.  The throw() macro is permitted to have one\n   argument, since it appends a NULL argument in the call to this function. */\nvoid try_throw_(int code, char *fmt, ...)\n{\n    /* save the thrown information in the try stack before jumping */\n    try_setup_();\n    assert(try_stack_ != NULL && \"try: naked throw\");\n    try_stack_->ball.ret = 1;\n    try_stack_->ball.code = code;\n    try_stack_->ball.free = 0;\n    try_stack_->ball.why = fmt;\n\n    /* consider the second argument to be a string, and if it has formatting\n       commands, process them with the subsequent arguments of throw, saving\n       the result in allocated memory -- this if statement and clause must be\n       updated for a different interpretation of the throw() arguments and\n       different contents of the ball_t structure */\n    if (fmt != NULL && strchr(fmt, '%') != NULL) {\n        char *why, nul[1];\n        size_t len;\n        va_list ap1, ap2;\n\n        va_start(ap1, fmt);\n        va_copy(ap2, ap1);\n        len = vsnprintf(nul, 1, fmt, ap1);\n        va_end(ap1);\n        why = malloc(len + 1);\n        if (why == NULL)\n            try_stack_->ball.why = \"try: out of memory\";\n        else {\n            vsnprintf(why, len + 1, fmt, ap2);\n            va_end(ap2);\n            try_stack_->ball.free = 1;\n            try_stack_->ball.why = why;\n        }\n    }\n\n    /* jump to the end of the nearest enclosing try block */\n    longjmp(try_stack_->env, 1);\n}\n"
        },
        {
          "name": "try.h",
          "type": "blob",
          "size": 22.5029296875,
          "content": "/* try.h -- try / catch / throw exception handling for C99\n  Copyright (C) 2013, 2015, 2016, 2021 Mark Adler\n  Version 1.5  10 April 2021\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n */\n\n/*\n    Version History\n    1.0    7 Jan 2013   - First version\n    1.1    2 Nov 2013   - Use variadic macros and functions instead of partial\n                          structure assignment, allowing arbitrary arguments\n                          to printf()\n    1.2   19 Jan 2015   - Obey setjmp() invocation limits from C standard\n    1.3    1 Mar 2015   - Add preserve to avoid use of volatile, remove retry\n    1.4    2 Jan 2016   - Add no-return attribute to throw()\n    1.5   10 Apr 2021   - Portability improvements\n */\n\n/* To use, include try.h in all source files that use these operations, and\n   compile and link try.c.  By default, pthread threads are used to make the\n   exception handling thread-safe. If a different threads library is required,\n   then try.h and try.c must be modified to use that environment's thread-local\n   storage for the try_stack_ pointer.  try.h and try.c assume that the\n   compiler and library conform to the C99 standard, at least with respect to\n   the use of variadic macro and function arguments. */\n\n/*\n   try.h provides a try / catch / throw exception handler, which allows\n   catching exceptions across any number of levels of function calls.  try\n   blocks can be nested as desired, with a throw going to the end of the\n   innermost enclosing try, passing the thrown information to the associated\n   catch block.  A global try stack is used, to avoid having to pass exception\n   handler information through all of the functions down to the invocations of\n   throw.  The try stack is thread-unique if pthread is made available.  In\n   addition to the macros try, catch, and throw, the macros preserve, always,\n   punt, and drop, and the type ball_t are created.  All other symbols are of\n   the form try_*_ or TRY_*_, where the final underscore should avoid conflicts\n   with application symbols. The eight exposed names can be changed easily in\n   #defines below.\n\n   A try block encloses code that may throw an exception with the throw()\n   macro, either directly in the try block or in any function called directly\n   or indirectly from the try block.  throw() must have at least one argument,\n   which is an integer.  The try block is followed by a catch block whose code\n   will be executed when throw() is called with a non-zero first argument.  If\n   the first argument of throw() is zero, then execution continues after the\n   catch block.  If the try block completes normally, with no throw() being\n   called, then execution continues normally after the catch block.\n\n   There can be only one catch block.  catch has one argument which must be a\n   ball_t type variable declared in the current function or block containing\n   the try and catch.  That variable is loaded with the information sent by the\n   throw() for use in the catch block.\n\n   throw() may optionally include more information that is passed to the catch\n   block in the ball_t structure.  throw() can have one or more arguments,\n   where the first (possibly only) argument is an integer code.  The second\n   argument can be a pointer, which will be replaced by NULL in the ball_t\n   structure if not provided.  The implementation of throw() in try.c assumes\n   that if the second argument is present and is not NULL, that it is a string.\n   If that string has any percent (%) signs in it, then throw() will run that\n   string through vsnprintf() with any other arguments provided after the\n   string in the throw() invocation, and save the resulting formatted string in\n   the ball_t structure.  Information on whether or not the string was\n   allocated is also maintained in the ball_t structure.\n\n   throw() in try.c can be modified to not assume that the second argument is a\n   string.  For example, an application may want to assume instead that the\n   second argument is a pointer to a set of information for use in the catch\n   block.\n\n   The catch block may conditionally do a punt(), where the argument of punt()\n   is the argument of catch.  This passes the exception on to the next\n   enclosing try/catch handler.\n\n   If a catch block does not always complete with a punt(), it should contain a\n   drop(), where the argument of drop() is the argument of catch.  This frees\n   the allocated string made if vsnprintf() was used by throw() to generate the\n   string.  If printf() format strings are never used, then drop() is not\n   required.\n\n   An always block may be placed between the try and catch block.  The\n   statements in that block will be executed regardless of whether or not the\n   try block completed normally.  As indicated by the ordering, the always\n   block will be executed before the catch block.  This block is not named\n   \"finally\", since it is different from the finally block in other languages\n   which is executed after the catch block.\n\n   A naked break or continue in a try or always block will go directly to the\n   end of that block.\n\n   try is thread-safe when compiled with pthread.h.  A throw() in a thread can\n   only be caught in the same thread.  If a throw() is attempted from a thread\n   without an enclosing try in that thread, even if in another thread there is\n   a try around the pthread_create() that spawned this thread, then the throw\n   will fail on an assert.  Each thread has its own thread-unique try stack,\n   which starts off empty.\n\n   If an intermediate function does not have a need for operations in a catch\n   block other than punt, and does not need an always block, then that function\n   does not need a try block.  \"try { block } catch (err) { punt(err); }\" is\n   the same as just \"block\".  More precisely, it's equivalent to \"do { block }\n   while (0);\", which replicates the behavior of a naked break or continue in a\n   block when it follows try.  throw() can be used from a function that has no\n   try.  All that is necessary is that there is a try somewhere up the function\n   chain that called the current function in the current thread.\n\n   There must not be a return in any try block, nor a goto in any try block\n   that leaves that block.  The always block does not catch a return from the\n   try block.  There is no check or protection for an improper use of return or\n   goto.  It is up to the user to assure that this doesn't happen.  If it does\n   happen, then the reference to the current try block is left on the try\n   stack, and the next throw which is supposed to go to an enclosing try would\n   instead go to this try, possibly after the enclosing function has returned.\n   Mayhem will then ensue.  This may be caught by the longjmp() implementation,\n   which would report \"longjmp botch\" and then abort.\n\n   Any local automatic storage variables that are modified in the try block and\n   used in the catch or always block must be declared volatile.  Otherwise\n   their value in the catch or always block is indeterminate.  Alternatively, a\n   preserve block can be inserted after an automatic storage variable is\n   changed in a try block.  The preserve block saves the state of those\n   variables at the moment preserve is executed, and effectively continues the\n   try block.  The same admonition then applies to variables modified in the\n   preserve block.  The only assurance is that the catch and always block will\n   have the values of the local automatic storage variables as they were at the\n   time of the last try or preserve statement, but only if they have not been\n   modified since the last try or preserve statement.  As many preserve blocks\n   as desired are permitted.\n\n   Any statements between try and always, between try and catch if there is no\n   always, or between always and catch are part of those respective try or\n   always blocks.  Use of { } to enclose those blocks is optional, but { }\n   should be used anyway for clarity, style, and to inform smart source editors\n   that the enclosed code is to be indented.  Enclosing the catch block with {\n   } is not optional if there is more than one statement in the block.\n   However, even if there is just one statement in the catch block, it should\n   be enclosed in { } anyway for style and editing convenience.\n\n   The contents of the ball_t structure after the first element (int code) can\n   be customized for the application.  If ball_t is customized, then the code\n   in try.c should be updated accordingly.  If there is no memory allocation in\n   throw(), then drop() can be eliminated.\n\n\n   Summary:\n\n   Here is the permitted structure, where [] means an optional element\n   permitted once, and []* means an optional element permitted more than once:\n\n   try { body } [preserve { body }]* [always { clean }] catch (ball) { action }\n\n   body must not contain a goto or return that exits body.  ball must be a\n   variable of the type ball_t.  \"action\" must always execute either a\n   drop(ball) or a punt(ball).\n\n   A throw() may be executed in body or at any level of functions called by\n   body, and will be processed by the innermost enclosing try in the same\n   thread:\n\n       throw(code);\n\n   or,\n\n       throw(code, \"string\");\n\n   or,\n\n       throw(code, \"format string\", ...);\n\n   A throw() whose first argument is not zero, and that is caught by this try,\n   will execute \"clean\" followed by \"action\".  Either a throw() whose first\n   argument is zero and caught by this try, or the normal completion of body,\n   results in the execution of just \"clean\", with execution continuing after\n   the catch block.  If \"action\" does not execute a punt(ball), then execution\n   continues after the catch block.  If \"action\" does execute a punt(ball),\n   then what was caught is thrown to the next enclosing try.\n\n   A '} preserve {' must be inserted in body after any local automatic storage\n   variable is changed in body that can be used in the always or catch block.\n   Alternatively, such variables may be declared volatile.  However the use of\n   volatile can limit optimization, and has a tendency to propagate compiler\n   warnings.\n\n\n   Example usage:\n\n    ball_t err;\n    char *temp = NULL;\n    try {\n        ... do something ...\n        if (ret == -1)\n            throw(1, \"bad thing happened to %s\\n\", me);\n        temp = malloc(sizeof(me) + 1);\n    }\n    preserve {\n        if (temp == NULL)\n            throw(2, \"out of memory\");\n        ... do more ...\n        if (ret == -1)\n            throw(3, \"worse thing happened to %s\\n\", temp);\n        ... some more code ...\n    }\n    always {\n        free(temp);\n    }\n    catch (err) {\n        fputs(err.why, stderr);\n        drop(err);\n        return err.code;\n    }\n    ... end up here if nothing bad happened ...\n\n\n   More involved example:\n\n    void check_part(void)\n    {\n        ball_t err;\n\n        try {\n            ...\n            if (part == bad1)\n                throw(1);\n            ...\n            if (part == bad2)\n                throw(1);\n            ...\n        }\n        catch (err) {\n            drop(err);\n            throw(3, \"part was bad\");\n        }\n    }\n\n    void check_input(void)\n    {\n        ...\n        if (input == wrong)\n            throw(4, \"input was wrong\");\n        ...\n        if (input == stupid)\n            throw(5, \"input was stupid\");\n        ...\n        check_part();\n        ...\n    }\n\n    void *build_something(void)\n    {\n        ball_t err;\n        volatile void *thing;\n        try {\n            thing = malloc(sizeof(struct thing));\n            ... build up thing ...\n            check_input();\n            ... finish building it ...\n        }\n        catch (err) {\n            free(thing);\n            punt(err);\n        }\n        return thing;\n    }\n\n    int grand_central(void)\n    {\n        ball_t err;\n        void *thing;\n        try {\n            thing = build_something();\n        }\n        catch (err) {\n            fputs(err.why, stderr);\n            drop(err);\n            return err.code;\n        }\n        ... use thing ...\n        free(thing);\n        return 0;\n    }\n\n */\n\n#ifndef _TRY_H\n#define _TRY_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <setjmp.h>\n\n/* If a POSIX pthread library is not available, then compile with NOTHREAD\n   defined. */\n#ifndef NOTHREAD\n#  include <pthread.h>\n#endif\n\n/* The exposed names can be changed here. */\n#define ball_t try_ball_t_\n#define try TRY_TRY_\n#define preserve TRY_PRESERVE_\n#define always TRY_ALWAYS_\n#define catch TRY_CATCH_\n#define throw TRY_THROW_\n#define punt TRY_PUNT_\n#define drop TRY_DROP_\n\n/* Package of an integer code and any other data to be thrown and caught. Here,\n   why is a string with information to be displayed to indicate why an\n   exception was thrown.  free is true if why was allocated and should be freed\n   when no longer needed.  This structure can be customized as needed, but it\n   must start with an int code.  If it is customized, the try_throw_() function\n   in try.c must also be updated accordingly.  As an example, why could be a\n   structure with information for use in the catch block. */\ntypedef struct {\n    int ret;            /* longjmp() return value */\n    int code;           /* integer code (required) */\n    int free;           /* if true, the message string was allocated */\n    char *why;          /* informational string or NULL */\n} try_ball_t_;\n\n/* Element in the global try stack (a linked list). */\ntypedef struct try_s_ try_t_;\nstruct try_s_ {\n    jmp_buf env;        /* state information for longjmp() to jump back */\n    try_ball_t_ ball;   /* data passed from the throw() */\n    try_t_ *next;       /* link to the next enclosing try_t, or NULL */\n};\n\n/* Global try stack.  try.c must be compiled and linked to provide the stack\n   pointer.  Use thread-local storage if pthread.h is included before this.\n   Note that a throw can only be caught within the same thread.  A new and\n   unique try stack is created for each thread, so any attempt to throw across\n   threads will fail with an assert, by virtue of reaching the end of the\n   stack. */\n#ifdef PTHREAD_ONCE_INIT\n    extern pthread_key_t try_key_;\n    void try_setup_(void);\n#   define try_stack_ ((try_t_ *)pthread_getspecific(try_key_))\n#   define try_stack_set_(next) \\\n        do { \\\n            int ret = pthread_setspecific(try_key_, next); \\\n            assert(ret == 0 && \"try: pthread_setspecific() failed\"); \\\n        } while (0)\n#else /* !PTHREAD_ONCE_INIT */\n    extern try_t_ *try_stack_;\n#   define try_setup_()\n#   define try_stack_set_(next) try_stack_ = (next)\n#endif /* PTHREAD_ONCE_INIT */\n\n/* Try a block.  The block should follow the invocation of try enclosed in { }.\n   The block must be immediately followed by a preserve, always, or catch.  You\n   must not goto or return out of the try block.  A naked break or continue in\n   the try block will go to the end of the block. */\n#define TRY_TRY_ \\\n    do { \\\n        try_t_ try_this_; \\\n        volatile int try_pushed_ = 1; \\\n        try_this_.ball.ret = 0; \\\n        try_this_.ball.code = 0; \\\n        try_this_.ball.free = 0; \\\n        try_this_.ball.why = NULL; \\\n        try_setup_(); \\\n        try_this_.next = try_stack_; \\\n        try_stack_set_(&try_this_); \\\n        if (setjmp(try_this_.env) == 0) \\\n            do { \\\n\n/* Preserve local automatic variables that were changed in the try block by\n   reissuing the setjmp(), replacing the state for the next longjmp().  The\n   preserve block should be enclosed in { }.  The block must be immediately\n   followed by a preserve, always, or catch.  You must not goto or return out\n   of the preserve block.  A naked break or continue in the preserve block will\n   go to the end of the block.  This can only follow a try or another preserve.\n   preserve effectively saves the state of local automatic variables at threat,\n   i.e. the register state, at that point so that a subsequent throw() will\n   restore those variables to that state for the always and catch blocks.\n   Changes to those variables after the preserve statement may or may not be\n   reflected in the always and catch blocks. */\n#define TRY_PRESERVE_ \\\n            } while (0); \\\n        if (try_this_.ball.ret == 0) if (setjmp(try_this_.env) == 0) \\\n            do { \\\n\n/* Execute the code between always and catch, whether or not something was\n   thrown.  An always block is optional.  If present, the always block must\n   follow a try or preserve block and be followed by a catch block.  The always\n   block should be enclosed in { }.  A naked break or continue in the always\n   block will go to the end of the block.  It is permitted to use throw in the\n   always block, which will fall up to the next enclosing try.  However this\n   will result in a memory leak if the original throw() allocated space for the\n   informational string.  So it's best to not throw() in an always block.  Keep\n   the always block simple.\n\n   Great care must be taken if the always block uses an automatic storage\n   variable local to the enclosing function that can be modified in the try\n   block.  Such variables must be declared volatile.  If such a variable is not\n   declared volatile, and if the compiler elects to keep that variable in a\n   register, then the throw will restore that variable to its state at the\n   beginning of the try block, wiping out any change that occurred in the try\n   block.  This can cause very confusing bugs until you remember that you\n   didn't follow this rule. */\n#define TRY_ALWAYS_ \\\n            } while (0); \\\n        if (try_pushed_) { \\\n            try_stack_set_(try_this_.next); \\\n            try_pushed_ = 0; \\\n        } \\\n        if (1) \\\n            do {\n\n/* Catch an error thrown in the preceding try block.  The catch block must\n   follow catch and its parameter, and must be enclosed in { }.  The catch must\n   immediately follow a try, preserve, or always block.  It is permitted to use\n   throw() in the catch block, which will fall up to the next enclosing try.\n   However the ball_t passed by throw() must be freed using drop() before doing\n   another throw, to avoid a potential memory leak. The parameter of catch must\n   be a ball_t declared in the function or block containing the catch.  It is\n   set to the parameters of the throw() that jumped to the catch.  The catch\n   block is not executed if the first parameter of the throw() was zero.\n\n   A catch block should end with either a punt() or a drop().\n\n   Great care must be taken if the catch block uses an automatic storage\n   variable local to the enclosing function that can be modified in the try\n   block.  Such variables must be declared volatile or preserve must be used to\n   save their state.  If such a variable is not declared volatile, and if the\n   compiler elects to keep that variable in a register, then the throw will\n   restore that variable to its state at the beginning of the most recent try\n   or preserve block, wiping out any change that occurred after the start of\n   that block.  This can cause very confusing bugs until you remember that you\n   didn't follow this rule. */\n#define TRY_CATCH_(try_ball_) \\\n            } while (0); \\\n        if (try_pushed_) { \\\n            try_stack_set_(try_this_.next); \\\n            try_pushed_ = 0; \\\n        } \\\n        try_ball_ = try_this_.ball; \\\n    } while (0); \\\n    if (try_ball_.code)\n\n/* Throw an error.  This can be in the try block or in any function called from\n   the try block, at any level of nesting.  This will fall back to the end of\n   the first enclosing try block in the same thread, invoking the associated\n   catch block with a ball_t set to the arguments of throw().  throw() will\n   abort the program with an assert() if there is no nesting try.  Make sure\n   that there's a nesting try!\n\n   try may have one or more arguments, where the first argument is an int, the\n   optional second argument is a string, and the remaining optional arguments\n   are referred to by printf() formatting commands in the string.  If there are\n   formatting commands in the string, i.e. any percent (%) signs, then\n   vsnprintf() is used to generate the formatted string from the arguments\n   before jumping to the enclosing try block.  This allows throw() to use\n   information on the stack in the scope of the throw() statement, which will\n   be lost after jumping back to the enclosing try block.  That formatted\n   string will use allocated memory, which is why it is important to use drop()\n   in catch blocks to free that memory, or punt() to pass the string on to\n   another catch block.  Eventually some catch block down the chain will have\n   to drop() it.\n\n   If a memory allocation fails during the execution of a throw(), then the\n   string provided to the catch block is not the formatted string at all, but\n   rather the string: \"try: out of memory\", with the integer code from the\n   throw() unchanged.\n\n   If the first argument of throw is zero, then the catch block is not\n   executed.  A throw(0) from a function called in the try block is equivalent\n   to a break or continue in the try block.  A throw(0) should not have any\n   other arguments, to avoid a potential memory leak.  There is no opportunity\n   to make use of any arguments after the 0 anyway.\n\n   try.c must be compiled and linked to provide the try_throw_() function. */\nvoid try_throw_(int code, char *fmt, ...)\n#if defined(__GNUC__) || defined(__has_builtin)\n                                                __attribute__((noreturn))\n#endif\n    ;\n\n#define TRY_THROW_(...) try_throw_(__VA_ARGS__, NULL)\n\n/* Punt a caught error on to the next enclosing catcher.  This is normally used\n   in a catch block with same argument as the catch. */\n#define TRY_PUNT_(try_ball_) \\\n    do { \\\n        try_setup_(); \\\n        assert(try_stack_ != NULL && \"try: naked punt\"); \\\n        try_stack_->ball = try_ball_; \\\n        longjmp(try_stack_->env, 1); \\\n    } while (0)\n\n/* Clean up at the end of the line in a catch (no more punts). */\n#define TRY_DROP_(try_ball_) \\\n    do { \\\n        if (try_ball_.free) { \\\n            free(try_ball_.why); \\\n            try_ball_.free = 0; \\\n            try_ball_.why = NULL; \\\n        } \\\n    } while (0)\n\n#endif /* _TRY_H */\n"
        },
        {
          "name": "yarn.c",
          "type": "blob",
          "size": 13.16796875,
          "content": "/* yarn.c -- generic thread operations implemented using pthread functions\n * Copyright (C) 2008, 2011, 2012, 2015, 2018, 2019, 2020 Mark Adler\n * Version 1.7  12 Apr 2020  Mark Adler\n * For conditions of distribution and use, see copyright notice in yarn.h\n */\n\n/* Basic thread operations implemented using the POSIX pthread library.  All\n   pthread references are isolated within this module to allow alternate\n   implementations with other thread libraries.  See yarn.h for the description\n   of these operations. */\n\n/* Version history:\n   1.0    19 Oct 2008  First version\n   1.1    26 Oct 2008  No need to set the stack size -- remove\n                       Add yarn_abort() function for clean-up on error exit\n   1.2    19 Dec 2011  (changes reversed in 1.3)\n   1.3    13 Jan 2012  Add large file #define for consistency with pigz.c\n                       Update thread portability #defines per IEEE 1003.1-2008\n                       Fix documentation in yarn.h for yarn_prefix\n   1.4    19 Jan 2015  Allow yarn_abort() to avoid error message to stderr\n                       Accept and do nothing for NULL argument to free_lock()\n   1.5     8 May 2018  Remove destruct() to avoid use of pthread_cancel()\n                       Normalize the code style\n   1.6     3 Apr 2019  Add debugging information to fail() error messages\n   1.7    12 Apr 2020  Fix use after free bug in ignition()\n */\n\n// For thread portability.\n#define _XOPEN_SOURCE 700\n#define _POSIX_C_SOURCE 200809L\n#define _THREAD_SAFE\n\n// Use large file functions if available.\n#define _FILE_OFFSET_BITS 64\n\n// External libraries and entities referenced.\n#include <stdio.h>      // fprintf(), stderr\n#include <stdlib.h>     // exit(), malloc(), free(), NULL\n#include <pthread.h>    // pthread_t, pthread_create(), pthread_join(),\n    // pthread_attr_t, pthread_attr_init(), pthread_attr_destroy(),\n    // PTHREAD_CREATE_JOINABLE, pthread_attr_setdetachstate(),\n    // pthread_self(), pthread_equal(),\n    // pthread_mutex_t, PTHREAD_MUTEX_INITIALIZER, pthread_mutex_init(),\n    // pthread_mutex_lock(), pthread_mutex_unlock(), pthread_mutex_destroy(),\n    // pthread_cond_t, PTHREAD_COND_INITIALIZER, pthread_cond_init(),\n    // pthread_cond_broadcast(), pthread_cond_wait(), pthread_cond_destroy()\n#include <errno.h>      // EPERM, ESRCH, EDEADLK, ENOMEM, EBUSY, EINVAL, EAGAIN\n\n// Interface definition.\n#include \"yarn.h\"\n\n// Constants.\n#define local static            // for non-exported functions and globals\n\n// Error handling external globals, resettable by application.\nchar *yarn_prefix = \"yarn\";\nvoid (*yarn_abort)(int) = NULL;\n\n\n// Immediately exit -- use for errors that shouldn't ever happen.\nlocal void fail(int err, char const *file, long line, char const *func) {\n    fprintf(stderr, \"%s: \", yarn_prefix);\n    switch (err) {\n        case EPERM:\n            fputs(\"already unlocked\", stderr);\n            break;\n        case ESRCH:\n            fputs(\"no such thread\", stderr);\n            break;\n        case EDEADLK:\n            fputs(\"resource deadlock\", stderr);\n            break;\n        case ENOMEM:\n            fputs(\"out of memory\", stderr);\n            break;\n        case EBUSY:\n            fputs(\"can't destroy locked resource\", stderr);\n            break;\n        case EINVAL:\n            fputs(\"invalid request\", stderr);\n            break;\n        case EAGAIN:\n            fputs(\"resource unavailable\", stderr);\n            break;\n        default:\n            fprintf(stderr, \"internal error %d\", err);\n    }\n    fprintf(stderr, \" (%s:%ld:%s)\\n\", file, line, func);\n    if (yarn_abort != NULL)\n        yarn_abort(err);\n    exit(err);\n}\n\n// Memory handling routines provided by user. If none are provided, malloc()\n// and free() are used, which are therefore assumed to be thread-safe.\ntypedef void *(*malloc_t)(size_t);\ntypedef void (*free_t)(void *);\nlocal malloc_t my_malloc_f = malloc;\nlocal free_t my_free = free;\n\n// Use user-supplied allocation routines instead of malloc() and free().\nvoid yarn_mem(malloc_t lease, free_t vacate) {\n    my_malloc_f = lease;\n    my_free = vacate;\n}\n\n// Memory allocation that cannot fail (from the point of view of the caller).\nlocal void *my_malloc(size_t size, char const *file, long line) {\n    void *block;\n\n    if ((block = my_malloc_f(size)) == NULL)\n        fail(ENOMEM, file, line, \"malloc\");\n    return block;\n}\n\n// -- Lock functions --\n\nstruct lock_s {\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n    long value;\n};\n\nlock *new_lock_(long initial, char const *file, long line) {\n    lock *bolt = my_malloc(sizeof(struct lock_s), file, line);\n    int ret = pthread_mutex_init(&(bolt->mutex), NULL);\n    if (ret)\n        fail(ret, file, line, \"mutex_init\");\n    ret = pthread_cond_init(&(bolt->cond), NULL);\n    if (ret)\n        fail(ret, file, line, \"cond_init\");\n    bolt->value = initial;\n    return bolt;\n}\n\nvoid possess_(lock *bolt, char const *file, long line) {\n    int ret = pthread_mutex_lock(&(bolt->mutex));\n    if (ret)\n        fail(ret, file, line, \"mutex_lock\");\n}\n\nvoid release_(lock *bolt, char const *file, long line) {\n    int ret = pthread_mutex_unlock(&(bolt->mutex));\n    if (ret)\n        fail(ret, file, line, \"mutex_unlock\");\n}\n\nvoid twist_(lock *bolt, enum twist_op op, long val,\n            char const *file, long line) {\n    if (op == TO)\n        bolt->value = val;\n    else if (op == BY)\n        bolt->value += val;\n    int ret = pthread_cond_broadcast(&(bolt->cond));\n    if (ret)\n        fail(ret, file, line, \"cond_broadcast\");\n    ret = pthread_mutex_unlock(&(bolt->mutex));\n    if (ret)\n        fail(ret, file, line, \"mutex_unlock\");\n}\n\n#define until(a) while(!(a))\n\nvoid wait_for_(lock *bolt, enum wait_op op, long val,\n               char const *file, long line) {\n    switch (op) {\n        case TO_BE:\n            until (bolt->value == val) {\n                int ret = pthread_cond_wait(&(bolt->cond), &(bolt->mutex));\n                if (ret)\n                    fail(ret, file, line, \"cond_wait\");\n            }\n            break;\n        case NOT_TO_BE:\n            until (bolt->value != val) {\n                int ret = pthread_cond_wait(&(bolt->cond), &(bolt->mutex));\n                if (ret)\n                    fail(ret, file, line, \"cond_wait\");\n            }\n            break;\n        case TO_BE_MORE_THAN:\n            until (bolt->value > val) {\n                int ret = pthread_cond_wait(&(bolt->cond), &(bolt->mutex));\n                if (ret)\n                    fail(ret, file, line, \"cond_wait\");\n            }\n            break;\n        case TO_BE_LESS_THAN:\n            until (bolt->value < val) {\n                int ret = pthread_cond_wait(&(bolt->cond), &(bolt->mutex));\n                if (ret)\n                    fail(ret, file, line, \"cond_wait\");\n            }\n    }\n}\n\nlong peek_lock(lock *bolt) {\n    return bolt->value;\n}\n\nvoid free_lock_(lock *bolt, char const *file, long line) {\n    if (bolt == NULL)\n        return;\n    int ret = pthread_cond_destroy(&(bolt->cond));\n    if (ret)\n        fail(ret, file, line, \"cond_destroy\");\n    ret = pthread_mutex_destroy(&(bolt->mutex));\n    if (ret)\n        fail(ret, file, line, \"mutex_destroy\");\n    my_free(bolt);\n}\n\n// -- Thread functions (uses the lock functions above) --\n\nstruct thread_s {\n    pthread_t id;\n    int done;                   // true if this thread has exited\n    thread *next;               // for list of all launched threads\n};\n\n// List of threads launched but not joined, count of threads exited but not\n// joined (incremented by ignition() just before exiting).\nlocal lock threads_lock = {\n    PTHREAD_MUTEX_INITIALIZER,\n    PTHREAD_COND_INITIALIZER,\n    0                           // number of threads exited but not joined\n};\nlocal thread *threads = NULL;       // list of extant threads\n\n// Structure in which to pass the probe and its payload to ignition().\nstruct capsule {\n    void (*probe)(void *);\n    void *payload;\n    char const *file;\n    long line;\n};\n\n// Mark the calling thread as done and alert join_all().\nlocal void reenter(void *arg) {\n    struct capsule *capsule = arg;\n\n    // find this thread in the threads list by matching the thread id\n    pthread_t me = pthread_self();\n    possess_(&(threads_lock), capsule->file, capsule->line);\n    thread **prior = &(threads);\n    thread *match;\n    while ((match = *prior) != NULL) {\n        if (pthread_equal(match->id, me))\n            break;\n        prior = &(match->next);\n    }\n    if (match == NULL)\n        fail(ESRCH, capsule->file, capsule->line, \"reenter lost\");\n\n    // mark this thread as done and move it to the head of the list\n    match->done = 1;\n    if (threads != match) {\n        *prior = match->next;\n        match->next = threads;\n        threads = match;\n    }\n\n    // update the count of threads to be joined and alert join_all()\n    twist_(&(threads_lock), BY, +1, capsule->file, capsule->line);\n\n    // free the capsule resource, even if the thread is cancelled (though yarn\n    // doesn't use pthread_cancel() -- you never know)\n    my_free(capsule);\n}\n\n// All threads go through this routine. Just before a thread exits, it marks\n// itself as done in the threads list and alerts join_all() so that the thread\n// resources can be released. Use a cleanup stack so that the marking occurs\n// even if the thread is cancelled.\nlocal void *ignition(void *arg) {\n    struct capsule *capsule = arg;\n\n    // run reenter() before leaving\n    pthread_cleanup_push(reenter, arg);\n\n    // execute the requested function with argument\n    capsule->probe(capsule->payload);\n\n    // mark this thread as done, letting join_all() know, and free capsule\n    pthread_cleanup_pop(1);\n\n    // exit thread\n    return NULL;\n}\n\n// Not all POSIX implementations create threads as joinable by default, so that\n// is made explicit here.\nthread *launch_(void (*probe)(void *), void *payload,\n                char const *file, long line) {\n    // construct the requested call and argument for the ignition() routine\n    // (allocated instead of automatic so that we're sure this will still be\n    // there when ignition() actually starts up -- ignition() will free this\n    // allocation)\n    struct capsule *capsule = my_malloc(sizeof(struct capsule), file, line);\n    capsule->probe = probe;\n    capsule->payload = payload;\n    capsule->file = file;\n    capsule->line = line;\n\n    // assure this thread is in the list before join_all() or ignition() looks\n    // for it\n    possess_(&(threads_lock), file, line);\n\n    // create the thread and call ignition() from that thread\n    thread *th = my_malloc(sizeof(struct thread_s), file, line);\n    pthread_attr_t attr;\n    int ret = pthread_attr_init(&attr);\n    if (ret)\n        fail(ret, file, line, \"attr_init\");\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    if (ret)\n        fail(ret, file, line, \"attr_setdetachstate\");\n    ret = pthread_create(&(th->id), &attr, ignition, capsule);\n    if (ret)\n        fail(ret, file, line, \"create\");\n    ret = pthread_attr_destroy(&attr);\n    if (ret)\n        fail(ret, file, line, \"attr_destroy\");\n\n    // put the thread in the threads list for join_all()\n    th->done = 0;\n    th->next = threads;\n    threads = th;\n    release_(&(threads_lock), file, line);\n    return th;\n}\n\nvoid join_(thread *ally, char const *file, long line) {\n    // wait for thread to exit and return its resources\n    int ret = pthread_join(ally->id, NULL);\n    if (ret)\n        fail(ret, file, line, \"join\");\n\n    // find the thread in the threads list\n    possess_(&(threads_lock), file, line);\n    thread **prior = &(threads);\n    thread *match;\n    while ((match = *prior) != NULL) {\n        if (match == ally)\n            break;\n        prior = &(match->next);\n    }\n    if (match == NULL)\n        fail(ESRCH, file, line, \"join lost\");\n\n    // remove thread from list and update exited count, free thread\n    if (match->done)\n        threads_lock.value--;\n    *prior = match->next;\n    release_(&(threads_lock), file, line);\n    my_free(ally);\n}\n\n// This implementation of join_all() only attempts to join threads that have\n// announced that they have exited (see ignition()). When there are many\n// threads, this is faster than waiting for some random thread to exit while a\n// bunch of other threads have already exited.\nint join_all_(char const *file, long line) {\n    // grab the threads list and initialize the joined count\n    int count = 0;\n    possess_(&(threads_lock), file, line);\n\n    // do until threads list is empty\n    while (threads != NULL) {\n        // wait until at least one thread has reentered\n        wait_for_(&(threads_lock), NOT_TO_BE, 0, file, line);\n\n        // find the first thread marked done (should be at or near the top)\n        thread **prior = &(threads);\n        thread *match;\n        while ((match = *prior) != NULL) {\n            if (match->done)\n                break;\n            prior = &(match->next);\n        }\n        if (match == NULL)\n            fail(ESRCH, file, line, \"join_all lost\");\n\n        // join the thread (will be almost immediate), remove from the threads\n        // list, update the reenter count, and free the thread\n        int ret = pthread_join(match->id, NULL);\n        if (ret)\n            fail(ret, file, line, \"join\");\n        threads_lock.value--;\n        *prior = match->next;\n        my_free(match);\n        count++;\n    }\n\n    // let go of the threads list and return the number of threads joined\n    release_(&(threads_lock), file, line);\n    return count;\n}\n"
        },
        {
          "name": "yarn.h",
          "type": "blob",
          "size": 6.6875,
          "content": "/* yarn.h -- generic interface for thread operations\n * Copyright (C) 2008, 2011, 2012, 2015, 2018, 2019, 2020 Mark Adler\n * Version 1.7  12 Apr 2020  Mark Adler\n */\n\n/*\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler\n  madler@alumni.caltech.edu\n */\n\n/* Basic thread operations\n\n   This interface isolates the local operating system implementation of threads\n   from the application in order to facilitate platform independent use of\n   threads.  All of the implementation details are deliberately hidden.\n\n   Assuming adequate system resources and proper use, none of these functions\n   can fail.  As a result, any errors encountered will cause an exit() to be\n   executed, or the execution of your own optionally-provided abort function.\n\n   These functions allow the simple launching and joining of threads, and the\n   locking of objects and synchronization of changes of objects.  The latter is\n   implemented with a single lock type that contains an integer value.  The\n   value can be ignored for simple exclusive access to an object, or the value\n   can be used to signal and wait for changes to an object.\n\n   -- Arguments --\n\n   thread *thread;          identifier for launched thread, used by join\n   void probe(void *);      pointer to function \"probe\", run when thread starts\n   void *payload;           single argument passed to the probe function\n   lock *lock;              a lock with a value -- used for exclusive access to\n                            an object and to synchronize threads waiting for\n                            changes to an object\n   long val;                value to set lock, increment lock, or wait for\n   int n;                   number of threads joined\n\n   -- Thread functions --\n\n   thread = launch(probe, payload) - launch a thread -- exit via probe() return\n   join(thread) - join a thread and by joining end it, waiting for the thread\n        to exit if it hasn't already -- will free the resources allocated by\n        launch() (don't try to join the same thread more than once)\n   n = join_all() - join all threads launched by launch() that are not joined\n        yet and free the resources allocated by the launches, usually to clean\n        up when the thread processing is done -- join_all() returns an int with\n        the count of the number of threads joined (join_all() should only be\n        called from the main thread, and should only be called after any calls\n        of join() have completed)\n\n   -- Lock functions --\n\n   lock = new_lock(val) - create a new lock with initial value val (lock is\n        created in the released state)\n   possess(lock) - acquire exclusive possession of a lock, waiting if necessary\n   twist(lock, [TO | BY], val) - set lock to or increment lock by val, signal\n        all threads waiting on this lock and then release the lock -- must\n        possess the lock before calling (twist releases, so don't do a\n        release() after a twist() on the same lock)\n   wait_for(lock, [TO_BE | NOT_TO_BE | TO_BE_MORE_THAN | TO_BE_LESS_THAN], val)\n        - wait on lock value to be, not to be, be greater than, or be less than\n        val -- must possess the lock before calling, will possess the lock on\n        return but the lock is released while waiting to permit other threads\n        to use twist() to change the value and signal the change (so make sure\n        that the object is in a usable state when waiting)\n   release(lock) - release a possessed lock (do not try to release a lock that\n        the current thread does not possess)\n   val = peek_lock(lock) - return the value of the lock (assumes that lock is\n        already possessed, no possess or release is done by peek_lock())\n   free_lock(lock) - free the resources allocated by new_lock() (application\n        must assure that the lock is released before calling free_lock())\n\n   -- Memory allocation ---\n\n   yarn_mem(better_malloc, better_free) - set the memory allocation and free\n        routines for use by the yarn routines where the supplied routines have\n        the same interface and operation as malloc() and free(), and may be\n        provided in order to supply thread-safe memory allocation routines or\n        for any other reason -- by default malloc() and free() will be used\n\n   -- Error control --\n\n   yarn_prefix - a char pointer to a string that will be the prefix for any\n        error messages that these routines generate before exiting -- if not\n        changed by the application, \"yarn\" will be used\n   yarn_abort - an external function that will be executed when there is an\n        internal yarn error, due to out of memory or misuse -- this function\n        may exit to abort the application, or if it returns, the yarn error\n        handler will exit (set to NULL by default for no action)\n */\n\nextern char *yarn_prefix;\nextern void (*yarn_abort)(int);\n\nvoid yarn_mem(void *(*)(size_t), void (*)(void *));\n\ntypedef struct thread_s thread;\nthread *launch_(void (*)(void *), void *, char const *, long);\n#define launch(a, b) launch_(a, b, __FILE__, __LINE__)\nvoid join_(thread *, char const *, long);\n#define join(a) join_(a, __FILE__, __LINE__)\nint join_all_(char const *, long);\n#define join_all() join_all_(__FILE__, __LINE__)\n\ntypedef struct lock_s lock;\nlock *new_lock_(long, char const *, long);\n#define new_lock(a) new_lock_(a, __FILE__, __LINE__)\nvoid possess_(lock *, char const *, long);\n#define possess(a) possess_(a, __FILE__, __LINE__)\nvoid release_(lock *, char const *, long);\n#define release(a) release_(a, __FILE__, __LINE__)\nenum twist_op { TO, BY };\nvoid twist_(lock *, enum twist_op, long, char const *, long);\n#define twist(a, b, c) twist_(a, b, c, __FILE__, __LINE__)\nenum wait_op {\n    TO_BE, /* or */ NOT_TO_BE, /* that is the question */\n    TO_BE_MORE_THAN, TO_BE_LESS_THAN };\nvoid wait_for_(lock *, enum wait_op, long, char const *, long);\n#define wait_for(a, b, c) wait_for_(a, b, c, __FILE__, __LINE__)\nlong peek_lock(lock *);\nvoid free_lock_(lock *, char const *, long);\n#define free_lock(a) free_lock_(a, __FILE__, __LINE__)\n"
        },
        {
          "name": "zopfli",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}