{
  "metadata": {
    "timestamp": 1736710145084,
    "page": 800,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "FlyGoat/RyzenAdj",
      "stars": 1766,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.71875,
          "content": "CMakeCache.txt\nCMakeFiles\nCMakeScripts\nTesting\nMakefile\ncmake_install.cmake\ninstall_manifest.txt\ncompile_commands.json\nCTestTestfile.cmake\nbuild/\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n# ASP.NET Core default setup: bower directory is configured as wwwroot/lib/ and bower restore is true\n**/wwwroot/lib/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- Backup*.rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# End of https://www.gitignore.io/api/visualstudio\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.4931640625,
          "content": "#cmake version\nCMAKE_MINIMUM_REQUIRED(VERSION 3.9)\n\n#define project name\nPROJECT(ryzenadj)\n\nset(CMAKE_C_VISIBILITY_PRESET hidden)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_VISIBILITY_PRESET hidden)\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\n\n#Enable LTO\ninclude(CheckIPOSupported)\ncheck_ipo_supported(RESULT supported OUTPUT error)\nif( supported )\n    message(STATUS \"IPO / LTO enabled\")\n    set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)\nendif()\n\nINCLUDE_DIRECTORIES(${INC_DIR})\n\nAUX_SOURCE_DIRECTORY(./ SRC_DIR)\n\nif(WIN32)\nset(OS_SOURCE lib/osdep_win32.cpp)\nset(OS_LINK_LIBRARY WinRing0x64)\nset(OS_LINK_DIR ./win32)\nelse()\nset(OS_SOURCE lib/osdep_linux.c)\n#if (CMAKE_BUILD_TYPE STREQUAL \"Release\")\n#Static link libpci in release build\n#set(OS_LINK_LIBRARY libpci.a)\n#else()\nset(OS_LINK_LIBRARY pci)\n#endif()\nendif()\n\nLINK_DIRECTORIES(${OS_LINK_DIR})\n\nset(COMMON_SOURCES lib/nb_smu_ops.c lib/api.c lib/cpuid.c)\nadd_definitions(-D_LIBRYZENADJ_INTERNAL)\n\nADD_EXECUTABLE(${PROJECT_NAME} ${OS_SOURCE} ${COMMON_SOURCES} argparse.c main.c)\ntarget_link_libraries(${PROJECT_NAME} ${OS_LINK_LIBRARY})\n#SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE C)\noption(BUILD_SHARED_LIBS \"Build using shared libraries\" ON)\nADD_LIBRARY (libryzenadj ${OS_SOURCE} ${COMMON_SOURCES})\nset_target_properties(libryzenadj PROPERTIES PREFIX \"\")\ntarget_link_libraries(libryzenadj ${OS_LINK_LIBRARY})\n#SET_TARGET_PROPERTIES(libryzenadj PROPERTIES LINKER_LANGUAGE C)\ninstall(TARGETS ${PROJECT_NAME} DESTINATION ${CMAKE_INSTALL_BINDIR})\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 7.47265625,
          "content": "                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.388671875,
          "content": "# RyzenAdj\nAdjust power management settings for Ryzen Mobile Processors.\n\n[![Build Status](https://travis-ci.org/FlyGoat/RyzenAdj.svg?branch=master)](https://travis-ci.org/FlyGoat/RyzenAdj)\n\nBased on: [FlyGoat/ryzen_nb_smu](https://github.com/flygoat/ryzen_nb_smu)\n\nRyzenAdjUI_WPF by \"JustSkill\" is no longer maintained, for GUI please see  [Universal x86 Tuning Utility](https://github.com/JamesCJ60/Universal-x86-Tuning-Utility) or [ryzen-controller-team/ryzen-controller](https://gitlab.com/ryzen-controller-team/ryzen-controller/).\n\n## Usage\nThe command line interface is identical on both Windows and Unix-Like OS.\n\nYou should run it with Administrator on Windows or root on Linux.\n\nYou can write a shell script or bat to do it automatically.\n\n```\n$./ryzenadj -h\nUsage: ryzenadj [options]\n\n Ryzen Power Management adjust tool.\n\n    -h, --help                            show this help message and exit\n\nOptions\n    -i, --info                            Show information and most important power metrics after adjustment\n    --dump-table                          Show whole power metric table before and after adjustment\n\nSettings\n    -a, --stapm-limit=<u32>               Sustained Power Limit         - STAPM LIMIT (mW)\n    -b, --fast-limit=<u32>                Actual Power Limit            - PPT LIMIT FAST (mW)\n    -c, --slow-limit=<u32>                Average Power Limit           - PPT LIMIT SLOW (mW)\n    -d, --slow-time=<u32>                 Slow PPT Constant Time (s)\n    -e, --stapm-time=<u32>                STAPM constant time (s)\n    -f, --tctl-temp=<u32>                 Tctl Temperature Limit (degree C)\n    -g, --vrm-current=<u32>               VRM Current Limit             - TDC LIMIT VDD (mA)\n    -j, --vrmsoc-current=<u32>            VRM SoC Current Limit         - TDC LIMIT SoC (mA)\n    -k, --vrmmax-current=<u32>            VRM Maximum Current Limit     - EDC LIMIT VDD (mA)\n    -l, --vrmsocmax-current=<u32>         VRM SoC Maximum Current Limit - EDC LIMIT SoC (mA)\n    -m, --psi0-current=<u32>              PSI0 VDD Current Limit (mA)\n    -n, --psi0soc-current=<u32>           PSI0 SoC Current Limit (mA)\n    -o, --max-socclk-frequency=<u32>      Maximum SoC Clock Frequency (MHz)\n    -p, --min-socclk-frequency=<u32>      Minimum SoC Clock Frequency (MHz)\n    -q, --max-fclk-frequency=<u32>        Maximum Transmission (CPU-GPU) Frequency (MHz)\n    -r, --min-fclk-frequency=<u32>        Minimum Transmission (CPU-GPU) Frequency (MHz)\n    -s, --max-vcn=<u32>                   Maximum Video Core Next (VCE - Video Coding Engine) (MHz)\n    -t, --min-vcn=<u32>                   Minimum Video Core Next (VCE - Video Coding Engine) (MHz)\n    -u, --max-lclk=<u32>                  Maximum Data Launch Clock (MHz)\n    -v, --min-lclk=<u32>                  Minimum Data Launch Clock (MHz)\n    -w, --max-gfxclk=<u32>                Maximum GFX Clock (MHz)\n    -x, --min-gfxclk=<u32>                Minimum GFX Clock (MHz)\n    -y, --prochot-deassertion-ramp=<u32>  Ramp Time After Prochot is Deasserted: limit power based on value, higher values does apply tighter limits after prochot is over\n    --apu-skin-temp=<u32>                 APU Skin Temperature Limit    - STT LIMIT APU (degree C)\n    --dgpu-skin-temp=<u32>                dGPU Skin Temperature Limit   - STT LIMIT dGPU (degree C)\n    --apu-slow-limit=<u32>                APU PPT Slow Power limit for A+A dGPU platform - PPT LIMIT APU (mW)\n    --skin-temp-limit=<u32>               Skin Temperature Power Limit (mW)\n    --power-saving                        Hidden options to improve power efficiency (is set when AC unplugged): behavior depends on CPU generation, Device and Manufacture\n    --max-performance                     Hidden options to improve performance (is set when AC plugged in): behavior depends on CPU generation, Device and Manufacture\n```\n\n### Demo\nIf I'm going to set all the Power Limit to 45W, and Tctl to 90 Â°C,\nthen the command line should be:\n\n    ./ryzenadj --stapm-limit=45000 --fast-limit=45000 --slow-limit=45000 --tctl-temp=90\n\n### Documentation\n- [Supported Models](https://github.com/FlyGoat/RyzenAdj/wiki/Supported-Models)\n- [Renoir Tuning Guide](https://github.com/FlyGoat/RyzenAdj/wiki/Renoir-Tuning-Guide)\n- [Options](https://github.com/FlyGoat/RyzenAdj/wiki/Options)\n- [FAQ](https://github.com/FlyGoat/RyzenAdj/wiki/FAQ)\n\n## Installation\n\nYou don't need to install RyzenAdj because it does not need configuration, everything is set via arguments\nHowever, some settings could get overwritten by power management features of your device, and you need to regularly set your values again.\n\nWe did provide some examples for automation. And these require configuration during installation.\n\n### Linux Installation\n\nBecause it is very easy to build the latest version of RyzenAdj on Linux, we don't provide precompiled packages for distributions.\nJust follow the build instructions below and you are ready to use it.\n\n### Windows Installation\n\nBefore you start installing anything, it is highly recommended getting familiar with RyzenAdj to find out what can be done on your device.\nUse the CLI `ryzenadj.exe` to test the support of your device and to benchmark the effects of each setting.\nIf your values don't stay persistent you may want to consider installing our example script for automation.\n\n1. Prepare your favorite RyzenAdj arguments\n1. Copy the content of your RyzenAdj folder to the final destination\n1. Put your configuration into `readjustService.ps1` and test it as administrator until everything works as expected\n1. Install `readjustService.ps1` as Task for Windows Task Scheduler by running `installServiceTask.bat`\n\nDeinstallation of the Task can be done via `uninstallServiceTask.bat`\n\nOver Windows Task Scheduler you can check if it is running. It is called `RyzenAdj` below `AMD` folder.\nOr just run\n\n    SCHTASKS /query /TN \"AMD\\RyzenAdj\"\n\n## Build\n\n### Build Requirements\n\nBuilding this tool requires C & C++ compilers as well as **cmake**. It\nrequires privileged access to NB PCI config space, in order to compile it\none must have pcilib library & headers available.\n\n### Linux\n\nPlease make sure that you have libpci dependency before compiling. On\nDebian-based distros this is covered by installing **pcilib-dev** package:\n\n    sudo apt install build-essential cmake libpci-dev\n\nOn Fedora:\n\n    sudo dnf install cmake gcc-c++ pciutils-devel\n\nOn Arch:\n\n    sudo pacman -S base-devel pciutils cmake\n\nIf your Distribution is not supported, try finding the packages or use [Distrobox](https://github.com/89luca89/distrobox) or [Toolbox](https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/) instead.\n\nThe simplest way to build it:\n\n    git clone https://github.com/FlyGoat/RyzenAdj.git\n    cd RyzenAdj\n    rm -r win32\n    mkdir build && cd build\n    cmake -DCMAKE_BUILD_TYPE=Release ..\n    make\n    if [ -d ~/.local/bin ]; then ln -s ryzenadj ~/.local/bin/ryzenadj && echo \"symlinked to ~/.local/bin/ryzenadj\"; fi\n    if [ -d ~/.bin ]; then ln -s ryzenadj ~/.bin/ryzenadj && echo \"symlinked to ~/.bin/ryzenadj\"; fi\n\n### Windows\n\nIt can be built by Visual Studio + MSVC automaticaly, or Clang + Nmake in command line.\nHowever, as for now, MingW-gcc can't be used to compile for some reason.\n\nRequired dll is included in ./win32 of source tree. Please put the dll\nlibrary and sys driver in the same folder with ryzenadj.exe.\n\nWe don't recommend you to build by yourself on Windows since the environment configuarion\nis very complicated. If you would like to use ryzenadj functions in your program, see libryzenadj.\n"
        },
        {
          "name": "argparse.c",
          "type": "blob",
          "size": 10.0234375,
          "content": "/**\n * Copyright (C) 2012-2015 Yecheng Fu <cofyc.jackson at gmail dot com>\n * All rights reserved.\n *\n * Use of this source code is governed by a MIT-style license that can be found\n * in the LICENSE file.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include \"argparse.h\"\n\n#define OPT_UNSET 1\n#define OPT_LONG  (1 << 1)\n\nstatic const char *\nprefix_skip(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\nstatic int\nprefix_cmp(const char *str, const char *prefix)\n{\n\tfor (;; str++, prefix++)\n\t\tif (!*prefix) {\n\t\t\treturn 0;\n\t\t} else if (*str != *prefix) {\n\t\t\treturn (unsigned char)*prefix - (unsigned char)*str;\n\t\t}\n}\n\nstatic void\nargparse_error(struct argparse *self, const struct argparse_option *opt,\n\t\t\t   const char *reason, int flags)\n{\n\t(void)self;\n\tif (flags & OPT_LONG) {\n\t\tfprintf(stderr, \"error: option `--%s` %s\\n\", opt->long_name, reason);\n\t} else {\n\t\tfprintf(stderr, \"error: option `-%c` %s\\n\", opt->short_name, reason);\n\t}\n\texit(1);\n}\n\nstatic int\nargparse_getvalue(struct argparse *self, const struct argparse_option *opt,\n\t\t\t\t  int flags)\n{\n\tconst char *s = NULL;\n\tchar buf[256];\n\tbuf[0] = 0;\n\tchar *pbuf = buf;\n\n\tif (!opt->value)\n\t\tgoto skipped;\n\tswitch (opt->type) {\n\tcase ARGPARSE_OPT_BOOLEAN:\n\t\tif (flags & OPT_UNSET) {\n\t\t\t*(int *)opt->value = *(int *)opt->value - 1;\n\t\t} else {\n\t\t\t*(int *)opt->value = *(int *)opt->value + 1;\n\t\t}\n\t\tif (*(int *)opt->value < 0) {\n\t\t\t*(int *)opt->value = 0;\n\t\t}\n\t\tbreak;\n\tcase ARGPARSE_OPT_BIT:\n\t\tif (flags & OPT_UNSET) {\n\t\t\t*(int *)opt->value &= ~opt->data;\n\t\t} else {\n\t\t\t*(int *)opt->value |= opt->data;\n\t\t}\n\t\tbreak;\n\tcase ARGPARSE_OPT_STRING:\n\t\tif (self->optvalue) {\n\t\t\t*(const char **)opt->value = self->optvalue;\n\t\t\tself->optvalue             = NULL;\n\t\t} else if (self->argc > 1) {\n\t\t\tself->argc--;\n\t\t\t*(const char **)opt->value = *++self->argv;\n\t\t} else {\n\t\t\targparse_error(self, opt, \"requires a value\", flags);\n\t\t}\n\t\tbreak;\n\tcase ARGPARSE_OPT_INTEGER:\n\t\terrno = 0;\n\t\tif (self->optvalue) {\n\t\t\t*(int *)opt->value = strtol(self->optvalue, (char **)&s, 0);\n\t\t\tself->optvalue     = NULL;\n\t\t} else if (self->argc > 1) {\n\t\t\tself->argc--;\n\t\t\t*(int *)opt->value = strtol(*++self->argv, (char **)&s, 0);\n\t\t} else {\n\t\t\targparse_error(self, opt, \"requires a value\", flags);\n\t\t}\n\t\tif (errno){\n\t\t\t#ifdef _WIN32\n\t\t\tstrerror_s(buf, sizeof(buf), errno);\n\t\t\t#else\n\t\t\tstrerror_r(errno, buf, sizeof(buf));\n\t\t\t#endif\n\t\t\targparse_error(self, opt, pbuf, flags);\n\t\t}\n\t\tif (s[0] != '\\0')\n\t\t\targparse_error(self, opt, \"expects an integer value\", flags);\n\t\tbreak;\n\tcase ARGPARSE_OPT_U32:\n\t\terrno = 0;\n\t\tif (self->optvalue) {\n\t\t\t*(uint32_t *)opt->value = strtoul(self->optvalue, (char **)&s, 0);\n\t\t\tself->optvalue     = NULL;\n\t\t} else if (self->argc > 1) {\n\t\t\tself->argc--;\n\t\t\t*(uint32_t *)opt->value = strtoul(*++self->argv, (char **)&s, 0);\n\t\t} else {\n\t\t\targparse_error(self, opt, \"requires a value\", flags);\n\t\t}\n\t\tif (errno){\n\t\t\t#ifdef _WIN32\n\t\t\tstrerror_s(buf, sizeof(buf), errno);\n\t\t\t#else\n\t\t\tstrerror_r(errno, buf, sizeof(buf));\n\t\t\t#endif\n\t\t\targparse_error(self, opt, pbuf, flags);\n\t\t}\n\t\tif (s[0] != '\\0')\n\t\t\targparse_error(self, opt, \"expects an unsigned 32-bit integer value\", flags);\n\t\tbreak;\n\tcase ARGPARSE_OPT_FLOAT:\n\t\terrno = 0;\n\t\tif (self->optvalue) {\n\t\t\t*(float *)opt->value = strtof(self->optvalue, (char **)&s);\n\t\t\tself->optvalue       = NULL;\n\t\t} else if (self->argc > 1) {\n\t\t\tself->argc--;\n\t\t\t*(float *)opt->value = strtof(*++self->argv, (char **)&s);\n\t\t} else {\n\t\t\targparse_error(self, opt, \"requires a value\", flags);\n\t\t}\n\t\tif (errno){\n\t\t\t#ifdef _WIN32\n\t\t\tstrerror_s(buf, sizeof(buf), errno);\n\t\t\t#else\n\t\t\tstrerror_r(errno, buf, sizeof(buf));\n\t\t\t#endif\n\t\t\targparse_error(self, opt, pbuf, flags);\n\t\t}\n\t\tif (s[0] != '\\0')\n\t\t\targparse_error(self, opt, \"expects a numerical value\", flags);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\nskipped:\n\tif (opt->callback) {\n\t\treturn opt->callback(self, opt);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nargparse_options_check(const struct argparse_option *options)\n{\n\tfor (; options->type != ARGPARSE_OPT_END; options++) {\n\t\tswitch (options->type) {\n\t\tcase ARGPARSE_OPT_END:\n\t\tcase ARGPARSE_OPT_BOOLEAN:\n\t\tcase ARGPARSE_OPT_BIT:\n\t\tcase ARGPARSE_OPT_INTEGER:\n\t\tcase ARGPARSE_OPT_U32:\n\t\tcase ARGPARSE_OPT_FLOAT:\n\t\tcase ARGPARSE_OPT_STRING:\n\t\tcase ARGPARSE_OPT_GROUP:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"wrong option type: %d\", options->type);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nargparse_short_opt(struct argparse *self, const struct argparse_option *options)\n{\n\tfor (; options->type != ARGPARSE_OPT_END; options++) {\n\t\tif (options->short_name == *self->optvalue) {\n\t\t\tself->optvalue = self->optvalue[1] ? self->optvalue + 1 : NULL;\n\t\t\treturn argparse_getvalue(self, options, 0);\n\t\t}\n\t}\n\treturn -2;\n}\n\nstatic int\nargparse_long_opt(struct argparse *self, const struct argparse_option *options)\n{\n\tfor (; options->type != ARGPARSE_OPT_END; options++) {\n\t\tconst char *rest;\n\t\tint opt_flags = 0;\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\n\t\trest = prefix_skip(self->argv[0] + 2, options->long_name);\n\t\tif (!rest) {\n\t\t\t// negation disabled?\n\t\t\tif (options->flags & OPT_NONEG) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// only OPT_BOOLEAN/OPT_BIT supports negation\n\t\t\tif (options->type != ARGPARSE_OPT_BOOLEAN && options->type !=\n\t\t\t\tARGPARSE_OPT_BIT) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prefix_cmp(self->argv[0] + 2, \"no-\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trest = prefix_skip(self->argv[0] + 2 + 3, options->long_name);\n\t\t\tif (!rest)\n\t\t\t\tcontinue;\n\t\t\topt_flags |= OPT_UNSET;\n\t\t}\n\t\tif (*rest) {\n\t\t\tif (*rest != '=')\n\t\t\t\tcontinue;\n\t\t\tself->optvalue = rest + 1;\n\t\t}\n\t\treturn argparse_getvalue(self, options, opt_flags | OPT_LONG);\n\t}\n\treturn -2;\n}\n\nint\nargparse_init(struct argparse *self, struct argparse_option *options,\n\t\t\t  const char *const *usages, int flags)\n{\n\tmemset(self, 0, sizeof(*self));\n\tself->options     = options;\n\tself->usages      = usages;\n\tself->flags       = flags;\n\tself->description = NULL;\n\tself->epilog      = NULL;\n\treturn 0;\n}\n\nvoid\nargparse_describe(struct argparse *self, const char *description,\n\t\t\t\t  const char *epilog)\n{\n\tself->description = description;\n\tself->epilog      = epilog;\n}\n\nint\nargparse_parse(struct argparse *self, int argc, const char **argv)\n{\n\tself->argc = argc - 1;\n\tself->argv = argv + 1;\n\tself->out  = argv;\n\n\targparse_options_check(self->options);\n\tif(!self->argc) {\n\t\targparse_usage(self);\n\t\texit(1);\n\t}\n\n\tfor (; self->argc; self->argc--, self->argv++) {\n\t\tconst char *arg = self->argv[0];\n\t\tif (arg[0] != '-' || !arg[1]) {\n\t\t\tif (self->flags & ARGPARSE_STOP_AT_NON_OPTION) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (self->flags & ARGPARSE_NON_OPTION_IS_INVALID) {\n\t\t\t\tgoto unknown;\n\t\t\t}\n\t\t\t// if it's not option or is a single char '-', copy verbatim\n\t\t\tself->out[self->cpidx++] = self->argv[0];\n\t\t\tcontinue;\n\t\t}\n\t\t// short option\n\t\tif (arg[1] != '-') {\n\t\t\tself->optvalue = arg + 1;\n\t\t\tswitch (argparse_short_opt(self, self->options)) {\n\t\t\tcase -1:\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\tgoto unknown;\n\t\t\t}\n\t\t\twhile (self->optvalue) {\n\t\t\t\tswitch (argparse_short_opt(self, self->options)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tgoto unknown;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t// if '--' presents\n\t\tif (!arg[2]) {\n\t\t\tself->argc--;\n\t\t\tself->argv++;\n\t\t\tbreak;\n\t\t}\n\t\t// long option\n\t\tswitch (argparse_long_opt(self, self->options)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase -2:\n\t\t\tgoto unknown;\n\t\t}\n\t\tcontinue;\n\nunknown:\n\t\tfprintf(stderr, \"error: unknown option `%s`\\n\", self->argv[0]);\n\t\targparse_usage(self);\n\t\texit(1);\n\t}\n\nend:\n\tmemmove(self->out + self->cpidx, self->argv,\n\t\t\tself->argc * sizeof(*self->out));\n\tself->out[self->cpidx + self->argc] = NULL;\n\n\treturn self->cpidx + self->argc;\n}\n\nvoid\nargparse_usage(struct argparse *self)\n{\n\tif (self->usages) {\n\t\tfprintf(stdout, \"Usage: %s\\n\", *self->usages++);\n\t\twhile (*self->usages && **self->usages)\n\t\t\tfprintf(stdout, \"   or: %s\\n\", *self->usages++);\n\t} else {\n\t\tfprintf(stdout, \"Usage:\\n\");\n\t}\n\n\t// print description\n\tif (self->description)\n\t\tfprintf(stdout, \"%s\\n\", self->description);\n\n\tfputc('\\n', stdout);\n\n\tconst struct argparse_option *options;\n\n\t// figure out best width\n\tsize_t usage_opts_width = 0;\n\tsize_t len;\n\toptions = self->options;\n\tfor (; options->type != ARGPARSE_OPT_END; options++) {\n\t\tlen = 0;\n\t\tif ((options)->short_name) {\n\t\t\tlen += 2;\n\t\t}\n\t\tif ((options)->short_name && (options)->long_name) {\n\t\t\tlen += 2;           // separator \", \"\n\t\t}\n\t\tif ((options)->long_name) {\n\t\t\tlen += strlen((options)->long_name) + 2;\n\t\t}\n\t\tif (options->type == ARGPARSE_OPT_INTEGER) {\n\t\t\tlen += strlen(\"=<int>\");\n\t\t}\n\t\tif (options->type == ARGPARSE_OPT_U32) {\n\t\t\tlen += strlen(\"=<u32>\");\n\t\t}\n\t\tif (options->type == ARGPARSE_OPT_FLOAT) {\n\t\t\tlen += strlen(\"=<flt>\");\n\t\t} else if (options->type == ARGPARSE_OPT_STRING) {\n\t\t\tlen += strlen(\"=<str>\");\n\t\t}\n\t\tlen = (len + 3) - ((len + 3) & 3);\n\t\tif (usage_opts_width < len) {\n\t\t\tusage_opts_width = len;\n\t\t}\n\t}\n\tusage_opts_width += 4;      // 4 spaces prefix\n\n\toptions = self->options;\n\tfor (; options->type != ARGPARSE_OPT_END; options++) {\n\t\tsize_t pos = 0;\n\t\tsize_t pad = 0;\n\t\tif (options->type == ARGPARSE_OPT_GROUP) {\n\t\t\tfputc('\\n', stdout);\n\t\t\tfprintf(stdout, \"%s\", options->help);\n\t\t\tfputc('\\n', stdout);\n\t\t\tcontinue;\n\t\t}\n\t\tpos = fprintf(stdout, \"    \");\n\t\tif (options->short_name) {\n\t\t\tpos += fprintf(stdout, \"-%c\", options->short_name);\n\t\t}\n\t\tif (options->long_name && options->short_name) {\n\t\t\tpos += fprintf(stdout, \", \");\n\t\t}\n\t\tif (options->long_name) {\n\t\t\tpos += fprintf(stdout, \"--%s\", options->long_name);\n\t\t}\n\t\tif (options->type == ARGPARSE_OPT_INTEGER) {\n\t\t\tpos += fprintf(stdout, \"=<int>\");\n\t\t} else if (options->type == ARGPARSE_OPT_U32) {\n\t\t\tpos += fprintf(stdout, \"=<u32>\");\n\t\t} else if (options->type == ARGPARSE_OPT_FLOAT) {\n\t\t\tpos += fprintf(stdout, \"=<flt>\");\n\t\t} else if (options->type == ARGPARSE_OPT_STRING) {\n\t\t\tpos += fprintf(stdout, \"=<str>\");\n\t\t}\n\t\tif (pos <= usage_opts_width) {\n\t\t\tpad = usage_opts_width - pos;\n\t\t} else {\n\t\t\tfputc('\\n', stdout);\n\t\t\tpad = usage_opts_width;\n\t\t}\n\t\tfprintf(stdout, \"%*s%s\\n\", (int)pad + 2, \"\", options->help);\n\t}\n\n\t// print epilog\n\tif (self->epilog)\n\t\tfprintf(stdout, \"%s\\n\", self->epilog);\n}\n\nint\nargparse_help_cb(struct argparse *self, const struct argparse_option *option)\n{\n\t(void)option;\n\targparse_usage(self);\n\texit(0);\n}\n"
        },
        {
          "name": "argparse.h",
          "type": "blob",
          "size": 3.375,
          "content": "/**\n * Copyright (C) 2012-2015 Yecheng Fu <cofyc.jackson at gmail dot com>\n * All rights reserved.\n *\n * Use of this source code is governed by a MIT-style license that can be found\n * in the LICENSE file.\n */\n#ifndef ARGPARSE_H\n#define ARGPARSE_H\n\n/* For c++ compatibility */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n\nstruct argparse;\nstruct argparse_option;\n\ntypedef int argparse_callback (struct argparse *self,\n\t\t\t\t\t\t\t   const struct argparse_option *option);\n\nenum argparse_flag {\n\tARGPARSE_STOP_AT_NON_OPTION = 1,\n\tARGPARSE_NON_OPTION_IS_INVALID = 2,\n};\n\nenum argparse_option_type {\n\t/* special */\n\tARGPARSE_OPT_END,\n\tARGPARSE_OPT_GROUP,\n\t/* options with no arguments */\n\tARGPARSE_OPT_BOOLEAN,\n\tARGPARSE_OPT_BIT,\n\t/* options with arguments (optional or required) */\n\tARGPARSE_OPT_INTEGER,\n\tARGPARSE_OPT_U32,\n\tARGPARSE_OPT_FLOAT,\n\tARGPARSE_OPT_STRING,\n};\n\nenum argparse_option_flags {\n\tOPT_NONEG = 1,              /* disable negation */\n};\n\n/**\n *  argparse option\n *\n *  `type`:\n *    holds the type of the option, you must have an ARGPARSE_OPT_END last in your\n *    array.\n *\n *  `short_name`:\n *    the character to use as a short option name, '\\0' if none.\n *\n *  `long_name`:\n *    the long option name, without the leading dash, NULL if none.\n *\n *  `value`:\n *    stores pointer to the value to be filled.\n *\n *  `help`:\n *    the short help message associated to what the option does.\n *    Must never be NULL (except for ARGPARSE_OPT_END).\n *\n *  `callback`:\n *    function is called when corresponding argument is parsed.\n *\n *  `data`:\n *    associated data. Callbacks can use it like they want.\n *\n *  `flags`:\n *    option flags.\n */\nstruct argparse_option {\n\tenum argparse_option_type type;\n\tconst char short_name;\n\tconst char *long_name;\n\tvoid *value;\n\tconst char *help;\n\targparse_callback *callback;\n\tintptr_t data;\n\tint flags;\n};\n\n/**\n * argpparse\n */\nstruct argparse {\n\t// user supplied\n\tconst struct argparse_option *options;\n\tconst char *const *usages;\n\tint flags;\n\tconst char *description;    // a description after usage\n\tconst char *epilog;         // a description at the end\n\t// internal context\n\tint argc;\n\tconst char **argv;\n\tconst char **out;\n\tint cpidx;\n\tconst char *optvalue;       // current option value\n};\n\n// built-in callbacks\nint argparse_help_cb(struct argparse *self,\n\t\t\t\t\t const struct argparse_option *option);\n\n// built-in option macros\n#define OPT_END()        { ARGPARSE_OPT_END, 0, NULL, NULL, 0, NULL, 0, 0 }\n#define OPT_BOOLEAN(...) { ARGPARSE_OPT_BOOLEAN, __VA_ARGS__ }\n#define OPT_BIT(...)     { ARGPARSE_OPT_BIT, __VA_ARGS__ }\n#define OPT_INTEGER(...) { ARGPARSE_OPT_INTEGER, __VA_ARGS__ }\n#define OPT_U32(...) { ARGPARSE_OPT_U32, __VA_ARGS__ }\n#define OPT_FLOAT(...)   { ARGPARSE_OPT_FLOAT, __VA_ARGS__ }\n#define OPT_STRING(...)  { ARGPARSE_OPT_STRING, __VA_ARGS__ }\n#define OPT_GROUP(h)     { ARGPARSE_OPT_GROUP, 0, NULL, NULL, h, NULL, 0, 0 }\n#define OPT_HELP()       OPT_BOOLEAN('h', \"help\", NULL,                 \\\n\t\t\t\t\t\t\t\t\t \"show this help message and exit\", \\\n\t\t\t\t\t\t\t\t\t argparse_help_cb, 0, OPT_NONEG)\n\nint argparse_init(struct argparse *self, struct argparse_option *options,\n\t\t\t\t  const char *const *usages, int flags);\nvoid argparse_describe(struct argparse *self, const char *description,\n\t\t\t\t\t   const char *epilog);\nint argparse_parse(struct argparse *self, int argc, const char **argv);\nvoid argparse_usage(struct argparse *self);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 16.1953125,
          "content": "// SPDX-License-Identifier: GPL-2.0\n/* Copyright (C) 2018-2019 Jiaxun Yang <jiaxun.yang@flygoat.com> */\n/* Ryzen NB SMU Service Request Tool */\n\n#include <string.h>\n#include \"lib/ryzenadj.h\"\n#include \"argparse.h\"\n\n#define STRINGIFY2(X) #X\n#define STRINGIFY(X) STRINGIFY2(X)\n\n#define _do_adjust(ARG) \\\ndo {                                                                              \\\n\t/* ignore max unsigned integer values */                                      \\\n\tif (ARG != -1) {                                                              \\\n\t\tint adjerr = set_##ARG(ry, ARG);                                          \\\n\t\tif (!adjerr){                                                             \\\n\t\t\tany_adjust_applied = 1;                                               \\\n\t\t\tprintf(\"Sucessfully set \" STRINGIFY(ARG) \" to %u\\n\", ARG);            \\\n\t\t} else if (adjerr == ADJ_ERR_FAM_UNSUPPORTED) {                           \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is not supported on this family\\n\");   \\\n\t\t\terr = -1;                                                             \\\n\t\t} else if (adjerr == ADJ_ERR_SMU_UNSUPPORTED) {                           \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is not supported on this SMU\\n\");      \\\n\t\t\terr = -1;                                                             \\\n\t\t} else if (adjerr == ADJ_ERR_SMU_REJECTED) {                              \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is rejected by SMU\\n\");                \\\n\t\t\terr = -1;                                                             \\\n\t\t} else {                                                                  \\\n\t\t\tprintf(\"Failed to set\" STRINGIFY(ARG) \" \\n\");                         \\\n\t\t\terr = -1;                                                             \\\n\t\t}                                                                         \\\n\t}                                                                             \\\n} while(0);\n\n#define _do_enable(ARG) \\\ndo {                                                                              \\\n\tif (ARG) {                                                                    \\\n\t\tint adjerr = set_##ARG(ry);                                               \\\n\t\tif (!adjerr){                                                             \\\n\t\t\tany_adjust_applied = 1;                                               \\\n\t\t\tprintf(\"Sucessfully enable \" STRINGIFY(ARG) \"\\n\");                    \\\n\t\t} else if (adjerr == ADJ_ERR_FAM_UNSUPPORTED) {                           \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is not supported on this family\\n\");   \\\n\t\t\terr = -1;                                                             \\\n\t\t} else if (adjerr == ADJ_ERR_SMU_UNSUPPORTED) {                           \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is not supported on this SMU\\n\");      \\\n\t\t\terr = -1;                                                             \\\n\t\t} else if (adjerr == ADJ_ERR_SMU_REJECTED) {                              \\\n\t\t\tprintf(\"set_\" STRINGIFY(ARG) \" is rejected by SMU\\n\");                \\\n\t\t\terr = -1;                                                             \\\n\t\t} else {                                                                  \\\n\t\t\tprintf(\"Failed to set\" STRINGIFY(ARG) \" \\n\");                         \\\n\t\t\terr = -1;                                                             \\\n\t\t}                                                                         \\\n\t}                                                                             \\\n} while(0);\n\nstatic const char *const usage[] = {\n\t\"ryzenadj [options]\",\n\tNULL,\n};\n\nstatic const char *family_name(enum ryzen_family fam)\n{\n\tswitch (fam)\n\t{\n\tcase FAM_RAVEN: return \"Raven\";\n\tcase FAM_PICASSO: return \"Picasso\";\n\tcase FAM_RENOIR: return \"Renoir\";\n\tcase FAM_CEZANNE: return \"Cezanne\";\n\tcase FAM_DALI: return \"Dali\";\n\tcase FAM_LUCIENNE: return \"Lucienne\";\n\tcase FAM_VANGOGH: return \"Vangogh\";\n\tcase FAM_REMBRANDT: return \"Rembrandt\";\n\tcase FAM_PHOENIX: return \"Phoenix Point\";\n\tcase FAM_HAWKPOINT: return \"Hawk Point\";\n\tcase FAM_STRIXPOINT: return \"Strix Point\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void show_info_header(ryzen_access ry)\n{\n\tprintf(\"CPU Family: %s\\n\", family_name(get_cpu_family(ry)));\n\tprintf(\"SMU BIOS Interface Version: %d\\n\", get_bios_if_ver(ry));\n\tprintf(\"Version: v\" STRINGIFY(RYZENADJ_REVISION_VER) \".\" STRINGIFY(RYZENADJ_MAJOR_VER) \".\" STRINGIFY(RYZENADJ_MINIOR_VER) \" \\n\");\n}\n\nstatic void show_info_table(ryzen_access ry)\n{\n\tprintf(\"PM Table Version: %x\\n\", get_table_ver(ry));\n\n\t//get refresh table after adjust\n\tint errorcode = refresh_table(ry);\n\tif(errorcode){\n\t\tprintf(\"Unable to refresh power metric table: %d\\n\", errorcode);\n\t\treturn;\n\t}\n\n\t//print table in github markdown\n\tprintf(\"|        Name         |   Value   |     Parameter      |\\n\");\n\tprintf(\"|---------------------|-----------|--------------------|\\n\");\n\tchar tableFormat[] = \"| %-19s | %9.3lf | %-18s |\\n\";\n\tprintf(tableFormat, \"STAPM LIMIT\", get_stapm_limit(ry), \"stapm-limit\");\n\tprintf(tableFormat, \"STAPM VALUE\", get_stapm_value(ry), \"\");\n\tprintf(tableFormat, \"PPT LIMIT FAST\", get_fast_limit(ry), \"fast-limit\");\n\tprintf(tableFormat, \"PPT VALUE FAST\", get_fast_value(ry), \"\");\n\tprintf(tableFormat, \"PPT LIMIT SLOW\", get_slow_limit(ry), \"slow-limit\");\n\tprintf(tableFormat, \"PPT VALUE SLOW\", get_slow_value(ry), \"\");\n\tprintf(tableFormat, \"StapmTimeConst\", get_stapm_time(ry), \"stapm-time\");\n\tprintf(tableFormat, \"SlowPPTTimeConst\", get_slow_time(ry), \"slow-time\");\n\tprintf(tableFormat, \"PPT LIMIT APU\", get_apu_slow_limit(ry), \"apu-slow-limit\");\n\tprintf(tableFormat, \"PPT VALUE APU\", get_apu_slow_value(ry), \"\");\n\tprintf(tableFormat, \"TDC LIMIT VDD\", get_vrm_current(ry), \"vrm-current\");\n\tprintf(tableFormat, \"TDC VALUE VDD\", get_vrm_current_value(ry), \"\");\n\tprintf(tableFormat, \"TDC LIMIT SOC\", get_vrmsoc_current(ry), \"vrmsoc-current\");\n\tprintf(tableFormat, \"TDC VALUE SOC\", get_vrmsoc_current_value(ry), \"\");\n\tprintf(tableFormat, \"EDC LIMIT VDD\", get_vrmmax_current(ry), \"vrmmax-current\");\n\tprintf(tableFormat, \"EDC VALUE VDD\", get_vrmmax_current_value(ry), \"\");\n\tprintf(tableFormat, \"EDC LIMIT SOC\", get_vrmsocmax_current(ry), \"vrmsocmax-current\");\n\tprintf(tableFormat, \"EDC VALUE SOC\", get_vrmsocmax_current_value(ry), \"\");\n\tprintf(tableFormat, \"THM LIMIT CORE\", get_tctl_temp(ry), \"tctl-temp\");\n\tprintf(tableFormat, \"THM VALUE CORE\", get_tctl_temp_value(ry), \"\");\n\tprintf(tableFormat, \"STT LIMIT APU\", get_apu_skin_temp_limit(ry), \"apu-skin-temp\");\n\tprintf(tableFormat, \"STT VALUE APU\", get_apu_skin_temp_value(ry), \"\");\n\tprintf(tableFormat, \"STT LIMIT dGPU\", get_dgpu_skin_temp_limit(ry), \"dgpu-skin-temp\");\n\tprintf(tableFormat, \"STT VALUE dGPU\", get_dgpu_skin_temp_value(ry), \"\");\n\tprintf(tableFormat, \"CCLK Boost SETPOINT\", get_cclk_setpoint(ry), \"power-saving /\");\n\tprintf(tableFormat, \"CCLK BUSY VALUE\", get_cclk_busy_value(ry), \"max-performance\");\n}\n\nstatic void show_table_dump(ryzen_access ry, int any_adjust_applied)\n{\n\tsize_t index, table_size;\n\tuint32_t *table_data_copy;\n\tfloat *current_table_values, *old_table_values;\n\n\tprintf(\"PM Table Dump of Version: %x\\n\", get_table_ver(ry));\n\ttable_size = get_table_size(ry);\n\n\tcurrent_table_values = get_table_values(ry);\n\ttable_data_copy = malloc(table_size);\n\tmemcpy(table_data_copy, current_table_values, table_size);\n\n\tif(any_adjust_applied)\n\t{\n\t\t//copy old values before refresh\n\t\told_table_values = malloc(table_size);\n\t\tmemcpy(old_table_values, table_data_copy, table_size);\n\n\t\tint errorcode = refresh_table(ry);\n\t\tif(errorcode){\n\t\t\tprintf(\"Unable to refresh power metric table: %d\\n\", errorcode);\n\t\t}\n\n\t\t//print table in github markdown\n\t\tprintf(\"| Offset |    Data    |   Value   | After Adjust |\\n\");\n\t\tprintf(\"|--------|------------|-----------|--------------|\\n\");\n\t\tchar tableFormat[] = \"| 0x%04X | 0x%08X | %9.3lf | %12.3lf |\\n\";\n\t\tfor(index = 0; index < table_size / 4; index++)\n\t\t{\n\t\t\tprintf(tableFormat, index * 4, table_data_copy[index], old_table_values[index], current_table_values[index]);\n\t\t}\n\n\t\tfree(old_table_values);\n\t}\n\telse\n\t{\n\t\t//print table in github markdown\n\t\tprintf(\"| Offset |    Data    |   Value   |\\n\");\n\t\tprintf(\"|--------|------------|-----------|\\n\");\n\t\tchar tableFormat[] = \"| 0x%04X | 0x%08X | %9.3lf |\\n\";\n\t\tfor(index = 0; index < table_size / 4; index++)\n\t\t{\n\t\t\tprintf(tableFormat, index * 4, table_data_copy[index], current_table_values[index]);\n\t\t}\n\t}\n\n\tfree(table_data_copy);\n\t//don't free current_table_values because this would deinitialize our table\n}\n\n\nint main(int argc, const char **argv)\n{\n\tryzen_access ry;\n\tint err = 0;\n\n\tint info = 0, dump_table = 0, any_adjust_applied = 0;\n\tint power_saving = 0, max_performance = 0, enable_oc = 0x0, disable_oc = 0x0;\n\t//init unsigned types with max value because we treat max value as unset\n\tuint32_t stapm_limit = -1, fast_limit = -1, slow_limit = -1, slow_time = -1, stapm_time = -1, tctl_temp = -1;\n\tuint32_t vrm_current = -1, vrmsoc_current = -1, vrmmax_current = -1, vrmsocmax_current = -1, psi0_current = -1, psi0soc_current = -1;\n\tuint32_t vrmgfx_current = -1, vrmcvip_current = -1, vrmgfxmax_current = -1, psi3cpu_current = -1, psi3gfx_current = -1;\n\tuint32_t max_socclk_freq = -1, min_socclk_freq = -1, max_fclk_freq = -1, min_fclk_freq = -1, max_vcn = -1, min_vcn = -1, max_lclk = -1, min_lclk = -1;\n\tuint32_t max_gfxclk_freq = -1, min_gfxclk_freq = -1, prochot_deassertion_ramp = -1, apu_skin_temp_limit = -1, dgpu_skin_temp_limit = -1, apu_slow_limit = -1;\n\tuint32_t skin_temp_power_limit = -1;\n\tuint32_t gfx_clk = -1, oc_clk = -1, oc_volt = -1, coall = -1, coper = -1, cogfx = -1;\n\n\t//create structure for parseing\n\tstruct argparse_option options[] = {\n\t\tOPT_HELP(),\n\t\tOPT_GROUP(\"Options\"),\n\t\tOPT_BOOLEAN('i', \"info\", &info, \"Show information and most important power metrics after adjustment\"),\n\t\tOPT_BOOLEAN('\\0', \"dump-table\", &dump_table, \"Show whole power metric table before and after adjustment\"),\n\t\tOPT_GROUP(\"Settings\"),\n\t\tOPT_U32('a', \"stapm-limit\", &stapm_limit, \"Sustained Power Limit         - STAPM LIMIT (mW)\"),\n\t\tOPT_U32('b', \"fast-limit\", &fast_limit, \"Actual Power Limit            - PPT LIMIT FAST (mW)\"),\n\t\tOPT_U32('c', \"slow-limit\", &slow_limit, \"Average Power Limit           - PPT LIMIT SLOW (mW)\"),\n\t\tOPT_U32('d', \"slow-time\", &slow_time, \"Slow PPT Constant Time (s)\"),\n\t\tOPT_U32('e', \"stapm-time\", &stapm_time, \"STAPM constant time (s)\"),\n\t\tOPT_U32('f', \"tctl-temp\", &tctl_temp, \"Tctl Temperature Limit (degree C)\"),\n\t\tOPT_U32('g', \"vrm-current\", &vrm_current, \"VRM Current Limit             - TDC LIMIT VDD (mA)\"),\n\t\tOPT_U32('j', \"vrmsoc-current\", &vrmsoc_current, \"VRM SoC Current Limit         - TDC LIMIT SoC (mA)\"),\n\t\tOPT_U32('\\0', \"vrmgfx-current\", &vrmgfx_current, \"VRM GFX Current Limit - TDC LIMIT GFX (mA)\"),\n\t\tOPT_U32('\\0', \"vrmcvip-current\", &vrmcvip_current, \"VRM CVIP Current Limit - TDC LIMIT CVIP (mA)\"),\n\t\tOPT_U32('k', \"vrmmax-current\", &vrmmax_current, \"VRM Maximum Current Limit     - EDC LIMIT VDD (mA)\"),\n\t\tOPT_U32('l', \"vrmsocmax-current\", &vrmsocmax_current, \"VRM SoC Maximum Current Limit - EDC LIMIT SoC (mA)\"),\n\t\tOPT_U32('\\0', \"vrmgfxmax_current\", &vrmgfxmax_current, \"VRM GFX Maximum Current Limit - EDC LIMIT GFX (mA)\"),\n\t\tOPT_U32('m', \"psi0-current\", &psi0_current, \"PSI0 VDD Current Limit (mA)\"),\n\t\tOPT_U32('\\0', \"psi3cpu_current\", &psi3cpu_current, \"PSI3 CPU Current Limit (mA)\"),\n\t\tOPT_U32('n', \"psi0soc-current\", &psi0soc_current, \"PSI0 SoC Current Limit (mA)\"),\n\t\tOPT_U32('\\0', \"psi3gfx_current\", &psi3gfx_current, \"PSI3 GFX Current Limit (mA)\"),\n\t\tOPT_U32('o', \"max-socclk-frequency\", &max_socclk_freq, \"Maximum SoC Clock Frequency (MHz)\"),\n\t\tOPT_U32('p', \"min-socclk-frequency\", &min_socclk_freq, \"Minimum SoC Clock Frequency (MHz)\"),\n\t\tOPT_U32('q', \"max-fclk-frequency\", &max_fclk_freq, \"Maximum Transmission (CPU-GPU) Frequency (MHz)\"),\n\t\tOPT_U32('r', \"min-fclk-frequency\", &min_fclk_freq, \"Minimum Transmission (CPU-GPU) Frequency (MHz)\"),\n\t\tOPT_U32('s', \"max-vcn\", &max_vcn, \"Maximum Video Core Next (VCE - Video Coding Engine) (MHz)\"),\n\t\tOPT_U32('t', \"min-vcn\", &min_vcn, \"Minimum Video Core Next (VCE - Video Coding Engine) (MHz)\"),\n\t\tOPT_U32('u', \"max-lclk\", &max_lclk, \"Maximum Data Launch Clock (MHz)\"),\n\t\tOPT_U32('v', \"min-lclk\", &min_lclk, \"Minimum Data Launch Clock (MHz)\"),\n\t\tOPT_U32('w', \"max-gfxclk\", &max_gfxclk_freq, \"Maximum GFX Clock (MHz)\"),\n\t\tOPT_U32('x', \"min-gfxclk\", &min_gfxclk_freq, \"Minimum GFX Clock (MHz)\"),\n\t\tOPT_U32('y', \"prochot-deassertion-ramp\", &prochot_deassertion_ramp, \"Ramp Time After Prochot is Deasserted: limit power based on value, higher values does apply tighter limits after prochot is over\"),\n\t\tOPT_U32('\\0', \"apu-skin-temp\", &apu_skin_temp_limit, \"APU Skin Temperature Limit    - STT LIMIT APU (degree C)\"),\n\t\tOPT_U32('\\0', \"dgpu-skin-temp\", &dgpu_skin_temp_limit, \"dGPU Skin Temperature Limit   - STT LIMIT dGPU (degree C)\"),\n\t\tOPT_U32('\\0', \"apu-slow-limit\", &apu_slow_limit, \"APU PPT Slow Power limit for A+A dGPU platform - PPT LIMIT APU (mW)\"),\n\t\tOPT_U32('\\0', \"skin-temp-limit\", &skin_temp_power_limit, \"Skin Temperature Power Limit (mW)\"),\n\t\tOPT_U32('\\0', \"gfx-clk\", &gfx_clk, \"Forced Clock Speed MHz (Renoir Only)\"),\n\t\tOPT_U32('\\0', \"oc-clk\", &oc_clk, \"Forced Core Clock Speed MHz (Renoir and up Only)\"),\n\t\tOPT_U32('\\0', \"oc-volt\", &oc_volt, \"Forced Core VID: Must follow this calcuation (1.55 - [VID you want to set e.g. 1.25 for 1.25v]) / 0.00625 (Renoir and up Only)\"),\n\t\tOPT_BOOLEAN('\\0', \"enable-oc\", &enable_oc, \"Enable OC (Renoir and up Only)\"),\n\t\tOPT_BOOLEAN('\\0', \"disable-oc\", &disable_oc, \"Disable OC (Renoir and up Only)\"),\n\t\tOPT_U32('\\0', \"set-coall\", &coall, \"All core Curve Optimiser\"),\n\t\tOPT_U32('\\0', \"set-coper\", &coper, \"Per core Curve Optimiser\"),\n\t\tOPT_U32('\\0', \"set-cogfx\", &cogfx, \"iGPU Curve Optimiser\"),\n\t\tOPT_BOOLEAN('\\0', \"power-saving\", &power_saving, \"Hidden options to improve power efficiency (is set when AC unplugged): behavior depends on CPU generation, Device and Manufacture\"),\n\t\tOPT_BOOLEAN('\\0', \"max-performance\", &max_performance, \"Hidden options to improve performance (is set when AC plugged in): behavior depends on CPU generation, Device and Manufacture\"),\n\t\tOPT_GROUP(\"P-State Functions\"),\n\t\tOPT_END(),\n\t};\n\n\n\tstruct argparse argparse;\n\targparse_init(&argparse, options, usage, ARGPARSE_NON_OPTION_IS_INVALID);\n\targparse_describe(&argparse, \"\\n Ryzen Power Management adjust tool.\", \"\\nWARNING: Use at your own risk!\\nBy Jiaxun Yang <jiaxun.yang@flygoat.com>, Under LGPL.\\nVersion: v\" STRINGIFY(RYZENADJ_REVISION_VER) \".\" STRINGIFY(RYZENADJ_MAJOR_VER) \".\" STRINGIFY(RYZENADJ_MINIOR_VER));\n\targc = argparse_parse(&argparse, argc, argv);\n\n\n\t//init RyzenAdj and validate that it was able to\n\try = init_ryzenadj();\n\tif(!ry){\n\t\tprintf(\"Unable to init ryzenadj\\n\");\n\t\treturn -1;\n\t}\n\n\t//shows info header before init_table\n\tif (info) {\n\t\tshow_info_header(ry);\n\t}\n\n\tif (info || dump_table) {\n\t\t//init before adjustment to get the default values\n\t\terr = init_table(ry);\n\t\tif (err) {\n\t\t\tprintf(\"Unable to init power metric table: %d, this does not affect adjustments because it is only needed for monitoring.\\n\", err);\n\t\t}\n\t}\n\n\t//adjust all the arguments sent to RyzenAdj.exe\n\t_do_adjust(stapm_limit);\n\t_do_adjust(fast_limit);\n\t_do_adjust(slow_limit);\n\t_do_adjust(slow_time);\n\t_do_adjust(stapm_time);\n\t_do_adjust(tctl_temp);\n\t_do_adjust(vrm_current);\n\t_do_adjust(vrmsoc_current);\n\t_do_adjust(vrmgfx_current);\n\t_do_adjust(vrmcvip_current);\n\t_do_adjust(vrmmax_current);\n\t_do_adjust(vrmsocmax_current);\n\t_do_adjust(vrmgfxmax_current);\n\t_do_adjust(psi0_current);\n\t_do_adjust(psi3cpu_current);\n\t_do_adjust(psi0soc_current);\n\t_do_adjust(psi3gfx_current);\n\t_do_adjust(max_socclk_freq);\n\t_do_adjust(min_socclk_freq);\n\t_do_adjust(max_fclk_freq);\n\t_do_adjust(min_fclk_freq);\n\t_do_adjust(max_vcn);\n\t_do_adjust(min_vcn);\n\t_do_adjust(max_lclk);\n\t_do_adjust(min_lclk);\n\t_do_adjust(max_gfxclk_freq);\n\t_do_adjust(min_gfxclk_freq);\n\t_do_adjust(prochot_deassertion_ramp);\n\t_do_adjust(apu_skin_temp_limit);\n\t_do_adjust(dgpu_skin_temp_limit);\n\t_do_adjust(apu_slow_limit);\n\t_do_adjust(skin_temp_power_limit);\n\t_do_adjust(gfx_clk);\n\t_do_adjust(oc_clk);\n\t_do_adjust(oc_volt);\n\t_do_enable(power_saving);\n\t_do_enable(max_performance);\n\t_do_enable(enable_oc)\n\t_do_enable(disable_oc);\n\t_do_adjust(coall);\n\t_do_adjust(coper);\n\t_do_adjust(cogfx);\n\n\tif (!err) {\n\t\t//call show table dump before anybody did call table refresh, because we want to copy the old values first\n\t\tif (dump_table) {\n\t\t\tshow_table_dump(ry, any_adjust_applied);\n\t\t}\n\t\t//show power table after apply settings\n\t\tif (info) {\n\t\t\tshow_info_table(ry);\n\t\t}\n\t}\n\n\tcleanup_ryzenadj(ry);\n\n\treturn err;\n}\n"
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}