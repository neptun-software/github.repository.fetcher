{
  "metadata": {
    "timestamp": 1736710114810,
    "page": 745,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "twitter/ios-twitter-image-pipeline",
      "stars": 1855,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.2451171875,
          "content": "# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## Build generated\nbuild/\nDerivedData\n\n## Various settings\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata\n\nTwitterImagePipeline.xcodeproj/project.xcworkspace/xcuserdata\nTwitterImagePipeline.xcodeproj/xcuserdata\n\n## Other\n*.xccheckout\n*.moved-aside\n*.xcuserstate\n*.xcscmblueprint\n\n## Obj-C/Swift specific\n*.hmap\n*.ipa\n\n# CocoaPods\n#\n# We recommend against adding the Pods directory to your .gitignore. However\n# you should judge for yourself, the pros and cons are mentioned at:\n# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control\n#\n# Pods/\n\n# Carthage\n#\n# Add this line if you want to avoid checking in source code from Carthage dependencies.\n# Carthage/Checkouts\n\nCarthage/Build\n\n# fastlane\n#\n# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the \n# screenshots whenever they are needed.\n# For more information about the recommended setup visit:\n# https://github.com/fastlane/fastlane/blob/master/docs/Gitignore.md\n\nfastlane/report.xml\nfastlane/screenshots\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0625,
          "content": "language: objective-c\nosx_image: xcode11.5\nscript:\n  ./build.sh\n"
        },
        {
          "name": "BuildConfiguration",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 27.615234375,
          "content": "# Twitter Image Pipeline Change Log\n\n## Info\n\n**Document version:** 2.25.0\n\n**Last updated:** 10/29/2020\n\n**Author:** Nolan O'Brien\n\n## History\n\n### 2.25.0\n\n- Fix codec detection for images that are not JPEG, PNG, GIF or BMP\n  - In more recent versions of iOS, more image types require the complete image data to detect the image type instead of just the headers\n    - This mostly just affects very small images, larger images generally were never affected\n  - This regressed our codec detection logic for images that do not also have TIPs \"magic numbers\" image type detection\n  - This fixes that by informing the codecs if the data being provided for detection is the complete image data or not\n  - Caveat: for images other than JPEG, PNG, GIF, BMP or WEBP, it is likely that it will take the complete image data to detect those images now which can lengthen the duration for book-keeping overhead as the image is being loaded\n    - If you want to have an image format detected faster than what Core Graphics detects (all data required for most formats), you can either provide a custom codec with better format detection logic or you can update the magic numbers APIs in `TIPImageTypes.m`\n\n### 2.24.3\n\n- Fix scaling logic to better preserve source size aspect ratio during scale\n  - For example: 800x800 scaled to fill 954x954 would yield a 953x954 size.  Now it will properly yield 954x954.\n\n### 2.24.2\n\n- Fix WebP decoder for animations\n  - Complex animations were not properly being decoded\n\n### 2.24.1 - Liam Nichols\n\n- Add MP4 and WebP subspecs for CocoaPods\n\n### 2.24.0\n\n- Drop iOS 8 and iOS 9 support\n\n### 2.23.5\n\n- Refactor WebP decoder to support animation decoding and improve efficiency\n  - Requires _WebPDemux.framework_ for iOS (the Catalyst lib already has the necessary bits)\n  - The `TIPXWebPCodec` also supports progressive loading (rendering the first frame while more data is loading)\n    - This makes it potentially a better choice as a decoder than the iOS 14+ built in decoder, depending on your use case\n  - Improve decoder to support having static _WebP_ images decode into the provided target sizing for better efficiency\n\n### 2.23.2\n\n- Update to WebP v1.1.0\n  - Also fixes building WebP for Apple Silicon Catalyst builds\n\n### 2.23.1\n\n- Optimize the rendered cache unloading when `clearMemoryCachesOnApplicationBackgroundEnabled` is `YES`\n  - When the app goes into the background, the rendered cache used to clear the oldest rendered images and just keep a max of 50% of the rendered cache capacity for when the app resumes\n    - This was mostly effective for keeping the on screen images in cache avoiding any flashing UI, but had edge cases that could lead flashing or holding onto too much in memory that isn't needed for app resumes\n  - Now, the rendered cache will turn each cache entry as _weak_ and on app resume, these _weak_ entries will be made strong again.\n    - This will have the effect of all rendered cache images with no references being purged, but all those references being retained\n    - Effectively, any UI that is holding the rendered images will keep those around for when the app resumes, making it seemless\n    - For any UI that has unloaded its images when not visible, those images will be purged and will reload when the view becomes visible again\n    - This works especially well with `TIPImageViewFetchHelper` when `disappearanceBehavior` is `TIPImageViewDisappearanceBehaviorUnload` or `TIPImageViewDisappearanceBehaviorReplaceWithPlaceholder`\n\n### 2.23.0\n\n- Replace `TIPImageFetchProgressiveLoadingPolicy` class methods with C functions\n  - Swift does not like having an `@interface` have the same name as an `@protocol`\n  - It can work, but gets very messy\n  - Best to avoid it and replace the convenient class method interfaces in Objective-C with C functions\n  - Though this is a minor version bump, it is API breaking\n    - There isn't a way to deprecated the old APIs and introduce new ones, we just have to remove the old ones to fix usages in Swift\n    - _Apologies for the inconvenience!_\n\n### 2.22.0\n\n- Add `TIPImageFetchSkipStoringToRenderedCache` to `TIPImageFetchOptions`\n  - This permits a fetch to skip storing to the synchronous rendered cache altogether after a fetch\n  - This is useful for UI that displays a large image but is not frequented regularly, such as a full screen image view\n  - By avoiding infrequent images going to rendered cache, the rendered cache can keep more relevent images in cache (or can be configured to be smaller)\n- Add `TIPImageViewDisappearanceBehaviorUnload` to `TIPImageViewDisappearanceBehavior`\n  - This new behavior will set the `fetchView` image to `nil` on disappearance\n  - This new feature can really level up an app at keeping a memory footprint down automatically, no extra work is needed when using `TIPImageViewFetchHelper` for displaying images!\n- Add `TIPImageViewDisappearanceBehaviorReplaceWithPlaceholder` to `TIPImageViewDisappearanceBehavior`\n  - This new behavior will set the `fetchView` image to a placeholder (low resolution) version on disappearance, which will be replace with the full image on visible return\n  - Similar benefits to `TIPImageViewDisappearanceBehaviorUnload` but with the compromise of keeping a little more RAM for a placeholder to avoid UI situations that could yield an empty image view temporarily as the full image is decoded (notably for large images or slow devices)\n- Rename `TIPImageViewFetchHelper` class' `fetchDisappearanceBehavior` to `disappearanceBehavior`\n- Add `shouldTreatApplicationBackgroundAsViewDisappearance` property to `TIPImageViewFetchHelper`\n  - This `BOOL` property will opt the fetch helper into using the disappearance behavior when the app backgrounds\n  - Another big improvement for app memory footprint as the large amount of RAM used for images can be unloaded on app background, reducing the risk of the app being jettisoned!\n  - Impact is really great for large images on screen when backgrounded, be sure to set to `YES` for your large image views!\n\n### 2.21.5\n\n- Adopt `direct` support for Objective-C code and eliminate `PRIVATE_SELF` C function pattern\n  - Preserves Objective-C calling syntax for better code legibility (less C-style calls interleaving ObjC)\n  - Safer than `PRIVATE_SELF` C functions (don't need to check `self != nil`)\n  - Avoids awkward `self->_ivar` access in the direct methods (can stick with just using `_ivar`)\n  - Same low binary overhead as private C functions\n\n### 2.21.0\n\n- Revise `TIPError.h` to be much more Swift compatible\n\n### 2.20.5\n\n- Revise _WebP_ support by adding _iOS 14_ decoder and integrating that with existing `TIPXWebPCodec`\n  - Also means _Animated WebP_ are supported (decode only) on _iOS 14+_ now\n\n### 2.20.0\n\n- Fundamentally apply a rearchitecture to __Twitter Image Pipeline__\n  - First: when loading images from data or files, the target sizing (dimensions & content mode) can now be used by codecs for more efficient decoding\n    - This means that decoding a large image into a view port that is smaller can now decode directly into the appropriate size, reducing RAM and CPU of the decode AND avoiding needing to scale the image down before delivering the image as a result (more CPU savings)\n    - This is implemented with the `ImageIO` based codecs, but not the extended codecs (`WebP` and `MP4`)...yet\n  - Second: there are 3 caches in __TIP__: Rendered image cache, In Memory image cache, and On Disk image data cache.\n    - The In Memory cache has been been restructured to cache the compressed image data instead of the image itself\n    - This means:\n      - Less RAM is needed for this middle cache\n      - Less RAM is used when decoding the image to serve as a response\n      - No more scaling the image from full size to the size to serve as a response (for core image codecs)\n- Given how substantial this change is, we are bumping from version `2.13` to `2.20`\n  - In particular, custom codecs will need to be updated to support the new `targetDimensions` and `targetContentMode` arguments \n\n### 2.13.5\n\n- Add _WebP_ support to Catalyst builds\n  - See `WEBP_README.md`\n- Miscellaneous performance improvements\n  - Async load the default codes to avoid main thread blockage on app launch\n  - Tighter memory management with autorelease pools\n  - `TIPImageFetchHelper` will now register for all image cache updates and filter on observation vs registering against specific pipelines, which avoids register/unregister locking performance impact\n  - Add `TIPDetectImageTypeFromFile(...)` for efficient and effective image type detection from a file\n- Add replacements for `UIImagePNGRepresentation` and `UIImageJPEGRepresentation`\n  - Unifies to the __TIP__ codec based encoding rather than the __UIKit__ implementation which can be unreliable for consistency.\n  - Provides progressive support for JPEG variant of functionality.\n  - See `-[UIImage tip_PNGRepresentation]` and `-[UIImage tip_JPEGRepresentationWithQuality:progressive:]`\n- Add some palette based image utilities\n  - `-[UIImage tip_canLosslesslyEncodeUsingIndexedPaletteWithOptions:]`\n- Fix bug where a GIF load may be incomplete in response but complete in data loaded failing to load in __TIP__\n  - Mostly an issue with some CDN vendors terminating the HTTP response incorrectly\n\n### 2.13.2\n\n- Add `[TIPGlobalConfiguration defaultInterpolationQuality]`\n  - By default, will use `CGInterpolationQualityDefault` which is same behavior as before\n  - Add quality arg to image scaling with `[UIImage tip_scaledImageWithTargetDimensions:contentMode:interpolationQuality:decode:]`\n\n### 2.13.1\n\n- Add `[TIPImageFetchDelegate tip_imageFetchOperation:didLoadDirtyPreviewImage:]` support\n  - This allows for the rendered cache to mark a specific entry dirty (by identifier)\n  - On fetch operation load, the dirty preview can be synchronously loaded while the op continues on async\n  - This helps systems where a larger version of an image with a shared identifier loads and matching fetch helpers that are not visible in the UI take note in order to refresh with the better resolution image, but without the risk of clearing that image's render cache which can lead to a 1 or 2 frame \"flash\" of the image loading async from cache\n\n### 2.13.0\n\n- Separate out authentication support for image requests from hydration support\n  - Hydration now just serves populating the image fetch's URL request\n  - Authorization now serves to generate an _Authorization_ header's value to be applied as a separate step\n  - Works better with multi step networking frameworks such as __TwitterNetworkLayer__\n  - See `[TIPImageFetchRequest imageRequestAuthorizationBlock]`\n\n### 2.12.2\n\n- Add automatic handling of unnecessary image download errors when the download has finished loading\n  - It is not uncommon for a service/CDN to yield an error after the final byte of the response has been loaded by the client\n  - The consequence of treating a successful load as a failure is that upon next fetch for that image an unnessecary network request will trigger:\n    - For image resumption supported loads, resumes the load beyond the available byte range\n    - For full image loads, a redundant download\n  - When TIP sees an error on image download but has all the bytes (looking at `Content-Length` header), TIP now posts `TIPProblemImageDownloadedWithUnnecessaryError` problem\n\n### 2.12.1\n\n- Fix bugs related to capping the sizes of caches\n  - Capping a cache to `0` bytes would not completely disable it as documented, fixed\n  - Setting the max ratio value to a negative value would not use the default value as documented, fixed\n  - Thanks to @jml5qh for filing this issue (#41)\n\n### 2.12.0\n\n- Add `TIPImageTypeHEIC` and `TIPImageTypeAVCI` support\n  - There are OS version limitations, see `TIPImageTypes.h` for details\n\n### 2.11.1\n\n- Update defaults in `TIPGlobalConfiguration` for cache sizes\n  - `TIPMaxBytesForAllRenderedCachesDefault` and `TIPMaxBytesForAllMemoryCachesDefault`\n    - the lesser of `System RAM / 12` or `160 MBs`\n  - `TIPMaxCountForAllRenderedCachesDefault` and `TIPMaxCountForAllMemoryCachesDefault`\n    - default cap to `255` instead of `511`\n\n### 2.11.0\n\n- add support for animated images with `TIPImageViewFetchHelper` by supporting `TIPImageContainer` as well as `UIImage`\n  - to support animated images, implement a `UIView` that adopts `TIPImageFetchable` with `tip_fetchedImageContainer` that can animate the provided `TIPImageContainer`\n  - update `TIPImageFetchable`\n    - add `tip_fetchedImageContainer` as optional property\n    - mark `tip_fetchedImage` as optional\n    - require at least one of the two methods be implemented to conform to `TIPImageFetchable`\n  - add helper functions:\n    - `TIPImageFetchableHasImage`\n    - `TIPImageFetchableGetImage` and `TIPImageFetchableGetImageContainer`\n    - `TIPImageFetchableSetImage` and `TIPImageFetchableSetImageContainer`\n  - update `TIPImageViewFetchHelper`\n    - add `setImageContainerAsIfLoaded:`\n    - add `setImageContainerAsIfPlaceholder:`\n  - update `TIPImageViewFetchHelperDataSource`\n    - add `tip_imageContainerForFetchHelper:`\n  - update `TIPImageViewFetchHelperDelegate`\n    - add `tip_fetchHelper:didUpdateDisplayedImageContainer:fromSourceDimensions:isFinal:`\n    - deprecate `tip_fetchHelper:didUpdateDisplayedImage:fromSourceDimensions:isFinal:`\n    - add `tip_fetchHelper:shouldReloadAfterDifferentFetchCompletedWithImageContainer:dimensions:identifier:URL:treatedAsPlaceholder:manuallyStored:`\n    - deprecate `tip_fetchHelper:shouldReloadAfterDifferentFetchCompletedWithImage:dimensions:identifier:URL:treatedAsPlaceholder:manuallyStored:`\n\n### 2.10.0\n\n- drop support for iOS 7\n  - the code had already diverged to requiring many iOS 8+ only APIs, this just makes it official\n\n### 2.9.4 - Armand Raynor\n\n- Fix MP4 decoder when decoding anamorphic mp4s into animations\n\n### 2.9.3\n\n- Add `notifyAllFetchHelpersToRetryFailedLoads` class method to `TIPImageViewFetchHelper`\n  - This will offer an easy way for consuming apps to trigger a reload of failed image fetches when the network conditions change \n\n### 2.9.2\n\n- Add `TIPRenderImage` util function\n- Add `tip_imageWithRenderFormattings:render:` method to `UIImage+TIPAdditions`\n\n### 2.9.1\n\n- Use modern `UIGraphicsImageRenderer` always when scaling images on iOS 10+\n  - source the `UIGraphicsImageRendererFormat` from the image being scaled, this is optimal\n  - roughly 10% speed boost\n  - add _GraphicsRendererSpeed_ project that validates the perf differences\n\n### 2.9.0\n\n- Add P3 color gamut support\n  - Image scaling preserves P3 (on device's with P3 screens) now\n  - Add functions to check if a screen supports P3\n  - Add category property to UIImage to check if image has P3 colorspace\n\n### 2.8.1\n\n- Persist source image dimensions for Rendered Cache\n  - this provides more context about the source image, such as knowing if the displayed image was scaled up or scaled down\n  - also added new \"RMem\" value when showing info with debug info feature on `TIPImageViewFetchHelper`\n  - improve `TIPImageViewFetchHelper` when reloading an image after a new \"matching\" image was cached (such as a larger resolution)\n\n### 2.8.0\n\n- Move `TIPImageViewFetchHelper` from using `UIImageView` instances directly to using `UIView` with `TIPImageFetchable` protocol\n  - makes it possible for  `UIView` subclasses to support the fetch helper, like `UIButton` or a custom view\n\n### 2.7.2\n\n- improve `TIPImageFetchTransformer` support with optional identifier\n  - was easy to get the rendered cache images mixed up between transformed and non-transformed fetches\n  - now, transform requests can only fetch images from the rendered cache if there is a match with the `tip_tranformerIdentifier`\n  - transformers that don't provide an identifier cannot be cached nor retrieved from the rendered cache\n- removed transformer from `TIPGlobalConfiguration` (would interfere with above improvement)\n\n### 2.7.1\n\n- add generic concrete class for `TIPImageFetchRequest` as convenience\n  - generic fetch request is mutable/immutable pair: `TIPGenericImageFetchRequest` and `TIPMutableGenericImageFetchRequest`\n\n### 2.7.0\n\n- add decoder config support\n  - enables custom TIPImageDecoder implementations to have configurable ways of being decoded\n- add memory map loading option for images\n  - default continues to not use memory map loading, but it's now exposed on TIPImageContainer\n- add MP4 decoder to TIP (as an extended decoder, not bundled by default)\n  - decodes MP4s as animated images\n\n### 2.6.0\n\n- Remove `TIPImageView`, just use `UIImageView` category instead\n  - Add `hidden` property support to `UIImageView` fetch helper category\n- Remove `TIPImageViewFetchHelper` subclassing event methods\n  - Use delegate pattern for eventing instead of polymorphism #Simplify\n- Remove `setViewHidden:` method for `TIPImageViewFetchHelper`\n  - It never did what it was advertised to do and muddied the control flow\n- Add `fetchResultDimensions` to `TIPImageViewFetchHelper` for more insight into results\n\n\n\n### 2.5.0\n\n- Remove detached downloads support for TIP image fetches\n  - using HTTP/2 is the ideal solution, removing the complexity to remove the crutch\n\n### 2.4.5\n\n- reduce thread count for TIP by unifying all disk caches to using 1 manifest queue\n  - make disk cache manifest load async instead of sync now that it is shared\n  - no real speed improvements, just fewer threads need to be used in multi-pipeline apps\n- clean up some large inline functions to be regular functions\n\n### 2.4.4 - protosphere\n\n- Fix WebP Encoder (channels could be mixed up)\n\n### 2.4.3\n\n- Update WebP codec to v0.6.0\n\n### 2.4.2\n\n- Add support for changing a cached image's identifier\n\n### 2.4.1 - Brandon Carpenter\n\n- Add category to `UIImageView` for setting a `TIPImageViewFetchHelper`\n  - offers convenience of __TIP__ work encapsulated in `TIPImageViewFetchHelper` without needing to refactor onto `TIPImageView`\n\n### 2.4.0\n\n- Add image transform support to __TIP__\n- A `TIPImageFetchTransform` can be set globally or on a specific request\n- Clean up some nullability notation\n- Update ImageSpeedComparison sample app\n    - add WebP\n    - add more bitrates\n    - add optional blur transform (for progress)\n    - add smaller PJPEG\n\n### 2.3.0\n\n- Reduce memory pressure w/ `@autoreleasepool` blocks on GCD queues in _TIP_\n- Add \"problem\" for images not caching because they are too large\n- Add \"problem\" when downloaded image cannot be decoded\n- Add Animated PNG support (iOS 8+)\n- Add the store operation as an argument to `TIPImagePipelineStoreCompletionBlock`\n- Tightened up some threading race conditions that cropped up with the thread sanitizer\n\n### 2.2.2\n\n- Fix decoder bug on iOS 9 that prevented images from decoding\n\n### 2.2.1\n\n- Revise `TIPImageFetchViewHelper` to use delegate and data source pattern, like `UITableView` and `UIPickerView` do.\n  - Less fiddly with simpler touch points by implementing the delegate and/or data source.\n- Added a sample application that uses the Twitter API.\n\n### 2.2.0\n\n- Refactor `TIPImageFetchOperation` and `TIPImageFetchDelegate` to use an encapsulated `TIPImageFetchResult`\n  - Gives us a consistent interface for preview, progressive and final image results\n\n### 2.1.0\n\n- Add support for \"placeholder\" images\n  - This offers a way to contextually \"flag\" certain images as \"less valuable\" that full images\n  - Consider a black and white preview of a full color image, that could be flagged as a \"placeholder\"\n- Cap caches to have a max number of images too\n\n### 2.0.0\n\n- __TwitterImagePipeline__ now supports pluggable image decoding and encoding w/ `TIPImageCodecs.h`\n  - `TIPImageCodecCatalogue` exists to encapsulate the set of known codecs for TIP to use\n  - The default codecs are all those included by iOS\n  - WebP codec is used in the unit tests, but does not come bundled with TIP as a default\n    - Consumers of TIP can use the WebP codec in their projects if they want to use it\n\n### 1.16.1 - Jeff Holliday\n\n- By default, process entries from the disk image cache manifest in parallel, reducing manifest load time by 25-50%\n\n### 1.16.0\n\n- Properly prefix methods in __TwitterImagePipeline__ with `tip_` prefix\n\n### 1.15.1\n\n- Remove `forceUITraitCollectionToSynchronizeConstruction` property from `TIPGlobalConfiguration`\n- _TIP_ will now always force the synchronization fix on iOS 8 & 9\n\n### 1.15.0\n\n- Move many image helper functions into `UIImage(TIPAdditions)` category\n- For some methods, add error output\n- Rename remaining helper functions to have better names and drop the \"Image\" prefix\n\n### 1.14.0\n\n- Abstract out the networking of __TIP__ via the `TIPImageFetchDownload` protocol in `TIPImageFetchDownload.h`\n- This permits __TIP__ to have it's own basic implementation but also frees consumers to plug in whatever networking layer they prefer instead.  Twitter uses the protocol to plug in it's own __Twitter Network Layer__ framework.\n- Plugging in a custom `TIPImageFetchDownload` is done via the `imageFetchDownloadClass` property on `TIPGlobalConfiguration`.\n- The default __TIP__ `TIPImageFetchDownload` implementation is just a thin wrapper on `NSURLSession`.\n\n### 1.13.0\n\n- Refactor __TIP__ to use `NSString` representations for image types instead of `TIPImageType`\n\n### 1.12.1\n\n- Restructure __TIP__.  No code/interface changes, just project layout and code moving between files.\n\n### 1.12.0\n\n- Add swizzling to mitigate crash in Apple's `UIImage`.\n- `UIImage` is thread safe _except_ with image creation (Apple bugs #27141588 and #26954460) which creates a `UITraitCollection` that has a race condition that leads to overrelease.\n- Following same pattern as Peter Steinberger to mitigate the issue: https://pspdfkit.com/blog/2016/investigating-thread-saftey-of-UIImage/\n- Swizzle `[UITraitCollection traitCollectionWithDisplayScale:]` to use a mutex for thread safety\n- Swizzling is opt-in via `TIPGlobalConfiguration.forceUITraitCollectionToSynchronizeConstruction`\n- This issue definitely exists on iOS 9, but it might have been fixed on iOS 10.  iOS 10 is in beta a.t.m. so we'll need to wait until we can validate in production.\n\n### 1.11.0 - Brandon Carpenter\n\n- Update the API to be more Swift-friendly\n- Value accessors in TIPImageFetchRequest and TIPImageStoreRequest are now defined as read-only properties, rather than as methods.\n- Moves TIPImageFetchLoadingSourcesNone out of the TIPImageFetchLoadingSources NS_OPTIONS and defines it as a constant instead so that it does not break Swift's automatic prefix stripping for the rest of the values.\n\n### 1.10.0\n\n- Create `TIPImageViewFetchHelper` to encapsulate reusable fetch behavior for an Image View\n- With given *glue methods*, a fetch helper can dynamically update the fetch request to target the desired image view's constraints.\n- By subclassing, a custom fetch helper can add additional concrete utility such as auto-selecting the best URL for a fetch based on the constraints of the target image view.\n- Encapsulate `TIPImageViewFetchHelper` in a `TIPImageView` for convenience\n\n### 1.9.0\n\n- Remove Twitter specific logging framework dependency and expose hooks to provide any desired logger\n\n### 1.8.1\n\n- Increase metadata of network downloaded images\n- Support multiple global TIP observers instead of just one\n\n### 1.8.0\n\n- Rework `TIPImageFetchDelegate` to be weakly held and cancel its operation(s) on dealloc\n\n### 1.7.2\n\n- Add support for capping the size of an entry in the caches\n- `[TIPGlobalConfiguration maxRatioSizeOfCacheEntry]`\n\n### 1.7.1\n\n- Add `imageFetchOperation:willAttemptToLoadFromSource:` to `TIPImageFetchDelegate`\n\n### 1.7.0\n\n- Provide extensibility to `TIPImageStoreRequest` by offering ability to provide a `TIPImageStoreRequestHydrater`.\n- The hydrater can be used to extend the work that executes for an image store operation.\n- Useful for asynchronously loading the image from a PhotoKit\n-    or asynchronously tranforming or modifying the image to be cached.\n- Expose the underlying `NSOperation` for the image store operation so that it can be used in dependency chains (but as a `TIPDependencyOperation`)\n- Useful for preventing a fetch operation from starting until a related store operation completes\n- Offers being made a dependency, being waited on until finished, and Key-Value-Observing when it finishes or transitions to/from executing\n- Does not offer mutability of the operation: that includes cancelling, prioritization or applying dependencies\n- Increase versatility of `TIPImageStoreRequest` by permitting a request to have both a data representation (`NSData` or `NSString` file path) and a `UIImage` representation.\n- This provides a single action that applies a `UIImage` to the memory cache and the data representation to the disk cache so that if the caller already made these expensive serializations/deserializations, they needn't be duplicated by the image pipeline during storage.\n- Previous behavior is in tact so if only one image representation is provided, it will be accurately converted to the right formats for the appropriate caches.\n\n### 1.6.4\n\n- provide load source when a progressive frame is loaded or the first frame of an animated image is loaded\n\n### 1.6.3\n\n- Optimize TIP for when a TIPImageFetchOperation over HTTP/1.1 is cancelled\n- When an op is cancelled and the underlying download would have no more delegates do the following:\n- If the download is known to be going over SPDY or HTTP/2 (not always easy to detect), cancel the download\n- If there is less than 1 KB of data left to download, continue as a \"detached\" download\n- If there is less than 3 seconds of estimated time remaining, continue as a \"detached\" download\n- Otherwise, just as before, cancel the download\n- As a \"detached\" download receives more data; if the download slows down too much, cancel the download\n- When a \"detached\" download completes, don't decode the image.  Just store it to the disk cache.\n- This optimization is particularly valuable on HTTP/1.1 (vs SPDY or HTTP/2) since it prevents connections from being closed and having to build up a new connection for subsequent image downloads\n\n### 1.6.2\n\n- Share max concurrent operations across all image pipelines\n\n### 1.6.1\n\n- Add method to TIPImagePipeline to get a copy of the on disk cache file for an image entry\n\n### 1.6.0\n\n- Add TIPGlobalConfiguration\n- Share cache max bytes across all caches\n\n### 1.5.0\n\n- Encapsulate images fetched by TIP in a `TIPImageContainer` so that additional meta data can be maintained\n- Currently, additiona meta data is loop count and frame durations for animated images (GIFs)\n\n### 1.4.0\n\n- Add preliminary support for progressive JPEG-2000\n- Still not ready and disabled in code\n- Have progressive loading policy split into progressive loading policies so that a policy can be specified per `TIPImageType`\n- This will allow us to hone our policy for JPEG-2000 separately from PJPEG\n\n### 1.3.1\n\n- Fix bug in Progressive Loading logic for PJPEG (could skip scans by mistake)\n- Update unit tests\n\n### 1.3.0\n\n- Add support for GIFs\n- Animated GIFs will automatically be supported and retrieved as `UIImage`s with `images` property\npopulated with the animated frames.  Adding an animated `UIImage` to a `UIImageView` will automatically animate.\n- `TIPImageFetchDelegate` now has a method to optionally have the first frame of an animated image loaded while the remainder of the animated image loads\n- `[TIPImageFetchDelegate tip_imageFetchOperation:didLoadFirstAnimatedImageFrame:progress:]`\n\n### 1.2.5\n\n- Add TIPImageFetchMetrics for encapsulating the information related to an image fetch\n\n### 1.2.1\n\n- Provide ability to inspect TIPImagePipeline (info on all the entries in each cache)\n- Provide mechanism to clear memory and/or disk caches specifically (usefull for debugging)\n\n### 1.2.0\n\n- Split up image fetches into two methods: 1) for constructing the operation and 2) for starting the operation\n- Add ability to discard the delegate of a `TIPImageFetchOperation`\n- Increase sanitization of image identifiers loaded from disk that were hashed (under the covers, so a transparent increase in robustness)\n\n### 1.1.1\n\n- Detect invalid requests and elicit an appropriate error when encountered\n\n### 1.1.0\n\n- Add `TIPImagePipelineObserver`\n\n### 1.0.0 (04/21/2015)\n\n- Initial release\n"
        },
        {
          "name": "COCOAPODS.md",
          "type": "blob",
          "size": 1.7255859375,
          "content": "# CocoaPods\n\n## Basic Integration\n\nTo integrate TIP into your iOS project using CocoaPods, simply add the following to your **Podfile**:\n\n```ruby\ntarget 'MyApp' do\n  pod 'TwitterImagePipeline', '~> 2.25.0'\nend\n```\n\nThen run a `pod install` inside your terminal, or from CocoaPods.app.\n\n## Extended Integration\n\nTIP also has support for two additional codecs that are not included with the default installation:\n\n- WebP (Backwards compatible to iOS 10)\n- MP4\n\nIf you wish to include these codecs, modify your **Podfile** to define the appropriate subspecs like the examples below:\n\n```ruby\ntarget 'MyApp' do\n  pod 'TwitterImagePipeline', '~> 2.25.0', :subspecs => ['WebPCodec/Default']\n\n  pod 'TwitterImagePipeline', '~> 2.25.0', :subspecs => ['WebPCodec/Animated']\n\n  pod 'TwitterImagePipeline', '~> 2.25.0', :subspecs => ['MP4Codec']\n\n  pod 'TwitterImagePipeline', '~> 2.25.0', :subspecs => ['WebPCodec/Animated', 'MP4']\nend\n```\n\n- **`WebP/Default`**: Includes the `TIPXWebPCodec` with the WebP framework for basic WebP support.\n- **`WebP/Animated`**: Adds additional support to the `TIPXWebPCodec` for demuxing WebP data allowing for animated images.\n- **`MP4Codec`**: Includes the `TIPXMP4Codec`.\n\n**Note:** You are still required to add these codecs to the `TIPImageCodecCatalogue` manually:\n\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    TIPImageCodecCatalogue *codecCatalogue = [TIPImageCodecCatalogue sharedInstance];\n\n    [codecCatalogue setCodec:[[TIPXWebPCodec alloc] initPreservingDefaultCodecsIfPresent:NO]\n                forImageType:TIPImageTypeWEBP];\n\n    [codecCatalogue setCodec:[[TIPMP4Codec alloc] init]\n                forImageType:TIPXImageTypeMP4];\n\n    // ...\n}\n```\n"
        },
        {
          "name": "Extended",
          "type": "tree",
          "content": null
        },
        {
          "name": "GraphicsRendererSpeed",
          "type": "tree",
          "content": null
        },
        {
          "name": "ImageSpeedComparison",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.0029296875,
          "content": "# Twitter Image Pipeline (a.k.a. TIP)\n\n## Background\n\nThe __Twitter Image Pipeline__ is a streamlined framework for _fetching_ and\n_storing_ images in an application.  The high level concept is that all\nrequests to fetch or store an image go through an _image pipeline_ which\nencapsulates the work of checking the _in memory caches_ and an _on disk\ncache_ before retrieving the image from over the _network_ as well as\nkeeping the caches both up to date and pruned.\n\n## Goals and Requirements\n\n_Twitter Image Pipeline_ came to fruition as numerous needs rose out of\nTwitter for iOS use cases.  The system for image loading prior to TIP was\nfragile and inefficient with some severe edge cases.  Designing a new\nframework from the ground up to holistically approach the need for loading\nimages was the best route and led to *TIP*.\n\n- Progressive image loading support (Progressive JPEG)\n  - PJPEG can render progressive scans with a fraction of the bytes needed for the full image\n  - Users can see a 35% to 65% improvement in how soon an image is visible (occasionally even better)\n  - PJPEG images happen to be 10% smaller (on average) than their non-progressive counterparts\n  - PJPEG is hardware decodable on iOS devices, just like non-progressive JPEG images\n- Resumable download support\n  - If an image load is terminated (via failure or cancellation) when an image is partially loaded, the next load of that image should resume from where it left off saving on bytes needing to be transferred\n  - Has a compounding benefit with Progressive JPEG as resuming an image that is partially loaded can render to screen with a progressive scan immediately while remaining bytes can be loaded to improve the quality\n- Support programmatically/manually storing images to the cache(s)\n  - By being able to store images to the underlying cache(s), cases where images are uploaded can have those images in cache at the right location without having to make a fetch.  (Ex// Post a Tweet with an image, that image can be stored to the cache before it is ever seen in the timeline making the timeline's fetch of that image immediate and avoids hitting the network.)\n- Support vending a larger variant when a smaller variant is fetched\n  - By maintaining the largest variant in cache, we can merely scale the image (in the background) and vend that image instead of hitting the network\n- Support vending a smaller variant when a larger variant is fetched\n  - When fetching a larger variant of an image when a smaller variant is in the cache, the smaller variant should be optionally be consumable as the larger variant is loaded over the network\n  - This improves the user experience by providing an image at lower quality while loading the higher quality variant instead of just having an empty/blank UI or placeholder\n- Asynchronous architecture\n  - Using requests to encapsulate _what_ to load, using an operation for executing the asynchronous work, and having a delegate for callbacks we can provide a strong and scalable pattern for image loading\n- Cancellable fetches\n  - When an image fetch is no longer relevant (such as navigating away from an image that hasn't finished loading), we should be permitted to cancel fetches\n  - HTTP/1.1 based fetch downloads that are cancelled will have the negative side effect of tearing down that TCP connection which is expensive to re-establish at the tradeoff of saving on bandwidth and unnecessary network contention with other network requests\n  - HTTP/2 (or SPDY) based fetch downloads will have no negative side effects since the protocol supports midstream cancellation without impacting overall network performance\n- Fast access to cached images\n  - Having the fetch synchronously load already scaled and cached images will keep the UI smooth by avoiding lapses when the image is immediately available\n- Background rendering/scaling/decoding of fetched images\n  - Fetched images need to be decoded and often scaled and even rendered, doing so on a background thread will eliminate framerate drops from trying to do the same expensive work from the main thread\n- Segregated caches / pipelines\n  - By having caches support being segregated, the Twitter app can utilize this segregation to keep caches separate per user account.  On account removal, that account's cache can be cleared without affecting other account caches.\n- Image fetch hydration support\n  - Certain image fetches will require the fetch to sign the request to be loaded over the network, having support for a hydration step will enable this with \"pull\" based pattern vs a \"push\" based pattern that would require applying any such request construct up front.\n- Support for custom networking to execute the downloading of images.\n  - Twitter has strict requirements to have all networking go through its network layer and as such *TIP* has abstracted out networking so that any network layer can be plugged in via the abstraction interface for downloads.\n  - An NSURLSession based download plugin is used by default, but consumers can plug in whatever network layer they desire.\n- Support any image codec desired\n  - By default, all ImageIO supported image types are supported\n  - A plugin architecture supports custom codecs for encoding and/or decoding images in TIP\n  - Use cases include WebP support, or any custom decoding support such as JPEG decoding with a shared quantization table and/or header, or even applying some visual transform (like a blur) as a part of the rendering\n\n## Architecture\n\n### Caches\n\nThere are 3 separate caches for each _image pipeline_: the rendered in-memory cache,\nthe image data in-memory cache, and the on-disk cache.  Entries in the caches are keyed by an _image identifier_\nwhich is provided by the creator of the fetch request or automatically generated from the image fetch's URL.\n\n- The _On-Disk Cache_ will maintain both the latest partial image and the largest completed image for an _image identifier_\n- The _Image Data In-Memory Cache_ will maintain the largest matching image data (based on the image identifier), but is not decoded\n- The _Rendered In-Memory Cache_ will maintain the 3 most recently sized and rendered/decoded UIImages that match (based on the image identifier)\n\nThe image will simultaneously be loaded into memory (as raw bytes) and\nwritten to the disk cache when retrieving from the Network.  Partial images\nwill be persisted as well and not replace any completed images in the cache.\n\nOnce the image is either retrieved from any of the caches or the\nnetwork, the retrieved image will percolate back through the caches in its\nvarious forms.\n\nCaches will be configurable at a global level to have maximum size.  This\nmaximum will be enforced across all image pipeline cache's of the same kind,\nand be maintained with the combination of time-to-live (TTL) expiration and\nleast-recently-used (LRU) purging.  (This solves the long standing issue for\nthe Twitter iOS app of having an unbounded cache that could consume\nGigabytes of disk space).\n\n\n### Execution\n\nThe architecture behind the fetch operation is rather straightforward and\nstreamlined into a pipeline (hence, \"_image pipeline_\").\n\nWhen the request is made, the fetch operation will perform the following:\n\n- Synchronously consult the _Rendered In-Memory Cache_ for an image that will fit the target dimensions and content mode.\n- On miss, asynchronously consult the _Image Data In-Memory Cache_ that holds the image of the largest matching image (based on identifier).\n- On miss, asynchronously consult the _On-Disk Cache_ that maintains the image data of the largest matching image (based on identifier).  As an optimization, *TIP* will take it a step further and also consult all other registered _pipeline disk caches_ - thus saving on the cost of network load by pulling from disk. The cross pipeline retrieved image will be stored to the fetching pipeline's caches to maintain image pipeline siloing.  _Note:_ this cross pipeline access requires the fetching image identifier and image URL to match.\n- On miss, asynchronously consult any provided _additional caches_ (based on URL).  This is so that legacy caches can be pulled from when transitioning to *TIP* without having to forcibly load all assets again.\n- On miss, asynchronously retrieve the image from the _Network_, resuming any partially loaded data that may exist in the _On-Disk Cache_.\n\n### Preview Support\n\nIn addition to this simple progression, the fetch operation will offer the first matching\n(based on image identifier) complete image in the In-Memory Cache or On-Disk Cache\n(rendered and sized to the request's specified target sizing) as a preview image when the URLs\ndon't match.  At that point, the fetch delegate can choose to just use the preview image or continue\nwith the _Network_ loading the final image.  This is particularly useful when the fetch image URL is\nfor a smaller image than the image in cache, no need to hit the network :)\n\n### Progressive Support\n\nA great value that the _image pipeline_ offers is the ability to stream progressive scans of an\nimage, if it is PJPEG, as the image is loaded from the Network.  This progressive rendering is\nnatively supported by iOS 8+, the OS minimum for *TIP* is now iOS 10+.\nProgressive support is opt-in and also configurable in how scans should load.\n\n### Resuming Image Downloads\n\nAs already mentioned, by persisting the partial load of an image to the _On-Disk Cache_, we are able\nto support resumable downloads.  This requires no interface either, it's just a part of how the\nimage pipeline works.\n\n### Rendering to Target Sizing\n\nAs of 2.20, the _image pipeline_ will load the image from data to the specified target sizing of the fetch request,\nwhich avoids the overhead of loading the entire image into a large bitmap just to scale it down to the correct size.\nIf the target sizing is larger than the image data, it will load that image bitmap and scale it up to the target sizing\nspecified by the fetch request.  If a request does not provide target sizing (or the sizing indicates to not resize),\nit will yield the full size image, as one would expect.\n\n## Twitter Image Pipeline features\n\n- Fetching\n    - Progress reporting\n    - Customizable progressive loading policies\n    - Preview loading with option to avoid continuing to load\n    - Placeholder support (for non-canonical images that get purged)\n    - Automatic scaling to target view's size\n    - Custom caching uptions\n    - Customizable set of loading sources (caches and network)\n    - NSOperation based\n        - Cancellable\n        - Priority support\n        - Dependency chain support\n    - Delegate pattern (for robust support)\n    - Block callback pattern (for simple use cases)\n- Storing\n    - Manual storage support (UIImage, NSData or file on disk)\n    - Manual purging support\n    - Dependency chain support (like NSOperation)\n- Caching\n    - Synchronous/fast cache for rendered images\n    - Async memory cache for image data\n    - Async disk cache for image data\n    - Automatic LRU purging\n    - Automatic TTL purging\n    - Siloed caches (via multiple `TIPImagePipeline` instances)\n    - Support for loading from additional non-TIP caches (helps with migration)\n    - Expose method to copy disk cache images directly\n- Downloads\n    - Coalescing image downloads\n    - Image download resumption support built in\n        - Image response \"Accept-Ranges\" must be \"bytes\" and have \"Last-Modified\" header\n        - Uses \"Range\" and \"If-Range\" headers to specify continuation\n    - Pluggable networking (use your own network layer)\n        - Check out how to integrate [Twitter Network Layer](https://github.com/twitter/ios-twitter-network-layer) as your pluggable downloader with this [gist](https://gist.github.com/NSProgrammer/6e4c93ca9b9518178c9cbc7d950efd9c)\n    - Custom hydration (useful for authenticated fetches)\n- Detailed insights\n    - Global pipeline observability\n    - Individual pipeline observability\n    - Global problem observability (non-fatal problems for monitoring)\n    - Asserts can be enabled/disabled\n    - Pluggable logging\n    - Inspectable (can inspect each pipeline's entries)\n    - Robust errors\n    - Detailed metrics on fetch operation completion\n- Robust image support\n    - Pluggable codecs (can add WebP or other image codecs)\n    - Can serialize access to CGContext\n    - UIImage convenience methods\n    - Animated image support (GIFs, by default)\n- UIKit integration\n    - Dedicated helper object decoupling logic from views w/ `TIPImageViewFetchHelper`\n    - Fetch helper offers useful fetch behavior encapsulation\n    - Debug overlay feature to see debug details of the image view\n    - `UIImageView` category for convenient pairing with a `TIPImageViewFetchHelper`\n- Configurable\n    - caches sizes (both in bytes and image count)\n    - max cache entry size\n    - max time for detached download\n    - max concurrent downloads\n\n\n## Components of the Twitter Image Pipeline\n\n- `TIPGlobalConfiguration`\n  - The global configuration for *TIP*\n  - Configure/modify this configuration to adjust *TIP* behavior for your needs\n- `TIPImagePipeline`\n  - the pipeline for fetching images from and storing images to\n  - multiple pipelines can exist providing segregation by use case\n  - a fetch operation is constructed by providing a _request_ (`TIPImageFetchRequest`) with a delegate (`TIPImageFetchDelegate`) or completion block (`TIPImagePipelineFetchCompletionBlock`) to a desired pipeline.  The operation can then be provided to that same pipeline to start the fetching.  This two step approach is necessary to support both synchronous and asynchronous loading while incurring minimal burden on the developer.\n- `TIPImageFetchRequest`\n  - the protocol that encapsulates the information necessary for retrieving an image\n- `TIPImageFetchDelegate`\n  - the delegate for dealing with dynamic decisions and event callbacks\n- `TIPImageFetchOperation`\n  - the `NSOperation` that executes the request and provides a handle to the operation\n  - the operation maintains the state of the fetch's progress as it executes\n  - the operation offers several features:\n    - cancelability\n    - dependency support\n    - prioritization (can be mutated at any time)\n    - a unique reference for distinguishing between operations\n- `TIPImageStoreRequest`\n  - the protocol that encapsulates the information necessary for programmatically storing an image\n- `TIPImageContainer`\n  - object to encapsulate the relevant info for a fetched image\n  - the `TIPImageFetchDelegate` will use `TIPImageContainer` instances for callbacks, and the `TIPImageFetchOperation` will maintain `TIPImageFetchOperation` properties as it progresses.\n- `TIPImageViewFetchHelper`\n  - powerful class that can encapsulate the majority of use cases for loading an image and displaying it in a `UIImageView`\n  - 99% of image loading and displaying use cases can be solved by using this class, configuring it and providing a delegate and/or data source\n  - having the logic in this class avoid coupling _controller_ code with _view_ code in the _MVC_ practice\n- `UIView(TIPImageFetchable)` and `UIImageView(TIPImageFetchable)`\n  - convenience categories on `UIImageView` and `UIView` for associating a `TIPImageViewFetchHelper`\n\n## Usage\n\nThe simplest way to use *TIP* is with the `TIPImageViewHelper` counterpart.\n\nFor concrete coding samples, look at the *TIP Sample App* and *TIP Swift Sample App* (in Objective-C and Swift, respectively).\n\nHere's a simple example of using *TIP* with a `UIViewController` that has an array of image views to\npopulate with images.\n\n```\n\n    /* category on TIPImagePipeline */\n\n    + (TIPImagePipeline *)my_imagePipeline\n    {\n        static TIPImagePipeline *sPipeline;\n        static dispatch_once_t sOnceToken;\n        dispatch_once(&sOnceToken, ^{\n            sPipeline = [[TIPImagePipeline alloc] initWithIdentifier:@\"com.my.app.image.pipeline\"];\n\n            // support looking in legacy cache before hitting the network\n            sPipeline.additionalCaches = @[ [MyLegacyCache sharedInstance] ];\n        });\n        return sPipeline;\n    }\n\n    // ...\n\n    /* in a UIViewController */\n\n    - (void)viewDidLayoutSubviews\n    {\n        [super viewDidLayoutSubviews];\n\n        if (nil == self.view.window) {\n            // not visible\n            return;\n        }\n\n        [_imageFetchOperations makeAllObjectsPerformSelector:@selector(cancelAndDiscardDelegate)];\n        [_imageFetchOperations removeAllObjects];\n\n        TIPImagePipeline *pipeline = [TIPImagePipeline my_imagePipeline];\n        for (NSInteger imageIndex = 0; imageIndex < self.imageViewCount; imageIndex++) {\n            UIImageView *imageView = _imageView[imageIndex];\n            imageView.image = nil;\n            id<TIPImageFetchRequest> request = [self _my_imageFetchRequestForIndex:imageIndex];\n\n            TIPImageFetchOperation *op = [pipeline operationWithRequest:request context:@(imageIndex) delegate:self];\n\n            // fetch can complete sync or async, so we need to hold the reference BEFORE\n            // triggering the fetch (in case it completes sync and will clear the ref)\n            [_imageFetchOperations addObject:op];\n            [[TIPImagePipeline my_imagePipeline] fetchImageWithOperation:op];\n        }\n    }\n\n    - (id<TIPImageFetchRequest>)_my_imageFetchRequestForIndex:(NSInteger)index\n    {\n        NSAssert(index < self.imageViewCount);\n\n        UIImageView *imageView = _imageViews[index];\n        MyImageModel *model = _imageModels[index];\n\n        MyImageFetchRequest *request = [[MyImageFetchRequest alloc] init];\n        request.imageURL = model.thumbnailImageURL;\n        request.imageIdentifier = model.imageURL.absoluteString; // shared identifier between image and thumbnail\n        request.targetDimensions = TIPDimensionsFromView(imageViews);\n        request.targetContentMode = imageView.contentMode;\n\n        return request;\n    }\n\n    /* delegate methods */\n\n    - (void)tip_imageFetchOperation:(TIPImageFetchOperation *)op\n                didLoadPreviewImage:(id<TIPImageFetchResult>)previewResult\n                         completion:(TIPImageFetchDidLoadPreviewCallback)completion\n    {\n        TIPImageContainer *imageContainer = previewResult.imageContainer;\n        NSInteger idx = [op.context integerValue];\n        UIImageView *imageView = _imageViews[idx];\n        imageView.image = imageContainer.image;\n\n        if ((imageContainer.dimension.width * imageContainer.dimensions.height) >= (originalDimensions.width * originalDimensions.height)) {\n            // scaled down, preview is plenty\n            completion(TIPImageFetchPreviewLoadedBehaviorStopLoading);\n        } else {\n            completion(TIPImageFetchPreviewLoadedBehaviorContinueLoading);\n        }\n    }\n\n    - (BOOL)tip_imageFetchOperation:(TIPImageFetchOperation *)op\n    shouldLoadProgressivelyWithIdentifier:(NSString *)identifier\n                                URL:(NSURL *)URL\n                          imageType:(NSString *)imageType\n                 originalDimensions:(CGSize)originalDimensions\n    {\n        // only load progressively if we didn't load a \"preview\"\n        return (nil == op.previewImageContainer);\n    }\n\n    - (void)tip_imageFetchOperation:(TIPImageFetchOperation *)op\n          didUpdateProgressiveImage:(id<TIPImageFetchResult>)progressiveResult\n                           progress:(float)progress\n    {\n        NSInteger idx = [op.context integerValue];\n        UIImageView *imageView = _imageViews[idx];\n        imageView.image = progressiveResult.imageContainer.image;\n    }\n\n    - (void)tip_imageFetchOperation:(TIPImageFetchOperation *)op\n                  didLoadFinalImage:(id<TIPImageFetchResult>)finalResult\n    {\n        NSInteger idx = [op.context integerValue];\n        UIImageView *imageView = _imageViews[idx];\n        imageView.image = finalResult.imageContainer.image;\n\n        [_imageFetchOperations removeObject:op];\n    }\n\n    - (void)tip_imageFetchOperation:(TIPImageFetchOperation *)op\n            didFailToLoadFinalImage:(NSError *)error\n    {\n        NSInteger idx = [op.context integerValue];\n        UIImageView *imageView = _imageViews[idx];\n        if (!imageView.image) {\n            imageView.image = MyAppImageLoadFailedPlaceholderImage();\n        }\n\n        NSLog(@\"-[%@ %@]: %@\", NSStringFromClass([self class]), NSStringFromSelector(_cmd), error);\n        [_imageFetchOperations removeObject:op];\n    }\n\n```\n\n## Inspecting Image Pipelines\n\n_Twitter Image Pipeline_ has built in support for inspecting the caches via convenience categories.\n`TIPGlobalConfiguration` has an `inspect:` method that will inspect all registered\n`TIPImagePipeline` instances (even if they have not been explicitely loaded) and will provide\ndetailed results for those caches and the images there-in.  You can also call `inspect:` on a\nspecific `TIPImagePipeline` instance to be provided detailed info for that specific pipeline.\nInspecting pipelines is asynchronously done on background threads before the inspection callback is\ncalled on the main thread.  This can provide very useful debugging info.  As an example, Twitter has\nbuilt in UI and tools that use the inspection support of *TIP* for internal builds.\n\n# License\n\nCopyright 2015-2020 Twitter, Inc.\n\nLicensed under the Apache License, Version 2.0: https://www.apache.org/licenses/LICENSE-2.0\n\n# Security Issues?\n\nPlease report sensitive security issues via Twitter's bug-bounty program (https://hackerone.com/twitter) rather than GitHub.\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "TIP Sample App",
          "type": "tree",
          "content": null
        },
        {
          "name": "TIP Swift Sample App",
          "type": "tree",
          "content": null
        },
        {
          "name": "TIPTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TIPTestsResources.bundle",
          "type": "tree",
          "content": null
        },
        {
          "name": "TwitterImagePipeline.podspec",
          "type": "blob",
          "size": 1.83984375,
          "content": "Pod::Spec.new do |s|\n  s.name             = 'TwitterImagePipeline'\n  s.version          = '2.25.0'\n  s.compiler_flags   = '-DTIP_PROJECT_VERSION=2.25'\n  s.summary          = 'Twitter Image Pipeline is a robust and performant image loading and caching framework for iOS'\n  s.description      = 'Twitter created a framework for image loading/caching in order to fulfill the numerous needs of Twitter for iOS including being fast, safe, modular and versatile.'\n  s.homepage         = 'https://github.com/twitter/ios-twitter-image-pipeline'\n  s.license          = { :type => 'Apache License, Version 2.0', :file => 'LICENSE' }\n  s.author           = { 'Twitter' => 'opensource@twitter.com' }\n  s.source           = { :git => 'https://github.com/twitter/ios-twitter-image-pipeline.git', :tag => s.version.to_s }\n  s.ios.deployment_target = '10.0'\n  s.swift_versions   = [ 5.0 ]\n\n  s.subspec 'Default' do |sp|\n    sp.source_files = 'TwitterImagePipeline/**/*.{h,m}'\n    sp.public_header_files = 'TwitterImagePipeline/*.h'\n  end\n\n  s.subspec 'WebPCodec' do |sp|\n    sp.subspec 'Default' do |ssp|\n      ssp.source_files = 'Extended/TIPXWebPCodec.{h,m}', 'Extended/TIPXUtils.{h,m}'\n      ssp.public_header_files = 'Extended/TIPXWebPCodec.h'\n      ssp.vendored_frameworks = 'Extended/WebP.framework'\n      ssp.dependency 'TwitterImagePipeline/Default'\n    end\n\n    sp.subspec 'Animated' do |ssp|\n      ssp.xcconfig = { 'GCC_PREPROCESSOR_DEFINITIONS' => 'TIPX_WEBP_ANIMATION_DECODING_ENABLED=1' }\n      ssp.vendored_frameworks = 'Extended/WebPDemux.framework'\n      ssp.dependency 'TwitterImagePipeline/WebPCodec/Default'\n    end\n  end\n\n  s.subspec 'MP4Codec' do |sp|\n    sp.source_files = 'Extended/TIPXMP4Codec.{h,m}', 'Extended/TIPXUtils.{h,m}'\n    sp.public_header_files = 'Extended/TIPXMP4Codec.h'\n    sp.dependency 'TwitterImagePipeline/Default'\n  end\n\n  s.default_subspec = 'Default'\nend\n"
        },
        {
          "name": "TwitterImagePipeline.xcodeproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "TwitterImagePipeline",
          "type": "tree",
          "content": null
        },
        {
          "name": "TwitterImagePipelineTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.5908203125,
          "content": "#!/bin/sh\n\nset -eu\n\nfunction ci_lib() {\n    NAME=$1\n    xcodebuild -project TwitterImagePipeline.xcodeproj \\\n               -scheme \"TwitterImagePipeline.framework\" \\\n               -destination \"platform=iOS Simulator,name=${NAME}\" \\\n               -sdk iphonesimulator \\\n               build test\n}\n\nfunction ci_demo() {\n    NAME=$1\n    xcodebuild -project TwitterImagePipeline.xcodeproj \\\n               -scheme \"TIP Sample App\" \\\n               -destination \"platform=iOS Simulator,name=${NAME}\" \\\n               -sdk iphonesimulator \\\n               build\n}\n\n\nci_lib \"iPhone 8\" && ci_demo \"iPhone 8\"\n"
        },
        {
          "name": "placeholder.jpg",
          "type": "blob",
          "size": 5.4775390625,
          "content": null
        },
        {
          "name": "webp",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}